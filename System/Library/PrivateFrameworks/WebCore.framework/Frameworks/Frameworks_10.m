uint64_t cricket::StunMessage::CreateNew(cricket::StunMessage *this)
{
  uint64_t result;

  result = operator new();
  *(_QWORD *)result = &off_24C0C1470;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(_BYTE *)(result + 63) = 16;
  if (result + 40 <= (unint64_t)"0000000000000000" && result + 56 > (unint64_t)"0000000000000000")
  {
    __break(1u);
  }
  else
  {
    strcpy((char *)(result + 40), "0000000000000000");
    *(_QWORD *)(result + 64) = 0x2112A44200000000;
    *(_QWORD *)(result + 112) = 0;
    *(_QWORD *)(result + 120) = 0;
    *(_QWORD *)(result + 104) = 0;
    *(_QWORD *)(result + 80) = 0;
    *(_QWORD *)(result + 88) = 0;
    *(_QWORD *)(result + 72) = 0;
    *(_DWORD *)(result + 96) = 0;
  }
  return result;
}

uint64_t cricket::StunMessage::GetAttributeValueType(cricket::StunMessage *this, int a2)
{
  uint64_t result;

  result = 1;
  if (a2 > 32802)
  {
    if (a2 <= 49239)
    {
      if (a2 != 32803)
      {
        if (a2 == 32808)
          return 3;
        else
          return 0;
      }
    }
    else
    {
      switch(a2)
      {
        case 49240:
        case 49244:
LABEL_13:
          result = 5;
          break;
        case 49241:
LABEL_6:
          result = 7;
          break;
        case 49242:
        case 49243:
          return 0;
        case 49245:
          result = 4;
          break;
        default:
          if (a2 == 65280)
            return 3;
          return 0;
      }
    }
  }
  else
  {
    switch(a2)
    {
      case 1:
        return result;
      case 2:
      case 3:
      case 4:
      case 5:
      case 7:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
        return 0;
      case 6:
      case 8:
      case 20:
      case 21:
        goto LABEL_13;
      case 9:
        result = 6;
        break;
      case 10:
        goto LABEL_6;
      case 32:
        result = 2;
        break;
      default:
        if (a2 == 32802)
          goto LABEL_13;
        return 0;
    }
  }
  return result;
}

uint64_t cricket::StunAttribute::Create(int a1, __int16 a2, __int16 a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  void (**v10)(cricket::StunUInt64Attribute *__hidden);
  uint64_t v11;
  _QWORD *v12;

  switch(a1)
  {
    case 1:
      result = operator new();
      *(_WORD *)(result + 8) = a2;
      *(_WORD *)(result + 10) = a3;
      *(_QWORD *)result = off_24C0C14A0;
      *(_QWORD *)(result + 16) = 0;
      *(_QWORD *)(result + 24) = 0;
      *(_QWORD *)(result + 32) = 0;
      *(_QWORD *)(result + 40) = &unk_24C0ACDA0;
      *(_BYTE *)(result + 80) = 0;
      *(_WORD *)(result + 72) = 0;
      *(_DWORD *)(result + 76) = 0;
      *(_QWORD *)(result + 48) = 0;
      *(_QWORD *)(result + 56) = 0;
      *(_DWORD *)(result + 64) = 0;
      break;
    case 2:
      result = operator new();
      *(_WORD *)(result + 8) = a2;
      *(_WORD *)(result + 10) = a3;
      *(_QWORD *)(result + 16) = 0;
      *(_QWORD *)(result + 24) = 0;
      *(_QWORD *)(result + 32) = 0;
      *(_QWORD *)(result + 40) = &unk_24C0ACDA0;
      *(_BYTE *)(result + 80) = 0;
      *(_WORD *)(result + 72) = 0;
      *(_DWORD *)(result + 76) = 0;
      *(_QWORD *)(result + 48) = 0;
      *(_QWORD *)(result + 56) = 0;
      *(_DWORD *)(result + 64) = 0;
      *(_QWORD *)result = off_24C0C14E0;
      *(_QWORD *)(result + 88) = a4;
      break;
    case 3:
      result = operator new();
      *(_WORD *)(result + 8) = a2;
      *(_WORD *)(result + 10) = 4;
      *(_QWORD *)result = &off_24C0C1520;
      *(_DWORD *)(result + 12) = 0;
      break;
    case 4:
      v8 = operator new();
      v9 = v8;
      *(_WORD *)(v8 + 8) = a2;
      *(_WORD *)(v8 + 10) = 8;
      v10 = &off_24C0C1560;
      goto LABEL_8;
    case 5:
      v8 = operator new();
      v9 = v8;
      *(_WORD *)(v8 + 8) = a2;
      *(_WORD *)(v8 + 10) = a3;
      v10 = &off_24C0C15A0;
LABEL_8:
      *(_QWORD *)v8 = v10;
      *(_QWORD *)(v8 + 16) = 0;
      result = v9;
      break;
    case 6:
      result = operator new();
      *(_WORD *)(result + 8) = a2;
      *(_WORD *)(result + 10) = a3;
      *(_QWORD *)result = off_24C0C15E0;
      *(_WORD *)(result + 12) = 0;
      *(_QWORD *)(result + 24) = 0;
      *(_QWORD *)(result + 32) = 0;
      *(_QWORD *)(result + 16) = 0;
      break;
    case 7:
      v11 = operator new();
      *(_WORD *)(v11 + 8) = a2;
      *(_WORD *)(v11 + 10) = a3;
      *(_QWORD *)v11 = &off_24C0C1620;
      v12 = (_QWORD *)operator new();
      v12[1] = 0;
      v12[2] = 0;
      *v12 = 0;
      *(_QWORD *)(v11 + 16) = v12;
      result = v11;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t cricket::StunMessage::EqualAttributes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  cricket::StunAddressAttribute *v23;
  const rtc::SocketAddress *v24;
  __int128 v25;
  void *__s2;
  size_t __n[2];
  void *__s1;
  int v29;

  __s1 = (void *)operator new[]();
  *(_OWORD *)__n = xmmword_208F070B0;
  v6 = (void *)operator new[]();
  v7 = *(uint64_t **)(a1 + 8);
  v8 = *(uint64_t **)(a1 + 16);
  __s2 = v6;
  v25 = xmmword_208F070B0;
  while (v7 != v8)
  {
    v29 = *(unsigned __int16 *)(*v7 + 8);
    v9 = *(_QWORD *)(a3 + 24);
    if (!v9)
    {
LABEL_29:
      v23 = (cricket::StunAddressAttribute *)std::__throw_bad_function_call[abi:sn180100]();
      return cricket::StunAddressAttribute::SetAddress(v23, v24);
    }
    if ((*(unsigned int (**)(uint64_t, int *))(*(_QWORD *)v9 + 48))(v9, &v29))
    {
      v10 = *(uint64_t **)(a2 + 8);
      v11 = *(uint64_t **)(a2 + 16);
      if (v10 == v11)
        goto LABEL_22;
      v12 = *v7;
      while (1)
      {
        v13 = *v10;
        if (*(unsigned __int16 *)(*v10 + 8) == *(unsigned __int16 *)(*v7 + 8))
          break;
        if (++v10 == v11)
          goto LABEL_22;
      }
      __n[0] = 0;
      *(_QWORD *)&v25 = 0;
      (*(void (**)(uint64_t, size_t *))(*(_QWORD *)v12 + 40))(v12, __n);
      (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v13 + 40))(v13, &v25);
      if (__n[0] != (_QWORD)v25)
      {
LABEL_22:
        v15 = 0;
        goto LABEL_23;
      }
      v14 = __s2;
      if (memcmp(__s1, __s2, __n[0]))
      {
        v15 = 0;
        goto LABEL_24;
      }
    }
    ++v7;
  }
  v16 = *(_QWORD *)(a2 + 8);
  v17 = *(_QWORD *)(a2 + 16);
  v15 = 1;
  while (v16 != v17)
  {
    v29 = *(unsigned __int16 *)(*(_QWORD *)v16 + 8);
    v18 = *(_QWORD *)(a3 + 24);
    if (!v18)
      goto LABEL_29;
    if ((*(unsigned int (**)(uint64_t, int *))(*(_QWORD *)v18 + 48))(v18, &v29))
    {
      v19 = *(_QWORD *)(a1 + 8);
      v20 = *(_QWORD *)(a1 + 16);
      if (v19 == v20)
        goto LABEL_22;
      while (*(unsigned __int16 *)(*(_QWORD *)v19 + 8) != *(unsigned __int16 *)(*(_QWORD *)v16 + 8))
      {
        v19 += 8;
        if (v19 == v20)
          goto LABEL_22;
      }
    }
    v16 += 8;
  }
LABEL_23:
  v14 = __s2;
LABEL_24:
  __s2 = 0;
  if (v14)
    MEMORY[0x20BD0ADD4](v14, 0x1000C8077774924);
  v21 = __s1;
  __s1 = 0;
  if (v21)
    MEMORY[0x20BD0ADD4](v21, 0x1000C8077774924);
  return v15;
}

std::string *cricket::StunAddressAttribute::SetAddress(cricket::StunAddressAttribute *this, std::string *a2)
{
  const rtc::SocketAddress *v2;
  std::string *result;
  __int128 v5;
  size_t v6;
  int v7;
  __int16 v8;
  __int16 v9;

  v2 = (const rtc::SocketAddress *)a2;
  result = (std::string *)((char *)this + 16);
  if (result != a2)
  {
    if (*((char *)this + 39) < 0)
    {
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v6 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
      }
      else
      {
        a2 = (std::string *)a2->__r_.__value_.__r.__words[0];
        v6 = *((_QWORD *)v2 + 1);
      }
      result = std::string::__assign_no_alias<false>(result, (const std::string::value_type *)a2, v6);
    }
    else if ((*((_BYTE *)&a2->__r_.__value_.__s + 23) & 0x80) != 0)
    {
      result = (std::string *)std::string::__assign_no_alias<true>(result, a2->__r_.__value_.__l.__data_, a2->__r_.__value_.__l.__size_);
    }
    else
    {
      v5 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
      result->__r_.__value_.__r.__words[2] = a2->__r_.__value_.__r.__words[2];
      *(_OWORD *)&result->__r_.__value_.__l.__data_ = v5;
    }
  }
  v7 = *((_DWORD *)v2 + 8);
  *((_DWORD *)this + 12) = v7;
  *(_OWORD *)((char *)this + 52) = *(_OWORD *)((char *)v2 + 36);
  *((_WORD *)this + 36) = *((_WORD *)v2 + 28);
  *((_BYTE *)this + 80) = *((_BYTE *)v2 + 64);
  *((_DWORD *)this + 19) = *((_DWORD *)v2 + 15);
  if (v7 == 30)
    v8 = 20;
  else
    v8 = 0;
  if (v7 == 2)
    v9 = 8;
  else
    v9 = v8;
  *((_WORD *)this + 5) = v9;
  return result;
}

uint64_t cricket::StunAddressAttribute::value_type(cricket::StunAddressAttribute *this)
{
  return 1;
}

uint64_t cricket::StunAddressAttribute::Read(cricket::StunAddressAttribute *this, rtc::ByteBufferReader *a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  __int128 v12;
  std::string __p;
  void *v14;
  int v15;
  __int128 v16;
  __int16 v17;
  int v18;
  char v19;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)a2 + 2);
  v3 = *((_QWORD *)a2 + 3);
  if (v3 == v2)
    return 0;
  *((_QWORD *)a2 + 2) = v2 + 1;
  if (v3 == v2 + 1)
    return 0;
  v4 = *(unsigned __int8 *)(*(_QWORD *)a2 + v2 + 1);
  *((_QWORD *)a2 + 2) = v2 + 2;
  if ((unint64_t)(v3 - (v2 + 2)) < 2)
    return 0;
  v5 = *(_QWORD *)a2;
  v6 = *(unsigned __int16 *)(*(_QWORD *)a2 + v2 + 2);
  v7 = v2 + 4;
  *((_QWORD *)a2 + 2) = v2 + 4;
  v8 = bswap32(v6) >> 16;
  if (v4 != 2)
  {
    if (v4 == 1)
    {
      v9 = 0;
      if (*((_WORD *)this + 5) != 8 || (unint64_t)(v3 - v7) < 4)
        return v9;
      v10 = *(_DWORD *)(v5 + v7);
      *((_QWORD *)a2 + 2) = v2 + 8;
      memset(&__p, 0, sizeof(__p));
      v14 = &unk_24C0ACDA0;
      v19 = 0;
      v15 = 2;
      LODWORD(v16) = v10;
      *(_QWORD *)((char *)&v16 + 4) = 0;
      HIDWORD(v16) = 0;
      goto LABEL_14;
    }
    return 0;
  }
  v9 = 0;
  if (*((_WORD *)this + 5) != 20 || (unint64_t)(v3 - v7) < 0x10)
    return v9;
  v20 = *(_OWORD *)(v5 + v7);
  v12 = v20;
  *((_QWORD *)a2 + 2) = v2 + 20;
  memset(&__p, 0, sizeof(__p));
  v14 = &unk_24C0ACDA0;
  v19 = 0;
  v15 = 30;
  v16 = v12;
LABEL_14:
  v18 = 0;
  v17 = v8;
  cricket::StunAddressAttribute::SetAddress(this, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return 1;
}

BOOL cricket::StunAddressAttribute::Write(uint64_t a1, uint64_t a2)
{
  int v2;
  unint64_t v6;
  size_t v7;
  unint64_t v8;
  size_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  size_t v23;
  unint64_t v24;
  size_t v25;
  size_t v26;
  void *v27;
  void *v28;
  uint64_t v29;
  unsigned int v30;
  size_t v31;
  unint64_t v32;
  size_t v33;
  size_t v34;
  void *v35;
  void *v36;
  uint64_t v37;
  int v38;
  int v39;
  size_t v40;
  unint64_t v41;
  unint64_t v42;
  size_t v43;
  void *v44;
  void *v45;
  uint64_t v46;
  __int128 v47;
  unint64_t v48;
  unint64_t v49;
  size_t v50;
  void *v51;
  void *v52;
  uint64_t v53;
  __int128 v56;

  v2 = *(_DWORD *)(a1 + 48);
  if (v2 == 2 || v2 == 30)
  {
    v7 = *(_QWORD *)a2;
    v6 = *(_QWORD *)(a2 + 8);
    v8 = *(_QWORD *)a2 + 1;
    v9 = *(_QWORD *)a2;
    if (v6 < v8)
    {
      if (v6 + (v6 >> 1) <= v8)
        v10 = *(_QWORD *)a2 + 1;
      else
        v10 = v6 + (v6 >> 1);
      v11 = (void *)operator new[]();
      v12 = v11;
      v13 = *(_QWORD *)(a2 + 16);
      if (v13)
      {
        memcpy(v11, *(const void **)(a2 + 16), *(_QWORD *)a2);
        *(_QWORD *)(a2 + 16) = v12;
        MEMORY[0x20BD0ADD4](v13, 0x1000C8077774924);
      }
      else
      {
        *(_QWORD *)(a2 + 16) = v11;
      }
      *(_QWORD *)(a2 + 8) = v10;
      v9 = *(_QWORD *)a2;
    }
    *(_BYTE *)(*(_QWORD *)(a2 + 16) + v9) = 0;
    *(_QWORD *)a2 = v8;
    if (v2 == 2)
      v22 = 1;
    else
      v22 = 2 * (v2 == 30);
    v23 = v7 + 2;
    v24 = *(_QWORD *)(a2 + 8);
    if (v24 < v7 + 2)
    {
      v25 = v24 + (v24 >> 1);
      if (v25 <= v23)
        v26 = v7 + 2;
      else
        v26 = v25;
      v27 = (void *)operator new[]();
      v28 = v27;
      v29 = *(_QWORD *)(a2 + 16);
      if (v29)
      {
        memcpy(v27, *(const void **)(a2 + 16), *(_QWORD *)a2);
        *(_QWORD *)(a2 + 16) = v28;
        MEMORY[0x20BD0ADD4](v29, 0x1000C8077774924);
      }
      else
      {
        *(_QWORD *)(a2 + 16) = v27;
      }
      *(_QWORD *)(a2 + 8) = v26;
      v8 = *(_QWORD *)a2;
    }
    *(_BYTE *)(*(_QWORD *)(a2 + 16) + v8) = v22;
    *(_QWORD *)a2 = v23;
    v30 = *(unsigned __int16 *)(a1 + 72);
    v31 = v7 + 4;
    v32 = *(_QWORD *)(a2 + 8);
    if (v32 < v7 + 4)
    {
      v33 = v32 + (v32 >> 1);
      if (v33 <= v31)
        v34 = v7 + 4;
      else
        v34 = v33;
      v35 = (void *)operator new[]();
      v36 = v35;
      v37 = *(_QWORD *)(a2 + 16);
      if (v37)
      {
        memcpy(v35, *(const void **)(a2 + 16), *(_QWORD *)a2);
        *(_QWORD *)(a2 + 16) = v36;
        MEMORY[0x20BD0ADD4](v37, 0x1000C8077774924);
      }
      else
      {
        *(_QWORD *)(a2 + 16) = v35;
      }
      *(_QWORD *)(a2 + 8) = v34;
      v23 = *(_QWORD *)a2;
    }
    *(_WORD *)(*(_QWORD *)(a2 + 16) + v23) = __rev16(v30);
    *(_QWORD *)a2 = v31;
    v38 = *(_DWORD *)(a1 + 48);
    if (v38 == 30)
    {
      v47 = *(_OWORD *)(a1 + 52);
      v40 = v7 + 20;
      v48 = *(_QWORD *)(a2 + 8);
      if (v48 < v7 + 20)
      {
        v56 = *(_OWORD *)(a1 + 52);
        v49 = v48 + (v48 >> 1);
        if (v49 <= v40)
          v50 = v7 + 20;
        else
          v50 = v49;
        v51 = (void *)operator new[]();
        v52 = v51;
        v53 = *(_QWORD *)(a2 + 16);
        if (v53)
        {
          memcpy(v51, *(const void **)(a2 + 16), *(_QWORD *)a2);
          *(_QWORD *)(a2 + 16) = v52;
          MEMORY[0x20BD0ADD4](v53, 0x1000C8077774924);
        }
        else
        {
          *(_QWORD *)(a2 + 16) = v51;
        }
        *(_QWORD *)(a2 + 8) = v50;
        v31 = *(_QWORD *)a2;
        v47 = v56;
      }
      *(_OWORD *)(*(_QWORD *)(a2 + 16) + v31) = v47;
    }
    else
    {
      if (v38 != 2)
        return v2 == 2 || v2 == 30;
      v39 = *(_DWORD *)(a1 + 52);
      v40 = v7 + 8;
      v41 = *(_QWORD *)(a2 + 8);
      if (v41 < v7 + 8)
      {
        v42 = v41 + (v41 >> 1);
        if (v42 <= v40)
          v43 = v7 + 8;
        else
          v43 = v42;
        v44 = (void *)operator new[]();
        v45 = v44;
        v46 = *(_QWORD *)(a2 + 16);
        if (v46)
        {
          memcpy(v44, *(const void **)(a2 + 16), *(_QWORD *)a2);
          *(_QWORD *)(a2 + 16) = v45;
          MEMORY[0x20BD0ADD4](v46, 0x1000C8077774924);
        }
        else
        {
          *(_QWORD *)(a2 + 16) = v44;
        }
        *(_QWORD *)(a2 + 8) = v43;
        v31 = *(_QWORD *)a2;
      }
      *(_DWORD *)(*(_QWORD *)(a2 + 16) + v31) = v39;
    }
    *(_QWORD *)a2 = v40;
  }
  else
  {
    v14 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>();
    if ((v14 & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/transport/stun.cc");
  }
  return v2 == 2 || v2 == 30;
}

uint64_t cricket::StunXorAddressAttribute::value_type(cricket::StunXorAddressAttribute *this)
{
  return 2;
}

uint64_t cricket::StunXorAddressAttribute::SetOwner(uint64_t this, cricket::StunMessage *a2)
{
  *(_QWORD *)(this + 88) = a2;
  return this;
}

uint64_t cricket::StunXorAddressAttribute::Read(cricket::StunXorAddressAttribute *this, rtc::ByteBufferReader *a2)
{
  uint64_t v3;
  std::string *v4;
  __int16 v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  BOOL v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  _BOOL4 v16;
  int v17;
  char v18;
  __int16 v19;
  void *__p[2];
  uint64_t v22;
  void *v23;
  int v24;
  __int128 v25;
  __int16 v26;
  int v27;
  char v28;

  v3 = cricket::StunAddressAttribute::Read(this, a2);
  if (!(_DWORD)v3)
    return v3;
  v4 = (std::string *)((char *)this + 16);
  v5 = *((_WORD *)this + 36) ^ 0x2112;
  v6 = *((_QWORD *)this + 11);
  if (v6)
  {
    v7 = *((_DWORD *)this + 12);
    v8 = *(_QWORD *)((char *)this + 52);
    if (v7 != 30)
    {
      v9 = v7 == 2;
      v10 = v8 ^ 0x42A41221;
      if (v7 == 2)
        v11 = v10;
      else
        v11 = 0;
      v12 = 0;
      if (v9)
        v13 = 2;
      else
        v13 = 0;
      v6 = 0;
      goto LABEL_19;
    }
    v14 = v6 + 40;
    v15 = *(char *)(v6 + 63);
    if (v15 < 0)
    {
      if (*(_QWORD *)(v6 + 48) != 12)
      {
LABEL_18:
        v11 = 0;
        v12 = 0;
        v13 = 0;
        v6 = 0;
        goto LABEL_19;
      }
      v14 = *(_QWORD *)v14;
    }
    else if (v15 != 12)
    {
      goto LABEL_18;
    }
    v6 = *(_DWORD *)(v14 + 4) ^ *(_QWORD *)((char *)this + 60) | ((unint64_t)(*(_DWORD *)(v14 + 8) ^ HIDWORD(*(_QWORD *)((char *)this + 60))) << 32);
    v12 = (unint64_t)(*(_DWORD *)v14 ^ HIDWORD(v8)) << 32;
    v11 = v8 ^ 0x42A41221;
    v13 = 30;
  }
  else
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
  }
LABEL_19:
  __p[0] = 0;
  __p[1] = 0;
  v22 = 0;
  v23 = &unk_24C0ACDA0;
  v28 = 0;
  v24 = v13;
  *(_QWORD *)&v25 = v12 | v11;
  *((_QWORD *)&v25 + 1) = v6;
  v27 = 0;
  v26 = v5;
  if (v4 == (std::string *)__p)
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
  }
  else if (*((char *)this + 39) < 0)
  {
    std::string::__assign_no_alias<false>(v4, (const std::string::value_type *)__p, 0);
    v13 = v24;
    v5 = v26;
    v18 = v28;
    v17 = v27;
    v16 = v22 < 0;
  }
  else
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 4) = 0;
  }
  *((_DWORD *)this + 12) = v13;
  *(_OWORD *)((char *)this + 52) = v25;
  *((_WORD *)this + 36) = v5;
  *((_BYTE *)this + 80) = v18;
  *((_DWORD *)this + 19) = v17;
  if (v13 == 30)
    v19 = 20;
  else
    v19 = 0;
  if (v13 == 2)
    v19 = 8;
  *((_WORD *)this + 5) = v19;
  if (v16)
    operator delete(__p[0]);
  return v3;
}

uint64_t cricket::StunXorAddressAttribute::Write(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v5;
  uint64_t *v7;
  int v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v18;
  size_t v19;
  unint64_t v20;
  size_t v21;
  unint64_t v22;
  void *v23;
  void *v24;
  uint64_t v25;
  int v26;
  char v27;
  size_t v28;
  unint64_t v29;
  size_t v30;
  size_t v31;
  void *v32;
  void *v33;
  uint64_t v34;
  unsigned int v35;
  size_t v36;
  unint64_t v37;
  size_t v38;
  size_t v39;
  void *v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  size_t v44;
  unint64_t v45;
  unint64_t v46;
  size_t v47;
  void *v48;
  void *v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  size_t v53;
  void *v54;
  void *v55;
  uint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;

  v2 = *(_DWORD *)(a1 + 48);
  if (v2 == 2 || v2 == 30)
  {
    v5 = *(_QWORD *)(a1 + 88);
    if (v5)
    {
      if (v2 == 2)
      {
        v59 = 0;
        LODWORD(v60) = *(_QWORD *)(a1 + 52);
        v58 = 0;
        v19 = *(_QWORD *)a2;
        v18 = *(_QWORD *)(a2 + 8);
        v20 = *(_QWORD *)a2 + 1;
        v21 = *(_QWORD *)a2;
        if (v18 < v20)
        {
LABEL_20:
          if (v18 + (v18 >> 1) <= v20)
            v22 = v20;
          else
            v22 = v18 + (v18 >> 1);
          v23 = (void *)operator new[]();
          v24 = v23;
          v25 = *(_QWORD *)(a2 + 16);
          if (v25)
          {
            memcpy(v23, *(const void **)(a2 + 16), *(_QWORD *)a2);
            *(_QWORD *)(a2 + 16) = v24;
            MEMORY[0x20BD0ADD4](v25, 0x1000C8077774924);
          }
          else
          {
            *(_QWORD *)(a2 + 16) = v23;
          }
          *(_QWORD *)(a2 + 8) = v22;
          v21 = *(_QWORD *)a2;
        }
LABEL_27:
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + v21) = 0;
        *(_QWORD *)a2 = v20;
        v26 = *(_DWORD *)(a1 + 48);
        if (v26 == 2)
          v27 = 1;
        else
          v27 = 2 * (v26 == 30);
        v28 = v19 + 2;
        v29 = *(_QWORD *)(a2 + 8);
        if (v29 < v19 + 2)
        {
          v30 = v29 + (v29 >> 1);
          if (v30 <= v28)
            v31 = v19 + 2;
          else
            v31 = v30;
          v32 = (void *)operator new[]();
          v33 = v32;
          v34 = *(_QWORD *)(a2 + 16);
          if (v34)
          {
            memcpy(v32, *(const void **)(a2 + 16), *(_QWORD *)a2);
            *(_QWORD *)(a2 + 16) = v33;
            MEMORY[0x20BD0ADD4](v34, 0x1000C8077774924);
          }
          else
          {
            *(_QWORD *)(a2 + 16) = v32;
          }
          *(_QWORD *)(a2 + 8) = v31;
          v20 = *(_QWORD *)a2;
        }
        *(_BYTE *)(*(_QWORD *)(a2 + 16) + v20) = v27;
        *(_QWORD *)a2 = v28;
        v35 = *(unsigned __int16 *)(a1 + 72) ^ 0x2112;
        v36 = v19 + 4;
        v37 = *(_QWORD *)(a2 + 8);
        if (v37 < v19 + 4)
        {
          v38 = v37 + (v37 >> 1);
          if (v38 <= v36)
            v39 = v19 + 4;
          else
            v39 = v38;
          v40 = (void *)operator new[]();
          v41 = v40;
          v42 = *(_QWORD *)(a2 + 16);
          if (v42)
          {
            memcpy(v40, *(const void **)(a2 + 16), *(_QWORD *)a2);
            *(_QWORD *)(a2 + 16) = v41;
            MEMORY[0x20BD0ADD4](v42, 0x1000C8077774924);
          }
          else
          {
            *(_QWORD *)(a2 + 16) = v40;
          }
          *(_QWORD *)(a2 + 8) = v39;
          v28 = *(_QWORD *)a2;
        }
        v43 = v60 ^ 0x42A41221;
        *(_WORD *)(*(_QWORD *)(a2 + 16) + v28) = bswap32(v35) >> 16;
        *(_QWORD *)a2 = v36;
        if (v2 == 30)
        {
          v44 = v19 + 20;
          v51 = *(_QWORD *)(a2 + 8);
          if (v51 < v19 + 20)
          {
            v52 = v51 + (v51 >> 1);
            if (v52 <= v44)
              v53 = v19 + 20;
            else
              v53 = v52;
            v54 = (void *)operator new[]();
            v55 = v54;
            v56 = *(_QWORD *)(a2 + 16);
            if (v56)
            {
              memcpy(v54, *(const void **)(a2 + 16), *(_QWORD *)a2);
              *(_QWORD *)(a2 + 16) = v55;
              MEMORY[0x20BD0ADD4](v56, 0x1000C8077774924);
            }
            else
            {
              *(_QWORD *)(a2 + 16) = v54;
            }
            *(_QWORD *)(a2 + 8) = v53;
            v36 = *(_QWORD *)a2;
          }
          v57 = (unint64_t *)(*(_QWORD *)(a2 + 16) + v36);
          *v57 = v58 | v43;
          v57[1] = v59;
        }
        else
        {
          v44 = v19 + 8;
          v45 = *(_QWORD *)(a2 + 8);
          if (v45 < v19 + 8)
          {
            v46 = v45 + (v45 >> 1);
            if (v46 <= v44)
              v47 = v19 + 8;
            else
              v47 = v46;
            v48 = (void *)operator new[]();
            v49 = v48;
            v50 = *(_QWORD *)(a2 + 16);
            if (v50)
            {
              memcpy(v48, *(const void **)(a2 + 16), *(_QWORD *)a2);
              *(_QWORD *)(a2 + 16) = v49;
              MEMORY[0x20BD0ADD4](v50, 0x1000C8077774924);
            }
            else
            {
              *(_QWORD *)(a2 + 16) = v48;
            }
            *(_QWORD *)(a2 + 8) = v47;
            v36 = *(_QWORD *)a2;
          }
          *(_DWORD *)(*(_QWORD *)(a2 + 16) + v36) = v43;
        }
        *(_QWORD *)a2 = v44;
        return 1;
      }
      if (v2 == 30)
      {
        v7 = (uint64_t *)(v5 + 40);
        v8 = *(char *)(v5 + 63);
        if (v8 < 0)
        {
          if (*(_QWORD *)(v5 + 48) == 12)
          {
            v7 = (uint64_t *)*v7;
            goto LABEL_19;
          }
        }
        else if (v8 == 12)
        {
LABEL_19:
          v60 = *(_QWORD *)(a1 + 52);
          v58 = (unint64_t)(*(_DWORD *)v7 ^ HIDWORD(v60)) << 32;
          v59 = *((_DWORD *)v7 + 1) ^ *(_QWORD *)(a1 + 60) | ((unint64_t)(*((_DWORD *)v7 + 2) ^ HIDWORD(*(_QWORD *)(a1 + 60))) << 32);
          v19 = *(_QWORD *)a2;
          v18 = *(_QWORD *)(a2 + 8);
          v20 = *(_QWORD *)a2 + 1;
          v21 = *(_QWORD *)a2;
          if (v18 < v20)
            goto LABEL_20;
          goto LABEL_27;
        }
      }
    }
    return 0;
  }
  v9 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>();
  if ((v9 & 1) != 0)
    return 0;
  rtc::webrtc_logging_impl::Log("\r\t", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/transport/stun.cc");
  return 0;
}

uint64_t cricket::StunUInt32Attribute::value_type(cricket::StunUInt32Attribute *this)
{
  return 3;
}

uint64_t cricket::StunUInt32Attribute::Read(cricket::StunUInt32Attribute *this, rtc::ByteBufferReader *a2)
{
  uint64_t v2;
  unsigned int v3;

  if (*((_WORD *)this + 5) != 4)
    return 0;
  v2 = *((_QWORD *)a2 + 2);
  if ((unint64_t)(*((_QWORD *)a2 + 3) - v2) < 4)
    return 0;
  v3 = *(_DWORD *)(*(_QWORD *)a2 + v2);
  *((_QWORD *)a2 + 2) = v2 + 4;
  *((_DWORD *)this + 3) = bswap32(v3);
  return 1;
}

uint64_t cricket::StunUInt32Attribute::Write(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  size_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;

  v3 = *(_DWORD *)(a1 + 12);
  v4 = *(_QWORD *)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)a2 + 4;
  if (v5 < v6)
  {
    if (v5 + (v5 >> 1) <= v6)
      v7 = *(_QWORD *)a2 + 4;
    else
      v7 = v5 + (v5 >> 1);
    v8 = (void *)operator new[]();
    v9 = v8;
    v10 = *(_QWORD *)(a2 + 16);
    if (v10)
    {
      memcpy(v8, *(const void **)(a2 + 16), *(_QWORD *)a2);
      *(_QWORD *)(a2 + 16) = v9;
      MEMORY[0x20BD0ADD4](v10, 0x1000C8077774924);
    }
    else
    {
      *(_QWORD *)(a2 + 16) = v8;
    }
    *(_QWORD *)(a2 + 8) = v7;
    v4 = *(_QWORD *)a2;
  }
  *(_DWORD *)(*(_QWORD *)(a2 + 16) + v4) = bswap32(v3);
  *(_QWORD *)a2 = v6;
  return 1;
}

uint64_t cricket::StunUInt64Attribute::value_type(cricket::StunUInt64Attribute *this)
{
  return 4;
}

uint64_t cricket::StunUInt64Attribute::Read(cricket::StunUInt64Attribute *this, rtc::ByteBufferReader *a2)
{
  uint64_t v2;
  unint64_t v3;

  if (*((_WORD *)this + 5) != 8)
    return 0;
  v2 = *((_QWORD *)a2 + 2);
  if ((unint64_t)(*((_QWORD *)a2 + 3) - v2) < 8)
    return 0;
  v3 = *(_QWORD *)(*(_QWORD *)a2 + v2);
  *((_QWORD *)a2 + 2) = v2 + 8;
  *((_QWORD *)this + 2) = bswap64(v3);
  return 1;
}

uint64_t cricket::StunUInt64Attribute::Write(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  size_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;

  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)a2 + 8;
  if (v5 < v6)
  {
    if (v5 + (v5 >> 1) <= v6)
      v7 = *(_QWORD *)a2 + 8;
    else
      v7 = v5 + (v5 >> 1);
    v8 = (void *)operator new[]();
    v9 = v8;
    v10 = *(_QWORD *)(a2 + 16);
    if (v10)
    {
      memcpy(v8, *(const void **)(a2 + 16), *(_QWORD *)a2);
      *(_QWORD *)(a2 + 16) = v9;
      MEMORY[0x20BD0ADD4](v10, 0x1000C8077774924);
    }
    else
    {
      *(_QWORD *)(a2 + 16) = v8;
    }
    *(_QWORD *)(a2 + 8) = v7;
    v4 = *(_QWORD *)a2;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 16) + v4) = bswap64(v3);
  *(_QWORD *)a2 = v6;
  return 1;
}

void cricket::StunByteStringAttribute::~StunByteStringAttribute(cricket::StunByteStringAttribute *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_24C0C15A0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    MEMORY[0x20BD0ADD4](v1, 0x1000C8077774924);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_24C0C15A0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    MEMORY[0x20BD0ADD4](v1, 0x1000C8077774924);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t cricket::StunByteStringAttribute::value_type(cricket::StunByteStringAttribute *this)
{
  return 5;
}

uint64_t cricket::StunByteStringAttribute::Read(cricket::StunByteStringAttribute *this, rtc::ByteBufferReader *a2)
{
  void *v4;
  size_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v9;
  uint64_t v10;

  v4 = (void *)operator new[]();
  *((_QWORD *)this + 2) = v4;
  v5 = *((unsigned __int16 *)this + 5);
  if ((_DWORD)v5)
  {
    v6 = *((_QWORD *)a2 + 2);
    v7 = *((_QWORD *)a2 + 3) - v6;
    if (v5 - 1 < v7)
    {
      memcpy(v4, (const void *)(*(_QWORD *)a2 + v6), v5);
      *((_QWORD *)a2 + 2) = v6 + v5;
    }
    if (v7 < v5)
      return 0;
    if ((v5 & 3) != 0)
    {
      v9 = 4 - (v5 & 3);
      v10 = *((_QWORD *)a2 + 2);
      if (*((_QWORD *)a2 + 3) - v10 >= v9)
        *((_QWORD *)a2 + 2) = v10 + v9;
    }
  }
  return 1;
}

uint64_t cricket::StunByteStringAttribute::Write(uint64_t a1, uint64_t a2)
{
  size_t v4;
  const void *v5;
  size_t v6;
  size_t v7;
  size_t v8;
  size_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v14;
  size_t v15;
  size_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  void *v20;
  void *v21;
  uint64_t v22;
  int __src;

  v4 = *(unsigned __int16 *)(a1 + 10);
  switch(*(_WORD *)(a1 + 8))
  {
    case 6:
      if (v4 > 0x1FC)
        return 0;
      goto LABEL_6;
    case 7:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
      goto LABEL_6;
    case 8:
      if ((_DWORD)v4 == 20)
        goto LABEL_9;
      return 0;
    case 0x14:
    case 0x15:
      goto LABEL_5;
    default:
      if (*(unsigned __int16 *)(a1 + 8) != 32802)
        goto LABEL_6;
LABEL_5:
      if (v4 >= 0x1FD)
        return 0;
LABEL_6:
      if (*(_WORD *)(a1 + 10))
      {
LABEL_9:
        v5 = *(const void **)(a1 + 16);
        v6 = *(_QWORD *)a2;
        v7 = *(_QWORD *)(a2 + 8);
        v8 = *(_QWORD *)a2 + v4;
        if (v7 < v8)
        {
          if (v7 + (v7 >> 1) <= v8)
            v9 = *(_QWORD *)a2 + v4;
          else
            v9 = v7 + (v7 >> 1);
          v10 = (void *)operator new[]();
          v11 = v10;
          v12 = *(_QWORD *)(a2 + 16);
          if (v12)
          {
            memcpy(v10, *(const void **)(a2 + 16), *(_QWORD *)a2);
            *(_QWORD *)(a2 + 16) = v11;
            MEMORY[0x20BD0ADD4](v12, 0x1000C8077774924);
          }
          else
          {
            *(_QWORD *)(a2 + 16) = v10;
          }
          *(_QWORD *)(a2 + 8) = v9;
          v6 = *(_QWORD *)a2;
        }
        memcpy((void *)(*(_QWORD *)(a2 + 16) + v6), v5, v4);
        *(_QWORD *)a2 = v8;
        v14 = *(_WORD *)(a1 + 10) & 3;
        if ((*(_WORD *)(a1 + 10) & 3) != 0)
        {
          __src = 0;
          v15 = 4 - v14;
          v16 = v8 + 4 - v14;
          v17 = *(_QWORD *)(a2 + 8);
          if (v17 < v16)
          {
            v18 = v17 + (v17 >> 1);
            if (v18 <= v16)
              v19 = v16;
            else
              v19 = v18;
            v20 = (void *)operator new[]();
            v21 = v20;
            v22 = *(_QWORD *)(a2 + 16);
            if (v22)
            {
              memcpy(v20, *(const void **)(a2 + 16), *(_QWORD *)a2);
              *(_QWORD *)(a2 + 16) = v21;
              MEMORY[0x20BD0ADD4](v22, 0x1000C8077774924);
            }
            else
            {
              *(_QWORD *)(a2 + 16) = v20;
            }
            *(_QWORD *)(a2 + 8) = v19;
            v8 = *(_QWORD *)a2;
          }
          memcpy((void *)(*(_QWORD *)(a2 + 16) + v8), &__src, v15);
          *(_QWORD *)a2 = v16;
        }
      }
      return 1;
  }
}

void cricket::StunErrorCodeAttribute::~StunErrorCodeAttribute(void **this)
{
  *this = off_24C0C15E0;
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
}

{
  *this = off_24C0C15E0;
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t cricket::StunErrorCodeAttribute::value_type(cricket::StunErrorCodeAttribute *this)
{
  return 6;
}

void cricket::StunErrorCodeAttribute::Read(cricket::StunErrorCodeAttribute *this, rtc::ByteBufferReader *a2)
{
  uint64_t v3;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const std::string::value_type *v17;
  uint64_t v18;
  std::string::size_type v19;
  std::string::size_type v20;
  std::string *v21;
  char *v22;
  std::string::size_type v23;
  unint64_t v24;
  unint64_t v25;

  if (*((unsigned __int16 *)this + 5) >= 4u)
  {
    v3 = *((_QWORD *)a2 + 2);
    if ((unint64_t)(*((_QWORD *)a2 + 3) - v3) >= 4)
    {
      v5 = *(_DWORD *)(*(_QWORD *)a2 + v3);
      *((_QWORD *)a2 + 2) = v3 + 4;
      v6 = bswap32(v5);
      if (v6 >= 0x800 && (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v7, v8, v9, v10, v11, v12, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/transport/stun.cc");
      *((_BYTE *)this + 12) = BYTE1(v6) & 7;
      *((_BYTE *)this + 13) = v6;
      v14 = *((unsigned __int16 *)this + 5) - 4;
      v15 = *((_QWORD *)a2 + 2);
      if (*((_QWORD *)a2 + 3) - v15 >= v14)
      {
        v16 = *(_QWORD *)a2;
        if (*((_WORD *)this + 5) == 4 || v16)
        {
          v17 = (const std::string::value_type *)(v16 + v15);
          v18 = *((unsigned __int8 *)this + 39);
          if (*((char *)this + 39) < 0)
          {
            v20 = *((_QWORD *)this + 3);
            v19 = (*((_QWORD *)this + 4) & 0x7FFFFFFFFFFFFFFFLL) - 1;
            v21 = (std::string *)((char *)this + 16);
            if (v19 - v20 < v14)
              goto LABEL_12;
          }
          else
          {
            v19 = 22;
            v20 = *((unsigned __int8 *)this + 39);
            v21 = (std::string *)((char *)this + 16);
            if (22 - v18 < v14)
            {
LABEL_12:
              std::string::__grow_by_and_replace(v21, v19, v14 - v19 + v20, v20, v20, 0, *((unsigned __int16 *)this + 5) - 4, v17);
              goto LABEL_23;
            }
          }
          if (*((_WORD *)this + 5) == 4)
          {
LABEL_23:
            v24 = *((_QWORD *)a2 + 2) + v14;
            *((_QWORD *)a2 + 2) = v24;
            if ((*((_WORD *)this + 5) & 3) != 0)
            {
              v25 = 4 - (*((_WORD *)this + 5) & 3);
              if (*((_QWORD *)a2 + 3) - v24 >= v25)
                *((_QWORD *)a2 + 2) = v24 + v25;
            }
            return;
          }
          if ((v18 & 0x80) != 0)
            v21 = (std::string *)v21->__r_.__value_.__r.__words[0];
          v22 = (char *)v21 + v20;
          if ((char *)v21 + v20 > v17 || &v22[v14] <= v17)
          {
            memmove(v22, v17, *((unsigned __int16 *)this + 5) - 4);
            v23 = v20 + v14;
            if (*((char *)this + 39) < 0)
              *((_QWORD *)this + 3) = v23;
            else
              *((_BYTE *)this + 39) = v23 & 0x7F;
            v21->__r_.__value_.__s.__data_[v23] = 0;
            goto LABEL_23;
          }
        }
        __break(1u);
      }
    }
  }
}

uint64_t cricket::StunErrorCodeAttribute::Write(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  size_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  size_t v12;
  size_t v13;
  size_t v14;
  size_t v15;
  size_t v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  size_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  void *v26;
  void *v27;
  uint64_t v28;
  int __src;

  v3 = result;
  v4 = __rev16(*(unsigned __int16 *)(result + 12));
  v5 = *(_QWORD *)a2;
  v6 = *(_QWORD *)(a2 + 8);
  v7 = *(_QWORD *)a2 + 4;
  if (v6 < v7)
  {
    if (v6 + (v6 >> 1) <= v7)
      v8 = *(_QWORD *)a2 + 4;
    else
      v8 = v6 + (v6 >> 1);
    result = operator new[]();
    v9 = result;
    v10 = *(_QWORD *)(a2 + 16);
    if (v10)
    {
      memcpy((void *)result, *(const void **)(a2 + 16), *(_QWORD *)a2);
      *(_QWORD *)(a2 + 16) = v9;
      result = MEMORY[0x20BD0ADD4](v10, 0x1000C8077774924);
    }
    else
    {
      *(_QWORD *)(a2 + 16) = result;
    }
    *(_QWORD *)(a2 + 8) = v8;
    v5 = *(_QWORD *)a2;
  }
  *(_DWORD *)(*(_QWORD *)(a2 + 16) + v5) = bswap32(v4);
  *(_QWORD *)a2 = v7;
  v11 = (_QWORD *)(v3 + 16);
  if ((*(char *)(v3 + 39) & 0x80000000) == 0)
  {
    v12 = *(unsigned __int8 *)(v3 + 39);
    goto LABEL_14;
  }
  v12 = *(_QWORD *)(v3 + 24);
  if ((v12 & 0x8000000000000000) == 0)
  {
    v11 = (_QWORD *)*v11;
    if (!v12 || v11)
    {
LABEL_14:
      if (v12)
      {
        v13 = v12 + v7;
        v14 = *(_QWORD *)(a2 + 8);
        if (v14 < v12 + v7)
        {
          v15 = v14 + (v14 >> 1);
          if (v15 <= v13)
            v16 = v12 + v7;
          else
            v16 = v15;
          v17 = (void *)operator new[]();
          v18 = v17;
          v19 = *(_QWORD *)(a2 + 16);
          if (v19)
          {
            memcpy(v17, *(const void **)(a2 + 16), *(_QWORD *)a2);
            *(_QWORD *)(a2 + 16) = v18;
            MEMORY[0x20BD0ADD4](v19, 0x1000C8077774924);
          }
          else
          {
            *(_QWORD *)(a2 + 16) = v17;
          }
          *(_QWORD *)(a2 + 8) = v16;
          v7 = *(_QWORD *)a2;
        }
        memcpy((void *)(*(_QWORD *)(a2 + 16) + v7), v11, v12);
        *(_QWORD *)a2 = v13;
        v20 = *(_WORD *)(v3 + 10) & 3;
        if ((*(_WORD *)(v3 + 10) & 3) == 0)
          return 1;
      }
      else
      {
        v13 = v7;
        v20 = *(_WORD *)(v3 + 10) & 3;
        if ((*(_WORD *)(v3 + 10) & 3) == 0)
          return 1;
      }
      __src = 0;
      v21 = 4 - v20;
      v22 = v13 + 4 - v20;
      v23 = *(_QWORD *)(a2 + 8);
      if (v23 < v22)
      {
        v24 = v23 + (v23 >> 1);
        if (v24 <= v22)
          v25 = v22;
        else
          v25 = v24;
        v26 = (void *)operator new[]();
        v27 = v26;
        v28 = *(_QWORD *)(a2 + 16);
        if (v28)
        {
          memcpy(v26, *(const void **)(a2 + 16), *(_QWORD *)a2);
          *(_QWORD *)(a2 + 16) = v27;
          MEMORY[0x20BD0ADD4](v28, 0x1000C8077774924);
        }
        else
        {
          *(_QWORD *)(a2 + 16) = v26;
        }
        *(_QWORD *)(a2 + 8) = v25;
        v13 = *(_QWORD *)a2;
      }
      memcpy((void *)(*(_QWORD *)(a2 + 16) + v13), &__src, v21);
      *(_QWORD *)a2 = v22;
      return 1;
    }
  }
  __break(1u);
  return result;
}

void cricket::StunUInt16ListAttribute::~StunUInt16ListAttribute(cricket::StunUInt16ListAttribute *this)
{
  uint64_t v1;
  void *v2;

  *(_QWORD *)this = &off_24C0C1620;
  v1 = *((_QWORD *)this + 2);
  if (v1)
  {
    v2 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v2;
      operator delete(v2);
    }
    MEMORY[0x20BD0ADEC](v1, 0x10C402FEFCB83);
  }
}

{
  uint64_t v1;
  void *v2;

  *(_QWORD *)this = &off_24C0C1620;
  v1 = *((_QWORD *)this + 2);
  if (v1)
  {
    v2 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v2;
      operator delete(v2);
    }
    MEMORY[0x20BD0ADEC](v1, 0x10C402FEFCB83);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t cricket::StunUInt16ListAttribute::value_type(cricket::StunUInt16ListAttribute *this)
{
  return 7;
}

void cricket::StunUInt16ListAttribute::AddType(cricket::StunUInt16ListAttribute *this, __int16 a2)
{
  uint64_t v4;
  unint64_t v5;
  char *v6;
  char *v7;
  _WORD *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  _WORD *v18;
  char *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  _OWORD *v23;
  char *v24;
  unint64_t v25;
  __int128 v26;
  __int16 v27;

  v4 = *((_QWORD *)this + 2);
  v6 = *(char **)(v4 + 8);
  v5 = *(_QWORD *)(v4 + 16);
  v7 = v6;
  if ((unint64_t)v6 < v5)
  {
    if (v6)
    {
      *(_WORD *)v6 = a2;
      v8 = v6 + 2;
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  v9 = *(char **)v4;
  v10 = (uint64_t)&v6[-*(_QWORD *)v4];
  if (v10 <= -3)
    goto LABEL_23;
  v11 = v10 >> 1;
  v12 = v5 - (_QWORD)v9;
  if (v12 <= (v10 >> 1) + 1)
    v13 = v11 + 1;
  else
    v13 = v12;
  v14 = v12 >= 0x7FFFFFFFFFFFFFFELL;
  v15 = 0x7FFFFFFFFFFFFFFFLL;
  if (!v14)
    v15 = v13;
  if (!v15)
  {
LABEL_22:
    __break(1u);
LABEL_23:
    abort();
  }
  if (v15 < 0)
    std::__throw_bad_array_new_length[abi:sn180100]();
  v16 = 2 * v15;
  v17 = operator new(2 * v15);
  v18 = &v17[2 * v11];
  v19 = &v17[v16];
  *v18 = a2;
  v8 = v18 + 1;
  if (v6 != v9)
  {
    v20 = v6 - v9 - 2;
    if (v20 < 0x1E)
      goto LABEL_27;
    if ((unint64_t)(&v6[-(v10 & 0xFFFFFFFFFFFFFFFELL)] - v17) < 0x20)
      goto LABEL_27;
    v21 = (v20 >> 1) + 1;
    v22 = 2 * (v21 & 0xFFFFFFFFFFFFFFF0);
    v7 = &v6[-v22];
    v18 = (_WORD *)((char *)v18 - v22);
    v23 = &v17[2 * v11 - 16];
    v24 = v6 - 16;
    v25 = v21 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      v26 = *(_OWORD *)v24;
      *(v23 - 1) = *((_OWORD *)v24 - 1);
      *v23 = v26;
      v23 -= 2;
      v24 -= 32;
      v25 -= 16;
    }
    while (v25);
    if (v21 != (v21 & 0xFFFFFFFFFFFFFFF0))
    {
LABEL_27:
      do
      {
        v27 = *((_WORD *)v7 - 1);
        v7 -= 2;
        *--v18 = v27;
      }
      while (v7 != v9);
    }
  }
  *(_QWORD *)v4 = v18;
  *(_QWORD *)(v4 + 8) = v8;
  *(_QWORD *)(v4 + 16) = v19;
  if (v9)
    operator delete(v9);
LABEL_21:
  *(_QWORD *)(v4 + 8) = v8;
  *((_WORD *)this + 5) = (*(_DWORD *)(*((_QWORD *)this + 2) + 8) - **((_DWORD **)this + 2)) & 0xFFFE;
}

uint64_t cricket::StunUInt16ListAttribute::Read(cricket::StunUInt16ListAttribute *this, rtc::ByteBufferReader *a2)
{
  unint64_t v2;
  int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  _WORD *v24;
  _WORD *v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  _OWORD *v30;
  char *v31;
  unint64_t v32;
  __int128 v33;
  __int16 v34;
  unsigned __int16 *v35;

  LODWORD(v2) = *((unsigned __int16 *)this + 5);
  if ((v2 & 1) != 0)
    return 0;
  if (v2 >= 2)
  {
    v8 = 0;
    v35 = (unsigned __int16 *)this;
    while (1)
    {
      v9 = *((_QWORD *)a2 + 2);
      if ((unint64_t)(*((_QWORD *)a2 + 3) - v9) < 2)
        return 0;
      v10 = *(unsigned __int16 *)(*(_QWORD *)a2 + v9);
      *((_QWORD *)a2 + 2) = v9 + 2;
      v11 = bswap32(v10) >> 16;
      v12 = *((_QWORD *)this + 2);
      v14 = *(char **)(v12 + 8);
      v13 = *(_QWORD *)(v12 + 16);
      if ((unint64_t)v14 >= v13)
      {
        v15 = *(char **)v12;
        v16 = (uint64_t)&v14[-*(_QWORD *)v12];
        if (v16 <= -3)
          goto LABEL_33;
        v17 = v16 >> 1;
        v18 = v13 - (_QWORD)v15;
        if (v18 <= (v16 >> 1) + 1)
          v19 = v17 + 1;
        else
          v19 = v18;
        v20 = v18 >= 0x7FFFFFFFFFFFFFFELL;
        v21 = 0x7FFFFFFFFFFFFFFFLL;
        if (!v20)
          v21 = v19;
        if (!v21)
        {
LABEL_32:
          __break(1u);
LABEL_33:
          abort();
        }
        if (v21 < 0)
          std::__throw_bad_array_new_length[abi:sn180100]();
        v22 = 2 * v21;
        v23 = operator new(2 * v21);
        v24 = &v23[2 * v17];
        *v24 = v11;
        v25 = v24 + 1;
        if (v14 != v15)
        {
          v26 = v14 - v15 - 2;
          if (v26 < 0x1E)
            goto LABEL_37;
          if ((unint64_t)(&v14[-(v16 & 0xFFFFFFFFFFFFFFFELL)] - v23) < 0x20)
            goto LABEL_37;
          v27 = (v26 >> 1) + 1;
          v28 = 2 * (v27 & 0xFFFFFFFFFFFFFFF0);
          v29 = &v14[-v28];
          v24 = (_WORD *)((char *)v24 - v28);
          v30 = &v23[2 * v17 - 16];
          v31 = v14 - 16;
          v32 = v27 & 0xFFFFFFFFFFFFFFF0;
          do
          {
            v33 = *(_OWORD *)v31;
            *(v30 - 1) = *((_OWORD *)v31 - 1);
            *v30 = v33;
            v30 -= 2;
            v31 -= 32;
            v32 -= 16;
          }
          while (v32);
          v14 = v29;
          if (v27 != (v27 & 0xFFFFFFFFFFFFFFF0))
          {
LABEL_37:
            do
            {
              v34 = *((_WORD *)v14 - 1);
              v14 -= 2;
              *--v24 = v34;
            }
            while (v14 != v15);
          }
        }
        *(_QWORD *)v12 = v24;
        *(_QWORD *)(v12 + 8) = v25;
        *(_QWORD *)(v12 + 16) = &v23[v22];
        if (v15)
          operator delete(v15);
        this = (cricket::StunUInt16ListAttribute *)v35;
        *(_QWORD *)(v12 + 8) = v25;
        ++v8;
        v2 = v35[5];
        if (v8 >= v2 >> 1)
          break;
      }
      else
      {
        if (!v14)
          goto LABEL_32;
        *(_WORD *)v14 = v11;
        *(_QWORD *)(v12 + 8) = v14 + 2;
        ++v8;
        v2 = *((unsigned __int16 *)this + 5);
        if (v8 >= v2 >> 1)
          break;
      }
    }
  }
  v4 = v2 & 3;
  if (v4)
  {
    v5 = (4 - v4);
    v6 = *((_QWORD *)a2 + 2);
    if (*((_QWORD *)a2 + 3) - v6 >= v5)
      *((_QWORD *)a2 + 2) = v6 + v5;
  }
  return 1;
}

uint64_t cricket::StunUInt16ListAttribute::Write(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  size_t v7;
  uint64_t *v8;
  BOOL v9;
  unsigned int v10;
  size_t v11;
  unint64_t v12;
  unint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  size_t v19;
  size_t v20;
  size_t v21;
  size_t v22;
  void *v23;
  void *v24;
  uint64_t v25;
  int __src;

  v4 = *(uint64_t **)(a1 + 16);
  v5 = *v4;
  if (v4[1] != *v4)
  {
    v6 = 0;
    v7 = *(_QWORD *)a2;
    do
    {
      v10 = *(unsigned __int16 *)(v5 + 2 * v6);
      v11 = v7 + 2;
      v12 = *(_QWORD *)(a2 + 8);
      if (v12 < v7 + 2)
      {
        if (v12 + (v12 >> 1) <= v11)
          v13 = v7 + 2;
        else
          v13 = v12 + (v12 >> 1);
        v14 = (void *)operator new[]();
        v15 = v14;
        v16 = *(_QWORD *)(a2 + 16);
        if (v16)
        {
          memcpy(v14, *(const void **)(a2 + 16), *(_QWORD *)a2);
          *(_QWORD *)(a2 + 16) = v15;
          MEMORY[0x20BD0ADD4](v16, 0x1000C8077774924);
        }
        else
        {
          *(_QWORD *)(a2 + 16) = v14;
        }
        *(_QWORD *)(a2 + 8) = v13;
        v7 = *(_QWORD *)a2;
      }
      *(_WORD *)(*(_QWORD *)(a2 + 16) + v7) = __rev16(v10);
      *(_QWORD *)a2 = v11;
      ++v6;
      v8 = *(uint64_t **)(a1 + 16);
      v5 = *v8;
      v9 = v6 >= (v8[1] - *v8) >> 1;
      v7 = v11;
    }
    while (!v9);
  }
  v17 = *(_WORD *)(a1 + 10) & 3;
  if ((*(_WORD *)(a1 + 10) & 3) != 0)
  {
    __src = 0;
    v18 = 4 - v17;
    v19 = *(_QWORD *)a2;
    v20 = *(_QWORD *)(a2 + 8);
    v21 = *(_QWORD *)a2 + v18;
    if (v20 < v21)
    {
      if (v20 + (v20 >> 1) <= v21)
        v22 = *(_QWORD *)a2 + v18;
      else
        v22 = v20 + (v20 >> 1);
      v23 = (void *)operator new[]();
      v24 = v23;
      v25 = *(_QWORD *)(a2 + 16);
      if (v25)
      {
        memcpy(v23, *(const void **)(a2 + 16), *(_QWORD *)a2);
        *(_QWORD *)(a2 + 16) = v24;
        MEMORY[0x20BD0ADD4](v25, 0x1000C8077774924);
      }
      else
      {
        *(_QWORD *)(a2 + 16) = v23;
      }
      *(_QWORD *)(a2 + 8) = v22;
      v19 = *(_QWORD *)a2;
    }
    memcpy((void *)(*(_QWORD *)(a2 + 16) + v19), &__src, v18);
    *(_QWORD *)a2 = v21;
  }
  return 1;
}

void cricket::StunMethodToString(cricket *this@<X0>, unint64_t a2@<X8>)
{
  char *v3;
  const char *v4;
  const char *v5;
  std::string *v6;
  std::string::size_type v7;
  std::string::size_type size;
  std::string::size_type v9;
  std::string *v10;
  _BYTE *v11;
  std::string::size_type v12;
  char *v13;
  char *v14;
  char *v15;
  const char *v16;
  char *v17;
  char *v18;
  char *v19;
  int v20;
  char *v21;
  char *v22;
  char *v23;
  std::string v24;
  std::string v25;

  if ((int)this <= 511)
  {
    switch((int)this)
    {
      case 257:
        *(_BYTE *)(a2 + 23) = 21;
        v4 = "STUN BINDING response";
        if (a2 > (unint64_t)"STUN BINDING response")
          goto LABEL_60;
        goto LABEL_59;
      case 258:
      case 261:
      case 262:
      case 263:
      case 266:
      case 267:
      case 268:
      case 269:
      case 270:
      case 271:
      case 272:
      case 274:
      case 277:
      case 278:
      case 279:
        goto LABEL_20;
      case 259:
        *(_BYTE *)(a2 + 23) = 22;
        if (a2 <= (unint64_t)"TURN ALLOCATE response" && a2 + 22 > (unint64_t)"TURN ALLOCATE response")
          goto LABEL_83;
        strcpy((char *)a2, "TURN ALLOCATE response");
        return;
      case 260:
        *(_BYTE *)(a2 + 23) = 21;
        v4 = "TURN REFRESH response";
        if (a2 > (unint64_t)"TURN REFRESH response")
          goto LABEL_60;
LABEL_59:
        if (a2 + 21 > (unint64_t)v4)
          goto LABEL_83;
LABEL_60:
        *(_OWORD *)a2 = *(_OWORD *)v4;
        *(_QWORD *)(a2 + 13) = *(_QWORD *)(v4 + 13);
        *(_BYTE *)(a2 + 21) = 0;
        return;
      case 264:
        v13 = (char *)operator new(0x20uLL);
        *(_QWORD *)a2 = v13;
        *(_OWORD *)(a2 + 8) = xmmword_208F05170;
        if (v13 <= "TURN CREATE PERMISSION response" && v13 + 31 > "TURN CREATE PERMISSION response")
          goto LABEL_83;
        strcpy(v13, "TURN CREATE PERMISSION response");
        return;
      case 265:
        v14 = (char *)operator new(0x20uLL);
        *(_QWORD *)a2 = v14;
        *(_OWORD *)(a2 + 8) = xmmword_208F0AC80;
        if (v14 <= "TURN CHANNEL BIND response" && v14 + 26 > "TURN CHANNEL BIND response")
          goto LABEL_83;
        strcpy(v14, "TURN CHANNEL BIND response");
        return;
      case 273:
        v15 = (char *)operator new(0x20uLL);
        *(_QWORD *)a2 = v15;
        *(_OWORD *)(a2 + 8) = xmmword_208F051A0;
        v16 = "STUN BINDING error response";
        if (v15 > "STUN BINDING error response")
          goto LABEL_51;
        goto LABEL_50;
      case 275:
        v17 = (char *)operator new(0x20uLL);
        *(_QWORD *)a2 = v17;
        *(_OWORD *)(a2 + 8) = xmmword_208F05180;
        if (v17 <= "TURN ALLOCATE error response" && v17 + 28 > "TURN ALLOCATE error response")
          goto LABEL_83;
        strcpy(v17, "TURN ALLOCATE error response");
        return;
      case 276:
        v15 = (char *)operator new(0x20uLL);
        *(_QWORD *)a2 = v15;
        *(_OWORD *)(a2 + 8) = xmmword_208F051A0;
        v16 = "TURN REFRESH error response";
        if (v15 > "TURN REFRESH error response")
          goto LABEL_51;
LABEL_50:
        if (v15 + 27 > v16)
          goto LABEL_83;
LABEL_51:
        *(_OWORD *)v15 = *(_OWORD *)v16;
        *(_OWORD *)(v15 + 11) = *(_OWORD *)(v16 + 11);
        v15[27] = 0;
        break;
      case 280:
        v18 = (char *)operator new(0x28uLL);
        *(_QWORD *)a2 = v18;
        *(_OWORD *)(a2 + 8) = xmmword_208F086E0;
        if (v18 <= "TURN CREATE PERMISSION error response" && v18 + 37 > "TURN CREATE PERMISSION error response")
          goto LABEL_83;
        strcpy(v18, "TURN CREATE PERMISSION error response");
        return;
      case 281:
        v19 = (char *)operator new(0x28uLL);
        *(_QWORD *)a2 = v19;
        *(_OWORD *)(a2 + 8) = xmmword_208F04EE0;
        if (v19 <= "TURN CHANNEL BIND error response" && v19 + 32 > "TURN CHANNEL BIND error response")
          goto LABEL_83;
        strcpy(v19, "TURN CHANNEL BIND error response");
        return;
      default:
        switch((int)this)
        {
          case 1:
            *(_BYTE *)(a2 + 23) = 20;
            v5 = "STUN BINDING request";
            if (a2 > (unint64_t)"STUN BINDING request")
              goto LABEL_63;
            goto LABEL_62;
          case 3:
            *(_BYTE *)(a2 + 23) = 21;
            v4 = "TURN ALLOCATE request";
            if (a2 <= (unint64_t)"TURN ALLOCATE request")
              goto LABEL_59;
            goto LABEL_60;
          case 4:
            *(_BYTE *)(a2 + 23) = 20;
            v5 = "TURN REFRESH request";
            if (a2 > (unint64_t)"TURN REFRESH request")
              goto LABEL_63;
LABEL_62:
            if (a2 + 20 > (unint64_t)v5)
              goto LABEL_83;
LABEL_63:
            v20 = 1953719669;
            goto LABEL_78;
          case 8:
            v21 = (char *)operator new(0x20uLL);
            *(_QWORD *)a2 = v21;
            *(_OWORD *)(a2 + 8) = xmmword_208F05710;
            if (v21 <= "TURN CREATE PERMISSION request" && v21 + 30 > "TURN CREATE PERMISSION request")
              goto LABEL_83;
            strcpy(v21, "TURN CREATE PERMISSION request");
            return;
          case 9:
            v22 = (char *)operator new(0x20uLL);
            *(_QWORD *)a2 = v22;
            *(_OWORD *)(a2 + 8) = xmmword_208F05150;
            if (v22 <= "TURN CHANNEL BIND request" && v22 + 25 > "TURN CHANNEL BIND request")
              goto LABEL_83;
            strcpy(v22, "TURN CHANNEL BIND request");
            return;
          case 17:
            v23 = (char *)operator new(0x19uLL);
            *(_QWORD *)a2 = v23;
            *(_OWORD *)(a2 + 8) = xmmword_208F05110;
            if (v23 <= "STUN BINDING indication" && v23 + 23 > "STUN BINDING indication")
              goto LABEL_83;
            strcpy(v23, "STUN BINDING indication");
            return;
          case 22:
            *(_BYTE *)(a2 + 23) = 20;
            v5 = "TURN SEND INDICATION";
            if (a2 > (unint64_t)"TURN SEND INDICATION")
              goto LABEL_77;
            goto LABEL_76;
          case 23:
            *(_BYTE *)(a2 + 23) = 20;
            v5 = "TURN DATA INDICATION";
            if (a2 > (unint64_t)"TURN DATA INDICATION")
              goto LABEL_77;
LABEL_76:
            if (a2 + 20 > (unint64_t)v5)
              goto LABEL_83;
LABEL_77:
            v20 = 1313818964;
LABEL_78:
            *(_DWORD *)(a2 + 16) = v20;
            *(_OWORD *)a2 = *(_OWORD *)v5;
            *(_BYTE *)(a2 + 20) = 0;
            break;
          default:
            goto LABEL_20;
        }
        return;
    }
  }
  else
  {
    switch((_DWORD)this)
    {
      case 0x200:
        *(_BYTE *)(a2 + 23) = 17;
        if (a2 > (unint64_t)"GOOG PING request" || a2 + 17 <= (unint64_t)"GOOG PING request")
        {
          strcpy((char *)a2, "GOOG PING request");
          return;
        }
        goto LABEL_83;
      case 0x300:
        *(_BYTE *)(a2 + 23) = 18;
        if (a2 > (unint64_t)"GOOG PING response" || a2 + 18 <= (unint64_t)"GOOG PING response")
        {
          strcpy((char *)a2, "GOOG PING response");
          return;
        }
        goto LABEL_83;
      case 0x310:
        v3 = (char *)operator new(0x20uLL);
        *(_QWORD *)a2 = v3;
        *(_OWORD *)(a2 + 8) = xmmword_208F08630;
        if (v3 > "GOOG PING error response" || v3 + 24 <= "GOOG PING error response")
        {
          strcpy(v3, "GOOG PING error response");
          return;
        }
        goto LABEL_83;
    }
LABEL_20:
    std::to_string(&v24, (int)this);
    v6 = std::string::insert(&v24, 0, "UNKNOWN<");
    v7 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__r.__words[2] = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    size = HIBYTE(v25.__r_.__value_.__r.__words[2]);
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v9 = 22;
    else
      v9 = (v25.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = v25.__r_.__value_.__l.__size_;
    if (v9 == size)
    {
      std::string::__grow_by_and_replace(&v25, v9, 1uLL, v9, v9, 0, 1uLL, ">");
    }
    else
    {
      v10 = &v25;
      if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v10 = (std::string *)v25.__r_.__value_.__r.__words[0];
      v11 = (char *)v10 + size;
      if ((char *)v10 + size <= ">" && v11 + 1 > ">")
      {
LABEL_83:
        __break(1u);
        return;
      }
      *v11 = 62;
      v12 = size + 1;
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
        v25.__r_.__value_.__l.__size_ = v12;
      else
        *((_BYTE *)&v25.__r_.__value_.__s + 23) = v12 & 0x7F;
      v10->__r_.__value_.__s.__data_[v12] = 0;
    }
    *(std::string *)a2 = v25;
    memset(&v25, 0, sizeof(v25));
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v24.__r_.__value_.__l.__data_);
  }
}

uint64_t cricket::ComputeStunCredentialHash(uint64_t a1, char **a2, uint64_t a3, uint64_t a4)
{
  int v7;
  size_t v8;
  BOOL v9;
  char *v10;
  std::string::size_type v11;
  std::string::size_type size;
  int v13;
  const std::string::value_type *v14;
  std::string::size_type v15;
  BOOL v16;
  std::string *v17;
  std::string::size_type v19;
  std::string::size_type v20;
  std::string::size_type v21;
  std::string *v22;
  char *v23;
  std::string::size_type v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  std::string *v32;
  size_t v33;
  __int128 *p_dst;
  _BOOL4 v35;
  uint64_t v36;
  uint64_t v38;
  uint64_t v39;
  __int128 __dst;
  unint64_t v41;
  std::string v42;
  _OWORD __src[4];
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v42, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
    std::string::push_back(&v42, 58);
    v7 = *((char *)a2 + 23);
    if ((v7 & 0x80000000) == 0)
      goto LABEL_3;
  }
  else
  {
    v42 = *(std::string *)a1;
    std::string::push_back(&v42, 58);
    v7 = *((char *)a2 + 23);
    if ((v7 & 0x80000000) == 0)
    {
LABEL_3:
      v8 = v7;
      v9 = v7 == 0;
      v10 = (char *)a2;
      goto LABEL_7;
    }
  }
  v10 = *a2;
  v8 = (size_t)a2[1];
  v9 = v8 == 0;
  if (!*a2 && v8)
    goto LABEL_74;
LABEL_7:
  if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = 22;
  else
    v11 = (v42.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v42.__r_.__value_.__r.__words[2]);
  else
    size = v42.__r_.__value_.__l.__size_;
  if (v11 - size >= v8)
  {
    if (!v9)
    {
      if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v17 = &v42;
      else
        v17 = (std::string *)v42.__r_.__value_.__r.__words[0];
      if ((char *)v17 + size <= v10 && (char *)v17 + size + v8 > v10)
        goto LABEL_74;
      memmove((char *)v17 + size, v10, v8);
      v19 = size + v8;
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
      {
        v42.__r_.__value_.__l.__size_ = size + v8;
        v17->__r_.__value_.__s.__data_[v19] = 0;
        std::string::push_back(&v42, 58);
        v13 = *(char *)(a3 + 23);
        if (v13 < 0)
          goto LABEL_15;
        goto LABEL_29;
      }
      *((_BYTE *)&v42.__r_.__value_.__s + 23) = v19 & 0x7F;
      v17->__r_.__value_.__s.__data_[v19] = 0;
    }
    std::string::push_back(&v42, 58);
    v13 = *(char *)(a3 + 23);
    if (v13 < 0)
      goto LABEL_15;
LABEL_29:
    v15 = v13;
    v16 = v13 == 0;
    v14 = (const std::string::value_type *)a3;
    goto LABEL_30;
  }
  std::string::__grow_by_and_replace(&v42, v11, size + v8 - v11, size, size, 0, v8, v10);
  std::string::push_back(&v42, 58);
  v13 = *(char *)(a3 + 23);
  if ((v13 & 0x80000000) == 0)
    goto LABEL_29;
LABEL_15:
  v14 = *(const std::string::value_type **)a3;
  v15 = *(_QWORD *)(a3 + 8);
  v16 = v15 == 0;
  if (!*(_QWORD *)a3 && v15)
    goto LABEL_74;
LABEL_30:
  if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v20 = 22;
  else
    v20 = (v42.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = HIBYTE(v42.__r_.__value_.__r.__words[2]);
  else
    v21 = v42.__r_.__value_.__l.__size_;
  if (v20 - v21 < v15)
  {
    std::string::__grow_by_and_replace(&v42, v20, v21 + v15 - v20, v21, v21, 0, v15, v14);
    goto LABEL_50;
  }
  if (!v16)
  {
    if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v22 = &v42;
    else
      v22 = (std::string *)v42.__r_.__value_.__r.__words[0];
    v23 = (char *)v22 + v21;
    if ((char *)v22 + v21 > v14 || &v23[v15] <= v14)
    {
      memmove(v23, v14, v15);
      v24 = v21 + v15;
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
        v42.__r_.__value_.__l.__size_ = v21 + v15;
      else
        *((_BYTE *)&v42.__r_.__value_.__s + 23) = v24 & 0x7F;
      v22->__r_.__value_.__s.__data_[v24] = 0;
      goto LABEL_50;
    }
LABEL_74:
    __break(1u);
  }
LABEL_50:
  v25 = HIBYTE(v42.__r_.__value_.__r.__words[2]);
  v26 = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
  v27 = operator new();
  rtc::OpenSSLDigest::OpenSSLDigest(v27, (unsigned __int16 *)&rtc::DIGEST_MD5, 3);
  v29 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 16))(v28);
  v30 = *(_QWORD *)v27;
  if (v29)
  {
    if ((v25 & 0x80u) == 0)
      v31 = v25;
    else
      v31 = *((_QWORD *)&v26 + 1);
    if ((v25 & 0x80u) == 0)
      v32 = &v42;
    else
      v32 = (std::string *)v26;
    (*(void (**)(uint64_t, std::string *, uint64_t))(v30 + 24))(v27, v32, v31);
    v33 = (*(uint64_t (**)(uint64_t, _OWORD *, uint64_t))(*(_QWORD *)v27 + 32))(v27, __src, 64);
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
    if (v33)
    {
      if (v33 >= 0x7FFFFFFFFFFFFFF8)
        abort();
      if (v33 > 0x16)
      {
        v38 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v33 | 7) != 0x17)
          v38 = v33 | 7;
        v39 = v38 + 1;
        p_dst = (__int128 *)operator new(v38 + 1);
        *((_QWORD *)&__dst + 1) = v33;
        v41 = v39 | 0x8000000000000000;
        *(_QWORD *)&__dst = p_dst;
        v35 = (__int128 *)((char *)p_dst + v33) > __src;
        if (p_dst > __src)
          goto LABEL_70;
      }
      else
      {
        HIBYTE(v41) = v33;
        p_dst = &__dst;
        v35 = (__int128 *)((char *)&__dst + v33) > __src;
        if (&__dst > __src)
          goto LABEL_70;
      }
      if (v35)
        goto LABEL_74;
LABEL_70:
      memcpy(p_dst, __src, v33);
      *((_BYTE *)p_dst + v33) = 0;
      if (*(char *)(a4 + 23) < 0)
        operator delete(*(void **)a4);
      *(_OWORD *)a4 = __dst;
      *(_QWORD *)(a4 + 16) = v41;
      v36 = 1;
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_64;
      return v36;
    }
  }
  else
  {
    (*(void (**)(uint64_t))(v30 + 8))(v27);
  }
  v36 = 0;
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
LABEL_64:
    operator delete(v42.__r_.__value_.__l.__data_);
  return v36;
}

uint64_t cricket::TurnMessage::GetAttributeValueType(cricket::TurnMessage *this, int a2)
{
  uint64_t result;

  result = 3;
  if (a2 > 32802)
  {
    if (a2 <= 49239)
    {
      if (a2 == 32803)
      {
        return 1;
      }
      else if (a2 != 32808)
      {
        return 0;
      }
    }
    else
    {
      switch(a2)
      {
        case 49240:
        case 49244:
LABEL_14:
          result = 5;
          break;
        case 49241:
LABEL_6:
          result = 7;
          break;
        case 49242:
        case 49243:
          return 0;
        case 49245:
          result = 4;
          break;
        default:
          if (a2 != 65280)
            return 0;
          break;
      }
    }
  }
  else
  {
    switch(a2)
    {
      case 1:
        return 1;
      case 2:
      case 3:
      case 4:
      case 5:
      case 7:
      case 11:
      case 14:
      case 15:
      case 16:
      case 17:
      case 23:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 33:
        return 0;
      case 6:
      case 8:
      case 19:
      case 20:
      case 21:
      case 24:
      case 26:
      case 34:
        goto LABEL_14;
      case 9:
        result = 6;
        break;
      case 10:
        goto LABEL_6;
      case 12:
      case 13:
      case 25:
        return result;
      case 18:
      case 22:
      case 32:
        result = 2;
        break;
      default:
        if (a2 == 32802)
          goto LABEL_14;
        return 0;
    }
  }
  return result;
}

uint64_t cricket::TurnMessage::CreateNew(cricket::TurnMessage *this)
{
  uint64_t result;

  result = operator new();
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_QWORD *)result = &off_24C0C1470;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_BYTE *)(result + 63) = 16;
  *(_DWORD *)(result + 32) = 0;
  if (result + 40 <= (unint64_t)"0000000000000000" && result + 56 > (unint64_t)"0000000000000000")
  {
    __break(1u);
  }
  else
  {
    strcpy((char *)(result + 40), "0000000000000000");
    *(_QWORD *)(result + 64) = 0x2112A44200000000;
    *(_QWORD *)(result + 112) = 0;
    *(_QWORD *)(result + 120) = 0;
    *(_QWORD *)(result + 104) = 0;
    *(_QWORD *)(result + 80) = 0;
    *(_QWORD *)(result + 88) = 0;
    *(_QWORD *)(result + 72) = 0;
    *(_DWORD *)(result + 96) = 0;
    *(_QWORD *)result = &off_24C0C1660;
  }
  return result;
}

uint64_t cricket::IceMessage::GetAttributeValueType(cricket::IceMessage *this, int a2)
{
  uint64_t result;
  int v3;

  result = 3;
  if (a2 <= 32801)
  {
    switch(a2)
    {
      case 1:
LABEL_5:
        result = 1;
        break;
      case 6:
      case 8:
      case 20:
      case 21:
      case 37:
LABEL_7:
        result = 5;
        break;
      case 9:
        result = 6;
        break;
      case 10:
LABEL_9:
        result = 7;
        break;
      case 32:
        result = 2;
        break;
      case 36:
        return result;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  else if (a2 > 49238)
  {
    switch(a2)
    {
      case 49239:
        return result;
      case 49240:
      case 49244:
        goto LABEL_7;
      case 49241:
        goto LABEL_9;
      case 49242:
      case 49243:
        goto LABEL_16;
      case 49245:
LABEL_8:
        result = 4;
        break;
      default:
        v3 = 65280;
LABEL_12:
        if (a2 != v3)
          goto LABEL_16;
        break;
    }
  }
  else
  {
    switch(a2)
    {
      case 32802:
        goto LABEL_7;
      case 32803:
        goto LABEL_5;
      case 32804:
      case 32805:
      case 32806:
      case 32807:
        goto LABEL_16;
      case 32808:
        return result;
      case 32809:
      case 32810:
        goto LABEL_8;
      default:
        v3 = 49153;
        goto LABEL_12;
    }
  }
  return result;
}

uint64_t cricket::IceMessage::CreateNew(cricket::IceMessage *this)
{
  uint64_t result;

  result = operator new();
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_QWORD *)result = &off_24C0C1470;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_BYTE *)(result + 63) = 16;
  *(_DWORD *)(result + 32) = 0;
  if (result + 40 <= (unint64_t)"0000000000000000" && result + 56 > (unint64_t)"0000000000000000")
  {
    __break(1u);
  }
  else
  {
    strcpy((char *)(result + 40), "0000000000000000");
    *(_QWORD *)(result + 64) = 0x2112A44200000000;
    *(_QWORD *)(result + 112) = 0;
    *(_QWORD *)(result + 120) = 0;
    *(_QWORD *)(result + 104) = 0;
    *(_QWORD *)(result + 80) = 0;
    *(_QWORD *)(result + 88) = 0;
    *(_QWORD *)(result + 72) = 0;
    *(_DWORD *)(result + 96) = 0;
    *(_QWORD *)result = &off_24C0C1690;
  }
  return result;
}

std::string *cricket::StunMessage::Clone@<X0>(cricket::StunMessage *this@<X0>, std::string **a2@<X8>)
{
  std::string *result;
  std::string *v5;
  unsigned int v6;
  std::string *v7;
  _QWORD v8[4];
  __int128 v9;
  uint64_t v10;

  result = (std::string *)(*(uint64_t (**)(cricket::StunMessage *))(*(_QWORD *)this + 16))(this);
  if (!result)
  {
    *a2 = 0;
    return result;
  }
  v5 = result;
  v10 = operator new[]();
  v9 = xmmword_208F070B0;
  if (cricket::StunMessage::Write((uint64_t)this, (uint64_t)&v9))
  {
    v8[0] = v10;
    v8[1] = v9;
    v8[2] = 0;
    v8[3] = v9;
    v6 = cricket::StunMessage::Read(v5, (rtc::ByteBufferReader *)v8);
    if (v6)
      v7 = v5;
    else
      v7 = 0;
    if (v6)
      v5 = 0;
    *a2 = v7;
    result = (std::string *)v10;
    v10 = 0;
    if (!result)
      goto LABEL_14;
  }
  else
  {
    *a2 = 0;
    result = (std::string *)v10;
    v10 = 0;
    if (!result)
      goto LABEL_14;
  }
  result = (std::string *)MEMORY[0x20BD0ADD4](result, 0x1000C8077774924);
LABEL_14:
  if (v5)
    return (std::string *)(*(uint64_t (**)(std::string *))(v5->__r_.__value_.__r.__words[0] + 8))(v5);
  return result;
}

void cricket::StunUInt32Attribute::~StunUInt32Attribute(cricket::StunUInt32Attribute *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::StunAddressAttribute::~StunAddressAttribute(void **this)
{
  *this = off_24C0C14A0;
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
}

{
  *this = off_24C0C14A0;
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::StunXorAddressAttribute::~StunXorAddressAttribute(void **this)
{
  *this = off_24C0C14A0;
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
}

{
  *this = off_24C0C14A0;
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::StunUInt64Attribute::~StunUInt64Attribute(cricket::StunUInt64Attribute *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::TurnMessage::~TurnMessage(void **this)
{
  cricket::StunMessage::~StunMessage(this);
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::IceMessage::~IceMessage(void **this)
{
  cricket::StunMessage::~StunMessage(this);
  JUMPOUT(0x20BD0ADECLL);
}

void std::deque<std::unique_ptr<cricket::StunAttribute>>::pop_front(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + ((v1 >> 6) & 0x3FFFFFFFFFFFFF8));
  if (v2)
  {
    v4 = 8 * (*(_QWORD *)(a1 + 32) & 0x1FFLL);
    v5 = *(_QWORD *)(v2 + v4);
    *(_QWORD *)(v2 + v4) = 0;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      v1 = *(_QWORD *)(a1 + 32);
    }
    v6 = *(_QWORD *)(a1 + 40) - 1;
    v7 = v1 + 1;
    *(_QWORD *)(a1 + 32) = v7;
    *(_QWORD *)(a1 + 40) = v6;
    if (v7 >= 0x400)
    {
      operator delete(**(void ***)(a1 + 8));
      *(_QWORD *)(a1 + 8) += 8;
      *(_QWORD *)(a1 + 32) -= 512;
    }
  }
  else
  {
    __break(1u);
  }
}

void cricket::StunDictionaryView::ApplyDelta(cricket::StunDictionaryView *this@<X0>, const cricket::StunByteStringAttribute *a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v4;
  unsigned __int16 *v5;
  int v6;
  __int128 v7;
  char *v8;
  __int128 v9;
  int v10;
  int v11;
  cricket::StunDictionaryView *v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  char *v33;
  void *v34;
  void *v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  void *v41;
  void *v42;
  unint64_t v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  int64_t v49;
  char *v50;
  char *v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  char *v55;
  char *v56;
  BOOL v57;
  int64_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  uint64_t v62;
  char *v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  char *v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  char *v72;
  int64_t v73;
  unint64_t v74;
  char *v75;
  char *v76;
  uint64_t v77;
  uint64_t v78;
  __int128 *v79;
  char *v80;
  uint64_t v81;
  __int128 v82;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t v86;
  char *v87;
  char *v88;
  char *v89;
  char *v90;
  unint64_t v91;
  uint64_t v92;
  __int128 *v93;
  char *v94;
  uint64_t v95;
  __int128 v96;
  uint64_t v97;
  char *v98;
  char *v99;
  uint64_t v100;
  uint64_t v101;
  void *v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  __int128 *v110;
  char *v111;
  uint64_t v112;
  __int128 v113;
  uint64_t v114;
  unint64_t v115;
  unint64_t v116;
  uint64_t v117;
  char *v118;
  char *v119;
  int64_t v120;
  unint64_t v121;
  char *v122;
  uint64_t v123;
  uint64_t v124;
  char *v125;
  __int128 *v126;
  char *v127;
  uint64_t v128;
  __int128 v129;
  uint64_t v130;
  char *v131;
  const char *v132;
  uint64_t v133;
  char *v134;
  int v135;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  char **v140;
  char **v141;
  unsigned int v142;
  char **v143;
  char **v144;
  unsigned int v145;
  BOOL v146;
  char **v147;
  int v148;
  char **v149;
  char **v150;
  unsigned int v151;
  BOOL v152;
  char **v153;
  char *v154;
  int v155;
  int v156;
  int v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  cricket::StunDictionaryView *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  int v174;
  _QWORD *v175;
  _QWORD *v176;
  char *v177;
  char **v178;
  unsigned int v179;
  uint64_t **v180;
  uint64_t **v181;
  uint64_t **v182;
  unsigned int v183;
  char *v184;
  uint64_t v185;
  uint64_t *v186;
  unsigned int v187;
  uint64_t **v188;
  uint64_t **v189;
  uint64_t **v190;
  unsigned int v191;
  char *v192;
  uint64_t v193;
  uint64_t *v194;
  char *v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  _BYTE *v199;
  char *v200;
  unint64_t v201;
  char *v202;
  size_t v203;
  __int16 v204;
  int v205;
  uint64_t v206;
  unsigned int v207;
  uint64_t **v208;
  char *v209;
  uint64_t **v210;
  unsigned int v211;
  char *v212;
  uint64_t v213;
  uint64_t *v214;
  uint64_t *v215;
  uint64_t **v216;
  uint64_t *v217;
  unsigned int v218;
  uint64_t *v219;
  unsigned int v220;
  BOOL v221;
  uint64_t **v222;
  uint64_t *v223;
  uint64_t **v224;
  uint64_t *v225;
  _QWORD *v226;
  uint64_t *v227;
  unint64_t v228;
  uint64_t v229;
  unint64_t v230;
  _OWORD *v231;
  char *v232;
  unint64_t v233;
  __int128 v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  char *v243;
  const char *v244;
  __int128 v245;
  __int16 *v246;
  const char *v247;
  __int128 v248;
  __int128 v249;
  __int128 v250;
  void *v251;
  uint64_t **v252;
  uint64_t v253;
  size_t __sz;
  size_t __sza;
  size_t __szb;
  unsigned __int16 *v257;
  char *v258;
  unint64_t v259;
  _QWORD *v260;
  uint64_t *v261;
  char v263;
  _QWORD v264[2];
  int v265;
  void *__p[4];
  const char *v267;
  __int128 v268;
  __int128 v269;
  __int128 v270;
  char v271;
  const char *v272;
  _BYTE v273[32];
  uint64_t v274;
  uint64_t v275;
  __int128 v276;
  __int128 v277;
  __int128 v278;
  unint64_t v279;
  _QWORD *v280;
  uint64_t v281;
  _QWORD *v282;

  v4 = (_QWORD *)*((unsigned __int16 *)a2 + 5);
  v5 = (unsigned __int16 *)*((_QWORD *)a2 + 2);
  if (!*((_WORD *)a2 + 5))
    v5 = 0;
  v279 = (unint64_t)v5;
  v280 = v4;
  v282 = v4;
  if (v4 <= 1)
  {
    v8 = (char *)operator new(0x20uLL);
    if (v8 <= "Failed to read magic number" && v8 + 27 > "Failed to read magic number")
      goto LABEL_337;
    strcpy(v8, "Failed to read magic number");
    v265 = 3;
    __p[0] = v8;
    v9 = xmmword_208F051A0;
    goto LABEL_12;
  }
  v6 = *v5;
  v281 = 2;
  if (v6 != 34935)
  {
    LODWORD(v272) = 3;
    v273[23] = 20;
    if (v273 > "Invalid magic number" || &v273[20] <= "Invalid magic number")
    {
      v7 = *(_OWORD *)"Invalid magic number";
      strcpy(v273, "Invalid magic number");
      *(_DWORD *)&v273[24] = 0;
      v273[28] = 0;
      v273[30] = 0;
      v265 = 3;
      goto LABEL_16;
    }
LABEL_337:
    __break(1u);
LABEL_338:
    std::__throw_bad_array_new_length[abi:sn180100]();
  }
  if (((unsigned __int16)v4 & 0xFFFE) == 2)
  {
    LODWORD(v272) = 3;
    v273[23] = 22;
    if (v273 > "Failed to read version" || &v273[22] <= "Failed to read version")
    {
      strcpy(v273, "Failed to read version");
      *(_DWORD *)&v273[24] = 0;
      v273[28] = 0;
      v273[30] = 0;
      v265 = 3;
      v7 = *(_OWORD *)v273;
LABEL_16:
      *(_OWORD *)__p = v7;
      __p[2] = *(void **)&v273[16];
      LODWORD(__p[3]) = 0;
      *(_DWORD *)((char *)&__p[3] + 3) = *(_DWORD *)&v273[27];
      goto LABEL_17;
    }
    goto LABEL_337;
  }
  v11 = v5[1];
  v281 = 4;
  if (v11 != 256)
  {
    v13 = (char *)operator new(0x20uLL);
    if (v13 <= "Unsupported delta version" && v13 + 25 > "Unsupported delta version")
      goto LABEL_337;
    strcpy(v13, "Unsupported delta version");
    v265 = 3;
    __p[0] = v13;
    v9 = xmmword_208F05150;
LABEL_12:
    *(_OWORD *)&__p[1] = v9;
    LODWORD(__p[3]) = 0;
    BYTE4(__p[3]) = 0;
    BYTE6(__p[3]) = 0;
LABEL_17:
    LOBYTE(v267) = 0;
    v271 = 0;
    v10 = 3;
LABEL_18:
    LODWORD(v272) = v10;
    if (SHIBYTE(__p[2]) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)v273, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
      v10 = (int)v272;
    }
    else
    {
      *(_OWORD *)v273 = *(_OWORD *)__p;
      *(void **)&v273[16] = __p[2];
    }
    *(_DWORD *)a3 = v10;
    *(_OWORD *)(a3 + 8) = *(_OWORD *)v273;
    *(_QWORD *)(a3 + 24) = *(_QWORD *)&v273[16];
    *(_DWORD *)(a3 + 32) = __p[3];
    *(_DWORD *)(a3 + 35) = *(_DWORD *)((char *)&__p[3] + 3);
    *(_BYTE *)(a3 + 40) = 0;
    *(_BYTE *)(a3 + 72) = 0;
    if (!v271)
      goto LABEL_23;
    goto LABEL_22;
  }
  v12 = this;
  v278 = 0u;
  v277 = 0u;
  v276 = 0u;
  if ((_DWORD)v4 == 4)
    goto LABEL_28;
  v259 = (unint64_t)&__p[3];
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 4;
  do
  {
    if ((unint64_t)v4 - v18 <= 1)
    {
      v131 = (char *)operator new(0x20uLL);
      v132 = v131 + 28;
      if (v131 <= "Failed to read attribute key" && v132 > "Failed to read attribute key")
        goto LABEL_337;
      qmemcpy(v131, "Failed to read attribute key", 28);
      v133 = 28;
LABEL_168:
      *v132 = 0;
      v265 = 3;
      __p[0] = v131;
      __p[1] = (void *)v133;
      __p[2] = (void *)0x8000000000000020;
LABEL_172:
      LODWORD(__p[3]) = 0;
      BYTE4(__p[3]) = 0;
      BYTE6(__p[3]) = 0;
      goto LABEL_173;
    }
    v19 = *(unsigned __int16 *)(v279 + v18);
    v281 = v18 + 2;
    if ((unint64_t)v4 - v18 - 2 <= 1)
    {
      v131 = (char *)operator new(0x20uLL);
      v132 = v131 + 31;
      if (v131 <= "Failed to read attribute length" && v132 > "Failed to read attribute length")
        goto LABEL_337;
      qmemcpy(v131, "Failed to read attribute length", 31);
      v133 = 31;
      goto LABEL_168;
    }
    v20 = *(unsigned __int16 *)(v279 + v18 + 2);
    v281 = v18 + 4;
    if ((unint64_t)v4 - v18 - 4 <= 1)
    {
      v131 = (char *)operator new(0x20uLL);
      v132 = v131 + 25;
      if (v131 <= "Failed to read value type" && v132 > "Failed to read value type")
        goto LABEL_337;
      qmemcpy(v131, "Failed to read value type", 25);
      v133 = 25;
      goto LABEL_168;
    }
    v21 = bswap32(v19) >> 16;
    v22 = bswap32(v20) >> 16;
    v23 = *(unsigned __int16 *)(v279 + v18 + 4);
    v281 = v18 + 6;
    v24 = (unsigned __int16)((bswap32(v23) >> 16) - 1);
    if (v24 < 7)
      v25 = v24 + 1;
    else
      v25 = 0;
    v26 = (unsigned __int16 *)cricket::StunAttribute::Create(v25, v21, v22, 0);
    if (!v26)
    {
      v134 = (char *)operator new(0x20uLL);
      if (v134 <= "Failed to create attribute" && v134 + 26 > "Failed to create attribute")
        goto LABEL_337;
      strcpy(v134, "Failed to create attribute");
      v265 = 3;
      __p[0] = v134;
      *(_OWORD *)&__p[1] = xmmword_208F0AC80;
      goto LABEL_172;
    }
    v27 = v26;
    if (v26[5] != v22)
    {
      v243 = (char *)operator new(0x20uLL);
      v244 = v243 + 29;
      if (v243 <= "Inconsistent attribute length" && v244 > "Inconsistent attribute length")
        goto LABEL_337;
      qmemcpy(v243, "Inconsistent attribute length", 29);
      v245 = xmmword_208F05190;
      goto LABEL_329;
    }
    if (((*(uint64_t (**)(unsigned __int16 *, unint64_t *))(*(_QWORD *)v26 + 32))(v26, &v279) & 1) == 0)
    {
      v243 = (char *)operator new(0x28uLL);
      v244 = v243 + 32;
      if (v243 <= "Failed to read attribute content" && v244 > "Failed to read attribute content")
        goto LABEL_337;
      qmemcpy(v243, "Failed to read attribute content", 32);
      v245 = xmmword_208F04EE0;
LABEL_329:
      *v244 = 0;
      v265 = 3;
      __p[0] = v243;
      *(_OWORD *)&__p[1] = v245;
      LODWORD(__p[3]) = 0;
      BYTE4(__p[3]) = 0;
      BYTE6(__p[3]) = 0;
      LOBYTE(v267) = 0;
      v271 = 0;
      (*(void (**)(unsigned __int16 *))(*(_QWORD *)v27 + 8))(v27);
      goto LABEL_174;
    }
    v28 = ((v17 - v16) << 6) - 1;
    v29 = v17 - v16;
    if (v17 == v16)
      v28 = 0;
    if (v28 == v15 + v14)
    {
      if (v15 >= 0x200)
      {
        *(_QWORD *)&v278 = v15 - 512;
        v30 = v16 + 8;
        v31 = *(_QWORD *)v16;
        *((_QWORD *)&v276 + 1) = v16 + 8;
        if (v17 != *((char **)&v277 + 1))
          goto LABEL_49;
        v44 = (void *)v276;
        if ((unint64_t)v30 > (unint64_t)v276)
        {
          v45 = (uint64_t)&v30[-v276] >> 3;
          if (v45 >= -1)
            v46 = v45 + 1;
          else
            v46 = v45 + 2;
          v47 = v46 >> 1;
          v48 = &v30[-8 * (v46 >> 1)];
          v49 = v17 - v30;
          if (v17 != v30)
          {
            memmove(&v30[-8 * (v46 >> 1)], v30, v17 - v30);
            v17 = (char *)*((_QWORD *)&v276 + 1);
          }
          v50 = &v17[-8 * v47];
          v17 = &v48[v49];
          *((_QWORD *)&v276 + 1) = v50;
          *(_QWORD *)&v277 = &v48[v49];
LABEL_50:
          *(_QWORD *)v17 = v31;
LABEL_126:
          v63 = (char *)(v277 + 8);
          *(_QWORD *)&v277 = v277 + 8;
LABEL_127:
          v14 = *((_QWORD *)&v278 + 1);
          v16 = (char *)*((_QWORD *)&v276 + 1);
          v17 = v63;
          goto LABEL_128;
        }
        v52 = (uint64_t)&v17[-v276] >> 2;
        if (v17 == (char *)v276)
          v52 = 1;
        if (v52 >> 61)
          goto LABEL_338;
        v53 = v52 >> 2;
        v54 = 8 * v52;
        v55 = (char *)operator new(8 * v52);
        v56 = &v55[8 * v53];
        v58 = v17 - v30;
        v57 = v17 == v30;
        v17 = v56;
        if (!v57)
        {
          v17 = &v56[v58 & 0xFFFFFFFFFFFFFFF8];
          v59 = v58 - 8;
          if ((unint64_t)(v58 - 8) < 0x38)
          {
            v60 = &v55[8 * v53];
            do
            {
LABEL_143:
              v114 = *(_QWORD *)v30;
              v30 += 8;
              *(_QWORD *)v60 = v114;
              v60 += 8;
            }
            while (v60 != v17);
            goto LABEL_144;
          }
          v60 = &v55[8 * v53];
          if ((unint64_t)(v60 - v30) < 0x20)
            goto LABEL_143;
          v108 = (v59 >> 3) + 1;
          v109 = 8 * (v108 & 0x3FFFFFFFFFFFFFFCLL);
          v60 = &v56[v109];
          v30 += v109;
          v110 = (__int128 *)(v16 + 24);
          v111 = &v55[8 * v53 + 16];
          v112 = v108 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v113 = *v110;
            *((_OWORD *)v111 - 1) = *(v110 - 1);
            *(_OWORD *)v111 = v113;
            v110 += 2;
            v111 += 32;
            v112 -= 4;
          }
          while (v112);
          if (v108 != (v108 & 0x3FFFFFFFFFFFFFFCLL))
            goto LABEL_143;
        }
LABEL_144:
        *(_QWORD *)&v276 = v55;
        *((_QWORD *)&v276 + 1) = &v55[8 * v53];
        *(_QWORD *)&v277 = v17;
        *((_QWORD *)&v277 + 1) = &v55[v54];
        if (v44)
          operator delete(v44);
LABEL_49:
        if (!v17)
          goto LABEL_337;
        goto LABEL_50;
      }
      v32 = (char *)*((_QWORD *)&v277 + 1);
      v33 = (char *)v276;
      if (v29 >> 3 >= (unint64_t)((uint64_t)(*((_QWORD *)&v277 + 1) - v276) >> 3))
      {
        __sz = v276;
        v257 = v27;
        if (*((_QWORD *)&v277 + 1) == (_QWORD)v276)
          v36 = 1;
        else
          v36 = (uint64_t)(*((_QWORD *)&v277 + 1) - v276) >> 2;
        if (v36 >> 61)
          goto LABEL_338;
        v37 = (char *)operator new(8 * v36);
        v38 = v29 >> 3;
        v39 = &v37[8 * (v29 >> 3)];
        v40 = &v37[8 * v36];
        v41 = operator new(0x1000uLL);
        if (v29 >> 3 == v36)
        {
          v42 = (void *)__sz;
          if (v29 < 1)
          {
            v251 = v41;
            v61 = v29 >> 2;
            if (v17 == v16)
              v61 = 1;
            v27 = v257;
            if (v61 >> 61)
              goto LABEL_338;
            v62 = 8 * v61;
            v39 = (char *)operator new(8 * v61);
            operator delete(v37);
            v40 = &v39[v62];
            v37 = v39;
            v41 = v251;
          }
          else
          {
            v43 = v38 + 2;
            if (v38 >= -1)
              v43 = v38 + 1;
            v39 -= 8 * (v43 >> 1);
            v27 = v257;
          }
        }
        else
        {
          v42 = (void *)__sz;
          v27 = v257;
        }
        *(_QWORD *)v39 = v41;
        v63 = v39 + 8;
        if (v17 != v16)
        {
          do
          {
            if (v39 == v37)
            {
              if (v63 >= v40)
              {
                v69 = (v40 - v39) >> 2;
                if (v40 == v39)
                  v69 = 1;
                if (v69 >> 61)
                  goto LABEL_338;
                v70 = (v69 + 3) >> 2;
                v71 = 8 * v69;
                v72 = (char *)operator new(8 * v69);
                v37 = v72;
                v64 = &v72[8 * v70];
                v73 = v63 - v39;
                v57 = v63 == v39;
                v63 = v64;
                if (!v57)
                {
                  v63 = &v64[v73 & 0xFFFFFFFFFFFFFFF8];
                  v74 = v73 - 8;
                  v75 = &v72[8 * v70];
                  v76 = v39;
                  if (v74 < 0x38)
                    goto LABEL_342;
                  v75 = &v72[8 * v70];
                  v76 = v39;
                  if ((unint64_t)(v75 - v39) < 0x20)
                    goto LABEL_342;
                  v77 = (v74 >> 3) + 1;
                  v78 = 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
                  v75 = &v64[v78];
                  v76 = &v39[v78];
                  v79 = (__int128 *)(v39 + 16);
                  v80 = &v72[8 * v70 + 16];
                  v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    v82 = *v79;
                    *((_OWORD *)v80 - 1) = *(v79 - 1);
                    *(_OWORD *)v80 = v82;
                    v79 += 2;
                    v80 += 32;
                    v81 -= 4;
                  }
                  while (v81);
                  if (v77 != (v77 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_342:
                    do
                    {
                      v83 = *(_QWORD *)v76;
                      v76 += 8;
                      *(_QWORD *)v75 = v83;
                      v75 += 8;
                    }
                    while (v75 != v63);
                  }
                }
                v40 = &v72[v71];
                operator delete(v39);
              }
              else
              {
                v66 = (v40 - v63) >> 3;
                if (v66 >= -1)
                  v67 = v66 + 1;
                else
                  v67 = v66 + 2;
                v68 = &v63[8 * (v67 >> 1)];
                v64 = &v39[8 * (v67 >> 1)];
                if (v63 == v39)
                {
                  v37 = v63;
                }
                else
                {
                  memmove(&v39[8 * (v67 >> 1)], v39, v63 - v39);
                  v37 = v39;
                }
                v63 = v68;
              }
            }
            else
            {
              v64 = v39;
            }
            v65 = *((_QWORD *)v17 - 1);
            v17 -= 8;
            *((_QWORD *)v64 - 1) = v65;
            v39 = v64 - 8;
          }
          while (v17 != *((char **)&v276 + 1));
          v42 = (void *)v276;
        }
        *(_QWORD *)&v276 = v37;
        *((_QWORD *)&v276 + 1) = v39;
        *(_QWORD *)&v277 = v63;
        *((_QWORD *)&v277 + 1) = v40;
        if (v42)
          operator delete(v42);
        goto LABEL_127;
      }
      v34 = operator new(0x1000uLL);
      v35 = v34;
      if (v32 != v17)
      {
        if (!v17)
          goto LABEL_337;
        *(_QWORD *)v17 = v34;
        goto LABEL_126;
      }
      if (v16 == v33)
      {
        v84 = (v32 - v16) >> 2;
        if (v17 == v16)
          v84 = 1;
        if (v84 >> 61)
          goto LABEL_338;
        v85 = (v84 + 3) >> 2;
        v86 = 8 * v84;
        v87 = (char *)operator new(8 * v84);
        v51 = &v87[8 * v85];
        v88 = v51;
        if (v17 != v16)
        {
          v88 = &v51[8 * (v29 >> 3)];
          v89 = &v87[8 * v85];
          v90 = v16;
          if ((unint64_t)(v29 - 8) < 0x38)
            goto LABEL_343;
          v89 = &v87[8 * v85];
          v90 = v16;
          if ((unint64_t)(v89 - v16) < 0x20)
            goto LABEL_343;
          v91 = ((unint64_t)(v29 - 8) >> 3) + 1;
          v92 = 8 * (v91 & 0x3FFFFFFFFFFFFFFCLL);
          v89 = &v51[v92];
          v90 = &v16[v92];
          v93 = (__int128 *)(v16 + 16);
          v94 = &v87[8 * v85 + 16];
          v95 = v91 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v96 = *v93;
            *((_OWORD *)v94 - 1) = *(v93 - 1);
            *(_OWORD *)v94 = v96;
            v93 += 2;
            v94 += 32;
            v95 -= 4;
          }
          while (v95);
          if (v91 != (v91 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_343:
            do
            {
              v97 = *(_QWORD *)v90;
              v90 += 8;
              *(_QWORD *)v89 = v97;
              v89 += 8;
            }
            while (v89 != v88);
          }
        }
        *(_QWORD *)&v276 = v87;
        *((_QWORD *)&v276 + 1) = &v87[8 * v85];
        *(_QWORD *)&v277 = v88;
        *((_QWORD *)&v277 + 1) = &v87[v86];
        if (v16)
        {
          operator delete(v16);
          v51 = (char *)*((_QWORD *)&v276 + 1);
        }
      }
      else
      {
        v51 = v16;
      }
      *((_QWORD *)v51 - 1) = v35;
      v98 = (char *)*((_QWORD *)&v276 + 1);
      v99 = (char *)v277;
      v100 = *(_QWORD *)(*((_QWORD *)&v276 + 1) - 8);
      if ((_QWORD)v277 != *((_QWORD *)&v277 + 1))
        goto LABEL_124;
      v102 = (void *)v276;
      if (*((_QWORD *)&v276 + 1) > (unint64_t)v276)
      {
        v103 = (uint64_t)(*((_QWORD *)&v276 + 1) - v276) >> 3;
        if (v103 >= -1)
          v104 = v103 + 1;
        else
          v104 = v103 + 2;
        v105 = v104 >> 1;
        v106 = *((_QWORD *)&v276 + 1) - 8 * v105;
        v107 = v277 - *((_QWORD *)&v276 + 1);
        if ((_QWORD)v277 != *((_QWORD *)&v276 + 1))
          memmove((void *)(*((_QWORD *)&v276 + 1) - 8 * v105), *((const void **)&v276 + 1), v277 - *((_QWORD *)&v276 + 1));
        v99 = (char *)(v106 + v107);
        *((_QWORD *)&v276 + 1) = v106;
        *(_QWORD *)&v277 = v106 + v107;
LABEL_125:
        *(_QWORD *)v99 = v100;
        goto LABEL_126;
      }
      v115 = (uint64_t)(v277 - v276) >> 2;
      if ((_QWORD)v277 == (_QWORD)v276)
        v115 = 1;
      if (v115 >> 61)
        goto LABEL_338;
      v116 = v115 >> 2;
      v117 = 8 * v115;
      v118 = (char *)operator new(8 * v115);
      v119 = &v118[8 * v116];
      v120 = v99 - v98;
      v57 = v99 == v98;
      v99 = v119;
      if (!v57)
      {
        v99 = &v119[v120 & 0xFFFFFFFFFFFFFFF8];
        v121 = v120 - 8;
        if ((unint64_t)(v120 - 8) < 0x38)
        {
          v122 = &v118[8 * v116];
          do
          {
LABEL_156:
            v130 = *(_QWORD *)v98;
            v98 += 8;
            *(_QWORD *)v122 = v130;
            v122 += 8;
          }
          while (v122 != v99);
          goto LABEL_157;
        }
        v122 = &v118[8 * v116];
        if ((unint64_t)(v122 - v98) < 0x20)
          goto LABEL_156;
        v123 = (v121 >> 3) + 1;
        v124 = 8 * (v123 & 0x3FFFFFFFFFFFFFFCLL);
        v122 = &v119[v124];
        v125 = &v98[v124];
        v126 = (__int128 *)(v98 + 16);
        v127 = &v118[8 * v116 + 16];
        v128 = v123 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v129 = *v126;
          *((_OWORD *)v127 - 1) = *(v126 - 1);
          *(_OWORD *)v127 = v129;
          v126 += 2;
          v127 += 32;
          v128 -= 4;
        }
        while (v128);
        v98 = v125;
        if (v123 != (v123 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_156;
      }
LABEL_157:
      *(_QWORD *)&v276 = v118;
      *((_QWORD *)&v276 + 1) = &v118[8 * v116];
      *(_QWORD *)&v277 = v99;
      *((_QWORD *)&v277 + 1) = &v118[v117];
      if (v102)
        operator delete(v102);
LABEL_124:
      if (!v99)
        goto LABEL_337;
      goto LABEL_125;
    }
LABEL_128:
    v12 = this;
    if (v17 == v16)
      goto LABEL_337;
    v15 = v278;
    v101 = *(_QWORD *)&v16[((unint64_t)(v278 + v14) >> 6) & 0x3FFFFFFFFFFFFF8];
    if (!v101)
      goto LABEL_337;
    *(_QWORD *)(v101 + 8 * (((_WORD)v278 + (_WORD)v14++) & 0x1FF)) = v27;
    *((_QWORD *)&v278 + 1) = v14;
    v18 = v281;
    v4 = v282;
  }
  while (v282 != (_QWORD *)v281);
  if (!v14)
  {
LABEL_28:
    LODWORD(v272) = 3;
    v273[23] = 12;
    if (v273 <= "Empty delta!" && &v273[12] > "Empty delta!")
      goto LABEL_337;
    strcpy(v273, "Empty delta!");
    v273[30] = 0;
    v265 = 3;
    __p[2] = *(void **)&v273[16];
    *(_OWORD *)__p = *(_OWORD *)v273;
    memset(v273, 0, 29);
    LODWORD(__p[3]) = 0;
    *(_DWORD *)((char *)&__p[3] + 3) = *(_DWORD *)&v273[27];
LABEL_173:
    LOBYTE(v267) = 0;
    v271 = 0;
    goto LABEL_174;
  }
  v246 = *(__int16 **)(*(_QWORD *)&v16[8 * (v15 >> 9)] + 8 * (v15 & 0x1FF));
  if (v246[4] != -1 || (*(unsigned int (**)(__int16 *))(*(_QWORD *)v246 + 16))(v246) != 4)
  {
    LODWORD(v272) = 3;
    v273[23] = 16;
    if (v273 <= "Missing version!" && &v273[16] > "Missing version!")
      goto LABEL_337;
    v273[16] = 0;
    v273[30] = 0;
    v265 = 3;
    *(_OWORD *)__p = *(_OWORD *)"Missing version!";
    __p[2] = *(void **)&v273[16];
    memset(v273, 0, 29);
    LODWORD(__p[3]) = 0;
    *(_DWORD *)((char *)&__p[3] + 3) = *(_DWORD *)&v273[27];
    goto LABEL_173;
  }
  v247 = *(const char **)(*(_QWORD *)(*(_QWORD *)&v16[8 * (v15 >> 9)] + 8 * (v15 & 0x1FF)) + 16);
  std::deque<std::unique_ptr<cricket::StunAttribute>>::pop_front((uint64_t)&v276);
  v272 = v247;
  v248 = v277;
  v249 = v276;
  v277 = 0u;
  v276 = 0u;
  v250 = v278;
  v278 = 0uLL;
  v265 = 0;
  BYTE6(__p[3]) = 0;
  memset(__p, 0, 29);
  v267 = v247;
  v268 = v249;
  v269 = v248;
  memset(v273, 0, sizeof(v273));
  v270 = v250;
  v274 = 0;
  v275 = 0;
  v271 = 1;
  std::deque<std::unique_ptr<webrtc::RtpFrameObject>>::~deque[abi:sn180100]((void **)v273);
LABEL_174:
  std::deque<std::unique_ptr<webrtc::RtpFrameObject>>::~deque[abi:sn180100]((void **)&v276);
  v10 = v265;
  if (v265)
    goto LABEL_18;
  if (!v271)
    goto LABEL_337;
  v135 = *((_DWORD *)v12 + 13);
  v261 = (uint64_t *)v267;
  if ((_QWORD)v269 == *((_QWORD *)&v268 + 1)
    || (v136 = (uint64_t *)(*((_QWORD *)&v268 + 1) + 8 * ((unint64_t)v270 >> 9)),
        v137 = *v136,
        v138 = *v136 + 8 * (v270 & 0x1FF),
        v139 = *(_QWORD *)(*((_QWORD *)&v268 + 1)
                         + (((*((_QWORD *)&v270 + 1) + (_QWORD)v270) >> 6) & 0x3FFFFFFFFFFFFF8))
             + 8 * ((*((_QWORD *)&v270 + 1) + v270) & 0x1FF),
        v138 == v139))
  {
LABEL_217:
    v166 = this;
    if (v135 > *((_DWORD *)this + 12))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v167, v168, v169, v170, v171, v172, v173, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_dictionary.cc");
      *(_BYTE *)(a3 + 36) = 0;
      *(_DWORD *)(a3 + 32) = 0;
      v174 = 9;
      goto LABEL_321;
    }
    if (!v271)
      goto LABEL_337;
    if ((_QWORD)v269 == *((_QWORD *)&v268 + 1)
      || (v175 = (_QWORD *)(*((_QWORD *)&v268 + 1) + 8 * ((unint64_t)v270 >> 9)),
          v176 = (_QWORD *)(*v175 + 8 * (v270 & 0x1FF)),
          v253 = *(_QWORD *)(*((_QWORD *)&v268 + 1)
                           + (((*((_QWORD *)&v270 + 1) + (_QWORD)v270) >> 6) & 0x3FFFFFFFFFFFFF8))
               + 8 * ((*((_QWORD *)&v270 + 1) + v270) & 0x1FF),
          v176 == (_QWORD *)v253))
    {
      v177 = 0;
      __sza = 0;
      v258 = 0;
LABEL_316:
      *((_DWORD *)v166 + 13) = v135;
      v235 = operator new();
      *(_DWORD *)(v235 + 8) = 573533;
      *(_QWORD *)v235 = &off_24C0C1560;
      *(_QWORD *)(v235 + 16) = v261;
      *(_DWORD *)a3 = 0;
      *(_BYTE *)(a3 + 38) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 29) = 0;
      *(_QWORD *)(a3 + 40) = v235;
      *(_QWORD *)(a3 + 48) = v177;
      *(_QWORD *)(a3 + 56) = v258;
      *(_QWORD *)(a3 + 64) = __sza;
      *(_BYTE *)(a3 + 72) = 1;
      if (!v271)
        goto LABEL_23;
LABEL_22:
      std::deque<std::unique_ptr<webrtc::RtpFrameObject>>::~deque[abi:sn180100]((void **)&v268);
      goto LABEL_23;
    }
    __sza = 0;
    v258 = 0;
    v177 = 0;
    v178 = (char **)((char *)this + 32);
    v252 = (uint64_t **)((char *)this + 8);
    while (1)
    {
      v260 = v175;
      v179 = *(unsigned __int16 *)(*v176 + 8);
      v180 = (uint64_t **)*v178;
      v181 = (uint64_t **)((char *)this + 32);
      v182 = (uint64_t **)((char *)this + 32);
      if (*v178)
      {
        while (1)
        {
          while (1)
          {
            v182 = v180;
            v183 = *((unsigned __int16 *)v180 + 16);
            if (v179 >= v183)
              break;
            v180 = (uint64_t **)*v182;
            v181 = v182;
            if (!*v182)
              goto LABEL_233;
          }
          if (v183 >= v179)
            break;
          v180 = (uint64_t **)v182[1];
          if (!v180)
          {
            v181 = v182 + 1;
            goto LABEL_233;
          }
        }
      }
      else
      {
LABEL_233:
        v184 = (char *)v182;
        v182 = (uint64_t **)operator new(0x30uLL);
        *((_WORD *)v182 + 16) = v179;
        v182[5] = 0;
        *v182 = 0;
        v182[1] = 0;
        v182[2] = (uint64_t *)v184;
        *v181 = (uint64_t *)v182;
        v185 = **((_QWORD **)v166 + 3);
        v186 = (uint64_t *)v182;
        if (v185)
        {
          *((_QWORD *)v166 + 3) = v185;
          v186 = *v181;
        }
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v166 + 4), v186);
        ++*((_QWORD *)v166 + 5);
      }
      if (v261 <= v182[5])
        goto LABEL_296;
      v187 = *(unsigned __int16 *)(*v176 + 8);
      v188 = (uint64_t **)*v178;
      v189 = (uint64_t **)((char *)this + 32);
      v190 = (uint64_t **)((char *)this + 32);
      if (*v178)
      {
        while (1)
        {
          while (1)
          {
            v190 = v188;
            v191 = *((unsigned __int16 *)v188 + 16);
            if (v187 >= v191)
              break;
            v188 = (uint64_t **)*v190;
            v189 = v190;
            if (!*v190)
              goto LABEL_244;
          }
          if (v191 >= v187)
            break;
          v188 = (uint64_t **)v190[1];
          if (!v188)
          {
            v189 = v190 + 1;
            goto LABEL_244;
          }
        }
      }
      else
      {
LABEL_244:
        v192 = (char *)v190;
        v190 = (uint64_t **)operator new(0x30uLL);
        *((_WORD *)v190 + 16) = v187;
        v190[5] = 0;
        *v190 = 0;
        v190[1] = 0;
        v190[2] = (uint64_t *)v192;
        *v189 = (uint64_t *)v190;
        v193 = **((_QWORD **)v166 + 3);
        v194 = (uint64_t *)v190;
        if (v193)
        {
          *((_QWORD *)v166 + 3) = v193;
          v194 = *v189;
        }
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v166 + 4), v194);
        ++*((_QWORD *)v166 + 5);
        LOWORD(v187) = *(_WORD *)(*v176 + 8);
      }
      v190[5] = v261;
      if ((unint64_t)v258 >= __sza)
        break;
      if (!v258)
        goto LABEL_337;
      *(_WORD *)v258 = v187;
      v195 = v258 + 2;
LABEL_268:
      v205 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v176 + 16))(*v176);
      v206 = *v176;
      v258 = v195;
      if (v205 == 5 && !*(_WORD *)(v206 + 10))
      {
        v216 = (uint64_t **)((char *)this + 8);
        v217 = *v252;
        if (*v252)
        {
          v218 = *(unsigned __int16 *)(v206 + 8);
          v219 = *v252;
          v175 = v260;
          do
          {
            v220 = *((unsigned __int16 *)v219 + 16);
            v221 = v220 >= v218;
            if (v220 >= v218)
              v222 = (uint64_t **)v219;
            else
              v222 = (uint64_t **)(v219 + 1);
            if (v221)
              v216 = (uint64_t **)v219;
            v219 = *v222;
          }
          while (*v222);
          if (v216 != v252 && v218 >= *((unsigned __int16 *)v216 + 16))
          {
            v223 = v216[1];
            v224 = v216;
            if (v223)
            {
              do
              {
                v225 = v223;
                v223 = (uint64_t *)*v223;
              }
              while (v223);
            }
            else
            {
              do
              {
                v225 = v224[2];
                v57 = *v225 == (_QWORD)v224;
                v224 = (uint64_t **)v225;
              }
              while (!v57);
            }
            if (*(uint64_t ***)v166 == v216)
              *(_QWORD *)v166 = v225;
            --*((_QWORD *)v166 + 2);
            std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v217, (uint64_t *)v216);
            v227 = v216[5];
            v216[5] = 0;
            if (v227)
              (*(void (**)(uint64_t *))(*v227 + 8))(v227);
            operator delete(v216);
            if ((_QWORD *)((char *)++v176 - *v260) != (_QWORD *)4096)
              goto LABEL_225;
LABEL_298:
            v226 = (_QWORD *)v175[1];
            ++v175;
            v176 = v226;
            goto LABEL_225;
          }
          goto LABEL_297;
        }
LABEL_296:
        v175 = v260;
        goto LABEL_297;
      }
      v207 = *(unsigned __int16 *)(v206 + 8);
      v208 = (uint64_t **)((char *)this + 8);
      while (1)
      {
        v209 = (char *)*v208;
        v210 = v208;
        if (!*v208)
          break;
        while (1)
        {
          v208 = (uint64_t **)v209;
          v211 = *((unsigned __int16 *)v209 + 16);
          if (v207 < v211)
            break;
          if (v211 >= v207)
            goto LABEL_279;
          v209 = (char *)v208[1];
          if (!v209)
          {
            v210 = v208 + 1;
            goto LABEL_276;
          }
        }
      }
LABEL_276:
      v212 = (char *)v208;
      v208 = (uint64_t **)operator new(0x30uLL);
      *((_WORD *)v208 + 16) = v207;
      v208[5] = 0;
      *v208 = 0;
      v208[1] = 0;
      v208[2] = (uint64_t *)v212;
      *v210 = (uint64_t *)v208;
      v213 = **(_QWORD **)v166;
      v214 = (uint64_t *)v208;
      if (v213)
      {
        *(_QWORD *)v166 = v213;
        v214 = *v210;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v166 + 1), v214);
      ++*((_QWORD *)v166 + 2);
      v206 = *v176;
LABEL_279:
      v175 = v260;
      *v176 = 0;
      v215 = v208[5];
      v208[5] = (uint64_t *)v206;
      if (v215)
      {
        (*(void (**)(uint64_t *))(*v215 + 8))(v215);
        if ((_QWORD *)((char *)++v176 - *v260) == (_QWORD *)4096)
          goto LABEL_298;
        goto LABEL_225;
      }
LABEL_297:
      if ((_QWORD *)((char *)++v176 - *v175) == (_QWORD *)4096)
        goto LABEL_298;
LABEL_225:
      if (v176 == (_QWORD *)v253)
        goto LABEL_316;
    }
    v196 = v258 - v177;
    if (v258 - v177 <= -3)
      abort();
    v197 = v196 >> 1;
    if (__sza - (unint64_t)v177 <= (v196 >> 1) + 1)
      v198 = v197 + 1;
    else
      v198 = __sza - (_QWORD)v177;
    if (__sza - (unint64_t)v177 >= 0x7FFFFFFFFFFFFFFELL)
      v198 = 0x7FFFFFFFFFFFFFFFLL;
    if (!v198)
      goto LABEL_337;
    if (v198 < 0)
      goto LABEL_338;
    __szb = 2 * v198;
    v199 = operator new(2 * v198);
    v200 = &v199[2 * v197];
    *(_WORD *)v200 = v187;
    v195 = v200 + 2;
    if (v258 == v177)
    {
      v166 = this;
      v203 = __szb;
LABEL_265:
      __sza = (size_t)&v199[v203];
      if (v177)
        operator delete(v177);
      v177 = v200;
      goto LABEL_268;
    }
    v201 = v258 - v177 - 2;
    if (v201 < 0x5E
      || (v228 = (v258 - 2 - v177) & 0xFFFFFFFFFFFFFFFELL,
          &v199[(v196 & 0xFFFFFFFFFFFFFFFELL) - 2 - v228] > &v199[(v196 & 0xFFFFFFFFFFFFFFFELL) - 2])
      || &v258[-v228 - 2] > v258 - 2)
    {
      v202 = v258;
    }
    else
    {
      if ((unint64_t)(&v258[-(v196 & 0xFFFFFFFFFFFFFFFELL)] - v199) >= 0x20)
      {
        v229 = (v201 >> 1) + 1;
        v230 = 2 * (v229 & 0xFFFFFFFFFFFFFFF0);
        v202 = &v258[-v230];
        v200 -= v230;
        v231 = &v199[2 * v197 - 16];
        v232 = v258 - 16;
        v233 = v229 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          v234 = *(_OWORD *)v232;
          *(v231 - 1) = *((_OWORD *)v232 - 1);
          *v231 = v234;
          v231 -= 2;
          v232 -= 32;
          v233 -= 16;
        }
        while (v233);
        v166 = this;
        v203 = __szb;
        if (v229 == (v229 & 0xFFFFFFFFFFFFFFF0))
          goto LABEL_265;
        goto LABEL_262;
      }
      v202 = v258;
    }
    v166 = this;
    v203 = __szb;
    do
    {
LABEL_262:
      v204 = *((_WORD *)v202 - 1);
      v202 -= 2;
      *((_WORD *)v200 - 1) = v204;
      v200 -= 2;
    }
    while (v202 != v177);
    goto LABEL_265;
  }
  v140 = (char **)((char *)this + 32);
  v141 = (char **)((char *)this + 8);
  while (1)
  {
    v142 = *(unsigned __int16 *)(*(_QWORD *)v138 + 8);
    v143 = (char **)*v140;
    if (!*v140)
      goto LABEL_191;
    v144 = (char **)((char *)this + 32);
    do
    {
      v145 = *((unsigned __int16 *)v143 + 16);
      v146 = v145 >= v142;
      if (v145 >= v142)
        v147 = v143;
      else
        v147 = v143 + 1;
      if (v146)
        v144 = v143;
      v143 = (char **)*v147;
    }
    while (*v147);
    if (v144 == v140 || v142 < *((unsigned __int16 *)v144 + 16))
    {
LABEL_191:
      v148 = 1;
      v149 = (char **)*v141;
      if (!*v141)
        goto LABEL_206;
      goto LABEL_192;
    }
    if (v261 > (uint64_t *)v144[5])
      break;
LABEL_215:
    v138 += 8;
    if (v138 - v137 == 4096)
    {
      v165 = v136[1];
      ++v136;
      v137 = v165;
      v138 = v165;
    }
    if (v138 == v139)
      goto LABEL_217;
  }
  v148 = 0;
  v149 = (char **)*v141;
  if (!*v141)
    goto LABEL_206;
LABEL_192:
  v150 = (char **)((char *)this + 8);
  do
  {
    v151 = *((unsigned __int16 *)v149 + 16);
    v152 = v151 >= v142;
    if (v151 >= v142)
      v153 = v149;
    else
      v153 = v149 + 1;
    if (v152)
      v150 = v149;
    v149 = (char **)*v153;
  }
  while (*v153);
  if (v150 != v141 && *((unsigned __int16 *)v150 + 16) <= v142)
  {
    v154 = v150[5];
    if (v154)
    {
      v155 = *((unsigned __int16 *)v154 + 5);
      goto LABEL_207;
    }
  }
LABEL_206:
  v155 = 0;
LABEL_207:
  if (v148)
    v156 = *(unsigned __int16 *)(*(_QWORD *)v138 + 10) + 8;
  else
    v156 = *(unsigned __int16 *)(*(_QWORD *)v138 + 10);
  v157 = v156 + v135;
  v135 = v156 + v135 - v155;
  if (v157 - v155 > 0)
  {
    if (*((_DWORD *)this + 12) < v135)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        v272 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_dictionary.cc";
        *(_QWORD *)v273 = (unint64_t)v257 & 0xFFFFFFFF00000000 | 0x6D9;
        *(_QWORD *)&v273[8] = &v263;
        v264[0] = "attr: ";
        v264[1] = &v272;
        v279 = v259 & 0xFFFFFFFF00000000 | *(unsigned __int16 *)(*(_QWORD *)v138 + 8);
        v280 = v264;
        *(_QWORD *)&v276 = " old_length: ";
        *((_QWORD *)&v276 + 1) = &v279;
        v257 = *(unsigned __int16 **)v273;
        v259 = v279;
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v158, v159, v160, v161, v162, v163, v164, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_dictionary.cc");
      }
      v137 = *v136;
    }
    goto LABEL_215;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
  {
    v272 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_dictionary.cc";
    *(_QWORD *)v273 = 1690;
    *(_QWORD *)&v273[8] = &v279;
    *(_QWORD *)&v276 = "attr: ";
    *((_QWORD *)&v276 + 1) = &v272;
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v236, v237, v238, v239, v240, v241, v242, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_dictionary.cc");
  }
  *(_BYTE *)(a3 + 36) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  v174 = 3;
LABEL_321:
  *(_DWORD *)a3 = v174;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 38) = 0;
  *(_BYTE *)(a3 + 40) = 0;
  *(_BYTE *)(a3 + 72) = 0;
  if (v271)
    goto LABEL_22;
LABEL_23:
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
}

_QWORD *cricket::StunDictionaryWriter::CreateDelta@<X0>(_QWORD *this@<X0>, uint64_t *a2@<X8>)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  size_t v7;
  size_t v8;
  size_t v9;
  size_t v10;
  void *v11;
  void *v12;
  void *v13;
  unsigned int v14;
  size_t v15;
  size_t v16;
  void *v17;
  void *v18;
  void *v19;
  unsigned int v20;
  size_t v21;
  size_t v22;
  size_t v23;
  void *v24;
  void *v25;
  void *v26;
  size_t v27;
  void *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  size_t __n;
  size_t v39;
  void *__src;

  if (*(_BYTE *)this || (v3 = this, this[3] == this[4]))
  {
    *a2 = 0;
  }
  else
  {
    this = (_QWORD *)operator new[]();
    v39 = 4096;
    __src = this;
    *this = 0x800FFFF01008877;
    v4 = v3[3];
    v5 = v3[4];
    *((_WORD *)this + 4) = 1024;
    if (v4 == v5)
    {
      __break(1u);
    }
    else
    {
      *(_QWORD *)((char *)this + 10) = bswap64(*(_QWORD *)(v5 - 16));
      __n = 18;
      while (1)
      {
        v6 = *(unsigned __int16 *)(*(_QWORD *)(v4 + 8) + 8);
        v7 = __n;
        v8 = __n + 2;
        v9 = __n;
        if (v39 < __n + 2)
        {
          if (v39 + (v39 >> 1) <= v8)
            v10 = __n + 2;
          else
            v10 = v39 + (v39 >> 1);
          v11 = (void *)operator new[]();
          v12 = v11;
          v13 = __src;
          if (__src)
          {
            memcpy(v11, __src, __n);
            __src = v12;
            MEMORY[0x20BD0ADD4](v13, 0x1000C8077774924);
          }
          else
          {
            __src = v11;
          }
          v39 = v10;
          v9 = __n;
        }
        *(_WORD *)((char *)__src + v9) = __rev16(v6);
        __n = v8;
        v14 = *(unsigned __int16 *)(*(_QWORD *)(v4 + 8) + 10);
        v15 = v7 + 4;
        if (v39 < v15)
        {
          if (v39 + (v39 >> 1) <= v15)
            v16 = v15;
          else
            v16 = v39 + (v39 >> 1);
          v17 = (void *)operator new[]();
          v18 = v17;
          v19 = __src;
          if (__src)
          {
            memcpy(v17, __src, __n);
            __src = v18;
            MEMORY[0x20BD0ADD4](v19, 0x1000C8077774924);
          }
          else
          {
            __src = v17;
          }
          v39 = v16;
          v8 = __n;
        }
        *(_WORD *)((char *)__src + v8) = __rev16(v14);
        __n = v15;
        v20 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 8) + 16))(*(_QWORD *)(v4 + 8));
        v21 = __n;
        v22 = __n + 2;
        if (v39 < __n + 2)
        {
          if (v39 + (v39 >> 1) <= v22)
            v23 = __n + 2;
          else
            v23 = v39 + (v39 >> 1);
          v24 = (void *)operator new[]();
          v25 = v24;
          v26 = __src;
          if (__src)
          {
            memcpy(v24, __src, __n);
            __src = v25;
            MEMORY[0x20BD0ADD4](v26, 0x1000C8077774924);
          }
          else
          {
            __src = v24;
          }
          v39 = v23;
          v21 = __n;
        }
        *(_WORD *)((char *)__src + v21) = bswap32(v20) >> 16;
        __n = v22;
        if (((*(uint64_t (**)(_QWORD, size_t *))(**(_QWORD **)(v4 + 8) + 40))(*(_QWORD *)(v4 + 8), &__n) & 1) == 0)
          break;
        v4 += 16;
        if (v4 == v5)
        {
          v27 = __n;
          v28 = __src;
          v29 = operator new();
          *(_WORD *)(v29 + 8) = -16292;
          *(_QWORD *)v29 = &off_24C0C15A0;
          v30 = (void *)operator new[]();
          memcpy(v30, v28, v27);
          *(_QWORD *)(v29 + 16) = v30;
          *(_WORD *)(v29 + 10) = v27;
          *a2 = v29;
          this = __src;
          __src = 0;
          if (!this)
            return this;
          return (_QWORD *)MEMORY[0x20BD0ADD4](this, 0x1000C8077774924);
        }
      }
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      {
        *a2 = 0;
        this = __src;
        __src = 0;
        if (!this)
          return this;
      }
      else
      {
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v31, v32, v33, v34, v35, v36, v37, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_dictionary.cc");
        *a2 = 0;
        this = __src;
        __src = 0;
        if (!this)
          return this;
      }
      return (_QWORD *)MEMORY[0x20BD0ADD4](this, 0x1000C8077774924);
    }
  }
  return this;
}

void cricket::StunDictionaryWriter::ApplyDeltaAck(cricket::StunDictionaryWriter *this, const cricket::StunUInt64Attribute *a2)
{
  char *v3;
  char *v4;
  unint64_t v5;
  char *i;
  uint64_t v7;
  uint64_t *v8;
  uint64_t **v9;
  char *v10;
  unsigned int v11;
  uint64_t **v12;
  uint64_t *v13;
  unsigned int v14;
  BOOL v15;
  uint64_t **v16;
  uint64_t *v17;
  uint64_t **v18;
  uint64_t *v19;
  BOOL v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  double *v25;
  char *v26;
  unint64_t v27;
  unint64_t v28;
  double *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const double *v47;
  double *v48;
  double *v49;
  uint64_t v50;
  uint64_t v51;
  float64x2x2_t v52;
  float64x2x2_t v53;

  v4 = (char *)*((_QWORD *)this + 3);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v4 != v3)
  {
    v5 = *((_QWORD *)a2 + 2);
    while (*(_QWORD *)v4 > v5)
    {
      v4 += 16;
      if (v4 == v3)
        return;
    }
    if (v4 != v3)
    {
      for (i = v4 + 16; i != v3; i += 16)
      {
        if (*(_QWORD *)i > v5)
        {
          v7 = *((_QWORD *)i + 1);
          *(_QWORD *)v4 = *(_QWORD *)i;
          *((_QWORD *)v4 + 1) = v7;
          v4 += 16;
        }
      }
    }
  }
  if (v4 != v3)
  {
    v9 = (uint64_t **)((char *)this + 56);
    v8 = (uint64_t *)*((_QWORD *)this + 7);
    if (v8)
    {
      v10 = v4;
LABEL_15:
      v11 = *(unsigned __int16 *)(*((_QWORD *)v10 + 1) + 8);
      v12 = (uint64_t **)((char *)this + 56);
      v13 = v8;
      do
      {
        v14 = *((unsigned __int16 *)v13 + 16);
        v15 = v14 >= v11;
        if (v14 >= v11)
          v16 = (uint64_t **)v13;
        else
          v16 = (uint64_t **)(v13 + 1);
        if (v15)
          v12 = (uint64_t **)v13;
        v13 = *v16;
      }
      while (*v16);
      if (v12 != v9 && v11 >= *((unsigned __int16 *)v12 + 16))
      {
        v17 = v12[1];
        v18 = v12;
        if (v17)
        {
          do
          {
            v19 = v17;
            v17 = (uint64_t *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            v19 = v18[2];
            v20 = *v19 == (_QWORD)v18;
            v18 = (uint64_t **)v19;
          }
          while (!v20);
        }
        if (*((uint64_t ***)this + 6) == v12)
          *((_QWORD *)this + 6) = v19;
        --*((_QWORD *)this + 8);
        std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v8, (uint64_t *)v12);
        v21 = v12[5];
        v12[5] = 0;
        if (v21)
          (*(void (**)(uint64_t *))(*v21 + 8))(v21);
        operator delete(v12);
        v3 = (char *)*((_QWORD *)this + 4);
      }
      while (1)
      {
        v10 += 16;
        if (v10 == v3)
          break;
        v8 = *v9;
        if (*v9)
          goto LABEL_15;
      }
    }
  }
  v22 = v3 - v4;
  if (v3 < v4)
  {
    __break(1u);
  }
  else if (v4 != v3)
  {
    v23 = *((_QWORD *)this + 3);
    v24 = (unint64_t)&v4[-v23];
    v25 = (double *)(v23 + ((unint64_t)&v4[-v23] & 0xFFFFFFFFFFFFFFF0));
    v26 = (char *)v25 + v22;
    if ((char *)v25 + v22 == v3)
    {
      *((_QWORD *)this + 4) = v25;
      return;
    }
    v27 = v24 & 0xFFFFFFFFFFFFFFF0;
    v28 = (unint64_t)&v4[-v23 - (v24 & 0xFFFFFFFFFFFFFFF0) - 16];
    if (v28 >= 0x1D0)
    {
      v30 = v27 + v23;
      v31 = (unint64_t)&v4[-v27 - v23 - 16] & 0xFFFFFFFFFFFFFFF0;
      v32 = v27 + v23 + v31;
      v33 = v32 + 8;
      v34 = v22 + v23 + v27;
      v35 = v34 + v31;
      v36 = v34 + v31 + 8;
      v37 = v32 + 16;
      v38 = v34 + 8;
      v40 = v30 + 8 < v35 + 16 && v38 < v37;
      if ((unint64_t)v26 >= v33 || (unint64_t)v25 >= v36)
      {
        if (v40)
        {
          v29 = v25;
        }
        else
        {
          v42 = v22 >> 4;
          v43 = (v28 >> 4) + 1;
          v44 = 2 * (v43 & 0x1FFFFFFFFFFFFFFCLL);
          v29 = &v25[v44];
          v26 += v44 * 8;
          v45 = 2 * v42;
          v46 = v43 & 0x1FFFFFFFFFFFFFFCLL;
          do
          {
            v47 = &v25[v45];
            v52 = vld2q_f64(v47);
            v47 += 4;
            v53 = vld2q_f64(v47);
            v48 = v25 + 8;
            vst2q_f64(v25, v52);
            v49 = v25 + 4;
            vst2q_f64(v49, v53);
            v25 = v48;
            v46 -= 4;
          }
          while (v46);
          if (v43 == (v43 & 0x1FFFFFFFFFFFFFFCLL))
            goto LABEL_59;
        }
      }
      else
      {
        v29 = v25;
      }
    }
    else
    {
      v29 = (double *)(v23 + ((unint64_t)&v4[-v23] & 0xFFFFFFFFFFFFFFF0));
    }
    do
    {
      v50 = *(_QWORD *)v26;
      v51 = *((_QWORD *)v26 + 1);
      v26 += 16;
      *(_QWORD *)v29 = v50;
      *((_QWORD *)v29 + 1) = v51;
      v29 += 2;
    }
    while (v26 != v3);
LABEL_59:
    *((_QWORD *)this + 4) = v29;
  }
}

uint64_t cricket::UDPPort::Init(cricket::UDPPort *this)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  std::string *v28;
  rtc::AsyncPacketSocket *v29;
  uint64_t v30;
  _QWORD v31[2];
  __int128 v32;
  _BYTE v33[8];
  int v34;
  __int128 v35;
  void *__p[2];
  uint64_t v37;
  void *v38;
  int v39;
  __int128 v40;
  __int16 v41;
  int v42;
  char v43;

  if ((*(int (**)(cricket::UDPPort *))(*(_QWORD *)this + 312))(this) <= 899)
    v2 = -1;
  else
    v2 = 120000;
  *((_DWORD *)this + 240) = v2;
  if (((*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 64))(this) & 1) != 0)
    goto LABEL_9;
  v3 = (*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 216))(this);
  v4 = (*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 24))(this);
  rtc::Network::GetBestIP(v4, (uint64_t)v33);
  __p[0] = 0;
  __p[1] = 0;
  v37 = 0;
  v38 = &unk_24C0ACDA0;
  v43 = 0;
  v39 = v34;
  v40 = v35;
  v42 = 0;
  v41 = 0;
  v5 = (*(uint64_t (**)(uint64_t, void **, _QWORD, _QWORD))(*(_QWORD *)v3 + 16))(v3, __p, *((unsigned __int16 *)this + 280), *((unsigned __int16 *)this + 281));
  v10 = v5;
  *((_QWORD *)this + 116) = v5;
  if (SHIBYTE(v37) < 0)
  {
    operator delete(__p[0]);
    v10 = *((_QWORD *)this + 116);
    if (v10)
      goto LABEL_7;
LABEL_11:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      return 0;
    (*(void (**)(void **__return_ptr, cricket::UDPPort *))(*(_QWORD *)this + 176))(__p, this);
    rtc::webrtc_logging_impl::Log("\r\n\t", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_port.cc");
    if (SHIBYTE(v37) < 0)
      operator delete(__p[0]);
    return 0;
  }
  if (!v5)
    goto LABEL_11;
LABEL_7:
  v31[0] = this;
  *(_QWORD *)&v32 = absl::internal_any_invocable::LocalManagerTrivial;
  *((_QWORD *)&v32 + 1) = absl::internal_any_invocable::LocalInvoker<false,void,cricket::UDPPort::Init(void)::$_0 &,rtc::AsyncPacketSocket *,rtc::ReceivedPacket const&>;
  if (!*(_QWORD *)(v10 + 336))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 328))(1, v10 + 312, v10 + 312);
    *(_QWORD *)(v10 + 328) = absl::internal_any_invocable::EmptyManager;
    *(_QWORD *)(v10 + 336) = 0;
    ((void (*)(_QWORD, _QWORD *, uint64_t))v32)(0, v31, v10 + 312);
    *(_OWORD *)(v10 + 328) = v32;
    v32 = (unint64_t)absl::internal_any_invocable::EmptyManager;
    absl::internal_any_invocable::EmptyManager(1, v31, v31);
LABEL_9:
    v11 = (_QWORD *)*((_QWORD *)this + 116);
    v12 = operator new(0x30uLL);
    v12[2] = sigslot::_opaque_connection::emitter<cricket::UDPPort,rtc::AsyncPacketSocket *,rtc::SentPacket const&>;
    v12[3] = (char *)this + 232;
    *((_OWORD *)v12 + 2) = xmmword_208F17020;
    v13 = v11[9];
    v11 += 9;
    *v12 = v13;
    v12[1] = v11;
    *(_QWORD *)(v13 + 8) = v12;
    *v11 = v12;
    ++v11[2];
    (*((void (**)(char *, _QWORD *))this + 30))((char *)this + 232, v11 - 2);
    v14 = (_QWORD *)*((_QWORD *)this + 116);
    v15 = operator new(0x30uLL);
    v15[2] = sigslot::_opaque_connection::emitter<cricket::UDPPort,rtc::AsyncPacketSocket *>;
    v15[3] = (char *)this + 232;
    v15[4] = cricket::UDPPort::OnReadyToSend;
    v15[5] = 0;
    v16 = v14[16];
    v14 += 16;
    *v15 = v16;
    v15[1] = v14;
    *(_QWORD *)(v16 + 8) = v15;
    *v14 = v15;
    ++v14[2];
    (*((void (**)(char *, _QWORD *))this + 30))((char *)this + 232, v14 - 2);
    v17 = (_QWORD *)*((_QWORD *)this + 116);
    v18 = operator new(0x30uLL);
    v18[2] = sigslot::_opaque_connection::emitter<cricket::UDPPort,rtc::AsyncPacketSocket *,rtc::SocketAddress const&>;
    v18[3] = (char *)this + 232;
    v18[4] = cricket::UDPPort::OnLocalAddressReady;
    v18[5] = 0;
    v19 = v17[23];
    v17 += 23;
    *v18 = v19;
    v18[1] = v17;
    *(_QWORD *)(v19 + 8) = v18;
    *v17 = v18;
    ++v17[2];
    (*((void (**)(char *, _QWORD *))this + 30))((char *)this + 232, v17 - 2);
    return 1;
  }
  v28 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/async_packet_socket.cc", 47, "!received_packet_callback_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v6, v7, v8, v9, v30);
  return (uint64_t)cricket::UDPPort::OnReadyToSend(v28, v29);
}

_QWORD *cricket::UDPPort::OnReadyToSend(_QWORD *this, rtc::AsyncPacketSocket *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  void (*v6)(_QWORD *, _QWORD *);
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  v2 = (_QWORD *)this[84];
  v3 = this + 85;
  if (v2 != this + 85)
  {
    do
    {
      v4 = (_QWORD *)v2[13];
      this = (_QWORD *)v4[18];
      for (v4[20] = this; this != v4 + 17; this = (_QWORD *)v4[20])
      {
        v6 = (void (*)(_QWORD *, _QWORD *))this[2];
        v5 = this + 2;
        v4[20] = *(v5 - 1);
        v6(v5, v4);
      }
      v7 = (_QWORD *)v2[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v2[2];
          v9 = *v8 == (_QWORD)v2;
          v2 = v8;
        }
        while (!v9);
      }
      v2 = v8;
    }
    while (v8 != v3);
  }
  return this;
}

void cricket::UDPPort::OnLocalAddressReady(cricket::UDPPort *this, rtc::AsyncPacketSocket *a2, void **a3)
{
  int v5;
  BOOL v6;
  uint64_t v8;
  int v9;
  int v10;
  cricket::UDPPort *v12;
  cricket::UDPPort *v13;
  cricket::UDPPort *v14;
  cricket::UDPPort *v15;
  _QWORD *v16;
  _QWORD *v17;
  void (*v18)(_QWORD *, cricket::UDPPort *);
  void *__p[6];
  int v20;
  __int16 v21;
  int v22;
  char v23;
  void *__dst[2];
  void *v25;
  void *v26;
  _DWORD v27[6];
  __int16 v28;
  int v29;
  char v30;
  __int128 v31;

  __dst[0] = 0;
  __dst[1] = 0;
  v25 = 0;
  v26 = &unk_24C0ACDA0;
  memset(v27, 0, 20);
  if (__dst != a3)
  {
    if (*((char *)a3 + 23) < 0)
    {
      std::string::__assign_no_alias<true>(__dst, (char *)*a3, (size_t)a3[1]);
    }
    else
    {
      *(_OWORD *)__dst = *(_OWORD *)a3;
      v25 = a3[2];
    }
  }
  v5 = *((_DWORD *)a3 + 8);
  v27[0] = v5;
  *(_OWORD *)&v27[1] = *(_OWORD *)((char *)a3 + 36);
  v28 = *((_WORD *)a3 + 28);
  v30 = *((_BYTE *)a3 + 64);
  v29 = *((_DWORD *)a3 + 15);
  if (v5 == 2)
  {
    if (v27[1])
      goto LABEL_28;
  }
  else
  {
    if (v5 != 30)
      goto LABEL_28;
    *(_OWORD *)((char *)&__p[1] + 4) = *MEMORY[0x24BDAE878];
    v6 = *(void **)&v27[1] == *(void **)((char *)&__p[1] + 4) && *(void **)&v27[3] == *(void **)((char *)&__p[2] + 4);
    if (!v6)
    {
      v31 = rtc::kV4MappedPrefix;
      if (*(_QWORD *)&v27[1] != (_QWORD)rtc::kV4MappedPrefix
        || *(_QWORD *)&v27[3] != *((_QWORD *)&rtc::kV4MappedPrefix + 1))
      {
        goto LABEL_28;
      }
    }
  }
  if (*((_BYTE *)this + 992)
    && *(_QWORD *)((*(uint64_t (**)(cricket::UDPPort *, rtc::AsyncPacketSocket *))(*(_QWORD *)this + 24))(this, a2)+ 112))
  {
    memset(&__p[1], 0, 20);
    __p[0] = &unk_24C0ACDA0;
    v8 = (*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 24))(this);
    v9 = (*(uint64_t (**)(_QWORD, _QWORD, void **))(**(_QWORD **)(v8 + 112) + 16))(*(_QWORD *)(v8 + 112), v27[0], __p);
    v10 = (int)__p[1];
    if (v9 && LODWORD(__p[1]) != 0)
    {
      if (SHIBYTE(v25) < 0)
      {
        *(_BYTE *)__dst[0] = 0;
        __dst[1] = 0;
        v10 = (int)__p[1];
      }
      else
      {
        LOBYTE(__dst[0]) = 0;
        HIBYTE(v25) = 0;
      }
      v30 = 0;
      *(_OWORD *)&v27[1] = *(_OWORD *)((char *)&__p[1] + 4);
      v27[0] = v10;
      v29 = 0;
    }
  }
LABEL_28:
  memset(__p, 0, 24);
  __p[3] = &unk_24C0ACDA0;
  v23 = 0;
  v21 = 0;
  v22 = 0;
  __p[4] = 0;
  __p[5] = 0;
  v20 = 0;
  cricket::Port::AddAddress((uint64_t)this, (__int128 *)__dst, (const rtc::SocketAddress *)__dst, (uint64_t)__p, (char *)&cricket::UDP_PROTOCOL_NAME, 3uLL, &byte_208EB9246, 0, &byte_208EB9246, 0, 0, 126, 0, &byte_208EB9246, 0, 0);
  if (SHIBYTE(__p[2]) < 0)
  {
    operator delete(__p[0]);
    if (*((_QWORD *)this + 101))
    {
LABEL_30:
      v12 = (cricket::UDPPort *)*((_QWORD *)this + 99);
      if (v12 != (cricket::UDPPort *)((char *)this + 800))
      {
        do
        {
          v13 = (cricket::UDPPort *)*((_QWORD *)v12 + 1);
          v14 = v12;
          if (v13)
          {
            do
            {
              v15 = v13;
              v13 = *(cricket::UDPPort **)v13;
            }
            while (v13);
          }
          else
          {
            do
            {
              v15 = (cricket::UDPPort *)*((_QWORD *)v14 + 2);
              v6 = *(_QWORD *)v15 == (_QWORD)v14;
              v14 = v15;
            }
            while (!v6);
          }
          cricket::UDPPort::SendStunBindingRequest(this, (void **)v12 + 4);
          v12 = v15;
        }
        while (v15 != (cricket::UDPPort *)((char *)this + 800));
      }
      goto LABEL_45;
    }
  }
  else if (*((_QWORD *)this + 101))
  {
    goto LABEL_30;
  }
  if (*((_DWORD *)this + 184) != 1 && !*((_BYTE *)this + 952) && !(*((_QWORD *)this + 104) + *((_QWORD *)this + 107)))
  {
    *((_BYTE *)this + 952) = 1;
    v16 = (_QWORD *)*((_QWORD *)this + 53);
    for (*((_QWORD *)this + 55) = v16; v16 != (_QWORD *)((char *)this + 416); v16 = (_QWORD *)*((_QWORD *)this + 55))
    {
      v18 = (void (*)(_QWORD *, cricket::UDPPort *))v16[2];
      v17 = v16 + 2;
      *((_QWORD *)this + 55) = *(v17 - 1);
      v18(v17, this);
    }
  }
LABEL_45:
  if (SHIBYTE(v25) < 0)
    operator delete(__dst[0]);
}

void cricket::UDPPort::~UDPPort(cricket::UDPPort *this)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  cricket::UDPPort *v6;
  uint64_t v7;

  *(_QWORD *)this = &off_24C0C16C0;
  *((_QWORD *)this + 29) = &unk_24C0C1838;
  if (!*((_BYTE *)this + 720))
  {
    v2 = *((_QWORD *)this + 116);
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  }
  v3 = *((_QWORD *)this + 118);
  *((_QWORD *)this + 118) = 0;
  if (v3)
  {
    std::__tree<std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>,std::__map_value_compare<rtc::SocketAddress,std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>,std::less<rtc::SocketAddress>,true>,std::allocator<std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>>>::destroy(*(char **)(v3 + 48));
    v4 = *(_QWORD **)(v3 + 32);
    if (v4 == (_QWORD *)(v3 + 8))
    {
      v5 = 4;
      v4 = (_QWORD *)(v3 + 8);
    }
    else
    {
      if (!v4)
      {
LABEL_10:
        MEMORY[0x20BD0ADEC](v3, 0x1020C40460B878DLL);
        goto LABEL_11;
      }
      v5 = 5;
    }
    (*(void (**)(void))(*v4 + 8 * v5))();
    goto LABEL_10;
  }
LABEL_11:
  v6 = (cricket::UDPPort *)*((_QWORD *)this + 115);
  if (v6 == (cricket::UDPPort *)((char *)this + 896))
  {
    v7 = 4;
    v6 = (cricket::UDPPort *)((char *)this + 896);
    goto LABEL_15;
  }
  if (v6)
  {
    v7 = 5;
LABEL_15:
    (*(void (**)(void))(*(_QWORD *)v6 + 8 * v7))();
  }
  std::__tree<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>>>::destroy((uint64_t)this + 872, *((char **)this + 110));
  std::__tree<rtc::SocketAddress>::destroy((uint64_t)this + 840, *((char **)this + 106));
  std::__tree<rtc::SocketAddress>::destroy((uint64_t)this + 816, *((char **)this + 103));
  std::__tree<rtc::SocketAddress>::destroy((uint64_t)this + 792, *((char **)this + 100));
  cricket::Port::~Port(this);
}

{
  cricket::UDPPort::~UDPPort(this);
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'cricket::UDPPort::~UDPPort(cricket::UDPPort *this)
{
  cricket::UDPPort::~UDPPort((cricket::UDPPort *)((char *)this - 232));
}

{
  cricket::UDPPort::~UDPPort((cricket::UDPPort *)((char *)this - 232));
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::UDPPort::PrepareAddress(cricket::UDPPort *this)
{
  rtc::AsyncPacketSocket *v2;
  void *__p[2];
  char v4;

  if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 116) + 56))(*((_QWORD *)this + 116)) == 2)
  {
    (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 116) + 16))(__p);
    cricket::UDPPort::OnLocalAddressReady(this, v2, __p);
    if (v4 < 0)
      operator delete(__p[0]);
  }
}

uint64_t *cricket::UDPPort::CreateConnection(uint64_t *result, uint64_t a2)
{
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  int v7;
  _QWORD *v8;
  cricket::Connection *v9;
  uint64_t v10;
  unsigned int v11;
  _QWORD *v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int *v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int v27;
  _QWORD *v28;
  uint64_t v29;

  v3 = result;
  v4 = (_QWORD *)(a2 + 32);
  if ((*(char *)(a2 + 55) & 0x80000000) == 0)
  {
    v5 = *(unsigned __int8 *)(a2 + 55);
    goto LABEL_8;
  }
  v5 = *(_QWORD *)(a2 + 40);
  if ((v5 & 0x8000000000000000) == 0)
  {
    v4 = (_QWORD *)*v4;
    if (!v5 || v4 != 0)
    {
LABEL_8:
      if (!(*(unsigned int (**)(uint64_t *, _QWORD *, uint64_t))(*result + 72))(result, v4, v5))
        return 0;
      rtc::Network::GetBestIP(v3[69], (uint64_t)&v28);
      v7 = *(_DWORD *)(a2 + 112);
      if (v7 != (_DWORD)v29
        || v7 == 30 && ((WORD2(v29) & 0xC0FF) == 33022) != ((*(_QWORD *)(a2 + 116) & 0xC0FFLL) == 33022))
      {
        return 0;
      }
      v8 = (_QWORD *)(*(uint64_t (**)(uint64_t *))(*v3 + 136))(v3);
      if (*v8 == v8[1])
        return 0;
      v9 = (cricket::Connection *)operator new();
      v10 = v3[97];
      if (v10 && (v11 = atomic_load((unsigned int *)(v10 + 4)), v11 != 1))
      {
        v12 = (_QWORD *)v3[97];
        if (!v12)
        {
          v21 = v3[98];
LABEL_34:
          v28 = v12;
          v29 = v21;
          cricket::Connection::Connection((uint64_t)v9, (uint64_t *)&v28, 0, (std::string *)a2);
          if (v28)
          {
            v25 = (unsigned int *)v28 + 1;
            do
            {
              v26 = __ldaxr(v25);
              v27 = v26 - 1;
            }
            while (__stlxr(v27, v25));
            if (!v27)
              MEMORY[0x20BD0ADEC]();
          }
          *(_QWORD *)v9 = &unk_24C0B15F8;
          *((_DWORD *)v9 + 706) = 0;
          cricket::Port::AddOrReplaceConnection((cricket::Port *)v3, v9);
          return (uint64_t *)v9;
        }
      }
      else
      {
        v12 = (_QWORD *)operator new();
        *v12 = 1;
        v13 = (unsigned int *)v12 + 1;
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
        v15 = v3[97];
        if (v15)
        {
          v16 = (unsigned int *)(v15 + 4);
          do
          {
            v17 = __ldaxr(v16);
            v18 = v17 - 1;
          }
          while (__stlxr(v18, v16));
          if (!v18)
            MEMORY[0x20BD0ADEC]();
        }
        v3[97] = (uint64_t)v12;
      }
      v19 = (unsigned int *)v12 + 1;
      do
        v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
      v21 = v3[98];
      do
        v22 = __ldxr(v19);
      while (__stxr(v22 + 1, v19));
      do
      {
        v23 = __ldaxr(v19);
        v24 = v23 - 1;
      }
      while (__stlxr(v24, v19));
      if (!v24)
        MEMORY[0x20BD0ADEC](v12, 0x1000C404A09149ALL);
      goto LABEL_34;
    }
  }
  __break(1u);
  return result;
}

uint64_t cricket::UDPPort::SendTo(cricket::UDPPort *this, const void *a2, uint64_t a3, const rtc::SocketAddress *a4, const rtc::PacketOptions *a5)
{
  _BYTE *v10;
  _BYTE *v11;
  size_t v12;
  char *v13;
  char *v14;
  __int128 v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *__p;
  char v29;
  void *v30;
  char v31;
  __int128 v32;
  int v33;
  void *v34;
  void *v35;
  char *v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  __int16 v41;

  v32 = *(_OWORD *)a5;
  v33 = *((_DWORD *)a5 + 4);
  v35 = 0;
  v36 = 0;
  v34 = 0;
  v11 = (_BYTE *)*((_QWORD *)a5 + 3);
  v10 = (_BYTE *)*((_QWORD *)a5 + 4);
  v12 = v10 - v11;
  if (v10 != v11)
  {
    if ((v12 & 0x8000000000000000) != 0)
      abort();
    v13 = (char *)operator new(v10 - v11);
    v14 = &v13[v12];
    v34 = v13;
    v36 = &v13[v12];
    memcpy(v13, v11, v12);
    v35 = v14;
  }
  v15 = *((_OWORD *)a5 + 4);
  v37 = *((_OWORD *)a5 + 3);
  v38 = v15;
  v39 = *((_OWORD *)a5 + 5);
  v40 = *((_QWORD *)a5 + 12);
  v41 = *((_WORD *)a5 + 52);
  v16 = (*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 128))(this);
  if (v16 < 4)
    v17 = v16 + 1;
  else
    v17 = 0;
  DWORD2(v38) = v17;
  WORD6(v38) = *(_WORD *)((*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 24))(this) + 286);
  BYTE14(v38) = 1;
  v18 = (*(uint64_t (**)(_QWORD, const void *, uint64_t, const rtc::SocketAddress *, __int128 *))(**((_QWORD **)this + 116) + 40))(*((_QWORD *)this + 116), a2, a3, a4, &v32);
  if ((v18 & 0x80000000) != 0)
  {
    *((_DWORD *)this + 234) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 116) + 80))(*((_QWORD *)this + 116));
    v19 = *((_DWORD *)this + 235);
    if (v19 <= 4)
    {
      *((_DWORD *)this + 235) = v19 + 1;
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      {
        (*(void (**)(void **__return_ptr, cricket::UDPPort *))(*(_QWORD *)this + 176))(&v30, this);
        rtc::SocketAddress::ToSensitiveNameAndAddressString(a4, (unint64_t)&__p);
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v20, v21, v22, v23, v24, v25, v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_port.cc");
        if (v29 < 0)
          operator delete(__p);
        if (v31 < 0)
          operator delete(v30);
      }
    }
  }
  else
  {
    *((_DWORD *)this + 235) = 0;
  }
  if (v34)
  {
    v35 = v34;
    operator delete(v34);
  }
  return v18;
}

uint64_t cricket::UDPPort::UpdateNetworkCost(cricket::UDPPort *this)
{
  uint64_t result;
  int v3;

  cricket::Port::UpdateNetworkCost(this);
  result = (*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 312))(this);
  if ((int)result <= 899)
    v3 = -1;
  else
    v3 = 120000;
  *((_DWORD *)this + 240) = v3;
  return result;
}

uint64_t cricket::UDPPort::StunDscpValue(cricket::UDPPort *this)
{
  return *((unsigned int *)this + 241);
}

uint64_t cricket::UDPPort::SetOption(uint64_t a1, int a2, int a3)
{
  if (a2 == 5)
    *(_DWORD *)(a1 + 964) = a3;
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 928) + 72))(*(_QWORD *)(a1 + 928));
}

uint64_t cricket::UDPPort::GetOption(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 928) + 64))(*(_QWORD *)(a1 + 928));
}

uint64_t cricket::UDPPort::GetError(cricket::UDPPort *this)
{
  return *((unsigned int *)this + 234);
}

uint64_t cricket::UDPPort::HandleIncomingPacket(uint64_t a1, uint64_t a2, uint64_t a3)
{
  cricket::UDPPort::OnReadPacket(a1, a3);
  return 1;
}

uint64_t cricket::UDPPort::OnReadPacket(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;

  v4 = *(_QWORD **)(a1 + 800);
  if (v4)
  {
    v5 = *(char **)(a2 + 32);
    v6 = a1 + 800;
    v7 = a1 + 800;
    do
    {
      v8 = rtc::SocketAddress::operator<((uint64_t)(v4 + 4), v5);
      v9 = v4 + 1;
      if (!v8)
      {
        v9 = v4;
        v7 = (uint64_t)v4;
      }
      v4 = (_QWORD *)*v9;
    }
    while (*v9);
    if (v7 != v6 && (rtc::SocketAddress::operator<((uint64_t)v5, (char *)(v7 + 32)) & 1) == 0)
      return cricket::StunRequestManager::CheckResponse((uint64_t **)(a1 + 864), *(void ***)a2, *(_QWORD *)(a2 + 8));
  }
  v10 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 88))(a1, *(_QWORD *)(a2 + 32));
  if (v10)
    return cricket::Connection::OnReadPacket(v10, (_QWORD *)a2);
  else
    return cricket::Port::OnReadPacket(a1, (uint64_t *)a2, 0);
}

BOOL cricket::UDPPort::SupportsProtocol(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  if (a3 != 3)
    return 0;
  return *a2 == (unsigned __int16)cricket::UDP_PROTOCOL_NAME && *((_BYTE *)a2 + 2) == 112;
}

uint64_t cricket::UDPPort::GetProtocol(cricket::UDPPort *this)
{
  return 0;
}

uint64_t cricket::UDPPort::GetStunStats(uint64_t result, uint64_t a2)
{
  int v2;
  uint64_t v3;

  v2 = *(unsigned __int8 *)(a2 + 24);
  v3 = *(_QWORD *)(result + 984);
  *(_OWORD *)a2 = *(_OWORD *)(result + 968);
  *(_QWORD *)(a2 + 16) = v3;
  if (!v2)
    *(_BYTE *)(a2 + 24) = 1;
  return result;
}

uint64_t cricket::UDPPort::PostAddAddress(uint64_t this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void (*v5)(uint64_t, _QWORD *);
  uint64_t v6;
  void (*v7)(uint64_t, _QWORD *);

  if (*(_DWORD *)(this + 736) != 1)
  {
    v1 = (_QWORD *)this;
    if (!*(_BYTE *)(this + 952))
    {
      v2 = *(_QWORD *)(this + 832);
      v3 = v2 + *(_QWORD *)(this + 856);
      if (*(_QWORD *)(this + 808) == v3)
      {
        *(_BYTE *)(this + 952) = 1;
        if (v2 || !v3 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)this + 64))(this))
        {
          this = v1[53];
          for (v1[55] = this; (_QWORD *)this != v1 + 52; this = v1[55])
          {
            v5 = *(void (**)(uint64_t, _QWORD *))(this + 16);
            v4 = this + 16;
            v1[55] = *(_QWORD *)(v4 - 8);
            v5(v4, v1);
          }
        }
        else
        {
          this = v1[60];
          for (v1[62] = this; (_QWORD *)this != v1 + 59; this = v1[62])
          {
            v7 = *(void (**)(uint64_t, _QWORD *))(this + 16);
            v6 = this + 16;
            v1[62] = *(_QWORD *)(v6 - 8);
            v7(v6, v1);
          }
        }
      }
    }
  }
  return this;
}

uint64_t cricket::UDPPort::OnSentPacket(cricket::UDPPort *this, rtc::AsyncPacketSocket *a2, const rtc::SentPacket *a3)
{
  char *v4;
  uint64_t result;
  uint64_t v7;
  void (*v8)(uint64_t, const rtc::SentPacket *);

  v4 = (char *)this + 192;
  result = *((_QWORD *)this + 25);
  for (*((_QWORD *)this + 27) = result; (char *)result != v4; result = *((_QWORD *)this + 27))
  {
    v8 = *(void (**)(uint64_t, const rtc::SentPacket *))(result + 16);
    v7 = result + 16;
    *((_QWORD *)this + 27) = *(_QWORD *)(v7 - 8);
    v8(v7, a3);
  }
  return result;
}

void cricket::UDPPort::SendStunBindingRequest(cricket::UDPPort *this, void **a2)
{
  BOOL v4;
  void *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  const void **v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _QWORD *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char **v41;
  uint64_t v42;
  char *v43;
  char **v44;
  char **v45;
  int v46;
  char **v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  char **v51;
  uint64_t v52;
  char *v53;
  _QWORD *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[2];
  uint64_t (*v62)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v63)(uint64_t);
  void *__p;
  __int128 v65;
  void *v66;
  void *v67;
  _BYTE v68[20];
  __int16 v69;
  int v70;
  char v71;
  void *__dst[2];
  void *v73;
  void *v74;
  _BYTE v75[20];
  __int16 v76;
  int v77;
  char v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD v81[3];
  _QWORD *v82;
  uint64_t v83;

  v83 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)a2 + 8))
    v4 = 0;
  else
    v4 = *((_BYTE *)a2 + 64) == 0;
  if (!v4)
    goto LABEL_14;
  v5 = (void *)*((unsigned __int8 *)a2 + 23);
  if ((char)v5 < 0)
    v5 = a2[1];
  if (!v5)
  {
LABEL_14:
    if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 116) + 56))(*((_QWORD *)this + 116)) == 2)
    {
      rtc::Network::GetBestIP(*((_QWORD *)this + 69), (uint64_t)__dst);
      v12 = *((_DWORD *)a2 + 8);
      if (v12 != LODWORD(__dst[1])
        || v12 == 30
        && ((WORD2(__dst[1]) & 0xC0FF) == 33022) != ((*(unint64_t *)((char *)a2 + 36) & 0xC0FF) == 33022))
      {
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
          rtc::webrtc_logging_impl::Log("\r\t", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_port.cc");
        cricket::UDPPort::OnStunBindingOrResolveRequestFailed((uint64_t)this, (rtc::SocketAddress *)a2, 701, "STUN server address is incompatible.", 0x24uLL);
      }
      else
      {
        v20 = (_QWORD *)operator new();
        if (rtc::g_clock)
        {
          v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
        }
        else
        {
          if (!dword_253EA791C)
            mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
          v21 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
              / dword_253EA791C;
        }
        v22 = v21 / 1000000;
        v23 = (const void **)operator new();
        cricket::StunMessage::StunMessage((cricket::StunMessage *)v23, 1);
        v20[1] = (char *)this + 864;
        v20[2] = v24;
        v20[3] = 0;
        *((_DWORD *)v20 + 8) = 0;
        *((_BYTE *)v20 + 36) = 0;
        v25 = operator new();
        *(_DWORD *)v25 = 0;
        *(_BYTE *)(v25 + 4) = 0;
        do
          v26 = __ldxr((unsigned int *)v25);
        while (__stxr(v26 + 1, (unsigned int *)v25));
        v20[5] = v25;
        *((_BYTE *)v20 + 48) = 1;
        *v20 = off_24C0C19F0;
        v20[7] = this;
        v20[8] = 0;
        v27 = v20 + 8;
        v20[9] = 0;
        v20[10] = 0;
        v20[12] = 0;
        v20[13] = 0;
        v20[11] = &unk_24C0ACDA0;
        *((_DWORD *)v20 + 28) = 0;
        if (v20 + 8 != a2)
        {
          if (*((char *)a2 + 23) < 0)
          {
            std::string::__assign_no_alias<true>(v27, (char *)*a2, (size_t)a2[1]);
            v23 = (const void **)v20[2];
          }
          else
          {
            *(_OWORD *)v27 = *(_OWORD *)a2;
            v20[10] = a2[2];
          }
        }
        *((_DWORD *)v20 + 24) = *((_DWORD *)a2 + 8);
        *(_OWORD *)((char *)v20 + 100) = *(_OWORD *)((char *)a2 + 36);
        *((_WORD *)v20 + 60) = *((_WORD *)a2 + 28);
        *((_BYTE *)v20 + 128) = *((_BYTE *)a2 + 64);
        *((_DWORD *)v20 + 31) = *((_DWORD *)a2 + 15);
        v20[17] = v22;
        *((_BYTE *)v20 + 48) = 0;
        __dst[0] = v20;
        std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>((uint64_t)this + 872, v23 + 5, (uint64_t)(v23 + 5), (uint64_t *)__dst);
        v29 = __dst[0];
        __dst[0] = 0;
        if (v29)
          (*(void (**)(void *))(*(_QWORD *)v29 + 8))(v29);
        v30 = v20[5];
        if (v30)
        {
          do
            v31 = __ldxr((unsigned int *)v30);
          while (__stxr(v31 + 1, (unsigned int *)v30));
          *(_BYTE *)(v30 + 4) = 1;
          do
          {
            v32 = __ldaxr((unsigned int *)v30);
            v33 = v32 - 1;
          }
          while (__stlxr(v33, (unsigned int *)v30));
          if (!v33)
            MEMORY[0x20BD0ADEC]();
        }
        else
        {
          MEMORY[4] = 1;
        }
        cricket::StunRequest::SendInternal((cricket::StunRequest *)v20);
      }
    }
    return;
  }
  if (!*((_QWORD *)this + 118))
  {
    v6 = (_QWORD *)operator new();
    v7 = (*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 216))(this);
    v81[0] = &off_24C0C1AC8;
    v81[1] = this;
    v8 = v81;
    v82 = v81;
    *v6 = v7;
    v6[1] = &off_24C0C1AC8;
    v6[2] = this;
    v6[7] = 0;
    v6[6] = 0;
    v6[4] = v6 + 1;
    v6[5] = v6 + 6;
    v9 = *((_QWORD *)this + 118);
    *((_QWORD *)this + 118) = v6;
    if (!v9)
    {
      v28 = 4;
LABEL_49:
      (*(void (**)(void))(*v8 + 8 * v28))();
      goto LABEL_50;
    }
    std::__tree<std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>,std::__map_value_compare<rtc::SocketAddress,std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>,std::less<rtc::SocketAddress>,true>,std::allocator<std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>>>::destroy(*(char **)(v9 + 48));
    v10 = *(_QWORD **)(v9 + 32);
    if (v10 == (_QWORD *)(v9 + 8))
    {
      v11 = 4;
      v10 = (_QWORD *)(v9 + 8);
    }
    else
    {
      if (!v10)
        goto LABEL_45;
      v11 = 5;
    }
    (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_45:
    MEMORY[0x20BD0ADEC](v9, 0x1020C40460B878DLL);
    v8 = v82;
    if (v82 == v81)
    {
      v28 = 4;
      v8 = v81;
    }
    else
    {
      if (!v82)
        goto LABEL_50;
      v28 = 5;
    }
    goto LABEL_49;
  }
LABEL_50:
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    (*(void (**)(void **__return_ptr, cricket::UDPPort *))(*(_QWORD *)this + 176))(__dst, this);
    rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)a2, (char *)&__p);
    rtc::webrtc_logging_impl::Log("\r\n\t\n", v34, v35, v36, v37, v38, v39, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_port.cc");
    if (SHIBYTE(v65) < 0)
      operator delete(__p);
    if (SHIBYTE(v73) < 0)
      operator delete(__dst[0]);
  }
  v41 = (char **)*((_QWORD *)this + 118);
  v42 = *(unsigned int *)((*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 24))(this) + 184);
  v44 = v41 + 6;
  v43 = v41[6];
  if (!v43)
    goto LABEL_62;
  v45 = v41 + 6;
  do
  {
    v46 = rtc::SocketAddress::operator<((uint64_t)(v43 + 32), (char *)a2);
    v47 = (char **)(v43 + 8);
    if (!v46)
    {
      v47 = (char **)v43;
      v45 = (char **)v43;
    }
    v43 = *v47;
  }
  while (*v47);
  if (v45 == v44 || rtc::SocketAddress::operator<((uint64_t)a2, (char *)v45 + 32))
  {
LABEL_62:
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)*v41 + 40))(&v80);
    v48 = v80;
    __dst[0] = 0;
    __dst[1] = 0;
    v73 = 0;
    v74 = &unk_24C0ACDA0;
    memset(v75, 0, sizeof(v75));
    v49 = v80;
    if (__dst != a2)
    {
      if (*((char *)a2 + 23) < 0)
      {
        std::string::__assign_no_alias<true>(__dst, (char *)*a2, (size_t)a2[1]);
      }
      else
      {
        *(_OWORD *)__dst = *(_OWORD *)a2;
        v73 = a2[2];
      }
      v49 = v80;
    }
    *(_DWORD *)v75 = *((_DWORD *)a2 + 8);
    *(_OWORD *)&v75[4] = *(_OWORD *)((char *)a2 + 36);
    v76 = *((_WORD *)a2 + 28);
    v78 = *((_BYTE *)a2 + 64);
    v77 = *((_DWORD *)a2 + 15);
    v80 = 0;
    v79 = v49;
    v50 = *v44;
    if (*v44)
    {
      while (1)
      {
        while (1)
        {
          v51 = (char **)v50;
          v52 = (uint64_t)(v50 + 32);
          if (!rtc::SocketAddress::operator<((uint64_t)__dst, v50 + 32))
            break;
          v50 = *v51;
          v44 = v51;
          if (!*v51)
            goto LABEL_75;
        }
        if (!rtc::SocketAddress::operator<(v52, (char *)__dst))
          break;
        v44 = v51 + 1;
        v50 = v51[1];
        if (!v50)
          goto LABEL_75;
      }
      if (*v44)
        goto LABEL_81;
    }
    else
    {
      v51 = v41 + 6;
    }
LABEL_75:
    v53 = (char *)operator new(0x70uLL);
    *((_QWORD *)v53 + 4) = 0;
    v54 = v53 + 32;
    *((_QWORD *)v53 + 5) = 0;
    *((_QWORD *)v53 + 6) = 0;
    *((_QWORD *)v53 + 8) = 0;
    *((_QWORD *)v53 + 9) = 0;
    *((_QWORD *)v53 + 7) = &unk_24C0ACDA0;
    *((_DWORD *)v53 + 20) = 0;
    if (SHIBYTE(v73) < 0)
    {
      std::string::__assign_no_alias<true>(v54, (char *)__dst[0], (size_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)v54 = *(_OWORD *)__dst;
      *((_QWORD *)v53 + 6) = v73;
    }
    *((_DWORD *)v53 + 16) = *(_DWORD *)v75;
    *(_OWORD *)(v53 + 68) = *(_OWORD *)&v75[4];
    *((_WORD *)v53 + 44) = v76;
    v53[96] = v78;
    *((_DWORD *)v53 + 23) = v77;
    v55 = v79;
    v79 = 0;
    *((_QWORD *)v53 + 13) = v55;
    *(_QWORD *)v53 = 0;
    *((_QWORD *)v53 + 1) = 0;
    *((_QWORD *)v53 + 2) = v51;
    *v44 = v53;
    v56 = *(char **)v41[5];
    if (v56)
    {
      v41[5] = v56;
      v53 = *v44;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>((uint64_t *)v41[6], (uint64_t *)v53);
    ++v41[7];
LABEL_81:
    __p = v41;
    v65 = 0uLL;
    v66 = 0;
    memset(v68, 0, sizeof(v68));
    v67 = &unk_24C0ACDA0;
    if (&v65 != (__int128 *)a2)
    {
      if (*((char *)a2 + 23) < 0)
      {
        std::string::__assign_no_alias<true>(&v65, (char *)*a2, (size_t)a2[1]);
      }
      else
      {
        v65 = *(_OWORD *)a2;
        v66 = a2[2];
      }
    }
    *(_DWORD *)v68 = *((_DWORD *)a2 + 8);
    *(_OWORD *)&v68[4] = *(_OWORD *)((char *)a2 + 36);
    v69 = *((_WORD *)a2 + 28);
    v71 = *((_BYTE *)a2 + 64);
    v70 = *((_DWORD *)a2 + 15);
    v57 = operator new();
    *(_QWORD *)v57 = __p;
    *(_QWORD *)(v57 + 8) = 0;
    v58 = (_QWORD *)(v57 + 8);
    *(_QWORD *)(v57 + 16) = 0;
    *(_QWORD *)(v57 + 24) = 0;
    *(_QWORD *)(v57 + 40) = 0;
    *(_QWORD *)(v57 + 48) = 0;
    *(_QWORD *)(v57 + 32) = &unk_24C0ACDA0;
    *(_DWORD *)(v57 + 56) = 0;
    if (SHIBYTE(v66) < 0)
    {
      std::string::__assign_no_alias<true>(v58, (char *)v65, *((size_t *)&v65 + 1));
    }
    else
    {
      *(_OWORD *)v58 = v65;
      *(_QWORD *)(v57 + 24) = v66;
    }
    *(_DWORD *)(v57 + 40) = *(_DWORD *)v68;
    *(_OWORD *)(v57 + 44) = *(_OWORD *)&v68[4];
    *(_WORD *)(v57 + 64) = v69;
    *(_BYTE *)(v57 + 72) = v71;
    *(_DWORD *)(v57 + 68) = v70;
    v61[0] = v57;
    v62 = absl::internal_any_invocable::RemoteManagerNontrivial<cricket::UDPPort::AddressResolver::Resolve(rtc::SocketAddress const&,int,webrtc::FieldTrialsView const&)::$_0>;
    v63 = absl::internal_any_invocable::RemoteInvoker<false,void,cricket::UDPPort::AddressResolver::Resolve(rtc::SocketAddress const&,int,webrtc::FieldTrialsView const&)::$_0 &>;
    (*(void (**)(uint64_t, void **, uint64_t, _QWORD *))(*(_QWORD *)v48 + 24))(v48, a2, v42, v61);
    v62(1, v61, v61);
    if (SHIBYTE(v66) < 0)
      operator delete((void *)v65);
    v59 = v79;
    v79 = 0;
    if (v59)
      (*(void (**)(uint64_t))(*(_QWORD *)v59 + 8))(v59);
    if (SHIBYTE(v73) < 0)
      operator delete(__dst[0]);
    v60 = v80;
    v80 = 0;
    if (v60)
      (*(void (**)(uint64_t))(*(_QWORD *)v60 + 8))(v60);
  }
}

void cricket::UDPPort::OnStunBindingOrResolveRequestFailed(uint64_t a1, rtc::SocketAddress *this, int a3, char *a4, size_t a5)
{
  std::string::size_type v10;
  BOOL v11;
  const std::string::value_type *p_p_new_stuff;
  std::string::size_type v13;
  std::string::size_type size;
  std::string *v15;
  char *v16;
  std::string::size_type v17;
  size_t v18;
  std::string *v19;
  int v20;
  size_t v21;
  std::string *v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, uint64_t, std::string::value_type **);
  _QWORD *v26;
  char *v27;
  int v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  void (*v37)(uint64_t, uint64_t);
  void *v38;
  char v39;
  int v40;
  void *v41[2];
  char v42;
  std::string v43;
  std::string::value_type *__p_new_stuff;
  std::string::size_type v45;
  unsigned __int8 v46;
  void *v47;
  char v48;
  void *__p;
  char v50;
  std::string v51;

  memset(&v51, 0, sizeof(v51));
  if (&v51 <= (std::string *)"stun:" && (char *)v51.__r_.__value_.__r.__words + 5 > "stun:")
    goto LABEL_75;
  strcpy((char *)&v51, "stun:");
  *((_BYTE *)&v51.__r_.__value_.__s + 23) = 5;
  rtc::SocketAddress::ToString(this, (char *)&__p_new_stuff);
  if ((char)v46 < 0)
  {
    v10 = v45;
    if ((v45 & 0x8000000000000000) != 0)
      goto LABEL_75;
    p_p_new_stuff = __p_new_stuff;
    v11 = v45 == 0;
    if (v45)
    {
      if (!__p_new_stuff)
        goto LABEL_75;
    }
  }
  else
  {
    v10 = v46;
    v11 = v46 == 0;
    p_p_new_stuff = (const std::string::value_type *)&__p_new_stuff;
  }
  if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v13 = 22;
  else
    v13 = (v51.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v51.__r_.__value_.__r.__words[2]);
  else
    size = v51.__r_.__value_.__l.__size_;
  if (v13 - size < v10)
  {
    std::string::__grow_by_and_replace(&v51, v13, size + v10 - v13, size, size, 0, v10, p_p_new_stuff);
    if (((char)v46 & 0x80000000) == 0)
      goto LABEL_27;
    goto LABEL_26;
  }
  if (v11)
  {
LABEL_25:
    if (((char)v46 & 0x80000000) == 0)
      goto LABEL_27;
    goto LABEL_26;
  }
  if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = &v51;
  else
    v15 = (std::string *)v51.__r_.__value_.__r.__words[0];
  v16 = (char *)v15 + size;
  if ((char *)v15 + size <= p_p_new_stuff && &v16[v10] > p_p_new_stuff)
    goto LABEL_75;
  memmove(v16, p_p_new_stuff, v10);
  v17 = size + v10;
  if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    *((_BYTE *)&v51.__r_.__value_.__s + 23) = v17 & 0x7F;
    v15->__r_.__value_.__s.__data_[v17] = 0;
    goto LABEL_25;
  }
  v51.__r_.__value_.__l.__size_ = size + v10;
  v15->__r_.__value_.__s.__data_[v17] = 0;
  if ((char)v46 < 0)
LABEL_26:
    operator delete(__p_new_stuff);
LABEL_27:
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 928) + 16))(v41);
  rtc::SocketAddress::HostAsSensitiveURIString((rtc::SocketAddress *)v41, &v43);
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
  {
    v18 = v43.__r_.__value_.__l.__size_;
    if ((v43.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
      goto LABEL_75;
    v19 = (std::string *)v43.__r_.__value_.__r.__words[0];
    if (v43.__r_.__value_.__l.__size_)
    {
      if (!v43.__r_.__value_.__r.__words[0])
        goto LABEL_75;
    }
  }
  else
  {
    v18 = HIBYTE(v43.__r_.__value_.__r.__words[2]);
    v19 = &v43;
  }
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 928) + 16))(&v38);
  if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v21 = HIBYTE(v51.__r_.__value_.__r.__words[2]);
    v22 = &v51;
    goto LABEL_37;
  }
  v21 = v51.__r_.__value_.__l.__size_;
  if ((v51.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0
    || (v22 = (std::string *)v51.__r_.__value_.__r.__words[0], v51.__r_.__value_.__l.__size_)
    && !v51.__r_.__value_.__r.__words[0])
  {
LABEL_75:
    __break(1u);
    return;
  }
LABEL_37:
  cricket::IceCandidateErrorEvent::IceCandidateErrorEvent(&__p_new_stuff, v19, v18, (unsigned __int16)v40, (char *)v22, v21, a3, v20, a4, a5);
  v23 = *(_QWORD *)(a1 + 368);
  for (*(_QWORD *)(a1 + 384) = v23; v23 != a1 + 360; v23 = *(_QWORD *)(a1 + 384))
  {
    v25 = *(void (**)(uint64_t, uint64_t, std::string::value_type **))(v23 + 16);
    v24 = v23 + 16;
    *(_QWORD *)(a1 + 384) = *(_QWORD *)(v24 - 8);
    v25(v24, a1, &__p_new_stuff);
  }
  if (v50 < 0)
  {
    operator delete(__p);
    if ((v48 & 0x80000000) == 0)
    {
LABEL_41:
      if (((char)v46 & 0x80000000) == 0)
        goto LABEL_42;
      goto LABEL_49;
    }
  }
  else if ((v48 & 0x80000000) == 0)
  {
    goto LABEL_41;
  }
  operator delete(v47);
  if (((char)v46 & 0x80000000) == 0)
  {
LABEL_42:
    if ((v39 & 0x80000000) == 0)
      goto LABEL_43;
    goto LABEL_50;
  }
LABEL_49:
  operator delete(__p_new_stuff);
  if ((v39 & 0x80000000) == 0)
  {
LABEL_43:
    if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_44;
    goto LABEL_51;
  }
LABEL_50:
  operator delete(v38);
  if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_44:
    if ((v42 & 0x80000000) == 0)
      goto LABEL_45;
    goto LABEL_52;
  }
LABEL_51:
  operator delete(v43.__r_.__value_.__l.__data_);
  if ((v42 & 0x80000000) == 0)
  {
LABEL_45:
    v26 = *(_QWORD **)(a1 + 848);
    if (!v26)
      goto LABEL_59;
LABEL_53:
    v27 = (char *)(a1 + 848);
    do
    {
      v28 = rtc::SocketAddress::operator<((uint64_t)(v26 + 4), (char *)this);
      v29 = v26 + 1;
      if (!v28)
      {
        v29 = v26;
        v27 = (char *)v26;
      }
      v26 = (_QWORD *)*v29;
    }
    while (*v29);
    if (v27 != (char *)(a1 + 848) && !rtc::SocketAddress::operator<((uint64_t)this, v27 + 32))
      goto LABEL_67;
    goto LABEL_59;
  }
LABEL_52:
  operator delete(v41[0]);
  v26 = *(_QWORD **)(a1 + 848);
  if (v26)
    goto LABEL_53;
LABEL_59:
  std::__tree<rtc::SocketAddress>::__emplace_unique_key_args<rtc::SocketAddress,rtc::SocketAddress const&>((uint64_t **)(a1 + 840), (char *)this, (uint64_t)this);
  if (*(_DWORD *)(a1 + 736) != 1 && !*(_BYTE *)(a1 + 952))
  {
    v30 = *(_QWORD *)(a1 + 832);
    v31 = v30 + *(_QWORD *)(a1 + 856);
    if (*(_QWORD *)(a1 + 808) == v31)
    {
      *(_BYTE *)(a1 + 952) = 1;
      if (v30 || !v31 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1))
      {
        v32 = *(_QWORD *)(a1 + 424);
        for (*(_QWORD *)(a1 + 440) = v32; v32 != a1 + 416; v32 = *(_QWORD *)(a1 + 440))
        {
          v34 = *(void (**)(uint64_t, uint64_t))(v32 + 16);
          v33 = v32 + 16;
          *(_QWORD *)(a1 + 440) = *(_QWORD *)(v33 - 8);
          v34(v33, a1);
        }
      }
      else
      {
        v35 = *(_QWORD *)(a1 + 480);
        for (*(_QWORD *)(a1 + 496) = v35; v35 != a1 + 472; v35 = *(_QWORD *)(a1 + 496))
        {
          v37 = *(void (**)(uint64_t, uint64_t))(v35 + 16);
          v36 = v35 + 16;
          *(_QWORD *)(a1 + 496) = *(_QWORD *)(v36 - 8);
          v37(v36, a1);
        }
      }
    }
  }
LABEL_67:
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v51.__r_.__value_.__l.__data_);
}

void cricket::UDPPort::OnSendPacket(cricket::UDPPort *this, const void *a2, uint64_t a3, cricket::StunRequest *a4)
{
  unsigned int v8;
  unsigned int v9;
  rtc::SocketAddress *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *__p;
  char v20;
  int v21;
  char v22;
  uint64_t v23;
  int v24;
  void *v25;
  void *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  __int16 v30;
  int v31;
  unsigned int v32;
  __int16 v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int16 v38;
  const char *v39;
  int v40;
  int v41;
  int v42;

  v21 = (*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 272))(this);
  v22 = 0;
  v23 = -1;
  v24 = -1;
  v26 = 0;
  v27 = 0;
  v25 = 0;
  v28 = -1;
  v29 = -1;
  v30 = 0;
  v36 = 0;
  v37 = 0;
  v35 = 0;
  v38 = 0;
  v31 = 4;
  v8 = (*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 128))(this);
  if (v8 < 4)
    v9 = v8 + 1;
  else
    v9 = 0;
  v32 = v9;
  v33 = *(_WORD *)((*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)this + 24))(this) + 286);
  v34 = 1;
  v10 = (cricket::StunRequest *)((char *)a4 + 64);
  if (((*(uint64_t (**)(_QWORD, const void *, uint64_t, rtc::SocketAddress *, int *))(**((_QWORD **)this + 116)
                                                                                              + 40))(*((_QWORD *)this + 116), a2, a3, v10, &v21) & 0x80000000) != 0&& (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
  {
    v11 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 116) + 80))(*((_QWORD *)this + 116));
    rtc::SocketAddress::ToSensitiveNameAndAddressString(v10, (unint64_t)&__p);
    v39 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_port.cc";
    v40 = 4859;
    v41 = 1;
    v42 = v11;
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)14,rtc::webrtc_logging_impl::LogMetadataErr>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)14,rtc::webrtc_logging_impl::LogMetadataErr>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v12, v13, v14, v15, v16, v17, v18, (uint64_t)&v39);
    if (v20 < 0)
      operator delete(__p);
  }
  ++*((_DWORD *)this + 242);
  if (v25)
  {
    v26 = v25;
    operator delete(v25);
  }
}

uint64_t cricket::StunPort::Create@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, __int16 a4@<W3>, __int16 a5@<W4>, void **a6@<X5>, size_t a7@<X6>, uint64_t *a8@<X8>, void **a9, size_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t result;

  v20 = operator new();
  v22 = cricket::Port::Port(v20, a1, 1, a2, a3, a4, a5, v21, a6, a7, a9, a10, a13, 0);
  *(_OWORD *)(v22 + 800) = 0u;
  v23 = v22 + 792;
  *(_QWORD *)(v20 + 792) = v20 + 800;
  *(_OWORD *)(v20 + 824) = 0u;
  *(_QWORD *)(v20 + 816) = v20 + 824;
  *(_OWORD *)(v20 + 848) = 0u;
  *(_QWORD *)(v20 + 840) = v20 + 848;
  *(_QWORD *)(v20 + 864) = a1;
  *(_OWORD *)(v20 + 880) = 0u;
  *(_QWORD *)(v20 + 872) = v20 + 880;
  *(_QWORD *)(v20 + 920) = v20 + 896;
  *(_QWORD *)(v20 + 896) = &off_24C0C1A80;
  *(_QWORD *)(v20 + 904) = v20;
  *(_OWORD *)(v20 + 928) = 0u;
  *(_BYTE *)(v20 + 952) = 0;
  *(_QWORD *)(v20 + 944) = 0;
  *(_DWORD *)(v20 + 956) = 10000;
  *(_QWORD *)(v20 + 960) = -1;
  *(_BYTE *)(v20 + 992) = 0;
  *(_QWORD *)(v20 + 984) = 0;
  *(_OWORD *)(v20 + 968) = 0u;
  *(_QWORD *)v20 = &off_24C0C1858;
  *(_QWORD *)(v20 + 232) = &unk_24C0C19D0;
  if (v23 != a11)
    std::__tree<rtc::SocketAddress>::__assign_multi<std::__tree_const_iterator<rtc::SocketAddress,std::__tree_node<rtc::SocketAddress,void *> *,long>>(v23, *(char **)a11, (char *)(a11 + 8));
  if ((a12 & 0xFF00000000) != 0)
    v24 = a12;
  else
    v24 = 10000;
  *(_DWORD *)(v20 + 956) = v24;
  result = cricket::UDPPort::Init((cricket::UDPPort *)v20);
  if ((result & 1) == 0)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
    v20 = 0;
  }
  *a8 = v20;
  return result;
}

void cricket::StunPort::PrepareAddress(cricket::StunPort *this)
{
  char *v1;
  char *v2;
  char *v4;
  char *v5;
  char *v6;
  BOOL v7;

  v1 = (char *)*((_QWORD *)this + 99);
  v2 = (char *)this + 800;
  if (v1 != (char *)this + 800)
  {
    do
    {
      v4 = (char *)*((_QWORD *)v1 + 1);
      v5 = v1;
      if (v4)
      {
        do
        {
          v6 = v4;
          v4 = *(char **)v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          v6 = (char *)*((_QWORD *)v5 + 2);
          v7 = *(_QWORD *)v6 == (_QWORD)v5;
          v5 = v6;
        }
        while (!v7);
      }
      cricket::UDPPort::SendStunBindingRequest(this, (void **)v1 + 4);
      v1 = v6;
    }
    while (v6 != v2);
  }
}

void cricket::StunPort::~StunPort(cricket::StunPort *this)
{
  cricket::UDPPort::~UDPPort(this);
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'cricket::StunPort::~StunPort(cricket::StunPort *this)
{
  cricket::UDPPort::~UDPPort((cricket::StunPort *)((char *)this - 232));
}

{
  cricket::UDPPort::~UDPPort((cricket::StunPort *)((char *)this - 232));
  JUMPOUT(0x20BD0ADECLL);
}

void std::__tree<std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>,std::__map_value_compare<rtc::SocketAddress,std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>,std::less<rtc::SocketAddress>,true>,std::allocator<std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>>>::destroy(char *a1)
{
  uint64_t v2;

  if (a1)
  {
    std::__tree<std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>,std::__map_value_compare<rtc::SocketAddress,std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>,std::less<rtc::SocketAddress>,true>,std::allocator<std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>>>::destroy(*(_QWORD *)a1);
    std::__tree<std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>,std::__map_value_compare<rtc::SocketAddress,std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>,std::less<rtc::SocketAddress>,true>,std::allocator<std::__value_type<rtc::SocketAddress,std::unique_ptr<webrtc::AsyncDnsResolverInterface>>>>::destroy(*((_QWORD *)a1 + 1));
    v2 = *((_QWORD *)a1 + 13);
    *((_QWORD *)a1 + 13) = 0;
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    if (a1[55] < 0)
      operator delete(*((void **)a1 + 4));
    operator delete(a1);
  }
}

void cricket::StunBindingRequest::~StunBindingRequest(void **this)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  void *v5;

  *this = off_24C0C19F0;
  if (*((char *)this + 87) < 0)
    operator delete(this[8]);
  *this = &off_24C0C1B10;
  v2 = (unsigned int *)this[5];
  *((_BYTE *)v2 + 4) = 0;
  do
  {
    v3 = __ldaxr(v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  v5 = this[2];
  this[2] = 0;
  if (v5)
    (*(void (**)(void *))(*(_QWORD *)v5 + 8))(v5);
}

{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  void *v5;

  *this = off_24C0C19F0;
  if (*((char *)this + 87) < 0)
    operator delete(this[8]);
  *this = &off_24C0C1B10;
  v2 = (unsigned int *)this[5];
  *((_BYTE *)v2 + 4) = 0;
  do
  {
    v3 = __ldaxr(v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  v5 = this[2];
  this[2] = 0;
  if (v5)
    (*(void (**)(void *))(*(_QWORD *)v5 + 8))(v5);
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::StunBindingRequest::OnResponse(cricket::StunBindingRequest *this, cricket::StunMessage *a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;
  unsigned __int16 v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  int v29;
  _QWORD *v30;
  int v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD *v35;
  int v36;
  uint64_t v39;
  int v40;
  unsigned int v41;
  BOOL v42;
  int v43;
  char v44;
  int v45;
  char v46;
  __int16 v47;
  size_t v48;
  BOOL v49;
  size_t v50;
  uint64_t v51;
  size_t v52;
  char *v53;
  char *v54;
  unint64_t v55;
  int v56;
  std::string::size_type v57;
  size_t v58;
  _BYTE *v59;
  _BYTE *v60;
  size_t v61;
  std::string::size_type v62;
  const std::string::value_type *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  void (*v68)(uint64_t, uint64_t);
  uint64_t v69;
  uint64_t v70;
  void (*v71)(uint64_t, uint64_t);
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  const void **v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  _QWORD *v79;
  int v80;
  std::string::size_type v81;
  TimeDelta v82;
  __int128 v83;
  uint64_t v84;
  void *v85;
  _BYTE v86[20];
  unsigned __int16 v87;
  int v88;
  char v89;
  void *__p[7];
  __int16 v91;
  int v92;
  char v93;
  std::string v94;
  unsigned int v95;
  __int128 v96;
  __int16 v97;
  int v98;
  char v99;
  void *v100[2];
  char v101;
  unsigned __int16 v102;
  _BYTE v103[28];

  v3 = (uint64_t *)*((_QWORD *)a2 + 1);
  v4 = (uint64_t *)*((_QWORD *)a2 + 2);
  if (v3 == v4)
  {
LABEL_15:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      goto LABEL_18;
    goto LABEL_149;
  }
  v5 = (uint64_t *)*((_QWORD *)a2 + 1);
  while (1)
  {
    v6 = *v5;
    if (*(_WORD *)(*v5 + 8) == 1)
      break;
    if (++v5 == v4)
    {
      while (1)
      {
        v6 = *v3;
        if (*(_WORD *)(*v3 + 8) == 32)
          goto LABEL_8;
        if (++v3 == v4)
          goto LABEL_15;
      }
    }
  }
LABEL_8:
  v7 = *(_DWORD *)(v6 + 48);
  if (v7 == 2 || v7 == 30)
  {
    v9 = *(_WORD *)(v6 + 72);
    v83 = 0uLL;
    v84 = 0;
    v85 = &unk_24C0ACDA0;
    *(_DWORD *)&v86[16] = 0;
    *(_OWORD *)v86 = 0uLL;
    v10 = *(_DWORD *)(v6 + 48);
    v89 = 0;
    *(_DWORD *)v86 = v10;
    *(_OWORD *)&v86[4] = *(_OWORD *)(v6 + 52);
    v88 = 0;
    v87 = v9;
    v11 = *((_QWORD *)this + 7);
    if (rtc::g_clock)
    {
      LODWORD(v12) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
    }
    else
    {
      if (!dword_253EA791C)
        mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
      v12 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
          / dword_253EA791C;
    }
    v25 = (int)v12 / 1000000 - *((_DWORD *)this + 6);
    v26 = (_QWORD *)((char *)this + 64);
    ++*(_DWORD *)(v11 + 972);
    *(double *)(v11 + 976) = *(double *)(v11 + 976) + (double)v25;
    *(double *)(v11 + 984) = *(double *)(v11 + 984) + (double)(v25 * v25);
    v27 = *(_QWORD **)(v11 + 824);
    if (v27)
    {
      v28 = v11 + 824;
      do
      {
        v29 = rtc::SocketAddress::operator<((uint64_t)(v27 + 4), (char *)this + 64);
        v30 = v27 + 1;
        if (!v29)
        {
          v30 = v27;
          v28 = (uint64_t)v27;
        }
        v27 = (_QWORD *)*v30;
      }
      while (*v30);
      if (v28 != v11 + 824 && !rtc::SocketAddress::operator<((uint64_t)this + 64, (char *)(v28 + 32)))
      {
LABEL_148:
        if (SHIBYTE(v84) < 0)
        {
          operator delete((void *)v83);
          v21 = rtc::g_clock;
          if (rtc::g_clock)
            goto LABEL_150;
LABEL_19:
          if (!dword_253EA791C)
            mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
          v22 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
              / dword_253EA791C;
          v23 = *((_QWORD *)this + 7);
          v24 = *(unsigned int *)(v23 + 960);
          if ((v24 & 0x80000000) != 0)
            goto LABEL_152;
LABEL_151:
          if (v22 / 1000000 - *((_QWORD *)this + 17) > v24)
            return;
          goto LABEL_152;
        }
LABEL_149:
        v21 = rtc::g_clock;
        if (rtc::g_clock)
          goto LABEL_150;
        goto LABEL_19;
      }
    }
    std::__tree<rtc::SocketAddress>::__emplace_unique_key_args<rtc::SocketAddress,rtc::SocketAddress const&>((uint64_t **)(v11 + 816), (char *)this + 64, (uint64_t)this + 64);
    v31 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 64))(v11);
    if (!v31
      || ((*(void (**)(void **__return_ptr))(**(_QWORD **)(v11 + 928) + 16))(v100),
          !rtc::SocketAddress::EqualIPs((rtc::SocketAddress *)&v83, (const rtc::SocketAddress *)v100))
      || v87 != v102
      || (v32 = *(_QWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11) + 120)) != 0
      && (*(uint64_t (**)(uint64_t))(*(_QWORD *)v32 + 16))(v32))
    {
      v33 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 136))(v11);
      v34 = *v33;
      if (*v33 == v33[1])
      {
LABEL_48:
        if ((v31 & 1) == 0)
          goto LABEL_51;
        v36 = 1;
        if (v101 < 0)
          goto LABEL_46;
        goto LABEL_50;
      }
      v35 = v33;
      while (*(_DWORD *)(v34 + 208) != 1
           || !rtc::SocketAddress::EqualIPs((rtc::SocketAddress *)(v34 + 80), (const rtc::SocketAddress *)&v83)
           || *(unsigned __int16 *)(v34 + 136) != v87)
      {
        v34 += 432;
        if (v34 == v35[1])
          goto LABEL_48;
      }
      if (!v31)
      {
LABEL_133:
        if (*(_DWORD *)(v11 + 736) == 1)
          goto LABEL_148;
        goto LABEL_138;
      }
    }
    v36 = 0;
    if (v101 < 0)
    {
LABEL_46:
      operator delete(v100[0]);
      if (!v36)
        goto LABEL_133;
LABEL_51:
      (*(void (**)(std::string *__return_ptr))(**(_QWORD **)(v11 + 928) + 16))(&v94);
      if (v95 == 2)
      {
        if ((_DWORD)v96)
          goto LABEL_85;
      }
      else
      {
        if (v95 != 30)
          goto LABEL_85;
        *(_OWORD *)((char *)&__p[1] + 4) = *MEMORY[0x24BDAE878];
        if ((void *)v96 != *(void **)((char *)&__p[1] + 4) || *((void **)&v96 + 1) != *(void **)((char *)&__p[2] + 4))
        {
          *(_OWORD *)&v103[12] = rtc::kV4MappedPrefix;
          if ((_QWORD)v96 != (_QWORD)rtc::kV4MappedPrefix
            || *((_QWORD *)&v96 + 1) != *((_QWORD *)&rtc::kV4MappedPrefix + 1))
          {
            goto LABEL_85;
          }
        }
      }
      if (*(_BYTE *)(v11 + 992) && *(_QWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11) + 112))
      {
        memset(&__p[1], 0, 20);
        __p[0] = &unk_24C0ACDA0;
        v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
        v40 = (*(uint64_t (**)(_QWORD, _QWORD, void **))(**(_QWORD **)(v39 + 112) + 16))(*(_QWORD *)(v39 + 112), v95, __p);
        v41 = __p[1];
        if (v40)
          v42 = LODWORD(__p[1]) == 0;
        else
          v42 = 1;
        if (v42)
        {
          if (v95 == 30)
          {
            memset(__p, 0, 24);
            __p[3] = &unk_24C0ACDA0;
            v93 = 0;
            v43 = 30;
            LODWORD(__p[4]) = 30;
            *(_OWORD *)((char *)&__p[4] + 4) = *MEMORY[0x24BDAE878];
            v92 = 0;
            v91 = 0;
          }
          else if (v95 == 2)
          {
            memset(__p, 0, 24);
            __p[3] = &unk_24C0ACDA0;
            v93 = 0;
            v43 = 2;
            LODWORD(__p[4]) = 2;
            v92 = 0;
            v91 = 0;
            *(_OWORD *)((char *)&__p[4] + 4) = 0uLL;
          }
          else
          {
            v43 = 0;
            memset(__p, 0, 24);
            __p[3] = &unk_24C0ACDA0;
            v93 = 0;
            v91 = 0;
            v92 = 0;
            memset(&__p[4], 0, 20);
          }
          if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
          {
            std::string::__assign_no_alias<false>(&v94, (const std::string::value_type *)__p, 0);
            v43 = (int)__p[4];
            v47 = v91;
            v46 = v93;
            v45 = v92;
            v44 = HIBYTE(__p[2]);
          }
          else
          {
            v44 = 0;
            v45 = 0;
            v46 = 0;
            v47 = 0;
            v94 = *(std::string *)__p;
          }
          v95 = v43;
          v96 = *(_OWORD *)((char *)&__p[4] + 4);
          v97 = v47;
          v99 = v46;
          v98 = v45;
          if (v44 < 0)
            operator delete(__p[0]);
        }
        else
        {
          if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
          {
            *v94.__r_.__value_.__l.__data_ = 0;
            v94.__r_.__value_.__l.__size_ = 0;
            v41 = __p[1];
          }
          else
          {
            v94.__r_.__value_.__s.__data_[0] = 0;
            *((_BYTE *)&v94.__r_.__value_.__s + 23) = 0;
          }
          v99 = 0;
          v96 = *(_OWORD *)((char *)&__p[1] + 4);
          v95 = v41;
          v98 = 0;
        }
      }
LABEL_85:
      memset(v103, 0, 24);
      if (v103 <= "stun:" && &v103[5] > "stun:")
        goto LABEL_164;
      strcpy(v103, "stun:");
      v103[23] = 5;
      if (*((char *)this + 87) < 0)
      {
        v48 = *((_QWORD *)this + 9);
        if ((v48 & 0x8000000000000000) != 0)
          goto LABEL_164;
        v26 = (_QWORD *)*v26;
        v49 = v48 == 0;
        if (v48)
        {
          if (!v26)
            goto LABEL_164;
        }
      }
      else
      {
        v48 = *((unsigned __int8 *)this + 87);
        v49 = *((_BYTE *)this + 87) == 0;
      }
      if (v48 <= 0x11)
      {
        if (v49)
        {
          v50 = 0;
          LODWORD(v55) = 5;
        }
        else
        {
          if (&v103[5] <= (_BYTE *)v26 && &v103[v48 + 5] > (_BYTE *)v26)
            goto LABEL_164;
          memmove(&v103[5], v26, v48);
          if ((v103[23] & 0x80000000) != 0)
            *(_QWORD *)&v103[8] = v48 + 5;
          else
            v103[23] = v48 + 5;
          v103[v48 + 5] = 0;
          LODWORD(v55) = v103[23];
          v50 = *(_QWORD *)&v103[8];
        }
      }
      else
      {
        if (v48 - 0x7FFFFFFFFFFFFFF2 <= 0x800000000000001ELL)
          goto LABEL_165;
        v50 = v48 + 5;
        v51 = 44;
        if (v48 + 5 > 0x2C)
          v51 = v48 + 5;
        v52 = (v51 | 7) + 1;
        v53 = (char *)operator new(v52);
        v54 = v53 + 5;
        if (v103 >= v53 && v53 + 5 > v103)
          goto LABEL_164;
        v53[4] = 58;
        *(_DWORD *)v53 = 1853191283;
        if (v54 <= (char *)v26 && &v54[v48] > (char *)v26)
          goto LABEL_164;
        memcpy(v54, v26, v48);
        *(_QWORD *)&v103[8] = v48 + 5;
        *(_QWORD *)&v103[16] = v52 | 0x8000000000000000;
        *(_QWORD *)v103 = v53;
        v53[v50] = 0;
        v55 = (v52 | 0x8000000000000000) >> 56;
      }
      v56 = (char)v55;
      if ((v55 & 0x80u) == 0)
        v57 = 22;
      else
        v57 = (*(_QWORD *)&v103[16] & 0x7FFFFFFFFFFFFFFFLL) - 1;
      if ((v55 & 0x80u) == 0)
        v58 = v55;
      else
        v58 = v50;
      if (v57 == v58)
      {
        std::string::__grow_by_and_replace((std::string *)v103, v57, 1uLL, v57, v57, 0, 1uLL, ":");
LABEL_125:
        rtc::StringBuilder::operator<<((std::string *)v103, *((unsigned __int16 *)this + 60));
        (*(void (**)(void **__return_ptr))(**(_QWORD **)(v11 + 928) + 16))(__p);
        if ((v103[23] & 0x80000000) == 0)
        {
          v62 = v103[23];
          v63 = v103;
          goto LABEL_130;
        }
        v62 = *(_QWORD *)&v103[8];
        if ((*(_QWORD *)&v103[8] & 0x8000000000000000) == 0)
        {
          v63 = *(const std::string::value_type **)v103;
          if (!*(_QWORD *)&v103[8] || *(_QWORD *)v103)
          {
LABEL_130:
            cricket::Port::AddAddress(v11, &v83, (const rtc::SocketAddress *)__p, (uint64_t)&v94, (char *)&cricket::UDP_PROTOCOL_NAME, 3uLL, &byte_208EB9246, 0, &byte_208EB9246, 0, 1, 100, 0, v63, v62, 0);
            if (SHIBYTE(__p[2]) < 0)
            {
              operator delete(__p[0]);
              if ((v103[23] & 0x80000000) == 0)
              {
LABEL_132:
                if ((SHIBYTE(v94.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  goto LABEL_133;
                goto LABEL_137;
              }
            }
            else if ((v103[23] & 0x80000000) == 0)
            {
              goto LABEL_132;
            }
            operator delete(*(void **)v103);
            if ((SHIBYTE(v94.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_133;
LABEL_137:
            operator delete(v94.__r_.__value_.__l.__data_);
            if (*(_DWORD *)(v11 + 736) == 1)
              goto LABEL_148;
LABEL_138:
            if (!*(_BYTE *)(v11 + 952))
            {
              v64 = *(_QWORD *)(v11 + 832);
              v65 = v64 + *(_QWORD *)(v11 + 856);
              if (*(_QWORD *)(v11 + 808) == v65)
              {
                *(_BYTE *)(v11 + 952) = 1;
                if (v64 || !v65 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 64))(v11))
                {
                  v66 = *(_QWORD *)(v11 + 424);
                  for (*(_QWORD *)(v11 + 440) = v66; v66 != v11 + 416; v66 = *(_QWORD *)(v11 + 440))
                  {
                    v68 = *(void (**)(uint64_t, uint64_t))(v66 + 16);
                    v67 = v66 + 16;
                    *(_QWORD *)(v11 + 440) = *(_QWORD *)(v67 - 8);
                    v68(v67, v11);
                  }
                }
                else
                {
                  v69 = *(_QWORD *)(v11 + 480);
                  for (*(_QWORD *)(v11 + 496) = v69; v69 != v11 + 472; v69 = *(_QWORD *)(v11 + 496))
                  {
                    v71 = *(void (**)(uint64_t, uint64_t))(v69 + 16);
                    v70 = v69 + 16;
                    *(_QWORD *)(v11 + 496) = *(_QWORD *)(v70 - 8);
                    v71(v70, v11);
                  }
                }
              }
            }
            goto LABEL_148;
          }
        }
        goto LABEL_164;
      }
      v59 = *(_BYTE **)v103;
      if (v56 >= 0)
        v59 = v103;
      v60 = &v59[v58];
      if (&v59[v58] > ":" || v60 + 1 <= ":")
      {
        *v60 = 58;
        v61 = v58 + 1;
        if ((v103[23] & 0x80000000) != 0)
          *(_QWORD *)&v103[8] = v61;
        else
          v103[23] = v61 & 0x7F;
        v59[v61] = 0;
        goto LABEL_125;
      }
LABEL_164:
      __break(1u);
LABEL_165:
      abort();
    }
LABEL_50:
    if (!v36)
      goto LABEL_133;
    goto LABEL_51;
  }
  v13 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>();
  if ((v13 & 1) != 0)
    goto LABEL_149;
LABEL_18:
  rtc::webrtc_logging_impl::Log("\r\t", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_port.cc");
  v21 = rtc::g_clock;
  if (!rtc::g_clock)
    goto LABEL_19;
LABEL_150:
  v22 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v21 + 16))(v21);
  v23 = *((_QWORD *)this + 7);
  v24 = *(unsigned int *)(v23 + 960);
  if ((v24 & 0x80000000) == 0)
    goto LABEL_151;
LABEL_152:
  v72 = operator new();
  v73 = *((_QWORD *)this + 7);
  v74 = *((_QWORD *)this + 17);
  v75 = (const void **)operator new();
  cricket::StunMessage::StunMessage((cricket::StunMessage *)v75, 1);
  *(_QWORD *)(v72 + 8) = v73 + 864;
  *(_QWORD *)(v72 + 16) = v76;
  *(_QWORD *)(v72 + 24) = 0;
  *(_DWORD *)(v72 + 32) = 0;
  *(_BYTE *)(v72 + 36) = 0;
  v77 = operator new();
  *(_DWORD *)v77 = 0;
  *(_BYTE *)(v77 + 4) = 0;
  do
    v78 = __ldxr((unsigned int *)v77);
  while (__stxr(v78 + 1, (unsigned int *)v77));
  *(_QWORD *)(v72 + 40) = v77;
  *(_BYTE *)(v72 + 48) = 1;
  *(_QWORD *)v72 = off_24C0C19F0;
  *(_QWORD *)(v72 + 56) = v73;
  *(_QWORD *)(v72 + 64) = 0;
  v79 = (_QWORD *)(v72 + 64);
  *(_QWORD *)(v72 + 72) = 0;
  *(_QWORD *)(v72 + 80) = 0;
  *(_QWORD *)(v72 + 96) = 0;
  *(_QWORD *)(v72 + 104) = 0;
  *(_QWORD *)(v72 + 88) = &unk_24C0ACDA0;
  *(_DWORD *)(v72 + 112) = 0;
  if ((cricket::StunBindingRequest *)v72 != this)
  {
    if (*((char *)this + 87) < 0)
    {
      std::string::__assign_no_alias<true>(v79, *((char **)this + 8), *((_QWORD *)this + 9));
      v75 = *(const void ***)(v72 + 16);
    }
    else
    {
      *(_OWORD *)v79 = *((_OWORD *)this + 4);
      *(_QWORD *)(v72 + 80) = *((_QWORD *)this + 10);
    }
  }
  *(_DWORD *)(v72 + 96) = *((_DWORD *)this + 24);
  *(_OWORD *)(v72 + 100) = *(_OWORD *)((char *)this + 100);
  *(_WORD *)(v72 + 120) = *((_WORD *)this + 60);
  *(_BYTE *)(v72 + 128) = *((_BYTE *)this + 128);
  *(_DWORD *)(v72 + 124) = *((_DWORD *)this + 31);
  *(_QWORD *)(v72 + 136) = v74;
  *(_BYTE *)(v72 + 48) = 0;
  v80 = *(_DWORD *)(*((_QWORD *)this + 7) + 956);
  v94.__r_.__value_.__r.__words[0] = v72;
  std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>(v23 + 872, v75 + 5, (uint64_t)(v75 + 5), (uint64_t *)&v94);
  v81 = v94.__r_.__value_.__r.__words[0];
  v94.__r_.__value_.__r.__words[0] = 0;
  if (v81)
    (*(void (**)(std::string::size_type))(*(_QWORD *)v81 + 8))(v81);
  v82.var0 = 1000 * v80;
  cricket::StunRequest::Send((cricket::StunRequest *)v72, v82);
}

void cricket::StunBindingRequest::OnErrorResponse(cricket::StunBindingRequest *this, cricket::StunMessage *a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  int v15;
  unsigned __int8 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t size;
  std::string *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const void **v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  _QWORD *v40;
  int v41;
  std::string::size_type v42;
  TimeDelta v43;
  std::string v44;

  v3 = (uint64_t *)*((_QWORD *)a2 + 1);
  v4 = (uint64_t *)*((_QWORD *)a2 + 2);
  if (v3 == v4)
  {
LABEL_4:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_port.cc");
    v13 = *((_QWORD *)this + 7);
    v14 = (char *)operator new(0x38uLL);
    v44.__r_.__value_.__r.__words[0] = (std::string::size_type)v14;
    *(_OWORD *)&v44.__r_.__value_.__r.__words[1] = xmmword_208F0B3E0;
    if (v14 <= "STUN binding response with no error code attribute."
      && v14 + 51 > "STUN binding response with no error code attribute.")
    {
      goto LABEL_44;
    }
    strcpy(v14, "STUN binding response with no error code attribute.");
    v15 = 600;
    v16 = HIBYTE(v44.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_14:
      size = v16;
      v25 = &v44;
      goto LABEL_19;
    }
  }
  else
  {
    while (1)
    {
      v5 = *v3;
      if (*(_WORD *)(*v3 + 8) == 9)
        break;
      if (++v3 == v4)
        goto LABEL_4;
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v17, v18, v19, v20, v21, v22, v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_port.cc");
    v13 = *((_QWORD *)this + 7);
    v15 = *(unsigned __int8 *)(v5 + 13);
    if (*(char *)(v5 + 39) < 0)
    {
      std::string::__init_copy_ctor_external(&v44, *(const std::string::value_type **)(v5 + 16), *(_QWORD *)(v5 + 24));
      v16 = HIBYTE(v44.__r_.__value_.__r.__words[2]);
      if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_14;
    }
    else
    {
      v44 = *(std::string *)(v5 + 16);
      v16 = HIBYTE(v44.__r_.__value_.__r.__words[2]);
      if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_14;
    }
  }
  size = v44.__r_.__value_.__l.__size_;
  if ((v44.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0
    || (v25 = (std::string *)v44.__r_.__value_.__r.__words[0], v44.__r_.__value_.__l.__size_)
    && !v44.__r_.__value_.__r.__words[0])
  {
LABEL_44:
    __break(1u);
    return;
  }
LABEL_19:
  cricket::UDPPort::OnStunBindingOrResolveRequestFailed(v13, (cricket::StunBindingRequest *)((char *)this + 64), v15, (char *)v25, size);
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v44.__r_.__value_.__l.__data_);
    v26 = rtc::g_clock;
    if (rtc::g_clock)
      goto LABEL_21;
LABEL_23:
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v27 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
        / dword_253EA791C;
    goto LABEL_26;
  }
  v26 = rtc::g_clock;
  if (!rtc::g_clock)
    goto LABEL_23;
LABEL_21:
  v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v26 + 16))(v26);
LABEL_26:
  v28 = *((_QWORD *)this + 7);
  v29 = *(unsigned int *)(v28 + 960);
  v30 = v27 / 1000000 - *((_QWORD *)this + 17);
  if ((v30 <= v29 || (int)v29 < 0) && v30 <= 49999)
  {
    v33 = operator new();
    v34 = *((_QWORD *)this + 7);
    v35 = *((_QWORD *)this + 17);
    v36 = (const void **)operator new();
    cricket::StunMessage::StunMessage((cricket::StunMessage *)v36, 1);
    *(_QWORD *)(v33 + 8) = v34 + 864;
    *(_QWORD *)(v33 + 16) = v37;
    *(_QWORD *)(v33 + 24) = 0;
    *(_DWORD *)(v33 + 32) = 0;
    *(_BYTE *)(v33 + 36) = 0;
    v38 = operator new();
    *(_DWORD *)v38 = 0;
    *(_BYTE *)(v38 + 4) = 0;
    do
      v39 = __ldxr((unsigned int *)v38);
    while (__stxr(v39 + 1, (unsigned int *)v38));
    *(_QWORD *)(v33 + 40) = v38;
    *(_BYTE *)(v33 + 48) = 1;
    *(_QWORD *)v33 = off_24C0C19F0;
    *(_QWORD *)(v33 + 56) = v34;
    *(_QWORD *)(v33 + 64) = 0;
    v40 = (_QWORD *)(v33 + 64);
    *(_QWORD *)(v33 + 72) = 0;
    *(_QWORD *)(v33 + 80) = 0;
    *(_QWORD *)(v33 + 96) = 0;
    *(_QWORD *)(v33 + 104) = 0;
    *(_QWORD *)(v33 + 88) = &unk_24C0ACDA0;
    *(_DWORD *)(v33 + 112) = 0;
    if ((cricket::StunBindingRequest *)v33 != this)
    {
      if (*((char *)this + 87) < 0)
      {
        std::string::__assign_no_alias<true>(v40, *((char **)this + 8), *((_QWORD *)this + 9));
        v36 = *(const void ***)(v33 + 16);
      }
      else
      {
        *(_OWORD *)v40 = *((_OWORD *)this + 4);
        *(_QWORD *)(v33 + 80) = *((_QWORD *)this + 10);
      }
    }
    *(_DWORD *)(v33 + 96) = *((_DWORD *)this + 24);
    *(_OWORD *)(v33 + 100) = *(_OWORD *)((char *)this + 100);
    *(_WORD *)(v33 + 120) = *((_WORD *)this + 60);
    *(_BYTE *)(v33 + 128) = *((_BYTE *)this + 128);
    *(_DWORD *)(v33 + 124) = *((_DWORD *)this + 31);
    *(_QWORD *)(v33 + 136) = v35;
    *(_BYTE *)(v33 + 48) = 0;
    v41 = *(_DWORD *)(*((_QWORD *)this + 7) + 956);
    v44.__r_.__value_.__r.__words[0] = v33;
    std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>(v28 + 872, v36 + 5, (uint64_t)(v36 + 5), (uint64_t *)&v44);
    v42 = v44.__r_.__value_.__r.__words[0];
    v44.__r_.__value_.__r.__words[0] = 0;
    if (v42)
      (*(void (**)(std::string::size_type))(*(_QWORD *)v42 + 8))(v42);
    v43.var0 = 1000 * v41;
    cricket::StunRequest::Send((cricket::StunRequest *)v33, v43);
  }
}

void cricket::StunBindingRequest::OnTimeout(cricket::StunBindingRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *__p[2];
  char v10;
  void *v11;
  char v12;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
  {
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 7) + 928) + 16))(__p);
    rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)__p, (char *)&v11);
    (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 7) + 24))(*((_QWORD *)this + 7));
    rtc::webrtc_logging_impl::Log("\r\t\n\t\n\t", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_port.cc");
    if (v12 < 0)
    {
      operator delete(v11);
      if ((v10 & 0x80000000) == 0)
        goto LABEL_4;
    }
    else if ((v10 & 0x80000000) == 0)
    {
      goto LABEL_4;
    }
    operator delete(__p[0]);
  }
LABEL_4:
  cricket::UDPPort::OnStunBindingOrResolveRequestFailed(*((_QWORD *)this + 7), (cricket::StunBindingRequest *)((char *)this + 64), 701, "STUN binding request timed out.", 0x1FuLL);
}

_BYTE *cricket::IceCandidateErrorEvent::IceCandidateErrorEvent(_BYTE *a1, _BYTE *__src, size_t __len, int a4, char *a5, size_t a6, int a7, int a8, char *__srca, size_t __lena)
{
  _BYTE *v16;
  size_t v17;
  size_t v18;
  _BYTE *v19;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  char *v26;
  size_t v27;
  size_t v28;

  if (__len > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_35;
  v16 = a1;
  if (__len > 0x16)
  {
    v17 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v17 = __len | 7;
    v18 = v17 + 1;
    a1 = operator new(v17 + 1);
    *((_QWORD *)v16 + 1) = __len;
    *((_QWORD *)v16 + 2) = v18 | 0x8000000000000000;
    *(_QWORD *)v16 = a1;
  }
  else
  {
    a1[23] = __len;
  }
  v19 = &a1[__len];
  if (a1 <= __src && v19 > __src)
    goto LABEL_34;
  if (__len)
    memmove(a1, __src, __len);
  *v19 = 0;
  *((_DWORD *)v16 + 6) = a4;
  if (a6 > 0x7FFFFFFFFFFFFFF7)
LABEL_35:
    abort();
  if (a6 <= 0x16)
  {
    v21 = v16 + 32;
    v16[55] = a6;
    v22 = &v16[a6 + 32];
    if (v16 + 32 > a5)
      goto LABEL_21;
    goto LABEL_20;
  }
  v23 = (a6 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((a6 | 7) != 0x17)
    v23 = a6 | 7;
  v24 = v23 + 1;
  v21 = (char *)operator new(v23 + 1);
  *((_QWORD *)v16 + 5) = a6;
  *((_QWORD *)v16 + 6) = v24 | 0x8000000000000000;
  *((_QWORD *)v16 + 4) = v21;
  v22 = &v21[a6];
  if (v21 <= a5)
  {
LABEL_20:
    if (v22 <= a5)
      goto LABEL_21;
LABEL_34:
    __break(1u);
    goto LABEL_35;
  }
LABEL_21:
  if (a6)
    memmove(v21, a5, a6);
  *v22 = 0;
  *((_DWORD *)v16 + 14) = a7;
  if (__lena > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_35;
  if (__lena <= 0x16)
  {
    v25 = v16 + 64;
    v16[87] = __lena;
    v26 = &v16[__lena + 64];
    if (v16 + 64 > __srca)
      goto LABEL_31;
    goto LABEL_30;
  }
  v27 = (__lena & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((__lena | 7) != 0x17)
    v27 = __lena | 7;
  v28 = v27 + 1;
  v25 = (char *)operator new(v27 + 1);
  *((_QWORD *)v16 + 9) = __lena;
  *((_QWORD *)v16 + 10) = v28 | 0x8000000000000000;
  *((_QWORD *)v16 + 8) = v25;
  v26 = &v25[__lena];
  if (v25 <= __srca)
  {
LABEL_30:
    if (v26 <= __srca)
      goto LABEL_31;
    goto LABEL_34;
  }
LABEL_31:
  if (__lena)
    memmove(v25, __srca, __lena);
  *v26 = 0;
  return v16;
}

uint64_t absl::internal_any_invocable::RemoteInvoker<false,void,cricket::UDPPort::AddressResolver::Resolve(rtc::SocketAddress const&,int,webrtc::FieldTrialsView const&)::$_0 &>(uint64_t result)
{
  char *v1;
  uint64_t v2;
  _QWORD *v3;
  char *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v1 = (char *)(*(_QWORD *)result + 8);
  v2 = **(_QWORD **)result;
  v3 = *(_QWORD **)(v2 + 48);
  if (v3)
  {
    v4 = (char *)(v2 + 48);
    do
    {
      result = rtc::SocketAddress::operator<((uint64_t)(v3 + 4), v1);
      v5 = v3 + 1;
      if (!(_DWORD)result)
      {
        v5 = v3;
        v4 = (char *)v3;
      }
      v3 = (_QWORD *)*v5;
    }
    while (*v5);
    if (v4 != (char *)(v2 + 48))
    {
      result = rtc::SocketAddress::operator<((uint64_t)v1, v4 + 32);
      if ((result & 1) == 0)
      {
        v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v4 + 13) + 32))(*((_QWORD *)v4 + 13));
        v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
        v7 = *(_QWORD *)(v2 + 32);
        if (v7)
        {
          return (*(uint64_t (**)(uint64_t, _QWORD *, int *))(*(_QWORD *)v7 + 48))(v7, (_QWORD *)v4 + 4, &v9);
        }
        else
        {
          v8 = std::__throw_bad_function_call[abi:sn180100]();
          return absl::internal_any_invocable::RemoteManagerNontrivial<cricket::UDPPort::AddressResolver::Resolve(rtc::SocketAddress const&,int,webrtc::FieldTrialsView const&)::$_0>(v8);
        }
      }
    }
  }
  return result;
}

uint64_t absl::internal_any_invocable::RemoteManagerNontrivial<cricket::UDPPort::AddressResolver::Resolve(rtc::SocketAddress const&,int,webrtc::FieldTrialsView const&)::$_0>(uint64_t result, uint64_t *a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *a2;
  if ((result & 1) != 0)
  {
    if (v3)
    {
      if (*(char *)(v3 + 31) < 0)
        operator delete(*(void **)(v3 + 8));
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    *a3 = v3;
  }
  return result;
}

void std::__function::__func<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C0C1A38;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C0C1A38;
  a2[1] = v2;
  return result;
}

void std::__function::__func<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::operator()(uint64_t a1, const void **a2, uint64_t *a3, cricket::StunRequest **a4)
{
  cricket::UDPPort::OnSendPacket(*(cricket::UDPPort **)(a1 + 8), *a2, *a3, *a4);
}

void std::__function::__func<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C0C1A80;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C0C1A80;
  a2[1] = v2;
  return result;
}

void std::__function::__func<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::UDPPort::UDPPort(rtc::Thread *,webrtc::IceCandidateType,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,BOOL,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::operator()(uint64_t a1, const void **a2, uint64_t *a3, cricket::StunRequest **a4)
{
  cricket::UDPPort::OnSendPacket(*(cricket::UDPPort **)(a1 + 8), *a2, *a3, *a4);
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,cricket::UDPPort::Init(void)::$_0 &,rtc::AsyncPacketSocket *,rtc::ReceivedPacket const&>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return cricket::UDPPort::OnReadPacket(*a1, a3);
}

uint64_t sigslot::_opaque_connection::emitter<cricket::UDPPort,rtc::AsyncPacketSocket *,rtc::SentPacket const&>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = a1[1];
  if (v3)
    v4 = v3 - 232;
  else
    v4 = 0;
  v5 = (_QWORD *)(v4 + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v5 + v1);
  return v1(v5);
}

uint64_t sigslot::_opaque_connection::emitter<cricket::UDPPort,rtc::AsyncPacketSocket *>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = a1[1];
  if (v3)
    v4 = v3 - 232;
  else
    v4 = 0;
  v5 = (_QWORD *)(v4 + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v5 + v1);
  return v1(v5);
}

uint64_t sigslot::_opaque_connection::emitter<cricket::UDPPort,rtc::AsyncPacketSocket *,rtc::SocketAddress const&>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = a1[1];
  if (v3)
    v4 = v3 - 232;
  else
    v4 = 0;
  v5 = (_QWORD *)(v4 + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v5 + v1);
  return v1(v5);
}

void std::__function::__func<cricket::UDPPort::ResolveStunAddress(rtc::SocketAddress const&)::$_0,std::allocator<cricket::UDPPort::ResolveStunAddress(rtc::SocketAddress const&)::$_0>,void ()(rtc::SocketAddress const&,int)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<cricket::UDPPort::ResolveStunAddress(rtc::SocketAddress const&)::$_0,std::allocator<cricket::UDPPort::ResolveStunAddress(rtc::SocketAddress const&)::$_0>,void ()(rtc::SocketAddress const&,int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C0C1AC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<cricket::UDPPort::ResolveStunAddress(rtc::SocketAddress const&)::$_0,std::allocator<cricket::UDPPort::ResolveStunAddress(rtc::SocketAddress const&)::$_0>,void ()(rtc::SocketAddress const&,int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C0C1AC8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<cricket::UDPPort::ResolveStunAddress(rtc::SocketAddress const&)::$_0,std::allocator<cricket::UDPPort::ResolveStunAddress(rtc::SocketAddress const&)::$_0>,void ()(rtc::SocketAddress const&,int)>::operator()(uint64_t a1, char *a2, int *a3)
{
  cricket::UDPPort *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  char *v19;
  int v20;
  _QWORD *v21;
  uint64_t v22;
  char **v23;
  _QWORD *v24;
  char *v25;
  char *v26;
  int v27;
  _QWORD *v28;
  char *v29;
  char *v30;
  char *v31;
  BOOL v32;
  _QWORD *v33;
  char *v34;
  int v35;
  _QWORD *v36;
  void *__p;
  unsigned int v38;
  char v39;
  void *__s2[2];
  uint64_t v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  __int16 v46;
  int v47;
  char v48;

  v4 = *(cricket::UDPPort **)(a1 + 8);
  v5 = *a3;
  __s2[0] = 0;
  __s2[1] = 0;
  v41 = 0;
  v42 = &unk_24C0ACDA0;
  v48 = 0;
  v46 = 0;
  v47 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  if (v5)
    goto LABEL_45;
  v13 = *((_QWORD *)v4 + 118);
  v14 = (*(uint64_t (**)(cricket::UDPPort *))(*(_QWORD *)v4 + 24))(v4);
  rtc::Network::GetBestIP(v14, (uint64_t)&__p);
  v17 = *(_QWORD **)(v13 + 48);
  v15 = (char *)(v13 + 48);
  v16 = v17;
  if (!v17)
    goto LABEL_45;
  v18 = v38;
  v19 = v15;
  do
  {
    v20 = rtc::SocketAddress::operator<((uint64_t)(v16 + 4), a2);
    v21 = v16 + 1;
    if (!v20)
    {
      v21 = v16;
      v19 = (char *)v16;
    }
    v16 = (_QWORD *)*v21;
  }
  while (*v21);
  if (v19 == v15
    || (rtc::SocketAddress::operator<((uint64_t)a2, v19 + 32) & 1) != 0
    || (v22 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v19 + 13) + 32))(*((_QWORD *)v19 + 13)),
        ((*(uint64_t (**)(uint64_t, uint64_t, void **))(*(_QWORD *)v22 + 16))(v22, v18, __s2) & 1) == 0))
  {
LABEL_45:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      (*(void (**)(void **__return_ptr, cricket::UDPPort *))(*(_QWORD *)v4 + 176))(&__p, v4);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_port.cc");
      if (v39 < 0)
        operator delete(__p);
    }
    cricket::UDPPort::OnStunBindingOrResolveRequestFailed((uint64_t)v4, (rtc::SocketAddress *)a2, 701, "STUN host lookup received error.", 0x20uLL);
  }
  else
  {
    v23 = (char **)((char *)v4 + 792);
    v24 = (_QWORD *)*((_QWORD *)v4 + 100);
    if (!v24)
      goto LABEL_42;
    v25 = (char *)v4 + 800;
    v26 = (char *)v4 + 800;
    do
    {
      v27 = rtc::SocketAddress::operator<((uint64_t)(v24 + 4), a2);
      v28 = v24 + 1;
      if (!v27)
      {
        v28 = v24;
        v26 = (char *)v24;
      }
      v24 = (_QWORD *)*v28;
    }
    while (*v28);
    if (v26 != v25 && (rtc::SocketAddress::operator<((uint64_t)a2, v26 + 32) & 1) == 0)
    {
      v29 = (char *)*((_QWORD *)v26 + 1);
      if (v29)
      {
        do
        {
          v30 = v29;
          v29 = *(char **)v29;
        }
        while (v29);
      }
      else
      {
        v31 = v26;
        do
        {
          v30 = (char *)*((_QWORD *)v31 + 2);
          v32 = *(_QWORD *)v30 == (_QWORD)v31;
          v31 = v30;
        }
        while (!v32);
      }
      if (*v23 == v26)
        *v23 = v30;
      --*((_QWORD *)v4 + 101);
      std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v4 + 100), (uint64_t *)v26);
      if (v26[55] < 0)
        operator delete(*((void **)v26 + 4));
      operator delete(v26);
    }
    v33 = *(_QWORD **)v25;
    if (!*(_QWORD *)v25)
      goto LABEL_42;
    v34 = (char *)v4 + 800;
    do
    {
      v35 = rtc::SocketAddress::operator<((uint64_t)(v33 + 4), (char *)__s2);
      v36 = v33 + 1;
      if (!v35)
      {
        v36 = v33;
        v34 = (char *)v33;
      }
      v33 = (_QWORD *)*v36;
    }
    while (*v36);
    if (v34 == v25 || rtc::SocketAddress::operator<((uint64_t)__s2, v34 + 32))
    {
LABEL_42:
      std::__tree<rtc::SocketAddress>::__emplace_unique_key_args<rtc::SocketAddress,rtc::SocketAddress const&>((uint64_t **)v4 + 99, (char *)__s2, (uint64_t)__s2);
      cricket::UDPPort::SendStunBindingRequest(v4, __s2);
    }
  }
  if (SHIBYTE(v41) < 0)
    operator delete(__s2[0]);
}

void cricket::StunRequestManager::SendDelayed(cricket::StunRequestManager *this, cricket::StunRequest *a2, int a3)
{
  const void **v5;
  uint64_t v6;
  TimeDelta v7;
  cricket::StunRequest *v8;

  v5 = (const void **)(*((_QWORD *)a2 + 2) + 40);
  v8 = a2;
  std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>((uint64_t)this + 8, v5, (uint64_t)v5, (uint64_t *)&v8);
  v6 = (uint64_t)v8;
  v8 = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v7.var0 = 1000 * a3;
  cricket::StunRequest::Send(a2, v7);
}

void cricket::StunRequest::Send(cricket::StunRequest *this, TimeDelta a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  _QWORD *v11;
  char v12;
  char v13;
  _QWORD v14[2];
  uint64_t (*v15)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v16)(uint64_t);

  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    do
      v5 = __ldxr((unsigned int *)v4);
    while (__stxr(v5 + 1, (unsigned int *)v4));
    *(_BYTE *)(v4 + 4) = 1;
    do
    {
      v6 = __ldaxr((unsigned int *)v4);
      v7 = v6 - 1;
    }
    while (__stlxr(v7, (unsigned int *)v4));
    if (!v7)
      MEMORY[0x20BD0ADEC]();
    if (a2.var0)
      goto LABEL_8;
LABEL_12:
    cricket::StunRequest::SendInternal(this);
    return;
  }
  MEMORY[4] = 1;
  if (!a2.var0)
    goto LABEL_12;
LABEL_8:
  v8 = **((_QWORD **)this + 1);
  v9 = (unsigned int *)*((_QWORD *)this + 5);
  if (v9)
  {
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = (_QWORD *)operator new();
  *v11 = v9;
  v11[1] = this;
  v11[3] = absl::internal_any_invocable::LocalManagerTrivial;
  v11[4] = absl::internal_any_invocable::LocalInvoker<false,void,cricket::StunRequest::SendDelayed(webrtc::TimeDelta)::$_0 &&>;
  v14[0] = v11;
  v15 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
  v16 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  v13 = 0;
  (*(void (**)(uint64_t, _QWORD *, int64_t, char *, char *))(*(_QWORD *)v8 + 16))(v8, v14, a2.var0, &v13, &v12);
  v15(1, v14, v14);
}

uint64_t cricket::StunRequestManager::CheckResponse(uint64_t **this, cricket::StunMessage *a2)
{
  _QWORD *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  size_t v8;
  void **v9;
  size_t v10;
  void *v11;
  BOOL v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  std::string::size_type size;
  std::string::size_type v28;
  int v29;
  std::string *v30;
  uint64_t v31;
  std::string *v32;
  int v33;
  int v34;
  int v35;
  int v36;
  BOOL v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t *v57;
  int v58;
  int v59;
  uint64_t v61;
  uint64_t *v62;
  uint64_t *v63;
  uint64_t *v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t *v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t *v81;
  uint64_t v82;
  std::string v83;
  std::string v84;

  v4 = (_QWORD *)((char *)a2 + 40);
  v5 = (uint64_t *)(this + 2);
  v6 = std::__tree<std::__value_type<std::string,cricket::ContentGroup const*>,std::__map_value_compare<std::string,std::__value_type<std::string,cricket::ContentGroup const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,cricket::ContentGroup const*>>>::__lower_bound<std::string>((const void **)a2 + 5, this[2], (uint64_t *)this + 2);
  if (v5 == v6)
    return 0;
  v7 = v6;
  if (*((char *)a2 + 63) < 0)
  {
    v8 = *((_QWORD *)a2 + 6);
    if ((v8 & 0x8000000000000000) != 0)
      goto LABEL_128;
    v4 = (_QWORD *)*v4;
    if (v8)
    {
      if (!v4)
        goto LABEL_128;
    }
  }
  else
  {
    v8 = *((unsigned __int8 *)a2 + 63);
  }
  v9 = (void **)(v6 + 4);
  if ((*((char *)v6 + 55) & 0x80000000) == 0)
  {
    v10 = *((unsigned __int8 *)v6 + 55);
    v11 = v6 + 4;
    goto LABEL_14;
  }
  v10 = v6[5];
  if ((v10 & 0x8000000000000000) != 0 || ((v11 = *v9, v10) ? (v12 = v11 == 0) : (v12 = 0), v12))
  {
LABEL_128:
    __break(1u);
    goto LABEL_129;
  }
LABEL_14:
  if (v10 >= v8)
    v13 = v8;
  else
    v13 = v10;
  v6 = (uint64_t *)memcmp(v4, v11, v13);
  if ((_DWORD)v6)
  {
    if ((v6 & 0x80000000) != 0)
      return 0;
  }
  else if (v8 < v10)
  {
    return 0;
  }
  v14 = v7[7];
  v15 = *(_QWORD *)(v14 + 16);
  v16 = *(_DWORD *)(v15 + 96);
  if (*(_BYTE *)(v14 + 48))
  {
    if (v16)
    {
      v17 = *((_DWORD *)a2 + 24);
      if (v17 != 2)
      {
        if (!v17)
        {
          if (*(char *)(v15 + 127) < 0)
            std::string::__init_copy_ctor_external(&v84, *(const std::string::value_type **)(v15 + 104), *(_QWORD *)(v15 + 112));
          else
            v84 = *(std::string *)(v15 + 104);
LABEL_68:
          cricket::StunMessage::ValidateMessageIntegrity((uint64_t)a2, &v84);
          if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v84.__r_.__value_.__l.__data_);
          goto LABEL_70;
        }
LABEL_63:
        if (v17 == 3)
        {
          v40 = *(_QWORD *)(v14 + 16);
          if (*(char *)(v40 + 127) < 0)
          {
            std::string::__init_copy_ctor_external(&v84, *(const std::string::value_type **)(v40 + 104), *(_QWORD *)(v40 + 112));
            if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
              goto LABEL_67;
          }
          else
          {
            v84 = *(std::string *)(v40 + 104);
            if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
            {
LABEL_67:
              *((_DWORD *)a2 + 24) = 0;
              goto LABEL_68;
            }
          }
          rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v41, v42, v43, v44, v45, v46, v47, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/transport/stun.cc");
          goto LABEL_67;
        }
LABEL_129:
        rtc::webrtc_checks_impl::UnreachableCodeReached((rtc::webrtc_checks_impl *)v6);
      }
      if (*((char *)a2 + 127) < 0)
      {
        std::string::__init_copy_ctor_external(&v84, *((const std::string::value_type **)a2 + 13), *((_QWORD *)a2 + 14));
        v25 = *(_QWORD *)(v14 + 16);
        if ((*(char *)(v25 + 127) & 0x80000000) == 0)
          goto LABEL_31;
      }
      else
      {
        v84 = *(std::string *)((char *)a2 + 104);
        v25 = *(_QWORD *)(v14 + 16);
        if ((*(char *)(v25 + 127) & 0x80000000) == 0)
        {
LABEL_31:
          v83 = *(std::string *)(v25 + 104);
          goto LABEL_35;
        }
      }
      std::string::__init_copy_ctor_external(&v83, *(const std::string::value_type **)(v25 + 104), *(_QWORD *)(v25 + 112));
LABEL_35:
      v26 = HIBYTE(v84.__r_.__value_.__r.__words[2]);
      if ((v84.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v84.__r_.__value_.__r.__words[2]);
      else
        size = v84.__r_.__value_.__l.__size_;
      v28 = HIBYTE(v83.__r_.__value_.__r.__words[2]);
      v29 = SHIBYTE(v83.__r_.__value_.__r.__words[2]);
      if ((v83.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v28 = v83.__r_.__value_.__l.__size_;
      if (size == v28)
      {
        if ((v83.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v30 = &v83;
        else
          v30 = (std::string *)v83.__r_.__value_.__r.__words[0];
        if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0)
        {
          v6 = (uint64_t *)memcmp(v84.__r_.__value_.__l.__data_, v30, v84.__r_.__value_.__l.__size_);
          v39 = (_DWORD)v6 == 0;
        }
        else if (*((_BYTE *)&v84.__r_.__value_.__s + 23))
        {
          v31 = HIBYTE(v84.__r_.__value_.__r.__words[2]) - 1;
          v32 = &v84;
          do
          {
            v34 = v32->__r_.__value_.__s.__data_[0];
            v32 = (std::string *)((char *)v32 + 1);
            v33 = v34;
            v36 = v30->__r_.__value_.__s.__data_[0];
            v30 = (std::string *)((char *)v30 + 1);
            v35 = v36;
            v38 = v31-- != 0;
            v39 = v33 == v35;
          }
          while (v33 == v35 && v38);
        }
        else
        {
          v39 = 1;
        }
      }
      else
      {
        v39 = 0;
      }
      if (v29 < 0)
      {
        operator delete(v83.__r_.__value_.__l.__data_);
        if ((*((_BYTE *)&v84.__r_.__value_.__s + 23) & 0x80) == 0)
        {
LABEL_58:
          if (v39)
            goto LABEL_70;
          goto LABEL_62;
        }
      }
      else if ((v26 & 0x80) == 0)
      {
        goto LABEL_58;
      }
      operator delete(v84.__r_.__value_.__l.__data_);
      if (v39)
        goto LABEL_70;
LABEL_62:
      v17 = *((_DWORD *)a2 + 24);
      goto LABEL_63;
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v18, v19, v20, v21, v22, v23, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_request.cc");
  }
LABEL_70:
  cricket::StunMessage::GetNonComprehendedAttributes(a2, &v84.__r_.__value_.__l.__data_);
  v48 = *(_OWORD *)&v84.__r_.__value_.__l.__data_;
  if (v84.__r_.__value_.__r.__words[0])
    operator delete(v84.__r_.__value_.__l.__data_);
  if ((_QWORD)v48 != *((_QWORD *)&v48 + 1))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v49, v50, v51, v52, v53, v54, v55, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_request.cc");
    v56 = (uint64_t *)v7[1];
    if (v56)
    {
      do
      {
        v57 = v56;
        v56 = (uint64_t *)*v56;
      }
      while (v56);
    }
    else
    {
      v64 = v7;
      do
      {
        v57 = (uint64_t *)v64[2];
        v12 = *v57 == (_QWORD)v64;
        v64 = v57;
      }
      while (!v12);
    }
    if (this[1] == v7)
      this[1] = v57;
    v65 = this[2];
    this[3] = (uint64_t *)((char *)this[3] - 1);
    std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v65, v7);
    v66 = v7[7];
    v7[7] = 0;
    if (v66)
      (*(void (**)(uint64_t))(*(_QWORD *)v66 + 8))(v66);
    if (*((char *)v7 + 55) < 0)
      operator delete(*v9);
    operator delete(v7);
    return 0;
  }
  v58 = *((unsigned __int16 *)a2 + 16);
  v59 = *(unsigned __int16 *)(*(_QWORD *)(v14 + 16) + 32);
  if ((v59 & 0x110) == 0 && (v59 | 0x100) == v58)
  {
    if (*((_DWORD *)a2 + 24) != 2 && v16)
      return 0;
    v61 = v7[7];
    v7[7] = 0;
    v68 = (uint64_t *)v7[1];
    if (v68)
    {
      do
      {
        v69 = v68;
        v68 = (uint64_t *)*v68;
      }
      while (v68);
    }
    else
    {
      v80 = v7;
      do
      {
        v69 = (uint64_t *)v80[2];
        v12 = *v69 == (_QWORD)v80;
        v80 = v69;
      }
      while (!v12);
    }
    if (this[1] == v7)
      this[1] = v69;
    v81 = this[2];
    this[3] = (uint64_t *)((char *)this[3] - 1);
    std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v81, v7);
    v82 = v7[7];
    v7[7] = 0;
    if (v82)
      (*(void (**)(uint64_t))(*(_QWORD *)v82 + 8))(v82);
    if (*((char *)v7 + 55) < 0)
      operator delete(*v9);
    operator delete(v7);
    (*(void (**)(uint64_t, cricket::StunMessage *))(*(_QWORD *)v61 + 16))(v61, a2);
  }
  else
  {
    if ((v59 & 0x110) != 0 || (v59 | 0x110) != v58)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v70, v71, v72, v73, v74, v75, v76, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_request.cc");
      return 0;
    }
    v61 = v7[7];
    v7[7] = 0;
    v62 = (uint64_t *)v7[1];
    if (v62)
    {
      do
      {
        v63 = v62;
        v62 = (uint64_t *)*v62;
      }
      while (v62);
    }
    else
    {
      v77 = v7;
      do
      {
        v63 = (uint64_t *)v77[2];
        v12 = *v63 == (_QWORD)v77;
        v77 = v63;
      }
      while (!v12);
    }
    if (this[1] == v7)
      this[1] = v63;
    v78 = this[2];
    this[3] = (uint64_t *)((char *)this[3] - 1);
    std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v78, v7);
    v79 = v7[7];
    v7[7] = 0;
    if (v79)
      (*(void (**)(uint64_t))(*(_QWORD *)v79 + 8))(v79);
    if (*((char *)v7 + 55) < 0)
      operator delete(*v9);
    operator delete(v7);
    (*(void (**)(uint64_t, cricket::StunMessage *))(*(_QWORD *)v61 + 24))(v61, a2);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v61 + 8))(v61);
  return 1;
}

uint64_t cricket::StunRequestManager::CheckResponse(uint64_t **this, void **a2, unint64_t a3)
{
  uint64_t v3;
  void **v7;
  uint64_t *v8;
  uint64_t *v9;
  size_t v10;
  char v11;
  uint64_t *v12;
  const void *p_s1;
  _QWORD *v14;
  size_t v15;
  size_t v17;
  int v18;
  cricket::StunMessage *v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  void **v34;
  _BYTE *v35;
  unsigned int v36;
  void *__p[2];
  int64_t v38;
  _QWORD v39[4];
  void *__s1;
  unint64_t v41;
  uint64_t v42;

  if (a3 >= 0x14)
  {
    __s1 = 0;
    v41 = 0;
    v42 = 0;
    v7 = a2 + 1;
    if (&__s1 <= a2 + 1 && (char *)&v41 + 4 > (char *)v7)
      goto LABEL_53;
    __s1 = *v7;
    LODWORD(v41) = *((_DWORD *)a2 + 4);
    HIBYTE(v42) = 12;
    BYTE4(v41) = 0;
    v8 = (uint64_t *)(this + 2);
    v9 = std::__tree<std::__value_type<std::string,cricket::ContentGroup const*>,std::__map_value_compare<std::string,std::__value_type<std::string,cricket::ContentGroup const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,cricket::ContentGroup const*>>>::__lower_bound<std::string>((const void **)&__s1, this[2], (uint64_t *)this + 2);
    v10 = HIBYTE(v42);
    v11 = HIBYTE(v42);
    if (v8 != v9)
    {
      v12 = v9;
      if (SHIBYTE(v42) < 0)
      {
        v10 = v41;
        if ((v41 & 0x8000000000000000) != 0)
          goto LABEL_53;
        p_s1 = __s1;
        if (v41)
        {
          if (!__s1)
            goto LABEL_53;
        }
      }
      else
      {
        p_s1 = &__s1;
      }
      v14 = v12 + 4;
      if (*((char *)v12 + 55) < 0)
      {
        v15 = v12[5];
        if ((v15 & 0x8000000000000000) != 0)
          goto LABEL_53;
        v14 = (_QWORD *)*v14;
        if (v15 && v14 == 0)
          goto LABEL_53;
      }
      else
      {
        v15 = *((unsigned __int8 *)v12 + 55);
      }
      if (v15 >= v10)
        v17 = v10;
      else
        v17 = v15;
      v18 = memcmp(p_s1, v14, v17);
      if (v18)
      {
        if ((v18 & 0x80000000) == 0)
          goto LABEL_23;
      }
      else if (v10 >= v15)
      {
LABEL_23:
        v39[0] = a2;
        v39[1] = a3;
        v39[2] = 0;
        v39[3] = a3;
        v19 = (cricket::StunMessage *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v12[7] + 16) + 16))(*(_QWORD *)(v12[7] + 16));
        if ((cricket::StunMessage::Read((std::string *)v19, (rtc::ByteBufferReader *)v39) & 1) != 0)
        {
          v3 = cricket::StunRequestManager::CheckResponse(this, v19);
          if (!v19)
            goto LABEL_26;
          goto LABEL_25;
        }
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        {
LABEL_51:
          v3 = 0;
          if (!v19)
          {
LABEL_26:
            if ((v42 & 0x8000000000000000) == 0)
              return v3;
LABEL_30:
            operator delete(__s1);
            return v3;
          }
LABEL_25:
          (*(void (**)(cricket::StunMessage *))(*(_QWORD *)v19 + 8))(v19);
          goto LABEL_26;
        }
        if ((SHIBYTE(v42) & 0x80000000) == 0)
        {
          v28 = HIBYTE(v42);
          v29 = (unsigned __int8 *)&__s1;
          goto LABEL_39;
        }
        v28 = v41;
        if ((v41 & 0x8000000000000000) == 0)
        {
          v29 = (unsigned __int8 *)__s1;
          if (!v41 || __s1)
          {
            if (v41 < 0x3FFFFFFFFFFFFFFCLL)
            {
LABEL_39:
              v30 = 2 * v28;
              if (v28 >= 0xC)
              {
                v32 = (v30 & 0x7FFFFFFFFFFFFFF8) + 8;
                if ((v30 | 7) != 0x17)
                  v32 = v30 | 7;
                v33 = v32 + 1;
                v31 = operator new(v32 + 1);
                __p[1] = (void *)(2 * v28);
                v38 = v33 | 0x8000000000000000;
                __p[0] = v31;
              }
              else
              {
                HIBYTE(v38) = 2 * v28;
                v31 = __p;
                if (!v28)
                {
                  LOBYTE(__p[0]) = 0;
LABEL_49:
                  rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v21, v22, v23, v24, v25, v26, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/stun_request.cc");
                  if (SHIBYTE(v38) < 0)
                    operator delete(__p[0]);
                  goto LABEL_51;
                }
              }
              bzero(v31, 2 * v28);
              *((_BYTE *)v31 + 2 * v28) = 0;
              v34 = __p;
              if (v38 < 0)
                v34 = (void **)__p[0];
              v35 = (char *)v34 + 1;
              do
              {
                v36 = *v29++;
                v35 += 2;
                --v28;
              }
              while (v28);
              goto LABEL_49;
            }
LABEL_54:
            abort();
          }
        }
LABEL_53:
        __break(1u);
        goto LABEL_54;
      }
    }
    v3 = 0;
    if ((v11 & 0x80) == 0)
      return v3;
    goto LABEL_30;
  }
  return 0;
}

uint64_t cricket::StunRequest::StunRequest(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;

  *(_QWORD *)a1 = &off_24C0C1B10;
  *(_QWORD *)(a1 + 8) = a2;
  v4 = *a3;
  *a3 = 0;
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 36) = 0;
  v5 = operator new();
  *(_DWORD *)v5 = 0;
  *(_BYTE *)(v5 + 4) = 0;
  do
    v6 = __ldxr((unsigned int *)v5);
  while (__stxr(v6 + 1, (unsigned int *)v5));
  *(_QWORD *)(a1 + 40) = v5;
  *(_BYTE *)(a1 + 48) = 1;
  return a1;
}

void cricket::StunRequest::~StunRequest(cricket::StunRequest *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C0C1B10;
  v2 = *((_QWORD *)this + 5);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  v5 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
}

{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C0C1B10;
  v2 = *((_QWORD *)this + 5);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  v5 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::StunRequest::SendInternal(cricket::StunRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t *v5;
  uint64_t *v6;
  size_t v7;
  uint64_t v8;
  BOOL v9;
  void **v10;
  size_t v11;
  void *v12;
  size_t v14;
  int v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int *v24;
  unsigned int v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  cricket::StunRequest *v34;
  uint64_t v35;
  _QWORD v36[2];
  uint64_t (*v37)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v38)(uint64_t);

  if (!*((_BYTE *)this + 36))
  {
    if (rtc::g_clock)
    {
      v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
    }
    else
    {
      if (!dword_253EA791C)
        mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
      v8 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
         / dword_253EA791C;
    }
    *((_QWORD *)this + 3) = v8 / 1000000;
    v18 = operator new[]();
    v19 = *((_QWORD *)this + 2);
    v33 = v18;
    v32 = xmmword_208F070B0;
    cricket::StunMessage::Write(v19, (uint64_t)&v32);
    v20 = *((_QWORD *)this + 1);
    v35 = v32;
    v36[0] = v33;
    v34 = this;
    v21 = *(_QWORD *)(v20 + 56);
    if (v21)
    {
      (*(void (**)(uint64_t, _QWORD *, uint64_t *, cricket::StunRequest **))(*(_QWORD *)v21 + 48))(v21, v36, &v35, &v34);
      (*(void (**)(cricket::StunRequest *))(*(_QWORD *)this + 40))(this);
      v22 = 1000 * (*(int (**)(cricket::StunRequest *))(*(_QWORD *)this + 48))(this);
      v23 = **((_QWORD **)this + 1);
      v24 = (unsigned int *)*((_QWORD *)this + 5);
      if (v24)
      {
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      v26 = (_QWORD *)operator new();
      *v26 = v24;
      v26[1] = this;
      v26[3] = absl::internal_any_invocable::LocalManagerTrivial;
      v26[4] = absl::internal_any_invocable::LocalInvoker<false,void,cricket::StunRequest::SendDelayed(webrtc::TimeDelta)::$_0 &&>;
      v36[0] = v26;
      v37 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
      v38 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
      LOBYTE(v35) = 0;
      (*(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t *, cricket::StunRequest **))(*(_QWORD *)v23 + 16))(v23, v36, v22, &v35, &v34);
      v37(1, v36, v36);
      v27 = v33;
      v33 = 0;
      if (v27)
        MEMORY[0x20BD0ADD4](v27, 0x1000C8077774924);
      return;
    }
LABEL_48:
    v31 = std::__throw_bad_function_call[abi:sn180100]();
    cricket::StunRequest::OnSent(v31);
    return;
  }
  (*(void (**)(cricket::StunRequest *))(*(_QWORD *)this + 32))(this);
  v2 = *((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 2);
  v4 = (_QWORD *)(v3 + 40);
  v5 = std::__tree<std::__value_type<std::string,cricket::ContentGroup const*>,std::__map_value_compare<std::string,std::__value_type<std::string,cricket::ContentGroup const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,cricket::ContentGroup const*>>>::__lower_bound<std::string>((const void **)(v3 + 40), *(uint64_t **)(v2 + 16), (uint64_t *)(v2 + 16));
  if ((uint64_t *)(v2 + 16) == v5)
    return;
  v6 = v5;
  if (*(char *)(v3 + 63) < 0)
  {
    v7 = *(_QWORD *)(v3 + 48);
    if ((v7 & 0x8000000000000000) != 0 || ((v4 = (_QWORD *)*v4, v7) ? (v9 = v4 == 0) : (v9 = 0), v9))
    {
LABEL_47:
      __break(1u);
      goto LABEL_48;
    }
  }
  else
  {
    v7 = *(unsigned __int8 *)(v3 + 63);
  }
  v10 = (void **)(v5 + 4);
  if (*((char *)v5 + 55) < 0)
  {
    v11 = v5[5];
    if ((v11 & 0x8000000000000000) == 0)
    {
      v12 = *v10;
      if (!v11 || v12 != 0)
        goto LABEL_19;
    }
    goto LABEL_47;
  }
  v11 = *((unsigned __int8 *)v5 + 55);
  v12 = v5 + 4;
LABEL_19:
  if (v11 >= v7)
    v14 = v7;
  else
    v14 = v11;
  v15 = memcmp(v4, v12, v14);
  if (v15)
  {
    if (v15 < 0)
      return;
  }
  else if (v7 < v11)
  {
    return;
  }
  v16 = (uint64_t *)v6[1];
  if (v16)
  {
    do
    {
      v17 = v16;
      v16 = (uint64_t *)*v16;
    }
    while (v16);
  }
  else
  {
    v28 = v6;
    do
    {
      v17 = (uint64_t *)v28[2];
      v9 = *v17 == (_QWORD)v28;
      v28 = v17;
    }
    while (!v9);
  }
  if (*(uint64_t **)(v2 + 8) == v6)
    *(_QWORD *)(v2 + 8) = v17;
  v29 = *(uint64_t **)(v2 + 16);
  --*(_QWORD *)(v2 + 24);
  std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v29, v6);
  v30 = v6[7];
  v6[7] = 0;
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  if (*((char *)v6 + 55) < 0)
    operator delete(*v10);
  operator delete(v6);
}

uint64_t cricket::StunRequest::OnSent(uint64_t this)
{
  int v1;

  v1 = *(_DWORD *)(this + 32);
  *(_DWORD *)(this + 32) = v1 + 1;
  if (v1 >= 8)
    *(_BYTE *)(this + 36) = 1;
  return this;
}

uint64_t cricket::StunRequest::resend_delay(cricket::StunRequest *this)
{
  int v1;
  int v2;

  v1 = *((_DWORD *)this + 8);
  v2 = 250 << (v1 - 1);
  if (v2 >= 8000)
    v2 = 8000;
  if (v1)
    return v2;
  else
    return 0;
}

_QWORD *std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>(uint64_t a1, const void **a2, uint64_t a3, uint64_t *a4)
{
  const void **v7;
  _QWORD *v8;
  uint64_t **v9;
  std::string *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v16;

  v7 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(a1, &v16, a2);
  v8 = *v7;
  if (!*v7)
  {
    v9 = (uint64_t **)v7;
    v8 = operator new(0x40uLL);
    v10 = (std::string *)(v8 + 4);
    if (*(char *)(a3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
      v8[6] = *(_QWORD *)(a3 + 16);
    }
    v11 = *a4;
    *a4 = 0;
    v8[7] = v11;
    v12 = v16;
    *v8 = 0;
    v8[1] = 0;
    v8[2] = v12;
    *v9 = v8;
    v13 = **(_QWORD **)a1;
    v14 = v8;
    if (v13)
    {
      *(_QWORD *)a1 = v13;
      v14 = *v9;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 8), v14);
    ++*(_QWORD *)(a1 + 16);
  }
  return v8;
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,cricket::StunRequest::SendDelayed(webrtc::TimeDelta)::$_0 &&>(cricket::StunRequest **a1)
{
  return cricket::StunRequest::SendInternal(*a1);
}

webrtc::SubbandErleEstimator *webrtc::SubbandErleEstimator::SubbandErleEstimator(webrtc::SubbandErleEstimator *this, const webrtc::EchoCanceller3Config *a2, unint64_t a3, double a4, int32x2_t a5)
{
  int32x4_t v7;
  int32x4_t v8;
  uint64_t v9;
  int v10;
  void *v11;
  size_t *v12;
  size_t *v13;
  size_t *v14;
  _DWORD *v15;
  size_t *v16;
  BOOL v19;
  size_t v20;
  size_t v21;
  char *v22;
  char *v23;
  size_t v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  size_t v29;
  size_t v30;
  char *v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  char *v44;
  size_t v46[2];
  unsigned __int8 v47;

  *(_BYTE *)this = *((_BYTE *)a2 + 252);
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 60);
  a5.i32[0] = *((_DWORD *)a2 + 62);
  v7 = vdupq_lane_s32(*(int32x2_t *)((char *)a2 + 244), 0);
  *(int32x4_t *)((char *)this + 8) = v7;
  *(int32x4_t *)((char *)this + 24) = v7;
  *(int32x4_t *)((char *)this + 40) = v7;
  *(int32x4_t *)((char *)this + 56) = v7;
  *(int32x4_t *)((char *)this + 72) = v7;
  *(int32x4_t *)((char *)this + 88) = v7;
  *(int32x4_t *)((char *)this + 104) = v7;
  *(int32x4_t *)((char *)this + 120) = v7;
  v8 = vdupq_lane_s32(a5, 0);
  *(int32x4_t *)((char *)this + 136) = v8;
  *(int32x4_t *)((char *)this + 152) = v8;
  *(int32x4_t *)((char *)this + 168) = v8;
  *(int32x4_t *)((char *)this + 184) = v8;
  *(int32x4_t *)((char *)this + 200) = v8;
  *(int32x4_t *)((char *)this + 216) = v8;
  *(int32x4_t *)((char *)this + 232) = v8;
  *(int32x4_t *)((char *)this + 248) = v8;
  *((_DWORD *)this + 66) = a5.i32[0];
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3MinErleDuringOnsetsKillSwitch", 0x28uLL, v46);
  v9 = v47;
  v10 = (char)v47;
  v11 = (void *)v46[0];
  if ((v47 & 0x80u) == 0)
  {
    v12 = v46;
  }
  else
  {
    v9 = v46[1];
    v12 = (size_t *)v46[0];
  }
  v13 = (size_t *)((char *)v12 + v9);
  if (v9 >= 7)
  {
    v14 = v12;
    do
    {
      v15 = memchr(v14, 69, v9 - 6);
      if (!v15)
        break;
      v16 = (size_t *)v15;
      if (*v15 == 1650552389 && *(_DWORD *)((char *)v15 + 3) == 1684368482)
        goto LABEL_13;
      v14 = (size_t *)((char *)v15 + 1);
      v9 = (char *)v13 - ((char *)v16 + 1);
    }
    while (v9 > 6);
  }
  v16 = v13;
LABEL_13:
  if (v10 < 0)
    operator delete(v11);
  v19 = v16 == v13 || v16 != v12;
  *((_BYTE *)this + 268) = v19;
  *((_QWORD *)this + 35) = 0;
  *((_QWORD *)this + 36) = 0;
  *((_QWORD *)this + 34) = 0;
  if (a3)
  {
    if (a3 >= 0xFC0FC0FC0FC0FDLL)
      abort();
    v20 = 65 * a3;
    v21 = 260 * a3;
    v22 = (char *)operator new(260 * a3);
    *((_QWORD *)this + 34) = v22;
    v23 = &v22[260 * a3];
    *((_QWORD *)this + 36) = v23;
    v24 = 260 * ((260 * a3 - 260) / 0x104) + 260;
    bzero(v22, v24);
    *((_QWORD *)this + 35) = v23;
    v25 = (char *)operator new(260 * a3);
    *((_QWORD *)this + 37) = v25;
    v26 = &v25[260 * a3];
    *((_QWORD *)this + 39) = v26;
    bzero(v25, v24);
    *((_QWORD *)this + 38) = v26;
    v27 = (char *)operator new(65 * a3);
    *((_QWORD *)this + 40) = v27;
    v28 = &v27[65 * a3];
    *((_QWORD *)this + 42) = v28;
    v29 = 65 * ((65 * a3 - 65) / 0x41) + 65;
    bzero(v27, v29);
    *((_QWORD *)this + 41) = v28;
    v30 = 4 * a3;
    v31 = (char *)operator new(v30);
    *((_QWORD *)this + 43) = v31;
    v32 = &v31[v30];
    *((_QWORD *)this + 45) = &v31[v30];
    bzero(v31, v30);
    *((_QWORD *)this + 44) = v32;
    v33 = (char *)operator new(v21);
    *((_QWORD *)this + 46) = v33;
    v34 = &v33[v21];
    *((_QWORD *)this + 48) = &v33[v21];
    bzero(v33, v24);
    *((_QWORD *)this + 47) = v34;
    v35 = (char *)operator new(v21);
    *((_QWORD *)this + 49) = v35;
    v36 = &v35[v21];
    *((_QWORD *)this + 51) = &v35[v21];
    bzero(v35, v24);
    *((_QWORD *)this + 50) = v36;
    v37 = (char *)operator new(v21);
    *((_QWORD *)this + 52) = v37;
    v38 = &v37[v21];
    *((_QWORD *)this + 54) = &v37[v21];
    bzero(v37, v24);
    *((_QWORD *)this + 53) = v38;
    v39 = (char *)operator new(v21);
    *((_QWORD *)this + 55) = v39;
    v40 = &v39[v21];
    *((_QWORD *)this + 57) = &v39[v21];
    bzero(v39, v24);
    *((_QWORD *)this + 56) = v40;
    v41 = (char *)operator new(v20);
    *((_QWORD *)this + 58) = v41;
    v42 = &v41[v20];
    *((_QWORD *)this + 60) = &v41[v20];
    bzero(v41, v29);
    *((_QWORD *)this + 59) = v42;
    v43 = (char *)operator new(v21);
    *((_QWORD *)this + 61) = v43;
    v44 = &v43[v21];
    *((_QWORD *)this + 63) = &v43[v21];
    bzero(v43, v24);
    *((_QWORD *)this + 62) = v44;
  }
  else
  {
    *((_QWORD *)this + 63) = 0;
    *(_OWORD *)((char *)this + 488) = 0u;
    *(_OWORD *)((char *)this + 472) = 0u;
    *(_OWORD *)((char *)this + 456) = 0u;
    *(_OWORD *)((char *)this + 440) = 0u;
    *(_OWORD *)((char *)this + 424) = 0u;
    *(_OWORD *)((char *)this + 408) = 0u;
    *(_OWORD *)((char *)this + 392) = 0u;
    *(_OWORD *)((char *)this + 376) = 0u;
    *(_OWORD *)((char *)this + 360) = 0u;
    *(_OWORD *)((char *)this + 344) = 0u;
    *(_OWORD *)((char *)this + 328) = 0u;
    *(_OWORD *)((char *)this + 312) = 0u;
    *(_OWORD *)((char *)this + 296) = 0u;
  }
  webrtc::SubbandErleEstimator::Reset(this);
  return this;
}

void webrtc::SubbandErleEstimator::Reset(webrtc::SubbandErleEstimator *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v2 = *((_QWORD *)this + 47) - *((_QWORD *)this + 46);
  if (v2)
  {
    v3 = 0;
    v4 = 0;
    v5 = 0;
    v6 = v2 / 260;
    if (v6 <= 1)
      v7 = 1;
    else
      v7 = v6;
    do
    {
      v8 = *((_QWORD *)this + 46);
      if (0xFC0FC0FC0FC0FC1 * ((*((_QWORD *)this + 47) - v8) >> 2) <= v5)
        goto LABEL_20;
      std::array<float,65ul>::fill[abi:sn180100]((_DWORD *)(v8 + v4), (_DWORD *)this + 1);
      v9 = *((_QWORD *)this + 49);
      if (0xFC0FC0FC0FC0FC1 * ((*((_QWORD *)this + 50) - v9) >> 2) <= v5)
        goto LABEL_20;
      std::array<float,65ul>::fill[abi:sn180100]((_DWORD *)(v9 + v4), (_DWORD *)this + 1);
      v10 = *((_QWORD *)this + 52);
      if (0xFC0FC0FC0FC0FC1 * ((*((_QWORD *)this + 53) - v10) >> 2) <= v5)
        goto LABEL_20;
      std::array<float,65ul>::fill[abi:sn180100]((_DWORD *)(v10 + v4), (_DWORD *)this + 1);
      v11 = *((_QWORD *)this + 55);
      if (0xFC0FC0FC0FC0FC1 * ((*((_QWORD *)this + 56) - v11) >> 2) <= v5)
        goto LABEL_20;
      std::array<float,65ul>::fill[abi:sn180100]((_DWORD *)(v11 + v4), (_DWORD *)this + 1);
      v12 = *((_QWORD *)this + 58);
      if (0xFC0FC0FC0FC0FC1 * (*((_QWORD *)this + 59) - v12) <= v5)
        goto LABEL_20;
      v13 = v12 + v3;
      *(_BYTE *)(v13 + 64) = 1;
      *(_QWORD *)&v14 = 0x101010101010101;
      *((_QWORD *)&v14 + 1) = 0x101010101010101;
      *(_OWORD *)(v13 + 32) = v14;
      *(_OWORD *)(v13 + 48) = v14;
      *(_OWORD *)v13 = v14;
      *(_OWORD *)(v13 + 16) = v14;
      v15 = *((_QWORD *)this + 61);
      if (0xFC0FC0FC0FC0FC1 * ((*((_QWORD *)this + 62) - v15) >> 2) <= v5)
        goto LABEL_20;
      v16 = v15 + v4;
      *(_DWORD *)(v16 + 256) = 0;
      ++v5;
      *(_OWORD *)(v16 + 224) = 0u;
      *(_OWORD *)(v16 + 240) = 0u;
      *(_OWORD *)(v16 + 192) = 0u;
      *(_OWORD *)(v16 + 208) = 0u;
      *(_OWORD *)(v16 + 160) = 0u;
      *(_OWORD *)(v16 + 176) = 0u;
      *(_OWORD *)(v16 + 128) = 0u;
      *(_OWORD *)(v16 + 144) = 0u;
      *(_OWORD *)(v16 + 96) = 0u;
      *(_OWORD *)(v16 + 112) = 0u;
      *(_OWORD *)(v16 + 64) = 0u;
      *(_OWORD *)(v16 + 80) = 0u;
      *(_OWORD *)(v16 + 32) = 0u;
      *(_OWORD *)(v16 + 48) = 0u;
      v4 += 260;
      v3 += 65;
      *(_OWORD *)v16 = 0u;
      *(_OWORD *)(v16 + 16) = 0u;
    }
    while (v7 != v5);
  }
  if (*((_QWORD *)this + 56) != *((_QWORD *)this + 55))
  {
    v17 = 0;
    v18 = 0;
    v19 = 0;
    while (1)
    {
      v20 = *((_QWORD *)this + 34);
      if (0xFC0FC0FC0FC0FC1 * ((*((_QWORD *)this + 35) - v20) >> 2) <= v19)
        break;
      v21 = v20 + v17;
      *(_DWORD *)(v21 + 256) = 0;
      *(_OWORD *)(v21 + 224) = 0uLL;
      *(_OWORD *)(v21 + 240) = 0uLL;
      *(_OWORD *)(v21 + 192) = 0uLL;
      *(_OWORD *)(v21 + 208) = 0uLL;
      *(_OWORD *)(v21 + 160) = 0uLL;
      *(_OWORD *)(v21 + 176) = 0uLL;
      *(_OWORD *)(v21 + 128) = 0uLL;
      *(_OWORD *)(v21 + 144) = 0uLL;
      *(_OWORD *)(v21 + 96) = 0uLL;
      *(_OWORD *)(v21 + 112) = 0uLL;
      *(_OWORD *)(v21 + 64) = 0uLL;
      *(_OWORD *)(v21 + 80) = 0uLL;
      *(_OWORD *)(v21 + 32) = 0uLL;
      *(_OWORD *)(v21 + 48) = 0uLL;
      *(_OWORD *)v21 = 0uLL;
      *(_OWORD *)(v21 + 16) = 0uLL;
      v22 = *((_QWORD *)this + 37);
      if (0xFC0FC0FC0FC0FC1 * ((*((_QWORD *)this + 38) - v22) >> 2) <= v19)
        break;
      v23 = v22 + v17;
      *(_DWORD *)(v23 + 256) = 0;
      *(_OWORD *)(v23 + 224) = 0uLL;
      *(_OWORD *)(v23 + 240) = 0uLL;
      *(_OWORD *)(v23 + 192) = 0uLL;
      *(_OWORD *)(v23 + 208) = 0uLL;
      *(_OWORD *)(v23 + 160) = 0uLL;
      *(_OWORD *)(v23 + 176) = 0uLL;
      *(_OWORD *)(v23 + 128) = 0uLL;
      *(_OWORD *)(v23 + 144) = 0uLL;
      *(_OWORD *)(v23 + 96) = 0uLL;
      *(_OWORD *)(v23 + 112) = 0uLL;
      *(_OWORD *)(v23 + 64) = 0uLL;
      *(_OWORD *)(v23 + 80) = 0uLL;
      *(_OWORD *)(v23 + 32) = 0uLL;
      *(_OWORD *)(v23 + 48) = 0uLL;
      *(_OWORD *)v23 = 0uLL;
      *(_OWORD *)(v23 + 16) = 0uLL;
      v24 = *((_QWORD *)this + 43);
      if (v19 >= (*((_QWORD *)this + 44) - v24) >> 2)
        break;
      *(_DWORD *)(v24 + 4 * v19) = 0;
      v25 = *((_QWORD *)this + 40);
      if (0xFC0FC0FC0FC0FC1 * (*((_QWORD *)this + 41) - v25) <= v19)
        break;
      v26 = v25 + v18;
      ++v19;
      *(_BYTE *)(v26 + 64) = 0;
      *(_OWORD *)(v26 + 32) = 0uLL;
      *(_OWORD *)(v26 + 48) = 0uLL;
      *(_OWORD *)v26 = 0uLL;
      *(_OWORD *)(v26 + 16) = 0uLL;
      v18 += 65;
      v17 += 260;
      if (v19 >= 0xFC0FC0FC0FC0FC1 * ((uint64_t)(*((_QWORD *)this + 56) - *((_QWORD *)this + 55)) >> 2))
        return;
    }
LABEL_20:
    __break(1u);
  }
}

void webrtc::SubbandErleEstimator::~SubbandErleEstimator(webrtc::SubbandErleEstimator *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  v2 = (void *)*((_QWORD *)this + 61);
  if (v2)
  {
    *((_QWORD *)this + 62) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 58);
  if (v3)
  {
    *((_QWORD *)this + 59) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 55);
  if (v4)
  {
    *((_QWORD *)this + 56) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 52);
  if (v5)
  {
    *((_QWORD *)this + 53) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 49);
  if (v6)
  {
    *((_QWORD *)this + 50) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 46);
  if (v7)
  {
    *((_QWORD *)this + 47) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 43);
  if (v8)
  {
    *((_QWORD *)this + 44) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 40);
  if (v9)
  {
    *((_QWORD *)this + 41) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 37);
  if (v10)
  {
    *((_QWORD *)this + 38) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 34);
  if (v11)
  {
    *((_QWORD *)this + 35) = v11;
    operator delete(v11);
  }
}

uint64_t webrtc::SubbandErleEstimator::Update(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  _DWORD *v19;
  uint64_t v20;
  _DWORD *v21;

  if (!a4)
    a3 = 0;
  if (!a6)
    a5 = 0;
  webrtc::SubbandErleEstimator::UpdateAccumulatedSpectra(a1, a2, a3, a4, a5, a6, a7);
  result = webrtc::SubbandErleEstimator::UpdateBands((uint64_t)a1, a7);
  if (*(_BYTE *)a1)
    result = (uint64_t)webrtc::SubbandErleEstimator::DecreaseErlePerBandForLowRenderSignals(a1);
  v10 = a1[46];
  v11 = a1[47];
  v12 = v11 - v10;
  if (v11 != v10)
  {
    v13 = 0;
    v14 = 0;
    v15 = v12 / 260;
    v16 = a1[49];
    v17 = 0xFC0FC0FC0FC0FC1 * ((a1[50] - v16) >> 2);
    if (v15 <= 1)
      v15 = 1;
    while (1)
    {
      v18 = (_DWORD *)(v10 + v13);
      *v18 = *(_DWORD *)(v10 + v13 + 4);
      v18[64] = *(_DWORD *)(v10 + v13 + 252);
      if (v17 == v14)
        break;
      v19 = (_DWORD *)(v16 + v13);
      *v19 = *(_DWORD *)(v16 + v13 + 4);
      v19[64] = *(_DWORD *)(v16 + v13 + 252);
      v20 = a1[52];
      if (0xFC0FC0FC0FC0FC1 * ((a1[53] - v20) >> 2) <= v14)
        break;
      v21 = (_DWORD *)(v20 + v13);
      *v21 = v21[1];
      v21[64] = v21[63];
      ++v14;
      v13 += 260;
      if (v15 == v14)
        return result;
    }
    __break(1u);
  }
  return result;
}

_QWORD *webrtc::SubbandErleEstimator::UpdateAccumulatedSpectra(_QWORD *result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float32x4_t *v23;
  uint64_t v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  float32x4_t *v38;
  unint64_t v39;
  float32x4_t *v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;

  if (a4 >= 1)
  {
    v7 = 0;
    v8 = 0;
    v9 = a4;
    v10 = a5;
    v11 = a3;
    do
    {
      if (((*(_QWORD *)(*a7 + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v8) & 1) != 0)
      {
        v13 = result[43];
        if (v8 >= (result[44] - v13) >> 2)
          goto LABEL_36;
        v14 = result[34];
        v15 = result[35];
        if (*(_DWORD *)(v13 + 4 * v8) == 6)
        {
          *(_DWORD *)(v13 + 4 * v8) = 0;
          if (0xFC0FC0FC0FC0FC1 * ((v15 - v14) >> 2) <= v8)
            goto LABEL_36;
          v16 = v14 + 260 * v8;
          *(_DWORD *)(v16 + 256) = 0;
          *(_OWORD *)(v16 + 224) = 0uLL;
          *(_OWORD *)(v16 + 240) = 0uLL;
          *(_OWORD *)(v16 + 192) = 0uLL;
          *(_OWORD *)(v16 + 208) = 0uLL;
          *(_OWORD *)(v16 + 160) = 0uLL;
          *(_OWORD *)(v16 + 176) = 0uLL;
          *(_OWORD *)(v16 + 128) = 0uLL;
          *(_OWORD *)(v16 + 144) = 0uLL;
          *(_OWORD *)(v16 + 96) = 0uLL;
          *(_OWORD *)(v16 + 112) = 0uLL;
          *(_OWORD *)(v16 + 64) = 0uLL;
          *(_OWORD *)(v16 + 80) = 0uLL;
          *(_OWORD *)(v16 + 32) = 0uLL;
          *(_OWORD *)(v16 + 48) = 0uLL;
          *(_OWORD *)v16 = 0uLL;
          *(_OWORD *)(v16 + 16) = 0uLL;
          v17 = result[37];
          if (0xFC0FC0FC0FC0FC1 * ((result[38] - v17) >> 2) <= v8)
            goto LABEL_36;
          v18 = v17 + 260 * v8;
          *(_DWORD *)(v18 + 256) = 0;
          *(_OWORD *)(v18 + 224) = 0uLL;
          *(_OWORD *)(v18 + 240) = 0uLL;
          *(_OWORD *)(v18 + 192) = 0uLL;
          *(_OWORD *)(v18 + 208) = 0uLL;
          *(_OWORD *)(v18 + 160) = 0uLL;
          *(_OWORD *)(v18 + 176) = 0uLL;
          *(_OWORD *)(v18 + 128) = 0uLL;
          *(_OWORD *)(v18 + 144) = 0uLL;
          *(_OWORD *)(v18 + 96) = 0uLL;
          *(_OWORD *)(v18 + 112) = 0uLL;
          *(_OWORD *)(v18 + 64) = 0uLL;
          *(_OWORD *)(v18 + 80) = 0uLL;
          *(_OWORD *)(v18 + 32) = 0uLL;
          *(_OWORD *)(v18 + 48) = 0uLL;
          *(_OWORD *)v18 = 0uLL;
          *(_OWORD *)(v18 + 16) = 0uLL;
          v19 = result[40];
          if (0xFC0FC0FC0FC0FC1 * (result[41] - v19) <= v8)
            goto LABEL_36;
          v20 = v19 + 65 * v8;
          *(_BYTE *)(v20 + 64) = 0;
          *(_OWORD *)(v20 + 32) = 0uLL;
          *(_OWORD *)(v20 + 48) = 0uLL;
          *(_OWORD *)v20 = 0uLL;
          *(_OWORD *)(v20 + 16) = 0uLL;
          v14 = result[34];
          v15 = result[35];
        }
        if (0xFC0FC0FC0FC0FC1 * ((v15 - v14) >> 2) <= v8)
          goto LABEL_36;
        v21 = 260 * v8;
        v22 = 260 * v8 + 260;
        v23 = (float32x4_t *)(v14 + 260 * v8);
        if ((unint64_t)v23 >= a3 + v22 || a3 + v21 >= (unint64_t)(v14 + v22))
        {
          v25 = (float32x4_t *)(a3 + 260 * v8);
          v26 = vaddq_f32(v25[1], v23[1]);
          *v23 = vaddq_f32(*v25, *v23);
          v23[1] = v26;
          v27 = vaddq_f32(v25[3], v23[3]);
          v23[2] = vaddq_f32(v25[2], v23[2]);
          v23[3] = v27;
          v28 = vaddq_f32(v25[5], v23[5]);
          v23[4] = vaddq_f32(v25[4], v23[4]);
          v23[5] = v28;
          v29 = vaddq_f32(v25[7], v23[7]);
          v23[6] = vaddq_f32(v25[6], v23[6]);
          v23[7] = v29;
          v30 = vaddq_f32(v25[9], v23[9]);
          v23[8] = vaddq_f32(v25[8], v23[8]);
          v23[9] = v30;
          v31 = vaddq_f32(v25[11], v23[11]);
          v23[10] = vaddq_f32(v25[10], v23[10]);
          v23[11] = v31;
          v32 = vaddq_f32(v25[13], v23[13]);
          v23[12] = vaddq_f32(v25[12], v23[12]);
          v23[13] = v32;
          v33 = vaddq_f32(v25[15], v23[15]);
          v23[14] = vaddq_f32(v25[14], v23[14]);
          v23[15] = v33;
          v23 += 16;
          v24 = 64;
        }
        else
        {
          v24 = 0;
        }
        v34 = a5 + v21;
        v35 = a5 + v22;
        v36 = 4 * v24;
        do
        {
          v23->f32[0] = *(float *)(v11 + v36) + v23->f32[0];
          v23 = (float32x4_t *)((char *)v23 + 4);
          v36 += 4;
        }
        while (v36 != 260);
        v37 = result[37];
        if (0xFC0FC0FC0FC0FC1 * ((result[38] - v37) >> 2) <= v8)
          goto LABEL_36;
        v38 = (float32x4_t *)(v37 + 260 * v8);
        v39 = v37 + v22;
        if ((unint64_t)v38 >= v35 || v34 >= v39)
        {
          v41 = (float32x4_t *)(a5 + 260 * v8);
          v42 = vaddq_f32(v41[1], v38[1]);
          *v38 = vaddq_f32(*v41, *v38);
          v38[1] = v42;
          v43 = vaddq_f32(v41[3], v38[3]);
          v38[2] = vaddq_f32(v41[2], v38[2]);
          v38[3] = v43;
          v44 = vaddq_f32(v41[5], v38[5]);
          v38[4] = vaddq_f32(v41[4], v38[4]);
          v38[5] = v44;
          v45 = vaddq_f32(v41[7], v38[7]);
          v38[6] = vaddq_f32(v41[6], v38[6]);
          v38[7] = v45;
          v46 = vaddq_f32(v41[9], v38[9]);
          v38[8] = vaddq_f32(v41[8], v38[8]);
          v38[9] = v46;
          v47 = vaddq_f32(v41[11], v38[11]);
          v38[10] = vaddq_f32(v41[10], v38[10]);
          v38[11] = v47;
          v48 = vaddq_f32(v41[13], v38[13]);
          v38[12] = vaddq_f32(v41[12], v38[12]);
          v38[13] = v48;
          v49 = vaddq_f32(v41[15], v38[15]);
          v38[14] = vaddq_f32(v41[14], v38[14]);
          v38[15] = v49;
          v38 += 16;
          v50 = 64;
        }
        else
        {
          v50 = 0;
        }
        v51 = 4 * v50;
        do
        {
          v38->f32[0] = *(float *)(v10 + v51) + v38->f32[0];
          v38 = (float32x4_t *)((char *)v38 + 4);
          v51 += 4;
        }
        while (v51 != 260);
        v52 = result[40];
        if (0xFC0FC0FC0FC0FC1 * (result[41] - v52) <= v8)
          goto LABEL_36;
        v53 = 0;
        v54 = v52 + v7;
        do
        {
          while (!*(_BYTE *)(v54 + v53))
          {
            *(_BYTE *)(v54 + v53) = *(float *)(a2 + 4 * v53) < 44015000.0;
            if (++v53 == 65)
              goto LABEL_3;
          }
          *(_BYTE *)(v54 + v53++) = 1;
        }
        while (v53 != 65);
LABEL_3:
        v12 = result[43];
        if (v8 >= (result[44] - v12) >> 2)
        {
LABEL_36:
          __break(1u);
          return result;
        }
        ++*(_DWORD *)(v12 + 4 * v8);
      }
      ++v8;
      v11 += 260;
      v10 += 260;
      v7 += 65;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t webrtc::SubbandErleEstimator::UpdateBands(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t j;
  float v13;
  float *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  float v21;
  uint64_t v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  uint64_t v39;
  uint64_t v40;
  float v41;
  float v42;
  float v43;
  float v44;
  uint64_t v45;
  uint64_t v46;
  float v47;
  float v48;
  float v49;
  float v50;
  _BYTE v51[256];
  _OWORD v52[4];
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(result + 272);
  v3 = 0xFC0FC0FC0FC0FC1 * ((*(_QWORD *)(result + 280) - v2) >> 2);
  if ((int)v3 >= 1)
  {
    v4 = 0;
    v5 = 0;
    v6 = *a2;
    v7 = result + 12;
    for (i = 1; ; i += 65)
    {
      if (((*(_QWORD *)(v6 + ((v5 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v5) & 1) != 0)
      {
        v9 = *(_QWORD *)(result + 344);
        if (v5 >= (*(_QWORD *)(result + 352) - v9) >> 2)
          goto LABEL_128;
        if (*(_DWORD *)(v9 + 4 * v5) == 6)
          break;
      }
LABEL_3:
      ++v5;
      v2 += 260;
      v4 += 260;
      if (v5 == v3)
        return result;
    }
    memset(v52, 0, sizeof(v52));
    v10 = *(_QWORD *)(result + 296);
    if (0xFC0FC0FC0FC0FC1 * ((*(_QWORD *)(result + 304) - v10) >> 2) > v5)
    {
      if (v3 > v5)
      {
        v11 = v10 + v4;
        for (j = 1; j != 64; ++j)
        {
          v13 = *(float *)(v11 + 4 * j);
          if (v13 > 0.0)
          {
            *(float *)&v51[4 * j] = *(float *)(v2 + 4 * j) / v13;
            *((_BYTE *)v52 + j) = 1;
          }
        }
        goto LABEL_76;
      }
      v14 = (float *)(v10 + 260 * v5);
      if (v14[1] <= 0.0
        && v14[2] <= 0.0
        && v14[3] <= 0.0
        && v14[4] <= 0.0
        && v14[5] <= 0.0
        && v14[6] <= 0.0
        && v14[7] <= 0.0
        && v14[8] <= 0.0
        && v14[9] <= 0.0
        && v14[10] <= 0.0
        && v14[11] <= 0.0
        && v14[12] <= 0.0
        && v14[13] <= 0.0
        && v14[14] <= 0.0
        && v14[15] <= 0.0
        && v14[16] <= 0.0
        && v14[17] <= 0.0
        && v14[18] <= 0.0
        && v14[19] <= 0.0
        && v14[20] <= 0.0
        && v14[21] <= 0.0
        && v14[22] <= 0.0
        && v14[23] <= 0.0
        && v14[24] <= 0.0
        && v14[25] <= 0.0
        && v14[26] <= 0.0
        && v14[27] <= 0.0
        && v14[28] <= 0.0
        && v14[29] <= 0.0
        && v14[30] <= 0.0
        && v14[31] <= 0.0
        && v14[32] <= 0.0
        && v14[33] <= 0.0
        && v14[34] <= 0.0
        && v14[35] <= 0.0
        && v14[36] <= 0.0
        && v14[37] <= 0.0
        && v14[38] <= 0.0
        && v14[39] <= 0.0
        && v14[40] <= 0.0
        && v14[41] <= 0.0
        && v14[42] <= 0.0
        && v14[43] <= 0.0
        && v14[44] <= 0.0
        && v14[45] <= 0.0
        && v14[46] <= 0.0
        && v14[47] <= 0.0
        && v14[48] <= 0.0
        && v14[49] <= 0.0
        && v14[50] <= 0.0
        && v14[51] <= 0.0
        && v14[52] <= 0.0
        && v14[53] <= 0.0
        && v14[54] <= 0.0
        && v14[55] <= 0.0
        && v14[56] <= 0.0
        && v14[57] <= 0.0
        && v14[58] <= 0.0
        && v14[59] <= 0.0
        && v14[60] <= 0.0
        && v14[61] <= 0.0
        && v14[62] <= 0.0
        && v14[63] <= 0.0)
      {
LABEL_76:
        if (!*(_BYTE *)result)
        {
LABEL_96:
          v28 = 0;
          while (1)
          {
            if (*((_BYTE *)v52 + v28 + 1))
            {
              v29 = *(_QWORD *)(result + 320);
              if (0xFC0FC0FC0FC0FC1 * (*(_QWORD *)(result + 328) - v29) <= v5)
                goto LABEL_128;
              v30 = *(_QWORD *)(result + 368);
              if (0xFC0FC0FC0FC0FC1 * ((*(_QWORD *)(result + 376) - v30) >> 2) <= v5)
                goto LABEL_128;
              v31 = v30 + v4 + 4 * v28;
              v32 = *(float *)&v51[4 * v28 + 4];
              v33 = *(float *)(result + 4);
              v34 = *(float *)(v7 + 4 * v28);
              v35 = *(float *)(v31 + 4);
              v36 = 0.1;
              if (*(_BYTE *)(v29 + i + v28))
                v36 = 0.0;
              v37 = 0.05;
              if (v35 > v32)
                v37 = v36;
              v38 = v35 + (float)(v37 * (float)(v32 - v35));
              if (v38 < v34)
                v34 = v38;
              if (v38 > v33)
                v33 = v34;
              *(float *)(v31 + 4) = v33;
              if (*(_BYTE *)result)
              {
                v39 = *(_QWORD *)(result + 392);
                if (0xFC0FC0FC0FC0FC1 * ((*(_QWORD *)(result + 400) - v39) >> 2) <= v5)
                  goto LABEL_128;
                v40 = v39 + v4 + 4 * v28;
                v41 = *(float *)(v7 + 4 * v28);
                v42 = *(float *)(v40 + 4);
                v43 = 0.05;
                if (v42 > v32)
                  v43 = v36;
                v44 = v42 + (float)(v43 * (float)(v32 - v42));
                if (v44 < v41)
                  v41 = v44;
                if (v44 <= *(float *)(result + 4))
                  v41 = *(float *)(result + 4);
                *(float *)(v40 + 4) = v41;
              }
              v45 = *(_QWORD *)(result + 416);
              if (0xFC0FC0FC0FC0FC1 * ((*(_QWORD *)(result + 424) - v45) >> 2) <= v5)
                goto LABEL_128;
              v46 = v45 + v4 + 4 * v28;
              v47 = *(float *)(v46 + 4);
              if (v47 <= v32)
                v36 = 0.05;
              v48 = v47 + (float)(v36 * (float)(v32 - v47));
              v49 = 100000.0;
              if (v48 < 100000.0)
                v49 = v48;
              if (v48 > *(float *)(result + 4))
                v50 = v49;
              else
                v50 = *(float *)(result + 4);
              *(float *)(v46 + 4) = v50;
            }
            if (++v28 == 63)
              goto LABEL_3;
          }
        }
        v15 = 0;
        while (1)
        {
          if (*((_BYTE *)v52 + v15 + 1))
          {
            v17 = *(_QWORD *)(result + 320);
            if (0xFC0FC0FC0FC0FC1 * (*(_QWORD *)(result + 328) - v17) <= v5)
              break;
            if (!*(_BYTE *)(v17 + i + v15))
            {
              v18 = *(_QWORD *)(result + 464);
              if (0xFC0FC0FC0FC0FC1 * (*(_QWORD *)(result + 472) - v18) <= v5)
                break;
              v19 = v18 + i;
              if (*(_BYTE *)(v19 + v15))
              {
                *(_BYTE *)(v19 + v15) = 0;
                if (!*(_BYTE *)(result + 268))
                {
                  v20 = *(_QWORD *)(result + 440);
                  if (0xFC0FC0FC0FC0FC1 * ((*(_QWORD *)(result + 448) - v20) >> 2) <= v5)
                    break;
                  v21 = *(float *)&v51[4 * v15 + 4];
                  v22 = v20 + v4 + 4 * v15;
                  v23 = *(float *)(v22 + 4);
                  v24 = 0.15;
                  if (v21 < v23)
                    v24 = 0.3;
                  v25 = v23 + (float)(v24 * (float)(v21 - v23));
                  v26 = *(float *)(v7 + 4 * v15);
                  if (v25 < v26)
                    v26 = v25;
                  if (v25 > *(float *)(result + 4))
                    v27 = v26;
                  else
                    v27 = *(float *)(result + 4);
                  *(float *)(v22 + 4) = v27;
                }
              }
              v16 = *(_QWORD *)(result + 488);
              if (0xFC0FC0FC0FC0FC1 * ((*(_QWORD *)(result + 496) - v16) >> 2) <= v5)
                break;
              *(_DWORD *)(v16 + v4 + 4 * v15 + 4) = 250;
            }
          }
          if (++v15 == 63)
            goto LABEL_96;
        }
      }
    }
LABEL_128:
    __break(1u);
  }
  return result;
}

_QWORD *webrtc::SubbandErleEstimator::DecreaseErlePerBandForLowRenderSignals(_QWORD *this)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;

  if ((int)(-1057222719 * ((uint64_t)(this[35] - this[34]) >> 2)) >= 1)
  {
    v1 = 0;
    v2 = this[61];
    v3 = 0xFC0FC0FC0FC0FC1 * ((this[62] - v2) >> 2);
    v4 = -1057222719 * ((uint64_t)(this[35] - this[34]) >> 2);
    v5 = 1;
    while (v1 != v3)
    {
      v6 = v5;
      v7 = 63;
      do
      {
        v8 = *(_DWORD *)(v2 + 4 * v6);
        *(_DWORD *)(v2 + 4 * v6) = v8 - 1;
        if (v8 < 152)
        {
          v9 = this[49];
          if (0xFC0FC0FC0FC0FC1 * ((this[50] - v9) >> 2) <= v1)
            goto LABEL_18;
          v10 = this[55];
          if (0xFC0FC0FC0FC0FC1 * ((this[56] - v10) >> 2) <= v1)
            goto LABEL_18;
          v11 = *(float *)(v9 + 4 * v6);
          v12 = *(float *)(v10 + 4 * v6);
          if (v11 > v12)
          {
            v13 = v11 * 0.97;
            if (v12 >= v13)
              v13 = *(float *)(v10 + 4 * v6);
            *(float *)(v9 + 4 * v6) = v13;
          }
          if (v8 <= 1)
          {
            v14 = this[58];
            if (0xFC0FC0FC0FC0FC1 * (this[59] - v14) <= v1)
              goto LABEL_18;
            *(_BYTE *)(v14 + v6) = 1;
            *(_DWORD *)(v2 + 4 * v6) = 0;
          }
        }
        ++v6;
        --v7;
      }
      while (v7);
      ++v1;
      v5 += 65;
      if (v1 == v4)
        return this;
    }
LABEL_18:
    __break(1u);
  }
  return this;
}

uint64_t webrtc::SubbandNearendDetector::SubbandNearendDetector(uint64_t a1, __int128 *a2, unint64_t a3)
{
  __int128 v5;
  __int128 v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  size_t v10;
  float v11;
  _QWORD v13[2];
  float v14;
  void *__p;
  void *v16;
  char *v17;
  uint64_t v18;

  *(_QWORD *)a1 = &off_24C0C1B58;
  v5 = *a2;
  v6 = a2[1];
  *(_OWORD *)(a1 + 40) = a2[2];
  *(_OWORD *)(a1 + 24) = v6;
  *(_OWORD *)(a1 + 8) = v5;
  *(_QWORD *)(a1 + 56) = a3;
  v7 = *(_QWORD *)(a1 + 8);
  v14 = 1.0 / (float)v7;
  v16 = 0;
  v17 = 0;
  __p = 0;
  v8 = v7 - 1;
  v13[0] = 65;
  v13[1] = v8;
  if (v8)
  {
    v9 = 65 * v8;
    if ((65 * v8) >> 62)
      abort();
    v10 = 260 * v8;
    __p = operator new(260 * v8);
    v17 = (char *)__p + 4 * v9;
    bzero(__p, v10);
    v16 = v17;
  }
  v18 = 0;
  std::vector<webrtc::aec3::MovingAverage>::vector((char **)(a1 + 64), a3, (uint64_t)v13);
  if (__p)
  {
    v16 = __p;
    operator delete(__p);
  }
  v11 = 1.0 / (float)(unint64_t)(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32) + 1);
  *(float *)(a1 + 88) = 1.0 / (float)(unint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16) + 1);
  *(float *)(a1 + 92) = v11;
  *(_BYTE *)(a1 + 96) = 0;
  return a1;
}

float *webrtc::SubbandNearendDetector::Update(float *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  float *v8;
  unint64_t i;
  BOOL v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int8 *v18;
  unint64_t v19;
  uint64_t v20;
  float *v21;
  float32x4_t *p_dst;
  float *v23;
  uint64_t v25;
  uint64_t v26;
  float32x4_t *v27;
  float32x4_t v28;
  float v29;
  float *v30;
  uint64_t v31;
  float v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  float *v41;
  float v42;
  uint64_t v43;
  float v44;
  uint64_t v45;
  float v46;
  float v47;
  float32x4_t *v48;
  uint64_t v49;
  float v50;
  uint64_t v51;
  uint64_t v52;
  float32x4_t *v53;
  uint64_t v54;
  float v55;
  float v56;
  float v57;
  float32x4_t __dst;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int v74;

  *((_BYTE *)result + 96) = 0;
  if (*((_QWORD *)result + 7))
  {
    v8 = result;
    for (i = 0; i < *((_QWORD *)v8 + 7); ++i)
    {
      v11 = *((_QWORD *)v8 + 8);
      if (0x6DB6DB6DB6DB6DB7 * ((*((_QWORD *)v8 + 9) - v11) >> 3) <= i)
      {
        __break(1u);
        return result;
      }
      v12 = (_QWORD *)(v11 + 56 * i);
      result = (float *)memmove(&__dst, (const void *)(a2 + 260 * i), 0x104uLL);
      v13 = v12[3];
      v14 = v12[4];
      if (v13 < v14)
      {
        v15 = *v12;
        if (*v12)
        {
          v16 = 0;
          v17 = 4 * v15;
          v18 = &__dst.i8[4 * v15];
          v19 = (v15 - 1) & 0x3FFFFFFFFFFFFFFFLL;
          v20 = (v19 + 1) & 0x7FFFFFFFFFFFFFF8;
          v21 = (float *)v12[3];
          do
          {
            result = &v21[(unint64_t)v17 / 4];
            p_dst = &__dst;
            if (v19 >= 7)
            {
              if ((unint64_t)&__dst >= v13 + v17 + v17 * v16 || v21 >= (float *)v18)
              {
                v25 = 0;
                v23 = &v21[v20];
                v26 = (v19 + 1) & 0x7FFFFFFFFFFFFFF8;
                do
                {
                  v27 = (float32x4_t *)((char *)&__dst + v25 * 4);
                  v28 = vaddq_f32(*(float32x4_t *)&v21[v25 + 4], *(float32x4_t *)((char *)&__dst + v25 * 4 + 16));
                  *v27 = vaddq_f32(*(float32x4_t *)&v21[v25], *(float32x4_t *)((char *)&__dst + v25 * 4));
                  v27[1] = v28;
                  v25 += 8;
                  v26 -= 8;
                }
                while (v26);
                p_dst = (float32x4_t *)((char *)&__dst + 4 * v20);
                if (v19 + 1 == v20)
                  goto LABEL_9;
              }
              else
              {
                v23 = v21;
              }
            }
            else
            {
              v23 = v21;
            }
            do
            {
              v29 = *v23++;
              p_dst->f32[0] = v29 + p_dst->f32[0];
              p_dst = (float32x4_t *)((char *)p_dst + 4);
            }
            while (v23 != result);
LABEL_9:
            ++v16;
            v21 = (float *)((char *)v21 + v17);
          }
          while ((unint64_t)result < v14);
        }
      }
      v30 = (float *)(v12 + 2);
      if ((unint64_t)&__dst >= v11 + 56 * i + 20 || v30 >= (float *)&v74)
      {
        v32 = *v30;
        v33 = vmulq_n_f32(v59, *v30);
        __dst = vmulq_n_f32(__dst, *v30);
        v59 = v33;
        v60 = vmulq_n_f32(v60, v32);
        v61 = vmulq_n_f32(v61, v32);
        v62 = vmulq_n_f32(v62, v32);
        v63 = vmulq_n_f32(v63, v32);
        v64 = vmulq_n_f32(v64, v32);
        v65 = vmulq_n_f32(v65, v32);
        v66 = vmulq_n_f32(v66, v32);
        v67 = vmulq_n_f32(v67, v32);
        v34 = vmulq_n_f32(v69, *v30);
        v68 = vmulq_n_f32(v68, *v30);
        v69 = v34;
        v35 = vmulq_n_f32(v71, *v30);
        v70 = vmulq_n_f32(v70, *v30);
        v71 = v35;
        v36 = vmulq_n_f32(v73, *v30);
        v72 = vmulq_n_f32(v72, *v30);
        v73 = v36;
        v31 = 64;
      }
      else
      {
        v31 = 0;
      }
      v37 = a6 + 260 * i;
      v38 = v31;
      do
      {
        __dst.f32[v38] = *v30 * __dst.f32[v38];
        ++v38;
      }
      while (v38 != 65);
      if (v12[1])
      {
        result = (float *)memmove((void *)(v13 + 4 * *v12 * v12[6]), (const void *)(a2 + 260 * i), 0x104uLL);
        v12[6] = (unint64_t)(v12[6] + 1) % v12[1];
      }
      v39 = *((_QWORD *)v8 + 2);
      v40 = *((_QWORD *)v8 + 3);
      v41 = (float *)(v37 + 4 * v39);
      v42 = 0.0;
      v43 = 4 * v40;
      v44 = 0.0;
      if (v41 != (float *)(v37 + 4 * v40 + 4))
      {
        v45 = v43 - 4 * v39 + 4;
        do
        {
          v46 = *v41++;
          v44 = v44 + v46;
          v45 -= 4;
        }
        while (v45);
      }
      v47 = v8[22];
      v48 = (float32x4_t *)((char *)&__dst + 4 * v39);
      if (v48 != (float32x4_t *)&__dst.i32[v40 + 1])
      {
        v49 = v43 - 4 * v39 + 4;
        v42 = 0.0;
        do
        {
          v50 = v48->f32[0];
          v48 = (float32x4_t *)((char *)v48 + 4);
          v42 = v42 + v50;
          v49 -= 4;
        }
        while (v49);
      }
      v51 = *((_QWORD *)v8 + 4);
      v52 = *((_QWORD *)v8 + 5);
      v53 = (float32x4_t *)((char *)&__dst + 4 * v51);
      if (v53 == (float32x4_t *)&__dst.i32[v52 + 1])
      {
        v55 = 0.0;
        if (!*((_BYTE *)v8 + 96))
          goto LABEL_42;
      }
      else
      {
        v54 = 4 * v52 - 4 * v51 + 4;
        v55 = 0.0;
        do
        {
          v56 = v53->f32[0];
          v53 = (float32x4_t *)((char *)v53 + 4);
          v55 = v55 + v56;
          v54 -= 4;
        }
        while (v54);
        if (!*((_BYTE *)v8 + 96))
        {
LABEL_42:
          v57 = v47 * v42;
          v10 = v57 < (float)(v8[12] * (float)(v55 * v8[23])) && v57 > (float)((float)(v44 * v47) * v8[13]);
          goto LABEL_4;
        }
      }
      v10 = 1;
LABEL_4:
      *((_BYTE *)v8 + 96) = v10;
    }
  }
  return result;
}

void webrtc::SubbandNearendDetector::~SubbandNearendDetector(webrtc::SubbandNearendDetector *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;

  *(_QWORD *)this = &off_24C0C1B58;
  v2 = *((_QWORD *)this + 8);
  if (v2)
  {
    v3 = *((_QWORD *)this + 9);
    v4 = (void *)*((_QWORD *)this + 8);
    if (v3 != v2)
    {
      do
      {
        v5 = *(void **)(v3 - 32);
        if (v5)
        {
          *(_QWORD *)(v3 - 24) = v5;
          operator delete(v5);
        }
        v3 -= 56;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 8);
    }
    *((_QWORD *)this + 9) = v2;
    operator delete(v4);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;

  *(_QWORD *)this = &off_24C0C1B58;
  v2 = *((_QWORD *)this + 8);
  if (v2)
  {
    v3 = *((_QWORD *)this + 9);
    v4 = (void *)*((_QWORD *)this + 8);
    if (v3 != v2)
    {
      do
      {
        v5 = *(void **)(v3 - 32);
        if (v5)
        {
          *(_QWORD *)(v3 - 24) = v5;
          operator delete(v5);
        }
        v3 -= 56;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 8);
    }
    *((_QWORD *)this + 9) = v2;
    operator delete(v4);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::SubbandNearendDetector::IsNearendState(webrtc::SubbandNearendDetector *this)
{
  return *((unsigned __int8 *)this + 96);
}

char **std::vector<webrtc::aec3::MovingAverage>::vector(char **a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  char *v14;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >= 0x492492492492493)
      abort();
    v5 = 56 * a2;
    v6 = (char *)operator new(56 * a2);
    v7 = v6;
    *a1 = v6;
    a1[1] = v6;
    v8 = &v6[v5];
    a1[2] = &v6[v5];
    v10 = *(_BYTE **)(a3 + 24);
    v9 = *(_BYTE **)(a3 + 32);
    v11 = *(_QWORD *)(a3 + 48);
    v12 = v9 - v10;
    if (v9 == v10)
    {
      do
      {
        *(_OWORD *)v7 = *(_OWORD *)a3;
        *((_DWORD *)v7 + 4) = *(_DWORD *)(a3 + 16);
        *((_QWORD *)v7 + 3) = 0;
        *((_QWORD *)v7 + 4) = 0;
        *((_QWORD *)v7 + 5) = 0;
        *((_QWORD *)v7 + 6) = v11;
        v7 += 56;
      }
      while (v7 != v8);
    }
    else
    {
      if (v12 < 0)
      {
        *(_OWORD *)v6 = *(_OWORD *)a3;
        *((_DWORD *)v6 + 4) = *(_DWORD *)(a3 + 16);
        *((_QWORD *)v6 + 4) = 0;
        *((_QWORD *)v6 + 5) = 0;
        *((_QWORD *)v6 + 3) = 0;
        abort();
      }
      do
      {
        *(_OWORD *)v7 = *(_OWORD *)a3;
        *((_DWORD *)v7 + 4) = *(_DWORD *)(a3 + 16);
        *((_QWORD *)v7 + 4) = 0;
        *((_QWORD *)v7 + 5) = 0;
        *((_QWORD *)v7 + 3) = 0;
        v13 = (char *)operator new(v12);
        *((_QWORD *)v7 + 3) = v13;
        *((_QWORD *)v7 + 4) = v13;
        v14 = &v13[4 * (v12 >> 2)];
        *((_QWORD *)v7 + 5) = v14;
        memcpy(v13, v10, v12);
        *((_QWORD *)v7 + 4) = v14;
        *((_QWORD *)v7 + 6) = v11;
        v7 += 56;
      }
      while (v7 != v8);
    }
    a1[1] = v8;
  }
  return a1;
}

uint64_t webrtc::Subtractor::Subtractor(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  __int128 v8;
  __int128 v9;
  char v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  int v36;
  void *v37;
  size_t *v38;
  size_t *v39;
  size_t *v40;
  _DWORD *v41;
  size_t *v42;
  BOOL v45;
  unint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  char *v58;
  char *v59;
  char *v60;
  __int128 *v61;
  unint64_t v62;
  char *v63;
  char *v64;
  char **v65;
  int64_t v66;
  uint64_t v67;
  char **v68;
  char *v69;
  char *v70;
  int v71;
  size_t v72;
  char *v73;
  char *v74;
  char **v75;
  int64_t v76;
  uint64_t v77;
  char **v78;
  char *v79;
  char *v80;
  unint64_t v81;
  __int128 *v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  void *v90;
  uint64_t v91;
  void *v92;
  void *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  void *v100;
  uint64_t v101;
  void *v102;
  void *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unsigned int v107;
  __int128 v108;
  __int128 v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  __int128 v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  void **v120;
  void *v121;
  char **v123;
  int v124;
  unint64_t v125;
  unint64_t v126;
  _QWORD *v127;
  uint64_t *v128;
  _QWORD *v129;
  uint64_t *v130;
  size_t v133[2];
  unsigned __int8 v134;

  *(_BYTE *)a1 = 0;
  *(_QWORD *)(a1 + 8) = a5;
  *(_DWORD *)(a1 + 16) = a6;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)a2;
  v9 = *(_OWORD *)(a2 + 80);
  v8 = *(_OWORD *)(a2 + 96);
  v10 = *(_BYTE *)(a2 + 112);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 136) = v10;
  *(_OWORD *)(a1 + 120) = v8;
  *(_OWORD *)(a1 + 104) = v9;
  v11 = *(_OWORD *)(a2 + 16);
  v12 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 56) = v12;
  *(_OWORD *)(a1 + 40) = v11;
  v13 = *(_OWORD *)(a2 + 168);
  v14 = *(_OWORD *)(a2 + 200);
  v15 = *(_OWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 224) = v14;
  *(_OWORD *)(a1 + 176) = v15;
  *(_OWORD *)(a1 + 192) = v13;
  v16 = *(_OWORD *)(a2 + 232);
  v17 = *(_OWORD *)(a2 + 264);
  v18 = *(_OWORD *)(a2 + 216);
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 288) = v17;
  *(_OWORD *)(a1 + 240) = v18;
  *(_OWORD *)(a1 + 256) = v16;
  v20 = *(_OWORD *)(a2 + 296);
  v19 = *(_OWORD *)(a2 + 312);
  v21 = *(_OWORD *)(a2 + 280);
  *(_QWORD *)(a1 + 350) = *(_QWORD *)(a2 + 326);
  *(_OWORD *)(a1 + 320) = v20;
  *(_OWORD *)(a1 + 336) = v19;
  *(_OWORD *)(a1 + 304) = v21;
  v22 = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 160) = v22;
  v23 = *(_OWORD *)(a2 + 336);
  v24 = *(_OWORD *)(a2 + 352);
  *(_OWORD *)(a1 + 385) = *(_OWORD *)(a2 + 361);
  *(_OWORD *)(a1 + 360) = v23;
  *(_OWORD *)(a1 + 376) = v24;
  *(_DWORD *)(a1 + 408) = *(_DWORD *)(a2 + 384);
  *(_QWORD *)(a1 + 416) = *(_QWORD *)(a2 + 392);
  v25 = *(_QWORD *)(a2 + 400);
  *(_DWORD *)(a1 + 432) = *(_DWORD *)(a2 + 408);
  *(_QWORD *)(a1 + 424) = v25;
  v26 = *(_QWORD *)(a2 + 412);
  *(_DWORD *)(a1 + 444) = *(_DWORD *)(a2 + 420);
  *(_QWORD *)(a1 + 436) = v26;
  *(_QWORD *)(a1 + 448) = *(_QWORD *)(a2 + 424);
  v27 = *(_QWORD *)(a2 + 432);
  *(_DWORD *)(a1 + 464) = *(_DWORD *)(a2 + 440);
  *(_QWORD *)(a1 + 456) = v27;
  v28 = *(_QWORD *)(a2 + 444);
  *(_DWORD *)(a1 + 476) = *(_DWORD *)(a2 + 452);
  *(_QWORD *)(a1 + 468) = v28;
  *(_QWORD *)(a1 + 480) = *(_QWORD *)(a2 + 456);
  v29 = *(_OWORD *)(a2 + 464);
  v30 = *(_OWORD *)(a2 + 480);
  v31 = *(_OWORD *)(a2 + 512);
  *(_OWORD *)(a1 + 520) = *(_OWORD *)(a2 + 496);
  *(_OWORD *)(a1 + 536) = v31;
  *(_OWORD *)(a1 + 488) = v29;
  *(_OWORD *)(a1 + 504) = v30;
  v32 = *(_OWORD *)(a2 + 528);
  v33 = *(_OWORD *)(a2 + 544);
  v34 = *(_OWORD *)(a2 + 560);
  *(_OWORD *)(a1 + 593) = *(_OWORD *)(a2 + 569);
  *(_OWORD *)(a1 + 568) = v33;
  *(_OWORD *)(a1 + 584) = v34;
  *(_OWORD *)(a1 + 552) = v32;
  *(_OWORD *)(a1 + 616) = *(_OWORD *)(a2 + 592);
  *(_QWORD *)(a1 + 632) = a4;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3CoarseFilterResetHangoverKillSwitch", 0x2EuLL, v133);
  v35 = v134;
  v36 = (char)v134;
  v37 = (void *)v133[0];
  if ((v134 & 0x80u) == 0)
  {
    v38 = v133;
  }
  else
  {
    v35 = v133[1];
    v38 = (size_t *)v133[0];
  }
  v39 = (size_t *)((char *)v38 + v35);
  if (v35 >= 7)
  {
    v40 = v38;
    do
    {
      v41 = memchr(v40, 69, v35 - 6);
      if (!v41)
        break;
      v42 = (size_t *)v41;
      if (*v41 == 1650552389 && *(_DWORD *)((char *)v41 + 3) == 1684368482)
        goto LABEL_13;
      v40 = (size_t *)((char *)v41 + 1);
      v35 = (char *)v39 - ((char *)v42 + 1);
    }
    while (v35 > 6);
  }
  v42 = v39;
LABEL_13:
  if (v36 < 0)
    operator delete(v37);
  v45 = v42 == v39 || v42 != v38;
  *(_BYTE *)(a1 + 640) = v45;
  v46 = *(_QWORD *)(a1 + 632);
  *(_QWORD *)(a1 + 648) = 0;
  *(_QWORD *)(a1 + 664) = 0;
  *(_QWORD *)(a1 + 656) = 0;
  if (v46)
  {
    if (v46 >> 61)
      goto LABEL_105;
    v47 = (char *)operator new(8 * v46);
    *(_QWORD *)(a1 + 648) = v47;
    v48 = &v47[8 * v46];
    *(_QWORD *)(a1 + 664) = v48;
    bzero(v47, 8 * v46);
    *(_QWORD *)(a1 + 656) = v48;
    v49 = (char *)operator new(8 * v46);
    *(_QWORD *)(a1 + 672) = v49;
    v50 = &v49[8 * v46];
    *(_QWORD *)(a1 + 688) = v50;
    bzero(v49, 8 * v46);
    *(_QWORD *)(a1 + 680) = v50;
    v51 = (char *)operator new(8 * v46);
    *(_QWORD *)(a1 + 696) = v51;
    v52 = &v51[8 * v46];
    *(_QWORD *)(a1 + 712) = v52;
    bzero(v51, 8 * v46);
    *(_QWORD *)(a1 + 704) = v52;
    v53 = (char *)operator new(8 * v46);
    *(_QWORD *)(a1 + 720) = v53;
    v54 = &v53[8 * v46];
    *(_QWORD *)(a1 + 736) = v54;
    bzero(v53, 8 * v46);
    *(_QWORD *)(a1 + 728) = v54;
    *(_QWORD *)(a1 + 744) = 0;
    *(_QWORD *)(a1 + 760) = 0;
    *(_QWORD *)(a1 + 752) = 0;
    if (v46 > 0xAAAAAAAAAAAAAAALL)
      goto LABEL_105;
    v129 = (_QWORD *)(a1 + 704);
    v130 = (uint64_t *)(a1 + 696);
    v127 = (_QWORD *)(a1 + 728);
    v128 = (uint64_t *)(a1 + 720);
    v55 = (char *)operator new(24 * v46);
    *(_QWORD *)(a1 + 744) = v55;
    v56 = &v55[24 * v46];
    *(_QWORD *)(a1 + 760) = v56;
    do
    {
      *(_DWORD *)v55 = 4;
      *(_QWORD *)(v55 + 12) = 0;
      *(_QWORD *)(v55 + 4) = 0;
      *((_DWORD *)v55 + 5) = 0;
      v55 += 24;
    }
    while (v55 != v56);
    *(_QWORD *)(a1 + 752) = v56;
    v57 = (char *)operator new(8 * v46);
    *(_QWORD *)(a1 + 768) = v57;
    v58 = &v57[8 * v46];
    *(_QWORD *)(a1 + 784) = v58;
    bzero(v57, 8 * v46);
    *(_QWORD *)(a1 + 776) = v58;
    v59 = (char *)operator new(4 * v46);
    *(_QWORD *)(a1 + 792) = v59;
    v60 = &v59[4 * v46];
    *(_QWORD *)(a1 + 808) = v60;
    bzero(v59, 4 * v46);
    *(_QWORD *)(a1 + 800) = v60;
  }
  else
  {
    *(_OWORD *)(a1 + 784) = 0u;
    *(_OWORD *)(a1 + 800) = 0u;
    v129 = (_QWORD *)(a1 + 704);
    v130 = (uint64_t *)(a1 + 696);
    v127 = (_QWORD *)(a1 + 728);
    v128 = (uint64_t *)(a1 + 720);
    *(_OWORD *)(a1 + 752) = 0u;
    *(_OWORD *)(a1 + 768) = 0u;
    *(_OWORD *)(a1 + 720) = 0u;
    *(_OWORD *)(a1 + 736) = 0u;
    *(_OWORD *)(a1 + 688) = 0u;
    *(_OWORD *)(a1 + 704) = 0u;
    *(_OWORD *)(a1 + 672) = 0u;
  }
  v61 = (__int128 *)(a1 + 192);
  if (*(_QWORD *)(a1 + 192) <= *(_QWORD *)(a1 + 144))
    v62 = *(_QWORD *)(a1 + 144);
  else
    v62 = *(_QWORD *)(a1 + 192);
  if (v62)
  {
    if (v62 > 0xFC0FC0FC0FC0FCLL)
      goto LABEL_105;
    v63 = (char *)operator new(260 * v62);
    bzero(v63, 260 * ((260 * v62 - 260) / 0x104) + 260);
    v64 = &v63[260 * v62];
    *(_QWORD *)(a1 + 816) = 0;
    *(_QWORD *)(a1 + 824) = 0;
    *(_QWORD *)(a1 + 832) = 0;
    if (!v46)
      goto LABEL_43;
  }
  else
  {
    v64 = 0;
    v63 = 0;
    *(_QWORD *)(a1 + 816) = 0;
    *(_QWORD *)(a1 + 824) = 0;
    *(_QWORD *)(a1 + 832) = 0;
    if (!v46)
      goto LABEL_43;
  }
  v65 = (char **)operator new(24 * v46);
  *(_QWORD *)(a1 + 816) = v65;
  *(_QWORD *)(a1 + 824) = v65;
  v123 = &v65[3 * v46];
  v124 = v62;
  *(_QWORD *)(a1 + 832) = v123;
  v66 = v64 - v63;
  v125 = v46;
  if (v66)
  {
    if ((unint64_t)(0xFC0FC0FC0FC0FC1 * (v66 >> 2)) > 0xFC0FC0FC0FC0FCLL)
      goto LABEL_106;
    v67 = 24 * v46;
    v68 = v65 + 1;
    do
    {
      *v68 = 0;
      v68[1] = 0;
      v69 = (char *)operator new(v66);
      *(v68 - 1) = v69;
      v70 = &v69[4 * (v66 >> 2)];
      v68[1] = v70;
      memcpy(v69, v63, v66);
      *v68 = v70;
      v68 += 3;
      v67 -= 24;
    }
    while (v67);
  }
  else
  {
    bzero(v65, 24 * ((24 * v46 - 24) / 0x18) + 24);
  }
  LODWORD(v62) = v124;
  *(_QWORD *)(a1 + 824) = v123;
  v46 = v125;
LABEL_43:
  if (v63)
  {
    operator delete(v63);
    v46 = *(_QWORD *)(a1 + 632);
    if (*(_QWORD *)(a1 + 192) <= *(_QWORD *)(a1 + 144))
      v62 = *(_QWORD *)(a1 + 144);
    else
      v62 = *(_QWORD *)(a1 + 192);
  }
  v71 = (_DWORD)v62 << 6;
  if (!((_DWORD)v62 << 6))
  {
    v74 = 0;
    v73 = 0;
    *(_QWORD *)(a1 + 840) = 0;
    *(_QWORD *)(a1 + 848) = 0;
    *(_QWORD *)(a1 + 856) = 0;
    if (!v46)
      goto LABEL_60;
    goto LABEL_52;
  }
  if (v71 < 0)
    goto LABEL_105;
  v72 = 4 * v71;
  v73 = (char *)operator new(v72);
  bzero(v73, v72);
  v74 = &v73[v72];
  *(_QWORD *)(a1 + 840) = 0;
  *(_QWORD *)(a1 + 848) = 0;
  *(_QWORD *)(a1 + 856) = 0;
  if (v46)
  {
LABEL_52:
    if (v46 > 0xAAAAAAAAAAAAAAALL)
      goto LABEL_105;
    v65 = (char **)operator new(24 * v46);
    *(_QWORD *)(a1 + 840) = v65;
    *(_QWORD *)(a1 + 848) = v65;
    v75 = &v65[3 * v46];
    *(_QWORD *)(a1 + 856) = v75;
    v76 = v74 - v73;
    v126 = v46;
    if (!v76)
    {
      bzero(v65, 24 * ((24 * v46 - 24) / 0x18) + 24);
LABEL_59:
      *(_QWORD *)(a1 + 848) = v75;
      v46 = v126;
      goto LABEL_60;
    }
    if ((v76 & 0x8000000000000000) == 0)
    {
      v77 = 24 * v46;
      v78 = v65 + 1;
      do
      {
        *v78 = 0;
        v78[1] = 0;
        v79 = (char *)operator new(v76);
        *(v78 - 1) = v79;
        v80 = &v79[4 * (v76 >> 2)];
        v78[1] = v80;
        memcpy(v79, v73, v76);
        *v78 = v80;
        v78 += 3;
        v77 -= 24;
      }
      while (v77);
      goto LABEL_59;
    }
LABEL_106:
    *v65 = 0;
    v65[1] = 0;
    v65[2] = 0;
    abort();
  }
LABEL_60:
  if (v73)
  {
    operator delete(v73);
    v46 = *(_QWORD *)(a1 + 632);
  }
  *(_QWORD *)(a1 + 880) = 0;
  *(_OWORD *)(a1 + 864) = 0u;
  if (v46)
  {
    v81 = 0;
    v82 = (__int128 *)(a1 + 224);
    do
    {
      v84 = operator new();
      v85 = webrtc::AdaptiveFirFilter::AdaptiveFirFilter(v84, *(_QWORD *)(a1 + 144), *(_QWORD *)(a1 + 192), *(_QWORD *)(a2 + 216), a3, a6, *(_QWORD *)(a1 + 8));
      v86 = *(_QWORD *)(a1 + 648);
      if (v81 >= (*(_QWORD *)(a1 + 656) - v86) >> 3)
        goto LABEL_104;
      v87 = *(_QWORD *)(v86 + 8 * v81);
      *(_QWORD *)(v86 + 8 * v81) = v85;
      if (v87)
      {
        v88 = *(_QWORD *)(v87 + 72);
        if (v88)
        {
          v89 = *(_QWORD *)(v87 + 80);
          v90 = *(void **)(v87 + 72);
          if (v89 != v88)
          {
            v91 = *(_QWORD *)(v87 + 80);
            do
            {
              v93 = *(void **)(v91 - 24);
              v91 -= 24;
              v92 = v93;
              if (v93)
              {
                *(_QWORD *)(v89 - 16) = v92;
                operator delete(v92);
              }
              v89 = v91;
            }
            while (v91 != v88);
            v90 = *(void **)(v87 + 72);
          }
          *(_QWORD *)(v87 + 80) = v88;
          operator delete(v90);
        }
        MEMORY[0x20BD0ADEC](v87, 0x1060C403DE63BB8);
      }
      v94 = operator new();
      v95 = webrtc::AdaptiveFirFilter::AdaptiveFirFilter(v94, *(_QWORD *)(a1 + 176), *(_QWORD *)(a1 + 224), *(_QWORD *)(a2 + 216), a3, a6, *(_QWORD *)(a1 + 8));
      v96 = *(_QWORD *)(a1 + 672);
      if (v81 >= (*(_QWORD *)(a1 + 680) - v96) >> 3)
        goto LABEL_104;
      v97 = *(_QWORD *)(v96 + 8 * v81);
      *(_QWORD *)(v96 + 8 * v81) = v95;
      if (v97)
      {
        v98 = *(_QWORD *)(v97 + 72);
        if (v98)
        {
          v99 = *(_QWORD *)(v97 + 80);
          v100 = *(void **)(v97 + 72);
          if (v99 != v98)
          {
            v101 = *(_QWORD *)(v97 + 80);
            do
            {
              v103 = *(void **)(v101 - 24);
              v101 -= 24;
              v102 = v103;
              if (v103)
              {
                *(_QWORD *)(v99 - 16) = v102;
                operator delete(v102);
              }
              v99 = v101;
            }
            while (v101 != v98);
            v100 = *(void **)(v97 + 72);
          }
          *(_QWORD *)(v97 + 80) = v98;
          operator delete(v100);
        }
        MEMORY[0x20BD0ADEC](v97, 0x1060C403DE63BB8);
      }
      v104 = operator new();
      v105 = *(_QWORD *)(a1 + 240);
      v106 = operator new();
      do
        v107 = __ldaxr(&webrtc::RefinedFilterUpdateGain::instance_count_);
      while (__stlxr(v107 + 1, &webrtc::RefinedFilterUpdateGain::instance_count_));
      *(_QWORD *)v104 = v106;
      *(_DWORD *)(v104 + 8) = v105;
      *(_QWORD *)(v104 + 376) = 1000;
      *(_QWORD *)(v104 + 384) = 0;
      v108 = *v61;
      v109 = *(_OWORD *)(a1 + 208);
      *(_OWORD *)(v104 + 48) = *v61;
      *(_OWORD *)(v104 + 64) = v109;
      *(_OWORD *)(v104 + 16) = v108;
      *(_OWORD *)(v104 + 32) = v109;
      *(_OWORD *)(v104 + 80) = v108;
      *(_OWORD *)(v104 + 96) = v109;
      *(_DWORD *)(v104 + 392) = 0;
      *(float *)(v104 + 12) = 1.0 / (float)*(int *)(v104 + 8);
      v110 = *v130;
      if (v81 >= (*v129 - *v130) >> 3)
        goto LABEL_104;
      v111 = *(uint64_t **)(v110 + 8 * v81);
      *(_QWORD *)(v110 + 8 * v81) = v104;
      if (v111)
      {
        v112 = *v111;
        *v111 = 0;
        if (v112)
          MEMORY[0x20BD0ADEC](v112, 0xC400A2AC0F1);
        MEMORY[0x20BD0ADEC](v111, 0x1020C40743614A2);
      }
      v113 = operator new();
      v114 = *(_DWORD *)(a2 + 216);
      *(_DWORD *)(v113 + 48) = v114;
      *(_QWORD *)(v113 + 56) = 0;
      *(_QWORD *)(v113 + 64) = 0;
      v115 = *v82;
      *(_OWORD *)v113 = *v82;
      *(_OWORD *)(v113 + 16) = v115;
      *(_OWORD *)(v113 + 32) = v115;
      *(_DWORD *)(v113 + 72) = 0;
      *(float *)(v113 + 52) = 1.0 / (float)v114;
      v116 = *v128;
      if (v81 >= (*v127 - *v128) >> 3)
        goto LABEL_104;
      v117 = *(_QWORD *)(v116 + 8 * v81);
      *(_QWORD *)(v116 + 8 * v81) = v113;
      if (v117)
        MEMORY[0x20BD0ADEC](v117, 0x1000C40D9C97D19);
      ++v81;
      v83 = *(_QWORD *)(a1 + 632);
    }
    while (v81 < v83);
    if (v83)
    {
      v118 = *(_QWORD *)(a1 + 816);
      v119 = 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 824) - v118) >> 3);
      v120 = (void **)(v118 + 8);
      while (v119)
      {
        v121 = *(v120 - 1);
        if (v121 != *v120)
          bzero(v121, 260 * (((_BYTE *)*v120 - (_BYTE *)v121 - 260) / 0x104uLL) + 260);
        v120 += 3;
        --v119;
        if (!--v83)
          return a1;
      }
LABEL_104:
      __break(1u);
LABEL_105:
      abort();
    }
  }
  return a1;
}

void webrtc::Subtractor::~Subtractor(webrtc::Subtractor *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  void *v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  void *v55;

  v2 = *((_QWORD *)this + 108);
  if (v2)
  {
    v3 = *((_QWORD *)this + 109);
    v4 = (void *)*((_QWORD *)this + 108);
    if (v3 != v2)
    {
      v5 = *((_QWORD *)this + 109);
      do
      {
        v7 = *(void **)(v5 - 24);
        v5 -= 24;
        v6 = v7;
        if (v7)
        {
          *(_QWORD *)(v3 - 16) = v6;
          operator delete(v6);
        }
        v3 = v5;
      }
      while (v5 != v2);
      v4 = (void *)*((_QWORD *)this + 108);
    }
    *((_QWORD *)this + 109) = v2;
    operator delete(v4);
  }
  v8 = *((_QWORD *)this + 105);
  if (v8)
  {
    v9 = *((_QWORD *)this + 106);
    v10 = (void *)*((_QWORD *)this + 105);
    if (v9 != v8)
    {
      v11 = *((_QWORD *)this + 106);
      do
      {
        v13 = *(void **)(v11 - 24);
        v11 -= 24;
        v12 = v13;
        if (v13)
        {
          *(_QWORD *)(v9 - 16) = v12;
          operator delete(v12);
        }
        v9 = v11;
      }
      while (v11 != v8);
      v10 = (void *)*((_QWORD *)this + 105);
    }
    *((_QWORD *)this + 106) = v8;
    operator delete(v10);
  }
  v14 = *((_QWORD *)this + 102);
  if (v14)
  {
    v15 = *((_QWORD *)this + 103);
    v16 = (void *)*((_QWORD *)this + 102);
    if (v15 != v14)
    {
      v17 = *((_QWORD *)this + 103);
      do
      {
        v19 = *(void **)(v17 - 24);
        v17 -= 24;
        v18 = v19;
        if (v19)
        {
          *(_QWORD *)(v15 - 16) = v18;
          operator delete(v18);
        }
        v15 = v17;
      }
      while (v17 != v14);
      v16 = (void *)*((_QWORD *)this + 102);
    }
    *((_QWORD *)this + 103) = v14;
    operator delete(v16);
  }
  v20 = (void *)*((_QWORD *)this + 99);
  if (v20)
  {
    *((_QWORD *)this + 100) = v20;
    operator delete(v20);
  }
  v21 = (void *)*((_QWORD *)this + 96);
  if (v21)
  {
    *((_QWORD *)this + 97) = v21;
    operator delete(v21);
  }
  v22 = (void *)*((_QWORD *)this + 93);
  if (v22)
  {
    *((_QWORD *)this + 94) = v22;
    operator delete(v22);
  }
  v23 = (_QWORD *)*((_QWORD *)this + 90);
  if (v23)
  {
    v24 = (_QWORD *)*((_QWORD *)this + 91);
    v25 = (void *)*((_QWORD *)this + 90);
    if (v24 != v23)
    {
      do
      {
        v27 = *--v24;
        v26 = v27;
        *v24 = 0;
        if (v27)
          MEMORY[0x20BD0ADEC](v26, 0x1000C40D9C97D19);
      }
      while (v24 != v23);
      v25 = (void *)*((_QWORD *)this + 90);
    }
    *((_QWORD *)this + 91) = v23;
    operator delete(v25);
  }
  v28 = (_QWORD *)*((_QWORD *)this + 87);
  if (v28)
  {
    v29 = (_QWORD *)*((_QWORD *)this + 88);
    v30 = (void *)*((_QWORD *)this + 87);
    if (v29 != v28)
    {
      do
      {
        v32 = (uint64_t *)*--v29;
        v31 = v32;
        *v29 = 0;
        if (v32)
        {
          v33 = *v31;
          *v31 = 0;
          if (v33)
            MEMORY[0x20BD0ADEC](v33, 0xC400A2AC0F1);
          MEMORY[0x20BD0ADEC](v31, 0x1020C40743614A2);
        }
      }
      while (v29 != v28);
      v30 = (void *)*((_QWORD *)this + 87);
    }
    *((_QWORD *)this + 88) = v28;
    operator delete(v30);
  }
  v34 = (_QWORD *)*((_QWORD *)this + 84);
  if (v34)
  {
    v35 = (_QWORD *)*((_QWORD *)this + 85);
    v36 = (void *)*((_QWORD *)this + 84);
    if (v35 != v34)
    {
      do
      {
        v39 = *--v35;
        v38 = v39;
        *v35 = 0;
        if (v39)
        {
          v40 = *(_QWORD *)(v38 + 72);
          if (v40)
          {
            v41 = *(_QWORD *)(v38 + 80);
            v37 = *(void **)(v38 + 72);
            if (v41 != v40)
            {
              v42 = *(_QWORD *)(v38 + 80);
              do
              {
                v44 = *(void **)(v42 - 24);
                v42 -= 24;
                v43 = v44;
                if (v44)
                {
                  *(_QWORD *)(v41 - 16) = v43;
                  operator delete(v43);
                }
                v41 = v42;
              }
              while (v42 != v40);
              v37 = *(void **)(v38 + 72);
            }
            *(_QWORD *)(v38 + 80) = v40;
            operator delete(v37);
          }
          MEMORY[0x20BD0ADEC](v38, 0x1060C403DE63BB8);
        }
      }
      while (v35 != v34);
      v36 = (void *)*((_QWORD *)this + 84);
    }
    *((_QWORD *)this + 85) = v34;
    operator delete(v36);
  }
  v45 = (_QWORD *)*((_QWORD *)this + 81);
  if (v45)
  {
    v46 = (_QWORD *)*((_QWORD *)this + 82);
    v47 = (void *)*((_QWORD *)this + 81);
    if (v46 != v45)
    {
      do
      {
        v50 = *--v46;
        v49 = v50;
        *v46 = 0;
        if (v50)
        {
          v51 = *(_QWORD *)(v49 + 72);
          if (v51)
          {
            v52 = *(_QWORD *)(v49 + 80);
            v48 = *(void **)(v49 + 72);
            if (v52 != v51)
            {
              v53 = *(_QWORD *)(v49 + 80);
              do
              {
                v55 = *(void **)(v53 - 24);
                v53 -= 24;
                v54 = v55;
                if (v55)
                {
                  *(_QWORD *)(v52 - 16) = v54;
                  operator delete(v54);
                }
                v52 = v53;
              }
              while (v53 != v51);
              v48 = *(void **)(v49 + 72);
            }
            *(_QWORD *)(v49 + 80) = v51;
            operator delete(v48);
          }
          MEMORY[0x20BD0ADEC](v49, 0x1060C403DE63BB8);
        }
      }
      while (v46 != v45);
      v47 = (void *)*((_QWORD *)this + 81);
    }
    *((_QWORD *)this + 82) = v45;
    operator delete(v47);
  }
}

void webrtc::Subtractor::HandleEchoPathChange(_QWORD *a1, unsigned __int8 *a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  char *v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  char *v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  char *v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  char *v62;
  unint64_t v63;
  unint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  _OWORD *v68;
  _OWORD *v69;
  unint64_t v70;

  if (*((_DWORD *)a2 + 1) && a1[79])
  {
    v4 = 0;
    v68 = a1 + 28;
    v69 = a1 + 24;
    do
    {
      v5 = a1[81];
      if (v4 >= (a1[82] - v5) >> 3)
        goto LABEL_83;
      v70 = v4;
      v6 = *(_QWORD **)(v5 + 8 * v4);
      v7 = v6[5];
      v8 = v6[3];
      if (v7 < v8)
      {
        v9 = (char *)v6[9];
        v10 = (char *)v6[10];
        do
        {
          v11 = v10 - v9;
          if (v10 == v9)
            goto LABEL_83;
          if (*((_QWORD *)v9 + 1) != *(_QWORD *)v9)
          {
            v12 = 0;
            v13 = 0;
            while (0xAAAAAAAAAAAAAAABLL * (v11 >> 3) > v7)
            {
              v15 = &v9[24 * v7];
              v14 = *(_QWORD *)v15;
              if (0xFC0FC0FC0FC0FC1 * ((uint64_t)(*((_QWORD *)v15 + 1) - *(_QWORD *)v15) >> 3) <= v13)
                break;
              bzero((void *)(v14 + v12), 0x208uLL);
              v9 = (char *)v6[9];
              v10 = (char *)v6[10];
              v11 = v10 - v9;
              if (v10 == v9)
                break;
              ++v13;
              v12 += 520;
              if (v13 >= 0xFC0FC0FC0FC0FC1 * ((uint64_t)(*((_QWORD *)v9 + 1) - *(_QWORD *)v9) >> 3))
                goto LABEL_7;
            }
            goto LABEL_83;
          }
LABEL_7:
          ;
        }
        while (++v7 != v8);
      }
      v16 = a1[84];
      if (v70 >= (a1[85] - v16) >> 3)
        goto LABEL_83;
      v17 = *(_QWORD **)(v16 + 8 * v70);
      v18 = v17[5];
      v19 = v17[3];
      if (v18 < v19)
      {
        v20 = (char *)v17[9];
        v21 = (char *)v17[10];
        do
        {
          v22 = v21 - v20;
          if (v21 == v20)
            goto LABEL_83;
          if (*((_QWORD *)v20 + 1) != *(_QWORD *)v20)
          {
            v23 = 0;
            v24 = 0;
            while (0xAAAAAAAAAAAAAAABLL * (v22 >> 3) > v18)
            {
              v26 = &v20[24 * v18];
              v25 = *(_QWORD *)v26;
              if (0xFC0FC0FC0FC0FC1 * ((uint64_t)(*((_QWORD *)v26 + 1) - *(_QWORD *)v26) >> 3) <= v24)
                break;
              bzero((void *)(v25 + v23), 0x208uLL);
              v20 = (char *)v17[9];
              v21 = (char *)v17[10];
              v22 = v21 - v20;
              if (v21 == v20)
                break;
              ++v24;
              v23 += 520;
              if (v24 >= 0xFC0FC0FC0FC0FC1 * ((uint64_t)(*((_QWORD *)v20 + 1) - *(_QWORD *)v20) >> 3))
                goto LABEL_19;
            }
            goto LABEL_83;
          }
LABEL_19:
          ;
        }
        while (++v18 != v19);
      }
      v27 = a1[87];
      v28 = v70;
      if (v70 >= (a1[88] - v27) >> 3)
        goto LABEL_83;
      v29 = *(_QWORD *)(v27 + 8 * v70);
      if (*((_DWORD *)a2 + 1))
      {
        v28 = v70;
      }
      if (!*a2)
      {
        *(_QWORD *)(v29 + 376) = 1000;
        *(_QWORD *)(v29 + 384) = 0;
      }
      v30 = a1[90];
      if (v28 >= (a1[91] - v30) >> 3)
        goto LABEL_83;
      v31 = *(_QWORD *)(v30 + 8 * v28);
      *(_QWORD *)(v31 + 56) = 0;
      *(_QWORD *)(v31 + 64) = 0;
      v32 = a1[87];
      if (v28 >= (a1[88] - v32) >> 3)
        goto LABEL_83;
      v33 = *(_QWORD *)(v32 + 8 * v28);
      v34 = v69[1];
      *(_OWORD *)(v33 + 48) = *v69;
      *(_OWORD *)(v33 + 64) = v34;
      v35 = *v69;
      v36 = v69[1];
      *(_OWORD *)(v33 + 16) = *v69;
      *(_OWORD *)(v33 + 32) = v36;
      *(_OWORD *)(v33 + 80) = v35;
      *(_OWORD *)(v33 + 96) = v36;
      *(_DWORD *)(v33 + 392) = 0;
      v37 = a1[90];
      if (v28 >= (a1[91] - v37) >> 3)
        goto LABEL_83;
      v38 = *(_QWORD *)(v37 + 8 * v28);
      *(_OWORD *)(v38 + 16) = *v68;
      v39 = *v68;
      *(_OWORD *)v38 = *v68;
      *(_OWORD *)(v38 + 32) = v39;
      *(_DWORD *)(v38 + 72) = 0;
      v40 = a1[81];
      if (v28 >= (a1[82] - v40) >> 3)
        goto LABEL_83;
      v41 = *(_QWORD *)(v40 + 8 * v28);
      if (*(_QWORD *)(v41 + 24) >= *(_QWORD *)v69)
        v42 = *(_QWORD *)v69;
      else
        v42 = *(_QWORD *)(v41 + 24);
      v43 = *(_QWORD *)(v41 + 40);
      *(_QWORD *)(v41 + 48) = v42;
      *(_QWORD *)(v41 + 56) = v42;
      *(_QWORD *)(v41 + 40) = v42;
      if (v43 < v42)
      {
        v44 = *(char **)(v41 + 72);
        v45 = *(char **)(v41 + 80);
        while (1)
        {
          v46 = v45 - v44;
          if (v45 == v44)
            goto LABEL_83;
          if (*((_QWORD *)v44 + 1) != *(_QWORD *)v44)
          {
            v47 = 0;
            v48 = 0;
            while (0xAAAAAAAAAAAAAAABLL * (v46 >> 3) > v43)
            {
              v50 = &v44[24 * v43];
              v49 = *(_QWORD *)v50;
              if (0xFC0FC0FC0FC0FC1 * ((uint64_t)(*((_QWORD *)v50 + 1) - *(_QWORD *)v50) >> 3) <= v48)
                break;
              bzero((void *)(v49 + v47), 0x208uLL);
              v44 = *(char **)(v41 + 72);
              v45 = *(char **)(v41 + 80);
              v46 = v45 - v44;
              if (v45 == v44)
                break;
              ++v48;
              v47 += 520;
              if (v48 >= 0xFC0FC0FC0FC0FC1 * ((uint64_t)(*((_QWORD *)v44 + 1) - *(_QWORD *)v44) >> 3))
                goto LABEL_42;
            }
            goto LABEL_83;
          }
LABEL_42:
          if (++v43 == v42)
          {
            v42 = *(_QWORD *)(v41 + 40);
            v28 = v70;
            break;
          }
        }
      }
      v51 = v42 - 1;
      if (v42 - 1 >= *(_QWORD *)(v41 + 96))
        v51 = *(_QWORD *)(v41 + 96);
      *(_QWORD *)(v41 + 96) = v51;
      *(_DWORD *)(v41 + 64) = 0;
      v52 = a1[84];
      if (v28 >= (a1[85] - v52) >> 3)
        goto LABEL_83;
      v53 = *(_QWORD *)(v52 + 8 * v28);
      if (*(_QWORD *)(v53 + 24) >= *(_QWORD *)v68)
        v54 = *(_QWORD *)v68;
      else
        v54 = *(_QWORD *)(v53 + 24);
      v55 = *(_QWORD *)(v53 + 40);
      *(_QWORD *)(v53 + 48) = v54;
      *(_QWORD *)(v53 + 56) = v54;
      *(_QWORD *)(v53 + 40) = v54;
      if (v55 < v54)
      {
        v56 = *(char **)(v53 + 72);
        v57 = *(char **)(v53 + 80);
        while (1)
        {
          v58 = v57 - v56;
          if (v57 == v56)
            goto LABEL_83;
          if (*((_QWORD *)v56 + 1) != *(_QWORD *)v56)
          {
            v59 = 0;
            v60 = 0;
            while (0xAAAAAAAAAAAAAAABLL * (v58 >> 3) > v55)
            {
              v62 = &v56[24 * v55];
              v61 = *(_QWORD *)v62;
              if (0xFC0FC0FC0FC0FC1 * ((uint64_t)(*((_QWORD *)v62 + 1) - *(_QWORD *)v62) >> 3) <= v60)
                break;
              bzero((void *)(v61 + v59), 0x208uLL);
              v56 = *(char **)(v53 + 72);
              v57 = *(char **)(v53 + 80);
              v58 = v57 - v56;
              if (v57 == v56)
                break;
              ++v60;
              v59 += 520;
              if (v60 >= 0xFC0FC0FC0FC0FC1 * ((uint64_t)(*((_QWORD *)v56 + 1) - *(_QWORD *)v56) >> 3))
                goto LABEL_60;
            }
            goto LABEL_83;
          }
LABEL_60:
          if (++v55 == v54)
          {
            v54 = *(_QWORD *)(v53 + 40);
            v28 = v70;
            break;
          }
        }
      }
      v63 = v54 - 1;
      if (v54 - 1 >= *(_QWORD *)(v53 + 96))
        v63 = *(_QWORD *)(v53 + 96);
      *(_QWORD *)(v53 + 96) = v63;
      *(_DWORD *)(v53 + 64) = 0;
      v4 = v28 + 1;
    }
    while (v4 < a1[79]);
  }
  if (*a2 && a1[79])
  {
    v64 = 0;
    v65 = 1;
    while (1)
    {
      v66 = a1[87];
      if (v64 >= (a1[88] - v66) >> 3)
        break;
      v67 = *(_QWORD *)(v66 + 8 * v64);
      if (*((_DWORD *)a2 + 1))
      {
        v65 = *a2;
      }
      if (!v65)
      {
        *(_QWORD *)(v67 + 376) = 1000;
        *(_QWORD *)(v67 + 384) = 0;
      }
      if (++v64 >= a1[79])
        return;
    }
LABEL_83:
    __break(1u);
  }
}

uint64_t webrtc::Subtractor::ExitInitialState(uint64_t this)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  if (*(_QWORD *)(this + 632))
  {
    v1 = 0;
    while (1)
    {
      v2 = *(_QWORD *)(this + 696);
      if (v1 >= (*(_QWORD *)(this + 704) - v2) >> 3)
        break;
      v3 = *(_QWORD *)(v2 + 8 * v1);
      v4 = *(_OWORD *)(v3 + 32);
      *(_OWORD *)(v3 + 80) = *(_OWORD *)(v3 + 16);
      *(_OWORD *)(v3 + 96) = v4;
      v5 = *(_OWORD *)(this + 160);
      *(_OWORD *)(v3 + 48) = *(_OWORD *)(this + 144);
      *(_OWORD *)(v3 + 64) = v5;
      *(_DWORD *)(v3 + 392) = *(_DWORD *)(v3 + 8);
      v6 = *(_QWORD *)(this + 720);
      if (v1 >= (*(_QWORD *)(this + 728) - v6) >> 3)
        break;
      v7 = *(_QWORD *)(v6 + 8 * v1);
      *(_OWORD *)(v7 + 32) = *(_OWORD *)v7;
      *(_OWORD *)(v7 + 16) = *(_OWORD *)(this + 176);
      *(_DWORD *)(v7 + 72) = *(_DWORD *)(v7 + 48);
      v8 = *(_QWORD *)(this + 648);
      if (v1 >= (*(_QWORD *)(this + 656) - v8) >> 3)
        break;
      v9 = *(_QWORD *)(v8 + 8 * v1);
      v10 = *(_QWORD *)(this + 144);
      if (*(_QWORD *)(v9 + 24) < v10)
        v10 = *(_QWORD *)(v9 + 24);
      *(_QWORD *)(v9 + 48) = v10;
      *(_DWORD *)(v9 + 64) = *(_DWORD *)(v9 + 32);
      v11 = *(_QWORD *)(this + 672);
      if (v1 >= (*(_QWORD *)(this + 680) - v11) >> 3)
        break;
      v12 = *(_QWORD *)(v11 + 8 * v1);
      v13 = *(_QWORD *)(this + 176);
      if (*(_QWORD *)(v12 + 24) < v13)
        v13 = *(_QWORD *)(v12 + 24);
      *(_QWORD *)(v12 + 48) = v13;
      *(_DWORD *)(v12 + 64) = *(_DWORD *)(v12 + 32);
      if (++v1 >= *(_QWORD *)(this + 632))
        return this;
    }
    __break(1u);
  }
  return this;
}

void webrtc::Subtractor::Process(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v8;
  unint64_t v10;
  unint64_t v11;
  float32x4_t *p_src;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  float32x4_t **v18;
  float32x4_t *v19;
  float32x4_t *v20;
  uint64_t v21;
  float32x4_t *v22;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  uint64_t v32;
  uint64_t v33;
  float32x4_t *v34;
  float32x4_t *v35;
  float32x4_t *v36;
  unint64_t v37;
  int v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  float32x4_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;
  int8x16_t v53;
  int8x16_t v54;
  int8x16_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  float32x4_t *v61;
  uint64_t v62;
  float *v63;
  float *v64;
  float *v65;
  float *v66;
  float *v67;
  float *v68;
  float *v69;
  float *v70;
  float *v71;
  float *v72;
  float *v73;
  float *v74;
  __int128 v75;
  float *v76;
  float *v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  uint64_t i;
  float32x4_t *v88;
  uint64_t m;
  uint64_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float *v100;
  float *v101;
  float *v102;
  float *v103;
  float *v104;
  float *v105;
  float *v106;
  float *v107;
  float *v108;
  float *v109;
  float *v110;
  float *v111;
  float *v112;
  __int128 v113;
  float *v114;
  float *v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  uint64_t j;
  uint64_t v126;
  float *v127;
  float32x4_t *v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  double v138;
  uint64_t v139;
  int *v140;
  uint64_t v141;
  _QWORD *v142;
  float v143;
  float v144;
  float v145;
  _DWORD *v146;
  int v147;
  int v148;
  float v149;
  float v150;
  int *v151;
  uint64_t v152;
  float *v153;
  float v154;
  float v155;
  int v156;
  int v157;
  uint64_t v158;
  float v159;
  float v161;
  uint64_t v162;
  uint64_t v163;
  float32x4_t **v164;
  float *v165;
  float32x4_t *v166;
  unint64_t v167;
  float *v168;
  uint64_t v169;
  float32x4_t *v170;
  uint64_t v171;
  float32x4_t v172;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  uint64_t k;
  float v199;
  uint64_t v200;
  uint64_t v201;
  float32x4_t *v202;
  uint64_t v203;
  float32x4_t *v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;
  float32x4_t v209;
  float32x4_t v210;
  float32x4_t v211;
  float32x4_t v212;
  uint64_t v213;
  float v214;
  uint64_t v215;
  float32x4_t v216;
  float32x4_t v217;
  float32x4_t v218;
  float32x4_t v219;
  float32x4_t v220;
  float32x4_t v221;
  float32x4_t v222;
  float32x4_t v223;
  float32x4_t v224;
  uint64_t v225;
  uint64_t v226;
  char v227;
  uint64_t v228;
  float32x4_t v229;
  float32x4_t **v230;
  float32x4_t *v231;
  float32x4_t *v232;
  uint64_t v233;
  float32x4_t *v234;
  float32x4_t *v235;
  float32x4_t v237;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32x4_t v242;
  float32x4_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t *v249;
  uint64_t *v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  unint64_t v255;
  unint64_t v256;
  uint64_t v257;
  unint64_t v258;
  unint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  int v269;
  uint64_t *v270;
  uint64_t *v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  unint64_t v275;
  _QWORD *v276;
  uint64_t *v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  unint64_t v281;
  _QWORD *v282;
  float v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  int v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  float32x4_t *v296;
  float32x4_t *v297;
  uint64_t v298;
  __int32 v300;
  float32x4_t v301;
  float32x4_t v302;
  float32x4_t v303;
  float32x4_t v304;
  float32x4_t v305;
  float32x4_t v306;
  float32x4_t v307;
  float32x4_t v308;
  float32x4_t v309;
  float32x4_t v310;
  float32x4_t v311;
  float32x4_t v312;
  float32x4_t v313;
  float32x4_t v314;
  unsigned int v315;
  unsigned int v316;
  unsigned int v317;
  unsigned int v318;
  unsigned int v319;
  unsigned int v320;
  __int32 v321;
  unsigned int v322;
  float32x4_t v323;
  float32x4_t v324;
  float32x4_t v325;
  float32x4_t v326;
  float32x4_t v327;
  float32x4_t v328;
  float32x4_t v329;
  float32x4_t v330;
  float32x4_t v331;
  float32x4_t v332;
  float32x4_t v333;
  float32x4_t v334;
  float32x4_t v335;
  __int128 v336;
  unsigned int v337;
  unsigned int v338;
  unsigned int v339;
  unsigned int v340;
  unsigned int v341;
  unsigned int v342;
  unsigned int v343;
  float32x4_t v344;
  float32x4_t v345;
  float32x4_t v346;
  float32x4_t v347;
  float32x4_t v348;
  float32x4_t v349;
  float32x4_t v350;
  float32x4_t v351;
  float32x4_t v352;
  float32x4_t v353;
  float32x4_t v354;
  float32x4_t v355;
  float32x4_t v356;
  float32x4_t v357;
  float32x4_t v358;
  float32x4_t v359;
  float32x4_t v360;
  float32x4_t v361;
  float32x4_t v362;
  float32x4_t v363;
  float32x4_t v364;
  float32x4_t v365;
  float32x4_t v366;
  float32x4_t v367;
  float32x4_t v368;
  float32x4_t v369;
  float32x4_t v370;
  float32x4_t v371;
  float32x4_t v372;
  float32x4_t v373;
  float32x4_t v374;
  float32x4_t v375;
  int v376;
  _BYTE v377[264];
  float32x4_t __src;
  float32x4_t v379;
  float32x4_t v380;
  float32x4_t v381;
  float32x4_t v382;
  float32x4_t v383;
  float32x4_t v384;
  float32x4_t v385;
  float32x4_t v386;
  float32x4_t v387;
  float32x4_t v388;
  float32x4_t v389;
  float32x4_t v390;
  float32x4_t v391;
  float32x4_t v392;
  float32x4_t v393;
  int v394;
  int v395;
  float32x4_t v396;
  float32x4_t v397;
  float32x4_t v398;
  float32x4_t v399;
  float32x4_t v400;
  float32x4_t v401;
  float32x4_t v402;
  float32x4_t v403;
  float32x4_t v404;
  float32x4_t v405;
  float32x4_t v406;
  float32x4_t v407;
  float32x4_t v408;
  float32x4_t v409;
  float32x4_t v410;
  float32x4_t v411;
  float32x4_t v412;
  float32x4_t v413;
  float32x4_t v414;
  float32x4_t v415;
  float32x4_t v416;
  float32x4_t v417;
  float32x4_t v418;
  float32x4_t v419;
  float32x4_t v420;
  float32x4_t v421;
  float32x4_t v422;
  float32x4_t v423;
  float32x4_t v424;
  float32x4_t v425;
  float32x4_t v426;
  float32x4_t v427;
  float32x4x2_t v428;
  float32x4x2_t v429;
  float32x4x2_t v430;
  float32x4x2_t v431;

  v6 = *(_QWORD *)(a1 + 648);
  if (*(_QWORD *)(a1 + 656) == v6 || (v8 = *(_QWORD *)(a1 + 672), *(_QWORD *)(a1 + 680) == v8))
  {
LABEL_157:
    __break(1u);
    return;
  }
  v10 = *(_QWORD *)(*(_QWORD *)v6 + 40);
  v11 = *(_QWORD *)(*(_QWORD *)v8 + 40);
  p_src = (float32x4_t *)&v377[4];
  if (v10 == v11)
    p_src = &__src;
  v287 = (uint64_t)p_src;
  if (v10 == v11)
  {
    v394 = 0;
    v392 = 0u;
    v393 = 0u;
    v390 = 0u;
    v391 = 0u;
    v388 = 0u;
    v389 = 0u;
    v386 = 0u;
    v387 = 0u;
    v384 = 0u;
    v385 = 0u;
    v382 = 0u;
    v383 = 0u;
    v380 = 0u;
    v381 = 0u;
    __src = 0u;
    v379 = 0u;
    if (v10)
    {
      v13 = 0;
      v14 = *(_QWORD *)(a2 + 8);
      v15 = *(_DWORD *)(v14 + 36);
      v16 = *(_QWORD *)(v14 + 8);
      v17 = 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v14 + 16) - v16) >> 3);
      while (v17 > v15)
      {
        v18 = (float32x4_t **)(v16 + 24 * v15);
        v20 = *v18;
        v19 = v18[1];
        if (v20 != v19)
        {
          v21 = 0;
          v22 = v20;
          do
          {
            if (&__src >= (float32x4_t *)&v20[16].i32[65 * v21 + 1] || v22 >= (float32x4_t *)&v395)
            {
              v24 = vaddq_f32(v22[1], v379);
              __src = vaddq_f32(*v22, __src);
              v379 = v24;
              v25 = vaddq_f32(v22[3], v381);
              v380 = vaddq_f32(v22[2], v380);
              v381 = v25;
              v26 = vaddq_f32(v22[5], v383);
              v382 = vaddq_f32(v22[4], v382);
              v383 = v26;
              v27 = vaddq_f32(v22[7], v385);
              v384 = vaddq_f32(v22[6], v384);
              v385 = v27;
              v28 = vaddq_f32(v22[9], v387);
              v386 = vaddq_f32(v22[8], v386);
              v387 = v28;
              v29 = vaddq_f32(v22[11], v389);
              v388 = vaddq_f32(v22[10], v388);
              v389 = v29;
              v30 = vaddq_f32(v22[13], v391);
              v390 = vaddq_f32(v22[12], v390);
              v391 = v30;
              v31 = vaddq_f32(v22[15], v393);
              v32 = 64;
              v392 = vaddq_f32(v22[14], v392);
              v393 = v31;
            }
            else
            {
              v32 = 0;
            }
            v33 = v32;
            do
            {
              __src.f32[v33] = v22->f32[v33] + __src.f32[v33];
              ++v33;
            }
            while (v33 != 65);
            v22 = (float32x4_t *)((char *)v22 + 260);
            ++v21;
          }
          while (v22 != v19);
        }
        if (*(_DWORD *)v14 - 1 > v15)
          ++v15;
        else
          v15 = 0;
        if (++v13 == v10)
          goto LABEL_29;
      }
      goto LABEL_157;
    }
  }
  else
  {
    if (v10 <= v11)
    {
      v34 = &__src;
      v35 = (float32x4_t *)&v377[4];
      v36 = (float32x4_t *)a2;
      v37 = v10;
      v10 = v11;
    }
    else
    {
      v34 = (float32x4_t *)&v377[4];
      v35 = &__src;
      v36 = (float32x4_t *)a2;
      v37 = v11;
    }
    webrtc::RenderBuffer::SpectralSums(v36, v37, v10, v34, v35);
  }
LABEL_29:
  if (*(_QWORD *)(a1 + 632))
  {
    v38 = 0;
    v39 = 0;
    v285 = a6 + 256;
    v284 = a6 + 768;
    v40 = a6;
    v286 = a6 + 512;
    v41 = a6 + 512;
    while (1)
    {
      v56 = *(_QWORD *)(a3 + 8);
      if ((int)((_DWORD)v39 << 6) >= (unint64_t)((*(_QWORD *)(a3 + 16) - v56) >> 2))
        goto LABEL_157;
      v57 = *(_QWORD *)(a1 + 648);
      if (v39 >= (*(_QWORD *)(a1 + 656) - v57) >> 3)
        goto LABEL_157;
      v294 = v41;
      v291 = v38;
      v292 = 4 * v38;
      v298 = 2092 * v39;
      v58 = v286 + 2092 * v39;
      v59 = a6;
      v60 = 4 * (int)((_DWORD)v39 << 6);
      v61 = (float32x4_t *)(v56 + v60);
      v62 = v59;
      v295 = v59 + 2092 * v39;
      v296 = (float32x4_t *)(v295 + 512);
      webrtc::aec3::ApplyFilter(a2, *(_QWORD *)(*(_QWORD *)(v57 + 8 * v39) + 40), (_QWORD *)(*(_QWORD *)(v57 + 8 * v39) + 72), (char *)&v300);
      v428.val[0] = v301;
      v430.val[0] = v302;
      v63 = &v396.f32[2];
      v428.val[1] = v323;
      v430.val[1] = v324;
      vst2q_f32(v63, v428);
      v64 = &v398.f32[2];
      vst2q_f32(v64, v430);
      v428.val[0] = v303;
      v430.val[0] = v304;
      v428.val[1] = v325;
      v430.val[1] = v326;
      v65 = &v400.f32[2];
      vst2q_f32(v65, v428);
      v66 = &v402.f32[2];
      vst2q_f32(v66, v430);
      v428.val[0] = v305;
      v430.val[0] = v306;
      v428.val[1] = v327;
      v430.val[1] = v328;
      v67 = &v404.f32[2];
      vst2q_f32(v67, v428);
      v68 = &v406.f32[2];
      vst2q_f32(v68, v430);
      v428.val[0] = v307;
      v430.val[0] = v308;
      v428.val[1] = v329;
      v430.val[1] = v330;
      v69 = &v408.f32[2];
      vst2q_f32(v69, v428);
      v71 = &v412.f32[2];
      v70 = &v410.f32[2];
      vst2q_f32(v70, v430);
      v428.val[0] = v309;
      v430.val[0] = v310;
      v428.val[1] = v331;
      v430.val[1] = v332;
      vst2q_f32(v71, v428);
      v72 = &v414.f32[2];
      vst2q_f32(v72, v430);
      v428.val[0] = v311;
      v430.val[0] = v312;
      v428.val[1] = v333;
      v430.val[1] = v334;
      v73 = &v416.f32[2];
      vst2q_f32(v73, v428);
      v428.val[0].i32[0] = v300;
      v74 = &v418.f32[2];
      vst2q_f32(v74, v430);
      v430.val[0].i32[0] = v321;
      v396.i64[0] = __PAIR64__(v322, v428.val[0].u32[0]);
      v428.val[0] = v313;
      v430.val[1] = v314;
      v428.val[1] = v335;
      v75 = v336;
      v76 = &v420.f32[2];
      vst2q_f32(v76, v428);
      v424.i64[1] = __PAIR64__(v337, v315);
      v425.i64[0] = __PAIR64__(v338, v316);
      v425.i64[1] = __PAIR64__(v339, v317);
      v426.i64[0] = __PAIR64__(v340, v318);
      v426.i64[1] = __PAIR64__(v341, v319);
      v427.i64[0] = __PAIR64__(v342, v320);
      v427.i64[1] = __PAIR64__(v343, v430.val[0].u32[0]);
      v77 = &v422.f32[2];
      vst2q_f32(v77, *(float32x4x2_t *)((char *)&v430 + 16));
      webrtc::OouraFft::InverseFft((webrtc::OouraFft *)a1, v396.f32);
      v293 = v60;
      if ((unint64_t)(v58 - (v60 + v56)) < 0x20 || (unint64_t)(v58 - (_QWORD)&v412) <= 0x1F)
      {
        for (i = 0; i != 64; ++i)
          *(float *)(v294 + i * 4) = *(float *)(v56 + v292 + i * 4) + (float)(v412.f32[i] * -0.015625);
      }
      else
      {
        v78 = (float32x4_t)vdupq_n_s32(0x3C800000u);
        v79 = vmlsq_f32(v61[1], v78, v413);
        *v296 = vmlsq_f32(*v61, v78, v412);
        *(float32x4_t *)(v295 + 528) = v79;
        v80 = vmlsq_f32(v61[3], v78, v415);
        *(float32x4_t *)(v295 + 544) = vmlsq_f32(v61[2], v78, v414);
        *(float32x4_t *)(v295 + 560) = v80;
        v81 = vmlsq_f32(v61[5], v78, v417);
        *(float32x4_t *)(v295 + 576) = vmlsq_f32(v61[4], v78, v416);
        *(float32x4_t *)(v295 + 592) = v81;
        v82 = vmlsq_f32(v61[7], v78, v419);
        *(float32x4_t *)(v295 + 608) = vmlsq_f32(v61[6], v78, v418);
        *(float32x4_t *)(v295 + 624) = v82;
        v83 = vmlsq_f32(v61[9], v78, v421);
        *(float32x4_t *)(v295 + 640) = vmlsq_f32(v61[8], v78, v420);
        *(float32x4_t *)(v295 + 656) = v83;
        v84 = vmlsq_f32(v61[11], v78, v423);
        *(float32x4_t *)(v295 + 672) = vmlsq_f32(v61[10], v78, v422);
        *(float32x4_t *)(v295 + 688) = v84;
        v85 = vmlsq_f32(v61[13], v78, v425);
        *(float32x4_t *)(v295 + 704) = vmlsq_f32(v61[12], v78, v424);
        *(float32x4_t *)(v295 + 720) = v85;
        v86 = vmlsq_f32(v61[15], v78, v427);
        *(float32x4_t *)(v295 + 736) = vmlsq_f32(v61[14], v78, v426);
        *(float32x4_t *)(v295 + 752) = v86;
      }
      a6 = v62;
      v88 = (float32x4_t *)(v62 + v298);
      if (!v62)
        goto LABEL_43;
      if ((unint64_t)((char *)v88 - (char *)&v412) <= 0x1F)
        break;
      v91 = (float32x4_t)vdupq_n_s32(0x3C800000u);
      v92 = vmulq_f32(v413, v91);
      *v88 = vmulq_f32(v412, v91);
      v88[1] = v92;
      v93 = vmulq_f32(v415, v91);
      v88[2] = vmulq_f32(v414, v91);
      v88[3] = v93;
      v94 = vmulq_f32(v417, v91);
      v88[4] = vmulq_f32(v416, v91);
      v88[5] = v94;
      v95 = vmulq_f32(v419, v91);
      v88[6] = vmulq_f32(v418, v91);
      v88[7] = v95;
      v96 = vmulq_f32(v421, v91);
      v88[8] = vmulq_f32(v420, v91);
      v88[9] = v96;
      v97 = vmulq_f32(v423, v91);
      v88[10] = vmulq_f32(v422, v91);
      v88[11] = v97;
      v98 = vmulq_f32(v425, v91);
      v88[12] = vmulq_f32(v424, v91);
      v88[13] = v98;
      v99 = vmulq_f32(v427, v91);
      v88[14] = vmulq_f32(v426, v91);
      v88[15] = v99;
      v90 = *(_QWORD *)(a1 + 672);
      if (v39 >= (*(_QWORD *)(a1 + 680) - v90) >> 3)
        goto LABEL_157;
LABEL_46:
      v297 = (float32x4_t *)(v62 + v298);
      v100 = (float *)(v295 + 768);
      webrtc::aec3::ApplyFilter(a2, *(_QWORD *)(*(_QWORD *)(v90 + 8 * v39) + 40), (_QWORD *)(*(_QWORD *)(v90 + 8 * v39) + 72), (char *)&v300);
      v429.val[0] = v301;
      v431.val[0] = v302;
      v101 = &v396.f32[2];
      v429.val[1] = v323;
      v431.val[1] = v324;
      vst2q_f32(v101, v429);
      v102 = &v398.f32[2];
      vst2q_f32(v102, v431);
      v429.val[0] = v303;
      v431.val[0] = v304;
      v429.val[1] = v325;
      v431.val[1] = v326;
      v103 = &v400.f32[2];
      vst2q_f32(v103, v429);
      v104 = &v402.f32[2];
      vst2q_f32(v104, v431);
      v429.val[0] = v305;
      v431.val[0] = v306;
      v429.val[1] = v327;
      v431.val[1] = v328;
      v105 = &v404.f32[2];
      vst2q_f32(v105, v429);
      v106 = &v406.f32[2];
      vst2q_f32(v106, v431);
      v429.val[0] = v307;
      v431.val[0] = v308;
      v429.val[1] = v329;
      v431.val[1] = v330;
      v107 = &v408.f32[2];
      vst2q_f32(v107, v429);
      v109 = &v412.f32[2];
      v108 = &v410.f32[2];
      vst2q_f32(v108, v431);
      v429.val[0] = v309;
      v431.val[0] = v310;
      v429.val[1] = v331;
      v431.val[1] = v332;
      vst2q_f32(v109, v429);
      v110 = &v414.f32[2];
      vst2q_f32(v110, v431);
      v429.val[0] = v311;
      v431.val[0] = v312;
      v429.val[1] = v333;
      v431.val[1] = v334;
      v111 = &v416.f32[2];
      vst2q_f32(v111, v429);
      v429.val[0].i32[0] = v300;
      v112 = &v418.f32[2];
      vst2q_f32(v112, v431);
      v431.val[0].i32[0] = v321;
      v396.i64[0] = __PAIR64__(v322, v429.val[0].u32[0]);
      v429.val[0] = v313;
      v431.val[1] = v314;
      v429.val[1] = v335;
      v113 = v336;
      v114 = &v420.f32[2];
      vst2q_f32(v114, v429);
      v424.i64[1] = __PAIR64__(v337, v315);
      v425.i64[0] = __PAIR64__(v338, v316);
      v425.i64[1] = __PAIR64__(v339, v317);
      v426.i64[0] = __PAIR64__(v340, v318);
      v426.i64[1] = __PAIR64__(v341, v319);
      v427.i64[0] = __PAIR64__(v342, v320);
      v427.i64[1] = __PAIR64__(v343, v431.val[0].u32[0]);
      v115 = &v422.f32[2];
      vst2q_f32(v115, *(float32x4x2_t *)((char *)&v431 + 16));
      webrtc::OouraFft::InverseFft((webrtc::OouraFft *)a1, v396.f32);
      if ((unint64_t)(v284 + v298 - (v293 + v56)) < 0x20
        || (unint64_t)(v284 + v298 - (_QWORD)&v412) <= 0x1F)
      {
        for (j = 0; j != 64; ++j)
          *(float *)(v40 + j * 4 + 768) = *(float *)(v56 + v292 + j * 4) + (float)(v412.f32[j] * -0.015625);
      }
      else
      {
        v116 = (float32x4_t)vdupq_n_s32(0x3C800000u);
        v117 = vmlsq_f32(v61[1], v116, v413);
        *(float32x4_t *)v100 = vmlsq_f32(*v61, v116, v412);
        *(float32x4_t *)(v295 + 784) = v117;
        v118 = vmlsq_f32(v61[3], v116, v415);
        *(float32x4_t *)(v295 + 800) = vmlsq_f32(v61[2], v116, v414);
        *(float32x4_t *)(v295 + 816) = v118;
        v119 = vmlsq_f32(v61[5], v116, v417);
        *(float32x4_t *)(v295 + 832) = vmlsq_f32(v61[4], v116, v416);
        *(float32x4_t *)(v295 + 848) = v119;
        v120 = vmlsq_f32(v61[7], v116, v419);
        *(float32x4_t *)(v295 + 864) = vmlsq_f32(v61[6], v116, v418);
        *(float32x4_t *)(v295 + 880) = v120;
        v121 = vmlsq_f32(v61[9], v116, v421);
        *(float32x4_t *)(v295 + 896) = vmlsq_f32(v61[8], v116, v420);
        *(float32x4_t *)(v295 + 912) = v121;
        v122 = vmlsq_f32(v61[11], v116, v423);
        *(float32x4_t *)(v295 + 928) = vmlsq_f32(v61[10], v116, v422);
        *(float32x4_t *)(v295 + 944) = v122;
        v123 = vmlsq_f32(v61[13], v116, v425);
        *(float32x4_t *)(v295 + 960) = vmlsq_f32(v61[12], v116, v424);
        *(float32x4_t *)(v295 + 976) = v123;
        v124 = vmlsq_f32(v61[15], v116, v427);
        *(float32x4_t *)(v295 + 992) = vmlsq_f32(v61[14], v116, v426);
        *(float32x4_t *)(v295 + 1008) = v124;
      }
      if ((unint64_t)(v285 + v298 - (_QWORD)&v412) > 0x1F)
      {
        v128 = (float32x4_t *)(a6 + 2092 * v39);
        v129 = (float32x4_t)vdupq_n_s32(0x3C800000u);
        v130 = vmulq_f32(v413, v129);
        v128[16] = vmulq_f32(v412, v129);
        v128[17] = v130;
        v128 += 16;
        v131 = vmulq_f32(v415, v129);
        v128[2] = vmulq_f32(v414, v129);
        v128[3] = v131;
        v132 = vmulq_f32(v417, v129);
        v128[4] = vmulq_f32(v416, v129);
        v128[5] = v132;
        v133 = vmulq_f32(v419, v129);
        v128[6] = vmulq_f32(v418, v129);
        v128[7] = v133;
        v134 = vmulq_f32(v421, v129);
        v128[8] = vmulq_f32(v420, v129);
        v128[9] = v134;
        v135 = vmulq_f32(v423, v129);
        v128[10] = vmulq_f32(v422, v129);
        v128[11] = v135;
        v136 = vmulq_f32(v425, v129);
        v128[12] = vmulq_f32(v424, v129);
        v128[13] = v136;
        v137 = vmulq_f32(v427, v129);
        v128[14] = vmulq_f32(v426, v129);
        v128[15] = v137;
        v127 = (float *)v297;
      }
      else
      {
        v126 = 64;
        v127 = (float *)v297;
        do
        {
          *(float *)(v40 + v126 * 4) = v396.f32[v126] * 0.015625;
          ++v126;
        }
        while (v126 != 128);
      }
      webrtc::SubtractorOutput::ComputeMetrics(v127, v61->f32, 64);
      v139 = *(_QWORD *)(a1 + 744);
      if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 752) - v139) >> 3) <= v39)
        goto LABEL_157;
      v140 = (int *)(v139 + 24 * v39);
      v141 = a6 + 2092 * v39;
      v142 = v140 + 2;
      v143 = *(float *)(v141 + 2072) + *((float *)v140 + 2);
      *((float *)v140 + 2) = v143;
      v144 = *(float *)(v141 + 2080) + *((float *)v140 + 3);
      *((float *)v140 + 3) = v144;
      v145 = *(float *)v140;
      v147 = v140[1];
      v146 = v140 + 1;
      v148 = v147 + 1;
      *v146 = v147 + 1;
      if (v147 + 1 == LODWORD(v145))
      {
        v149 = (float)v148;
        if (v144 > (float)((float)((float)((float)v148 * 200.0) * 200.0) * 64.0))
        {
          v150 = v143 / v144;
          v151 = (int *)(v139 + 24 * v39 + 20);
          if (v143 > (float)((float)((float)(v149 * 7500.0) * 7500.0) * 64.0))
          {
            *v151 = 4;
            v152 = v139 + 24 * v39;
            v154 = *(float *)(v152 + 16);
            v153 = (float *)(v152 + 16);
            v155 = v154;
            goto LABEL_67;
          }
          v156 = *v151;
          if (*v151 <= 1)
            v156 = 1;
          v157 = v156 - 1;
          *v151 = v157;
          v158 = v139 + 24 * v39;
          v159 = *(float *)(v158 + 16);
          v153 = (float *)(v158 + 16);
          v155 = v159;
          if (v150 < v159 || v157 != 0)
LABEL_67:
            *v153 = v155 + (float)((float)(v150 - v155) * 0.1);
        }
        *v142 = 0;
        *v146 = 0;
      }
      v161 = *(float *)(v139 + 24 * v39 + 16);
      if (v161 > 10.0)
      {
        v162 = *(_QWORD *)(a1 + 648);
        if (v39 >= (*(_QWORD *)(a1 + 656) - v162) >> 3)
          goto LABEL_157;
        *(float *)&v138 = 2.0 / sqrtf(v161);
        v283 = *(float *)&v138;
        webrtc::AdaptiveFirFilter::ScaleFilter(*(_QWORD *)(v162 + 8 * v39), v138);
        v163 = *(_QWORD *)(a1 + 840);
        if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 848) - v163) >> 3) <= v39)
          goto LABEL_157;
        v164 = (float32x4_t **)(v163 + 24 * v39);
        v166 = *v164;
        v165 = (float *)v164[1];
        if (v166 != (float32x4_t *)v165)
        {
          v167 = (char *)v165 - (char *)v166 - 4;
          v168 = (float *)v166;
          if (v167 < 0x1C)
            goto LABEL_160;
          v169 = (v167 >> 2) + 1;
          v168 = &v166->f32[v169 & 0x7FFFFFFFFFFFFFF8];
          v170 = v166 + 1;
          v171 = v169 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v172 = vmulq_n_f32(*v170, v283);
            v170[-1] = vmulq_n_f32(v170[-1], v283);
            *v170 = v172;
            v170 += 2;
            v171 -= 8;
          }
          while (v171);
          if (v169 != (v169 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_160:
            do
            {
              *v168 = v283 * *v168;
              ++v168;
            }
            while (v168 != v165);
          }
        }
        if ((unint64_t)v297 >= v56 + v293 + 256 || v61 >= &v297[48])
        {
          v174 = vmulq_n_f32(*v297, v283);
          v175 = vmulq_n_f32(v297[1], v283);
          *v297 = v174;
          v297[1] = v175;
          v176 = vsubq_f32(v61[1], v175);
          *v296 = vsubq_f32(*v61, v174);
          *(float32x4_t *)(v295 + 528) = v176;
          v177 = vmulq_n_f32(v297[2], v283);
          v178 = vmulq_n_f32(v297[3], v283);
          v297[2] = v177;
          v297[3] = v178;
          v179 = vsubq_f32(v61[3], v178);
          *(float32x4_t *)(v295 + 544) = vsubq_f32(v61[2], v177);
          *(float32x4_t *)(v295 + 560) = v179;
          v180 = vmulq_n_f32(v297[4], v283);
          v181 = vmulq_n_f32(v297[5], v283);
          v297[4] = v180;
          v297[5] = v181;
          v182 = vsubq_f32(v61[5], v181);
          *(float32x4_t *)(v295 + 576) = vsubq_f32(v61[4], v180);
          *(float32x4_t *)(v295 + 592) = v182;
          v183 = vmulq_n_f32(v297[6], v283);
          v184 = vmulq_n_f32(v297[7], v283);
          v297[6] = v183;
          v297[7] = v184;
          v185 = vsubq_f32(v61[7], v184);
          *(float32x4_t *)(v295 + 608) = vsubq_f32(v61[6], v183);
          *(float32x4_t *)(v295 + 624) = v185;
          v186 = vmulq_n_f32(v297[8], v283);
          v187 = vmulq_n_f32(v297[9], v283);
          v297[8] = v186;
          v297[9] = v187;
          v188 = vsubq_f32(v61[9], v187);
          *(float32x4_t *)(v295 + 640) = vsubq_f32(v61[8], v186);
          *(float32x4_t *)(v295 + 656) = v188;
          v189 = vmulq_n_f32(v297[10], v283);
          v190 = vmulq_n_f32(v297[11], v283);
          v297[10] = v189;
          v297[11] = v190;
          v191 = vsubq_f32(v61[11], v190);
          *(float32x4_t *)(v295 + 672) = vsubq_f32(v61[10], v189);
          *(float32x4_t *)(v295 + 688) = v191;
          v192 = vmulq_n_f32(v297[12], v283);
          v193 = vmulq_n_f32(v297[13], v283);
          v297[12] = v192;
          v297[13] = v193;
          v194 = vsubq_f32(v61[13], v193);
          *(float32x4_t *)(v295 + 704) = vsubq_f32(v61[12], v192);
          *(float32x4_t *)(v295 + 720) = v194;
          v195 = vmulq_n_f32(v297[14], v283);
          v196 = vmulq_n_f32(v297[15], v283);
          v297[14] = v195;
          v297[15] = v196;
          v197 = vsubq_f32(v61[15], v196);
          *(float32x4_t *)(v295 + 736) = vsubq_f32(v61[14], v195);
          *(float32x4_t *)(v295 + 752) = v197;
        }
        else
        {
          for (k = 0; k != 256; k += 4)
          {
            v199 = v283 * *(float *)(v40 + k);
            *(float *)(v40 + k) = v199;
            *(float *)(v294 + k) = *(float *)(v56 + v292 + k) - v199;
          }
        }
        v200 = *(_QWORD *)(a1 + 744);
        if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 752) - v200) >> 3) <= v39)
          goto LABEL_157;
        v201 = v200 + 24 * v39;
        *(_QWORD *)(v201 + 12) = 0;
        *(_QWORD *)(v201 + 4) = 0;
        *(_DWORD *)(v201 + 20) = 0;
      }
      webrtc::Aec3Fft::ZeroPaddedFft((webrtc::OouraFft *)a1, v296->f32, 64, 1, v295 + 1024);
      webrtc::Aec3Fft::ZeroPaddedFft((webrtc::OouraFft *)a1, v100, 64, 1, (uint64_t)&v344);
      v202 = (float32x4_t *)(a6 + 2092 * v39 + 1804);
      if ((char *)&v297[112].u64[1] + 4 >= v377 || &v344 >= &v297[129])
      {
        v205 = vmlaq_f32(vmulq_f32(v361, v361), v345, v345);
        *v202 = vmlaq_f32(vmulq_f32(v360, v360), v344, v344);
        *(float32x4_t *)(a6 + 2092 * v39 + 1820) = v205;
        v206 = vmlaq_f32(vmulq_f32(v363, v363), v347, v347);
        *(float32x4_t *)(a6 + 2092 * v39 + 1836) = vmlaq_f32(vmulq_f32(v362, v362), v346, v346);
        *(float32x4_t *)(a6 + 2092 * v39 + 1852) = v206;
        v207 = vmlaq_f32(vmulq_f32(v365, v365), v349, v349);
        *(float32x4_t *)(a6 + 2092 * v39 + 1868) = vmlaq_f32(vmulq_f32(v364, v364), v348, v348);
        *(float32x4_t *)(a6 + 2092 * v39 + 1884) = v207;
        v208 = vmlaq_f32(vmulq_f32(v367, v367), v351, v351);
        *(float32x4_t *)(a6 + 2092 * v39 + 1900) = vmlaq_f32(vmulq_f32(v366, v366), v350, v350);
        *(float32x4_t *)(a6 + 2092 * v39 + 1916) = v208;
        v209 = vmlaq_f32(vmulq_f32(v369, v369), v353, v353);
        *(float32x4_t *)(a6 + 2092 * v39 + 1932) = vmlaq_f32(vmulq_f32(v368, v368), v352, v352);
        *(float32x4_t *)(a6 + 2092 * v39 + 1948) = v209;
        v210 = vmlaq_f32(vmulq_f32(v371, v371), v355, v355);
        *(float32x4_t *)(a6 + 2092 * v39 + 1964) = vmlaq_f32(vmulq_f32(v370, v370), v354, v354);
        *(float32x4_t *)(a6 + 2092 * v39 + 1980) = v210;
        v211 = vmlaq_f32(vmulq_f32(v373, v373), v357, v357);
        *(float32x4_t *)(a6 + 2092 * v39 + 1996) = vmlaq_f32(vmulq_f32(v372, v372), v356, v356);
        *(float32x4_t *)(a6 + 2092 * v39 + 2012) = v211;
        v212 = vmlaq_f32(vmulq_f32(v375, v375), v359, v359);
        *(float32x4_t *)(a6 + 2092 * v39 + 2028) = vmlaq_f32(vmulq_f32(v374, v374), v358, v358);
        *(float32x4_t *)(a6 + 2092 * v39 + 2044) = v212;
        v202 = (float32x4_t *)(a6 + 2092 * v39 + 2060);
        v204 = (float32x4_t *)&v376;
        v203 = 64;
      }
      else
      {
        v203 = 0;
        v204 = &v360;
      }
      v213 = v203;
      do
      {
        v214 = v204->f32[0];
        v204 = (float32x4_t *)((char *)v204 + 4);
        v202->f32[0] = (float)(v214 * v214) + (float)(v344.f32[v213] * v344.f32[v213]);
        v202 = (float32x4_t *)((char *)v202 + 4);
        ++v213;
      }
      while (v213 != 65);
      v215 = a6 + 2092 * v39;
      v216 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1300), *(float32x4_t *)(v215 + 1300)), *(float32x4_t *)(v295 + 1040), *(float32x4_t *)(v295 + 1040));
      *(float32x4_t *)(v215 + 1544) = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1284), *(float32x4_t *)(v215 + 1284)), *(float32x4_t *)(v295 + 1024), *(float32x4_t *)(v295 + 1024));
      *(float32x4_t *)(v215 + 1560) = v216;
      v217 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1332), *(float32x4_t *)(v215 + 1332)), *(float32x4_t *)(v295 + 1072), *(float32x4_t *)(v295 + 1072));
      *(float32x4_t *)(v215 + 1576) = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1316), *(float32x4_t *)(v215 + 1316)), *(float32x4_t *)(v295 + 1056), *(float32x4_t *)(v295 + 1056));
      *(float32x4_t *)(v215 + 1592) = v217;
      v218 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1364), *(float32x4_t *)(v215 + 1364)), *(float32x4_t *)(v295 + 1104), *(float32x4_t *)(v295 + 1104));
      *(float32x4_t *)(v215 + 1608) = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1348), *(float32x4_t *)(v215 + 1348)), *(float32x4_t *)(v295 + 1088), *(float32x4_t *)(v295 + 1088));
      *(float32x4_t *)(v215 + 1624) = v218;
      v219 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1396), *(float32x4_t *)(v215 + 1396)), *(float32x4_t *)(v295 + 1136), *(float32x4_t *)(v295 + 1136));
      *(float32x4_t *)(v215 + 1640) = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1380), *(float32x4_t *)(v215 + 1380)), *(float32x4_t *)(v295 + 1120), *(float32x4_t *)(v295 + 1120));
      *(float32x4_t *)(v215 + 1656) = v219;
      v220 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1428), *(float32x4_t *)(v215 + 1428)), *(float32x4_t *)(v295 + 1168), *(float32x4_t *)(v295 + 1168));
      *(float32x4_t *)(v215 + 1672) = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1412), *(float32x4_t *)(v215 + 1412)), *(float32x4_t *)(v295 + 1152), *(float32x4_t *)(v295 + 1152));
      *(float32x4_t *)(v215 + 1688) = v220;
      v221 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1460), *(float32x4_t *)(v215 + 1460)), *(float32x4_t *)(v295 + 1200), *(float32x4_t *)(v295 + 1200));
      *(float32x4_t *)(v215 + 1704) = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1444), *(float32x4_t *)(v215 + 1444)), *(float32x4_t *)(v295 + 1184), *(float32x4_t *)(v295 + 1184));
      *(float32x4_t *)(v215 + 1720) = v221;
      v222 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1492), *(float32x4_t *)(v215 + 1492)), *(float32x4_t *)(v295 + 1232), *(float32x4_t *)(v295 + 1232));
      *(float32x4_t *)(v215 + 1736) = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1476), *(float32x4_t *)(v215 + 1476)), *(float32x4_t *)(v295 + 1216), *(float32x4_t *)(v295 + 1216));
      *(float32x4_t *)(v215 + 1752) = v222;
      v224 = *(float32x4_t *)(v295 + 1264);
      v223 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1524), *(float32x4_t *)(v215 + 1524)), v224, v224);
      *(float32x4_t *)(v215 + 1768) = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v215 + 1508), *(float32x4_t *)(v215 + 1508)), *(float32x4_t *)(v295 + 1248), *(float32x4_t *)(v295 + 1248));
      *(float32x4_t *)(v215 + 1784) = v223;
      v224.f32[0] = *(float *)(v215 + 1540) * *(float *)(v215 + 1540);
      *(float *)(v215 + 1800) = v224.f32[0] + (float)(*(float *)(v295 + 1280) * *(float *)(v295 + 1280));
      if (v161 <= 10.0)
      {
        v226 = *(_QWORD *)(a1 + 792);
        if (v39 >= (*(_QWORD *)(a1 + 800) - v226) >> 2)
          goto LABEL_157;
        v227 = *(int *)(v226 + 4 * v39) >= 1 && *(_BYTE *)(a1 + 640) != 0;
        v228 = *(_QWORD *)(a1 + 816);
        if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 824) - v228) >> 3) <= v39)
          goto LABEL_157;
        v412.i32[0] = 0;
        v229 = 0uLL;
        v411 = 0u;
        v230 = (float32x4_t **)(v228 + 24 * v39);
        v410 = 0u;
        v409 = 0u;
        v408 = 0u;
        v407 = 0u;
        v406 = 0u;
        v405 = 0u;
        v404 = 0u;
        v403 = 0u;
        v402 = 0u;
        v401 = 0u;
        v400 = 0u;
        v399 = 0u;
        v398 = 0u;
        v397 = 0u;
        v396 = 0u;
        v231 = *v230;
        v232 = v230[1];
        if (v231 != v232)
        {
          v233 = 0;
          v234 = v231;
          do
          {
            v235 = &v396;
            if (&v396 >= (float32x4_t *)&v231[16].i32[65 * v233 + 1] || v234 >= (float32x4_t *)&v412.i32[1])
            {
              v237 = vaddq_f32(v234[1], v397);
              v396 = vaddq_f32(*v234, v396);
              v397 = v237;
              v238 = vaddq_f32(v234[3], v399);
              v398 = vaddq_f32(v234[2], v398);
              v399 = v238;
              v239 = vaddq_f32(v234[5], v401);
              v400 = vaddq_f32(v234[4], v400);
              v401 = v239;
              v240 = vaddq_f32(v234[7], v403);
              v402 = vaddq_f32(v234[6], v402);
              v403 = v240;
              v241 = vaddq_f32(v234[9], v405);
              v404 = vaddq_f32(v234[8], v404);
              v405 = v241;
              v242 = vaddq_f32(v234[11], v407);
              v406 = vaddq_f32(v234[10], v406);
              v407 = v242;
              v243 = vaddq_f32(v234[13], v409);
              v408 = vaddq_f32(v234[12], v408);
              v409 = v243;
              v229 = vaddq_f32(v234[14], v410);
              v224 = vaddq_f32(v234[15], v411);
              v410 = v229;
              v235 = &v412;
              v244 = 64;
              v411 = v224;
            }
            else
            {
              v244 = 0;
            }
            v245 = v244;
            do
            {
              v224.i32[0] = v235->i32[0];
              v229.f32[0] = v234->f32[v245] + v235->f32[0];
              v235->i32[0] = v229.i32[0];
              v235 = (float32x4_t *)((char *)v235 + 4);
              ++v245;
            }
            while (v245 != 65);
            v234 = (float32x4_t *)((char *)v234 + 260);
            ++v233;
          }
          while (v234 != v232);
        }
        v246 = *(_QWORD *)(a1 + 696);
        if (v39 >= (*(_QWORD *)(a1 + 704) - v246) >> 3)
          goto LABEL_157;
        v247 = *(_QWORD *)(a1 + 648);
        if (v39 >= (*(_QWORD *)(a1 + 656) - v247) >> 3)
          goto LABEL_157;
        webrtc::RefinedFilterUpdateGain::Compute(*(_QWORD *)(v246 + 8 * v39), &__src, a4, (uint64_t)v297, &v396, 65, *(_QWORD *)(*(_QWORD *)(v247 + 8 * v39) + 40), *(_BYTE *)(a5 + 2000), v229, v224, v227, (float32x4_t *)&v300);
        v225 = *(_QWORD *)(a1 + 648);
        if (v39 >= (*(_QWORD *)(a1 + 656) - v225) >> 3)
          goto LABEL_157;
      }
      else
      {
        bzero(&v300, 0x208uLL);
        v225 = *(_QWORD *)(a1 + 648);
        if (v39 >= (*(_QWORD *)(a1 + 656) - v225) >> 3)
          goto LABEL_157;
      }
      v248 = *(_QWORD *)(a1 + 840);
      if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 848) - v248) >> 3) <= v39)
        goto LABEL_157;
      v249 = *(uint64_t **)(v225 + 8 * v39);
      v250 = (uint64_t *)(v248 + 24 * v39);
      webrtc::AdaptiveFirFilter::UpdateSize((webrtc::AdaptiveFirFilter *)v249);
      webrtc::aec3::AdaptPartitions(a2, (unint64_t)&v300, v249[5], v249 + 9);
      webrtc::AdaptiveFirFilter::ConstrainAndUpdateImpulseResponse((uint64_t)v249, v250);
      v251 = *(_QWORD *)(a1 + 648);
      if (v39 >= (*(_QWORD *)(a1 + 656) - v251) >> 3)
        goto LABEL_157;
      v252 = *(_QWORD *)(a1 + 816);
      if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 824) - v252) >> 3) <= v39)
        goto LABEL_157;
      v253 = *(_QWORD *)(v251 + 8 * v39);
      v254 = v252 + 24 * v39;
      v255 = *(_QWORD *)(v253 + 40);
      v256 = 0xFC0FC0FC0FC0FC1 * ((uint64_t)(*(_QWORD *)(v254 + 8) - *(_QWORD *)v254) >> 2);
      if (v255 <= v256)
      {
        if (v255 < v256)
          *(_QWORD *)(v254 + 8) = *(_QWORD *)v254 + 260 * v255;
      }
      else
      {
        std::vector<std::array<float,65ul>>::__append((char **)v254, v255 - v256);
        v255 = *(_QWORD *)(v253 + 40);
      }
      webrtc::aec3::ComputeFrequencyResponse(v255, v253 + 72, (void **)v254);
      v257 = *(_QWORD *)(a1 + 768);
      v258 = (*(_QWORD *)(a1 + 776) - v257) >> 3;
      if (*(float *)(a6 + 2092 * v39 + 2072) >= *(float *)(a6 + 2092 * v39 + 2076))
      {
        if (v258 <= v39)
          goto LABEL_157;
        *(_QWORD *)(v257 + 8 * v39) = 0;
      }
      else
      {
        if (v258 <= v39)
          goto LABEL_157;
        v259 = *(_QWORD *)(v257 + 8 * v39) + 1;
        *(_QWORD *)(v257 + 8 * v39) = v259;
        if (v259 > 4)
        {
          *(_QWORD *)(v257 + 8 * v39) = 0;
          v260 = *(_QWORD *)(a1 + 672);
          if (v39 >= (*(_QWORD *)(a1 + 680) - v260) >> 3)
            goto LABEL_157;
          v261 = *(_QWORD *)(a1 + 648);
          if (v39 >= (*(_QWORD *)(a1 + 656) - v261) >> 3)
            goto LABEL_157;
          webrtc::AdaptiveFirFilter::SetFilter(*(_QWORD **)(v260 + 8 * v39), *(_QWORD *)(*(_QWORD *)(v261 + 8 * v39) + 40), (_QWORD *)(*(_QWORD *)(v261 + 8 * v39) + 72));
          v262 = *(_QWORD *)(a1 + 720);
          if (v39 >= (*(_QWORD *)(a1 + 728) - v262) >> 3)
            goto LABEL_157;
          v263 = *(_QWORD *)(a1 + 672);
          if (v39 >= (*(_QWORD *)(a1 + 680) - v263) >> 3)
            goto LABEL_157;
          webrtc::CoarseFilterUpdateGain::Compute(*(_QWORD *)(v262 + 8 * v39), v287, a4, v295 + 1024, *(_QWORD *)(*(_QWORD *)(v263 + 8 * v39) + 40), *(_BYTE *)(a5 + 2000), (float32x4_t *)&v300);
          v264 = *(_QWORD *)(a1 + 792);
          if (v39 >= (*(_QWORD *)(a1 + 800) - v264) >> 2)
            goto LABEL_157;
          *(_DWORD *)(v264 + 4 * v39) = *(_DWORD *)(a1 + 252);
          v265 = *(_QWORD *)(a1 + 672);
          if (v39 >= (*(_QWORD *)(a1 + 680) - v265) >> 3)
            goto LABEL_157;
          goto LABEL_140;
        }
      }
      v266 = *(_QWORD *)(a1 + 720);
      if (v39 >= (*(_QWORD *)(a1 + 728) - v266) >> 3)
        goto LABEL_157;
      v267 = *(_QWORD *)(a1 + 672);
      if (v39 >= (*(_QWORD *)(a1 + 680) - v267) >> 3)
        goto LABEL_157;
      webrtc::CoarseFilterUpdateGain::Compute(*(_QWORD *)(v266 + 8 * v39), v287, a4, (unint64_t)&v344, *(_QWORD *)(*(_QWORD *)(v267 + 8 * v39) + 40), *(_BYTE *)(a5 + 2000), (float32x4_t *)&v300);
      v268 = *(_QWORD *)(a1 + 792);
      if (v39 >= (*(_QWORD *)(a1 + 800) - v268) >> 2)
        goto LABEL_157;
      v269 = *(_DWORD *)(v268 + 4 * v39);
      if (v269 <= 1)
        v269 = 1;
      *(_DWORD *)(v268 + 4 * v39) = v269 - 1;
      v265 = *(_QWORD *)(a1 + 672);
      if (v39 >= (*(_QWORD *)(a1 + 680) - v265) >> 3)
        goto LABEL_157;
LABEL_140:
      v270 = *(uint64_t **)(v265 + 8 * v39);
      webrtc::AdaptiveFirFilter::UpdateSize((webrtc::AdaptiveFirFilter *)v270);
      webrtc::aec3::AdaptPartitions(a2, (unint64_t)&v300, v270[5], v270 + 9);
      webrtc::AdaptiveFirFilter::Constrain((webrtc::AdaptiveFirFilter *)v270);
      if (!v39)
      {
        if (*(_QWORD *)(a1 + 752) == *(_QWORD *)(a1 + 744))
          goto LABEL_157;
        if (*(_QWORD *)(a1 + 848) == *(_QWORD *)(a1 + 840))
          goto LABEL_157;
        v271 = *(uint64_t **)(a1 + 648);
        if (*(uint64_t **)(a1 + 656) == v271)
          goto LABEL_157;
        v272 = *v271;
        v273 = *(_QWORD *)(*v271 + 24);
        if (v273)
        {
          v274 = *(_QWORD *)(v272 + 72);
          v275 = 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v272 + 80) - v274) >> 3);
          v276 = (_QWORD *)(v274 + 8);
          while (v275 && *v276 != *(v276 - 1))
          {
            v276 += 3;
            --v275;
            if (!--v273)
              goto LABEL_149;
          }
          goto LABEL_157;
        }
LABEL_149:
        v277 = *(uint64_t **)(a1 + 672);
        if (*(uint64_t **)(a1 + 680) == v277)
          goto LABEL_157;
        v278 = *v277;
        v279 = *(_QWORD *)(*v277 + 24);
        if (v279)
        {
          v280 = *(_QWORD *)(v278 + 72);
          v281 = 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v278 + 80) - v280) >> 3);
          v282 = (_QWORD *)(v280 + 8);
          while (v281 && *v282 != *(v282 - 1))
          {
            v282 += 3;
            --v281;
            if (!--v279)
              goto LABEL_31;
          }
          goto LABEL_157;
        }
      }
LABEL_31:
      v42.i64[0] = 0xC7000000C7000000;
      v42.i64[1] = 0xC7000000C7000000;
      v43 = (int8x16_t)vdupq_n_s32(0x46FFFE00u);
      v44 = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 528)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 528), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 528)));
      v45 = *(int8x16_t *)(v295 + 544);
      v46 = *(int8x16_t *)(v295 + 560);
      *(int8x16_t *)v296 = vbslq_s8((int8x16_t)vcgeq_f32(v42, *v296), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*v296, (float32x4_t)v43), v43, *(int8x16_t *)v296));
      *(int8x16_t *)(v295 + 528) = v44;
      *(int8x16_t *)(v295 + 544) = vbslq_s8((int8x16_t)vcgeq_f32(v42, (float32x4_t)v45), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v45, (float32x4_t)v43), v43, v45));
      *(int8x16_t *)(v295 + 560) = vbslq_s8((int8x16_t)vcgeq_f32(v42, (float32x4_t)v46), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v46, (float32x4_t)v43), v43, v46));
      v47 = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 592)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 592), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 592)));
      *(int8x16_t *)(v295 + 576) = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 576)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 576), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 576)));
      *(int8x16_t *)(v295 + 592) = v47;
      v48 = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 624)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 624), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 624)));
      *(int8x16_t *)(v295 + 608) = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 608)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 608), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 608)));
      *(int8x16_t *)(v295 + 624) = v48;
      v49 = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 656)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 656), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 656)));
      *(int8x16_t *)(v295 + 640) = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 640)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 640), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 640)));
      *(int8x16_t *)(v295 + 656) = v49;
      v50 = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 688)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 688), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 688)));
      *(int8x16_t *)(v295 + 672) = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 672)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 672), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 672)));
      *(int8x16_t *)(v295 + 688) = v50;
      v51 = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 720)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 720), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 720)));
      *(int8x16_t *)(v295 + 704) = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 704)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 704), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 704)));
      *(int8x16_t *)(v295 + 720) = v51;
      v52 = *(int8x16_t *)(v295 + 736);
      v53 = (int8x16_t)vcgeq_f32(v42, (float32x4_t)v52);
      v54 = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v52, (float32x4_t)v43), v43, v52);
      v55 = vbslq_s8((int8x16_t)vcgeq_f32(v42, *(float32x4_t *)(v295 + 752)), (int8x16_t)v42, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v295 + 752), (float32x4_t)v43), v43, *(int8x16_t *)(v295 + 752)));
      *(int8x16_t *)(v295 + 736) = vbslq_s8(v53, (int8x16_t)v42, v54);
      *(int8x16_t *)(v295 + 752) = v55;
      ++v39;
      v41 = v294 + 2092;
      v38 = v291 + 64;
      v40 += 2092;
      if (v39 >= *(_QWORD *)(a1 + 632))
        return;
    }
    for (m = 0; m != 64; ++m)
      *(float *)(v40 + m * 4) = v412.f32[m] * 0.015625;
LABEL_43:
    v90 = *(_QWORD *)(a1 + 672);
    if (v39 >= (*(_QWORD *)(a1 + 680) - v90) >> 3)
      goto LABEL_157;
    goto LABEL_46;
  }
}

float *webrtc::SubtractorOutput::ComputeMetrics(float *result, float *a2, uint64_t a3)
{
  float v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  float *v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  uint64_t v53;
  float *v54;
  float v55;
  float v56;
  uint64_t v57;
  float *v58;
  float v59;
  float v60;
  float v61;
  uint64_t v62;
  float v63;
  uint64_t v64;
  BOOL v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;

  v3 = 0.0;
  if (!a3)
    goto LABEL_9;
  v4 = (a3 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v4)
  {
    v5 = v4 + 1;
    v6 = (v4 + 1) & 0x7FFFFFFFFFFFFFFELL;
    v7 = &a2[v6];
    v8 = a2 + 1;
    v9 = v6;
    do
    {
      v3 = (float)(v3 + (float)(*(v8 - 1) * *(v8 - 1))) + (float)(*v8 * *v8);
      v8 += 2;
      v9 -= 2;
    }
    while (v9);
    if (v5 == v6)
      goto LABEL_9;
  }
  else
  {
    v7 = a2;
  }
  do
  {
    v10 = *v7++;
    v3 = v3 + (float)(v10 * v10);
  }
  while (v7 != &a2[a3]);
LABEL_9:
  result[520] = v3;
  v11 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(result[128] * result[128]) + 0.0) + (float)(result[129] * result[129])) + (float)(result[130] * result[130])) + (float)(result[131] * result[131])) + (float)(result[132] * result[132])) + (float)(result[133] * result[133])) + (float)(result[134] * result[134])) + (float)(result[135] * result[135])) + (float)(result[136] * result[136]))
                                                                                              + (float)(result[137] * result[137]))
                                                                                      + (float)(result[138] * result[138]))
                                                                              + (float)(result[139] * result[139]))
                                                                      + (float)(result[140] * result[140]))
                                                              + (float)(result[141] * result[141]))
                                                      + (float)(result[142] * result[142]))
                                              + (float)(result[143] * result[143]))
                                      + (float)(result[144] * result[144]))
                              + (float)(result[145] * result[145]))
                      + (float)(result[146] * result[146]))
              + (float)(result[147] * result[147]))
      + (float)(result[148] * result[148]);
  v12 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v11 + (float)(result[149] * result[149])) + (float)(result[150] * result[150])) + (float)(result[151] * result[151])) + (float)(result[152] * result[152])) + (float)(result[153] * result[153])) + (float)(result[154] * result[154])) + (float)(result[155] * result[155])) + (float)(result[156] * result[156])) + (float)(result[157] * result[157]))
                                                                                              + (float)(result[158] * result[158]))
                                                                                      + (float)(result[159] * result[159]))
                                                                              + (float)(result[160] * result[160]))
                                                                      + (float)(result[161] * result[161]))
                                                              + (float)(result[162] * result[162]))
                                                      + (float)(result[163] * result[163]))
                                              + (float)(result[164] * result[164]))
                                      + (float)(result[165] * result[165]))
                              + (float)(result[166] * result[166]))
                      + (float)(result[167] * result[167]))
              + (float)(result[168] * result[168]))
      + (float)(result[169] * result[169]);
  v13 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v12 + (float)(result[170] * result[170])) + (float)(result[171] * result[171])) + (float)(result[172] * result[172])) + (float)(result[173] * result[173])) + (float)(result[174] * result[174])) + (float)(result[175] * result[175])) + (float)(result[176] * result[176])) + (float)(result[177] * result[177])) + (float)(result[178] * result[178]))
                                                                                              + (float)(result[179] * result[179]))
                                                                                      + (float)(result[180] * result[180]))
                                                                              + (float)(result[181] * result[181]))
                                                                      + (float)(result[182] * result[182]))
                                                              + (float)(result[183] * result[183]))
                                                      + (float)(result[184] * result[184]))
                                              + (float)(result[185] * result[185]))
                                      + (float)(result[186] * result[186]))
                              + (float)(result[187] * result[187]))
                      + (float)(result[188] * result[188]))
              + (float)(result[189] * result[189]))
      + (float)(result[190] * result[190]);
  result[518] = v13 + (float)(result[191] * result[191]);
  v14 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(result[192] * result[192]) + 0.0) + (float)(result[193] * result[193])) + (float)(result[194] * result[194])) + (float)(result[195] * result[195])) + (float)(result[196] * result[196])) + (float)(result[197] * result[197])) + (float)(result[198] * result[198])) + (float)(result[199] * result[199])) + (float)(result[200] * result[200]))
                                                                                              + (float)(result[201] * result[201]))
                                                                                      + (float)(result[202] * result[202]))
                                                                              + (float)(result[203] * result[203]))
                                                                      + (float)(result[204] * result[204]))
                                                              + (float)(result[205] * result[205]))
                                                      + (float)(result[206] * result[206]))
                                              + (float)(result[207] * result[207]))
                                      + (float)(result[208] * result[208]))
                              + (float)(result[209] * result[209]))
                      + (float)(result[210] * result[210]))
              + (float)(result[211] * result[211]))
      + (float)(result[212] * result[212]);
  v15 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v14 + (float)(result[213] * result[213])) + (float)(result[214] * result[214])) + (float)(result[215] * result[215])) + (float)(result[216] * result[216])) + (float)(result[217] * result[217])) + (float)(result[218] * result[218])) + (float)(result[219] * result[219])) + (float)(result[220] * result[220])) + (float)(result[221] * result[221]))
                                                                                              + (float)(result[222] * result[222]))
                                                                                      + (float)(result[223] * result[223]))
                                                                              + (float)(result[224] * result[224]))
                                                                      + (float)(result[225] * result[225]))
                                                              + (float)(result[226] * result[226]))
                                                      + (float)(result[227] * result[227]))
                                              + (float)(result[228] * result[228]))
                                      + (float)(result[229] * result[229]))
                              + (float)(result[230] * result[230]))
                      + (float)(result[231] * result[231]))
              + (float)(result[232] * result[232]))
      + (float)(result[233] * result[233]);
  v16 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v15 + (float)(result[234] * result[234])) + (float)(result[235] * result[235])) + (float)(result[236] * result[236])) + (float)(result[237] * result[237])) + (float)(result[238] * result[238])) + (float)(result[239] * result[239])) + (float)(result[240] * result[240])) + (float)(result[241] * result[241])) + (float)(result[242] * result[242]))
                                                                                              + (float)(result[243] * result[243]))
                                                                                      + (float)(result[244] * result[244]))
                                                                              + (float)(result[245] * result[245]))
                                                                      + (float)(result[246] * result[246]))
                                                              + (float)(result[247] * result[247]))
                                                      + (float)(result[248] * result[248]))
                                              + (float)(result[249] * result[249]))
                                      + (float)(result[250] * result[250]))
                              + (float)(result[251] * result[251]))
                      + (float)(result[252] * result[252]))
              + (float)(result[253] * result[253]))
      + (float)(result[254] * result[254]);
  result[519] = v16 + (float)(result[255] * result[255]);
  v17 = *result;
  v18 = result[11];
  v19 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v17 * v17) + 0.0) + (float)(result[1] * result[1])) + (float)(result[2] * result[2])) + (float)(result[3] * result[3])) + (float)(result[4] * result[4])) + (float)(result[5] * result[5])) + (float)(result[6] * result[6])) + (float)(result[7] * result[7])) + (float)(result[8] * result[8])) + (float)(result[9] * result[9]))
                                                                                              + (float)(result[10] * result[10]))
                                                                                      + (float)(v18 * v18))
                                                                              + (float)(result[12] * result[12]))
                                                                      + (float)(result[13] * result[13]))
                                                              + (float)(result[14] * result[14]))
                                                      + (float)(result[15] * result[15]))
                                              + (float)(result[16] * result[16]))
                                      + (float)(result[17] * result[17]))
                              + (float)(result[18] * result[18]))
                      + (float)(result[19] * result[19]))
              + (float)(result[20] * result[20]))
      + (float)(result[21] * result[21]);
  v20 = result[33];
  v21 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v19 + (float)(result[22] * result[22])) + (float)(result[23] * result[23])) + (float)(result[24] * result[24])) + (float)(result[25] * result[25])) + (float)(result[26] * result[26])) + (float)(result[27] * result[27])) + (float)(result[28] * result[28])) + (float)(result[29] * result[29])) + (float)(result[30] * result[30])) + (float)(result[31] * result[31]))
                                                                                              + (float)(result[32] * result[32]))
                                                                                      + (float)(v20 * v20))
                                                                              + (float)(result[34] * result[34]))
                                                                      + (float)(result[35] * result[35]))
                                                              + (float)(result[36] * result[36]))
                                                      + (float)(result[37] * result[37]))
                                              + (float)(result[38] * result[38]))
                                      + (float)(result[39] * result[39]))
                              + (float)(result[40] * result[40]))
                      + (float)(result[41] * result[41]))
              + (float)(result[42] * result[42]))
      + (float)(result[43] * result[43]);
  v22 = result[55];
  result[516] = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v21 + (float)(result[44] * result[44])) + (float)(result[45] * result[45])) + (float)(result[46] * result[46])) + (float)(result[47] * result[47])) + (float)(result[48] * result[48])) + (float)(result[49] * result[49])) + (float)(result[50] * result[50])) + (float)(result[51] * result[51])) + (float)(result[52] * result[52]))
                                                                                              + (float)(result[53] * result[53]))
                                                                                      + (float)(result[54] * result[54]))
                                                                              + (float)(v22 * v22))
                                                                      + (float)(result[56] * result[56]))
                                                              + (float)(result[57] * result[57]))
                                                      + (float)(result[58] * result[58]))
                                              + (float)(result[59] * result[59]))
                                      + (float)(result[60] * result[60]))
                              + (float)(result[61] * result[61]))
                      + (float)(result[62] * result[62]))
              + (float)(result[63] * result[63]);
  v23 = result[64];
  v24 = result[65];
  v25 = result[66];
  v26 = result[67];
  v27 = result[68];
  v28 = result[69];
  v29 = result[70];
  v30 = result[71];
  v31 = result[72];
  v32 = result[73];
  v33 = result[74];
  v34 = result[75];
  v35 = result[76];
  v36 = result[77];
  v37 = result[78];
  v38 = result[79];
  v39 = result[80];
  v40 = result[81];
  v41 = result[82];
  v42 = result[83];
  v43 = result[84];
  v44 = result[85];
  v45 = result[86];
  v46 = result[87];
  v47 = result[88];
  v48 = result[89];
  v49 = result[90];
  v50 = result[91];
  v99 = result[92];
  v51 = result[93];
  v100 = result[94];
  v101 = result[95];
  v93 = result[96];
  v68 = result[97];
  v69 = result[98];
  v70 = result[99];
  v71 = result[100];
  v72 = result[101];
  v73 = result[102];
  v74 = result[103];
  v75 = result[104];
  v76 = result[105];
  v77 = result[106];
  v78 = result[107];
  v79 = result[108];
  v80 = result[109];
  v81 = result[110];
  v82 = result[111];
  v83 = result[112];
  v84 = result[113];
  v85 = result[114];
  v86 = result[115];
  v87 = result[116];
  v88 = result[117];
  v89 = result[118];
  v90 = result[119];
  v91 = result[120];
  v92 = result[121];
  v98 = result[122];
  v97 = result[123];
  v96 = result[124];
  v94 = result[125];
  v95 = result[126];
  v102 = result[127];
  v52 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v23 * v23) + 0.0) + (float)(v24 * v24)) + (float)(v25 * v25)) + (float)(v26 * v26)) + (float)(v27 * v27)) + (float)(v28 * v28)) + (float)(v29 * v29)) + (float)(v30 * v30)) + (float)(v31 * v31)) + (float)(v32 * v32)) + (float)(v33 * v33)) + (float)(v34 * v34)) + (float)(v35 * v35)) + (float)(v36 * v36)) + (float)(v37 * v37)) + (float)(v38 * v38)) + (float)(v39 * v39)) + (float)(v40 * v40)) + (float)(v41 * v41)) + (float)(v42 * v42)) + (float)(v43 * v43)) + (float)(v44 * v44)) + (float)(v45 * v45)) + (float)(v46 * v46)) + (float)(v47 * v47)) + (float)(v48 * v48)) + (float)(v49 * v49)) + (float)(v50 * v50)) + (float)(v99 * v99)) + (float)(v51 * v51)) + (float)(v100 * v100)) + (float)(v101 * v101)) + (float)(v93 * v93)) + (float)(v68 * v68)) + (float)(v69 * v69)) + (float)(v70 * v70)) + (float)(v71 * v71)) + (float)(v72 * v72)) + (float)(v73 * v73)) + (float)(v74 * v74)) + (float)(v75 * v75)) + (float)(v76 * v76)) + (float)(v77 * v77)) + (float)(v78 * v78)) + (float)(v79 * v79)) + (float)(v80 * v80)) + (float)(v81 * v81)) + (float)(v82 * v82)) + (float)(v83 * v83)) + (float)(v84 * v84)) + (float)(v85 * v85)) + (float)(v86 * v86))
                                                                                              + (float)(v87 * v87))
                                                                                      + (float)(v88 * v88))
                                                                              + (float)(v89 * v89))
                                                                      + (float)(v90 * v90))
                                                              + (float)(v91 * v91))
                                                      + (float)(v92 * v92))
                                              + (float)(v98 * v98))
                                      + (float)(v97 * v97))
                              + (float)(v96 * v96))
                      + (float)(v94 * v94))
              + (float)(v95 * v95))
      + (float)(v102 * v102);
  result[517] = v52;
  v53 = 1;
  v54 = result;
  v55 = v17;
  do
  {
    if (v55 < result[v53])
    {
      v55 = result[v53];
      v54 = &result[v53];
    }
    ++v53;
  }
  while (v53 != 64);
  v56 = *v54;
  result[521] = *v54;
  v57 = 1;
  v58 = result;
  do
  {
    if (result[v57] < v17)
    {
      v17 = result[v57];
      v58 = &result[v57];
    }
    ++v57;
  }
  while (v57 != 64);
  if (v56 < (float)-*v58)
    v56 = -*v58;
  v67 = v56;
  if (v23 >= v24)
  {
    v59 = v23;
  }
  else
  {
    v57 = 65;
    v59 = v24;
  }
  if (v59 < v25)
  {
    v59 = v25;
    v57 = 66;
  }
  if (v59 < v26)
  {
    v59 = v26;
    v57 = 67;
  }
  if (v59 < v27)
  {
    v59 = v27;
    v57 = 68;
  }
  if (v59 < v28)
  {
    v59 = v28;
    v57 = 69;
  }
  if (v59 < v29)
  {
    v59 = v29;
    v57 = 70;
  }
  if (v59 < v30)
  {
    v59 = v30;
    v57 = 71;
  }
  if (v59 < v31)
  {
    v59 = v31;
    v57 = 72;
  }
  if (v59 < v32)
  {
    v59 = v32;
    v57 = 73;
  }
  if (v59 < v33)
  {
    v59 = v33;
    v57 = 74;
  }
  if (v59 < v34)
  {
    v59 = v34;
    v57 = 75;
  }
  if (v59 < v35)
  {
    v59 = v35;
    v57 = 76;
  }
  if (v59 < v36)
  {
    v59 = v36;
    v57 = 77;
  }
  if (v59 < v37)
  {
    v59 = v37;
    v57 = 78;
  }
  if (v59 < v38)
  {
    v59 = v38;
    v57 = 79;
  }
  if (v59 < v39)
  {
    v59 = v39;
    v57 = 80;
  }
  if (v59 < v40)
  {
    v59 = v40;
    v57 = 81;
  }
  if (v59 < v41)
  {
    v59 = v41;
    v57 = 82;
  }
  if (v59 < v42)
  {
    v59 = v42;
    v57 = 83;
  }
  if (v59 < v43)
  {
    v59 = v43;
    v57 = 84;
  }
  if (v59 < v44)
  {
    v59 = v44;
    v57 = 85;
  }
  if (v59 < v45)
  {
    v59 = v45;
    v57 = 86;
  }
  if (v59 < v46)
  {
    v59 = v46;
    v57 = 87;
  }
  if (v59 < v47)
  {
    v59 = v47;
    v57 = 88;
  }
  if (v59 < v48)
  {
    v59 = v48;
    v57 = 89;
  }
  if (v59 < v49)
  {
    v59 = v49;
    v57 = 90;
  }
  if (v59 < v50)
  {
    v59 = v50;
    v57 = 91;
  }
  if (v59 < v99)
  {
    v59 = v99;
    v57 = 92;
  }
  if (v59 < v51)
  {
    v59 = v51;
    v57 = 93;
  }
  if (v59 < v100)
  {
    v59 = v100;
    v57 = 94;
  }
  if (v59 < v101)
  {
    v59 = v101;
    v57 = 95;
  }
  if (v59 < v93)
  {
    v59 = v93;
    v57 = 96;
  }
  if (v59 < v68)
  {
    v59 = v68;
    v57 = 97;
  }
  if (v59 < v69)
  {
    v59 = v69;
    v57 = 98;
  }
  if (v59 < v70)
  {
    v59 = v70;
    v57 = 99;
  }
  if (v59 < v71)
  {
    v59 = v71;
    v57 = 100;
  }
  if (v59 < v72)
  {
    v59 = v72;
    v57 = 101;
  }
  if (v59 < v73)
  {
    v59 = v73;
    v57 = 102;
  }
  if (v59 < v74)
  {
    v59 = v74;
    v57 = 103;
  }
  if (v59 < v75)
  {
    v59 = v75;
    v57 = 104;
  }
  if (v59 < v76)
  {
    v59 = v76;
    v57 = 105;
  }
  if (v59 < v77)
  {
    v59 = v77;
    v57 = 106;
  }
  if (v59 < v78)
  {
    v59 = v78;
    v57 = 107;
  }
  if (v59 < v79)
  {
    v59 = v79;
    v57 = 108;
  }
  if (v59 < v80)
  {
    v59 = v80;
    v57 = 109;
  }
  if (v59 < v81)
  {
    v59 = v81;
    v57 = 110;
  }
  if (v59 < v82)
  {
    v59 = v82;
    v57 = 111;
  }
  if (v59 < v83)
  {
    v59 = v83;
    v57 = 112;
  }
  if (v59 < v84)
  {
    v59 = v84;
    v57 = 113;
  }
  if (v59 < v85)
  {
    v59 = v85;
    v57 = 114;
  }
  if (v59 < v86)
  {
    v59 = v86;
    v57 = 115;
  }
  if (v59 < v87)
  {
    v59 = v87;
    v57 = 116;
  }
  if (v59 < v88)
  {
    v59 = v88;
    v57 = 117;
  }
  if (v59 < v89)
  {
    v59 = v89;
    v57 = 118;
  }
  if (v59 < v90)
  {
    v59 = v90;
    v57 = 119;
  }
  if (v59 < v91)
  {
    v59 = v91;
    v57 = 120;
  }
  if (v59 < v92)
  {
    v59 = v92;
    v57 = 121;
  }
  if (v59 < v98)
  {
    v59 = v98;
    v57 = 122;
  }
  v60 = v97;
  if (v59 < v97)
    v57 = 123;
  else
    v60 = v59;
  if (v60 < v96)
  {
    v60 = v96;
    v57 = 124;
  }
  if (v60 >= v94)
    v61 = v60;
  else
    v61 = v94;
  if (v60 < v94)
    v57 = 125;
  if (v61 < v95)
  {
    v61 = v95;
    v57 = 126;
  }
  if (v61 >= v102)
    v62 = v57 * 4;
  else
    v62 = 508;
  v63 = v24;
  if (v24 >= v23)
    v63 = v23;
  v64 = 64;
  if (v24 < v23)
    v64 = 65;
  if (v25 < v63)
  {
    v63 = v25;
    v64 = 66;
  }
  if (v26 < v63)
  {
    v63 = v26;
    v64 = 67;
  }
  if (v27 < v63)
  {
    v63 = v27;
    v64 = 68;
  }
  if (v28 < v63)
  {
    v63 = v28;
    v64 = 69;
  }
  if (v29 < v63)
  {
    v63 = v29;
    v64 = 70;
  }
  if (v30 < v63)
  {
    v63 = v30;
    v64 = 71;
  }
  if (v31 < v63)
  {
    v63 = v31;
    v64 = 72;
  }
  if (v32 < v63)
  {
    v63 = v32;
    v64 = 73;
  }
  if (v33 < v63)
  {
    v63 = v33;
    v64 = 74;
  }
  if (v34 < v63)
  {
    v63 = v34;
    v64 = 75;
  }
  if (v35 < v63)
  {
    v63 = v35;
    v64 = 76;
  }
  if (v36 < v63)
  {
    v63 = v36;
    v64 = 77;
  }
  if (v37 < v63)
  {
    v63 = v37;
    v64 = 78;
  }
  if (v38 < v63)
  {
    v63 = v38;
    v64 = 79;
  }
  if (v39 < v63)
  {
    v63 = v39;
    v64 = 80;
  }
  if (v40 < v63)
  {
    v63 = v40;
    v64 = 81;
  }
  if (v41 < v63)
  {
    v63 = v41;
    v64 = 82;
  }
  if (v42 < v63)
  {
    v63 = v42;
    v64 = 83;
  }
  if (v43 < v63)
  {
    v63 = v43;
    v64 = 84;
  }
  if (v44 < v63)
  {
    v63 = v44;
    v64 = 85;
  }
  if (v45 < v63)
  {
    v63 = v45;
    v64 = 86;
  }
  if (v46 < v63)
  {
    v63 = v46;
    v64 = 87;
  }
  if (v47 < v63)
  {
    v63 = v47;
    v64 = 88;
  }
  if (v48 < v63)
  {
    v63 = v48;
    v64 = 89;
  }
  if (v49 < v63)
  {
    v63 = v49;
    v64 = 90;
  }
  if (v50 < v63)
  {
    v63 = v50;
    v64 = 91;
  }
  if (v99 < v63)
  {
    v63 = v99;
    v64 = 92;
  }
  if (v51 < v63)
  {
    v63 = v51;
    v64 = 93;
  }
  if (v100 < v63)
  {
    v63 = v100;
    v64 = 94;
  }
  if (v101 < v63)
  {
    v63 = v101;
    v64 = 95;
  }
  if (v93 < v63)
  {
    v63 = v93;
    v64 = 96;
  }
  if (v68 < v63)
  {
    v63 = v68;
    v64 = 97;
  }
  if (v69 < v63)
  {
    v64 = 98;
    v63 = v69;
  }
  if (v70 < v63)
    v64 = 99;
  result[521] = v67;
  if (v70 < v63)
    v63 = v70;
  if (v71 < v63)
  {
    v63 = v71;
    v64 = 100;
  }
  if (v72 < v63)
  {
    v63 = v72;
    v64 = 101;
  }
  if (v73 < v63)
  {
    v63 = v73;
    v64 = 102;
  }
  if (v74 < v63)
  {
    v63 = v74;
    v64 = 103;
  }
  if (v75 < v63)
  {
    v63 = v75;
    v64 = 104;
  }
  if (v76 < v63)
  {
    v63 = v76;
    v64 = 105;
  }
  if (v77 < v63)
  {
    v63 = v77;
    v64 = 106;
  }
  if (v78 < v63)
  {
    v63 = v78;
    v64 = 107;
  }
  if (v79 < v63)
  {
    v63 = v79;
    v64 = 108;
  }
  if (v80 < v63)
  {
    v63 = v80;
    v64 = 109;
  }
  if (v81 < v63)
  {
    v63 = v81;
    v64 = 110;
  }
  if (v82 < v63)
  {
    v63 = v82;
    v64 = 111;
  }
  if (v83 < v63)
  {
    v63 = v83;
    v64 = 112;
  }
  if (v84 < v63)
  {
    v63 = v84;
    v64 = 113;
  }
  if (v85 < v63)
  {
    v63 = v85;
    v64 = 114;
  }
  if (v86 < v63)
  {
    v63 = v86;
    v64 = 115;
  }
  if (v87 < v63)
  {
    v63 = v87;
    v64 = 116;
  }
  if (v88 < v63)
  {
    v63 = v88;
    v64 = 117;
  }
  if (v89 < v63)
  {
    v63 = v89;
    v64 = 118;
  }
  if (v90 < v63)
  {
    v63 = v90;
    v64 = 119;
  }
  if (v91 < v63)
  {
    v63 = v91;
    v64 = 120;
  }
  if (v92 < v63)
  {
    v63 = v92;
    v64 = 121;
  }
  if (v98 < v63)
  {
    v63 = v98;
    v64 = 122;
  }
  if (v97 < v63)
  {
    v63 = v97;
    v64 = 123;
  }
  if (v96 < v63)
  {
    v63 = v96;
    v64 = 124;
  }
  if (v94 < v63)
  {
    v63 = v94;
    v64 = 125;
  }
  if (v95 < v63)
  {
    v63 = v95;
    v64 = 126;
  }
  v65 = v102 < v63;
  v66 = *(float *)((char *)result + v62);
  if (v65)
    v64 = 127;
  if (v66 < (float)-result[v64])
    v66 = -result[v64];
  result[522] = v66;
  return result;
}

void dcsctp::SupportedExtensionsParameter::~SupportedExtensionsParameter(dcsctp::SupportedExtensionsParameter *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C0C1B88;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_24C0C1B88;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x20BD0ADECLL);
}

void dcsctp::SupportedExtensionsParameter::SerializeTo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  char *v11;
  unint64_t v12;
  __int16 v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  const void *v17;
  size_t v18;
  BOOL v19;
  std::string *v20;
  uint64_t v21;

  v10 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
  v11 = *(char **)a2;
  v12 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  v13 = v10 + 4;
  v14 = v12 + v10 + 4;
  if (v12 >= v14)
  {
    if (v12 > v14)
      *(_QWORD *)(a2 + 8) = &v11[v14];
  }
  else
  {
    std::vector<unsigned char>::__append((char **)a2, v10 + 4);
    v11 = *(char **)a2;
  }
  v15 = &v11[v12];
  *(_WORD *)v15 = 2176;
  v15[2] = HIBYTE(v13);
  v15[3] = v13;
  if (v10 >= 0xFFFFFFFFFFFFFFFCLL)
  {
    v20 = rtc::webrtc_checks_impl::FatalLog("Source/webrtc/net/dcsctp/packet/bounded_byte_writer.h", 59, "data.size() >= FixedSize", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v21);
    dcsctp::SupportedExtensionsParameter::ToString((dcsctp::SupportedExtensionsParameter *)v20);
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
    if (v16)
      v17 = *(const void **)(a1 + 8);
    else
      v17 = 0;
    if (v10 >= v16)
      v18 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
    else
      v18 = v10;
    if (v17)
      v19 = v18 == 0;
    else
      v19 = 1;
    if (!v19)
      memcpy((void *)(*(_QWORD *)a2 + v12 + 4), v17, v18);
  }
}

void dcsctp::SupportedExtensionsParameter::ToString(dcsctp::SupportedExtensionsParameter *this@<X0>, std::string *a2@<X8>)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  std::string::size_type v9;
  std::string::size_type size;
  std::string *v11;
  std::string::size_type v13;
  size_t v14;
  BOOL v15;
  std::string *p_p_new_stuff;
  std::string::size_type v17;
  std::string::size_type v18;
  std::string *v19;
  char *v20;
  std::string::size_type v21;
  std::string::size_type v22;
  std::string::size_type v23;
  std::string *v24;
  _BYTE *v25;
  std::string::size_type v26;
  std::string __p_new_stuff;
  std::string v28;
  std::string v29;

  memset(&v28, 0, sizeof(v28));
  if (&v28 <= (std::string *)"Supported Extensions ("
    && (char *)&v28.__r_.__value_.__r.__words[2] + 6 > "Supported Extensions (")
  {
    goto LABEL_71;
  }
  strcpy((char *)&v28, "Supported Extensions (");
  *((_BYTE *)&v28.__r_.__value_.__s + 23) = 22;
  v4 = (unsigned __int8 *)*((_QWORD *)this + 1);
  v5 = (unsigned __int8 *)*((_QWORD *)this + 2);
  memset(&v29, 0, sizeof(v29));
  if (v4 != v5)
  {
    v7 = *v4;
    v6 = v4 + 1;
    rtc::StringBuilder::operator<<(&v29, v7);
    if (", ")
    {
      while (v6 != v5)
      {
        if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v9 = 22;
        else
          v9 = (v29.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(v29.__r_.__value_.__r.__words[2]);
        else
          size = v29.__r_.__value_.__l.__size_;
        if (v9 - size < 2)
        {
          std::string::__grow_by_and_replace(&v29, v9, size + 2 - v9, size, size, 0, 2uLL, ", ");
        }
        else
        {
          if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v11 = &v29;
          else
            v11 = (std::string *)v29.__r_.__value_.__r.__words[0];
          if ((char *)v11 + size <= ", " && &v11->__r_.__value_.__s.__data_[size + 2] > ", ")
            goto LABEL_71;
          memmove((char *)v11 + size, ", ", 2uLL);
          v13 = size + 2;
          if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
            v29.__r_.__value_.__l.__size_ = size + 2;
          else
            *((_BYTE *)&v29.__r_.__value_.__s + 23) = v13 & 0x7F;
          v11->__r_.__value_.__s.__data_[v13] = 0;
        }
        v8 = *v6++;
        rtc::StringBuilder::operator<<(&v29, v8);
      }
    }
    else if (v6 != v5)
    {
      goto LABEL_71;
    }
  }
  __p_new_stuff = v29;
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
  {
    v14 = __p_new_stuff.__r_.__value_.__l.__size_;
    if ((__p_new_stuff.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
      goto LABEL_71;
    p_p_new_stuff = (std::string *)__p_new_stuff.__r_.__value_.__r.__words[0];
    v15 = __p_new_stuff.__r_.__value_.__l.__size_ == 0;
    if (__p_new_stuff.__r_.__value_.__l.__size_)
    {
      if (!__p_new_stuff.__r_.__value_.__r.__words[0])
        goto LABEL_71;
    }
  }
  else
  {
    v14 = HIBYTE(v29.__r_.__value_.__r.__words[2]);
    v15 = HIBYTE(v29.__r_.__value_.__r.__words[2]) == 0;
    p_p_new_stuff = &__p_new_stuff;
  }
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = 22;
  else
    v17 = (v28.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v18 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
  else
    v18 = v28.__r_.__value_.__l.__size_;
  if (v17 - v18 >= v14)
  {
    if (!v15)
    {
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v19 = &v28;
      else
        v19 = (std::string *)v28.__r_.__value_.__r.__words[0];
      v20 = (char *)v19 + v18;
      if ((std::string *)((char *)v19 + v18) <= p_p_new_stuff && &v20[v14] > (char *)p_p_new_stuff)
        goto LABEL_71;
      memmove(v20, p_p_new_stuff, v14);
      v21 = v18 + v14;
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
        v28.__r_.__value_.__l.__size_ = v18 + v14;
      else
        *((_BYTE *)&v28.__r_.__value_.__s + 23) = v21 & 0x7F;
      v19->__r_.__value_.__s.__data_[v21] = 0;
    }
  }
  else
  {
    std::string::__grow_by_and_replace(&v28, v17, v18 + v14 - v17, v18, v18, 0, v14, (const std::string::value_type *)p_p_new_stuff);
  }
  v22 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v23 = 22;
  else
    v23 = (v28.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v22 = v28.__r_.__value_.__l.__size_;
  if (v23 == v22)
  {
    std::string::__grow_by_and_replace(&v28, v23, 1uLL, v23, v23, 0, 1uLL, ")");
    if ((SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_60:
      *a2 = v28;
      return;
    }
LABEL_59:
    operator delete(__p_new_stuff.__r_.__value_.__l.__data_);
    goto LABEL_60;
  }
  v24 = &v28;
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v24 = (std::string *)v28.__r_.__value_.__r.__words[0];
  v25 = (char *)v24 + v22;
  if ((char *)v24 + v22 > ")" || v25 + 1 <= ")")
  {
    *v25 = 41;
    v26 = v22 + 1;
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
    {
      v28.__r_.__value_.__l.__size_ = v26;
      v24->__r_.__value_.__s.__data_[v26] = 0;
      if ((SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_60;
    }
    else
    {
      *((_BYTE *)&v28.__r_.__value_.__s + 23) = v26 & 0x7F;
      v24->__r_.__value_.__s.__data_[v26] = 0;
      if ((SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_60;
    }
    goto LABEL_59;
  }
LABEL_71:
  __break(1u);
}

uint64_t webrtc::SuppressionFilter::SuppressionFilter(uint64_t a1, int a2, int a3, unint64_t a4)
{
  size_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  _QWORD *v12;
  int64_t v13;
  uint64_t v14;
  char **v15;
  char *v16;
  char *v17;
  uint64_t v18;
  void **v19;
  _BYTE *v20;
  unint64_t v21;

  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_QWORD *)(a1 + 8) = a4;
  *(_BYTE *)(a1 + 16) = 0;
  if (a4)
  {
    if (HIBYTE(a4))
      goto LABEL_27;
    v6 = a4 << 8;
    v7 = (char *)operator new(a4 << 8);
    v8 = &v7[v6];
    bzero(v7, v6);
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  v9 = 0;
  v10 = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  if ((a3 + 15999) < 0x7CFF)
    goto LABEL_14;
  if (a3 <= -16000)
LABEL_27:
    abort();
  v11 = a3 / 16000;
  v12 = operator new(24 * v11);
  v9 = (char *)v12;
  *(_QWORD *)(a1 + 24) = v12;
  *(_QWORD *)(a1 + 32) = v12;
  v10 = (char *)&v12[3 * v11];
  *(_QWORD *)(a1 + 40) = v10;
  v13 = v8 - v7;
  if (v8 == v7)
  {
    bzero(v12, 24 * ((24 * v11 - 24) / 0x18uLL) + 24);
  }
  else
  {
    if (v13 < 0)
    {
      *v12 = 0;
      v12[1] = 0;
      v12[2] = 0;
      abort();
    }
    v14 = 24 * v11;
    v15 = (char **)(v12 + 1);
    do
    {
      *v15 = 0;
      v15[1] = 0;
      v16 = (char *)operator new(v13);
      *(v15 - 1) = v16;
      v17 = &v16[256 * (v13 >> 8)];
      v15[1] = v17;
      memcpy(v16, v7, v13);
      *v15 = v17;
      v15 += 3;
      v14 -= 24;
    }
    while (v14);
  }
  *(_QWORD *)(a1 + 32) = v10;
LABEL_14:
  if (v7)
  {
    operator delete(v7);
    v9 = *(char **)(a1 + 24);
    v10 = *(char **)(a1 + 32);
  }
  if (v10 != v9)
  {
    if ((unint64_t)((v10 - v9) / 24) <= 1)
      v18 = 1;
    else
      v18 = (v10 - v9) / 24;
    v19 = (void **)(v9 + 8);
    do
    {
      v20 = *(v19 - 1);
      if (*v19 != v20)
      {
        v21 = ((_BYTE *)*v19 - v20) >> 8;
        if (v21 <= 1)
          v21 = 1;
        bzero(v20, v21 << 8);
      }
      v19 += 3;
      --v18;
    }
    while (v18);
  }
  return a1;
}

void webrtc::SuppressionFilter::ApplyGain(_QWORD *a1, uint64_t a2, int32x2_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float32x4_t *a7, uint64_t a8, uint64_t a9, unsigned int *a10)
{
  uint64_t v12;
  int v13;
  unint64_t v14;
  int32x2_t v19;
  float v20;
  __int128 *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  float32x4_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  float32x4_t v41;
  __int128 v42;
  __int128 v43;
  float32x4_t v44;
  float32x4_t v45;
  uint64_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int v63;
  int32x4_t v64;
  int32x4_t v65;
  float *v66;
  float *v67;
  float *v68;
  float *v69;
  float *v70;
  float *v71;
  float *v72;
  float *v73;
  float *v74;
  float *v75;
  float *v76;
  float *v77;
  float *v78;
  float *v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  float32x4_t *v83;
  uint64_t v84;
  float32x4_t *v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  int v104;
  unsigned int v105;
  float32x4_t *v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  __int128 *v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  int32x4_t v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  int32x4_t v139;
  float *v140;
  float *v141;
  float *v142;
  float *v143;
  float *v144;
  float *v145;
  float *v146;
  float *v147;
  float *v148;
  float *v149;
  float *v150;
  float *v151;
  float *v152;
  float *v153;
  unsigned int v154;
  unint64_t v155;
  uint64_t v156;
  unint64_t v157;
  float32x4_t *v158;
  uint64_t v159;
  uint64_t v160;
  int8x16_t v161;
  uint64_t v162;
  unint64_t v163;
  unsigned int v164;
  int v165;
  uint64_t v166;
  int8x16_t v167;
  int8x16_t v168;
  int8x16_t v169;
  int8x16_t v170;
  int8x16_t v171;
  int8x16_t v172;
  int8x16_t v173;
  int8x16_t v174;
  int8x16_t v175;
  int8x16_t v176;
  int8x16_t v177;
  int8x16_t v178;
  int8x16_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  int v188;
  unsigned int v189;
  int v190;
  unint64_t v191;
  __int128 *v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  __int128 v216;
  unint64_t v217;
  uint64_t v218;
  uint64_t *v219;
  uint64_t v220;
  uint64_t v221;
  unint64_t v222;
  unint64_t v223;
  __int128 *v224;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  int v229;
  float32x4_t v230;
  float v231;
  float v233;
  float32x4_t v234;
  float32x4_t v235;
  float32x4_t v236;
  float32x4_t v237;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32x4_t v242;
  float32x4_t v243;
  float32x4_t v244;
  float32x4_t v245;
  float32x4_t v246;
  float32x4_t v247;
  float32x4_t v248;
  float32x4_t v249;
  webrtc::OouraFft *v252;
  float32x4_t v253[2];
  float32x4_t v254[2];
  float32x4_t v255[2];
  float32x4_t v256[2];
  float32x4_t v257[2];
  float32x4_t v258[2];
  float32x4_t v259[2];
  float32x4_t v260[2];
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  _DWORD v267[14];
  int32x4_t v268;
  int32x4_t v269;
  float32x4_t v270[2];
  float32x4_t v271[2];
  float32x4_t v272[2];
  float32x4_t v273[2];
  float32x4_t v274[2];
  float32x4_t v275[2];
  float32x4_t v276[2];
  float32x4_t v277[2];
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  _DWORD v284[14];
  int32x4_t v285;
  int32x4_t v286;
  _BYTE v287[240];
  _BYTE v288[240];
  uint64_t v289;
  float32x4x2_t v290;
  float32x4x2_t v291;
  float32x4x2_t v292;

  v233 = *(float *)a3.i32;
  v289 = *MEMORY[0x24BDAC8D0];
  if (a1[1])
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    __asm { FMOV            V2.4S, #1.0 }
    v249 = vsqrtq_f32(vmlsq_f32(_Q2, *a7, *a7));
    v248 = vsqrtq_f32(vmlsq_f32(_Q2, a7[1], a7[1]));
    v247 = vsqrtq_f32(vmlsq_f32(_Q2, a7[2], a7[2]));
    v246 = vsqrtq_f32(vmlsq_f32(_Q2, a7[3], a7[3]));
    v245 = vsqrtq_f32(vmlsq_f32(_Q2, a7[4], a7[4]));
    v244 = vsqrtq_f32(vmlsq_f32(_Q2, a7[5], a7[5]));
    v243 = vsqrtq_f32(vmlsq_f32(_Q2, a7[6], a7[6]));
    v242 = vsqrtq_f32(vmlsq_f32(_Q2, a7[7], a7[7]));
    v241 = vsqrtq_f32(vmlsq_f32(_Q2, a7[8], a7[8]));
    v240 = vsqrtq_f32(vmlsq_f32(_Q2, a7[9], a7[9]));
    v238 = vsqrtq_f32(vmlsq_f32(_Q2, a7[11], a7[11]));
    v239 = vsqrtq_f32(vmlsq_f32(_Q2, a7[10], a7[10]));
    v236 = vsqrtq_f32(vmlsq_f32(_Q2, a7[13], a7[13]));
    v237 = vsqrtq_f32(vmlsq_f32(_Q2, a7[12], a7[12]));
    v234 = vsqrtq_f32(vmlsq_f32(_Q2, a7[15], a7[15]));
    v235 = vsqrtq_f32(vmlsq_f32(_Q2, a7[14], a7[14]));
    v19 = a3;
    v252 = (webrtc::OouraFft *)(a1 + 2);
    *(float *)v19.i32 = (float)(sqrtf(1.0 - (float)(*(float *)v19.i32 * *(float *)v19.i32)) * 0.4) * 0.015625;
    v231 = *(float *)v19.i32;
    v230 = (float32x4_t)vdupq_lane_s32(v19, 0);
    v20 = sqrtf(1.0 - (float)(a7[16].f32[0] * a7[16].f32[0]));
    do
    {
      v21 = (__int128 *)(a8 + 520 * v14);
      v22 = *v21;
      v23 = v21[1];
      *(_OWORD *)&v288[32] = v21[2];
      *(_OWORD *)&v288[16] = v23;
      *(_OWORD *)v288 = v22;
      v24 = v21[3];
      v25 = v21[4];
      v26 = v21[5];
      *(_OWORD *)&v288[96] = v21[6];
      *(_OWORD *)&v288[80] = v26;
      *(_OWORD *)&v288[64] = v25;
      *(_OWORD *)&v288[48] = v24;
      v27 = v21[7];
      v28 = v21[8];
      v29 = v21[9];
      *(_OWORD *)&v288[160] = v21[10];
      *(_OWORD *)&v288[144] = v29;
      *(_OWORD *)&v288[128] = v28;
      *(_OWORD *)&v288[112] = v27;
      v30 = v21[11];
      v31 = v21[12];
      v32 = v21[13];
      *(_OWORD *)&v288[224] = v21[14];
      *(_OWORD *)&v288[208] = v32;
      *(_OWORD *)&v288[192] = v31;
      *(_OWORD *)&v288[176] = v30;
      v33 = (float32x4_t)v21[15];
      LODWORD(v30) = *((_DWORD *)v21 + 64);
      v21 = (__int128 *)((char *)v21 + 260);
      v34 = v21[5];
      v36 = v21[3];
      v35 = v21[4];
      *(_OWORD *)&v287[96] = v21[6];
      *(_OWORD *)&v287[80] = v34;
      *(_OWORD *)&v287[48] = v36;
      *(_OWORD *)&v287[64] = v35;
      v37 = v21[9];
      v39 = v21[7];
      v38 = v21[8];
      *(_OWORD *)&v287[160] = v21[10];
      *(_OWORD *)&v287[144] = v37;
      *(_OWORD *)&v287[112] = v39;
      *(_OWORD *)&v287[128] = v38;
      v40 = v21[13];
      v42 = v21[11];
      v41 = (float32x4_t)v21[12];
      *(_OWORD *)&v287[224] = v21[14];
      *(_OWORD *)&v287[208] = v40;
      *(_OWORD *)&v287[176] = v42;
      *(float32x4_t *)&v287[192] = v41;
      v43 = *v21;
      v44 = (float32x4_t)v21[1];
      *(_OWORD *)&v287[32] = v21[2];
      *(float32x4_t *)&v287[16] = v44;
      *(_OWORD *)v287 = v43;
      v45 = (float32x4_t)v21[15];
      *(_DWORD *)v287 = 0;
      v46 = a2 + 520 * v14;
      v47 = a7[1];
      v48 = vmulq_f32(*a7, *(float32x4_t *)v287);
      *(float32x4_t *)v288 = vmlaq_f32(vmulq_f32(*(float32x4_t *)v288, *a7), *(float32x4_t *)v46, v249);
      *(float32x4_t *)v287 = vmlaq_f32(v48, *(float32x4_t *)(v46 + 260), v249);
      *(float32x4_t *)&v288[16] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[16], v47), *(float32x4_t *)(v46 + 16), v248);
      *(float32x4_t *)&v287[16] = vmlaq_f32(vmulq_f32(v47, v44), *(float32x4_t *)(v46 + 276), v248);
      v49 = a7[2];
      v50 = a7[3];
      *(float32x4_t *)&v288[32] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[32], v49), *(float32x4_t *)(v46 + 32), v247);
      *(float32x4_t *)&v287[32] = vmlaq_f32(vmulq_f32(v49, *(float32x4_t *)&v287[32]), *(float32x4_t *)(v46 + 292), v247);
      *(float32x4_t *)&v288[48] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[48], v50), *(float32x4_t *)(v46 + 48), v246);
      *(float32x4_t *)&v287[48] = vmlaq_f32(vmulq_f32(v50, *(float32x4_t *)&v287[48]), *(float32x4_t *)(v46 + 308), v246);
      v51 = a7[4];
      v52 = a7[5];
      *(float32x4_t *)&v288[64] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[64], v51), *(float32x4_t *)(v46 + 64), v245);
      *(float32x4_t *)&v287[64] = vmlaq_f32(vmulq_f32(v51, *(float32x4_t *)&v287[64]), *(float32x4_t *)(v46 + 324), v245);
      *(float32x4_t *)&v288[80] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[80], v52), *(float32x4_t *)(v46 + 80), v244);
      *(float32x4_t *)&v287[80] = vmlaq_f32(vmulq_f32(v52, *(float32x4_t *)&v287[80]), *(float32x4_t *)(v46 + 340), v244);
      v53 = a7[6];
      v54 = a7[7];
      *(float32x4_t *)&v288[96] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[96], v53), *(float32x4_t *)(v46 + 96), v243);
      *(float32x4_t *)&v287[96] = vmlaq_f32(vmulq_f32(v53, *(float32x4_t *)&v287[96]), *(float32x4_t *)(v46 + 356), v243);
      *(float32x4_t *)&v288[112] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[112], v54), *(float32x4_t *)(v46 + 112), v242);
      *(float32x4_t *)&v287[112] = vmlaq_f32(vmulq_f32(v54, *(float32x4_t *)&v287[112]), *(float32x4_t *)(v46 + 372), v242);
      v55 = a7[8];
      v56 = a7[9];
      *(float32x4_t *)&v288[128] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[128], v55), *(float32x4_t *)(v46 + 128), v241);
      *(float32x4_t *)&v287[128] = vmlaq_f32(vmulq_f32(v55, *(float32x4_t *)&v287[128]), *(float32x4_t *)(v46 + 388), v241);
      *(float32x4_t *)&v288[144] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[144], v56), *(float32x4_t *)(v46 + 144), v240);
      *(float32x4_t *)&v287[144] = vmlaq_f32(vmulq_f32(v56, *(float32x4_t *)&v287[144]), *(float32x4_t *)(v46 + 404), v240);
      v57 = a7[10];
      v58 = a7[11];
      *(float32x4_t *)&v288[160] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[160], v57), *(float32x4_t *)(v46 + 160), v239);
      *(float32x4_t *)&v287[160] = vmlaq_f32(vmulq_f32(v57, *(float32x4_t *)&v287[160]), *(float32x4_t *)(v46 + 420), v239);
      *(float32x4_t *)&v288[176] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[176], v58), *(float32x4_t *)(v46 + 176), v238);
      *(float32x4_t *)&v287[176] = vmlaq_f32(vmulq_f32(v58, *(float32x4_t *)&v287[176]), *(float32x4_t *)(v46 + 436), v238);
      v59 = a7[12];
      v60 = a7[13];
      *(float32x4_t *)&v288[192] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[192], v59), *(float32x4_t *)(v46 + 192), v237);
      *(float32x4_t *)&v287[192] = vmlaq_f32(vmulq_f32(v59, v41), *(float32x4_t *)(v46 + 452), v237);
      *(float32x4_t *)&v288[208] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[208], v60), *(float32x4_t *)(v46 + 208), v236);
      *(float32x4_t *)&v287[208] = vmlaq_f32(vmulq_f32(v60, *(float32x4_t *)&v287[208]), *(float32x4_t *)(v46 + 468), v236);
      v61 = a7[14];
      v62 = a7[15];
      v63 = (_DWORD)v14 << 6;
      *(float32x4_t *)&v288[224] = vmlaq_f32(vmulq_f32(*(float32x4_t *)&v288[224], v61), *(float32x4_t *)(v46 + 224), v235);
      *(float32x4_t *)&v287[224] = vmlaq_f32(vmulq_f32(v61, *(float32x4_t *)&v287[224]), *(float32x4_t *)(v46 + 484), v235);
      v64 = (int32x4_t)vmlaq_f32(vmulq_f32(v33, v62), *(float32x4_t *)(v46 + 240), v234);
      v65 = (int32x4_t)vmlaq_f32(vmulq_f32(v62, v45), *(float32x4_t *)(v46 + 500), v234);
      *(float *)&v30 = (float)(*(float *)&v30 * a7[16].f32[0]) + (float)(v20 * *(float *)(v46 + 256));
      v44.i32[0] = *(_DWORD *)v288;
      v291.val[0] = *(float32x4_t *)&v288[4];
      v291.val[1] = *(float32x4_t *)&v287[4];
      v66 = &v270[0].f32[2];
      vst2q_f32(v66, v291);
      v291.val[0] = *(float32x4_t *)&v288[20];
      v291.val[1] = *(float32x4_t *)&v287[20];
      v67 = &v271[0].f32[2];
      vst2q_f32(v67, v291);
      v291.val[0] = *(float32x4_t *)&v288[36];
      v291.val[1] = *(float32x4_t *)&v287[36];
      v68 = &v272[0].f32[2];
      vst2q_f32(v68, v291);
      v291.val[0] = *(float32x4_t *)&v288[52];
      v291.val[1] = *(float32x4_t *)&v287[52];
      v69 = &v273[0].f32[2];
      vst2q_f32(v69, v291);
      v291.val[0] = *(float32x4_t *)&v288[68];
      v291.val[1] = *(float32x4_t *)&v287[68];
      v70 = &v274[0].f32[2];
      vst2q_f32(v70, v291);
      v291.val[0] = *(float32x4_t *)&v288[84];
      v291.val[1] = *(float32x4_t *)&v287[84];
      v71 = &v275[0].f32[2];
      vst2q_f32(v71, v291);
      v291.val[0] = *(float32x4_t *)&v288[100];
      v291.val[1] = *(float32x4_t *)&v287[100];
      v72 = &v276[0].f32[2];
      vst2q_f32(v72, v291);
      v291.val[0] = *(float32x4_t *)&v288[116];
      v291.val[1] = *(float32x4_t *)&v287[116];
      v73 = &v277[0].f32[2];
      vst2q_f32(v73, v291);
      v291.val[0] = *(float32x4_t *)&v288[132];
      v291.val[1] = *(float32x4_t *)&v287[132];
      v74 = (float *)&v279;
      vst2q_f32(v74, v291);
      v291.val[0] = *(float32x4_t *)&v288[148];
      v291.val[1] = *(float32x4_t *)&v287[148];
      v75 = (float *)&v280;
      vst2q_f32(v75, v291);
      v291.val[0] = *(float32x4_t *)&v288[164];
      v291.val[1] = *(float32x4_t *)&v287[164];
      v76 = (float *)&v281;
      vst2q_f32(v76, v291);
      v291.val[0] = *(float32x4_t *)&v288[180];
      v291.val[1] = *(float32x4_t *)&v287[180];
      v77 = (float *)&v282;
      vst2q_f32(v77, v291);
      v291.val[0] = *(float32x4_t *)&v288[196];
      v291.val[1] = *(float32x4_t *)&v287[196];
      v78 = (float *)&v283;
      vst2q_f32(v78, v291);
      v291.val[0] = *(float32x4_t *)&v288[212];
      v291.val[1] = *(float32x4_t *)&v287[212];
      v79 = (float *)v284;
      vst2q_f32(v79, v291);
      v270[0].i64[0] = __PAIR64__(v30, v44.u32[0]);
      v284[8] = *(_DWORD *)&v288[228];
      v284[9] = *(_DWORD *)&v287[228];
      v284[10] = *(_DWORD *)&v288[232];
      v284[11] = *(_DWORD *)&v287[232];
      v284[12] = *(_DWORD *)&v288[236];
      v284[13] = *(_DWORD *)&v287[236];
      v285 = vzip1q_s32(v64, v65);
      v286 = vzip2q_s32(v64, v65);
      webrtc::OouraFft::InverseFft(v252, v270[0].f32);
      v80 = *((_QWORD *)a10 + 1);
      if ((int)((_DWORD)v14 << 6) >= (unint64_t)((*((_QWORD *)a10 + 2) - v80) >> 2))
        goto LABEL_44;
      v81 = (uint64_t *)a1[3];
      if ((uint64_t *)a1[4] == v81)
        goto LABEL_44;
      v82 = *v81;
      if (v14 >= (v81[1] - *v81) >> 8)
        goto LABEL_44;
      v83 = (float32x4_t *)(v82 + (v14 << 8));
      v84 = 4 * v63 + v80;
      if (v84 - (v14 << 8) - v82 < 0x20 || (unint64_t)(v84 - (_QWORD)v270) <= 0x1F)
      {
        v96 = 0;
        v97 = v80 + 4 * v13;
        v98 = v82 + v12;
        do
        {
          *(float *)(v97 + v96) = (float)((float)(*(float *)(v98 + v96)
                                                           + v96
                                                           + 256))
                                        + (float)(v270[0].f32[v96 / 4]
                                * 0.015625;
          v96 += 4;
        }
        while (v96 != 256);
      }
      else
      {
        v85 = (float32x4_t *)(v80 + 4 * v63);
        v86 = (float32x4_t)vdupq_n_s32(0x3C800000u);
        v87 = vmulq_f32(vmlaq_f32(vmulq_f32(v83[1], (float32x4_t)xmmword_208F1C260), (float32x4_t)xmmword_208F1C280, v270[1]), v86);
        *v85 = vmulq_f32(vmlaq_f32(vmulq_f32(*v83, (float32x4_t)xmmword_208F1C250), (float32x4_t)xmmword_208F1C270, v270[0]), v86);
        v85[1] = v87;
        v88 = vmulq_f32(vmlaq_f32(vmulq_f32(v83[3], (float32x4_t)xmmword_208F1C2A0), (float32x4_t)xmmword_208F1C2C0, v271[1]), v86);
        v85[2] = vmulq_f32(vmlaq_f32(vmulq_f32(v83[2], (float32x4_t)xmmword_208F1C290), (float32x4_t)xmmword_208F1C2B0, v271[0]), v86);
        v85[3] = v88;
        v89 = vmulq_f32(vmlaq_f32(vmulq_f32(v83[5], (float32x4_t)xmmword_208F1C2E0), (float32x4_t)xmmword_208F1C300, v272[1]), v86);
        v85[4] = vmulq_f32(vmlaq_f32(vmulq_f32(v83[4], (float32x4_t)xmmword_208F1C2D0), (float32x4_t)xmmword_208F1C2F0, v272[0]), v86);
        v85[5] = v89;
        v90 = vmulq_f32(vmlaq_f32(vmulq_f32(v83[7], (float32x4_t)xmmword_208F1C320), (float32x4_t)xmmword_208F1C340, v273[1]), v86);
        v85[6] = vmulq_f32(vmlaq_f32(vmulq_f32(v83[6], (float32x4_t)xmmword_208F1C310), (float32x4_t)xmmword_208F1C330, v273[0]), v86);
        v85[7] = v90;
        v91 = vmulq_f32(vmlaq_f32(vmulq_f32(v83[9], (float32x4_t)xmmword_208F1C360), (float32x4_t)xmmword_208F1C380, v274[1]), v86);
        v85[8] = vmulq_f32(vmlaq_f32(vmulq_f32(v83[8], (float32x4_t)xmmword_208F1C350), (float32x4_t)xmmword_208F1C370, v274[0]), v86);
        v85[9] = v91;
        v92 = vmulq_f32(vmlaq_f32(vmulq_f32(v83[11], (float32x4_t)xmmword_208F1C3A0), (float32x4_t)xmmword_208F1C3C0, v275[1]), v86);
        v85[10] = vmulq_f32(vmlaq_f32(vmulq_f32(v83[10], (float32x4_t)xmmword_208F1C390), (float32x4_t)xmmword_208F1C3B0, v275[0]), v86);
        v85[11] = v92;
        v93 = vmulq_f32(vmlaq_f32(vmulq_f32(v83[13], (float32x4_t)xmmword_208F1C3E0), (float32x4_t)xmmword_208F1C400, v276[1]), v86);
        v85[12] = vmulq_f32(vmlaq_f32(vmulq_f32(v83[12], (float32x4_t)xmmword_208F1C3D0), (float32x4_t)xmmword_208F1C3F0, v276[0]), v86);
        v85[13] = v93;
        v94 = vmulq_f32(vmlaq_f32(vmulq_f32(v83[14], (float32x4_t)xmmword_208F1C410), (float32x4_t)xmmword_208F1C430, v277[0]), v86);
        v95 = vmulq_f32(vmlaq_f32(vmulq_f32(v83[15], (float32x4_t)xmmword_208F1C420), (float32x4_t)xmmword_208F1C440, v277[1]), v86);
        v85[14] = v94;
        v85[15] = v95;
      }
      memmove(v83, &v278, 0x100uLL);
      v99 = *a10;
      if ((int)v99 <= 1)
      {
        v161.i64[0] = 0xC7000000C7000000;
        v161.i64[1] = 0xC7000000C7000000;
      }
      else
      {
        v100 = a10[1];
        v101 = *((_QWORD *)a10 + 1);
        v102 = (*((_QWORD *)a10 + 2) - v101) >> 2;
        v103 = v99 - 1;
        v104 = (v100 + (_DWORD)v14) << 6;
        v105 = v100 << 6;
        do
        {
          if (v102 <= v104)
            goto LABEL_44;
          v106 = (float32x4_t *)(v101 + 4 * v104);
          v107 = vmulq_n_f32(v106[1], v233);
          *v106 = vmulq_n_f32(*v106, v233);
          v106[1] = v107;
          v108 = vmulq_n_f32(v106[3], v233);
          v106[2] = vmulq_n_f32(v106[2], v233);
          v106[3] = v108;
          v109 = vmulq_n_f32(v106[5], v233);
          v106[4] = vmulq_n_f32(v106[4], v233);
          v106[5] = v109;
          v110 = vmulq_n_f32(v106[7], v233);
          v106[6] = vmulq_n_f32(v106[6], v233);
          v106[7] = v110;
          v111 = vmulq_n_f32(v106[9], v233);
          v106[8] = vmulq_n_f32(v106[8], v233);
          v106[9] = v111;
          v112 = vmulq_n_f32(v106[11], v233);
          v106[10] = vmulq_n_f32(v106[10], v233);
          v106[11] = v112;
          v113 = vmulq_n_f32(v106[13], v233);
          v106[12] = vmulq_n_f32(v106[12], v233);
          v106[13] = v113;
          v114 = vmulq_n_f32(v106[15], v233);
          v104 += v105;
          v106[14] = vmulq_n_f32(v106[14], v233);
          v106[15] = v114;
          --v103;
        }
        while (v103);
        v115 = (__int128 *)(a5 + 520 * v14);
        v116 = *v115;
        v117 = v115[1];
        *(_OWORD *)&v288[32] = v115[2];
        *(_OWORD *)&v288[16] = v117;
        *(_OWORD *)v288 = v116;
        v118 = v115[3];
        v119 = v115[4];
        v120 = v115[5];
        *(_OWORD *)&v288[96] = v115[6];
        *(_OWORD *)&v288[80] = v120;
        *(_OWORD *)&v288[64] = v119;
        *(_OWORD *)&v288[48] = v118;
        v121 = v115[7];
        v122 = v115[8];
        v123 = v115[9];
        *(_OWORD *)&v288[160] = v115[10];
        *(_OWORD *)&v288[144] = v123;
        *(_OWORD *)&v288[128] = v122;
        *(_OWORD *)&v288[112] = v121;
        v124 = v115[11];
        v125 = v115[12];
        v126 = v115[13];
        *(_OWORD *)&v288[224] = v115[14];
        *(_OWORD *)&v288[208] = v126;
        *(_OWORD *)&v288[192] = v125;
        *(_OWORD *)&v288[176] = v124;
        v127 = (int32x4_t)v115[15];
        LODWORD(v125) = *((_DWORD *)v115 + 64);
        v115 = (__int128 *)((char *)v115 + 260);
        v128 = v115[5];
        v130 = v115[3];
        v129 = v115[4];
        *(_OWORD *)&v287[96] = v115[6];
        *(_OWORD *)&v287[80] = v128;
        *(_OWORD *)&v287[48] = v130;
        *(_OWORD *)&v287[64] = v129;
        v131 = v115[9];
        v133 = v115[7];
        v132 = v115[8];
        *(_OWORD *)&v287[160] = v115[10];
        *(_OWORD *)&v287[144] = v131;
        *(_OWORD *)&v287[112] = v133;
        *(_OWORD *)&v287[128] = v132;
        v134 = v115[13];
        v136 = v115[11];
        v135 = v115[12];
        *(_OWORD *)&v287[224] = v115[14];
        *(_OWORD *)&v287[208] = v134;
        *(_OWORD *)&v287[176] = v136;
        *(_OWORD *)&v287[192] = v135;
        v137 = *v115;
        v138 = v115[1];
        *(_OWORD *)&v287[32] = v115[2];
        *(_OWORD *)&v287[16] = v138;
        *(_OWORD *)v287 = v137;
        v139 = (int32x4_t)v115[15];
        *(_DWORD *)v287 = 0;
        v290.val[0] = *(float32x4_t *)&v288[4];
        v290.val[1] = *(float32x4_t *)&v287[4];
        v140 = &v253[0].f32[2];
        vst2q_f32(v140, v290);
        v290.val[0] = *(float32x4_t *)&v288[20];
        v290.val[1] = *(float32x4_t *)&v287[20];
        v141 = &v254[0].f32[2];
        vst2q_f32(v141, v290);
        v290.val[0] = *(float32x4_t *)&v288[36];
        v290.val[1] = *(float32x4_t *)&v287[36];
        v142 = &v255[0].f32[2];
        vst2q_f32(v142, v290);
        v290.val[0] = *(float32x4_t *)&v288[52];
        v290.val[1] = *(float32x4_t *)&v287[52];
        v143 = &v256[0].f32[2];
        vst2q_f32(v143, v290);
        v290.val[0] = *(float32x4_t *)&v288[68];
        v290.val[1] = *(float32x4_t *)&v287[68];
        v144 = &v257[0].f32[2];
        vst2q_f32(v144, v290);
        v290.val[0] = *(float32x4_t *)&v288[84];
        v290.val[1] = *(float32x4_t *)&v287[84];
        v145 = &v258[0].f32[2];
        vst2q_f32(v145, v290);
        v290.val[0] = *(float32x4_t *)&v288[100];
        v290.val[1] = *(float32x4_t *)&v287[100];
        v146 = &v259[0].f32[2];
        vst2q_f32(v146, v290);
        v290.val[0] = *(float32x4_t *)&v288[116];
        v290.val[1] = *(float32x4_t *)&v287[116];
        v147 = &v260[0].f32[2];
        vst2q_f32(v147, v290);
        v290.val[0] = *(float32x4_t *)&v288[132];
        v290.val[1] = *(float32x4_t *)&v287[132];
        v148 = (float *)&v262;
        vst2q_f32(v148, v290);
        v290.val[0] = *(float32x4_t *)&v288[148];
        v290.val[1] = *(float32x4_t *)&v287[148];
        v149 = (float *)&v263;
        vst2q_f32(v149, v290);
        v290.val[0] = *(float32x4_t *)&v288[164];
        v290.val[1] = *(float32x4_t *)&v287[164];
        v150 = (float *)&v264;
        vst2q_f32(v150, v290);
        v290.val[0] = *(float32x4_t *)&v288[180];
        v290.val[1] = *(float32x4_t *)&v287[180];
        v151 = (float *)&v265;
        vst2q_f32(v151, v290);
        v290.val[0] = *(float32x4_t *)&v288[196];
        v290.val[1] = *(float32x4_t *)&v287[196];
        v152 = (float *)&v266;
        vst2q_f32(v152, v290);
        v253[0].i64[0] = __PAIR64__(v125, *(unsigned int *)v288);
        v267[8] = *(_DWORD *)&v288[228];
        v267[9] = *(_DWORD *)&v287[228];
        v267[10] = *(_DWORD *)&v288[232];
        v292.val[0] = *(float32x4_t *)&v288[212];
        v292.val[1] = *(float32x4_t *)&v287[212];
        v267[11] = *(_DWORD *)&v287[232];
        v267[12] = *(_DWORD *)&v288[236];
        v267[13] = *(_DWORD *)&v287[236];
        v268 = vzip1q_s32(v127, v139);
        v269 = vzip2q_s32(v127, v139);
        v153 = (float *)v267;
        vst2q_f32(v153, v292);
        webrtc::OouraFft::InverseFft(v252, v253[0].f32);
        v154 = a10[1];
        v155 = (int)((v154 + (_DWORD)v14) << 6);
        v156 = *((_QWORD *)a10 + 1);
        v157 = (*((_QWORD *)a10 + 2) - v156) >> 2;
        if (v157 <= v155)
          goto LABEL_44;
        v158 = (float32x4_t *)(v156 + 4 * v155);
        if (v158 >= (float32x4_t *)&v261 || v253 >= &v158[16])
        {
          v180 = vmlaq_f32(v158[1], v230, v253[1]);
          *v158 = vmlaq_f32(*v158, v230, v253[0]);
          v158[1] = v180;
          v181 = vmlaq_f32(v158[3], v230, v254[1]);
          v158[2] = vmlaq_f32(v158[2], v230, v254[0]);
          v158[3] = v181;
          v182 = vmlaq_f32(v158[5], v230, v255[1]);
          v158[4] = vmlaq_f32(v158[4], v230, v255[0]);
          v158[5] = v182;
          v183 = vmlaq_f32(v158[7], v230, v256[1]);
          v158[6] = vmlaq_f32(v158[6], v230, v256[0]);
          v158[7] = v183;
          v184 = vmlaq_f32(v158[9], v230, v257[1]);
          v158[8] = vmlaq_f32(v158[8], v230, v257[0]);
          v158[9] = v184;
          v185 = vmlaq_f32(v158[11], v230, v258[1]);
          v158[10] = vmlaq_f32(v158[10], v230, v258[0]);
          v158[11] = v185;
          v186 = vmlaq_f32(v158[13], v230, v259[1]);
          v158[12] = vmlaq_f32(v158[12], v230, v259[0]);
          v158[13] = v186;
          v187 = vmlaq_f32(v158[15], v230, v260[1]);
          v158[14] = vmlaq_f32(v158[14], v230, v260[0]);
          v158[15] = v187;
          v161.i64[0] = 0xC7000000C7000000;
          v161.i64[1] = 0xC7000000C7000000;
          v99 = *a10;
          if ((int)v99 > 1)
            goto LABEL_30;
        }
        else
        {
          v159 = 0;
          v161.i64[0] = 0xC7000000C7000000;
          v161.i64[1] = 0xC7000000C7000000;
          do
          {
            v160 = v156 + 4 * (int)((v154 + (_DWORD)v14) << 6);
            *(float *)(v160 + v159 * 4) = *(float *)(v160 + v159 * 4) + (float)(v253[0].f32[v159] * v231);
            ++v159;
          }
          while (v159 != 64);
          v99 = *a10;
          if ((int)v99 > 1)
          {
LABEL_30:
            v188 = 0;
            v189 = v154 << 6;
            v190 = (v154 + (_DWORD)v14) << 6;
            v191 = 1;
            while (1)
            {
              v217 = (int)(((_DWORD)v14 + (_DWORD)v191 * v154) << 6);
              if (v157 <= v217)
                break;
              v218 = a1[3];
              if (0xAAAAAAAAAAAAAAABLL * ((a1[4] - v218) >> 3) <= v191)
                break;
              v219 = (uint64_t *)(v218 + 24 * v191);
              v220 = *v219;
              if (v14 >= (v219[1] - *v219) >> 8)
                break;
              v221 = 4 * (int)(v155 + v189 * v188);
              v222 = v156 + v221;
              v223 = v156 + 256 + v221;
              v224 = (__int128 *)(v220 + (v14 << 8));
              if (v222 >= v220 + (v14 << 8) + 256 || (unint64_t)v224 >= v223)
              {
                v192 = (__int128 *)(v156 + 4 * v217);
                v193 = *v192;
                v194 = v192[1];
                v195 = v224[1];
                *v192 = *v224;
                v192[1] = v195;
                *v224 = v193;
                v224[1] = v194;
                v196 = v192[2];
                v197 = v192[3];
                v198 = v224[3];
                v192[2] = v224[2];
                v192[3] = v198;
                v224[2] = v196;
                v224[3] = v197;
                v199 = v192[4];
                v200 = v192[5];
                v201 = v224[5];
                v192[4] = v224[4];
                v192[5] = v201;
                v224[4] = v199;
                v224[5] = v200;
                v202 = v192[6];
                v203 = v192[7];
                v204 = v224[7];
                v192[6] = v224[6];
                v192[7] = v204;
                v224[6] = v202;
                v224[7] = v203;
                v205 = v192[8];
                v206 = v192[9];
                v207 = v224[9];
                v192[8] = v224[8];
                v192[9] = v207;
                v224[8] = v205;
                v224[9] = v206;
                v208 = v192[10];
                v209 = v192[11];
                v210 = v224[11];
                v192[10] = v224[10];
                v192[11] = v210;
                v224[10] = v208;
                v224[11] = v209;
                v211 = v192[12];
                v212 = v192[13];
                v213 = v224[13];
                v192[12] = v224[12];
                v192[13] = v213;
                v224[12] = v211;
                v224[13] = v212;
                v214 = v192[14];
                v215 = v192[15];
                v216 = v224[15];
                v192[14] = v224[14];
                v192[15] = v216;
                v224[14] = v214;
                v224[15] = v215;
              }
              else
              {
                v226 = 0;
                v227 = v156 + 4 * v190;
                v228 = v220 + v12;
                do
                {
                  v229 = *(_DWORD *)(v227 + v226);
                  *(_DWORD *)(v227 + v226) = *(_DWORD *)(v228 + v226);
                  *(_DWORD *)(v228 + v226) = v229;
                  v226 += 4;
                }
                while (v226 != 256);
              }
              ++v191;
              ++v188;
              v190 += v189;
              if (v191 == v99)
                goto LABEL_24;
            }
LABEL_44:
            __break(1u);
          }
        }
      }
LABEL_24:
      if ((int)v99 >= 1)
      {
        v162 = *((_QWORD *)a10 + 1);
        v163 = (*((_QWORD *)a10 + 2) - v162) >> 2;
        v164 = a10[1] << 6;
        v165 = v13;
        while (v163 > v165)
        {
          v166 = v162 + 4 * v165;
          v167 = (int8x16_t)vdupq_n_s32(0x46FFFE00u);
          v168 = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 16)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 16), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 16)));
          v169 = *(int8x16_t *)(v166 + 32);
          v170 = *(int8x16_t *)(v166 + 48);
          *(int8x16_t *)v166 = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)v166), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)v166, (float32x4_t)v167), v167, *(int8x16_t *)v166));
          *(int8x16_t *)(v166 + 16) = v168;
          *(int8x16_t *)(v166 + 32) = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, (float32x4_t)v169), v161, vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v169, (float32x4_t)v167), v167, v169));
          *(int8x16_t *)(v166 + 48) = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, (float32x4_t)v170), v161, vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v170, (float32x4_t)v167), v167, v170));
          v171 = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 80)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 80), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 80)));
          *(int8x16_t *)(v166 + 64) = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 64)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 64), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 64)));
          *(int8x16_t *)(v166 + 80) = v171;
          v172 = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 112)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 112), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 112)));
          *(int8x16_t *)(v166 + 96) = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 96)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 96), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 96)));
          *(int8x16_t *)(v166 + 112) = v172;
          v173 = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 144)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 144), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 144)));
          *(int8x16_t *)(v166 + 128) = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 128)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 128), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 128)));
          *(int8x16_t *)(v166 + 144) = v173;
          v174 = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 176)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 176), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 176)));
          *(int8x16_t *)(v166 + 160) = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 160)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 160), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 160)));
          *(int8x16_t *)(v166 + 176) = v174;
          v175 = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 208)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 208), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 208)));
          *(int8x16_t *)(v166 + 192) = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 192)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 192), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 192)));
          *(int8x16_t *)(v166 + 208) = v175;
          v176 = *(int8x16_t *)(v166 + 224);
          v177 = (int8x16_t)vcgeq_f32((float32x4_t)v161, (float32x4_t)v176);
          v178 = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v176, (float32x4_t)v167), v167, v176);
          v179 = vbslq_s8((int8x16_t)vcgeq_f32((float32x4_t)v161, *(float32x4_t *)(v166 + 240)), v161, vbslq_s8((int8x16_t)vcgeq_f32(*(float32x4_t *)(v166 + 240), (float32x4_t)v167), v167, *(int8x16_t *)(v166 + 240)));
          *(int8x16_t *)(v166 + 224) = vbslq_s8(v177, v161, v178);
          *(int8x16_t *)(v166 + 240) = v179;
          v165 += v164;
          if (!--v99)
            goto LABEL_3;
        }
        goto LABEL_44;
      }
LABEL_3:
      ++v14;
      v13 += 64;
      v12 += 256;
    }
    while (v14 < a1[1]);
  }
}

uint64_t webrtc::SuppressionGain::SuppressionGain(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  size_t v47;
  int32x2_t v48;
  int32x2_t v49;
  int32x2_t v50;
  int32x2_t v51;
  int32x2_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  float v56;
  int64x2_t v57;
  int64x2_t v58;
  int32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float v64;
  int64x2_t v65;
  int64x2_t v66;
  int64x2_t v67;
  int32x4_t v68;
  int32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float v77;
  uint64_t v78;
  float v79;
  float v80;
  int32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float v86;
  int64x2_t v87;
  int64x2_t v88;
  int32x4_t v89;
  int32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  int64x2_t v94;
  float v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v99;
  _QWORD *v100;
  unint64_t v101;
  size_t v102;
  char *v103;
  char *v104;
  char *v105;
  char *v106;
  _QWORD v107[2];
  float v108;
  void *__p;
  void *v110;
  char *v111;
  uint64_t v112;

  v9 = (_QWORD *)(a1 + 1772);
  v10 = a1 + 500;
  v11 = operator new();
  do
    v12 = __ldaxr((unsigned int *)&webrtc::SuppressionGain::instance_count_);
  while (__stlxr(v12 + 1, (unsigned int *)&webrtc::SuppressionGain::instance_count_));
  *(_QWORD *)a1 = v11;
  *(_DWORD *)(a1 + 8) = a3;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
  v14 = *(_OWORD *)(a2 + 80);
  v13 = *(_OWORD *)(a2 + 96);
  v15 = *(_OWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 128) = *(_BYTE *)(a2 + 112);
  *(_OWORD *)(a1 + 96) = v14;
  *(_OWORD *)(a1 + 112) = v13;
  *(_OWORD *)(a1 + 80) = v15;
  v16 = *(_OWORD *)(a2 + 16);
  v17 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 64) = v17;
  *(_OWORD *)(a1 + 32) = v16;
  v18 = *(_OWORD *)(a2 + 168);
  v19 = *(_OWORD *)(a2 + 184);
  v20 = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 216) = v20;
  *(_OWORD *)(a1 + 200) = v19;
  *(_OWORD *)(a1 + 184) = v18;
  v21 = *(_OWORD *)(a2 + 232);
  v22 = *(_OWORD *)(a2 + 248);
  v23 = *(_OWORD *)(a2 + 264);
  *(_OWORD *)(a1 + 232) = *(_OWORD *)(a2 + 216);
  *(_OWORD *)(a1 + 280) = v23;
  *(_OWORD *)(a1 + 264) = v22;
  *(_OWORD *)(a1 + 248) = v21;
  v25 = *(_OWORD *)(a2 + 296);
  v24 = *(_OWORD *)(a2 + 312);
  v26 = *(_OWORD *)(a2 + 280);
  *(_QWORD *)(a1 + 342) = *(_QWORD *)(a2 + 326);
  *(_OWORD *)(a1 + 312) = v25;
  *(_OWORD *)(a1 + 328) = v24;
  *(_OWORD *)(a1 + 296) = v26;
  v27 = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 136) = v27;
  v28 = *(_OWORD *)(a2 + 336);
  v29 = *(_OWORD *)(a2 + 352);
  *(_OWORD *)(a1 + 377) = *(_OWORD *)(a2 + 361);
  *(_OWORD *)(a1 + 352) = v28;
  *(_OWORD *)(a1 + 368) = v29;
  *(_DWORD *)(a1 + 400) = *(_DWORD *)(a2 + 384);
  *(_QWORD *)(a1 + 408) = *(_QWORD *)(a2 + 392);
  v30 = *(_QWORD *)(a2 + 400);
  *(_DWORD *)(a1 + 424) = *(_DWORD *)(a2 + 408);
  *(_QWORD *)(a1 + 416) = v30;
  v31 = *(_QWORD *)(a2 + 412);
  *(_DWORD *)(a1 + 436) = *(_DWORD *)(a2 + 420);
  *(_QWORD *)(a1 + 428) = v31;
  *(_QWORD *)(a1 + 440) = *(_QWORD *)(a2 + 424);
  v32 = *(_QWORD *)(a2 + 432);
  *(_DWORD *)(a1 + 456) = *(_DWORD *)(a2 + 440);
  *(_QWORD *)(a1 + 448) = v32;
  v33 = *(_QWORD *)(a2 + 444);
  *(_DWORD *)(a1 + 468) = *(_DWORD *)(a2 + 452);
  *(_QWORD *)(a1 + 460) = v33;
  *(_QWORD *)(a1 + 472) = *(_QWORD *)(a2 + 456);
  v34 = *(_OWORD *)(a2 + 464);
  v35 = *(_OWORD *)(a2 + 480);
  v36 = *(_OWORD *)(a2 + 512);
  *(_OWORD *)(a1 + 512) = *(_OWORD *)(a2 + 496);
  *(_OWORD *)(a1 + 528) = v36;
  *(_OWORD *)(a1 + 480) = v34;
  *(_OWORD *)(a1 + 496) = v35;
  v37 = *(_OWORD *)(a2 + 528);
  v38 = *(_OWORD *)(a2 + 544);
  v39 = *(_OWORD *)(a2 + 560);
  *(_OWORD *)(a1 + 585) = *(_OWORD *)(a2 + 569);
  *(_OWORD *)(a1 + 560) = v38;
  *(_OWORD *)(a1 + 576) = v39;
  *(_OWORD *)(a1 + 544) = v37;
  *(_OWORD *)(a1 + 608) = *(_OWORD *)(a2 + 592);
  *(_QWORD *)(a1 + 624) = a5;
  *(_DWORD *)(a1 + 632) = *(_QWORD *)(a1 + 232);
  *(_QWORD *)(a1 + 904) = 0;
  *(_QWORD *)(a1 + 912) = 0;
  *(_QWORD *)(a1 + 896) = 0;
  if (a5)
  {
    if (a5 >= 0xFC0FC0FC0FC0FDLL)
      goto LABEL_32;
    v40 = (char *)operator new(260 * a5);
    *(_QWORD *)(a1 + 896) = v40;
    v41 = &v40[260 * a5];
    *(_QWORD *)(a1 + 912) = v41;
    bzero(v40, 260 * ((260 * a5 - 260) / 0x104) + 260);
    *(_QWORD *)(a1 + 904) = v41;
    v42 = (char *)operator new(260 * a5);
    *(_QWORD *)(a1 + 920) = v42;
    v43 = &v42[260 * a5];
    *(_QWORD *)(a1 + 936) = v43;
    bzero(v42, 260 * ((260 * a5 - 260) / 0x104) + 260);
    *(_QWORD *)(a1 + 928) = v43;
  }
  else
  {
    *(_QWORD *)(a1 + 936) = 0;
    *(_OWORD *)(a1 + 920) = 0u;
  }
  *(_DWORD *)(a1 + 944) = 1317011456;
  *(_BYTE *)(a1 + 948) = 1;
  *(_DWORD *)(a1 + 952) = 0;
  v44 = *(_QWORD *)(a2 + 392);
  v108 = 1.0 / (float)v44;
  v110 = 0;
  v111 = 0;
  __p = 0;
  v45 = v44 - 1;
  v107[0] = 65;
  v107[1] = v45;
  if (v45)
  {
    v46 = 65 * v45;
    if ((65 * v45) >> 62)
      goto LABEL_32;
    v47 = 260 * v45;
    __p = operator new(260 * v45);
    v111 = (char *)__p + 4 * v46;
    bzero(__p, v47);
    v110 = v111;
  }
  v112 = 0;
  std::vector<webrtc::aec3::MovingAverage>::vector((char **)(a1 + 960), a5, (uint64_t)v107);
  if (__p)
  {
    v110 = __p;
    operator delete(__p);
  }
  v53 = 0;
  v54 = *(int *)(a1 + 492);
  v55 = *(int *)(a1 + 496);
  *(_QWORD *)(a1 + 984) = *(_QWORD *)(a1 + 472);
  *(float *)v48.i32 = (float)((int)v55 - (int)v54);
  v49.i32[0] = *(_DWORD *)(a1 + 448);
  v52.i32[0] = *(_DWORD *)(a1 + 460);
  v50.i32[0] = *(_DWORD *)(a1 + 452);
  v56 = *(float *)(a1 + 464);
  v51.i32[0] = *(_DWORD *)(a1 + 456);
  v57 = vdupq_n_s64(v54);
  v58 = vdupq_n_s64(v55);
  v59 = vdupq_n_s32(v54);
  v60 = (float32x4_t)vdupq_lane_s32(v48, 0);
  v61 = (float32x4_t)vdupq_lane_s32(v49, 0);
  v62 = (float32x4_t)vdupq_lane_s32(v50, 0);
  v63 = (float32x4_t)vdupq_lane_s32(v51, 0);
  v64 = *(float *)(a1 + 468);
  v65 = (int64x2_t)xmmword_208F08AD0;
  v66 = (int64x2_t)xmmword_208F05120;
  v67 = vdupq_n_s64(4uLL);
  v68 = (int32x4_t)xmmword_208F071C0;
  __asm { FMOV            V0.4S, #1.0 }
  v74.i64[0] = 0x400000004;
  v74.i64[1] = 0x400000004;
  do
  {
    v75 = (float32x4_t)vandq_s8(vbslq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_s64(v58, v66), (int32x4_t)vcgtq_s64(v58, v65)), (int8x16_t)vdivq_f32(vcvtq_f32_s32(vsubq_s32(v68, v59)), v60), _Q0), (int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_s64(v66, v57), (int32x4_t)vcgtq_s64(v65, v57)));
    v76 = vsubq_f32((float32x4_t)_Q0, v75);
    *(float32x4_t *)(a1 + v53 + 992) = vmlaq_f32(vmulq_n_f32(v75, *(float *)v52.i32), v61, v76);
    *(float32x4_t *)(a1 + v53 + 1252) = vmlaq_f32(vmulq_n_f32(v75, v56), v62, v76);
    *(float32x4_t *)(a1 + v53 + 1512) = vmlaq_f32(vmulq_n_f32(v75, v64), v63, v76);
    v65 = vaddq_s64(v65, v67);
    v66 = vaddq_s64(v66, v67);
    v68 = vaddq_s32(v68, v74);
    v53 += 16;
  }
  while (v53 != 256);
  v77 = 0.0;
  if ((int)v54 <= 63)
  {
    v77 = 1.0;
    if ((int)v55 >= 65)
      v77 = (float)(64 - (int)v54) / *(float *)v48.i32;
  }
  v78 = 0;
  *v9 = *(_QWORD *)(a1 + 440);
  *(float *)(a1 + 1248) = (float)(*(float *)v52.i32 * v77) + (float)((float)(1.0 - v77) * *(float *)v49.i32);
  *(float *)(a1 + 1508) = (float)(v56 * v77) + (float)((float)(1.0 - v77) * *(float *)v50.i32);
  *(float *)(a1 + 1768) = (float)(v64 * v77) + (float)((float)(1.0 - v77) * *(float *)v51.i32);
  v52.i32[0] = *(_DWORD *)(a1 + 416);
  v79 = *(float *)(a1 + 428);
  v50.i32[0] = *(_DWORD *)(a1 + 420);
  v80 = *(float *)(a1 + 432);
  v49.i32[0] = *(_DWORD *)(a1 + 424);
  v81 = vdupq_n_s32(v54);
  v82 = (float32x4_t)vdupq_lane_s32(v48, 0);
  v83 = (float32x4_t)vdupq_lane_s32(v52, 0);
  v84 = (float32x4_t)vdupq_lane_s32(v50, 0);
  v85 = (float32x4_t)vdupq_lane_s32(v49, 0);
  v86 = *(float *)(a1 + 436);
  v87 = (int64x2_t)xmmword_208F08AD0;
  v88 = (int64x2_t)xmmword_208F05120;
  v89 = (int32x4_t)xmmword_208F071C0;
  v90.i64[0] = 0x400000004;
  v90.i64[1] = 0x400000004;
  do
  {
    v91 = (float32x4_t)vandq_s8(vbslq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_s64(v58, v88), (int32x4_t)vcgtq_s64(v58, v87)), (int8x16_t)vdivq_f32(vcvtq_f32_s32(vsubq_s32(v89, v81)), v82), _Q0), (int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_s64(v88, v57), (int32x4_t)vcgtq_s64(v87, v57)));
    v92 = vsubq_f32((float32x4_t)_Q0, v91);
    *(float32x4_t *)(a1 + v78 + 1780) = vmlaq_f32(vmulq_n_f32(v91, v79), v83, v92);
    *(float32x4_t *)(a1 + v78 + 2040) = vmlaq_f32(vmulq_n_f32(v91, v80), v84, v92);
    v93 = vmlaq_f32(vmulq_n_f32(v91, v86), v85, v92);
    v94 = vdupq_n_s64(4uLL);
    *(float32x4_t *)(a1 + v78 + 2300) = v93;
    v87 = vaddq_s64(v87, v94);
    v88 = vaddq_s64(v88, v94);
    v89 = vaddq_s32(v89, v90);
    v78 += 16;
  }
  while (v78 != 256);
  v95 = 0.0;
  if ((int)v54 <= 63)
  {
    v95 = 1.0;
    if ((int)v55 >= 65)
      v95 = (float)(64 - (int)v54) / *(float *)v48.i32;
  }
  *(float *)(a1 + 2036) = (float)(v79 * v95) + (float)((float)(1.0 - v95) * *(float *)v52.i32);
  *(float *)(a1 + 2296) = (float)(v80 * v95) + (float)((float)(1.0 - v95) * *(float *)v50.i32);
  *(float *)(a1 + 2556) = (float)(v86 * v95) + (float)((float)(1.0 - v95) * *(float *)v49.i32);
  *(_BYTE *)(a1 + 2560) = *(_BYTE *)(a2 + 505);
  *(_QWORD *)(a1 + 2568) = 0;
  *(int8x16_t *)(v10 + 136) = _Q0;
  *(int8x16_t *)(v10 + 152) = _Q0;
  *(int8x16_t *)(v10 + 168) = _Q0;
  *(int8x16_t *)(v10 + 184) = _Q0;
  *(int8x16_t *)(v10 + 200) = _Q0;
  *(int8x16_t *)(v10 + 216) = _Q0;
  *(int8x16_t *)(v10 + 232) = _Q0;
  *(int8x16_t *)(v10 + 248) = _Q0;
  *(int8x16_t *)(v10 + 264) = _Q0;
  *(int8x16_t *)(v10 + 280) = _Q0;
  *(int8x16_t *)(v10 + 296) = _Q0;
  *(int8x16_t *)(v10 + 312) = _Q0;
  *(int8x16_t *)(v10 + 328) = _Q0;
  *(int8x16_t *)(v10 + 344) = _Q0;
  *(int8x16_t *)(v10 + 360) = _Q0;
  *(int8x16_t *)(v10 + 376) = _Q0;
  *(_DWORD *)(a1 + 892) = 1065353216;
  if (!*(_BYTE *)(a1 + 576))
  {
    v99 = operator new();
    v100 = (_QWORD *)v99;
    v101 = *(_QWORD *)(a1 + 624);
    *(_QWORD *)v99 = &off_24C0B3228;
    *(_QWORD *)(v99 + 8) = *(_QWORD *)v10;
    *(_DWORD *)(v99 + 16) = *(_DWORD *)(a1 + 508);
    *(_QWORD *)(v99 + 20) = *(_QWORD *)(a1 + 512);
    *(_BYTE *)(v99 + 28) = *(_BYTE *)(a1 + 520);
    *(_QWORD *)(v99 + 32) = v101;
    *(_BYTE *)(v99 + 40) = 0;
    *(_QWORD *)(v99 + 56) = 0;
    *(_QWORD *)(v99 + 64) = 0;
    *(_QWORD *)(v99 + 48) = 0;
    if (!v101)
    {
      *(_QWORD *)(v99 + 72) = 0;
      *(_QWORD *)(v99 + 80) = 0;
      *(_QWORD *)(v99 + 88) = 0;
      v97 = *(_QWORD *)(a1 + 2568);
      *(_QWORD *)(a1 + 2568) = v100;
      if (!v97)
        return a1;
      goto LABEL_24;
    }
    if (!(v101 >> 62))
    {
      v102 = 4 * v101;
      v103 = (char *)operator new(4 * v101);
      v100[6] = v103;
      v104 = &v103[v102];
      v100[8] = &v103[v102];
      bzero(v103, v102);
      v100[7] = v104;
      v105 = (char *)operator new(v102);
      v100[9] = v105;
      v106 = &v105[v102];
      v100[11] = &v105[v102];
      bzero(v105, v102);
      v100[10] = v106;
      v97 = *(_QWORD *)(a1 + 2568);
      *(_QWORD *)(a1 + 2568) = v100;
      if (!v97)
        return a1;
      goto LABEL_24;
    }
LABEL_32:
    abort();
  }
  v96 = operator new();
  webrtc::SubbandNearendDetector::SubbandNearendDetector(v96, (__int128 *)(a1 + 528), *(_QWORD *)(a1 + 624));
  v97 = *(_QWORD *)(a1 + 2568);
  *(_QWORD *)(a1 + 2568) = v96;
  if (v97)
LABEL_24:
    (*(void (**)(uint64_t))(*(_QWORD *)v97 + 8))(v97);
  return a1;
}

void webrtc::SuppressionGain::~SuppressionGain(webrtc::SuppressionGain *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;

  v2 = *((_QWORD *)this + 321);
  *((_QWORD *)this + 321) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 120);
  if (v3)
  {
    v4 = *((_QWORD *)this + 121);
    v5 = (void *)*((_QWORD *)this + 120);
    if (v4 != v3)
    {
      do
      {
        v6 = *(void **)(v4 - 32);
        if (v6)
        {
          *(_QWORD *)(v4 - 24) = v6;
          operator delete(v6);
        }
        v4 -= 56;
      }
      while (v4 != v3);
      v5 = (void *)*((_QWORD *)this + 120);
    }
    *((_QWORD *)this + 121) = v3;
    operator delete(v5);
  }
  v7 = (void *)*((_QWORD *)this + 115);
  if (v7)
  {
    *((_QWORD *)this + 116) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 112);
  if (v8)
  {
    *((_QWORD *)this + 113) = v8;
    operator delete(v8);
  }
  v9 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v9)
    MEMORY[0x20BD0ADEC](v9, 0xC400A2AC0F1);
}

uint64_t webrtc::SuppressionGain::GetGain(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11, uint64_t a12, uint64_t a13, float32x4_t *a14, float32x4_t *a15, char a16, uint64_t a17, uint64_t a18)
{
  float v18;
  uint64_t v24;
  uint64_t v25;
  float32x4_t *p_dst;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float v33;
  float v34;
  uint64_t i;
  uint64_t v36;
  float v37;
  float v38;
  int v42;
  int32x2_t v43;
  uint64_t v44;
  float v45;
  float v46;
  float v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int8x16_t v51;
  int8x16_t v52;
  int8x16_t v53;
  int8x16_t v54;
  int8x16_t v55;
  int8x16_t v56;
  int8x16_t v57;
  int8x16_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int8x16_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t v75;
  int8x16_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t v81;
  int8x16_t v82;
  int8x16_t v83;
  uint64_t v84;
  int8x16_t v86;
  int8x16_t v87;
  float32x4_t v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  __int8 *v94;
  unint64_t v95;
  uint64_t v96;
  float *v97;
  float *v98;
  float32x4_t *v99;
  float *v100;
  uint64_t v102;
  uint64_t v103;
  float32x4_t *v104;
  float32x4_t v105;
  float v106;
  uint64_t v107;
  float v108;
  _QWORD *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float32x4_t v125;
  float v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  int8x16_t v155;
  int8x16_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float v159;
  float v160;
  int v161;
  uint64_t v162;
  unint64_t v163;
  float v164;
  float v165;
  float v166;
  float v167;
  float v168;
  float v169;
  int8x16_t v170;
  int8x16_t v171;
  int8x16_t v172;
  int8x16_t v173;
  int8x16_t v174;
  int8x16_t v175;
  int8x16_t v176;
  int8x16_t v177;
  int8x16_t v178;
  int8x16_t v179;
  int8x16_t v180;
  int8x16_t v181;
  int8x16_t v182;
  int8x16_t v183;
  int8x16_t v184;
  int8x16_t v185;
  int8x16_t v186;
  int8x16_t v187;
  int8x16_t v188;
  int8x16_t v189;
  int8x16_t v190;
  int8x16_t v191;
  int8x16_t v192;
  int8x16_t v193;
  int8x16_t v194;
  int8x16_t v195;
  int8x16_t v196;
  int8x16_t v197;
  int8x16_t v198;
  int8x16_t v199;
  int8x16_t v200;
  int8x16_t v201;
  int8x16_t v202;
  int8x16_t v203;
  int8x16_t v204;
  int8x16_t v205;
  int8x16_t v206;
  int8x16_t v207;
  int8x16_t v208;
  int8x16_t v209;
  int8x16_t v210;
  int8x16_t v211;
  int8x16_t v212;
  int8x16_t v213;
  int8x16_t v214;
  int8x16_t v215;
  int8x16_t v216;
  float v217;
  float v218;
  uint64_t v219;
  float32x4_t v220;
  int8x16_t v221;
  int8x16_t v222;
  int8x16_t v223;
  int8x16_t v224;
  int8x16_t v225;
  int8x16_t v226;
  int8x16_t v227;
  int8x16_t v228;
  int8x16_t v229;
  int8x16_t v230;
  int8x16_t v231;
  int8x16_t v232;
  int8x16_t v233;
  int8x16_t v234;
  int8x16_t v235;
  int8x16_t v236;
  int v237;
  uint64_t v238;
  uint64_t v239;
  float v240;
  float v241;
  int v242;
  int32x2_t v243;
  int v244;
  uint64_t v245;
  int8x16_t v246;
  int8x16_t v247;
  int8x16_t v248;
  int8x16_t v249;
  int8x16_t v250;
  int8x16_t v251;
  int8x16_t v252;
  int8x16_t v253;
  int8x16_t v254;
  int8x16_t v255;
  int8x16_t v256;
  int8x16_t v257;
  float32x2_t v258;
  int8x16_t v259;
  float v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  float v265;
  float v266;
  float v267;
  float v268;
  float v269;
  float v270;
  float v271;
  float v272;
  float v273;
  float v274;
  float v275;
  float v276;
  float v277;
  float v278;
  float v279;
  float v280;
  float v281;
  float v282;
  float v283;
  float v284;
  float v285;
  float v286;
  float v287;
  float v288;
  float v289;
  float v290;
  float v291;
  float v292;
  float v293;
  float v294;
  float v295;
  float v296;
  float v297;
  float v298;
  uint64_t v299;
  float v300;
  float *v301;
  uint64_t v302;
  uint64_t v303;
  float v304;
  float *v305;
  float v306;
  float v307;
  float v308;
  float v309;
  float v310;
  float v311;
  float v312;
  uint64_t v313;
  int v314;
  int v315;
  unint64_t v316;
  float *v317;
  float v318;
  float v319;
  float v320;
  float v321;
  float v322;
  float v323;
  float v324;
  float v325;
  float v326;
  uint64_t v327;
  float *v328;
  float *v329;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  int8x16_t v334;
  int8x16_t v335;
  int8x16_t v336;
  int8x16_t v337;
  int8x16_t v338;
  int8x16_t v339;
  int8x16_t v340;
  int8x16_t v341;
  int8x16_t v342;
  int8x16_t v343;
  int8x16_t v344;
  int8x16_t v345;
  int8x16_t v346;
  int8x16_t v347;
  int8x16_t v348;
  int8x16_t v349;
  _QWORD *v350;
  int v351;
  uint64_t v352;
  uint64_t v353;
  float *v354;
  int8x16_t v355;
  float v356;
  float v357;
  int8x16_t v358;
  int8x16_t v359;
  int8x16_t v360;
  int8x16_t v361;
  int8x16_t v362;
  int8x16_t v363;
  int8x16_t v364;
  int8x16_t v365;
  int8x16_t v366;
  int8x16_t v367;
  int8x16_t v368;
  int8x16_t v369;
  int8x16_t v370;
  int8x16_t v371;
  int8x16_t v372;
  int8x16_t v373;
  float v374;
  float32x4_t __src[17];
  float32x4_t __dst;
  float32x4_t v377;
  float32x4_t v378;
  float32x4_t v379;
  float32x4_t v380;
  float32x4_t v381;
  float32x4_t v382;
  float32x4_t v383;
  float32x4_t v384;
  float32x4_t v385;
  float32x4_t v386;
  float32x4_t v387;
  float32x4_t v388;
  float32x4_t v389;
  float32x4_t v390;
  float32x4_t v391;
  float v392;
  _BYTE v393[12];
  float32x4_t v394;
  int8x16_t v395;
  float32x4_t v396;
  int8x16_t v397;
  float32x4_t v398;
  int8x16_t v399;
  float32x4_t v400;
  int8x16_t v401;
  float32x4_t v402;
  int8x16_t v403;
  float32x4_t v404;
  int8x16_t v405;
  float32x4_t v406;
  int8x16_t v407;
  float32x4_t v408;
  float32x4_t v409;
  float v410;
  _BYTE v411[28];

  v24 = a17;
  p_dst = a14;
  v25 = (uint64_t)a15;
  v27 = *(_QWORD *)(a1 + 2568);
  if (!a3)
    a2 = 0;
  if (a12)
    v28 = a11;
  else
    v28 = 0;
  v353 = a2;
  (*(void (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
  v29 = a15->u32[1];
  if ((int)v29 >= 1)
  {
    v30 = 0;
    v31 = 0;
    v32 = a15->i64[1];
    v33 = 0.0;
    v34 = 0.0;
    while ((a15[1].i64[0] - v32) >> 2 > (unint64_t)(int)((_DWORD)v31 << 6))
    {
      for (i = 0; i != 256; i += 4)
      {
        v36 = v32 + 4 * (int)v30;
        v37 = *(float *)(v36 + i) * *(float *)(v36 + i);
        v33 = v33 + v37;
        if (v34 < v37)
          v34 = *(float *)(v36 + i) * *(float *)(v36 + i);
      }
      ++v31;
      v30 = (v30 + 64);
      if (v31 == v29)
        goto LABEL_16;
    }
LABEL_202:
    __break(1u);
    goto LABEL_203;
  }
  v34 = 0.0;
  v33 = 0.0;
LABEL_16:
  v331 = a5;
  v332 = a4;
  v38 = *(float *)(a1 + 944);
  *(float *)(a1 + 944) = (float)((float)(v33 / (float)(int)v29) * 0.1) + (float)(v38 * 0.9);
  v351 = a14[50].u8[0];
  __asm { FMOV            V0.4S, #1.0 }
  *(int8x16_t *)a18 = _Q0;
  *(int8x16_t *)(a18 + 16) = _Q0;
  *(int8x16_t *)(a18 + 32) = _Q0;
  *(int8x16_t *)(a18 + 48) = _Q0;
  *(int8x16_t *)(a18 + 64) = _Q0;
  *(int8x16_t *)(a18 + 80) = _Q0;
  *(int8x16_t *)(a18 + 128) = _Q0;
  *(int8x16_t *)(a18 + 144) = _Q0;
  *(int8x16_t *)(a18 + 160) = _Q0;
  *(int8x16_t *)(a18 + 176) = _Q0;
  *(int8x16_t *)(a18 + 192) = _Q0;
  *(int8x16_t *)(a18 + 208) = _Q0;
  *(int8x16_t *)(a18 + 224) = _Q0;
  *(int8x16_t *)(a18 + 240) = _Q0;
  *(int8x16_t *)(a18 + 96) = _Q0;
  *(int8x16_t *)(a18 + 112) = _Q0;
  v355 = _Q0;
  *(_DWORD *)(a18 + 256) = 1065353216;
  v42 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2568) + 16))(*(_QWORD *)(a1 + 2568));
  v44 = 1772;
  if (v42)
    v44 = 984;
  v45 = *(float *)(a1 + v44);
  v43.i32[0] = *(_DWORD *)(a1 + 596);
  v46 = v45 * *(float *)(a1 + 892);
  if (v46 < *(float *)v43.i32)
    v46 = *(float *)(a1 + 596);
  v18 = 1.0;
  if (v46 <= 1.0)
    v47 = v46;
  else
    v47 = 1.0;
  if (a7)
    v48 = a6;
  else
    v48 = 0;
  v352 = v48;
  v354 = (float *)(a1 + 636);
  if (*(_QWORD *)(a1 + 624))
  {
    v49 = 0;
    v50 = 0;
    v51 = (int8x16_t)vdupq_lane_s32(v43, 0);
    v52 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 636), v45);
    v53 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 652), v45);
    v54 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v52), v51, v52);
    v55 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v53), v51, v53);
    v349 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v54, (float32x4_t)v355), v355, v54);
    v348 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v55, (float32x4_t)v355), v355, v55);
    v56 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 668), v45);
    v57 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 684), v45);
    v58 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v56), v51, v56);
    v59 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v57), v51, v57);
    v347 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v58, (float32x4_t)v355), v355, v58);
    v346 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v59, (float32x4_t)v355), v355, v59);
    v60 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 700), v45);
    v61 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 716), v45);
    v62 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v60), v51, v60);
    v63 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v61), v51, v61);
    v345 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v62, (float32x4_t)v355), v355, v62);
    v344 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v63, (float32x4_t)v355), v355, v63);
    v64 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 732), v45);
    v65 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 748), v45);
    v66 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v64), v51, v64);
    v67 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v65), v51, v65);
    v343 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v66, (float32x4_t)v355), v355, v66);
    v342 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v67, (float32x4_t)v355), v355, v67);
    v68 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 764), v45);
    v69 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 780), v45);
    v70 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v68), v51, v68);
    v71 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v69), v51, v69);
    v341 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v70, (float32x4_t)v355), v355, v70);
    v340 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v71, (float32x4_t)v355), v355, v71);
    v72 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 796), v45);
    v73 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 812), v45);
    v74 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v72), v51, v72);
    v75 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v73), v51, v73);
    v339 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v74, (float32x4_t)v355), v355, v74);
    v338 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v75, (float32x4_t)v355), v355, v75);
    v76 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 828), v45);
    v77 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 844), v45);
    v78 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v76), v51, v76);
    v79 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v77), v51, v77);
    v337 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v78, (float32x4_t)v355), v355, v78);
    v336 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v79, (float32x4_t)v355), v355, v79);
    v80 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 860), v45);
    v81 = (int8x16_t)vmulq_n_f32(*(float32x4_t *)(a1 + 876), v45);
    v82 = (int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v80);
    v83 = (int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v81);
    v84 = 308;
    if (v34 < (float)(v38 * 3.0) && v38 < 160000.0)
      v84 = 304;
    v333 = v84;
    v86 = vbslq_s8(v82, v51, v80);
    v87 = vbslq_s8(v83, v51, v81);
    v24 = 56;
    p_dst = &__dst;
    v334 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v87, (float32x4_t)v355), v355, v87);
    v335 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v86, (float32x4_t)v355), v355, v86);
    v350 = v28;
    do
    {
      v25 = *(_QWORD *)(a1 + 960);
      v30 = 0x6DB6DB6DB6DB6DB7;
      v29 = 0x6DB6DB6DB6DB6DB7 * ((*(_QWORD *)(a1 + 968) - v25) >> 3);
      if (v29 <= v50)
        goto LABEL_202;
      v28 = (_QWORD *)(v25 + 56 * v50);
      memmove(&__dst, (const void *)(v353 + 260 * v50), 0x104uLL);
      v89 = v28[3];
      v90 = v28[4];
      if (v89 < v90)
      {
        v91 = *v28;
        if (*v28)
        {
          v92 = 0;
          v93 = 4 * v91;
          v94 = &__dst.i8[4 * v91];
          v95 = (v91 - 1) & 0x3FFFFFFFFFFFFFFFLL;
          v96 = (v95 + 1) & 0x7FFFFFFFFFFFFFF8;
          v97 = (float *)v28[3];
          do
          {
            v98 = &v97[(unint64_t)v93 / 4];
            v99 = &__dst;
            if (v95 >= 7)
            {
              if ((unint64_t)&__dst >= v89 + v93 + v93 * v92 || v97 >= (float *)v94)
              {
                v102 = 0;
                v100 = &v97[v96];
                v103 = (v95 + 1) & 0x7FFFFFFFFFFFFFF8;
                do
                {
                  v104 = (float32x4_t *)((char *)&__dst + v102 * 4);
                  v88 = vaddq_f32(*(float32x4_t *)&v97[v102], *(float32x4_t *)((char *)&__dst + v102 * 4));
                  v105 = vaddq_f32(*(float32x4_t *)&v97[v102 + 4], *(float32x4_t *)((char *)&__dst + v102 * 4 + 16));
                  *v104 = v88;
                  v104[1] = v105;
                  v102 += 8;
                  v103 -= 8;
                }
                while (v103);
                v99 = (float32x4_t *)((char *)&__dst + 4 * v96);
                if (v95 + 1 == v96)
                  goto LABEL_37;
              }
              else
              {
                v100 = v97;
              }
            }
            else
            {
              v100 = v97;
            }
            do
            {
              v106 = *v100++;
              v99->f32[0] = v106 + v99->f32[0];
              v99 = (float32x4_t *)((char *)v99 + 4);
            }
            while (v100 != v98);
LABEL_37:
            ++v92;
            v97 = (float *)((char *)v97 + v93);
          }
          while ((unint64_t)v98 < v90);
        }
      }
      v107 = v25 + 56 * v50;
      v108 = *(float *)(v107 + 16);
      __dst = vmulq_n_f32(__dst, v108);
      v377 = vmulq_n_f32(v377, v108);
      v378 = vmulq_n_f32(v378, v108);
      v379 = vmulq_n_f32(v379, v108);
      v380 = vmulq_n_f32(v380, v108);
      v381 = vmulq_n_f32(v381, v108);
      v382 = vmulq_n_f32(v382, v108);
      v383 = vmulq_n_f32(v383, v108);
      v384 = vmulq_n_f32(v384, v108);
      v385 = vmulq_n_f32(v385, v108);
      v386 = vmulq_n_f32(v386, v108);
      v387 = vmulq_n_f32(v387, v108);
      v388 = vmulq_n_f32(v388, v108);
      v389 = vmulq_n_f32(v389, v108);
      v390 = vmulq_n_f32(v390, v108);
      v391 = vmulq_n_f32(v391, v108);
      v392 = v108 * v392;
      v110 = *(_QWORD *)(v107 + 8);
      v109 = (_QWORD *)(v107 + 8);
      if (v110)
      {
        v111 = v25 + 56 * v50;
        memmove((void *)(v89 + 4 * *v28 * *(_QWORD *)(v111 + 48)), (const void *)(v353 + 260 * v50), 0x104uLL);
        *(_QWORD *)(v111 + 48) = (unint64_t)(*(_QWORD *)(v111 + 48) + 1) % *v109;
      }
      v112 = v352 + 260 * v50;
      v113 = *(float *)(a1 + 312);
      v114 = v113 * *(float *)(a1 + 316);
      v115 = 1.0 / (float)(v114 - v113);
      v116 = *(float *)v112;
      if (*(float *)v112 < v114)
        v116 = v116
             * fmaxf(1.0 - (float)((float)((float)(v114 - v116) * v115) * (float)((float)(v114 - v116) * v115)), 0.0);
      v24 = a1 + 636;
      __src[0].f32[0] = v116;
      v117 = *(float *)(v112 + 4);
      if (v117 < v114)
        v117 = v117
             * fmaxf(1.0 - (float)((float)(v115 * (float)(v114 - v117)) * (float)(v115 * (float)(v114 - v117))), 0.0);
      __src[0].f32[1] = v117;
      v118 = *(float *)(v112 + 8);
      if (v118 < v114)
        v118 = v118
             * fmaxf(1.0 - (float)((float)(v115 * (float)(v114 - v118)) * (float)(v115 * (float)(v114 - v118))), 0.0);
      __src[0].f32[2] = v118;
      v119 = v113 * *(float *)(a1 + 320);
      v120 = 1.0 / (float)(v119 - v113);
      v121 = *(float *)(v112 + 12);
      if (v121 < v119)
      {
        __src[0].f32[3] = v121
                        * fmaxf(1.0 - (float)((float)((float)(v119 - v121) * v120) * (float)((float)(v119 - v121) * v120)), 0.0);
        v122 = *(float *)(v112 + 16);
        if (v122 >= v119)
        {
LABEL_60:
          __src[1].f32[0] = v122;
          v123 = *(float *)(v112 + 20);
          if (v123 < v119)
            goto LABEL_92;
          goto LABEL_61;
        }
      }
      else
      {
        __src[0].i32[3] = *(_DWORD *)(v112 + 12);
        v122 = *(float *)(v112 + 16);
        if (v122 >= v119)
          goto LABEL_60;
      }
      __src[1].f32[0] = v122
                      * fmaxf(1.0 - (float)((float)(v120 * (float)(v119 - v122)) * (float)(v120 * (float)(v119 - v122))), 0.0);
      v123 = *(float *)(v112 + 20);
      if (v123 < v119)
      {
LABEL_92:
        __src[1].f32[1] = v123
                        * fmaxf(1.0 - (float)((float)(v120 * (float)(v119 - v123)) * (float)(v120 * (float)(v119 - v123))), 0.0);
        v124 = *(float *)(v112 + 24);
        if (v124 >= v119)
          goto LABEL_63;
LABEL_62:
        v124 = v124
             * fmaxf(1.0 - (float)((float)(v120 * (float)(v119 - v124)) * (float)(v120 * (float)(v119 - v124))), 0.0);
        goto LABEL_63;
      }
LABEL_61:
      __src[1].f32[1] = v123;
      v124 = *(float *)(v112 + 24);
      if (v124 < v119)
        goto LABEL_62;
LABEL_63:
      v88.f32[0] = v113 * *(float *)(a1 + 324);
      v125 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v88.f32, 0);
      v126 = 1.0 / (float)(v88.f32[0] - v113);
      v127 = *(float32x4_t *)(v112 + 28);
      v128 = *(float32x4_t *)(v112 + 44);
      v129 = vmulq_n_f32(vsubq_f32(v125, v127), v126);
      v130 = vmulq_n_f32(vsubq_f32(v125, v128), v126);
      v131 = vmulq_f32(v127, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v127), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v129, v129), (float32x4_t)0), v355));
      v132 = vmulq_f32(v128, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v128), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v130, v130), (float32x4_t)0), v355));
      v133 = *(float32x4_t *)(v112 + 60);
      v134 = *(float32x4_t *)(v112 + 76);
      __src[1].f32[2] = v124;
      v30 = (unint64_t)__src;
      *(float32x4_t *)((char *)&__src[1] + 12) = v131;
      v135 = vmulq_n_f32(vsubq_f32(v125, v133), v126);
      v136 = vmulq_n_f32(vsubq_f32(v125, v134), v126);
      *(float32x4_t *)((char *)&__src[2] + 12) = v132;
      *(float32x4_t *)((char *)&__src[3] + 12) = vmulq_f32(v133, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v133), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v135, v135), (float32x4_t)0), v355));
      *(float32x4_t *)((char *)&__src[4] + 12) = vmulq_f32(v134, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v134), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v136, v136), (float32x4_t)0), v355));
      v137 = *(float32x4_t *)(v112 + 92);
      v138 = *(float32x4_t *)(v112 + 108);
      v139 = vmulq_n_f32(vsubq_f32(v125, v137), v126);
      v140 = vmulq_n_f32(vsubq_f32(v125, v138), v126);
      *(float32x4_t *)((char *)&__src[5] + 12) = vmulq_f32(v137, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v137), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v139, v139), (float32x4_t)0), v355));
      *(float32x4_t *)((char *)&__src[6] + 12) = vmulq_f32(v138, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v138), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v140, v140), (float32x4_t)0), v355));
      v141 = *(float32x4_t *)(v112 + 124);
      v142 = *(float32x4_t *)(v112 + 140);
      v143 = vmulq_n_f32(vsubq_f32(v125, v141), v126);
      v144 = vmulq_n_f32(vsubq_f32(v125, v142), v126);
      *(float32x4_t *)((char *)&__src[7] + 12) = vmulq_f32(v141, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v141), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v143, v143), (float32x4_t)0), v355));
      *(float32x4_t *)((char *)&__src[8] + 12) = vmulq_f32(v142, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v142), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v144, v144), (float32x4_t)0), v355));
      v145 = *(float32x4_t *)(v112 + 156);
      v146 = *(float32x4_t *)(v112 + 172);
      v147 = vmulq_n_f32(vsubq_f32(v125, v145), v126);
      v148 = vmulq_n_f32(vsubq_f32(v125, v146), v126);
      *(float32x4_t *)((char *)&__src[9] + 12) = vmulq_f32(v145, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v145), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v147, v147), (float32x4_t)0), v355));
      *(float32x4_t *)((char *)&__src[10] + 12) = vmulq_f32(v146, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v146), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v148, v148), (float32x4_t)0), v355));
      v149 = *(float32x4_t *)(v112 + 188);
      v150 = *(float32x4_t *)(v112 + 204);
      v151 = vmulq_n_f32(vsubq_f32(v125, v149), v126);
      v152 = vmulq_n_f32(vsubq_f32(v125, v150), v126);
      *(float32x4_t *)((char *)&__src[11] + 12) = vmulq_f32(v149, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v149), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v151, v151), (float32x4_t)0), v355));
      *(float32x4_t *)((char *)&__src[12] + 12) = vmulq_f32(v150, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v125, v150), (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v152, v152), (float32x4_t)0), v355));
      v153 = *(float32x4_t *)(v112 + 220);
      v154 = *(float32x4_t *)(v112 + 236);
      v155 = (int8x16_t)vcgtq_f32(v125, v153);
      v156 = (int8x16_t)vcgtq_f32(v125, v154);
      v157 = vmulq_n_f32(vsubq_f32(v125, v153), v126);
      v158 = vmulq_n_f32(vsubq_f32(v125, v154), v126);
      *(float32x4_t *)((char *)&__src[13] + 12) = vmulq_f32(v153, (float32x4_t)vbslq_s8(v155, (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v157, v157), (float32x4_t)0), v355));
      *(float32x4_t *)((char *)&__src[14] + 12) = vmulq_f32(v154, (float32x4_t)vbslq_s8(v156, (int8x16_t)vmaxnmq_f32(vmlsq_f32((float32x4_t)v355, v158, v158), (float32x4_t)0), v355));
      v159 = *(float *)(v112 + 252);
      if (v159 < v88.f32[0])
        v159 = v159
             * fmaxf(1.0 - (float)((float)(v126 * (float)(v88.f32[0] - v159)) * (float)(v126 * (float)(v88.f32[0] - v159))), 0.0);
      __src[15].f32[3] = v159;
      v160 = *(float *)(v112 + 256);
      if (v160 < v88.f32[0])
        v160 = v160
             * fmaxf(1.0 - (float)((float)(v126 * (float)(v88.f32[0] - v160)) * (float)(v126 * (float)(v88.f32[0] - v160))), 0.0);
      __src[16].f32[0] = v160;
      v25 = *(_QWORD *)(a1 + 896);
      v29 = 0xFC0FC0FC0FC0FC1 * ((*(_QWORD *)(a1 + 904) - v25) >> 2);
      if (v29 <= v50)
        goto LABEL_202;
      v28 = *(_QWORD **)(a1 + 920);
      v29 = 0xFC0FC0FC0FC0FC1 * ((uint64_t)(*(_QWORD *)(a1 + 928) - (_QWORD)v28) >> 2);
      if (v29 <= v50)
        goto LABEL_202;
      if (v351)
      {
        v374 = 0.0;
        v372 = 0u;
        v373 = 0u;
        v370 = 0u;
        v371 = 0u;
        v368 = 0u;
        v369 = 0u;
        v366 = 0u;
        v367 = 0u;
        v364 = 0u;
        v365 = 0u;
        v362 = 0u;
        v363 = 0u;
        v360 = 0u;
        v361 = 0u;
        v358 = 0u;
        v359 = 0u;
      }
      else
      {
        v88.i32[0] = *(_DWORD *)(a1 + v333);
        v220 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v88.f32, 0);
        v221 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[0]), (int8x16_t)vdivq_f32(v220, __src[0]), v355);
        v222 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[1]), (int8x16_t)vdivq_f32(v220, __src[1]), v355);
        v358 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v221, (float32x4_t)v355), v355, v221);
        v359 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v222, (float32x4_t)v355), v355, v222);
        v223 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[2]), (int8x16_t)vdivq_f32(v220, __src[2]), v355);
        v224 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[3]), (int8x16_t)vdivq_f32(v220, __src[3]), v355);
        v360 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v223, (float32x4_t)v355), v355, v223);
        v361 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v224, (float32x4_t)v355), v355, v224);
        v225 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[4]), (int8x16_t)vdivq_f32(v220, __src[4]), v355);
        v226 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[5]), (int8x16_t)vdivq_f32(v220, __src[5]), v355);
        v362 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v225, (float32x4_t)v355), v355, v225);
        v363 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v226, (float32x4_t)v355), v355, v226);
        v227 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[6]), (int8x16_t)vdivq_f32(v220, __src[6]), v355);
        v228 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[7]), (int8x16_t)vdivq_f32(v220, __src[7]), v355);
        v364 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v227, (float32x4_t)v355), v355, v227);
        v365 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v228, (float32x4_t)v355), v355, v228);
        v229 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[8]), (int8x16_t)vdivq_f32(v220, __src[8]), v355);
        v230 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[9]), (int8x16_t)vdivq_f32(v220, __src[9]), v355);
        v366 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v229, (float32x4_t)v355), v355, v229);
        v367 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v230, (float32x4_t)v355), v355, v230);
        v231 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[10]), (int8x16_t)vdivq_f32(v220, __src[10]), v355);
        v232 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[11]), (int8x16_t)vdivq_f32(v220, __src[11]), v355);
        v368 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v231, (float32x4_t)v355), v355, v231);
        v369 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v232, (float32x4_t)v355), v355, v232);
        v233 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[12]), (int8x16_t)vdivq_f32(v220, __src[12]), v355);
        v234 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[13]), (int8x16_t)vdivq_f32(v220, __src[13]), v355);
        v370 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v233, (float32x4_t)v355), v355, v233);
        v371 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v234, (float32x4_t)v355), v355, v234);
        v235 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[14]), (int8x16_t)vdivq_f32(v220, __src[14]), v355);
        v236 = vbslq_s8((int8x16_t)vcgtzq_f32(__src[15]), (int8x16_t)vdivq_f32(v220, __src[15]), v355);
        v372 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v235, (float32x4_t)v355), v355, v235);
        v373 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v236, (float32x4_t)v355), v355, v236);
        v88.f32[0] = v88.f32[0] / __src[16].f32[0];
        if (__src[16].f32[0] <= 0.0)
          v88.f32[0] = 1.0;
        if (v88.f32[0] > 1.0)
          v88.f32[0] = 1.0;
        v374 = v88.f32[0];
        if (!*(_BYTE *)(a1 + 948) || *(_BYTE *)(a1 + 480))
        {
          v237 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2568) + 16))(*(_QWORD *)(a1 + 2568));
          v29 = 1776;
          if (v237)
            v29 = 988;
          v238 = *(unsigned int *)(a1 + 488);
          if ((v238 & 0x80000000) == 0)
          {
            v30 = 0;
            v239 = v238 + 1;
            do
            {
              if (*(float *)(v25 + v49 + 4 * v30) > *(float *)((char *)v28 + 4 * v30 + v49)
                || (uint64_t)v30 <= *(int *)(a1 + 484))
              {
                if (v30 >= 0x41)
                  goto LABEL_202;
                v240 = v354[v30] * *(float *)(a1 + v29);
                if (*(float *)&v358.i32[v30] >= v240)
                  v240 = *(float *)&v358.i32[v30];
                if (v240 > 1.0)
                  v240 = 1.0;
                *(float *)&v358.i32[v30] = v240;
              }
              ++v30;
            }
            while (v239 != v30);
          }
        }
      }
      v161 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2568) + 16))(*(_QWORD *)(a1 + 2568));
      v162 = a1 + 984;
      if (!v161)
        v162 = a1 + 1772;
      v163 = -260;
      v28 = v350;
      v24 = 56;
      v25 = 260;
      do
      {
        v164 = __src[16].f32[v163 / 4 + 1];
        v165 = 1.0;
        v166 = v164 / (float)(*(float *)&v393[v163] + 1.0);
        v167 = *(float *)(v162 + v163 + 268);
        if (v166 > v167)
        {
          v168 = v164 / (float)(*(float *)((char *)v350 + v163 + 260) + 1.0);
          v169 = *(float *)(v162 + v163 + 788);
          if (v168 > v169)
          {
            v165 = (float)(*(float *)(v162 + v163 + 528) - v166) / (float)(*(float *)(v162 + v163 + 528) - v167);
            if (v165 < (float)(v169 / v168))
              v165 = v169 / v168;
          }
        }
        *(float *)&v411[v163] = v165;
        v163 += 4;
      }
      while (v163);
      v170 = vbslq_s8((int8x16_t)vcgtq_f32(v394, (float32x4_t)v349), v349, (int8x16_t)v394);
      v171 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v358, (float32x4_t)v170), v358, v170);
      v172 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v395, (float32x4_t)v348), v348, v395);
      v173 = *(int8x16_t *)(a18 + 16);
      v174 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)a18, (float32x4_t)v171), v171, *(int8x16_t *)a18);
      v394 = (float32x4_t)v171;
      v395 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v359, (float32x4_t)v172), v359, v172);
      v175 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v173, (float32x4_t)v395), v395, v173);
      *(int8x16_t *)a18 = v174;
      *(int8x16_t *)(a18 + 16) = v175;
      v176 = vbslq_s8((int8x16_t)vcgtq_f32(v396, (float32x4_t)v347), v347, (int8x16_t)v396);
      v177 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v360, (float32x4_t)v176), v360, v176);
      v178 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v397, (float32x4_t)v346), v346, v397);
      v179 = *(int8x16_t *)(a18 + 48);
      v180 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 32), (float32x4_t)v177), v177, *(int8x16_t *)(a18 + 32));
      v396 = (float32x4_t)v177;
      v397 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v361, (float32x4_t)v178), v361, v178);
      v181 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v179, (float32x4_t)v397), v397, v179);
      *(int8x16_t *)(a18 + 32) = v180;
      *(int8x16_t *)(a18 + 48) = v181;
      v182 = vbslq_s8((int8x16_t)vcgtq_f32(v398, (float32x4_t)v345), v345, (int8x16_t)v398);
      v183 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v362, (float32x4_t)v182), v362, v182);
      v184 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v399, (float32x4_t)v344), v344, v399);
      v185 = *(int8x16_t *)(a18 + 80);
      v186 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 64), (float32x4_t)v183), v183, *(int8x16_t *)(a18 + 64));
      v398 = (float32x4_t)v183;
      v399 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v363, (float32x4_t)v184), v363, v184);
      v187 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v185, (float32x4_t)v399), v399, v185);
      *(int8x16_t *)(a18 + 64) = v186;
      *(int8x16_t *)(a18 + 80) = v187;
      v188 = vbslq_s8((int8x16_t)vcgtq_f32(v400, (float32x4_t)v343), v343, (int8x16_t)v400);
      v189 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v364, (float32x4_t)v188), v364, v188);
      v190 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v401, (float32x4_t)v342), v342, v401);
      v191 = *(int8x16_t *)(a18 + 112);
      v192 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 96), (float32x4_t)v189), v189, *(int8x16_t *)(a18 + 96));
      v400 = (float32x4_t)v189;
      v401 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v365, (float32x4_t)v190), v365, v190);
      v193 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v191, (float32x4_t)v401), v401, v191);
      *(int8x16_t *)(a18 + 96) = v192;
      *(int8x16_t *)(a18 + 112) = v193;
      v194 = vbslq_s8((int8x16_t)vcgtq_f32(v402, (float32x4_t)v341), v341, (int8x16_t)v402);
      v195 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v366, (float32x4_t)v194), v366, v194);
      v196 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v403, (float32x4_t)v340), v340, v403);
      v197 = *(int8x16_t *)(a18 + 144);
      v198 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 128), (float32x4_t)v195), v195, *(int8x16_t *)(a18 + 128));
      v402 = (float32x4_t)v195;
      v403 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v367, (float32x4_t)v196), v367, v196);
      v199 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v197, (float32x4_t)v403), v403, v197);
      *(int8x16_t *)(a18 + 128) = v198;
      *(int8x16_t *)(a18 + 144) = v199;
      v200 = vbslq_s8((int8x16_t)vcgtq_f32(v404, (float32x4_t)v339), v339, (int8x16_t)v404);
      v201 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v368, (float32x4_t)v200), v368, v200);
      v202 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v405, (float32x4_t)v338), v338, v405);
      v203 = *(int8x16_t *)(a18 + 176);
      v204 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 160), (float32x4_t)v201), v201, *(int8x16_t *)(a18 + 160));
      v404 = (float32x4_t)v201;
      v405 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v369, (float32x4_t)v202), v369, v202);
      v205 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v203, (float32x4_t)v405), v405, v203);
      *(int8x16_t *)(a18 + 160) = v204;
      *(int8x16_t *)(a18 + 176) = v205;
      v206 = vbslq_s8((int8x16_t)vcgtq_f32(v406, (float32x4_t)v337), v337, (int8x16_t)v406);
      v207 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v370, (float32x4_t)v206), v370, v206);
      v208 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v407, (float32x4_t)v336), v336, v407);
      v209 = *(int8x16_t *)(a18 + 208);
      v210 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 192), (float32x4_t)v207), v207, *(int8x16_t *)(a18 + 192));
      v406 = (float32x4_t)v207;
      v407 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v371, (float32x4_t)v208), v371, v208);
      v211 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v209, (float32x4_t)v407), v407, v209);
      *(int8x16_t *)(a18 + 192) = v210;
      *(int8x16_t *)(a18 + 208) = v211;
      v212 = vbslq_s8((int8x16_t)vcgtq_f32(v408, (float32x4_t)v335), v335, (int8x16_t)v408);
      v213 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v372, (float32x4_t)v212), v372, v212);
      v214 = vbslq_s8((int8x16_t)vcgtq_f32(v409, (float32x4_t)v334), v334, (int8x16_t)v409);
      v215 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v373, (float32x4_t)v214), v373, v214);
      v216 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 240), (float32x4_t)v215), v215, *(int8x16_t *)(a18 + 240));
      *(int8x16_t *)(a18 + 224) = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 224), (float32x4_t)v213), v213, *(int8x16_t *)(a18 + 224));
      *(int8x16_t *)(a18 + 240) = v216;
      v217 = v410;
      if (v47 < v410)
        v217 = v47;
      if (v217 < v374)
        v217 = v374;
      v218 = *(float *)(a18 + 256);
      if (v217 < v218)
        v218 = v217;
      *(float *)(a18 + 256) = v218;
      v29 = *(_QWORD *)(a1 + 896);
      v219 = (uint64_t)(*(_QWORD *)(a1 + 904) - v29) >> 2;
      v408 = (float32x4_t)v213;
      v409 = (float32x4_t)v215;
      v30 = 0xFC0FC0FC0FC0FC1 * v219;
      v410 = v217;
      if (v30 <= v50)
        goto LABEL_202;
      memmove((void *)(v29 + 260 * v50), &__dst, 0x104uLL);
      v29 = *(_QWORD *)(a1 + 920);
      v30 = 0xFC0FC0FC0FC0FC1 * ((uint64_t)(*(_QWORD *)(a1 + 928) - v29) >> 2);
      if (v30 <= v50)
        goto LABEL_202;
      memcpy((void *)(v29 + 260 * v50++), __src, 0x104uLL);
      v49 += 260;
    }
    while (v50 < *(_QWORD *)(a1 + 624));
  }
  v241 = *(float *)(a18 + 8);
  if (v241 >= *(float *)(a18 + 4))
    v241 = *(float *)(a18 + 4);
  *(float *)a18 = v241;
  *(float *)(a18 + 4) = v241;
  v242 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2568) + 16))(*(_QWORD *)(a1 + 2568));
  v244 = *(unsigned __int8 *)(a1 + 600);
  if (!v242)
  {
    p_dst = a15;
    v24 = a17;
    v245 = v331;
    v25 = v332;
    goto LABEL_121;
  }
  p_dst = a15;
  v24 = a17;
  v245 = v331;
  v25 = v332;
  if ((a16 & 1) != 0)
  {
LABEL_121:
    v243.i32[0] = *(_DWORD *)(a18 + 64);
    v246 = (int8x16_t)vdupq_lane_s32(v243, 0);
    v247 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 68), (float32x4_t)v246), v246, *(int8x16_t *)(a18 + 68));
    *(int8x16_t *)(a18 + 68) = v247;
    v248 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 84), (float32x4_t)v246), v246, *(int8x16_t *)(a18 + 84));
    *(int8x16_t *)(a18 + 84) = v248;
    v249 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 100), (float32x4_t)v246), v246, *(int8x16_t *)(a18 + 100));
    *(int8x16_t *)(a18 + 100) = v249;
    v250 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 116), (float32x4_t)v246), v246, *(int8x16_t *)(a18 + 116));
    *(int8x16_t *)(a18 + 116) = v250;
    v251 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 132), (float32x4_t)v246), v246, *(int8x16_t *)(a18 + 132));
    *(int8x16_t *)(a18 + 132) = v251;
    v252 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 148), (float32x4_t)v246), v246, *(int8x16_t *)(a18 + 148));
    *(int8x16_t *)(a18 + 148) = v252;
    v253 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 164), (float32x4_t)v246), v246, *(int8x16_t *)(a18 + 164));
    *(int8x16_t *)(a18 + 164) = v253;
    v254 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 180), (float32x4_t)v246), v246, *(int8x16_t *)(a18 + 180));
    *(int8x16_t *)(a18 + 180) = v254;
    v255 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 196), (float32x4_t)v246), v246, *(int8x16_t *)(a18 + 196));
    *(int8x16_t *)(a18 + 196) = v255;
    v256 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 212), (float32x4_t)v246), v246, *(int8x16_t *)(a18 + 212));
    *(int8x16_t *)(a18 + 212) = v256;
    v257 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a18 + 228), (float32x4_t)v246), v246, *(int8x16_t *)(a18 + 228));
    *(int8x16_t *)(a18 + 228) = v257;
    v258 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(a18 + 244), *(float32x2_t *)v246.i8), *(int8x8_t *)v246.i8, *(int8x8_t *)(a18 + 244));
    *(float32x2_t *)(a18 + 244) = v258;
    if (*(float *)v243.i32 >= *(float *)(a18 + 252))
      v243.i32[0] = *(_DWORD *)(a18 + 252);
    *(_DWORD *)(a18 + 252) = v243.i32[0];
    *(_DWORD *)(a18 + 256) = v243.i32[0];
    if (v244)
    {
      *(float *)v249.i32 = (float)((float)((float)((float)((float)((float)((float)((float)((float)(*(float *)&v247.i32[3]
                                                                                                 + 0.0)
                                                                                         + *(float *)v248.i32)
                                                                                 + *(float *)&v248.i32[1])
                                                                         + *(float *)&v248.i32[2])
                                                                 + *(float *)&v248.i32[3])
                                                         + *(float *)v249.i32)
                                                 + *(float *)&v249.i32[1])
                                         + *(float *)&v249.i32[2])
                                 + *(float *)&v249.i32[3])
                         * 0.11111;
      v259 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v249.i8, 0);
      *(int8x16_t *)(a18 + 116) = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v250, (float32x4_t)v259), v259, v250);
      *(int8x16_t *)(a18 + 132) = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v251, (float32x4_t)v259), v259, v251);
      *(int8x16_t *)(a18 + 148) = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v252, (float32x4_t)v259), v259, v252);
      *(int8x16_t *)(a18 + 164) = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v253, (float32x4_t)v259), v259, v253);
      *(int8x16_t *)(a18 + 180) = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v254, (float32x4_t)v259), v259, v254);
      *(int8x16_t *)(a18 + 196) = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v255, (float32x4_t)v259), v259, v255);
      *(int8x16_t *)(a18 + 212) = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v256, (float32x4_t)v259), v259, v256);
      *(int8x16_t *)(a18 + 228) = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v257, (float32x4_t)v259), v259, v257);
      *(int8x8_t *)(a18 + 244) = vbsl_s8((int8x8_t)vcgt_f32(v258, *(float32x2_t *)v259.i8), *(int8x8_t *)v259.i8, (int8x8_t)v258);
      if (*(float *)v249.i32 >= *(float *)v243.i32)
        v260 = *(float *)v243.i32;
      else
        v260 = *(float *)v249.i32;
      *(float *)(a18 + 252) = v260;
      *(float *)(a18 + 256) = v260;
    }
    goto LABEL_128;
  }
  if (*(_BYTE *)(a1 + 600))
  {
    v244 = 1;
    goto LABEL_121;
  }
LABEL_128:
  memmove(v354, (const void *)a18, 0x104uLL);
  v261 = vsqrtq_f32(*(float32x4_t *)(a18 + 16));
  *(float32x4_t *)a18 = vsqrtq_f32(*(float32x4_t *)a18);
  *(float32x4_t *)(a18 + 16) = v261;
  v262 = vsqrtq_f32(*(float32x4_t *)(a18 + 48));
  *(float32x4_t *)(a18 + 32) = vsqrtq_f32(*(float32x4_t *)(a18 + 32));
  *(float32x4_t *)(a18 + 48) = v262;
  v263 = vsqrtq_f32(*(float32x4_t *)(a18 + 80));
  *(float32x4_t *)(a18 + 64) = vsqrtq_f32(*(float32x4_t *)(a18 + 64));
  *(float32x4_t *)(a18 + 80) = v263;
  v264 = vsqrtq_f32(*(float32x4_t *)(a18 + 112));
  v265 = *(float *)(a18 + 132);
  v266 = sqrtf(*(float *)(a18 + 128));
  *(float32x4_t *)(a18 + 96) = vsqrtq_f32(*(float32x4_t *)(a18 + 96));
  *(float32x4_t *)(a18 + 112) = v264;
  v267 = sqrtf(v265);
  v357 = v266;
  *(float *)(a18 + 128) = v266;
  *(float *)(a18 + 132) = v267;
  v268 = sqrtf(*(float *)(a18 + 136));
  v269 = sqrtf(*(float *)(a18 + 140));
  *(float *)(a18 + 136) = v268;
  *(float *)(a18 + 140) = v269;
  v270 = sqrtf(*(float *)(a18 + 144));
  v271 = sqrtf(*(float *)(a18 + 148));
  *(float *)(a18 + 144) = v270;
  *(float *)(a18 + 148) = v271;
  v272 = sqrtf(*(float *)(a18 + 152));
  v273 = sqrtf(*(float *)(a18 + 156));
  *(float *)(a18 + 152) = v272;
  *(float *)(a18 + 156) = v273;
  v274 = sqrtf(*(float *)(a18 + 160));
  v275 = sqrtf(*(float *)(a18 + 164));
  *(float *)(a18 + 160) = v274;
  *(float *)(a18 + 164) = v275;
  v276 = sqrtf(*(float *)(a18 + 168));
  v277 = sqrtf(*(float *)(a18 + 172));
  *(float *)(a18 + 168) = v276;
  *(float *)(a18 + 172) = v277;
  v278 = sqrtf(*(float *)(a18 + 176));
  v279 = sqrtf(*(float *)(a18 + 180));
  *(float *)(a18 + 176) = v278;
  *(float *)(a18 + 180) = v279;
  v280 = sqrtf(*(float *)(a18 + 184));
  v281 = sqrtf(*(float *)(a18 + 188));
  *(float *)(a18 + 184) = v280;
  *(float *)(a18 + 188) = v281;
  v282 = sqrtf(*(float *)(a18 + 192));
  v283 = sqrtf(*(float *)(a18 + 196));
  *(float *)(a18 + 192) = v282;
  *(float *)(a18 + 196) = v283;
  v284 = sqrtf(*(float *)(a18 + 200));
  v285 = sqrtf(*(float *)(a18 + 204));
  *(float *)(a18 + 200) = v284;
  *(float *)(a18 + 204) = v285;
  v286 = sqrtf(*(float *)(a18 + 208));
  v287 = sqrtf(*(float *)(a18 + 212));
  *(float *)(a18 + 208) = v286;
  *(float *)(a18 + 212) = v287;
  v288 = sqrtf(*(float *)(a18 + 216));
  v289 = sqrtf(*(float *)(a18 + 220));
  *(float *)(a18 + 216) = v288;
  *(float *)(a18 + 220) = v289;
  v290 = sqrtf(*(float *)(a18 + 224));
  v291 = sqrtf(*(float *)(a18 + 228));
  *(float *)(a18 + 224) = v290;
  *(float *)(a18 + 228) = v291;
  v292 = sqrtf(*(float *)(a18 + 232));
  v293 = sqrtf(*(float *)(a18 + 236));
  *(float *)(a18 + 232) = v292;
  *(float *)(a18 + 236) = v293;
  v294 = sqrtf(*(float *)(a18 + 240));
  v295 = sqrtf(*(float *)(a18 + 244));
  *(float *)(a18 + 240) = v294;
  *(float *)(a18 + 244) = v295;
  v296 = sqrtf(*(float *)(a18 + 248));
  v297 = sqrtf(*(float *)(a18 + 252));
  *(float *)(a18 + 248) = v296;
  *(float *)(a18 + 252) = v297;
  v356 = sqrtf(*(float *)(a18 + 256));
  *(float *)(a18 + 256) = v356;
  if (!v245)
    v25 = 0;
  v29 = p_dst->u32[0];
  v298 = 1.0;
  if ((_DWORD)v29 == 1)
    goto LABEL_233;
  v299 = *(_QWORD *)(a13 + 512);
  v30 = p_dst->u32[1];
  if ((v299 & 0xFF00000000) != 0 && (int)v299 > 55)
  {
    v298 = 0.001;
    goto LABEL_233;
  }
  v300 = v357;
  if (v267 < v357)
    v300 = v267;
  v301 = (float *)(a18 + 132);
  if (v267 >= v357)
    v301 = (float *)(a18 + 128);
  if (v268 < v300)
  {
    v300 = v268;
    v301 = (float *)(a18 + 136);
  }
  if (v269 < v300)
  {
    v300 = v269;
    v301 = (float *)(a18 + 140);
  }
  if (v270 < v300)
  {
    v300 = v270;
    v301 = (float *)(a18 + 144);
  }
  if (v271 < v300)
  {
    v300 = v271;
    v301 = (float *)(a18 + 148);
  }
  if (v272 < v300)
  {
    v300 = v272;
    v301 = (float *)(a18 + 152);
  }
  if (v273 < v300)
  {
    v300 = v273;
    v301 = (float *)(a18 + 156);
  }
  if (v274 < v300)
  {
    v300 = v274;
    v301 = (float *)(a18 + 160);
  }
  if (v275 < v300)
  {
    v300 = v275;
    v301 = (float *)(a18 + 164);
  }
  if (v276 < v300)
  {
    v300 = v276;
    v301 = (float *)(a18 + 168);
  }
  if (v277 < v300)
  {
    v300 = v277;
    v301 = (float *)(a18 + 172);
  }
  if (v278 < v300)
  {
    v300 = v278;
    v301 = (float *)(a18 + 176);
  }
  if (v279 < v300)
  {
    v300 = v279;
    v301 = (float *)(a18 + 180);
  }
  if (v280 < v300)
  {
    v300 = v280;
    v301 = (float *)(a18 + 184);
  }
  if (v281 < v300)
  {
    v300 = v281;
    v301 = (float *)(a18 + 188);
  }
  if (v282 < v300)
  {
    v300 = v282;
    v301 = (float *)(a18 + 192);
  }
  if (v283 < v300)
  {
    v300 = v283;
    v301 = (float *)(a18 + 196);
  }
  if (v284 < v300)
  {
    v300 = v284;
    v301 = (float *)(a18 + 200);
  }
  if (v285 < v300)
  {
    v300 = v285;
    v301 = (float *)(a18 + 204);
  }
  if (v286 < v300)
  {
    v300 = v286;
    v301 = (float *)(a18 + 208);
  }
  if (v287 < v300)
  {
    v300 = v287;
    v301 = (float *)(a18 + 212);
  }
  if (v288 < v300)
  {
    v300 = v288;
    v301 = (float *)(a18 + 216);
  }
  if (v289 < v300)
  {
    v300 = v289;
    v301 = (float *)(a18 + 220);
  }
  if (v290 < v300)
  {
    v300 = v290;
    v301 = (float *)(a18 + 224);
  }
  if (v291 < v300)
  {
    v300 = v291;
    v301 = (float *)(a18 + 228);
  }
  if (v292 < v300)
  {
    v300 = v292;
    v301 = (float *)(a18 + 232);
  }
  if (v293 < v300)
  {
    v300 = v293;
    v301 = (float *)(a18 + 236);
  }
  if (v294 < v300)
  {
    v300 = v294;
    v301 = (float *)(a18 + 240);
  }
  if (v295 < v300)
  {
    v300 = v295;
    v301 = (float *)(a18 + 244);
  }
  if (v296 < v300)
  {
    v300 = v296;
    v301 = (float *)(a18 + 248);
  }
  if (v297 < v300)
  {
    v300 = v297;
    v301 = (float *)(a18 + 252);
  }
  if (v356 < v300)
    v301 = (float *)(a18 + 256);
  v18 = *v301;
  if (a14[50].i8[0])
  {
    v298 = fminf(v18, 0.001);
    goto LABEL_233;
  }
LABEL_203:
  if ((int)v30 < 1)
  {
    v304 = 0.0;
    v312 = 0.0;
  }
  else
  {
    v302 = 0;
    v303 = p_dst->i64[1];
    v304 = 0.0;
    do
    {
      v305 = (float *)(v303 + 4 * (int)v302);
      v306 = v305[11];
      v307 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*v305 * *v305) + 0.0) + (float)(v305[1] * v305[1])) + (float)(v305[2] * v305[2])) + (float)(v305[3] * v305[3])) + (float)(v305[4] * v305[4])) + (float)(v305[5] * v305[5])) + (float)(v305[6] * v305[6])) + (float)(v305[7] * v305[7])) + (float)(v305[8] * v305[8])) + (float)(v305[9] * v305[9])) + (float)(v305[10] * v305[10]))
                                                                                           + (float)(v306 * v306))
                                                                                   + (float)(v305[12] * v305[12]))
                                                                           + (float)(v305[13] * v305[13]))
                                                                   + (float)(v305[14] * v305[14]))
                                                           + (float)(v305[15] * v305[15]))
                                                   + (float)(v305[16] * v305[16]))
                                           + (float)(v305[17] * v305[17]))
                                   + (float)(v305[18] * v305[18]))
                           + (float)(v305[19] * v305[19]))
                   + (float)(v305[20] * v305[20]))
           + (float)(v305[21] * v305[21]);
      v308 = v305[33];
      v309 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v307 + (float)(v305[22] * v305[22])) + (float)(v305[23] * v305[23])) + (float)(v305[24] * v305[24])) + (float)(v305[25] * v305[25])) + (float)(v305[26] * v305[26])) + (float)(v305[27] * v305[27])) + (float)(v305[28] * v305[28])) + (float)(v305[29] * v305[29])) + (float)(v305[30] * v305[30])) + (float)(v305[31] * v305[31])) + (float)(v305[32] * v305[32]))
                                                                                           + (float)(v308 * v308))
                                                                                   + (float)(v305[34] * v305[34]))
                                                                           + (float)(v305[35] * v305[35]))
                                                                   + (float)(v305[36] * v305[36]))
                                                           + (float)(v305[37] * v305[37]))
                                                   + (float)(v305[38] * v305[38]))
                                           + (float)(v305[39] * v305[39]))
                                   + (float)(v305[40] * v305[40]))
                           + (float)(v305[41] * v305[41]))
                   + (float)(v305[42] * v305[42]))
           + (float)(v305[43] * v305[43]);
      v310 = v305[55];
      v311 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v309 + (float)(v305[44] * v305[44])) + (float)(v305[45] * v305[45])) + (float)(v305[46] * v305[46])) + (float)(v305[47] * v305[47])) + (float)(v305[48] * v305[48])) + (float)(v305[49] * v305[49])) + (float)(v305[50] * v305[50])) + (float)(v305[51] * v305[51])) + (float)(v305[52] * v305[52]))
                                                                                           + (float)(v305[53] * v305[53]))
                                                                                   + (float)(v305[54] * v305[54]))
                                                                           + (float)(v310 * v310))
                                                                   + (float)(v305[56] * v305[56]))
                                                           + (float)(v305[57] * v305[57]))
                                                   + (float)(v305[58] * v305[58]))
                                           + (float)(v305[59] * v305[59]))
                                   + (float)(v305[60] * v305[60]))
                           + (float)(v305[61] * v305[61]))
                   + (float)(v305[62] * v305[62]))
           + (float)(v305[63] * v305[63]);
      if (v304 < v311)
        v304 = v311;
      v302 += 64;
    }
    while (v30 << 6 != v302);
    v312 = 0.0;
    if ((int)v29 >= 2)
    {
      v313 = 1;
      v314 = (_DWORD)v30 << 6;
      do
      {
        v315 = v314;
        v316 = v30;
        do
        {
          v317 = (float *)(v303 + 4 * v315);
          v318 = v317[11];
          v319 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*v317 * *v317) + 0.0) + (float)(v317[1] * v317[1])) + (float)(v317[2] * v317[2])) + (float)(v317[3] * v317[3])) + (float)(v317[4] * v317[4])) + (float)(v317[5] * v317[5])) + (float)(v317[6] * v317[6])) + (float)(v317[7] * v317[7])) + (float)(v317[8] * v317[8])) + (float)(v317[9] * v317[9])) + (float)(v317[10] * v317[10]))
                                                                                               + (float)(v318 * v318))
                                                                                       + (float)(v317[12] * v317[12]))
                                                                               + (float)(v317[13] * v317[13]))
                                                                       + (float)(v317[14] * v317[14]))
                                                               + (float)(v317[15] * v317[15]))
                                                       + (float)(v317[16] * v317[16]))
                                               + (float)(v317[17] * v317[17]))
                                       + (float)(v317[18] * v317[18]))
                               + (float)(v317[19] * v317[19]))
                       + (float)(v317[20] * v317[20]))
               + (float)(v317[21] * v317[21]);
          v320 = v317[33];
          v321 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v319 + (float)(v317[22] * v317[22])) + (float)(v317[23] * v317[23])) + (float)(v317[24] * v317[24])) + (float)(v317[25] * v317[25])) + (float)(v317[26] * v317[26])) + (float)(v317[27] * v317[27])) + (float)(v317[28] * v317[28])) + (float)(v317[29] * v317[29])) + (float)(v317[30] * v317[30])) + (float)(v317[31] * v317[31])) + (float)(v317[32] * v317[32]))
                                                                                               + (float)(v320 * v320))
                                                                                       + (float)(v317[34] * v317[34]))
                                                                               + (float)(v317[35] * v317[35]))
                                                                       + (float)(v317[36] * v317[36]))
                                                               + (float)(v317[37] * v317[37]))
                                                       + (float)(v317[38] * v317[38]))
                                               + (float)(v317[39] * v317[39]))
                                       + (float)(v317[40] * v317[40]))
                               + (float)(v317[41] * v317[41]))
                       + (float)(v317[42] * v317[42]))
               + (float)(v317[43] * v317[43]);
          v322 = v317[55];
          v323 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v321 + (float)(v317[44] * v317[44])) + (float)(v317[45] * v317[45])) + (float)(v317[46] * v317[46])) + (float)(v317[47] * v317[47])) + (float)(v317[48] * v317[48])) + (float)(v317[49] * v317[49])) + (float)(v317[50] * v317[50])) + (float)(v317[51] * v317[51])) + (float)(v317[52] * v317[52]))
                                                                                               + (float)(v317[53] * v317[53]))
                                                                                       + (float)(v317[54] * v317[54]))
                                                                               + (float)(v322 * v322))
                                                                       + (float)(v317[56] * v317[56]))
                                                               + (float)(v317[57] * v317[57]))
                                                       + (float)(v317[58] * v317[58]))
                                               + (float)(v317[59] * v317[59]))
                                       + (float)(v317[60] * v317[60]))
                               + (float)(v317[61] * v317[61]))
                       + (float)(v317[62] * v317[62]))
               + (float)(v317[63] * v317[63]);
          if (v312 < v323)
            v312 = v323;
          v315 += 64;
          --v316;
        }
        while (v316);
        ++v313;
        v314 += (_DWORD)v30 << 6;
      }
      while (v313 != v29);
    }
  }
  v324 = *(float *)(a1 + 588) * 64.0;
  if (v304 >= v324)
    v324 = v304;
  v325 = 1.0;
  v326 = 1.0;
  if (v312 >= v324)
    v326 = sqrtf(v304 / v312) * *(float *)(a1 + 592);
  if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2568) + 16))(*(_QWORD *)(a1 + 2568)) & 1) == 0)
  {
    v327 = *(_QWORD *)(a1 + 624);
    if (v327)
    {
      v328 = (float *)(v25 + 32);
      v329 = (float *)(v28 + 4);
      while ((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(v328 - 7) + 0.0) + *(v328 - 6)) + *(v328 - 5)) + *(v328 - 4)) + *(v328 - 3))
                                                                                            + *(v328 - 2))
                                                                                    + *(v328 - 1))
                                                                            + *v328)
                                                                    + v328[1])
                                                            + v328[2])
                                                    + v328[3])
                                            + v328[4])
                                    + v328[5])
                            + v328[6])
                    + v328[7]) <= (float)(*(float *)(a1 + 580)
                                        * (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(v329 - 7) + 0.0) + *(v329 - 6)) + *(v329 - 5)) + *(v329 - 4)) + *(v329 - 3)) + *(v329 - 2)) + *(v329 - 1)) + *v329)
                                                                                                + v329[1])
                                                                                        + v329[2])
                                                                                + v329[3])
                                                                        + v329[4])
                                                                + v329[5])
                                                        + v329[6])
                                                + v329[7])))
      {
        v328 += 65;
        v329 += 65;
        if (!--v327)
          goto LABEL_228;
      }
      v325 = *(float *)(a1 + 584);
    }
  }
LABEL_228:
  if (v326 >= v18)
    v298 = v18;
  else
    v298 = v326;
  if (v325 < v298)
    v298 = v325;
LABEL_233:
  *(float *)v24 = v298;
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2568) + 16))(*(_QWORD *)(a1 + 2568));
}

void webrtc::ConfigureSvcScreenSharing(webrtc *this@<X0>, float a2@<S0>, int a3@<W1>, unint64_t a4@<X2>, char **a5@<X8>)
{
  uint64_t v6;
  int v9;
  float v10;
  char *v11;
  char *v12;
  char *v13;
  float v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t i;
  char *v25;
  __int128 v26;
  float v27;
  unint64_t v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  __int128 v37;
  char v38;
  char *v39;

  if (a4 >= 3)
    v6 = 3;
  else
    v6 = a4;
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  if (v6)
  {
    if (!a5[2])
    {
      v9 = (int)this;
      v10 = fminf(a2, 5.0);
      v11 = (char *)operator new(0x24uLL);
      *(_DWORD *)v11 = v9;
      *((_DWORD *)v11 + 1) = a3;
      *((float *)v11 + 2) = v10;
      v11[12] = 1;
      *((_QWORD *)v11 + 2) = 0x96000000FALL;
      *((_QWORD *)v11 + 3) = 30;
      v11[32] = 1;
      v12 = v11 + 36;
      *a5 = v11;
      a5[1] = v11 + 36;
      a5[2] = v11 + 36;
      if (v6 == 1)
        return;
      v13 = v11;
      v14 = fminf(a2, 10.0);
      v15 = (unint64_t)a5[2];
      if ((unint64_t)v12 >= v15)
      {
        v18 = 2;
        v19 = 0x8E38E38E38E38E39 * ((uint64_t)(v15 - (_QWORD)v11) >> 2);
        if (2 * v19 > 2)
          v18 = 2 * v19;
        if (v19 >= 0x38E38E38E38E38ELL)
          v20 = 0x71C71C71C71C71CLL;
        else
          v20 = v18;
        if (!v20)
          goto LABEL_41;
        if (v20 > 0x71C71C71C71C71CLL)
          goto LABEL_42;
        v21 = 36 * v20;
        v22 = (char *)operator new(36 * v20);
        v17 = &v22[4 * ((v12 - v13) >> 2)];
        *(_DWORD *)v17 = v9;
        *((_DWORD *)v17 + 1) = a3;
        v23 = &v22[v21];
        *((float *)v17 + 2) = v14;
        v17[12] = 1;
        *((_QWORD *)v17 + 2) = 0x15E000001F4;
        *((_QWORD *)v17 + 3) = 200;
        v17[32] = 1;
        v16 = v17 + 36;
        if (v12 != v13)
        {
          for (i = 0; i != -36; i -= 36)
          {
            v25 = &v22[i];
            v26 = *(_OWORD *)&v13[i + 16];
            *(_OWORD *)v25 = *(_OWORD *)&v13[i];
            *((_OWORD *)v25 + 1) = v26;
            v25[32] = v13[i + 32];
          }
          v17 = v22;
        }
        *a5 = v17;
        a5[1] = v16;
        a5[2] = v23;
        if (v13)
          operator delete(v13);
      }
      else
      {
        *(_DWORD *)v12 = v9;
        *((_DWORD *)v11 + 10) = a3;
        *((float *)v11 + 11) = v14;
        v11[48] = 1;
        *(_QWORD *)(v11 + 52) = 0x15E000001F4;
        *(_QWORD *)(v11 + 60) = 200;
        v16 = v11 + 72;
        v17 = v11;
        v11[68] = 1;
      }
      a5[1] = v16;
      if (v6 == 2)
        return;
      v27 = fminf(a2, 30.0);
      v28 = (unint64_t)a5[2];
      if ((unint64_t)v16 < v28)
      {
        *(_DWORD *)v16 = v9;
        *((_DWORD *)v16 + 1) = a3;
        *((float *)v16 + 2) = v27;
        v16[12] = 1;
        *((_QWORD *)v16 + 2) = 0x3B6000003B6;
        *((_QWORD *)v16 + 3) = 500;
        v29 = v16 + 36;
        v16[32] = 1;
        goto LABEL_37;
      }
      v30 = 0x8E38E38E38E38E39 * ((v16 - v17) >> 2) + 1;
      if (v30 > 0x71C71C71C71C71CLL)
        abort();
      v31 = 0x8E38E38E38E38E39 * ((uint64_t)(v28 - (_QWORD)v17) >> 2);
      if (2 * v31 > v30)
        v30 = 2 * v31;
      if (v31 >= 0x38E38E38E38E38ELL)
        v32 = 0x71C71C71C71C71CLL;
      else
        v32 = v30;
      if (v32)
      {
        if (v32 <= 0x71C71C71C71C71CLL)
        {
          v33 = 36 * v32;
          v34 = (char *)operator new(36 * v32);
          v35 = &v34[4 * ((v16 - v17) >> 2)];
          *(_DWORD *)v35 = v9;
          *((_DWORD *)v35 + 1) = a3;
          v36 = &v34[v33];
          *((float *)v35 + 2) = v27;
          v35[12] = 1;
          *((_QWORD *)v35 + 2) = 0x3B6000003B6;
          *((_QWORD *)v35 + 3) = 500;
          v35[32] = 1;
          v29 = v35 + 36;
          if (v16 == v17)
          {
            *a5 = v35;
            a5[1] = v29;
            a5[2] = v36;
            if (!v17)
              goto LABEL_37;
          }
          else
          {
            do
            {
              v37 = *(_OWORD *)(v16 - 20);
              v38 = *(v16 - 4);
              v39 = v35 - 36;
              *(_OWORD *)(v35 - 36) = *(_OWORD *)(v16 - 36);
              *(_OWORD *)(v35 - 20) = v37;
              *(v35 - 4) = v38;
              v16 -= 36;
              v35 -= 36;
            }
            while (v16 != v17);
            *a5 = v39;
            a5[1] = v29;
            a5[2] = v36;
            if (!v17)
              goto LABEL_37;
          }
          operator delete(v17);
LABEL_37:
          a5[1] = v29;
          return;
        }
LABEL_42:
        std::__throw_bad_array_new_length[abi:sn180100]();
      }
    }
LABEL_41:
    __break(1u);
    goto LABEL_42;
  }
}

void webrtc::ConfigureSvcNormalVideo(unint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, char **a7@<X8>, float a8@<S0>)
{
  unint64_t v14;
  unint64_t v15;
  float v16;
  float v17;
  unint64_t v18;
  __int128 v19;
  float v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char **v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  float *v38;
  char *v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char v47;
  double v48;
  double v49;
  int v50;
  int v51;
  unsigned int v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  char *v57;
  char *v58;
  char *v59;
  __int128 v60;
  char *v61;
  float *v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v68;

  if (a1 >= a2)
    v14 = 240;
  else
    v14 = 135;
  if (a1 >= a2)
    v15 = 135;
  else
    v15 = 240;
  v16 = log2f((float)a1 / (float)v14);
  if (v16 <= 0.0)
    v17 = 1.0;
  else
    v17 = v16 + 1.0;
  v18 = vcvtms_u32_f32(v17);
  *(float *)&v19 = log2f((float)a2 / (float)v15);
  if (*(float *)&v19 <= 0.0)
    v20 = 1.0;
  else
    v20 = *(float *)&v19 + 1.0;
  v21 = vcvtms_u32_f32(v20);
  if (v21 >= v18)
    v22 = v18;
  else
    v22 = v21;
  if (v22 < a4)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v23, v24, v25, v26, v27, v28, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp9/svc_config.cc");
    v30 = a7;
    if (v22 <= a3 + 1)
      v31 = a3 + 1;
    else
      v31 = v22;
    if (*(_BYTE *)(a6 + 44))
      goto LABEL_23;
LABEL_35:
    v33 = 1 << (v31 + ~(_BYTE)a3);
    goto LABEL_36;
  }
  v30 = a7;
  if (a4 <= a3 + 1)
    v31 = a3 + 1;
  else
    v31 = a4;
  if (!*(_BYTE *)(a6 + 44))
    goto LABEL_35;
LABEL_23:
  if (!v31)
  {
    v38 = 0;
    *v30 = 0;
    v30[1] = 0;
    v30[2] = 0;
    v63 = a3;
    goto LABEL_65;
  }
  v32 = 0;
  v33 = 1;
  do
  {
    v35 = *(_DWORD *)(a6 + 4 * v32 + 28);
    v36 = v33 % v35;
    if (v33 % v35)
    {
      v37 = *(_DWORD *)(a6 + 4 * v32 + 28);
      do
      {
        v34 = v36;
        v36 = v37 % v36;
        v37 = v34;
      }
      while (v36);
    }
    else
    {
      v34 = *(_DWORD *)(a6 + 4 * v32 + 28);
    }
    v33 *= v35 / v34;
    ++v32;
  }
  while (v32 != v31);
LABEL_36:
  v38 = 0;
  *v30 = 0;
  v30[1] = 0;
  v30[2] = 0;
  v63 = a3;
  if (v31 > a3)
  {
    v38 = 0;
    v39 = 0;
    v40 = a1 / v33 * v33;
    v41 = a2 / v33 * v33;
    v65 = v40;
    v66 = v31;
    v64 = v41;
    while (1)
    {
      while (1)
      {
        if (*(_BYTE *)(a6 + 44))
        {
          v42 = a6 + 4 * a3;
          v43 = *(int *)(v42 + 12);
          v44 = *(int *)(v42 + 28);
          v45 = v40 * v43 / v44;
          v46 = v41 * v43 / v44;
        }
        else
        {
          v47 = v31 + ~(_BYTE)a3;
          v45 = v40 >> v47;
          v46 = v41 >> v47;
        }
        v48 = (double)(unint64_t)((int)v46 * (int)v45);
        v49 = sqrt(v48);
        v50 = ((int)((v49 * 600.0 + -95000.0) / 1000.0) & ~((int)((v49 * 600.0 + -95000.0) / 1000.0) >> 31)) <= 0x1E
            ? 30
            : (int)((v49 * 600.0 + -95000.0) / 1000.0) & ~((int)((v49 * 600.0 + -95000.0) / 1000.0) >> 31);
        *(double *)&v19 = (v48 * 1.6 + 50000.0) / 1000.0;
        v51 = (int)*(double *)&v19;
        v52 = (v50 + (int)*(double *)&v19) >> 1;
        v53 = (unint64_t)v30[2];
        if ((unint64_t)v38 >= v53)
          break;
        if (!v38)
          goto LABEL_69;
        *(_DWORD *)v38 = v45;
        *((_DWORD *)v38 + 1) = v46;
        v38[2] = a8;
        *((_BYTE *)v38 + 12) = a5;
        *((_DWORD *)v38 + 4) = v51;
        *((_DWORD *)v38 + 5) = v52;
        *((_DWORD *)v38 + 6) = v50;
        v38[7] = 0.0;
        *((_BYTE *)v38 + 32) = 1;
        v38 += 9;
        v30[1] = (char *)v38;
        if (++a3 == v31)
          goto LABEL_65;
      }
      v54 = 0x8E38E38E38E38E39 * (((char *)v38 - v39) >> 2) + 1;
      if (v54 > 0x71C71C71C71C71CLL)
        goto LABEL_70;
      v55 = 0x8E38E38E38E38E39 * ((uint64_t)(v53 - (_QWORD)v39) >> 2);
      if (2 * v55 > v54)
        v54 = 2 * v55;
      if (v55 >= 0x38E38E38E38E38ELL)
        v56 = 0x71C71C71C71C71CLL;
      else
        v56 = v54;
      if (!v56)
        goto LABEL_69;
      if (v56 > 0x71C71C71C71C71CLL)
        std::__throw_bad_array_new_length[abi:sn180100]();
      v68 = 36 * v56;
      v57 = (char *)operator new(36 * v56);
      v58 = &v57[4 * (((char *)v38 - v39) >> 2)];
      *(_DWORD *)v58 = v45;
      *((_DWORD *)v58 + 1) = v46;
      *((float *)v58 + 2) = a8;
      v58[12] = a5;
      *((_DWORD *)v58 + 4) = v51;
      *((_DWORD *)v58 + 5) = v52;
      *((_DWORD *)v58 + 6) = v50;
      *((_DWORD *)v58 + 7) = 0;
      v58[32] = 1;
      if (v38 != (float *)v39)
        break;
      v61 = &v57[4 * (((char *)v38 - v39) >> 2)];
      v30 = a7;
      v38 = (float *)(v58 + 36);
      *a7 = v58;
      a7[1] = v58 + 36;
      a7[2] = &v57[v68];
      if (v39)
        goto LABEL_63;
LABEL_38:
      v39 = v61;
      v40 = v65;
      v31 = v66;
      v41 = v64;
      v30[1] = (char *)v38;
      if (++a3 == v66)
        goto LABEL_65;
    }
    v59 = &v57[4 * (((char *)v38 - v39) >> 2)];
    v30 = a7;
    do
    {
      v19 = *(_OWORD *)(v38 - 9);
      v60 = *(_OWORD *)(v38 - 5);
      v61 = v59 - 36;
      *(v59 - 4) = *((_BYTE *)v38 - 4);
      *(_OWORD *)(v59 - 20) = v60;
      *(_OWORD *)(v59 - 36) = v19;
      v38 -= 9;
      v59 -= 36;
    }
    while (v38 != (float *)v39);
    v38 = (float *)(v58 + 36);
    *a7 = v61;
    a7[1] = v58 + 36;
    a7[2] = &v57[v68];
    if (!v39)
      goto LABEL_38;
LABEL_63:
    operator delete(v39);
    v30 = a7;
    goto LABEL_38;
  }
LABEL_65:
  if (v63)
  {
    v62 = (float *)*v30;
    if (v38 == (float *)*v30)
    {
LABEL_69:
      __break(1u);
LABEL_70:
      abort();
    }
    *((_DWORD *)v62 + 6) = 30;
    *(float *)&v19 = v62[4];
    *((_DWORD *)v62 + 4) = ((double)(unint64_t)v19 * 1.1);
  }
}

void webrtc::GetVp9SvcConfig(webrtc *this@<X0>, uint64_t a2@<X4>, uint64_t a3@<X5>, uint64_t a4@<X6>, uint64_t a5@<X7>, uint64_t a6@<X8>)
{
  unsigned int v7;
  uint64_t v8;
  int v10;
  unsigned int v11;
  unsigned int v12;
  float v13;
  float v14;
  float v15;
  float v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float v24;
  float v25;
  unint64_t v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  float v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  __int128 v56;
  __int128 v57;
  int v58;
  char v59;

  v7 = *((unsigned __int16 *)this + 186);
  if (v7 <= 0xFF)
    goto LABEL_34;
  v8 = a6;
  a6 = *((_WORD *)this + 186);
  if (*((_WORD *)this + 186) >= 0x22u)
  {
LABEL_35:
    v29 = (uint64_t)rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/svc/scalability_mode_util.cc", 309, "index < kNumScalabilityModes", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long> const&)::t, a2, a3, a4, a5, a6);
    goto LABEL_36;
  }
                                                                        + 24];
  v11 = *((unsigned __int16 *)this + 2);
  v12 = *((unsigned __int16 *)this + 3);
  if (v11 >= v12)
    v13 = 240.0;
  else
    v13 = 135.0;
  if (v11 >= v12)
    v14 = 135.0;
  else
    v14 = 240.0;
  v15 = log2f((float)v11 / v13);
  if (v15 <= 0.0)
    v16 = 1.0;
  else
    v16 = v15 + 1.0;
  v17 = vcvtms_u32_f32(v16);
  v24 = log2f((float)v12 / v14);
  if (v24 <= 0.0)
    v25 = 1.0;
  else
    v25 = v24 + 1.0;
  v26 = vcvtms_u32_f32(v25);
  if (v26 >= v17)
    v27 = v17;
  else
    v27 = v26;
  LOBYTE(v28) = v7;
  if (v10 > v27)
  {
    v28 = webrtc::LimitNumSpatialLayers(v7, v27, v18, v19, v20, v21, v22, v23);
    v29 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>();
    if ((v29 & 1) != 0)
    {
      *((_WORD *)this + 186) = v28 | 0x100;
      if (v28 >= 0x22)
      {
        v29 = (uint64_t)rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/svc/scalability_mode_util.cc", 309, "index < kNumScalabilityModes", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long> const&)::t, v33, v34, v35, v36, v28);
        goto LABEL_36;
      }
    }
    else
    {
      if (v7 >= 0x22u
        || (v37 = (char)v7,
            v38 = *(_QWORD *)((char *)&unk_208F1C650 + v37 * 8),
            v55 = off_24C0C1CB8[v37],
            *(_QWORD *)&v56 = v38,
            v28 >= 0x22))
      {
LABEL_36:
        rtc::webrtc_checks_impl::UnreachableCodeReached((rtc::webrtc_checks_impl *)v29);
      }
      rtc::webrtc_logging_impl::Log("\r\t\v\t\v", v30, v31, v32, v33, v34, v35, v36, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp9/svc_config.cc");
      *((_WORD *)this + 186) = v28 | 0x100;
    }
  }
                                                                                           + 32];
  if (v28 >= 0x22u)
  {
    v29 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>();
    if ((v29 & 1) == 0)
    {
      if (v28 >= 0x22u)
        goto LABEL_36;
      v53 = (char)v28;
      v54 = *(_QWORD *)((char *)&unk_208F1C650 + v53 * 8);
      v55 = off_24C0C1CB8[v53];
      *(_QWORD *)&v56 = v54;
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*> const&)::t, v46, v47, v48, v49, v50, v51, v52, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp9/svc_config.cc");
    }
    *(_QWORD *)v8 = 0;
    *(_QWORD *)(v8 + 8) = 0;
    *(_QWORD *)(v8 + 16) = 0;
    return;
  }
  v39 = (uint64_t)*(&off_24C0C1BA8 + (char)v28);
  v40 = *(int *)(v39 + 16);
  v41 = *(_DWORD *)(v39 + 20);
  v42 = *((unsigned __int16 *)this + 2);
  v43 = *((unsigned __int16 *)this + 3);
  v44 = (float)*((unsigned int *)this + 5);
  LOBYTE(v55) = *(_DWORD *)(v39 + 16);
  BYTE3(v55) = BYTE3(v40);
  *(_WORD *)((char *)&v55 + 1) = v40 >> 8;
  HIDWORD(v55) = v41;
  v56 = *(_OWORD *)(v39 + 24);
  v57 = *(_OWORD *)(v39 + 40);
  v58 = *(_DWORD *)(v39 + 56);
  v59 = 1;
  webrtc::ConfigureSvcNormalVideo(v42, v43, 0, v40, v41, (uint64_t)&v55, (char **)v8, v44);
  a6 = *(_QWORD *)v8;
  if (*(_QWORD *)(v8 + 8) == *(_QWORD *)v8)
  {
LABEL_34:
    __break(1u);
    goto LABEL_35;
  }
  *(_DWORD *)(a6 + 24) = 30;
  if (v10 == 1)
  {
    v45 = *(_QWORD *)((char *)this + 12);
    *(_DWORD *)(a6 + 16) = v45;
    *(_QWORD *)(a6 + 20) = v45;
  }
}

webrtc::SvcRateAllocator *webrtc::SvcRateAllocator::SvcRateAllocator(webrtc::SvcRateAllocator *this, const webrtc::VideoCodec *a2)
{
  void *v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void **v9;
  void **v10;
  void *v11;
  void *v13;
  void *__p;
  void **v15;
  uint64_t v16;
  uint64_t v17;

  *(_QWORD *)this = off_24C0C1DD8;
  v4 = memcpy((char *)this + 8, a2, 0x180uLL);
  v5 = *((unsigned __int16 *)a2 + 186);
  if (v5 >= 0x100
    && *((_WORD *)a2 + 186) <= 0x21u
    && ((*((void (**)(uint64_t *__return_ptr, void *))*(&off_24C0C1E00 + (char)v5) + 1))(&v17, v4), v17))
  {
    (*(void (**)(void **__return_ptr))(*(_QWORD *)v17 + 16))(&v13);
    v6 = (int)v13;
    v7 = SHIDWORD(v13);
    v8 = v17;
    v17 = 0;
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  }
  else if (*(_DWORD *)a2 == 2)
  {
    v6 = *((unsigned __int8 *)a2 + 366);
    v7 = *((unsigned __int8 *)a2 + 356);
  }
  else
  {
    v6 = 1;
    v7 = 1;
  }
  *((_QWORD *)this + 49) = v6;
  *((_QWORD *)this + 50) = v7;
  v15 = 0;
  v16 = 0;
  v13 = &unk_24C0B3F60;
  __p = 0;
  webrtc::StableTargetRateExperiment::StableTargetRateExperiment((uint64_t)this + 408, (uint64_t)&v13, 1.2, 1.35);
  v13 = &unk_24C0B4260;
  v9 = (void **)__p;
  if (__p)
  {
    v10 = v15;
    v11 = __p;
    if (v15 != __p)
    {
      do
      {
        if (*((char *)v10 - 1) < 0)
          operator delete(*(v10 - 3));
        v10 -= 3;
      }
      while (v10 != v9);
      v11 = __p;
    }
    v15 = v9;
    operator delete(v11);
  }
  webrtc::SvcRateAllocator::GetLayerStartBitrates(a2, (_QWORD *)this + 77);
  *((_QWORD *)this + 83) = 0;
  return this;
}

void webrtc::SvcRateAllocator::GetLayerStartBitrates(webrtc::SvcRateAllocator *this@<X0>, _QWORD *a2@<X8>)
{
  webrtc::SvcRateAllocator *v3;
  unsigned int v4;
  unint64_t v5;
  void *v6;
  unint64_t v7;
  _DWORD *v8;
  unsigned int *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  unsigned int v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  BOOL v32;
  unint64_t v33;
  uint64_t v35;
  webrtc::SvcRateAllocator *v36;
  char *v37;
  char *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unsigned int *v43;
  _DWORD *v44;
  uint64_t v45;
  char *v47[6];
  void *__p[3];

  v3 = this;
  *a2 = 0;
  v4 = *((unsigned __int16 *)this + 186);
  if (v4 >= 0x100
    && *((_WORD *)this + 186) <= 0x21u
    && ((*((void (**)(void **__return_ptr))*(&off_24C0C1E00 + (char)v4) + 1))(__p), __p[0]))
  {
    (*(void (**)(char **__return_ptr))(*(_QWORD *)__p[0] + 16))(v47);
    v5 = SLODWORD(v47[0]);
    v6 = __p[0];
    __p[0] = 0;
    if (v6)
      (*(void (**)(void *))(*(_QWORD *)v6 + 8))(v6);
    if (!v5)
      return;
  }
  else if (*(_DWORD *)v3 == 2)
  {
    v5 = *((unsigned __int8 *)v3 + 366);
    if (!*((_BYTE *)v3 + 366))
      return;
  }
  else
  {
    v5 = 1;
  }
  v7 = 0;
  v8 = (_DWORD *)((char *)v3 + 164);
  v9 = (unsigned int *)((char *)v3 + 168);
  v10 = 176;
  while (!*((_BYTE *)v3 + 36 * v7 + 176))
  {
    ++v7;
    v8 += 9;
    v9 += 9;
    v10 += 36;
    if (v7 == v5)
      return;
  }
  if (v7 < v5)
  {
    v11 = v7;
    while (*((_BYTE *)v3 + v10))
    {
      ++v11;
      v10 += 36;
      if (v5 == v11)
      {
        v11 = v5;
        break;
      }
    }
    v12 = v11 - v7;
    if (v11 != v7)
    {
      v13 = 0;
      v44 = v8;
      v14 = 1;
      v42 = v11 - v7;
      v43 = v9;
      do
      {
        v15 = v14 - 1;
        v45 = v13;
        if (v14 == 1)
        {
          v16 = 1000 * *((unsigned int *)v3 + 42);
        }
        else if (*((_DWORD *)v3 + 81))
        {
          v17 = 0;
          v18 = v8;
          v19 = v13;
          do
          {
            v20 = *v18;
            v18 += 9;
            v21 = v17 + 1000 * v20;
            if (v17 == 0x8000000000000000)
              v21 = 0x8000000000000000;
            if (v17 != 0x7FFFFFFFFFFFFFFFLL)
              v17 = v21;
            --v19;
          }
          while (v19);
          v16 = 0x7FFFFFFFFFFFFFFFLL;
          if (v17 != 0x7FFFFFFFFFFFFFFFLL)
          {
            v22 = v17 + 1000 * *((unsigned int *)v3 + 9 * v15 + 9 * v7 + 42);
            if (v17 == 0x8000000000000000)
              v16 = 0x8000000000000000;
            else
              v16 = v22;
          }
        }
        else
        {
          if (v14 < 2)
          {
            v24 = 0;
            v16 = 1000 * *((unsigned int *)v3 + 9 * v15 + 9 * v7 + 42);
          }
          else
          {
            v23 = 0;
            v24 = 0;
            v25 = v9;
            v26 = v13;
            do
            {
              v27 = v24 + 1000 * *v25;
              if (v24 == 0x8000000000000000)
                v27 = 0x8000000000000000;
              if (v24 != 0x7FFFFFFFFFFFFFFFLL)
                v24 = v27;
              v28 = v23 + 1000 * *(v25 - 2);
              if (v23 == 0x8000000000000000)
                v28 = 0x8000000000000000;
              if (v23 != 0x7FFFFFFFFFFFFFFFLL)
                v23 = v28;
              v25 += 9;
              --v26;
            }
            while (v26);
            v16 = 0x7FFFFFFFFFFFFFFFLL;
            if (v23 != 0x7FFFFFFFFFFFFFFFLL)
            {
              v29 = v23 + 1000 * *((unsigned int *)v3 + 9 * v15 + 9 * v7 + 42);
              if (v23 == 0x8000000000000000)
                v16 = 0x8000000000000000;
              else
                v16 = v29;
            }
          }
          while (1)
          {
            v30 = v16 == 0x7FFFFFFFFFFFFFFFLL || v24 == 0x8000000000000000;
            if (!v30 && (v16 == 0x8000000000000000 || v24 == 0x7FFFFFFFFFFFFFFFLL || (uint64_t)(v16 - v24) < 2))
              break;
            v31 = v16 + v24;
            if ((uint64_t)(v16 + v24) < 0 != __OFADD__(v16, v24))
              ++v31;
            v32 = v16 == 0x8000000000000000 || v24 == 0x8000000000000000;
            v33 = v31 >> 1;
            if (v32)
              v33 = 0xC000000000000000;
            if (v16 == 0x7FFFFFFFFFFFFFFFLL || v24 == 0x7FFFFFFFFFFFFFFFLL)
              v35 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v35 = v33;
            v36 = v3;
            v37 = v47[0];
            v38 = v47[1];
            if (v47[0])
              operator delete(v47[0]);
            if (__p[0])
              operator delete(__p[0]);
            if ((v38 - v37) >> 3 == v14)
              v16 = v35;
            else
              v24 = v35;
            v3 = v36;
          }
          v12 = v42;
          v9 = v43;
        }
        v39 = (_QWORD *)a2[1];
        v40 = a2[2];
        if ((*a2 & 1) == 0)
        {
          v39 = a2 + 1;
          v40 = 5;
        }
        v41 = *a2 >> 1;
        if (v41 == v40)
        {
          absl::inlined_vector_internal::Storage<long long,5ul,std::allocator<long long>>::EmplaceBackSlow<long long>((uint64_t)a2, v16);
        }
        else
        {
          if (!v39)
          {
            __break(1u);
            return;
          }
          v39[v41] = v16;
          *a2 += 2;
        }
        ++v14;
        v13 = v45 + 1;
        v8 = v44;
      }
      while (v14 <= v12);
    }
  }
}

void webrtc::SvcRateAllocator::Allocate(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned int *a3@<X4>, uint64_t a4@<X5>, char *a5@<X6>, uint64_t a6@<X7>, uint64_t a7@<X8>)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v12;
  unint64_t v13;
  unsigned __int8 *v14;
  int v15;
  unsigned __int8 *v16;
  unint64_t v17;
  int v18;
  __int128 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  unint64_t v34;
  int64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  char *v45;
  __int128 *v46;
  unsigned int *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  __int128 *v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  char *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;
  BOOL v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t v85;
  BOOL v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  __int128 *v90;
  unsigned int *v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  __int128 *v96;
  unsigned int *v97;
  int v98;
  uint64_t v99;
  uint64_t v100;
  __int128 *v101;
  unsigned int *v102;
  int v103;
  uint64_t v104;
  uint64_t v105;
  __int128 *v106;
  unsigned int *v107;
  int v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  BOOL v112;
  uint64_t v113;
  BOOL v114;
  unint64_t v115;
  __int128 *v116;
  _DWORD *v117;
  uint64_t v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  unint64_t v124;
  __int128 *v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  int v136;
  char v137;
  _QWORD *v138;
  _BYTE *v139;

  v8 = *(_DWORD *)(a1 + 20);
  v9 = 1000 * v8;
  if (v9 >= *a2)
    v9 = *a2;
  if (v8)
    v10 = v9;
  else
    v10 = *a2;
  if (!*(_DWORD *)(a1 + 172))
  {
    *(_BYTE *)(a7 + 12) = 0;
    *(_BYTE *)(a7 + 16) = 0;
    *(_BYTE *)(a7 + 20) = 0;
    *(_BYTE *)(a7 + 24) = 0;
    *(_BYTE *)(a7 + 28) = 0;
    *(_BYTE *)(a7 + 32) = 0;
    *(_BYTE *)(a7 + 36) = 0;
    *(_BYTE *)(a7 + 40) = 0;
    *(_BYTE *)(a7 + 44) = 0;
    *(_BYTE *)(a7 + 48) = 0;
    *(_BYTE *)(a7 + 52) = 0;
    *(_BYTE *)(a7 + 56) = 0;
    *(_BYTE *)(a7 + 60) = 0;
    *(_BYTE *)(a7 + 64) = 0;
    *(_BYTE *)(a7 + 68) = 0;
    *(_BYTE *)(a7 + 72) = 0;
    *(_BYTE *)(a7 + 76) = 0;
    *(_BYTE *)(a7 + 80) = 0;
    *(_BYTE *)(a7 + 84) = 0;
    *(_BYTE *)(a7 + 88) = 0;
    *(_BYTE *)(a7 + 92) = 0;
    *(_BYTE *)(a7 + 96) = 0;
    *(_BYTE *)(a7 + 100) = 0;
    *(_BYTE *)(a7 + 104) = 0;
    *(_BYTE *)(a7 + 108) = 0;
    *(_BYTE *)(a7 + 112) = 0;
    *(_BYTE *)(a7 + 116) = 0;
    *(_BYTE *)(a7 + 120) = 0;
    *(_BYTE *)(a7 + 124) = 0;
    *(_BYTE *)(a7 + 128) = 0;
    *(_BYTE *)(a7 + 132) = 0;
    *(_BYTE *)(a7 + 136) = 0;
    *(_BYTE *)(a7 + 140) = 0;
    *(_BYTE *)(a7 + 144) = 0;
    *(_BYTE *)(a7 + 148) = 0;
    *(_BYTE *)(a7 + 152) = 0;
    *(_BYTE *)(a7 + 156) = 0;
    *(_BYTE *)(a7 + 160) = 0;
    *(_BYTE *)(a7 + 164) = 0;
    *(_BYTE *)(a7 + 8) = 1;
    *(_DWORD *)a7 = v10;
    *(_DWORD *)(a7 + 4) = v10;
    return;
  }
  v12 = *(_QWORD *)(a1 + 392);
  if (v12)
  {
    v13 = 0;
    v14 = (unsigned __int8 *)(a1 + 184);
    while (1)
    {
      v15 = *v14;
      v14 += 36;
      if (v15)
        break;
      if (v12 == ++v13)
        goto LABEL_20;
    }
  }
  else
  {
    v13 = 0;
  }
  if (v13 >= v12)
    goto LABEL_20;
  v16 = (unsigned __int8 *)(a1 + 36 * v13 + 184);
  v17 = v13;
  while (1)
  {
    v18 = *v16;
    v16 += 36;
    if (!v18)
      break;
    if (v12 == ++v17)
    {
      v17 = *(_QWORD *)(a1 + 392);
      break;
    }
  }
  v19 = (__int128 *)(v17 - v13);
  if (v17 == v13)
  {
LABEL_20:
    *(_DWORD *)a7 = 0;
    *(_BYTE *)(a7 + 4) = 0;
    *(_BYTE *)(a7 + 8) = 0;
    *(_BYTE *)(a7 + 12) = 0;
    *(_BYTE *)(a7 + 16) = 0;
    *(_BYTE *)(a7 + 20) = 0;
    *(_BYTE *)(a7 + 24) = 0;
    *(_BYTE *)(a7 + 28) = 0;
    *(_BYTE *)(a7 + 32) = 0;
    *(_BYTE *)(a7 + 36) = 0;
    *(_BYTE *)(a7 + 40) = 0;
    *(_BYTE *)(a7 + 44) = 0;
    *(_BYTE *)(a7 + 48) = 0;
    *(_BYTE *)(a7 + 52) = 0;
    *(_BYTE *)(a7 + 56) = 0;
    *(_BYTE *)(a7 + 60) = 0;
    *(_BYTE *)(a7 + 64) = 0;
    *(_BYTE *)(a7 + 68) = 0;
    *(_BYTE *)(a7 + 72) = 0;
    *(_BYTE *)(a7 + 76) = 0;
    *(_BYTE *)(a7 + 80) = 0;
    *(_BYTE *)(a7 + 84) = 0;
    *(_BYTE *)(a7 + 88) = 0;
    *(_BYTE *)(a7 + 92) = 0;
    *(_BYTE *)(a7 + 96) = 0;
    *(_BYTE *)(a7 + 100) = 0;
    *(_BYTE *)(a7 + 104) = 0;
    *(_BYTE *)(a7 + 108) = 0;
    *(_BYTE *)(a7 + 112) = 0;
    *(_BYTE *)(a7 + 116) = 0;
    *(_BYTE *)(a7 + 120) = 0;
    *(_BYTE *)(a7 + 124) = 0;
    *(_BYTE *)(a7 + 128) = 0;
    *(_BYTE *)(a7 + 132) = 0;
    *(_BYTE *)(a7 + 136) = 0;
    *(_BYTE *)(a7 + 140) = 0;
    *(_BYTE *)(a7 + 144) = 0;
    *(_BYTE *)(a7 + 148) = 0;
    *(_BYTE *)(a7 + 152) = 0;
    *(_BYTE *)(a7 + 156) = 0;
    *(_BYTE *)(a7 + 160) = 0;
    *(_BYTE *)(a7 + 164) = 0;
    return;
  }
  if (*(_BYTE *)(a1 + 465) && (v20 = a2[1], v20 >= 1))
  {
    if (*(_DWORD *)(a1 + 332) == 1)
      v21 = 608;
    else
      v21 = 536;
    if (v20 >= v10)
      v22 = v10;
    else
      v22 = a2[1];
    v23 = *(_QWORD *)(a1 + 616);
    if (v23 < 2)
    {
      v24 = 0;
      v25 = 0;
      v26 = *(_QWORD *)(a1 + 664);
      if (!v26)
        goto LABEL_63;
      goto LABEL_60;
    }
    v32 = (_QWORD *)(a1 + 624);
    v33 = (_QWORD *)(a1 + 624);
    if ((v23 & 1) != 0)
      v33 = (_QWORD *)*v32;
    v34 = v23 >> 1;
    v24 = (((v23 >> 1) - 1) & 0x1FFFFFFFFFFFFFFFLL) + 1;
    if (v23 >> 1 == 1)
    {
      v26 = *(_QWORD *)(a1 + 664);
      if (v24 >= v26)
      {
        v25 = (((v23 >> 1) - 1) & 0x1FFFFFFFFFFFFFFFLL) + 1;
        goto LABEL_63;
      }
      goto LABEL_51;
    }
    v35 = llround((double)v22 / *(double *)(a1 + v21));
    v36 = 8 * v34 - 8;
    v25 = 1;
    while (v33[v25] <= v35)
    {
      ++v25;
      v36 -= 8;
      if (!v36)
      {
        v25 = (((v23 >> 1) - 1) & 0x1FFFFFFFFFFFFFFFLL) + 1;
        break;
      }
    }
    v26 = *(_QWORD *)(a1 + 664);
    if (v25 < v26)
    {
LABEL_51:
      if ((v23 & 1) != 0)
        v32 = (_QWORD *)*v32;
      if (v34 != 1)
      {
        v37 = 8 * v34 - 8;
        v38 = 1;
        while (v32[v38] <= v22)
        {
          ++v38;
          v37 -= 8;
          if (!v37)
            goto LABEL_60;
        }
        v24 = v38;
      }
LABEL_60:
      if (v24 >= v26)
        v25 = v26;
      else
        v25 = v24;
    }
  }
  else
  {
    v27 = *(_QWORD *)(a1 + 616);
    if (v27 >= 2)
    {
      v28 = (_QWORD *)(a1 + 624);
      if ((v27 & 1) != 0)
        v28 = (_QWORD *)*v28;
      v29 = v27 >> 1;
      v25 = ((v29 - 1) & 0x1FFFFFFFFFFFFFFFLL) + 1;
      if (v29 != 1)
      {
        v30 = 8 * v29 - 8;
        v31 = 1;
        while (v28[v31] <= v10)
        {
          ++v31;
          v30 -= 8;
          if (!v30)
            goto LABEL_63;
        }
        v25 = v31;
      }
    }
    else
    {
      v25 = 0;
    }
  }
LABEL_63:
  *(_QWORD *)(a1 + 664) = v25;
  *(_DWORD *)a7 = 0;
  *(_BYTE *)(a7 + 4) = 0;
  *(_BYTE *)(a7 + 8) = 0;
  *(_BYTE *)(a7 + 12) = 0;
  *(_BYTE *)(a7 + 16) = 0;
  *(_BYTE *)(a7 + 20) = 0;
  *(_BYTE *)(a7 + 24) = 0;
  *(_BYTE *)(a7 + 28) = 0;
  *(_BYTE *)(a7 + 32) = 0;
  *(_BYTE *)(a7 + 36) = 0;
  *(_BYTE *)(a7 + 40) = 0;
  *(_BYTE *)(a7 + 44) = 0;
  *(_BYTE *)(a7 + 48) = 0;
  *(_BYTE *)(a7 + 52) = 0;
  *(_BYTE *)(a7 + 56) = 0;
  *(_BYTE *)(a7 + 60) = 0;
  *(_BYTE *)(a7 + 64) = 0;
  *(_BYTE *)(a7 + 68) = 0;
  *(_BYTE *)(a7 + 72) = 0;
  *(_BYTE *)(a7 + 76) = 0;
  *(_BYTE *)(a7 + 80) = 0;
  *(_BYTE *)(a7 + 84) = 0;
  *(_BYTE *)(a7 + 88) = 0;
  *(_BYTE *)(a7 + 92) = 0;
  *(_BYTE *)(a7 + 96) = 0;
  *(_BYTE *)(a7 + 100) = 0;
  *(_BYTE *)(a7 + 104) = 0;
  *(_BYTE *)(a7 + 108) = 0;
  *(_BYTE *)(a7 + 112) = 0;
  *(_BYTE *)(a7 + 116) = 0;
  *(_BYTE *)(a7 + 120) = 0;
  *(_BYTE *)(a7 + 124) = 0;
  *(_BYTE *)(a7 + 128) = 0;
  *(_BYTE *)(a7 + 132) = 0;
  *(_BYTE *)(a7 + 136) = 0;
  *(_BYTE *)(a7 + 140) = 0;
  *(_BYTE *)(a7 + 144) = 0;
  *(_BYTE *)(a7 + 148) = 0;
  *(_BYTE *)(a7 + 152) = 0;
  *(_BYTE *)(a7 + 156) = 0;
  *(_BYTE *)(a7 + 160) = 0;
  *(_BYTE *)(a7 + 164) = 0;
  v39 = *(unsigned int *)(a1 + 332);
  if (!(_DWORD)v39)
  {
    v124 = v25;
    v125 = v19;
    if (v25)
    {
      v44 = (char *)*((_QWORD *)&v126 + 1);
      v45 = (char *)v126;
      if (v138)
        operator delete(v138);
      v10 = v25;
    }
    else
    {
      v45 = (char *)operator new(8uLL);
      *(_QWORD *)v45 = v10;
      v44 = v45 + 8;
      v10 = 1;
    }
    v25 = 0;
    LODWORD(v126) = 0;
    BYTE4(v126) = 0;
    BYTE8(v126) = 0;
    BYTE12(v126) = 0;
    LOBYTE(v127) = 0;
    BYTE4(v127) = 0;
    BYTE8(v127) = 0;
    BYTE12(v127) = 0;
    LOBYTE(v128) = 0;
    BYTE4(v128) = 0;
    BYTE8(v128) = 0;
    BYTE12(v128) = 0;
    LOBYTE(v129) = 0;
    BYTE4(v129) = 0;
    BYTE8(v129) = 0;
    BYTE12(v129) = 0;
    LOBYTE(v130) = 0;
    BYTE4(v130) = 0;
    BYTE8(v130) = 0;
    BYTE12(v130) = 0;
    LOBYTE(v131) = 0;
    BYTE4(v131) = 0;
    BYTE8(v131) = 0;
    BYTE12(v131) = 0;
    LOBYTE(v132) = 0;
    BYTE4(v132) = 0;
    BYTE8(v132) = 0;
    BYTE12(v132) = 0;
    LOBYTE(v133) = 0;
    BYTE4(v133) = 0;
    BYTE8(v133) = 0;
    BYTE12(v133) = 0;
    LOBYTE(v134) = 0;
    BYTE4(v134) = 0;
    BYTE8(v134) = 0;
    BYTE12(v134) = 0;
    LOBYTE(v135) = 0;
    BYTE4(v135) = 0;
    BYTE8(v135) = 0;
    v40 = v44 - v45;
    BYTE12(v135) = 0;
    v49 = 32 * v13;
    LOBYTE(v136) = 0;
    v19 = &v126;
    v137 = 0;
    while (1)
    {
      if ((v44 - v45) >> 3 == v25)
      {
LABEL_169:
        __break(1u);
        goto LABEL_170;
      }
      v50 = *(_QWORD *)(a1 + 400);
      switch(v50)
      {
        case 3:
          v51 = v138;
          v40 = v139 - (_BYTE *)v138;
          if ((unint64_t)(v139 - (_BYTE *)v138) <= 0x10)
            goto LABEL_169;
          if (v25 + v13 >= 5)
          {
LABEL_203:
            v52 = v13 + v25;
LABEL_204:
            rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_bitrate_allocation.cc", 27, "spatial_index < kMaxSpatialLayers", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, (uint64_t)a3, a4, (uint64_t)a5, a6, v52);
            while (1)
            {
LABEL_205:
              rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/svc/svc_rate_allocator.cc", 321, "num_layers_.temporal == 3", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, (uint64_t)a3, a4, (uint64_t)a5, a6, v50);
LABEL_206:
              rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_bitrate_allocation.cc", 27, "spatial_index < kMaxSpatialLayers", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, (uint64_t)a3, a4, v84, a6, v79);
            }
          }
          v63 = v126;
          v64 = (char *)&v126 + v49;
          v65 = v126;
          if (*((_BYTE *)&v126 + v49 + 8))
            v65 = v126 - (unint64_t)*((unsigned int *)v64 + 1);
          v66 = v138[2];
          v67 = v65 + v66;
          if (v67 <= 0xFFFFFFFFLL)
          {
            *((_DWORD *)v64 + 1) = v66;
            v64[8] = 1;
            v63 = v67;
            LODWORD(v126) = v67;
          }
          v68 = (char *)&v126 + v49;
          v69 = v63;
          if (*((_BYTE *)&v126 + v49 + 16))
            v69 = v63 - *((unsigned int *)v68 + 3);
          v70 = v69 + *v51;
          if (v70 <= 0xFFFFFFFFLL)
          {
            *((_DWORD *)v68 + 3) = *v51;
            v68[16] = 1;
            v63 = v70;
            LODWORD(v126) = v70;
          }
          v71 = (char *)&v126 + v49;
          if (*((_BYTE *)&v127 + v49 + 8))
            v63 -= *((unsigned int *)v71 + 5);
          v56 = v63 + v51[1];
          if (v56 > 0xFFFFFFFFLL)
            goto LABEL_80;
          v55 = (__int128 *)((char *)&v127 + 32 * v25 + 32 * v13 + 8);
          *((_DWORD *)v71 + 5) = v51[1];
          break;
        case 2:
          v51 = v138;
          v40 = v139 - (_BYTE *)v138;
          if ((unint64_t)(v139 - (_BYTE *)v138) <= 8)
            goto LABEL_169;
          if (v25 + v13 >= 5)
            goto LABEL_203;
          v57 = v126;
          v58 = (char *)&v126 + v49;
          v59 = v126;
          if (*((_BYTE *)&v126 + v49 + 8))
            v59 = v126 - (unint64_t)*((unsigned int *)v58 + 1);
          v60 = v138[1];
          v61 = v59 + v60;
          if (v61 <= 0xFFFFFFFFLL)
          {
            *((_DWORD *)v58 + 1) = v60;
            v58[8] = 1;
            v57 = v61;
            LODWORD(v126) = v61;
          }
          v62 = (char *)&v126 + v49;
          if (*((_BYTE *)&v126 + v49 + 16))
            v57 -= *((unsigned int *)v62 + 3);
          v56 = v57 + *v51;
          if (v56 > 0xFFFFFFFFLL)
            goto LABEL_80;
          v55 = &v126 + 2 * v25 + 2 * v13 + 1;
          *((_DWORD *)v62 + 3) = *v51;
          break;
        case 1:
          v51 = v138;
          v40 = (uint64_t)v139;
          if (v139 == (_BYTE *)v138)
            goto LABEL_169;
          v52 = v13 + v25;
          if (v13 + v25 >= 5)
            goto LABEL_204;
          v53 = v126;
          v54 = (char *)&v126 + v49;
          v55 = (__int128 *)((char *)&v126 + v49 + 8);
          if (*(_BYTE *)v55)
            v53 = v126 - (unint64_t)*((unsigned int *)v54 + 1);
          v56 = v53 + *v138;
          if (v56 > 0xFFFFFFFFLL)
            goto LABEL_80;
          *((_DWORD *)v54 + 1) = *v138;
          break;
        default:
          goto LABEL_205;
      }
      *(_BYTE *)v55 = 1;
      LODWORD(v126) = v56;
LABEL_80:
      operator delete(v51);
      ++v25;
      v49 += 32;
      if (v10 == v25)
      {
        operator delete(v45);
        v72 = v135;
        *(_OWORD *)(a7 + 128) = v134;
        *(_OWORD *)(a7 + 144) = v72;
        *(_DWORD *)(a7 + 160) = v136;
        v73 = v131;
        *(_OWORD *)(a7 + 64) = v130;
        *(_OWORD *)(a7 + 80) = v73;
        v74 = v133;
        *(_OWORD *)(a7 + 96) = v132;
        *(_OWORD *)(a7 + 112) = v74;
        v75 = v127;
        *(_OWORD *)a7 = v126;
        *(_OWORD *)(a7 + 16) = v75;
        v76 = v129;
        *(_OWORD *)(a7 + 32) = v128;
        *(_OWORD *)(a7 + 48) = v76;
        v25 = v124;
        v19 = v125;
        goto LABEL_202;
      }
    }
  }
  LODWORD(v126) = 0;
  BYTE4(v126) = 0;
  BYTE8(v126) = 0;
  BYTE12(v126) = 0;
  LOBYTE(v127) = 0;
  BYTE4(v127) = 0;
  BYTE8(v127) = 0;
  BYTE12(v127) = 0;
  LOBYTE(v128) = 0;
  BYTE4(v128) = 0;
  BYTE8(v128) = 0;
  BYTE12(v128) = 0;
  LOBYTE(v129) = 0;
  BYTE4(v129) = 0;
  BYTE8(v129) = 0;
  BYTE12(v129) = 0;
  LOBYTE(v130) = 0;
  BYTE4(v130) = 0;
  BYTE8(v130) = 0;
  BYTE12(v130) = 0;
  LOBYTE(v131) = 0;
  BYTE4(v131) = 0;
  BYTE8(v131) = 0;
  BYTE12(v131) = 0;
  LOBYTE(v132) = 0;
  BYTE4(v132) = 0;
  BYTE8(v132) = 0;
  BYTE12(v132) = 0;
  LOBYTE(v133) = 0;
  BYTE4(v133) = 0;
  BYTE8(v133) = 0;
  BYTE12(v133) = 0;
  LOBYTE(v134) = 0;
  BYTE4(v134) = 0;
  BYTE8(v134) = 0;
  BYTE12(v134) = 0;
  LOBYTE(v135) = 0;
  BYTE4(v135) = 0;
  BYTE8(v135) = 0;
  BYTE12(v135) = 0;
  LOBYTE(v136) = 0;
  if (!v25 || 1000 * *(unsigned int *)(a1 + 36 * v13 + 176) > v10)
  {
    v40 = 0;
    if (v13 >= 5)
      goto LABEL_208;
    goto LABEL_197;
  }
  if (v25 + v13 <= v13)
  {
    if (!v13)
      goto LABEL_201;
    v40 = 0;
    v41 = 0;
    v77 = 0;
    goto LABEL_183;
  }
  if (v10 != 0x7FFFFFFFFFFFFFFFLL)
  {
    v40 = 0;
    v78 = 0;
    v41 = 0;
    if (v13 <= 5)
      v79 = 5;
    else
      v79 = v13;
    v80 = v25 - 1;
    v81 = 32 * v13;
    v82 = a1 + 36 * v13 + 172;
    a3 = (unsigned int *)v82;
    do
    {
      v83 = *a3;
      a3 += 9;
      v77 = 1000 * v83;
      v84 = v10 - v41;
      if (v78)
        v84 = 0x8000000000000000;
      if (v41 == 0x8000000000000000)
        v84 = 0x7FFFFFFFFFFFFFFFLL;
      if (v84 < v77)
        v77 = v84;
      if (v79 == v13)
        goto LABEL_206;
      a4 = v13;
      a5 = (char *)&v126 + v81;
      v85 = v40;
      if (*((_BYTE *)&v126 + v81 + 8))
        v85 = v40 - *((unsigned int *)a5 + 1);
      a6 = v85 + v77;
      if (a6 <= 0xFFFFFFFFLL)
      {
        *((_DWORD *)a5 + 1) = v77;
        a5[8] = 1;
        v40 = a6;
        LODWORD(v126) = a6;
      }
      v86 = v77 == 0x8000000000000000 || v41 == 0x8000000000000000;
      v41 += v77;
      if (v86)
        v41 = 0x8000000000000000;
      if (v78)
        v41 = 0x7FFFFFFFFFFFFFFFLL;
      if (!v80)
        break;
      v87 = v41 == 0x8000000000000000 ? 0x8000000000000000 : v41 + 1000 * *(unsigned int *)(v82 + 40);
      v78 = v41 == 0x7FFFFFFFFFFFFFFFLL;
      a5 = (char *)(v41 == 0x7FFFFFFFFFFFFFFFLL ? 0x7FFFFFFFFFFFFFFFLL : v87);
      --v80;
      v81 += 32;
      ++v13;
      v82 = (uint64_t)a3;
    }
    while ((uint64_t)a5 <= v10);
    v13 = a4 + 1;
    goto LABEL_183;
  }
  if (v13 >= 5)
  {
LABEL_208:
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_bitrate_allocation.cc", 27, "spatial_index < kMaxSpatialLayers", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, (uint64_t)a3, a4, (uint64_t)a5, a6, v13);
    goto LABEL_205;
  }
  v41 = 1000 * *(unsigned int *)(a1 + 36 * v13 + 172);
  v46 = &v126 + 2 * v13;
  v47 = (unsigned int *)v46 + 1;
  if (*((_BYTE *)v46 + 8))
    v48 = -(uint64_t)*v47;
  else
    v48 = 0;
  v42 = v25 + v13 - 1;
  v88 = v48 + (1000 * *(_DWORD *)(a1 + 36 * v13 + 172));
  if (v88 > 0xFFFFFFFFLL)
  {
    v40 = 0;
  }
  else
  {
    *v47 = v41;
    *((_BYTE *)v47 + 4) = 1;
    v40 = v88;
    LODWORD(v126) = v88;
  }
  v89 = v13 + 1;
  if (v13 == v42)
  {
    ++v13;
    v77 = v41;
    goto LABEL_183;
  }
  if (v13 == 4)
    goto LABEL_207;
  v77 = 1000 * *(unsigned int *)(a1 + 36 * v89 + 172);
  v90 = &v126 + 2 * v89;
  v91 = (unsigned int *)v90 + 1;
  v92 = *((unsigned __int8 *)v90 + 8);
  v93 = v40;
  if (v92)
    v93 = v40 - *v91;
  v94 = v93 + (1000 * *(_DWORD *)(a1 + 36 * v89 + 172));
  if (v94 <= 0xFFFFFFFFLL)
  {
    *v91 = v77;
    *((_BYTE *)v91 + 4) = 1;
    v40 = v94;
    LODWORD(v126) = v94;
  }
  v41 += v77;
  v95 = v13 + 2;
  if (v89 == v42)
    goto LABEL_161;
  if (v13 == 3)
    goto LABEL_207;
  v77 = 1000 * *(unsigned int *)(a1 + 36 * v95 + 172);
  v96 = &v126 + 2 * v95;
  v97 = (unsigned int *)v96 + 1;
  v98 = *((unsigned __int8 *)v96 + 8);
  v99 = v40;
  if (v98)
    v99 = v40 - *v97;
  v100 = v99 + (1000 * *(_DWORD *)(a1 + 36 * v95 + 172));
  if (v100 <= 0xFFFFFFFFLL)
  {
    *v97 = v77;
    *((_BYTE *)v97 + 4) = 1;
    v40 = v100;
    LODWORD(v126) = v100;
  }
  v41 += v77;
  v43 = v13 + 3;
  if (v95 == v42)
  {
    v13 += 3;
    goto LABEL_183;
  }
LABEL_170:
  if (v43 == 5)
    goto LABEL_207;
  v77 = 1000 * *(unsigned int *)(a1 + 36 * v43 + 172);
  v101 = &v126 + 2 * v43;
  v102 = (unsigned int *)v101 + 1;
  v103 = *((unsigned __int8 *)v101 + 8);
  v104 = v40;
  if (v103)
    v104 = v40 - *v102;
  v105 = v104 + (1000 * *(_DWORD *)(a1 + 36 * v43 + 172));
  if (v105 <= 0xFFFFFFFFLL)
  {
    *v102 = v77;
    *((_BYTE *)v102 + 4) = 1;
    v40 = v105;
    LODWORD(v126) = v105;
  }
  v41 += v77;
  v95 = v13 + 4;
  if (v43 == v42)
  {
LABEL_161:
    v13 = v95;
    goto LABEL_183;
  }
  if (v13 == 1)
    goto LABEL_207;
  v77 = 1000 * *(unsigned int *)(a1 + 36 * v95 + 172);
  v106 = &v126 + 2 * v95;
  v107 = (unsigned int *)v106 + 1;
  v108 = *((unsigned __int8 *)v106 + 8);
  v109 = v40;
  if (v108)
    v109 = v40 - *v107;
  v110 = v109 + (1000 * *(_DWORD *)(a1 + 36 * v95 + 172));
  if (v110 <= 0xFFFFFFFFLL)
  {
    *v107 = v77;
    *((_BYTE *)v107 + 4) = 1;
    v40 = v110;
    LODWORD(v126) = v110;
  }
  if (v95 != v42)
  {
LABEL_207:
    v13 = 5;
    goto LABEL_208;
  }
  v41 += v77;
  v13 += 5;
LABEL_183:
  v111 = 0x7FFFFFFFFFFFFFFFLL;
  if (v10 != 0x7FFFFFFFFFFFFFFFLL && v41 != 0x8000000000000000)
  {
    v112 = __OFSUB__(v10, v41);
    v113 = v10 - v41;
    if ((v113 < 0) ^ v112 | (v113 == 0))
      goto LABEL_201;
    v114 = v113 == 0x8000000000000000 || v77 == 0x8000000000000000;
    v115 = v113 + v77;
    if (v114)
      v115 = 0x8000000000000000;
    if (v113 != 0x7FFFFFFFFFFFFFFFLL)
      v111 = v115;
  }
  --v13;
  if (1000 * *(unsigned int *)(a1 + 36 * v13 + 168) >= v111)
    LODWORD(v10) = v111;
  else
    LODWORD(v10) = 1000 * *(_DWORD *)(a1 + 36 * v13 + 168);
  if (v13 >= 5)
    goto LABEL_208;
LABEL_197:
  v116 = &v126 + 2 * v13;
  v117 = (_DWORD *)v116 + 1;
  if (*((_BYTE *)v116 + 8))
    v40 -= *v117;
  v118 = v40 + v10;
  if (v118 <= 0xFFFFFFFFLL)
  {
    *v117 = v10;
    *((_BYTE *)v116 + 8) = 1;
    LODWORD(v126) = v118;
  }
LABEL_201:
  v119 = v135;
  *(_OWORD *)(a7 + 128) = v134;
  *(_OWORD *)(a7 + 144) = v119;
  *(_DWORD *)(a7 + 160) = v136;
  v120 = v131;
  *(_OWORD *)(a7 + 64) = v130;
  *(_OWORD *)(a7 + 80) = v120;
  v121 = v133;
  *(_OWORD *)(a7 + 96) = v132;
  *(_OWORD *)(a7 + 112) = v121;
  v122 = v127;
  *(_OWORD *)a7 = v126;
  *(_OWORD *)(a7 + 16) = v122;
  v123 = v129;
  *(_OWORD *)(a7 + 32) = v128;
  *(_OWORD *)(a7 + 48) = v123;
LABEL_202:
  *(_BYTE *)(a7 + 164) = v25 < (unint64_t)v19;
}

void webrtc::`anonymous namespace'::AdjustAndVerify(char **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  BOOL v18;
  unint64_t v19;
  int64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t *v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  _BYTE *v33;
  unint64_t v34;
  char *v35;
  unint64_t v36;
  char *v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _OWORD *v41;
  char *v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _OWORD *v48;
  char *v49;
  uint64_t v50;
  __int128 v51;
  uint64_t v52;
  char **v53;
  char *v54;
  char *v55;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v5 = *(_QWORD **)a4;
  v4 = *(_QWORD **)(a4 + 8);
  v6 = (uint64_t)v4 - *(_QWORD *)a4;
  if (v4 == *(_QWORD **)a4)
  {
    v11 = 0;
    v22 = 0;
    v9 = 0;
LABEL_80:
    v53 = a1;
    *a1 = v11;
    a1[1] = v22;
    goto LABEL_81;
  }
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = v6 >> 3;
  v58 = a3;
  v59 = a4;
  v57 = a2;
  while (1)
  {
    v14 = 1000 * *(unsigned int *)(a2 + 36 * (v8 + a3) + 160);
    v15 = v5[v8];
    v16 = v15 == 0x7FFFFFFFFFFFFFFFLL || v7 == 0x7FFFFFFFFFFFFFFFLL;
    v17 = 0x7FFFFFFFFFFFFFFFLL;
    if (v16)
      goto LABEL_25;
    v18 = v7 == 0x8000000000000000 || v15 == 0x8000000000000000;
    v19 = v15 + v7;
    v20 = v18 ? 0x8000000000000000 : v19;
    if (v20 < 1000 * *(unsigned int *)(a2 + 36 * (v8 + a3) + 168))
      break;
    if (v20 > v14)
    {
      v21 = v19 - v14;
      if (v19 == 0x8000000000000000)
        v21 = 0x8000000000000000;
      if (v19 == 0x7FFFFFFFFFFFFFFFLL)
        v17 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v17 = v21;
LABEL_25:
      if (v10 < v9)
      {
        if (!v10)
          goto LABEL_89;
        *(_QWORD *)v10 = v14;
        v22 = v10 + 8;
        goto LABEL_7;
      }
      v23 = (v10 - v11) >> 3;
      v24 = v23 + 1;
      if ((unint64_t)(v23 + 1) >> 61)
        goto LABEL_90;
      if ((v9 - v11) >> 2 > v24)
        v24 = (v9 - v11) >> 2;
      if ((unint64_t)(v9 - v11) >= 0x7FFFFFFFFFFFFFF8)
        v24 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v24)
        goto LABEL_89;
      if (v24 >> 61)
        goto LABEL_91;
      v25 = 8 * v24;
      v26 = operator new(8 * v24);
      v9 = &v26[v25];
      v27 = (uint64_t *)&v26[8 * v23];
      *v27 = v14;
      v22 = (char *)(v27 + 1);
      if (v10 == v11)
      {
        if (!v10)
          goto LABEL_6;
        v13 = v10;
      }
      else
      {
        v28 = v10 - v11 - 8;
        if (v28 < 0x168)
        {
          v29 = v10;
          goto LABEL_66;
        }
        v36 = (v10 - 8 - v11) & 0xFFFFFFFFFFFFFFF8;
        if (&v26[v10 - v11 - 8 - v36] > &v26[v10 - v11 - 8])
        {
          v29 = v10;
          goto LABEL_66;
        }
        if (&v10[-v36 - 8] > v10 - 8)
        {
          v29 = v10;
          goto LABEL_66;
        }
        if ((unint64_t)(v11 - v26) < 0x20)
        {
          v29 = v10;
          goto LABEL_66;
        }
        v39 = (v28 >> 3) + 1;
        v40 = 8 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
        v29 = &v10[-v40];
        v27 = (uint64_t *)((char *)v27 - v40);
        v41 = &v26[8 * v23 - 16];
        v42 = v10 - 16;
        v43 = v39 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v44 = *(_OWORD *)v42;
          *(v41 - 1) = *((_OWORD *)v42 - 1);
          *v41 = v44;
          v41 -= 2;
          v42 -= 32;
          v43 -= 4;
        }
        while (v43);
        if (v39 != (v39 & 0x3FFFFFFFFFFFFFFCLL))
        {
          do
          {
LABEL_66:
            v45 = *((_QWORD *)v29 - 1);
            v29 -= 8;
            *--v27 = v45;
          }
          while (v29 != v11);
        }
        if (!v11)
          goto LABEL_6;
        v13 = v11;
      }
      operator delete(v13);
      goto LABEL_6;
    }
    if (v10 >= v9)
    {
      v30 = (v10 - v11) >> 3;
      v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) >> 61)
        goto LABEL_90;
      if ((v9 - v11) >> 2 > v31)
        v31 = (v9 - v11) >> 2;
      if ((unint64_t)(v9 - v11) >= 0x7FFFFFFFFFFFFFF8)
        v31 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v31)
      {
LABEL_89:
        __break(1u);
LABEL_90:
        abort();
      }
      if (v31 >> 61)
LABEL_91:
        std::__throw_bad_array_new_length[abi:sn180100]();
      v32 = 8 * v31;
      v33 = operator new(8 * v31);
      v9 = &v33[v32];
      v27 = (uint64_t *)&v33[8 * v30];
      *v27 = v20;
      v22 = (char *)(v27 + 1);
      if (v10 == v11)
      {
        if (v10)
        {
          v37 = v10;
          goto LABEL_77;
        }
      }
      else
      {
        v34 = v10 - v11 - 8;
        if (v34 < 0x168)
        {
          v35 = v10;
          goto LABEL_74;
        }
        v38 = (v10 - 8 - v11) & 0xFFFFFFFFFFFFFFF8;
        if (&v33[v10 - v11 - 8 - v38] > &v33[v10 - v11 - 8])
        {
          v35 = v10;
          goto LABEL_74;
        }
        if (&v10[-v38 - 8] > v10 - 8)
        {
          v35 = v10;
          goto LABEL_74;
        }
        if ((unint64_t)(v11 - v33) < 0x20)
        {
          v35 = v10;
          goto LABEL_74;
        }
        v46 = (v34 >> 3) + 1;
        v47 = 8 * (v46 & 0x3FFFFFFFFFFFFFFCLL);
        v35 = &v10[-v47];
        v27 = (uint64_t *)((char *)v27 - v47);
        v48 = &v33[8 * v30 - 16];
        v49 = v10 - 16;
        v50 = v46 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v51 = *(_OWORD *)v49;
          *(v48 - 1) = *((_OWORD *)v49 - 1);
          *v48 = v51;
          v48 -= 2;
          v49 -= 32;
          v50 -= 4;
        }
        while (v50);
        if (v46 != (v46 & 0x3FFFFFFFFFFFFFFCLL))
        {
          do
          {
LABEL_74:
            v52 = *((_QWORD *)v35 - 1);
            v35 -= 8;
            *--v27 = v52;
          }
          while (v35 != v11);
        }
        if (v11)
        {
          v37 = v11;
LABEL_77:
          operator delete(v37);
        }
      }
      v17 = 0;
LABEL_6:
      v11 = (char *)v27;
      a3 = v58;
      a4 = v59;
      a2 = v57;
      goto LABEL_7;
    }
    if (!v10)
      goto LABEL_89;
    v17 = 0;
    *(_QWORD *)v10 = v20;
    v22 = v10 + 8;
LABEL_7:
    ++v8;
    v5 = *(_QWORD **)a4;
    v4 = *(_QWORD **)(a4 + 8);
    v6 = (uint64_t)v4 - *(_QWORD *)a4;
    v12 = v6 >> 3;
    v7 = v17;
    v10 = v22;
    if (v8 >= v6 >> 3)
      goto LABEL_80;
  }
  if (v6 != 8)
  {
    v53 = a1;
    *a1 = v11;
    a1[1] = v10;
LABEL_81:
    v53[2] = v9;
    return;
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (v4 != v5)
  {
    v54 = (char *)operator new(8uLL);
    v55 = &v54[8 * v12];
    a1[1] = v55;
    a1[2] = v55;
    *(_QWORD *)v54 = *v5;
    *a1 = v54;
  }
  if (v11)
    operator delete(v11);
}

void webrtc::`anonymous namespace'::SplitBitrate(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v9;
  unint64_t v10;
  double v11;
  BOOL v12;
  unint64_t v13;
  double v14;
  double v15;
  unint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  _BYTE *v25;
  unint64_t *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v33;
  uint64_t v34;
  _OWORD *v35;
  unint64_t *v36;
  __int128 v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  unint64_t v42;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v48;
  uint64_t v50;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (!a2)
  {
    v12 = a3 <= 0;
    if (a3 <= 0 && (a3 & 0x8000000000000000) == 0)
      return;
LABEL_76:
    __break(1u);
    goto LABEL_77;
  }
  v9 = a2 - 1;
  if (a2 == 1)
  {
    v10 = 0;
    v11 = 0.0;
  }
  else
  {
    v13 = 0;
    v10 = a2 & 0xFFFFFFFFFFFFFFFELL;
    v11 = 0.0;
    do
    {
      v14 = pow(0.550000012, (double)v13);
      v11 = v11 + v14 + pow(0.550000012, (double)(v13 + 1));
      v13 += 2;
    }
    while (v13 != v10);
    if (v10 == a2)
      goto LABEL_11;
  }
  do
    v11 = v11 + pow(0.550000012, (double)v10++);
  while (a2 != v10);
LABEL_11:
  v15 = pow(0.550000012, (double)v9);
  v16 = 0;
  v6 = 0;
  v17 = 0;
  do
  {
    while (1)
    {
      a4 = llround(v15 * (double)a3);
      v18 = llround((double)a4 / v11);
      v12 = (uint64_t)v6 <= (uint64_t)v16;
      if (v6 < v16)
        break;
      v19 = (unint64_t *)*a1;
      v20 = (uint64_t)v6 - *a1;
      v21 = v20 >> 3;
      a4 = (v20 >> 3) + 1;
      if ((unint64_t)a4 >> 61)
        abort();
      v22 = (char *)v16 - (char *)v19;
      if (((char *)v16 - (char *)v19) >> 2 > (unint64_t)a4)
        a4 = ((char *)v16 - (char *)v19) >> 2;
      v23 = (unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8;
      v12 = v22 <= 0x7FFFFFFFFFFFFFF8;
      v4 = 0x1FFFFFFFFFFFFFFFLL;
      if (v23)
        a4 = 0x1FFFFFFFFFFFFFFFLL;
      if (!a4)
        goto LABEL_76;
      if ((unint64_t)a4 >> 61)
        std::__throw_bad_array_new_length[abi:sn180100]();
      v24 = 8 * a4;
      v25 = operator new(8 * a4);
      v26 = (unint64_t *)&v25[8 * v21];
      *v26 = v18;
      v27 = v26 + 1;
      v4 = (char *)v6 - (char *)v19;
      if (v6 == v19)
        goto LABEL_41;
      v28 = v4 - 8;
      if (v28 >= 0x168)
      {
        v29 = ((char *)(v6 - 1) - (char *)v19) & 0xFFFFFFFFFFFFFFF8;
        v30 = (unint64_t)&v25[v20 - 8];
        v5 = v30 - v29;
        v31 = (unint64_t)v6 - v29 - 8;
        if (v5 > v30 || v31 > (unint64_t)(v6 - 1))
        {
          v4 = (uint64_t)v6;
        }
        else if ((unint64_t)((char *)v6 - &v25[v20]) >= 0x20)
        {
          v33 = (v28 >> 3) + 1;
          v34 = 8 * (v33 & 0x3FFFFFFFFFFFFFFCLL);
          v4 = (uint64_t)&v6[v34 / 0xFFFFFFFFFFFFFFF8];
          v26 = (unint64_t *)((char *)v26 - v34);
          v35 = &v25[8 * v21 - 16];
          v36 = v6 - 2;
          v5 = v33 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v37 = *(_OWORD *)v36;
            *(v35 - 1) = *((_OWORD *)v36 - 1);
            *v35 = v37;
            v35 -= 2;
            v36 -= 4;
            v5 -= 4;
          }
          while (v5);
          if (v33 == (v33 & 0x3FFFFFFFFFFFFFFCLL))
            goto LABEL_40;
        }
        else
        {
          v4 = (uint64_t)v6;
        }
      }
      else
      {
        v4 = (uint64_t)v6;
      }
      do
      {
        v38 = *(_QWORD *)(v4 - 8);
        v4 -= 8;
        *--v26 = v38;
      }
      while ((unint64_t *)v4 != v19);
LABEL_40:
      v6 = v19;
LABEL_41:
      v16 = (unint64_t *)&v25[v24];
      *a1 = (uint64_t)v26;
      a1[1] = (uint64_t)v27;
      a1[2] = (uint64_t)v16;
      if (v6)
        operator delete(v6);
      v6 = v27;
      a1[1] = (uint64_t)v27;
      ++v17;
      v15 = v15 / 0.550000012;
      if (v17 == a2)
        goto LABEL_43;
    }
    if (!v6)
      goto LABEL_76;
    *v6++ = v18;
    a1[1] = (uint64_t)v6;
    ++v17;
    v15 = v15 / 0.550000012;
  }
  while (v17 != a2);
LABEL_43:
  v4 = *a1;
  if ((unint64_t *)*a1 == v6)
  {
    a4 = a3;
    v12 = a3 <= 0;
    if (a3 <= 0 && (a3 & 0x8000000000000000) == 0)
      return;
    goto LABEL_76;
  }
  a4 = 0;
  v5 = a3;
  do
  {
    v40 = *(_QWORD *)v4;
    v4 += 8;
    v39 = v40;
    v41 = v40 == 0x8000000000000000 || a4 == 0x8000000000000000;
    v42 = v39 + a4;
    if (v41)
      v42 = 0x8000000000000000;
    if (a4 == 0x7FFFFFFFFFFFFFFFLL || v39 == 0x7FFFFFFFFFFFFFFFLL)
      a4 = 0x7FFFFFFFFFFFFFFFLL;
    else
      a4 = v42;
  }
  while ((unint64_t *)v4 != v6);
  v4 = a4 - a3;
  v12 = a4 <= a3;
  if (a4 < a3)
  {
    v44 = a3 - a4;
    v45 = 0x8000000000000000;
    v41 = a4 == 0x8000000000000000;
    v46 = 0x7FFFFFFFFFFFFFFFLL;
    if (v41 || a3 == 0x7FFFFFFFFFFFFFFFLL)
      v44 = 0x7FFFFFFFFFFFFFFFLL;
    v48 = *(v6 - 1);
    if (v44 != 0x8000000000000000 && v48 != 0x8000000000000000)
      v45 = v48 + v44;
    if (v44 == 0x7FFFFFFFFFFFFFFFLL)
      v50 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v50 = v45;
    if (v48 != 0x7FFFFFFFFFFFFFFFLL)
      v46 = v50;
    goto LABEL_94;
  }
LABEL_77:
  if (!v12)
  {
    if (v5 == 0x8000000000000000 || a4 == 0x7FFFFFFFFFFFFFFFLL)
      v52 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v52 = v4;
    v53 = *(v6 - 1);
    v54 = v53 - v52;
    if (v52 == 0x7FFFFFFFFFFFFFFFLL || v53 == 0x8000000000000000)
      v54 = 0x8000000000000000;
    if (v52 == 0x8000000000000000)
      v46 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v46 = v54;
    if (v53 == 0x7FFFFFFFFFFFFFFFLL)
      v46 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_94:
    *(v6 - 1) = v46;
  }
}

uint64_t webrtc::SvcRateAllocator::GetMaxBitrate(webrtc::SvcRateAllocator *this, const VideoCodec *a2)
{
  unsigned int v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  unsigned int *v8;
  unint64_t v9;
  int v10;
  int64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v15;
  unint64_t v16;
  int v17[11];
  uint64_t v18;

  v3 = *((unsigned __int16 *)this + 186);
  if (v3 < 0x100
    || *((_WORD *)this + 186) > 0x21u
    || ((*((void (**)(uint64_t *__return_ptr))*(&off_24C0C1E00 + (char)v3) + 1))(&v18), !v18))
  {
    if (*(_DWORD *)this != 2)
    {
      v4 = 1;
      goto LABEL_12;
    }
    v4 = *((unsigned __int8 *)this + 366);
    goto LABEL_9;
  }
  (*(void (**)(int *__return_ptr))(*(_QWORD *)v18 + 16))(v17);
  v4 = v17[0];
  v5 = v18;
  v18 = 0;
  if (!v5)
  {
LABEL_9:
    if (!v4)
      goto LABEL_22;
    goto LABEL_12;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  if (!v4)
  {
LABEL_22:
    v11 = 0;
    goto LABEL_23;
  }
LABEL_12:
  v6 = 0;
  v7 = (char *)this + 176;
  while (!*v7)
  {
    ++v6;
    v7 += 36;
    if (v4 == v6)
      goto LABEL_22;
  }
  if (v6 >= v4)
    goto LABEL_22;
  v8 = (unsigned int *)(v7 - 16);
  v9 = v6;
  while (1)
  {
    v10 = *v7;
    v7 += 36;
    if (!v10)
      break;
    if (v4 == ++v9)
    {
      v9 = v4;
      break;
    }
  }
  if (v9 == v6)
    goto LABEL_22;
  v11 = 0;
  do
  {
    v15 = *v8;
    v8 += 9;
    v16 = v11 + 1000 * v15;
    if (v11 == 0x8000000000000000)
      v16 = 0x8000000000000000;
    if (v11 != 0x7FFFFFFFFFFFFFFFLL)
      v11 = v16;
    --v9;
  }
  while (v6 != v9);
LABEL_23:
  v12 = *((_DWORD *)this + 3);
  v13 = 1000 * v12;
  if (v13 >= v11)
    v13 = v11;
  if (v12)
    return v13;
  else
    return v11;
}

void webrtc::SvcRateAllocator::~SvcRateAllocator(void **this)
{
  void *v2;
  void *v3;
  void *v4;

  *this = off_24C0C1DD8;
  if (((_BYTE)this[77] & 1) != 0)
  {
    operator delete(this[78]);
    this[68] = off_24C0B4170;
    if ((*((char *)this + 599) & 0x80000000) == 0)
    {
LABEL_3:
      v2 = this[69];
      if (!v2)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  else
  {
    this[68] = off_24C0B4170;
    if ((*((char *)this + 599) & 0x80000000) == 0)
      goto LABEL_3;
  }
  operator delete(this[72]);
  v2 = this[69];
  if (v2)
  {
LABEL_4:
    this[70] = v2;
    operator delete(v2);
  }
LABEL_5:
  this[59] = off_24C0B4170;
  if ((*((char *)this + 527) & 0x80000000) == 0)
  {
    v3 = this[60];
    if (!v3)
      goto LABEL_8;
    goto LABEL_7;
  }
  operator delete(this[63]);
  v3 = this[60];
  if (v3)
  {
LABEL_7:
    this[61] = v3;
    operator delete(v3);
  }
LABEL_8:
  this[51] = off_24C0B4170;
  if (*((char *)this + 463) < 0)
  {
    operator delete(this[55]);
    v4 = this[52];
    if (!v4)
      return;
  }
  else
  {
    v4 = this[52];
    if (!v4)
      return;
  }
  this[53] = v4;
  operator delete(v4);
}

{
  void *v2;
  void *v3;
  void *v4;

  *this = off_24C0C1DD8;
  if (((_BYTE)this[77] & 1) != 0)
  {
    operator delete(this[78]);
    this[68] = off_24C0B4170;
    if ((*((char *)this + 599) & 0x80000000) == 0)
    {
LABEL_3:
      v2 = this[69];
      if (!v2)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  else
  {
    this[68] = off_24C0B4170;
    if ((*((char *)this + 599) & 0x80000000) == 0)
      goto LABEL_3;
  }
  operator delete(this[72]);
  v2 = this[69];
  if (!v2)
  {
LABEL_5:
    this[59] = off_24C0B4170;
    if (*((char *)this + 527) < 0)
    {
      operator delete(this[63]);
      v3 = this[60];
      if (!v3)
      {
LABEL_8:
        this[51] = off_24C0B4170;
        if (*((char *)this + 463) < 0)
        {
          operator delete(this[55]);
          v4 = this[52];
          if (!v4)
            goto LABEL_18;
        }
        else
        {
          v4 = this[52];
          if (!v4)
            goto LABEL_18;
        }
        this[53] = v4;
        operator delete(v4);
LABEL_18:
        JUMPOUT(0x20BD0ADECLL);
      }
    }
    else
    {
      v3 = this[60];
      if (!v3)
        goto LABEL_8;
    }
    this[61] = v3;
    operator delete(v3);
    goto LABEL_8;
  }
LABEL_4:
  this[70] = v2;
  operator delete(v2);
  goto LABEL_5;
}

unint64_t webrtc::SyncBuffer::PushBack(webrtc::SyncBuffer *this, const webrtc::AudioMultiVector *a2)
{
  unint64_t result;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  result = (*(uint64_t (**)(const webrtc::AudioMultiVector *))(*(_QWORD *)a2 + 120))(a2);
  v5 = result;
  v6 = *((_QWORD *)this + 4);
  if (v6)
    v7 = v6 == *((_QWORD *)a2 + 4);
  else
    v7 = 0;
  if (v7)
  {
    v8 = 0;
    do
    {
      v9 = *((_QWORD *)this + 1);
      if (v8 >= (*((_QWORD *)this + 2) - v9) >> 3)
        goto LABEL_19;
      v10 = *((_QWORD *)a2 + 1);
      if (v8 >= (*((_QWORD *)a2 + 2) - v10) >> 3)
        goto LABEL_19;
      result = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v9 + 8 * v8) + 56))(*(_QWORD *)(v9 + 8 * v8), *(_QWORD *)(v10 + 8 * v8));
      ++v8;
      v6 = *((_QWORD *)this + 4);
    }
    while (v8 < v6);
  }
  if (v6)
  {
    v11 = 0;
    while (1)
    {
      v12 = *((_QWORD *)this + 1);
      if (v11 >= (*((_QWORD *)this + 2) - v12) >> 3)
        break;
      result = (*(uint64_t (**)(_QWORD, unint64_t))(**(_QWORD **)(v12 + 8 * v11) + 80))(*(_QWORD *)(v12 + 8 * v11), v5);
      if (++v11 >= *((_QWORD *)this + 4))
        goto LABEL_14;
    }
LABEL_19:
    __break(1u);
    return result;
  }
LABEL_14:
  v13 = *((_QWORD *)this + 5);
  v14 = v13 >= v5;
  v15 = v13 - v5;
  if (!v14)
    v15 = 0;
  *((_QWORD *)this + 5) = v15;
  v16 = *((_QWORD *)this + 7);
  v14 = v16 >= v5;
  v17 = v16 - v5;
  if (!v14)
    v17 = 0;
  *((_QWORD *)this + 7) = v17;
  return result;
}

unint64_t webrtc::SyncBuffer::InsertZerosAtIndex(webrtc::SyncBuffer *this, unint64_t a2, unint64_t a3)
{
  unint64_t v6;
  unint64_t result;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  v6 = (*(uint64_t (**)(webrtc::SyncBuffer *))(*(_QWORD *)this + 120))(this);
  if (v6 < a3)
    a3 = v6;
  result = (*(uint64_t (**)(webrtc::SyncBuffer *))(*(_QWORD *)this + 120))(this);
  if (result - a3 < a2)
    a2 = result - a3;
  if (*((_QWORD *)this + 4))
  {
    v8 = 0;
    do
    {
      v9 = *((_QWORD *)this + 1);
      if (v8 >= (*((_QWORD *)this + 2) - v9) >> 3)
        goto LABEL_25;
      result = (*(uint64_t (**)(_QWORD, unint64_t))(**(_QWORD **)(v9 + 8 * v8) + 88))(*(_QWORD *)(v9 + 8 * v8), a2);
    }
    while (++v8 < *((_QWORD *)this + 4));
  }
  result = (*(uint64_t (**)(webrtc::SyncBuffer *))(*(_QWORD *)this + 112))(this);
  if (result)
  {
    v10 = 0;
    while (1)
    {
      v11 = *((_QWORD *)this + 1);
      if (v10 >= (*((_QWORD *)this + 2) - v11) >> 3)
        break;
      (*(void (**)(_QWORD, unint64_t, unint64_t))(**(_QWORD **)(v11 + 8 * v10) + 112))(*(_QWORD *)(v11 + 8 * v10), a2, a3);
      ++v10;
      result = (*(uint64_t (**)(webrtc::SyncBuffer *))(*(_QWORD *)this + 112))(this);
      if (v10 >= result)
        goto LABEL_13;
    }
LABEL_25:
    __break(1u);
    return result;
  }
LABEL_13:
  v12 = *((_QWORD *)this + 5);
  if (v12 >= a3)
  {
    v13 = v12 + a2;
    result = (*(uint64_t (**)(webrtc::SyncBuffer *))(*(_QWORD *)this + 120))(this);
    if (result >= v13)
      v14 = v13;
    else
      v14 = result;
    *((_QWORD *)this + 5) = v14;
  }
  v15 = *((_QWORD *)this + 7);
  if (v15 && v15 >= a3)
  {
    v16 = v15 + a2;
    result = (*(uint64_t (**)(webrtc::SyncBuffer *))(*(_QWORD *)this + 120))(this);
    if (result >= v16)
      v17 = v16;
    else
      v17 = result;
    *((_QWORD *)this + 7) = v17;
  }
  return result;
}

unint64_t webrtc::SyncBuffer::ReplaceAtIndex(webrtc::SyncBuffer *this, const webrtc::AudioMultiVector *a2, unint64_t a3, unint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t result;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v8 = (*(uint64_t (**)(webrtc::SyncBuffer *))(*(_QWORD *)this + 120))(this);
  if (v8 < a4)
    a4 = v8;
  v9 = (*(uint64_t (**)(webrtc::SyncBuffer *))(*(_QWORD *)this + 120))(this);
  if (v9 - a4 < a3)
    a3 = v9 - a4;
  result = (*(uint64_t (**)(const webrtc::AudioMultiVector *))(*(_QWORD *)a2 + 120))(a2);
  if (result < a3)
    a3 = result;
  v11 = *((_QWORD *)this + 4);
  if (v11)
    v12 = v11 == *((_QWORD *)a2 + 4);
  else
    v12 = 0;
  if (v12)
  {
    v13 = 0;
    while (1)
    {
      v14 = *((_QWORD *)this + 1);
      if (v13 >= (*((_QWORD *)this + 2) - v14) >> 3)
        break;
      v15 = *((_QWORD *)a2 + 1);
      if (v13 >= (*((_QWORD *)a2 + 2) - v15) >> 3)
        break;
      result = (*(uint64_t (**)(_QWORD, _QWORD, unint64_t, unint64_t))(**(_QWORD **)(v14 + 8 * v13)
                                                                                             + 120))(*(_QWORD *)(v14 + 8 * v13), *(_QWORD *)(v15 + 8 * v13), a3, a4);
      if (++v13 >= *((_QWORD *)this + 4))
        return result;
    }
    __break(1u);
  }
  return result;
}

uint64_t webrtc::SyncBuffer::ReplaceAtIndex(webrtc::SyncBuffer *this, const webrtc::AudioMultiVector *a2, uint64_t a3)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(const webrtc::AudioMultiVector *))(*(_QWORD *)a2 + 120))(a2);
  return (*(uint64_t (**)(webrtc::SyncBuffer *, const webrtc::AudioMultiVector *, uint64_t, uint64_t))(*(_QWORD *)this + 160))(this, a2, v6, a3);
}

uint64_t webrtc::SyncBuffer::GetNextAudioInterleaved(webrtc::SyncBuffer *this, unint64_t a2, webrtc::AudioFrame *a3)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t result;

  v6 = (char *)a3 + 15432;
  v7 = (*(uint64_t (**)(webrtc::SyncBuffer *))(*(_QWORD *)this + 120))(this);
  v8 = *((_QWORD *)this + 5);
  *(_DWORD *)a3 = 0;
  *((_QWORD *)a3 + 1) = -1;
  *((_QWORD *)a3 + 2) = -1;
  *((_QWORD *)a3 + 3) = 0;
  *((_DWORD *)a3 + 8) = 0;
  *((_QWORD *)a3 + 5) = 0;
  *((_DWORD *)a3 + 3859) = 0;
  *((_QWORD *)a3 + 6) = 0x200000004;
  v9 = *((_QWORD *)a3 + 8);
  *((_QWORD *)a3 + 7) = 0;
  *((_QWORD *)a3 + 8) = 0;
  if (v9)
  {
    do
    {
      v10 = __ldaxr((unsigned int *)v9);
      v11 = v10 - 1;
    }
    while (__stlxr(v11, (unsigned int *)v9));
    if (!v11)
    {
      v12 = *(_QWORD *)(v9 + 8);
      if (v12)
      {
        v13 = *(_QWORD *)(v9 + 16);
        v14 = *(void **)(v9 + 8);
        if (v13 != v12)
        {
          do
          {
            v15 = *(void **)(v13 - 96);
            if (v15)
            {
              *(_QWORD *)(v13 - 88) = v15;
              operator delete(v15);
            }
            v13 -= 104;
          }
          while (v13 != v12);
          v14 = *(void **)(v9 + 8);
        }
        *(_QWORD *)(v9 + 16) = v12;
        operator delete(v14);
      }
      MEMORY[0x20BD0ADEC](v9, 0x1020C40E72D6CFBLL);
    }
  }
  if (v6[16])
    v6[16] = 0;
  v16 = *((_QWORD *)this + 5);
  if (*v6)
    bzero((char *)a3 + 72, 0x3C01uLL);
  if (v7 - v8 >= a2)
    v17 = a2;
  else
    v17 = v7 - v8;
  v18 = (*(uint64_t (**)(webrtc::SyncBuffer *, uint64_t, unint64_t, char *))(*(_QWORD *)this + 80))(this, v16, v17, (char *)a3 + 72);
  v19 = v18 / (*(uint64_t (**)(webrtc::SyncBuffer *))(*(_QWORD *)this + 112))(this);
  *((_QWORD *)this + 5) += v19;
  result = (*(uint64_t (**)(webrtc::SyncBuffer *))(*(_QWORD *)this + 112))(this);
  *((_QWORD *)a3 + 5) = result;
  *((_QWORD *)a3 + 3) = v19;
  return result;
}

void webrtc::SyncBuffer::~SyncBuffer(webrtc::SyncBuffer *this)
{
  _QWORD *v2;
  _QWORD *v3;

  *(_QWORD *)this = &off_24C0AE108;
  v3 = (_QWORD *)*((_QWORD *)this + 1);
  v2 = (_QWORD *)*((_QWORD *)this + 2);
  if (v3 == v2)
  {
    if (!v3)
      return;
    goto LABEL_3;
  }
  do
  {
    if (*v3)
    {
      (*(void (**)(_QWORD))(*(_QWORD *)*v3 + 8))(*v3);
      v2 = (_QWORD *)*((_QWORD *)this + 2);
    }
    ++v3;
  }
  while (v3 != v2);
  v3 = (_QWORD *)*((_QWORD *)this + 1);
  if (v3)
  {
LABEL_3:
    *((_QWORD *)this + 2) = v3;
    operator delete(v3);
  }
}

{
  _QWORD *v2;
  _QWORD *v3;

  *(_QWORD *)this = &off_24C0AE108;
  v3 = (_QWORD *)*((_QWORD *)this + 1);
  v2 = (_QWORD *)*((_QWORD *)this + 2);
  if (v3 == v2)
  {
    if (!v3)
      goto LABEL_9;
  }
  else
  {
    do
    {
      if (*v3)
      {
        (*(void (**)(_QWORD))(*(_QWORD *)*v3 + 8))(*v3);
        v2 = (_QWORD *)*((_QWORD *)this + 2);
      }
      ++v3;
    }
    while (v3 != v2);
    v3 = (_QWORD *)*((_QWORD *)this + 1);
    if (!v3)
LABEL_9:
      JUMPOUT(0x20BD0ADECLL);
  }
  *((_QWORD *)this + 2) = v3;
  operator delete(v3);
  goto LABEL_9;
}

void webrtc::rtcp::TargetBitrate::AddTargetBitrate(webrtc::rtcp::TargetBitrate *this, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t *v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  BOOL v17;
  unint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD *v25;
  unint64_t *v26;
  uint64_t v27;
  __int128 v28;
  unint64_t v29;

  v9 = (unint64_t *)*((_QWORD *)this + 1);
  v8 = *((_QWORD *)this + 2);
  v10 = v9;
  if ((unint64_t)v9 < v8)
  {
    if (v9)
    {
      *v9 = ((unint64_t)a3 << 8) | (a4 << 32) | a2;
      v11 = v9 + 1;
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  v12 = *(unint64_t **)this;
  v13 = (uint64_t)v9 - *(_QWORD *)this;
  v14 = v13 >> 3;
  v15 = (v13 >> 3) + 1;
  if (v15 >> 61)
    goto LABEL_23;
  v16 = v8 - (_QWORD)v12;
  if (v16 >> 2 > v15)
    v15 = v16 >> 2;
  v17 = (unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8;
  v18 = 0x1FFFFFFFFFFFFFFFLL;
  if (!v17)
    v18 = v15;
  if (!v18)
  {
LABEL_22:
    __break(1u);
LABEL_23:
    abort();
  }
  if (v18 >> 61)
    std::__throw_bad_array_new_length[abi:sn180100]();
  v19 = 8 * v18;
  v20 = operator new(8 * v18);
  v21 = (unint64_t *)&v20[8 * v14];
  *v21 = ((unint64_t)a3 << 8) | (a4 << 32) | a2;
  v11 = v21 + 1;
  if (v9 != v12)
  {
    v22 = (char *)v9 - (char *)v12 - 8;
    if (v22 < 0x58)
      goto LABEL_27;
    if ((unint64_t)((char *)v9 - v13 - v20) < 0x20)
      goto LABEL_27;
    v23 = (v22 >> 3) + 1;
    v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
    v10 = &v9[v24 / 0xFFFFFFFFFFFFFFF8];
    v21 = (unint64_t *)((char *)v21 - v24);
    v25 = &v20[8 * v14 - 16];
    v26 = v9 - 2;
    v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v28 = *(_OWORD *)v26;
      *(v25 - 1) = *((_OWORD *)v26 - 1);
      *v25 = v28;
      v25 -= 2;
      v26 -= 4;
      v27 -= 4;
    }
    while (v27);
    if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_27:
      do
      {
        v29 = *--v10;
        *--v21 = v29;
      }
      while (v10 != v12);
    }
    v10 = v12;
  }
  *(_QWORD *)this = v21;
  *((_QWORD *)this + 1) = v11;
  *((_QWORD *)this + 2) = &v20[v19];
  if (v10)
    operator delete(v10);
LABEL_21:
  *((_QWORD *)this + 1) = v11;
}

_QWORD *std::vector<webrtc::rtcp::TargetBitrate::BitrateItem>::__assign_with_size[abi:sn180100]<webrtc::rtcp::TargetBitrate::BitrateItem*,webrtc::rtcp::TargetBitrate::BitrateItem*>(_QWORD *result, char *__src, char *a3, size_t __sz)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  size_t v14;
  void **v15;
  _BYTE *v16;
  unint64_t v17;
  char *v18;
  void *v19;

  v6 = __src;
  v7 = result;
  v8 = result[2];
  v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 3)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz >> 61)
      goto LABEL_22;
    v10 = v8 >> 2;
    if (v8 >> 2 <= __sz)
      v10 = __sz;
    v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8;
    v12 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v11)
      v12 = v10;
    if (v12 >> 61)
LABEL_22:
      abort();
    v13 = v12;
    result = operator new(8 * v12);
    v9 = (char *)result;
    *v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    v14 = a3 - v6;
    if (v14)
      result = memcpy(result, v6, v14);
    v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  v15 = (void **)(result + 1);
  v16 = (_BYTE *)result[1];
  v17 = (v16 - v9) >> 3;
  if (v17 >= __sz)
  {
    v14 = a3 - __src;
    if (a3 == __src)
      goto LABEL_21;
    v19 = (void *)*result;
LABEL_20:
    result = memmove(v19, __src, v14);
    goto LABEL_21;
  }
  v18 = &__src[8 * v17];
  if (v16 != v9)
  {
    result = memmove((void *)*result, __src, v16 - v9);
    v9 = (char *)*v15;
  }
  v14 = a3 - v18;
  if (v14)
  {
    v19 = v9;
    __src = v18;
    goto LABEL_20;
  }
LABEL_21:
  *v15 = &v9[v14];
  return result;
}

void webrtc::TaskQueueFrameDecodeScheduler::~TaskQueueFrameDecodeScheduler(webrtc::TaskQueueFrameDecodeScheduler *this)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;

  *(_QWORD *)this = &off_24C0C1FE0;
  v1 = *((_QWORD *)this + 4);
  *(_BYTE *)(v1 + 4) = 0;
  do
  {
    v2 = __ldaxr((unsigned int *)v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, (unsigned int *)v1));
  if (!v3)
    MEMORY[0x20BD0ADEC]();
}

{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;

  *(_QWORD *)this = &off_24C0C1FE0;
  v1 = *((_QWORD *)this + 4);
  *(_BYTE *)(v1 + 4) = 0;
  do
  {
    v2 = __ldaxr((unsigned int *)v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, (unsigned int *)v1));
  if (!v3)
    MEMORY[0x20BD0ADEC]();
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::TaskQueueFrameDecodeScheduler::ScheduleFrame(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  _OWORD *v16;
  __int128 v17;
  _QWORD *v18;
  char v20;
  __int128 v21;
  __int128 v22;
  _BYTE v23[16];
  __int128 v24;
  _QWORD v25[2];
  uint64_t (*v26)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v27)(uint64_t);
  char v28;

  *(_DWORD *)(a1 + 24) = a2;
  *(_BYTE *)(a1 + 28) = 1;
  v10 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  v11 = 0x7FFFFFFFFFFFFFFFLL;
  if (a3 == 0x7FFFFFFFFFFFFFFFLL
    || v10 == 0x8000000000000000
    || (v10 != 0x7FFFFFFFFFFFFFFFLL ? (v12 = a3 == 0x8000000000000000) : (v12 = 1),
        !v12 ? (v11 = a3 - v10) : (v11 = 0x8000000000000000),
        v11 >= 1))
  {
    v13 = *(_QWORD *)(a1 + 16);
    v14 = *(unsigned int **)(a1 + 32);
    if (!v14)
      goto LABEL_12;
  }
  else
  {
    v11 = 0;
    v13 = *(_QWORD *)(a1 + 16);
    v14 = *(unsigned int **)(a1 + 32);
    if (!v14)
      goto LABEL_12;
  }
  do
    v15 = __ldxr(v14);
  while (__stxr(v15 + 1, v14));
LABEL_12:
  *(_QWORD *)&v21 = a1;
  DWORD2(v21) = a2;
  *(_QWORD *)&v22 = a3;
  *((_QWORD *)&v22 + 1) = a4;
  (*(void (**)(_QWORD, uint64_t, _BYTE *))(a5 + 16))(0, a5, v23);
  v24 = *(_OWORD *)(a5 + 16);
  *(_QWORD *)(a5 + 16) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(a5 + 24) = 0;
  v16 = (_OWORD *)operator new();
  v17 = v22;
  *v16 = v21;
  v16[1] = v17;
  ((void (*)(_QWORD, _BYTE *, _OWORD *))v24)(0, v23, v16 + 2);
  v16[3] = v24;
  v24 = (unint64_t)absl::internal_any_invocable::EmptyManager;
  v18 = (_QWORD *)operator new();
  *v18 = v14;
  v18[1] = v16;
  v18[3] = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc29TaskQueueFrameDecodeScheduler13ScheduleFrameEjNS2_17FrameDecodeTiming13FrameScheduleENS_12AnyInvocableIFvjNS2_9TimestampEOEEEE3__0EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESD_;
  v18[4] = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc29TaskQueueFrameDecodeScheduler13ScheduleFrameEjNS2_17FrameDecodeTiming13FrameScheduleENS_12AnyInvocableIFvjNS2_9TimestampEOEEEE3__0JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  v28 = 1;
  v25[0] = v18;
  v26 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
  v27 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  (*(void (**)(uint64_t, _QWORD *, uint64_t, char *, char *))(*(_QWORD *)v13 + 16))(v13, v25, v11, &v28, &v20);
  v26(1, v25, v25);
  return ((uint64_t (*)(uint64_t, _BYTE *, _BYTE *))v24)(1, v23, v23);
}

uint64_t webrtc::TaskQueueFrameDecodeScheduler::CancelOutstanding(uint64_t this)
{
  if (*(_BYTE *)(this + 28))
    *(_BYTE *)(this + 28) = 0;
  return this;
}

uint64_t webrtc::TaskQueueFrameDecodeScheduler::ScheduledRtpTimestamp(webrtc::TaskQueueFrameDecodeScheduler *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t webrtc::TaskQueueFrameDecodeScheduler::Stop(webrtc::TaskQueueFrameDecodeScheduler *this)
{
  uint64_t result;

  result = (*(uint64_t (**)(webrtc::TaskQueueFrameDecodeScheduler *))(*(_QWORD *)this + 32))(this);
  *((_BYTE *)this + 40) = 1;
  return result;
}

uint64_t **_ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc29TaskQueueFrameDecodeScheduler13ScheduleFrameEjNS2_17FrameDecodeTiming13FrameScheduleENS_12AnyInvocableIFvjNS2_9TimestampEOEEEE3__0JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE(uint64_t **result)
{
  uint64_t *v1;
  uint64_t v2;
  BOOL v3;

  v1 = *result;
  v2 = **result;
  if (*(_BYTE *)(v2 + 28))
    v3 = *(_DWORD *)(v2 + 24) == *((_DWORD *)*result + 2);
  else
    v3 = 0;
  if (v3)
  {
    *(_BYTE *)(v2 + 28) = 0;
    return (uint64_t **)((uint64_t (*)(uint64_t *))v1[7])(v1 + 4);
  }
  return result;
}

uint64_t _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc29TaskQueueFrameDecodeScheduler13ScheduleFrameEjNS2_17FrameDecodeTiming13FrameScheduleENS_12AnyInvocableIFvjNS2_9TimestampEOEEEE3__0EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESD_(uint64_t result, uint64_t *a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *a2;
  if ((result & 1) != 0)
  {
    if (v3)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v3 + 48))(1, v3 + 32, v3 + 32);
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    *a3 = v3;
  }
  return result;
}

_QWORD *webrtc::CreateTaskQueueGcdFactory@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  *result = &off_24C0C2020;
  *a1 = result;
  return result;
}

void webrtc::`anonymous namespace'::TaskQueueGcdFactory::~TaskQueueGcdFactory(webrtc::_anonymous_namespace_::TaskQueueGcdFactory *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::`anonymous namespace'::TaskQueueGcdFactory::CreateTaskQueue(void **a1@<X1>, size_t a2@<X2>, int a3@<W3>, _QWORD *a4@<X8>)
{
  _BOOL4 v8;
  _QWORD *v9;
  intptr_t v10;
  _QWORD *v11;
  void **v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void **v16;
  NSObject *global_queue;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  std::string *v23;
  void *v24;
  uint64_t v25;
  void *__p[2];
  int64_t v27;

  v8 = a3 == 1;
  v9 = (_QWORD *)operator new();
  if (a3 == 2)
    v10 = -2;
  else
    v10 = 2 * v8;
  *v9 = &off_24C0C2048;
  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_22;
  v11 = v9;
  if (a2 <= 0x16)
  {
    HIBYTE(v27) = a2;
    v12 = __p;
    v13 = (void **)((char *)__p + a2);
    if (__p > a1)
      goto LABEL_12;
    goto LABEL_11;
  }
  v14 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((a2 | 7) != 0x17)
    v14 = a2 | 7;
  v15 = v14 + 1;
  v12 = (void **)operator new(v14 + 1);
  __p[1] = (void *)a2;
  v27 = v15 | 0x8000000000000000;
  __p[0] = v12;
  v13 = (void **)((char *)v12 + a2);
  if (v12 <= a1)
  {
LABEL_11:
    if (v13 <= a1)
      goto LABEL_12;
    __break(1u);
LABEL_22:
    abort();
  }
LABEL_12:
  if (a2)
    memmove(v12, a1, a2);
  *(_BYTE *)v13 = 0;
  if (v27 >= 0)
    v16 = __p;
  else
    v16 = (void **)__p[0];
  global_queue = dispatch_get_global_queue(v10, 0);
  v22 = dispatch_queue_create_with_target_V2((const char *)v16, 0, global_queue);
  if (SHIBYTE(v27) < 0)
    operator delete(__p[0]);
  v11[1] = v22;
  *((_BYTE *)v11 + 16) = 1;
  if (v22)
  {
    dispatch_set_context(v22, v11);
    *a4 = v11;
  }
  else
  {
    v23 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/task_queue_gcd.cc", 84, "queue_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v18, v19, v20, v21, v25);
  }
}

uint64_t webrtc::`anonymous namespace'::TaskQueueGcd::DeleteQueue(uint64_t this, void *a2)
{
  if (this)
    JUMPOUT(0x20BD0ADECLL);
  return this;
}

void webrtc::`anonymous namespace'::TaskQueueGcd::Delete(dispatch_queue_t *this)
{
  dispatch_release(this[1]);
}

void webrtc::`anonymous namespace'::TaskQueueGcd::PostTaskImpl(uint64_t a1, uint64_t a2)
{
  char *v4;
  void (*v5)(_QWORD, _BYTE *, char *);
  _BYTE v6[16];
  __int128 v7;

  v4 = (char *)operator new();
  (*(void (**)(_QWORD, uint64_t, _BYTE *))(a2 + 16))(0, a2, v6);
  v7 = *(_OWORD *)(a2 + 16);
  v5 = (void (*)(_QWORD, _BYTE *, char *))v7;
  *(_QWORD *)(a2 + 16) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)v4 = a1;
  v5(0, v6, v4 + 8);
  *(_OWORD *)(v4 + 24) = v7;
  v7 = (unint64_t)absl::internal_any_invocable::EmptyManager;
}

void webrtc::`anonymous namespace'::TaskQueueGcd::PostDelayedTaskImpl(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  void (*v7)(_QWORD, _BYTE *, char *);
  dispatch_time_t v8;
  _BYTE v9[16];
  __int128 v10;

  v6 = (char *)operator new();
  (*(void (**)(_QWORD, uint64_t, _BYTE *))(a2 + 16))(0, a2, v9);
  v10 = *(_OWORD *)(a2 + 16);
  v7 = (void (*)(_QWORD, _BYTE *, char *))v10;
  *(_QWORD *)(a2 + 16) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)v6 = a1;
  v7(0, v9, v6 + 8);
  *(_OWORD *)(v6 + 24) = v10;
  v10 = (unint64_t)absl::internal_any_invocable::EmptyManager;
  v8 = dispatch_time(0, 1000 * a3);
}

void webrtc::`anonymous namespace'::TaskQueueGcd::~TaskQueueGcd(webrtc::_anonymous_namespace_::TaskQueueGcd *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::`anonymous namespace'::TaskQueueGcd::SetNotActive(uint64_t this, void *a2)
{
  *(_BYTE *)(this + 16) = 0;
  return this;
}

uint64_t webrtc::`anonymous namespace'::TaskQueueGcd::RunTask(void (**this)(char *), void *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v4 = *v3;
  *v3 = v5;
  if (*((_BYTE *)*this + 16))
    this[4]((char *)this + 8);
  ((void (*)(uint64_t, char *, char *))this[3])(1, (char *)this + 8, (char *)this + 8);
  result = MEMORY[0x20BD0ADEC](this, 0x10E2C40E82BB0D6);
  *v3 = v4;
  return result;
}

void webrtc::TaskQueuePacedSender::~TaskQueuePacedSender(webrtc::TaskQueuePacedSender *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)this = &off_24C0C2080;
  *((_QWORD *)this + 1) = &unk_24C0C2118;
  *((_BYTE *)this + 961) = 1;
  v2 = *((_QWORD *)this + 129);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  webrtc::PacingController::~PacingController((webrtc::TaskQueuePacedSender *)((char *)this + 40));
}

{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)this = &off_24C0C2080;
  *((_QWORD *)this + 1) = &unk_24C0C2118;
  *((_BYTE *)this + 961) = 1;
  v2 = *((_QWORD *)this + 129);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  webrtc::PacingController::~PacingController((webrtc::TaskQueuePacedSender *)((char *)this + 40));
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'webrtc::TaskQueuePacedSender::~TaskQueuePacedSender(webrtc::TaskQueuePacedSender *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;

  *((_QWORD *)this - 1) = &off_24C0C2080;
  *(_QWORD *)this = &unk_24C0C2118;
  *((_BYTE *)this + 953) = 1;
  v2 = *((_QWORD *)this + 128);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  webrtc::PacingController::~PacingController((webrtc::TaskQueuePacedSender *)((char *)this + 32));
}

{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;

  *((_QWORD *)this - 1) = &off_24C0C2080;
  *(_QWORD *)this = &unk_24C0C2118;
  *((_BYTE *)this + 953) = 1;
  v2 = *((_QWORD *)this + 128);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  webrtc::PacingController::~PacingController((webrtc::TaskQueuePacedSender *)((char *)this + 32));
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::TaskQueuePacedSender::MaybeProcessPackets(uint64_t this, Timestamp a2)
{
  uint64_t v2;
  uint64_t SendTime;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  BOOL v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int *v36;
  unsigned int v37;
  _QWORD *v38;
  char v39;
  _QWORD v40[2];
  uint64_t (*v41)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v42)(uint64_t);
  char v43;

  if (!*(_BYTE *)(this + 961))
  {
    v2 = this;
    if (*(_BYTE *)(this + 960))
    {
      *(_BYTE *)(this + 1024) = 1;
      SendTime = webrtc::PacingController::NextSendTime((webrtc::PacingController *)(this + 40));
      this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 16) + 16))(*(_QWORD *)(v2 + 16));
      if (this == 0x7FFFFFFFFFFFFFFFLL)
      {
        while (1)
        {
          webrtc::PacingController::ProcessPackets((Timestamp *)(v2 + 40));
          webrtc::PacingController::NextSendTime((webrtc::PacingController *)(v2 + 40));
        }
      }
      v5 = this;
      v6 = *(_DWORD *)(v2 + 152);
      v7 = 1000;
      if (v6 != 2)
        v7 = 0;
      if (this == 0x8000000000000000)
      {
        if (SendTime == 0x8000000000000000)
        {
          do
          {
            webrtc::PacingController::ProcessPackets((Timestamp *)(v2 + 40));
            this = webrtc::PacingController::NextSendTime((webrtc::PacingController *)(v2 + 40));
          }
          while (this == 0x8000000000000000);
          SendTime = this;
          v6 = *(_DWORD *)(v2 + 152);
          v7 = 1000;
          if (v6 != 2)
            v7 = 0;
        }
      }
      else if (v7 + this >= SendTime)
      {
        do
        {
          webrtc::PacingController::ProcessPackets((Timestamp *)(v2 + 40));
          this = webrtc::PacingController::NextSendTime((webrtc::PacingController *)(v2 + 40));
          v6 = *(_DWORD *)(v2 + 152);
          if (v6 == 2)
            v7 = 1000;
          else
            v7 = 0;
        }
        while (v7 + v5 >= this);
        SendTime = this;
      }
      v8 = *(_QWORD *)(v2 + 584);
      v9 = v8;
      if (*(_BYTE *)(v2 + 945))
      {
        v9 = 0x7FFFFFFFFFFFFFFFLL;
        if (v8 != 0x7FFFFFFFFFFFFFFFLL)
        {
          v10 = *(_QWORD *)(v2 + 80) * *(int *)(v2 + 560);
          if (v10 != 0x7FFFFFFFFFFFFFFFLL)
          {
            v11 = v10 == 0x8000000000000000 || v8 == 0x8000000000000000;
            v12 = v10 + v8;
            if (v11)
              v9 = 0x8000000000000000;
            else
              v9 = v12;
          }
        }
      }
      v13 = *(_QWORD *)(v2 + 136);
      v14 = 8000000 * v9;
      if (*(_QWORD *)(v2 + 920))
      {
        v15 = *(_QWORD *)(*(_QWORD *)(v2 + 912) + 16);
        v16 = *(_QWORD *)(v2 + 464);
        v17 = *(_BYTE *)(v2 + 472);
        v18 = v14 / v13;
        if (!*(_BYTE *)(v2 + 945))
          goto LABEL_42;
      }
      else
      {
        v15 = 0x8000000000000000;
        v16 = *(_QWORD *)(v2 + 464);
        v17 = *(_BYTE *)(v2 + 472);
        v18 = v14 / v13;
        if (!*(_BYTE *)(v2 + 945))
          goto LABEL_42;
      }
      v19 = *(_QWORD *)(v2 + 80) * *(int *)(v2 + 560);
      this = 0x7FFFFFFFFFFFFFFFLL;
      v20 = 0x8000000000000000;
      if (v19 != 0x8000000000000000 && v8 != 0x8000000000000000)
        v20 = v19 + v8;
      if (v19 == 0x7FFFFFFFFFFFFFFFLL)
        v22 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v22 = v20;
      if (v8 == 0x7FFFFFFFFFFFFFFFLL)
        v8 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v8 = v22;
LABEL_42:
      *(_QWORD *)(v2 + 984) = v15;
      *(_QWORD *)(v2 + 992) = v8;
      *(_QWORD *)(v2 + 1000) = v18;
      *(_QWORD *)(v2 + 1008) = v16;
      *(_BYTE *)(v2 + 1016) = v17;
      if ((unint64_t)(a2.var0 + 0x7FFFFFFFFFFFFFFFLL) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (*(_QWORD *)(v2 + 952) != a2.var0)
        {
LABEL_81:
          *(_BYTE *)(v2 + 1024) = 0;
          return this;
        }
        *(_QWORD *)(v2 + 952) = 0x8000000000000000;
      }
      if (v6 == 2)
      {
        v23 = 0;
      }
      else
      {
        v23 = *(_QWORD *)(v2 + 24);
        v24 = *(int *)(v2 + 32);
        if ((_DWORD)v24 != -1)
        {
          v25 = *(float *)(v2 + 968);
          if (v25 != -1.0)
          {
            if (v25 == INFINITY)
              v26 = -8000000;
            else
              v26 = v25 == -INFINITY ? 0 : 8000000 * (uint64_t)v25;
            v27 = v26 / v13 * v24;
            if (v27 < v23)
              v23 = v27;
          }
        }
      }
      v28 = 0x7FFFFFFFFFFFFFFFLL;
      if (v5 != 0x8000000000000000 && SendTime != 0x7FFFFFFFFFFFFFFFLL)
      {
        v29 = SendTime - v5 - v7;
        if (SendTime - v5 == 0x8000000000000000)
          v29 = 0x8000000000000000;
        if (SendTime - v5 == 0x7FFFFFFFFFFFFFFFLL)
          v28 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v28 = v29;
      }
      if (v23 <= v28)
        v30 = v28;
      else
        v30 = v23;
      v31 = v30 == 0x8000000000000000 || v5 == 0x8000000000000000;
      v32 = v30 + v5;
      if (v31)
        v32 = 0x8000000000000000;
      if (v30 == 0x7FFFFFFFFFFFFFFFLL)
        v33 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v33 = v32;
      v34 = *(_QWORD *)(v2 + 952);
      if (v34 == 0x8000000000000000 || v34 > v33)
      {
        v35 = *(_QWORD *)(v2 + 1040);
        v36 = *(unsigned int **)(v2 + 1032);
        if (v36)
        {
          do
            v37 = __ldxr(v36);
          while (__stxr(v37 + 1, v36));
        }
        v38 = (_QWORD *)operator new();
        *v38 = v36;
        v38[1] = v2;
        v38[2] = v33;
        v38[3] = absl::internal_any_invocable::LocalManagerTrivial;
        v38[4] = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::TaskQueuePacedSender::MaybeProcessPackets(webrtc::Timestamp)::$_2 &&>;
        v43 = 1;
        v40[0] = v38;
        v41 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
        v42 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
        (*(void (**)(uint64_t, _QWORD *, uint64_t, char *, char *))(*(_QWORD *)v35 + 16))(v35, v40, 1000 * ((v30 + 999) / 1000), &v43, &v39);
        this = v41(1, v40, v40);
        *(_QWORD *)(v2 + 952) = v33;
      }
      goto LABEL_81;
    }
  }
  return this;
}

void webrtc::TaskQueuePacedSender::CreateProbeClusters(webrtc::TaskQueuePacedSender *this, __int128 **a2)
{
  __int128 *v3;
  uint64_t v4;
  __int128 *v5;
  __int128 *v6;
  __int128 v7;
  __int128 v8;
  Timestamp v9;
  _OWORD v10[2];

  v3 = *a2;
  v4 = (char *)a2[1] - (char *)*a2;
  if (v4)
    v5 = *a2;
  else
    v5 = 0;
  if (v4)
  {
    v6 = (__int128 *)((char *)v5 + v4);
    do
    {
      v7 = *v3;
      v8 = v3[1];
      v3 += 2;
      v10[0] = v7;
      v10[1] = v8;
      webrtc::BitrateProber::CreateProbeCluster((uint64_t)this + 152, (int32x2_t *)v10);
    }
    while (v3 != v6);
  }
  if (!*((_BYTE *)this + 1024))
  {
    v9.var0 = 0x8000000000000000;
    webrtc::TaskQueuePacedSender::MaybeProcessPackets((uint64_t)this, v9);
  }
}

uint64_t webrtc::TaskQueuePacedSender::Pause(webrtc::TaskQueuePacedSender *this)
{
  return webrtc::PacingController::Pause((webrtc::TaskQueuePacedSender *)((char *)this + 40));
}

uint64_t webrtc::TaskQueuePacedSender::Resume(webrtc::TaskQueuePacedSender *this)
{
  Timestamp v2;

  webrtc::PacingController::Resume((webrtc::TaskQueuePacedSender *)((char *)this + 40));
  v2.var0 = 0x8000000000000000;
  return webrtc::TaskQueuePacedSender::MaybeProcessPackets((uint64_t)this, v2);
}

uint64_t webrtc::TaskQueuePacedSender::SetCongested(webrtc::TaskQueuePacedSender *this, char a2)
{
  uint64_t result;
  Timestamp v4;

  result = webrtc::PacingController::SetCongested((uint64_t)this + 40, a2);
  if (!*((_BYTE *)this + 1024))
  {
    v4.var0 = 0x8000000000000000;
    return webrtc::TaskQueuePacedSender::MaybeProcessPackets((uint64_t)this, v4);
  }
  return result;
}

void webrtc::TaskQueuePacedSender::SetPacingRates(uint64_t a1, uint64_t a2, unint64_t a3)
{
  Timestamp v4;

  webrtc::PacingController::SetPacingRates((webrtc::PacingController *)(a1 + 40), a2, a3);
  if (!*(_BYTE *)(a1 + 1024))
  {
    v4.var0 = 0x8000000000000000;
    webrtc::TaskQueuePacedSender::MaybeProcessPackets(a1, v4);
  }
}

uint64_t webrtc::TaskQueuePacedSender::EnqueuePackets(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  __int128 v10;
  char v11;
  char v12;
  _QWORD v13[2];
  uint64_t (*v14)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v15)(uint64_t);

  v3 = *(_QWORD *)(a1 + 1040);
  v4 = *(unsigned int **)(a1 + 1032);
  if (v4)
  {
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = *((_QWORD *)a2 + 2);
  v10 = *a2;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  v7 = operator new();
  *(_QWORD *)v7 = a1;
  *(_OWORD *)(v7 + 8) = v10;
  *(_QWORD *)(v7 + 24) = v6;
  v8 = (_QWORD *)operator new();
  *v8 = v4;
  v8[1] = v7;
  v8[3] = absl::internal_any_invocable::RemoteManagerNontrivial<webrtc::TaskQueuePacedSender::EnqueuePackets(std::vector<std::unique_ptr<webrtc::RtpPacketToSend>>)::$_0>;
  v8[4] = absl::internal_any_invocable::RemoteInvoker<false,void,webrtc::TaskQueuePacedSender::EnqueuePackets(std::vector<std::unique_ptr<webrtc::RtpPacketToSend>>)::$_0 &&>;
  v13[0] = v8;
  v14 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
  v15 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  (*(void (**)(uint64_t, _QWORD *, char *, char *))(*(_QWORD *)v3 + 8))(v3, v13, &v12, &v11);
  return v14(1, v13, v13);
}

uint64_t `non-virtual thunk to'webrtc::TaskQueuePacedSender::EnqueuePackets(uint64_t a1, __int128 *a2)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  __int128 v10;
  char v11;
  char v12;
  _QWORD v13[2];
  uint64_t (*v14)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v15)(uint64_t);

  v2 = *(_QWORD *)(a1 + 1032);
  v3 = *(unsigned int **)(a1 + 1024);
  if (v3)
  {
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a1 - 8;
  v6 = *((_QWORD *)a2 + 2);
  v10 = *a2;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  v7 = operator new();
  *(_QWORD *)v7 = v5;
  *(_OWORD *)(v7 + 8) = v10;
  *(_QWORD *)(v7 + 24) = v6;
  v8 = (_QWORD *)operator new();
  *v8 = v3;
  v8[1] = v7;
  v8[3] = absl::internal_any_invocable::RemoteManagerNontrivial<webrtc::TaskQueuePacedSender::EnqueuePackets(std::vector<std::unique_ptr<webrtc::RtpPacketToSend>>)::$_0>;
  v8[4] = absl::internal_any_invocable::RemoteInvoker<false,void,webrtc::TaskQueuePacedSender::EnqueuePackets(std::vector<std::unique_ptr<webrtc::RtpPacketToSend>>)::$_0 &&>;
  v13[0] = v8;
  v14 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
  v15 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  (*(void (**)(uint64_t, _QWORD *, char *, char *))(*(_QWORD *)v2 + 8))(v2, v13, &v12, &v11);
  return v14(1, v13, v13);
}

uint64_t webrtc::TaskQueuePacedSender::RemovePacketsForSsrc(webrtc::TaskQueuePacedSender *this, int a2)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  char v9;
  char v10;
  _QWORD v11[2];
  uint64_t (*v12)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v13)(uint64_t);

  v4 = *((_QWORD *)this + 130);
  v5 = (unsigned int *)*((_QWORD *)this + 129);
  if (v5)
  {
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = operator new();
  *(_QWORD *)v7 = v5;
  *(_QWORD *)(v7 + 8) = this;
  *(_DWORD *)(v7 + 16) = a2;
  *(_QWORD *)(v7 + 24) = absl::internal_any_invocable::LocalManagerTrivial;
  *(_QWORD *)(v7 + 32) = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::TaskQueuePacedSender::RemovePacketsForSsrc::$_0 &&>;
  v11[0] = v7;
  v12 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
  v13 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  (*(void (**)(uint64_t, _QWORD *, char *, char *))(*(_QWORD *)v4 + 8))(v4, v11, &v10, &v9);
  return v12(1, v11, v11);
}

uint64_t `non-virtual thunk to'webrtc::TaskQueuePacedSender::RemovePacketsForSsrc(webrtc::TaskQueuePacedSender *this, int a2)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  char *v6;
  uint64_t v7;
  char v9;
  char v10;
  _QWORD v11[2];
  uint64_t (*v12)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v13)(uint64_t);

  v3 = *((_QWORD *)this + 129);
  v4 = (unsigned int *)*((_QWORD *)this + 128);
  if (v4)
  {
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (char *)this - 8;
  v7 = operator new();
  *(_QWORD *)v7 = v4;
  *(_QWORD *)(v7 + 8) = v6;
  *(_DWORD *)(v7 + 16) = a2;
  *(_QWORD *)(v7 + 24) = absl::internal_any_invocable::LocalManagerTrivial;
  *(_QWORD *)(v7 + 32) = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::TaskQueuePacedSender::RemovePacketsForSsrc::$_0 &&>;
  v11[0] = v7;
  v12 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
  v13 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  (*(void (**)(uint64_t, _QWORD *, char *, char *))(*(_QWORD *)v3 + 8))(v3, v11, &v10, &v9);
  return v12(1, v11, v11);
}

uint64_t webrtc::TaskQueuePacedSender::SetAccountForAudioPackets(webrtc::TaskQueuePacedSender *this, char a2)
{
  Timestamp v2;

  *((_BYTE *)this + 944) = a2;
  v2.var0 = 0x8000000000000000;
  return webrtc::TaskQueuePacedSender::MaybeProcessPackets((uint64_t)this, v2);
}

uint64_t webrtc::TaskQueuePacedSender::SetIncludeOverhead(webrtc::TaskQueuePacedSender *this)
{
  Timestamp v1;

  *((_BYTE *)this + 976) = 1;
  *((_BYTE *)this + 945) = 1;
  v1.var0 = 0x8000000000000000;
  return webrtc::TaskQueuePacedSender::MaybeProcessPackets((uint64_t)this, v1);
}

uint64_t webrtc::TaskQueuePacedSender::SetTransportOverhead(uint64_t a1, uint64_t a2)
{
  Timestamp v2;

  if (!*(_BYTE *)(a1 + 67))
    *(_QWORD *)(a1 + 80) = a2;
  v2.var0 = 0x8000000000000000;
  return webrtc::TaskQueuePacedSender::MaybeProcessPackets(a1, v2);
}

uint64_t webrtc::TaskQueuePacedSender::SetQueueTimeLimit(TimeDelta *this, TimeDelta a2)
{
  Timestamp v2;

  this[117].var0 = a2.var0;
  v2.var0 = 0x8000000000000000;
  return webrtc::TaskQueuePacedSender::MaybeProcessPackets((uint64_t)this, v2);
}

uint64_t webrtc::TaskQueuePacedSender::ExpectedQueueTime(webrtc::TaskQueuePacedSender *this)
{
  return *((_QWORD *)this + 125);
}

uint64_t webrtc::TaskQueuePacedSender::QueueSizeData(webrtc::TaskQueuePacedSender *this)
{
  return *((_QWORD *)this + 124);
}

uint64_t webrtc::TaskQueuePacedSender::FirstSentPacketTime(webrtc::TaskQueuePacedSender *this)
{
  return *((_QWORD *)this + 126);
}

uint64_t webrtc::TaskQueuePacedSender::OldestPacketWaitTime(webrtc::TaskQueuePacedSender *this)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *((_QWORD *)this + 123);
  if ((unint64_t)(v1 - 0x7FFFFFFFFFFFFFFFLL) < 2)
    return 0;
  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 16))(*((_QWORD *)this + 2));
  v4 = v3 - v1;
  if (v3 < v1)
    return 0;
  v5 = v3;
  result = 0x7FFFFFFFFFFFFFFFLL;
  if (v5 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v5 == 0x8000000000000000)
      return 0x8000000000000000;
    else
      return v4;
  }
  return result;
}

uint64_t absl::internal_any_invocable::RemoteInvoker<false,void,webrtc::TaskQueuePacedSender::EnqueuePackets(std::vector<std::unique_ptr<webrtc::RtpPacketToSend>>)::$_0 &&>(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t i;
  unint64_t v11;
  float v12;
  float v13;
  float v14;
  uint64_t v16;
  _QWORD *v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  void *v27;
  Timestamp v28;
  _QWORD *v30;

  v8 = **a1;
  v9 = (uint64_t *)(*a1)[1];
  for (i = (*a1)[2]; v9 != (uint64_t *)i; ++v9)
  {
    v11 = *(_QWORD *)(*v9 + 24) + *(unsigned __int8 *)(*v9 + 2);
    if (*(_BYTE *)(v8 + 976))
      v11 += *(_QWORD *)(*v9 + 16);
    v12 = (float)v11;
    v13 = *(float *)(v8 + 968);
    if (v13 != -1.0)
      v12 = (float)((float)(1.0 - *(float *)(v8 + 964)) * v12) + (float)(*(float *)(v8 + 964) * v13);
    v14 = *(float *)(v8 + 972);
    if (v12 > v14 && v14 != -1.0)
      v12 = *(float *)(v8 + 972);
    *(float *)(v8 + 968) = v12;
    v16 = *v9;
    *v9 = 0;
    v30 = (_QWORD *)v16;
    webrtc::PacingController::EnqueuePacket((_QWORD *)(v8 + 40), (uint64_t *)&v30, a3, a4, a5, a6, a7, a8);
    v17 = v30;
    v30 = 0;
    if (v17)
    {
      v18 = (unsigned int *)v17[22];
      if (v18)
      {
        v19 = v18 + 2;
        do
        {
          v20 = __ldaxr(v19);
          v21 = v20 - 1;
        }
        while (__stlxr(v21, v19));
        if (!v21)
          (*(void (**)(unsigned int *))(*(_QWORD *)v18 + 8))(v18);
      }
      v22 = v17[11];
      if (v22)
      {
        v23 = (unsigned int *)(v22 + 24);
        do
        {
          v24 = __ldaxr(v23);
          v25 = v24 - 1;
        }
        while (__stlxr(v25, v23));
        if (!v25)
        {
          v26 = *(_QWORD *)(v22 + 16);
          *(_QWORD *)(v22 + 16) = 0;
          if (v26)
            MEMORY[0x20BD0ADD4](v26, 0x1000C8077774924);
          MEMORY[0x20BD0ADEC](v22, 0x1010C40EE34DA14);
        }
      }
      v27 = (void *)v17[7];
      if (v27)
      {
        v17[8] = v27;
        operator delete(v27);
      }
      MEMORY[0x20BD0ADEC](v17, 0x1020C4000E59722);
    }
  }
  v28.var0 = 0x8000000000000000;
  return webrtc::TaskQueuePacedSender::MaybeProcessPackets(v8, v28);
}

uint64_t absl::internal_any_invocable::RemoteManagerNontrivial<webrtc::TaskQueuePacedSender::EnqueuePackets(std::vector<std::unique_ptr<webrtc::RtpPacketToSend>>)::$_0>(uint64_t result, uint64_t *a2, _QWORD *a3)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  void *v18;

  v3 = *a2;
  if ((result & 1) != 0)
  {
    if (v3)
    {
      v4 = *(_QWORD **)(v3 + 8);
      if (v4)
      {
        v5 = *(_QWORD **)(v3 + 16);
        v6 = *(void **)(v3 + 8);
        if (v5 != v4)
        {
          do
          {
            v8 = (_QWORD *)*--v5;
            v7 = v8;
            *v5 = 0;
            if (v8)
            {
              v9 = (unsigned int *)v7[22];
              if (v9)
              {
                v10 = v9 + 2;
                do
                {
                  v11 = __ldaxr(v10);
                  v12 = v11 - 1;
                }
                while (__stlxr(v12, v10));
                if (!v12)
                  (*(void (**)(unsigned int *))(*(_QWORD *)v9 + 8))(v9);
              }
              v13 = v7[11];
              if (v13)
              {
                v14 = (unsigned int *)(v13 + 24);
                do
                {
                  v15 = __ldaxr(v14);
                  v16 = v15 - 1;
                }
                while (__stlxr(v16, v14));
                if (!v16)
                {
                  v17 = *(_QWORD *)(v13 + 16);
                  *(_QWORD *)(v13 + 16) = 0;
                  if (v17)
                    MEMORY[0x20BD0ADD4](v17, 0x1000C8077774924);
                  MEMORY[0x20BD0ADEC](v13, 0x1010C40EE34DA14);
                }
              }
              v18 = (void *)v7[7];
              if (v18)
              {
                v7[8] = v18;
                operator delete(v18);
              }
              MEMORY[0x20BD0ADEC](v7, 0x1020C4000E59722);
            }
          }
          while (v5 != v4);
          v6 = *(void **)(v3 + 8);
        }
        *(_QWORD *)(v3 + 16) = v4;
        operator delete(v6);
      }
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    *a3 = v3;
  }
  return result;
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,webrtc::TaskQueuePacedSender::RemovePacketsForSsrc(unsigned int)::$_0 &&>(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  Timestamp v9;

  v8 = *(_QWORD *)a1;
  webrtc::PrioritizedPacketQueue::RemovePacketsForSsrc((webrtc::PrioritizedPacketQueue *)(*(_QWORD *)a1 + 488), a1[2], a3, a4, a5, a6, a7, a8);
  v9.var0 = 0x8000000000000000;
  return webrtc::TaskQueuePacedSender::MaybeProcessPackets(v8, v9);
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,webrtc::TaskQueuePacedSender::MaybeProcessPackets(webrtc::Timestamp)::$_2 &&>(uint64_t a1)
{
  Timestamp v1;

  v1.var0 = *(_QWORD *)(a1 + 8);
  return webrtc::TaskQueuePacedSender::MaybeProcessPackets(*(webrtc::TaskQueuePacedSender **)a1, v1);
}

void webrtc::`anonymous namespace'::TaskQueueStdlibFactory::~TaskQueueStdlibFactory(webrtc::_anonymous_namespace_::TaskQueueStdlibFactory *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::`anonymous namespace'::TaskQueueStdlibFactory::CreateTaskQueue@<X0>(__int128 *a1@<X1>, size_t a2@<X2>, int a3@<W3>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t (***v13)();
  uint64_t (***v14)();
  uint64_t v15;
  TimeDelta v16;
  TimeDelta v17;
  uint64_t result;
  uint64_t (**v19)();
  __int128 v20;
  uint64_t (***v21)();
  pthread_mutex_t v22;
  pthread_cond_t v23;
  uint64_t (**v24)();
  __int128 v25;
  uint64_t (***v26)();
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v8 = (_QWORD *)operator new();
  v9 = v8;
  v10 = 4;
  if (a3 == 2)
    v11 = 1;
  else
    v11 = 4;
  if (a3)
    v12 = v11;
  else
    v12 = 2;
  *v8 = &off_24C0C2170;
  rtc::Event::Event((rtc::Event *)(v8 + 1), 0, 0);
  pthread_mutexattr_init((pthread_mutexattr_t *)&v22);
  pthread_mutexattr_setpolicy_np((pthread_mutexattr_t *)&v22, 3);
  pthread_mutex_init((pthread_mutex_t *)v9 + 2, (const pthread_mutexattr_t *)&v22);
  pthread_mutexattr_destroy((pthread_mutexattr_t *)&v22);
  *((_BYTE *)v9 + 192) = 0;
  v9[33] = 0;
  v9[34] = 0;
  *(_OWORD *)(v9 + 25) = 0u;
  *(_OWORD *)(v9 + 27) = 0u;
  *(_OWORD *)(v9 + 29) = 0u;
  v9[31] = 0;
  v9[32] = v9 + 33;
  rtc::Event::Event((rtc::Event *)&v22, 0, 0);
  v19 = &off_24C0C21A8;
  *(_QWORD *)&v20 = &v22;
  *((_QWORD *)&v20 + 1) = v9;
  v21 = &v19;
  v26 = &v24;
  v24 = &off_24C0C21A8;
  v25 = v20;
  rtc::PlatformThread::SpawnThread(&v24, a1, a2, v12, 1, (uint64_t)(v9 + 35));
  v13 = v26;
  if (v26 == &v24)
  {
    v13 = &v24;
  }
  else
  {
    if (!v26)
      goto LABEL_12;
    v10 = 5;
  }
  (*v13)[v10]();
LABEL_12:
  v14 = v21;
  if (v21 == &v19)
  {
    v15 = 4;
    v14 = &v19;
    goto LABEL_16;
  }
  if (v21)
  {
    v15 = 5;
LABEL_16:
    (*v14)[v15]();
  }
  v16.var0 = 0x7FFFFFFFFFFFFFFFLL;
  v17.var0 = 3000000;
  rtc::Event::Wait((rtc::Event *)&v22, v16, v17);
  pthread_mutex_destroy(&v22);
  result = pthread_cond_destroy(&v23);
  *a4 = v9;
  return result;
}

void webrtc::`anonymous namespace'::TaskQueueStdlib::Delete(webrtc::_anonymous_namespace_::TaskQueueStdlib *this)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = (pthread_mutex_t *)((char *)this + 128);
  pthread_mutex_lock((pthread_mutex_t *)this + 2);
  *((_BYTE *)this + 192) = 1;
  pthread_mutex_unlock(v2);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  *((_BYTE *)this + 121) = 1;
  pthread_cond_broadcast((pthread_cond_t *)((char *)this + 72));
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  if (*((_BYTE *)this + 296))
  {
    if (!*((_BYTE *)this + 304))
      goto LABEL_5;
    if (pthread_join(*((pthread_t *)this + 36), 0))
    {
      if (*((_BYTE *)this + 296))
      {
        pthread_join(*((pthread_t *)this + 36), 0);
        rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/platform_thread.cc", 166, "0 == pthread_join(*handle_, nullptr)", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, v3, v4, v5, v6, 0);
      }
      __break(1u);
LABEL_10:
      JUMPOUT(0x20BD0ADECLL);
    }
    if (*((_BYTE *)this + 296))
LABEL_5:
      *((_BYTE *)this + 296) = 0;
  }
  _ZNSt3__16__treeINS_12__value_typeIN6webrtc12_GLOBAL__N_115TaskQueueStdlib19DelayedEntryTimeoutEN4absl12AnyInvocableIFvvOEEEEENS_19__map_value_compareIS5_SA_NS_4lessIS5_EELb1EEENS_9allocatorISA_EEE7destroyEPNS_11__tree_nodeISA_PvEE(*((_QWORD **)this + 33));
  _ZNSt3__15dequeINS_4pairIyN4absl12AnyInvocableIFvvOEEEEENS_9allocatorIS6_EEED2B8sn180100Ev((void **)this + 26);
  pthread_mutex_destroy(v2);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
  pthread_cond_destroy((pthread_cond_t *)((char *)this + 72));
  goto LABEL_10;
}

uint64_t webrtc::`anonymous namespace'::TaskQueueStdlib::PostTaskImpl(uint64_t a1, uint64_t a2)
{
  char *v2;
  pthread_mutex_t *v5;
  uint64_t v6;
  _BYTE *v7;
  __int128 v8;
  char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  unint64_t v22;
  char *v23;
  char *v24;
  void *v25;
  unint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  void *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int64_t v39;
  char *v40;
  char *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  BOOL v47;
  int64_t v48;
  unint64_t v49;
  char *v50;
  unint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  char *v60;
  int64_t v61;
  unint64_t v62;
  char *v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  __int128 *v67;
  char *v68;
  uint64_t v69;
  __int128 v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  char *v75;
  char *v76;
  char *v77;
  char *v78;
  char *v79;
  unint64_t v80;
  uint64_t v81;
  __int128 *v82;
  _OWORD *v83;
  uint64_t v84;
  __int128 v85;
  uint64_t v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  int64_t v93;
  char *v94;
  uint64_t v95;
  uint64_t v96;
  __int128 *v97;
  _OWORD *v98;
  uint64_t v99;
  __int128 v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  char *v105;
  char *v106;
  int64_t v107;
  unint64_t v108;
  char *v109;
  char *v110;
  uint64_t v111;
  uint64_t v112;
  char *v113;
  __int128 *v114;
  _OWORD *v115;
  uint64_t v116;
  __int128 v117;
  uint64_t v118;
  uint64_t v119;
  int64_t v120;
  pthread_mutex_t *v121;
  _BYTE *v122;
  uint64_t v123;
  _BYTE v124[16];
  __int128 v125;

  v5 = (pthread_mutex_t *)(a1 + 128);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 128));
  v6 = *(_QWORD *)(a1 + 200) + 1;
  *(_QWORD *)(a1 + 200) = v6;
  v123 = v6;
  v7 = v124;
  (*(void (**)(_QWORD, uint64_t, _BYTE *))(a2 + 16))(0, a2, v124);
  v8 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(a2 + 24) = 0;
  v10 = *(char **)(a1 + 216);
  v9 = *(char **)(a1 + 224);
  v11 = (v9 - v10) >> 3;
  v12 = v9 - v10;
  v125 = v8;
  v13 = v10;
  if (v9 == v10)
    v14 = 0;
  else
    v14 = 102 * v11 - 1;
  v15 = *(_QWORD *)(a1 + 240);
  if (v14 == *(_QWORD *)(a1 + 248) + v15)
  {
    v16 = v15 >= 0x66;
    v17 = v15 - 102;
    if (!v16)
    {
      v122 = v124;
      v19 = *(char **)(a1 + 232);
      v20 = *(char **)(a1 + 208);
      if (v11 < (unint64_t)((v19 - v20) >> 3))
      {
        v21 = (char *)operator new(0xFF0uLL);
        v2 = v21;
        if (v19 != v9)
        {
          if (!v9)
            goto LABEL_86;
          *(_QWORD *)v9 = v21;
          v9 = (char *)(*(_QWORD *)(a1 + 224) + 8);
          *(_QWORD *)(a1 + 224) = v9;
          v7 = v124;
LABEL_27:
          v13 = *(char **)(a1 + 216);
          goto LABEL_28;
        }
        if (v10 != v20)
        {
          v41 = v10;
          v7 = v124;
          goto LABEL_84;
        }
        v120 = v9 - v10;
        v72 = (v19 - v10) >> 2;
        if (v9 == v10)
          v72 = 1;
        if (!(v72 >> 61))
        {
          v73 = (v72 + 3) >> 2;
          v74 = 8 * v72;
          v75 = (char *)operator new(8 * v72);
          v41 = &v75[8 * v73];
          v76 = v41;
          v7 = v124;
          if (v9 != v10)
          {
            v76 = &v41[8 * v11];
            v77 = &v75[8 * v73];
            v78 = v10;
            if ((unint64_t)(v120 - 8) < 0x38)
              goto LABEL_117;
            v79 = &v75[8 * v73];
            v77 = v79;
            v78 = v10;
            if ((unint64_t)(v79 - v10) < 0x20)
              goto LABEL_117;
            v80 = ((unint64_t)(v120 - 8) >> 3) + 1;
            v81 = 8 * (v80 & 0x3FFFFFFFFFFFFFFCLL);
            v77 = &v41[v81];
            v78 = &v10[v81];
            v82 = (__int128 *)(v10 + 16);
            v83 = v79 + 16;
            v84 = v80 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v85 = *v82;
              *(v83 - 1) = *(v82 - 1);
              *v83 = v85;
              v82 += 2;
              v83 += 2;
              v84 -= 4;
            }
            while (v84);
            if (v80 != (v80 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_117:
              do
              {
                v86 = *(_QWORD *)v78;
                v78 += 8;
                *(_QWORD *)v77 = v86;
                v77 += 8;
              }
              while (v77 != v76);
            }
          }
          *(_QWORD *)(a1 + 208) = v75;
          *(_QWORD *)(a1 + 216) = v41;
          *(_QWORD *)(a1 + 224) = v76;
          *(_QWORD *)(a1 + 232) = &v75[v74];
          if (v10)
          {
            operator delete(v10);
            v41 = *(char **)(a1 + 216);
          }
LABEL_84:
          *((_QWORD *)v41 - 1) = v2;
          v2 = *(char **)(a1 + 216);
          v9 = *(char **)(a1 + 224);
          *(_QWORD *)(a1 + 216) = v2 - 8;
          v12 = *((_QWORD *)v2 - 1);
          *(_QWORD *)(a1 + 216) = v2;
          if (v9 == *(char **)(a1 + 232))
            goto LABEL_87;
          goto LABEL_85;
        }
LABEL_114:
        std::__throw_bad_array_new_length[abi:sn180100]();
      }
      v119 = v9 - v10;
      v121 = v5;
      if (v19 == v20)
        v22 = 1;
      else
        v22 = (v19 - v20) >> 2;
      if (v22 >> 61)
        goto LABEL_114;
      v2 = (char *)operator new(8 * v22);
      v23 = &v2[8 * v11];
      v24 = &v2[8 * v22];
      v25 = operator new(0xFF0uLL);
      v12 = (uint64_t)v25;
      if (v11 == v22)
      {
        if (v119 < 1)
        {
          v51 = v119 >> 2;
          if (v9 == v10)
            v51 = 1;
          if (v51 >> 61)
            goto LABEL_114;
          v52 = 8 * v51;
          v23 = (char *)operator new(8 * v51);
          operator delete(v2);
          v24 = &v23[v52];
          v53 = *(char **)(a1 + 216);
          v9 = *(char **)(a1 + 224);
          v2 = v23;
          *(_QWORD *)v23 = v12;
          v27 = v23 + 8;
          if (v9 != v53)
          {
            while (1)
            {
LABEL_53:
              if (v23 == v2)
              {
                if (v27 >= v24)
                {
                  v58 = (v24 - v23) >> 2;
                  if (v24 == v23)
                    v58 = 1;
                  if (v58 >> 61)
                    goto LABEL_114;
                  v59 = (v58 + 3) >> 2;
                  v12 = 8 * v58;
                  v60 = (char *)operator new(8 * v58);
                  v2 = v60;
                  v54 = &v60[8 * v59];
                  v29 = v54;
                  v61 = v27 - v23;
                  if (v27 != v23)
                  {
                    v29 = &v54[v61 & 0xFFFFFFFFFFFFFFF8];
                    v62 = v61 - 8;
                    v63 = &v60[8 * v59];
                    v64 = v23;
                    if (v62 < 0x38)
                      goto LABEL_118;
                    v63 = &v60[8 * v59];
                    v64 = v23;
                    if ((unint64_t)(v63 - v23) < 0x20)
                      goto LABEL_118;
                    v65 = (v62 >> 3) + 1;
                    v66 = 8 * (v65 & 0x3FFFFFFFFFFFFFFCLL);
                    v63 = &v54[v66];
                    v64 = &v23[v66];
                    v67 = (__int128 *)(v23 + 16);
                    v68 = &v60[8 * v59 + 16];
                    v69 = v65 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      v70 = *v67;
                      *((_OWORD *)v68 - 1) = *(v67 - 1);
                      *(_OWORD *)v68 = v70;
                      v67 += 2;
                      v68 += 32;
                      v69 -= 4;
                    }
                    while (v69);
                    if (v65 != (v65 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_118:
                      do
                      {
                        v71 = *(_QWORD *)v64;
                        v64 += 8;
                        *(_QWORD *)v63 = v71;
                        v63 += 8;
                      }
                      while (v63 != v29);
                    }
                  }
                  v24 = &v60[v12];
                  operator delete(v23);
                }
                else
                {
                  v56 = (v24 - v27) >> 3;
                  if (v56 >= -1)
                    v57 = v56 + 1;
                  else
                    v57 = v56 + 2;
                  v29 = &v27[8 * (v57 >> 1)];
                  v54 = &v23[8 * (v57 >> 1)];
                  if (v27 == v23)
                  {
                    v2 = v27;
                  }
                  else
                  {
                    memmove(&v23[8 * (v57 >> 1)], v23, v27 - v23);
                    v2 = v23;
                  }
                }
              }
              else
              {
                v54 = v23;
                v29 = v27;
              }
              v55 = *((_QWORD *)v9 - 1);
              v9 -= 8;
              *((_QWORD *)v54 - 1) = v55;
              v28 = v54 - 8;
              v27 = v29;
              v23 = v28;
              if (v9 == *(char **)(a1 + 216))
                goto LABEL_25;
            }
          }
LABEL_24:
          v28 = v23;
          v29 = v27;
LABEL_25:
          v30 = *(void **)(a1 + 208);
          *(_QWORD *)(a1 + 208) = v2;
          *(_QWORD *)(a1 + 216) = v28;
          v9 = v29;
          *(_QWORD *)(a1 + 224) = v29;
          *(_QWORD *)(a1 + 232) = v24;
          v5 = v121;
          v7 = v124;
          if (v30)
          {
            operator delete(v30);
            v9 = *(char **)(a1 + 224);
          }
          goto LABEL_27;
        }
        v26 = v11 + 2;
        if (v11 >= -1)
          v26 = v11 + 1;
        v23 -= 8 * (v26 >> 1);
      }
      *(_QWORD *)v23 = v25;
      v27 = v23 + 8;
      if (v9 != v10)
        goto LABEL_53;
      goto LABEL_24;
    }
    *(_QWORD *)(a1 + 240) = v17;
    v18 = v10 + 8;
    v12 = *(_QWORD *)v10;
    *(_QWORD *)(a1 + 216) = v10 + 8;
    if (v9 != *(char **)(a1 + 232))
      goto LABEL_8;
    v2 = *(char **)(a1 + 208);
    if (v18 > v2)
    {
      v35 = (v18 - v2) >> 3;
      if (v35 >= -1)
        v36 = v35 + 1;
      else
        v36 = v35 + 2;
      v37 = v36 >> 1;
      v38 = -v37;
      v2 = &v18[-8 * v37];
      v39 = v9 - v18;
      if (v9 != v18)
      {
        memmove(&v18[-8 * v37], v10 + 8, v9 - v18);
        v9 = *(char **)(a1 + 216);
      }
      v40 = &v9[8 * v38];
      v9 = &v2[v39];
      *(_QWORD *)(a1 + 216) = v40;
      *(_QWORD *)(a1 + 224) = &v2[v39];
LABEL_9:
      *(_QWORD *)v9 = v12;
      v9 = (char *)(*(_QWORD *)(a1 + 224) + 8);
      *(_QWORD *)(a1 + 224) = v9;
      goto LABEL_27;
    }
    v42 = (v9 - v2) >> 2;
    if (v9 == v2)
      v42 = 1;
    if (v42 >> 61)
      goto LABEL_114;
    v43 = v42 >> 2;
    v44 = 8 * v42;
    v45 = (char *)operator new(8 * v42);
    v46 = &v45[8 * v43];
    v48 = v9 - v18;
    v47 = v9 == v18;
    v9 = v46;
    if (!v47)
    {
      v9 = &v46[v48 & 0xFFFFFFFFFFFFFFF8];
      v49 = v48 - 8;
      if ((unint64_t)(v48 - 8) < 0x38)
      {
        v50 = &v45[8 * v43];
        do
        {
LABEL_98:
          v101 = *(_QWORD *)v18;
          v18 += 8;
          *(_QWORD *)v50 = v101;
          v50 += 8;
        }
        while (v50 != v9);
        goto LABEL_99;
      }
      v94 = &v45[8 * v43];
      v50 = v94;
      if ((unint64_t)(v94 - v18) < 0x20)
        goto LABEL_98;
      v95 = (v49 >> 3) + 1;
      v96 = 8 * (v95 & 0x3FFFFFFFFFFFFFFCLL);
      v50 = &v46[v96];
      v18 += v96;
      v97 = (__int128 *)(v10 + 24);
      v98 = v94 + 16;
      v99 = v95 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v100 = *v97;
        *(v98 - 1) = *(v97 - 1);
        *v98 = v100;
        v97 += 2;
        v98 += 2;
        v99 -= 4;
      }
      while (v99);
      if (v95 != (v95 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_98;
    }
LABEL_99:
    *(_QWORD *)(a1 + 208) = v45;
    *(_QWORD *)(a1 + 216) = v46;
    *(_QWORD *)(a1 + 224) = v9;
    *(_QWORD *)(a1 + 232) = &v45[v44];
    if (v2)
    {
      operator delete(v2);
      v9 = *(char **)(a1 + 224);
    }
LABEL_8:
    if (v9)
      goto LABEL_9;
    while (1)
    {
LABEL_86:
      __break(1u);
LABEL_87:
      v87 = *(char **)(a1 + 208);
      if (v2 > v87)
      {
        v88 = (v2 - v87) >> 3;
        if (v88 >= -1)
          v89 = v88 + 1;
        else
          v89 = v88 + 2;
        v90 = v89 >> 1;
        v91 = -v90;
        v92 = &v2[-8 * v90];
        v93 = v9 - v2;
        if (v9 != v2)
        {
          memmove(&v2[-8 * v90], v2, v9 - v2);
          v2 = *(char **)(a1 + 216);
        }
        v9 = &v92[v93];
        *(_QWORD *)(a1 + 216) = &v2[8 * v91];
        *(_QWORD *)(a1 + 224) = &v92[v93];
        v7 = v122;
        goto LABEL_9;
      }
      v102 = (v9 - v87) >> 2;
      if (v9 == v87)
        v102 = 1;
      if (v102 >> 61)
        goto LABEL_114;
      v103 = v102 >> 2;
      v104 = 8 * v102;
      v105 = (char *)operator new(8 * v102);
      v106 = &v105[8 * v103];
      v107 = v9 - v2;
      v47 = v9 == v2;
      v9 = v106;
      v7 = v122;
      if (!v47)
      {
        v9 = &v106[v107 & 0xFFFFFFFFFFFFFFF8];
        v108 = v107 - 8;
        if ((unint64_t)(v107 - 8) >= 0x38)
        {
          v110 = &v105[8 * v103];
          v109 = v110;
          if ((unint64_t)(v110 - v2) >= 0x20)
          {
            v111 = (v108 >> 3) + 1;
            v112 = 8 * (v111 & 0x3FFFFFFFFFFFFFFCLL);
            v109 = &v106[v112];
            v113 = &v2[v112];
            v114 = (__int128 *)(v2 + 16);
            v115 = v110 + 16;
            v116 = v111 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v117 = *v114;
              *(v115 - 1) = *(v114 - 1);
              *v115 = v117;
              v114 += 2;
              v115 += 2;
              v116 -= 4;
            }
            while (v116);
            v2 = v113;
            if (v111 == (v111 & 0x3FFFFFFFFFFFFFFCLL))
              goto LABEL_112;
          }
        }
        else
        {
          v109 = &v105[8 * v103];
        }
        do
        {
          v118 = *(_QWORD *)v2;
          v2 += 8;
          *(_QWORD *)v109 = v118;
          v109 += 8;
        }
        while (v109 != v9);
      }
LABEL_112:
      *(_QWORD *)(a1 + 208) = v105;
      *(_QWORD *)(a1 + 216) = v106;
      *(_QWORD *)(a1 + 224) = v9;
      *(_QWORD *)(a1 + 232) = &v105[v104];
      if (v87)
      {
        operator delete(v87);
        v9 = *(char **)(a1 + 224);
      }
LABEL_85:
      if (v9)
        goto LABEL_9;
    }
  }
LABEL_28:
  if (v9 == v13)
    goto LABEL_86;
  v31 = *(_QWORD *)(a1 + 248) + *(_QWORD *)(a1 + 240);
  v32 = *(_QWORD *)&v13[8 * (v31 / 0x66)];
  if (!v32)
    goto LABEL_86;
  v33 = v32 + 40 * (v31 % 0x66);
  *(_QWORD *)v33 = v123;
  ((void (*)(_QWORD, _BYTE *, uint64_t))v125)(0, v7, v33 + 8);
  *(_OWORD *)(v33 + 24) = v125;
  ++*(_QWORD *)(a1 + 248);
  pthread_mutex_unlock(v5);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  *(_BYTE *)(a1 + 121) = 1;
  pthread_cond_broadcast((pthread_cond_t *)(a1 + 72));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
}

uint64_t webrtc::`anonymous namespace'::TaskQueueStdlib::PostDelayedTaskImpl(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t **v10;
  uint64_t **v11;
  uint64_t *v12;
  unint64_t v13;
  _BOOL4 v14;
  _BOOL4 v15;
  BOOL v16;
  _BOOL4 v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;

  if (rtc::g_clock)
  {
    v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v6 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
       / dword_253EA791C;
  }
  v7 = (uint64_t *)(v6 / 1000 + a3);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 128));
  v8 = *(_QWORD *)(a1 + 200) + 1;
  *(_QWORD *)(a1 + 200) = v8;
  v9 = *(uint64_t **)(a1 + 264);
  if (v9)
  {
    while (1)
    {
      while (1)
      {
        v11 = (uint64_t **)v9;
        v12 = (uint64_t *)v9[4];
        v13 = (unint64_t)v11[5];
        v14 = v13 > v8;
        if (v12 != v7)
          v14 = (uint64_t)v12 > (uint64_t)v7;
        if (!v14)
          break;
        v9 = *v11;
        v10 = v11;
        if (!*v11)
          goto LABEL_17;
      }
      v15 = v13 < v8;
      v16 = v12 == v7;
      v17 = (uint64_t)v12 < (uint64_t)v7;
      if (v16)
        v17 = v15;
      if (!v17)
        break;
      v9 = v11[1];
      if (!v9)
      {
        v10 = v11 + 1;
        goto LABEL_17;
      }
    }
  }
  else
  {
    v10 = (uint64_t **)(a1 + 264);
    v11 = (uint64_t **)(a1 + 264);
LABEL_17:
    v18 = (uint64_t *)v11;
    v11 = (uint64_t **)operator new(0x50uLL);
    v11[4] = v7;
    v11[5] = (uint64_t *)v8;
    v11[6] = 0;
    v11[7] = 0;
    v11[8] = (uint64_t *)absl::internal_any_invocable::EmptyManager;
    v11[9] = 0;
    *v11 = 0;
    v11[1] = 0;
    v11[2] = v18;
    *v10 = (uint64_t *)v11;
    v19 = **(_QWORD **)(a1 + 256);
    v20 = (uint64_t *)v11;
    if (v19)
    {
      *(_QWORD *)(a1 + 256) = v19;
      v20 = *v10;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 264), v20);
    ++*(_QWORD *)(a1 + 272);
  }
  ((void (*)(uint64_t, uint64_t **, uint64_t **))v11[8])(1, v11 + 6, v11 + 6);
  v11[8] = (uint64_t *)absl::internal_any_invocable::EmptyManager;
  v11[9] = 0;
  (*(void (**)(_QWORD, uint64_t, uint64_t **))(a2 + 16))(0, a2, v11 + 6);
  *((_OWORD *)v11 + 4) = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(a2 + 24) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 128));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  *(_BYTE *)(a1 + 121) = 1;
  pthread_cond_broadcast((pthread_cond_t *)(a1 + 72));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
}

void webrtc::`anonymous namespace'::TaskQueueStdlib::~TaskQueueStdlib(webrtc::_anonymous_namespace_::TaskQueueStdlib *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!*((_BYTE *)this + 296))
    goto LABEL_6;
  if (!*((_BYTE *)this + 304))
    goto LABEL_5;
  if (!pthread_join(*((pthread_t *)this + 36), 0))
  {
    if (!*((_BYTE *)this + 296))
    {
LABEL_6:
      _ZNSt3__16__treeINS_12__value_typeIN6webrtc12_GLOBAL__N_115TaskQueueStdlib19DelayedEntryTimeoutEN4absl12AnyInvocableIFvvOEEEEENS_19__map_value_compareIS5_SA_NS_4lessIS5_EELb1EEENS_9allocatorISA_EEE7destroyEPNS_11__tree_nodeISA_PvEE(*((_QWORD **)this + 33));
      _ZNSt3__15dequeINS_4pairIyN4absl12AnyInvocableIFvvOEEEEENS_9allocatorIS6_EEED2B8sn180100Ev((void **)this + 26);
      pthread_mutex_destroy((pthread_mutex_t *)this + 2);
      pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
      pthread_cond_destroy((pthread_cond_t *)((char *)this + 72));
      return;
    }
LABEL_5:
    *((_BYTE *)this + 296) = 0;
    goto LABEL_6;
  }
  if (*((_BYTE *)this + 296))
  {
    pthread_join(*((pthread_t *)this + 36), 0);
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/platform_thread.cc", 166, "0 == pthread_join(*handle_, nullptr)", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, v2, v3, v4, v5, 0);
  }
  __break(1u);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*((_BYTE *)this + 296))
  {
    if (!*((_BYTE *)this + 304))
      goto LABEL_5;
    if (pthread_join(*((pthread_t *)this + 36), 0))
    {
      if (*((_BYTE *)this + 296))
      {
        pthread_join(*((pthread_t *)this + 36), 0);
        rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/platform_thread.cc", 166, "0 == pthread_join(*handle_, nullptr)", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, v2, v3, v4, v5, 0);
      }
      __break(1u);
LABEL_10:
      JUMPOUT(0x20BD0ADECLL);
    }
    if (*((_BYTE *)this + 296))
LABEL_5:
      *((_BYTE *)this + 296) = 0;
  }
  _ZNSt3__16__treeINS_12__value_typeIN6webrtc12_GLOBAL__N_115TaskQueueStdlib19DelayedEntryTimeoutEN4absl12AnyInvocableIFvvOEEEEENS_19__map_value_compareIS5_SA_NS_4lessIS5_EELb1EEENS_9allocatorISA_EEE7destroyEPNS_11__tree_nodeISA_PvEE(*((_QWORD **)this + 33));
  _ZNSt3__15dequeINS_4pairIyN4absl12AnyInvocableIFvvOEEEEENS_9allocatorIS6_EEED2B8sn180100Ev((void **)this + 26);
  pthread_mutex_destroy((pthread_mutex_t *)this + 2);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
  pthread_cond_destroy((pthread_cond_t *)((char *)this + 72));
  goto LABEL_10;
}

void std::__function::__func<webrtc::`anonymous namespace'::TaskQueueStdlib::InitializeThread(webrtc::`anonymous namespace'::TaskQueueStdlib*,std::string_view,rtc::ThreadPriority)::$_0,std::allocator<webrtc::`anonymous namespace'::TaskQueueStdlib::InitializeThread(webrtc::`anonymous namespace'::TaskQueueStdlib*,std::string_view,rtc::ThreadPriority)::$_0>,void ()(void)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

__n128 std::__function::__func<webrtc::`anonymous namespace'::TaskQueueStdlib::InitializeThread(webrtc::`anonymous namespace'::TaskQueueStdlib*,std::string_view,rtc::ThreadPriority)::$_0,std::allocator<webrtc::`anonymous namespace'::TaskQueueStdlib::InitializeThread(webrtc::`anonymous namespace'::TaskQueueStdlib*,std::string_view,rtc::ThreadPriority)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24C0C21A8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<webrtc::`anonymous namespace'::TaskQueueStdlib::InitializeThread(webrtc::`anonymous namespace'::TaskQueueStdlib*,std::string_view,rtc::ThreadPriority)::$_0,std::allocator<webrtc::`anonymous namespace'::TaskQueueStdlib::InitializeThread(webrtc::`anonymous namespace'::TaskQueueStdlib*,std::string_view,rtc::ThreadPriority)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24C0C21A8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<webrtc::`anonymous namespace'::TaskQueueStdlib::InitializeThread(webrtc::`anonymous namespace'::TaskQueueStdlib*,std::string_view,rtc::ThreadPriority)::$_0,std::allocator<webrtc::`anonymous namespace'::TaskQueueStdlib::InitializeThread(webrtc::`anonymous namespace'::TaskQueueStdlib*,std::string_view,rtc::ThreadPriority)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  TimeDelta v6;
  TimeDelta v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t result;
  unint64_t v17;
  uint64_t v18;
  int64x2_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  int64x2_t v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t *v30;
  void **v31;
  unint64_t v32;
  uint64_t v33;
  void **v34;
  void **v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  void *v40;
  void *v41;
  BOOL v42;
  uint64_t v43;
  _QWORD *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  void *__p[2];
  _BYTE v50[32];

  v43 = *v2;
  v44 = v2;
  *v2 = v3;
  v4 = *(_QWORD *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)v4);
  *(_BYTE *)(v4 + 113) = 1;
  pthread_cond_broadcast((pthread_cond_t *)(v4 + 64));
  pthread_mutex_unlock((pthread_mutex_t *)v4);
  v5 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    LOBYTE(__p[0]) = 0;
    *(_QWORD *)&v50[8] = absl::internal_any_invocable::EmptyManager;
    *(_QWORD *)&v50[16] = 0;
    *(_QWORD *)&v50[24] = 0x7FFFFFFFFFFFFFFFLL;
    if (rtc::g_clock)
    {
      v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
      pthread_mutex_lock((pthread_mutex_t *)(v5 + 128));
      if (*(_BYTE *)(v5 + 192))
        goto LABEL_9;
    }
    else
    {
      if (!dword_253EA791C)
        mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
      v8 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
         / dword_253EA791C;
      pthread_mutex_lock((pthread_mutex_t *)(v5 + 128));
      if (*(_BYTE *)(v5 + 192))
      {
LABEL_9:
        LOBYTE(__p[0]) = 1;
        goto LABEL_10;
      }
    }
    if (!*(_QWORD *)(v5 + 272))
      goto LABEL_22;
    v9 = v8 / 1000;
    v10 = *(_QWORD *)(v5 + 256);
    v11 = *(_QWORD *)(v10 + 32);
    v12 = __OFSUB__(v11, v9);
    v13 = v11 - v9;
    if (!((v13 < 0) ^ v12 | (v13 == 0)))
    {
      if (v13 % 1000 <= 0)
        v14 = v13 / 1000;
      else
        v14 = v13 / 1000 + 1;
      *(_QWORD *)&v50[24] = 1000 * v14;
LABEL_22:
      if (*(_QWORD *)(v5 + 248))
      {
        v15 = *(_QWORD *)(*(_QWORD *)(v5 + 216) + 8 * (*(_QWORD *)(v5 + 240) / 0x66uLL))
            + 40 * (*(_QWORD *)(v5 + 240) % 0x66uLL);
        *(_QWORD *)&v50[8] = absl::internal_any_invocable::EmptyManager;
        *(_QWORD *)&v50[16] = 0;
        result = (*(uint64_t (**)(_QWORD, unint64_t, void **))(v15 + 24))(0, v15 + 8, &__p[1]);
        *(_OWORD *)&v50[8] = *(_OWORD *)(v15 + 24);
        *(_QWORD *)(v15 + 24) = absl::internal_any_invocable::EmptyManager;
        *(_QWORD *)(v15 + 32) = 0;
        v17 = *(_QWORD *)(v5 + 240);
        v18 = *(_QWORD *)(*(_QWORD *)(v5 + 216) + 8 * (v17 / 0x66));
        if (!v18)
          goto LABEL_60;
        (*(void (**)(uint64_t, unint64_t, unint64_t))(v18 + 40 * (v17 % 0x66) + 24))(1, v18 + 40 * (v17 % 0x66) + 8, v18 + 40 * (v17 % 0x66) + 8);
        v19 = vaddq_s64(*(int64x2_t *)(v5 + 240), (int64x2_t)xmmword_208F0A010);
        *(int64x2_t *)(v5 + 240) = v19;
        if (v19.i64[0] >= 0xCCuLL)
          goto LABEL_25;
      }
      goto LABEL_10;
    }
    if (*(_QWORD *)(v5 + 248)
      && (v20 = *(_QWORD *)(v5 + 240),
          v21 = *(_QWORD *)(*(_QWORD *)(v5 + 216) + 8 * (v20 / 0x66)),
          v22 = v20 % 0x66,
          *(_QWORD *)(v21 + 40 * v22) < *(_QWORD *)(v10 + 40)))
    {
      v23 = v21 + 40 * v22;
      *(_QWORD *)&v50[8] = absl::internal_any_invocable::EmptyManager;
      *(_QWORD *)&v50[16] = 0;
      result = (*(uint64_t (**)(_QWORD, uint64_t, void **))(v23 + 24))(0, v23 + 8, &__p[1]);
      *(_OWORD *)&v50[8] = *(_OWORD *)(v23 + 24);
      *(_QWORD *)(v23 + 24) = absl::internal_any_invocable::EmptyManager;
      *(_QWORD *)(v23 + 32) = 0;
      v24 = *(_QWORD *)(v5 + 240);
      v25 = *(_QWORD *)(*(_QWORD *)(v5 + 216) + 8 * (v24 / 0x66));
      if (!v25)
        goto LABEL_60;
      (*(void (**)(uint64_t, unint64_t, unint64_t))(v25 + 40 * (v24 % 0x66) + 24))(1, v25 + 40 * (v24 % 0x66) + 8, v25 + 40 * (v24 % 0x66) + 8);
      v26 = vaddq_s64(*(int64x2_t *)(v5 + 240), (int64x2_t)xmmword_208F0A010);
      *(int64x2_t *)(v5 + 240) = v26;
      if (v26.i64[0] >= 0xCCuLL)
      {
LABEL_25:
        operator delete(**(void ***)(v5 + 216));
        *(_QWORD *)(v5 + 216) += 8;
        *(_QWORD *)(v5 + 240) -= 102;
      }
    }
    else
    {
      *(_QWORD *)&v50[8] = absl::internal_any_invocable::EmptyManager;
      *(_QWORD *)&v50[16] = 0;
      (*(void (**)(_QWORD, uint64_t, void **))(v10 + 64))(0, v10 + 48, &__p[1]);
      *(_OWORD *)&v50[8] = *(_OWORD *)(v10 + 64);
      *(_QWORD *)(v10 + 64) = absl::internal_any_invocable::EmptyManager;
      *(_QWORD *)(v10 + 72) = 0;
      v27 = *(_QWORD **)(v10 + 8);
      v28 = (_QWORD *)v10;
      if (v27)
      {
        do
        {
          v29 = v27;
          v27 = (_QWORD *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          v29 = (_QWORD *)v28[2];
          v42 = *v29 == (_QWORD)v28;
          v28 = v29;
        }
        while (!v42);
      }
      if (*(_QWORD *)(v5 + 256) == v10)
        *(_QWORD *)(v5 + 256) = v29;
      v30 = *(uint64_t **)(v5 + 264);
      --*(_QWORD *)(v5 + 272);
      std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v30, (uint64_t *)v10);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 64))(1, v10 + 48, v10 + 48);
      operator delete((void *)v10);
    }
LABEL_10:
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 128));
    if (LOBYTE(__p[0]))
      break;
    if (*(_QWORD *)&v50[16])
    {
      (*(void (**)(void **))&v50[16])(&__p[1]);
    }
    else
    {
      v6.var0 = *(_QWORD *)&v50[24];
      if (*(_QWORD *)&v50[24] == 0x7FFFFFFFFFFFFFFFLL)
        v7.var0 = 3000000;
      else
        v7.var0 = 0x7FFFFFFFFFFFFFFFLL;
      rtc::Event::Wait((rtc::Event *)(v5 + 8), v6, v7);
    }
    (*(void (**)(uint64_t, void **, void **))&v50[8])(1, &__p[1], &__p[1]);
  }
  (*(void (**)(uint64_t, void **, void **))&v50[8])(1, &__p[1], &__p[1]);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 128));
  v31 = *(void ***)(v5 + 216);
  __p[0] = *(void **)(v5 + 208);
  __p[1] = v31;
  v45 = *(_OWORD *)(v5 + 224);
  *(_OWORD *)(v5 + 208) = 0u;
  *(_OWORD *)(v5 + 224) = 0u;
  *(_OWORD *)v50 = v45;
  v32 = *(_QWORD *)(v5 + 240);
  v33 = *(_QWORD *)(v5 + 248);
  *(_OWORD *)(v5 + 240) = 0u;
  *(_QWORD *)&v50[16] = v32;
  *(_QWORD *)&v50[24] = v33;
  result = pthread_mutex_unlock((pthread_mutex_t *)(v5 + 128));
  v47 = 0u;
  v48 = 0u;
  v46 = 0u;
  v34 = (void **)v45;
  if ((void **)v45 == v31)
  {
    v34 = v31;
  }
  else
  {
    v35 = &v31[v32 / 0x66];
    v36 = (unint64_t)*v35 + 40 * (v32 % 0x66);
    v37 = (unint64_t)v31[(v33 + v32) / 0x66] + 40 * ((v33 + v32) % 0x66);
    if (v36 != v37)
    {
      while (v36)
      {
        result = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t))(v36 + 24))(1, v36 + 8, v36 + 8);
        v36 += 40;
        if (v36 - (_QWORD)*v35 == 4080)
        {
          v38 = (unint64_t)v35[1];
          ++v35;
          v36 = v38;
        }
        if (v36 == v37)
        {
          v31 = (void **)__p[1];
          v34 = *(void ***)v50;
          goto LABEL_47;
        }
      }
LABEL_60:
      __break(1u);
      return result;
    }
LABEL_47:
    v39 = (char *)v34 - (char *)v31;
    if ((unint64_t)((char *)v34 - (char *)v31) >= 0x11)
    {
      do
      {
        v40 = *v31++;
        operator delete(v40);
        __p[1] = v31;
        v39 -= 8;
      }
      while (v39 > 0x10);
    }
  }
  while (v34 != v31)
  {
    v41 = *--v34;
    operator delete(v41);
  }
  v42 = *(void **)&v50[8] == __p[0] || __p[0] == 0;
  if (!v42)
    operator delete(__p[0]);
  *(_OWORD *)__p = v46;
  *(_OWORD *)v50 = v47;
  v46 = 0u;
  v47 = 0u;
  *(_OWORD *)&v50[16] = v48;
  v48 = 0uLL;
  _ZNSt3__15dequeINS_4pairIyN4absl12AnyInvocableIFvvOEEEEENS_9allocatorIS6_EEED2B8sn180100Ev((void **)&v46);
  result = (uint64_t)_ZNSt3__15dequeINS_4pairIyN4absl12AnyInvocableIFvvOEEEEENS_9allocatorIS6_EEED2B8sn180100Ev(__p);
  *v44 = v43;
  return result;
}

void **_ZNSt3__15dequeINS_4pairIyN4absl12AnyInvocableIFvvOEEEEENS_9allocatorIS6_EEED2B8sn180100Ev(void **result)
{
  void **v1;
  void **v2;
  void **v3;
  unint64_t v4;
  void **v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  void *v12;
  _BYTE *v13;
  _BYTE *v14;

  v1 = result;
  v2 = (void **)result[1];
  v3 = (void **)result[2];
  if (v3 == v2)
  {
    v3 = (void **)result[1];
    result[5] = 0;
    v9 = 0;
    goto LABEL_11;
  }
  v4 = (unint64_t)result[4];
  v5 = &v2[v4 / 0x66];
  v6 = (unint64_t)*v5 + 40 * (v4 % 0x66);
  v7 = (unint64_t)v2[((unint64_t)result[5] + v4) / 0x66]
     + 40 * (((unint64_t)result[5] + v4) % 0x66);
  if (v6 == v7)
  {
LABEL_9:
    v1[5] = 0;
    v9 = (char *)v3 - (char *)v2;
    if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
    {
      do
      {
        operator delete(*v2);
        v3 = (void **)v1[2];
        v2 = (void **)((char *)v1[1] + 8);
        v1[1] = v2;
        v9 = (char *)v3 - (char *)v2;
      }
      while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
    }
LABEL_11:
    v10 = v9 >> 3;
    if (v10 == 1)
    {
      v11 = 51;
    }
    else
    {
      if (v10 != 2)
        goto LABEL_17;
      v11 = 102;
    }
    v1[4] = (void *)v11;
LABEL_17:
    if (v2 != v3)
    {
      do
      {
        v12 = *v2++;
        operator delete(v12);
      }
      while (v2 != v3);
      v14 = v1[1];
      v13 = v1[2];
      if (v13 != v14)
        v1[2] = &v13[(v14 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
    }
    if (*v1)
      operator delete(*v1);
    return v1;
  }
  while (v6)
  {
    result = (void **)(*(uint64_t (**)(uint64_t, unint64_t, unint64_t))(v6 + 24))(1, v6 + 8, v6 + 8);
    v6 += 40;
    if (v6 - (_QWORD)*v5 == 4080)
    {
      v8 = (unint64_t)v5[1];
      ++v5;
      v6 = v8;
    }
    if (v6 == v7)
    {
      v2 = (void **)v1[1];
      v3 = (void **)v1[2];
      goto LABEL_9;
    }
  }
  __break(1u);
  return result;
}

void _ZNSt3__16__treeINS_12__value_typeIN6webrtc12_GLOBAL__N_115TaskQueueStdlib19DelayedEntryTimeoutEN4absl12AnyInvocableIFvvOEEEEENS_19__map_value_compareIS5_SA_NS_4lessIS5_EELb1EEENS_9allocatorISA_EEE7destroyEPNS_11__tree_nodeISA_PvEE(_QWORD *a1)
{
  if (a1)
  {
    _ZNSt3__16__treeINS_12__value_typeIN6webrtc12_GLOBAL__N_115TaskQueueStdlib19DelayedEntryTimeoutEN4absl12AnyInvocableIFvvOEEEEENS_19__map_value_compareIS5_SA_NS_4lessIS5_EELb1EEENS_9allocatorISA_EEE7destroyEPNS_11__tree_nodeISA_PvEE(*a1);
    _ZNSt3__16__treeINS_12__value_typeIN6webrtc12_GLOBAL__N_115TaskQueueStdlib19DelayedEntryTimeoutEN4absl12AnyInvocableIFvvOEEEEENS_19__map_value_compareIS5_SA_NS_4lessIS5_EELb1EEENS_9allocatorISA_EEE7destroyEPNS_11__tree_nodeISA_PvEE(a1[1]);
    ((void (*)(uint64_t, _QWORD *, _QWORD *))a1[8])(1, a1 + 6, a1 + 6);
    operator delete(a1);
  }
}

void dcsctp::TaskQueueTimeoutFactory::TaskQueueTimeout::~TaskQueueTimeout(dcsctp::TaskQueueTimeoutFactory::TaskQueueTimeout *this)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;

  *(_QWORD *)this = &off_24C0C21F0;
  v1 = *((_QWORD *)this + 3);
  *(_BYTE *)(v1 + 4) = 0;
  do
  {
    v2 = __ldaxr((unsigned int *)v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, (unsigned int *)v1));
  if (!v3)
    MEMORY[0x20BD0ADEC]();
}

{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;

  *(_QWORD *)this = &off_24C0C21F0;
  v1 = *((_QWORD *)this + 3);
  *(_BYTE *)(v1 + 4) = 0;
  do
  {
    v2 = __ldaxr((unsigned int *)v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, (unsigned int *)v1));
  if (!v3)
    MEMORY[0x20BD0ADEC]();
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t dcsctp::TaskQueueTimeoutFactory::TaskQueueTimeout::Start(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  unsigned int *v19;
  unsigned int v20;
  _QWORD *v21;
  uint64_t v22;
  char v23;
  _QWORD v24[2];
  uint64_t (*v25)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v26)(uint64_t);

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32);
  if (v4)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
    if (a2 == 0x7FFFFFFF)
    {
      *(_QWORD *)(a1 + 40) = 0x7FFFFFFFFFFFFFFFLL;
      *(_QWORD *)(a1 + 48) = a3;
    }
    else
    {
      v8 = 1000 * (result + a2);
      *(_QWORD *)(a1 + 40) = v8;
      *(_QWORD *)(a1 + 48) = a3;
      v9 = *(_QWORD *)(a1 + 32);
      if (v8 < v9)
      {
        v10 = 1000 * a2;
        if (v9 != 0x7FFFFFFFFFFFFFFFLL)
        {
          *(_BYTE *)(*(_QWORD *)(a1 + 24) + 4) = 0;
          v11 = operator new();
          v12 = v11;
          *(_DWORD *)v11 = 0;
          *(_BYTE *)(v11 + 4) = 1;
          do
            v13 = __ldxr((unsigned int *)v11);
          while (__stxr(v13 + 1, (unsigned int *)v11));
          v14 = *(unsigned int **)(a1 + 24);
          *(_QWORD *)(a1 + 24) = v12;
          if (v14)
          {
            do
            {
              v15 = __ldaxr(v14);
              v16 = v15 - 1;
            }
            while (__stlxr(v16, v14));
            if (!v16)
              MEMORY[0x20BD0ADEC]();
          }
          v8 = *(_QWORD *)(a1 + 40);
        }
        *(_QWORD *)(a1 + 32) = v8;
        v17 = **(_QWORD **)(a1 + 8);
        v18 = *(_DWORD *)(a1 + 16);
        v19 = *(unsigned int **)(a1 + 24);
        if (v19)
        {
          do
            v20 = __ldxr(v19);
          while (__stxr(v20 + 1, v19));
        }
        v21 = (_QWORD *)operator new();
        *v21 = v19;
        v21[1] = a3;
        v21[2] = a1;
        v21[3] = absl::internal_any_invocable::LocalManagerTrivial;
        v21[4] = absl::internal_any_invocable::LocalInvoker<false,void,dcsctp::TaskQueueTimeoutFactory::TaskQueueTimeout::Start(dcsctp::DurationMs,webrtc::StrongAlias<dcsctp::TimeoutTag,unsigned long long>)::$_1 &&>;
        v24[0] = v21;
        v25 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
        v26 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
        webrtc::TaskQueueBase::PostDelayedTaskWithPrecision(v17, v18, (uint64_t)v24, v10, (uint64_t)&v23);
        return v25(1, v24, v24);
      }
    }
  }
  else
  {
    v22 = std::__throw_bad_function_call[abi:sn180100]();
    return dcsctp::TaskQueueTimeoutFactory::TaskQueueTimeout::Stop(v22);
  }
  return result;
}

uint64_t dcsctp::TaskQueueTimeoutFactory::TaskQueueTimeout::Stop(uint64_t this)
{
  *(_QWORD *)(this + 40) = 0x7FFFFFFFFFFFFFFFLL;
  return this;
}

uint64_t dcsctp::Timeout::Restart(uint64_t a1, unsigned int a2, uint64_t a3)
{
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 16))(a1, a2, a3);
}

void absl::internal_any_invocable::LocalInvoker<false,void,dcsctp::TaskQueueTimeoutFactory::TaskQueueTimeout::Start(dcsctp::DurationMs,webrtc::StrongAlias<dcsctp::TimeoutTag,unsigned long long>)::$_1 &&>(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  cricket::TCPPort *v10;
  uint64_t v11;

  v1 = *(_QWORD **)(a1 + 8);
  v1[4] = 0x7FFFFFFFFFFFFFFFLL;
  if (v1[5] == 0x7FFFFFFFFFFFFFFFLL)
    return;
  v2 = *(_QWORD *)(v1[1] + 32);
  if (!v2)
  {
LABEL_15:
    v10 = (cricket::TCPPort *)std::__throw_bad_function_call[abi:sn180100]();
    cricket::TCPPort::TryCreateServerSocket(v10);
    return;
  }
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  v4 = v1[5];
  if (v4 == 0x8000000000000000)
  {
    v1[5] = 0x7FFFFFFFFFFFFFFFLL;
LABEL_12:
    v8 = v1[1];
    v11 = v1[6];
    v9 = *(_QWORD *)(v8 + 64);
    if (v9)
    {
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v9 + 48))(v9, &v11);
      return;
    }
    goto LABEL_15;
  }
  if (v4 != 0x7FFFFFFFFFFFFFFFLL)
  {
    v5 = v4 - 1000 * v3;
    v1[5] = 0x7FFFFFFFFFFFFFFFLL;
    if (v5 >= 1)
      goto LABEL_8;
    goto LABEL_12;
  }
  v1[5] = 0x7FFFFFFFFFFFFFFFLL;
  v5 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_8:
  v6 = v5 / 0x3E8uLL;
  if (v5 % 0x3E8uLL <= 0x1F3)
    v7 = v6;
  else
    v7 = (v6 + 1);
  (*(void (**)(_QWORD *, uint64_t, _QWORD))(*v1 + 16))(v1, v7, v1[6]);
}

void cricket::TCPPort::TryCreateServerSocket(cricket::TCPPort *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v17[8];
  int v18;
  __int128 v19;
  void *__p[2];
  uint64_t v21;
  void *v22;
  int v23;
  __int128 v24;
  __int16 v25;
  int v26;
  char v27;

  v2 = (*(uint64_t (**)(cricket::TCPPort *))(*(_QWORD *)this + 216))(this);
  v3 = (*(uint64_t (**)(cricket::TCPPort *))(*(_QWORD *)this + 24))(this);
  rtc::Network::GetBestIP(v3, (uint64_t)v17);
  __p[0] = 0;
  __p[1] = 0;
  v21 = 0;
  v22 = &unk_24C0ACDA0;
  v27 = 0;
  v23 = v18;
  v24 = v19;
  v26 = 0;
  v25 = 0;
  v4 = (*(uint64_t (**)(uint64_t, void **, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v2 + 24))(v2, __p, *((unsigned __int16 *)this + 280), *((unsigned __int16 *)this + 281), 0);
  v5 = *((_QWORD *)this + 100);
  *((_QWORD *)this + 100) = v4;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  if (SHIBYTE(v21) < 0)
  {
    operator delete(__p[0]);
    v6 = *((_QWORD *)this + 100);
    if (v6)
      goto LABEL_5;
  }
  else
  {
    v6 = *((_QWORD *)this + 100);
    if (v6)
    {
LABEL_5:
      v7 = operator new(0x30uLL);
      v7[2] = sigslot::_opaque_connection::emitter<cricket::TCPPort,rtc::AsyncListenSocket *,rtc::AsyncPacketSocket *>;
      v7[3] = (char *)this + 232;
      v7[4] = cricket::TCPPort::OnNewConnection;
      v7[5] = 0;
      v9 = *(_QWORD *)(v6 + 72);
      v8 = (_QWORD *)(v6 + 72);
      *v7 = v9;
      v7[1] = v8;
      *(_QWORD *)(v9 + 8) = v7;
      *v8 = v7;
      ++v8[2];
      (*((void (**)(char *, _QWORD *))this + 30))((char *)this + 232, v8 - 2);
      return;
    }
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
  {
    (*(void (**)(void **__return_ptr, cricket::TCPPort *))(*(_QWORD *)this + 176))(__p, this);
    rtc::webrtc_logging_impl::Log("\r\n\t", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
    if (SHIBYTE(v21) < 0)
      operator delete(__p[0]);
  }
}

void cricket::TCPPort::~TCPPort(cricket::TCPPort *this)
{
  uint64_t v2;
  char *v3;
  uint64_t i;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  char *v15;

  *(_QWORD *)this = &off_24C0C2228;
  *((_QWORD *)this + 29) = &unk_24C0C23A0;
  v2 = *((_QWORD *)this + 100);
  *((_QWORD *)this + 100) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (char *)this + 840;
  for (i = *((_QWORD *)this + 106); (char *)i != v3; i = *(_QWORD *)(i + 8))
  {
    v5 = *(_QWORD *)(i + 88);
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  }
  if (*((_QWORD *)this + 107))
  {
    v6 = (char *)*((_QWORD *)this + 106);
    v7 = *((_QWORD *)this + 105);
    v8 = *(_QWORD *)v6;
    *(_QWORD *)(v8 + 8) = *(_QWORD *)(v7 + 8);
    **(_QWORD **)(v7 + 8) = v8;
    *((_QWORD *)this + 107) = 0;
    if (v6 != v3)
    {
      do
      {
        v9 = (char *)*((_QWORD *)v6 + 1);
        if (v6[39] < 0)
          operator delete(*((void **)v6 + 2));
        operator delete(v6);
        v6 = v9;
      }
      while (v9 != v3);
      if (*((_QWORD *)this + 107))
      {
        v10 = (char *)*((_QWORD *)this + 106);
        v11 = *((_QWORD *)this + 105);
        v12 = *(_QWORD *)v10;
        *(_QWORD *)(v12 + 8) = *(_QWORD *)(v11 + 8);
        **(_QWORD **)(v11 + 8) = v12;
        *((_QWORD *)this + 107) = 0;
        if (v10 != v3)
        {
          do
          {
            v15 = (char *)*((_QWORD *)v10 + 1);
            if (v10[39] < 0)
              operator delete(*((void **)v10 + 2));
            operator delete(v10);
            v10 = v15;
          }
          while (v15 != v3);
        }
      }
    }
  }
  v13 = (void *)*((_QWORD *)this + 101);
  if (v13)
  {
    *((_QWORD *)this + 102) = v13;
    operator delete(v13);
  }
  v14 = *((_QWORD *)this + 100);
  *((_QWORD *)this + 100) = 0;
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  cricket::Port::~Port(this);
}

{
  cricket::TCPPort::~TCPPort(this);
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'cricket::TCPPort::~TCPPort(cricket::TCPPort *this)
{
  cricket::TCPPort::~TCPPort((cricket::TCPPort *)((char *)this - 232));
}

{
  cricket::TCPPort::~TCPPort((cricket::TCPPort *)((char *)this - 232));
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t cricket::TCPPort::CreateConnection(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t **v10;
  uint64_t v11;
  uint64_t v12;
  cricket::Connection *v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int v29;
  _QWORD *v30;
  unsigned int *v31;
  unsigned int v32;
  uint64_t v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int *v37;
  unsigned int v38;
  uint64_t v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  uint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  uint64_t v53;
  unsigned int *v54;
  unsigned int v55;
  unsigned int v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  int v60;
  uint64_t v61;

  v5 = result;
  v6 = (uint64_t *)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    v7 = *(_QWORD *)(a2 + 40);
    if (v7 < 0)
      goto LABEL_94;
    v8 = (uint64_t *)*v6;
    if (v7 && v8 == 0)
      goto LABEL_94;
  }
  else
  {
    v7 = *(unsigned __int8 *)(a2 + 55);
    v8 = (uint64_t *)(a2 + 32);
  }
  result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(*(_QWORD *)result + 72))(result, v8, v7);
  if (!(_DWORD)result)
    return 0;
  v10 = (uint64_t **)(a2 + 352);
  v11 = *(unsigned __int8 *)(a2 + 375);
  if (*(char *)(a2 + 375) < 0)
  {
    v12 = *(_QWORD *)(a2 + 360);
    if (v12 < 0)
      goto LABEL_94;
    v10 = (uint64_t **)*v10;
    if (v12)
    {
      if (!v10)
        goto LABEL_94;
    }
  }
  else
  {
    v12 = *(unsigned __int8 *)(a2 + 375);
  }
  if (v12 == 6
    && !(*(_DWORD *)v10 ^ *(_DWORD *)"active" | *((unsigned __int16 *)v10 + 2) ^ *(unsigned __int16 *)"ve")
    && *(_DWORD *)(a2 + 208) != 2)
  {
    return 0;
  }
  if ((v11 & 0x80u) != 0)
    v11 = *(_QWORD *)(a2 + 360);
  if (!v11)
  {
    v14 = 0;
    if (a3 == 1 || !*(_WORD *)(a2 + 136))
      return (uint64_t)v14;
    goto LABEL_27;
  }
  if (a3 == 1)
    return 0;
LABEL_27:
  if ((*(char *)(a2 + 55) & 0x80000000) == 0)
  {
    v15 = *(unsigned __int8 *)(a2 + 55);
    goto LABEL_32;
  }
  v15 = *(_QWORD *)(a2 + 40);
  if ((v15 & 0x8000000000000000) == 0)
  {
    v6 = (uint64_t *)*v6;
    if (!v15 || v6)
    {
LABEL_32:
      if (v15 == 6)
      {
        v16 = bswap32(*(_DWORD *)v6);
        v17 = bswap32(*(unsigned int *)"ssltcp");
        if (v16 == v17
          && (v16 = bswap32(*((unsigned __int16 *)v6 + 2)) >> 16,
              v17 = bswap32(*(unsigned __int16 *)"cp") >> 16,
              v16 == v17))
        {
          v18 = 0;
        }
        else
        {
          v18 = v16 < v17 ? -1 : 1;
        }
        if (!(v18 | a3))
          return 0;
      }
      rtc::Network::GetBestIP(*(_QWORD *)(v5 + 552), (uint64_t)&v59);
      v19 = *(_DWORD *)(a2 + 112);
      if (v19 != v60 || v19 == 30 && ((v61 & 0xC0FF) == 33022) != ((*(_QWORD *)(a2 + 116) & 0xC0FFLL) == 33022))
        return 0;
      v20 = *(uint64_t **)(v5 + 848);
      if (v20 != (uint64_t *)(v5 + 840))
      {
        while (!rtc::SocketAddress::EqualIPs((rtc::SocketAddress *)(v20 + 2), (const rtc::SocketAddress *)(a2 + 80))
             || *((unsigned __int16 *)v20 + 36) != *(unsigned __int16 *)(a2 + 136))
        {
          v20 = (uint64_t *)v20[1];
          if (v20 == (uint64_t *)(v5 + 840))
            goto LABEL_60;
        }
        v21 = v20[11];
        v22 = *v20;
        *(_QWORD *)(v22 + 8) = v20[1];
        *(_QWORD *)v20[1] = v22;
        --*(_QWORD *)(v5 + 856);
        if (*((char *)v20 + 39) < 0)
          operator delete((void *)v20[2]);
        operator delete(v20);
        if (v21)
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(v21 + 328))(1, v21 + 312, v21 + 312);
          *(_QWORD *)(v21 + 328) = absl::internal_any_invocable::EmptyManager;
          *(_QWORD *)(v21 + 336) = 0;
          v14 = (cricket::Connection *)operator new();
          rtc::internal::WeakReferenceOwner::GetRef(v5 + 776, &v59);
          v23 = *(_QWORD *)(v5 + 784);
          *(_QWORD *)&v58 = v59;
          if (v59)
          {
            v24 = (unsigned int *)(v59 + 4);
            do
              v25 = __ldxr(v24);
            while (__stxr(v25 + 1, v24));
            *((_QWORD *)&v58 + 1) = v23;
            do
            {
              v26 = __ldaxr(v24);
              v27 = v26 - 1;
            }
            while (__stlxr(v27, v24));
            if (!v27)
              MEMORY[0x20BD0ADEC]();
          }
          else
          {
            *((_QWORD *)&v58 + 1) = v23;
          }
          cricket::TCPConnection::TCPConnection((uint64_t)v14, &v58, (std::string *)a2, (rtc::AsyncPacketSocket *)v21);
          if ((_QWORD)v58)
          {
            v54 = (unsigned int *)(v58 + 4);
            do
            {
              v55 = __ldaxr(v54);
              v56 = v55 - 1;
            }
            while (__stlxr(v56, v54));
            if (!v56)
              MEMORY[0x20BD0ADEC]();
          }
LABEL_87:
          cricket::Port::AddOrReplaceConnection((cricket::Port *)v5, v14);
          return (uint64_t)v14;
        }
      }
LABEL_60:
      v14 = (cricket::Connection *)operator new();
      v28 = *(_QWORD *)(v5 + 776);
      if (v28 && (v29 = atomic_load((unsigned int *)(v28 + 4)), v29 != 1))
      {
        v30 = *(_QWORD **)(v5 + 776);
        if (!v30)
        {
          v43 = *(_QWORD *)(v5 + 784);
          *(_QWORD *)&v57 = 0;
          *((_QWORD *)&v57 + 1) = v43;
LABEL_80:
          cricket::TCPConnection::TCPConnection((uint64_t)v14, &v57, (std::string *)a2, 0);
          if ((_QWORD)v57)
          {
            v44 = (unsigned int *)(v57 + 4);
            do
            {
              v45 = __ldaxr(v44);
              v46 = v45 - 1;
            }
            while (__stlxr(v46, v44));
            if (!v46)
              MEMORY[0x20BD0ADEC]();
          }
          v47 = *((_QWORD *)v14 + 360);
          if (v47)
          {
            v48 = operator new(0x30uLL);
            v48[2] = sigslot::_opaque_connection::emitter<cricket::TCPPort,rtc::AsyncPacketSocket *>;
            v48[3] = v5 + 232;
            v48[4] = cricket::TCPPort::OnReadyToSend;
            v48[5] = 0;
            v50 = *(_QWORD *)(v47 + 128);
            v49 = (_QWORD *)(v47 + 128);
            *v48 = v50;
            v48[1] = v49;
            *(_QWORD *)(v50 + 8) = v48;
            *v49 = v48;
            ++v49[2];
            (*(void (**)(uint64_t, _QWORD *))(v5 + 240))(v5 + 232, v49 - 2);
            v51 = (_QWORD *)*((_QWORD *)v14 + 360);
            v52 = operator new(0x30uLL);
            v52[2] = sigslot::_opaque_connection::emitter<cricket::TCPPort,rtc::AsyncPacketSocket *,rtc::SentPacket const&>;
            v52[3] = v5 + 232;
            *((_OWORD *)v52 + 2) = xmmword_208F17020;
            v53 = v51[9];
            v51 += 9;
            *v52 = v53;
            v52[1] = v51;
            *(_QWORD *)(v53 + 8) = v52;
            *v51 = v52;
            ++v51[2];
            (*(void (**)(uint64_t, _QWORD *))(v5 + 240))(v5 + 232, v51 - 2);
          }
          goto LABEL_87;
        }
      }
      else
      {
        v30 = (_QWORD *)operator new();
        *v30 = 1;
        v31 = (unsigned int *)v30 + 1;
        do
          v32 = __ldxr(v31);
        while (__stxr(v32 + 1, v31));
        v33 = *(_QWORD *)(v5 + 776);
        if (v33)
        {
          v34 = (unsigned int *)(v33 + 4);
          do
          {
            v35 = __ldaxr(v34);
            v36 = v35 - 1;
          }
          while (__stlxr(v36, v34));
          if (!v36)
            MEMORY[0x20BD0ADEC]();
        }
        *(_QWORD *)(v5 + 776) = v30;
      }
      v37 = (unsigned int *)v30 + 1;
      do
        v38 = __ldxr(v37);
      while (__stxr(v38 + 1, v37));
      v39 = *(_QWORD *)(v5 + 784);
      *(_QWORD *)&v57 = v30;
      do
        v40 = __ldxr(v37);
      while (__stxr(v40 + 1, v37));
      *((_QWORD *)&v57 + 1) = v39;
      do
      {
        v41 = __ldaxr(v37);
        v42 = v41 - 1;
      }
      while (__stlxr(v42, v37));
      if (!v42)
        MEMORY[0x20BD0ADEC](v30, 0x1000C404A09149ALL);
      goto LABEL_80;
    }
  }
LABEL_94:
  __break(1u);
  return result;
}

_QWORD *cricket::TCPPort::OnReadyToSend(_QWORD *this, rtc::AsyncPacketSocket *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  void (*v6)(_QWORD *, _QWORD *);
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  v2 = (_QWORD *)this[84];
  v3 = this + 85;
  if (v2 != this + 85)
  {
    do
    {
      v4 = (_QWORD *)v2[13];
      this = (_QWORD *)v4[18];
      for (v4[20] = this; this != v4 + 17; this = (_QWORD *)v4[20])
      {
        v6 = (void (*)(_QWORD *, _QWORD *))this[2];
        v5 = this + 2;
        v4[20] = *(v5 - 1);
        v6(v5, v4);
      }
      v7 = (_QWORD *)v2[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v2[2];
          v9 = *v8 == (_QWORD)v2;
          v2 = v8;
        }
        while (!v9);
      }
      v2 = v8;
    }
    while (v8 != v3);
  }
  return this;
}

void cricket::TCPPort::PrepareAddress(cricket::TCPPort *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE v18[8];
  int v19;
  __int128 v20;
  _BYTE v21[8];
  int v22;
  __int128 v23;
  void *__p;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  __int16 v31;
  int v32;
  char v33;
  void *v34[2];
  uint64_t v35;
  void *v36;
  int v37;
  __int128 v38;
  __int16 v39;
  int v40;
  char v41;
  __int128 v42;
  uint64_t v43;
  void *v44;
  int v45;
  __int128 v46;
  __int16 v47;
  int v48;
  char v49;

  if (*((_QWORD *)this + 100))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)this + 100) + 16))(*((_QWORD *)this + 100));
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
    }
    (*(void (**)(__int128 *__return_ptr))(**((_QWORD **)this + 100) + 24))(&v42);
    (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 100) + 24))(v34);
    __p = 0;
    v25 = 0;
    v26 = 0;
    v27 = &unk_24C0ACDA0;
    v33 = 0;
    v31 = 0;
    v32 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    cricket::Port::AddAddress((uint64_t)this, &v42, (const rtc::SocketAddress *)v34, (uint64_t)&__p, (char *)&cricket::TCP_PROTOCOL_NAME, 3uLL, &byte_208EB9246, 0, "passive", 7uLL, 0, 90, 0, &byte_208EB9246, 0, 1u);
  }
  else
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      (*(void (**)(__int128 *__return_ptr, cricket::TCPPort *))(*(_QWORD *)this + 176))(&v42, this);
      rtc::webrtc_logging_impl::Log("\r\n\t", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
      if (SHIBYTE(v43) < 0)
        operator delete((void *)v42);
    }
    v16 = (*(uint64_t (**)(cricket::TCPPort *))(*(_QWORD *)this + 24))(this);
    rtc::Network::GetBestIP(v16, (uint64_t)v21);
    v42 = 0uLL;
    v43 = 0;
    v44 = &unk_24C0ACDA0;
    v49 = 0;
    v45 = v22;
    v46 = v23;
    v48 = 0;
    v47 = 9;
    v17 = (*(uint64_t (**)(cricket::TCPPort *))(*(_QWORD *)this + 24))(this);
    rtc::Network::GetBestIP(v17, (uint64_t)v18);
    v34[0] = 0;
    v34[1] = 0;
    v35 = 0;
    v36 = &unk_24C0ACDA0;
    v41 = 0;
    v37 = v19;
    v38 = v20;
    v40 = 0;
    v39 = 0;
    __p = 0;
    v25 = 0;
    v26 = 0;
    v27 = &unk_24C0ACDA0;
    v33 = 0;
    v31 = 0;
    v32 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    cricket::Port::AddAddress((uint64_t)this, &v42, (const rtc::SocketAddress *)v34, (uint64_t)&__p, (char *)&cricket::TCP_PROTOCOL_NAME, 3uLL, &byte_208EB9246, 0, "active", 6uLL, 0, 90, 0, &byte_208EB9246, 0, 1u);
  }
  if (SHIBYTE(v26) < 0)
  {
    operator delete(__p);
    if ((SHIBYTE(v35) & 0x80000000) == 0)
    {
LABEL_11:
      if ((SHIBYTE(v43) & 0x80000000) == 0)
        return;
LABEL_15:
      operator delete((void *)v42);
      return;
    }
  }
  else if ((SHIBYTE(v35) & 0x80000000) == 0)
  {
    goto LABEL_11;
  }
  operator delete(v34[0]);
  if (SHIBYTE(v43) < 0)
    goto LABEL_15;
}

uint64_t cricket::TCPPort::SendTo(cricket::TCPPort *this, const void *a2, uint64_t a3, const rtc::SocketAddress *a4, const rtc::PacketOptions *a5)
{
  uint64_t v10;
  cricket::Connection *v11;
  uint64_t v12;
  _BYTE *v13;
  _BYTE *v14;
  size_t v15;
  char *v16;
  char *v17;
  __int128 v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t i;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  std::string v52;
  void *__p;
  void *v54;
  char *v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  __int16 v60;
  void *v61[2];
  char v62;

  v10 = (*(uint64_t (**)(cricket::TCPPort *, const rtc::SocketAddress *))(*(_QWORD *)this + 88))(this, a4);
  if (!v10)
  {
    for (i = *((_QWORD *)this + 106);
          (cricket::TCPPort *)i != (cricket::TCPPort *)((char *)this + 840);
          i = *(_QWORD *)(i + 8))
    {
      if (rtc::SocketAddress::EqualIPs((rtc::SocketAddress *)(i + 16), a4)
        && *(unsigned __int16 *)(i + 72) == *((unsigned __int16 *)a4 + 28))
      {
        v12 = *(_QWORD *)(i + 88);
        if (v12)
          goto LABEL_4;
        break;
      }
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      goto LABEL_34;
    (*(void (**)(std::string *__return_ptr, cricket::TCPPort *))(*(_QWORD *)this + 176))(&v52, this);
    rtc::SocketAddress::ToSensitiveString(a4, (char *)v61);
    rtc::webrtc_logging_impl::Log("\r\n\t\n", v30, v31, v32, v33, v34, v35, v36, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
    if ((v62 & 0x80000000) == 0)
      goto LABEL_25;
    goto LABEL_24;
  }
  v11 = (cricket::Connection *)v10;
  if (!*(_BYTE *)(v10 + 2333))
  {
    if (!*(_BYTE *)(v10 + 2893) && *(_BYTE *)(v10 + 2892))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        cricket::Connection::ToString(v11, &v52);
        rtc::webrtc_logging_impl::Log("\r\n\t", v37, v38, v39, v40, v41, v42, v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v52.__r_.__value_.__l.__data_);
      }
      cricket::TCPConnection::CreateOutgoingTcpSocket(v11);
      *((_DWORD *)v11 + 722) = 32;
    }
    return 0xFFFFFFFFLL;
  }
  v12 = *(_QWORD *)(v10 + 2880);
  if (!v12)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    {
LABEL_34:
      *((_DWORD *)this + 208) = 65;
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(std::string *__return_ptr, cricket::TCPPort *))(*(_QWORD *)this + 176))(&v52, this);
    rtc::SocketAddress::ToSensitiveString(a4, (char *)v61);
    rtc::webrtc_logging_impl::Log("\r\n\t\n", v45, v46, v47, v48, v49, v50, v51, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
    if ((v62 & 0x80000000) == 0)
    {
LABEL_25:
      if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v52.__r_.__value_.__l.__data_);
      goto LABEL_34;
    }
LABEL_24:
    operator delete(v61[0]);
    goto LABEL_25;
  }
LABEL_4:
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = *(_OWORD *)a5;
  LODWORD(v52.__r_.__value_.__r.__words[2]) = *((_DWORD *)a5 + 4);
  v54 = 0;
  v55 = 0;
  __p = 0;
  v14 = (_BYTE *)*((_QWORD *)a5 + 3);
  v13 = (_BYTE *)*((_QWORD *)a5 + 4);
  v15 = v13 - v14;
  if (v13 != v14)
  {
    if ((v15 & 0x8000000000000000) != 0)
      abort();
    v16 = (char *)operator new(v13 - v14);
    v17 = &v16[v15];
    __p = v16;
    v55 = &v16[v15];
    memcpy(v16, v14, v15);
    v54 = v17;
  }
  v18 = *((_OWORD *)a5 + 4);
  v56 = *((_OWORD *)a5 + 3);
  v57 = v18;
  v58 = *((_OWORD *)a5 + 5);
  v59 = *((_QWORD *)a5 + 12);
  v60 = *((_WORD *)a5 + 52);
  v19 = (*(uint64_t (**)(cricket::TCPPort *))(*(_QWORD *)this + 128))(this);
  if (v19 < 4)
    v20 = v19 + 1;
  else
    v20 = 0;
  DWORD2(v57) = v20;
  WORD6(v57) = *(_WORD *)((*(uint64_t (**)(cricket::TCPPort *))(*(_QWORD *)this + 24))(this) + 286);
  BYTE14(v57) = 1;
  v21 = (*(uint64_t (**)(uint64_t, const void *, uint64_t, std::string *))(*(_QWORD *)v12 + 32))(v12, a2, a3, &v52);
  if ((v21 & 0x80000000) != 0)
  {
    *((_DWORD *)this + 208) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 80))(v12);
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
    {
      (*(void (**)(void **__return_ptr, cricket::TCPPort *))(*(_QWORD *)this + 176))(v61, this);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v22, v23, v24, v25, v26, v27, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
      if (v62 < 0)
        operator delete(v61[0]);
    }
  }
  if (__p)
  {
    v54 = __p;
    operator delete(__p);
  }
  return v21;
}

uint64_t cricket::TCPPort::GetOption(uint64_t a1, int a2, _DWORD *a3)
{
  char *v3;
  char *v4;
  unint64_t v5;
  char *v6;
  unint64_t v7;
  int *v8;
  char *v9;
  int v10;
  uint64_t result;

  v3 = *(char **)(a1 + 808);
  v4 = *(char **)(a1 + 816);
  if (v4 == v3)
  {
    v6 = *(char **)(a1 + 816);
LABEL_13:
    if (v4 == v6)
      v6 = *(char **)(a1 + 816);
    if (v6 != v4)
      goto LABEL_11;
    return 0xFFFFFFFFLL;
  }
  v5 = (v4 - v3) >> 3;
  v6 = *(char **)(a1 + 808);
  do
  {
    v7 = v5 >> 1;
    v8 = (int *)&v6[8 * (v5 >> 1)];
    v10 = *v8;
    v9 = (char *)(v8 + 2);
    v5 += ~(v5 >> 1);
    if (v10 < a2)
      v6 = v9;
    else
      v5 = v7;
  }
  while (v5);
  if (v4 == v6)
    goto LABEL_13;
  if (&v6[8 * (*(_DWORD *)v6 <= a2)] == v6)
    v6 = *(char **)(a1 + 816);
  if (v6 != v4)
  {
LABEL_11:
    result = 0;
    *a3 = *(_DWORD *)&v3[8 * ((v6 - v3) >> 3) + 4];
    return result;
  }
  return 0xFFFFFFFFLL;
}

uint64_t cricket::TCPPort::SetOption(_QWORD *a1, int a2, int a3)
{
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  int *v12;
  char *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  _OWORD *v28;
  char *v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  void *v47;
  char *v48;
  _QWORD *v49;
  char *v50;
  char *v51;
  char *v52;
  unint64_t v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;
  uint64_t v59;
  __int128 v60;
  uint64_t v61;
  char *v62;
  char *v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _OWORD *v67;
  char *v68;
  uint64_t v69;
  __int128 v70;
  uint64_t v71;
  void *v72;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  char *v78;
  char *v79;
  unint64_t v80;
  BOOL v81;
  BOOL v82;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  unint64_t v87;
  const float *v88;
  float *v89;
  uint64_t v90;
  float32x4x2_t v91;

  v6 = (char *)a1[101];
  v7 = (char *)a1[102];
  v8 = v7 - v6;
  if (v7 == v6)
  {
    v15 = v7 - v6;
    v16 = (v7 - v6) >> 3;
    v17 = &v6[(v7 - v6) & 0xFFFFFFFFFFFFFFF8];
    if (v17 != v7)
      goto LABEL_8;
  }
  else
  {
    v9 = v8 >> 3;
    v10 = (char *)a1[101];
    do
    {
      v11 = v9 >> 1;
      v12 = (int *)&v10[8 * (v9 >> 1)];
      v14 = *v12;
      v13 = (char *)(v12 + 2);
      v9 += ~(v9 >> 1);
      if (v14 < a2)
        v10 = v13;
      else
        v9 = v11;
    }
    while (v9);
    v15 = v10 - v6;
    v16 = (v10 - v6) >> 3;
    v17 = &v6[(v10 - v6) & 0xFFFFFFFFFFFFFFF8];
    if (v17 != v7)
    {
LABEL_8:
      if (*(_DWORD *)v17 <= a2)
        goto LABEL_67;
      v18 = a1[103];
      if ((unint64_t)v7 < v18)
      {
        v19 = v7 - (v17 + 8);
        v20 = (unint64_t)(v7 - 8);
        v21 = (char *)a1[102];
        if ((unint64_t)v7 >= 8)
        {
          v22 = (v15 & 0xFFFFFFFFFFFFFFF8) + v19;
          v23 = (unint64_t)&v6[v22 + 8];
          if ((unint64_t)v7 > v23)
            v23 = a1[102];
          v24 = v23 + ~(unint64_t)v6 - v22;
          v25 = v7 - 8;
          v21 = (char *)a1[102];
          if (v24 < 0x58)
            goto LABEL_89;
          v25 = v7 - 8;
          v21 = (char *)a1[102];
          if ((unint64_t)(v17 + 8 - &v6[v15 & 0xFFFFFFFFFFFFFFF8]) < 0x20)
            goto LABEL_89;
          v26 = (v24 >> 3) + 1;
          v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
          v25 = (char *)(v20 + v27);
          v21 = &v7[v27];
          v28 = v7 + 16;
          v29 = &v6[8 * (v19 >> 3) + 16 + 8 * v16];
          v30 = v26 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v31 = *(_OWORD *)v29;
            *(v28 - 1) = *((_OWORD *)v29 - 1);
            *v28 = v31;
            v28 += 2;
            v29 += 32;
            v30 -= 4;
          }
          while (v30);
          if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_89:
            do
            {
              v32 = *(_QWORD *)v25;
              v25 += 8;
              *(_QWORD *)v21 = v32;
              v21 += 8;
            }
            while (v25 < v7);
          }
        }
        a1[102] = v21;
        if (v7 != v17 + 8)
        {
          v33 = v19 - 8;
          if ((unint64_t)(v19 - 8) < 0xB8)
            goto LABEL_21;
          v74 = v19 & 0xFFFFFFFFFFFFFFF8;
          v75 = (v19 & 0xFFFFFFFFFFFFFFF8) - 8;
          v76 = v19 + (v15 & 0xFFFFFFFFFFFFFFF8);
          v77 = (unint64_t)&v6[v76 - v75 - 8];
          v76 -= 4;
          v78 = &v6[v76];
          v79 = &v7[-v74];
          v80 = (unint64_t)&v6[v76 - v75];
          v81 = (unint64_t)(v79 + 4) >= v20 || v80 >= (unint64_t)v7;
          v82 = !v81;
          if (v77 < (unint64_t)(v7 - 4) && v79 < v78)
            goto LABEL_21;
          if (v82)
            goto LABEL_21;
          v84 = (v33 >> 3) + 1;
          v85 = 8 * (v84 & 0x3FFFFFFFFFFFFFFCLL);
          v86 = &v7[-v85];
          v87 = v20 - v85;
          v88 = (const float *)(v7 - 40);
          v89 = (float *)(v7 - 32);
          v90 = v84 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v91 = vld2q_f32(v88);
            v88 -= 8;
            vst2q_f32(v89, v91);
            v89 -= 8;
            v90 -= 4;
          }
          while (v90);
          v7 = v86;
          v20 = v87;
          if (v84 != (v84 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_21:
            v34 = v7 - 8;
            do
            {
              v35 = *(_QWORD *)(v20 - 8);
              v20 -= 8;
              *(_QWORD *)v34 = v35;
              v34 -= 8;
            }
            while ((char *)v20 != v17);
          }
        }
        *(_DWORD *)v17 = a2;
        *(_DWORD *)&v6[8 * v16 + 4] = 0;
        goto LABEL_67;
      }
      goto LABEL_28;
    }
  }
  v18 = a1[103];
  if ((unint64_t)v7 < v18)
  {
    if (v6)
    {
      *(_DWORD *)v7 = a2;
      *(_DWORD *)&v6[8 * v16 + 4] = 0;
      a1[102] = v7 + 8;
      v17 = v7;
      goto LABEL_67;
    }
    goto LABEL_84;
  }
LABEL_28:
  v36 = (v8 >> 3) + 1;
  if (v36 >> 61)
    goto LABEL_85;
  v37 = v18 - (_QWORD)v6;
  v38 = (uint64_t)(v18 - (_QWORD)v6) >> 2;
  if (v38 > v36)
    v36 = v38;
  if (v37 >= 0x7FFFFFFFFFFFFFF8)
    v39 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v39 = v36;
  if (v39)
  {
    if (v39 >> 61)
      goto LABEL_86;
    v40 = (char *)operator new(8 * v39);
    v41 = &v40[8 * v16];
    v42 = &v40[8 * v39];
    if (v16 != v39)
      goto LABEL_49;
  }
  else
  {
    v40 = 0;
    v41 = (char *)(8 * v16);
    v42 = 0;
    if (v16)
      goto LABEL_49;
  }
  if ((uint64_t)(v15 & 0xFFFFFFFFFFFFFFF8) >= 1)
  {
    v43 = v16 + 2;
    if (v16 >= -1)
      v43 = v16 + 1;
    v41 -= 8 * (v43 >> 1);
    goto LABEL_49;
  }
  if ((unint64_t)v15 < 8)
    v44 = 1;
  else
    v44 = (v15 >> 2) & 0xFFFFFFFFFFFFFFFELL;
  if (v44 >> 61)
LABEL_86:
    std::__throw_bad_array_new_length[abi:sn180100]();
  v45 = 8 * v44;
  v46 = (char *)operator new(8 * v44);
  v41 = &v46[8 * (v44 >> 2)];
  v42 = &v46[v45];
  if (v40)
  {
    v47 = v40;
    v48 = v42;
    operator delete(v47);
    v42 = v48;
  }
LABEL_49:
  if (!v41)
  {
LABEL_84:
    __break(1u);
LABEL_85:
    abort();
  }
  *(_DWORD *)v41 = a2;
  *((_DWORD *)v41 + 1) = 0;
  v49 = v41 + 8;
  v50 = (char *)a1[101];
  v51 = v41;
  if (v50 != v17)
  {
    v52 = &v6[v15 & 0xFFFFFFFFFFFFFFF8];
    v53 = v52 - v50 - 8;
    v54 = v17;
    v51 = v41;
    if (v53 < 0x58)
      goto LABEL_90;
    v54 = v17;
    v51 = v41;
    if ((unint64_t)(v52 - v41) < 0x20)
      goto LABEL_90;
    v55 = (v53 >> 3) + 1;
    v56 = 8 * (v55 & 0x3FFFFFFFFFFFFFFCLL);
    v54 = &v17[-v56];
    v51 = &v41[-v56];
    v57 = v41 - 16;
    v58 = &v6[8 * v16 - 16];
    v59 = v55 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v60 = *(_OWORD *)v58;
      *((_OWORD *)v57 - 1) = *((_OWORD *)v58 - 1);
      *(_OWORD *)v57 = v60;
      v57 -= 32;
      v58 -= 32;
      v59 -= 4;
    }
    while (v59);
    if (v55 != (v55 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_90:
      do
      {
        v61 = *((_QWORD *)v54 - 1);
        v54 -= 8;
        *((_QWORD *)v51 - 1) = v61;
        v51 -= 8;
      }
      while (v54 != v50);
    }
  }
  v62 = (char *)a1[102];
  if (v62 != v17)
  {
    v63 = &v6[v15 & 0xFFFFFFFFFFFFFFF8];
    v64 = v62 - v63 - 8;
    if (v64 < 0x48)
      goto LABEL_91;
    if ((unint64_t)(v41 - v63 + 8) < 0x20)
      goto LABEL_91;
    v65 = (v64 >> 3) + 1;
    v66 = 8 * (v65 & 0x3FFFFFFFFFFFFFFCLL);
    v17 += v66;
    v49 = (_QWORD *)((char *)v49 + v66);
    v67 = v41 + 24;
    v68 = &v6[8 * v16 + 16];
    v69 = v65 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v70 = *(_OWORD *)v68;
      *(v67 - 1) = *((_OWORD *)v68 - 1);
      *v67 = v70;
      v67 += 2;
      v68 += 32;
      v69 -= 4;
    }
    while (v69);
    if (v65 != (v65 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_91:
      do
      {
        v71 = *(_QWORD *)v17;
        v17 += 8;
        *v49++ = v71;
      }
      while (v17 != v62);
    }
  }
  v72 = (void *)a1[101];
  a1[101] = v51;
  a1[102] = v49;
  a1[103] = v42;
  if (v72)
    operator delete(v72);
  v17 = v41;
LABEL_67:
  *((_DWORD *)v17 + 1) = a3;
  return 0;
}

uint64_t cricket::TCPPort::GetError(cricket::TCPPort *this)
{
  return *((unsigned int *)this + 208);
}

BOOL cricket::TCPPort::SupportsProtocol(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  if (a3 == 6)
    return *(_DWORD *)a2 == *(_DWORD *)"ssltcp" && a2[2] == *(unsigned __int16 *)"cp";
  if (a3 == 3)
    return *a2 == (unsigned __int16)cricket::TCP_PROTOCOL_NAME && *((_BYTE *)a2 + 2) == 112;
  return 0;
}

uint64_t cricket::TCPPort::GetProtocol(cricket::TCPPort *this)
{
  return 1;
}

void cricket::TCPPort::OnNewConnection(cricket::TCPPort *this, rtc::AsyncListenSocket *a2, rtc::AsyncPacketSocket *a3)
{
  unsigned int *v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  rtc::AsyncPacketSocket *v14;
  char *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  rtc::AsyncPacketSocket *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  _QWORD *v30;
  uint64_t v31;
  std::string *v32;
  rtc::AsyncPacketSocket *v33;
  const rtc::SentPacket *v34;
  uint64_t v35;
  void *v36;
  char v37;
  __int128 v38;
  uint64_t (*v39)(_QWORD, _QWORD, _QWORD);
  uint64_t v40;
  void *__p[2];
  uint64_t v42;
  int v43;
  __int128 v44;
  __int16 v45;
  int v46;
  char v47;
  __int128 __dst;
  uint64_t v49;
  void *v50;
  _BYTE v51[20];
  __int16 v52;
  int v53;
  char v54;
  rtc::AsyncPacketSocket *v55;

  v5 = (unsigned int *)*((_QWORD *)this + 101);
  v6 = (unsigned int *)*((_QWORD *)this + 102);
  while (v5 != v6)
  {
    v7 = *v5;
    v8 = v5[1];
    v5 += 2;
    (*(void (**)(rtc::AsyncPacketSocket *, uint64_t, uint64_t))(*(_QWORD *)a3 + 72))(a3, v7, v8);
  }
  __dst = 0uLL;
  v49 = 0;
  v50 = &unk_24C0ACDA0;
  v54 = 0;
  v52 = 0;
  v53 = 0;
  memset(v51, 0, sizeof(v51));
  (*(void (**)(void **__return_ptr, rtc::AsyncPacketSocket *, rtc::AsyncListenSocket *))(*(_QWORD *)a3 + 24))(__p, a3, a2);
  if (SHIBYTE(v42) < 0)
  {
    std::string::__assign_no_alias<true>(&__dst, (char *)__p[0], (size_t)__p[1]);
    v13 = v42 < 0;
  }
  else
  {
    v13 = 0;
    __dst = *(_OWORD *)__p;
    v49 = v42;
  }
  *(_DWORD *)v51 = v43;
  *(_OWORD *)&v51[4] = v44;
  v52 = v45;
  v54 = v47;
  v53 = v46;
  if (v13)
    operator delete(__p[0]);
  v55 = a3;
  *(_QWORD *)&v38 = this;
  if (*((_QWORD *)a3 + 42))
  {
    v32 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/async_packet_socket.cc", 47, "!received_packet_callback_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v9, v10, v11, v12, v35);
    cricket::TCPPort::OnSentPacket((cricket::TCPPort *)v32, v33, v34);
    return;
  }
  (*((void (**)(uint64_t, char *, char *))a3 + 41))(1, (char *)a3 + 312, (char *)a3 + 312);
  *(_OWORD *)((char *)a3 + 312) = v38;
  *((_QWORD *)a3 + 41) = absl::internal_any_invocable::LocalManagerTrivial;
  *((_QWORD *)a3 + 42) = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TCPPort::OnNewConnection(rtc::AsyncListenSocket *,rtc::AsyncPacketSocket *)::$_0 &,rtc::AsyncPacketSocket *,rtc::ReceivedPacket const&>;
  v39 = absl::internal_any_invocable::EmptyManager;
  v40 = 0;
  absl::internal_any_invocable::EmptyManager(1, &v38, &v38);
  v14 = v55;
  if (this)
    v15 = (char *)this + 232;
  else
    v15 = 0;
  v16 = operator new(0x30uLL);
  v16[2] = sigslot::_opaque_connection::emitter<cricket::TCPPort,rtc::AsyncPacketSocket *>;
  v16[3] = v15;
  v16[4] = cricket::TCPPort::OnReadyToSend;
  v16[5] = 0;
  v18 = *((_QWORD *)v14 + 16);
  v17 = (_QWORD *)((char *)v14 + 128);
  *v16 = v18;
  v16[1] = v17;
  *(_QWORD *)(v18 + 8) = v16;
  *v17 = v16;
  ++v17[2];
  (*((void (**)(char *, _QWORD *))this + 30))((char *)this + 232, v17 - 2);
  v19 = v55;
  v20 = operator new(0x30uLL);
  v20[2] = sigslot::_opaque_connection::emitter<cricket::TCPPort,rtc::AsyncPacketSocket *,rtc::SentPacket const&>;
  v20[3] = v15;
  *((_OWORD *)v20 + 2) = xmmword_208F17020;
  v21 = *((_QWORD *)v19 + 9);
  v19 = (rtc::AsyncPacketSocket *)((char *)v19 + 72);
  *v20 = v21;
  v20[1] = v19;
  *(_QWORD *)(v21 + 8) = v20;
  *(_QWORD *)v19 = v20;
  ++*((_QWORD *)v19 + 2);
  (*((void (**)(char *, _QWORD *))this + 30))((char *)this + 232, (_QWORD *)v19 - 2);
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
  {
    (*(void (**)(void **__return_ptr, cricket::TCPPort *))(*(_QWORD *)this + 176))(__p, this);
    rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)&__dst, (char *)&v36);
    rtc::webrtc_logging_impl::Log("\r\n\t\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
    if (v37 < 0)
    {
      operator delete(v36);
      if ((SHIBYTE(v42) & 0x80000000) == 0)
        goto LABEL_15;
    }
    else if ((SHIBYTE(v42) & 0x80000000) == 0)
    {
      goto LABEL_15;
    }
    operator delete(__p[0]);
  }
LABEL_15:
  v29 = (char *)operator new(0x60uLL);
  *((_OWORD *)v29 + 1) = 0u;
  v30 = v29 + 16;
  *(_OWORD *)v29 = 0u;
  *((_QWORD *)v29 + 4) = 0;
  *((_QWORD *)v29 + 5) = &unk_24C0ACDA0;
  *((_QWORD *)v29 + 6) = 0;
  *((_QWORD *)v29 + 7) = 0;
  *((_DWORD *)v29 + 16) = 0;
  if (SHIBYTE(v49) < 0)
  {
    std::string::__assign_no_alias<true>(v30, (char *)__dst, *((size_t *)&__dst + 1));
  }
  else
  {
    *(_OWORD *)v30 = __dst;
    *((_QWORD *)v29 + 4) = v49;
  }
  *((_DWORD *)v29 + 12) = *(_DWORD *)v51;
  *(_OWORD *)(v29 + 52) = *(_OWORD *)&v51[4];
  *((_WORD *)v29 + 36) = v52;
  v29[80] = v54;
  *((_DWORD *)v29 + 19) = v53;
  *((_QWORD *)v29 + 11) = v55;
  v31 = *((_QWORD *)this + 105);
  *(_QWORD *)v29 = v31;
  *((_QWORD *)v29 + 1) = (char *)this + 840;
  *(_QWORD *)(v31 + 8) = v29;
  *((_QWORD *)this + 105) = v29;
  ++*((_QWORD *)this + 107);
  if (SHIBYTE(v49) < 0)
    operator delete((void *)__dst);
}

uint64_t cricket::TCPPort::OnSentPacket(cricket::TCPPort *this, rtc::AsyncPacketSocket *a2, const rtc::SentPacket *a3)
{
  char *v4;
  uint64_t result;
  uint64_t v7;
  void (*v8)(uint64_t, const rtc::SentPacket *);

  v4 = (char *)this + 192;
  result = *((_QWORD *)this + 25);
  for (*((_QWORD *)this + 27) = result; (char *)result != v4; result = *((_QWORD *)this + 27))
  {
    v8 = *(void (**)(uint64_t, const rtc::SentPacket *))(result + 16);
    v7 = result + 16;
    *((_QWORD *)this + 27) = *(_QWORD *)(v7 - 8);
    v8(v7, a3);
  }
  return result;
}

uint64_t cricket::TCPConnection::TCPConnection(uint64_t a1, __int128 *a2, std::string *a3, rtc::AsyncPacketSocket *a4)
{
  __int128 v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  rtc::Network *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  std::string __p;
  void *v31[2];
  char v32;
  void *v33;
  char v34;
  std::string v35;
  char v36;
  const char *v37;
  uint64_t v38;
  char *v39;
  __int128 v40;

  v6 = *a2;
  *(_QWORD *)a2 = 0;
  v40 = v6;
  cricket::Connection::Connection(a1, (uint64_t *)&v40, 0, a3);
  if ((_QWORD)v40)
  {
    v7 = (unsigned int *)(v40 + 4);
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      MEMORY[0x20BD0ADEC]();
  }
  *(_QWORD *)(a1 + 2832) = sigslot::has_slots<sigslot::single_threaded>::do_signal_connect;
  *(_QWORD *)(a1 + 2840) = sigslot::has_slots<sigslot::single_threaded>::do_signal_disconnect;
  *(_QWORD *)(a1 + 2848) = sigslot::has_slots<sigslot::single_threaded>::do_disconnect_all;
  *(_OWORD *)(a1 + 2864) = 0u;
  *(_QWORD *)(a1 + 2856) = a1 + 2864;
  *(_QWORD *)a1 = &off_24C0C23C0;
  *(_QWORD *)(a1 + 2824) = &unk_24C0C2420;
  *(_QWORD *)(a1 + 2880) = a4;
  *(_DWORD *)(a1 + 2888) = 0;
  *(_BYTE *)(a1 + 2892) = a4 == 0;
  *(_WORD *)(a1 + 2893) = 0;
  *(_DWORD *)(a1 + 2896) = 5000;
  v10 = operator new();
  *(_DWORD *)v10 = 0;
  *(_BYTE *)(v10 + 4) = 1;
  *(_QWORD *)(a1 + 2904) = v10;
  do
    v11 = __ldxr((unsigned int *)v10);
  while (__stxr(v11 + 1, (unsigned int *)v10));
  v12 = operator new(0x30uLL);
  v13 = *(_QWORD *)(a1 + 80);
  v12[2] = sigslot::_opaque_connection::emitter<cricket::TCPConnection,cricket::Connection *>;
  v12[3] = a1 + 2824;
  v12[4] = cricket::TCPConnection::OnDestroyed;
  v12[5] = 0;
  *v12 = v13;
  v12[1] = a1 + 80;
  *(_QWORD *)(v13 + 8) = v12;
  *(_QWORD *)(a1 + 80) = v12;
  ++*(_QWORD *)(a1 + 96);
  (*(void (**)(uint64_t, uint64_t))(a1 + 2832))(a1 + 2824, a1 + 64);
  if (!*(_BYTE *)(a1 + 2892))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) != 0)
    {
LABEL_15:
      cricket::TCPConnection::ConnectSocketSignals((cricket::TCPConnection *)a1, a4, v14, v15, v16, v17, v18, v19);
      return a1;
    }
    v37 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc";
    v38 = 2976;
    v39 = &v36;
    v20 = cricket::Connection::ToString((cricket::Connection *)a1, &v35);
    (*(void (**)(void **__return_ptr, double))(**(_QWORD **)(a1 + 2880) + 16))(v31, v20);
    rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)v31, (char *)&v33);
    v21 = (rtc::Network *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 256) + 24))(*(_QWORD *)(a1 + 256));
    rtc::Network::ToString(v21, &__p);
    rtc::webrtc_logging_impl::Log("\r\n\t\n\t\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)v37);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v34 & 0x80000000) == 0)
      {
LABEL_13:
        if ((v32 & 0x80000000) == 0)
          goto LABEL_14;
        goto LABEL_19;
      }
    }
    else if ((v34 & 0x80000000) == 0)
    {
      goto LABEL_13;
    }
    operator delete(v33);
    if ((v32 & 0x80000000) == 0)
    {
LABEL_14:
      if ((SHIBYTE(v35.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_15;
LABEL_20:
      operator delete(v35.__r_.__value_.__l.__data_);
      goto LABEL_15;
    }
LABEL_19:
    operator delete(v31[0]);
    if ((SHIBYTE(v35.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_15;
    goto LABEL_20;
  }
  cricket::TCPConnection::CreateOutgoingTcpSocket((cricket::TCPConnection *)a1);
  return a1;
}

void cricket::TCPConnection::OnDestroyed(cricket::TCPConnection *this, cricket::Connection *a2)
{
  rtc::AsyncPacketSocket *v2;

  v2 = (rtc::AsyncPacketSocket *)*((_QWORD *)this + 360);
  if (v2)
    cricket::TCPConnection::DisconnectSocketSignals((void (**)(char *, char *))this, v2);
}

void cricket::TCPConnection::CreateOutgoingTcpSocket(cricket::TCPConnection *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  int v6;
  int v7;
  _BOOL4 v9;
  rtc::AsyncPacketSocket *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  void (*v41)(_QWORD *, cricket::TCPConnection *);
  void **v42;
  double v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  unsigned int *v63;
  unsigned int v64;
  _QWORD *v65;
  void **v66;
  void **v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  void *v71;
  char v72;
  void *v73[2];
  char v74;
  void *v75;
  int v76;
  __int128 v77;
  std::string __p;
  uint64_t (*v79)(uint64_t);
  int v80;
  __int128 v81;
  __int16 v82;
  int v83;
  char v84;
  _BOOL4 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  uint64_t v89;

  v2 = (*(uint64_t (**)(cricket::TCPConnection *))(*(_QWORD *)this + 24))(this);
  v3 = v2 + 32;
  if (*(char *)(v2 + 55) < 0)
  {
    v4 = *(_QWORD *)(v2 + 40);
    if (v4 < 0 || ((v3 = *(_QWORD *)v3, v4) ? (v5 = v3 == 0) : (v5 = 0), v5))
    {
      __break(1u);
      return;
    }
  }
  else
  {
    v4 = *(unsigned __int8 *)(v2 + 55);
  }
  if (v4 != 6)
  {
    v9 = 0;
    v10 = (rtc::AsyncPacketSocket *)*((_QWORD *)this + 360);
    if (!v10)
      goto LABEL_19;
    goto LABEL_18;
  }
  v6 = *(_DWORD *)v3;
  v7 = *(unsigned __int16 *)(v3 + 4);
  v9 = v6 == *(_DWORD *)"ssltcp" && v7 == *(unsigned __int16 *)"cp";
  v10 = (rtc::AsyncPacketSocket *)*((_QWORD *)this + 360);
  if (v10)
LABEL_18:
    cricket::TCPConnection::DisconnectSocketSignals((void (**)(char *, char *))this, v10);
LABEL_19:
  v89 = 0;
  v88 = 0u;
  v87 = 0u;
  v86 = 0u;
  v85 = v9;
  v11 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 32) + 216))(*((_QWORD *)this + 32));
  v12 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 32) + 24))(*((_QWORD *)this + 32));
  rtc::Network::GetBestIP(v12, (uint64_t)&v75);
  memset(&__p, 0, sizeof(__p));
  v79 = (uint64_t (*)(uint64_t))&unk_24C0ACDA0;
  v84 = 0;
  v80 = v76;
  v81 = v77;
  v83 = 0;
  v82 = 0;
  v13 = (*(uint64_t (**)(cricket::TCPConnection *))(*(_QWORD *)this + 24))(this);
  v14 = (*(uint64_t (**)(uint64_t, std::string *, uint64_t, _BOOL4 *))(*(_QWORD *)v11 + 32))(v11, &__p, v13 + 80, &v85);
  v15 = *((_QWORD *)this + 360);
  *((_QWORD *)this + 360) = v14;
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (*((_QWORD *)this + 360))
      goto LABEL_23;
LABEL_37:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      goto LABEL_40;
    v43 = cricket::Connection::ToString(this, &__p);
    v44 = (*(uint64_t (**)(cricket::TCPConnection *, double))(*(_QWORD *)this + 24))(this, v43);
    rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)(v44 + 80), (char *)&v75);
    rtc::webrtc_logging_impl::Log("\r\n\t\n", v45, v46, v47, v48, v49, v50, v51, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
    if (SBYTE11(v77) < 0)
    {
      operator delete(v75);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_40:
        v52 = *((_DWORD *)this + 640);
        *((_DWORD *)this + 640) = 3;
        if (v52 == 3)
          goto LABEL_51;
LABEL_41:
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
        {
          cricket::Connection::ToString(this, &__p);
          rtc::webrtc_logging_impl::Log("\r\n\t", v53, v54, v55, v56, v57, v58, v59, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/connection.cc");
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
        }
LABEL_51:
        v62 = *((_QWORD *)this + 29);
        v63 = (unsigned int *)*((_QWORD *)this + 363);
        if (v63)
        {
          do
            v64 = __ldxr(v63);
          while (__stxr(v64 + 1, v63));
        }
        v65 = (_QWORD *)operator new();
        *v65 = v63;
        v65[1] = this;
        v65[3] = absl::internal_any_invocable::LocalManagerTrivial;
        v65[4] = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TCPConnection::CreateOutgoingTcpSocket(void)::$_0 &&>;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v65;
        __p.__r_.__value_.__r.__words[2] = (std::string::size_type)_ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
        v79 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
        (*(void (**)(uint64_t, std::string *, void **, void **))(*(_QWORD *)v62 + 8))(v62, &__p, &v75, v73);
        ((void (*)(uint64_t, std::string *, std::string *))__p.__r_.__value_.__r.__words[2])(1, &__p, &__p);
        v42 = (void **)*((_QWORD *)&v87 + 1);
        if (!*((_QWORD *)&v87 + 1))
          goto LABEL_61;
        goto LABEL_54;
      }
    }
    else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_40;
    }
    operator delete(__p.__r_.__value_.__l.__data_);
    v61 = *((_DWORD *)this + 640);
    *((_DWORD *)this + 640) = 3;
    if (v61 == 3)
      goto LABEL_51;
    goto LABEL_41;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!*((_QWORD *)this + 360))
    goto LABEL_37;
LABEL_23:
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) != 0)
    goto LABEL_28;
  v22 = cricket::Connection::ToString(this, (std::string *)&v75);
  (*(void (**)(std::string *__return_ptr, double))(**((_QWORD **)this + 360) + 16))(&__p, v22);
  rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)&__p, (char *)v73);
  v23 = (*(uint64_t (**)(cricket::TCPConnection *))(*(_QWORD *)this + 24))(this);
  rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)(v23 + 80), (char *)&v71);
  rtc::webrtc_logging_impl::Log("\r\n\t\n\t\n", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
  if (v72 < 0)
  {
    operator delete(v71);
    if ((v74 & 0x80000000) == 0)
    {
LABEL_26:
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_27;
      goto LABEL_46;
    }
  }
  else if ((v74 & 0x80000000) == 0)
  {
    goto LABEL_26;
  }
  operator delete(v73[0]);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_27:
    if ((SBYTE11(v77) & 0x80000000) == 0)
      goto LABEL_28;
LABEL_47:
    operator delete(v75);
    v60 = *((unsigned __int8 *)this + 2333);
    *((_BYTE *)this + 2333) = 0;
    if (!v60)
      goto LABEL_34;
    goto LABEL_29;
  }
LABEL_46:
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SBYTE11(v77) < 0)
    goto LABEL_47;
LABEL_28:
  v31 = *((unsigned __int8 *)this + 2333);
  *((_BYTE *)this + 2333) = 0;
  if (!v31)
    goto LABEL_34;
LABEL_29:
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
  {
    cricket::Connection::ToString(this, &__p);
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v32, v33, v34, v35, v36, v37, v38, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/connection.cc");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  v39 = (_QWORD *)*((_QWORD *)this + 4);
  for (*((_QWORD *)this + 6) = v39; v39 != (_QWORD *)((char *)this + 24); v39 = (_QWORD *)*((_QWORD *)this + 6))
  {
    v41 = (void (*)(_QWORD *, cricket::TCPConnection *))v39[2];
    v40 = v39 + 2;
    *((_QWORD *)this + 6) = *(v40 - 1);
    v41(v40, this);
  }
LABEL_34:
  *((_BYTE *)this + 2893) = 1;
  cricket::TCPConnection::ConnectSocketSignals(this, *((rtc::AsyncPacketSocket **)this + 360), v16, v17, v18, v19, v20, v21);
  v42 = (void **)*((_QWORD *)&v87 + 1);
  if (*((_QWORD *)&v87 + 1))
  {
LABEL_54:
    v66 = (void **)v88;
    v67 = v42;
    if ((void **)v88 != v42)
    {
      do
      {
        if (*((char *)v66 - 1) < 0)
          operator delete(*(v66 - 3));
        v66 -= 3;
      }
      while (v66 != v42);
      v67 = (void **)*((_QWORD *)&v87 + 1);
    }
    *(_QWORD *)&v88 = v42;
    operator delete(v67);
  }
LABEL_61:
  v68 = v86;
  if ((_QWORD)v86)
  {
    v69 = *((_QWORD *)&v86 + 1);
    v70 = (void *)v86;
    if (*((_QWORD *)&v86 + 1) != (_QWORD)v86)
    {
      do
      {
        if (*(char *)(v69 - 1) < 0)
          operator delete(*(void **)(v69 - 24));
        v69 -= 24;
      }
      while (v69 != v68);
      v70 = (void *)v86;
    }
    *((_QWORD *)&v86 + 1) = v68;
    operator delete(v70);
  }
}

void cricket::TCPConnection::ConnectSocketSignals(cricket::TCPConnection *this, rtc::AsyncPacketSocket *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  std::string *v23;
  uint64_t v24;
  __int128 v25;
  uint64_t (*v26)(_QWORD, _QWORD, _QWORD);
  uint64_t v27;
  uint64_t v28[3];

  if (*((_BYTE *)this + 2892))
  {
    v10 = operator new(0x30uLL);
    v11 = *((_QWORD *)a2 + 30);
    v10[2] = sigslot::_opaque_connection::emitter<cricket::TCPConnection,rtc::AsyncPacketSocket *>;
    v10[3] = (char *)this + 2824;
    v10[4] = cricket::TCPConnection::OnConnect;
    v10[5] = 0;
    *v10 = v11;
    v10[1] = (char *)a2 + 240;
    *(_QWORD *)(v11 + 8) = v10;
    *((_QWORD *)a2 + 30) = v10;
    ++*((_QWORD *)a2 + 32);
    (*((void (**)(char *, char *))this + 354))((char *)this + 2824, (char *)a2 + 224);
  }
  *(_QWORD *)&v25 = this;
  if (*((_QWORD *)a2 + 42))
  {
    v23 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/async_packet_socket.cc", 47, "!received_packet_callback_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v24);
    cricket::TCPConnection::~TCPConnection((cricket::TCPConnection *)v23);
  }
  else
  {
    (*((void (**)(uint64_t, char *, char *))a2 + 41))(1, (char *)a2 + 312, (char *)a2 + 312);
    *(_OWORD *)((char *)a2 + 312) = v25;
    *((_QWORD *)a2 + 41) = absl::internal_any_invocable::LocalManagerTrivial;
    *((_QWORD *)a2 + 42) = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_0 &,rtc::AsyncPacketSocket *,rtc::ReceivedPacket const&>;
    v26 = absl::internal_any_invocable::EmptyManager;
    v27 = 0;
    absl::internal_any_invocable::EmptyManager(1, &v25, &v25);
    v12 = operator new(0x30uLL);
    v13 = *((_QWORD *)a2 + 16);
    v12[2] = sigslot::_opaque_connection::emitter<cricket::TCPConnection,rtc::AsyncPacketSocket *>;
    v12[3] = (char *)this + 2824;
    v12[4] = cricket::TCPConnection::OnReadyToSend;
    v12[5] = 0;
    *v12 = v13;
    v12[1] = (char *)a2 + 128;
    *(_QWORD *)(v13 + 8) = v12;
    *((_QWORD *)a2 + 16) = v12;
    ++*((_QWORD *)a2 + 18);
    (*((void (**)(char *, char *))this + 354))((char *)this + 2824, (char *)a2 + 112);
    v14 = (unsigned int *)*((_QWORD *)this + 363);
    if (v14)
    {
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v16 = operator new(0x18uLL);
    *v16 = &off_24C0C2440;
    v16[1] = this;
    v16[2] = v14;
    v17 = operator new();
    *(_QWORD *)(v17 + 24) = v16;
    v28[0] = v17;
    v28[1] = (uint64_t)webrtc::webrtc_function_impl::CallHelpers<void ()(rtc::AsyncPacketSocket *,int)>::CallVoidPtr<std::function<void ()(rtc::AsyncPacketSocket *,int)>>;
    v28[2] = (uint64_t)webrtc::UntypedFunction::PrepareArgs<void ()(rtc::AsyncPacketSocket *,int),std::function<void ()(rtc::AsyncPacketSocket *,int)>,std::function<void ()(rtc::AsyncPacketSocket *,int)>,(void *)0>(std::function<void ()(rtc::AsyncPacketSocket *,int)> &&)::{lambda(webrtc::webrtc_function_impl::VoidUnion *)#1}::__invoke;
    webrtc::callback_list_impl::CallbackListReceivers::AddReceiver<webrtc::UntypedFunction::NontrivialUntypedFunctionArgs>((char *)a2 + 280, (uint64_t)this, v28, v18, v19, v20, v21, v22);
  }
}

void cricket::TCPConnection::~TCPConnection(cricket::TCPConnection *this)
{
  char *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  *(_QWORD *)this = &off_24C0C23C0;
  v2 = (char *)this + 2824;
  *((_QWORD *)this + 353) = &unk_24C0C2420;
  v3 = *((_QWORD *)this + 363);
  *(_BYTE *)(v3 + 4) = 0;
  do
  {
    v4 = __ldaxr((unsigned int *)v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, (unsigned int *)v3));
  if (!v5)
    MEMORY[0x20BD0ADEC]();
  v6 = *((_QWORD *)this + 360);
  *((_QWORD *)this + 360) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  *((_QWORD *)this + 353) = &unk_24C0ACE30;
  (*((void (**)(char *))this + 356))(v2);
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 2856, *((_QWORD **)this + 358));
  cricket::Connection::~Connection(this);
}

{
  char *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  *(_QWORD *)this = &off_24C0C23C0;
  v2 = (char *)this + 2824;
  *((_QWORD *)this + 353) = &unk_24C0C2420;
  v3 = *((_QWORD *)this + 363);
  *(_BYTE *)(v3 + 4) = 0;
  do
  {
    v4 = __ldaxr((unsigned int *)v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, (unsigned int *)v3));
  if (!v5)
    MEMORY[0x20BD0ADEC]();
  v6 = *((_QWORD *)this + 360);
  *((_QWORD *)this + 360) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  *((_QWORD *)this + 353) = &unk_24C0ACE30;
  (*((void (**)(char *))this + 356))(v2);
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 2856, *((_QWORD **)this + 358));
  cricket::Connection::~Connection(this);
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'cricket::TCPConnection::~TCPConnection(cricket::TCPConnection *this)
{
  cricket::Connection *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  v2 = (cricket::TCPConnection *)((char *)this - 2824);
  *((_QWORD *)this - 353) = &off_24C0C23C0;
  *(_QWORD *)this = &unk_24C0C2420;
  v3 = *((_QWORD *)this + 10);
  *(_BYTE *)(v3 + 4) = 0;
  do
  {
    v4 = __ldaxr((unsigned int *)v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, (unsigned int *)v3));
  if (!v5)
    MEMORY[0x20BD0ADEC]();
  v6 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  *(_QWORD *)this = &unk_24C0ACE30;
  (*((void (**)(cricket::TCPConnection *))this + 3))(this);
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 32, *((_QWORD **)this + 5));
  cricket::Connection::~Connection(v2);
}

{
  cricket::Connection *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  v2 = (cricket::TCPConnection *)((char *)this - 2824);
  *((_QWORD *)this - 353) = &off_24C0C23C0;
  *(_QWORD *)this = &unk_24C0C2420;
  v3 = *((_QWORD *)this + 10);
  *(_BYTE *)(v3 + 4) = 0;
  do
  {
    v4 = __ldaxr((unsigned int *)v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, (unsigned int *)v3));
  if (!v5)
    MEMORY[0x20BD0ADEC]();
  v6 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  *(_QWORD *)this = &unk_24C0ACE30;
  (*((void (**)(cricket::TCPConnection *))this + 3))(this);
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 32, *((_QWORD **)this + 5));
  cricket::Connection::~Connection(v2);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t cricket::TCPConnection::Send(cricket::TCPConnection *this, const void *a2, uint64_t a3, const rtc::PacketOptions *a4)
{
  int v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v18;
  _BYTE *v19;
  size_t v20;
  char *v21;
  char *v22;
  __int128 v23;
  _BYTE *v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  std::string __p;
  void *v38;
  void *v39;
  char *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  __int16 v45;

  if (!*((_QWORD *)this + 360))
    goto LABEL_5;
  if (!*((_BYTE *)this + 2333))
  {
    if (*((_BYTE *)this + 2893) || !*((_BYTE *)this + 2892))
      return 0xFFFFFFFFLL;
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      cricket::Connection::ToString(this, &__p);
      rtc::webrtc_logging_impl::Log("\r\n\t", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    cricket::TCPConnection::CreateOutgoingTcpSocket(this);
    v5 = 32;
LABEL_6:
    *((_DWORD *)this + 722) = v5;
    return 0xFFFFFFFFLL;
  }
  if (*((_BYTE *)this + 2894) || *((_DWORD *)this + 582))
  {
LABEL_5:
    v5 = 57;
    goto LABEL_6;
  }
  ++*((_QWORD *)this + 147);
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)a4;
  LODWORD(__p.__r_.__value_.__r.__words[2]) = *((_DWORD *)a4 + 4);
  v39 = 0;
  v40 = 0;
  v38 = 0;
  v19 = (_BYTE *)*((_QWORD *)a4 + 3);
  v18 = (_BYTE *)*((_QWORD *)a4 + 4);
  v20 = v18 - v19;
  if (v18 != v19)
  {
    if ((v20 & 0x8000000000000000) != 0)
      abort();
    v21 = (char *)operator new(v18 - v19);
    v22 = &v21[v20];
    v38 = v21;
    v40 = &v21[v20];
    memcpy(v21, v19, v20);
    v39 = v22;
  }
  v23 = *((_OWORD *)a4 + 4);
  v41 = *((_OWORD *)a4 + 3);
  v42 = v23;
  v43 = *((_OWORD *)a4 + 5);
  v44 = *((_QWORD *)a4 + 12);
  v45 = *((_WORD *)a4 + 52);
  v24 = (_BYTE *)*((_QWORD *)this + 31);
  if (v24 && *v24)
    v25 = *((_QWORD *)this + 32);
  else
    v25 = 0;
  v26 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v25 + 128))(v25);
  if (v26 < 4)
    v27 = v26 + 1;
  else
    v27 = 0;
  DWORD2(v42) = v27;
  WORD6(v42) = *(_WORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v25 + 24))(v25) + 286);
  BYTE14(v42) = 1;
  v6 = (*(uint64_t (**)(_QWORD, const void *, uint64_t, std::string *))(**((_QWORD **)this + 360) + 32))(*((_QWORD *)this + 360), a2, a3, &__p);
  if (rtc::g_clock)
  {
    v28 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v28 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
        / dword_253EA791C;
  }
  v29 = v28 / 1000000;
  if ((v6 & 0x80000000) != 0)
  {
    ++*((_QWORD *)this + 146);
    *((_DWORD *)this + 722) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 360) + 80))(*((_QWORD *)this + 360));
  }
  else
  {
    if (*((_QWORD *)this + 288) == -1)
    {
      v30 = (*(uint64_t (**)(char *))(*((_QWORD *)this + 282) + 16))((char *)this + 2256);
      *((_QWORD *)this + 289) = v30;
      *((_QWORD *)this + 288) = v30;
      *((_QWORD *)this + 287) = 0;
      **((_QWORD **)this + 285) = 0;
    }
    v31 = 0;
    v32 = *((_QWORD *)this + 284);
    while (1)
    {
      v33 = *((_QWORD *)this + 288);
      v34 = *((_QWORD *)this + 283);
      if (v34 + v33 > v29)
        break;
      *((_QWORD *)this + 288) = v34 + v33;
      v35 = (*((_QWORD *)this + 287) + 1) % (v32 + 1);
      *((_QWORD *)this + 287) = v35;
      v36 = *((_QWORD *)this + 285);
      *(_QWORD *)(v36 + 8 * v35) = 0;
      if (++v31 > v32)
      {
        v34 = *((_QWORD *)this + 283);
        v33 = *((_QWORD *)this + 288);
        goto LABEL_39;
      }
    }
    v36 = *((_QWORD *)this + 285);
    v35 = *((_QWORD *)this + 287);
LABEL_39:
    *((_QWORD *)this + 288) = v33 + (v29 - v33) / v34 * v34;
    *(_QWORD *)(v36 + 8 * v35) += v6;
    *((_QWORD *)this + 286) += v6;
  }
  *((_QWORD *)this + 290) = v29;
  if (v38)
  {
    v39 = v38;
    operator delete(v38);
  }
  return v6;
}

uint64_t cricket::TCPConnection::GetError(cricket::TCPConnection *this)
{
  return *((unsigned int *)this + 722);
}

void cricket::TCPConnection::OnConnectionRequestResponse(cricket::TCPConnection *this, cricket::StunRequest *a2, cricket::StunMessage *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  void (*v6)(_QWORD *, cricket::TCPConnection *);

  cricket::Connection::OnConnectionRequestResponse(this, a2, a3);
  if (*((_BYTE *)this + 2894))
  {
    v4 = (_QWORD *)*((_QWORD *)this + 18);
    for (*((_QWORD *)this + 20) = v4; v4 != (_QWORD *)((char *)this + 136); v4 = (_QWORD *)*((_QWORD *)this + 20))
    {
      v6 = (void (*)(_QWORD *, cricket::TCPConnection *))v4[2];
      v5 = v4 + 2;
      *((_QWORD *)this + 20) = *(v5 - 1);
      v6(v5, this);
    }
  }
  *((_BYTE *)this + 2894) = 0;
}

void cricket::TCPConnection::OnConnect(cricket::TCPConnection *this, rtc::AsyncPacketSocket *a2)
{
  _BYTE *v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  __int16 v14;
  char v15;
  int v16;
  char *v17;
  uint64_t v18;
  char *v19;
  int v20;
  _BOOL4 v21;
  BOOL v22;
  _QWORD *v23;
  char *v24;
  uint64_t v26;
  char *v27;
  double v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _BOOL4 IsLoopbackIP;
  _BOOL4 v37;
  rtc::Network *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _BOOL4 v49;
  char v50;
  rtc::Network *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD *v67;
  _QWORD *v68;
  void (*v69)(_QWORD *, cricket::TCPConnection *);
  rtc::Network *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void *v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  _BYTE __p[56];
  __int16 v83;
  int v84;
  char v85;
  void *v86[2];
  uint64_t v87;
  uint64_t v88;
  int v89;
  __int128 v90;
  __int16 v91;
  int v92;
  char v93;
  _QWORD __dst[7];
  __int16 v95;
  int v96;
  char v97;

  v2 = (_BYTE *)*((_QWORD *)this + 31);
  if (!v2 || !*v2 || !*((_QWORD *)this + 32))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
    return;
  }
  (*(void (**)(void **__return_ptr, rtc::AsyncPacketSocket *))(*(_QWORD *)a2 + 16))(v86, a2);
  v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 32) + 24))(*((_QWORD *)this + 32));
  memset(__p, 0, 24);
  *(_QWORD *)&__p[24] = &unk_24C0ACDA0;
  memset(&__p[32], 0, 20);
  if (SHIBYTE(v87) < 0)
  {
    std::string::__assign_no_alias<true>(__p, (char *)v86[0], (size_t)v86[1]);
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)v86;
    *(_QWORD *)&__p[16] = v87;
  }
  v13 = v89;
  *(_DWORD *)&__p[32] = v89;
  *(_OWORD *)&__p[36] = v90;
  v14 = v91;
  v83 = v91;
  v15 = v93;
  v85 = v93;
  v16 = v92;
  v84 = v92;
  v18 = *(_QWORD *)(v5 + 240);
  v17 = *(char **)(v5 + 248);
  memset(__dst, 0, 24);
  __dst[3] = &unk_24C0ACDA0;
  memset(&__dst[4], 0, 20);
  if ((__p[23] & 0x80000000) != 0)
  {
    std::string::__assign_no_alias<true>(__dst, *(char **)__p, *(size_t *)&__p[8]);
    v13 = *(_DWORD *)&__p[32];
    v14 = v83;
    v15 = v85;
    v16 = v84;
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)__p;
    __dst[2] = *(_QWORD *)&__p[16];
  }
  LODWORD(__dst[4]) = v13;
  *(_OWORD *)((char *)&__dst[4] + 4) = *(_OWORD *)&__p[36];
  v95 = v14;
  v97 = v15;
  v96 = v16;
  if ((char *)v18 == v17)
    goto LABEL_36;
  if (v13 == 30)
  {
    v23 = (_QWORD *)(v18 + 12);
    while (*((_DWORD *)v23 - 1) != 30
         || *(_QWORD *)((char *)&__dst[4] + 4) != *v23
         || *(_QWORD *)((char *)&__dst[5] + 4) != v23[1])
    {
      v24 = (char *)v23 + 20;
      v23 += 4;
      if (v24 == v17)
        goto LABEL_36;
    }
    goto LABEL_35;
  }
  if (v13 == 2)
  {
    v26 = v18 + 12;
    while (__PAIR64__(HIDWORD(__dst[4]), 2) != *(_QWORD *)(v26 - 4))
    {
      v27 = (char *)(v26 + 20);
      v26 += 32;
      if (v27 == v17)
        goto LABEL_36;
    }
LABEL_35:
    v21 = 1;
    goto LABEL_37;
  }
  if (v13)
  {
LABEL_36:
    v21 = 0;
    goto LABEL_37;
  }
  v19 = (char *)(v18 + 32);
  do
  {
    v20 = *((_DWORD *)v19 - 6);
    v21 = v20 == 0;
    if (v20)
      v22 = v19 == v17;
    else
      v22 = 1;
    v19 += 32;
  }
  while (!v22);
LABEL_37:
  if (SHIBYTE(__dst[2]) < 0)
  {
    operator delete((void *)__dst[0]);
    if ((__p[23] & 0x80000000) == 0)
    {
LABEL_39:
      if (v21)
        goto LABEL_40;
      goto LABEL_47;
    }
  }
  else if ((__p[23] & 0x80000000) == 0)
  {
    goto LABEL_39;
  }
  operator delete(*(void **)__p);
  if (v21)
  {
LABEL_40:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) != 0)
      goto LABEL_82;
    v28 = cricket::Connection::ToString(this, (std::string *)__p);
    (*(void (**)(_QWORD *__return_ptr, rtc::AsyncPacketSocket *, double))(*(_QWORD *)a2 + 24))(__dst, a2, v28);
    rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)__dst, (char *)&v78);
    rtc::webrtc_logging_impl::Log("\r\n\t\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
    if (SBYTE3(v81) < 0)
    {
      operator delete(v78);
      if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
      {
LABEL_43:
        if ((__p[23] & 0x80000000) == 0)
          goto LABEL_82;
LABEL_69:
        operator delete(*(void **)__p);
        goto LABEL_82;
      }
    }
    else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
    {
      goto LABEL_43;
    }
    operator delete((void *)__dst[0]);
    if ((__p[23] & 0x80000000) == 0)
      goto LABEL_82;
    goto LABEL_69;
  }
LABEL_47:
  (*(void (**)(_QWORD *__return_ptr, rtc::AsyncPacketSocket *))(*(_QWORD *)a2 + 16))(__dst, a2);
  IsLoopbackIP = rtc::SocketAddress::IsLoopbackIP((rtc::SocketAddress *)__dst);
  v37 = IsLoopbackIP;
  if (SHIBYTE(__dst[2]) < 0)
  {
    operator delete((void *)__dst[0]);
    if (v37)
    {
LABEL_49:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        goto LABEL_82;
      rtc::IPAddress::ToSensitiveString((rtc::IPAddress *)&v88, (uint64_t)__dst);
      v38 = (rtc::Network *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 32) + 24))(*((_QWORD *)this + 32));
      rtc::Network::ToString(v38, (std::string *)__p);
      rtc::webrtc_logging_impl::Log("\r\t\n\t\n\t", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
      if ((__p[23] & 0x80000000) == 0)
        goto LABEL_52;
      goto LABEL_51;
    }
  }
  else if (IsLoopbackIP)
  {
    goto LABEL_49;
  }
  v46 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 32) + 24))(*((_QWORD *)this + 32));
  rtc::Network::GetBestIP(v46, (uint64_t)&v78);
  if (v79 == 2)
  {
    v49 = v80;
  }
  else
  {
    if (v79 != 30)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        goto LABEL_79;
LABEL_75:
      rtc::IPAddress::ToSensitiveString((rtc::IPAddress *)&v88, (uint64_t)__dst);
      v51 = (rtc::Network *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 32) + 24))(*((_QWORD *)this + 32));
      rtc::Network::ToString(v51, (std::string *)__p);
      rtc::webrtc_logging_impl::Log("\r\t\n\t\n", v52, v53, v54, v55, v56, v57, v58, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
      if ((__p[23] & 0x80000000) != 0)
        operator delete(*(void **)__p);
      if (SHIBYTE(__dst[2]) < 0)
        operator delete((void *)__dst[0]);
LABEL_79:
      cricket::TCPConnection::OnClose(this, 0);
      if ((SHIBYTE(v87) & 0x80000000) == 0)
        return;
      goto LABEL_89;
    }
    *(_OWORD *)((char *)&__dst[1] + 4) = *MEMORY[0x24BDAE878];
    if (v80 == *(_QWORD *)((char *)&__dst[1] + 4) && v81 == *(_QWORD *)((char *)&__dst[2] + 4))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        goto LABEL_82;
      goto LABEL_92;
    }
    *(_OWORD *)&__p[12] = rtc::kV4MappedPrefix;
    v49 = v80 != (_QWORD)rtc::kV4MappedPrefix || v81 != *((_QWORD *)&rtc::kV4MappedPrefix + 1);
  }
  v50 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>();
  if (v49)
  {
    if ((v50 & 1) != 0)
      goto LABEL_79;
    goto LABEL_75;
  }
  if ((v50 & 1) != 0)
    goto LABEL_82;
LABEL_92:
  rtc::IPAddress::ToSensitiveString((rtc::IPAddress *)&v88, (uint64_t)__dst);
  v70 = (rtc::Network *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 32) + 24))(*((_QWORD *)this + 32));
  rtc::Network::ToString(v70, (std::string *)__p);
  rtc::webrtc_logging_impl::Log("\r\t\n\t\n\t", v71, v72, v73, v74, v75, v76, v77, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
  if ((__p[23] & 0x80000000) != 0)
LABEL_51:
    operator delete(*(void **)__p);
LABEL_52:
  if (SHIBYTE(__dst[2]) < 0)
    operator delete((void *)__dst[0]);
LABEL_82:
  v59 = *((unsigned __int8 *)this + 2333);
  *((_BYTE *)this + 2333) = 1;
  if (!v59)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
    {
      cricket::Connection::ToString(this, (std::string *)__dst);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v60, v61, v62, v63, v64, v65, v66, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/connection.cc");
      if (SHIBYTE(__dst[2]) < 0)
        operator delete((void *)__dst[0]);
    }
    v67 = (_QWORD *)*((_QWORD *)this + 4);
    for (*((_QWORD *)this + 6) = v67; v67 != (_QWORD *)((char *)this + 24); v67 = (_QWORD *)*((_QWORD *)this + 6))
    {
      v69 = (void (*)(_QWORD *, cricket::TCPConnection *))v67[2];
      v68 = v67 + 2;
      *((_QWORD *)this + 6) = *(v68 - 1);
      v69(v68, this);
    }
  }
  *((_BYTE *)this + 2893) = 0;
  if (SHIBYTE(v87) < 0)
LABEL_89:
    operator delete(v86[0]);
}

void cricket::TCPConnection::OnClose(cricket::TCPConnection *this, rtc::AsyncPacketSocket *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void (*v20)(_QWORD *, cricket::TCPConnection *);
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  char v34;
  std::string __p;
  uint64_t (*v36)(uint64_t);

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0
    && (cricket::Connection::ToString(this, &__p),
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc"), SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0))
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    v10 = (_BYTE *)*((_QWORD *)this + 31);
    if (!v10)
      goto LABEL_17;
  }
  else
  {
    v10 = (_BYTE *)*((_QWORD *)this + 31);
    if (!v10)
      goto LABEL_17;
  }
  if (*v10 && *((_QWORD *)this + 32))
  {
    if (*((_BYTE *)this + 2333))
    {
      *((_BYTE *)this + 2333) = 0;
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
      {
        cricket::Connection::ToString(this, &__p);
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v11, v12, v13, v14, v15, v16, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/connection.cc");
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      v18 = (_QWORD *)*((_QWORD *)this + 4);
      for (*((_QWORD *)this + 6) = v18; v18 != (_QWORD *)((char *)this + 24); v18 = (_QWORD *)*((_QWORD *)this + 6))
      {
        v20 = (void (*)(_QWORD *, cricket::TCPConnection *))v18[2];
        v19 = v18 + 2;
        *((_QWORD *)this + 6) = *(v19 - 1);
        v20(v19, this);
      }
      *((_BYTE *)this + 2894) = 1;
      v21 = *((_QWORD *)this + 29);
      v22 = (unsigned int *)*((_QWORD *)this + 363);
      if (v22)
      {
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v24 = (_QWORD *)operator new();
      *v24 = v22;
      v24[1] = this;
      v24[3] = absl::internal_any_invocable::LocalManagerTrivial;
      v24[4] = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TCPConnection::OnClose(rtc::AsyncPacketSocket *,int)::$_1 &&>;
      v25 = 1000 * *((int *)this + 724);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)_ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
      v36 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
      v34 = 0;
      (*(void (**)(uint64_t, std::string *, uint64_t, char *, char *))(*(_QWORD *)v21 + 16))(v21, &__p, v25, &v34, &v33);
      ((void (*)(uint64_t, std::string *, std::string *))__p.__r_.__value_.__r.__words[2])(1, &__p, &__p);
    }
    else if (!*((_BYTE *)this + 2894))
    {
      cricket::TCPConnection::DisconnectSocketSignals((void (**)(char *, char *))this, *((rtc::AsyncPacketSocket **)this + 360));
      (*(void (**)(_QWORD, cricket::TCPConnection *))(**((_QWORD **)this + 32) + 200))(*((_QWORD *)this + 32), this);
    }
    return;
  }
LABEL_17:
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
}

void cricket::TCPConnection::DisconnectSocketSignals(void (**this)(char *, char *), rtc::AsyncPacketSocket *a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;

  if (*((_BYTE *)this + 2892))
  {
    v4 = (uint64_t *)*((_QWORD *)a2 + 31);
    if (v4 != (uint64_t *)((char *)a2 + 240))
    {
      while ((void (**)(char *, char *))v4[3] != this + 353)
      {
        v4 = (uint64_t *)v4[1];
        if (v4 == (uint64_t *)((char *)a2 + 240))
          goto LABEL_9;
      }
      v5 = *v4;
      v6 = v4[1];
      *(_QWORD *)(v5 + 8) = v6;
      *(_QWORD *)v4[1] = v5;
      v7 = (uint64_t *)*((_QWORD *)a2 + 33);
      --*((_QWORD *)a2 + 32);
      operator delete(v4);
      if (v7 == v4)
        *((_QWORD *)a2 + 33) = v6;
      this[355]((char *)this + 2824, (char *)a2 + 224);
    }
  }
LABEL_9:
  (*((void (**)(uint64_t, char *, char *))a2 + 41))(1, (char *)a2 + 312, (char *)a2 + 312);
  *((_QWORD *)a2 + 41) = absl::internal_any_invocable::EmptyManager;
  *((_QWORD *)a2 + 42) = 0;
  v8 = (uint64_t *)*((_QWORD *)a2 + 17);
  if (v8 != (uint64_t *)((char *)a2 + 128))
  {
    while ((void (**)(char *, char *))v8[3] != this + 353)
    {
      v8 = (uint64_t *)v8[1];
      if (v8 == (uint64_t *)((char *)a2 + 128))
        goto LABEL_16;
    }
    v9 = *v8;
    v10 = v8[1];
    *(_QWORD *)(v9 + 8) = v10;
    *(_QWORD *)v8[1] = v9;
    v11 = (uint64_t *)*((_QWORD *)a2 + 19);
    --*((_QWORD *)a2 + 18);
    operator delete(v8);
    if (v11 == v8)
      *((_QWORD *)a2 + 19) = v10;
    this[355]((char *)this + 2824, (char *)a2 + 112);
  }
LABEL_16:
  webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((rtc::AsyncPacketSocket *)((char *)a2 + 280), this);
}

uint64_t cricket::TCPConnection::OnReadyToSend(cricket::TCPConnection *this, rtc::AsyncPacketSocket *a2)
{
  char *v3;
  uint64_t result;
  uint64_t v5;
  void (*v6)(uint64_t, cricket::TCPConnection *);

  v3 = (char *)this + 136;
  result = *((_QWORD *)this + 18);
  for (*((_QWORD *)this + 20) = result; (char *)result != v3; result = *((_QWORD *)this + 20))
  {
    v6 = *(void (**)(uint64_t, cricket::TCPConnection *))(result + 16);
    v5 = result + 16;
    *((_QWORD *)this + 20) = *(_QWORD *)(v5 - 8);
    v6(v5, this);
  }
  return result;
}

uint64_t sigslot::_opaque_connection::emitter<cricket::TCPPort,rtc::AsyncPacketSocket *>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = a1[1];
  if (v3)
    v4 = v3 - 232;
  else
    v4 = 0;
  v5 = (_QWORD *)(v4 + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v5 + v1);
  return v1(v5);
}

uint64_t sigslot::_opaque_connection::emitter<cricket::TCPPort,rtc::AsyncPacketSocket *,rtc::SentPacket const&>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = a1[1];
  if (v3)
    v4 = v3 - 232;
  else
    v4 = 0;
  v5 = (_QWORD *)(v4 + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v5 + v1);
  return v1(v5);
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,cricket::TCPPort::OnNewConnection(rtc::AsyncListenSocket *,rtc::AsyncPacketSocket *)::$_0 &,rtc::AsyncPacketSocket *,rtc::ReceivedPacket const&>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  return cricket::Port::OnReadPacket(*a1, a3, 1);
}

uint64_t sigslot::_opaque_connection::emitter<cricket::TCPPort,rtc::AsyncListenSocket *,rtc::AsyncPacketSocket *>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = a1[1];
  if (v3)
    v4 = v3 - 232;
  else
    v4 = 0;
  v5 = (_QWORD *)(v4 + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v5 + v1);
  return v1(v5);
}

uint64_t sigslot::_opaque_connection::emitter<cricket::TCPConnection,cricket::Connection *>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = a1[1];
  if (v3)
    v4 = v3 - 2824;
  else
    v4 = 0;
  v5 = (_QWORD *)(v4 + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v5 + v1);
  return v1(v5);
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,cricket::TCPConnection::OnClose(rtc::AsyncPacketSocket *,int)::$_1 &&>(uint64_t result)
{
  uint64_t v1;
  _BYTE *v2;

  v1 = *(_QWORD *)result;
  if (*(_BYTE *)(*(_QWORD *)result + 2894))
  {
    v2 = *(_BYTE **)(v1 + 248);
    if (v2)
    {
      if (*v2)
      {
        result = *(_QWORD *)(v1 + 256);
        if (result)
          return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 192))(result);
      }
    }
  }
  return result;
}

void absl::internal_any_invocable::LocalInvoker<false,void,cricket::TCPConnection::CreateOutgoingTcpSocket(void)::$_0 &&>(cricket::Connection **a1)
{
  cricket::Connection::FailAndPrune(*a1);
}

uint64_t sigslot::_opaque_connection::emitter<cricket::TCPConnection,rtc::AsyncPacketSocket *>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = a1[1];
  if (v3)
    v4 = v3 - 2824;
  else
    v4 = 0;
  v5 = (_QWORD *)(v4 + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v5 + v1);
  return v1(v5);
}

void absl::internal_any_invocable::LocalInvoker<false,void,cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_0 &,rtc::AsyncPacketSocket *,rtc::ReceivedPacket const&>(uint64_t *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = *a1;
  v4 = *(_BYTE **)(v3 + 248);
  if (v4 && *v4 && *(_QWORD *)(v3 + 256))
  {
    cricket::Connection::OnReadPacket(v3, a3);
  }
  else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
  {
    rtc::webrtc_logging_impl::Log("\r\t", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcp_port.cc");
  }
}

_QWORD *std::__function::__func<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1,std::allocator<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1>,void ()(rtc::AsyncPacketSocket *,int)>::~__func(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  *a1 = &off_24C0C2440;
  v2 = (unsigned int *)a1[2];
  if (v2)
  {
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
      MEMORY[0x20BD0ADEC]();
  }
  return a1;
}

void std::__function::__func<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1,std::allocator<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1>,void ()(rtc::AsyncPacketSocket *,int)>::~__func(_QWORD *a1)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  *a1 = &off_24C0C2440;
  v1 = (unsigned int *)a1[2];
  if (v1)
  {
    do
    {
      v2 = __ldaxr(v1);
      v3 = v2 - 1;
    }
    while (__stlxr(v3, v1));
    if (!v3)
      MEMORY[0x20BD0ADEC]();
  }
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1,std::allocator<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1>,void ()(rtc::AsyncPacketSocket *,int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  unsigned int *v3;
  uint64_t v4;
  unsigned int v5;

  result = operator new(0x18uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(unsigned int **)(a1 + 16);
  *result = &off_24C0C2440;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    do
      v5 = __ldxr(v3);
    while (__stxr(v5 + 1, v3));
  }
  return result;
}

uint64_t std::__function::__func<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1,std::allocator<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1>,void ()(rtc::AsyncPacketSocket *,int)>::__clone(uint64_t result, _QWORD *a2)
{
  unsigned int *v2;
  uint64_t v3;
  unsigned int v4;

  v3 = *(_QWORD *)(result + 8);
  v2 = *(unsigned int **)(result + 16);
  *a2 = &off_24C0C2440;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    do
      v4 = __ldxr(v2);
    while (__stxr(v4 + 1, v2));
  }
  return result;
}

unsigned int *std::__function::__func<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1,std::allocator<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1>,void ()(rtc::AsyncPacketSocket *,int)>::destroy(uint64_t a1)
{
  unsigned int *result;
  unsigned int v2;
  unsigned int v3;

  result = *(unsigned int **)(a1 + 16);
  if (result)
  {
    do
    {
      v2 = __ldaxr(result);
      v3 = v2 - 1;
    }
    while (__stlxr(v3, result));
    if (!v3)
      JUMPOUT(0x20BD0ADECLL);
  }
  return result;
}

void std::__function::__func<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1,std::allocator<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1>,void ()(rtc::AsyncPacketSocket *,int)>::destroy_deallocate(_QWORD *__p)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  v2 = (unsigned int *)__p[2];
  if (v2)
  {
    do
    {
      v3 = __ldaxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
      MEMORY[0x20BD0ADEC]();
  }
  operator delete(__p);
}

void std::__function::__func<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1,std::allocator<cricket::TCPConnection::ConnectSocketSignals(rtc::AsyncPacketSocket *)::$_1>,void ()(rtc::AsyncPacketSocket *,int)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  if (*(_BYTE *)(*(_QWORD *)(a1 + 16) + 4))
    cricket::TCPConnection::OnClose(*(cricket::TCPConnection **)(a1 + 8), (rtc::AsyncPacketSocket *)*a3);
}

uint64_t webrtc::TemporalLayersChecker::CheckTemporalConfig(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result;
  int v4;
  int v5;
  unsigned int v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;

  if (*(_BYTE *)a3)
    return 1;
  v4 = *(_DWORD *)(a3 + 20);
  if (v4 == 255)
    return 1;
  v5 = *(_DWORD *)(a1 + 32);
  v6 = *(_DWORD *)(a1 + 36) + 1;
  *(_DWORD *)(a1 + 36) = v6;
  if (v4 >= v5)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0;
LABEL_10:
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v10, v11, v12, v13, v14, v15, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/temporal_layers_checker.cc");
    return 0;
  }
  v7 = v4 > 0;
  v8 = *(_DWORD *)(a3 + 4);
  if ((v8 & 1) == 0)
  {
    v9 = v6;
    goto LABEL_26;
  }
  if (*(_BYTE *)(a1 + 9))
  {
    v9 = v6;
    if (*(_BYTE *)(a1 + 8))
      goto LABEL_26;
    v7 = 0;
  }
  v9 = v6;
  if (!*(_BYTE *)(a1 + 8))
  {
    v9 = v6;
    if ((a2 & 1) == 0)
    {
      if (*(_DWORD *)(a1 + 12) >= v6)
        v9 = v6;
      else
        v9 = *(_DWORD *)(a1 + 12);
    }
  }
  if (*(unsigned __int8 *)(a1 + 9) > v4 && (a2 & 1) == 0 && !*(_BYTE *)(a1 + 8))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v17, v18, v19, v20, v21, v22, v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/temporal_layers_checker.cc");
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0;
LABEL_65:
    rtc::webrtc_logging_impl::Log("\r\t", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/temporal_layers_checker.cc");
    return 0;
  }
LABEL_26:
  if ((v8 & 2) == 0)
  {
    if (!a2)
      goto LABEL_28;
LABEL_31:
    *(_BYTE *)(a1 + 8) = 1;
    v31 = *(_DWORD *)(a3 + 8);
    if ((v31 & 1) == 0)
      goto LABEL_46;
    goto LABEL_32;
  }
  *(_BYTE *)(a1 + 9) = v4;
  *(_DWORD *)(a1 + 12) = v6;
  *(_BYTE *)(a1 + 8) = a2;
  if (a2)
    goto LABEL_31;
LABEL_28:
  v31 = *(_DWORD *)(a3 + 8);
  if ((v31 & 1) == 0)
    goto LABEL_46;
LABEL_32:
  if (*(_BYTE *)(a1 + 25))
  {
    if (*(_BYTE *)(a1 + 24))
      goto LABEL_46;
    v7 = 0;
  }
  if (!*(_BYTE *)(a1 + 24) && (a2 & 1) == 0 && *(_DWORD *)(a1 + 28) < v9)
    v9 = *(_DWORD *)(a1 + 28);
  if (*(unsigned __int8 *)(a1 + 25) > v4 && (a2 & 1) == 0 && !*(_BYTE *)(a1 + 24))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/temporal_layers_checker.cc");
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0;
    goto LABEL_65;
  }
LABEL_46:
  if ((v31 & 2) == 0)
  {
    if (!a2)
      goto LABEL_48;
LABEL_51:
    *(_BYTE *)(a1 + 24) = 1;
    v39 = *(_DWORD *)(a3 + 12);
    if ((v39 & 1) == 0)
      goto LABEL_66;
    goto LABEL_52;
  }
  *(_BYTE *)(a1 + 25) = v4;
  *(_DWORD *)(a1 + 28) = v6;
  *(_BYTE *)(a1 + 24) = a2;
  if (a2)
    goto LABEL_51;
LABEL_48:
  v39 = *(_DWORD *)(a3 + 12);
  if ((v39 & 1) == 0)
    goto LABEL_66;
LABEL_52:
  if (*(_BYTE *)(a1 + 17))
  {
    if (*(_BYTE *)(a1 + 16))
      goto LABEL_66;
    v7 = 0;
  }
  if (!*(_BYTE *)(a1 + 16) && (a2 & 1) == 0 && *(_DWORD *)(a1 + 20) < v9)
    v9 = *(_DWORD *)(a1 + 20);
  if (*(unsigned __int8 *)(a1 + 17) > v4 && (a2 & 1) == 0 && !*(_BYTE *)(a1 + 16))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v40, v41, v42, v43, v44, v45, v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/temporal_layers_checker.cc");
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0;
    goto LABEL_65;
  }
LABEL_66:
  if ((v39 & 2) != 0)
  {
    *(_BYTE *)(a1 + 17) = v4;
    *(_DWORD *)(a1 + 20) = v6;
    *(_BYTE *)(a1 + 16) = a2;
  }
  if (a2)
  {
    *(_BYTE *)(a1 + 16) = 1;
    v47 = (unsigned int *)(a1 + 40);
  }
  else
  {
    v47 = (unsigned int *)(a1 + 40);
    if (v9 < *(_DWORD *)(a1 + 40))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int> const&)::t, v48, v49, v50, v51, v52, v53, v54, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/temporal_layers_checker.cc");
      return 0;
    }
  }
  if (v4)
  {
    if (!a2)
      goto LABEL_76;
LABEL_83:
    *v47 = v6;
    if (!v7)
      goto LABEL_78;
    goto LABEL_77;
  }
  *(_DWORD *)(a1 + 44) = v6;
  if (a2)
    goto LABEL_83;
LABEL_76:
  if (v7)
LABEL_77:
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 44);
LABEL_78:
  result = 1;
  if (v7 != *(unsigned __int8 *)(a3 + 24) && (a2 & 1) == 0)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0;
    goto LABEL_10;
  }
  return result;
}

void webrtc::TemporalLayersChecker::~TemporalLayersChecker(webrtc::TemporalLayersChecker *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

void dcsctp::TextPcapPacketObserver::OnSentPacket(uint64_t a1, int a2, unsigned __int8 *a3, uint64_t a4)
{
  const std::string::value_type *v6;
  std::string::size_type v7;
  unsigned __int8 *v8;

  v6 = (const std::string::value_type *)(a1 + 8);
  if ((*(char *)(a1 + 31) & 0x80000000) == 0)
  {
    v7 = *(unsigned __int8 *)(a1 + 31);
    if (a4)
      v8 = a3;
    else
      v8 = 0;
LABEL_5:
    dcsctp::TextPcapPacketObserver::PrintPacket("O ", 2uLL, v6, v7, a2, v8, a4);
    return;
  }
  v7 = *(_QWORD *)(a1 + 16);
  if ((v7 & 0x8000000000000000) == 0)
  {
    v6 = *(const std::string::value_type **)v6;
    if (!v7 || v6 != 0)
    {
      if (a4)
        v8 = a3;
      else
        v8 = 0;
      goto LABEL_5;
    }
  }
  __break(1u);
}

void dcsctp::TextPcapPacketObserver::PrintPacket(char *__src, size_t __len, const std::string::value_type *a3, std::string::size_type a4, int a5, unsigned __int8 *a6, uint64_t a7)
{
  uint64_t v15;
  size_t v16;
  std::string *v17;
  std::string::value_type *v18;
  std::string::value_type *v19;
  std::string::size_type v20;
  std::string::size_type size;
  std::string *v22;
  char *v23;
  std::string::size_type v24;
  int v25;
  std::string::size_type v26;
  std::string::size_type v27;
  std::string *v28;
  std::string::size_type v30;
  std::string::size_type v31;
  std::string::size_type v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  std::string *v40;
  char *v41;
  std::string::size_type v42;
  std::string v43;

  memset(&v43, 0, sizeof(v43));
  if (&v43 <= (std::string *)"\n" && (char *)&v43.__r_.__value_.__l.__data_ + 1 > "\n")
    goto LABEL_87;
  LOWORD(v43.__r_.__value_.__l.__data_) = 10;
  *((_BYTE *)&v43.__r_.__value_.__s + 23) = 1;
  if (!__src)
  {
    if (__len)
      goto LABEL_87;
  }
  if (__len <= 0x15)
  {
    if (!__len)
      goto LABEL_24;
    if ((char *)&v43.__r_.__value_.__l.__data_ + 1 <= __src
      && (char *)&v43.__r_.__value_.__l.__data_ + __len + 1 > __src)
    {
      goto LABEL_87;
    }
    memmove((char *)&v43.__r_.__value_.__l.__data_ + 1, __src, __len);
    if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
      v43.__r_.__value_.__l.__size_ = __len + 1;
    else
      *((_BYTE *)&v43.__r_.__value_.__s + 23) = __len + 1;
    v19 = &v43.__r_.__value_.__s.__data_[__len + 1];
  }
  else
  {
    if (__len - 0x7FFFFFFFFFFFFFF6 <= 0x800000000000001ELL)
      goto LABEL_88;
    v15 = 44;
    if (__len + 1 > 0x2C)
      v15 = __len + 1;
    v16 = (v15 | 7) + 1;
    v17 = (std::string *)operator new(v16);
    v18 = &v17->__r_.__value_.__s.__data_[1];
    if (&v43 >= v17 && (std::string *)((char *)&v17->__r_.__value_.__l.__data_ + 1) > &v43)
      goto LABEL_87;
    v17->__r_.__value_.__s.__data_[0] = 10;
    if (v18 <= __src && &v18[__len] > __src)
      goto LABEL_87;
    memcpy(v18, __src, __len);
    v43.__r_.__value_.__l.__size_ = __len + 1;
    v43.__r_.__value_.__r.__words[2] = v16 | 0x8000000000000000;
    v43.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
    v19 = &v17->__r_.__value_.__s.__data_[__len + 1];
  }
  *v19 = 0;
LABEL_24:
  rtc::StringBuilder::AppendFormat(&v43, "%02d:%02d:%02d.%03d", a5 % 86400000 / 3600000, a5 % 86400000 % 3600000 / 60000, a5 % 86400000 % 3600000 % 60000 / 1000, a5 % 86400000 % 3600000 % 60000 % 1000);
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v20 = 22;
  else
    v20 = (v43.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v43.__r_.__value_.__r.__words[2]);
  else
    size = v43.__r_.__value_.__l.__size_;
  if (v20 - size < 5)
  {
    std::string::__grow_by_and_replace(&v43, v20, size - v20 + 5, size, size, 0, 5uLL, " 0000");
    if (!a7)
      goto LABEL_43;
    do
    {
LABEL_42:
      v25 = *a6++;
      rtc::StringBuilder::AppendFormat(&v43, " %02x", v25);
      --a7;
    }
    while (a7);
    goto LABEL_43;
  }
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v22 = &v43;
  else
    v22 = (std::string *)v43.__r_.__value_.__r.__words[0];
  v23 = (char *)v22 + size;
  if ((char *)v22 + size <= " 0000" && v23 + 5 > " 0000")
    goto LABEL_87;
  v23[4] = 48;
  *(_DWORD *)v23 = 808464416;
  v24 = size + 5;
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
  {
    v43.__r_.__value_.__l.__size_ = size + 5;
    v22->__r_.__value_.__s.__data_[v24] = 0;
    if (!a7)
      goto LABEL_43;
    goto LABEL_42;
  }
  *((_BYTE *)&v43.__r_.__value_.__s + 23) = v24 & 0x7F;
  v22->__r_.__value_.__s.__data_[v24] = 0;
  if (a7)
    goto LABEL_42;
LABEL_43:
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v26 = 22;
  else
    v26 = (v43.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v27 = HIBYTE(v43.__r_.__value_.__r.__words[2]);
  else
    v27 = v43.__r_.__value_.__l.__size_;
  if (v26 - v27 < 0xF)
  {
    std::string::__grow_by_and_replace(&v43, v26, v27 - v26 + 15, v27, v27, 0, 0xFuLL, " # SCTP_PACKET ");
    if (a3)
      goto LABEL_63;
    goto LABEL_62;
  }
  v28 = &v43;
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v28 = (std::string *)v43.__r_.__value_.__r.__words[0];
  if ((char *)v28 + v27 <= " # SCTP_PACKET "
    && (char *)&v28->__r_.__value_.__r.__words[1] + v27 + 7 > " # SCTP_PACKET ")
  {
    goto LABEL_87;
  }
  qmemcpy((char *)v28 + v27, " # SCTP_PACKET ", 15);
  v30 = v27 + 15;
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
  {
    v43.__r_.__value_.__l.__size_ = v27 + 15;
    v28->__r_.__value_.__s.__data_[v30] = 0;
    if (a3)
      goto LABEL_63;
LABEL_62:
    if (!a4)
      goto LABEL_63;
LABEL_87:
    __break(1u);
LABEL_88:
    abort();
  }
  *((_BYTE *)&v43.__r_.__value_.__s + 23) = v30 & 0x7F;
  v28->__r_.__value_.__s.__data_[v30] = 0;
  if (!a3)
    goto LABEL_62;
LABEL_63:
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v31 = 22;
  else
    v31 = (v43.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v32 = HIBYTE(v43.__r_.__value_.__r.__words[2]);
  else
    v32 = v43.__r_.__value_.__l.__size_;
  if (v31 - v32 < a4)
  {
    std::string::__grow_by_and_replace(&v43, v31, v32 + a4 - v31, v32, v32, 0, a4, a3);
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) != 0)
      goto LABEL_82;
LABEL_81:
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v33, v34, v35, v36, v37, v38, v39, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/net/dcsctp/public/text_pcap_packet_observer.cc");
    goto LABEL_82;
  }
  if (!a4)
  {
LABEL_80:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) != 0)
      goto LABEL_82;
    goto LABEL_81;
  }
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v40 = &v43;
  else
    v40 = (std::string *)v43.__r_.__value_.__r.__words[0];
  v41 = (char *)v40 + v32;
  if ((char *)v40 + v32 <= a3 && &v41[a4] > a3)
    goto LABEL_87;
  memmove(v41, a3, a4);
  v42 = v32 + a4;
  if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    *((_BYTE *)&v43.__r_.__value_.__s + 23) = v42 & 0x7F;
    v40->__r_.__value_.__s.__data_[v42] = 0;
    goto LABEL_80;
  }
  v43.__r_.__value_.__l.__size_ = v32 + a4;
  v40->__r_.__value_.__s.__data_[v42] = 0;
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
    goto LABEL_81;
LABEL_82:
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v43.__r_.__value_.__l.__data_);
}

void dcsctp::TextPcapPacketObserver::OnReceivedPacket(uint64_t a1, int a2, unsigned __int8 *a3, uint64_t a4)
{
  const std::string::value_type *v6;
  std::string::size_type v7;
  unsigned __int8 *v8;

  v6 = (const std::string::value_type *)(a1 + 8);
  if ((*(char *)(a1 + 31) & 0x80000000) == 0)
  {
    v7 = *(unsigned __int8 *)(a1 + 31);
    if (a4)
      v8 = a3;
    else
      v8 = 0;
LABEL_5:
    dcsctp::TextPcapPacketObserver::PrintPacket("I ", 2uLL, v6, v7, a2, v8, a4);
    return;
  }
  v7 = *(_QWORD *)(a1 + 16);
  if ((v7 & 0x8000000000000000) == 0)
  {
    v6 = *(const std::string::value_type **)v6;
    if (!v7 || v6 != 0)
    {
      if (a4)
        v8 = a3;
      else
        v8 = 0;
      goto LABEL_5;
    }
  }
  __break(1u);
}

void dcsctp::TextPcapPacketObserver::~TextPcapPacketObserver(void **this)
{
  *this = off_24C0C24B0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_24C0C24B0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x20BD0ADECLL);
}

rtc::ThreadManager *rtc::ThreadManager::ThreadManager(rtc::ThreadManager *this)
{
  pthread_mutex_t *v2;
  pthread_mutexattr_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v2 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutexattr_init(&v4);
  pthread_mutexattr_setpolicy_np(&v4, 3);
  pthread_mutex_init(v2, &v4);
  pthread_mutexattr_destroy(&v4);
  InitCocoaMultiThreading();
  pthread_key_create((pthread_key_t *)this + 11, 0);
  return this;
}

uint64_t rtc::ThreadManager::Add(rtc::ThreadManager *this, rtc::Thread *a2)
{
  rtc::ThreadManager *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v6;
  uint64_t v7;
  pthread_mutexattr_t v9;
  uint64_t v10;

  v2 = this;
  v10 = *MEMORY[0x24BDAC8D0];
  v4 = &unk_253EA7000;
  if ((v3 & 1) == 0)
  {
    v2 = this;
    if (v6)
    {
      v7 = operator new();
      *(_QWORD *)(v7 + 8) = 0;
      *(_QWORD *)(v7 + 16) = 0;
      *(_QWORD *)v7 = 0;
      pthread_mutexattr_init(&v9);
      pthread_mutexattr_setpolicy_np(&v9, 3);
      pthread_mutex_init((pthread_mutex_t *)(v7 + 24), &v9);
      pthread_mutexattr_destroy(&v9);
      InitCocoaMultiThreading();
      pthread_key_create((pthread_key_t *)(v7 + 88), 0);
      rtc::ThreadManager::Instance(void)::thread_manager = v7;
      v4 = (_QWORD *)&unk_253EA7000;
      v2 = this;
    }
  }
  return rtc::ThreadManager::AddInternal(v4[292], (uint64_t)v2);
}

uint64_t rtc::ThreadManager::AddInternal(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  unint64_t v5;
  char *v6;
  char *v7;
  _QWORD *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  unint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  char *v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _OWORD *v23;
  __int128 *v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;

  v4 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  v6 = *(char **)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v7 = v6;
  if ((unint64_t)v6 < v5)
  {
    if (v6)
    {
      *(_QWORD *)v6 = a2;
      v8 = v6 + 8;
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  v9 = *(char **)a1;
  v10 = (uint64_t)&v6[-*(_QWORD *)a1];
  v11 = v10 >> 3;
  v12 = (v10 >> 3) + 1;
  if (v12 >> 61)
    goto LABEL_23;
  v13 = v5 - (_QWORD)v9;
  if (v13 >> 2 > v12)
    v12 = v13 >> 2;
  v14 = (unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8;
  v15 = 0x1FFFFFFFFFFFFFFFLL;
  if (!v14)
    v15 = v12;
  if (!v15)
  {
LABEL_22:
    __break(1u);
LABEL_23:
    abort();
  }
  if (v15 >> 61)
    std::__throw_bad_array_new_length[abi:sn180100]();
  v16 = 8 * v15;
  v17 = operator new(8 * v15);
  v18 = &v17[v16];
  v19 = &v17[8 * v11];
  *v19 = a2;
  v8 = v19 + 1;
  if (v6 != v9)
  {
    v20 = v6 - v9 - 8;
    if (v20 < 0x58)
      goto LABEL_27;
    if ((unint64_t)(&v6[-v10] - v17) < 0x20)
      goto LABEL_27;
    v21 = (v20 >> 3) + 1;
    v22 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v7 = &v6[-v22];
    v19 = (_QWORD *)((char *)v19 - v22);
    v23 = &v17[8 * v11 - 16];
    v24 = (__int128 *)(v6 - 16);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v26 = *v24;
      *(v23 - 1) = *(v24 - 1);
      *v23 = v26;
      v23 -= 2;
      v24 -= 2;
      v25 -= 4;
    }
    while (v25);
    if (v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_27:
      do
      {
        v27 = *((_QWORD *)v7 - 1);
        v7 -= 8;
        *--v19 = v27;
      }
      while (v7 != v9);
    }
    v7 = v9;
  }
  *(_QWORD *)a1 = v19;
  *(_QWORD *)(a1 + 8) = v8;
  *(_QWORD *)(a1 + 16) = v18;
  if (v7)
    operator delete(v7);
LABEL_21:
  *(_QWORD *)(a1 + 8) = v8;
  return pthread_mutex_unlock(v4);
}

void *rtc::Thread::Current(rtc::Thread *this)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v4;
  pthread_mutexattr_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v2 = &unk_253EA7000;
  {
    v4 = operator new();
    *(_QWORD *)(v4 + 8) = 0;
    *(_QWORD *)(v4 + 16) = 0;
    *(_QWORD *)v4 = 0;
    pthread_mutexattr_init(&v5);
    pthread_mutexattr_setpolicy_np(&v5, 3);
    pthread_mutex_init((pthread_mutex_t *)(v4 + 24), &v5);
    pthread_mutexattr_destroy(&v5);
    InitCocoaMultiThreading();
    pthread_key_create((pthread_key_t *)(v4 + 88), 0);
    rtc::ThreadManager::Instance(void)::thread_manager = v4;
    v2 = (_QWORD *)&unk_253EA7000;
  }
  return pthread_getspecific(*(_QWORD *)(v2[292] + 88));
}

void rtc::Thread::ProcessMessages(rtc::Thread *this, int a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  BOOL v8;
  void *v9;
  uint64_t v10;
  _BYTE v11[16];
  __int128 v12;
  _BYTE v13[16];
  __int128 v14;

  if (a2 == -1)
  {
    do
    {
      v4 = (void *)MEMORY[0x20BD0B284]();
      rtc::Thread::Get((rtc::Thread *)v13, (uint64_t)this, -1);
      v5 = *((_QWORD *)&v14 + 1);
      if (*((_QWORD *)&v14 + 1))
      {
        ((void (*)(_QWORD, _BYTE *, _BYTE *))v14)(0, v13, v11);
        v12 = v14;
        v14 = (unint64_t)absl::internal_any_invocable::EmptyManager;
        rtc::Thread::Dispatch((uint64_t)this, (uint64_t)v11);
        ((void (*)(uint64_t, _BYTE *, _BYTE *))v12)(1, v11, v11);
      }
      else
      {
        (*(void (**)(rtc::Thread *))(*(_QWORD *)this + 48))(this);
      }
      ((void (*)(uint64_t, _BYTE *, _BYTE *))v14)(1, v13, v13);
      objc_autoreleasePoolPop(v4);
    }
    while (v5);
  }
  else
  {
    if (rtc::g_clock)
    {
      v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
    }
    else
    {
      if (!dword_253EA791C)
        mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
      v3 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
         / dword_253EA791C;
    }
    v6 = 0;
    v7 = v3 / 1000000;
    do
    {
      v9 = (void *)MEMORY[0x20BD0B284]();
      rtc::Thread::Get((rtc::Thread *)v13, (uint64_t)this, v6);
      if (*((_QWORD *)&v14 + 1))
      {
        ((void (*)(_QWORD, _BYTE *, _BYTE *))v14)(0, v13, v11);
        v12 = v14;
        v14 = (unint64_t)absl::internal_any_invocable::EmptyManager;
        rtc::Thread::Dispatch((uint64_t)this, (uint64_t)v11);
        ((void (*)(uint64_t, _BYTE *, _BYTE *))v12)(1, v11, v11);
        if (rtc::g_clock)
        {
          LODWORD(v10) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
        }
        else
        {
          if (!dword_253EA791C)
            mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
          v10 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
              / dword_253EA791C;
        }
        v6 = (int)v10 / -1000000 + v7;
        v8 = v6 >= 0;
      }
      else
      {
        (*(void (**)(rtc::Thread *))(*(_QWORD *)this + 48))(this);
        v8 = 0;
      }
      ((void (*)(uint64_t, _BYTE *, _BYTE *))v14)(1, v13, v13);
      objc_autoreleasePoolPop(v9);
    }
    while (v8);
  }
}

uint64_t rtc::ThreadManager::SetCurrentThread(rtc::ThreadManager *this, rtc::Thread *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;

  if (a2)
  {
    operator new();
    *v5 = *v4;
    *v4 = a2;
    v6 = (_QWORD *)*((_QWORD *)a2 + 28);
    *((_QWORD *)a2 + 28) = v5;
    if (v6)
    {
      *v4 = *v6;
      MEMORY[0x20BD0ADEC](v6, 0x60C4044C4A2DFLL);
    }
    return pthread_setspecific(*((_QWORD *)this + 11), a2);
  }
  else
  {
    v7 = pthread_getspecific(*((_QWORD *)this + 11));
    if (v7)
    {
      v8 = v7[28];
      v7[28] = 0;
      if (v8)
      {
        *v9 = v10;
        MEMORY[0x20BD0ADEC](v11, 0x60C4044C4A2DFLL);
      }
    }
    return pthread_setspecific(*((_QWORD *)this + 11), 0);
  }
}

uint64_t rtc::ThreadManager::WrapCurrentThread(rtc::ThreadManager *this)
{
  uint64_t v2;
  uint64_t v3;
  rtc::Signaler *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  pthread_mutexattr_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = (uint64_t)pthread_getspecific(*((_QWORD *)this + 11));
  if (!v2)
  {
    v2 = operator new();
    v3 = operator new();
    *(_QWORD *)v3 = &off_24C0BA760;
    *(_QWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_QWORD *)(v3 + 48) = 0;
    *(_DWORD *)(v3 + 56) = 1065353216;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_DWORD *)(v3 + 96) = 1065353216;
    *(_QWORD *)(v3 + 112) = 0;
    *(_QWORD *)(v3 + 120) = 0;
    *(_QWORD *)(v3 + 104) = 0;
    pthread_mutexattr_init(&v10);
    pthread_mutexattr_settype(&v10, 2);
    pthread_mutexattr_setpolicy_np(&v10, 3);
    pthread_mutex_init((pthread_mutex_t *)(v3 + 136), &v10);
    pthread_mutexattr_destroy(&v10);
    *(_WORD *)(v3 + 216) = 0;
    v4 = (rtc::Signaler *)operator new();
    *(_QWORD *)(v3 + 128) = rtc::Signaler::Signaler(v4, (rtc::PhysicalSocketServer *)v3, (BOOL *)(v3 + 216));
    rtc::Thread::Thread((_BYTE *)v2, v3, 1);
    v5 = *(_QWORD *)(v2 + 176);
    *(_QWORD *)(v2 + 176) = v3;
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    *(_QWORD *)(v2 + 208) = pthread_self();
    *(_BYTE *)(v2 + 216) = 0;
    operator new();
    *v7 = *v6;
    *v6 = v2;
    v8 = *(uint64_t **)(v2 + 224);
    *(_QWORD *)(v2 + 224) = v7;
    if (v8)
    {
      *v6 = *v8;
      MEMORY[0x20BD0ADEC](v8, 0x60C4044C4A2DFLL);
    }
    pthread_setspecific(*((_QWORD *)this + 11), (const void *)v2);
  }
  return v2;
}

uint64_t rtc::Thread::UnwrapCurrent(rtc::Thread *this)
{
  unsigned __int8 v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  pthread_mutexattr_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = &unk_253EA7000;
  {
    v11 = operator new();
    *(_QWORD *)(v11 + 8) = 0;
    *(_QWORD *)(v11 + 16) = 0;
    *(_QWORD *)v11 = 0;
    pthread_mutexattr_init(&v12);
    pthread_mutexattr_setpolicy_np(&v12, 3);
    pthread_mutex_init((pthread_mutex_t *)(v11 + 24), &v12);
    pthread_mutexattr_destroy(&v12);
    InitCocoaMultiThreading();
    pthread_key_create((pthread_key_t *)(v11 + 88), 0);
    rtc::ThreadManager::Instance(void)::thread_manager = v11;
    v3 = (_QWORD *)&unk_253EA7000;
  }
  v4 = v3[292];
  v5 = pthread_getspecific(*(_QWORD *)(v4 + 88));
  if (v5)
  {
    v6 = v5[28];
    v5[28] = 0;
    if (v6)
    {
      *v7 = v8;
      MEMORY[0x20BD0ADEC](v9, 0x60C4044C4A2DFLL);
    }
  }
  result = pthread_setspecific(*(_QWORD *)(v4 + 88), 0);
  *((_QWORD *)this + 26) = 0;
  return result;
}

_BYTE *rtc::Thread::Thread(_BYTE *a1, uint64_t a2, int a3)
{
  pthread_mutex_t *v6;
  rtc::Thread *v7;
  pthread_mutexattr_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = &off_24C0C24E0;
  *((_DWORD *)a1 + 22) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  v6 = (pthread_mutex_t *)(a1 + 96);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *((_QWORD *)a1 + 9) = 0;
  pthread_mutexattr_init(&v9);
  pthread_mutexattr_setpolicy_np(&v9, 3);
  pthread_mutex_init(v6, &v9);
  pthread_mutexattr_destroy(&v9);
  *((_WORD *)a1 + 80) = 0;
  *((_DWORD *)a1 + 41) = 0;
  *((_QWORD *)a1 + 21) = a2;
  *((_QWORD *)a1 + 26) = 0;
  *((_OWORD *)a1 + 11) = 0u;
  *((_OWORD *)a1 + 12) = 0u;
  *((_WORD *)a1 + 108) = 257;
  *((_QWORD *)a1 + 28) = 0;
  *((_DWORD *)a1 + 58) = 50;
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)a2 + 24))(a2, a1);
  rtc::Thread::SetName((uint64_t)a1, "Thread", 6uLL, a1);
  if (a3 && !a1[160])
  {
    a1[160] = 1;
    rtc::ThreadManager::Add((rtc::ThreadManager *)a1, v7);
  }
  return a1;
}

uint64_t rtc::Thread::SetName(uint64_t a1, char *__src, size_t __len, const void *a4)
{
  char *v8;
  size_t v9;
  size_t v10;
  char *v11;
  void **v13;
  size_t v14;
  size_t v15;
  uint64_t v16;
  std::string::size_type v17;
  std::string::size_type v18;
  std::string::size_type v19;
  char __str[16];
  unint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if (__len >= 0x7FFFFFFFFFFFFFF8)
LABEL_32:
    abort();
  if (__len > 0x16)
  {
    v9 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v9 = __len | 7;
    v10 = v9 + 1;
    v8 = (char *)operator new(v9 + 1);
    *(_QWORD *)&__str[8] = __len;
    v22 = v10 | 0x8000000000000000;
    *(_QWORD *)__str = v8;
  }
  else
  {
    HIBYTE(v22) = __len;
    v8 = __str;
  }
  v11 = &v8[__len];
  if (v8 <= __src && v11 > __src)
    goto LABEL_31;
  if (__len)
    memmove(v8, __src, __len);
  *v11 = 0;
  v13 = (void **)(a1 + 184);
  if (*(char *)(a1 + 207) < 0)
  {
    operator delete(*v13);
    *(_OWORD *)v13 = *(_OWORD *)__str;
    *(_QWORD *)(a1 + 200) = v22;
    if (!a4)
      return 1;
  }
  else
  {
    *(_OWORD *)v13 = *(_OWORD *)__str;
    *(_QWORD *)(a1 + 200) = v22;
    if (!a4)
      return 1;
  }
  snprintf(__str, 0x1EuLL, " 0x%p", a4);
  v14 = strlen(__str);
  v15 = v14;
  v16 = *(unsigned __int8 *)(a1 + 207);
  if (*(char *)(a1 + 207) < 0)
  {
    v18 = *(_QWORD *)(a1 + 192);
    v17 = (*(_QWORD *)(a1 + 200) & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v17 - v18 < v14)
      goto LABEL_19;
  }
  else
  {
    v17 = 22;
    v18 = *(unsigned __int8 *)(a1 + 207);
    if (22 - v16 < v14)
    {
LABEL_19:
      std::string::__grow_by_and_replace((std::string *)(a1 + 184), v17, v14 - v17 + v18, v18, v18, 0, v14, __str);
      return 1;
    }
  }
  if (!v14)
    return 1;
  if ((v16 & 0x80) != 0)
    v13 = (void **)*v13;
  if ((char *)v13 + v18 <= __str && (char *)v13 + v18 + v14 > __str)
  {
LABEL_31:
    __break(1u);
    goto LABEL_32;
  }
  memmove((char *)v13 + v18, __str, v14);
  v19 = v18 + v15;
  if (*(char *)(a1 + 207) < 0)
    *(_QWORD *)(a1 + 192) = v19;
  else
    *(_BYTE *)(a1 + 207) = v19 & 0x7F;
  *((_BYTE *)v13 + v19) = 0;
  return 1;
}

void rtc::Thread::~Thread(rtc::Thread *this)
{
  rtc::Thread *v2;
  rtc::Thread *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;

  *(_QWORD *)this = &off_24C0C24E0;
  atomic_store(1u, (unsigned int *)this + 41);
  v2 = (rtc::Thread *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 21) + 40))(*((_QWORD *)this + 21));
  if (*((_QWORD *)this + 26))
  {
    v3 = (rtc::Thread *)rtc::Thread::Current(v2);
    if (v3
      && !*((_BYTE *)rtc::Thread::Current(v3) + 217)
      && (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      rtc::webrtc_logging_impl::Log("\r\t", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/thread.cc");
    }
    pthread_join(*((pthread_t *)this + 26), 0);
    *((_QWORD *)this + 26) = 0;
  }
  rtc::Thread::DoDestroy(this);
  v11 = *((_QWORD *)this + 28);
  *((_QWORD *)this + 28) = 0;
  if (v11)
  {
    *v12 = v13;
    MEMORY[0x20BD0ADEC](v14, 0x60C4044C4A2DFLL);
  }
  if ((*((char *)this + 207) & 0x80000000) == 0)
  {
    v15 = *((_QWORD *)this + 22);
    *((_QWORD *)this + 22) = 0;
    if (!v15)
      goto LABEL_12;
    goto LABEL_11;
  }
  operator delete(*((void **)this + 23));
  v15 = *((_QWORD *)this + 22);
  *((_QWORD *)this + 22) = 0;
  if (v15)
LABEL_11:
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
LABEL_12:
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 96));
  v16 = *((_QWORD *)this + 7);
  if (v16)
  {
    v17 = *((_QWORD *)this + 8);
    v18 = (void *)*((_QWORD *)this + 7);
    if (v17 != v16)
    {
      do
      {
        v19 = v17 - 56;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(v17 - 16))(1, v17 - 32, v17 - 32);
        v17 = v19;
      }
      while (v19 != v16);
      v18 = (void *)*((_QWORD *)this + 7);
    }
    *((_QWORD *)this + 8) = v16;
    operator delete(v18);
  }
  _ZNSt3__15dequeIN4absl12AnyInvocableIFvvOEEENS_9allocatorIS4_EEED2B8sn180100Ev((void **)this + 1);
}

{
  rtc::Thread::~Thread(this);
  JUMPOUT(0x20BD0ADECLL);
}

void rtc::Thread::DoDestroy(rtc::Thread *this)
{
  uint64_t v2;
  unsigned __int8 v3;
  uint64_t v4;
  rtc::Thread **v5;
  rtc::Thread **v6;
  int64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  void **v11;
  unint64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  void **v32;
  uint64_t v33;
  _OWORD *v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  void **v47;
  uint64_t v48;
  _OWORD *v49;
  __int128 v50;
  uint64_t v51;
  __int128 v52;
  void **v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  unsigned __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v62 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 161))
    return;
  *((_BYTE *)this + 161) = 1;
  v2 = *((_QWORD *)this + 21);
  if (v2)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 24))(v2, 0);
  {
    v58 = operator new();
    *(_QWORD *)(v58 + 8) = 0;
    *(_QWORD *)(v58 + 16) = 0;
    *(_QWORD *)v58 = 0;
    pthread_mutexattr_init((pthread_mutexattr_t *)&v59);
    pthread_mutexattr_setpolicy_np((pthread_mutexattr_t *)&v59, 3);
    pthread_mutex_init((pthread_mutex_t *)(v58 + 24), (const pthread_mutexattr_t *)&v59);
    pthread_mutexattr_destroy((pthread_mutexattr_t *)&v59);
    InitCocoaMultiThreading();
    pthread_key_create((pthread_key_t *)(v58 + 88), 0);
    rtc::ThreadManager::Instance(void)::thread_manager = v58;
  }
  v4 = rtc::ThreadManager::Instance(void)::thread_manager;
  pthread_mutex_lock((pthread_mutex_t *)(rtc::ThreadManager::Instance(void)::thread_manager + 24));
  v6 = *(rtc::Thread ***)v4;
  v5 = *(rtc::Thread ***)(v4 + 8);
  if (*(rtc::Thread ***)v4 != v5)
  {
    while (*v6 != this)
    {
      if (++v6 == v5)
      {
        v6 = *(rtc::Thread ***)(v4 + 8);
        break;
      }
    }
  }
  if (v6 != v5)
  {
    v7 = (char *)v5 - (char *)(v6 + 1);
    if (v5 != v6 + 1)
      memmove(v6, v6 + 1, (char *)v5 - (char *)(v6 + 1));
    *(_QWORD *)(v4 + 8) = (char *)v6 + v7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 24));
  v9 = *v8;
  *v8 = (uint64_t)this;
  v60 = 0u;
  v61 = 0u;
  v59 = 0u;
  v11 = (void **)*((_QWORD *)this + 2);
  v10 = *((_QWORD *)this + 3);
  if ((void **)v10 == v11)
  {
    v10 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 6) = 0;
    v17 = 0;
  }
  else
  {
    v12 = *((_QWORD *)this + 5);
    v13 = &v11[v12 >> 7];
    v14 = (uint64_t)*v13 + 32 * (v12 & 0x7F);
    v15 = *(uint64_t *)((char *)v11 + (((*((_QWORD *)this + 6) + v12) >> 4) & 0xFFFFFFFFFFFFFF8))
        + 32 * ((*((_QWORD *)this + 6) + v12) & 0x7F);
    if (v14 != v15)
    {
      do
      {
        if (!v14)
          __break(1u);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(v14 + 16))(1, v14, v14);
        v14 += 32;
        if (v14 - (_QWORD)*v13 == 4096)
        {
          v16 = (uint64_t)v13[1];
          ++v13;
          v14 = v16;
        }
      }
      while (v14 != v15);
      v11 = (void **)*((_QWORD *)this + 2);
      v10 = *((_QWORD *)this + 3);
    }
    *((_QWORD *)this + 6) = 0;
    v17 = v10 - (_QWORD)v11;
    if ((unint64_t)(v10 - (_QWORD)v11) >= 0x11)
    {
      do
      {
        operator delete(*v11);
        v10 = *((_QWORD *)this + 3);
        v11 = (void **)(*((_QWORD *)this + 2) + 8);
        *((_QWORD *)this + 2) = v11;
        v17 = v10 - (_QWORD)v11;
      }
      while ((unint64_t)(v10 - (_QWORD)v11) > 0x10);
    }
  }
  v18 = v17 >> 3;
  if (v18 == 1)
  {
    v19 = 64;
  }
  else
  {
    if (v18 != 2)
      goto LABEL_29;
    v19 = 128;
  }
  *((_QWORD *)this + 5) = v19;
LABEL_29:
  v20 = *((_QWORD *)this + 6);
  if (v20)
  {
    v21 = *((_QWORD *)this + 5);
    if (v21 >= 0x80)
    {
      operator delete(*v11);
      v10 = *((_QWORD *)this + 3);
      v11 = (void **)(*((_QWORD *)this + 2) + 8);
      *((_QWORD *)this + 2) = v11;
      v20 = *((_QWORD *)this + 6);
      v21 = *((_QWORD *)this + 5) - 128;
      *((_QWORD *)this + 5) = v21;
    }
    v22 = 16 * (v10 - (_QWORD)v11) - 1;
    if ((void **)v10 == v11)
      v22 = 0;
    if (v22 - (v21 + v20) >= 0x80)
    {
      operator delete(*(void **)(v10 - 8));
      v11 = (void **)*((_QWORD *)this + 2);
      v10 = *((_QWORD *)this + 3) - 8;
      *((_QWORD *)this + 3) = v10;
    }
  }
  else
  {
    if ((void **)v10 != v11)
    {
      do
      {
        operator delete(*(void **)(v10 - 8));
        v23 = *((_QWORD *)this + 2);
        v10 = *((_QWORD *)this + 3) - 8;
        *((_QWORD *)this + 3) = v10;
      }
      while (v10 != v23);
    }
    *((_QWORD *)this + 5) = 0;
    v11 = (void **)v10;
  }
  v24 = (void *)*((_QWORD *)this + 1);
  v25 = v10 - (_QWORD)v11;
  v26 = (v10 - (uint64_t)v11) >> 3;
  if (v26 < (uint64_t)(*((_QWORD *)this + 4) - (_QWORD)v24) >> 3)
  {
    if ((void **)v10 == v11)
    {
      v27 = 0;
      v10 = 8 * v26;
      goto LABEL_51;
    }
    if (v25 < 0)
      goto LABEL_80;
    v27 = operator new(v10 - (_QWORD)v11);
    v10 = (uint64_t)&v27[v26];
    if ((unint64_t)(v25 - 8) < 0x18 || (unint64_t)((char *)v27 - (char *)v11) < 0x20)
    {
      v31 = v27;
      v32 = v11;
    }
    else
    {
      v28 = 0;
      v29 = ((unint64_t)(v25 - 8) >> 3) + 1;
      v30 = v29 & 0x3FFFFFFFFFFFFFFCLL;
      v31 = &v27[v30];
      v32 = &v11[v30];
      v33 = v29 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v34 = &v27[v28];
        v35 = *(_OWORD *)&v11[v28 + 2];
        *v34 = *(_OWORD *)&v11[v28];
        v34[1] = v35;
        v28 += 4;
        v33 -= 4;
      }
      while (v33);
      if (v29 == (v29 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_51:
        *((_QWORD *)this + 1) = v27;
        *((_QWORD *)this + 2) = v27;
        v11 = (void **)v27;
        *((_QWORD *)this + 3) = v10;
        *((_QWORD *)this + 4) = v10;
        if (v24)
        {
          operator delete(v24);
          v11 = (void **)*((_QWORD *)this + 2);
          v10 = *((_QWORD *)this + 3);
        }
        goto LABEL_53;
      }
    }
    do
    {
      v36 = (uint64_t)*v32++;
      *v31++ = v36;
    }
    while (v31 != (_QWORD *)v10);
    goto LABEL_51;
  }
LABEL_53:
  if ((void **)v10 == v11)
  {
    v37 = v10;
  }
  else
  {
    v10 += ((unint64_t)v11 - v10 + 7) & 0xFFFFFFFFFFFFFFF8;
    *((_QWORD *)this + 3) = v10;
    v37 = (uint64_t)v11;
  }
  v38 = (void *)*((_QWORD *)this + 1);
  v39 = v10 - v37;
  v40 = (v10 - v37) >> 3;
  if (v40 < (uint64_t)(*((_QWORD *)this + 4) - (_QWORD)v38) >> 3)
  {
    if ((void **)v10 == v11)
    {
      v41 = 0;
      v42 = 8 * v40;
      goto LABEL_68;
    }
    if ((v39 & 0x8000000000000000) == 0)
    {
      v41 = operator new(v10 - v37);
      v42 = (uint64_t)&v41[v40];
      if ((unint64_t)(v39 - 8) < 0x18 || (unint64_t)((char *)v41 - (char *)v11) < 0x20)
      {
        v46 = v41;
        v47 = v11;
      }
      else
      {
        v43 = 0;
        v44 = ((unint64_t)(v39 - 8) >> 3) + 1;
        v45 = v44 & 0x3FFFFFFFFFFFFFFCLL;
        v46 = &v41[v45];
        v47 = &v11[v45];
        v48 = v44 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v49 = &v41[v43];
          v50 = *(_OWORD *)&v11[v43 + 2];
          *v49 = *(_OWORD *)&v11[v43];
          v49[1] = v50;
          v43 += 4;
          v48 -= 4;
        }
        while (v48);
        if (v44 == (v44 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_68:
          *((_QWORD *)this + 1) = v41;
          *((_QWORD *)this + 2) = v41;
          *((_QWORD *)this + 3) = v42;
          *((_QWORD *)this + 4) = v42;
          if (v38)
            operator delete(v38);
          goto LABEL_70;
        }
      }
      do
      {
        v51 = (uint64_t)*v47++;
        *v46++ = v51;
      }
      while (v46 != (_QWORD *)v42);
      goto LABEL_68;
    }
LABEL_80:
    std::__throw_bad_array_new_length[abi:sn180100]();
  }
LABEL_70:
  v52 = v60;
  *(_OWORD *)((char *)this + 8) = v59;
  *(_OWORD *)((char *)this + 24) = v52;
  v59 = 0u;
  v60 = 0u;
  *(_OWORD *)((char *)this + 40) = v61;
  v61 = 0uLL;
  _ZNSt3__15dequeIN4absl12AnyInvocableIFvvOEEENS_9allocatorIS4_EEED2B8sn180100Ev((void **)&v59);
  v53 = (void **)((char *)this + 56);
  v54 = *((_QWORD *)this + 7);
  if (v54)
  {
    v55 = *((_QWORD *)this + 8);
    v56 = (void *)*((_QWORD *)this + 7);
    if (v55 != v54)
    {
      do
      {
        v57 = v55 - 56;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(v55 - 16))(1, v55 - 32, v55 - 32);
        v55 = v57;
      }
      while (v57 != v54);
      v56 = *v53;
    }
    *((_QWORD *)this + 8) = v54;
    operator delete(v56);
  }
  *v53 = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *v8 = v9;
}

uint64_t rtc::Thread::socketserver(rtc::Thread *this)
{
  return *((_QWORD *)this + 21);
}

uint64_t rtc::Thread::Quit(rtc::Thread *this)
{
  atomic_store(1u, (unsigned int *)this + 41);
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 21) + 40))(*((_QWORD *)this + 21));
}

BOOL rtc::Thread::IsQuitting(rtc::Thread *this)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)this + 41);
  return v1 != 0;
}

uint64_t rtc::Thread::Restart(uint64_t this)
{
  atomic_store(0, (unsigned int *)(this + 164));
  return this;
}

void rtc::Thread::Get(rtc::Thread *this, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 *v17;
  __int128 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 *v22;
  __int128 v23;
  __int128 *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __int128 *v30;
  __int128 v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  __int128 *v37;
  __int128 v38;
  _QWORD *v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int64x2_t v47;
  uint64_t v49;
  pthread_mutex_t *v50;
  uint64_t v51;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  __int128 v56;
  int v57;
  _BYTE v58[16];
  __int128 v59;
  __int128 v60;
  unsigned int v61;
  _BYTE v62[16];
  __int128 v63;

  if (rtc::g_clock)
  {
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v4 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
       / dword_253EA791C;
  }
  v5 = 0;
  v6 = (pthread_mutex_t *)(a2 + 96);
  v53 = a2;
  v54 = a2 + 8;
  v49 = v4 / 1000000;
  v50 = (pthread_mutex_t *)(a2 + 96);
  v7 = v4 / 1000000;
  while (1)
  {
    v51 = v5;
    pthread_mutex_lock(v6);
    v8 = *(_QWORD *)(a2 + 56);
    if (v8 != *(_QWORD *)(a2 + 64))
    {
      v55 = v7;
      while (1)
      {
        v9 = *(_QWORD *)(v8 + 8);
        v10 = v9 - v7;
        if (v9 > v7)
          goto LABEL_45;
        v11 = *(_QWORD *)(a2 + 16);
        v12 = *(_QWORD *)(a2 + 24);
        v13 = 16 * (v12 - v11) - 1;
        if (v12 == v11)
          v13 = 0;
        if (v13 == *(_QWORD *)(a2 + 48) + *(_QWORD *)(a2 + 40))
        {
          _ZNSt3__15dequeIN4absl12AnyInvocableIFvvOEEENS_9allocatorIS4_EEE19__add_back_capacityEv(v54);
          v11 = *(_QWORD *)(a2 + 16);
          v12 = *(_QWORD *)(a2 + 24);
        }
        if (v12 == v11)
          goto LABEL_71;
        v14 = *(_QWORD *)(a2 + 48) + *(_QWORD *)(a2 + 40);
        v15 = *(_QWORD *)(v11 + ((v14 >> 4) & 0xFFFFFFFFFFFFFF8));
        if (!v15)
          goto LABEL_71;
        v16 = v15 + 32 * (v14 & 0x7F);
        (*(void (**)(_QWORD, uint64_t, uint64_t))(v8 + 40))(0, v8 + 24, v16);
        *(_OWORD *)(v16 + 16) = *(_OWORD *)(v8 + 40);
        *(_QWORD *)(v8 + 40) = absl::internal_any_invocable::EmptyManager;
        *(_QWORD *)(v8 + 48) = 0;
        v17 = *(__int128 **)(a2 + 56);
        ++*(_QWORD *)(a2 + 48);
        v18 = *(__int128 **)(a2 + 64);
        v19 = (char *)v18 - (char *)v17;
        if ((char *)v18 - (char *)v17 <= 0)
          goto LABEL_71;
        if (v19 != 56)
          break;
LABEL_38:
        if (v17 == v18)
          goto LABEL_71;
        (*((void (**)(uint64_t, __int128 *, __int128 *))v18 - 2))(1, v18 - 2, v18 - 2);
        *(_QWORD *)(a2 + 64) = (char *)v18 - 56;
        v8 = *(_QWORD *)(a2 + 56);
        if ((__int128 *)v8 == (__int128 *)((char *)v18 - 56))
          goto LABEL_44;
      }
      v20 = 0x6DB6DB6DB6DB6DB7 * (v19 >> 3);
      v57 = *((_DWORD *)v17 + 4);
      v56 = *v17;
      (*((void (**)(_QWORD, uint64_t, _BYTE *))v17 + 5))(0, (uint64_t)v17 + 24, v58);
      v21 = 0;
      v59 = *(__int128 *)((char *)v17 + 40);
      *((_QWORD *)v17 + 5) = absl::internal_any_invocable::EmptyManager;
      *((_QWORD *)v17 + 6) = 0;
      v22 = v17;
      do
      {
        v24 = v22;
        v25 = v21 + 1;
        v22 = (__int128 *)((char *)v22 + 56 * v21 + 56);
        v26 = 2 * v21;
        v21 = (2 * v21) | 1;
        v27 = v26 + 2;
        if (v27 < v20)
        {
          v28 = *((_QWORD *)v22 + 8);
          v29 = *((_QWORD *)v24 + 7 * v25 + 1);
          if (v28 < v29 || v28 == v29 && *((_DWORD *)v22 + 18) < *((_DWORD *)v24 + 14 * v25 + 4))
          {
            v22 = (__int128 *)((char *)v22 + 56);
            v21 = v27;
          }
        }
        v23 = *v22;
        *((_DWORD *)v24 + 4) = *((_DWORD *)v22 + 4);
        *v24 = v23;
        *((_QWORD *)v24 + 5) = absl::internal_any_invocable::EmptyManager;
        *((_QWORD *)v24 + 6) = 0;
        (*((void (**)(_QWORD, uint64_t, uint64_t))v22 + 5))(0, (uint64_t)v22 + 24, (uint64_t)v24 + 24);
        *(__int128 *)((char *)v24 + 40) = *(__int128 *)((char *)v22 + 40);
        *((_QWORD *)v22 + 5) = absl::internal_any_invocable::EmptyManager;
        *((_QWORD *)v22 + 6) = 0;
      }
      while (v21 <= (uint64_t)((unint64_t)(v20 - 2) >> 1));
      v30 = (__int128 *)((char *)v18 - 56);
      if (v22 == (__int128 *)((char *)v18 - 56))
      {
        *((_DWORD *)v22 + 4) = v57;
        *v22 = v56;
        *((_QWORD *)v22 + 5) = absl::internal_any_invocable::EmptyManager;
        *((_QWORD *)v22 + 6) = 0;
        ((void (*)(_QWORD, _BYTE *, char *))v59)(0, v58, (char *)v22 + 24);
        *(__int128 *)((char *)v22 + 40) = v59;
        v59 = (unint64_t)absl::internal_any_invocable::EmptyManager;
        v7 = v55;
      }
      else
      {
        v31 = *v30;
        *((_DWORD *)v22 + 4) = *((_DWORD *)v18 - 10);
        *v22 = v31;
        *((_QWORD *)v22 + 5) = absl::internal_any_invocable::EmptyManager;
        *((_QWORD *)v22 + 6) = 0;
        (*((void (**)(_QWORD, __int128 *, uint64_t))v18 - 2))(0, v18 - 2, (uint64_t)v22 + 24);
        *(__int128 *)((char *)v22 + 40) = *(v18 - 1);
        *((_DWORD *)v18 - 10) = v57;
        *v30 = v56;
        *((_QWORD *)v18 - 2) = absl::internal_any_invocable::EmptyManager;
        *((_QWORD *)v18 - 1) = 0;
        ((void (*)(_QWORD, _BYTE *, __int128 *))v59)(0, v58, v18 - 2);
        *(v18 - 1) = v59;
        v59 = (unint64_t)absl::internal_any_invocable::EmptyManager;
        v32 = (char *)v22 - (char *)v17 + 56;
        v7 = v55;
        if (v32 >= 57)
        {
          v33 = (v32 / 0x38uLL - 2) >> 1;
          v34 = *((_QWORD *)v22 + 1);
          v35 = *((_QWORD *)v17 + 7 * v33 + 1);
          if (v34 < v35 || v34 == v35 && *((_DWORD *)v22 + 4) < *((_DWORD *)v17 + 14 * v33 + 4))
          {
            v36 = *v22;
            v61 = *((_DWORD *)v22 + 4);
            v60 = v36;
            (*((void (**)(_QWORD, uint64_t, _BYTE *))v22 + 5))(0, (uint64_t)v22 + 24, v62);
            v63 = *(__int128 *)((char *)v22 + 40);
            *((_QWORD *)v22 + 5) = absl::internal_any_invocable::EmptyManager;
            *((_QWORD *)v22 + 6) = 0;
            do
            {
              v37 = v22;
              v22 = (__int128 *)((char *)v17 + 56 * v33);
              v38 = *v22;
              *((_DWORD *)v37 + 4) = *((_DWORD *)v22 + 4);
              *v37 = v38;
              *((_QWORD *)v37 + 5) = absl::internal_any_invocable::EmptyManager;
              *((_QWORD *)v37 + 6) = 0;
              v39 = (_QWORD *)v22 + 5;
              (*((void (**)(_QWORD, uint64_t, uint64_t))v22 + 5))(0, (uint64_t)v22 + 24, (uint64_t)v37 + 24);
              *(__int128 *)((char *)v37 + 40) = *(__int128 *)((char *)v22 + 40);
              *((_QWORD *)v22 + 6) = 0;
              *((_QWORD *)v22 + 5) = absl::internal_any_invocable::EmptyManager;
              if (!v33)
                break;
              v33 = (v33 - 1) >> 1;
              v40 = *((_QWORD *)v17 + 7 * v33 + 1);
            }
            while (*((uint64_t *)&v60 + 1) < v40
                 || *((_QWORD *)&v60 + 1) == v40 && v61 < *((_DWORD *)v17 + 14 * v33 + 4));
            v41 = v60;
            *((_DWORD *)v22 + 4) = v61;
            *v22 = v41;
            *v39 = absl::internal_any_invocable::EmptyManager;
            *((_QWORD *)v22 + 6) = 0;
            ((void (*)(_QWORD, _BYTE *, char *))v63)(0, v62, (char *)v22 + 24);
            *(_OWORD *)v39 = v63;
            ((void (*)(uint64_t, _BYTE *, _BYTE *))v59)(1, v58, v58);
            goto LABEL_37;
          }
        }
      }
      absl::internal_any_invocable::EmptyManager(1, v58, v58);
LABEL_37:
      a2 = v53;
      v17 = *(__int128 **)(v53 + 56);
      v18 = *(__int128 **)(v53 + 64);
      goto LABEL_38;
    }
LABEL_44:
    v10 = -1;
LABEL_45:
    v6 = v50;
    if (*(_QWORD *)(a2 + 48))
      break;
    pthread_mutex_unlock(v50);
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 48))(a2) & 1) != 0)
      goto LABEL_66;
    if (a3 == -1)
    {
      v43 = *(_QWORD *)(a2 + 168);
      if (v10 == -1)
      {
        if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v43 + 32))(v43, 0x7FFFFFFFFFFFFFFFLL, 1) & 1) == 0)goto LABEL_66;
        goto LABEL_57;
      }
    }
    else
    {
      if (v10 >= ((a3 - v51) & ~((a3 - v51) >> 63)) || v10 == -1)
        v10 = (a3 - v51) & ~((a3 - v51) >> 63);
      v43 = *(_QWORD *)(a2 + 168);
    }
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v43 + 32))(v43, 1000 * v10, 1) & 1) == 0)
      goto LABEL_66;
LABEL_57:
    if (rtc::g_clock)
    {
      v44 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
    }
    else
    {
      if (!dword_253EA791C)
        mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
      v44 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
          / dword_253EA791C;
    }
    v7 = v44 / 1000000;
    v5 = v44 / 1000000 - v49;
    if (a3 != -1 && v5 >= a3)
    {
LABEL_66:
      *((_QWORD *)this + 2) = absl::internal_any_invocable::EmptyManager;
      *((_QWORD *)this + 3) = 0;
      return;
    }
  }
  v45 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + ((*(_QWORD *)(a2 + 40) >> 4) & 0xFFFFFFFFFFFFFF8))
      + 32 * (*(_QWORD *)(a2 + 40) & 0x7FLL);
  (*(void (**)(_QWORD, uint64_t, rtc::Thread *))(v45 + 16))(0, v45, this);
  *((_OWORD *)this + 1) = *(_OWORD *)(v45 + 16);
  *(_QWORD *)(v45 + 16) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(v45 + 24) = 0;
  v46 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + ((*(_QWORD *)(a2 + 40) >> 4) & 0xFFFFFFFFFFFFFF8));
  if (v46)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v46 + 32 * (*(_QWORD *)(a2 + 40) & 0x7FLL) + 16))(1, v46 + 32 * (*(_QWORD *)(a2 + 40) & 0x7FLL), v46 + 32 * (*(_QWORD *)(a2 + 40) & 0x7FLL));
    v47 = vaddq_s64(*(int64x2_t *)(a2 + 40), (int64x2_t)xmmword_208F0A010);
    *(int64x2_t *)(a2 + 40) = v47;
    if (v47.i64[0] >= 0x100uLL)
    {
      operator delete(**(void ***)(a2 + 16));
      *(_QWORD *)(a2 + 16) += 8;
      *(_QWORD *)(a2 + 40) -= 128;
    }
    pthread_mutex_unlock(v50);
  }
  else
  {
LABEL_71:
    __break(1u);
  }
}

void rtc::Thread::PostTaskImpl(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1) & 1) == 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
    v4 = *(_QWORD *)(a1 + 16);
    v5 = *(_QWORD *)(a1 + 24);
    v6 = 16 * (v5 - v4) - 1;
    if (v5 == v4)
      v6 = 0;
    if (v6 == *(_QWORD *)(a1 + 48) + *(_QWORD *)(a1 + 40))
    {
      _ZNSt3__15dequeIN4absl12AnyInvocableIFvvOEEENS_9allocatorIS4_EEE19__add_back_capacityEv(a1 + 8);
      v4 = *(_QWORD *)(a1 + 16);
      v5 = *(_QWORD *)(a1 + 24);
    }
    if (v5 == v4
      || (v7 = *(_QWORD *)(a1 + 48) + *(_QWORD *)(a1 + 40),
          (v8 = *(_QWORD *)(v4 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8))) == 0))
    {
      __break(1u);
    }
    else
    {
      v9 = v8 + 32 * (v7 & 0x7F);
      (*(void (**)(_QWORD, uint64_t, uint64_t))(a2 + 16))(0, a2, v9);
      *(_OWORD *)(v9 + 16) = *(_OWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 16) = absl::internal_any_invocable::EmptyManager;
      *(_QWORD *)(a2 + 24) = 0;
      ++*(_QWORD *)(a1 + 48);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 96));
      (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 168) + 40))(*(_QWORD *)(a1 + 168));
    }
  }
}

uint64_t rtc::Thread::PostDelayedTaskImpl(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  pthread_mutex_t *v16;
  __int128 v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  uint64_t v32;
  char *v33;
  char *v34;
  __int128 v35;
  void (**v36)(uint64_t, uint64_t, uint64_t);
  void (**v37)(uint64_t, uint64_t, uint64_t);
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  __int128 v43;
  char *v44;
  __int128 v45;
  _QWORD *v46;
  uint64_t v47;
  __int128 v48;
  char *v49;
  void (*v50)(_QWORD, _BYTE *, char *);
  __int128 v51;
  int v52;
  _BYTE v53[16];
  __int128 v54;
  __int128 v55;
  unsigned int v56;
  uint64_t v57;
  __int128 v58;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
  if ((result & 1) != 0)
    return result;
  v7 = 1000 * ((a3 + 999) / 1000);
  v8 = (unint64_t)((((125 * ((a3 + 999) / 1000)) & 0x1FFFFFFFFFFFFFFFLL)
                         * (unsigned __int128)0x20C49BA5E353F7CFuLL) >> 64) >> 4;
  if (v7 - 1000 * v8 > 0x1F3)
    LODWORD(v8) = v8 + 1;
  v9 = (unint64_t)((((0x1FFFFFFFFFFFFF83 * ((a3 + 999) / 1000)) & 0x1FFFFFFFFFFFFFFFLL)
                         * (unsigned __int128)0x20C49BA5E353F7CFuLL) >> 64) >> 4;
  if (-1000 * ((a3 + 999) / 1000) - 1000 * v9 <= 0x1F4)
    v10 = 0;
  else
    v10 = -1;
  v11 = v10 - v9;
  if (v7 < 0)
    v12 = v11;
  else
    v12 = v8;
  v13 = v12;
  if (rtc::g_clock)
  {
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v14 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
        / dword_253EA791C;
  }
  v15 = v14 / 1000000 + v13;
  v16 = (pthread_mutex_t *)(a1 + 96);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  *(_QWORD *)&v51 = v13;
  *((_QWORD *)&v51 + 1) = v15;
  v52 = *(_DWORD *)(a1 + 88);
  (*(void (**)(_QWORD, uint64_t, _BYTE *))(a2 + 16))(0, a2, v53);
  v17 = *(_OWORD *)(a2 + 16);
  v54 = v17;
  *(_QWORD *)(a2 + 16) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(a2 + 24) = 0;
  v19 = *(_QWORD *)(a1 + 64);
  v18 = *(_QWORD *)(a1 + 72);
  if (v19 < v18)
  {
    if (v19)
    {
      *(_DWORD *)(v19 + 16) = v52;
      *(_OWORD *)v19 = v51;
      ((void (*)(_QWORD, _BYTE *, unint64_t))v54)(0, v53, v19 + 24);
      *(_OWORD *)(v19 + 40) = v54;
      v54 = (unint64_t)absl::internal_any_invocable::EmptyManager;
      v20 = (char *)(v19 + 56);
      goto LABEL_33;
    }
    goto LABEL_47;
  }
  v21 = *(_QWORD *)(a1 + 56);
  v22 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v19 - v21) >> 3);
  if ((unint64_t)(v22 + 1) > 0x492492492492492)
    goto LABEL_48;
  v23 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v18 - v21) >> 3);
  v24 = 2 * v23;
  if (2 * v23 <= v22 + 1)
    v24 = v22 + 1;
  if (v23 >= 0x249249249249249)
    v25 = 0x492492492492492;
  else
    v25 = v24;
  if (!v25)
  {
LABEL_47:
    __break(1u);
LABEL_48:
    abort();
  }
  v50 = (void (*)(_QWORD, _BYTE *, char *))v17;
  if (v25 > 0x492492492492492)
    std::__throw_bad_array_new_length[abi:sn180100]();
  v26 = 56 * v25;
  v27 = (char *)operator new(56 * v25);
  v28 = &v27[v26];
  v29 = &v27[56 * v22];
  *(_OWORD *)v29 = v51;
  *((_DWORD *)v29 + 4) = v52;
  v50(0, v53, v29 + 24);
  *(_OWORD *)(v29 + 40) = v54;
  v54 = (unint64_t)absl::internal_any_invocable::EmptyManager;
  v20 = v29 + 56;
  v30 = *(char **)(a1 + 56);
  v31 = *(char **)(a1 + 64);
  if (v31 != v30)
  {
    v49 = v28;
    v32 = 0;
    do
    {
      v33 = &v29[v32];
      v34 = &v31[v32];
      v35 = *(_OWORD *)&v31[v32 - 56];
      *((_DWORD *)v33 - 10) = *(_DWORD *)&v31[v32 - 40];
      *(_OWORD *)(v33 - 56) = v35;
      (*(void (**)(_QWORD, char *, char *))&v31[v32 - 16])(0, &v31[v32 - 32], &v29[v32 - 32]);
      *((_OWORD *)v33 - 1) = *(_OWORD *)&v31[v32 - 16];
      *((_QWORD *)v34 - 2) = absl::internal_any_invocable::EmptyManager;
      *((_QWORD *)v34 - 1) = 0;
      v32 -= 56;
    }
    while (&v31[v32] != v30);
    v31 = *(char **)(a1 + 56);
    v36 = *(void (***)(uint64_t, uint64_t, uint64_t))(a1 + 64);
    *(_QWORD *)(a1 + 56) = &v29[v32];
    *(_QWORD *)(a1 + 64) = v20;
    *(_QWORD *)(a1 + 72) = v49;
    v16 = (pthread_mutex_t *)(a1 + 96);
    if (v36 != (void (**)(uint64_t, uint64_t, uint64_t))v31)
    {
      do
      {
        v37 = v36 - 7;
        (*(v36 - 2))(1, (uint64_t)(v36 - 4), (uint64_t)(v36 - 4));
        v36 = v37;
      }
      while (v37 != (void (**)(uint64_t, uint64_t, uint64_t))v31);
    }
    if (!v31)
      goto LABEL_33;
    goto LABEL_32;
  }
  *(_QWORD *)(a1 + 56) = v29;
  *(_QWORD *)(a1 + 64) = v20;
  *(_QWORD *)(a1 + 72) = v28;
  if (v31)
LABEL_32:
    operator delete(v31);
LABEL_33:
  *(_QWORD *)(a1 + 64) = v20;
  v38 = *(_QWORD *)(a1 + 56);
  if ((uint64_t)&v20[-v38] >= 57)
  {
    v39 = ((unint64_t)&v20[-v38] / 0x38 - 2) >> 1;
    v40 = *((_QWORD *)v20 - 6);
    v41 = *(_QWORD *)(v38 + 56 * v39 + 8);
    if (v40 < v41 || v40 == v41 && *((_DWORD *)v20 - 10) < *(_DWORD *)(v38 + 56 * v39 + 16))
    {
      v42 = v20 - 56;
      v43 = *(_OWORD *)(v20 - 56);
      v56 = *((_DWORD *)v20 - 10);
      v55 = v43;
      (*((void (**)(_QWORD, char *))v20 - 2))(0, v20 - 32);
      v58 = *((_OWORD *)v20 - 1);
      *((_QWORD *)v20 - 2) = absl::internal_any_invocable::EmptyManager;
      *((_QWORD *)v20 - 1) = 0;
      do
      {
        v44 = v42;
        v42 = (char *)(v38 + 56 * v39);
        v45 = *(_OWORD *)v42;
        *((_DWORD *)v44 + 4) = *((_DWORD *)v42 + 4);
        *(_OWORD *)v44 = v45;
        (*((void (**)(uint64_t, char *, char *))v44 + 5))(1, v44 + 24, v44 + 24);
        *((_QWORD *)v44 + 5) = absl::internal_any_invocable::EmptyManager;
        *((_QWORD *)v44 + 6) = 0;
        v46 = v42 + 40;
        (*((void (**)(_QWORD, char *, char *))v42 + 5))(0, v42 + 24, v44 + 24);
        *(_OWORD *)(v44 + 40) = *(_OWORD *)(v42 + 40);
        *((_QWORD *)v42 + 6) = 0;
        *((_QWORD *)v42 + 5) = absl::internal_any_invocable::EmptyManager;
        if (!v39)
          break;
        v39 = (v39 - 1) >> 1;
        v47 = *(_QWORD *)(v38 + 56 * v39 + 8);
      }
      while (*((uint64_t *)&v55 + 1) < v47 || *((_QWORD *)&v55 + 1) == v47 && v56 < *(_DWORD *)(v38 + 56 * v39 + 16));
      v48 = v55;
      *((_DWORD *)v42 + 4) = v56;
      *(_OWORD *)v42 = v48;
      *v46 = absl::internal_any_invocable::EmptyManager;
      *((_QWORD *)v42 + 6) = 0;
      ((void (*)(_QWORD, uint64_t *, char *))v58)(0, &v57, v42 + 24);
      *(_OWORD *)v46 = v58;
    }
  }
  ((void (*)(uint64_t, _BYTE *, _BYTE *))v54)(1, v53, v53);
  ++*(_DWORD *)(a1 + 88);
  pthread_mutex_unlock(v16);
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 168) + 40))(*(_QWORD *)(a1 + 168));
}

uint64_t rtc::Thread::GetDelay(rtc::Thread *this)
{
  pthread_mutex_t *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = (pthread_mutex_t *)((char *)this + 96);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 96));
  if (*((_QWORD *)this + 6))
  {
    pthread_mutex_unlock(v2);
    return 0;
  }
  else
  {
    v4 = *((_QWORD *)this + 7);
    if (v4 == *((_QWORD *)this + 8))
    {
      pthread_mutex_unlock(v2);
      return 0xFFFFFFFFLL;
    }
    else
    {
      v5 = *(_QWORD *)(v4 + 8);
      if (rtc::g_clock)
      {
        LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
      }
      else
      {
        if (!dword_253EA791C)
          mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
        v6 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
           / dword_253EA791C;
      }
      v7 = ((int)v6 / -1000000 + (_DWORD)v5) & ~(((int)v6 / -1000000 + (int)v5) >> 31);
      pthread_mutex_unlock(v2);
      return v7;
    }
  }
}

void rtc::Thread::Dispatch(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (rtc::g_clock)
  {
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v4 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
       / dword_253EA791C;
  }
  v5 = v4 / -1000000;
  (*(void (**)(uint64_t))(a2 + 24))(a2);
  if (rtc::g_clock)
  {
    v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v6 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
       / dword_253EA791C;
  }
  v7 = v6 / 1000000 + v5;
  if (v7 >= *(int *)(a1 + 232))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v8, v9, v10, v11, v12, v13, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/thread.cc");
    *(_DWORD *)(a1 + 232) = v7 + 1;
  }
}

BOOL rtc::Thread::IsCurrent(rtc::Thread *this)
{
  unsigned __int8 v2;
  _QWORD *v3;
  uint64_t v5;
  pthread_mutexattr_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v3 = &unk_253EA7000;
  {
    v5 = operator new();
    *(_QWORD *)(v5 + 8) = 0;
    *(_QWORD *)(v5 + 16) = 0;
    *(_QWORD *)v5 = 0;
    pthread_mutexattr_init(&v6);
    pthread_mutexattr_setpolicy_np(&v6, 3);
    pthread_mutex_init((pthread_mutex_t *)(v5 + 24), &v6);
    pthread_mutexattr_destroy(&v6);
    InitCocoaMultiThreading();
    pthread_key_create((pthread_key_t *)(v5 + 88), 0);
    rtc::ThreadManager::Instance(void)::thread_manager = v5;
    v3 = (_QWORD *)&unk_253EA7000;
  }
  return pthread_getspecific(*(_QWORD *)(v3[292] + 88)) == this;
}

uint64_t rtc::Thread::CreateWithSocketServer@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  rtc::Signaler *v5;
  uint64_t result;
  pthread_mutexattr_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v3 = operator new();
  v4 = operator new();
  *(_QWORD *)v4 = &off_24C0BA760;
  *(_QWORD *)(v4 + 8) = 0;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_QWORD *)(v4 + 48) = 0;
  *(_DWORD *)(v4 + 56) = 1065353216;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_DWORD *)(v4 + 96) = 1065353216;
  *(_QWORD *)(v4 + 112) = 0;
  *(_QWORD *)(v4 + 120) = 0;
  *(_QWORD *)(v4 + 104) = 0;
  pthread_mutexattr_init(&v7);
  pthread_mutexattr_settype(&v7, 2);
  pthread_mutexattr_setpolicy_np(&v7, 3);
  pthread_mutex_init((pthread_mutex_t *)(v4 + 136), &v7);
  pthread_mutexattr_destroy(&v7);
  *(_WORD *)(v4 + 216) = 0;
  v5 = (rtc::Signaler *)operator new();
  *(_QWORD *)(v4 + 128) = rtc::Signaler::Signaler(v5, (rtc::PhysicalSocketServer *)v4, (BOOL *)(v4 + 216));
  rtc::Thread::Thread((_BYTE *)v3, v4, 1);
  result = *(_QWORD *)(v3 + 176);
  *(_QWORD *)(v3 + 176) = v4;
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  *a1 = v3;
  return result;
}

uint64_t rtc::Thread::Create@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t result;

  v3 = operator new();
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C0B7990;
  v4[1] = 0;
  rtc::Event::Event((rtc::Event *)(v4 + 2), 0, 0);
  rtc::Thread::Thread((_BYTE *)v3, (uint64_t)v4, 1);
  result = *(_QWORD *)(v3 + 176);
  *(_QWORD *)(v3 + 176) = v4;
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  *a1 = v3;
  return result;
}

BOOL rtc::Thread::SleepMs(rtc::Thread *this)
{
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  timespec __rqtp;
  const char *v12;
  int v13;
  int v14;
  int v15;

  __rqtp.tv_sec = (int)this / 1000;
  __rqtp.tv_nsec = 1000000 * ((int)this % 1000);
  v1 = nanosleep(&__rqtp, 0);
  if (v1 && (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
  {
    v2 = *__error();
    v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/thread.cc";
    v13 = 4514;
    v14 = 1;
    v15 = v2;
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)14,rtc::webrtc_logging_impl::LogMetadataErr>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)14,rtc::webrtc_logging_impl::LogMetadataErr>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v3, v4, v5, v6, v7, v8, v9, (uint64_t)&v12);
  }
  return v1 == 0;
}

BOOL rtc::Thread::Start(rtc::Thread *this)
{
  pthread_t *v1;
  _BOOL8 v2;
  unsigned __int8 v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  rtc::ThreadManager *v14;
  pthread_attr_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v1 = (pthread_t *)((char *)this + 208);
  if (*((_QWORD *)this + 26))
    return 0;
  (*(void (**)(rtc::Thread *))(*(_QWORD *)this + 56))(this);
  {
    v14 = (rtc::ThreadManager *)operator new();
    rtc::ThreadManager::Instance(void)::thread_manager = (uint64_t)rtc::ThreadManager::ThreadManager(v14);
  }
  *((_BYTE *)this + 216) = 1;
  pthread_attr_init(&v15);
  v5 = pthread_create(v1, &v15, (void *(__cdecl *)(void *))rtc::Thread::PreRun, this);
  v2 = v5 == 0;
  if (v5)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/thread.cc");
    *v1 = 0;
  }
  return v2;
}

uint64_t rtc::Thread::PreRun(rtc::Thread *this, void *a2)
{
  unsigned __int8 v3;
  const char *v4;
  uint64_t v5;
  void *v6;
  unsigned __int8 v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  pthread_mutexattr_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  {
    v15 = operator new();
    *(_QWORD *)(v15 + 8) = 0;
    *(_QWORD *)(v15 + 16) = 0;
    *(_QWORD *)v15 = 0;
    pthread_mutexattr_init(&v17);
    pthread_mutexattr_setpolicy_np(&v17, 3);
    pthread_mutex_init((pthread_mutex_t *)(v15 + 24), &v17);
    pthread_mutexattr_destroy(&v17);
    InitCocoaMultiThreading();
    pthread_key_create((pthread_key_t *)(v15 + 88), 0);
    rtc::ThreadManager::Instance(void)::thread_manager = v15;
  }
  rtc::ThreadManager::SetCurrentThread((rtc::ThreadManager *)rtc::ThreadManager::Instance(void)::thread_manager, this);
  v4 = (char *)this + 184;
  if (*((char *)this + 207) < 0)
    v4 = *(const char **)v4;
  v5 = pthread_setname_np(v4);
  v6 = (void *)MEMORY[0x20BD0B284](v5);
  (*(void (**)(rtc::Thread *))(*(_QWORD *)this + 88))(this);
  {
    v16 = operator new();
    *(_QWORD *)(v16 + 8) = 0;
    *(_QWORD *)(v16 + 16) = 0;
    *(_QWORD *)v16 = 0;
    pthread_mutexattr_init(&v17);
    pthread_mutexattr_setpolicy_np(&v17, 3);
    pthread_mutex_init((pthread_mutex_t *)(v16 + 24), &v17);
    pthread_mutexattr_destroy(&v17);
    InitCocoaMultiThreading();
    pthread_key_create((pthread_key_t *)(v16 + 88), 0);
    rtc::ThreadManager::Instance(void)::thread_manager = v16;
  }
  v8 = rtc::ThreadManager::Instance(void)::thread_manager;
  v9 = pthread_getspecific(*(_QWORD *)(rtc::ThreadManager::Instance(void)::thread_manager + 88));
  if (v9)
  {
    v10 = v9[28];
    v9[28] = 0;
    if (v10)
    {
      *v11 = v12;
      MEMORY[0x20BD0ADEC](v13, 0x60C4044C4A2DFLL);
    }
  }
  pthread_setspecific(*(_QWORD *)(v8 + 88), 0);
  objc_autoreleasePoolPop(v6);
  return 0;
}

void rtc::Thread::Run(rtc::Thread *this)
{
  rtc::Thread::ProcessMessages(this, -1);
}

uint64_t rtc::Thread::Stop(rtc::Thread *this)
{
  uint64_t result;
  rtc::Thread *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  atomic_store(1u, (unsigned int *)this + 41);
  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 21) + 40))(*((_QWORD *)this + 21));
  if (*((_QWORD *)this + 26))
  {
    v3 = (rtc::Thread *)rtc::Thread::Current((rtc::Thread *)result);
    if (v3
      && !*((_BYTE *)rtc::Thread::Current(v3) + 217)
      && (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      rtc::webrtc_logging_impl::Log("\r\t", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/thread.cc");
    }
    result = pthread_join(*((pthread_t *)this + 26), 0);
    *((_QWORD *)this + 26) = 0;
  }
  return result;
}

uint64_t rtc::Thread::BlockingCallImpl(rtc::Thread *a1, uint64_t a2, uint64_t (*a3)(uint64_t))
{
  uint64_t result;
  uint64_t v6;
  TimeDelta v7;
  TimeDelta v8;
  char v10;
  char v11;
  _QWORD v12[2];
  uint64_t (*v13)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v14)(_QWORD **);
  pthread_mutex_t v15;
  pthread_cond_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  result = (*(uint64_t (**)(rtc::Thread *))(*(_QWORD *)a1 + 48))(a1);
  if ((result & 1) == 0)
  {
    if (rtc::Thread::IsCurrent(a1))
    {
      return a3(a2);
    }
    else
    {
      rtc::Event::Event((rtc::Event *)&v15, 0, 0);
      v6 = operator new();
      *(_QWORD *)v6 = a2;
      *(_QWORD *)(v6 + 8) = a3;
      *(_QWORD *)(v6 + 24) = &v15;
      *(_BYTE *)(v6 + 16) = 1;
      v12[0] = v6;
      v13 = absl::internal_any_invocable::RemoteManagerNontrivial<rtc::Thread::BlockingCallImpl(rtc::FunctionView<void ()(void)>,webrtc::Location const&)::$_1>;
      v14 = absl::internal_any_invocable::RemoteInvoker<false,void,rtc::Thread::BlockingCallImpl(rtc::FunctionView<void ()(void)>,webrtc::Location const&)::$_1 &&>;
      (*(void (**)(rtc::Thread *, _QWORD *, char *, char *))(*(_QWORD *)a1 + 8))(a1, v12, &v11, &v10);
      v13(1, v12, v12);
      v7.var0 = 0x7FFFFFFFFFFFFFFFLL;
      v8.var0 = 3000000;
      rtc::Event::Wait((rtc::Event *)&v15, v7, v8);
      pthread_mutex_destroy(&v15);
      return pthread_cond_destroy(&v16);
    }
  }
  return result;
}

uint64_t rtc::Thread::Delete(rtc::Thread *this)
{
  (*(void (**)(rtc::Thread *))(*(_QWORD *)this + 80))(this);
  return (*(uint64_t (**)(rtc::Thread *))(*(_QWORD *)this + 32))(this);
}

uint64_t rtc::Thread::IsProcessingMessagesForTesting(rtc::Thread *this)
{
  uint64_t result;

  if (*((_BYTE *)this + 216))
    return (*(unsigned int (**)(rtc::Thread *))(*(_QWORD *)this + 48))(this) ^ 1;
  result = rtc::Thread::IsCurrent(this);
  if ((_DWORD)result)
    return (*(unsigned int (**)(rtc::Thread *))(*(_QWORD *)this + 48))(this) ^ 1;
  return result;
}

void **_ZNSt3__15dequeIN4absl12AnyInvocableIFvvOEEENS_9allocatorIS4_EEED2B8sn180100Ev(void **result)
{
  void **v1;
  void **v2;
  void **v3;
  unint64_t v4;
  void **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  void *v12;
  _BYTE *v13;
  _BYTE *v14;

  v1 = result;
  v2 = (void **)result[1];
  v3 = (void **)result[2];
  if (v3 == v2)
  {
    v3 = (void **)result[1];
    result[5] = 0;
    v9 = 0;
    goto LABEL_11;
  }
  v4 = (unint64_t)result[4];
  v5 = &v2[v4 >> 7];
  v6 = (uint64_t)*v5 + 32 * (v4 & 0x7F);
  v7 = *(uint64_t *)((char *)v2 + ((((unint64_t)result[5] + v4) >> 4) & 0xFFFFFFFFFFFFFF8))
     + 32 * (((unint64_t)result[5] + v4) & 0x7F);
  if (v6 == v7)
  {
LABEL_9:
    v1[5] = 0;
    v9 = (char *)v3 - (char *)v2;
    if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
    {
      do
      {
        operator delete(*v2);
        v3 = (void **)v1[2];
        v2 = (void **)((char *)v1[1] + 8);
        v1[1] = v2;
        v9 = (char *)v3 - (char *)v2;
      }
      while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
    }
LABEL_11:
    v10 = v9 >> 3;
    if (v10 == 1)
    {
      v11 = 64;
    }
    else
    {
      if (v10 != 2)
        goto LABEL_17;
      v11 = 128;
    }
    v1[4] = (void *)v11;
LABEL_17:
    if (v2 != v3)
    {
      do
      {
        v12 = *v2++;
        operator delete(v12);
      }
      while (v2 != v3);
      v14 = v1[1];
      v13 = v1[2];
      if (v13 != v14)
        v1[2] = &v13[(v14 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
    }
    if (*v1)
      operator delete(*v1);
    return v1;
  }
  while (v6)
  {
    result = (void **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 16))(1, v6, v6);
    v6 += 32;
    if (v6 - (_QWORD)*v5 == 4096)
    {
      v8 = (uint64_t)v5[1];
      ++v5;
      v6 = v8;
    }
    if (v6 == v7)
    {
      v2 = (void **)v1[1];
      v3 = (void **)v1[2];
      goto LABEL_9;
    }
  }
  __break(1u);
  return result;
}

void _ZNSt3__15dequeIN4absl12AnyInvocableIFvvOEEENS_9allocatorIS4_EEE19__add_back_capacityEv(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  void *v20;
  void *v21;
  unint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  int64_t v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  BOOL v41;
  int64_t v42;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  char *v55;
  int64_t v56;
  unint64_t v57;
  char *v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  __int128 *v62;
  char *v63;
  uint64_t v64;
  __int128 v65;
  uint64_t v66;
  char *v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  char *v71;
  char *v72;
  int64_t v73;
  unint64_t v74;
  char *v75;
  char *v76;
  uint64_t v77;
  uint64_t v78;
  __int128 *v79;
  _OWORD *v80;
  uint64_t v81;
  __int128 v82;
  uint64_t v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  __int128 *v87;
  _OWORD *v88;
  uint64_t v89;
  __int128 v90;
  uint64_t v91;
  void *v92;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x80;
  v4 = v2 - 128;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_4;
    v27 = *(char **)a1;
    v28 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 > *(_QWORD *)a1)
    {
LABEL_23:
      v29 = v28 >> 3;
      if (v29 >= -1)
        v30 = v29 + 1;
      else
        v30 = v29 + 2;
      v31 = v30 >> 1;
      v32 = -v31;
      v33 = &v7[-8 * v31];
      v34 = v5 - v7;
      if (v5 != v7)
      {
        memmove(&v7[-8 * v31], v7, v5 - v7);
        v7 = *(char **)(a1 + 8);
      }
      v5 = &v33[v34];
      *(_QWORD *)(a1 + 8) = &v7[8 * v32];
      *(_QWORD *)(a1 + 16) = &v33[v34];
LABEL_31:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v36 = (v5 - v27) >> 2;
    if (v5 == v27)
      v36 = 1;
    if (v36 >> 61)
      goto LABEL_86;
    v37 = v36 >> 2;
    v38 = 8 * v36;
    v39 = (char *)operator new(8 * v36);
    v40 = &v39[8 * v37];
    v42 = v5 - v7;
    v41 = v5 == v7;
    v5 = v40;
    if (!v41)
    {
      v5 = &v40[v42 & 0xFFFFFFFFFFFFFFF8];
      v43 = v42 - 8;
      if ((unint64_t)(v42 - 8) < 0x38)
      {
        v44 = &v39[8 * v37];
        do
        {
LABEL_76:
          v83 = *(_QWORD *)v7;
          v7 += 8;
          *(_QWORD *)v44 = v83;
          v44 += 8;
        }
        while (v44 != v5);
        goto LABEL_77;
      }
      v76 = &v39[8 * v37];
      v44 = v76;
      if ((unint64_t)(v76 - v7) < 0x20)
        goto LABEL_76;
      v77 = (v43 >> 3) + 1;
      v78 = 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
      v44 = &v40[v78];
      v7 += v78;
      v79 = (__int128 *)(v6 + 3);
      v80 = v76 + 16;
      v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v82 = *v79;
        *(v80 - 1) = *(v79 - 1);
        *v80 = v82;
        v79 += 2;
        v80 += 2;
        v81 -= 4;
      }
      while (v81);
      if (v77 != (v77 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_76;
    }
LABEL_77:
    *(_QWORD *)a1 = v39;
    *(_QWORD *)(a1 + 8) = v40;
    *(_QWORD *)(a1 + 16) = v5;
    *(_QWORD *)(a1 + 24) = &v39[v38];
    if (v27)
    {
      operator delete(v27);
      v5 = *(char **)(a1 + 16);
    }
LABEL_4:
    if (!v5)
      goto LABEL_5;
    goto LABEL_31;
  }
  while (1)
  {
    v10 = *(_QWORD *)(a1 + 16);
    v9 = *(_QWORD *)(a1 + 24);
    v11 = *(_QWORD *)(a1 + 8);
    v12 = v10 - v11;
    v13 = (v10 - v11) >> 3;
    v14 = v9 - *(_QWORD *)a1;
    if (v13 >= (unint64_t)(v14 >> 3))
      break;
    if (v9 != v10)
    {
      v92 = operator new(0x1000uLL);
      std::__split_buffer<std::unique_ptr<webrtc::RtpFrameObject> *,std::allocator<std::unique_ptr<webrtc::RtpFrameObject> *>>::push_back((char **)a1, &v92);
      return;
    }
    v92 = operator new(0x1000uLL);
    std::__split_buffer<std::unique_ptr<webrtc::RtpFrameObject> *,std::allocator<std::unique_ptr<webrtc::RtpFrameObject> *>>::push_front((void **)a1, &v92);
    v35 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v35 + 1);
    v8 = *v35;
    *(_QWORD *)(a1 + 8) = v35 + 1;
    if (v5 == *(char **)(a1 + 24))
    {
      v67 = *(char **)a1;
      v28 = (uint64_t)&v7[-*(_QWORD *)a1];
      if ((unint64_t)v7 > *(_QWORD *)a1)
        goto LABEL_23;
      v68 = (v5 - v67) >> 2;
      if (v5 == v67)
        v68 = 1;
      if (v68 >> 61)
        goto LABEL_86;
      v69 = v68 >> 2;
      v70 = 8 * v68;
      v71 = (char *)operator new(8 * v68);
      v72 = &v71[8 * v69];
      v73 = v5 - v7;
      v41 = v5 == v7;
      v5 = v72;
      if (!v41)
      {
        v5 = &v72[v73 & 0xFFFFFFFFFFFFFFF8];
        v74 = v73 - 8;
        if ((unint64_t)(v73 - 8) < 0x38)
        {
          v75 = &v71[8 * v69];
          goto LABEL_83;
        }
        v84 = &v71[8 * v69];
        v75 = v84;
        if ((unint64_t)(v84 - v7) < 0x20)
          goto LABEL_89;
        v85 = (v74 >> 3) + 1;
        v86 = 8 * (v85 & 0x3FFFFFFFFFFFFFFCLL);
        v75 = &v72[v86];
        v7 += v86;
        v87 = (__int128 *)(v35 + 3);
        v88 = v84 + 16;
        v89 = v85 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v90 = *v87;
          *(v88 - 1) = *(v87 - 1);
          *v88 = v90;
          v87 += 2;
          v88 += 2;
          v89 -= 4;
        }
        while (v89);
        if (v85 != (v85 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_89:
          do
          {
LABEL_83:
            v91 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v75 = v91;
            v75 += 8;
          }
          while (v75 != v5);
        }
      }
      *(_QWORD *)a1 = v71;
      *(_QWORD *)(a1 + 8) = v72;
      *(_QWORD *)(a1 + 16) = v5;
      *(_QWORD *)(a1 + 24) = &v71[v70];
      if (v67)
      {
        operator delete(v67);
        v5 = *(char **)(a1 + 16);
      }
    }
    if (v5)
      goto LABEL_31;
LABEL_5:
    __break(1u);
  }
  v15 = v14 >> 2;
  if (v9 == *(_QWORD *)a1)
    v16 = 1;
  else
    v16 = v15;
  if (v16 >> 61)
    goto LABEL_86;
  v17 = (char *)operator new(8 * v16);
  v18 = &v17[8 * v13];
  v19 = &v17[8 * v16];
  v20 = operator new(0x1000uLL);
  v21 = v20;
  if (v13 != v16)
  {
LABEL_18:
    *(_QWORD *)v18 = v20;
    v23 = v18 + 8;
    if (v10 != v11)
      goto LABEL_46;
    goto LABEL_19;
  }
  if (v12 >= 1)
  {
    v22 = v13 + 2;
    if (v13 >= -1)
      v22 = v13 + 1;
    v18 -= 8 * (v22 >> 1);
    goto LABEL_18;
  }
  v45 = v12 >> 2;
  if (v10 == v11)
    v45 = 1;
  if (v45 >> 61)
LABEL_86:
    std::__throw_bad_array_new_length[abi:sn180100]();
  v46 = 8 * v45;
  v18 = (char *)operator new(8 * v45);
  operator delete(v17);
  v19 = &v18[v46];
  v47 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 16);
  v17 = v18;
  *(_QWORD *)v18 = v21;
  v23 = v18 + 8;
  if (v10 != v47)
  {
    while (1)
    {
LABEL_46:
      if (v18 == v17)
      {
        if (v23 >= v19)
        {
          v52 = (v19 - v18) >> 2;
          if (v19 == v18)
            v52 = 1;
          if (v52 >> 61)
            goto LABEL_86;
          v53 = (v52 + 3) >> 2;
          v54 = 8 * v52;
          v55 = (char *)operator new(8 * v52);
          v17 = v55;
          v48 = &v55[8 * v53];
          v25 = v48;
          v56 = v23 - v18;
          if (v23 != v18)
          {
            v25 = &v48[v56 & 0xFFFFFFFFFFFFFFF8];
            v57 = v56 - 8;
            v58 = &v55[8 * v53];
            v59 = v18;
            if (v57 < 0x38)
              goto LABEL_90;
            v58 = &v55[8 * v53];
            v59 = v18;
            if ((unint64_t)(v58 - v18) < 0x20)
              goto LABEL_90;
            v60 = (v57 >> 3) + 1;
            v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
            v58 = &v48[v61];
            v59 = &v18[v61];
            v62 = (__int128 *)(v18 + 16);
            v63 = &v55[8 * v53 + 16];
            v64 = v60 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v65 = *v62;
              *((_OWORD *)v63 - 1) = *(v62 - 1);
              *(_OWORD *)v63 = v65;
              v62 += 2;
              v63 += 32;
              v64 -= 4;
            }
            while (v64);
            if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_90:
              do
              {
                v66 = *(_QWORD *)v59;
                v59 += 8;
                *(_QWORD *)v58 = v66;
                v58 += 8;
              }
              while (v58 != v25);
            }
          }
          v19 = &v55[v54];
          operator delete(v18);
        }
        else
        {
          v50 = (v19 - v23) >> 3;
          if (v50 >= -1)
            v51 = v50 + 1;
          else
            v51 = v50 + 2;
          v25 = &v23[8 * (v51 >> 1)];
          v48 = &v18[8 * (v51 >> 1)];
          if (v23 == v18)
          {
            v17 = v23;
          }
          else
          {
            memmove(&v18[8 * (v51 >> 1)], v18, v23 - v18);
            v17 = v18;
          }
        }
      }
      else
      {
        v48 = v18;
        v25 = v23;
      }
      v49 = *(_QWORD *)(v10 - 8);
      v10 -= 8;
      *((_QWORD *)v48 - 1) = v49;
      v24 = v48 - 8;
      v23 = v25;
      v18 = v24;
      if (v10 == *(_QWORD *)(a1 + 8))
        goto LABEL_20;
    }
  }
LABEL_19:
  v24 = v18;
  v25 = v23;
LABEL_20:
  v26 = *(char **)a1;
  *(_QWORD *)a1 = v17;
  *(_QWORD *)(a1 + 8) = v24;
  *(_QWORD *)(a1 + 16) = v25;
  *(_QWORD *)(a1 + 24) = v19;
  if (v26)
    operator delete(v26);
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,rtc::Thread::SetDispatchWarningMs(int)::$_0 &&>(uint64_t a1)
{
  rtc::Thread *v1;
  int v2;
  uint64_t result;
  char v4;
  char v5;
  rtc::Thread *v6;
  int v7;
  __n128 (*v8)(uint64_t, __n128 *, __n128 *);
  uint64_t (*v9)();

  v1 = *(rtc::Thread **)a1;
  v2 = *(_DWORD *)(a1 + 8);
  result = rtc::Thread::IsCurrent(*(rtc::Thread **)a1);
  if ((result & 1) != 0)
  {
    *((_DWORD *)v1 + 58) = v2;
  }
  else
  {
    v6 = v1;
    v7 = v2;
    v8 = absl::internal_any_invocable::LocalManagerTrivial;
    v9 = absl::internal_any_invocable::LocalInvoker<false,void,rtc::Thread::SetDispatchWarningMs(int)::$_0 &&>;
    (*(void (**)(rtc::Thread *, rtc::Thread **, char *, char *))(*(_QWORD *)v1 + 8))(v1, &v6, &v5, &v4);
    return ((uint64_t (*)(uint64_t, rtc::Thread **, rtc::Thread **))v8)(1, &v6, &v6);
  }
  return result;
}

uint64_t absl::internal_any_invocable::RemoteInvoker<false,void,rtc::Thread::BlockingCallImpl(rtc::FunctionView<void ()(void)>,webrtc::Location const&)::$_1 &&>(_QWORD **a1)
{
  return ((uint64_t (*)(_QWORD))(*a1)[1])(**a1);
}

uint64_t absl::internal_any_invocable::RemoteManagerNontrivial<rtc::Thread::BlockingCallImpl(rtc::FunctionView<void ()(void)>,webrtc::Location const&)::$_1>(uint64_t result, uint64_t *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *a2;
  if ((result & 1) != 0)
  {
    if (v3)
    {
      if (*(_BYTE *)(v3 + 16))
      {
        v4 = *(_QWORD *)(v3 + 24);
        pthread_mutex_lock((pthread_mutex_t *)v4);
        *(_BYTE *)(v4 + 113) = 1;
        pthread_cond_broadcast((pthread_cond_t *)(v4 + 64));
        pthread_mutex_unlock((pthread_mutex_t *)v4);
        *(_BYTE *)(v3 + 16) = 0;
      }
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    *a3 = v3;
  }
  return result;
}

void webrtc::ThreeBandFilterBank::Analysis(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const float *v8;
  uint64_t v9;
  const float *v10;
  unsigned __int128 v11;
  unsigned __int128 v12;
  unsigned __int128 *v13;
  uint64_t v14;
  int v15;
  int v16;
  float32x4_t *v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v23;
  int v24;
  int v25;
  float *v26;
  _OWORD *v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float *v32;
  unint64_t v33;
  float v34;
  uint64_t v35;
  float *v36;
  unsigned int v37;
  float v38;
  unsigned int v39;
  float *v40;
  unint64_t v41;
  char *v42;
  float v43;
  const float *v44;
  const float *v45;
  const float *v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  uint64_t i;
  float32x4_t *v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  __int128 v58;
  const float *v59;
  float32x4_t v60;
  float32x4_t *v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t *v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t *v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  const float *v125;
  float32x4_t **v126;
  uint64_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  _BYTE v169[580];
  __int128 v170;
  __int128 v171;
  _BYTE v172[28];

  v4 = *(_QWORD *)(a3 + 8);
  if (v4 >= 1)
    bzero(*(void **)a3, 4 * (v4 - ((v4 & 0x3FFFFFFFFFFFFFFFLL) != 0)) + 4);
  v5 = *(_QWORD *)(a3 + 24);
  if (v5 >= 1)
    bzero(*(void **)(a3 + 16), 4 * (v5 - ((v5 & 0x3FFFFFFFFFFFFFFFLL) != 0)) + 4);
  v6 = *(_QWORD *)(a3 + 40);
  if (v6 >= 1)
    bzero(*(void **)(a3 + 32), 4 * (v6 - ((v6 & 0x3FFFFFFFFFFFFFFFLL) != 0)) + 4);
  v7 = 0;
  v8 = (const float *)(a2 + 56);
  v126 = (float32x4_t **)a3;
LABEL_9:
  v9 = 16;
  v125 = v8;
  do
  {
    v10 = v8 - 12;
    v11 = (unsigned __int128)vld3q_f32(v10);
    v12 = (unsigned __int128)vld3q_f32(v8);
    v13 = (unsigned __int128 *)&v169[v9];
    *(v13 - 1) = v11;
    *v13 = v12;
    v8 += 24;
    v9 += 32;
  }
  while (v9 != 624);
  v14 = 0;
  v15 = *(_DWORD *)(a2 + 4 * (461 - v7));
  HIDWORD(v171) = *(_DWORD *)(a2 + 4 * (458 - v7));
  *(_DWORD *)v172 = v15;
  *(_DWORD *)&v172[4] = *(_DWORD *)(a2 + 4 * (464 - v7));
  v16 = *(_DWORD *)(a2 + 4 * (470 - v7));
  *(_DWORD *)&v172[8] = *(_DWORD *)(a2 + 4 * (467 - v7));
  *(_DWORD *)&v172[12] = v16;
  *(_DWORD *)&v172[16] = *(_DWORD *)(a2 + 4 * (473 - v7));
  *(_DWORD *)&v172[20] = *(_DWORD *)(a2 + 4 * (476 - v7));
  v17 = &v129;
  v18 = v169;
  v19 = v7;
  v20 = 15;
  *(_DWORD *)&v172[24] = *(_DWORD *)(a2 + 4 * (479 - v7));
  v128 = v7;
  while (1)
  {
    v21 = 3 * v14 + v7;
    if ((_DWORD)v21 != 3 && (_DWORD)v21 != 9)
      break;
LABEL_12:
    ++v14;
    --v20;
    v17 = (float32x4_t *)((char *)v17 + 4);
    v19 += 3;
    v18 -= 4;
    if (v14 == 4)
    {
      ++v7;
      v8 = v125 - 1;
      if (v7 == 3)
        return;
      goto LABEL_9;
    }
  }
  if (v21 >= 9)
    v23 = -2;
  else
    v23 = -1;
  if (v21 >= 3)
    v24 = v23;
  else
    v24 = 0;
  v25 = v24 + v21;
  if ((v24 + v21) < 0xA)
  {
    v27 = (_OWORD *)(a1 + 60 * v25);
    bzero(&v129, 0x280uLL);
    if (v14)
    {
      v29 = *v26;
      v28 = v26[1];
      v31 = v26[2];
      v30 = v26[3];
      v32 = (float *)v27 + v20;
      v129.f32[0] = (float)((float)((float)(v129.f32[0] + (float)(*v32 * *v26)) + (float)(*(v32 - 4) * v28))
                          + (float)(*(v32 - 8) * v31))
                  + (float)(*(v32 - 12) * v30);
      if (v14 != 1)
      {
        v129.f32[1] = (float)((float)((float)(v129.f32[1] + (float)(v32[1] * v29)) + (float)(*(v32 - 3) * v28))
                            + (float)(*(v32 - 7) * v31))
                    + (float)(*(v32 - 11) * v30);
        if (v14 != 2)
          v129.f32[2] = (float)((float)((float)(v129.f32[2] + (float)(*((float *)v27 + v20 + 2) * v29))
                                      + (float)(*((float *)v27 + v20 - 2) * v28))
                              + (float)(*((float *)v27 + v20 - 6) * v31))
                      + (float)(*((float *)v27 + v20 - 10) * v30);
      }
    }
    v33 = 0;
    v34 = *v26;
    v35 = a1 + 28 + 60 * (v19 + v24);
    v36 = &v168.f32[2];
    do
    {
      v37 = v33 >> 2;
      if (v33 >> 2 >= 3)
        v37 = 3;
      v38 = v17->f32[v33] + (float)(v36[4] * v34);
      if (v37)
      {
        v39 = v37 + 1;
        v38 = v38 + (float)(*v36 * v26[1]);
        if (v39 != 2)
        {
          v38 = v38 + (float)(*(v36 - 4) * v26[2]);
          if (v39 != 3)
            v38 = v38 + (float)(*(v36 - 8) * v26[3]);
        }
      }
      v17->f32[v33] = v38;
      if (v33 <= 0xB)
      {
        v40 = (float *)(v35 - ((4 * v33) & 0xFFFFFFFFFFFFFFF0));
        v41 = v33 >> 2;
        if (v33 >> 2 >= 3)
          v41 = 3;
        v42 = (char *)&v26[v41];
        v43 = v38 + (float)(v40[4] * *((float *)v42 + 1));
        if (v41 < 2)
        {
          v43 = v43 + (float)(*v40 * *((float *)v42 + 2));
          if (!v41)
            v43 = v43 + (float)(*(v40 - 4) * v26[3]);
        }
        v17->f32[v33] = v43;
      }
      ++v33;
      v35 += 4;
      ++v36;
    }
    while (v14 + v33 != 16);
    v44 = v26 + 3;
    v45 = v26 + 2;
    v47 = vld1q_dup_f32(v26);
    v46 = v26 + 1;
    v48 = vld1q_dup_f32(v46);
    v49 = vld1q_dup_f32(v45);
    v50 = vld1q_dup_f32(v44);
    for (i = 80; i != 656; i += 32)
    {
      v52 = (float32x4_t *)((char *)&v129 + i);
      v54 = *(float32x4_t *)&v18[i - 32];
      v53 = *(float32x4_t *)&v18[i - 16];
      v55 = vmlaq_f32(vmlaq_f32(*(float32x4_t *)((char *)&v129 + i - 16), v47, v53), v48, v54);
      v56 = vmlaq_f32(vmlaq_f32(vmlaq_f32(*(float32x4_t *)((char *)&v129 + i), v47, *(float32x4_t *)&v18[i]), v48, v53), v49, v54);
      v57 = *(float32x4_t *)&v18[i - 48];
      v52[-1] = vmlaq_f32(vmlaq_f32(v55, v49, v57), v50, *(float32x4_t *)&v18[i - 64]);
      *v52 = vmlaq_f32(v56, v50, v57);
    }
    v58 = v171;
    *v27 = v170;
    v27[1] = v58;
    v27[2] = *(_OWORD *)v172;
    *(_OWORD *)((char *)v27 + 44) = *(_OWORD *)&v172[12];
    v60 = vld1q_dup_f32(v59++);
    v61 = *v126;
    v62 = vmlaq_f32((*v126)[1], v130, v60);
    *v61 = vmlaq_f32(**v126, v129, v60);
    v61[1] = v62;
    v63 = vmlaq_f32(v61[3], v132, v60);
    v61[2] = vmlaq_f32(v61[2], v131, v60);
    v61[3] = v63;
    v64 = vmlaq_f32(v61[5], v134, v60);
    v61[4] = vmlaq_f32(v61[4], v133, v60);
    v61[5] = v64;
    v65 = vmlaq_f32(v61[7], v136, v60);
    v61[6] = vmlaq_f32(v61[6], v135, v60);
    v61[7] = v65;
    v66 = vmlaq_f32(v61[9], v138, v60);
    v61[8] = vmlaq_f32(v61[8], v137, v60);
    v61[9] = v66;
    v67 = vmlaq_f32(v61[11], v140, v60);
    v61[10] = vmlaq_f32(v61[10], v139, v60);
    v61[11] = v67;
    v68 = vmlaq_f32(v61[13], v142, v60);
    v61[12] = vmlaq_f32(v61[12], v141, v60);
    v61[13] = v68;
    v69 = vmlaq_f32(v61[15], v144, v60);
    v61[14] = vmlaq_f32(v61[14], v143, v60);
    v61[15] = v69;
    v70 = vmlaq_f32(v61[17], v146, v60);
    v61[16] = vmlaq_f32(v61[16], v145, v60);
    v61[17] = v70;
    v71 = vmlaq_f32(v61[19], v148, v60);
    v61[18] = vmlaq_f32(v61[18], v147, v60);
    v61[19] = v71;
    v72 = vmlaq_f32(v61[21], v150, v60);
    v61[20] = vmlaq_f32(v61[20], v149, v60);
    v61[21] = v72;
    v73 = vmlaq_f32(v61[23], v152, v60);
    v61[22] = vmlaq_f32(v61[22], v151, v60);
    v61[23] = v73;
    v74 = vmlaq_f32(v61[25], v154, v60);
    v61[24] = vmlaq_f32(v61[24], v153, v60);
    v61[25] = v74;
    v75 = vmlaq_f32(v61[27], v156, v60);
    v61[26] = vmlaq_f32(v61[26], v155, v60);
    v61[27] = v75;
    v76 = vmlaq_f32(v61[29], v158, v60);
    v61[28] = vmlaq_f32(v61[28], v157, v60);
    v61[29] = v76;
    v77 = vmlaq_f32(v61[31], v160, v60);
    v61[30] = vmlaq_f32(v61[30], v159, v60);
    v61[31] = v77;
    v78 = vmlaq_f32(v61[33], v162, v60);
    v61[32] = vmlaq_f32(v61[32], v161, v60);
    v61[33] = v78;
    v79 = vmlaq_f32(v61[35], v164, v60);
    v61[34] = vmlaq_f32(v61[34], v163, v60);
    v61[35] = v79;
    v80 = vmlaq_f32(v61[37], v166, v60);
    v61[36] = vmlaq_f32(v61[36], v165, v60);
    v61[37] = v80;
    v81 = vmlaq_f32(v61[39], v168, v60);
    v61[38] = vmlaq_f32(v61[38], v167, v60);
    v61[39] = v81;
    v60.f32[0] = *v59;
    v82 = v126[2];
    v83 = vmlaq_n_f32(v82[1], v130, v60.f32[0]);
    *v82 = vmlaq_n_f32(*v82, v129, v60.f32[0]);
    v82[1] = v83;
    v84 = vmlaq_n_f32(v82[3], v132, v60.f32[0]);
    v82[2] = vmlaq_n_f32(v82[2], v131, v60.f32[0]);
    v82[3] = v84;
    v85 = vmlaq_n_f32(v82[5], v134, v60.f32[0]);
    v82[4] = vmlaq_n_f32(v82[4], v133, v60.f32[0]);
    v82[5] = v85;
    v86 = vmlaq_n_f32(v82[7], v136, v60.f32[0]);
    v82[6] = vmlaq_n_f32(v82[6], v135, v60.f32[0]);
    v82[7] = v86;
    v87 = vmlaq_n_f32(v82[9], v138, v60.f32[0]);
    v82[8] = vmlaq_n_f32(v82[8], v137, v60.f32[0]);
    v82[9] = v87;
    v88 = vmlaq_n_f32(v82[11], v140, v60.f32[0]);
    v82[10] = vmlaq_n_f32(v82[10], v139, v60.f32[0]);
    v82[11] = v88;
    v89 = vmlaq_n_f32(v82[13], v142, v60.f32[0]);
    v82[12] = vmlaq_n_f32(v82[12], v141, v60.f32[0]);
    v82[13] = v89;
    v90 = vmlaq_n_f32(v82[15], v144, v60.f32[0]);
    v82[14] = vmlaq_n_f32(v82[14], v143, v60.f32[0]);
    v82[15] = v90;
    v91 = vmlaq_n_f32(v82[17], v146, v60.f32[0]);
    v82[16] = vmlaq_n_f32(v82[16], v145, v60.f32[0]);
    v82[17] = v91;
    v92 = vmlaq_n_f32(v82[19], v148, v60.f32[0]);
    v82[18] = vmlaq_n_f32(v82[18], v147, v60.f32[0]);
    v82[19] = v92;
    v93 = vmlaq_n_f32(v82[21], v150, v60.f32[0]);
    v82[20] = vmlaq_n_f32(v82[20], v149, v60.f32[0]);
    v82[21] = v93;
    v94 = vmlaq_n_f32(v82[23], v152, v60.f32[0]);
    v82[22] = vmlaq_n_f32(v82[22], v151, v60.f32[0]);
    v82[23] = v94;
    v95 = vmlaq_n_f32(v82[25], v154, v60.f32[0]);
    v82[24] = vmlaq_n_f32(v82[24], v153, v60.f32[0]);
    v82[25] = v95;
    v96 = vmlaq_n_f32(v82[27], v156, v60.f32[0]);
    v82[26] = vmlaq_n_f32(v82[26], v155, v60.f32[0]);
    v82[27] = v96;
    v97 = vmlaq_n_f32(v82[29], v158, v60.f32[0]);
    v82[28] = vmlaq_n_f32(v82[28], v157, v60.f32[0]);
    v82[29] = v97;
    v98 = vmlaq_n_f32(v82[31], v160, v60.f32[0]);
    v82[30] = vmlaq_n_f32(v82[30], v159, v60.f32[0]);
    v82[31] = v98;
    v99 = vmlaq_n_f32(v82[33], v162, v60.f32[0]);
    v82[32] = vmlaq_n_f32(v82[32], v161, v60.f32[0]);
    v82[33] = v99;
    v100 = vmlaq_n_f32(v82[35], v164, v60.f32[0]);
    v82[34] = vmlaq_n_f32(v82[34], v163, v60.f32[0]);
    v82[35] = v100;
    v101 = vmlaq_n_f32(v82[37], v166, v60.f32[0]);
    v82[36] = vmlaq_n_f32(v82[36], v165, v60.f32[0]);
    v82[37] = v101;
    v102 = vmlaq_n_f32(v82[39], v168, v60.f32[0]);
    v82[38] = vmlaq_n_f32(v82[38], v167, v60.f32[0]);
    v82[39] = v102;
    v103 = v126[4];
    v104 = vmlaq_n_f32(v103[1], v130, v60.f32[0]);
    *v103 = vmlaq_n_f32(*v103, v129, v60.f32[0]);
    v103[1] = v104;
    v105 = vmlaq_n_f32(v103[3], v132, v60.f32[0]);
    v103[2] = vmlaq_n_f32(v103[2], v131, v60.f32[0]);
    v103[3] = v105;
    v106 = vmlaq_n_f32(v103[5], v134, v60.f32[0]);
    v103[4] = vmlaq_n_f32(v103[4], v133, v60.f32[0]);
    v103[5] = v106;
    v107 = vmlaq_n_f32(v103[7], v136, v60.f32[0]);
    v103[6] = vmlaq_n_f32(v103[6], v135, v60.f32[0]);
    v103[7] = v107;
    v108 = vmlaq_n_f32(v103[9], v138, v60.f32[0]);
    v103[8] = vmlaq_n_f32(v103[8], v137, v60.f32[0]);
    v103[9] = v108;
    v109 = vmlaq_n_f32(v103[11], v140, v60.f32[0]);
    v103[10] = vmlaq_n_f32(v103[10], v139, v60.f32[0]);
    v103[11] = v109;
    v110 = vmlaq_n_f32(v103[13], v142, v60.f32[0]);
    v103[12] = vmlaq_n_f32(v103[12], v141, v60.f32[0]);
    v103[13] = v110;
    v111 = vmlaq_n_f32(v103[15], v144, v60.f32[0]);
    v103[14] = vmlaq_n_f32(v103[14], v143, v60.f32[0]);
    v103[15] = v111;
    v112 = vmlaq_n_f32(v103[17], v146, v60.f32[0]);
    v103[16] = vmlaq_n_f32(v103[16], v145, v60.f32[0]);
    v103[17] = v112;
    v113 = vmlaq_n_f32(v103[19], v148, v60.f32[0]);
    v103[18] = vmlaq_n_f32(v103[18], v147, v60.f32[0]);
    v103[19] = v113;
    v114 = vmlaq_n_f32(v103[21], v150, v60.f32[0]);
    v103[20] = vmlaq_n_f32(v103[20], v149, v60.f32[0]);
    v103[21] = v114;
    v115 = vmlaq_n_f32(v103[23], v152, v60.f32[0]);
    v103[22] = vmlaq_n_f32(v103[22], v151, v60.f32[0]);
    v103[23] = v115;
    v116 = vmlaq_n_f32(v103[25], v154, v60.f32[0]);
    v103[24] = vmlaq_n_f32(v103[24], v153, v60.f32[0]);
    v103[25] = v116;
    v117 = vmlaq_n_f32(v103[27], v156, v60.f32[0]);
    v103[26] = vmlaq_n_f32(v103[26], v155, v60.f32[0]);
    v103[27] = v117;
    v118 = vmlaq_n_f32(v103[29], v158, v60.f32[0]);
    v103[28] = vmlaq_n_f32(v103[28], v157, v60.f32[0]);
    v103[29] = v118;
    v119 = vmlaq_n_f32(v103[31], v160, v60.f32[0]);
    v103[30] = vmlaq_n_f32(v103[30], v159, v60.f32[0]);
    v103[31] = v119;
    v120 = vmlaq_n_f32(v103[33], v162, v60.f32[0]);
    v103[32] = vmlaq_n_f32(v103[32], v161, v60.f32[0]);
    v103[33] = v120;
    v121 = vmlaq_n_f32(v103[35], v164, v60.f32[0]);
    v103[34] = vmlaq_n_f32(v103[34], v163, v60.f32[0]);
    v103[35] = v121;
    v122 = vmlaq_n_f32(v103[37], v166, v60.f32[0]);
    v103[36] = vmlaq_n_f32(v103[36], v165, v60.f32[0]);
    v103[37] = v122;
    v123 = vmlaq_n_f32(v103[39], v168, v60.f32[0]);
    v103[38] = vmlaq_n_f32(v103[38], v167, v60.f32[0]);
    v103[39] = v123;
    v7 = v128;
    goto LABEL_12;
  }
  __break(1u);
}

void webrtc::ThreeBandFilterBank::Synthesis(uint64_t a1, float32x4_t **a2, char *a3)
{
  float *v3;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  float32x4_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v13;
  int v14;
  unsigned int v15;
  const float *v16;
  float *v17;
  const float *v18;
  float32x4_t v19;
  float32x4_t *v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t *v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t *v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  _OWORD *v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float *v88;
  unint64_t v89;
  float v90;
  uint64_t v91;
  float *v92;
  unsigned int v93;
  float v94;
  unsigned int v95;
  float *v96;
  unint64_t v97;
  char *v98;
  float v99;
  const float *v100;
  const float *v101;
  const float *v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  uint64_t i;
  float32x4_t *v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  uint64_t v114;
  __int128 v115;
  float *v116;
  float v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v121;
  float *v122;
  signed int v123;
  float v124;
  float v125;
  float v126;
  uint64_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  _BYTE v164[64];

  v3 = (float *)a3;
  bzero(a3, 0x780uLL);
  v5 = 0;
  v119 = a1 + 600;
  v118 = a1 + 644;
LABEL_3:
  v6 = 0;
  v7 = &v124;
  v8 = &v128;
  v9 = v5;
  v10 = 15;
  v121 = v5;
  v122 = v3;
  while (1)
  {
    v11 = 3 * v6 + v5;
    if ((_DWORD)v11 != 3 && (_DWORD)v11 != 9)
      break;
LABEL_4:
    ++v6;
    --v10;
    ++v7;
    v9 += 3;
    v8 = (float32x4_t *)((char *)v8 - 4);
    if (v6 == 4)
    {
      ++v5;
      ++v3;
      if (v5 == 3)
        return;
      goto LABEL_3;
    }
  }
  if (v11 >= 9)
    v13 = -2;
  else
    v13 = -1;
  if (v11 >= 3)
    v14 = v13;
  else
    v14 = 0;
  v15 = v14 + v11;
  if (v15 < 0xA)
  {
    v123 = v15;
    bzero(&v128, 0x280uLL);
    v18 = v16;
    v19 = vld1q_dup_f32(v18++);
    v20 = *a2;
    v21 = vmlaq_f32(v129, (*a2)[1], v19);
    v128 = vmlaq_f32(v128, **a2, v19);
    v129 = v21;
    v22 = vmlaq_f32(v131, v20[3], v19);
    v130 = vmlaq_f32(v130, v20[2], v19);
    v131 = v22;
    v23 = vmlaq_f32(v133, v20[5], v19);
    v132 = vmlaq_f32(v132, v20[4], v19);
    v133 = v23;
    v24 = vmlaq_f32(v135, v20[7], v19);
    v134 = vmlaq_f32(v134, v20[6], v19);
    v135 = v24;
    v25 = vmlaq_f32(v137, v20[9], v19);
    v136 = vmlaq_f32(v136, v20[8], v19);
    v137 = v25;
    v26 = vmlaq_f32(v139, v20[11], v19);
    v138 = vmlaq_f32(v138, v20[10], v19);
    v139 = v26;
    v27 = vmlaq_f32(v141, v20[13], v19);
    v140 = vmlaq_f32(v140, v20[12], v19);
    v141 = v27;
    v28 = vmlaq_f32(v143, v20[15], v19);
    v142 = vmlaq_f32(v142, v20[14], v19);
    v143 = v28;
    v29 = vmlaq_f32(v145, v20[17], v19);
    v144 = vmlaq_f32(v144, v20[16], v19);
    v145 = v29;
    v30 = vmlaq_f32(v147, v20[19], v19);
    v146 = vmlaq_f32(v146, v20[18], v19);
    v147 = v30;
    v31 = vmlaq_f32(v149, v20[21], v19);
    v148 = vmlaq_f32(v148, v20[20], v19);
    v149 = v31;
    v32 = vmlaq_f32(v151, v20[23], v19);
    v150 = vmlaq_f32(v150, v20[22], v19);
    v151 = v32;
    v33 = vmlaq_f32(v153, v20[25], v19);
    v152 = vmlaq_f32(v152, v20[24], v19);
    v153 = v33;
    v34 = vmlaq_f32(v155, v20[27], v19);
    v154 = vmlaq_f32(v154, v20[26], v19);
    v155 = v34;
    v35 = vmlaq_f32(v157, v20[29], v19);
    v156 = vmlaq_f32(v156, v20[28], v19);
    v157 = v35;
    v36 = vmlaq_f32(v159, v20[31], v19);
    v158 = vmlaq_f32(v158, v20[30], v19);
    v159 = v36;
    v37 = vmlaq_f32(v161, v20[33], v19);
    v160 = vmlaq_f32(v160, v20[32], v19);
    v161 = v37;
    v38 = vmlaq_f32(v163, v20[35], v19);
    v162 = vmlaq_f32(v162, v20[34], v19);
    v163 = v38;
    v39 = vmlaq_f32(*(float32x4_t *)&v164[16], v20[37], v19);
    *(float32x4_t *)v164 = vmlaq_f32(*(float32x4_t *)v164, v20[36], v19);
    *(float32x4_t *)&v164[16] = v39;
    v40 = vmlaq_f32(*(float32x4_t *)&v164[48], v20[39], v19);
    *(float32x4_t *)&v164[32] = vmlaq_f32(*(float32x4_t *)&v164[32], v20[38], v19);
    *(float32x4_t *)&v164[48] = v40;
    v19.f32[0] = *v18;
    v41 = a2[2];
    v42 = vmlaq_n_f32(v129, v41[1], v19.f32[0]);
    v128 = vmlaq_n_f32(v128, *v41, v19.f32[0]);
    v129 = v42;
    v43 = vmlaq_n_f32(v131, v41[3], v19.f32[0]);
    v130 = vmlaq_n_f32(v130, v41[2], v19.f32[0]);
    v131 = v43;
    v44 = vmlaq_n_f32(v133, v41[5], v19.f32[0]);
    v132 = vmlaq_n_f32(v132, v41[4], v19.f32[0]);
    v133 = v44;
    v45 = vmlaq_n_f32(v135, v41[7], v19.f32[0]);
    v134 = vmlaq_n_f32(v134, v41[6], v19.f32[0]);
    v135 = v45;
    v46 = vmlaq_n_f32(v137, v41[9], v19.f32[0]);
    v136 = vmlaq_n_f32(v136, v41[8], v19.f32[0]);
    v137 = v46;
    v47 = vmlaq_n_f32(v139, v41[11], v19.f32[0]);
    v138 = vmlaq_n_f32(v138, v41[10], v19.f32[0]);
    v139 = v47;
    v48 = vmlaq_n_f32(v141, v41[13], v19.f32[0]);
    v140 = vmlaq_n_f32(v140, v41[12], v19.f32[0]);
    v141 = v48;
    v49 = vmlaq_n_f32(v143, v41[15], v19.f32[0]);
    v142 = vmlaq_n_f32(v142, v41[14], v19.f32[0]);
    v143 = v49;
    v50 = vmlaq_n_f32(v145, v41[17], v19.f32[0]);
    v144 = vmlaq_n_f32(v144, v41[16], v19.f32[0]);
    v145 = v50;
    v51 = vmlaq_n_f32(v147, v41[19], v19.f32[0]);
    v146 = vmlaq_n_f32(v146, v41[18], v19.f32[0]);
    v147 = v51;
    v52 = vmlaq_n_f32(v149, v41[21], v19.f32[0]);
    v148 = vmlaq_n_f32(v148, v41[20], v19.f32[0]);
    v149 = v52;
    v53 = vmlaq_n_f32(v151, v41[23], v19.f32[0]);
    v150 = vmlaq_n_f32(v150, v41[22], v19.f32[0]);
    v151 = v53;
    v54 = vmlaq_n_f32(v153, v41[25], v19.f32[0]);
    v152 = vmlaq_n_f32(v152, v41[24], v19.f32[0]);
    v153 = v54;
    v55 = vmlaq_n_f32(v155, v41[27], v19.f32[0]);
    v154 = vmlaq_n_f32(v154, v41[26], v19.f32[0]);
    v155 = v55;
    v56 = vmlaq_n_f32(v157, v41[29], v19.f32[0]);
    v156 = vmlaq_n_f32(v156, v41[28], v19.f32[0]);
    v157 = v56;
    v57 = vmlaq_n_f32(v159, v41[31], v19.f32[0]);
    v158 = vmlaq_n_f32(v158, v41[30], v19.f32[0]);
    v159 = v57;
    v58 = vmlaq_n_f32(v161, v41[33], v19.f32[0]);
    v160 = vmlaq_n_f32(v160, v41[32], v19.f32[0]);
    v161 = v58;
    v59 = vmlaq_n_f32(v163, v41[35], v19.f32[0]);
    v162 = vmlaq_n_f32(v162, v41[34], v19.f32[0]);
    v163 = v59;
    v60 = vmlaq_n_f32(*(float32x4_t *)&v164[16], v41[37], v19.f32[0]);
    *(float32x4_t *)v164 = vmlaq_n_f32(*(float32x4_t *)v164, v41[36], v19.f32[0]);
    *(float32x4_t *)&v164[16] = v60;
    v61 = vmlaq_n_f32(*(float32x4_t *)&v164[48], v41[39], v19.f32[0]);
    *(float32x4_t *)&v164[32] = vmlaq_n_f32(*(float32x4_t *)&v164[32], v41[38], v19.f32[0]);
    *(float32x4_t *)&v164[48] = v61;
    v19.f32[0] = v16[2];
    v62 = a2[4];
    v63 = vmlaq_n_f32(v129, v62[1], v19.f32[0]);
    v128 = vmlaq_n_f32(v128, *v62, v19.f32[0]);
    v129 = v63;
    v64 = vmlaq_n_f32(v131, v62[3], v19.f32[0]);
    v130 = vmlaq_n_f32(v130, v62[2], v19.f32[0]);
    v131 = v64;
    v65 = vmlaq_n_f32(v133, v62[5], v19.f32[0]);
    v132 = vmlaq_n_f32(v132, v62[4], v19.f32[0]);
    v133 = v65;
    v66 = vmlaq_n_f32(v135, v62[7], v19.f32[0]);
    v134 = vmlaq_n_f32(v134, v62[6], v19.f32[0]);
    v135 = v66;
    v67 = vmlaq_n_f32(v137, v62[9], v19.f32[0]);
    v136 = vmlaq_n_f32(v136, v62[8], v19.f32[0]);
    v137 = v67;
    v68 = vmlaq_n_f32(v139, v62[11], v19.f32[0]);
    v138 = vmlaq_n_f32(v138, v62[10], v19.f32[0]);
    v139 = v68;
    v69 = vmlaq_n_f32(v141, v62[13], v19.f32[0]);
    v140 = vmlaq_n_f32(v140, v62[12], v19.f32[0]);
    v141 = v69;
    v70 = vmlaq_n_f32(v143, v62[15], v19.f32[0]);
    v142 = vmlaq_n_f32(v142, v62[14], v19.f32[0]);
    v143 = v70;
    v71 = vmlaq_n_f32(v145, v62[17], v19.f32[0]);
    v144 = vmlaq_n_f32(v144, v62[16], v19.f32[0]);
    v145 = v71;
    v72 = vmlaq_n_f32(v147, v62[19], v19.f32[0]);
    v146 = vmlaq_n_f32(v146, v62[18], v19.f32[0]);
    v147 = v72;
    v73 = vmlaq_n_f32(v149, v62[21], v19.f32[0]);
    v148 = vmlaq_n_f32(v148, v62[20], v19.f32[0]);
    v149 = v73;
    v74 = vmlaq_n_f32(v151, v62[23], v19.f32[0]);
    v150 = vmlaq_n_f32(v150, v62[22], v19.f32[0]);
    v151 = v74;
    v75 = vmlaq_n_f32(v153, v62[25], v19.f32[0]);
    v152 = vmlaq_n_f32(v152, v62[24], v19.f32[0]);
    v153 = v75;
    v76 = vmlaq_n_f32(v155, v62[27], v19.f32[0]);
    v154 = vmlaq_n_f32(v154, v62[26], v19.f32[0]);
    v155 = v76;
    v77 = vmlaq_n_f32(v157, v62[29], v19.f32[0]);
    v156 = vmlaq_n_f32(v156, v62[28], v19.f32[0]);
    v157 = v77;
    v78 = vmlaq_n_f32(v159, v62[31], v19.f32[0]);
    v158 = vmlaq_n_f32(v158, v62[30], v19.f32[0]);
    v159 = v78;
    v79 = vmlaq_n_f32(v161, v62[33], v19.f32[0]);
    v160 = vmlaq_n_f32(v160, v62[32], v19.f32[0]);
    v161 = v79;
    v80 = vmlaq_n_f32(v163, v62[35], v19.f32[0]);
    v162 = vmlaq_n_f32(v162, v62[34], v19.f32[0]);
    v163 = v80;
    v81 = vmlaq_n_f32(*(float32x4_t *)&v164[16], v62[37], v19.f32[0]);
    *(float32x4_t *)v164 = vmlaq_n_f32(*(float32x4_t *)v164, v62[36], v19.f32[0]);
    *(float32x4_t *)&v164[16] = v81;
    v82 = vmlaq_n_f32(*(float32x4_t *)&v164[48], v62[39], v19.f32[0]);
    v83 = (_OWORD *)(v119 + 60 * v123);
    *(float32x4_t *)&v164[32] = vmlaq_n_f32(*(float32x4_t *)&v164[32], v62[38], v19.f32[0]);
    *(float32x4_t *)&v164[48] = v82;
    bzero(&v124, 0x280uLL);
    if (v6)
    {
      v85 = *v17;
      v84 = v17[1];
      v87 = v17[2];
      v86 = v17[3];
      v88 = (float *)v83 + v10;
      v124 = (float)((float)((float)(v124 + (float)(*v88 * *v17)) + (float)(*(v88 - 4) * v84))
                   + (float)(*(v88 - 8) * v87))
           + (float)(*(v88 - 12) * v86);
      if (v6 != 1)
      {
        v125 = (float)((float)((float)(v125 + (float)(v88[1] * v85)) + (float)(*(v88 - 3) * v84))
                     + (float)(*(v88 - 7) * v87))
             + (float)(*(v88 - 11) * v86);
        if (v6 != 2)
          v126 = (float)((float)((float)(v126 + (float)(*((float *)v83 + v10 + 2) * v85))
                               + (float)(*((float *)v83 + v10 - 2) * v84))
                       + (float)(*((float *)v83 + v10 - 6) * v87))
               + (float)(*((float *)v83 + v10 - 10) * v86);
      }
    }
    v89 = 0;
    v90 = *v17;
    v91 = v118 + 60 * (v9 + v14);
    v92 = (float *)&v127;
    do
    {
      v93 = v89 >> 2;
      if (v89 >> 2 >= 3)
        v93 = 3;
      v94 = v7[v89] + (float)(v92[4] * v90);
      if (v93)
      {
        v95 = v93 + 1;
        v94 = v94 + (float)(*v92 * v17[1]);
        if (v95 != 2)
        {
          v94 = v94 + (float)(*(v92 - 4) * v17[2]);
          if (v95 != 3)
            v94 = v94 + (float)(*(v92 - 8) * v17[3]);
        }
      }
      v7[v89] = v94;
      if (v89 <= 0xB)
      {
        v96 = (float *)(v91 - ((4 * v89) & 0xFFFFFFFFFFFFFFF0));
        v97 = v89 >> 2;
        if (v89 >> 2 >= 3)
          v97 = 3;
        v98 = (char *)&v17[v97];
        v99 = v94 + (float)(*v96 * *((float *)v98 + 1));
        if (v97 < 2)
        {
          v99 = v99 + (float)(*(v96 - 4) * *((float *)v98 + 2));
          if (!v97)
            v99 = v99 + (float)(*(v96 - 8) * v17[3]);
        }
        v7[v89] = v99;
      }
      ++v89;
      v91 += 4;
      ++v92;
    }
    while (v6 + v89 != 16);
    v100 = v17 + 3;
    v101 = v17 + 2;
    v103 = vld1q_dup_f32(v17);
    v102 = v17 + 1;
    v104 = vld1q_dup_f32(v102);
    v105 = vld1q_dup_f32(v101);
    v106 = vld1q_dup_f32(v100);
    for (i = 5; i != 41; i += 2)
    {
      v108 = (float32x4_t *)((char *)&v124 + i * 16);
      v110 = v8[i - 2];
      v109 = v8[i - 1];
      v111 = vmlaq_f32(vmlaq_f32(*(float32x4_t *)((char *)&v124 + i * 16 - 16), v103, v109), v104, v110);
      v112 = vmlaq_f32(vmlaq_f32(vmlaq_f32(*(float32x4_t *)((char *)&v124 + i * 16), v103, v8[i]), v104, v109), v105, v110);
      v113 = v8[i - 3];
      v108[-1] = vmlaq_f32(vmlaq_f32(v111, v105, v113), v106, v8[i - 4]);
      *v108 = vmlaq_f32(v112, v106, v113);
    }
    v114 = 0;
    v115 = *(_OWORD *)&v164[20];
    *v83 = *(_OWORD *)&v164[4];
    v83[1] = v115;
    v83[2] = *(_OWORD *)&v164[36];
    *(_OWORD *)((char *)v83 + 44) = *(_OWORD *)&v164[48];
    v3 = v122;
    v116 = v122;
    do
    {
      v117 = v116[3] + (float)(*(float *)((char *)&v124 + v114 + 4) * 3.0);
      *v116 = *v116 + (float)(*(float *)((char *)&v124 + v114) * 3.0);
      v116[3] = v117;
      v114 += 8;
      v116 += 6;
    }
    while (v114 != 640);
    v5 = v121;
    goto LABEL_4;
  }
  __break(1u);
}

void absl::base_internal::ThrowStdOutOfRange(absl::base_internal *this, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  absl::raw_log_internal::RawLog(3, (uint64_t)"throw_delegate.cc", 112, "%s", a5, a6, a7, a8, (char)this);
  __break(1u);
}

unint64_t webrtc::ToString@<X0>(webrtc *this@<X0>, TimeDelta a2@<0:X1>, char *a3@<X8>)
{
  char *v4;
  size_t v5;
  char *v6;
  const char *v7;
  char *v8;
  unint64_t result;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  char *__s;
  __int128 v25;
  _BYTE v26[7];
  _BYTE v27[65];

  *(_QWORD *)&v27[57] = *MEMORY[0x24BDAC8D0];
  __s = v26;
  v25 = xmmword_208F08610;
  v26[0] = 0;
  if (this == (webrtc *)0x8000000000000000)
  {
    qmemcpy(v26, "-inf ms", sizeof(v26));
    *((_QWORD *)&v25 + 1) = 7;
    v4 = v27;
    goto LABEL_12;
  }
  if (!this)
    goto LABEL_7;
  if (this != (webrtc *)0x7FFFFFFFFFFFFFFFLL)
  {
    if (__ROR8__(0x1CAC083126E978D5 * (_QWORD)this + 0x10624DD2F1A9FB8, 3) >= 0x4189374BC6A7EFuLL)
    {
LABEL_7:
      rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%lld", this);
      if ((_QWORD)v25 + ~*((_QWORD *)&v25 + 1) >= 3uLL)
        v5 = 3;
      else
        v5 = v25 + ~*((_QWORD *)&v25 + 1);
      v6 = &__s[*((_QWORD *)&v25 + 1)];
      v7 = " us";
LABEL_11:
      memcpy(v6, v7, v5);
      *((_QWORD *)&v25 + 1) += v5;
      v4 = &__s[*((_QWORD *)&v25 + 1)];
      goto LABEL_12;
    }
    if (((unint64_t)this & 0x8000000000000000) != 0)
    {
      v17 = -(uint64_t)this;
      v18 = -(uint64_t)this / 0x3E8uLL;
      v19 = -(uint64_t)this % 0x3E8uLL;
      if (v19 <= 0x1F4)
        v20 = -(uint64_t)this / 0x3E8uLL;
      else
        v20 = v18 + 1;
      if (__ROR8__(0x1CAC083126E978D5 * v20, 3) < 0x4189374BC6A7F0uLL)
      {
        v22 = v17 / 0xF4240;
        if (v17 % 0xF4240 <= 0x7A120)
          v23 = 0;
        else
          v23 = -1;
        v16 = v23 - v22;
LABEL_49:
        rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%lld", v16);
        if ((_QWORD)v25 + ~*((_QWORD *)&v25 + 1) >= 2uLL)
          v5 = 2;
        else
          v5 = v25 + ~*((_QWORD *)&v25 + 1);
        v6 = &__s[*((_QWORD *)&v25 + 1)];
        v7 = " s";
        goto LABEL_11;
      }
      if (v19 <= 0x1F4)
        v21 = 0;
      else
        v21 = -1;
      v15 = v21 - v18;
    }
    else
    {
      v15 = (unint64_t)this / 0x3E8;
      if ((unint64_t)this % 0x3E8 > 0x1F3)
        ++v15;
      if (__ROR8__(0x1CAC083126E978D5 * v15, 3) < 0x4189374BC6A7F0uLL)
      {
        v16 = (unint64_t)this / 0xF4240;
        if ((unint64_t)this % 0xF4240 > 0x7A11F)
          ++v16;
        goto LABEL_49;
      }
    }
    rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%lld", v15);
    if ((_QWORD)v25 + ~*((_QWORD *)&v25 + 1) >= 3uLL)
      v5 = 3;
    else
      v5 = v25 + ~*((_QWORD *)&v25 + 1);
    v6 = &__s[*((_QWORD *)&v25 + 1)];
    v7 = " ms";
    goto LABEL_11;
  }
  qmemcpy(v26, "+inf ms", sizeof(v26));
  *((_QWORD *)&v25 + 1) = 7;
  v4 = v27;
LABEL_12:
  *v4 = 0;
  v8 = __s;
  if (!__s)
    goto LABEL_53;
  result = strlen(__s);
  if (result >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_54;
  v10 = result;
  if (result > 0x16)
  {
    v11 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17)
      v11 = result | 7;
    v12 = v11 + 1;
    result = (unint64_t)operator new(v11 + 1);
    *((_QWORD *)a3 + 1) = v10;
    *((_QWORD *)a3 + 2) = v12 | 0x8000000000000000;
    *(_QWORD *)a3 = result;
    a3 = (char *)result;
  }
  else
  {
    a3[23] = result;
  }
  v13 = &a3[v10];
  if (a3 <= v8 && v13 > v8)
  {
LABEL_53:
    __break(1u);
LABEL_54:
    abort();
  }
  if (v10)
    result = (unint64_t)memmove(a3, v8, v10);
  *v13 = 0;
  return result;
}

uint64_t webrtc::TimeStretch::Process(webrtc::TimeStretch *this, int16x8_t *a2, unint64_t a3, unsigned int a4, webrtc::AudioMultiVector *a5, unint64_t *a6)
{
  int16x8_t *v7;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int16x8_t v21;
  _OWORD *v22;
  uint64_t v23;
  __int16 *v24;
  uint64_t v25;
  int v26;
  int v27;
  int16x8_t *v28;
  unint64_t v29;
  unint64_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int16x8_t v48;
  int16x8_t v49;
  int16x8_t v50;
  int16x8_t v51;
  int16x8_t v52;
  int16x8_t v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v61;
  unint64_t v62;
  unsigned int v63;
  char v64;
  int v65;
  __int16 *v66;
  unsigned int v67;
  unsigned int v68;
  int32x4_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int16x8_t v72;
  int32x4_t v73;
  int32x4_t v74;
  int16x8_t v75;
  int v76;
  int v77;
  int v78;
  unint64_t v79;
  unsigned int v80;
  int v81;
  unsigned int v82;
  int v83;
  uint64_t v84;
  uint64_t i64;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  uint64_t v92;
  int v93;
  signed int v94;
  char v95;
  int v96;
  int v97;
  signed int v98;
  int v99;
  char v100;
  int v101;
  char v102;
  int v103;
  int8x8_t v104;
  __int32 v105;
  int v106;
  __int16 v107;
  int v108;
  int v109;
  const __int16 *v110;
  uint64_t v111;
  unint64_t v112;
  unint64_t v114;
  __int16 v120;
  __int16 v121;
  int32x4_t v122[12];
  int v123;
  int v124;
  uint64_t v125;

  v7 = a2;
  v125 = *MEMORY[0x24BDAC8D0];
  v9 = *((int *)this + 3);
  v10 = *((_QWORD *)this + 2);
  if (v10 == 1)
  {
    v11 = 0;
    v12 = a3;
    goto LABEL_18;
  }
  v12 = a3 / v10;
  v13 = operator new[]();
  v11 = v13;
  if (v10 <= a3)
  {
    v14 = *((_QWORD *)this + 2);
    if (v12 <= 1)
      v15 = 1;
    else
      v15 = a3 / v10;
    if (v15 >= 0x10 && v14 == 1)
    {
      v19 = 0;
      v18 = v15 & 0xFFFFFFFFFFFFFFF0;
      v17 = (v15 & 0xFFFFFFFFFFFFFFF0) * v14;
      v20 = v15 & 0xFFFFFFFFFFFFFFF0;
      do
      {
        v21 = v7[v19 + 1];
        v22 = (_OWORD *)(v13 + v19 * 16);
        *v22 = v7[v19];
        v22[1] = v21;
        v19 += 2;
        v20 -= 16;
      }
      while (v20);
      if (v15 == v18)
        goto LABEL_17;
    }
    else
    {
      v17 = 0;
      v18 = 0;
    }
    v23 = 2 * v14;
    v24 = &v7->i16[v17];
    do
    {
      *(_WORD *)(v13 + 2 * v18++) = *v24;
      v24 = (__int16 *)((char *)v24 + v23);
    }
    while (v15 != v18);
  }
LABEL_17:
  v7 = (int16x8_t *)v13;
LABEL_18:
  v25 = 15 * v9;
  *((_WORD *)this + 16) = WebRtcSpl_MaxAbsValueW16C(v7, v12);
  v26 = *((_DWORD *)this + 2);
  if (v26 > 31999)
  {
    if (v26 == 32000)
    {
      v27 = 8;
      v28 = (int16x8_t *)&webrtc::DspHelper::kDownsample32kHzTbl;
    }
    else
    {
      if (v26 != 48000)
        goto LABEL_29;
      v27 = 12;
      v28 = (int16x8_t *)&webrtc::DspHelper::kDownsample48kHzTbl;
    }
    v29 = 4;
    v30 = 7;
  }
  else if (v26 == 8000)
  {
    v29 = 2;
    v28 = (int16x8_t *)&webrtc::DspHelper::kDownsample8kHzTbl;
    v30 = 3;
    v27 = 2;
  }
  else
  {
    if (v26 != 16000)
      goto LABEL_29;
    v27 = 4;
    v28 = (int16x8_t *)&webrtc::DspHelper::kDownsample16kHzTbl;
    v29 = 3;
    v30 = 5;
  }
  WebRtcSpl_DownsampleFastC((uint64_t)v7->i64 + 2 * v30 - 2, v12 - v30 + 1, (_WORD *)this + 17, 110, v28, v30, v27, v29);
LABEL_29:
  v114 = v12;
  v31 = *(int16x8_t *)((char *)this + 218);
  v32 = *(int16x8_t *)((char *)this + 186);
  v33 = *(int16x8_t *)((char *)this + 154);
  v34 = *(int16x8_t *)((char *)this + 234);
  v35 = *(int16x8_t *)((char *)this + 202);
  v36 = *(int16x8_t *)((char *)this + 170);
  v37 = vmaxvq_s16(vmaxq_s16(vmaxq_s16(v31, vmaxq_s16(v32, v33)), vmaxq_s16(v34, vmaxq_s16(v35, v36))));
  v38 = vminvq_s16(vminq_s16(vminq_s16(v31, vminq_s16(v32, v33)), vminq_s16(v34, vminq_s16(v35, v36))));
  v39 = *((__int16 *)this + 125);
  if (v39 < v38)
    v38 = *((__int16 *)this + 125);
  if (v39 <= v37)
    v39 = v37;
  v40 = *((__int16 *)this + 126);
  if (v40 >= v38)
    v41 = v38;
  else
    v41 = *((__int16 *)this + 126);
  v42 = *(int16x8_t *)((char *)this + 196);
  v43 = *(int16x8_t *)((char *)this + 164);
  v44 = *(int16x8_t *)((char *)this + 132);
  v45 = *(int16x8_t *)((char *)this + 100);
  v46 = *(int16x8_t *)((char *)this + 68);
  v47 = *(int16x8_t *)((char *)this + 36);
  v48 = *(int16x8_t *)((char *)this + 212);
  v49 = *(int16x8_t *)((char *)this + 180);
  v50 = *(int16x8_t *)((char *)this + 148);
  v51 = *(int16x8_t *)((char *)this + 116);
  v52 = *(int16x8_t *)((char *)this + 84);
  v53 = *(int16x8_t *)((char *)this + 52);
  v54 = vmaxvq_s16(vmaxq_s16(vmaxq_s16(v42, vmaxq_s16(v43, vmaxq_s16(v44, vmaxq_s16(v45, vmaxq_s16(v46, v47))))), vmaxq_s16(v48, vmaxq_s16(v49, vmaxq_s16(v50, vmaxq_s16(v51, vmaxq_s16(v52, v53)))))));
  v55 = vminvq_s16(vminq_s16(vminq_s16(v42, vminq_s16(v43, vminq_s16(v44, vminq_s16(v45, vminq_s16(v46, v47))))), vminq_s16(v48, vminq_s16(v49, vminq_s16(v50, vminq_s16(v51, vminq_s16(v52, v53)))))));
  if (v40 > v39)
    v39 = *((__int16 *)this + 126);
  v56 = *((__int16 *)this + 114);
  if (v56 < v55)
    v55 = *((__int16 *)this + 114);
  if (v56 > v54)
    v54 = *((__int16 *)this + 114);
  v57 = *((__int16 *)this + 115);
  if (v57 < v55)
    v55 = *((__int16 *)this + 115);
  if (v57 > v54)
    v54 = *((__int16 *)this + 115);
  v58 = *((__int16 *)this + 116);
  if (v58 < v55)
    v55 = *((__int16 *)this + 116);
  if (v58 > v54)
    v54 = *((__int16 *)this + 116);
  if (v41 >= -v39 && v41 != v39)
    v41 = v39;
  if (v55 < -v54 || v55 == v54)
    v54 = v55;
  v61 = v54 * v41;
  if (v61 < 0)
    v61 = -v61;
  v62 = (50 * (unint64_t)v61) >> 31;
  v63 = 32 - __clz(v62);
  if ((_DWORD)v62)
    v64 = v63;
  else
    v64 = 0;
  WebRtcSpl_CrossCorrelationC(v122[0].i32, (uint64_t)this + 154, (uint64_t)this + 134, 0x32uLL, 50, v64, -1);
  v65 = WebRtcSpl_MaxAbsValueW32C(v122, 0x32uLL);
  v67 = __clz(v65 ^ (v65 >> 31));
  v68 = (18 - v67) & ~((int)(18 - v67) >> 31);
  if (!v65)
    v68 = 17;
  v69 = vnegq_s32(vdupq_n_s32(v68));
  v70 = vqmovn_high_s32(vqmovn_s32(vshlq_s32(v122[2], v69)), vshlq_s32(v122[3], v69));
  *(int16x8_t *)((char *)this + 254) = vqmovn_high_s32(vqmovn_s32(vshlq_s32(v122[0], v69)), vshlq_s32(v122[1], v69));
  v71 = vqmovn_high_s32(vqmovn_s32(vshlq_s32(v122[4], v69)), vshlq_s32(v122[5], v69));
  v72 = vqmovn_high_s32(vqmovn_s32(vshlq_s32(v122[6], v69)), vshlq_s32(v122[7], v69));
  *(int16x8_t *)((char *)this + 270) = v70;
  *(int16x8_t *)((char *)this + 286) = v71;
  v73 = vshlq_s32(v122[9], v69);
  v74 = vshlq_s32(v122[8], v69);
  v75 = vqmovn_high_s32(vqmovn_s32(vshlq_s32(v122[10], v69)), vshlq_s32(v122[11], v69));
  *(int16x8_t *)((char *)this + 302) = v72;
  *(int16x8_t *)((char *)this + 318) = vqmovn_high_s32(vqmovn_s32(v74), v73);
  *(int16x8_t *)((char *)this + 334) = v75;
  v76 = v124;
  v77 = v123 >> v68;
  if (v123 >> v68 <= -32768)
    v77 = -32768;
  if (v77 >= 0x7FFF)
    LOWORD(v77) = 0x7FFF;
  *((_WORD *)this + 175) = v77;
  v78 = v76 >> v68;
  if (v78 <= -32768)
    v78 = -32768;
  if (v78 >= 0x7FFF)
    LOWORD(v78) = 0x7FFF;
  *((_WORD *)this + 176) = v78;
  v122[0].i64[0] = 0;
  v121 = 0;
  webrtc::DspHelper::PeakDetection((webrtc::TimeStretch *)((char *)this + 254), (__int16 *)0x32, 1, (__int16 *)*((unsigned int *)this + 3), v122[0].i16, (unint64_t *)&v121, v66);
  v79 = v122[0].i64[0] + 20 * *((int *)this + 3);
  v122[0].i64[0] = v79;
  v80 = 32 - __clz(*((__int16 *)this + 16) * *((__int16 *)this + 16));
  if (*((_WORD *)this + 16))
    v81 = v80;
  else
    v81 = 31;
  v82 = __clz(v79 ^ ((int)v79 >> 31)) - 1;
  if (!(_DWORD)v79)
    v82 = 0;
  v83 = (v81 - v82) & ~((int)(v81 - v82) >> 31);
  v84 = (uint64_t)v7->i64 + 2 * (v25 * 8 - v79);
  i64 = (uint64_t)v7[v25].i64;
  WebRtcSpl_DotProductWithScale(v84, v84, v79, (v81 - v82) & ~((int)(v81 - v82) >> 31));
  v87 = v86;
  WebRtcSpl_DotProductWithScale(i64, i64, v79, v83);
  v89 = v88;
  WebRtcSpl_DotProductWithScale(v84, i64, v79, v83);
  v91 = v90;
  v92 = *((_QWORD *)this + 3);
  if (*(_BYTE *)(v92 + 24))
  {
    v93 = **(_DWORD **)(v92 + 16);
    v94 = 17 - __clz(v93 ^ (v93 >> 31));
    if (!v93)
      v94 = 16;
  }
  else
  {
    v94 = 2;
    v93 = 75000;
  }
  v95 = v94 & ~(v94 >> 31);
  v96 = (int)((v89 + (uint64_t)v87) / 16) >> v95;
  v97 = (v93 >> v95) * v79;
  v98 = __clz(v96 ^ (v96 >> 31)) - 1;
  if (!v96)
    v98 = 0;
  v99 = 2 * v83;
  v100 = 2 * v83 - v98;
  if (2 * v83 <= v98)
    v100 = 0;
  v101 = v97 >> v100;
  if (v99 >= v98)
    v102 = v98;
  else
    v102 = v99;
  v103 = v96 << v102;
  v120 = 0;
  if (v96 << v102 <= v101)
  {
    (*(void (**)(webrtc::TimeStretch *, unint64_t, __int16 *, int32x4_t *))(*(_QWORD *)this + 16))(this, v114, &v120, v122);
    LOWORD(v109) = v120;
    v79 = v122[0].i64[0];
    v110 = (const __int16 *)a2;
  }
  else
  {
    v104 = vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)__PAIR64__(v87, v89)), (int8x8_t)0x1000000010, (int8x8_t)vmax_s32(vsub_s32((int32x2_t)0x1100000011, vclz_s32((int32x2_t)veor_s8((int8x8_t)vcltz_s32((int32x2_t)__PAIR64__(v87, v89)), (int8x8_t)__PAIR64__(v87, v89)))), 0));
    v105 = v104.i32[0];
    v106 = ((v104.i8[0] + v104.i8[4]) & 1) + v104.i32[1];
    v107 = WebRtcSpl_SqrtFloor((__int16)(v87 >> (((v104.i8[0] + v104.i8[4]) & 1) + v104.i8[4])) * (__int16)(v89 >> v104.i8[0]));
    if (v107)
    {
      if ((v106 + v105) >= 0x1E)
        v108 = v91 >> (((v106 + v105) >> 1) - 14);
      else
        v108 = v91 << (14 - ((v106 + v105) >> 1));
      v109 = (v108 & ~(v108 >> 31)) / v107;
    }
    else
    {
      LOWORD(v109) = -1;
    }
    v110 = (const __int16 *)a2;
    if ((__int16)v109 >= 0x4000)
      LOWORD(v109) = 0x4000;
    v120 = v109;
  }
  v111 = (*(uint64_t (**)(webrtc::TimeStretch *, const __int16 *, unint64_t, unint64_t, _QWORD, BOOL, _QWORD, webrtc::AudioMultiVector *))(*(_QWORD *)this + 24))(this, v110, a3, v79, (__int16)v109, v103 > v101, a4, a5);
  v112 = 0;
  switch((int)v111)
  {
    case -1:
    case 2:
      goto LABEL_105;
    case 0:
    case 1:
      v112 = v122[0].i64[0];
LABEL_105:
      *a6 = v112;
      break;
    default:
      break;
  }
  if (v11)
    MEMORY[0x20BD0ADD4](v11, 0x1000C80BDFB0063);
  return v111;
}

uint64_t rtc::TimeMillis(rtc *this)
{
  uint64_t v1;

  if (rtc::g_clock)
  {
    v1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v1 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
       / dword_253EA791C;
  }
  return v1 / 1000000;
}

uint64_t rtc::TimeMicros(rtc *this)
{
  uint64_t v1;

  if (rtc::g_clock)
  {
    v1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v1 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
       / dword_253EA791C;
  }
  return v1 / 1000;
}

uint64_t rtc::TimeUTCMicros(rtc *this)
{
  timeval v2;

  if (rtc::g_clock)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock) / 1000;
  gettimeofday(&v2, 0);
  return v2.tv_usec + 1000000 * v2.tv_sec;
}

void dcsctp::Timer::~Timer(dcsctp::Timer *this)
{
  uint64_t v2;
  uint64_t v3;
  dcsctp::Timer *v4;
  uint64_t v5;
  dcsctp::Timer *v6;
  uint64_t v7;
  dcsctp::Timer *v8;

  if (*((_BYTE *)this + 156))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 17) + 24))(*((_QWORD *)this + 17));
    *((_DWORD *)this + 40) = 0;
    *((_BYTE *)this + 156) = 0;
  }
  v2 = *((_QWORD *)this + 16);
  if (!v2)
  {
    v8 = (dcsctp::Timer *)std::__throw_bad_function_call[abi:sn180100]();
    dcsctp::Timer::Start(v8);
    return;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  v3 = *((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (dcsctp::Timer *)*((_QWORD *)this + 16);
  if (v4 == (dcsctp::Timer *)((char *)this + 104))
  {
    v5 = 4;
    v4 = (dcsctp::Timer *)((char *)this + 104);
  }
  else
  {
    if (!v4)
      goto LABEL_11;
    v5 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v4 + 8 * v5))();
LABEL_11:
  v6 = (dcsctp::Timer *)*((_QWORD *)this + 12);
  if (v6 == (dcsctp::Timer *)((char *)this + 72))
  {
    v7 = 4;
    v6 = (dcsctp::Timer *)((char *)this + 72);
  }
  else
  {
    if (!v6)
      goto LABEL_16;
    v7 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v6 + 8 * v7))();
LABEL_16:
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

uint64_t dcsctp::Timer::Start(dcsctp::Timer *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  unsigned int v10;
  unint64_t v11;
  int v12;
  unsigned int v13;

  *((_DWORD *)this + 40) = 0;
  if (*((_BYTE *)this + 156))
  {
    v1 = (*((_DWORD *)this + 38) + 1);
    *((_DWORD *)this + 38) = v1;
    v2 = *((_QWORD *)this + 17);
    v3 = *((_QWORD *)this + 18);
    if ((unint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
    {
      v8 = v3 / 0x3E8uLL;
      if (v3 % 0x3E8uLL > 0x1F3)
        LODWORD(v8) = v8 + 1;
      if (-v3 % 0x3E8uLL <= 0x1F4)
        v9 = 0;
      else
        v9 = -1;
      if (v3 < 0)
        v10 = v9 - -v3 / 0x3E8uLL;
      else
        v10 = v8;
      return (*(uint64_t (**)(_QWORD, _QWORD, unint64_t))(*(_QWORD *)v2 + 32))(*((_QWORD *)this + 17), v10, v1 | ((unint64_t)*(unsigned int *)this << 32));
    }
    else
    {
      return (*(uint64_t (**)(_QWORD, uint64_t, unint64_t))(*(_QWORD *)v2 + 32))(*((_QWORD *)this + 17), 0x7FFFFFFFLL, v1 | ((unint64_t)*(unsigned int *)this << 32));
    }
  }
  else
  {
    *((_BYTE *)this + 156) = 1;
    v5 = (*((_DWORD *)this + 38) + 1);
    *((_DWORD *)this + 38) = v5;
    v6 = *((_QWORD *)this + 17);
    v7 = *((_QWORD *)this + 18);
    if ((unint64_t)(v7 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
    {
      v11 = v7 / 0x3E8uLL;
      if (v7 % 0x3E8uLL > 0x1F3)
        LODWORD(v11) = v11 + 1;
      if (-v7 % 0x3E8uLL <= 0x1F4)
        v12 = 0;
      else
        v12 = -1;
      if (v7 < 0)
        v13 = v12 - -v7 / 0x3E8uLL;
      else
        v13 = v11;
      return (*(uint64_t (**)(_QWORD, _QWORD, unint64_t))(*(_QWORD *)v6 + 16))(*((_QWORD *)this + 17), v13, v5 | ((unint64_t)*(unsigned int *)this << 32));
    }
    else
    {
      return (*(uint64_t (**)(_QWORD, uint64_t, unint64_t))(*(_QWORD *)v6 + 16))(*((_QWORD *)this + 17), 0x7FFFFFFFLL, v5 | ((unint64_t)*(unsigned int *)this << 32));
    }
  }
}

uint64_t dcsctp::Timer::Trigger(uint64_t result, int a2)
{
  unsigned int *v2;
  int v3;
  int v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  char *v22;
  size_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;

  if (*(_BYTE *)(result + 156))
  {
    v2 = (unsigned int *)result;
    if (*(_DWORD *)(result + 152) == a2)
    {
      v3 = *(_DWORD *)(result + 160);
      v4 = v3 + 1;
      *(_DWORD *)(result + 160) = v3 + 1;
      *(_BYTE *)(result + 156) = 0;
      if (!*(_BYTE *)(result + 48) || v3 < *(_DWORD *)(result + 44))
      {
        *(_BYTE *)(result + 156) = 1;
        v5 = *(_QWORD *)(result + 144);
        if (*(_DWORD *)(result + 40) == 1)
        {
          while (1)
          {
            v6 = __OFSUB__(v4, 1);
            if (--v4 < 0 != v6 || v5 >= 86400000000)
              break;
            v5 *= 2;
            if (v5 > *(_QWORD *)(result + 56))
            {
              v5 = *(_QWORD *)(result + 56);
              goto LABEL_12;
            }
          }
          if (v5 >= 86400000000)
            v5 = 86400000000;
        }
LABEL_12:
        v7 = (a2 + 1);
        *(_DWORD *)(result + 152) = v7;
        v8 = *(_QWORD *)(result + 136);
        if ((unint64_t)(v5 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
        {
          v10 = v5 / 0x3E8uLL;
          if (v5 % 0x3E8uLL > 0x1F3)
            LODWORD(v10) = v10 + 1;
          if (-v5 % 0x3E8uLL <= 0x1F4)
            v11 = 0;
          else
            v11 = -1;
          if (v5 < 0)
            v12 = v11 - -v5 / 0x3E8uLL;
          else
            v12 = v10;
          v9 = v12;
        }
        else
        {
          v9 = 0x7FFFFFFFLL;
        }
        (*(void (**)(uint64_t, uint64_t, unint64_t))(*(_QWORD *)v8 + 16))(v8, v9, v7 | ((unint64_t)*v2 << 32));
      }
      v13 = *((_QWORD *)v2 + 12);
      if (v13)
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 48))(v13);
        if (result >= 1 && result != *((_QWORD *)v2 + 18))
        {
          *((_QWORD *)v2 + 18) = result;
          if (*((_BYTE *)v2 + 156))
          {
            (*(void (**)(_QWORD))(**((_QWORD **)v2 + 17) + 24))(*((_QWORD *)v2 + 17));
            v14 = *((_QWORD *)v2 + 18);
            if (v2[10] == 1)
            {
              v15 = v2[40];
              while (1)
              {
                v6 = __OFSUB__(v15, 1);
                if (((--v15 & 0x80000000) != 0) != v6 || v14 >= 86400000000)
                  break;
                v14 *= 2;
                if (v14 > *((_QWORD *)v2 + 7))
                {
                  v14 = *((_QWORD *)v2 + 7);
                  goto LABEL_37;
                }
              }
              if (v14 >= 86400000000)
                v14 = 86400000000;
            }
LABEL_37:
            v16 = v2[38] + 1;
            v2[38] = v16;
            if ((unint64_t)(v14 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
            {
              v18 = v14 / 0x3E8uLL;
              if (v14 % 0x3E8uLL > 0x1F3)
                LODWORD(v18) = v18 + 1;
              if (-v14 % 0x3E8uLL <= 0x1F4)
                v19 = 0;
              else
                v19 = -1;
              if (v14 < 0)
                v20 = v19 - -v14 / 0x3E8uLL;
              else
                v20 = v18;
              v17 = v20;
            }
            else
            {
              v17 = 0x7FFFFFFFLL;
            }
            return (*(uint64_t (**)(_QWORD, uint64_t, unint64_t))(**((_QWORD **)v2 + 17) + 16))(*((_QWORD *)v2 + 17), v17, v16 | ((unint64_t)*v2 << 32));
          }
        }
      }
      else
      {
        v21 = std::__throw_bad_function_call[abi:sn180100]();
        return dcsctp::TimerManager::CreateTimer(v21, v22, v23, v24, v25, v26, v27, v28, v29);
      }
    }
  }
  return result;
}

uint64_t dcsctp::TimerManager::CreateTimer@<X0>(uint64_t a1@<X0>, char *a2@<X1>, size_t a3@<X2>, _QWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t *a9@<X8>)
{
  int v10;
  uint64_t v11;
  uint64_t v14;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  unsigned int *v35;
  uint64_t **v36;
  _QWORD *v37;
  unsigned int v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t result;
  uint64_t v43;
  uint64_t v44;
  int v45;
  _QWORD v46[3];
  _QWORD *v47;
  _QWORD v48[3];
  _QWORD *v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v10 = *(_DWORD *)(a1 + 56);
  v11 = (v10 + 1);
  *(_DWORD *)(a1 + 56) = v11;
  if (v10 == -2)
  {
LABEL_52:
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/net/dcsctp/timer/timer.cc", 148, "*id != std::numeric_limits<uint32_t>::max()", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int> const&)::t, a5, a6, a7, a8, 0xFFFFFFFFLL);
    goto LABEL_53;
  }
  v45 = *(_DWORD *)(a5 + 32);
  v14 = *(_QWORD *)(a1 + 24);
  if (!v14)
  {
LABEL_53:
    std::__throw_bad_function_call[abi:sn180100]();
    goto LABEL_54;
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, int *))(*(_QWORD *)v14 + 48))(&v44, v14, &v45);
  if (!v44)
  {
LABEL_54:
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/net/dcsctp/timer/timer.cc", 150, "timeout != nullptr", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v18, v19, v20, v21, v43);
    goto LABEL_55;
  }
  v22 = operator new();
  v23 = (_QWORD *)a4[3];
  if (v23)
  {
    if (v23 == a4)
    {
      v49 = v48;
      (*(void (**)(_QWORD *, _QWORD *))(*a4 + 24))(a4, v48);
    }
    else
    {
      v49 = (_QWORD *)a4[3];
      a4[3] = 0;
    }
  }
  else
  {
    v49 = 0;
  }
  v46[0] = &off_24C0C2558;
  v46[1] = a1;
  v46[2] = v11;
  v47 = v46;
  v24 = v44;
  v44 = 0;
  *(_DWORD *)v22 = v11;
  v25 = (char *)(v22 + 8);
  if (a3 >= 0x7FFFFFFFFFFFFFF8)
LABEL_55:
    abort();
  if (a3 <= 0x16)
  {
    *(_BYTE *)(v22 + 31) = a3;
    v26 = &v25[a3];
    if (v25 > a2)
      goto LABEL_17;
    goto LABEL_16;
  }
  v27 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((a3 | 7) != 0x17)
    v27 = a3 | 7;
  v28 = v27 + 1;
  v25 = (char *)operator new(v27 + 1);
  *(_QWORD *)(v22 + 16) = a3;
  *(_QWORD *)(v22 + 24) = v28 | 0x8000000000000000;
  *(_QWORD *)(v22 + 8) = v25;
  v26 = &v25[a3];
  if (v25 <= a2)
  {
LABEL_16:
    if (v26 <= a2)
      goto LABEL_17;
    __break(1u);
    goto LABEL_52;
  }
LABEL_17:
  if (a3)
    memmove(v25, a2, a3);
  *v26 = 0;
  v29 = *(_OWORD *)(a5 + 16);
  *(_OWORD *)(v22 + 32) = *(_OWORD *)a5;
  *(_OWORD *)(v22 + 48) = v29;
  *(_QWORD *)(v22 + 64) = *(_QWORD *)(a5 + 32);
  if (!v49)
  {
    *(_QWORD *)(v22 + 96) = 0;
    goto LABEL_23;
  }
  if (v49 != v48)
  {
    *(_QWORD *)(v22 + 96) = v49;
    v49 = 0;
LABEL_23:
    *(_QWORD *)(v22 + 128) = v22 + 104;
    (*(void (**)(_QWORD *))(v46[0] + 24))(v46);
    v30 = v47;
    goto LABEL_24;
  }
  *(_QWORD *)(v22 + 96) = v22 + 72;
  (*(void (**)(_QWORD *))(v48[0] + 24))(v48);
  if (v47)
  {
    if (v47 == v46)
      goto LABEL_23;
    v30 = 0;
    *(_QWORD *)(v22 + 128) = v47;
    v47 = 0;
  }
  else
  {
    v30 = 0;
    *(_QWORD *)(v22 + 128) = 0;
  }
LABEL_24:
  v31 = *(_QWORD *)a5;
  *(_QWORD *)(v22 + 136) = v24;
  *(_QWORD *)(v22 + 144) = v31;
  *(_DWORD *)(v22 + 152) = 0;
  *(_BYTE *)(v22 + 156) = 0;
  *(_DWORD *)(v22 + 160) = 0;
  *a9 = v22;
  if (v30 == v46)
  {
    v32 = 4;
    v30 = v46;
  }
  else
  {
    if (!v30)
      goto LABEL_29;
    v32 = 5;
  }
  (*(void (**)(void))(*v30 + 8 * v32))();
LABEL_29:
  v33 = v49;
  if (v49 == v48)
  {
    v34 = 4;
    v33 = v48;
  }
  else
  {
    if (!v49)
      goto LABEL_34;
    v34 = 5;
  }
  (*(void (**)(void))(*v33 + 8 * v34))();
LABEL_34:
  v36 = (uint64_t **)(a1 + 40);
  v35 = *(unsigned int **)(a1 + 40);
  if (v35)
  {
    while (1)
    {
      while (1)
      {
        v37 = v35;
        v38 = v35[8];
        if (v11 >= v38)
          break;
        v35 = (unsigned int *)*v37;
        v36 = (uint64_t **)v37;
        if (!*v37)
          goto LABEL_41;
      }
      if (v38 >= v11)
        break;
      v35 = (unsigned int *)v37[1];
      if (!v35)
      {
        v36 = (uint64_t **)(v37 + 1);
        goto LABEL_41;
      }
    }
  }
  else
  {
    v37 = (_QWORD *)(a1 + 40);
LABEL_41:
    v39 = v37;
    v37 = operator new(0x30uLL);
    *((_DWORD *)v37 + 8) = v11;
    v37[5] = 0;
    *v37 = 0;
    v37[1] = 0;
    v37[2] = v39;
    *v36 = v37;
    v40 = **(_QWORD **)(a1 + 32);
    v41 = v37;
    if (v40)
    {
      *(_QWORD *)(a1 + 32) = v40;
      v41 = *v36;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 40), v41);
    ++*(_QWORD *)(a1 + 48);
  }
  v37[5] = v22;
  result = v44;
  v44 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void std::__function::__func<dcsctp::TimerManager::CreateTimer(std::string_view,std::function<webrtc::TimeDelta ()(void)>,dcsctp::TimerOptions const&)::$_0,std::allocator<dcsctp::TimerManager::CreateTimer(std::string_view,std::function<webrtc::TimeDelta ()(void)>,dcsctp::TimerOptions const&)::$_0>,void ()(void)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

__n128 std::__function::__func<dcsctp::TimerManager::CreateTimer(std::string_view,std::function<webrtc::TimeDelta ()(void)>,dcsctp::TimerOptions const&)::$_0,std::allocator<dcsctp::TimerManager::CreateTimer(std::string_view,std::function<webrtc::TimeDelta ()(void)>,dcsctp::TimerOptions const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24C0C2558;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<dcsctp::TimerManager::CreateTimer(std::string_view,std::function<webrtc::TimeDelta ()(void)>,dcsctp::TimerOptions const&)::$_0,std::allocator<dcsctp::TimerManager::CreateTimer(std::string_view,std::function<webrtc::TimeDelta ()(void)>,dcsctp::TimerOptions const&)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24C0C2558;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<dcsctp::TimerManager::CreateTimer(std::string_view,std::function<webrtc::TimeDelta ()(void)>,dcsctp::TimerOptions const&)::$_0,std::allocator<dcsctp::TimerManager::CreateTimer(std::string_view,std::function<webrtc::TimeDelta ()(void)>,dcsctp::TimerOptions const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  _QWORD *v2;
  uint64_t *v3;
  unsigned int v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  uint64_t *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  BOOL v13;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = (uint64_t *)v2[5];
  if (v3)
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = v2 + 5;
    v6 = v2[5];
    do
    {
      v7 = *(_DWORD *)(v6 + 32);
      v8 = v7 >= v4;
      if (v7 >= v4)
        v9 = (uint64_t *)v6;
      else
        v9 = (uint64_t *)(v6 + 8);
      if (v8)
        v5 = (_QWORD *)v6;
      v6 = *v9;
    }
    while (*v9);
    if (v5 != v2 + 5 && *((_DWORD *)v5 + 8) <= v4)
    {
      v10 = (_QWORD *)v5[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
      else
      {
        v12 = v5;
        do
        {
          v11 = (_QWORD *)v12[2];
          v13 = *v11 == (_QWORD)v12;
          v12 = v11;
        }
        while (!v13);
      }
      if ((_QWORD *)v2[4] == v5)
        v2[4] = v11;
      --v2[6];
      std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v3, v5);
      operator delete(v5);
    }
  }
}

uint64_t webrtc::TimestampExtrapolator::Update(uint64_t this, Timestamp a2, unsigned int a3)
{
  uint64_t v3;
  BOOL v4;
  BOOL v5;
  int64_t var0;
  unint64_t v7;
  unint64_t v8;
  int64_t v9;
  unsigned int v10;
  BOOL v11;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  double v20;
  double v21;
  double v22;
  double *v23;
  double v24;
  double *v25;
  double v26;
  double v27;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  unsigned int v41;
  unint64_t v42;
  double v43;

  v3 = *(_QWORD *)(this + 56);
  v4 = a2.var0 == 0x7FFFFFFFFFFFFFFFLL || v3 == 0x8000000000000000;
  if (!v4
    && (a2.var0 == 0x8000000000000000 || (v3 != 0x7FFFFFFFFFFFFFFFLL ? (v5 = a2.var0 - v3 < 10000001) : (v5 = 1), v5)))
  {
    *(Timestamp *)(this + 56) = a2;
    var0 = *(_QWORD *)(this + 48);
    v7 = 0x7FFFFFFFFFFFFFFFLL;
    if (a2.var0 == 0x7FFFFFFFFFFFFFFFLL)
      goto LABEL_21;
  }
  else
  {
    *(Timestamp *)(this + 48) = a2;
    *(Timestamp *)(this + 56) = a2;
    if (*(_BYTE *)(this + 72))
      *(_BYTE *)(this + 72) = 0;
    if (*(_BYTE *)(this + 104))
      *(_BYTE *)(this + 104) = 0;
    *(_OWORD *)this = xmmword_208F1C8D0;
    *(_QWORD *)(this + 32) = 0;
    *(_QWORD *)(this + 40) = 0x4202A05F20000000;
    *(_QWORD *)(this + 16) = 0x3FF0000000000000;
    *(_QWORD *)(this + 24) = 0;
    *(_QWORD *)(this + 80) = 0;
    *(_QWORD *)(this + 88) = 0;
    *(_DWORD *)(this + 112) = 0;
    *(_QWORD *)(this + 120) = 0;
    *(_QWORD *)(this + 128) = 0;
    var0 = a2.var0;
    v7 = 0x7FFFFFFFFFFFFFFFLL;
    if (a2.var0 == 0x7FFFFFFFFFFFFFFFLL)
      goto LABEL_21;
  }
  v8 = 0x8000000000000000;
  if (var0 != 0x8000000000000000)
  {
    if (a2.var0 == 0x8000000000000000
      || var0 == 0x7FFFFFFFFFFFFFFFLL
      || (v8 = a2.var0 - var0, v7 = a2.var0 - var0, a2.var0 - var0 < 0))
    {
      v15 = -(uint64_t)v8;
      v16 = -(uint64_t)v8 / 0x3E8uLL;
      if (v15 % 0x3E8 <= 0x1F4)
        v17 = 0;
      else
        v17 = -1;
      v9 = v17 - v16;
      if (*(_BYTE *)(this + 92))
        goto LABEL_25;
LABEL_37:
      v14 = a3;
      goto LABEL_38;
    }
  }
LABEL_21:
  if (v7 % 0x3E8 <= 0x1F3)
    v9 = v7 / 0x3E8;
  else
    v9 = v7 / 0x3E8 + 1;
  if (!*(_BYTE *)(this + 92))
    goto LABEL_37;
LABEL_25:
  v10 = *(_DWORD *)(this + 88);
  v11 = a3 >= v10;
  v12 = a3 - v10;
  v13 = (_DWORD)v12 != 0 && v11;
  if ((_DWORD)v12 != 0x80000000)
    v13 = (int)v12 >= 0;
  if (!v13)
    v12 |= 0xFFFFFFFF00000000;
  v14 = v12 + *(_QWORD *)(this + 80);
LABEL_38:
  v18 = (double)v9;
  *(_QWORD *)(this + 80) = v14;
  *(_DWORD *)(this + 88) = a3;
  *(_BYTE *)(this + 92) = 1;
  if (*(_BYTE *)(this + 72))
  {
    v19 = *(_QWORD *)(this + 64);
    v21 = *(double *)this;
    v20 = *(double *)(this + 8);
  }
  else
  {
    v21 = *(double *)this;
    v20 = -(*(double *)this * v18);
    *(double *)(this + 8) = v20;
    *(_QWORD *)(this + 64) = v14;
    *(_BYTE *)(this + 72) = 1;
    v19 = v14;
  }
  v22 = (double)v14 - (double)v19 - v18 * v21 - v20;
  v43 = v22;
  if (v22 <= 0.0)
  {
    v42 = 0xC0BB580000000000;
    v23 = &v43;
    if (v22 < -7000.0)
      v23 = (double *)&v42;
  }
  else
  {
    if (v22 <= 7000.0)
      v23 = &v43;
  }
  v24 = *v23;
  v25 = (double *)(this + 120);
  v26 = v24 + *(double *)(this + 120) + -6600.0;
  if (v26 < 0.0)
    v26 = 0.0;
  v27 = v24 + *(double *)(this + 128) + 6600.0;
  if (v27 > 0.0)
    v27 = 0.0;
  *v25 = v26;
  *(double *)(this + 128) = v27;
  if (v26 > 60000.0 || v27 < -60000.0)
  {
    *v25 = 0.0;
    *(_QWORD *)(this + 128) = 0;
    if (*(_DWORD *)(this + 112) >= 2u)
      *(_QWORD *)(this + 40) = 0x4202A05F20000000;
  }
  if (!*(_BYTE *)(this + 104) || v14 >= *(_QWORD *)(this + 96))
  {
    v29 = *(double *)(this + 16);
    v30 = *(double *)(this + 24);
    v31 = v30 + v29 * v18;
    v32 = *(double *)(this + 32);
    v33 = *(double *)(this + 40);
    v34 = v33 + v32 * v18;
    v35 = v18 * v31 + 1.0 + v34;
    v36 = v31 / v35;
    v37 = v34 / v35;
    *(double *)this = v21 + v36 * v22;
    *(double *)(this + 8) = v20 + v37 * v22;
    v38 = v29 - (v32 * v36 + v36 * v18 * v29);
    v39 = v30 - (v33 * v36 + v36 * v18 * v30);
    v40 = v37 * v18;
    *(double *)(this + 32) = v32 - (v32 * v37 + v40 * v29);
    *(double *)(this + 40) = v33 - (v33 * v37 + v40 * v30);
    *(double *)(this + 16) = v38;
    *(double *)(this + 24) = v39;
    *(_QWORD *)(this + 96) = v14;
    *(_BYTE *)(this + 104) = 1;
    v41 = *(_DWORD *)(this + 112);
    if (v41 <= 1)
      *(_DWORD *)(this + 112) = v41 + 1;
  }
  return this;
}

unint64_t webrtc::TimestampExtrapolator::ExtrapolateLocalTime(unint64_t this, unsigned int a2)
{
  unsigned int v2;
  BOOL v3;
  uint64_t v4;
  _BOOL4 v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  unint64_t v13;

  if (*(_BYTE *)(this + 92))
  {
    v2 = *(_DWORD *)(this + 88);
    v3 = a2 >= v2;
    v4 = a2 - v2;
    v5 = (_DWORD)v4 != 0 && v3;
    if ((_DWORD)v4 != 0x80000000)
      v5 = (int)v4 >= 0;
    if (!v5)
      v4 |= 0xFFFFFFFF00000000;
    v6 = v4 + *(_QWORD *)(this + 80);
    if (!*(_BYTE *)(this + 72))
      return 0;
  }
  else
  {
    v6 = a2;
    if (!*(_BYTE *)(this + 72))
      return 0;
  }
  if (*(_DWORD *)(this + 112) <= 1u)
  {
    if (!*(_BYTE *)(this + 104))
    {
      __break(1u);
      return this;
    }
    v7 = (double)(v6 - *(_QWORD *)(this + 96)) / 90.0 * 1000.0;
    if (v7 == INFINITY)
    {
      v8 = 0x7FFFFFFFFFFFFFFFLL;
      v9 = *(_QWORD *)(this + 56);
      v10 = v9 + 0x7FFFFFFFFFFFFFFFLL;
      if (v9 + 0x7FFFFFFFFFFFFFFFLL < 0)
        return 0;
      goto LABEL_27;
    }
    if (v7 == -INFINITY)
    {
      v8 = 0x8000000000000000;
      v9 = *(_QWORD *)(this + 56);
      v10 = v9 + 0x8000000000000000;
      if ((uint64_t)(v9 + 0x8000000000000000) >= 0)
      {
LABEL_27:
        if (v9 == 0x8000000000000000 || v8 == 0x8000000000000000)
          v10 = 0x8000000000000000;
        if (v9 == 0x7FFFFFFFFFFFFFFFLL || v8 == 0x7FFFFFFFFFFFFFFFLL)
          return 0x7FFFFFFFFFFFFFFFLL;
        else
          return v10;
      }
    }
    else
    {
      v8 = (uint64_t)v7;
      v9 = *(_QWORD *)(this + 56);
      v10 = v9 + (uint64_t)v7;
      if (v10 >= 0)
        goto LABEL_27;
    }
    return 0;
  }
  if (*(double *)this < 0.001)
    return *(_QWORD *)(this + 48) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(this + 48);
  v11 = ((double)(v6 - *(_QWORD *)(this + 64)) - *(double *)(this + 8)) / *(double *)this + 0.5;
  v12 = *(_QWORD *)(this + 48);
  v13 = v12 + 1000 * (uint64_t)v11;
  if ((v13 & 0x8000000000000000) != 0)
    return 0;
  if (v12 == 0x8000000000000000)
    v13 = 0x8000000000000000;
  if (v12 != 0x7FFFFFFFFFFFFFFFLL)
    return v13;
  return v12;
}

uint64_t webrtc::TimestampScaler::Reset(uint64_t this)
{
  *(_BYTE *)(this + 8) = 0;
  return this;
}

uint64_t webrtc::TimestampScaler::ToInternal(uint64_t result, unsigned int *a2)
{
  if (a2)
  {
    result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)result + 40))(result, *a2, *((unsigned __int8 *)a2 + 6));
    *a2 = result;
  }
  return result;
}

uint64_t webrtc::TimestampScaler::ToInternal(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *(_QWORD *)(a2 + 8);
  if (v2 != a2)
  {
    v4 = result;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 24))(v4, v2 + 16);
      v2 = *(_QWORD *)(v2 + 8);
    }
    while (v2 != a2);
  }
  return result;
}

uint64_t webrtc::TimestampScaler::ToInternal(webrtc::TimestampScaler *this, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  result = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4), a3);
  if (!result)
    return a2;
  v6 = result;
  if (*(unsigned __int8 *)(result + 128) - 1 <= 1)
  {
    v7 = *((_DWORD *)this + 3);
    v8 = *((_DWORD *)this + 4);
    if (v7 == v8)
      return a2;
    goto LABEL_9;
  }
  if (*(_BYTE *)(result + 128))
    goto LABEL_6;
  result = *(_QWORD *)(result + 112);
  if (result)
    goto LABEL_17;
  (*(void (**)(uint64_t *__return_ptr, _QWORD, uint64_t, _QWORD, _QWORD))(**(_QWORD **)(v6 + 104) + 48))(&v14, *(_QWORD *)(v6 + 104), v6 + 24, *(_QWORD *)(v6 + 88), *(_QWORD *)(v6 + 96));
  result = v14;
  v14 = 0;
  v11 = *(_QWORD *)(v6 + 112);
  *(_QWORD *)(v6 + 112) = result;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
    v12 = v14;
    v14 = 0;
    if (v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
    result = *(_QWORD *)(v6 + 112);
  }
  if (result)
  {
LABEL_17:
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 88))(result);
    *((_DWORD *)this + 3) = v7;
    v8 = *(_DWORD *)(v6 + 48);
    if (!v8)
      goto LABEL_18;
  }
  else
  {
LABEL_6:
    if (!*(_BYTE *)(v6 + 124))
    {
      __break(1u);
      return result;
    }
    v7 = *(_DWORD *)(v6 + 120);
    *((_DWORD *)this + 3) = v7;
    v8 = *(_DWORD *)(v6 + 48);
    if (!v8)
    {
LABEL_18:
      *((_DWORD *)this + 4) = v7;
      return a2;
    }
  }
  *((_DWORD *)this + 4) = v8;
  if (v7 == v8)
    return a2;
LABEL_9:
  if (*((_BYTE *)this + 8))
  {
    v10 = *((_DWORD *)this + 5);
    v9 = *((_DWORD *)this + 6);
  }
  else
  {
    *((_BYTE *)this + 8) = 1;
    v9 = a2;
    v10 = a2;
  }
  *((_DWORD *)this + 5) = a2;
  v13 = (uint64_t)((a2 - (unint64_t)v10) * v7) / v8;
  *((_DWORD *)this + 6) = v9 + v13;
  return (v9 + v13);
}

uint64_t webrtc::TimestampScaler::ToExternal(webrtc::TimestampScaler *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  if (*((_BYTE *)this + 8))
  {
    v2 = *((int *)this + 3);
    v3 = *((int *)this + 4);
    if ((_DWORD)v2 != (_DWORD)v3)
      return *((_DWORD *)this + 5)
           + ((uint64_t)((a2 - (unint64_t)*((unsigned int *)this + 6)) * v3) / v2);
  }
  return a2;
}

void webrtc::TimestampScaler::~TimestampScaler(webrtc::TimestampScaler *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::VCMTiming::VCMTiming(uint64_t a1, uint64_t a2, uint64_t a3)
{
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *sig;
  pthread_mutexattr_t v13;
  unsigned __int8 v14;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = off_24C0C25E8;
  v6 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutexattr_init(&v13);
  pthread_mutexattr_setpolicy_np(&v13, 3);
  pthread_mutex_init(v6, &v13);
  pthread_mutexattr_destroy(&v13);
  *(_QWORD *)(a1 + 72) = a2;
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  v8 = operator new();
  *(_BYTE *)(v8 + 72) = 0;
  *(_BYTE *)(v8 + 96) = 0;
  *(_BYTE *)(v8 + 104) = 0;
  *(_BYTE *)(v8 + 64) = 0;
  *(_QWORD *)(v8 + 48) = v7;
  *(_QWORD *)(v8 + 56) = v7;
  *(_OWORD *)v8 = xmmword_208F1C8D0;
  *(_QWORD *)(v8 + 32) = 0;
  *(_QWORD *)(v8 + 40) = 0x4202A05F20000000;
  *(_QWORD *)(v8 + 16) = 0x3FF0000000000000;
  *(_QWORD *)(v8 + 24) = 0;
  *(_QWORD *)(v8 + 80) = 0;
  *(_QWORD *)(v8 + 88) = 0;
  *(_DWORD *)(v8 + 112) = 0;
  *(_QWORD *)(v8 + 120) = 0;
  *(_QWORD *)(v8 + 128) = 0;
  *(_QWORD *)(a1 + 80) = v8;
  v9 = operator new();
  *(_DWORD *)v9 = 0;
  *(_OWORD *)(v9 + 8) = 0u;
  *(_OWORD *)(v9 + 24) = 0u;
  *(_OWORD *)(v9 + 40) = 0u;
  *(_DWORD *)(v9 + 56) = 1064514355;
  *(_QWORD *)(v9 + 72) = 0;
  *(_QWORD *)(v9 + 64) = v9 + 72;
  *(_QWORD *)(v9 + 80) = 0;
  *(_QWORD *)(v9 + 88) = v9 + 72;
  *(_QWORD *)(v9 + 96) = 0;
  *(_QWORD *)(a1 + 88) = v9;
  *(_OWORD *)(a1 + 96) = xmmword_208F1C8F0;
  *(_BYTE *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 272) = 0;
  *(_BYTE *)(a1 + 276) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 112) = 10000000;
  *(_DWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 280) = off_24C0B4170;
  *(_QWORD *)(a1 + 288) = 0;
  *(_BYTE *)(a1 + 335) = 10;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 304) = 0;
  if (a1 + 312 <= (unint64_t)"min_pacing" && a1 + 322 > (unint64_t)"min_pacing")
    goto LABEL_11;
  strcpy((char *)(a1 + 312), "min_pacing");
  *(_BYTE *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 280) = &unk_24C0B0268;
  *(_QWORD *)(a1 + 344) = 8000;
  *(_QWORD *)(a1 + 352) = 0;
  v15[0] = a1 + 280;
  (*(void (**)(pthread_mutexattr_t *__return_ptr, uint64_t, const char *, uint64_t))(*(_QWORD *)a3 + 16))(&v13, a3, "WebRTC-ZeroPlayoutDelay", 23);
  if (((char)v14 & 0x80000000) == 0)
  {
    v10 = v14;
    sig = (char *)&v13;
    goto LABEL_8;
  }
  v10 = *(_QWORD *)v13.__opaque;
  if ((*(_QWORD *)v13.__opaque & 0x8000000000000000) != 0
    || (sig = (char *)v13.__sig, *(_QWORD *)v13.__opaque) && !v13.__sig)
  {
LABEL_11:
    __break(1u);
  }
LABEL_8:
  webrtc::ParseFieldTrial(v15, 1, sig, v10);
  if ((char)v14 < 0)
    operator delete((void *)v13.__sig);
  return a1;
}

uint64_t webrtc::VCMTiming::Reset(webrtc::VCMTiming *this)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v3 = *((_QWORD *)this + 10);
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 9) + 16))(*((_QWORD *)this + 9));
  *(_QWORD *)(v3 + 48) = v4;
  *(_QWORD *)(v3 + 56) = v4;
  if (*(_BYTE *)(v3 + 72))
    *(_BYTE *)(v3 + 72) = 0;
  if (*(_BYTE *)(v3 + 104))
    *(_BYTE *)(v3 + 104) = 0;
  *(_OWORD *)v3 = xmmword_208F1C8D0;
  *(_QWORD *)(v3 + 32) = 0;
  *(_QWORD *)(v3 + 40) = 0x4202A05F20000000;
  *(_QWORD *)(v3 + 16) = 0x3FF0000000000000;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 80) = 0;
  *(_QWORD *)(v3 + 88) = 0;
  *(_DWORD *)(v3 + 112) = 0;
  *(_QWORD *)(v3 + 120) = 0;
  *(_QWORD *)(v3 + 128) = 0;
  v5 = operator new();
  *(_DWORD *)v5 = 0;
  *(_OWORD *)(v5 + 8) = 0u;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_OWORD *)(v5 + 40) = 0u;
  *(_DWORD *)(v5 + 56) = 1064514355;
  *(_QWORD *)(v5 + 72) = 0;
  *(_QWORD *)(v5 + 64) = v5 + 72;
  *(_QWORD *)(v5 + 80) = 0;
  *(_QWORD *)(v5 + 88) = v5 + 72;
  *(_QWORD *)(v5 + 96) = 0;
  v6 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = v5;
  if (v6)
  {
    std::__tree<sigslot::_signal_base_interface *>::destroy(v6 + 64, *(_QWORD **)(v6 + 72));
    std::deque<webrtc::DecodeTimePercentileFilter::Sample>::~deque[abi:sn180100]((void **)(v6 + 8));
    MEMORY[0x20BD0ADEC](v6, 0x10A0C4048E4D329);
  }
  *((_OWORD *)this + 6) = xmmword_208F1C8F0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  return pthread_mutex_unlock(v2);
}

void webrtc::`anonymous namespace'::CheckDelaysValid(webrtc::_anonymous_namespace_ *this, TimeDelta a2, TimeDelta a3)
{
  uint64_t v3;
  uint64_t v4;
  TimeDelta v7;
  TimeDelta v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  char v17;
  _QWORD v18[3];
  _QWORD v19[2];
  std::string v20;
  _QWORD *v21;
  _QWORD v22[2];
  std::string v23;
  _QWORD *v24;
  std::string v25;
  uint64_t v26;
  uint64_t v27;

  if ((uint64_t)this > a2.var0)
  {
    v26 = v3;
    v27 = v4;
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
    {
      v18[0] = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_c"
               "oding/timing/timing.cc";
      v18[1] = 259;
      v18[2] = &v17;
      v19[0] = "Playout delays set incorrectly: min playout delay (";
      v19[1] = v18;
      webrtc::ToString(this, v7, (char *)&v23);
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&v20, v23.__r_.__value_.__l.__data_, v23.__r_.__value_.__l.__size_);
        v21 = v19;
        if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v23.__r_.__value_.__l.__data_);
      }
      else
      {
        v20 = v23;
        v21 = v19;
      }
      v22[0] = ") > max playout delay (";
      v22[1] = &v20;
      webrtc::ToString((webrtc *)a2.var0, v8, (char *)&v25);
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&v23, v25.__r_.__value_.__l.__data_, v25.__r_.__value_.__l.__size_);
        v16 = v22;
        v24 = v22;
        if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v25.__r_.__value_.__l.__data_);
          v16 = v24;
        }
      }
      else
      {
        v23 = v25;
        v16 = v22;
        v24 = v22;
      }
      rtc::webrtc_logging_impl::Log("\r\t\n\t\n\t", v9, v10, v11, v12, v13, v14, v15, **(_QWORD **)(*(_QWORD *)(v16[1] + 24) + 8));
      if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          return;
        goto LABEL_13;
      }
      operator delete(v23.__r_.__value_.__l.__data_);
      if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
LABEL_13:
        operator delete(v20.__r_.__value_.__l.__data_);
    }
  }
}

uint64_t webrtc::VCMTiming::UpdateCurrentDelay(webrtc::VCMTiming *this, Timestamp a2, Timestamp a3)
{
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v16;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  int64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  uint64_t v28;
  unint64_t v30;

  v6 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v7 = *((_QWORD *)this + 15);
  v8 = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 != 0x7FFFFFFFFFFFFFFFLL)
  {
    v9 = *((_QWORD *)this + 11);
    if (*(_QWORD *)(v9 + 80))
      v10 = 1000 * *(int *)(*(_QWORD *)(v9 + 88) + 32);
    else
      v10 = 0;
    v11 = v10 + v7;
    v12 = 0x8000000000000000;
    if (v7 != 0x8000000000000000)
      v7 = v11;
    v13 = *((_QWORD *)this + 12);
    if (v13 != 0x8000000000000000 && v7 != 0x8000000000000000)
      v12 = v7 + v13;
    if (v7 == 0x7FFFFFFFFFFFFFFFLL || v13 == 0x7FFFFFFFFFFFFFFFLL)
      v8 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v8 = v12;
  }
  v16 = *((_QWORD *)this + 13);
  if (v16 <= v8)
    v16 = v8;
  if (a3.var0 == 0x7FFFFFFFFFFFFFFFLL || a2.var0 == 0x8000000000000000)
    goto LABEL_55;
  v18 = a3.var0 == 0x8000000000000000 || a2.var0 == 0x7FFFFFFFFFFFFFFFLL;
  v19 = *((_QWORD *)this + 11);
  if (*(_QWORD *)(v19 + 80))
  {
    v20 = 1000 * *(int *)(*(_QWORD *)(v19 + 88) + 32);
    if (v18)
      goto LABEL_34;
  }
  else
  {
    v20 = 0;
    if (v18)
    {
LABEL_34:
      v22 = 0x8000000000000000;
      goto LABEL_35;
    }
  }
  v21 = a3.var0 - a2.var0;
  if (a3.var0 - a2.var0 == 0x7FFFFFFFFFFFFFFFLL)
  {
LABEL_55:
    v27 = (unint64_t *)((char *)this + 128);
    goto LABEL_56;
  }
  if (v21 == 0x8000000000000000)
    goto LABEL_34;
  v22 = v20 + v21;
  if (v22 == 0x7FFFFFFFFFFFFFFFLL)
    goto LABEL_55;
LABEL_35:
  v23 = *((_QWORD *)this + 12);
  if (v23 == 0x7FFFFFFFFFFFFFFFLL)
    goto LABEL_55;
  v24 = 0x8000000000000000;
  if (v22 == 0x8000000000000000 || v23 == 0x8000000000000000 || (v24 = v23 + v22, (uint64_t)(v23 + v22) < 0))
  {
    v25 = -(uint64_t)v24 % 0x3E8uLL <= 0x1F4 ? 0 : -1;
    if ((uint64_t)(-(uint64_t)v24 / 0x3E8uLL) > v25)
      return pthread_mutex_unlock(v6);
  }
  v28 = *((_QWORD *)this + 16);
  v27 = (unint64_t *)((char *)this + 128);
  v26 = v28;
  if (v24 != 0x7FFFFFFFFFFFFFFFLL && v26 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v24 == 0x8000000000000000 || v26 == 0x8000000000000000 || (uint64_t)(v26 + v24) <= v16)
    {
      if (v26 == 0x8000000000000000 || v24 == 0x8000000000000000)
        v30 = 0x8000000000000000;
      else
        v30 = v26 + v24;
      goto LABEL_57;
    }
    goto LABEL_59;
  }
LABEL_56:
  v30 = 0x7FFFFFFFFFFFFFFFLL;
  if (v16 == 0x7FFFFFFFFFFFFFFFLL)
  {
LABEL_57:
    *v27 = v30;
    return pthread_mutex_unlock(v6);
  }
LABEL_59:
  *v27 = v16;
  return pthread_mutex_unlock(v6);
}

uint64_t webrtc::VCMTiming::IncomingTimestamp(webrtc::VCMTiming *this, unsigned int a2, Timestamp a3)
{
  pthread_mutex_t *v6;
  Timestamp v7;

  v6 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v7.var0 = a3.var0;
  webrtc::TimestampExtrapolator::Update(*((_QWORD *)this + 10), v7, a2);
  return pthread_mutex_unlock(v6);
}

unint64_t webrtc::VCMTiming::RenderTime(webrtc::VCMTiming *this, unsigned int a2, Timestamp a3)
{
  pthread_mutex_t *v6;
  unint64_t v7;
  unint64_t v8;
  char v9;
  int64_t var0;
  uint64_t v11;
  uint64_t v12;
  BOOL v14;
  unint64_t v15;

  v6 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  if (*((_QWORD *)this + 13) || *((uint64_t *)this + 14) >= 500001)
  {
    v8 = webrtc::TimestampExtrapolator::ExtrapolateLocalTime(*((_QWORD *)this + 10), a2);
    if (v9)
      var0 = v8;
    else
      var0 = a3.var0;
    v11 = *((_QWORD *)this + 13);
    v12 = *((_QWORD *)this + 14);
    if (*((_QWORD *)this + 16) < v12)
      v12 = *((_QWORD *)this + 16);
    if (v12 > v11)
      v11 = v12;
    v7 = 0x7FFFFFFFFFFFFFFFLL;
    if (var0 != 0x7FFFFFFFFFFFFFFFLL && v11 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v14 = v11 == 0x8000000000000000 || var0 == 0x8000000000000000;
      v15 = v11 + var0;
      if (v14)
        v7 = 0x8000000000000000;
      else
        v7 = v15;
    }
  }
  else
  {
    v7 = 0;
  }
  pthread_mutex_unlock(v6);
  return v7;
}

uint64_t webrtc::VCMTiming::MaxWaitingTime(webrtc::VCMTiming *this, Timestamp a2, Timestamp a3, char a4)
{
  pthread_mutex_t *v8;
  uint64_t v9;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v20;
  uint64_t v22;
  unint64_t v23;
  uint64_t v25;
  uint64_t v26;

  v8 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  if (!a2.var0)
  {
    v14 = *((_QWORD *)this + 43);
    if (v14 >= 1 && !*((_QWORD *)this + 13) && *((uint64_t *)this + 14) >= 1)
    {
      if ((a4 & 1) != 0)
      {
        v9 = 0;
      }
      else
      {
        v22 = *((_QWORD *)this + 44);
        v23 = v22 + v14;
        if (v22 == 0x8000000000000000)
          v23 = 0x8000000000000000;
        if (v22 == 0x7FFFFFFFFFFFFFFFLL || v14 == 0x7FFFFFFFFFFFFFFFLL)
          v25 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v25 = v23;
        v26 = v25 - a3.var0;
        if (a3.var0 == 0x8000000000000000 || v25 == 0x7FFFFFFFFFFFFFFFLL)
          v26 = 0x7FFFFFFFFFFFFFFFLL;
        if (v25 > a3.var0)
          v9 = v26;
        else
          v9 = 0;
      }
      goto LABEL_33;
    }
  }
  v9 = 0x7FFFFFFFFFFFFFFFLL;
  if (a2.var0 == 0x7FFFFFFFFFFFFFFFLL || a3.var0 == 0x8000000000000000)
    goto LABEL_33;
  v11 = a2.var0 == 0x8000000000000000 || a3.var0 == 0x7FFFFFFFFFFFFFFFLL;
  v12 = *((_QWORD *)this + 11);
  if (*(_QWORD *)(v12 + 80))
  {
    v13 = -1000 * *(int *)(*(_QWORD *)(v12 + 88) + 32);
    if (v11)
      goto LABEL_21;
  }
  else
  {
    v13 = 0;
    if (v11)
      goto LABEL_21;
  }
  v15 = a2.var0 - a3.var0;
  if (a2.var0 - a3.var0 == 0x7FFFFFFFFFFFFFFFLL)
    goto LABEL_33;
  if (v15 != 0x8000000000000000)
  {
    v16 = v13 + v15;
    goto LABEL_22;
  }
LABEL_21:
  v16 = 0x8000000000000000;
LABEL_22:
  v17 = *((_QWORD *)this + 12);
  v18 = v16 - v17;
  if (v17 == 0x7FFFFFFFFFFFFFFFLL || v16 == 0x8000000000000000)
    v18 = 0x8000000000000000;
  if (v17 == 0x8000000000000000)
    v20 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v16 == 0x7FFFFFFFFFFFFFFFLL)
    v9 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v9 = v20;
LABEL_33:
  pthread_mutex_unlock(v8);
  return v9;
}

uint64_t webrtc::VCMTiming::GetTimings@<X0>(webrtc::VCMTiming *this@<X0>, uint64_t a2@<X8>)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v24;

  v4 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v5 = *((_QWORD *)this + 15);
  *(_QWORD *)a2 = *((_QWORD *)this + 33);
  *(_QWORD *)(a2 + 8) = v5;
  v6 = *((_QWORD *)this + 11);
  v7 = *(_QWORD *)(v6 + 80);
  if (v7)
    v8 = 1000 * *(int *)(*(_QWORD *)(v6 + 88) + 32);
  else
    v8 = 0;
  v9 = *((_QWORD *)this + 12);
  *(_QWORD *)(a2 + 16) = v8;
  *(_QWORD *)(a2 + 24) = v9;
  v10 = *(_OWORD *)((char *)this + 104);
  *(_OWORD *)(a2 + 32) = v10;
  v11 = 0x7FFFFFFFFFFFFFFFLL;
  if (v5 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v7)
      v12 = 1000 * *(int *)(*(_QWORD *)(v6 + 88) + 32);
    else
      v12 = 0;
    v13 = v12 + v5;
    v14 = 0x8000000000000000;
    if (v5 != 0x8000000000000000)
      v5 = v13;
    v11 = 0x7FFFFFFFFFFFFFFFLL;
    if (v9 != 0x8000000000000000 && v5 != 0x8000000000000000)
      v14 = v5 + v9;
    if (v5 != 0x7FFFFFFFFFFFFFFFLL && v9 != 0x7FFFFFFFFFFFFFFFLL)
      v11 = v14;
  }
  v17 = v10;
  if ((uint64_t)v10 <= v11)
    v17 = v11;
  if (v7)
    v18 = 1000 * *(int *)(*(_QWORD *)(v6 + 88) + 32);
  else
    v18 = 0;
  v19 = v18 + v9;
  if (v9 == 0x8000000000000000)
    v20 = 0x8000000000000000;
  else
    v20 = v19;
  v21 = 0x7FFFFFFFFFFFFFFFLL;
  if (v9 != 0x7FFFFFFFFFFFFFFFLL)
    v9 = v20;
  if (v17 != 0x7FFFFFFFFFFFFFFFLL && v9 != 0x8000000000000000)
  {
    if (v9 == 0x7FFFFFFFFFFFFFFFLL || v17 == 0x8000000000000000)
      v21 = 0x8000000000000000;
    else
      v21 = v17 - v9;
    if (v21 < 1)
      v21 = 0;
  }
  v24 = *((_QWORD *)this + 16);
  *(_QWORD *)(a2 + 48) = v21;
  *(_QWORD *)(a2 + 56) = v24;
  return pthread_mutex_unlock(v4);
}

void webrtc::VCMTiming::~VCMTiming(webrtc::VCMTiming *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = off_24C0C25E8;
  *((_QWORD *)this + 35) = off_24C0B4170;
  if ((*((char *)this + 335) & 0x80000000) == 0)
  {
    v2 = (void *)*((_QWORD *)this + 36);
    if (!v2)
      goto LABEL_4;
    goto LABEL_3;
  }
  operator delete(*((void **)this + 39));
  v2 = (void *)*((_QWORD *)this + 36);
  if (v2)
  {
LABEL_3:
    *((_QWORD *)this + 37) = v2;
    operator delete(v2);
  }
LABEL_4:
  v3 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v3)
  {
    std::__tree<sigslot::_signal_base_interface *>::destroy(v3 + 64, *(_QWORD **)(v3 + 72));
    std::deque<webrtc::DecodeTimePercentileFilter::Sample>::~deque[abi:sn180100]((void **)(v3 + 8));
    MEMORY[0x20BD0ADEC](v3, 0x10A0C4048E4D329);
  }
  v4 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v4)
    MEMORY[0x20BD0ADEC](v4, 0x1000C4036CF81B0);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = off_24C0C25E8;
  *((_QWORD *)this + 35) = off_24C0B4170;
  if (*((char *)this + 335) < 0)
  {
    operator delete(*((void **)this + 39));
    v2 = (void *)*((_QWORD *)this + 36);
    if (!v2)
    {
LABEL_4:
      v3 = *((_QWORD *)this + 11);
      *((_QWORD *)this + 11) = 0;
      if (v3)
      {
        std::__tree<sigslot::_signal_base_interface *>::destroy(v3 + 64, *(_QWORD **)(v3 + 72));
        std::deque<webrtc::DecodeTimePercentileFilter::Sample>::~deque[abi:sn180100]((void **)(v3 + 8));
        MEMORY[0x20BD0ADEC](v3, 0x10A0C4048E4D329);
      }
      v4 = *((_QWORD *)this + 10);
      *((_QWORD *)this + 10) = 0;
      if (v4)
        MEMORY[0x20BD0ADEC](v4, 0x1000C4036CF81B0);
      pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    v2 = (void *)*((_QWORD *)this + 36);
    if (!v2)
      goto LABEL_4;
  }
  *((_QWORD *)this + 37) = v2;
  operator delete(v2);
  goto LABEL_4;
}

void webrtc::rtcp::Tmmbn::~Tmmbn(webrtc::rtcp::Tmmbn *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C0C2620;
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_24C0C2620;
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::rtcp::Tmmbn::Parse(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unsigned __int8 *v20;
  int v21;
  __int16 v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v2 = *(unsigned int *)(a2 + 4);
  if (v2 <= 7)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      goto LABEL_6;
    return 0;
  }
  if ((v2 & 7) != 0)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
LABEL_6:
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/tmmbn.cc");
    return 0;
  }
  v12 = v2 - 8;
  v13 = *(unsigned int **)(a2 + 8);
  v16 = *(_QWORD *)(a1 + 16);
  v14 = a1 + 16;
  v15 = v16;
  *(_DWORD *)(v14 - 8) = bswap32(*v13);
  *(_DWORD *)(v14 - 4) = bswap32(v13[1]);
  v17 = v12 >> 3;
  v18 = *(_QWORD *)(v14 + 8);
  v19 = 0xAAAAAAAAAAAAAAABLL * ((v18 - v16) >> 3);
  if (v17 <= v19)
  {
    if (v17 < v19)
    {
      v18 = v15 + 24 * v17;
      *(_QWORD *)(a1 + 24) = v18;
    }
  }
  else
  {
    std::vector<webrtc::rtcp::TmmbItem>::__append((void **)v14, v17 - v19);
    v15 = *(_QWORD *)(a1 + 16);
    v18 = *(_QWORD *)(a1 + 24);
  }
  if (v15 != v18)
  {
    v20 = (unsigned __int8 *)v13 + 15;
    while (1)
    {
      *(_DWORD *)v15 = bswap32(*(_DWORD *)(v20 - 7));
      v21 = *(v20 - 3);
      v22 = *(v20 - 1);
      v23 = *v20;
      v24 = (((v21 << 24) | (*(v20 - 2) << 16) | (*(v20 - 1) << 8)) >> 9) & 0x1FFFF;
      *(_QWORD *)(v15 + 8) = v24 << (v21 >> 2);
      if ((unint64_t)(v24 << (v21 >> 2)) >> (v21 >> 2) != v24)
        break;
      v20 += 8;
      *(_WORD *)(v15 + 16) = ((v22 << 8) | v23) & 0x1FF;
      v15 += 24;
      if (v15 == v18)
        return 1;
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)6,unsigned long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)6,unsigned long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v25, v26, v27, v28, v29, v30, v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/tmmb_item.cc");
    return 0;
  }
  return 1;
}

void webrtc::rtcp::Tmmbn::AddTmmbr(_QWORD *a1, __int128 *a2)
{
  unint64_t v4;
  char *v5;
  __int128 v6;
  char *v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  __int128 v15;

  v5 = (char *)a1[3];
  v4 = a1[4];
  if ((unint64_t)v5 < v4)
  {
    if (v5)
    {
      v6 = *a2;
      *((_QWORD *)v5 + 2) = *((_QWORD *)a2 + 2);
      *(_OWORD *)v5 = v6;
      v7 = v5 + 24;
LABEL_4:
      a1[3] = v7;
      return;
    }
    goto LABEL_18;
  }
  v8 = (char *)a1[2];
  v9 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v8) >> 3) + 1;
  if (v9 > 0xAAAAAAAAAAAAAAALL)
    goto LABEL_19;
  v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - (_QWORD)v8) >> 3);
  if (2 * v10 > v9)
    v9 = 2 * v10;
  if (v10 >= 0x555555555555555)
    v11 = 0xAAAAAAAAAAAAAAALL;
  else
    v11 = v9;
  if (!v11)
  {
LABEL_18:
    __break(1u);
LABEL_19:
    abort();
  }
  if (v11 > 0xAAAAAAAAAAAAAAALL)
    std::__throw_bad_array_new_length[abi:sn180100]();
  v12 = 24 * v11;
  v13 = (char *)operator new(24 * v11);
  v14 = &v13[8 * ((v5 - v8) >> 3)];
  *(_OWORD *)v14 = *a2;
  *((_QWORD *)v14 + 2) = *((_QWORD *)a2 + 2);
  v7 = v14 + 24;
  if (v5 != v8)
  {
    do
    {
      v15 = *(_OWORD *)(v5 - 24);
      *((_WORD *)v14 - 4) = *((_WORD *)v5 - 4);
      *(_OWORD *)(v14 - 24) = v15;
      v14 -= 24;
      v5 -= 24;
    }
    while (v5 != v8);
    v5 = v8;
  }
  a1[2] = v14;
  a1[3] = v7;
  a1[4] = &v13[v12];
  if (!v5)
    goto LABEL_4;
  operator delete(v5);
  a1[3] = v7;
}

uint64_t webrtc::rtcp::Tmmbn::BlockLength(webrtc::rtcp::Tmmbn *this)
{
  return 0x5555555555555558 * ((*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3) + 12;
}

uint64_t webrtc::rtcp::Tmmbn::Create(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5, void (*a6)(uint64_t, uint64_t))
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t i;
  unsigned int v25;
  uint64_t v26;
  __int16 v27;
  unint64_t v28;
  unint64_t v29;
  std::string *v31;

  v12 = *a3;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) + v12 <= a4)
  {
LABEL_4:
    v13 = *a3;
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) + v13;
    v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    *(_BYTE *)(a2 + *a3) = -124;
    *(_BYTE *)(*a3 + a2 + 1) = -51;
    *(_BYTE *)(*a3 + a2 + 2) = (unint64_t)(v15 - 4) >> 10;
    *(_BYTE *)(*a3 + a2 + 3) = (unint64_t)(v15 - 4) >> 2;
    v20 = *a3 + 4;
    *a3 = v20;
    v21 = (_DWORD *)(a2 + v20);
    *v21 = bswap32(*(_DWORD *)(a1 + 8));
    v21[1] = bswap32(*(_DWORD *)(a1 + 12));
    v22 = *a3 + 8;
    *a3 = v22;
    v23 = *(_QWORD *)(a1 + 16);
    for (i = *(_QWORD *)(a1 + 24); v23 != i; v23 += 24)
    {
      v28 = *(_QWORD *)(v23 + 8);
      if (v28 < 0x20000)
      {
        v25 = 0;
      }
      else
      {
        v25 = 0;
        do
        {
          v29 = v28 >> 18;
          v28 >>= 1;
          v25 += 0x4000000;
        }
        while (v29);
      }
      v26 = a2 + v22;
      *(_DWORD *)v26 = bswap32(*(_DWORD *)v23);
      v27 = *(_WORD *)(v23 + 16);
      *(_BYTE *)(v26 + 4) = (((_DWORD)v28 << 9) | v25) >> 24;
      *(_BYTE *)(v26 + 5) = v28 >> 7;
      *(_BYTE *)(v26 + 6) = (unsigned __int16)(((_WORD)v28 << 9) | v27) >> 8;
      *(_BYTE *)(v26 + 7) = v27;
      v22 = *a3 + 8;
      *a3 = v22;
    }
    if (v14 == v22)
    {
      return 1;
    }
    else
    {
      v31 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/tmmbn.cc", 105, "index_end == *index", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long> const&)::t, v16, v17, v18, v19, v14);
      return std::vector<webrtc::rtcp::TmmbItem>::__append(v31);
    }
  }
  else
  {
    while (*a3)
    {
      a6(a5, a2);
      *a3 = 0;
      if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) <= a4)
        goto LABEL_4;
    }
    return 0;
  }
}

void std::vector<webrtc::rtcp::TmmbItem>::__append(void **a1, unint64_t a2)
{
  _BYTE *v4;
  char *v5;
  char *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  __int128 v17;
  char *v18;
  void *v19;

  v5 = (char *)a1[1];
  v4 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - v5) >> 3) < a2)
  {
    v6 = (char *)*a1;
    v7 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (_BYTE *)*a1) >> 3);
    v8 = v7 + a2;
    if (v7 + a2 <= 0xAAAAAAAAAAAAAAALL)
    {
      v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v6) >> 3);
      if (2 * v9 > v8)
        v8 = 2 * v9;
      if (v9 >= 0x555555555555555)
        v10 = 0xAAAAAAAAAAAAAAALL;
      else
        v10 = v8;
      if (v10)
      {
        if (v10 > 0xAAAAAAAAAAAAAAALL)
          std::__throw_bad_array_new_length[abi:sn180100]();
        v11 = (char *)operator new(24 * v10);
      }
      else
      {
        v11 = 0;
      }
      v13 = &v11[24 * v7];
      v14 = &v11[24 * v10];
      v15 = &v13[24 * a2];
      v16 = v13;
      do
      {
        if (!v16)
          goto LABEL_27;
        *(_DWORD *)v16 = 0;
        *((_QWORD *)v16 + 1) = 0;
        *((_WORD *)v16 + 8) = 0;
        v16 += 24;
      }
      while (v16 != v15);
      if (v5 == v6)
      {
        v19 = *a1;
        *a1 = v13;
        a1[1] = v15;
        a1[2] = v14;
        if (!v19)
          return;
      }
      else
      {
        do
        {
          v17 = *(_OWORD *)(v5 - 24);
          v18 = v13 - 24;
          *((_WORD *)v13 - 4) = *((_WORD *)v5 - 4);
          *(_OWORD *)(v13 - 24) = v17;
          v5 -= 24;
          v13 -= 24;
        }
        while (v5 != v6);
        v19 = *a1;
        *a1 = v18;
        a1[1] = v15;
        a1[2] = v14;
        if (!v19)
          return;
      }
      operator delete(v19);
      return;
    }
LABEL_28:
    abort();
  }
  if (!a2)
    goto LABEL_16;
  v12 = &v5[24 * a2];
  do
  {
    if (!v5)
    {
LABEL_27:
      __break(1u);
      goto LABEL_28;
    }
    *(_DWORD *)v5 = 0;
    *((_QWORD *)v5 + 1) = 0;
    *((_WORD *)v5 + 8) = 0;
    v5 += 24;
  }
  while (v5 != v12);
  v5 = v12;
LABEL_16:
  a1[1] = v5;
}

void webrtc::rtcp::Tmmbr::~Tmmbr(webrtc::rtcp::Tmmbr *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C0C2650;
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_24C0C2650;
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::rtcp::Tmmbr::Parse(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unsigned __int8 *v20;
  int v21;
  __int16 v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v2 = *(unsigned int *)(a2 + 4);
  if (v2 <= 0xF)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      goto LABEL_6;
    return 0;
  }
  if ((v2 & 7) != 0)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
LABEL_6:
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/tmmbr.cc");
    return 0;
  }
  v12 = v2 - 8;
  v13 = *(unsigned int **)(a2 + 8);
  v16 = *(_QWORD *)(a1 + 16);
  v14 = a1 + 16;
  v15 = v16;
  *(_DWORD *)(v14 - 8) = bswap32(*v13);
  *(_DWORD *)(v14 - 4) = bswap32(v13[1]);
  v17 = v12 >> 3;
  v18 = *(_QWORD *)(v14 + 8);
  v19 = 0xAAAAAAAAAAAAAAABLL * ((v18 - v16) >> 3);
  if (v17 <= v19)
  {
    if (v17 < v19)
    {
      v18 = v15 + 24 * v17;
      *(_QWORD *)(a1 + 24) = v18;
    }
  }
  else
  {
    std::vector<webrtc::rtcp::TmmbItem>::__append((void **)v14, v17 - v19);
    v15 = *(_QWORD *)(a1 + 16);
    v18 = *(_QWORD *)(a1 + 24);
  }
  if (v15 != v18)
  {
    v20 = (unsigned __int8 *)v13 + 15;
    while (1)
    {
      *(_DWORD *)v15 = bswap32(*(_DWORD *)(v20 - 7));
      v21 = *(v20 - 3);
      v22 = *(v20 - 1);
      v23 = *v20;
      v24 = (((v21 << 24) | (*(v20 - 2) << 16) | (*(v20 - 1) << 8)) >> 9) & 0x1FFFF;
      *(_QWORD *)(v15 + 8) = v24 << (v21 >> 2);
      if ((unint64_t)(v24 << (v21 >> 2)) >> (v21 >> 2) != v24)
        break;
      v20 += 8;
      *(_WORD *)(v15 + 16) = ((v22 << 8) | v23) & 0x1FF;
      v15 += 24;
      if (v15 == v18)
        return 1;
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)6,unsigned long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)6,unsigned long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v25, v26, v27, v28, v29, v30, v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/tmmb_item.cc");
    return 0;
  }
  return 1;
}

uint64_t webrtc::rtcp::Tmmbr::BlockLength(webrtc::rtcp::Tmmbr *this)
{
  return 0x5555555555555558 * ((*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3) + 12;
}

uint64_t webrtc::rtcp::Tmmbr::Create(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5, void (*a6)(uint64_t, uint64_t))
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t i;
  unsigned int v25;
  uint64_t v26;
  __int16 v27;
  unint64_t v28;
  unint64_t v29;
  std::string *v31;

  v12 = *a3;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) + v12 <= a4)
  {
LABEL_4:
    v13 = *a3;
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) + v13;
    v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    *(_BYTE *)(a2 + *a3) = -125;
    *(_BYTE *)(*a3 + a2 + 1) = -51;
    *(_BYTE *)(*a3 + a2 + 2) = (unint64_t)(v15 - 4) >> 10;
    *(_BYTE *)(*a3 + a2 + 3) = (unint64_t)(v15 - 4) >> 2;
    v20 = *a3 + 4;
    *a3 = v20;
    v21 = (_DWORD *)(a2 + v20);
    *v21 = bswap32(*(_DWORD *)(a1 + 8));
    v21[1] = bswap32(*(_DWORD *)(a1 + 12));
    v22 = *a3 + 8;
    *a3 = v22;
    v23 = *(_QWORD *)(a1 + 16);
    for (i = *(_QWORD *)(a1 + 24); v23 != i; v23 += 24)
    {
      v28 = *(_QWORD *)(v23 + 8);
      if (v28 < 0x20000)
      {
        v25 = 0;
      }
      else
      {
        v25 = 0;
        do
        {
          v29 = v28 >> 18;
          v28 >>= 1;
          v25 += 0x4000000;
        }
        while (v29);
      }
      v26 = a2 + v22;
      *(_DWORD *)v26 = bswap32(*(_DWORD *)v23);
      v27 = *(_WORD *)(v23 + 16);
      *(_BYTE *)(v26 + 4) = (((_DWORD)v28 << 9) | v25) >> 24;
      *(_BYTE *)(v26 + 5) = v28 >> 7;
      *(_BYTE *)(v26 + 6) = (unsigned __int16)(((_WORD)v28 << 9) | v27) >> 8;
      *(_BYTE *)(v26 + 7) = v27;
      v22 = *a3 + 8;
      *a3 = v22;
    }
    if (v14 == v22)
    {
      return 1;
    }
    else
    {
      v31 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/tmmbr.cc", 107, "index_end == *index", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long> const&)::t, v16, v17, v18, v19, v14);
      return webrtc::TMMBRHelp::FindBoundingSet(v31);
    }
  }
  else
  {
    while (*a3)
    {
      a6(a5, a2);
      *a3 = 0;
      if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) <= a4)
        goto LABEL_4;
    }
    return 0;
  }
}

__n128 webrtc::TMMBRHelp::FindBoundingSet@<Q0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>, __n128 result@<Q0>)
{
  uint64_t *v3;
  __n128 *v4;
  __n128 *v5;
  uint64_t v6;
  int64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  _QWORD *v16;
  __n128 *v17;
  unint64_t v18;
  char *v19;
  void **v20;
  _DWORD *v21;
  unsigned int v22;
  _DWORD *v23;
  __n128 v24;
  unint64_t v25;
  char *v26;
  float v27;
  float *v28;
  unint64_t i;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  unsigned int *v34;
  unsigned int *v35;
  unint64_t v36;
  unint64_t v37;
  float v38;
  float v39;
  float v40;
  char *v41;
  char *v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  char *v50;
  __int128 v51;
  char *v52;
  unint64_t v53;
  void *v54;
  __n128 *v55;
  unint64_t v56;
  _DWORD *v57;
  uint64_t *v58;
  float *__p;
  unsigned int v60;
  int v62;
  __int16 v63;

  v3 = a1;
  v5 = (__n128 *)*a1;
  v4 = (__n128 *)a1[1];
  if ((__n128 *)*a1 == v4)
  {
    v6 = *a1;
  }
  else
  {
    do
    {
      while (v5->n128_u64[1])
      {
        v5 = (__n128 *)((char *)v5 + 24);
        if (v5 == v4)
          goto LABEL_8;
      }
      v7 = (char *)v4 - &v5[1].n128_i8[8];
      if (v4 != (__n128 *)&v5[1].n128_i8[8])
        memmove(v5, &v5[1].n128_i8[8], v7 - 6);
      v4 = (__n128 *)((char *)v5 + v7);
      v3[1] = (uint64_t)v5 + v7;
    }
    while (v5 != (__n128 *)((char *)v5 + v7));
LABEL_8:
    v6 = *v3;
    v5 = v4;
  }
  v8 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - v6) >> 3);
  if (v8 >= 2)
  {
    v9 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - v6) >> 3));
    if (v5 == (__n128 *)v6)
      v10 = 0;
    else
      v10 = v9;
    std::__introsort<std::_ClassicAlgPolicy,webrtc::TMMBRHelp::FindBoundingSet(std::vector<webrtc::rtcp::TmmbItem>)::$_0 &,webrtc::rtcp::TmmbItem*,false>(v6, v5, v10, 1, result);
    v11 = *v3;
    v12 = v3[1];
    v13 = *v3;
    if (*v3 == v12)
    {
      v14 = a2;
    }
    else
    {
      v14 = a2;
      do
      {
        v15 = v13;
        v13 += 24;
        if (v13 == v12)
          break;
        while (*(unsigned __int16 *)(v13 + 16) == *(unsigned __int16 *)(v15 + 16))
        {
          v16 = (_QWORD *)(v13 + 8);
          if (*(_QWORD *)(v13 + 8) < *(_QWORD *)(v15 + 8))
          {
            v16 = (_QWORD *)(v15 + 8);
            v15 = v13;
          }
          *v16 = 0;
          --v8;
          v13 += 24;
          if (v13 == v12)
            goto LABEL_23;
        }
      }
      while (v13 != v12);
LABEL_23:
      v13 = v11;
      while (!*(_QWORD *)(v13 + 8))
      {
        v13 += 24;
        if (v13 == v12)
          goto LABEL_35;
      }
    }
    if (v13 == v12)
    {
LABEL_35:
      v17 = (__n128 *)v12;
    }
    else
    {
      v17 = (__n128 *)v13;
      do
      {
        v18 = *(_QWORD *)(v13 + 8);
        if (v18 && v18 <= v17->n128_u64[1])
          v17 = (__n128 *)v13;
        v13 += 24;
      }
      while (v13 != v12);
    }
    *v14 = 0;
    v14[1] = 0;
    v14[2] = 0;
    if (v8)
    {
      if (v8 > 0xAAAAAAAAAAAAAAALL)
        goto LABEL_80;
      v19 = (char *)operator new(24 * v8);
      v20 = (void **)a2;
      *a2 = (uint64_t)v19;
      a2[1] = (uint64_t)v19;
      a2[2] = (uint64_t)&v19[24 * v8];
      v21 = operator new(4 * v8);
      bzero(v21, 4 * v8);
      __p = (float *)operator new(4 * v8);
      bzero(__p, 4 * v8);
      v23 = v21;
      v24 = *v17;
      v25 = v17[1].n128_u64[0];
      *((_QWORD *)v19 + 2) = v25;
      *(__n128 *)v19 = v24;
      v26 = v19 + 24;
      a2[1] = (uint64_t)(v19 + 24);
      *v21 = 0;
      if ((_WORD)v25)
        v27 = (float)*((unint64_t *)v19 + 1) / (float)(unsigned __int16)v25;
      else
        v27 = 3.4028e38;
      v28 = __p;
      *__p = v27;
      v17->n128_u64[1] = 0;
      for (i = v8 - 1; v11 != v12; v11 += 24)
      {
        if (*(_QWORD *)(v11 + 8) && *(unsigned __int16 *)(v11 + 16) < (unsigned __int16)v25)
        {
          *(_QWORD *)(v11 + 8) = 0;
          --i;
        }
      }
      if (i)
      {
        v30 = 0;
        v31 = 0;
        v32 = 0;
        v33 = 1;
        v57 = v21;
        v58 = v3;
        do
        {
          while (1)
          {
            if (!v33 || (v34 = (unsigned int *)*v3, v35 = (unsigned int *)v3[1], (unsigned int *)*v3 == v35))
            {
LABEL_53:
              if (v19 == v26)
                goto LABEL_79;
            }
            else
            {
              while (!*((_QWORD *)v34 + 1))
              {
                v34 += 6;
                if (v34 == v35)
                  goto LABEL_53;
              }
              v30 = *v34;
              v22 = v34[1];
              v32 = *((unsigned __int16 *)v34 + 8);
              v31 = *((_QWORD *)v34 + 1);
              *((_QWORD *)v34 + 1) = 0;
              if (v19 == v26)
                goto LABEL_79;
            }
            v36 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v19) >> 3);
            v37 = v36 - 1;
            if (v8 <= v36 - 1)
              goto LABEL_79;
            v38 = (float)(int)(v32 - *((unsigned __int16 *)v26 - 4));
            v39 = (float)(unint64_t)(v31 - *((_QWORD *)v26 - 2)) / v38;
            v40 = *(float *)&v23[v37];
            v33 = v39 > v40;
            if (v39 > v40)
              break;
            v26 -= 24;
            v20[1] = v26;
          }
          if (v39 < v28[v37])
          {
            v41 = (char *)v20[2];
            if (v26 >= v41)
            {
              v43 = v36 + 1;
              if (v36 + 1 > 0xAAAAAAAAAAAAAAALL)
                goto LABEL_80;
              v44 = 0xAAAAAAAAAAAAAAABLL * ((v41 - v19) >> 3);
              if (2 * v44 > v43)
                v43 = 2 * v44;
              if (v44 >= 0x555555555555555)
                v45 = 0xAAAAAAAAAAAAAAALL;
              else
                v45 = v43;
              if (!v45)
              {
LABEL_79:
                __break(1u);
LABEL_80:
                abort();
              }
              v60 = v22;
              if (v45 > 0xAAAAAAAAAAAAAAALL)
                std::__throw_bad_array_new_length[abi:sn180100]();
              v46 = v31;
              v47 = v32;
              v48 = v30;
              v49 = (char *)operator new(24 * v45);
              v50 = &v49[8 * ((v26 - v19) >> 3)];
              v30 = v48;
              v22 = v60;
              *(_DWORD *)v50 = v48;
              *((_DWORD *)v50 + 1) = v60;
              v31 = v46;
              *((_QWORD *)v50 + 1) = v46;
              v32 = v47;
              *((_WORD *)v50 + 8) = v47;
              *(_DWORD *)(v50 + 18) = v62;
              *((_WORD *)v50 + 11) = v63;
              v42 = v50;
              do
              {
                v51 = *(_OWORD *)(v26 - 24);
                *((_WORD *)v42 - 4) = *((_WORD *)v26 - 4);
                *(_OWORD *)(v42 - 24) = v51;
                v42 -= 24;
                v26 -= 24;
              }
              while (v26 != v19);
              v52 = &v49[24 * v45];
              v26 = v50 + 24;
              v20 = (void **)a2;
              *a2 = (uint64_t)v42;
              a2[1] = (uint64_t)(v50 + 24);
              a2[2] = (uint64_t)v52;
              if (v19)
              {
                operator delete(v19);
                v22 = v60;
                v31 = v46;
                v32 = v47;
                v30 = v48;
              }
              v23 = v57;
              v3 = v58;
              v28 = __p;
            }
            else
            {
              *(_DWORD *)v26 = v30;
              *((_DWORD *)v26 + 1) = v22;
              *((_QWORD *)v26 + 1) = v31;
              *((_WORD *)v26 + 8) = v32;
              *(_DWORD *)(v26 + 18) = v62;
              *((_WORD *)v26 + 11) = v63;
              v26 += 24;
              v42 = (char *)*v20;
            }
            v20[1] = v26;
            v53 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v42) >> 3) - 1;
            if (v8 <= v53)
              goto LABEL_79;
            *(float *)&v23[v53] = v39;
            if (v42 == v26)
              goto LABEL_79;
            LOWORD(v38) = *((_WORD *)v26 - 4);
            v28[v53] = (float)*((unint64_t *)v26 - 2) / (float)LODWORD(v38);
            v19 = v42;
          }
          --i;
        }
        while (i);
      }
      v54 = v23;
      operator delete(v28);
      operator delete(v54);
    }
    else
    {
      v55 = (__n128 *)operator new(0x18uLL);
      v56 = v17[1].n128_u64[0];
      result = *v17;
      *v55 = *v17;
      v55[1].n128_u64[0] = v56;
      v14[1] = (uint64_t)&v55[1].n128_i64[1];
      v14[2] = (uint64_t)&v55[1].n128_i64[1];
      *v14 = (uint64_t)v55;
      __break(1u);
    }
  }
  else
  {
    *a2 = v6;
    a2[1] = (uint64_t)v5;
    a2[2] = v3[2];
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,webrtc::TMMBRHelp::FindBoundingSet(std::vector<webrtc::rtcp::TmmbItem>)::$_0 &,webrtc::rtcp::TmmbItem*,false>(uint64_t a1, __n128 *a2, uint64_t a3, char a4, __n128 a5)
{
  __n128 *v9;
  __n128 *v10;
  __int8 *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  __n128 *v16;
  unsigned int v17;
  unsigned int v18;
  __n128 v19;
  unsigned int v20;
  __n128 v21;
  __n128 v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;
  __n128 v26;
  __n128 v27;
  __n128 *v28;
  unint64_t v29;
  __n128 *v30;
  unsigned int v31;
  unsigned int v32;
  __n128 v33;
  uint64_t v34;
  unsigned __int16 v35;
  __n128 v36;
  __n128 v37;
  uint64_t v38;
  __int16 v39;
  __n128 v40;
  __n128 v41;
  unint64_t v42;
  __n128 v43;
  unsigned __int16 v44;
  __int16 v45;
  __n128 v46;
  __n128 *v47;
  unint64_t v48;
  __n128 *v49;
  unsigned int v50;
  unsigned int v51;
  __n128 v52;
  uint64_t v53;
  unsigned __int16 v54;
  __n128 v55;
  __n128 v56;
  uint64_t v57;
  __int16 v58;
  __n128 v59;
  unsigned __int16 v60;
  __int16 v61;
  __n128 v62;
  unsigned int v63;
  unsigned int v64;
  __n128 v65;
  uint64_t v66;
  unsigned int v67;
  unint64_t v68;
  __n128 *v69;
  __n128 *v70;
  unsigned int v71;
  __n128 *v72;
  unsigned int v73;
  __n128 *v74;
  __n128 v75;
  __n128 *v76;
  unsigned int v77;
  unint64_t v78;
  unsigned int v79;
  __n128 *v80;
  __n128 v81;
  BOOL v82;
  __n128 v83;
  __n128 *v84;
  unsigned int v85;
  unint64_t v86;
  unsigned int v87;
  __n128 *v88;
  __n128 *v89;
  unsigned int v90;
  __n128 v91;
  __n128 *v92;
  unsigned int v93;
  unint64_t v94;
  unsigned int v95;
  __n128 *v96;
  __n128 v97;
  __int128 v98;
  unsigned int v99;
  unsigned int v100;
  __n128 v101;
  __n128 v102;
  __n128 *v103;
  __n128 *v104;
  __n128 *v105;
  __n128 v106;
  unsigned __int16 v107;
  unsigned __int16 v108;
  uint64_t v109;
  __n128 v110;
  uint64_t v111;
  __n128 v112;
  __n128 *v113;
  BOOL v115;
  uint64_t v116;
  __n128 *v117;
  uint64_t v118;
  unsigned int v119;
  unsigned int v120;
  uint64_t v121;
  uint64_t v122;
  int64_t v123;
  int64_t v124;
  BOOL v125;
  uint64_t v126;
  unint64_t v127;
  unsigned int v128;
  unsigned int v129;
  unint64_t v130;
  unsigned int v131;
  unint64_t v132;
  __int128 v133;
  uint64_t v134;
  uint64_t v135;
  unsigned int v136;
  unsigned int v137;
  int64_t v138;
  uint64_t v139;
  unint64_t v140;
  __int128 v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  unsigned int v145;
  unsigned int v146;
  __n128 v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  unsigned int v151;
  uint64_t v152;
  __int128 v153;
  __n128 v154;
  unsigned __int16 v155;
  unsigned __int16 v156;
  unint64_t v157;
  uint64_t v158;
  uint64_t v159;
  unint64_t v160;
  unsigned int v161;
  unint64_t v162;
  unint64_t v163;
  uint64_t v164;
  unsigned __int16 v165;
  __n128 v166;
  __n128 v167;
  __int128 v168;
  __n128 v169;
  __n128 v170;
  __n128 v171;
  __n128 v172;
  __n128 v173;
  __n128 v174;
  __n128 v175;
  __n128 v176;
  __n128 v177;
  __n128 v178;
  __n128 v179;
  __n128 v180;
  __n128 v181;
  __n128 v182;
  __n128 v183;
  __n128 v184;
  __n128 v185;
  __n128 v186;
  __n128 v187;
  __n128 v188;
  __n128 v189;
  __n128 v190;
  __n128 v191;
  __int128 v192;
  __n128 v193;
  __n128 v194;
  __n128 v195;
  __int128 v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t v199;
  uint64_t v200;
  uint64_t v201;
  unint64_t v202;
  uint64_t v203;
  uint64_t v204;
  unint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unint64_t v209;
  unint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;

BOOL std::__insertion_sort_incomplete[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::TMMBRHelp::FindBoundingSet(std::vector<webrtc::rtcp::TmmbItem>)::$_0 &,webrtc::rtcp::TmmbItem*>(uint64_t a1, __n128 *a2, __n128 a3)
{
  unint64_t v5;
  _BOOL8 result;
  __n128 v7;
  uint64_t v8;
  __int16 v9;
  __n128 *v10;
  __n128 *v11;
  unsigned int v12;
  unsigned int v13;
  __n128 v14;
  uint64_t v15;
  __int16 v16;
  __n128 *v17;
  __n128 *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  __n128 v23;
  __n128 *v24;
  __n128 *v25;
  __n128 *v26;
  __n128 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __n128 v31;
  uint64_t v32;
  __n128 v33;
  uint64_t v34;
  __n128 v35;
  __n128 v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  __n128 v40;
  uint64_t v41;
  __n128 v42;
  uint64_t v43;
  __n128 v44;
  uint64_t v45;
  __n128 v46;
  uint64_t v47;
  __int16 v48;
  uint64_t v49;
  __n128 v50;
  uint64_t v51;
  __n128 v52;
  __n128 *v53;
  uint64_t v54;
  int v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  __n128 v60;

  v5 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)a2 - a1) >> 3);
  result = 1;
  switch(v5)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (a2[-1].n128_u16[4] < *(unsigned __int16 *)(a1 + 16))
      {
        v7 = *(__n128 *)a1;
        v8 = *(_QWORD *)(a1 + 16);
        v9 = a2[-1].n128_i16[4];
        *(__n128 *)a1 = *(__n128 *)((char *)a2 - 24);
        *(_WORD *)(a1 + 16) = v9;
        a2[-1].n128_u16[4] = v8;
        *(__n128 *)((char *)a2 - 24) = v7;
      }
      return result;
    case 3uLL:
      v10 = (__n128 *)(a1 + 24);
      v11 = (__n128 *)((char *)a2 - 24);
      v12 = *(unsigned __int16 *)(a1 + 40);
      v13 = a2[-1].n128_u16[4];
      if (v12 >= *(unsigned __int16 *)(a1 + 16))
      {
        if (v13 < v12)
        {
          v36 = *v10;
          v37 = *(_QWORD *)(a1 + 40);
          v38 = a2[-1].n128_i16[4];
          *v10 = *v11;
          *(_WORD *)(a1 + 40) = v38;
          a2[-1].n128_u16[4] = v37;
          *v11 = v36;
          if (*(unsigned __int16 *)(a1 + 40) < *(unsigned __int16 *)(a1 + 16))
          {
            v39 = *(_QWORD *)(a1 + 16);
            v40 = *(__n128 *)a1;
            *(__n128 *)a1 = *v10;
            *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 40);
            *v10 = v40;
            *(_WORD *)(a1 + 40) = v39;
          }
        }
      }
      else
      {
        if (v13 >= v12)
        {
          v45 = *(_QWORD *)(a1 + 16);
          v46 = *(__n128 *)a1;
          *(__n128 *)a1 = *v10;
          *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 40);
          *v10 = v46;
          *(_WORD *)(a1 + 40) = v45;
          if (a2[-1].n128_u16[4] >= *(unsigned __int16 *)(a1 + 40))
            return result;
          v14 = *v10;
          v47 = *(_QWORD *)(a1 + 40);
          v48 = a2[-1].n128_i16[4];
          *v10 = *v11;
          *(_WORD *)(a1 + 40) = v48;
          a2[-1].n128_u16[4] = v47;
        }
        else
        {
          v14 = *(__n128 *)a1;
          v15 = *(_QWORD *)(a1 + 16);
          v16 = a2[-1].n128_i16[4];
          *(__n128 *)a1 = *v11;
          *(_WORD *)(a1 + 16) = v16;
          a2[-1].n128_u16[4] = v15;
        }
        *v11 = v14;
      }
      return result;
    case 4uLL:
      std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::TMMBRHelp::FindBoundingSet(std::vector<webrtc::rtcp::TmmbItem>)::$_0 &,webrtc::rtcp::TmmbItem*>((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)((char *)a2 - 24), a3);
      return 1;
    case 5uLL:
      v24 = (__n128 *)(a1 + 24);
      v25 = (__n128 *)(a1 + 48);
      v26 = (__n128 *)(a1 + 72);
      std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::TMMBRHelp::FindBoundingSet(std::vector<webrtc::rtcp::TmmbItem>)::$_0 &,webrtc::rtcp::TmmbItem*>((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a1 + 72), a3);
      if (a2[-1].n128_u16[4] < *(unsigned __int16 *)(a1 + 88))
      {
        v27 = *v26;
        v28 = *(_QWORD *)(a1 + 88);
        v29 = a2[-1].n128_i16[4];
        *v26 = *(__n128 *)((char *)a2 - 24);
        *(_WORD *)(a1 + 88) = v29;
        a2[-1].n128_u16[4] = v28;
        *(__n128 *)((char *)a2 - 24) = v27;
        if (*(unsigned __int16 *)(a1 + 88) < *(unsigned __int16 *)(a1 + 64))
        {
          v30 = *(_QWORD *)(a1 + 64);
          v31 = *v25;
          *v25 = *v26;
          *(_WORD *)(a1 + 64) = *(_WORD *)(a1 + 88);
          *v26 = v31;
          *(_WORD *)(a1 + 88) = v30;
          if (*(unsigned __int16 *)(a1 + 64) < *(unsigned __int16 *)(a1 + 40))
          {
            v32 = *(_QWORD *)(a1 + 40);
            v33 = *v24;
            *v24 = *v25;
            *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 64);
            *v25 = v33;
            *(_WORD *)(a1 + 64) = v32;
            if (*(unsigned __int16 *)(a1 + 40) < *(unsigned __int16 *)(a1 + 16))
            {
              v34 = *(_QWORD *)(a1 + 16);
              v35 = *(__n128 *)a1;
              *(__n128 *)a1 = *v24;
              *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 40);
              *v24 = v35;
              *(_WORD *)(a1 + 40) = v34;
            }
          }
        }
      }
      return 1;
    default:
      v17 = (__n128 *)(a1 + 48);
      v18 = (__n128 *)(a1 + 24);
      v19 = *(unsigned __int16 *)(a1 + 40);
      v20 = *(unsigned __int16 *)(a1 + 16);
      v21 = *(unsigned __int16 *)(a1 + 64);
      if (v19 >= v20)
      {
        if (v21 < v19)
        {
          v41 = *(_QWORD *)(a1 + 40);
          v42 = *v18;
          *v18 = *v17;
          *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 64);
          *v17 = v42;
          *(_WORD *)(a1 + 64) = v41;
          if (*(unsigned __int16 *)(a1 + 40) < v20)
          {
            v43 = *(_QWORD *)(a1 + 16);
            v44 = *(__n128 *)a1;
            *(__n128 *)a1 = *v18;
            *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 40);
            *v18 = v44;
            *(_WORD *)(a1 + 40) = v43;
          }
        }
      }
      else if (v21 >= v19)
      {
        v49 = *(_QWORD *)(a1 + 16);
        v50 = *(__n128 *)a1;
        *(__n128 *)a1 = *v18;
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 40);
        *v18 = v50;
        *(_WORD *)(a1 + 40) = v49;
        if (v21 < *(unsigned __int16 *)(a1 + 40))
        {
          v51 = *(_QWORD *)(a1 + 40);
          v52 = *v18;
          *v18 = *v17;
          *(_WORD *)(a1 + 40) = *(_WORD *)(a1 + 64);
          *v17 = v52;
          *(_WORD *)(a1 + 64) = v51;
        }
      }
      else
      {
        v22 = *(_QWORD *)(a1 + 16);
        v23 = *(__n128 *)a1;
        *(__n128 *)a1 = *v17;
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 64);
        *v17 = v23;
        *(_WORD *)(a1 + 64) = v22;
      }
      v53 = (__n128 *)(a1 + 72);
      if ((__n128 *)(a1 + 72) == a2)
        return 1;
      v54 = 0;
      v55 = 0;
      break;
  }
  while (1)
  {
    v56 = v53[1].n128_u16[0];
    if (v56 < v17[1].n128_u16[0])
      break;
LABEL_31:
    v17 = v53;
    v54 += 24;
    v53 = (__n128 *)((char *)v53 + 24);
    if (v53 == a2)
      return 1;
  }
  v60 = *v53;
  v57 = v54;
  do
  {
    v58 = a1 + v57;
    *(_OWORD *)(v58 + 72) = *(_OWORD *)(a1 + v57 + 48);
    *(_WORD *)(v58 + 88) = *(_WORD *)(a1 + v57 + 64);
    if (v57 == -48)
    {
      *(__n128 *)a1 = v60;
      *(_WORD *)(a1 + 16) = v56;
      if (++v55 != 8)
        goto LABEL_31;
      return &v53[1].n128_i8[8] == (__int8 *)a2;
    }
    v57 -= 24;
  }
  while (v56 < *(unsigned __int16 *)(v58 + 40));
  v59 = a1 + v57;
  *(__n128 *)(v59 + 72) = v60;
  *(_WORD *)(v59 + 88) = v56;
  if (++v55 != 8)
    goto LABEL_31;
  return &v53[1].n128_i8[8] == (__int8 *)a2;
}

__n128 std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::TMMBRHelp::FindBoundingSet(std::vector<webrtc::rtcp::TmmbItem>)::$_0 &,webrtc::rtcp::TmmbItem*>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 result)
{
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  unsigned __int16 v8;
  unint64_t v9;
  unsigned __int16 v10;
  unint64_t v11;
  unsigned __int16 v12;
  unint64_t v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unint64_t v16;
  unsigned __int16 v17;
  unint64_t v18;
  unsigned __int16 v19;
  unint64_t v20;
  unsigned __int16 v21;

  v5 = a2[1].n128_u16[0];
  v6 = a3[1].n128_u16[0];
  if (v5 >= a1[1].n128_u16[0])
  {
    if (v6 < v5)
    {
      result = *a2;
      v9 = a2[1].n128_u64[0];
      v10 = a3[1].n128_u16[0];
      *a2 = *a3;
      a2[1].n128_u16[0] = v10;
      a3[1].n128_u16[0] = v9;
      *a3 = result;
      if (a2[1].n128_u16[0] < a1[1].n128_u16[0])
      {
        result = *a1;
        v11 = a1[1].n128_u64[0];
        v12 = a2[1].n128_u16[0];
        *a1 = *a2;
        a1[1].n128_u16[0] = v12;
        a2[1].n128_u16[0] = v11;
        *a2 = result;
      }
    }
  }
  else
  {
    if (v6 < v5)
    {
      result = *a1;
      v7 = a1[1].n128_u64[0];
      v8 = a3[1].n128_u16[0];
      *a1 = *a3;
      a1[1].n128_u16[0] = v8;
LABEL_9:
      a3[1].n128_u16[0] = v7;
      *a3 = result;
      goto LABEL_10;
    }
    result = *a1;
    v13 = a1[1].n128_u64[0];
    v14 = a2[1].n128_u16[0];
    *a1 = *a2;
    a1[1].n128_u16[0] = v14;
    a2[1].n128_u16[0] = v13;
    *a2 = result;
    if (a3[1].n128_u16[0] < a2[1].n128_u16[0])
    {
      result = *a2;
      v7 = a2[1].n128_u64[0];
      v15 = a3[1].n128_u16[0];
      *a2 = *a3;
      a2[1].n128_u16[0] = v15;
      goto LABEL_9;
    }
  }
LABEL_10:
  if (a4[1].n128_u16[0] < a3[1].n128_u16[0])
  {
    result = *a3;
    v16 = a3[1].n128_u64[0];
    v17 = a4[1].n128_u16[0];
    *a3 = *a4;
    a3[1].n128_u16[0] = v17;
    a4[1].n128_u16[0] = v16;
    *a4 = result;
    if (a3[1].n128_u16[0] < a2[1].n128_u16[0])
    {
      result = *a2;
      v18 = a2[1].n128_u64[0];
      v19 = a3[1].n128_u16[0];
      *a2 = *a3;
      a2[1].n128_u16[0] = v19;
      a3[1].n128_u16[0] = v18;
      *a3 = result;
      if (a2[1].n128_u16[0] < a1[1].n128_u16[0])
      {
        result = *a1;
        v20 = a1[1].n128_u64[0];
        v21 = a2[1].n128_u16[0];
        *a1 = *a2;
        a1[1].n128_u16[0] = v21;
        a2[1].n128_u16[0] = v20;
        *a2 = result;
      }
    }
  }
  return result;
}

void webrtc::TrackMediaInfoMap::Initialize(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, _QWORD *a6, uint64_t a7)
{
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  int v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  int v25;
  uint64_t *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t *v29;
  uint64_t **v30;
  uint64_t **v31;
  unsigned int v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t **v36;
  unsigned int v37;
  uint64_t *v38;
  uint64_t *v39;
  _QWORD *v40;
  int v41;
  uint64_t *v42;
  int *v43;
  int *v44;
  uint64_t v45;
  _QWORD *v46;
  unsigned int v47;
  _QWORD **v48;
  _QWORD *v49;
  unsigned int v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  BOOL v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  _BYTE *v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  unsigned int v69;
  _QWORD **v70;
  _QWORD *v71;
  unsigned int v72;
  _QWORD *v73;
  _QWORD *v74;
  _QWORD *v75;
  uint64_t v76;
  _QWORD *v77;
  uint64_t v78;
  _BYTE *v79;
  int v80;
  uint64_t v81;
  int v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  _QWORD *v89;
  unint64_t **v90;
  int v91;
  uint64_t *v92;
  unint64_t *v93;
  uint64_t **v94;
  _QWORD *v95;
  unint64_t v96;
  _QWORD *v97;
  uint64_t v98;
  uint64_t *v99;
  _QWORD *v100;
  unint64_t **v101;
  int v102;
  uint64_t *v103;
  unint64_t *v104;
  uint64_t **v105;
  _QWORD *v106;
  unint64_t v107;
  _QWORD *v108;
  uint64_t v109;
  uint64_t *v110;
  uint64_t *v111;
  uint64_t *v112;
  uint64_t **v113;
  uint64_t **v114;
  unsigned int *v115;
  unsigned int *v116;
  unsigned int v117;
  uint64_t *v118;
  uint64_t **v119;
  uint64_t *v120;
  uint64_t **v121;
  unsigned int v122;
  uint64_t *v123;
  uint64_t *v124;
  uint64_t *v125;
  uint64_t *v126;
  uint64_t **v127;
  uint64_t **v128;
  unint64_t v129;
  uint64_t *v130;
  uint64_t v131;
  uint64_t *v132;
  uint64_t *v133;
  unsigned int v134;
  uint64_t *v135;
  uint64_t **v136;
  uint64_t **v137;
  uint64_t *v138;
  unsigned int v139;
  unsigned int v140;
  uint64_t *v141;
  uint64_t v142;
  uint64_t *v143;
  unint64_t v144;
  uint64_t v145;
  uint64_t **v146;
  uint64_t **v147;
  unsigned int *v148;
  unsigned int v149;
  _QWORD *v150;
  _QWORD **v151;
  _QWORD *v152;
  _QWORD **v153;
  unsigned int v154;
  _QWORD *v155;
  _QWORD *v156;
  _QWORD *v157;
  uint64_t *v158;
  uint64_t *v159;
  uint64_t **v160;
  uint64_t **v161;
  uint64_t *v162;
  unint64_t v163;
  uint64_t *v164;
  uint64_t v165;
  uint64_t *v166;
  uint64_t *v167;
  unsigned int *v168;
  unsigned int *v169;
  unsigned int v170;
  uint64_t *v171;
  unint64_t v172;
  uint64_t *v173;
  unsigned int v174;
  unsigned int v175;
  uint64_t **v176;
  uint64_t **v177;
  unsigned int v178;
  uint64_t *v179;
  uint64_t v180;
  uint64_t *v181;
  _QWORD *v182;
  int *v183;
  int v184;
  _DWORD *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  unsigned int *v189;
  unsigned int *v190;
  unsigned int v191;
  _QWORD *v192;
  _QWORD *v193;
  _QWORD **v194;
  unsigned int v195;
  _QWORD *v196;
  _QWORD *v197;
  uint64_t v198;
  _QWORD *v199;
  uint64_t v200;
  _BYTE *v201;
  int v202;
  uint64_t v203;
  int v204;
  uint64_t *v205;
  uint64_t v206;
  uint64_t v207;
  _QWORD *v208;
  uint64_t v209;
  unsigned int v210;
  uint64_t **v211;
  uint64_t *v212;
  uint64_t *v213;
  uint64_t **v214;
  unsigned int v215;
  uint64_t *v216;
  uint64_t *v217;
  uint64_t *v218;
  _QWORD *v219;
  _QWORD **v220;
  uint64_t **v221;
  uint64_t *v222;
  uint64_t **v223;
  unint64_t v224;
  uint64_t *v225;
  uint64_t v226;
  uint64_t *v227;
  uint64_t *v228;
  unint64_t v229;
  uint64_t v230;
  uint64_t **v231;
  uint64_t **v232;
  unsigned int *v233;
  unsigned int v234;
  uint64_t *v235;
  uint64_t **v236;
  uint64_t **v237;
  unsigned int v238;
  uint64_t *v239;
  uint64_t v240;
  uint64_t *v241;
  unsigned int *v242;
  unsigned int v243;
  uint64_t *v244;
  uint64_t **v245;
  uint64_t *v246;
  uint64_t **v247;
  unsigned int v248;
  uint64_t **v249;
  uint64_t *v250;
  uint64_t *v251;
  uint64_t *v252;
  uint64_t *v253;
  uint64_t **v254;
  uint64_t **v255;
  unint64_t v256;
  uint64_t *v257;
  uint64_t v258;
  uint64_t *v259;
  uint64_t *v260;
  unint64_t v261;
  uint64_t v262;
  uint64_t **v263;
  uint64_t **v264;
  unsigned int *v265;
  unsigned int v266;
  _QWORD *v267;
  _QWORD **v268;
  _QWORD *v269;
  _QWORD **v270;
  unsigned int v271;
  _QWORD *v272;
  _QWORD *v273;
  _QWORD *v274;
  uint64_t *v275;
  uint64_t *v276;
  uint64_t **v277;
  uint64_t **v278;
  uint64_t *v279;
  unint64_t v280;
  uint64_t *v281;
  uint64_t v282;
  uint64_t *v283;
  uint64_t *v284;
  unsigned int *v285;
  unsigned int v286;
  uint64_t *v287;
  uint64_t **v288;
  uint64_t **v289;
  unint64_t v290;
  unsigned int v291;
  uint64_t *v292;
  uint64_t v293;
  uint64_t *v294;
  std::string *v295;
  char v296;
  _BYTE *v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v301;
  _QWORD *v302;
  _QWORD *v303;
  _QWORD *v304;
  uint64_t *v305;
  uint64_t *v306;
  _QWORD *v307;
  _QWORD *v308;
  uint64_t v309;
  _QWORD *v310;
  _QWORD *v311;
  uint64_t v312;
  uint64_t **v313;
  uint64_t *v314;
  uint64_t v315;
  uint64_t **v316;
  uint64_t *v317;
  uint64_t v318;
  uint64_t *v319;
  _QWORD *v320;
  uint64_t v321;
  int *v322;
  int *v323;

  v13 = rtc::Thread::Current((rtc::Thread *)a1);
  v296 = v13[217];
  v297 = v13;
  v13[217] = 0;
  *(_BYTE *)a1 = 1;
  v18 = (uint64_t *)(a1 + 8);
  if (*(unsigned __int8 *)(a1 + 112) == *(unsigned __int8 *)(a2 + 104))
  {
    if (*(_BYTE *)(a1 + 112))
    {
      if (v18 != (uint64_t *)a2)
      {
        std::vector<cricket::VoiceSenderInfo>::__assign_with_size[abi:sn180100]<cricket::VoiceSenderInfo*,cricket::VoiceSenderInfo*>(v18, *(_QWORD *)a2, *(_QWORD *)(a2 + 8), 0x7D6343EB1A1F58D1 * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3));
        std::vector<cricket::VoiceReceiverInfo>::__assign_with_size[abi:sn180100]<cricket::VoiceReceiverInfo*,cricket::VoiceReceiverInfo*>((uint64_t *)(a1 + 32), *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32), 0xF83E0F83E0F83E1 * ((uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 4));
        std::__tree<std::__value_type<int,webrtc::RtpCodecParameters>,std::__map_value_compare<int,std::__value_type<int,webrtc::RtpCodecParameters>,std::less<int>,true>,std::allocator<std::__value_type<int,webrtc::RtpCodecParameters>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<int,webrtc::RtpCodecParameters>,std::__tree_node<std::__value_type<int,webrtc::RtpCodecParameters>,void *> *,long>>(a1 + 56, *(_QWORD **)(a2 + 48), (_QWORD *)(a2 + 56));
        std::__tree<std::__value_type<int,webrtc::RtpCodecParameters>,std::__map_value_compare<int,std::__value_type<int,webrtc::RtpCodecParameters>,std::less<int>,true>,std::allocator<std::__value_type<int,webrtc::RtpCodecParameters>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<int,webrtc::RtpCodecParameters>,std::__tree_node<std::__value_type<int,webrtc::RtpCodecParameters>,void *> *,long>>(a1 + 80, *(_QWORD **)(a2 + 72), (_QWORD *)(a2 + 80));
      }
      *(_DWORD *)(a1 + 104) = *(_DWORD *)(a2 + 96);
      v19 = (uint64_t *)(a1 + 120);
      v20 = *(unsigned __int8 *)(a1 + 240);
      if (v20 != *(unsigned __int8 *)(a3 + 120))
        goto LABEL_6;
LABEL_11:
      v21 = a6;
      if (v19 != (uint64_t *)a3 && v20)
      {
        std::vector<cricket::VideoSenderInfo>::__assign_with_size[abi:sn180100]<cricket::VideoSenderInfo*,cricket::VideoSenderInfo*>(v19, *(_QWORD *)a3, *(_QWORD *)(a3 + 8), 0x823EE08FB823EE09 * ((uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3));
        std::vector<cricket::VideoSenderInfo>::__assign_with_size[abi:sn180100]<cricket::VideoSenderInfo*,cricket::VideoSenderInfo*>((uint64_t *)(a1 + 144), *(_QWORD *)(a3 + 24), *(_QWORD *)(a3 + 32), 0x823EE08FB823EE09 * ((uint64_t)(*(_QWORD *)(a3 + 32) - *(_QWORD *)(a3 + 24)) >> 3));
        std::vector<cricket::VideoReceiverInfo>::__assign_with_size[abi:sn180100]<cricket::VideoReceiverInfo*,cricket::VideoReceiverInfo*>((uint64_t *)(a1 + 168), *(__int128 **)(a3 + 48), *(__int128 **)(a3 + 56), 0x2FD2FD2FD2FD2FD3 * ((uint64_t)(*(_QWORD *)(a3 + 56) - *(_QWORD *)(a3 + 48)) >> 3));
        std::__tree<std::__value_type<int,webrtc::RtpCodecParameters>,std::__map_value_compare<int,std::__value_type<int,webrtc::RtpCodecParameters>,std::less<int>,true>,std::allocator<std::__value_type<int,webrtc::RtpCodecParameters>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<int,webrtc::RtpCodecParameters>,std::__tree_node<std::__value_type<int,webrtc::RtpCodecParameters>,void *> *,long>>(a1 + 192, *(_QWORD **)(a3 + 72), (_QWORD *)(a3 + 80));
        std::__tree<std::__value_type<int,webrtc::RtpCodecParameters>,std::__map_value_compare<int,std::__value_type<int,webrtc::RtpCodecParameters>,std::less<int>,true>,std::allocator<std::__value_type<int,webrtc::RtpCodecParameters>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<int,webrtc::RtpCodecParameters>,std::__tree_node<std::__value_type<int,webrtc::RtpCodecParameters>,void *> *,long>>(a1 + 216, *(_QWORD **)(a3 + 96), (_QWORD *)(a3 + 104));
      }
      goto LABEL_15;
    }
  }
  else
  {
    if (!*(_BYTE *)(a1 + 112))
    {
      cricket::VoiceMediaInfo::VoiceMediaInfo((cricket::VoiceMediaInfo *)v18, (const cricket::VoiceMediaInfo *)a2);
      *(_BYTE *)(a1 + 112) = 1;
      v19 = (uint64_t *)(a1 + 120);
      v20 = *(unsigned __int8 *)(a1 + 240);
      if (v20 == *(unsigned __int8 *)(a3 + 120))
        goto LABEL_11;
      goto LABEL_6;
    }
    cricket::VoiceMediaInfo::~VoiceMediaInfo((char **)v18);
    *(_BYTE *)(a1 + 112) = 0;
  }
  v19 = (uint64_t *)(a1 + 120);
  v20 = *(unsigned __int8 *)(a1 + 240);
  if (v20 == *(unsigned __int8 *)(a3 + 120))
    goto LABEL_11;
LABEL_6:
  v21 = a6;
  if (v20)
  {
    cricket::VideoMediaInfo::~VideoMediaInfo((char **)v19);
    *(_BYTE *)(a1 + 240) = 0;
  }
  else
  {
    cricket::VideoMediaInfo::VideoMediaInfo((cricket::VideoMediaInfo *)v19, (const cricket::VideoMediaInfo *)a3);
    *(_BYTE *)(a1 + 240) = 1;
  }
LABEL_15:
  v317 = 0;
  v318 = 0;
  v301 = a1;
  v315 = 0;
  v316 = &v317;
  v313 = &v314;
  v314 = 0;
  v311 = 0;
  v312 = 0;
  v309 = 0;
  v310 = &v311;
  v307 = &v308;
  v308 = 0;
  v305 = 0;
  v306 = 0;
  if (a5)
    v22 = a4;
  else
    v22 = 0;
  v298 = a5;
  v299 = a7;
  if (!a7)
    v21 = 0;
  if (a5)
  {
    v23 = &v22[a5];
    v24 = a4;
    do
    {
      v25 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v24 + 64))(*v24);
      (*(void (**)(uint64_t **__return_ptr))(*(_QWORD *)*v24 + 40))(&v319);
      v26 = v319;
      if (v319)
      {
        (*(void (**)(uint64_t *))(*v319 + 8))(v319);
        v27 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v24 + 56))(*v24);
        if (v27)
        {
          v28 = v27;
          if (v25)
          {
            v29 = v314;
            v30 = &v314;
LABEL_30:
            v31 = v30;
            if (v29)
            {
              do
              {
                v30 = (uint64_t **)v29;
                v32 = *((_DWORD *)v29 + 8);
                if (v27 < v32)
                {
                  v29 = *v30;
                  goto LABEL_30;
                }
                if (v32 >= v27)
                  goto LABEL_23;
                v29 = v30[1];
              }
              while (v29);
              v31 = v30 + 1;
            }
            v33 = (uint64_t *)v30;
            v30 = (uint64_t **)operator new(0x30uLL);
            *((_DWORD *)v30 + 8) = v28;
            v30[5] = 0;
            *v30 = 0;
            v30[1] = 0;
            v30[2] = v33;
            *v31 = (uint64_t *)v30;
            v34 = (uint64_t *)v30;
            if (*v313)
            {
              v313 = (uint64_t **)*v313;
              v34 = *v31;
            }
            std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(v314, v34);
            ++v315;
          }
          else
          {
            v35 = v317;
            v30 = &v317;
LABEL_39:
            v36 = v30;
            if (v35)
            {
              do
              {
                v30 = (uint64_t **)v35;
                v37 = *((_DWORD *)v35 + 8);
                if (v27 < v37)
                {
                  v35 = *v30;
                  goto LABEL_39;
                }
                if (v37 >= v27)
                  goto LABEL_23;
                v35 = v30[1];
              }
              while (v35);
              v36 = v30 + 1;
            }
            v38 = (uint64_t *)v30;
            v30 = (uint64_t **)operator new(0x30uLL);
            *((_DWORD *)v30 + 8) = v28;
            v30[5] = 0;
            *v30 = 0;
            v30[1] = 0;
            v30[2] = v38;
            *v36 = (uint64_t *)v30;
            v39 = (uint64_t *)v30;
            if (*v316)
            {
              v316 = (uint64_t **)*v316;
              v39 = *v36;
            }
            std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(v317, v39);
            ++v318;
          }
LABEL_23:
          v30[5] = v26;
        }
      }
      ++v24;
    }
    while (v24 != v23);
  }
  if (v299)
  {
    v302 = &v21[v299];
    v40 = a6;
    do
    {
      v41 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v40 + 64))(*v40);
      (*(void (**)(uint64_t **__return_ptr))(*(_QWORD *)*v40 + 32))(&v319);
      v42 = v319;
      if (v319)
        (*(void (**)(uint64_t *))(*v319 + 8))(v319);
      (*(void (**)(uint64_t **__return_ptr))(*(_QWORD *)*v40 + 80))(&v319);
      v43 = v322;
      v44 = v323;
      if (v322 != v323)
      {
        if (v41)
        {
          v45 = v309;
          do
          {
            while (!*((_BYTE *)v43 + 4))
            {
              v305 = v42;
              v43 += 68;
              if (v43 == v44)
                goto LABEL_49;
            }
            v46 = v308;
            v47 = *v43;
            v48 = &v308;
LABEL_59:
            v49 = v48;
            if (v46)
            {
              do
              {
                v48 = (_QWORD **)v46;
                v50 = *((_DWORD *)v46 + 8);
                if (v47 < v50)
                {
                  v46 = *v48;
                  goto LABEL_59;
                }
                if (v50 >= v47)
                  goto LABEL_89;
                v46 = v48[1];
              }
              while (v46);
              v49 = v48 + 1;
            }
            v51 = v48;
            v48 = (_QWORD **)operator new(0x30uLL);
            *((_DWORD *)v48 + 8) = v47;
            v48[5] = 0;
            *v48 = 0;
            v48[1] = 0;
            v48[2] = v51;
            *v49 = v48;
            v52 = v48;
            if (*v307)
            {
              v307 = (_QWORD *)*v307;
              v52 = (_QWORD *)*v49;
            }
            v53 = v308;
            v54 = v52 == v308;
            *((_BYTE *)v52 + 24) = v52 == v308;
            if (!v54)
            {
              do
              {
                v55 = v52[2];
                if (*(_BYTE *)(v55 + 24))
                  break;
                v56 = *(_QWORD **)(v55 + 16);
                v57 = *v56;
                if (*v56 == v55)
                {
                  v60 = v56[1];
                  if (!v60 || (v61 = *(unsigned __int8 *)(v60 + 24), v58 = (_BYTE *)(v60 + 24), v61))
                  {
                    if (*(_QWORD **)v55 == v52)
                    {
                      *(_BYTE *)(v55 + 24) = 1;
                      *((_BYTE *)v56 + 24) = 0;
                      v64 = *(_QWORD *)(v55 + 8);
                      *v56 = v64;
                      if (v64)
                        goto LABEL_81;
                    }
                    else
                    {
                      v62 = *(uint64_t **)(v55 + 8);
                      v63 = *v62;
                      *(_QWORD *)(v55 + 8) = *v62;
                      if (v63)
                      {
                        *(_QWORD *)(v63 + 16) = v55;
                        v56 = *(_QWORD **)(v55 + 16);
                      }
                      v62[2] = (uint64_t)v56;
                      *(_QWORD *)(*(_QWORD *)(v55 + 16) + 8 * (**(_QWORD **)(v55 + 16) != v55)) = v62;
                      *v62 = v55;
                      *(_QWORD *)(v55 + 16) = v62;
                      v56 = (_QWORD *)v62[2];
                      v55 = *v56;
                      *((_BYTE *)v62 + 24) = 1;
                      *((_BYTE *)v56 + 24) = 0;
                      v64 = *(_QWORD *)(v55 + 8);
                      *v56 = v64;
                      if (v64)
LABEL_81:
                        *(_QWORD *)(v64 + 16) = v56;
                    }
                    *(_QWORD *)(v55 + 16) = v56[2];
                    *(_QWORD *)(v56[2] + 8 * (*(_QWORD *)v56[2] != (_QWORD)v56)) = v55;
                    *(_QWORD *)(v55 + 8) = v56;
LABEL_87:
                    v56[2] = v55;
                    break;
                  }
                }
                else if (!v57 || (v59 = *(unsigned __int8 *)(v57 + 24), v58 = (_BYTE *)(v57 + 24), v59))
                {
                  if (*(_QWORD **)v55 == v52)
                  {
                    v66 = v52[1];
                    *(_QWORD *)v55 = v66;
                    if (v66)
                    {
                      *(_QWORD *)(v66 + 16) = v55;
                      v56 = *(_QWORD **)(v55 + 16);
                    }
                    v52[2] = v56;
                    *(_QWORD *)(*(_QWORD *)(v55 + 16) + 8 * (**(_QWORD **)(v55 + 16) != v55)) = v52;
                    v52[1] = v55;
                    *(_QWORD *)(v55 + 16) = v52;
                    v56 = (_QWORD *)v52[2];
                    *((_BYTE *)v52 + 24) = 1;
                    *((_BYTE *)v56 + 24) = 0;
                    v55 = v56[1];
                    v65 = *(_QWORD **)v55;
                    v56[1] = *(_QWORD *)v55;
                    if (v65)
LABEL_85:
                      v65[2] = v56;
                  }
                  else
                  {
                    *(_BYTE *)(v55 + 24) = 1;
                    *((_BYTE *)v56 + 24) = 0;
                    v55 = v56[1];
                    v65 = *(_QWORD **)v55;
                    v56[1] = *(_QWORD *)v55;
                    if (v65)
                      goto LABEL_85;
                  }
                  *(_QWORD *)(v55 + 16) = v56[2];
                  *(_QWORD *)(v56[2] + 8 * (*(_QWORD *)v56[2] != (_QWORD)v56)) = v55;
                  *(_QWORD *)v55 = v56;
                  goto LABEL_87;
                }
                *(_BYTE *)(v55 + 24) = 1;
                v52 = v56;
                *((_BYTE *)v56 + 24) = v56 == v53;
                *v58 = 1;
              }
              while (v56 != v53);
            }
            v309 = ++v45;
LABEL_89:
            v48[5] = v42;
            v43 += 68;
          }
          while (v43 != v44);
        }
        else
        {
          v67 = v312;
          do
          {
            while (!*((_BYTE *)v43 + 4))
            {
              v306 = v42;
              v43 += 68;
              if (v43 == v44)
                goto LABEL_49;
            }
            v68 = v311;
            v69 = *v43;
            v70 = &v311;
LABEL_102:
            v71 = v70;
            if (v68)
            {
              do
              {
                v70 = (_QWORD **)v68;
                v72 = *((_DWORD *)v68 + 8);
                if (v69 < v72)
                {
                  v68 = *v70;
                  goto LABEL_102;
                }
                if (v72 >= v69)
                  goto LABEL_132;
                v68 = v70[1];
              }
              while (v68);
              v71 = v70 + 1;
            }
            v73 = v70;
            v70 = (_QWORD **)operator new(0x30uLL);
            *((_DWORD *)v70 + 8) = v69;
            v70[5] = 0;
            *v70 = 0;
            v70[1] = 0;
            v70[2] = v73;
            *v71 = v70;
            v74 = v70;
            if (*v310)
            {
              v310 = (_QWORD *)*v310;
              v74 = (_QWORD *)*v71;
            }
            v75 = v311;
            v54 = v74 == v311;
            *((_BYTE *)v74 + 24) = v74 == v311;
            if (!v54)
            {
              do
              {
                v76 = v74[2];
                if (*(_BYTE *)(v76 + 24))
                  break;
                v77 = *(_QWORD **)(v76 + 16);
                v78 = *v77;
                if (*v77 == v76)
                {
                  v81 = v77[1];
                  if (!v81 || (v82 = *(unsigned __int8 *)(v81 + 24), v79 = (_BYTE *)(v81 + 24), v82))
                  {
                    if (*(_QWORD **)v76 == v74)
                    {
                      *(_BYTE *)(v76 + 24) = 1;
                      *((_BYTE *)v77 + 24) = 0;
                      v85 = *(_QWORD *)(v76 + 8);
                      *v77 = v85;
                      if (v85)
                        goto LABEL_124;
                    }
                    else
                    {
                      v83 = *(uint64_t **)(v76 + 8);
                      v84 = *v83;
                      *(_QWORD *)(v76 + 8) = *v83;
                      if (v84)
                      {
                        *(_QWORD *)(v84 + 16) = v76;
                        v77 = *(_QWORD **)(v76 + 16);
                      }
                      v83[2] = (uint64_t)v77;
                      *(_QWORD *)(*(_QWORD *)(v76 + 16) + 8 * (**(_QWORD **)(v76 + 16) != v76)) = v83;
                      *v83 = v76;
                      *(_QWORD *)(v76 + 16) = v83;
                      v77 = (_QWORD *)v83[2];
                      v76 = *v77;
                      *((_BYTE *)v83 + 24) = 1;
                      *((_BYTE *)v77 + 24) = 0;
                      v85 = *(_QWORD *)(v76 + 8);
                      *v77 = v85;
                      if (v85)
LABEL_124:
                        *(_QWORD *)(v85 + 16) = v77;
                    }
                    *(_QWORD *)(v76 + 16) = v77[2];
                    *(_QWORD *)(v77[2] + 8 * (*(_QWORD *)v77[2] != (_QWORD)v77)) = v76;
                    *(_QWORD *)(v76 + 8) = v77;
LABEL_130:
                    v77[2] = v76;
                    break;
                  }
                }
                else if (!v78 || (v80 = *(unsigned __int8 *)(v78 + 24), v79 = (_BYTE *)(v78 + 24), v80))
                {
                  if (*(_QWORD **)v76 == v74)
                  {
                    v87 = v74[1];
                    *(_QWORD *)v76 = v87;
                    if (v87)
                    {
                      *(_QWORD *)(v87 + 16) = v76;
                      v77 = *(_QWORD **)(v76 + 16);
                    }
                    v74[2] = v77;
                    *(_QWORD *)(*(_QWORD *)(v76 + 16) + 8 * (**(_QWORD **)(v76 + 16) != v76)) = v74;
                    v74[1] = v76;
                    *(_QWORD *)(v76 + 16) = v74;
                    v77 = (_QWORD *)v74[2];
                    *((_BYTE *)v74 + 24) = 1;
                    *((_BYTE *)v77 + 24) = 0;
                    v76 = v77[1];
                    v86 = *(_QWORD **)v76;
                    v77[1] = *(_QWORD *)v76;
                    if (v86)
LABEL_128:
                      v86[2] = v77;
                  }
                  else
                  {
                    *(_BYTE *)(v76 + 24) = 1;
                    *((_BYTE *)v77 + 24) = 0;
                    v76 = v77[1];
                    v86 = *(_QWORD **)v76;
                    v77[1] = *(_QWORD *)v76;
                    if (v86)
                      goto LABEL_128;
                  }
                  *(_QWORD *)(v76 + 16) = v77[2];
                  *(_QWORD *)(v77[2] + 8 * (*(_QWORD *)v77[2] != (_QWORD)v77)) = v76;
                  *(_QWORD *)v76 = v77;
                  goto LABEL_130;
                }
                *(_BYTE *)(v76 + 24) = 1;
                v74 = v77;
                *((_BYTE *)v77 + 24) = v77 == v75;
                *v79 = 1;
              }
              while (v77 != v75);
            }
            v312 = ++v67;
LABEL_132:
            v70[5] = v42;
            v43 += 68;
          }
          while (v43 != v44);
        }
      }
LABEL_49:
      webrtc::RtpParameters::~RtpParameters((void **)&v319);
      ++v40;
    }
    while (v40 != v302);
  }
  v88 = v301;
  if (v298)
  {
    v89 = &a4[v298];
    v90 = (unint64_t **)(v301 + 352);
    do
    {
      v91 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a4 + 272))(*a4);
      (*(void (**)(uint64_t **__return_ptr))(*(_QWORD *)*a4 + 40))(&v319);
      v92 = v319;
      v93 = *v90;
      v94 = (uint64_t **)(v301 + 352);
      v95 = (_QWORD *)(v301 + 352);
      if (*v90)
      {
        while (1)
        {
          while (1)
          {
            v95 = v93;
            v96 = v93[4];
            if ((unint64_t)v319 >= v96)
              break;
            v93 = (unint64_t *)*v95;
            v94 = (uint64_t **)v95;
            if (!*v95)
              goto LABEL_150;
          }
          if (v96 >= (unint64_t)v319)
            break;
          v93 = (unint64_t *)v95[1];
          if (!v93)
          {
            v94 = (uint64_t **)(v95 + 1);
            goto LABEL_150;
          }
        }
      }
      else
      {
LABEL_150:
        v97 = v95;
        v95 = operator new(0x30uLL);
        v95[4] = v92;
        *((_DWORD *)v95 + 10) = 0;
        *v95 = 0;
        v95[1] = 0;
        v95[2] = v97;
        *v94 = v95;
        v98 = **(_QWORD **)(v301 + 344);
        v99 = v95;
        if (v98)
        {
          *(_QWORD *)(v301 + 344) = v98;
          v99 = *v94;
        }
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v301 + 352), v99);
        ++*(_QWORD *)(v301 + 360);
        v92 = v319;
      }
      *((_DWORD *)v95 + 10) = v91;
      if (v92)
        (*(void (**)(uint64_t *))(*v92 + 8))(v92);
      ++a4;
    }
    while (a4 != v89);
  }
  v100 = a6;
  if (v299)
  {
    v101 = (unint64_t **)(v301 + 352);
    do
    {
      v102 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v100 + 232))(*v100);
      (*(void (**)(uint64_t **__return_ptr))(*(_QWORD *)*v100 + 32))(&v319);
      v103 = v319;
      v104 = *v101;
      v105 = (uint64_t **)(v301 + 352);
      v106 = (_QWORD *)(v301 + 352);
      if (*v101)
      {
        while (1)
        {
          while (1)
          {
            v106 = v104;
            v107 = v104[4];
            if ((unint64_t)v319 >= v107)
              break;
            v104 = (unint64_t *)*v106;
            v105 = (uint64_t **)v106;
            if (!*v106)
              goto LABEL_165;
          }
          if (v107 >= (unint64_t)v319)
            break;
          v104 = (unint64_t *)v106[1];
          if (!v104)
          {
            v105 = (uint64_t **)(v106 + 1);
            goto LABEL_165;
          }
        }
      }
      else
      {
LABEL_165:
        v108 = v106;
        v106 = operator new(0x30uLL);
        v106[4] = v103;
        *((_DWORD *)v106 + 10) = 0;
        *v106 = 0;
        v106[1] = 0;
        v106[2] = v108;
        *v105 = v106;
        v109 = **(_QWORD **)(v301 + 344);
        v110 = v106;
        if (v109)
        {
          *(_QWORD *)(v301 + 344) = v109;
          v110 = *v105;
        }
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v301 + 352), v110);
        ++*(_QWORD *)(v301 + 360);
        v103 = v319;
      }
      *((_DWORD *)v106 + 10) = v102;
      if (v103)
        (*(void (**)(uint64_t *))(*v103 + 8))(v103);
      ++v100;
    }
    while (v100 != &a6[v299]);
  }
  if (!*(_BYTE *)(v301 + 112))
    goto LABEL_287;
  v111 = *(uint64_t **)(v301 + 8);
  v112 = *(uint64_t **)(v301 + 16);
  if (v111 == v112)
    goto LABEL_223;
  v113 = (uint64_t **)(v301 + 256);
  v114 = (uint64_t **)(v301 + 376);
  do
  {
    v115 = (unsigned int *)v111[14];
    v116 = (unsigned int *)v111[15];
    if (v116 == v115)
    {
      v117 = 0;
      v118 = v317;
      if (!v317)
        goto LABEL_207;
    }
    else
    {
      v117 = *v115;
      v118 = v317;
      if (!v317)
        goto LABEL_207;
    }
    v119 = &v317;
    do
    {
      v120 = v118;
      v121 = v119;
      v122 = *((_DWORD *)v118 + 8);
      if (v122 >= v117)
        v119 = (uint64_t **)v118;
      else
        ++v118;
      v118 = (uint64_t *)*v118;
    }
    while (v118);
    if (v119 != &v317)
    {
      v123 = v122 >= v117 ? v120 : (uint64_t *)v121;
      if (*((_DWORD *)v123 + 8) <= v117)
      {
        v124 = v122 >= v117 ? v120 : (uint64_t *)v121;
        v125 = (uint64_t *)v124[5];
        if (v125)
        {
          v126 = *v113;
          v127 = (uint64_t **)(v301 + 256);
          v128 = (uint64_t **)(v301 + 256);
          if (*v113)
          {
            while (1)
            {
              while (1)
              {
                v128 = (uint64_t **)v126;
                v129 = v126[4];
                if ((unint64_t)v111 >= v129)
                  break;
                v126 = *v128;
                v127 = v128;
                if (!*v128)
                  goto LABEL_201;
              }
              if (v129 >= (unint64_t)v111)
                break;
              v126 = v128[1];
              if (!v126)
              {
                v127 = v128 + 1;
                goto LABEL_201;
              }
            }
          }
          else
          {
LABEL_201:
            v130 = (uint64_t *)v128;
            v128 = (uint64_t **)operator new(0x30uLL);
            v128[4] = v111;
            v128[5] = 0;
            *v128 = 0;
            v128[1] = 0;
            v128[2] = v130;
            *v127 = (uint64_t *)v128;
            v131 = **(_QWORD **)(v301 + 248);
            v132 = (uint64_t *)v128;
            if (v131)
            {
              *(_QWORD *)(v301 + 248) = v131;
              v132 = *v127;
            }
            std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v301 + 256), v132);
            ++*(_QWORD *)(v301 + 264);
          }
          (*(void (**)(uint64_t *))*v125)(v125);
          v133 = v128[5];
          if (v133)
            (*(void (**)(uint64_t *))(*v133 + 8))(v133);
          v128[5] = v125;
          v115 = (unsigned int *)v111[14];
          v116 = (unsigned int *)v111[15];
        }
      }
    }
LABEL_207:
    if (v116 != v115)
    {
      v134 = *v115;
      if (*v115)
      {
        v135 = *v114;
        v136 = (uint64_t **)(v301 + 376);
        v137 = (uint64_t **)(v301 + 376);
        if (*v114)
        {
          v138 = *v114;
          do
          {
            v139 = *((_DWORD *)v138 + 8);
            if (v134 >= v139)
            {
              if (v139 >= v134)
                goto LABEL_481;
              ++v138;
            }
            v138 = (uint64_t *)*v138;
          }
          while (v138);
          while (1)
          {
            while (1)
            {
              v137 = (uint64_t **)v135;
              v140 = *((_DWORD *)v135 + 8);
              if (v134 >= v140)
                break;
              v135 = *v137;
              v136 = v137;
              if (!*v137)
                goto LABEL_220;
            }
            if (v140 >= v134)
              break;
            v135 = v137[1];
            if (!v135)
            {
              v136 = v137 + 1;
              goto LABEL_220;
            }
          }
        }
        else
        {
LABEL_220:
          v141 = (uint64_t *)v137;
          v137 = (uint64_t **)operator new(0x30uLL);
          *((_DWORD *)v137 + 8) = v134;
          v137[5] = 0;
          *v137 = 0;
          v137[1] = 0;
          v137[2] = v141;
          *v136 = (uint64_t *)v137;
          v142 = **(_QWORD **)(v301 + 368);
          v143 = (uint64_t *)v137;
          if (v142)
          {
            *(_QWORD *)(v301 + 368) = v142;
            v143 = *v136;
          }
          std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v301 + 376), v143);
          ++*(_QWORD *)(v301 + 384);
        }
        v137[5] = v111;
      }
    }
    v111 += 49;
  }
  while (v111 != v112);
  if (!*(_BYTE *)(v301 + 112))
  {
LABEL_479:
    __break(1u);
LABEL_480:
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/track_media_info_map.cc", 164, "voice_info_by_receiver_ssrc_.count(receiver_info.ssrc()) == 0", rtc::webrtc_checks_impl::LogStreamer<>::Call<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int> const&)::t, v14, v15, v16, v17, (uint64_t)"Duplicate voice receiver SSRC: ");
LABEL_481:
    v295 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/track_media_info_map.cc", 150, "voice_info_by_sender_ssrc_.count(sender_info.ssrc()) == 0", rtc::webrtc_checks_impl::LogStreamer<>::Call<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int> const&)::t, v14, v15, v16, v17, (uint64_t)"Duplicate voice sender SSRC: ");
    dcsctp::TraditionalReassemblyStreams::StreamBase::AssembleMessage(v295);
    return;
  }
LABEL_223:
  v144 = *(_QWORD *)(v301 + 32);
  v145 = *(_QWORD *)(v301 + 40);
  if (v144 != v145)
  {
    v146 = (uint64_t **)(v301 + 280);
    v147 = (uint64_t **)(v301 + 400);
    do
    {
      v148 = *(unsigned int **)(v144 + 160);
      if (*(unsigned int **)(v144 + 168) == v148)
      {
        v149 = 0;
        v150 = v311;
        if (!v311)
          goto LABEL_246;
      }
      else
      {
        v149 = *v148;
        v150 = v311;
        if (!v311)
          goto LABEL_246;
      }
      v151 = &v311;
      do
      {
        v152 = v150;
        v153 = v151;
        v154 = *((_DWORD *)v150 + 8);
        v155 = v150 + 1;
        if (v154 >= v149)
        {
          v155 = v152;
          v151 = (_QWORD **)v152;
        }
        v150 = (_QWORD *)*v155;
      }
      while (v150);
      if (v151 != &v311)
      {
        v156 = v154 >= v149 ? v152 : v153;
        if (*((_DWORD *)v156 + 8) <= v149)
        {
          v157 = v154 >= v149 ? v152 : v153;
          v158 = (uint64_t *)v157[5];
          if (v158)
          {
            v159 = *v146;
            v160 = (uint64_t **)(v301 + 280);
            v161 = (uint64_t **)(v301 + 280);
            if (*v146)
            {
              while (1)
              {
                while (1)
                {
                  v161 = (uint64_t **)v159;
                  v172 = v159[4];
                  if (v144 >= v172)
                    break;
                  v159 = *v161;
                  v160 = v161;
                  if (!*v161)
                    goto LABEL_254;
                }
                if (v172 >= v144)
                  goto LABEL_257;
                v159 = v161[1];
                if (!v159)
                {
LABEL_253:
                  v160 = v161 + 1;
                  goto LABEL_254;
                }
              }
            }
            goto LABEL_254;
          }
        }
      }
LABEL_246:
      v158 = v306;
      if (!v306)
        goto LABEL_260;
      v162 = *v146;
      v160 = (uint64_t **)(v301 + 280);
      v161 = (uint64_t **)(v301 + 280);
      if (*v146)
      {
        while (1)
        {
          while (1)
          {
            v161 = (uint64_t **)v162;
            v163 = v162[4];
            if (v144 >= v163)
              break;
            v162 = *v161;
            v160 = v161;
            if (!*v161)
              goto LABEL_254;
          }
          if (v163 >= v144)
            goto LABEL_257;
          v162 = v161[1];
          if (!v162)
            goto LABEL_253;
        }
      }
LABEL_254:
      v164 = (uint64_t *)v161;
      v161 = (uint64_t **)operator new(0x30uLL);
      v161[4] = (uint64_t *)v144;
      v161[5] = 0;
      *v161 = 0;
      v161[1] = 0;
      v161[2] = v164;
      *v160 = (uint64_t *)v161;
      v165 = **(_QWORD **)(v301 + 272);
      v166 = (uint64_t *)v161;
      if (v165)
      {
        *(_QWORD *)(v301 + 272) = v165;
        v166 = *v160;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v301 + 280), v166);
      ++*(_QWORD *)(v301 + 288);
LABEL_257:
      (*(void (**)(uint64_t *))*v158)(v158);
      v167 = v161[5];
      if (v167)
        (*(void (**)(uint64_t *))(*v167 + 8))(v167);
      v161[5] = v158;
LABEL_260:
      v168 = *(unsigned int **)(v144 + 160);
      v169 = *(unsigned int **)(v144 + 168);
      if (v169 == v168)
      {
        v170 = 0;
        v171 = *v147;
        if (*v147)
        {
LABEL_269:
          v173 = v171;
          do
          {
            v174 = *((_DWORD *)v173 + 8);
            if (v170 >= v174)
            {
              if (v174 >= v170)
                goto LABEL_480;
              ++v173;
            }
            v173 = (uint64_t *)*v173;
          }
          while (v173);
        }
      }
      else
      {
        v170 = *v168;
        v171 = *v147;
        if (*v147)
          goto LABEL_269;
      }
      if (v169 == v168)
      {
        v175 = 0;
        v176 = (uint64_t **)(v301 + 400);
        v177 = (uint64_t **)(v301 + 400);
        if (v171)
        {
          while (1)
          {
LABEL_281:
            while (1)
            {
              v177 = (uint64_t **)v171;
              v178 = *((_DWORD *)v171 + 8);
              if (v175 >= v178)
                break;
              v171 = *v177;
              v176 = v177;
              if (!*v177)
                goto LABEL_285;
            }
            if (v178 >= v175)
              goto LABEL_226;
            v171 = v177[1];
            if (!v171)
            {
              v176 = v177 + 1;
              break;
            }
          }
        }
      }
      else
      {
        v175 = *v168;
        v176 = (uint64_t **)(v301 + 400);
        v177 = (uint64_t **)(v301 + 400);
        if (v171)
          goto LABEL_281;
      }
LABEL_285:
      v179 = (uint64_t *)v177;
      v177 = (uint64_t **)operator new(0x30uLL);
      *((_DWORD *)v177 + 8) = v175;
      v177[5] = 0;
      *v177 = 0;
      v177[1] = 0;
      v177[2] = v179;
      *v176 = (uint64_t *)v177;
      v180 = **(_QWORD **)(v301 + 392);
      v181 = (uint64_t *)v177;
      if (v180)
      {
        *(_QWORD *)(v301 + 392) = v180;
        v181 = *v176;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v301 + 400), v181);
      ++*(_QWORD *)(v301 + 408);
LABEL_226:
      v177[5] = (uint64_t *)v144;
      v144 += 528;
    }
    while (v144 != v145);
  }
LABEL_287:
  if (!*(_BYTE *)(v301 + 240))
    goto LABEL_476;
  v182 = *(_QWORD **)(v301 + 120);
  v303 = *(_QWORD **)(v301 + 128);
  if (v182 != v303)
  {
    do
    {
      v320 = 0;
      v321 = 0;
      v183 = (int *)v182[14];
      if ((int *)v182[15] == v183)
        v184 = 0;
      else
        v184 = *v183;
      v185 = operator new(0x20uLL);
      v185[7] = v184;
      *(_QWORD *)v185 = 0;
      *((_QWORD *)v185 + 1) = 0;
      *((_QWORD *)v185 + 2) = &v320;
      v319 = (uint64_t *)v185;
      v320 = v185;
      *((_BYTE *)v185 + 24) = 1;
      v321 = 1;
      v186 = v182[25];
      v187 = v182[26];
      if (v186 == v187)
        goto LABEL_484;
      v304 = v182;
      v188 = 1;
      do
      {
        v190 = *(unsigned int **)(v186 + 24);
        v189 = *(unsigned int **)(v186 + 32);
        while (v190 != v189)
        {
          v191 = *v190;
          v192 = v320;
          v193 = &v320;
          v194 = &v320;
          if (v320)
          {
            while (1)
            {
              while (1)
              {
                v194 = (_QWORD **)v192;
                v195 = *((_DWORD *)v192 + 7);
                if (v191 >= v195)
                  break;
                v192 = *v194;
                v193 = v194;
                if (!*v194)
                  goto LABEL_312;
              }
              if (v195 >= v191)
                break;
              v192 = v194[1];
              if (!v192)
              {
                v193 = v194 + 1;
                goto LABEL_312;
              }
            }
          }
          else
          {
LABEL_312:
            v196 = operator new(0x20uLL);
            *((_DWORD *)v196 + 7) = v191;
            *v196 = 0;
            v196[1] = 0;
            v196[2] = v194;
            *v193 = v196;
            if (*v319)
            {
              v319 = (uint64_t *)*v319;
              v196 = (_QWORD *)*v193;
            }
            v197 = v320;
            v54 = v196 == v320;
            *((_BYTE *)v196 + 24) = v196 == v320;
            if (!v54)
            {
              do
              {
                v198 = v196[2];
                if (*(_BYTE *)(v198 + 24))
                  break;
                v199 = *(_QWORD **)(v198 + 16);
                v200 = *v199;
                if (*v199 == v198)
                {
                  v203 = v199[1];
                  if (!v203 || (v204 = *(unsigned __int8 *)(v203 + 24), v201 = (_BYTE *)(v203 + 24), v204))
                  {
                    if (*(_QWORD **)v198 == v196)
                    {
                      *(_BYTE *)(v198 + 24) = 1;
                      *((_BYTE *)v199 + 24) = 0;
                      v207 = *(_QWORD *)(v198 + 8);
                      *v199 = v207;
                      if (v207)
                        goto LABEL_329;
                    }
                    else
                    {
                      v205 = *(uint64_t **)(v198 + 8);
                      v206 = *v205;
                      *(_QWORD *)(v198 + 8) = *v205;
                      if (v206)
                      {
                        *(_QWORD *)(v206 + 16) = v198;
                        v199 = *(_QWORD **)(v198 + 16);
                      }
                      v205[2] = (uint64_t)v199;
                      *(_QWORD *)(*(_QWORD *)(v198 + 16) + 8 * (**(_QWORD **)(v198 + 16) != v198)) = v205;
                      *v205 = v198;
                      *(_QWORD *)(v198 + 16) = v205;
                      v199 = (_QWORD *)v205[2];
                      v198 = *v199;
                      *((_BYTE *)v205 + 24) = 1;
                      *((_BYTE *)v199 + 24) = 0;
                      v207 = *(_QWORD *)(v198 + 8);
                      *v199 = v207;
                      if (v207)
LABEL_329:
                        *(_QWORD *)(v207 + 16) = v199;
                    }
                    *(_QWORD *)(v198 + 16) = v199[2];
                    *(_QWORD *)(v199[2] + 8 * (*(_QWORD *)v199[2] != (_QWORD)v199)) = v198;
                    *(_QWORD *)(v198 + 8) = v199;
LABEL_301:
                    v199[2] = v198;
                    break;
                  }
                }
                else if (!v200 || (v202 = *(unsigned __int8 *)(v200 + 24), v201 = (_BYTE *)(v200 + 24), v202))
                {
                  if (*(_QWORD **)v198 == v196)
                  {
                    v209 = v196[1];
                    *(_QWORD *)v198 = v209;
                    if (v209)
                    {
                      *(_QWORD *)(v209 + 16) = v198;
                      v199 = *(_QWORD **)(v198 + 16);
                    }
                    v196[2] = v199;
                    *(_QWORD *)(*(_QWORD *)(v198 + 16) + 8 * (**(_QWORD **)(v198 + 16) != v198)) = v196;
                    v196[1] = v198;
                    *(_QWORD *)(v198 + 16) = v196;
                    v199 = (_QWORD *)v196[2];
                    *((_BYTE *)v196 + 24) = 1;
                    *((_BYTE *)v199 + 24) = 0;
                    v198 = v199[1];
                    v208 = *(_QWORD **)v198;
                    v199[1] = *(_QWORD *)v198;
                    if (!v208)
                      goto LABEL_300;
                  }
                  else
                  {
                    *(_BYTE *)(v198 + 24) = 1;
                    *((_BYTE *)v199 + 24) = 0;
                    v198 = v199[1];
                    v208 = *(_QWORD **)v198;
                    v199[1] = *(_QWORD *)v198;
                    if (!v208)
                      goto LABEL_300;
                  }
                  v208[2] = v199;
LABEL_300:
                  *(_QWORD *)(v198 + 16) = v199[2];
                  *(_QWORD *)(v199[2] + 8 * (*(_QWORD *)v199[2] != (_QWORD)v199)) = v198;
                  *(_QWORD *)v198 = v199;
                  goto LABEL_301;
                }
                *(_BYTE *)(v198 + 24) = 1;
                v196 = v199;
                *((_BYTE *)v199 + 24) = v199 == v197;
                *v201 = 1;
              }
              while (v199 != v197);
            }
            v321 = ++v188;
          }
          ++v190;
        }
        v186 += 48;
      }
      while (v186 != v187);
      v185 = v319;
      v182 = v304;
      if (v319 != (uint64_t *)&v320)
      {
LABEL_484:
        while (1)
        {
          if (v314)
          {
            v210 = v185[7];
            v211 = &v314;
            v212 = v314;
            do
            {
              v213 = v212;
              v214 = v211;
              v215 = *((_DWORD *)v212 + 8);
              if (v215 >= v210)
                v211 = (uint64_t **)v212;
              else
                ++v212;
              v212 = (uint64_t *)*v212;
            }
            while (v212);
            if (v211 != &v314)
            {
              v216 = v215 >= v210 ? v213 : (uint64_t *)v214;
              if (*((_DWORD *)v216 + 8) <= v210)
              {
                v217 = v215 >= v210 ? v213 : (uint64_t *)v214;
                v218 = (uint64_t *)v217[5];
                if (v218)
                  break;
              }
            }
          }
          v219 = (_QWORD *)*((_QWORD *)v185 + 1);
          if (v219)
          {
            do
            {
              v220 = (_QWORD **)v219;
              v219 = (_QWORD *)*v219;
            }
            while (v219);
          }
          else
          {
            do
            {
              v220 = (_QWORD **)*((_QWORD *)v185 + 2);
              v54 = *v220 == (_QWORD *)v185;
              v185 = v220;
            }
            while (!v54);
          }
          v185 = v220;
          if (v220 == &v320)
            goto LABEL_291;
        }
        v221 = (uint64_t **)(v301 + 304);
        while (1)
        {
          v222 = *v221;
          v223 = v221;
          if (!*v221)
            break;
          while (1)
          {
            v221 = (uint64_t **)v222;
            v224 = v222[4];
            if ((unint64_t)v182 < v224)
              break;
            if (v224 >= (unint64_t)v182)
              goto LABEL_373;
            v222 = v221[1];
            if (!v222)
            {
              v223 = v221 + 1;
              goto LABEL_370;
            }
          }
        }
LABEL_370:
        v225 = (uint64_t *)v221;
        v221 = (uint64_t **)operator new(0x30uLL);
        v221[4] = v182;
        v221[5] = 0;
        *v221 = 0;
        v221[1] = 0;
        v221[2] = v225;
        *v223 = (uint64_t *)v221;
        v226 = **(_QWORD **)(v301 + 296);
        v227 = (uint64_t *)v221;
        if (v226)
        {
          *(_QWORD *)(v301 + 296) = v226;
          v227 = *v223;
        }
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v301 + 304), v227);
        ++*(_QWORD *)(v301 + 312);
LABEL_373:
        (*(void (**)(uint64_t *))*v218)(v218);
        v228 = v221[5];
        if (v228)
          (*(void (**)(uint64_t *))(*v228 + 8))(v228);
        v221[5] = v218;
      }
LABEL_291:
      std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)&v319, v320);
      v182 += 57;
    }
    while (v182 != v303);
    v88 = v301;
    if (!*(_BYTE *)(v301 + 240))
      goto LABEL_479;
  }
  v229 = *(_QWORD *)(v88 + 144);
  v230 = *(_QWORD *)(v88 + 152);
  if (v229 == v230)
    goto LABEL_422;
  v231 = (uint64_t **)(v88 + 424);
  v232 = (uint64_t **)(v88 + 304);
  while (2)
  {
    v233 = *(unsigned int **)(v229 + 112);
    if (*(unsigned int **)(v229 + 120) != v233)
    {
      v234 = *v233;
      if (*v233)
      {
        v235 = *v231;
        v236 = (uint64_t **)(v88 + 424);
        v237 = (uint64_t **)(v88 + 424);
        if (*v231)
        {
          while (1)
          {
            while (1)
            {
              v237 = (uint64_t **)v235;
              v238 = *((_DWORD *)v235 + 8);
              if (v234 >= v238)
                break;
              v235 = *v237;
              v236 = v237;
              if (!*v237)
                goto LABEL_389;
            }
            if (v238 >= v234)
              break;
            v235 = v237[1];
            if (!v235)
            {
              v236 = v237 + 1;
              goto LABEL_389;
            }
          }
        }
        else
        {
LABEL_389:
          v239 = (uint64_t *)v237;
          v237 = (uint64_t **)operator new(0x30uLL);
          *((_DWORD *)v237 + 8) = v234;
          v237[5] = 0;
          *v237 = 0;
          v237[1] = 0;
          v237[2] = v239;
          *v236 = (uint64_t *)v237;
          v240 = **(_QWORD **)(v88 + 416);
          v241 = (uint64_t *)v237;
          if (v240)
          {
            *(_QWORD *)(v88 + 416) = v240;
            v241 = *v236;
          }
          std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v88 + 424), v241);
          ++*(_QWORD *)(v88 + 432);
        }
        v237[5] = (uint64_t *)v229;
        v242 = *(unsigned int **)(v229 + 112);
        if (*(unsigned int **)(v229 + 120) == v242)
        {
          v243 = 0;
          v244 = v314;
          if (!v314)
            goto LABEL_379;
        }
        else
        {
          v243 = *v242;
          v244 = v314;
          if (!v314)
            goto LABEL_379;
        }
        v245 = &v314;
        do
        {
          v246 = v244;
          v247 = v245;
          v248 = *((_DWORD *)v244 + 8);
          v249 = (uint64_t **)(v244 + 1);
          if (v248 >= v243)
          {
            v249 = (uint64_t **)v246;
            v245 = (uint64_t **)v246;
          }
          v244 = *v249;
        }
        while (v244);
        if (v245 != &v314)
        {
          v250 = v248 >= v243 ? v246 : (uint64_t *)v247;
          if (*((_DWORD *)v250 + 8) <= v243)
          {
            v251 = v248 >= v243 ? v246 : (uint64_t *)v247;
            v252 = (uint64_t *)v251[5];
            if (v252)
            {
              v253 = *v232;
              v254 = (uint64_t **)(v88 + 304);
              v255 = (uint64_t **)(v88 + 304);
              if (*v232)
              {
                while (1)
                {
                  while (1)
                  {
                    v255 = (uint64_t **)v253;
                    v256 = v253[4];
                    if (v229 >= v256)
                      break;
                    v253 = *v255;
                    v254 = v255;
                    if (!*v255)
                      goto LABEL_416;
                  }
                  if (v256 >= v229)
                    break;
                  v253 = v255[1];
                  if (!v253)
                  {
                    v254 = v255 + 1;
                    goto LABEL_416;
                  }
                }
              }
              else
              {
LABEL_416:
                v257 = (uint64_t *)v255;
                v255 = (uint64_t **)operator new(0x30uLL);
                v255[4] = (uint64_t *)v229;
                v255[5] = 0;
                *v255 = 0;
                v255[1] = 0;
                v255[2] = v257;
                *v254 = (uint64_t *)v255;
                v258 = **(_QWORD **)(v88 + 296);
                v259 = (uint64_t *)v255;
                if (v258)
                {
                  *(_QWORD *)(v88 + 296) = v258;
                  v259 = *v254;
                }
                std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v88 + 304), v259);
                ++*(_QWORD *)(v88 + 312);
              }
              (*(void (**)(uint64_t *))*v252)(v252);
              v260 = v255[5];
              if (v260)
                (*(void (**)(uint64_t *))(*v260 + 8))(v260);
              v255[5] = v252;
            }
          }
        }
      }
    }
LABEL_379:
    v229 += 456;
    if (v229 != v230)
      continue;
    break;
  }
  if (!*(_BYTE *)(v88 + 240))
    goto LABEL_479;
LABEL_422:
  v261 = *(_QWORD *)(v88 + 168);
  v262 = *(_QWORD *)(v88 + 176);
  if (v261 != v262)
  {
    v263 = (uint64_t **)(v88 + 328);
    v264 = (uint64_t **)(v88 + 448);
    do
    {
      v265 = *(unsigned int **)(v261 + 160);
      if (*(unsigned int **)(v261 + 168) == v265)
      {
        v266 = 0;
        v267 = v308;
        if (!v308)
          goto LABEL_445;
      }
      else
      {
        v266 = *v265;
        v267 = v308;
        if (!v308)
          goto LABEL_445;
      }
      v268 = &v308;
      do
      {
        v269 = v267;
        v270 = v268;
        v271 = *((_DWORD *)v267 + 8);
        v272 = v267 + 1;
        if (v271 >= v266)
        {
          v272 = v269;
          v268 = (_QWORD **)v269;
        }
        v267 = (_QWORD *)*v272;
      }
      while (v267);
      if (v268 != &v308)
      {
        v273 = v271 >= v266 ? v269 : v270;
        if (*((_DWORD *)v273 + 8) <= v266)
        {
          v274 = v271 >= v266 ? v269 : v270;
          v275 = (uint64_t *)v274[5];
          if (v275)
          {
            v276 = *v263;
            v277 = (uint64_t **)(v88 + 328);
            v278 = (uint64_t **)(v88 + 328);
            if (*v263)
            {
              while (1)
              {
                while (1)
                {
                  v278 = (uint64_t **)v276;
                  v290 = v276[4];
                  if (v261 >= v290)
                    break;
                  v276 = *v278;
                  v277 = v278;
                  if (!*v278)
                    goto LABEL_453;
                }
                if (v290 >= v261)
                  goto LABEL_456;
                v276 = v278[1];
                if (!v276)
                {
LABEL_452:
                  v277 = v278 + 1;
                  goto LABEL_453;
                }
              }
            }
            goto LABEL_453;
          }
        }
      }
LABEL_445:
      v275 = v305;
      if (!v305)
        goto LABEL_459;
      v279 = *v263;
      v277 = (uint64_t **)(v88 + 328);
      v278 = (uint64_t **)(v88 + 328);
      if (*v263)
      {
        while (1)
        {
          while (1)
          {
            v278 = (uint64_t **)v279;
            v280 = v279[4];
            if (v261 >= v280)
              break;
            v279 = *v278;
            v277 = v278;
            if (!*v278)
              goto LABEL_453;
          }
          if (v280 >= v261)
            goto LABEL_456;
          v279 = v278[1];
          if (!v279)
            goto LABEL_452;
        }
      }
LABEL_453:
      v281 = (uint64_t *)v278;
      v278 = (uint64_t **)operator new(0x30uLL);
      v278[4] = (uint64_t *)v261;
      v278[5] = 0;
      *v278 = 0;
      v278[1] = 0;
      v278[2] = v281;
      *v277 = (uint64_t *)v278;
      v282 = **(_QWORD **)(v88 + 320);
      v283 = (uint64_t *)v278;
      if (v282)
      {
        *(_QWORD *)(v88 + 320) = v282;
        v283 = *v277;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v88 + 328), v283);
      ++*(_QWORD *)(v88 + 336);
LABEL_456:
      (*(void (**)(uint64_t *))*v275)(v275);
      v284 = v278[5];
      if (v284)
        (*(void (**)(uint64_t *))(*v284 + 8))(v284);
      v278[5] = v275;
LABEL_459:
      v285 = *(unsigned int **)(v261 + 160);
      if (*(unsigned int **)(v261 + 168) == v285)
      {
        v286 = 0;
        v287 = *v264;
        v288 = (uint64_t **)(v88 + 448);
        v289 = (uint64_t **)(v88 + 448);
        if (*v264)
        {
          while (1)
          {
LABEL_470:
            while (1)
            {
              v289 = (uint64_t **)v287;
              v291 = *((_DWORD *)v287 + 8);
              if (v286 >= v291)
                break;
              v287 = *v289;
              v288 = v289;
              if (!*v289)
                goto LABEL_474;
            }
            if (v291 >= v286)
              goto LABEL_425;
            v287 = v289[1];
            if (!v287)
            {
              v288 = v289 + 1;
              break;
            }
          }
        }
      }
      else
      {
        v286 = *v285;
        v287 = *v264;
        v288 = (uint64_t **)(v88 + 448);
        v289 = (uint64_t **)(v88 + 448);
        if (*v264)
          goto LABEL_470;
      }
LABEL_474:
      v292 = (uint64_t *)v289;
      v289 = (uint64_t **)operator new(0x30uLL);
      *((_DWORD *)v289 + 8) = v286;
      v289[5] = 0;
      *v289 = 0;
      v289[1] = 0;
      v289[2] = v292;
      *v288 = (uint64_t *)v289;
      v293 = **(_QWORD **)(v88 + 440);
      v294 = (uint64_t *)v289;
      if (v293)
      {
        *(_QWORD *)(v88 + 440) = v293;
        v294 = *v288;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v88 + 448), v294);
      ++*(_QWORD *)(v88 + 456);
LABEL_425:
      v289[5] = (uint64_t *)v261;
      v261 += 728;
    }
    while (v261 != v262);
  }
LABEL_476:
  std::__tree<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::__map_value_compare<webrtc::AudioSendStream *,std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::less<webrtc::AudioSendStream *>,true>,std::allocator<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>>>::destroy(v308);
  std::__tree<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::__map_value_compare<webrtc::AudioSendStream *,std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::less<webrtc::AudioSendStream *>,true>,std::allocator<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>>>::destroy(v311);
  std::__tree<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::__map_value_compare<webrtc::AudioSendStream *,std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::less<webrtc::AudioSendStream *>,true>,std::allocator<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>>>::destroy(v314);
  std::__tree<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::__map_value_compare<webrtc::AudioSendStream *,std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::less<webrtc::AudioSendStream *>,true>,std::allocator<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>>>::destroy(v317);
  v297[217] = v296;
}

uint64_t dcsctp::TraditionalReassemblyStreams::StreamBase::AssembleMessage(_QWORD *a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v4;
  unint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  void *v24;
  void *v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  _BYTE *v34;
  char *v35;
  char *v36;
  unint64_t v37;
  char *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _OWORD *v42;
  char *v43;
  uint64_t v44;
  __int128 v45;
  uint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  unint64_t v58;
  void *v59[2];
  uint64_t v60;
  void *__p[2];
  __int128 v62;
  char *v63;
  uint64_t v64;
  _QWORD v65[2];

  v4 = a1;
  v65[1] = *MEMORY[0x24BDAC8D0];
  if ((_QWORD *)a2 == a3)
  {
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v18 = 0;
    v22 = 0uLL;
    goto LABEL_63;
  }
  v6 = 0;
  v7 = (_QWORD *)a2;
  do
  {
    v8 = v6;
    v9 = (_QWORD *)v7[1];
    if (v9)
    {
      do
      {
        v10 = v9;
        v9 = (_QWORD *)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        v10 = (_QWORD *)v7[2];
        v11 = *v10 == (_QWORD)v7;
        v7 = v10;
      }
      while (!v11);
    }
    v6 = v8 + 1;
    v7 = v10;
  }
  while (v10 != a3);
  if (v8)
  {
    LODWORD(v12) = 0;
    __p[0] = 0;
    __p[1] = 0;
    v13 = (_QWORD *)a2;
    *(_QWORD *)&v62 = 0;
    do
    {
      v14 = (_QWORD *)v13[1];
      v15 = v13;
      if (v14)
      {
        do
        {
          v16 = v14;
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          v16 = (_QWORD *)v15[2];
          v11 = *v16 == (_QWORD)v15;
          v15 = v16;
        }
        while (!v11);
      }
      v12 = v13[8] - v13[7] + v12;
      v13 = v16;
    }
    while (v16 != a3);
    if (v8 < 0x1FFFFFFFFFFFFFFFLL)
    {
      v17 = 8 * v6;
      v18 = (char *)operator new(8 * v6);
      v56 = v4;
      if (!(v12 << 32))
      {
        v55 = 0;
        goto LABEL_29;
      }
      if (((v12 << 32) & 0x8000000000000000) == 0)
      {
        v55 = (int)v12;
        __p[0] = operator new((int)v12);
        __p[1] = __p[0];
        *(_QWORD *)&v62 = (char *)__p[0] + (int)v12;
LABEL_29:
        v29 = &v18[v17];
        v30 = (_QWORD *)a2;
        v21 = v18;
        while (v21 < v29)
        {
          *(_QWORD *)v21 = v30[4];
          v21 += 8;
LABEL_56:
          std::vector<unsigned char>::__insert_with_size[abi:sn180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((uint64_t)__p, (char *)__p[1], (char *)v30[7], (char *)v30[8], v30[8] - v30[7]);
          v47 = (_QWORD *)v30[1];
          if (v47)
          {
            do
            {
              v48 = v47;
              v47 = (_QWORD *)*v47;
            }
            while (v47);
          }
          else
          {
            do
            {
              v48 = (_QWORD *)v30[2];
              v11 = *v48 == (_QWORD)v30;
              v30 = v48;
            }
            while (!v11);
          }
          v30 = v48;
          if (v48 == a3)
          {
            v22 = *(_OWORD *)__p;
            v20 = v62;
            v19 = v55;
            v4 = v56;
LABEL_63:
            v49 = *(unsigned __int16 *)(a2 + 40);
            __p[1] = 0;
            *(_QWORD *)&v62 = 0;
            v60 = v20;
            __p[0] = 0;
            v50 = v49 | ((unint64_t)*(unsigned int *)(a2 + 52) << 32);
            v51 = *v4;
            if (v21 == v18)
              v52 = 0;
            else
              v52 = v18;
            v58 = v50;
            *(_OWORD *)v59 = v22;
            v63 = v52;
            v64 = (v21 - v18) >> 3;
            v53 = *(_QWORD *)(v51 + 48);
            if (v53)
            {
              (*(void (**)(uint64_t, char **, unint64_t *))(*(_QWORD *)v53 + 48))(v53, &v63, &v58);
              if (v59[0])
              {
                v59[1] = v59[0];
                operator delete(v59[0]);
              }
              if (__p[0])
              {
                __p[1] = __p[0];
                operator delete(__p[0]);
              }
              if (v18)
                operator delete(v18);
              return v19;
            }
LABEL_77:
            std::__throw_bad_function_call[abi:sn180100]();
          }
        }
        v31 = (v21 - v18) >> 3;
        v32 = v31 + 1;
        if ((unint64_t)(v31 + 1) >> 61)
          goto LABEL_74;
        if ((v29 - v18) >> 2 > v32)
          v32 = (v29 - v18) >> 2;
        if ((unint64_t)(v29 - v18) >= 0x7FFFFFFFFFFFFFF8)
          v32 = 0x1FFFFFFFFFFFFFFFLL;
        if (!v32)
        {
          __break(1u);
LABEL_76:
          std::__throw_bad_array_new_length[abi:sn180100]();
        }
        if (v32 >> 61)
          goto LABEL_76;
        v33 = 8 * v32;
        v34 = operator new(8 * v32);
        v35 = &v34[8 * v31];
        *(_QWORD *)v35 = v30[4];
        v36 = v35 + 8;
        if (v21 != v18)
        {
          v37 = v21 - v18 - 8;
          if (v37 >= 0x168)
          {
            v39 = (v21 - 8 - v18) & 0xFFFFFFFFFFFFFFF8;
            if (&v34[v21 - v18 - 8 - v39] > &v34[v21 - v18 - 8])
            {
              v38 = v21;
            }
            else if (&v21[-v39 - 8] > v21 - 8)
            {
              v38 = v21;
            }
            else if ((unint64_t)(v18 - v34) >= 0x20)
            {
              v40 = (v37 >> 3) + 1;
              v41 = 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
              v38 = &v21[-v41];
              v35 -= v41;
              v42 = &v34[8 * v31 - 16];
              v43 = v21 - 16;
              v44 = v40 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v45 = *(_OWORD *)v43;
                *(v42 - 1) = *((_OWORD *)v43 - 1);
                *v42 = v45;
                v42 -= 2;
                v43 -= 32;
                v44 -= 4;
              }
              while (v44);
              if (v40 == (v40 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_53;
            }
            else
            {
              v38 = v21;
            }
          }
          else
          {
            v38 = v21;
          }
          do
          {
            v46 = *((_QWORD *)v38 - 1);
            v38 -= 8;
            *((_QWORD *)v35 - 1) = v46;
            v35 -= 8;
          }
          while (v38 != v18);
        }
LABEL_53:
        v29 = &v34[v33];
        if (v18)
          operator delete(v18);
        v18 = v35;
        v21 = v36;
        goto LABEL_56;
      }
    }
LABEL_74:
    abort();
  }
  v23 = *(_QWORD *)(a2 + 32);
  v24 = *(void **)(a2 + 56);
  v25 = (void *)(*(unsigned __int16 *)(a2 + 40) | ((unint64_t)*(unsigned int *)(a2 + 52) << 32));
  v26 = *(_OWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  v65[0] = v23;
  v27 = *a1;
  __p[0] = v25;
  __p[1] = v24;
  v57 = v26;
  v62 = v26;
  v63 = (char *)v65;
  v64 = 1;
  v28 = *(_QWORD *)(v27 + 48);
  if (!v28)
    goto LABEL_77;
  (*(void (**)(uint64_t, char **, void **))(*(_QWORD *)v28 + 48))(v28, &v63, __p);
  if (__p[1])
  {
    *(void **)&v62 = __p[1];
    operator delete(__p[1]);
  }
  return v57 - (_QWORD)v24;
}

uint64_t dcsctp::TraditionalReassemblyStreams::Add(uint64_t a1, uint64_t a2, unsigned __int16 *a3)
{
  char v6;
  unsigned int v7;
  unsigned __int16 *v8;
  uint64_t **v9;
  _QWORD *v10;
  unsigned int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  int64_t v22;
  unsigned __int16 *v23;
  uint64_t **v24;
  char *v25;
  unsigned int v26;
  char *v27;
  uint64_t v28;
  uint64_t *v29;
  char v30;
  uint64_t *v31;
  uint64_t **v32;
  uint64_t **v33;
  uint64_t v34;
  unsigned __int16 *v35;
  _QWORD *v36;
  unsigned __int16 v37;
  int v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  BOOL v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  _QWORD *v48;
  int v49;
  uint64_t *v50;
  void *v51;
  _BYTE *v52;
  uint64_t *v53;
  unsigned int v54;
  BOOL v55;
  uint64_t v56;
  int v57;
  _BOOL4 v58;
  int v59;
  uint64_t *v60;
  _QWORD *v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  uint64_t *v66;
  uint64_t **v67;
  uint64_t **v68;
  uint64_t *v69;
  _BYTE *v70;
  char v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t *v75;
  uint64_t **v76;
  uint64_t **v77;
  uint64_t v78;
  _QWORD *v79;
  uint64_t *v80;
  uint64_t *v81;
  uint64_t *v82;
  uint64_t **v83;
  _QWORD *v84;
  uint64_t *v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t *v88;
  uint64_t *v89;
  uint64_t **v90;
  uint64_t **v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t *v95;
  _QWORD *v96;
  _QWORD *v97;
  _QWORD *v98;
  _QWORD *v99;
  uint64_t *v100;
  void *v101;
  int v102;
  uint64_t *v103;
  _QWORD *v104;
  uint64_t v105;
  _QWORD *v106;
  _QWORD *v107;
  _QWORD *v108;
  _QWORD *v109;
  _QWORD *v110;
  _QWORD *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  _QWORD *v115;
  _QWORD *v116;
  _QWORD *v117;
  uint64_t v119;
  int64_t v120;
  char v121;
  char v122;
  char v123;
  uint64_t v124;
  int v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  char v129;
  int v130;
  void *v131;
  void *v132;
  unint64_t v133;
  void *__p;
  void *v135;
  uint64_t v136;
  _QWORD *v137;
  uint64_t v138;
  _QWORD v139[2];

  v139[1] = *MEMORY[0x24BDAC8D0];
  v6 = *((_BYTE *)a3 + 42);
  v7 = *a3;
  if (!v6)
  {
    v24 = (uint64_t **)(a1 + 88);
    v23 = *(unsigned __int16 **)(a1 + 88);
    if (v23)
    {
      while (1)
      {
        while (1)
        {
          v25 = (char *)v23;
          v26 = v23[16];
          if (v7 >= v26)
            break;
          v23 = *(unsigned __int16 **)v25;
          v24 = (uint64_t **)v25;
          if (!*(_QWORD *)v25)
            goto LABEL_26;
        }
        if (v26 >= v7)
          break;
        v23 = (unsigned __int16 *)*((_QWORD *)v25 + 1);
        if (!v23)
        {
          v24 = (uint64_t **)(v25 + 8);
          goto LABEL_26;
        }
      }
      v30 = 0;
    }
    else
    {
      v25 = (char *)(a1 + 88);
LABEL_26:
      v27 = v25;
      v25 = (char *)operator new(0x60uLL);
      *((_WORD *)v25 + 16) = v7;
      *((_QWORD *)v25 + 8) = 0;
      *((_QWORD *)v25 + 9) = 0;
      *((_QWORD *)v25 + 7) = 0;
      *((_QWORD *)v25 + 5) = a1;
      *((_QWORD *)v25 + 6) = v25 + 56;
      *((_WORD *)v25 + 40) = 0;
      v25[82] = 1;
      *((_QWORD *)v25 + 11) = 0;
      *(_QWORD *)v25 = 0;
      *((_QWORD *)v25 + 1) = 0;
      *((_QWORD *)v25 + 2) = v27;
      *v24 = (uint64_t *)v25;
      v28 = **(_QWORD **)(a1 + 80);
      v29 = (uint64_t *)v25;
      if (v28)
      {
        *(_QWORD *)(a1 + 80) = v28;
        v29 = *v24;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 88), v29);
      ++*(_QWORD *)(a1 + 96);
      v7 = *a3;
      v30 = *((_BYTE *)a3 + 42);
    }
    v50 = (uint64_t *)a3[1];
    v124 = *(_QWORD *)(a3 + 2);
    v126 = *((unsigned int *)a3 + 3);
    v51 = (void *)*((_QWORD *)a3 + 2);
    v52 = (_BYTE *)*((_QWORD *)a3 + 3);
    v128 = *((_QWORD *)a3 + 4);
    *((_QWORD *)a3 + 3) = 0;
    *((_QWORD *)a3 + 4) = 0;
    *((_QWORD *)a3 + 2) = 0;
    v53 = v50;
    if (v25[82])
    {
      v54 = *((unsigned __int16 *)v25 + 40);
      v55 = v50 >= v54;
      LODWORD(v56) = (_DWORD)v50 - v54;
      v57 = (_DWORD)v56 != 0 && v55;
      v58 = (v56 & 0x8000u) == 0;
      if ((_DWORD)v56 == 0x8000)
        v58 = v57;
      if (v58)
        v56 = (unsigned __int16)v56;
      else
        v56 |= 0xFFFFFFFFFFFF0000;
      v53 = (uint64_t *)(v56 + *((_QWORD *)v25 + 9));
    }
    v132 = v51;
    v22 = v52 - (_BYTE *)v51;
    v59 = *((unsigned __int8 *)a3 + 40);
    v61 = v25 + 88;
    v60 = (uint64_t *)*((_QWORD *)v25 + 11);
    v130 = *((unsigned __int8 *)a3 + 41);
    *((_QWORD *)v25 + 9) = v53;
    *((_WORD *)v25 + 40) = (_WORD)v50;
    v25[82] = 1;
    if (v53 == v60)
    {
      v62 = (uint64_t *)(v25 + 40);
      if (v59 && v130)
      {
        v139[0] = a2;
        v63 = *v62;
        v133 = v7 | (unint64_t)(v126 << 32);
        __p = v51;
        v135 = v52;
        v136 = v128;
        v137 = v139;
        v138 = 1;
        v64 = *(_QWORD *)(v63 + 48);
        if (!v64)
          goto LABEL_165;
        (*(void (**)(uint64_t, _QWORD **, unint64_t *))(*(_QWORD *)v64 + 48))(v64, &v137, &v133);
        if (__p)
        {
          v135 = __p;
          operator delete(__p);
        }
        v65 = (_DWORD)v132 - (_DWORD)v52;
LABEL_139:
        v102 = 0;
        ++*v61;
        do
        {
          if (!*((_QWORD *)v25 + 8))
            break;
          v104 = (_QWORD *)*((_QWORD *)v25 + 6);
          if (v104[4] != *((_QWORD *)v25 + 11))
            break;
          v105 = v104[5];
          if (!*(_BYTE *)(v105 + 80))
            break;
          v106 = (_QWORD *)v104[6];
          v107 = v106;
          v108 = v104 + 6;
          if (v106)
          {
            do
            {
              v109 = v107;
              v107 = (_QWORD *)v107[1];
            }
            while (v107);
          }
          else
          {
            do
            {
              v109 = (_QWORD *)v108[2];
              v44 = *v109 == (_QWORD)v108;
              v108 = v109;
            }
            while (v44);
          }
          if (!*((_BYTE *)v109 + 81))
            break;
          v110 = v104 + 6;
          if (v106)
          {
            do
            {
              v111 = v106;
              v106 = (_QWORD *)v106[1];
            }
            while (v106);
          }
          else
          {
            do
            {
              v111 = (_QWORD *)v110[2];
              v44 = *v111 == (_QWORD)v110;
              v110 = v111;
            }
            while (v44);
          }
          v112 = v111[4] - *(_QWORD *)(v105 + 32);
          if (v112 < 0)
            v112 = *(_QWORD *)(v105 + 32) - v111[4];
          if (v104[7] - 1 != v112)
            break;
          v113 = dcsctp::TraditionalReassemblyStreams::StreamBase::AssembleMessage(v62, v105, v104 + 6);
          v114 = *((_QWORD *)v25 + 6);
          v115 = *(_QWORD **)(v114 + 8);
          v116 = (_QWORD *)v114;
          if (v115)
          {
            do
            {
              v117 = v115;
              v115 = (_QWORD *)*v115;
            }
            while (v115);
          }
          else
          {
            do
            {
              v117 = (_QWORD *)v116[2];
              v44 = *v117 == (_QWORD)v116;
              v116 = v117;
            }
            while (!v44);
          }
          *((_QWORD *)v25 + 6) = v117;
          v103 = (uint64_t *)*((_QWORD *)v25 + 7);
          --*((_QWORD *)v25 + 8);
          std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v103, (uint64_t *)v114);
          std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>::destroy(*(_QWORD **)(v114 + 48));
          operator delete((void *)v114);
          ++*((_QWORD *)v25 + 11);
          v102 += v113;
        }
        while (v113);
        return (v65 + v22 - v102);
      }
      v123 = v59;
      v121 = v30;
      v83 = (uint64_t **)(v25 + 56);
      v82 = (uint64_t *)*((_QWORD *)v25 + 7);
      if (v82)
      {
        while (1)
        {
          while (1)
          {
            v84 = v82;
            v85 = (uint64_t *)v82[4];
            if ((uint64_t)v85 <= (uint64_t)v53)
              break;
            v82 = (uint64_t *)*v84;
            v83 = (uint64_t **)v84;
            if (!*v84)
              goto LABEL_102;
          }
          if ((uint64_t)v85 >= (uint64_t)v53)
            break;
          v82 = (uint64_t *)v84[1];
          if (!v82)
          {
            v83 = (uint64_t **)(v84 + 1);
            goto LABEL_102;
          }
        }
      }
      else
      {
        v84 = v25 + 56;
LABEL_102:
        v86 = v84;
        v84 = operator new(0x40uLL);
        v84[7] = 0;
        v84[6] = 0;
        v84[4] = v53;
        v84[5] = v84 + 6;
        *v84 = 0;
        v84[1] = 0;
        v84[2] = v86;
        *v83 = v84;
        v87 = **((_QWORD **)v25 + 6);
        v88 = v84;
        if (v87)
        {
          *((_QWORD *)v25 + 6) = v87;
          v88 = *v83;
        }
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v25 + 7), v88);
        ++*((_QWORD *)v25 + 8);
        v62 = (uint64_t *)(v25 + 40);
      }
      v90 = (uint64_t **)(v84 + 6);
      v89 = (uint64_t *)v84[6];
      if (!v89)
      {
        v91 = (uint64_t **)(v84 + 6);
LABEL_112:
        v93 = operator new(0x58uLL);
        v93[4] = a2;
        *((_WORD *)v93 + 20) = v7;
        *((_WORD *)v93 + 21) = (_WORD)v50;
        *(_QWORD *)((char *)v93 + 44) = v124;
        *((_DWORD *)v93 + 13) = v126;
        v93[7] = v132;
        v93[8] = v52;
        v93[9] = v128;
        *((_BYTE *)v93 + 80) = v123;
        *((_BYTE *)v93 + 81) = v130;
        *((_BYTE *)v93 + 82) = v121;
        *v93 = 0;
        v93[1] = 0;
        v93[2] = v91;
        *v90 = v93;
        v94 = *(_QWORD *)v84[5];
        if (v94)
        {
          v84[5] = v94;
          v95 = *v90;
        }
        else
        {
          v95 = v93;
        }
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>((uint64_t *)v84[6], v95);
        v65 = 0;
        v61 = v84 + 7;
        goto LABEL_139;
      }
      while (1)
      {
        while (1)
        {
          v91 = (uint64_t **)v89;
          v92 = v89[4];
          if (v92 <= a2)
            break;
          v89 = *v91;
          v90 = v91;
          if (!*v91)
            goto LABEL_112;
        }
        if (v92 >= a2)
          break;
        v89 = v91[1];
        if (!v89)
        {
          v90 = v91 + 1;
          goto LABEL_112;
        }
      }
    }
    else
    {
      v122 = v59;
      v67 = (uint64_t **)(v25 + 56);
      v66 = (uint64_t *)*((_QWORD *)v25 + 7);
      if (v66)
      {
        while (1)
        {
          while (1)
          {
            v68 = (uint64_t **)v66;
            v69 = (uint64_t *)v66[4];
            if ((uint64_t)v53 >= (uint64_t)v69)
              break;
            v66 = *v68;
            v67 = v68;
            if (!*v68)
              goto LABEL_83;
          }
          if ((uint64_t)v69 >= (uint64_t)v53)
            break;
          v66 = v68[1];
          if (!v66)
          {
            v67 = v68 + 1;
            goto LABEL_83;
          }
        }
      }
      else
      {
        v68 = (uint64_t **)(v25 + 56);
LABEL_83:
        v120 = v52 - (_BYTE *)v51;
        v70 = v52;
        v71 = v30;
        v72 = (uint64_t *)v68;
        v68 = (uint64_t **)operator new(0x40uLL);
        v68[7] = 0;
        v68[6] = 0;
        v68[4] = v53;
        v68[5] = (uint64_t *)(v68 + 6);
        *v68 = 0;
        v68[1] = 0;
        v68[2] = v72;
        *v67 = (uint64_t *)v68;
        v73 = **((_QWORD **)v25 + 6);
        v74 = (uint64_t *)v68;
        if (v73)
        {
          *((_QWORD *)v25 + 6) = v73;
          v74 = *v67;
        }
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v25 + 7), v74);
        ++*((_QWORD *)v25 + 8);
        v30 = v71;
        v52 = v70;
        v22 = v120;
      }
      v76 = v68 + 6;
      v75 = v68[6];
      if (!v75)
      {
        v77 = v68 + 6;
LABEL_93:
        v79 = operator new(0x58uLL);
        v79[4] = a2;
        *((_WORD *)v79 + 20) = v7;
        *((_WORD *)v79 + 21) = (_WORD)v50;
        *(_QWORD *)((char *)v79 + 44) = v124;
        *((_DWORD *)v79 + 13) = v126;
        v79[7] = v132;
        v79[8] = v52;
        v79[9] = v128;
        *((_BYTE *)v79 + 80) = v122;
        *((_BYTE *)v79 + 81) = v130;
        *((_BYTE *)v79 + 82) = v30;
        *v79 = 0;
        v79[1] = 0;
        v79[2] = v77;
        *v76 = v79;
        v80 = (uint64_t *)*v68[5];
        if (v80)
        {
          v68[5] = v80;
          v81 = *v76;
        }
        else
        {
          v81 = v79;
        }
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(v68[6], v81);
        v68[7] = (uint64_t *)((char *)v68[7] + 1);
        return v22;
      }
      while (1)
      {
        while (1)
        {
          v77 = (uint64_t **)v75;
          v78 = v75[4];
          if (v78 <= a2)
            break;
          v75 = *v77;
          v76 = v77;
          if (!*v77)
            goto LABEL_93;
        }
        if (v78 >= a2)
          break;
        v75 = v77[1];
        if (!v75)
        {
          v76 = v77 + 1;
          goto LABEL_93;
        }
      }
    }
    v16 = v132;
    if (!v132)
      return 0;
    goto LABEL_17;
  }
  v9 = (uint64_t **)(a1 + 64);
  v8 = *(unsigned __int16 **)(a1 + 64);
  if (v8)
  {
    while (1)
    {
      while (1)
      {
        v10 = v8;
        v11 = v8[16];
        if (v7 >= v11)
          break;
        v8 = (unsigned __int16 *)*v10;
        v9 = (uint64_t **)v10;
        if (!*v10)
          goto LABEL_9;
      }
      if (v11 >= v7)
        break;
      v8 = (unsigned __int16 *)v10[1];
      if (!v8)
      {
        v9 = (uint64_t **)(v10 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    v10 = (_QWORD *)(a1 + 64);
LABEL_9:
    v12 = v10;
    v10 = operator new(0x48uLL);
    *((_WORD *)v10 + 16) = v7;
    v10[8] = 0;
    v10[7] = 0;
    v10[5] = a1;
    v10[6] = v10 + 7;
    *v10 = 0;
    v10[1] = 0;
    v10[2] = v12;
    *v9 = v10;
    v13 = **(_QWORD **)(a1 + 56);
    v14 = v10;
    if (v13)
    {
      *(_QWORD *)(a1 + 56) = v13;
      v14 = *v9;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 64), v14);
    ++*(_QWORD *)(a1 + 72);
    v7 = *a3;
    v6 = *((_BYTE *)a3 + 42);
  }
  v15 = *((unsigned int *)a3 + 3);
  v16 = (void *)*((_QWORD *)a3 + 2);
  v17 = (void *)*((_QWORD *)a3 + 3);
  v18 = *((_QWORD *)a3 + 4);
  *((_QWORD *)a3 + 3) = 0;
  *((_QWORD *)a3 + 4) = 0;
  *((_QWORD *)a3 + 2) = 0;
  v19 = *((_BYTE *)a3 + 40);
  if (!v19 || !*((_BYTE *)a3 + 41))
  {
    v31 = (uint64_t *)v10[7];
    if (!v31)
    {
      v32 = (uint64_t **)(v10 + 7);
      v33 = (uint64_t **)(v10 + 7);
LABEL_36:
      v131 = v16;
      v35 = a3 + 1;
      v125 = v15;
      v127 = v18;
      v129 = *((_BYTE *)a3 + 41);
      v36 = operator new(0x58uLL);
      v36[4] = a2;
      *((_WORD *)v36 + 20) = v7;
      *(_QWORD *)((char *)v36 + 42) = *(_QWORD *)v35;
      v37 = v35[4];
      v38 = (int)v131;
      *((_WORD *)v36 + 25) = v37;
      *((_DWORD *)v36 + 13) = v125;
      v36[7] = v131;
      v36[8] = v17;
      v36[9] = v127;
      *((_BYTE *)v36 + 80) = v19;
      *((_BYTE *)v36 + 81) = v129;
      *((_BYTE *)v36 + 82) = v6;
      *v36 = 0;
      v36[1] = 0;
      v36[2] = v33;
      *v32 = v36;
      v39 = *(_QWORD *)v10[6];
      v40 = v36;
      if (v39)
      {
        v10[6] = v39;
        v40 = *v32;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>((uint64_t *)v10[7], v40);
      ++v10[8];
      v41 = v36[4];
      v42 = v41;
      v43 = (uint64_t)v36;
      while (!*(_BYTE *)(v43 + 80))
      {
        if (v43 != v10[6])
        {
          v45 = *(_QWORD *)v43;
          if (*(_QWORD *)v43)
          {
            do
            {
              v46 = (_QWORD *)v45;
              v45 = *(_QWORD *)(v45 + 8);
            }
            while (v45);
          }
          else
          {
            do
            {
              v46 = *(_QWORD **)(v43 + 16);
              v44 = *v46 == v43;
              v43 = (uint64_t)v46;
            }
            while (v44);
          }
          v43 = (uint64_t)v46;
          v44 = v46[4] + 1 == v42;
          v42 = v46[4];
          if (v44)
            continue;
        }
LABEL_56:
        v49 = 0;
        return ((_DWORD)v17 - v38 - v49);
      }
      while (1)
      {
        v47 = (_QWORD *)v36[1];
        if (*((_BYTE *)v36 + 81))
          break;
        if (v47)
        {
          do
          {
            v48 = v47;
            v47 = (_QWORD *)*v47;
          }
          while (v47);
        }
        else
        {
          do
          {
            v48 = (_QWORD *)v36[2];
            v44 = *v48 == (_QWORD)v36;
            v36 = v48;
          }
          while (!v44);
        }
        if (v48 != v10 + 7)
        {
          ++v41;
          v36 = v48;
          if (v48[4] == v41)
            continue;
        }
        goto LABEL_56;
      }
      if (v47)
      {
        do
        {
          v96 = v47;
          v47 = (_QWORD *)*v47;
        }
        while (v47);
      }
      else
      {
        do
        {
          v96 = (_QWORD *)v36[2];
          v44 = *v96 == (_QWORD)v36;
          v36 = v96;
        }
        while (!v44);
      }
      v49 = dcsctp::TraditionalReassemblyStreams::StreamBase::AssembleMessage(v10 + 5, v43, v96);
      if ((_QWORD *)v43 != v96)
      {
        do
        {
          v97 = *(_QWORD **)(v43 + 8);
          v98 = (_QWORD *)v43;
          if (v97)
          {
            do
            {
              v99 = v97;
              v97 = (_QWORD *)*v97;
            }
            while (v97);
          }
          else
          {
            do
            {
              v99 = (_QWORD *)v98[2];
              v44 = *v99 == (_QWORD)v98;
              v98 = v99;
            }
            while (!v44);
          }
          if (v10[6] == v43)
            v10[6] = v99;
          v100 = (uint64_t *)v10[7];
          --v10[8];
          std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v100, (uint64_t *)v43);
          v101 = *(void **)(v43 + 56);
          if (v101)
          {
            *(_QWORD *)(v43 + 64) = v101;
            operator delete(v101);
          }
          operator delete((void *)v43);
          v43 = (uint64_t)v99;
        }
        while (v99 != v96);
        v38 = (int)v131;
      }
      return ((_DWORD)v17 - v38 - v49);
    }
    while (1)
    {
      while (1)
      {
        v33 = (uint64_t **)v31;
        v34 = v31[4];
        if (v34 <= a2)
          break;
        v31 = *v33;
        v32 = v33;
        if (!*v33)
          goto LABEL_36;
      }
      if (v34 >= a2)
        break;
      v31 = v33[1];
      if (!v31)
      {
        v32 = v33 + 1;
        goto LABEL_36;
      }
    }
    if (!v16)
      return 0;
    goto LABEL_17;
  }
  v139[0] = a2;
  v20 = v10[5];
  v133 = v7 | (unint64_t)(v15 << 32);
  __p = v16;
  v135 = v17;
  v136 = v18;
  v137 = v139;
  v138 = 1;
  v21 = *(_QWORD *)(v20 + 48);
  if (v21)
  {
    (*(void (**)(uint64_t, _QWORD **, unint64_t *))(*(_QWORD *)v21 + 48))(v21, &v137, &v133);
    v16 = __p;
    if (!__p)
      return 0;
    v135 = __p;
LABEL_17:
    operator delete(v16);
    return 0;
  }
LABEL_165:
  v119 = std::__throw_bad_function_call[abi:sn180100]();
  return dcsctp::TraditionalReassemblyStreams::HandleForwardTsn(v119);
}

uint64_t dcsctp::TraditionalReassemblyStreams::HandleForwardTsn(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v9;
  _QWORD *v10;
  uint64_t *v11;
  uint64_t v12;
  BOOL v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  void *v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unsigned __int16 **v30;
  unsigned __int16 *v31;
  unsigned int v32;
  uint64_t **v33;
  char *v34;
  unsigned int v35;
  char *v36;
  uint64_t v37;
  uint64_t *v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  BOOL v42;
  uint64_t v43;
  int v44;
  _BOOL4 v45;
  _QWORD *v46;
  _QWORD *v47;
  uint64_t v48;
  BOOL v49;
  _QWORD *v50;
  _QWORD *v51;
  int v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  _QWORD *v56;
  _QWORD *v57;
  _QWORD *v58;
  int v59;
  _QWORD *v60;
  _QWORD *v61;
  uint64_t *v62;
  _QWORD *v63;
  _QWORD *v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  _QWORD *v70;
  uint64_t v71;
  _QWORD *v72;
  _QWORD *v73;
  _QWORD *v74;
  _QWORD *v75;
  _QWORD *v76;
  _QWORD *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD *v81;
  _QWORD *v82;
  _QWORD *v83;
  unsigned __int16 *v86;

  v6 = *(_QWORD **)(a1 + 56);
  v7 = (_QWORD *)(a1 + 64);
  if (v6 != (_QWORD *)(a1 + 64))
  {
    v9 = 0;
    while (1)
    {
      v11 = v6 + 7;
      v10 = (_QWORD *)v6[7];
      if (v10)
      {
        do
        {
          v12 = v10[4];
          v13 = v12 <= a2;
          if (v12 <= a2)
            v14 = v10 + 1;
          else
            v14 = v10;
          if (!v13)
            v11 = v10;
          v10 = (_QWORD *)*v14;
        }
        while (*v14);
      }
      v15 = (uint64_t *)v6[6];
      if (v15 == v11)
      {
        v27 = 0;
        v28 = (_QWORD *)v6[1];
        if (v28)
          goto LABEL_33;
      }
      else
      {
        LODWORD(v16) = 0;
        v17 = (uint64_t *)v6[6];
        do
        {
          v18 = (uint64_t *)v17[1];
          v19 = v17;
          if (v18)
          {
            do
            {
              v20 = v18;
              v18 = (uint64_t *)*v18;
            }
            while (v18);
          }
          else
          {
            do
            {
              v20 = (uint64_t *)v19[2];
              v21 = *v20 == (_QWORD)v19;
              v19 = v20;
            }
            while (!v21);
          }
          v16 = v17[8] - v17[7] + v16;
          v17 = v20;
        }
        while (v20 != v11);
        do
        {
          v22 = (uint64_t *)v15[1];
          v23 = v15;
          if (v22)
          {
            do
            {
              v24 = v22;
              v22 = (uint64_t *)*v22;
            }
            while (v22);
          }
          else
          {
            do
            {
              v24 = (uint64_t *)v23[2];
              v21 = *v24 == (_QWORD)v23;
              v23 = v24;
            }
            while (!v21);
          }
          if ((uint64_t *)v6[6] == v15)
            v6[6] = v24;
          v25 = (uint64_t *)v6[7];
          --v6[8];
          std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v25, v15);
          v26 = (void *)v15[7];
          if (v26)
          {
            v15[8] = (uint64_t)v26;
            operator delete(v26);
          }
          operator delete(v15);
          v15 = v24;
        }
        while (v24 != v11);
        v27 = (int)v16;
        v28 = (_QWORD *)v6[1];
        if (v28)
        {
          do
          {
LABEL_33:
            v29 = v28;
            v28 = (_QWORD *)*v28;
          }
          while (v28);
          goto LABEL_3;
        }
      }
      do
      {
        v29 = (_QWORD *)v6[2];
        v21 = *v29 == (_QWORD)v6;
        v6 = v29;
      }
      while (!v21);
LABEL_3:
      v9 += v27;
      v6 = v29;
      if (v29 == v7)
        goto LABEL_39;
    }
  }
  v9 = 0;
LABEL_39:
  if (a4)
  {
    v86 = &a3[6 * a4];
    v30 = (unsigned __int16 **)(a1 + 88);
    do
    {
      v31 = *v30;
      v32 = *a3;
      v33 = (uint64_t **)(a1 + 88);
      v34 = (char *)(a1 + 88);
      if (*v30)
      {
        while (1)
        {
          while (1)
          {
            v34 = (char *)v31;
            v35 = v31[16];
            if (v32 >= v35)
              break;
            v31 = *(unsigned __int16 **)v34;
            v33 = (uint64_t **)v34;
            if (!*(_QWORD *)v34)
              goto LABEL_49;
          }
          if (v35 >= v32)
            break;
          v31 = (unsigned __int16 *)*((_QWORD *)v34 + 1);
          if (!v31)
          {
            v33 = (uint64_t **)(v34 + 8);
            goto LABEL_49;
          }
        }
      }
      else
      {
LABEL_49:
        v36 = v34;
        v34 = (char *)operator new(0x60uLL);
        *((_WORD *)v34 + 16) = v32;
        *((_QWORD *)v34 + 8) = 0;
        *((_QWORD *)v34 + 9) = 0;
        *((_QWORD *)v34 + 7) = 0;
        *((_QWORD *)v34 + 5) = a1;
        *((_QWORD *)v34 + 6) = v34 + 56;
        *((_WORD *)v34 + 40) = 0;
        v34[82] = 1;
        *((_QWORD *)v34 + 11) = 0;
        *(_QWORD *)v34 = 0;
        *((_QWORD *)v34 + 1) = 0;
        *((_QWORD *)v34 + 2) = v36;
        *v33 = (uint64_t *)v34;
        v37 = **(_QWORD **)(a1 + 80);
        v38 = (uint64_t *)v34;
        if (v37)
        {
          *(_QWORD *)(a1 + 80) = v37;
          v38 = *v33;
        }
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 88), v38);
        ++*(_QWORD *)(a1 + 96);
      }
      v39 = a3[1];
      v40 = a3[1];
      if (v34[82])
      {
        v41 = *((unsigned __int16 *)v34 + 40);
        v42 = v39 >= v41;
        LODWORD(v43) = v39 - v41;
        v44 = (_DWORD)v43 != 0 && v42;
        v45 = (v43 & 0x8000u) == 0;
        if ((_DWORD)v43 == 0x8000)
          v45 = v44;
        if (v45)
          v43 = (unsigned __int16)v43;
        else
          v43 |= 0xFFFFFFFFFFFF0000;
        v40 = v43 + *((_QWORD *)v34 + 9);
      }
      v47 = v34 + 56;
      v46 = (_QWORD *)*((_QWORD *)v34 + 7);
      *((_QWORD *)v34 + 9) = v40;
      *((_WORD *)v34 + 40) = v39;
      v34[82] = 1;
      if (v46)
      {
        do
        {
          v48 = v46[4];
          v49 = v40 < v48;
          if (v40 >= v48)
            v50 = v46 + 1;
          else
            v50 = v46;
          if (v49)
            v47 = v46;
          v46 = (_QWORD *)*v50;
        }
        while (*v50);
      }
      v51 = (_QWORD *)*((_QWORD *)v34 + 6);
      if (v51 == v47)
      {
        v66 = 0;
        v67 = *((_QWORD *)v34 + 11);
        if (v40 >= v67)
          goto LABEL_98;
        goto LABEL_99;
      }
      v52 = 0;
      v53 = (_QWORD *)*((_QWORD *)v34 + 6);
      do
      {
        v54 = (_QWORD *)v53[5];
        if (v54 == v53 + 6)
        {
          v59 = 0;
          v60 = (_QWORD *)v53[1];
          if (!v60)
            goto LABEL_86;
        }
        else
        {
          LODWORD(v55) = 0;
          do
          {
            v56 = (_QWORD *)v54[1];
            v57 = v54;
            if (v56)
            {
              do
              {
                v58 = v56;
                v56 = (_QWORD *)*v56;
              }
              while (v56);
            }
            else
            {
              do
              {
                v58 = (_QWORD *)v57[2];
                v21 = *v58 == (_QWORD)v57;
                v57 = v58;
              }
              while (!v21);
            }
            v55 = v54[8] - v54[7] + v55;
            v54 = v58;
          }
          while (v58 != v53 + 6);
          v59 = v55;
          v60 = (_QWORD *)v53[1];
          if (!v60)
          {
            do
            {
LABEL_86:
              v61 = (_QWORD *)v53[2];
              v21 = *v61 == (_QWORD)v53;
              v53 = v61;
            }
            while (!v21);
            goto LABEL_71;
          }
        }
        do
        {
          v61 = v60;
          v60 = (_QWORD *)*v60;
        }
        while (v60);
LABEL_71:
        v52 += v59;
        v53 = v61;
      }
      while (v61 != v47);
      do
      {
        v63 = (_QWORD *)v51[1];
        v64 = v51;
        if (v63)
        {
          do
          {
            v65 = v63;
            v63 = (_QWORD *)*v63;
          }
          while (v63);
        }
        else
        {
          do
          {
            v65 = (_QWORD *)v64[2];
            v21 = *v65 == (_QWORD)v64;
            v64 = v65;
          }
          while (!v21);
        }
        if (*((_QWORD **)v34 + 6) == v51)
          *((_QWORD *)v34 + 6) = v65;
        v62 = (uint64_t *)*((_QWORD *)v34 + 7);
        --*((_QWORD *)v34 + 8);
        std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v62, v51);
        std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>::destroy((_QWORD *)v51[6]);
        operator delete(v51);
        v51 = v65;
      }
      while (v65 != v47);
      v66 = v52;
      v67 = *((_QWORD *)v34 + 11);
      if (v40 >= v67)
      {
LABEL_98:
        v67 = v40 + 1;
        *((_QWORD *)v34 + 11) = v40 + 1;
      }
LABEL_99:
      v68 = 0;
      do
      {
        if (!*((_QWORD *)v34 + 8))
          break;
        v70 = (_QWORD *)*((_QWORD *)v34 + 6);
        if (v70[4] != v67)
          break;
        v71 = v70[5];
        if (!*(_BYTE *)(v71 + 80))
          break;
        v72 = (_QWORD *)v70[6];
        v73 = v72;
        v74 = v70 + 6;
        if (v72)
        {
          do
          {
            v75 = v73;
            v73 = (_QWORD *)v73[1];
          }
          while (v73);
        }
        else
        {
          do
          {
            v75 = (_QWORD *)v74[2];
            v21 = *v75 == (_QWORD)v74;
            v74 = v75;
          }
          while (v21);
        }
        if (!*((_BYTE *)v75 + 81))
          break;
        v76 = v70 + 6;
        if (v72)
        {
          do
          {
            v77 = v72;
            v72 = (_QWORD *)v72[1];
          }
          while (v72);
        }
        else
        {
          do
          {
            v77 = (_QWORD *)v76[2];
            v21 = *v77 == (_QWORD)v76;
            v76 = v77;
          }
          while (v21);
        }
        v78 = v77[4] - *(_QWORD *)(v71 + 32);
        if (v78 < 0)
          v78 = *(_QWORD *)(v71 + 32) - v77[4];
        if (v70[7] - 1 != v78)
          break;
        v79 = dcsctp::TraditionalReassemblyStreams::StreamBase::AssembleMessage((_QWORD *)v34 + 5, v71, v70 + 6);
        v80 = *((_QWORD *)v34 + 6);
        v81 = *(_QWORD **)(v80 + 8);
        v82 = (_QWORD *)v80;
        if (v81)
        {
          do
          {
            v83 = v81;
            v81 = (_QWORD *)*v81;
          }
          while (v81);
        }
        else
        {
          do
          {
            v83 = (_QWORD *)v82[2];
            v21 = *v83 == (_QWORD)v82;
            v82 = v83;
          }
          while (!v21);
        }
        *((_QWORD *)v34 + 6) = v83;
        v69 = (uint64_t *)*((_QWORD *)v34 + 7);
        --*((_QWORD *)v34 + 8);
        std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v69, (uint64_t *)v80);
        std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>::destroy(*(_QWORD **)(v80 + 48));
        operator delete((void *)v80);
        v67 = *((_QWORD *)v34 + 11) + 1;
        *((_QWORD *)v34 + 11) = v67;
        v68 += v79;
      }
      while (v79);
      v9 += v66 + v68;
      a3 += 6;
    }
    while (a3 != v86);
  }
  return v9;
}

_QWORD *dcsctp::TraditionalReassemblyStreams::ResetStreams(_QWORD *result, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned __int16 *v5;
  unsigned int v6;
  _QWORD *v7;
  unsigned int v8;
  BOOL v9;
  uint64_t *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;

  if (a3)
  {
    v4 = result[11];
    result += 11;
    v3 = v4;
    if (v4)
    {
      v5 = &a2[a3];
LABEL_4:
      v6 = *a2;
      v7 = result;
      do
      {
        v8 = *(unsigned __int16 *)(v3 + 32);
        v9 = v8 >= v6;
        if (v8 >= v6)
          v10 = (uint64_t *)v3;
        else
          v10 = (uint64_t *)(v3 + 8);
        if (v9)
          v7 = (_QWORD *)v3;
        v3 = *v10;
      }
      while (*v10);
      if (v7 != result && v6 >= *((unsigned __int16 *)v7 + 16))
      {
        v7[9] = 0;
        *((_WORD *)v7 + 40) = 0;
        *((_BYTE *)v7 + 82) = 1;
        v7[11] = 0;
      }
      while (++a2 != v5)
      {
        v3 = *result;
        if (*result)
          goto LABEL_4;
      }
    }
  }
  else
  {
    v11 = (_QWORD *)result[10];
    if (v11 != result + 11)
    {
      do
      {
        v11[9] = 0;
        *((_WORD *)v11 + 40) = 0;
        *((_BYTE *)v11 + 82) = 1;
        v11[11] = 0;
        v12 = (_QWORD *)v11[1];
        if (v12)
        {
          do
          {
            v13 = v12;
            v12 = (_QWORD *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            v13 = (_QWORD *)v11[2];
            v14 = *v13 == (_QWORD)v11;
            v11 = v13;
          }
          while (!v14);
        }
        v11 = v13;
      }
      while (v13 != result + 11);
    }
  }
  return result;
}

uint64_t dcsctp::TraditionalReassemblyStreams::GetHandoverReadiness(dcsctp::TraditionalReassemblyStreams *this)
{
  dcsctp::TraditionalReassemblyStreams *v2;
  uint64_t result;
  char *v4;
  char *v5;
  dcsctp::TraditionalReassemblyStreams *v6;
  dcsctp::TraditionalReassemblyStreams *v7;
  BOOL v8;
  char *v9;
  char *v10;

  v2 = (dcsctp::TraditionalReassemblyStreams *)*((_QWORD *)this + 10);
  if (v2 == (dcsctp::TraditionalReassemblyStreams *)((char *)this + 88))
  {
LABEL_2:
    result = 0;
    v4 = (char *)*((_QWORD *)this + 7);
    v5 = (char *)this + 64;
    if (v4 != v5)
      goto LABEL_15;
  }
  else
  {
    while (!*((_QWORD *)v2 + 8))
    {
      v6 = (dcsctp::TraditionalReassemblyStreams *)*((_QWORD *)v2 + 1);
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = *(dcsctp::TraditionalReassemblyStreams **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (dcsctp::TraditionalReassemblyStreams *)*((_QWORD *)v2 + 2);
          v8 = *(_QWORD *)v7 == (_QWORD)v2;
          v2 = v7;
        }
        while (!v8);
      }
      v2 = v7;
      if (v7 == (dcsctp::TraditionalReassemblyStreams *)((char *)this + 88))
        goto LABEL_2;
    }
    result = 128;
    v4 = (char *)*((_QWORD *)this + 7);
    v5 = (char *)this + 64;
    if (v4 != v5)
    {
LABEL_15:
      while (!*((_QWORD *)v4 + 8))
      {
        v9 = (char *)*((_QWORD *)v4 + 1);
        if (v9)
        {
          do
          {
            v10 = v9;
            v9 = *(char **)v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            v10 = (char *)*((_QWORD *)v4 + 2);
            v8 = *(_QWORD *)v10 == (_QWORD)v4;
            v4 = v10;
          }
          while (!v8);
        }
        v4 = v10;
        if (v10 == v5)
          return result;
      }
      return result | 0x100;
    }
  }
  return result;
}

void dcsctp::TraditionalReassemblyStreams::AddHandoverState(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  unint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t *v30;
  uint64_t v31;
  __int128 v32;
  unint64_t v33;
  _QWORD *v34;
  BOOL v35;
  _QWORD *v36;
  char *v37;
  int v38;
  unint64_t v39;
  _QWORD *v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  _BYTE *v47;
  _DWORD *v48;
  char *v49;
  unint64_t v50;
  char *v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v57;
  uint64_t v58;
  _OWORD *v59;
  char *v60;
  uint64_t v61;
  __int128 v62;
  int v63;
  _QWORD *v64;

  v3 = (_QWORD *)a1[10];
  v4 = a1 + 11;
  if (v3 != a1 + 11)
  {
    v5 = (unint64_t *)a2[15];
    while (1)
    {
      v6 = *((unsigned __int16 *)v3 + 16);
      v7 = v3[11];
      v8 = a2[16];
      if ((unint64_t)v5 >= v8)
        break;
      if (!v5)
        goto LABEL_77;
      *v5++ = v6 & 0xFFFF0000FFFFFFFFLL | ((unint64_t)(unsigned __int16)v3[11] << 32);
      a2[15] = v5;
      v9 = (_QWORD *)v3[1];
      if (v9)
      {
        do
        {
LABEL_34:
          v34 = v9;
          v9 = (_QWORD *)*v9;
        }
        while (v9);
        goto LABEL_3;
      }
      do
      {
LABEL_36:
        v34 = (_QWORD *)v3[2];
        v35 = *v34 == (_QWORD)v3;
        v3 = v34;
      }
      while (!v35);
LABEL_3:
      v3 = v34;
      if (v34 == v4)
        goto LABEL_39;
    }
    v10 = (char *)a2[14];
    v11 = ((char *)v5 - v10) >> 3;
    v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 61)
      goto LABEL_78;
    v13 = v8 - (_QWORD)v10;
    if (v13 >> 2 > v12)
      v12 = v13 >> 2;
    v14 = (unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8;
    v15 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v14)
      v15 = v12;
    if (!v15)
    {
LABEL_77:
      __break(1u);
LABEL_78:
      abort();
    }
    if (v15 >> 61)
LABEL_79:
      std::__throw_bad_array_new_length[abi:sn180100]();
    v16 = 8 * v15;
    v17 = (char *)operator new(8 * v15);
    v18 = (unint64_t *)&v17[8 * v11];
    *v18 = v6 & 0xFFFF0000FFFFFFFFLL | ((unint64_t)(unsigned __int16)v7 << 32);
    v19 = v18 + 1;
    if (v5 == (unint64_t *)v10)
    {
LABEL_31:
      a2[14] = v18;
      a2[15] = v19;
      a2[16] = &v17[v16];
      if (v5)
        operator delete(v5);
      v5 = v19;
      a2[15] = v19;
      v9 = (_QWORD *)v3[1];
      if (v9)
        goto LABEL_34;
      goto LABEL_36;
    }
    v20 = (char *)v5 - v10 - 8;
    if (v20 >= 0x168)
    {
      v22 = ((char *)(v5 - 1) - v10) & 0xFFFFFFFFFFFFFFF8;
      v23 = (unint64_t)&v17[(char *)v5 - v10 - 8];
      v24 = v23 - v22;
      v25 = (unint64_t)v5 - v22 - 8;
      if (v24 > v23 || v25 > (unint64_t)(v5 - 1))
      {
        v21 = v5;
      }
      else if ((unint64_t)(v10 - v17) >= 0x20)
      {
        v27 = (v20 >> 3) + 1;
        v28 = 8 * (v27 & 0x3FFFFFFFFFFFFFFCLL);
        v21 = &v5[v28 / 0xFFFFFFFFFFFFFFF8];
        v18 = (unint64_t *)((char *)v18 - v28);
        v29 = &v17[8 * v11 - 16];
        v30 = v5 - 2;
        v31 = v27 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v32 = *(_OWORD *)v30;
          *((_OWORD *)v29 - 1) = *((_OWORD *)v30 - 1);
          *(_OWORD *)v29 = v32;
          v29 -= 32;
          v30 -= 4;
          v31 -= 4;
        }
        while (v31);
        if (v27 == (v27 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_30;
      }
      else
      {
        v21 = v5;
      }
    }
    else
    {
      v21 = v5;
    }
    do
    {
      v33 = *--v21;
      *--v18 = v33;
    }
    while (v21 != (unint64_t *)v10);
LABEL_30:
    v5 = (unint64_t *)v10;
    goto LABEL_31;
  }
LABEL_39:
  v36 = (_QWORD *)a1[7];
  if (v36 != a1 + 8)
  {
    v37 = (char *)a2[18];
    while (1)
    {
      v38 = *((unsigned __int16 *)v36 + 16);
      v39 = a2[19];
      if ((unint64_t)v37 >= v39)
        break;
      if (!v37)
        goto LABEL_77;
      *(_DWORD *)v37 = v38;
      v37 += 4;
      a2[18] = v37;
      v40 = (_QWORD *)v36[1];
      if (v40)
      {
        do
        {
LABEL_71:
          v64 = v40;
          v40 = (_QWORD *)*v40;
        }
        while (v40);
        goto LABEL_41;
      }
      do
      {
LABEL_73:
        v64 = (_QWORD *)v36[2];
        v35 = *v64 == (_QWORD)v36;
        v36 = v64;
      }
      while (!v35);
LABEL_41:
      v36 = v64;
      if (v64 == a1 + 8)
        return;
    }
    v41 = (char *)a2[17];
    v42 = (v37 - v41) >> 2;
    v43 = v42 + 1;
    if ((unint64_t)(v42 + 1) >> 62)
      goto LABEL_78;
    v44 = v39 - (_QWORD)v41;
    if (v44 >> 1 > v43)
      v43 = v44 >> 1;
    v14 = (unint64_t)v44 >= 0x7FFFFFFFFFFFFFFCLL;
    v45 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v14)
      v45 = v43;
    if (!v45)
      goto LABEL_77;
    if (v45 >> 62)
      goto LABEL_79;
    v46 = 4 * v45;
    v47 = operator new(4 * v45);
    v48 = &v47[4 * v42];
    *v48 = v38;
    v49 = (char *)(v48 + 1);
    if (v37 != v41)
    {
      v50 = v37 - v41 - 4;
      if (v50 < 0xBC)
      {
        v51 = v37;
        goto LABEL_67;
      }
      v52 = (v37 - 4 - v41) & 0xFFFFFFFFFFFFFFFCLL;
      v53 = (unint64_t)&v47[v37 - v41 - 4];
      v54 = v53 - v52;
      v55 = (unint64_t)&v37[-v52 - 4];
      if (v54 > v53 || v55 > (unint64_t)(v37 - 4))
      {
        v51 = v37;
        goto LABEL_67;
      }
      if ((unint64_t)(v41 - v47) < 0x20)
      {
        v51 = v37;
        do
        {
LABEL_67:
          v63 = *((_DWORD *)v51 - 1);
          v51 -= 4;
          *--v48 = v63;
        }
        while (v51 != v41);
        goto LABEL_68;
      }
      v57 = (v50 >> 2) + 1;
      v58 = 4 * (v57 & 0x7FFFFFFFFFFFFFF8);
      v51 = &v37[-v58];
      v48 = (_DWORD *)((char *)v48 - v58);
      v59 = &v47[4 * v42 - 16];
      v60 = v37 - 16;
      v61 = v57 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v62 = *(_OWORD *)v60;
        *(v59 - 1) = *((_OWORD *)v60 - 1);
        *v59 = v62;
        v59 -= 2;
        v60 -= 32;
        v61 -= 8;
      }
      while (v61);
      if (v57 != (v57 & 0x7FFFFFFFFFFFFFF8))
        goto LABEL_67;
    }
LABEL_68:
    a2[17] = v48;
    a2[18] = v49;
    a2[19] = &v47[v46];
    if (v41)
      operator delete(v41);
    v37 = v49;
    a2[18] = v49;
    v40 = (_QWORD *)v36[1];
    if (v40)
      goto LABEL_71;
    goto LABEL_73;
  }
}

void dcsctp::TraditionalReassemblyStreams::RestoreFromState(uint64_t a1, _QWORD *a2)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  unsigned int v6;
  int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t **v10;
  uint64_t **v11;
  uint64_t **v12;
  uint64_t v13;
  unsigned int v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  unsigned int v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t **v20;
  uint64_t **v21;
  uint64_t **v22;
  uint64_t v23;
  unsigned int v24;

  v4 = (unsigned __int16 *)a2[14];
  v5 = (unsigned __int16 *)a2[15];
  if (v4 != v5)
  {
    while (2)
    {
      while (1)
      {
        v6 = *v4;
        v7 = *((_DWORD *)v4 + 1);
        v8 = (uint64_t *)operator new(0x60uLL);
        v9 = v8;
        *((_WORD *)v8 + 16) = v6;
        v8[7] = 0;
        v8[5] = a1;
        v8[6] = (uint64_t)(v8 + 7);
        v8[8] = 0;
        v8[9] = (unsigned __int16)v7;
        *((_WORD *)v8 + 40) = v7;
        *((_BYTE *)v8 + 82) = 1;
        v8[11] = (unsigned __int16)v7;
        v10 = (uint64_t **)(a1 + 88);
        v11 = (uint64_t **)(a1 + 88);
        v12 = *(uint64_t ***)(a1 + 88);
        if (v12)
          break;
LABEL_5:
        *v8 = 0;
        v8[1] = 0;
        v8[2] = (uint64_t)v11;
        *v10 = v8;
        v13 = **(_QWORD **)(a1 + 80);
        if (v13)
        {
LABEL_12:
          *(_QWORD *)(a1 + 80) = v13;
          v9 = *v10;
        }
LABEL_3:
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 88), v9);
        ++*(_QWORD *)(a1 + 96);
        v4 += 4;
        if (v4 == v5)
          goto LABEL_14;
      }
      while (1)
      {
        while (1)
        {
          v11 = v12;
          v14 = *((unsigned __int16 *)v12 + 16);
          if (v14 <= v6)
            break;
          v12 = (uint64_t **)*v12;
          v10 = v11;
          if (!*v11)
            goto LABEL_5;
        }
        if (v14 >= v6)
          break;
        v12 = (uint64_t **)v12[1];
        if (!v12)
        {
          v10 = v11 + 1;
          *v8 = 0;
          v8[1] = 0;
          v8[2] = (uint64_t)v11;
          v11[1] = v8;
          v13 = **(_QWORD **)(a1 + 80);
          if (!v13)
            goto LABEL_3;
          goto LABEL_12;
        }
      }
      operator delete(v8);
      v4 += 4;
      if (v4 != v5)
        continue;
      break;
    }
  }
LABEL_14:
  v16 = (unsigned __int16 *)a2[17];
  v15 = (unsigned __int16 *)a2[18];
  if (v16 != v15)
  {
    while (2)
    {
      while (1)
      {
        v17 = *v16;
        v18 = (uint64_t *)operator new(0x48uLL);
        v19 = v18;
        *((_WORD *)v18 + 16) = v17;
        v18[7] = 0;
        v18[8] = 0;
        v18[5] = a1;
        v18[6] = (uint64_t)(v18 + 7);
        v20 = *(uint64_t ***)(a1 + 64);
        v21 = (uint64_t **)(a1 + 64);
        v22 = (uint64_t **)(a1 + 64);
        if (v20)
          break;
LABEL_18:
        *v18 = 0;
        v18[1] = 0;
        v18[2] = (uint64_t)v22;
        *v21 = v18;
        v23 = **(_QWORD **)(a1 + 56);
        if (v23)
        {
LABEL_25:
          *(_QWORD *)(a1 + 56) = v23;
          v19 = *v21;
        }
LABEL_16:
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 64), v19);
        ++*(_QWORD *)(a1 + 72);
        v16 += 2;
        if (v16 == v15)
          return;
      }
      while (1)
      {
        while (1)
        {
          v22 = v20;
          v24 = *((unsigned __int16 *)v20 + 16);
          if (v24 <= v17)
            break;
          v20 = (uint64_t **)*v20;
          v21 = v22;
          if (!*v22)
            goto LABEL_18;
        }
        if (v24 >= v17)
          break;
        v20 = (uint64_t **)v20[1];
        if (!v20)
        {
          v21 = v22 + 1;
          *v18 = 0;
          v18[1] = 0;
          v18[2] = (uint64_t)v22;
          v22[1] = v18;
          v23 = **(_QWORD **)(a1 + 56);
          if (!v23)
            goto LABEL_16;
          goto LABEL_25;
        }
      }
      operator delete(v18);
      v16 += 2;
      if (v16 != v15)
        continue;
      break;
    }
  }
}

void dcsctp::TraditionalReassemblyStreams::~TraditionalReassemblyStreams(dcsctp::TraditionalReassemblyStreams *this)
{
  dcsctp::TraditionalReassemblyStreams *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24C0C2680;
  std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>>>::destroy(*((_QWORD **)this + 11));
  std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>>>::destroy(*((_QWORD **)this + 8));
  v2 = (dcsctp::TraditionalReassemblyStreams *)*((_QWORD *)this + 6);
  if (v2 == (dcsctp::TraditionalReassemblyStreams *)((char *)this + 24))
  {
    v3 = 4;
    v2 = (dcsctp::TraditionalReassemblyStreams *)((char *)this + 24);
  }
  else
  {
    if (!v2)
      return;
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
}

{
  dcsctp::TraditionalReassemblyStreams *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24C0C2680;
  std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>>>::destroy(*((_QWORD **)this + 11));
  std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>>>::destroy(*((_QWORD **)this + 8));
  v2 = (dcsctp::TraditionalReassemblyStreams *)*((_QWORD *)this + 6);
  if (v2 == (dcsctp::TraditionalReassemblyStreams *)((char *)this + 24))
  {
    v3 = 4;
    v2 = (dcsctp::TraditionalReassemblyStreams *)((char *)this + 24);
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

void std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>>>::destroy(*a1);
    std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::OrderedStream>>>::destroy(a1[1]);
    std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>>::destroy((_QWORD *)a1[7]);
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>>::destroy(*a1);
    std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::SSNTag,unsigned short>>,std::map<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>>::destroy(a1[1]);
    std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>::destroy((_QWORD *)a1[6]);
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>::destroy(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>::destroy(*a1);
    std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>::destroy(a1[1]);
    v2 = (void *)a1[7];
    if (v2)
    {
      a1[8] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>>>::destroy(*a1);
    std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::TraditionalReassemblyStreams::UnorderedStream>>>::destroy(a1[1]);
    std::__tree<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::__map_value_compare<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>,std::less<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>>,true>,std::allocator<std::__value_type<dcsctp::UnwrappedSequenceNumber<webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>>,dcsctp::Data>>>::destroy((_QWORD *)a1[7]);
    operator delete(a1);
  }
}

uint64_t std::optional<std::vector<std::string>>::operator=[abi:sn180100]<std::vector<std::string> const&,void>(uint64_t a1, __int128 **a2)
{
  __int128 *v4;
  __int128 *v5;
  int64_t v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  std::string *v11;
  __int128 v12;

  if (*(_BYTE *)(a1 + 24))
  {
    if ((__int128 **)a1 != a2)
      std::vector<std::string>::__assign_with_size[abi:sn180100]<std::string*,std::string*>((std::string **)a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3));
    return a1;
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    v4 = *a2;
    v5 = a2[1];
    v6 = (char *)v5 - (char *)*a2;
    if (v5 != *a2)
    {
      v7 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 3);
      if (v7 >= 0xAAAAAAAAAAAAAABLL)
        abort();
      v8 = (char *)operator new(v6);
      v9 = 0;
      *(_QWORD *)a1 = v8;
      *(_QWORD *)(a1 + 8) = v8;
      *(_QWORD *)(a1 + 16) = &v8[24 * v7];
      do
      {
        while (1)
        {
          v10 = (char *)v4 + v9;
          v11 = (std::string *)&v8[v9];
          if ((*((char *)v4 + v9 + 23) & 0x80000000) == 0)
            break;
          std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
          v9 += 24;
          if ((__int128 *)((char *)v4 + v9) == v5)
            goto LABEL_11;
        }
        v12 = *(_OWORD *)v10;
        v11->__r_.__value_.__r.__words[2] = *((_QWORD *)v10 + 2);
        *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
        v9 += 24;
      }
      while ((__int128 *)((char *)v4 + v9) != v5);
LABEL_11:
      *(_QWORD *)(a1 + 8) = &v8[v9];
    }
    *(_BYTE *)(a1 + 24) = 1;
    return a1;
  }
}

uint64_t std::optional<std::vector<webrtc::RtpEncodingParameters>>::operator=[abi:sn180100]<std::vector<webrtc::RtpEncodingParameters> const&,void>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  int64_t v5;
  unint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  std::string *v14;
  const std::string::value_type **v15;
  __int128 v16;
  uint64_t v17;
  std::string *v18;
  const std::string::value_type **v19;
  __int128 v20;
  char *v21;

  if (*(_BYTE *)(a1 + 24))
  {
    if ((uint64_t *)a1 != a2)
      std::vector<webrtc::RtpEncodingParameters>::__assign_with_size[abi:sn180100]<webrtc::RtpEncodingParameters*,webrtc::RtpEncodingParameters*>((uint64_t *)a1, *a2, a2[1], 0xF0F0F0F0F0F0F0F1 * ((a2[1] - *a2) >> 4));
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    v3 = *a2;
    v4 = a2[1];
    v5 = v4 - *a2;
    if (v4 != *a2)
    {
      v6 = 0xF0F0F0F0F0F0F0F1 * (v5 >> 4);
      if (v6 >= 0xF0F0F0F0F0F0F1)
        abort();
      v7 = operator new(v5);
      v8 = 0;
      *(_QWORD *)a1 = v7;
      *(_QWORD *)(a1 + 8) = v7;
      *(_QWORD *)(a1 + 16) = &v7[272 * v6];
      do
      {
        v9 = &v7[v8];
        v10 = v3 + v8;
        *(_OWORD *)v9 = *(_OWORD *)(v3 + v8);
        v11 = *(_OWORD *)(v3 + v8 + 16);
        v12 = *(_OWORD *)(v3 + v8 + 32);
        v13 = *(_OWORD *)(v3 + v8 + 48);
        *(_OWORD *)(v9 + 57) = *(_OWORD *)(v3 + v8 + 57);
        *((_OWORD *)v9 + 2) = v12;
        *((_OWORD *)v9 + 3) = v13;
        *((_OWORD *)v9 + 1) = v11;
        v7[v8 + 80] = 0;
        v14 = (std::string *)&v7[v8 + 80];
        v9[104] = 0;
        if (*(_BYTE *)(v3 + v8 + 104))
        {
          v15 = (const std::string::value_type **)(v10 + 80);
          if (*(char *)(v10 + 103) < 0)
          {
            std::string::__init_copy_ctor_external(v14, *v15, *(_QWORD *)(v3 + v8 + 88));
          }
          else
          {
            v16 = *(_OWORD *)v15;
            *(_QWORD *)&v7[v8 + 96] = *(_QWORD *)(v10 + 96);
            *(_OWORD *)&v14->__r_.__value_.__l.__data_ = v16;
          }
          v9[104] = 1;
        }
        v17 = *(_QWORD *)(v10 + 112);
        *(_QWORD *)(v9 + 117) = *(_QWORD *)(v10 + 117);
        *((_QWORD *)v9 + 14) = v17;
        v18 = (std::string *)(v9 + 128);
        v19 = (const std::string::value_type **)(v10 + 128);
        if (*(char *)(v10 + 151) < 0)
        {
          std::string::__init_copy_ctor_external(v18, *v19, *(_QWORD *)(v3 + v8 + 136));
        }
        else
        {
          v20 = *(_OWORD *)v19;
          *((_QWORD *)v9 + 18) = *(_QWORD *)(v10 + 144);
          *(_OWORD *)&v18->__r_.__value_.__l.__data_ = v20;
        }
        v21 = &v7[v8];
        *((_WORD *)v21 + 76) = *(_WORD *)(v10 + 152);
        v7[v8 + 160] = 0;
        v21[264] = 0;
        if (*(_BYTE *)(v10 + 264))
        {
          webrtc::RtpCodec::RtpCodec((webrtc::RtpCodec *)&v7[v8 + 160], (const webrtc::RtpCodec *)(v3 + v8 + 160));
          v21[264] = 1;
        }
        v8 += 272;
      }
      while (v10 + 272 != v4);
      *(_QWORD *)(a1 + 8) = &v7[v8];
    }
    *(_BYTE *)(a1 + 24) = 1;
  }
  return a1;
}

void webrtc::TransceiverList::ListInternal(webrtc::TransceiverList *this@<X0>, char **a2@<X8>)
{
  _QWORD *v2;
  _QWORD *v3;
  char **v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  BOOL v16;
  unint64_t v17;
  _BYTE *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  BOOL v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _OWORD *v30;
  char *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v35;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v2 = *(_QWORD **)this;
  v3 = (_QWORD *)*((_QWORD *)this + 1);
  if (*(_QWORD **)this != v3)
  {
    v4 = a2;
    v5 = 0;
    v6 = 0;
    while (1)
    {
      v10 = (_QWORD *)*v2;
      if (*v2)
        (*(void (**)(_QWORD))*v10)(*v2);
      v11 = v10[2];
      v12 = (unint64_t)v4[2];
      if ((unint64_t)v5 >= v12)
        break;
      if (!v5)
        goto LABEL_37;
      *(_QWORD *)v5 = v11;
      v7 = v5 + 8;
      v4[1] = v7;
      v8 = v7;
      v9 = v6;
LABEL_5:
      (*(void (**)(_QWORD *))(*v10 + 8))(v10);
LABEL_6:
      ++v2;
      v5 = v8;
      v6 = v9;
      if (v2 == v3)
        return;
    }
    v13 = (v5 - v6) >> 3;
    v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 61)
      goto LABEL_38;
    v15 = v12 - (_QWORD)v6;
    if (v15 >> 2 > v14)
      v14 = v15 >> 2;
    v16 = (unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8;
    v17 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v16)
      v17 = v14;
    if (!v17)
    {
LABEL_37:
      __break(1u);
LABEL_38:
      abort();
    }
    if (v17 >> 61)
      std::__throw_bad_array_new_length[abi:sn180100]();
    v35 = 8 * v17;
    v18 = operator new(8 * v17);
    v9 = &v18[8 * v13];
    *(_QWORD *)v9 = v11;
    v8 = v9 + 8;
    if (v5 == v6)
    {
      v4 = a2;
      *a2 = v9;
      a2[1] = v8;
      a2[2] = &v18[v35];
      if (!v6)
      {
LABEL_28:
        v4[1] = v8;
        if (!v10)
          goto LABEL_6;
        goto LABEL_5;
      }
LABEL_27:
      operator delete(v6);
      goto LABEL_28;
    }
    v19 = v5 - v6 - 8;
    if (v19 < 0x168
      || ((v20 = (v5 - 8 - v6) & 0xFFFFFFFFFFFFFFF8,
           v21 = (unint64_t)&v18[v5 - v6 - 8],
           v22 = v21 - v20,
           v23 = (unint64_t)&v5[-v20 - 8],
           v22 <= v21)
        ? (v24 = v23 > (unint64_t)(v5 - 8))
        : (v24 = 1),
          v24 || (unint64_t)(v6 - v18) < 0x20))
    {
      v25 = v5;
      v4 = a2;
      v26 = v35;
    }
    else
    {
      v28 = (v19 >> 3) + 1;
      v29 = 8 * (v28 & 0x3FFFFFFFFFFFFFFCLL);
      v25 = &v5[-v29];
      v9 -= v29;
      v30 = &v18[8 * v13 - 16];
      v31 = v5 - 16;
      v32 = v28 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *(_OWORD *)v31;
        *(v30 - 1) = *((_OWORD *)v31 - 1);
        *v30 = v33;
        v30 -= 2;
        v31 -= 32;
        v32 -= 4;
      }
      while (v32);
      v4 = a2;
      v26 = v35;
      if (v28 == (v28 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_26:
        *v4 = v9;
        v4[1] = v8;
        v4[2] = &v18[v26];
        if (!v6)
          goto LABEL_28;
        goto LABEL_27;
      }
    }
    do
    {
      v27 = *((_QWORD *)v25 - 1);
      v25 -= 8;
      *((_QWORD *)v9 - 1) = v27;
      v9 -= 8;
    }
    while (v25 != v6);
    goto LABEL_26;
  }
}

void webrtc::TransceiverList::FindByMid(uint64_t **a1@<X0>, unsigned __int8 **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t *v4;
  uint64_t *v5;
  void *v7;
  int v8;
  uint64_t v9;
  size_t v10;
  unsigned __int8 *v11;
  int v12;
  unsigned __int8 *v13;
  uint64_t v14;
  int v15;
  int v16;
  void *__s1;
  size_t __n;
  unsigned __int8 v20;
  char v21;

  v4 = *a1;
  v5 = a1[1];
  if (*a1 != v5)
  {
    do
    {
      v9 = *v4;
      *a3 = *v4;
      if (v9)
        (**(void (***)(uint64_t))v9)(v9);
      (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v9 + 40))(&__s1, v9);
      if (v21)
      {
        if ((v20 & 0x80u) == 0)
          v10 = v20;
        else
          v10 = __n;
        v11 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
        v12 = (char)v11;
        if ((char)v11 < 0)
          v11 = a2[1];
        if ((unsigned __int8 *)v10 == v11)
        {
          if (v12 >= 0)
            v13 = (unsigned __int8 *)a2;
          else
            v13 = *a2;
          if ((v20 & 0x80) != 0)
          {
            v7 = __s1;
            v8 = memcmp(__s1, v13, __n);
            operator delete(v7);
            if (!v8)
              return;
          }
          else
          {
            if (!v20)
              return;
            v14 = 0;
            do
            {
              v15 = *((unsigned __int8 *)&__s1 + v14);
              v16 = v13[v14];
            }
            while (v15 == v16 && v20 - 1 != v14++);
            if (v15 == v16)
              return;
          }
        }
        else if ((v20 & 0x80) != 0)
        {
          operator delete(__s1);
        }
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
      ++v4;
    }
    while (v4 != v5);
  }
  *a3 = 0;
}

uint64_t dcsctp::TransmissionControlBlock::TransmissionControlBlock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  BOOL v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  double v62;
  int v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  _QWORD *v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  int v80;
  unsigned int v81;
  unsigned int v82;
  BOOL v83;
  uint64_t v84;
  _BOOL4 v85;
  uint64_t v86;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  _QWORD v94[3];
  _QWORD *v95;
  _BYTE v96[24];
  _BYTE *v97;
  _QWORD v98[3];
  _QWORD *v99;
  _QWORD v100[3];
  _QWORD *v101;
  _QWORD v102[3];
  _QWORD *v103;
  uint64_t v104;

  v104 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = &off_24C0C26D0;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  v25 = *(_OWORD *)a5;
  v26 = *(_OWORD *)(a5 + 16);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 40) = v26;
  *(_OWORD *)(a1 + 24) = v25;
  v27 = *(_OWORD *)(a5 + 48);
  v28 = *(_OWORD *)(a5 + 64);
  v29 = *(_OWORD *)(a5 + 80);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a5 + 96);
  *(_OWORD *)(a1 + 104) = v29;
  *(_OWORD *)(a1 + 88) = v28;
  *(_OWORD *)(a1 + 72) = v27;
  v30 = *(_OWORD *)(a5 + 112);
  v31 = *(_OWORD *)(a5 + 128);
  v32 = *(_OWORD *)(a5 + 144);
  *(_OWORD *)(a1 + 184) = *(_OWORD *)(a5 + 160);
  *(_OWORD *)(a1 + 168) = v32;
  *(_OWORD *)(a1 + 152) = v31;
  *(_OWORD *)(a1 + 136) = v30;
  *(_QWORD *)(a1 + 200) = a2;
  *(_QWORD *)(a1 + 208) = *(_QWORD *)a6;
  *(_QWORD *)(a1 + 216) = a7;
  v33 = operator new(0x20uLL);
  *v33 = &off_24C0C2790;
  v33[1] = dcsctp::TransmissionControlBlock::OnRtxTimerExpiry;
  v33[2] = 0;
  v33[3] = a1;
  v101 = v33;
  v37 = *(_DWORD *)(a5 + 76);
  v38 = 1000 * v37;
  if (v37 == 0x7FFFFFFF)
    v38 = 0x7FFFFFFFFFFFFFFFLL;
  v39 = *(int *)(a5 + 100);
  v40 = v39 == 0x7FFFFFFF || *(_BYTE *)(a5 + 104) == 0;
  v41 = 1000 * (int)v39;
  if (v40)
    v41 = 0x7FFFFFFFFFFFFFFFLL;
  v89 = v38;
  v90 = 1;
  v91 = 0;
  v92 = v41;
  v93 = 0;
  dcsctp::TimerManager::CreateTimer(a2, "t3-rtx", 6uLL, v100, (uint64_t)&v89, v34, v35, v36, (uint64_t *)(a1 + 224));
  v42 = v101;
  if (v101 == v100)
  {
    v43 = 4;
    v42 = v100;
  }
  else
  {
    if (!v101)
      goto LABEL_13;
    v43 = 5;
  }
  (*(void (**)(void))(*v42 + 8 * v43))();
LABEL_13:
  v44 = *(_QWORD *)(a1 + 200);
  v45 = operator new(0x20uLL);
  *v45 = &off_24C0C2790;
  v45[1] = dcsctp::TransmissionControlBlock::OnDelayedAckTimerExpiry;
  v45[2] = 0;
  v45[3] = a1;
  v99 = v45;
  v49 = *(_DWORD *)(a5 + 112);
  v50 = 1000 * v49;
  if (v49 == 0x7FFFFFFF)
    v50 = 0x7FFFFFFFFFFFFFFFLL;
  v89 = v50;
  v90 = 1;
  v91 = 0x100000000;
  v92 = 0x7FFFFFFFFFFFFFFFLL;
  v93 = 1;
  dcsctp::TimerManager::CreateTimer(v44, "delayed-ack", 0xBuLL, v98, (uint64_t)&v89, v46, v47, v48, (uint64_t *)(a1 + 232));
  v51 = v99;
  if (v99 == v98)
  {
    v52 = 4;
    v51 = v98;
  }
  else
  {
    if (!v99)
      goto LABEL_20;
    v52 = 5;
  }
  (*(void (**)(void))(*v51 + 8 * v52))();
LABEL_20:
  *(_DWORD *)(a1 + 240) = a9;
  *(_DWORD *)(a1 + 244) = a11;
  *(_DWORD *)(a1 + 248) = a13;
  *(_DWORD *)(a1 + 252) = a15;
  *(_QWORD *)(a1 + 256) = a17;
  v53 = *(_QWORD *)(a19 + 24);
  if (v53)
  {
    if (v53 == a19)
    {
      *(_QWORD *)(a1 + 288) = a1 + 264;
      (*(void (**)(_QWORD))(**(_QWORD **)(a19 + 24) + 24))(*(_QWORD *)(a19 + 24));
    }
    else
    {
      *(_QWORD *)(a1 + 288) = v53;
      *(_QWORD *)(a19 + 24) = 0;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 288) = 0;
  }
  *(_QWORD *)(a1 + 296) = a18;
  *(_QWORD *)(a1 + 304) = 0;
  v54 = *(_DWORD *)(a5 + 84);
  v55 = 1000 * v54;
  v40 = v54 == 0x7FFFFFFF;
  v56 = 0x7FFFFFFFFFFFFFFFLL;
  if (v40)
    v55 = 0x7FFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 312) = v55;
  v57 = *(_DWORD *)(a5 + 80);
  if (v57 == 0x7FFFFFFF)
    v58 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v58 = 1000 * v57;
  *(_QWORD *)(a1 + 320) = v58;
  v59 = *(_DWORD *)(a5 + 72);
  if (v59 == 0x7FFFFFFF)
    v60 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v60 = 1000 * v59;
  *(_QWORD *)(a1 + 328) = v60;
  v61 = *(_DWORD *)(a5 + 116);
  v62 = (double)(1000 * v61) * 0.125;
  if (v61 == 0x7FFFFFFF)
    v62 = 1.1529215e18;
  *(_QWORD *)(a1 + 336) = llround(v62);
  *(_BYTE *)(a1 + 344) = 1;
  v63 = *(_DWORD *)(a5 + 76);
  if (v63 == 0x7FFFFFFF)
    v64 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v64 = 1000 * v63;
  *(_QWORD *)(a1 + 352) = v64;
  *(_QWORD *)(a1 + 360) = 0;
  v65 = *(_DWORD *)(a5 + 76);
  if (v65 != 0x7FFFFFFF)
    v56 = 1000 * v65;
  *(_QWORD *)(a1 + 368) = v56;
  *(_QWORD *)(a1 + 376) = a3;
  *(_QWORD *)(a1 + 384) = a4;
  *(_QWORD *)(a1 + 392) = *(_QWORD *)(a5 + 148);
  *(_DWORD *)(a1 + 400) = 0;
  v66 = *(_QWORD *)(a1 + 232);
  *(_QWORD *)(a1 + 408) = a3;
  *(_QWORD *)(a1 + 416) = a4;
  *(_BYTE *)(a1 + 424) = 0;
  *(_QWORD *)(a1 + 432) = v66;
  *(_DWORD *)(a1 + 440) = 0;
  v67 = (a15 - 1);
  *(_QWORD *)(a1 + 448) = v67;
  *(_DWORD *)(a1 + 456) = v67;
  *(_BYTE *)(a1 + 460) = 1;
  *(_QWORD *)(a1 + 464) = v67;
  *(_QWORD *)(a1 + 472) = 0;
  *(_QWORD *)(a1 + 480) = 0;
  *(_QWORD *)(a1 + 488) = 0;
  *(_QWORD *)(a1 + 504) = 0;
  *(_QWORD *)(a1 + 512) = 0;
  *(_QWORD *)(a1 + 496) = a1 + 504;
  dcsctp::ReassemblyQueue::ReassemblyQueue(a1 + 520, a3, a4, *(_QWORD *)(a5 + 40), *(unsigned __int8 *)(a6 + 1));
  v68 = *(_QWORD *)(a1 + 216);
  v69 = (char *)operator new(0x20uLL);
  *(_QWORD *)v69 = &off_24C0C27D8;
  *(_OWORD *)(v69 + 8) = xmmword_208F05250;
  *((_QWORD *)v69 + 3) = a1;
  v97 = v69;
  v94[0] = &off_24C0C2820;
  v94[1] = a1;
  v95 = v94;
  dcsctp::RetransmissionQueue::RetransmissionQueue(a1 + 672, a3, a4, v68, a11, a16, a8, (uint64_t)v96, (uint64_t)v94, *(_QWORD *)(a1 + 224), (unint64_t *)a5, *(_WORD *)a6, HIBYTE(*(_WORD *)a6));
  v70 = v95;
  if (v95 == v94)
  {
    v71 = 4;
    v70 = v94;
  }
  else
  {
    if (!v95)
      goto LABEL_45;
    v71 = 5;
  }
  (*(void (**)(void))(*v70 + 8 * v71))();
LABEL_45:
  v72 = v97;
  if (v97 == v96)
  {
    v73 = 4;
    v72 = v96;
  }
  else
  {
    if (!v97)
      goto LABEL_50;
    v73 = 5;
  }
  (*(void (**)(void))(*v72 + 8 * v73))();
LABEL_50:
  *(_QWORD *)(a1 + 1240) = a3;
  *(_QWORD *)(a1 + 1248) = a4;
  *(_QWORD *)(a1 + 1256) = a1;
  *(_QWORD *)(a1 + 1264) = a1 + 408;
  *(_QWORD *)(a1 + 1272) = a1 + 520;
  *(_QWORD *)(a1 + 1280) = a1 + 672;
  *(_QWORD *)(a1 + 1288) = 0;
  *(_BYTE *)(a1 + 1296) = 0;
  *(_BYTE *)(a1 + 1300) = 0;
  v74 = operator new(0x20uLL);
  *v74 = &off_24C0C2748;
  v74[1] = dcsctp::StreamResetHandler::OnReconfigTimerExpiry;
  v74[2] = 0;
  v74[3] = a1 + 1240;
  v103 = v74;
  v89 = 0;
  v90 = 1;
  v91 = 0;
  v92 = 0x7FFFFFFFFFFFFFFFLL;
  v93 = 0;
  dcsctp::TimerManager::CreateTimer(a2, "re-config", 9uLL, v102, (uint64_t)&v89, v75, v76, v77, (uint64_t *)(a1 + 1304));
  v78 = v103;
  if (v103 == v102)
  {
    v79 = 4;
    v78 = v102;
  }
  else
  {
    if (!v103)
      goto LABEL_55;
    v79 = 5;
  }
  (*(void (**)(void))(*v78 + 8 * v79))();
LABEL_55:
  *(_DWORD *)(a1 + 1312) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 1256) + 24))(*(_QWORD *)(a1 + 1256));
  *(_BYTE *)(a1 + 1320) = 0;
  *(_BYTE *)(a1 + 1360) = 0;
  v80 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 1256) + 32))(*(_QWORD *)(a1 + 1256));
  v81 = v80 - 1;
  if (*(_BYTE *)(a1 + 1300))
  {
    v82 = *(_DWORD *)(a1 + 1296);
    v83 = v81 >= v82;
    v84 = v81 - v82;
    v85 = (_DWORD)v84 != 0 && v83;
    if ((_DWORD)v84 != 0x80000000)
      v85 = (int)v84 >= 0;
    if (!v85)
      v84 |= 0xFFFFFFFF00000000;
    v86 = v84 + *(_QWORD *)(a1 + 1288);
  }
  else
  {
    v86 = (v80 - 1);
  }
  *(_QWORD *)(a1 + 1288) = v86;
  *(_DWORD *)(a1 + 1296) = v81;
  *(_BYTE *)(a1 + 1300) = 1;
  *(_QWORD *)(a1 + 1368) = v86;
  *(_DWORD *)(a1 + 1376) = 0;
  dcsctp::HeartbeatHandler::HeartbeatHandler(a1 + 1384, a3, a4, a5, a1, *(_QWORD *)(a1 + 200));
  *(_BYTE *)(a1 + 1448) = 0;
  *(_BYTE *)(a1 + 1480) = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a8 + 112))(a8, *(unsigned __int8 *)(a6 + 1));
  return a1;
}

uint64_t dcsctp::TransmissionControlBlock::OnRtxTimerExpiry(dcsctp::TransmissionControlBlock *this)
{
  uint64_t v2;
  int64_t v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  void *v8[2];
  void *__p;
  void *v10;
  uint64_t v11;

  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 27) + 56))(*((_QWORD *)this + 27));
  if (*((_BYTE *)this + 1480))
    return 0;
  v4 = v2;
  if (!(*(unsigned int (**)(dcsctp::TransmissionControlBlock *, const char *, uint64_t))(*(_QWORD *)this
                                                                                                  + 64))(this, "t3-rtx expired", 14))return 0;
  v5 = *((_QWORD *)this + 123) >> 1;
  v6 = *((_QWORD *)this + 87);
  if (v5 <= 4 * v6)
    v5 = 4 * v6;
  *((_QWORD *)this + 125) = v5;
  *((_QWORD *)this + 123) = v6;
  *((_QWORD *)this + 126) = 0;
  dcsctp::OutstandingData::NackAll((dcsctp::TransmissionControlBlock *)((char *)this + 1056));
  LODWORD(v8[0]) = *((_DWORD *)this + 62);
  v7 = *((_DWORD *)this + 7);
  WORD2(v8[0]) = *((_DWORD *)this + 6);
  HIWORD(v8[0]) = v7;
  v8[1] = (void *)(*((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFFCLL);
  __p = 0;
  v10 = 0;
  v11 = 0;
  dcsctp::TransmissionControlBlock::SendBufferedPackets((uint64_t)this, v8, v4);
  if (!__p)
    return 0;
  v10 = __p;
  operator delete(__p);
  return 0;
}

uint64_t dcsctp::TransmissionControlBlock::OnDelayedAckTimerExpiry(dcsctp::TransmissionControlBlock *this)
{
  int v2;
  uint64_t v3;

  v2 = *((_DWORD *)this + 110);
  if (v2 != 3)
  {
    if (v2 == 2)
    {
      v3 = *((_QWORD *)this + 54);
      if (*(_BYTE *)(v3 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v3 + 136) + 24))(*(_QWORD *)(v3 + 136));
        *(_DWORD *)(v3 + 160) = 0;
        *(_BYTE *)(v3 + 156) = 0;
      }
    }
    *((_DWORD *)this + 110) = 3;
  }
  dcsctp::TransmissionControlBlock::MaybeSendSack(this);
  return 0;
}

uint64_t dcsctp::TransmissionControlBlock::ObserveRTT(dcsctp::TransmissionControlBlock *this, TimeDelta a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;

  result = dcsctp::RetransmissionTimeout::ObserveRTT((uint64_t)this + 312, a2);
  v4 = *((_QWORD *)this + 46);
  if (v4 >= 86400000000)
    v4 = 86400000000;
  *(_QWORD *)(*((_QWORD *)this + 28) + 144) = v4;
  v5 = llround((double)*((uint64_t *)this + 46) * 0.5);
  v6 = *((_DWORD *)this + 34);
  v7 = 1000 * v6;
  v8 = v6 == 0x7FFFFFFF;
  v9 = 0x7FFFFFFFFFFFFFFFLL;
  if (!v8)
    v9 = v7;
  if (v9 < v5)
    v5 = v9;
  if (v5 >= 86400000000)
    v5 = 86400000000;
  *(_QWORD *)(*((_QWORD *)this + 29) + 144) = v5;
  return result;
}

void dcsctp::TransmissionControlBlock::MaybeSendSack(dcsctp::TransmissionControlBlock *this)
{
  dcsctp::DataTracker *v2;
  _QWORD v3[2];
  void *__p;
  void *v5;
  _QWORD *v6[3];
  void *v7[2];
  void *v8;
  void *v9;

  if (*((_DWORD *)this + 110) == 3)
  {
    v2 = (dcsctp::TransmissionControlBlock *)((char *)this + 408);
    *((_DWORD *)this + 110) = 0;
    (*(void (**)(void **__return_ptr))(*(_QWORD *)this + 88))(v7);
    dcsctp::DataTracker::CreateSelectiveAck(v2, *((_DWORD *)this + 136) - *((_DWORD *)this + 164), (uint64_t)v3);
    dcsctp::SctpPacket::Builder::Add((uint64_t)v7, (uint64_t)v3);
    v3[0] = &off_24C0BEDA0;
    std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)v6, v6[1]);
    if (__p)
    {
      v5 = __p;
      operator delete(__p);
    }
    (*(void (**)(dcsctp::TransmissionControlBlock *, void **))(*(_QWORD *)this + 96))(this, v7);
    if (v8)
    {
      v9 = v8;
      operator delete(v8);
    }
  }
}

void dcsctp::TransmissionControlBlock::MaybeSendFastRetransmit(int64x2_t *this)
{
  __int32 v2;
  char *v3;
  char *v4;
  char *v5;
  __int128 *v6;
  _QWORD *v7;
  __int16 *v8;
  int v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  __int16 v13;
  char v14;
  void *v15;
  int v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  __int16 v20;
  char v21;
  void *v22;
  void (**v23)(dcsctp::DataChunk *__hidden);
  int v24;
  __int128 v25;
  void *__p[2];
  uint64_t v27;
  __int16 v28;
  char v29;
  char v30;
  char *v31;
  char *v32;
  __int32 v33;
  __int16 v34;
  __int16 v35;
  unint64_t v36;
  void *v37;
  void *v38;
  uint64_t v39;

  if (this[74].i64[0])
  {
    v33 = this[15].i32[2];
    v2 = this[1].i32[3];
    v34 = this[1].i32[2];
    v35 = v2;
    v36 = this[2].i64[1] & 0xFFFFFFFFFFFFFFFCLL;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    dcsctp::RetransmissionQueue::GetChunksForFastRetransmit(this + 42, v36 - 12, (uint64_t)&v31);
    v3 = v31;
    v4 = v32;
    if (v31 != v32)
    {
      v5 = v31;
      while (1)
      {
        v6 = (__int128 *)(v5 + 8);
        v7 = v5 + 24;
        v8 = (__int16 *)(v5 + 48);
        if (this[13].i8[1])
          break;
        v16 = *(_DWORD *)v5;
        v17 = *v6;
        v18 = *((_QWORD *)v5 + 5);
        v19 = *(_OWORD *)(v5 + 24);
        *((_QWORD *)v5 + 4) = 0;
        *((_QWORD *)v5 + 5) = 0;
        *v7 = 0;
        v20 = *v8;
        v21 = v5[50];
        v24 = v16;
        v25 = v17;
        *(_OWORD *)__p = v19;
        v27 = v18;
        v29 = v21;
        v28 = v20;
        v30 = 0;
        v23 = &off_24C0B2738;
        dcsctp::SctpPacket::Builder::Add((uint64_t)&v33, (uint64_t)&v23);
        v23 = (void (**)(dcsctp::DataChunk *__hidden))&unk_24C0B1318;
        v15 = __p[0];
        if (__p[0])
          goto LABEL_9;
LABEL_4:
        v5 += 56;
        if (v5 == v4)
          goto LABEL_10;
      }
      v9 = *(_DWORD *)v5;
      v10 = *v6;
      v11 = *((_QWORD *)v5 + 5);
      v12 = *(_OWORD *)(v5 + 24);
      *((_QWORD *)v5 + 4) = 0;
      *((_QWORD *)v5 + 5) = 0;
      *v7 = 0;
      v13 = *v8;
      v14 = v5[50];
      v24 = v9;
      v25 = v10;
      *(_OWORD *)__p = v12;
      v27 = v11;
      v29 = v14;
      v28 = v13;
      v30 = 0;
      v23 = &off_24C0B52E0;
      dcsctp::SctpPacket::Builder::Add((uint64_t)&v33, (uint64_t)&v23);
      v23 = (void (**)(dcsctp::DataChunk *__hidden))&unk_24C0B1318;
      v15 = __p[0];
      if (!__p[0])
        goto LABEL_4;
LABEL_9:
      __p[1] = v15;
      operator delete(v15);
      goto LABEL_4;
    }
LABEL_10:
    (*(void (**)(int64x2_t *, __int32 *))(this->i64[0] + 96))(this, &v33);
    if (v3)
    {
      for (; v4 != v3; v4 -= 56)
      {
        v22 = (void *)*((_QWORD *)v4 - 4);
        if (v22)
        {
          *((_QWORD *)v4 - 3) = v22;
          operator delete(v22);
        }
      }
      operator delete(v3);
    }
    if (v37)
    {
      v38 = v37;
      operator delete(v37);
    }
  }
}

void dcsctp::TransmissionControlBlock::SendBufferedPackets(uint64_t a1, _QWORD *a2, int64_t a3)
{
  int v5;
  void (**v6)(dcsctp::DataChunk *__hidden);
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  Timestamp v18;
  char *v19;
  char *v20;
  __int128 *v21;
  _QWORD *v22;
  __int16 *v23;
  int v24;
  __int128 v25;
  _QWORD *v26;
  __int128 v27;
  __int16 v28;
  char v29;
  void *v30;
  int v31;
  __int128 v32;
  _QWORD *v33;
  __int128 v34;
  __int16 v35;
  char v36;
  int v37;
  char *v38;
  void (**v39)(dcsctp::DataChunk *__hidden);
  int v40;
  char *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  void *v51;
  unint64_t v52;
  uint64_t v53;
  BOOL v54;
  char *v55;
  char *v56;
  void *v57;
  void *v58;
  uint64_t v59;
  dcsctp::DataTracker *v60;
  dcsctp::StreamResetHandler *v61;
  dcsctp::OutstandingData *v62;
  dcsctp::RetransmissionQueue *v63;
  unint64_t *v64;
  void (**v66)(dcsctp::IDataChunk *__hidden);
  void *v67;
  __int128 __p;
  void *v69[2];
  _QWORD *v70;
  __int16 v71;
  char v72;
  char v73;
  void *v74;
  char *v75;

  if (*(int *)(a1 + 168) < 1)
    return;
  v5 = 0;
  v59 = a1 + 1448;
  v60 = (dcsctp::DataTracker *)(a1 + 408);
  v61 = (dcsctp::StreamResetHandler *)(a1 + 1240);
  v62 = (dcsctp::OutstandingData *)(a1 + 1056);
  v63 = (dcsctp::RetransmissionQueue *)(a1 + 672);
  v6 = &off_24C0B2738;
  while (2)
  {
    v7 = *(_QWORD *)(a1 + 984);
    if (v7 >= *(_QWORD *)(a1 + 696) * *(_QWORD *)(a1 + 816))
    {
      v8 = *(_QWORD *)(a1 + 1152);
      v9 = v7 >= v8;
      v10 = v7 - v8;
      if (!v9)
        v10 = 0;
      if (v8 && v10 >= *(_QWORD *)(a1 + 992))
        v10 = *(_QWORD *)(a1 + 992);
      if (v10 < *(_QWORD *)(a1 + 856))
        return;
    }
    if (v5)
      goto LABEL_11;
    if (*(_BYTE *)(a1 + 1480))
      dcsctp::SctpPacket::Builder::Add((uint64_t)a2, v59);
    v17 = *(_DWORD *)(a1 + 440);
    if (v17 == 3)
      goto LABEL_18;
    if ((v17 - 1) <= 1)
    {
      if (v17 == 2)
      {
        v44 = *(_QWORD *)(a1 + 432);
        if (*(_BYTE *)(v44 + 156))
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(v44 + 136) + 24))(*(_QWORD *)(v44 + 136));
          *(_DWORD *)(v44 + 160) = 0;
          *(_BYTE *)(v44 + 156) = 0;
        }
      }
LABEL_18:
      *(_DWORD *)(a1 + 440) = 0;
      dcsctp::DataTracker::CreateSelectiveAck(v60, *(_DWORD *)(a1 + 544) - *(_DWORD *)(a1 + 656), (uint64_t)&v66);
      dcsctp::SctpPacket::Builder::Add((uint64_t)a2, (uint64_t)&v66);
      v66 = &off_24C0BEDA0;
      std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)&v69[1], v70);
      if ((_QWORD)__p)
      {
        *((_QWORD *)&__p + 1) = __p;
        operator delete((void *)__p);
      }
    }
    v5 = 0;
    if (*(_QWORD *)(a1 + 304) > a3 || !*(_BYTE *)(a1 + 864))
      goto LABEL_75;
    v45 = *(_QWORD *)(a1 + 1112);
    v46 = *(_QWORD *)(a1 + 1144);
    if (*(_QWORD *)(a1 + 1120) != v45)
    {
      v47 = *(_QWORD *)(a1 + 1136);
      v64 = (unint64_t *)(v45 + 8 * (v47 / 0x2E));
      v48 = *v64;
      v49 = *v64 + 88 * (v47 % 0x2E);
      v50 = *(_QWORD *)(v45 + 8 * ((v46 + v47) / 0x2E)) + 88 * ((v46 + v47) % 0x2E);
      if (v49 != v50)
      {
        do
        {
          if (*(_BYTE *)(v49 + 18) != 2)
          {
            if (*(_BYTE *)(v49 + 19) != 2 || *(_QWORD *)(v49 + 24) > a3)
              break;
            dcsctp::OutstandingData::AbandonAllFor(v62, (int *)v49);
            v48 = *v64;
          }
          v49 += 88;
          if (v49 - v48 == 4048)
          {
            v48 = v64[1];
            ++v64;
            v49 = v48;
          }
        }
        while (v49 != v50);
        v46 = *(_QWORD *)(a1 + 1144);
      }
    }
    if (!v46
      || *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 1112) + 8 * (*(_QWORD *)(a1 + 1136) / 0x2EuLL))
                  + 88 * (*(_QWORD *)(a1 + 1136) % 0x2EuLL)
                  + 18) != 2)
    {
      goto LABEL_75;
    }
    if (!*(_BYTE *)(a1 + 209))
    {
      dcsctp::OutstandingData::CreateForwardTsn(v62, (uint64_t)&v66);
      dcsctp::SctpPacket::Builder::Add((uint64_t)a2, (uint64_t)&v66);
      v66 = (void (**)(dcsctp::IDataChunk *__hidden))&unk_24C0B1348;
      v51 = (void *)__p;
      if (!(_QWORD)__p)
        goto LABEL_66;
      goto LABEL_65;
    }
    dcsctp::OutstandingData::CreateIForwardTsn(v62, (uint64_t)&v66);
    dcsctp::SctpPacket::Builder::Add((uint64_t)a2, (uint64_t)&v66);
    v66 = (void (**)(dcsctp::IDataChunk *__hidden))&unk_24C0B1348;
    v51 = (void *)__p;
    if ((_QWORD)__p)
    {
LABEL_65:
      *((_QWORD *)&__p + 1) = v51;
      operator delete(v51);
    }
LABEL_66:
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 96))(a1, a2);
    v52 = 0x7FFFFFFFFFFFFFFFLL;
    if (a3 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v53 = *(_QWORD *)(a1 + 352);
      if (v53 >= 200000)
        v53 = 200000;
      v54 = v53 == 0x8000000000000000 || a3 == 0x8000000000000000;
      v52 = v53 + a3;
      if (v54)
        v52 = 0x8000000000000000;
    }
    *(_QWORD *)(a1 + 304) = v52;
LABEL_75:
    dcsctp::StreamResetHandler::MakeStreamResetRequest(v61, (uint64_t)&v66);
    if (LOBYTE(v69[0]))
    {
      dcsctp::SctpPacket::Builder::Add((uint64_t)a2, (uint64_t)&v66);
      if (LOBYTE(v69[0]))
      {
        v66 = &off_24C0BB340;
        if (v67)
        {
          *(_QWORD *)&__p = v67;
          operator delete(v67);
        }
      }
    }
LABEL_11:
    v11 = a2[2];
    v12 = a2[3];
    if (v11 == v12)
    {
      v16 = a2[1] - 12;
    }
    else
    {
      v13 = v12 - v11;
      v14 = a2[1];
      v9 = v14 >= v13;
      v15 = v14 - v13;
      if (v9)
        v16 = v15;
      else
        v16 = 0;
    }
    v18.var0 = a3;
    dcsctp::RetransmissionQueue::GetChunksToSend((int64x2_t *)v63, v18, v16, (uint64_t)&v74);
    v20 = (char *)v74;
    v19 = v75;
    while (v20 != v19)
    {
      v21 = (__int128 *)(v20 + 8);
      v22 = v20 + 24;
      v23 = (__int16 *)(v20 + 48);
      if (!*(_BYTE *)(a1 + 209))
      {
        v31 = *(_DWORD *)v20;
        v32 = *v21;
        v33 = (_QWORD *)*((_QWORD *)v20 + 5);
        v34 = *(_OWORD *)(v20 + 24);
        *((_QWORD *)v20 + 4) = 0;
        *((_QWORD *)v20 + 5) = 0;
        *v22 = 0;
        v35 = *v23;
        v36 = v20[50];
        LODWORD(v67) = v31;
        __p = v32;
        *(_OWORD *)v69 = v34;
        v70 = v33;
        v72 = v36;
        v71 = v35;
        v73 = 0;
        v66 = v6;
        dcsctp::SctpPacket::Builder::Add((uint64_t)a2, (uint64_t)&v66);
        v66 = (void (**)(dcsctp::IDataChunk *__hidden))&unk_24C0B1318;
        v30 = v69[0];
        if (!v69[0])
          goto LABEL_22;
LABEL_28:
        v69[1] = v30;
        operator delete(v30);
        goto LABEL_22;
      }
      v24 = *(_DWORD *)v20;
      v25 = *v21;
      v26 = (_QWORD *)*((_QWORD *)v20 + 5);
      v27 = *(_OWORD *)(v20 + 24);
      *((_QWORD *)v20 + 4) = 0;
      *((_QWORD *)v20 + 5) = 0;
      *v22 = 0;
      v28 = *v23;
      v29 = v20[50];
      LODWORD(v67) = v24;
      __p = v25;
      *(_OWORD *)v69 = v27;
      v70 = v26;
      v72 = v29;
      v71 = v28;
      v73 = 0;
      v66 = &off_24C0B52E0;
      dcsctp::SctpPacket::Builder::Add((uint64_t)a2, (uint64_t)&v66);
      v66 = (void (**)(dcsctp::IDataChunk *__hidden))&unk_24C0B1318;
      v30 = v69[0];
      if (v69[0])
        goto LABEL_28;
LABEL_22:
      v20 += 56;
    }
    if (*(_BYTE *)(a1 + 211))
    {
      if (!dcsctp::PacketSender::Send(*(_QWORD **)(a1 + 296), (uint64_t)a2, *(_BYTE *)(a1 + 1480) != 0))
        goto LABEL_81;
LABEL_33:
      v37 = *(unsigned __int8 *)(a1 + 1480);
      v38 = (char *)v74;
      if (v74)
      {
        v39 = v6;
        v40 = v5;
        v41 = v75;
        v42 = v74;
        if (v75 != v74)
        {
          do
          {
            v43 = (void *)*((_QWORD *)v41 - 4);
            if (v43)
            {
              *((_QWORD *)v41 - 3) = v43;
              operator delete(v43);
            }
            v41 -= 56;
          }
          while (v41 != v38);
          v42 = v74;
        }
        v75 = v38;
        operator delete(v42);
        v5 = v40;
        v6 = v39;
      }
      if (v37)
        return;
      if (++v5 >= *(_DWORD *)(a1 + 168))
        return;
      continue;
    }
    break;
  }
  if (dcsctp::PacketSender::Send(*(_QWORD **)(a1 + 296), (uint64_t)a2, 1))
    goto LABEL_33;
LABEL_81:
  v55 = (char *)v74;
  if (v74)
  {
    v56 = v75;
    v57 = v74;
    if (v75 != v74)
    {
      do
      {
        v58 = (void *)*((_QWORD *)v56 - 4);
        if (v58)
        {
          *((_QWORD *)v56 - 3) = v58;
          operator delete(v58);
        }
        v56 -= 56;
      }
      while (v56 != v55);
      v57 = v74;
    }
    v75 = v55;
    operator delete(v57);
  }
}

void dcsctp::TransmissionControlBlock::~TransmissionControlBlock(dcsctp::TransmissionControlBlock *this)
{
  dcsctp::TransmissionControlBlock::~TransmissionControlBlock(this);
  JUMPOUT(0x20BD0ADECLL);
}

{
  void *v2;
  dcsctp::Timer *v3;
  dcsctp::Timer *v4;
  void *v5;
  dcsctp::Timer *v6;
  void *v7;
  void **v8;
  void **v9;
  unint64_t v10;
  void **v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  void *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  dcsctp::TransmissionControlBlock *v24;
  uint64_t v25;
  dcsctp::TransmissionControlBlock *v26;
  uint64_t v27;
  dcsctp::TransmissionControlBlock *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  void *v39;
  void *v40;
  dcsctp::TransmissionControlBlock *v41;
  uint64_t v42;
  dcsctp::Timer *v43;
  dcsctp::Timer *v44;

  *(_QWORD *)this = &off_24C0C26D0;
  if (*((_BYTE *)this + 1480))
  {
    *((_QWORD *)this + 181) = &off_24C0B1730;
    v2 = (void *)*((_QWORD *)this + 182);
    if (v2)
    {
      *((_QWORD *)this + 183) = v2;
      operator delete(v2);
    }
  }
  v3 = (dcsctp::Timer *)*((_QWORD *)this + 180);
  *((_QWORD *)this + 180) = 0;
  if (v3)
  {
    dcsctp::Timer::~Timer(v3);
    MEMORY[0x20BD0ADEC]();
  }
  v4 = (dcsctp::Timer *)*((_QWORD *)this + 179);
  *((_QWORD *)this + 179) = 0;
  if (v4)
  {
    dcsctp::Timer::~Timer(v4);
    MEMORY[0x20BD0ADEC]();
  }
  if (*((_BYTE *)this + 1360))
  {
    v5 = (void *)*((_QWORD *)this + 167);
    if (v5)
    {
      *((_QWORD *)this + 168) = v5;
      operator delete(v5);
    }
  }
  v6 = (dcsctp::Timer *)*((_QWORD *)this + 163);
  *((_QWORD *)this + 163) = 0;
  if (v6)
  {
    dcsctp::Timer::~Timer(v6);
    MEMORY[0x20BD0ADEC]();
  }
  v7 = (void *)*((_QWORD *)this + 152);
  if (v7)
  {
    *((_QWORD *)this + 153) = v7;
    operator delete(v7);
  }
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 1192, *((_QWORD **)this + 150));
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 1168, *((_QWORD **)this + 147));
  v8 = (void **)*((_QWORD *)this + 139);
  v9 = (void **)*((_QWORD *)this + 140);
  if (v9 == v8)
  {
    v9 = (void **)*((_QWORD *)this + 139);
    *((_QWORD *)this + 143) = 0;
    v17 = 0;
    goto LABEL_27;
  }
  v10 = *((_QWORD *)this + 142);
  v11 = &v8[v10 / 0x2E];
  v12 = (unint64_t)*v11;
  v13 = (unint64_t)*v11 + 88 * (v10 % 0x2E);
  v14 = (unint64_t)v8[(*((_QWORD *)this + 143) + v10) / 0x2E] + 88 * ((*((_QWORD *)this + 143) + v10) % 0x2E);
  if (v13 == v14)
  {
LABEL_25:
    *((_QWORD *)this + 143) = 0;
    v17 = (char *)v9 - (char *)v8;
    if ((unint64_t)((char *)v9 - (char *)v8) >= 0x11)
    {
      do
      {
        operator delete(*v8);
        v8 = (void **)(*((_QWORD *)this + 139) + 8);
        *((_QWORD *)this + 139) = v8;
        v9 = (void **)*((_QWORD *)this + 140);
        v17 = (char *)v9 - (char *)v8;
      }
      while ((unint64_t)((char *)v9 - (char *)v8) > 0x10);
    }
LABEL_27:
    v18 = v17 >> 3;
    if (v18 == 1)
    {
      v19 = 23;
    }
    else
    {
      if (v18 != 2)
      {
LABEL_33:
        if (v8 != v9)
        {
          do
          {
            v20 = *v8++;
            operator delete(v20);
          }
          while (v8 != v9);
          v21 = *((_QWORD *)this + 139);
          v22 = *((_QWORD *)this + 140);
          if (v22 != v21)
            *((_QWORD *)this + 140) = v22 + ((v21 - v22 + 7) & 0xFFFFFFFFFFFFFFF8);
        }
        v23 = (void *)*((_QWORD *)this + 138);
        if (v23)
          operator delete(v23);
        v24 = (dcsctp::TransmissionControlBlock *)*((_QWORD *)this + 137);
        if (v24 == (dcsctp::TransmissionControlBlock *)((char *)this + 1072))
        {
          v25 = 4;
          v24 = (dcsctp::TransmissionControlBlock *)((char *)this + 1072);
        }
        else
        {
          if (!v24)
            goto LABEL_44;
          v25 = 5;
        }
        (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_44:
        v26 = (dcsctp::TransmissionControlBlock *)*((_QWORD *)this + 119);
        if (v26 == (dcsctp::TransmissionControlBlock *)((char *)this + 928))
        {
          v27 = 4;
          v26 = (dcsctp::TransmissionControlBlock *)((char *)this + 928);
        }
        else
        {
          if (!v26)
            goto LABEL_49;
          v27 = 5;
        }
        (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_49:
        v28 = (dcsctp::TransmissionControlBlock *)*((_QWORD *)this + 115);
        if (v28 == (dcsctp::TransmissionControlBlock *)((char *)this + 896))
        {
          v29 = 4;
          v28 = (dcsctp::TransmissionControlBlock *)((char *)this + 896);
        }
        else
        {
          if (!v28)
            goto LABEL_54;
          v29 = 5;
        }
        (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_54:
        v30 = *((_QWORD *)this + 83);
        *((_QWORD *)this + 83) = 0;
        if (v30)
          (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
        if (*((_BYTE *)this + 648))
        {
          v31 = *((_QWORD *)this + 78);
          if (v31)
          {
            v32 = *((_QWORD *)this + 79);
            v33 = (void *)*((_QWORD *)this + 78);
            if (v32 != v31)
            {
              do
              {
                v34 = v32 - 32;
                (*(void (**)(uint64_t, uint64_t, uint64_t))(v32 - 16))(1, v34, v34);
                v32 = v34;
              }
              while (v34 != v31);
              v33 = (void *)*((_QWORD *)this + 78);
            }
            *((_QWORD *)this + 79) = v31;
            operator delete(v33);
          }
          v35 = (void *)*((_QWORD *)this + 75);
          if (v35)
          {
            *((_QWORD *)this + 76) = v35;
            operator delete(v35);
          }
        }
        v36 = *((_QWORD *)this + 71);
        if (v36)
        {
          v37 = *((_QWORD *)this + 72);
          v38 = (void *)*((_QWORD *)this + 71);
          if (v37 != v36)
          {
            do
            {
              v39 = *(void **)(v37 - 24);
              if (v39)
              {
                *(_QWORD *)(v37 - 16) = v39;
                operator delete(v39);
              }
              v37 -= 32;
            }
            while (v37 != v36);
            v38 = (void *)*((_QWORD *)this + 71);
          }
          *((_QWORD *)this + 72) = v36;
          operator delete(v38);
        }
        std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 496, *((_QWORD **)this + 63));
        v40 = (void *)*((_QWORD *)this + 59);
        if (v40)
        {
          *((_QWORD *)this + 60) = v40;
          operator delete(v40);
        }
        v41 = (dcsctp::TransmissionControlBlock *)*((_QWORD *)this + 36);
        if (v41 == (dcsctp::TransmissionControlBlock *)((char *)this + 264))
        {
          v42 = 4;
          v41 = (dcsctp::TransmissionControlBlock *)((char *)this + 264);
        }
        else
        {
          if (!v41)
          {
LABEL_79:
            v43 = (dcsctp::Timer *)*((_QWORD *)this + 29);
            *((_QWORD *)this + 29) = 0;
            if (v43)
            {
              dcsctp::Timer::~Timer(v43);
              MEMORY[0x20BD0ADEC]();
            }
            v44 = (dcsctp::Timer *)*((_QWORD *)this + 28);
            *((_QWORD *)this + 28) = 0;
            if (v44)
            {
              dcsctp::Timer::~Timer(v44);
              MEMORY[0x20BD0ADEC]();
            }
            return;
          }
          v42 = 5;
        }
        (*(void (**)(void))(*(_QWORD *)v41 + 8 * v42))();
        goto LABEL_79;
      }
      v19 = 46;
    }
    *((_QWORD *)this + 142) = v19;
    goto LABEL_33;
  }
  while (v13)
  {
    v15 = *(void **)(v13 + 56);
    if (v15)
    {
      *(_QWORD *)(v13 + 64) = v15;
      operator delete(v15);
      v12 = (unint64_t)*v11;
    }
    v13 += 88;
    if (v13 - v12 == 4048)
    {
      v16 = (unint64_t)v11[1];
      ++v11;
      v12 = v16;
      v13 = v16;
    }
    if (v13 == v14)
    {
      v9 = (void **)*((_QWORD *)this + 140);
      v8 = (void **)*((_QWORD *)this + 139);
      goto LABEL_25;
    }
  }
  __break(1u);
}

uint64_t dcsctp::TransmissionControlBlock::is_connection_established(dcsctp::TransmissionControlBlock *this)
{
  uint64_t v1;
  dcsctp::TransmissionControlBlock *v3;

  v1 = *((_QWORD *)this + 36);
  if (v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
  v3 = (dcsctp::TransmissionControlBlock *)std::__throw_bad_function_call[abi:sn180100]();
  return dcsctp::TransmissionControlBlock::my_initial_tsn(v3);
}

uint64_t dcsctp::TransmissionControlBlock::my_initial_tsn(dcsctp::TransmissionControlBlock *this)
{
  return *((unsigned int *)this + 61);
}

uint64_t dcsctp::TransmissionControlBlock::peer_initial_tsn(dcsctp::TransmissionControlBlock *this)
{
  return *((unsigned int *)this + 63);
}

uint64_t dcsctp::TransmissionControlBlock::callbacks(dcsctp::TransmissionControlBlock *this)
{
  return *((_QWORD *)this + 27);
}

uint64_t dcsctp::TransmissionControlBlock::current_rto(dcsctp::TransmissionControlBlock *this)
{
  return *((_QWORD *)this + 46);
}

BOOL dcsctp::TransmissionControlBlock::IncrementTxErrorCounter(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 400);
  *(_DWORD *)(a1 + 400) = v1 + 1;
  return !*(_BYTE *)(a1 + 396) || v1 < *(_DWORD *)(a1 + 392);
}

uint64_t dcsctp::TransmissionControlBlock::ClearTxErrorCounter(uint64_t this)
{
  if (*(int *)(this + 400) >= 1)
    *(_DWORD *)(this + 400) = 0;
  return this;
}

BOOL dcsctp::TransmissionControlBlock::HasTooManyTxErrors(dcsctp::TransmissionControlBlock *this)
{
  return *((_BYTE *)this + 396) && *((_DWORD *)this + 100) > *((_DWORD *)this + 98);
}

uint64_t dcsctp::TransmissionControlBlock::PacketBuilder@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  int v2;

  *(_DWORD *)a2 = *(_DWORD *)(this + 248);
  v2 = *(_DWORD *)(this + 28);
  *(_WORD *)(a2 + 4) = *(_DWORD *)(this + 24);
  *(_WORD *)(a2 + 6) = v2;
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(this + 40) & 0xFFFFFFFFFFFFFFFCLL;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  return this;
}

uint64_t dcsctp::TransmissionControlBlock::Send(uint64_t a1, uint64_t a2)
{
  return dcsctp::PacketSender::Send(*(_QWORD **)(a1 + 296), a2, *(_BYTE *)(a1 + 211) == 0);
}

void std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::StreamResetHandler::*)(void),dcsctp::StreamResetHandler*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::StreamResetHandler::*)(void),dcsctp::StreamResetHandler*>>,webrtc::TimeDelta ()(void)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

__n128 std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::StreamResetHandler::*)(void),dcsctp::StreamResetHandler*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::StreamResetHandler::*)(void),dcsctp::StreamResetHandler*>>,webrtc::TimeDelta ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24C0C2748;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::StreamResetHandler::*)(void),dcsctp::StreamResetHandler*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::StreamResetHandler::*)(void),dcsctp::StreamResetHandler*>>,webrtc::TimeDelta ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24C0C2748;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::StreamResetHandler::*)(void),dcsctp::StreamResetHandler*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::StreamResetHandler::*)(void),dcsctp::StreamResetHandler*>>,webrtc::TimeDelta ()(void)>::operator()(_QWORD *a1)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD *);
  _QWORD *v3;

  v1 = a1[2];
  v2 = (uint64_t (*)(_QWORD *))a1[1];
  v3 = (_QWORD *)(a1[3] + (v1 >> 1));
  if ((v1 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *))(*v3 + v2);
  return v2(v3);
}

void std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::TransmissionControlBlock::*)(void),dcsctp::TransmissionControlBlock*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::TransmissionControlBlock::*)(void),dcsctp::TransmissionControlBlock*>>,webrtc::TimeDelta ()(void)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

__n128 std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::TransmissionControlBlock::*)(void),dcsctp::TransmissionControlBlock*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::TransmissionControlBlock::*)(void),dcsctp::TransmissionControlBlock*>>,webrtc::TimeDelta ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24C0C2790;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::TransmissionControlBlock::*)(void),dcsctp::TransmissionControlBlock*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::TransmissionControlBlock::*)(void),dcsctp::TransmissionControlBlock*>>,webrtc::TimeDelta ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24C0C2790;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::TransmissionControlBlock::*)(void),dcsctp::TransmissionControlBlock*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::TransmissionControlBlock::*)(void),dcsctp::TransmissionControlBlock*>>,webrtc::TimeDelta ()(void)>::operator()(_QWORD *a1)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD *);
  _QWORD *v3;

  v1 = a1[2];
  v2 = (uint64_t (*)(_QWORD *))a1[1];
  v3 = (_QWORD *)(a1[3] + (v1 >> 1));
  if ((v1 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *))(*v3 + v2);
  return v2(v3);
}

void std::__function::__func<std::__bind_front_t<void (dcsctp::TransmissionControlBlock::*)(webrtc::TimeDelta),dcsctp::TransmissionControlBlock*>,std::allocator<std::__bind_front_t<void (dcsctp::TransmissionControlBlock::*)(webrtc::TimeDelta),dcsctp::TransmissionControlBlock*>>,void ()(webrtc::TimeDelta)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

__n128 std::__function::__func<std::__bind_front_t<void (dcsctp::TransmissionControlBlock::*)(webrtc::TimeDelta),dcsctp::TransmissionControlBlock*>,std::allocator<std::__bind_front_t<void (dcsctp::TransmissionControlBlock::*)(webrtc::TimeDelta),dcsctp::TransmissionControlBlock*>>,void ()(webrtc::TimeDelta)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24C0C27D8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind_front_t<void (dcsctp::TransmissionControlBlock::*)(webrtc::TimeDelta),dcsctp::TransmissionControlBlock*>,std::allocator<std::__bind_front_t<void (dcsctp::TransmissionControlBlock::*)(webrtc::TimeDelta),dcsctp::TransmissionControlBlock*>>,void ()(webrtc::TimeDelta)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24C0C27D8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind_front_t<void (dcsctp::TransmissionControlBlock::*)(webrtc::TimeDelta),dcsctp::TransmissionControlBlock*>,std::allocator<std::__bind_front_t<void (dcsctp::TransmissionControlBlock::*)(webrtc::TimeDelta),dcsctp::TransmissionControlBlock*>>,void ()(webrtc::TimeDelta)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t (*v3)(_QWORD *, _QWORD);
  _QWORD *v4;

  v2 = a1[2];
  v3 = (uint64_t (*)(_QWORD *, _QWORD))a1[1];
  v4 = (_QWORD *)(a1[3] + (v2 >> 1));
  if ((v2 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v3);
  return v3(v4, *a2);
}

void std::__function::__func<dcsctp::TransmissionControlBlock::TransmissionControlBlock(dcsctp::TimerManager &,std::string_view,dcsctp::DcSctpOptions const&,dcsctp::Capabilities const&,dcsctp::DcSctpSocketCallbacks &,dcsctp::SendQueue &,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>,dcsctp::PacketSender &,std::function<BOOL ()(void)>)::$_0,std::allocator<dcsctp::TransmissionControlBlock::TransmissionControlBlock(dcsctp::TimerManager &,std::string_view,dcsctp::DcSctpOptions const&,dcsctp::Capabilities const&,dcsctp::DcSctpSocketCallbacks &,dcsctp::SendQueue &,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>,dcsctp::PacketSender &,std::function<BOOL ()(void)>)::$_0>,void ()(void)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<dcsctp::TransmissionControlBlock::TransmissionControlBlock(dcsctp::TimerManager &,std::string_view,dcsctp::DcSctpOptions const&,dcsctp::Capabilities const&,dcsctp::DcSctpSocketCallbacks &,dcsctp::SendQueue &,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>,dcsctp::PacketSender &,std::function<BOOL ()(void)>)::$_0,std::allocator<dcsctp::TransmissionControlBlock::TransmissionControlBlock(dcsctp::TimerManager &,std::string_view,dcsctp::DcSctpOptions const&,dcsctp::Capabilities const&,dcsctp::DcSctpSocketCallbacks &,dcsctp::SendQueue &,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>,dcsctp::PacketSender &,std::function<BOOL ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C0C2820;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<dcsctp::TransmissionControlBlock::TransmissionControlBlock(dcsctp::TimerManager &,std::string_view,dcsctp::DcSctpOptions const&,dcsctp::Capabilities const&,dcsctp::DcSctpSocketCallbacks &,dcsctp::SendQueue &,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>,dcsctp::PacketSender &,std::function<BOOL ()(void)>)::$_0,std::allocator<dcsctp::TransmissionControlBlock::TransmissionControlBlock(dcsctp::TimerManager &,std::string_view,dcsctp::DcSctpOptions const&,dcsctp::Capabilities const&,dcsctp::DcSctpSocketCallbacks &,dcsctp::SendQueue &,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>,dcsctp::PacketSender &,std::function<BOOL ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C0C2820;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<dcsctp::TransmissionControlBlock::TransmissionControlBlock(dcsctp::TimerManager &,std::string_view,dcsctp::DcSctpOptions const&,dcsctp::Capabilities const&,dcsctp::DcSctpSocketCallbacks &,dcsctp::SendQueue &,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>,dcsctp::PacketSender &,std::function<BOOL ()(void)>)::$_0,std::allocator<dcsctp::TransmissionControlBlock::TransmissionControlBlock(dcsctp::TimerManager &,std::string_view,dcsctp::DcSctpOptions const&,dcsctp::Capabilities const&,dcsctp::DcSctpSocketCallbacks &,dcsctp::SendQueue &,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>,dcsctp::PacketSender &,std::function<BOOL ()(void)>)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 8);
  if (*(int *)(v1 + 400) >= 1)
    *(_DWORD *)(v1 + 400) = 0;
  return result;
}

uint64_t webrtc::TransparentMode::Create@<X0>(webrtc::TransparentMode *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v5;
  int v6;
  void *v7;
  size_t *v8;
  size_t *v9;
  size_t *v10;
  _DWORD *v11;
  size_t *v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  int v23;
  void *v24;
  size_t *v25;
  size_t *v26;
  size_t *v27;
  _DWORD *v28;
  size_t *v29;
  char v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  size_t v39;
  uint64_t v40;
  unsigned __int8 v41;

  if (*((_BYTE *)this + 285))
    goto LABEL_19;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3TransparentModeKillSwitch", 0x24uLL, &v39);
  v5 = v41;
  v6 = (char)v41;
  v7 = (void *)v39;
  if ((v41 & 0x80u) == 0)
  {
    v8 = &v39;
  }
  else
  {
    v5 = v40;
    v8 = (size_t *)v39;
  }
  v9 = (size_t *)((char *)v8 + v5);
  if (v5 >= 7)
  {
    v10 = v8;
    do
    {
      v11 = memchr(v10, 69, v5 - 6);
      if (!v11)
        break;
      v12 = (size_t *)v11;
      if (*v11 == 1650552389 && *(_DWORD *)((char *)v11 + 3) == 1684368482)
        goto LABEL_14;
      v10 = (size_t *)((char *)v11 + 1);
      v5 = (char *)v9 - ((char *)v12 + 1);
    }
    while (v5 > 6);
  }
  v12 = v9;
LABEL_14:
  if (v6 < 0)
  {
    operator delete(v7);
    if (v12 == v9)
      goto LABEL_23;
  }
  else if (v12 == v9)
  {
    goto LABEL_23;
  }
  if (v12 == v8)
  {
LABEL_19:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_processing/aec3/transparent_mode.cc");
    result = 0;
    goto LABEL_22;
  }
LABEL_23:
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3TransparentModeHmm", 0x1DuLL, &v39);
  v22 = v41;
  v23 = (char)v41;
  v24 = (void *)v39;
  if ((v41 & 0x80u) == 0)
  {
    v25 = &v39;
  }
  else
  {
    v22 = v40;
    v25 = (size_t *)v39;
  }
  v26 = (size_t *)((char *)v25 + v22);
  if (v22 >= 7)
  {
    v27 = v25;
    do
    {
      v28 = memchr(v27, 69, v22 - 6);
      if (!v28)
        break;
      v29 = (size_t *)v28;
      if (*v28 == 1650552389 && *(_DWORD *)((char *)v28 + 3) == 1684368482)
        goto LABEL_35;
      v27 = (size_t *)((char *)v28 + 1);
      v22 = (char *)v26 - ((char *)v29 + 1);
    }
    while (v22 > 6);
  }
  v29 = v26;
LABEL_35:
  if (v23 < 0)
    operator delete(v24);
  v31 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>();
  if (v29 == v26 || v29 != v25)
  {
    if ((v31 & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_processing/aec3/transparent_mode.cc");
    result = operator new();
    *(_QWORD *)result = &off_24C0C28A0;
    *(_BYTE *)(result + 8) = *((_BYTE *)this + 333);
    *(_QWORD *)(result + 16) = 0;
    *(_BYTE *)(result + 24) = 0;
    *(_QWORD *)(result + 32) = 10000;
    *(_WORD *)(result + 40) = 0;
    *(_QWORD *)(result + 88) = 0;
    *(_QWORD *)(result + 48) = 10000;
    *(_QWORD *)(result + 56) = 0;
    *(_QWORD *)(result + 64) = 0;
    *(_QWORD *)(result + 72) = 0;
    *(_BYTE *)(result + 80) = 0;
  }
  else
  {
    if ((v31 & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_processing/aec3/transparent_mode.cc");
    result = operator new();
    *(_QWORD *)result = &off_24C0C2868;
    *(_QWORD *)(result + 8) = 0;
  }
LABEL_22:
  *a2 = result;
  return result;
}

void webrtc::TransparentModeImpl::~TransparentModeImpl(webrtc::TransparentModeImpl *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::TransparentModeImpl::Active(webrtc::TransparentModeImpl *this)
{
  return *((unsigned __int8 *)this + 8);
}

uint64_t webrtc::TransparentModeImpl::Reset(uint64_t this)
{
  *(_BYTE *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  return this;
}

uint64_t webrtc::TransparentModeImpl::Update(uint64_t this, int a2, BOOL a3, BOOL a4, int a5, BOOL a6, int a7)
{
  float v7;
  float v8;
  char v9;

  if (a7)
  {
    v7 = (float)(*(float *)(this + 12) * 1.0) + (float)((float)(1.0 - *(float *)(this + 12)) * 0.000001);
    v8 = (float)(v7 * flt_208F1C920[a5 + 2])
       / (float)((float)(v7 * flt_208F1C920[a5 + 2]) + (float)(flt_208F1C920[a5] * (float)(1.0 - v7)));
    *(float *)(this + 12) = v8;
    if (v8 <= 0.95)
    {
      if (v8 >= 0.5)
        return this;
      v9 = 0;
    }
    else
    {
      v9 = 1;
    }
    *(_BYTE *)(this + 8) = v9;
  }
  return this;
}

void webrtc::LegacyTransparentModeImpl::~LegacyTransparentModeImpl(webrtc::LegacyTransparentModeImpl *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::LegacyTransparentModeImpl::Active(webrtc::LegacyTransparentModeImpl *this)
{
  return *((unsigned __int8 *)this + 24);
}

uint64_t webrtc::LegacyTransparentModeImpl::Reset(uint64_t this)
{
  *(_OWORD *)(this + 48) = xmmword_208F1C8F0;
  *(_QWORD *)(this + 88) = 0;
  if (*(_BYTE *)(this + 8))
    *(_BYTE *)(this + 80) = 0;
  return this;
}

uint64_t webrtc::LegacyTransparentModeImpl::Update(uint64_t this, int a2, int a3, int a4, BOOL a5, char a6, int a7, int a8)
{
  unint64_t v8;
  unint64_t v9;
  _BOOL4 v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;

  v8 = *(_QWORD *)(this + 16) + 1;
  *(_QWORD *)(this + 16) = v8;
  v9 = *(_QWORD *)(this + 88) + (a7 & ~a8);
  *(_QWORD *)(this + 88) = v9;
  if (a2 <= 4 && a3)
  {
    *(_BYTE *)(this + 40) = 1;
    *(_QWORD *)(this + 32) = 0;
  }
  else if (a7)
  {
    ++*(_QWORD *)(this + 32);
  }
  if (*(_BYTE *)(this + 40))
  {
    v10 = *(_QWORD *)(this + 32) < 0x1D4DuLL;
    if (a4)
    {
LABEL_8:
      *(_BYTE *)(this + 80) = 1;
      *(_QWORD *)(this + 48) = 0;
      v11 = *(_QWORD *)(this + 72) + 1;
      *(_QWORD *)(this + 64) = 0;
      *(_QWORD *)(this + 72) = v11;
      goto LABEL_15;
    }
  }
  else
  {
    v10 = v8 < 0x4E3;
    if (a4)
      goto LABEL_8;
  }
  v12 = *(_QWORD *)(this + 48) + 1;
  *(_QWORD *)(this + 48) = v12;
  if (v12 >= 0x1389)
    *(_QWORD *)(this + 72) = 0;
  if (a7)
  {
    v13 = *(_QWORD *)(this + 64) + 1;
    *(_QWORD *)(this + 64) = v13;
    if (v13 >= 0x3A99)
      *(_BYTE *)(this + 80) = 0;
  }
LABEL_15:
  if ((a6 & 1) != 0)
  {
    v14 = *(_QWORD *)(this + 56) + 1;
    *(_QWORD *)(this + 56) = v14;
    if (v14 < 0x3C)
    {
      if (*(_QWORD *)(this + 64) < 0x3A99uLL)
        goto LABEL_18;
LABEL_23:
      *(_BYTE *)(this + 41) = 0;
      if (*(_QWORD *)(this + 72) >= 0x33uLL)
        goto LABEL_19;
      goto LABEL_24;
    }
    *(_QWORD *)(this + 48) = 10000;
    if (*(_QWORD *)(this + 64) >= 0x3A99uLL)
      goto LABEL_23;
  }
  else
  {
    *(_QWORD *)(this + 56) = 0;
    if (*(_QWORD *)(this + 64) >= 0x3A99uLL)
      goto LABEL_23;
  }
LABEL_18:
  if (*(_QWORD *)(this + 72) >= 0x33uLL)
  {
LABEL_19:
    *(_BYTE *)(this + 41) = 1;
    *(_BYTE *)(this + 24) = 0;
    return this;
  }
LABEL_24:
  if (*(_BYTE *)(this + 41))
    *(_BYTE *)(this + 24) = 0;
  else
    *(_BYTE *)(this + 24) = (!v10 || !*(_BYTE *)(this + 80)) && v9 > 0x5DC;
  return this;
}

void webrtc::internal::TransportAdapter::~TransportAdapter(webrtc::internal::TransportAdapter *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::internal::TransportAdapter::SendRtp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v3;
  uint64_t (***v5)(_QWORD, uint64_t);

  v3 = atomic_load((unsigned __int8 *)(a1 + 16));
  if ((v3 & 1) == 0)
    return 0;
  v5 = *(uint64_t (****)(_QWORD, uint64_t))(a1 + 8);
  if (!a3)
    a2 = 0;
  return (**v5)(v5, a2);
}

uint64_t webrtc::internal::TransportAdapter::SendRtcp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v3;
  uint64_t v5;

  v3 = atomic_load((unsigned __int8 *)(a1 + 16));
  if ((v3 & 1) == 0)
    return 0;
  v5 = *(_QWORD *)(a1 + 8);
  if (!a3)
    a2 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 8))(v5, a2);
}

void cricket::IceParameters::Validate(cricket::IceParameters *this@<X0>, uint64_t a2@<X8>)
{
  cricket::IceParameters *v2;
  uint64_t v4;
  cricket::IceParameters *v5;
  char *v6;
  std::string *v7;
  std::string *v8;
  int v9;
  std::string::size_type v10;
  std::string::size_type size;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::string *v22;
  std::string::size_type v23;
  std::string::size_type v24;
  std::string *v25;
  int v26;
  std::string::size_type v27;
  std::string::size_type v28;
  std::string *v29;
  std::string::size_type v30;
  std::string::size_type v31;
  char v32;
  std::string *p_src;
  size_t v34;
  std::string *v35;
  std::string *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned __int8 *v40;
  uint64_t v41;
  char *v42;
  std::string *v43;
  std::string *v44;
  int v45;
  std::string::size_type v46;
  std::string::size_type v47;
  uint64_t v49;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  std::string *v58;
  std::string::size_type v59;
  std::string::size_type v60;
  char *v61;
  std::string *v62;
  int v63;
  std::string::size_type v64;
  std::string::size_type v65;
  std::string *v66;
  std::string::size_type v67;
  std::string::size_type v68;
  char v69;
  std::string *v70;
  size_t v71;
  std::string *v72;
  std::string *v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  char *v78;
  _BYTE __p[32];
  _BYTE v81[7];
  int v82;
  void *v83[4];
  std::string v84;
  std::string __src;

  v2 = this;
  v4 = *((unsigned __int8 *)this + 23);
  if (*((char *)this + 23) < 0)
  {
    if (!*((_QWORD *)this + 1))
      goto LABEL_5;
  }
  else if (!*((_BYTE *)this + 23))
  {
LABEL_5:
    if (*((char *)this + 47) < 0)
    {
      if (*((_QWORD *)this + 4))
        goto LABEL_7;
    }
    else if (*((_BYTE *)this + 47))
    {
      goto LABEL_7;
    }
    *(_DWORD *)a2 = 0;
    *(_BYTE *)(a2 + 38) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 29) = 0;
    return;
  }
LABEL_7:
  v5 = this;
  if ((v4 & 0x80) != 0)
  {
    v4 = *((_QWORD *)this + 1);
    if (v4 < 0)
      goto LABEL_169;
    v5 = *(cricket::IceParameters **)this;
    if (v4)
    {
      if (!v5)
        goto LABEL_169;
    }
  }
  if ((unint64_t)(v4 - 257) <= 0xFFFFFFFFFFFFFF02)
  {
    v6 = (char *)operator new(0x30uLL);
    if (v6 <= "ICE ufrag must be between " && v6 + 26 > "ICE ufrag must be between ")
      goto LABEL_169;
    strcpy(v6, "ICE ufrag must be between ");
    *(_QWORD *)__p = v6;
    *(_OWORD *)&__p[8] = xmmword_208F1C940;
    v7 = rtc::StringBuilder::operator<<((std::string *)__p, 4);
    v8 = v7;
    v9 = SHIBYTE(v7->__r_.__value_.__r.__words[2]);
    if (v9 >= 0)
      v10 = 22;
    else
      v10 = (v7->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 >= 0)
      size = HIBYTE(v7->__r_.__value_.__r.__words[2]);
    else
      size = v7->__r_.__value_.__l.__size_;
    if (v10 - size >= 5)
    {
      if (v9 >= 0)
        v22 = v7;
      else
        v22 = (std::string *)v7->__r_.__value_.__r.__words[0];
      v23 = (std::string::size_type)v22 + size;
      if ((char *)v22 + size <= " and " && v23 + 5 > (unint64_t)" and ")
        goto LABEL_169;
      *(_BYTE *)(v23 + 4) = 32;
      *(_DWORD *)v23 = 1684955424;
      v24 = size + 5;
      if (SHIBYTE(v7->__r_.__value_.__r.__words[2]) < 0)
        v7->__r_.__value_.__l.__size_ = v24;
      else
        *((_BYTE *)&v7->__r_.__value_.__s + 23) = v24 & 0x7F;
      v22->__r_.__value_.__s.__data_[v24] = 0;
    }
    else
    {
      std::string::__grow_by_and_replace(v7, v10, size - v10 + 5, size, size, 0, 5uLL, " and ");
    }
    v25 = rtc::StringBuilder::operator<<(v8, 256);
    v26 = SHIBYTE(v25->__r_.__value_.__r.__words[2]);
    if (v26 >= 0)
      v27 = 22;
    else
      v27 = (v25->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v26 >= 0)
      v28 = HIBYTE(v25->__r_.__value_.__r.__words[2]);
    else
      v28 = v25->__r_.__value_.__l.__size_;
    if (v27 - v28 >= 0x11)
    {
      if (v26 >= 0)
        v29 = v25;
      else
        v29 = (std::string *)v25->__r_.__value_.__r.__words[0];
      v30 = (std::string::size_type)v29 + v28;
      if ((char *)v29 + v28 <= " characters long." && v30 + 17 > (unint64_t)" characters long.")
        goto LABEL_169;
      *(_BYTE *)(v30 + 16) = 46;
      *(_OWORD *)v30 = *(_OWORD *)" characters long.";
      v31 = v28 + 17;
      if (SHIBYTE(v25->__r_.__value_.__r.__words[2]) < 0)
        v25->__r_.__value_.__l.__size_ = v31;
      else
        *((_BYTE *)&v25->__r_.__value_.__s + 23) = v31 & 0x7F;
      v29->__r_.__value_.__s.__data_[v31] = 0;
    }
    else
    {
      std::string::__grow_by_and_replace(v25, v27, v28 - v27 + 17, v28, v28, 0, 0x11uLL, " characters long.");
    }
    __src = *(std::string *)__p;
    memset(__p, 0, 24);
    v32 = HIBYTE(__src.__r_.__value_.__r.__words[2]);
    if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
    {
      v34 = __src.__r_.__value_.__l.__size_;
      if ((__src.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
        goto LABEL_169;
      p_src = (std::string *)__src.__r_.__value_.__r.__words[0];
      if (__src.__r_.__value_.__l.__size_)
      {
        if (!__src.__r_.__value_.__r.__words[0])
          goto LABEL_169;
      }
      v82 = 5;
      if (__src.__r_.__value_.__l.__size_ > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_170;
    }
    else
    {
      v82 = 5;
      p_src = &__src;
      v34 = HIBYTE(__src.__r_.__value_.__r.__words[2]);
    }
    if (v34 > 0x16)
    {
      v37 = (v34 & 0x7FFFFFFFFFFFFFF8) + 8;
      if ((v34 | 7) != 0x17)
        v37 = v34 | 7;
      v38 = v37 + 1;
      v35 = (std::string *)operator new(v37 + 1);
      v83[1] = (void *)v34;
      v83[2] = (void *)(v38 | 0x8000000000000000);
      v83[0] = v35;
      v36 = (std::string *)((char *)v35 + v34);
      if (v35 > p_src)
        goto LABEL_76;
    }
    else
    {
      v35 = (std::string *)v83;
      HIBYTE(v83[2]) = v34;
      v36 = (std::string *)((char *)v83 + v34);
      if (v83 > (void **)p_src)
        goto LABEL_76;
    }
    if (v36 > p_src)
      goto LABEL_169;
LABEL_76:
    if (v34)
      memmove(v35, p_src, v34);
    v36->__r_.__value_.__s.__data_[0] = 0;
    LODWORD(v83[3]) = 0;
    BYTE4(v83[3]) = 0;
    BYTE6(v83[3]) = 0;
    if (v32 < 0 && (operator delete(__src.__r_.__value_.__l.__data_), (__p[23] & 0x80000000) != 0))
    {
      operator delete(*(void **)__p);
      v39 = v82;
      if (v82)
        goto LABEL_121;
    }
    else
    {
      v39 = v82;
      if (v82)
        goto LABEL_121;
    }
LABEL_81:
    v40 = (unsigned __int8 *)v2 + 24;
    if (*((char *)v2 + 47) < 0)
    {
      v41 = *((_QWORD *)v2 + 4);
      if (v41 < 0)
        goto LABEL_169;
      v40 = *(unsigned __int8 **)v40;
      if (v41)
      {
        if (!v40)
          goto LABEL_169;
      }
    }
    else
    {
      v41 = *((unsigned __int8 *)v2 + 47);
    }
    if ((unint64_t)(v41 - 257) > 0xFFFFFFFFFFFFFF14)
    {
      do
      {
        v49 = *v40;
        if ((v49 - 35) > 0x3C || ((1 << (v49 - 35)) & 0x1000000004000401) == 0)
        {
          if ((v49 & 0xFFFFFFFB) != 0x2B && (absl::ascii_internal::kPropertyBits[v49] & 4) == 0)
          {
            *(_DWORD *)__p = 5;
            v78 = (char *)operator new(0x48uLL);
            *(_QWORD *)&__p[8] = v78;
            *(_OWORD *)&__p[16] = xmmword_208F0BC90;
            if (v78 > "ICE pwd must contain only alphanumeric characters, '+', and '/'."
              || v78 + 64 <= "ICE pwd must contain only alphanumeric characters, '+', and '/'.")
            {
              strcpy(v78, "ICE pwd must contain only alphanumeric characters, '+', and '/'.");
              *(_DWORD *)v81 = 0;
              v81[4] = 0;
              v76 = 5;
              v81[6] = 0;
              goto LABEL_165;
            }
LABEL_169:
            __break(1u);
LABEL_170:
            abort();
          }
        }
        else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        {
          rtc::webrtc_logging_impl::Log("\r\t\t\t\t", v51, v52, v53, v54, v55, v56, v57, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transport_description.cc");
        }
        ++v40;
        --v41;
      }
      while (v41);
      *(_DWORD *)__p = 0;
      v81[6] = 0;
      *(_DWORD *)a2 = 0;
      *(_BYTE *)(a2 + 38) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 24) = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 29) = 0;
      goto LABEL_166;
    }
    memset(&__src, 0, sizeof(__src));
    v42 = (char *)operator new(0x30uLL);
    if (v42 <= "ICE pwd must be between " && v42 + 24 > "ICE pwd must be between ")
      goto LABEL_169;
    strcpy(v42, "ICE pwd must be between ");
    __src.__r_.__value_.__r.__words[0] = (std::string::size_type)v42;
    *(_OWORD *)&__src.__r_.__value_.__r.__words[1] = xmmword_208F0B3A0;
    v43 = rtc::StringBuilder::operator<<(&__src, 22);
    v44 = v43;
    v45 = SHIBYTE(v43->__r_.__value_.__r.__words[2]);
    if (v45 >= 0)
      v46 = 22;
    else
      v46 = (v43->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v45 >= 0)
      v47 = HIBYTE(v43->__r_.__value_.__r.__words[2]);
    else
      v47 = v43->__r_.__value_.__l.__size_;
    if (v46 - v47 >= 5)
    {
      if (v45 >= 0)
        v58 = v43;
      else
        v58 = (std::string *)v43->__r_.__value_.__r.__words[0];
      v59 = (std::string::size_type)v58 + v47;
      if ((char *)v58 + v47 <= " and " && v59 + 5 > (unint64_t)" and ")
        goto LABEL_169;
      *(_BYTE *)(v59 + 4) = 32;
      *(_DWORD *)v59 = 1684955424;
      v60 = v47 + 5;
      if (SHIBYTE(v43->__r_.__value_.__r.__words[2]) < 0)
        v43->__r_.__value_.__l.__size_ = v60;
      else
        *((_BYTE *)&v43->__r_.__value_.__s + 23) = v60 & 0x7F;
      v58->__r_.__value_.__s.__data_[v60] = 0;
    }
    else
    {
      std::string::__grow_by_and_replace(v43, v46, v47 - v46 + 5, v47, v47, 0, 5uLL, " and ");
    }
    v62 = rtc::StringBuilder::operator<<(v44, 256);
    v63 = SHIBYTE(v62->__r_.__value_.__r.__words[2]);
    if (v63 >= 0)
      v64 = 22;
    else
      v64 = (v62->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v63 >= 0)
      v65 = HIBYTE(v62->__r_.__value_.__r.__words[2]);
    else
      v65 = v62->__r_.__value_.__l.__size_;
    if (v64 - v65 >= 0x11)
    {
      if (v63 >= 0)
        v66 = v62;
      else
        v66 = (std::string *)v62->__r_.__value_.__r.__words[0];
      v67 = (std::string::size_type)v66 + v65;
      if ((char *)v66 + v65 <= " characters long." && v67 + 17 > (unint64_t)" characters long.")
        goto LABEL_169;
      *(_BYTE *)(v67 + 16) = 46;
      *(_OWORD *)v67 = *(_OWORD *)" characters long.";
      v68 = v65 + 17;
      if (SHIBYTE(v62->__r_.__value_.__r.__words[2]) < 0)
        v62->__r_.__value_.__l.__size_ = v68;
      else
        *((_BYTE *)&v62->__r_.__value_.__s + 23) = v68 & 0x7F;
      v66->__r_.__value_.__s.__data_[v68] = 0;
    }
    else
    {
      std::string::__grow_by_and_replace(v62, v64, v65 - v64 + 17, v65, v65, 0, 0x11uLL, " characters long.");
    }
    v84 = __src;
    memset(&__src, 0, sizeof(__src));
    v69 = HIBYTE(v84.__r_.__value_.__r.__words[2]);
    if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0)
    {
      v71 = v84.__r_.__value_.__l.__size_;
      if ((v84.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
        goto LABEL_169;
      v70 = (std::string *)v84.__r_.__value_.__r.__words[0];
      if (v84.__r_.__value_.__l.__size_)
      {
        if (!v84.__r_.__value_.__r.__words[0])
          goto LABEL_169;
      }
      *(_DWORD *)__p = 5;
      if (v84.__r_.__value_.__l.__size_ > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_170;
    }
    else
    {
      *(_DWORD *)__p = 5;
      v70 = &v84;
      v71 = HIBYTE(v84.__r_.__value_.__r.__words[2]);
    }
    if (v71 > 0x16)
    {
      v74 = (v71 & 0x7FFFFFFFFFFFFFF8) + 8;
      if ((v71 | 7) != 0x17)
        v74 = v71 | 7;
      v75 = v74 + 1;
      v72 = (std::string *)operator new(v74 + 1);
      *(_QWORD *)&__p[16] = v71;
      *(_QWORD *)&__p[24] = v75 | 0x8000000000000000;
      *(_QWORD *)&__p[8] = v72;
      v73 = (std::string *)((char *)v72 + v71);
      if (v72 > v70)
      {
LABEL_154:
        if (v71)
          memmove(v72, v70, v71);
        v73->__r_.__value_.__s.__data_[0] = 0;
        *(_DWORD *)v81 = 0;
        v81[4] = 0;
        v81[6] = 0;
        if (v69 < 0)
        {
          operator delete(v84.__r_.__value_.__l.__data_);
          if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__src.__r_.__value_.__l.__data_);
        }
        v76 = *(_DWORD *)__p;
        if (*(_DWORD *)__p)
        {
LABEL_165:
          *(_DWORD *)a2 = v76;
          *(_OWORD *)(a2 + 8) = *(_OWORD *)&__p[8];
          *(_QWORD *)(a2 + 24) = *(_QWORD *)&__p[24];
          *(_DWORD *)(a2 + 32) = *(_DWORD *)v81;
          *(_DWORD *)(a2 + 35) = *(_DWORD *)&v81[3];
        }
        else
        {
          v77 = __p[31];
          *(_DWORD *)a2 = 0;
          *(_BYTE *)(a2 + 38) = 0;
          *(_QWORD *)(a2 + 16) = 0;
          *(_QWORD *)(a2 + 24) = 0;
          *(_QWORD *)(a2 + 8) = 0;
          *(_QWORD *)(a2 + 29) = 0;
          if (v77 < 0)
            operator delete(*(void **)&__p[8]);
        }
LABEL_166:
        if (SHIBYTE(v83[2]) < 0)
          operator delete(v83[0]);
        return;
      }
    }
    else
    {
      v72 = (std::string *)&__p[8];
      __p[31] = v71;
      v73 = (std::string *)&__p[v71 + 8];
      if (&__p[8] > (_BYTE *)v70)
        goto LABEL_154;
    }
    if (v73 > v70)
      goto LABEL_169;
    goto LABEL_154;
  }
  while (1)
  {
    v13 = *(unsigned __int8 *)v5;
    if ((v13 - 35) <= 0x3C && ((1 << (v13 - 35)) & 0x1000000004000401) != 0)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t\t\t\t", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transport_description.cc");
      goto LABEL_27;
    }
    if ((v13 & 0xFFFFFFFB) != 0x2B && (absl::ascii_internal::kPropertyBits[v13] & 4) == 0)
      break;
LABEL_27:
    v5 = (cricket::IceParameters *)((char *)v5 + 1);
    if (!--v4)
    {
      v82 = 0;
      BYTE6(v83[3]) = 0;
      memset(v83, 0, 29);
      v2 = this;
      goto LABEL_81;
    }
  }
  v61 = (char *)operator new(0x48uLL);
  v83[0] = v61;
  *(_OWORD *)&v83[1] = xmmword_208F1C930;
  if (v61 <= "ICE ufrag must contain only alphanumeric characters, '+', and '/'."
    && v61 + 66 > "ICE ufrag must contain only alphanumeric characters, '+', and '/'.")
  {
    goto LABEL_169;
  }
  strcpy(v61, "ICE ufrag must contain only alphanumeric characters, '+', and '/'.");
  LODWORD(v83[3]) = 0;
  BYTE4(v83[3]) = 0;
  v39 = 5;
  BYTE6(v83[3]) = 0;
LABEL_121:
  *(_DWORD *)a2 = v39;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)v83;
  *(void **)(a2 + 24) = v83[2];
  *(_DWORD *)(a2 + 32) = v83[3];
  *(_DWORD *)(a2 + 35) = *(_DWORD *)((char *)&v83[3] + 3);
}

uint64_t cricket::StringToConnectionRole(char *a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  char v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  char v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;

  switch(a2)
  {
    case 8:
      v9 = *a1;
      if (v9 == 104)
        goto LABEL_57;
      if ((v9 - 65) < 0x1A)
        LOBYTE(v9) = v9 + 32;
      if (v9 == 104)
      {
LABEL_57:
        v10 = a1[1];
        if (v10 == 111)
          goto LABEL_127;
        if ((v10 - 65) < 0x1A)
          LOBYTE(v10) = v10 + 32;
        if (v10 == 111)
        {
LABEL_127:
          v11 = a1[2];
          if (v11 == 108)
            goto LABEL_128;
          if ((v11 - 65) < 0x1A)
            LOBYTE(v11) = v11 + 32;
          if (v11 == 108)
          {
LABEL_128:
            v12 = a1[3];
            if (v12 == 100)
              goto LABEL_129;
            if ((v12 - 65) < 0x1A)
              LOBYTE(v12) = v12 + 32;
            if (v12 == 100)
            {
LABEL_129:
              v13 = a1[4];
              if (v13 == 99)
                goto LABEL_130;
              if ((v13 - 65) < 0x1A)
                LOBYTE(v13) = v13 + 32;
              if (v13 == 99)
              {
LABEL_130:
                v14 = a1[5];
                if (v14 == 111)
                  goto LABEL_131;
                if ((v14 - 65) < 0x1A)
                  LOBYTE(v14) = v14 + 32;
                if (v14 == 111)
                {
LABEL_131:
                  v15 = a1[6];
                  if (v15 == 110)
                    goto LABEL_132;
                  if ((v15 - 65) < 0x1A)
                    LOBYTE(v15) = v15 + 32;
                  if (v15 == 110)
                  {
LABEL_132:
                    v16 = a1[7];
                    if (v16 == 110)
                      return 0x100000004;
                    if ((v16 - 65) < 0x1A)
                      LOBYTE(v16) = v16 + 32;
                    if (v16 == 110)
                      return 0x100000004;
                  }
                }
              }
            }
          }
        }
      }
      break;
    case 7:
      v17 = *a1;
      if (v17 == 112 || ((v17 - 65) >= 0x1A ? (v18 = *a1) : (v18 = v17 + 32), v18 == 112))
      {
        v19 = a1[1];
        if (v19 == 97)
          goto LABEL_68;
        if ((v19 - 65) < 0x1A)
          LOBYTE(v19) = v19 + 32;
        if (v19 == 97)
        {
LABEL_68:
          v20 = a1[2];
          if (v20 == 115)
            goto LABEL_87;
          if ((v20 - 65) < 0x1A)
            LOBYTE(v20) = v20 + 32;
          if (v20 == 115)
          {
LABEL_87:
            v21 = a1[3];
            if (v21 == 115)
              goto LABEL_133;
            if ((v21 - 65) < 0x1A)
              LOBYTE(v21) = v21 + 32;
            if (v21 == 115)
            {
LABEL_133:
              v22 = a1[4];
              if (v22 == 105)
                goto LABEL_134;
              if ((v22 - 65) < 0x1A)
                LOBYTE(v22) = v22 + 32;
              if (v22 == 105)
              {
LABEL_134:
                v23 = a1[5];
                if (v23 == 118)
                  goto LABEL_135;
                if ((v23 - 65) < 0x1A)
                  LOBYTE(v23) = v23 + 32;
                if (v23 == 118)
                {
LABEL_135:
                  v24 = a1[6];
                  if (v24 == 101)
                    return 0x100000002;
                  if ((v24 - 65) < 0x1A)
                    LOBYTE(v24) = v24 + 32;
                  if (v24 == 101)
                    return 0x100000002;
                }
              }
            }
          }
        }
      }
      if (v17 == 97 || ((v17 - 65) >= 0x1A ? (v25 = *a1) : (v25 = v17 + 32), v25 == 97))
      {
        v26 = a1[1];
        if (v26 == 99)
          goto LABEL_98;
        if ((v26 - 65) < 0x1A)
          LOBYTE(v26) = v26 + 32;
        if (v26 == 99)
        {
LABEL_98:
          v27 = a1[2];
          if (v27 == 116)
            goto LABEL_113;
          if ((v27 - 65) < 0x1A)
            LOBYTE(v27) = v27 + 32;
          if (v27 == 116)
          {
LABEL_113:
            v28 = a1[3];
            if (v28 == 112)
              goto LABEL_136;
            if ((v28 - 65) < 0x1A)
              LOBYTE(v28) = v28 + 32;
            if (v28 == 112)
            {
LABEL_136:
              v29 = a1[4];
              if (v29 == 97)
                goto LABEL_137;
              if ((v29 - 65) < 0x1A)
                LOBYTE(v29) = v29 + 32;
              if (v29 == 97)
              {
LABEL_137:
                v30 = a1[5];
                if (v30 == 115)
                  goto LABEL_114;
                if ((v30 - 65) < 0x1A)
                  LOBYTE(v30) = v30 + 32;
                if (v30 == 115)
                {
LABEL_114:
                  v31 = a1[6];
                  if (v31 == 115)
                    return 0x100000003;
                  if ((v31 - 65) < 0x1A)
                    LOBYTE(v31) = v31 + 32;
                  if (v31 == 115)
                    return 0x100000003;
                }
              }
            }
          }
        }
      }
      break;
    case 6:
      v2 = *a1;
      if (v2 == 97)
        goto LABEL_8;
      if ((v2 - 65) < 0x1A)
        LOBYTE(v2) = v2 + 32;
      if (v2 == 97)
      {
LABEL_8:
        v3 = a1[1];
        if (v3 == 99)
          goto LABEL_23;
        if ((v3 - 65) < 0x1A)
          LOBYTE(v3) = v3 + 32;
        if (v3 == 99)
        {
LABEL_23:
          v4 = a1[2];
          if (v4 == 116)
            goto LABEL_138;
          if ((v4 - 65) < 0x1A)
            LOBYTE(v4) = v4 + 32;
          if (v4 == 116)
          {
LABEL_138:
            v5 = a1[3];
            if (v5 == 105)
              goto LABEL_139;
            if ((v5 - 65) < 0x1A)
              LOBYTE(v5) = v5 + 32;
            if (v5 == 105)
            {
LABEL_139:
              v6 = a1[4];
              if (v6 == 118)
                goto LABEL_24;
              if ((v6 - 65) < 0x1A)
                LOBYTE(v6) = v6 + 32;
              if (v6 == 118)
              {
LABEL_24:
                v7 = a1[5];
                if (v7 == 101)
                  return 0x100000001;
                if ((v7 - 65) < 0x1A)
                  LOBYTE(v7) = v7 + 32;
                if (v7 == 101)
                  return 0x100000001;
              }
            }
          }
        }
      }
      break;
  }
  return 0;
}

uint64_t cricket::ConnectionRoleToString(_DWORD *a1, uint64_t *a2)
{
  uint64_t result;
  const char *v3;

  switch(*a1)
  {
    case 1:
      if (*((char *)a2 + 23) < 0)
      {
        a2[1] = 6;
        a2 = (uint64_t *)*a2;
      }
      else
      {
        *((_BYTE *)a2 + 23) = 6;
      }
      strcpy((char *)a2, "active");
      result = 1;
      break;
    case 2:
      if (*((char *)a2 + 23) < 0)
      {
        a2[1] = 7;
        a2 = (uint64_t *)*a2;
      }
      else
      {
        *((_BYTE *)a2 + 23) = 7;
      }
      v3 = "passive";
      goto LABEL_17;
    case 3:
      if (*((char *)a2 + 23) < 0)
      {
        a2[1] = 7;
        a2 = (uint64_t *)*a2;
      }
      else
      {
        *((_BYTE *)a2 + 23) = 7;
      }
      v3 = "actpass";
LABEL_17:
      *(_DWORD *)a2 = *(_DWORD *)v3;
      *(_DWORD *)((char *)a2 + 3) = *(_DWORD *)(v3 + 3);
      *((_BYTE *)a2 + 7) = 0;
      result = 1;
      break;
    case 4:
      if (*((char *)a2 + 23) < 0)
      {
        a2[1] = 8;
        a2 = (uint64_t *)*a2;
      }
      else
      {
        *((_BYTE *)a2 + 23) = 8;
      }
      strcpy((char *)a2, "holdconn");
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t cricket::TransportDescription::TransportDescription(uint64_t a1, uint64_t *a2, unint64_t a3, size_t __len, char *__src, size_t a6, int a7, int a8, uint64_t a9)
{
  int v9;
  int v10;
  char *v12;
  uint64_t v15;
  uint64_t v16;
  int64_t v17;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  __int128 *v23;
  std::string *v24;
  __int128 v25;
  char *v26;
  char *v27;
  char *v28;
  size_t v29;
  size_t v30;
  char *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  std::string *v35;
  std::string *v36;
  std::string::size_type v37;
  unsigned int *v38;
  unsigned int v39;

  v9 = a8;
  v10 = a7;
  v12 = __src;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v15 = *a2;
  v16 = a2[1];
  v17 = v16 - *a2;
  if (v16 != *a2)
  {
    v20 = 0xAAAAAAAAAAAAAAABLL * (v17 >> 3);
    if (v20 >= 0xAAAAAAAAAAAAAABLL)
      goto LABEL_39;
    v21 = (char *)operator new(v17);
    v22 = 0;
    *(_QWORD *)a1 = v21;
    *(_QWORD *)(a1 + 8) = v21;
    *(_QWORD *)(a1 + 16) = &v21[24 * v20];
    v9 = a8;
    v10 = a7;
    v12 = __src;
    do
    {
      while (1)
      {
        v23 = (__int128 *)(v15 + v22);
        v24 = (std::string *)&v21[v22];
        if ((*(char *)(v15 + v22 + 23) & 0x80000000) == 0)
          break;
        std::string::__init_copy_ctor_external(v24, *(const std::string::value_type **)v23, *((_QWORD *)v23 + 1));
        v22 += 24;
        if (v15 + v22 == v16)
          goto LABEL_7;
      }
      v25 = *v23;
      v24->__r_.__value_.__r.__words[2] = *((_QWORD *)v23 + 2);
      *(_OWORD *)&v24->__r_.__value_.__l.__data_ = v25;
      v22 += 24;
    }
    while (v15 + v22 != v16);
LABEL_7:
    *(_QWORD *)(a1 + 8) = &v21[v22];
  }
  if (__len > 0x7FFFFFFFFFFFFFF7)
LABEL_39:
    abort();
  if (__len > 0x16)
  {
    v29 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v29 = __len | 7;
    v30 = v29 + 1;
    v26 = (char *)operator new(v29 + 1);
    *(_QWORD *)(a1 + 32) = __len;
    *(_QWORD *)(a1 + 40) = v30 | 0x8000000000000000;
    *(_QWORD *)(a1 + 24) = v26;
    v27 = (char *)a3;
    v28 = &v26[__len];
    if ((unint64_t)v26 > a3)
      goto LABEL_16;
  }
  else
  {
    v26 = (char *)(a1 + 24);
    *(_BYTE *)(a1 + 47) = __len;
    v27 = (char *)a3;
    v28 = (char *)(a1 + 24 + __len);
    if (a1 + 24 > a3)
      goto LABEL_16;
  }
  if (v28 > v27)
  {
LABEL_38:
    __break(1u);
    goto LABEL_39;
  }
LABEL_16:
  if (__len)
    memmove(v26, v27, __len);
  *v28 = 0;
  if (a6 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_39;
  if (a6 <= 0x16)
  {
    v31 = (char *)(a1 + 48);
    *(_BYTE *)(a1 + 71) = a6;
    v32 = (char *)(a1 + 48 + a6);
    if (a1 + 48 > (unint64_t)v12)
      goto LABEL_26;
    goto LABEL_25;
  }
  v33 = (a6 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((a6 | 7) != 0x17)
    v33 = a6 | 7;
  v34 = v33 + 1;
  v31 = (char *)operator new(v33 + 1);
  *(_QWORD *)(a1 + 56) = a6;
  *(_QWORD *)(a1 + 64) = v34 | 0x8000000000000000;
  *(_QWORD *)(a1 + 48) = v31;
  v32 = &v31[a6];
  if (v31 <= v12)
  {
LABEL_25:
    if (v32 <= v12)
      goto LABEL_26;
    goto LABEL_38;
  }
LABEL_26:
  if (a6)
    memmove(v31, v12, a6);
  *v32 = 0;
  *(_DWORD *)(a1 + 72) = v10;
  *(_DWORD *)(a1 + 76) = v9;
  if (a9)
  {
    v35 = (std::string *)operator new();
    v36 = v35;
    if (*(char *)(a9 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v35, *(const std::string::value_type **)a9, *(_QWORD *)(a9 + 8));
      v37 = *(_QWORD *)(a9 + 24);
      v36[1].__r_.__value_.__r.__words[0] = v37;
      if (!v37)
      {
LABEL_36:
        *(_OWORD *)&v36[1].__r_.__value_.__r.__words[1] = *(_OWORD *)(a9 + 32);
        goto LABEL_37;
      }
    }
    else
    {
      *(_OWORD *)&v35->__r_.__value_.__l.__data_ = *(_OWORD *)a9;
      v37 = *(_QWORD *)(a9 + 24);
      v35->__r_.__value_.__r.__words[2] = *(_QWORD *)(a9 + 16);
      v35[1].__r_.__value_.__r.__words[0] = v37;
      if (!v37)
        goto LABEL_36;
    }
    v38 = (unsigned int *)(v37 + 24);
    do
      v39 = __ldxr(v38);
    while (__stxr(v39 + 1, v38));
    goto LABEL_36;
  }
  v36 = 0;
LABEL_37:
  *(_QWORD *)(a1 + 80) = v36;
  return a1;
}

uint64_t cricket::TransportDescription::TransportDescription(uint64_t a1, char *__src, size_t __len, char *a4, size_t a5)
{
  char *v10;
  size_t v11;
  size_t v12;
  char *v13;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  if (__len > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_25;
  if (__len > 0x16)
  {
    v11 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v11 = __len | 7;
    v12 = v11 + 1;
    v10 = (char *)operator new(v11 + 1);
    *(_QWORD *)(a1 + 32) = __len;
    *(_QWORD *)(a1 + 40) = v12 | 0x8000000000000000;
    *(_QWORD *)(a1 + 24) = v10;
  }
  else
  {
    v10 = (char *)(a1 + 24);
    *(_BYTE *)(a1 + 47) = __len;
  }
  v13 = &v10[__len];
  if (v10 <= __src && v13 > __src)
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }
  if (__len)
    memmove(v10, __src, __len);
  *v13 = 0;
  if (a5 > 0x7FFFFFFFFFFFFFF7)
LABEL_25:
    abort();
  if (a5 <= 0x16)
  {
    v15 = (char *)(a1 + 48);
    *(_BYTE *)(a1 + 71) = a5;
    v16 = (char *)(a1 + 48 + a5);
    if (a1 + 48 > (unint64_t)a4)
      goto LABEL_21;
    goto LABEL_20;
  }
  v17 = (a5 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((a5 | 7) != 0x17)
    v17 = a5 | 7;
  v18 = v17 + 1;
  v15 = (char *)operator new(v17 + 1);
  *(_QWORD *)(a1 + 56) = a5;
  *(_QWORD *)(a1 + 64) = v18 | 0x8000000000000000;
  *(_QWORD *)(a1 + 48) = v15;
  v16 = &v15[a5];
  if (v15 <= a4)
  {
LABEL_20:
    if (v16 <= a4)
      goto LABEL_21;
    goto LABEL_24;
  }
LABEL_21:
  if (a5)
    memmove(v15, a4, a5);
  *v16 = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  return a1;
}

cricket::TransportDescription *cricket::TransportDescription::TransportDescription(cricket::TransportDescription *this, const cricket::TransportDescription *a2)
{
  uint64_t v4;
  uint64_t v5;
  int64_t v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  __int128 *v10;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  __int128 v14;
  std::string *v15;
  __int128 v16;
  __int128 *v17;
  std::string *v18;
  std::string *v19;
  __int128 v20;
  std::string::size_type v21;
  unsigned int *v22;
  unsigned int v23;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v4 = *(_QWORD *)a2;
  v5 = *((_QWORD *)a2 + 1);
  v6 = v5 - *(_QWORD *)a2;
  if (v5 != *(_QWORD *)a2)
  {
    v7 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 3);
    if (v7 >= 0xAAAAAAAAAAAAAABLL)
      abort();
    v8 = (char *)operator new(v6);
    v9 = 0;
    *(_QWORD *)this = v8;
    *((_QWORD *)this + 1) = v8;
    *((_QWORD *)this + 2) = &v8[24 * v7];
    do
    {
      while (1)
      {
        v10 = (__int128 *)(v4 + v9);
        v11 = (std::string *)&v8[v9];
        if ((*(char *)(v4 + v9 + 23) & 0x80000000) == 0)
          break;
        std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
        v9 += 24;
        if (v4 + v9 == v5)
          goto LABEL_7;
      }
      v12 = *v10;
      v11->__r_.__value_.__r.__words[2] = *((_QWORD *)v10 + 2);
      *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
      v9 += 24;
    }
    while (v4 + v9 != v5);
LABEL_7:
    *((_QWORD *)this + 1) = &v8[v9];
  }
  v13 = (std::string *)((char *)this + 24);
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v13, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
    v15 = (std::string *)((char *)this + 48);
    if ((*((char *)a2 + 71) & 0x80000000) == 0)
    {
LABEL_10:
      v16 = *((_OWORD *)a2 + 3);
      v15->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 8);
      *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v16;
      *((_QWORD *)this + 9) = *((_QWORD *)a2 + 9);
      v17 = (__int128 *)*((_QWORD *)a2 + 10);
      if (v17)
        goto LABEL_11;
      goto LABEL_16;
    }
  }
  else
  {
    v14 = *(_OWORD *)((char *)a2 + 24);
    *((_QWORD *)this + 5) = *((_QWORD *)a2 + 5);
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
    v15 = (std::string *)((char *)this + 48);
    if ((*((char *)a2 + 71) & 0x80000000) == 0)
      goto LABEL_10;
  }
  std::string::__init_copy_ctor_external(v15, *((const std::string::value_type **)a2 + 6), *((_QWORD *)a2 + 7));
  *((_QWORD *)this + 9) = *((_QWORD *)a2 + 9);
  v17 = (__int128 *)*((_QWORD *)a2 + 10);
  if (v17)
  {
LABEL_11:
    v18 = (std::string *)operator new();
    v19 = v18;
    if (*((char *)v17 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v18, *(const std::string::value_type **)v17, *((_QWORD *)v17 + 1));
      v21 = *((_QWORD *)v17 + 3);
      v19[1].__r_.__value_.__r.__words[0] = v21;
      if (!v21)
      {
LABEL_20:
        *(_OWORD *)&v19[1].__r_.__value_.__r.__words[1] = v17[2];
        goto LABEL_21;
      }
    }
    else
    {
      v20 = *v17;
      v18->__r_.__value_.__r.__words[2] = *((_QWORD *)v17 + 2);
      *(_OWORD *)&v18->__r_.__value_.__l.__data_ = v20;
      v21 = *((_QWORD *)v17 + 3);
      v18[1].__r_.__value_.__r.__words[0] = v21;
      if (!v21)
        goto LABEL_20;
    }
    v22 = (unsigned int *)(v21 + 24);
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
    goto LABEL_20;
  }
LABEL_16:
  v19 = 0;
LABEL_21:
  *((_QWORD *)this + 10) = v19;
  return this;
}

void cricket::TransportDescription::~TransportDescription(cricket::TransportDescription *this)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  void **v8;
  void **v9;
  void **v10;

  v2 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 24);
    if (v3)
    {
      v4 = (unsigned int *)(v3 + 24);
      do
      {
        v5 = __ldaxr(v4);
        v6 = v5 - 1;
      }
      while (__stlxr(v6, v4));
      if (!v6)
      {
        v7 = *(_QWORD *)(v3 + 16);
        *(_QWORD *)(v3 + 16) = 0;
        if (v7)
          MEMORY[0x20BD0ADD4](v7, 0x1000C8077774924);
        MEMORY[0x20BD0ADEC](v3, 0x1010C40EE34DA14);
      }
    }
    if (*(char *)(v2 + 23) < 0)
      operator delete(*(void **)v2);
    MEMORY[0x20BD0ADEC](v2, 0x1032C40CD05A1E1);
  }
  if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    if ((*((char *)this + 47) & 0x80000000) == 0)
      goto LABEL_14;
LABEL_17:
    operator delete(*((void **)this + 3));
    v8 = *(void ***)this;
    if (!*(_QWORD *)this)
      return;
    goto LABEL_18;
  }
  operator delete(*((void **)this + 6));
  if (*((char *)this + 47) < 0)
    goto LABEL_17;
LABEL_14:
  v8 = *(void ***)this;
  if (!*(_QWORD *)this)
    return;
LABEL_18:
  v9 = (void **)*((_QWORD *)this + 1);
  v10 = v8;
  if (v9 != v8)
  {
    do
    {
      if (*((char *)v9 - 1) < 0)
        operator delete(*(v9 - 3));
      v9 -= 3;
    }
    while (v9 != v8);
    v10 = *(void ***)this;
  }
  *((_QWORD *)this + 1) = v8;
  operator delete(v10);
}

void cricket::TransportDescriptionFactory::CreateOffer(uint64_t a1@<X0>, _BYTE *a2@<X1>, uint64_t a3@<X2>, cricket::IceCredentialsIterator *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  std::string *v13;
  uint64_t v14;
  std::string *v15;
  std::string *v16;
  size_t v17;
  std::string *v18;
  size_t size;
  const std::string::value_type *p_p;
  size_t v21;
  char v22;
  const std::string::value_type *v23;
  size_t v24;
  char *v25;
  char *v26;
  rtc::SSLFingerprint *v27;
  std::string v28;
  __int128 __p;
  std::string::size_type v30;

  v10 = operator new();
  v11 = v10;
  *(_OWORD *)v10 = 0u;
  *(_OWORD *)(v10 + 16) = 0u;
  *(_OWORD *)(v10 + 32) = 0u;
  *(_OWORD *)(v10 + 48) = 0u;
  *(_OWORD *)(v10 + 64) = 0u;
  *(_QWORD *)(v10 + 80) = 0;
  if (!a3 || *a2)
  {
    cricket::IceCredentialsIterator::GetIceCredentials(a4, &v28);
    v15 = (std::string *)(v11 + 24);
    if (*(char *)(v11 + 47) < 0)
    {
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v18 = &v28;
      else
        v18 = (std::string *)v28.__r_.__value_.__r.__words[0];
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
      else
        size = v28.__r_.__value_.__l.__size_;
      std::string::__assign_no_alias<false>(v15, (const std::string::value_type *)v18, size);
      v16 = (std::string *)(v11 + 48);
      v17 = HIBYTE(v30);
      if (*(char *)(v11 + 71) < 0)
        goto LABEL_19;
    }
    else
    {
      if ((*((_BYTE *)&v28.__r_.__value_.__s + 23) & 0x80) == 0)
      {
        *(_OWORD *)&v15->__r_.__value_.__l.__data_ = *(_OWORD *)&v28.__r_.__value_.__l.__data_;
        *(_QWORD *)(v11 + 40) = *((_QWORD *)&v28.__r_.__value_.__l + 2);
        v16 = (std::string *)(v11 + 48);
        v17 = HIBYTE(v30);
        if ((*(char *)(v11 + 71) & 0x80000000) == 0)
          goto LABEL_10;
LABEL_19:
        if ((v17 & 0x80u) == 0)
          p_p = (const std::string::value_type *)&__p;
        else
          p_p = (const std::string::value_type *)__p;
        if ((v17 & 0x80u) == 0)
          v21 = v17;
        else
          v21 = *((_QWORD *)&__p + 1);
        std::string::__assign_no_alias<false>(v16, p_p, v21);
        if (SHIBYTE(v30) < 0)
LABEL_26:
          operator delete((void *)__p);
LABEL_27:
        if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v28.__r_.__value_.__l.__data_);
        goto LABEL_44;
      }
      std::string::__assign_no_alias<true>(v15, v28.__r_.__value_.__l.__data_, v28.__r_.__value_.__l.__size_);
      v16 = (std::string *)(v11 + 48);
      v17 = HIBYTE(v30);
      if (*(char *)(v11 + 71) < 0)
        goto LABEL_19;
    }
LABEL_10:
    if ((v17 & 0x80) == 0)
    {
      *(_OWORD *)&v16->__r_.__value_.__l.__data_ = __p;
      v16->__r_.__value_.__r.__words[2] = v30;
      goto LABEL_27;
    }
    std::string::__assign_no_alias<true>(v16, (char *)__p, *((size_t *)&__p + 1));
    if (SHIBYTE(v30) < 0)
      goto LABEL_26;
    goto LABEL_27;
  }
  if (v10 == a3)
    goto LABEL_44;
  v12 = (_QWORD *)(v10 + 24);
  if ((*(char *)(a3 + 47) & 0x80000000) == 0)
  {
    *(_OWORD *)v12 = *(_OWORD *)(a3 + 24);
    *(_QWORD *)(v11 + 40) = *(_QWORD *)(a3 + 40);
    v13 = (std::string *)(v11 + 48);
    if ((*(char *)(a3 + 71) & 0x80000000) == 0)
    {
      v14 = a3 + 48;
LABEL_31:
      *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)v14;
      v13->__r_.__value_.__r.__words[2] = *(_QWORD *)(v14 + 16);
      goto LABEL_44;
    }
    goto LABEL_36;
  }
  std::string::__assign_no_alias<true>(v12, *(char **)(a3 + 24), *(_QWORD *)(a3 + 32));
  v14 = a3 + 48;
  v13 = (std::string *)(v11 + 48);
  v22 = *(_BYTE *)(a3 + 71);
  if ((*(char *)(v11 + 71) & 0x80000000) == 0)
  {
    if ((*(_BYTE *)(a3 + 71) & 0x80) == 0)
      goto LABEL_31;
LABEL_36:
    std::string::__assign_no_alias<true>(v13, *(char **)(a3 + 48), *(_QWORD *)(a3 + 56));
    goto LABEL_44;
  }
  if (v22 >= 0)
    v23 = (const std::string::value_type *)(a3 + 48);
  else
    v23 = *(const std::string::value_type **)(a3 + 48);
  if (v22 >= 0)
    v24 = *(unsigned __int8 *)(a3 + 71);
  else
    v24 = *(_QWORD *)(a3 + 56);
  std::string::__assign_no_alias<false>(v13, v23, v24);
LABEL_44:
  v28.__r_.__value_.__r.__words[0] = (std::string::size_type)"trickle";
  v28.__r_.__value_.__l.__size_ = 7;
  v25 = *(char **)(v11 + 8);
  if ((unint64_t)v25 >= *(_QWORD *)(v11 + 16))
  {
    v26 = std::vector<std::string>::__emplace_back_slow_path<std::string_view &>((void **)v11, &v28.__r_.__value_.__l.__data_);
    *(_QWORD *)(v11 + 8) = v26;
    if (!a2[2])
    {
LABEL_49:
      if (*(_BYTE *)a1)
      {
LABEL_50:
        v27 = *(rtc::SSLFingerprint **)(a1 + 8);
        if (!v27 || cricket::TransportDescriptionFactory::SetSecurityInfo(v27, v11, 3))
          goto LABEL_52;
LABEL_62:
        *a5 = 0;
        cricket::TransportDescription::~TransportDescription((cricket::TransportDescription *)v11);
        MEMORY[0x20BD0ADEC]();
        return;
      }
LABEL_61:
      if (cricket::TransportDescriptionFactory::SetSecurityInfo(*(rtc::SSLFingerprint **)(a1 + 8), v11, 3))
      {
LABEL_52:
        *a5 = v11;
        return;
      }
      goto LABEL_62;
    }
  }
  else
  {
    if (!v25)
      goto LABEL_63;
    v25[23] = 7;
    if (v25 <= "trickle" && v25 + 7 > "trickle")
      goto LABEL_63;
    strcpy(v25, "trickle");
    v26 = v25 + 24;
    *(_QWORD *)(v11 + 8) = v25 + 24;
    if (!a2[2])
      goto LABEL_49;
  }
  v28.__r_.__value_.__r.__words[0] = (std::string::size_type)"renomination";
  v28.__r_.__value_.__l.__size_ = 12;
  if ((unint64_t)v26 >= *(_QWORD *)(v11 + 16))
  {
    *(_QWORD *)(v11 + 8) = std::vector<std::string>::__emplace_back_slow_path<std::string_view &>((void **)v11, &v28.__r_.__value_.__l.__data_);
    if (*(_BYTE *)a1)
      goto LABEL_50;
    goto LABEL_61;
  }
  if (v26)
  {
    v26[23] = 12;
    if (v26 > "renomination" || v26 + 12 <= "renomination")
    {
      strcpy(v26, "renomination");
      *(_QWORD *)(v11 + 8) = v26 + 24;
      if (*(_BYTE *)a1)
        goto LABEL_50;
      goto LABEL_61;
    }
  }
LABEL_63:
  __break(1u);
}

uint64_t cricket::TransportDescriptionFactory::SetSecurityInfo(rtc::SSLFingerprint *a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  if (a1)
  {
    rtc::SSLFingerprint::CreateFromCertificate(a1, (const rtc::RTCCertificate *)a2, &v26);
    v5 = v26;
    v26 = 0;
    v6 = *(_QWORD *)(a2 + 80);
    *(_QWORD *)(a2 + 80) = v5;
    if (v6)
    {
      v7 = *(_QWORD *)(v6 + 24);
      if (v7)
      {
        v8 = (unsigned int *)(v7 + 24);
        do
        {
          v9 = __ldaxr(v8);
          v10 = v9 - 1;
        }
        while (__stlxr(v10, v8));
        if (!v10)
        {
          v11 = *(_QWORD *)(v7 + 16);
          *(_QWORD *)(v7 + 16) = 0;
          if (v11)
            MEMORY[0x20BD0ADD4](v11, 0x1000C8077774924);
          MEMORY[0x20BD0ADEC](v7, 0x1010C40EE34DA14);
        }
      }
      if (*(char *)(v6 + 23) < 0)
        operator delete(*(void **)v6);
      MEMORY[0x20BD0ADEC](v6, 0x1032C40CD05A1E1);
      v12 = v26;
      v26 = 0;
      if (v12)
      {
        v13 = *(_QWORD *)(v12 + 24);
        if (v13)
        {
          v14 = (unsigned int *)(v13 + 24);
          do
          {
            v15 = __ldaxr(v14);
            v16 = v15 - 1;
          }
          while (__stlxr(v16, v14));
          if (!v16)
          {
            v17 = *(_QWORD *)(v13 + 16);
            *(_QWORD *)(v13 + 16) = 0;
            if (v17)
              MEMORY[0x20BD0ADD4](v17, 0x1000C8077774924);
            MEMORY[0x20BD0ADEC](v13, 0x1010C40EE34DA14);
          }
        }
        if (*(char *)(v12 + 23) < 0)
          operator delete(*(void **)v12);
        MEMORY[0x20BD0ADEC](v12, 0x1032C40CD05A1E1);
      }
      v5 = *(_QWORD *)(a2 + 80);
    }
    if (v5)
    {
      *(_DWORD *)(a2 + 76) = a3;
      return 1;
    }
    return 0;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
    return 0;
  rtc::webrtc_logging_impl::Log("\r\t", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transport_description_factory.cc");
  return 0;
}

void cricket::TransportDescriptionFactory::CreateAnswer(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, cricket::IceCredentialsIterator *a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  std::string *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  std::string *v30;
  std::string *v31;
  size_t v32;
  std::string *v33;
  size_t size;
  char v35;
  const std::string::value_type *p_p;
  size_t v37;
  const std::string::value_type *v38;
  size_t v39;
  char *v40;
  char *v41;
  rtc::SSLFingerprint *v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  std::string *v67;
  uint64_t v68;
  std::string v69;
  __int128 __p;
  std::string::size_type v71;

  if (a2)
  {
    v14 = operator new();
    v19 = v14;
    *(_OWORD *)v14 = 0u;
    *(_OWORD *)(v14 + 16) = 0u;
    *(_OWORD *)(v14 + 32) = 0u;
    *(_OWORD *)(v14 + 48) = 0u;
    *(_OWORD *)(v14 + 64) = 0u;
    *(_QWORD *)(v14 + 80) = 0;
    if (a5 && !*a3)
    {
      if (v14 == a5)
        goto LABEL_48;
      v20 = (_QWORD *)(v14 + 24);
      if ((*(char *)(a5 + 47) & 0x80000000) == 0)
      {
        *(_OWORD *)v20 = *(_OWORD *)(a5 + 24);
        *(_QWORD *)(v19 + 40) = *(_QWORD *)(a5 + 40);
        v21 = (std::string *)(v19 + 48);
        if ((*(char *)(a5 + 71) & 0x80000000) == 0)
        {
          v22 = a5 + 48;
LABEL_26:
          *(_OWORD *)&v21->__r_.__value_.__l.__data_ = *(_OWORD *)v22;
          v21->__r_.__value_.__r.__words[2] = *(_QWORD *)(v22 + 16);
          goto LABEL_48;
        }
        goto LABEL_40;
      }
      std::string::__assign_no_alias<true>(v20, *(char **)(a5 + 24), *(_QWORD *)(a5 + 32));
      v22 = a5 + 48;
      v21 = (std::string *)(v19 + 48);
      v35 = *(_BYTE *)(a5 + 71);
      if ((*(char *)(v19 + 71) & 0x80000000) == 0)
      {
        if ((*(_BYTE *)(a5 + 71) & 0x80) == 0)
          goto LABEL_26;
LABEL_40:
        std::string::__assign_no_alias<true>(v21, *(char **)(a5 + 48), *(_QWORD *)(a5 + 56));
        goto LABEL_48;
      }
      if (v35 >= 0)
        v38 = (const std::string::value_type *)(a5 + 48);
      else
        v38 = *(const std::string::value_type **)(a5 + 48);
      if (v35 >= 0)
        v39 = *(unsigned __int8 *)(a5 + 71);
      else
        v39 = *(_QWORD *)(a5 + 56);
      std::string::__assign_no_alias<false>(v21, v38, v39);
LABEL_48:
      v69.__r_.__value_.__r.__words[0] = (std::string::size_type)"trickle";
      v69.__r_.__value_.__l.__size_ = 7;
      v40 = *(char **)(v19 + 8);
      if ((unint64_t)v40 >= *(_QWORD *)(v19 + 16))
      {
        v41 = std::vector<std::string>::__emplace_back_slow_path<std::string_view &>((void **)v19, &v69.__r_.__value_.__l.__data_);
        *(_QWORD *)(v19 + 8) = v41;
        if (!a3[2])
        {
LABEL_53:
          v42 = *(rtc::SSLFingerprint **)(a1 + 8);
          if (!v42)
            goto LABEL_64;
          goto LABEL_63;
        }
      }
      else
      {
        if (!v40)
          goto LABEL_89;
        v40[23] = 7;
        if (v40 <= "trickle" && v40 + 7 > "trickle")
          goto LABEL_89;
        strcpy(v40, "trickle");
        v41 = v40 + 24;
        *(_QWORD *)(v19 + 8) = v40 + 24;
        if (!a3[2])
          goto LABEL_53;
      }
      v69.__r_.__value_.__r.__words[0] = (std::string::size_type)"renomination";
      v69.__r_.__value_.__l.__size_ = 12;
      if ((unint64_t)v41 >= *(_QWORD *)(v19 + 16))
      {
        *(_QWORD *)(v19 + 8) = std::vector<std::string>::__emplace_back_slow_path<std::string_view &>((void **)v19, &v69.__r_.__value_.__l.__data_);
        v42 = *(rtc::SSLFingerprint **)(a1 + 8);
        if (!v42)
          goto LABEL_64;
LABEL_63:
        if (*(_QWORD *)(a2 + 80))
          goto LABEL_67;
LABEL_64:
        if (!*(_BYTE *)a1)
        {
          if (*(_QWORD *)(a2 + 80))
          {
            if (v42)
            {
LABEL_67:
              v43 = 2;
              switch(*(_DWORD *)(a2 + 76))
              {
                case 0:
                  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
                    rtc::webrtc_logging_impl::Log("\r\t", v44, v45, v46, v47, v48, v49, v50, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transport_description_factory.cc");
                  if (a3[1])
                    v51 = 2;
                  else
                    v51 = 1;
                  if (!cricket::TransportDescriptionFactory::SetSecurityInfo(*(rtc::SSLFingerprint **)(a1 + 8), v19, v51))goto LABEL_88;
                  goto LABEL_79;
                case 1:
                  break;
                case 2:
                  v43 = 1;
                  break;
                case 3:
                  if (a3[1])
                    v59 = 2;
                  else
                    v59 = 1;
                  if (!cricket::TransportDescriptionFactory::SetSecurityInfo(v42, v19, v59))
                    goto LABEL_88;
                  goto LABEL_79;
                default:
                  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
                    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v52, v53, v54, v55, v56, v57, v58, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transport_description_factory.cc");
                  goto LABEL_88;
              }
              if (cricket::TransportDescriptionFactory::SetSecurityInfo(v42, v19, v43))
                goto LABEL_79;
              goto LABEL_88;
            }
            goto LABEL_90;
          }
          if (a4)
          {
            if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
              rtc::webrtc_logging_impl::Log("\r\t", v60, v61, v62, v63, v64, v65, v66, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transport_description_factory.cc");
LABEL_88:
            *a7 = 0;
            cricket::TransportDescription::~TransportDescription((cricket::TransportDescription *)v19);
            MEMORY[0x20BD0ADEC]();
            return;
          }
        }
LABEL_79:
        *a7 = v19;
        return;
      }
      if (v41)
      {
        v41[23] = 12;
        if (v41 > "renomination" || v41 + 12 <= "renomination")
        {
          strcpy(v41, "renomination");
          *(_QWORD *)(v19 + 8) = v41 + 24;
          v42 = *(rtc::SSLFingerprint **)(a1 + 8);
          if (!v42)
            goto LABEL_64;
          goto LABEL_63;
        }
      }
LABEL_89:
      __break(1u);
LABEL_90:
      v67 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transport_description_factory.cc", 110, "certificate_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v15, v16, v17, v18, v68);
      webrtc::rtcp::TransportFeedback::LastChunk::Emit((unsigned __int8 *)v67);
      return;
    }
    cricket::IceCredentialsIterator::GetIceCredentials(a6, &v69);
    v30 = (std::string *)(v19 + 24);
    if (*(char *)(v19 + 47) < 0)
    {
      if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v33 = &v69;
      else
        v33 = (std::string *)v69.__r_.__value_.__r.__words[0];
      if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v69.__r_.__value_.__r.__words[2]);
      else
        size = v69.__r_.__value_.__l.__size_;
      std::string::__assign_no_alias<false>(v30, (const std::string::value_type *)v33, size);
      v31 = (std::string *)(v19 + 48);
      v32 = HIBYTE(v71);
      if (*(char *)(v19 + 71) < 0)
      {
LABEL_28:
        if ((v32 & 0x80u) == 0)
          p_p = (const std::string::value_type *)&__p;
        else
          p_p = (const std::string::value_type *)__p;
        if ((v32 & 0x80u) == 0)
          v37 = v32;
        else
          v37 = *((_QWORD *)&__p + 1);
        std::string::__assign_no_alias<false>(v31, p_p, v37);
        if (SHIBYTE(v71) < 0)
LABEL_35:
          operator delete((void *)__p);
LABEL_36:
        if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v69.__r_.__value_.__l.__data_);
        goto LABEL_48;
      }
    }
    else if ((*((_BYTE *)&v69.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(v30, v69.__r_.__value_.__l.__data_, v69.__r_.__value_.__l.__size_);
      v31 = (std::string *)(v19 + 48);
      v32 = HIBYTE(v71);
      if (*(char *)(v19 + 71) < 0)
        goto LABEL_28;
    }
    else
    {
      *(_OWORD *)&v30->__r_.__value_.__l.__data_ = *(_OWORD *)&v69.__r_.__value_.__l.__data_;
      *(_QWORD *)(v19 + 40) = *((_QWORD *)&v69.__r_.__value_.__l + 2);
      v31 = (std::string *)(v19 + 48);
      v32 = HIBYTE(v71);
      if (*(char *)(v19 + 71) < 0)
        goto LABEL_28;
    }
    if ((v32 & 0x80) == 0)
    {
      *(_OWORD *)&v31->__r_.__value_.__l.__data_ = __p;
      v31->__r_.__value_.__r.__words[2] = v71;
      goto LABEL_36;
    }
    std::string::__assign_no_alias<true>(v31, (char *)__p, *((size_t *)&__p + 1));
    if (SHIBYTE(v71) < 0)
      goto LABEL_35;
    goto LABEL_36;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t", v23, v24, v25, v26, v27, v28, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/transport_description_factory.cc");
  *a7 = 0;
}

unsigned __int8 *webrtc::rtcp::TransportFeedback::LastChunk::Emit(unsigned __int8 *this)
{
  unsigned __int16 v1;
  uint64_t v2;
  __int16 v3;
  __int16 v4;
  int8x16_t v5;
  unint64_t v6;
  int v7;
  int v8;
  BOOL v9;
  char v10;
  int v11;
  BOOL v13;
  int v14;
  int v15;
  int v16;
  int v17;
  BOOL v18;
  char v19;

  if (this[24])
  {
    v1 = *((_WORD *)this + 8) | (*this << 13);
LABEL_5:
    *((_QWORD *)this + 2) = 0;
    *((_WORD *)this + 12) = 1;
    return (unsigned __int8 *)v1;
  }
  v2 = *((_QWORD *)this + 2);
  v3 = *this;
  v4 = this[1];
  if (v2 == 14)
  {
    v5 = (int8x16_t)vshlq_u16(vmovl_u8(*(uint8x8_t *)(this + 2)), (uint16x8_t)xmmword_208F1C960);
    *(int8x8_t *)v5.i8 = vorr_s8(*(int8x8_t *)v5.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL));
    v1 = this[13] | (4 * this[11]) | (2 * this[12]) | v5.i16[0] | v5.i16[2] | ((v5.i32[0] | v5.i32[1]) >> 16) | (v4 << 12) | (8 * this[10]) | (v3 << 13) | 0x8000;
    goto LABEL_5;
  }
  v1 = (v3 << 12) | (v4 << 10) | (this[2] << 8) | (this[3] << 6) | (16 * this[4]) | (4 * this[5]) | this[6] | 0xC000;
  *((_WORD *)this + 12) = 1;
  v6 = v2 - 7;
  *((_QWORD *)this + 2) = v6;
  if (!v6)
    return (unsigned __int8 *)v1;
  v7 = this[7];
  *this = v7;
  this[25] = v7 == 2;
  if (v6 == 1)
    return (unsigned __int8 *)v1;
  v8 = this[8];
  this[1] = v8;
  this[24] = v8 == v7;
  v9 = v7 == 2 || v8 == 2;
  v10 = v9;
  this[25] = v10;
  if (v6 < 3)
    return (unsigned __int8 *)v1;
  v11 = this[9];
  v13 = v8 == v7 && v11 == v7;
  this[2] = v11;
  this[24] = v13;
  if (v11 == 2)
    v10 = 1;
  this[25] = v10;
  if (v6 == 3)
    return (unsigned __int8 *)v1;
  v14 = this[10];
  if (v14 != v7)
    v13 = 0;
  this[3] = v14;
  this[24] = v13;
  if (v14 == 2)
    v10 = 1;
  this[25] = v10;
  if (v6 < 5)
    return (unsigned __int8 *)v1;
  v15 = this[11];
  if (v15 != v7)
    v13 = 0;
  this[4] = v15;
  this[24] = v13;
  if (v15 == 2)
    v10 = 1;
  this[25] = v10;
  if (v6 == 5)
    return (unsigned __int8 *)v1;
  v16 = this[12];
  if (v16 != v7)
    v13 = 0;
  this[5] = v16;
  this[24] = v13;
  if (v16 == 2)
    v10 = 1;
  this[25] = v10;
  if (v6 < 7)
    return (unsigned __int8 *)v1;
  v17 = this[13];
  v18 = v17 == v7 && v13;
  this[6] = v17;
  this[24] = v18;
  if (v17 == 2)
    v19 = 1;
  else
    v19 = v10;
  this[25] = v19;
  __break(1u);
  return this;
}

void webrtc::rtcp::TransportFeedback::~TransportFeedback(webrtc::rtcp::TransportFeedback *this)
{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = &off_24C0C2908;
  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
  {
    *((_QWORD *)this + 12) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 8);
  if (v3)
  {
    *((_QWORD *)this + 9) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 5);
  if (v4)
  {
    *((_QWORD *)this + 6) = v4;
    operator delete(v4);
  }
}

{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = &off_24C0C2908;
  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
  {
    *((_QWORD *)this + 12) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 8);
  if (v3)
  {
    *((_QWORD *)this + 9) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 5);
  if (v4)
  {
    *((_QWORD *)this + 6) = v4;
    operator delete(v4);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::rtcp::TransportFeedback::AddReceivedPacket(webrtc::rtcp::TransportFeedback *this, unsigned int a2, Timestamp a3)
{
  __int16 v3;
  int64_t v5;
  uint64_t v6;
  BOOL v7;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  int64_t v12;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t result;
  uint64_t v26;
  unsigned __int16 v27;
  unsigned __int8 v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int8 *v33;
  int v34;
  char v35;
  unsigned __int16 v36;
  unsigned int v37;
  int v38;
  unint64_t v40;
  __int16 v41;
  _BYTE *v42;
  unint64_t v43;
  int v44;
  unsigned __int16 v45;
  unint64_t v46;
  char *v47;
  _WORD *v48;
  BOOL v49;
  char v50;
  unint64_t v51;
  char *v52;
  _WORD *v53;
  char *v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  BOOL v58;
  unint64_t v59;
  uint64_t v60;
  char *v61;
  char *v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  char *v67;
  char *v68;
  uint64_t v69;
  __int128 v70;
  int v71;
  uint64_t v72;
  unint64_t v73;
  unsigned __int16 v74;
  unsigned __int16 v75;
  unint64_t v76;
  unsigned __int16 *v77;
  _WORD *v78;
  unsigned __int16 *v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _BYTE *v86;
  unsigned __int16 *v87;
  char *v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  unsigned __int16 *v93;
  _OWORD *v94;
  unsigned __int16 *v95;
  unint64_t v96;
  __int128 v97;
  unsigned __int16 v98;
  char *v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _BYTE *v106;
  unsigned __int16 *v107;
  char *v108;
  unint64_t v109;
  uint64_t v110;
  unint64_t v111;
  char *v112;
  _OWORD *v113;
  char *v114;
  unint64_t v115;
  __int128 v116;
  unsigned __int16 v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unsigned __int16 *v123;
  unsigned __int16 *v124;
  uint64_t v125;
  uint64_t v126;
  unsigned __int16 *v127;
  uint64_t v128;
  unint64_t v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t v132;
  _BYTE *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  unsigned __int16 *v137;
  unsigned __int16 *v138;
  unsigned __int16 *v139;
  unsigned __int16 v140;
  char *v141;
  unint64_t v142;
  unsigned int v143;
  unint64_t v144;
  int16x8_t v145;
  int16x8_t *v146;
  unint64_t v147;
  unsigned __int16 *v148;
  char *v149;
  uint64_t v150;
  char *v151;
  unsigned __int16 *v152;
  unsigned __int16 *v153;
  unint64_t v154;
  unint64_t v155;
  uint64_t v156;
  _OWORD *v157;
  __int128 *v158;
  unint64_t v159;
  __int128 v160;
  unsigned __int16 v161;
  int64_t v162;
  char *v163;
  size_t v164;
  char *v165;
  char *v166;
  __int16 v167;
  unsigned __int16 v168;
  unint64_t v169;
  unsigned __int16 v170;

  v3 = a2;
  if (*((_BYTE *)this + 25))
  {
    v5 = 0x93FFFFFFFFLL;
    v6 = *((_QWORD *)this + 4);
    if (v6 > a3.var0)
    {
      v7 = a3.var0 == 0x8000000000000000 || v6 == 0x7FFFFFFFFFFFFFFFLL;
      v8 = v6 - a3.var0 + 0xFA00000000;
      if (v7)
        v8 = 0x800000F9FFFFFFFFLL;
      v9 = (unsigned __int128)((v8 - 1) * (__int128)0x20C49BA5E353F7CFLL) >> 64;
      v10 = 0xFA00000000 * ((v9 >> 37) + ((unint64_t)v9 >> 63));
      if (v10 == 0x7FFFFFFFFFFFFFFFLL)
        goto LABEL_25;
      v11 = v10 == 0x8000000000000000 || a3.var0 == 0x8000000000000000;
      v12 = v10 + a3.var0;
      if (v11)
        a3.var0 = 0x8000000000000000;
      else
        a3.var0 = v12;
    }
    if (v6 != 0x8000000000000000 && a3.var0 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v5 = (a3.var0 - v6) % 0xFA00000000;
      v14 = a3.var0 == 0x8000000000000000 || v6 == 0x7FFFFFFFFFFFFFFFLL;
      v15 = 0xFFFFFF6C00000000;
      if (!v14)
        v15 = v5;
      if (v15 < 0x7D00000001)
      {
        v16 = v15 + 125;
LABEL_26:
        v17 = v16 / 250;
        if (v17 != (__int16)v17)
        {
          if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
          {
            rtc::webrtc_logging_impl::Log("\r\t", v18, v19, v20, v21, v22, v23, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/transport_feedback.cc");
            return 0;
          }
          return 0;
        }
        goto LABEL_30;
      }
    }
LABEL_25:
    v16 = v5 - 0xFA0000007DLL;
    goto LABEL_26;
  }
  LOWORD(v17) = 0;
LABEL_30:
  v26 = *((unsigned __int16 *)this + 9);
  v27 = v26 + *((_WORD *)this + 8);
  if (a2 == v27)
    goto LABEL_31;
  v36 = v27 - 1;
  v37 = a2 - (unsigned __int16)(v27 - 1);
  if (v37 == 0x8000)
  {
    if (a2 <= v36)
      return 0;
  }
  else
  {
    v38 = v37 & 0x8000;
    if (a2 == v36 || v38 != 0)
      return 0;
  }
  v40 = (unsigned __int16)(a2 - v27);
  v41 = v40 + v26;
  if ((v40 + v26) >> 16)
    return 0;
  v42 = (char *)this + 112;
  v43 = *((_QWORD *)this + 16);
  if (!v43)
    goto LABEL_157;
  while (1)
  {
    if (v43 < 7)
      goto LABEL_64;
    if (v43 > 0xD)
    {
      if (v43 > 0x1FFE)
        break;
    }
    else if (!*((_BYTE *)this + 137))
    {
      goto LABEL_64;
    }
    if (!*((_BYTE *)this + 136) || *v42)
      break;
    if (v43 >= 0xE)
    {
      v44 = 0;
      *((_QWORD *)this + 16) = ++v43;
      goto LABEL_54;
    }
LABEL_64:
    v42[v43] = 0;
    v44 = *((unsigned __int8 *)this + 136);
    v43 = *((_QWORD *)this + 16) + 1;
    *((_QWORD *)this + 16) = v43;
    if (!v44)
      goto LABEL_55;
    v44 = *v42;
LABEL_54:
    LOBYTE(v44) = v44 == 0;
LABEL_55:
    *((_BYTE *)this + 136) = v44;
    if (!--v40)
      goto LABEL_211;
  }
  v74 = (unsigned __int16)webrtc::rtcp::TransportFeedback::LastChunk::Emit((unsigned __int8 *)this + 112);
  v75 = v74;
  v77 = (unsigned __int16 *)*((_QWORD *)this + 12);
  v76 = *((_QWORD *)this + 13);
  if ((unint64_t)v77 < v76)
  {
    if (v77)
    {
      *v77 = v74;
      v78 = v77 + 1;
      goto LABEL_156;
    }
LABEL_212:
    __break(1u);
LABEL_213:
    abort();
  }
  v79 = (unsigned __int16 *)*((_QWORD *)this + 11);
  v80 = (char *)v77 - (char *)v79;
  if ((char *)v77 - (char *)v79 <= -3)
    goto LABEL_213;
  v167 = v41;
  v81 = v80 >> 1;
  v82 = v76 - (_QWORD)v79;
  if (v82 <= (v80 >> 1) + 1)
    v83 = v81 + 1;
  else
    v83 = v82;
  v58 = v82 >= 0x7FFFFFFFFFFFFFFELL;
  v84 = 0x7FFFFFFFFFFFFFFFLL;
  if (!v58)
    v84 = v83;
  if (!v84)
    goto LABEL_212;
  if (v84 < 0)
    goto LABEL_214;
  v85 = 2 * v84;
  v86 = operator new(2 * v84);
  v87 = (unsigned __int16 *)&v86[2 * v81];
  v88 = &v86[v85];
  *v87 = v75;
  v78 = v87 + 1;
  if (v77 == v79)
  {
    v41 = v167;
  }
  else
  {
    v89 = v81;
    v90 = (char *)v77 - (char *)v79 - 2;
    v41 = v167;
    if (v90 < 0x1E)
      goto LABEL_217;
    if ((unint64_t)((char *)v77 - &v86[((char *)v77 - (char *)v79) & 0xFFFFFFFFFFFFFFFELL]) < 0x20)
      goto LABEL_217;
    v91 = (v90 >> 1) + 1;
    v92 = 2 * (v91 & 0xFFFFFFFFFFFFFFF0);
    v93 = &v77[v92 / 0xFFFFFFFFFFFFFFFELL];
    v87 = (unsigned __int16 *)((char *)v87 - v92);
    v94 = &v86[2 * v89 - 16];
    v95 = v77 - 8;
    v96 = v91 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      v97 = *(_OWORD *)v95;
      *(v94 - 1) = *((_OWORD *)v95 - 1);
      *v94 = v97;
      v94 -= 2;
      v95 -= 16;
      v96 -= 16;
    }
    while (v96);
    v77 = v93;
    if (v91 != (v91 & 0xFFFFFFFFFFFFFFF0))
    {
LABEL_217:
      do
      {
        v98 = *--v77;
        *--v87 = v98;
      }
      while (v77 != v79);
    }
  }
  *((_QWORD *)this + 11) = v87;
  *((_QWORD *)this + 12) = v78;
  *((_QWORD *)this + 13) = v88;
  if (v79)
    operator delete(v79);
LABEL_156:
  *((_QWORD *)this + 12) = v78;
LABEL_157:
  v119 = v40 / 0x1FFF;
  v120 = v40 % 0x1FFF;
  if (v40 % 0x1FFF)
    v121 = v119 + 1;
  else
    v121 = v40 / 0x1FFF;
  v122 = *((_QWORD *)this + 18) + 2 * v121;
  if (v122 > 0x40000)
  {
    result = 0;
    *((_WORD *)this + 9) = v41 - v40;
    return result;
  }
  *((_QWORD *)this + 18) = v122;
  v123 = (unsigned __int16 *)*((_QWORD *)this + 12);
  v170 = 0x1FFF;
  if (v40 < 0x1FFF)
    goto LABEL_210;
  v124 = (unsigned __int16 *)*((_QWORD *)this + 11);
  v125 = (char *)v123 - (char *)v124;
  v126 = v123 - v124;
  v127 = (unsigned __int16 *)((char *)v124 + (((char *)v123 - (char *)v124) & 0xFFFFFFFFFFFFFFFELL));
  v128 = *((_QWORD *)this + 13);
  if (v119 > (v128 - (uint64_t)v123) >> 1)
  {
    v129 = v126 + v119;
    if ((uint64_t)(v126 + v119) < 0)
      goto LABEL_213;
    v130 = v128 - (_QWORD)v124;
    if (v130 > v129)
      v129 = v130;
    v58 = v130 >= 0x7FFFFFFFFFFFFFFELL;
    v131 = 0x7FFFFFFFFFFFFFFFLL;
    if (!v58)
      v131 = v129;
    v169 = v120;
    if (!v131)
    {
      v133 = 0;
      goto LABEL_195;
    }
    if ((v131 & 0x8000000000000000) == 0)
    {
      v132 = v131;
      v133 = operator new(2 * v131);
      v131 = v132;
      v126 = v123 - v124;
      v125 = (char *)v123 - (char *)v124;
LABEL_195:
      v148 = (unsigned __int16 *)&v133[2 * v126];
      v149 = &v133[2 * v131];
      v150 = 2 * v119;
      v151 = (char *)&v148[v119];
      v152 = v148;
      do
      {
        if (!v152)
          goto LABEL_212;
        *v152++ = v170;
        v150 -= 2;
      }
      while (v150);
      if (v124 != v123)
      {
        if ((unint64_t)(v125 - 2) < 0x1E)
        {
          v153 = (unsigned __int16 *)((char *)v124 + (((char *)v123 - (char *)v124) & 0xFFFFFFFFFFFFFFFELL));
          goto LABEL_205;
        }
        v153 = (unsigned __int16 *)((char *)v124 + (((char *)v123 - (char *)v124) & 0xFFFFFFFFFFFFFFFELL));
        if ((unint64_t)((char *)v124 + (v125 & 0xFFFFFFFFFFFFFFFELL) - &v133[v125 & 0xFFFFFFFFFFFFFFFELL]) < 0x20)
          goto LABEL_218;
        v154 = ((unint64_t)(v125 - 2) >> 1) + 1;
        v155 = 2 * (v154 & 0xFFFFFFFFFFFFFFF0);
        v153 = &v127[v155 / 0xFFFFFFFFFFFFFFFELL];
        v148 = (unsigned __int16 *)((char *)v148 - v155);
        v156 = 2 * v126 - 16;
        v157 = &v133[v156];
        v158 = (__int128 *)((char *)v124 + v156);
        v159 = v154 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          v160 = *v158;
          *(v157 - 1) = *(v158 - 1);
          *v157 = v160;
          v157 -= 2;
          v158 -= 2;
          v159 -= 16;
        }
        while (v159);
        if (v154 != (v154 & 0xFFFFFFFFFFFFFFF0))
        {
LABEL_218:
          do
          {
LABEL_205:
            v161 = *--v153;
            *--v148 = v161;
          }
          while (v153 != v124);
        }
      }
      v162 = (char *)v123 - (char *)v127;
      if (v123 != v127)
      {
        v163 = (char *)v124 + (((char *)v123 - (char *)v124) & 0xFFFFFFFFFFFFFFFELL);
        v164 = (char *)v123 - (char *)v127;
        v165 = v149;
        v166 = v151;
        memmove(v151, v163, v164);
        v151 = v166;
        v149 = v165;
      }
      *((_QWORD *)this + 11) = v148;
      *((_QWORD *)this + 12) = &v151[v162];
      *((_QWORD *)this + 13) = v149;
      v120 = v169;
      if (v124)
      {
        operator delete(v124);
        v120 = v169;
      }
      goto LABEL_210;
    }
LABEL_214:
    std::__throw_bad_array_new_length[abi:sn180100]();
  }
  v134 = v123 - v127;
  v135 = 2 * v119;
  if (v119 <= v134)
  {
    v137 = v123;
    v134 = v119;
  }
  else
  {
    v136 = 0;
    v137 = &v123[v119 - v134];
    do
    {
      if (!&v123[v136 / 2])
        goto LABEL_212;
      v123[v136 / 2] = 0x1FFF;
      v136 += 2;
    }
    while (v135 - 2 * v134 != v136);
    *((_QWORD *)this + 12) = v137;
    if (v123 == v127)
      goto LABEL_210;
  }
  v138 = &v137[v135 / 0xFFFFFFFFFFFFFFFELL];
  v139 = v137;
  if (&v137[v135 / 0xFFFFFFFFFFFFFFFELL] < v123)
  {
    v139 = v137;
    while (v139)
    {
      v140 = *v138++;
      *v139++ = v140;
      if (v138 >= v123)
        goto LABEL_183;
    }
    goto LABEL_212;
  }
LABEL_183:
  v141 = (char *)&v127[(unint64_t)v135 / 2];
  *((_QWORD *)this + 12) = v139;
  if (v137 != (unsigned __int16 *)v141)
  {
    v142 = v120;
    memmove(&v137[-(((char *)v137 - v141) >> 1)], (char *)v124 + (((char *)v123 - (char *)v124) & 0xFFFFFFFFFFFFFFFELL), (char *)v137 - v141);
    v126 = v123 - v124;
    v120 = v142;
  }
  v143 = v170;
  if (v127 > &v170)
    v143 = 0x1FFF;
  if (v134 >= 0x10)
  {
    v127 += v134 & 0xFFFFFFFFFFFFFFF0;
    v144 = v134 & 0xF;
    v145 = vdupq_n_s16(v143);
    v146 = (int16x8_t *)&v124[v126 + 8];
    v147 = v134 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      v146[-1] = v145;
      *v146 = v145;
      v146 += 2;
      v147 -= 16;
    }
    while (v147);
    if (v134 == (v134 & 0xFFFFFFFFFFFFFFF0))
      goto LABEL_210;
  }
  else
  {
    v144 = v134;
  }
  do
  {
    *v127++ = v143;
    --v144;
  }
  while (v144);
LABEL_210:
  *(_QWORD *)((char *)this + 118) = 0;
  *(_QWORD *)v42 = 0;
  *((_QWORD *)this + 16) = v120;
LABEL_211:
  *((_WORD *)this + 9) = v41;
  LOWORD(v26) = v41;
LABEL_31:
  if ((unsigned __int16)v17 < 0x100u)
    v28 = 1;
  else
    v28 = 2;
  if ((_WORD)v26 == 0xFFFF)
    return 0;
  v29 = *((_QWORD *)this + 16);
  v30 = 2 * (v29 == 0);
  v31 = *((_QWORD *)this + 18);
  v32 = v31 + v28;
  if ((unint64_t)(v32 + v30) > 0x40000)
    return 0;
  v33 = (unsigned __int8 *)this + 112;
  if (v29 < 7)
    goto LABEL_37;
  if (v29 > 0xD)
  {
    if (v29 <= 0x1FFE)
      goto LABEL_71;
    goto LABEL_75;
  }
  if ((unsigned __int16)v17 <= 0xFFu && !*((_BYTE *)this + 137))
  {
LABEL_37:
    *((_QWORD *)this + 18) = v30 + v31;
    goto LABEL_38;
  }
LABEL_71:
  if (!*((_BYTE *)this + 136) || *v33 != v28)
  {
LABEL_75:
    if ((unint64_t)(v32 - 0x3FFFF) >= 0xFFFFFFFFFFFBFFFFLL)
    {
      v45 = (unsigned __int16)webrtc::rtcp::TransportFeedback::LastChunk::Emit((unsigned __int8 *)this + 112);
      v47 = (char *)*((_QWORD *)this + 12);
      v46 = *((_QWORD *)this + 13);
      if ((unint64_t)v47 >= v46)
      {
        v99 = (char *)*((_QWORD *)this + 11);
        v100 = v47 - v99;
        if (v47 - v99 <= -3)
          goto LABEL_213;
        v101 = v100 >> 1;
        v102 = v46 - (_QWORD)v99;
        if (v102 <= (v100 >> 1) + 1)
          v103 = v101 + 1;
        else
          v103 = v102;
        v58 = v102 >= 0x7FFFFFFFFFFFFFFELL;
        v104 = 0x7FFFFFFFFFFFFFFFLL;
        if (!v58)
          v104 = v103;
        if (!v104)
          goto LABEL_212;
        v168 = v45;
        if (v104 < 0)
          goto LABEL_214;
        v105 = 2 * v104;
        v106 = operator new(2 * v104);
        v107 = (unsigned __int16 *)&v106[2 * v101];
        v108 = &v106[v105];
        *v107 = v168;
        v48 = v107 + 1;
        if (v47 != v99)
        {
          v109 = v47 - v99 - 2;
          if (v109 < 0x1E)
            goto LABEL_219;
          if ((unint64_t)(&v47[-((v47 - v99) & 0xFFFFFFFFFFFFFFFELL)] - v106) < 0x20)
            goto LABEL_219;
          v110 = (v109 >> 1) + 1;
          v111 = 2 * (v110 & 0xFFFFFFFFFFFFFFF0);
          v112 = &v47[-v111];
          v107 = (unsigned __int16 *)((char *)v107 - v111);
          v113 = &v106[2 * v101 - 16];
          v114 = v47 - 16;
          v115 = v110 & 0xFFFFFFFFFFFFFFF0;
          do
          {
            v116 = *(_OWORD *)v114;
            *(v113 - 1) = *((_OWORD *)v114 - 1);
            *v113 = v116;
            v113 -= 2;
            v114 -= 32;
            v115 -= 16;
          }
          while (v115);
          v47 = v112;
          if (v110 != (v110 & 0xFFFFFFFFFFFFFFF0))
          {
LABEL_219:
            do
            {
              v117 = *((_WORD *)v47 - 1);
              v47 -= 2;
              *--v107 = v117;
            }
            while (v47 != v99);
          }
        }
        *((_QWORD *)this + 11) = v107;
        *((_QWORD *)this + 12) = v48;
        *((_QWORD *)this + 13) = v108;
        if (v99)
          operator delete(v99);
      }
      else
      {
        if (!v47)
          goto LABEL_212;
        *(_WORD *)v47 = v45;
        v48 = v47 + 2;
      }
      *((_QWORD *)this + 12) = v48;
      *((_QWORD *)this + 18) += 2;
      v118 = *((_QWORD *)this + 16);
      if (v118 <= 0xD)
      {
        v33[v118] = v28;
        v118 = *((_QWORD *)this + 16);
      }
      *((_QWORD *)this + 16) = v118 + 1;
      v35 = *((_BYTE *)this + 136);
      if (v35)
LABEL_39:
        v35 = *v33 == v28;
      goto LABEL_80;
    }
    return 0;
  }
  *((_QWORD *)this + 18) = v30 + v31;
  if (v29 >= 0xE)
  {
    *((_QWORD *)this + 16) = v29 + 1;
    goto LABEL_39;
  }
LABEL_38:
  v33[v29] = v28;
  v34 = *((unsigned __int8 *)this + 136);
  ++*((_QWORD *)this + 16);
  if (v34)
    goto LABEL_39;
  v35 = 0;
LABEL_80:
  *((_BYTE *)this + 136) = v35;
  if (*((_BYTE *)this + 137))
    v49 = 1;
  else
    v49 = (unsigned __int16)v17 > 0xFFu;
  v50 = v49;
  *((_BYTE *)this + 137) = v50;
  ++*((_WORD *)this + 9);
  v52 = (char *)*((_QWORD *)this + 6);
  v51 = *((_QWORD *)this + 7);
  if ((unint64_t)v52 >= v51)
  {
    v54 = (char *)*((_QWORD *)this + 5);
    v55 = (v52 - v54) >> 2;
    v56 = v55 + 1;
    if ((unint64_t)(v55 + 1) >> 62)
      goto LABEL_213;
    v57 = v51 - (_QWORD)v54;
    if (v57 >> 1 > v56)
      v56 = v57 >> 1;
    v58 = (unint64_t)v57 >= 0x7FFFFFFFFFFFFFFCLL;
    v59 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v58)
      v59 = v56;
    if (!v59)
      goto LABEL_212;
    if (v59 >> 62)
      goto LABEL_214;
    v60 = 4 * v59;
    v61 = (char *)operator new(4 * v59);
    v62 = &v61[4 * v55];
    *(_WORD *)v62 = v3;
    *((_WORD *)v62 + 1) = v17;
    v53 = v62 + 4;
    if (v52 != v54)
    {
      v63 = v52 - v54 - 4;
      if (v63 < 0x2C)
        goto LABEL_220;
      if ((unint64_t)(v54 - v61) < 0x20)
        goto LABEL_220;
      v64 = (v63 >> 2) + 1;
      v65 = 4 * (v64 & 0x7FFFFFFFFFFFFFF8);
      v66 = &v52[-v65];
      v62 -= v65;
      v67 = &v61[4 * v55 - 16];
      v68 = v52 - 16;
      v69 = v64 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v70 = *(_OWORD *)v68;
        *((_OWORD *)v67 - 1) = *((_OWORD *)v68 - 1);
        *(_OWORD *)v67 = v70;
        v67 -= 32;
        v68 -= 32;
        v69 -= 8;
      }
      while (v69);
      v52 = v66;
      if (v64 != (v64 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_220:
        do
        {
          v71 = *((_DWORD *)v52 - 1);
          v52 -= 4;
          *((_DWORD *)v62 - 1) = v71;
          v62 -= 4;
        }
        while (v52 != v54);
      }
      v52 = v54;
    }
    *((_QWORD *)this + 5) = v62;
    *((_QWORD *)this + 6) = v53;
    *((_QWORD *)this + 7) = &v61[v60];
    if (v52)
      operator delete(v52);
  }
  else
  {
    if (!v52)
      goto LABEL_212;
    *(_WORD *)v52 = v3;
    *((_WORD *)v52 + 1) = v17;
    v53 = v52 + 4;
  }
  *((_QWORD *)this + 6) = v53;
  v72 = *((_QWORD *)this + 4);
  v73 = v72 + 250 * (__int16)v17;
  if (v72 == 0x8000000000000000)
    v73 = 0x8000000000000000;
  if (v72 == 0x7FFFFFFFFFFFFFFFLL)
    v73 = 0x7FFFFFFFFFFFFFFFLL;
  *((_QWORD *)this + 4) = v73;
  if (*((_BYTE *)this + 25))
    *((_QWORD *)this + 18) += v28;
  return 1;
}

uint64_t webrtc::rtcp::TransportFeedback::Parse(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  unsigned int v12;
  char v13;
  uint64_t v14;
  BOOL *v15;
  uint64_t v16;
  uint8x8_t *v17;
  unint64_t v18;
  unsigned int v19;
  unsigned int v20;
  __int16 v21;
  unint64_t v22;
  char *v23;
  size_t *v24;
  _WORD *v25;
  unint64_t v26;
  size_t v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  _BYTE *v35;
  _WORD *v36;
  int v37;
  _WORD *v38;
  unint64_t v39;
  char v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  _OWORD *v46;
  char *v47;
  unint64_t v48;
  __int128 v49;
  __int16 v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  size_t v56;
  int8x16_t *v57;
  size_t v58;
  unint64_t v59;
  BOOL *v60;
  size_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  int8x16_t v65;
  int8x16_t *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  size_t v70;
  _BYTE *v71;
  unint64_t v72;
  unint64_t v73;
  BOOL *v74;
  _BYTE *v75;
  uint64_t v76;
  unint64_t v77;
  _OWORD *v78;
  size_t *v79;
  __int128 v80;
  _BYTE *v81;
  char v82;
  unint64_t v83;
  int8x16_t *v84;
  unint64_t v85;
  unint64_t v86;
  BOOL *v87;
  uint64_t v88;
  unint64_t v89;
  int8x16_t v90;
  int8x16_t *v91;
  BOOL *v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  __int128 v96;
  _OWORD *v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  __int128 v102;
  __int8 *v103;
  uint64_t v104;
  unint64_t v105;
  _BYTE *v106;
  char v107;
  __int8 *v108;
  char v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  __int16 v127;
  unsigned int v128;
  uint8x8_t *v129;
  unint64_t v130;
  uint32x4_t v131;
  uint32x4_t v132;
  uint8x8_t *v133;
  unint64_t v134;
  uint32x4_t v135;
  uint32x4_t v136;
  uint32x4_t v137;
  uint32x4_t v138;
  uint32x4_t v139;
  uint32x4_t v140;
  uint8x16_t v141;
  uint16x8_t v142;
  uint16x8_t v143;
  uint16x8_t v144;
  uint16x8_t v145;
  uint32x4_t v146;
  uint32x4_t v147;
  uint8x8_t *v148;
  unint64_t v149;
  uint8x8_t v150;
  uint16x8_t v151;
  int v152;
  uint8x8_t *v153;
  _WORD *v154;
  unint64_t v155;
  char *v156;
  char *v157;
  uint64_t v158;
  unint64_t v159;
  uint64_t v160;
  unint64_t v161;
  uint64_t v162;
  char *v163;
  char *v164;
  char *v165;
  char *v166;
  char *v167;
  uint64_t v168;
  uint64_t v169;
  char *v170;
  char *v171;
  char *v172;
  uint64_t v173;
  __int128 v174;
  int v175;
  uint8x8_t *v176;
  _WORD *v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  int v181;
  unsigned int v182;
  unint64_t v183;
  char *v184;
  _WORD *v185;
  int v186;
  unint64_t v187;
  char *v188;
  uint64_t v189;
  char *v190;
  uint64_t v191;
  unint64_t v192;
  uint64_t v193;
  unint64_t v194;
  uint64_t v195;
  char *v196;
  char *v197;
  char *v198;
  char *v199;
  char *v200;
  uint64_t v201;
  char *v202;
  uint64_t v203;
  unint64_t v204;
  uint64_t v205;
  unint64_t v206;
  uint64_t v207;
  char *v208;
  char *v209;
  char *v210;
  char *v211;
  char *v212;
  uint64_t v213;
  uint64_t v214;
  char *v215;
  char *v216;
  char *v217;
  uint64_t v218;
  __int128 v219;
  int v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  char *v224;
  char *v225;
  char *v226;
  uint64_t v227;
  __int128 v228;
  int v229;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  unint64_t v238;
  unsigned int v239;
  size_t v240;
  uint8x8_t *v241;
  unint64_t v242;
  size_t *v243;
  uint64_t v244;
  char *v245;
  _QWORD *v246;
  uint64_t v247;

  if (*(_DWORD *)(a2 + 4) <= 0x11u)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long> const&)::t, v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/transport_feedback.cc");
      return 0;
    }
    return 0;
  }
  v9 = a1;
  v10 = *(_QWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 8) = bswap32(*(_DWORD *)v10);
  *(_DWORD *)(a1 + 12) = bswap32(*(_DWORD *)(v10 + 4));
  *(_WORD *)(a1 + 16) = bswap32(*(unsigned __int16 *)(v10 + 8)) >> 16;
  v11 = __rev16(*(unsigned __int16 *)(v10 + 10));
  v12 = (*(unsigned __int8 *)(v10 + 12) << 16) | (*(unsigned __int8 *)(v10 + 13) << 8) | *(unsigned __int8 *)(v10 + 14);
  *(_DWORD *)(a1 + 20) = v12;
  v244 = v10;
  v13 = *(_BYTE *)(v10 + 15);
  *(_QWORD *)(a1 + 128) = 0;
  *(_BYTE *)(a1 + 24) = v13;
  *(_WORD *)(a1 + 18) = 0;
  *(_QWORD *)(a1 + 32) = 64000 * v12 + 0xFA00000000;
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a1 + 88);
  *(_WORD *)(a1 + 136) = 1;
  *(_QWORD *)(a1 + 144) = 20;
  if (!(_DWORD)v11)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      rtc::webrtc_logging_impl::Log("\r\t", v110, v111, v112, v113, v114, v115, v116, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/transport_feedback.cc");
      return 0;
    }
    return 0;
  }
  v242 = *(unsigned int *)(a2 + 4);
  v243 = (size_t *)(a1 + 128);
  v14 = (uint64_t)operator new(v11);
  v245 = (char *)(v14 + v11);
  v15 = (BOOL *)(v9 + 112);
  v238 = v9 + 113;
  v16 = 16;
  v17 = (uint8x8_t *)v14;
  v246 = (_QWORD *)v9;
  v240 = v11;
  do
  {
    if (v16 + 2 > v242)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v118, v119, v120, v121, v122, v123, v124, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/transport_feedback.cc");
      v117 = 0;
      v125 = 64000 * *(unsigned int *)(v9 + 20) + 0xFA00000000;
      *(_WORD *)(v9 + 18) = 0;
      *(_QWORD *)(v9 + 32) = v125;
      *(_QWORD *)(v9 + 48) = *(_QWORD *)(v9 + 40);
      *(_QWORD *)(v9 + 72) = *(_QWORD *)(v9 + 64);
      *(_QWORD *)(v9 + 96) = *(_QWORD *)(v9 + 88);
      *(_QWORD *)(v9 + 128) = 0;
      *(_WORD *)(v9 + 136) = 1;
      *(_QWORD *)(v9 + 144) = 20;
      if (v17)
        goto LABEL_307;
      return v117;
    }
    v247 = v16 + 2;
    v19 = *(unsigned __int8 *)(v244 + v16);
    v20 = *(unsigned __int8 *)(v244 + v16 + 1);
    v21 = v20 | ((_WORD)v19 << 8);
    v23 = *(char **)(v9 + 96);
    v22 = *(_QWORD *)(v9 + 104);
    if ((unint64_t)v23 >= v22)
    {
      v241 = v17;
      v28 = *(char **)(v9 + 88);
      v9 = v23 - v28;
      if (v23 - v28 <= -3)
        goto LABEL_312;
      v29 = v9 >> 1;
      v30 = v22 - (_QWORD)v28;
      if (v30 <= (v9 >> 1) + 1)
        v31 = v29 + 1;
      else
        v31 = v30;
      v32 = v30 >= 0x7FFFFFFFFFFFFFFELL;
      v33 = 0x7FFFFFFFFFFFFFFFLL;
      if (!v32)
        v33 = v31;
      if (!v33)
        goto LABEL_309;
      v239 = v20;
      if (v33 < 0)
LABEL_313:
        std::__throw_bad_array_new_length[abi:sn180100]();
      v34 = 2 * v33;
      v35 = operator new(2 * v33);
      v36 = &v35[2 * v29];
      v37 = v21;
      *v36 = v21;
      v38 = v36 + 1;
      if (v23 == v28)
      {
        v9 = (uint64_t)v246;
        goto LABEL_47;
      }
      v39 = v23 - v28 - 2;
      if (v39 >= 0x1E)
      {
        v42 = &v23[-(v9 & 0xFFFFFFFFFFFFFFFELL)] - v35;
        v9 = (uint64_t)v246;
        if (v42 >= 0x20)
        {
          v43 = (v39 >> 1) + 1;
          v44 = 2 * (v43 & 0xFFFFFFFFFFFFFFF0);
          v45 = &v23[-v44];
          v36 = (_WORD *)((char *)v36 - v44);
          v46 = &v35[2 * v29 - 16];
          v47 = v23 - 16;
          v48 = v43 & 0xFFFFFFFFFFFFFFF0;
          do
          {
            v49 = *(_OWORD *)v47;
            *(v46 - 1) = *((_OWORD *)v47 - 1);
            *v46 = v49;
            v46 -= 2;
            v47 -= 32;
            v48 -= 16;
          }
          while (v48);
          v23 = v45;
          if (v43 == (v43 & 0xFFFFFFFFFFFFFFF0))
          {
LABEL_47:
            *(_QWORD *)(v9 + 88) = v36;
            *(_QWORD *)(v9 + 96) = v38;
            *(_QWORD *)(v9 + 104) = &v35[v34];
            if (v28)
            {
              operator delete(v28);
              v37 = v21;
            }
            v11 = v240;
            v17 = v241;
            v16 = v247;
            v24 = v243;
            v20 = v239;
            *(_QWORD *)(v9 + 96) = v38;
            v26 = (unint64_t)v241 + v240 - v14;
            if (v37 < 0)
              goto LABEL_12;
            goto LABEL_50;
          }
        }
      }
      else
      {
        v9 = (uint64_t)v246;
      }
      do
      {
        v50 = *((_WORD *)v23 - 1);
        v23 -= 2;
        *--v36 = v50;
      }
      while (v23 != v28);
      goto LABEL_47;
    }
    v24 = v243;
    if (!v23)
      goto LABEL_309;
    *(_WORD *)v23 = v21;
    v25 = v23 + 2;
    v16 = v247;
    *(_QWORD *)(v9 + 96) = v25;
    v26 = (unint64_t)v17 + v11 - v14;
    if (v21 < 0)
    {
LABEL_12:
      if ((v19 & 0x40) != 0)
      {
        if (v26 >= 7)
          v27 = 7;
        else
          v27 = v26;
        *(_QWORD *)(v9 + 128) = v27;
        *(_WORD *)(v9 + 136) = 256;
        if (!v27)
          goto LABEL_7;
        *v15 = (v19 >> 4) & 3;
        if (v27 == 1)
          goto LABEL_95;
        *(_BYTE *)(v9 + 113) = (v19 >> 2) & 3;
        if (v27 < 3)
          goto LABEL_94;
        *(_BYTE *)(v9 + 114) = v19 & 3;
        if (v27 == 3)
          goto LABEL_95;
        *(_BYTE *)(v9 + 115) = v20 >> 6;
        if (v27 < 5)
          goto LABEL_144;
        *(_BYTE *)(v9 + 116) = (v20 >> 4) & 3;
        if (v27 != 5)
        {
          *(_BYTE *)(v9 + 117) = (v20 >> 2) & 3;
          if (v26 >= 7)
          {
            v40 = 3;
            v41 = 6;
            goto LABEL_41;
          }
        }
LABEL_95:
        if ((uint64_t)&v245[-v14] >= (uint64_t)v27)
        {
          memmove((void *)v14, v15, v27);
          v14 += v27;
          v9 = (uint64_t)v246;
          v11 = v240;
          goto LABEL_7;
        }
        v67 = v14 - (_QWORD)v17;
        v68 = v27 + v14 - (_QWORD)v17;
        if (v68 < 0)
LABEL_312:
          abort();
        v69 = v245 - (char *)v17;
        if (2 * (v245 - (char *)v17) > (unint64_t)v68)
          v68 = 2 * v69;
        if (v69 >= 0x3FFFFFFFFFFFFFFFLL)
          v70 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v70 = v68;
        if (v70)
          v71 = operator new(v70);
        else
          v71 = 0;
        v9 = (uint64_t)&v71[v67];
        v72 = (char *)v17 - &v71[v14];
        if (v72 >= v27 - 1)
          v72 = v27 - 1;
        v73 = v72 + 1;
        v74 = v15;
        v75 = &v71[v67];
        if (v73 >= 0x21)
        {
          v76 = v73 & 0x1F;
          if ((v73 & 0x1F) == 0)
            v76 = 32;
          v77 = v73 - v76;
          v74 = &v15[v77];
          v75 = (_BYTE *)(v9 + v77);
          v78 = (_OWORD *)(v9 + 16);
          v79 = v243;
          do
          {
            v80 = *(_OWORD *)v79;
            *(v78 - 1) = *((_OWORD *)v79 - 1);
            *v78 = v80;
            v78 += 2;
            v79 += 4;
            v77 -= 32;
          }
          while (v77);
        }
        v245 = &v71[v70];
        v81 = (_BYTE *)(v9 + v27);
        v11 = v240;
        do
        {
          if (!v75)
            goto LABEL_309;
          v82 = *v74++;
          *v75++ = v82;
        }
        while (v75 != v81);
        if ((uint8x8_t *)v14 != v17)
        {
          if (v67 >= 8
            && v71 <= &v71[v14 - (_QWORD)v17 - 1]
            && (unint64_t)v17 <= v14 - 1
            && (unint64_t)((char *)v17 - v71) >= 0x20)
          {
            if (v67 >= 0x20)
            {
              v83 = v67 & 0xFFFFFFFFFFFFFFE0;
              v94 = v14 - (_QWORD)v17 - 16;
              v95 = v67 & 0xFFFFFFFFFFFFFFE0;
              do
              {
                v96 = *(_OWORD *)&v17->i8[v94];
                v97 = &v71[v94];
                *(v97 - 1) = *(_OWORD *)&v17[-2].i8[v94];
                *v97 = v96;
                v94 -= 32;
                v95 -= 32;
              }
              while (v95);
              if (v67 == v83)
                goto LABEL_168;
              if ((v67 & 0x18) != 0)
                goto LABEL_149;
              v9 -= v83;
              v14 -= v83;
            }
            else
            {
              v83 = 0;
LABEL_149:
              v9 -= v67 & 0xFFFFFFFFFFFFFFF8;
              v98 = v14 - v83 - (_QWORD)v17 - 8;
              v99 = v83 - (v67 & 0xFFFFFFFFFFFFFFF8);
              do
              {
                *(uint8x8_t *)&v71[v98] = *(uint8x8_t *)((char *)v17 + v98);
                v98 -= 8;
                v99 += 8;
              }
              while (v99);
              v14 -= v67 & 0xFFFFFFFFFFFFFFF8;
              if (v67 == (v67 & 0xFFFFFFFFFFFFFFF8))
              {
LABEL_168:
                v9 = (uint64_t)v71;
                goto LABEL_169;
              }
            }
          }
          v106 = (_BYTE *)(v9 - 1);
          do
          {
            v107 = *(_BYTE *)--v14;
            *v106-- = v107;
          }
          while ((uint8x8_t *)v14 != v17);
          goto LABEL_168;
        }
LABEL_169:
        if (v17)
          operator delete(v17);
        v14 = (uint64_t)v81;
        v17 = (uint8x8_t *)v9;
        v9 = (uint64_t)v246;
        goto LABEL_7;
      }
      if (v26 >= 0xE)
        v26 = 14;
      *(_QWORD *)(v9 + 128) = v26;
      *(_WORD *)(v9 + 136) = 0;
      if (v26)
      {
        *v15 = (v19 & 0x20) != 0;
        if (v26 == 1)
        {
          v27 = 1;
          goto LABEL_95;
        }
        *(_BYTE *)(v9 + 113) = (v19 & 0x10) != 0;
        if (v26 >= 3)
        {
          *(_BYTE *)(v9 + 114) = (v19 & 8) != 0;
          if (v26 == 3)
          {
            v27 = 3;
            goto LABEL_95;
          }
          *(_BYTE *)(v9 + 115) = (v19 & 4) != 0;
          if (v26 >= 5)
          {
            *(_BYTE *)(v9 + 116) = (v19 & 2) != 0;
            if (v26 == 5)
            {
              v27 = 5;
              goto LABEL_95;
            }
            *(_BYTE *)(v9 + 117) = v19 & 1;
            if (v26 < 7)
            {
              v27 = 6;
              goto LABEL_95;
            }
            *(_BYTE *)(v9 + 118) = v20 >> 7;
            if (v26 == 7)
            {
              v27 = 7;
              goto LABEL_95;
            }
            *(_BYTE *)(v9 + 119) = (v20 & 0x40) != 0;
            if (v26 < 9)
            {
              v27 = 8;
              goto LABEL_95;
            }
            *(_BYTE *)(v9 + 120) = (v20 & 0x20) != 0;
            if (v26 == 9)
            {
              v27 = 9;
              goto LABEL_95;
            }
            *(_BYTE *)(v9 + 121) = (v20 & 0x10) != 0;
            if (v26 < 0xB)
            {
              v27 = 10;
              goto LABEL_95;
            }
            *(_BYTE *)(v9 + 122) = (v20 & 8) != 0;
            if (v26 == 11)
            {
              v27 = 11;
              goto LABEL_95;
            }
            *(_BYTE *)(v9 + 123) = (v20 & 4) != 0;
            if (v26 >= 0xD)
            {
              *(_BYTE *)(v9 + 124) = (v20 & 2) != 0;
              if (v26 == 13)
              {
                v27 = 13;
                goto LABEL_95;
              }
              v40 = 1;
              v27 = 14;
              v41 = 13;
LABEL_41:
              v15[v41] = v20 & v40;
              goto LABEL_95;
            }
            v27 = 12;
            goto LABEL_95;
          }
LABEL_144:
          v27 = 4;
          goto LABEL_95;
        }
LABEL_94:
        v27 = 2;
        goto LABEL_95;
      }
      goto LABEL_7;
    }
LABEL_50:
    if ((v21 & 0x1FFFu) >= v26)
      v27 = v26;
    else
      v27 = v21 & 0x1FFF;
    *(_QWORD *)(v9 + 128) = v27;
    *(_BYTE *)(v9 + 137) = v19 > 0x3F;
    *(_BYTE *)(v9 + 136) = 1;
    if (v27 >= 0xE)
      v51 = 14;
    else
      v51 = v27;
    if (v51)
    {
      v52 = 0;
      do
      {
        v15[v52++] = v19 >> 5;
        v27 = *v24;
        if (*v24 >= 0xE)
          v53 = 14;
        else
          v53 = *v24;
      }
      while (v52 < v53);
      if (!*(_BYTE *)(v9 + 136))
      {
        if ((uint64_t)v27 < 1)
          goto LABEL_7;
        goto LABEL_95;
      }
    }
    if (!v27)
      goto LABEL_7;
    v9 = v14 - (_QWORD)v17;
    if ((unint64_t)&v245[-v14] < v27)
    {
      v54 = v27 + v9;
      if ((uint64_t)(v27 + v9) < 0)
        goto LABEL_312;
      v55 = v245 - (char *)v17;
      if (2 * (v245 - (char *)v17) > v54)
        v54 = 2 * v55;
      if (v55 >= 0x3FFFFFFFFFFFFFFFLL)
        v56 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v56 = v54;
      if (v56)
        v57 = (int8x16_t *)operator new(v56);
      else
        v57 = 0;
      v84 = (int8x16_t *)((char *)v57 + v9);
      v85 = (char *)v17 - &v57->i8[v14];
      if (v85 >= v27 - 1)
        v85 = v27 - 1;
      v86 = v85 + 1;
      v87 = (BOOL *)&v57->i8[v9];
      if (v86 >= 0x21)
      {
        v88 = v86 & 0x1F;
        if ((v86 & 0x1F) == 0)
          v88 = 32;
        v89 = v86 - v88;
        v87 = (BOOL *)&v84->i8[v89];
        v90 = vld1q_dup_s8((const char *)v15);
        v91 = v84 + 1;
        do
        {
          v91[-1] = v90;
          *v91 = v90;
          v91 += 2;
          v89 -= 32;
        }
        while (v89);
      }
      v245 = &v57->i8[v56];
      v92 = (BOOL *)&v84->i8[v27];
      v11 = v240;
      do
      {
        if (!v87)
          goto LABEL_309;
        *v87++ = *v15;
      }
      while (v87 != v92);
      if ((uint8x8_t *)v14 == v17)
        goto LABEL_175;
      if ((unint64_t)v9 >= 8
        && v57 <= (int8x16_t *)&v57->i8[v14 - (_QWORD)v17 - 1]
        && (unint64_t)v17 <= v14 - 1
        && (unint64_t)((char *)v17 - (char *)v57) >= 0x20)
      {
        if ((unint64_t)v9 >= 0x20)
        {
          v93 = v9 & 0xFFFFFFFFFFFFFFE0;
          v100 = v14 - (_QWORD)v17 - 16;
          v101 = v9 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            v102 = *(_OWORD *)&v17->i8[v100];
            v103 = &v57->i8[v100];
            *((_OWORD *)v103 - 1) = *(_OWORD *)&v17[-2].i8[v100];
            *(_OWORD *)v103 = v102;
            v100 -= 32;
            v101 -= 32;
          }
          while (v101);
          if (v9 == v93)
            goto LABEL_174;
          if ((v9 & 0x18) != 0)
            goto LABEL_157;
          v84 = (int8x16_t *)((char *)v84 - v93);
          v14 -= v93;
        }
        else
        {
          v93 = 0;
LABEL_157:
          v84 = (int8x16_t *)((char *)v84 - (v9 & 0xFFFFFFFFFFFFFFF8));
          v104 = v14 - v93 - (_QWORD)v17 - 8;
          v105 = v93 - (v9 & 0xFFFFFFFFFFFFFFF8);
          do
          {
            *(uint8x8_t *)&v57->i8[v104] = *(uint8x8_t *)((char *)v17 + v104);
            v104 -= 8;
            v105 += 8;
          }
          while (v105);
          v14 -= v9 & 0xFFFFFFFFFFFFFFF8;
          if (v9 == (v9 & 0xFFFFFFFFFFFFFFF8))
          {
LABEL_174:
            v84 = v57;
LABEL_175:
            v9 = (uint64_t)v246;
            if (v17)
              operator delete(v17);
            v14 = (uint64_t)v92;
            v17 = (uint8x8_t *)v84;
            goto LABEL_7;
          }
        }
      }
      v108 = &v84[-1].i8[15];
      do
      {
        v109 = *(_BYTE *)--v14;
        *v108-- = v109;
      }
      while ((uint8x8_t *)v14 != v17);
      goto LABEL_174;
    }
    if (-v14 < v27 - 1)
      v58 = -v14;
    else
      v58 = v27 - 1;
    v59 = v58 + 1;
    v60 = (BOOL *)v14;
    if (v59 >= 0x21)
    {
      v61 = -v14 < v27 - 1 ? -v14 : v27 - 1;
      if (v14 >= v238 || (v62 = v14 + v61 + 1, v60 = (BOOL *)v14, (unint64_t)v15 >= v62))
      {
        v63 = v59 & 0x1F;
        if ((v59 & 0x1F) == 0)
          v63 = 32;
        v64 = v59 - v63;
        v60 = (BOOL *)(v14 + v64);
        v65 = vld1q_dup_s8((const char *)v15);
        v66 = (int8x16_t *)(v14 + 16);
        do
        {
          v66[-1] = v65;
          *v66 = v65;
          v66 += 2;
          v64 -= 32;
        }
        while (v64);
      }
    }
    do
    {
      if (!v60)
        goto LABEL_309;
      *v60++ = *v15;
    }
    while (v60 != (BOOL *)(v14 + v27));
    v14 += v27;
    v9 = (uint64_t)v246;
LABEL_7:
    v18 = v14 - (_QWORD)v17;
  }
  while (v14 - (uint64_t)v17 < v11);
  v126 = *(_QWORD *)(v9 + 96);
  if (*(_QWORD *)(v9 + 88) == v126)
  {
LABEL_309:
    __break(1u);
LABEL_310:
    *(_WORD *)(v9 + 18) = 0;
    *(_QWORD *)(v9 + 32) = 64000 * *(unsigned int *)(v9 + 20) + 0xFA00000000;
    *(_QWORD *)(v9 + 48) = *(_QWORD *)(v9 + 40);
    *(_QWORD *)(v9 + 72) = *(_QWORD *)(v9 + 64);
    *(_QWORD *)(v9 + 96) = *(_QWORD *)(v9 + 88);
    *(_QWORD *)(v9 + 128) = 0;
    *(_WORD *)(v9 + 136) = 1;
    *(_QWORD *)(v9 + 144) = 20;
    v117 = 0;
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v231, v232, v233, v234, v235, v236, v237, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/transport_feedback.cc");
      v117 = 0;
    }
    goto LABEL_306;
  }
  *(_QWORD *)(v9 + 96) = v126 - 2;
  *(_WORD *)(v9 + 18) = v11;
  v241 = v17;
  if (v17 == (uint8x8_t *)v14)
    goto LABEL_305;
  v127 = *(_WORD *)(v9 + 16);
  if (v18 < 8)
  {
    v128 = 0;
    v129 = v241;
    goto LABEL_214;
  }
  if (v18 >= 0x20)
  {
    v131 = 0uLL;
    v130 = v18 & 0xFFFFFFFFFFFFFFE0;
    v132 = 0uLL;
    v133 = v241 + 2;
    v134 = v18 & 0xFFFFFFFFFFFFFFE0;
    v135 = 0uLL;
    v136 = 0uLL;
    v137 = 0uLL;
    v138 = 0uLL;
    v139 = 0uLL;
    v140 = 0uLL;
    do
    {
      v141 = *(uint8x16_t *)v133[-2].i8;
      v142 = vmovl_u8(*(uint8x8_t *)v141.i8);
      v143 = vmovl_high_u8(v141);
      v144 = vmovl_u8(*v133);
      v145 = vmovl_high_u8(*(uint8x16_t *)v133->i8);
      v136 = vaddw_high_u16(v136, v143);
      v135 = vaddw_u16(v135, *(uint16x4_t *)v143.i8);
      v132 = vaddw_high_u16(v132, v142);
      v131 = vaddw_u16(v131, *(uint16x4_t *)v142.i8);
      v140 = vaddw_high_u16(v140, v145);
      v139 = vaddw_u16(v139, *(uint16x4_t *)v145.i8);
      v138 = vaddw_high_u16(v138, v144);
      v137 = vaddw_u16(v137, *(uint16x4_t *)v144.i8);
      v133 += 4;
      v134 -= 32;
    }
    while (v134);
    v128 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)v137, (int32x4_t)v131), vaddq_s32((int32x4_t)v139, (int32x4_t)v135)), vaddq_s32(vaddq_s32((int32x4_t)v138, (int32x4_t)v132), vaddq_s32((int32x4_t)v140, (int32x4_t)v136))));
    if (v18 != v130)
    {
      if ((v18 & 0x18) == 0)
      {
        v129 = (uint8x8_t *)((char *)v241 + v130);
        goto LABEL_214;
      }
      goto LABEL_209;
    }
  }
  else
  {
    v128 = 0;
    v130 = 0;
LABEL_209:
    v129 = (uint8x8_t *)((char *)v241 + (v18 & 0xFFFFFFFFFFFFFFF8));
    v146 = 0uLL;
    v147 = (uint32x4_t)v128;
    v148 = (uint8x8_t *)((char *)v241 + v130);
    v149 = v130 - (v18 & 0xFFFFFFFFFFFFFFF8);
    do
    {
      v150 = *v148++;
      v151 = vmovl_u8(v150);
      v146 = vaddw_high_u16(v146, v151);
      v147 = vaddw_u16(v147, *(uint16x4_t *)v151.i8);
      v149 += 8;
    }
    while (v149);
    v128 = vaddvq_s32(vaddq_s32((int32x4_t)v147, (int32x4_t)v146));
    if (v18 != (v18 & 0xFFFFFFFFFFFFFFF8))
    {
      do
      {
LABEL_214:
        v152 = v129->u8[0];
        v129 = (uint8x8_t *)((char *)v129 + 1);
        v128 += v152;
      }
      while (v129 != (uint8x8_t *)v14);
    }
  }
  if (v16 + (unint64_t)v128 <= v242)
  {
    v176 = v241;
    while (1)
    {
      v181 = v176->u8[0];
      if (v181 == 1)
        break;
      if (v181 == 2)
      {
        v186 = (__int16)(*(unsigned __int8 *)(v244 + v16) << 8) | *(unsigned __int8 *)(v244 + v16 + 1);
        v188 = *(char **)(v9 + 48);
        v187 = *(_QWORD *)(v9 + 56);
        if ((unint64_t)v188 < v187)
        {
          if (!v188)
            goto LABEL_309;
          *(_WORD *)v188 = v127;
          *((_WORD *)v188 + 1) = v186;
          v177 = v188 + 4;
LABEL_246:
          *(_QWORD *)(v9 + 48) = v177;
          v178 = *(_QWORD *)(v9 + 32);
          v179 = v178 + 250 * v186;
          if (v178 == 0x8000000000000000)
            v179 = *(_QWORD *)(v9 + 32);
          if (v178 != 0x7FFFFFFFFFFFFFFFLL)
            v178 = v179;
          v180 = 2;
LABEL_251:
          *(_QWORD *)(v9 + 32) = v178;
          v16 += v180;
          goto LABEL_252;
        }
        v201 = v16;
        v202 = *(char **)(v9 + 40);
        v9 = v188 - v202;
        v203 = (v188 - v202) >> 2;
        v204 = v203 + 1;
        if ((unint64_t)(v203 + 1) >> 62)
          goto LABEL_312;
        v205 = v187 - (_QWORD)v202;
        if (v205 >> 1 > v204)
          v204 = v205 >> 1;
        v32 = (unint64_t)v205 >= 0x7FFFFFFFFFFFFFFCLL;
        v206 = 0x3FFFFFFFFFFFFFFFLL;
        if (!v32)
          v206 = v204;
        if (!v206)
          goto LABEL_309;
        if (v206 >> 62)
          goto LABEL_313;
        v207 = 4 * v206;
        v208 = (char *)operator new(4 * v206);
        v209 = &v208[4 * v203];
        *(_WORD *)v209 = v127;
        *((_WORD *)v209 + 1) = v186;
        v210 = (char *)(v188 - v202);
        if (v188 == v202)
        {
          v9 = (uint64_t)v246;
          v16 = v201;
          v177 = v209 + 4;
          v246[5] = v209;
          v246[6] = v209 + 4;
          v246[7] = &v208[v207];
          if (!v188)
            goto LABEL_246;
        }
        else
        {
          v211 = v210 - 4;
          if ((unint64_t)(v210 - 4) < 0x2C)
          {
            v212 = &v208[4 * v203];
            v9 = (uint64_t)v246;
            goto LABEL_301;
          }
          v212 = &v208[4 * v203];
          v9 = (uint64_t)v246;
          if ((unint64_t)(v202 - v208) < 0x20)
            goto LABEL_316;
          v222 = ((unint64_t)v211 >> 2) + 1;
          v223 = 4 * (v222 & 0x7FFFFFFFFFFFFFF8);
          v224 = &v188[-v223];
          v212 = &v209[-v223];
          v225 = &v208[4 * v203 - 16];
          v226 = v188 - 16;
          v227 = v222 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v228 = *(_OWORD *)v226;
            *((_OWORD *)v225 - 1) = *((_OWORD *)v226 - 1);
            *(_OWORD *)v225 = v228;
            v225 -= 32;
            v226 -= 32;
            v227 -= 8;
          }
          while (v227);
          v188 = v224;
          if (v222 != (v222 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_316:
            do
            {
LABEL_301:
              v229 = *((_DWORD *)v188 - 1);
              v188 -= 4;
              *((_DWORD *)v212 - 1) = v229;
              v212 -= 4;
            }
            while (v188 != v202);
          }
          v188 = v202;
          v16 = v201;
          v177 = v209 + 4;
          *(_QWORD *)(v9 + 40) = v212;
          *(_QWORD *)(v9 + 48) = v209 + 4;
          *(_QWORD *)(v9 + 56) = &v208[v207];
          if (!v188)
            goto LABEL_246;
        }
        operator delete(v188);
        goto LABEL_246;
      }
      if (v181 == 3)
        goto LABEL_310;
LABEL_252:
      ++v127;
      v176 = (uint8x8_t *)((char *)v176 + 1);
      if (v176 == (uint8x8_t *)v14)
        goto LABEL_305;
    }
    v182 = *(unsigned __int8 *)(v244 + v16);
    v184 = *(char **)(v9 + 48);
    v183 = *(_QWORD *)(v9 + 56);
    if ((unint64_t)v184 < v183)
    {
      if (!v184)
        goto LABEL_309;
      *(_WORD *)v184 = v127;
      *((_WORD *)v184 + 1) = v182;
      v185 = v184 + 4;
      goto LABEL_292;
    }
    v189 = v16;
    v190 = *(char **)(v9 + 40);
    v9 = v184 - v190;
    v191 = (v184 - v190) >> 2;
    v192 = v191 + 1;
    if ((unint64_t)(v191 + 1) >> 62)
      goto LABEL_312;
    v193 = v183 - (_QWORD)v190;
    if (v193 >> 1 > v192)
      v192 = v193 >> 1;
    v32 = (unint64_t)v193 >= 0x7FFFFFFFFFFFFFFCLL;
    v194 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v32)
      v194 = v192;
    if (!v194)
      goto LABEL_309;
    if (v194 >> 62)
      goto LABEL_313;
    v195 = 4 * v194;
    v196 = (char *)operator new(4 * v194);
    v197 = &v196[4 * v191];
    *(_WORD *)v197 = v127;
    *((_WORD *)v197 + 1) = v182;
    v198 = (char *)(v184 - v190);
    if (v184 == v190)
    {
      v9 = (uint64_t)v246;
      v16 = v189;
      v185 = v197 + 4;
      v246[5] = v197;
      v246[6] = v197 + 4;
      v246[7] = &v196[v195];
      if (!v184)
        goto LABEL_292;
      goto LABEL_291;
    }
    v199 = v198 - 4;
    if ((unint64_t)(v198 - 4) >= 0x2C)
    {
      v200 = &v196[4 * v191];
      v9 = (uint64_t)v246;
      if ((unint64_t)(v190 - v196) >= 0x20)
      {
        v213 = ((unint64_t)v199 >> 2) + 1;
        v214 = 4 * (v213 & 0x7FFFFFFFFFFFFFF8);
        v215 = &v184[-v214];
        v200 = &v197[-v214];
        v216 = &v196[4 * v191 - 16];
        v217 = v184 - 16;
        v218 = v213 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v219 = *(_OWORD *)v217;
          *((_OWORD *)v216 - 1) = *((_OWORD *)v217 - 1);
          *(_OWORD *)v216 = v219;
          v216 -= 32;
          v217 -= 32;
          v218 -= 8;
        }
        while (v218);
        v184 = v215;
        if (v213 == (v213 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_290:
          v184 = v190;
          v16 = v189;
          v185 = v197 + 4;
          *(_QWORD *)(v9 + 40) = v200;
          *(_QWORD *)(v9 + 48) = v197 + 4;
          *(_QWORD *)(v9 + 56) = &v196[v195];
          if (!v184)
          {
LABEL_292:
            *(_QWORD *)(v9 + 48) = v185;
            v178 = *(_QWORD *)(v9 + 32);
            v221 = v178 + 250 * v182;
            if (v178 == 0x8000000000000000)
              v221 = *(_QWORD *)(v9 + 32);
            if (v178 != 0x7FFFFFFFFFFFFFFFLL)
              v178 = v221;
            v180 = 1;
            goto LABEL_251;
          }
LABEL_291:
          operator delete(v184);
          goto LABEL_292;
        }
      }
    }
    else
    {
      v200 = &v196[4 * v191];
      v9 = (uint64_t)v246;
    }
    do
    {
      v220 = *((_DWORD *)v184 - 1);
      v184 -= 4;
      *((_DWORD *)v200 - 1) = v220;
      v200 -= 4;
    }
    while (v184 != v190);
    goto LABEL_290;
  }
  *(_BYTE *)(v9 + 25) = 0;
  v9 = 0x3FFFFFFFFFFFFFFFLL;
  v153 = v241;
  do
  {
    if (v153->i8[0])
    {
      v156 = (char *)v246[6];
      v155 = v246[7];
      if ((unint64_t)v156 < v155)
      {
        if (!v156)
          goto LABEL_309;
        *(_WORD *)v156 = v127;
        *((_WORD *)v156 + 1) = 0;
        v154 = v156 + 4;
        goto LABEL_219;
      }
      v157 = (char *)v246[5];
      v158 = (v156 - v157) >> 2;
      v159 = v158 + 1;
      if ((unint64_t)(v158 + 1) >> 62)
        goto LABEL_312;
      v160 = v155 - (_QWORD)v157;
      if (v160 >> 1 > v159)
        v159 = v160 >> 1;
      if ((unint64_t)v160 >= 0x7FFFFFFFFFFFFFFCLL)
        v161 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v161 = v159;
      if (!v161)
        goto LABEL_309;
      if (v161 >> 62)
        goto LABEL_313;
      v162 = 4 * v161;
      v163 = (char *)operator new(4 * v161);
      v164 = &v163[4 * v158];
      *(_WORD *)v164 = v127;
      *((_WORD *)v164 + 1) = 0;
      v165 = (char *)(v156 - v157);
      if (v156 == v157)
      {
        v154 = v164 + 4;
        v16 = v247;
        v246[5] = &v163[4 * v158];
        v246[6] = v164 + 4;
        v246[7] = &v163[v162];
        if (!v156)
        {
LABEL_219:
          v246[6] = v154;
          goto LABEL_220;
        }
LABEL_218:
        operator delete(v156);
        goto LABEL_219;
      }
      v166 = v165 - 4;
      if ((unint64_t)(v165 - 4) >= 0x2C)
      {
        v167 = &v163[4 * v158];
        v16 = v247;
        if ((unint64_t)(v157 - v163) >= 0x20)
        {
          v168 = ((unint64_t)v166 >> 2) + 1;
          v169 = 4 * (v168 & 0x7FFFFFFFFFFFFFF8);
          v170 = &v156[-v169];
          v167 = &v164[-v169];
          v171 = &v163[4 * v158 - 16];
          v172 = v156 - 16;
          v173 = v168 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v174 = *(_OWORD *)v172;
            *((_OWORD *)v171 - 1) = *((_OWORD *)v172 - 1);
            *(_OWORD *)v171 = v174;
            v171 -= 32;
            v172 -= 32;
            v173 -= 8;
          }
          while (v173);
          v156 = v170;
          if (v168 == (v168 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_241:
            v156 = v157;
            v154 = v164 + 4;
            v246[5] = v167;
            v246[6] = v164 + 4;
            v246[7] = &v163[v162];
            if (!v156)
              goto LABEL_219;
            goto LABEL_218;
          }
        }
      }
      else
      {
        v167 = &v163[4 * v158];
        v16 = v247;
      }
      do
      {
        v175 = *((_DWORD *)v156 - 1);
        v156 -= 4;
        *((_DWORD *)v167 - 1) = v175;
        v167 -= 4;
      }
      while (v156 != v157);
      goto LABEL_241;
    }
LABEL_220:
    ++v127;
    v153 = (uint8x8_t *)((char *)v153 + 1);
  }
  while (v153 != (uint8x8_t *)v14);
  v9 = (uint64_t)v246;
LABEL_305:
  *(_QWORD *)(v9 + 144) = v16 + 4;
  v117 = 1;
LABEL_306:
  v17 = v241;
  if (v241)
LABEL_307:
    operator delete(v17);
  return v117;
}

unint64_t webrtc::rtcp::TransportFeedback::BlockLength(webrtc::rtcp::TransportFeedback *this)
{
  return (*((_QWORD *)this + 18) + 3) & 0xFFFFFFFFFFFFFFFCLL;
}

uint64_t webrtc::rtcp::TransportFeedback::Create(_WORD *a1, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5, void (*a6)(uint64_t, uint64_t))
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  char v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  int v24;
  uint64_t v25;
  char v26;
  unsigned __int16 *v27;
  unsigned __int16 *v28;
  uint64_t v29;
  unsigned int v30;
  unint64_t v31;
  unsigned __int8 *v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  _BYTE *v37;
  uint64_t v38;
  uint64_t i;
  uint64_t v40;
  unsigned int v41;
  _BYTE *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __int16 v46;
  __int16 v47;

  if (!a1[9])
    return 0;
  v12 = *a3;
  if ((*(uint64_t (**)(_WORD *))(*(_QWORD *)a1 + 16))(a1) + v12 > a4)
  {
    while (*a3)
    {
      a6(a5, a2);
      *a3 = 0;
      if ((*(uint64_t (**)(_WORD *))(*(_QWORD *)a1 + 16))(a1) <= a4)
        goto LABEL_5;
    }
    return 0;
  }
LABEL_5:
  (*(void (**)(_WORD *))(*(_QWORD *)a1 + 16))(a1);
  v13 = (*(uint64_t (**)(_WORD *))(*(_QWORD *)a1 + 16))(a1);
  v14 = *((_QWORD *)a1 + 18);
  result = (*(uint64_t (**)(_WORD *))(*(_QWORD *)a1 + 16))(a1);
  v16 = v13 - v14;
  if (v13 == v14)
    v17 = -113;
  else
    v17 = -81;
  *(_BYTE *)(a2 + *a3) = v17;
  *(_BYTE *)(*a3 + a2 + 1) = -51;
  *(_BYTE *)(*a3 + a2 + 2) = (unint64_t)(result - 4) >> 10;
  *(_BYTE *)(*a3 + a2 + 3) = (unint64_t)(result - 4) >> 2;
  v18 = *a3 + 4;
  *a3 = v18;
  v19 = (_DWORD *)(a2 + v18);
  *v19 = bswap32(*((_DWORD *)a1 + 2));
  v19[1] = bswap32(*((_DWORD *)a1 + 3));
  v20 = *a3 + 8;
  *a3 = v20;
  *(_WORD *)(a2 + v20) = bswap32((unsigned __int16)a1[8]) >> 16;
  v21 = *a3 + 2;
  *a3 = v21;
  *(_WORD *)(a2 + v21) = bswap32((unsigned __int16)a1[9]) >> 16;
  v22 = *a3 + 2;
  *a3 = v22;
  v23 = (_BYTE *)(a2 + v22);
  v24 = *((_DWORD *)a1 + 5);
  *v23 = BYTE2(v24);
  v23[1] = BYTE1(v24);
  v23[2] = v24;
  v25 = *a3 + a2;
  v26 = *((_BYTE *)a1 + 24);
  *a3 += 4;
  *(_BYTE *)(v25 + 3) = v26;
  v27 = (unsigned __int16 *)*((_QWORD *)a1 + 11);
  v28 = (unsigned __int16 *)*((_QWORD *)a1 + 12);
  if (v27 != v28)
  {
    v29 = *a3;
    do
    {
      v30 = *v27++;
      *(_WORD *)(a2 + v29) = bswap32(v30) >> 16;
      v29 = *a3 + 2;
      *a3 = v29;
    }
    while (v27 != v28);
  }
  v31 = *((_QWORD *)a1 + 16);
  if (!v31)
    goto LABEL_24;
  v32 = (unsigned __int8 *)(a1 + 56);
  if (*((_BYTE *)a1 + 136))
  {
    LOWORD(v32) = v31 | (*v32 << 13);
  }
  else
  {
    if (v31 > 7)
    {
      if (v31 - 15 < 0xFFFFFFFFFFFFFFF2)
      {
        __break(1u);
        return result;
      }
      v34 = 0;
      v35 = -(uint64_t)v31;
      LODWORD(v31) = 0x8000;
      do
      {
        v36 = *v32++;
        LODWORD(v31) = v31 | (v36 << (v34-- + 13));
      }
      while (v35 != v34);
      LOBYTE(v32) = BYTE1(v31);
      goto LABEL_23;
    }
    v33 = (*v32 << 12) | 0xC000;
    if (v31 == 1)
    {
      LOBYTE(v31) = 0;
      LODWORD(v32) = (unsigned __int16)(v33 & 0xF000) >> 8;
      goto LABEL_23;
    }
    LOWORD(v32) = v33 | (*((unsigned __int8 *)a1 + 113) << 10);
    if (v31 != 2)
    {
      LOWORD(v32) = (unsigned __int16)v32 | (*((unsigned __int8 *)a1 + 114) << 8);
      if (v31 != 3)
      {
        LOWORD(v32) = (unsigned __int16)v32 | (*((unsigned __int8 *)a1 + 115) << 6);
        if (v31 == 4)
        {
          LOBYTE(v32) = BYTE1(v32);
          LOBYTE(v31) = *((_BYTE *)a1 + 115) << 6;
        }
        else
        {
          v46 = (unsigned __int16)v32 | (16 * *((unsigned __int8 *)a1 + 116));
          if (v31 == 5)
          {
            LOBYTE(v32) = (unsigned __int16)((unsigned __int16)v32 | (16 * *((unsigned __int8 *)a1 + 116))) >> 8;
            LOBYTE(v31) = v46;
          }
          else
          {
            v47 = v46 | (4 * *((unsigned __int8 *)a1 + 117));
            LOBYTE(v32) = HIBYTE(v47);
            if (v31 == 6)
              LOBYTE(v31) = v47;
            else
              LOBYTE(v31) = *((_BYTE *)a1 + 118) | v47;
          }
        }
        goto LABEL_23;
      }
    }
    LOBYTE(v31) = 0;
  }
  LOBYTE(v32) = BYTE1(v32);
LABEL_23:
  v37 = (_BYTE *)(a2 + *a3);
  *v37 = (_BYTE)v32;
  v37[1] = v31;
  *a3 += 2;
LABEL_24:
  if (*((_BYTE *)a1 + 25))
  {
    v38 = *((_QWORD *)a1 + 5);
    for (i = *((_QWORD *)a1 + 6); v38 != i; v38 += 4)
    {
      while (1)
      {
        v41 = *(unsigned __int16 *)(v38 + 2);
        if (v41 > 0xFF)
          break;
        v40 = (*a3)++;
        *(_BYTE *)(a2 + v40) = v41;
        v38 += 4;
        if (v38 == i)
          goto LABEL_30;
      }
      v42 = (_BYTE *)(a2 + *a3);
      *v42 = BYTE1(v41);
      v42[1] = v41;
      *a3 += 2;
    }
  }
LABEL_30:
  if (v13 != v14)
  {
    v43 = v16 - 1;
    if (v16 != 1)
    {
      do
      {
        v44 = (*a3)++;
        *(_BYTE *)(a2 + v44) = 0;
        --v43;
      }
      while (v43);
    }
    v45 = (*a3)++;
    *(_BYTE *)(a2 + v45) = v16;
  }
  return 1;
}

void webrtc::InFlightBytesTracker::RemoveInFlightPacketBytes(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  BOOL v9;
  BOOL v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t *v15;

  if ((unint64_t)(*(_QWORD *)(a2 + 8) - 0x7FFFFFFFFFFFFFFFLL) >= 2)
  {
    v4 = std::__tree<std::__value_type<rtc::NetworkRoute,webrtc::DataSize>,std::__map_value_compare<rtc::NetworkRoute,std::__value_type<rtc::NetworkRoute,webrtc::DataSize>,webrtc::InFlightBytesTracker::NetworkRouteComparator,true>,std::allocator<std::__value_type<rtc::NetworkRoute,webrtc::DataSize>>>::find<rtc::NetworkRoute>((uint64_t)a1, (unsigned __int8 *)(a2 + 88));
    if (a1 + 1 != (_QWORD *)v4)
    {
      v5 = (uint64_t *)v4;
      v6 = *(_QWORD *)(a2 + 16);
      v7 = *(_QWORD *)(v4 + 72);
      v8 = 0x7FFFFFFFFFFFFFFFLL;
      v9 = v7 == 0x7FFFFFFFFFFFFFFFLL || v6 == 0x8000000000000000;
      if (v9
        || (v7 != 0x8000000000000000 ? (v10 = v6 == 0x7FFFFFFFFFFFFFFFLL) : (v10 = 1), v8 = 0x8000000000000000, v10))
      {
        *(_QWORD *)(v4 + 72) = v8;
      }
      else
      {
        v11 = v7 - v6;
        *(_QWORD *)(v4 + 72) = v11;
        if (!v11)
        {
          v12 = *(_QWORD **)(v4 + 8);
          if (v12)
          {
            do
            {
              v13 = v12;
              v12 = (_QWORD *)*v12;
            }
            while (v12);
          }
          else
          {
            v14 = (_QWORD *)v4;
            do
            {
              v13 = (_QWORD *)v14[2];
              v9 = *v13 == (_QWORD)v14;
              v14 = v13;
            }
            while (!v9);
          }
          if (*a1 == v4)
            *a1 = v13;
          v15 = (uint64_t *)a1[1];
          --a1[2];
          std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v15, v5);
          operator delete(v5);
        }
      }
    }
  }
}

void webrtc::TransportFeedbackAdapter::AddPacket(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  BOOL v9;
  uint64_t v10;
  int v11;
  _BOOL4 v12;
  uint64_t v13;
  BOOL v14;
  char v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t **v35;
  uint64_t **v36;
  uint64_t v37;
  _OWORD *v38;
  uint64_t v39;
  uint64_t *v40;
  __int128 v41;
  char v42;
  __int128 v44;
  __int128 v45;
  int v46;

  v6 = *a2;
  v7 = *a2;
  if (*(_BYTE *)(a1 + 34))
  {
    v8 = *(unsigned __int16 *)(a1 + 32);
    v9 = v6 >= v8;
    LODWORD(v10) = v6 - v8;
    v11 = (_DWORD)v10 != 0 && v9;
    v12 = (v10 & 0x8000u) == 0;
    if ((_DWORD)v10 == 0x8000)
      v12 = v11;
    if (v12)
      v10 = (unsigned __int16)v10;
    else
      v10 |= 0xFFFFFFFFFFFF0000;
    v7 = v10 + *(_QWORD *)(a1 + 24);
  }
  *(_QWORD *)(a1 + 24) = v7;
  *(_WORD *)(a1 + 32) = v6;
  *(_BYTE *)(a1 + 34) = 1;
  v13 = *((_QWORD *)a2 + 3);
  if (*((_BYTE *)a2 + 40))
    v14 = *((_QWORD *)a2 + 4) == 0;
  else
    v14 = 0;
  v15 = v14;
  v42 = v15;
  v44 = *(_OWORD *)(a1 + 112);
  v45 = *(_OWORD *)(a1 + 128);
  v46 = *(_DWORD *)(a1 + 144);
  v16 = *((_QWORD *)a2 + 6);
  v41 = *(_OWORD *)(a2 + 28);
  if (*(_QWORD *)(a1 + 56))
  {
    if (a4 == 0x7FFFFFFFFFFFFFFFLL)
    {
      do
      {
        v18 = *(uint64_t **)(a1 + 40);
        if (v18[13] > *(_QWORD *)(a1 + 64))
        {
          webrtc::InFlightBytesTracker::RemoveInFlightPacketBytes((_QWORD *)(a1 + 72), (uint64_t)(v18 + 5));
          v18 = *(uint64_t **)(a1 + 40);
        }
        v19 = (uint64_t *)v18[1];
        v20 = v18;
        if (v19)
        {
          do
          {
            v21 = v19;
            v19 = (uint64_t *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            v21 = (uint64_t *)v20[2];
            v14 = *v21 == (_QWORD)v20;
            v20 = v21;
          }
          while (!v14);
        }
        *(_QWORD *)(a1 + 40) = v21;
        v17 = *(uint64_t **)(a1 + 48);
        --*(_QWORD *)(a1 + 56);
        std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v17, v18);
        operator delete(v18);
      }
      while (*(_QWORD *)(a1 + 56));
    }
    else if (a4 == 0x8000000000000000)
    {
      do
      {
        v30 = *(uint64_t **)(a1 + 40);
        if (v30[5] != 0x8000000000000000)
          break;
        if (v30[13] > *(_QWORD *)(a1 + 64))
        {
          webrtc::InFlightBytesTracker::RemoveInFlightPacketBytes((_QWORD *)(a1 + 72), (uint64_t)(v30 + 5));
          v30 = *(uint64_t **)(a1 + 40);
        }
        v31 = (uint64_t *)v30[1];
        v32 = v30;
        if (v31)
        {
          do
          {
            v33 = v31;
            v31 = (uint64_t *)*v31;
          }
          while (v31);
        }
        else
        {
          do
          {
            v33 = (uint64_t *)v32[2];
            v14 = *v33 == (_QWORD)v32;
            v32 = v33;
          }
          while (!v14);
        }
        *(_QWORD *)(a1 + 40) = v33;
        v29 = *(uint64_t **)(a1 + 48);
        --*(_QWORD *)(a1 + 56);
        std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v29, v30);
        operator delete(v30);
      }
      while (*(_QWORD *)(a1 + 56));
    }
    else
    {
      do
      {
        v23 = *(uint64_t **)(a1 + 40);
        v24 = v23[5];
        if (v24 != 0x8000000000000000 && (v24 == 0x7FFFFFFFFFFFFFFFLL || a4 - v24 < 60000001))
          break;
        if (v23[13] > *(_QWORD *)(a1 + 64))
        {
          webrtc::InFlightBytesTracker::RemoveInFlightPacketBytes((_QWORD *)(a1 + 72), (uint64_t)(v23 + 5));
          v23 = *(uint64_t **)(a1 + 40);
        }
        v26 = (uint64_t *)v23[1];
        v27 = v23;
        if (v26)
        {
          do
          {
            v28 = v26;
            v26 = (uint64_t *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            v28 = (uint64_t *)v27[2];
            v14 = *v28 == (_QWORD)v27;
            v27 = v28;
          }
          while (!v14);
        }
        *(_QWORD *)(a1 + 40) = v28;
        v22 = *(uint64_t **)(a1 + 48);
        --*(_QWORD *)(a1 + 56);
        std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v22, v23);
        operator delete(v23);
      }
      while (*(_QWORD *)(a1 + 56));
    }
  }
  v35 = (uint64_t **)(a1 + 48);
  v34 = *(uint64_t **)(a1 + 48);
  if (v34)
  {
    while (1)
    {
      while (1)
      {
        v36 = (uint64_t **)v34;
        v37 = v34[4];
        if (v7 >= v37)
          break;
        v34 = *v36;
        v35 = v36;
        if (!*v36)
          goto LABEL_61;
      }
      if (v37 >= v7)
        break;
      v34 = v36[1];
      if (!v34)
      {
        v35 = v36 + 1;
        goto LABEL_61;
      }
    }
  }
  else
  {
    v36 = (uint64_t **)(a1 + 48);
LABEL_61:
    v38 = operator new(0xA8uLL);
    v38[5] = v41;
    v38[7] = xmmword_208F0A8D0;
    v38[8] = v44;
    *((_QWORD *)v38 + 4) = v7;
    *((_QWORD *)v38 + 5) = a4;
    *((_QWORD *)v38 + 6) = 0x7FFFFFFFFFFFFFFFLL;
    *((_QWORD *)v38 + 7) = v13 + a3;
    *((_QWORD *)v38 + 8) = 0;
    *((_QWORD *)v38 + 9) = v16;
    *((_BYTE *)v38 + 96) = v42;
    *((_QWORD *)v38 + 13) = v7;
    v38[9] = v45;
    *((_DWORD *)v38 + 40) = v46;
    *(_QWORD *)v38 = 0;
    *((_QWORD *)v38 + 1) = 0;
    *((_QWORD *)v38 + 2) = v36;
    *v35 = (uint64_t *)v38;
    v39 = **(_QWORD **)(a1 + 40);
    if (v39)
    {
      *(_QWORD *)(a1 + 40) = v39;
      v40 = *v35;
    }
    else
    {
      v40 = (uint64_t *)v38;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 48), v40);
    ++*(_QWORD *)(a1 + 56);
  }
}

void webrtc::TransportFeedbackAdapter::ProcessSentPacket(webrtc::TransportFeedbackAdapter *this@<X0>, const rtc::SentPacket *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  unsigned int v8;
  unsigned __int16 v9;
  int v10;
  unint64_t v11;
  unsigned int v12;
  _BOOL4 v13;
  _BOOL4 v14;
  unint64_t v15;
  int64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  char *v32;
  int64_t v33;
  BOOL v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  TimeDelta v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v54;
  char v55;
  uint64_t **v56;
  uint64_t v57;
  uint64_t *v58;
  unint64_t v59;
  uint64_t v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  unsigned int v67;
  unsigned int v68;
  int v69;
  uint64_t *v70;
  uint64_t **v71;
  _QWORD *v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  unsigned int v76;
  int v77;
  BOOL v78;
  BOOL v79;
  unsigned int v80;
  char *v81;
  int v82;
  int v83;
  uint64_t v84;
  uint64_t *v85;
  _QWORD *v86;
  uint64_t v87;
  __int128 v88;
  __int128 v89;
  uint64_t **v90;
  __int16 v91;
  char v92;
  __int16 v93;
  __int16 v94;
  char v95;
  uint64_t v96;
  void *__p[2];
  char v98;
  uint64_t v99;

  v99 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)a2;
  v6 = 1000 * *((_QWORD *)a2 + 1);
  if (*((_BYTE *)a2 + 16))
    v7 = 0;
  else
    v7 = v5 == -1;
  if (v7)
  {
    if (*((_BYTE *)a2 + 17))
    {
      if (v6 < *((_QWORD *)this + 1) && (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v18, v19, v20, v21, v22, v23, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/rtp/transport_feedback_adapter.cc");
      v25 = *((_QWORD *)a2 + 4);
      v26 = *(_QWORD *)this;
      v27 = 0x8000000000000000;
      if (v25 != 0x8000000000000000 && v26 != 0x8000000000000000)
        v27 = v26 + v25;
      if (v25 == 0x7FFFFFFFFFFFFFFFLL)
        v29 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v29 = v27;
      if (v26 == 0x7FFFFFFFFFFFFFFFLL)
        v29 = 0x7FFFFFFFFFFFFFFFLL;
      *(_QWORD *)this = v29;
      v30 = *((_QWORD *)this + 2);
      if (v30 <= v6)
        v30 = v6;
      *((_QWORD *)this + 2) = v30;
    }
    goto LABEL_66;
  }
  if (*((_BYTE *)this + 34))
  {
    v8 = *((unsigned __int16 *)this + 16);
    v9 = v5 - v8;
    v10 = (__int16)(v5 - v8);
    v11 = (unsigned __int16)(v5 - v8);
    v12 = (unsigned __int16)*(_QWORD *)a2 - v8;
    v13 = v8 < (unsigned __int16)v5;
    v14 = v10 >= 0;
    if (v12 != 0x8000)
      v13 = v14;
    if (v13)
      v15 = v11;
    else
      v15 = v9 | 0xFFFFFFFFFFFF0000;
    v16 = v15 + *((_QWORD *)this + 3);
  }
  else
  {
    v16 = (unsigned __int16)*(_QWORD *)a2;
  }
  v31 = (_QWORD *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 3) = v16;
  *((_WORD *)this + 16) = v5;
  *((_BYTE *)this + 34) = 1;
  if (!v31)
    goto LABEL_66;
  v32 = (char *)this + 48;
  do
  {
    v33 = v31[4];
    v34 = v33 < v16;
    if (v33 >= v16)
      v35 = v31;
    else
      v35 = v31 + 1;
    if (!v34)
      v32 = (char *)v31;
    v31 = (_QWORD *)*v35;
  }
  while (*v35);
  if (v32 == (char *)this + 48 || v16 < *((_QWORD *)v32 + 4))
    goto LABEL_66;
  v36 = *((_QWORD *)v32 + 6) + 0x7FFFFFFFFFFFFFFFLL;
  *((_QWORD *)v32 + 6) = v6;
  v37 = *(_QWORD *)this;
  v38 = *((_QWORD *)this + 1);
  if (v38 <= v6)
    v38 = v6;
  *((_QWORD *)this + 1) = v38;
  if (v37)
  {
    if (v6 < *((_QWORD *)this + 2))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      {
        v40 = *((_QWORD *)this + 2);
        v41 = v40 - v6;
        if (v40 == 0x8000000000000000)
          v41 = 0x8000000000000000;
        if (v40 == 0x7FFFFFFFFFFFFFFFLL)
          v42 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v42 = v41;
        webrtc::ToString((webrtc *)v42, v39, (char *)__p);
        rtc::webrtc_logging_impl::Log("\r\t\n\t", v43, v44, v45, v46, v47, v48, v49, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/rtp/transport_feedback_adapter.cc");
        if (v98 < 0)
          operator delete(__p[0]);
      }
      v37 = *(_QWORD *)this;
    }
    v50 = *((_QWORD *)v32 + 8);
    v51 = 0x8000000000000000;
    if (v37 != 0x8000000000000000 && v50 != 0x8000000000000000)
      v51 = v50 + v37;
    if (v50 == 0x7FFFFFFFFFFFFFFFLL || v37 == 0x7FFFFFFFFFFFFFFFLL)
      v54 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v54 = v51;
    *((_QWORD *)v32 + 8) = v54;
    *(_QWORD *)this = 0;
  }
  if (v36 < 0xFFFFFFFFFFFFFFFELL)
  {
LABEL_66:
    v55 = 0;
    *(_BYTE *)a3 = 0;
    goto LABEL_67;
  }
  if (*((_QWORD *)v32 + 13) > *((_QWORD *)this + 8))
  {
    v56 = (uint64_t **)std::__tree<std::__value_type<rtc::NetworkRoute,webrtc::DataSize>,std::__map_value_compare<rtc::NetworkRoute,std::__value_type<rtc::NetworkRoute,webrtc::DataSize>,webrtc::InFlightBytesTracker::NetworkRouteComparator,true>,std::allocator<std::__value_type<rtc::NetworkRoute,webrtc::DataSize>>>::find<rtc::NetworkRoute>((uint64_t)this + 72, (unsigned __int8 *)v32 + 128);
    if ((uint64_t **)((char *)this + 80) != v56)
    {
      v57 = *((_QWORD *)v32 + 7);
      v58 = v56[9];
      v59 = 0x8000000000000000;
      if (v57 != 0x8000000000000000 && v58 != (uint64_t *)0x8000000000000000)
        v59 = (unint64_t)v58 + v57;
      if (v58 == (uint64_t *)0x7FFFFFFFFFFFFFFFLL || v57 == 0x7FFFFFFFFFFFFFFFLL)
        v62 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v62 = v59;
      v56[9] = (uint64_t *)v62;
      goto LABEL_125;
    }
    v63 = v32[128];
    v64 = *((unsigned __int16 *)v32 + 68);
    v65 = *((unsigned __int16 *)v32 + 69);
    v66 = v32[140];
    v67 = *((unsigned __int16 *)v32 + 74);
    v68 = *((unsigned __int16 *)v32 + 75);
    v69 = v32[152];
    __p[0] = *(void **)(v32 + 153);
    *(_DWORD *)((char *)__p + 7) = *((_DWORD *)v32 + 40);
    v70 = *v56;
    if (!*v56)
    {
      v71 = v56;
      v72 = v56;
LABEL_121:
      v90 = v56;
      v96 = *((_QWORD *)v32 + 7);
      v94 = v67;
      v95 = v69;
      v91 = v64;
      v92 = v66;
      v93 = v68;
      v81 = (char *)operator new(0x50uLL);
      v81[32] = v63;
      v82 = *((_DWORD *)v32 + 33);
      *(_DWORD *)(v81 + 33) = *(_DWORD *)(v32 + 129);
      *((_DWORD *)v81 + 9) = v82;
      *((_WORD *)v81 + 20) = v91;
      *((_WORD *)v81 + 21) = v65;
      v81[44] = v92;
      v83 = *((_DWORD *)v32 + 36);
      *(_DWORD *)(v81 + 45) = *(_DWORD *)(v32 + 141);
      *((_DWORD *)v81 + 12) = v83;
      *((_WORD *)v81 + 26) = v94;
      *((_WORD *)v81 + 27) = v93;
      v81[56] = v95;
      *(void **)(v81 + 57) = __p[0];
      *((void **)v81 + 8) = *(void **)((char *)__p + 7);
      *((_QWORD *)v81 + 9) = v96;
      *(_QWORD *)v81 = 0;
      *((_QWORD *)v81 + 1) = 0;
      *((_QWORD *)v81 + 2) = v72;
      *v71 = (uint64_t *)v81;
      v84 = **((_QWORD **)this + 9);
      if (v84)
      {
        *((_QWORD *)this + 9) = v84;
        v85 = *v71;
      }
      else
      {
        v85 = (uint64_t *)v81;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*v90, v85);
      ++*((_QWORD *)this + 11);
      goto LABEL_125;
    }
    while (1)
    {
      while (1)
      {
        v72 = v70;
        v73 = *((unsigned __int16 *)v70 + 21);
        if (v65 == v73)
          break;
        if (v65 < v73)
          goto LABEL_84;
        if (v73 >= v65)
          goto LABEL_125;
LABEL_118:
        v70 = (uint64_t *)v72[1];
        if (!v70)
        {
          v71 = (uint64_t **)(v72 + 1);
          goto LABEL_121;
        }
      }
      v74 = *((unsigned __int16 *)v72 + 27);
      if (v68 != v74)
      {
        if (v68 < v74)
          goto LABEL_84;
        if (v74 >= v68)
          break;
        goto LABEL_118;
      }
      v75 = *((unsigned __int16 *)v72 + 20);
      if (v64 != v75)
      {
        if (v64 < v75)
          goto LABEL_84;
        if (v75 >= v64)
          break;
        goto LABEL_118;
      }
      v76 = *((unsigned __int16 *)v72 + 26);
      if (v67 != v76)
      {
        if (v67 < v76)
          goto LABEL_84;
        if (v76 >= v67)
          break;
        goto LABEL_118;
      }
      v77 = *((unsigned __int8 *)v72 + 44);
      if ((v66 != 0) == (*((_BYTE *)v72 + 44) != 0))
      {
        v77 = *((unsigned __int8 *)v72 + 56);
        if ((v69 != 0) == (*((_BYTE *)v72 + 56) != 0))
        {
          v80 = *((unsigned __int8 *)v72 + 32);
          if (v63 >= v80)
          {
            if (v80 >= v63)
              break;
            goto LABEL_118;
          }
        }
        else
        {
          if (*((_BYTE *)v72 + 56))
            v79 = v69 == 0;
          else
            v79 = 0;
          if (!v79)
          {
            if (!v69)
              break;
LABEL_114:
            if (v77)
              break;
            goto LABEL_118;
          }
        }
      }
      else
      {
        if (*((_BYTE *)v72 + 44))
          v78 = v66 == 0;
        else
          v78 = 0;
        if (!v78)
        {
          if (!v66)
            break;
          goto LABEL_114;
        }
      }
LABEL_84:
      v70 = (uint64_t *)*v72;
      v71 = (uint64_t **)v72;
      if (!*v72)
        goto LABEL_121;
    }
  }
LABEL_125:
  v86 = (_QWORD *)std::__tree<std::__value_type<rtc::NetworkRoute,webrtc::DataSize>,std::__map_value_compare<rtc::NetworkRoute,std::__value_type<rtc::NetworkRoute,webrtc::DataSize>,webrtc::InFlightBytesTracker::NetworkRouteComparator,true>,std::allocator<std::__value_type<rtc::NetworkRoute,webrtc::DataSize>>>::find<rtc::NetworkRoute>((uint64_t)this + 72, (unsigned __int8 *)this + 112);
  if ((_QWORD *)((char *)this + 80) == v86)
    v87 = 0;
  else
    v87 = v86[9];
  *((_QWORD *)v32 + 14) = v87;
  v88 = *((_OWORD *)v32 + 6);
  *(_OWORD *)(a3 + 32) = *((_OWORD *)v32 + 5);
  *(_OWORD *)(a3 + 48) = v88;
  v89 = *((_OWORD *)v32 + 4);
  *(_OWORD *)a3 = *((_OWORD *)v32 + 3);
  *(_OWORD *)(a3 + 16) = v89;
  *(_QWORD *)(a3 + 64) = *((_QWORD *)v32 + 14);
  v55 = 1;
LABEL_67:
  *(_BYTE *)(a3 + 72) = v55;
}

void webrtc::TransportFeedbackAdapter::ProcessTransportFeedback(webrtc::TransportFeedbackAdapter *this@<X0>, const webrtc::rtcp::TransportFeedback *a2@<X1>, Timestamp a3@<0:X2>, _BYTE *a4@<X8>)
{
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *__p;
  __int128 v17;
  _QWORD v18[3];
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  if (*((_WORD *)a2 + 9))
  {
    v21 = 0;
    v22 = 0;
    v20 = 0;
    v18[0] = a3.var0;
    webrtc::TransportFeedbackAdapter::ProcessTransportFeedbackInner((Timestamp *)this, a2, a3, &__p);
    v6 = __p;
    v18[2] = __p;
    v19 = v17;
    if (__p == (void *)v17)
    {
      *a4 = 0;
      a4[64] = 0;
      if (v6)
LABEL_13:
        operator delete(v6);
    }
    else
    {
      v7 = (_QWORD *)std::__tree<std::__value_type<rtc::NetworkRoute,webrtc::DataSize>,std::__map_value_compare<rtc::NetworkRoute,std::__value_type<rtc::NetworkRoute,webrtc::DataSize>,webrtc::InFlightBytesTracker::NetworkRouteComparator,true>,std::allocator<std::__value_type<rtc::NetworkRoute,webrtc::DataSize>>>::find<rtc::NetworkRoute>((uint64_t)this + 72, (unsigned __int8 *)this + 112);
      if ((_QWORD *)((char *)this + 80) == v7)
        v8 = 0;
      else
        v8 = v7[9];
      v18[1] = v8;
      webrtc::TransportPacketsFeedback::TransportPacketsFeedback((uint64_t)a4, (uint64_t)v18);
      a4[64] = 1;
      if (v6)
        goto LABEL_13;
    }
  }
  else
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/rtp/transport_feedback_adapter.cc");
    *a4 = 0;
    a4[64] = 0;
  }
}

void webrtc::TransportFeedbackAdapter::ProcessTransportFeedbackInner(Timestamp *this@<X0>, const webrtc::rtcp::TransportFeedback *a2@<X1>, Timestamp a3@<0:X2>, _QWORD *a4@<X8>)
{
  int64_t var0;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int64_t v18;
  unint64_t v19;
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  int v33;
  unsigned __int16 v34;
  unsigned __int16 *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD v51[4];
  uint64_t v52;
  uint64_t v53;

  var0 = this[13].var0;
  if ((unint64_t)(var0 - 0x7FFFFFFFFFFFFFFFLL) <= 1)
  {
LABEL_27:
    this[12].var0 = a3.var0;
    goto LABEL_39;
  }
  v9 = 64000 * *((unsigned int *)a2 + 5) - var0;
  v10 = v9 + 0xFA00000000;
  v11 = 0x7FFFFFFFFFFFFFFFLL;
  if (v9 == 0x7FFFFF05FFFFFFFFLL)
    v12 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v12 = v9;
  if (v12 >= 0)
    v13 = v12;
  else
    v13 = -v12;
  v14 = 0xFFFFFF0600000000 - v9;
  if (v10 >= 0)
    v14 = v9 + 0xFA00000000;
  v15 = v9 + 0x1F400000000;
  if (v10 == 0x7FFFFFFFFFFFFFFFLL)
    v15 = 0x7FFFFFFFFFFFFFFFLL;
  if (v15 >= 0)
    v16 = v15;
  else
    v16 = -v15;
  if (v16 >= v14)
    v15 = v10;
  if (v13 < v14)
    v15 = v12;
  v17 = 1000 * (v15 / 1000);
  v18 = this[12].var0;
  v19 = 0x8000000000000000;
  if (v18 == 0x7FFFFFFFFFFFFFFFLL)
    v20 = 0x8000000000000000;
  else
    v20 = -v18;
  if (v18 == 0x8000000000000000)
    v20 = 0x7FFFFFFFFFFFFFFFLL;
  if (v17 < v20)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/rtp/transport_feedback_adapter.cc");
    goto LABEL_27;
  }
  if (v17 != 0x8000000000000000 && v18 != 0x8000000000000000)
    v19 = v17 + v18;
  if (v17 != 0x7FFFFFFFFFFFFFFFLL && v18 != 0x7FFFFFFFFFFFFFFFLL)
    v11 = v19;
  this[12].var0 = v11;
LABEL_39:
  this[13].var0 = 64000 * *((unsigned int *)a2 + 5) + 0xFA00000000;
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  v30 = *((unsigned __int16 *)a2 + 9);
  if (*((_WORD *)a2 + 9))
  {
    v31 = (char *)operator new(80 * v30);
    *a4 = v31;
    a4[1] = v31;
    a4[2] = &v31[80 * v30];
  }
  v52 = 0;
  v53 = 0;
  v51[0] = this;
  v51[1] = &v53;
  v51[2] = a4;
  v51[3] = &v52;
  if ((_DWORD)v30)
  {
    v32 = 0;
    v33 = *((unsigned __int16 *)a2 + 8);
    v34 = v30 + v33;
    v35 = (unsigned __int16 *)*((_QWORD *)a2 + 5);
    do
    {
      while (v35 == *((unsigned __int16 **)a2 + 6) || *v35 != (unsigned __int16)v33)
      {
        rtc::FunctionView<void ()(unsigned short,webrtc::TimeDelta)>::CallVoidPtr<webrtc::TransportFeedbackAdapter::ProcessTransportFeedbackInner(webrtc::rtcp::TransportFeedback const&,webrtc::Timestamp)::$_0>(v51, (unsigned __int16)v33++, 0x7FFFFFFFFFFFFFFFLL);
        if ((unsigned __int16)v33 == v34)
          goto LABEL_51;
      }
      v36 = v32 + 250 * (__int16)v35[1];
      if (v32 == 0x8000000000000000)
        v36 = 0x8000000000000000;
      if (v32 != 0x7FFFFFFFFFFFFFFFLL)
        v32 = v36;
      rtc::FunctionView<void ()(unsigned short,webrtc::TimeDelta)>::CallVoidPtr<webrtc::TransportFeedbackAdapter::ProcessTransportFeedbackInner(webrtc::rtcp::TransportFeedback const&,webrtc::Timestamp)::$_0>(v51, (unsigned __int16)v33, v32);
      v35 += 2;
      ++v33;
    }
    while ((unsigned __int16)v33 != v34);
LABEL_51:
    if (v53 && (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v37, v38, v39, v40, v41, v42, v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/rtp/transport_feedback_adapter.cc");
  }
  if (v52)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v44, v45, v46, v47, v48, v49, v50, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/rtp/transport_feedback_adapter.cc");
  }
}

uint64_t std::__tree<std::__value_type<rtc::NetworkRoute,webrtc::DataSize>,std::__map_value_compare<rtc::NetworkRoute,std::__value_type<rtc::NetworkRoute,webrtc::DataSize>,webrtc::InFlightBytesTracker::NetworkRouteComparator,true>,std::allocator<std::__value_type<rtc::NetworkRoute,webrtc::DataSize>>>::find<rtc::NetworkRoute>(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  BOOL v15;
  uint64_t *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  BOOL v22;
  int v24;
  BOOL v25;
  uint64_t *v26;
  unsigned int v27;
  BOOL v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  BOOL v32;
  BOOL v34;

  v4 = *(_QWORD *)(a1 + 8);
  v2 = a1 + 8;
  v3 = v4;
  if (!v4)
    return v2;
  v5 = *((unsigned __int16 *)a2 + 5);
  v6 = *((unsigned __int16 *)a2 + 11);
  v7 = *((unsigned __int16 *)a2 + 4);
  v8 = *((unsigned __int16 *)a2 + 10);
  v9 = a2[12];
  v10 = a2[24];
  v11 = v2;
  v12 = *a2;
  do
  {
    while (1)
    {
      v17 = *(unsigned __int16 *)(v3 + 42);
      v13 = v17 >= v5;
      if (v17 != v5)
        goto LABEL_4;
      v18 = *(unsigned __int16 *)(v3 + 54);
      v13 = v18 >= v6;
      if (v18 != v6)
        goto LABEL_4;
      v19 = *(unsigned __int16 *)(v3 + 40);
      v13 = v19 >= v7;
      if (v19 != v7)
        goto LABEL_4;
      v20 = *(unsigned __int16 *)(v3 + 52);
      v13 = v20 >= v8;
      if (v20 != v8)
        goto LABEL_4;
      v21 = *(unsigned __int8 *)(v3 + 44);
      if ((v9 != 0) == (*(_BYTE *)(v3 + 44) != 0))
        break;
      v22 = v9 == 0;
LABEL_22:
      v24 = !v22 && v21 == 0;
      v25 = v24 == 0;
      if (v24)
        v26 = (uint64_t *)(v3 + 8);
      else
        v26 = (uint64_t *)v3;
      if (v25)
        v11 = v3;
      v3 = *v26;
      if (!*v26)
        goto LABEL_35;
    }
    v21 = *(unsigned __int8 *)(v3 + 56);
    if ((v10 != 0) != (*(_BYTE *)(v3 + 56) != 0))
    {
      v22 = v10 == 0;
      goto LABEL_22;
    }
    v13 = *(unsigned __int8 *)(v3 + 32) >= v12;
LABEL_4:
    v14 = !v13;
    v15 = v14 == 0;
    if (v14)
      v16 = (uint64_t *)(v3 + 8);
    else
      v16 = (uint64_t *)v3;
    if (v15)
      v11 = v3;
    v3 = *v16;
  }
  while (*v16);
LABEL_35:
  if (v11 == v2)
    return v2;
  v27 = *(unsigned __int16 *)(v11 + 42);
  v28 = v5 >= v27;
  if (v5 != v27
    || (v29 = *(unsigned __int16 *)(v11 + 54), v28 = v6 >= v29, v6 != v29)
    || (v30 = *(unsigned __int16 *)(v11 + 40), v28 = v7 >= v30, v7 != v30)
    || (v31 = *(unsigned __int16 *)(v11 + 52), v28 = v8 >= v31, v8 != v31))
  {
    if (v28)
      return v11;
    return v2;
  }
  if ((v9 != 0) != (*(_BYTE *)(v11 + 44) != 0))
  {
    if (*(_BYTE *)(v11 + 44))
      v32 = v9 == 0;
    else
      v32 = 0;
    if (!v32)
      return v11;
    return v2;
  }
  if ((v10 != 0) == (*(_BYTE *)(v11 + 56) != 0))
  {
    if (v12 >= *(unsigned __int8 *)(v11 + 32))
      return v11;
    return v2;
  }
  if (*(_BYTE *)(v11 + 56))
    v34 = v10 == 0;
  else
    v34 = 0;
  if (v34)
    return v2;
  return v11;
}

void rtc::FunctionView<void ()(unsigned short,webrtc::TimeDelta)>::CallVoidPtr<webrtc::TransportFeedbackAdapter::ProcessTransportFeedbackInner(webrtc::rtcp::TransportFeedback const&,webrtc::Timestamp)::$_0>(_QWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5;
  unsigned int v6;
  BOOL v7;
  uint64_t v8;
  int v9;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  BOOL v18;
  uint64_t **v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  BOOL v23;
  uint64_t **v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;
  BOOL v30;
  uint64_t **v31;
  _QWORD *v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  BOOL v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t *v52;
  uint64_t *v53;
  int v54;
  void **v55;
  unint64_t v56;
  char *v57;
  char *v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  char *v64;
  char *v65;
  char *v66;
  char *v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  uint64_t v76;
  int v77;
  int v78;
  int v79;
  int v80;
  char v81;
  uint64_t v82;
  _BYTE v83[15];
  __int128 v84;
  uint64_t v85;

  v5 = *a1;
  if (*(_BYTE *)(*a1 + 34))
  {
    v6 = *(unsigned __int16 *)(v5 + 32);
    v7 = a2 >= v6;
    LODWORD(v8) = a2 - v6;
    v9 = (_DWORD)v8 != 0 && v7;
    v10 = (v8 & 0x8000u) == 0;
    if ((_DWORD)v8 == 0x8000)
      v10 = v9;
    if (v10)
      v8 = (unsigned __int16)v8;
    else
      v8 |= 0xFFFFFFFFFFFF0000;
    v11 = v8 + *(_QWORD *)(v5 + 24);
  }
  else
  {
    v11 = a2;
  }
  v13 = (uint64_t **)(v5 + 48);
  v12 = *(uint64_t **)(v5 + 48);
  *(_QWORD *)(v5 + 24) = v11;
  *(_WORD *)(v5 + 32) = a2;
  *(_BYTE *)(v5 + 34) = 1;
  v14 = *(_QWORD *)(v5 + 64);
  if (v11 > v14)
  {
    v15 = (uint64_t *)(v5 + 48);
    if (v12)
    {
      v15 = (uint64_t *)(v5 + 48);
      v16 = v12;
      do
      {
        v17 = v16[4];
        v18 = v14 < v17;
        if (v14 >= v17)
          v19 = (uint64_t **)(v16 + 1);
        else
          v19 = (uint64_t **)v16;
        if (v18)
          v15 = v16;
        v16 = *v19;
      }
      while (*v19);
    }
    while (1)
    {
      v20 = (uint64_t *)(v5 + 48);
      if (v12)
      {
        v20 = (uint64_t *)(v5 + 48);
        v21 = v12;
        do
        {
          v22 = v21[4];
          v23 = v11 < v22;
          if (v11 >= v22)
            v24 = (uint64_t **)(v21 + 1);
          else
            v24 = (uint64_t **)v21;
          if (v23)
            v20 = v21;
          v21 = *v24;
        }
        while (*v24);
      }
      if (v15 == v20)
        break;
      webrtc::InFlightBytesTracker::RemoveInFlightPacketBytes((_QWORD *)(v5 + 72), (uint64_t)(v15 + 5));
      v25 = (uint64_t *)v15[1];
      if (v25)
      {
        do
        {
          v26 = v25;
          v25 = (uint64_t *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          v26 = (uint64_t *)v15[2];
          v49 = *v26 == (_QWORD)v15;
          v15 = v26;
        }
        while (!v49);
      }
      v12 = *v13;
      v15 = v26;
    }
    *(_QWORD *)(v5 + 64) = v11;
  }
  if (!v12)
    goto LABEL_49;
  v27 = (uint64_t *)(v5 + 48);
  v28 = v12;
  do
  {
    v29 = v28[4];
    v30 = v29 < v11;
    if (v29 >= v11)
      v31 = (uint64_t **)v28;
    else
      v31 = (uint64_t **)(v28 + 1);
    if (!v30)
      v27 = v28;
    v28 = *v31;
  }
  while (*v31);
  if (v27 == (uint64_t *)v13 || v11 < v27[4])
  {
LABEL_49:
    v32 = (_QWORD *)a1[1];
LABEL_50:
    ++*v32;
    return;
  }
  v33 = v27[6];
  if ((unint64_t)(v33 - 0x7FFFFFFFFFFFFFFFLL) < 2)
    return;
  v84 = *(_OWORD *)(v27 + 7);
  v85 = v27[9];
  v77 = *((_DWORD *)v27 + 20);
  v78 = *((_DWORD *)v27 + 21);
  v79 = *((_DWORD *)v27 + 22);
  v80 = *((_DWORD *)v27 + 23);
  v81 = *((_BYTE *)v27 + 96);
  v82 = v27[14];
  *(_QWORD *)v83 = *(uint64_t *)((char *)v27 + 97);
  *(_QWORD *)&v83[7] = v27[13];
  v34 = *((unsigned __int8 *)v27 + 128);
  v35 = *((_DWORD *)v27 + 33);
  v36 = *((unsigned __int16 *)v27 + 68);
  v37 = *((unsigned __int16 *)v27 + 69);
  v38 = *((unsigned __int8 *)v27 + 140);
  v39 = *((_DWORD *)v27 + 36);
  v40 = *((unsigned __int16 *)v27 + 74);
  v41 = *((unsigned __int16 *)v27 + 75);
  v42 = *((unsigned __int8 *)v27 + 152);
  v43 = 0x7FFFFFFFFFFFFFFFLL;
  v44 = *((_DWORD *)v27 + 39);
  v45 = *((_DWORD *)v27 + 40);
  if ((unint64_t)(a3 + 0x7FFFFFFFFFFFFFFFLL) > 0xFFFFFFFFFFFFFFFDLL)
  {
    v76 = v27[15];
    if (v34 != *(unsigned __int8 *)(v5 + 112))
    {
LABEL_88:
      v32 = (_QWORD *)a1[3];
      goto LABEL_50;
    }
  }
  else
  {
    v73 = *((_DWORD *)v27 + 36);
    v74 = *((unsigned __int16 *)v27 + 74);
    v75 = *((unsigned __int16 *)v27 + 75);
    v46 = 1000 * (a3 / 1000);
    v47 = *(_QWORD *)(v5 + 96);
    v48 = 0x8000000000000000;
    v49 = v46 == 0x8000000000000000 || v47 == 0x8000000000000000;
    if (!v49)
      v48 = v47 + v46;
    if (v46 == 0x7FFFFFFFFFFFFFFFLL)
      v50 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v50 = v48;
    if (v47 != 0x7FFFFFFFFFFFFFFFLL)
      v43 = v50;
    v76 = v43;
    v51 = (uint64_t *)v27[1];
    v71 = *((_DWORD *)v27 + 33);
    v72 = *((unsigned __int16 *)v27 + 68);
    if (v51)
    {
      do
      {
        v52 = v51;
        v51 = (uint64_t *)*v51;
      }
      while (v51);
    }
    else
    {
      v53 = v27;
      do
      {
        v52 = (uint64_t *)v53[2];
        v49 = *v52 == (_QWORD)v53;
        v53 = v52;
      }
      while (!v49);
    }
    v54 = *((unsigned __int8 *)v27 + 140);
    if (*(uint64_t **)(v5 + 40) == v27)
      *(_QWORD *)(v5 + 40) = v52;
    --*(_QWORD *)(v5 + 56);
    std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v12, v27);
    operator delete(v27);
    v40 = v74;
    v41 = v75;
    v36 = v72;
    v39 = v73;
    v38 = v54;
    v35 = v71;
    if (v34 != *(unsigned __int8 *)(v5 + 112))
      goto LABEL_88;
  }
  if (v35 != *(_DWORD *)(v5 + 116)
    || v36 != *(unsigned __int16 *)(v5 + 120)
    || v37 != *(unsigned __int16 *)(v5 + 122)
    || v38 != *(unsigned __int8 *)(v5 + 124)
    || v39 != *(_DWORD *)(v5 + 128)
    || v40 != *(unsigned __int16 *)(v5 + 132)
    || v41 != *(unsigned __int16 *)(v5 + 134)
    || v42 != *(unsigned __int8 *)(v5 + 136)
    || v45 != *(_DWORD *)(v5 + 144)
    || v44 != *(_DWORD *)(v5 + 140))
  {
    goto LABEL_88;
  }
  v55 = (void **)a1[2];
  v57 = (char *)v55[1];
  v56 = (unint64_t)v55[2];
  if ((unint64_t)v57 < v56)
  {
    if (v57)
    {
      *(_QWORD *)v57 = v33;
      *(_OWORD *)(v57 + 8) = v84;
      *((_QWORD *)v57 + 3) = v85;
      *((_DWORD *)v57 + 8) = v77;
      *((_DWORD *)v57 + 9) = v78;
      *((_DWORD *)v57 + 10) = v79;
      *((_DWORD *)v57 + 11) = v80;
      v57[48] = v81;
      *(_QWORD *)(v57 + 49) = *(_QWORD *)v83;
      *((_QWORD *)v57 + 7) = *(_QWORD *)&v83[7];
      *((_QWORD *)v57 + 8) = v82;
      *((_QWORD *)v57 + 9) = v76;
      v55[1] = v57 + 80;
      return;
    }
    goto LABEL_103;
  }
  v58 = (char *)*v55;
  v59 = 0xCCCCCCCCCCCCCCCDLL * ((v57 - (_BYTE *)*v55) >> 4);
  v60 = v59 + 1;
  if (v59 + 1 > 0x333333333333333)
    goto LABEL_104;
  v61 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v56 - (_QWORD)v58) >> 4);
  if (2 * v61 > v60)
    v60 = 2 * v61;
  if (v61 >= 0x199999999999999)
    v62 = 0x333333333333333;
  else
    v62 = v60;
  if (!v62)
  {
LABEL_103:
    __break(1u);
LABEL_104:
    abort();
  }
  if (v62 > 0x333333333333333)
    std::__throw_bad_array_new_length[abi:sn180100]();
  v63 = 80 * v62;
  v64 = (char *)operator new(80 * v62);
  v65 = &v64[80 * v59];
  *(_QWORD *)v65 = v33;
  v66 = &v64[v63];
  *(_OWORD *)(v65 + 8) = v84;
  *((_QWORD *)v65 + 3) = v85;
  *((_DWORD *)v65 + 8) = v77;
  *((_DWORD *)v65 + 9) = v78;
  *((_DWORD *)v65 + 10) = v79;
  *((_DWORD *)v65 + 11) = v80;
  v65[48] = v81;
  *(_QWORD *)(v65 + 49) = *(_QWORD *)v83;
  *((_QWORD *)v65 + 7) = *(_QWORD *)&v83[7];
  *((_QWORD *)v65 + 8) = v82;
  v67 = v65 + 80;
  *((_QWORD *)v65 + 9) = v76;
  if (v57 != v58)
  {
    do
    {
      *((_OWORD *)v65 - 5) = *((_OWORD *)v57 - 5);
      v68 = *((_OWORD *)v57 - 4);
      v69 = *((_OWORD *)v57 - 3);
      v70 = *((_OWORD *)v57 - 1);
      *((_OWORD *)v65 - 2) = *((_OWORD *)v57 - 2);
      *((_OWORD *)v65 - 1) = v70;
      *((_OWORD *)v65 - 4) = v68;
      *((_OWORD *)v65 - 3) = v69;
      v65 -= 80;
      v57 -= 80;
    }
    while (v57 != v58);
    v57 = v58;
  }
  *v55 = v65;
  v55[1] = v67;
  v55[2] = v66;
  if (v57)
    operator delete(v57);
  v55[1] = v67;
}

void webrtc::TransportFeedbackDemuxer::RegisterStreamFeedbackObserver(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const void *v6;
  int64_t v7;
  char *v8;
  char *v9;
  unint64_t v10;
  char *v11;
  _QWORD *v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  BOOL v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;
  char *v24;
  char *v25;
  void *v26;
  void *v27;

  v6 = *(const void **)a2;
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v5 - *(_QWORD *)a2;
  if (v5 == *(_QWORD *)a2)
  {
    v9 = 0;
    v8 = 0;
    v11 = (char *)a1[7];
    v10 = a1[8];
    if ((unint64_t)v11 < v10)
    {
LABEL_4:
      if (v11)
      {
        *(_QWORD *)v11 = v8;
        *((_QWORD *)v11 + 1) = v9;
        v12 = v11 + 32;
        *((_QWORD *)v11 + 2) = v9;
        *((_QWORD *)v11 + 3) = a3;
        goto LABEL_24;
      }
      goto LABEL_25;
    }
  }
  else
  {
    if (v7 < 0)
      goto LABEL_26;
    v8 = (char *)operator new(v5 - *(_QWORD *)a2);
    v9 = &v8[4 * (v7 >> 2)];
    memcpy(v8, v6, v7);
    v11 = (char *)a1[7];
    v10 = a1[8];
    if ((unint64_t)v11 < v10)
      goto LABEL_4;
  }
  v13 = (char *)a1[6];
  v14 = (v11 - v13) >> 5;
  v15 = v14 + 1;
  if ((unint64_t)(v14 + 1) >> 59)
    goto LABEL_26;
  v16 = v10 - (_QWORD)v13;
  if (v16 >> 4 > v15)
    v15 = v16 >> 4;
  v17 = (unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0;
  v18 = 0x7FFFFFFFFFFFFFFLL;
  if (!v17)
    v18 = v15;
  if (!v18)
  {
LABEL_25:
    __break(1u);
LABEL_26:
    abort();
  }
  if (v18 >> 59)
    std::__throw_bad_array_new_length[abi:sn180100]();
  v19 = 32 * v18;
  v20 = (char *)operator new(32 * v18);
  v21 = &v20[32 * v14];
  *(_QWORD *)v21 = v8;
  *((_QWORD *)v21 + 1) = v9;
  v22 = &v20[v19];
  *((_QWORD *)v21 + 2) = v9;
  *((_QWORD *)v21 + 3) = a3;
  v12 = v21 + 32;
  if (v11 == v13)
  {
    a1[6] = v21;
    a1[7] = v12;
    a1[8] = v22;
  }
  else
  {
    do
    {
      v23 = *((_OWORD *)v11 - 2);
      v11 -= 32;
      *((_OWORD *)v21 - 2) = v23;
      v21 -= 32;
      *((_QWORD *)v21 + 2) = *((_QWORD *)v11 + 2);
      *(_QWORD *)v11 = 0;
      *((_QWORD *)v11 + 1) = 0;
      *((_QWORD *)v11 + 2) = 0;
      *((_QWORD *)v21 + 3) = *((_QWORD *)v11 + 3);
    }
    while (v11 != v13);
    v11 = (char *)a1[6];
    v24 = (char *)a1[7];
    a1[6] = v21;
    a1[7] = v12;
    a1[8] = v22;
    if (v24 != v11)
    {
      v25 = v24;
      do
      {
        v27 = (void *)*((_QWORD *)v25 - 4);
        v25 -= 32;
        v26 = v27;
        if (v27)
        {
          *((_QWORD *)v24 - 3) = v26;
          operator delete(v26);
        }
        v24 = v25;
      }
      while (v25 != v11);
    }
  }
  if (v11)
    operator delete(v11);
LABEL_24:
  a1[7] = v12;
}

void webrtc::TransportFeedbackDemuxer::DeRegisterStreamFeedbackObserver(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;

  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(_QWORD *)(a1 + 56);
  if (v3 == v4)
    goto LABEL_5;
  do
  {
    if (*(_QWORD *)(v3 + 24) == a2)
      goto LABEL_5;
    v3 += 32;
  }
  while (v3 != v4);
  do
  {
    __break(1u);
LABEL_5:
    ;
  }
  while (v4 == v3);
  if (v3 + 32 == v4)
  {
    if (v4 == v3)
      goto LABEL_17;
    goto LABEL_13;
  }
  do
  {
    v9 = *(void **)v3;
    if (*(_QWORD *)v3)
    {
      *(_QWORD *)(v3 + 8) = v9;
      operator delete(v9);
      *(_QWORD *)(v3 + 8) = 0;
      *(_QWORD *)(v3 + 16) = 0;
    }
    v5 = v3 + 32;
    *(_OWORD *)v3 = *(_OWORD *)(v3 + 32);
    v6 = *(_QWORD *)(v3 + 48);
    v7 = *(_QWORD *)(v3 + 56);
    *(_QWORD *)(v3 + 40) = 0;
    *(_QWORD *)(v3 + 48) = 0;
    *(_QWORD *)(v3 + 32) = 0;
    *(_QWORD *)(v3 + 16) = v6;
    *(_QWORD *)(v3 + 24) = v7;
    v8 = v3 + 64;
    v3 += 32;
  }
  while (v8 != v4);
  v4 = *(_QWORD *)(a1 + 56);
  v3 = v5;
  if (v4 != v5)
  {
LABEL_13:
    v10 = v4;
    do
    {
      v12 = *(void **)(v10 - 32);
      v10 -= 32;
      v11 = v12;
      if (v12)
      {
        *(_QWORD *)(v4 - 24) = v11;
        operator delete(v11);
      }
      v4 = v10;
    }
    while (v10 != v3);
  }
LABEL_17:
  *(_QWORD *)(a1 + 56) = v3;
}

void webrtc::TransportFeedbackDemuxer::AddPacket(uint64_t a1, unsigned __int16 *a2)
{
  char v3;
  BOOL v4;
  char v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  BOOL v9;
  uint64_t v10;
  int v11;
  _BOOL4 v12;
  char v13;
  unsigned __int16 v14;
  uint64_t *v15;
  uint64_t **v16;
  uint64_t **v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t *v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  __int16 v27;
  char v28;

  v3 = *((_BYTE *)a2 + 4);
  v27 = *(unsigned __int16 *)((char *)a2 + 5);
  v28 = *((_BYTE *)a2 + 7);
  if (*((_BYTE *)a2 + 40))
    v4 = *((_QWORD *)a2 + 4) == 2;
  else
    v4 = 0;
  v5 = v4;
  v6 = *a2;
  v7 = *a2;
  if (*(_BYTE *)(a1 + 18))
  {
    v8 = *(unsigned __int16 *)(a1 + 16);
    v9 = v6 >= v8;
    LODWORD(v10) = v6 - v8;
    v11 = (_DWORD)v10 != 0 && v9;
    v12 = (v10 & 0x8000u) == 0;
    if ((_DWORD)v10 == 0x8000)
      v12 = v11;
    if (v12)
      v10 = (unsigned __int16)v10;
    else
      v10 |= 0xFFFFFFFFFFFF0000;
    v7 = v10 + *(_QWORD *)(a1 + 8);
  }
  v13 = *((_BYTE *)a2 + 8);
  v14 = a2[6];
  v16 = (uint64_t **)(a1 + 32);
  v15 = *(uint64_t **)(a1 + 32);
  *(_QWORD *)(a1 + 8) = v7;
  *(_WORD *)(a1 + 16) = v6;
  *(_BYTE *)(a1 + 18) = 1;
  if (!v15)
  {
    v17 = (uint64_t **)(a1 + 32);
LABEL_24:
    v19 = (char *)operator new(0x38uLL);
    *((_QWORD *)v19 + 4) = v7;
    v19[40] = 0;
    v19[44] = v3;
    *(_WORD *)(v19 + 45) = v27;
    v19[47] = v28;
    v19[48] = v13;
    *((_WORD *)v19 + 26) = v14;
    v19[54] = v5;
    *(_QWORD *)v19 = 0;
    *((_QWORD *)v19 + 1) = 0;
    *((_QWORD *)v19 + 2) = v17;
    *v16 = (uint64_t *)v19;
    v20 = **(_QWORD **)(a1 + 24);
    if (v20)
    {
      *(_QWORD *)(a1 + 24) = v20;
      v21 = *v16;
    }
    else
    {
      v21 = (uint64_t *)v19;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 32), v21);
    v22 = *(_QWORD *)(a1 + 40) + 1;
    *(_QWORD *)(a1 + 40) = v22;
    if (v22 < 0x1389)
      return;
    do
    {
LABEL_32:
      v23 = *(uint64_t **)(a1 + 24);
      v24 = (uint64_t *)v23[1];
      v25 = v23;
      if (v24)
      {
        do
        {
          v26 = v24;
          v24 = (uint64_t *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          v26 = (uint64_t *)v25[2];
          v4 = *v26 == (_QWORD)v25;
          v25 = v26;
        }
        while (!v4);
      }
      *(_QWORD *)(a1 + 24) = v26;
      *(_QWORD *)(a1 + 40) = v22 - 1;
      std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 32), v23);
      operator delete(v23);
      v22 = *(_QWORD *)(a1 + 40);
    }
    while (v22 > 0x1388);
    return;
  }
  while (1)
  {
    while (1)
    {
      v17 = (uint64_t **)v15;
      v18 = v15[4];
      if (v7 >= v18)
        break;
      v15 = (uint64_t *)*v15;
      v16 = v17;
      if (!*v17)
        goto LABEL_24;
    }
    if (v18 >= v7)
      break;
    v15 = (uint64_t *)v15[1];
    if (!v15)
    {
      v16 = v17 + 1;
      goto LABEL_24;
    }
  }
  v22 = *(_QWORD *)(a1 + 40);
  if (v22 >= 0x1389)
    goto LABEL_32;
}

void webrtc::TransportFeedbackDemuxer::OnTransportFeedback(webrtc::TransportFeedbackDemuxer *this, const webrtc::rtcp::TransportFeedback *a2, double a3, double a4, double a5, double a6, double a7, int64x2_t a8, int64x2_t a9)
{
  uint64_t v11;
  int v12;
  unsigned __int16 v13;
  unsigned __int16 *v14;
  unint64_t v15;
  _DWORD *v16;
  int32x4_t **v17;
  int32x4_t **v18;
  int8x16_t v19;
  _DWORD *v20;
  _DWORD *v21;
  char *v22;
  char *v23;
  char *v24;
  int32x4_t *v25;
  int32x4_t *v26;
  unsigned int v27;
  unint64_t v28;
  uint64_t v29;
  int32x4_t *v30;
  uint64_t v31;
  int32x4_t v32;
  int32x4_t *v33;
  int64x2_t v34;
  uint64_t v35;
  int64x2_t v36;
  int64x2_t v37;
  int64x2_t v38;
  int8x8_t v39;
  uint16x4_t v40;
  uint32x4_t v41;
  int8x16_t v42;
  int64x2_t v43;
  uint32x4_t v44;
  int64x2_t v45;
  int v46;
  __int32 v47;
  BOOL v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  char *v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  int32x4_t *v58;
  int8x16_t v59;
  char *v60;
  char *v61;
  char *v62;
  _QWORD v63[2];
  void *__p;
  _DWORD *v65;
  uint64_t v66;

  __p = 0;
  v65 = 0;
  v66 = 0;
  v63[0] = this;
  v63[1] = &__p;
  if (*((_WORD *)a2 + 9))
  {
    v11 = 0;
    v12 = *((unsigned __int16 *)a2 + 8);
    v13 = *((_WORD *)a2 + 9) + v12;
    v14 = (unsigned __int16 *)*((_QWORD *)a2 + 5);
    do
    {
      while (v14 == *((unsigned __int16 **)a2 + 6) || *v14 != (unsigned __int16)v12)
      {
        rtc::FunctionView<void ()(unsigned short,webrtc::TimeDelta)>::CallVoidPtr<webrtc::TransportFeedbackDemuxer::OnTransportFeedback(webrtc::rtcp::TransportFeedback const&)::$_1>(v63, (unsigned __int16)v12++, 0x7FFFFFFFFFFFFFFFLL);
        if ((unsigned __int16)v12 == v13)
          goto LABEL_11;
      }
      v15 = v11 + 250 * (__int16)v14[1];
      if (v11 == 0x8000000000000000)
        v15 = 0x8000000000000000;
      if (v11 != 0x7FFFFFFFFFFFFFFFLL)
        v11 = v15;
      rtc::FunctionView<void ()(unsigned short,webrtc::TimeDelta)>::CallVoidPtr<webrtc::TransportFeedbackDemuxer::OnTransportFeedback(webrtc::rtcp::TransportFeedback const&)::$_1>(v63, (unsigned __int16)v12, v11);
      v14 += 2;
      ++v12;
    }
    while ((unsigned __int16)v12 != v13);
LABEL_11:
    v16 = __p;
    v17 = (int32x4_t **)*((_QWORD *)this + 6);
    v18 = (int32x4_t **)*((_QWORD *)this + 7);
    if (v17 == v18)
      goto LABEL_58;
  }
  else
  {
    v16 = 0;
    v17 = (int32x4_t **)*((_QWORD *)this + 6);
    v18 = (int32x4_t **)*((_QWORD *)this + 7);
    if (v17 == v18)
      goto LABEL_58;
  }
  if (v16 == v65)
    goto LABEL_58;
  v19 = (int8x16_t)vdupq_n_s64(1uLL);
  v59 = v19;
  while (2)
  {
    v20 = __p;
    v21 = v65;
    if (__p == v65 || *v17 == v17[1])
      goto LABEL_18;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    do
    {
      v26 = *v17;
      v25 = v17[1];
      if (*v17 == v25)
        goto LABEL_23;
      v27 = v20[1];
      v28 = (char *)v25 - (char *)v26 - 4;
      if (v28 >= 0x1C)
      {
        v31 = (v28 >> 2) + 1;
        v30 = (int32x4_t *)((char *)v26 + 4 * (v31 & 0x7FFFFFFFFFFFFFF8));
        v32 = vdupq_n_s32(v27);
        v33 = v26 + 1;
        v34 = 0uLL;
        v35 = v31 & 0x7FFFFFFFFFFFFFF8;
        v36 = 0uLL;
        v37 = 0uLL;
        v38 = 0uLL;
        do
        {
          a8.i32[0] = 0;
          a9.i32[0] = *((unsigned __int8 *)v20 + 8);
          v39 = (int8x8_t)vdup_lane_s32((int32x2_t)vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)a9.i8, *(int32x2_t *)a8.i8)), 0);
          v40 = (uint16x4_t)vand_s8((int8x8_t)vmovn_s32(vceqq_s32(*v33, v32)), v39);
          v41 = vmovl_u16((uint16x4_t)vand_s8((int8x8_t)vmovn_s32(vceqq_s32(v33[-1], v32)), v39));
          v42.i64[0] = v41.u32[0];
          v42.i64[1] = v41.u32[1];
          v43 = (int64x2_t)vandq_s8(v42, v19);
          v42.i64[0] = v41.u32[2];
          v42.i64[1] = v41.u32[3];
          a8 = (int64x2_t)vandq_s8(v42, v19);
          v44 = vmovl_u16(v40);
          v42.i64[0] = v44.u32[0];
          v42.i64[1] = v44.u32[1];
          v45 = (int64x2_t)vandq_s8(v42, v19);
          v42.i64[0] = v44.u32[2];
          v42.i64[1] = v44.u32[3];
          a9 = (int64x2_t)vandq_s8(v42, v19);
          v36 = vaddq_s64(v36, a8);
          v34 = vaddq_s64(v34, v43);
          v38 = vaddq_s64(v38, a9);
          v37 = vaddq_s64(v37, v45);
          v33 += 2;
          v35 -= 8;
        }
        while (v35);
        v29 = vaddvq_s64(vaddq_s64(vaddq_s64(v37, v34), vaddq_s64(v38, v36)));
        if (v31 == (v31 & 0x7FFFFFFFFFFFFFF8))
          goto LABEL_36;
      }
      else
      {
        v29 = 0;
        v30 = *v17;
      }
      do
      {
        v47 = v30->i32[0];
        v30 = (int32x4_t *)((char *)v30 + 4);
        v46 = v47;
        if (*((_BYTE *)v20 + 8))
          v48 = v46 == v27;
        else
          v48 = 0;
        if (v48)
          ++v29;
      }
      while (v30 != v25);
LABEL_36:
      if (v29)
      {
        if (v23 >= v22)
        {
          v49 = (v23 - v24) >> 4;
          v50 = v49 + 1;
          if ((unint64_t)(v49 + 1) >> 60)
            goto LABEL_62;
          if ((v22 - v24) >> 3 > v50)
            v50 = (v22 - v24) >> 3;
          if ((unint64_t)(v22 - v24) >= 0x7FFFFFFFFFFFFFF0)
            v50 = 0xFFFFFFFFFFFFFFFLL;
          if (!v50)
          {
LABEL_61:
            __break(1u);
LABEL_62:
            abort();
          }
          if (v50 >> 60)
            std::__throw_bad_array_new_length[abi:sn180100]();
          v51 = 16 * v50;
          v52 = (char *)operator new(16 * v50);
          v53 = &v52[16 * v49];
          *(_OWORD *)v53 = *(_OWORD *)v20;
          if (v23 == v24)
          {
            v57 = v23;
            v24 = &v52[16 * v49];
            v22 = &v52[v51];
            v23 = v53 + 16;
            if (v57)
              goto LABEL_53;
          }
          else
          {
            v54 = &v52[16 * v49];
            do
            {
              v55 = *((_QWORD *)v23 - 2);
              v23 -= 16;
              v56 = *(_QWORD *)(v23 + 7);
              *((_QWORD *)v54 - 2) = v55;
              v54 -= 16;
              *(_QWORD *)(v54 + 7) = v56;
            }
            while (v23 != v24);
            v57 = v24;
            v24 = v54;
            v22 = &v52[v51];
            v23 = v53 + 16;
            if (!v57)
              goto LABEL_22;
LABEL_53:
            operator delete(v57);
          }
LABEL_22:
          v19 = v59;
          goto LABEL_23;
        }
        if (!v23)
          goto LABEL_61;
        *(_OWORD *)v23 = *(_OWORD *)v20;
        v23 += 16;
      }
LABEL_23:
      v20 += 4;
    }
    while (v20 != v21);
    if (v24 == v23)
    {
      if (v24)
        goto LABEL_17;
    }
    else
    {
      v58 = v17[3];
      v60 = v24;
      v61 = v23;
      v62 = v22;
      (*(void (**)(int32x4_t *, char **))(v58->i64[0] + 16))(v58, &v60);
      v19 = v59;
      v24 = v60;
      if (v60)
      {
        v61 = v60;
LABEL_17:
        operator delete(v24);
        v19 = v59;
      }
    }
LABEL_18:
    v17 += 4;
    if (v17 != v18)
      continue;
    break;
  }
  v16 = __p;
LABEL_58:
  if (v16)
  {
    v65 = v16;
    operator delete(v16);
  }
}

void webrtc::TransportFeedbackDemuxer::~TransportFeedbackDemuxer(webrtc::TransportFeedbackDemuxer *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;

  v2 = *((_QWORD *)this + 6);
  if (v2)
  {
    v3 = *((_QWORD *)this + 7);
    v4 = (void *)*((_QWORD *)this + 6);
    if (v3 != v2)
    {
      v5 = *((_QWORD *)this + 7);
      do
      {
        v7 = *(void **)(v5 - 32);
        v5 -= 32;
        v6 = v7;
        if (v7)
        {
          *(_QWORD *)(v3 - 24) = v6;
          operator delete(v6);
        }
        v3 = v5;
      }
      while (v5 != v2);
      v4 = (void *)*((_QWORD *)this + 6);
    }
    *((_QWORD *)this + 7) = v2;
    operator delete(v4);
  }
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 24, *((_QWORD **)this + 4));
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;

  v2 = *((_QWORD *)this + 6);
  if (v2)
  {
    v3 = *((_QWORD *)this + 7);
    v4 = (void *)*((_QWORD *)this + 6);
    if (v3 != v2)
    {
      v5 = *((_QWORD *)this + 7);
      do
      {
        v7 = *(void **)(v5 - 32);
        v5 -= 32;
        v6 = v7;
        if (v7)
        {
          *(_QWORD *)(v3 - 24) = v6;
          operator delete(v6);
        }
        v3 = v5;
      }
      while (v5 != v2);
      v4 = (void *)*((_QWORD *)this + 6);
    }
    *((_QWORD *)this + 7) = v2;
    operator delete(v4);
  }
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 24, *((_QWORD **)this + 4));
  JUMPOUT(0x20BD0ADECLL);
}

void rtc::FunctionView<void ()(unsigned short,webrtc::TimeDelta)>::CallVoidPtr<webrtc::TransportFeedbackDemuxer::OnTransportFeedback(webrtc::rtcp::TransportFeedback const&)::$_1>(_QWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  uint64_t v6;
  int v7;
  _BOOL4 v8;
  uint64_t v9;
  uint64_t *v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  BOOL v14;
  _QWORD *v15;
  unint64_t v16;
  BOOL v17;
  BOOL **v18;
  unint64_t v19;
  BOOL *v20;
  BOOL *v21;
  BOOL *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  BOOL *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t *v35;
  BOOL v36;
  uint64_t *v37;
  _BYTE v38[15];

  v3 = *a1;
  if (!*(_BYTE *)(*a1 + 18))
  {
    v9 = a2;
    v10 = (uint64_t *)(v3 + 32);
    v11 = *(_QWORD **)(v3 + 32);
    if (!v11)
      return;
LABEL_13:
    v12 = v10;
    do
    {
      v13 = v11[4];
      v14 = v13 < v9;
      if (v13 >= v9)
        v15 = v11;
      else
        v15 = v11 + 1;
      if (!v14)
        v12 = v11;
      v11 = (_QWORD *)*v15;
    }
    while (*v15);
    if (v12 == v10 || v9 < v12[4])
      return;
    *(_QWORD *)v38 = *(uint64_t *)((char *)v12 + 41);
    *(_QWORD *)&v38[7] = v12[6];
    v16 = a3 + 0x7FFFFFFFFFFFFFFFLL;
    v17 = (unint64_t)(a3 + 0x7FFFFFFFFFFFFFFFLL) < 0xFFFFFFFFFFFFFFFELL;
    v18 = (BOOL **)a1[1];
    v20 = v18[1];
    v19 = (unint64_t)v18[2];
    if ((unint64_t)v20 >= v19)
    {
      v22 = *v18;
      v23 = (v20 - *v18) >> 4;
      v24 = v23 + 1;
      if ((unint64_t)(v23 + 1) >> 60)
        goto LABEL_49;
      v25 = v19 - (_QWORD)v22;
      if (v25 >> 3 > v24)
        v24 = v25 >> 3;
      v5 = (unint64_t)v25 >= 0x7FFFFFFFFFFFFFF0;
      v26 = 0xFFFFFFFFFFFFFFFLL;
      if (!v5)
        v26 = v24;
      if (v26)
      {
        if (v26 >> 60)
          std::__throw_bad_array_new_length[abi:sn180100]();
        v27 = 16 * v26;
        v28 = (char *)operator new(16 * v26);
        v29 = &v28[v27];
        v30 = (BOOL *)&v28[16 * v23];
        *v30 = v17;
        *(_QWORD *)(v30 + 1) = *(_QWORD *)v38;
        *((_QWORD *)v30 + 1) = *(_QWORD *)&v38[7];
        v21 = v30 + 16;
        if (v20 != v22)
        {
          do
          {
            v31 = *((_QWORD *)v20 - 2);
            v20 -= 16;
            v32 = *(_QWORD *)(v20 + 7);
            *((_QWORD *)v30 - 2) = v31;
            v30 -= 16;
            *(_QWORD *)(v30 + 7) = v32;
          }
          while (v20 != v22);
          v20 = v22;
        }
        *v18 = v30;
        v18[1] = v21;
        v18[2] = (BOOL *)v29;
        if (v20)
          operator delete(v20);
        goto LABEL_37;
      }
    }
    else if (v20)
    {
      *v20 = v17;
      *(_QWORD *)(v20 + 1) = *(_QWORD *)v38;
      *((_QWORD *)v20 + 1) = *(_QWORD *)&v38[7];
      v21 = v20 + 16;
LABEL_37:
      v18[1] = v21;
      if (v16 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v33 = (uint64_t *)v12[1];
        if (v33)
        {
          do
          {
            v34 = v33;
            v33 = (uint64_t *)*v33;
          }
          while (v33);
        }
        else
        {
          v35 = v12;
          do
          {
            v34 = (uint64_t *)v35[2];
            v36 = *v34 == (_QWORD)v35;
            v35 = v34;
          }
          while (!v36);
        }
        if (*(uint64_t **)(v3 + 24) == v12)
          *(_QWORD *)(v3 + 24) = v34;
        v37 = *(uint64_t **)(v3 + 32);
        --*(_QWORD *)(v3 + 40);
        std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v37, v12);
        operator delete(v12);
      }
      return;
    }
    __break(1u);
LABEL_49:
    abort();
  }
  v4 = *(unsigned __int16 *)(v3 + 16);
  v5 = a2 >= v4;
  LODWORD(v6) = a2 - v4;
  v7 = (_DWORD)v6 != 0 && v5;
  v8 = (v6 & 0x8000u) == 0;
  if ((_DWORD)v6 == 0x8000)
    v8 = v7;
  if (v8)
    v6 = (unsigned __int16)v6;
  else
    v6 |= 0xFFFFFFFFFFFF0000;
  v9 = v6 + *(_QWORD *)(v3 + 8);
  v10 = (uint64_t *)(v3 + 32);
  v11 = *(_QWORD **)(v3 + 32);
  if (v11)
    goto LABEL_13;
}

void cricket::TransportChannelStats::~TransportChannelStats(void **this)
{
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void **v7;

  if (*((char *)this + 151) < 0)
  {
    operator delete(this[16]);
    v2 = (void **)this[7];
    if (!v2)
    {
LABEL_3:
      v3 = (void **)this[4];
      if (!v3)
        return;
      goto LABEL_10;
    }
  }
  else
  {
    v2 = (void **)this[7];
    if (!v2)
      goto LABEL_3;
  }
  v4 = (void **)this[8];
  v5 = v2;
  if (v4 != v2)
  {
    do
    {
      cricket::Candidate::~Candidate(v4 - 64);
      cricket::Candidate::~Candidate(v4 - 118);
      v4 -= 133;
    }
    while (v4 != v2);
    v5 = (void **)this[7];
  }
  this[8] = v2;
  operator delete(v5);
  v3 = (void **)this[4];
  if (v3)
  {
LABEL_10:
    v6 = (void **)this[5];
    v7 = v3;
    if (v6 != v3)
    {
      do
        cricket::Candidate::~Candidate(v6 - 58);
      while (v6 != v3);
      v7 = (void **)this[4];
    }
    this[5] = v3;
    operator delete(v7);
  }
}

uint64_t cricket::IceTransportStats::IceTransportStats(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  int64_t v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  std::string *v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  int64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  std::string *v31;
  __int128 v32;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v4 = *a2;
  v5 = a2[1];
  v6 = v5 - *a2;
  if (v5 != *a2)
  {
    v7 = 0x34F72C234F72C235 * (v6 >> 4);
    if (v7 >= 0x8D3DCB08D3DCB1)
      goto LABEL_15;
    v8 = (char *)operator new(v6);
    v9 = 0;
    *(_QWORD *)a1 = v8;
    *(_QWORD *)(a1 + 8) = v8;
    *(_QWORD *)(a1 + 16) = &v8[464 * v7];
    do
    {
      v10 = cricket::Candidate::Candidate((std::string *)&v8[v9], (std::string *)(v4 + v9));
      v11 = *(_OWORD *)(v4 + v9 + 448);
      *(_OWORD *)&v10[18].__r_.__value_.__l.__data_ = *(_OWORD *)(v4 + v9 + 432);
      *(_OWORD *)&v10[18].__r_.__value_.__r.__words[2] = v11;
      v9 += 464;
    }
    while (v4 + v9 != v5);
    *(_QWORD *)(a1 + 8) = &v8[v9];
  }
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v12 = a2[3];
  v13 = a2[4];
  v14 = v13 - v12;
  if (v13 != v12)
  {
    v15 = 0x133F84CFE133F84DLL * (v14 >> 3);
    if (v15 < 0x3D980F6603D981)
    {
      v16 = (char *)operator new(v14);
      v17 = 0;
      *(_QWORD *)(a1 + 24) = v16;
      *(_QWORD *)(a1 + 32) = v16;
      *(_QWORD *)(a1 + 40) = &v16[1064 * v15];
      do
      {
        v18 = v12 + v17;
        v19 = &v16[v17];
        v20 = *(_OWORD *)(v12 + v17);
        v21 = *(_OWORD *)(v12 + v17 + 16);
        v22 = *(_OWORD *)(v12 + v17 + 48);
        *((_OWORD *)v19 + 2) = *(_OWORD *)(v12 + v17 + 32);
        *((_OWORD *)v19 + 3) = v22;
        *(_OWORD *)v19 = v20;
        *((_OWORD *)v19 + 1) = v21;
        v23 = *(_OWORD *)(v12 + v17 + 64);
        v24 = *(_OWORD *)(v12 + v17 + 80);
        v25 = *(_OWORD *)(v12 + v17 + 96);
        *((_QWORD *)v19 + 14) = *(_QWORD *)(v12 + v17 + 112);
        *((_OWORD *)v19 + 5) = v24;
        *((_OWORD *)v19 + 6) = v25;
        *((_OWORD *)v19 + 4) = v23;
        cricket::Candidate::Candidate((std::string *)&v16[v17 + 120], (std::string *)(v12 + v17 + 120));
        cricket::Candidate::Candidate((std::string *)&v16[v17 + 552], (std::string *)(v12 + v17 + 552));
        *(_OWORD *)(v19 + 984) = *(_OWORD *)(v12 + v17 + 984);
        v26 = *(_OWORD *)(v12 + v17 + 1000);
        v27 = *(_OWORD *)(v12 + v17 + 1016);
        v28 = *(_OWORD *)(v12 + v17 + 1032);
        *(_OWORD *)(v19 + 1041) = *(_OWORD *)(v12 + v17 + 1041);
        *(_OWORD *)(v19 + 1016) = v27;
        *(_OWORD *)(v19 + 1032) = v28;
        *(_OWORD *)(v19 + 1000) = v26;
        v17 += 1064;
      }
      while (v18 + 1064 != v13);
      *(_QWORD *)(a1 + 32) = &v16[v17];
      goto LABEL_11;
    }
LABEL_15:
    abort();
  }
LABEL_11:
  v29 = *((_OWORD *)a2 + 3);
  v30 = *((_OWORD *)a2 + 4);
  *(_OWORD *)(a1 + 76) = *(_OWORD *)((char *)a2 + 76);
  *(_OWORD *)(a1 + 48) = v29;
  *(_OWORD *)(a1 + 64) = v30;
  v31 = (std::string *)(a1 + 96);
  if (*((char *)a2 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(v31, (const std::string::value_type *)a2[12], a2[13]);
  }
  else
  {
    v32 = *((_OWORD *)a2 + 6);
    *(_QWORD *)(a1 + 112) = a2[14];
    *(_OWORD *)&v31->__r_.__value_.__l.__data_ = v32;
  }
  *(_DWORD *)(a1 + 120) = *((_DWORD *)a2 + 30);
  return a1;
}

_QWORD *webrtc::TrendlineEstimator::TrendlineEstimator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BYTE *v6;
  unsigned int *v7;
  double *v8;
  int *v9;
  _QWORD *result;
  std::string *p_p;
  std::string::size_type size;
  _BOOL4 v13;
  int data;
  int v15;
  std::string *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t *v34;
  std::string::size_type v35;
  std::string *v36;
  void *v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  double v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  unsigned int *v81;
  unint64_t v82;
  std::string __p;

  *(_QWORD *)a1 = &off_24C0C2968;
  v6 = (_BYTE *)(a1 + 9);
  *(_WORD *)(a1 + 8) = 0;
  v80 = a1 + 8;
  *(_QWORD *)(a1 + 12) = 0x700000007;
  v7 = (unsigned int *)(a1 + 12);
  *(_QWORD *)(a1 + 24) = 0;
  v8 = (double *)(a1 + 24);
  *(_DWORD *)(a1 + 32) = 20;
  v9 = (int *)(a1 + 32);
  result = (*(_QWORD *(**)(std::string *__return_ptr, uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(&__p, a2, "WebRTC-BweWindowSizeInPackets", 29);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    size = __p.__r_.__value_.__l.__size_;
    if ((__p.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
      goto LABEL_68;
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (__p.__r_.__value_.__l.__size_)
    {
      if (!__p.__r_.__value_.__r.__words[0])
        goto LABEL_68;
    }
  }
  else
  {
    p_p = &__p;
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  if (size < 7)
  {
    v13 = 0;
    v81 = (unsigned int *)(a1 + 16);
    if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) == 0)
      goto LABEL_17;
    goto LABEL_16;
  }
  data = (int)p_p->__r_.__value_.__l.__data_;
  v15 = *(_DWORD *)((char *)p_p->__r_.__value_.__r.__words + 3);
  v13 = data == 1650552389 && v15 == 1684368482;
  v81 = (unsigned int *)(a1 + 16);
  if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
LABEL_16:
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_17:
  if (!v13)
    goto LABEL_31;
  (*(void (**)(std::string *__return_ptr, uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(&__p, a2, "WebRTC-BweWindowSizeInPackets", 29);
  v82 = 0;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = &__p;
  else
    v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if (sscanf((const char *)v17, "Enabled-%zu", &v82) != 1)
    goto LABEL_25;
  v18 = v82;
  if (v82 <= 1)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/goog_cc/trendline_estimator.cc");
LABEL_25:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/goog_cc/trendline_estimator.cc");
    v18 = 20;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *v9 = v18;
LABEL_31:
  v33 = operator new(0xC0uLL);
  *v33 = "sort";
  v33[1] = v80;
  v33[2] = webrtc::struct_parser_impl::TypedParser<BOOL>::Parse;
  v33[3] = webrtc::struct_parser_impl::TypedParser<BOOL>::Encode;
  v33[4] = "cap";
  v33[5] = v6;
  v33[6] = webrtc::struct_parser_impl::TypedParser<BOOL>::Parse;
  v33[7] = webrtc::struct_parser_impl::TypedParser<BOOL>::Encode;
  v33[8] = "beginning_packets";
  v33[9] = v7;
  v33[10] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Parse;
  v33[11] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Encode;
  v33[12] = "end_packets";
  v33[13] = v81;
  v33[14] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Parse;
  v33[15] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Encode;
  v33[16] = "cap_uncertainty";
  v33[17] = v8;
  v33[18] = webrtc::struct_parser_impl::TypedParser<double>::Parse;
  v33[19] = webrtc::struct_parser_impl::TypedParser<double>::Encode;
  v33[20] = "window_size";
  v33[21] = v9;
  v33[22] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Parse;
  v33[23] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Encode;
  v34 = (uint64_t *)operator new();
  *v34 = (uint64_t)v33;
  v34[1] = (uint64_t)(v33 + 24);
  v34[2] = (uint64_t)(v33 + 24);
  result = (*(_QWORD *(**)(std::string *__return_ptr, uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(&__p, a2, "WebRTC-Bwe-TrendlineEstimatorSettings", 37);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v35 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    v36 = &__p;
    goto LABEL_36;
  }
  v35 = __p.__r_.__value_.__l.__size_;
  if ((__p.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0
    || (v36 = (std::string *)__p.__r_.__value_.__r.__words[0], __p.__r_.__value_.__l.__size_)
    && !__p.__r_.__value_.__r.__words[0])
  {
LABEL_68:
    __break(1u);
    return result;
  }
LABEL_36:
  webrtc::StructParametersParser::Parse(v34, (uint64_t)v36, v35);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v37 = (void *)*v34;
  if (*v34)
  {
    v34[1] = (uint64_t)v37;
    operator delete(v37);
  }
  MEMORY[0x20BD0ADEC](v34, 0x20C40960023A9);
  v38 = *v9;
  if ((*v9 - 201) <= 0xFFFFFF40)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/goog_cc/trendline_estimator.cc");
    v38 = 20;
    *v9 = 20;
  }
  if (!*v6)
    goto LABEL_61;
  v46 = *v7;
  if (*v7 && (v47 = *v81) != 0 && v46 <= v38 && v47 <= v38)
  {
    if (v46 + v47 > v38)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v48, v49, v50, v51, v52, v53, v54, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/goog_cc/trendline_estimator.cc");
      *v6 = 0;
      *(_QWORD *)v7 = 0;
      v55 = 0.0;
      *v8 = 0.0;
      goto LABEL_57;
    }
  }
  else
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int> const&)::t, v56, v57, v58, v59, v60, v61, v62, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/goog_cc/trendline_estimator.cc");
    *v6 = 0;
    *(_QWORD *)v7 = 0;
    *v8 = 0.0;
  }
  v55 = *v8;
  if (*v8 < 0.0)
  {
LABEL_58:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v63, v64, v65, v66, v67, v68, v69, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/goog_cc/trendline_estimator.cc");
    *v8 = 0.0;
    goto LABEL_61;
  }
LABEL_57:
  if (v55 > 0.025)
    goto LABEL_58;
LABEL_61:
  *(_OWORD *)(a1 + 40) = xmmword_208F1C980;
  *(_DWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = -1;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = xmmword_208F16C10;
  *(_OWORD *)(a1 + 152) = xmmword_208F1C990;
  *(_QWORD *)(a1 + 168) = 0x7FF8000000000000;
  *(_QWORD *)(a1 + 176) = -1;
  *(_OWORD *)(a1 + 184) = xmmword_208F16C00;
  *(_QWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = a3;
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    v70 = operator new(0xC0uLL);
    *v70 = "sort";
    v70[1] = v80;
    v70[2] = webrtc::struct_parser_impl::TypedParser<BOOL>::Parse;
    v70[3] = webrtc::struct_parser_impl::TypedParser<BOOL>::Encode;
    v70[4] = "cap";
    v70[5] = v6;
    v70[6] = webrtc::struct_parser_impl::TypedParser<BOOL>::Parse;
    v70[7] = webrtc::struct_parser_impl::TypedParser<BOOL>::Encode;
    v70[8] = "beginning_packets";
    v70[9] = v7;
    v70[10] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Parse;
    v70[11] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Encode;
    v70[12] = "end_packets";
    v70[13] = v81;
    v70[14] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Parse;
    v70[15] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Encode;
    v70[16] = "cap_uncertainty";
    v70[17] = v8;
    v70[18] = webrtc::struct_parser_impl::TypedParser<double>::Parse;
    v70[19] = webrtc::struct_parser_impl::TypedParser<double>::Encode;
    v70[20] = "window_size";
    v70[21] = v9;
    v70[22] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Parse;
    v70[23] = webrtc::struct_parser_impl::TypedParser<unsigned int>::Encode;
    v71 = (uint64_t *)operator new();
    *v71 = (uint64_t)v70;
    v71[1] = (uint64_t)(v70 + 24);
    v71[2] = (uint64_t)(v70 + 24);
    webrtc::StructParametersParser::Encode(v71, &__p);
    rtc::webrtc_logging_impl::Log("\r\t\n\t\t\t", v72, v73, v74, v75, v76, v77, v78, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/goog_cc/trendline_estimator.cc");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    v79 = (void *)*v71;
    if (*v71)
    {
      v71[1] = (uint64_t)v79;
      operator delete(v79);
    }
    MEMORY[0x20BD0ADEC](v71, 0x20C40960023A9);
  }
  return (_QWORD *)a1;
}

void webrtc::TrendlineEstimator::~TrendlineEstimator(void **this)
{
  *this = &off_24C0C2968;
  std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](this + 11);
}

{
  *this = &off_24C0C2968;
  std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](this + 11);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::TrendlineEstimator::Update(webrtc::TrendlineEstimator *this, __n128 a2, float64x2_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  double v10;
  double v11;
  int v12;
  char *v13;
  int v14;
  uint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  double v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  void *v30;
  void *v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  void *v36;
  void *v37;
  unint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  int64_t v46;
  char *v47;
  char *v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  char *v52;
  char *v53;
  BOOL v54;
  int64_t v55;
  unint64_t v56;
  char *v57;
  unint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  char *v62;
  void *v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  char *v71;
  int64_t v72;
  unint64_t v73;
  char *v74;
  char *v75;
  uint64_t v76;
  uint64_t v77;
  __int128 *v78;
  char *v79;
  uint64_t v80;
  __int128 v81;
  uint64_t v82;
  unint64_t v83;
  unint64_t v84;
  uint64_t v85;
  char *v86;
  char *v87;
  char *v88;
  char *v89;
  char *v90;
  unint64_t v91;
  uint64_t v92;
  __int128 *v93;
  _OWORD *v94;
  uint64_t v95;
  __int128 v96;
  uint64_t v97;
  char *v98;
  char *v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unint64_t v111;
  void **v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  uint64_t v116;
  char **v117;
  char *v118;
  char *v119;
  unint64_t v120;
  char *v121;
  char *v122;
  uint64_t v123;
  float64x2_t v124;
  float64x2_t v125;
  char *v126;
  float64x2_t v127;
  uint64_t v128;
  float64x2_t v129;
  float64x2_t v130;
  float64x2_t v131;
  char *v132;
  double v133;
  double *v134;
  double v135;
  double v136;
  uint64_t v137;
  uint64_t v138;
  unint64_t v139;
  uint64_t v140;
  uint64_t v141;
  double *v142;
  double v143;
  double v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v148;
  unint64_t v149;
  double v150;
  double v151;
  uint64_t result;
  const char *v155;
  double v156;
  double v157;
  double v158;
  double v159;
  int v160;
  BOOL v161;
  uint64_t v162;
  uint64_t v163;
  double v164;
  uint64_t v165;
  uint64_t v166;
  double v167;
  char *v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  char *v173;
  int64_t v174;
  char *v175;
  uint64_t v176;
  uint64_t v177;
  __int128 *v178;
  _OWORD *v179;
  uint64_t v180;
  __int128 v181;
  uint64_t v182;
  unint64_t v183;
  unint64_t v184;
  uint64_t v185;
  char *v186;
  char *v187;
  int64_t v188;
  unint64_t v189;
  char *v190;
  char *v191;
  uint64_t v192;
  uint64_t v193;
  char *v194;
  __int128 *v195;
  _OWORD *v196;
  uint64_t v197;
  __int128 v198;
  uint64_t v199;
  char *v201;
  uint64_t v202;

  v7 = a5;
  v8 = a4;
  if (!a7)
  {
LABEL_139:
    result = *((_QWORD *)this + 27);
    if (!result)
      return result;
    goto LABEL_140;
  }
  v10 = a3.f64[0];
  v11 = a2.n128_f64[0] - a3.f64[0];
  v13 = (char *)this + 56;
  v12 = *((_DWORD *)this + 14);
  if (v12 < 1000)
    v14 = v12 + 1;
  else
    v14 = 1000;
  *(_DWORD *)v13 = v14;
  v15 = *((_QWORD *)this + 8);
  if (v15 == -1)
  {
    *((_QWORD *)this + 8) = a5;
    v15 = a5;
  }
  v16 = (char *)*((_QWORD *)this + 12);
  v17 = (char *)*((_QWORD *)this + 13);
  v18 = (v17 - v16) >> 3;
  v19 = v17 - v16;
  v20 = *((double *)this + 10);
  v21 = v11 + *((double *)this + 9);
  v22 = *((double *)this + 5);
  *((double *)this + 9) = v21;
  *((double *)this + 10) = v21 * (1.0 - v22) + v22 * v20;
  if (v17 == v16)
    v23 = 0;
  else
    v23 = 170 * v18 - 1;
  v25 = *((_QWORD *)this + 15);
  v24 = *((_QWORD *)this + 16);
  if (v23 == v24 + v25)
  {
    v202 = v15;
    if (v25 >= 0xAA)
    {
      *((_QWORD *)this + 15) = v25 - 170;
      v27 = v16 + 8;
      v26 = *(_QWORD *)v16;
      *((_QWORD *)this + 12) = v16 + 8;
      if (v17 != *((char **)this + 14))
        goto LABEL_13;
      v40 = (char *)*((_QWORD *)this + 11);
      if (v27 > v40)
      {
        v41 = (v27 - v40) >> 3;
        if (v41 >= -1)
          v42 = v41 + 1;
        else
          v42 = v41 + 2;
        v43 = v42 >> 1;
        v44 = -v43;
        v45 = &v27[-8 * v43];
        v46 = v17 - v27;
        if (v17 != v27)
        {
          memmove(&v27[-8 * v43], v27, v17 - v27);
          v17 = (char *)*((_QWORD *)this + 12);
        }
        v47 = &v17[8 * v44];
        v17 = &v45[v46];
        *((_QWORD *)this + 12) = v47;
        *((_QWORD *)this + 13) = &v45[v46];
        v13 = (char *)this + 56;
        goto LABEL_14;
      }
      v49 = (v17 - v40) >> 2;
      if (v17 == v40)
        v49 = 1;
      if (!(v49 >> 61))
      {
        v50 = v49 >> 2;
        v51 = 8 * v49;
        v52 = (char *)operator new(8 * v49);
        v53 = &v52[8 * v50];
        v55 = v17 - v27;
        v54 = v17 == v27;
        v17 = v53;
        if (v54)
          goto LABEL_188;
        v17 = &v53[v55 & 0xFFFFFFFFFFFFFFF8];
        v56 = v55 - 8;
        if ((unint64_t)(v55 - 8) >= 0x38)
        {
          v175 = &v52[8 * v50];
          v57 = v175;
          if ((unint64_t)(v175 - v27) >= 0x20)
          {
            v176 = (v56 >> 3) + 1;
            v177 = 8 * (v176 & 0x3FFFFFFFFFFFFFFCLL);
            v57 = &v53[v177];
            v27 += v177;
            v178 = (__int128 *)(v16 + 24);
            v179 = v175 + 16;
            v180 = v176 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v181 = *v178;
              *(v179 - 1) = *(v178 - 1);
              *v179 = v181;
              v178 += 2;
              v179 += 2;
              v180 -= 4;
            }
            while (v180);
            if (v176 == (v176 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_188:
              *((_QWORD *)this + 11) = v52;
              *((_QWORD *)this + 12) = v53;
              *((_QWORD *)this + 13) = v17;
              *((_QWORD *)this + 14) = &v52[v51];
              if (v40)
              {
                operator delete(v40);
                v17 = (char *)*((_QWORD *)this + 13);
              }
LABEL_13:
              v13 = (char *)this + 56;
              if (v17)
              {
LABEL_14:
                *(_QWORD *)v17 = v26;
                v17 = (char *)(*((_QWORD *)this + 13) + 8);
                *((_QWORD *)this + 13) = v17;
                v8 = a4;
LABEL_90:
                v25 = *((_QWORD *)this + 15);
                v24 = *((_QWORD *)this + 16);
                v16 = (char *)*((_QWORD *)this + 12);
                v15 = v202;
                goto LABEL_91;
              }
LABEL_203:
              __break(1u);
              goto LABEL_204;
            }
          }
        }
        else
        {
          v57 = &v52[8 * v50];
        }
        do
        {
          v182 = *(_QWORD *)v27;
          v27 += 8;
          *(_QWORD *)v57 = v182;
          v57 += 8;
        }
        while (v57 != v17);
        goto LABEL_188;
      }
LABEL_204:
      std::__throw_bad_array_new_length[abi:sn180100]();
    }
    v28 = (char *)*((_QWORD *)this + 14);
    v29 = (char *)*((_QWORD *)this + 11);
    v201 = (char *)this + 56;
    if (v18 >= (unint64_t)((v28 - v29) >> 3))
    {
      if (v28 == v29)
        v32 = 1;
      else
        v32 = (v28 - v29) >> 2;
      if (v32 >> 61)
        goto LABEL_204;
      v33 = (char *)operator new(8 * v32);
      v34 = &v33[8 * v18];
      v35 = &v33[8 * v32];
      v36 = operator new(0xFF0uLL);
      v37 = v36;
      if (v18 == v32)
      {
        v7 = a5;
        if (v19 < 1)
        {
          v58 = v19 >> 2;
          if (v17 == v16)
            v58 = 1;
          if (v58 >> 61)
            goto LABEL_204;
          v59 = 8 * v58;
          v34 = (char *)operator new(8 * v58);
          operator delete(v33);
          v35 = &v34[v59];
          v60 = (char *)*((_QWORD *)this + 12);
          v17 = (char *)*((_QWORD *)this + 13);
          v33 = v34;
          *(_QWORD *)v34 = v37;
          v39 = v34 + 8;
          if (v17 != v60)
            goto LABEL_55;
        }
        else
        {
          v38 = v18 + 2;
          if (v18 >= -1)
            v38 = v18 + 1;
          v34 -= 8 * (v38 >> 1);
          *(_QWORD *)v34 = v36;
          v39 = v34 + 8;
          if (v17 != v16)
          {
            while (1)
            {
LABEL_55:
              if (v34 == v33)
              {
                if (v39 >= v35)
                {
                  v68 = (v35 - v34) >> 2;
                  if (v35 == v34)
                    v68 = 1;
                  if (v68 >> 61)
                    goto LABEL_204;
                  v69 = (v68 + 3) >> 2;
                  v70 = 8 * v68;
                  v71 = (char *)operator new(8 * v68);
                  v33 = v71;
                  v64 = &v71[8 * v69];
                  v62 = v64;
                  v72 = v39 - v34;
                  if (v39 != v34)
                  {
                    v62 = &v64[v72 & 0xFFFFFFFFFFFFFFF8];
                    v73 = v72 - 8;
                    v74 = &v71[8 * v69];
                    v75 = v34;
                    if (v73 < 0x38)
                      goto LABEL_207;
                    v74 = &v71[8 * v69];
                    v75 = v34;
                    if ((unint64_t)(v74 - v34) < 0x20)
                      goto LABEL_207;
                    v76 = (v73 >> 3) + 1;
                    v77 = 8 * (v76 & 0x3FFFFFFFFFFFFFFCLL);
                    v74 = &v64[v77];
                    v75 = &v34[v77];
                    v78 = (__int128 *)(v34 + 16);
                    v79 = &v71[8 * v69 + 16];
                    v80 = v76 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      v81 = *v78;
                      *((_OWORD *)v79 - 1) = *(v78 - 1);
                      *(_OWORD *)v79 = v81;
                      v78 += 2;
                      v79 += 32;
                      v80 -= 4;
                    }
                    while (v80);
                    if (v76 != (v76 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_207:
                      do
                      {
                        v82 = *(_QWORD *)v75;
                        v75 += 8;
                        *(_QWORD *)v74 = v82;
                        v74 += 8;
                      }
                      while (v74 != v62);
                    }
                  }
                  v35 = &v71[v70];
                  operator delete(v34);
                }
                else
                {
                  v66 = (v35 - v39) >> 3;
                  if (v66 >= -1)
                    v67 = v66 + 1;
                  else
                    v67 = v66 + 2;
                  v62 = &v39[8 * (v67 >> 1)];
                  v64 = &v34[8 * (v67 >> 1)];
                  if (v39 == v34)
                  {
                    v33 = v39;
                  }
                  else
                  {
                    memmove(&v34[8 * (v67 >> 1)], v34, v39 - v34);
                    v33 = v34;
                  }
                }
              }
              else
              {
                v64 = v34;
                v62 = v39;
              }
              v65 = *((_QWORD *)v17 - 1);
              v17 -= 8;
              *((_QWORD *)v64 - 1) = v65;
              v61 = v64 - 8;
              v39 = v62;
              v34 = v61;
              if (v17 == *((char **)this + 12))
                goto LABEL_51;
            }
          }
        }
      }
      else
      {
        v7 = a5;
        *(_QWORD *)v34 = v36;
        v39 = v34 + 8;
        if (v17 != v16)
          goto LABEL_55;
      }
      v61 = v34;
      v62 = v39;
LABEL_51:
      v63 = (void *)*((_QWORD *)this + 11);
      *((_QWORD *)this + 11) = v33;
      *((_QWORD *)this + 12) = v61;
      v17 = v62;
      *((_QWORD *)this + 13) = v62;
      *((_QWORD *)this + 14) = v35;
      v8 = a4;
      v13 = v201;
      if (v63)
      {
        operator delete(v63);
        v17 = (char *)*((_QWORD *)this + 13);
      }
      goto LABEL_90;
    }
    v30 = operator new(0xFF0uLL);
    v31 = v30;
    if (v28 != v17)
    {
      if (!v17)
        goto LABEL_203;
      *(_QWORD *)v17 = v30;
LABEL_89:
      v17 = (char *)(*((_QWORD *)this + 13) + 8);
      *((_QWORD *)this + 13) = v17;
      v8 = a4;
      v13 = v201;
      goto LABEL_90;
    }
    if (v16 == v29)
    {
      v83 = (v28 - v16) >> 2;
      if (v17 == v16)
        v83 = 1;
      if (v83 >> 61)
        goto LABEL_204;
      v84 = (v83 + 3) >> 2;
      v85 = 8 * v83;
      v86 = (char *)operator new(8 * v83);
      v48 = &v86[8 * v84];
      v87 = v48;
      if (v17 != v16)
      {
        v87 = &v48[8 * v18];
        v88 = &v86[8 * v84];
        v89 = v16;
        if ((unint64_t)(v19 - 8) < 0x38)
          goto LABEL_208;
        v90 = &v86[8 * v84];
        v88 = v90;
        v89 = v16;
        if ((unint64_t)(v90 - v16) < 0x20)
          goto LABEL_208;
        v91 = ((unint64_t)(v19 - 8) >> 3) + 1;
        v92 = 8 * (v91 & 0x3FFFFFFFFFFFFFFCLL);
        v88 = &v48[v92];
        v89 = &v16[v92];
        v93 = (__int128 *)(v16 + 16);
        v94 = v90 + 16;
        v95 = v91 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v96 = *v93;
          *(v94 - 1) = *(v93 - 1);
          *v94 = v96;
          v93 += 2;
          v94 += 2;
          v95 -= 4;
        }
        while (v95);
        if (v91 != (v91 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_208:
          do
          {
            v97 = *(_QWORD *)v89;
            v89 += 8;
            *(_QWORD *)v88 = v97;
            v88 += 8;
          }
          while (v88 != v87);
        }
      }
      *((_QWORD *)this + 11) = v86;
      *((_QWORD *)this + 12) = v48;
      *((_QWORD *)this + 13) = v87;
      *((_QWORD *)this + 14) = &v86[v85];
      if (v16)
      {
        operator delete(v16);
        v48 = (char *)*((_QWORD *)this + 12);
      }
    }
    else
    {
      v48 = v16;
    }
    *((_QWORD *)v48 - 1) = v31;
    v98 = (char *)*((_QWORD *)this + 12);
    v99 = (char *)*((_QWORD *)this + 13);
    *((_QWORD *)this + 12) = v98 - 8;
    v100 = *((_QWORD *)v98 - 1);
    *((_QWORD *)this + 12) = v98;
    if (v99 != *((char **)this + 14))
      goto LABEL_87;
    v168 = (char *)*((_QWORD *)this + 11);
    if (v98 > v168)
    {
      v169 = (v98 - v168) >> 3;
      if (v169 >= -1)
        v170 = v169 + 1;
      else
        v170 = v169 + 2;
      v171 = v170 >> 1;
      v172 = -v171;
      v173 = &v98[-8 * v171];
      v174 = v99 - v98;
      if (v99 != v98)
      {
        memmove(&v98[-8 * v171], v98, v99 - v98);
        v98 = (char *)*((_QWORD *)this + 12);
      }
      v99 = &v173[v174];
      *((_QWORD *)this + 12) = &v98[8 * v172];
      *((_QWORD *)this + 13) = &v173[v174];
LABEL_88:
      *(_QWORD *)v99 = v100;
      goto LABEL_89;
    }
    v183 = (v99 - v168) >> 2;
    if (v99 == v168)
      v183 = 1;
    if (v183 >> 61)
      goto LABEL_204;
    v184 = v183 >> 2;
    v185 = 8 * v183;
    v186 = (char *)operator new(8 * v183);
    v187 = &v186[8 * v184];
    v188 = v99 - v98;
    v54 = v99 == v98;
    v99 = v187;
    if (!v54)
    {
      v99 = &v187[v188 & 0xFFFFFFFFFFFFFFF8];
      v189 = v188 - 8;
      if ((unint64_t)(v188 - 8) < 0x38)
      {
        v190 = &v186[8 * v184];
        do
        {
LABEL_200:
          v199 = *(_QWORD *)v98;
          v98 += 8;
          *(_QWORD *)v190 = v199;
          v190 += 8;
        }
        while (v190 != v99);
        goto LABEL_201;
      }
      v191 = &v186[8 * v184];
      v190 = v191;
      if ((unint64_t)(v191 - v98) < 0x20)
        goto LABEL_200;
      v192 = (v189 >> 3) + 1;
      v193 = 8 * (v192 & 0x3FFFFFFFFFFFFFFCLL);
      v190 = &v187[v193];
      v194 = &v98[v193];
      v195 = (__int128 *)(v98 + 16);
      v196 = v191 + 16;
      v197 = v192 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v198 = *v195;
        *(v196 - 1) = *(v195 - 1);
        *v196 = v198;
        v195 += 2;
        v196 += 2;
        v197 -= 4;
      }
      while (v197);
      v98 = v194;
      if (v192 != (v192 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_200;
    }
LABEL_201:
    *((_QWORD *)this + 11) = v186;
    *((_QWORD *)this + 12) = v187;
    *((_QWORD *)this + 13) = v99;
    *((_QWORD *)this + 14) = &v186[v185];
    if (v168)
    {
      operator delete(v168);
      v99 = (char *)*((_QWORD *)this + 13);
    }
LABEL_87:
    if (!v99)
      goto LABEL_203;
    goto LABEL_88;
  }
LABEL_91:
  if (v17 == v16)
    goto LABEL_203;
  v101 = v24 + v25;
  v102 = *(_QWORD *)&v16[8 * (v101 / 0xAA)];
  if (!v102)
    goto LABEL_203;
  v103 = v102 + 24 * (v101 % 0xAA);
  a3 = *(float64x2_t *)((char *)this + 72);
  *(double *)v103 = (double)(v7 - v15);
  a2 = (__n128)vextq_s8((int8x16_t)a3, (int8x16_t)a3, 8uLL);
  *(__n128 *)(v103 + 8) = a2;
  v104 = v24 + 1;
  *((_QWORD *)this + 16) = v24 + 1;
  if (*((_BYTE *)this + 8) && v24)
  {
    do
    {
      v105 = v24 + *((_QWORD *)this + 15);
      v106 = *((_QWORD *)this + 12);
      v107 = *(_QWORD *)(v106 + 8 * (v105 / 0xAA)) + 24 * (v105 % 0xAA);
      v108 = *(_QWORD *)(v106 + 8 * ((v105 - 1) / 0xAA)) + 24 * ((v105 - 1) % 0xAA);
      if (*(double *)v107 >= *(double *)v108)
        break;
      v109 = *(_QWORD *)(v107 + 16);
      a2 = *(__n128 *)v107;
      v110 = *(_QWORD *)(v108 + 16);
      a3 = *(float64x2_t *)v108;
      *(_OWORD *)v107 = *(_OWORD *)v108;
      *(_QWORD *)(v107 + 16) = v110;
      *(__n128 *)v108 = a2;
      *(_QWORD *)(v108 + 16) = v109;
      --v24;
    }
    while (v24);
    v104 = *((_QWORD *)this + 16);
  }
  v111 = *((unsigned int *)this + 8);
  if (v104 > v111)
  {
    v112 = (void **)*((_QWORD *)this + 12);
    v113 = *((_QWORD *)this + 15);
    if (*(void **)((char *)v112
                  + (((unint64_t)((v113 * (unsigned __int128)0xC0C0C0C0C0C0C0C1) >> 64) >> 4) & 0xFFFFFFFFFFFFFF8)))
    {
      --v104;
      v114 = v113 + 1;
      *((_QWORD *)this + 15) = v114;
      *((_QWORD *)this + 16) = v104;
      if (v114 >= 0x154)
      {
        operator delete(*v112);
        *((_QWORD *)this + 12) += 8;
        v104 = *((_QWORD *)this + 16);
        *((_QWORD *)this + 15) -= 170;
        v111 = *((unsigned int *)this + 8);
      }
      goto LABEL_102;
    }
    goto LABEL_203;
  }
LABEL_102:
  a2.n128_u64[0] = *((_QWORD *)this + 23);
  *(_QWORD *)&a3.f64[0] = a2.n128_u64[0];
  if (v104 == v111)
  {
    v115 = *((_QWORD *)this + 15);
    v116 = *((_QWORD *)this + 12);
    v117 = (char **)(v116 + 8 * (v115 / 0xAA));
    a3 = 0uLL;
    if (*((_QWORD *)this + 13) != v116)
    {
      v118 = *v117;
      v119 = &(*v117)[24 * (v115 % 0xAA)];
      v120 = *(_QWORD *)(v116 + 8 * ((v115 + v111) / 0xAA)) + 24 * ((v115 + v111) % 0xAA);
      if (v119 != (char *)v120)
      {
        v121 = *v117;
        v122 = &(*v117)[24 * (v115 % 0xAA)];
        v123 = v116 + 8 * (v115 / 0xAA);
        do
        {
          v124 = *(float64x2_t *)v122;
          v122 += 24;
          v125 = v124;
          if (v122 - v121 == 4080)
          {
            v126 = *(char **)(v123 + 8);
            v123 += 8;
            v121 = v126;
            v122 = v126;
          }
          a3 = vaddq_f64(a3, v125);
        }
        while (v122 != (char *)v120);
        v127 = vdivq_f64(a3, (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v111), 0));
        a3 = 0uLL;
        v128 = v116 + 8 * (v115 / 0xAA);
        do
        {
          v130 = *(float64x2_t *)v119;
          v119 += 24;
          v131 = v130;
          if (v119 - v118 == 4080)
          {
            v132 = *(char **)(v128 + 8);
            v128 += 8;
            v118 = v132;
            v119 = v132;
          }
          v129 = vsubq_f64(v131, v127);
          a3 = vmlaq_n_f64(a3, v129, v129.f64[0]);
        }
        while (v119 != (char *)v120);
      }
    }
    *(_QWORD *)&v133 = *(_OWORD *)&vdivq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)a3, 1), a3);
    if (a3.f64[0] == 0.0)
      a3.f64[0] = *((float64_t *)this + 23);
    else
      a3.f64[0] = v133;
    if (*((_BYTE *)this + 9))
    {
      v134 = (double *)&(*v117)[24 * (v115 % 0xAA)];
      v135 = *v134;
      v136 = v134[2];
      v137 = *((unsigned int *)this + 3);
      if (v137 >= 2)
      {
        v138 = v137 - 1;
        v139 = v115 + 1;
        do
        {
          v140 = *(_QWORD *)(v116 + 8 * (v139 / 0xAA));
          if (*(double *)(v140 + 24 * (v139 % 0xAA) + 16) < v136)
          {
            v135 = *(double *)(v140 + 24 * (v139 % 0xAA));
            v136 = *(double *)(v140 + 24 * (v139 % 0xAA) + 16);
          }
          ++v139;
          --v138;
        }
        while (v138);
      }
      v141 = *((unsigned int *)this + 4);
      v142 = (double *)(*(_QWORD *)(v116 + 8 * ((v111 - v141 + v115) / 0xAA)) + 24 * ((v111 - v141 + v115) % 0xAA));
      v143 = *v142;
      v144 = v142[2];
      if (v111 - v141 + 1 < v111)
      {
        v145 = 1 - v141;
        v146 = v111 + v115;
        do
        {
          v148 = *(_QWORD *)(v116 + 8 * ((v146 + v145) / 0xAAuLL));
          v149 = (v146 + v145) % 0xAAuLL;
          if (*(double *)(v148 + 24 * v149 + 16) < v144)
          {
            v143 = *(double *)(v148 + 24 * v149);
            v144 = *(double *)(v148 + 24 * v149 + 16);
          }
        }
        while (!__CFADD__(v145++, 1));
      }
      v150 = v143 - v135;
      v151 = 0.0;
      if (v150 >= 1.0)
        v151 = (v144 - v136) / v150 + *((double *)this + 3);
      if (a3.f64[0] > v151 && v150 >= 1.0 && a3.f64[0] >= 0.0)
        a3.f64[0] = v151;
    }
  }
  if (*(int *)v13 <= 1)
  {
    *((_DWORD *)this + 51) = 0;
    goto LABEL_139;
  }
  if (*(_DWORD *)v13 <= 0x3Cu)
    v155 = v13;
  else
    v155 = "<";
  v156 = *((double *)this + 6) * (a3.f64[0] * (double)*(int *)v155);
  *((double *)this + 21) = v156;
  v157 = *((double *)this + 20);
  if (v156 <= v157)
  {
    *((_QWORD *)this + 24) = 0xBFF0000000000000;
    *((_DWORD *)this + 50) = 0;
    if (v156 >= -v157)
    {
      *((_DWORD *)this + 51) = 0;
      *((_QWORD *)this + 23) = *(_QWORD *)&a3.f64[0];
      a2.n128_f64[0] = fabs(v156);
      a3.f64[0] = v157 + 15.0;
      if (a2.n128_f64[0] > v157 + 15.0)
        goto LABEL_172;
      goto LABEL_159;
    }
    *((_DWORD *)this + 51) = 1;
  }
  else
  {
    v158 = *((double *)this + 24);
    if (v158 == -1.0)
      v159 = v10 * 0.5;
    else
      v159 = v158 + v10;
    *((double *)this + 24) = v159;
    v160 = *((_DWORD *)this + 50);
    *((_DWORD *)this + 50) = v160 + 1;
    v161 = v159 <= *((double *)this + 19) || v160 < 1;
    if (!v161 && a2.n128_f64[0] <= a3.f64[0])
    {
      *((_QWORD *)this + 24) = 0;
      *((_QWORD *)this + 25) = 0x200000000;
      *((_QWORD *)this + 23) = *(_QWORD *)&a3.f64[0];
      a2.n128_f64[0] = fabs(v156);
      a3.f64[0] = v157 + 15.0;
      if (a2.n128_f64[0] > v157 + 15.0)
        goto LABEL_172;
      goto LABEL_159;
    }
  }
  *((_QWORD *)this + 23) = *(_QWORD *)&a3.f64[0];
  a2.n128_f64[0] = fabs(v156);
  a3.f64[0] = v157 + 15.0;
  if (a2.n128_f64[0] > v157 + 15.0)
    goto LABEL_172;
LABEL_159:
  v162 = *((_QWORD *)this + 22);
  v163 = 136;
  if (a2.n128_f64[0] < v157)
    v163 = 144;
  v164 = *(double *)((char *)this + v163);
  v165 = v7 - v162;
  if (v7 - v162 >= 100)
    v165 = 100;
  if (v162 == -1)
    v166 = 0;
  else
    v166 = v165;
  v167 = v157 + (a2.n128_f64[0] - v157) * v164 * (double)v166;
  a3.f64[0] = 600.0;
  if (v167 < 600.0)
    a3.f64[0] = v167;
  if (v167 > 6.0)
    a2.n128_f64[0] = a3.f64[0];
  else
    a2.n128_f64[0] = 6.0;
  *((_QWORD *)this + 20) = a2.n128_u64[0];
LABEL_172:
  *((_QWORD *)this + 22) = v7;
  result = *((_QWORD *)this + 27);
  if (result)
  {
LABEL_140:
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, __n128, float64x2_t))(*(_QWORD *)result + 16))(result, v8, v7, *((unsigned int *)this + 51), a2, a3);
    *((_DWORD *)this + 52) = result;
  }
  return result;
}

uint64_t webrtc::TrendlineEstimator::State(webrtc::TrendlineEstimator *this)
{
  uint64_t v1;

  v1 = 208;
  if (!*((_QWORD *)this + 27))
    v1 = 204;
  return *(unsigned int *)((char *)this + v1);
}

uint64_t cricket::TurnPort::TurnPort(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void **__src, size_t a7, int a8, void **a9, size_t a10, __int128 *a11, __int128 *a12, int a13, uint64_t *a14, uint64_t *a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  _QWORD *v21;
  __int128 *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  int64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t v29;
  __int128 *v30;
  std::string *v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  int64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;
  __int128 v39;
  __int128 *v40;
  std::string *v41;
  std::string *v42;
  __int128 v43;
  uint64_t v44;
  int v45;
  std::string *v46;
  __int128 v47;
  uint64_t v48;
  unsigned int v49;
  _QWORD v51[6];

  v51[4] = *MEMORY[0x24BDAC8D0];
  v21 = (_QWORD *)cricket::Port::Port(a1, a2, 3, a3, a4, 0, 0, a8, __src, a7, a9, a10, a18, 1);
  *v21 = &off_24C0C2998;
  v21[29] = &unk_24C0C2B40;
  v22 = (__int128 *)(v21 + 99);
  *(_QWORD *)(a1 + 792) = 0;
  *(_QWORD *)(a1 + 808) = 0;
  *(_QWORD *)(a1 + 800) = 0;
  *(_QWORD *)(a1 + 816) = &unk_24C0ACDA0;
  *(_QWORD *)(a1 + 832) = 0;
  *(_QWORD *)(a1 + 824) = 0;
  *(_DWORD *)(a1 + 840) = 0;
  if (v22 != a11)
  {
    if (*((char *)a11 + 23) < 0)
    {
      std::string::__assign_no_alias<true>(v22, *(char **)a11, *((_QWORD *)a11 + 1));
    }
    else
    {
      v23 = *a11;
      *((_QWORD *)v22 + 2) = *((_QWORD *)a11 + 2);
      *v22 = v23;
    }
  }
  *(_DWORD *)(a1 + 824) = *((_DWORD *)a11 + 8);
  *(_OWORD *)(a1 + 828) = *(__int128 *)((char *)a11 + 36);
  *(_WORD *)(a1 + 848) = *((_WORD *)a11 + 28);
  *(_BYTE *)(a1 + 856) = *((_BYTE *)a11 + 64);
  *(_DWORD *)(a1 + 852) = *((_DWORD *)a11 + 15);
  *(_DWORD *)(a1 + 864) = *((_DWORD *)a11 + 18);
  cricket::TurnPort::ReconstructServerUrl((std::string *)(a1 + 872), a1);
  *(_DWORD *)(a1 + 896) = 0;
  *(_QWORD *)(a1 + 904) = 0;
  *(_QWORD *)(a1 + 920) = 0;
  *(_QWORD *)(a1 + 912) = 0;
  v24 = *a14;
  v25 = a14[1];
  v26 = v25 - *a14;
  if (v25 != *a14)
  {
    v27 = 0xAAAAAAAAAAAAAAABLL * (v26 >> 3);
    if (v27 > 0xAAAAAAAAAAAAAAALL)
      goto LABEL_27;
    v28 = (char *)operator new(v26);
    v29 = 0;
    *(_QWORD *)(a1 + 904) = v28;
    *(_QWORD *)(a1 + 912) = v28;
    *(_QWORD *)(a1 + 920) = &v28[24 * v27];
    do
    {
      while (1)
      {
        v30 = (__int128 *)(v24 + v29);
        v31 = (std::string *)&v28[v29];
        if ((*(char *)(v24 + v29 + 23) & 0x80000000) == 0)
          break;
        std::string::__init_copy_ctor_external(v31, *(const std::string::value_type **)v30, *((_QWORD *)v30 + 1));
        v29 += 24;
        if (v24 + v29 == v25)
          goto LABEL_11;
      }
      v32 = *v30;
      v31->__r_.__value_.__r.__words[2] = *((_QWORD *)v30 + 2);
      *(_OWORD *)&v31->__r_.__value_.__l.__data_ = v32;
      v29 += 24;
    }
    while (v24 + v29 != v25);
LABEL_11:
    *(_QWORD *)(a1 + 912) = &v28[v29];
  }
  *(_QWORD *)(a1 + 944) = 0;
  *(_OWORD *)(a1 + 928) = 0u;
  v33 = *a15;
  v34 = a15[1];
  v35 = v34 - *a15;
  if (v34 == *a15)
    goto LABEL_19;
  v36 = 0xAAAAAAAAAAAAAAABLL * (v35 >> 3);
  if (v36 > 0xAAAAAAAAAAAAAAALL)
LABEL_27:
    abort();
  v37 = (char *)operator new(v35);
  v38 = 0;
  *(_QWORD *)(a1 + 928) = v37;
  *(_QWORD *)(a1 + 936) = v37;
  *(_QWORD *)(a1 + 944) = &v37[24 * v36];
  do
  {
    while (1)
    {
      v40 = (__int128 *)(v33 + v38);
      v41 = (std::string *)&v37[v38];
      if (*(char *)(v33 + v38 + 23) < 0)
        break;
      v39 = *v40;
      v41->__r_.__value_.__r.__words[2] = *((_QWORD *)v40 + 2);
      *(_OWORD *)&v41->__r_.__value_.__l.__data_ = v39;
      v38 += 24;
      if (v33 + v38 == v34)
        goto LABEL_18;
    }
    std::string::__init_copy_ctor_external(v41, *(const std::string::value_type **)v40, *((_QWORD *)v40 + 1));
    v38 += 24;
  }
  while (v33 + v38 != v34);
LABEL_18:
  *(_QWORD *)(a1 + 936) = &v37[v38];
LABEL_19:
  *(_QWORD *)(a1 + 952) = a17;
  v42 = (std::string *)(a1 + 960);
  if (*((char *)a12 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v42, *(const std::string::value_type **)a12, *((_QWORD *)a12 + 1));
    v44 = a16;
    v45 = a13;
    v46 = (std::string *)(a1 + 984);
    if ((*((char *)a12 + 47) & 0x80000000) == 0)
      goto LABEL_21;
LABEL_23:
    std::string::__init_copy_ctor_external(v46, *((const std::string::value_type **)a12 + 3), *((_QWORD *)a12 + 4));
    goto LABEL_24;
  }
  v43 = *a12;
  *(_QWORD *)(a1 + 976) = *((_QWORD *)a12 + 2);
  *(_OWORD *)&v42->__r_.__value_.__l.__data_ = v43;
  v44 = a16;
  v45 = a13;
  v46 = (std::string *)(a1 + 984);
  if (*((char *)a12 + 47) < 0)
    goto LABEL_23;
LABEL_21:
  v47 = *(__int128 *)((char *)a12 + 24);
  v46->__r_.__value_.__r.__words[2] = *((_QWORD *)a12 + 5);
  *(_OWORD *)&v46->__r_.__value_.__l.__data_ = v47;
LABEL_24:
  *(_OWORD *)(a1 + 1016) = 0u;
  *(_QWORD *)(a1 + 1008) = a1 + 1016;
  *(_QWORD *)(a1 + 1032) = a5;
  *(_QWORD *)(a1 + 1048) = 0;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_QWORD *)(a1 + 1040) = a1 + 1048;
  *(_QWORD *)(a1 + 1072) = 0xFFFFFFFF00000000;
  v51[0] = &off_24C0C2CA0;
  v51[1] = a1;
  v51[3] = v51;
  *(_OWORD *)(a1 + 1096) = 0u;
  *(_QWORD *)(a1 + 1080) = a2;
  *(_QWORD *)(a1 + 1088) = a1 + 1096;
  *(_QWORD *)(a1 + 1136) = a1 + 1112;
  *(_QWORD *)(a1 + 1112) = &off_24C0C2CA0;
  *(_QWORD *)(a1 + 1120) = a1;
  *(_QWORD *)(a1 + 1208) = 0;
  *(_OWORD *)(a1 + 1176) = 0u;
  *(_OWORD *)(a1 + 1192) = 0u;
  *(_OWORD *)(a1 + 1144) = 0u;
  *(_OWORD *)(a1 + 1160) = 0u;
  *(_DWORD *)(a1 + 1216) = 0x4000;
  *(_QWORD *)(a1 + 1240) = 0;
  *(_DWORD *)(a1 + 1248) = 0;
  *(_OWORD *)(a1 + 1224) = 0u;
  *(_DWORD *)(a1 + 1252) = v45;
  *(_QWORD *)(a1 + 1256) = 0;
  *(_QWORD *)(a1 + 1264) = v44;
  *(_QWORD *)(a1 + 1288) = 0;
  *(_OWORD *)(a1 + 1272) = 0u;
  v48 = operator new();
  *(_DWORD *)v48 = 0;
  *(_BYTE *)(v48 + 4) = 1;
  *(_QWORD *)(a1 + 1296) = v48;
  do
    v49 = __ldxr((unsigned int *)v48);
  while (__stxr(v49 + 1, (unsigned int *)v48));
  *(_QWORD *)(a1 + 1304) = 0;
  return a1;
}

void cricket::TurnPort::ReconstructServerUrl(std::string *this, uint64_t a2)
{
  int v4;
  size_t v5;
  int v6;
  std::string::size_type size;
  std::string::size_type v8;
  unsigned __int8 v9;
  size_t v10;
  BOOL v11;
  std::string *p_p_new_stuff;
  std::string *p_dst;
  _BYTE *v14;
  std::string::size_type v15;
  std::string::size_type v16;
  std::string::size_type v17;
  std::string *v18;
  char *v19;
  std::string::size_type v20;
  std::string::size_type v21;
  std::string::size_type v22;
  std::string *v23;
  _BYTE *v24;
  std::string::size_type v25;
  std::string *v26;
  std::string *v27;
  int v28;
  std::string::size_type v29;
  std::string::size_type v30;
  unsigned __int8 v31;
  size_t v32;
  BOOL v33;
  char *v34;
  std::string *v35;
  std::string::size_type v36;
  std::string::size_type v37;
  int v38;
  std::string::size_type v39;
  std::string::size_type v40;
  std::string *v41;
  char *v42;
  std::string::size_type v43;
  std::string __p_new_stuff;
  std::string __dst;
  std::string::value_type *v46;
  size_t v47;
  char v48;
  void *__src[2];
  char v50;

  v50 = 4;
  if (__src <= (void **)"turn" && (char *)__src + 4 > "turn")
    goto LABEL_114;
  strcpy((char *)__src, "turn");
  v48 = 3;
  if (&v46 <= (std::string::value_type **)"tcp" && (char *)&v46 + 3 > "tcp")
    goto LABEL_114;
  LODWORD(v46) = 7365492;
  v4 = *(_DWORD *)(a2 + 864);
  if ((v4 - 2) >= 2)
  {
    if (!v4)
    {
      v48 = 3;
      qmemcpy(&v46, "udp", 3);
    }
    v5 = 4;
  }
  else
  {
    v5 = 5;
    v50 = 5;
    strcpy((char *)__src, "turns");
  }
  memset(&__dst, 0, sizeof(__dst));
  if (&__dst <= (std::string *)__src && ((unint64_t)&__dst | v5) > (unint64_t)__src)
    goto LABEL_114;
  memcpy(&__dst, __src, v5);
  v6 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    __dst.__r_.__value_.__l.__size_ = v5;
    size = v5;
  }
  else
  {
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v5;
    size = __dst.__r_.__value_.__l.__size_;
    v6 = v5;
  }
  *(_BYTE *)((unint64_t)&__dst | v5) = 0;
  if (v6 >= 0)
    v8 = 22;
  else
    v8 = (__dst.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v6 >= 0)
    size = v6;
  if (v8 == size)
  {
    std::string::__grow_by_and_replace(&__dst, v8, 1uLL, v8, v8, 0, 1uLL, ":");
    rtc::SocketAddress::HostAsURIString((rtc::SocketAddress *)(a2 + 792), &__p_new_stuff);
    v9 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_22:
      v10 = v9;
      v11 = v9 == 0;
      p_p_new_stuff = &__p_new_stuff;
      goto LABEL_33;
    }
  }
  else
  {
    if (v6 >= 0)
      p_dst = &__dst;
    else
      p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
    v14 = (char *)p_dst + size;
    if ((char *)p_dst + size <= ":" && v14 + 1 > ":")
      goto LABEL_114;
    *v14 = 58;
    v15 = size + 1;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      __dst.__r_.__value_.__l.__size_ = v15;
      p_dst->__r_.__value_.__s.__data_[v15] = 0;
      rtc::SocketAddress::HostAsURIString((rtc::SocketAddress *)(a2 + 792), &__p_new_stuff);
      v9 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
      if ((SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_22;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v15 & 0x7F;
      p_dst->__r_.__value_.__s.__data_[v15] = 0;
      rtc::SocketAddress::HostAsURIString((rtc::SocketAddress *)(a2 + 792), &__p_new_stuff);
      v9 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
      if ((SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_22;
    }
  }
  v10 = __p_new_stuff.__r_.__value_.__l.__size_;
  if ((__p_new_stuff.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
    goto LABEL_114;
  p_p_new_stuff = (std::string *)__p_new_stuff.__r_.__value_.__r.__words[0];
  v11 = __p_new_stuff.__r_.__value_.__l.__size_ == 0;
  if (__p_new_stuff.__r_.__value_.__l.__size_)
  {
    if (!__p_new_stuff.__r_.__value_.__r.__words[0])
      goto LABEL_114;
  }
LABEL_33:
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v16 = 22;
  else
    v16 = (__dst.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  else
    v17 = __dst.__r_.__value_.__l.__size_;
  if (v16 - v17 >= v10)
  {
    if (!v11)
    {
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v18 = &__dst;
      else
        v18 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      v19 = (char *)v18 + v17;
      if ((std::string *)((char *)v18 + v17) <= p_p_new_stuff && &v19[v10] > (char *)p_p_new_stuff)
        goto LABEL_114;
      memmove(v19, p_p_new_stuff, v10);
      v20 = v17 + v10;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        __dst.__r_.__value_.__l.__size_ = v17 + v10;
      else
        *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v20 & 0x7F;
      v18->__r_.__value_.__s.__data_[v20] = 0;
    }
  }
  else
  {
    std::string::__grow_by_and_replace(&__dst, v16, v17 + v10 - v16, v17, v17, 0, v10, (const std::string::value_type *)p_p_new_stuff);
  }
  v21 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v22 = 22;
  else
    v22 = (__dst.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v21 = __dst.__r_.__value_.__l.__size_;
  if (v22 == v21)
  {
    std::string::__grow_by_and_replace(&__dst, v22, 1uLL, v22, v22, 0, 1uLL, ":");
  }
  else
  {
    v23 = &__dst;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v23 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    v24 = (char *)v23 + v21;
    if ((char *)v23 + v21 <= ":" && v24 + 1 > ":")
      goto LABEL_114;
    *v24 = 58;
    v25 = v21 + 1;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      __dst.__r_.__value_.__l.__size_ = v25;
    else
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v25 & 0x7F;
    v23->__r_.__value_.__s.__data_[v25] = 0;
  }
  v26 = rtc::StringBuilder::operator<<(&__dst, *(unsigned __int16 *)(a2 + 848));
  v27 = v26;
  v28 = SHIBYTE(v26->__r_.__value_.__r.__words[2]);
  if (v28 >= 0)
    v29 = 22;
  else
    v29 = (v26->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v28 >= 0)
    v30 = HIBYTE(v26->__r_.__value_.__r.__words[2]);
  else
    v30 = v26->__r_.__value_.__l.__size_;
  if (v29 - v30 >= 0xB)
  {
    if (v28 >= 0)
      v35 = v26;
    else
      v35 = (std::string *)v26->__r_.__value_.__r.__words[0];
    v36 = (std::string::size_type)v35 + v30;
    if ((char *)v35 + v30 <= "?transport=" && v36 + 11 > (unint64_t)"?transport=")
      goto LABEL_114;
    *(_DWORD *)(v36 + 7) = 1031041647;
    *(_QWORD *)v36 = *(_QWORD *)"?transport=";
    v37 = v30 + 11;
    if (SHIBYTE(v26->__r_.__value_.__r.__words[2]) < 0)
    {
      v26->__r_.__value_.__l.__size_ = v37;
      v35->__r_.__value_.__s.__data_[v37] = 0;
      v31 = v48;
      if ((v48 & 0x80000000) == 0)
        goto LABEL_76;
    }
    else
    {
      *((_BYTE *)&v26->__r_.__value_.__s + 23) = v37 & 0x7F;
      v35->__r_.__value_.__s.__data_[v37] = 0;
      v31 = v48;
      if ((v48 & 0x80000000) == 0)
        goto LABEL_76;
    }
  }
  else
  {
    std::string::__grow_by_and_replace(v26, v29, v30 - v29 + 11, v30, v30, 0, 0xBuLL, "?transport=");
    v31 = v48;
    if ((v48 & 0x80000000) == 0)
    {
LABEL_76:
      v32 = v31;
      v33 = v31 == 0;
      v34 = (char *)&v46;
      goto LABEL_87;
    }
  }
  v32 = v47;
  if ((v47 & 0x8000000000000000) != 0)
    goto LABEL_114;
  v34 = v46;
  v33 = v47 == 0;
  if (v47)
  {
    if (!v46)
      goto LABEL_114;
  }
LABEL_87:
  v38 = SHIBYTE(v27->__r_.__value_.__r.__words[2]);
  if (v38 >= 0)
    v39 = 22;
  else
    v39 = (v27->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v38 >= 0)
    v40 = HIBYTE(v27->__r_.__value_.__r.__words[2]);
  else
    v40 = v27->__r_.__value_.__l.__size_;
  if (v39 - v40 >= v32)
  {
    if (v33)
      goto LABEL_106;
    if (v38 >= 0)
      v41 = v27;
    else
      v41 = (std::string *)v27->__r_.__value_.__r.__words[0];
    v42 = (char *)v41 + v40;
    if ((char *)v41 + v40 > v34 || &v42[v32] <= v34)
    {
      memmove(v42, v34, v32);
      v43 = v40 + v32;
      if (SHIBYTE(v27->__r_.__value_.__r.__words[2]) < 0)
      {
        v27->__r_.__value_.__l.__size_ = v43;
        v41->__r_.__value_.__s.__data_[v43] = 0;
        if ((SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_107;
LABEL_95:
        operator delete(__p_new_stuff.__r_.__value_.__l.__data_);
        *this = __dst;
        if (v48 < 0)
          goto LABEL_96;
LABEL_108:
        if (v50 < 0)
          goto LABEL_97;
        return;
      }
      *((_BYTE *)&v27->__r_.__value_.__s + 23) = v43 & 0x7F;
      v41->__r_.__value_.__s.__data_[v43] = 0;
LABEL_106:
      if ((SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_107;
      goto LABEL_95;
    }
LABEL_114:
    __break(1u);
    return;
  }
  std::string::__grow_by_and_replace(v27, v39, v40 + v32 - v39, v40, v40, 0, v32, v34);
  if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_95;
LABEL_107:
  *this = __dst;
  if ((v48 & 0x80000000) == 0)
    goto LABEL_108;
LABEL_96:
  operator delete(v46);
  if (v50 < 0)
LABEL_97:
    operator delete(__src[0]);
}

uint64_t cricket::TurnPort::TurnPort(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 a5, __int16 a6, void **__src, size_t a8, void **a9, size_t a10, __int128 *a11, __int128 *a12, int a13, uint64_t *a14, uint64_t *a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  _QWORD *v20;
  __int128 *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  int64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  __int128 *v29;
  std::string *v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  int64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t v37;
  __int128 v38;
  __int128 *v39;
  std::string *v40;
  std::string *v41;
  __int128 v42;
  uint64_t v43;
  int v44;
  std::string *v45;
  __int128 v46;
  uint64_t v47;
  unsigned int v48;
  _QWORD v50[5];

  v50[4] = *MEMORY[0x24BDAC8D0];
  v20 = (_QWORD *)cricket::Port::Port(a1, a2, 3, a3, a4, a5, a6, a8, __src, a8, a9, a10, a18, 0);
  *v20 = &off_24C0C2998;
  v20[29] = &unk_24C0C2B40;
  v21 = (__int128 *)(v20 + 99);
  *(_QWORD *)(a1 + 792) = 0;
  *(_QWORD *)(a1 + 808) = 0;
  *(_QWORD *)(a1 + 800) = 0;
  *(_QWORD *)(a1 + 816) = &unk_24C0ACDA0;
  *(_QWORD *)(a1 + 832) = 0;
  *(_QWORD *)(a1 + 824) = 0;
  *(_DWORD *)(a1 + 840) = 0;
  if (v21 != a11)
  {
    if (*((char *)a11 + 23) < 0)
    {
      std::string::__assign_no_alias<true>(v21, *(char **)a11, *((_QWORD *)a11 + 1));
    }
    else
    {
      v22 = *a11;
      *((_QWORD *)v21 + 2) = *((_QWORD *)a11 + 2);
      *v21 = v22;
    }
  }
  *(_DWORD *)(a1 + 824) = *((_DWORD *)a11 + 8);
  *(_OWORD *)(a1 + 828) = *(__int128 *)((char *)a11 + 36);
  *(_WORD *)(a1 + 848) = *((_WORD *)a11 + 28);
  *(_BYTE *)(a1 + 856) = *((_BYTE *)a11 + 64);
  *(_DWORD *)(a1 + 852) = *((_DWORD *)a11 + 15);
  *(_DWORD *)(a1 + 864) = *((_DWORD *)a11 + 18);
  cricket::TurnPort::ReconstructServerUrl((std::string *)(a1 + 872), a1);
  *(_DWORD *)(a1 + 896) = 0;
  *(_QWORD *)(a1 + 904) = 0;
  *(_QWORD *)(a1 + 920) = 0;
  *(_QWORD *)(a1 + 912) = 0;
  v23 = *a14;
  v24 = a14[1];
  v25 = v24 - *a14;
  if (v24 != *a14)
  {
    v26 = 0xAAAAAAAAAAAAAAABLL * (v25 >> 3);
    if (v26 > 0xAAAAAAAAAAAAAAALL)
      goto LABEL_27;
    v27 = (char *)operator new(v25);
    v28 = 0;
    *(_QWORD *)(a1 + 904) = v27;
    *(_QWORD *)(a1 + 912) = v27;
    *(_QWORD *)(a1 + 920) = &v27[24 * v26];
    do
    {
      while (1)
      {
        v29 = (__int128 *)(v23 + v28);
        v30 = (std::string *)&v27[v28];
        if ((*(char *)(v23 + v28 + 23) & 0x80000000) == 0)
          break;
        std::string::__init_copy_ctor_external(v30, *(const std::string::value_type **)v29, *((_QWORD *)v29 + 1));
        v28 += 24;
        if (v23 + v28 == v24)
          goto LABEL_11;
      }
      v31 = *v29;
      v30->__r_.__value_.__r.__words[2] = *((_QWORD *)v29 + 2);
      *(_OWORD *)&v30->__r_.__value_.__l.__data_ = v31;
      v28 += 24;
    }
    while (v23 + v28 != v24);
LABEL_11:
    *(_QWORD *)(a1 + 912) = &v27[v28];
  }
  *(_QWORD *)(a1 + 944) = 0;
  *(_OWORD *)(a1 + 928) = 0u;
  v32 = *a15;
  v33 = a15[1];
  v34 = v33 - *a15;
  if (v33 == *a15)
    goto LABEL_19;
  v35 = 0xAAAAAAAAAAAAAAABLL * (v34 >> 3);
  if (v35 > 0xAAAAAAAAAAAAAAALL)
LABEL_27:
    abort();
  v36 = (char *)operator new(v34);
  v37 = 0;
  *(_QWORD *)(a1 + 928) = v36;
  *(_QWORD *)(a1 + 936) = v36;
  *(_QWORD *)(a1 + 944) = &v36[24 * v35];
  do
  {
    while (1)
    {
      v39 = (__int128 *)(v32 + v37);
      v40 = (std::string *)&v36[v37];
      if (*(char *)(v32 + v37 + 23) < 0)
        break;
      v38 = *v39;
      v40->__r_.__value_.__r.__words[2] = *((_QWORD *)v39 + 2);
      *(_OWORD *)&v40->__r_.__value_.__l.__data_ = v38;
      v37 += 24;
      if (v32 + v37 == v33)
        goto LABEL_18;
    }
    std::string::__init_copy_ctor_external(v40, *(const std::string::value_type **)v39, *((_QWORD *)v39 + 1));
    v37 += 24;
  }
  while (v32 + v37 != v33);
LABEL_18:
  *(_QWORD *)(a1 + 936) = &v36[v37];
LABEL_19:
  *(_QWORD *)(a1 + 952) = a17;
  v41 = (std::string *)(a1 + 960);
  if (*((char *)a12 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v41, *(const std::string::value_type **)a12, *((_QWORD *)a12 + 1));
    v43 = a16;
    v44 = a13;
    v45 = (std::string *)(a1 + 984);
    if ((*((char *)a12 + 47) & 0x80000000) == 0)
      goto LABEL_21;
LABEL_23:
    std::string::__init_copy_ctor_external(v45, *((const std::string::value_type **)a12 + 3), *((_QWORD *)a12 + 4));
    goto LABEL_24;
  }
  v42 = *a12;
  *(_QWORD *)(a1 + 976) = *((_QWORD *)a12 + 2);
  *(_OWORD *)&v41->__r_.__value_.__l.__data_ = v42;
  v43 = a16;
  v44 = a13;
  v45 = (std::string *)(a1 + 984);
  if (*((char *)a12 + 47) < 0)
    goto LABEL_23;
LABEL_21:
  v46 = *(__int128 *)((char *)a12 + 24);
  v45->__r_.__value_.__r.__words[2] = *((_QWORD *)a12 + 5);
  *(_OWORD *)&v45->__r_.__value_.__l.__data_ = v46;
LABEL_24:
  *(_OWORD *)(a1 + 1016) = 0u;
  *(_QWORD *)(a1 + 1008) = a1 + 1016;
  *(_QWORD *)(a1 + 1032) = 0;
  *(_QWORD *)(a1 + 1048) = 0;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_QWORD *)(a1 + 1040) = a1 + 1048;
  *(_QWORD *)(a1 + 1072) = 0xFFFFFFFF00000000;
  v50[0] = &off_24C0C2CE8;
  v50[1] = a1;
  v50[3] = v50;
  *(_OWORD *)(a1 + 1096) = 0u;
  *(_QWORD *)(a1 + 1080) = a2;
  *(_QWORD *)(a1 + 1088) = a1 + 1096;
  *(_QWORD *)(a1 + 1136) = a1 + 1112;
  *(_QWORD *)(a1 + 1112) = &off_24C0C2CE8;
  *(_QWORD *)(a1 + 1120) = a1;
  *(_QWORD *)(a1 + 1208) = 0;
  *(_OWORD *)(a1 + 1176) = 0u;
  *(_OWORD *)(a1 + 1192) = 0u;
  *(_OWORD *)(a1 + 1144) = 0u;
  *(_OWORD *)(a1 + 1160) = 0u;
  *(_DWORD *)(a1 + 1216) = 0x4000;
  *(_QWORD *)(a1 + 1240) = 0;
  *(_DWORD *)(a1 + 1248) = 0;
  *(_OWORD *)(a1 + 1224) = 0u;
  *(_DWORD *)(a1 + 1252) = v44;
  *(_QWORD *)(a1 + 1256) = 0;
  *(_QWORD *)(a1 + 1264) = v43;
  *(_QWORD *)(a1 + 1288) = 0;
  *(_OWORD *)(a1 + 1272) = 0u;
  v47 = operator new();
  *(_DWORD *)v47 = 0;
  *(_BYTE *)(v47 + 4) = 1;
  *(_QWORD *)(a1 + 1296) = v47;
  do
    v48 = __ldxr((unsigned int *)v47);
  while (__stxr(v48 + 1, (unsigned int *)v47));
  *(_QWORD *)(a1 + 1304) = 0;
  return a1;
}

void cricket::TurnPort::~TurnPort(cricket::TurnPort *this)
{
  cricket::TurnRefreshRequest *v2;
  cricket::TurnRefreshRequest *refreshed;
  const void **v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  _QWORD *v19;
  cricket::TurnPort *v20;
  cricket::TurnPort *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  void **v28;
  void **v29;
  void **v30;
  void *v31;
  void **v32;
  void *v33;
  cricket::TurnRefreshRequest *v34;

  *(_QWORD *)this = &off_24C0C2998;
  *((_QWORD *)this + 29) = &unk_24C0C2B40;
  if (*((_DWORD *)this + 312) == 2)
  {
    std::__tree<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>>>::destroy((uint64_t)this + 1088, *((char **)this + 137));
    *((_QWORD *)this + 136) = (char *)this + 1096;
    *((_QWORD *)this + 138) = 0;
    *((_QWORD *)this + 137) = 0;
    v2 = (cricket::TurnRefreshRequest *)operator new();
    refreshed = cricket::TurnRefreshRequest::TurnRefreshRequest(v2, this, 0);
    v4 = (const void **)(*((_QWORD *)refreshed + 2) + 40);
    v34 = refreshed;
    std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>((uint64_t)this + 1088, v4, (uint64_t)v4, (uint64_t *)&v34);
    v5 = (uint64_t)v34;
    v34 = 0;
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    v6 = *((_QWORD *)v2 + 5);
    if (v6)
    {
      do
        v7 = __ldxr((unsigned int *)v6);
      while (__stxr(v7 + 1, (unsigned int *)v6));
      *(_BYTE *)(v6 + 4) = 1;
      do
      {
        v8 = __ldaxr((unsigned int *)v6);
        v9 = v8 - 1;
      }
      while (__stlxr(v9, (unsigned int *)v6));
      if (!v9)
        MEMORY[0x20BD0ADEC]();
    }
    else
    {
      MEMORY[4] = 1;
    }
    cricket::StunRequest::SendInternal(v2);
    *((_DWORD *)this + 312) = 3;
  }
  v10 = (_QWORD *)*((_QWORD *)this + 154);
  v11 = (_QWORD *)*((_QWORD *)this + 153);
  while (v10 != v11)
  {
    v13 = *--v10;
    v12 = v13;
    *v10 = 0;
    if (v13)
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  }
  *((_QWORD *)this + 154) = v11;
  v14 = *((_QWORD *)this + 129);
  if (v14)
    webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(v14 + 280), this);
  if (((*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 64))(this) & 1) == 0)
  {
    v15 = *((_QWORD *)this + 129);
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  }
  v16 = *((_QWORD *)this + 162);
  *(_BYTE *)(v16 + 4) = 0;
  do
  {
    v17 = __ldaxr((unsigned int *)v16);
    v18 = v17 - 1;
  }
  while (__stlxr(v18, (unsigned int *)v16));
  if (v18)
  {
    if ((*((char *)this + 1295) & 0x80000000) == 0)
      goto LABEL_25;
  }
  else
  {
    MEMORY[0x20BD0ADEC]();
    if ((*((char *)this + 1295) & 0x80000000) == 0)
    {
LABEL_25:
      v19 = (_QWORD *)*((_QWORD *)this + 153);
      if (!v19)
        goto LABEL_26;
LABEL_34:
      v23 = (_QWORD *)*((_QWORD *)this + 154);
      if (v23 == v19)
      {
        *((_QWORD *)this + 154) = v19;
        operator delete(v19);
        if (*((char *)this + 1215) < 0)
          goto LABEL_41;
      }
      else
      {
        do
        {
          v25 = *--v23;
          v24 = v25;
          *v23 = 0;
          if (v25)
            (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
        }
        while (v23 != v19);
        v26 = (void *)*((_QWORD *)this + 153);
        *((_QWORD *)this + 154) = v19;
        operator delete(v26);
        if (*((char *)this + 1215) < 0)
          goto LABEL_41;
      }
LABEL_27:
      if ((*((char *)this + 1191) & 0x80000000) == 0)
        goto LABEL_28;
      goto LABEL_42;
    }
  }
  operator delete(*((void **)this + 159));
  v19 = (_QWORD *)*((_QWORD *)this + 153);
  if (v19)
    goto LABEL_34;
LABEL_26:
  if ((*((char *)this + 1215) & 0x80000000) == 0)
    goto LABEL_27;
LABEL_41:
  operator delete(*((void **)this + 149));
  if ((*((char *)this + 1191) & 0x80000000) == 0)
  {
LABEL_28:
    if ((*((char *)this + 1167) & 0x80000000) == 0)
      goto LABEL_29;
LABEL_43:
    operator delete(*((void **)this + 143));
    v20 = (cricket::TurnPort *)((char *)this + 1112);
    v21 = (cricket::TurnPort *)*((_QWORD *)this + 142);
    if (v21 != (cricket::TurnPort *)((char *)this + 1112))
      goto LABEL_30;
LABEL_44:
    v22 = 4;
    v21 = v20;
    goto LABEL_45;
  }
LABEL_42:
  operator delete(*((void **)this + 146));
  if (*((char *)this + 1167) < 0)
    goto LABEL_43;
LABEL_29:
  v20 = (cricket::TurnPort *)((char *)this + 1112);
  v21 = (cricket::TurnPort *)*((_QWORD *)this + 142);
  if (v21 == (cricket::TurnPort *)((char *)this + 1112))
    goto LABEL_44;
LABEL_30:
  if (!v21)
    goto LABEL_46;
  v22 = 5;
LABEL_45:
  (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
LABEL_46:
  std::__tree<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>>>::destroy((uint64_t)this + 1088, *((char **)this + 137));
  v27 = *((_QWORD *)this + 133);
  *((_QWORD *)this + 133) = 0;
  if (v27)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 1040, *((_QWORD **)this + 131));
  std::__tree<rtc::SocketAddress>::destroy((uint64_t)this + 1008, *((char **)this + 127));
  if (*((char *)this + 1007) < 0)
  {
    operator delete(*((void **)this + 123));
    if ((*((char *)this + 983) & 0x80000000) == 0)
    {
LABEL_50:
      v28 = (void **)*((_QWORD *)this + 116);
      if (!v28)
        goto LABEL_51;
LABEL_57:
      v30 = (void **)*((_QWORD *)this + 117);
      if (v30 == v28)
      {
        *((_QWORD *)this + 117) = v28;
        operator delete(v28);
        v29 = (void **)*((_QWORD *)this + 113);
        if (v29)
          goto LABEL_64;
      }
      else
      {
        do
        {
          if (*((char *)v30 - 1) < 0)
            operator delete(*(v30 - 3));
          v30 -= 3;
        }
        while (v30 != v28);
        v31 = (void *)*((_QWORD *)this + 116);
        *((_QWORD *)this + 117) = v28;
        operator delete(v31);
        v29 = (void **)*((_QWORD *)this + 113);
        if (v29)
          goto LABEL_64;
      }
LABEL_52:
      if ((*((char *)this + 895) & 0x80000000) == 0)
        goto LABEL_53;
LABEL_71:
      operator delete(*((void **)this + 109));
      if ((*((char *)this + 815) & 0x80000000) == 0)
        goto LABEL_54;
      goto LABEL_72;
    }
  }
  else if ((*((char *)this + 983) & 0x80000000) == 0)
  {
    goto LABEL_50;
  }
  operator delete(*((void **)this + 120));
  v28 = (void **)*((_QWORD *)this + 116);
  if (v28)
    goto LABEL_57;
LABEL_51:
  v29 = (void **)*((_QWORD *)this + 113);
  if (!v29)
    goto LABEL_52;
LABEL_64:
  v32 = (void **)*((_QWORD *)this + 114);
  if (v32 == v29)
  {
    *((_QWORD *)this + 114) = v29;
    operator delete(v29);
    if (*((char *)this + 895) < 0)
      goto LABEL_71;
  }
  else
  {
    do
    {
      if (*((char *)v32 - 1) < 0)
        operator delete(*(v32 - 3));
      v32 -= 3;
    }
    while (v32 != v29);
    v33 = (void *)*((_QWORD *)this + 113);
    *((_QWORD *)this + 114) = v29;
    operator delete(v33);
    if (*((char *)this + 895) < 0)
      goto LABEL_71;
  }
LABEL_53:
  if ((*((char *)this + 815) & 0x80000000) == 0)
  {
LABEL_54:
    cricket::Port::~Port(this);
    return;
  }
LABEL_72:
  operator delete(*((void **)this + 99));
  cricket::Port::~Port(this);
}

{
  cricket::TurnPort::~TurnPort(this);
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'cricket::TurnPort::~TurnPort(cricket::TurnPort *this)
{
  cricket::TurnPort::~TurnPort((cricket::TurnPort *)((char *)this - 232));
}

{
  cricket::TurnPort::~TurnPort((cricket::TurnPort *)((char *)this - 232));
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::TurnPort::set_realm(uint64_t a1, __int128 *__src, size_t __len)
{
  uint64_t v6;
  unsigned __int8 v7;
  const void *v8;
  uint64_t v9;
  __int128 *p_dst;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  size_t v19;
  __int128 __dst;
  unint64_t v21;

  if (__len)
  {
    v6 = a1 + 1144;
    v7 = *(_BYTE *)(a1 + 1167);
    v8 = (const void *)(a1 + 1144);
    v9 = v7;
    if (((char)v7 & 0x80000000) == 0
      || (v9 = *(_QWORD *)(a1 + 1152), (v9 & 0x8000000000000000) == 0) && ((v8 = *(const void **)v6, !v9) || v8))
    {
      if (__len == v9 && !memcmp(__src, v8, __len))
        return;
      if (__len >= 0x7FFFFFFFFFFFFFF8)
LABEL_23:
        abort();
      if (__len > 0x16)
      {
        v18 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((__len | 7) != 0x17)
          v18 = __len | 7;
        v19 = v18 + 1;
        p_dst = (__int128 *)operator new(v18 + 1);
        *((_QWORD *)&__dst + 1) = __len;
        v21 = v19 | 0x8000000000000000;
        *(_QWORD *)&__dst = p_dst;
        if (p_dst > __src)
          goto LABEL_18;
      }
      else
      {
        HIBYTE(v21) = __len;
        p_dst = &__dst;
        if (&__dst > __src)
          goto LABEL_18;
      }
      if ((__int128 *)((char *)p_dst + __len) <= __src)
      {
LABEL_18:
        memmove(p_dst, __src, __len);
        *((_BYTE *)p_dst + __len) = 0;
        if ((v7 & 0x80) != 0)
          operator delete(*(void **)v6);
        *(_OWORD *)v6 = __dst;
        *(_QWORD *)(v6 + 16) = v21;
        cricket::ComputeStunCredentialHash(a1 + 960, (char **)v6, a1 + 984, a1 + 1192);
        return;
      }
    }
    __break(1u);
    goto LABEL_23;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t\t", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
}

uint64_t cricket::TurnPort::GetProtocol(cricket::TurnPort *this)
{
  return *((unsigned int *)this + 216);
}

uint64_t cricket::TurnPort::GetTlsCertPolicy(cricket::TurnPort *this)
{
  return *((unsigned int *)this + 224);
}

uint64_t cricket::TurnPort::SetTlsCertPolicy(uint64_t result, int a2)
{
  *(_DWORD *)(result + 896) = a2;
  return result;
}

void cricket::TurnPort::GetTlsAlpnProtocols(cricket::TurnPort *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  int64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  __int128 *v9;
  std::string *v10;
  __int128 v11;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v2 = *((_QWORD *)this + 113);
  v3 = *((_QWORD *)this + 114);
  v4 = v3 - v2;
  if (v3 != v2)
  {
    v6 = 0xAAAAAAAAAAAAAAABLL * (v4 >> 3);
    if (v6 >= 0xAAAAAAAAAAAAAABLL)
      abort();
    v7 = (char *)operator new(v4);
    v8 = 0;
    *a2 = v7;
    a2[2] = &v7[24 * v6];
    do
    {
      while (1)
      {
        v9 = (__int128 *)(v2 + v8);
        v10 = (std::string *)&v7[v8];
        if ((*(char *)(v2 + v8 + 23) & 0x80000000) == 0)
          break;
        std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)v9, *((_QWORD *)v9 + 1));
        v8 += 24;
        if (v2 + v8 == v3)
          goto LABEL_7;
      }
      v11 = *v9;
      v10->__r_.__value_.__r.__words[2] = *((_QWORD *)v9 + 2);
      *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
      v8 += 24;
    }
    while (v2 + v8 != v3);
LABEL_7:
    a2[1] = &v7[v8];
  }
}

void cricket::TurnPort::GetTlsEllipticCurves(cricket::TurnPort *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  int64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  __int128 *v9;
  std::string *v10;
  __int128 v11;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v2 = *((_QWORD *)this + 116);
  v3 = *((_QWORD *)this + 117);
  v4 = v3 - v2;
  if (v3 != v2)
  {
    v6 = 0xAAAAAAAAAAAAAAABLL * (v4 >> 3);
    if (v6 >= 0xAAAAAAAAAAAAAABLL)
      abort();
    v7 = (char *)operator new(v4);
    v8 = 0;
    *a2 = v7;
    a2[2] = &v7[24 * v6];
    do
    {
      while (1)
      {
        v9 = (__int128 *)(v2 + v8);
        v10 = (std::string *)&v7[v8];
        if ((*(char *)(v2 + v8 + 23) & 0x80000000) == 0)
          break;
        std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)v9, *((_QWORD *)v9 + 1));
        v8 += 24;
        if (v2 + v8 == v3)
          goto LABEL_7;
      }
      v11 = *v9;
      v10->__r_.__value_.__r.__words[2] = *((_QWORD *)v9 + 2);
      *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
      v8 += 24;
    }
    while (v2 + v8 != v3);
LABEL_7:
    a2[1] = &v7[v8];
  }
}

void cricket::TurnPort::PrepareAddress(cricket::TurnPort *this)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  cricket::TurnAllocateRequest *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  void *v53;
  uint64_t v54;
  uint64_t v55;
  void *__p[2];
  char v57;
  void *v58;
  int v59;
  __int16 v60;
  __n128 (*v61)(uint64_t, __n128 *, __n128 *);
  void (*v62)(uint64_t *);

  if (*((char *)this + 983) < 0)
  {
    if (!*((_QWORD *)this + 121))
      goto LABEL_17;
  }
  else if (!*((_BYTE *)this + 983))
  {
    goto LABEL_17;
  }
  if ((*((char *)this + 1007) & 0x80000000) == 0)
  {
    if (*((_BYTE *)this + 1007))
      goto LABEL_7;
LABEL_17:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    cricket::TurnPort::OnAllocateError((uint64_t)this, 401, "Missing TURN server credentials.", 0x20uLL);
    return;
  }
  if (!*((_QWORD *)this + 124))
    goto LABEL_17;
LABEL_7:
  if (*((_WORD *)this + 424))
  {
    v2 = *((unsigned __int16 *)this + 424);
    if (v2 <= 0x3FF && v2 != 53 && v2 != 80 && v2 != 443)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      cricket::TurnPort::OnAllocateError((uint64_t)this, 500, "Attempt to start allocation to a disallowed port", 0x30uLL);
      return;
    }
  }
  else
  {
    *((_WORD *)this + 424) = 3478;
  }
  if (*((_DWORD *)this + 206)
    || *((_BYTE *)this + 856)
    || (*((char *)this + 815) < 0 ? (v42 = *((_QWORD *)this + 100)) : (v42 = *((unsigned __int8 *)this + 815)), !v42))
  {
    rtc::Network::GetBestIP(*((_QWORD *)this + 69), (uint64_t)&v58);
    v17 = *((_DWORD *)this + 206);
    if (v17 == v59
      && (v17 != 30 || ((v60 & 0xC0FF) == 33022) == ((*(_QWORD *)((_BYTE *)this + 828) & 0xC0FFLL) == 33022)))
    {
      std::__tree<rtc::SocketAddress>::__emplace_unique_key_args<rtc::SocketAddress,rtc::SocketAddress const&>((uint64_t **)this + 126, (char *)this + 792, (uint64_t)this + 792);
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        (*(void (**)(void **__return_ptr, cricket::TurnPort *))(*(_QWORD *)this + 176))(&v58, this);
        rtc::SocketAddress::ToSensitiveNameAndAddressString((cricket::TurnPort *)((char *)this + 792), (unint64_t)__p);
        rtc::webrtc_logging_impl::Log("\r\n\t\t\t\n", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
        if (v57 < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v61) < 0)
          operator delete(v58);
      }
      cricket::TurnPort::CreateTurnClientSocket(this);
      if ((v33 & 1) != 0)
      {
        if (!*((_DWORD *)this + 216))
        {
          v34 = (cricket::TurnAllocateRequest *)operator new();
          cricket::TurnAllocateRequest::TurnAllocateRequest(v34, this);
          cricket::StunRequestManager::SendDelayed((cricket::TurnPort *)((char *)this + 1080), v34, 0);
        }
      }
      else
      {
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
          rtc::webrtc_logging_impl::Log("\r\t", v35, v36, v37, v38, v39, v40, v41, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
        cricket::TurnPort::OnAllocateError((uint64_t)this, 701, "Failed to create TURN client socket.", 0x24uLL);
      }
    }
    else
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      {
        v18 = (*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 24))(this);
        rtc::Network::GetBestIP(v18, (uint64_t)&v58);
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v19, v20, v21, v22, v23, v24, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      }
      cricket::TurnPort::OnAllocateError((uint64_t)this, 600, "IP address family does not match.", 0x21uLL);
    }
  }
  else if (!*((_QWORD *)this + 133))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      (*(void (**)(void **__return_ptr, cricket::TurnPort *))(*(_QWORD *)this + 176))(&v58, this);
      rtc::SocketAddress::ToSensitiveString((cricket::TurnPort *)((char *)this + 792), (char *)__p);
      rtc::webrtc_logging_impl::Log("\r\n\t\n", v43, v44, v45, v46, v47, v48, v49, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (v57 < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v61) < 0)
        operator delete(v58);
    }
    v50 = (*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 216))(this);
    (*(void (**)(void **__return_ptr))(*(_QWORD *)v50 + 40))(&v58);
    v51 = v58;
    v58 = 0;
    v52 = *((_QWORD *)this + 133);
    *((_QWORD *)this + 133) = v51;
    if (v52)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
      v53 = v58;
      v58 = 0;
      if (v53)
        (*(void (**)(void *))(*(_QWORD *)v53 + 8))(v53);
    }
    v54 = *((_QWORD *)this + 133);
    v55 = *(unsigned int *)((*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 24))(this) + 184);
    v58 = this;
    v61 = absl::internal_any_invocable::LocalManagerTrivial;
    v62 = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnPort::ResolveTurnAddress(rtc::SocketAddress const&)::$_0 &>;
    (*(void (**)(uint64_t, char *, uint64_t, void **))(*(_QWORD *)v54 + 24))(v54, (char *)this + 792, v55, &v58);
    v61(1, (__n128 *)&v58, (__n128 *)&v58);
  }
}

void cricket::TurnPort::OnAllocateError(uint64_t a1, int a2, char *a3, size_t a4)
{
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  BOOL v18;
  _BOOL4 v19;
  unsigned int v20;
  unsigned int v21;
  unsigned __int8 v22;
  size_t size;
  std::string *p_src;
  char *v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(uint64_t, uint64_t, void **);
  void *__p;
  _BYTE v31[24];
  void *v32;
  uint64_t v33;
  int v34;
  char v35;
  int v36;
  int v37;
  void *v38;
  char v39;
  std::string __src;
  char v41;
  __int128 v42;
  void (*v43)(uint64_t, __int128 *, __int128 *);
  uint64_t v44;
  _QWORD v45[2];
  void (*v46)(uint64_t, _QWORD *, _QWORD *);
  uint64_t v47;

  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 208))(a1);
  v9 = *(unsigned int **)(a1 + 1296);
  if (v9)
  {
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  *(_QWORD *)&v42 = a1;
  v43 = (void (*)(uint64_t, __int128 *, __int128 *))absl::internal_any_invocable::EmptyManager;
  v44 = 0;
  v11 = (char *)operator new();
  *(_QWORD *)v11 = v9;
  *(_OWORD *)(v11 + 8) = v42;
  *((_QWORD *)v11 + 3) = absl::internal_any_invocable::LocalManagerTrivial;
  *((_QWORD *)v11 + 4) = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnPort::OnAllocateError(int,std::string_view)::$_0 &&>;
  __p = v11;
  *(_QWORD *)&v31[8] = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
  *(_QWORD *)&v31[16] = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  v45[0] = v11;
  v46 = (void (*)(uint64_t, _QWORD *, _QWORD *))absl::internal_any_invocable::EmptyManager;
  v47 = 0;
  (*(void (**)(uint64_t, void **, std::string *, char *))(*(_QWORD *)v8 + 8))(v8, &__p, &__src, &v41);
  (*(void (**)(uint64_t, void **, void **))&v31[8])(1, &__p, &__p);
  v46(1, v45, v45);
  v43(1, &v42, &v42);
  v12 = *(_QWORD *)(a1 + 1032);
  if (v12)
  {
    (*(void (**)(void **__return_ptr))(*(_QWORD *)v12 + 16))(&__p);
    rtc::SocketAddress::HostAsSensitiveURIString((rtc::SocketAddress *)&__p, &__src);
    if ((v31[15] & 0x80000000) == 0)
      goto LABEL_5;
  }
  else
  {
    __p = 0;
    *(_OWORD *)v31 = 0uLL;
    *(_QWORD *)&v31[16] = &unk_24C0ACDA0;
    LOBYTE(v38) = 0;
    LOWORD(v36) = 0;
    v37 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    rtc::SocketAddress::HostAsSensitiveURIString((rtc::SocketAddress *)&__p, &__src);
    if ((v31[15] & 0x80000000) == 0)
    {
LABEL_5:
      v14 = *(_QWORD *)(a1 + 1032);
      if (v14)
        goto LABEL_6;
LABEL_12:
      v15 = 0;
      if (*(_DWORD *)(a1 + 864) != 1)
        goto LABEL_36;
      goto LABEL_13;
    }
  }
  operator delete(__p);
  v14 = *(_QWORD *)(a1 + 1032);
  if (!v14)
    goto LABEL_12;
LABEL_6:
  (*(void (**)(void **__return_ptr))(*(_QWORD *)v14 + 16))(&__p);
  v15 = (unsigned __int16)v36;
  if ((v31[15] & 0x80000000) != 0)
    operator delete(__p);
  if (*(_DWORD *)(a1 + 864) != 1)
    goto LABEL_36;
LABEL_13:
  v16 = *(_DWORD *)(a1 + 824);
  if (v16 != 2)
  {
    if (v16 == 30)
    {
      v17 = *(_QWORD *)(a1 + 828);
      if ((v17 & 0xC0FF) != 0x80FE)
      {
        *(_OWORD *)&v31[4] = *MEMORY[0x24BDAE880];
        v18 = *(_QWORD *)(a1 + 828) == *(_QWORD *)&v31[4] && *(_QWORD *)(a1 + 836) == *(_QWORD *)&v31[12];
        v19 = !v18;
        if (v17 != 253 && v19)
          goto LABEL_36;
      }
      goto LABEL_34;
    }
    v20 = *(_DWORD *)(a1 + 828);
    goto LABEL_32;
  }
  v20 = *(_DWORD *)(a1 + 828);
  if ((unsigned __int16)v20 != 65193 && *(_DWORD *)(a1 + 828) != 127)
  {
    v21 = bswap32(v20);
    if (HIWORD(v21) != 49320 && (v21 & 0xFF000000) != 0xA000000 && (v21 & 0xFFF00000) != 0xAC100000)
    {
LABEL_32:
      if (v16 != 2 || (v20 & 0xC0FF) != 0x4064)
        goto LABEL_36;
    }
  }
LABEL_34:
  if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
  {
    v15 = 0;
    *__src.__r_.__value_.__l.__data_ = 0;
    __src.__r_.__value_.__l.__size_ = 0;
    v22 = HIBYTE(__src.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(__src.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_37;
    goto LABEL_39;
  }
  v15 = 0;
  __src.__r_.__value_.__s.__data_[0] = 0;
  *((_BYTE *)&__src.__r_.__value_.__s + 23) = 0;
LABEL_36:
  v22 = HIBYTE(__src.__r_.__value_.__r.__words[2]);
  if ((SHIBYTE(__src.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_37:
    size = v22;
    p_src = &__src;
    goto LABEL_42;
  }
LABEL_39:
  size = __src.__r_.__value_.__l.__size_;
  if ((__src.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
    goto LABEL_58;
  p_src = (std::string *)__src.__r_.__value_.__r.__words[0];
  if (__src.__r_.__value_.__l.__size_)
  {
    if (!__src.__r_.__value_.__r.__words[0])
      goto LABEL_58;
  }
LABEL_42:
  v25 = (char *)(a1 + 872);
  if ((*(char *)(a1 + 895) & 0x80000000) == 0)
  {
    v26 = *(unsigned __int8 *)(a1 + 895);
    goto LABEL_47;
  }
  v26 = *(_QWORD *)(a1 + 880);
  if ((v26 & 0x8000000000000000) != 0 || (v25 = *(char **)v25, v26) && !v25)
  {
LABEL_58:
    __break(1u);
    return;
  }
LABEL_47:
  cricket::IceCandidateErrorEvent::IceCandidateErrorEvent(&__p, p_src, size, v15, v25, v26, a2, v13, a3, a4);
  v27 = *(_QWORD *)(a1 + 368);
  for (*(_QWORD *)(a1 + 384) = v27; v27 != a1 + 360; v27 = *(_QWORD *)(a1 + 384))
  {
    v29 = *(void (**)(uint64_t, uint64_t, void **))(v27 + 16);
    v28 = v27 + 16;
    *(_QWORD *)(a1 + 384) = *(_QWORD *)(v28 - 8);
    v29(v28, a1, &__p);
  }
  if (v39 < 0)
  {
    operator delete(v38);
    if ((v35 & 0x80000000) == 0)
    {
LABEL_51:
      if ((v31[15] & 0x80000000) == 0)
        goto LABEL_52;
      goto LABEL_56;
    }
  }
  else if ((v35 & 0x80000000) == 0)
  {
    goto LABEL_51;
  }
  operator delete(v32);
  if ((v31[15] & 0x80000000) == 0)
  {
LABEL_52:
    if ((SHIBYTE(__src.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
LABEL_57:
    operator delete(__src.__r_.__value_.__l.__data_);
    return;
  }
LABEL_56:
  operator delete(__p);
  if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_57;
}

void cricket::TurnPort::CreateTurnClientSocket(cricket::TurnPort *this)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  void **v6;
  void **v7;
  void *v8;
  void **v9;
  void **v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  cricket::TurnPort *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  cricket::TurnPort *v37;
  cricket::TurnPort *v38;
  BOOL v39;
  _QWORD *v40;
  uint64_t v41;
  std::string *v42;
  rtc::AsyncPacketSocket *v43;
  uint64_t v44;
  int v45;
  __int128 v46;
  int v47;
  void *v48[4];
  __int128 v49;
  uint64_t v50;
  void *__p;
  uint64_t (*v52)(uint64_t *, uint64_t, int);
  void (*v53)(uint64_t);
  void *v54;
  int v55;
  __int128 v56;
  __int16 v57;
  int v58;
  char v59;
  _QWORD v60[3];
  _QWORD *v61;
  uint64_t v62;

  v62 = *MEMORY[0x24BDAC8D0];
  v2 = *((_DWORD *)this + 216);
  if (v2)
  {
    if (v2 != 1)
    {
LABEL_3:
      if (v2 != 3)
        goto LABEL_34;
      if (*((_DWORD *)this + 224) == 1)
        v3 = 12;
      else
        v3 = 6;
LABEL_10:
      v50 = 0;
      v49 = 0u;
      memset(v48, 0, sizeof(v48));
      v47 = v3;
      if (v48 != (void **)((char *)this + 904))
        std::vector<std::string>::__assign_with_size[abi:sn180100]<std::string*,std::string*>((std::string **)v48, *((__int128 **)this + 113), *((__int128 **)this + 114), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 114) - *((_QWORD *)this + 113)) >> 3));
      if (&v48[3] != (void **)((char *)this + 928))
        std::vector<std::string>::__assign_with_size[abi:sn180100]<std::string*,std::string*>((std::string **)&v48[3], *((__int128 **)this + 116), *((__int128 **)this + 117), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 117) - *((_QWORD *)this + 116)) >> 3));
      v50 = *((_QWORD *)this + 119);
      v4 = (*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 216))(this);
      v5 = (*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 24))(this);
      rtc::Network::GetBestIP(v5, (uint64_t)&v44);
      __p = 0;
      v52 = 0;
      v53 = 0;
      v54 = &unk_24C0ACDA0;
      v59 = 0;
      v55 = v45;
      v56 = v46;
      v58 = 0;
      v57 = 0;
      *((_QWORD *)this + 129) = (*(uint64_t (**)(uint64_t, void **, char *, int *))(*(_QWORD *)v4 + 32))(v4, &__p, (char *)this + 792, &v47);
      if (SHIBYTE(v53) < 0)
        operator delete(__p);
      v6 = (void **)v48[3];
      if (v48[3])
      {
        v7 = (void **)v49;
        v8 = v48[3];
        if ((void *)v49 != v48[3])
        {
          do
          {
            if (*((char *)v7 - 1) < 0)
              operator delete(*(v7 - 3));
            v7 -= 3;
          }
          while (v7 != v6);
          v8 = v48[3];
        }
        *(_QWORD *)&v49 = v6;
        operator delete(v8);
      }
      v9 = (void **)v48[0];
      if (v48[0])
      {
        v10 = (void **)v48[1];
        v11 = v48[0];
        if (v48[1] != v48[0])
        {
          do
          {
            if (*((char *)v10 - 1) < 0)
              operator delete(*(v10 - 3));
            v10 -= 3;
          }
          while (v10 != v9);
          v11 = v48[0];
        }
        v48[1] = v9;
        goto LABEL_32;
      }
      goto LABEL_34;
    }
LABEL_9:
    v3 = 4;
    goto LABEL_10;
  }
  if (((*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 64))(this) & 1) != 0)
  {
    v2 = *((_DWORD *)this + 216);
    if (v2 != 1)
      goto LABEL_3;
    goto LABEL_9;
  }
  v12 = (*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 216))(this);
  v13 = (*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 24))(this);
  rtc::Network::GetBestIP(v13, (uint64_t)&v47);
  __p = 0;
  v52 = 0;
  v53 = 0;
  v54 = &unk_24C0ACDA0;
  v59 = 0;
  v55 = (int)v48[0];
  v56 = *(_OWORD *)((char *)v48 + 4);
  v58 = 0;
  v57 = 0;
  *((_QWORD *)this + 129) = (*(uint64_t (**)(uint64_t, void **, _QWORD, _QWORD))(*(_QWORD *)v12 + 16))(v12, &__p, *((unsigned __int16 *)this + 280), *((unsigned __int16 *)this + 281));
  if (SHIBYTE(v53) < 0)
  {
    v11 = __p;
LABEL_32:
    operator delete(v11);
  }
LABEL_34:
  if (!*((_QWORD *)this + 129))
  {
    *((_DWORD *)this + 268) = -1;
    return;
  }
  v14 = (cricket::TurnPort *)*((_QWORD *)this + 130);
  if (v14 != (cricket::TurnPort *)((char *)this + 1048))
  {
    do
    {
      (*(void (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 129) + 72))(*((_QWORD *)this + 129), *((unsigned int *)v14 + 7), *((unsigned int *)v14 + 8));
      v37 = (cricket::TurnPort *)*((_QWORD *)v14 + 1);
      if (v37)
      {
        do
        {
          v38 = v37;
          v37 = *(cricket::TurnPort **)v37;
        }
        while (v37);
      }
      else
      {
        do
        {
          v38 = (cricket::TurnPort *)*((_QWORD *)v14 + 2);
          v39 = *(_QWORD *)v38 == (_QWORD)v14;
          v14 = v38;
        }
        while (!v39);
      }
      v14 = v38;
    }
    while (v38 != (cricket::TurnPort *)((char *)this + 1048));
  }
  if (((*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 64))(this) & 1) == 0)
  {
    v19 = *((_QWORD *)this + 129);
    if (*(_QWORD *)(v19 + 336))
    {
      v42 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/async_packet_socket.cc", 47, "!received_packet_callback_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v15, v16, v17, v18, v44);
      cricket::TurnPort::OnSocketConnect((cricket::TurnPort *)v42, v43);
      return;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v19 + 328))(1, v19 + 312, v19 + 312);
    *(_QWORD *)(v19 + 312) = this;
    *(_QWORD *)(v19 + 328) = absl::internal_any_invocable::LocalManagerTrivial;
    *(_QWORD *)(v19 + 336) = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnPort::CreateTurnClientSocket(void)::$_0 &,rtc::AsyncPacketSocket *,rtc::ReceivedPacket const&>;
  }
  v20 = (_QWORD *)*((_QWORD *)this + 129);
  v21 = operator new(0x30uLL);
  v21[2] = sigslot::_opaque_connection::emitter<cricket::TurnPort,rtc::AsyncPacketSocket *>;
  v21[3] = (char *)this + 232;
  *((_OWORD *)v21 + 2) = xmmword_208F170A0;
  v22 = v20[16];
  v20 += 16;
  *v21 = v22;
  v21[1] = v20;
  *(_QWORD *)(v22 + 8) = v21;
  *v20 = v21;
  ++v20[2];
  (*((void (**)(char *, _QWORD *))this + 30))((char *)this + 232, v20 - 2);
  v23 = (_QWORD *)*((_QWORD *)this + 129);
  v24 = operator new(0x30uLL);
  v24[2] = sigslot::_opaque_connection::emitter<cricket::TurnPort,rtc::AsyncPacketSocket *,rtc::SentPacket const&>;
  v24[3] = (char *)this + 232;
  *((_OWORD *)v24 + 2) = xmmword_208F17020;
  v25 = v23[9];
  v23 += 9;
  *v24 = v25;
  v24[1] = v23;
  *(_QWORD *)(v25 + 8) = v24;
  *v23 = v24;
  ++v23[2];
  (*((void (**)(char *, _QWORD *))this + 30))((char *)this + 232, v23 - 2);
  if ((*((_DWORD *)this + 216) | 2) != 3)
  {
    *((_DWORD *)this + 312) = 1;
    return;
  }
  v26 = (_QWORD *)*((_QWORD *)this + 129);
  v27 = operator new(0x30uLL);
  v27[2] = sigslot::_opaque_connection::emitter<cricket::TurnPort,rtc::AsyncPacketSocket *>;
  v27[3] = (char *)this + 232;
  v27[4] = cricket::TurnPort::OnSocketConnect;
  v27[5] = 0;
  v28 = v26[30];
  v26 += 30;
  *v27 = v28;
  v27[1] = v26;
  *(_QWORD *)(v28 + 8) = v27;
  *v26 = v27;
  ++v26[2];
  (*((void (**)(char *, _QWORD *))this + 30))((char *)this + 232, v26 - 2);
  v29 = *((_QWORD *)this + 129);
  v60[0] = &off_24C0C2D30;
  v60[1] = this;
  v61 = v60;
  v30 = operator new();
  v36 = (void *)v30;
  if (v61)
  {
    if (v61 == v60)
    {
      *(_QWORD *)(v30 + 24) = v30;
      (*(void (**)(_QWORD *, uint64_t))(v60[0] + 24))(v60, v30);
    }
    else
    {
      *(_QWORD *)(v30 + 24) = v61;
      v61 = 0;
    }
  }
  else
  {
    *(_QWORD *)(v30 + 24) = 0;
  }
  __p = v36;
  v52 = webrtc::webrtc_function_impl::CallHelpers<void ()(rtc::AsyncPacketSocket *,int)>::CallVoidPtr<std::function<void ()(rtc::AsyncPacketSocket *,int)>>;
  v53 = webrtc::UntypedFunction::PrepareArgs<void ()(rtc::AsyncPacketSocket *,int),std::function<void ()(rtc::AsyncPacketSocket *,int)>,std::function<void ()(rtc::AsyncPacketSocket *,int)>,(void *)0>(std::function<void ()(rtc::AsyncPacketSocket *,int)> &&)::{lambda(webrtc::webrtc_function_impl::VoidUnion *)#1}::__invoke;
  webrtc::callback_list_impl::CallbackListReceivers::AddReceiver<webrtc::UntypedFunction::NontrivialUntypedFunctionArgs>((char *)(v29 + 280), (uint64_t)this, (uint64_t *)&__p, v31, v32, v33, v34, v35);
  v40 = v61;
  if (v61 == v60)
  {
    v41 = 4;
    v40 = v60;
  }
  else
  {
    if (!v61)
      return;
    v41 = 5;
  }
  (*(void (**)(void))(*v40 + 8 * v41))();
}

void cricket::TurnPort::OnSocketConnect(cricket::TurnPort *this, rtc::AsyncPacketSocket *a2)
{
  uint64_t v4;
  int v5;
  __int16 v6;
  char v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BOOL4 v12;
  BOOL v13;
  int v14;
  uint64_t v15;
  uint64_t v17;
  _BOOL4 IsLoopbackIP;
  _BOOL4 v19;
  rtc::Network *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BOOL4 v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  cricket::TurnAllocateRequest *v40;
  const void **v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  rtc::Network *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  rtc::Network *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const std::string::value_type *v64;
  size_t v65;
  _BYTE v66[8];
  int v67;
  uint64_t v68;
  uint64_t v69;
  _BYTE __p[56];
  __int16 v71;
  int v72;
  char v73;
  void *v74[2];
  uint64_t v75;
  int v76;
  __int128 v77;
  __int16 v78;
  int v79;
  char v80;
  _QWORD __dst[7];
  __int16 v82;
  int v83;
  char v84;

  (*(void (**)(void **__return_ptr, rtc::AsyncPacketSocket *))(*(_QWORD *)a2 + 16))(v74, a2);
  v4 = (*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 24))(this);
  memset(__p, 0, 24);
  *(_QWORD *)&__p[24] = &unk_24C0ACDA0;
  memset(&__p[32], 0, 20);
  if (SHIBYTE(v75) < 0)
  {
    std::string::__assign_no_alias<true>(__p, (char *)v74[0], (size_t)v74[1]);
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)v74;
    *(_QWORD *)&__p[16] = v75;
  }
  v5 = v76;
  *(_DWORD *)&__p[32] = v76;
  *(_OWORD *)&__p[36] = v77;
  v6 = v78;
  v71 = v78;
  v7 = v80;
  v73 = v80;
  v8 = v79;
  v72 = v79;
  v10 = *(_QWORD *)(v4 + 240);
  v9 = *(_QWORD *)(v4 + 248);
  memset(__dst, 0, 24);
  __dst[3] = &unk_24C0ACDA0;
  memset(&__dst[4], 0, 20);
  if ((__p[23] & 0x80000000) != 0)
  {
    std::string::__assign_no_alias<true>(__dst, *(char **)__p, *(size_t *)&__p[8]);
    v5 = *(_DWORD *)&__p[32];
    v6 = v71;
    v7 = v73;
    v8 = v72;
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)__p;
    __dst[2] = *(_QWORD *)&__p[16];
  }
  LODWORD(__dst[4]) = v5;
  *(_OWORD *)((char *)&__dst[4] + 4) = *(_OWORD *)&__p[36];
  v82 = v6;
  v84 = v7;
  v83 = v8;
  if (v10 == v9)
  {
    v14 = 1;
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
      goto LABEL_43;
    goto LABEL_42;
  }
  switch(v5)
  {
    case 30:
      v15 = v10 + 32;
      while (1)
      {
        if (*(_DWORD *)(v15 - 24) == 30)
        {
          v12 = *(_QWORD *)((char *)&__dst[4] + 4) == *(_QWORD *)(v15 - 20)
             && *(_QWORD *)((char *)&__dst[5] + 4) == *(_QWORD *)(v15 - 12);
          if (v12)
            goto LABEL_41;
        }
        else
        {
          v12 = 0;
        }
        v13 = v15 == v9;
        v15 += 32;
        if (v13)
          goto LABEL_41;
      }
    case 2:
      v17 = v10 + 32;
      do
      {
        if (*(_DWORD *)(v17 - 24) == 2)
        {
          v12 = HIDWORD(__dst[4]) == *(_DWORD *)(v17 - 20);
          if (HIDWORD(__dst[4]) == *(_DWORD *)(v17 - 20))
            break;
        }
        else
        {
          v12 = 0;
        }
        v13 = v17 == v9;
        v17 += 32;
      }
      while (!v13);
LABEL_41:
      v14 = !v12;
      if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
        goto LABEL_43;
      goto LABEL_42;
    case 0:
      v11 = v10 + 32;
      do
      {
        v12 = *(_DWORD *)(v11 - 24) == 0;
        if (*(_DWORD *)(v11 - 24))
          v13 = v11 == v9;
        else
          v13 = 1;
        v11 += 32;
      }
      while (!v13);
      goto LABEL_41;
  }
  v14 = 1;
  if (SHIBYTE(__dst[2]) < 0)
LABEL_42:
    operator delete((void *)__dst[0]);
LABEL_43:
  if ((__p[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__p);
    if (!v14)
      goto LABEL_69;
  }
  else if (!v14)
  {
    goto LABEL_69;
  }
  (*(void (**)(_QWORD *__return_ptr, rtc::AsyncPacketSocket *))(*(_QWORD *)a2 + 16))(__dst, a2);
  IsLoopbackIP = rtc::SocketAddress::IsLoopbackIP((rtc::SocketAddress *)__dst);
  v19 = IsLoopbackIP;
  if (SHIBYTE(__dst[2]) < 0)
  {
    operator delete((void *)__dst[0]);
    if (v19)
    {
LABEL_49:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        goto LABEL_69;
      rtc::SocketAddress::ToSensitiveNameAndAddressString((rtc::SocketAddress *)v74, (unint64_t)__dst);
      v20 = (rtc::Network *)(*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 24))(this);
      rtc::Network::ToString(v20, (std::string *)__p);
      rtc::webrtc_logging_impl::Log("\r\t\n\t\n\t", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if ((__p[23] & 0x80000000) == 0)
        goto LABEL_52;
      goto LABEL_51;
    }
  }
  else if (IsLoopbackIP)
  {
    goto LABEL_49;
  }
  v28 = (*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 24))(this);
  rtc::Network::GetBestIP(v28, (uint64_t)v66);
  if (v67 == 2)
  {
    v47 = v68;
    v32 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>();
    if (!v47)
      goto LABEL_68;
    goto LABEL_95;
  }
  if (v67 == 30)
  {
    *(_OWORD *)((char *)&__dst[1] + 4) = *MEMORY[0x24BDAE878];
    if (v68 == *(_QWORD *)((char *)&__dst[1] + 4) && v69 == *(_QWORD *)((char *)&__dst[2] + 4))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        goto LABEL_69;
      goto LABEL_110;
    }
    *(_OWORD *)&__p[12] = rtc::kV4MappedPrefix;
    v31 = v68 != (_QWORD)rtc::kV4MappedPrefix || v69 != *((_QWORD *)&rtc::kV4MappedPrefix + 1);
    v32 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>();
    if (!v31)
    {
LABEL_68:
      if ((v32 & 1) != 0)
        goto LABEL_69;
LABEL_110:
      rtc::SocketAddress::ToSensitiveNameAndAddressString((rtc::SocketAddress *)v74, (unint64_t)__dst);
      v56 = (rtc::Network *)(*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 24))(this);
      rtc::Network::ToString(v56, (std::string *)__p);
      rtc::webrtc_logging_impl::Log("\r\t\n\t\n\t", v57, v58, v59, v60, v61, v62, v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if ((__p[23] & 0x80000000) == 0)
      {
LABEL_52:
        if (SHIBYTE(__dst[2]) < 0)
          operator delete((void *)__dst[0]);
LABEL_69:
        *((_DWORD *)this + 312) = 1;
        if (!*((_DWORD *)this + 206) && !*((_BYTE *)this + 856))
        {
          if (*((char *)this + 815) < 0)
          {
            if (!*((_QWORD *)this + 100))
              goto LABEL_71;
          }
          else if (!*((_BYTE *)this + 815))
          {
            goto LABEL_71;
          }
          (*(void (**)(_QWORD *__return_ptr))(**((_QWORD **)this + 129) + 24))(__dst);
          if ((_QWORD *)((char *)this + 792) != __dst)
          {
            if (*((char *)this + 815) < 0)
            {
              if (__dst[2] >= 0)
                v64 = (const std::string::value_type *)__dst;
              else
                v64 = (const std::string::value_type *)__dst[0];
              if (__dst[2] >= 0)
                v65 = HIBYTE(__dst[2]);
              else
                v65 = __dst[1];
              std::string::__assign_no_alias<false>((std::string *)this + 33, v64, v65);
            }
            else if ((__dst[2] & 0x8000000000000000) != 0)
            {
              std::string::__assign_no_alias<true>((_QWORD *)this + 99, (char *)__dst[0], __dst[1]);
            }
            else
            {
              *(_OWORD *)((char *)this + 792) = *(_OWORD *)__dst;
              *((_QWORD *)this + 101) = __dst[2];
            }
          }
          *((_DWORD *)this + 206) = __dst[4];
          *(_OWORD *)((char *)this + 828) = *(_OWORD *)((char *)&__dst[4] + 4);
          *((_WORD *)this + 424) = v82;
          *((_BYTE *)this + 856) = v84;
          *((_DWORD *)this + 213) = v83;
          if (SHIBYTE(__dst[2]) < 0)
            operator delete((void *)__dst[0]);
        }
LABEL_71:
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
          goto LABEL_74;
        (*(void (**)(_QWORD *__return_ptr, rtc::AsyncPacketSocket *))(*(_QWORD *)a2 + 24))(__dst, a2);
        rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)__dst, __p);
        rtc::webrtc_logging_impl::Log("\r\t\n\t", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
        if ((__p[23] & 0x80000000) != 0)
        {
          operator delete(*(void **)__p);
          if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
            goto LABEL_74;
        }
        else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
        {
          goto LABEL_74;
        }
        operator delete((void *)__dst[0]);
LABEL_74:
        v40 = (cricket::TurnAllocateRequest *)operator new();
        cricket::TurnAllocateRequest::TurnAllocateRequest(v40, this);
        v41 = (const void **)(*((_QWORD *)v40 + 2) + 40);
        __dst[0] = v40;
        std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>((uint64_t)this + 1088, v41, (uint64_t)v41, __dst);
        v42 = __dst[0];
        __dst[0] = 0;
        if (v42)
          (*(void (**)(uint64_t))(*(_QWORD *)v42 + 8))(v42);
        v43 = *((_QWORD *)v40 + 5);
        if (v43)
        {
          do
            v44 = __ldxr((unsigned int *)v43);
          while (__stxr(v44 + 1, (unsigned int *)v43));
          *(_BYTE *)(v43 + 4) = 1;
          do
          {
            v45 = __ldaxr((unsigned int *)v43);
            v46 = v45 - 1;
          }
          while (__stlxr(v46, (unsigned int *)v43));
          if (!v46)
          {
            MEMORY[0x20BD0ADEC]();
            cricket::StunRequest::SendInternal(v40);
            if ((SHIBYTE(v75) & 0x80000000) == 0)
              return;
            goto LABEL_85;
          }
        }
        else
        {
          MEMORY[4] = 1;
        }
        cricket::StunRequest::SendInternal(v40);
        if ((SHIBYTE(v75) & 0x80000000) == 0)
          return;
        goto LABEL_85;
      }
LABEL_51:
      operator delete(*(void **)__p);
      goto LABEL_52;
    }
LABEL_95:
    if ((v32 & 1) != 0)
      goto LABEL_102;
    goto LABEL_98;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
    goto LABEL_102;
LABEL_98:
  rtc::SocketAddress::ToSensitiveNameAndAddressString((rtc::SocketAddress *)v74, (unint64_t)__dst);
  v48 = (rtc::Network *)(*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 24))(this);
  rtc::Network::ToString(v48, (std::string *)__p);
  rtc::webrtc_logging_impl::Log("\r\t\n\t\n\t", v49, v50, v51, v52, v53, v54, v55, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if ((__p[23] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  if (SHIBYTE(__dst[2]) < 0)
    operator delete((void *)__dst[0]);
LABEL_102:
  cricket::TurnPort::OnAllocateError((uint64_t)this, 600, "Address not associated with the desired network interface.", 0x3AuLL);
  if (SHIBYTE(v75) < 0)
LABEL_85:
    operator delete(v74[0]);
}

cricket::Connection *cricket::TurnPort::CreateConnection(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  cricket::Connection *v4;
  unint64_t v5;
  cricket::TurnCreatePermissionRequest *v6;
  uint64_t v7;
  cricket::TurnCreatePermissionRequest **v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v15;
  int v16;
  int v17;
  BOOL v18;
  _QWORD *v19;
  _QWORD *v20;
  char *v21;
  uint64_t v22;
  unsigned int v23;
  _QWORD *v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int *v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  cricket::TurnCreatePermissionRequest **v42;
  uint64_t v43;
  cricket::TurnCreatePermissionRequest *v44;
  unsigned int v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  cricket::Connection **v50;
  uint64_t v51;
  unsigned int v52;
  const void **v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  char *v64;
  unint64_t *v65;
  unint64_t v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  __int128 *v72;
  uint64_t v73;
  __int128 v74;
  __int128 v75;
  unint64_t v76;
  _QWORD *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _OWORD *v86;
  __int128 *v87;
  uint64_t v88;
  __int128 v89;
  uint64_t v90;
  uint64_t v91[2];

  v9 = a2;
  v10 = a1;
  v11 = (_QWORD *)(a2 + 32);
  v12 = *(char *)(v9 + 55);
  if ((v12 & 0x80000000) != 0)
  {
    v13 = *(_QWORD *)(v9 + 40);
    if (v13 < 0)
      goto LABEL_126;
    v11 = (_QWORD *)*v11;
    if (v13 && v11 == 0)
      goto LABEL_126;
  }
  else
  {
    v13 = *(unsigned __int8 *)(v9 + 55);
  }
  a1 = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v11, v13);
  if ((_DWORD)a1 && (*(_DWORD *)(v10 + 1248) - 3) >= 2)
  {
    v12 = v9 + 80;
    if (*(char *)(v9 + 103) < 0)
    {
      v2 = *(_QWORD *)(v9 + 88);
      if ((v2 & 0x8000000000000000) != 0)
        goto LABEL_126;
      v12 = *(_QWORD *)v12;
      if (v2)
      {
        if (!v12)
          goto LABEL_126;
      }
    }
    else
    {
      v2 = *(unsigned __int8 *)(v9 + 103);
    }
    if (v2 < 6
      || ((v15 = v2 + v12, v16 = *(_DWORD *)(v15 - 6), v17 = *(unsigned __int16 *)(v15 - 2), v16 == *(_DWORD *)".local")
        ? (v18 = v17 == *(unsigned __int16 *)"al")
        : (v18 = 0),
          !v18))
    {
      v19 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
      if (v19[1] != *v19)
      {
        v4 = 0;
        v5 = 0;
        v6 = (cricket::TurnCreatePermissionRequest *)0x84BDA12F684BDA13;
        while (1)
        {
          a1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
          v12 = *(_QWORD *)a1;
          v2 = 0x84BDA12F684BDA13 * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4);
          if (v2 <= v5)
            goto LABEL_126;
          v21 = (char *)v4 + v12;
          if (*((_DWORD *)v21 + 52) == 3 && *((_DWORD *)v21 + 28) == *(_DWORD *)(v9 + 112))
            break;
          ++v5;
          v20 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
          v4 = (cricket::Connection *)((char *)v4 + 432);
          if (v5 >= 0x84BDA12F684BDA13 * ((uint64_t)(v20[1] - *v20) >> 4))
            return 0;
        }
        v4 = (cricket::Connection *)operator new();
        v22 = *(_QWORD *)(v10 + 776);
        if (v22 && (v23 = atomic_load((unsigned int *)(v22 + 4)), v23 != 1))
        {
          v24 = *(_QWORD **)(v10 + 776);
          if (!v24)
          {
            v34 = *(_QWORD *)(v10 + 784);
LABEL_47:
            v91[0] = (uint64_t)v24;
            v91[1] = v34;
            cricket::Connection::Connection((uint64_t)v4, v91, v5, (std::string *)v9);
            if (v91[0])
            {
              v38 = (unsigned int *)(v91[0] + 4);
              do
              {
                v39 = __ldaxr(v38);
                v40 = v39 - 1;
              }
              while (__stlxr(v40, v38));
              if (!v40)
                MEMORY[0x20BD0ADEC]();
            }
            *(_QWORD *)v4 = &unk_24C0B15F8;
            *((_DWORD *)v4 + 706) = 0;
            v7 = *(unsigned int *)(v10 + 1216);
            v41 = cricket::Connection::remote_candidate(v4);
            v42 = *(cricket::TurnCreatePermissionRequest ***)(v10 + 1224);
            v8 = *(cricket::TurnCreatePermissionRequest ***)(v10 + 1232);
            if (v42 != v8)
            {
              v43 = v41;
              v5 = v41 + 80;
              while (1)
              {
                v44 = *v42;
                a1 = rtc::SocketAddress::EqualIPs((cricket::TurnCreatePermissionRequest *)((char *)*v42 + 104), (const rtc::SocketAddress *)v5);
                if ((_DWORD)a1)
                {
                  v2 = *(unsigned __int16 *)(v43 + 136);
                  if (*((unsigned __int16 *)v44 + 80) == (_DWORD)v2)
                    break;
                }
                if (++v42 == v8)
                {
                  v42 = v8;
                  break;
                }
              }
              if (v42 != *(cricket::TurnCreatePermissionRequest ***)(v10 + 1232))
              {
                v6 = *v42;
                if (v6)
                {
                  v9 = *((_QWORD *)v6 + 24);
                  if (*((_QWORD *)v6 + 23) == v9)
                  {
                    a1 = operator new();
                    *(_DWORD *)a1 = 0;
                    *(_BYTE *)(a1 + 4) = 1;
                    do
                      v45 = __ldxr((unsigned int *)a1);
                    while (__stxr(v45 + 1, (unsigned int *)a1));
                    v46 = *((_QWORD *)v6 + 26);
                    *(_BYTE *)(v46 + 4) = 0;
                    *((_QWORD *)v6 + 26) = a1;
                    do
                    {
                      v47 = __ldaxr((unsigned int *)v46);
                      v2 = v47 - 1;
                      v3 = __stlxr(v2, (unsigned int *)v46);
                    }
                    while ((_DWORD)v3);
                    if (!(_DWORD)v2)
                      a1 = MEMORY[0x20BD0ADEC](v46, 0x1000C4090D0E795);
                    v9 = *((_QWORD *)v6 + 24);
                  }
                  v12 = *((_QWORD *)v6 + 25);
                  if (v9 < v12)
                  {
                    if (v9)
                    {
                      *(_QWORD *)v9 = v4;
                      v5 = v9 + 8;
LABEL_136:
                      *((_QWORD *)v6 + 24) = v5;
                      goto LABEL_137;
                    }
                    goto LABEL_126;
                  }
                  v7 = *((_QWORD *)v6 + 23);
                  v8 = (cricket::TurnCreatePermissionRequest **)(v9 - v7);
                  v80 = (uint64_t)(v9 - v7) >> 3;
                  v2 = v80 + 1;
                  if (!((unint64_t)(v80 + 1) >> 61))
                  {
                    v81 = v12 - v7;
                    if (v81 >> 2 > v2)
                      v2 = v81 >> 2;
                    v3 = 0x7FFFFFFFFFFFFFF8;
                    v67 = (unint64_t)v81 >= 0x7FFFFFFFFFFFFFF8;
                    v12 = 0x1FFFFFFFFFFFFFFFLL;
                    if (!v67)
                      v12 = v2;
                    if (v12)
                    {
                      if (!(v12 >> 61))
                      {
                        v82 = 8 * v12;
                        a1 = (uint64_t)operator new(8 * v12);
                        v12 = a1 + v82;
                        v2 = a1 + 8 * v80;
                        *(_QWORD *)v2 = v4;
                        v5 = v2 + 8;
                        if (v9 == v7)
                          goto LABEL_134;
                        v3 = v9 - v7 - 8;
                        if (v3 < 0x58)
                        {
                          v83 = v9;
                          goto LABEL_132;
                        }
LABEL_127:
                        if (v9 - (unint64_t)v8 - a1 >= 0x20)
                        {
                          v84 = (v3 >> 3) + 1;
                          v85 = 8 * (v84 & 0x3FFFFFFFFFFFFFFCLL);
                          v83 = v9 - v85;
                          v2 -= v85;
                          v86 = (_OWORD *)((char *)v8 + a1 - 16);
                          v87 = (__int128 *)(v9 - 16);
                          v88 = v84 & 0x3FFFFFFFFFFFFFFCLL;
                          do
                          {
                            v89 = *v87;
                            *(v86 - 1) = *(v87 - 1);
                            *v86 = v89;
                            v86 -= 2;
                            v87 -= 2;
                            v88 -= 4;
                          }
                          while (v88);
                          if (v84 == (v84 & 0x3FFFFFFFFFFFFFFCLL))
                            goto LABEL_133;
                        }
                        else
                        {
                          v83 = v9;
                        }
                        do
                        {
LABEL_132:
                          v90 = *(_QWORD *)(v83 - 8);
                          v83 -= 8;
                          *(_QWORD *)(v2 - 8) = v90;
                          v2 -= 8;
                        }
                        while (v83 != v7);
LABEL_133:
                        v9 = v7;
LABEL_134:
                        *((_QWORD *)v6 + 23) = v2;
                        *((_QWORD *)v6 + 24) = v5;
                        *((_QWORD *)v6 + 25) = v12;
                        if (v9)
                          operator delete((void *)v9);
                        goto LABEL_136;
                      }
LABEL_139:
                      std::__throw_bad_array_new_length[abi:sn180100]();
                    }
LABEL_126:
                    __break(1u);
                    goto LABEL_127;
                  }
LABEL_138:
                  abort();
                }
              }
            }
            v9 = operator new();
            *(_QWORD *)(v9 + 16) = sigslot::has_slots<sigslot::single_threaded>::do_signal_disconnect;
            *(_QWORD *)(v9 + 24) = sigslot::has_slots<sigslot::single_threaded>::do_disconnect_all;
            *(_QWORD *)(v9 + 48) = 0;
            *(_QWORD *)(v9 + 56) = 0;
            *(_QWORD *)(v9 + 40) = 0;
            *(_QWORD *)(v9 + 32) = v9 + 40;
            *(_QWORD *)v9 = &off_24C0C2C80;
            *(_QWORD *)(v9 + 8) = sigslot::has_slots<sigslot::single_threaded>::do_signal_connect;
            *(_QWORD *)(v9 + 64) = 0;
            *(_QWORD *)(v9 + 72) = 0;
            *(_BYTE *)(v9 + 80) = 0;
            *(_QWORD *)(v9 + 88) = v10;
            *(_DWORD *)(v9 + 96) = v7;
            v48 = (*(uint64_t (**)(cricket::Connection *))(*(_QWORD *)v4 + 24))(v4);
            v49 = v48;
            *(_QWORD *)(v9 + 104) = 0;
            *(_QWORD *)(v9 + 112) = 0;
            *(_QWORD *)(v9 + 120) = 0;
            *(_QWORD *)(v9 + 136) = 0;
            *(_QWORD *)(v9 + 144) = 0;
            *(_QWORD *)(v9 + 128) = &unk_24C0ACDA0;
            *(_DWORD *)(v9 + 152) = 0;
            if (v9 + 104 != v48 + 80)
            {
              if (*(char *)(v48 + 103) < 0)
              {
                std::string::__assign_no_alias<true>((_QWORD *)(v9 + 104), *(char **)(v48 + 80), *(_QWORD *)(v48 + 88));
              }
              else
              {
                *(_OWORD *)(v9 + 104) = *(_OWORD *)(v48 + 80);
                *(_QWORD *)(v9 + 120) = *(_QWORD *)(v48 + 96);
              }
            }
            *(_DWORD *)(v9 + 136) = *(_DWORD *)(v49 + 112);
            *(_OWORD *)(v9 + 140) = *(_OWORD *)(v49 + 116);
            *(_WORD *)(v9 + 160) = *(_WORD *)(v49 + 136);
            *(_BYTE *)(v9 + 168) = *(_BYTE *)(v49 + 144);
            *(_DWORD *)(v9 + 164) = *(_DWORD *)(v49 + 140);
            *(_DWORD *)(v9 + 176) = 0;
            v50 = (cricket::Connection **)operator new(8uLL);
            *(_QWORD *)(v9 + 184) = v50;
            *v50++ = v4;
            *(_QWORD *)(v9 + 192) = v50;
            *(_QWORD *)(v9 + 200) = v50;
            v51 = operator new();
            *(_DWORD *)v51 = 0;
            *(_BYTE *)(v51 + 4) = 1;
            *(_QWORD *)(v9 + 208) = v51;
            do
              v52 = __ldxr((unsigned int *)v51);
            while (__stxr(v52 + 1, (unsigned int *)v51));
            v7 = *(_QWORD *)(v9 + 88);
            v6 = (cricket::TurnCreatePermissionRequest *)operator new();
            cricket::TurnCreatePermissionRequest::TurnCreatePermissionRequest(v6, *(cricket::TurnPort **)(v9 + 88), (cricket::TurnEntry *)v9, (const rtc::SocketAddress *)(v9 + 104));
            v53 = (const void **)(*((_QWORD *)v6 + 2) + 40);
            v91[0] = (uint64_t)v6;
            std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>(v7 + 1088, v53, (uint64_t)v53, v91);
            v54 = v91[0];
            v91[0] = 0;
            if (v54)
              (*(void (**)(uint64_t))(*(_QWORD *)v54 + 8))(v54);
            v55 = *((_QWORD *)v6 + 5);
            if (v55)
            {
              do
                v56 = __ldxr((unsigned int *)v55);
              while (__stxr(v56 + 1, (unsigned int *)v55));
              *(_BYTE *)(v55 + 4) = 1;
              do
              {
                v57 = __ldaxr((unsigned int *)v55);
                v58 = v57 - 1;
              }
              while (__stlxr(v58, (unsigned int *)v55));
              if (!v58)
                MEMORY[0x20BD0ADEC](v55);
            }
            else
            {
              MEMORY[4] = 1;
            }
            cricket::StunRequest::SendInternal(v6);
            v5 = *(_QWORD *)(v10 + 1232);
            v12 = *(_QWORD *)(v10 + 1240);
            if (v5 >= v12)
            {
              v7 = *(_QWORD *)(v10 + 1224);
              v8 = (cricket::TurnCreatePermissionRequest **)(v5 - v7);
              v60 = (uint64_t)(v5 - v7) >> 3;
              v2 = v60 + 1;
              if ((unint64_t)(v60 + 1) >> 61)
                goto LABEL_138;
              v61 = v12 - v7;
              if (v61 >> 2 > v2)
                v2 = v61 >> 2;
              v3 = 0x7FFFFFFFFFFFFFF8;
              v67 = (unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8;
              v12 = 0x1FFFFFFFFFFFFFFFLL;
              if (!v67)
                v12 = v2;
              if (!v12)
                goto LABEL_126;
              if (v12 >> 61)
                goto LABEL_139;
              v62 = 8 * v12;
              v63 = (char *)operator new(8 * v12);
              v64 = &v63[v62];
              v65 = (unint64_t *)&v63[8 * v60];
              *v65 = v9;
              v59 = v65 + 1;
              if (v5 == v7)
              {
                *(_QWORD *)(v10 + 1224) = v65;
                *(_QWORD *)(v10 + 1232) = v59;
                *(_QWORD *)(v10 + 1240) = v64;
              }
              else
              {
                v66 = v5 - v7 - 8;
                if (v66 < 0x78)
                  goto LABEL_142;
                v67 = v5 - (v66 & 0xFFFFFFFFFFFFFFF8) - 8 >= (unint64_t)v65
                   || &v63[(_QWORD)v8 - (v66 & 0xFFFFFFFFFFFFFFF8) - 8] >= (char *)v5;
                if (!v67)
                  goto LABEL_142;
                v68 = (v66 >> 3) + 1;
                v69 = 8 * (v68 & 0x3FFFFFFFFFFFFFFCLL);
                v70 = v5 - v69;
                v65 = (unint64_t *)((char *)v65 - v69);
                v71 = &v63[(_QWORD)v8 - 16];
                v72 = (__int128 *)(v5 - 16);
                v73 = v68 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  v75 = *(v72 - 1);
                  v74 = *v72;
                  *(v72 - 1) = 0uLL;
                  *v72 = 0uLL;
                  *((_OWORD *)v71 - 1) = v75;
                  *(_OWORD *)v71 = v74;
                  v71 -= 32;
                  v72 -= 2;
                  v73 -= 4;
                }
                while (v73);
                v5 = v70;
                if (v68 != (v68 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_142:
                  do
                  {
                    v76 = *(_QWORD *)(v5 - 8);
                    v5 -= 8;
                    *(_QWORD *)v5 = 0;
                    *--v65 = v76;
                  }
                  while (v5 != v7);
                }
                v5 = *(_QWORD *)(v10 + 1224);
                v77 = *(_QWORD **)(v10 + 1232);
                *(_QWORD *)(v10 + 1224) = v65;
                *(_QWORD *)(v10 + 1232) = v59;
                *(_QWORD *)(v10 + 1240) = v64;
                while (v77 != (_QWORD *)v5)
                {
                  v79 = *--v77;
                  v78 = v79;
                  *v77 = 0;
                  if (v79)
                    (*(void (**)(uint64_t))(*(_QWORD *)v78 + 8))(v78);
                }
              }
              if (v5)
                operator delete((void *)v5);
            }
            else
            {
              if (!v5)
                goto LABEL_126;
              *(_QWORD *)v5 = v9;
              v59 = (_QWORD *)(v5 + 8);
            }
            *(_QWORD *)(v10 + 1232) = v59;
            ++*(_DWORD *)(v10 + 1216);
LABEL_137:
            cricket::Port::AddOrReplaceConnection((cricket::Port *)v10, v4);
            return v4;
          }
        }
        else
        {
          v24 = (_QWORD *)operator new();
          *v24 = 1;
          v25 = (unsigned int *)v24 + 1;
          do
            v26 = __ldxr(v25);
          while (__stxr(v26 + 1, v25));
          v27 = *(_QWORD *)(v10 + 776);
          if (v27)
          {
            v28 = (unsigned int *)(v27 + 4);
            do
            {
              v29 = __ldaxr(v28);
              v30 = v29 - 1;
            }
            while (__stlxr(v30, v28));
            if (!v30)
              MEMORY[0x20BD0ADEC]();
          }
          *(_QWORD *)(v10 + 776) = v24;
        }
        v32 = (unsigned int *)v24 + 1;
        do
          v33 = __ldxr(v32);
        while (__stxr(v33 + 1, v32));
        v34 = *(_QWORD *)(v10 + 784);
        do
          v35 = __ldxr(v32);
        while (__stxr(v35 + 1, v32));
        do
        {
          v36 = __ldaxr(v32);
          v37 = v36 - 1;
        }
        while (__stlxr(v37, v32));
        if (!v37)
          MEMORY[0x20BD0ADEC](v24, 0x1000C404A09149ALL);
        goto LABEL_47;
      }
    }
  }
  return 0;
}

uint64_t cricket::TurnPort::SetOption(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  int v4;
  uint64_t v6;
  int *v8;
  uint64_t **v9;
  _QWORD *v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t *v14;

  v3 = a3;
  v4 = a2;
  if ((_DWORD)a2 == 5)
    *(_DWORD *)(a1 + 1076) = a3;
  v6 = *(_QWORD *)(a1 + 1032);
  if (v6)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 72))(v6, a2, a3);
  v8 = *(int **)(a1 + 1048);
  if (v8)
  {
    while (1)
    {
      while (1)
      {
        v10 = v8;
        v11 = v8[7];
        if (v11 <= (int)a2)
          break;
        v8 = (int *)*v10;
        v9 = (uint64_t **)v10;
        if (!*v10)
          goto LABEL_12;
      }
      if (v11 >= (int)a2)
        break;
      v8 = (int *)v10[1];
      if (!v8)
      {
        v9 = (uint64_t **)(v10 + 1);
        goto LABEL_12;
      }
    }
  }
  else
  {
    v9 = (uint64_t **)(a1 + 1048);
    v10 = (_QWORD *)(a1 + 1048);
LABEL_12:
    v12 = v10;
    v10 = operator new(0x28uLL);
    *((_DWORD *)v10 + 7) = v4;
    *((_DWORD *)v10 + 8) = 0;
    *v10 = 0;
    v10[1] = 0;
    v10[2] = v12;
    *v9 = v10;
    v13 = **(_QWORD **)(a1 + 1040);
    v14 = v10;
    if (v13)
    {
      *(_QWORD *)(a1 + 1040) = v13;
      v14 = *v9;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 1048), v14);
    ++*(_QWORD *)(a1 + 1056);
  }
  *((_DWORD *)v10 + 8) = v3;
  return 0;
}

uint64_t cricket::TurnPort::GetOption(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t *v9;

  v3 = *(_QWORD *)(a1 + 1032);
  if (v3)
    return (*(uint64_t (**)(_QWORD))(*(_QWORD *)v3 + 64))(*(_QWORD *)(a1 + 1032));
  v5 = *(_QWORD *)(a1 + 1048);
  if (!v5)
    return 0xFFFFFFFFLL;
  v6 = a1 + 1048;
  do
  {
    v7 = *(_DWORD *)(v5 + 28);
    v8 = v7 < a2;
    if (v7 >= a2)
      v9 = (uint64_t *)v5;
    else
      v9 = (uint64_t *)(v5 + 8);
    if (!v8)
      v6 = v5;
    v5 = *v9;
  }
  while (*v9);
  if (v6 == a1 + 1048 || *(_DWORD *)(v6 + 28) > a2)
    return 0xFFFFFFFFLL;
  result = 0;
  *a3 = *(_DWORD *)(v6 + 32);
  return result;
}

uint64_t cricket::TurnPort::GetError(cricket::TurnPort *this)
{
  return *((unsigned int *)this + 268);
}

size_t cricket::TurnPort::SendTo(cricket::TurnPort *this, const void *a2, size_t a3, const rtc::SocketAddress *a4, const rtc::PacketOptions *a5, int a6)
{
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  _BYTE *v17;
  size_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  __int16 v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  _WORD *v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  __int128 v33;
  uint64_t v34;
  __int16 v35;
  int v36;
  __int16 v37;
  __int16 v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  void (***v46)(_QWORD);
  uint64_t v47;
  cricket::TurnChannelBindRequest *v48;
  const void **v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  size_t v60;
  char *v61;
  char *v62;
  int v63;
  _DWORD *v64;
  char *v66;
  char *v67;
  int v68;
  __int16 v69;
  unsigned int v70;
  int v71;
  __int128 v72;
  __int128 v73;
  uint64_t v74;
  uint64_t v75;
  void *v76[2];
  _QWORD *v77;
  void *v78;
  void *v79;
  void *v80;
  __int128 v81;
  uint64_t v82;
  _BYTE v83[24];
  uint64_t v84;
  void *__p;
  char v86;
  __int128 v87;
  _DWORD *v88;
  cricket::TurnChannelBindRequest *v89;
  _OWORD v90[2];
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  v11 = (uint64_t *)*((_QWORD *)this + 153);
  v12 = (uint64_t *)*((_QWORD *)this + 154);
  if (v11 == v12)
  {
LABEL_10:
    v15 = 0;
    if (*((_DWORD *)this + 312) != 2)
    {
LABEL_8:
      *((_DWORD *)this + 268) = 57;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    do
    {
      v14 = *v11;
      if (rtc::SocketAddress::EqualIPs((rtc::SocketAddress *)(*v11 + 104), a4)
        && *(unsigned __int16 *)(v14 + 160) == *((unsigned __int16 *)a4 + 28))
      {
        if (v11 == *((uint64_t **)this + 154))
          goto LABEL_10;
        goto LABEL_7;
      }
      ++v11;
    }
    while (v11 != v12);
    v11 = v12;
    if (v12 == *((uint64_t **)this + 154))
      goto LABEL_10;
LABEL_7:
    v15 = *v11;
    if (*((_DWORD *)this + 312) != 2)
      goto LABEL_8;
  }
  v73 = *(_OWORD *)a5;
  v17 = (_BYTE *)*((_QWORD *)a5 + 3);
  v16 = (_BYTE *)*((_QWORD *)a5 + 4);
  v18 = v16 - v17;
  v71 = *((_DWORD *)a5 + 4);
  v68 = a6;
  if (v16 == v17)
  {
    v20 = 0;
    v19 = 0;
  }
  else
  {
    if ((v18 & 0x8000000000000000) != 0)
      goto LABEL_95;
    v19 = (char *)operator new(v16 - v17);
    v20 = &v19[v18];
    memcpy(v19, v17, v18);
  }
  v72 = *((_OWORD *)a5 + 3);
  v21 = *((_QWORD *)a5 + 8);
  v90[0] = *(_OWORD *)((char *)a5 + 79);
  *(_OWORD *)((char *)v90 + 9) = *(_OWORD *)((char *)a5 + 88);
  v22 = *((_WORD *)a5 + 52);
  v23 = (*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 128))(this);
  if (v23 < 4)
    v24 = v23 + 1;
  else
    v24 = 0;
  v70 = v24;
  v69 = *(_WORD *)((*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 24))(this) + 286);
  v25 = operator new[]();
  v26 = *(_DWORD *)(v15 + 176);
  v88 = (_DWORD *)v25;
  v87 = xmmword_208F070B0;
  if (v26 != 2
    || (v27 = (_WORD *)v25, (v28 = *(_QWORD *)(*(_QWORD *)(v15 + 88) + 1264)) != 0)
    && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28) & 1) == 0)
  {
    cricket::StunMessage::StunMessage((cricket::StunMessage *)v76, 22);
    v76[0] = &off_24C0C1660;
    v31 = operator new();
    *(_DWORD *)(v31 + 8) = 18;
    *(_QWORD *)v31 = off_24C0C14A0;
    *(_QWORD *)(v31 + 16) = 0;
    v32 = (_QWORD *)(v31 + 16);
    *(_QWORD *)(v31 + 24) = 0;
    *(_QWORD *)(v31 + 32) = 0;
    *(_BYTE *)(v31 + 80) = 0;
    *(_WORD *)(v31 + 72) = 0;
    *(_DWORD *)(v31 + 76) = 0;
    *(_QWORD *)(v31 + 48) = 0;
    *(_QWORD *)(v31 + 56) = 0;
    *(_QWORD *)(v31 + 40) = &unk_24C0ACDA0;
    *(_DWORD *)(v31 + 64) = 0;
    if (v31 + 16 != v15 + 104)
    {
      if (*(char *)(v15 + 127) < 0)
      {
        std::string::__assign_no_alias<true>(v32, *(char **)(v15 + 104), *(_QWORD *)(v15 + 112));
      }
      else
      {
        v33 = *(_OWORD *)(v15 + 104);
        *(_QWORD *)(v31 + 32) = *(_QWORD *)(v15 + 120);
        *(_OWORD *)v32 = v33;
      }
    }
    v67 = v20;
    v34 = v21;
    v35 = v22;
    v36 = *(_DWORD *)(v15 + 136);
    *(_DWORD *)(v31 + 48) = v36;
    *(_OWORD *)(v31 + 52) = *(_OWORD *)(v15 + 140);
    *(_WORD *)(v31 + 72) = *(_WORD *)(v15 + 160);
    *(_BYTE *)(v31 + 80) = *(_BYTE *)(v15 + 168);
    *(_DWORD *)(v31 + 76) = *(_DWORD *)(v15 + 164);
    if (v36 == 30)
      v37 = 20;
    else
      v37 = 0;
    if (v36 == 2)
      v38 = 8;
    else
      v38 = v37;
    *(_WORD *)(v31 + 10) = v38;
    *(_QWORD *)v31 = off_24C0C14E0;
    *(_QWORD *)(v31 + 88) = 0;
    v75 = v31;
    cricket::StunXorAddressAttribute::SetOwner(v31, (cricket::StunMessage *)v76);
    WORD1(v79) += ((*(_WORD *)(v31 + 10) + 3) & 0xFFFC) + 4;
    v39 = v77;
    if (v77 >= v78)
    {
      v77 = std::vector<std::unique_ptr<webrtc::PushSincResampler>>::__push_back_slow_path<std::unique_ptr<webrtc::PushSincResampler>>(&v76[1], &v75);
      v40 = v75;
      v75 = 0;
      if (!v40)
        goto LABEL_44;
    }
    else
    {
      if (!v77)
        goto LABEL_94;
      v75 = 0;
      *v77 = v31;
      v77 = v39 + 1;
      v40 = v75;
      v75 = 0;
      if (!v40)
      {
LABEL_44:
        v41 = operator new();
        *(_DWORD *)(v41 + 8) = 19;
        *(_QWORD *)v41 = &off_24C0C15A0;
        *(_QWORD *)(v41 + 16) = 0;
        v42 = (void *)operator new[]();
        memcpy(v42, a2, a3);
        v43 = *(_QWORD *)(v41 + 16);
        if (v43)
          MEMORY[0x20BD0ADD4](v43, 0x1000C8077774924);
        *(_QWORD *)(v41 + 16) = v42;
        *(_WORD *)(v41 + 10) = a3;
        v74 = v41;
        (*(void (**)(uint64_t, void **))(*(_QWORD *)v41 + 24))(v41, v76);
        WORD1(v79) += ((*(_WORD *)(v41 + 10) + 3) & 0xFFFC) + 4;
        v44 = v77;
        if (v77 >= v78)
        {
          v22 = v35;
          v21 = v34;
          v77 = std::vector<std::unique_ptr<webrtc::PushSincResampler>>::__push_back_slow_path<std::unique_ptr<webrtc::PushSincResampler>>(&v76[1], &v74);
          v45 = v74;
          v74 = 0;
          if (!v45)
            goto LABEL_52;
          goto LABEL_51;
        }
        if (v77)
        {
          v22 = v35;
          v74 = 0;
          *v77 = v41;
          v21 = v34;
          v77 = v44 + 1;
          v45 = v74;
          v74 = 0;
          if (!v45)
          {
LABEL_52:
            v46 = *(void (****)(_QWORD))(*(_QWORD *)(v15 + 88) + 1264);
            if (v46)
              (**v46)(v46);
            cricket::StunMessage::Write((uint64_t)v76, (uint64_t)&v87);
            if (!*(_DWORD *)(v15 + 176) && v68)
            {
              v47 = *(_QWORD *)(v15 + 88);
              v48 = (cricket::TurnChannelBindRequest *)operator new();
              cricket::TurnChannelBindRequest::TurnChannelBindRequest(v48, *(cricket::TurnPort **)(v15 + 88), (cricket::TurnEntry *)v15, *(_DWORD *)(v15 + 96), (const rtc::SocketAddress *)(v15 + 104));
              v49 = (const void **)(*((_QWORD *)v48 + 2) + 40);
              v89 = v48;
              std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>(v47 + 1088, v49, (uint64_t)v49, (uint64_t *)&v89);
              v50 = (uint64_t)v89;
              v89 = 0;
              if (v50)
                (*(void (**)(uint64_t))(*(_QWORD *)v50 + 8))(v50);
              v51 = *((_QWORD *)v48 + 5);
              if (v51)
              {
                do
                  v52 = __ldxr((unsigned int *)v51);
                while (__stxr(v52 + 1, (unsigned int *)v51));
                *(_BYTE *)(v51 + 4) = 1;
                do
                {
                  v53 = __ldaxr((unsigned int *)v51);
                  v54 = v53 - 1;
                }
                while (__stlxr(v54, (unsigned int *)v51));
                if (!v54)
                  MEMORY[0x20BD0ADEC]();
              }
              else
              {
                MEMORY[4] = 1;
              }
              cricket::StunRequest::SendInternal(v48);
              *(_DWORD *)(v15 + 176) = 1;
            }
            v76[0] = &off_24C0C1470;
            if (v86 < 0)
            {
              operator delete(__p);
              if ((v83[23] & 0x80000000) == 0)
              {
LABEL_68:
                if ((SHIBYTE(v81) & 0x80000000) == 0)
                  goto LABEL_69;
                goto LABEL_73;
              }
            }
            else if ((v83[23] & 0x80000000) == 0)
            {
              goto LABEL_68;
            }
            operator delete(*(void **)v83);
            if ((SHIBYTE(v81) & 0x80000000) == 0)
            {
LABEL_69:
              v55 = v76[1];
              if (!v76[1])
                goto LABEL_81;
              goto LABEL_74;
            }
LABEL_73:
            operator delete(v80);
            v55 = v76[1];
            if (!v76[1])
            {
LABEL_81:
              v20 = v67;
              goto LABEL_82;
            }
LABEL_74:
            v56 = v77;
            v57 = v55;
            if (v77 != v55)
            {
              do
              {
                v59 = *--v56;
                v58 = v59;
                *v56 = 0;
                if (v59)
                  (*(void (**)(uint64_t))(*(_QWORD *)v58 + 8))(v58);
              }
              while (v56 != v55);
              v57 = v76[1];
            }
            v77 = v55;
            operator delete(v57);
            goto LABEL_81;
          }
LABEL_51:
          (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
          goto LABEL_52;
        }
LABEL_94:
        __break(1u);
      }
    }
    (*(void (**)(uint64_t))(*(_QWORD *)v40 + 8))(v40);
    goto LABEL_44;
  }
  *v27 = bswap32(*(unsigned __int16 *)(v15 + 96)) >> 16;
  v27[1] = bswap32(a3) >> 16;
  *(_QWORD *)&v87 = 4;
  if (a3)
  {
    if (a3 + 4 > 0x1000)
    {
      v66 = v20;
      if (a3 + 4 <= 0x1800)
        v29 = 6144;
      else
        v29 = a3 + 4;
      v30 = (_DWORD *)operator new[]();
      *v30 = *(_DWORD *)v27;
      MEMORY[0x20BD0ADD4](v27, 0x1000C8077774924);
      *((_QWORD *)&v87 + 1) = v29;
      v88 = v30;
      v20 = v66;
      v27 = v30;
    }
    memcpy(v27 + 2, a2, a3);
    *(_QWORD *)&v87 = a3 + 4;
  }
LABEL_82:
  *(_OWORD *)v76 = v73;
  LODWORD(v77) = v71;
  v79 = 0;
  v80 = 0;
  v78 = 0;
  v60 = v20 - v19;
  if (v60)
  {
    if ((v60 & 0x8000000000000000) == 0)
    {
      v61 = (char *)operator new(v60);
      v62 = &v61[v60];
      v78 = v61;
      v80 = &v61[v60];
      memcpy(v61, v19, v60);
      v79 = v62;
      goto LABEL_85;
    }
LABEL_95:
    abort();
  }
LABEL_85:
  v81 = v72;
  v82 = v21;
  *(_DWORD *)v83 = v70;
  *(_WORD *)&v83[4] = v69;
  v83[6] = 1;
  v84 = *(_QWORD *)((char *)&v90[1] + 1);
  *(_OWORD *)&v83[7] = v90[0];
  LOWORD(__p) = v22;
  *(_QWORD *)&v83[16] = v87 - a3;
  v63 = (*(uint64_t (**)(_QWORD, _DWORD *))(**(_QWORD **)(*(_QWORD *)(v15 + 88) + 1032) + 40))(*(_QWORD *)(*(_QWORD *)(v15 + 88) + 1032), v88);
  if (v78)
  {
    v79 = v78;
    operator delete(v78);
  }
  v64 = v88;
  v88 = 0;
  if (v64)
    MEMORY[0x20BD0ADD4](v64, 0x1000C8077774924);
  if (v63 <= 0)
  {
    *((_DWORD *)this + 268) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 129) + 80))(*((_QWORD *)this + 129));
    a3 = 0xFFFFFFFFLL;
  }
  if (v19)
    operator delete(v19);
  return a3;
}

BOOL cricket::TurnPort::CanHandleIncomingPacketsFrom(cricket::TurnPort *this, const rtc::SocketAddress *a2)
{
  _BOOL8 result;

  result = rtc::SocketAddress::EqualIPs((cricket::TurnPort *)((char *)this + 792), a2);
  if ((_DWORD)result)
    return *((unsigned __int16 *)this + 424) == *((unsigned __int16 *)a2 + 28);
  return result;
}

void cricket::TurnPort::SendBindingErrorResponse(uint64_t a1, uint64_t a2, rtc::SocketAddress *a3, int a4, void **a5, size_t a6)
{
  if ((*(uint64_t (**)(uint64_t, rtc::SocketAddress *))(*(_QWORD *)a1 + 88))(a1, a3))
    cricket::Port::SendBindingErrorResponse(a1, a2, a3, a4, a5, a6);
}

uint64_t cricket::TurnPort::HandleIncomingPacket(uint64_t **a1, uint64_t *a2, char **a3)
{
  unsigned __int16 *v6;
  rtc::SocketAddress *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t *v37;
  int v38;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void *__p;
  char v61;
  void *v62;
  char v63;
  void *v64[2];
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;

  if (a1[129] != a2)
    return 0;
  v6 = (unsigned __int16 *)a3[4];
  v7 = (rtc::SocketAddress *)(a1 + 99);
  if (!rtc::SocketAddress::EqualIPs((rtc::SocketAddress *)v6, (const rtc::SocketAddress *)(a1 + 99))
    || v6[28] != *((unsigned __int16 *)a1 + 424))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      return 0;
    ((void (*)(void **__return_ptr, uint64_t **))(*a1)[22])(v64, a1);
    rtc::SocketAddress::ToSensitiveNameAndAddressString((rtc::SocketAddress *)a3[4], (unint64_t)&v62);
    rtc::SocketAddress::ToSensitiveNameAndAddressString(v7, (unint64_t)&__p);
    rtc::webrtc_logging_impl::Log("\r\n\t\n\t\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (v61 < 0)
    {
      operator delete(__p);
      if ((v63 & 0x80000000) == 0)
      {
LABEL_12:
        if ((SHIBYTE(v65) & 0x80000000) == 0)
          return 0;
LABEL_16:
        operator delete(v64[0]);
        return 0;
      }
    }
    else if ((v63 & 0x80000000) == 0)
    {
      goto LABEL_12;
    }
    operator delete(v62);
    if ((SHIBYTE(v65) & 0x80000000) == 0)
      return 0;
    goto LABEL_16;
  }
  v8 = (unint64_t)a3[1];
  if (v8 <= 3)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      return 0;
    ((void (*)(void **__return_ptr, uint64_t **))(*a1)[22])(v64, a1);
    rtc::webrtc_logging_impl::Log("\r\n\t", v16, v17, v18, v19, v20, v21, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (SHIBYTE(v65) < 0)
      operator delete(v64[0]);
    return 0;
  }
  if (*((_DWORD *)a1 + 312) == 4)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      return 0;
    ((void (*)(void **__return_ptr, uint64_t **))(*a1)[22])(v64, a1);
    rtc::webrtc_logging_impl::Log("\r\n\t", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (SHIBYTE(v65) < 0)
      operator delete(v64[0]);
    return 0;
  }
  v23 = *a3;
  if (*((_BYTE *)a3 + 24))
    v24 = (uint64_t)a3[2];
  else
    v24 = -1;
  v25 = *(unsigned __int16 *)v23;
  v26 = __rev16(v25);
  if ((v26 & 0xC000) == 0x4000)
  {
    v27 = (int)v8;
    v28 = __rev16(*((unsigned __int16 *)v23 + 1));
    if (v27 - 4 >= v28)
    {
      v36 = a1[153];
      v37 = a1[154];
      if (v36 != v37)
      {
        while (*(_DWORD *)(*v36 + 96) != v26)
        {
          if (++v36 == v37)
            goto LABEL_52;
        }
      }
      if (v36 == v37 || (v40 = *v36) == 0)
      {
LABEL_52:
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
          goto LABEL_53;
      }
      else
      {
        v41 = (unint64_t)v24 >> 63;
        v42 = v24 & 0xFFFFFFFFFFFFFF00 | (v24 & ~(v24 >> 63));
        if (*((_WORD *)v23 + 1))
          v43 = v23 + 4;
        else
          v43 = 0;
        v64[0] = v43;
        v64[1] = (void *)v28;
        v65 = v42;
        v66 = v41 ^ 1;
        v67 = v40 + 104;
        v68 = 0;
        v44 = ((uint64_t (*)(uint64_t **))(*a1)[11])(a1);
        if (v44)
        {
          cricket::Connection::OnReadPacket(v44, v64);
          return 1;
        }
        cricket::Port::OnReadPacket((uint64_t)a1, (uint64_t *)v64, 0);
      }
    }
    else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
LABEL_53:
      ((void (*)(void **__return_ptr, uint64_t **))(*a1)[22])(v64, a1);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v45, v46, v47, v48, v49, v50, v51, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (SHIBYTE(v65) < 0)
      {
        operator delete(v64[0]);
        return 1;
      }
    }
    return 1;
  }
  if (v25 == 5888)
  {
    cricket::TurnPort::HandleDataIndication((cricket::TurnPort *)a1, v23, (int)v8, v24);
    return 1;
  }
  else
  {
    v38 = ((uint64_t (*)(uint64_t **))(*a1)[8])(a1);
    if ((v26 & 0xFFFFFFEF) != 0x101 || v38 == 0)
    {
      cricket::StunRequestManager::CheckResponse(a1 + 135, (void **)v23, (int)v8);
      return 1;
    }
    else
    {
      v52 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>();
      if ((v52 & 1) != 0)
      {
        return 0;
      }
      else
      {
        ((void (*)(void **__return_ptr, uint64_t **))(*a1)[22])(v64, a1);
        rtc::webrtc_logging_impl::Log("\r\n\t", v53, v54, v55, v56, v57, v58, v59, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
        if (SHIBYTE(v65) < 0)
          operator delete(v64[0]);
        return 0;
      }
    }
  }
}

void cricket::TurnPort::HandleDataIndication(cricket::TurnPort *this, const char *a2, uint64_t a3, uint64_t a4)
{
  const char *v6;
  std::string::size_type size;
  std::string::size_type v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  std::string::size_type v18;
  _QWORD *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t *i;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  void *v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  void *v41;
  char v42;
  void *__p[2];
  uint64_t v44;
  void *v45;
  _BYTE v46[20];
  __int16 v47;
  int v48;
  char v49;
  std::string v50;
  void *v51;
  char v52;
  void *v53;
  char v54;
  void *v55;
  char v56;
  _QWORD v57[4];
  void *v58[2];
  unint64_t v59;
  uint64_t v60;
  void **v61;
  uint64_t v62;

  if (a3)
    v6 = a2;
  else
    v6 = 0;
  v57[0] = v6;
  v57[1] = a3;
  v57[2] = 0;
  v57[3] = a3;
  cricket::StunMessage::StunMessage((uint64_t)&v50, 0, (int8x16_t *)"0000000000000000", 0x10uLL);
  v50.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24C0C1660;
  if ((cricket::StunMessage::Read(&v50, (rtc::ByteBufferReader *)v57) & 1) != 0)
  {
    size = v50.__r_.__value_.__l.__size_;
    if (v50.__r_.__value_.__l.__size_ == v50.__r_.__value_.__r.__words[2])
    {
LABEL_9:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        goto LABEL_20;
    }
    else
    {
      v8 = v50.__r_.__value_.__l.__size_;
      while (1)
      {
        v9 = *(_QWORD *)v8;
        if (*(_WORD *)(*(_QWORD *)v8 + 8) == 18)
          break;
        v8 += 8;
        if (v8 == v50.__r_.__value_.__r.__words[2])
          goto LABEL_9;
      }
      do
      {
        v10 = *(_QWORD *)size;
        if (*(_WORD *)(*(_QWORD *)size + 8) == 19)
        {
          __p[0] = 0;
          __p[1] = 0;
          v44 = 0;
          v45 = &unk_24C0ACDA0;
          memset(v46, 0, sizeof(v46));
          if (__p != (void **)(v9 + 16))
          {
            if (*(char *)(v9 + 39) < 0)
            {
              std::string::__assign_no_alias<true>(__p, *(char **)(v9 + 16), *(_QWORD *)(v9 + 24));
            }
            else
            {
              *(_OWORD *)__p = *(_OWORD *)(v9 + 16);
              v44 = *(_QWORD *)(v9 + 32);
            }
          }
          v23 = *(_DWORD *)(v9 + 48);
          *(_DWORD *)v46 = v23;
          *(_OWORD *)&v46[4] = *(_OWORD *)(v9 + 52);
          v47 = *(_WORD *)(v9 + 72);
          v49 = *(_BYTE *)(v9 + 80);
          v48 = *(_DWORD *)(v9 + 76);
          for (i = (uint64_t *)*((_QWORD *)this + 153); i != *((uint64_t **)this + 154); ++i)
          {
            v25 = *i;
            if (*(_DWORD *)(*i + 136) == v23)
            {
              switch(v23)
              {
                case 2:
                  if (*(_DWORD *)(v25 + 140) == *(_DWORD *)&v46[4])
                    goto LABEL_58;
                  break;
                case 30:
                  v26 = *(_QWORD *)(v25 + 140);
                  v27 = *(_QWORD *)(v25 + 148);
                  if (v26 == *(_QWORD *)&v46[4] && v27 == *(_QWORD *)&v46[12])
                    goto LABEL_58;
                  break;
                case 0:
                  goto LABEL_58;
              }
            }
          }
          if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
          {
            (*(void (**)(void **__return_ptr, cricket::TurnPort *))(*(_QWORD *)this + 176))(v58, this);
            rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)__p, (char *)&v41);
            rtc::webrtc_logging_impl::Log("\r\n\t\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
            if (v42 < 0)
              operator delete(v41);
            if (SHIBYTE(v59) < 0)
              operator delete(v58[0]);
          }
LABEL_58:
          v36 = *(void **)(v10 + 16);
          v37 = (void *)*(unsigned __int16 *)(v10 + 10);
          v38 = (unint64_t)a4 >> 63;
          v39 = a4 & 0xFFFFFFFFFFFFFF00 | (a4 & ~(a4 >> 63));
          if (!*(_WORD *)(v10 + 10))
            v36 = 0;
          v58[0] = v36;
          v58[1] = v37;
          v59 = v39;
          v60 = v38 ^ 1;
          v61 = __p;
          v62 = 0;
          v40 = (*(uint64_t (**)(cricket::TurnPort *, void **))(*(_QWORD *)this + 88))(this, __p);
          if (v40)
            cricket::Connection::OnReadPacket(v40, v58);
          else
            cricket::Port::OnReadPacket((uint64_t)this, (uint64_t *)v58, 0);
          goto LABEL_18;
        }
        size += 8;
      }
      while (size != v50.__r_.__value_.__r.__words[2]);
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        goto LABEL_20;
    }
  }
  else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
  {
    goto LABEL_20;
  }
  (*(void (**)(void **__return_ptr, cricket::TurnPort *))(*(_QWORD *)this + 176))(__p, this);
  rtc::webrtc_logging_impl::Log("\r\n\t", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
LABEL_18:
  if (SHIBYTE(v44) < 0)
    operator delete(__p[0]);
LABEL_20:
  v50.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24C0C1470;
  if (v56 < 0)
  {
    operator delete(v55);
    if ((v54 & 0x80000000) == 0)
    {
LABEL_22:
      if ((v52 & 0x80000000) == 0)
        goto LABEL_23;
LABEL_27:
      operator delete(v51);
      v18 = v50.__r_.__value_.__l.__size_;
      if (!v50.__r_.__value_.__l.__size_)
        return;
      goto LABEL_28;
    }
  }
  else if ((v54 & 0x80000000) == 0)
  {
    goto LABEL_22;
  }
  operator delete(v53);
  if (v52 < 0)
    goto LABEL_27;
LABEL_23:
  v18 = v50.__r_.__value_.__l.__size_;
  if (!v50.__r_.__value_.__l.__size_)
    return;
LABEL_28:
  v19 = (_QWORD *)v50.__r_.__value_.__r.__words[2];
  v20 = (void *)v18;
  if (v50.__r_.__value_.__r.__words[2] != v18)
  {
    do
    {
      v22 = *--v19;
      v21 = v22;
      *v19 = 0;
      if (v22)
        (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
    }
    while (v19 != (_QWORD *)v18);
    v20 = (void *)v50.__r_.__value_.__l.__size_;
  }
  v50.__r_.__value_.__r.__words[2] = v18;
  operator delete(v20);
}

uint64_t cricket::TurnPort::OnReadPacket(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 320))(a1);
}

uint64_t cricket::TurnPort::OnSentPacket(cricket::TurnPort *this, rtc::AsyncPacketSocket *a2, const rtc::SentPacket *a3)
{
  char *v4;
  uint64_t result;
  uint64_t v7;
  void (*v8)(uint64_t, const rtc::SentPacket *);

  v4 = (char *)this + 192;
  result = *((_QWORD *)this + 25);
  for (*((_QWORD *)this + 27) = result; (char *)result != v4; result = *((_QWORD *)this + 27))
  {
    v8 = *(void (**)(uint64_t, const rtc::SentPacket *))(result + 16);
    v7 = result + 16;
    *((_QWORD *)this + 27) = *(_QWORD *)(v7 - 8);
    v8(v7, a3);
  }
  return result;
}

uint64_t cricket::TurnPort::OnReadyToSend(uint64_t this, rtc::AsyncPacketSocket *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (*(_DWORD *)(this + 1248) == 2)
  {
    v2 = *(_QWORD **)(this + 672);
    v3 = (_QWORD *)(this + 680);
    if (v2 != (_QWORD *)(this + 680))
    {
      do
      {
        v4 = v2[13];
        this = *(_QWORD *)(v4 + 144);
        for (*(_QWORD *)(v4 + 160) = this; this != v4 + 136; this = *(_QWORD *)(v4 + 160))
        {
          v6 = *(void (**)(uint64_t, uint64_t))(this + 16);
          v5 = this + 16;
          *(_QWORD *)(v4 + 160) = *(_QWORD *)(v5 - 8);
          v6(v5, v4);
        }
        v7 = (_QWORD *)v2[1];
        if (v7)
        {
          do
          {
            v8 = v7;
            v7 = (_QWORD *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            v8 = (_QWORD *)v2[2];
            v9 = *v8 == (_QWORD)v2;
            v2 = v8;
          }
          while (!v9);
        }
        v2 = v8;
      }
      while (v8 != v3);
    }
  }
  return this;
}

BOOL cricket::TurnPort::SupportsProtocol(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  if (a3 != 3)
    return 0;
  return *a2 == (unsigned __int16)cricket::UDP_PROTOCOL_NAME && *((_BYTE *)a2 + 2) == 112;
}

void cricket::TurnPort::OnSendStunPacket(cricket::TurnPort *this, const void *a2, uint64_t a3, cricket::StunRequest *a4)
{
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *__p;
  char v17;
  int v18;
  char v19;
  uint64_t v20;
  int v21;
  void *v22;
  void *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  unsigned int v29;
  __int16 v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __int16 v35;

  v18 = (*(uint64_t (**)(cricket::TurnPort *, const void *, uint64_t, cricket::StunRequest *))(*(_QWORD *)this + 272))(this, a2, a3, a4);
  v19 = 0;
  v20 = -1;
  v21 = -1;
  v23 = 0;
  v24 = 0;
  v22 = 0;
  v25 = -1;
  v26 = -1;
  v27 = 0;
  v33 = 0;
  v34 = 0;
  v32 = 0;
  v35 = 0;
  v28 = 5;
  v7 = (*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 128))(this);
  if (v7 < 4)
    v8 = v7 + 1;
  else
    v8 = 0;
  v29 = v8;
  v30 = *(_WORD *)((*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 24))(this) + 286);
  v31 = 1;
  if (((*(uint64_t (**)(_QWORD, const void *, uint64_t, char *, int *))(**((_QWORD **)this + 129) + 40))(*((_QWORD *)this + 129), a2, a3, (char *)this + 792, &v18) & 0x80000000) != 0&& (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
  {
    (*(void (**)(void **__return_ptr, cricket::TurnPort *))(*(_QWORD *)this + 176))(&__p, this);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 129) + 80))(*((_QWORD *)this + 129));
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v9, v10, v11, v12, v13, v14, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (v17 < 0)
      operator delete(__p);
  }
  if (v22)
  {
    v23 = v22;
    operator delete(v22);
  }
}

uint64_t cricket::TurnPort::StunDscpValue(cricket::TurnPort *this)
{
  return *((unsigned int *)this + 269);
}

void cricket::TurnPort::ScheduleRefresh(cricket::TurnPort *this, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  cricket::TurnRefreshRequest *v19;
  const void **v20;
  void *v21;
  TimeDelta v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *__p[2];
  char v31;

  if (a2 > 0x77)
  {
    if (a2 < 0xE11)
    {
      v11 = 1000 * a2 - 60000;
    }
    else
    {
      v11 = 3540000;
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      {
        (*(void (**)(void **__return_ptr, cricket::TurnPort *))(*(_QWORD *)this + 176))(__p, this);
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v12, v13, v14, v15, v16, v17, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
        if (v31 < 0)
          operator delete(__p[0]);
      }
    }
  }
  else
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      (*(void (**)(void **__return_ptr, cricket::TurnPort *))(*(_QWORD *)this + 176))(__p, this);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v4, v5, v6, v7, v8, v9, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (v31 < 0)
        operator delete(__p[0]);
    }
    v11 = 500 * a2;
  }
  v19 = (cricket::TurnRefreshRequest *)operator new();
  cricket::TurnRefreshRequest::TurnRefreshRequest(v19, this, -1);
  v20 = (const void **)(*((_QWORD *)v19 + 2) + 40);
  __p[0] = v19;
  std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>((uint64_t)this + 1088, v20, (uint64_t)v20, (uint64_t *)__p);
  v21 = __p[0];
  __p[0] = 0;
  if (v21)
    (*(void (**)(void *))(*(_QWORD *)v21 + 8))(v21);
  v22.var0 = 1000 * v11;
  cricket::StunRequest::Send(v19, v22);
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    (*(void (**)(void **__return_ptr, cricket::TurnPort *))(*(_QWORD *)this + 176))(__p, this);
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v23, v24, v25, v26, v27, v28, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (v31 < 0)
      operator delete(__p[0]);
  }
}

unint64_t cricket::TurnPort::AddRequestAuthInfo(cricket::TurnPort *this, cricket::StunMessage *a2)
{
  _QWORD *v4;
  unint64_t result;
  uint64_t v6;
  size_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  size_t v13;
  void *v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  size_t v20;
  void *v21;
  uint64_t *v22;
  _QWORD *v23;
  __int128 *v24;
  size_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v4 = (_QWORD *)((char *)this + 960);
  result = operator new();
  v6 = result;
  if (*((char *)this + 983) < 0)
  {
    v7 = *((_QWORD *)this + 121);
    if ((v7 & 0x8000000000000000) != 0)
      goto LABEL_40;
    v4 = (_QWORD *)*v4;
    if (v7)
    {
      if (!v4)
        goto LABEL_40;
    }
  }
  else
  {
    v7 = *((unsigned __int8 *)this + 983);
  }
  *(_DWORD *)(result + 8) = 6;
  *(_QWORD *)result = &off_24C0C15A0;
  *(_QWORD *)(result + 16) = 0;
  v8 = (void *)operator new[]();
  memcpy(v8, v4, v7);
  v9 = *(_QWORD *)(v6 + 16);
  if (v9)
    MEMORY[0x20BD0ADD4](v9, 0x1000C8077774924);
  *(_QWORD *)(v6 + 16) = v8;
  *(_WORD *)(v6 + 10) = v7;
  v28 = v6;
  (*(void (**)(uint64_t, cricket::StunMessage *))(*(_QWORD *)v6 + 24))(v6, a2);
  *((_WORD *)a2 + 17) += ((*(_WORD *)(v6 + 10) + 3) & 0xFFFC) + 4;
  result = *((_QWORD *)a2 + 2);
  if (result >= *((_QWORD *)a2 + 3))
  {
    *((_QWORD *)a2 + 2) = std::vector<std::unique_ptr<webrtc::PushSincResampler>>::__push_back_slow_path<std::unique_ptr<webrtc::PushSincResampler>>((_QWORD *)a2 + 1, &v28);
    v10 = v28;
    v28 = 0;
    if (!v10)
      goto LABEL_14;
LABEL_13:
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
    goto LABEL_14;
  }
  if (!result)
    goto LABEL_40;
  v28 = 0;
  *(_QWORD *)result = v6;
  *((_QWORD *)a2 + 2) = result + 8;
  v10 = v28;
  v28 = 0;
  if (v10)
    goto LABEL_13;
LABEL_14:
  v11 = (_QWORD *)((char *)this + 1144);
  result = operator new();
  v12 = result;
  if (*((char *)this + 1167) < 0)
  {
    v13 = *((_QWORD *)this + 144);
    if ((v13 & 0x8000000000000000) != 0)
      goto LABEL_40;
    v11 = (_QWORD *)*v11;
    if (v13)
    {
      if (!v11)
        goto LABEL_40;
    }
  }
  else
  {
    v13 = *((unsigned __int8 *)this + 1167);
  }
  *(_WORD *)(result + 8) = 20;
  *(_QWORD *)result = &off_24C0C15A0;
  v14 = (void *)operator new[]();
  memcpy(v14, v11, v13);
  *(_QWORD *)(v12 + 16) = v14;
  *(_WORD *)(v12 + 10) = v13;
  v27 = v12;
  result = cricket::StunAttribute::SetOwner((cricket::StunAttribute *)v12, a2);
  *((_WORD *)a2 + 17) += ((*(_WORD *)(v12 + 10) + 3) & 0xFFFC) + 4;
  v15 = (uint64_t *)*((_QWORD *)a2 + 2);
  if ((unint64_t)v15 >= *((_QWORD *)a2 + 3))
  {
    v16 = std::vector<std::unique_ptr<webrtc::PushSincResampler>>::__push_back_slow_path<std::unique_ptr<webrtc::PushSincResampler>>((_QWORD *)a2 + 1, &v27);
    v17 = v27;
    *((_QWORD *)a2 + 2) = v16;
    v27 = 0;
    if (v17)
      (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  }
  else
  {
    if (!v15)
      goto LABEL_40;
    *v15 = v12;
    *((_QWORD *)a2 + 2) = v15 + 1;
    v27 = 0;
  }
  v18 = (_QWORD *)((char *)this + 1168);
  result = operator new();
  v19 = result;
  if (*((char *)this + 1191) < 0)
  {
    v20 = *((_QWORD *)this + 147);
    if ((v20 & 0x8000000000000000) != 0)
      goto LABEL_40;
    v18 = (_QWORD *)*v18;
    if (v20)
    {
      if (!v18)
        goto LABEL_40;
    }
  }
  else
  {
    v20 = *((unsigned __int8 *)this + 1191);
  }
  *(_WORD *)(result + 8) = 21;
  *(_QWORD *)result = &off_24C0C15A0;
  v21 = (void *)operator new[]();
  memcpy(v21, v18, v20);
  *(_QWORD *)(v19 + 16) = v21;
  *(_WORD *)(v19 + 10) = v20;
  v26 = v19;
  result = cricket::StunAttribute::SetOwner((cricket::StunAttribute *)v19, a2);
  *((_WORD *)a2 + 17) += ((*(_WORD *)(v19 + 10) + 3) & 0xFFFC) + 4;
  v22 = (uint64_t *)*((_QWORD *)a2 + 2);
  if ((unint64_t)v22 >= *((_QWORD *)a2 + 3))
  {
    v23 = std::vector<std::unique_ptr<webrtc::PushSincResampler>>::__push_back_slow_path<std::unique_ptr<webrtc::PushSincResampler>>((_QWORD *)a2 + 1, (uint64_t *)&v26);
    result = v26;
    *((_QWORD *)a2 + 2) = v23;
    v26 = 0;
    if (result)
      result = (*(uint64_t (**)(unint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    if (!v22)
      goto LABEL_40;
    *v22 = v19;
    *((_QWORD *)a2 + 2) = v22 + 1;
    v26 = 0;
  }
  v24 = (__int128 *)((char *)this + 1192);
  if ((*((char *)this + 1215) & 0x80000000) == 0)
  {
    v25 = *((unsigned __int8 *)this + 1215);
    return cricket::StunMessage::AddMessageIntegrityOfType((uint64_t)a2, 8, 0x14uLL, v24, v25);
  }
  v25 = *((_QWORD *)this + 150);
  if ((v25 & 0x8000000000000000) == 0)
  {
    v24 = *(__int128 **)v24;
    if (!v25 || v24)
      return cricket::StunMessage::AddMessageIntegrityOfType((uint64_t)a2, 8, 0x14uLL, v24, v25);
  }
LABEL_40:
  __break(1u);
  return result;
}

void cricket::TurnPort::UpdateNonce(cricket::TurnPort *this, cricket::StunMessage *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 *v14;
  size_t v15;
  BOOL v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  __int128 *v20;
  size_t v21;
  BOOL v22;
  __int128 *v23;
  uint64_t v24;
  __int128 *v25;
  void **v27;
  __int128 v28;
  uint64_t v29;

  v2 = (uint64_t *)*((_QWORD *)a2 + 1);
  v3 = (uint64_t *)*((_QWORD *)a2 + 2);
  if (v2 == v3)
  {
LABEL_4:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return;
LABEL_15:
    rtc::webrtc_logging_impl::Log("\r\t", v7, v8, v9, v10, v11, v12, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    return;
  }
  while (1)
  {
    v6 = *v2;
    if (*(_WORD *)(*v2 + 8) == 20)
      break;
    if (++v2 == v3)
      goto LABEL_4;
  }
  v14 = *(__int128 **)(v6 + 16);
  v15 = *(unsigned __int16 *)(v6 + 10);
  if (v14)
    v16 = 1;
  else
    v16 = (_DWORD)v15 == 0;
  if (!v16)
    goto LABEL_36;
  cricket::TurnPort::set_realm((uint64_t)this, v14, v15);
  v17 = (uint64_t *)*((_QWORD *)a2 + 1);
  v18 = (uint64_t *)*((_QWORD *)a2 + 2);
  if (v17 == v18)
  {
LABEL_14:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return;
    goto LABEL_15;
  }
  while (1)
  {
    v19 = *v17;
    if (*(_WORD *)(*v17 + 8) == 21)
      break;
    if (++v17 == v18)
      goto LABEL_14;
  }
  v20 = *(__int128 **)(v19 + 16);
  v21 = *(unsigned __int16 *)(v19 + 10);
  if (v20)
    v22 = 1;
  else
    v22 = (_DWORD)v21 == 0;
  if (!v22)
    goto LABEL_36;
  if (v21 > 0x16)
  {
    v24 = (v21 | 7) == 0x17 ? ((unsigned __int16)v21 & 0xFFF8) + 8 : v21 | 7;
    v23 = (__int128 *)operator new(v24 + 1);
    *((_QWORD *)&v28 + 1) = v21;
    v29 = v24 - 0x7FFFFFFFFFFFFFFFLL;
    *(_QWORD *)&v28 = v23;
  }
  else
  {
    HIBYTE(v29) = *(_WORD *)(v19 + 10);
    v23 = &v28;
  }
  v25 = (__int128 *)((char *)v23 + v21);
  if (v23 <= v20 && v25 > v20)
  {
LABEL_36:
    __break(1u);
    return;
  }
  if ((_DWORD)v21)
    memmove(v23, v20, v21);
  *(_BYTE *)v25 = 0;
  v27 = (void **)((char *)this + 1168);
  if (*((char *)this + 1191) < 0)
    operator delete(*v27);
  *(_OWORD *)v27 = v28;
  *((_QWORD *)this + 148) = v29;
}

uint64_t cricket::TurnPort::HandleConnectionDestroyed(cricket::TurnPort *this, cricket::Connection *a2)
{
  uint64_t result;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  const rtc::SocketAddress *v8;
  uint64_t v9;
  _QWORD *v10;
  cricket::Connection **v11;
  cricket::Connection **v12;
  cricket::Connection **v13;
  int64_t v14;
  unsigned int *v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  _QWORD *v19;
  unsigned int v20;
  unsigned int v21;
  char v22;
  char v23;
  _QWORD v24[2];
  uint64_t (*v25)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v26)(uint64_t);

  result = (*(uint64_t (**)(cricket::Connection *))(*(_QWORD *)a2 + 24))(a2);
  v5 = (uint64_t *)*((_QWORD *)this + 153);
  v6 = (uint64_t *)*((_QWORD *)this + 154);
  if (v5 == v6)
  {
LABEL_10:
    v10 = 0;
    v11 = (cricket::Connection **)MEMORY[0xB8];
    v12 = (cricket::Connection **)MEMORY[0xC0];
    v13 = (cricket::Connection **)MEMORY[0xB8];
    if (MEMORY[0xB8] != MEMORY[0xC0])
    {
LABEL_11:
      v13 = v11;
      while (*v13 != a2)
      {
        if (++v13 == v12)
        {
          v13 = v12;
          break;
        }
      }
    }
  }
  else
  {
    v7 = result;
    v8 = (const rtc::SocketAddress *)(result + 80);
    do
    {
      v9 = *v5;
      result = rtc::SocketAddress::EqualIPs((rtc::SocketAddress *)(*v5 + 104), v8);
      if ((_DWORD)result && *(unsigned __int16 *)(v9 + 160) == *(unsigned __int16 *)(v7 + 136))
      {
        if (v5 == *((uint64_t **)this + 154))
          goto LABEL_10;
        goto LABEL_7;
      }
      ++v5;
    }
    while (v5 != v6);
    v5 = v6;
    if (v6 == *((uint64_t **)this + 154))
      goto LABEL_10;
LABEL_7:
    v10 = (_QWORD *)*v5;
    v11 = *(cricket::Connection ***)(*v5 + 184);
    v12 = *(cricket::Connection ***)(*v5 + 192);
    v13 = v11;
    if (v11 != v12)
      goto LABEL_11;
  }
  if (v12 == v13)
  {
    __break(1u);
  }
  else
  {
    v14 = (char *)v12 - (char *)(v13 + 1);
    if (v12 != v13 + 1)
    {
      result = (uint64_t)memmove(v13, v13 + 1, (char *)v12 - (char *)(v13 + 1));
      v11 = (cricket::Connection **)v10[23];
    }
    v10[24] = (char *)v13 + v14;
    if (v11 == (cricket::Connection **)((char *)v13 + v14))
    {
      v15 = (unsigned int *)v10[26];
      if (v15)
      {
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
        v17 = (*(uint64_t (**)(cricket::TurnPort *))(*(_QWORD *)this + 208))(this);
        do
          v18 = __ldxr(v15);
        while (__stxr(v18 + 1, v15));
        v19 = (_QWORD *)operator new();
        *v19 = v15;
        v19[1] = this;
        v19[2] = v10;
        v19[3] = absl::internal_any_invocable::LocalManagerTrivial;
        v19[4] = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnPort::HandleConnectionDestroyed(cricket::Connection *)::$_0 &&>;
        v24[0] = v19;
        v25 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
        v26 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
        v23 = 0;
        (*(void (**)(uint64_t, _QWORD *, uint64_t, char *, char *))(*(_QWORD *)v17 + 16))(v17, v24, 300000000, &v23, &v22);
        result = v25(1, v24, v24);
        do
        {
          v20 = __ldaxr(v15);
          v21 = v20 - 1;
        }
        while (__stlxr(v21, v15));
        if (!v21)
          return MEMORY[0x20BD0ADEC](v15, 0x1000C4090D0E795);
      }
    }
  }
  return result;
}

cricket::TurnAllocateRequest *cricket::TurnAllocateRequest::TurnAllocateRequest(cricket::TurnAllocateRequest *this, cricket::TurnPort *a2)
{
  char *v4;
  cricket::StunMessage *v5;
  _QWORD *v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  cricket::TurnAllocateRequest *result;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _QWORD *v17;
  uint64_t v18;
  size_t v19;
  void *v20;
  uint64_t *v21;
  _QWORD *v22;
  uint64_t v23;
  void (***v24)(_QWORD);
  uint64_t v25;
  uint64_t v26;

  v4 = (char *)a2 + 1080;
  v5 = (cricket::StunMessage *)operator new();
  cricket::StunMessage::StunMessage(v5, 3);
  *v6 = &off_24C0C1660;
  *(_QWORD *)this = &off_24C0C1B10;
  *((_QWORD *)this + 1) = v4;
  *((_QWORD *)this + 2) = v6;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_BYTE *)this + 36) = 0;
  v7 = operator new();
  *(_DWORD *)v7 = 0;
  *(_BYTE *)(v7 + 4) = 0;
  do
    v8 = __ldxr((unsigned int *)v7);
  while (__stxr(v8 + 1, (unsigned int *)v7));
  *((_QWORD *)this + 5) = v7;
  *((_BYTE *)this + 48) = 1;
  *(_QWORD *)this = &off_24C0C2B60;
  *((_QWORD *)this + 7) = a2;
  v9 = *((_QWORD *)this + 2);
  v10 = operator new();
  *(_QWORD *)v10 = &off_24C0C1520;
  *(_QWORD *)(v10 + 8) = 0x1100000000040019;
  v25 = v10;
  result = (cricket::TurnAllocateRequest *)cricket::StunAttribute::SetOwner((cricket::StunAttribute *)v10, (cricket::StunMessage *)v9);
  *(_WORD *)(v9 + 34) += ((*(_WORD *)(v10 + 10) + 3) & 0xFFFC) + 4;
  v12 = *(uint64_t **)(v9 + 16);
  if ((unint64_t)v12 >= *(_QWORD *)(v9 + 24))
  {
    v13 = std::vector<std::unique_ptr<webrtc::PushSincResampler>>::__push_back_slow_path<std::unique_ptr<webrtc::PushSincResampler>>((_QWORD *)(v9 + 8), &v25);
    v14 = v25;
    *(_QWORD *)(v9 + 16) = v13;
    v25 = 0;
    if (v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  }
  else
  {
    if (!v12)
      goto LABEL_29;
    *v12 = v10;
    *(_QWORD *)(v9 + 16) = v12 + 1;
    v25 = 0;
  }
  v15 = *((_QWORD *)this + 7);
  if (*(char *)(v15 + 1215) < 0)
  {
    if (*(_QWORD *)(v15 + 1200))
    {
LABEL_10:
      cricket::TurnPort::AddRequestAuthInfo(*((cricket::TurnPort **)this + 7), (cricket::StunMessage *)v9);
      v15 = *((_QWORD *)this + 7);
      v16 = *(char *)(v15 + 1295);
      if ((v16 & 0x80000000) == 0)
        goto LABEL_11;
      goto LABEL_15;
    }
  }
  else if (*(_BYTE *)(v15 + 1215))
  {
    goto LABEL_10;
  }
  *((_BYTE *)this + 48) = 0;
  v16 = *(char *)(v15 + 1295);
  if ((v16 & 0x80000000) == 0)
  {
LABEL_11:
    if (!(_BYTE)v16)
      goto LABEL_26;
    goto LABEL_16;
  }
LABEL_15:
  if (*(_QWORD *)(v15 + 1280))
  {
LABEL_16:
    v17 = (_QWORD *)(v15 + 1272);
    result = (cricket::TurnAllocateRequest *)operator new();
    v18 = (uint64_t)result;
    if (*(char *)(v15 + 1295) < 0)
    {
      v19 = *(_QWORD *)(v15 + 1280);
      if ((v19 & 0x8000000000000000) != 0)
        goto LABEL_29;
      v17 = (_QWORD *)*v17;
      if (v19)
      {
        if (!v17)
          goto LABEL_29;
      }
    }
    else
    {
      v19 = *(unsigned __int8 *)(v15 + 1295);
    }
    *((_WORD *)result + 4) = -251;
    *(_QWORD *)result = &off_24C0C15A0;
    v20 = (void *)operator new[]();
    memcpy(v20, v17, v19);
    *(_QWORD *)(v18 + 16) = v20;
    *(_WORD *)(v18 + 10) = v19;
    v26 = v18;
    result = (cricket::TurnAllocateRequest *)cricket::StunAttribute::SetOwner((cricket::StunAttribute *)v18, (cricket::StunMessage *)v9);
    *(_WORD *)(v9 + 34) += ((*(_WORD *)(v18 + 10) + 3) & 0xFFFC) + 4;
    v21 = *(uint64_t **)(v9 + 16);
    if ((unint64_t)v21 >= *(_QWORD *)(v9 + 24))
    {
      v22 = std::vector<std::unique_ptr<webrtc::PushSincResampler>>::__push_back_slow_path<std::unique_ptr<webrtc::PushSincResampler>>((_QWORD *)(v9 + 8), &v26);
      v23 = v26;
      *(_QWORD *)(v9 + 16) = v22;
      v26 = 0;
      if (v23)
        (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
      goto LABEL_26;
    }
    if (v21)
    {
      *v21 = v18;
      *(_QWORD *)(v9 + 16) = v21 + 1;
      goto LABEL_26;
    }
LABEL_29:
    __break(1u);
    return result;
  }
LABEL_26:
  v24 = *(void (****)(_QWORD))(*((_QWORD *)this + 7) + 1264);
  if (v24)
    (**v24)(v24);
  return this;
}

void cricket::TurnAllocateRequest::OnSent(cricket::TurnAllocateRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  _BYTE *v18;
  unsigned int v19;
  int v20;
  int v21;
  void *__p[2];
  int64_t v23;
  void *v24;
  char v25;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    goto LABEL_22;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(&v24);
  v9 = *((_QWORD *)this + 2);
  v10 = (_QWORD *)(v9 + 40);
  if ((*(char *)(v9 + 63) & 0x80000000) == 0)
  {
    v11 = *(unsigned __int8 *)(v9 + 63);
    goto LABEL_10;
  }
  v11 = *(_QWORD *)(v9 + 48);
  if ((v11 & 0x8000000000000000) != 0 || ((v10 = (_QWORD *)*v10, v11) ? (v12 = v10 == 0) : (v12 = 0), v12))
  {
    __break(1u);
LABEL_29:
    abort();
  }
  if (v11 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_29;
LABEL_10:
  v13 = 2 * v11;
  if (v11 >= 0xC)
  {
    v15 = (v13 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v15 = v13 | 7;
    v16 = v15 + 1;
    v14 = operator new(v15 + 1);
    __p[1] = (void *)(2 * v11);
    v23 = v16 | 0x8000000000000000;
    __p[0] = v14;
  }
  else
  {
    HIBYTE(v23) = 2 * v11;
    v14 = __p;
    if (!v11)
    {
      LOBYTE(__p[0]) = 0;
      goto LABEL_20;
    }
  }
  bzero(v14, 2 * v11);
  *((_BYTE *)v14 + 2 * v11) = 0;
  v17 = __p;
  if (v23 < 0)
    v17 = (void **)__p[0];
  v18 = (char *)v17 + 1;
  do
  {
    v19 = *(unsigned __int8 *)v10;
    v10 = (_QWORD *)((char *)v10 + 1);
    v18 += 2;
    --v11;
  }
  while (v11);
LABEL_20:
  rtc::webrtc_logging_impl::Log("\r\n\t\n", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (SHIBYTE(v23) < 0)
  {
    operator delete(__p[0]);
    if (v25 < 0)
      goto LABEL_26;
LABEL_22:
    v20 = *((_DWORD *)this + 8);
    *((_DWORD *)this + 8) = v20 + 1;
    if (v20 < 8)
      return;
    goto LABEL_23;
  }
  if ((v25 & 0x80000000) == 0)
    goto LABEL_22;
LABEL_26:
  operator delete(v24);
  v21 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = v21 + 1;
  if (v21 >= 8)
LABEL_23:
    *((_BYTE *)this + 36) = 1;
}

void cricket::TurnAllocateRequest::OnResponse(cricket::TurnAllocateRequest *this, cricket::StunMessage *a2)
{
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  _BYTE *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  size_t v38;
  int v39;
  const std::string::value_type *v40;
  std::string::size_type v41;
  void *v42[2];
  int64_t v43;
  void *__p[2];
  uint64_t v45;
  void *v46;
  _BYTE v47[20];
  __int16 v48;
  int v49;
  char v50;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    goto LABEL_27;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(__p);
  v4 = *((_QWORD *)this + 2);
  v5 = (_QWORD *)(v4 + 40);
  if (*(char *)(v4 + 63) < 0)
  {
    v6 = *(_QWORD *)(v4 + 48);
    if ((v6 & 0x8000000000000000) != 0 || ((v5 = (_QWORD *)*v5, v6) ? (v7 = v5 == 0) : (v7 = 0), v7))
    {
LABEL_61:
      __break(1u);
LABEL_62:
      abort();
    }
    if (v6 >= 0x3FFFFFFFFFFFFFFCLL)
      goto LABEL_62;
  }
  else
  {
    v6 = *(unsigned __int8 *)(v4 + 63);
  }
  v8 = 2 * v6;
  if (v6 >= 0xC)
  {
    v10 = (v8 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v10 = v8 | 7;
    v11 = v10 + 1;
    v9 = operator new(v10 + 1);
    v42[1] = (void *)(2 * v6);
    v43 = v11 | 0x8000000000000000;
    v42[0] = v9;
    goto LABEL_16;
  }
  HIBYTE(v43) = 2 * v6;
  v9 = v42;
  if (v6)
  {
LABEL_16:
    bzero(v9, 2 * v6);
    *((_BYTE *)v9 + 2 * v6) = 0;
    v12 = v42;
    if (v43 < 0)
      v12 = (void **)v42[0];
    v13 = (char *)v12 + 1;
    do
    {
      v14 = *(unsigned __int8 *)v5;
      v5 = (_QWORD *)((char *)v5 + 1);
      v13 += 2;
      --v6;
    }
    while (v6);
    goto LABEL_20;
  }
  LOBYTE(v42[0]) = 0;
LABEL_20:
  if (rtc::g_clock)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    mach_absolute_time();
  }
  rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v15, v16, v17, v18, v19, v20, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if ((SHIBYTE(v43) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v45) & 0x80000000) == 0)
      goto LABEL_27;
LABEL_45:
    operator delete(__p[0]);
    v22 = (uint64_t *)*((_QWORD *)a2 + 1);
    v23 = (uint64_t *)*((_QWORD *)a2 + 2);
    if (v22 != v23)
      goto LABEL_28;
LABEL_31:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      return;
LABEL_32:
    (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(__p);
    rtc::webrtc_logging_impl::Log("\r\n\t", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (SHIBYTE(v45) < 0)
      operator delete(__p[0]);
    return;
  }
  operator delete(v42[0]);
  if (SHIBYTE(v45) < 0)
    goto LABEL_45;
LABEL_27:
  v22 = (uint64_t *)*((_QWORD *)a2 + 1);
  v23 = (uint64_t *)*((_QWORD *)a2 + 2);
  if (v22 == v23)
    goto LABEL_31;
LABEL_28:
  v24 = v22;
  while (1)
  {
    v25 = *v24;
    if (*(_WORD *)(*v24 + 8) == 32)
      break;
    if (++v24 == v23)
      goto LABEL_31;
  }
  v33 = v22;
  while (1)
  {
    v34 = *v33;
    if (*(_WORD *)(*v33 + 8) == 22)
      break;
    if (++v33 == v23)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        return;
      goto LABEL_32;
    }
  }
  do
  {
    v35 = *v22;
    if (*(_WORD *)(*v22 + 8) == 13)
    {
      v36 = *((_QWORD *)this + 7);
      *(_DWORD *)(v36 + 1248) = 2;
      __p[0] = 0;
      __p[1] = 0;
      v45 = 0;
      v46 = &unk_24C0ACDA0;
      memset(v47, 0, sizeof(v47));
      if (__p != (void **)(v25 + 16))
      {
        if (*(char *)(v25 + 39) < 0)
        {
          std::string::__assign_no_alias<true>(__p, *(char **)(v25 + 16), *(_QWORD *)(v25 + 24));
        }
        else
        {
          *(_OWORD *)__p = *(_OWORD *)(v25 + 16);
          v45 = *(_QWORD *)(v25 + 32);
        }
      }
      *(_DWORD *)v47 = *(_DWORD *)(v25 + 48);
      *(_OWORD *)&v47[4] = *(_OWORD *)(v25 + 52);
      v48 = *(_WORD *)(v25 + 72);
      v50 = *(_BYTE *)(v25 + 80);
      v49 = *(_DWORD *)(v25 + 76);
      v37 = *(unsigned int *)(v36 + 864);
      v38 = strlen(*((const char **)&cricket::PROTO_NAMES + v37));
      v39 = 2 * (v37 != 3);
      if ((_DWORD)v37 == 1)
        v39 = 1;
      v40 = (const std::string::value_type *)(v36 + 872);
      if ((*(char *)(v36 + 895) & 0x80000000) == 0)
      {
        v41 = *(unsigned __int8 *)(v36 + 895);
LABEL_57:
        cricket::Port::AddAddress(v36, (__int128 *)(v34 + 16), (const rtc::SocketAddress *)(v34 + 16), (uint64_t)__p, (char *)&cricket::UDP_PROTOCOL_NAME, 3uLL, *((const std::string::value_type **)&cricket::PROTO_NAMES + v37), v38, &byte_208EB9246, 0, 3, v39, *(_DWORD *)(v36 + 1252), v40, v41, 1u);
        if (SHIBYTE(v45) < 0)
          operator delete(__p[0]);
        cricket::TurnPort::ScheduleRefresh(*((cricket::TurnPort **)this + 7), *(_DWORD *)(v35 + 12));
        return;
      }
      v41 = *(_QWORD *)(v36 + 880);
      if ((v41 & 0x8000000000000000) == 0)
      {
        v40 = *(const std::string::value_type **)v40;
        if (!v41 || v40)
          goto LABEL_57;
      }
      goto LABEL_61;
    }
    ++v22;
  }
  while (v22 != v23);
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    goto LABEL_32;
}

void cricket::TurnAllocateRequest::OnErrorResponse(cricket::TurnAllocateRequest *this, cricket::StunMessage *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t v11;
  void **v12;
  uint64_t v13;
  uint64_t v14;
  void **v15;
  _BYTE *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 v37;
  _QWORD *v38;
  uint64_t v39;
  unsigned int *v40;
  unsigned int v41;
  _QWORD *v42;
  void *v43;
  uint64_t v44;
  _QWORD *v45;
  unint64_t v46;
  uint64_t *v47;
  uint64_t *v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned __int8 v63;
  size_t size;
  std::string *p_p;
  uint64_t v66;
  std::string *v67;
  _QWORD *v68;
  char *v69;
  int v70;
  _QWORD *v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  void **v81;
  uint64_t v82;
  uint64_t v83;
  void **v84;
  _BYTE *v85;
  unsigned int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t *v95;
  uint64_t v96;
  uint64_t v97;
  unsigned __int8 v98;
  size_t v99;
  std::string *v100;
  __int128 *v101;
  size_t v102;
  BOOL v103;
  uint64_t *v104;
  uint64_t *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  std::string *v135;
  int v136;
  std::string *v137;
  std::string::size_type v138;
  BOOL v139;
  uint64_t v140;
  std::string *v141;
  uint64_t v142;
  std::string *v143;
  void **v145;
  uint64_t v146;
  cricket::TurnAllocateRequest *v147;
  const void **v148;
  std::string::size_type v149;
  uint64_t v150;
  unsigned int v151;
  unsigned int v152;
  unsigned int v153;
  std::string *v154;
  size_t v155;
  uint64_t *v156;
  uint64_t *v157;
  uint64_t *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  __int128 *v167;
  size_t v168;
  BOOL v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  std::string *v178;
  std::string::size_type v179;
  BOOL v180;
  uint64_t v181;
  std::string *v182;
  uint64_t v183;
  std::string *v184;
  void **v186;
  unsigned int v187;
  std::string __p;
  uint64_t (*v189)(uint64_t);
  _BYTE v190[20];
  __int16 v191;
  int v192;
  char v193;
  int v194;
  void *v195[2];
  char v196;
  void **v197;
  uint64_t v198;
  int64_t v199;

  v4 = *((_QWORD *)a2 + 1);
  v5 = *((_QWORD *)a2 + 2);
  if (v4 == v5)
  {
LABEL_4:
    v6 = 600;
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
      goto LABEL_32;
  }
  else
  {
    while (*(_WORD *)(*(_QWORD *)v4 + 8) != 9)
    {
      v4 += 8;
      if (v4 == v5)
        goto LABEL_4;
    }
    v6 = *(unsigned __int8 *)(*(_QWORD *)v4 + 13) + 100 * *(unsigned __int8 *)(*(_QWORD *)v4 + 12);
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
      goto LABEL_32;
  }
  (*(void (**)(std::string *__return_ptr))(**((_QWORD **)this + 7) + 176))(&__p);
  v7 = *((_QWORD *)this + 2);
  v8 = (_QWORD *)(v7 + 40);
  if (*(char *)(v7 + 63) < 0)
  {
    v9 = *(_QWORD *)(v7 + 48);
    if ((v9 & 0x8000000000000000) != 0)
      goto LABEL_261;
    v8 = (_QWORD *)*v8;
    if (v9 && v8 == 0)
      goto LABEL_261;
    if (v9 > 0x3FFFFFFFFFFFFFFBLL)
      goto LABEL_262;
  }
  else
  {
    v9 = *(unsigned __int8 *)(v7 + 63);
  }
  v11 = 2 * v9;
  if (v9 >= 0xC)
  {
    v13 = (v11 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v13 = v11 | 7;
    v14 = v13 + 1;
    v12 = (void **)operator new(v13 + 1);
    v198 = 2 * v9;
    v199 = v14 | 0x8000000000000000;
    v197 = v12;
  }
  else
  {
    HIBYTE(v199) = 2 * v9;
    v12 = (void **)&v197;
    if (!v9)
    {
      LOBYTE(v197) = 0;
      goto LABEL_25;
    }
  }
  bzero(v12, 2 * v9);
  *((_BYTE *)v12 + 2 * v9) = 0;
  v15 = (void **)&v197;
  if (v199 < 0)
    v15 = v197;
  v16 = (char *)v15 + 1;
  do
  {
    v17 = *(unsigned __int8 *)v8;
    v8 = (_QWORD *)((char *)v8 + 1);
    v16 += 2;
    --v9;
  }
  while (v9);
LABEL_25:
  if (rtc::g_clock)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    mach_absolute_time();
  }
  rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v18, v19, v20, v21, v22, v23, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (SHIBYTE(v199) < 0)
  {
    operator delete(v197);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_54;
LABEL_32:
    if (v6 != 300)
      goto LABEL_33;
LABEL_55:
    v47 = (uint64_t *)*((_QWORD *)a2 + 1);
    v48 = (uint64_t *)*((_QWORD *)a2 + 2);
    if (v47 == v48)
    {
      v50 = 0;
LABEL_69:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      {
        (*(void (**)(std::string *__return_ptr))(**((_QWORD **)this + 7) + 176))(&__p);
        rtc::webrtc_logging_impl::Log("\r\n\t", v55, v56, v57, v58, v59, v60, v61, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      v62 = *((_QWORD *)this + 7);
      if (!v50)
        goto LABEL_156;
      goto LABEL_73;
    }
    v49 = (uint64_t *)*((_QWORD *)a2 + 1);
    do
    {
      v50 = *v49;
      if (*(_WORD *)(*v49 + 8) == 9)
        goto LABEL_67;
      ++v49;
    }
    while (v49 != v48);
    v50 = 0;
LABEL_67:
    while (1)
    {
      v54 = *v47;
      if (*(unsigned __int16 *)(*v47 + 8) == 32803)
        break;
      if (++v47 == v48)
        goto LABEL_69;
    }
    v66 = *((_QWORD *)this + 7);
    v67 = (std::string *)(v54 + 16);
    v68 = *(_QWORD **)(v66 + 1016);
    if (v68)
    {
      v69 = (char *)(v66 + 1016);
      do
      {
        v70 = rtc::SocketAddress::operator<((uint64_t)(v68 + 4), (char *)(v54 + 16));
        v71 = v68 + 1;
        if (!v70)
        {
          v71 = v68;
          v69 = (char *)v68;
        }
        v68 = (_QWORD *)*v71;
      }
      while (*v71);
      if (v69 != (char *)(v66 + 1016) && (rtc::SocketAddress::operator<(v54 + 16, v69 + 32) & 1) == 0)
      {
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
          goto LABEL_155;
        (*(void (**)(std::string *__return_ptr, uint64_t))(*(_QWORD *)v66 + 176))(&__p, v66);
        rtc::SocketAddress::ToSensitiveNameAndAddressString((rtc::SocketAddress *)(v54 + 16), (unint64_t)&v197);
        rtc::webrtc_logging_impl::Log("\r\n\t\n\t", v121, v122, v123, v124, v125, v126, v127, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
        if (SHIBYTE(v199) < 0)
          operator delete(v197);
        goto LABEL_153;
      }
    }
    rtc::Network::GetBestIP(*(_QWORD *)(v66 + 552), (uint64_t)&__p);
    v72 = *(_DWORD *)(v54 + 48);
    if (v72 != LODWORD(__p.__r_.__value_.__r.__words[1])
      || v72 == 30
      && ((WORD2(__p.__r_.__value_.__r.__words[1]) & 0xC0FF) == 33022) != ((*(_QWORD *)(v54 + 52) & 0xC0FFLL) == 33022))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v73, v74, v75, v76, v77, v78, v79, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      goto LABEL_155;
    }
    if (rtc::SocketAddress::IsLoopbackIP((rtc::SocketAddress *)(v54 + 16)))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        goto LABEL_155;
      (*(void (**)(std::string *__return_ptr, uint64_t))(*(_QWORD *)v66 + 176))(&__p, v66);
      rtc::webrtc_logging_impl::Log("\r\n\t", v114, v115, v116, v117, v118, v119, v120, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
LABEL_153:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
LABEL_155:
      v62 = *((_QWORD *)this + 7);
      if (!v50)
      {
LABEL_156:
        *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
        __p.__r_.__value_.__s.__data_[0] = 0;
        v63 = 0;
        goto LABEL_75;
      }
LABEL_73:
      if (*(char *)(v50 + 39) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v50 + 16), *(_QWORD *)(v50 + 24));
        v63 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_75;
      }
      else
      {
        __p = *(std::string *)(v50 + 16);
        v63 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_75:
          size = v63;
          p_p = &__p;
          goto LABEL_160;
        }
      }
      size = __p.__r_.__value_.__l.__size_;
      if ((__p.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
        goto LABEL_261;
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if (__p.__r_.__value_.__l.__size_)
      {
        if (!__p.__r_.__value_.__r.__words[0])
          goto LABEL_261;
      }
LABEL_160:
      cricket::TurnPort::OnAllocateError(v62, 300, (char *)p_p, size);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        return;
      goto LABEL_161;
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    {
LABEL_167:
      v135 = (std::string *)(v66 + 792);
      v136 = *(_DWORD *)(v66 + 864);
      memset(&__p, 0, sizeof(__p));
      v189 = (uint64_t (*)(uint64_t))&unk_24C0ACDA0;
      memset(v190, 0, sizeof(v190));
      if (&__p != v67)
      {
        if (*(char *)(v54 + 39) < 0)
        {
          std::string::__assign_no_alias<true>(&__p, *(char **)(v54 + 16), *(_QWORD *)(v54 + 24));
        }
        else
        {
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v54 + 32);
        }
      }
      *(_DWORD *)v190 = *(_DWORD *)(v54 + 48);
      *(_OWORD *)&v190[4] = *(_OWORD *)(v54 + 52);
      v191 = *(_WORD *)(v54 + 72);
      v193 = *(_BYTE *)(v54 + 80);
      v192 = *(_DWORD *)(v54 + 76);
      v194 = v136;
      if (v135 != &__p)
      {
        if (*(char *)(v66 + 815) < 0)
        {
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v154 = &__p;
          else
            v154 = (std::string *)__p.__r_.__value_.__r.__words[0];
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v155 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          else
            v155 = __p.__r_.__value_.__l.__size_;
          std::string::__assign_no_alias<false>((std::string *)(v66 + 792), (const std::string::value_type *)v154, v155);
        }
        else if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>((_QWORD *)(v66 + 792), __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        }
        else
        {
          *(_OWORD *)&v135->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(_QWORD *)(v66 + 808) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
        }
      }
      *(_DWORD *)(v66 + 824) = *(_DWORD *)v190;
      *(_OWORD *)(v66 + 828) = *(_OWORD *)&v190[4];
      *(_WORD *)(v66 + 848) = v191;
      *(_BYTE *)(v66 + 856) = v193;
      *(_DWORD *)(v66 + 852) = v192;
      *(_DWORD *)(v66 + 864) = v194;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      std::__tree<rtc::SocketAddress>::__emplace_unique_key_args<rtc::SocketAddress,rtc::SocketAddress const&>((uint64_t **)(v66 + 1008), (char *)(v66 + 792), v66 + 792);
      v156 = (uint64_t *)*((_QWORD *)a2 + 1);
      v157 = (uint64_t *)*((_QWORD *)a2 + 2);
      if (v156 != v157)
      {
        v158 = (uint64_t *)*((_QWORD *)a2 + 1);
        do
        {
          v159 = *v158;
          if (*(_WORD *)(*v158 + 8) == 20)
          {
            if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
            {
              (*(void (**)(std::string *__return_ptr))(**((_QWORD **)this + 7) + 176))(&__p);
              rtc::webrtc_logging_impl::Log("\r\n\t", v160, v161, v162, v163, v164, v165, v166, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__p.__r_.__value_.__l.__data_);
            }
            v167 = *(__int128 **)(v159 + 16);
            v168 = *(unsigned __int16 *)(v159 + 10);
            if (v167)
              v169 = 1;
            else
              v169 = (_DWORD)v168 == 0;
            if (v169)
            {
              cricket::TurnPort::set_realm(*((_QWORD *)this + 7), v167, v168);
              v156 = (uint64_t *)*((_QWORD *)a2 + 1);
              v157 = (uint64_t *)*((_QWORD *)a2 + 2);
              goto LABEL_233;
            }
            goto LABEL_261;
          }
          ++v158;
        }
        while (v158 != v157);
        while (1)
        {
LABEL_233:
          if (v156 == v157)
            goto LABEL_258;
          v170 = *v156;
          if (*(_WORD *)(*v156 + 8) == 21)
            break;
          ++v156;
        }
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
        {
          (*(void (**)(std::string *__return_ptr))(**((_QWORD **)this + 7) + 176))(&__p);
          rtc::webrtc_logging_impl::Log("\r\n\t", v171, v172, v173, v174, v175, v176, v177, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
        }
        v178 = *(std::string **)(v170 + 16);
        v179 = *(unsigned __int16 *)(v170 + 10);
        if (v178)
          v180 = 1;
        else
          v180 = (_DWORD)v179 == 0;
        if (v180)
        {
          v181 = *((_QWORD *)this + 7);
          if (v179 > 0x16)
          {
            v183 = (v179 | 7) == 0x17 ? ((unsigned __int16)v179 & 0xFFF8) + 8 : v179 | 7;
            v182 = (std::string *)operator new(v183 + 1);
            __p.__r_.__value_.__l.__size_ = v179;
            __p.__r_.__value_.__r.__words[2] = v183 - 0x7FFFFFFFFFFFFFFFLL;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v182;
          }
          else
          {
            *((_BYTE *)&__p.__r_.__value_.__s + 23) = v179;
            v182 = &__p;
          }
          v184 = (std::string *)((char *)v182 + v179);
          if (v182 > v178 || v184 <= v178)
          {
            if ((_DWORD)v179)
              memmove(v182, v178, v179);
            v184->__r_.__value_.__s.__data_[0] = 0;
            v186 = (void **)(v181 + 1168);
            if (*(char *)(v181 + 1191) < 0)
              operator delete(*v186);
            *(_OWORD *)v186 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
            *(_QWORD *)(v181 + 1184) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
            goto LABEL_258;
          }
        }
LABEL_261:
        __break(1u);
        goto LABEL_262;
      }
LABEL_258:
      v38 = (_QWORD *)*((_QWORD *)this + 7);
      v39 = (*(uint64_t (**)(_QWORD *))(*v38 + 208))(v38);
      v40 = (unsigned int *)v38[162];
      if (v40)
      {
        do
          v187 = __ldxr(v40);
        while (__stxr(v187 + 1, v40));
      }
      v42 = (_QWORD *)operator new();
      v43 = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnAllocateRequest::OnTryAlternate(cricket::StunMessage *,int)::$_0 &&>;
LABEL_49:
      *v42 = v40;
      v42[1] = v38;
      v42[3] = absl::internal_any_invocable::LocalManagerTrivial;
      v42[4] = v43;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v42;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)_ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
      v189 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
      (*(void (**)(uint64_t, std::string *, void ***, void **))(*(_QWORD *)v39 + 8))(v39, &__p, &v197, v195);
      ((void (*)(uint64_t, std::string *, std::string *))__p.__r_.__value_.__r.__words[2])(1, &__p, &__p);
      return;
    }
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(_QWORD *)v66 + 176))(&__p, v66);
    rtc::SocketAddress::ToSensitiveNameAndAddressString((rtc::SocketAddress *)(v66 + 792), (unint64_t)&v197);
    rtc::SocketAddress::ToSensitiveNameAndAddressString((rtc::SocketAddress *)(v54 + 16), (unint64_t)v195);
    rtc::webrtc_logging_impl::Log("\r\n\t\n\t\n\t", v128, v129, v130, v131, v132, v133, v134, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (v196 < 0)
    {
      operator delete(v195[0]);
      if ((SHIBYTE(v199) & 0x80000000) == 0)
      {
LABEL_166:
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_167;
LABEL_213:
        operator delete(__p.__r_.__value_.__l.__data_);
        goto LABEL_167;
      }
    }
    else if ((SHIBYTE(v199) & 0x80000000) == 0)
    {
      goto LABEL_166;
    }
    operator delete(v197);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_167;
    goto LABEL_213;
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_32;
LABEL_54:
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v6 == 300)
    goto LABEL_55;
LABEL_33:
  if (v6 == 437)
  {
    v38 = (_QWORD *)*((_QWORD *)this + 7);
    v39 = (*(uint64_t (**)(_QWORD *))(*v38 + 208))(v38);
    v40 = (unsigned int *)v38[162];
    if (v40)
    {
      do
        v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
    }
    v42 = (_QWORD *)operator new();
    v43 = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnAllocateRequest::OnErrorResponse(cricket::StunMessage *)::$_0 &&>;
    goto LABEL_49;
  }
  if (v6 != 401)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      goto LABEL_120;
    (*(void (**)(std::string *__return_ptr))(**((_QWORD **)this + 7) + 176))(&__p);
    v44 = *((_QWORD *)this + 2);
    v45 = (_QWORD *)(v44 + 40);
    if ((*(char *)(v44 + 63) & 0x80000000) == 0)
    {
      v46 = *(unsigned __int8 *)(v44 + 63);
      goto LABEL_101;
    }
    v46 = *(_QWORD *)(v44 + 48);
    if ((v46 & 0x8000000000000000) != 0)
      goto LABEL_261;
    v45 = (_QWORD *)*v45;
    if (v46)
    {
      if (!v45)
        goto LABEL_261;
    }
    if (v46 <= 0x3FFFFFFFFFFFFFFBLL)
    {
LABEL_101:
      v80 = 2 * v46;
      if (v46 >= 0xC)
      {
        v82 = (v80 & 0x7FFFFFFFFFFFFFF8) + 8;
        if ((v80 | 7) != 0x17)
          v82 = v80 | 7;
        v83 = v82 + 1;
        v81 = (void **)operator new(v82 + 1);
        v198 = 2 * v46;
        v199 = v83 | 0x8000000000000000;
        v197 = v81;
      }
      else
      {
        HIBYTE(v199) = 2 * v46;
        v81 = (void **)&v197;
        if (!v46)
        {
          LOBYTE(v197) = 0;
LABEL_111:
          if (rtc::g_clock)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
          }
          else
          {
            if (!dword_253EA791C)
              mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
            mach_absolute_time();
          }
          rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v87, v88, v89, v90, v91, v92, v93, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
          if (SHIBYTE(v199) < 0)
            operator delete(v197);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
LABEL_120:
          v94 = (uint64_t *)*((_QWORD *)a2 + 1);
          v95 = (uint64_t *)*((_QWORD *)a2 + 2);
          if (v94 == v95)
          {
LABEL_123:
            v97 = *((_QWORD *)this + 7);
            *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
            __p.__r_.__value_.__s.__data_[0] = 0;
            v98 = 0;
          }
          else
          {
            while (1)
            {
              v96 = *v94;
              if (*(_WORD *)(*v94 + 8) == 9)
                break;
              if (++v94 == v95)
                goto LABEL_123;
            }
            v97 = *((_QWORD *)this + 7);
            if (*(char *)(v96 + 39) < 0)
            {
              std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v96 + 16), *(_QWORD *)(v96 + 24));
              v98 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                goto LABEL_127;
            }
            else
            {
              __p = *(std::string *)(v96 + 16);
              v98 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              {
LABEL_127:
                v99 = __p.__r_.__value_.__l.__size_;
                if ((__p.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
                  goto LABEL_261;
                v100 = (std::string *)__p.__r_.__value_.__r.__words[0];
                if (__p.__r_.__value_.__l.__size_)
                {
                  if (!__p.__r_.__value_.__r.__words[0])
                    goto LABEL_261;
                }
LABEL_130:
                cricket::TurnPort::OnAllocateError(v97, v6, (char *)v100, v99);
                if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  return;
                goto LABEL_161;
              }
            }
          }
          v99 = v98;
          v100 = &__p;
          goto LABEL_130;
        }
      }
      bzero(v81, 2 * v46);
      *((_BYTE *)v81 + 2 * v46) = 0;
      v84 = (void **)&v197;
      if (v199 < 0)
        v84 = v197;
      v85 = (char *)v84 + 1;
      do
      {
        v86 = *(unsigned __int8 *)v45;
        v45 = (_QWORD *)((char *)v45 + 1);
        v85 += 2;
        --v46;
      }
      while (v46);
      goto LABEL_111;
    }
LABEL_262:
    abort();
  }
  v25 = *((_QWORD *)this + 7);
  if (*(char *)(v25 + 1215) < 0)
  {
    if (*(_QWORD *)(v25 + 1200))
      goto LABEL_37;
LABEL_61:
    v51 = (uint64_t *)*((_QWORD *)a2 + 1);
    v52 = (uint64_t *)*((_QWORD *)a2 + 2);
    if (v51 == v52)
    {
LABEL_64:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        return;
    }
    else
    {
      while (1)
      {
        v53 = *v51;
        if (*(_WORD *)(*v51 + 8) == 20)
          break;
        if (++v51 == v52)
          goto LABEL_64;
      }
      v101 = *(__int128 **)(v53 + 16);
      v102 = *(unsigned __int16 *)(v53 + 10);
      if (v101)
        v103 = 1;
      else
        v103 = (_DWORD)v102 == 0;
      if (!v103)
        goto LABEL_261;
      cricket::TurnPort::set_realm(v25, v101, v102);
      v104 = (uint64_t *)*((_QWORD *)a2 + 1);
      v105 = (uint64_t *)*((_QWORD *)a2 + 2);
      if (v104 != v105)
      {
        while (1)
        {
          v106 = *v104;
          if (*(_WORD *)(*v104 + 8) == 21)
            break;
          if (++v104 == v105)
            goto LABEL_140;
        }
        v137 = *(std::string **)(v106 + 16);
        v138 = *(unsigned __int16 *)(v106 + 10);
        if (v137)
          v139 = 1;
        else
          v139 = (_DWORD)v138 == 0;
        if (!v139)
          goto LABEL_261;
        v140 = *((_QWORD *)this + 7);
        if (v138 > 0x16)
        {
          v142 = (v138 | 7) == 0x17 ? ((unsigned __int16)v138 & 0xFFF8) + 8 : v138 | 7;
          v141 = (std::string *)operator new(v142 + 1);
          __p.__r_.__value_.__l.__size_ = v138;
          __p.__r_.__value_.__r.__words[2] = v142 - 0x7FFFFFFFFFFFFFFFLL;
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v141;
        }
        else
        {
          *((_BYTE *)&__p.__r_.__value_.__s + 23) = *(_WORD *)(v106 + 10);
          v141 = &__p;
        }
        v143 = (std::string *)((char *)v141 + v138);
        if (v141 <= v137 && v143 > v137)
          goto LABEL_261;
        if ((_DWORD)v138)
          memmove(v141, v137, v138);
        v143->__r_.__value_.__s.__data_[0] = 0;
        v145 = (void **)(v140 + 1168);
        if (*(char *)(v140 + 1191) < 0)
          operator delete(*v145);
        *(_OWORD *)v145 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *(_QWORD *)(v140 + 1184) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
        v146 = *((_QWORD *)this + 7);
        v147 = (cricket::TurnAllocateRequest *)operator new();
        cricket::TurnAllocateRequest::TurnAllocateRequest(v147, *((cricket::TurnPort **)this + 7));
        v148 = (const void **)(*((_QWORD *)v147 + 2) + 40);
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v147;
        std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>(v146 + 1088, v148, (uint64_t)v148, (uint64_t *)&__p);
        v149 = __p.__r_.__value_.__r.__words[0];
        __p.__r_.__value_.__r.__words[0] = 0;
        if (v149)
          (*(void (**)(std::string::size_type))(*(_QWORD *)v149 + 8))(v149);
        v150 = *((_QWORD *)v147 + 5);
        if (v150)
        {
          do
            v151 = __ldxr((unsigned int *)v150);
          while (__stxr(v151 + 1, (unsigned int *)v150));
          *(_BYTE *)(v150 + 4) = 1;
          do
          {
            v152 = __ldaxr((unsigned int *)v150);
            v153 = v152 - 1;
          }
          while (__stlxr(v153, (unsigned int *)v150));
          if (!v153)
            MEMORY[0x20BD0ADEC]();
        }
        else
        {
          MEMORY[4] = 1;
        }
        cricket::StunRequest::SendInternal(v147);
        return;
      }
LABEL_140:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        return;
    }
    (*(void (**)(std::string *__return_ptr))(**((_QWORD **)this + 7) + 176))(&__p);
    rtc::webrtc_logging_impl::Log("\r\n\t", v107, v108, v109, v110, v111, v112, v113, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_161;
  }
  if (!*(_BYTE *)(v25 + 1215))
    goto LABEL_61;
LABEL_37:
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
  {
    (*(void (**)(std::string *__return_ptr))(**((_QWORD **)this + 7) + 176))(&__p);
    rtc::webrtc_logging_impl::Log("\r\n\t", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  v33 = (uint64_t *)*((_QWORD *)a2 + 1);
  v34 = (uint64_t *)*((_QWORD *)a2 + 2);
  if (v33 == v34)
  {
LABEL_43:
    v36 = *((_QWORD *)this + 7);
    *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
    v37 = 0;
    goto LABEL_44;
  }
  while (1)
  {
    v35 = *v33;
    if (*(_WORD *)(*v33 + 8) == 9)
      break;
    if (++v33 == v34)
      goto LABEL_43;
  }
  v36 = *((_QWORD *)this + 7);
  if (*(char *)(v35 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v35 + 16), *(_QWORD *)(v35 + 24));
    v37 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_92;
LABEL_44:
    cricket::TurnPort::OnAllocateError(v36, 401, (char *)&__p, v37);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_161;
  }
  __p = *(std::string *)(v35 + 16);
  v37 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_44;
LABEL_92:
  if ((__p.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0
    || __p.__r_.__value_.__l.__size_ && !__p.__r_.__value_.__r.__words[0])
  {
    goto LABEL_261;
  }
  cricket::TurnPort::OnAllocateError(v36, 401, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
LABEL_161:
    operator delete(__p.__r_.__value_.__l.__data_);
}

void cricket::TurnAllocateRequest::OnTimeout(cricket::TurnAllocateRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  _BYTE *v18;
  unsigned int v19;
  void *__p[2];
  int64_t v21;
  void *v22;
  char v23;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
  {
    (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(&v22);
    v9 = *((_QWORD *)this + 2);
    v10 = (_QWORD *)(v9 + 40);
    if ((*(char *)(v9 + 63) & 0x80000000) == 0)
    {
      v11 = *(unsigned __int8 *)(v9 + 63);
      goto LABEL_10;
    }
    v11 = *(_QWORD *)(v9 + 48);
    if ((v11 & 0x8000000000000000) != 0 || ((v10 = (_QWORD *)*v10, v11) ? (v12 = v10 == 0) : (v12 = 0), v12))
    {
      __break(1u);
    }
    else if (v11 < 0x3FFFFFFFFFFFFFFCLL)
    {
LABEL_10:
      v13 = 2 * v11;
      if (v11 >= 0xC)
      {
        v15 = (v13 & 0x7FFFFFFFFFFFFFF8) + 8;
        if ((v13 | 7) != 0x17)
          v15 = v13 | 7;
        v16 = v15 + 1;
        v14 = operator new(v15 + 1);
        __p[1] = (void *)(2 * v11);
        v21 = v16 | 0x8000000000000000;
        __p[0] = v14;
      }
      else
      {
        HIBYTE(v21) = 2 * v11;
        v14 = __p;
        if (!v11)
        {
          LOBYTE(__p[0]) = 0;
          goto LABEL_20;
        }
      }
      bzero(v14, 2 * v11);
      *((_BYTE *)v14 + 2 * v11) = 0;
      v17 = __p;
      if (v21 < 0)
        v17 = (void **)__p[0];
      v18 = (char *)v17 + 1;
      do
      {
        v19 = *(unsigned __int8 *)v10;
        v10 = (_QWORD *)((char *)v10 + 1);
        v18 += 2;
        --v11;
      }
      while (v11);
LABEL_20:
      rtc::webrtc_logging_impl::Log("\r\n\t\n\t", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (SHIBYTE(v21) < 0)
      {
        operator delete(__p[0]);
        if ((v23 & 0x80000000) == 0)
          goto LABEL_22;
      }
      else if ((v23 & 0x80000000) == 0)
      {
        goto LABEL_22;
      }
      operator delete(v22);
      goto LABEL_22;
    }
    abort();
  }
LABEL_22:
  cricket::TurnPort::OnAllocateError(*((_QWORD *)this + 7), 701, "TURN allocate request timed out.", 0x20uLL);
}

cricket::TurnRefreshRequest *cricket::TurnRefreshRequest::TurnRefreshRequest(cricket::TurnRefreshRequest *this, cricket::TurnPort *a2, int a3)
{
  char *v6;
  cricket::StunMessage *v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  cricket::TurnRefreshRequest *result;
  uint64_t *v14;
  _QWORD *v15;
  uint64_t v16;
  void (***v17)(_QWORD);
  uint64_t v18;

  v6 = (char *)a2 + 1080;
  v7 = (cricket::StunMessage *)operator new();
  cricket::StunMessage::StunMessage(v7, 4);
  *v8 = &off_24C0C1660;
  *(_QWORD *)this = &off_24C0C1B10;
  *((_QWORD *)this + 1) = v6;
  *((_QWORD *)this + 2) = v8;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_BYTE *)this + 36) = 0;
  v9 = operator new();
  *(_DWORD *)v9 = 0;
  *(_BYTE *)(v9 + 4) = 0;
  do
    v10 = __ldxr((unsigned int *)v9);
  while (__stxr(v10 + 1, (unsigned int *)v9));
  *((_QWORD *)this + 5) = v9;
  *((_BYTE *)this + 48) = 1;
  *(_QWORD *)this = &off_24C0C2BA8;
  *((_QWORD *)this + 7) = a2;
  v11 = *((_QWORD *)this + 2);
  if ((a3 & 0x80000000) == 0)
  {
    v12 = operator new();
    *(_QWORD *)v12 = &off_24C0C1520;
    *(_QWORD *)(v12 + 8) = 262157;
    v18 = v12;
    result = (cricket::TurnRefreshRequest *)cricket::StunAttribute::SetOwner((cricket::StunAttribute *)v12, (cricket::StunMessage *)v11);
    *(_WORD *)(v11 + 34) += ((*(_WORD *)(v12 + 10) + 3) & 0xFFFC) + 4;
    v14 = *(uint64_t **)(v11 + 16);
    if ((unint64_t)v14 >= *(_QWORD *)(v11 + 24))
    {
      v15 = std::vector<std::unique_ptr<webrtc::PushSincResampler>>::__push_back_slow_path<std::unique_ptr<webrtc::PushSincResampler>>((_QWORD *)(v11 + 8), &v18);
      v16 = v18;
      *(_QWORD *)(v11 + 16) = v15;
      v18 = 0;
      if (v16)
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
    }
    else
    {
      if (!v14)
      {
        __break(1u);
        return result;
      }
      *v14 = v12;
      *(_QWORD *)(v11 + 16) = v14 + 1;
      v18 = 0;
    }
  }
  cricket::TurnPort::AddRequestAuthInfo(*((cricket::TurnPort **)this + 7), (cricket::StunMessage *)v11);
  v17 = *(void (****)(_QWORD))(*((_QWORD *)this + 7) + 1264);
  if (v17)
    (**v17)(v17);
  return this;
}

void cricket::TurnRefreshRequest::OnSent(cricket::TurnRefreshRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  _BYTE *v18;
  unsigned int v19;
  int v20;
  int v21;
  void *__p[2];
  int64_t v23;
  void *v24;
  char v25;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    goto LABEL_22;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(&v24);
  v9 = *((_QWORD *)this + 2);
  v10 = (_QWORD *)(v9 + 40);
  if ((*(char *)(v9 + 63) & 0x80000000) == 0)
  {
    v11 = *(unsigned __int8 *)(v9 + 63);
    goto LABEL_10;
  }
  v11 = *(_QWORD *)(v9 + 48);
  if ((v11 & 0x8000000000000000) != 0 || ((v10 = (_QWORD *)*v10, v11) ? (v12 = v10 == 0) : (v12 = 0), v12))
  {
    __break(1u);
LABEL_29:
    abort();
  }
  if (v11 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_29;
LABEL_10:
  v13 = 2 * v11;
  if (v11 >= 0xC)
  {
    v15 = (v13 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v15 = v13 | 7;
    v16 = v15 + 1;
    v14 = operator new(v15 + 1);
    __p[1] = (void *)(2 * v11);
    v23 = v16 | 0x8000000000000000;
    __p[0] = v14;
  }
  else
  {
    HIBYTE(v23) = 2 * v11;
    v14 = __p;
    if (!v11)
    {
      LOBYTE(__p[0]) = 0;
      goto LABEL_20;
    }
  }
  bzero(v14, 2 * v11);
  *((_BYTE *)v14 + 2 * v11) = 0;
  v17 = __p;
  if (v23 < 0)
    v17 = (void **)__p[0];
  v18 = (char *)v17 + 1;
  do
  {
    v19 = *(unsigned __int8 *)v10;
    v10 = (_QWORD *)((char *)v10 + 1);
    v18 += 2;
    --v11;
  }
  while (v11);
LABEL_20:
  rtc::webrtc_logging_impl::Log("\r\n\t\n", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (SHIBYTE(v23) < 0)
  {
    operator delete(__p[0]);
    if (v25 < 0)
      goto LABEL_26;
LABEL_22:
    v20 = *((_DWORD *)this + 8);
    *((_DWORD *)this + 8) = v20 + 1;
    if (v20 < 8)
      return;
    goto LABEL_23;
  }
  if ((v25 & 0x80000000) == 0)
    goto LABEL_22;
LABEL_26:
  operator delete(v24);
  v21 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = v21 + 1;
  if (v21 >= 8)
LABEL_23:
    *((_BYTE *)this + 36) = 1;
}

void cricket::TurnRefreshRequest::OnResponse(cricket::TurnRefreshRequest *this, cricket::StunMessage *a2)
{
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  _BYTE *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int *v35;
  unsigned int v36;
  _QWORD *v37;
  char v38;
  void *v39[2];
  int64_t v40;
  void *__p[2];
  uint64_t (*v42)(uint64_t, uint64_t *, void **);
  uint64_t (*v43)(uint64_t);

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    goto LABEL_27;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(__p);
  v4 = *((_QWORD *)this + 2);
  v5 = (_QWORD *)(v4 + 40);
  if ((*(char *)(v4 + 63) & 0x80000000) == 0)
  {
    v6 = *(unsigned __int8 *)(v4 + 63);
    goto LABEL_10;
  }
  v6 = *(_QWORD *)(v4 + 48);
  if ((v6 & 0x8000000000000000) != 0 || ((v5 = (_QWORD *)*v5, v6) ? (v7 = v5 == 0) : (v7 = 0), v7))
  {
    __break(1u);
LABEL_45:
    abort();
  }
  if (v6 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_45;
LABEL_10:
  v8 = 2 * v6;
  if (v6 >= 0xC)
  {
    v10 = (v8 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v10 = v8 | 7;
    v11 = v10 + 1;
    v9 = operator new(v10 + 1);
    v39[1] = (void *)(2 * v6);
    v40 = v11 | 0x8000000000000000;
    v39[0] = v9;
  }
  else
  {
    HIBYTE(v40) = 2 * v6;
    v9 = v39;
    if (!v6)
    {
      LOBYTE(v39[0]) = 0;
      goto LABEL_20;
    }
  }
  bzero(v9, 2 * v6);
  *((_BYTE *)v9 + 2 * v6) = 0;
  v12 = v39;
  if (v40 < 0)
    v12 = (void **)v39[0];
  v13 = (char *)v12 + 1;
  do
  {
    v14 = *(unsigned __int8 *)v5;
    v5 = (_QWORD *)((char *)v5 + 1);
    v13 += 2;
    --v6;
  }
  while (v6);
LABEL_20:
  if (rtc::g_clock)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    mach_absolute_time();
  }
  rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v15, v16, v17, v18, v19, v20, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (SHIBYTE(v40) < 0)
  {
    operator delete(v39[0]);
    if (SHIBYTE(v42) < 0)
      goto LABEL_38;
LABEL_27:
    v22 = *((_QWORD *)a2 + 1);
    v23 = *((_QWORD *)a2 + 2);
    if (v22 != v23)
      goto LABEL_28;
    goto LABEL_30;
  }
  if ((SHIBYTE(v42) & 0x80000000) == 0)
    goto LABEL_27;
LABEL_38:
  operator delete(__p[0]);
  v22 = *((_QWORD *)a2 + 1);
  v23 = *((_QWORD *)a2 + 2);
  if (v22 == v23)
  {
LABEL_30:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(__p);
      rtc::webrtc_logging_impl::Log("\r\n\t", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (SHIBYTE(v42) < 0)
        operator delete(__p[0]);
    }
    return;
  }
LABEL_28:
  while (*(_WORD *)(*(_QWORD *)v22 + 8) != 13)
  {
    v22 += 8;
    if (v22 == v23)
      goto LABEL_30;
  }
  v31 = *(_DWORD *)(*(_QWORD *)v22 + 12);
  v32 = (_QWORD *)*((_QWORD *)this + 7);
  if (v31)
  {
    cricket::TurnPort::ScheduleRefresh(*((cricket::TurnPort **)this + 7), v31);
    v33 = *(_QWORD *)(*((_QWORD *)this + 7) + 1304);
    if (!v33)
      return;
    goto LABEL_35;
  }
  v34 = (*(uint64_t (**)(_QWORD))(*v32 + 208))(*((_QWORD *)this + 7));
  v35 = (unsigned int *)v32[162];
  if (v35)
  {
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
  }
  v37 = (_QWORD *)operator new();
  *v37 = v35;
  v37[1] = v32;
  v37[3] = absl::internal_any_invocable::LocalManagerTrivial;
  v37[4] = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnRefreshRequest::OnResponse(cricket::StunMessage *)::$_0 &&>;
  __p[0] = v37;
  v42 = (uint64_t (*)(uint64_t, uint64_t *, void **))_ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
  v43 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  (*(void (**)(uint64_t, void **, void **, char *))(*(_QWORD *)v34 + 8))(v34, __p, v39, &v38);
  v42(1, (uint64_t *)__p, __p);
  v33 = *(_QWORD *)(*((_QWORD *)this + 7) + 1304);
  if (v33)
LABEL_35:
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v33 + 24))(v33, 0);
}

void cricket::TurnRefreshRequest::OnErrorResponse(cricket::TurnRefreshRequest *this, cricket::StunMessage *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  cricket::TurnRefreshRequest *v11;
  const void **v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  BOOL v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  void **v23;
  _BYTE *v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  unsigned int *v35;
  unsigned int v36;
  _QWORD *v37;
  uint64_t v38;
  void *__p[2];
  int64_t v40;
  void *v41[2];
  char v42;
  char v43;
  void **v44;
  uint64_t *v45;
  uint64_t v46[2];
  uint64_t (*v47)(uint64_t, uint64_t *, uint64_t *);
  uint64_t (*v48)(uint64_t);

  v3 = *((_QWORD *)a2 + 1);
  v4 = *((_QWORD *)a2 + 2);
  if (v3 == v4)
  {
LABEL_4:
    v5 = 600;
    goto LABEL_5;
  }
  while (*(_WORD *)(*(_QWORD *)v3 + 8) != 9)
  {
    v3 += 8;
    if (v3 == v4)
      goto LABEL_4;
  }
  v5 = *(unsigned __int8 *)(*(_QWORD *)v3 + 13) + 100 * *(unsigned __int8 *)(*(_QWORD *)v3 + 12);
  if ((_DWORD)v5 != 438)
  {
LABEL_5:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
    {
LABEL_41:
      v33 = (_QWORD *)*((_QWORD *)this + 7);
      v34 = (*(uint64_t (**)(_QWORD *))(*v33 + 208))(v33);
      v35 = (unsigned int *)v33[162];
      if (v35)
      {
        do
          v36 = __ldxr(v35);
        while (__stxr(v36 + 1, v35));
      }
      v37 = (_QWORD *)operator new();
      *v37 = v35;
      v37[1] = v33;
      v37[3] = absl::internal_any_invocable::LocalManagerTrivial;
      v37[4] = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnPort::OnRefreshError(void)::$_0 &&>;
      v46[0] = (uint64_t)v37;
      v47 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
      v48 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
      (*(void (**)(uint64_t, uint64_t *, void **, void **))(*(_QWORD *)v34 + 8))(v34, v46, v41, __p);
      v47(1, v46, v46);
      v38 = *(_QWORD *)(*((_QWORD *)this + 7) + 1304);
      if (v38)
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v38 + 24))(v38, v5);
      return;
    }
    v46[0] = (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc";
    v46[1] = 12690;
    v47 = (uint64_t (*)(uint64_t, uint64_t *, uint64_t *))&v43;
    (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(v41);
    v44 = v41;
    v45 = v46;
    v6 = *((_QWORD *)this + 2);
    v7 = (_QWORD *)(v6 + 40);
    if ((*(char *)(v6 + 63) & 0x80000000) == 0)
    {
      v8 = *(unsigned __int8 *)(v6 + 63);
      goto LABEL_24;
    }
    v8 = *(_QWORD *)(v6 + 48);
    if ((v8 & 0x8000000000000000) != 0 || ((v7 = (_QWORD *)*v7, v8) ? (v18 = v7 == 0) : (v18 = 0), v18))
    {
      __break(1u);
    }
    else if (v8 < 0x3FFFFFFFFFFFFFFCLL)
    {
LABEL_24:
      v19 = 2 * v8;
      if (v8 >= 0xC)
      {
        v21 = (v19 & 0x7FFFFFFFFFFFFFF8) + 8;
        if ((v19 | 7) != 0x17)
          v21 = v19 | 7;
        v22 = v21 + 1;
        v20 = operator new(v21 + 1);
        __p[1] = (void *)(2 * v8);
        v40 = v22 | 0x8000000000000000;
        __p[0] = v20;
      }
      else
      {
        HIBYTE(v40) = 2 * v8;
        v20 = __p;
        if (!v8)
        {
          LOBYTE(__p[0]) = 0;
          goto LABEL_34;
        }
      }
      bzero(v20, 2 * v8);
      *((_BYTE *)v20 + 2 * v8) = 0;
      v23 = __p;
      if (v40 < 0)
        v23 = (void **)__p[0];
      v24 = (char *)v23 + 1;
      do
      {
        v25 = *(unsigned __int8 *)v7;
        v7 = (_QWORD *)((char *)v7 + 1);
        v24 += 2;
        --v8;
      }
      while (v8);
LABEL_34:
      if (rtc::g_clock)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
      }
      else
      {
        if (!dword_253EA791C)
          mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
        mach_absolute_time();
      }
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v26, v27, v28, v29, v30, v31, v32, *v45);
      if (SHIBYTE(v40) < 0)
      {
        operator delete(__p[0]);
        if ((v42 & 0x80000000) == 0)
          goto LABEL_41;
      }
      else if ((v42 & 0x80000000) == 0)
      {
        goto LABEL_41;
      }
      operator delete(v41[0]);
      goto LABEL_41;
    }
    abort();
  }
  cricket::TurnPort::UpdateNonce(*((cricket::TurnPort **)this + 7), a2);
  if (v9)
  {
    v10 = *((_QWORD *)this + 7);
    v11 = (cricket::TurnRefreshRequest *)operator new();
    cricket::TurnRefreshRequest::TurnRefreshRequest(v11, *((cricket::TurnPort **)this + 7), -1);
    v12 = (const void **)(*((_QWORD *)v11 + 2) + 40);
    v46[0] = (uint64_t)v11;
    std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>(v10 + 1088, v12, (uint64_t)v12, v46);
    v13 = v46[0];
    v46[0] = 0;
    if (v13)
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
    v14 = *((_QWORD *)v11 + 5);
    if (v14)
    {
      do
        v15 = __ldxr((unsigned int *)v14);
      while (__stxr(v15 + 1, (unsigned int *)v14));
      *(_BYTE *)(v14 + 4) = 1;
      do
      {
        v16 = __ldaxr((unsigned int *)v14);
        v17 = v16 - 1;
      }
      while (__stlxr(v17, (unsigned int *)v14));
      if (!v17)
        MEMORY[0x20BD0ADEC]();
    }
    else
    {
      MEMORY[4] = 1;
    }
    cricket::StunRequest::SendInternal(v11);
  }
}

uint64_t cricket::TurnRefreshRequest::OnTimeout(cricket::TurnRefreshRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  _BYTE *v18;
  unsigned int v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  _QWORD *v24;
  void *__p[2];
  int64_t v27;
  char v28;
  void *v29[2];
  uint64_t (*v30)(uint64_t, uint64_t *, void **);
  uint64_t (*v31)(uint64_t);

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
    goto LABEL_22;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(v29);
  v9 = *((_QWORD *)this + 2);
  v10 = (_QWORD *)(v9 + 40);
  if ((*(char *)(v9 + 63) & 0x80000000) == 0)
  {
    v11 = *(unsigned __int8 *)(v9 + 63);
    goto LABEL_10;
  }
  v11 = *(_QWORD *)(v9 + 48);
  if ((v11 & 0x8000000000000000) != 0 || ((v10 = (_QWORD *)*v10, v11) ? (v12 = v10 == 0) : (v12 = 0), v12))
  {
    __break(1u);
LABEL_28:
    abort();
  }
  if (v11 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_28;
LABEL_10:
  v13 = 2 * v11;
  if (v11 >= 0xC)
  {
    v15 = (v13 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v15 = v13 | 7;
    v16 = v15 + 1;
    v14 = operator new(v15 + 1);
    __p[1] = (void *)(2 * v11);
    v27 = v16 | 0x8000000000000000;
    __p[0] = v14;
    goto LABEL_16;
  }
  HIBYTE(v27) = 2 * v11;
  v14 = __p;
  if (v11)
  {
LABEL_16:
    bzero(v14, 2 * v11);
    *((_BYTE *)v14 + 2 * v11) = 0;
    v17 = __p;
    if (v27 < 0)
      v17 = (void **)__p[0];
    v18 = (char *)v17 + 1;
    do
    {
      v19 = *(unsigned __int8 *)v10;
      v10 = (_QWORD *)((char *)v10 + 1);
      v18 += 2;
      --v11;
    }
    while (v11);
    goto LABEL_20;
  }
  LOBYTE(__p[0]) = 0;
LABEL_20:
  rtc::webrtc_logging_impl::Log("\r\n\t\n", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (SHIBYTE(v27) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v30) & 0x80000000) == 0)
      goto LABEL_22;
  }
  else if ((SHIBYTE(v30) & 0x80000000) == 0)
  {
    goto LABEL_22;
  }
  operator delete(v29[0]);
LABEL_22:
  v20 = (_QWORD *)*((_QWORD *)this + 7);
  v21 = (*(uint64_t (**)(_QWORD *))(*v20 + 208))(v20);
  v22 = (unsigned int *)v20[162];
  if (v22)
  {
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }
  v24 = (_QWORD *)operator new();
  *v24 = v22;
  v24[1] = v20;
  v24[3] = absl::internal_any_invocable::LocalManagerTrivial;
  v24[4] = absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnPort::OnRefreshError(void)::$_0 &&>;
  v29[0] = v24;
  v30 = (uint64_t (*)(uint64_t, uint64_t *, void **))_ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
  v31 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  (*(void (**)(uint64_t, void **, void **, char *))(*(_QWORD *)v21 + 8))(v21, v29, __p, &v28);
  return v30(1, (uint64_t *)v29, v29);
}

cricket::TurnCreatePermissionRequest *cricket::TurnCreatePermissionRequest::TurnCreatePermissionRequest(cricket::TurnCreatePermissionRequest *this, cricket::TurnPort *a2, cricket::TurnEntry *a3, const rtc::SocketAddress *a4)
{
  char *v8;
  cricket::StunMessage *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  _OWORD *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  int v22;
  __int16 v23;
  __int16 v24;
  cricket::TurnCreatePermissionRequest *result;
  uint64_t *v26;
  _QWORD *v27;
  uint64_t v28;
  void (***v29)(_QWORD);
  uint64_t v30;

  v8 = (char *)a2 + 1080;
  v9 = (cricket::StunMessage *)operator new();
  cricket::StunMessage::StunMessage(v9, 8);
  *v10 = &off_24C0C1660;
  *(_QWORD *)this = &off_24C0C1B10;
  *((_QWORD *)this + 1) = v8;
  *((_QWORD *)this + 2) = v10;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_BYTE *)this + 36) = 0;
  v11 = operator new();
  *(_DWORD *)v11 = 0;
  *(_BYTE *)(v11 + 4) = 0;
  do
    v16 = __ldxr((unsigned int *)v11);
  while (__stxr(v16 + 1, (unsigned int *)v11));
  *((_QWORD *)this + 5) = v11;
  *((_BYTE *)this + 48) = 1;
  *(_QWORD *)this = off_24C0C2BF0;
  *((_QWORD *)this + 7) = a2;
  *((_QWORD *)this + 8) = a3;
  *((_QWORD *)this + 9) = 0;
  v17 = (_OWORD *)((char *)this + 72);
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 12) = &unk_24C0ACDA0;
  *((_DWORD *)this + 30) = 0;
  if ((cricket::TurnCreatePermissionRequest *)((char *)this + 72) != a4)
  {
    if (*((char *)a4 + 23) < 0)
    {
      std::string::__assign_no_alias<true>((_QWORD *)this + 9, *(char **)a4, *((_QWORD *)a4 + 1));
      a3 = (cricket::TurnEntry *)*((_QWORD *)this + 8);
    }
    else
    {
      v18 = *(_OWORD *)a4;
      *((_QWORD *)this + 11) = *((_QWORD *)a4 + 2);
      *v17 = v18;
    }
  }
  *((_DWORD *)this + 26) = *((_DWORD *)a4 + 8);
  *(_OWORD *)((char *)this + 108) = *(_OWORD *)((char *)a4 + 36);
  *((_WORD *)this + 64) = *((_WORD *)a4 + 28);
  *((_BYTE *)this + 136) = *((_BYTE *)a4 + 64);
  *((_DWORD *)this + 33) = *((_DWORD *)a4 + 15);
  webrtc::callback_list_impl::CallbackListReceivers::AddReceiver<webrtc::UntypedFunction::TrivialUntypedFunctionArgs<1ul>>((char *)a3 + 56, (uint64_t)this, (uint64_t)this, (uint64_t)webrtc::webrtc_function_impl::CallHelpers<void ()(cricket::TurnEntry *)>::CallInlineStorage<cricket::TurnCreatePermissionRequest::TurnCreatePermissionRequest(cricket::TurnPort *,cricket::TurnEntry *,rtc::SocketAddress const&)::$_0>, v12, v13, v14, v15);
  v19 = *((_QWORD *)this + 2);
  v20 = operator new();
  *(_DWORD *)(v20 + 8) = 18;
  *(_QWORD *)v20 = off_24C0C14A0;
  *(_QWORD *)(v20 + 16) = 0;
  v21 = (_QWORD *)(v20 + 16);
  *(_QWORD *)(v20 + 24) = 0;
  *(_QWORD *)(v20 + 32) = 0;
  *(_BYTE *)(v20 + 80) = 0;
  *(_WORD *)(v20 + 72) = 0;
  *(_DWORD *)(v20 + 76) = 0;
  *(_QWORD *)(v20 + 48) = 0;
  *(_QWORD *)(v20 + 56) = 0;
  *(_QWORD *)(v20 + 40) = &unk_24C0ACDA0;
  *(_DWORD *)(v20 + 64) = 0;
  if ((_OWORD *)(v20 + 16) != v17)
  {
    if (*((char *)this + 95) < 0)
    {
      std::string::__assign_no_alias<true>(v21, *((char **)this + 9), *((_QWORD *)this + 10));
    }
    else
    {
      *(_OWORD *)v21 = *v17;
      *(_QWORD *)(v20 + 32) = *((_QWORD *)this + 11);
    }
  }
  v22 = *((_DWORD *)this + 26);
  *(_DWORD *)(v20 + 48) = v22;
  *(_OWORD *)(v20 + 52) = *(_OWORD *)((char *)this + 108);
  *(_WORD *)(v20 + 72) = *((_WORD *)this + 64);
  *(_BYTE *)(v20 + 80) = *((_BYTE *)this + 136);
  *(_DWORD *)(v20 + 76) = *((_DWORD *)this + 33);
  if (v22 == 30)
    v23 = 20;
  else
    v23 = 0;
  if (v22 == 2)
    v24 = 8;
  else
    v24 = v23;
  *(_WORD *)(v20 + 10) = v24;
  *(_QWORD *)v20 = off_24C0C14E0;
  *(_QWORD *)(v20 + 88) = 0;
  v30 = v20;
  result = (cricket::TurnCreatePermissionRequest *)cricket::StunXorAddressAttribute::SetOwner(v20, (cricket::StunMessage *)v19);
  *(_WORD *)(v19 + 34) += ((*(_WORD *)(v20 + 10) + 3) & 0xFFFC) + 4;
  v26 = *(uint64_t **)(v19 + 16);
  if ((unint64_t)v26 >= *(_QWORD *)(v19 + 24))
  {
    v27 = std::vector<std::unique_ptr<webrtc::PushSincResampler>>::__push_back_slow_path<std::unique_ptr<webrtc::PushSincResampler>>((_QWORD *)(v19 + 8), &v30);
    v28 = v30;
    *(_QWORD *)(v19 + 16) = v27;
    v30 = 0;
    if (v28)
      (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
  }
  else
  {
    if (!v26)
    {
      __break(1u);
      return result;
    }
    *v26 = v20;
    *(_QWORD *)(v19 + 16) = v26 + 1;
    v30 = 0;
  }
  cricket::TurnPort::AddRequestAuthInfo(*((cricket::TurnPort **)this + 7), (cricket::StunMessage *)v19);
  v29 = *(void (****)(_QWORD))(*((_QWORD *)this + 7) + 1264);
  if (v29)
    (**v29)(v29);
  return this;
}

void cricket::TurnCreatePermissionRequest::~TurnCreatePermissionRequest(cricket::TurnCreatePermissionRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  *(_QWORD *)this = off_24C0C2BF0;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(v2 + 56), this);
  if (*((char *)this + 95) < 0)
    operator delete(*((void **)this + 9));
  *(_QWORD *)this = &off_24C0C1B10;
  v3 = *((_QWORD *)this + 5);
  *(_BYTE *)(v3 + 4) = 0;
  do
  {
    v4 = __ldaxr((unsigned int *)v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, (unsigned int *)v3));
  if (!v5)
    MEMORY[0x20BD0ADEC]();
  v6 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
}

{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  *(_QWORD *)this = off_24C0C2BF0;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(v2 + 56), this);
  if (*((char *)this + 95) < 0)
    operator delete(*((void **)this + 9));
  *(_QWORD *)this = &off_24C0C1B10;
  v3 = *((_QWORD *)this + 5);
  *(_BYTE *)(v3 + 4) = 0;
  do
  {
    v4 = __ldaxr((unsigned int *)v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, (unsigned int *)v3));
  if (!v5)
    MEMORY[0x20BD0ADEC]();
  v6 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::TurnCreatePermissionRequest::OnSent(cricket::TurnCreatePermissionRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  _BYTE *v18;
  unsigned int v19;
  int v20;
  int v21;
  void *__p[2];
  int64_t v23;
  void *v24;
  char v25;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    goto LABEL_22;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(&v24);
  v9 = *((_QWORD *)this + 2);
  v10 = (_QWORD *)(v9 + 40);
  if ((*(char *)(v9 + 63) & 0x80000000) == 0)
  {
    v11 = *(unsigned __int8 *)(v9 + 63);
    goto LABEL_10;
  }
  v11 = *(_QWORD *)(v9 + 48);
  if ((v11 & 0x8000000000000000) != 0 || ((v10 = (_QWORD *)*v10, v11) ? (v12 = v10 == 0) : (v12 = 0), v12))
  {
    __break(1u);
LABEL_29:
    abort();
  }
  if (v11 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_29;
LABEL_10:
  v13 = 2 * v11;
  if (v11 >= 0xC)
  {
    v15 = (v13 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v15 = v13 | 7;
    v16 = v15 + 1;
    v14 = operator new(v15 + 1);
    __p[1] = (void *)(2 * v11);
    v23 = v16 | 0x8000000000000000;
    __p[0] = v14;
  }
  else
  {
    HIBYTE(v23) = 2 * v11;
    v14 = __p;
    if (!v11)
    {
      LOBYTE(__p[0]) = 0;
      goto LABEL_20;
    }
  }
  bzero(v14, 2 * v11);
  *((_BYTE *)v14 + 2 * v11) = 0;
  v17 = __p;
  if (v23 < 0)
    v17 = (void **)__p[0];
  v18 = (char *)v17 + 1;
  do
  {
    v19 = *(unsigned __int8 *)v10;
    v10 = (_QWORD *)((char *)v10 + 1);
    v18 += 2;
    --v11;
  }
  while (v11);
LABEL_20:
  rtc::webrtc_logging_impl::Log("\r\n\t\n", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (SHIBYTE(v23) < 0)
  {
    operator delete(__p[0]);
    if (v25 < 0)
      goto LABEL_26;
LABEL_22:
    v20 = *((_DWORD *)this + 8);
    *((_DWORD *)this + 8) = v20 + 1;
    if (v20 < 8)
      return;
    goto LABEL_23;
  }
  if ((v25 & 0x80000000) == 0)
    goto LABEL_22;
LABEL_26:
  operator delete(v24);
  v21 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = v21 + 1;
  if (v21 >= 8)
LABEL_23:
    *((_BYTE *)this + 36) = 1;
}

void cricket::TurnCreatePermissionRequest::OnResponse(cricket::TurnCreatePermissionRequest *this, cricket::StunMessage *a2)
{
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void **v11;
  _BYTE *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const void **v32;
  void *v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int *v38;
  uint64_t v39;
  unsigned int v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *__p[2];
  int64_t v50;
  char v51;
  void *v52[2];
  uint64_t (*v53)(uint64_t, uint64_t *, void **);
  uint64_t (*v54)(uint64_t);

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    goto LABEL_27;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(v52);
  v3 = *((_QWORD *)this + 2);
  v4 = (_QWORD *)(v3 + 40);
  if ((*(char *)(v3 + 63) & 0x80000000) == 0)
  {
    v5 = *(unsigned __int8 *)(v3 + 63);
    goto LABEL_10;
  }
  v5 = *(_QWORD *)(v3 + 48);
  if ((v5 & 0x8000000000000000) != 0 || ((v4 = (_QWORD *)*v4, v5) ? (v6 = v4 == 0) : (v6 = 0), v6))
  {
    __break(1u);
LABEL_56:
    abort();
  }
  if (v5 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_56;
LABEL_10:
  v7 = 2 * v5;
  if (v5 >= 0xC)
  {
    v9 = (v7 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v9 = v7 | 7;
    v10 = v9 + 1;
    v8 = operator new(v9 + 1);
    __p[1] = (void *)(2 * v5);
    v50 = v10 | 0x8000000000000000;
    __p[0] = v8;
  }
  else
  {
    HIBYTE(v50) = 2 * v5;
    v8 = __p;
    if (!v5)
    {
      LOBYTE(__p[0]) = 0;
      goto LABEL_20;
    }
  }
  bzero(v8, 2 * v5);
  *((_BYTE *)v8 + 2 * v5) = 0;
  v11 = __p;
  if (v50 < 0)
    v11 = (void **)__p[0];
  v12 = (char *)v11 + 1;
  do
  {
    v13 = *(unsigned __int8 *)v4;
    v4 = (_QWORD *)((char *)v4 + 1);
    v12 += 2;
    --v5;
  }
  while (v5);
LABEL_20:
  if (rtc::g_clock)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    mach_absolute_time();
  }
  rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v14, v15, v16, v17, v18, v19, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (SHIBYTE(v50) < 0)
  {
    operator delete(__p[0]);
    if (SHIBYTE(v53) < 0)
      goto LABEL_46;
LABEL_27:
    v21 = *((_QWORD *)this + 8);
    if (!v21)
      return;
    goto LABEL_28;
  }
  if ((SHIBYTE(v53) & 0x80000000) == 0)
    goto LABEL_27;
LABEL_46:
  operator delete(v52[0]);
  v21 = *((_QWORD *)this + 8);
  if (!v21)
    return;
LABEL_28:
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    goto LABEL_31;
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v21 + 88) + 176))(v52);
  rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)(v21 + 104), (char *)__p);
  rtc::webrtc_logging_impl::Log("\r\n\t\n\t", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (SHIBYTE(v50) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v53) & 0x80000000) == 0)
    {
LABEL_31:
      v29 = *(_QWORD *)(*(_QWORD *)(v21 + 88) + 1304);
      if (!v29)
        goto LABEL_33;
      goto LABEL_32;
    }
  }
  else if ((SHIBYTE(v53) & 0x80000000) == 0)
  {
    goto LABEL_31;
  }
  operator delete(v52[0]);
  v29 = *(_QWORD *)(*(_QWORD *)(v21 + 88) + 1304);
  if (v29)
LABEL_32:
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v29 + 16))(v29, 0);
LABEL_33:
  if (*(_DWORD *)(v21 + 176) != 2)
  {
    v30 = *(_QWORD *)(v21 + 88);
    v31 = operator new();
    cricket::TurnCreatePermissionRequest::TurnCreatePermissionRequest((cricket::TurnCreatePermissionRequest *)v31, *(cricket::TurnPort **)(v21 + 88), (cricket::TurnEntry *)v21, (const rtc::SocketAddress *)(v21 + 104));
    v32 = (const void **)(*(_QWORD *)(v31 + 16) + 40);
    v52[0] = (void *)v31;
    std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>(v30 + 1088, v32, (uint64_t)v32, (uint64_t *)v52);
    v33 = v52[0];
    v52[0] = 0;
    if (v33)
      (*(void (**)(void *))(*(_QWORD *)v33 + 8))(v33);
    v34 = *(_QWORD *)(v31 + 40);
    if (v34)
    {
      do
        v35 = __ldxr((unsigned int *)v34);
      while (__stxr(v35 + 1, (unsigned int *)v34));
      *(_BYTE *)(v34 + 4) = 1;
      do
      {
        v36 = __ldaxr((unsigned int *)v34);
        v37 = v36 - 1;
      }
      while (__stlxr(v37, (unsigned int *)v34));
      if (!v37)
        MEMORY[0x20BD0ADEC]();
      v38 = *(unsigned int **)(v31 + 40);
      v39 = **(_QWORD **)(v31 + 8);
      if (v38)
      {
        do
          v40 = __ldxr(v38);
        while (__stxr(v40 + 1, v38));
      }
    }
    else
    {
      v38 = 0;
      MEMORY[4] = 1;
      v39 = **(_QWORD **)(v31 + 8);
    }
    v41 = (_QWORD *)operator new();
    *v41 = v38;
    v41[1] = v31;
    v41[3] = absl::internal_any_invocable::LocalManagerTrivial;
    v41[4] = absl::internal_any_invocable::LocalInvoker<false,void,cricket::StunRequest::SendDelayed(webrtc::TimeDelta)::$_0 &&>;
    v52[0] = v41;
    v53 = (uint64_t (*)(uint64_t, uint64_t *, void **))_ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
    v54 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
    LOBYTE(__p[0]) = 0;
    (*(void (**)(uint64_t, void **, uint64_t, void **, char *))(*(_QWORD *)v39 + 16))(v39, v52, 240000000, __p, &v51);
    v53(1, (uint64_t *)v52, v52);
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      (*(void (**)(void **__return_ptr))(**(_QWORD **)(v21 + 88) + 176))(v52);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v42, v43, v44, v45, v46, v47, v48, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (SHIBYTE(v53) < 0)
        operator delete(v52[0]);
    }
  }
}

void cricket::TurnCreatePermissionRequest::OnErrorResponse(cricket::TurnCreatePermissionRequest *this, cricket::StunMessage *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  BOOL v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void **v15;
  _BYTE *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  cricket::TurnPort **v25;
  cricket::TurnPort *v26;
  int v27;
  cricket::TurnPort *v28;
  cricket::TurnCreatePermissionRequest *v29;
  const void **v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  cricket::Connection *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *__p[2];
  int64_t v46;
  void *v47[2];
  char v48;
  char v49;
  uint64_t v50[4];
  uint64_t *v51;

  v4 = *((_QWORD *)a2 + 1);
  v5 = *((_QWORD *)a2 + 2);
  if (v4 == v5)
  {
LABEL_4:
    v6 = 600;
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      goto LABEL_32;
  }
  else
  {
    while (*(_WORD *)(*(_QWORD *)v4 + 8) != 9)
    {
      v4 += 8;
      if (v4 == v5)
        goto LABEL_4;
    }
    v6 = *(unsigned __int8 *)(*(_QWORD *)v4 + 13) + 100 * *(unsigned __int8 *)(*(_QWORD *)v4 + 12);
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      goto LABEL_32;
  }
  v50[0] = (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc";
  v50[1] = 13242;
  v50[2] = (uint64_t)&v49;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(v47);
  v50[3] = (uint64_t)v47;
  v51 = v50;
  v7 = *((_QWORD *)this + 2);
  v8 = (_QWORD *)(v7 + 40);
  if ((*(char *)(v7 + 63) & 0x80000000) == 0)
  {
    v9 = *(unsigned __int8 *)(v7 + 63);
    goto LABEL_15;
  }
  v9 = *(_QWORD *)(v7 + 48);
  if ((v9 & 0x8000000000000000) != 0 || ((v8 = (_QWORD *)*v8, v9) ? (v10 = v8 == 0) : (v10 = 0), v10))
  {
    __break(1u);
LABEL_55:
    abort();
  }
  if (v9 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_55;
LABEL_15:
  v11 = 2 * v9;
  if (v9 >= 0xC)
  {
    v13 = (v11 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v13 = v11 | 7;
    v14 = v13 + 1;
    v12 = operator new(v13 + 1);
    __p[1] = (void *)(2 * v9);
    v46 = v14 | 0x8000000000000000;
    __p[0] = v12;
  }
  else
  {
    HIBYTE(v46) = 2 * v9;
    v12 = __p;
    if (!v9)
    {
      LOBYTE(__p[0]) = 0;
      goto LABEL_25;
    }
  }
  bzero(v12, 2 * v9);
  *((_BYTE *)v12 + 2 * v9) = 0;
  v15 = __p;
  if (v46 < 0)
    v15 = (void **)__p[0];
  v16 = (char *)v15 + 1;
  do
  {
    v17 = *(unsigned __int8 *)v8;
    v8 = (_QWORD *)((char *)v8 + 1);
    v16 += 2;
    --v9;
  }
  while (v9);
LABEL_25:
  if (rtc::g_clock)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    mach_absolute_time();
  }
  rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v18, v19, v20, v21, v22, v23, v24, *v51);
  if (SHIBYTE(v46) < 0)
  {
    operator delete(__p[0]);
    if (v48 < 0)
      goto LABEL_47;
LABEL_32:
    v25 = (cricket::TurnPort **)*((_QWORD *)this + 8);
    if (!v25)
      return;
    goto LABEL_33;
  }
  if ((v48 & 0x80000000) == 0)
    goto LABEL_32;
LABEL_47:
  operator delete(v47[0]);
  v25 = (cricket::TurnPort **)*((_QWORD *)this + 8);
  if (!v25)
    return;
LABEL_33:
  v26 = v25[11];
  if ((_DWORD)v6 == 438)
  {
    cricket::TurnPort::UpdateNonce(v26, a2);
    if (v27)
    {
      v28 = v25[11];
      v29 = (cricket::TurnCreatePermissionRequest *)operator new();
      cricket::TurnCreatePermissionRequest::TurnCreatePermissionRequest(v29, v25[11], (cricket::TurnEntry *)v25, (const rtc::SocketAddress *)(v25 + 13));
      v30 = (const void **)(*((_QWORD *)v29 + 2) + 40);
      v50[0] = (uint64_t)v29;
      std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>((uint64_t)v28 + 1088, v30, (uint64_t)v30, v50);
      v31 = v50[0];
      v50[0] = 0;
      if (v31)
        (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
      v32 = *((_QWORD *)v29 + 5);
      if (v32)
      {
        do
          v33 = __ldxr((unsigned int *)v32);
        while (__stxr(v33 + 1, (unsigned int *)v32));
        *(_BYTE *)(v32 + 4) = 1;
        do
        {
          v34 = __ldaxr((unsigned int *)v32);
          v35 = v34 - 1;
        }
        while (__stlxr(v35, (unsigned int *)v32));
        if (!v35)
          MEMORY[0x20BD0ADEC]();
      }
      else
      {
        MEMORY[4] = 1;
      }
      cricket::StunRequest::SendInternal(v29);
    }
  }
  else
  {
    v36 = (cricket::Connection *)(*(uint64_t (**)(cricket::TurnPort *, cricket::TurnPort **))(*(_QWORD *)v26 + 88))(v26, v25 + 13);
    if (v36)
    {
      cricket::Connection::FailAndPrune(v36);
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v37, v38, v39, v40, v41, v42, v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    }
  }
  v44 = *((_QWORD *)v25[11] + 163);
  if (v44)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v44 + 16))(v44, v6);
}

void cricket::TurnCreatePermissionRequest::OnTimeout(cricket::TurnCreatePermissionRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  _BYTE *v18;
  unsigned int v19;
  uint64_t v20;
  cricket::Connection *v21;
  void *__p[2];
  int64_t v23;
  void *v24;
  char v25;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
    goto LABEL_22;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(&v24);
  v9 = *((_QWORD *)this + 2);
  v10 = (_QWORD *)(v9 + 40);
  if ((*(char *)(v9 + 63) & 0x80000000) == 0)
  {
    v11 = *(unsigned __int8 *)(v9 + 63);
    goto LABEL_10;
  }
  v11 = *(_QWORD *)(v9 + 48);
  if ((v11 & 0x8000000000000000) != 0 || ((v10 = (_QWORD *)*v10, v11) ? (v12 = v10 == 0) : (v12 = 0), v12))
  {
    __break(1u);
LABEL_30:
    abort();
  }
  if (v11 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_30;
LABEL_10:
  v13 = 2 * v11;
  if (v11 >= 0xC)
  {
    v15 = (v13 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v15 = v13 | 7;
    v16 = v15 + 1;
    v14 = operator new(v15 + 1);
    __p[1] = (void *)(2 * v11);
    v23 = v16 | 0x8000000000000000;
    __p[0] = v14;
    goto LABEL_16;
  }
  HIBYTE(v23) = 2 * v11;
  v14 = __p;
  if (v11)
  {
LABEL_16:
    bzero(v14, 2 * v11);
    *((_BYTE *)v14 + 2 * v11) = 0;
    v17 = __p;
    if (v23 < 0)
      v17 = (void **)__p[0];
    v18 = (char *)v17 + 1;
    do
    {
      v19 = *(unsigned __int8 *)v10;
      v10 = (_QWORD *)((char *)v10 + 1);
      v18 += 2;
      --v11;
    }
    while (v11);
    goto LABEL_20;
  }
  LOBYTE(__p[0]) = 0;
LABEL_20:
  rtc::webrtc_logging_impl::Log("\r\n\t\n", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if ((v25 & 0x80000000) == 0)
      goto LABEL_22;
LABEL_27:
    operator delete(v24);
    v20 = *((_QWORD *)this + 8);
    if (!v20)
      return;
    goto LABEL_23;
  }
  operator delete(__p[0]);
  if (v25 < 0)
    goto LABEL_27;
LABEL_22:
  v20 = *((_QWORD *)this + 8);
  if (!v20)
    return;
LABEL_23:
  v21 = (cricket::Connection *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v20 + 88) + 88))(*(_QWORD *)(v20 + 88), v20 + 104);
  if (v21)
    cricket::Connection::FailAndPrune(v21);
}

cricket::TurnChannelBindRequest *cricket::TurnChannelBindRequest::TurnChannelBindRequest(cricket::TurnChannelBindRequest *this, cricket::TurnPort *a2, cricket::TurnEntry *a3, int a4, const rtc::SocketAddress *a5)
{
  char *v10;
  cricket::StunMessage *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  _OWORD *v19;
  __int128 v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  cricket::TurnChannelBindRequest *result;
  uint64_t *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  int v30;
  __int16 v31;
  __int16 v32;
  uint64_t *v33;
  _QWORD *v34;
  uint64_t v35;
  void (***v36)(_QWORD);
  uint64_t v37;
  uint64_t v38;

  v10 = (char *)a2 + 1080;
  v11 = (cricket::StunMessage *)operator new();
  cricket::StunMessage::StunMessage(v11, 9);
  *v12 = &off_24C0C1660;
  *(_QWORD *)this = &off_24C0C1B10;
  *((_QWORD *)this + 1) = v10;
  *((_QWORD *)this + 2) = v12;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_BYTE *)this + 36) = 0;
  v13 = operator new();
  *(_DWORD *)v13 = 0;
  *(_BYTE *)(v13 + 4) = 0;
  do
    v18 = __ldxr((unsigned int *)v13);
  while (__stxr(v18 + 1, (unsigned int *)v13));
  *((_QWORD *)this + 5) = v13;
  *((_BYTE *)this + 48) = 1;
  *(_QWORD *)this = off_24C0C2C38;
  *((_QWORD *)this + 7) = a2;
  *((_QWORD *)this + 8) = a3;
  *((_DWORD *)this + 18) = a4;
  *((_QWORD *)this + 10) = 0;
  v19 = (_OWORD *)((char *)this + 80);
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 13) = &unk_24C0ACDA0;
  *((_DWORD *)this + 32) = 0;
  if ((cricket::TurnChannelBindRequest *)((char *)this + 80) != a5)
  {
    if (*((char *)a5 + 23) < 0)
    {
      std::string::__assign_no_alias<true>((_QWORD *)this + 10, *(char **)a5, *((_QWORD *)a5 + 1));
      a3 = (cricket::TurnEntry *)*((_QWORD *)this + 8);
    }
    else
    {
      v20 = *(_OWORD *)a5;
      *((_QWORD *)this + 12) = *((_QWORD *)a5 + 2);
      *v19 = v20;
    }
  }
  *((_DWORD *)this + 28) = *((_DWORD *)a5 + 8);
  *(_OWORD *)((char *)this + 116) = *(_OWORD *)((char *)a5 + 36);
  *((_WORD *)this + 68) = *((_WORD *)a5 + 28);
  *((_BYTE *)this + 144) = *((_BYTE *)a5 + 64);
  *((_DWORD *)this + 35) = *((_DWORD *)a5 + 15);
  webrtc::callback_list_impl::CallbackListReceivers::AddReceiver<webrtc::UntypedFunction::TrivialUntypedFunctionArgs<1ul>>((char *)a3 + 56, (uint64_t)this, (uint64_t)this, (uint64_t)webrtc::webrtc_function_impl::CallHelpers<void ()(cricket::TurnEntry *)>::CallInlineStorage<cricket::TurnChannelBindRequest::TurnChannelBindRequest(cricket::TurnPort *,cricket::TurnEntry *,int,rtc::SocketAddress const&)::$_0>, v14, v15, v16, v17);
  v21 = *((_QWORD *)this + 2);
  v22 = *((_DWORD *)this + 18) << 16;
  v23 = operator new();
  *(_QWORD *)v23 = &off_24C0C1520;
  *(_DWORD *)(v23 + 8) = 262156;
  *(_DWORD *)(v23 + 12) = v22;
  v38 = v23;
  result = (cricket::TurnChannelBindRequest *)cricket::StunAttribute::SetOwner((cricket::StunAttribute *)v23, (cricket::StunMessage *)v21);
  *(_WORD *)(v21 + 34) += ((*(_WORD *)(v23 + 10) + 3) & 0xFFFC) + 4;
  v25 = *(uint64_t **)(v21 + 16);
  if ((unint64_t)v25 >= *(_QWORD *)(v21 + 24))
  {
    v26 = std::vector<std::unique_ptr<webrtc::PushSincResampler>>::__push_back_slow_path<std::unique_ptr<webrtc::PushSincResampler>>((_QWORD *)(v21 + 8), &v38);
    v27 = v38;
    *(_QWORD *)(v21 + 16) = v26;
    v38 = 0;
    if (v27)
      (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
  }
  else
  {
    if (!v25)
      goto LABEL_30;
    *v25 = v23;
    *(_QWORD *)(v21 + 16) = v25 + 1;
    v38 = 0;
  }
  v28 = operator new();
  *(_DWORD *)(v28 + 8) = 18;
  *(_QWORD *)(v28 + 16) = 0;
  v29 = (_QWORD *)(v28 + 16);
  *(_QWORD *)v28 = off_24C0C14A0;
  *(_QWORD *)(v28 + 24) = 0;
  *(_QWORD *)(v28 + 32) = 0;
  *(_BYTE *)(v28 + 80) = 0;
  *(_WORD *)(v28 + 72) = 0;
  *(_DWORD *)(v28 + 76) = 0;
  *(_QWORD *)(v28 + 48) = 0;
  *(_QWORD *)(v28 + 56) = 0;
  *(_QWORD *)(v28 + 40) = &unk_24C0ACDA0;
  *(_DWORD *)(v28 + 64) = 0;
  if ((_OWORD *)(v28 + 16) != v19)
  {
    if (*((char *)this + 103) < 0)
    {
      std::string::__assign_no_alias<true>(v29, *((char **)this + 10), *((_QWORD *)this + 11));
    }
    else
    {
      *(_OWORD *)v29 = *v19;
      *(_QWORD *)(v28 + 32) = *((_QWORD *)this + 12);
    }
  }
  v30 = *((_DWORD *)this + 28);
  *(_DWORD *)(v28 + 48) = v30;
  *(_OWORD *)(v28 + 52) = *(_OWORD *)((char *)this + 116);
  *(_WORD *)(v28 + 72) = *((_WORD *)this + 68);
  *(_BYTE *)(v28 + 80) = *((_BYTE *)this + 144);
  *(_DWORD *)(v28 + 76) = *((_DWORD *)this + 35);
  if (v30 == 30)
    v31 = 20;
  else
    v31 = 0;
  if (v30 == 2)
    v32 = 8;
  else
    v32 = v31;
  *(_WORD *)(v28 + 10) = v32;
  *(_QWORD *)v28 = off_24C0C14E0;
  *(_QWORD *)(v28 + 88) = 0;
  v37 = v28;
  result = (cricket::TurnChannelBindRequest *)cricket::StunXorAddressAttribute::SetOwner(v28, (cricket::StunMessage *)v21);
  *(_WORD *)(v21 + 34) += ((*(_WORD *)(v28 + 10) + 3) & 0xFFFC) + 4;
  v33 = *(uint64_t **)(v21 + 16);
  if ((unint64_t)v33 >= *(_QWORD *)(v21 + 24))
  {
    v34 = std::vector<std::unique_ptr<webrtc::PushSincResampler>>::__push_back_slow_path<std::unique_ptr<webrtc::PushSincResampler>>((_QWORD *)(v21 + 8), &v37);
    v35 = v37;
    *(_QWORD *)(v21 + 16) = v34;
    v37 = 0;
    if (v35)
      (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
    goto LABEL_27;
  }
  if (!v33)
  {
LABEL_30:
    __break(1u);
    return result;
  }
  *v33 = v28;
  *(_QWORD *)(v21 + 16) = v33 + 1;
  v37 = 0;
LABEL_27:
  cricket::TurnPort::AddRequestAuthInfo(*((cricket::TurnPort **)this + 7), (cricket::StunMessage *)v21);
  v36 = *(void (****)(_QWORD))(*((_QWORD *)this + 7) + 1264);
  if (v36)
    (**v36)(v36);
  return this;
}

void cricket::TurnChannelBindRequest::~TurnChannelBindRequest(cricket::TurnChannelBindRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  *(_QWORD *)this = off_24C0C2C38;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(v2 + 56), this);
  if (*((char *)this + 103) < 0)
    operator delete(*((void **)this + 10));
  *(_QWORD *)this = &off_24C0C1B10;
  v3 = *((_QWORD *)this + 5);
  *(_BYTE *)(v3 + 4) = 0;
  do
  {
    v4 = __ldaxr((unsigned int *)v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, (unsigned int *)v3));
  if (!v5)
    MEMORY[0x20BD0ADEC]();
  v6 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
}

{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  *(_QWORD *)this = off_24C0C2C38;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(v2 + 56), this);
  if (*((char *)this + 103) < 0)
    operator delete(*((void **)this + 10));
  *(_QWORD *)this = &off_24C0C1B10;
  v3 = *((_QWORD *)this + 5);
  *(_BYTE *)(v3 + 4) = 0;
  do
  {
    v4 = __ldaxr((unsigned int *)v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, (unsigned int *)v3));
  if (!v5)
    MEMORY[0x20BD0ADEC]();
  v6 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::TurnChannelBindRequest::OnSent(cricket::TurnChannelBindRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  _BYTE *v18;
  unsigned int v19;
  int v20;
  int v21;
  void *__p[2];
  int64_t v23;
  void *v24;
  char v25;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    goto LABEL_22;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(&v24);
  v9 = *((_QWORD *)this + 2);
  v10 = (_QWORD *)(v9 + 40);
  if ((*(char *)(v9 + 63) & 0x80000000) == 0)
  {
    v11 = *(unsigned __int8 *)(v9 + 63);
    goto LABEL_10;
  }
  v11 = *(_QWORD *)(v9 + 48);
  if ((v11 & 0x8000000000000000) != 0 || ((v10 = (_QWORD *)*v10, v11) ? (v12 = v10 == 0) : (v12 = 0), v12))
  {
    __break(1u);
LABEL_29:
    abort();
  }
  if (v11 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_29;
LABEL_10:
  v13 = 2 * v11;
  if (v11 >= 0xC)
  {
    v15 = (v13 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v15 = v13 | 7;
    v16 = v15 + 1;
    v14 = operator new(v15 + 1);
    __p[1] = (void *)(2 * v11);
    v23 = v16 | 0x8000000000000000;
    __p[0] = v14;
  }
  else
  {
    HIBYTE(v23) = 2 * v11;
    v14 = __p;
    if (!v11)
    {
      LOBYTE(__p[0]) = 0;
      goto LABEL_20;
    }
  }
  bzero(v14, 2 * v11);
  *((_BYTE *)v14 + 2 * v11) = 0;
  v17 = __p;
  if (v23 < 0)
    v17 = (void **)__p[0];
  v18 = (char *)v17 + 1;
  do
  {
    v19 = *(unsigned __int8 *)v10;
    v10 = (_QWORD *)((char *)v10 + 1);
    v18 += 2;
    --v11;
  }
  while (v11);
LABEL_20:
  rtc::webrtc_logging_impl::Log("\r\n\t\n", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (SHIBYTE(v23) < 0)
  {
    operator delete(__p[0]);
    if (v25 < 0)
      goto LABEL_26;
LABEL_22:
    v20 = *((_DWORD *)this + 8);
    *((_DWORD *)this + 8) = v20 + 1;
    if (v20 < 8)
      return;
    goto LABEL_23;
  }
  if ((v25 & 0x80000000) == 0)
    goto LABEL_22;
LABEL_26:
  operator delete(v24);
  v21 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = v21 + 1;
  if (v21 >= 8)
LABEL_23:
    *((_BYTE *)this + 36) = 1;
}

void cricket::TurnChannelBindRequest::OnResponse(cricket::TurnChannelBindRequest *this, cricket::StunMessage *a2)
{
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void **v11;
  _BYTE *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const void **v32;
  void *v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int *v38;
  uint64_t v39;
  unsigned int v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *__p[2];
  int64_t v50;
  char v51;
  void *v52[2];
  uint64_t (*v53)(uint64_t, uint64_t *, void **);
  uint64_t (*v54)(uint64_t);

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    goto LABEL_27;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(v52);
  v3 = *((_QWORD *)this + 2);
  v4 = (_QWORD *)(v3 + 40);
  if ((*(char *)(v3 + 63) & 0x80000000) == 0)
  {
    v5 = *(unsigned __int8 *)(v3 + 63);
    goto LABEL_10;
  }
  v5 = *(_QWORD *)(v3 + 48);
  if ((v5 & 0x8000000000000000) != 0 || ((v4 = (_QWORD *)*v4, v5) ? (v6 = v4 == 0) : (v6 = 0), v6))
  {
    __break(1u);
LABEL_53:
    abort();
  }
  if (v5 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_53;
LABEL_10:
  v7 = 2 * v5;
  if (v5 >= 0xC)
  {
    v9 = (v7 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v9 = v7 | 7;
    v10 = v9 + 1;
    v8 = operator new(v9 + 1);
    __p[1] = (void *)(2 * v5);
    v50 = v10 | 0x8000000000000000;
    __p[0] = v8;
  }
  else
  {
    HIBYTE(v50) = 2 * v5;
    v8 = __p;
    if (!v5)
    {
      LOBYTE(__p[0]) = 0;
      goto LABEL_20;
    }
  }
  bzero(v8, 2 * v5);
  *((_BYTE *)v8 + 2 * v5) = 0;
  v11 = __p;
  if (v50 < 0)
    v11 = (void **)__p[0];
  v12 = (char *)v11 + 1;
  do
  {
    v13 = *(unsigned __int8 *)v4;
    v4 = (_QWORD *)((char *)v4 + 1);
    v12 += 2;
    --v5;
  }
  while (v5);
LABEL_20:
  if (rtc::g_clock)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    mach_absolute_time();
  }
  rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v14, v15, v16, v17, v18, v19, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if (SHIBYTE(v50) < 0)
  {
    operator delete(__p[0]);
    if (SHIBYTE(v53) < 0)
      goto LABEL_47;
LABEL_27:
    v21 = *((_QWORD *)this + 8);
    if (!v21)
      return;
    goto LABEL_28;
  }
  if ((SHIBYTE(v53) & 0x80000000) == 0)
    goto LABEL_27;
LABEL_47:
  operator delete(v52[0]);
  v21 = *((_QWORD *)this + 8);
  if (!v21)
    return;
LABEL_28:
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(v21 + 88) + 176))(v52);
    rtc::SocketAddress::ToSensitiveString((rtc::SocketAddress *)(v21 + 104), (char *)__p);
    rtc::webrtc_logging_impl::Log("\r\n\t\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (SHIBYTE(v50) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v53) & 0x80000000) == 0)
        goto LABEL_31;
    }
    else if ((SHIBYTE(v53) & 0x80000000) == 0)
    {
      goto LABEL_31;
    }
    operator delete(v52[0]);
  }
LABEL_31:
  *(_DWORD *)(v21 + 176) = 2;
  v29 = *((_QWORD *)this + 8);
  v30 = *(_QWORD *)(v29 + 88);
  v31 = operator new();
  cricket::TurnChannelBindRequest::TurnChannelBindRequest((cricket::TurnChannelBindRequest *)v31, *(cricket::TurnPort **)(v29 + 88), (cricket::TurnEntry *)v29, *(_DWORD *)(v29 + 96), (const rtc::SocketAddress *)(v29 + 104));
  v32 = (const void **)(*(_QWORD *)(v31 + 16) + 40);
  v52[0] = (void *)v31;
  std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>(v30 + 1088, v32, (uint64_t)v32, (uint64_t *)v52);
  v33 = v52[0];
  v52[0] = 0;
  if (v33)
    (*(void (**)(void *))(*(_QWORD *)v33 + 8))(v33);
  v34 = *(_QWORD *)(v31 + 40);
  if (v34)
  {
    do
      v35 = __ldxr((unsigned int *)v34);
    while (__stxr(v35 + 1, (unsigned int *)v34));
    *(_BYTE *)(v34 + 4) = 1;
    do
    {
      v36 = __ldaxr((unsigned int *)v34);
      v37 = v36 - 1;
    }
    while (__stlxr(v37, (unsigned int *)v34));
    if (!v37)
      MEMORY[0x20BD0ADEC]();
    v38 = *(unsigned int **)(v31 + 40);
    v39 = **(_QWORD **)(v31 + 8);
    if (v38)
    {
      do
        v40 = __ldxr(v38);
      while (__stxr(v40 + 1, v38));
    }
  }
  else
  {
    v38 = 0;
    MEMORY[4] = 1;
    v39 = **(_QWORD **)(v31 + 8);
  }
  v41 = (_QWORD *)operator new();
  *v41 = v38;
  v41[1] = v31;
  v41[3] = absl::internal_any_invocable::LocalManagerTrivial;
  v41[4] = absl::internal_any_invocable::LocalInvoker<false,void,cricket::StunRequest::SendDelayed(webrtc::TimeDelta)::$_0 &&>;
  v52[0] = v41;
  v53 = (uint64_t (*)(uint64_t, uint64_t *, void **))_ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
  v54 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  LOBYTE(__p[0]) = 0;
  (*(void (**)(uint64_t, void **, uint64_t, void **, char *))(*(_QWORD *)v39 + 16))(v39, v52, 240000000, __p, &v51);
  v53(1, (uint64_t *)v52, v52);
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(v52);
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v42, v43, v44, v45, v46, v47, v48, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (SHIBYTE(v53) < 0)
      operator delete(v52[0]);
  }
}

void cricket::TurnChannelBindRequest::OnErrorResponse(cricket::TurnChannelBindRequest *this, cricket::StunMessage *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  BOOL v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void **v15;
  _BYTE *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  cricket::TurnChannelBindRequest *v28;
  const void **v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  cricket::Connection *v35;
  void *__p[2];
  int64_t v37;
  void *v38[2];
  char v39;
  char v40;
  uint64_t v41[4];
  uint64_t *v42;

  v4 = *((_QWORD *)a2 + 1);
  v5 = *((_QWORD *)a2 + 2);
  if (v4 == v5)
  {
LABEL_4:
    v6 = 600;
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      goto LABEL_32;
  }
  else
  {
    while (*(_WORD *)(*(_QWORD *)v4 + 8) != 9)
    {
      v4 += 8;
      if (v4 == v5)
        goto LABEL_4;
    }
    v6 = *(unsigned __int8 *)(*(_QWORD *)v4 + 13) + 100 * *(unsigned __int8 *)(*(_QWORD *)v4 + 12);
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      goto LABEL_32;
  }
  v41[0] = (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc";
  v41[1] = 13890;
  v41[2] = (uint64_t)&v40;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(v38);
  v41[3] = (uint64_t)v38;
  v42 = v41;
  v7 = *((_QWORD *)this + 2);
  v8 = (_QWORD *)(v7 + 40);
  if ((*(char *)(v7 + 63) & 0x80000000) == 0)
  {
    v9 = *(unsigned __int8 *)(v7 + 63);
    goto LABEL_15;
  }
  v9 = *(_QWORD *)(v7 + 48);
  if ((v9 & 0x8000000000000000) != 0 || ((v8 = (_QWORD *)*v8, v9) ? (v10 = v8 == 0) : (v10 = 0), v10))
  {
    __break(1u);
LABEL_52:
    abort();
  }
  if (v9 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_52;
LABEL_15:
  v11 = 2 * v9;
  if (v9 >= 0xC)
  {
    v13 = (v11 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v13 = v11 | 7;
    v14 = v13 + 1;
    v12 = operator new(v13 + 1);
    __p[1] = (void *)(2 * v9);
    v37 = v14 | 0x8000000000000000;
    __p[0] = v12;
  }
  else
  {
    HIBYTE(v37) = 2 * v9;
    v12 = __p;
    if (!v9)
    {
      LOBYTE(__p[0]) = 0;
      goto LABEL_25;
    }
  }
  bzero(v12, 2 * v9);
  *((_BYTE *)v12 + 2 * v9) = 0;
  v15 = __p;
  if (v37 < 0)
    v15 = (void **)__p[0];
  v16 = (char *)v15 + 1;
  do
  {
    v17 = *(unsigned __int8 *)v8;
    v8 = (_QWORD *)((char *)v8 + 1);
    v16 += 2;
    --v9;
  }
  while (v9);
LABEL_25:
  if (rtc::g_clock)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    mach_absolute_time();
  }
  rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v18, v19, v20, v21, v22, v23, v24, *v42);
  if (SHIBYTE(v37) < 0)
  {
    operator delete(__p[0]);
    if (v39 < 0)
      goto LABEL_46;
LABEL_32:
    v25 = *((_QWORD *)this + 8);
    if (!v25)
      return;
    goto LABEL_33;
  }
  if ((v39 & 0x80000000) == 0)
    goto LABEL_32;
LABEL_46:
  operator delete(v38[0]);
  v25 = *((_QWORD *)this + 8);
  if (!v25)
    return;
LABEL_33:
  if (v6 == 438)
  {
    cricket::TurnPort::UpdateNonce(*(cricket::TurnPort **)(v25 + 88), a2);
    if (v26)
    {
      v27 = *(_QWORD *)(v25 + 88);
      v28 = (cricket::TurnChannelBindRequest *)operator new();
      cricket::TurnChannelBindRequest::TurnChannelBindRequest(v28, *(cricket::TurnPort **)(v25 + 88), (cricket::TurnEntry *)v25, *(_DWORD *)(v25 + 96), (const rtc::SocketAddress *)(v25 + 104));
      v29 = (const void **)(*((_QWORD *)v28 + 2) + 40);
      v41[0] = (uint64_t)v28;
      std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>(v27 + 1088, v29, (uint64_t)v29, v41);
      v30 = v41[0];
      v41[0] = 0;
      if (v30)
        (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
      v31 = *((_QWORD *)v28 + 5);
      if (v31)
      {
        do
          v32 = __ldxr((unsigned int *)v31);
        while (__stxr(v32 + 1, (unsigned int *)v31));
        *(_BYTE *)(v31 + 4) = 1;
        do
        {
          v33 = __ldaxr((unsigned int *)v31);
          v34 = v33 - 1;
        }
        while (__stlxr(v34, (unsigned int *)v31));
        if (!v34)
          MEMORY[0x20BD0ADEC]();
      }
      else
      {
        MEMORY[4] = 1;
      }
      cricket::StunRequest::SendInternal(v28);
    }
  }
  else
  {
    *(_DWORD *)(v25 + 176) = 0;
    v35 = (cricket::Connection *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v25 + 88) + 88))(*(_QWORD *)(v25 + 88), v25 + 104);
    if (v35)
      cricket::Connection::FailAndPrune(v35);
  }
}

void cricket::TurnChannelBindRequest::OnTimeout(cricket::TurnChannelBindRequest *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  _BYTE *v18;
  unsigned int v19;
  uint64_t v20;
  cricket::Connection *v21;
  void *__p[2];
  int64_t v23;
  void *v24;
  char v25;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
    goto LABEL_22;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 7) + 176))(&v24);
  v9 = *((_QWORD *)this + 2);
  v10 = (_QWORD *)(v9 + 40);
  if ((*(char *)(v9 + 63) & 0x80000000) == 0)
  {
    v11 = *(unsigned __int8 *)(v9 + 63);
    goto LABEL_10;
  }
  v11 = *(_QWORD *)(v9 + 48);
  if ((v11 & 0x8000000000000000) != 0 || ((v10 = (_QWORD *)*v10, v11) ? (v12 = v10 == 0) : (v12 = 0), v12))
  {
    __break(1u);
LABEL_30:
    abort();
  }
  if (v11 >= 0x3FFFFFFFFFFFFFFCLL)
    goto LABEL_30;
LABEL_10:
  v13 = 2 * v11;
  if (v11 >= 0xC)
  {
    v15 = (v13 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v15 = v13 | 7;
    v16 = v15 + 1;
    v14 = operator new(v15 + 1);
    __p[1] = (void *)(2 * v11);
    v23 = v16 | 0x8000000000000000;
    __p[0] = v14;
    goto LABEL_16;
  }
  HIBYTE(v23) = 2 * v11;
  v14 = __p;
  if (v11)
  {
LABEL_16:
    bzero(v14, 2 * v11);
    *((_BYTE *)v14 + 2 * v11) = 0;
    v17 = __p;
    if (v23 < 0)
      v17 = (void **)__p[0];
    v18 = (char *)v17 + 1;
    do
    {
      v19 = *(unsigned __int8 *)v10;
      v10 = (_QWORD *)((char *)v10 + 1);
      v18 += 2;
      --v11;
    }
    while (v11);
    goto LABEL_20;
  }
  LOBYTE(__p[0]) = 0;
LABEL_20:
  rtc::webrtc_logging_impl::Log("\r\n\t\n", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if ((v25 & 0x80000000) == 0)
      goto LABEL_22;
LABEL_27:
    operator delete(v24);
    v20 = *((_QWORD *)this + 8);
    if (!v20)
      return;
    goto LABEL_23;
  }
  operator delete(__p[0]);
  if (v25 < 0)
    goto LABEL_27;
LABEL_22:
  v20 = *((_QWORD *)this + 8);
  if (!v20)
    return;
LABEL_23:
  *(_DWORD *)(v20 + 176) = 0;
  v21 = (cricket::Connection *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v20 + 88) + 88))(*(_QWORD *)(v20 + 88), v20 + 104);
  if (v21)
    cricket::Connection::FailAndPrune(v21);
}

void cricket::TurnEntry::~TurnEntry(cricket::TurnEntry *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  webrtc::callback_list_impl::CallbackListReceivers *v8;
  _BYTE *v9;
  uint64_t v11;
  uint64_t v12;
  char v13;
  _BYTE *v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  void *v18;
  char *v19;
  char *v20;
  char *v21;
  void (*v22)(char *);
  std::string *v23;
  uint64_t v24;

  *(_QWORD *)this = &off_24C0C2C80;
  v8 = (cricket::TurnEntry *)((char *)this + 56);
  v9 = (char *)this + 80;
  if (*((_BYTE *)this + 80))
  {
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/callback_list.cc", 72, "!send_in_progress_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v24);
LABEL_27:
    v23 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/callback_list.cc", 21, "!send_in_progress_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v24);
    cricket::TurnEntry::~TurnEntry((cricket::TurnEntry *)v23);
    return;
  }
  *((_BYTE *)this + 80) = 1;
  v11 = *((_QWORD *)this + 7);
  v12 = *((_QWORD *)this + 8);
  if (v11 == v12)
  {
    *v9 = 0;
  }
  else
  {
    v13 = 0;
    do
    {
      (*(void (**)(uint64_t, cricket::TurnEntry *))(v11 + 40))(v11 + 8, this);
      v14 = *(_BYTE **)v11;
      v11 += 56;
      v13 |= v14 == v9;
    }
    while (v11 != v12);
    *v9 = 0;
    if ((v13 & 1) != 0)
      webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers(v8, v9);
  }
  v15 = *((_QWORD *)this + 26);
  *(_BYTE *)(v15 + 4) = 0;
  do
  {
    v16 = __ldaxr((unsigned int *)v15);
    v17 = v16 - 1;
  }
  while (__stlxr(v17, (unsigned int *)v15));
  if (!v17)
    MEMORY[0x20BD0ADEC]();
  v18 = (void *)*((_QWORD *)this + 23);
  if (v18)
  {
    *((_QWORD *)this + 24) = v18;
    operator delete(v18);
  }
  if (*((char *)this + 127) < 0)
    operator delete(*((void **)this + 13));
  if (*v9)
    goto LABEL_27;
  v19 = *(char **)v8;
  if (*(_QWORD *)v8)
  {
    v20 = (char *)*((_QWORD *)this + 8);
    v21 = *(char **)v8;
    if (v20 != v19)
    {
      do
      {
        v22 = (void (*)(char *))*((_QWORD *)v20 - 1);
        if (v22)
          v22(v20 - 48);
        v20 -= 56;
      }
      while (v20 != v19);
      v21 = *(char **)v8;
    }
    *((_QWORD *)this + 8) = v19;
    operator delete(v21);
  }
  *(_QWORD *)this = &unk_24C0ACE30;
  (*((void (**)(cricket::TurnEntry *))this + 3))(this);
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 32, *((_QWORD **)this + 5));
}

{
  cricket::TurnEntry::~TurnEntry(this, a2, a3, a4, a5, a6, a7, a8);
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::TurnAllocateRequest::~TurnAllocateRequest(cricket::TurnAllocateRequest *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C0C1B10;
  v2 = *((_QWORD *)this + 5);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  v5 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
}

{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C0C1B10;
  v2 = *((_QWORD *)this + 5);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  v5 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::TurnRefreshRequest::~TurnRefreshRequest(cricket::TurnRefreshRequest *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C0C1B10;
  v2 = *((_QWORD *)this + 5);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  v5 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
}

{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24C0C1B10;
  v2 = *((_QWORD *)this + 5);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  v5 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  JUMPOUT(0x20BD0ADECLL);
}

void std::__function::__func<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C0C2CA0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C0C2CA0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,rtc::AsyncPacketSocket *,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::operator()(uint64_t a1, const void **a2, uint64_t *a3, cricket::StunRequest *a4)
{
  cricket::TurnPort::OnSendStunPacket(*(cricket::TurnPort **)(a1 + 8), *a2, *a3, a4);
}

void std::__function::__func<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C0C2CE8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C0C2CE8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0,std::allocator<cricket::TurnPort::TurnPort(webrtc::TaskQueueBase *,rtc::PacketSocketFactory *,rtc::Network const*,unsigned short,unsigned short,std::string_view,std::string_view,cricket::ProtocolAddress const&,cricket::RelayCredentials const&,int,std::vector<std::string> const&,std::vector<std::string> const&,webrtc::TurnCustomizer *,rtc::SSLCertificateVerifier *,webrtc::FieldTrialsView const*)::$_0>,void ()(void const*,unsigned long,cricket::StunRequest *)>::operator()(uint64_t a1, const void **a2, uint64_t *a3, cricket::StunRequest *a4)
{
  cricket::TurnPort::OnSendStunPacket(*(cricket::TurnPort **)(a1 + 8), *a2, *a3, a4);
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnPort::CreateTurnClientSocket(void)::$_0 &,rtc::AsyncPacketSocket *,rtc::ReceivedPacket const&>(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 392))(*a1);
}

uint64_t sigslot::_opaque_connection::emitter<cricket::TurnPort,rtc::AsyncPacketSocket *>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = a1[1];
  if (v3)
    v4 = v3 - 232;
  else
    v4 = 0;
  v5 = (_QWORD *)(v4 + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v5 + v1);
  return v1(v5);
}

uint64_t sigslot::_opaque_connection::emitter<cricket::TurnPort,rtc::AsyncPacketSocket *,rtc::SentPacket const&>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = a1[1];
  if (v3)
    v4 = v3 - 232;
  else
    v4 = 0;
  v5 = (_QWORD *)(v4 + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v5 + v1);
  return v1(v5);
}

void std::__function::__func<cricket::TurnPort::CreateTurnClientSocket(void)::$_1,std::allocator<cricket::TurnPort::CreateTurnClientSocket(void)::$_1>,void ()(rtc::AsyncPacketSocket *,int)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<cricket::TurnPort::CreateTurnClientSocket(void)::$_1,std::allocator<cricket::TurnPort::CreateTurnClientSocket(void)::$_1>,void ()(rtc::AsyncPacketSocket *,int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C0C2D30;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<cricket::TurnPort::CreateTurnClientSocket(void)::$_1,std::allocator<cricket::TurnPort::CreateTurnClientSocket(void)::$_1>,void ()(rtc::AsyncPacketSocket *,int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C0C2D30;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<cricket::TurnPort::CreateTurnClientSocket(void)::$_1,std::allocator<cricket::TurnPort::CreateTurnClientSocket(void)::$_1>,void ()(rtc::AsyncPacketSocket *,int)>::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _OWORD *v10;
  uint64_t result;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  BOOL v15;
  void *__p;
  char v17;

  v1 = *(_QWORD *)(a1 + 8);
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0
    || ((*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v1 + 176))(&__p, v1),
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc"), (v17 & 0x80000000) == 0))
  {
    if (*(_DWORD *)(v1 + 1248) == 2)
      goto LABEL_5;
    goto LABEL_4;
  }
  operator delete(__p);
  if (*(_DWORD *)(v1 + 1248) != 2)
LABEL_4:
    cricket::TurnPort::OnAllocateError(v1, 701, &byte_208EB9246, 0);
LABEL_5:
  std::__tree<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>>>::destroy(v1 + 1088, *(char **)(v1 + 1096));
  *(_QWORD *)(v1 + 1088) = v1 + 1096;
  *(_QWORD *)(v1 + 1104) = 0;
  *(_QWORD *)(v1 + 1096) = 0;
  *(_DWORD *)(v1 + 1248) = 4;
  v9 = *(_QWORD **)(v1 + 672);
  v10 = (_OWORD *)(v1 + 680);
  if (v9 != (_QWORD *)(v1 + 680))
  {
    do
    {
      cricket::Connection::Shutdown((cricket::Connection *)v9[13]);
      v12 = v9[13];
      if (v12)
        (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
      v13 = (_QWORD *)v9[1];
      if (v13)
      {
        do
        {
          v14 = v13;
          v13 = (_QWORD *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          v14 = (_QWORD *)v9[2];
          v15 = *v14 == (_QWORD)v9;
          v9 = v14;
        }
        while (!v15);
      }
      v9 = v14;
    }
    while (v14 != (_QWORD *)v10);
  }
  std::__tree<rtc::SocketAddress>::destroy(v1 + 672, *(char **)(v1 + 680));
  *(_QWORD *)(v1 + 672) = v10;
  *v10 = 0u;
  result = *(_QWORD *)(v1 + 1304);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  return result;
}

void absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnPort::ResolveTurnAddress(rtc::SocketAddress const&)::$_0 &>(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  char v3;
  void **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  size_t v14;
  void *__p;
  unsigned int v16;
  char v17;
  void *__dst[2];
  uint64_t v19;
  void *v20;
  _BYTE v21[20];
  __int16 v22;
  int v23;
  char v24;

  v1 = *a1;
  v2 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*a1 + 1064) + 32))(*(_QWORD *)(*a1 + 1064));
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2) && (*(_DWORD *)(v1 + 864) | 2) == 3)
  {
    cricket::TurnPort::CreateTurnClientSocket((cricket::TurnPort *)v1);
    if ((v3 & 1) == 0)
      cricket::TurnPort::OnAllocateError(v1, 701, "TURN host lookup received error.", 0x20uLL);
    return;
  }
  v4 = (void **)(v1 + 792);
  __dst[0] = 0;
  __dst[1] = 0;
  v19 = 0;
  v20 = &unk_24C0ACDA0;
  memset(v21, 0, sizeof(v21));
  if (__dst != (void **)(v1 + 792))
  {
    if (*(char *)(v1 + 815) < 0)
    {
      std::string::__assign_no_alias<true>(__dst, *(char **)(v1 + 792), *(_QWORD *)(v1 + 800));
    }
    else
    {
      *(_OWORD *)__dst = *(_OWORD *)v4;
      v19 = *(_QWORD *)(v1 + 808);
    }
  }
  *(_DWORD *)v21 = *(_DWORD *)(v1 + 824);
  *(_OWORD *)&v21[4] = *(_OWORD *)(v1 + 828);
  v22 = *(_WORD *)(v1 + 848);
  v24 = *(_BYTE *)(v1 + 856);
  v23 = *(_DWORD *)(v1 + 852);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2)
    || (v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1),
        rtc::Network::GetBestIP(v5, (uint64_t)&__p),
        ((*(uint64_t (**)(uint64_t, _QWORD, void **))(*(_QWORD *)v2 + 16))(v2, v16, __dst) & 1) == 0))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v1 + 176))(&__p, v1);
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (v17 < 0)
        operator delete(__p);
    }
    *(_DWORD *)(v1 + 1072) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    cricket::TurnPort::OnAllocateError(v1, 701, "TURN host lookup received error.", 0x20uLL);
    if (SHIBYTE(v19) < 0)
      goto LABEL_29;
  }
  else
  {
    if (__dst != v4)
    {
      if (*(char *)(v1 + 815) < 0)
      {
        if (v19 >= 0)
          v13 = __dst;
        else
          v13 = (void **)__dst[0];
        if (v19 >= 0)
          v14 = HIBYTE(v19);
        else
          v14 = (size_t)__dst[1];
        std::string::__assign_no_alias<false>((std::string *)(v1 + 792), (const std::string::value_type *)v13, v14);
      }
      else if (v19 < 0)
      {
        std::string::__assign_no_alias<true>((_QWORD *)(v1 + 792), (char *)__dst[0], (size_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)v4 = *(_OWORD *)__dst;
        *(_QWORD *)(v1 + 808) = v19;
      }
    }
    *(_DWORD *)(v1 + 824) = *(_DWORD *)v21;
    *(_OWORD *)(v1 + 828) = *(_OWORD *)&v21[4];
    *(_WORD *)(v1 + 848) = v22;
    *(_BYTE *)(v1 + 856) = v24;
    *(_DWORD *)(v1 + 852) = v23;
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 80))(v1);
    if (SHIBYTE(v19) < 0)
LABEL_29:
      operator delete(__dst[0]);
  }
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnPort::OnAllocateError(int,std::string_view)::$_0 &&>(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  void (*v5)(uint64_t, uint64_t);

  v1 = *a1;
  v2 = *a1 + 472;
  result = *(_QWORD *)(*a1 + 480);
  for (*(_QWORD *)(v1 + 496) = result; result != v2; result = *(_QWORD *)(v1 + 496))
  {
    v5 = *(void (**)(uint64_t, uint64_t))(result + 16);
    v4 = result + 16;
    *(_QWORD *)(v1 + 496) = *(_QWORD *)(v4 - 8);
    v5(v4, v1);
  }
  return result;
}

void absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnPort::OnRefreshError(void)::$_0 &&>(uint64_t *a1)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;
  void *__p[2];
  uint64_t v8;
  void *v9;
  _DWORD v10[6];
  __int16 v11;
  int v12;
  char v13;
  cricket::Connection *v14;

  v1 = *a1;
  std::__tree<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>>>::destroy(*a1 + 1088, *(char **)(*a1 + 1096));
  *(_QWORD *)(v1 + 1088) = v1 + 1096;
  *(_QWORD *)(v1 + 1104) = 0;
  *(_QWORD *)(v1 + 1096) = 0;
  *(_DWORD *)(v1 + 1248) = 3;
  v2 = *(_QWORD **)(v1 + 672);
  v3 = (_QWORD *)(v1 + 680);
  if (v2 != v3)
  {
    do
    {
      __p[0] = 0;
      __p[1] = 0;
      v8 = 0;
      v9 = &unk_24C0ACDA0;
      memset(v10, 0, 20);
      if (__p != v2 + 4)
      {
        if (*((char *)v2 + 55) < 0)
        {
          std::string::__assign_no_alias<true>(__p, (char *)v2[4], v2[5]);
        }
        else
        {
          *(_OWORD *)__p = *((_OWORD *)v2 + 2);
          v8 = v2[6];
        }
      }
      v10[0] = *((_DWORD *)v2 + 16);
      *(_OWORD *)&v10[1] = *(_OWORD *)((char *)v2 + 68);
      v11 = *((_WORD *)v2 + 44);
      v13 = *((_BYTE *)v2 + 96);
      v12 = *((_DWORD *)v2 + 23);
      v14 = (cricket::Connection *)v2[13];
      cricket::Connection::FailAndPrune(v14);
      if (SHIBYTE(v8) < 0)
      {
        operator delete(__p[0]);
        v4 = (_QWORD *)v2[1];
        if (v4)
        {
          do
          {
LABEL_12:
            v5 = v4;
            v4 = (_QWORD *)*v4;
          }
          while (v4);
          goto LABEL_3;
        }
      }
      else
      {
        v4 = (_QWORD *)v2[1];
        if (v4)
          goto LABEL_12;
      }
      do
      {
        v5 = (_QWORD *)v2[2];
        v6 = *v5 == (_QWORD)v2;
        v2 = v5;
      }
      while (!v6);
LABEL_3:
      v2 = v5;
    }
    while (v5 != v3);
  }
}

_QWORD *absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnPort::HandleConnectionDestroyed(cricket::Connection *)::$_0 &&>(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  v1 = *result;
  v2 = *(_QWORD **)(*result + 1224);
  v3 = *(_QWORD **)(*result + 1232);
  if (v2 == v3)
    goto LABEL_5;
  do
  {
    if (*v2 == result[1])
      goto LABEL_5;
    ++v2;
  }
  while (v2 != v3);
  do
  {
    __break(1u);
LABEL_5:
    ;
  }
  while (v3 == v2);
  v4 = v2 + 1;
  if (v2 + 1 != v3)
  {
    do
    {
      result = (_QWORD *)*(v4 - 1);
      *(v4 - 1) = *v4;
      *v4 = 0;
      if (result)
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
      ++v4;
    }
    while (v4 != v3);
    v3 = *(_QWORD **)(v1 + 1232);
    v2 = v4 - 1;
  }
  while (v3 != v2)
  {
    v5 = (_QWORD *)*--v3;
    result = v5;
    *v3 = 0;
    if (v5)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
  }
  *(_QWORD *)(v1 + 1232) = v2;
  return result;
}

void absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnAllocateRequest::OnErrorResponse(cricket::StunMessage *)::$_0 &&>(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17[2];
  char v18;

  v1 = *(_QWORD **)a1;
  if (*(_QWORD *)(*(_QWORD *)a1 + 1256) < 2uLL)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      (*(void (**)(void **__return_ptr, _QWORD *))(*v1 + 176))(v17, v1);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long> const&)::t, v9, v10, v11, v12, v13, v14, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
      if (v18 < 0)
        operator delete(v17[0]);
    }
    webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(v1[129] + 280), v1);
    if ((*(unsigned int (**)(_QWORD *))(*v1 + 64))(v1))
    {
      *((_BYTE *)v1 + 720) = 0;
    }
    else
    {
      v16 = v1[129];
      if (v16)
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
    }
    v1[129] = 0;
    if (*((char *)v1 + 1215) < 0)
    {
      *(_BYTE *)v1[149] = 0;
      v1[150] = 0;
      if ((*((char *)v1 + 1191) & 0x80000000) == 0)
      {
LABEL_15:
        *((_BYTE *)v1 + 1168) = 0;
        *((_BYTE *)v1 + 1191) = 0;
        if ((*((char *)v1 + 1167) & 0x80000000) == 0)
        {
LABEL_16:
          *((_BYTE *)v1 + 1144) = 0;
          *((_BYTE *)v1 + 1167) = 0;
LABEL_20:
          (*(void (**)(_QWORD *))(*v1 + 80))(v1);
          ++v1[157];
          return;
        }
LABEL_19:
        *(_BYTE *)v1[143] = 0;
        v1[144] = 0;
        goto LABEL_20;
      }
    }
    else
    {
      *((_BYTE *)v1 + 1192) = 0;
      *((_BYTE *)v1 + 1215) = 0;
      if ((*((char *)v1 + 1191) & 0x80000000) == 0)
        goto LABEL_15;
    }
    *(_BYTE *)v1[146] = 0;
    v1[147] = 0;
    if ((*((char *)v1 + 1167) & 0x80000000) == 0)
      goto LABEL_16;
    goto LABEL_19;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
  {
    (*(void (**)(void **__return_ptr, _QWORD *))(*v1 + 176))(v17, v1);
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/turn_port.cc");
    if (v18 < 0)
      operator delete(v17[0]);
  }
  cricket::TurnPort::OnAllocateError((uint64_t)v1, 437, "Maximum retries reached for allocation mismatch.", 0x30uLL);
}

void absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnAllocateRequest::OnTryAlternate(cricket::StunMessage *,int)::$_0 &&>(cricket::TurnPort **a1)
{
  cricket::TurnPort *v1;
  uint64_t v2;
  cricket::TurnAllocateRequest *v3;
  const void **v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  cricket::TurnAllocateRequest *v10;

  v1 = *a1;
  if (*((_DWORD *)*a1 + 216))
  {
    v2 = *((_QWORD *)v1 + 129);
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)v1 + 129) = 0;
    (*(void (**)(cricket::TurnPort *))(*(_QWORD *)v1 + 80))(v1);
  }
  else
  {
    v3 = (cricket::TurnAllocateRequest *)operator new();
    cricket::TurnAllocateRequest::TurnAllocateRequest(v3, v1);
    v4 = (const void **)(*((_QWORD *)v3 + 2) + 40);
    v10 = v3;
    std::__tree<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<cricket::StunRequest>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<cricket::StunRequest>>((uint64_t)v1 + 1088, v4, (uint64_t)v4, (uint64_t *)&v10);
    v5 = (uint64_t)v10;
    v10 = 0;
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    v6 = *((_QWORD *)v3 + 5);
    if (v6)
    {
      do
        v7 = __ldxr((unsigned int *)v6);
      while (__stxr(v7 + 1, (unsigned int *)v6));
      *(_BYTE *)(v6 + 4) = 1;
      do
      {
        v8 = __ldaxr((unsigned int *)v6);
        v9 = v8 - 1;
      }
      while (__stlxr(v9, (unsigned int *)v6));
      if (!v9)
        MEMORY[0x20BD0ADEC]();
      cricket::StunRequest::SendInternal(v3);
    }
    else
    {
      MEMORY[4] = 1;
      cricket::StunRequest::SendInternal(v3);
    }
  }
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,cricket::TurnRefreshRequest::OnResponse(cricket::StunMessage *)::$_0 &&>(uint64_t *a1)
{
  uint64_t v1;
  _QWORD *v2;
  _OWORD *v3;
  uint64_t result;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;

  v1 = *a1;
  if (*(_DWORD *)(*a1 + 1248) != 2)
    cricket::TurnPort::OnAllocateError(*a1, 701, &byte_208EB9246, 0);
  std::__tree<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<webrtc::RTCStats const>>>>::destroy(v1 + 1088, *(char **)(v1 + 1096));
  *(_QWORD *)(v1 + 1088) = v1 + 1096;
  *(_QWORD *)(v1 + 1104) = 0;
  *(_QWORD *)(v1 + 1096) = 0;
  *(_DWORD *)(v1 + 1248) = 4;
  v2 = *(_QWORD **)(v1 + 672);
  v3 = (_OWORD *)(v1 + 680);
  if (v2 != (_QWORD *)(v1 + 680))
  {
    do
    {
      cricket::Connection::Shutdown((cricket::Connection *)v2[13]);
      v5 = v2[13];
      if (v5)
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      v6 = (_QWORD *)v2[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v2[2];
          v8 = *v7 == (_QWORD)v2;
          v2 = v7;
        }
        while (!v8);
      }
      v2 = v7;
    }
    while (v7 != (_QWORD *)v3);
  }
  std::__tree<rtc::SocketAddress>::destroy(v1 + 672, *(char **)(v1 + 680));
  *(_QWORD *)(v1 + 672) = v3;
  *v3 = 0u;
  result = *(_QWORD *)(v1 + 1304);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  return result;
}

uint64_t webrtc::webrtc_function_impl::CallHelpers<void ()(cricket::TurnEntry *)>::CallInlineStorage<cricket::TurnCreatePermissionRequest::TurnCreatePermissionRequest(cricket::TurnPort *,cricket::TurnEntry *,rtc::SocketAddress const&)::$_0>(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)result + 64) = 0;
  return result;
}

uint64_t webrtc::webrtc_function_impl::CallHelpers<void ()(cricket::TurnEntry *)>::CallInlineStorage<cricket::TurnChannelBindRequest::TurnChannelBindRequest(cricket::TurnPort *,cricket::TurnEntry *,int,rtc::SocketAddress const&)::$_0>(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)result + 64) = 0;
  return result;
}

void cricket::TurnPortFactory::~TurnPortFactory(cricket::TurnPortFactory *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

void cricket::TurnPortFactory::Create(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  void **v9;
  size_t v10;
  void **v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 *v15;
  size_t v16;
  __int128 *v17;
  uint64_t v18;
  uint64_t v19;
  __int128 *v20;
  void **v22;
  __int128 v23;
  unint64_t v24;

  if (!cricket::TurnPort::Validate(a1))
  {
    v8 = 0;
    goto LABEL_33;
  }
  v6 = operator new();
  v8 = v6;
  v9 = (void **)(a1 + 40);
  if (*(char *)(a1 + 63) < 0)
  {
    v10 = *(_QWORD *)(a1 + 48);
    if ((v10 & 0x8000000000000000) != 0)
      goto LABEL_34;
    v9 = (void **)*v9;
    if (v10)
    {
      if (!v9)
        goto LABEL_34;
    }
  }
  else
  {
    v10 = *(unsigned __int8 *)(a1 + 63);
  }
  v11 = (void **)(a1 + 64);
  if (*(char *)(a1 + 87) < 0)
  {
    v12 = *(_QWORD *)(a1 + 72);
    if ((v12 & 0x8000000000000000) != 0)
      goto LABEL_34;
    v11 = (void **)*v11;
    if (v12)
    {
      if (!v11)
        goto LABEL_34;
    }
  }
  else
  {
    v12 = *(unsigned __int8 *)(a1 + 87);
  }
  v13 = cricket::TurnPort::TurnPort(v6, *(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), a2, v9, v10, v7, v11, v12, *(__int128 **)(a1 + 24), (__int128 *)(*(_QWORD *)(a1 + 32) + 24), *(_DWORD *)(a1 + 104), (uint64_t *)(*(_QWORD *)(a1 + 32) + 80), (uint64_t *)(*(_QWORD *)(a1 + 32) + 104), *(_QWORD *)(a1 + 88), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 128), *(_QWORD *)(a1 + 96));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 368))(v13, *(unsigned int *)(*(_QWORD *)(a1 + 32) + 72));
  v14 = *(_QWORD *)(a1 + 32);
  v15 = (__int128 *)(v14 + 136);
  if ((*(char *)(v14 + 159) & 0x80000000) == 0)
  {
    v16 = *(unsigned __int8 *)(v14 + 159);
    goto LABEL_19;
  }
  v16 = *(_QWORD *)(v14 + 144);
  if ((v16 & 0x8000000000000000) != 0 || (v15 = *(__int128 **)v15, v16) && !v15)
  {
LABEL_34:
    __break(1u);
LABEL_35:
    abort();
  }
  if (v16 >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_35;
LABEL_19:
  if (v16 > 0x16)
  {
    v18 = (v16 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17)
      v18 = v16 | 7;
    v19 = v18 + 1;
    v17 = (__int128 *)operator new(v18 + 1);
    *((_QWORD *)&v23 + 1) = v16;
    v24 = v19 | 0x8000000000000000;
    *(_QWORD *)&v23 = v17;
  }
  else
  {
    HIBYTE(v24) = v16;
    v17 = &v23;
  }
  v20 = (__int128 *)((char *)v17 + v16);
  if (v17 <= v15 && v20 > v15)
    goto LABEL_34;
  if (v16)
    memmove(v17, v15, v16);
  *(_BYTE *)v20 = 0;
  v22 = (void **)(v8 + 1272);
  if (*(char *)(v8 + 1295) < 0)
    operator delete(*v22);
  *(_OWORD *)v22 = v23;
  *(_QWORD *)(v8 + 1288) = v24;
LABEL_33:
  *a3 = v8;
}

void cricket::TurnPortFactory::Create(uint64_t a1@<X1>, __int16 a2@<W2>, __int16 a3@<W3>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  void **v10;
  size_t v11;
  void **v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 *v16;
  size_t v17;
  __int128 *v18;
  uint64_t v19;
  uint64_t v20;
  __int128 *v21;
  void **v23;
  __int128 v24;
  unint64_t v25;

  if (!cricket::TurnPort::Validate(a1))
  {
    v9 = 0;
    goto LABEL_33;
  }
  v8 = operator new();
  v9 = v8;
  v10 = (void **)(a1 + 40);
  if (*(char *)(a1 + 63) < 0)
  {
    v11 = *(_QWORD *)(a1 + 48);
    if ((v11 & 0x8000000000000000) != 0)
      goto LABEL_34;
    v10 = (void **)*v10;
    if (v11)
    {
      if (!v10)
        goto LABEL_34;
    }
  }
  else
  {
    v11 = *(unsigned __int8 *)(a1 + 63);
  }
  v12 = (void **)(a1 + 64);
  if (*(char *)(a1 + 87) < 0)
  {
    v13 = *(_QWORD *)(a1 + 72);
    if ((v13 & 0x8000000000000000) != 0)
      goto LABEL_34;
    v12 = (void **)*v12;
    if (v13)
    {
      if (!v12)
        goto LABEL_34;
    }
  }
  else
  {
    v13 = *(unsigned __int8 *)(a1 + 87);
  }
  v14 = cricket::TurnPort::TurnPort(v8, *(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), a2, a3, v10, v11, v12, v13, *(__int128 **)(a1 + 24), (__int128 *)(*(_QWORD *)(a1 + 32) + 24), *(_DWORD *)(a1 + 104), (uint64_t *)(*(_QWORD *)(a1 + 32) + 80), (uint64_t *)(*(_QWORD *)(a1 + 32) + 104), *(_QWORD *)(a1 + 88), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 128), *(_QWORD *)(a1 + 96));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 368))(v14, *(unsigned int *)(*(_QWORD *)(a1 + 32) + 72));
  v15 = *(_QWORD *)(a1 + 32);
  v16 = (__int128 *)(v15 + 136);
  if ((*(char *)(v15 + 159) & 0x80000000) == 0)
  {
    v17 = *(unsigned __int8 *)(v15 + 159);
    goto LABEL_19;
  }
  v17 = *(_QWORD *)(v15 + 144);
  if ((v17 & 0x8000000000000000) != 0 || (v16 = *(__int128 **)v16, v17) && !v16)
  {
LABEL_34:
    __break(1u);
LABEL_35:
    abort();
  }
  if (v17 >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_35;
LABEL_19:
  if (v17 > 0x16)
  {
    v19 = (v17 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17)
      v19 = v17 | 7;
    v20 = v19 + 1;
    v18 = (__int128 *)operator new(v19 + 1);
    *((_QWORD *)&v24 + 1) = v17;
    v25 = v20 | 0x8000000000000000;
    *(_QWORD *)&v24 = v18;
  }
  else
  {
    HIBYTE(v25) = v17;
    v18 = &v24;
  }
  v21 = (__int128 *)((char *)v18 + v17);
  if (v18 <= v16 && v21 > v16)
    goto LABEL_34;
  if (v17)
    memmove(v18, v16, v17);
  *(_BYTE *)v21 = 0;
  v23 = (void **)(v9 + 1272);
  if (*(char *)(v9 + 1295) < 0)
    operator delete(*v23);
  *(_OWORD *)v23 = v24;
  *(_QWORD *)(v9 + 1288) = v25;
LABEL_33:
  *a4 = v9;
}

uint64_t cricket::TurnPort::Validate(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(char *)(v1 + 47) < 0 && *(_QWORD *)(v1 + 32) >= 0x1FEuLL)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long> const&)::t, v2, v3, v4, v5, v6, v7, v8, (uint64_t)"Source/webrtc/p2p/base/turn_port.h");
    return 0;
  }
  v9 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 24) + 56);
  result = 1;
  if (v9 <= 0x3FF && v9 != 53 && v9 != 80 && v9 != 443)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v11, v12, v13, v14, v15, v16, v17, (uint64_t)"Source/webrtc/p2p/base/turn_port.h");
    return 0;
  }
  return result;
}

uint64_t webrtc::UlpfecGenerator::UlpfecGenerator(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  pthread_mutexattr_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = &off_24C0C2DA8;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 24) = 0;
  v5 = operator new();
  *(_OWORD *)(v5 + 8) = xmmword_208F09F80;
  *(_QWORD *)v5 = &unk_24C0C2E08;
  v6 = operator new();
  *(int64x2_t *)(v6 + 8) = vdupq_n_s64(0x30uLL);
  *(_QWORD *)(v6 + 24) = 18;
  *(_QWORD *)v6 = &unk_24C0C2E30;
  v7 = (_QWORD *)operator new();
  *v7 = 0;
  v7[1] = v5;
  v7[2] = v6;
  v8 = operator new(0x780uLL);
  *v8 = &off_24C0B43E8;
  v8[1] = 0;
  v8[2] = 0;
  v8[3] = 0;
  *((_DWORD *)v8 + 8) = 0;
  v8[5] = &off_24C0B43E8;
  v8[6] = 0;
  v8[7] = 0;
  v8[8] = 0;
  *((_DWORD *)v8 + 18) = 0;
  v8[10] = &off_24C0B43E8;
  v8[11] = 0;
  v8[12] = 0;
  v8[13] = 0;
  *((_DWORD *)v8 + 28) = 0;
  v8[15] = &off_24C0B43E8;
  v8[16] = 0;
  *((_DWORD *)v8 + 38) = 0;
  v8[17] = 0;
  v8[18] = 0;
  *((_DWORD *)v8 + 48) = 0;
  v8[20] = &off_24C0B43E8;
  v8[21] = 0;
  v8[22] = 0;
  v8[23] = 0;
  *((_DWORD *)v8 + 58) = 0;
  v8[25] = &off_24C0B43E8;
  v8[26] = 0;
  v8[27] = 0;
  v8[28] = 0;
  *((_DWORD *)v8 + 68) = 0;
  v8[30] = &off_24C0B43E8;
  v8[31] = 0;
  v8[32] = 0;
  v8[33] = 0;
  v8[35] = &off_24C0B43E8;
  v8[36] = 0;
  *((_DWORD *)v8 + 78) = 0;
  v8[37] = 0;
  v8[38] = 0;
  v8[40] = &off_24C0B43E8;
  v8[41] = 0;
  *((_DWORD *)v8 + 88) = 0;
  v8[42] = 0;
  v8[43] = 0;
  v8[45] = &off_24C0B43E8;
  v8[46] = 0;
  *((_DWORD *)v8 + 98) = 0;
  v8[47] = 0;
  v8[48] = 0;
  v8[50] = &off_24C0B43E8;
  v8[51] = 0;
  *((_DWORD *)v8 + 108) = 0;
  v8[52] = 0;
  v8[53] = 0;
  v8[55] = &off_24C0B43E8;
  v8[56] = 0;
  *((_DWORD *)v8 + 118) = 0;
  v8[57] = 0;
  v8[58] = 0;
  v8[60] = &off_24C0B43E8;
  v8[61] = 0;
  *((_DWORD *)v8 + 128) = 0;
  v8[62] = 0;
  v8[63] = 0;
  v8[65] = &off_24C0B43E8;
  v8[67] = 0;
  v8[66] = 0;
  *((_DWORD *)v8 + 138) = 0;
  v8[68] = 0;
  v8[70] = &off_24C0B43E8;
  v8[72] = 0;
  v8[71] = 0;
  *((_DWORD *)v8 + 148) = 0;
  v8[73] = 0;
  v8[75] = &off_24C0B43E8;
  v8[77] = 0;
  v8[76] = 0;
  *((_DWORD *)v8 + 158) = 0;
  v8[78] = 0;
  v8[80] = &off_24C0B43E8;
  v8[82] = 0;
  v8[81] = 0;
  *((_DWORD *)v8 + 168) = 0;
  v8[83] = 0;
  v8[85] = &off_24C0B43E8;
  v8[87] = 0;
  v8[86] = 0;
  *((_DWORD *)v8 + 178) = 0;
  v8[88] = 0;
  v8[90] = &off_24C0B43E8;
  v8[92] = 0;
  v8[91] = 0;
  *((_DWORD *)v8 + 188) = 0;
  v8[93] = 0;
  v8[95] = &off_24C0B43E8;
  v8[97] = 0;
  v8[96] = 0;
  *((_DWORD *)v8 + 198) = 0;
  v8[98] = 0;
  v8[100] = &off_24C0B43E8;
  v8[102] = 0;
  v8[101] = 0;
  *((_DWORD *)v8 + 208) = 0;
  v8[103] = 0;
  v8[105] = &off_24C0B43E8;
  v8[107] = 0;
  v8[106] = 0;
  *((_DWORD *)v8 + 218) = 0;
  v8[108] = 0;
  v8[110] = &off_24C0B43E8;
  v8[112] = 0;
  v8[111] = 0;
  *((_DWORD *)v8 + 228) = 0;
  v8[113] = 0;
  v8[115] = &off_24C0B43E8;
  v8[117] = 0;
  v8[116] = 0;
  *((_DWORD *)v8 + 238) = 0;
  v8[118] = 0;
  v8[120] = &off_24C0B43E8;
  v8[122] = 0;
  v8[121] = 0;
  *((_DWORD *)v8 + 248) = 0;
  v8[123] = 0;
  v8[125] = &off_24C0B43E8;
  v8[127] = 0;
  v8[126] = 0;
  *((_DWORD *)v8 + 258) = 0;
  v8[128] = 0;
  v8[130] = &off_24C0B43E8;
  v8[132] = 0;
  v8[131] = 0;
  *((_DWORD *)v8 + 268) = 0;
  v8[133] = 0;
  v8[135] = &off_24C0B43E8;
  v8[137] = 0;
  v8[136] = 0;
  *((_DWORD *)v8 + 278) = 0;
  v8[138] = 0;
  v8[140] = &off_24C0B43E8;
  v8[142] = 0;
  v8[141] = 0;
  *((_DWORD *)v8 + 288) = 0;
  v8[143] = 0;
  v8[145] = &off_24C0B43E8;
  v8[147] = 0;
  v8[146] = 0;
  *((_DWORD *)v8 + 298) = 0;
  v8[148] = 0;
  v8[150] = &off_24C0B43E8;
  v8[152] = 0;
  v8[151] = 0;
  *((_DWORD *)v8 + 308) = 0;
  v8[153] = 0;
  v8[155] = &off_24C0B43E8;
  v8[157] = 0;
  v8[156] = 0;
  *((_DWORD *)v8 + 318) = 0;
  v8[158] = 0;
  v8[160] = &off_24C0B43E8;
  v8[162] = 0;
  v8[161] = 0;
  *((_DWORD *)v8 + 328) = 0;
  v8[163] = 0;
  v8[165] = &off_24C0B43E8;
  v8[167] = 0;
  v8[166] = 0;
  *((_DWORD *)v8 + 338) = 0;
  v8[168] = 0;
  v8[170] = &off_24C0B43E8;
  v8[172] = 0;
  v8[171] = 0;
  *((_DWORD *)v8 + 348) = 0;
  v8[173] = 0;
  v8[175] = &off_24C0B43E8;
  v8[177] = 0;
  v8[176] = 0;
  *((_DWORD *)v8 + 358) = 0;
  v8[178] = 0;
  v8[180] = &off_24C0B43E8;
  v8[182] = 0;
  v8[181] = 0;
  *((_DWORD *)v8 + 368) = 0;
  v8[183] = 0;
  v8[185] = &off_24C0B43E8;
  v8[187] = 0;
  v8[186] = 0;
  *((_DWORD *)v8 + 378) = 0;
  v8[188] = 0;
  v8[190] = &off_24C0B43E8;
  v8[192] = 0;
  v8[191] = 0;
  *((_DWORD *)v8 + 388) = 0;
  v8[193] = 0;
  v8[195] = &off_24C0B43E8;
  v8[197] = 0;
  v8[196] = 0;
  *((_DWORD *)v8 + 398) = 0;
  v8[198] = 0;
  v8[200] = &off_24C0B43E8;
  v8[202] = 0;
  v8[201] = 0;
  *((_DWORD *)v8 + 408) = 0;
  v8[203] = 0;
  v8[205] = &off_24C0B43E8;
  v8[207] = 0;
  v8[206] = 0;
  *((_DWORD *)v8 + 418) = 0;
  v8[208] = 0;
  v8[210] = &off_24C0B43E8;
  v8[212] = 0;
  v8[211] = 0;
  *((_DWORD *)v8 + 428) = 0;
  v8[213] = 0;
  v8[215] = &off_24C0B43E8;
  v8[217] = 0;
  v8[216] = 0;
  *((_DWORD *)v8 + 438) = 0;
  v8[218] = 0;
  v8[220] = &off_24C0B43E8;
  v8[222] = 0;
  v8[221] = 0;
  *((_DWORD *)v8 + 448) = 0;
  v8[223] = 0;
  v8[225] = &off_24C0B43E8;
  v8[227] = 0;
  v8[226] = 0;
  *((_DWORD *)v8 + 458) = 0;
  v8[228] = 0;
  v8[230] = &off_24C0B43E8;
  v8[232] = 0;
  v8[231] = 0;
  *((_DWORD *)v8 + 468) = 0;
  v8[233] = 0;
  v8[235] = &off_24C0B43E8;
  v8[237] = 0;
  v8[236] = 0;
  *((_DWORD *)v8 + 478) = 0;
  v8[238] = 0;
  v7[3] = v8;
  v7[4] = v8 + 240;
  v7[5] = v8 + 240;
  v7[6] = v7 + 6;
  v7[7] = v7 + 6;
  v7[8] = 0;
  v7[81] = 0;
  *(_QWORD *)(a1 + 40) = v7;
  *(_QWORD *)(a1 + 48) = a1 + 48;
  *(_QWORD *)(a1 + 56) = a1 + 48;
  *(_QWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = a1 + 288;
  *(_QWORD *)(a1 + 296) = a1 + 288;
  *(_QWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 312) = 0x100000000;
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  *(_BYTE *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 336) = 0;
  pthread_mutexattr_init(&v10);
  pthread_mutexattr_setpolicy_np(&v10, 3);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 352), &v10);
  pthread_mutexattr_destroy(&v10);
  *(_BYTE *)(a1 + 416) = 0;
  *(_BYTE *)(a1 + 440) = 0;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_QWORD *)(a1 + 496) = 0;
  *(_QWORD *)(a1 + 504) = -1;
  *(_BYTE *)(a1 + 512) = 0;
  *(_QWORD *)(a1 + 516) = 0x45FA000000000000;
  *(int64x2_t *)(a1 + 528) = vdupq_n_s64(0x3E8uLL);
  return a1;
}

void webrtc::UlpfecGenerator::~UlpfecGenerator(webrtc::UlpfecGenerator *this)
{
  webrtc::UlpfecGenerator *v2;
  uint64_t v3;
  uint64_t v4;
  webrtc::UlpfecGenerator *v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  webrtc::UlpfecGenerator *v17;
  uint64_t v18;
  webrtc::ForwardErrorCorrection *v19;
  uint64_t v20;
  webrtc::UlpfecGenerator *v21;

  *(_QWORD *)this = &off_24C0C2DA8;
  std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100]((void **)this + 56);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 352));
  if (*((_QWORD *)this + 38))
  {
    v3 = *((_QWORD *)this + 36);
    v2 = (webrtc::UlpfecGenerator *)*((_QWORD *)this + 37);
    v4 = *(_QWORD *)v2;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(v3 + 8);
    **(_QWORD **)(v3 + 8) = v4;
    *((_QWORD *)this + 38) = 0;
    if (v2 != (webrtc::UlpfecGenerator *)((char *)this + 288))
    {
      do
      {
        v5 = (webrtc::UlpfecGenerator *)*((_QWORD *)v2 + 1);
        operator delete(v2);
        v2 = v5;
      }
      while (v5 != (webrtc::UlpfecGenerator *)((char *)this + 288));
    }
  }
  if (*((_BYTE *)this + 280))
  {
    v6 = (unsigned int *)*((_QWORD *)this + 31);
    if (v6)
    {
      v7 = v6 + 2;
      do
      {
        v8 = __ldaxr(v7);
        v9 = v8 - 1;
      }
      while (__stlxr(v9, v7));
      if (!v9)
        (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
    v10 = *((_QWORD *)this + 20);
    if (v10)
    {
      v11 = (unsigned int *)(v10 + 24);
      do
      {
        v12 = __ldaxr(v11);
        v13 = v12 - 1;
      }
      while (__stlxr(v13, v11));
      if (!v13)
      {
        v14 = *(_QWORD *)(v10 + 16);
        *(_QWORD *)(v10 + 16) = 0;
        if (v14)
          MEMORY[0x20BD0ADD4](v14, 0x1000C8077774924);
        MEMORY[0x20BD0ADEC](v10, 0x1010C40EE34DA14);
      }
    }
    v15 = (void *)*((_QWORD *)this + 16);
    if (v15)
    {
      *((_QWORD *)this + 17) = v15;
      operator delete(v15);
    }
  }
  if (*((_QWORD *)this + 8))
  {
    v16 = *((_QWORD *)this + 6);
    v17 = (webrtc::UlpfecGenerator *)*((_QWORD *)this + 7);
    v18 = *(_QWORD *)v17;
    *(_QWORD *)(v18 + 8) = *(_QWORD *)(v16 + 8);
    **(_QWORD **)(v16 + 8) = v18;
    *((_QWORD *)this + 8) = 0;
    if (v17 != (webrtc::UlpfecGenerator *)((char *)this + 48))
    {
      do
      {
        v21 = (webrtc::UlpfecGenerator *)*((_QWORD *)v17 + 1);
        v20 = *((_QWORD *)v17 + 2);
        *((_QWORD *)v17 + 2) = 0;
        if (v20)
          (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
        operator delete(v17);
        v17 = v21;
      }
      while (v21 != (webrtc::UlpfecGenerator *)((char *)this + 48));
    }
  }
  v19 = (webrtc::ForwardErrorCorrection *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v19)
  {
    webrtc::ForwardErrorCorrection::~ForwardErrorCorrection(v19);
    MEMORY[0x20BD0ADEC]();
  }
}

{
  webrtc::UlpfecGenerator::~UlpfecGenerator(this);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::UlpfecGenerator::SetProtectionParameters(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  pthread_mutex_t *v6;
  int v7;
  uint64_t v8;
  int v9;

  v6 = (pthread_mutex_t *)(a1 + 352);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 352));
  if (*(_BYTE *)(a1 + 440))
    *(_BYTE *)(a1 + 440) = 0;
  v7 = *(_DWORD *)(a2 + 8);
  v8 = *a3;
  v9 = *((_DWORD *)a3 + 2);
  *(_QWORD *)(a1 + 416) = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 424) = v7;
  *(_QWORD *)(a1 + 428) = v8;
  *(_DWORD *)(a1 + 436) = v9;
  *(_BYTE *)(a1 + 440) = 1;
  return pthread_mutex_unlock(v6);
}

void webrtc::UlpfecGenerator::AddPacketAndGenerateFec(webrtc::UlpfecGenerator *this, const webrtc::RtpPacketToSend *a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  _QWORD *v14;
  uint64_t v15;
  _OWORD *v16;
  char *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  unint64_t v23;
  BOOL v24;
  unint64_t v25;
  float v26;
  int v27;
  _BOOL4 v28;
  _BOOL4 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _BYTE *v33;
  _BYTE *v34;
  int64_t v35;
  char *v36;
  char *v37;
  uint64_t v38;
  unsigned int *v39;
  unsigned int v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  unsigned int *v45;
  unsigned int v46;
  __int128 v47;

  v4 = (pthread_mutex_t *)((char *)this + 352);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 352));
  if (*((_BYTE *)this + 440))
  {
    *((_OWORD *)this + 20) = *((_OWORD *)this + 26);
    *((_QWORD *)this + 42) = *((_QWORD *)this + 54);
    *((_BYTE *)this + 440) = 0;
    v5 = 332;
    if (!*((_BYTE *)this + 344))
      v5 = 320;
    if (*(int *)((char *)this + v5) <= 80)
      v6 = 1;
    else
      v6 = 4;
    *((_DWORD *)this + 79) = v6;
  }
  pthread_mutex_unlock(v4);
  if (*((_BYTE *)a2 + 185))
    *((_BYTE *)this + 344) = 1;
  v8 = *(unsigned __int8 *)a2;
  if (*((_QWORD *)this + 8) <= 0x2FuLL)
  {
    v9 = operator new();
    v10 = v9;
    *(_QWORD *)v9 = &off_24C0B43E8;
    *(_DWORD *)(v9 + 32) = 0;
    v11 = *((_QWORD *)a2 + 11);
    if (v11)
    {
      v12 = (unsigned int *)(v11 + 24);
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    *(_QWORD *)(v9 + 8) = v11;
    *(_OWORD *)(v9 + 16) = *((_OWORD *)a2 + 6);
    v14 = operator new(0x18uLL);
    v14[1] = (char *)this + 48;
    v14[2] = v10;
    v15 = *((_QWORD *)this + 6);
    *v14 = v15;
    *(_QWORD *)(v15 + 8) = v14;
    *((_QWORD *)this + 6) = v14;
    ++*((_QWORD *)this + 8);
    v16 = (_OWORD *)((char *)this + 72);
    if (!*((_BYTE *)this + 280))
    {
      v30 = *(_OWORD *)a2;
      v31 = *((_OWORD *)a2 + 1);
      v32 = *((_OWORD *)a2 + 2);
      *(_QWORD *)((char *)this + 118) = *(_QWORD *)((char *)a2 + 46);
      *(_OWORD *)((char *)this + 88) = v31;
      *(_OWORD *)((char *)this + 104) = v32;
      *v16 = v30;
      *((_QWORD *)this + 17) = 0;
      *((_QWORD *)this + 18) = 0;
      *((_QWORD *)this + 16) = 0;
      v34 = (_BYTE *)*((_QWORD *)a2 + 7);
      v33 = (_BYTE *)*((_QWORD *)a2 + 8);
      v35 = v33 - v34;
      if (v33 != v34)
      {
        if (v35 < 0)
          abort();
        v36 = (char *)operator new(v33 - v34);
        *((_QWORD *)this + 16) = v36;
        *((_QWORD *)this + 17) = v36;
        v37 = &v36[4 * (v35 >> 2)];
        *((_QWORD *)this + 18) = v37;
        memcpy(v36, v34, v35);
        *((_QWORD *)this + 17) = v37;
      }
      v38 = *((_QWORD *)a2 + 11);
      *((_QWORD *)this + 19) = *((_QWORD *)a2 + 10);
      *((_QWORD *)this + 20) = v38;
      if (v38)
      {
        v39 = (unsigned int *)(v38 + 24);
        do
          v40 = __ldxr(v39);
        while (__stxr(v40 + 1, v39));
      }
      *(_OWORD *)((char *)this + 168) = *((_OWORD *)a2 + 6);
      v41 = *((_OWORD *)a2 + 7);
      v42 = *((_OWORD *)a2 + 8);
      v43 = *((_OWORD *)a2 + 9);
      *(_OWORD *)((char *)this + 229) = *(_OWORD *)((char *)a2 + 157);
      *(_OWORD *)((char *)this + 216) = v43;
      *(_OWORD *)((char *)this + 200) = v42;
      *(_OWORD *)((char *)this + 184) = v41;
      v44 = *((_QWORD *)a2 + 22);
      *((_QWORD *)this + 31) = v44;
      if (v44)
      {
        v45 = (unsigned int *)(v44 + 8);
        do
          v46 = __ldxr(v45);
        while (__stxr(v46 + 1, v45));
      }
      v47 = *(_OWORD *)((char *)a2 + 184);
      *((_BYTE *)this + 272) = *((_BYTE *)a2 + 200);
      *((_OWORD *)this + 16) = v47;
      *((_BYTE *)this + 280) = 1;
      if (v8)
        goto LABEL_17;
      goto LABEL_18;
    }
    webrtc::RtpPacketToSend::operator=((uint64_t)v16, (__int128 *)a2);
  }
  if (v8)
LABEL_17:
    ++*((_DWORD *)this + 78);
LABEL_18:
  v17 = (char *)this + 320;
  v18 = 332;
  if (*((_BYTE *)this + 344))
    v17 = (char *)this + 332;
  else
    v18 = 320;
  if (v8)
  {
    v19 = *(_DWORD *)((char *)this + v18);
    v21 = *((_DWORD *)v17 + 1);
    v20 = *((unsigned int *)v17 + 2);
    v22 = *((_DWORD *)this + 78);
    if (v22 >= v21)
      goto LABEL_35;
    v23 = *((_QWORD *)this + 8);
    v24 = (char)(v19 * v23) != v19 * (_DWORD)v23 || v19 <= 0;
    v25 = (int)((v19 * v23 + 128) & 0xFFFFFF00);
    if (!v24)
      v25 = 256;
    if ((int)(v25 / v23 - v19) <= 49)
    {
      v26 = (float)v23 / (float)v22;
      v27 = *((_DWORD *)this + 79);
      v24 = v27 < (int)v23;
      v28 = v27 <= (int)v23;
      v29 = v24;
      if (v26 >= 2.0)
        v28 = v29;
      if (v28)
      {
LABEL_35:
        webrtc::ForwardErrorCorrection::EncodeFec(*((_QWORD **)this + 5), (_QWORD *)this + 6, v19, 0, 0, v20, (uint64_t *)this + 36, v7);
        if (!*((_QWORD *)this + 38))
          webrtc::UlpfecGenerator::ResetState(this);
      }
    }
  }
}

void webrtc::UlpfecGenerator::ResetState(webrtc::UlpfecGenerator *this)
{
  char *v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  void *v15;
  webrtc::UlpfecGenerator *v16;
  uint64_t v17;
  uint64_t v18;
  webrtc::UlpfecGenerator *v19;
  uint64_t v20;
  char *v21;

  if (*((_QWORD *)this + 8))
  {
    v2 = (char *)this + 48;
    v3 = *((_QWORD *)this + 6);
    v4 = (char *)*((_QWORD *)this + 7);
    v5 = *(_QWORD *)v4;
    *(_QWORD *)(v5 + 8) = *(_QWORD *)(v3 + 8);
    **(_QWORD **)(v3 + 8) = v5;
    *((_QWORD *)this + 8) = 0;
    if (v4 != (char *)this + 48)
    {
      do
      {
        v21 = (char *)*((_QWORD *)v4 + 1);
        v20 = *((_QWORD *)v4 + 2);
        *((_QWORD *)v4 + 2) = 0;
        if (v20)
          (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
        operator delete(v4);
        v4 = v21;
      }
      while (v21 != v2);
    }
  }
  if (*((_BYTE *)this + 280))
  {
    v6 = (unsigned int *)*((_QWORD *)this + 31);
    if (v6)
    {
      v7 = v6 + 2;
      do
      {
        v8 = __ldaxr(v7);
        v9 = v8 - 1;
      }
      while (__stlxr(v9, v7));
      if (!v9)
        (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
    v10 = *((_QWORD *)this + 20);
    if (v10)
    {
      v11 = (unsigned int *)(v10 + 24);
      do
      {
        v12 = __ldaxr(v11);
        v13 = v12 - 1;
      }
      while (__stlxr(v13, v11));
      if (!v13)
      {
        v14 = *(_QWORD *)(v10 + 16);
        *(_QWORD *)(v10 + 16) = 0;
        if (v14)
          MEMORY[0x20BD0ADD4](v14, 0x1000C8077774924);
        MEMORY[0x20BD0ADEC](v10, 0x1010C40EE34DA14);
      }
    }
    v15 = (void *)*((_QWORD *)this + 16);
    if (v15)
    {
      *((_QWORD *)this + 17) = v15;
      operator delete(v15);
    }
    *((_BYTE *)this + 280) = 0;
  }
  if (*((_QWORD *)this + 38))
  {
    v17 = *((_QWORD *)this + 36);
    v16 = (webrtc::UlpfecGenerator *)*((_QWORD *)this + 37);
    v18 = *(_QWORD *)v16;
    *(_QWORD *)(v18 + 8) = *(_QWORD *)(v17 + 8);
    **(_QWORD **)(v17 + 8) = v18;
    *((_QWORD *)this + 38) = 0;
    if (v16 != (webrtc::UlpfecGenerator *)((char *)this + 288))
    {
      do
      {
        v19 = (webrtc::UlpfecGenerator *)*((_QWORD *)v16 + 1);
        operator delete(v16);
        v16 = v19;
      }
      while (v19 != (webrtc::UlpfecGenerator *)((char *)this + 288));
    }
  }
  *((_DWORD *)this + 78) = 0;
  *((_BYTE *)this + 344) = 0;
}

uint64_t webrtc::UlpfecGenerator::MaxPacketOverhead(webrtc::UlpfecGenerator *this)
{
  return *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 5) + 16) + 24);
}

uint64_t webrtc::UlpfecGenerator::GetFecPackets@<X0>(uint64_t this@<X0>, uint64_t a2@<X4>, uint64_t a3@<X5>, uint64_t a4@<X6>, uint64_t a5@<X7>, _QWORD *a6@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  __int128 v13;
  _BYTE *v14;
  _BYTE *v15;
  int64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  uint64_t v30;
  char v31;
  char v32;
  rtc::CopyOnWriteBuffer *v33;
  uint64_t v34;
  char v35;
  rtc::CopyOnWriteBuffer *v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE *v39;
  void *v40;
  uint64_t v41;
  const void *v42;
  rtc::CopyOnWriteBuffer *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  rtc::CopyOnWriteBuffer **v48;
  rtc::CopyOnWriteBuffer *v49;
  unsigned int *v50;
  unsigned int *v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  std::string *v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  rtc::CopyOnWriteBuffer *v68;

  if (*(_QWORD *)(this + 304))
  {
    v7 = this;
    if (*(_BYTE *)(this + 280))
    {
      v67 = this + 288;
      *(_QWORD *)(this + 96) = 0;
      rtc::CopyOnWriteBuffer::SetSize((uint64_t *)(this + 160), *(uint64_t **)(this + 88));
      v8 = *(_QWORD *)(v7 + 160);
      if (v8)
        rtc::CopyOnWriteBuffer::UnshareAndEnsureCapacity((uint64_t *)(v7 + 160), (uint64_t *)(*(_QWORD *)(v8 + 8) - *(_QWORD *)(v7 + 168)));
      *a6 = 0;
      a6[1] = 0;
      a6[2] = 0;
      std::vector<std::unique_ptr<webrtc::RtpPacketToSend>>::reserve((uint64_t)a6, *(_QWORD *)(v7 + 304));
      v9 = *(_QWORD *)(v7 + 296);
      if (v9 != v67)
      {
        v10 = 0;
        v66 = a6;
        while (1)
        {
          if (!*(_BYTE *)(v7 + 280))
          {
LABEL_59:
            __break(1u);
LABEL_60:
            abort();
          }
          v11 = *(_QWORD **)(v9 + 16);
          v12 = operator new();
          v13 = *(_OWORD *)(v7 + 88);
          *(_OWORD *)v12 = *(_OWORD *)(v7 + 72);
          *(_OWORD *)(v12 + 16) = v13;
          *(_OWORD *)(v12 + 32) = *(_OWORD *)(v7 + 104);
          *(_QWORD *)(v12 + 46) = *(_QWORD *)(v7 + 118);
          *(_QWORD *)(v12 + 64) = 0;
          *(_QWORD *)(v12 + 72) = 0;
          *(_QWORD *)(v12 + 56) = 0;
          v15 = *(_BYTE **)(v7 + 128);
          v14 = *(_BYTE **)(v7 + 136);
          v16 = v14 - v15;
          if (v14 != v15)
          {
            if (v16 < 0)
              goto LABEL_60;
            v17 = (char *)operator new(v14 - v15);
            *(_QWORD *)(v12 + 56) = v17;
            *(_QWORD *)(v12 + 64) = v17;
            v18 = &v17[4 * (v16 >> 2)];
            *(_QWORD *)(v12 + 72) = v18;
            memcpy(v17, v15, v16);
            *(_QWORD *)(v12 + 64) = v18;
          }
          v20 = *(_QWORD *)(v7 + 152);
          v19 = *(_QWORD *)(v7 + 160);
          *(_QWORD *)(v12 + 88) = v19;
          *(_QWORD *)(v12 + 80) = v20;
          if (v19)
          {
            v21 = (unsigned int *)(v19 + 24);
            do
              v22 = __ldxr(v21);
            while (__stxr(v22 + 1, v21));
          }
          v23 = *(_OWORD *)(v7 + 168);
          v24 = *(_OWORD *)(v7 + 184);
          v25 = *(_OWORD *)(v7 + 200);
          *(_OWORD *)(v12 + 96) = v23;
          *(_OWORD *)(v12 + 112) = v24;
          v26 = *(_OWORD *)(v7 + 216);
          *(_OWORD *)(v12 + 128) = v25;
          *(_OWORD *)(v12 + 144) = v26;
          *(_OWORD *)(v12 + 157) = *(_OWORD *)(v7 + 229);
          v27 = *(_QWORD *)(v7 + 248);
          *(_QWORD *)(v12 + 176) = v27;
          if (v27)
          {
            v28 = (unsigned int *)(v27 + 8);
            do
              v29 = __ldxr(v28);
            while (__stxr(v29 + 1, v28));
            v30 = *(_QWORD *)(v12 + 96);
          }
          else
          {
            v30 = v23;
          }
          *(_BYTE *)(v12 + 200) = *(_BYTE *)(v7 + 272);
          *(_OWORD *)(v12 + 184) = *(_OWORD *)(v7 + 256);
          v68 = (rtc::CopyOnWriteBuffer *)v12;
          v31 = *(_BYTE *)(v7 + 8);
          *(_BYTE *)(v12 + 1) = v31;
          v32 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 88) + 16) + v30 + 1) & 0x80 | v31;
          rtc::CopyOnWriteBuffer::UnshareAndEnsureCapacity((uint64_t *)(v12 + 88), (uint64_t *)(*(_QWORD *)(*(_QWORD *)(v12 + 88) + 8) - v30));
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 88) + 16) + *(_QWORD *)(v12 + 96) + 1) = v32;
          v33 = v68;
          *(_BYTE *)v68 = 0;
          v34 = *((_QWORD *)v33 + 12);
          v35 = *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v33 + 11) + 16) + v34 + 1);
          rtc::CopyOnWriteBuffer::UnshareAndEnsureCapacity((uint64_t *)v33 + 11, (uint64_t *)(*(_QWORD *)(*((_QWORD *)v33 + 11) + 8) - v34));
          *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v33 + 11) + 16) + *((_QWORD *)v33 + 12) + 1) = v35 & 0x7F;
          v36 = v68;
          v37 = v11[3] + 1;
          *((_QWORD *)v68 + 3) = v37;
          rtc::CopyOnWriteBuffer::SetSize((uint64_t *)v36 + 11, (uint64_t *)(*((_QWORD *)v36 + 2) + v37));
          v38 = *((_QWORD *)v36 + 2);
          rtc::CopyOnWriteBuffer::UnshareAndEnsureCapacity((uint64_t *)v36 + 11, (uint64_t *)(*(_QWORD *)(*((_QWORD *)v36 + 11) + 8) - *((_QWORD *)v36 + 12)));
          v39 = (_BYTE *)(*(_QWORD *)(*((_QWORD *)v36 + 11) + 16) + *((_QWORD *)v36 + 12) + v38);
          *v39 = *(_DWORD *)(v7 + 12);
          v40 = v39 + 1;
          v41 = v11[1];
          if (v41)
            v42 = (const void *)(*(_QWORD *)(v41 + 16) + v11[2]);
          else
            v42 = 0;
          memcpy(v40, v42, v11[3]);
          v43 = v68;
          v44 = *((_QWORD *)v68 + 2);
          v45 = *((_QWORD *)v68 + 3);
          v46 = *((unsigned __int8 *)v68 + 2);
          v47 = *((_QWORD *)v68 + 15);
          if (*((_BYTE *)v68 + 128) && !v47 || *((_BYTE *)v68 + 128) && v47 == 1)
          {
            *((_DWORD *)v68 + 34) = v47;
            *((_BYTE *)v43 + 140) = 1;
          }
          *((_QWORD *)v43 + 15) = 3;
          *((_BYTE *)v43 + 128) = 1;
          *((_BYTE *)v43 + 168) = 0;
          *((_WORD *)v43 + 93) = 256;
          v48 = (rtc::CopyOnWriteBuffer **)v66[1];
          if ((unint64_t)v48 >= v66[2])
          {
            v66[1] = std::vector<std::unique_ptr<webrtc::RtpPacketToSend>>::__push_back_slow_path<std::unique_ptr<webrtc::RtpPacketToSend>>(v66, (uint64_t *)&v68);
            v49 = v68;
            v68 = 0;
            if (v49)
              goto LABEL_34;
          }
          else
          {
            if (!v48)
              goto LABEL_59;
            v68 = 0;
            *v48 = v43;
            v66[1] = v48 + 1;
            v49 = v68;
            v68 = 0;
            if (v49)
            {
LABEL_34:
              v50 = (unsigned int *)*((_QWORD *)v49 + 22);
              if (v50)
              {
                v51 = v50 + 2;
                do
                {
                  v52 = __ldaxr(v51);
                  v53 = v52 - 1;
                }
                while (__stlxr(v53, v51));
                if (!v53)
                  (*(void (**)(unsigned int *))(*(_QWORD *)v50 + 8))(v50);
              }
              v54 = *((_QWORD *)v49 + 11);
              if (v54)
              {
                v55 = (unsigned int *)(v54 + 24);
                do
                {
                  v56 = __ldaxr(v55);
                  v57 = v56 - 1;
                }
                while (__stlxr(v57, v55));
                if (!v57)
                {
                  v58 = *(_QWORD *)(v54 + 16);
                  *(_QWORD *)(v54 + 16) = 0;
                  if (v58)
                    MEMORY[0x20BD0ADD4](v58, 0x1000C8077774924);
                  MEMORY[0x20BD0ADEC](v54, 0x1010C40EE34DA14);
                }
              }
              v59 = (void *)*((_QWORD *)v49 + 7);
              if (v59)
              {
                *((_QWORD *)v49 + 8) = v59;
                operator delete(v59);
              }
              MEMORY[0x20BD0ADEC](v49, 0x1020C4000E59722);
            }
          }
          v10 += v44 + v45 + v46;
          v9 = *(_QWORD *)(v9 + 8);
          if (v9 == v67)
            goto LABEL_50;
        }
      }
      v10 = 0;
LABEL_50:
      webrtc::UlpfecGenerator::ResetState((webrtc::UlpfecGenerator *)v7);
      pthread_mutex_lock((pthread_mutex_t *)(v7 + 352));
      v60 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v7 + 16) + 16))(*(_QWORD *)(v7 + 16));
      v61 = v60 / 0x3E8uLL;
      if (v60 % 0x3E8uLL > 0x1F3)
        ++v61;
      if (-v60 % 0x3E8uLL <= 0x1F4)
        v62 = 0;
      else
        v62 = -1;
      if (v60 < 0)
        v63 = v62 - -v60 / 0x3E8uLL;
      else
        v63 = v61;
      webrtc::RateStatistics::Update((webrtc::RateStatistics *)(v7 + 448), v10, v63);
      return pthread_mutex_unlock((pthread_mutex_t *)(v7 + 352));
    }
    else
    {
      v64 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/ulpfec_generator.cc", 208, "last_media_packet_.has_value()", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a2, a3, a4, a5, v65);
      return webrtc::UlpfecGenerator::CurrentFecRate((webrtc::UlpfecGenerator *)v64);
    }
  }
  else
  {
    *a6 = 0;
    a6[1] = 0;
    a6[2] = 0;
  }
  return this;
}

unint64_t webrtc::UlpfecGenerator::CurrentFecRate(webrtc::UlpfecGenerator *this)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  char v8;
  unint64_t v9;

  v2 = (pthread_mutex_t *)((char *)this + 352);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 352));
  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 16))(*((_QWORD *)this + 2));
  v4 = v3 / 0x3E8uLL;
  if (v3 % 0x3E8uLL > 0x1F3)
    ++v4;
  if (-v3 % 0x3E8uLL <= 0x1F4)
    v5 = 0;
  else
    v5 = -1;
  if (v3 < 0)
    v6 = v5 - -v3 / 0x3E8uLL;
  else
    v6 = v4;
  v7 = webrtc::RateStatistics::Rate((webrtc::UlpfecGenerator *)((char *)this + 448), v6);
  if (v8)
    v9 = v7;
  else
    v9 = 0;
  pthread_mutex_unlock(v2);
  return v9;
}

uint64_t webrtc::UlpfecGenerator::GetFecType(webrtc::UlpfecGenerator *this)
{
  return 1;
}

uint64_t webrtc::UlpfecGenerator::FecSsrc(webrtc::UlpfecGenerator *this)
{
  return 0;
}

void webrtc::UlpfecGenerator::GetRtpState(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[40] = 0;
}

void webrtc::UlpfecHeaderReader::~UlpfecHeaderReader(webrtc::UlpfecHeaderReader *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

BOOL webrtc::UlpfecHeaderReader::ReadFecHeader(webrtc::UlpfecHeaderReader *this, webrtc::ForwardErrorCorrection::ReceivedFecPacket *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = (uint64_t *)*((_QWORD *)a2 + 20);
  v4 = v3[1];
  if (v4)
  {
    rtc::CopyOnWriteBuffer::UnshareAndEnsureCapacity(v3 + 1, (uint64_t *)(*(_QWORD *)(v4 + 8) - v3[2]));
    v5 = *(_QWORD *)(v3[1] + 16) + v3[2];
    v6 = *(_QWORD *)(*((_QWORD *)a2 + 20) + 24);
    if (v6 < 0xC)
      return v6 > 0xB;
  }
  else
  {
    v5 = 0;
    v6 = v3[3];
    if (v6 < 0xC)
      return v6 > 0xB;
  }
  v7 = 6;
  if ((*(_BYTE *)v5 & 0x40) == 0)
    v7 = 2;
  v8 = 18;
  if ((*(_BYTE *)v5 & 0x40) == 0)
    v8 = 14;
  *((_QWORD *)a2 + 5) = v8;
  v9 = bswap32(*(unsigned __int16 *)(v5 + 2));
  LODWORD(v11) = *((_DWORD *)a2 + 8);
  WORD2(v11) = HIWORD(v9);
  *((_QWORD *)&v11 + 1) = 12;
  v12 = v7;
  absl::inlined_vector_internal::Storage<webrtc::ForwardErrorCorrection::ProtectedStream,4ul,std::allocator<webrtc::ForwardErrorCorrection::ProtectedStream>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<webrtc::ForwardErrorCorrection::ProtectedStream>,webrtc::ForwardErrorCorrection::ProtectedStream const*>>((unint64_t *)a2 + 6, &v11, 1uLL);
  *((_QWORD *)a2 + 19) = __rev16(*(unsigned __int16 *)(v5 + 10));
  *(_WORD *)(v5 + 2) = *(_WORD *)(v5 + 8);
  return v6 > 0xB;
}

void webrtc::UlpfecHeaderWriter::~UlpfecHeaderWriter(webrtc::UlpfecHeaderWriter *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::UlpfecHeaderWriter::MinPacketMaskSize(webrtc::UlpfecHeaderWriter *this, const unsigned __int8 *a2, uint64_t a3)
{
  return a3;
}

uint64_t webrtc::UlpfecHeaderWriter::FecHeaderSize(webrtc::UlpfecHeaderWriter *this, unint64_t a2)
{
  if (a2 >= 3)
    return 18;
  else
    return 14;
}

double webrtc::UlpfecHeaderWriter::FinalizeFecHeader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v9;
  const void *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  double result;
  std::string *v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;

  if (a3 == 1)
  {
    v9 = *(_WORD *)(a2 + 4);
    v10 = *(const void **)(a2 + 8);
    v11 = *(_QWORD *)(a2 + 16);
    v12 = a4 + 8;
    rtc::CopyOnWriteBuffer::UnshareAndEnsureCapacity((uint64_t *)(a4 + 8), (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a4 + 8) + 8) - *(_QWORD *)(a4 + 16)));
    v13 = *(_QWORD *)(*(_QWORD *)v12 + 16) + *(_QWORD *)(v12 + 8);
    if (v11 == 6)
      v14 = *(_BYTE *)v13 & 0x3F | 0x40;
    else
      v14 = *(_BYTE *)v13 & 0x3F;
    *(_BYTE *)v13 = v14;
    *(_WORD *)(v13 + 8) = *(_WORD *)(v13 + 2);
    *(_BYTE *)(v13 + 2) = HIBYTE(v9);
    *(_BYTE *)(v13 + 3) = v9;
    *(_WORD *)(v13 + 10) = bswap32(*(_DWORD *)(v12 + 16)- (*(uint64_t (**)(uint64_t, size_t))(*(_QWORD *)a1 + 24))(a1, v11)) >> 16;
    memcpy((void *)(v13 + 12), v10, v11);
  }
  else
  {
    v16 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/ulpfec_header_reader_writer.cc", 113, "protected_streams.size() == 1", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, a5, a6, a7, a8, a3);
    return webrtc::UlpfecReceiver::UlpfecReceiver((uint64_t)v16, v17, v18, v19, v20);
  }
  return result;
}

double webrtc::UlpfecReceiver::UlpfecReceiver(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  double result;

  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_QWORD *)(a1 + 8) = a5;
  *(_QWORD *)(a1 + 16) = a4;
  v7 = operator new();
  *(_OWORD *)(v7 + 8) = xmmword_208F09F80;
  *(_QWORD *)v7 = &unk_24C0C2E08;
  v8 = operator new();
  *(int64x2_t *)(v8 + 8) = vdupq_n_s64(0x30uLL);
  *(_QWORD *)(v8 + 24) = 18;
  *(_QWORD *)v8 = &unk_24C0C2E30;
  v9 = operator new();
  *(_DWORD *)v9 = a2;
  *(_DWORD *)(v9 + 4) = a2;
  *(_QWORD *)(v9 + 8) = v7;
  *(_QWORD *)(v9 + 16) = v8;
  v10 = operator new(0x780uLL);
  *v10 = &off_24C0B43E8;
  v10[1] = 0;
  v10[2] = 0;
  v10[3] = 0;
  *((_DWORD *)v10 + 8) = 0;
  v10[5] = &off_24C0B43E8;
  v10[6] = 0;
  v10[7] = 0;
  v10[8] = 0;
  *((_DWORD *)v10 + 18) = 0;
  v10[10] = &off_24C0B43E8;
  v10[11] = 0;
  v10[12] = 0;
  v10[13] = 0;
  *((_DWORD *)v10 + 28) = 0;
  v10[15] = &off_24C0B43E8;
  v10[16] = 0;
  *((_DWORD *)v10 + 38) = 0;
  v10[17] = 0;
  v10[18] = 0;
  v10[20] = &off_24C0B43E8;
  v10[21] = 0;
  *((_DWORD *)v10 + 48) = 0;
  v10[22] = 0;
  v10[23] = 0;
  v10[25] = &off_24C0B43E8;
  v10[26] = 0;
  *((_DWORD *)v10 + 58) = 0;
  v10[27] = 0;
  v10[28] = 0;
  v10[30] = &off_24C0B43E8;
  v10[31] = 0;
  *((_DWORD *)v10 + 68) = 0;
  v10[32] = 0;
  v10[33] = 0;
  v10[35] = &off_24C0B43E8;
  v10[36] = 0;
  *((_DWORD *)v10 + 78) = 0;
  v10[37] = 0;
  v10[38] = 0;
  v10[40] = &off_24C0B43E8;
  v10[41] = 0;
  *((_DWORD *)v10 + 88) = 0;
  v10[42] = 0;
  v10[43] = 0;
  v10[45] = &off_24C0B43E8;
  v10[46] = 0;
  *((_DWORD *)v10 + 98) = 0;
  v10[47] = 0;
  v10[48] = 0;
  v10[50] = &off_24C0B43E8;
  v10[51] = 0;
  *((_DWORD *)v10 + 108) = 0;
  v10[52] = 0;
  v10[53] = 0;
  v10[55] = &off_24C0B43E8;
  v10[56] = 0;
  *((_DWORD *)v10 + 118) = 0;
  v10[57] = 0;
  v10[58] = 0;
  v10[60] = &off_24C0B43E8;
  v10[61] = 0;
  *((_DWORD *)v10 + 128) = 0;
  v10[62] = 0;
  v10[63] = 0;
  v10[65] = &off_24C0B43E8;
  v10[67] = 0;
  v10[66] = 0;
  *((_DWORD *)v10 + 138) = 0;
  v10[68] = 0;
  v10[70] = &off_24C0B43E8;
  v10[72] = 0;
  v10[71] = 0;
  *((_DWORD *)v10 + 148) = 0;
  v10[73] = 0;
  v10[75] = &off_24C0B43E8;
  v10[77] = 0;
  v10[76] = 0;
  *((_DWORD *)v10 + 158) = 0;
  v10[78] = 0;
  v10[80] = &off_24C0B43E8;
  v10[82] = 0;
  v10[81] = 0;
  *((_DWORD *)v10 + 168) = 0;
  v10[83] = 0;
  v10[85] = &off_24C0B43E8;
  v10[87] = 0;
  v10[86] = 0;
  *((_DWORD *)v10 + 178) = 0;
  v10[88] = 0;
  v10[90] = &off_24C0B43E8;
  v10[92] = 0;
  v10[91] = 0;
  *((_DWORD *)v10 + 188) = 0;
  v10[93] = 0;
  v10[95] = &off_24C0B43E8;
  v10[97] = 0;
  v10[96] = 0;
  *((_DWORD *)v10 + 198) = 0;
  v10[98] = 0;
  v10[100] = &off_24C0B43E8;
  v10[102] = 0;
  v10[101] = 0;
  *((_DWORD *)v10 + 208) = 0;
  v10[103] = 0;
  v10[105] = &off_24C0B43E8;
  v10[107] = 0;
  v10[106] = 0;
  *((_DWORD *)v10 + 218) = 0;
  v10[108] = 0;
  v10[110] = &off_24C0B43E8;
  v10[112] = 0;
  v10[111] = 0;
  *((_DWORD *)v10 + 228) = 0;
  v10[113] = 0;
  v10[115] = &off_24C0B43E8;
  v10[117] = 0;
  v10[116] = 0;
  *((_DWORD *)v10 + 238) = 0;
  v10[118] = 0;
  v10[120] = &off_24C0B43E8;
  v10[122] = 0;
  v10[121] = 0;
  *((_DWORD *)v10 + 248) = 0;
  v10[123] = 0;
  v10[125] = &off_24C0B43E8;
  v10[127] = 0;
  v10[126] = 0;
  *((_DWORD *)v10 + 258) = 0;
  v10[128] = 0;
  v10[130] = &off_24C0B43E8;
  v10[132] = 0;
  v10[131] = 0;
  *((_DWORD *)v10 + 268) = 0;
  v10[133] = 0;
  v10[135] = &off_24C0B43E8;
  v10[137] = 0;
  v10[136] = 0;
  *((_DWORD *)v10 + 278) = 0;
  v10[138] = 0;
  v10[140] = &off_24C0B43E8;
  v10[142] = 0;
  v10[141] = 0;
  *((_DWORD *)v10 + 288) = 0;
  v10[143] = 0;
  v10[145] = &off_24C0B43E8;
  v10[147] = 0;
  v10[146] = 0;
  *((_DWORD *)v10 + 298) = 0;
  v10[148] = 0;
  v10[150] = &off_24C0B43E8;
  v10[152] = 0;
  v10[151] = 0;
  *((_DWORD *)v10 + 308) = 0;
  v10[153] = 0;
  v10[155] = &off_24C0B43E8;
  v10[157] = 0;
  v10[156] = 0;
  *((_DWORD *)v10 + 318) = 0;
  v10[158] = 0;
  v10[160] = &off_24C0B43E8;
  v10[162] = 0;
  v10[161] = 0;
  *((_DWORD *)v10 + 328) = 0;
  v10[163] = 0;
  v10[165] = &off_24C0B43E8;
  v10[167] = 0;
  v10[166] = 0;
  *((_DWORD *)v10 + 338) = 0;
  v10[168] = 0;
  v10[170] = &off_24C0B43E8;
  v10[172] = 0;
  v10[171] = 0;
  *((_DWORD *)v10 + 348) = 0;
  v10[173] = 0;
  v10[175] = &off_24C0B43E8;
  v10[177] = 0;
  v10[176] = 0;
  *((_DWORD *)v10 + 358) = 0;
  v10[178] = 0;
  v10[180] = &off_24C0B43E8;
  v10[182] = 0;
  v10[181] = 0;
  *((_DWORD *)v10 + 368) = 0;
  v10[183] = 0;
  v10[185] = &off_24C0B43E8;
  v10[187] = 0;
  v10[186] = 0;
  *((_DWORD *)v10 + 378) = 0;
  v10[188] = 0;
  v10[190] = &off_24C0B43E8;
  v10[192] = 0;
  v10[191] = 0;
  *((_DWORD *)v10 + 388) = 0;
  v10[193] = 0;
  v10[195] = &off_24C0B43E8;
  v10[197] = 0;
  v10[196] = 0;
  *((_DWORD *)v10 + 398) = 0;
  v10[198] = 0;
  v10[200] = &off_24C0B43E8;
  v10[202] = 0;
  v10[201] = 0;
  *((_DWORD *)v10 + 408) = 0;
  v10[203] = 0;
  v10[205] = &off_24C0B43E8;
  v10[207] = 0;
  v10[206] = 0;
  *((_DWORD *)v10 + 418) = 0;
  v10[208] = 0;
  v10[210] = &off_24C0B43E8;
  v10[212] = 0;
  v10[211] = 0;
  *((_DWORD *)v10 + 428) = 0;
  v10[213] = 0;
  v10[215] = &off_24C0B43E8;
  v10[217] = 0;
  v10[216] = 0;
  *((_DWORD *)v10 + 438) = 0;
  v10[218] = 0;
  v10[220] = &off_24C0B43E8;
  v10[222] = 0;
  v10[221] = 0;
  *((_DWORD *)v10 + 448) = 0;
  v10[223] = 0;
  v10[225] = &off_24C0B43E8;
  v10[227] = 0;
  v10[226] = 0;
  *((_DWORD *)v10 + 458) = 0;
  v10[228] = 0;
  v10[230] = &off_24C0B43E8;
  v10[232] = 0;
  v10[231] = 0;
  *((_DWORD *)v10 + 468) = 0;
  v10[233] = 0;
  v10[235] = &off_24C0B43E8;
  v10[237] = 0;
  v10[236] = 0;
  *((_DWORD *)v10 + 478) = 0;
  v10[238] = 0;
  *(_QWORD *)(v9 + 24) = v10;
  *(_QWORD *)(v9 + 32) = v10 + 240;
  *(_QWORD *)(v9 + 40) = v10 + 240;
  *(_QWORD *)(v9 + 48) = v9 + 48;
  *(_QWORD *)(v9 + 56) = v9 + 48;
  *(_QWORD *)(v9 + 64) = 0;
  *(_QWORD *)(v9 + 648) = 0;
  *(_QWORD *)(a1 + 24) = v9;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = a1 + 56;
  *(_QWORD *)(a1 + 64) = a1 + 56;
  result = 0.0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0x8000000000000000;
  return result;
}

void webrtc::UlpfecReceiver::~UlpfecReceiver(webrtc::UlpfecReceiver *this)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  BOOL v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  webrtc::ForwardErrorCorrection *v28;

  if (*((_QWORD *)this + 14) != 0x8000000000000000)
  {
    v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
    v3 = *((_QWORD *)this + 14);
    v4 = 0x7FFFFFFFFFFFFFFFLL;
    v5 = v2 == 0x7FFFFFFFFFFFFFFFLL || v3 == 0x8000000000000000;
    if (v5
      || (v2 != 0x8000000000000000 ? (v6 = v3 == 0x7FFFFFFFFFFFFFFFLL) : (v6 = 1),
          !v6 && (v4 = v2 - v3, ((v2 - v3) & 0x8000000000000000) == 0)))
    {
      v7 = v4 % 0xF4240 <= 0x7A11F ? v4 / 0xF4240 : v4 / 0xF4240 + 1;
      if (v7 >= 0xA && *((_DWORD *)this + 1) != -1)
      {
        v8 = atomic_load(&webrtc::UlpfecReceiver::~UlpfecReceiver()::atomic_histogram_pointer);
        if (v8)
        {
          webrtc::metrics::HistogramAdd(v8, 8 * *((_QWORD *)this + 11) / v7 / 0x3E8);
        }
        else
        {
          while (!__ldaxr(&webrtc::UlpfecReceiver::~UlpfecReceiver()::atomic_histogram_pointer))
          {
            if (!__stlxr(0, &webrtc::UlpfecReceiver::~UlpfecReceiver()::atomic_histogram_pointer))
              goto LABEL_21;
          }
          __clrex();
        }
      }
    }
  }
LABEL_21:
  v10 = (_QWORD *)*((_QWORD *)this + 4);
  v11 = (_QWORD *)*((_QWORD *)this + 5);
  while (v11 != v10)
  {
    v13 = *--v11;
    v12 = v13;
    *v11 = 0;
    if (v13)
    {
      v14 = *(_QWORD *)(v12 + 32);
      if (v14)
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
      MEMORY[0x20BD0ADEC](v12, 0x1020C40615C549ELL);
    }
  }
  *((_QWORD *)this + 5) = v10;
  v15 = (char *)this + 56;
  webrtc::ForwardErrorCorrection::ResetState(*((_QWORD **)this + 3), (uint64_t *)this + 7);
  if (*((_QWORD *)this + 9))
  {
    v16 = *((_QWORD *)this + 7);
    v17 = (char *)*((_QWORD *)this + 8);
    v18 = *(_QWORD *)v17;
    *(_QWORD *)(v18 + 8) = *(_QWORD *)(v16 + 8);
    **(_QWORD **)(v16 + 8) = v18;
    *((_QWORD *)this + 9) = 0;
    if (v17 != v15)
    {
      do
      {
        v23 = (char *)*((_QWORD *)v17 + 1);
        v22 = *((_QWORD *)v17 + 2);
        *((_QWORD *)v17 + 2) = 0;
        if (v22)
        {
          v24 = *(_QWORD *)(v22 + 16);
          if (v24)
            (*(void (**)(uint64_t))(*(_QWORD *)v24 + 24))(v24);
          MEMORY[0x20BD0ADEC](v22, 0x1020C407D5D75B9);
        }
        operator delete(v17);
        v17 = v23;
      }
      while (v23 != v15);
    }
  }
  v19 = (_QWORD *)*((_QWORD *)this + 4);
  if (v19)
  {
    v20 = (_QWORD *)*((_QWORD *)this + 5);
    v21 = (void *)*((_QWORD *)this + 4);
    if (v20 != v19)
    {
      do
      {
        v26 = *--v20;
        v25 = v26;
        *v20 = 0;
        if (v26)
        {
          v27 = *(_QWORD *)(v25 + 32);
          if (v27)
            (*(void (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
          MEMORY[0x20BD0ADEC](v25, 0x1020C40615C549ELL);
        }
      }
      while (v20 != v19);
      v21 = (void *)*((_QWORD *)this + 4);
    }
    *((_QWORD *)this + 5) = v19;
    operator delete(v21);
  }
  v28 = (webrtc::ForwardErrorCorrection *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v28)
  {
    webrtc::ForwardErrorCorrection::~ForwardErrorCorrection(v28);
    MEMORY[0x20BD0ADEC]();
  }
}

uint64_t webrtc::UlpfecReceiver::AddReceivedRedPacket(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL8 v11;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  int v22;
  int v23;
  char *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  unsigned int *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int *v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  char *v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  char *v69;
  char *v70;
  uint64_t *v71;
  _QWORD *v72;
  unint64_t v73;
  BOOL v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  char *v78;
  char *v79;
  uint64_t v80;
  __int128 v81;
  __int128 v82;
  uint64_t v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;

  if (*(_DWORD *)(a2 + 12) == *(_DWORD *)a1)
  {
    v3 = *(_QWORD *)(a2 + 24);
    if (v3 + *(_QWORD *)(a2 + 16) + (unint64_t)*(unsigned __int8 *)(a2 + 2) >= 0x5DD)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        goto LABEL_6;
      return 0;
    }
    if (!v3)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        return 0;
      goto LABEL_6;
    }
    v14 = operator new();
    *(_QWORD *)(v14 + 10) = 0;
    *(_QWORD *)(v14 + 26) = 0;
    *(_QWORD *)(v14 + 18) = 0;
    *(_QWORD *)(v14 + 32) = 0;
    v15 = operator new();
    *(_QWORD *)v15 = &off_24C0B43E8;
    *(_QWORD *)(v15 + 8) = 0;
    *(_QWORD *)(v15 + 16) = 0;
    *(_QWORD *)(v15 + 24) = 0;
    *(_DWORD *)(v15 + 32) = 0;
    webrtc::ForwardErrorCorrection::Packet::AddRef((webrtc::ForwardErrorCorrection::Packet *)v15);
    v16 = *(_QWORD *)(v14 + 32);
    if (v16)
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
    *(_QWORD *)(v14 + 32) = v15;
    v17 = *(_QWORD *)(a2 + 88);
    if (v17)
      v18 = *(_QWORD *)(v17 + 16) + *(_QWORD *)(a2 + 96);
    else
      v18 = 0;
    v19 = *(_QWORD *)(a2 + 16);
    v20 = *(_QWORD *)(a2 + 24);
    v21 = (_BYTE *)(v18 + v19);
    if (!v20)
      v21 = 0;
    v22 = *v21 & 0x7F;
    v23 = *(_DWORD *)(a1 + 4) == v22;
    *(_BYTE *)(v14 + 8) = v23;
    *(_BYTE *)(v14 + 9) = *(_BYTE *)(a2 + 128);
    *(_DWORD *)v14 = *(_DWORD *)(a2 + 12);
    *(_WORD *)(v14 + 4) = *(_WORD *)(a2 + 4);
    *(_OWORD *)(v14 + 10) = *(_OWORD *)(a2 + 32);
    *(_QWORD *)(v14 + 24) = *(_QWORD *)(a2 + 46);
    if (v17)
      v17 = *(_QWORD *)(v17 + 16) + *(_QWORD *)(a2 + 96);
    v24 = (char *)(v17 + v19);
    if (!v20)
      v24 = 0;
    v25 = *v24;
    v11 = v25 >= 0;
    if (v25 < 0)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v34, v35, v36, v37, v38, v39, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/ulpfec_receiver.cc");
      v41 = *(_QWORD **)(v14 + 32);
      if (!v41)
        goto LABEL_63;
    }
    else
    {
      v26 = v20 + v19 + *(unsigned __int8 *)(a2 + 2) + *(_QWORD *)(a1 + 88);
      ++*(_QWORD *)(a1 + 80);
      *(_QWORD *)(a1 + 88) = v26;
      if (*(_QWORD *)(a1 + 112) == 0x8000000000000000)
      {
        *(_QWORD *)(a1 + 112) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
        v23 = *(unsigned __int8 *)(v14 + 8);
      }
      if (v23)
      {
        ++*(_QWORD *)(a1 + 96);
        v27 = *(_QWORD *)(a2 + 88);
        if (v27)
        {
          v28 = (unsigned int *)(v27 + 24);
          do
            v29 = __ldxr(v28);
          while (__stxr(v29 + 1, v28));
          v30 = *(_QWORD *)(a2 + 96);
          v31 = *(_QWORD *)(a2 + 16);
          v32 = *(_QWORD *)(a2 + 24);
          do
            v33 = __ldxr(v28);
          while (__stxr(v33 + 1, v28));
        }
        else
        {
          v30 = *(_QWORD *)(a2 + 96);
          v31 = *(_QWORD *)(a2 + 16);
          v32 = *(_QWORD *)(a2 + 24);
        }
        v44 = v32 - 1;
        v45 = v31 + v30 + 1;
        v46 = *(_QWORD **)(v14 + 32);
        v47 = v46[1];
        v46[1] = v27;
        if (v47)
        {
          v48 = (unsigned int *)(v47 + 24);
          do
          {
            v49 = __ldaxr(v48);
            v50 = v49 - 1;
          }
          while (__stlxr(v50, v48));
          if (!v50)
          {
            v51 = *(_QWORD *)(v47 + 16);
            *(_QWORD *)(v47 + 16) = 0;
            if (v51)
              MEMORY[0x20BD0ADD4](v51, 0x1000C8077774924);
            MEMORY[0x20BD0ADEC](v47, 0x1010C40EE34DA14);
          }
        }
        v46[2] = v45;
        v46[3] = v44;
        if (v27)
        {
          v52 = (unsigned int *)(v27 + 24);
          do
          {
            v53 = __ldaxr(v52);
            v54 = v53 - 1;
          }
          while (__stlxr(v54, v52));
          if (!v54)
          {
            v55 = *(_QWORD *)(v27 + 16);
            *(_QWORD *)(v27 + 16) = 0;
            if (v55)
              MEMORY[0x20BD0ADD4](v55, 0x1000C8077774924);
            MEMORY[0x20BD0ADEC](v27, 0x1010C40EE34DA14);
          }
        }
      }
      else
      {
        rtc::CopyOnWriteBuffer::EnsureCapacity((uint64_t *)(*(_QWORD *)(v14 + 32) + 8), (uint64_t *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 24) + *(unsigned __int8 *)(a2 + 2) - 1));
        v42 = *(_QWORD *)(a2 + 88);
        if (v42)
          v43 = (void *)(*(_QWORD *)(v42 + 16) + *(_QWORD *)(a2 + 96));
        else
          v43 = 0;
        rtc::CopyOnWriteBuffer::SetData<unsigned char,(void *)0>((uint64_t *)(*(_QWORD *)(v14 + 32) + 8), v43, *(uint64_t **)(a2 + 16));
        v56 = *(uint64_t **)(v14 + 32);
        v57 = v56[1];
        v58 = v56[2];
        rtc::CopyOnWriteBuffer::UnshareAndEnsureCapacity(++v56, (uint64_t *)(*(_QWORD *)(v57 + 8) - v58));
        v59 = *(_QWORD *)(*v56 + 16) + v56[1];
        *(_BYTE *)(v59 + 1) = *(_BYTE *)(v59 + 1) & 0x80 | v22;
        v60 = *(_QWORD *)(a2 + 88);
        if (v60)
          v60 = *(_QWORD *)(v60 + 16) + *(_QWORD *)(a2 + 96);
        rtc::CopyOnWriteBuffer::AppendData<unsigned char,(void *)0>((rtc::CopyOnWriteBuffer *)(*(_QWORD *)(v14 + 32) + 8), (const void *)(v60 + *(_QWORD *)(a2 + 16) + 1), *(_QWORD *)(a2 + 24) + *(unsigned __int8 *)(a2 + 2) - 1);
      }
      v41 = *(_QWORD **)(v14 + 32);
      if (v41[3])
      {
        v62 = *(char **)(a1 + 40);
        v61 = *(_QWORD *)(a1 + 48);
        if ((unint64_t)v62 >= v61)
        {
          v63 = *(char **)(a1 + 32);
          v64 = (v62 - v63) >> 3;
          v65 = v64 + 1;
          if ((unint64_t)(v64 + 1) >> 61)
            goto LABEL_94;
          v66 = v61 - (_QWORD)v63;
          if (v66 >> 2 > v65)
            v65 = v66 >> 2;
          v74 = (unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8;
          v67 = 0x1FFFFFFFFFFFFFFFLL;
          if (!v74)
            v67 = v65;
          if (v67)
          {
            if (v67 >> 61)
              std::__throw_bad_array_new_length[abi:sn180100]();
            v68 = 8 * v67;
            v69 = (char *)operator new(8 * v67);
            v70 = &v69[v68];
            v71 = (uint64_t *)&v69[8 * v64];
            *v71 = v14;
            v72 = v71 + 1;
            if (v62 == v63)
            {
              *(_QWORD *)(a1 + 32) = v71;
              *(_QWORD *)(a1 + 40) = v72;
              *(_QWORD *)(a1 + 48) = v70;
            }
            else
            {
              v73 = v62 - v63 - 8;
              if (v73 < 0x78)
                goto LABEL_98;
              v74 = &v62[-(v73 & 0xFFFFFFFFFFFFFFF8) - 8] >= (char *)v71
                 || &v69[v62 - v63 - (v73 & 0xFFFFFFFFFFFFFFF8) - 8] >= v62;
              if (!v74)
                goto LABEL_98;
              v75 = (v73 >> 3) + 1;
              v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              v77 = &v62[-v76];
              v71 = (uint64_t *)((char *)v71 - v76);
              v78 = &v69[8 * v64 - 16];
              v79 = v62 - 16;
              v80 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v82 = *((_OWORD *)v79 - 1);
                v81 = *(_OWORD *)v79;
                *((_OWORD *)v79 - 1) = 0uLL;
                *(_OWORD *)v79 = 0uLL;
                *((_OWORD *)v78 - 1) = v82;
                *(_OWORD *)v78 = v81;
                v78 -= 32;
                v79 -= 32;
                v80 -= 4;
              }
              while (v80);
              v62 = v77;
              if (v75 != (v75 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_98:
                do
                {
                  v83 = *((_QWORD *)v62 - 1);
                  v62 -= 8;
                  *(_QWORD *)v62 = 0;
                  *--v71 = v83;
                }
                while (v62 != v63);
              }
              v62 = *(char **)(a1 + 32);
              v84 = *(char **)(a1 + 40);
              *(_QWORD *)(a1 + 32) = v71;
              *(_QWORD *)(a1 + 40) = v72;
              *(_QWORD *)(a1 + 48) = v70;
              while (v84 != v62)
              {
                v86 = *((_QWORD *)v84 - 1);
                v84 -= 8;
                v85 = v86;
                *(_QWORD *)v84 = 0;
                if (v86)
                {
                  v87 = *(_QWORD *)(v85 + 32);
                  if (v87)
                    (*(void (**)(uint64_t))(*(_QWORD *)v87 + 24))(v87);
                  MEMORY[0x20BD0ADEC](v85, 0x1020C40615C549ELL);
                }
              }
            }
            if (v62)
              operator delete(v62);
            *(_QWORD *)(a1 + 40) = v72;
            return 1;
          }
        }
        else if (v62)
        {
          *(_QWORD *)v62 = v14;
          *(_QWORD *)(a1 + 40) = v62 + 8;
          return 1;
        }
        __break(1u);
LABEL_94:
        abort();
      }
    }
    (*(void (**)(_QWORD *))(*v41 + 24))(v41);
LABEL_63:
    MEMORY[0x20BD0ADEC](v14, 0x1020C40615C549ELL);
    return v11;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
LABEL_6:
    rtc::webrtc_logging_impl::Log("\r\t", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/ulpfec_receiver.cc");
  return 0;
}

void webrtc::UlpfecReceiver::ProcessReceivedFec(webrtc::UlpfecReceiver *this)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  unsigned int v18;
  __int128 v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  unsigned int *v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t *i;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int *v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  unsigned int *v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int *v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  unsigned int *v67;
  unsigned int v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  __int128 v74;
  unint64_t v75;
  webrtc::RtpHeaderExtensionMap *v76;
  uint64_t *v77;
  uint64_t v78;
  __int128 v79;
  uint64_t v80;
  __int128 v81;
  _BYTE v82[56];
  void *__p;
  void *v84;
  uint64_t v85;
  __int128 v86;
  unint64_t v87;
  uint64_t v88;
  char v89;
  uint64_t v90;
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  v1 = (uint64_t *)*((_QWORD *)this + 4);
  v2 = (uint64_t *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  if (v1 == v2)
  {
    if (!v1)
      return;
    goto LABEL_96;
  }
  v4 = 0;
  v76 = 0;
  v77 = (uint64_t *)((char *)this + 56);
  v5 = v1;
  do
  {
    v6 = *v5;
    if (*(_BYTE *)(*v5 + 8))
    {
      if (*(_BYTE *)(v6 + 9))
        goto LABEL_3;
LABEL_6:
      webrtc::ForwardErrorCorrection::DecodeFec(*((uint64_t **)this + 3), v6, v77);
      v76 = (webrtc::RtpHeaderExtensionMap *)(*v5 + 10);
      v4 += v7;
      goto LABEL_3;
    }
    v8 = *(_QWORD *)(v6 + 32);
    webrtc::RtpPacket::RtpPacket((webrtc::RtpPacket *)v82, (const webrtc::RtpHeaderExtensionMap *)(v6 + 10), (uint64_t *)0x5DC);
    v87 = 0x8000000000000000;
    v90 = 0;
    v88 = 0;
    v89 = 0;
    v9 = *(_QWORD *)(v8 + 8);
    *(_QWORD *)(v8 + 8) = 0;
    v80 = v9;
    v81 = *(_OWORD *)(v8 + 16);
    *(_QWORD *)(v8 + 16) = 0;
    *(_QWORD *)(v8 + 24) = 0;
    v10 = webrtc::RtpPacket::Parse((uint64_t)v82, &v80);
    v11 = v80;
    if (v80)
    {
      v12 = (unsigned int *)(v80 + 24);
      do
      {
        v13 = __ldaxr(v12);
        v14 = v13 - 1;
      }
      while (__stlxr(v14, v12));
      if (!v14)
      {
        v15 = *(_QWORD *)(v11 + 16);
        *(_QWORD *)(v11 + 16) = 0;
        if (v15)
          MEMORY[0x20BD0ADD4](v15, 0x1000C8077774924);
        MEMORY[0x20BD0ADEC](v11, 0x1010C40EE34DA14);
      }
    }
    if ((v10 & 1) != 0)
    {
      (***((void (****)(_QWORD, _BYTE *))this + 2))(*((_QWORD *)this + 2), v82);
      webrtc::RtpPacket::ZeroMutableExtensions((webrtc::RtpPacket *)v82);
      v16 = v85;
      if (v85)
      {
        v17 = (unsigned int *)(v85 + 24);
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }
      v19 = v86;
      v20 = *(_QWORD *)(v8 + 8);
      *(_QWORD *)(v8 + 8) = v16;
      if (v20)
      {
        v21 = (unsigned int *)(v20 + 24);
        do
        {
          v22 = __ldaxr(v21);
          v23 = v22 - 1;
        }
        while (__stlxr(v23, v21));
        if (!v23)
        {
          v74 = v19;
          v24 = *(_QWORD *)(v20 + 16);
          *(_QWORD *)(v20 + 16) = 0;
          if (v24)
            MEMORY[0x20BD0ADD4](v24, 0x1000C8077774924);
          MEMORY[0x20BD0ADEC](v20, 0x1010C40EE34DA14);
          v19 = v74;
        }
      }
      *(_OWORD *)(v8 + 16) = v19;
      v25 = v90;
      if (v90)
      {
        v26 = (unsigned int *)(v90 + 8);
        do
        {
          v27 = __ldaxr(v26);
          v28 = v27 - 1;
        }
        while (__stlxr(v28, v26));
        if (!v28)
          (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
      }
      v29 = v85;
      if (v85)
      {
        v30 = (unsigned int *)(v85 + 24);
        do
        {
          v31 = __ldaxr(v30);
          v32 = v31 - 1;
        }
        while (__stlxr(v32, v30));
        if (!v32)
        {
          v33 = *(_QWORD *)(v29 + 16);
          *(_QWORD *)(v29 + 16) = 0;
          if (v33)
            MEMORY[0x20BD0ADD4](v33, 0x1000C8077774924);
          MEMORY[0x20BD0ADEC](v29, 0x1010C40EE34DA14);
        }
      }
      if (__p)
      {
        v84 = __p;
        operator delete(__p);
      }
      v6 = *v5;
      if (!*(_BYTE *)(*v5 + 9))
        goto LABEL_6;
    }
    else
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      {
        v75 = v75 & 0xFFFFFFFF00000000 | 0x662;
        rtc::webrtc_logging_impl::Log("\r\t", v34, v35, v36, v37, v38, v39, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/ulpfec_receiver.cc");
      }
      v41 = v90;
      if (v90)
      {
        v42 = (unsigned int *)(v90 + 8);
        do
        {
          v43 = __ldaxr(v42);
          v44 = v43 - 1;
        }
        while (__stlxr(v44, v42));
        if (!v44)
          (*(void (**)(uint64_t))(*(_QWORD *)v41 + 8))(v41);
      }
      v45 = v85;
      if (v85)
      {
        v46 = (unsigned int *)(v85 + 24);
        do
        {
          v47 = __ldaxr(v46);
          v48 = v47 - 1;
        }
        while (__stlxr(v48, v46));
        if (!v48)
        {
          v49 = *(_QWORD *)(v45 + 16);
          *(_QWORD *)(v45 + 16) = 0;
          if (v49)
            MEMORY[0x20BD0ADD4](v49, 0x1000C8077774924);
          MEMORY[0x20BD0ADEC](v45, 0x1010C40EE34DA14);
        }
      }
      if (__p)
      {
        v84 = __p;
        operator delete(__p);
      }
    }
LABEL_3:
    ++v5;
  }
  while (v5 != v2);
  if (v4)
  {
    for (i = (uint64_t *)*((_QWORD *)this + 8); i != v77; i = (uint64_t *)i[1])
    {
      v51 = i[2];
      if (!*(_BYTE *)(v51 + 9))
      {
        v52 = *(_QWORD *)(v51 + 16);
        ++*((_QWORD *)this + 13);
        *(_BYTE *)(v51 + 9) = 1;
        webrtc::RtpPacket::RtpPacket((webrtc::RtpPacket *)v82, v76, (uint64_t *)0x5DC);
        v87 = 0x8000000000000000;
        v90 = 0;
        v88 = 0;
        v89 = 0;
        v53 = *(_QWORD *)(v52 + 8);
        v78 = v53;
        if (v53)
        {
          v54 = (unsigned int *)(v53 + 24);
          do
            v55 = __ldxr(v54);
          while (__stxr(v55 + 1, v54));
        }
        v79 = *(_OWORD *)(v52 + 16);
        v56 = webrtc::RtpPacket::Parse((uint64_t)v82, &v78);
        v57 = v78;
        if (v78)
        {
          v58 = (unsigned int *)(v78 + 24);
          do
          {
            v59 = __ldaxr(v58);
            v60 = v59 - 1;
          }
          while (__stlxr(v60, v58));
          if (!v60)
          {
            v61 = *(_QWORD *)(v57 + 16);
            *(_QWORD *)(v57 + 16) = 0;
            if (v61)
              MEMORY[0x20BD0ADD4](v61, 0x1000C8077774924);
            MEMORY[0x20BD0ADEC](v57, 0x1010C40EE34DA14);
          }
        }
        if (v56)
        {
          v89 = 1;
          (***((void (****)(_QWORD, _BYTE *))this + 2))(*((_QWORD *)this + 2), v82);
        }
        v62 = v90;
        if (v90)
        {
          v63 = (unsigned int *)(v90 + 8);
          do
          {
            v64 = __ldaxr(v63);
            v65 = v64 - 1;
          }
          while (__stlxr(v65, v63));
          if (!v65)
            (*(void (**)(uint64_t))(*(_QWORD *)v62 + 8))(v62);
        }
        v66 = v85;
        if (v85)
        {
          v67 = (unsigned int *)(v85 + 24);
          do
          {
            v68 = __ldaxr(v67);
            v69 = v68 - 1;
          }
          while (__stlxr(v69, v67));
          if (!v69)
          {
            v70 = *(_QWORD *)(v66 + 16);
            *(_QWORD *)(v66 + 16) = 0;
            if (v70)
              MEMORY[0x20BD0ADD4](v70, 0x1000C8077774924);
            MEMORY[0x20BD0ADEC](v66, 0x1010C40EE34DA14);
          }
        }
        if (__p)
        {
          v84 = __p;
          operator delete(__p);
        }
      }
    }
  }
  if (v1)
  {
    do
    {
      v72 = *--v2;
      v71 = v72;
      *v2 = 0;
      if (v72)
      {
        v73 = *(_QWORD *)(v71 + 32);
        if (v73)
          (*(void (**)(uint64_t))(*(_QWORD *)v73 + 24))(v73);
        MEMORY[0x20BD0ADEC](v71, 0x1020C40615C549ELL);
      }
    }
    while (v2 != v1);
LABEL_96:
    operator delete(v1);
  }
}

uint64_t webrtc::UnderrunOptimizer::Update(uint64_t this, int a2)
{
  uint64_t v3;
  uint64_t *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  int v23;
  unint64_t v24;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  unint64_t v30;
  int v31;

  v3 = this;
  if (*(_BYTE *)(this + 80))
  {
    if (!*(_QWORD *)(this + 88))
    {
      v4 = *(uint64_t **)this;
      v5 = (_QWORD *)operator new();
      v6 = *v4;
      *v5 = v4;
      v5[1] = v6;
      this = *(_QWORD *)(v3 + 88);
      *(_QWORD *)(v3 + 88) = v5;
      if (this)
        this = MEMORY[0x20BD0ADEC](this, 0x1060C40C2E02434);
    }
    if (!*(_BYTE *)(v3 + 80))
      goto LABEL_33;
    v7 = *(_QWORD **)(v3 + 88);
    v8 = (_QWORD *)*v7;
    v9 = *(_QWORD *)*v7 - v7[1];
    v10 = *((int *)v8 + 2);
    v11 = 0xFFFFFFFFFFFFFFFFLL / v10;
    v12 = v10 * v9;
    if (v9 >= v11)
      v13 = -1;
    else
      v13 = v12;
    v14 = *(_DWORD *)(v3 + 96);
    if (*(_DWORD *)(v3 + 76) >= v13)
    {
      if (v14 <= a2)
        v31 = a2;
      else
        v31 = *(_DWORD *)(v3 + 96);
      *(_DWORD *)(v3 + 96) = v31;
      return this;
    }
    v15 = *(uint64_t **)v3;
    v16 = (_QWORD *)operator new();
    v17 = *v15;
    *v16 = v15;
    v16[1] = v17;
    this = *(_QWORD *)(v3 + 88);
    *(_QWORD *)(v3 + 88) = v16;
    if (this)
      this = MEMORY[0x20BD0ADEC](this, 0x1060C40C2E02434);
    *(_DWORD *)(v3 + 96) = a2 & ~(a2 >> 31);
    a2 = v14;
  }
  v18 = *(char **)(v3 + 16);
  v19 = *(char **)(v3 + 24);
  v20 = v19 - v18;
  if (a2 / 20 < (int)((unint64_t)(v19 - v18) >> 2))
  {
    this = webrtc::Histogram::Add(v3 + 8, a2 / 20);
    v18 = *(char **)(v3 + 16);
    v19 = *(char **)(v3 + 24);
    v20 = v19 - v18;
  }
  if (v19 == v18)
  {
LABEL_33:
    __break(1u);
    return this;
  }
  v21 = *(_DWORD *)(v3 + 72);
  v22 = v20 >> 2;
  v23 = *(_DWORD *)v18;
  v24 = v22 - 1;
  if (v22 != 1 && v23 < v21)
  {
    v27 = 0x40000000 - v21;
    v28 = 0x40000000 - v23;
    if (v22 <= 1)
      v29 = 1;
    else
      v29 = v22;
    v26 = 20;
    v30 = 1;
    while (v29 != v30)
    {
      v26 += 20;
      if (v30 < v24)
      {
        v28 -= *(_DWORD *)&v18[4 * v30++];
        if (v28 > v27)
          continue;
      }
      goto LABEL_28;
    }
    goto LABEL_33;
  }
  v26 = 20;
LABEL_28:
  *(_DWORD *)(v3 + 100) = v26;
  *(_BYTE *)(v3 + 104) = 1;
  return this;
}

uint64_t rtc::UniqueRandomIdGenerator::GenerateId(rtc::UniqueRandomIdGenerator *this)
{
  rtc *RandomId;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t **v7;
  int v8;
  uint64_t *v9;
  unsigned int v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t **v16;
  uint64_t **v17;
  int v18;
  void *v19;
  size_t v20;

  RandomId = (rtc *)pthread_mutex_lock((pthread_mutex_t *)this);
  if (*((_QWORD *)this + 10) > 0xFFFFFFFDuLL)
  {
    v18 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/unique_id_generator.cc", 32, "known_ids_.size() < std::numeric_limits<uint32_t>::max() - 1", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int> const&)::t, v3, v4, v5, v6, *((_QWORD *)this + 10));
    return rtc::UniqueStringGenerator::AddKnownId(v18, v19, v20);
  }
  else
  {
    v7 = (uint64_t **)((char *)this + 72);
    while (1)
    {
      do
        RandomId = (rtc *)rtc::CreateRandomId(RandomId);
      while (!(_DWORD)RandomId);
      v8 = (int)RandomId;
      v9 = *v7;
      if (!*v7)
        break;
      while (1)
      {
        while (1)
        {
          v17 = (uint64_t **)v9;
          v10 = *((_DWORD *)v9 + 7);
          if (RandomId >= v10)
            break;
          v9 = *v17;
          v16 = v17;
          if (!*v17)
            goto LABEL_11;
        }
        if (v10 >= RandomId)
          break;
        v9 = v17[1];
        if (!v9)
        {
          v16 = v17 + 1;
          goto LABEL_11;
        }
      }
    }
    v16 = (uint64_t **)((char *)this + 72);
    v17 = (uint64_t **)((char *)this + 72);
LABEL_11:
    v11 = operator new(0x20uLL);
    v11[7] = v8;
    *(_QWORD *)v11 = 0;
    *((_QWORD *)v11 + 1) = 0;
    *((_QWORD *)v11 + 2) = v17;
    *v16 = (uint64_t *)v11;
    v12 = **((_QWORD **)this + 8);
    v13 = (uint64_t *)v11;
    if (v12)
    {
      *((_QWORD *)this + 8) = v12;
      v13 = *v16;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 9), v13);
    ++*((_QWORD *)this + 10);
    v14 = v11[7];
    pthread_mutex_unlock((pthread_mutex_t *)this);
    return v14;
  }
}

uint64_t rtc::UniqueStringGenerator::AddKnownId(uint64_t a1, char *__src, size_t __len)
{
  char *p_p;
  size_t v7;
  size_t v8;
  char *v9;
  size_t v11;
  void **v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  char v16;
  unsigned int v17;
  uint64_t *v19;
  uint64_t **v20;
  uint64_t **v21;
  unsigned int v22;
  _DWORD *v23;
  uint64_t v24;
  uint64_t *v25;
  void *__p;
  size_t __lena;
  unint64_t v28;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
LABEL_44:
    abort();
  if (__len > 0x16)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    p_p = (char *)operator new(v7 + 1);
    __lena = __len;
    v28 = v8 | 0x8000000000000000;
    __p = p_p;
  }
  else
  {
    HIBYTE(v28) = __len;
    p_p = (char *)&__p;
  }
  v9 = &p_p[__len];
  if (p_p <= __src && v9 > __src)
  {
LABEL_43:
    __break(1u);
    goto LABEL_44;
  }
  if (__len)
    memmove(p_p, __src, __len);
  *v9 = 0;
  if (SHIBYTE(v28) < 0)
  {
    v11 = __lena;
    if ((__lena & 0x8000000000000000) == 0)
    {
      v12 = (void **)__p;
      if (!__lena || __p)
        goto LABEL_18;
    }
    goto LABEL_43;
  }
  v11 = HIBYTE(v28);
  v12 = &__p;
LABEL_18:
  v13 = rtc::string_to_number_internal::ParseUnsigned(v12, v11, 10);
  if (v14)
    v15 = HIDWORD(v13) == 0;
  else
    v15 = 0;
  v16 = !v15;
  if (v15)
    v17 = v13;
  else
    v17 = 0;
  if (SHIBYTE(v28) < 0)
  {
    operator delete(__p);
    if ((v16 & 1) != 0)
      return 0;
  }
  else if ((v16 & 1) != 0)
  {
    return 0;
  }
  v20 = (uint64_t **)(a1 + 16);
  v19 = *(uint64_t **)(a1 + 16);
  if (v19)
  {
    while (1)
    {
      while (1)
      {
        v21 = (uint64_t **)v19;
        v22 = *((_DWORD *)v19 + 7);
        if (v22 <= v17)
          break;
        v19 = *v21;
        v20 = v21;
        if (!*v21)
          goto LABEL_39;
      }
      if (v22 >= v17)
        return 0;
      v19 = v21[1];
      if (!v19)
      {
        v20 = v21 + 1;
        goto LABEL_39;
      }
    }
  }
  v21 = (uint64_t **)(a1 + 16);
LABEL_39:
  v23 = operator new(0x20uLL);
  v23[7] = v17;
  *(_QWORD *)v23 = 0;
  *((_QWORD *)v23 + 1) = 0;
  *((_QWORD *)v23 + 2) = v21;
  *v20 = (uint64_t *)v23;
  v24 = **(_QWORD **)(a1 + 8);
  if (v24)
  {
    *(_QWORD *)(a1 + 8) = v24;
    v25 = *v20;
  }
  else
  {
    v25 = (uint64_t *)v23;
  }
  std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v25);
  ++*(_QWORD *)(a1 + 24);
  return 1;
}

uint64_t rtc::UniqueNumberGenerator<unsigned int>::GenerateNumber(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  _QWORD *v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  _QWORD *v14;
  unsigned int v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t *v18;

  v10 = *a1;
  if (*a1 == -1)
  {
LABEL_10:
    rtc::webrtc_checks_impl::FatalLog("Source/webrtc/rtc_base/unique_id_generator.h", 135, "counter_ < std::numeric_limits<TIntegral>::max()", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)4,unsigned int> const&)::t, a5, a6, a7, a8, 0xFFFFFFFFLL);
    goto LABEL_11;
  }
  v8 = a1;
  v9 = a1 + 4;
  v11 = *((_QWORD *)a1 + 2);
  if (v11)
  {
    while (2)
    {
      v12 = v10++;
      *a1 = v10;
      v13 = v11;
      while (1)
      {
        while (1)
        {
          v14 = (_QWORD *)v13;
          v15 = *(_DWORD *)(v13 + 28);
          if (v12 >= v15)
            break;
          v13 = *v14;
          if (!*v14)
          {
            v10 = v12;
            v9 = v14;
            goto LABEL_13;
          }
        }
        if (v15 >= v12)
          break;
        v13 = v14[1];
        if (!v13)
        {
          v9 = v14 + 1;
          v10 = v12;
          goto LABEL_13;
        }
      }
      if (v10 != -1)
        continue;
      goto LABEL_10;
    }
  }
LABEL_11:
  *v8 = v10 + 1;
  v14 = v9;
LABEL_13:
  v16 = operator new(0x20uLL);
  v16[7] = v10;
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = 0;
  *((_QWORD *)v16 + 2) = v14;
  *v9 = v16;
  v17 = **((_QWORD **)v8 + 1);
  v18 = (uint64_t *)v16;
  if (v17)
  {
    *((_QWORD *)v8 + 1) = v17;
    v18 = (uint64_t *)*v9;
  }
  std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v8 + 2), v18);
  ++*((_QWORD *)v8 + 3);
  return v16[7];
}

void webrtc::UniqueTimestampCounter::Add(webrtc::UniqueTimestampCounter *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  uint64_t *v15;
  unsigned int v16;
  uint64_t **v17;
  uint64_t *v18;
  unsigned int v19;
  BOOL v20;
  uint64_t **v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t **v24;
  BOOL v25;

  v2 = a2;
  if (*((_QWORD *)this + 5) != a2)
  {
    v6 = (uint64_t **)((char *)this + 16);
    v5 = (uint64_t *)*((_QWORD *)this + 2);
    v7 = (uint64_t **)((char *)this + 16);
    v8 = (uint64_t **)((char *)this + 16);
    if (v5)
    {
      while (1)
      {
        while (1)
        {
          v8 = (uint64_t **)v5;
          v9 = *((_DWORD *)v5 + 7);
          if (v9 <= a2)
            break;
          v5 = *v8;
          v7 = v8;
          if (!*v8)
            goto LABEL_9;
        }
        if (v9 >= a2)
          break;
        v5 = v8[1];
        if (!v5)
        {
          v7 = v8 + 1;
          goto LABEL_9;
        }
      }
    }
    else
    {
LABEL_9:
      v10 = operator new(0x20uLL);
      v10[7] = a2;
      *(_QWORD *)v10 = 0;
      *((_QWORD *)v10 + 1) = 0;
      *((_QWORD *)v10 + 2) = v8;
      *v7 = (uint64_t *)v10;
      v11 = **((_QWORD **)this + 1);
      if (v11)
      {
        *((_QWORD *)this + 1) = v11;
        v12 = *v7;
      }
      else
      {
        v12 = (uint64_t *)v10;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 2), v12);
      v13 = *((_QWORD *)this + 3);
      *((_QWORD *)this + 3) = v13 + 1;
      v14 = *(_DWORD *)this % 1000;
      if (*(int *)this >= 1000)
      {
        v15 = *v6;
        if (*v6)
        {
          v16 = *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v14);
          v17 = v6;
          v18 = *v6;
          do
          {
            v19 = *((_DWORD *)v18 + 7);
            v20 = v19 >= v16;
            if (v19 >= v16)
              v21 = (uint64_t **)v18;
            else
              v21 = (uint64_t **)(v18 + 1);
            if (v20)
              v17 = (uint64_t **)v18;
            v18 = *v21;
          }
          while (*v21);
          if (v17 != v6 && v16 >= *((_DWORD *)v17 + 7))
          {
            v22 = v17[1];
            if (v22)
            {
              do
              {
                v23 = v22;
                v22 = (uint64_t *)*v22;
              }
              while (v22);
            }
            else
            {
              v24 = v17;
              do
              {
                v23 = v24[2];
                v25 = *v23 == (_QWORD)v24;
                v24 = (uint64_t **)v23;
              }
              while (!v25);
            }
            if (*((uint64_t ***)this + 1) == v17)
              *((_QWORD *)this + 1) = v23;
            *((_QWORD *)this + 3) = v13;
            std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v15, (uint64_t *)v17);
            operator delete(v17);
          }
        }
      }
      *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v14) = a2;
      *((_QWORD *)this + 5) = v2;
      ++*(_DWORD *)this;
    }
  }
}

void dcsctp::UnrecognizedChunkTypeCause::~UnrecognizedChunkTypeCause(dcsctp::UnrecognizedChunkTypeCause *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C0C2E68;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_24C0C2E68;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x20BD0ADECLL);
}

void dcsctp::UnrecognizedChunkTypeCause::SerializeTo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  char *v11;
  unint64_t v12;
  __int16 v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  const void *v17;
  size_t v18;
  BOOL v19;
  std::string *v20;
  std::string *v21;
  uint64_t v22;

  v10 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
  v11 = *(char **)a2;
  v12 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  v13 = v10 + 4;
  v14 = v12 + v10 + 4;
  if (v12 >= v14)
  {
    if (v12 > v14)
      *(_QWORD *)(a2 + 8) = &v11[v14];
  }
  else
  {
    std::vector<unsigned char>::__append((char **)a2, v10 + 4);
    v11 = *(char **)a2;
  }
  v15 = &v11[v12];
  *(_WORD *)v15 = 1536;
  v15[2] = HIBYTE(v13);
  v15[3] = v13;
  if (v10 >= 0xFFFFFFFFFFFFFFFCLL)
  {
    v20 = rtc::webrtc_checks_impl::FatalLog("Source/webrtc/net/dcsctp/packet/bounded_byte_writer.h", 59, "data.size() >= FixedSize", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v22);
    dcsctp::UnrecognizedChunkTypeCause::ToString((dcsctp::UnrecognizedChunkTypeCause *)v20, v21);
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
    if (v16)
      v17 = *(const void **)(a1 + 8);
    else
      v17 = 0;
    if (v10 >= v16)
      v18 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
    else
      v18 = v10;
    if (v17)
      v19 = v18 == 0;
    else
      v19 = 1;
    if (!v19)
      memcpy((void *)(*(_QWORD *)a2 + v12 + 4), v17, v18);
  }
}

char *dcsctp::UnrecognizedChunkTypeCause::ToString@<X0>(dcsctp::UnrecognizedChunkTypeCause *this@<X0>, std::string *a2@<X8>)
{
  char *result;
  char *v5;
  unsigned __int8 *v6;
  const char *v7;
  std::string v8;

  result = (char *)operator new(0x30uLL);
  v5 = result + 36;
  if (result > "Unrecognized Chunk Type, chunk_type=" || v5 <= "Unrecognized Chunk Type, chunk_type=")
  {
    strcpy(result, "Unrecognized Chunk Type, chunk_type=");
    v8.__r_.__value_.__r.__words[0] = (std::string::size_type)result;
    *(_OWORD *)&v8.__r_.__value_.__r.__words[1] = xmmword_208F1CA20;
    v6 = (unsigned __int8 *)*((_QWORD *)this + 1);
    if (v6 != *((unsigned __int8 **)this + 2))
    {
      result = (char *)rtc::StringBuilder::operator<<(&v8, *v6);
LABEL_8:
      *a2 = v8;
      return result;
    }
    v7 = result + 45;
    if (v5 > "<missing>" || v7 <= "<missing>")
    {
      result[44] = 62;
      *(_QWORD *)v5 = *(_QWORD *)"<missing>";
      v8.__r_.__value_.__l.__size_ = 45;
      *v7 = 0;
      goto LABEL_8;
    }
  }
  __break(1u);
  return result;
}

void dcsctp::UnrecognizedParametersCause::~UnrecognizedParametersCause(dcsctp::UnrecognizedParametersCause *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C0C2E98;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_24C0C2E98;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x20BD0ADECLL);
}

void dcsctp::UnrecognizedParametersCause::SerializeTo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  char *v11;
  unint64_t v12;
  __int16 v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  const void *v17;
  size_t v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;

  v10 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
  v11 = *(char **)a2;
  v12 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  v13 = v10 + 4;
  v14 = v12 + v10 + 4;
  if (v12 >= v14)
  {
    if (v12 > v14)
      *(_QWORD *)(a2 + 8) = &v11[v14];
  }
  else
  {
    std::vector<unsigned char>::__append((char **)a2, v10 + 4);
    v11 = *(char **)a2;
  }
  v15 = &v11[v12];
  *(_WORD *)v15 = 2048;
  v15[2] = HIBYTE(v13);
  v15[3] = v13;
  if (v10 >= 0xFFFFFFFFFFFFFFFCLL)
  {
    rtc::webrtc_checks_impl::FatalLog("Source/webrtc/net/dcsctp/packet/bounded_byte_writer.h", 59, "data.size() >= FixedSize", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v21);
    dcsctp::UnrecognizedParametersCause::ToString(v20);
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
    if (v16)
      v17 = *(const void **)(a1 + 8);
    else
      v17 = 0;
    if (v10 >= v16)
      v18 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
    else
      v18 = v10;
    if (v17)
      v19 = v18 == 0;
    else
      v19 = 1;
    if (!v19)
      memcpy((void *)(*(_QWORD *)a2 + v12 + 4), v17, v18);
  }
}

char *dcsctp::UnrecognizedParametersCause::ToString@<X0>(uint64_t a1@<X8>)
{
  char *result;

  result = (char *)operator new(0x19uLL);
  *(_QWORD *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_208F05110;
  if (result <= "Unrecognized Parameters" && result + 23 > "Unrecognized Parameters")
    __break(1u);
  else
    strcpy(result, "Unrecognized Parameters");
  return result;
}

void dcsctp::UnresolvableAddressCause::~UnresolvableAddressCause(dcsctp::UnresolvableAddressCause *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C0C2EC8;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_24C0C2EC8;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x20BD0ADECLL);
}

void dcsctp::UnresolvableAddressCause::SerializeTo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  char *v11;
  unint64_t v12;
  __int16 v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  const void *v17;
  size_t v18;
  BOOL v19;
  char *v20;
  uint64_t v21;

  v10 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
  v11 = *(char **)a2;
  v12 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  v13 = v10 + 4;
  v14 = v12 + v10 + 4;
  if (v12 >= v14)
  {
    if (v12 > v14)
      *(_QWORD *)(a2 + 8) = &v11[v14];
  }
  else
  {
    std::vector<unsigned char>::__append((char **)a2, v10 + 4);
    v11 = *(char **)a2;
  }
  v15 = &v11[v12];
  *(_WORD *)v15 = 1280;
  v15[2] = HIBYTE(v13);
  v15[3] = v13;
  if (v10 >= 0xFFFFFFFFFFFFFFFCLL)
  {
    rtc::webrtc_checks_impl::FatalLog("Source/webrtc/net/dcsctp/packet/bounded_byte_writer.h", 59, "data.size() >= FixedSize", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v21);
    dcsctp::UnresolvableAddressCause::ToString(v20);
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
    if (v16)
      v17 = *(const void **)(a1 + 8);
    else
      v17 = 0;
    if (v10 >= v16)
      v18 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
    else
      v18 = v10;
    if (v17)
      v19 = v18 == 0;
    else
      v19 = 1;
    if (!v19)
      memcpy((void *)(*(_QWORD *)a2 + v12 + 4), v17, v18);
  }
}

void dcsctp::UnresolvableAddressCause::ToString(char *a1@<X8>)
{
  a1[23] = 20;
  if (a1 <= "Unresolvable Address" && a1 + 20 > "Unresolvable Address")
    __break(1u);
  else
    strcpy(a1, "Unresolvable Address");
}

void dcsctp::UserInitiatedAbortCause::Parse(unsigned __int16 *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned __int16 *v4;
  unint64_t v5;
  BOOL v6;
  BOOL v7;
  void **v8;
  size_t v9;
  void **p_dst;
  uint64_t v11;
  uint64_t v12;
  size_t v14;
  void **v15;
  void **v16;
  void **v17;
  uint64_t v18;
  uint64_t v19;
  void **__dst;
  unint64_t v21;
  unint64_t v22;
  void (**v23)(dcsctp::UserInitiatedAbortCause *__hidden);
  __int128 v24;
  unint64_t v25;

  if (a2)
    v4 = a1;
  else
    v4 = 0;
  if (a2 < 4
    || __rev16(*v4) != 12
    || ((v5 = __rev16(v4[1]), v5 >= 4) ? (v6 = a2 >= v5) : (v6 = 0),
        v6 ? (v7 = a2 - v5 >= 4) : (v7 = 1),
        v7))
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 32) = 0;
    return;
  }
  if (v5 <= 4)
  {
    *(_QWORD *)a3 = off_24C0C2EF8;
    *(_QWORD *)(a3 + 8) = 0;
    *(_WORD *)(a3 + 31) = 256;
    return;
  }
  v8 = (void **)(v4 + 2);
  v9 = v5 - 4;
  if (v5 - 4 > 0x16)
  {
    v11 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17)
      v11 = v9 | 7;
    v12 = v11 + 1;
    p_dst = (void **)operator new(v11 + 1);
    v21 = v9;
    v22 = v12 | 0x8000000000000000;
    __dst = p_dst;
  }
  else
  {
    HIBYTE(v22) = v5 - 4;
    p_dst = (void **)&__dst;
  }
  if (p_dst <= v8 && (void **)((char *)p_dst + v9) > v8)
    goto LABEL_44;
  memmove(p_dst, v8, v9);
  *((_BYTE *)p_dst + v9) = 0;
  if (SHIBYTE(v22) < 0)
  {
    v14 = v21;
    if ((v21 & 0x8000000000000000) != 0)
      goto LABEL_44;
    v15 = __dst;
    if (v21)
    {
      if (!__dst)
        goto LABEL_44;
    }
    v23 = off_24C0C2EF8;
    if (v21 >= 0x7FFFFFFFFFFFFFF8)
      goto LABEL_45;
    if (v21 <= 0x16)
      goto LABEL_29;
LABEL_36:
    v18 = (v14 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17)
      v18 = v14 | 7;
    v19 = v18 + 1;
    v16 = (void **)operator new(v18 + 1);
    *((_QWORD *)&v24 + 1) = v14;
    v25 = v19 | 0x8000000000000000;
    *(_QWORD *)&v24 = v16;
    v17 = (void **)((char *)v16 + v14);
    if (v16 > v15)
      goto LABEL_40;
    goto LABEL_39;
  }
  v14 = HIBYTE(v22);
  v23 = off_24C0C2EF8;
  v15 = (void **)&__dst;
  if (HIBYTE(v22) > 0x16uLL)
    goto LABEL_36;
LABEL_29:
  HIBYTE(v25) = v14;
  v16 = (void **)&v24;
  v17 = (void **)((char *)&v24 + v14);
  if (&v24 > (__int128 *)v15)
    goto LABEL_40;
LABEL_39:
  if (v17 > v15)
  {
LABEL_44:
    __break(1u);
LABEL_45:
    abort();
  }
LABEL_40:
  if (v14)
    memmove(v16, v15, v14);
  *(_BYTE *)v17 = 0;
  *(_QWORD *)a3 = off_24C0C2EF8;
  *(_OWORD *)(a3 + 8) = v24;
  *(_QWORD *)(a3 + 24) = v25;
  v24 = 0uLL;
  v25 = 0;
  *(_BYTE *)(a3 + 32) = 1;
  v23 = off_24C0C2EF8;
  if (SHIBYTE(v22) < 0)
    operator delete(__dst);
}

void dcsctp::UserInitiatedAbortCause::~UserInitiatedAbortCause(void **this)
{
  *this = off_24C0C2EF8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_24C0C2EF8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x20BD0ADECLL);
}

void dcsctp::UserInitiatedAbortCause::SerializeTo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  char *v16;
  const void *v17;
  size_t v18;
  unint64_t v19;
  std::string *v20;
  uint64_t v21;

  if (*(char *)(a1 + 31) < 0)
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(char **)a2;
    v12 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
    v13 = v10 + 4;
    v14 = v12 + v10 + 4;
    v15 = v12 > v14;
    if (v12 < v14)
      goto LABEL_3;
  }
  else
  {
    v10 = *(unsigned __int8 *)(a1 + 31);
    v11 = *(char **)a2;
    v12 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
    v13 = v10 + 4;
    v14 = v12 + v10 + 4;
    v15 = v12 > v14;
    if (v12 < v14)
    {
LABEL_3:
      std::vector<unsigned char>::__append((char **)a2, v13);
      v11 = *(char **)a2;
      goto LABEL_8;
    }
  }
  if (v15)
    *(_QWORD *)(a2 + 8) = &v11[v14];
LABEL_8:
  v16 = &v11[v12];
  *(_WORD *)v16 = 3072;
  v16[2] = BYTE1(v13);
  v16[3] = v13;
  if (v10 >= 0xFFFFFFFFFFFFFFFCLL)
  {
    v20 = rtc::webrtc_checks_impl::FatalLog("Source/webrtc/net/dcsctp/packet/bounded_byte_writer.h", 59, "data.size() >= FixedSize", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v21);
    dcsctp::UserInitiatedAbortCause::ToString((dcsctp::UserInitiatedAbortCause *)v20);
    return;
  }
  if ((*(char *)(a1 + 31) & 0x80000000) == 0)
  {
    if (*(_BYTE *)(a1 + 31))
      v17 = (const void *)(a1 + 8);
    else
      v17 = 0;
    if (v10 >= *(unsigned __int8 *)(a1 + 31))
      v18 = *(unsigned __int8 *)(a1 + 31);
    else
      v18 = v10;
    if (!v18)
      return;
LABEL_25:
    if (v17)
      memcpy((void *)(*(_QWORD *)a2 + v12 + 4), v17, v18);
    return;
  }
  v19 = *(_QWORD *)(a1 + 16);
  if (v19)
    v17 = *(const void **)(a1 + 8);
  else
    v17 = 0;
  if (v10 >= v19)
    v18 = *(_QWORD *)(a1 + 16);
  else
    v18 = v10;
  if (v18)
    goto LABEL_25;
}

void dcsctp::UserInitiatedAbortCause::ToString(dcsctp::UserInitiatedAbortCause *this@<X0>, std::string *a2@<X8>)
{
  char *v4;
  std::string::value_type *v5;
  int v6;
  const std::string::value_type *v7;
  std::string::size_type v8;
  BOOL v9;
  std::string v10;

  v4 = (char *)operator new(0x30uLL);
  v5 = v4 + 29;
  if (v4 <= "User-Initiated Abort, reason=" && v5 > "User-Initiated Abort, reason=")
    goto LABEL_15;
  strcpy(v4, "User-Initiated Abort, reason=");
  v10.__r_.__value_.__r.__words[0] = (std::string::size_type)v4;
  *(_OWORD *)&v10.__r_.__value_.__r.__words[1] = xmmword_208F1CA30;
  v6 = *((char *)this + 31);
  v7 = (char *)this + 8;
  if (v6 < 0)
  {
    v8 = *((_QWORD *)this + 2);
    if ((v8 & 0x8000000000000000) != 0)
      goto LABEL_15;
    v7 = *(const std::string::value_type **)v7;
    v9 = v8 == 0;
    if (v8)
    {
      if (!v7)
        goto LABEL_15;
    }
  }
  else
  {
    v8 = *((unsigned __int8 *)this + 31);
    v9 = v6 == 0;
  }
  if (v8 > 0x12)
  {
    std::string::__grow_by_and_replace(&v10, 0x2FuLL, v8 - 18, 0x1DuLL, 0x1DuLL, 0, v8, v7);
LABEL_14:
    *a2 = v10;
    return;
  }
  if (v9)
    goto LABEL_14;
  if (v5 > v7 || &v5[v8] <= v7)
  {
    memmove(v5, v7, v8);
    v10.__r_.__value_.__l.__size_ = v8 + 29;
    v4[v8 + 29] = 0;
    goto LABEL_14;
  }
LABEL_15:
  __break(1u);
}

void webrtc::`anonymous namespace'::VadImpl::Reset(webrtc::_anonymous_namespace_::VadImpl *this)
{
  void *v2;
  _DWORD *v3;
  int inited;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  std::string *v17;

  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
    free(v2);
  v3 = malloc_type_malloc(0x2E0uLL, 0x1000040384D0BBCuLL);
  v3[183] = 0;
  *((_QWORD *)this + 1) = v3;
  inited = WebRtcVad_InitCore((uint64_t)v3);
  v5 = *((_QWORD *)this + 1);
  if (inited)
  {
    v7 = WebRtcVad_Init(v5);
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/common_audio/vad/vad.cc", 51, "WebRtcVad_Init(handle_) == 0", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, v8, v9, v10, v11, v7);
    goto LABEL_9;
  }
  v6 = *((_DWORD *)this + 4);
  if (!v5 || *(_DWORD *)(v5 + 732) != 42)
    goto LABEL_10;
  if (WebRtcVad_set_mode_core(v5, v6))
  {
LABEL_9:
    v5 = *((_QWORD *)this + 1);
    v6 = *((_DWORD *)this + 4);
LABEL_10:
    v12 = WebRtcVad_set_mode(v5, v6);
    v17 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/common_audio/vad/vad.cc", 52, "WebRtcVad_set_mode(handle_, aggressiveness_) == 0", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, v13, v14, v15, v16, v12);
  }
}

void webrtc::`anonymous namespace'::VadImpl::~VadImpl(void **this)
{
  free(this[1]);
}

{
  free(this[1]);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::`anonymous namespace'::VadImpl::VoiceActivity(webrtc::_anonymous_namespace_::VadImpl *this, __int16 *a2, unint64_t a3, int a4)
{
  int v4;
  unsigned int v5;

  v4 = WebRtcVad_Process(*((_DWORD **)this + 1), a4, a2, a3);
  if (v4 == 1)
    v5 = 1;
  else
    v5 = -1;
  if (v4)
    return v5;
  else
    return 0;
}

webrtc::VadAudioProc *webrtc::VadAudioProc::VadAudioProc(webrtc::VadAudioProc *this)
{
  uint64_t v2;
  float32x4_t v3;
  float *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  double v8;
  long double v9;
  float v11[512];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  bzero((char *)this + 3072, 0x8C0uLL);
  *((_QWORD *)this + 664) = 80;
  *((_QWORD *)this + 665) = 0xC000000000000000;
  *((_QWORD *)this + 666) = 0x4049000000000000;
  *((_QWORD *)this + 667) = operator new();
  *((_QWORD *)this + 668) = operator new();
  v2 = operator new();
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 128) = 0u;
  *(_OWORD *)(v2 + 144) = 0u;
  *(_OWORD *)(v2 + 160) = 0u;
  *(_OWORD *)(v2 + 176) = 0u;
  *(_OWORD *)(v2 + 192) = 0u;
  *(_OWORD *)(v2 + 208) = 0u;
  *(_OWORD *)(v2 + 224) = 0u;
  *(_OWORD *)(v2 + 240) = 0u;
  *(_OWORD *)(v2 + 256) = 0u;
  *(_OWORD *)(v2 + 272) = 0u;
  *(_OWORD *)(v2 + 288) = 0u;
  *(_OWORD *)(v2 + 304) = 0u;
  *(_OWORD *)(v2 + 320) = 0u;
  *(_OWORD *)(v2 + 336) = 0u;
  *(_OWORD *)(v2 + 352) = 0u;
  *(_OWORD *)(v2 + 368) = 0u;
  *(_OWORD *)(v2 + 384) = 0u;
  *(_OWORD *)(v2 + 400) = 0u;
  *(_OWORD *)(v2 + 416) = 0u;
  *(_OWORD *)(v2 + 432) = 0u;
  *(_OWORD *)(v2 + 448) = 0u;
  *(_OWORD *)(v2 + 464) = 0u;
  *(_QWORD *)(v2 + 480) = 0;
  *(_QWORD *)(v2 + 488) = 2;
  v3 = (float32x4_t)vdupq_n_s64(2uLL);
  *(_DWORD *)(v2 + 296) = 1064930883;
  *(_QWORD *)(v2 + 288) = 0xBFF98E223F798E43;
  *(_DWORD *)(v2 + 396) = 1064891121;
  *(float32x4_t *)(v2 + 496) = v3;
  *(_QWORD *)(v2 + 388) = 0xBFFC6A773F800000;
  *((_QWORD *)this + 669) = v2;
  *(_QWORD *)this = 0;
  webrtc::WebRtc_rdft((webrtc *)0x200, 1, v11, (int64x2_t *)this, (float *)this + 512, v4, v3);
  bzero(*((void **)this + 668), 0x318uLL);
  v5 = (_QWORD *)*((_QWORD *)this + 667);
  bzero(v5, 0xA10uLL);
  v5[322] = 0x4049000000000000;
  bzero(v5 + 323, 0x620uLL);
  v5[519] = 0x4049000000000000;
  bzero(v5 + 520, 0x818uLL);
  v6 = 0;
  v7 = v5 + 779;
  v8 = 0.5;
  do
  {
    v9 = sin((v8 * (v8 * 0.7) * 0.0000173611111 + v8 * 0.3 * 0.00416666667) * 3.14159265);
    *(long double *)&v7[v6] = v9 * v9;
    v8 = v8 + 1.0;
    ++v6;
  }
  while (v6 != 240);
  return this;
}

uint64_t webrtc::VadAudioProc::ExtractFeatures()
{
  uint64_t v0;
  const __int16 *v1;
  uint64_t v2;
  double v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  unint64_t v8;
  uint64_t v9;
  double v10;
  float32x4_t v11;
  float32x4_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  uint64_t v17;
  double v18;
  double v19;
  float32x4_t v20;
  float32x4_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  double v26;
  double v27;
  uint64_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  float64x2_t v34;
  double v35;
  double v36;
  double v37;
  double v38;
  long double v39;
  float64_t v40;
  float64x2_t v41;
  float64x2_t v42;
  int8x16_t v43;
  float32x2_t *v44;
  uint64_t v45;
  float32x4_t v46;
  float64x2_t v47;
  float64x2_t v48;
  float64x2_t v49;
  float64x2_t *v50;
  uint64_t v51;
  int8x16_t v52;
  double v53;
  int8x16_t v54;
  int8x16_t v55;
  int8x16_t v56;
  uint64_t v57;
  double v58;
  int8x16_t v59;
  double v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  uint64_t v64;
  double v65;
  int8x16_t v66;
  double v67;
  float64x2_t v68;
  int8x16_t v69;
  int8x16_t v70;
  int8x16_t v71;
  uint64_t v72;
  double v73;
  double v74;
  int8x16_t v75;
  double v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  uint64_t v80;
  double v81;
  int8x16_t v82;
  double v83;
  int8x16_t v84;
  int8x16_t v85;
  int8x16_t v86;
  uint64_t v87;
  double v88;
  double v89;
  int8x16_t v90;
  double v91;
  int8x16_t v92;
  int8x16_t v93;
  int8x16_t v94;
  uint64_t v95;
  double v96;
  double v97;
  int8x16_t v98;
  double v99;
  int8x16_t v100;
  int8x16_t v101;
  int8x16_t v102;
  uint64_t v103;
  double v104;
  double v105;
  int8x16_t v106;
  double v107;
  int8x16_t v108;
  int8x16_t v109;
  int8x16_t v110;
  uint64_t v111;
  double v112;
  int8x16_t v113;
  double v114;
  int8x16_t v115;
  int8x16_t v116;
  int8x16_t v117;
  uint64_t v118;
  double v119;
  double v120;
  int8x16_t v121;
  double v122;
  int8x16_t v123;
  int8x16_t v124;
  int8x16_t v125;
  uint64_t v126;
  double v127;
  double v128;
  int8x16_t v129;
  double v130;
  int8x16_t v131;
  int8x16_t v132;
  int8x16_t v133;
  uint64_t v134;
  double v135;
  double v136;
  int8x16_t v137;
  double v138;
  int8x16_t v139;
  int8x16_t v140;
  int8x16_t v141;
  uint64_t v142;
  double v143;
  int8x16_t v144;
  double v145;
  int8x16_t v146;
  int8x16_t v147;
  int8x16_t v148;
  uint64_t v149;
  double v150;
  double v151;
  int8x16_t v152;
  double v153;
  int8x16_t v154;
  int8x16_t v155;
  int8x16_t v156;
  uint64_t v157;
  double v158;
  double v159;
  int8x16_t v160;
  double v161;
  int8x16_t v162;
  int8x16_t v163;
  int8x16_t v164;
  uint64_t v165;
  float64x2_t v166;
  double v167;
  float64x2_t v168;
  double v169;
  int8x16_t v170;
  int8x16_t v171;
  int8x16_t v172;
  uint64_t v173;
  double v174;
  int8x16_t v175;
  double v176;
  int8x16_t v177;
  int8x16_t v178;
  int8x16_t v179;
  float64x2_t v180;
  double v181;
  double v182;
  double v183;
  float32x2_t *v184;
  uint64_t v185;
  float32x4_t v186;
  float64x2_t v187;
  float64x2_t v188;
  float64x2_t v189;
  float64x2_t *v190;
  uint64_t v191;
  int8x16_t v192;
  double v193;
  int8x16_t v194;
  int8x16_t v195;
  int8x16_t v196;
  uint64_t v197;
  double v198;
  int8x16_t v199;
  double v200;
  int8x16_t v201;
  int8x16_t v202;
  int8x16_t v203;
  uint64_t v204;
  double v205;
  int8x16_t v206;
  double v207;
  float64x2_t v208;
  int8x16_t v209;
  int8x16_t v210;
  int8x16_t v211;
  uint64_t v212;
  double v213;
  double v214;
  int8x16_t v215;
  double v216;
  int8x16_t v217;
  int8x16_t v218;
  int8x16_t v219;
  uint64_t v220;
  double v221;
  int8x16_t v222;
  double v223;
  int8x16_t v224;
  int8x16_t v225;
  int8x16_t v226;
  uint64_t v227;
  double v228;
  double v229;
  int8x16_t v230;
  double v231;
  int8x16_t v232;
  int8x16_t v233;
  int8x16_t v234;
  uint64_t v235;
  double v236;
  double v237;
  int8x16_t v238;
  double v239;
  int8x16_t v240;
  int8x16_t v241;
  int8x16_t v242;
  uint64_t v243;
  double v244;
  double v245;
  int8x16_t v246;
  double v247;
  int8x16_t v248;
  int8x16_t v249;
  int8x16_t v250;
  uint64_t v251;
  double v252;
  int8x16_t v253;
  double v254;
  int8x16_t v255;
  int8x16_t v256;
  int8x16_t v257;
  uint64_t v258;
  double v259;
  double v260;
  int8x16_t v261;
  double v262;
  int8x16_t v263;
  int8x16_t v264;
  int8x16_t v265;
  uint64_t v266;
  double v267;
  double v268;
  int8x16_t v269;
  double v270;
  int8x16_t v271;
  int8x16_t v272;
  int8x16_t v273;
  uint64_t v274;
  double v275;
  double v276;
  int8x16_t v277;
  double v278;
  int8x16_t v279;
  int8x16_t v280;
  int8x16_t v281;
  uint64_t v282;
  double v283;
  int8x16_t v284;
  double v285;
  int8x16_t v286;
  int8x16_t v287;
  int8x16_t v288;
  uint64_t v289;
  double v290;
  double v291;
  int8x16_t v292;
  int8x16_t v293;
  int8x16_t v294;
  int8x16_t v295;
  uint64_t v296;
  double v297;
  double v298;
  int8x16_t v299;
  double v300;
  int8x16_t v301;
  int8x16_t v302;
  int8x16_t v303;
  uint64_t v304;
  float64x2_t v305;
  double v306;
  float64x2_t v307;
  double v308;
  int8x16_t v309;
  int8x16_t v310;
  int8x16_t v311;
  uint64_t v312;
  double v313;
  int8x16_t v314;
  double v315;
  int8x16_t v316;
  int8x16_t v317;
  int8x16_t v318;
  double v319;
  double v320;
  uint64_t v321;
  uint64_t v322;
  float32x4_t v323;
  float32x4_t v324;
  float64x2_t v325;
  float64x2_t v326;
  float64x2_t v327;
  float64x2_t v328;
  float64x2_t *v329;
  uint64_t v330;
  int8x16_t v331;
  double v332;
  int8x16_t v333;
  int8x16_t v334;
  int8x16_t v335;
  uint64_t v336;
  double v337;
  int8x16_t v338;
  double v339;
  int8x16_t v340;
  int8x16_t v341;
  int8x16_t v342;
  uint64_t v343;
  double v344;
  int8x16_t v345;
  double v346;
  float64x2_t v347;
  int8x16_t v348;
  int8x16_t v349;
  int8x16_t v350;
  uint64_t v351;
  double v352;
  double v353;
  int8x16_t v354;
  double v355;
  int8x16_t v356;
  int8x16_t v357;
  int8x16_t v358;
  uint64_t v359;
  double v360;
  int8x16_t v361;
  double v362;
  int8x16_t v363;
  int8x16_t v364;
  int8x16_t v365;
  uint64_t v366;
  double v367;
  double v368;
  int8x16_t v369;
  double v370;
  int8x16_t v371;
  int8x16_t v372;
  int8x16_t v373;
  uint64_t v374;
  double v375;
  double v376;
  int8x16_t v377;
  double v378;
  int8x16_t v379;
  int8x16_t v380;
  int8x16_t v381;
  uint64_t v382;
  double v383;
  double v384;
  int8x16_t v385;
  double v386;
  int8x16_t v387;
  int8x16_t v388;
  int8x16_t v389;
  uint64_t v390;
  double v391;
  int8x16_t v392;
  double v393;
  int8x16_t v394;
  int8x16_t v395;
  int8x16_t v396;
  uint64_t v397;
  double v398;
  double v399;
  int8x16_t v400;
  double v401;
  int8x16_t v402;
  int8x16_t v403;
  int8x16_t v404;
  uint64_t v405;
  double v406;
  double v407;
  int8x16_t v408;
  double v409;
  int8x16_t v410;
  int8x16_t v411;
  int8x16_t v412;
  uint64_t v413;
  double v414;
  double v415;
  int8x16_t v416;
  double v417;
  int8x16_t v418;
  int8x16_t v419;
  int8x16_t v420;
  uint64_t v421;
  double v422;
  int8x16_t v423;
  double v424;
  int8x16_t v425;
  int8x16_t v426;
  int8x16_t v427;
  uint64_t v428;
  double v429;
  double v430;
  int8x16_t v431;
  double v432;
  int8x16_t v433;
  int8x16_t v434;
  int8x16_t v435;
  uint64_t v436;
  double v437;
  double v438;
  int8x16_t v439;
  double v440;
  int8x16_t v441;
  int8x16_t v442;
  int8x16_t v443;
  uint64_t v444;
  float64x2_t v445;
  double v446;
  float64x2_t v447;
  double v448;
  int8x16_t v449;
  int8x16_t v450;
  int8x16_t v451;
  uint64_t v452;
  double v453;
  int8x16_t v454;
  double v455;
  int8x16_t v456;
  int8x16_t v457;
  int8x16_t v458;
  float64x2_t v459;
  double v460;
  double v461;
  float32x4_t v462;
  unint64_t v463;
  float *v464;
  float v465;
  float v466;
  float *v467;
  float v468;
  float v469;
  float v470;
  double v471;
  uint64_t v472;
  unint64_t v473;
  uint64_t v474;
  BOOL v475;
  uint64_t v476;
  double v477;
  double *v478;
  uint64_t v479;
  double v480;
  unint64_t v481;
  double v482;
  double v483;
  double v484;
  double *v485;
  double v486;
  double v487;
  double v488;
  double v489;
  double *v490;
  double v491;
  double v492;
  double v493;
  double v494;
  double *v495;
  double v496;
  double v497;
  double v498;
  double v499;
  double *v500;
  double v501;
  double v502;
  double v503;
  uint64_t v504;
  unint64_t v505;
  uint64_t v506;
  uint64_t v507;
  double v508;
  double *v509;
  uint64_t v510;
  double v511;
  unint64_t v512;
  double v513;
  double v514;
  double v515;
  double *v516;
  double v517;
  double v518;
  double v519;
  double v520;
  double *v521;
  double v522;
  double v523;
  double v524;
  double v525;
  double *v526;
  double v527;
  double v528;
  double v529;
  double v530;
  double *v531;
  double v532;
  double v533;
  double v534;
  uint64_t v535;
  unint64_t v536;
  uint64_t v537;
  uint64_t v538;
  double v539;
  double *v540;
  uint64_t v541;
  double v542;
  unint64_t v543;
  double v544;
  double v545;
  float64_t v546;
  double *v547;
  double v548;
  float64_t v549;
  double v550;
  float64_t v551;
  double *v552;
  double v553;
  float64_t v554;
  double v555;
  float64_t v556;
  double *v557;
  double v558;
  float64_t v559;
  double v560;
  float64_t v561;
  double *v562;
  double v563;
  float64_t v564;
  float32x4_t v565;
  unint64_t v566;
  float *v567;
  float v568;
  float v569;
  float *v570;
  float v571;
  float v572;
  float v573;
  float32x4_t v574;
  unint64_t v575;
  float *v576;
  float v577;
  float v578;
  float *v579;
  float v580;
  float v581;
  float v582;
  double v583;
  double v584;
  double v585;
  double v586;
  float32x4_t v587;
  float32x4_t v588;
  float32x4_t v589;
  float32x4_t v590;
  double v591;
  double v592;
  double v593;
  double v594;
  double v595;
  double v596;
  double v597;
  double v598;
  double v599[205];
  double v600;
  double v601;
  double v602;
  double v603;
  double v604;
  double v605;
  double v606;
  double v607;
  double v608;
  double v609;
  double v610;
  double v611;
  double v612;
  double v613;
  double v614;
  double v615;
  double v616;
  double v617;
  double v618;
  double v619;
  double v620;
  double v621;
  double v622;
  double v623;
  double v624;
  double v625;
  double v626;
  double v627;
  double v628;
  float64x2_t v629;
  double v630;
  _BYTE v631[136];
  _BYTE v632[136];
  float64x2_t v633[223];
  double v634;
  float64x2_t v635;
  float64_t v636;
  double v637;
  double v638;
  double v639;
  double v640;
  uint64_t v641;

  v0 = MEMORY[0x24BDAC7A8]();
  v641 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(v2 + 128) = 0;
  if (v4 != 160)
    return 0xFFFFFFFFLL;
  v5 = v2;
  v6 = v0;
  if (webrtc::PoleZeroFilter::Filter(*(webrtc::PoleZeroFilter **)(v0 + 5352), v1, 0xA0uLL, (float *)(v6 + 4 * *(_QWORD *)(v6 + 5312) + 3072), v3))return 0xFFFFFFFFLL;
  v8 = *(_QWORD *)(v6 + 5312) + 160;
  *(_QWORD *)(v6 + 5312) = v8;
  if (v8 < 0x230)
    return 0;
  v9 = 0;
  *(_QWORD *)(v5 + 128) = 3;
  *(_BYTE *)(v5 + 136) = 0;
  v10 = 0.0;
  do
  {
    v11 = vmulq_f32(*(float32x4_t *)(v6 + v9 + 3392), *(float32x4_t *)(v6 + v9 + 3392));
    v12 = vmulq_f32(*(float32x4_t *)(v6 + v9 + 3408), *(float32x4_t *)(v6 + v9 + 3408));
    v13 = vcvt_hight_f64_f32(v11);
    v14 = vcvtq_f64_f32(*(float32x2_t *)v11.f32);
    v15 = vcvt_hight_f64_f32(v12);
    v16 = vcvtq_f64_f32(*(float32x2_t *)v12.f32);
    v10 = v10 + v14.f64[0] + v14.f64[1] + v13.f64[0] + v13.f64[1] + v16.f64[0] + v16.f64[1] + v15.f64[0] + v15.f64[1];
    v9 += 32;
  }
  while (v9 != 640);
  v17 = 0;
  v18 = sqrt(v10 / 160.0);
  *(double *)(v5 + 96) = v18;
  v19 = 0.0;
  do
  {
    v20 = vmulq_f32(*(float32x4_t *)(v6 + v17 + 4032), *(float32x4_t *)(v6 + v17 + 4032));
    v21 = vmulq_f32(*(float32x4_t *)(v6 + v17 + 4048), *(float32x4_t *)(v6 + v17 + 4048));
    v22 = vcvt_hight_f64_f32(v20);
    v23 = vcvtq_f64_f32(*(float32x2_t *)v20.f32);
    v24 = vcvt_hight_f64_f32(v21);
    v25 = vcvtq_f64_f32(*(float32x2_t *)v21.f32);
    v19 = v19 + v23.f64[0] + v23.f64[1] + v22.f64[0] + v22.f64[1] + v25.f64[0] + v25.f64[1] + v24.f64[0] + v24.f64[1];
    v17 += 32;
  }
  while (v17 != 640);
  v26 = sqrt(v19 / 160.0);
  *(double *)(v5 + 104) = v26;
  v27 = 0.0;
  v28 = -640;
  do
  {
    v29 = vmulq_f32(*(float32x4_t *)(v6 + v28 + 5312), *(float32x4_t *)(v6 + v28 + 5312));
    v30 = vmulq_f32(*(float32x4_t *)(v6 + v28 + 5328), *(float32x4_t *)(v6 + v28 + 5328));
    v31 = vcvt_hight_f64_f32(v29);
    v32 = vcvtq_f64_f32(*(float32x2_t *)v29.f32);
    v33 = vcvt_hight_f64_f32(v30);
    v34 = vcvtq_f64_f32(*(float32x2_t *)v30.f32);
    v27 = v27 + v32.f64[0] + v32.f64[1] + v31.f64[0] + v31.f64[1] + v34.f64[0] + v34.f64[1] + v33.f64[0] + v33.f64[1];
    v28 += 32;
  }
  while (v28);
  v35 = sqrt(v27 / 160.0);
  *(double *)(v5 + 112) = v35;
  if (v18 < 5.0 || v26 < 5.0 || v35 < 5.0)
  {
    *(_BYTE *)(v5 + 136) = 1;
  }
  else
  {
    WebRtcIsac_SplitAndFilterFloat();
    WebRtcIsac_PitchAnalysis();
    v36 = log(v637 + 1.0e-12);
    v37 = log(v638 + 1.0e-12);
    v38 = log(v639 + 1.0e-12);
    v39 = log(v640 + 1.0e-12);
    *(double *)v5 = v36 * 0.833333333 + *(double *)(v6 + 5320) * 0.166666667;
    *(double *)(v5 + 8) = v38 * 0.166666667 + v37 * 0.833333333;
    *(long double *)(v5 + 16) = v39 * 0.5 + v38 * 0.5;
    *(long double *)(v6 + 5320) = v39;
    v40 = v636;
    v41 = v635;
    v42.f64[1] = v635.f64[1];
    v42.f64[0] = v636;
    *(double *)(v5 + 32) = v634 * 0.833333333 + *(double *)(v6 + 5328) * 0.166666667;
    v43 = (int8x16_t)vmulq_f64(v42, (float64x2_t)xmmword_208F1CAB0);
    *(float64x2_t *)(v5 + 40) = vmlaq_f64((float64x2_t)vextq_s8(v43, v43, 8uLL), (float64x2_t)xmmword_208F1CAC0, v41);
    *(float64_t *)(v6 + 5328) = v40;
    *(float64x2_t *)(v5 + 32) = vdivq_f64((float64x2_t)vdupq_n_s64(0x40BF400000000000uLL), *(float64x2_t *)(v5 + 32));
    *(double *)(v5 + 48) = 8000.0 / *(double *)(v5 + 48);
    v44 = (float32x2_t *)(v6 + 3088);
    v45 = 0x20u;
    do
    {
      v46 = *(float32x4_t *)v44[-2].f32;
      v47 = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v45 - 16), vcvt_hight_f64_f32(v46));
      v48 = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v45), vcvtq_f64_f32(*v44));
      v49 = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v45 + 16), vcvt_hight_f64_f32(*(float32x4_t *)v44->f32));
      v50 = (float64x2_t *)((char *)&v587 + v45);
      v50[-2] = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v45 - 32), vcvtq_f64_f32(*(float32x2_t *)v46.f32));
      v50[-1] = v47;
      *v50 = v48;
      v50[1] = v49;
      v44 += 4;
      v45 += 64;
    }
    while (v45 != 1952);
    v51 = 0;
    v52 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v587.i64), 0);
    v53 = 0.0;
    do
    {
      v54 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v51 + 8), *(float64x2_t *)((char *)&v587 + v51 + 8));
      v55 = vextq_s8(v52, v54, 8uLL);
      v52 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v51 + 8), *(float64x2_t *)((char *)&v588 + v51 + 8));
      v56 = vextq_s8(v54, v52, 8uLL);
      v53 = v53 + *(double *)v55.i64 + *(double *)&v55.i64[1] + *(double *)v56.i64 + *(double *)&v56.i64[1];
      v51 += 32;
    }
    while (v51 != 1888);
    v57 = 0;
    v58 = v613 * v613 + v612 * v612 + *(double *)&v52.i64[1] + v53;
    v59 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v587.i64[1]), 0);
    v60 = 0.0;
    do
    {
      v61 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v57 + 8), *(float64x2_t *)((char *)&v587 + v57 + 16));
      v62 = vextq_s8(v59, v61, 8uLL);
      v59 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v57 + 8), *(float64x2_t *)((char *)&v589 + v57));
      v63 = vextq_s8(v61, v59, 8uLL);
      v60 = v60 + *(double *)v62.i64 + *(double *)&v62.i64[1] + *(double *)v63.i64 + *(double *)&v63.i64[1];
      v57 += 32;
    }
    while (v57 != 1888);
    v64 = 0;
    v65 = v612 * v613 + *(double *)&v59.i64[1] + v60;
    v66 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v588.i64), 0);
    v67 = 0.0;
    do
    {
      v68 = *(float64x2_t *)((char *)&v588 + v64 + 8);
      v69 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v64 + 8), v68);
      v70 = vextq_s8(v66, v69, 8uLL);
      v66 = (int8x16_t)vmulq_f64(v68, *(float64x2_t *)((char *)&v589 + v64 + 8));
      v71 = vextq_s8(v69, v66, 8uLL);
      v67 = v67 + *(double *)v70.i64 + *(double *)&v70.i64[1] + *(double *)v71.i64 + *(double *)&v71.i64[1];
      v64 += 32;
    }
    while (v64 != 1888);
    v72 = 0;
    v73 = *(double *)&v66.i64[1] + v67;
    v74 = v58 + v614 * v614;
    v75 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v588.i64[1]), 0);
    v76 = 0.0;
    do
    {
      v77 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v72 + 8), *(float64x2_t *)((char *)&v589 + v72));
      v78 = vextq_s8(v75, v77, 8uLL);
      v75 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v72 + 8), *(float64x2_t *)((char *)&v590 + v72));
      v79 = vextq_s8(v77, v75, 8uLL);
      v76 = v76 + *(double *)v78.i64 + *(double *)&v78.i64[1] + *(double *)v79.i64 + *(double *)&v79.i64[1];
      v72 += 32;
    }
    while (v72 != 1888);
    v80 = 0;
    v81 = v65 + v613 * v614;
    v82 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v589.i64), 0);
    v83 = 0.0;
    do
    {
      v84 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v80 + 8), *(float64x2_t *)((char *)&v589 + v80 + 8));
      v85 = vextq_s8(v82, v84, 8uLL);
      v82 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v80 + 8), *(float64x2_t *)((char *)&v590 + v80 + 8));
      v86 = vextq_s8(v84, v82, 8uLL);
      v83 = v83 + *(double *)v85.i64 + *(double *)&v85.i64[1] + *(double *)v86.i64 + *(double *)&v86.i64[1];
      v80 += 32;
    }
    while (v80 != 1856);
    v87 = 0;
    v88 = v610 * v613 + v609 * v612 + *(double *)&v82.i64[1] + v83;
    v89 = v73 + v612 * v614;
    v90 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v589.i64[1]), 0);
    v91 = 0.0;
    do
    {
      v92 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v87 + 8), *(float64x2_t *)((char *)&v590 + v87));
      v93 = vextq_s8(v90, v92, 8uLL);
      v90 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v87 + 8), *(float64x2_t *)((char *)&v591 + v87));
      v94 = vextq_s8(v92, v90, 8uLL);
      v91 = v91 + *(double *)v93.i64 + *(double *)&v93.i64[1] + *(double *)v94.i64 + *(double *)&v94.i64[1];
      v87 += 32;
    }
    while (v87 != 1856);
    v95 = 0;
    v96 = v609 * v613 + *(double *)&v90.i64[1] + v91;
    v97 = v76 + *(double *)&v75.i64[1];
    v98 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v590.i64), 0);
    v99 = 0.0;
    do
    {
      v100 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v95 + 8), *(float64x2_t *)((char *)&v590 + v95 + 8));
      v101 = vextq_s8(v98, v100, 8uLL);
      v98 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v95 + 8), *(float64x2_t *)((char *)&v592 + v95));
      v102 = vextq_s8(v100, v98, 8uLL);
      v99 = v99 + *(double *)v101.i64 + *(double *)&v101.i64[1] + *(double *)v102.i64 + *(double *)&v102.i64[1];
      v95 += 32;
    }
    while (v95 != 1856);
    v103 = 0;
    v104 = *(double *)&v98.i64[1] + v99;
    v105 = v88 + v611 * v614;
    v106 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v590.i64[1]), 0);
    v107 = 0.0;
    do
    {
      v108 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v103 + 8), *(float64x2_t *)((char *)&v591 + v103));
      v109 = vextq_s8(v106, v108, 8uLL);
      v106 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v103 + 8), *(float64x2_t *)((char *)&v593 + v103));
      v110 = vextq_s8(v108, v106, 8uLL);
      v107 = v107 + *(double *)v109.i64 + *(double *)&v109.i64[1] + *(double *)v110.i64 + *(double *)&v110.i64[1];
      v103 += 32;
    }
    while (v103 != 1856);
    v111 = 0;
    v112 = v96 + v610 * v614;
    v113 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v591), 0);
    v114 = 0.0;
    do
    {
      v115 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v111 + 8), *(float64x2_t *)((char *)&v592 + v111));
      v116 = vextq_s8(v113, v115, 8uLL);
      v113 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v111 + 8), *(float64x2_t *)((char *)&v594 + v111));
      v117 = vextq_s8(v115, v113, 8uLL);
      v114 = v114 + *(double *)v116.i64 + *(double *)&v116.i64[1] + *(double *)v117.i64 + *(double *)&v117.i64[1];
      v111 += 32;
    }
    while (v111 != 1824);
    v118 = 0;
    v119 = v607 * v613 + v606 * v612 + *(double *)&v113.i64[1] + v114;
    v120 = v104 + v609 * v614;
    v121 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v592), 0);
    v122 = 0.0;
    do
    {
      v123 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v118 + 8), *(float64x2_t *)((char *)&v593 + v118));
      v124 = vextq_s8(v121, v123, 8uLL);
      v121 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v118 + 8), *(float64x2_t *)((char *)&v595 + v118));
      v125 = vextq_s8(v123, v121, 8uLL);
      v122 = v122 + *(double *)v124.i64 + *(double *)&v124.i64[1] + *(double *)v125.i64 + *(double *)&v125.i64[1];
      v118 += 32;
    }
    while (v118 != 1824);
    v126 = 0;
    v127 = v606 * v613 + *(double *)&v121.i64[1] + v122;
    v128 = v107 + *(double *)&v106.i64[1];
    v129 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v593), 0);
    v130 = 0.0;
    do
    {
      v131 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v126 + 8), *(float64x2_t *)((char *)&v594 + v126));
      v132 = vextq_s8(v129, v131, 8uLL);
      v129 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v126 + 8), *(float64x2_t *)((char *)&v596 + v126));
      v133 = vextq_s8(v131, v129, 8uLL);
      v130 = v130 + *(double *)v132.i64 + *(double *)&v132.i64[1] + *(double *)v133.i64 + *(double *)&v133.i64[1];
      v126 += 32;
    }
    while (v126 != 1824);
    v134 = 0;
    v135 = *(double *)&v129.i64[1] + v130;
    v136 = v119 + v608 * v614;
    v137 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v594), 0);
    v138 = 0.0;
    do
    {
      v139 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v134 + 8), *(float64x2_t *)((char *)&v595 + v134));
      v140 = vextq_s8(v137, v139, 8uLL);
      v137 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v134 + 8), *(float64x2_t *)((char *)&v597 + v134));
      v141 = vextq_s8(v139, v137, 8uLL);
      v138 = v138 + *(double *)v140.i64 + *(double *)&v140.i64[1] + *(double *)v141.i64 + *(double *)&v141.i64[1];
      v134 += 32;
    }
    while (v134 != 1824);
    v142 = 0;
    v143 = v127 + v607 * v614;
    v144 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v595), 0);
    v145 = 0.0;
    do
    {
      v146 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v142 * 8 + 8), *(float64x2_t *)((char *)&v596 + v142 * 8));
      v147 = vextq_s8(v144, v146, 8uLL);
      v144 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v142 * 8 + 8), *(float64x2_t *)&v599[v142 - 1]);
      v148 = vextq_s8(v146, v144, 8uLL);
      v145 = v145 + *(double *)v147.i64 + *(double *)&v147.i64[1] + *(double *)v148.i64 + *(double *)&v148.i64[1];
      v142 += 4;
    }
    while (v142 != 224);
    v149 = 0;
    v150 = v604 * v613 + v603 * v612 + *(double *)&v144.i64[1] + v145;
    v151 = v135 + v606 * v614;
    v152 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v596), 0);
    v153 = 0.0;
    do
    {
      v154 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v149 * 8 + 8), *(float64x2_t *)((char *)&v597 + v149 * 8));
      v155 = vextq_s8(v152, v154, 8uLL);
      v152 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v149 * 8 + 8), *(float64x2_t *)&v599[v149]);
      v156 = vextq_s8(v154, v152, 8uLL);
      v153 = v153 + *(double *)v155.i64 + *(double *)&v155.i64[1] + *(double *)v156.i64 + *(double *)&v156.i64[1];
      v149 += 4;
    }
    while (v149 != 224);
    v157 = 0;
    v158 = v603 * v613 + *(double *)&v152.i64[1] + v153;
    v159 = v138 + *(double *)&v137.i64[1];
    v160 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v597), 0);
    v161 = 0.0;
    do
    {
      v162 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v157 * 8 + 8), *(float64x2_t *)&v599[v157 - 1]);
      v163 = vextq_s8(v160, v162, 8uLL);
      v160 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v157 * 8 + 8), *(float64x2_t *)&v599[v157 + 1]);
      v164 = vextq_s8(v162, v160, 8uLL);
      v161 = v161 + *(double *)v163.i64 + *(double *)&v163.i64[1] + *(double *)v164.i64 + *(double *)&v164.i64[1];
      v157 += 4;
    }
    while (v157 != 224);
    v165 = 0;
    v166.f64[0] = *(double *)&v160.i64[1] + v161;
    v167 = v150 + v605 * v614;
    v168 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v598), 0);
    v169 = 0.0;
    do
    {
      v170 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v165 * 8 + 8), *(float64x2_t *)&v599[v165]);
      v171 = vextq_s8((int8x16_t)v168, v170, 8uLL);
      v168 = vmulq_f64(*(float64x2_t *)((char *)&v588 + v165 * 8 + 8), *(float64x2_t *)&v599[v165 + 2]);
      v172 = vextq_s8(v170, (int8x16_t)v168, 8uLL);
      v169 = v169 + *(double *)v171.i64 + *(double *)&v171.i64[1] + *(double *)v172.i64 + *(double *)&v172.i64[1];
      v165 += 4;
    }
    while (v165 != 224);
    v173 = 0;
    v174 = v158 + v604 * v614;
    v175 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v599[0]), 0);
    v176 = 0.0;
    do
    {
      v177 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v173 * 8 + 8), *(float64x2_t *)&v599[v173 + 1]);
      v178 = vextq_s8(v175, v177, 8uLL);
      v175 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v173 * 8 + 8), *(float64x2_t *)&v599[v173 + 3]);
      v179 = vextq_s8(v177, v175, 8uLL);
      v176 = v176 + *(double *)v178.i64 + *(double *)&v178.i64[1] + *(double *)v179.i64 + *(double *)&v179.i64[1];
      v173 += 4;
    }
    while (v173 != 220);
    v166.f64[1] = v169;
    v168.f64[0] = v603 * v614;
    v180 = vaddq_f64(v166, v168);
    v181 = v601 * v613 + v600 * v612 + *(double *)&v175.i64[1] + v176 + v602 * v614;
    v182 = v74 * 1.0001;
    v183 = v81 * 0.985;
    v615 = v182;
    v616 = v81 * 0.985;
    v586 = 0.970225;
    v585 = 0.955672;
    v617 = v89 * 0.970225;
    v618 = v97 * 0.955672;
    v584 = 0.941337;
    v583 = 0.927217;
    v619 = v105 * 0.941337;
    v620 = v112 * 0.927217;
    v621 = v120 * 0.913308;
    v622 = v128 * 0.899609;
    v623 = v136 * 0.886115;
    v624 = v143 * 0.872823;
    v625 = v151 * 0.85973;
    v626 = v159 * 0.846834;
    v627 = v167 * 0.834132;
    v628 = v174 * 0.82162;
    v629 = vmulq_f64(v180, (float64x2_t)xmmword_208F1CAD0);
    v630 = v181 * 0.785199;
    *(_QWORD *)v631 = 0x3FF0000000000000;
    if (v182 >= 1.0e-10)
    {
      *(double *)&v631[8] = -v183 / v182;
      v471 = v182 + v183 * *(double *)&v631[8];
      v472 = 1;
      v473 = 2;
      v474 = 8;
      do
      {
        v476 = v472++;
        v477 = *(&v615 + v472);
        v478 = (double *)&v631[8];
        v479 = v474;
        do
        {
          v480 = *v478++;
          v477 = v477 + v480 * *(double *)((char *)&v615 + v479);
          v479 -= 8;
        }
        while (v479);
        v481 = v473 >> 1;
        v482 = -v477 / v471;
        v483 = *(double *)&v631[8 * v476];
        v484 = *(double *)&v631[8] + v482 * v483;
        *(double *)&v631[8 * v476] = v483 + v482 * *(double *)&v631[8];
        *(double *)&v631[8] = v484;
        if (v473 >> 1 != 1)
        {
          v485 = (double *)&v631[8 * v476];
          v486 = *(v485 - 1);
          v487 = *(double *)&v631[16] + v482 * v486;
          *(v485 - 1) = v486 + v482 * *(double *)&v631[16];
          *(double *)&v631[16] = v487;
          if (v481 != 2)
          {
            v488 = *(v485 - 2);
            v489 = *(double *)&v631[24] + v482 * v488;
            *(v485 - 2) = v488 + v482 * *(double *)&v631[24];
            *(double *)&v631[24] = v489;
            if (v481 != 3)
            {
              v490 = (double *)&v631[8 * v476];
              v491 = *(v490 - 3);
              v492 = *(double *)&v631[32] + v482 * v491;
              *(v490 - 3) = v491 + v482 * *(double *)&v631[32];
              *(double *)&v631[32] = v492;
              if (v481 != 4)
              {
                v493 = *(v490 - 4);
                v494 = *(double *)&v631[40] + v482 * v493;
                *(v490 - 4) = v493 + v482 * *(double *)&v631[40];
                *(double *)&v631[40] = v494;
                if (v481 != 5)
                {
                  v495 = (double *)&v631[8 * v476];
                  v496 = *(v495 - 5);
                  v497 = *(double *)&v631[48] + v482 * v496;
                  *(v495 - 5) = v496 + v482 * *(double *)&v631[48];
                  *(double *)&v631[48] = v497;
                  if (v481 != 6)
                  {
                    v498 = *(v495 - 6);
                    v499 = *(double *)&v631[56] + v482 * v498;
                    *(v495 - 6) = v498 + v482 * *(double *)&v631[56];
                    *(double *)&v631[56] = v499;
                    if (v481 != 7)
                    {
                      v500 = (double *)&v631[8 * v476];
                      v501 = *(v500 - 7);
                      v502 = *(double *)&v631[64] + v482 * v501;
                      *(v500 - 7) = v501 + v482 * *(double *)&v631[64];
                      *(double *)&v631[64] = v502;
                    }
                  }
                }
              }
            }
          }
        }
        v471 = v471 + v482 * v477;
        *(double *)&v631[8 * v472] = v482;
        v474 += 8;
        v475 = v473++ == 16;
      }
      while (!v475);
    }
    else
    {
      memset(&v631[8], 0, 128);
    }
    v184 = (float32x2_t *)(v6 + 3728);
    v185 = 0x20u;
    do
    {
      v186 = *(float32x4_t *)v184[-2].f32;
      v187 = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v185 - 16), vcvt_hight_f64_f32(v186));
      v188 = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v185), vcvtq_f64_f32(*v184));
      v189 = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v185 + 16), vcvt_hight_f64_f32(*(float32x4_t *)v184->f32));
      v190 = (float64x2_t *)((char *)&v587 + v185);
      v190[-2] = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v185 - 32), vcvtq_f64_f32(*(float32x2_t *)v186.f32));
      v190[-1] = v187;
      *v190 = v188;
      v190[1] = v189;
      v185 += 64;
      v184 += 4;
    }
    while (v185 != 1952);
    v191 = 0;
    v192 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v587.i64), 0);
    v193 = 0.0;
    do
    {
      v194 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v191 + 8), *(float64x2_t *)((char *)&v587 + v191 + 8));
      v195 = vextq_s8(v192, v194, 8uLL);
      v192 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v191 + 8), *(float64x2_t *)((char *)&v588 + v191 + 8));
      v196 = vextq_s8(v194, v192, 8uLL);
      v193 = v193 + *(double *)v195.i64 + *(double *)&v195.i64[1] + *(double *)v196.i64 + *(double *)&v196.i64[1];
      v191 += 32;
    }
    while (v191 != 1888);
    v197 = 0;
    v198 = v613 * v613 + v612 * v612 + *(double *)&v192.i64[1] + v193;
    v199 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v587.i64[1]), 0);
    v200 = 0.0;
    do
    {
      v201 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v197 + 8), *(float64x2_t *)((char *)&v587 + v197 + 16));
      v202 = vextq_s8(v199, v201, 8uLL);
      v199 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v197 + 8), *(float64x2_t *)((char *)&v589 + v197));
      v203 = vextq_s8(v201, v199, 8uLL);
      v200 = v200 + *(double *)v202.i64 + *(double *)&v202.i64[1] + *(double *)v203.i64 + *(double *)&v203.i64[1];
      v197 += 32;
    }
    while (v197 != 1888);
    v204 = 0;
    v205 = v612 * v613 + *(double *)&v199.i64[1] + v200;
    v206 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v588.i64), 0);
    v207 = 0.0;
    do
    {
      v208 = *(float64x2_t *)((char *)&v588 + v204 + 8);
      v209 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v204 + 8), v208);
      v210 = vextq_s8(v206, v209, 8uLL);
      v206 = (int8x16_t)vmulq_f64(v208, *(float64x2_t *)((char *)&v589 + v204 + 8));
      v211 = vextq_s8(v209, v206, 8uLL);
      v207 = v207 + *(double *)v210.i64 + *(double *)&v210.i64[1] + *(double *)v211.i64 + *(double *)&v211.i64[1];
      v204 += 32;
    }
    while (v204 != 1888);
    v212 = 0;
    v213 = *(double *)&v206.i64[1] + v207;
    v214 = v198 + v614 * v614;
    v215 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v588.i64[1]), 0);
    v216 = 0.0;
    do
    {
      v217 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v212 + 8), *(float64x2_t *)((char *)&v589 + v212));
      v218 = vextq_s8(v215, v217, 8uLL);
      v215 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v212 + 8), *(float64x2_t *)((char *)&v590 + v212));
      v219 = vextq_s8(v217, v215, 8uLL);
      v216 = v216 + *(double *)v218.i64 + *(double *)&v218.i64[1] + *(double *)v219.i64 + *(double *)&v219.i64[1];
      v212 += 32;
    }
    while (v212 != 1888);
    v220 = 0;
    v221 = v205 + v613 * v614;
    v222 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v589.i64), 0);
    v223 = 0.0;
    do
    {
      v224 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v220 + 8), *(float64x2_t *)((char *)&v589 + v220 + 8));
      v225 = vextq_s8(v222, v224, 8uLL);
      v222 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v220 + 8), *(float64x2_t *)((char *)&v590 + v220 + 8));
      v226 = vextq_s8(v224, v222, 8uLL);
      v223 = v223 + *(double *)v225.i64 + *(double *)&v225.i64[1] + *(double *)v226.i64 + *(double *)&v226.i64[1];
      v220 += 32;
    }
    while (v220 != 1856);
    v227 = 0;
    v228 = v610 * v613 + v609 * v612 + *(double *)&v222.i64[1] + v223;
    v229 = v213 + v612 * v614;
    v230 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v589.i64[1]), 0);
    v231 = 0.0;
    do
    {
      v232 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v227 + 8), *(float64x2_t *)((char *)&v590 + v227));
      v233 = vextq_s8(v230, v232, 8uLL);
      v230 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v227 + 8), *(float64x2_t *)((char *)&v591 + v227));
      v234 = vextq_s8(v232, v230, 8uLL);
      v231 = v231 + *(double *)v233.i64 + *(double *)&v233.i64[1] + *(double *)v234.i64 + *(double *)&v234.i64[1];
      v227 += 32;
    }
    while (v227 != 1856);
    v235 = 0;
    v236 = v609 * v613 + *(double *)&v230.i64[1] + v231;
    v237 = v216 + *(double *)&v215.i64[1];
    v238 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v590.i64), 0);
    v239 = 0.0;
    do
    {
      v240 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v235 + 8), *(float64x2_t *)((char *)&v590 + v235 + 8));
      v241 = vextq_s8(v238, v240, 8uLL);
      v238 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v235 + 8), *(float64x2_t *)((char *)&v592 + v235));
      v242 = vextq_s8(v240, v238, 8uLL);
      v239 = v239 + *(double *)v241.i64 + *(double *)&v241.i64[1] + *(double *)v242.i64 + *(double *)&v242.i64[1];
      v235 += 32;
    }
    while (v235 != 1856);
    v243 = 0;
    v244 = *(double *)&v238.i64[1] + v239;
    v245 = v228 + v611 * v614;
    v246 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v590.i64[1]), 0);
    v247 = 0.0;
    do
    {
      v248 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v243 + 8), *(float64x2_t *)((char *)&v591 + v243));
      v249 = vextq_s8(v246, v248, 8uLL);
      v246 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v243 + 8), *(float64x2_t *)((char *)&v593 + v243));
      v250 = vextq_s8(v248, v246, 8uLL);
      v247 = v247 + *(double *)v249.i64 + *(double *)&v249.i64[1] + *(double *)v250.i64 + *(double *)&v250.i64[1];
      v243 += 32;
    }
    while (v243 != 1856);
    v251 = 0;
    v252 = v236 + v610 * v614;
    v253 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v591), 0);
    v254 = 0.0;
    do
    {
      v255 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v251 + 8), *(float64x2_t *)((char *)&v592 + v251));
      v256 = vextq_s8(v253, v255, 8uLL);
      v253 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v251 + 8), *(float64x2_t *)((char *)&v594 + v251));
      v257 = vextq_s8(v255, v253, 8uLL);
      v254 = v254 + *(double *)v256.i64 + *(double *)&v256.i64[1] + *(double *)v257.i64 + *(double *)&v257.i64[1];
      v251 += 32;
    }
    while (v251 != 1824);
    v258 = 0;
    v259 = v607 * v613 + v606 * v612 + *(double *)&v253.i64[1] + v254;
    v260 = v244 + v609 * v614;
    v261 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v592), 0);
    v262 = 0.0;
    do
    {
      v263 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v258 + 8), *(float64x2_t *)((char *)&v593 + v258));
      v264 = vextq_s8(v261, v263, 8uLL);
      v261 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v258 + 8), *(float64x2_t *)((char *)&v595 + v258));
      v265 = vextq_s8(v263, v261, 8uLL);
      v262 = v262 + *(double *)v264.i64 + *(double *)&v264.i64[1] + *(double *)v265.i64 + *(double *)&v265.i64[1];
      v258 += 32;
    }
    while (v258 != 1824);
    v266 = 0;
    v267 = v606 * v613 + *(double *)&v261.i64[1] + v262;
    v268 = v247 + *(double *)&v246.i64[1];
    v269 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v593), 0);
    v270 = 0.0;
    do
    {
      v271 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v266 + 8), *(float64x2_t *)((char *)&v594 + v266));
      v272 = vextq_s8(v269, v271, 8uLL);
      v269 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v266 + 8), *(float64x2_t *)((char *)&v596 + v266));
      v273 = vextq_s8(v271, v269, 8uLL);
      v270 = v270 + *(double *)v272.i64 + *(double *)&v272.i64[1] + *(double *)v273.i64 + *(double *)&v273.i64[1];
      v266 += 32;
    }
    while (v266 != 1824);
    v274 = 0;
    v275 = *(double *)&v269.i64[1] + v270;
    v276 = v259 + v608 * v614;
    v277 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v594), 0);
    v278 = 0.0;
    do
    {
      v279 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v274 + 8), *(float64x2_t *)((char *)&v595 + v274));
      v280 = vextq_s8(v277, v279, 8uLL);
      v277 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v274 + 8), *(float64x2_t *)((char *)&v597 + v274));
      v281 = vextq_s8(v279, v277, 8uLL);
      v278 = v278 + *(double *)v280.i64 + *(double *)&v280.i64[1] + *(double *)v281.i64 + *(double *)&v281.i64[1];
      v274 += 32;
    }
    while (v274 != 1824);
    v282 = 0;
    v283 = v267 + v607 * v614;
    v284 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v595), 0);
    v285 = 0.0;
    do
    {
      v286 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v282 * 8 + 8), *(float64x2_t *)((char *)&v596 + v282 * 8));
      v287 = vextq_s8(v284, v286, 8uLL);
      v284 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v282 * 8 + 8), *(float64x2_t *)&v599[v282 - 1]);
      v288 = vextq_s8(v286, v284, 8uLL);
      v285 = v285 + *(double *)v287.i64 + *(double *)&v287.i64[1] + *(double *)v288.i64 + *(double *)&v288.i64[1];
      v282 += 4;
    }
    while (v282 != 224);
    v289 = 0;
    v290 = v604 * v613 + v603 * v612 + *(double *)&v284.i64[1] + v285;
    v291 = v275 + v606 * v614;
    v292 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v596), 0);
    v277.i64[0] = 0;
    do
    {
      v293 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v289 * 8 + 8), *(float64x2_t *)((char *)&v597 + v289 * 8));
      v294 = vextq_s8(v292, v293, 8uLL);
      v292 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v289 * 8 + 8), *(float64x2_t *)&v599[v289]);
      v295 = vextq_s8(v293, v292, 8uLL);
      *(double *)v277.i64 = *(double *)v277.i64
                          + *(double *)v294.i64
                          + *(double *)&v294.i64[1]
                          + *(double *)v295.i64
                          + *(double *)&v295.i64[1];
      v289 += 4;
    }
    while (v289 != 224);
    v296 = 0;
    v297 = v603 * v613 + *(double *)&v292.i64[1] + *(double *)v277.i64;
    v298 = v278 + *(double *)&v277.i64[1];
    v299 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v597), 0);
    v300 = 0.0;
    do
    {
      v301 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v296 * 8 + 8), *(float64x2_t *)&v599[v296 - 1]);
      v302 = vextq_s8(v299, v301, 8uLL);
      v299 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v296 * 8 + 8), *(float64x2_t *)&v599[v296 + 1]);
      v303 = vextq_s8(v301, v299, 8uLL);
      v300 = v300 + *(double *)v302.i64 + *(double *)&v302.i64[1] + *(double *)v303.i64 + *(double *)&v303.i64[1];
      v296 += 4;
    }
    while (v296 != 224);
    v304 = 0;
    v305.f64[0] = *(double *)&v299.i64[1] + v300;
    v306 = v290 + v605 * v614;
    v307 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v598), 0);
    v308 = 0.0;
    do
    {
      v309 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v304 * 8 + 8), *(float64x2_t *)&v599[v304]);
      v310 = vextq_s8((int8x16_t)v307, v309, 8uLL);
      v307 = vmulq_f64(*(float64x2_t *)((char *)&v588 + v304 * 8 + 8), *(float64x2_t *)&v599[v304 + 2]);
      v311 = vextq_s8(v309, (int8x16_t)v307, 8uLL);
      v308 = v308 + *(double *)v310.i64 + *(double *)&v310.i64[1] + *(double *)v311.i64 + *(double *)&v311.i64[1];
      v304 += 4;
    }
    while (v304 != 224);
    v312 = 0;
    v313 = v297 + v604 * v614;
    v314 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v599[0]), 0);
    v315 = 0.0;
    do
    {
      v316 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v312 * 8 + 8), *(float64x2_t *)&v599[v312 + 1]);
      v317 = vextq_s8(v314, v316, 8uLL);
      v314 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v312 * 8 + 8), *(float64x2_t *)&v599[v312 + 3]);
      v318 = vextq_s8(v316, v314, 8uLL);
      v315 = v315 + *(double *)v317.i64 + *(double *)&v317.i64[1] + *(double *)v318.i64 + *(double *)&v318.i64[1];
      v312 += 4;
    }
    while (v312 != 220);
    v305.f64[1] = v308;
    v307.f64[0] = v603 * v614;
    v617 = v229 * v586;
    v618 = v237 * v585;
    v619 = v245 * v584;
    v620 = v252 * v583;
    v621 = v260 * 0.913308;
    v622 = v268 * 0.899609;
    v623 = v276 * 0.886115;
    v624 = v283 * 0.872823;
    v625 = v291 * 0.85973;
    v626 = v298 * 0.846834;
    v627 = v306 * 0.834132;
    v628 = v313 * 0.82162;
    v629 = vmulq_f64(vaddq_f64(v305, v307), (float64x2_t)xmmword_208F1CAD0);
    v630 = (v601 * v613 + v600 * v612 + *(double *)&v314.i64[1] + v315 + v602 * v614) * 0.785199;
    v319 = v214 * 1.0001;
    v320 = v221 * 0.985;
    v615 = v214 * 1.0001;
    v616 = v221 * 0.985;
    *(_QWORD *)v632 = 0x3FF0000000000000;
    if (v214 * 1.0001 >= 1.0e-10)
    {
      *(double *)&v632[8] = -v320 / v319;
      v503 = v319 + v320 * *(double *)&v632[8];
      v504 = 1;
      v505 = 2;
      v506 = 8;
      do
      {
        v507 = v504++;
        v508 = *(&v615 + v504);
        v509 = (double *)&v632[8];
        v510 = v506;
        do
        {
          v511 = *v509++;
          v508 = v508 + v511 * *(double *)((char *)&v615 + v510);
          v510 -= 8;
        }
        while (v510);
        v512 = v505 >> 1;
        v513 = -v508 / v503;
        v514 = *(double *)&v632[8 * v507];
        v515 = *(double *)&v632[8] + v513 * v514;
        *(double *)&v632[8 * v507] = v514 + v513 * *(double *)&v632[8];
        *(double *)&v632[8] = v515;
        if (v505 >> 1 != 1)
        {
          v516 = (double *)&v632[8 * v507];
          v517 = *(v516 - 1);
          v518 = *(double *)&v632[16] + v513 * v517;
          *(v516 - 1) = v517 + v513 * *(double *)&v632[16];
          *(double *)&v632[16] = v518;
          if (v512 != 2)
          {
            v519 = *(v516 - 2);
            v520 = *(double *)&v632[24] + v513 * v519;
            *(v516 - 2) = v519 + v513 * *(double *)&v632[24];
            *(double *)&v632[24] = v520;
            if (v512 != 3)
            {
              v521 = (double *)&v632[8 * v507];
              v522 = *(v521 - 3);
              v523 = *(double *)&v632[32] + v513 * v522;
              *(v521 - 3) = v522 + v513 * *(double *)&v632[32];
              *(double *)&v632[32] = v523;
              if (v512 != 4)
              {
                v524 = *(v521 - 4);
                v525 = *(double *)&v632[40] + v513 * v524;
                *(v521 - 4) = v524 + v513 * *(double *)&v632[40];
                *(double *)&v632[40] = v525;
                if (v512 != 5)
                {
                  v526 = (double *)&v632[8 * v507];
                  v527 = *(v526 - 5);
                  v528 = *(double *)&v632[48] + v513 * v527;
                  *(v526 - 5) = v527 + v513 * *(double *)&v632[48];
                  *(double *)&v632[48] = v528;
                  if (v512 != 6)
                  {
                    v529 = *(v526 - 6);
                    v530 = *(double *)&v632[56] + v513 * v529;
                    *(v526 - 6) = v529 + v513 * *(double *)&v632[56];
                    *(double *)&v632[56] = v530;
                    if (v512 != 7)
                    {
                      v531 = (double *)&v632[8 * v507];
                      v532 = *(v531 - 7);
                      v533 = *(double *)&v632[64] + v513 * v532;
                      *(v531 - 7) = v532 + v513 * *(double *)&v632[64];
                      *(double *)&v632[64] = v533;
                    }
                  }
                }
              }
            }
          }
        }
        v503 = v503 + v513 * v508;
        *(double *)&v632[8 * v504] = v513;
        v506 += 8;
        v475 = v505++ == 16;
      }
      while (!v475);
    }
    else
    {
      memset(&v632[8], 0, 128);
    }
    v321 = 0x20u;
    v322 = 4368;
    do
    {
      v323 = *(float32x4_t *)(v6 + v322 - 16);
      v324 = *(float32x4_t *)(v6 + v322);
      v325 = vcvt_hight_f64_f32(v324);
      v326 = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v321 - 16), vcvt_hight_f64_f32(v323));
      v327 = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v321), vcvtq_f64_f32(*(float32x2_t *)v324.f32));
      v328 = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v321 + 16), v325);
      v329 = (float64x2_t *)((char *)&v587 + v321);
      v329[-2] = vmulq_f64(*(float64x2_t *)((char *)&webrtc::kLpcAnalWin + v321 - 32), vcvtq_f64_f32(*(float32x2_t *)v323.f32));
      v329[-1] = v326;
      *v329 = v327;
      v329[1] = v328;
      v321 += 64;
      v322 += 32;
    }
    while (v321 != 1952);
    v330 = 0;
    v331 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v587.i64), 0);
    v332 = 0.0;
    do
    {
      v333 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v330 + 8), *(float64x2_t *)((char *)&v587 + v330 + 8));
      v334 = vextq_s8(v331, v333, 8uLL);
      v331 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v330 + 8), *(float64x2_t *)((char *)&v588 + v330 + 8));
      v335 = vextq_s8(v333, v331, 8uLL);
      v332 = v332 + *(double *)v334.i64 + *(double *)&v334.i64[1] + *(double *)v335.i64 + *(double *)&v335.i64[1];
      v330 += 32;
    }
    while (v330 != 1888);
    v336 = 0;
    v337 = v613 * v613 + v612 * v612 + *(double *)&v331.i64[1] + v332;
    v338 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v587.i64[1]), 0);
    v339 = 0.0;
    do
    {
      v340 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v336 + 8), *(float64x2_t *)((char *)&v587 + v336 + 16));
      v341 = vextq_s8(v338, v340, 8uLL);
      v338 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v336 + 8), *(float64x2_t *)((char *)&v589 + v336));
      v342 = vextq_s8(v340, v338, 8uLL);
      v339 = v339 + *(double *)v341.i64 + *(double *)&v341.i64[1] + *(double *)v342.i64 + *(double *)&v342.i64[1];
      v336 += 32;
    }
    while (v336 != 1888);
    v343 = 0;
    v344 = v612 * v613 + *(double *)&v338.i64[1] + v339;
    v345 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v588.i64), 0);
    v346 = 0.0;
    do
    {
      v347 = *(float64x2_t *)((char *)&v588 + v343 + 8);
      v348 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v343 + 8), v347);
      v349 = vextq_s8(v345, v348, 8uLL);
      v345 = (int8x16_t)vmulq_f64(v347, *(float64x2_t *)((char *)&v589 + v343 + 8));
      v350 = vextq_s8(v348, v345, 8uLL);
      v346 = v346 + *(double *)v349.i64 + *(double *)&v349.i64[1] + *(double *)v350.i64 + *(double *)&v350.i64[1];
      v343 += 32;
    }
    while (v343 != 1888);
    v351 = 0;
    v352 = *(double *)&v345.i64[1] + v346;
    v353 = v337 + v614 * v614;
    v354 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v588.i64[1]), 0);
    v355 = 0.0;
    do
    {
      v356 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v351 + 8), *(float64x2_t *)((char *)&v589 + v351));
      v357 = vextq_s8(v354, v356, 8uLL);
      v354 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v351 + 8), *(float64x2_t *)((char *)&v590 + v351));
      v358 = vextq_s8(v356, v354, 8uLL);
      v355 = v355 + *(double *)v357.i64 + *(double *)&v357.i64[1] + *(double *)v358.i64 + *(double *)&v358.i64[1];
      v351 += 32;
    }
    while (v351 != 1888);
    v359 = 0;
    v360 = v344 + v613 * v614;
    v361 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v589.i64), 0);
    v362 = 0.0;
    do
    {
      v363 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v359 + 8), *(float64x2_t *)((char *)&v589 + v359 + 8));
      v364 = vextq_s8(v361, v363, 8uLL);
      v361 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v359 + 8), *(float64x2_t *)((char *)&v590 + v359 + 8));
      v365 = vextq_s8(v363, v361, 8uLL);
      v362 = v362 + *(double *)v364.i64 + *(double *)&v364.i64[1] + *(double *)v365.i64 + *(double *)&v365.i64[1];
      v359 += 32;
    }
    while (v359 != 1856);
    v366 = 0;
    v367 = v610 * v613 + v609 * v612 + *(double *)&v361.i64[1] + v362;
    v368 = v352 + v612 * v614;
    v369 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v589.i64[1]), 0);
    v370 = 0.0;
    do
    {
      v371 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v366 + 8), *(float64x2_t *)((char *)&v590 + v366));
      v372 = vextq_s8(v369, v371, 8uLL);
      v369 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v366 + 8), *(float64x2_t *)((char *)&v591 + v366));
      v373 = vextq_s8(v371, v369, 8uLL);
      v370 = v370 + *(double *)v372.i64 + *(double *)&v372.i64[1] + *(double *)v373.i64 + *(double *)&v373.i64[1];
      v366 += 32;
    }
    while (v366 != 1856);
    v374 = 0;
    v375 = v609 * v613 + *(double *)&v369.i64[1] + v370;
    v376 = v355 + *(double *)&v354.i64[1];
    v377 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)v590.i64), 0);
    v378 = 0.0;
    do
    {
      v379 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v374 + 8), *(float64x2_t *)((char *)&v590 + v374 + 8));
      v380 = vextq_s8(v377, v379, 8uLL);
      v377 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v374 + 8), *(float64x2_t *)((char *)&v592 + v374));
      v381 = vextq_s8(v379, v377, 8uLL);
      v378 = v378 + *(double *)v380.i64 + *(double *)&v380.i64[1] + *(double *)v381.i64 + *(double *)&v381.i64[1];
      v374 += 32;
    }
    while (v374 != 1856);
    v382 = 0;
    v383 = *(double *)&v377.i64[1] + v378;
    v384 = v367 + v611 * v614;
    v385 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * *(double *)&v590.i64[1]), 0);
    v386 = 0.0;
    do
    {
      v387 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v382 + 8), *(float64x2_t *)((char *)&v591 + v382));
      v388 = vextq_s8(v385, v387, 8uLL);
      v385 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v382 + 8), *(float64x2_t *)((char *)&v593 + v382));
      v389 = vextq_s8(v387, v385, 8uLL);
      v386 = v386 + *(double *)v388.i64 + *(double *)&v388.i64[1] + *(double *)v389.i64 + *(double *)&v389.i64[1];
      v382 += 32;
    }
    while (v382 != 1856);
    v390 = 0;
    v391 = v375 + v610 * v614;
    v392 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v591), 0);
    v393 = 0.0;
    do
    {
      v394 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v390 + 8), *(float64x2_t *)((char *)&v592 + v390));
      v395 = vextq_s8(v392, v394, 8uLL);
      v392 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v390 + 8), *(float64x2_t *)((char *)&v594 + v390));
      v396 = vextq_s8(v394, v392, 8uLL);
      v393 = v393 + *(double *)v395.i64 + *(double *)&v395.i64[1] + *(double *)v396.i64 + *(double *)&v396.i64[1];
      v390 += 32;
    }
    while (v390 != 1824);
    v397 = 0;
    v398 = v607 * v613 + v606 * v612 + *(double *)&v392.i64[1] + v393;
    v399 = v383 + v609 * v614;
    v400 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v592), 0);
    v401 = 0.0;
    do
    {
      v402 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v397 + 8), *(float64x2_t *)((char *)&v593 + v397));
      v403 = vextq_s8(v400, v402, 8uLL);
      v400 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v397 + 8), *(float64x2_t *)((char *)&v595 + v397));
      v404 = vextq_s8(v402, v400, 8uLL);
      v401 = v401 + *(double *)v403.i64 + *(double *)&v403.i64[1] + *(double *)v404.i64 + *(double *)&v404.i64[1];
      v397 += 32;
    }
    while (v397 != 1824);
    v405 = 0;
    v406 = v606 * v613 + *(double *)&v400.i64[1] + v401;
    v407 = v386 + *(double *)&v385.i64[1];
    v408 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v593), 0);
    v409 = 0.0;
    do
    {
      v410 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v405 + 8), *(float64x2_t *)((char *)&v594 + v405));
      v411 = vextq_s8(v408, v410, 8uLL);
      v408 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v405 + 8), *(float64x2_t *)((char *)&v596 + v405));
      v412 = vextq_s8(v410, v408, 8uLL);
      v409 = v409 + *(double *)v411.i64 + *(double *)&v411.i64[1] + *(double *)v412.i64 + *(double *)&v412.i64[1];
      v405 += 32;
    }
    while (v405 != 1824);
    v413 = 0;
    v414 = *(double *)&v408.i64[1] + v409;
    v415 = v398 + v608 * v614;
    v416 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v594), 0);
    v417 = 0.0;
    do
    {
      v418 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v413 + 8), *(float64x2_t *)((char *)&v595 + v413));
      v419 = vextq_s8(v416, v418, 8uLL);
      v416 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v413 + 8), *(float64x2_t *)((char *)&v597 + v413));
      v420 = vextq_s8(v418, v416, 8uLL);
      v417 = v417 + *(double *)v419.i64 + *(double *)&v419.i64[1] + *(double *)v420.i64 + *(double *)&v420.i64[1];
      v413 += 32;
    }
    while (v413 != 1824);
    v421 = 0;
    v422 = v406 + v607 * v614;
    v423 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v595), 0);
    v424 = 0.0;
    do
    {
      v425 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v421 * 8 + 8), *(float64x2_t *)((char *)&v596 + v421 * 8));
      v426 = vextq_s8(v423, v425, 8uLL);
      v423 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v421 * 8 + 8), *(float64x2_t *)&v599[v421 - 1]);
      v427 = vextq_s8(v425, v423, 8uLL);
      v424 = v424 + *(double *)v426.i64 + *(double *)&v426.i64[1] + *(double *)v427.i64 + *(double *)&v427.i64[1];
      v421 += 4;
    }
    while (v421 != 224);
    v428 = 0;
    v429 = v604 * v613 + v603 * v612 + *(double *)&v423.i64[1] + v424;
    v430 = v414 + v606 * v614;
    v431 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v596), 0);
    v432 = 0.0;
    do
    {
      v433 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v428 * 8 + 8), *(float64x2_t *)((char *)&v597 + v428 * 8));
      v434 = vextq_s8(v431, v433, 8uLL);
      v431 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v428 * 8 + 8), *(float64x2_t *)&v599[v428]);
      v435 = vextq_s8(v433, v431, 8uLL);
      v432 = v432 + *(double *)v434.i64 + *(double *)&v434.i64[1] + *(double *)v435.i64 + *(double *)&v435.i64[1];
      v428 += 4;
    }
    while (v428 != 224);
    v436 = 0;
    v437 = v603 * v613 + *(double *)&v431.i64[1] + v432;
    v438 = v417 + *(double *)&v416.i64[1];
    v439 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v597), 0);
    v440 = 0.0;
    do
    {
      v441 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v436 * 8 + 8), *(float64x2_t *)&v599[v436 - 1]);
      v442 = vextq_s8(v439, v441, 8uLL);
      v439 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v436 * 8 + 8), *(float64x2_t *)&v599[v436 + 1]);
      v443 = vextq_s8(v441, v439, 8uLL);
      v440 = v440 + *(double *)v442.i64 + *(double *)&v442.i64[1] + *(double *)v443.i64 + *(double *)&v443.i64[1];
      v436 += 4;
    }
    while (v436 != 224);
    v444 = 0;
    v445.f64[0] = *(double *)&v439.i64[1] + v440;
    v446 = v429 + v605 * v614;
    v447 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v598), 0);
    v448 = 0.0;
    do
    {
      v449 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v444 * 8 + 8), *(float64x2_t *)&v599[v444]);
      v450 = vextq_s8((int8x16_t)v447, v449, 8uLL);
      v447 = vmulq_f64(*(float64x2_t *)((char *)&v588 + v444 * 8 + 8), *(float64x2_t *)&v599[v444 + 2]);
      v451 = vextq_s8(v449, (int8x16_t)v447, 8uLL);
      v448 = v448 + *(double *)v450.i64 + *(double *)&v450.i64[1] + *(double *)v451.i64 + *(double *)&v451.i64[1];
      v444 += 4;
    }
    while (v444 != 224);
    v452 = 0;
    v453 = v437 + v604 * v614;
    v454 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(*(double *)v587.i64 * v599[0]), 0);
    v455 = 0.0;
    do
    {
      v456 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v587 + v452 * 8 + 8), *(float64x2_t *)&v599[v452 + 1]);
      v457 = vextq_s8(v454, v456, 8uLL);
      v454 = (int8x16_t)vmulq_f64(*(float64x2_t *)((char *)&v588 + v452 * 8 + 8), *(float64x2_t *)&v599[v452 + 3]);
      v458 = vextq_s8(v456, v454, 8uLL);
      v455 = v455 + *(double *)v457.i64 + *(double *)&v457.i64[1] + *(double *)v458.i64 + *(double *)&v458.i64[1];
      v452 += 4;
    }
    while (v452 != 220);
    v445.f64[1] = v448;
    v447.f64[0] = v603 * v614;
    v459 = vaddq_f64(v445, v447);
    v460 = v353 * 1.0001;
    v461 = v360 * 0.985;
    v615 = v353 * 1.0001;
    v616 = v360 * 0.985;
    v617 = v368 * v586;
    v618 = v376 * v585;
    v619 = v384 * v584;
    v620 = v391 * v583;
    v621 = v399 * 0.913308;
    v622 = v407 * 0.899609;
    v623 = v415 * 0.886115;
    v624 = v422 * 0.872823;
    v625 = v430 * 0.85973;
    v626 = v438 * 0.846834;
    v627 = v446 * 0.834132;
    v628 = v453 * 0.82162;
    v629 = vmulq_f64(v459, (float64x2_t)xmmword_208F1CAD0);
    v630 = (v601 * v613 + v600 * v612 + *(double *)&v454.i64[1] + v455 + v602 * v614) * 0.785199;
    v633[0].f64[0] = 1.0;
    if (v353 * 1.0001 >= 1.0e-10)
    {
      v633[0].f64[1] = -v461 / v460;
      v534 = v460 + v461 * v633[0].f64[1];
      v535 = 1;
      v536 = 2;
      v537 = 8;
      do
      {
        v538 = v535++;
        v539 = *(&v615 + v535);
        v540 = &v633[0].f64[1];
        v541 = v537;
        do
        {
          v542 = *v540++;
          v539 = v539 + v542 * *(double *)((char *)&v615 + v541);
          v541 -= 8;
        }
        while (v541);
        v543 = v536 >> 1;
        v544 = -v539 / v534;
        v545 = v633[0].f64[v538];
        v546 = v633[0].f64[1] + v544 * v545;
        v633[0].f64[v538] = v545 + v544 * v633[0].f64[1];
        v633[0].f64[1] = v546;
        if (v536 >> 1 != 1)
        {
          v547 = &v633[0].f64[v538];
          v548 = *(v547 - 1);
          v549 = v633[1].f64[0] + v544 * v548;
          *(v547 - 1) = v548 + v544 * v633[1].f64[0];
          v633[1].f64[0] = v549;
          if (v543 != 2)
          {
            v550 = *(v547 - 2);
            v551 = v633[1].f64[1] + v544 * v550;
            *(v547 - 2) = v550 + v544 * v633[1].f64[1];
            v633[1].f64[1] = v551;
            if (v543 != 3)
            {
              v552 = &v633[0].f64[v538];
              v553 = *(v552 - 3);
              v554 = v633[2].f64[0] + v544 * v553;
              *(v552 - 3) = v553 + v544 * v633[2].f64[0];
              v633[2].f64[0] = v554;
              if (v543 != 4)
              {
                v555 = *(v552 - 4);
                v556 = v633[2].f64[1] + v544 * v555;
                *(v552 - 4) = v555 + v544 * v633[2].f64[1];
                v633[2].f64[1] = v556;
                if (v543 != 5)
                {
                  v557 = &v633[0].f64[v538];
                  v558 = *(v557 - 5);
                  v559 = v633[3].f64[0] + v544 * v558;
                  *(v557 - 5) = v558 + v544 * v633[3].f64[0];
                  v633[3].f64[0] = v559;
                  if (v543 != 6)
                  {
                    v560 = *(v557 - 6);
                    v561 = v633[3].f64[1] + v544 * v560;
                    *(v557 - 6) = v560 + v544 * v633[3].f64[1];
                    v633[3].f64[1] = v561;
                    if (v543 != 7)
                    {
                      v562 = &v633[0].f64[v538];
                      v563 = *(v562 - 7);
                      v564 = v633[4].f64[0] + v544 * v563;
                      *(v562 - 7) = v563 + v544 * v633[4].f64[0];
                      v633[4].f64[0] = v564;
                    }
                  }
                }
              }
            }
          }
        }
        v534 = v534 + v544 * v539;
        v633[0].f64[v535] = v544;
        v537 += 8;
        v475 = v536++ == 16;
      }
      while (!v475);
    }
    else
    {
      memset(&v633[0].f64[1], 0, 128);
    }
    bzero((char *)&v591 + 4, 0x7BCuLL);
    v587 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v631), *(float64x2_t *)&v631[16]);
    v588 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v631[32]), *(float64x2_t *)&v631[48]);
    v462.i64[1] = *(_QWORD *)&v631[120];
    v589 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v631[64]), *(float64x2_t *)&v631[80]);
    v590 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v631[96]), *(float64x2_t *)&v631[112]);
    v462.i32[1] = *(_DWORD *)&v631[132];
    v462.f32[0] = *(double *)&v631[128];
    LODWORD(v591) = v462.i32[0];
    v463 = 1;
    webrtc::WebRtc_rdft((webrtc *)0x200, 1, v587.f32, (int64x2_t *)v6, (float *)(v6 + 2048), v464, v462);
    v465 = v587.f32[0] * v587.f32[0];
    v466 = (float)(v587.f32[3] * v587.f32[3]) + (float)(v587.f32[2] * v587.f32[2]);
    v467 = &v588.f32[1];
    do
    {
      v468 = v466;
      v466 = (float)(*v467 * *v467) + (float)(*(v467 - 1) * *(v467 - 1));
      if (v468 < v465 && v468 < v466)
      {
        v469 = (float)v463;
        v470 = (float)((float)((float)(1.0 / v466) - (float)(1.0 / v465)) * -0.5)
             / (float)((float)((float)(1.0 / v465) + (float)(1.0 / v466)) + (float)((float)(1.0 / v468) * -2.0));
        goto LABEL_175;
      }
      ++v463;
      v467 += 2;
      v465 = v468;
    }
    while (v463 != 255);
    v469 = 0.0;
    v470 = 0.0;
    if (v466 < v468)
    {
      v470 = 0.0;
      if (v466 < (float)(v587.f32[1] * v587.f32[1]))
        v469 = 256.0;
      else
        v469 = 0.0;
    }
LABEL_175:
    *(double *)(v5 + 64) = (float)((float)(v470 + v469) * 31.25);
    bzero((char *)&v591 + 4, 0x7BCuLL);
    v587 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v632), *(float64x2_t *)&v632[16]);
    v588 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v632[32]), *(float64x2_t *)&v632[48]);
    v565.i64[1] = *(_QWORD *)&v632[120];
    v589 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v632[64]), *(float64x2_t *)&v632[80]);
    v590 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v632[96]), *(float64x2_t *)&v632[112]);
    v565.i32[1] = *(_DWORD *)&v632[132];
    v565.f32[0] = *(double *)&v632[128];
    LODWORD(v591) = v565.i32[0];
    v566 = 1;
    webrtc::WebRtc_rdft((webrtc *)0x200, 1, v587.f32, (int64x2_t *)v6, (float *)(v6 + 2048), v567, v565);
    v568 = v587.f32[0] * v587.f32[0];
    v569 = (float)(v587.f32[3] * v587.f32[3]) + (float)(v587.f32[2] * v587.f32[2]);
    v570 = &v588.f32[1];
    do
    {
      v571 = v569;
      v569 = (float)(*v570 * *v570) + (float)(*(v570 - 1) * *(v570 - 1));
      if (v571 < v568 && v571 < v569)
      {
        v572 = (float)v566;
        v573 = (float)((float)((float)(1.0 / v569) - (float)(1.0 / v568)) * -0.5)
             / (float)((float)((float)(1.0 / v568) + (float)(1.0 / v569)) + (float)((float)(1.0 / v571) * -2.0));
        goto LABEL_184;
      }
      ++v566;
      v570 += 2;
      v568 = v571;
    }
    while (v566 != 255);
    v572 = 0.0;
    v573 = 0.0;
    if (v569 < v571)
    {
      v573 = 0.0;
      if (v569 < (float)(v587.f32[1] * v587.f32[1]))
        v572 = 256.0;
      else
        v572 = 0.0;
    }
LABEL_184:
    *(double *)(v5 + 72) = (float)((float)(v573 + v572) * 31.25);
    bzero((char *)&v591 + 4, 0x7BCuLL);
    v587 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v633[0]), v633[1]);
    v588 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v633[2]), v633[3]);
    v574.i64[1] = *(_QWORD *)&v633[7].f64[1];
    v589 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v633[4]), v633[5]);
    v590 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v633[6]), v633[7]);
    v574.i32[1] = HIDWORD(v633[8].f64[0]);
    v574.f32[0] = v633[8].f64[0];
    LODWORD(v591) = v574.i32[0];
    v575 = 1;
    webrtc::WebRtc_rdft((webrtc *)0x200, 1, v587.f32, (int64x2_t *)v6, (float *)(v6 + 2048), v576, v574);
    v577 = v587.f32[0] * v587.f32[0];
    v578 = (float)(v587.f32[3] * v587.f32[3]) + (float)(v587.f32[2] * v587.f32[2]);
    v579 = &v588.f32[1];
    do
    {
      v580 = v578;
      v578 = (float)(*v579 * *v579) + (float)(*(v579 - 1) * *(v579 - 1));
      if (v580 < v577 && v580 < v578)
      {
        v581 = (float)v575;
        v582 = (float)((float)((float)(1.0 / v578) - (float)(1.0 / v577)) * -0.5)
             / (float)((float)((float)(1.0 / v577) + (float)(1.0 / v578)) + (float)((float)(1.0 / v580) * -2.0));
        goto LABEL_193;
      }
      ++v575;
      v579 += 2;
      v577 = v580;
    }
    while (v575 != 255);
    v581 = 0.0;
    v582 = 0.0;
    if (v578 < v580)
    {
      v582 = 0.0;
      if (v578 < (float)(v587.f32[1] * v587.f32[1]))
        v581 = 256.0;
      else
        v581 = 0.0;
    }
LABEL_193:
    *(double *)(v5 + 80) = (float)((float)(v582 + v581) * 31.25);
  }
  memcpy((void *)(v6 + 3072), (const void *)(v6 + 4992), 0x140uLL);
  result = 0;
  *(_QWORD *)(v6 + 5312) = 80;
  return result;
}

uint64_t webrtc::VadCircularBuffer::RemoveTransient(webrtc::VadCircularBuffer *this, int a2, double a3)
{
  int v3;
  int v4;
  int v5;
  int v7;
  uint64_t v8;
  double v9;
  double v10;
  int v11;
  int v12;
  int v13;
  int v14;
  BOOL v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  int v22;
  int v23;
  uint64_t v24;

  v3 = *((unsigned __int8 *)this + 8);
  if (!*((_BYTE *)this + 8) && *((_DWORD *)this + 3) < a2 + 2)
    return 0;
  v4 = *((_DWORD *)this + 4);
  if (v4 < 1)
    return 0xFFFFFFFFLL;
  v5 = *((_DWORD *)this + 3);
  if (!*((_BYTE *)this + 8) && v5 < 1)
    return 0xFFFFFFFFLL;
  v7 = (v4 & ((v5 - 1) >> 31)) + v5 - 1;
  v8 = *(_QWORD *)this;
  v9 = *(double *)(*(_QWORD *)this + 8 * v7);
  if (v9 >= a3)
    return 0;
  *((double *)this + 3) = *((double *)this + 3) - v9;
  *(_QWORD *)(v8 + 8 * v7) = 0;
  v10 = *((double *)this + 3) + 0.0;
  *((double *)this + 3) = v10;
  if (a2 < 0)
    return 0;
  v11 = a2 + 1;
  if (a2 + 1 >= 1)
    v12 = 1;
  else
    v12 = a2 + 1;
  v13 = v12 - 1;
  if (!v3)
  {
    if (v11 < v4)
    {
      v16 = v5 - a2 - 2;
      v17 = a2 + 1;
      while (v11 < v5)
      {
        if (*(double *)(v8 + 8 * ((v4 & (v16 >> 31)) + v16)) < a3)
        {
          v11 = v17;
          goto LABEL_28;
        }
        ++v16;
        v15 = __OFSUB__(v17--, 1);
        if ((v17 < 0) ^ v15 | (v17 == 0))
        {
LABEL_26:
          v11 = v13;
          goto LABEL_28;
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (v11 >= v4)
    return 0xFFFFFFFFLL;
  v14 = v5 - a2 - 2;
  while (*(double *)(v8 + 8 * ((v4 & (v14 >> 31)) + v14)) >= a3)
  {
    ++v14;
    v15 = __OFSUB__(v11--, 1);
    if ((v11 < 0) ^ v15 | (v11 == 0))
      goto LABEL_26;
  }
LABEL_28:
  if (v11 < 1)
    return 0;
  if (!v3)
  {
    if (v11 < v4)
    {
      v22 = ~v11 + v5;
      v23 = v11 + 1;
      while (v11 < v5)
      {
        v24 = 8 * ((v4 & (v22 >> 31)) + v22);
        *((double *)this + 3) = v10 - *(double *)(v8 + v24);
        *(_QWORD *)(v8 + v24) = 0;
        v10 = *((double *)this + 3) + 0.0;
        *((double *)this + 3) = v10;
        ++v22;
        if (--v23 <= 1)
          return 0;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (v11 >= v4)
    return 0xFFFFFFFFLL;
  v18 = v11 + 1;
  v19 = ~v11 + v5;
  do
  {
    v20 = 8 * ((v4 & (v19 >> 31)) + v19);
    *((double *)this + 3) = v10 - *(double *)(v8 + v20);
    *(_QWORD *)(v8 + v20) = 0;
    v10 = *((double *)this + 3) + 0.0;
    *((double *)this + 3) = v10;
    --v18;
    ++v19;
  }
  while (v18 > 1);
  return 0;
}

uint64_t WebRtcVad_InitCore(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)a1 = 1;
  v2 = a1 + 276;
  *(_QWORD *)(a1 + 276) = 0;
  *(_QWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 4) = 0;
  *(_OWORD *)(a1 + 20) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 100) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 148) = 0u;
  *(_OWORD *)(a1 + 164) = 0u;
  *(_QWORD *)(a1 + 196) = 0x110A139C1C621E8CLL;
  *(_OWORD *)(a1 + 180) = kNoiseDataMeans;
  *(_OWORD *)(a1 + 204) = kSpeechDataMeans;
  *(_QWORD *)(a1 + 220) = 0x1D3B1FF41D9D2A7FLL;
  *(_OWORD *)(a1 + 228) = kNoiseDataStds;
  *(_QWORD *)(a1 + 244) = 0x1C701A502B001DBLL;
  *(_OWORD *)(a1 + 252) = kSpeechDataStds;
  *(_QWORD *)(a1 + 268) = 0x3520437060401ECLL;
  *(_OWORD *)(a1 + 284) = 0u;
  *(_OWORD *)(a1 + 300) = 0u;
  *(_OWORD *)(a1 + 316) = 0u;
  *(_OWORD *)(a1 + 332) = 0u;
  *(_OWORD *)(a1 + 348) = 0u;
  *(_OWORD *)(a1 + 364) = 0u;
  *(_OWORD *)(a1 + 380) = 0u;
  *(_OWORD *)(a1 + 396) = 0u;
  *(_OWORD *)(a1 + 412) = 0u;
  *(_OWORD *)(a1 + 428) = 0u;
  *(_OWORD *)(a1 + 444) = 0u;
  *(_OWORD *)(a1 + 460) = 0u;
  memset_pattern16((void *)(a1 + 476), &memset_pattern_2, 0xC0uLL);
  *(_WORD *)(a1 + 688) = 0;
  *(_QWORD *)(a1 + 680) = 0;
  *(_QWORD *)(a1 + 690) = 0;
  *(_WORD *)(a1 + 698) = 0;
  *(_QWORD *)(v2 + 424) = 0;
  memset_pattern16((void *)(a1 + 668), &memset_pattern_1_0, 0xCuLL);
  result = 0;
  *(_DWORD *)(a1 + 714) = 458766;
  *(_DWORD *)(a1 + 726) = 3145785;
  *(_WORD *)(a1 + 712) = 3;
  *(_DWORD *)(a1 + 708) = 262152;
  *(_WORD *)(a1 + 718) = 5;
  *(_DWORD *)(a1 + 720) = 1376280;
  *(_WORD *)(a1 + 724) = 24;
  *(_WORD *)(a1 + 730) = 57;
  *(_DWORD *)(a1 + 732) = 42;
  return result;
}

uint64_t WebRtcVad_set_mode_core(uint64_t a1, int a2)
{
  uint64_t result;

  switch(a2)
  {
    case 0:
      result = 0;
      *(_DWORD *)(a1 + 714) = 458766;
      *(_WORD *)(a1 + 712) = 3;
      *(_DWORD *)(a1 + 708) = 262152;
      *(_WORD *)(a1 + 718) = 5;
      *(_DWORD *)(a1 + 720) = 1376280;
      *(_WORD *)(a1 + 724) = 24;
      *(_WORD *)(a1 + 730) = 57;
      *(_DWORD *)(a1 + 726) = 3145785;
      break;
    case 1:
      result = 0;
      *(_DWORD *)(a1 + 714) = 458766;
      *(_WORD *)(a1 + 712) = 3;
      *(_DWORD *)(a1 + 708) = 262152;
      *(_WORD *)(a1 + 718) = 5;
      *(_DWORD *)(a1 + 720) = 2097189;
      *(_WORD *)(a1 + 724) = 37;
      *(_WORD *)(a1 + 730) = 100;
      *(_DWORD *)(a1 + 726) = 5242980;
      break;
    case 2:
      result = 0;
      *(_DWORD *)(a1 + 714) = 327689;
      *(_WORD *)(a1 + 712) = 2;
      *(_DWORD *)(a1 + 708) = 196614;
      *(_WORD *)(a1 + 718) = 3;
      *(_DWORD *)(a1 + 720) = 5111890;
      *(_WORD *)(a1 + 724) = 82;
      *(_WORD *)(a1 + 730) = 285;
      *(_DWORD *)(a1 + 726) = 17039645;
      break;
    case 3:
      result = 0;
      *(_DWORD *)(a1 + 714) = 327689;
      *(_WORD *)(a1 + 712) = 2;
      *(_DWORD *)(a1 + 708) = 196614;
      *(_WORD *)(a1 + 718) = 3;
      *(_DWORD *)(a1 + 720) = 6160478;
      *(_WORD *)(a1 + 724) = 94;
      *(_WORD *)(a1 + 730) = 1100;
      *(_DWORD *)(a1 + 726) = 68813900;
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t WebRtcVad_CalcVad48khz(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v6;
  __int16 *v7;
  _BYTE v9[2944];
  _BYTE v10[480];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  bzero(v9, 0xB80uLL);
  if (a3 >= 0x1E0)
  {
    v6 = a3 / 0x1E0;
    v7 = (__int16 *)v10;
    do
    {
      WebRtcSpl_Resample48khzTo8khz(a2, v7, a1 + 20, (uint64_t)v9);
      v7 += 80;
      --v6;
    }
    while (v6);
  }
  return WebRtcVad_CalcVad8khz(a1, (uint64_t)v10, a3 / 6);
}

uint64_t WebRtcVad_CalcVad8khz(uint64_t a1, uint64_t a2, unint64_t a3)
{
  int v5;
  __int16 *v6;
  __int16 *v7;
  __int16 *v8;
  __int16 *v9;
  __int16 *v10;
  __int16 *v11;
  __int16 *v12;
  unint64_t v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  __int16 v20;
  __int16 v21;
  int v22;
  int v23;
  unsigned int v24;
  unint64_t v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  unint64_t v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  unint64_t v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  unsigned int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  signed int v56;
  int v57;
  int v58;
  signed int v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  __int16 v63;
  __int16 v64;
  __int16 v65;
  int Minimum;
  _WORD *v67;
  __int16 v68;
  int v69;
  int v70;
  int v71;
  int v72;
  _WORD *v73;
  __int16 v74;
  int v75;
  int v76;
  __int16 v77;
  int v78;
  int v79;
  int v80;
  __int16 v81;
  __int16 v82;
  int v83;
  int v84;
  char v85;
  int v86;
  int v87;
  int v88;
  int v89;
  unsigned int v90;
  int v91;
  int v92;
  int v93;
  _WORD *v94;
  __int16 v95;
  _WORD *v96;
  __int16 v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  char v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  __int16 v113;
  __int16 v114;
  int v115;
  unint64_t v116;
  __int16 v117;
  int v118;
  __int16 v119;
  int v120;
  int v121;
  int v122;
  int v123;
  __int16 v124;
  int v125;
  unsigned int v126;
  __int16 v127;
  int v128;
  unsigned int v129;
  int v130;
  int v131;
  int v132;
  __int16 v133;
  int v134;
  __int16 v135;
  __int16 v136;
  uint64_t result;
  __int16 v138;
  __int16 v139;
  int v140;
  __int16 v141[6];
  uint64_t v142;
  _QWORD v143[2];
  uint64_t v144;
  _QWORD v145[9];

  v145[8] = *MEMORY[0x24BDAC8D0];
  v5 = WebRtcVad_CalculateFeatures((unsigned __int16 *)a1, a2, a3, v141);
  v6 = (__int16 *)(a1 + 722);
  v144 = 0;
  v145[0] = 0;
  v145[1] = 0;
  v7 = (__int16 *)(a1 + 712);
  v8 = (__int16 *)(a1 + 718);
  v9 = (__int16 *)(a1 + 730);
  v142 = 0;
  v143[0] = 0;
  v143[1] = 0;
  if (a3 == 80)
  {
    v7 = (__int16 *)(a1 + 708);
    v8 = (__int16 *)(a1 + 714);
    v10 = (__int16 *)(a1 + 720);
  }
  else
  {
    v10 = (__int16 *)(a1 + 724);
  }
  if (a3 == 80)
    v9 = (__int16 *)(a1 + 726);
  if (a3 == 160)
    v11 = (__int16 *)(a1 + 710);
  else
    v11 = v7;
  if (a3 == 160)
    v8 = (__int16 *)(a1 + 716);
  else
    v6 = v10;
  if (a3 == 160)
    v12 = (__int16 *)(a1 + 728);
  else
    v12 = v9;
  if (v5 < 11)
    goto LABEL_124;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v139 = *v8;
  v140 = *v12;
  v138 = *v11;
  v16 = *v6;
  v17 = a1 + 264;
  do
  {
    if (*(_WORD *)(v17 + v13 - 36))
      v19 = (((*(__int16 *)(v17 + v13 - 36) >> 1) + 0x20000) / *(__int16 *)(v17 + v13 - 36)) << 16;
    else
      v19 = -65536;
    v20 = 8 * v141[v13 / 2];
    v21 = v20 - *(_WORD *)(v17 + v13 - 84);
    v22 = (__int16)(((v19 >> 18) * (v19 >> 18)) >> 2) * v21;
    *(_WORD *)((char *)&v145[5] + v13) = v22 >> 10;
    v23 = (__int16)(v22 >> 10) * v21;
    if (v23 >= 11266560)
    {
      v24 = 0;
      v25 = v17 + v13;
      v26 = *(__int16 *)(v17 + v13 - 12);
      if (*(_WORD *)(v17 + v13 - 12))
      {
LABEL_25:
        v27 = (((v26 >> 1) + 0x20000) / v26) << 16;
        goto LABEL_28;
      }
    }
    else
    {
      v24 = ((-((94544 * (v23 >> 9)) & 0xFFFF0000) >> 16) & 0x3FF | 0x400) >> -((signed int)-((94544 * (v23 >> 9)) & 0xFFFF0000) >> 26);
      v25 = v17 + v13;
      v26 = *(__int16 *)(v17 + v13 - 12);
      if (*(_WORD *)(v17 + v13 - 12))
        goto LABEL_25;
    }
    v27 = -65536;
LABEL_28:
    v28 = kNoiseDataWeights[v13 / 2];
    v29 = (__int16)(v20 - *(_WORD *)(v25 - 60));
    v30 = (__int16)(((v27 >> 18) * (v27 >> 18)) >> 2) * v29;
    *(_WORD *)((char *)&v145[2] + v13) = v30 >> 10;
    v31 = (__int16)(v30 >> 10) * v29;
    if (v31 >= 11266560)
    {
      v32 = 0;
      v33 = v17 + v13;
      v34 = *(__int16 *)(v17 + v13 - 24);
      if (*(_WORD *)(v17 + v13 - 24))
      {
LABEL_30:
        v35 = (((v34 >> 1) + 0x20000) / v34) << 16;
        goto LABEL_33;
      }
    }
    else
    {
      v32 = ((-((94544 * (v31 >> 9)) & 0xFFFF0000) >> 16) & 0x3FF | 0x400) >> -((signed int)-((94544 * (v31 >> 9)) & 0xFFFF0000) >> 26);
      v33 = v17 + v13;
      v34 = *(__int16 *)(v17 + v13 - 24);
      if (*(_WORD *)(v17 + v13 - 24))
        goto LABEL_30;
    }
    v35 = -65536;
LABEL_33:
    v36 = kSpeechDataWeights[v13 / 2];
    v37 = (__int16)(v20 - *(_WORD *)(v33 - 72));
    v38 = (__int16)(((v35 >> 18) * (v35 >> 18)) >> 2) * v37;
    *(_WORD *)((char *)&v145[6] + v13 + 4) = v38 >> 10;
    v39 = (__int16)(v38 >> 10) * v37;
    if (v39 >= 11266560)
    {
      v40 = 0;
      v41 = v17 + v13;
      v42 = *(__int16 *)(v17 + v13);
      if (*(_WORD *)(v17 + v13))
      {
LABEL_35:
        v43 = (((v42 >> 1) + 0x20000) / v42) << 16;
        goto LABEL_38;
      }
    }
    else
    {
      v40 = ((-((94544 * (v39 >> 9)) & 0xFFFF0000) >> 16) & 0x3FF | 0x400) >> -((signed int)-((94544 * (v39 >> 9)) & 0xFFFF0000) >> 26);
      v41 = v17 + v13;
      v42 = *(__int16 *)(v17 + v13);
      if (*(_WORD *)(v17 + v13))
        goto LABEL_35;
    }
    v43 = -65536;
LABEL_38:
    v44 = kNoiseDataWeights[v13 / 2 + 6];
    v45 = (__int16)(v20 - *(_WORD *)(v41 - 48));
    v46 = (__int16)(((v43 >> 18) * (v43 >> 18)) >> 2) * v45;
    *(_WORD *)((char *)&v145[3] + v13 + 4) = v46 >> 10;
    v47 = (__int16)(v46 >> 10) * v45;
    if (v47 >= 11266560)
      v48 = 0;
    else
      v48 = ((-((94544 * (v47 >> 9)) & 0xFFFF0000) >> 16) & 0x3FF | 0x400) >> -((signed int)-((94544 * (v47 >> 9)) & 0xFFFF0000) >> 26);
    v49 = v24 * (v19 >> 16) * v28;
    v50 = v32 * (v27 >> 16) * v36;
    v51 = v49 + v40 * (v35 >> 16) * v44;
    v52 = v50 + v48 * (v43 >> 16) * kSpeechDataWeights[v13 / 2 + 6];
    v53 = __clz(v51 ^ (v51 >> 31)) - 1;
    v54 = __clz(v52 ^ (v52 >> 31)) - 1;
    if (!v51)
      v53 = 31;
    if (!v52)
      v54 = 31;
    v55 = v53 - v54;
    if (v16 < (int)(4 * v55))
      v15 = 1;
    v56 = (16 * v51) & 0xFFFF0000;
    if (v56 < 1)
    {
      LOWORD(v57) = 0x4000;
    }
    else
    {
      if ((v51 & 0xFFFF000) != 0)
        v57 = (int)((4 * v49) & 0xFFFFC000) / (int)HIWORD(v56);
      else
        LOWORD(v57) = -1;
      *(_WORD *)((char *)v145 + v13 + 4) = 0x4000 - v57;
    }
    v58 = kSpectrumWeight[v13 / 2];
    *(_WORD *)((char *)&v145[-1] + v13) = v57;
    v59 = (16 * v52) & 0xFFFF0000;
    if (v59 >= 1)
    {
      if ((v52 & 0xFFFF000) != 0)
        v18 = (int)((4 * v50) & 0xFFFFC000) / (int)HIWORD(v59);
      else
        LOWORD(v18) = -1;
      *(_WORD *)((char *)&v143[-1] + v13) = v18;
      *(_WORD *)((char *)v143 + v13 + 4) = 0x4000 - v18;
    }
    v14 += v55 * v58;
    v13 += 2;
  }
  while (v13 != 12);
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v63 = v15 | (v14 >= v140);
  v64 = 12800;
  v65 = 72;
  do
  {
    Minimum = WebRtcVad_FindMinimum(a1, v141[v60 / 2], v62);
    v67 = (_WORD *)(a1 + v60);
    v68 = *(_WORD *)(a1 + v60 + 180);
    v69 = kNoiseDataWeights[v60 / 2];
    v70 = kNoiseDataWeights[v60 / 2 + 6];
    v71 = 19712
        * ((int)((Minimum << 20) - ((v69 * v68 + v70 * *(__int16 *)(a1 + v60 + 192)) >> 6 << 16)) >> 16);
    v72 = (__int16)(v64 + 640);
    if (v63)
    {
      v73 = v67 + 126;
      v74 = v67[126];
      v75 = (__int16)v67[102];
      v76 = (__int16)(v68 + HIWORD(v71));
      if (v76 <= 640)
        v76 = 640;
      if (v76 >= (__int16)(v65 << 7))
        v77 = v65 << 7;
      else
        v77 = v76;
      v78 = *(__int16 *)((char *)&v143[-1] + v60);
      v79 = *(__int16 *)((char *)&v145[2] + v60);
      v80 = (__int16)(v75 + ((((6554 * (__int16)((v78 * v79) >> 11)) >> 21) + 1) >> 1));
      if (v80 <= 640)
        v80 = 640;
      if (v80 >= v72)
        v81 = v64 + 640;
      else
        v81 = v80;
      v82 = v141[v60 / 2];
      v83 = ((((__int16)(v82 - ((v75 + 4) >> 3)) * v79) >> 3) - 4096) * (v78 >> 2);
      LOWORD(v78) = 10 * v74;
      v67[90] = v77;
      v67[102] = v81;
      if (v83 > 15)
        v84 = 0x7FFFFFFF;
      else
        v84 = -2147483647;
      v85 = 24;
      v86 = 0x800000;
      if (10 * v74)
      {
        v87 = v83 >> 4;
LABEL_83:
        v84 = v87 / (__int16)v78;
      }
    }
    else
    {
      v73 = (_WORD *)(a1 + 2 * v61 + 228);
      v78 = (unsigned __int16)v67[114];
      v88 = *(__int16 *)((char *)&v145[-1] + v60);
      v89 = *(__int16 *)((char *)&v145[5] + v60);
      v90 = v68;
      v91 = (__int16)(v68 + HIWORD(v71) + ((__int16)((655 * (__int16)((v88 * v89) >> 11)) >> 16) >> 6));
      if (v91 <= 640)
        v91 = 640;
      if (v91 >= (__int16)(v65 << 7))
        LOWORD(v91) = v65 << 7;
      v67[90] = v91;
      v82 = v141[v60 / 2];
      v92 = ((((__int16)(v82 - (v90 >> 3)) * v89) >> 3) - 4096) * ((v88 + 2) >> 2);
      if (v92 >= 0x4000)
        v84 = 0x7FFFFFFF;
      else
        v84 = -2147483647;
      v85 = 22;
      v86 = 0x200000;
      if (v78)
      {
        v87 = v92 >> 14;
        v74 = v78;
        goto LABEL_83;
      }
      v74 = 0;
    }
    v93 = (__int16)(v74 + ((v86 + (v84 << 16)) >> v85));
    if (v93 <= 384)
      LOWORD(v93) = 384;
    *v73 = v93;
    v94 = (_WORD *)(a1 + v60);
    v95 = *(_WORD *)(a1 + v60 + 192);
    if (v63)
    {
      v96 = v94 + 132;
      v97 = v94[132];
      v98 = (__int16)v94[108];
      v99 = (__int16)(v95 + HIWORD(v71));
      if (v99 <= 768)
        v99 = 768;
      if (v99 >= (__int16)(9344 - ((_WORD)v62 << 7)))
        LOWORD(v99) = 9344 - ((_WORD)v62 << 7);
      v94[96] = v99;
      v100 = *(__int16 *)((char *)v143 + v60 + 4);
      v101 = *(__int16 *)((char *)&v145[3] + v60 + 4);
      v102 = (__int16)(v98 + ((((6554 * (__int16)((v100 * v101) >> 11)) >> 21) + 1) >> 1));
      if (v102 <= 768)
        v102 = 768;
      if (v102 < v72)
        LOWORD(v72) = v102;
      v94[108] = v72;
      v103 = ((((__int16)(v82 - ((v98 + 4) >> 3)) * v101) >> 3) - 4096) * (v100 >> 2);
      LOWORD(v98) = 10 * v97;
      if (v103 > 15)
        v104 = 0x7FFFFFFF;
      else
        v104 = -2147483647;
      v105 = 24;
      v106 = 0x800000;
      if (10 * v97)
      {
        v107 = v103 >> 4;
LABEL_110:
        v104 = v107 / (__int16)v98;
      }
    }
    else
    {
      v96 = (_WORD *)(a1 + 2 * (v61 + 6) + 228);
      v98 = (unsigned __int16)v94[120];
      v108 = *(__int16 *)((char *)v145 + v60 + 4);
      v109 = *(__int16 *)((char *)&v145[6] + v60 + 4);
      v110 = (__int16)(v95 + HIWORD(v71) + ((__int16)((655 * (__int16)((v108 * v109) >> 11)) >> 16) >> 6));
      if (v110 <= 768)
        v110 = 768;
      if (v110 >= (__int16)(9344 - ((_WORD)v62 << 7)))
        LOWORD(v110) = 9344 - ((_WORD)v62 << 7);
      v94[96] = v110;
      v111 = ((((__int16)(v82 - (v95 >> 3)) * v109) >> 3) - 4096) * ((v108 + 2) >> 2);
      if (v111 >= 0x4000)
        v104 = 0x7FFFFFFF;
      else
        v104 = -2147483647;
      v105 = 22;
      v106 = 0x200000;
      if (v98)
      {
        v107 = v111 >> 14;
        v97 = v98;
        goto LABEL_110;
      }
      v97 = 0;
    }
    v112 = (__int16)(v97 + ((v106 + (v104 << 16)) >> v105));
    if (v112 <= 384)
      LOWORD(v112) = 384;
    *v96 = v112;
    v113 = v67[90];
    v114 = v67[96];
    v115 = v113 * v69 + v114 * v70;
    v116 = a1 + v60;
    v117 = *(_WORD *)(a1 + v60 + 204);
    v118 = kSpeechDataWeights[v60 / 2];
    v119 = *(_WORD *)(a1 + v60 + 216);
    v120 = kSpeechDataWeights[v60 / 2 + 6];
    v121 = v118 * v117 + v120 * v119;
    v122 = (v121 >> 9) - (v115 >> 9);
    v123 = kMinimumDifference[v60 / 2];
    if (v123 > (__int16)((v121 >> 9) - (v115 >> 9)))
    {
      v124 = v123 - v122;
      v125 = (__int16)(v123 - v122);
      v126 = (13 * v125) >> 2;
      v117 += v126;
      *(_WORD *)(v116 + 204) = v117;
      v119 += v126;
      *(_WORD *)(v116 + 216) = v119;
      v121 = v117 * v118 + v119 * v120;
      v127 = (v125 + 2 * v124) >> 2;
      v113 -= v127;
      v67[90] = v113;
      v114 -= v127;
      v67[96] = v114;
      v115 = v113 * v69 + v114 * v70;
    }
    v64 = kMaximumSpeech[v60 / 2];
    v128 = v121 << 9;
    if (v64 >= (__int16)(v121 >> 7))
    {
      v129 = v115 << 9;
      v130 = kMaximumNoise[v60 / 2];
      if (v130 >= (__int16)(v115 >> 7))
        goto LABEL_57;
    }
    else
    {
      *(_WORD *)(v116 + 204) = v64 - HIWORD(v128) + v117;
      *(_WORD *)(a1 + v60 + 216) = v64 - HIWORD(v128) + v119;
      v129 = v115 << 9;
      v130 = kMaximumNoise[v60 / 2];
      if (v130 >= (__int16)(v115 >> 7))
        goto LABEL_57;
    }
    v131 = (unsigned __int16)v130 - HIWORD(v129);
    v67[90] = v131 + v113;
    v94[96] = v131 + v114;
LABEL_57:
    ++v61;
    ++v62;
    v60 += 2;
    --v65;
  }
  while (v60 != 12);
  ++*(_DWORD *)(a1 + 276);
  if (v63)
  {
    v132 = (__int16)++*(_WORD *)(a1 + 282);
    if (v132 < 7)
    {
      v133 = v138;
    }
    else
    {
      *(_WORD *)(a1 + 282) = 6;
      v133 = v139;
    }
    *(_WORD *)(a1 + 280) = v133;
    v136 = 1;
    goto LABEL_130;
  }
LABEL_124:
  v134 = *(__int16 *)(a1 + 280);
  v135 = v134 - 1;
  if (v134 < 1)
  {
    v136 = 0;
  }
  else
  {
    v136 = v134 + 2;
    *(_WORD *)(a1 + 280) = v135;
  }
  *(_WORD *)(a1 + 282) = 0;
LABEL_130:
  result = v136;
  *(_DWORD *)a1 = result;
  return result;
}

uint64_t WebRtcVad_CalcVad32khz(_DWORD *a1, __int16 *a2, unint64_t a3)
{
  unint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  _WORD *v9;
  int v10;
  unsigned int v11;
  int v12;
  __int16 v13;
  _WORD *v14;
  __int16 *v15;
  unint64_t v16;
  int v17;
  unsigned int v18;
  int v19;
  __int16 v20;
  _BYTE v22[480];
  _BYTE v23[960];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (a3 > 1)
  {
    v6 = a1[3];
    v7 = a1[4];
    v8 = a3 >> 1;
    v9 = v23;
    do
    {
      v10 = *a2;
      v11 = ((5243 * v10) >> 14) + (v6 >> 1);
      v6 = v10 - ((5243 * (__int16)(((5243 * v10) >> 14) + (v6 >> 1))) >> 12);
      v12 = a2[1];
      v13 = ((1392 * v12) >> 14) + (v7 >> 1);
      *v9++ = v13 + v11;
      v7 = v12 - ((1392 * v13) >> 12);
      a2 += 2;
      --v8;
    }
    while (v8);
    a1[3] = v6;
    a1[4] = v7;
    v4 = a1[1];
    v5 = a1[2];
    if (a3 >= 4)
    {
      v3 = a3 >> 2;
      v14 = v22;
      v15 = (__int16 *)v23;
      v16 = v3;
      do
      {
        v17 = *v15;
        v18 = ((5243 * v17) >> 14) + (v4 >> 1);
        v4 = v17 - ((5243 * (__int16)(((5243 * v17) >> 14) + (v4 >> 1))) >> 12);
        v19 = v15[1];
        v20 = ((1392 * v19) >> 14) + (v5 >> 1);
        *v14++ = v20 + v18;
        v5 = v19 - ((1392 * v20) >> 12);
        v15 += 2;
        --v16;
      }
      while (v16);
    }
    else
    {
      v3 = 0;
    }
  }
  else
  {
    v3 = 0;
    v4 = a1[1];
    v5 = a1[2];
  }
  a1[1] = v4;
  a1[2] = v5;
  return WebRtcVad_CalcVad8khz((uint64_t)a1, (uint64_t)v22, v3);
}

uint64_t WebRtcVad_CalculateFeatures(unsigned __int16 *a1, uint64_t a2, unint64_t a3, __int16 *a4)
{
  uint64_t v4;
  int v5;
  unint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  int v13;
  unint64_t v14;
  uint64_t v15;
  __int16 *v16;
  __int16 *v17;
  uint64_t v18;
  int16x8_t *v19;
  int16x8_t *v20;
  uint64_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  unint64_t v27;
  __int16 v28;
  __int16 v29;
  unint64_t v30;
  __int16 v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  BOOL v35;
  int v36;
  unsigned int v38;
  uint64_t v39;
  unsigned int v40;
  _BYTE *v41;
  unint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  int v48;
  int v49;
  int v50;
  unint64_t v51;
  uint64_t v52;
  __int16 *v53;
  _BYTE *v54;
  int16x8_t *v55;
  int32x4_t v56;
  uint32x4_t v57;
  uint64_t v58;
  int32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  int16x8_t v62;
  int16x8_t v63;
  unint64_t v64;
  int v65;
  unsigned int v66;
  char v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  __int16 v72;
  int v73;
  __int16 v74;
  __int16 *v75;
  unint64_t v76;
  int16x8_t *v77;
  int16x8_t v78;
  uint64_t v79;
  int16x8_t v80;
  int v81;
  int v82;
  unsigned int v83;
  signed int v84;
  uint64_t v86;
  unsigned int v87;
  __int16 *v88;
  int16x8_t *v89;
  int32x4_t v90;
  uint32x4_t v91;
  uint64_t v92;
  int32x4_t v93;
  int32x4_t v94;
  int32x4_t v95;
  int16x8_t v96;
  int16x8_t v97;
  unint64_t v98;
  int v99;
  unsigned int v100;
  char v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  unsigned int v105;
  __int16 v106;
  uint64_t v107;
  int v108;
  __int16 *v109;
  int v110;
  int v111;
  uint64_t v112;
  __int16 *v113;
  int v114;
  int v115;
  int v116;
  unint64_t v117;
  uint64_t v118;
  __int16 *v119;
  _BYTE *v120;
  uint64_t v121;
  int16x8_t *v122;
  int16x8_t *v123;
  uint64_t v124;
  int16x8_t v125;
  int16x8_t v126;
  int16x8_t v127;
  int16x8_t v128;
  int16x8_t v129;
  unint64_t v130;
  __int16 v131;
  __int16 v132;
  __int16 v133;
  unsigned int v134;
  signed int v135;
  uint64_t v137;
  unsigned int v138;
  _BYTE *v139;
  _BYTE *v140;
  unint64_t v141;
  int16x8_t *v142;
  int32x4_t v143;
  uint32x4_t v144;
  uint64_t v145;
  int32x4_t v146;
  int32x4_t v147;
  int32x4_t v148;
  int16x8_t v149;
  int16x8_t v150;
  unint64_t v151;
  int v152;
  unsigned int v153;
  char v154;
  unsigned int v155;
  unsigned int v156;
  unsigned int v157;
  __int16 v158;
  unint64_t v159;
  unint64_t v160;
  int v161;
  uint64_t v162;
  int v163;
  int v164;
  unint64_t v165;
  int v166;
  int v167;
  int v168;
  unint64_t v169;
  uint64_t v170;
  __int16 *v171;
  __int16 *v172;
  __int16 v173;
  uint64_t v174;
  int16x8_t *v175;
  int16x8_t *v176;
  uint64_t v177;
  int16x8_t v178;
  int16x8_t v179;
  int16x8_t v180;
  int16x8_t v181;
  int16x8_t v182;
  unint64_t v183;
  __int16 v184;
  __int16 v185;
  __int16 *v186;
  uint64_t v187;
  int16x8_t *v188;
  int16x8_t v189;
  uint64_t v190;
  int16x8_t v191;
  int v192;
  int v193;
  unsigned int v194;
  unsigned int v195;
  signed int v196;
  uint64_t v198;
  unsigned int v199;
  __int16 *v200;
  int16x8_t *v201;
  int32x4_t v202;
  uint32x4_t v203;
  uint64_t v204;
  int32x4_t v205;
  int32x4_t v206;
  int32x4_t v207;
  int16x8_t v208;
  int16x8_t v209;
  unint64_t v210;
  int v211;
  unsigned int v212;
  unsigned int v213;
  unsigned int v214;
  unsigned int v215;
  unsigned int v216;
  __int16 v217;
  unint64_t v218;
  uint64_t v219;
  unint64_t v220;
  int v221;
  int v222;
  int v223;
  unint64_t v224;
  int v225;
  int v226;
  int v227;
  unint64_t v228;
  uint64_t v229;
  __int16 *v230;
  _BYTE *v231;
  __int16 v232;
  uint64_t v233;
  int16x8_t *v234;
  int16x8_t *v235;
  uint64_t v236;
  int16x8_t v237;
  int16x8_t v238;
  int16x8_t v239;
  int16x8_t v240;
  int16x8_t v241;
  unint64_t v242;
  __int16 v243;
  __int16 v244;
  _BYTE *v245;
  unint64_t v246;
  int16x8_t *v247;
  int16x8_t v248;
  uint64_t v249;
  int16x8_t v250;
  int v251;
  int v252;
  unsigned int v253;
  unsigned int v254;
  signed int v255;
  uint64_t v257;
  unsigned int v258;
  _BYTE *v259;
  int16x8_t *v260;
  int32x4_t v261;
  uint32x4_t v262;
  uint64_t v263;
  int32x4_t v264;
  int32x4_t v265;
  int32x4_t v266;
  int16x8_t v267;
  int16x8_t v268;
  unint64_t v269;
  int v270;
  unsigned int v271;
  char v272;
  unsigned int v273;
  unsigned int v274;
  unsigned int v275;
  unsigned int v276;
  __int16 v277;
  unint64_t v278;
  signed __int16 v279;
  signed __int16 v280;
  unsigned int v281;
  signed __int16 v282;
  signed __int16 v283;
  unsigned __int16 v284;
  __int16 v285;
  __int16 *v286;
  unint64_t v287;
  int16x8_t *v288;
  int16x8_t v289;
  uint64_t v290;
  int16x8_t v291;
  int v292;
  int v293;
  unsigned int v294;
  signed int v295;
  uint64_t v297;
  unsigned int v298;
  __int16 *v299;
  int16x8_t *v300;
  int32x4_t v301;
  uint32x4_t v302;
  uint64_t v303;
  int32x4_t v304;
  int32x4_t v305;
  int32x4_t v306;
  int16x8_t v307;
  int16x8_t v308;
  unint64_t v309;
  int v310;
  unsigned int v311;
  unsigned int v312;
  unsigned int v313;
  unsigned int v314;
  unsigned int v315;
  __int16 v316;
  uint64_t v318;
  int16x8_t *v319;
  int16x8_t *v320;
  uint64_t v321;
  int16x8_t v322;
  int16x8_t v323;
  int16x8_t v324;
  int16x8_t v325;
  int16x8_t v326;
  unint64_t v327;
  __int16 v328;
  __int16 v329;
  _BYTE *v330;
  int16x8_t *v331;
  int16x8_t v332;
  uint64_t v333;
  int16x8_t v334;
  int v335;
  int v336;
  int16x8_t *v337;
  int16x8_t v338;
  uint64_t v339;
  int16x8_t v340;
  int v341;
  int v342;
  __int16 v343[8];
  _BYTE v344[104];
  _WORD v345[8];
  _BYTE v346[104];
  __int16 v347[1];
  _WORD v348[7];
  _BYTE v349[224];
  __int16 v350[8];
  _QWORD v351[29];

  v351[28] = *MEMORY[0x24BDAC8D0];
  if (a3 < 2)
    goto LABEL_17;
  v4 = 0;
  v5 = a1[340] << 16;
  v6 = a3 >> 1;
  do
  {
    v7 = *(__int16 *)(a2 + 1 * v4);
    v8 = v5 + 20972 * v7;
    v350[v4] = HIWORD(v8);
    v5 = -41944 * (v8 >> 16) + (v7 << 15);
    ++v4;
    --v6;
  }
  while (v6);
  v9 = 0;
  v10 = a1[345] << 16;
  a1[340] = HIWORD(v5);
  v11 = a3 >> 1;
  do
  {
    v12 = *(__int16 *)(a2 + 2 + 1 * v9);
    v13 = v10 + 5571 * v12;
    v347[v9] = HIWORD(v13);
    v10 = -11142 * (v13 >> 16) + (v12 << 15);
    ++v9;
    --v11;
  }
  while (v11);
  a1[345] = HIWORD(v10);
  if (a3 >> 1 <= 1)
    v14 = 1;
  else
    v14 = a3 >> 1;
  if (v14 < 0x10)
  {
    v15 = 0;
    v16 = v347;
    v17 = v350;
LABEL_14:
    v27 = v14 - v15;
    do
    {
      v28 = *v17;
      v29 = *v16;
      *v17++ -= *v16;
      *v16++ = v29 + v28;
      --v27;
    }
    while (v27);
    goto LABEL_16;
  }
  v15 = v14 & 0x7FFFFFFFFFFFFFF0;
  v18 = v14 & 0x7FFFFFFFFFFFFFF0;
  v16 = &v347[v18];
  v17 = &v350[v18];
  v19 = (int16x8_t *)v351;
  v20 = (int16x8_t *)v349;
  v21 = v14 & 0x7FFFFFFFFFFFFFF0;
  do
  {
    v22 = v19[-1];
    v23 = *v19;
    v24 = v20[-1];
    v25 = *v20;
    v26 = vsubq_s16(*v19, *v20);
    v19[-1] = vsubq_s16(v22, v24);
    *v19 = v26;
    v20[-1] = vaddq_s16(v24, v22);
    *v20 = vaddq_s16(v25, v23);
    v19 += 2;
    v20 += 2;
    v21 -= 16;
  }
  while (v21);
  if (v14 != v15)
    goto LABEL_14;
LABEL_16:
  if (a3 < 4)
  {
LABEL_17:
    v30 = 0;
    v31 = -1;
    LOBYTE(v32) = 1;
    goto LABEL_18;
  }
  v42 = 0;
  v30 = a3 >> 2;
  v43 = a1[341] << 16;
  v44 = 2 * (a3 >> 2);
  do
  {
    v45 = v350[v42];
    v46 = v43 + 20972 * v45;
    v345[v42 / 2] = HIWORD(v46);
    v43 = -41944 * (v46 >> 16) + (v45 << 15);
    v42 += 2;
  }
  while (v44 != v42);
  v47 = 0;
  a1[341] = HIWORD(v43);
  v48 = a1[346] << 16;
  do
  {
    v49 = v350[v47 + 1];
    v50 = v48 + 5571 * v49;
    v343[v47 / 2] = HIWORD(v50);
    v48 = -11142 * (v50 >> 16) + (v49 << 15);
    v47 += 2;
  }
  while (v44 != v47);
  a1[346] = HIWORD(v48);
  if (v30 <= 1)
    v51 = 1;
  else
    v51 = a3 >> 2;
  if (v51 < 0x10)
  {
    v52 = 0;
    v53 = v343;
    v54 = v345;
LABEL_278:
    v327 = v51 - v52;
    do
    {
      v328 = *(_WORD *)v54;
      v329 = *v53;
      *(_WORD *)v54 -= *v53;
      v54 += 2;
      *v53++ = v329 + v328;
      --v327;
    }
    while (v327);
    goto LABEL_280;
  }
  v52 = v51 & 0x3FFFFFFFFFFFFFF0;
  v318 = v51 & 0x3FFFFFFFFFFFFFF0;
  v53 = &v343[v318];
  v54 = &v345[v318];
  v319 = (int16x8_t *)v346;
  v320 = (int16x8_t *)v344;
  v321 = v51 & 0x3FFFFFFFFFFFFFF0;
  do
  {
    v322 = v319[-1];
    v323 = *v319;
    v324 = v320[-1];
    v325 = *v320;
    v326 = vsubq_s16(*v319, *v320);
    v319[-1] = vsubq_s16(v322, v324);
    *v319 = v326;
    v320[-1] = vaddq_s16(v324, v322);
    *v320 = vaddq_s16(v325, v323);
    v319 += 2;
    v320 += 2;
    v321 -= 16;
  }
  while (v321);
  if (v51 != v52)
    goto LABEL_278;
LABEL_280:
  if (a3 >= 0x40)
  {
    v330 = &v345[v30 & 0x3FFFFFFFFFFFFFF0];
    v32 = (a3 >> 2) & 0xF;
    v337 = (int16x8_t *)v346;
    v338.i64[0] = -1;
    v338.i64[1] = -1;
    v339 = v30 & 0x3FFFFFFFFFFFFFF0;
    v340.i64[0] = -1;
    v340.i64[1] = -1;
    do
    {
      v338 = vmaxq_s16(vabsq_s16(v337[-1]), v338);
      v340 = vmaxq_s16(vabsq_s16(*v337), v340);
      v337 += 2;
      v339 -= 16;
    }
    while (v339);
    v31 = vmaxvq_s16(vmaxq_s16(v338, v340));
    if (v30 == (v30 & 0x3FFFFFFFFFFFFFF0))
    {
      LOBYTE(v32) = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v31 = -1;
    v330 = v345;
    v32 = a3 >> 2;
  }
  do
  {
    v342 = *(__int16 *)v330;
    v330 += 2;
    v341 = v342;
    if (v342 < 0)
      v341 = -v341;
    if ((__int16)v341 > v31)
      v31 = v341;
    --v32;
  }
  while (v32);
LABEL_18:
  v33 = 32 - __clz(v30);
  v34 = __clz(v31 * v31) - 1;
  if (!v31)
    v34 = 0;
  v35 = __OFSUB__(v33, v34);
  v36 = v33 - v34;
  if (v36 < 0 != v35 || v31 == 0)
    v38 = 0;
  else
    v38 = v36;
  if ((v32 & 1) != 0)
  {
LABEL_53:
    v73 = 0;
    a4[5] = 176;
    if ((v32 & 1) != 0)
      goto LABEL_54;
    goto LABEL_51;
  }
  if (v30 < 0x10)
  {
    v39 = 0;
    v40 = 0;
    v41 = v345;
LABEL_41:
    v64 = v30 - v39;
    do
    {
      v65 = *(__int16 *)v41;
      v41 += 2;
      v40 += (v65 * v65) >> v38;
      --v64;
    }
    while (v64);
    goto LABEL_43;
  }
  v39 = v30 & 0x3FFFFFFFFFFFFFF0;
  v41 = &v345[v30 & 0x3FFFFFFFFFFFFFF0];
  v55 = (int16x8_t *)v346;
  v56 = 0uLL;
  v57 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v38));
  v58 = v30 & 0x3FFFFFFFFFFFFFF0;
  v59 = 0uLL;
  v60 = 0uLL;
  v61 = 0uLL;
  do
  {
    v62 = v55[-1];
    v63 = *v55;
    v59 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v62, v62), v57), v59);
    v56 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v62.i8, *(int16x4_t *)v62.i8), v57), v56);
    v61 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v63, v63), v57), v61);
    v60 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v63.i8, *(int16x4_t *)v63.i8), v57), v60);
    v55 += 2;
    v58 -= 16;
  }
  while (v58);
  v40 = vaddvq_s32(vaddq_s32(vaddq_s32(v60, v56), vaddq_s32(v61, v59)));
  if (v30 != v39)
    goto LABEL_41;
LABEL_43:
  if (!v40)
    goto LABEL_53;
  v66 = __clz(v40);
  v67 = 17 - v66;
  v68 = 17 - v66 + v38;
  v69 = v40 << (v66 - 17);
  v70 = v40 >> v67;
  if (v40 >= 0x4000)
    v69 = v70;
  v71 = ((24660 * ((v69 >> 4) & 0x3FF) + 353525760) >> 19) + ((24660 * v68) >> 9);
  if ((v71 & 0x8000) != 0)
    v72 = 176;
  else
    v72 = v71 + 176;
  a4[5] = v72;
  if ((v68 & 0x80000000) == 0)
  {
    v73 = 11;
    if ((v32 & 1) == 0)
      goto LABEL_51;
LABEL_54:
    v74 = -1;
    goto LABEL_63;
  }
  v73 = v69 >> -(char)v68;
  if ((v32 & 1) != 0)
    goto LABEL_54;
LABEL_51:
  if (v30 >= 0x10)
  {
    v75 = &v343[v30 & 0x3FFFFFFFFFFFFFF0];
    v76 = v30 & 0xF;
    v77 = (int16x8_t *)v344;
    v78.i64[0] = -1;
    v78.i64[1] = -1;
    v79 = v30 & 0x3FFFFFFFFFFFFFF0;
    v80.i64[0] = -1;
    v80.i64[1] = -1;
    do
    {
      v78 = vmaxq_s16(vabsq_s16(v77[-1]), v78);
      v80 = vmaxq_s16(vabsq_s16(*v77), v80);
      v77 += 2;
      v79 -= 16;
    }
    while (v79);
    v74 = vmaxvq_s16(vmaxq_s16(v78, v80));
    if (v30 == (v30 & 0x3FFFFFFFFFFFFFF0))
      goto LABEL_63;
  }
  else
  {
    v74 = -1;
    v75 = v343;
    v76 = v30;
  }
  do
  {
    v82 = *v75++;
    v81 = v82;
    if (v82 < 0)
      v81 = -v81;
    if ((__int16)v81 > v74)
      v74 = v81;
    --v76;
  }
  while (v76);
LABEL_63:
  v83 = __clz(v74 * v74) - 1;
  if (!v74)
    v83 = 0;
  v35 = __OFSUB__(v33, v83);
  v84 = v33 - v83;
  if (v84 < 0 != v35 || v74 == 0)
    v84 = 0;
  if ((v32 & 1) != 0)
    goto LABEL_88;
  if (v30 < 0x10)
  {
    v86 = 0;
    v87 = 0;
    v88 = v343;
LABEL_76:
    v98 = v30 - v86;
    do
    {
      v99 = *v88++;
      v87 += (v99 * v99) >> v84;
      --v98;
    }
    while (v98);
    goto LABEL_78;
  }
  v86 = v30 & 0x3FFFFFFFFFFFFFF0;
  v88 = &v343[v30 & 0x3FFFFFFFFFFFFFF0];
  v89 = (int16x8_t *)v344;
  v90 = 0uLL;
  v91 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v84));
  v92 = v30 & 0x3FFFFFFFFFFFFFF0;
  v93 = 0uLL;
  v94 = 0uLL;
  v95 = 0uLL;
  do
  {
    v96 = v89[-1];
    v97 = *v89;
    v93 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v96, v96), v91), v93);
    v90 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v96.i8, *(int16x4_t *)v96.i8), v91), v90);
    v95 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v97, v97), v91), v95);
    v94 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v97.i8, *(int16x4_t *)v97.i8), v91), v94);
    v89 += 2;
    v92 -= 16;
  }
  while (v92);
  v87 = vaddvq_s32(vaddq_s32(vaddq_s32(v94, v90), vaddq_s32(v95, v93)));
  if (v30 != v86)
    goto LABEL_76;
LABEL_78:
  if (!v87)
  {
LABEL_88:
    a4[4] = 176;
    goto LABEL_89;
  }
  v100 = __clz(v87);
  v101 = 17 - v100;
  v102 = 17 - v100 + v84;
  v103 = v87 << (v100 - 17);
  v104 = v87 >> v101;
  if (v87 >= 0x4000)
    v103 = v104;
  v105 = ((24660 * ((v103 >> 4) & 0x3FF) + 353525760) >> 19) + ((24660 * v102) >> 9);
  if ((v105 & 0x8000) != 0)
    v106 = 176;
  else
    v106 = v105 + 176;
  a4[4] = v106;
  if ((__int16)v73 >= 11)
  {
LABEL_89:
    if ((v32 & 1) != 0)
      goto LABEL_105;
    goto LABEL_90;
  }
  if ((v102 & 0x80000000) == 0)
  {
    v73 += 11;
    if ((v32 & 1) == 0)
      goto LABEL_90;
LABEL_105:
    v133 = -1;
    goto LABEL_106;
  }
  v73 += v103 >> -(char)v102;
  if ((v32 & 1) != 0)
    goto LABEL_105;
LABEL_90:
  v107 = 0;
  v108 = a1[342] << 16;
  v109 = v347;
  do
  {
    v110 = *v109;
    v109 += 2;
    v111 = v108 + 20972 * v110;
    v345[v107] = HIWORD(v111);
    v108 = -41944 * (v111 >> 16) + (v110 << 15);
    ++v107;
  }
  while (v30 != v107);
  v112 = 0;
  a1[342] = HIWORD(v108);
  v113 = v348;
  v114 = a1[347] << 16;
  do
  {
    v115 = *v113;
    v113 += 2;
    v116 = v114 + 5571 * v115;
    v343[v112] = HIWORD(v116);
    v114 = -11142 * (v116 >> 16) + (v115 << 15);
    ++v112;
  }
  while (v30 != v112);
  a1[347] = HIWORD(v114);
  if (v30 <= 1)
    v117 = 1;
  else
    v117 = v30;
  if (v117 < 0x10)
  {
    v118 = 0;
    v119 = v343;
    v120 = v345;
LABEL_102:
    v130 = v117 - v118;
    do
    {
      v131 = *(_WORD *)v120;
      v132 = *v119;
      *(_WORD *)v120 -= *v119;
      v120 += 2;
      *v119++ = v132 + v131;
      --v130;
    }
    while (v130);
    goto LABEL_104;
  }
  v118 = v117 & 0x3FFFFFFFFFFFFFF0;
  v121 = v117 & 0x3FFFFFFFFFFFFFF0;
  v119 = &v343[v121];
  v120 = &v345[v121];
  v122 = (int16x8_t *)v346;
  v123 = (int16x8_t *)v344;
  v124 = v117 & 0x3FFFFFFFFFFFFFF0;
  do
  {
    v125 = v122[-1];
    v126 = *v122;
    v127 = v123[-1];
    v128 = *v123;
    v129 = vsubq_s16(*v122, *v123);
    v122[-1] = vsubq_s16(v125, v127);
    *v122 = v129;
    v123[-1] = vaddq_s16(v127, v125);
    *v123 = vaddq_s16(v128, v126);
    v122 += 2;
    v123 += 2;
    v124 -= 16;
  }
  while (v124);
  if (v117 != v118)
    goto LABEL_102;
LABEL_104:
  if ((v32 & 1) != 0)
    goto LABEL_105;
  if (v30 >= 0x10)
  {
    v140 = &v345[v30 & 0x3FFFFFFFFFFFFFF0];
    v141 = v30 & 0xF;
    v331 = (int16x8_t *)v346;
    v332.i64[0] = -1;
    v332.i64[1] = -1;
    v333 = v30 & 0x3FFFFFFFFFFFFFF0;
    v334.i64[0] = -1;
    v334.i64[1] = -1;
    do
    {
      v332 = vmaxq_s16(vabsq_s16(v331[-1]), v332);
      v334 = vmaxq_s16(vabsq_s16(*v331), v334);
      v331 += 2;
      v333 -= 16;
    }
    while (v333);
    v133 = vmaxvq_s16(vmaxq_s16(v332, v334));
    if (v30 == (v30 & 0x3FFFFFFFFFFFFFF0))
      goto LABEL_106;
  }
  else
  {
    v133 = -1;
    v140 = v345;
    v141 = v30;
  }
  do
  {
    v336 = *(__int16 *)v140;
    v140 += 2;
    v335 = v336;
    if (v336 < 0)
      v335 = -v335;
    if ((__int16)v335 > v133)
      v133 = v335;
    --v141;
  }
  while (v141);
LABEL_106:
  v134 = __clz(v133 * v133) - 1;
  if (!v133)
    v134 = 0;
  v35 = __OFSUB__(v33, v134);
  v135 = v33 - v134;
  if (v135 < 0 != v35 || v133 == 0)
    v135 = 0;
  if ((v32 & 1) != 0)
    goto LABEL_141;
  if (v30 < 0x10)
  {
    v137 = 0;
    v138 = 0;
    v139 = v345;
LABEL_121:
    v151 = v30 - v137;
    do
    {
      v152 = *(__int16 *)v139;
      v139 += 2;
      v138 += (v152 * v152) >> v135;
      --v151;
    }
    while (v151);
    goto LABEL_123;
  }
  v137 = v30 & 0x3FFFFFFFFFFFFFF0;
  v139 = &v345[v30 & 0x3FFFFFFFFFFFFFF0];
  v142 = (int16x8_t *)v346;
  v143 = 0uLL;
  v144 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v135));
  v145 = v30 & 0x3FFFFFFFFFFFFFF0;
  v146 = 0uLL;
  v147 = 0uLL;
  v148 = 0uLL;
  do
  {
    v149 = v142[-1];
    v150 = *v142;
    v146 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v149, v149), v144), v146);
    v143 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v149.i8, *(int16x4_t *)v149.i8), v144), v143);
    v148 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v150, v150), v144), v148);
    v147 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v150.i8, *(int16x4_t *)v150.i8), v144), v147);
    v142 += 2;
    v145 -= 16;
  }
  while (v145);
  v138 = vaddvq_s32(vaddq_s32(vaddq_s32(v147, v143), vaddq_s32(v148, v146)));
  if (v30 != v137)
    goto LABEL_121;
LABEL_123:
  if (!v138)
  {
LABEL_141:
    a4[3] = 176;
    goto LABEL_142;
  }
  v153 = __clz(v138);
  v154 = 17 - v153;
  v155 = 17 - v153 + v135;
  v156 = v138 << (v153 - 17);
  if (v138 >= 0x4000)
    v156 = v138 >> v154;
  v157 = ((24660 * ((v156 >> 4) & 0x3FF) + 353525760) >> 19) + ((24660 * v155) >> 9);
  if ((v157 & 0x8000) != 0)
    v158 = 176;
  else
    v158 = v157 + 176;
  a4[3] = v158;
  if ((__int16)v73 >= 11)
  {
LABEL_142:
    v159 = a3 >> 3;
    if (a3 >= 8)
      goto LABEL_132;
LABEL_143:
    v173 = -1;
    goto LABEL_159;
  }
  if ((v155 & 0x80000000) != 0)
  {
    v73 += v156 >> -(char)v155;
    v159 = a3 >> 3;
    if (a3 >= 8)
      goto LABEL_132;
    goto LABEL_143;
  }
  v73 += 11;
  v159 = a3 >> 3;
  if (a3 < 8)
    goto LABEL_143;
LABEL_132:
  v160 = 0;
  v161 = a1[343] << 16;
  v162 = 2 * v159;
  do
  {
    v163 = v343[v160];
    v164 = v161 + 20972 * v163;
    v350[v160 / 2] = HIWORD(v164);
    v161 = -41944 * (v164 >> 16) + (v163 << 15);
    v160 += 2;
  }
  while (v162 != v160);
  v165 = 0;
  a1[343] = HIWORD(v161);
  v166 = a1[348] << 16;
  do
  {
    v167 = v343[v165 + 1];
    v168 = v166 + 5571 * v167;
    v347[v165 / 2] = HIWORD(v168);
    v166 = -11142 * (v168 >> 16) + (v167 << 15);
    v165 += 2;
  }
  while (v162 != v165);
  a1[348] = HIWORD(v166);
  if (v159 <= 1)
    v169 = 1;
  else
    v169 = v159;
  if (v169 < 0x10)
  {
    v170 = 0;
    v171 = v347;
    v172 = v350;
LABEL_147:
    v183 = v169 - v170;
    do
    {
      v184 = *v172;
      v185 = *v171;
      *v172++ -= *v171;
      *v171++ = v185 + v184;
      --v183;
    }
    while (v183);
    goto LABEL_149;
  }
  v170 = v169 & 0x1FFFFFFFFFFFFFF0;
  v174 = v169 & 0x1FFFFFFFFFFFFFF0;
  v171 = &v347[v174];
  v172 = &v350[v174];
  v175 = (int16x8_t *)v351;
  v176 = (int16x8_t *)v349;
  v177 = v169 & 0x1FFFFFFFFFFFFFF0;
  do
  {
    v178 = v175[-1];
    v179 = *v175;
    v180 = v176[-1];
    v181 = *v176;
    v182 = vsubq_s16(*v175, *v176);
    v175[-1] = vsubq_s16(v178, v180);
    *v175 = v182;
    v176[-1] = vaddq_s16(v180, v178);
    *v176 = vaddq_s16(v181, v179);
    v175 += 2;
    v176 += 2;
    v177 -= 16;
  }
  while (v177);
  if (v169 != v170)
    goto LABEL_147;
LABEL_149:
  if (a3 >= 0x80)
  {
    v186 = &v350[v159 & 0x1FFFFFFFFFFFFFF0];
    v187 = (a3 >> 3) & 0xF;
    v188 = (int16x8_t *)v351;
    v189.i64[0] = -1;
    v189.i64[1] = -1;
    v190 = v159 & 0x1FFFFFFFFFFFFFF0;
    v191.i64[0] = -1;
    v191.i64[1] = -1;
    do
    {
      v189 = vmaxq_s16(vabsq_s16(v188[-1]), v189);
      v191 = vmaxq_s16(vabsq_s16(*v188), v191);
      v188 += 2;
      v190 -= 16;
    }
    while (v190);
    v173 = vmaxvq_s16(vmaxq_s16(v189, v191));
    if (v159 == (v159 & 0x1FFFFFFFFFFFFFF0))
      goto LABEL_159;
  }
  else
  {
    v173 = -1;
    v186 = v350;
    v187 = v159;
  }
  do
  {
    v193 = *v186++;
    v192 = v193;
    if (v193 < 0)
      v192 = -v192;
    if ((__int16)v192 > v173)
      v173 = v192;
    --v187;
  }
  while (v187);
LABEL_159:
  v194 = 32 - __clz(v159);
  v195 = __clz(v173 * v173) - 1;
  if (!v173)
    v195 = 0;
  v35 = __OFSUB__(v194, v195);
  v196 = v194 - v195;
  if (v196 < 0 != v35 || v173 == 0)
    v196 = 0;
  if (a3 < 8)
    goto LABEL_192;
  if (a3 < 0x80)
  {
    v198 = 0;
    v199 = 0;
    v200 = v350;
LABEL_172:
    v210 = v159 - v198;
    do
    {
      v211 = *v200++;
      v199 += (v211 * v211) >> v196;
      --v210;
    }
    while (v210);
    goto LABEL_174;
  }
  v198 = v159 & 0x1FFFFFFFFFFFFFF0;
  v200 = &v350[v159 & 0x1FFFFFFFFFFFFFF0];
  v201 = (int16x8_t *)v351;
  v202 = 0uLL;
  v203 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v196));
  v204 = v159 & 0x1FFFFFFFFFFFFFF0;
  v205 = 0uLL;
  v206 = 0uLL;
  v207 = 0uLL;
  do
  {
    v208 = v201[-1];
    v209 = *v201;
    v205 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v208, v208), v203), v205);
    v202 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v208.i8, *(int16x4_t *)v208.i8), v203), v202);
    v207 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v209, v209), v203), v207);
    v206 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v209.i8, *(int16x4_t *)v209.i8), v203), v206);
    v201 += 2;
    v204 -= 16;
  }
  while (v204);
  v199 = vaddvq_s32(vaddq_s32(vaddq_s32(v206, v202), vaddq_s32(v207, v205)));
  if (v159 != v198)
    goto LABEL_172;
LABEL_174:
  if (!v199)
  {
LABEL_192:
    a4[2] = 272;
    goto LABEL_193;
  }
  v212 = __clz(v199);
  v213 = 17 - v212 + v196;
  v214 = v199 << (v212 - 17);
  v215 = v199 >> (17 - v212);
  if (v199 >= 0x4000)
    v214 = v215;
  v216 = ((24660 * ((v214 >> 4) & 0x3FF) + 353525760) >> 19) + ((24660 * v213) >> 9);
  if ((v216 & 0x8000) != 0)
    v217 = 272;
  else
    v217 = v216 + 272;
  a4[2] = v217;
  if ((__int16)v73 >= 11)
  {
LABEL_193:
    v218 = a3 >> 4;
    v219 = 2 * (a3 >> 4);
    if (a3 >= 0x10)
      goto LABEL_183;
LABEL_194:
    v232 = -1;
    goto LABEL_210;
  }
  if ((v213 & 0x80000000) != 0)
  {
    v73 += v214 >> -(char)v213;
    v218 = a3 >> 4;
    v219 = 2 * (a3 >> 4);
    if (a3 >= 0x10)
      goto LABEL_183;
    goto LABEL_194;
  }
  v73 += 11;
  v218 = a3 >> 4;
  v219 = 2 * (a3 >> 4);
  if (a3 < 0x10)
    goto LABEL_194;
LABEL_183:
  v220 = 0;
  v221 = a1[344] << 16;
  do
  {
    v222 = v347[v220];
    v223 = v221 + 20972 * v222;
    v345[v220 / 2] = HIWORD(v223);
    v221 = -41944 * (v223 >> 16) + (v222 << 15);
    v220 += 2;
  }
  while (v219 != v220);
  v224 = 0;
  a1[344] = HIWORD(v221);
  v225 = a1[349] << 16;
  do
  {
    v226 = (__int16)v348[v224];
    v227 = v225 + 5571 * v226;
    v343[v224 / 2] = HIWORD(v227);
    v225 = -11142 * (v227 >> 16) + (v226 << 15);
    v224 += 2;
  }
  while (v219 != v224);
  a1[349] = HIWORD(v225);
  if (v218 <= 1)
    v228 = 1;
  else
    v228 = v218;
  if (v228 < 0x10)
  {
    v229 = 0;
    v230 = v343;
    v231 = v345;
LABEL_198:
    v242 = v228 - v229;
    do
    {
      v243 = *(_WORD *)v231;
      v244 = *v230;
      *(_WORD *)v231 -= *v230;
      v231 += 2;
      *v230++ = v244 + v243;
      --v242;
    }
    while (v242);
    goto LABEL_200;
  }
  v229 = v228 & 0xFFFFFFFFFFFFFF0;
  v233 = v228 & 0xFFFFFFFFFFFFFF0;
  v230 = &v343[v233];
  v231 = &v345[v233];
  v234 = (int16x8_t *)v346;
  v235 = (int16x8_t *)v344;
  v236 = v228 & 0xFFFFFFFFFFFFFF0;
  do
  {
    v237 = v234[-1];
    v238 = *v234;
    v239 = v235[-1];
    v240 = *v235;
    v241 = vsubq_s16(*v234, *v235);
    v234[-1] = vsubq_s16(v237, v239);
    *v234 = v241;
    v235[-1] = vaddq_s16(v239, v237);
    *v235 = vaddq_s16(v240, v238);
    v234 += 2;
    v235 += 2;
    v236 -= 16;
  }
  while (v236);
  if (v228 != v229)
    goto LABEL_198;
LABEL_200:
  if (a3 >= 0x100)
  {
    v245 = &v345[v218 & 0xFFFFFFFFFFFFFF0];
    v246 = a3 >> 4;
    v247 = (int16x8_t *)v346;
    v248.i64[0] = -1;
    v248.i64[1] = -1;
    v249 = v218 & 0xFFFFFFFFFFFFFF0;
    v250.i64[0] = -1;
    v250.i64[1] = -1;
    do
    {
      v248 = vmaxq_s16(vabsq_s16(v247[-1]), v248);
      v250 = vmaxq_s16(vabsq_s16(*v247), v250);
      v247 += 2;
      v249 -= 16;
    }
    while (v249);
    v232 = vmaxvq_s16(vmaxq_s16(v248, v250));
    if (v218 == (v218 & 0xFFFFFFFFFFFFFF0))
      goto LABEL_210;
  }
  else
  {
    v232 = -1;
    v245 = v345;
    v246 = v218;
  }
  do
  {
    v252 = *(__int16 *)v245;
    v245 += 2;
    v251 = v252;
    if (v252 < 0)
      v251 = -v251;
    if ((__int16)v251 > v232)
      v232 = v251;
    --v246;
  }
  while (v246);
LABEL_210:
  v253 = 32 - __clz(v218);
  v254 = __clz(v232 * v232) - 1;
  if (!v232)
    v254 = 0;
  v35 = __OFSUB__(v253, v254);
  v255 = v253 - v254;
  if (v255 < 0 != v35 || v232 == 0)
    v255 = 0;
  if (a3 < 0x10)
    goto LABEL_238;
  if (a3 < 0x100)
  {
    v257 = 0;
    v258 = 0;
    v259 = v345;
LABEL_223:
    v269 = v218 - v257;
    do
    {
      v270 = *(__int16 *)v259;
      v259 += 2;
      v258 += (v270 * v270) >> v255;
      --v269;
    }
    while (v269);
    goto LABEL_225;
  }
  v257 = v218 & 0xFFFFFFFFFFFFFF0;
  v259 = &v345[v218 & 0xFFFFFFFFFFFFFF0];
  v260 = (int16x8_t *)v346;
  v261 = 0uLL;
  v262 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v255));
  v263 = v218 & 0xFFFFFFFFFFFFFF0;
  v264 = 0uLL;
  v265 = 0uLL;
  v266 = 0uLL;
  do
  {
    v267 = v260[-1];
    v268 = *v260;
    v264 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v267, v267), v262), v264);
    v261 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v267.i8, *(int16x4_t *)v267.i8), v262), v261);
    v266 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v268, v268), v262), v266);
    v265 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v268.i8, *(int16x4_t *)v268.i8), v262), v265);
    v260 += 2;
    v263 -= 16;
  }
  while (v263);
  v258 = vaddvq_s32(vaddq_s32(vaddq_s32(v265, v261), vaddq_s32(v266, v264)));
  if (v218 != v257)
    goto LABEL_223;
LABEL_225:
  if (!v258)
  {
LABEL_238:
    a4[1] = 368;
    goto LABEL_239;
  }
  v271 = __clz(v258);
  v272 = 17 - v271;
  v273 = 17 - v271 + v255;
  v274 = v258 << (v271 - 17);
  v275 = v258 >> v272;
  if (v258 >= 0x4000)
    v274 = v275;
  v276 = ((24660 * ((v274 >> 4) & 0x3FF) + 353525760) >> 19) + ((24660 * v273) >> 9);
  if ((v276 & 0x8000) != 0)
    v277 = 368;
  else
    v277 = v276 + 368;
  a4[1] = v277;
  if ((__int16)v73 < 11)
  {
    if ((v273 & 0x80000000) != 0)
      v73 += v274 >> -(char)v273;
    else
      v73 += 11;
    goto LABEL_234;
  }
LABEL_239:
  if (a3 < 0x10)
  {
    v285 = -1;
    goto LABEL_249;
  }
LABEL_234:
  v278 = 0;
  v279 = a1[350];
  v280 = a1[351];
  LOWORD(v281) = a1[352];
  v282 = a1[353];
  do
  {
    v283 = v279;
    v284 = v281;
    v279 = v343[v278 / 2];
    v281 = (1073736204 * v282 + 7756 * (__int16)v281 + 1073728562 * v283 + 6631 * (v279 + v280)) >> 14;
    v350[v278 / 2] = v281;
    v278 += 2;
    v282 = v284;
    v280 = v283;
  }
  while (v219 != v278);
  a1[350] = v279;
  a1[351] = v283;
  a1[352] = v281;
  a1[353] = v284;
  if (a3 >= 0x100)
  {
    v286 = &v350[v218 & 0xFFFFFFFFFFFFFF0];
    v287 = a3 >> 4;
    v288 = (int16x8_t *)v351;
    v289.i64[0] = -1;
    v289.i64[1] = -1;
    v290 = v218 & 0xFFFFFFFFFFFFFF0;
    v291.i64[0] = -1;
    v291.i64[1] = -1;
    do
    {
      v289 = vmaxq_s16(vabsq_s16(v288[-1]), v289);
      v291 = vmaxq_s16(vabsq_s16(*v288), v291);
      v288 += 2;
      v290 -= 16;
    }
    while (v290);
    v285 = vmaxvq_s16(vmaxq_s16(v289, v291));
    if (v218 == (v218 & 0xFFFFFFFFFFFFFF0))
      goto LABEL_249;
  }
  else
  {
    v285 = -1;
    v286 = v350;
    v287 = v218;
  }
  do
  {
    v293 = *v286++;
    v292 = v293;
    if (v293 < 0)
      v292 = -v292;
    if ((__int16)v292 > v285)
      v285 = v292;
    --v287;
  }
  while (v287);
LABEL_249:
  v294 = __clz(v285 * v285) - 1;
  if (!v285)
    v294 = 0;
  v35 = __OFSUB__(v253, v294);
  v295 = v253 - v294;
  if (v295 < 0 != v35 || v285 == 0)
    v295 = 0;
  if (a3 < 0x10)
    goto LABEL_273;
  if (a3 < 0x100)
  {
    v297 = 0;
    v298 = 0;
    v299 = v350;
LABEL_262:
    v309 = v218 - v297;
    do
    {
      v310 = *v299++;
      v298 += (v310 * v310) >> v295;
      --v309;
    }
    while (v309);
    goto LABEL_264;
  }
  v297 = v218 & 0xFFFFFFFFFFFFFF0;
  v299 = &v350[v218 & 0xFFFFFFFFFFFFFF0];
  v300 = (int16x8_t *)v351;
  v301 = 0uLL;
  v302 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v295));
  v303 = v218 & 0xFFFFFFFFFFFFFF0;
  v304 = 0uLL;
  v305 = 0uLL;
  v306 = 0uLL;
  do
  {
    v307 = v300[-1];
    v308 = *v300;
    v304 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v307, v307), v302), v304);
    v301 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v307.i8, *(int16x4_t *)v307.i8), v302), v301);
    v306 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_high_s16(v308, v308), v302), v306);
    v305 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmull_s16(*(int16x4_t *)v308.i8, *(int16x4_t *)v308.i8), v302), v305);
    v300 += 2;
    v303 -= 16;
  }
  while (v303);
  v298 = vaddvq_s32(vaddq_s32(vaddq_s32(v305, v301), vaddq_s32(v306, v304)));
  if (v218 != v297)
    goto LABEL_262;
LABEL_264:
  if (!v298)
  {
LABEL_273:
    *a4 = 368;
    return (__int16)v73;
  }
  v311 = __clz(v298);
  v312 = 17 - v311 + v295;
  v313 = v298 << (v311 - 17);
  v314 = v298 >> (17 - v311);
  if (v298 >= 0x4000)
    v313 = v314;
  v315 = ((24660 * ((v313 >> 4) & 0x3FF) + 353525760) >> 19) + ((24660 * v312) >> 9);
  if ((v315 & 0x8000) != 0)
    v316 = 368;
  else
    v316 = v315 + 368;
  *a4 = v316;
  if ((__int16)v73 < 11)
  {
    if ((v312 & 0x80000000) != 0)
      v73 += v313 >> -(char)v312;
    else
      LOWORD(v73) = v73 + 11;
  }
  return (__int16)v73;
}

__int16 *WebRtcVad_Downsampling(__int16 *result, _WORD *a2, unsigned int *a3, unint64_t a4)
{
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;
  __int16 v7;
  __int16 v8;

  v4 = *a3;
  v5 = a3[1];
  if (a4 >= 2)
  {
    v6 = a4 >> 1;
    do
    {
      v7 = ((5243 * *result) >> 14) + (v4 >> 1);
      *a2 = v7;
      v4 = *result - ((5243 * v7) >> 12);
      v8 = ((1392 * result[1]) >> 14) + (v5 >> 1);
      *a2++ = v8 + v7;
      v5 = result[1] - ((1392 * v8) >> 12);
      result += 2;
      --v6;
    }
    while (v6);
  }
  *a3 = v4;
  a3[1] = v5;
  return result;
}

uint64_t WebRtcVad_FindMinimum(uint64_t a1, int a2, int a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int16 *v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int16 *v14;
  _OWORD *v15;
  __int128 v16;
  _OWORD *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  _WORD *v21;
  unint64_t v22;
  _WORD *v23;
  __int16 v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;

  v3 = 0;
  v4 = 16 * a3;
  v5 = a1 + 2 * v4;
  v6 = v5 + 284;
  v7 = (__int16 *)(v5 + 476);
  v8 = v5 + 478;
  do
  {
    while (1)
    {
      v9 = *(unsigned __int16 *)(v6 + 2 * v3);
      if (v9 != 100)
        break;
      if (v3 <= 0xE)
      {
        v10 = 15 - v3;
        v11 = v3;
        if (15 - v3 < 0x10)
          goto LABEL_8;
        v12 = 2 * v3 + 2;
        v13 = *(_OWORD *)((char *)v7 + v12 + 16);
        v14 = &v7[v3];
        *(_OWORD *)v14 = *(_OWORD *)((char *)v7 + v12);
        *((_OWORD *)v14 + 1) = v13;
        v15 = (_OWORD *)(v6 + v12);
        v16 = v15[1];
        v17 = (_OWORD *)(v6 + 2 * v3);
        *v17 = *v15;
        v17[1] = v16;
        if (v10 != (v10 & 0xFFFFFFFFFFFFFFF0))
        {
          v11 = v3 + (v10 & 0xFFFFFFFFFFFFFFF0);
LABEL_8:
          v18 = 2 * v11;
          do
          {
            v19 = v8 + v18;
            *(_WORD *)(v19 - 2) = *(_WORD *)(v8 + v18);
            *(_WORD *)(v19 - 194) = *(_WORD *)(v8 + v18 - 192);
            v18 += 2;
          }
          while (v18 != 30);
        }
      }
      *(_WORD *)(v6 + 30) = 101;
      v7[15] = 10000;
      if (++v3 == 16)
        goto LABEL_12;
    }
    *(_WORD *)(v6 + 2 * v3++) = v9 + 1;
  }
  while (v3 != 16);
LABEL_12:
  if (v7[7] > a2)
  {
    if (v7[3] <= a2)
    {
      if (v7[5] <= a2)
      {
        v20 = 6;
        if (v7[6] <= a2)
          v20 = 7;
      }
      else
      {
        v20 = 4;
        if (v7[4] <= a2)
          v20 = 5;
      }
    }
    else if (v7[1] <= a2)
    {
      v20 = 2;
      if (v7[2] <= a2)
        v20 = 3;
    }
    else
    {
      v20 = *v7 <= a2;
    }
    goto LABEL_41;
  }
  if (v7[15] > a2)
  {
    if (v7[11] > a2)
    {
      if (v7[9] <= a2)
      {
        v20 = 10;
        if (v7[10] <= a2)
          v20 = 11;
      }
      else
      {
        v20 = 8;
        if (v7[8] <= a2)
          v20 = 9;
      }
      goto LABEL_41;
    }
    if (v7[13] <= a2)
    {
      if (v7[14] > a2)
      {
        v20 = 14;
        goto LABEL_41;
      }
      v20 = 15;
    }
    else
    {
      v20 = 12;
      if (v7[12] <= a2)
        v20 = 13;
LABEL_41:
      v21 = (_WORD *)(a1 + 2 * v4 + 506);
      v22 = 15;
      v23 = v21;
      do
      {
        v24 = *--v23;
        --v22;
        *v21 = v24;
        *(v21 - 96) = *(v21 - 97);
        v21 = v23;
      }
      while (v22 > v20);
    }
    v25 = v20;
    v7[v25] = a2;
    *(_WORD *)(v6 + v25 * 2) = 1;
  }
  v26 = *(_DWORD *)(a1 + 276);
  if (v26 < 3)
  {
    if (v26 > 0)
      goto LABEL_47;
    v30 = 0;
    v28 = a3;
    LOWORD(v29) = *(_WORD *)(a1 + 2 * a3 + 668);
    v27 = 1600;
  }
  else
  {
    v7 += 2;
LABEL_47:
    v27 = *v7;
    v28 = a3;
    v29 = *(__int16 *)(a1 + 2 * a3 + 668);
    if (v27 >= v29)
      v30 = 32439;
    else
      v30 = 6553;
  }
  v31 = (__int16)v29 + (__int16)v29 * v30 + (v30 ^ 0x7FFF) * v27 + 0x4000;
  *(_WORD *)(a1 + 2 * v28 + 668) = v31 >> 15;
  return (__int16)(v31 >> 15);
}

uint64_t webrtc::VoiceActivityDetectorWrapper::VoiceActivityDetectorWrapper(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  double v7;
  float32x4_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  __int16 v23;
  float32x4_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  __int16 v31;
  char v32;

  v6 = operator new();
  *(_QWORD *)v6 = &off_24C0C2F58;
  webrtc::rnn_vad::FeaturesExtractor::FeaturesExtractor(v6 + 8, (__int16 *)a2);
  webrtc::rnn_vad::FullyConnectedLayer::FullyConnectedLayer(v6 + 4392, 42, 24, (unint64_t)&rnnoise::kInputDenseBias, 0x18uLL, (unint64_t)&rnnoise::kInputDenseWeights, 0x3F0uLL, 0, v7, v8, (__int16 *)a2);
  *(_QWORD *)(v6 + 4568) = 0x1800000018;
  v23 = *(_WORD *)a2;
  *(_BYTE *)(v6 + 4650) = *(_BYTE *)(a2 + 2);
  *(_WORD *)(v6 + 4648) = v23;
  *(_OWORD *)(v6 + 4652) = 0u;
  *(_OWORD *)(v6 + 4668) = 0u;
  *(_OWORD *)(v6 + 4684) = 0u;
  *(_OWORD *)(v6 + 4700) = 0u;
  *(_OWORD *)(v6 + 4716) = 0u;
  *(_OWORD *)(v6 + 4732) = 0u;
  v32 = 0;
  v31 = 0;
  webrtc::rnn_vad::FullyConnectedLayer::FullyConnectedLayer(v6 + 4752, 24, 1, (unint64_t)&rnnoise::kOutputDenseBias, 1uLL, (unint64_t)&rnnoise::kOutputDenseWeights, 0x18uLL, 1uLL, 0.0, v24, &v31);
  v30 = v6;
  webrtc::VoiceActivityDetectorWrapper::VoiceActivityDetectorWrapper(a1, 1500, &v30, a3, v25, v26, v27, v28);
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  return a1;
}

uint64_t webrtc::VoiceActivityDetectorWrapper::VoiceActivityDetectorWrapper(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v8;
  double v9;
  float32x4_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  __int16 v25;
  float32x4_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;
  __int16 v33;
  char v34;

  v8 = operator new();
  *(_QWORD *)v8 = &off_24C0C2F58;
  webrtc::rnn_vad::FeaturesExtractor::FeaturesExtractor(v8 + 8, (__int16 *)a3);
  webrtc::rnn_vad::FullyConnectedLayer::FullyConnectedLayer(v8 + 4392, 42, 24, (unint64_t)&rnnoise::kInputDenseBias, 0x18uLL, (unint64_t)&rnnoise::kInputDenseWeights, 0x3F0uLL, 0, v9, v10, (__int16 *)a3);
  *(_QWORD *)(v8 + 4568) = 0x1800000018;
  v25 = *(_WORD *)a3;
  *(_BYTE *)(v8 + 4650) = *(_BYTE *)(a3 + 2);
  *(_WORD *)(v8 + 4648) = v25;
  *(_OWORD *)(v8 + 4652) = 0u;
  *(_OWORD *)(v8 + 4668) = 0u;
  *(_OWORD *)(v8 + 4684) = 0u;
  *(_OWORD *)(v8 + 4700) = 0u;
  *(_OWORD *)(v8 + 4716) = 0u;
  *(_OWORD *)(v8 + 4732) = 0u;
  v34 = 0;
  v33 = 0;
  webrtc::rnn_vad::FullyConnectedLayer::FullyConnectedLayer(v8 + 4752, 24, 1, (unint64_t)&rnnoise::kOutputDenseBias, 1uLL, (unint64_t)&rnnoise::kOutputDenseWeights, 0x18uLL, 1uLL, 0.0, v26, &v33);
  v32 = v8;
  webrtc::VoiceActivityDetectorWrapper::VoiceActivityDetectorWrapper(a1, a2, &v32, a4, v27, v28, v29, v30);
  if (v32)
    (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
  return a1;
}

void webrtc::VoiceActivityDetectorWrapper::VoiceActivityDetectorWrapper(uint64_t a1, int a2, uint64_t *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  std::string *v19;

  v8 = a2 / 10;
  v9 = (a2 % 10);
  if ((_DWORD)v9)
    goto LABEL_9;
  *(_DWORD *)a1 = v8;
  *(_DWORD *)(a1 + 8) = v8;
  *(_QWORD *)(a1 + 16) = &unk_24C0BAE68;
  v12 = a1 + 16;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  v13 = *a3;
  *a3 = 0;
  *(_QWORD *)(a1 + 88) = v13;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 16))(v13);
  v9 = (v14 % 100);
  if ((_DWORD)v9)
    goto LABEL_9;
  v15 = v14 / 100;
  v16 = *(_QWORD *)(a1 + 96);
  v17 = (*(_QWORD *)(a1 + 104) - v16) >> 2;
  if (v15 <= v17)
  {
    if (v15 < v17)
      *(_QWORD *)(a1 + 104) = v16 + 4 * v15;
  }
  else
  {
    std::vector<float>::__append(a1 + 96, v15 - v17);
  }
  v9 = (a4 % 100);
  if ((_DWORD)v9)
  {
LABEL_9:
    v19 = rtc::webrtc_checks_impl::FatalLog("Source/webrtc/rtc_base/checks.h", 478, "a % b == 0", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, a5, a6, a7, a8, v9);
  }
  else
  {
    *(_DWORD *)(a1 + 4) = a4 / 100;
    v18 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88));
    webrtc::PushResampler<float>::InitializeIfNeeded(v12, a4, v18, 1);
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 24))(*(_QWORD *)(a1 + 88));
  }
}

void webrtc::`anonymous namespace'::MonoVadImpl::~MonoVadImpl(webrtc::_anonymous_namespace_::MonoVadImpl *this)
{
  webrtc::rnn_vad::FeaturesExtractor *v1;

  *(_QWORD *)this = &off_24C0C2F58;
  v1 = (webrtc::_anonymous_namespace_::MonoVadImpl *)((char *)this + 8);
  webrtc::rnn_vad::RnnVad::~RnnVad((webrtc::_anonymous_namespace_::MonoVadImpl *)((char *)this + 4392));
  webrtc::rnn_vad::FeaturesExtractor::~FeaturesExtractor(v1);
}

{
  webrtc::rnn_vad::FeaturesExtractor *v1;

  *(_QWORD *)this = &off_24C0C2F58;
  v1 = (webrtc::_anonymous_namespace_::MonoVadImpl *)((char *)this + 8);
  webrtc::rnn_vad::RnnVad::~RnnVad((webrtc::_anonymous_namespace_::MonoVadImpl *)((char *)this + 4392));
  webrtc::rnn_vad::FeaturesExtractor::~FeaturesExtractor(v1);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::`anonymous namespace'::MonoVadImpl::SampleRateHz(webrtc::_anonymous_namespace_::MonoVadImpl *this)
{
  return 24000;
}

double webrtc::`anonymous namespace'::MonoVadImpl::Reset(webrtc::_anonymous_namespace_::MonoVadImpl *this)
{
  double result;

  result = 0.0;
  *(_OWORD *)((char *)this + 4732) = 0u;
  *(_OWORD *)((char *)this + 4716) = 0u;
  *(_OWORD *)((char *)this + 4700) = 0u;
  *(_OWORD *)((char *)this + 4684) = 0u;
  *(_OWORD *)((char *)this + 4668) = 0u;
  *(_OWORD *)((char *)this + 4652) = 0u;
  return result;
}

float webrtc::`anonymous namespace'::MonoVadImpl::Analyze(uint64_t a1, float *a2)
{
  uint64_t v4;
  float32x4_t *v5;
  uint64_t v6;
  float32x4_t *v7;
  float32x4_t v8[10];

  if (webrtc::rnn_vad::FeaturesExtractor::CheckSilenceComputeFeatures(a1 + 8, a2, (float32x2_t *)v8))
  {
    *(_OWORD *)(a1 + 4732) = 0u;
    *(_OWORD *)(a1 + 4716) = 0u;
    *(_OWORD *)(a1 + 4700) = 0u;
    *(_OWORD *)(a1 + 4684) = 0u;
    *(_OWORD *)(a1 + 4668) = 0u;
    *(_OWORD *)(a1 + 4652) = 0u;
    return 0.0;
  }
  else
  {
    webrtc::rnn_vad::FullyConnectedLayer::ComputeOutput(a1 + 4392, v8, 42);
    v4 = *(int *)(a1 + 4396);
    if ((_DWORD)v4)
      v5 = (float32x4_t *)(a1 + 4472);
    else
      v5 = 0;
    webrtc::rnn_vad::GatedRecurrentLayer::ComputeOutput((int *)(a1 + 4568), v5, v4);
    v6 = *(int *)(a1 + 4572);
    if ((_DWORD)v6)
      v7 = (float32x4_t *)(a1 + 4652);
    else
      v7 = 0;
    webrtc::rnn_vad::FullyConnectedLayer::ComputeOutput(a1 + 4752, v7, v6);
    return *(float *)(a1 + 4832);
  }
}

uint64_t WebRtcSpl_ScaleAndAddVectorsWithRoundC(int16x4_t *a1, unsigned int a2, int16x4_t *a3, unsigned int a4, unsigned int a5, int16x8_t *a6, unint64_t a7)
{
  uint64_t v7;
  unsigned int v8;
  unint64_t v9;
  int32x4_t v10;
  int16x4_t *v11;
  int16x4_t *v12;
  int16x8_t *v13;
  int16x8_t v14;
  int16x8_t v15;
  int32x4_t v16;
  unint64_t v17;
  int16x8_t v18;
  int32x4_t v19;
  int32x4_t v20;
  int16x8_t v21;
  unint64_t v22;
  uint64_t v23;
  __int16 *v24;
  int16x4_t *v25;
  int16x4_t *v26;
  int v27;
  int v28;
  int v29;

  v7 = 0xFFFFFFFFLL;
  if ((a5 & 0x80000000) == 0 && a1 && a3 && a6 && a7)
  {
    v8 = 1 << a5 >> 1;
    if (a7 >= 0x10)
    {
      v9 = 0;
      if ((unint64_t)((char *)a6 - (char *)a1) >= 0x20 && (unint64_t)((char *)a6 - (char *)a3) >= 0x20)
      {
        v10 = vdupq_n_s32(v8);
        v9 = a7 & 0xFFFFFFFFFFFFFFF0;
        v11 = a1 + 2;
        v12 = a3 + 2;
        v13 = a6 + 1;
        v14 = vdupq_n_s16(a2);
        v15 = vdupq_n_s16(a4);
        v16 = vnegq_s32(vdupq_n_s32(a5));
        v17 = a7 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          v18 = *(int16x8_t *)v11[-2].i8;
          v19 = vmlal_high_s16(v10, v14, v18);
          v20 = vmlal_s16(v10, *(int16x4_t *)v14.i8, *(int16x4_t *)v18.i8);
          v21 = vuzp1q_s16((int16x8_t)vshlq_s32(vmlal_s16(vmlal_s16(v10, *(int16x4_t *)v14.i8, *v11), *(int16x4_t *)v15.i8, *v12), v16), (int16x8_t)vshlq_s32(vmlal_high_s16(vmlal_high_s16(v10, v14, *(int16x8_t *)v11->i8), v15, *(int16x8_t *)v12->i8), v16));
          v13[-1] = vuzp1q_s16((int16x8_t)vshlq_s32(vmlal_s16(v20, *(int16x4_t *)v15.i8, v12[-2]), v16), (int16x8_t)vshlq_s32(vmlal_high_s16(v19, v15, *(int16x8_t *)v12[-2].i8), v16));
          *v13 = v21;
          v11 += 4;
          v12 += 4;
          v13 += 2;
          v17 -= 16;
        }
        while (v17);
        if (v9 == a7)
          return 0;
      }
    }
    else
    {
      v9 = 0;
    }
    v22 = a7 - v9;
    v23 = 2 * v9;
    v24 = &a6->i16[v9];
    v25 = (int16x4_t *)((char *)a3 + v23);
    v26 = (int16x4_t *)((char *)a1 + v23);
    do
    {
      v28 = v26->i16[0];
      v26 = (int16x4_t *)((char *)v26 + 2);
      v27 = v28;
      v29 = v25->i16[0];
      v25 = (int16x4_t *)((char *)v25 + 2);
      *v24++ = (int)(v8 + v27 * a2 + v29 * a4) >> a5;
      --v22;
    }
    while (v22);
    return 0;
  }
  return v7;
}

void webrtc::VideoAdaptationCounters::ToString(webrtc::VideoAdaptationCounters *this@<X0>, std::string *a2@<X8>)
{
  std::string *v5;
  std::string *v6;
  int v7;
  std::string::size_type v8;
  std::string::size_type size;
  std::string *v10;
  std::string::size_type v11;
  std::string::size_type v13;
  std::string *v14;
  int v15;
  std::string::size_type v16;
  std::string::size_type v17;
  std::string *v18;
  std::string::size_type v20;
  std::string v21;

  memset(&v21, 0, sizeof(v21));
  if (&v21 > (std::string *)"{ res=" || (char *)v21.__r_.__value_.__r.__words + 6 <= "{ res=")
  {
    strcpy((char *)&v21, "{ res=");
    *((_BYTE *)&v21.__r_.__value_.__s + 23) = 6;
    v5 = rtc::StringBuilder::operator<<(&v21, *(_DWORD *)this);
    v6 = v5;
    v7 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
    if (v7 >= 0)
      v8 = 22;
    else
      v8 = (v5->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v7 >= 0)
      size = HIBYTE(v5->__r_.__value_.__r.__words[2]);
    else
      size = v5->__r_.__value_.__l.__size_;
    if (v8 - size >= 5)
    {
      if (v7 >= 0)
        v10 = v5;
      else
        v10 = (std::string *)v5->__r_.__value_.__r.__words[0];
      v11 = (std::string::size_type)v10 + size;
      if ((char *)v10 + size <= " fps=" && (char *)v10->__r_.__value_.__r.__words + size + 5 > " fps=")
        goto LABEL_44;
      *(_BYTE *)(v11 + 4) = 61;
      *(_DWORD *)v11 = 1936746016;
      v13 = size + 5;
      if (SHIBYTE(v5->__r_.__value_.__r.__words[2]) < 0)
        v5->__r_.__value_.__l.__size_ = v13;
      else
        *((_BYTE *)&v5->__r_.__value_.__s + 23) = v13 & 0x7F;
      v10->__r_.__value_.__s.__data_[v13] = 0;
    }
    else
    {
      std::string::__grow_by_and_replace(v5, v8, size - v8 + 5, size, size, 0, 5uLL, " fps=");
    }
    v14 = rtc::StringBuilder::operator<<(v6, *((_DWORD *)this + 1));
    v15 = SHIBYTE(v14->__r_.__value_.__r.__words[2]);
    if (v15 >= 0)
      v16 = 22;
    else
      v16 = (v14->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v15 >= 0)
      v17 = HIBYTE(v14->__r_.__value_.__r.__words[2]);
    else
      v17 = v14->__r_.__value_.__l.__size_;
    if (v16 - v17 < 2)
    {
      std::string::__grow_by_and_replace(v14, v16, v17 - v16 + 2, v17, v17, 0, 2uLL, " }");
LABEL_43:
      *a2 = v21;
      return;
    }
    if (v15 >= 0)
      v18 = v14;
    else
      v18 = (std::string *)v14->__r_.__value_.__r.__words[0];
    if ((char *)v18 + v17 > " }" || &v18->__r_.__value_.__s.__data_[v17 + 2] <= " }")
    {
      *(_WORD *)((char *)&v18->__r_.__value_.__l.__data_ + v17) = 32032;
      v20 = v17 + 2;
      if (SHIBYTE(v14->__r_.__value_.__r.__words[2]) < 0)
        v14->__r_.__value_.__l.__size_ = v20;
      else
        *((_BYTE *)&v14->__r_.__value_.__s + 23) = v20 & 0x7F;
      v18->__r_.__value_.__s.__data_[v20] = 0;
      goto LABEL_43;
    }
  }
LABEL_44:
  __break(1u);
}

void cricket::VideoAdapter::~VideoAdapter(cricket::VideoAdapter *this)
{
  *(_QWORD *)this = &off_24C0C2F90;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 176));
}

{
  *(_QWORD *)this = &off_24C0C2F90;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 176));
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t cricket::VideoAdapter::AdaptFrameResolution(cricket::VideoAdapter *this, int a2, int a3, uint64_t a4, int *a5, int *a6, int *a7, int *a8)
{
  pthread_mutex_t *v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  char *v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  unint64_t v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  char v71;
  const char *v72;
  uint64_t v73;
  char *v74;

  v16 = (pthread_mutex_t *)((char *)this + 176);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 176));
  v17 = *((_DWORD *)this + 2) + 1;
  *((_DWORD *)this + 2) = v17;
  v18 = *((_DWORD *)this + 23);
  if (a2 <= a3)
  {
    if (*((_BYTE *)this + 68))
    {
      v19 = *(_QWORD *)((char *)this + 60);
      v20 = 1;
      if (!*((_BYTE *)this + 76))
        goto LABEL_14;
    }
    else
    {
      v20 = 0;
      v19 = 0;
      if (!*((_BYTE *)this + 76))
        goto LABEL_14;
    }
    v21 = (char *)this + 72;
  }
  else
  {
    if (*((_BYTE *)this + 48))
    {
      v19 = *((_QWORD *)this + 5);
      v20 = 1;
      if (!*((_BYTE *)this + 56))
        goto LABEL_14;
    }
    else
    {
      v20 = 0;
      v19 = 0;
      if (!*((_BYTE *)this + 56))
        goto LABEL_14;
    }
    v21 = (char *)this + 52;
  }
  v22 = *(_DWORD *)v21;
  if (v22 < v18)
    v18 = v22;
LABEL_14:
  v23 = *((_DWORD *)this + 22);
  if (v18 < v23)
    v23 = v18;
  if (v18 < 1)
    goto LABEL_28;
  v24 = *((_DWORD *)this + 24);
  if (*((_BYTE *)this + 84) && *((_DWORD *)this + 20) < v24)
    v24 = *((_DWORD *)this + 20);
  *((double *)this + 19) = (double)v24;
  if (v24 < 1)
    goto LABEL_28;
  v25 = (uint64_t)(1000000000.0 / (double)v24);
  if (v25 >= 1)
  {
    if (*((_BYTE *)this + 168))
    {
      v26 = *((_QWORD *)this + 20);
      v27 = v26 - a4 >= 0 ? v26 - a4 : a4 - v26;
      if (v27 < 2 * v25)
      {
        if (v26 - a4 > 0)
        {
LABEL_28:
          HIDWORD(v28) = -1527099483 * (v17 - *((_DWORD *)this + 3)) + 47721858;
          LODWORD(v28) = HIDWORD(v28);
          if ((v28 >> 1) > 0x2D82D82 || (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
          {
            v36 = 0;
          }
          else
          {
            rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v29, v30, v31, v32, v33, v34, v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/video_adapter.cc");
            v36 = 0;
          }
          goto LABEL_91;
        }
        *((_QWORD *)this + 20) = v26 + v25;
        if (!v20)
          goto LABEL_44;
        goto LABEL_33;
      }
    }
    *((_QWORD *)this + 20) = a4 + ((unint64_t)v25 >> 1);
    *((_BYTE *)this + 168) = 1;
  }
  if (!v20)
    goto LABEL_44;
LABEL_33:
  if ((int)v19 >= 1 && v19 > 0)
  {
    v37 = (float)(int)v19 / (float)SHIDWORD(v19);
    v38 = (int)(float)(v37 * (float)a3);
    if (v38 >= a2)
      v38 = a2;
    *a5 = v38;
    if ((int)(float)((float)a2 / v37) >= a3)
      v39 = a3;
    else
      v39 = (int)(float)((float)a2 / v37);
    *a6 = v39;
    v40 = *a5;
    v41 = *a5 * v39;
    v42 = v41 - v23;
    if (v41 > v23)
      goto LABEL_45;
    goto LABEL_41;
  }
LABEL_44:
  *a5 = a2;
  v39 = a3;
  *a6 = a3;
  v40 = *a5;
  v41 = *a5 * a3;
  v42 = v41 - v23;
  if (v41 > v23)
  {
LABEL_45:
    if (v41 > v18)
      v42 = 0x7FFFFFFF;
    v44 = (v40 % 9) | (v39 % 9);
    if ((v40 % 3) | (v39 % 3))
      v45 = 1;
    else
      v45 = 6;
    if (v44)
      v46 = v45;
    else
      v46 = 36;
    v47 = 1;
    v48 = v46;
    v49 = 1;
    do
    {
      v54 = v46 / 3;
      if (v48 & 1 | (v46 % 3))
      {
        v48 *= 4;
        v46 *= 3;
      }
      else
      {
        if (v48 >= 0)
          v55 = v48;
        else
          v55 = v48 + 1;
        v48 = v55 >> 1;
        v46 = v54;
      }
      v50 = v46 * v46 * (uint64_t)v41 / (v48 * v48);
      v51 = v23 - v50;
      if (v23 - (int)v50 < 0)
        v51 = v50 - v23;
      if (v51 < v42)
        v52 = v48;
      else
        v52 = v49;
      if (v51 < v42)
        v53 = v46;
      else
        v53 = v47;
      if (v51 >= v42)
        v51 = v42;
      if (v18 >= (int)v50)
      {
        v49 = v52;
        v47 = v53;
        v42 = v51;
      }
    }
    while (v23 < (int)v50);
    v56 = v47 % v49;
    v57 = v49;
    if (v47 % v49)
    {
      v58 = v49;
      do
      {
        v57 = v56;
        v56 = v58 % v56;
        v58 = v57;
      }
      while (v56);
    }
    v43 = (v47 / v57) | ((unint64_t)(v49 / v57) << 32);
    goto LABEL_77;
  }
LABEL_41:
  v43 = 0x100000001;
LABEL_77:
  v59 = *((_DWORD *)this + 9) * HIDWORD(v43);
  v60 = (v40 + v59 - 1) / v59 * v59;
  if (v60 > a2)
    v60 = a2 / v59 * v59;
  *a5 = v60;
  v61 = *((_DWORD *)this + 9) * HIDWORD(v43);
  v62 = (*a6 + v61 - 1) / v61 * v61;
  if (v62 > a3)
    v62 = a3 / v61 * v61;
  *a6 = v62;
  *a7 = *a5 / SHIDWORD(v43) * v43;
  *a8 = *a6 / SHIDWORD(v43) * v43;
  ++*((_DWORD *)this + 3);
  if ((_DWORD)v43 != HIDWORD(v43))
    ++*((_DWORD *)this + 4);
  v63 = *((_DWORD *)this + 6);
  if (v63)
  {
    if (v63 != *a7 || *((_DWORD *)this + 7) != *a8)
    {
      ++*((_DWORD *)this + 5);
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        v72 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/video_adapter.cc";
        v73 = 2025;
        v74 = &v71;
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, (uint64_t)" fps: ", v64, v65, v66, v67, v68, v69, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/video_adapter.cc");
      }
      v63 = *a7;
    }
  }
  else
  {
    v63 = *a7;
  }
  *((_DWORD *)this + 6) = v63;
  *((_DWORD *)this + 7) = *a8;
  v36 = 1;
LABEL_91:
  pthread_mutex_unlock(v16);
  return v36;
}

uint64_t cricket::VideoAdapter::OnOutputFormatRequest(uint64_t a1, uint64_t *a2, unsigned int *a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  pthread_mutex_t *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  std::string __p;
  _BYTE v38[13];
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v12 = (pthread_mutex_t *)(a1 + 176);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 176));
  v13 = *a2;
  v14 = HIDWORD(*a2);
  v15 = *((unsigned __int8 *)a2 + 8);
  v16 = *a3 | ((unint64_t)*((unsigned __int8 *)a3 + 4) << 32);
  v17 = *a4;
  v18 = HIDWORD(*a4);
  v19 = *((unsigned __int8 *)a4 + 8);
  *(_DWORD *)v38 = *(_DWORD *)a5;
  v38[4] = *(_BYTE *)(a5 + 4);
  *(_DWORD *)&v38[8] = *(_DWORD *)a6;
  v38[12] = *(_BYTE *)(a6 + 4);
  if (!*(_BYTE *)(a1 + 148))
  {
    if (*(unsigned __int8 *)(a1 + 48) == v15)
    {
      if (*(_BYTE *)(a1 + 48))
      {
        *(_DWORD *)(a1 + 40) = v13;
        *(_DWORD *)(a1 + 44) = v14;
        *(_DWORD *)(a1 + 52) = v16;
        *(_BYTE *)(a1 + 56) = BYTE4(v16);
        v21 = *(unsigned __int8 *)(a1 + 68);
        if (v21 != v19)
          goto LABEL_32;
LABEL_19:
        if (!v21)
          goto LABEL_34;
        *(_DWORD *)(a1 + 60) = v17;
        *(_DWORD *)(a1 + 64) = v18;
        *(_QWORD *)(a1 + 72) = *(_QWORD *)v38;
        *(_QWORD *)(a1 + 77) = *(_QWORD *)&v38[5];
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
          goto LABEL_37;
        goto LABEL_35;
      }
    }
    else
    {
      if (!*(_BYTE *)(a1 + 48))
      {
        *(_QWORD *)(a1 + 40) = v13;
        *(_BYTE *)(a1 + 48) = 1;
        *(_DWORD *)(a1 + 52) = v16;
        *(_BYTE *)(a1 + 56) = BYTE4(v16);
        v21 = *(unsigned __int8 *)(a1 + 68);
        if (v21 == v19)
          goto LABEL_19;
        goto LABEL_32;
      }
      *(_BYTE *)(a1 + 48) = 0;
    }
    *(_DWORD *)(a1 + 52) = v16;
    *(_BYTE *)(a1 + 56) = BYTE4(v16);
    v21 = *(unsigned __int8 *)(a1 + 68);
    if (v21 == v19)
      goto LABEL_19;
LABEL_32:
    if (v21)
    {
      *(_BYTE *)(a1 + 68) = 0;
LABEL_34:
      *(_QWORD *)(a1 + 72) = *(_QWORD *)v38;
      *(_QWORD *)(a1 + 77) = *(_QWORD *)&v38[5];
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
        goto LABEL_37;
      goto LABEL_35;
    }
    *(_QWORD *)(a1 + 60) = v17;
    *(_BYTE *)(a1 + 68) = 1;
    *(_QWORD *)(a1 + 72) = *(_QWORD *)v38;
    *(_QWORD *)(a1 + 77) = *(_QWORD *)&v38[5];
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
      goto LABEL_37;
LABEL_35:
    cricket::VideoAdapter::OutputFormatRequest::ToString(&__p, a1 + 40);
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v29, v30, v31, v32, v33, v34, v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/video_adapter.cc");
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_37;
    goto LABEL_36;
  }
  if (*(unsigned __int8 *)(a1 + 108) != v15)
  {
    if (!*(_BYTE *)(a1 + 108))
    {
      *(_QWORD *)(a1 + 100) = v13;
      *(_BYTE *)(a1 + 108) = 1;
      *(_DWORD *)(a1 + 112) = v16;
      *(_BYTE *)(a1 + 116) = BYTE4(v16);
      v20 = *(unsigned __int8 *)(a1 + 128);
      if (v20 == v19)
        goto LABEL_13;
LABEL_23:
      if (!v20)
      {
        *(_QWORD *)(a1 + 120) = v17;
        *(_BYTE *)(a1 + 128) = 1;
        *(_QWORD *)(a1 + 132) = *(_QWORD *)v38;
        *(_QWORD *)(a1 + 137) = *(_QWORD *)&v38[5];
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
          goto LABEL_37;
        goto LABEL_26;
      }
      *(_BYTE *)(a1 + 128) = 0;
      goto LABEL_25;
    }
    *(_BYTE *)(a1 + 108) = 0;
LABEL_12:
    *(_DWORD *)(a1 + 112) = v16;
    *(_BYTE *)(a1 + 116) = BYTE4(v16);
    v20 = *(unsigned __int8 *)(a1 + 128);
    if (v20 == v19)
      goto LABEL_13;
    goto LABEL_23;
  }
  if (!*(_BYTE *)(a1 + 108))
    goto LABEL_12;
  *(_DWORD *)(a1 + 100) = v13;
  *(_DWORD *)(a1 + 104) = v14;
  *(_DWORD *)(a1 + 112) = v16;
  *(_BYTE *)(a1 + 116) = BYTE4(v16);
  v20 = *(unsigned __int8 *)(a1 + 128);
  if (v20 != v19)
    goto LABEL_23;
LABEL_13:
  if (v20)
  {
    *(_DWORD *)(a1 + 120) = v17;
    *(_DWORD *)(a1 + 124) = v18;
    *(_QWORD *)(a1 + 132) = *(_QWORD *)v38;
    *(_QWORD *)(a1 + 137) = *(_QWORD *)&v38[5];
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
      goto LABEL_37;
    goto LABEL_26;
  }
LABEL_25:
  *(_QWORD *)(a1 + 132) = *(_QWORD *)v38;
  *(_QWORD *)(a1 + 137) = *(_QWORD *)&v38[5];
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    goto LABEL_37;
LABEL_26:
  if (!*(_BYTE *)(a1 + 148))
    __break(1u);
  cricket::VideoAdapter::OutputFormatRequest::ToString(&__p, a1 + 100);
  rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v22, v23, v24, v25, v26, v27, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/video_adapter.cc");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
LABEL_36:
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_37:
  *(_QWORD *)(a1 + 152) = 0x7FEFFFFFFFFFFFFFLL;
  if (*(_BYTE *)(a1 + 168))
    *(_BYTE *)(a1 + 168) = 0;
  return pthread_mutex_unlock(v12);
}

void cricket::VideoAdapter::OutputFormatRequest::ToString(std::string *this, uint64_t a2)
{
  int v5;
  int v6;
  BOOL v7;
  int v8;
  std::string *v9;
  std::string *v10;
  std::string::size_type v11;
  int v12;
  std::string::size_type v13;
  unsigned int v14;
  std::string::size_type v15;
  std::string::size_type v16;
  std::string *v17;
  std::string *v18;
  std::string::size_type size;
  int v20;
  std::string::size_type v21;
  std::string *v22;
  _BYTE *v23;
  std::string::size_type v24;
  int v25;
  uint64_t v26;
  std::string::size_type v27;
  std::string::size_type v28;
  std::string *v29;
  char *v30;
  std::string::size_type v31;
  int v32;
  uint64_t v33;
  std::string::size_type v34;
  std::string::size_type v35;
  std::string *v36;
  char *v37;
  std::string::size_type v38;
  std::string *v39;
  std::string *v40;
  std::string::size_type v41;
  int v42;
  std::string::size_type v43;
  std::string *v44;
  _BYTE *v45;
  std::string::size_type v46;
  std::string::size_type v47;
  std::string::size_type v48;
  std::string *v49;
  char *v50;
  std::string::size_type v51;
  std::string::size_type v52;
  std::string::size_type v53;
  std::string *v54;
  _WORD *v55;
  std::string::size_type v56;
  std::string *v57;
  _BYTE *v58;
  std::string::size_type v59;
  std::string::size_type v60;
  std::string::size_type v61;
  std::string *v62;
  char *v63;
  std::string::size_type v64;
  std::string::size_type v65;
  std::string::size_type v66;
  std::string *v67;
  char *v68;
  std::string::size_type v69;
  std::string::size_type v70;
  std::string::size_type v71;
  std::string *v72;
  char *v73;
  std::string::size_type v74;
  std::string::size_type v75;
  std::string::size_type v76;
  std::string *v77;
  _WORD *v78;
  std::string::size_type v79;
  std::string v80;

  memset(&v80, 0, sizeof(v80));
  if (&v80 <= (std::string *)"[ " && &v80.__r_.__value_.__s.__data_[2] > "[ ")
    goto LABEL_222;
  strcpy((char *)&v80, "[ ");
  *((_BYTE *)&v80.__r_.__value_.__s + 23) = 2;
  v5 = *(unsigned __int8 *)(a2 + 8);
  v6 = *(unsigned __int8 *)(a2 + 28);
  if (*(_BYTE *)(a2 + 8))
    v7 = v6 == 0;
  else
    v7 = 1;
  if (v7)
  {
    if ((v5 != 0) != (v6 != 0))
      goto LABEL_17;
LABEL_14:
    v8 = *(unsigned __int8 *)(a2 + 16);
    if (*(_BYTE *)(a2 + 16) && *(_BYTE *)(a2 + 36))
    {
      if (*(_DWORD *)(a2 + 12) != *(_DWORD *)(a2 + 32))
        goto LABEL_17;
    }
    else if ((v8 != 0) != (*(_BYTE *)(a2 + 36) != 0))
    {
      goto LABEL_17;
    }
    if (*(_BYTE *)(a2 + 8))
    {
      v17 = rtc::StringBuilder::operator<<(&v80, *(_DWORD *)a2);
      v18 = v17;
      size = HIBYTE(v17->__r_.__value_.__r.__words[2]);
      v20 = (char)size;
      if ((size & 0x80u) == 0)
        v21 = 22;
      else
        v21 = (v17->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
      if ((size & 0x80u) != 0)
        size = v17->__r_.__value_.__l.__size_;
      if (v21 == size)
      {
        std::string::__grow_by_and_replace(v17, v21, 1uLL, v21, v21, 0, 1uLL, "x");
        if (!*(_BYTE *)(a2 + 8))
          goto LABEL_222;
      }
      else
      {
        if (v20 >= 0)
          v57 = v17;
        else
          v57 = (std::string *)v17->__r_.__value_.__r.__words[0];
        v58 = (char *)v57 + size;
        if ((char *)v57 + size <= "x" && v58 + 1 > "x")
          goto LABEL_222;
        *v58 = 120;
        v59 = size + 1;
        if (SHIBYTE(v17->__r_.__value_.__r.__words[2]) < 0)
        {
          v17->__r_.__value_.__l.__size_ = v59;
          v57->__r_.__value_.__s.__data_[v59] = 0;
          if (!*(_BYTE *)(a2 + 8))
            goto LABEL_222;
        }
        else
        {
          *((_BYTE *)&v17->__r_.__value_.__s + 23) = v59 & 0x7F;
          v57->__r_.__value_.__s.__data_[v59] = 0;
          if (!*(_BYTE *)(a2 + 8))
            goto LABEL_222;
        }
      }
      rtc::StringBuilder::operator<<(v18, *(_DWORD *)(a2 + 4));
      if (!*(_BYTE *)(a2 + 16))
        goto LABEL_172;
    }
    else
    {
      if (&v80.__r_.__value_.__s.__data_[2] <= "unset-resolution"
        && (char *)&v80.__r_.__value_.__r.__words[2] + 2 > "unset-resolution")
      {
        goto LABEL_222;
      }
      strcpy(&v80.__r_.__value_.__s.__data_[2], "unset-resolution");
      *((_BYTE *)&v80.__r_.__value_.__s + 23) = 18;
      if (!v8)
      {
LABEL_172:
        if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v65 = 22;
        else
          v65 = (v80.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v66 = HIBYTE(v80.__r_.__value_.__r.__words[2]);
        else
          v66 = v80.__r_.__value_.__l.__size_;
        if (v65 - v66 >= 0xA)
        {
          v67 = &v80;
          if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v67 = (std::string *)v80.__r_.__value_.__r.__words[0];
          v68 = (char *)v67 + v66;
          if ((char *)v67 + v66 <= " max_fps: " && v68 + 10 > " max_fps: ")
            goto LABEL_222;
          *((_WORD *)v68 + 4) = 8250;
          *(_QWORD *)v68 = *(_QWORD *)" max_fps: ";
          v69 = v66 + 10;
          if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
          {
            v80.__r_.__value_.__l.__size_ = v66 + 10;
            v67->__r_.__value_.__s.__data_[v69] = 0;
            if (*(_BYTE *)(a2 + 44))
              goto LABEL_180;
          }
          else
          {
            *((_BYTE *)&v80.__r_.__value_.__s + 23) = v69 & 0x7F;
            v67->__r_.__value_.__s.__data_[v69] = 0;
            if (*(_BYTE *)(a2 + 44))
              goto LABEL_180;
          }
        }
        else
        {
          std::string::__grow_by_and_replace(&v80, v65, v66 - v65 + 10, v66, v66, 0, 0xAuLL, " max_fps: ");
          if (*(_BYTE *)(a2 + 44))
          {
LABEL_180:
            rtc::StringBuilder::operator<<(&v80, *(_DWORD *)(a2 + 40));
            goto LABEL_205;
          }
        }
        if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v70 = 22;
        else
          v70 = (v80.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v71 = HIBYTE(v80.__r_.__value_.__r.__words[2]);
        else
          v71 = v80.__r_.__value_.__l.__size_;
        if (v70 - v71 >= 5)
        {
          v72 = &v80;
          if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v72 = (std::string *)v80.__r_.__value_.__r.__words[0];
          v73 = (char *)v72 + v71;
          if ((char *)v72 + v71 <= "unset" && v73 + 5 > "unset")
            goto LABEL_222;
          v73[4] = 116;
          *(_DWORD *)v73 = 1702063733;
          v74 = v71 + 5;
          if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
            v80.__r_.__value_.__l.__size_ = v71 + 5;
          else
            *((_BYTE *)&v80.__r_.__value_.__s + 23) = v74 & 0x7F;
          v72->__r_.__value_.__s.__data_[v74] = 0;
        }
        else
        {
          std::string::__grow_by_and_replace(&v80, v70, v71 - v70 + 5, v71, v71, 0, 5uLL, "unset");
        }
LABEL_205:
        if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v75 = 22;
        else
          v75 = (v80.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v76 = HIBYTE(v80.__r_.__value_.__r.__words[2]);
        else
          v76 = v80.__r_.__value_.__l.__size_;
        if (v75 - v76 >= 2)
        {
          v77 = &v80;
          if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v77 = (std::string *)v80.__r_.__value_.__r.__words[0];
          v78 = (_WORD *)((char *)v77 + v76);
          if ((char *)v77 + v76 <= " ]" && v78 + 1 > (_WORD *)" ]")
            goto LABEL_222;
          *v78 = 23840;
          v79 = v76 + 2;
          if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
            v80.__r_.__value_.__l.__size_ = v76 + 2;
          else
            *((_BYTE *)&v80.__r_.__value_.__s + 23) = v79 & 0x7F;
          v77->__r_.__value_.__s.__data_[v79] = 0;
        }
        else
        {
          std::string::__grow_by_and_replace(&v80, v75, v76 - v75 + 2, v76, v76, 0, 2uLL, " ]");
        }
        *this = v80;
        return;
      }
    }
    if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v60 = 22;
    else
      v60 = (v80.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v61 = HIBYTE(v80.__r_.__value_.__r.__words[2]);
    else
      v61 = v80.__r_.__value_.__l.__size_;
    if (v60 - v61 >= 0x12)
    {
      v62 = &v80;
      if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v62 = (std::string *)v80.__r_.__value_.__r.__words[0];
      v63 = (char *)v62 + v61;
      if ((char *)v62 + v61 <= " max_pixel_count: " && v63 + 18 > " max_pixel_count: ")
        goto LABEL_222;
      *((_WORD *)v63 + 8) = 8250;
      *(_OWORD *)v63 = *(_OWORD *)" max_pixel_count: ";
      v64 = v61 + 18;
      if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
      {
        v80.__r_.__value_.__l.__size_ = v61 + 18;
        v62->__r_.__value_.__s.__data_[v64] = 0;
        if (!*(_BYTE *)(a2 + 16))
          goto LABEL_222;
      }
      else
      {
        *((_BYTE *)&v80.__r_.__value_.__s + 23) = v64 & 0x7F;
        v62->__r_.__value_.__s.__data_[v64] = 0;
        if (!*(_BYTE *)(a2 + 16))
          goto LABEL_222;
      }
    }
    else
    {
      std::string::__grow_by_and_replace(&v80, v60, v61 - v60 + 18, v61, v61, 0, 0x12uLL, " max_pixel_count: ");
      if (!*(_BYTE *)(a2 + 16))
        goto LABEL_222;
    }
    rtc::StringBuilder::operator<<(&v80, *(_DWORD *)(a2 + 12));
    goto LABEL_172;
  }
  if (*(_DWORD *)a2 == *(_DWORD *)(a2 + 24) && *(_DWORD *)(a2 + 4) == *(_DWORD *)(a2 + 20))
    goto LABEL_14;
LABEL_17:
  if (&v80.__r_.__value_.__s.__data_[2] <= "[ landscape: "
    && (char *)&v80.__r_.__value_.__r.__words[1] + 7 > "[ landscape: ")
  {
    goto LABEL_222;
  }
  strcpy(&v80.__r_.__value_.__s.__data_[2], "[ landscape: ");
  *((_BYTE *)&v80.__r_.__value_.__s + 23) = 15;
  if (!v5)
  {
    if ((char *)&v80.__r_.__value_.__r.__words[1] + 7 <= "unset"
      && (char *)&v80.__r_.__value_.__r.__words[2] + 4 > "unset")
    {
      goto LABEL_222;
    }
    strcpy(&v80.__r_.__value_.__s.__data_[15], "unset");
    v14 = 20;
    *((_BYTE *)&v80.__r_.__value_.__s + 23) = 20;
    v16 = v80.__r_.__value_.__r.__words[2];
    v15 = v80.__r_.__value_.__l.__size_;
    if (!*(_BYTE *)(a2 + 16))
      goto LABEL_74;
    goto LABEL_56;
  }
  v9 = rtc::StringBuilder::operator<<(&v80, *(_DWORD *)a2);
  v10 = v9;
  v11 = HIBYTE(v9->__r_.__value_.__r.__words[2]);
  v12 = (char)v11;
  if ((v11 & 0x80u) == 0)
    v13 = 22;
  else
    v13 = (v9->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v11 & 0x80u) != 0)
    v11 = v9->__r_.__value_.__l.__size_;
  if (v13 == v11)
  {
    std::string::__grow_by_and_replace(v9, v13, 1uLL, v13, v13, 0, 1uLL, "x");
    if (!*(_BYTE *)(a2 + 8))
      goto LABEL_222;
  }
  else
  {
    if (v12 >= 0)
      v22 = v9;
    else
      v22 = (std::string *)v9->__r_.__value_.__r.__words[0];
    v23 = (char *)v22 + v11;
    if ((char *)v22 + v11 <= "x" && v23 + 1 > "x")
      goto LABEL_222;
    *v23 = 120;
    v24 = v11 + 1;
    if (SHIBYTE(v9->__r_.__value_.__r.__words[2]) < 0)
    {
      v9->__r_.__value_.__l.__size_ = v24;
      v22->__r_.__value_.__s.__data_[v24] = 0;
      if (!*(_BYTE *)(a2 + 8))
        goto LABEL_222;
    }
    else
    {
      *((_BYTE *)&v9->__r_.__value_.__s + 23) = v24 & 0x7F;
      v22->__r_.__value_.__s.__data_[v24] = 0;
      if (!*(_BYTE *)(a2 + 8))
        goto LABEL_222;
    }
  }
  rtc::StringBuilder::operator<<(v10, *(_DWORD *)(a2 + 4));
  v14 = HIBYTE(v80.__r_.__value_.__r.__words[2]);
  v16 = v80.__r_.__value_.__r.__words[2];
  v15 = v80.__r_.__value_.__l.__size_;
  if (*(_BYTE *)(a2 + 16))
  {
LABEL_56:
    v25 = (char)v14;
    v26 = (v16 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if ((v14 & 0x80u) == 0)
      v27 = 22;
    else
      v27 = v26;
    if ((v14 & 0x80u) == 0)
      v28 = v14;
    else
      v28 = v15;
    if (v27 - v28 >= 0x12)
    {
      v29 = (std::string *)v80.__r_.__value_.__r.__words[0];
      if (v25 >= 0)
        v29 = &v80;
      v30 = (char *)v29 + v28;
      if ((char *)v29 + v28 <= " max_pixel_count: " && v30 + 18 > " max_pixel_count: ")
        goto LABEL_222;
      *((_WORD *)v30 + 8) = 8250;
      *(_OWORD *)v30 = *(_OWORD *)" max_pixel_count: ";
      v31 = v28 + 18;
      if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
      {
        v80.__r_.__value_.__l.__size_ = v28 + 18;
        v29->__r_.__value_.__s.__data_[v31] = 0;
        if (!*(_BYTE *)(a2 + 16))
          goto LABEL_222;
      }
      else
      {
        *((_BYTE *)&v80.__r_.__value_.__s + 23) = v31 & 0x7F;
        v29->__r_.__value_.__s.__data_[v31] = 0;
        if (!*(_BYTE *)(a2 + 16))
          goto LABEL_222;
      }
    }
    else
    {
      std::string::__grow_by_and_replace(&v80, v27, v28 - v27 + 18, v28, v28, 0, 0x12uLL, " max_pixel_count: ");
      if (!*(_BYTE *)(a2 + 16))
        goto LABEL_222;
    }
    rtc::StringBuilder::operator<<(&v80, *(_DWORD *)(a2 + 12));
    v14 = HIBYTE(v80.__r_.__value_.__r.__words[2]);
    v16 = v80.__r_.__value_.__r.__words[2];
    v15 = v80.__r_.__value_.__l.__size_;
  }
LABEL_74:
  v32 = (char)v14;
  v33 = (v16 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v14 & 0x80u) == 0)
    v34 = 22;
  else
    v34 = v33;
  if ((v14 & 0x80u) == 0)
    v35 = v14;
  else
    v35 = v15;
  if (v34 - v35 < 0xF)
  {
    std::string::__grow_by_and_replace(&v80, v34, v35 - v34 + 15, v35, v35, 0, 0xFuLL, " ] [ portrait: ");
    if (!*(_BYTE *)(a2 + 28))
      goto LABEL_82;
LABEL_92:
    v39 = rtc::StringBuilder::operator<<(&v80, *(_DWORD *)(a2 + 20));
    v40 = v39;
    v41 = HIBYTE(v39->__r_.__value_.__r.__words[2]);
    v42 = (char)v41;
    if ((v41 & 0x80u) == 0)
      v43 = 22;
    else
      v43 = (v39->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if ((v41 & 0x80u) != 0)
      v41 = v39->__r_.__value_.__l.__size_;
    if (v43 == v41)
    {
      std::string::__grow_by_and_replace(v39, v43, 1uLL, v43, v43, 0, 1uLL, "x");
      if (!*(_BYTE *)(a2 + 28))
        goto LABEL_222;
    }
    else
    {
      if (v42 >= 0)
        v44 = v39;
      else
        v44 = (std::string *)v39->__r_.__value_.__r.__words[0];
      v45 = (char *)v44 + v41;
      if ((char *)v44 + v41 <= "x" && v45 + 1 > "x")
        goto LABEL_222;
      *v45 = 120;
      v46 = v41 + 1;
      if (SHIBYTE(v39->__r_.__value_.__r.__words[2]) < 0)
      {
        v39->__r_.__value_.__l.__size_ = v46;
        v44->__r_.__value_.__s.__data_[v46] = 0;
        if (!*(_BYTE *)(a2 + 28))
          goto LABEL_222;
      }
      else
      {
        *((_BYTE *)&v39->__r_.__value_.__s + 23) = v46 & 0x7F;
        v44->__r_.__value_.__s.__data_[v46] = 0;
        if (!*(_BYTE *)(a2 + 28))
          goto LABEL_222;
      }
    }
    rtc::StringBuilder::operator<<(v40, *(_DWORD *)(a2 + 24));
    if (!*(_BYTE *)(a2 + 36))
      goto LABEL_128;
    goto LABEL_110;
  }
  v36 = (std::string *)v80.__r_.__value_.__r.__words[0];
  if (v32 >= 0)
    v36 = &v80;
  v37 = (char *)v36 + v35;
  if ((char *)v36 + v35 <= " ] [ portrait: " && v37 + 15 > " ] [ portrait: ")
    goto LABEL_222;
  qmemcpy(v37, " ] [ portrait: ", 15);
  v38 = v35 + 15;
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
  {
    v80.__r_.__value_.__l.__size_ = v35 + 15;
    v36->__r_.__value_.__s.__data_[v38] = 0;
    if (*(_BYTE *)(a2 + 28))
      goto LABEL_92;
  }
  else
  {
    *((_BYTE *)&v80.__r_.__value_.__s + 23) = v38 & 0x7F;
    v36->__r_.__value_.__s.__data_[v38] = 0;
    if (*(_BYTE *)(a2 + 28))
      goto LABEL_92;
  }
LABEL_82:
  if (!*(_BYTE *)(a2 + 36))
  {
LABEL_128:
    if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v52 = 22;
    else
      v52 = (v80.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v53 = HIBYTE(v80.__r_.__value_.__r.__words[2]);
    else
      v53 = v80.__r_.__value_.__l.__size_;
    if (v52 - v53 >= 2)
    {
      v54 = &v80;
      if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v54 = (std::string *)v80.__r_.__value_.__r.__words[0];
      v55 = (_WORD *)((char *)v54 + v53);
      if ((char *)v54 + v53 <= " ]" && v55 + 1 > (_WORD *)" ]")
        goto LABEL_222;
      *v55 = 23840;
      v56 = v53 + 2;
      if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
        v80.__r_.__value_.__l.__size_ = v53 + 2;
      else
        *((_BYTE *)&v80.__r_.__value_.__s + 23) = v56 & 0x7F;
      v54->__r_.__value_.__s.__data_[v56] = 0;
    }
    else
    {
      std::string::__grow_by_and_replace(&v80, v52, v53 - v52 + 2, v53, v53, 0, 2uLL, " ]");
    }
    goto LABEL_172;
  }
LABEL_110:
  if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v47 = 22;
  else
    v47 = (v80.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v48 = HIBYTE(v80.__r_.__value_.__r.__words[2]);
  else
    v48 = v80.__r_.__value_.__l.__size_;
  if (v47 - v48 < 0x12)
  {
    std::string::__grow_by_and_replace(&v80, v47, v48 - v47 + 18, v48, v48, 0, 0x12uLL, " max_pixel_count: ");
    if (!*(_BYTE *)(a2 + 36))
      goto LABEL_222;
    goto LABEL_127;
  }
  v49 = &v80;
  if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v49 = (std::string *)v80.__r_.__value_.__r.__words[0];
  v50 = (char *)v49 + v48;
  if ((char *)v49 + v48 <= " max_pixel_count: " && v50 + 18 > " max_pixel_count: ")
    goto LABEL_222;
  *((_WORD *)v50 + 8) = 8250;
  *(_OWORD *)v50 = *(_OWORD *)" max_pixel_count: ";
  v51 = v48 + 18;
  if ((SHIBYTE(v80.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    *((_BYTE *)&v80.__r_.__value_.__s + 23) = v51 & 0x7F;
    v49->__r_.__value_.__s.__data_[v51] = 0;
    if (!*(_BYTE *)(a2 + 36))
      goto LABEL_222;
    goto LABEL_127;
  }
  v80.__r_.__value_.__l.__size_ = v48 + 18;
  v49->__r_.__value_.__s.__data_[v51] = 0;
  if (*(_BYTE *)(a2 + 36))
  {
LABEL_127:
    rtc::StringBuilder::operator<<(&v80, *(_DWORD *)(a2 + 32));
    goto LABEL_128;
  }
LABEL_222:
  __break(1u);
}

void cricket::VideoAdapter::OnSinkWants(cricket::VideoAdapter *this, const rtc::VideoSinkWants *a2)
{
  pthread_mutex_t *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  std::string __p;

  v4 = (pthread_mutex_t *)((char *)this + 176);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 176));
  v5 = *((_DWORD *)a2 + 1);
  *((_DWORD *)this + 23) = v5;
  if (*((_BYTE *)a2 + 12))
    v5 = *((_DWORD *)a2 + 2);
  *((_DWORD *)this + 22) = v5;
  *((_DWORD *)this + 24) = *((_DWORD *)a2 + 4);
  v6 = *((_DWORD *)this + 8);
  v7 = *((_DWORD *)a2 + 5);
  v8 = v6 % v7;
  if (!(v6 % v7))
  {
    *((_DWORD *)this + 9) = v7 / v7 * v6;
    if (*((_BYTE *)a2 + 62))
      goto LABEL_7;
LABEL_19:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/video_adapter.cc");
    goto LABEL_45;
  }
  v9 = *((_DWORD *)a2 + 5);
  do
  {
    v10 = v8;
    v8 = v9 % v8;
    v9 = v10;
  }
  while (v8);
  *((_DWORD *)this + 9) = v7 / v10 * v6;
  if (!*((_BYTE *)a2 + 62))
    goto LABEL_19;
LABEL_7:
  if (!*((_BYTE *)a2 + 56))
  {
    if (*((_BYTE *)this + 148))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        if (!*((_BYTE *)this + 148))
          goto LABEL_46;
        cricket::VideoAdapter::OutputFormatRequest::ToString(&__p, (uint64_t)this + 100);
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v28, v29, v30, v31, v32, v33, v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/video_adapter.cc");
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (*((_BYTE *)this + 148))
      {
        if (*((unsigned __int8 *)this + 48) == *((unsigned __int8 *)this + 108))
        {
          if (*((_BYTE *)this + 48))
            *((_QWORD *)this + 5) = *(_QWORD *)((char *)this + 100);
        }
        else if (*((_BYTE *)this + 48))
        {
          *((_BYTE *)this + 48) = 0;
        }
        else
        {
          *((_QWORD *)this + 5) = *(_QWORD *)((char *)this + 100);
          *((_BYTE *)this + 48) = 1;
        }
        *((_DWORD *)this + 13) = *((_DWORD *)this + 28);
        *((_BYTE *)this + 56) = *((_BYTE *)this + 116);
        if (*((unsigned __int8 *)this + 68) == *((unsigned __int8 *)this + 128))
        {
          if (*((_BYTE *)this + 68))
            *(_QWORD *)((char *)this + 60) = *((_QWORD *)this + 15);
        }
        else if (*((_BYTE *)this + 68))
        {
          *((_BYTE *)this + 68) = 0;
        }
        else
        {
          *(_QWORD *)((char *)this + 60) = *((_QWORD *)this + 15);
          *((_BYTE *)this + 68) = 1;
        }
        *((_QWORD *)this + 9) = *(_QWORD *)((char *)this + 132);
        *(_QWORD *)((char *)this + 77) = *(_QWORD *)((char *)this + 137);
        *((_BYTE *)this + 148) = 0;
        goto LABEL_45;
      }
      goto LABEL_46;
    }
LABEL_45:
    pthread_mutex_unlock(v4);
    return;
  }
  if (*((_BYTE *)a2 + 61))
    goto LABEL_45;
  if (*((_BYTE *)this + 148))
    goto LABEL_15;
  v11 = *(_OWORD *)((char *)this + 56);
  *(_OWORD *)((char *)this + 100) = *(_OWORD *)((char *)this + 40);
  *(_OWORD *)((char *)this + 116) = v11;
  *(_OWORD *)((char *)this + 132) = *(_OWORD *)((char *)this + 72);
  *((_BYTE *)this + 148) = 1;
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    if (!*((_BYTE *)this + 148))
      goto LABEL_46;
    cricket::VideoAdapter::OutputFormatRequest::ToString(&__p, (uint64_t)this + 100);
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v12, v13, v14, v15, v16, v17, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/video_adapter.cc");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (*((_BYTE *)a2 + 56))
  {
LABEL_15:
    v19 = *((_QWORD *)a2 + 6);
    v20 = HIDWORD(v19) * v19;
    if (*((_BYTE *)this + 48))
    {
      *((_QWORD *)this + 5) = v19;
      *((_DWORD *)this + 13) = v20;
      *((_BYTE *)this + 56) = 1;
      if (*((_BYTE *)this + 68))
      {
LABEL_17:
        *((_DWORD *)this + 15) = HIDWORD(v19);
        *((_DWORD *)this + 16) = v19;
        goto LABEL_34;
      }
    }
    else
    {
      *((_QWORD *)this + 5) = v19;
      *((_BYTE *)this + 48) = 1;
      *((_DWORD *)this + 13) = v20;
      *((_BYTE *)this + 56) = 1;
      if (*((_BYTE *)this + 68))
        goto LABEL_17;
    }
    *(_QWORD *)((char *)this + 60) = HIDWORD(v19) | (v19 << 32);
    *((_BYTE *)this + 68) = 1;
LABEL_34:
    *((_DWORD *)this + 18) = v20;
    *((_BYTE *)this + 76) = 1;
    *((_DWORD *)this + 20) = *((_DWORD *)this + 24);
    *((_BYTE *)this + 84) = 1;
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      cricket::VideoAdapter::OutputFormatRequest::ToString(&__p, (uint64_t)this + 40);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v35, v36, v37, v38, v39, v40, v41, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/video_adapter.cc");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    goto LABEL_45;
  }
LABEL_46:
  __break(1u);
}

uint64_t webrtc::VideoBitrateAllocation::VideoBitrateAllocation(uint64_t this)
{
  *(_DWORD *)this = 0;
  *(_BYTE *)(this + 4) = 0;
  *(_BYTE *)(this + 8) = 0;
  *(_BYTE *)(this + 12) = 0;
  *(_BYTE *)(this + 16) = 0;
  *(_BYTE *)(this + 20) = 0;
  *(_BYTE *)(this + 24) = 0;
  *(_BYTE *)(this + 28) = 0;
  *(_BYTE *)(this + 32) = 0;
  *(_BYTE *)(this + 36) = 0;
  *(_BYTE *)(this + 40) = 0;
  *(_BYTE *)(this + 44) = 0;
  *(_BYTE *)(this + 48) = 0;
  *(_BYTE *)(this + 52) = 0;
  *(_BYTE *)(this + 56) = 0;
  *(_BYTE *)(this + 60) = 0;
  *(_BYTE *)(this + 64) = 0;
  *(_BYTE *)(this + 68) = 0;
  *(_BYTE *)(this + 72) = 0;
  *(_BYTE *)(this + 76) = 0;
  *(_BYTE *)(this + 80) = 0;
  *(_BYTE *)(this + 84) = 0;
  *(_BYTE *)(this + 88) = 0;
  *(_BYTE *)(this + 92) = 0;
  *(_BYTE *)(this + 96) = 0;
  *(_BYTE *)(this + 100) = 0;
  *(_BYTE *)(this + 104) = 0;
  *(_BYTE *)(this + 108) = 0;
  *(_BYTE *)(this + 112) = 0;
  *(_BYTE *)(this + 116) = 0;
  *(_BYTE *)(this + 120) = 0;
  *(_BYTE *)(this + 124) = 0;
  *(_BYTE *)(this + 128) = 0;
  *(_BYTE *)(this + 132) = 0;
  *(_BYTE *)(this + 136) = 0;
  *(_BYTE *)(this + 140) = 0;
  *(_BYTE *)(this + 144) = 0;
  *(_BYTE *)(this + 148) = 0;
  *(_BYTE *)(this + 152) = 0;
  *(_BYTE *)(this + 156) = 0;
  *(_BYTE *)(this + 160) = 0;
  *(_BYTE *)(this + 164) = 0;
  return this;
}

void webrtc::VideoBitrateAllocation::SetBitrate(webrtc::VideoBitrateAllocation *this, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char *v9;
  unsigned int *v10;
  uint64_t v11;
  std::string *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  std::vector<unsigned int> *v18;

  if (a2 >= 5)
  {
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_bitrate_allocation.cc", 27, "spatial_index < kMaxSpatialLayers", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, a5, a6, a7, a8, a2);
    goto LABEL_9;
  }
  if (a3 >= 4)
  {
LABEL_9:
    v12 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_bitrate_allocation.cc", 28, "temporal_index < kMaxTemporalStreams", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, a5, a6, a7, a8, a3);
    webrtc::VideoBitrateAllocation::GetTemporalLayerAllocation((webrtc::VideoBitrateAllocation *)v12, v13, v14, v15, v16, v17, v18);
    return;
  }
  v8 = *(unsigned int *)this;
  v9 = (char *)this + 32 * a2 + 8 * a3;
  v10 = (unsigned int *)(v9 + 4);
  if (v9[8])
    v8 -= *v10;
  v11 = v8 + a4;
  if (v11 <= 0xFFFFFFFFLL)
  {
    *v10 = a4;
    v9[8] = 1;
    *(_DWORD *)this = v11;
  }
}

void webrtc::VideoBitrateAllocation::GetTemporalLayerAllocation(webrtc::VideoBitrateAllocation *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, std::vector<unsigned int> *a7@<X8>)
{
  char *v10;
  std::vector<unsigned int>::pointer begin;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  _BYTE *v15;
  unsigned int v16;
  std::string *v17;

  if (a2 >= 5)
  {
    v17 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_bitrate_allocation.cc", 91, "spatial_index < kMaxSpatialLayers", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, a3, a4, a5, a6, a2);
    webrtc::VideoBitrateAllocation::GetSimulcastAllocations((webrtc::VideoBitrateAllocation *)v17);
    return;
  }
  a7->__begin_ = 0;
  a7->__end_ = 0;
  a7->__end_cap_.__value_ = 0;
  v10 = (char *)this + 32 * a2;
  if (v10[32])
  {
    std::vector<int>::__append(a7, 4uLL);
    begin = a7->__begin_;
    v12 = (char *)a7->__end_ - (char *)a7->__begin_;
    if (!v12)
      return;
  }
  else if (v10[24])
  {
    std::vector<int>::__append(a7, 3uLL);
    begin = a7->__begin_;
    v12 = (char *)a7->__end_ - (char *)a7->__begin_;
    if (!v12)
      return;
  }
  else
  {
    v13 = (char *)this + 32 * a2;
    if (v13[16])
    {
      std::vector<int>::__append(a7, 2uLL);
      begin = a7->__begin_;
      v12 = (char *)a7->__end_ - (char *)a7->__begin_;
      if (!v12)
        return;
    }
    else
    {
      if (!v13[8])
        return;
      std::vector<int>::__append(a7, 1uLL);
      begin = a7->__begin_;
      v12 = (char *)a7->__end_ - (char *)a7->__begin_;
      if (!v12)
        return;
    }
  }
  v14 = v12 >> 2;
  if (v14 <= 1)
    v14 = 1;
  v15 = (char *)this + 32 * a2 + 8;
  do
  {
    v16 = *v15;
    if (*v15)
      v16 = *((_DWORD *)v15 - 1);
    *begin++ = v16;
    v15 += 8;
    --v14;
  }
  while (v14);
}

uint64_t webrtc::VideoBitrateAllocation::GetSimulcastAllocations@<X0>(uint64_t this@<X0>, int a2@<W2>, int a3@<W5>, char **a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  char v7;
  unsigned int v8;
  char **v9;
  int *v10;
  int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  char *v50;
  uint64_t v52;
  uint64_t v53;
  char v54;
  int *__p;
  uint64_t v56;
  int v57;
  unsigned int v58;
  int v59;
  int v60;
  unsigned int v61;
  int v62;

  v9 = a4;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  v52 = this;
  do
  {
    while (1)
    {
      v19 = this + 32 * v17;
      if (*(_BYTE *)(v19 + 8))
      {
        v8 = *(_DWORD *)(v19 + 4);
        v4 = v8 >> 8;
        v7 = 1;
        if (!*(_BYTE *)(v19 + 16))
        {
          v15 = 0;
          v16 = 0;
          v5 = 0;
          LOBYTE(v21) = *(_DWORD *)(v19 + 4);
          v6 = v8 >> 8;
          v22 = *(_DWORD *)(v19 + 4);
          v23 = this + 32 * v17;
          if (!*(_BYTE *)(v23 + 24))
            goto LABEL_20;
          goto LABEL_17;
        }
        v6 = v8 >> 8;
        v20 = *(unsigned int *)(this + 32 * v17 + 12);
        v21 = v20 + v8;
        if (HIDWORD(v21))
        {
          v15 = 0;
          v16 = 0;
          v5 = 0;
          LOBYTE(v21) = v8;
          v22 = v8;
          v23 = this + 32 * v17;
          if (!*(_BYTE *)(v23 + 24))
            goto LABEL_20;
          goto LABEL_17;
        }
        goto LABEL_6;
      }
      if (*(_BYTE *)(v19 + 16))
      {
        LOBYTE(v8) = 0;
        v7 = 0;
        LODWORD(v20) = *(_DWORD *)(this + 32 * v17 + 12);
        LODWORD(v21) = v20;
LABEL_6:
        v15 = v20;
        v16 = v20 >> 8;
        v6 = v21 >> 8;
        v5 = 1;
        v22 = v21;
        v23 = this + 32 * v17;
        if (!*(_BYTE *)(v23 + 24))
          goto LABEL_20;
        goto LABEL_17;
      }
      v24 = this + 32 * v17;
      if (*(_BYTE *)(v24 + 24) || *(_BYTE *)(v24 + 32))
        break;
      v29 = 0;
      LOBYTE(v21) = 0;
      v30 = (unint64_t)v9[2];
      if ((unint64_t)v10 >= v30)
        goto LABEL_29;
LABEL_25:
      if (!v10)
        goto LABEL_45;
      *v10 = v21 | (v6 << 8);
      v10[1] = v8 | ((_DWORD)v4 << 8);
      *((_BYTE *)v10 + 8) = v7;
      v10[3] = v15 | ((_DWORD)v16 << 8);
      *((_BYTE *)v10 + 16) = v5;
      v10[5] = v13 | (v14 << 8);
      *((_BYTE *)v10 + 24) = a2;
      v10[7] = v11 | (v12 << 8);
      *((_BYTE *)v10 + 32) = a3;
      *((_BYTE *)v10 + 36) = 0;
      *((_BYTE *)v10 + 40) = 0;
      *((_BYTE *)v10 + 44) = 0;
      *((_BYTE *)v10 + 48) = 0;
      *((_BYTE *)v10 + 52) = 0;
      *((_BYTE *)v10 + 56) = 0;
      *((_BYTE *)v10 + 60) = 0;
      *((_BYTE *)v10 + 64) = 0;
      *((_BYTE *)v10 + 68) = 0;
      *((_BYTE *)v10 + 72) = 0;
      *((_BYTE *)v10 + 76) = 0;
      *((_BYTE *)v10 + 80) = 0;
      *((_BYTE *)v10 + 84) = 0;
      *((_BYTE *)v10 + 88) = 0;
      *((_BYTE *)v10 + 92) = 0;
      *((_BYTE *)v10 + 96) = 0;
      *((_BYTE *)v10 + 100) = 0;
      *((_BYTE *)v10 + 104) = 0;
      *((_BYTE *)v10 + 108) = 0;
      *((_BYTE *)v10 + 112) = 0;
      *((_BYTE *)v10 + 116) = 0;
      *((_BYTE *)v10 + 120) = 0;
      *((_BYTE *)v10 + 124) = 0;
      *((_BYTE *)v10 + 128) = 0;
      *((_BYTE *)v10 + 132) = 0;
      *((_BYTE *)v10 + 136) = 0;
      *((_BYTE *)v10 + 140) = 0;
      *((_BYTE *)v10 + 144) = 0;
      *((_BYTE *)v10 + 148) = 0;
      *((_BYTE *)v10 + 152) = 0;
      *((_BYTE *)v10 + 156) = 0;
      *((_BYTE *)v10 + 160) = 0;
      *((_BYTE *)v10 + 164) = 0;
      *((_BYTE *)v10 + 168) = v29;
      v10 += 43;
      v9[1] = (char *)v10;
      if (++v17 == 5)
        return this;
    }
    v7 = 0;
    LOBYTE(v8) = 0;
    v15 = 0;
    v16 = 0;
    LOBYTE(v21) = 0;
    v6 = 0;
    v5 = 0;
    v22 = 0;
    v23 = this + 32 * v17;
    if (!*(_BYTE *)(v23 + 24))
      goto LABEL_20;
LABEL_17:
    v25 = *(unsigned int *)(v23 + 20);
    v26 = v25 + v22;
    if (!HIDWORD(v26))
    {
      v13 = *(_DWORD *)(v23 + 20);
      v14 = v25 >> 8;
      v6 = v26 >> 8;
      a2 = 1;
      LOBYTE(v21) = v25 + v22;
      v22 += v25;
      if (!*(_BYTE *)(v23 + 32))
        goto LABEL_24;
      goto LABEL_21;
    }
LABEL_20:
    v13 = 0;
    v14 = 0;
    a2 = 0;
    if (!*(_BYTE *)(v23 + 32))
      goto LABEL_24;
LABEL_21:
    v27 = *(unsigned int *)(this + 32 * v17 + 28);
    v28 = v27 + v22;
    if (HIDWORD(v28))
    {
LABEL_24:
      v11 = 0;
      v12 = 0;
      a3 = 0;
      v29 = 1;
      v30 = (unint64_t)v9[2];
      if ((unint64_t)v10 >= v30)
        goto LABEL_29;
      goto LABEL_25;
    }
    v11 = *(_DWORD *)(this + 32 * v17 + 28);
    v12 = v27 >> 8;
    v6 = v28 >> 8;
    v29 = 1;
    LOBYTE(v21) = v28;
    a3 = 1;
    v30 = (unint64_t)v9[2];
    if ((unint64_t)v10 < v30)
      goto LABEL_25;
LABEL_29:
    v31 = v5;
    v32 = v16;
    v33 = v15;
    v34 = v4;
    v35 = 0x82FA0BE82FA0BE83 * (((char *)v10 - v18) >> 2);
    v36 = v35 + 1;
    if (v35 + 1 > 0x17D05F417D05F41)
      goto LABEL_46;
    v37 = 0x82FA0BE82FA0BE83 * ((uint64_t)(v30 - (_QWORD)v18) >> 2);
    if (2 * v37 > v36)
      v36 = 2 * v37;
    if (v37 >= 0xBE82FA0BE82FA0)
      v38 = 0x17D05F417D05F41;
    else
      v38 = v36;
    if (!v38)
    {
LABEL_45:
      __break(1u);
LABEL_46:
      abort();
    }
    v54 = v29;
    v57 = a3;
    v58 = v12;
    v59 = v11;
    v60 = a2;
    v61 = v14;
    v62 = v13;
    __p = (int *)v18;
    v56 = v17;
    if (v38 > 0x17D05F417D05F41)
      std::__throw_bad_array_new_length[abi:sn180100]();
    v53 = 172 * v38;
    v39 = (char *)operator new(172 * v38);
    v40 = &v39[172 * v35];
    v4 = v34;
    *(_DWORD *)v40 = v21 | (v6 << 8);
    *((_DWORD *)v40 + 1) = v8 | ((_DWORD)v34 << 8);
    v40[8] = v7;
    v15 = v33;
    v16 = v32;
    *((_DWORD *)v40 + 3) = v15 | ((_DWORD)v32 << 8);
    v5 = v31;
    v40[16] = v31;
    v14 = v61;
    v13 = v62;
    *((_DWORD *)v40 + 5) = v62 | (v61 << 8);
    v11 = v59;
    a2 = v60;
    v40[24] = v60;
    a3 = v57;
    v12 = v58;
    *((_DWORD *)v40 + 7) = v59 | (v58 << 8);
    v40[32] = v57;
    v40[36] = 0;
    v40[40] = 0;
    v40[44] = 0;
    v40[48] = 0;
    v40[52] = 0;
    v40[56] = 0;
    v40[60] = 0;
    v40[64] = 0;
    v40[68] = 0;
    v40[72] = 0;
    v40[76] = 0;
    v40[80] = 0;
    v40[84] = 0;
    v40[88] = 0;
    v40[92] = 0;
    v40[96] = 0;
    v40[100] = 0;
    v40[104] = 0;
    v40[108] = 0;
    v40[112] = 0;
    v40[116] = 0;
    v40[120] = 0;
    v40[124] = 0;
    v40[128] = 0;
    v40[132] = 0;
    v40[136] = 0;
    v40[140] = 0;
    v40[144] = 0;
    v40[148] = 0;
    v40[152] = 0;
    v40[156] = 0;
    v40[160] = 0;
    v40[164] = 0;
    v40[168] = v54;
    if (v10 == __p)
    {
      v50 = v40;
    }
    else
    {
      v41 = v40;
      do
      {
        v42 = *(_OWORD *)(v10 - 43);
        v43 = *(_OWORD *)(v10 - 39);
        *(_OWORD *)(v41 - 140) = *(_OWORD *)(v10 - 35);
        *(_OWORD *)(v41 - 156) = v43;
        *(_OWORD *)(v41 - 172) = v42;
        v44 = *(_OWORD *)(v10 - 31);
        v45 = *(_OWORD *)(v10 - 27);
        v46 = *(_OWORD *)(v10 - 23);
        *(_OWORD *)(v41 - 76) = *(_OWORD *)(v10 - 19);
        *(_OWORD *)(v41 - 92) = v46;
        *(_OWORD *)(v41 - 108) = v45;
        *(_OWORD *)(v41 - 124) = v44;
        v47 = *(_OWORD *)(v10 - 15);
        v48 = *(_OWORD *)(v10 - 11);
        v49 = *(_OWORD *)(v10 - 7);
        v50 = v41 - 172;
        *(_OWORD *)(v41 - 19) = *(_OWORD *)((char *)v10 - 19);
        *(_OWORD *)(v41 - 28) = v49;
        *(_OWORD *)(v41 - 44) = v48;
        *(_OWORD *)(v41 - 60) = v47;
        v10 -= 43;
        v41 -= 172;
      }
      while (v10 != __p);
    }
    v10 = (int *)(v40 + 172);
    v9 = a4;
    *a4 = v50;
    a4[1] = v40 + 172;
    a4[2] = &v39[v53];
    if (__p)
    {
      operator delete(__p);
      a3 = v57;
      v12 = v58;
      v11 = v59;
      a2 = v60;
      v14 = v61;
      v13 = v62;
      v9 = a4;
    }
    v18 = v50;
    this = v52;
    v9[1] = (char *)v10;
    v17 = v56 + 1;
  }
  while (v56 != 4);
  return this;
}

uint64_t webrtc::VideoBitrateAllocation::operator==(uint64_t a1, uint64_t a2)
{
  int v2;
  BOOL v3;
  int v4;
  BOOL v5;

  v2 = *(unsigned __int8 *)(a2 + 8);
  if (*(_BYTE *)(a1 + 8))
    v3 = v2 == 0;
  else
    v3 = 1;
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 8) != 0) != (v2 != 0))
      return 0;
  }
  else if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
  {
    return 0;
  }
  v4 = *(unsigned __int8 *)(a2 + 16);
  if (*(_BYTE *)(a1 + 16))
    v5 = v4 == 0;
  else
    v5 = 1;
  if (v5)
  {
    if ((*(_BYTE *)(a1 + 16) != 0) != (v4 != 0))
      return 0;
  }
  else if (*(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 24) && *(_BYTE *)(a2 + 24))
  {
    if (*(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 24) != 0) != (*(_BYTE *)(a2 + 24) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 32) && *(_BYTE *)(a2 + 32))
  {
    if (*(_DWORD *)(a1 + 28) != *(_DWORD *)(a2 + 28))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 32) != 0) != (*(_BYTE *)(a2 + 32) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 40) && *(_BYTE *)(a2 + 40))
  {
    if (*(_DWORD *)(a1 + 36) != *(_DWORD *)(a2 + 36))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 40) != 0) != (*(_BYTE *)(a2 + 40) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 48) && *(_BYTE *)(a2 + 48))
  {
    if (*(_DWORD *)(a1 + 44) != *(_DWORD *)(a2 + 44))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 48) != 0) != (*(_BYTE *)(a2 + 48) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 56) && *(_BYTE *)(a2 + 56))
  {
    if (*(_DWORD *)(a1 + 52) != *(_DWORD *)(a2 + 52))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 56) != 0) != (*(_BYTE *)(a2 + 56) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 64) && *(_BYTE *)(a2 + 64))
  {
    if (*(_DWORD *)(a1 + 60) != *(_DWORD *)(a2 + 60))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 64) != 0) != (*(_BYTE *)(a2 + 64) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 72) && *(_BYTE *)(a2 + 72))
  {
    if (*(_DWORD *)(a1 + 68) != *(_DWORD *)(a2 + 68))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 72) != 0) != (*(_BYTE *)(a2 + 72) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 80) && *(_BYTE *)(a2 + 80))
  {
    if (*(_DWORD *)(a1 + 76) != *(_DWORD *)(a2 + 76))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 80) != 0) != (*(_BYTE *)(a2 + 80) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 88) && *(_BYTE *)(a2 + 88))
  {
    if (*(_DWORD *)(a1 + 84) != *(_DWORD *)(a2 + 84))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 88) != 0) != (*(_BYTE *)(a2 + 88) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 96) && *(_BYTE *)(a2 + 96))
  {
    if (*(_DWORD *)(a1 + 92) != *(_DWORD *)(a2 + 92))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 96) != 0) != (*(_BYTE *)(a2 + 96) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 104) && *(_BYTE *)(a2 + 104))
  {
    if (*(_DWORD *)(a1 + 100) != *(_DWORD *)(a2 + 100))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 104) != 0) != (*(_BYTE *)(a2 + 104) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 112) && *(_BYTE *)(a2 + 112))
  {
    if (*(_DWORD *)(a1 + 108) != *(_DWORD *)(a2 + 108))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 112) != 0) != (*(_BYTE *)(a2 + 112) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 120) && *(_BYTE *)(a2 + 120))
  {
    if (*(_DWORD *)(a1 + 116) != *(_DWORD *)(a2 + 116))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 120) != 0) != (*(_BYTE *)(a2 + 120) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 128) && *(_BYTE *)(a2 + 128))
  {
    if (*(_DWORD *)(a1 + 124) != *(_DWORD *)(a2 + 124))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 128) != 0) != (*(_BYTE *)(a2 + 128) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 136) && *(_BYTE *)(a2 + 136))
  {
    if (*(_DWORD *)(a1 + 132) != *(_DWORD *)(a2 + 132))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 136) != 0) != (*(_BYTE *)(a2 + 136) != 0))
  {
    return 0;
  }
  if (*(_BYTE *)(a1 + 144) && *(_BYTE *)(a2 + 144))
  {
    if (*(_DWORD *)(a1 + 140) != *(_DWORD *)(a2 + 140))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 144) != 0) != (*(_BYTE *)(a2 + 144) != 0))
  {
    return 0;
  }
  if (!*(_BYTE *)(a1 + 152) || !*(_BYTE *)(a2 + 152))
  {
    if ((*(_BYTE *)(a1 + 152) != 0) == (*(_BYTE *)(a2 + 152) != 0))
      goto LABEL_102;
    return 0;
  }
  if (*(_DWORD *)(a1 + 148) != *(_DWORD *)(a2 + 148))
    return 0;
LABEL_102:
  if (*(_BYTE *)(a1 + 160) && *(_BYTE *)(a2 + 160))
  {
    if (*(_DWORD *)(a1 + 156) != *(_DWORD *)(a2 + 156))
      return 0;
  }
  else if ((*(_BYTE *)(a1 + 160) != 0) != (*(_BYTE *)(a2 + 160) != 0))
  {
    return 0;
  }
  return 1;
}

unint64_t webrtc::VideoBitrateAllocation::ToString@<X0>(webrtc::VideoBitrateAllocation *this@<X0>, char *a2@<X8>)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int v11;
  int v12;
  char *v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  char *v19;
  const char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  size_t v27;
  int v28;
  int v29;
  size_t v30;
  int v31;
  size_t v32;
  size_t v33;
  char *v34;
  unint64_t result;
  size_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  char *__s;
  __int128 v44;
  char __src;
  char v46[512];
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  if (!*(_DWORD *)this)
  {
    result = (unint64_t)operator new(0x20uLL);
    *(_QWORD *)a2 = result;
    *(_OWORD *)(a2 + 8) = xmmword_208F05190;
    if (result > (unint64_t)"VideoBitrateAllocation [ [] ]"
      || result + 29 <= (unint64_t)"VideoBitrateAllocation [ [] ]")
    {
      strcpy((char *)result, "VideoBitrateAllocation [ [] ]");
      return result;
    }
    goto LABEL_79;
  }
  v4 = 0;
  v5 = 0;
  __s = v46;
  strcpy(v46, "VideoBitrateAllocation [");
  v44 = xmmword_208F1D3B0;
  while (v5 != *(_DWORD *)this)
  {
    v10 = (char *)this + v4;
    v11 = *((unsigned __int8 *)this + v4 + 8);
    if (*((_BYTE *)this + v4 + 8))
      v11 = *((_DWORD *)v10 + 1);
    v12 = v10[16];
    if (v10[16])
      v12 = *((_DWORD *)v10 + 3);
    v13 = (char *)this + v4;
    v14 = *((unsigned __int8 *)this + v4 + 24);
    if (*((_BYTE *)this + v4 + 24))
      v14 = *((_DWORD *)v13 + 5);
    if (v13[32])
    {
      v15 = v12 + v11 + v14 + *((_DWORD *)v13 + 7);
      v16 = *((_QWORD *)&v44 + 1);
      v17 = v44;
      if (v4)
        goto LABEL_24;
    }
    else
    {
      v15 = v12 + v11 + v14;
      v16 = *((_QWORD *)&v44 + 1);
      v17 = v44;
      if (v4)
        goto LABEL_24;
    }
    if (v15 == *(_DWORD *)this)
    {
      if ((unint64_t)(v17 + ~v16) >= 2)
        v18 = 2;
      else
        v18 = v17 + ~v16;
      v19 = &__s[v16];
      v20 = " [";
      goto LABEL_34;
    }
LABEL_24:
    v21 = __s;
    if (v4)
    {
      v22 = v16 + 1;
      memcpy(&__s[v16], ",", v17 != v16 + 1);
      v23 = *((_QWORD *)&v44 + 1);
      if (v17 != v22)
        v23 = *((_QWORD *)&v44 + 1) + 1;
      *((_QWORD *)&v44 + 1) = v23;
      __s[v23] = 0;
      v16 = *((_QWORD *)&v44 + 1);
      v17 = v44;
      v21 = __s;
    }
    __src = 10;
    v24 = v16 + 1;
    memcpy(&v21[v16], &__src, v17 != v16 + 1);
    v25 = *((_QWORD *)&v44 + 1);
    if (v17 != v24)
      v25 = *((_QWORD *)&v44 + 1) + 1;
    *((_QWORD *)&v44 + 1) = v25;
    __s[v25] = 0;
    if ((_QWORD)v44 + ~*((_QWORD *)&v44 + 1) >= 3uLL)
      v18 = 3;
    else
      v18 = v44 + ~*((_QWORD *)&v44 + 1);
    v19 = &__s[*((_QWORD *)&v44 + 1)];
    v20 = "  [";
LABEL_34:
    memcpy(v19, v20, v18);
    *((_QWORD *)&v44 + 1) += v18;
    __s[*((_QWORD *)&v44 + 1)] = 0;
    if (v15)
    {
      if (!v10[8])
      {
        v26 = 0;
        rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", 0);
LABEL_39:
        if ((_QWORD)v44 + ~*((_QWORD *)&v44 + 1) >= 2uLL)
          v27 = 2;
        else
          v27 = v44 + ~*((_QWORD *)&v44 + 1);
        memcpy(&__s[*((_QWORD *)&v44 + 1)], ", ", v27);
        *((_QWORD *)&v44 + 1) += v27;
        __s[*((_QWORD *)&v44 + 1)] = 0;
        if (*((_BYTE *)this + v4 + 16))
          v28 = *(_DWORD *)((char *)this + v4 + 12);
        else
          v28 = 0;
        rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", v28);
        v29 = v28 + v26;
        if (v29 != v15)
        {
          v30 = (_QWORD)v44 + ~*((_QWORD *)&v44 + 1) >= 2uLL ? 2 : v44 + ~*((_QWORD *)&v44 + 1);
          memcpy(&__s[*((_QWORD *)&v44 + 1)], ", ", v30);
          *((_QWORD *)&v44 + 1) += v30;
          __s[*((_QWORD *)&v44 + 1)] = 0;
          v31 = *((_BYTE *)this + v4 + 24) ? *(_DWORD *)((char *)this + v4 + 20) : 0;
          rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", v31);
          if (v31 + v29 != v15)
          {
            if ((_QWORD)v44 + ~*((_QWORD *)&v44 + 1) >= 2uLL)
              v32 = 2;
            else
              v32 = v44 + ~*((_QWORD *)&v44 + 1);
            memcpy(&__s[*((_QWORD *)&v44 + 1)], ", ", v32);
            *((_QWORD *)&v44 + 1) += v32;
            __s[*((_QWORD *)&v44 + 1)] = 0;
            if (*((_BYTE *)this + v4 + 32))
              v6 = *(_DWORD *)((char *)this + v4 + 28);
            else
              v6 = 0;
            rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", v6);
          }
        }
        goto LABEL_5;
      }
      v26 = *((_DWORD *)v10 + 1);
      rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", v26);
      if (v26 != v15)
        goto LABEL_39;
    }
LABEL_5:
    v5 += v15;
    v7 = v44;
    v8 = *((_QWORD *)&v44 + 1) + 1;
    memcpy(&__s[*((_QWORD *)&v44 + 1)], "]", v44 != *((_QWORD *)&v44 + 1) + 1);
    v9 = *((_QWORD *)&v44 + 1);
    if (v7 != v8)
      v9 = *((_QWORD *)&v44 + 1) + 1;
    *((_QWORD *)&v44 + 1) = v9;
    __s[v9] = 0;
    v4 += 32;
    if (v4 == 160)
      break;
  }
  if ((_QWORD)v44 + ~*((_QWORD *)&v44 + 1) >= 2uLL)
    v33 = 2;
  else
    v33 = v44 + ~*((_QWORD *)&v44 + 1);
  memcpy(&__s[*((_QWORD *)&v44 + 1)], " ]", v33);
  *((_QWORD *)&v44 + 1) += v33;
  __s[*((_QWORD *)&v44 + 1)] = 0;
  v34 = __s;
  if (!__s)
    goto LABEL_79;
  result = strlen(__s);
  if (result >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v36 = result;
  v37 = a2;
  if (result > 0x16)
  {
    v38 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17)
      v38 = result | 7;
    v39 = v38 + 1;
    result = (unint64_t)operator new(v38 + 1);
    *((_QWORD *)a2 + 1) = v36;
    *((_QWORD *)a2 + 2) = v39 | 0x8000000000000000;
    *(_QWORD *)a2 = result;
    v37 = (char *)result;
  }
  else
  {
    a2[23] = result;
  }
  v40 = &v37[v36];
  if (v37 <= v34 && v40 > v34)
LABEL_79:
    __break(1u);
  if (v36)
    result = (unint64_t)memmove(v37, v34, v36);
  *v40 = 0;
  return result;
}

uint64_t webrtc::VideoBitrateAllocator::GetAllocation(webrtc::VideoBitrateAllocator *this, unsigned int a2, unsigned int a3)
{
  _QWORD v4[3];

  v4[0] = a2;
  v4[1] = a2;
  *(double *)&v4[2] = (double)a3;
  return (*(uint64_t (**)(webrtc::VideoBitrateAllocator *, _QWORD *))(*(_QWORD *)this + 24))(this, v4);
}

void rtc::VideoBroadcaster::~VideoBroadcaster(rtc::VideoBroadcaster *this)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  void *v7;

  *(_QWORD *)this = &off_24C0C2FB0;
  *((_QWORD *)this + 4) = &unk_24C0C2FF8;
  v2 = *((_QWORD *)this + 21);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 16);
  if (v3)
  {
    *((_QWORD *)this + 17) = v3;
    operator delete(v3);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 40));
  *(_QWORD *)this = &off_24C0C49A0;
  v4 = *((_QWORD *)this + 1);
  if (v4)
  {
    v5 = *((_QWORD *)this + 2);
    v6 = (void *)*((_QWORD *)this + 1);
    if (v5 != v4)
    {
      do
      {
        v7 = *(void **)(v5 - 40);
        if (v7)
        {
          *(_QWORD *)(v5 - 32) = v7;
          operator delete(v7);
        }
        v5 -= 72;
      }
      while (v5 != v4);
      v6 = (void *)*((_QWORD *)this + 1);
    }
    *((_QWORD *)this + 2) = v4;
    operator delete(v6);
  }
}

{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  void *v7;

  *(_QWORD *)this = &off_24C0C2FB0;
  *((_QWORD *)this + 4) = &unk_24C0C2FF8;
  v2 = *((_QWORD *)this + 21);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 16);
  if (v3)
  {
    *((_QWORD *)this + 17) = v3;
    operator delete(v3);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 40));
  *(_QWORD *)this = &off_24C0C49A0;
  v4 = *((_QWORD *)this + 1);
  if (v4)
  {
    v5 = *((_QWORD *)this + 2);
    v6 = (void *)*((_QWORD *)this + 1);
    if (v5 != v4)
    {
      do
      {
        v7 = *(void **)(v5 - 40);
        if (v7)
        {
          *(_QWORD *)(v5 - 32) = v7;
          operator delete(v7);
        }
        v5 -= 72;
      }
      while (v5 != v4);
      v6 = (void *)*((_QWORD *)this + 1);
    }
    *((_QWORD *)this + 2) = v4;
    operator delete(v6);
  }
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'rtc::VideoBroadcaster::~VideoBroadcaster(rtc::VideoBroadcaster *this)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  void *v7;

  *((_QWORD *)this - 4) = &off_24C0C2FB0;
  *(_QWORD *)this = &unk_24C0C2FF8;
  v2 = *((_QWORD *)this + 17);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 12);
  if (v3)
  {
    *((_QWORD *)this + 13) = v3;
    operator delete(v3);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
  *((_QWORD *)this - 4) = &off_24C0C49A0;
  v4 = *((_QWORD *)this - 3);
  if (v4)
  {
    v5 = *((_QWORD *)this - 2);
    v6 = (void *)*((_QWORD *)this - 3);
    if (v5 != v4)
    {
      do
      {
        v7 = *(void **)(v5 - 40);
        if (v7)
        {
          *(_QWORD *)(v5 - 32) = v7;
          operator delete(v7);
        }
        v5 -= 72;
      }
      while (v5 != v4);
      v6 = (void *)*((_QWORD *)this - 3);
    }
    *((_QWORD *)this - 2) = v4;
    operator delete(v6);
  }
}

{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  void *v7;

  *((_QWORD *)this - 4) = &off_24C0C2FB0;
  *(_QWORD *)this = &unk_24C0C2FF8;
  v2 = *((_QWORD *)this + 17);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 12);
  if (v3)
  {
    *((_QWORD *)this + 13) = v3;
    operator delete(v3);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
  *((_QWORD *)this - 4) = &off_24C0C49A0;
  v4 = *((_QWORD *)this - 3);
  if (v4)
  {
    v5 = *((_QWORD *)this - 2);
    v6 = (void *)*((_QWORD *)this - 3);
    if (v5 != v4)
    {
      do
      {
        v7 = *(void **)(v5 - 40);
        if (v7)
        {
          *(_QWORD *)(v5 - 32) = v7;
          operator delete(v7);
        }
        v5 -= 72;
      }
      while (v5 != v4);
      v6 = (void *)*((_QWORD *)this - 3);
    }
    *((_QWORD *)this - 2) = v4;
    operator delete(v6);
  }
  JUMPOUT(0x20BD0ADECLL);
}

void rtc::VideoBroadcaster::AddOrUpdateSink(uint64_t a1, uint64_t a2, __int128 *a3)
{
  pthread_mutex_t *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v6 = (pthread_mutex_t *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
  v7 = *(_QWORD **)(a1 + 8);
  v8 = *(_QWORD **)(a1 + 16);
  if (v7 != v8)
  {
    while (*v7 != a2)
    {
      v7 += 9;
      if (v7 == v8)
        goto LABEL_10;
    }
  }
  if (v7 != v8 && v7 != 0)
    goto LABEL_16;
LABEL_10:
  *(_BYTE *)(a1 + 176) = 0;
  if (!*(_BYTE *)(a1 + 216))
  {
LABEL_16:
    rtc::VideoSourceBase::AddOrUpdateSink((_QWORD *)a1, a2, a3);
    rtc::VideoBroadcaster::UpdateWants((rtc::VideoBroadcaster *)a1);
    pthread_mutex_unlock(v6);
    return;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    if (!*(_BYTE *)(a1 + 216))
      goto LABEL_17;
    rtc::webrtc_logging_impl::Log("\r\t\t\a\t\a", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/video_broadcaster.cc");
  }
  if (*(_BYTE *)(a1 + 216))
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, a1 + 184);
    goto LABEL_16;
  }
LABEL_17:
  __break(1u);
}

__n128 rtc::VideoBroadcaster::UpdateWants(rtc::VideoBroadcaster *this)
{
  int32x2_t *v2;
  int32x2_t *v3;
  int32x2_t *v4;
  char v5;
  char v6;
  int v7;
  char v8;
  char v9;
  int v10;
  char v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  __n128 v19;
  char v20;
  int v21;
  __int32 v22;
  int v23;
  __int32 v24;
  int v25;
  int v26;
  char v27;
  unsigned int v28;
  __n128 result;
  __n128 v30;

  v2 = (int32x2_t *)*((_QWORD *)this + 1);
  v3 = (int32x2_t *)*((_QWORD *)this + 2);
  if (v2 == v3)
  {
    v6 = 0;
    LOBYTE(v7) = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v30 = 0u;
    v13 = 0x7FFFFFFF;
    v14 = 0x7FFFFFFF;
    v15 = 1;
    goto LABEL_57;
  }
  v4 = (int32x2_t *)*((_QWORD *)this + 1);
  do
  {
    if (v4[8].i8[4] && v4[8].i8[0])
    {
      v5 = 1;
      goto LABEL_9;
    }
    v4 += 9;
  }
  while (v4 != v3);
  v5 = 0;
LABEL_9:
  v16 = 0;
  v7 = 0;
  v17 = 0;
  v18 = 0;
  v8 = 0;
  v9 = 0;
  v6 = 0;
  v19 = 0uLL;
  v14 = 0x7FFFFFFF;
  v15 = 1;
  v13 = 0x7FFFFFFF;
  do
  {
    if (v2[8].i8[4] || (v2[8].i8[0] ? (v20 = 1) : (v20 = v5), (v20 & 1) == 0))
    {
      if (v2[1].i8[0])
        v6 = 1;
      if (v2[1].i32[1] < v13)
        v13 = v2[1].i32[1];
      if (v2[2].i8[4])
      {
        if (v17)
        {
          v21 = v2[2].i32[0];
          if (v21 >= (int)(v16 | (v18 << 8)))
            goto LABEL_26;
        }
        else
        {
          v21 = v2[2].i32[0];
        }
        v16 = v21;
        v18 = v21 >> 8;
        v17 = 1;
        v22 = v2[3].i32[1];
        if (v2[3].i32[0] < v14)
          v14 = v2[3].i32[0];
        v23 = v15 % v22;
        if (v15 % v22)
        {
LABEL_29:
          v24 = v22;
          do
          {
            v25 = v23;
            v23 = v24 % v23;
            v24 = v25;
          }
          while (v23);
          if (!v2[8].i8[0])
          {
LABEL_10:
            if (v2[8].i8[4])
              v9 = 1;
            goto LABEL_12;
          }
LABEL_38:
          if (v7)
          {
            v19.n128_u64[0] = (unint64_t)vmax_s32((int32x2_t)v19.n128_u64[0], v2[7]);
          }
          else
          {
            v19.n128_u64[0] = (unint64_t)v2[7];
            v7 = 1;
          }
LABEL_12:
          v15 *= v22 / v25;
          v8 |= v2[8].u8[4];
          goto LABEL_13;
        }
LABEL_37:
        v25 = v22;
        if (!v2[8].i8[0])
          goto LABEL_10;
        goto LABEL_38;
      }
LABEL_26:
      v22 = v2[3].i32[1];
      if (v2[3].i32[0] < v14)
        v14 = v2[3].i32[0];
      v23 = v15 % v22;
      if (v15 % v22)
        goto LABEL_29;
      goto LABEL_37;
    }
LABEL_13:
    v2 += 9;
  }
  while (v2 != v3);
  v26 = v13;
  if ((int)(v16 | (v18 << 8)) >= v13)
  {
    v27 = 1;
  }
  else
  {
    v26 = v16;
    v27 = v17;
  }
  if ((int)(v16 | (v18 << 8)) >= v13)
    v28 = v13 >> 8;
  else
    v28 = v18;
  if (v17)
    v10 = v26;
  else
    v10 = v16;
  if (v17)
    v11 = v27;
  else
    v11 = 0;
  if (v17)
    v12 = v28;
  else
    v12 = v18;
  v30 = v19;
LABEL_57:
  *((_BYTE *)this + 104) = v6;
  *((_BYTE *)this + 105) = 0;
  *((_DWORD *)this + 27) = v13;
  *((_DWORD *)this + 28) = v10 | (v12 << 8);
  *((_BYTE *)this + 116) = v11;
  *((_DWORD *)this + 30) = v14;
  *((_DWORD *)this + 31) = v15;
  std::vector<webrtc::rtcp::TargetBitrate::BitrateItem>::__assign_with_size[abi:sn180100]<webrtc::rtcp::TargetBitrate::BitrateItem*,webrtc::rtcp::TargetBitrate::BitrateItem*>((_QWORD *)this + 16, 0, 0, 0);
  result = v30;
  *((_QWORD *)this + 19) = v30.n128_u64[0];
  *((_BYTE *)this + 160) = v7;
  *((_BYTE *)this + 164) = v8;
  *((_BYTE *)this + 165) = v9;
  *((_BYTE *)this + 166) = 1;
  return result;
}

uint64_t rtc::VideoBroadcaster::RemoveSink(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;

  v4 = (pthread_mutex_t *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
  rtc::VideoSourceBase::RemoveSink(a1, a2);
  rtc::VideoBroadcaster::UpdateWants((rtc::VideoBroadcaster *)a1);
  return pthread_mutex_unlock(v4);
}

uint64_t rtc::VideoBroadcaster::OnFrame(rtc::VideoBroadcaster *this, const webrtc::VideoFrame *a2)
{
  unint64_t v2;
  uint64_t v3;
  _QWORD *v6;
  _QWORD *v7;
  char v8;
  BOOL v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  void (***v24)(_QWORD);
  __int128 v25;
  __int128 v26;
  __int128 v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  webrtc::I420Buffer *v42;
  _DWORD *v43;
  int v44;
  int v45;
  unsigned int v46;
  int v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unsigned int *v54;
  unsigned int v55;
  uint64_t v56;
  void (***v57)(_QWORD);
  int v58;
  uint64_t v59;
  unsigned int v60;
  unsigned int v61;
  uint64_t v62;
  void *v63;
  std::string *v65;
  const webrtc::VideoFrame *v66;
  uint64_t v67;
  pthread_mutex_t *v68;
  __int16 v69;
  void (***v70)(_QWORD);
  __int128 v71;
  __int128 v72;
  _BYTE v73[28];
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  char v78;
  char v79;
  _BYTE v80[29];
  unsigned int *v81;
  __int128 v82;
  uint64_t v83;

  v68 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  v6 = (_QWORD *)*((_QWORD *)this + 1);
  v7 = (_QWORD *)*((_QWORD *)this + 2);
  if (v6 == v7)
  {
    v8 = 0;
LABEL_74:
    *((_BYTE *)this + 176) = (v8 & 1) == 0;
    return pthread_mutex_unlock(v68);
  }
  v8 = 0;
  while (1)
  {
    if (*((_BYTE *)v6 + 8))
      v9 = *((_DWORD *)a2 + 18) == 0;
    else
      v9 = 1;
    if (!v9)
    {
      v15 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>();
      if ((v15 & 1) == 0)
      {
        v2 = v2 & 0xFFFFFFFF00000000 | 0x260;
        rtc::webrtc_logging_impl::Log("\r\t", v16, v17, v18, v19, v20, v21, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/video_broadcaster.cc");
      }
      (*(void (**)(_QWORD))(*(_QWORD *)*v6 + 24))(*v6);
      v8 = 1;
      goto LABEL_4;
    }
    if (*((_BYTE *)v6 + 9))
      break;
    if (*((_BYTE *)this + 176))
      v23 = 1;
    else
      v23 = *((_BYTE *)a2 + 176) == 0;
    if (!v23)
    {
      v69 = *(_WORD *)a2;
      v24 = (void (***)(_QWORD))*((_QWORD *)a2 + 1);
      v70 = v24;
      if (v24)
        (**v24)(v24);
      v25 = *((_OWORD *)a2 + 2);
      v71 = *((_OWORD *)a2 + 1);
      v72 = v25;
      *(_OWORD *)v73 = *((_OWORD *)a2 + 3);
      *(_OWORD *)&v73[12] = *(_OWORD *)((char *)a2 + 60);
      LOBYTE(v74) = 0;
      v79 = 0;
      if (*((_BYTE *)a2 + 144))
      {
        v26 = *(_OWORD *)((char *)a2 + 124);
        v76 = *(_OWORD *)((char *)a2 + 108);
        v77 = v26;
        v78 = *((_BYTE *)a2 + 140);
        v27 = *(_OWORD *)((char *)a2 + 92);
        v74 = *(_OWORD *)((char *)a2 + 76);
        v75 = v27;
        v79 = 1;
      }
      *(_OWORD *)v80 = *(_OWORD *)((char *)a2 + 148);
      *(_OWORD *)&v80[13] = *(_OWORD *)((char *)a2 + 161);
      v28 = (unsigned int *)*((_QWORD *)a2 + 23);
      v81 = v28;
      if (v28)
      {
        do
          v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
      }
      v82 = *((_OWORD *)a2 + 12);
      v83 = *((_QWORD *)a2 + 26);
      if (v80[28])
        v80[28] = 0;
      (*(void (**)(_QWORD, __int16 *))(*(_QWORD *)*v6 + 16))(*v6, &v69);
      v30 = v81;
      if (v81)
      {
        do
        {
          v31 = __ldaxr(v30);
          v32 = v31 - 1;
        }
        while (__stlxr(v32, v30));
        if (!v32)
        {
          v33 = *((_QWORD *)v30 + 1);
          if (v33)
          {
            v34 = *((_QWORD *)v30 + 2);
            v35 = (void *)*((_QWORD *)v30 + 1);
            if (v34 == v33)
              goto LABEL_69;
            do
            {
              v36 = *(void **)(v34 - 96);
              if (v36)
              {
                *(_QWORD *)(v34 - 88) = v36;
                operator delete(v36);
              }
              v34 -= 104;
            }
            while (v34 != v33);
LABEL_68:
            v35 = (void *)*((_QWORD *)v30 + 1);
            goto LABEL_69;
          }
LABEL_70:
          MEMORY[0x20BD0ADEC](v30, 0x1020C40E72D6CFBLL);
        }
      }
LABEL_71:
      if (v70)
        (*v70)[1](v70);
      goto LABEL_4;
    }
    (*(void (**)(_QWORD, const webrtc::VideoFrame *))(*(_QWORD *)*v6 + 16))(*v6, a2);
LABEL_4:
    v6 += 9;
    if (v6 == v7)
      goto LABEL_74;
  }
  v10 = *((_QWORD *)a2 + 1);
  if (!v10)
  {
    v11 = 0;
    v13 = 0;
    v14 = *((_QWORD *)this + 21);
    if (v14)
      goto LABEL_43;
    goto LABEL_45;
  }
  v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
  v12 = *((_QWORD *)a2 + 1);
  if (v12)
  {
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 48))(v12);
    v14 = *((_QWORD *)this + 21);
    if (!v14)
      goto LABEL_45;
  }
  else
  {
    v13 = 0;
    v14 = *((_QWORD *)this + 21);
    if (!v14)
      goto LABEL_45;
  }
LABEL_43:
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14) != v11
    || (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 21) + 48))(*((_QWORD *)this + 21)) != v13)
  {
LABEL_45:
    v41 = (_DWORD *)operator new();
    v43 = v41;
    v44 = v11 + 2;
    if (v11 >= -1)
      v44 = v11 + 1;
    v45 = v44 >> 1;
    v41[2] = v11;
    v41[3] = v13;
    v41[4] = v11;
    v41[5] = v45;
    v41[6] = v45;
    v46 = v13 + 2;
    if (v13 >= -1)
      v46 = v13 + 1;
    v47 = v13 * v11 + 2 * v45 * (v46 >> 1);
    if (v47)
    {
      v48 = malloc_type_malloc(v47 + 71, 0xB9DC9477uLL);
      if (!v48)
        goto LABEL_76;
      v53 = ((unint64_t)v48 + 71) & 0xFFFFFFFFFFFFFFC0;
      *(_QWORD *)(v53 - 8) = v48;
    }
    else
    {
      v53 = 0;
    }
    *((_QWORD *)v43 + 4) = v53;
    *(_QWORD *)v43 = &unk_24C0B4DF0;
    v43[10] = 0;
    v54 = v43 + 10;
    do
      v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
    webrtc::I420Buffer::SetBlack((webrtc::I420Buffer *)v43, v42);
    (**(void (***)(_DWORD *))v43)(v43);
    v56 = *((_QWORD *)this + 21);
    if (v56)
      (*(void (**)(uint64_t))(*(_QWORD *)v56 + 8))(v56);
    *((_QWORD *)this + 21) = v43;
    (*(void (**)(_DWORD *))(*(_QWORD *)v43 + 8))(v43);
  }
  v57 = (void (***)(_QWORD))*((_QWORD *)this + 21);
  if (v57)
  {
    v3 &= 0xFFFFFFFFFFFFFF00;
    (**v57)(*((_QWORD *)this + 21));
    v58 = *((_DWORD *)a2 + 18);
    v59 = *((_QWORD *)a2 + 4);
    v69 = *(_WORD *)a2;
    v70 = v57;
    (**v57)(v57);
    LODWORD(v71) = 0;
    *((_QWORD *)&v71 + 1) = 0;
    *(_QWORD *)&v72 = v59;
    *((_QWORD *)&v72 + 1) = v3;
    v73[0] = 0;
    v73[8] = 0;
    v73[16] = 0;
    *(_DWORD *)&v73[24] = v58;
    LOBYTE(v74) = 0;
    v79 = 0;
    v80[0] = 0;
    v80[4] = 0;
    v80[8] = 0;
    v80[12] = 0;
    v80[28] = 0;
    v81 = 0;
    LOBYTE(v82) = 0;
    LOBYTE(v83) = 0;
    (*v57)[1](v57);
    (*(void (**)(_QWORD, __int16 *))(*(_QWORD *)*v6 + 16))(*v6, &v69);
    v30 = v81;
    if (v81)
    {
      do
      {
        v60 = __ldaxr(v30);
        v61 = v60 - 1;
      }
      while (__stlxr(v61, v30));
      if (!v61)
      {
        v33 = *((_QWORD *)v30 + 1);
        if (v33)
        {
          v62 = *((_QWORD *)v30 + 2);
          v35 = (void *)*((_QWORD *)v30 + 1);
          if (v62 != v33)
          {
            do
            {
              v63 = *(void **)(v62 - 96);
              if (v63)
              {
                *(_QWORD *)(v62 - 88) = v63;
                operator delete(v63);
              }
              v62 -= 104;
            }
            while (v62 != v33);
            goto LABEL_68;
          }
LABEL_69:
          *((_QWORD *)v30 + 2) = v33;
          operator delete(v35);
        }
        goto LABEL_70;
      }
    }
    goto LABEL_71;
  }
  rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame.cc", 165, "video_frame_buffer_ != nullptr", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v37, v38, v39, v40, v67);
LABEL_76:
  v65 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/memory/aligned_malloc.cc", 66, "memory_pointer", "\t", v49, v50, v51, v52, (uint64_t)"Couldn't allocate memory in AlignedMalloc");
}

uint64_t `non-virtual thunk to'rtc::VideoBroadcaster::OnFrame(rtc::VideoBroadcaster *this, const webrtc::VideoFrame *a2)
{
  return rtc::VideoBroadcaster::OnFrame((rtc::VideoBroadcaster *)((char *)this - 32), a2);
}

uint64_t rtc::VideoBroadcaster::OnDiscardedFrame(rtc::VideoBroadcaster *this)
{
  pthread_mutex_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;

  v2 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  v4 = (uint64_t *)*((_QWORD *)this + 1);
  v3 = (uint64_t *)*((_QWORD *)this + 2);
  while (v4 != v3)
  {
    v5 = *v4;
    v4 += 9;
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  }
  return pthread_mutex_unlock(v2);
}

uint64_t `non-virtual thunk to'rtc::VideoBroadcaster::OnDiscardedFrame(rtc::VideoBroadcaster *this)
{
  pthread_mutex_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;

  v2 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v4 = (uint64_t *)*((_QWORD *)this - 3);
  v3 = (uint64_t *)*((_QWORD *)this - 2);
  while (v4 != v3)
  {
    v5 = *v4;
    v4 += 9;
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  }
  return pthread_mutex_unlock(v2);
}

BOOL webrtc::VideoCodecVP9::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2
      && a1[1] == a2[1]
      && *((_DWORD *)a1 + 1) == *((_DWORD *)a2 + 1)
      && a1[8] == a2[8]
      && a1[9] == a2[9]
      && a1[10] == a2[10]
      && a1[11] == a2[11];
}

double webrtc::VideoCodec::VideoCodec(webrtc::VideoCodec *this)
{
  double result;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_BYTE *)this + 24) = 1;
  *((_DWORD *)this + 7) = 0;
  *((_BYTE *)this + 32) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 36) = 0u;
  *(_OWORD *)((char *)this + 52) = 0u;
  *(_OWORD *)((char *)this + 68) = 0u;
  *(_OWORD *)((char *)this + 84) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
  *(_OWORD *)((char *)this + 116) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_BYTE *)this + 48) = 1;
  *(_QWORD *)((char *)this + 60) = 0;
  *(_QWORD *)((char *)this + 52) = 0;
  *((_BYTE *)this + 68) = 0;
  *((_BYTE *)this + 84) = 1;
  *((_BYTE *)this + 104) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_BYTE *)this + 120) = 1;
  *(_QWORD *)((char *)this + 132) = 0;
  *(_QWORD *)((char *)this + 124) = 0;
  *((_BYTE *)this + 140) = 0;
  *((_DWORD *)this + 80) = 0;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_BYTE *)this + 156) = 1;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_BYTE *)this + 176) = 0;
  *((_BYTE *)this + 192) = 1;
  *(_QWORD *)((char *)this + 204) = 0;
  *(_QWORD *)((char *)this + 196) = 0;
  *((_BYTE *)this + 212) = 0;
  *((_BYTE *)this + 228) = 1;
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 30) = 0;
  *((_BYTE *)this + 248) = 0;
  *((_BYTE *)this + 264) = 1;
  *(_QWORD *)((char *)this + 276) = 0;
  *(_QWORD *)((char *)this + 268) = 0;
  *((_BYTE *)this + 284) = 0;
  *((_BYTE *)this + 300) = 1;
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 39) = 0;
  *((_BYTE *)this + 320) = 0;
  *((_DWORD *)this + 81) = 0;
  *((_BYTE *)this + 328) = 0;
  *((_QWORD *)this + 42) = 0;
  *((_WORD *)this + 172) = 0;
  *((_BYTE *)this + 352) = 0;
  *((_DWORD *)this + 94) = 0;
  *((_BYTE *)this + 380) = 0;
  *(_QWORD *)((char *)this + 364) = 0;
  *(_QWORD *)((char *)this + 356) = 0;
  *((_WORD *)this + 186) = 0;
  return result;
}

unint64_t webrtc::VideoCodec::ToString@<X0>(webrtc::VideoCodec *this@<X0>, char *a2@<X8>)
{
  uint64_t v3;
  webrtc::VideoCodec *v4;
  const char *v5;
  size_t v6;
  size_t v7;
  char *v8;
  size_t v9;
  size_t v10;
  const char *v11;
  size_t v12;
  size_t v13;
  char *v14;
  unsigned int v15;
  unsigned int v16;
  char *v17;
  uint64_t v18;
  size_t v19;
  uint64_t v20;
  char *v21;
  unint64_t v22;
  size_t v23;
  unint64_t v24;
  const char *v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  size_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  size_t v51;
  unint64_t v52;
  const char *v53;
  size_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  unint64_t result;
  size_t v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  char *__s;
  __int128 v67;
  char v68[2048];
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  __s = v68;
  strcpy(v68, "VideoCodec {type: ");
  v67 = xmmword_208F1D3D0;
  v3 = *(int *)this;
  if (v3 >= 6)
    goto LABEL_43;
  v4 = this;
  v5 = (&off_24C0C3130)[v3];
  v6 = strlen(v5);
  if (v6 >= 0x7ED)
    v7 = 2029;
  else
    v7 = v6;
  memcpy(&v68[18], v5, v7);
  v8 = &v68[v7 + 18];
  *v8 = 0;
  if (2029 - v7 >= 8)
    v9 = 8;
  else
    v9 = 2029 - v7;
  memcpy(v8, ", mode: ", v9);
  v10 = v9 + v7 + 18;
  v68[v10] = 0;
  if (*((_DWORD *)v4 + 81))
    v11 = "Screensharing";
  else
    v11 = "RealtimeVideo";
  if (2047 - v10 >= 0xD)
    v12 = 13;
  else
    v12 = 2047 - v10;
  memcpy(&v68[v10], v11, v12);
  v13 = v12 + v10;
  *((_QWORD *)&v67 + 1) = v13;
  v14 = &v68[v13];
  v68[v13] = 0;
  v15 = *((unsigned __int8 *)v4 + 32);
  if (v15 > 1)
  {
    v65 = a2;
    if (2047 - v13 >= 0xE)
      v19 = 14;
    else
      v19 = 2047 - v13;
    memcpy(v14, ", Simulcast: {", v19);
    v20 = 0;
    v68[v19 + v13] = 0;
    *((_QWORD *)&v67 + 1) = v19 + v13;
    v21 = (char *)v4 + 36;
    while (1)
    {
      v30 = v21[12];
      if ((v30 - 4) >= 0xFFFFFFFD)
      {
        v31 = v21[32];
        v32 = v67;
        v33 = *((_QWORD *)&v67 + 1) + 1;
        v34 = *(_DWORD *)v21;
        v35 = *((_DWORD *)v21 + 1);
        memcpy(&__s[*((_QWORD *)&v67 + 1)], "[", v67 != *((_QWORD *)&v67 + 1) + 1);
        v36 = *((_QWORD *)&v67 + 1);
        if (v32 != v33)
          v36 = *((_QWORD *)&v67 + 1) + 1;
        *((_QWORD *)&v67 + 1) = v36;
        __s[v36] = 0;
        rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", v34);
        v37 = v67;
        v38 = *((_QWORD *)&v67 + 1) + 1;
        memcpy(&__s[*((_QWORD *)&v67 + 1)], "x", v67 != *((_QWORD *)&v67 + 1) + 1);
        v39 = *((_QWORD *)&v67 + 1);
        if (v37 != v38)
          v39 = *((_QWORD *)&v67 + 1) + 1;
        *((_QWORD *)&v67 + 1) = v39;
        __s[v39] = 0;
        rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", v35);
        v40 = v67;
        v41 = *((_QWORD *)&v67 + 1) + 1;
        this = (webrtc::VideoCodec *)memcpy(&__s[*((_QWORD *)&v67 + 1)], " ", v67 != *((_QWORD *)&v67 + 1) + 1);
        if (v40 == v41)
          v42 = *((_QWORD *)&v67 + 1);
        else
          v42 = *((_QWORD *)&v67 + 1) + 1;
        v43 = (char)webrtc::SimulcastStream::GetScalabilityMode(void)const::scalability_modes[v30 - 1];
        *((_QWORD *)&v67 + 1) = v42;
        __s[v42] = 0;
        if (v43 >= 0x22)
          goto LABEL_43;
        v22 = v43;
        if (qword_208F1D400[v22] >= (_QWORD)v67 + ~*((_QWORD *)&v67 + 1))
          v23 = v67 + ~*((_QWORD *)&v67 + 1);
        else
          v23 = qword_208F1D400[v22];
        memcpy(&__s[*((_QWORD *)&v67 + 1)], off_24C0C3020[v22], v23);
        *((_QWORD *)&v67 + 1) += v23;
        __s[*((_QWORD *)&v67 + 1)] = 0;
        v24 = 8;
        if (v31)
        {
          v25 = ", active";
        }
        else
        {
          v24 = 10;
          v25 = ", inactive";
        }
        if (v24 >= (_QWORD)v67 + ~*((_QWORD *)&v67 + 1))
          v26 = v67 + ~*((_QWORD *)&v67 + 1);
        else
          v26 = v24;
        memcpy(&__s[*((_QWORD *)&v67 + 1)], v25, v26);
        *((_QWORD *)&v67 + 1) += v26;
        __s[*((_QWORD *)&v67 + 1)] = 0;
        v27 = v67;
        v28 = *((_QWORD *)&v67 + 1) + 1;
        memcpy(&__s[*((_QWORD *)&v67 + 1)], "]", v67 != *((_QWORD *)&v67 + 1) + 1);
        v29 = *((_QWORD *)&v67 + 1);
        if (v27 != v28)
          v29 = *((_QWORD *)&v67 + 1) + 1;
        *((_QWORD *)&v67 + 1) = v29;
        __s[v29] = 0;
        v15 = *((unsigned __int8 *)v4 + 32);
      }
      v21 += 36;
      if (++v20 >= (unint64_t)v15)
        goto LABEL_62;
    }
  }
  v16 = *((unsigned __int16 *)v4 + 186);
  v17 = v68;
  if (v16 < 0x100)
  {
    v18 = 2048;
    goto LABEL_65;
  }
  v65 = a2;
  if (2047 - v13 >= 0xF)
    v44 = 15;
  else
    v44 = 2047 - v13;
  memcpy(v14, ", Singlecast: {", v44);
  *((_QWORD *)&v67 + 1) = v44 + v13;
  v68[*((_QWORD *)&v67 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((unsigned __int16 *)v4 + 2));
  v45 = v67;
  v46 = *((_QWORD *)&v67 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v67 + 1)], "x", v67 != *((_QWORD *)&v67 + 1) + 1);
  v47 = *((_QWORD *)&v67 + 1);
  if (v45 != v46)
    v47 = *((_QWORD *)&v67 + 1) + 1;
  *((_QWORD *)&v67 + 1) = v47;
  __s[v47] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((unsigned __int16 *)v4 + 3));
  v48 = v67;
  v49 = *((_QWORD *)&v67 + 1) + 1;
  this = (webrtc::VideoCodec *)memcpy(&__s[*((_QWORD *)&v67 + 1)], " ", v67 != *((_QWORD *)&v67 + 1) + 1);
  v50 = *((_QWORD *)&v67 + 1);
  if (v48 != v49)
    v50 = *((_QWORD *)&v67 + 1) + 1;
  *((_QWORD *)&v67 + 1) = v50;
  __s[v50] = 0;
  if (v16 >= 0x22u)
LABEL_43:
    rtc::webrtc_checks_impl::UnreachableCodeReached(this);
  if (qword_208F1D400[(char)v16] >= (_QWORD)v67 + ~*((_QWORD *)&v67 + 1))
    v51 = v67 + ~*((_QWORD *)&v67 + 1);
  else
    v51 = qword_208F1D400[(char)v16];
  memcpy(&__s[*((_QWORD *)&v67 + 1)], off_24C0C3020[(char)v16], v51);
  *((_QWORD *)&v67 + 1) += v51;
  __s[*((_QWORD *)&v67 + 1)] = 0;
  v52 = 8;
  if (*((_BYTE *)v4 + 24))
  {
    v53 = ", active";
  }
  else
  {
    v52 = 10;
    v53 = ", inactive";
  }
  if (v52 >= (_QWORD)v67 + ~*((_QWORD *)&v67 + 1))
    v54 = v67 + ~*((_QWORD *)&v67 + 1);
  else
    v54 = v52;
  memcpy(&__s[*((_QWORD *)&v67 + 1)], v53, v54);
  *((_QWORD *)&v67 + 1) += v54;
  __s[*((_QWORD *)&v67 + 1)] = 0;
LABEL_62:
  v55 = v67;
  v56 = *((_QWORD *)&v67 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v67 + 1)], "}", v67 != *((_QWORD *)&v67 + 1) + 1);
  v57 = *((_QWORD *)&v67 + 1);
  a2 = v65;
  if (v55 != v56)
    v57 = *((_QWORD *)&v67 + 1) + 1;
  *((_QWORD *)&v67 + 1) = v57;
  __s[v57] = 0;
  v13 = *((_QWORD *)&v67 + 1);
  v18 = v67;
  v17 = __s;
LABEL_65:
  memcpy(&v17[v13], "}", v18 != v13 + 1);
  v58 = *((_QWORD *)&v67 + 1);
  if (v18 != v13 + 1)
    v58 = *((_QWORD *)&v67 + 1) + 1;
  *((_QWORD *)&v67 + 1) = v58;
  __s[v58] = 0;
  v59 = __s;
  if (!__s)
  {
LABEL_79:
    __break(1u);
LABEL_80:
    abort();
  }
  result = strlen(__s);
  if (result >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_80;
  v61 = result;
  if (result <= 0x16)
  {
    a2[23] = result;
    v62 = &a2[result];
    if (a2 > v59)
      goto LABEL_76;
    goto LABEL_75;
  }
  v63 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((result | 7) != 0x17)
    v63 = result | 7;
  v64 = v63 + 1;
  result = (unint64_t)operator new(v63 + 1);
  *((_QWORD *)a2 + 1) = v61;
  *((_QWORD *)a2 + 2) = v64 | 0x8000000000000000;
  *(_QWORD *)a2 = result;
  a2 = (char *)result;
  v62 = (char *)(result + v61);
  if (result <= (unint64_t)v59)
  {
LABEL_75:
    if (v62 <= v59)
      goto LABEL_76;
    goto LABEL_79;
  }
LABEL_76:
  if (v61)
    result = (unint64_t)memmove(a2, v59, v61);
  *v62 = 0;
  return result;
}

uint64_t webrtc::VideoCodec::VP8(webrtc::VideoCodec *this)
{
  return (uint64_t)this + 356;
}

uint64_t webrtc::VideoCodec::VP9(webrtc::VideoCodec *this)
{
  return (uint64_t)this + 356;
}

uint64_t webrtc::PayloadStringToCodecType(uint64_t result)
{
  uint64_t v1;
  unsigned __int8 *v2;
  uint64_t v3;
  int v5;
  int v6;
  int v7;
  unsigned __int8 *v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  unsigned __int8 *v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  unsigned __int8 *v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned __int8 *v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;

  v1 = *(unsigned __int8 *)(result + 23);
  v2 = (unsigned __int8 *)result;
  v3 = v1;
  if (*(char *)(result + 23) < 0)
  {
    v3 = *(_QWORD *)(result + 8);
    if (v3 < 0)
      goto LABEL_123;
    v2 = *(unsigned __int8 **)result;
    if (v3 && v2 == 0)
      goto LABEL_123;
  }
  if (v3 == 3)
  {
    v5 = *v2;
    if (v5 == 86)
      goto LABEL_12;
    if ((v5 - 65) < 0x1A)
      LOBYTE(v5) = v5 + 32;
    if (v5 == 118)
    {
LABEL_12:
      v6 = v2[1];
      if (v6 == 80)
        goto LABEL_19;
      if ((v6 - 65) < 0x1A)
        LOBYTE(v6) = v6 + 32;
      if (v6 == 112)
      {
LABEL_19:
        v7 = v2[2];
        if (v7 == 56)
          return 1;
        if ((v7 - 65) < 0x1A)
          LOBYTE(v7) = v7 + 32;
        if (v7 == 56)
          return 1;
      }
    }
  }
  v8 = (unsigned __int8 *)result;
  v9 = *(unsigned __int8 *)(result + 23);
  if ((v1 & 0x80) != 0)
  {
    v9 = *(_QWORD *)(result + 8);
    if (v9 < 0)
      goto LABEL_123;
    v8 = *(unsigned __int8 **)result;
    if (v9)
    {
      if (!v8)
        goto LABEL_123;
    }
  }
  if (v9 == 3)
  {
    v10 = *v8;
    if (v10 == 86)
      goto LABEL_30;
    if ((v10 - 65) < 0x1A)
      LOBYTE(v10) = v10 + 32;
    if (v10 == 118)
    {
LABEL_30:
      v11 = v8[1];
      if (v11 == 80)
        goto LABEL_37;
      if ((v11 - 65) < 0x1A)
        LOBYTE(v11) = v11 + 32;
      if (v11 == 112)
      {
LABEL_37:
        v12 = v8[2];
        if (v12 == 57)
          return 2;
        if ((v12 - 65) < 0x1A)
          LOBYTE(v12) = v12 + 32;
        if (v12 == 57)
          return 2;
      }
    }
  }
  v13 = (unsigned __int8 *)result;
  v14 = *(unsigned __int8 *)(result + 23);
  if ((v1 & 0x80) != 0)
  {
    v14 = *(_QWORD *)(result + 8);
    if (v14 < 0)
      goto LABEL_123;
    v13 = *(unsigned __int8 **)result;
    if (v14)
    {
      if (!v13)
        goto LABEL_123;
    }
  }
  if (v14 == 3)
  {
    v15 = *v13;
    if (v15 == 65)
      goto LABEL_48;
    if ((v15 - 65) < 0x1A)
      LOBYTE(v15) = v15 + 32;
    if (v15 == 97)
    {
LABEL_48:
      v16 = v13[1];
      if (v16 == 86)
        goto LABEL_55;
      if ((v16 - 65) < 0x1A)
        LOBYTE(v16) = v16 + 32;
      if (v16 == 118)
      {
LABEL_55:
        v17 = v13[2];
        if (v17 == 49)
          return 3;
        if ((v17 - 65) < 0x1A)
          LOBYTE(v17) = v17 + 32;
        if (v17 == 49)
          return 3;
      }
    }
  }
  v18 = (unsigned __int8 *)result;
  v19 = *(unsigned __int8 *)(result + 23);
  if ((v1 & 0x80) != 0)
  {
    v19 = *(_QWORD *)(result + 8);
    if (v19 < 0)
      goto LABEL_123;
    v18 = *(unsigned __int8 **)result;
    if (v19)
    {
      if (!v18)
        goto LABEL_123;
    }
  }
  if (v19 == 4)
  {
    v20 = *v18;
    if (v20 == 65)
      goto LABEL_65;
    if ((v20 - 65) < 0x1A)
      LOBYTE(v20) = v20 + 32;
    if (v20 == 97)
    {
LABEL_65:
      v21 = v18[1];
      if (v21 == 86)
        goto LABEL_76;
      if ((v21 - 65) < 0x1A)
        LOBYTE(v21) = v21 + 32;
      if (v21 == 118)
      {
LABEL_76:
        v22 = v18[2];
        if (v22 == 49)
          goto LABEL_126;
        if ((v22 - 65) < 0x1A)
          LOBYTE(v22) = v22 + 32;
        if (v22 == 49)
        {
LABEL_126:
          v23 = v18[3];
          if (v23 == 88)
            return 3;
          if ((v23 - 65) < 0x1A)
            LOBYTE(v23) = v23 + 32;
          if (v23 == 120)
            return 3;
        }
      }
    }
  }
  v24 = (unsigned __int8 *)result;
  v25 = *(unsigned __int8 *)(result + 23);
  if ((v1 & 0x80) != 0)
  {
    v25 = *(_QWORD *)(result + 8);
    if (v25 < 0)
      goto LABEL_123;
    v24 = *(unsigned __int8 **)result;
    if (v25)
    {
      if (!v24)
        goto LABEL_123;
    }
  }
  if (v25 == 4)
  {
    v26 = *v24;
    if (v26 == 72)
      goto LABEL_87;
    if ((v26 - 65) < 0x1A)
      LOBYTE(v26) = v26 + 32;
    if (v26 == 104)
    {
LABEL_87:
      v27 = v24[1];
      if (v27 == 50)
        goto LABEL_98;
      if ((v27 - 65) < 0x1A)
        LOBYTE(v27) = v27 + 32;
      if (v27 == 50)
      {
LABEL_98:
        v28 = v24[2];
        if (v28 == 54)
          goto LABEL_127;
        if ((v28 - 65) < 0x1A)
          LOBYTE(v28) = v28 + 32;
        if (v28 == 54)
        {
LABEL_127:
          v29 = v24[3];
          if (v29 == 52)
            return 4;
          if ((v29 - 65) < 0x1A)
            LOBYTE(v29) = v29 + 32;
          if (v29 == 52)
            return 4;
        }
      }
    }
  }
  if ((v1 & 0x80) != 0 && ((v1 = *(_QWORD *)(result + 8), v1 < 0) || (result = *(_QWORD *)result, v1) && !result))
  {
LABEL_123:
    __break(1u);
  }
  else
  {
    if (v1 != 4)
      return 0;
    v30 = *(unsigned __int8 *)result;
    if (v30 != 72)
    {
      if ((v30 - 65) < 0x1A)
        LOBYTE(v30) = v30 + 32;
      if (v30 != 104)
        return 0;
    }
    v31 = *(unsigned __int8 *)(result + 1);
    if (v31 != 50)
    {
      if ((v31 - 65) < 0x1A)
        LOBYTE(v31) = v31 + 32;
      if (v31 != 50)
        return 0;
    }
    v32 = *(unsigned __int8 *)(result + 2);
    if (v32 != 54)
    {
      if ((v32 - 65) < 0x1A)
        LOBYTE(v32) = v32 + 32;
      if (v32 != 54)
        return 0;
    }
    v33 = *(unsigned __int8 *)(result + 3);
    if (v33 == 53)
      return 5;
    if ((v33 - 65) < 0x1A)
      LOBYTE(v33) = v33 + 32;
    if (v33 == 53)
      return 5;
    else
      return 0;
  }
  return result;
}

void webrtc::VideoCodecInitializer::SetupCodec(uint64_t a1@<X0>, int *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, int *a9@<X8>)
{
  uint64_t v9;
  int *v12;
  _QWORD *v13;
  unsigned int v14;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  BOOL v24;
  uint64_t v25;
  unint64_t v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  int *v30;
  uint64_t v31;
  int64x2_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  unsigned int v38;
  int v39;
  int v40;
  __int16 v41;
  __int16 v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  int v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char v67;
  uint64_t v68;
  _BYTE *v69;
  _BYTE *v70;
  size_t v71;
  unint64_t v72;
  char *v73;
  char *v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  _BYTE *v80;
  char *v81;
  char v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unsigned __int8 *v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  float v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  _BYTE *v110;
  char v111;
  char v112;
  uint64_t v113;
  char *v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  char v118;
  unint64_t v119;
  unint64_t v120;
  uint64_t v121;
  int *v122;
  __int128 v123;
  __int128 v124;
  int v125;
  int v126;
  uint64_t v127;
  char v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  unsigned int v133;
  _QWORD *v135;
  int *v136;
  _QWORD *v137;
  unint64_t v138;
  char *v139;
  char *v140;
  char *v141;
  char *v142;
  char v143;

  *(_QWORD *)a9 = 0;
  *((_QWORD *)a9 + 1) = 0;
  *((_QWORD *)a9 + 2) = 0;
  *((_BYTE *)a9 + 24) = 1;
  a9[7] = 0;
  *((_BYTE *)a9 + 32) = 0;
  *(_OWORD *)(a9 + 9) = 0u;
  *(_OWORD *)(a9 + 13) = 0u;
  *(_OWORD *)(a9 + 17) = 0u;
  *(_OWORD *)(a9 + 21) = 0u;
  *(_OWORD *)(a9 + 25) = 0u;
  *(_OWORD *)(a9 + 29) = 0u;
  *((_OWORD *)a9 + 8) = 0u;
  *((_BYTE *)a9 + 48) = 1;
  *(_QWORD *)(a9 + 15) = 0;
  *(_QWORD *)(a9 + 13) = 0;
  *((_BYTE *)a9 + 68) = 0;
  *((_BYTE *)a9 + 84) = 1;
  *((_BYTE *)a9 + 104) = 0;
  *((_QWORD *)a9 + 11) = 0;
  *((_QWORD *)a9 + 12) = 0;
  *((_BYTE *)a9 + 120) = 1;
  *(_QWORD *)(a9 + 33) = 0;
  *(_QWORD *)(a9 + 31) = 0;
  *((_BYTE *)a9 + 140) = 0;
  a9[80] = 0;
  *((_OWORD *)a9 + 18) = 0u;
  *((_OWORD *)a9 + 19) = 0u;
  *((_OWORD *)a9 + 16) = 0u;
  *((_OWORD *)a9 + 17) = 0u;
  *((_OWORD *)a9 + 14) = 0u;
  *((_OWORD *)a9 + 15) = 0u;
  *((_OWORD *)a9 + 12) = 0u;
  *((_OWORD *)a9 + 13) = 0u;
  *((_OWORD *)a9 + 11) = 0u;
  *((_OWORD *)a9 + 9) = 0u;
  *((_OWORD *)a9 + 10) = 0u;
  v12 = a9 + 40;
  *((_BYTE *)a9 + 156) = 1;
  *((_QWORD *)a9 + 21) = 0;
  *((_QWORD *)a9 + 20) = 0;
  *((_BYTE *)a9 + 176) = 0;
  *((_BYTE *)a9 + 192) = 1;
  *(_QWORD *)(a9 + 51) = 0;
  *(_QWORD *)(a9 + 49) = 0;
  *((_BYTE *)a9 + 212) = 0;
  *((_BYTE *)a9 + 228) = 1;
  *((_QWORD *)a9 + 29) = 0;
  *((_QWORD *)a9 + 30) = 0;
  *((_BYTE *)a9 + 248) = 0;
  *((_BYTE *)a9 + 264) = 1;
  *(_QWORD *)(a9 + 69) = 0;
  *(_QWORD *)(a9 + 67) = 0;
  *((_BYTE *)a9 + 284) = 0;
  *((_BYTE *)a9 + 300) = 1;
  *((_QWORD *)a9 + 38) = 0;
  *((_QWORD *)a9 + 39) = 0;
  *((_BYTE *)a9 + 320) = 0;
  a9[81] = 0;
  *((_BYTE *)a9 + 328) = 0;
  *((_QWORD *)a9 + 42) = 0;
  *((_WORD *)a9 + 172) = 0;
  v13 = a9 + 89;
  a9[94] = 0;
  *(_QWORD *)(a9 + 91) = 0;
  *(_QWORD *)(a9 + 89) = 0;
  *((_WORD *)a9 + 186) = 0;
  *a9 = *a2;
  v14 = a2[34];
  if (v14 <= 1)
    a9[81] = v14;
  v16 = v14 == 1 && *((_BYTE *)a2 + 200) != 0;
  *((_BYTE *)a9 + 352) = v16;
  *((_BYTE *)a9 + 380) = *((_BYTE *)a2 + 140);
  v17 = *a3;
  v18 = a3[1];
  *((_BYTE *)a9 + 32) = -85 * ((v18 - *a3) >> 5);
  if (v18 == v17)
  {
LABEL_173:
    __break(1u);
LABEL_174:
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/svc/scalability_mode_util.cc", 309, "index < kNumScalabilityModes", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long> const&)::t, a5, a6, a7, a8, v9);
    goto LABEL_175;
  }
  v19 = *(_DWORD *)(v17 + 20) / 1000;
  a9[4] = v19;
  v21 = *((_QWORD *)a2 + 21);
  v20 = *((_QWORD *)a2 + 22);
  if (v21 == v20)
  {
    v23 = 0;
    v136 = v12;
    v137 = v13;
    v135 = a2;
    *((_BYTE *)a9 + 24) = 0;
    if (v19 > 0x1D)
      goto LABEL_19;
  }
  else
  {
    v22 = v21 + 96;
    do
    {
      v23 = *(_BYTE *)(v22 - 14) != 0;
      if (*(_BYTE *)(v22 - 14))
        v24 = 1;
      else
        v24 = v22 == v20;
      v22 += 96;
    }
    while (!v24);
    v136 = v12;
    v137 = v13;
    v135 = a2;
    *((_BYTE *)a9 + 24) = v23;
    if (v19 > 0x1D)
      goto LABEL_19;
  }
  a9[4] = 30;
LABEL_19:
  v25 = 0;
  v26 = 0;
  v27 = 0;
  *((_QWORD *)a9 + 42) = 200;
  *((_WORD *)a9 + 172) = 500;
  v133 = *(unsigned __int16 *)(v17 + 80);
  v28 = v133 >> 8;
  v29 = 82;
  do
  {
    v30 = &a9[v25];
    v31 = v17 + v29;
    v32 = *(int64x2_t *)(v17 + v29 - 82);
    *(int8x8_t *)(v30 + 9) = vand_s8((int8x8_t)vmovn_s64(v32), (int8x8_t)0xFFFF0000FFFFLL);
    *((float *)v30 + 11) = (float)*(int *)(v17 + v29 - 66);
    v33 = 274877907 * *(int *)(v17 + v29 - 62);
    v34 = (v33 >> 38) + ((unint64_t)v33 >> 63);
    v30[15] = v34;
    v35 = 274877907 * *(int *)(v17 + v29 - 58);
    v30[14] = (v35 >> 38) + ((unint64_t)v35 >> 63);
    v36 = 274877907 * *(int *)(v17 + v29 - 54);
    v37 = (v36 >> 38) + ((unint64_t)v36 >> 63);
    v30[13] = v37;
    v38 = *(_DWORD *)(v17 + v29 - 42);
    v30[16] = v38;
    v39 = *(unsigned __int8 *)(v17 + v29 - 1);
    if (*(_BYTE *)(v17 + v29 - 1))
    {
      v9 = *(unsigned __int8 *)(v31 - 2);
      if (v9 >= 0x22)
        goto LABEL_174;
                                                                                 + 28];
    }
    else if (*(_BYTE *)(v31 - 26))
    {
      v9 = *(_QWORD *)(v31 - 34);
    }
    else
    {
      v9 = 1;
    }
    LOBYTE(a9[v25 + 12]) = v9;
    if (0xAAAAAAAAAAAAAAABLL * ((v18 - v17) >> 5) <= v26)
      goto LABEL_173;
    v40 = *(unsigned __int8 *)(v17 + v29);
    LOBYTE(a9[v25 + 17]) = v40;
    v41 = v32.i16[0];
    if (*((unsigned __int16 *)a9 + 2) > v32.u16[0])
      v41 = *((_WORD *)a9 + 2);
    *((_WORD *)a9 + 2) = v41;
    v42 = v32.i16[4];
    if (*((unsigned __int16 *)a9 + 3) > v32.u16[4])
      v42 = *((_WORD *)a9 + 3);
    *((_WORD *)a9 + 3) = v42;
    v34 = (unsigned __int16)v34;
    if ((unsigned __int16)v34 >= *((unsigned __int16 *)a9 + 8))
      v34 = *((unsigned __int16 *)a9 + 8);
    v9 = a9[3];
    a9[3] = v9 + v37;
    a9[4] = v34;
    v43 = a9[7];
    if (v43 <= v38)
      v43 = v38;
    a9[7] = v43;
    if (v27 <= *(_DWORD *)(v31 - 66))
      v27 = *(_DWORD *)(v31 - 66);
    if (v40)
    {
      if (*(_BYTE *)(v17 + 81) && v39)
      {
        if (*(unsigned __int8 *)(v17 + 80) == *(unsigned __int8 *)(v31 - 2))
          goto LABEL_21;
      }
      else if ((*(_BYTE *)(v17 + 81) != 0) == (v39 != 0))
      {
        goto LABEL_21;
      }
      if (*a9 == 1)
      {
        v28 = 0;
      }
      else
      {
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        {
          v138 = v138 & 0xFFFFFFFF00000000 | 0x432;
          rtc::webrtc_logging_impl::Log("\r\t", v44, v45, a4, a5, a6, a7, a8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc");
        }
        v28 = 0;
      }
    }
LABEL_21:
    ++v26;
    v17 = *a3;
    v18 = a3[1];
    v29 += 96;
    v25 += 9;
  }
  while (v26 < 0xAAAAAAAAAAAAAAABLL * ((v18 - *a3) >> 5));
  if (v28)
    *((_WORD *)a9 + 186) = v133 | 0x100;
  v46 = a9[3];
  if (v46)
  {
    if (v46 <= 0x1D)
      goto LABEL_53;
  }
  else
  {
    v52 = *((unsigned __int16 *)a9 + 3) * *((unsigned __int16 *)a9 + 2) * a9[5] / 0x3E8;
    a9[3] = v52;
    if (v52 <= 0x1D)
LABEL_53:
      a9[3] = 30;
  }
  a9[5] = v27;
  *((_BYTE *)a9 + 156) = 1;
  *(_QWORD *)v136 = 0;
  *((_QWORD *)v136 + 1) = 0;
  *((_BYTE *)v136 + 16) = 0;
  v47 = *((unsigned __int16 *)a9 + 3);
  a9[36] = *((unsigned __int16 *)a9 + 2);
  a9[37] = v47;
  *((float *)a9 + 38) = (float)v27;
  if (v18 == v17)
    goto LABEL_173;
  if (*(_BYTE *)(v17 + 81))
  {
    v48 = *(unsigned __int8 *)(v17 + 80);
    v49 = v135;
    if (v48 < 0x22)
    {
                                                                                             + 28];
      v50 = (_QWORD *)v135[18];
      v51 = *a9;
      if (!v50)
        goto LABEL_69;
LABEL_67:
      if ((v51 - 1) <= 2)
      {
        (*(void (**)(void))(*v50 + 8 * (v51 - 1) + 32))();
        v51 = *a9;
      }
      goto LABEL_69;
    }
    while (1)
LABEL_175:
      rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/svc/scalability_mode_util.cc", 309, "index < kNumScalabilityModes", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long> const&)::t, a5, a6, a7, a8, v48);
  }
  v49 = v135;
  if (!*(_BYTE *)(v17 + 56))
  {
    *((_BYTE *)a9 + 156) = 1;
    v50 = (_QWORD *)v135[18];
    v51 = *a9;
    if (!v50)
      goto LABEL_69;
    goto LABEL_67;
  }
  *((_BYTE *)a9 + 156) = *(_QWORD *)(v17 + 48);
  v50 = (_QWORD *)v135[18];
  v51 = *a9;
  if (v50)
    goto LABEL_67;
LABEL_69:
  switch(v51)
  {
    case 1:
      if (!v49[18])
        *v137 = 0xBB800000101;
      v54 = *a3;
      v53 = a3[1];
      if (*a3 == v53)
        goto LABEL_173;
      v55 = *a3;
      while (!*(_BYTE *)(v55 + 81) || *(unsigned __int8 *)(v55 + 80) < 3u)
      {
        v55 += 96;
        if (v55 == v53)
          goto LABEL_83;
      }
      v56 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>();
      if ((v56 & 1) != 0)
        goto LABEL_81;
      if (!*(_BYTE *)(v55 + 81))
        goto LABEL_173;
      v60 = *(char *)(v55 + 80);
      if (v60 >= 0x22)
        rtc::webrtc_checks_impl::UnreachableCodeReached((rtc::webrtc_checks_impl *)v56);
      v61 = v60;
      v62 = *(char **)((char *)&unk_208F1D528 + v61 * 8);
      v141 = off_24C0C3160[v61];
      v142 = v62;
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*> const&)::t, v57, v58, v59, a5, a6, a7, a8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc");
LABEL_81:
      if (!*(_BYTE *)(v55 + 81))
        goto LABEL_173;
      *((_WORD *)a9 + 186) = *(unsigned __int8 *)(v55 + 80) | 0x100;
      v54 = *a3;
      v53 = a3[1];
LABEL_83:
      if (v54 == v53)
        goto LABEL_173;
      if (*(_BYTE *)(v53 - 15))
      {
        v48 = *(unsigned __int8 *)(v53 - 16);
        if (v48 >= 0x22)
          goto LABEL_175;
      }
      else
      {
        if (*(_BYTE *)(v53 - 40))
          v75 = *(_QWORD *)(v53 - 48);
        else
          LOBYTE(v75) = *(_BYTE *)v137;
        *(_BYTE *)v137 = v75;
      }
      goto LABEL_163;
    case 2:
      if (*((unsigned __int8 *)a9 + 32) > 1u)
      {
        if (v49[18])
          goto LABEL_89;
LABEL_99:
        *(_OWORD *)v137 = xmmword_208F1D510;
        v63 = a3[1];
        if (*a3 == v63)
          goto LABEL_173;
        goto LABEL_100;
      }
      *((_BYTE *)a9 + 68) = v23;
      if (!v49[18])
        goto LABEL_99;
LABEL_89:
      v63 = a3[1];
      if (*a3 == v63)
        goto LABEL_173;
LABEL_100:
      if (!*(_BYTE *)(v63 - 40))
      {
        v68 = *(unsigned __int8 *)v137;
        *(_BYTE *)v137 = v68;
        v70 = (_BYTE *)v49[14];
        v69 = (_BYTE *)v49[15];
        if (v70 != v69)
          goto LABEL_102;
LABEL_121:
        if (*((unsigned __int16 *)a9 + 186) > 0xFFu)
        {
          webrtc::GetVp9SvcConfig((webrtc *)a9, v68, a6, a7, a8, (uint64_t)&v141);
          v73 = v141;
          v74 = v142;
        }
        else
        {
          v90 = v49[21];
          v91 = v49[22] - v90;
          if (v91)
          {
            v92 = 0;
            v93 = v91 / 96;
            if (v93 <= 1)
              v93 = 1;
            v94 = (unsigned __int8 *)(v90 + 82);
            while (1)
            {
              v95 = *v94;
              v94 += 96;
              if (v95)
                break;
              if (v93 == ++v92)
                goto LABEL_128;
            }
          }
          else
          {
LABEL_128:
            v92 = 0;
          }
          v96 = *((unsigned __int16 *)a9 + 2);
          v97 = *((unsigned __int16 *)a9 + 3);
          v98 = (float)a9[5];
          v99 = *((unsigned __int8 *)a9 + 366);
          if (a9[81] == 1)
          {
            webrtc::ConfigureSvcScreenSharing((webrtc *)v96, v98, v97, *((unsigned __int8 *)a9 + 366), &v139);
          }
          else
          {
            LOBYTE(v141) = 0;
            v143 = 0;
            webrtc::ConfigureSvcNormalVideo(v96, v97, v92, v99, v68, (uint64_t)&v141, &v139, v98);
          }
          v73 = v139;
          v74 = v140;
          if (*((unsigned __int8 *)a9 + 366) <= 1u)
          {
            if (v139 == v140)
              goto LABEL_173;
            v100 = *(_QWORD *)(a9 + 3);
            *((_QWORD *)v140 - 2) = v100;
            *((_DWORD *)v74 - 5) = v100;
          }
          v101 = v49[21];
          v102 = 0xAAAAAAAAAAAAAAABLL * ((v49[22] - v101) >> 5);
          if (v92 < v102)
          {
            v103 = (v74 - v73) / 36;
            v104 = v103 + v92;
            if (v92 > v103 + v92)
              v104 = v92;
            v105 = v102 + ~v92;
            if (v103 < v105)
              v105 = (v74 - v73) / 36;
            if (v105 >= v104 - v92)
              v105 = v104 - v92;
            v106 = v105 + 1;
            v107 = v92;
            if (v106 >= 3)
            {
              v108 = v106 & 1;
              if ((v106 & 1) == 0)
                v108 = 2;
              v109 = v106 - v108;
              v107 = v92 + v109;
              v110 = v73 + 68;
              v9 = v101 + 96 * v92 + 178;
              do
              {
                v111 = *(_BYTE *)(v9 - 96);
                v112 = *(_BYTE *)v9;
                v9 += 192;
                *(v110 - 36) = v111;
                *v110 = v112;
                v110 += 72;
                v109 -= 2;
              }
              while (v109);
            }
            v113 = -36 * v92 + 36 * v107 + 32;
            v114 = (char *)(v101 + 96 * v107 + 82);
            v115 = v102 - v107;
            v116 = v92 + v103 - v107;
            v117 = v104 - v107;
            do
            {
              if (!v117)
                break;
              if (!v116)
                goto LABEL_173;
              v118 = *v114;
              v114 += 96;
              v73[v113] = v118;
              v113 += 36;
              --v116;
              --v117;
              --v115;
            }
            while (v115);
          }
        }
        goto LABEL_155;
      }
      v68 = *(unsigned __int8 *)(v63 - 48);
      *(_BYTE *)v137 = v68;
      v70 = (_BYTE *)v49[14];
      v69 = (_BYTE *)v49[15];
      if (v70 == v69)
        goto LABEL_121;
LABEL_102:
      v71 = v69 - v70;
      v72 = 0x8E38E38E38E38E39 * ((v69 - v70) >> 2);
      if (v72 >= 0x71C71C71C71C71DLL)
LABEL_178:
        abort();
      v73 = (char *)operator new(v71);
      memcpy(v73, v70, v71 - 3);
      v74 = &v73[36 * v72];
LABEL_155:
      if (v74 == v73)
        goto LABEL_173;
      v119 = 0;
      v120 = (v74 - v73) / 36;
      if (v120 <= 1)
        v121 = 1;
      else
        v121 = (v74 - v73) / 36;
      do
      {
        v122 = &a9[v119 / 4 + 36];
        v123 = *(_OWORD *)&v73[v119];
        v124 = *(_OWORD *)&v73[v119 + 16];
        *((_BYTE *)v122 + 32) = v73[v119 + 32];
        *(_OWORD *)v122 = v123;
        *((_OWORD *)v122 + 1) = v124;
        v119 += 36;
        --v121;
      }
      while (v121);
      v125 = *((_DWORD *)v74 - 9);
      *((_WORD *)a9 + 2) = v125;
      v126 = *((_DWORD *)v74 - 8);
      *((_WORD *)a9 + 3) = v126;
      if (*((_BYTE *)a9 + 32) == 1)
      {
        a9[9] = v125;
        a9[10] = v126;
      }
      *((_BYTE *)a9 + 366) = v120;
      *((_BYTE *)a9 + 356) = *(v74 - 24);
      operator delete(v73);
LABEL_163:
      webrtc::GetExperimentalMinVideoBitrate(a1, *a9);
      if (v128)
      {
        v129 = v127 / 0x3E8uLL;
        if (v127 % 0x3E8uLL > 0x1F3)
          ++v129;
        if (-v127 % 0x3E8uLL <= 0x1F4)
          v130 = 0;
        else
          v130 = -1;
        v131 = v130 - -v127 / 0x3E8uLL;
        if (v127 >= 0)
          v131 = v129;
        __asm { BR              X12 }
      }
      return;
    case 3:
      v64 = a3[1];
      if (*a3 == v64)
        goto LABEL_173;
      if (*(_BYTE *)(v64 - 40))
        v65 = *(unsigned int *)(v64 - 48);
      else
        v65 = 1;
      if ((int)(954437177 * ((v49[15] - v49[14]) >> 2)) <= 1)
        v76 = 1;
      else
        v76 = 954437177 * ((v49[15] - v49[14]) >> 2);
      if (webrtc::SetAv1SvcConfig((webrtc *)a9, (webrtc::VideoCodec *)v65, v76, a4, a5, a6, a7, a8))
      {
        v77 = v49[14];
        v78 = v49[15] - v77;
        if (v78)
        {
          v79 = v78 / 36;
          if (v79 <= 1)
            v79 = 1;
          v80 = a9 + 44;
          v81 = (char *)(v77 + 32);
          do
          {
            v82 = *v81;
            v81 += 36;
            *v80 = v82;
            v80 += 36;
            --v79;
          }
          while (v79);
        }
      }
      else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      {
        rtc::webrtc_logging_impl::Log("\r\t", v83, v84, v85, v86, v87, v88, v89, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc");
      }
      goto LABEL_163;
    case 4:
      if (!v49[18])
      {
        *v137 = 0x100000BB8;
        v66 = a3[1];
        if (*a3 == v66)
          goto LABEL_173;
        if (*(_BYTE *)(v66 - 40))
          v67 = *(_BYTE *)(v66 - 48);
        else
          v67 = 1;
        *((_BYTE *)a9 + 360) = v67;
        goto LABEL_163;
      }
      rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc", 312, "!config.encoder_specific_settings", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v132);
      goto LABEL_178;
    default:
      goto LABEL_163;
  }
}

void webrtc::CodecSpecificInfo::~CodecSpecificInfo(webrtc::CodecSpecificInfo *this)
{
  if (*((_BYTE *)this + 1984))
    webrtc::FrameDependencyStructure::~FrameDependencyStructure((webrtc::CodecSpecificInfo *)((char *)this + 1856));
  if (*((_BYTE *)this + 1848))
    webrtc::GenericFrameInfo::~GenericFrameInfo((webrtc::CodecSpecificInfo *)((char *)this + 1640));
}

uint64_t webrtc::DecodedImageCallback::Decoded(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
}

uint64_t webrtc::DecodedImageCallback::Decoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a3 & 0xFF00000000) != 0)
    a3 = (int)a3;
  else
    a3 = -1;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 24))(a1, a2, a3);
}

std::string *webrtc::VideoDecoder::GetDecoderInfo@<X0>(webrtc::VideoDecoder *this@<X0>, std::string *a2@<X8>)
{
  std::string *result;

  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2[1].__r_.__value_.__s.__data_[0] = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  result = (std::string *)(*(uint64_t (**)(webrtc::VideoDecoder *))(*(_QWORD *)this + 64))(this);
  if (result)
    return std::string::__assign_external(a2, (const std::string::value_type *)result);
  __break(1u);
  return result;
}

const char *webrtc::VideoDecoder::ImplementationName(webrtc::VideoDecoder *this)
{
  return "unknown";
}

unint64_t webrtc::VideoDecoder::DecoderInfo::ToString@<X0>(webrtc::VideoDecoder::DecoderInfo *this@<X0>, char *a2@<X8>)
{
  unint64_t v4;
  webrtc::VideoDecoder::DecoderInfo *v5;
  size_t v6;
  size_t v7;
  char *v8;
  size_t v9;
  size_t v10;
  char *v11;
  size_t v12;
  size_t v13;
  unint64_t v14;
  const char *v15;
  size_t v16;
  size_t v17;
  size_t v18;
  unint64_t result;
  size_t v20;
  char *v21;
  _BOOL4 v22;
  uint64_t v23;
  uint64_t v24;
  char __s[2048];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  strcpy(__s, "DecoderInfo { prefers_late_decoding = implementation_name = '");
  if (*((char *)this + 23) < 0)
  {
    v4 = *((_QWORD *)this + 1);
    if ((v4 & 0x8000000000000000) != 0 || (v5 = *(webrtc::VideoDecoder::DecoderInfo **)this, v4) && !v5)
    {
LABEL_35:
      __break(1u);
      goto LABEL_36;
    }
  }
  else
  {
    v4 = *((unsigned __int8 *)this + 23);
    v5 = this;
  }
  if (v4 >= 0x7C2)
    v6 = 1986;
  else
    v6 = v4;
  memcpy(&__s[61], v5, v6);
  v7 = v6 + 61;
  v8 = &__s[v6 + 61];
  *v8 = 0;
  if (1986 - v6 >= 3)
    v9 = 3;
  else
    v9 = 1986 - v6;
  memcpy(v8, "', ", v9);
  v10 = v9 + v7;
  v11 = &__s[v9 + v7];
  *v11 = 0;
  if (2047 - (v9 + v7) >= 0x1A)
    v12 = 26;
  else
    v12 = 2047 - v10;
  memcpy(v11, "is_hardware_accelerated = ", v12);
  v13 = v12 + v10;
  __s[v13] = 0;
  v14 = 4;
  if (*((_BYTE *)this + 24))
  {
    v15 = "true";
  }
  else
  {
    v14 = 5;
    v15 = "false";
  }
  if (v14 >= 2047 - v13)
    v16 = 2047 - v13;
  else
    v16 = v14;
  memcpy(&__s[v13], v15, v16);
  v17 = v16 + v13;
  __s[v17] = 0;
  if (2047 - v17 >= 2)
    v18 = 2;
  else
    v18 = 2047 - v17;
  memcpy(&__s[v17], " }", v18);
  __s[v18 + v17] = 0;
  result = strlen(__s);
  if (result >= 0x7FFFFFFFFFFFFFF8)
LABEL_36:
    abort();
  v20 = result;
  if (result <= 0x16)
  {
    a2[23] = result;
    v21 = &a2[result];
    v22 = &a2[result] > __s;
    if (a2 > __s)
      goto LABEL_32;
    goto LABEL_31;
  }
  v23 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((result | 7) != 0x17)
    v23 = result | 7;
  v24 = v23 + 1;
  result = (unint64_t)operator new(v23 + 1);
  *((_QWORD *)a2 + 1) = v20;
  *((_QWORD *)a2 + 2) = v24 | 0x8000000000000000;
  *(_QWORD *)a2 = result;
  a2 = (char *)result;
  v21 = (char *)(result + v20);
  v22 = result + v20 > (unint64_t)__s;
  if (result <= (unint64_t)__s)
  {
LABEL_31:
    if (!v22)
      goto LABEL_32;
    goto LABEL_35;
  }
LABEL_32:
  if (v20)
    result = (unint64_t)memcpy(a2, __s, v20);
  *v21 = 0;
  return result;
}

uint64_t webrtc::VideoDecoder::Settings::set_number_of_cores(uint64_t this, int a2)
{
  *(_DWORD *)(this + 16) = a2;
  return this;
}

void webrtc::CreateVideoDecoderSoftwareFallbackWrapper(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  std::string *p_p;
  std::string::size_type size;
  BOOL v13;
  int data;
  int v15;
  std::string::size_type v17;
  std::string::size_type v18;
  std::string *v19;
  char *v20;
  std::string::size_type v21;
  size_t v22;
  BOOL v23;
  char *v24;
  std::string::size_type v25;
  std::string::size_type v26;
  std::string *v27;
  char *v28;
  std::string::size_type v29;
  unint64_t v30;
  std::string::size_type v31;
  int v32;
  uint64_t v33;
  std::string::size_type v34;
  std::string::size_type v35;
  BOOL v36;
  std::string *v37;
  _BYTE *v38;
  std::string::size_type v39;
  void *v40;
  size_t v41;
  unsigned __int8 v42;
  std::string __p;
  std::string v44;
  std::string v45;

  v8 = operator new();
  v9 = *a2;
  *a2 = 0;
  v10 = *a3;
  *a3 = 0;
  *(_QWORD *)v8 = off_24C0C3310;
  *(_DWORD *)(v8 + 8) = 0;
  *(_QWORD *)(v8 + 16) = v10;
  (*(void (**)(std::string *__return_ptr, _QWORD, const char *, uint64_t))(**(_QWORD **)(a1 + 8) + 16))(&__p, *(_QWORD *)(a1 + 8), "WebRTC-Video-ForcedSwDecoderFallback", 36);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    size = __p.__r_.__value_.__l.__size_;
    if ((__p.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
      goto LABEL_79;
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (__p.__r_.__value_.__l.__size_)
    {
      if (!__p.__r_.__value_.__r.__words[0])
        goto LABEL_79;
    }
  }
  else
  {
    p_p = &__p;
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  if (size < 7)
  {
    v13 = 0;
    if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) == 0)
      goto LABEL_17;
    goto LABEL_16;
  }
  data = (int)p_p->__r_.__value_.__l.__data_;
  v15 = *(_DWORD *)((char *)p_p->__r_.__value_.__r.__words + 3);
  v13 = data == 1650552389 && v15 == 1684368482;
  if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
LABEL_16:
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_17:
  *(_BYTE *)(v8 + 24) = v13;
  *(_BYTE *)(v8 + 28) = 0;
  *(_BYTE *)(v8 + 32) = 0;
  *(_OWORD *)(v8 + 36) = xmmword_208F05120;
  *(_QWORD *)(v8 + 56) = v9;
  (*(void (**)(std::string *__return_ptr, uint64_t))(*(_QWORD *)v9 + 56))(&__p, v9);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = 22;
  else
    v17 = (__p.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v18 = __p.__r_.__value_.__l.__size_;
  if (v17 - v18 >= 0x11)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v19 = &__p;
    else
      v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
    v20 = (char *)v19 + v18;
    if ((char *)v19 + v18 <= " (fallback from: " && v20 + 17 > " (fallback from: ")
      goto LABEL_79;
    v20[16] = 32;
    *(_OWORD *)v20 = *(_OWORD *)" (fallback from: ";
    v21 = v18 + 17;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      __p.__r_.__value_.__l.__size_ = v18 + 17;
    else
      *((_BYTE *)&__p.__r_.__value_.__s + 23) = v21 & 0x7F;
    v19->__r_.__value_.__s.__data_[v21] = 0;
  }
  else
  {
    std::string::__grow_by_and_replace(&__p, v17, v18 - v17 + 17, v18, v18, 0, 0x11uLL, " (fallback from: ");
  }
  v44 = __p;
  memset(&__p, 0, sizeof(__p));
  (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v10 + 56))(&v40, v10);
  if ((char)v42 < 0)
  {
    v24 = (char *)v40;
    v22 = v41;
    v23 = v41 == 0;
    if (!v40 && v41)
      goto LABEL_79;
  }
  else
  {
    v22 = v42;
    v23 = v42 == 0;
    v24 = (char *)&v40;
  }
  if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v25 = 22;
  else
    v25 = (v44.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v26 = HIBYTE(v44.__r_.__value_.__r.__words[2]);
  else
    v26 = v44.__r_.__value_.__l.__size_;
  if (v25 - v26 >= v22)
  {
    if (!v23)
    {
      if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v27 = &v44;
      else
        v27 = (std::string *)v44.__r_.__value_.__r.__words[0];
      v28 = (char *)v27 + v26;
      if ((char *)v27 + v26 <= v24 && &v28[v22] > v24)
        goto LABEL_79;
      memmove(v28, v24, v22);
      v29 = v26 + v22;
      if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
        v44.__r_.__value_.__l.__size_ = v26 + v22;
      else
        *((_BYTE *)&v44.__r_.__value_.__s + 23) = v29 & 0x7F;
      v27->__r_.__value_.__s.__data_[v29] = 0;
    }
  }
  else
  {
    std::string::__grow_by_and_replace(&v44, v25, v26 + v22 - v25, v26, v26, 0, v22, v24);
  }
  v30 = v44.__r_.__value_.__r.__words[2];
  v45 = v44;
  memset(&v44, 0, sizeof(v44));
  v31 = HIBYTE(v30);
  v32 = SHIBYTE(v30);
  v33 = (v30 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v32 >= 0)
    v34 = 22;
  else
    v34 = v33;
  if (v32 >= 0)
    v35 = v31;
  else
    v35 = v45.__r_.__value_.__l.__size_;
  if (v34 == v35)
  {
    std::string::__grow_by_and_replace(&v45, v34, 1uLL, v34, v34, 0, 1uLL, ")");
    goto LABEL_72;
  }
  v36 = v32 < 0;
  v37 = &v45;
  if (v36)
    v37 = (std::string *)v45.__r_.__value_.__r.__words[0];
  v38 = (char *)v37 + v35;
  if ((char *)v37 + v35 > ")" || v38 + 1 <= ")")
  {
    *v38 = 41;
    v39 = v35 + 1;
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
      v45.__r_.__value_.__l.__size_ = v39;
    else
      *((_BYTE *)&v45.__r_.__value_.__s + 23) = v39 & 0x7F;
    v37->__r_.__value_.__s.__data_[v39] = 0;
LABEL_72:
    *(std::string *)(v8 + 64) = v45;
    memset(&v45, 0, sizeof(v45));
    if ((char)v42 < 0)
    {
      operator delete(v40);
      if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_74:
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_75:
          *(_QWORD *)(v8 + 88) = 0;
          *(_DWORD *)(v8 + 96) = 0;
          *(_QWORD *)(v8 + 104) = 0;
          *a4 = v8;
          return;
        }
LABEL_78:
        operator delete(__p.__r_.__value_.__l.__data_);
        goto LABEL_75;
      }
    }
    else if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_74;
    }
    operator delete(v44.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_75;
    goto LABEL_78;
  }
LABEL_79:
  __break(1u);
}

void webrtc::`anonymous namespace'::VideoDecoderSoftwareFallbackWrapper::~VideoDecoderSoftwareFallbackWrapper(webrtc::_anonymous_namespace_::VideoDecoderSoftwareFallbackWrapper *this)
{
  uint64_t v2;
  uint64_t v3;

  if ((*((char *)this + 87) & 0x80000000) == 0)
  {
    v2 = *((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = 0;
    if (!v2)
      goto LABEL_4;
    goto LABEL_3;
  }
  operator delete(*((void **)this + 8));
  v2 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v2)
LABEL_3:
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
LABEL_4:
  v3 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
}

void webrtc::`anonymous namespace'::VideoDecoderSoftwareFallbackWrapper::~VideoDecoderSoftwareFallbackWrapper(void **this)
{
  void *v2;
  void *v3;

  if (*((char *)this + 87) < 0)
  {
    operator delete(this[8]);
    v2 = this[7];
    this[7] = 0;
    if (!v2)
    {
LABEL_4:
      v3 = this[2];
      this[2] = 0;
      if (v3)
        (*(void (**)(void *))(*(_QWORD *)v3 + 8))(v3);
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    v2 = this[7];
    this[7] = 0;
    if (!v2)
      goto LABEL_4;
  }
  (*(void (**)(void *))(*(_QWORD *)v2 + 8))(v2);
  goto LABEL_4;
}

uint64_t webrtc::`anonymous namespace'::VideoDecoderSoftwareFallbackWrapper::Configure(webrtc::_anonymous_namespace_::VideoDecoderSoftwareFallbackWrapper *this, const webrtc::VideoDecoder::Settings *a2)
{
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *(_OWORD *)a2;
  *(_QWORD *)((char *)this + 44) = *((_QWORD *)a2 + 2);
  *(_OWORD *)((char *)this + 28) = v3;
  if (*((_BYTE *)this + 24))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_decoder_software_fallback_wrapper.cc");
  }
  *((_DWORD *)this + 2) = 1;
  if (*((_QWORD *)this + 11))
    (*(void (**)(_QWORD))(**((_QWORD **)this + 2) + 40))(*((_QWORD *)this + 2));
  return 1;
}

uint64_t webrtc::`anonymous namespace'::VideoDecoderSoftwareFallbackWrapper::Decode(webrtc::_anonymous_namespace_::VideoDecoderSoftwareFallbackWrapper *this, const webrtc::EncodedImage *a2, uint64_t a3)
{
  int v3;
  uint64_t result;
  uint64_t v8;
  unint64_t v9;

  v3 = *((_DWORD *)this + 2);
  if (!v3)
    return 4294967289;
  if (v3 == 2)
    return (*(uint64_t (**)(_QWORD, const webrtc::EncodedImage *, uint64_t))(**((_QWORD **)this + 7) + 24))(*((_QWORD *)this + 7), a2, a3);
  if (v3 != 1)
    return 0xFFFFFFFFLL;
  result = (*(uint64_t (**)(_QWORD, const webrtc::EncodedImage *, uint64_t))(**((_QWORD **)this + 2) + 24))(*((_QWORD *)this + 2), a2, a3);
  v8 = result;
  if ((_DWORD)result == -13)
  {
LABEL_12:
      return v8;
    return (*(uint64_t (**)(_QWORD, const webrtc::EncodedImage *, uint64_t))(**((_QWORD **)this + 7) + 24))(*((_QWORD *)this + 7), a2, a3);
  }
  if ((_DWORD)result == -1)
  {
    v9 = *((_QWORD *)this + 13);
    if (*((_DWORD *)a2 + 6) == 3)
      *((_QWORD *)this + 13) = ++v9;
    if (v9 < 4)
      return 0xFFFFFFFFLL;
    goto LABEL_12;
  }
  ++*((_DWORD *)this + 24);
  *((_QWORD *)this + 13) = 0;
  return result;
}

uint64_t webrtc::`anonymous namespace'::VideoDecoderSoftwareFallbackWrapper::RegisterDecodeCompleteCallback(webrtc::_anonymous_namespace_::VideoDecoderSoftwareFallbackWrapper *this, webrtc::DecodedImageCallback *a2)
{
  uint64_t v2;

  *((_QWORD *)this + 11) = a2;
  v2 = 16;
  if (*((_DWORD *)this + 2) == 2)
    v2 = 56;
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)((char *)this + v2) + 40))(*(_QWORD *)((char *)this + v2));
}

uint64_t webrtc::`anonymous namespace'::VideoDecoderSoftwareFallbackWrapper::Release(webrtc::_anonymous_namespace_::VideoDecoderSoftwareFallbackWrapper *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = *((unsigned int *)this + 2);
  switch((_DWORD)result)
  {
    case 0:
      goto LABEL_9;
    case 2:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_decoder_software_fallback_wrapper.cc");
      v3 = *((_QWORD *)this + 7);
      goto LABEL_8;
    case 1:
      v3 = *((_QWORD *)this + 2);
LABEL_8:
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
LABEL_9:
      *((_DWORD *)this + 2) = 0;
      return result;
  }
  result = 0xFFFFFFFFLL;
  *((_DWORD *)this + 2) = 0;
  return result;
}

std::string *webrtc::`anonymous namespace'::VideoDecoderSoftwareFallbackWrapper::GetDecoderInfo@<X0>(webrtc::_anonymous_namespace_::VideoDecoderSoftwareFallbackWrapper *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  std::string *result;
  _OWORD *v6;
  char v8;
  const std::string::value_type *v9;
  size_t v10;

  v4 = 16;
  if (*((_DWORD *)this + 2) == 2)
    v4 = 56;
  result = (std::string *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)((char *)this + v4) + 56))(*(_QWORD *)((char *)this + v4));
  v6 = (_OWORD *)((char *)this + 64);
  if (*((_DWORD *)this + 2) == 2 && v6 != (_OWORD *)a2)
  {
    v8 = *((_BYTE *)this + 87);
    if (*(char *)(a2 + 23) < 0)
    {
      if (v8 >= 0)
        v9 = (char *)this + 64;
      else
        v9 = (const std::string::value_type *)*((_QWORD *)this + 8);
      if (v8 >= 0)
        v10 = *((unsigned __int8 *)this + 87);
      else
        v10 = *((_QWORD *)this + 9);
      return std::string::__assign_no_alias<false>((std::string *)a2, v9, v10);
    }
    else if ((*((_BYTE *)this + 87) & 0x80) != 0)
    {
      return (std::string *)std::string::__assign_no_alias<true>((_QWORD *)a2, *((char **)this + 8), *((_QWORD *)this + 9));
    }
    else
    {
      *(_OWORD *)a2 = *v6;
      *(_QWORD *)(a2 + 16) = *((_QWORD *)this + 10);
    }
  }
  return result;
}

_QWORD *webrtc::`anonymous namespace'::VideoDecoderSoftwareFallbackWrapper::ImplementationName(webrtc::_anonymous_namespace_::VideoDecoderSoftwareFallbackWrapper *this)
{
  _QWORD *result;

  if (*((_DWORD *)this + 2) != 2)
    return (*(_QWORD *(**)(_QWORD *__return_ptr))(**((_QWORD **)this + 2) + 64))(**((_QWORD ***)this + 2));
  result = (_QWORD *)((char *)this + 64);
  if (*((char *)this + 87) < 0)
    return (_QWORD *)*result;
  return result;
}

uint64_t webrtc::`anonymous namespace'::VideoDecoderSoftwareFallbackWrapper::InitFallbackDecoder(webrtc::_anonymous_namespace_::VideoDecoderSoftwareFallbackWrapper *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  size_t v12;
  unint64_t v13;
  char *p_p;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  unint64_t v23;
  char *v24;
  size_t v25;
  unint64_t v26;
  char *v27;
  size_t v28;
  unint64_t v29;
  char *v30;
  size_t v31;
  unint64_t v32;
  char *v33;
  size_t v34;
  unint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  char *v52;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  char *v64;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  char *v70;
  void *__p;
  size_t v75;
  unint64_t v76;
  void *v77;
  __int128 v78;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_decoder_software_fallback_wrapper.cc");
  v9 = (*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)this + 7) + 16))(*((_QWORD *)this + 7), (char *)this + 28);
  if ((v9 & 1) == 0)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_decoder_software_fallback_wrapper.cc");
    return v9;
  }
  v10 = (char *)operator new(0x40uLL);
  v77 = v10;
  v78 = xmmword_208F0ABB0;
  if (v10 <= "WebRTC.Video.HardwareDecodedFramesBetweenSoftwareFallbacks."
    && v10 + 59 > "WebRTC.Video.HardwareDecodedFramesBetweenSoftwareFallbacks.")
  {
    goto LABEL_193;
  }
  strcpy(v10, "WebRTC.Video.HardwareDecodedFramesBetweenSoftwareFallbacks.");
  switch(*((_DWORD *)this + 12))
  {
    case 0:
      v11 = atomic_load(&_MergedGlobals_21);
      if (v11)
        goto LABEL_45;
      if (v78 >= 0)
        v12 = HIBYTE(v78);
      else
        v12 = v78;
      v13 = v12 + 7;
      if (v12 + 7 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_194;
      if (v13 > 0x16)
      {
        v49 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v13 | 7) != 0x17)
          v49 = v13 | 7;
        v50 = v49 + 1;
        p_p = (char *)operator new(v49 + 1);
        v75 = v12 + 7;
        v76 = v50 | 0x8000000000000000;
        __p = p_p;
      }
      else
      {
        v75 = 0;
        v76 = 0;
        __p = 0;
        p_p = (char *)&__p;
        HIBYTE(v76) = v12 + 7;
      }
      if (v78 >= 0)
        v51 = (char *)&v77;
      else
        v51 = (char *)v77;
      v52 = &p_p[v12];
      if (v51 >= p_p && v52 > v51)
        goto LABEL_193;
      if (v12)
        memmove(p_p, v51, v12);
      if (v52 <= "Generic" && v52 + 7 > "Generic")
        goto LABEL_193;
      strcpy(v52, "Generic");
      if ((SHIBYTE(v76) & 0x80000000) == 0)
        goto LABEL_115;
      if ((v75 & 0x8000000000000000) != 0 || v75 && !__p)
        goto LABEL_193;
      operator delete(__p);
LABEL_115:
      while (!__ldaxr(&_MergedGlobals_21))
      {
        if (!__stlxr(0, &_MergedGlobals_21))
          goto LABEL_185;
      }
      goto LABEL_184;
    case 1:
      v11 = atomic_load(&qword_253EA5AB8);
      if (v11)
        goto LABEL_45;
      if (v78 >= 0)
        v22 = HIBYTE(v78);
      else
        v22 = v78;
      v23 = v22 + 3;
      if (v22 + 3 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_194;
      if (v23 > 0x16)
      {
        v55 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v23 | 7) != 0x17)
          v55 = v23 | 7;
        v56 = v55 + 1;
        v24 = (char *)operator new(v55 + 1);
        v75 = v22 + 3;
        v76 = v56 | 0x8000000000000000;
        __p = v24;
      }
      else
      {
        v75 = 0;
        v76 = 0;
        __p = 0;
        v24 = (char *)&__p;
        HIBYTE(v76) = v22 + 3;
      }
      if (v78 >= 0)
        v57 = (char *)&v77;
      else
        v57 = (char *)v77;
      v58 = &v24[v22];
      if (v57 >= v24 && v58 > v57)
        goto LABEL_193;
      if (v22)
        memmove(v24, v57, v22);
      if (v58 <= "Vp8" && v58 + 3 > "Vp8")
        goto LABEL_193;
      *(_DWORD *)v58 = 3698774;
      if ((SHIBYTE(v76) & 0x80000000) == 0)
        goto LABEL_137;
      if ((v75 & 0x8000000000000000) != 0 || v75 && !__p)
        goto LABEL_193;
      operator delete(__p);
LABEL_137:
      while (!__ldaxr(&qword_253EA5AB8))
      {
        if (!__stlxr(0, &qword_253EA5AB8))
          goto LABEL_185;
      }
      goto LABEL_184;
    case 2:
      v11 = atomic_load(&qword_253EA5AC0);
      if (v11)
        goto LABEL_45;
      if (v78 >= 0)
        v25 = HIBYTE(v78);
      else
        v25 = v78;
      v26 = v25 + 3;
      if (v25 + 3 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_194;
      if (v26 > 0x16)
      {
        v37 = (v26 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v26 | 7) != 0x17)
          v37 = v26 | 7;
        v38 = v37 + 1;
        v27 = (char *)operator new(v37 + 1);
        v75 = v25 + 3;
        v76 = v38 | 0x8000000000000000;
        __p = v27;
      }
      else
      {
        v75 = 0;
        v76 = 0;
        __p = 0;
        v27 = (char *)&__p;
        HIBYTE(v76) = v25 + 3;
      }
      if (v78 >= 0)
        v39 = (char *)&v77;
      else
        v39 = (char *)v77;
      v40 = &v27[v25];
      if (v39 >= v27 && v40 > v39)
        goto LABEL_193;
      if (v25)
        memmove(v27, v39, v25);
      if (v40 <= "Vp9" && v40 + 3 > "Vp9")
        goto LABEL_193;
      *(_DWORD *)v40 = 3764310;
      if ((SHIBYTE(v76) & 0x80000000) == 0)
        goto LABEL_71;
      if ((v75 & 0x8000000000000000) != 0 || v75 && !__p)
        goto LABEL_193;
      operator delete(__p);
LABEL_71:
      while (!__ldaxr(&qword_253EA5AC0))
      {
        if (!__stlxr(0, &qword_253EA5AC0))
          goto LABEL_185;
      }
      goto LABEL_184;
    case 3:
      v11 = atomic_load(&qword_253EA5AC8);
      if (v11)
        goto LABEL_45;
      if (v78 >= 0)
        v28 = HIBYTE(v78);
      else
        v28 = v78;
      v29 = v28 + 3;
      if (v28 + 3 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_194;
      if (v29 > 0x16)
      {
        v61 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v29 | 7) != 0x17)
          v61 = v29 | 7;
        v62 = v61 + 1;
        v30 = (char *)operator new(v61 + 1);
        v75 = v28 + 3;
        v76 = v62 | 0x8000000000000000;
        __p = v30;
      }
      else
      {
        v75 = 0;
        v76 = 0;
        __p = 0;
        v30 = (char *)&__p;
        HIBYTE(v76) = v28 + 3;
      }
      if (v78 >= 0)
        v63 = (char *)&v77;
      else
        v63 = (char *)v77;
      v64 = &v30[v28];
      if (v63 >= v30 && v64 > v63)
        goto LABEL_193;
      if (v28)
        memmove(v30, v63, v28);
      if (v64 <= "Av1" && v64 + 3 > "Av1")
        goto LABEL_193;
      *(_DWORD *)v64 = 3241537;
      if ((SHIBYTE(v76) & 0x80000000) == 0)
        goto LABEL_159;
      if ((v75 & 0x8000000000000000) != 0 || v75 && !__p)
        goto LABEL_193;
      operator delete(__p);
LABEL_159:
      while (!__ldaxr(&qword_253EA5AC8))
      {
        if (!__stlxr(0, &qword_253EA5AC8))
          goto LABEL_185;
      }
      goto LABEL_184;
    case 4:
      v11 = atomic_load(&qword_253EA5AD0);
      if (v11)
        goto LABEL_45;
      if (v78 >= 0)
        v31 = HIBYTE(v78);
      else
        v31 = v78;
      v32 = v31 + 4;
      if (v31 + 4 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_194;
      if (v32 > 0x16)
      {
        v43 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v32 | 7) != 0x17)
          v43 = v32 | 7;
        v44 = v43 + 1;
        v33 = (char *)operator new(v43 + 1);
        v75 = v31 + 4;
        v76 = v44 | 0x8000000000000000;
        __p = v33;
      }
      else
      {
        v75 = 0;
        v76 = 0;
        __p = 0;
        v33 = (char *)&__p;
        HIBYTE(v76) = v31 + 4;
      }
      if (v78 >= 0)
        v45 = (char *)&v77;
      else
        v45 = (char *)v77;
      v46 = &v33[v31];
      if (v45 >= v33 && v46 > v45)
        goto LABEL_193;
      if (v31)
        memmove(v33, v45, v31);
      if (v46 <= "H264" && v46 + 4 > "H264")
        goto LABEL_193;
      strcpy(v46, "H264");
      if ((SHIBYTE(v76) & 0x80000000) == 0)
        goto LABEL_93;
      if ((v75 & 0x8000000000000000) != 0 || v75 && !__p)
        goto LABEL_193;
      operator delete(__p);
LABEL_93:
      while (!__ldaxr(&qword_253EA5AD0))
      {
        if (!__stlxr(0, &qword_253EA5AD0))
          goto LABEL_185;
      }
      goto LABEL_184;
    case 5:
      v11 = atomic_load(&qword_253EA5AD8);
      if (!v11)
      {
        if (v78 >= 0)
          v34 = HIBYTE(v78);
        else
          v34 = v78;
        v35 = v34 + 4;
        if (v34 + 4 > 0x7FFFFFFFFFFFFFF7)
LABEL_194:
          abort();
        if (v35 > 0x16)
        {
          v67 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v35 | 7) != 0x17)
            v67 = v35 | 7;
          v68 = v67 + 1;
          v36 = (char *)operator new(v67 + 1);
          v75 = v34 + 4;
          v76 = v68 | 0x8000000000000000;
          __p = v36;
        }
        else
        {
          v75 = 0;
          v76 = 0;
          __p = 0;
          v36 = (char *)&__p;
          HIBYTE(v76) = v34 + 4;
        }
        if (v78 >= 0)
          v69 = (char *)&v77;
        else
          v69 = (char *)v77;
        v70 = &v36[v34];
        if (v69 < v36 || v70 <= v69)
        {
          if (v34)
            memmove(v36, v69, v34);
          if (v70 > "H265" || v70 + 4 <= "H265")
          {
            strcpy(v70, "H265");
            if ((SHIBYTE(v76) & 0x80000000) == 0)
              goto LABEL_181;
            if ((v75 & 0x8000000000000000) == 0 && (!v75 || __p))
            {
              operator delete(__p);
LABEL_181:
              while (!__ldaxr(&qword_253EA5AD8))
              {
                if (!__stlxr(0, &qword_253EA5AD8))
                  goto LABEL_185;
              }
LABEL_184:
              __clrex();
              goto LABEL_185;
            }
          }
        }
LABEL_193:
        __break(1u);
        goto LABEL_194;
      }
LABEL_45:
      webrtc::metrics::HistogramAdd(v11, *((_DWORD *)this + 24));
LABEL_185:
      if (SHIBYTE(v78) < 0)
      {
        operator delete(v77);
        if (*((_DWORD *)this + 2) == 1)
        {
LABEL_187:
          (*(void (**)(_QWORD))(**((_QWORD **)this + 2) + 48))(*((_QWORD *)this + 2));
          *((_DWORD *)this + 2) = 2;
          if (!*((_QWORD *)this + 11))
            return v9;
          goto LABEL_191;
        }
      }
      else if (*((_DWORD *)this + 2) == 1)
      {
        goto LABEL_187;
      }
      *((_DWORD *)this + 2) = 2;
      if (*((_QWORD *)this + 11))
LABEL_191:
        (*(void (**)(_QWORD))(**((_QWORD **)this + 7) + 40))(*((_QWORD *)this + 7));
      return v9;
    default:
      goto LABEL_185;
  }
}

webrtc::VideoEncoder::EncoderInfo *webrtc::VideoEncoder::EncoderInfo::EncoderInfo(webrtc::VideoEncoder::EncoderInfo *this, const webrtc::VideoEncoder::EncoderInfo *a2)
{
  int v4;
  std::string *v5;
  __int128 v6;
  __int16 v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t *v19;
  unint64_t v20;
  _BYTE *v21;
  _BYTE *v22;
  int64_t v23;
  char *v24;
  char *v25;
  unint64_t v26;
  __int128 v27;
  _BYTE *v28;
  _BYTE *v29;

  *(_OWORD *)this = *(_OWORD *)a2;
  v4 = *((_DWORD *)a2 + 4);
  *((_WORD *)this + 10) = *((_WORD *)a2 + 10);
  *((_DWORD *)this + 4) = v4;
  v5 = (std::string *)((char *)this + 24);
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v6 = *(_OWORD *)((char *)a2 + 24);
    v5->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  v7 = *((_WORD *)a2 + 24);
  *((_QWORD *)this + 7) = 0;
  *((_WORD *)this + 24) = v7;
  v8 = *((_QWORD *)a2 + 7);
  if (v8 < 2)
  {
    *((_QWORD *)this + 10) = 0;
    v9 = (unint64_t *)((char *)this + 80);
    v10 = (unint64_t *)((char *)a2 + 80);
    v11 = *((_QWORD *)a2 + 10);
    if (v11 < 2)
      goto LABEL_6;
LABEL_19:
    if ((v11 & 1) != 0)
    {
      absl::inlined_vector_internal::Storage<unsigned char,4ul,std::allocator<unsigned char>>::InitFrom(v9, v10);
      *((_QWORD *)this + 13) = 0;
      v12 = (unint64_t *)((char *)this + 104);
      v13 = (unint64_t *)((char *)a2 + 104);
      v14 = *((_QWORD *)a2 + 13);
      if (v14 >= 2)
        goto LABEL_23;
    }
    else
    {
      *((_QWORD *)this + 10) = v11;
      *(_OWORD *)((char *)this + 88) = *(_OWORD *)((char *)a2 + 88);
      *((_QWORD *)this + 13) = 0;
      v12 = (unint64_t *)((char *)this + 104);
      v13 = (unint64_t *)((char *)a2 + 104);
      v14 = *((_QWORD *)a2 + 13);
      if (v14 >= 2)
        goto LABEL_23;
    }
LABEL_7:
    *((_QWORD *)this + 16) = 0;
    v15 = (unint64_t *)((char *)this + 128);
    v16 = (unint64_t *)((char *)a2 + 128);
    v17 = *((_QWORD *)a2 + 16);
    if (v17 < 2)
      goto LABEL_8;
LABEL_27:
    if ((v17 & 1) != 0)
    {
      absl::inlined_vector_internal::Storage<unsigned char,4ul,std::allocator<unsigned char>>::InitFrom(v15, v16);
      *((_QWORD *)this + 19) = 0;
      v18 = (unint64_t *)((char *)this + 152);
      v19 = (unint64_t *)((char *)a2 + 152);
      v20 = *((_QWORD *)a2 + 19);
      if (v20 >= 2)
        goto LABEL_31;
    }
    else
    {
      *((_QWORD *)this + 16) = v17;
      *(_OWORD *)((char *)this + 136) = *(_OWORD *)((char *)a2 + 136);
      *((_QWORD *)this + 19) = 0;
      v18 = (unint64_t *)((char *)this + 152);
      v19 = (unint64_t *)((char *)a2 + 152);
      v20 = *((_QWORD *)a2 + 19);
      if (v20 >= 2)
        goto LABEL_31;
    }
LABEL_9:
    *((_QWORD *)this + 22) = 0;
    *((_QWORD *)this + 23) = 0;
    *((_QWORD *)this + 24) = 0;
    v22 = (_BYTE *)*((_QWORD *)a2 + 22);
    v21 = (_BYTE *)*((_QWORD *)a2 + 23);
    v23 = v21 - v22;
    if (v21 == v22)
      goto LABEL_12;
    goto LABEL_10;
  }
  if ((v8 & 1) != 0)
  {
    absl::inlined_vector_internal::Storage<unsigned char,4ul,std::allocator<unsigned char>>::InitFrom((unint64_t *)this + 7, (unint64_t *)a2 + 7);
    *((_QWORD *)this + 10) = 0;
    v9 = (unint64_t *)((char *)this + 80);
    v10 = (unint64_t *)((char *)a2 + 80);
    v11 = *((_QWORD *)a2 + 10);
    if (v11 >= 2)
      goto LABEL_19;
  }
  else
  {
    *((_QWORD *)this + 7) = v8;
    *((_OWORD *)this + 4) = *((_OWORD *)a2 + 4);
    *((_QWORD *)this + 10) = 0;
    v9 = (unint64_t *)((char *)this + 80);
    v10 = (unint64_t *)((char *)a2 + 80);
    v11 = *((_QWORD *)a2 + 10);
    if (v11 >= 2)
      goto LABEL_19;
  }
LABEL_6:
  *((_QWORD *)this + 13) = 0;
  v12 = (unint64_t *)((char *)this + 104);
  v13 = (unint64_t *)((char *)a2 + 104);
  v14 = *((_QWORD *)a2 + 13);
  if (v14 < 2)
    goto LABEL_7;
LABEL_23:
  if ((v14 & 1) != 0)
  {
    absl::inlined_vector_internal::Storage<unsigned char,4ul,std::allocator<unsigned char>>::InitFrom(v12, v13);
    *((_QWORD *)this + 16) = 0;
    v15 = (unint64_t *)((char *)this + 128);
    v16 = (unint64_t *)((char *)a2 + 128);
    v17 = *((_QWORD *)a2 + 16);
    if (v17 >= 2)
      goto LABEL_27;
  }
  else
  {
    *((_QWORD *)this + 13) = v14;
    *((_OWORD *)this + 7) = *((_OWORD *)a2 + 7);
    *((_QWORD *)this + 16) = 0;
    v15 = (unint64_t *)((char *)this + 128);
    v16 = (unint64_t *)((char *)a2 + 128);
    v17 = *((_QWORD *)a2 + 16);
    if (v17 >= 2)
      goto LABEL_27;
  }
LABEL_8:
  *((_QWORD *)this + 19) = 0;
  v18 = (unint64_t *)((char *)this + 152);
  v19 = (unint64_t *)((char *)a2 + 152);
  v20 = *((_QWORD *)a2 + 19);
  if (v20 < 2)
    goto LABEL_9;
LABEL_31:
  if ((v20 & 1) != 0)
  {
    absl::inlined_vector_internal::Storage<unsigned char,4ul,std::allocator<unsigned char>>::InitFrom(v18, v19);
    *((_QWORD *)this + 22) = 0;
    *((_QWORD *)this + 23) = 0;
    *((_QWORD *)this + 24) = 0;
    v22 = (_BYTE *)*((_QWORD *)a2 + 22);
    v29 = (_BYTE *)*((_QWORD *)a2 + 23);
    v23 = v29 - v22;
    if (v29 == v22)
      goto LABEL_12;
  }
  else
  {
    *((_QWORD *)this + 19) = v20;
    *((_OWORD *)this + 10) = *((_OWORD *)a2 + 10);
    *((_QWORD *)this + 22) = 0;
    *((_QWORD *)this + 23) = 0;
    *((_QWORD *)this + 24) = 0;
    v22 = (_BYTE *)*((_QWORD *)a2 + 22);
    v28 = (_BYTE *)*((_QWORD *)a2 + 23);
    v23 = v28 - v22;
    if (v28 == v22)
      goto LABEL_12;
  }
LABEL_10:
  if (v23 < 0)
    abort();
  v24 = (char *)operator new(v23);
  *((_QWORD *)this + 22) = v24;
  *((_QWORD *)this + 23) = v24;
  v25 = &v24[16 * (v23 >> 4)];
  *((_QWORD *)this + 24) = v25;
  memcpy(v24, v22, v23);
  *((_QWORD *)this + 23) = v25;
LABEL_12:
  *((_QWORD *)this + 26) = 0;
  v26 = *((_QWORD *)a2 + 26);
  *((_BYTE *)this + 200) = *((_BYTE *)a2 + 200);
  if (v26 >= 2)
  {
    if ((v26 & 1) != 0)
    {
      absl::inlined_vector_internal::Storage<webrtc::VideoFrameBuffer::Type,5ul,std::allocator<webrtc::VideoFrameBuffer::Type>>::InitFrom((unint64_t *)this + 26, (unint64_t *)a2 + 26);
    }
    else
    {
      *((_QWORD *)this + 26) = v26;
      v27 = *(_OWORD *)((char *)a2 + 216);
      *((_QWORD *)this + 29) = *((_QWORD *)a2 + 29);
      *(_OWORD *)((char *)this + 216) = v27;
    }
  }
  *((_WORD *)this + 120) = *((_WORD *)a2 + 120);
  return this;
}

void webrtc::VideoEncoder::EncoderInfo::~EncoderInfo(void **this)
{
  void *v2;

  if (((_BYTE)this[26] & 1) != 0)
    operator delete(this[27]);
  v2 = this[22];
  if (v2)
  {
    this[23] = v2;
    operator delete(v2);
  }
  if (((_BYTE)this[19] & 1) != 0)
  {
    operator delete(this[20]);
    if (((_BYTE)this[16] & 1) == 0)
    {
LABEL_7:
      if (((_BYTE)this[13] & 1) == 0)
        goto LABEL_8;
      goto LABEL_14;
    }
  }
  else if (((_BYTE)this[16] & 1) == 0)
  {
    goto LABEL_7;
  }
  operator delete(this[17]);
  if (((_BYTE)this[13] & 1) == 0)
  {
LABEL_8:
    if (((_BYTE)this[10] & 1) == 0)
      goto LABEL_9;
    goto LABEL_15;
  }
LABEL_14:
  operator delete(this[14]);
  if (((_BYTE)this[10] & 1) == 0)
  {
LABEL_9:
    if (((_BYTE)this[7] & 1) == 0)
      goto LABEL_10;
    goto LABEL_16;
  }
LABEL_15:
  operator delete(this[11]);
  if (((_BYTE)this[7] & 1) == 0)
  {
LABEL_10:
    if ((*((char *)this + 47) & 0x80000000) == 0)
      return;
LABEL_17:
    operator delete(this[3]);
    return;
  }
LABEL_16:
  operator delete(this[8]);
  if (*((char *)this + 47) < 0)
    goto LABEL_17;
}

unint64_t webrtc::VideoEncoder::EncoderInfo::ToString@<X0>(webrtc::VideoEncoder::EncoderInfo *this@<X0>, unint64_t *a2@<X8>)
{
  char *v4;
  size_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  size_t v20;
  size_t v21;
  size_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  size_t v26;
  size_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  size_t v31;
  char *v32;
  _QWORD *v33;
  unint64_t v34;
  size_t v35;
  size_t v36;
  unint64_t v37;
  _BYTE **v38;
  _BYTE *v39;
  unint64_t v40;
  size_t v41;
  unint64_t v42;
  _BYTE *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  size_t v47;
  int *v48;
  size_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  size_t v54;
  size_t v55;
  size_t v56;
  size_t v57;
  uint64_t v58;
  unint64_t v59;
  size_t v60;
  uint64_t v61;
  _DWORD *v62;
  size_t v63;
  int v64;
  int v65;
  int v66;
  int v67;
  size_t v68;
  size_t v69;
  size_t v70;
  size_t v71;
  size_t v72;
  size_t v73;
  unint64_t v74;
  char **v75;
  char *v76;
  unsigned int v77;
  const char *v78;
  size_t v79;
  size_t v80;
  unint64_t v81;
  size_t v82;
  size_t v83;
  size_t v84;
  unint64_t v85;
  char *v86;
  unsigned int v87;
  const char *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  void *v92;
  size_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  unint64_t result;
  size_t v99;
  char *v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t *v103;
  uint64_t v104;
  char *__s;
  __int128 v106;
  char v107[2048];
  uint64_t v108;

  v108 = *MEMORY[0x24BDAC8D0];
  v4 = v107;
  __s = v107;
  strcpy(v107, "EncoderInfo { ScalingSettings { ");
  v106 = xmmword_208F1D640;
  if (*((_BYTE *)this + 8))
  {
    strcpy(&v107[32], "Thresholds { low = ");
    *((_QWORD *)&v106 + 1) = 51;
    rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *(_DWORD *)this);
    if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 9uLL)
      v5 = 9;
    else
      v5 = v106 + ~*((_QWORD *)&v106 + 1);
    memcpy(&__s[*((_QWORD *)&v106 + 1)], ", high = ", v5);
    *((_QWORD *)&v106 + 1) += v5;
    __s[*((_QWORD *)&v106 + 1)] = 0;
    if (!*((_BYTE *)this + 8))
      goto LABEL_176;
    rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 1));
    if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 3uLL)
      v13 = 3;
    else
      v13 = v106 + ~*((_QWORD *)&v106 + 1);
    memcpy(&__s[*((_QWORD *)&v106 + 1)], "}, ", v13);
    *((_QWORD *)&v106 + 1) += v13;
    __s[*((_QWORD *)&v106 + 1)] = 0;
    v14 = *((_QWORD *)&v106 + 1);
    v15 = v106;
    v4 = __s;
  }
  else
  {
    v15 = 2048;
    v14 = 32;
  }
  v16 = v15 + ~v14;
  if (v16 >= 0x17)
    v17 = 23;
  else
    v17 = v16;
  memcpy(&v4[v14], "min_pixels_per_frame = ", v17);
  *((_QWORD *)&v106 + 1) += v17;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 3));
  if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 2uLL)
    v18 = 2;
  else
    v18 = v106 + ~*((_QWORD *)&v106 + 1);
  memcpy(&__s[*((_QWORD *)&v106 + 1)], " }", v18);
  *((_QWORD *)&v106 + 1) += v18;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x23uLL)
    v19 = 35;
  else
    v19 = v106 + ~*((_QWORD *)&v106 + 1);
  memcpy(&__s[*((_QWORD *)&v106 + 1)], ", requested_resolution_alignment = ", v19);
  *((_QWORD *)&v106 + 1) += v19;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *((_DWORD *)this + 4));
  if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x2CuLL)
    v20 = 44;
  else
    v20 = v106 + ~*((_QWORD *)&v106 + 1);
  memcpy(&__s[*((_QWORD *)&v106 + 1)], ", apply_alignment_to_all_simulcast_layers = ", v20);
  *((_QWORD *)&v106 + 1) += v20;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((unsigned __int8 *)this + 20));
  if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x1BuLL)
    v21 = 27;
  else
    v21 = v106 + ~*((_QWORD *)&v106 + 1);
  memcpy(&__s[*((_QWORD *)&v106 + 1)], ", supports_native_handle = ", v21);
  *((_QWORD *)&v106 + 1) += v21;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((unsigned __int8 *)this + 21));
  if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x19uLL)
    v22 = 25;
  else
    v22 = v106 + ~*((_QWORD *)&v106 + 1);
  memcpy(&__s[*((_QWORD *)&v106 + 1)], ", implementation_name = '", v22);
  *((_QWORD *)&v106 + 1) += v22;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  v6 = (_QWORD *)((char *)this + 24);
  if (*((char *)this + 47) < 0)
  {
    v23 = *((_QWORD *)this + 4);
    if ((v23 & 0x8000000000000000) != 0)
      goto LABEL_176;
    v6 = (_QWORD *)*v6;
    if (v23)
    {
      if (!v6)
        goto LABEL_176;
    }
  }
  else
  {
    v23 = *((unsigned __int8 *)this + 47);
  }
  v103 = a2;
  if (v23 >= (_QWORD)v106 + ~*((_QWORD *)&v106 + 1))
    v24 = v106 + ~*((_QWORD *)&v106 + 1);
  else
    v24 = v23;
  memcpy(&__s[*((_QWORD *)&v106 + 1)], v6, v24);
  *((_QWORD *)&v106 + 1) += v24;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x21uLL)
    v25 = 33;
  else
    v25 = v106 + ~*((_QWORD *)&v106 + 1);
  memcpy(&__s[*((_QWORD *)&v106 + 1)], "', has_trusted_rate_controller = ", v25);
  *((_QWORD *)&v106 + 1) += v25;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((unsigned __int8 *)this + 48));
  if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x1CuLL)
    v26 = 28;
  else
    v26 = v106 + ~*((_QWORD *)&v106 + 1);
  memcpy(&__s[*((_QWORD *)&v106 + 1)], ", is_hardware_accelerated = ", v26);
  *((_QWORD *)&v106 + 1) += v26;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((unsigned __int8 *)this + 49));
  if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x14uLL)
    v27 = 20;
  else
    v27 = v106 + ~*((_QWORD *)&v106 + 1);
  memcpy(&__s[*((_QWORD *)&v106 + 1)], ", fps_allocation = [", v27);
  *((_QWORD *)&v106 + 1) += v27;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  v28 = *((_QWORD *)this + 7) > 1uLL;
  if (*((_QWORD *)this + 10) >= 2uLL)
    v28 = 2;
  if (*((_QWORD *)this + 13) >= 2uLL)
    v28 = 3;
  if (*((_QWORD *)this + 16) >= 2uLL)
    v28 = 4;
  if (*((_QWORD *)this + 19) >= 2uLL)
    v28 = 5;
  v104 = v28;
  if (v28)
  {
    v29 = 0;
    v30 = 1;
    do
    {
      v32 = (char *)this + 24 * v29;
      v34 = *((_QWORD *)v32 + 7);
      v33 = v32 + 56;
      if (v34 < 2)
        break;
      if ((v30 & 1) != 0
        || ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 2uLL ? (v35 = 2) : (v35 = v106 + ~*((_QWORD *)&v106 + 1)),
            memcpy(&__s[*((_QWORD *)&v106 + 1)], ", ", v35),
            *((_QWORD *)&v106 + 1) += v35,
            __s[*((_QWORD *)&v106 + 1)] = 0,
            *v33 >= 2uLL))
      {
        if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 2uLL)
          v36 = 2;
        else
          v36 = v106 + ~*((_QWORD *)&v106 + 1);
        memcpy(&__s[*((_QWORD *)&v106 + 1)], "[ ", v36);
        *((_QWORD *)&v106 + 1) += v36;
        __s[*((_QWORD *)&v106 + 1)] = 0;
        if (*v33 >= 2uLL)
        {
          v38 = (_BYTE **)(v33 + 1);
          v39 = v33 + 1;
          if ((*v33 & 1) != 0)
            v39 = *v38;
          LOBYTE(v37) = *v39;
          rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%g", (double)v37 / 255.0);
          if (*v33 >= 4uLL)
          {
            v40 = 1;
            while (1)
            {
              v41 = (_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 2uLL ? 2 : v106 + ~*((_QWORD *)&v106 + 1);
              memcpy(&__s[*((_QWORD *)&v106 + 1)], ", ", v41);
              *((_QWORD *)&v106 + 1) += v41;
              __s[*((_QWORD *)&v106 + 1)] = 0;
              if (v40 >= *v33 >> 1)
                break;
              v43 = v33 + 1;
              if ((*v33 & 1) != 0)
                v43 = *v38;
              LOBYTE(v42) = v43[v40];
              rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%g", (double)v42 / 255.0);
              if (++v40 >= *v33 >> 1)
                goto LABEL_56;
            }
LABEL_176:
            __break(1u);
LABEL_177:
          }
        }
LABEL_56:
        if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 2uLL)
          v31 = 2;
        else
          v31 = v106 + ~*((_QWORD *)&v106 + 1);
        memcpy(&__s[*((_QWORD *)&v106 + 1)], "] ", v31);
        *((_QWORD *)&v106 + 1) += v31;
        __s[*((_QWORD *)&v106 + 1)] = 0;
      }
      v30 = 0;
      ++v29;
    }
    while (v29 != v104);
  }
  v44 = v106;
  v45 = *((_QWORD *)&v106 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v106 + 1)], "]", v106 != *((_QWORD *)&v106 + 1) + 1);
  v46 = *((_QWORD *)&v106 + 1);
  if (v44 != v45)
    v46 = *((_QWORD *)&v106 + 1) + 1;
  *((_QWORD *)&v106 + 1) = v46;
  __s[v46] = 0;
  if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x1FuLL)
    v47 = 31;
  else
    v47 = v106 + ~*((_QWORD *)&v106 + 1);
  memcpy(&__s[*((_QWORD *)&v106 + 1)], ", resolution_bitrate_limits = [", v47);
  *((_QWORD *)&v106 + 1) += v47;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  v48 = (int *)*((_QWORD *)this + 22);
  if (*((int **)this + 23) != v48)
  {
    v49 = (_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x1DuLL ? 29 : v106 + ~*((_QWORD *)&v106 + 1);
    v50 = *v48;
    v51 = v48[1];
    v53 = v48[2];
    v52 = v48[3];
    memcpy(&__s[*((_QWORD *)&v106 + 1)], "Limits { frame_size_pixels = ", v49);
    *((_QWORD *)&v106 + 1) += v49;
    __s[*((_QWORD *)&v106 + 1)] = 0;
    rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", v50);
    v54 = (_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x1AuLL ? 26 : v106 + ~*((_QWORD *)&v106 + 1);
    memcpy(&__s[*((_QWORD *)&v106 + 1)], ", min_start_bitrate_bps = ", v54);
    *((_QWORD *)&v106 + 1) += v54;
    __s[*((_QWORD *)&v106 + 1)] = 0;
    rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", v51);
    v55 = (_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x14uLL ? 20 : v106 + ~*((_QWORD *)&v106 + 1);
    memcpy(&__s[*((_QWORD *)&v106 + 1)], ", min_bitrate_bps = ", v55);
    *((_QWORD *)&v106 + 1) += v55;
    __s[*((_QWORD *)&v106 + 1)] = 0;
    rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", v53);
    v56 = (_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x14uLL ? 20 : v106 + ~*((_QWORD *)&v106 + 1);
    memcpy(&__s[*((_QWORD *)&v106 + 1)], ", max_bitrate_bps = ", v56);
    *((_QWORD *)&v106 + 1) += v56;
    __s[*((_QWORD *)&v106 + 1)] = 0;
    rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", v52);
    v57 = (_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 2uLL ? 2 : v106 + ~*((_QWORD *)&v106 + 1);
    memcpy(&__s[*((_QWORD *)&v106 + 1)], "} ", v57);
    *((_QWORD *)&v106 + 1) += v57;
    __s[*((_QWORD *)&v106 + 1)] = 0;
    if (*((_QWORD *)this + 23) - *((_QWORD *)this + 22) >= 0x11uLL)
    {
      v58 = 0;
      v59 = 1;
      do
      {
        v60 = (_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 2uLL ? 2 : v106 + ~*((_QWORD *)&v106 + 1);
        memcpy(&__s[*((_QWORD *)&v106 + 1)], ", ", v60);
        *((_QWORD *)&v106 + 1) += v60;
        __s[*((_QWORD *)&v106 + 1)] = 0;
        v61 = *((_QWORD *)this + 22);
        if (v59 >= (*((_QWORD *)this + 23) - v61) >> 4)
          goto LABEL_176;
        v62 = (_DWORD *)(v61 + v58);
        if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x1DuLL)
          v63 = 29;
        else
          v63 = v106 + ~*((_QWORD *)&v106 + 1);
        v65 = v62[4];
        v64 = v62[5];
        v67 = v62[6];
        v66 = v62[7];
        memcpy(&__s[*((_QWORD *)&v106 + 1)], "Limits { frame_size_pixels = ", v63);
        *((_QWORD *)&v106 + 1) += v63;
        __s[*((_QWORD *)&v106 + 1)] = 0;
        rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", v65);
        if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x1AuLL)
          v68 = 26;
        else
          v68 = v106 + ~*((_QWORD *)&v106 + 1);
        memcpy(&__s[*((_QWORD *)&v106 + 1)], ", min_start_bitrate_bps = ", v68);
        *((_QWORD *)&v106 + 1) += v68;
        __s[*((_QWORD *)&v106 + 1)] = 0;
        rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", v64);
        if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x14uLL)
          v69 = 20;
        else
          v69 = v106 + ~*((_QWORD *)&v106 + 1);
        memcpy(&__s[*((_QWORD *)&v106 + 1)], ", min_bitrate_bps = ", v69);
        *((_QWORD *)&v106 + 1) += v69;
        __s[*((_QWORD *)&v106 + 1)] = 0;
        rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", v67);
        if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x14uLL)
          v70 = 20;
        else
          v70 = v106 + ~*((_QWORD *)&v106 + 1);
        memcpy(&__s[*((_QWORD *)&v106 + 1)], ", max_bitrate_bps = ", v70);
        *((_QWORD *)&v106 + 1) += v70;
        __s[*((_QWORD *)&v106 + 1)] = 0;
        rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", v66);
        if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 2uLL)
          v71 = 2;
        else
          v71 = v106 + ~*((_QWORD *)&v106 + 1);
        memcpy(&__s[*((_QWORD *)&v106 + 1)], "} ", v71);
        *((_QWORD *)&v106 + 1) += v71;
        __s[*((_QWORD *)&v106 + 1)] = 0;
        ++v59;
        v58 += 16;
      }
      while (v59 < (uint64_t)(*((_QWORD *)this + 23) - *((_QWORD *)this + 22)) >> 4);
    }
  }
  if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x19uLL)
    v72 = 25;
  else
    v72 = v106 + ~*((_QWORD *)&v106 + 1);
  memcpy(&__s[*((_QWORD *)&v106 + 1)], "] , supports_simulcast = ", v72);
  *((_QWORD *)&v106 + 1) += v72;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((unsigned __int8 *)this + 200));
  if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x1DuLL)
    v73 = 29;
  else
    v73 = v106 + ~*((_QWORD *)&v106 + 1);
  memcpy(&__s[*((_QWORD *)&v106 + 1)], ", preferred_pixel_formats = [", v73);
  *((_QWORD *)&v106 + 1) += v73;
  __s[*((_QWORD *)&v106 + 1)] = 0;
  v74 = *((_QWORD *)this + 26);
  if (v74 >= 2)
  {
    v75 = (char **)((char *)this + 216);
    v76 = (char *)this + 216;
    if ((v74 & 1) != 0)
      v76 = *v75;
    v77 = *(_DWORD *)v76 - 1;
    v78 = v77 > 7 ? "kNative" : off_24C0C3378[v77];
    v79 = strlen(v78);
    v80 = v79 >= (_QWORD)v106 + ~*((_QWORD *)&v106 + 1) ? v106 + ~*((_QWORD *)&v106 + 1) : v79;
    memcpy(&__s[*((_QWORD *)&v106 + 1)], v78, v80);
    *((_QWORD *)&v106 + 1) += v80;
    __s[*((_QWORD *)&v106 + 1)] = 0;
    if (*((_QWORD *)this + 26) >= 4uLL)
    {
      v81 = 1;
      do
      {
        v84 = (_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 2uLL ? 2 : v106 + ~*((_QWORD *)&v106 + 1);
        memcpy(&__s[*((_QWORD *)&v106 + 1)], ", ", v84);
        *((_QWORD *)&v106 + 1) += v84;
        __s[*((_QWORD *)&v106 + 1)] = 0;
        v85 = *((_QWORD *)this + 26);
        if (v81 >= v85 >> 1)
          goto LABEL_177;
        v86 = (char *)this + 216;
        if ((v85 & 1) != 0)
          v86 = *v75;
        v87 = *(_DWORD *)&v86[4 * v81] - 1;
        v88 = "kNative";
        if (v87 <= 7)
          v88 = off_24C0C3378[v87];
        v82 = strlen(v88);
        if (v82 >= (_QWORD)v106 + ~*((_QWORD *)&v106 + 1))
          v83 = v106 + ~*((_QWORD *)&v106 + 1);
        else
          v83 = v82;
        memcpy(&__s[*((_QWORD *)&v106 + 1)], v88, v83);
        *((_QWORD *)&v106 + 1) += v83;
        __s[*((_QWORD *)&v106 + 1)] = 0;
      }
      while (++v81 < *((_QWORD *)this + 26) >> 1);
    }
  }
  v89 = v106;
  v90 = *((_QWORD *)&v106 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v106 + 1)], "]", v106 != *((_QWORD *)&v106 + 1) + 1);
  v91 = *((_QWORD *)&v106 + 1);
  if (v89 != v90)
    v91 = *((_QWORD *)&v106 + 1) + 1;
  *((_QWORD *)&v106 + 1) = v91;
  __s[v91] = 0;
  v92 = v103;
  if (*((_BYTE *)this + 241))
  {
    if ((_QWORD)v106 + ~*((_QWORD *)&v106 + 1) >= 0x12uLL)
      v93 = 18;
    else
      v93 = v106 + ~*((_QWORD *)&v106 + 1);
    memcpy(&__s[*((_QWORD *)&v106 + 1)], ", is_qp_trusted = ", v93);
    *((_QWORD *)&v106 + 1) += v93;
    __s[*((_QWORD *)&v106 + 1)] = 0;
    if (!*((_BYTE *)this + 241))
    {
      std::__throw_bad_optional_access[abi:sn180100]();
      return webrtc::VideoEncoder::EncoderInfo::operator==();
    }
    rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((unsigned __int8 *)this + 240));
  }
  v94 = v106;
  v95 = *((_QWORD *)&v106 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v106 + 1)], "}", v106 != *((_QWORD *)&v106 + 1) + 1);
  v96 = *((_QWORD *)&v106 + 1);
  if (v94 != v95)
    v96 = *((_QWORD *)&v106 + 1) + 1;
  *((_QWORD *)&v106 + 1) = v96;
  __s[v96] = 0;
  v97 = __s;
  if (!__s)
    goto LABEL_176;
  result = strlen(__s);
  if (result >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v99 = result;
  if (result > 0x16)
  {
    v101 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17)
      v101 = result | 7;
    v102 = v101 + 1;
    result = (unint64_t)operator new(v101 + 1);
    v103[1] = v99;
    v103[2] = v102 | 0x8000000000000000;
    *v103 = result;
    v92 = (void *)result;
    v100 = (char *)(result + v99);
    if (result > (unint64_t)v97)
      goto LABEL_173;
LABEL_172:
    if (v100 > v97)
      goto LABEL_176;
    goto LABEL_173;
  }
  *((_BYTE *)v103 + 23) = result;
  v100 = (char *)v103 + result;
  if (v103 <= (unint64_t *)v97)
    goto LABEL_172;
LABEL_173:
  if (v99)
    result = (unint64_t)memmove(v92, v97, v99);
  *v100 = 0;
  return result;
}

BOOL webrtc::VideoEncoder::EncoderInfo::operator==(_BOOL8 result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  const void **v9;
  unsigned __int8 *v10;
  unint64_t v11;
  unint64_t v12;
  const void *v13;
  const void *v14;
  unint64_t v15;
  unint64_t v16;
  const void *v17;
  const void *v18;
  unint64_t v19;
  unint64_t v20;
  const void *v21;
  const void *v22;
  unint64_t v23;
  unint64_t v24;
  const void *v25;
  const void *v26;
  unint64_t v27;
  unint64_t v28;
  const void *v29;
  const void *v30;

  if ((*(_BYTE *)(result + 8) != 0) != (*(_BYTE *)(a2 + 8) != 0))
    return 0;
  v3 = result;
  if (!*(_BYTE *)(result + 8))
  {
LABEL_9:
    if (*(_DWORD *)(result + 12) != *(_DWORD *)(a2 + 12)
      || *(unsigned __int8 *)(result + 21) != *(unsigned __int8 *)(a2 + 21))
    {
      return 0;
    }
    v5 = *(unsigned __int8 *)(result + 47);
    if ((v5 & 0x80u) == 0)
      v6 = *(unsigned __int8 *)(result + 47);
    else
      v6 = *(_QWORD *)(result + 32);
    v7 = *(unsigned __int8 *)(a2 + 47);
    v8 = (char)v7;
    if ((v7 & 0x80u) != 0)
      v7 = *(_QWORD *)(a2 + 32);
    if (v6 != v7)
      return 0;
    v9 = (const void **)(result + 24);
    if (v8 >= 0)
      v10 = (unsigned __int8 *)(a2 + 24);
    else
      v10 = *(unsigned __int8 **)(a2 + 24);
    if ((v5 & 0x80) == 0)
    {
      if (*(_BYTE *)(result + 47))
      {
        while (*(unsigned __int8 *)v9 == *v10)
        {
          v9 = (const void **)((char *)v9 + 1);
          ++v10;
          if (!--v5)
            goto LABEL_26;
        }
        return 0;
      }
LABEL_26:
      if (*(unsigned __int8 *)(v3 + 48) == *(unsigned __int8 *)(a2 + 48)
        && *(unsigned __int8 *)(v3 + 49) == *(unsigned __int8 *)(a2 + 49))
      {
        v11 = *(_QWORD *)(v3 + 56);
        v12 = *(_QWORD *)(a2 + 56);
        if (v11 >> 1 == v12 >> 1)
        {
          v13 = (v12 & 1) != 0 ? *(const void **)(a2 + 64) : (const void *)(a2 + 64);
          v14 = (v11 & 1) != 0 ? *(const void **)(v3 + 64) : (const void *)(v3 + 64);
          if (!memcmp(v14, v13, v11 >> 1))
          {
            v15 = *(_QWORD *)(v3 + 80);
            v16 = *(_QWORD *)(a2 + 80);
            if (v15 >> 1 == v16 >> 1)
            {
              v17 = (v16 & 1) != 0 ? *(const void **)(a2 + 88) : (const void *)(a2 + 88);
              v18 = (v15 & 1) != 0 ? *(const void **)(v3 + 88) : (const void *)(v3 + 88);
              if (!memcmp(v18, v17, v15 >> 1))
              {
                v19 = *(_QWORD *)(v3 + 104);
                v20 = *(_QWORD *)(a2 + 104);
                if (v19 >> 1 == v20 >> 1)
                {
                  v21 = (v20 & 1) != 0 ? *(const void **)(a2 + 112) : (const void *)(a2 + 112);
                  v22 = (v19 & 1) != 0 ? *(const void **)(v3 + 112) : (const void *)(v3 + 112);
                  if (!memcmp(v22, v21, v19 >> 1))
                  {
                    v23 = *(_QWORD *)(v3 + 128);
                    v24 = *(_QWORD *)(a2 + 128);
                    if (v23 >> 1 == v24 >> 1)
                    {
                      v25 = (v24 & 1) != 0 ? *(const void **)(a2 + 136) : (const void *)(a2 + 136);
                      v26 = (v23 & 1) != 0 ? *(const void **)(v3 + 136) : (const void *)(v3 + 136);
                      if (!memcmp(v26, v25, v23 >> 1))
                      {
                        v27 = *(_QWORD *)(v3 + 152);
                        v28 = *(_QWORD *)(a2 + 152);
                        if (v27 >> 1 == v28 >> 1)
                        {
                          v29 = (v28 & 1) != 0 ? *(const void **)(a2 + 160) : (const void *)(a2 + 160);
                          v30 = (v27 & 1) != 0 ? *(const void **)(v3 + 160) : (const void *)(v3 + 160);
                          if (!memcmp(v30, v29, v27 >> 1)
                            && (std::operator==[abi:sn180100]<webrtc::VideoEncoder::ResolutionBitrateLimits,std::allocator<webrtc::VideoEncoder::ResolutionBitrateLimits>>(*(char **)(v3 + 176), *(char **)(v3 + 184), *(_DWORD **)(a2 + 176), *(_QWORD *)(a2 + 184)) & 1) != 0)
                          {
                            return *(unsigned __int8 *)(v3 + 200) == *(unsigned __int8 *)(a2 + 200);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return 0;
    }
    if (!memcmp(*v9, v10, *(_QWORD *)(result + 32)))
      goto LABEL_26;
    return 0;
  }
  if (*(_BYTE *)(a2 + 8))
  {
    if (*(_DWORD *)result != *(_DWORD *)a2 || *(_DWORD *)(result + 4) != *(_DWORD *)(a2 + 4))
      return 0;
    goto LABEL_9;
  }
  __break(1u);
  return result;
}

uint64_t std::operator==[abi:sn180100]<webrtc::VideoEncoder::ResolutionBitrateLimits,std::allocator<webrtc::VideoEncoder::ResolutionBitrateLimits>>(char *a1, char *a2, _DWORD *a3, uint64_t a4)
{
  if (a2 - a1 == a4 - (_QWORD)a3)
  {
    if (a1 == a2)
      return 1;
    while (*(_DWORD *)a1 == *a3
         && *((_DWORD *)a1 + 1) == a3[1]
         && *((_DWORD *)a1 + 2) == a3[2]
         && *((_DWORD *)a1 + 3) == a3[3])
    {
      a1 += 16;
      a3 += 4;
      if (a1 == a2)
        return 1;
    }
  }
  return 0;
}

void webrtc::VideoEncoder::EncoderInfo::GetEncoderBitrateLimitsForResolution(webrtc::VideoEncoder::EncoderInfo *this@<X0>, signed __int32 a2@<W1>, __n128 *a3@<X8>, __n128 a4@<Q0>)
{
  _BYTE *v6;
  _BYTE *v7;
  int64_t v8;
  __n128 *v9;
  __n128 *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __n128 *v15;

  v7 = (_BYTE *)*((_QWORD *)this + 22);
  v6 = (_BYTE *)*((_QWORD *)this + 23);
  v8 = v6 - v7;
  if (v6 == v7)
  {
    v9 = 0;
    v10 = 0;
  }
  else
  {
    if (v8 < 0)
      abort();
    v9 = (__n128 *)operator new(v6 - v7);
    v10 = &v9[v8 >> 4];
    memcpy(v9, v7, v8);
  }
  v11 = v10 - v9;
  v12 = 126 - 2 * __clz(v11);
  if (v10 == v9)
    v13 = 0;
  else
    v13 = v12;
  std::__introsort<std::_ClassicAlgPolicy,webrtc::VideoEncoder::EncoderInfo::GetEncoderBitrateLimitsForResolution(int)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits *,false>((uint64_t)v9, v10, v13, 1, a4);
  if (v10 == v9)
  {
    a3->n128_u8[0] = 0;
    a3[1].n128_u8[0] = 0;
    if (v9)
      operator delete(v9);
  }
  else
  {
    if (v11 <= 1)
      v14 = 1;
    else
      v14 = v10 - v9;
    v15 = v9;
    while ((signed __int32)v15->n128_u32[0] < a2)
    {
      ++v15;
      if (!--v14)
      {
        a3->n128_u8[0] = 0;
        goto LABEL_19;
      }
    }
    *a3 = *v15;
    LOBYTE(v14) = 1;
LABEL_19:
    a3[1].n128_u8[0] = v14;
    operator delete(v9);
  }
}

uint64_t webrtc::VideoEncoder::RateControlParameters::RateControlParameters(uint64_t this)
{
  *(_QWORD *)this = &off_24C0C3368;
  *(_DWORD *)(this + 8) = 0;
  *(_BYTE *)(this + 12) = 0;
  *(_BYTE *)(this + 16) = 0;
  *(_BYTE *)(this + 20) = 0;
  *(_BYTE *)(this + 24) = 0;
  *(_BYTE *)(this + 28) = 0;
  *(_BYTE *)(this + 32) = 0;
  *(_BYTE *)(this + 36) = 0;
  *(_BYTE *)(this + 40) = 0;
  *(_BYTE *)(this + 44) = 0;
  *(_BYTE *)(this + 48) = 0;
  *(_BYTE *)(this + 52) = 0;
  *(_BYTE *)(this + 56) = 0;
  *(_BYTE *)(this + 60) = 0;
  *(_BYTE *)(this + 64) = 0;
  *(_BYTE *)(this + 68) = 0;
  *(_BYTE *)(this + 72) = 0;
  *(_BYTE *)(this + 76) = 0;
  *(_BYTE *)(this + 80) = 0;
  *(_BYTE *)(this + 84) = 0;
  *(_BYTE *)(this + 88) = 0;
  *(_BYTE *)(this + 92) = 0;
  *(_BYTE *)(this + 96) = 0;
  *(_BYTE *)(this + 100) = 0;
  *(_BYTE *)(this + 104) = 0;
  *(_BYTE *)(this + 108) = 0;
  *(_BYTE *)(this + 112) = 0;
  *(_BYTE *)(this + 116) = 0;
  *(_BYTE *)(this + 120) = 0;
  *(_BYTE *)(this + 124) = 0;
  *(_BYTE *)(this + 128) = 0;
  *(_BYTE *)(this + 132) = 0;
  *(_BYTE *)(this + 136) = 0;
  *(_BYTE *)(this + 140) = 0;
  *(_BYTE *)(this + 144) = 0;
  *(_BYTE *)(this + 148) = 0;
  *(_BYTE *)(this + 152) = 0;
  *(_BYTE *)(this + 156) = 0;
  *(_BYTE *)(this + 160) = 0;
  *(_BYTE *)(this + 164) = 0;
  *(_BYTE *)(this + 168) = 0;
  *(_BYTE *)(this + 172) = 0;
  *(_DWORD *)(this + 176) = 0;
  *(_BYTE *)(this + 180) = 0;
  *(_BYTE *)(this + 184) = 0;
  *(_BYTE *)(this + 188) = 0;
  *(_BYTE *)(this + 192) = 0;
  *(_BYTE *)(this + 196) = 0;
  *(_BYTE *)(this + 200) = 0;
  *(_BYTE *)(this + 204) = 0;
  *(_BYTE *)(this + 208) = 0;
  *(_BYTE *)(this + 212) = 0;
  *(_BYTE *)(this + 216) = 0;
  *(_BYTE *)(this + 220) = 0;
  *(_BYTE *)(this + 224) = 0;
  *(_BYTE *)(this + 228) = 0;
  *(_BYTE *)(this + 232) = 0;
  *(_BYTE *)(this + 236) = 0;
  *(_BYTE *)(this + 240) = 0;
  *(_BYTE *)(this + 244) = 0;
  *(_BYTE *)(this + 248) = 0;
  *(_BYTE *)(this + 252) = 0;
  *(_BYTE *)(this + 256) = 0;
  *(_BYTE *)(this + 260) = 0;
  *(_BYTE *)(this + 264) = 0;
  *(_BYTE *)(this + 268) = 0;
  *(_BYTE *)(this + 272) = 0;
  *(_BYTE *)(this + 276) = 0;
  *(_BYTE *)(this + 280) = 0;
  *(_BYTE *)(this + 284) = 0;
  *(_BYTE *)(this + 288) = 0;
  *(_BYTE *)(this + 292) = 0;
  *(_BYTE *)(this + 296) = 0;
  *(_BYTE *)(this + 300) = 0;
  *(_BYTE *)(this + 304) = 0;
  *(_BYTE *)(this + 308) = 0;
  *(_BYTE *)(this + 312) = 0;
  *(_BYTE *)(this + 316) = 0;
  *(_BYTE *)(this + 320) = 0;
  *(_BYTE *)(this + 324) = 0;
  *(_BYTE *)(this + 328) = 0;
  *(_BYTE *)(this + 332) = 0;
  *(_BYTE *)(this + 336) = 0;
  *(_BYTE *)(this + 340) = 0;
  *(_QWORD *)(this + 344) = 0;
  *(_QWORD *)(this + 352) = 0;
  return this;
}

uint64_t webrtc::VideoEncoder::RateControlParameters::RateControlParameters(uint64_t this, const webrtc::VideoBitrateAllocation *a2, double a3)
{
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;

  *(_QWORD *)this = &off_24C0C3368;
  *(_DWORD *)(this + 8) = 0;
  *(_BYTE *)(this + 12) = 0;
  *(_BYTE *)(this + 16) = 0;
  *(_BYTE *)(this + 20) = 0;
  *(_BYTE *)(this + 24) = 0;
  *(_BYTE *)(this + 28) = 0;
  *(_BYTE *)(this + 32) = 0;
  *(_BYTE *)(this + 36) = 0;
  *(_BYTE *)(this + 40) = 0;
  *(_BYTE *)(this + 44) = 0;
  *(_BYTE *)(this + 48) = 0;
  *(_BYTE *)(this + 52) = 0;
  *(_BYTE *)(this + 56) = 0;
  *(_BYTE *)(this + 60) = 0;
  *(_BYTE *)(this + 64) = 0;
  *(_BYTE *)(this + 68) = 0;
  *(_BYTE *)(this + 72) = 0;
  *(_BYTE *)(this + 76) = 0;
  *(_BYTE *)(this + 80) = 0;
  *(_BYTE *)(this + 84) = 0;
  *(_BYTE *)(this + 88) = 0;
  *(_BYTE *)(this + 92) = 0;
  *(_BYTE *)(this + 96) = 0;
  *(_BYTE *)(this + 100) = 0;
  *(_BYTE *)(this + 104) = 0;
  *(_BYTE *)(this + 108) = 0;
  *(_BYTE *)(this + 112) = 0;
  *(_BYTE *)(this + 116) = 0;
  *(_BYTE *)(this + 120) = 0;
  *(_BYTE *)(this + 124) = 0;
  *(_BYTE *)(this + 128) = 0;
  *(_BYTE *)(this + 132) = 0;
  *(_BYTE *)(this + 136) = 0;
  *(_BYTE *)(this + 140) = 0;
  *(_BYTE *)(this + 144) = 0;
  *(_BYTE *)(this + 148) = 0;
  *(_BYTE *)(this + 152) = 0;
  *(_BYTE *)(this + 156) = 0;
  *(_BYTE *)(this + 160) = 0;
  *(_BYTE *)(this + 164) = 0;
  *(_BYTE *)(this + 168) = 0;
  *(_BYTE *)(this + 172) = 0;
  v3 = *(_OWORD *)a2;
  v4 = *((_OWORD *)a2 + 2);
  *(_OWORD *)(this + 192) = *((_OWORD *)a2 + 1);
  *(_OWORD *)(this + 208) = v4;
  *(_OWORD *)(this + 176) = v3;
  v5 = *((_OWORD *)a2 + 3);
  v6 = *((_OWORD *)a2 + 4);
  v7 = *((_OWORD *)a2 + 6);
  *(_OWORD *)(this + 256) = *((_OWORD *)a2 + 5);
  *(_OWORD *)(this + 272) = v7;
  *(_OWORD *)(this + 224) = v5;
  *(_OWORD *)(this + 240) = v6;
  v8 = *((_OWORD *)a2 + 7);
  v9 = *((_OWORD *)a2 + 8);
  v10 = *((_OWORD *)a2 + 9);
  *(_QWORD *)(this + 336) = *((_QWORD *)a2 + 20);
  *(_OWORD *)(this + 304) = v9;
  *(_OWORD *)(this + 320) = v10;
  *(_OWORD *)(this + 288) = v8;
  *(double *)(this + 344) = a3;
  *(_QWORD *)(this + 352) = *(unsigned int *)a2;
  return this;
}

void webrtc::VideoEncoder::RateControlParameters::~RateControlParameters(webrtc::VideoEncoder::RateControlParameters *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::VideoEncoder::InitEncode(webrtc::VideoEncoder *this, const webrtc::VideoCodec *a2, int a3, uint64_t a4)
{
  _BYTE v5[4];
  int v6;
  uint64_t v7;
  char v8;
  char v9;

  v5[0] = 0;
  v6 = a3;
  v7 = a4;
  v8 = 0;
  v9 = 0;
  return (*(uint64_t (**)(webrtc::VideoEncoder *, const webrtc::VideoCodec *, _BYTE *))(*(_QWORD *)this + 32))(this, a2, v5);
}

__n128 std::__introsort<std::_ClassicAlgPolicy,webrtc::VideoEncoder::EncoderInfo::GetEncoderBitrateLimitsForResolution(int)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits *,false>(uint64_t a1, __n128 *a2, uint64_t a3, char a4, __n128 result)
{
  __n128 *v9;
  __n128 *v10;
  __n128 *v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  __n128 *v16;
  signed int v17;
  signed __int32 v18;
  signed int v19;
  __n128 *v20;
  __n128 *v21;
  unsigned int *v22;
  __n128 *v23;
  signed int v24;
  signed int v25;
  signed int v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  __n128 *v30;
  unsigned int *v31;
  __n128 *v32;
  signed int v33;
  signed int v34;
  signed int v35;
  __n128 v36;
  __n128 v37;
  __n128 v38;
  signed __int32 v39;
  signed __int32 v40;
  uint64_t v41;
  unsigned int *v42;
  unsigned int *v43;
  __n128 *v44;
  int v45;
  int v46;
  __n128 *v47;
  __n128 *v48;
  int v49;
  int v50;
  __n128 *v51;
  BOOL v52;
  __n128 v53;
  __n128 *v54;
  int v55;
  unsigned int *v56;
  __n128 *v57;
  int v58;
  __n128 *v59;
  int v60;
  int v61;
  __n128 *v62;
  signed int v63;
  signed int v64;
  signed int v65;
  unsigned __int32 v66;
  __n128 *v67;
  __n128 *v68;
  __n128 *v69;
  __n128 *v70;
  signed int v71;
  BOOL v73;
  uint64_t v74;
  __n128 *v75;
  uint64_t v76;
  __n128 *v77;
  signed __int32 v78;
  uint64_t v79;
  signed __int32 v80;
  int64_t v81;
  int64_t v82;
  uint64_t v83;
  unsigned int *v84;
  signed int v85;
  BOOL v86;
  unsigned int *v87;
  signed int v88;
  signed int v89;
  signed int v90;
  unsigned int *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  _OWORD *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  __n128 *v101;
  signed __int32 v102;
  _OWORD *v103;
  uint64_t v104;
  uint64_t v105;
  unsigned int *v106;
  signed __int32 v107;
  uint64_t v108;
  __n128 *v109;
  __n128 *v111;
  signed __int32 v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unsigned int v116;
  unsigned int v117;
  int v118;
  __n128 v119;
  __n128 v120;
  __n128 v121;
  __n128 v122;
  __n128 v123;
  __n128 v124;
  __n128 v125;
  __n128 v126;
  __n128 v127;
  __n128 v128;
  __n128 v129;
  __n128 v130;
  __n128 v131;
  __n128 v132;
  __n128 v133;
  __n128 v134;
  __n128 v135;
  __n128 v136;
  __n128 v137;
  __n128 v138;
  __n128 v139;
  uint64_t v140;
  uint64_t v141;
  __n128 v142;
  __n128 v143;
  unint64_t v144;
  __n128 v145;
  unsigned int v146;
  unsigned int v147;
  unsigned __int32 v148;

BOOL std::__insertion_sort_incomplete[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::VideoEncoder::EncoderInfo::GetEncoderBitrateLimitsForResolution(int)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits *>(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v5;
  _BOOL8 result;
  __n128 *v7;
  __n128 *v8;
  int v9;
  int v10;
  __n128 v11;
  __n128 *v12;
  int v13;
  __n128 *v14;
  int v15;
  signed __int32 v16;
  __n128 v17;
  __n128 *v18;
  __n128 *v19;
  __n128 *v20;
  __n128 *v21;
  int v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;
  __n128 v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  __n128 v31;
  __n128 v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;

  v5 = (a2 - a1) >> 4;
  result = 1;
  switch(v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v7 = (__n128 *)(a2 - 16);
      if (*(_DWORD *)(a2 - 16) < *(_DWORD *)a1)
        goto LABEL_6;
      return result;
    case 3:
      v8 = (__n128 *)(a1 + 16);
      v9 = *(_DWORD *)(a1 + 16);
      v7 = (__n128 *)(a2 - 16);
      v10 = *(_DWORD *)(a2 - 16);
      if (v9 >= *(_DWORD *)a1)
      {
        if (v10 < v9)
        {
          v27 = *v8;
          *v8 = *v7;
          *v7 = v27;
          if (*(_DWORD *)(a1 + 16) < *(_DWORD *)a1)
          {
            v28 = *(__n128 *)a1;
            *(__n128 *)a1 = *v8;
            *v8 = v28;
          }
        }
      }
      else
      {
        if (v10 < v9)
        {
LABEL_6:
          v11 = *(__n128 *)a1;
          *(__n128 *)a1 = *v7;
LABEL_7:
          *v7 = v11;
          return result;
        }
        v31 = *(__n128 *)a1;
        *(__n128 *)a1 = *v8;
        *v8 = v31;
        if ((signed __int32)v7->n128_u32[0] < *(_DWORD *)(a1 + 16))
        {
          v11 = *v8;
          *v8 = *v7;
          goto LABEL_7;
        }
      }
      return result;
    case 4:
      std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::EncoderInfoSettings::GetSinglecastBitrateLimitForResolutionWhenQpIsUntrusted(std::optional<int>,std::vector<webrtc::VideoEncoder::ResolutionBitrateLimits> const&)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits*>((__n128 *)a1, (__n128 *)(a1 + 16), (int *)(a1 + 32), (_OWORD *)(a2 - 16), a3);
      return 1;
    case 5:
      v18 = (__n128 *)(a1 + 16);
      v19 = (__n128 *)(a1 + 32);
      v20 = (__n128 *)(a1 + 48);
      std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::EncoderInfoSettings::GetSinglecastBitrateLimitForResolutionWhenQpIsUntrusted(std::optional<int>,std::vector<webrtc::VideoEncoder::ResolutionBitrateLimits> const&)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits*>((__n128 *)a1, (__n128 *)(a1 + 16), (int *)(a1 + 32), (_OWORD *)(a1 + 48), a3);
      v22 = *(_DWORD *)(a2 - 16);
      v21 = (__n128 *)(a2 - 16);
      if (v22 < *(_DWORD *)(a1 + 48))
      {
        v23 = *v20;
        *v20 = *v21;
        *v21 = v23;
        if ((signed __int32)v20->n128_u32[0] < (signed __int32)v19->n128_u32[0])
        {
          v24 = *v19;
          *v19 = *v20;
          *v20 = v24;
          if ((signed __int32)v19->n128_u32[0] < (signed __int32)v18->n128_u32[0])
          {
            v25 = *v18;
            *v18 = *v19;
            *v19 = v25;
            if (*(_DWORD *)(a1 + 16) < *(_DWORD *)a1)
            {
              v26 = *(__n128 *)a1;
              *(__n128 *)a1 = *v18;
              *v18 = v26;
            }
          }
        }
      }
      return 1;
    default:
      v12 = (__n128 *)(a1 + 32);
      v13 = *(_DWORD *)(a1 + 32);
      v14 = (__n128 *)(a1 + 16);
      v15 = *(_DWORD *)(a1 + 16);
      v16 = *(_DWORD *)a1;
      if (v15 >= *(_DWORD *)a1)
      {
        if (v13 < v15)
        {
          v29 = *v14;
          *v14 = *v12;
          *v12 = v29;
          if ((signed __int32)v14->n128_u32[0] < v16)
          {
            v30 = *(__n128 *)a1;
            *(__n128 *)a1 = *v14;
            *v14 = v30;
          }
        }
      }
      else
      {
        if (v13 >= v15)
        {
          v32 = *(__n128 *)a1;
          *(__n128 *)a1 = *v14;
          *v14 = v32;
          if (v13 >= *(_DWORD *)(a1 + 16))
            goto LABEL_29;
          v17 = *v14;
          *v14 = *v12;
        }
        else
        {
          v17 = *(__n128 *)a1;
          *(__n128 *)a1 = *v12;
        }
        *v12 = v17;
      }
LABEL_29:
      v33 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v34 = 0;
      v35 = 0;
      while (1)
      {
        v37 = *(_DWORD *)v33;
        if (*(_DWORD *)v33 < (signed __int32)v12->n128_u32[0])
        {
          v40 = *(_QWORD *)(v33 + 4);
          v41 = *(_DWORD *)(v33 + 12);
          v38 = v34;
          do
          {
            *(_OWORD *)(a1 + v38 + 48) = *(_OWORD *)(a1 + v38 + 32);
            if (v38 == -32)
            {
              v36 = a1;
              goto LABEL_32;
            }
            v39 = *(_DWORD *)(a1 + v38 + 16);
            v38 -= 16;
          }
          while (v37 < v39);
          v36 = a1 + v38 + 48;
LABEL_32:
          *(_DWORD *)v36 = v37;
          *(_QWORD *)(v36 + 4) = v40;
          *(_DWORD *)(v36 + 12) = v41;
          if (++v35 == 8)
            return v33 + 16 == a2;
        }
        v12 = (__n128 *)v33;
        v34 += 16;
        v33 += 16;
        if (v33 == a2)
          return 1;
      }
  }
}

unint64_t *absl::inlined_vector_internal::Storage<unsigned char,4ul,std::allocator<unsigned char>>::InitFrom(unint64_t *result, unint64_t *a2)
{
  unint64_t v2;
  unint64_t *v4;
  size_t v5;
  void *v6;
  const void *v7;
  size_t v8;

  v2 = *a2;
  if (*a2 <= 1)
  {
    __break(1u);
  }
  else
  {
    v4 = result;
    v5 = v2 >> 1;
    if ((v2 & 1) != 0)
    {
      if (v5 <= 0x20)
        v8 = 32;
      else
        v8 = v2 >> 1;
      v6 = operator new(v8);
      v4[1] = (unint64_t)v6;
      v4[2] = v8;
      v7 = (const void *)a2[1];
    }
    else
    {
      v6 = result + 1;
      v7 = a2 + 1;
    }
    result = (unint64_t *)memcpy(v6, v7, v5);
    *v4 = *a2;
  }
  return result;
}

void *absl::inlined_vector_internal::Storage<webrtc::VideoFrameBuffer::Type,5ul,std::allocator<webrtc::VideoFrameBuffer::Type>>::InitFrom(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v5;
  void *v6;
  const void *v7;
  unint64_t v8;
  void *result;

  v2 = *a2;
  if (*a2 <= 1)
  {
    __break(1u);
    goto LABEL_11;
  }
  v5 = v2 >> 1;
  if ((v2 & 1) != 0)
  {
    if (v5 <= 0xA)
      v8 = 10;
    else
      v8 = v2 >> 1;
    if (!(v8 >> 62))
    {
      v6 = operator new(4 * v8);
      a1[1] = (unint64_t)v6;
      a1[2] = v8;
      v7 = (const void *)a2[1];
      goto LABEL_9;
    }
LABEL_11:
    std::__throw_bad_array_new_length[abi:sn180100]();
  }
  v6 = a1 + 1;
  v7 = a2 + 1;
LABEL_9:
  result = memcpy(v6, v7, 4 * v5);
  *a1 = *a2;
  return result;
}

void webrtc::VideoEncoderConfig::~VideoEncoderConfig(webrtc::VideoEncoderConfig *this)
{
  void *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;

  v2 = (void *)*((_QWORD *)this + 21);
  if (v2)
  {
    *((_QWORD *)this + 22) = v2;
    operator delete(v2);
  }
  v3 = *((_QWORD *)this + 18);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (void *)*((_QWORD *)this + 14);
  if (v4)
  {
    *((_QWORD *)this + 15) = v4;
    operator delete(v4);
  }
  v5 = *((_QWORD *)this + 13);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  if ((*((_BYTE *)this + 56) & 1) == 0)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)this + 32, *((_QWORD *)this + 5));
    if ((*((char *)this + 31) & 0x80000000) == 0)
      return;
LABEL_13:
    operator delete(*((void **)this + 1));
    return;
  }
  operator delete(*((void **)this + 8));
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)this + 32, *((_QWORD *)this + 5));
  if (*((char *)this + 31) < 0)
    goto LABEL_13;
}

unint64_t webrtc::VideoEncoderConfig::ToString@<X0>(unint64_t this@<X0>, char *a2@<X8>)
{
  uint64_t v3;
  unint64_t v4;
  const char *v5;
  size_t v6;
  size_t v7;
  char *v8;
  size_t v9;
  size_t v10;
  int v11;
  const char *v12;
  unint64_t v13;
  size_t v14;
  size_t v15;
  size_t v16;
  uint64_t v17;
  const char *v18;
  unint64_t v19;
  size_t v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  size_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  char *__s;
  __int128 v31;
  char __src;
  char v33[1024];
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  __s = v33;
  v31 = xmmword_208F05840;
  strcpy(v33, "{codec_type: ");
  v3 = *(int *)this;
  if (v3 >= 6)
LABEL_48:
    rtc::webrtc_checks_impl::UnreachableCodeReached((rtc::webrtc_checks_impl *)this);
  v4 = this;
  v5 = (&off_24C0C33B8)[v3];
  v6 = strlen(v5);
  if (v6 >= 0x3F2)
    v7 = 1010;
  else
    v7 = v6;
  memcpy(&v33[13], v5, v7);
  v8 = &v33[v7 + 13];
  *v8 = 0;
  if (1010 - v7 >= 0x10)
    v9 = 16;
  else
    v9 = 1010 - v7;
  memcpy(v8, ", content_type: ", v9);
  v10 = v9 + v7 + 13;
  v33[v10] = 0;
  v11 = *(_DWORD *)(v4 + 136);
  if (v11)
  {
    if (v11 != 1)
      goto LABEL_16;
    v12 = "kScreenshare";
    v13 = 12;
  }
  else
  {
    v12 = "kRealtimeVideo";
    v13 = 14;
  }
  if (v13 >= 1023 - v10)
    v14 = 1023 - v10;
  else
    v14 = v13;
  memcpy(&v33[v10], v12, v14);
  v10 += v14;
  v33[v10] = 0;
LABEL_16:
  if (1023 - v10 >= 0x16)
    v15 = 22;
  else
    v15 = 1023 - v10;
  memcpy(&v33[v10], ", frame_drop_enabled: ", v15);
  *((_QWORD *)&v31 + 1) = v10 + v15;
  v33[*((_QWORD *)&v31 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *(unsigned __int8 *)(v4 + 140));
  if ((_QWORD)v31 + ~*((_QWORD *)&v31 + 1) >= 0x1DuLL)
    v16 = 29;
  else
    v16 = v31 + ~*((_QWORD *)&v31 + 1);
  memcpy(&__s[*((_QWORD *)&v31 + 1)], ", encoder_specific_settings: ", v16);
  *((_QWORD *)&v31 + 1) += v16;
  __s[*((_QWORD *)&v31 + 1)] = 0;
  v17 = *(_QWORD *)(v4 + 144);
  if (v17)
    v18 = "(ptr)";
  else
    v18 = "NULL";
  v19 = 4;
  if (v17)
    v19 = 5;
  if (v19 >= (_QWORD)v31 + ~*((_QWORD *)&v31 + 1))
    v20 = v31 + ~*((_QWORD *)&v31 + 1);
  else
    v20 = v19;
  memcpy(&__s[*((_QWORD *)&v31 + 1)], v18, v20);
  *((_QWORD *)&v31 + 1) += v20;
  __s[*((_QWORD *)&v31 + 1)] = 0;
  if ((_QWORD)v31 + ~*((_QWORD *)&v31 + 1) >= 0x1CuLL)
    v21 = 28;
  else
    v21 = v31 + ~*((_QWORD *)&v31 + 1);
  memcpy(&__s[*((_QWORD *)&v31 + 1)], ", min_transmit_bitrate_bps: ", v21);
  *((_QWORD *)&v31 + 1) += v21;
  __s[*((_QWORD *)&v31 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *(_DWORD *)(v4 + 152));
  __src = 125;
  v22 = v31;
  v23 = *((_QWORD *)&v31 + 1) + 1;
  this = (unint64_t)memcpy(&__s[*((_QWORD *)&v31 + 1)], &__src, v31 != *((_QWORD *)&v31 + 1) + 1);
  v24 = *((_QWORD *)&v31 + 1);
  if (v22 != v23)
    v24 = *((_QWORD *)&v31 + 1) + 1;
  *((_QWORD *)&v31 + 1) = v24;
  __s[v24] = 0;
  v25 = __s;
  if (!__s)
  {
LABEL_47:
    __break(1u);
    goto LABEL_48;
  }
  this = strlen(__s);
  if (this >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v26 = this;
  if (this <= 0x16)
  {
    a2[23] = this;
    v27 = &a2[this];
    if (a2 > v25)
      goto LABEL_44;
    goto LABEL_43;
  }
  v28 = (this & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((this | 7) != 0x17)
    v28 = this | 7;
  v29 = v28 + 1;
  this = (unint64_t)operator new(v28 + 1);
  *((_QWORD *)a2 + 1) = v26;
  *((_QWORD *)a2 + 2) = v29 | 0x8000000000000000;
  *(_QWORD *)a2 = this;
  a2 = (char *)this;
  v27 = (char *)(this + v26);
  if (this <= (unint64_t)v25)
  {
LABEL_43:
    if (v27 <= v25)
      goto LABEL_44;
    goto LABEL_47;
  }
LABEL_44:
  if (v26)
    this = (unint64_t)memmove(a2, v25, v26);
  *v27 = 0;
  return this;
}

webrtc::VideoEncoderConfig *webrtc::VideoEncoderConfig::VideoEncoderConfig(webrtc::VideoEncoderConfig *this, const webrtc::VideoEncoderConfig *a2)
{
  void (***v4)(_QWORD);
  _BYTE *v5;
  _BYTE *v6;
  int64_t v7;
  char *v8;
  char *v9;
  int v10;
  void (***v11)(_QWORD);
  uint64_t v12;
  uint64_t v13;
  int64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  *(_DWORD *)this = *(_DWORD *)a2;
  webrtc::SdpVideoFormat::SdpVideoFormat((std::string *)((char *)this + 8), (const webrtc::VideoEncoderConfig *)((char *)a2 + 8));
  v4 = (void (***)(_QWORD))*((_QWORD *)a2 + 13);
  *((_QWORD *)this + 13) = v4;
  if (v4)
    (**v4)(v4);
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  v6 = (_BYTE *)*((_QWORD *)a2 + 14);
  v5 = (_BYTE *)*((_QWORD *)a2 + 15);
  v7 = v5 - v6;
  if (v5 != v6)
  {
    if (0x8E38E38E38E38E39 * (v7 >> 2) >= 0x71C71C71C71C71DLL)
      goto LABEL_14;
    v8 = (char *)operator new(v7);
    *((_QWORD *)this + 14) = v8;
    *((_QWORD *)this + 15) = v8;
    v9 = &v8[4 * (v7 >> 2)];
    *((_QWORD *)this + 16) = v9;
    memcpy(v8, v6, v7 - 3);
    *((_QWORD *)this + 15) = v9;
  }
  v10 = *((_DWORD *)a2 + 34);
  *((_BYTE *)this + 140) = *((_BYTE *)a2 + 140);
  *((_DWORD *)this + 34) = v10;
  v11 = (void (***)(_QWORD))*((_QWORD *)a2 + 18);
  *((_QWORD *)this + 18) = v11;
  if (v11)
    (**v11)(v11);
  *(_OWORD *)((char *)this + 152) = *(_OWORD *)((char *)a2 + 152);
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 21) = 0;
  v12 = *((_QWORD *)a2 + 21);
  v13 = *((_QWORD *)a2 + 22);
  v14 = v13 - v12;
  if (v13 != v12)
  {
    v15 = 0xAAAAAAAAAAAAAAABLL * (v14 >> 5);
    if (v15 < 0x2AAAAAAAAAAAAABLL)
    {
      v16 = (char *)operator new(v14);
      v17 = 0;
      *((_QWORD *)this + 21) = v16;
      *((_QWORD *)this + 22) = v16;
      *((_QWORD *)this + 23) = &v16[96 * v15];
      do
      {
        v18 = &v16[v17];
        v19 = *(_OWORD *)(v12 + v17 + 16);
        *(_OWORD *)v18 = *(_OWORD *)(v12 + v17);
        *((_OWORD *)v18 + 1) = v19;
        v20 = *(_OWORD *)(v12 + v17 + 32);
        v21 = *(_OWORD *)(v12 + v17 + 48);
        v22 = *(_OWORD *)(v12 + v17 + 64);
        *(_OWORD *)(v18 + 77) = *(_OWORD *)(v12 + v17 + 77);
        *((_OWORD *)v18 + 3) = v21;
        *((_OWORD *)v18 + 4) = v22;
        *((_OWORD *)v18 + 2) = v20;
        v17 += 96;
      }
      while (v12 + v17 != v13);
      *((_QWORD *)this + 22) = &v16[v17];
      goto LABEL_13;
    }
LABEL_14:
    abort();
  }
LABEL_13:
  *((_OWORD *)this + 12) = *((_OWORD *)a2 + 12);
  return this;
}

VideoCodecVP8 *webrtc::VideoEncoderConfig::Vp8EncoderSpecificSettings::FillVideoCodecVp8(VideoCodecVP8 *this, VideoCodecVP8 *a2)
{
  *a2 = this[1];
  return this;
}

__n128 webrtc::VideoEncoderConfig::Vp9EncoderSpecificSettings::FillVideoCodecVp9(webrtc::VideoEncoderConfig::Vp9EncoderSpecificSettings *this, VideoCodecVP9 *a2)
{
  __n128 result;

  result = *(__n128 *)((char *)this + 8);
  *a2 = (VideoCodecVP9)result;
  return result;
}

uint64_t webrtc::VideoEncoderConfig::Av1EncoderSpecificSettings::FillVideoCodecAv1(uint64_t this, VideoCodecAV1 *a2)
{
  a2->var0 = *(BOOL *)(this + 8);
  return this;
}

void webrtc::CreateVideoEncoderSoftwareFallbackWrapper(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, int a4@<W3>, uint64_t *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *p_p;
  unsigned __int8 v16;
  int v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;
  void (****v23)(webrtc::FieldTrialParameterInterface *__hidden);
  int v24;
  int v25;
  BOOL v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  void (**v41)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v42;
  void *v43;
  uint64_t v44;
  void *v45;
  __int128 v46;
  char v47;
  unsigned int v48;
  char v49;
  __int128 __p;
  unsigned __int8 v51;
  void (***v52)(webrtc::FieldTrialParameterInterface *__hidden);
  unint64_t v53;
  unsigned __int8 v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)(a1 + 8);
  v10 = operator new();
  v11 = *a2;
  *a2 = 0;
  v12 = *a3;
  *a3 = 0;
  *(_QWORD *)v10 = &off_24C0C33F8;
  *(_QWORD *)(v10 + 16) = 0;
  *(_QWORD *)(v10 + 24) = 0;
  *(_QWORD *)(v10 + 8) = 0;
  *(_BYTE *)(v10 + 32) = 1;
  *(_DWORD *)(v10 + 36) = 0;
  *(_BYTE *)(v10 + 40) = 0;
  *(_OWORD *)(v10 + 44) = 0u;
  *(_OWORD *)(v10 + 60) = 0u;
  *(_OWORD *)(v10 + 76) = 0u;
  *(_OWORD *)(v10 + 92) = 0u;
  *(_OWORD *)(v10 + 108) = 0u;
  *(_OWORD *)(v10 + 124) = 0u;
  *(_OWORD *)(v10 + 136) = 0u;
  *(_BYTE *)(v10 + 56) = 1;
  *(_QWORD *)(v10 + 68) = 0;
  *(_QWORD *)(v10 + 60) = 0;
  *(_BYTE *)(v10 + 76) = 0;
  *(_BYTE *)(v10 + 92) = 1;
  *(_QWORD *)(v10 + 96) = 0;
  *(_QWORD *)(v10 + 104) = 0;
  *(_BYTE *)(v10 + 112) = 0;
  *(_BYTE *)(v10 + 128) = 1;
  *(_QWORD *)(v10 + 140) = 0;
  *(_QWORD *)(v10 + 132) = 0;
  *(_BYTE *)(v10 + 148) = 0;
  *(_DWORD *)(v10 + 328) = 0;
  *(_OWORD *)(v10 + 296) = 0u;
  *(_OWORD *)(v10 + 312) = 0u;
  *(_OWORD *)(v10 + 264) = 0u;
  *(_OWORD *)(v10 + 280) = 0u;
  *(_OWORD *)(v10 + 248) = 0u;
  *(_OWORD *)(v10 + 232) = 0u;
  *(_OWORD *)(v10 + 216) = 0u;
  *(_OWORD *)(v10 + 200) = 0u;
  *(_OWORD *)(v10 + 184) = 0u;
  *(_OWORD *)(v10 + 168) = 0u;
  *(_OWORD *)(v10 + 152) = 0u;
  *(_BYTE *)(v10 + 164) = 1;
  *(_QWORD *)(v10 + 168) = 0;
  *(_QWORD *)(v10 + 176) = 0;
  *(_BYTE *)(v10 + 184) = 0;
  *(_BYTE *)(v10 + 200) = 1;
  *(_QWORD *)(v10 + 212) = 0;
  *(_QWORD *)(v10 + 204) = 0;
  *(_BYTE *)(v10 + 220) = 0;
  *(_BYTE *)(v10 + 236) = 1;
  *(_QWORD *)(v10 + 240) = 0;
  *(_QWORD *)(v10 + 248) = 0;
  *(_BYTE *)(v10 + 256) = 0;
  *(_BYTE *)(v10 + 272) = 1;
  *(_QWORD *)(v10 + 284) = 0;
  *(_QWORD *)(v10 + 276) = 0;
  *(_BYTE *)(v10 + 292) = 0;
  *(_BYTE *)(v10 + 308) = 1;
  *(_QWORD *)(v10 + 320) = 0;
  *(_QWORD *)(v10 + 312) = 0;
  *(_BYTE *)(v10 + 328) = 0;
  *(_DWORD *)(v10 + 332) = 0;
  *(_BYTE *)(v10 + 336) = 0;
  *(_QWORD *)(v10 + 344) = 0;
  *(_WORD *)(v10 + 352) = 0;
  *(_BYTE *)(v10 + 360) = 0;
  *(_DWORD *)(v10 + 384) = 0;
  *(_BYTE *)(v10 + 388) = 0;
  *(_QWORD *)(v10 + 372) = 0;
  *(_QWORD *)(v10 + 364) = 0;
  *(_WORD *)(v10 + 380) = 0;
  *(_BYTE *)(v10 + 392) = 0;
  *(_BYTE *)(v10 + 416) = 0;
  *(_BYTE *)(v10 + 424) = 0;
  *(_BYTE *)(v10 + 784) = 0;
  *(_BYTE *)(v10 + 792) = 0;
  *(_BYTE *)(v10 + 796) = 0;
  *(_BYTE *)(v10 + 800) = 0;
  *(_BYTE *)(v10 + 808) = 0;
  *(_BYTE *)(v10 + 816) = 0;
  *(_BYTE *)(v10 + 828) = 0;
  *(_DWORD *)(v10 + 832) = 0;
  *(_QWORD *)(v10 + 840) = v12;
  *(_QWORD *)(v10 + 848) = v11;
  *(_QWORD *)(v10 + 856) = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v13 = (char *)operator new(0x19uLL);
  v45 = v13;
  v46 = xmmword_208F05110;
  if (v13 <= "resolution_threshold_px" && v13 + 23 > "resolution_threshold_px")
    goto LABEL_52;
  strcpy(v13, "resolution_threshold_px");
  v47 = 0;
  v41 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B4110;
  LOBYTE(v48) = 0;
  v49 = 0;
  v52 = &v41;
  (*(void (**)(__int128 *__return_ptr, uint64_t, const char *, uint64_t))(*(_QWORD *)v9 + 16))(&__p, v9, "WebRTC-Video-EncoderFallbackSettings", 36);
  if ((char)v51 < 0)
  {
    v14 = *((_QWORD *)&__p + 1);
    if ((*((_QWORD *)&__p + 1) & 0x8000000000000000) != 0)
      goto LABEL_52;
    p_p = (char *)__p;
    if (*((_QWORD *)&__p + 1))
    {
      if (!(_QWORD)__p)
        goto LABEL_52;
    }
  }
  else
  {
    v14 = v51;
    p_p = (char *)&__p;
  }
  webrtc::ParseFieldTrial(&v52, 1, p_p, v14);
  if (((char)v51 & 0x80000000) == 0)
  {
    if (v49)
      goto LABEL_10;
    goto LABEL_13;
  }
  operator delete((void *)__p);
  if (!v49)
  {
LABEL_13:
    (*(void (**)(void (****__return_ptr)(webrtc::FieldTrialParameterInterface *__hidden), uint64_t, const char *, uint64_t))(*(_QWORD *)v9 + 16))(&v52, v9, "WebRTC-VP8-Forced-Fallback-Encoder-v2", 37);
    if (((char)v54 & 0x80000000) == 0)
    {
      v22 = v54;
      v23 = &v52;
LABEL_18:
      if (v22 < 7
        || ((v24 = *(_DWORD *)v23, v25 = *(_DWORD *)((char *)v23 + 3), v24 == 1650552389)
          ? (v26 = v25 == 1684368482)
          : (v26 = 0),
            !v26))
      {
        v19 = 0;
        v16 = 0;
        v21 = 0;
        v17 = 0;
        v18 = 0;
        v20 = 0;
        if ((v54 & 0x80) == 0)
          goto LABEL_24;
LABEL_45:
        operator delete(v52);
        v41 = off_24C0B4170;
        if (SHIBYTE(v46) < 0)
          goto LABEL_46;
LABEL_25:
        v27 = v42;
        if (!v42)
          goto LABEL_27;
        goto LABEL_26;
      }
      (*(void (**)(__int128 *__return_ptr, uint64_t))(*(_QWORD *)v12 + 96))(&__p, v12);
      v31 = HIDWORD(__p);
      webrtc::VideoEncoder::EncoderInfo::~EncoderInfo((void **)&__p);
      LOWORD(__p) = 256;
      BYTE2(__p) = 0;
      *(_QWORD *)((char *)&__p + 4) = 0x12C000000E100;
      v40 = 0;
      if ((v54 & 0x80u) == 0)
        v32 = (const char *)&v52;
      else
        v32 = (const char *)v52;
      if (sscanf(v32, "Enabled-%d,%d,%d", (char *)&__p + 4, (char *)&__p + 8, &v40) == 3)
      {
        if (SDWORD1(__p) >= 1 && SDWORD2(__p) >= v31 - 1 && SDWORD2(__p) >= SDWORD1(__p) && v40 > 0)
        {
          BYTE2(__p) = 1;
          v16 = __p;
          v21 = __p & 0xFF00;
          v17 = __p & 0xFFFF0000;
          v18 = __p & 0xFF000000;
          v20 = __p & 0xFFFFFFFF00000000;
          v19 = DWORD2(__p) | 0x100000000;
          if ((v54 & 0x80) != 0)
            goto LABEL_45;
LABEL_24:
          v41 = off_24C0B4170;
          if (SHIBYTE(v46) < 0)
            goto LABEL_46;
          goto LABEL_25;
        }
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        {
LABEL_44:
          v19 = 0;
          v16 = 0;
          v21 = 0;
          v17 = 0;
          v18 = 0;
          v20 = 0;
          if ((v54 & 0x80) != 0)
            goto LABEL_45;
          goto LABEL_24;
        }
      }
      else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      {
        goto LABEL_44;
      }
      rtc::webrtc_logging_impl::Log("\r\t", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
      goto LABEL_44;
    }
    v22 = v53;
    if ((v53 & 0x8000000000000000) == 0)
    {
      v23 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v52;
      if (!v53 || v52)
        goto LABEL_18;
    }
LABEL_52:
    __break(1u);
  }
LABEL_10:
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = v48 | 0x100000000;
  v20 = 0xE10000000000;
  v21 = 256;
  v41 = off_24C0B4170;
  if ((SHIBYTE(v46) & 0x80000000) == 0)
    goto LABEL_25;
LABEL_46:
  operator delete(v45);
  v27 = v42;
  if (v42)
  {
LABEL_26:
    v43 = v27;
    operator delete(v27);
  }
LABEL_27:
  v28 = *(_QWORD *)&v17 & 0xFF0000 | v18 & 0xFF000000 | (unsigned __int16)v21 & 0xFF00;
  v29 = HIDWORD(v20);
  if (a4)
  {
    if ((v19 & 0x100000000) != 0)
    {
      v30 = 0x100000000;
    }
    else
    {
      v28 = 0;
      v30 = 0x100000000;
      v29 = 57600;
      LODWORD(v19) = 76800;
    }
    v16 = 1;
  }
  else
  {
    v30 = v19 & 0x100000000;
  }
  *(_QWORD *)(v10 + 864) = v28 | v16 | (v29 << 32);
  *(_QWORD *)(v10 + 872) = v30 & 0x100000000 | v19;
  *a5 = v10;
}

void webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::~VideoEncoderSoftwareFallbackWrapper(webrtc::_anonymous_namespace_::VideoEncoderSoftwareFallbackWrapper *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 106);
  *((_QWORD *)this + 106) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 105);
  *((_QWORD *)this + 105) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
}

{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 106);
  *((_QWORD *)this + 106) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 105);
  *((_QWORD *)this + 105) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::SetFecControllerOverride(uint64_t a1, uint64_t a2)
{
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 840) + 16))(*(_QWORD *)(a1 + 840));
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 848) + 16))(*(_QWORD *)(a1 + 848), a2);
}

uint64_t webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::InitEncode(uint64_t a1, webrtc::VideoCodec *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t inited;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  void *__p;
  char v75;
  char v76;
  _QWORD v77[3];
  _QWORD *v78;
  void *v79[7];
  uint64_t v80;
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    v79[0] = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/"
             "video_encoder_software_fallback_wrapper.cc";
    v79[1] = (void *)2529;
    v79[2] = &v76;
    v77[0] = "[VESFW] ";
    v77[1] = v79;
    v77[2] = "InitEncode";
    v78 = v77;
    webrtc::VideoCodec::ToString(a2, (char *)&__p);
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v6, v7, v8, v9, v10, v11, v12, *(_QWORD *)v78[1]);
    if (v75 < 0)
      operator delete(__p);
  }
  v13 = (int *)(a1 + 8);
  memcpy((void *)(a1 + 8), a2, 0x17DuLL);
  v18 = *(unsigned __int8 *)(a1 + 416);
  v19 = *(_QWORD *)(a3 + 16);
  *(_OWORD *)(a1 + 392) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 408) = v19;
  if (!v18)
    *(_BYTE *)(a1 + 416) = 1;
  if (*(_BYTE *)(a1 + 784))
    *(_BYTE *)(a1 + 784) = 0;
  if (!*(_BYTE *)(a1 + 876))
    goto LABEL_44;
  if (!*(_BYTE *)(a1 + 865)
    || *(unsigned __int16 *)(a1 + 14) * *(unsigned __int16 *)(a1 + 12) > *(_DWORD *)(a1 + 872)
    || *(_BYTE *)(a1 + 866) && (*(_DWORD *)(a1 + 8) != 1 || *(unsigned __int8 *)(a1 + 40) > 1u))
  {
    if (!*(_BYTE *)(a1 + 864))
      goto LABEL_44;
    if (*(unsigned __int16 *)(a1 + 380) >= 0x100u)
    {
      v30 = *(_WORD *)(a1 + 380);
      if (v30 >= 0x22)
      {
        rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/svc/scalability_mode_util.cc", 309, "index < kNumScalabilityModes", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long> const&)::t, v14, v15, v16, v17, v30);
        goto LABEL_86;
      }
                                                                            + 28];
    }
    else
    {
      v20 = *v13;
      if (*v13 == 4)
      {
        v21 = *(unsigned __int8 *)(a1 + 368);
      }
      else if (v20 == 2 || v20 == 1)
      {
        v21 = *(unsigned __int8 *)(a1 + 364);
      }
      else
      {
        v21 = 0;
      }
    }
    if (*(_BYTE *)(a1 + 40) && v21 <= *(unsigned __int8 *)(a1 + 56))
      v21 = *(unsigned __int8 *)(a1 + 56);
    if (v21 < 2)
      goto LABEL_44;
    if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 840) + 32))(*(_QWORD *)(a1 + 840), a1 + 8, a1 + 392))
    {
      if (*(_DWORD *)(a1 + 832) != 1)
        goto LABEL_37;
    }
    else
    {
      *(_DWORD *)(a1 + 832) = 1;
    }
    (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 840) + 96))(v79);
    v31 = v80 & 0xFFFFFFFFFFFFFFFELL;
    webrtc::VideoEncoder::EncoderInfo::~EncoderInfo(v79);
    if (v31 != 2)
      goto LABEL_76;
LABEL_37:
    if (*(_BYTE *)(a1 + 416))
    {
      if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 848) + 32))(*(_QWORD *)(a1 + 848), a1 + 8, a1 + 392))
      {
        if (*(_DWORD *)(a1 + 832) != 1)
          goto LABEL_44;
      }
      else
      {
        (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 848) + 96))(v79);
        v39 = v80 & 0xFFFFFFFFFFFFFFFELL;
        webrtc::VideoEncoder::EncoderInfo::~EncoderInfo(v79);
        if (v39 != 2)
        {
          if (*(_DWORD *)(a1 + 832) == 1)
            (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 840) + 48))(*(_QWORD *)(a1 + 840));
          *(_DWORD *)(a1 + 832) = 3;
          inited = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>();
          if ((inited & 1) != 0)
            goto LABEL_76;
          goto LABEL_75;
        }
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 848) + 48))(*(_QWORD *)(a1 + 848));
        if (*(_DWORD *)(a1 + 832) != 1)
          goto LABEL_44;
      }
      inited = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>();
      if ((inited & 1) == 0)
LABEL_75:
        rtc::webrtc_logging_impl::Log("\r\t", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
LABEL_76:
      v66 = *(_DWORD *)(a1 + 832);
      if ((v66 - 2) >= 2)
      {
        if (v66 == 1)
          goto LABEL_81;
        if (!v66)
        {
          if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
            rtc::webrtc_logging_impl::Log("\r\t", v67, v68, v69, v70, v71, v72, v73, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
LABEL_81:
          v49 = *(_QWORD *)(a1 + 840);
          if (!*(_QWORD *)(a1 + 856))
            goto LABEL_49;
          goto LABEL_48;
        }
LABEL_87:
        rtc::webrtc_checks_impl::UnreachableCodeReached((rtc::webrtc_checks_impl *)inited);
      }
      v49 = *(_QWORD *)(a1 + 848);
      if (!*(_QWORD *)(a1 + 856))
        goto LABEL_49;
LABEL_48:
      (*(void (**)(uint64_t))(*(_QWORD *)v49 + 40))(v49);
      goto LABEL_49;
    }
LABEL_86:
    std::__throw_bad_optional_access[abi:sn180100]();
    goto LABEL_87;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v22, v23, v24, v25, v26, v27, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
  if ((_DWORD)inited)
    goto LABEL_76;
LABEL_44:
  v40 = (*(uint64_t (**)(_QWORD, webrtc::VideoCodec *, uint64_t))(**(_QWORD **)(a1 + 840) + 32))(*(_QWORD *)(a1 + 840), a2, a3);
  if (!(_DWORD)v40)
  {
    *(_DWORD *)(a1 + 832) = 1;
    v49 = *(_QWORD *)(a1 + 840);
    if (!*(_QWORD *)(a1 + 856))
    {
LABEL_49:
      if (*(_BYTE *)(a1 + 784))
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v49 + 64))(v49, a1 + 424);
      if (*(_BYTE *)(a1 + 808))
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v49 + 80))(v49, *(_QWORD *)(a1 + 800));
      if (*(_BYTE *)(a1 + 796))
        (*(void (**)(uint64_t, float))(*(_QWORD *)v49 + 72))(v49, *(float *)(a1 + 792));
      if (*(_BYTE *)(a1 + 828))
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v49 + 88))(v49, a1 + 816);
      return 0;
    }
    goto LABEL_48;
  }
  v41 = v40;
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t\t\t", v42, v43, v44, v45, v46, v47, v48, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
  if ((_DWORD)inited)
  {
    v51 = *(_DWORD *)(a1 + 832);
    if ((v51 - 2) < 2)
    {
      v49 = *(_QWORD *)(a1 + 848);
      if (!*(_QWORD *)(a1 + 856))
        goto LABEL_49;
      goto LABEL_48;
    }
    if (v51 != 1)
    {
      if (v51)
        goto LABEL_87;
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v52, v53, v54, v55, v56, v57, v58, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
    }
    v49 = *(_QWORD *)(a1 + 840);
    if (!*(_QWORD *)(a1 + 856))
      goto LABEL_49;
    goto LABEL_48;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t", v59, v60, v61, v62, v63, v64, v65, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
  *(_DWORD *)(a1 + 832) = 0;
  return v41;
}

uint64_t webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::RegisterEncodeCompleteCallback(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;

  *(_QWORD *)(a1 + 856) = a2;
  v4 = *(_DWORD *)(a1 + 832);
  if ((v4 - 2) < 2)
  {
    v12 = (_QWORD *)(a1 + 848);
  }
  else
  {
    if (v4 != 1)
    {
      if (v4)
        rtc::webrtc_checks_impl::UnreachableCodeReached((rtc::webrtc_checks_impl *)a1);
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
    }
    v12 = (_QWORD *)(a1 + 840);
  }
  return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v12 + 40))(*v12, a2);
}

uint64_t webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::Release(webrtc::_anonymous_namespace_::VideoEncoderSoftwareFallbackWrapper *this)
{
  uint64_t result;
  char *v3;

  result = *((unsigned int *)this + 208);
  if ((result - 2) < 2)
  {
    v3 = (char *)this + 848;
  }
  else
  {
    if (!(_DWORD)result)
      return result;
    if ((_DWORD)result != 1)
      rtc::webrtc_checks_impl::UnreachableCodeReached((rtc::webrtc_checks_impl *)result);
    v3 = (char *)this + 840;
  }
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v3 + 48))(*(_QWORD *)v3);
  *((_DWORD *)this + 208) = 0;
  return result;
}

uint64_t webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::Encode(char *inited, const webrtc::VideoFrame *a2, uint64_t a3)
{
  char *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  unsigned __int8 v60;
  uint64_t v61;
  int v62;
  int v63;
  char v64;
  uint64_t v65;

  v5 = inited;
  v65 = *MEMORY[0x24BDAC8D0];
  v6 = *((_DWORD *)inited + 208);
  if ((v6 - 2) < 2)
    return (*(uint64_t (**)(_QWORD, const webrtc::VideoFrame *, uint64_t))(**((_QWORD **)inited + 106) + 56))(*((_QWORD *)inited + 106), a2, a3);
  if (!v6)
    return 0xFFFFFFFFLL;
  if (v6 != 1)
    goto LABEL_55;
  v7 = (*(uint64_t (**)(_QWORD, const webrtc::VideoFrame *, uint64_t))(**((_QWORD **)inited + 105) + 56))(*((_QWORD *)inited + 105), a2, a3);
  if ((_DWORD)v7 != -13)
    return v7;
  if (!(_DWORD)inited)
    return 4294967283;
  v8 = *((_DWORD *)v5 + 208);
  if ((v8 - 2) < 2)
  {
    v9 = (uint64_t *)(v5 + 848);
  }
  else
  {
    v9 = (uint64_t *)(v5 + 840);
    if (v8 != 1)
    {
      if (!v8)
      {
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
          rtc::webrtc_logging_impl::Log("\r\t", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
        goto LABEL_15;
      }
LABEL_55:
      rtc::webrtc_checks_impl::UnreachableCodeReached((rtc::webrtc_checks_impl *)inited);
    }
  }
LABEL_15:
  v18 = *v9;
  if (*((_QWORD *)v5 + 107))
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 40))(v18);
  if (v5[784])
    (*(void (**)(uint64_t, char *))(*(_QWORD *)v18 + 64))(v18, v5 + 424);
  if (v5[808])
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 80))(v18, *((_QWORD *)v5 + 100));
  if (v5[796])
    (*(void (**)(uint64_t, float))(*(_QWORD *)v18 + 72))(v18, *((float *)v5 + 198));
  if (v5[828])
    (*(void (**)(uint64_t, char *))(*(_QWORD *)v18 + 88))(v18, v5 + 816);
  v19 = *((_QWORD *)a2 + 1);
  if (v19)
    (**(void (***)(_QWORD))v19)(*((_QWORD *)a2 + 1));
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v19 + 32))(v19))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
LABEL_29:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v20, v21, v22, v23, v24, v25, v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
    v27 = *((_QWORD *)a2 + 1);
    if (v27)
      (**(void (***)(_QWORD))v27)(*((_QWORD *)a2 + 1));
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v27 + 56))(&v57, v27);
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
    v28 = v57;
    if (v57)
    {
      v29 = *((unsigned __int16 *)v5 + 6);
      v30 = *((unsigned __int16 *)v5 + 7);
      v31 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v57 + 40))(v57);
      v32 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 48))(v28);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v28 + 72))(&v56, v28, 0, 0, v31, v32, v29, v30);
      if (v56)
      {
        webrtc::VideoFrame::VideoFrame((webrtc::VideoFrame *)&v58, a2);
        webrtc::VideoFrame::set_video_frame_buffer((uint64_t)&v58, &v56, v33, v34, v35, v36, v37, v38);
        v39 = v59;
        if (v59)
        {
          v40 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v59 + 40))(v59);
          v39 = v59;
          if (v59)
            v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v59 + 48))(v59);
        }
        else
        {
          v40 = 0;
        }
        v61 = 0;
        v62 = v40;
        v63 = v39;
        if (!v64)
          v64 = 1;
        v7 = (*(uint64_t (**)(_QWORD, void **, uint64_t))(**((_QWORD **)v5 + 106) + 56))(*((_QWORD *)v5 + 106), &v58, a3);
        webrtc::VideoFrame::~VideoFrame((webrtc::VideoFrame *)&v58);
      }
      else
      {
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
          rtc::webrtc_logging_impl::Log("\r\t", v49, v50, v51, v52, v53, v54, v55, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
        v7 = 4294967280;
      }
      if (v56)
        (*(void (**)(uint64_t))(*(_QWORD *)v56 + 8))(v56);
    }
    else
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v42, v43, v44, v45, v46, v47, v48, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
      v7 = 4294967280;
    }
    if (v57)
      (*(void (**)(uint64_t))(*(_QWORD *)v57 + 8))(v57);
    return v7;
  }
  (*(void (**)(void **__return_ptr))(**((_QWORD **)v5 + 106) + 96))(&v58);
  v41 = v60;
  webrtc::VideoEncoder::EncoderInfo::~EncoderInfo(&v58);
  (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  if (!v41)
    goto LABEL_29;
  return (*(uint64_t (**)(_QWORD, const webrtc::VideoFrame *, uint64_t))(**((_QWORD **)v5 + 106) + 56))(*((_QWORD *)v5 + 106), a2, a3);
}

uint64_t webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::SetRates(webrtc::_anonymous_namespace_::VideoEncoderSoftwareFallbackWrapper *this, const webrtc::VideoEncoder::RateControlParameters *a2)
{
  rtc::webrtc_checks_impl *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;

  if (!*((_BYTE *)this + 784))
  {
    *((_QWORD *)this + 53) = &off_24C0C3368;
    v4 = (rtc::webrtc_checks_impl *)memcpy((char *)this + 432, (char *)a2 + 8, 0x160uLL);
    *((_BYTE *)this + 784) = 1;
    v5 = *((_DWORD *)this + 208);
    if ((v5 - 2) >= 2)
      goto LABEL_3;
LABEL_9:
    v13 = (char *)this + 848;
    return (*(uint64_t (**)(_QWORD, const webrtc::VideoEncoder::RateControlParameters *))(**(_QWORD **)v13
                                                                                                  + 64))(*(_QWORD *)v13, a2);
  }
  v4 = (rtc::webrtc_checks_impl *)memcpy((char *)this + 432, (char *)a2 + 8, 0x160uLL);
  v5 = *((_DWORD *)this + 208);
  if ((v5 - 2) < 2)
    goto LABEL_9;
LABEL_3:
  if (v5 != 1)
  {
    if (v5)
      rtc::webrtc_checks_impl::UnreachableCodeReached(v4);
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
  }
  v13 = (char *)this + 840;
  return (*(uint64_t (**)(_QWORD, const webrtc::VideoEncoder::RateControlParameters *))(**(_QWORD **)v13 + 64))(*(_QWORD *)v13, a2);
}

uint64_t webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::OnPacketLossRateUpdate(webrtc::_anonymous_namespace_::VideoEncoderSoftwareFallbackWrapper *this, float a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;

  *((float *)this + 198) = a2;
  *((_BYTE *)this + 796) = 1;
  v4 = *((_DWORD *)this + 208);
  if ((v4 - 2) < 2)
  {
    v12 = (char *)this + 848;
  }
  else
  {
    if (v4 != 1)
    {
      if (v4)
        rtc::webrtc_checks_impl::UnreachableCodeReached(this);
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
    }
    v12 = (char *)this + 840;
  }
  return (*(uint64_t (**)(_QWORD, float))(**(_QWORD **)v12 + 72))(*(_QWORD *)v12, a2);
}

uint64_t webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::OnRttUpdate(webrtc::_anonymous_namespace_::VideoEncoderSoftwareFallbackWrapper *this, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;

  *((_QWORD *)this + 100) = a2;
  *((_BYTE *)this + 808) = 1;
  v4 = *((_DWORD *)this + 208);
  if ((v4 - 2) < 2)
  {
    v12 = (char *)this + 848;
  }
  else
  {
    if (v4 != 1)
    {
      if (v4)
        rtc::webrtc_checks_impl::UnreachableCodeReached(this);
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
    }
    v12 = (char *)this + 840;
  }
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)v12 + 80))(*(_QWORD *)v12, a2);
}

uint64_t webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::OnLossNotification(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v4 = *(unsigned __int8 *)(a1 + 828);
  v5 = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 816) = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 824) = v5;
  if (!v4)
  {
    *(_BYTE *)(a1 + 828) = 1;
    v6 = *(_DWORD *)(a1 + 832);
    if ((v6 - 2) >= 2)
      goto LABEL_3;
LABEL_9:
    v14 = (_QWORD *)(a1 + 848);
    return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v14 + 88))(*v14, a2);
  }
  v6 = *(_DWORD *)(a1 + 832);
  if ((v6 - 2) < 2)
    goto LABEL_9;
LABEL_3:
  if (v6 != 1)
  {
    if (v6)
      rtc::webrtc_checks_impl::UnreachableCodeReached((rtc::webrtc_checks_impl *)a1);
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v7, v8, v9, v10, v11, v12, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
  }
  v14 = (_QWORD *)(a1 + 840);
  return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v14 + 88))(*v14, a2);
}

void webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::GetEncoderInfo(webrtc::_anonymous_namespace_::VideoEncoderSoftwareFallbackWrapper *this@<X0>, uint64_t a2@<X8>)
{
  void **v4;
  int v5;
  int v6;
  int v7;
  void *v8[2];
  int v9;
  unsigned __int8 v10;
  void *v11[2];
  int v12;
  unsigned __int8 v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 106) + 96))(v11);
  (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 105) + 96))(v8);
  if ((*((_DWORD *)this + 208) & 0xFFFFFFFE) == 2)
    v4 = v11;
  else
    v4 = v8;
  webrtc::VideoEncoder::EncoderInfo::EncoderInfo((webrtc::VideoEncoder::EncoderInfo *)a2, (const webrtc::VideoEncoder::EncoderInfo *)v4);
  v5 = v12 % v9;
  if (v12 % v9)
  {
    v6 = v9;
    do
    {
      v7 = v5;
      v5 = v6 % v5;
      v6 = v7;
    }
    while (v5);
  }
  else
  {
    v7 = v9;
  }
  *(_DWORD *)(a2 + 16) = v9 / v7 * v12;
  *(_BYTE *)(a2 + 20) = (v13 | v10) != 0;
  if (*((_BYTE *)this + 876) && *((_BYTE *)this + 866))
    *(_DWORD *)(a2 + 12) = *((_DWORD *)this + 217);
  webrtc::VideoEncoder::EncoderInfo::~EncoderInfo(v8);
  webrtc::VideoEncoder::EncoderInfo::~EncoderInfo(v11);
}

const char *webrtc::`anonymous namespace'::VideoEncoderSoftwareFallbackWrapper::InitFallbackEncoder(webrtc::_anonymous_namespace_::VideoEncoderSoftwareFallbackWrapper *this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  webrtc *v21;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t\t\t\t\t", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
  if (*((_BYTE *)this + 416))
  {
    v11 = (*(uint64_t (**)(_QWORD, char *, char *))(**((_QWORD **)this + 106) + 32))(*((_QWORD *)this + 106), (char *)this + 8, (char *)this + 392);
    if (v11)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t\t\t", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video_codecs/video_encoder_software_fallback_wrapper.cc");
      (*(void (**)(_QWORD))(**((_QWORD **)this + 106) + 48))(*((_QWORD *)this + 106));
    }
    else
    {
      if (*((_DWORD *)this + 208) == 1)
        (*(void (**)(_QWORD))(**((_QWORD **)this + 105) + 48))(*((_QWORD *)this + 105));
      if (a2)
        v19 = 3;
      else
        v19 = 2;
      *((_DWORD *)this + 208) = v19;
    }
    return (const char *)(v11 == 0);
  }
  else
  {
    std::__throw_bad_optional_access[abi:sn180100]();
    return webrtc::WebRtcVideoCodecErrorToString(v21);
  }
}

const char *webrtc::WebRtcVideoCodecErrorToString(webrtc *this)
{
  if (((_DWORD)this + 16) > 0x15)
    return "WEBRTC_VIDEO_CODEC_UNKNOWN";
  else
    return off_24C0C3510[(int)this + 16];
}

int *webrtc::VideoFrame::UpdateRect::Intersect(int *result, int *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;

  if (!*((_QWORD *)a2 + 1) || !*((_QWORD *)result + 1))
    goto LABEL_17;
  v2 = result[1];
  v3 = *a2 + a2[2];
  if (v3 >= *result + result[2])
    v3 = *result + result[2];
  v4 = a2[1] + a2[3];
  if (v4 >= v2 + result[3])
    v4 = v2 + result[3];
  if (*result <= *a2)
    v5 = *a2;
  else
    v5 = *result;
  *result = v5;
  v6 = a2[1];
  if (v2 > v6)
    v6 = v2;
  v7 = v3 - v5;
  result[1] = v6;
  result[2] = v7;
  v8 = v4 - v6;
  result[3] = v8;
  if (v7 < 1 || v8 <= 0)
  {
LABEL_17:
    *(_QWORD *)result = 0;
    *((_QWORD *)result + 1) = 0;
  }
  return result;
}

uint64_t webrtc::VideoFrame::Builder::Builder(uint64_t this)
{
  *(_WORD *)this = 0;
  *(_BYTE *)(this + 32) = 0;
  *(_BYTE *)(this + 40) = 0;
  *(_BYTE *)(this + 48) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_QWORD *)(this + 64) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_BYTE *)(this + 76) = 0;
  *(_BYTE *)(this + 144) = 0;
  *(_BYTE *)(this + 148) = 0;
  *(_BYTE *)(this + 152) = 0;
  *(_BYTE *)(this + 156) = 0;
  *(_BYTE *)(this + 160) = 0;
  *(_BYTE *)(this + 176) = 0;
  *(_QWORD *)(this + 184) = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_BYTE *)(this + 24) = 0;
  return this;
}

void webrtc::VideoFrame::Builder::~Builder(webrtc::VideoFrame::Builder *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;

  v2 = *((_QWORD *)this + 23);
  if (v2)
  {
    do
    {
      v3 = __ldaxr((unsigned int *)v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, (unsigned int *)v2));
    if (!v4)
    {
      v5 = *(_QWORD *)(v2 + 8);
      if (v5)
      {
        v6 = *(_QWORD *)(v2 + 16);
        v7 = *(void **)(v2 + 8);
        if (v6 != v5)
        {
          do
          {
            v8 = *(void **)(v6 - 96);
            if (v8)
            {
              *(_QWORD *)(v6 - 88) = v8;
              operator delete(v8);
            }
            v6 -= 104;
          }
          while (v6 != v5);
          v7 = *(void **)(v2 + 8);
        }
        *(_QWORD *)(v2 + 16) = v5;
        operator delete(v7);
      }
      MEMORY[0x20BD0ADEC](v2, 0x1020C40E72D6CFBLL);
    }
  }
  v9 = *((_QWORD *)this + 1);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
}

uint64_t (***webrtc::VideoFrame::Builder::build@<X0>(webrtc::VideoFrame::Builder *this@<X0>, uint64_t a2@<X4>, uint64_t a3@<X5>, uint64_t a4@<X6>, uint64_t a5@<X7>, uint64_t a6@<X8>))(_QWORD)
{
  uint64_t (***result)(_QWORD);
  __int16 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  unsigned int *v14;
  unsigned int v15;
  __int128 v16;
  __int128 v17;
  std::string *v18;
  _QWORD *v19;
  uint64_t v20;

  result = (uint64_t (***)(_QWORD))*((_QWORD *)this + 1);
  if (!result)
  {
    v18 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame.cc", 165, "video_frame_buffer_ != nullptr", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a2, a3, a4, a5, v20);
    return (uint64_t (***)(_QWORD))webrtc::VideoFrame::Builder::set_video_frame_buffer((uint64_t)v18, v19);
  }
  v9 = *(_WORD *)this;
  v10 = *((_QWORD *)this + 2);
  v11 = *((_DWORD *)this + 14);
  v12 = *((_QWORD *)this + 8);
  v13 = *((_DWORD *)this + 18);
  v14 = (unsigned int *)*((_QWORD *)this + 23);
  if (v14)
  {
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    result = (uint64_t (***)(_QWORD))*((_QWORD *)this + 1);
    *(_WORD *)a6 = v9;
    *(_QWORD *)(a6 + 8) = result;
    if (!result)
      goto LABEL_8;
  }
  else
  {
    *(_WORD *)a6 = v9;
    *(_QWORD *)(a6 + 8) = result;
  }
  result = (uint64_t (***)(_QWORD))(**result)(result);
LABEL_8:
  *(_BYTE *)(a6 + 76) = 0;
  *(_DWORD *)(a6 + 16) = v11;
  *(_QWORD *)(a6 + 24) = v12;
  *(_QWORD *)(a6 + 32) = v10;
  *(_OWORD *)(a6 + 40) = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)(a6 + 56) = *(_OWORD *)((char *)this + 40);
  *(_DWORD *)(a6 + 72) = v13;
  *(_BYTE *)(a6 + 144) = 0;
  if (*((_BYTE *)this + 144))
  {
    v16 = *(_OWORD *)((char *)this + 124);
    *(_OWORD *)(a6 + 108) = *(_OWORD *)((char *)this + 108);
    *(_OWORD *)(a6 + 124) = v16;
    *(_BYTE *)(a6 + 140) = *((_BYTE *)this + 140);
    v17 = *(_OWORD *)((char *)this + 92);
    *(_OWORD *)(a6 + 76) = *(_OWORD *)((char *)this + 76);
    *(_OWORD *)(a6 + 92) = v17;
    *(_BYTE *)(a6 + 144) = 1;
  }
  *(_QWORD *)(a6 + 148) = *(_QWORD *)((char *)this + 148);
  *(_DWORD *)(a6 + 156) = *((_DWORD *)this + 39);
  *(_OWORD *)(a6 + 160) = *((_OWORD *)this + 10);
  *(_DWORD *)(a6 + 176) = *((_DWORD *)this + 44);
  *(_QWORD *)(a6 + 184) = v14;
  *(_BYTE *)(a6 + 192) = 0;
  *(_BYTE *)(a6 + 208) = 0;
  return result;
}

uint64_t webrtc::VideoFrame::Builder::set_video_frame_buffer(uint64_t a1, _QWORD *a2)
{
  void (***v3)(_QWORD);
  uint64_t v4;

  v3 = (void (***)(_QWORD))*a2;
  if (*a2)
    (**v3)(*a2);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  *(_QWORD *)(a1 + 8) = v3;
  return a1;
}

uint64_t webrtc::VideoFrame::Builder::set_timestamp_rtp(uint64_t this, int a2)
{
  *(_DWORD *)(this + 56) = a2;
  return this;
}

uint64_t webrtc::VideoFrame::Builder::set_ntp_time_ms(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 64) = a2;
  return this;
}

__n128 webrtc::VideoFrame::Builder::set_color_space(webrtc::VideoFrame::Builder *this, const webrtc::ColorSpace *a2)
{
  char v2;
  __n128 result;
  int v4;
  __int128 v5;
  __int128 v6;
  __n128 v7;
  __int128 v8;

  if (a2)
  {
    v2 = *(_BYTE *)a2;
    v5 = *(_OWORD *)((char *)a2 + 1);
    v6 = *(_OWORD *)((char *)a2 + 17);
    result = *(__n128 *)((char *)a2 + 33);
    v7 = result;
    v8 = *(_OWORD *)((char *)a2 + 49);
    v4 = *((unsigned __int8 *)this + 144);
    if (v4 == 1)
      goto LABEL_3;
  }
  else
  {
    v2 = 0;
    v4 = *((unsigned __int8 *)this + 144);
    if (!*((_BYTE *)this + 144))
    {
LABEL_3:
      if (v4)
      {
        *((_BYTE *)this + 76) = v2;
        *(_OWORD *)((char *)this + 77) = v5;
        *(_OWORD *)((char *)this + 93) = v6;
        result = v7;
        *(__n128 *)((char *)this + 109) = v7;
        *(_OWORD *)((char *)this + 125) = v8;
      }
      return result;
    }
  }
  if (v4)
  {
    *((_BYTE *)this + 144) = 0;
  }
  else
  {
    *((_BYTE *)this + 76) = v2;
    *(_OWORD *)((char *)this + 77) = v5;
    *(_OWORD *)((char *)this + 93) = v6;
    result = v7;
    *(__n128 *)((char *)this + 109) = v7;
    *(_OWORD *)((char *)this + 125) = v8;
    *((_BYTE *)this + 144) = 1;
  }
  return result;
}

uint64_t webrtc::VideoFrame::VideoFrame(uint64_t a1, void (****a2)(_QWORD), int a3, uint64_t a4)
{
  void (***v7)(_QWORD);

  v7 = *a2;
  *(_QWORD *)(a1 + 8) = *a2;
  if (v7)
    (**v7)(v7);
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = a4;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = a3;
  *(_BYTE *)(a1 + 76) = 0;
  *(_BYTE *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 148) = 0;
  *(_BYTE *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 156) = 0;
  *(_BYTE *)(a1 + 160) = 0;
  *(_BYTE *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_BYTE *)(a1 + 192) = 0;
  *(_BYTE *)(a1 + 208) = 0;
  return a1;
}

void webrtc::VideoFrame::~VideoFrame(webrtc::VideoFrame *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;

  v2 = *((_QWORD *)this + 23);
  if (v2)
  {
    do
    {
      v3 = __ldaxr((unsigned int *)v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, (unsigned int *)v2));
    if (!v4)
    {
      v5 = *(_QWORD *)(v2 + 8);
      if (v5)
      {
        v6 = *(_QWORD *)(v2 + 16);
        v7 = *(void **)(v2 + 8);
        if (v6 != v5)
        {
          do
          {
            v8 = *(void **)(v6 - 96);
            if (v8)
            {
              *(_QWORD *)(v6 - 88) = v8;
              operator delete(v8);
            }
            v6 -= 104;
          }
          while (v6 != v5);
          v7 = *(void **)(v2 + 8);
        }
        *(_QWORD *)(v2 + 16) = v5;
        operator delete(v7);
      }
      MEMORY[0x20BD0ADEC](v2, 0x1020C40E72D6CFBLL);
    }
  }
  v9 = *((_QWORD *)this + 1);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
}

webrtc::VideoFrame *webrtc::VideoFrame::VideoFrame(webrtc::VideoFrame *this, const webrtc::VideoFrame *a2)
{
  void (***v4)(_QWORD);
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  unsigned int *v13;
  unsigned int v14;
  __int128 v15;

  *(_WORD *)this = *(_WORD *)a2;
  v4 = (void (***)(_QWORD))*((_QWORD *)a2 + 1);
  *((_QWORD *)this + 1) = v4;
  if (v4)
    (**v4)(v4);
  v5 = *((_OWORD *)a2 + 1);
  v6 = *((_OWORD *)a2 + 2);
  v7 = *((_OWORD *)a2 + 3);
  v8 = *(_OWORD *)((char *)a2 + 60);
  *((_BYTE *)this + 76) = 0;
  *(_OWORD *)((char *)this + 60) = v8;
  *((_OWORD *)this + 3) = v7;
  *((_OWORD *)this + 2) = v6;
  *((_OWORD *)this + 1) = v5;
  *((_BYTE *)this + 144) = 0;
  if (*((_BYTE *)a2 + 144))
  {
    *(_OWORD *)((char *)this + 76) = *(_OWORD *)((char *)a2 + 76);
    v9 = *(_OWORD *)((char *)a2 + 92);
    v10 = *(_OWORD *)((char *)a2 + 108);
    v11 = *(_OWORD *)((char *)a2 + 124);
    *((_BYTE *)this + 140) = *((_BYTE *)a2 + 140);
    *(_OWORD *)((char *)this + 108) = v10;
    *(_OWORD *)((char *)this + 124) = v11;
    *(_OWORD *)((char *)this + 92) = v9;
    *((_BYTE *)this + 144) = 1;
  }
  v12 = *(_OWORD *)((char *)a2 + 148);
  *(_OWORD *)((char *)this + 161) = *(_OWORD *)((char *)a2 + 161);
  *(_OWORD *)((char *)this + 148) = v12;
  v13 = (unsigned int *)*((_QWORD *)a2 + 23);
  *((_QWORD *)this + 23) = v13;
  if (v13)
  {
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  v15 = *((_OWORD *)a2 + 12);
  *((_QWORD *)this + 26) = *((_QWORD *)a2 + 26);
  *((_OWORD *)this + 12) = v15;
  return this;
}

uint64_t webrtc::VideoFrame::operator=(uint64_t a1, uint64_t a2)
{
  void (***v4)(_QWORD);
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  _OWORD *v9;
  _OWORD *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  unsigned int *v15;
  __int128 v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  void *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;

  *(_WORD *)a1 = *(_WORD *)a2;
  v4 = *(void (****)(_QWORD))(a2 + 8);
  if (v4)
    (**v4)(*(_QWORD *)(a2 + 8));
  v5 = *(_QWORD *)(a1 + 8);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  *(_QWORD *)(a1 + 8) = v4;
  v6 = *(_OWORD *)(a2 + 16);
  v7 = *(_OWORD *)(a2 + 32);
  v8 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 60) = *(_OWORD *)(a2 + 60);
  *(_OWORD *)(a1 + 32) = v7;
  *(_OWORD *)(a1 + 48) = v8;
  *(_OWORD *)(a1 + 16) = v6;
  v9 = (_OWORD *)(a1 + 76);
  v10 = (_OWORD *)(a2 + 76);
  if (*(unsigned __int8 *)(a1 + 144) == *(unsigned __int8 *)(a2 + 144))
  {
    if (*(_BYTE *)(a1 + 144))
    {
      *v9 = *v10;
      v11 = *(_OWORD *)(a2 + 92);
      v12 = *(_OWORD *)(a2 + 108);
      v13 = *(_OWORD *)(a2 + 124);
      *(_BYTE *)(a1 + 140) = *(_BYTE *)(a2 + 140);
      *(_OWORD *)(a1 + 108) = v12;
      *(_OWORD *)(a1 + 124) = v13;
      *(_OWORD *)(a1 + 92) = v11;
      v14 = *(_OWORD *)(a2 + 148);
      *(_OWORD *)(a1 + 161) = *(_OWORD *)(a2 + 161);
      *(_OWORD *)(a1 + 148) = v14;
      v15 = *(unsigned int **)(a2 + 184);
      if (!v15)
        goto LABEL_13;
      do
LABEL_12:
        v17 = __ldxr(v15);
      while (__stxr(v17 + 1, v15));
      goto LABEL_13;
    }
  }
  else
  {
    if (!*(_BYTE *)(a1 + 144))
    {
      *v9 = *v10;
      v25 = *(_OWORD *)(a2 + 92);
      v26 = *(_OWORD *)(a2 + 108);
      v27 = *(_OWORD *)(a2 + 124);
      *(_BYTE *)(a1 + 140) = *(_BYTE *)(a2 + 140);
      *(_OWORD *)(a1 + 108) = v26;
      *(_OWORD *)(a1 + 124) = v27;
      *(_OWORD *)(a1 + 92) = v25;
      *(_BYTE *)(a1 + 144) = 1;
      v28 = *(_OWORD *)(a2 + 148);
      *(_OWORD *)(a1 + 161) = *(_OWORD *)(a2 + 161);
      *(_OWORD *)(a1 + 148) = v28;
      v15 = *(unsigned int **)(a2 + 184);
      if (!v15)
        goto LABEL_13;
      goto LABEL_12;
    }
    *(_BYTE *)(a1 + 144) = 0;
  }
  v16 = *(_OWORD *)(a2 + 148);
  *(_OWORD *)(a1 + 161) = *(_OWORD *)(a2 + 161);
  *(_OWORD *)(a1 + 148) = v16;
  v15 = *(unsigned int **)(a2 + 184);
  if (v15)
    goto LABEL_12;
LABEL_13:
  v18 = *(_QWORD *)(a1 + 184);
  if (v18)
  {
    do
    {
      v19 = __ldaxr((unsigned int *)v18);
      v20 = v19 - 1;
    }
    while (__stlxr(v20, (unsigned int *)v18));
    if (!v20)
    {
      v21 = *(_QWORD *)(v18 + 8);
      if (v21)
      {
        v22 = *(_QWORD *)(v18 + 16);
        v23 = *(void **)(v18 + 8);
        if (v22 != v21)
        {
          do
          {
            v24 = *(void **)(v22 - 96);
            if (v24)
            {
              *(_QWORD *)(v22 - 88) = v24;
              operator delete(v24);
            }
            v22 -= 104;
          }
          while (v22 != v21);
          v23 = *(void **)(v18 + 8);
        }
        *(_QWORD *)(v18 + 16) = v21;
        operator delete(v23);
      }
      MEMORY[0x20BD0ADEC](v18, 0x1020C40E72D6CFBLL);
    }
  }
  *(_QWORD *)(a1 + 184) = v15;
  v29 = *(_OWORD *)(a2 + 192);
  *(_BYTE *)(a1 + 208) = *(_BYTE *)(a2 + 208);
  *(_OWORD *)(a1 + 192) = v29;
  return a1;
}

{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  _OWORD *v9;
  _OWORD *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  void *v25;
  __int128 v26;

  *(_WORD *)a1 = *(_WORD *)a2;
  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v5 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v4;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *(_OWORD *)(a2 + 16);
  v7 = *(_OWORD *)(a2 + 32);
  v8 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 60) = *(_OWORD *)(a2 + 60);
  *(_OWORD *)(a1 + 32) = v7;
  *(_OWORD *)(a1 + 48) = v8;
  *(_OWORD *)(a1 + 16) = v6;
  v9 = (_OWORD *)(a1 + 76);
  v10 = (_OWORD *)(a2 + 76);
  if (*(unsigned __int8 *)(a1 + 144) == *(unsigned __int8 *)(a2 + 144))
  {
    if (*(_BYTE *)(a1 + 144))
    {
      *v9 = *v10;
      v11 = *(_OWORD *)(a2 + 92);
      v12 = *(_OWORD *)(a2 + 108);
      v13 = *(_OWORD *)(a2 + 124);
      *(_BYTE *)(a1 + 140) = *(_BYTE *)(a2 + 140);
      *(_OWORD *)(a1 + 108) = v12;
      *(_OWORD *)(a1 + 124) = v13;
      *(_OWORD *)(a1 + 92) = v11;
    }
  }
  else if (*(_BYTE *)(a1 + 144))
  {
    *(_BYTE *)(a1 + 144) = 0;
  }
  else
  {
    *v9 = *v10;
    v14 = *(_OWORD *)(a2 + 92);
    v15 = *(_OWORD *)(a2 + 108);
    v16 = *(_OWORD *)(a2 + 124);
    *(_BYTE *)(a1 + 140) = *(_BYTE *)(a2 + 140);
    *(_OWORD *)(a1 + 108) = v15;
    *(_OWORD *)(a1 + 124) = v16;
    *(_OWORD *)(a1 + 92) = v14;
    *(_BYTE *)(a1 + 144) = 1;
  }
  v17 = *(_OWORD *)(a2 + 148);
  *(_OWORD *)(a1 + 161) = *(_OWORD *)(a2 + 161);
  *(_OWORD *)(a1 + 148) = v17;
  v18 = *(_QWORD *)(a2 + 184);
  *(_QWORD *)(a2 + 184) = 0;
  v19 = *(_QWORD *)(a1 + 184);
  *(_QWORD *)(a1 + 184) = v18;
  if (v19)
  {
    do
    {
      v20 = __ldaxr((unsigned int *)v19);
      v21 = v20 - 1;
    }
    while (__stlxr(v21, (unsigned int *)v19));
    if (!v21)
    {
      v22 = *(_QWORD *)(v19 + 8);
      if (v22)
      {
        v23 = *(_QWORD *)(v19 + 16);
        v24 = *(void **)(v19 + 8);
        if (v23 != v22)
        {
          do
          {
            v25 = *(void **)(v23 - 96);
            if (v25)
            {
              *(_QWORD *)(v23 - 88) = v25;
              operator delete(v25);
            }
            v23 -= 104;
          }
          while (v23 != v22);
          v24 = *(void **)(v19 + 8);
        }
        *(_QWORD *)(v19 + 16) = v22;
        operator delete(v24);
      }
      MEMORY[0x20BD0ADEC](v19, 0x1020C40E72D6CFBLL);
    }
  }
  v26 = *(_OWORD *)(a2 + 192);
  *(_BYTE *)(a1 + 208) = *(_BYTE *)(a2 + 208);
  *(_OWORD *)(a1 + 192) = v26;
  return a1;
}

uint64_t webrtc::VideoFrame::width(webrtc::VideoFrame *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

uint64_t webrtc::VideoFrame::height(webrtc::VideoFrame *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

uint64_t (***webrtc::VideoFrame::video_frame_buffer@<X0>(webrtc::VideoFrame *this@<X0>, _QWORD *a2@<X8>))(_QWORD)
{
  uint64_t (***result)(_QWORD);

  result = (uint64_t (***)(_QWORD))*((_QWORD *)this + 1);
  *a2 = result;
  if (result)
    return (uint64_t (***)(_QWORD))(**result)(result);
  return result;
}

webrtc::I420BufferInterface *webrtc::VideoFrame::set_video_frame_buffer(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void (***v8)(_QWORD);
  webrtc::I420BufferInterface *result;
  std::string *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  _QWORD *v18;
  uint64_t v19;

  v8 = (void (***)(_QWORD))*a2;
  if (*a2)
  {
    (**v8)(*a2);
    result = *(webrtc::I420BufferInterface **)(a1 + 8);
    if (result)
      result = (webrtc::I420BufferInterface *)(*(uint64_t (**)(webrtc::I420BufferInterface *))(*(_QWORD *)result + 8))(result);
    *(_QWORD *)(a1 + 8) = v8;
  }
  else
  {
    v11 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame.cc", 332, "buffer", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v19);
    return webrtc::VideoFrameBuffer::CropAndScale((webrtc::VideoFrameBuffer *)v11, v12, v13, v14, v15, v16, v17, v18);
  }
  return result;
}

webrtc::I420BufferInterface *webrtc::VideoFrameBuffer::CropAndScale@<X0>(webrtc::VideoFrameBuffer *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, int a6@<W5>, int a7@<W6>, _QWORD *a8@<X8>)
{
  _DWORD *v16;
  _DWORD *v17;
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  webrtc::I420BufferInterface *result;
  std::string *v31;
  webrtc::I420BufferInterface *v32;

  v16 = (_DWORD *)operator new();
  v17 = v16;
  v18 = a6 + 2;
  if (a6 >= -1)
    v18 = a6 + 1;
  v19 = v18 >> 1;
  v16[2] = a6;
  v16[3] = a7;
  v16[4] = a6;
  v16[5] = v19;
  v16[6] = v19;
  v20 = a7 + 2;
  if (a7 >= -1)
    v20 = a7 + 1;
  v21 = a7 * a6 + 2 * v19 * (v20 >> 1);
  if (v21)
  {
    v22 = malloc_type_malloc(v21 + 71, 0xB9DC9477uLL);
    if (!v22)
    {
      v31 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/memory/aligned_malloc.cc", 66, "memory_pointer", "\t", v23, v24, v25, v26, (uint64_t)"Couldn't allocate memory in AlignedMalloc");
      return (webrtc::I420BufferInterface *)webrtc::VideoFrameBuffer::GetI420((webrtc::VideoFrameBuffer *)v31);
    }
    v27 = ((unint64_t)v22 + 71) & 0xFFFFFFFFFFFFFFC0;
    *(_QWORD *)(v27 - 8) = v22;
  }
  else
  {
    v27 = 0;
  }
  *((_QWORD *)v17 + 4) = v27;
  *(_QWORD *)v17 = &unk_24C0B4DF0;
  v17[10] = 0;
  v28 = v17 + 10;
  do
    v29 = __ldxr(v28);
  while (__stxr(v29 + 1, v28));
  (*(void (**)(webrtc::I420BufferInterface **__return_ptr, webrtc::VideoFrameBuffer *))(*(_QWORD *)this + 56))(&v32, this);
  webrtc::I420Buffer::CropAndScaleFrom((webrtc::I420Buffer *)v17, v32, a2, a3, a4, a5);
  result = v32;
  if (v32)
    result = (webrtc::I420BufferInterface *)(*(uint64_t (**)(webrtc::I420BufferInterface *))(*(_QWORD *)v32 + 8))(v32);
  *a8 = v17;
  return result;
}

uint64_t webrtc::VideoFrameBuffer::GetI420(webrtc::VideoFrameBuffer *this)
{
  return 0;
}

webrtc::VideoFrameBuffer *webrtc::VideoFrameBuffer::GetI010(webrtc::VideoFrameBuffer *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::string *v7;
  uint64_t v8;

  if ((*(unsigned int (**)(webrtc::VideoFrameBuffer *))(*(_QWORD *)this + 32))(this) == 5)
    return this;
  v7 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame_buffer.cc", 59, "type() == Type::kI010", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v2, v3, v4, v5, v8);
  return (webrtc::VideoFrameBuffer *)webrtc::VideoFrameBuffer::GetMappedFrameBuffer(v7);
}

void webrtc::VideoFrameBuffer::GetMappedFrameBuffer(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1))
  {
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_frame_buffer.cc", 80, "type() == Type::kNative", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v3, v4, v5, v6, v8);
    webrtc::VideoFrameBuffer::storage_representation(v7);
  }
  else
  {
    *a2 = 0;
  }
}

void webrtc::VideoFrameBuffer::storage_representation(unint64_t a1@<X8>)
{
  *(_BYTE *)(a1 + 23) = 1;
  if (a1 <= (unint64_t)"?" && a1 + 1 > (unint64_t)"?")
    __break(1u);
  else
    *(_WORD *)a1 = 63;
}

uint64_t webrtc::I420BufferInterface::type(webrtc::I420BufferInterface *this)
{
  return 1;
}

uint64_t webrtc::I420BufferInterface::ChromaWidth(webrtc::I420BufferInterface *this)
{
  int v1;
  int v2;

  v1 = (*(uint64_t (**)(webrtc::I420BufferInterface *))(*(_QWORD *)this + 40))(this);
  v2 = v1 + 2;
  if (v1 >= -1)
    v2 = v1 + 1;
  return (v2 >> 1);
}

uint64_t webrtc::I420BufferInterface::ChromaHeight(webrtc::I420BufferInterface *this)
{
  int v1;
  int v2;

  v1 = (*(uint64_t (**)(webrtc::I420BufferInterface *))(*(_QWORD *)this + 48))(this);
  v2 = v1 + 2;
  if (v1 >= -1)
    v2 = v1 + 1;
  return (v2 >> 1);
}

uint64_t (***webrtc::I420BufferInterface::ToI420@<X0>(uint64_t (***this)(_QWORD)@<X0>, _QWORD *a2@<X8>))(_QWORD)
{
  *a2 = this;
  if (this)
    return (uint64_t (***)(_QWORD))(**this)(this);
  return this;
}

uint64_t webrtc::I444BufferInterface::type(webrtc::I444BufferInterface *this)
{
  return 4;
}

uint64_t webrtc::I444BufferInterface::ChromaWidth(webrtc::I444BufferInterface *this)
{
  return (*(uint64_t (**)(webrtc::I444BufferInterface *))(*(_QWORD *)this + 40))(this);
}

uint64_t webrtc::I444BufferInterface::ChromaHeight(webrtc::I444BufferInterface *this)
{
  return (*(uint64_t (**)(webrtc::I444BufferInterface *))(*(_QWORD *)this + 48))(this);
}

uint64_t webrtc::I444BufferInterface::CropAndScale@<X0>(webrtc::I444BufferInterface *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, int a6@<W5>, int a7@<W6>, uint64_t *a8@<X8>)
{
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unsigned int *v23;
  unsigned int v24;
  uint64_t result;
  std::string *v26;

  v16 = operator new();
  *(_DWORD *)(v16 + 8) = a6;
  *(_DWORD *)(v16 + 12) = a7;
  *(_DWORD *)(v16 + 16) = a6;
  *(_DWORD *)(v16 + 20) = a6;
  *(_DWORD *)(v16 + 24) = a6;
  if (3 * a6 * a7)
  {
    v17 = malloc_type_malloc(3 * a6 * a7 + 71, 0xB9DC9477uLL);
    if (!v17)
    {
      v26 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/memory/aligned_malloc.cc", 66, "memory_pointer", "\t", v18, v19, v20, v21, (uint64_t)"Couldn't allocate memory in AlignedMalloc");
      return webrtc::I422BufferInterface::type((webrtc::I422BufferInterface *)v26);
    }
    v22 = ((unint64_t)v17 + 71) & 0xFFFFFFFFFFFFFFC0;
    *(_QWORD *)(v22 - 8) = v17;
  }
  else
  {
    v22 = 0;
  }
  *(_QWORD *)(v16 + 32) = v22;
  *(_QWORD *)v16 = &unk_24C0B50C0;
  *(_DWORD *)(v16 + 40) = 0;
  v23 = (unsigned int *)(v16 + 40);
  do
    v24 = __ldxr(v23);
  while (__stxr(v24 + 1, v23));
  result = webrtc::I444Buffer::CropAndScaleFrom((webrtc::I444Buffer *)v16, this, a2, a3, a4, a5);
  *a8 = v16;
  return result;
}

uint64_t webrtc::I422BufferInterface::type(webrtc::I422BufferInterface *this)
{
  return 3;
}

uint64_t webrtc::I422BufferInterface::ChromaWidth(webrtc::I422BufferInterface *this)
{
  int v1;
  int v2;

  v1 = (*(uint64_t (**)(webrtc::I422BufferInterface *))(*(_QWORD *)this + 40))(this);
  v2 = v1 + 2;
  if (v1 >= -1)
    v2 = v1 + 1;
  return (v2 >> 1);
}

uint64_t webrtc::I422BufferInterface::ChromaHeight(webrtc::I422BufferInterface *this)
{
  return (*(uint64_t (**)(webrtc::I422BufferInterface *))(*(_QWORD *)this + 48))(this);
}

uint64_t webrtc::I422BufferInterface::CropAndScale@<X0>(webrtc::I422BufferInterface *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, int a6@<W5>, int a7@<W6>, _QWORD *a8@<X8>)
{
  _DWORD *v16;
  _DWORD *v17;
  int v18;
  signed int v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unsigned int *v26;
  unsigned int v27;
  uint64_t result;
  std::string *v29;

  v16 = (_DWORD *)operator new();
  v17 = v16;
  v18 = a6 + 2;
  if (a6 >= -1)
    v18 = a6 + 1;
  v16[2] = a6;
  v16[3] = a7;
  v16[4] = a6;
  v16[5] = v18 >> 1;
  v16[6] = v18 >> 1;
  v19 = ((v18 & 0xFFFFFFFE) + a6) * a7;
  if (v19)
  {
    v20 = malloc_type_malloc(v19 + 71, 0xB9DC9477uLL);
    if (!v20)
    {
      v29 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/memory/aligned_malloc.cc", 66, "memory_pointer", "\t", v21, v22, v23, v24, (uint64_t)"Couldn't allocate memory in AlignedMalloc");
      return webrtc::I010BufferInterface::type((webrtc::I010BufferInterface *)v29);
    }
    v25 = ((unint64_t)v20 + 71) & 0xFFFFFFFFFFFFFFC0;
    *(_QWORD *)(v25 - 8) = v20;
  }
  else
  {
    v25 = 0;
  }
  *((_QWORD *)v17 + 4) = v25;
  *(_QWORD *)v17 = &unk_24C0B4F58;
  v17[10] = 0;
  v26 = v17 + 10;
  do
    v27 = __ldxr(v26);
  while (__stxr(v27 + 1, v26));
  result = webrtc::I422Buffer::CropAndScaleFrom((webrtc::I422Buffer *)v17, this, a2, a3, a4, a5);
  *a8 = v17;
  return result;
}

uint64_t webrtc::I010BufferInterface::type(webrtc::I010BufferInterface *this)
{
  return 5;
}

uint64_t webrtc::I010BufferInterface::ChromaWidth(webrtc::I010BufferInterface *this)
{
  int v1;
  int v2;

  v1 = (*(uint64_t (**)(webrtc::I010BufferInterface *))(*(_QWORD *)this + 40))(this);
  v2 = v1 + 2;
  if (v1 >= -1)
    v2 = v1 + 1;
  return (v2 >> 1);
}

uint64_t webrtc::I010BufferInterface::ChromaHeight(webrtc::I010BufferInterface *this)
{
  int v1;
  int v2;

  v1 = (*(uint64_t (**)(webrtc::I010BufferInterface *))(*(_QWORD *)this + 48))(this);
  v2 = v1 + 2;
  if (v1 >= -1)
    v2 = v1 + 1;
  return (v2 >> 1);
}

uint64_t webrtc::I210BufferInterface::type(webrtc::I210BufferInterface *this)
{
  return 6;
}

uint64_t webrtc::I210BufferInterface::ChromaWidth(webrtc::I210BufferInterface *this)
{
  int v1;
  int v2;

  v1 = (*(uint64_t (**)(webrtc::I210BufferInterface *))(*(_QWORD *)this + 40))(this);
  v2 = v1 + 2;
  if (v1 >= -1)
    v2 = v1 + 1;
  return (v2 >> 1);
}

uint64_t webrtc::I210BufferInterface::ChromaHeight(webrtc::I210BufferInterface *this)
{
  return (*(uint64_t (**)(webrtc::I210BufferInterface *))(*(_QWORD *)this + 48))(this);
}

uint64_t webrtc::I410BufferInterface::type(webrtc::I410BufferInterface *this)
{
  return 7;
}

uint64_t webrtc::I410BufferInterface::ChromaWidth(webrtc::I410BufferInterface *this)
{
  return (*(uint64_t (**)(webrtc::I410BufferInterface *))(*(_QWORD *)this + 40))(this);
}

uint64_t webrtc::I410BufferInterface::ChromaHeight(webrtc::I410BufferInterface *this)
{
  return (*(uint64_t (**)(webrtc::I410BufferInterface *))(*(_QWORD *)this + 48))(this);
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>>::AddRef(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 88);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>>::Release(unsigned int *a1)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = a1 + 22;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (a1 && v2 == 1)
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 24))(a1);
  return v2 != 1;
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>>::~RefCountedObject(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;

  *a1 = &unk_24C0C3688;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        return (uint64_t)a1;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
    return (uint64_t)a1;
  }
  v6 = std::__throw_bad_function_call[abi:sn180100]();
}

{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &unk_24C0C3688;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        goto LABEL_9;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_9:
    JUMPOUT(0x20BD0ADECLL);
  }
  v5 = std::__throw_bad_function_call[abi:sn180100]();
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>::width(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>::height(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>::StrideY(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>::StrideU(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>::StrideV(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>::DataY(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>::DataU(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>::DataV(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::I420BufferInterface>>::HasOneRef(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)(a1 + 88));
  return v1 == 1;
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>>::AddRef(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 88);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>>::Release(unsigned int *a1)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = a1 + 22;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (a1 && v2 == 1)
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 24))(a1);
  return v2 != 1;
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>>::~RefCountedObject(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;

  *a1 = &unk_24C0C37F0;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        return (uint64_t)a1;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
    return (uint64_t)a1;
  }
  v6 = std::__throw_bad_function_call[abi:sn180100]();
}

{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &unk_24C0C37F0;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        goto LABEL_9;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_9:
    JUMPOUT(0x20BD0ADECLL);
  }
  v5 = std::__throw_bad_function_call[abi:sn180100]();
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>::width(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>::height(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t webrtc::`anonymous namespace'::I422BufferBase::ToI420@<X0>(webrtc::_anonymous_namespace_::I422BufferBase *this@<X0>, _QWORD *a2@<X8>)
{
  int v4;
  int v5;
  _DWORD *v6;
  _DWORD *v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  const unsigned __int8 *v20;
  int8x16_t *v21;
  unsigned __int8 *v22;
  int8x16_t *v23;
  int v24;
  int8x16_t *v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  int v29;
  uint64_t result;
  std::string *v31;
  unsigned __int8 *v32;
  int v33;
  unsigned __int8 *v34;
  unsigned int v35;
  unsigned __int8 *v36;
  unsigned int v37;
  libyuv *v38;
  _QWORD *v39;

  v4 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I422BufferBase *))(*(_QWORD *)this + 40))(this);
  v5 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I422BufferBase *))(*(_QWORD *)this + 48))(this);
  v6 = (_DWORD *)operator new();
  v7 = v6;
  v8 = v4 + 2;
  if (v4 >= -1)
    v8 = v4 + 1;
  v9 = v8 >> 1;
  v6[2] = v4;
  v6[3] = v5;
  v6[4] = v4;
  v6[5] = v9;
  v6[6] = v9;
  v10 = v5 + 2;
  if (v5 >= -1)
    v10 = v5 + 1;
  v11 = v5 * v4 + 2 * v9 * (v10 >> 1);
  if (v11)
  {
    v12 = malloc_type_malloc(v11 + 71, 0xB9DC9477uLL);
    if (!v12)
    {
      v31 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/memory/aligned_malloc.cc", 66, "memory_pointer", "\t", v13, v14, v15, v16, (uint64_t)"Couldn't allocate memory in AlignedMalloc");
    }
    v17 = ((unint64_t)v12 + 71) & 0xFFFFFFFFFFFFFFC0;
    *(_QWORD *)(v17 - 8) = v12;
  }
  else
  {
    v17 = 0;
  }
  v39 = a2;
  *((_QWORD *)v7 + 4) = v17;
  *(_QWORD *)v7 = &unk_24C0B4DF0;
  v7[10] = 0;
  v18 = v7 + 10;
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  v38 = (libyuv *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I422BufferBase *))(*(_QWORD *)this + 136))(this);
  v37 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I422BufferBase *))(*(_QWORD *)this + 112))(this);
  v36 = (unsigned __int8 *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I422BufferBase *))(*(_QWORD *)this + 144))(this);
  v35 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I422BufferBase *))(*(_QWORD *)this + 120))(this);
  v34 = (unsigned __int8 *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I422BufferBase *))(*(_QWORD *)this + 152))(this);
  v20 = (const unsigned __int8 *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I422BufferBase *))(*(_QWORD *)this + 128))(this);
  v21 = (int8x16_t *)webrtc::I420Buffer::DataY((webrtc::I420Buffer *)v7);
  v22 = (unsigned __int8 *)webrtc::I420Buffer::StrideY((webrtc::I420Buffer *)v7);
  v23 = (int8x16_t *)webrtc::I420Buffer::DataU((webrtc::I420Buffer *)v7);
  v24 = webrtc::I420Buffer::StrideU((webrtc::I420Buffer *)v7);
  v25 = (int8x16_t *)webrtc::I420Buffer::DataV((webrtc::I420Buffer *)v7);
  v26 = webrtc::I420Buffer::StrideV((webrtc::I420Buffer *)v7);
  v27 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I422BufferBase *))(*(_QWORD *)this + 40))(this);
  v28 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I422BufferBase *))(*(_QWORD *)this + 48))(this);
  v29 = (v27 + 1) >> 1;
  if (v27 < 0)
    v29 = -((1 - v27) >> 1);
  LODWORD(v32) = v24;
  result = libyuv::I4xxToI420(v38, (const unsigned __int8 *)v37, v36, (const unsigned __int8 *)v35, v34, v20, v21, v22, v23, v32, v25, (unsigned __int8 *)__PAIR64__(v27, v26), v28, v29, v28, v33, (int)v34);
  *v39 = v7;
  return result;
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>::StrideY(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>::StrideU(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>::StrideV(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>::DataY(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>::DataU(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>::DataV(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I422BufferBase>>::HasOneRef(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)(a1 + 88));
  return v1 == 1;
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>>::AddRef(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 88);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>>::Release(unsigned int *a1)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = a1 + 22;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (a1 && v2 == 1)
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 24))(a1);
  return v2 != 1;
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>>::~RefCountedObject(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;

  *a1 = &unk_24C0C3958;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        return (uint64_t)a1;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
    return (uint64_t)a1;
  }
  v6 = std::__throw_bad_function_call[abi:sn180100]();
}

{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &unk_24C0C3958;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        goto LABEL_9;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_9:
    JUMPOUT(0x20BD0ADECLL);
  }
  v5 = std::__throw_bad_function_call[abi:sn180100]();
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>::width(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>::height(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t webrtc::`anonymous namespace'::I444BufferBase::ToI420@<X0>(webrtc::_anonymous_namespace_::I444BufferBase *this@<X0>, _QWORD *a2@<X8>)
{
  int v4;
  int v5;
  _DWORD *v6;
  _DWORD *v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  const unsigned __int8 *v20;
  int8x16_t *v21;
  unsigned __int8 *v22;
  int8x16_t *v23;
  int v24;
  int8x16_t *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t result;
  std::string *v30;
  unsigned __int8 *v31;
  int v32;
  unsigned __int8 *v33;
  unsigned int v34;
  unsigned __int8 *v35;
  unsigned int v36;
  libyuv *v37;
  _QWORD *v38;

  v4 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I444BufferBase *))(*(_QWORD *)this + 40))(this);
  v5 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I444BufferBase *))(*(_QWORD *)this + 48))(this);
  v6 = (_DWORD *)operator new();
  v7 = v6;
  v8 = v4 + 2;
  if (v4 >= -1)
    v8 = v4 + 1;
  v9 = v8 >> 1;
  v6[2] = v4;
  v6[3] = v5;
  v6[4] = v4;
  v6[5] = v9;
  v6[6] = v9;
  v10 = v5 + 2;
  if (v5 >= -1)
    v10 = v5 + 1;
  v11 = v5 * v4 + 2 * v9 * (v10 >> 1);
  if (v11)
  {
    v12 = malloc_type_malloc(v11 + 71, 0xB9DC9477uLL);
    if (!v12)
    {
      v30 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/memory/aligned_malloc.cc", 66, "memory_pointer", "\t", v13, v14, v15, v16, (uint64_t)"Couldn't allocate memory in AlignedMalloc");
    }
    v17 = ((unint64_t)v12 + 71) & 0xFFFFFFFFFFFFFFC0;
    *(_QWORD *)(v17 - 8) = v12;
  }
  else
  {
    v17 = 0;
  }
  v38 = a2;
  *((_QWORD *)v7 + 4) = v17;
  *(_QWORD *)v7 = &unk_24C0B4DF0;
  v7[10] = 0;
  v18 = v7 + 10;
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  v37 = (libyuv *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I444BufferBase *))(*(_QWORD *)this + 136))(this);
  v36 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I444BufferBase *))(*(_QWORD *)this + 112))(this);
  v35 = (unsigned __int8 *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I444BufferBase *))(*(_QWORD *)this + 144))(this);
  v34 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I444BufferBase *))(*(_QWORD *)this + 120))(this);
  v33 = (unsigned __int8 *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I444BufferBase *))(*(_QWORD *)this + 152))(this);
  v20 = (const unsigned __int8 *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I444BufferBase *))(*(_QWORD *)this + 128))(this);
  v21 = (int8x16_t *)webrtc::I420Buffer::DataY((webrtc::I420Buffer *)v7);
  v22 = (unsigned __int8 *)webrtc::I420Buffer::StrideY((webrtc::I420Buffer *)v7);
  v23 = (int8x16_t *)webrtc::I420Buffer::DataU((webrtc::I420Buffer *)v7);
  v24 = webrtc::I420Buffer::StrideU((webrtc::I420Buffer *)v7);
  v25 = (int8x16_t *)webrtc::I420Buffer::DataV((webrtc::I420Buffer *)v7);
  v26 = webrtc::I420Buffer::StrideV((webrtc::I420Buffer *)v7);
  v27 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I444BufferBase *))(*(_QWORD *)this + 40))(this);
  v28 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I444BufferBase *))(*(_QWORD *)this + 48))(this);
  LODWORD(v31) = v24;
  result = libyuv::I4xxToI420(v37, (const unsigned __int8 *)v36, v35, (const unsigned __int8 *)v34, v33, v20, v21, v22, v23, v31, v25, (unsigned __int8 *)__PAIR64__(v27, v26), v28, v27, v28, v32, (int)v33);
  *v38 = v7;
  return result;
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>::StrideY(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>::StrideU(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>::StrideV(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>::DataY(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>::DataU(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>::DataV(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuvBuffer<webrtc::`anonymous namespace'::I444BufferBase>>::HasOneRef(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)(a1 + 88));
  return v1 == 1;
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>>::AddRef(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 88);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>>::Release(unsigned int *a1)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = a1 + 22;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (a1 && v2 == 1)
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 24))(a1);
  return v2 != 1;
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>>::~RefCountedObject(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;

  *a1 = &unk_24C0C3AC0;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        return (uint64_t)a1;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
    return (uint64_t)a1;
  }
  v6 = std::__throw_bad_function_call[abi:sn180100]();
}

{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &unk_24C0C3AC0;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        goto LABEL_9;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_9:
    JUMPOUT(0x20BD0ADECLL);
  }
  v5 = std::__throw_bad_function_call[abi:sn180100]();
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>::width(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>::height(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t webrtc::`anonymous namespace'::I010BufferBase::ToI420@<X0>(webrtc::_anonymous_namespace_::I010BufferBase *this@<X0>, _QWORD *a2@<X8>)
{
  int v4;
  int v5;
  _DWORD *v6;
  _DWORD *v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  const unsigned __int16 *v20;
  int8x16_t *v21;
  unsigned __int8 *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  uint64_t result;
  std::string *v30;
  unsigned __int8 *v31;
  uint16x8_t *v32;
  unsigned int v33;
  uint16x8_t *v34;
  unsigned int v35;
  libyuv *v36;
  _QWORD *v37;

  v4 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I010BufferBase *))(*(_QWORD *)this + 40))(this);
  v5 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I010BufferBase *))(*(_QWORD *)this + 48))(this);
  v6 = (_DWORD *)operator new();
  v7 = v6;
  v8 = v4 + 2;
  if (v4 >= -1)
    v8 = v4 + 1;
  v9 = v8 >> 1;
  v6[2] = v4;
  v6[3] = v5;
  v6[4] = v4;
  v6[5] = v9;
  v6[6] = v9;
  v10 = v5 + 2;
  if (v5 >= -1)
    v10 = v5 + 1;
  v11 = v5 * v4 + 2 * v9 * (v10 >> 1);
  if (v11)
  {
    v12 = malloc_type_malloc(v11 + 71, 0xB9DC9477uLL);
    if (!v12)
    {
      v30 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/memory/aligned_malloc.cc", 66, "memory_pointer", "\t", v13, v14, v15, v16, (uint64_t)"Couldn't allocate memory in AlignedMalloc");
    }
    v17 = ((unint64_t)v12 + 71) & 0xFFFFFFFFFFFFFFC0;
    *(_QWORD *)(v17 - 8) = v12;
  }
  else
  {
    v17 = 0;
  }
  v37 = a2;
  *((_QWORD *)v7 + 4) = v17;
  *(_QWORD *)v7 = &unk_24C0B4DF0;
  v7[10] = 0;
  v18 = v7 + 10;
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  v36 = (libyuv *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I010BufferBase *))(*(_QWORD *)this + 136))(this);
  v35 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I010BufferBase *))(*(_QWORD *)this + 112))(this);
  v34 = (uint16x8_t *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I010BufferBase *))(*(_QWORD *)this
                                                                                                 + 144))(this);
  v33 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I010BufferBase *))(*(_QWORD *)this + 120))(this);
  v32 = (uint16x8_t *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I010BufferBase *))(*(_QWORD *)this
                                                                                                 + 152))(this);
  v20 = (const unsigned __int16 *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I010BufferBase *))(*(_QWORD *)this + 128))(this);
  v21 = (int8x16_t *)webrtc::I420Buffer::DataY((webrtc::I420Buffer *)v7);
  v22 = (unsigned __int8 *)webrtc::I420Buffer::StrideY((webrtc::I420Buffer *)v7);
  v23 = webrtc::I420Buffer::DataU((webrtc::I420Buffer *)v7);
  v24 = webrtc::I420Buffer::StrideU((webrtc::I420Buffer *)v7);
  v25 = webrtc::I420Buffer::DataV((webrtc::I420Buffer *)v7);
  v26 = webrtc::I420Buffer::StrideV((webrtc::I420Buffer *)v7);
  v27 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I010BufferBase *))(*(_QWORD *)this + 40))(this);
  v28 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I010BufferBase *))(*(_QWORD *)this + 48))(this);
  LODWORD(v31) = v24;
  result = libyuv::Planar16bitTo8bit(v36, (const unsigned __int16 *)v35, v34, (const unsigned __int16 *)v33, v32, v20, v21, v22, v23, v31, v25, (unsigned __int8 *)__PAIR64__(v27, v26), v28, 1, 1, 10, (int)v32, SHIDWORD(v32));
  *v37 = v7;
  return result;
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>::StrideY(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>::StrideU(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>::StrideV(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>::DataY(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>::DataU(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>::DataV(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I010BufferBase>>::HasOneRef(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)(a1 + 88));
  return v1 == 1;
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>>::AddRef(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 88);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>>::Release(unsigned int *a1)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = a1 + 22;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (a1 && v2 == 1)
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 24))(a1);
  return v2 != 1;
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>>::~RefCountedObject(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;

  *a1 = &unk_24C0C3C28;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        return (uint64_t)a1;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
    return (uint64_t)a1;
  }
  v6 = std::__throw_bad_function_call[abi:sn180100]();
}

{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &unk_24C0C3C28;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        goto LABEL_9;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_9:
    JUMPOUT(0x20BD0ADECLL);
  }
  v5 = std::__throw_bad_function_call[abi:sn180100]();
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>::width(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>::height(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t webrtc::`anonymous namespace'::I210BufferBase::ToI420@<X0>(webrtc::_anonymous_namespace_::I210BufferBase *this@<X0>, _QWORD *a2@<X8>)
{
  int v4;
  int v5;
  _DWORD *v6;
  _DWORD *v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  const unsigned __int16 *v20;
  int8x16_t *v21;
  unsigned __int8 *v22;
  __int128 *v23;
  int v24;
  __int128 *v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  uint64_t result;
  std::string *v30;
  unsigned __int8 *v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned __int16 *v35;
  unsigned int v36;
  libyuv *v37;
  _QWORD *v38;

  v4 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I210BufferBase *))(*(_QWORD *)this + 40))(this);
  v5 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I210BufferBase *))(*(_QWORD *)this + 48))(this);
  v6 = (_DWORD *)operator new();
  v7 = v6;
  v8 = v4 + 2;
  if (v4 >= -1)
    v8 = v4 + 1;
  v9 = v8 >> 1;
  v6[2] = v4;
  v6[3] = v5;
  v6[4] = v4;
  v6[5] = v9;
  v6[6] = v9;
  v10 = v5 + 2;
  if (v5 >= -1)
    v10 = v5 + 1;
  v11 = v5 * v4 + 2 * v9 * (v10 >> 1);
  if (v11)
  {
    v12 = malloc_type_malloc(v11 + 71, 0xB9DC9477uLL);
    if (!v12)
    {
      v30 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/memory/aligned_malloc.cc", 66, "memory_pointer", "\t", v13, v14, v15, v16, (uint64_t)"Couldn't allocate memory in AlignedMalloc");
    }
    v17 = ((unint64_t)v12 + 71) & 0xFFFFFFFFFFFFFFC0;
    *(_QWORD *)(v17 - 8) = v12;
  }
  else
  {
    v17 = 0;
  }
  v38 = a2;
  *((_QWORD *)v7 + 4) = v17;
  *(_QWORD *)v7 = &unk_24C0B4DF0;
  v7[10] = 0;
  v18 = v7 + 10;
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  v37 = (libyuv *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I210BufferBase *))(*(_QWORD *)this + 136))(this);
  v36 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I210BufferBase *))(*(_QWORD *)this + 112))(this);
  v35 = (unsigned __int16 *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I210BufferBase *))(*(_QWORD *)this + 144))(this);
  v34 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I210BufferBase *))(*(_QWORD *)this + 120))(this);
  v33 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I210BufferBase *))(*(_QWORD *)this + 152))(this);
  v20 = (const unsigned __int16 *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I210BufferBase *))(*(_QWORD *)this + 128))(this);
  v21 = (int8x16_t *)webrtc::I420Buffer::DataY((webrtc::I420Buffer *)v7);
  v22 = (unsigned __int8 *)webrtc::I420Buffer::StrideY((webrtc::I420Buffer *)v7);
  v23 = (__int128 *)webrtc::I420Buffer::DataU((webrtc::I420Buffer *)v7);
  v24 = webrtc::I420Buffer::StrideU((webrtc::I420Buffer *)v7);
  v25 = (__int128 *)webrtc::I420Buffer::DataV((webrtc::I420Buffer *)v7);
  v26 = webrtc::I420Buffer::StrideV((webrtc::I420Buffer *)v7);
  v27 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I210BufferBase *))(*(_QWORD *)this + 40))(this);
  v28 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I210BufferBase *))(*(_QWORD *)this + 48))(this);
  LODWORD(v31) = v24;
  result = libyuv::I21xToI420(v37, (const unsigned __int16 *)v36, (uint64_t)v35, (const unsigned __int16 *)v34, v33, v20, v21, v22, v23, v31, v25, (unsigned __int8 *)__PAIR64__(v27, v26), v28, 10, v32, SHIDWORD(v32));
  *v38 = v7;
  return result;
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>::StrideY(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>::StrideU(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>::StrideV(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>::DataY(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>::DataU(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>::DataV(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I210BufferBase>>::HasOneRef(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)(a1 + 88));
  return v1 == 1;
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>>::AddRef(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 88);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>>::Release(unsigned int *a1)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = a1 + 22;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (a1 && v2 == 1)
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 24))(a1);
  return v2 != 1;
}

uint64_t rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>>::~RefCountedObject(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;

  *a1 = &unk_24C0C3D90;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        return (uint64_t)a1;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
    return (uint64_t)a1;
  }
  v6 = std::__throw_bad_function_call[abi:sn180100]();
}

{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &unk_24C0C3D90;
  v2 = a1[10];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v3 = (_QWORD *)a1[10];
    if (v3 == a1 + 7)
    {
      v4 = 4;
      v3 = a1 + 7;
    }
    else
    {
      if (!v3)
        goto LABEL_9;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_9:
    JUMPOUT(0x20BD0ADECLL);
  }
  v5 = std::__throw_bad_function_call[abi:sn180100]();
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>::width(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>::height(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t webrtc::`anonymous namespace'::I410BufferBase::ToI420@<X0>(webrtc::_anonymous_namespace_::I410BufferBase *this@<X0>, _QWORD *a2@<X8>)
{
  int v4;
  int v5;
  _DWORD *v6;
  _DWORD *v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  int v20;
  int8x16_t *v21;
  int v22;
  char *v23;
  int v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  uint64_t result;
  std::string *v30;
  unsigned __int16 *v31;
  int v32;
  unsigned __int16 *v33;
  int v34;
  uint16x8_t *v35;
  _QWORD *v36;

  v4 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I410BufferBase *))(*(_QWORD *)this + 40))(this);
  v5 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I410BufferBase *))(*(_QWORD *)this + 48))(this);
  v6 = (_DWORD *)operator new();
  v7 = v6;
  v8 = v4 + 2;
  if (v4 >= -1)
    v8 = v4 + 1;
  v9 = v8 >> 1;
  v6[2] = v4;
  v6[3] = v5;
  v6[4] = v4;
  v6[5] = v9;
  v6[6] = v9;
  v10 = v5 + 2;
  if (v5 >= -1)
    v10 = v5 + 1;
  v11 = v5 * v4 + 2 * v9 * (v10 >> 1);
  if (v11)
  {
    v12 = malloc_type_malloc(v11 + 71, 0xB9DC9477uLL);
    if (!v12)
    {
      v30 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/memory/aligned_malloc.cc", 66, "memory_pointer", "\t", v13, v14, v15, v16, (uint64_t)"Couldn't allocate memory in AlignedMalloc");
    }
    v17 = ((unint64_t)v12 + 71) & 0xFFFFFFFFFFFFFFC0;
    *(_QWORD *)(v17 - 8) = v12;
  }
  else
  {
    v17 = 0;
  }
  v36 = a2;
  *((_QWORD *)v7 + 4) = v17;
  *(_QWORD *)v7 = &unk_24C0B4DF0;
  v7[10] = 0;
  v18 = v7 + 10;
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  v35 = (uint16x8_t *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I410BufferBase *))(*(_QWORD *)this
                                                                                                 + 136))(this);
  v34 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I410BufferBase *))(*(_QWORD *)this + 112))(this);
  v33 = (unsigned __int16 *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I410BufferBase *))(*(_QWORD *)this + 144))(this);
  v32 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I410BufferBase *))(*(_QWORD *)this + 120))(this);
  v31 = (unsigned __int16 *)(*(uint64_t (**)(webrtc::_anonymous_namespace_::I410BufferBase *))(*(_QWORD *)this + 152))(this);
  v20 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I410BufferBase *))(*(_QWORD *)this + 128))(this);
  v21 = (int8x16_t *)webrtc::I420Buffer::DataY((webrtc::I420Buffer *)v7);
  v22 = webrtc::I420Buffer::StrideY((webrtc::I420Buffer *)v7);
  v23 = (char *)webrtc::I420Buffer::DataU((webrtc::I420Buffer *)v7);
  v24 = webrtc::I420Buffer::StrideU((webrtc::I420Buffer *)v7);
  v25 = (char *)webrtc::I420Buffer::DataV((webrtc::I420Buffer *)v7);
  v26 = webrtc::I420Buffer::StrideV((webrtc::I420Buffer *)v7);
  v27 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I410BufferBase *))(*(_QWORD *)this + 40))(this);
  v28 = (*(uint64_t (**)(webrtc::_anonymous_namespace_::I410BufferBase *))(*(_QWORD *)this + 48))(this);
  result = I410ToI420(v35, v34, v33, v32, v31, v20, v21, v22, v23, v24, v25, v26, v27, v28);
  *v36 = v7;
  return result;
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>::StrideY(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>::StrideU(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>::StrideV(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>::DataY(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>::DataU(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>::DataV(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

BOOL rtc::RefCountedObject<webrtc::`anonymous namespace'::WrappedYuv16BBuffer<webrtc::`anonymous namespace'::I410BufferBase>>::HasOneRef(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)(a1 + 88));
  return v1 == 1;
}

uint64_t webrtc::VideoFrameBufferPool::VideoFrameBufferPool(uint64_t this, char a2, uint64_t a3)
{
  *(_DWORD *)this = 0;
  *(_QWORD *)(this + 16) = this + 16;
  *(_QWORD *)(this + 24) = this + 16;
  *(_QWORD *)(this + 32) = 0;
  *(_BYTE *)(this + 40) = a2;
  *(_QWORD *)(this + 48) = a3;
  return this;
}

void webrtc::VideoFrameBufferPool::~VideoFrameBufferPool(webrtc::VideoFrameBufferPool *this)
{
  char *v1;
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;

  if (*((_QWORD *)this + 4))
  {
    v1 = (char *)this + 16;
    v2 = *((_QWORD *)this + 2);
    v3 = (char *)*((_QWORD *)this + 3);
    v4 = *(_QWORD *)v3;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(v2 + 8);
    **(_QWORD **)(v2 + 8) = v4;
    *((_QWORD *)this + 4) = 0;
    if (v3 != (char *)this + 16)
    {
      do
      {
        v6 = (char *)*((_QWORD *)v3 + 1);
        v5 = *((_QWORD *)v3 + 2);
        if (v5)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
        operator delete(v3);
        v3 = v6;
      }
      while (v6 != v1);
    }
  }
}

void webrtc::VideoFrameBufferPool::Release(webrtc::VideoFrameBufferPool *this)
{
  char *v1;
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;

  if (*((_QWORD *)this + 4))
  {
    v1 = (char *)this + 16;
    v2 = *((_QWORD *)this + 2);
    v3 = (char *)*((_QWORD *)this + 3);
    v4 = *(_QWORD *)v3;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(v2 + 8);
    **(_QWORD **)(v2 + 8) = v4;
    *((_QWORD *)this + 4) = 0;
    if (v3 != (char *)this + 16)
    {
      do
      {
        v6 = (char *)*((_QWORD *)v3 + 1);
        v5 = *((_QWORD *)v3 + 2);
        if (v5)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
        operator delete(v3);
        v3 = v6;
      }
      while (v6 != v1);
    }
  }
}

uint64_t webrtc::VideoFrameBufferPool::Resize(webrtc::VideoFrameBufferPool *this, unint64_t a2)
{
  char *v4;
  uint64_t v5;
  unint64_t v6;
  unsigned int v7;
  uint64_t result;
  char *v9;
  unint64_t v10;
  unsigned int v12;
  _QWORD *v13;
  char *v14;
  _QWORD *v15;

  v4 = (char *)this + 16;
  v5 = *((_QWORD *)this + 3);
  if ((webrtc::VideoFrameBufferPool *)v5 == (webrtc::VideoFrameBufferPool *)((char *)this + 16))
  {
    *((_QWORD *)this + 6) = a2;
    return 1;
  }
  else
  {
    v6 = 0;
    do
    {
      while (1)
      {
        v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 16) + 32))(*(_QWORD *)(v5 + 16)) - 1;
        if (v7 <= 7 && ((0xFDu >> v7) & 1) != 0)
          break;
        ++v6;
        v5 = *(_QWORD *)(v5 + 8);
        if ((char *)v5 == v4)
          goto LABEL_7;
      }
      v6 += (*(unsigned int (**)(void))(**(_QWORD **)(v5 + 16) + 8 * qword_208F1D6A8[v7]))() ^ 1;
      v5 = *(_QWORD *)(v5 + 8);
    }
    while ((char *)v5 != v4);
LABEL_7:
    if (v6 <= a2)
    {
      v9 = (char *)*((_QWORD *)this + 3);
      *((_QWORD *)this + 6) = a2;
      result = 1;
      if (v9 != v4)
      {
        v10 = *((_QWORD *)this + 4) - a2;
        if (v10)
        {
          while (1)
          {
            while (1)
            {
              v12 = (*(uint64_t (**)(_QWORD *))(**((_QWORD **)v9 + 2) + 32))(*((_QWORD **)v9 + 2)) - 1;
              if (v12 <= 7 && ((0xFDu >> v12) & 1) != 0)
              {
                result = (*(uint64_t (**)(void))(**((_QWORD **)v9 + 2) + 8 * qword_208F1D6A8[v12]))();
                if ((_DWORD)result)
                  break;
              }
              v9 = (char *)*((_QWORD *)v9 + 1);
              if (v9 == v4 || v10 == 0)
                return 1;
            }
            if (v9 == v4)
              break;
            v13 = *(_QWORD **)v9;
            v14 = (char *)*((_QWORD *)v9 + 1);
            v13[1] = v14;
            v15 = (_QWORD *)*((_QWORD *)v9 + 2);
            **((_QWORD **)v9 + 1) = v13;
            --*((_QWORD *)this + 4);
            if (v15)
              (*(void (**)(_QWORD *))(*v15 + 8))(v15);
            operator delete(v9);
            --v10;
            v9 = v14;
            if (v14 == v4 || v10 == 0)
              return 1;
          }
          __break(1u);
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void webrtc::VideoFrameBufferPool::CreateI420Buffer(webrtc::VideoFrameBufferPool *this@<X0>, int a2@<W1>, int a3@<W2>, _QWORD *a4@<X8>)
{
  uint64_t v8;
  _DWORD *v9;
  _DWORD *v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  _QWORD *v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  _QWORD *v25;
  uint64_t v26;
  std::string *v27;
  int v28;
  int v29;
  int v30;
  _QWORD *v31;
  uint64_t v32;

  webrtc::VideoFrameBufferPool::GetExistingBuffer(this, a2, a3, 1, &v32);
  v8 = v32;
  if (v32)
  {
    *a4 = v32;
    (**(void (***)(uint64_t))v8)(v8);
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    return;
  }
  if (*((_QWORD *)this + 4) >= *((_QWORD *)this + 6))
  {
    *a4 = 0;
    return;
  }
  v9 = (_DWORD *)operator new();
  v10 = v9;
  v11 = a2 + 2;
  if (a2 >= -1)
    v11 = a2 + 1;
  v12 = v11 >> 1;
  v9[2] = a2;
  v9[3] = a3;
  v9[4] = a2;
  v9[5] = v12;
  v9[6] = v12;
  v13 = a3 + 2;
  if (a3 >= -1)
    v13 = a3 + 1;
  v14 = a3 * a2 + 2 * v12 * (v13 >> 1);
  if (v14)
  {
    v15 = malloc_type_malloc(v14 + 71, 0xB9DC9477uLL);
    if (!v15)
    {
      v27 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/memory/aligned_malloc.cc", 66, "memory_pointer", "\t", v16, v17, v18, v19, (uint64_t)"Couldn't allocate memory in AlignedMalloc");
      webrtc::VideoFrameBufferPool::GetExistingBuffer(v27, v28, v29, v30, v31);
      return;
    }
    v20 = v15;
    v21 = (_QWORD *)(((unint64_t)v15 + 71) & 0xFFFFFFFFFFFFFFC0);
    *(v21 - 1) = v20;
  }
  else
  {
    v21 = 0;
  }
  *((_QWORD *)v10 + 4) = v21;
  *(_QWORD *)v10 = &unk_24C0B4DF0;
  v10[10] = 0;
  v22 = v10 + 10;
  *a4 = v10;
  do
    v23 = __ldxr(v22);
  while (__stxr(v23 + 1, v22));
  if (*((_BYTE *)this + 40))
    bzero(v21, v14);
  do
    v24 = __ldxr(v22);
  while (__stxr(v24 + 1, v22));
  v25 = operator new(0x18uLL);
  v25[1] = (char *)this + 16;
  v25[2] = v10;
  v26 = *((_QWORD *)this + 2);
  *v25 = v26;
  *(_QWORD *)(v26 + 8) = v25;
  *((_QWORD *)this + 2) = v25;
  ++*((_QWORD *)this + 4);
}

void webrtc::VideoFrameBufferPool::GetExistingBuffer(_QWORD *a1@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, _QWORD *a5@<X8>)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  void (***v21)(_QWORD);
  std::string *v22;
  uint64_t v23;

  v6 = a1 + 2;
  v7 = (uint64_t *)a1[3];
  if (v7 == a1 + 2)
  {
LABEL_21:
    *a5 = 0;
    return;
  }
  do
  {
    while ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v7[2] + 40))(v7[2]) == a2
         && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v7[2] + 48))(v7[2]) == a3
         && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v7[2] + 32))(v7[2]) == a4)
    {
      v7 = (uint64_t *)v7[1];
      if (v7 == v6)
        goto LABEL_12;
    }
    if (v7 == v6)
    {
      __break(1u);
LABEL_24:
      v22 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/video_frame_buffer_pool.cc", 336, "buffer->type() == type", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v12, v13, v14, v15, v23);
      webrtc::VideoFrameMetadata::GetWidth((webrtc::VideoFrameMetadata *)v22);
      return;
    }
    v16 = *v7;
    v17 = (uint64_t *)v7[1];
    *(_QWORD *)(v16 + 8) = v17;
    v18 = v7[2];
    *(_QWORD *)v7[1] = v16;
    --a1[4];
    if (v18)
      (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
    operator delete(v7);
    v7 = v17;
  }
  while (v17 != v6);
LABEL_12:
  v19 = a1[3];
  if ((uint64_t *)v19 == v6)
    goto LABEL_21;
  while (1)
  {
    v20 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v19 + 16) + 32))(*(_QWORD *)(v19 + 16)) - 1;
    if (v20 <= 7
      && ((0xFDu >> v20) & 1) != 0
      && (*(unsigned int (**)(void))(**(_QWORD **)(v19 + 16) + 8 * qword_208F1D6A8[v20]))())
    {
      break;
    }
    v19 = *(_QWORD *)(v19 + 8);
    if ((uint64_t *)v19 == v6)
      goto LABEL_21;
  }
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v19 + 16) + 32))(*(_QWORD *)(v19 + 16)) != a4)
    goto LABEL_24;
  v21 = *(void (****)(_QWORD))(v19 + 16);
  *a5 = v21;
  if (v21)
    (**v21)(v21);
}

uint64_t webrtc::VideoFrameMetadata::GetWidth(webrtc::VideoFrameMetadata *this)
{
  return *((unsigned __int16 *)this + 2);
}

uint64_t webrtc::VideoFrameMetadata::GetHeight(webrtc::VideoFrameMetadata *this)
{
  return *((unsigned __int16 *)this + 3);
}

uint64_t webrtc::VideoFrameMetadata::GetFrameId(webrtc::VideoFrameMetadata *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t webrtc::VideoFrameMetadata::GetSpatialIndex(webrtc::VideoFrameMetadata *this)
{
  return *((unsigned int *)this + 8);
}

uint64_t webrtc::VideoFrameMetadata::GetTemporalIndex(webrtc::VideoFrameMetadata *this)
{
  return *((unsigned int *)this + 9);
}

char *webrtc::VideoFrameMetadata::GetFrameDependencies(webrtc::VideoFrameMetadata *this)
{
  char *v1;
  char *v2;
  char *v3;
  unint64_t v4;

  v3 = (char *)*((_QWORD *)this + 6);
  v1 = (char *)this + 48;
  v2 = v3;
  v4 = *((_QWORD *)v1 - 1);
  if ((v4 & 1) == 0)
    v2 = v1;
  if (v4 >= 2)
    return v2;
  else
    return 0;
}

void webrtc::internal::VideoQualityObserver::UpdateHistograms(int64x2_t *this, int a2)
{
  char v2;
  uint64_t v4;
  uint64_t v5;
  int64x2_t v6;
  const char *v7;
  size_t v8;
  char *p_src;
  uint64_t v10;
  int v11;
  size_t v12;
  unint64_t v13;
  uint64_t v14;
  char *p_p;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  size_t v20;
  const void *v21;
  size_t v22;
  size_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  size_t v29;
  unint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  size_t v37;
  const void *v38;
  size_t v39;
  size_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  size_t v47;
  unint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  size_t v55;
  const void *v56;
  size_t v57;
  size_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  size_t v63;
  unint64_t v64;
  uint64_t v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  char *v70;
  size_t v71;
  const void *v72;
  size_t v73;
  size_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  size_t v79;
  unint64_t v80;
  __int32 v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  char *v86;
  size_t v87;
  const void *v88;
  size_t v89;
  size_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  size_t v95;
  size_t v96;
  uint64_t v97;
  char *v98;
  uint64_t v99;
  uint64_t v100;
  char *v101;
  char *v102;
  size_t v103;
  const void *v104;
  size_t v105;
  size_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  double v110;
  int v111;
  size_t v112;
  unint64_t v113;
  char *v114;
  uint64_t v115;
  uint64_t v116;
  char *v117;
  char *v118;
  size_t v119;
  const void *v120;
  unsigned int v121;
  size_t v122;
  size_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  void *__p;
  size_t v135;
  unint64_t v136;
  void *__src;
  __int128 v138;
  char *v139;
  __int128 v140;
  char v141;
  uint64_t v142;

  v142 = *MEMORY[0x24BDAC8D0];
  if (!this->i64[1])
    return;
  v2 = a2;
  v139 = &v141;
  v140 = xmmword_208F08DE0;
  v141 = 0;
  v4 = this[2].i64[1];
  v5 = this->i64[0] - v4;
  if (this->i64[0] > v4)
  {
    v6 = vdupq_n_s64(1uLL);
    v6.i64[0] = (int)v5;
    this[10] = vaddq_s64(this[10], v6);
    if (!this[11].i8[4] || this[11].i32[0] < (int)v5)
    {
      this[11].i32[0] = v5;
      this[11].i8[4] = 1;
    }
    if (!this[11].i8[12] || this[11].i32[2] > (int)v5)
    {
      this[11].i32[2] = v5;
      this[11].i8[12] = 1;
    }
  }
  if (a2)
    v7 = "WebRTC.Video.Screenshare";
  else
    v7 = "WebRTC.Video";
  if (a2)
    v8 = 24;
  else
    v8 = 12;
  if ((a2 & 1) != 0)
  {
    p_src = (char *)operator new(0x20uLL);
    __src = p_src;
    v138 = xmmword_208F08630;
    if (p_src > v7)
      goto LABEL_20;
  }
  else
  {
    HIBYTE(v138) = 12;
    p_src = (char *)&__src;
    if (&__src > (void **)v7)
      goto LABEL_20;
  }
  if (&p_src[v8] > v7)
    goto LABEL_287;
LABEL_20:
  memcpy(p_src, v7, v8);
  p_src[v8] = 0;
  v10 = this[10].i64[1];
  if (v10 < 1)
    goto LABEL_58;
  v11 = SHIBYTE(v138);
  if (v138 >= 0)
    v12 = HIBYTE(v138);
  else
    v12 = v138;
  v13 = v12 + 25;
  if (v12 + 25 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_288;
  v14 = this[10].i64[0];
  if (v13 > 0x16)
  {
    v16 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v16 = v13 | 7;
    v17 = v16 + 1;
    p_p = (char *)operator new(v16 + 1);
    v135 = v12 + 25;
    v136 = v17 | 0x8000000000000000;
    __p = p_p;
  }
  else
  {
    v135 = 0;
    v136 = 0;
    __p = 0;
    p_p = (char *)&__p;
    HIBYTE(v136) = v12 + 25;
  }
  if (v11 >= 0)
    v18 = (char *)&__src;
  else
    v18 = (char *)__src;
  v19 = &p_p[v12];
  if (v18 >= p_p && v19 > v18)
    goto LABEL_287;
  if (v12)
    memmove(p_p, v18, v12);
  if (v19 <= ".MeanTimeBetweenFreezesMs" && v19 + 25 > ".MeanTimeBetweenFreezesMs")
    goto LABEL_287;
  strcpy(v19, ".MeanTimeBetweenFreezesMs");
  if (SHIBYTE(v136) < 0)
  {
    if ((v135 & 0x8000000000000000) != 0 || v135 && !__p)
      goto LABEL_287;
    operator delete(__p);
    LOBYTE(v11) = HIBYTE(v138);
    if ((HIBYTE(v138) & 0x80) == 0)
      goto LABEL_41;
LABEL_46:
    v20 = v138;
    if ((v138 & 0x8000000000000000) != 0)
      goto LABEL_287;
    v21 = __src;
    if ((_QWORD)v138)
    {
      if (!__src)
        goto LABEL_287;
    }
    goto LABEL_49;
  }
  if ((v11 & 0x80) != 0)
    goto LABEL_46;
LABEL_41:
  v20 = v11;
  v21 = &__src;
LABEL_49:
  if (v20 >= (_QWORD)v140 + ~*((_QWORD *)&v140 + 1))
    v22 = v140 + ~*((_QWORD *)&v140 + 1);
  else
    v22 = v20;
  memcpy(&v139[*((_QWORD *)&v140 + 1)], v21, v22);
  *((_QWORD *)&v140 + 1) += v22;
  v139[*((_QWORD *)&v140 + 1)] = 0;
  if ((_QWORD)v140 + ~*((_QWORD *)&v140 + 1) >= 0x1AuLL)
    v23 = 26;
  else
    v23 = v140 + ~*((_QWORD *)&v140 + 1);
  memcpy(&v139[*((_QWORD *)&v140 + 1)], ".MeanTimeBetweenFreezesMs ", v23);
  *((_QWORD *)&v140 + 1) += v23;
  v139[*((_QWORD *)&v140 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&v139, "%d", v14 / v10);
  v24 = v140;
  v25 = *((_QWORD *)&v140 + 1) + 1;
  memcpy(&v139[*((_QWORD *)&v140 + 1)], "\n", v140 != *((_QWORD *)&v140 + 1) + 1);
  v26 = *((_QWORD *)&v140 + 1);
  if (v24 != v25)
    v26 = *((_QWORD *)&v140 + 1) + 1;
  *((_QWORD *)&v140 + 1) = v26;
  v139[v26] = 0;
LABEL_58:
  v27 = this[6].i64[1];
  if (v27 < 1)
    goto LABEL_96;
  v28 = SHIBYTE(v138);
  if (v138 >= 0)
    v29 = HIBYTE(v138);
  else
    v29 = v138;
  v30 = v29 + 21;
  if (v29 + 21 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_288;
  v31 = this[6].i64[0];
  if (v30 > 0x16)
  {
    v33 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v30 | 7) != 0x17)
      v33 = v30 | 7;
    v34 = v33 + 1;
    v32 = (char *)operator new(v33 + 1);
    v135 = v29 + 21;
    v136 = v34 | 0x8000000000000000;
    __p = v32;
  }
  else
  {
    v135 = 0;
    v136 = 0;
    __p = 0;
    v32 = (char *)&__p;
    HIBYTE(v136) = v29 + 21;
  }
  if (v28 >= 0)
    v35 = (char *)&__src;
  else
    v35 = (char *)__src;
  v36 = &v32[v29];
  if (v35 >= v32 && v36 > v35)
    goto LABEL_287;
  if (v29)
    memmove(v32, v35, v29);
  if (v36 <= ".MeanFreezeDurationMs" && v36 + 21 > ".MeanFreezeDurationMs")
    goto LABEL_287;
  strcpy(v36, ".MeanFreezeDurationMs");
  if (SHIBYTE(v136) < 0)
  {
    if ((v135 & 0x8000000000000000) != 0 || v135 && !__p)
      goto LABEL_287;
    operator delete(__p);
    LOBYTE(v28) = HIBYTE(v138);
    if ((HIBYTE(v138) & 0x80) == 0)
      goto LABEL_79;
LABEL_84:
    v37 = v138;
    if ((v138 & 0x8000000000000000) != 0)
      goto LABEL_287;
    v38 = __src;
    if ((_QWORD)v138)
    {
      if (!__src)
        goto LABEL_287;
    }
    goto LABEL_87;
  }
  if ((v28 & 0x80) != 0)
    goto LABEL_84;
LABEL_79:
  v37 = v28;
  v38 = &__src;
LABEL_87:
  if (v37 >= (_QWORD)v140 + ~*((_QWORD *)&v140 + 1))
    v39 = v140 + ~*((_QWORD *)&v140 + 1);
  else
    v39 = v37;
  memcpy(&v139[*((_QWORD *)&v140 + 1)], v38, v39);
  *((_QWORD *)&v140 + 1) += v39;
  v139[*((_QWORD *)&v140 + 1)] = 0;
  if ((_QWORD)v140 + ~*((_QWORD *)&v140 + 1) >= 0x16uLL)
    v40 = 22;
  else
    v40 = v140 + ~*((_QWORD *)&v140 + 1);
  memcpy(&v139[*((_QWORD *)&v140 + 1)], ".MeanFreezeDurationMs ", v40);
  *((_QWORD *)&v140 + 1) += v40;
  v139[*((_QWORD *)&v140 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&v139, "%d", v31 / v27);
  v41 = v140;
  v42 = *((_QWORD *)&v140 + 1) + 1;
  memcpy(&v139[*((_QWORD *)&v140 + 1)], "\n", v140 != *((_QWORD *)&v140 + 1) + 1);
  v43 = *((_QWORD *)&v140 + 1);
  if (v41 != v42)
    v43 = *((_QWORD *)&v140 + 1) + 1;
  *((_QWORD *)&v140 + 1) = v43;
  v139[v43] = 0;
LABEL_96:
  v44 = this->i64[0] - this[1].i64[0];
  if (v44 >= 3000)
  {
    v45 = this[12].i64[0];
    if ((unint64_t)(this[12].i64[1] - v45) <= 0x10)
      goto LABEL_287;
    v46 = SHIBYTE(v138);
    if (v138 >= 0)
      v47 = HIBYTE(v138);
    else
      v47 = v138;
    v48 = v47 + 19;
    if (v47 + 19 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_288;
    v49 = *(_QWORD *)(v45 + 16);
    if (v48 > 0x16)
    {
      v51 = (v48 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v48 | 7) != 0x17)
        v51 = v48 | 7;
      v52 = v51 + 1;
      v50 = (char *)operator new(v51 + 1);
      v135 = v47 + 19;
      v136 = v52 | 0x8000000000000000;
      __p = v50;
    }
    else
    {
      v135 = 0;
      v136 = 0;
      __p = 0;
      v50 = (char *)&__p;
      HIBYTE(v136) = v47 + 19;
    }
    if (v46 >= 0)
      v53 = (char *)&__src;
    else
      v53 = (char *)__src;
    v54 = &v50[v47];
    if (v53 >= v50 && v54 > v53)
      goto LABEL_287;
    if (v47)
      memmove(v50, v53, v47);
    if (v54 <= ".TimeInHdPercentage" && v54 + 19 > ".TimeInHdPercentage")
      goto LABEL_287;
    strcpy(v54, ".TimeInHdPercentage");
    if (SHIBYTE(v136) < 0)
    {
      if ((v135 & 0x8000000000000000) != 0 || v135 && !__p)
        goto LABEL_287;
      operator delete(__p);
      LOBYTE(v46) = HIBYTE(v138);
      if ((HIBYTE(v138) & 0x80) == 0)
        goto LABEL_118;
    }
    else if ((v46 & 0x80) == 0)
    {
LABEL_118:
      v55 = v46;
      v56 = &__src;
      goto LABEL_126;
    }
    v55 = v138;
    if ((v138 & 0x8000000000000000) != 0)
      goto LABEL_287;
    v56 = __src;
    if ((_QWORD)v138)
    {
      if (!__src)
        goto LABEL_287;
    }
LABEL_126:
    if (v55 >= (_QWORD)v140 + ~*((_QWORD *)&v140 + 1))
      v57 = v140 + ~*((_QWORD *)&v140 + 1);
    else
      v57 = v55;
    memcpy(&v139[*((_QWORD *)&v140 + 1)], v56, v57);
    *((_QWORD *)&v140 + 1) += v57;
    v139[*((_QWORD *)&v140 + 1)] = 0;
    if ((_QWORD)v140 + ~*((_QWORD *)&v140 + 1) >= 0x14uLL)
      v58 = 20;
    else
      v58 = v140 + ~*((_QWORD *)&v140 + 1);
    memcpy(&v139[*((_QWORD *)&v140 + 1)], ".TimeInHdPercentage ", v58);
    *((_QWORD *)&v140 + 1) += v58;
    v139[*((_QWORD *)&v140 + 1)] = 0;
    rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&v139, "%d", 100 * v49 / v44);
    v59 = v140;
    v60 = *((_QWORD *)&v140 + 1) + 1;
    memcpy(&v139[*((_QWORD *)&v140 + 1)], "\n", v140 != *((_QWORD *)&v140 + 1) + 1);
    v61 = *((_QWORD *)&v140 + 1);
    if (v59 != v60)
      v61 = *((_QWORD *)&v140 + 1) + 1;
    *((_QWORD *)&v140 + 1) = v61;
    v139[v61] = 0;
    v62 = SHIBYTE(v138);
    if (v138 >= 0)
      v63 = HIBYTE(v138);
    else
      v63 = v138;
    v64 = v63 + 28;
    if (v63 + 28 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_288;
    v65 = this[14].i64[0];
    if (v64 > 0x16)
    {
      v67 = (v64 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v64 | 7) != 0x17)
        v67 = v64 | 7;
      v68 = v67 + 1;
      v66 = (char *)operator new(v67 + 1);
      v135 = v63 + 28;
      v136 = v68 | 0x8000000000000000;
      __p = v66;
    }
    else
    {
      v135 = 0;
      v136 = 0;
      __p = 0;
      v66 = (char *)&__p;
      HIBYTE(v136) = v63 + 28;
    }
    if (v62 >= 0)
      v69 = (char *)&__src;
    else
      v69 = (char *)__src;
    v70 = &v66[v63];
    if (v69 >= v66 && v70 > v69)
      goto LABEL_287;
    if (v63)
      memmove(v66, v69, v63);
    if (v70 <= ".TimeInBlockyVideoPercentage" && v70 + 28 > ".TimeInBlockyVideoPercentage")
      goto LABEL_287;
    strcpy(v70, ".TimeInBlockyVideoPercentage");
    if (SHIBYTE(v136) < 0)
    {
      if ((v135 & 0x8000000000000000) != 0 || v135 && !__p)
        goto LABEL_287;
      operator delete(__p);
      LOBYTE(v62) = HIBYTE(v138);
      if ((HIBYTE(v138) & 0x80) == 0)
        goto LABEL_154;
    }
    else if ((v62 & 0x80) == 0)
    {
LABEL_154:
      v71 = v62;
      v72 = &__src;
      goto LABEL_162;
    }
    v71 = v138;
    if ((v138 & 0x8000000000000000) != 0)
      goto LABEL_287;
    v72 = __src;
    if ((_QWORD)v138)
    {
      if (!__src)
        goto LABEL_287;
    }
LABEL_162:
    if (v71 >= (_QWORD)v140 + ~*((_QWORD *)&v140 + 1))
      v73 = v140 + ~*((_QWORD *)&v140 + 1);
    else
      v73 = v71;
    memcpy(&v139[*((_QWORD *)&v140 + 1)], v72, v73);
    *((_QWORD *)&v140 + 1) += v73;
    v139[*((_QWORD *)&v140 + 1)] = 0;
    if ((_QWORD)v140 + ~*((_QWORD *)&v140 + 1) >= 0x1DuLL)
      v74 = 29;
    else
      v74 = v140 + ~*((_QWORD *)&v140 + 1);
    memcpy(&v139[*((_QWORD *)&v140 + 1)], ".TimeInBlockyVideoPercentage ", v74);
    *((_QWORD *)&v140 + 1) += v74;
    v139[*((_QWORD *)&v140 + 1)] = 0;
    rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&v139, "%d", 100 * v65 / v44);
    v75 = v140;
    v76 = *((_QWORD *)&v140 + 1) + 1;
    memcpy(&v139[*((_QWORD *)&v140 + 1)], "\n", v140 != *((_QWORD *)&v140 + 1) + 1);
    v77 = *((_QWORD *)&v140 + 1);
    if (v75 != v76)
      v77 = *((_QWORD *)&v140 + 1) + 1;
    *((_QWORD *)&v140 + 1) = v77;
    v139[v77] = 0;
    if ((v2 & 1) != 0)
    {
LABEL_208:
      v94 = SHIBYTE(v138);
      if (v138 >= 0)
        v95 = HIBYTE(v138);
      else
        v95 = v138;
      v96 = v95 + 23;
      if (v95 + 23 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_288;
      v97 = this[6].i64[1];
      if (v95 < 0xFFFFFFFFFFFFFFE9)
      {
        v99 = (v96 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v96 | 7) != 0x17)
          v99 = v96 | 7;
        v100 = v99 + 1;
        v98 = (char *)operator new(v99 + 1);
        v135 = v95 + 23;
        v136 = v100 | 0x8000000000000000;
        __p = v98;
      }
      else
      {
        v135 = 0;
        v136 = 0;
        __p = 0;
        v98 = (char *)&__p;
        HIBYTE(v136) = v95 + 23;
      }
      if (v94 >= 0)
        v101 = (char *)&__src;
      else
        v101 = (char *)__src;
      v102 = &v98[v95];
      if (v101 >= v98 && v102 > v101)
        goto LABEL_287;
      if (v95)
        memmove(v98, v101, v95);
      if (v102 <= ".NumberFreezesPerMinute" && v102 + 23 > ".NumberFreezesPerMinute")
        goto LABEL_287;
      strcpy(v102, ".NumberFreezesPerMinute");
      if (SHIBYTE(v136) < 0)
      {
        if ((v135 & 0x8000000000000000) != 0 || v135 && !__p)
          goto LABEL_287;
        operator delete(__p);
        LOBYTE(v94) = HIBYTE(v138);
        if ((HIBYTE(v138) & 0x80) == 0)
          goto LABEL_228;
      }
      else if ((v94 & 0x80) == 0)
      {
LABEL_228:
        v103 = v94;
        v104 = &__src;
        goto LABEL_236;
      }
      v103 = v138;
      if ((v138 & 0x8000000000000000) != 0)
        goto LABEL_287;
      v104 = __src;
      if ((_QWORD)v138)
      {
        if (!__src)
          goto LABEL_287;
      }
LABEL_236:
      if (v103 >= (_QWORD)v140 + ~*((_QWORD *)&v140 + 1))
        v105 = v140 + ~*((_QWORD *)&v140 + 1);
      else
        v105 = v103;
      memcpy(&v139[*((_QWORD *)&v140 + 1)], v104, v105);
      *((_QWORD *)&v140 + 1) += v105;
      v139[*((_QWORD *)&v140 + 1)] = 0;
      if ((_QWORD)v140 + ~*((_QWORD *)&v140 + 1) >= 0x18uLL)
        v106 = 24;
      else
        v106 = v140 + ~*((_QWORD *)&v140 + 1);
      memcpy(&v139[*((_QWORD *)&v140 + 1)], ".NumberFreezesPerMinute ", v106);
      *((_QWORD *)&v140 + 1) += v106;
      v139[*((_QWORD *)&v140 + 1)] = 0;
      rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&v139, "%d", 60000 * v97 / v44);
      v107 = v140;
      v108 = *((_QWORD *)&v140 + 1) + 1;
      memcpy(&v139[*((_QWORD *)&v140 + 1)], "\n", v140 != *((_QWORD *)&v140 + 1) + 1);
      v109 = *((_QWORD *)&v140 + 1);
      if (v107 != v108)
        v109 = *((_QWORD *)&v140 + 1) + 1;
      *((_QWORD *)&v140 + 1) = v109;
      v139[v109] = 0;
      v110 = *(double *)&this[5].i64[1];
      if (v110 <= 0.0)
        goto LABEL_282;
      v111 = SHIBYTE(v138);
      if (v138 >= 0)
        v112 = HIBYTE(v138);
      else
        v112 = v138;
      v113 = v112 + 18;
      if (v112 + 18 <= 0x7FFFFFFFFFFFFFF7)
      {
        if (v113 > 0x16)
        {
          v115 = (v113 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v113 | 7) != 0x17)
            v115 = v113 | 7;
          v116 = v115 + 1;
          v114 = (char *)operator new(v115 + 1);
          v135 = v112 + 18;
          v136 = v116 | 0x8000000000000000;
          __p = v114;
        }
        else
        {
          v135 = 0;
          v136 = 0;
          __p = 0;
          v114 = (char *)&__p;
          HIBYTE(v136) = v112 + 18;
        }
        if (v111 >= 0)
          v117 = (char *)&__src;
        else
          v117 = (char *)__src;
        v118 = &v114[v112];
        if (v117 < v114 || v118 <= v117)
        {
          if (v112)
            memmove(v114, v117, v112);
          if (v118 > ".HarmonicFrameRate" || v118 + 18 <= ".HarmonicFrameRate")
          {
            strcpy(v118, ".HarmonicFrameRate");
            if ((SHIBYTE(v136) & 0x80000000) == 0)
            {
              if ((v111 & 0x80) == 0)
              {
LABEL_265:
                v119 = v111;
                v120 = &__src;
                goto LABEL_273;
              }
              goto LABEL_270;
            }
            if ((v135 & 0x8000000000000000) == 0 && (!v135 || __p))
            {
              operator delete(__p);
              LOBYTE(v111) = HIBYTE(v138);
              if ((HIBYTE(v138) & 0x80) == 0)
                goto LABEL_265;
LABEL_270:
              v119 = v138;
              if ((v138 & 0x8000000000000000) == 0)
              {
                v120 = __src;
                if (!(_QWORD)v138 || __src)
                {
LABEL_273:
                  v121 = llround((double)v44 / (v110 * 1000.0));
                  if (v119 >= (_QWORD)v140 + ~*((_QWORD *)&v140 + 1))
                    v122 = v140 + ~*((_QWORD *)&v140 + 1);
                  else
                    v122 = v119;
                  memcpy(&v139[*((_QWORD *)&v140 + 1)], v120, v122);
                  *((_QWORD *)&v140 + 1) += v122;
                  v139[*((_QWORD *)&v140 + 1)] = 0;
                  if ((_QWORD)v140 + ~*((_QWORD *)&v140 + 1) >= 0x13uLL)
                    v123 = 19;
                  else
                    v123 = v140 + ~*((_QWORD *)&v140 + 1);
                  memcpy(&v139[*((_QWORD *)&v140 + 1)], ".HarmonicFrameRate ", v123);
                  *((_QWORD *)&v140 + 1) += v123;
                  v139[*((_QWORD *)&v140 + 1)] = 0;
                  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&v139, "%d", v121);
                  v124 = v140;
                  v125 = *((_QWORD *)&v140 + 1) + 1;
                  memcpy(&v139[*((_QWORD *)&v140 + 1)], "\n", v140 != *((_QWORD *)&v140 + 1) + 1);
                  v126 = *((_QWORD *)&v140 + 1);
                  if (v124 != v125)
                    v126 = *((_QWORD *)&v140 + 1) + 1;
                  *((_QWORD *)&v140 + 1) = v126;
                  v139[v126] = 0;
                  goto LABEL_282;
                }
              }
            }
          }
        }
LABEL_287:
        __break(1u);
      }
LABEL_288:
      abort();
    }
    v78 = SHIBYTE(v138);
    if (v138 >= 0)
      v79 = HIBYTE(v138);
    else
      v79 = v138;
    v80 = v79 + 38;
    if (v79 + 38 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_288;
    v81 = this[13].i32[3];
    if (v80 > 0x16)
    {
      v83 = (v80 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v80 | 7) != 0x17)
        v83 = v80 | 7;
      v84 = v83 + 1;
      v82 = (char *)operator new(v83 + 1);
      v135 = v79 + 38;
      v136 = v84 | 0x8000000000000000;
      __p = v82;
    }
    else
    {
      v135 = 0;
      v136 = 0;
      __p = 0;
      v82 = (char *)&__p;
      HIBYTE(v136) = v79 + 38;
    }
    if (v78 >= 0)
      v85 = (char *)&__src;
    else
      v85 = (char *)__src;
    v86 = &v82[v79];
    if (v85 >= v82 && v86 > v85)
      goto LABEL_287;
    if (v79)
      memmove(v82, v85, v79);
    if (v86 <= ".NumberResolutionDownswitchesPerMinute" && v86 + 38 > ".NumberResolutionDownswitchesPerMinute")
      goto LABEL_287;
    strcpy(v86, ".NumberResolutionDownswitchesPerMinute");
    if (SHIBYTE(v136) < 0)
    {
      if ((v135 & 0x8000000000000000) != 0 || v135 && !__p)
        goto LABEL_287;
      operator delete(__p);
      LOBYTE(v78) = HIBYTE(v138);
      if ((HIBYTE(v138) & 0x80) == 0)
        goto LABEL_191;
    }
    else if ((v78 & 0x80) == 0)
    {
LABEL_191:
      v87 = v78;
      v88 = &__src;
LABEL_199:
      if (v87 >= (_QWORD)v140 + ~*((_QWORD *)&v140 + 1))
        v89 = v140 + ~*((_QWORD *)&v140 + 1);
      else
        v89 = v87;
      memcpy(&v139[*((_QWORD *)&v140 + 1)], v88, v89);
      *((_QWORD *)&v140 + 1) += v89;
      v139[*((_QWORD *)&v140 + 1)] = 0;
      if ((_QWORD)v140 + ~*((_QWORD *)&v140 + 1) >= 0x27uLL)
        v90 = 39;
      else
        v90 = v140 + ~*((_QWORD *)&v140 + 1);
      memcpy(&v139[*((_QWORD *)&v140 + 1)], ".NumberResolutionDownswitchesPerMinute ", v90);
      *((_QWORD *)&v140 + 1) += v90;
      v139[*((_QWORD *)&v140 + 1)] = 0;
      rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&v139, "%d", 60000 * v81 / v44);
      v91 = v140;
      v92 = *((_QWORD *)&v140 + 1) + 1;
      memcpy(&v139[*((_QWORD *)&v140 + 1)], "\n", v140 != *((_QWORD *)&v140 + 1) + 1);
      v93 = *((_QWORD *)&v140 + 1);
      if (v91 != v92)
        v93 = *((_QWORD *)&v140 + 1) + 1;
      *((_QWORD *)&v140 + 1) = v93;
      v139[v93] = 0;
      goto LABEL_208;
    }
    v87 = v138;
    if ((v138 & 0x8000000000000000) != 0)
      goto LABEL_287;
    v88 = __src;
    if ((_QWORD)v138)
    {
      if (!__src)
        goto LABEL_287;
    }
    goto LABEL_199;
  }
LABEL_282:
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t", v127, v128, v129, v130, v131, v132, v133, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/video_quality_observer2.cc");
  if (SHIBYTE(v138) < 0)
    operator delete(__src);
}

void webrtc::internal::VideoQualityObserver::OnRenderedFrame(int64x2_t *a1, unsigned int *a2)
{
  uint64_t v3;
  uint64_t *v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  BOOL v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  int64x2_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  int v36;
  int64x2_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int64x2_t v45;
  uint64_t v46;
  int64x2_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t *v57;
  uint64_t *v58;
  uint64_t *v59;
  BOOL v60;
  uint64_t *v61;
  uint64_t *v62;
  uint64_t *v63;
  uint64_t *v64;

  v3 = a1->i64[1];
  if (v3)
  {
    v4 = &a1[15].i64[1];
    v5 = (_QWORD *)a1[15].i64[1];
    if (!v5)
    {
LABEL_22:
      v11 = v4;
      goto LABEL_23;
    }
  }
  else
  {
    v6 = *((_QWORD *)a2 + 4);
    v7 = v6 / 0x3E8uLL;
    if (v6 % 0x3E8uLL > 0x1F3)
      ++v7;
    if (-v6 % 0x3E8uLL <= 0x1F4)
      v8 = 0;
    else
      v8 = -1;
    if (v6 < 0)
      v9 = v8 - -v6 / 0x3E8uLL;
    else
      v9 = v7;
    a1[2].i64[1] = v9;
    a1[1].i64[0] = v9;
    v4 = &a1[15].i64[1];
    v5 = (_QWORD *)a1[15].i64[1];
    if (!v5)
      goto LABEL_22;
  }
  v10 = *a2;
  v11 = v4;
  do
  {
    v12 = v5[4];
    v13 = v12 < v10;
    if (v12 >= v10)
      v14 = v5;
    else
      v14 = v5 + 1;
    if (!v13)
      v11 = v5;
    v5 = (_QWORD *)*v14;
  }
  while (*v14);
  if (v11 == v4 || v11[4] > v10)
    goto LABEL_22;
LABEL_23:
  if (v3 < 1)
  {
    if (!a1[14].i8[8])
      goto LABEL_88;
    goto LABEL_36;
  }
  v15 = *((_QWORD *)a2 + 4);
  v16 = v15 / 0x3E8uLL;
  if (v15 % 0x3E8uLL > 0x1F3)
    ++v16;
  if (-v15 % 0x3E8uLL <= 0x1F4)
    v17 = 0;
  else
    v17 = -1;
  if (v15 < 0)
    v18 = v17 - -v15 / 0x3E8uLL;
  else
    v18 = v16;
  v19 = a1->i64[0];
  v20 = v18 - a1->i64[0];
  *(double *)&a1[5].i64[1] = *(double *)&a1[5].i64[1] + (double)v20 / 1000.0 * ((double)v20 / 1000.0);
  if (a1[14].i8[8])
  {
LABEL_36:
    a1[14].i8[8] = 0;
    v26 = a1->i64[0];
    v27 = a1[2].i64[1];
    v28 = __OFSUB__(a1->i64[0], v27);
    v29 = a1->i64[0] - v27;
    if (!((v29 < 0) ^ v28 | (v29 == 0)))
    {
      v30 = vdupq_n_s64(1uLL);
      v30.i64[0] = (int)v29;
      a1[10] = vaddq_s64(a1[10], v30);
      if (!a1[11].i8[4] || a1[11].i32[0] < (int)v29)
      {
        a1[11].i32[0] = v29;
        a1[11].i8[4] = 1;
      }
      if (!a1[11].i8[12] || a1[11].i32[2] > (int)v29)
      {
        a1[11].i32[2] = v29;
        a1[11].i8[12] = 1;
      }
    }
    v31 = *((_QWORD *)a2 + 4);
    if ((v31 & 0x8000000000000000) != 0)
    {
      v33 = -(uint64_t)v31;
      v34 = v33 / 0x3E8;
      if (v33 % 0x3E8 <= 0x1F4)
        v35 = 0;
      else
        v35 = -1;
      v32 = v35 - v34;
      a1[2].i64[1] = v32;
      if (a1->i64[1] <= 0)
        goto LABEL_88;
    }
    else
    {
      if (v31 % 0x3E8 <= 0x1F3)
        v32 = v31 / 0x3E8;
      else
        v32 = v31 / 0x3E8 + 1;
      a1[2].i64[1] = v32;
      if (a1->i64[1] < 1)
        goto LABEL_88;
    }
    v36 = v32 - v26;
    v37 = vdupq_n_s64(1uLL);
    v37.i64[0] = v36;
    a1[8] = vaddq_s64(v37, a1[8]);
    if (!a1[9].i8[4] || a1[9].i32[0] < v36)
    {
      a1[9].i32[0] = v36;
      a1[9].i8[4] = 1;
    }
    if (!a1[9].i8[12] || a1[9].i32[2] > v36)
    {
      a1[9].i32[2] = v36;
      a1[9].i8[12] = 1;
      v38 = (int)a2[7] * (uint64_t)(int)a2[6];
      if ((int)v38 < 518400)
        goto LABEL_95;
      goto LABEL_89;
    }
LABEL_88:
    v38 = (int)a2[7] * (uint64_t)(int)a2[6];
    if ((int)v38 < 518400)
      goto LABEL_95;
    goto LABEL_89;
  }
  v21 = a1[3].i64[0] + 1;
  a1[3].i64[0] = v21;
  v22 = a1[4].i64[0];
  v23 = (a1[4].i64[1] - v22) >> 2;
  v24 = v21 % v23;
  if (v21 <= v23)
    v25 = a1[3].i64[1];
  else
    v25 = a1[3].i64[1] - *(int *)(v22 + 4 * v24);
  v39 = v25 + (int)v20;
  a1[3].i64[1] = v39;
  *(_DWORD *)(v22 + 4 * v24) = v20;
  if (v23 < v21)
    v21 = v23;
  if (v21 < 5)
    goto LABEL_67;
  v40 = (int)(v39 / v21);
  v41 = 3 * v40;
  v42 = v40 + 150;
  if (v41 <= v42)
    v41 = v42;
  if (v20 < v41)
  {
LABEL_67:
    v43 = a1[13].u32[2];
    v44 = a1[12].i64[0];
    if (v43 >= (a1[12].i64[1] - v44) >> 3)
    {
      __break(1u);
      return;
    }
    *(_QWORD *)(v44 + 8 * v43) += v20;
    if (a1[2].i8[0])
    {
      a1[14].i64[0] += v20;
      v38 = (int)a2[7] * (uint64_t)(int)a2[6];
      if ((int)v38 < 518400)
        goto LABEL_95;
LABEL_89:
      a1[13].i32[2] = 2;
      if (a1[1].i64[1] <= v38)
        goto LABEL_100;
      goto LABEL_99;
    }
    goto LABEL_88;
  }
  v45 = vdupq_n_s64(1uLL);
  v45.i64[0] = (int)v20;
  a1[6] = vaddq_s64(a1[6], v45);
  if (!a1[7].i8[4] || a1[7].i32[0] < (int)v20)
  {
    a1[7].i32[0] = v20;
    a1[7].i8[4] = 1;
  }
  if (!a1[7].i8[12] || a1[7].i32[2] > (int)v20)
  {
    a1[7].i32[2] = v20;
    a1[7].i8[12] = 1;
  }
  v46 = v19 - a1[2].i64[1];
  v47 = vdupq_n_s64(1uLL);
  v47.i64[0] = (int)v46;
  a1[10] = vaddq_s64(v47, a1[10]);
  if (!a1[11].i8[4] || a1[11].i32[0] < (int)v46)
  {
    a1[11].i32[0] = v46;
    a1[11].i8[4] = 1;
  }
  if (!a1[11].i8[12] || a1[11].i32[2] > (int)v46)
  {
    a1[11].i32[2] = v46;
    a1[11].i8[12] = 1;
  }
  v48 = *((_QWORD *)a2 + 4);
  if ((v48 & 0x8000000000000000) == 0)
  {
    if (v48 % 0x3E8 <= 0x1F3)
      v49 = v48 / 0x3E8;
    else
      v49 = v48 / 0x3E8 + 1;
    a1[2].i64[1] = v49;
    goto LABEL_88;
  }
  v50 = -(uint64_t)v48;
  v51 = v50 / 0x3E8;
  if (v50 % 0x3E8 <= 0x1F4)
    v52 = 0;
  else
    v52 = -1;
  a1[2].i64[1] = v52 - v51;
  v38 = (int)a2[7] * (uint64_t)(int)a2[6];
  if ((int)v38 >= 518400)
    goto LABEL_89;
LABEL_95:
  if ((int)v38 >= 230400)
  {
    a1[13].i32[2] = 1;
    if (a1[1].i64[1] <= v38)
      goto LABEL_100;
    goto LABEL_99;
  }
  a1[13].i32[2] = 0;
  if (a1[1].i64[1] > v38)
LABEL_99:
    ++a1[13].i32[3];
LABEL_100:
  a1[1].i64[1] = v38;
  v53 = *((_QWORD *)a2 + 4);
  v54 = v53 / 0x3E8uLL;
  if (v53 % 0x3E8uLL > 0x1F3)
    ++v54;
  if (-v53 % 0x3E8uLL <= 0x1F4)
    v55 = 0;
  else
    v55 = -1;
  if (v53 < 0)
    v56 = v55 - -v53 / 0x3E8uLL;
  else
    v56 = v54;
  a1->i64[0] = v56;
  a1[2].i8[0] = v11 != v4;
  if (v11 != v4)
  {
    v57 = (uint64_t *)a1[15].i64[0];
    v58 = (uint64_t *)v11[1];
    if (v58)
    {
      do
      {
        v59 = v58;
        v58 = (uint64_t *)*v58;
      }
      while (v58);
    }
    else
    {
      do
      {
        v59 = (uint64_t *)v11[2];
        v60 = *v59 == (_QWORD)v11;
        v11 = v59;
      }
      while (!v60);
    }
    if (v57 != v59)
    {
      do
      {
        v62 = (uint64_t *)v57[1];
        v63 = v57;
        if (v62)
        {
          do
          {
            v64 = v62;
            v62 = (uint64_t *)*v62;
          }
          while (v62);
        }
        else
        {
          do
          {
            v64 = (uint64_t *)v63[2];
            v60 = *v64 == (_QWORD)v63;
            v63 = v64;
          }
          while (!v60);
        }
        if ((uint64_t *)a1[15].i64[0] == v57)
          a1[15].i64[0] = (uint64_t)v64;
        v61 = (uint64_t *)a1[15].i64[1];
        --a1[16].i64[0];
        std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v61, v57);
        operator delete(v57);
        v57 = v64;
      }
      while (v64 != v59);
    }
  }
  ++a1->i64[1];
}

void webrtc::internal::VideoQualityObserver::OnDecodedFrame(uint64_t a1, unsigned int a2, __int16 a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t *v17;
  uint64_t *v18;
  BOOL v19;
  uint64_t *v20;
  uint64_t **v21;
  uint64_t **v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v30;

  if ((a3 & 0xFF00) != 0)
  {
    if (a4 == 1)
    {
      if (a3 <= 0x46u)
        return;
    }
    else if (a4 != 2 || a3 <= 0xB4u)
    {
      return;
    }
    if (*(_QWORD *)(a1 + 256) >= 0x65uLL)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/video_quality_observer2.cc");
      v13 = *(uint64_t **)(a1 + 240);
      v14 = 50;
      v15 = v13;
      do
      {
        v17 = (uint64_t *)v15[1];
        v18 = v15;
        if (v17)
        {
          do
          {
            v15 = v17;
            v17 = (uint64_t *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            v15 = (uint64_t *)v18[2];
            v19 = *v15 == (_QWORD)v18;
            v18 = v15;
          }
          while (!v19);
        }
      }
      while (v14-- > 1);
      if (v13 != v15)
      {
        do
        {
          v24 = (uint64_t *)v13[1];
          v25 = v13;
          if (v24)
          {
            do
            {
              v26 = v24;
              v24 = (uint64_t *)*v24;
            }
            while (v24);
          }
          else
          {
            do
            {
              v26 = (uint64_t *)v25[2];
              v19 = *v26 == (_QWORD)v25;
              v25 = v26;
            }
            while (!v19);
          }
          if (*(uint64_t **)(a1 + 240) == v13)
            *(_QWORD *)(a1 + 240) = v26;
          v23 = *(uint64_t **)(a1 + 248);
          --*(_QWORD *)(a1 + 256);
          std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v23, v13);
          operator delete(v13);
          v13 = v26;
        }
        while (v26 != v15);
      }
    }
    v21 = (uint64_t **)(a1 + 248);
    v20 = *(uint64_t **)(a1 + 248);
    if (v20)
    {
      while (1)
      {
        while (1)
        {
          v22 = (uint64_t **)v20;
          v27 = v20[4];
          if (v27 <= a2)
            break;
          v20 = *v22;
          v21 = v22;
          if (!*v22)
            goto LABEL_35;
        }
        if (v27 >= a2)
          break;
        v20 = v22[1];
        if (!v20)
        {
          v21 = v22 + 1;
          goto LABEL_35;
        }
      }
    }
    else
    {
      v22 = (uint64_t **)(a1 + 248);
LABEL_35:
      v28 = (uint64_t *)operator new(0x28uLL);
      v28[4] = a2;
      *v28 = 0;
      v28[1] = 0;
      v28[2] = (uint64_t)v22;
      *v21 = v28;
      v29 = **(_QWORD **)(a1 + 240);
      if (v29)
      {
        *(_QWORD *)(a1 + 240) = v29;
        v30 = *v21;
      }
      else
      {
        v30 = v28;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 248), v30);
      ++*(_QWORD *)(a1 + 256);
    }
  }
}

char *webrtc::VideoReceiveStreamInterface::Stats::ToString@<X0>(webrtc::VideoReceiveStreamInterface::Stats *this@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  size_t v4;
  size_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  size_t v9;
  size_t v10;
  size_t v11;
  size_t v12;
  size_t v13;
  size_t v14;
  size_t v15;
  size_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  size_t v20;
  size_t v21;
  size_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  size_t v26;
  size_t v27;
  size_t v28;
  size_t v29;
  size_t v30;
  size_t v31;
  size_t v32;
  size_t v33;
  size_t v34;
  size_t v35;
  size_t v36;
  size_t v37;
  size_t v38;
  size_t v39;
  size_t v40;
  uint64_t v41;
  unint64_t v42;
  double v43;
  size_t v44;
  size_t v45;
  uint64_t v46;
  unint64_t v47;
  double v48;
  size_t v49;
  size_t v50;
  uint64_t v51;
  unint64_t v52;
  double v53;
  size_t v54;
  size_t v55;
  size_t v56;
  size_t v57;
  uint64_t v58;
  unint64_t v59;
  double v60;
  size_t v61;
  size_t v62;
  uint64_t v63;
  unint64_t v64;
  double v65;
  size_t v66;
  size_t v67;
  uint64_t v68;
  unint64_t v69;
  double v70;
  size_t v71;
  size_t v72;
  size_t v73;
  size_t v74;
  size_t v75;
  size_t v76;
  size_t v77;
  size_t v78;
  size_t v79;
  size_t v80;
  size_t v81;
  size_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  size_t v87;
  size_t v88;
  char *result;
  char *v90;
  uint64_t v91;
  uint64_t v92;
  char *__s;
  __int128 v95;
  char __src;
  char v97[2048];
  uint64_t v98;

  v98 = *MEMORY[0x24BDAC8D0];
  __s = v97;
  strcpy(v97, "VideoReceiveStreamInterface stats: ");
  v95 = xmmword_208F1D6F0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%lld", a2);
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 9uLL)
    v4 = 9;
  else
    v4 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", {ssrc: ", v4);
  *((_QWORD *)&v95 + 1) += v4;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *((_DWORD *)this + 67));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v5 = 2;
  else
    v5 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v5);
  *((_QWORD *)&v95 + 1) += v5;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xBuLL)
    v6 = 11;
  else
    v6 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "total_bps: ", v6);
  *((_QWORD *)&v95 + 1) += v6;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 53));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v7 = 2;
  else
    v7 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v7);
  *((_QWORD *)&v95 + 1) += v7;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xCuLL)
    v8 = 12;
  else
    v8 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "frameWidth: ", v8);
  *((_QWORD *)&v95 + 1) += v8;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 54));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v9 = 2;
  else
    v9 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v9);
  *((_QWORD *)&v95 + 1) += v9;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xDuLL)
    v10 = 13;
  else
    v10 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "frameHeight: ", v10);
  *((_QWORD *)&v95 + 1) += v10;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 55));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v11 = 2;
  else
    v11 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v11);
  *((_QWORD *)&v95 + 1) += v11;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 5uLL)
    v12 = 5;
  else
    v12 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "key: ", v12);
  *((_QWORD *)&v95 + 1) += v12;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 13));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v13 = 2;
  else
    v13 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v13);
  *((_QWORD *)&v95 + 1) += v13;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 7uLL)
    v14 = 7;
  else
    v14 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "delta: ", v14);
  *((_QWORD *)&v95 + 1) += v14;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 14));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v15 = 2;
  else
    v15 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v15);
  *((_QWORD *)&v95 + 1) += v15;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x24uLL)
    v16 = 36;
  else
    v16 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "framesAssembledFromMultiplePackets: ", v16);
  *((_QWORD *)&v95 + 1) += v16;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *((_DWORD *)this + 40));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v17 = 2;
  else
    v17 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v17);
  *((_QWORD *)&v95 + 1) += v17;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xFuLL)
    v18 = 15;
  else
    v18 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "framesDecoded: ", v18);
  *((_QWORD *)&v95 + 1) += v18;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *((_DWORD *)this + 33));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v19 = 2;
  else
    v19 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v19);
  *((_QWORD *)&v95 + 1) += v19;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xFuLL)
    v20 = 15;
  else
    v20 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "framesDropped: ", v20);
  *((_QWORD *)&v95 + 1) += v20;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *((_DWORD *)this + 32));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v21 = 2;
  else
    v21 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v21);
  *((_QWORD *)&v95 + 1) += v21;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xDuLL)
    v22 = 13;
  else
    v22 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "network_fps: ", v22);
  *((_QWORD *)&v95 + 1) += v22;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *(_DWORD *)this);
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v23 = 2;
  else
    v23 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v23);
  *((_QWORD *)&v95 + 1) += v23;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xCuLL)
    v24 = 12;
  else
    v24 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "decode_fps: ", v24);
  *((_QWORD *)&v95 + 1) += v24;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 1));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v25 = 2;
  else
    v25 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v25);
  *((_QWORD *)&v95 + 1) += v25;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xCuLL)
    v26 = 12;
  else
    v26 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "render_fps: ", v26);
  *((_QWORD *)&v95 + 1) += v26;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 2));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v27 = 2;
  else
    v27 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v27);
  *((_QWORD *)&v95 + 1) += v27;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xBuLL)
    v28 = 11;
  else
    v28 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "decode_ms: ", v28);
  *((_QWORD *)&v95 + 1) += v28;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 15));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v29 = 2;
  else
    v29 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v29);
  *((_QWORD *)&v95 + 1) += v29;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xFuLL)
    v30 = 15;
  else
    v30 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "max_decode_ms: ", v30);
  *((_QWORD *)&v95 + 1) += v30;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 16));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v31 = 2;
  else
    v31 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v31);
  *((_QWORD *)&v95 + 1) += v31;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x24uLL)
    v32 = 36;
  else
    v32 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "first_frame_received_to_decoded_ms: ", v32);
  *((_QWORD *)&v95 + 1) += v32;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%lld", *((_QWORD *)this + 23));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v33 = 2;
  else
    v33 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v33);
  *((_QWORD *)&v95 + 1) += v33;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x12uLL)
    v34 = 18;
  else
    v34 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "current_delay_ms: ", v34);
  *((_QWORD *)&v95 + 1) += v34;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 17));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v35 = 2;
  else
    v35 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v35);
  *((_QWORD *)&v95 + 1) += v35;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x11uLL)
    v36 = 17;
  else
    v36 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "target_delay_ms: ", v36);
  *((_QWORD *)&v95 + 1) += v36;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 18));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v37 = 2;
  else
    v37 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v37);
  *((_QWORD *)&v95 + 1) += v37;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x11uLL)
    v38 = 17;
  else
    v38 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "jitter_delay_ms: ", v38);
  *((_QWORD *)&v95 + 1) += v38;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 19));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v39 = 2;
  else
    v39 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v39);
  *((_QWORD *)&v95 + 1) += v39;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x13uLL)
    v40 = 19;
  else
    v40 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "totalAssemblyTime: ", v40);
  *((_QWORD *)&v95 + 1) += v40;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  v41 = *((_QWORD *)this + 19);
  if (v41 == 0x8000000000000000)
  {
    v42 = 0xFFF0000000000000;
    goto LABEL_116;
  }
  if (v41 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v42 = 0x7FF0000000000000;
LABEL_116:
    v43 = *(double *)&v42;
    goto LABEL_118;
  }
  v43 = (double)v41 * 0.000001;
LABEL_118:
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%g", v43);
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v44 = 2;
  else
    v44 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v44);
  *((_QWORD *)&v95 + 1) += v44;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x13uLL)
    v45 = 19;
  else
    v45 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "jitterBufferDelay: ", v45);
  *((_QWORD *)&v95 + 1) += v45;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  v46 = *((_QWORD *)this + 10);
  if (v46 == 0x8000000000000000)
  {
    v47 = 0xFFF0000000000000;
    goto LABEL_128;
  }
  if (v46 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v47 = 0x7FF0000000000000;
LABEL_128:
    v48 = *(double *)&v47;
    goto LABEL_130;
  }
  v48 = (double)v46 * 0.000001;
LABEL_130:
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%g", v48);
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v49 = 2;
  else
    v49 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v49);
  *((_QWORD *)&v95 + 1) += v49;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x19uLL)
    v50 = 25;
  else
    v50 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "jitterBufferTargetDelay: ", v50);
  *((_QWORD *)&v95 + 1) += v50;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  v51 = *((_QWORD *)this + 11);
  if (v51 == 0x8000000000000000)
  {
    v52 = 0xFFF0000000000000;
    goto LABEL_140;
  }
  if (v51 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v52 = 0x7FF0000000000000;
LABEL_140:
    v53 = *(double *)&v52;
    goto LABEL_142;
  }
  v53 = (double)v51 * 0.000001;
LABEL_142:
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%g", v53);
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v54 = 2;
  else
    v54 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v54);
  *((_QWORD *)&v95 + 1) += v54;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x1AuLL)
    v55 = 26;
  else
    v55 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "jitterBufferEmittedCount: ", v55);
  *((_QWORD *)&v95 + 1) += v55;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%llu", *((_QWORD *)this + 12));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v56 = 2;
  else
    v56 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v56);
  *((_QWORD *)&v95 + 1) += v56;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x1AuLL)
    v57 = 26;
  else
    v57 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "jitterBufferMinimumDelay: ", v57);
  *((_QWORD *)&v95 + 1) += v57;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  v58 = *((_QWORD *)this + 13);
  if (v58 == 0x8000000000000000)
  {
    v59 = 0xFFF0000000000000;
    goto LABEL_158;
  }
  if (v58 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v59 = 0x7FF0000000000000;
LABEL_158:
    v60 = *(double *)&v59;
    goto LABEL_160;
  }
  v60 = (double)v58 * 0.000001;
LABEL_160:
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%g", v60);
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v61 = 2;
  else
    v61 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v61);
  *((_QWORD *)&v95 + 1) += v61;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x11uLL)
    v62 = 17;
  else
    v62 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "totalDecodeTime: ", v62);
  *((_QWORD *)&v95 + 1) += v62;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  v63 = *((_QWORD *)this + 17);
  if (v63 == 0x8000000000000000)
  {
    v64 = 0xFFF0000000000000;
    goto LABEL_170;
  }
  if (v63 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v64 = 0x7FF0000000000000;
LABEL_170:
    v65 = *(double *)&v64;
    goto LABEL_172;
  }
  v65 = (double)v63 * 0.000001;
LABEL_172:
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%g", v65);
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v66 = 2;
  else
    v66 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v66);
  *((_QWORD *)&v95 + 1) += v66;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x16uLL)
    v67 = 22;
  else
    v67 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "totalProcessingDelay: ", v67);
  *((_QWORD *)&v95 + 1) += v67;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  v68 = *((_QWORD *)this + 18);
  if (v68 == 0x8000000000000000)
  {
    v69 = 0xFFF0000000000000;
    goto LABEL_182;
  }
  if (v68 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v69 = 0x7FF0000000000000;
LABEL_182:
    v70 = *(double *)&v69;
    goto LABEL_184;
  }
  v70 = (double)v68 * 0.000001;
LABEL_184:
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%g", v70);
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v71 = 2;
  else
    v71 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v71);
  *((_QWORD *)&v95 + 1) += v71;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x16uLL)
    v72 = 22;
  else
    v72 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "min_playout_delay_ms: ", v72);
  *((_QWORD *)&v95 + 1) += v72;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 28));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v73 = 2;
  else
    v73 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v73);
  *((_QWORD *)&v95 + 1) += v73;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0x10uLL)
    v74 = 16;
  else
    v74 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "sync_offset_ms: ", v74);
  *((_QWORD *)&v95 + 1) += v74;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 66));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v75 = 2;
  else
    v75 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v75);
  *((_QWORD *)&v95 + 1) += v75;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xAuLL)
    v76 = 10;
  else
    v76 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "cum_loss: ", v76);
  *((_QWORD *)&v95 + 1) += v76;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)this + 74));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v77 = 2;
  else
    v77 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v77);
  *((_QWORD *)&v95 + 1) += v77;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xBuLL)
    v78 = 11;
  else
    v78 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "nackCount: ", v78);
  *((_QWORD *)&v95 + 1) += v78;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *((_DWORD *)this + 92));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v79 = 2;
  else
    v79 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v79);
  *((_QWORD *)&v95 + 1) += v79;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xAuLL)
    v80 = 10;
  else
    v80 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "firCount: ", v80);
  *((_QWORD *)&v95 + 1) += v80;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *((_DWORD *)this + 93));
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 2uLL)
    v81 = 2;
  else
    v81 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], ", ", v81);
  *((_QWORD *)&v95 + 1) += v81;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  if ((_QWORD)v95 + ~*((_QWORD *)&v95 + 1) >= 0xAuLL)
    v82 = 10;
  else
    v82 = v95 + ~*((_QWORD *)&v95 + 1);
  memcpy(&__s[*((_QWORD *)&v95 + 1)], "pliCount: ", v82);
  *((_QWORD *)&v95 + 1) += v82;
  __s[*((_QWORD *)&v95 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *((_DWORD *)this + 94));
  __src = 125;
  v83 = v95;
  v84 = *((_QWORD *)&v95 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v95 + 1)], &__src, v95 != *((_QWORD *)&v95 + 1) + 1);
  v85 = *((_QWORD *)&v95 + 1);
  if (v83 != v84)
    v85 = *((_QWORD *)&v95 + 1) + 1;
  *((_QWORD *)&v95 + 1) = v85;
  __s[v85] = 0;
  v86 = __s;
  if (!__s)
  {
LABEL_234:
    __break(1u);
LABEL_235:
    abort();
  }
  v87 = strlen(__s);
  if (v87 >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_235;
  v88 = v87;
  if (v87 <= 0x16)
  {
    result = a3;
    a3[23] = v88;
    v90 = &a3[v88];
    if (a3 > v86)
      goto LABEL_231;
    goto LABEL_230;
  }
  v91 = (v87 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v87 | 7) != 0x17)
    v91 = v87 | 7;
  v92 = v91 + 1;
  result = (char *)operator new(v91 + 1);
  *((_QWORD *)a3 + 1) = v88;
  *((_QWORD *)a3 + 2) = v92 | 0x8000000000000000;
  *(_QWORD *)a3 = result;
  v90 = &result[v88];
  if (result <= v86)
  {
LABEL_230:
    if (v90 <= v86)
      goto LABEL_231;
    goto LABEL_234;
  }
LABEL_231:
  if (v88)
    result = (char *)memmove(result, v86, v88);
  *v90 = 0;
  return result;
}

webrtc::VideoReceiveStreamInterface::Config *webrtc::VideoReceiveStreamInterface::Config::Config(webrtc::VideoReceiveStreamInterface::Config *this, const webrtc::VideoReceiveStreamInterface::Config *a2)
{
  uint64_t v4;
  uint64_t v5;
  int64_t v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  std::string *v13;
  __int128 v14;
  void (***v15)(_QWORD);
  void (***v16)(_QWORD);

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v4 = *(_QWORD *)a2;
  v5 = *((_QWORD *)a2 + 1);
  v6 = v5 - *(_QWORD *)a2;
  if (v5 != *(_QWORD *)a2)
  {
    v7 = 0x4EC4EC4EC4EC4EC5 * (v6 >> 3);
    if (v7 >= 0x276276276276277)
      abort();
    v8 = (char *)operator new(v6);
    v9 = 0;
    *(_QWORD *)this = v8;
    *((_QWORD *)this + 1) = v8;
    *((_QWORD *)this + 2) = &v8[104 * v7];
    do
    {
      LODWORD(webrtc::SdpVideoFormat::SdpVideoFormat((std::string *)&v8[v9], (const webrtc::SdpVideoFormat *)(v4 + v9))[4].__r_.__value_.__l.__data_) = *(_DWORD *)(v4 + v9 + 96);
      v9 += 104;
    }
    while (v4 + v9 != v5);
    *((_QWORD *)this + 1) = &v8[v9];
  }
  *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
  *((_QWORD *)this + 4) = *((_QWORD *)a2 + 4);
  v10 = *(_OWORD *)((char *)a2 + 40);
  v11 = *(_OWORD *)((char *)a2 + 56);
  *((_QWORD *)this + 9) = *((_QWORD *)a2 + 9);
  *(_OWORD *)((char *)this + 56) = v11;
  *(_OWORD *)((char *)this + 40) = v10;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = (char *)this + 88;
  std::map<int,int>::insert[abi:sn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<int,int>,std::__tree_node<std::__value_type<int,int>,void *> *,long>>>((uint64_t *)this + 10, *((int **)a2 + 10), (int *)a2 + 22);
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 13) = (char *)this + 112;
  *((_QWORD *)this + 15) = 0;
  std::set<int>::insert[abi:sn180100]<std::__tree_const_iterator<int,std::__tree_node<int,void *> *,long>>((uint64_t *)this + 13, *((int **)a2 + 13), (int *)a2 + 28);
  v12 = *((_OWORD *)a2 + 8);
  *(_QWORD *)((char *)this + 141) = *(_QWORD *)((char *)a2 + 141);
  *((_OWORD *)this + 8) = v12;
  v13 = (std::string *)((char *)this + 152);
  if ((*((char *)a2 + 175) & 0x80000000) == 0)
  {
    v14 = *(_OWORD *)((char *)a2 + 152);
    *((_QWORD *)this + 21) = *((_QWORD *)a2 + 21);
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
    v15 = (void (***)(_QWORD))*((_QWORD *)a2 + 22);
    *((_QWORD *)this + 22) = v15;
    if (!v15)
      goto LABEL_9;
    goto LABEL_8;
  }
  std::string::__init_copy_ctor_external(v13, *((const std::string::value_type **)a2 + 19), *((_QWORD *)a2 + 20));
  v15 = (void (***)(_QWORD))*((_QWORD *)a2 + 22);
  *((_QWORD *)this + 22) = v15;
  if (v15)
LABEL_8:
    (**v15)(v15);
LABEL_9:
  *((_DWORD *)this + 46) = 65537;
  *((_BYTE *)this + 188) = 0;
  *((_DWORD *)this + 46) = *((_DWORD *)a2 + 46);
  *((_BYTE *)this + 188) = *((_BYTE *)a2 + 188);
  v16 = (void (***)(_QWORD))*((_QWORD *)a2 + 24);
  *((_QWORD *)this + 24) = v16;
  if (v16)
    (**v16)(v16);
  return this;
}

void webrtc::VideoReceiveStreamInterface::Config::~Config(webrtc::VideoReceiveStreamInterface::Config *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  v2 = *((_QWORD *)this + 24);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 22);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  if (*((char *)this + 175) < 0)
    operator delete(*((void **)this + 19));
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 104, *((_QWORD **)this + 14));
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 80, *((_QWORD **)this + 11));
  v4 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v5 = *((_QWORD *)this + 1);
    v6 = *(void **)this;
    if (v5 != v4)
    {
      do
      {
        while (1)
        {
          if ((*(_BYTE *)(v5 - 56) & 1) != 0)
            operator delete(*(void **)(v5 - 48));
          std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(v5 - 80, *(_QWORD *)(v5 - 72));
          if (*(char *)(v5 - 81) < 0)
            break;
          v5 -= 104;
          if (v5 == v4)
            goto LABEL_15;
        }
        operator delete(*(void **)(v5 - 104));
        v5 -= 104;
      }
      while (v5 != v4);
LABEL_15:
      v6 = *(void **)this;
    }
    *((_QWORD *)this + 1) = v4;
    operator delete(v6);
  }
}

char *webrtc::VideoReceiveStreamInterface::Config::ToString(webrtc::VideoReceiveStreamInterface::Config *this, uint64_t a2)
{
  _QWORD *v2;
  char *v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  size_t v10;
  const void *v11;
  BOOL v12;
  size_t v13;
  size_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  size_t v23;
  size_t v24;
  void **p_src;
  size_t v26;
  _QWORD *v27;
  size_t v28;
  size_t v29;
  size_t v30;
  _QWORD *v31;
  size_t v32;
  size_t v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  unint64_t v39;
  void **v40;
  _QWORD *v41;
  size_t v42;
  char *v43;
  unint64_t v44;
  size_t v45;
  uint64_t v46;
  _QWORD *v47;
  size_t v48;
  size_t v49;
  size_t v50;
  const char *v51;
  unint64_t v52;
  size_t v53;
  size_t v54;
  size_t v55;
  const char *v56;
  unint64_t v57;
  size_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  size_t v62;
  const char *v63;
  unint64_t v64;
  size_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  size_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  size_t v73;
  size_t v74;
  size_t v75;
  size_t v76;
  _QWORD *v77;
  size_t v78;
  size_t v79;
  _QWORD *v80;
  _QWORD *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  size_t v85;
  _QWORD *v86;
  _QWORD *v87;
  size_t v88;
  _QWORD *v89;
  _QWORD *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  size_t v98;
  size_t v99;
  void **v100;
  char *v101;
  uint64_t v102;
  uint64_t v103;
  size_t v104;
  void **v105;
  uint64_t v106;
  uint64_t v107;
  char *v108;
  size_t v109;
  size_t v110;
  char *v111;
  size_t v112;
  size_t v113;
  _QWORD *v114;
  uint64_t v115;
  const char *v116;
  unint64_t v117;
  size_t v118;
  size_t v119;
  size_t v120;
  _QWORD *v121;
  size_t v122;
  size_t v123;
  size_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  char *v128;
  size_t v129;
  size_t v130;
  char *result;
  char *v132;
  uint64_t v133;
  uint64_t v134;
  char *v135;
  _QWORD v136[2];
  _QWORD *v137;
  void **__src;
  size_t v139;
  unint64_t v140;
  char *v141;
  __int128 v142;
  char *__s;
  __int128 v144;
  char v145[4096];
  _QWORD v146[258];

  v2 = (_QWORD *)MEMORY[0x24BDAC7A8](this, a2);
  v146[256] = *MEMORY[0x24BDAC8D0];
  v3 = v145;
  v141 = v145;
  strcpy(v145, "{decoders: [");
  v142 = xmmword_208F1D700;
  v4 = *v2;
  v137 = v2;
  v135 = v5;
  if (v2[1] != *v2)
  {
    v6 = 0;
    v3 = v145;
    v7 = 12;
    qmemcpy(v136, "d_type: {payload", sizeof(v136));
    while (1)
    {
      v8 = v4 + 104 * v6;
      __s = (char *)v146;
      v146[0] = v136[1];
      *(_QWORD *)((char *)v146 + 7) = v136[0];
      v144 = xmmword_208F09F90;
      HIBYTE(v146[1]) = 0;
      rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *(_DWORD *)(v8 + 96));
      v9 = (_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0x10uLL ? 16 : v144 + ~*((_QWORD *)&v144 + 1);
      memcpy(&__s[*((_QWORD *)&v144 + 1)], ", payload_name: ", v9);
      *((_QWORD *)&v144 + 1) += v9;
      __s[*((_QWORD *)&v144 + 1)] = 0;
      if (*(char *)(v8 + 23) < 0)
      {
        v10 = *(_QWORD *)(v8 + 8);
        if ((v10 & 0x8000000000000000) != 0)
          goto LABEL_250;
        v11 = *(const void **)v8;
        v12 = v10 && v11 == 0;
        if (v12)
          goto LABEL_250;
      }
      else
      {
        v10 = *(unsigned __int8 *)(v8 + 23);
        v11 = (const void *)v8;
      }
      if (v10 >= (_QWORD)v144 + ~*((_QWORD *)&v144 + 1))
        v13 = v144 + ~*((_QWORD *)&v144 + 1);
      else
        v13 = v10;
      memcpy(&__s[*((_QWORD *)&v144 + 1)], v11, v13);
      *((_QWORD *)&v144 + 1) += v13;
      __s[*((_QWORD *)&v144 + 1)] = 0;
      if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0x11uLL)
        v14 = 17;
      else
        v14 = v144 + ~*((_QWORD *)&v144 + 1);
      memcpy(&__s[*((_QWORD *)&v144 + 1)], ", codec_params: {", v14);
      *((_QWORD *)&v144 + 1) += v14;
      __s[*((_QWORD *)&v144 + 1)] = 0;
      v15 = *(_QWORD **)(v8 + 24);
      if (v15 != (_QWORD *)(v8 + 32))
      {
        do
        {
          if (v15 != *(_QWORD **)(v8 + 24))
          {
            if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 2uLL)
              v26 = 2;
            else
              v26 = v144 + ~*((_QWORD *)&v144 + 1);
            memcpy(&__s[*((_QWORD *)&v144 + 1)], ", ", v26);
            *((_QWORD *)&v144 + 1) += v26;
            __s[*((_QWORD *)&v144 + 1)] = 0;
          }
          v27 = v15 + 4;
          if (*((char *)v15 + 55) < 0)
          {
            v28 = v15[5];
            if ((v28 & 0x8000000000000000) != 0)
              goto LABEL_250;
            v27 = (_QWORD *)*v27;
            if (v28)
            {
              if (!v27)
                goto LABEL_250;
            }
          }
          else
          {
            v28 = *((unsigned __int8 *)v15 + 55);
          }
          if (v28 >= (_QWORD)v144 + ~*((_QWORD *)&v144 + 1))
            v29 = v144 + ~*((_QWORD *)&v144 + 1);
          else
            v29 = v28;
          memcpy(&__s[*((_QWORD *)&v144 + 1)], v27, v29);
          *((_QWORD *)&v144 + 1) += v29;
          __s[*((_QWORD *)&v144 + 1)] = 0;
          if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 2uLL)
            v30 = 2;
          else
            v30 = v144 + ~*((_QWORD *)&v144 + 1);
          memcpy(&__s[*((_QWORD *)&v144 + 1)], ": ", v30);
          *((_QWORD *)&v144 + 1) += v30;
          __s[*((_QWORD *)&v144 + 1)] = 0;
          v31 = v15 + 7;
          if (*((char *)v15 + 79) < 0)
          {
            v32 = v15[8];
            if ((v32 & 0x8000000000000000) != 0)
              goto LABEL_250;
            v31 = (_QWORD *)*v31;
            if (v32)
            {
              if (!v31)
                goto LABEL_250;
            }
          }
          else
          {
            v32 = *((unsigned __int8 *)v15 + 79);
          }
          if (v32 >= (_QWORD)v144 + ~*((_QWORD *)&v144 + 1))
            v33 = v144 + ~*((_QWORD *)&v144 + 1);
          else
            v33 = v32;
          memcpy(&__s[*((_QWORD *)&v144 + 1)], v31, v33);
          *((_QWORD *)&v144 + 1) += v33;
          __s[*((_QWORD *)&v144 + 1)] = 0;
          v34 = (_QWORD *)v15[1];
          if (v34)
          {
            do
            {
              v35 = v34;
              v34 = (_QWORD *)*v34;
            }
            while (v34);
          }
          else
          {
            do
            {
              v35 = (_QWORD *)v15[2];
              v12 = *v35 == (_QWORD)v15;
              v15 = v35;
            }
            while (!v12);
          }
          v15 = v35;
        }
        while (v35 != (_QWORD *)(v8 + 32));
      }
      LOBYTE(__src) = 125;
      v16 = v144;
      v17 = *((_QWORD *)&v144 + 1) + 1;
      memcpy(&__s[*((_QWORD *)&v144 + 1)], &__src, v144 != *((_QWORD *)&v144 + 1) + 1);
      v18 = *((_QWORD *)&v144 + 1);
      if (v16 != v17)
        v18 = *((_QWORD *)&v144 + 1) + 1;
      *((_QWORD *)&v144 + 1) = v18;
      __s[v18] = 0;
      LOBYTE(__src) = 125;
      v19 = v144;
      v20 = *((_QWORD *)&v144 + 1) + 1;
      memcpy(&__s[*((_QWORD *)&v144 + 1)], &__src, v144 != *((_QWORD *)&v144 + 1) + 1);
      v21 = *((_QWORD *)&v144 + 1);
      if (v19 != v20)
        v21 = *((_QWORD *)&v144 + 1) + 1;
      *((_QWORD *)&v144 + 1) = v21;
      __s[v21] = 0;
      v22 = __s;
      if (!__s)
        goto LABEL_250;
      v23 = strlen(__s);
      if (v23 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_251;
      v24 = v23;
      if (v23 > 0x16)
      {
        v36 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v23 | 7) != 0x17)
          v36 = v23 | 7;
        v37 = v36 + 1;
        p_src = (void **)operator new(v36 + 1);
        v139 = v24;
        v140 = v37 | 0x8000000000000000;
        __src = p_src;
      }
      else
      {
        HIBYTE(v140) = v23;
        p_src = (void **)&__src;
      }
      v38 = (char *)p_src + v24;
      if (p_src <= (void **)v22 && v38 > v22)
        goto LABEL_250;
      if (v24)
        memmove(p_src, v22, v24);
      *v38 = 0;
      if (SHIBYTE(v140) < 0)
      {
        v39 = v139;
        v41 = v137;
        if ((v139 & 0x8000000000000000) != 0)
          goto LABEL_250;
        v40 = __src;
        if (v139)
        {
          if (!__src)
            goto LABEL_250;
        }
      }
      else
      {
        v39 = HIBYTE(v140);
        v40 = (void **)&__src;
        v41 = v137;
      }
      if (v39 >= 4095 - v7)
        v42 = 4095 - v7;
      else
        v42 = v39;
      memcpy(&v3[v7], v40, v42);
      v3 = v141;
      v7 = *((_QWORD *)&v142 + 1) + v42;
      *((_QWORD *)&v142 + 1) = v7;
      v43 = &v141[v7];
      v141[v7] = 0;
      if (SHIBYTE(v140) < 0)
        operator delete(__src);
      v4 = *v41;
      v44 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v41[1] - *v41) >> 3);
      if (v6 != v44 - 1)
      {
        if ((unint64_t)(4095 - v7) >= 2)
          v45 = 2;
        else
          v45 = 4095 - v7;
        memcpy(v43, ", ", v45);
        v7 += v45;
        *((_QWORD *)&v142 + 1) = v7;
        v3[v7] = 0;
        v4 = *v41;
        v44 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v41[1] - *v41) >> 3);
      }
      if (++v6 >= v44)
        goto LABEL_83;
    }
  }
  v41 = v2;
  v7 = 12;
LABEL_83:
  LOBYTE(v146[0]) = 93;
  if (v7 == 4095)
    v46 = 4095;
  else
    v46 = v7 + 1;
  v47 = v41;
  memcpy(&v3[v7], v146, v7 != 4095);
  v3[v46] = 0;
  if ((unint64_t)(4095 - v46) >= 7)
    v48 = 7;
  else
    v48 = 4095 - v46;
  memcpy(&v3[v46], ", rtp: ", v48);
  *((_QWORD *)&v142 + 1) = v46 + v48;
  v3[*((_QWORD *)&v142 + 1)] = 0;
  __s = (char *)v146;
  strcpy((char *)v146, "{remote_ssrc: ");
  v144 = xmmword_208F1D710;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *((_DWORD *)v41 + 8));
  if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0xEuLL)
    v49 = 14;
  else
    v49 = v144 + ~*((_QWORD *)&v144 + 1);
  memcpy(&__s[*((_QWORD *)&v144 + 1)], ", local_ssrc: ", v49);
  *((_QWORD *)&v144 + 1) += v49;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *((_DWORD *)v41 + 9));
  if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0xDuLL)
    v50 = 13;
  else
    v50 = v144 + ~*((_QWORD *)&v144 + 1);
  memcpy(&__s[*((_QWORD *)&v144 + 1)], ", rtcp_mode: ", v50);
  *((_QWORD *)&v144 + 1) += v50;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  if (*((_DWORD *)v41 + 11) == 1)
    v51 = "RtcpMode::kCompound";
  else
    v51 = "RtcpMode::kReducedSize";
  v52 = 19;
  if (*((_DWORD *)v41 + 11) != 1)
    v52 = 22;
  if (v52 >= (_QWORD)v144 + ~*((_QWORD *)&v144 + 1))
    v53 = v144 + ~*((_QWORD *)&v144 + 1);
  else
    v53 = v52;
  memcpy(&__s[*((_QWORD *)&v144 + 1)], v51, v53);
  *((_QWORD *)&v144 + 1) += v53;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0xBuLL)
    v54 = 11;
  else
    v54 = v144 + ~*((_QWORD *)&v144 + 1);
  memcpy(&__s[*((_QWORD *)&v144 + 1)], ", rtcp_xr: ", v54);
  *((_QWORD *)&v144 + 1) += v54;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0x21uLL)
    v55 = 33;
  else
    v55 = v144 + ~*((_QWORD *)&v144 + 1);
  memcpy(&__s[*((_QWORD *)&v144 + 1)], "{receiver_reference_time_report: ", v55);
  *((_QWORD *)&v144 + 1) += v55;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  if (*((_BYTE *)v41 + 48))
    v56 = "on";
  else
    v56 = "off";
  v57 = 2;
  if (!*((_BYTE *)v41 + 48))
    v57 = 3;
  if (v57 >= (_QWORD)v144 + ~*((_QWORD *)&v144 + 1))
    v58 = v144 + ~*((_QWORD *)&v144 + 1);
  else
    v58 = v57;
  memcpy(&__s[*((_QWORD *)&v144 + 1)], v56, v58);
  *((_QWORD *)&v144 + 1) += v58;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  LOBYTE(__src) = 125;
  v59 = v144;
  v60 = *((_QWORD *)&v144 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v144 + 1)], &__src, v144 != *((_QWORD *)&v144 + 1) + 1);
  v61 = *((_QWORD *)&v144 + 1);
  if (v59 != v60)
    v61 = *((_QWORD *)&v144 + 1) + 1;
  *((_QWORD *)&v144 + 1) = v61;
  __s[v61] = 0;
  if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0x12uLL)
    v62 = 18;
  else
    v62 = v144 + ~*((_QWORD *)&v144 + 1);
  memcpy(&__s[*((_QWORD *)&v144 + 1)], ", lntf: {enabled: ", v62);
  *((_QWORD *)&v144 + 1) += v62;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  if (*((_BYTE *)v47 + 50))
    v63 = "true";
  else
    v63 = "false";
  v64 = 4;
  if (!*((_BYTE *)v47 + 50))
    v64 = 5;
  if (v64 >= (_QWORD)v144 + ~*((_QWORD *)&v144 + 1))
    v65 = v144 + ~*((_QWORD *)&v144 + 1);
  else
    v65 = v64;
  memcpy(&__s[*((_QWORD *)&v144 + 1)], v63, v65);
  *((_QWORD *)&v144 + 1) += v65;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  LOBYTE(__src) = 125;
  v66 = v144;
  v67 = *((_QWORD *)&v144 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v144 + 1)], &__src, v144 != *((_QWORD *)&v144 + 1) + 1);
  v68 = *((_QWORD *)&v144 + 1);
  if (v66 != v67)
    v68 = *((_QWORD *)&v144 + 1) + 1;
  *((_QWORD *)&v144 + 1) = v68;
  __s[v68] = 0;
  if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0x19uLL)
    v69 = 25;
  else
    v69 = v144 + ~*((_QWORD *)&v144 + 1);
  memcpy(&__s[*((_QWORD *)&v144 + 1)], ", nack: {rtp_history_ms: ", v69);
  *((_QWORD *)&v144 + 1) += v69;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)v47 + 10));
  LOBYTE(__src) = 125;
  v70 = v144;
  v71 = *((_QWORD *)&v144 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v144 + 1)], &__src, v144 != *((_QWORD *)&v144 + 1) + 1);
  v72 = *((_QWORD *)&v144 + 1);
  if (v70 != v71)
    v72 = *((_QWORD *)&v144 + 1) + 1;
  *((_QWORD *)&v144 + 1) = v72;
  __s[v72] = 0;
  if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0x17uLL)
    v73 = 23;
  else
    v73 = v144 + ~*((_QWORD *)&v144 + 1);
  memcpy(&__s[*((_QWORD *)&v144 + 1)], ", ulpfec_payload_type: ", v73);
  *((_QWORD *)&v144 + 1) += v73;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)v47 + 13));
  if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0xCuLL)
    v74 = 12;
  else
    v74 = v144 + ~*((_QWORD *)&v144 + 1);
  memcpy(&__s[*((_QWORD *)&v144 + 1)], ", red_type: ", v74);
  *((_QWORD *)&v144 + 1) += v74;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)v47 + 14));
  if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0xCuLL)
    v75 = 12;
  else
    v75 = v144 + ~*((_QWORD *)&v144 + 1);
  memcpy(&__s[*((_QWORD *)&v144 + 1)], ", rtx_ssrc: ", v75);
  *((_QWORD *)&v144 + 1) += v75;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *((_DWORD *)v47 + 15));
  if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0x16uLL)
    v76 = 22;
  else
    v76 = v144 + ~*((_QWORD *)&v144 + 1);
  memcpy(&__s[*((_QWORD *)&v144 + 1)], ", rtx_payload_types: {", v76);
  *((_QWORD *)&v144 + 1) += v76;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  v77 = (_QWORD *)v47[10];
  if (v77 != v47 + 11)
  {
    do
    {
      rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)v77 + 7));
      if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 9uLL)
        v78 = 9;
      else
        v78 = v144 + ~*((_QWORD *)&v144 + 1);
      memcpy(&__s[*((_QWORD *)&v144 + 1)], " (pt) -> ", v78);
      *((_QWORD *)&v144 + 1) += v78;
      __s[*((_QWORD *)&v144 + 1)] = 0;
      rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)v77 + 8));
      if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 8uLL)
        v79 = 8;
      else
        v79 = v144 + ~*((_QWORD *)&v144 + 1);
      memcpy(&__s[*((_QWORD *)&v144 + 1)], " (apt), ", v79);
      *((_QWORD *)&v144 + 1) += v79;
      __s[*((_QWORD *)&v144 + 1)] = 0;
      v80 = (_QWORD *)v77[1];
      if (v80)
      {
        do
        {
          v81 = v80;
          v80 = (_QWORD *)*v80;
        }
        while (v80);
      }
      else
      {
        do
        {
          v81 = (_QWORD *)v77[2];
          v12 = *v81 == (_QWORD)v77;
          v77 = v81;
        }
        while (!v12);
      }
      v77 = v81;
    }
    while (v81 != v47 + 11);
  }
  LOBYTE(__src) = 125;
  v82 = v144;
  v83 = *((_QWORD *)&v144 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v144 + 1)], &__src, v144 != *((_QWORD *)&v144 + 1) + 1);
  v84 = *((_QWORD *)&v144 + 1);
  if (v82 != v83)
    v84 = *((_QWORD *)&v144 + 1) + 1;
  *((_QWORD *)&v144 + 1) = v84;
  __s[v84] = 0;
  if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 0x16uLL)
    v85 = 22;
  else
    v85 = v144 + ~*((_QWORD *)&v144 + 1);
  memcpy(&__s[*((_QWORD *)&v144 + 1)], ", raw_payload_types: {", v85);
  *((_QWORD *)&v144 + 1) += v85;
  __s[*((_QWORD *)&v144 + 1)] = 0;
  v86 = (_QWORD *)v137[13];
  v87 = v137 + 14;
  if (v86 != v137 + 14)
  {
    do
    {
      rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *((_DWORD *)v86 + 7));
      if ((_QWORD)v144 + ~*((_QWORD *)&v144 + 1) >= 2uLL)
        v88 = 2;
      else
        v88 = v144 + ~*((_QWORD *)&v144 + 1);
      memcpy(&__s[*((_QWORD *)&v144 + 1)], ", ", v88);
      *((_QWORD *)&v144 + 1) += v88;
      __s[*((_QWORD *)&v144 + 1)] = 0;
      v89 = (_QWORD *)v86[1];
      if (v89)
      {
        do
        {
          v90 = v89;
          v89 = (_QWORD *)*v89;
        }
        while (v89);
      }
      else
      {
        do
        {
          v90 = (_QWORD *)v86[2];
          v12 = *v90 == (_QWORD)v86;
          v86 = v90;
        }
        while (!v12);
      }
      v86 = v90;
    }
    while (v90 != v87);
  }
  LOBYTE(__src) = 125;
  v91 = v144;
  v92 = *((_QWORD *)&v144 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v144 + 1)], &__src, v144 != *((_QWORD *)&v144 + 1) + 1);
  v93 = *((_QWORD *)&v144 + 1);
  if (v91 != v92)
    v93 = *((_QWORD *)&v144 + 1) + 1;
  *((_QWORD *)&v144 + 1) = v93;
  __s[v93] = 0;
  LOBYTE(__src) = 125;
  v94 = v144;
  v95 = *((_QWORD *)&v144 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v144 + 1)], &__src, v144 != *((_QWORD *)&v144 + 1) + 1);
  v96 = *((_QWORD *)&v144 + 1);
  if (v94 != v95)
    v96 = *((_QWORD *)&v144 + 1) + 1;
  *((_QWORD *)&v144 + 1) = v96;
  __s[v96] = 0;
  v97 = __s;
  if (!__s)
    goto LABEL_250;
  v98 = strlen(__s);
  if (v98 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_251;
  v99 = v98;
  if (v98 > 0x16)
  {
    v102 = (v98 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v98 | 7) != 0x17)
      v102 = v98 | 7;
    v103 = v102 + 1;
    v100 = (void **)operator new(v102 + 1);
    v139 = v99;
    v140 = v103 | 0x8000000000000000;
    __src = v100;
    v101 = (char *)v100 + v99;
    if (v100 > (void **)v97)
      goto LABEL_194;
  }
  else
  {
    HIBYTE(v140) = v98;
    v100 = (void **)&__src;
    v101 = (char *)&__src + v99;
    if (&__src > (void ***)__s)
      goto LABEL_194;
  }
  if (v101 > v97)
    goto LABEL_250;
LABEL_194:
  if (v99)
    memmove(v100, v97, v99);
  *v101 = 0;
  if (SHIBYTE(v140) < 0)
  {
    v104 = v139;
    if ((v139 & 0x8000000000000000) != 0)
      goto LABEL_250;
    v105 = __src;
    if (v139)
    {
      if (!__src)
        goto LABEL_250;
    }
  }
  else
  {
    v104 = HIBYTE(v140);
    v105 = (void **)&__src;
  }
  v107 = *((_QWORD *)&v142 + 1);
  v106 = v142;
  v108 = v141;
  if (v104 >= (_QWORD)v142 + ~*((_QWORD *)&v142 + 1))
    v109 = v142 + ~*((_QWORD *)&v142 + 1);
  else
    v109 = v104;
  memcpy(&v141[*((_QWORD *)&v142 + 1)], v105, v109);
  v110 = v107 + v109;
  v111 = &v108[v107 + v109];
  *v111 = 0;
  if (SHIBYTE(v140) < 0)
    operator delete(__src);
  if (v106 + ~v110 >= 0xC)
    v112 = 12;
  else
    v112 = v106 + ~v110;
  memcpy(v111, ", renderer: ", v112);
  v113 = v110 + v112;
  v108[v113] = 0;
  v114 = v137;
  v115 = v137[17];
  if (v115)
    v116 = "(renderer)";
  else
    v116 = "nullptr";
  v117 = 10;
  if (!v115)
    v117 = 7;
  if (v117 >= v106 + ~v113)
    v118 = v106 + ~v113;
  else
    v118 = v117;
  memcpy(&v108[v113], v116, v118);
  v119 = v113 + v118;
  v108[v119] = 0;
  if (v106 + ~v119 >= 0x13)
    v120 = 19;
  else
    v120 = v106 + ~v119;
  memcpy(&v108[v119], ", render_delay_ms: ", v120);
  *((_QWORD *)&v142 + 1) = v119 + v120;
  v108[*((_QWORD *)&v142 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&v141, "%d", *((_DWORD *)v114 + 36));
  if (*((char *)v114 + 175) < 0)
  {
    if (!v114[20])
      goto LABEL_236;
  }
  else if (!*((_BYTE *)v114 + 175))
  {
    goto LABEL_236;
  }
  v121 = v114 + 19;
  if ((_QWORD)v142 + ~*((_QWORD *)&v142 + 1) >= 0xEuLL)
    v122 = 14;
  else
    v122 = v142 + ~*((_QWORD *)&v142 + 1);
  memcpy(&v141[*((_QWORD *)&v142 + 1)], ", sync_group: ", v122);
  *((_QWORD *)&v142 + 1) += v122;
  v141[*((_QWORD *)&v142 + 1)] = 0;
  if (*((char *)v114 + 175) < 0)
  {
    v123 = v114[20];
    if ((v123 & 0x8000000000000000) != 0)
      goto LABEL_250;
    v121 = (_QWORD *)*v121;
    if (v123)
    {
      if (!v121)
        goto LABEL_250;
    }
  }
  else
  {
    v123 = *((unsigned __int8 *)v114 + 175);
  }
  if (v123 >= (_QWORD)v142 + ~*((_QWORD *)&v142 + 1))
    v124 = v142 + ~*((_QWORD *)&v142 + 1);
  else
    v124 = v123;
  memcpy(&v141[*((_QWORD *)&v142 + 1)], v121, v124);
  *((_QWORD *)&v142 + 1) += v124;
  v141[*((_QWORD *)&v142 + 1)] = 0;
LABEL_236:
  LOBYTE(v146[0]) = 125;
  v125 = v142;
  v126 = *((_QWORD *)&v142 + 1) + 1;
  memcpy(&v141[*((_QWORD *)&v142 + 1)], v146, v142 != *((_QWORD *)&v142 + 1) + 1);
  v127 = *((_QWORD *)&v142 + 1);
  if (v125 != v126)
    v127 = *((_QWORD *)&v142 + 1) + 1;
  *((_QWORD *)&v142 + 1) = v127;
  v141[v127] = 0;
  v128 = v141;
  if (!v141)
    goto LABEL_250;
  v129 = strlen(v141);
  if (v129 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_251;
  v130 = v129;
  if (v129 <= 0x16)
  {
    result = v135;
    v135[23] = v130;
    v132 = &v135[v130];
    if (v135 > v128)
      goto LABEL_247;
    goto LABEL_246;
  }
  v133 = (v129 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v129 | 7) != 0x17)
    v133 = v129 | 7;
  v134 = v133 + 1;
  result = (char *)operator new(v133 + 1);
  *((_QWORD *)v135 + 1) = v130;
  *((_QWORD *)v135 + 2) = v134 | 0x8000000000000000;
  *(_QWORD *)v135 = result;
  v132 = &result[v130];
  if (result <= v128)
  {
LABEL_246:
    if (v132 <= v128)
      goto LABEL_247;
LABEL_250:
    __break(1u);
LABEL_251:
    abort();
  }
LABEL_247:
  if (v130)
    result = (char *)memmove(result, v128, v130);
  *v132 = 0;
  return result;
}

uint64_t webrtc::internal::VideoReceiveStream2::VideoReceiveStream2(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t *a9, webrtc::DecodeSynchronizer *a10)
{
  _BYTE *v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  pthread_mutexattr_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (***v42)(_QWORD);
  void (***v43)(_QWORD);
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int64x2_t **v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _DWORD *v66;
  uint64_t *v67;
  uint64_t *v68;
  int v69;
  uint64_t **v70;
  uint64_t **v71;
  uint64_t **v72;
  uint64_t *v73;
  uint64_t *v74;
  uint64_t **v75;
  int v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int64x2_t *v89;
  uint64_t v90;
  uint64_t v91;
  int64x2_t *v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v108;
  int *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v114;
  webrtc::VideoReceiveStreamInterface::Config *v115;
  unint64_t v116;
  uint64_t **v117;
  uint64_t *v118;
  uint64_t v119;
  void (***v120)(_QWORD);
  void (***v121)(_QWORD);
  pthread_mutexattr_t v122;
  uint64_t v123;
  pthread_mutexattr_t *v124;
  uint64_t v125;

  v125 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a1 + 16) = &unk_24C0C3F78;
  v112 = a1 + 16;
  *(_QWORD *)(a1 + 24) = &unk_24C0C3FA0;
  v114 = a1 + 24;
  v16 = (_BYTE *)(a1 + 4104);
  *(_QWORD *)(a1 + 40) = &unk_24C0C4010;
  v110 = a1 + 40;
  *(_QWORD *)a1 = &off_24C0C3E40;
  *(_QWORD *)(a1 + 8) = &unk_24C0C3F40;
  *(_QWORD *)(a1 + 32) = &unk_24C0C3FE8;
  v17 = *a2;
  *(_QWORD *)(a1 + 48) = *a2;
  if (v17)
  {
    v18 = (unsigned int *)(v17 + 8);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v20 = *(_OWORD *)(a2 + 1);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 3);
  *(_OWORD *)(a1 + 56) = v20;
  *(_QWORD *)(a1 + 88) = &unk_24C0C28D8;
  v111 = a1 + 88;
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a6 + 128);
  *(_BYTE *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 112) = *(_OWORD *)a6;
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a6 + 16);
  *(_QWORD *)a6 = 0;
  *(_QWORD *)(a6 + 8) = 0;
  *(_QWORD *)(a6 + 16) = 0;
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a6 + 24);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a6 + 32);
  v21 = *(_OWORD *)(a6 + 40);
  v22 = *(_OWORD *)(a6 + 56);
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a6 + 72);
  *(_OWORD *)(a1 + 168) = v22;
  *(_OWORD *)(a1 + 152) = v21;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  v109 = (int *)(a1 + 200);
  *(_QWORD *)(a1 + 192) = a1 + 200;
  std::map<int,int>::insert[abi:sn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<int,int>,std::__tree_node<std::__value_type<int,int>,void *> *,long>>>((uint64_t *)(a1 + 192), *(int **)(a6 + 80), (int *)(a6 + 88));
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 216) = a1 + 224;
  *(_QWORD *)(a1 + 232) = 0;
  std::set<int>::insert[abi:sn180100]<std::__tree_const_iterator<int,std::__tree_node<int,void *> *,long>>((uint64_t *)(a1 + 216), *(int **)(a6 + 104), (int *)(a6 + 112));
  v23 = *(_OWORD *)(a6 + 128);
  *(_QWORD *)(a1 + 253) = *(_QWORD *)(a6 + 141);
  *(_OWORD *)(a1 + 240) = v23;
  v24 = *(_OWORD *)(a6 + 152);
  *(_QWORD *)(a1 + 280) = *(_QWORD *)(a6 + 168);
  v115 = (webrtc::VideoReceiveStreamInterface::Config *)(a1 + 112);
  *(_OWORD *)(a1 + 264) = v24;
  *(_QWORD *)(a6 + 152) = 0;
  *(_QWORD *)(a6 + 160) = 0;
  v25 = *(_QWORD *)(a6 + 176);
  *(_QWORD *)(a6 + 168) = 0;
  *(_QWORD *)(a6 + 176) = 0;
  *(_QWORD *)(a1 + 288) = v25;
  *(_DWORD *)(a1 + 296) = 65537;
  *(_BYTE *)(a1 + 300) = 0;
  *(_DWORD *)(a1 + 296) = *(_DWORD *)(a6 + 184);
  *(_BYTE *)(a1 + 300) = *(_BYTE *)(a6 + 188);
  v26 = *(_QWORD *)(a6 + 192);
  *(_QWORD *)(a6 + 192) = 0;
  *(_QWORD *)(a1 + 304) = v26;
  *(_DWORD *)(a1 + 312) = a4;
  *(_QWORD *)(a1 + 320) = a3;
  *(_QWORD *)(a1 + 328) = a7;
  *(_WORD *)(a1 + 336) = 256;
  *(_QWORD *)(a1 + 352) = v27;
  *(_QWORD *)(a1 + 360) = a1 + 360;
  *(_QWORD *)(a1 + 368) = a1 + 360;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_QWORD *)(a1 + 408) = 0;
  *(_DWORD *)(a1 + 416) = 1065353216;
  v28 = operator new();
  *(_DWORD *)v28 = 0;
  *(_BYTE *)(v28 + 4) = 1;
  *(_QWORD *)(a1 + 424) = v28;
  do
    v29 = __ldxr((unsigned int *)v28);
  while (__stxr(v29 + 1, (unsigned int *)v28));
  v30 = *(_DWORD *)(a1 + 144);
  v31 = *(_QWORD *)(a1 + 64);
  v32 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 200))(a3);
  webrtc::internal::ReceiveStatisticsProxy::ReceiveStatisticsProxy(a1 + 432, v30, v31, v32);
  v33 = *(_QWORD *)(a1 + 64);
  v34 = operator new();
  v122.__sig = (uint64_t)&off_24C0BB148;
  v124 = &v122;
  webrtc::ReceiveStatisticsLocked::ReceiveStatisticsLocked(v34, v33, &v122);
  v35 = v124;
  if (v124 == &v122)
  {
    v36 = 4;
    v35 = &v122;
  }
  else
  {
    if (!v124)
      goto LABEL_11;
    v36 = 5;
  }
  (*(void (**)(void))(v35->__sig + 8 * v36))();
LABEL_11:
  *(_QWORD *)(a1 + 2072) = v34;
  v37 = *a8;
  *a8 = 0;
  *(_QWORD *)(a1 + 2080) = v37;
  v38 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 2088) = v38;
  webrtc::VCMDecodedFrameCallback::VCMDecodedFrameCallback(a1 + 2096, v37, v38);
  *(_WORD *)(a1 + 2257) = 0;
  *(_BYTE *)(a1 + 2264) = 0;
  *(_BYTE *)(a1 + 2320) = 0;
  *(_QWORD *)(a1 + 2344) = 0;
  *(_QWORD *)(a1 + 2336) = 0;
  *(_QWORD *)(a1 + 2328) = a1 + 2336;
  *(_QWORD *)(a1 + 2376) = 0;
  *(_QWORD *)(a1 + 2368) = 0;
  *(_QWORD *)(a1 + 2360) = 0;
  *(_QWORD *)(a1 + 2352) = a1 + 2360;
  v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 200))(a3);
  v40 = *(_QWORD *)(a1 + 64);
  v41 = *(_QWORD *)(a1 + 2072);
  v42 = *(void (****)(_QWORD))(a1 + 288);
  v121 = v42;
  if (v42)
    (**v42)(v42);
  v43 = *(void (****)(_QWORD))(a1 + 304);
  v120 = v43;
  if (v43)
    (**v43)(v43);
  webrtc::RtpVideoStreamReceiver2::RtpVideoStreamReceiver2(a1 + 2384, v39, v40, v111, a7, a5, (uint64_t)v115, v41, a1 + 448, a1 + 440, a9, v112, (uint64_t *)&v121, (uint64_t *)&v120, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 80));
  if (v120)
    (*v120)[1](v120);
  if (v121)
    (*v121)[1](v121);
  *(_QWORD *)(a1 + 3784) = 0;
  *(_QWORD *)(a1 + 3792) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 200))(a3);
  *(_QWORD *)(a1 + 3800) = v114;
  *(_QWORD *)(a1 + 3816) = 0;
  *(_QWORD *)(a1 + 3808) = 0;
  *(_DWORD *)(a1 + 3824) = 0;
  *(_QWORD *)(a1 + 3832) = a1 + 3832;
  *(_QWORD *)(a1 + 3840) = a1 + 3832;
  *(_QWORD *)(a1 + 3848) = 0;
  *(_BYTE *)(a1 + 3856) = 0;
  *(_BYTE *)(a1 + 3872) = 0;
  *(_QWORD *)(a1 + 3880) = 0;
  *(_BYTE *)(a1 + 3888) = 0;
  *(_BYTE *)(a1 + 3892) = 0;
  *(_QWORD *)(a1 + 3896) = 0;
  *(_DWORD *)(a1 + 3904) = 0;
  *(_DWORD *)(a1 + 3912) = 0;
  *(_QWORD *)(a1 + 3920) = a1 + 3920;
  *(_QWORD *)(a1 + 3928) = a1 + 3920;
  *(_QWORD *)(a1 + 3936) = 0;
  *(_BYTE *)(a1 + 3944) = 0;
  *(_BYTE *)(a1 + 3960) = 0;
  *(_QWORD *)(a1 + 3968) = 0;
  *(_BYTE *)(a1 + 3976) = 0;
  *(_BYTE *)(a1 + 3980) = 0;
  *(_QWORD *)(a1 + 3984) = 0;
  *(_DWORD *)(a1 + 3992) = 0;
  *(_QWORD *)(a1 + 4000) = 0;
  if (rtc::g_clock)
  {
    v44 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v44 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
        / dword_253EA791C;
  }
  *(_QWORD *)(a1 + 4008) = v44 / 1000000;
  *(_BYTE *)(a1 + 4052) = 0;
  *(_QWORD *)(a1 + 4056) = 0;
  *(_OWORD *)(a1 + 4016) = 0u;
  *(_OWORD *)(a1 + 4032) = 0u;
  *(_BYTE *)(a1 + 4048) = 0;
  *(_WORD *)(a1 + 4064) = 1;
  *(_BYTE *)(a1 + 4072) = 0;
  *(_BYTE *)(a1 + 4080) = 0;
  v45 = *(_DWORD *)(a1 + 152);
  v46 = 1000 * v45;
  v47 = 200000;
  if ((unint64_t)(v46 - 1) < 0xF423F)
    v47 = 1000 * v45;
  *(_QWORD *)(a1 + 4088) = v47;
  v48 = 3000 * v45;
  if ((unint64_t)(v46 - 1) >= 0xF423F)
    v48 = 3000000;
  *(_QWORD *)(a1 + 4096) = v48;
  *v16 = 0;
  v16[8] = 0;
  v16[16] = 0;
  v16[24] = 0;
  v16[32] = 0;
  v16[40] = 0;
  v49 = (int64x2_t **)(a1 + 4016);
  v16[48] = 0;
  v16[56] = 0;
  *(_QWORD *)(a1 + 4192) = 0;
  v16[96] = 0;
  pthread_mutexattr_init(&v122);
  pthread_mutexattr_setpolicy_np(&v122, 3);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4208), &v122);
  pthread_mutexattr_destroy(&v122);
  v16[168] = 0;
  v16[176] = 0;
  *(_QWORD *)(a1 + 4288) = 0;
  *(_QWORD *)(a1 + 4304) = 0;
  *(_QWORD *)(a1 + 4296) = 0;
  v50 = operator new();
  *(_DWORD *)v50 = 0;
  *(_BYTE *)(v50 + 4) = 1;
  *(_QWORD *)(a1 + 4312) = v50;
  do
    v51 = __ldxr((unsigned int *)v50);
  while (__stxr(v51 + 1, (unsigned int *)v50));
  (*(void (**)(_QWORD, const char *, uint64_t, uint64_t))(**(_QWORD **)(a1 + 72) + 16))(*(_QWORD *)(a1 + 72), "DecodingQueue", 13, 1);
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    webrtc::VideoReceiveStreamInterface::Config::ToString(v115, v52);
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v57, v58, v59, v60, v61, v62, v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/video_receive_stream2.cc");
    if (SHIBYTE(v123) < 0)
      operator delete((void *)v122.__sig);
  }
  if (!*(_QWORD *)(a1 + 136))
LABEL_75:
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/video_receive_stream2.cc", 234, "config_.decoder_factory", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v53, v54, v55, v56, v108);
  v118 = 0;
  v119 = 0;
  v117 = &v118;
  v64 = *(_QWORD *)(a1 + 112);
  v65 = *(_QWORD *)(a1 + 120);
  while (v64 != v65)
  {
    v68 = v118;
    v69 = *(_DWORD *)(v64 + 96);
    v70 = &v118;
    v71 = &v118;
    if (v118)
    {
      v72 = &v118;
      v73 = v118;
      do
      {
        v74 = v73;
        v75 = v72;
        v76 = *((_DWORD *)v73 + 7);
        if (v76 >= v69)
          v72 = (uint64_t **)v73;
        else
          ++v73;
        v73 = (uint64_t *)*v73;
      }
      while (v73);
      if (v72 != &v118)
      {
        if (v76 < v69)
          v74 = (uint64_t *)v75;
        if (v69 >= *((_DWORD *)v74 + 7))
        {
          rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/video_receive_stream2.cc", 238, "decoder_payload_types.find(decoder.payload_type) == decoder_payload_types.end()", rtc::webrtc_checks_impl::LogStreamer<>::Call<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*> const&)::t, v53, v54, v55, v56, (uint64_t)"Duplicate payload type (");
          goto LABEL_75;
        }
      }
      while (1)
      {
        while (1)
        {
          v71 = (uint64_t **)v68;
          v77 = *((_DWORD *)v68 + 7);
          if (v69 >= v77)
            break;
          v68 = *v71;
          v70 = v71;
          if (!*v71)
            goto LABEL_35;
        }
        if (v77 >= v69)
          break;
        v68 = v71[1];
        if (!v68)
        {
          v70 = v71 + 1;
          goto LABEL_35;
        }
      }
    }
    else
    {
LABEL_35:
      v66 = operator new(0x20uLL);
      v66[7] = v69;
      *(_QWORD *)v66 = 0;
      *((_QWORD *)v66 + 1) = 0;
      *((_QWORD *)v66 + 2) = v71;
      *v70 = (uint64_t *)v66;
      if (*v117)
      {
        v117 = (uint64_t **)*v117;
        v67 = *v70;
      }
      else
      {
        v67 = (uint64_t *)v66;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(v118, v67);
      ++v119;
    }
    v64 += 104;
  }
  v78 = *(_QWORD *)(a1 + 2080);
  v79 = 1000 * *(int *)(a1 + 256);
  pthread_mutex_lock((pthread_mutex_t *)(v78 + 8));
  *(_QWORD *)(v78 + 96) = v79;
  pthread_mutex_unlock((pthread_mutex_t *)(v78 + 8));
  if (a10)
  {
    webrtc::DecodeSynchronizer::CreateSynchronizedFrameScheduler(a10, &v116);
    v80 = v116;
  }
  else
  {
    v81 = *(_QWORD *)(a1 + 64);
    v82 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 320) + 200))(*(_QWORD *)(a1 + 320));
    v80 = operator new();
    *(_QWORD *)v80 = &off_24C0C1FE0;
    *(_QWORD *)(v80 + 8) = v81;
    *(_QWORD *)(v80 + 16) = v82;
    *(_BYTE *)(v80 + 24) = 0;
    *(_BYTE *)(v80 + 28) = 0;
    v83 = operator new();
    *(_DWORD *)v83 = 0;
    *(_BYTE *)(v83 + 4) = 1;
    *(_QWORD *)(v80 + 32) = v83;
    do
      v84 = __ldxr((unsigned int *)v83);
    while (__stxr(v84 + 1, (unsigned int *)v83));
    *(_BYTE *)(v80 + 40) = 0;
  }
  v85 = *(_QWORD *)(a1 + 64);
  v86 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 320) + 200))(*(_QWORD *)(a1 + 320));
  v87 = *(_QWORD *)(a1 + 2080);
  v88 = *(_QWORD *)(a1 + 56);
  v89 = (int64x2_t *)operator new();
  v90 = *(_QWORD *)(a1 + 4088);
  v91 = *(_QWORD *)(a1 + 4096);
  v122.__sig = v80;
  webrtc::VideoStreamBufferController::VideoStreamBufferController(v89, v85, v86, v87, a1 + 432, v110, v90, v91, &v122.__sig, v88);
  if (v122.__sig)
    (*(void (**)(uint64_t))(*(_QWORD *)v122.__sig + 8))(v122.__sig);
  v92 = *v49;
  *v49 = v89;
  if (v92)
    (*(void (**)(int64x2_t *))(v92->i64[0] + 8))(v92);
  v93 = *(_DWORD *)(a1 + 144);
  v94 = *(_QWORD *)(a1 + 2072);
  if (*(_QWORD *)(a1 + 208))
  {
    v95 = operator new();
    *(_QWORD *)v122.__opaque = 0;
    v123 = 0;
    v122.__sig = (uint64_t)v122.__opaque;
    std::map<int,int>::insert[abi:sn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<int,int>,std::__tree_node<std::__value_type<int,int>,void *> *,long>>>(&v122.__sig, *(int **)(a1 + 192), v109);
    *(_QWORD *)v95 = &off_24C0BED78;
    *(_QWORD *)(v95 + 8) = a1 + 2400;
    v96 = *(_QWORD *)v122.__opaque;
    *(_QWORD *)(v95 + 16) = v122.__sig;
    *(_QWORD *)(v95 + 24) = v96;
    v97 = v95 + 24;
    v98 = v123;
    *(_QWORD *)(v95 + 32) = v123;
    if (v98)
    {
      *(_QWORD *)(v96 + 16) = v97;
      v122.__sig = (uint64_t)v122.__opaque;
      *(_QWORD *)v122.__opaque = 0;
      v123 = 0;
      *(_DWORD *)(v95 + 40) = v93;
      *(_QWORD *)(v95 + 48) = v94;
    }
    else
    {
      *(_QWORD *)(v95 + 16) = v97;
      *(_DWORD *)(v95 + 40) = v93;
      *(_QWORD *)(v95 + 48) = v94;
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v99, v100, v101, v102, v103, v104, v105, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/call/rtx_receive_stream.cc");
    }
    std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)&v122, *(_QWORD **)v122.__opaque);
    v106 = *(_QWORD *)(a1 + 4040);
    *(_QWORD *)(a1 + 4040) = v95;
    if (v106)
      (*(void (**)(uint64_t))(*(_QWORD *)v106 + 8))(v106);
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)v94 + 48))(*(_QWORD *)(a1 + 2072), *(unsigned int *)(a1 + 144), 1);
  }
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)&v117, v118);
  return a1;
}

void webrtc::internal::VideoReceiveStream2::~VideoReceiveStream2(webrtc::internal::VideoReceiveStream2 *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (***v10)(_QWORD);
  uint64_t v11;
  unsigned int v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  webrtc::internal::VideoReceiveStream2 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  webrtc::internal::VideoReceiveStream2 *v41;
  uint64_t v42;
  uint64_t v43;
  webrtc::internal::VideoReceiveStream2 *v44;
  unsigned int *v45;
  unsigned int *v46;
  unsigned int v47;
  unsigned int v48;
  void *__p;
  char v50;

  *(_QWORD *)this = &off_24C0C3E40;
  *((_QWORD *)this + 1) = &unk_24C0C3F40;
  *((_QWORD *)this + 2) = &unk_24C0C3F78;
  *((_QWORD *)this + 3) = &unk_24C0C3FA0;
  *((_QWORD *)this + 4) = &unk_24C0C3FE8;
  *((_QWORD *)this + 5) = &unk_24C0C4010;
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    webrtc::VideoReceiveStreamInterface::Config::ToString((webrtc::internal::VideoReceiveStream2 *)((char *)this + 112), v2);
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/video_receive_stream2.cc");
    if (v50 < 0)
      operator delete(__p);
  }
  (*(void (**)(webrtc::internal::VideoReceiveStream2 *))(*(_QWORD *)this + 24))(this);
  v10 = (void (***)(_QWORD))*((_QWORD *)this + 540);
  *((_QWORD *)this + 540) = 0;
  if (v10)
    (**v10)(v10);
  v11 = *((_QWORD *)this + 539);
  *(_BYTE *)(v11 + 4) = 0;
  do
    v12 = __ldaxr((unsigned int *)v11);
  while (__stlxr(v12 - 1, (unsigned int *)v11));
  if (v12 == 1)
    MEMORY[0x20BD0ADEC]();
  v13 = (_QWORD *)*((_QWORD *)this + 536);
  if (v13)
  {
    v14 = (_QWORD *)*((_QWORD *)this + 537);
    v15 = (void *)*((_QWORD *)this + 536);
    if (v14 != v13)
    {
      do
      {
        v17 = *--v14;
        v16 = v17;
        *v14 = 0;
        if (v17)
          (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
      }
      while (v14 != v13);
      v15 = (void *)*((_QWORD *)this + 536);
    }
    *((_QWORD *)this + 537) = v13;
    operator delete(v15);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 4208));
  v18 = (webrtc::internal::VideoReceiveStream2 *)*((_QWORD *)this + 524);
  if (v18 == (webrtc::internal::VideoReceiveStream2 *)((char *)this + 4168))
  {
    v19 = 4;
    v18 = (webrtc::internal::VideoReceiveStream2 *)((char *)this + 4168);
  }
  else
  {
    if (!v18)
      goto LABEL_23;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_23:
  v20 = *((_QWORD *)this + 507);
  *((_QWORD *)this + 507) = 0;
  if (v20)
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
  v21 = *((_QWORD *)this + 505);
  *((_QWORD *)this + 505) = 0;
  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
  v22 = *((_QWORD *)this + 504);
  *((_QWORD *)this + 504) = 0;
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
  v23 = *((_QWORD *)this + 502);
  *((_QWORD *)this + 502) = 0;
  if (v23)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
  webrtc::internal::RtpStreamsSynchronizer::~RtpStreamsSynchronizer((webrtc::internal::VideoReceiveStream2 *)((char *)this + 3792));
  v31 = *((_QWORD *)this + 473);
  *((_QWORD *)this + 473) = 0;
  if (v31)
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 40))(v31);
  webrtc::RtpVideoStreamReceiver2::~RtpVideoStreamReceiver2((webrtc::internal::VideoReceiveStream2 *)((char *)this + 2384), v24, v25, v26, v27, v28, v29, v30);
  v32 = *((_QWORD *)this + 297);
  *((_QWORD *)this + 297) = 0;
  if (v32)
    (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
  webrtc::VideoReceiver2::~VideoReceiver2((webrtc::internal::VideoReceiveStream2 *)((char *)this + 2088));
  v33 = *((_QWORD *)this + 260);
  *((_QWORD *)this + 260) = 0;
  if (v33)
    (*(void (**)(uint64_t))(*(_QWORD *)v33 + 8))(v33);
  v34 = *((_QWORD *)this + 259);
  *((_QWORD *)this + 259) = 0;
  if (v34)
    (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
  webrtc::internal::ReceiveStatisticsProxy::~ReceiveStatisticsProxy((webrtc::internal::VideoReceiveStream2 *)((char *)this + 432));
  v35 = *((_QWORD *)this + 53);
  *(_BYTE *)(v35 + 4) = 0;
  do
  {
    v36 = __ldaxr((unsigned int *)v35);
    v37 = v36 - 1;
  }
  while (__stlxr(v37, (unsigned int *)v35));
  if (!v37)
    MEMORY[0x20BD0ADEC]();
  v38 = (_QWORD *)*((_QWORD *)this + 50);
  if (v38)
  {
    do
    {
      v39 = (_QWORD *)*v38;
      operator delete(v38);
      v38 = v39;
    }
    while (v39);
  }
  v40 = (void *)*((_QWORD *)this + 48);
  *((_QWORD *)this + 48) = 0;
  if (v40)
    operator delete(v40);
  if (*((_QWORD *)this + 47))
  {
    v42 = *((_QWORD *)this + 45);
    v41 = (webrtc::internal::VideoReceiveStream2 *)*((_QWORD *)this + 46);
    v43 = *(_QWORD *)v41;
    *(_QWORD *)(v43 + 8) = *(_QWORD *)(v42 + 8);
    **(_QWORD **)(v42 + 8) = v43;
    *((_QWORD *)this + 47) = 0;
    if (v41 != (webrtc::internal::VideoReceiveStream2 *)((char *)this + 360))
    {
      do
      {
        v44 = (webrtc::internal::VideoReceiveStream2 *)*((_QWORD *)v41 + 1);
        operator delete(v41);
        v41 = v44;
      }
      while (v44 != (webrtc::internal::VideoReceiveStream2 *)((char *)this + 360));
    }
  }
  webrtc::VideoReceiveStreamInterface::Config::~Config((webrtc::internal::VideoReceiveStream2 *)((char *)this + 112));
  v45 = (unsigned int *)*((_QWORD *)this + 6);
  if (v45)
  {
    v46 = v45 + 2;
    do
    {
      v47 = __ldaxr(v46);
      v48 = v47 - 1;
    }
    while (__stlxr(v48, v46));
    if (!v48)
      (*(void (**)(unsigned int *))(*(_QWORD *)v45 + 8))(v45);
  }
}

{
  webrtc::internal::VideoReceiveStream2::~VideoReceiveStream2(this);
  JUMPOUT(0x20BD0ADECLL);
}

