void ec_GFp_nistp224_add(double a1, double a2, double a3, double a4, int64x2_t a5, uint64_t a6, uint64_t *a7, _QWORD *a8, _QWORD *a9)
{
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  unint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  unint64_t v27;
  __int128 v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  BOOL v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  BOOL v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66[4];
  int8x16_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70[4];
  int8x16_t v71;
  uint64_t v72;
  unint64_t v73;
  int8x16_t v74;
  uint64_t v75;
  unint64_t v76;
  int8x16_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;

  v80 = *MEMORY[0x24BDAC8D0];
  v10 = a8[1];
  *((_QWORD *)&v11 + 1) = v10;
  *(_QWORD *)&v11 = *a8;
  v77.i64[0] = *a8 & 0xFFFFFFFFFFFFFFLL;
  v77.i64[1] = (v11 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v11 + 1) = a8[2];
  *(_QWORD *)&v11 = v10;
  v12 = (v11 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v13 = *((_OWORD *)a8 + 1);
  v78 = v12;
  v79 = (v13 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v14 = a8[10];
  *((_QWORD *)&v13 + 1) = v14;
  *(_QWORD *)&v13 = a8[9];
  v74.i64[0] = v13 & 0xFFFFFFFFFFFFFFLL;
  v74.i64[1] = (v13 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v13 + 1) = a8[11];
  *(_QWORD *)&v13 = v14;
  v15 = (v13 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v16 = *(_OWORD *)(a8 + 11);
  v75 = v15;
  v76 = (v16 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v17 = a8[19];
  *((_QWORD *)&v16 + 1) = v17;
  *(_QWORD *)&v16 = a8[18];
  v71.i64[0] = v16 & 0xFFFFFFFFFFFFFFLL;
  v71.i64[1] = (v16 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v16 + 1) = a8[20];
  *(_QWORD *)&v16 = v17;
  v18 = (v16 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v19 = *((_OWORD *)a8 + 10);
  v72 = v18;
  v73 = (v19 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v20 = a9[1];
  *((_QWORD *)&v19 + 1) = v20;
  *(_QWORD *)&v19 = *a9;
  v70[0] = *a9 & 0xFFFFFFFFFFFFFFLL;
  v70[1] = (v19 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v19 + 1) = a9[2];
  *(_QWORD *)&v19 = v20;
  v21 = (v19 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v22 = *((_OWORD *)a9 + 1);
  v70[2] = v21;
  v70[3] = (v22 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v23 = a9[10];
  *((_QWORD *)&v22 + 1) = v23;
  *(_QWORD *)&v22 = a9[9];
  v67.i64[0] = v22 & 0xFFFFFFFFFFFFFFLL;
  v67.i64[1] = (v22 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v22 + 1) = a9[11];
  *(_QWORD *)&v22 = v23;
  v24 = (v22 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v25 = *(_OWORD *)(a9 + 11);
  v68 = v24;
  v69 = (v25 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v26 = a9[19];
  *((_QWORD *)&v25 + 1) = v26;
  *(_QWORD *)&v25 = a9[18];
  v66[0] = v25 & 0xFFFFFFFFFFFFFFLL;
  v66[1] = (v25 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v25 + 1) = a9[20];
  *(_QWORD *)&v25 = v26;
  v27 = (v25 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v28 = *((_OWORD *)a9 + 10);
  v66[2] = v27;
  v66[3] = (v28 >> 40) & 0xFFFFFFFFFFFFFFLL;
  p224_point_add(&v77, &v74, &v71, (unint64_t *)&v77, (int64x2_t *)&v74, (int64x2_t *)&v71, 0, v70, a1, a2, a3, a4, a5, &v67, v66);
  v29 = (((v78 & v79 & (v77.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v77.i64[0] + (v77.i64[1] & 0xFFFFFFFFFFLL) - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v30 = v29 != 0;
  v31 = v77.i64[0] - HIBYTE(v79) + ((v29 - 1) >> 63);
  v32 = v31 + ((unint64_t)v31 >> 63 << 56);
  v33 = 0xFFFFFFFFFFLL;
  if (v30)
    v34 = -1;
  else
    v34 = 0xFFFFFFFFFFLL;
  v35 = (v34 & (v77.i64[1] + (HIBYTE(v79) << 40))) + (v31 >> 63);
  v36 = v30;
  v37 = v36 << 63 >> 63;
  v38 = (v78 & v37) + (v35 >> 56);
  v39 = (v79 & v37 & 0xFFFFFFFFFFFFFFLL) + (v38 >> 56);
  *a7 = v32 | (v35 << 56);
  a7[1] = ((unint64_t)v35 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v38 << 48);
  a7[2] = ((unint64_t)v38 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v39 << 40);
  a7[3] = v39 >> 24;
  v40 = (((v75 & v76 & (v74.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v74.i64[0] + (v74.i64[1] & 0xFFFFFFFFFFLL) - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v41 = v40 != 0;
  v42 = v40 - 1;
  v43 = v41;
  v44 = v43 << 63 >> 63;
  v45 = v76 & v44 & 0xFFFFFFFFFFFFFFLL;
  v46 = v75 & v44;
  if (v41)
    v47 = -1;
  else
    v47 = 0xFFFFFFFFFFLL;
  v48 = v74.i64[0] - HIBYTE(v76) + (v42 >> 63);
  v49 = v48 + ((unint64_t)v48 >> 63 << 56);
  v50 = (v47 & (v74.i64[1] + (HIBYTE(v76) << 40))) + (v48 >> 63);
  v51 = v46 + (v50 >> 56);
  v52 = v45 + (v51 >> 56);
  a7[9] = v49 | (v50 << 56);
  a7[10] = ((unint64_t)v50 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v51 << 48);
  a7[11] = ((unint64_t)v51 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v52 << 40);
  a7[12] = v52 >> 24;
  v53 = (((v72 & v73 & (v71.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v71.i64[0] + (v71.i64[1] & 0xFFFFFFFFFFLL) - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v54 = v53 != 0;
  v55 = v53 - 1;
  v56 = v54;
  v57 = v56 << 63 >> 63;
  v58 = v73 & v57 & 0xFFFFFFFFFFFFFFLL;
  v59 = v72 & v57;
  if (v54)
    v33 = -1;
  v60 = v71.i64[0] - HIBYTE(v73) + (v55 >> 63);
  v61 = v60 + ((unint64_t)v60 >> 63 << 56);
  v62 = (v33 & (v71.i64[1] + (HIBYTE(v73) << 40))) + (v60 >> 63);
  v63 = v59 + (v62 >> 56);
  a7[18] = v61 | (v62 << 56);
  a7[19] = ((unint64_t)v62 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v63 << 48);
  v64 = (unint64_t)v63 >> 16;
  v65 = v58 + (v63 >> 56);
  a7[20] = v64 & 0xFFFFFFFFFFLL | ((unint64_t)v65 << 40);
  a7[21] = v65 >> 24;
}

void ec_GFp_nistp224_dbl(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int8x16_t v51;
  uint64_t v52;
  unint64_t v53;
  int8x16_t v54;
  uint64_t v55;
  unint64_t v56;
  int8x16_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v4 = a3[1];
  *((_QWORD *)&v5 + 1) = v4;
  *(_QWORD *)&v5 = *a3;
  v57.i64[0] = *a3 & 0xFFFFFFFFFFFFFFLL;
  v57.i64[1] = (v5 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v5 + 1) = a3[2];
  *(_QWORD *)&v5 = v4;
  v6 = (v5 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v7 = *((_OWORD *)a3 + 1);
  v58 = v6;
  v59 = (v7 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v8 = a3[10];
  *((_QWORD *)&v7 + 1) = v8;
  *(_QWORD *)&v7 = a3[9];
  v54.i64[0] = v7 & 0xFFFFFFFFFFFFFFLL;
  v54.i64[1] = (v7 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v7 + 1) = a3[11];
  *(_QWORD *)&v7 = v8;
  v9 = (v7 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v10 = *(_OWORD *)(a3 + 11);
  v55 = v9;
  v56 = (v10 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v11 = a3[19];
  *((_QWORD *)&v10 + 1) = v11;
  *(_QWORD *)&v10 = a3[18];
  v51.i64[0] = v10 & 0xFFFFFFFFFFFFFFLL;
  v51.i64[1] = (v10 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v10 + 1) = a3[20];
  *(_QWORD *)&v10 = v11;
  v12 = (v10 >> 48) & 0xFFFFFFFFFFFFFFLL;
  v13 = *((_OWORD *)a3 + 10);
  v52 = v12;
  v53 = (v13 >> 40) & 0xFFFFFFFFFFFFFFLL;
  p224_point_double(&v57, &v54, &v51, (unint64_t *)&v57, (int64x2_t *)&v54, (int64x2_t *)&v51);
  v14 = (((v58 & v59 & (v57.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v57.i64[0] + (v57.i64[1] & 0xFFFFFFFFFFLL) - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v15 = v14 != 0;
  v16 = v57.i64[0] - HIBYTE(v59) + ((v14 - 1) >> 63);
  v17 = v16 + ((unint64_t)v16 >> 63 << 56);
  v18 = 0xFFFFFFFFFFLL;
  if (v15)
    v19 = -1;
  else
    v19 = 0xFFFFFFFFFFLL;
  v20 = (v19 & (v57.i64[1] + (HIBYTE(v59) << 40))) + (v16 >> 63);
  v21 = v15;
  v22 = v21 << 63 >> 63;
  v23 = (v58 & v22) + (v20 >> 56);
  v24 = (v59 & v22 & 0xFFFFFFFFFFFFFFLL) + (v23 >> 56);
  *a2 = v17 | (v20 << 56);
  a2[1] = ((unint64_t)v20 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v23 << 48);
  a2[2] = ((unint64_t)v23 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v24 << 40);
  a2[3] = v24 >> 24;
  v25 = (((v55 & v56 & (v54.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v54.i64[0] + (v54.i64[1] & 0xFFFFFFFFFFLL) - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v26 = v25 != 0;
  v27 = v25 - 1;
  v28 = v26;
  v29 = v28 << 63 >> 63;
  v30 = v56 & v29 & 0xFFFFFFFFFFFFFFLL;
  v31 = v55 & v29;
  if (v26)
    v32 = -1;
  else
    v32 = 0xFFFFFFFFFFLL;
  v33 = v54.i64[0] - HIBYTE(v56) + (v27 >> 63);
  v34 = v33 + ((unint64_t)v33 >> 63 << 56);
  v35 = (v32 & (v54.i64[1] + (HIBYTE(v56) << 40))) + (v33 >> 63);
  v36 = v31 + (v35 >> 56);
  v37 = v30 + (v36 >> 56);
  a2[9] = v34 | (v35 << 56);
  a2[10] = ((unint64_t)v35 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v36 << 48);
  a2[11] = ((unint64_t)v36 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v37 << 40);
  a2[12] = v37 >> 24;
  v38 = (((v52 & v53 & (v51.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v51.i64[0] + (v51.i64[1] & 0xFFFFFFFFFFLL) - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v39 = v38 != 0;
  v40 = v38 - 1;
  v41 = v39;
  v42 = v41 << 63 >> 63;
  v43 = v53 & v42 & 0xFFFFFFFFFFFFFFLL;
  v44 = v52 & v42;
  if (v39)
    v18 = -1;
  v45 = v51.i64[0] - HIBYTE(v53) + (v40 >> 63);
  v46 = v45 + ((unint64_t)v45 >> 63 << 56);
  v47 = (v18 & (v51.i64[1] + (HIBYTE(v53) << 40))) + (v45 >> 63);
  v48 = v44 + (v47 >> 56);
  a2[18] = v46 | (v47 << 56);
  a2[19] = ((unint64_t)v47 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v48 << 48);
  v49 = (unint64_t)v48 >> 16;
  v50 = v43 + (v48 >> 56);
  a2[20] = v49 & 0xFFFFFFFFFFLL | ((unint64_t)v50 << 40);
  a2[21] = v50 >> 24;
}

void ec_GFp_nistp224_point_mul(double a1, double a2, double a3, double a4, int64x2_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9)
{
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  double v19;
  double v20;
  double v21;
  double v22;
  int64x2_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  signed __int128 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;
  BOOL v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  BOOL v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  _OWORD v78[2];
  int8x16_t v79;
  __int128 v80;
  _OWORD v81[2];
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int8x16_t v86;
  __int128 v87;
  int8x16_t v88;
  __int128 v89;
  int8x16_t v90;
  __int128 v91;
  _BYTE v92[1632];
  uint64_t v93;

  v93 = *MEMORY[0x24BDAC8D0];
  ec_GFp_nistp224_make_precomp((uint64_t)v92, a8, a1, a2, a3, a4, a5);
  v86 = 0u;
  v87 = 0u;
  v10 = 1;
  v11 = 220;
  v88 = 0u;
  v89 = 0u;
  v90 = 0u;
  v91 = 0u;
  do
  {
    if (v10)
    {
      if (-858993459 * v11 >= 0x33333334)
        goto LABEL_2;
    }
    else
    {
      p224_point_double(&v86, &v88, &v90, (unint64_t *)&v86, (int64x2_t *)&v88, (int64x2_t *)&v90);
      if (-858993459 * v11 >= 0x33333334)
      {
LABEL_2:
        v12 = v11 - 1;
        goto LABEL_3;
      }
    }
    if (v11 <= 0xDB)
    {
      v13 = (*(_QWORD *)(a9 + (((v11 + 4) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v11 + 4)) & 1;
      v12 = v11 - 1;
      if (v11 - 1 > 0xDF)
      {
LABEL_12:
        v14 = 0;
        goto LABEL_13;
      }
    }
    else
    {
      v13 = 0;
      v12 = v11 - 1;
      if (v11 - 1 > 0xDF)
        goto LABEL_12;
    }
    v14 = (*(_QWORD *)(a9 + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v12) & 1;
LABEL_13:
    v15 = (2 * ((*(_QWORD *)(a9 + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v11) & 1)) | v14 | (4
                                                                                              * ((*(_QWORD *)(a9 + (((v11 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v11 + 1)) & 1)) & 0xFFFFFFFFFFFFFFF7 | (8 * ((*(_QWORD *)(a9 + (((v11 + 2) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v11 + 2)) & 1)) | (32 * v13) | (16 * ((*(_QWORD *)(a9 + (((v11 + 3) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v11 + 3)) & 1));
    v16 = -v13;
    v17 = (v15 ^ 0x3F) & -v13 | v15 & (v13 + 0x7FFFFFFFFFFFFFFFLL);
    v18 = p224_select_point((v17 & 1) + (v17 >> 1), 17, (uint64_t)v92, (uint64_t)v78);
    v24 = (((__PAIR128__(0x7FFFFFFFFFFFFF80, -256) - (unint64_t)v80) >> 56) - *((unint64_t *)&v80 + 1)) >> 64;
    v25 = ((__PAIR128__(0x7FFFFFFFFFFFFF80, -256) - (unint64_t)v80) >> 56) - *((_QWORD *)&v80 + 1);
    v41 = v25 >= 0x100;
    v26 = v25 - 256;
    if (v41)
      ++v24;
    v27 = (-256 - v80) & 0xFFFFFFFFFFFFFFLL;
    v28 = HIBYTE(v24);
    *((_QWORD *)&v30 + 1) = v24;
    *(_QWORD *)&v30 = v26;
    v29 = v30 >> 56;
    v31 = v26 & 0xFFFFFFFFFFFFFFLL;
    *((_QWORD *)&v30 + 1) = v24;
    *(_QWORD *)&v30 = v26;
    v32 = (v30 >> 16) & 0xFFFF0000000000;
    v33 = v29 + v79.i64[0];
    if (__CFADD__(v29, v79.i64[0]))
      ++v28;
    v34 = v32
        - __PAIR128__(v18, v79.u64[1])
        + ((__PAIR128__(0x8000000000000001, 33024) - __PAIR128__(v28, v33)) >> 56)
        + __PAIR128__(0x7FFFFFFFFFFFFF80, 0xFF7EFFFFFFFFFF00);
    v35 = (33024 - v33) & 0xFFFFFFFFFFFFFFLL;
    v36 = v34 >> 56;
    v41 = __CFADD__(v36, v27);
    v37 = v36 + v27;
    if (v41)
      v38 = HIBYTE(*((_QWORD *)&v34 + 1)) + 1;
    else
      v38 = HIBYTE(*((_QWORD *)&v34 + 1));
    v82 = v35;
    v83 = v34 & 0xFFFFFFFFFFFFFFLL;
    *((_QWORD *)&v39 + 1) = v38;
    *(_QWORD *)&v39 = v37;
    v84 = v37 & 0xFFFFFFFFFFFFFFLL;
    v85 = (v39 >> 56) + v31;
    v79.i64[0] = v35 & v16 | v79.i64[0] & (v13 - 1);
    v79.i64[1] = v34 & 0xFFFFFFFFFFFFFFLL & v16 | v79.i64[1] & (v13 - 1);
    *(_QWORD *)&v80 = v37 & 0xFFFFFFFFFFFFFFLL & v16 | v80 & (v13 - 1);
    *((_QWORD *)&v80 + 1) = v85 & v16 | *((_QWORD *)&v80 + 1) & (v13 - 1);
    if (v10)
    {
      v10 = 0;
      v88 = v79;
      v89 = v80;
      v90 = (int8x16_t)v81[0];
      v91 = v81[1];
      v86 = (int8x16_t)v78[0];
      v87 = v78[1];
    }
    else
    {
      p224_point_add(&v86, &v88, &v90, (unint64_t *)&v86, (int64x2_t *)&v88, (int64x2_t *)&v90, 0, (unint64_t *)v78, v19, v20, v21, v22, v23, &v79, (unint64_t *)v81);
    }
LABEL_3:
    v11 = v12;
  }
  while (v12 < 0xDD);
  v40 = (((v87 & *((_QWORD *)&v87 + 1) & (v86.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v86.i64[0]
                                                                               + (v86.i64[1] & 0xFFFFFFFFFFLL)
                                                                               - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v41 = v40 != 0;
  v42 = v86.i64[0] - HIBYTE(*((_QWORD *)&v87 + 1)) + ((v40 - 1) >> 63);
  v43 = v42 + ((unint64_t)v42 >> 63 << 56);
  v44 = 0xFFFFFFFFFFLL;
  if (v41)
    v45 = -1;
  else
    v45 = 0xFFFFFFFFFFLL;
  v46 = (v45 & (v86.i64[1] + (HIBYTE(*((_QWORD *)&v87 + 1)) << 40))) + (v42 >> 63);
  v47 = v41;
  v48 = v47 << 63 >> 63;
  v49 = (v87 & v48) + (v46 >> 56);
  v50 = (*((_QWORD *)&v87 + 1) & v48 & 0xFFFFFFFFFFFFFFLL) + (v49 >> 56);
  *a7 = v43 | (v46 << 56);
  a7[1] = ((unint64_t)v46 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v49 << 48);
  a7[2] = ((unint64_t)v49 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v50 << 40);
  a7[3] = v50 >> 24;
  v51 = (((v89 & *((_QWORD *)&v89 + 1) & (v88.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v88.i64[0]
                                                                               + (v88.i64[1] & 0xFFFFFFFFFFLL)
                                                                               - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v52 = v51 != 0;
  v53 = v51 - 1;
  v54 = v52;
  v55 = v54 << 63 >> 63;
  v56 = *((_QWORD *)&v89 + 1) & v55 & 0xFFFFFFFFFFFFFFLL;
  v57 = v89 & v55;
  if (v52)
    v58 = -1;
  else
    v58 = 0xFFFFFFFFFFLL;
  v59 = v88.i64[0] - HIBYTE(*((_QWORD *)&v89 + 1)) + (v53 >> 63);
  v60 = v59 + ((unint64_t)v59 >> 63 << 56);
  v61 = (v58 & (v88.i64[1] + (HIBYTE(*((_QWORD *)&v89 + 1)) << 40))) + (v59 >> 63);
  v62 = v57 + (v61 >> 56);
  v63 = v56 + (v62 >> 56);
  a7[9] = v60 | (v61 << 56);
  a7[10] = ((unint64_t)v61 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v62 << 48);
  a7[11] = ((unint64_t)v62 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v63 << 40);
  a7[12] = v63 >> 24;
  v64 = (((v91 & *((_QWORD *)&v91 + 1) & (v90.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v90.i64[0]
                                                                               + (v90.i64[1] & 0xFFFFFFFFFFLL)
                                                                               - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v65 = v64 != 0;
  v66 = v64 - 1;
  v67 = v65;
  v68 = v67 << 63 >> 63;
  v69 = *((_QWORD *)&v91 + 1) & v68 & 0xFFFFFFFFFFFFFFLL;
  v70 = v91 & v68;
  if (v65)
    v44 = -1;
  v71 = v90.i64[0] - HIBYTE(*((_QWORD *)&v91 + 1)) + (v66 >> 63);
  v72 = v71 + ((unint64_t)v71 >> 63 << 56);
  v73 = (v44 & (v90.i64[1] + (HIBYTE(*((_QWORD *)&v91 + 1)) << 40))) + (v71 >> 63);
  v74 = v70 + (v73 >> 56);
  a7[18] = v72 | (v73 << 56);
  a7[19] = ((unint64_t)v73 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v74 << 48);
  v75 = (unint64_t)v74 >> 16;
  v76 = v69 + (v74 >> 56);
  a7[20] = v75 & 0xFFFFFFFFFFLL | ((unint64_t)v76 << 40);
  a7[21] = v76 >> 24;
}

void ec_GFp_nistp224_point_mul_base(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  double v7;
  double v8;
  double v9;
  double v10;
  int64x2_t v11;
  unint64_t v12;
  double v13;
  double v14;
  double v15;
  double v16;
  int64x2_t v17;
  double v18;
  double v19;
  double v20;
  double v21;
  int64x2_t v22;
  unint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  BOOL v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  _OWORD v63[2];
  int8x16_t v64[2];
  _OWORD v65[2];
  int8x16_t v66;
  __int128 v67;
  int8x16_t v68;
  int8x16_t v69;
  int8x16_t v70;
  __int128 v71;
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  v4 = a3[2];
  v61 = a3[3];
  v6 = *a3;
  v5 = a3[1];
  p224_select_point((v61 >> 28) & 8 | (v4 >> 37) & 4 | (v5 >> 46) & 2 | (*a3 >> 55) & 1, 16, (uint64_t)&unk_208F2EA30, (uint64_t)v63);
  v68 = v64[0];
  v69 = v64[1];
  v70 = (int8x16_t)v65[0];
  v71 = v65[1];
  v66 = (int8x16_t)v63[0];
  v67 = v63[1];
  p224_select_point(v61 & 8 | (v4 >> 9) & 4 | (v5 >> 18) & 2 | (v6 >> 27) & 1, 16, (uint64_t)&g_p224_pre_comp, (uint64_t)v63);
  p224_point_add(&v66, &v68, &v70, (unint64_t *)&v66, (int64x2_t *)&v68, (int64x2_t *)&v70, 1, (unint64_t *)v63, v7, v8, v9, v10, v11, v64, (unint64_t *)v65);
  v12 = 138;
  do
  {
    p224_point_double(&v66, &v68, &v70, (unint64_t *)&v66, (int64x2_t *)&v68, (int64x2_t *)&v70);
    p224_select_point((8* ((*(unint64_t *)((char *)a3 + (((v12 + 84) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v12 - 108)) & 1)) | (4 * ((*(unint64_t *)((char *)a3 + (((v12 + 28) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v12 - 100)) & 1)) | (2 * ((*(unint64_t *)((char *)a3 + (((v12 - 28) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v12 - 92)) & 1)) | (*(unint64_t *)((char *)a3 + (((v12 - 84) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v12 - 84)) & 1, 16, (uint64_t)&unk_208F2EA30, (uint64_t)v63);
    p224_point_add(&v66, &v68, &v70, (unint64_t *)&v66, (int64x2_t *)&v68, (int64x2_t *)&v70, 1, (unint64_t *)v63, v13, v14, v15, v16, v17, v64, (unint64_t *)v65);
    p224_select_point((8* ((*(unint64_t *)((char *)a3 + (((v12 + 56) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v12 + 56)) & 1)) | (4 * ((*(unint64_t *)((char *)a3 + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v12) & 1)) | (2 * ((*(unint64_t *)((char *)a3 + (((v12 - 56) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v12 - 56)) & 1)) | (*(unint64_t *)((char *)a3 + (((v12 - 112) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v12 - 112)) & 1, 16, (uint64_t)&g_p224_pre_comp, (uint64_t)v63);
    p224_point_add(&v66, &v68, &v70, (unint64_t *)&v66, (int64x2_t *)&v68, (int64x2_t *)&v70, 1, (unint64_t *)v63, v18, v19, v20, v21, v22, v64, (unint64_t *)v65);
    v23 = v12 - 113;
    --v12;
  }
  while (v23 < 0x1C);
  v24 = (((v67 & *((_QWORD *)&v67 + 1) & (v66.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v66.i64[0]
                                                                               + (v66.i64[1] & 0xFFFFFFFFFFLL)
                                                                               - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v25 = v24 != 0;
  v26 = v66.i64[0] - HIBYTE(*((_QWORD *)&v67 + 1)) + ((v24 - 1) >> 63);
  v27 = v26 + ((unint64_t)v26 >> 63 << 56);
  v28 = 0xFFFFFFFFFFLL;
  if (v25)
    v29 = -1;
  else
    v29 = 0xFFFFFFFFFFLL;
  v30 = (v29 & (v66.i64[1] + (HIBYTE(*((_QWORD *)&v67 + 1)) << 40))) + (v26 >> 63);
  v31 = v25;
  v32 = v31 << 63 >> 63;
  v33 = (v67 & v32) + (v30 >> 56);
  v34 = (*((_QWORD *)&v67 + 1) & v32 & 0xFFFFFFFFFFFFFFLL) + (v33 >> 56);
  *a2 = v27 | (v30 << 56);
  a2[1] = ((unint64_t)v30 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v33 << 48);
  a2[2] = ((unint64_t)v33 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v34 << 40);
  a2[3] = v34 >> 24;
  v35 = (((v69.i64[0] & v69.i64[1] & (v68.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v68.i64[0]
                                                                           + (v68.i64[1] & 0xFFFFFFFFFFLL)
                                                                           - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v36 = v35 != 0;
  v37 = v35 - 1;
  v38 = v36;
  v39 = v38 << 63 >> 63;
  v40 = v69.i64[1] & v39 & 0xFFFFFFFFFFFFFFLL;
  v41 = v69.i64[0] & v39;
  if (v36)
    v42 = -1;
  else
    v42 = 0xFFFFFFFFFFLL;
  v43 = v68.i64[0] - HIBYTE(v69.i64[1]) + (v37 >> 63);
  v44 = v43 + ((unint64_t)v43 >> 63 << 56);
  v45 = (v42 & (v68.i64[1] + (HIBYTE(v69.i64[1]) << 40))) + (v43 >> 63);
  v46 = v41 + (v45 >> 56);
  v47 = v40 + (v46 >> 56);
  a2[9] = v44 | (v45 << 56);
  a2[10] = ((unint64_t)v45 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v46 << 48);
  a2[11] = ((unint64_t)v46 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v47 << 40);
  a2[12] = v47 >> 24;
  v48 = (((v71 & *((_QWORD *)&v71 + 1) & (v70.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v70.i64[0]
                                                                               + (v70.i64[1] & 0xFFFFFFFFFFLL)
                                                                               - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v49 = v48 != 0;
  v50 = v48 - 1;
  v51 = v49;
  v52 = v51 << 63 >> 63;
  v53 = *((_QWORD *)&v71 + 1) & v52 & 0xFFFFFFFFFFFFFFLL;
  v54 = v71 & v52;
  if (v49)
    v28 = -1;
  v55 = v70.i64[0] - HIBYTE(*((_QWORD *)&v71 + 1)) + (v50 >> 63);
  v56 = v55 + ((unint64_t)v55 >> 63 << 56);
  v57 = (v28 & (v70.i64[1] + (HIBYTE(*((_QWORD *)&v71 + 1)) << 40))) + (v55 >> 63);
  v58 = v54 + (v57 >> 56);
  a2[18] = v56 | (v57 << 56);
  a2[19] = ((unint64_t)v57 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v58 << 48);
  v59 = (unint64_t)v58 >> 16;
  v60 = v53 + (v58 >> 56);
  a2[20] = v59 & 0xFFFFFFFFFFLL | ((unint64_t)v60 << 40);
  a2[21] = v60 >> 24;
}

void ec_GFp_nistp224_point_mul_public(double a1, double a2, double a3, double a4, int64x2_t a5, uint64_t a6, uint64_t *a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  double v12;
  double v13;
  int64x2_t v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int8x16_t v20;
  unint64_t v21;
  int8x16_t *v22;
  double v23;
  int8x16_t *v24;
  double v25;
  double v26;
  double v27;
  int64x2_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t *v32;
  int8x16_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __int128 v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned __int128 v48;
  signed __int128 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int8x16_t v53;
  __int128 v54;
  uint64_t v55;
  BOOL v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  BOOL v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  int8x16_t v93;
  int8x16_t v94;
  int8x16_t v95;
  int8x16_t v96;
  int8x16_t v97;
  int8x16_t v98;
  int8x16_t v99;
  int8x16_t v100;
  int8x16_t v101;
  int8x16_t v102;
  int8x16_t v103;
  int8x16_t v104;
  _OWORD v105[102];
  uint64_t v106;

  v106 = *MEMORY[0x24BDAC8D0];
  ec_GFp_nistp224_make_precomp((uint64_t)v105, a9, a1, a2, a3, a4, a5);
  v99 = 0u;
  v100 = 0u;
  v101 = 0u;
  v102 = 0u;
  v103 = 0u;
  v104 = 0u;
  v15 = 1;
  v16 = 220;
  do
  {
    if (v15)
    {
      if (v16 > 0x1B)
        goto LABEL_2;
    }
    else
    {
      p224_point_double(&v99, &v101, &v103, (unint64_t *)&v99, (int64x2_t *)&v101, (int64x2_t *)&v103);
      if (v16 > 0x1B)
        goto LABEL_2;
    }
    v20 = vandq_s8((int8x16_t)vshlq_u64(vshlq_u64(*(uint64x2_t *)(a8 + 1), (uint64x2_t)vsubq_s64((int64x2_t)xmmword_208F2E3D0, vdupq_n_s64(v16))), (uint64x2_t)xmmword_208F08A50), (int8x16_t)xmmword_208F2E3E0);
    v21 = *a8;
    v22 = (int8x16_t *)((char *)&g_p224_pre_comp
                      + 96
                      * (v20.i64[1] | (8 * (((unint64_t)a8[3] >> (v16 + 4)) & 1)) | v20.i64[0] | ((unint64_t)*a8 >> (v16 + 28)) & 1));
    *(_QWORD *)&v23 = p224_point_add(&v99, &v101, &v103, (unint64_t *)&v99, (int64x2_t *)&v101, (int64x2_t *)&v103, 1, (unint64_t *)&v22[96], *(double *)v20.i64, COERCE_DOUBLE(2), NAN, v13, v14, v22 + 98, (unint64_t *)&v22[100]).u64[0];
    v24 = (int8x16_t *)((char *)&g_p224_pre_comp
                      + 96
                      * ((v21 >> v16) & 1 | (8
                                           * ((*(unint64_t *)((char *)a8
                                                                                 + (((v16 + 168) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v16 - 88)) & 1)) | (4 * ((*(unint64_t *)((char *)a8 + (((v16 + 112) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v16 + 112)) & 1)) | (2 * ((*(unint64_t *)((char *)a8 + (((v16 + 56) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v16 + 56)) & 1))));
    p224_point_add(&v99, &v101, &v103, (unint64_t *)&v99, (int64x2_t *)&v101, (int64x2_t *)&v103, 1, (unint64_t *)v24, v23, v25, v26, v27, v28, v24 + 2, (unint64_t *)&v24[4]);
LABEL_2:
    if (-858993459 * v16 >= 0x33333334)
    {
      v17 = v16 - 1;
      goto LABEL_4;
    }
    if (v16 <= 0xDB)
    {
      v18 = (*(_QWORD *)(a10 + (((v16 + 4) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v16 + 4)) & 1;
      v17 = v16 - 1;
      if (v16 - 1 > 0xDF)
      {
LABEL_14:
        v19 = 0;
        goto LABEL_15;
      }
    }
    else
    {
      v18 = 0;
      v17 = v16 - 1;
      if (v16 - 1 > 0xDF)
        goto LABEL_14;
    }
    v19 = (*(_QWORD *)(a10 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v17) & 1;
LABEL_15:
    v29 = (2 * ((*(_QWORD *)(a10 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v16) & 1)) | v19 | (4
                                                                                               * ((*(_QWORD *)(a10 + (((v16 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v16 + 1)) & 1)) & 0xFFFFFFFFFFFFFFF7 | (8 * ((*(_QWORD *)(a10 + (((v16 + 2) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v16 + 2)) & 1)) | (32 * v18) | (16 * ((*(_QWORD *)(a10 + (((v16 + 3) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v16 + 3)) & 1));
    v30 = v18 + 0x7FFFFFFFFFFFFFFFLL;
    v31 = -v18;
    v32 = (int8x16_t *)&v105[6 * (((v29 ^ 0x3F) & v31 | v29 & v30) & 1) + 6 * (((v29 ^ 0x3F) & v31 | v29 & v30) >> 1)];
    v33 = v32[3];
    v95 = v32[2];
    v96 = v33;
    v34 = v32[5];
    v97 = v32[4];
    v98 = v34;
    v35 = *v32;
    v36 = v32[1];
    v93 = *v32;
    v94 = v36;
    if ((v31 & 1) != 0)
    {
      v38 = (((__PAIR128__(0x7FFFFFFFFFFFFF80, -256) - v96.u64[0]) >> 56) - v96.u64[1]) >> 64;
      v37 = ((__PAIR128__(0x7FFFFFFFFFFFFF80, -256) - v96.u64[0]) >> 56) - v96.i64[1];
      v56 = v37 >= 0x100;
      v39 = v37 - 256;
      if (v56)
        ++v38;
      v40 = (-256 - v96.i64[0]) & 0xFFFFFFFFFFFFFFLL;
      *((_QWORD *)&v42 + 1) = v38;
      *(_QWORD *)&v42 = v39;
      v41 = v42 >> 56;
      v43 = v39 & 0xFFFFFFFFFFFFFFLL;
      *((_QWORD *)&v42 + 1) = v38;
      *(_QWORD *)&v42 = v39;
      v44 = (v42 >> 16) & 0xFFFF0000000000;
      v45 = v41 + v95.i64[0];
      if (__CFADD__(v41, v95.i64[0]))
        v46 = HIBYTE(v38) + 1;
      else
        v46 = HIBYTE(v38);
      v56 = v45 <= 0x8100;
      v47 = 33024 - v45;
      *((_QWORD *)&v48 + 1) = 0x8000000000000001 - (v46 + !v56);
      *(_QWORD *)&v48 = v47;
      v49 = v44 - __PAIR128__(v44, v95.u64[1]) + (v48 >> 56) + __PAIR128__(0x7FFFFFFFFFFFFF80, 0xFF7EFFFFFFFFFF00);
      v50 = v49 >> 56;
      v56 = __CFADD__(v50, v40);
      v51 = v50 + v40;
      if (v56)
        v52 = HIBYTE(*((_QWORD *)&v49 + 1)) + 1;
      else
        v52 = HIBYTE(*((_QWORD *)&v49 + 1));
      v53.i64[0] = v47;
      v53.i64[1] = v49;
      v36.i64[0] = 0xFFFFFFFFFFFFFFLL;
      v36.i64[1] = 0xFFFFFFFFFFFFFFLL;
      v35 = vandq_s8(v53, v36);
      v95 = v35;
      *((_QWORD *)&v54 + 1) = v52;
      *(_QWORD *)&v54 = v51;
      v96.i64[0] = v51 & 0xFFFFFFFFFFFFFFLL;
      v96.i64[1] = (v54 >> 56) + v43;
    }
    if (v15)
    {
      v15 = 0;
      v101 = v95;
      v102 = v96;
      v103 = v97;
      v104 = v98;
      v99 = v93;
      v100 = v94;
    }
    else
    {
      p224_point_add(&v99, &v101, &v103, (unint64_t *)&v99, (int64x2_t *)&v101, (int64x2_t *)&v103, 0, (unint64_t *)&v93, *(double *)v35.i64, *(double *)v36.i64, v12, v13, v14, &v95, (unint64_t *)&v97);
    }
LABEL_4:
    v16 = v17;
  }
  while (v17 < 0xDD);
  v55 = (((v100.i64[0] & v100.i64[1] & (v99.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v99.i64[0]
                                                                             + (v99.i64[1] & 0xFFFFFFFFFFLL)
                                                                             - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v56 = v55 != 0;
  v57 = v99.i64[0] - HIBYTE(v100.i64[1]) + ((v55 - 1) >> 63);
  v58 = v57 + ((unint64_t)v57 >> 63 << 56);
  v59 = 0xFFFFFFFFFFLL;
  if (v56)
    v60 = -1;
  else
    v60 = 0xFFFFFFFFFFLL;
  v61 = (v60 & (v99.i64[1] + (HIBYTE(v100.i64[1]) << 40))) + (v57 >> 63);
  v62 = v56;
  v63 = v62 << 63 >> 63;
  v64 = (v100.i64[0] & v63) + (v61 >> 56);
  v65 = (v100.i64[1] & v63 & 0xFFFFFFFFFFFFFFLL) + (v64 >> 56);
  *a7 = v58 | (v61 << 56);
  a7[1] = ((unint64_t)v61 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v64 << 48);
  a7[2] = ((unint64_t)v64 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v65 << 40);
  a7[3] = v65 >> 24;
  v66 = (((v102.i64[0] & v102.i64[1] & (v101.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v101.i64[0]
                                                                              + (v101.i64[1] & 0xFFFFFFFFFFLL)
                                                                              - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v67 = v66 != 0;
  v68 = v66 - 1;
  v69 = v67;
  v70 = v69 << 63 >> 63;
  v71 = v102.i64[1] & v70 & 0xFFFFFFFFFFFFFFLL;
  v72 = v102.i64[0] & v70;
  if (v67)
    v73 = -1;
  else
    v73 = 0xFFFFFFFFFFLL;
  v74 = v101.i64[0] - HIBYTE(v102.i64[1]) + (v68 >> 63);
  v75 = v74 + ((unint64_t)v74 >> 63 << 56);
  v76 = (v73 & (v101.i64[1] + (HIBYTE(v102.i64[1]) << 40))) + (v74 >> 63);
  v77 = v72 + (v76 >> 56);
  v78 = v71 + (v77 >> 56);
  a7[9] = v75 | (v76 << 56);
  a7[10] = ((unint64_t)v76 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v77 << 48);
  a7[11] = ((unint64_t)v77 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v78 << 40);
  a7[12] = v78 >> 24;
  v79 = (((v104.i64[0] & v104.i64[1] & (v103.i64[1] | 0xFFFFFFFFFFLL)) + 1) | ((v103.i64[0]
                                                                              + (v103.i64[1] & 0xFFFFFFFFFFLL)
                                                                              - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v80 = v79 != 0;
  v81 = v79 - 1;
  v82 = v80;
  v83 = v82 << 63 >> 63;
  v84 = v104.i64[1] & v83 & 0xFFFFFFFFFFFFFFLL;
  v85 = v104.i64[0] & v83;
  if (v80)
    v59 = -1;
  v86 = v103.i64[0] - HIBYTE(v104.i64[1]) + (v81 >> 63);
  v87 = v86 + ((unint64_t)v86 >> 63 << 56);
  v88 = (v59 & (v103.i64[1] + (HIBYTE(v104.i64[1]) << 40))) + (v86 >> 63);
  v89 = v85 + (v88 >> 56);
  a7[18] = v87 | (v88 << 56);
  a7[19] = ((unint64_t)v88 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v89 << 48);
  v90 = (unint64_t)v89 >> 16;
  v91 = v84 + (v89 >> 56);
  a7[20] = v90 & 0xFFFFFFFFFFLL | ((unint64_t)v91 << 40);
  a7[21] = v91 >> 24;
}

unint64_t ec_GFp_nistp224_felem_mul(uint64_t a1, uint64_t *a2, uint64_t a3, __int128 *a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  signed __int128 v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unsigned __int128 v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unsigned __int128 v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  BOOL v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  __int128 v55;
  uint64_t v56;
  signed __int128 v57;
  unint64_t result;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  __int128 v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unsigned __int128 v90;

  v4 = *(_QWORD *)a3 & 0xFFFFFFFFFFFFFFLL;
  v5 = (*(__int128 *)a3 >> 56) & 0xFFFFFFFFFFFFFFLL;
  v6 = (*(__int128 *)(a3 + 8) >> 48) & 0xFFFFFFFFFFFFFFLL;
  v7 = (*(__int128 *)(a3 + 16) >> 40) & 0xFFFFFFFFFFFFFFLL;
  v8 = *(_QWORD *)a4 & 0xFFFFFFFFFFFFFFLL;
  v9 = (*a4 >> 56) & 0xFFFFFFFFFFFFFFLL;
  v10 = *((_QWORD *)a4 + 2);
  v11 = *((_QWORD *)a4 + 3);
  *((_QWORD *)&v12 + 1) = v10;
  *(_QWORD *)&v12 = *((_QWORD *)a4 + 1);
  v13 = (v12 >> 48) & 0xFFFFFFFFFFFFFFLL;
  *((_QWORD *)&v12 + 1) = v11;
  *(_QWORD *)&v12 = v10;
  v14 = (v12 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v15 = ((unint64_t)v8 * (unsigned __int128)(unint64_t)v4) >> 64;
  v16 = v8 * v4;
  v90 = v9 * (unsigned __int128)(unint64_t)v4;
  v89 = ((unint64_t)v8 * (unsigned __int128)v5) >> 64;
  v17 = v8 * v5;
  v18 = (v13 * (unsigned __int128)(unint64_t)v4) >> 64;
  v19 = v13 * v4;
  v20 = (v9 * (unsigned __int128)v5) >> 64;
  v21 = v9 * v5;
  v22 = ((unint64_t)v8 * (unsigned __int128)v6) >> 64;
  v23 = v8 * v6;
  v24 = (((v12 >> 40) & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)(unint64_t)v4) >> 64;
  v25 = v14 * v4;
  v26 = (v13 * (unsigned __int128)v5) >> 64;
  v27 = v13 * v5;
  v28 = (v9 * (unsigned __int128)v6) >> 64;
  v29 = v9 * v6;
  v30 = (v7 * (unsigned __int128)(unint64_t)v8) >> 64;
  v31 = v7 * v8;
  v32 = (((v12 >> 40) & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)v5) >> 64;
  v33 = v14 * v5;
  v34 = (v13 * (unsigned __int128)v6) >> 64;
  v35 = v13 * v6;
  v36 = ((v12 >> 40) & 0xFFFFFFFFFFFFFFLL) * v6 + v13 * (unsigned __int128)v7;
  v37 = (v9 * (unsigned __int128)v7) >> 64;
  v38 = v9 * v7;
  v39 = v14 * v7;
  v40 = (((v12 >> 40) & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)v7) >> 64;
  *((_QWORD *)&v12 + 1) = v40;
  *(_QWORD *)&v12 = v39;
  v41 = __PAIR128__(v34, v35) + __PAIR128__(v37, v38) + __PAIR128__(v32, v33) + ((unsigned __int128)v12 >> 16);
  v43 = v23 + v21 + v19 - v39;
  v42 = (__PAIR128__(v22, v23) + __PAIR128__(v20, v21) + __PAIR128__(v18, v19) - __PAIR128__(v40, v39)) >> 64;
  v44 = (unint64_t)(unsigned __int16)v36 << 40;
  if (__CFADD__(v43, v44))
    ++v42;
  v45 = __PAIR128__(v42, v43 + v44) + (v41 >> 16);
  v47 = (__PAIR128__(v28, v29) + __PAIR128__(v30, v31) + __PAIR128__(v26, v27) + __PAIR128__(v24, v25)) >> 64;
  v46 = v29 + v31 + v27 + v25;
  v48 = (unint64_t)(unsigned __int16)v39 << 40;
  v49 = __CFADD__(v46, v48);
  v50 = v46 + v48;
  v51 = v36 >> 16;
  if (v49)
    ++v47;
  v49 = __CFADD__(v50, v51);
  v52 = v50 + v51;
  v53 = (*((_QWORD *)&v36 + 1) >> 16) + v49 + v47;
  *((_QWORD *)&v55 + 1) = *((_QWORD *)&v45 + 1) + 0x7FFFFFFFFFFFFF80;
  *(_QWORD *)&v55 = v45;
  v54 = v55 >> 56;
  v49 = __CFADD__(v52, v54);
  v56 = v52 + v54;
  *((_QWORD *)&v55 + 1) = ((unint64_t)(*((_QWORD *)&v45 + 1) + 0x7FFFFFFFFFFFFF80) >> 56) + v49 + v53;
  *(_QWORD *)&v55 = v56;
  v57 = __PAIR128__(v15, v16) - (v41 + ((unsigned __int128)v55 >> 56)) + __PAIR128__(0x8000000000000000, 0x8000);
  result = v89;
  v60 = (__PAIR128__(v89, v17) + v90 - v36) >> 64;
  v59 = v17 + v90 - v36;
  v61 = (unint64_t)(unsigned __int16)v41 << 40;
  v49 = __CFADD__(v59, v61);
  v62 = v59 + v61;
  v63 = (v45 & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v55 + 1) >> 8);
  *(_QWORD *)&v55 = v56;
  v64 = v56 & 0xFFFFFFFFFFFFFFLL;
  v65 = (v55 >> 16) & 0xFFFF0000000000;
  if (v49)
    ++v60;
  v49 = __CFADD__(v62, v65);
  v66 = v62 + v65;
  if (v49)
    ++v60;
  v68 = v66 + (v57 >> 56) - 0x80000000000000;
  v67 = (__PAIR128__(v60, v66) + ((unsigned __int128)v57 >> 56) + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64;
  v69 = v57 & 0xFFFFFFFFFFFFFFLL;
  v70 = HIBYTE(v67);
  v71 = (__int128)__PAIR128__(v67, v68) >> 56;
  v49 = __CFADD__(v63, v71);
  v72 = v63 + v71;
  if (v49)
    v73 = v70 + 1;
  else
    v73 = v70;
  *((_QWORD *)&v74 + 1) = v73;
  *(_QWORD *)&v74 = v72;
  v75 = (v74 >> 56) + v64;
  v76 = v69 - HIBYTE(v75);
  v77 = (v68 & 0xFFFFFFFFFFFFFFLL) + (HIBYTE(v75) << 40);
  v78 = ((((v68 & 0xFFFF0000000000 | 0xFFFFFFFFFFLL) & v72 & v75) + 1) | ((uint64_t)(v69 + (v68 & 0xFFFFFFFFFFLL) - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v79 = 0xFFFFFFFFFFFFFFLL;
  if (!v78)
    v79 = 0;
  v80 = v79 & v75;
  v81 = v79 & v72;
  v82 = 0x1FFFFFFFFFFFFFFLL;
  if (!v78)
    v82 = 0xFFFFFFFFFFLL;
  v83 = v76 + ((v78 - 1) >> 63);
  v84 = v82 & v77;
  v85 = v83 + ((unint64_t)v83 >> 63 << 56);
  v86 = v84 + (v83 >> 63);
  v87 = v81 + (v86 >> 56);
  *a2 = v85 | (v86 << 56);
  a2[1] = ((unint64_t)v86 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v87 << 48);
  v88 = v80 + (v87 >> 56);
  a2[2] = ((unint64_t)v87 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v88 << 40);
  a2[3] = v88 >> 24;
  return result;
}

uint64_t ec_GFp_nistp224_felem_sqr(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int128 v16;
  unsigned __int128 v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  __int128 v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  BOOL v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  __int128 v37;
  unint64_t v38;
  unint64_t v39;
  unsigned __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t result;
  uint64_t v44;
  signed __int128 v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  __int128 v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;

  v3 = *(_QWORD *)a3 & 0xFFFFFFFFFFFFFFLL;
  v4 = (*(__int128 *)a3 >> 56) & 0xFFFFFFFFFFFFFFLL;
  v5 = (*(__int128 *)(a3 + 8) >> 48) & 0xFFFFFFFFFFFFFFLL;
  v6 = *(_OWORD *)(a3 + 16);
  v7 = (v6 >> 40) & 0xFFFFFFFFFFFFFFLL;
  v8 = 2 * v3;
  v9 = ((unint64_t)v3 * (unsigned __int128)(unint64_t)v3) >> 64;
  v10 = v3 * v3;
  v11 = (2 * v4 * (unsigned __int128)(unint64_t)v3) >> 64;
  v12 = 2 * v4 * v3;
  v13 = (2 * v5 * (unsigned __int128)(unint64_t)v3) >> 64;
  v14 = 2 * v5 * v3;
  v15 = v4 * v4;
  v16 = ((v6 >> 40) & 0xFFFFFFFFFFFFFFLL) * (unint64_t)v8 + 2 * v5 * (unsigned __int128)v4;
  v17 = ((v6 >> 40) & 0xFFFFFFFFFFFFFFLL) * 2 * v4 + v5 * (unsigned __int128)v5;
  v18 = v7 * 2 * v5;
  v19 = (((v6 >> 40) & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)(2 * v5)) >> 64;
  v20 = v7 * v7;
  v21 = (((v6 >> 40) & 0xFFFFFFFFFFFFFFLL) * ((v6 >> 40) & (unsigned __int128)0xFFFFFFFFFFFFFFLL)) >> 64;
  *((_QWORD *)&v6 + 1) = v21;
  *(_QWORD *)&v6 = v20;
  v22 = v17 + ((unsigned __int128)v6 >> 16);
  v23 = (unint64_t)(unsigned __int16)v20 << 40;
  *((_QWORD *)&v6 + 1) = v19;
  *(_QWORD *)&v6 = v18;
  v24 = v6 >> 16;
  v25 = v19 >> 16;
  v26 = (v18 << 40) & 0xFFFE0000000000;
  v27 = (__PAIR128__(v11, v12) - __PAIR128__(v19, v18)) >> 64;
  v28 = (unint64_t)(unsigned __int16)v22 << 40;
  v29 = __CFADD__(v12 - v18, v28);
  v30 = v12 - v18 + v28;
  if (v29)
    ++v27;
  v32 = v15 + v14 - v20;
  v31 = (__PAIR128__(v13 + __CFADD__(v15, v14) + ((v4 * (unsigned __int128)v4) >> 64), v15 + v14) - __PAIR128__(v21, v20)) >> 64;
  if (__CFADD__(v32, v26))
    ++v31;
  v33 = v32 + v26 + (v22 >> 16);
  v34 = ((__PAIR128__(v31, v32 + v26) + ((unsigned __int128)v22 >> 16)) >> 64) + 0x7FFFFFFFFFFFFF80;
  v35 = HIBYTE(v34);
  *((_QWORD *)&v37 + 1) = v34;
  *(_QWORD *)&v37 = v33;
  v36 = v37 >> 56;
  v38 = (v16 + __PAIR128__(v25, v24)) >> 64;
  v39 = v16 + v24 + v23;
  if (__CFADD__(v16 + v24, v23))
    ++v38;
  v40 = __PAIR128__(v38, v39) + __PAIR128__(v35, v36);
  v41 = ((__int128)(__PAIR128__(v38, v39) + __PAIR128__(v35, v36)) >> 16) & 0xFFFF0000000000;
  v29 = __CFADD__(v30, v41);
  v42 = v30 + v41;
  if (v29)
    ++v27;
  result = HIBYTE(*((_QWORD *)&v40 + 1));
  v44 = (v33 & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v40 + 1) >> 8);
  v45 = __PAIR128__(v9, v10) - (v22 + (v40 >> 56)) + __PAIR128__(0x8000000000000000, 0x8000);
  v46 = (__PAIR128__(HIBYTE(*((_QWORD *)&v45 + 1)) + (unint64_t)__CFADD__(v42, (unint64_t)(v45 >> 56)) + v27, v42 + (unint64_t)(v45 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64;
  v47 = v42 + (v45 >> 56) - 0x80000000000000;
  v48 = v45 & 0xFFFFFFFFFFFFFFLL;
  v49 = HIBYTE(v46);
  v50 = (__int128)__PAIR128__(v46, v47) >> 56;
  v29 = __CFADD__(v44, v50);
  v51 = v44 + v50;
  if (v29)
    v52 = v49 + 1;
  else
    v52 = v49;
  *((_QWORD *)&v53 + 1) = v52;
  *(_QWORD *)&v53 = v51;
  v54 = (v53 >> 56) + (v40 & 0xFFFFFFFFFFFFFFLL);
  v55 = v48 - HIBYTE(v54);
  v56 = (v47 & 0xFFFFFFFFFFFFFFLL) + (HIBYTE(v54) << 40);
  v57 = ((((v47 & 0xFFFF0000000000 | 0xFFFFFFFFFFLL) & v51 & v54) + 1) | ((uint64_t)(v48 + (v47 & 0xFFFFFFFFFFLL) - 1) >> 63)) & 0xFFFFFFFFFFFFFFLL;
  v58 = 0xFFFFFFFFFFFFFFLL;
  if (!v57)
    v58 = 0;
  v59 = v58 & v51;
  v60 = 0x1FFFFFFFFFFFFFFLL;
  if (!v57)
    v60 = 0xFFFFFFFFFFLL;
  v61 = v55 + ((v57 - 1) >> 63);
  v62 = v60 & v56;
  v63 = v61 + ((unint64_t)v61 >> 63 << 56);
  v64 = v62 + (v61 >> 63);
  v65 = v59 + (v64 >> 56);
  v66 = (v58 & v54) + (v65 >> 56);
  *a2 = v63 | (v64 << 56);
  a2[1] = ((unint64_t)v64 >> 8) & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v65 << 48);
  a2[2] = ((unint64_t)v65 >> 16) & 0xFFFFFFFFFFLL | ((unint64_t)v66 << 40);
  a2[3] = v66 >> 24;
  return result;
}

int8x16_t p224_point_add(int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, unint64_t *a4, int64x2_t *a5, int64x2_t *a6, int a7, unint64_t *a8, double a9, double a10, double a11, double a12, int64x2_t a13, int8x16_t *a14, unint64_t *a15)
{
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned __int128 v19;
  signed __int128 v20;
  unint64_t v21;
  uint64_t v22;
  unsigned __int128 v23;
  unint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  __int128 v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unsigned __int128 v39;
  uint64_t v40;
  unint64_t v41;
  unsigned __int128 v42;
  uint64_t v43;
  signed __int128 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __int128 v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unsigned __int128 v59;
  unsigned __int128 v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unsigned __int128 v69;
  unint64_t v70;
  uint64_t v71;
  unsigned __int128 v72;
  unint64_t v73;
  unint64_t v74;
  unsigned __int128 v75;
  unint64_t v76;
  unint64_t v77;
  __int128 v78;
  unint64_t v79;
  unint64_t v80;
  signed __int128 v81;
  uint64_t v82;
  uint64_t v83;
  signed __int128 v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  signed __int128 v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  __int128 v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  signed __int128 v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  signed __int128 v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  uint64_t v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unsigned __int128 v124;
  uint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  __int128 v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  unint64_t v134;
  uint64_t v135;
  signed __int128 v136;
  unint64_t v137;
  uint64_t v138;
  unint64_t v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  __int128 v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  __int128 v147;
  unint64_t v148;
  unint64_t v149;
  uint64_t v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  uint64_t v154;
  unsigned __int128 v155;
  signed __int128 v156;
  unint64_t v157;
  uint64_t v158;
  unint64_t v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  unint64_t v163;
  __int128 v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  unint64_t v169;
  unint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t v176;
  unsigned __int128 v177;
  signed __int128 v178;
  unint64_t v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  unint64_t v190;
  __int128 v191;
  uint64_t v192;
  uint64_t v193;
  int8x16_t v194;
  unint64_t v195;
  unint64_t v196;
  unsigned __int128 v197;
  signed __int128 v198;
  unint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  unint64_t v203;
  unint64_t v204;
  unint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unint64_t v209;
  unint64_t v210;
  unint64_t v211;
  __int128 v212;
  unint64_t v213;
  uint64_t v214;
  unint64_t v215;
  unsigned __int128 v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  signed __int128 v220;
  uint64_t v221;
  uint64_t v222;
  unint64_t v223;
  __int128 v224;
  unint64_t v225;
  uint64_t v226;
  unint64_t v227;
  uint64_t v228;
  unsigned __int128 v229;
  unsigned __int128 v230;
  uint64_t v231;
  unint64_t v232;
  unint64_t v233;
  unint64_t v234;
  unsigned __int128 v235;
  unint64_t v236;
  unint64_t v237;
  uint64_t v238;
  unint64_t v239;
  unint64_t v240;
  unsigned __int128 v241;
  unsigned __int128 v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  unint64_t v246;
  uint64_t v247;
  uint64_t v248;
  unint64_t v249;
  unint64_t v250;
  unint64_t v251;
  uint64_t v252;
  unint64_t v253;
  uint64_t v254;
  __int128 v255;
  unint64_t v256;
  uint64_t v257;
  int8x16_t v258;
  uint64_t v259;
  unint64_t v260;
  uint64_t v261;
  unint64_t v262;
  unint64_t v263;
  uint64_t v264;
  signed __int128 v265;
  unsigned __int16 v266;
  unint64_t v267;
  unint64_t v268;
  unint64_t v269;
  uint64_t v270;
  unint64_t v271;
  unint64_t v272;
  unsigned __int128 v273;
  unsigned __int128 v274;
  unint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  unint64_t v279;
  unint64_t v280;
  unint64_t v281;
  uint64_t v282;
  unint64_t v283;
  uint64_t v284;
  unint64_t v285;
  unint64_t v286;
  unint64_t v287;
  unint64_t v288;
  __int128 v289;
  unint64_t v290;
  unint64_t v291;
  unint64_t v292;
  uint64_t v293;
  __int128 v294;
  uint64_t v295;
  uint64_t v296;
  unsigned __int128 v297;
  unint64_t v298;
  uint64_t v299;
  uint64_t v300;
  unint64_t v301;
  signed __int128 v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  __int128 v306;
  unint64_t v307;
  unint64_t v308;
  unint64_t v309;
  unint64_t v310;
  unsigned __int128 v311;
  unint64_t v312;
  unint64_t v313;
  uint64_t v314;
  unint64_t v315;
  unint64_t v316;
  unint64_t v317;
  unint64_t v318;
  unint64_t v319;
  unsigned __int128 v320;
  uint64_t v321;
  unsigned __int128 v322;
  unint64_t v323;
  unint64_t v324;
  unsigned __int128 v325;
  unint64_t v326;
  unsigned __int128 v327;
  unint64_t v328;
  __int128 v329;
  unsigned __int128 v330;
  uint64_t v331;
  unint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  unint64_t v338;
  uint64_t v339;
  __int128 v340;
  uint64_t v341;
  unint64_t v342;
  uint64_t v343;
  unint64_t v344;
  uint64_t v345;
  unint64_t v346;
  unint64_t v347;
  signed __int128 v348;
  uint64_t v349;
  BOOL v350;
  uint64_t v351;
  uint64_t v352;
  __int128 v353;
  uint64_t v354;
  int8x16_t v355;
  int8x16_t v356;
  int8x16_t v357;
  int64x2_t v358;
  int8x16_t v359;
  int8x16_t v360;
  int8x16_t v361;
  int8x16_t v362;
  unint64_t v363;
  unint64_t v364;
  unint64_t v365;
  unint64_t v366;
  uint64_t v367;
  int8x16_t result;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  unsigned __int128 v374;
  unsigned __int128 v375;
  unint64_t v376;
  uint64_t v377;
  unint64_t v378;
  unint64_t v379;
  uint64_t v380;
  unint64_t v381;
  unint64_t v382;
  uint64_t v383;
  unint64_t v384;
  unsigned __int128 v385;
  unsigned __int128 v386;
  uint64_t v387;
  unint64_t v388;
  unint64_t v389;
  uint64_t v390;
  uint64_t v391;
  unint64_t v392;
  signed __int128 v393;
  uint64_t v394;
  __int128 v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  unsigned __int128 v400;
  unsigned __int128 v401;
  unint64_t v402;
  uint64_t v403;
  unint64_t v404;
  unint64_t v405;
  unsigned __int128 v406;
  unint64_t v407;
  uint64_t v408;
  unint64_t v409;
  unint64_t v410;
  unsigned __int128 v411;
  unsigned __int128 v412;
  uint64_t v413;
  unint64_t v414;
  uint64_t v415;
  unsigned __int128 v416;
  unint64_t v417;
  uint64_t v418;
  unint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  __int128 v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  unint64_t v428;
  uint64_t v429;
  unint64_t v430;
  unint64_t v431;
  unsigned __int128 v432;
  unint64_t v433;
  uint64_t v434;
  unint64_t v435;
  unint64_t v436;
  unsigned __int128 v437;
  uint64_t v438;
  uint64_t v439;
  unint64_t v440;
  unint64_t v441;
  unsigned __int128 v442;
  signed __int128 v443;
  uint64_t v444;
  unint64_t v445;
  uint64_t v446;
  uint64_t v447;
  __int128 v448;
  unint64_t v449;
  uint64_t v450;
  uint64_t v451;
  unsigned __int128 v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  unint64_t v457;
  unint64_t v458;
  unint64_t v459;
  unsigned __int128 v460;
  unsigned __int128 v461;
  uint64_t v462;
  unsigned __int128 v463;
  unint64_t v464;
  unint64_t v465;
  unsigned __int128 v466;
  signed __int128 v467;
  uint64_t v468;
  unint64_t v469;
  uint64_t v470;
  unint64_t v471;
  unsigned __int128 v472;
  uint64_t v473;
  unsigned __int128 v474;
  unint64_t v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  unint64_t v479;
  signed __int128 v480;
  uint64_t v481;
  uint64_t v482;
  uint64_t v483;
  __int128 v484;
  unsigned __int128 v485;
  unint64_t v486;
  unint64_t v487;
  unint64_t v488;
  unint64_t v489;
  uint64_t v490;
  uint64_t v491;
  unint64_t v492;
  uint64_t v493;
  unint64_t v494;
  uint64_t v495;
  unint64_t v496;
  uint64_t v497;
  unint64_t v498;
  unint64_t v499;
  unsigned __int128 v500;
  unint64_t v501;
  unint64_t v502;
  unint64_t v503;
  unint64_t v504;
  unsigned __int128 v505;
  unsigned __int128 v506;
  unint64_t v507;
  unint64_t v508;
  uint64_t v509;
  unsigned __int128 v510;
  __int128 v511;
  uint64_t v512;
  unint64_t v513;
  uint64_t v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  unint64_t v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  uint64_t v522;
  __int128 v523;
  uint64_t v524;
  unint64_t v525;
  uint64_t v526;
  uint64_t v527;
  __int128 v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  __int128 v532;
  uint64_t v533;
  uint64_t v534;
  unint64_t v535;
  uint64_t v536;
  unint64_t v537;
  unint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  unsigned __int128 v542;
  uint64_t v543;
  uint64_t v544;
  unint64_t v545;
  uint64_t v546;
  uint64_t v547;
  unint64_t v548;
  uint64_t v549;
  unint64_t v550;
  uint64_t v551;
  unint64_t v552;
  unint64_t v553;
  unint64_t v554;
  __int128 v555;
  unsigned __int128 v556;
  uint64_t v557;
  unint64_t v558;
  uint64_t v559;
  unint64_t v560;
  unint64_t v561;
  unsigned __int128 v562;
  signed __int128 v563;
  unint64_t v564;
  unint64_t v565;
  uint64_t v566;
  uint64_t v567;
  unint64_t v568;
  uint64_t v569;
  uint64_t v570;
  uint64_t v571;
  unint64_t v572;
  uint64_t v573;
  __int128 v574;
  uint64_t v575;
  uint64_t v576;
  uint64_t v577;
  uint64_t v578;
  unint64_t v579;
  uint64_t v580;
  uint64_t v581;
  unint64_t v582;
  __int128 v583;
  uint64_t v584;
  uint64_t v585;
  uint64_t v586;
  uint64_t v587;
  unint64_t v588;
  int8x16_t v589;
  uint64_t v590;
  uint64_t v591;
  uint64_t v592;
  uint64_t v593;
  unint64_t v594;
  uint64_t v595;
  unint64_t v596;
  uint64_t v597;
  unint64_t v598;
  uint64_t v599;
  unint64_t v600;
  uint64_t v601;
  uint64_t v602;
  uint64_t v603;
  uint64_t v604;
  uint64_t v605;
  uint64_t v606;
  unsigned __int128 v607;
  unint64_t v608;
  unsigned __int128 v609;
  unsigned __int128 v610;
  uint64_t v611;
  unsigned __int128 v612;
  unint64_t v613;
  uint64_t v614;
  unint64_t v615;
  uint64_t v616;
  unint64_t v617;
  unint64_t v618;
  unsigned __int128 v619;
  unsigned __int128 v620;
  unsigned __int128 v621;
  unint64_t v622;
  uint64_t v623;
  uint64_t v624;
  uint64_t v625;
  __int128 v626;
  uint64_t v627;
  unsigned __int128 v628;
  unint64_t v629;
  uint64_t v630;
  unint64_t v631;
  uint64_t v632;
  uint64_t v633;
  uint64_t v634;
  unint64_t v635;
  signed __int128 v636;
  uint64_t v637;
  uint64_t v638;
  int8x16_t v639;
  uint64_t v640;
  uint64_t v641;
  __int128 v642;
  int8x16_t v643;
  int8x16_t v644;
  uint64_t v645;
  unint64_t v646;
  unint64_t v647;
  uint64_t v648;
  uint64_t v649;
  uint64_t v650;
  uint64_t v651;
  unint64_t v652;
  uint64_t v653;
  unint64_t v654;
  uint64_t v655;
  uint64_t v656;
  uint64_t v657;
  uint64_t v658;
  uint64_t v659;
  unint64_t v660;
  unint64_t v661;
  unint64_t v662;
  unint64_t v663;
  unint64_t v664;
  unint64_t v665;
  unint64_t v666;
  uint64_t v667;
  unint64_t v668;
  unint64_t v669;
  unint64_t v670;
  unint64_t v671;
  unsigned __int128 v672;
  unint64_t v673;
  unint64_t v674;
  uint64_t v675;
  unsigned __int128 v676;
  uint64_t v678;
  unint64_t v679;
  uint64_t v680;
  unint64_t v681;
  uint64_t v682;
  uint64_t v683;
  uint64_t v685;
  unint64_t v686;
  int64x2_t *v687;
  uint64_t v688;
  unint64_t v690;
  uint64_t v693;
  uint64_t v694;
  unint64_t v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  uint64_t v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v705;
  unint64_t v706;
  uint64_t v707;
  unint64_t v708;
  uint64_t v709;
  uint64_t v711;

  v687 = a6;
  if (a7)
  {
    v700 = a5->i64[1];
    v701 = a5->i64[0];
    v702 = a5[1].i64[1];
    v697 = a4[1];
    v699 = a5[1].i64[0];
    v693 = a4[2];
    v695 = *a4;
    v706 = a4[3];
  }
  else
  {
    v15 = *a15;
    v16 = a15[1];
    v18 = a15[2];
    v17 = a15[3];
    v19 = v17 * (unsigned __int128)(2 * *a15) + 2 * v18 * (unsigned __int128)v16;
    v20 = v17 * (unsigned __int128)(2 * v16) + v18 * (unsigned __int128)v18 + ((v17 * (unsigned __int128)v17) >> 16);
    v21 = (unint64_t)(unsigned __int16)(v17 * v17) << 40;
    v22 = ((v17 * 2 * v18) << 40) & 0xFFFE0000000000;
    v23 = 2 * v16 * (unsigned __int128)*a15 - v17 * (unsigned __int128)(2 * v18);
    v24 = (unint64_t)(unsigned __int16)(v17 * 2 * v16 + v18 * v18 + ((v17 * v17) >> 16)) << 40;
    v25 = __CFADD__((_QWORD)v23, v24);
    v26 = v23 + v24;
    if (v25)
      v27 = *((_QWORD *)&v23 + 1) + 1;
    else
      v27 = (2 * v16 * (unsigned __int128)*a15 - v17 * (unsigned __int128)(2 * v18)) >> 64;
    v28 = v20 >> 16;
    v29 = (v16 * (unsigned __int128)v16 + 2 * v18 * (unsigned __int128)*a15 - v17 * (unsigned __int128)v17) >> 64;
    v30 = v16 * v16 + 2 * v18 * *a15 - v17 * v17;
    v25 = __CFADD__(v30, v22);
    v31 = v30 + v22;
    if (v25)
      ++v29;
    v32 = ((__PAIR128__(v29, v31) + ((unsigned __int128)v20 >> 16)) >> 64) + 0x7FFFFFFFFFFFFF80;
    v33 = HIBYTE(v32);
    *((_QWORD *)&v35 + 1) = v32;
    *(_QWORD *)&v35 = v31 + v28;
    v34 = v35 >> 56;
    v37 = (v19 + ((v17 * (unsigned __int128)(2 * v18)) >> 16)) >> 64;
    v36 = v19 + ((v17 * (unsigned __int128)(2 * v18)) >> 16);
    v25 = __CFADD__(v36, v21);
    v38 = v36 + v21;
    if (v25)
      ++v37;
    v39 = __PAIR128__(v37, v38) + __PAIR128__(v33, v34);
    v40 = ((__int128)(__PAIR128__(v37, v38) + __PAIR128__(v33, v34)) >> 16) & 0xFFFF0000000000;
    v25 = __CFADD__(v26, v40);
    v41 = v26 + v40;
    if (v25)
      ++v27;
    v42 = v15 * (unsigned __int128)v15 - (v20 + (v39 >> 56)) + __PAIR128__(0x8000000000000000, 0x8000);
    v43 = ((v31 + v28) & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v39 + 1) >> 8);
    v44 = __PAIR128__(v27, v41) + (v42 >> 56) + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000);
    v45 = v44 >> 56;
    v25 = __CFADD__(v43, v45);
    v46 = v43 + v45;
    if (v25)
      v47 = HIBYTE(*((_QWORD *)&v44 + 1)) + 1;
    else
      v47 = HIBYTE(*((_QWORD *)&v44 + 1));
    *((_QWORD *)&v48 + 1) = v47;
    *(_QWORD *)&v48 = v46;
    v49 = (v48 >> 56) + (v39 & 0xFFFFFFFFFFFFFFLL);
    v50 = v42 & 0xFFFFFFFFFFFFFFLL;
    v51 = ((v42 & 0xFFFFFFFFFFFFFFLL) * v15) >> 64;
    v52 = (v42 & 0xFFFFFFFFFFFFFFLL) * v15;
    v53 = v44 & 0xFFFFFFFFFFFFFFLL;
    v54 = ((v44 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)v15) >> 64;
    v55 = (v44 & 0xFFFFFFFFFFFFFFLL) * v15;
    v56 = v46 & 0xFFFFFFFFFFFFFFLL;
    v57 = ((unint64_t)v56 * (unsigned __int128)v15) >> 64;
    v58 = v56 * v15;
    v59 = v49 * (unsigned __int128)v18 + (unint64_t)v56 * (unsigned __int128)v17;
    v60 = (unint64_t)v56 * (unsigned __int128)v18
        + (v44 & 0xFFFFFFFFFFFFFFLL) * v17
        + v49 * (unsigned __int128)v16
        + ((v49 * (unsigned __int128)v17) >> 16);
    v61 = (v42 & 0xFFFFFFFFFFFFFFLL) * v17;
    v62 = ((v44 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)v18) >> 64;
    v63 = (v44 & 0xFFFFFFFFFFFFFFLL) * v18;
    v64 = ((v42 & 0xFFFFFFFFFFFFFFLL) * v18 + (v44 & 0xFFFFFFFFFFFFFFLL) * v16) >> 64;
    v65 = (v42 & 0xFFFFFFFFFFFFFFLL) * v18 + (v44 & 0xFFFFFFFFFFFFFFLL) * v16;
    v66 = (v49 * (unsigned __int128)v15) >> 64;
    v67 = v49 * v15;
    v69 = __PAIR128__(v64, v65) + __PAIR128__(v57, v58);
    v68 = (__PAIR128__(v64, v65) + __PAIR128__(v57, v58)) >> 64;
    v70 = (unint64_t)(unsigned __int16)(((v48 >> 56) + v39) * v17) << 40;
    v72 = __PAIR128__(v68, v69) - v49 * (unsigned __int128)v17;
    v71 = *((_QWORD *)&v72 + 1);
    v73 = (unint64_t)(unsigned __int16)v59 << 40;
    v74 = v72 + v73;
    if (__CFADD__((_QWORD)v72, v73))
      v71 = *((_QWORD *)&v72 + 1) + 1;
    v75 = __PAIR128__(v71, v74) + (v60 >> 16);
    v76 = (unint64_t)(unsigned __int16)v60 << 40;
    *((_QWORD *)&v78 + 1) = *((_QWORD *)&v75 + 1) + 0x7FFFFFFFFFFFFF80;
    *(_QWORD *)&v78 = v74 + (v60 >> 16);
    v77 = v78 >> 56;
    v80 = v63 + v61 + v56 * v16 + v67;
    v79 = (__PAIR128__((((unint64_t)v50 * (unsigned __int128)v17) >> 64) + __CFADD__(v63, v61) + v62, v63 + v61)
         + (unint64_t)v56 * (unsigned __int128)v16
         + __PAIR128__(v66, v67)) >> 64;
    if (__CFADD__(v80, v70))
      ++v79;
    v81 = __PAIR128__(v79, v80 + v70)
        + (v59 >> 16)
        + __PAIR128__((unint64_t)(*((_QWORD *)&v75 + 1) + 0x7FFFFFFFFFFFFF80) >> 56, v77);
    v82 = (v75 & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v81 + 1) >> 8);
    v83 = (v81 >> 16) & 0xFFFF0000000000;
    v84 = __PAIR128__(v51, v52) - (v60 + ((unsigned __int128)v81 >> 56)) + __PAIR128__(0x8000000000000000, 0x8000);
    v85 = v84 >> 56;
    v86 = HIBYTE(*((_QWORD *)&v84 + 1));
    v87 = ((v42 & 0xFFFFFFFFFFFFFFLL) * v16 + __PAIR128__(v54, v55) - v59) >> 64;
    v88 = (v42 & 0xFFFFFFFFFFFFFFLL) * v16 + v55 - v59;
    v25 = __CFADD__(v88, v76);
    v89 = v88 + v76;
    if (v25)
      ++v87;
    v25 = __CFADD__(v89, v83);
    v90 = v89 + v83;
    if (v25)
      ++v87;
    v91 = __PAIR128__(v86 + (unint64_t)__CFADD__(v90, v85) + v87, v90 + v85)
        + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000);
    v92 = (unint64_t)((__PAIR128__(v86 + (unint64_t)__CFADD__(v90, v85) + v87, v90 + v85)
                            + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64) >> 56;
    v93 = v91 >> 56;
    v25 = __CFADD__(v82, v93);
    v94 = v82 + v93;
    if (v25)
      ++v92;
    *((_QWORD *)&v95 + 1) = v92;
    *(_QWORD *)&v95 = v94;
    v96 = (v95 >> 56) + (v81 & 0xFFFFFFFFFFFFFFLL);
    v97 = a5->i64[1];
    v707 = ((v84 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)(unint64_t)v97) >> 64;
    v703 = (v84 & 0xFFFFFFFFFFFFFFLL) * v97;
    v98 = (v91 & 0xFFFFFFFFFFFFFFLL) * a5->i64[0];
    v99 = a5[1].i64[0];
    v100 = a5[1].i64[1];
    v101 = ((v91 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)(unint64_t)v97) >> 64;
    v102 = (v91 & 0xFFFFFFFFFFFFFFLL) * v97;
    v103 = v94 & 0xFFFFFFFFFFFFFFLL;
    v105 = ((unint64_t)v103 * (unsigned __int128)(unint64_t)v99
          + (v91 & 0xFFFFFFFFFFFFFFLL) * (unint64_t)v100
          + v96 * (unsigned __int128)(unint64_t)v97) >> 64;
    v104 = v103 * v99 + (v91 & 0xFFFFFFFFFFFFFFLL) * v100 + v96 * v97;
    v106 = v96 * (unsigned __int128)(unint64_t)v99
         + (unint64_t)v103 * (unsigned __int128)(unint64_t)v100;
    v107 = ((unint64_t)v103 * (unsigned __int128)(unint64_t)v97) >> 64;
    v108 = v103 * v97;
    v109 = ((v84 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)(unint64_t)v100) >> 64;
    v110 = (v84 & 0xFFFFFFFFFFFFFFLL) * v100;
    v111 = (v96 * (unsigned __int128)a5->u64[0]) >> 64;
    v112 = v96 * a5->i64[0];
    v113 = v96 * v100;
    v115 = v96 * (unsigned __int128)(unint64_t)v100;
    v114 = v115 >> 16;
    v25 = __CFADD__(v104, v114);
    v116 = v104 + v114;
    v117 = (*((_QWORD *)&v115 + 1) >> 16) + v25 + v105;
    v118 = (unint64_t)(unsigned __int16)v113 << 40;
    v120 = ((v84 & 0xFFFFFFFFFFFFFFLL) * (unint64_t)v99
          + __PAIR128__(v101, v102)
          + (unint64_t)v103 * (unsigned __int128)a5->u64[0]
          - __PAIR128__(*((unint64_t *)&v115 + 1), v113)) >> 64;
    v119 = (v84 & 0xFFFFFFFFFFFFFFLL) * v99 + v102 + v103 * a5->i64[0] - v113;
    v121 = (unint64_t)(unsigned __int16)v106 << 40;
    v25 = __CFADD__(v119, v121);
    v122 = v119 + v121;
    *((_QWORD *)&v115 + 1) = v117;
    *(_QWORD *)&v115 = v116;
    v123 = v115 >> 16;
    if (v25)
      ++v120;
    v124 = __PAIR128__(v120, v122) + __PAIR128__(v117 >> 16, v123);
    v125 = v106 >> 16;
    v126 = (unint64_t)(unsigned __int16)v116 << 40;
    v127 = (unint64_t)(*((_QWORD *)&v124 + 1) + 0x7FFFFFFFFFFFFF80) >> 56;
    *((_QWORD *)&v129 + 1) = *((_QWORD *)&v124 + 1) + 0x7FFFFFFFFFFFFF80;
    *(_QWORD *)&v129 = v124;
    v128 = v129 >> 56;
    v131 = (v91 & 0xFFFFFFFFFFFFFFLL) * v99 + v110 + v108 + v112;
    v130 = ((v91 & 0xFFFFFFFFFFFFFFLL) * (unint64_t)v99
          + __PAIR128__(v109, v110)
          + __PAIR128__(v107, v108)
          + __PAIR128__(v111, v112)) >> 64;
    v132 = v131 + v118;
    if (__CFADD__(v131, v118))
      ++v130;
    v133 = (v132 + v125 + v128) & 0xFFFFFFFFFFFFFFLL;
    v134 = (v124 & 0xFFFFFFFFFFFFFFLL)
         + ((unint64_t)((__PAIR128__((*((_QWORD *)&v106 + 1) >> 16) + (unint64_t)__CFADD__(v132, v125) + v130, v132 + v125)+ __PAIR128__(v127, v128)) >> 64) >> 8);
    v135 = ((__int128)(__PAIR128__((*((_QWORD *)&v106 + 1) >> 16) + (unint64_t)__CFADD__(v132, v125) + v130, v132 + v125)+ __PAIR128__(v127, v128)) >> 16) & 0xFFFF0000000000;
    v136 = (v84 & 0xFFFFFFFFFFFFFFLL) * a5->u64[0]
         - (__PAIR128__(v117, v116)
          + ((__PAIR128__((*((_QWORD *)&v106 + 1) >> 16) + (unint64_t)__CFADD__(v132, v125) + v130, v132 + v125)
            + __PAIR128__((unint64_t)(*((_QWORD *)&v124 + 1) + 0x7FFFFFFFFFFFFF80) >> 56, v128)) >> 56))
         + __PAIR128__(0x8000000000000000, 0x8000);
    v137 = (__PAIR128__((((v91 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)a5->u64[0]) >> 64) + __CFADD__(v703, v98) + v707, v703 + v98)- v106) >> 64;
    v138 = v703 + v98 - v106 + v126;
    if (__CFADD__(v703 + v98 - v106, v126))
      ++v137;
    v25 = __CFADD__(v138, v135);
    v139 = v138 + v135;
    if (v25)
      v140 = v137 + 1;
    else
      v140 = v137;
    v141 = v139 + (v136 >> 56) - 0x80000000000000;
    *((_QWORD *)&v143 + 1) = __CFADD__(v139 + (v136 >> 56), 0xFF80000000000000)
                           + ((__PAIR128__(v140, v139) + ((unsigned __int128)v136 >> 56)) >> 64)
                           + 0x7FFFFFFFFFFFFF7FLL;
    *(_QWORD *)&v143 = v141;
    v142 = v143 >> 56;
    v144 = HIBYTE(*((_QWORD *)&v143 + 1));
    v145 = v134 + v142;
    if (__CFADD__(v134, v142))
      v146 = v144 + 1;
    else
      v146 = v144;
    *((_QWORD *)&v147 + 1) = v146;
    *(_QWORD *)&v147 = v145;
    v702 = (v147 >> 56) + v133;
    v148 = a4[1];
    v149 = ((unint64_t)v50 * (unsigned __int128)*a4) >> 64;
    v708 = ((unint64_t)v50 * (unsigned __int128)v148) >> 64;
    v150 = v50 * v148;
    v151 = a4[2];
    v152 = a4[3];
    v153 = ((unint64_t)v50 * (unsigned __int128)v151) >> 64;
    v154 = v50 * v151;
    v155 = (unint64_t)v56 * (unsigned __int128)v151
         + (unint64_t)v53 * (unsigned __int128)v152
         + v49 * (unsigned __int128)v148;
    v156 = v49 * (unsigned __int128)v151 + (unint64_t)v56 * (unsigned __int128)v152;
    v157 = ((unint64_t)v56 * (unsigned __int128)v148) >> 64;
    v158 = v56 * v148;
    v159 = v50 * *a4;
    v160 = ((unint64_t)v50 * (unsigned __int128)v152) >> 64;
    v161 = v50 * v152;
    v162 = v49 * v152;
    v163 = (v49 * (unsigned __int128)v152) >> 64;
    *((_QWORD *)&v147 + 1) = v163;
    *(_QWORD *)&v147 = v162;
    v164 = v155 + ((unsigned __int128)v147 >> 16);
    v166 = v154 + v53 * v148;
    v165 = (__PAIR128__(v153, v154) + (unint64_t)v53 * (unsigned __int128)v148) >> 64;
    a6 = v687;
    v168 = v166 + v56 * *a4 - v162;
    v167 = (__PAIR128__(v165, v166) + (unint64_t)v56 * (unsigned __int128)*a4 - __PAIR128__(v163, v162)) >> 64;
    v169 = (unint64_t)(unsigned __int16)v156 << 40;
    v25 = __CFADD__(v168, v169);
    v170 = v168 + v169;
    v171 = v164 >> 16;
    if (v25)
      ++v167;
    v172 = ((__PAIR128__(v167, v170) + ((unsigned __int128)v164 >> 16)) >> 64) + 0x7FFFFFFFFFFFFF80;
    v174 = v53 * v151 + v161 + v158 + v49 * *a4;
    v173 = ((unint64_t)v53 * (unsigned __int128)v151
          + __PAIR128__(v160, v161)
          + __PAIR128__(v157, v158)
          + v49 * (unsigned __int128)*a4) >> 64;
    v175 = (unint64_t)(unsigned __int16)v162 << 40;
    v25 = __CFADD__(v174, v175);
    v176 = v174 + v175;
    if (v25)
      ++v173;
    *((_QWORD *)&v177 + 1) = v172;
    *(_QWORD *)&v177 = v170 + v171;
    v178 = __PAIR128__((*((_QWORD *)&v156 + 1) >> 16) + (unint64_t)__CFADD__(v176, (unint64_t)(v156 >> 16)) + v173, v176 + (unint64_t)(v156 >> 16))+ (v177 >> 56);
    v179 = (__PAIR128__(v708, v150) + (unint64_t)v53 * (unsigned __int128)*a4 - v156) >> 64;
    v180 = v150 + v53 * *a4 - v156;
    v181 = (unint64_t)(unsigned __int16)v164 << 40;
    v25 = __CFADD__(v180, v181);
    v182 = v180 + v181;
    v183 = ((v170 + v171) & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v178 + 1) >> 8);
    v184 = (v178 >> 16) & 0xFFFF0000000000;
    if (v25)
      ++v179;
    v25 = __CFADD__(v182, v184);
    v185 = v182 + v184;
    if (v25)
      ++v179;
    v187 = (__PAIR128__(v179, v185)
          + ((__PAIR128__(v149, v159)
            - (v164
             + ((unsigned __int128)v178 >> 56))
            + __PAIR128__(0x8000000000000000, 0x8000)) >> 56)
          + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64;
    v186 = v185
         + ((__int128)(__PAIR128__(v149, v159)
                     - (v164
                      + ((unsigned __int128)v178 >> 56))
                     + __PAIR128__(0x8000000000000000, 0x8000)) >> 56)
         - 0x80000000000000;
    v188 = (__int128)__PAIR128__(v187, v186) >> 56;
    v25 = __CFADD__(v183, v188);
    v189 = v183 + v188;
    v190 = HIBYTE(v187);
    if (v25)
      ++v190;
    *((_QWORD *)&v191 + 1) = v190;
    *(_QWORD *)&v191 = v189;
    v706 = (v191 >> 56) + (v178 & 0xFFFFFFFFFFFFFFLL);
    v700 = v141 & 0xFFFFFFFFFFFFFFLL;
    v701 = v136 & 0xFFFFFFFFFFFFFFLL;
    v695 = (v159 - (v164 + (v178 >> 56)) + 0x8000) & 0xFFFFFFFFFFFFFFLL;
    v697 = v186 & 0xFFFFFFFFFFFFFFLL;
    v699 = v145 & 0xFFFFFFFFFFFFFFLL;
    v693 = v189 & 0xFFFFFFFFFFFFFFLL;
  }
  v192 = a6->i64[0];
  v193 = a6->i64[1];
  v194 = (int8x16_t)a6[1];
  v195 = a6[1].u64[0];
  v196 = a6[1].u64[1];
  v197 = v196 * (unsigned __int128)(unint64_t)(2 * a6->i64[0])
       + 2 * v195 * (unsigned __int128)(unint64_t)v193;
  v198 = (unint64_t)(2 * v193) * (unsigned __int128)v196
       + v195 * (unsigned __int128)v195
       + ((v196 * (unsigned __int128)v196) >> 16);
  v199 = (unint64_t)(unsigned __int16)(v196 * v196) << 40;
  v200 = ((v196 * 2 * v195) << 40) & 0xFFFE0000000000;
  v201 = ((unint64_t)(2 * v193) * (unsigned __int128)a6->u64[0] - v196 * (unsigned __int128)(2 * v195)) >> 64;
  v202 = 2 * v193 * a6->i64[0] - v196 * 2 * v195;
  v203 = (unint64_t)(unsigned __int16)(2 * v193 * v196 + v195 * v195 + ((v196 * v196) >> 16)) << 40;
  v25 = __CFADD__(v202, v203);
  v204 = v202 + v203;
  if (v25)
    ++v201;
  v205 = (a6->u64[1] * (unsigned __int128)a6->u64[1]
        + 2 * v195 * (unsigned __int128)a6->u64[0]
        - v196 * (unsigned __int128)v196) >> 64;
  v206 = a6->i64[1] * a6->i64[1] + 2 * v195 * a6->i64[0] - v196 * v196;
  v25 = __CFADD__(v206, v200);
  v207 = v206 + v200;
  if (v25)
    ++v205;
  v208 = v207 + (v198 >> 16);
  v209 = ((__PAIR128__(v205, v207) + ((unsigned __int128)v198 >> 16)) >> 64) + 0x7FFFFFFFFFFFFF80;
  v210 = HIBYTE(v209);
  *((_QWORD *)&v212 + 1) = v209;
  *(_QWORD *)&v212 = v208;
  v211 = v212 >> 56;
  v213 = (v197 + ((v196 * (unsigned __int128)(2 * v195)) >> 16)) >> 64;
  v214 = v197 + ((v196 * (unsigned __int128)(2 * v195)) >> 16);
  v25 = __CFADD__(v214, v199);
  v215 = v214 + v199;
  if (v25)
    ++v213;
  v216 = __PAIR128__(v213, v215) + __PAIR128__(v210, v211);
  v217 = ((__int128)(__PAIR128__(v213, v215) + __PAIR128__(v210, v211)) >> 16) & 0xFFFF0000000000;
  v25 = __CFADD__(v204, v217);
  v218 = v204 + v217;
  if (v25)
    ++v201;
  v219 = (v208 & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v216 + 1) >> 8);
  v220 = (unint64_t)v192 * (unsigned __int128)(unint64_t)v192
       - (v198
        + (v216 >> 56))
       + __PAIR128__(0x8000000000000000, 0x8000);
  v221 = (__int128)(__PAIR128__(HIBYTE(*((_QWORD *)&v220 + 1))+ (unint64_t)__CFADD__(v218, (unint64_t)(v220 >> 56))+ v201, v218 + (unint64_t)(v220 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 56;
  v25 = __CFADD__(v219, v221);
  v222 = v219 + v221;
  if (v25)
    v223 = ((unint64_t)((__PAIR128__(HIBYTE(*((_QWORD *)&v220 + 1))+ (unint64_t)__CFADD__(v218, (unint64_t)(v220 >> 56))+ v201, v218 + (unint64_t)(v220 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64) >> 56)+ 1;
  else
    v223 = (unint64_t)((__PAIR128__(HIBYTE(*((_QWORD *)&v220 + 1))+ (unint64_t)__CFADD__(v218, (unint64_t)(v220 >> 56))+ v201, v218 + (unint64_t)(v220 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64) >> 56;
  *((_QWORD *)&v224 + 1) = v223;
  *(_QWORD *)&v224 = v222;
  v225 = (v224 >> 56) + (v216 & 0xFFFFFFFFFFFFFFLL);
  v226 = v220 & 0xFFFFFFFFFFFFFFLL;
  v227 = (v218 + (v220 >> 56) - 0x80000000000000) & 0xFFFFFFFFFFFFFFLL;
  v228 = v222 & 0xFFFFFFFFFFFFFFLL;
  v229 = v225 * (unsigned __int128)v195 + (unint64_t)v228 * (unsigned __int128)v196;
  v230 = (unint64_t)v228 * (unsigned __int128)v195
       + v227 * (unsigned __int128)v196
       + v225 * (unsigned __int128)(unint64_t)v193
       + ((v225 * (unsigned __int128)v196) >> 16);
  v232 = ((v220 & 0xFFFFFFFFFFFFFFLL) * v195
        + v227 * (unsigned __int128)(unint64_t)v193
        + (unint64_t)v228 * (unsigned __int128)(unint64_t)v192
        - v225 * (unsigned __int128)v196) >> 64;
  v231 = (v220 & 0xFFFFFFFFFFFFFFLL) * v195 + v227 * v193 + v228 * v192 - v225 * v196;
  v233 = (unint64_t)(unsigned __int16)(((v224 >> 56) + v216) * v195 + v228 * v196) << 40;
  v25 = __CFADD__(v231, v233);
  v234 = v231 + v233;
  if (v25)
    ++v232;
  v235 = __PAIR128__(v232, v234) + (v230 >> 16);
  v680 = v195;
  v236 = (unint64_t)(unsigned __int16)(v225 * v196) << 40;
  v237 = (v227 * (unsigned __int128)v195
        + (unint64_t)v226 * (unsigned __int128)v196
        + (unint64_t)v228 * (unsigned __int128)(unint64_t)v193
        + v225 * (unsigned __int128)(unint64_t)v192) >> 64;
  v238 = v227 * v195 + v226 * v196 + v228 * v193 + v225 * v192;
  v25 = __CFADD__(v238, v236);
  v239 = v238 + v236;
  if (v25)
    ++v237;
  v240 = (unint64_t)(unsigned __int16)(v228 * v195
                                            + (v218 + (v220 >> 56)) * v196
                                            + v225 * v193
                                            + ((v225 * v196) >> 16)) << 40;
  *((_QWORD *)&v241 + 1) = *((_QWORD *)&v235 + 1) + 0x7FFFFFFFFFFFFF80;
  *(_QWORD *)&v241 = v234 + (v230 >> 16);
  v242 = __PAIR128__(v237, v239) + (v229 >> 16) + (v241 >> 56);
  v243 = (v235 & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v242 + 1) >> 8);
  v244 = ((__int128)v242 >> 16) & 0xFFFF0000000000;
  v245 = v226 * v192 - (v230 + (v242 >> 56)) + 0x8000;
  v246 = ((unint64_t)v226 * (unsigned __int128)(unint64_t)v193
        + ((v218 + (unint64_t)(v220 >> 56) - 0x80000000000000) & 0xFFFFFFFFFFFFFFLL)
        * (unsigned __int128)(unint64_t)v192
        - v229) >> 64;
  v247 = v226 * v193 + v227 * v192 - v229;
  v25 = __CFADD__(v247, v240);
  v248 = v247 + v240;
  if (v25)
    ++v246;
  v25 = __CFADD__(v248, v244);
  v249 = v248 + v244;
  if (v25)
    ++v246;
  v251 = v249
       + ((__int128)((unint64_t)v226 * (unsigned __int128)(unint64_t)v192
                   - (v230
                    + (v242 >> 56))
                   + __PAIR128__(0x8000000000000000, 0x8000)) >> 56)
       - 0x80000000000000;
  v250 = (__PAIR128__(v246, v249)
        + (((unint64_t)v226 * (unsigned __int128)(unint64_t)v192
          - (v230
           + (v242 >> 56))
          + __PAIR128__(0x8000000000000000, 0x8000)) >> 56)
        + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64;
  v252 = (__int128)__PAIR128__(v250, v251) >> 56;
  v253 = HIBYTE(v250);
  v25 = __CFADD__(v243, v252);
  v254 = v243 + v252;
  if (v25)
    ++v253;
  *((_QWORD *)&v255 + 1) = v253;
  *(_QWORD *)&v255 = v254;
  v256 = (v255 >> 56) + (v242 & 0xFFFFFFFFFFFFFFLL);
  v257 = v245 & 0xFFFFFFFFFFFFFFLL;
  v258 = *a14;
  v259 = a14->i64[0];
  v260 = a14->u64[1];
  v681 = ((v245 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)v260) >> 64;
  v261 = v251 & 0xFFFFFFFFFFFFFFLL;
  v263 = a14[1].u64[0];
  v262 = a14[1].u64[1];
  v264 = v254 & 0xFFFFFFFFFFFFFFLL;
  v265 = v256 * (unsigned __int128)v263 + (unint64_t)v264 * (unsigned __int128)v262;
  v266 = ((v255 >> 56) + v242) * v262;
  v267 = ((unint64_t)v264 * (unsigned __int128)v263
        + (v251 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)v262
        + v256 * (unsigned __int128)v260
        + ((v256 * (unsigned __int128)v262) >> 16)) >> 64;
  v268 = v264 * v263 + (v251 & 0xFFFFFFFFFFFFFFLL) * v262 + v256 * v260 + ((v256 * (unsigned __int128)v262) >> 16);
  v269 = ((v245 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)v263
        - (unint64_t)v699
        + (v251 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)v260
        + (unint64_t)v264 * (unsigned __int128)a14->u64[0]
        - v256 * (unsigned __int128)v262) >> 64;
  v270 = (v245 & 0xFFFFFFFFFFFFFFLL) * v263
       - v699
       + (v251 & 0xFFFFFFFFFFFFFFLL) * v260
       + v264 * a14->i64[0]
       - v256 * v262;
  v271 = (unint64_t)(unsigned __int16)(((v255 >> 56) + v242) * v263 + v264 * v262) << 40;
  v25 = __CFADD__(v270, v271);
  v272 = v270 + v271;
  if (v25)
    ++v269;
  v273 = __PAIR128__(v269, v272) + (__PAIR128__(v267, v268) >> 16);
  v274 = (unint64_t)v257 * (unsigned __int128)v262 - (unint64_t)v702;
  v275 = ((unint64_t)v264 * (unsigned __int128)v260) >> 64;
  v276 = v264 * v260;
  v277 = v257 * v260;
  v278 = v257 * v259;
  v279 = (v256 * (unsigned __int128)(unint64_t)v259) >> 64;
  v280 = v256 * v259;
  v281 = ((unint64_t)v261 * (unsigned __int128)(unint64_t)v259) >> 64;
  v282 = v261 * v259;
  v679 = a14[1].u64[0];
  v283 = (unint64_t)v266 << 40;
  v284 = v274 + v261 * v263 + v276;
  v285 = (v274 + (unint64_t)v261 * (unsigned __int128)v263 + __PAIR128__(v275, v276) + __PAIR128__(v279, v280)) >> 64;
  v286 = (unint64_t)(unsigned __int16)v268 << 40;
  v25 = __CFADD__(v284 + v280, v283);
  v287 = v284 + v280 + v283;
  *((_QWORD *)&v289 + 1) = ((unint64_t)v273 >= 0x100) + *((_QWORD *)&v273 + 1) + 0x7FFFFFFFFFFFFF80;
  *(_QWORD *)&v289 = v273 - 256;
  v288 = v289 >> 56;
  if (v25)
    ++v285;
  v291 = v287 + (v265 >> 16) + v288;
  v290 = (__PAIR128__(v285, v287)
        + ((unsigned __int128)v265 >> 16)
        + __PAIR128__(((unint64_t)((unint64_t)v273 >= 0x100) + *((_QWORD *)&v273 + 1) + 0x7FFFFFFFFFFFFF80) >> 56, v288)) >> 64;
  if (v291 >= 0x100)
    ++v290;
  v292 = HIBYTE(v290);
  *((_QWORD *)&v294 + 1) = v290;
  *(_QWORD *)&v294 = v291 - 256;
  v293 = v294 >> 56;
  v295 = ((v273 - 256) & 0xFFFFFFFFFFFFFFLL) + (v290 >> 8);
  *((_QWORD *)&v294 + 1) = v290;
  *(_QWORD *)&v294 = v291 - 256;
  v296 = (v294 >> 16) & 0xFFFF0000000000;
  if (__CFADD__(v268, v701))
    ++v267;
  v297 = __PAIR128__(((v245 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)a14->u64[0]) >> 64, v278)
       - __PAIR128__(v292 + __CFADD__(v268 + v701, v293) + v267, v268 + v701 + v293)
       + __PAIR128__(0x8000000000000001, 33024);
  v298 = (__PAIR128__(v681, v277) - (unint64_t)v700 + __PAIR128__(v281, v282) - v265) >> 64;
  v299 = v277 - v700 + v282 - v265;
  v25 = __CFADD__(v299, v286);
  v300 = v299 + v286;
  if (v25)
    ++v298;
  v25 = __CFADD__(v300, v296);
  v301 = v300 + v296;
  if (v25)
    ++v298;
  v302 = __PAIR128__(v298, v301) + (v297 >> 56) + __PAIR128__(0x7FFFFFFFFFFFFF80, 0xFF7EFFFFFFFFFF00);
  v303 = v302 >> 56;
  v304 = v295 + v303;
  if (__CFADD__(v295, v303))
    v305 = HIBYTE(*((_QWORD *)&v302 + 1)) + 1;
  else
    v305 = HIBYTE(*((_QWORD *)&v302 + 1));
  *((_QWORD *)&v306 + 1) = v305;
  *(_QWORD *)&v306 = v304;
  v307 = (v306 >> 56) + ((v291 - 256) & 0xFFFFFFFFFFFFFFLL);
  v308 = a8[1];
  v309 = a8[2];
  v310 = a8[3];
  v311 = v225 * (unsigned __int128)v309 + (unint64_t)v228 * (unsigned __int128)v310;
  v313 = ((unint64_t)v228 * (unsigned __int128)v309
        + v227 * (unsigned __int128)v310
        + v225 * (unsigned __int128)v308
        + ((v225 * (unsigned __int128)v310) >> 16)) >> 64;
  v312 = v228 * v309 + v227 * v310 + v225 * v308 + ((v225 * (unsigned __int128)v310) >> 16);
  v314 = v193;
  v315 = *a8;
  v316 = ((unint64_t)v226 * (unsigned __int128)v309
        - (unint64_t)v693
        + v227 * (unsigned __int128)v308
        + (unint64_t)v228 * (unsigned __int128)*a8
        - v225 * (unsigned __int128)v310) >> 64;
  v317 = v226 * v309 - v693 + v227 * v308 + v228 * *a8 - v225 * v310;
  v318 = (unint64_t)(unsigned __int16)(v225 * v309 + v228 * v310) << 40;
  v25 = __CFADD__(v317, v318);
  v319 = v317 + v318;
  if (v25)
    ++v316;
  v320 = __PAIR128__(v316, v319) + (__PAIR128__(v313, v312) >> 16);
  v323 = (unint64_t)(unsigned __int16)(v225 * v310) << 40;
  v322 = (unint64_t)v226 * (unsigned __int128)v310
       - v706
       + v227 * (unsigned __int128)v309
       + (unint64_t)v228 * (unsigned __int128)v308
       + v225 * (unsigned __int128)v315;
  v321 = *((_QWORD *)&v322 + 1);
  v25 = __CFADD__((_QWORD)v322, v323);
  v324 = v322 + v323;
  if (v25)
    v321 = *((_QWORD *)&v322 + 1) + 1;
  *((_QWORD *)&v325 + 1) = ((unint64_t)v320 >= 0x100) + *((_QWORD *)&v320 + 1) + 0x7FFFFFFFFFFFFF80;
  *(_QWORD *)&v325 = v320 - 256;
  v327 = __PAIR128__(v321, v324) + (v311 >> 16) + (v325 >> 56);
  v326 = *((_QWORD *)&v327 + 1);
  if ((unint64_t)v327 >= 0x100)
    v326 = *((_QWORD *)&v327 + 1) + 1;
  *((_QWORD *)&v329 + 1) = v326;
  *(_QWORD *)&v329 = v327 - 256;
  v328 = v329 >> 56;
  if (__CFADD__(v312, v695))
    ++v313;
  v330 = (unint64_t)v226 * (unsigned __int128)v315
       - (__PAIR128__(HIBYTE(v326), v312 + v695)
        + __PAIR128__(v313, v328));
  v675 = v304;
  v331 = v302 & 0xFFFFFFFFFFFFFFLL;
  v332 = v307;
  v333 = v330 + 33024;
  v334 = ((unint64_t)v226 * (unsigned __int128)v308 - (unint64_t)v697) >> 64;
  v335 = v226 * v308 - v697;
  v25 = __CFADD__(v335, v227 * v315);
  v336 = v335 + v227 * v315;
  v337 = (v227 * (unsigned __int128)v315) >> 64;
  v338 = (unint64_t)(unsigned __int16)v312 << 40;
  v339 = ((v320 - 256) & 0xFFFFFFFFFFFFFFLL) + (v326 >> 8);
  *((_QWORD *)&v340 + 1) = v326;
  *(_QWORD *)&v340 = v327 - 256;
  v341 = (v340 >> 16) & 0xFFFF0000000000;
  *((_QWORD *)&v340 + 1) = __CFADD__((_QWORD)v330, 33024) + *((_QWORD *)&v330 + 1) - 0x7FFFFFFFFFFFFFFFLL;
  *(_QWORD *)&v340 = v330 + 33024;
  v342 = v340 >> 56;
  v344 = (__PAIR128__(v337 + (unint64_t)v25 + v334, v336) - v311) >> 64;
  v343 = v336 - v311;
  v25 = __CFADD__(v343, v338);
  v345 = v343 + v338;
  if (v25)
    ++v344;
  v25 = __CFADD__(v345, v341);
  v346 = v345 + v341;
  if (v25)
    v347 = v344 + 1;
  else
    v347 = v344;
  v348 = __PAIR128__(v347, v346)
       + __PAIR128__(((unint64_t)__CFADD__((_QWORD)v330, 33024) + *((_QWORD *)&v330 + 1) - 0x7FFFFFFFFFFFFFFFLL) >> 56, v342)+ __PAIR128__(0x7FFFFFFFFFFFFF80, 0xFF7EFFFFFFFFFF00);
  v349 = v348 >> 56;
  v350 = __OFADD__(v339, v349);
  v351 = v339 + v349;
  if (__CFADD__(v339, v349))
    v352 = HIBYTE(*((_QWORD *)&v348 + 1)) + 1;
  else
    v352 = HIBYTE(*((_QWORD *)&v348 + 1));
  *((_QWORD *)&v353 + 1) = v352;
  *(_QWORD *)&v353 = v351;
  v354 = (v353 >> 56) + ((v327 - 256) & 0xFFFFFFFFFFFFFFLL);
  v355.i64[0] = v348 & 0xFFFFFFFFFFFFFFLL;
  v683 = v192;
  v685 = v314;
  v355.i64[1] = v314;
  v356.i64[0] = v333 & 0xFFFFFFFFFFFFFFLL;
  v356.i64[1] = v192;
  a13.i64[0] = v351 & 0xFFFFFFFFFFFFFFLL;
  v357 = (int8x16_t)vzip1q_s64(a13, (int64x2_t)v194);
  v194.i64[0] = v354;
  v358.i64[0] = -1;
  v358.i64[1] = -1;
  v359 = (int8x16_t)vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(v355, vorrq_s8(v356, v357)), v194), v358);
  v356.i64[0] = v348 & 0xFFFFFFFFFFFFFFLL;
  v355.i64[0] = v333 & 0xFFFFFFFFFFFFFFLL;
  v360.i64[0] = 0xFFFFFFFFFFFFFFLL;
  v360.i64[1] = 0xFFFFFFFFFFFFFFLL;
  v361 = veorq_s8(v357, v360);
  v362 = vorrq_s8(vorrq_s8((int8x16_t)vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(veorq_s8(v355, (int8x16_t)xmmword_208F2E400), vorrq_s8(veorq_s8(v356, (int8x16_t)xmmword_208F2E3F0), veorq_s8(v194, v360))), v361), v358), v359), (int8x16_t)vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(veorq_s8(v355, (int8x16_t)xmmword_208F2E420), vorrq_s8(veorq_s8(v356, (int8x16_t)xmmword_208F2E410), veorq_s8(v194, (int8x16_t)vdupq_n_s64(0x1FFFFFFFFFFFFFFuLL)))), v361), v358));
  v364 = *a15;
  v363 = a15[1];
  v366 = a15[2];
  v365 = a15[3];
  v367 = ((v363 ^ 0xFFFF0000000000 | *a15 ^ 1 | v365 ^ 0xFFFFFFFFFFFFFFLL | v366 ^ 0xFFFFFFFFFFFFFFLL) - 1) | ((v363 | *a15 | v366 | v365) - 1) | ((v363 ^ 0xFFFE0000000000 | *a15 ^ 2 | v365 ^ 0x1FFFFFFFFFFFFFFLL | v366 ^ 0xFFFFFFFFFFFFFFLL) - 1);
  if (((v362.i64[0] & ~v362.i64[1] & (((v331 ^ 0xFFFF0000000000 | v297 & 0xFFFFFFFFFFFFFFLL ^ 1 | v304 & 0xFFFFFFFFFFFFFFLL ^ 0xFFFFFFFFFFFFFFLL | v307 ^ 0xFFFFFFFFFFFFFFLL)
                                      - 1) | ((v331 | v297 & 0xFFFFFFFFFFFFFFLL | v304 & 0xFFFFFFFFFFFFFFLL | v307) - 1) | ((v331 ^ 0xFFFE0000000000 | v297 & 0xFFFFFFFFFFFFFFLL ^ 2 | v304 & 0xFFFFFFFFFFFFFFLL ^ 0xFFFFFFFFFFFFFFLL | v307 ^ 0x1FFFFFFFFFFFFFFLL) - 1)) & 0x8000000000000000) != 0) != v350
    && v367 >= 0)
  {
    result.i64[0] = p224_point_double(a1, a2, a3, a4, a5, v687).u64[0];
  }
  else
  {
    v648 = v348 & 0xFFFFFFFFFFFFFFLL;
    v650 = v351;
    v371 = v192;
    v656 = v304 & 0xFFFFFFFFFFFFFFLL;
    v686 = a14[1].u64[1];
    v659 = v297 & 0xFFFFFFFFFFFFFFLL;
    v661 = *a15;
    v673 = v308;
    v674 = v307;
    v666 = v315;
    v668 = v362.i64[1] >> 63;
    v669 = v367 >> 63;
    v670 = v310;
    v664 = a15[3];
    v665 = v196;
    v662 = a15[1];
    v663 = a15[2];
    if (a7)
    {
      v372 = v680;
      v373 = v314;
    }
    else
    {
      v374 = (unint64_t)v680 * (unsigned __int128)v365 + v196 * (unsigned __int128)v366;
      v375 = (unint64_t)v680 * (unsigned __int128)v366
           + v196 * (unsigned __int128)v363
           + v365 * (unsigned __int128)(unint64_t)v314
           + ((v196 * (unsigned __int128)v365) >> 16);
      v376 = ((unint64_t)v680 * (unsigned __int128)v364
            + v363 * (unsigned __int128)(unint64_t)v314
            + v366 * (unsigned __int128)(unint64_t)v192
            - v196 * (unsigned __int128)v365) >> 64;
      v377 = v680 * v364 + v363 * v314 + v366 * v192 - v196 * v365;
      v378 = (unint64_t)(unsigned __int16)(v680 * v365 + v196 * v366) << 40;
      v25 = __CFADD__(v377, v378);
      v379 = v377 + v378;
      if (v25)
        ++v376;
      v380 = ((__PAIR128__(v376, v379) + (v375 >> 16)) >> 64) + 0x7FFFFFFFFFFFFF80;
      v381 = (unint64_t)(unsigned __int16)(v196 * v365) << 40;
      v382 = ((unint64_t)v680 * (unsigned __int128)v363
            + v196 * (unsigned __int128)v364
            + v366 * (unsigned __int128)(unint64_t)v314
            + v365 * (unsigned __int128)(unint64_t)v192) >> 64;
      v383 = v680 * v363 + v196 * v364 + v366 * v314 + v365 * v192;
      v25 = __CFADD__(v383, v381);
      v384 = v383 + v381;
      if (v25)
        ++v382;
      *((_QWORD *)&v385 + 1) = v380;
      *(_QWORD *)&v385 = v379 + (v375 >> 16);
      v386 = __PAIR128__(v382, v384) + (v374 >> 16) + (v385 >> 56);
      v388 = (v364 * (unsigned __int128)(unint64_t)v314 + v363 * (unsigned __int128)(unint64_t)v192 - v374) >> 64;
      v387 = v364 * v314 + v363 * v192 - v374;
      v389 = (unint64_t)(unsigned __int16)(v680 * v366
                                                + v196 * v363
                                                + v365 * v314
                                                + ((v196 * v365) >> 16)) << 40;
      v390 = ((__int128)v386 >> 16) & 0xFFFF0000000000;
      v25 = __CFADD__(v387, v389);
      v391 = v387 + v389;
      if (v25)
        ++v388;
      v25 = __CFADD__(v391, v390);
      v392 = v391 + v390;
      if (v25)
        ++v388;
      v393 = __PAIR128__(v388, v392)
           + ((v364 * (unsigned __int128)(unint64_t)v192
             - (v375
              + (v386 >> 56))
             + __PAIR128__(0x8000000000000000, 0x8000)) >> 56)
           + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000);
      v394 = HIBYTE(*((_QWORD *)&v393 + 1));
      if (__CFADD__(((v379 + (v375 >> 16)) & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v386 + 1) >> 8), (unint64_t)(v393 >> 56)))
      {
        ++v394;
      }
      *((_QWORD *)&v395 + 1) = v394;
      *(_QWORD *)&v395 = *((_QWORD *)&v386 + 1);
      v196 = (v395 >> 56) + (v386 & 0xFFFFFFFFFFFFFFLL);
      v371 = (v364 * v192 - (v375 + (v386 >> 56)) + 0x8000) & 0xFFFFFFFFFFFFFFLL;
      v373 = v393 & 0xFFFFFFFFFFFFFFLL;
      v372 = *((_QWORD *)&v386 + 1) & 0xFFFFFFFFFFFFFFLL;
    }
    v396 = v351 & 0xFFFFFFFFFFFFFFLL;
    v397 = v333 & 0xFFFFFFFFFFFFFFLL;
    v398 = v348 & 0xFFFFFFFFFFFFFFLL;
    v399 = v351 & 0xFFFFFFFFFFFFFFLL;
    v400 = (unint64_t)v372 * (unsigned __int128)(unint64_t)v354
         + v196 * (unsigned __int128)(v351 & 0xFFFFFFFFFFFFFFLL);
    v401 = (unint64_t)v372 * (unsigned __int128)(v351 & 0xFFFFFFFFFFFFFFLL)
         + v196 * (unsigned __int128)(v348 & 0xFFFFFFFFFFFFFFLL)
         + ((v196 * (unsigned __int128)(unint64_t)v354) >> 16)
         + (unint64_t)v373 * (unsigned __int128)(unint64_t)v354;
    v402 = ((unint64_t)v372 * (unsigned __int128)(v333 & 0xFFFFFFFFFFFFFFLL)
          - v196 * (unsigned __int128)(unint64_t)v354
          + (unint64_t)v373 * (unsigned __int128)(v348 & 0xFFFFFFFFFFFFFFLL)
          + (unint64_t)v371 * (unsigned __int128)(v351 & 0xFFFFFFFFFFFFFFLL)) >> 64;
    v403 = v372 * (v333 & 0xFFFFFFFFFFFFFFLL)
         - v196 * v354
         + v373 * (v348 & 0xFFFFFFFFFFFFFFLL)
         + v371 * (v351 & 0xFFFFFFFFFFFFFFLL);
    v404 = (unint64_t)(unsigned __int16)(v372 * v354 + v196 * v650) << 40;
    v25 = __CFADD__(v403, v404);
    v405 = v403 + v404;
    if (v25)
      ++v402;
    v406 = __PAIR128__(v402, v405) + (v401 >> 16);
    v407 = ((unint64_t)v372 * (unsigned __int128)(v348 & 0xFFFFFFFFFFFFFFLL)
          + v196 * (unsigned __int128)(v333 & 0xFFFFFFFFFFFFFFLL)
          + __PAIR128__(((unint64_t)v373 * (unsigned __int128)(v650 & 0xFFFFFFFFFFFFFFLL)) >> 64, v373 * v399)) >> 64;
    v408 = v372 * (v348 & 0xFFFFFFFFFFFFFFLL) + v196 * (v333 & 0xFFFFFFFFFFFFFFLL) + v373 * v399;
    v409 = (unint64_t)(unsigned __int16)(v196 * v354) << 40;
    v25 = __CFADD__(v408, v409);
    v410 = v408 + v409;
    if (v25)
      ++v407;
    v411 = __PAIR128__(v407, v410) + (unint64_t)v371 * (unsigned __int128)(unint64_t)v354 + (v400 >> 16);
    *((_QWORD *)&v412 + 1) = *((_QWORD *)&v406 + 1) + 0x7FFFFFFFFFFFFF80;
    *(_QWORD *)&v412 = v405 + (v401 >> 16);
    v653 = v411 + (v412 >> 56);
    v413 = v371 * v397 - (v401 + ((__int128)(v411 + (v412 >> 56)) >> 56)) + 0x8000;
    v678 = v413;
    v414 = __CFADD__(v371 * v397 - (v401 + ((__int128)(v411 + (v412 >> 56)) >> 56)), 0x8000)
         + (((unint64_t)v371 * (unsigned __int128)(v333 & 0xFFFFFFFFFFFFFFLL)
           - (v401
            + ((v411 + (v412 >> 56)) >> 56))) >> 64)
         + 0x8000000000000000;
    v416 = (unint64_t)v373 * (unsigned __int128)(v333 & 0xFFFFFFFFFFFFFFLL)
         - v400
         + (unint64_t)v371 * (unsigned __int128)(v348 & 0xFFFFFFFFFFFFFFLL);
    v415 = *((_QWORD *)&v416 + 1);
    v417 = (unint64_t)(unsigned __int16)v401 << 40;
    v25 = __CFADD__((_QWORD)v416, v417);
    v418 = v416 + v417;
    v419 = (v406 & 0xFFFFFFFFFFFFFFLL) + ((unint64_t)((v411 + (v412 >> 56)) >> 64) >> 8);
    v420 = ((__int128)(v411 + (v412 >> 56)) >> 16) & 0xFFFF0000000000;
    if (v25)
      v415 = *((_QWORD *)&v416 + 1) + 1;
    v25 = __CFADD__(v418, v420);
    v421 = v418 + v420;
    if (v25)
      v422 = v415 + 1;
    else
      v422 = v415;
    *((_QWORD *)&v424 + 1) = v414;
    *(_QWORD *)&v424 = v413;
    v423 = v424 >> 56;
    v25 = __CFADD__(v421, v423);
    v425 = v421 + v423;
    v658 = v425 - 0x80000000000000;
    *((_QWORD *)&v424 + 1) = __CFADD__(v425, 0xFF80000000000000) + HIBYTE(v414) + v25 + v422 + 0x7FFFFFFFFFFFFF7FLL;
    *(_QWORD *)&v424 = v425 - 0x80000000000000;
    v426 = v424 >> 56;
    v688 = v419 + v426;
    v427 = HIBYTE(*((_QWORD *)&v424 + 1));
    if (__CFADD__(v419, v426))
      ++v427;
    v651 = v427;
    v428 = ((unint64_t)v398 * (unsigned __int128)(unint64_t)(2 * v396)
          + (unint64_t)v354 * (unsigned __int128)(2 * (v333 & 0xFFFFFFFFFFFFFFuLL))) >> 64;
    v429 = v398 * 2 * v396 + v354 * 2 * (v333 & 0xFFFFFFFFFFFFFFLL);
    v430 = (unint64_t)(unsigned __int16)(v354 * v354) << 40;
    v25 = __CFADD__(v429, v430);
    v431 = v429 + v430;
    if (v25)
      ++v428;
    v432 = __PAIR128__(v428, v431) + (((unint64_t)v354 * (unsigned __int128)(unint64_t)(2 * v396)) >> 16);
    v433 = ((unint64_t)v397 * (unsigned __int128)(unint64_t)(2 * v648)
          - (unint64_t)v354 * (unsigned __int128)(unint64_t)(2 * v396)) >> 64;
    v434 = v397 * 2 * v648 - v354 * 2 * v396;
    v435 = (unint64_t)(unsigned __int16)(v354 * 2 * v348 + v399 * v399 + ((v354 * v354) >> 16)) << 40;
    v25 = __CFADD__(v434, v435);
    v436 = v434 + v435;
    if (v25)
      ++v433;
    v437 = (unint64_t)v398 * (unsigned __int128)(unint64_t)v398
         - (unint64_t)v354 * (unsigned __int128)(unint64_t)v354
         + (unint64_t)v397 * (unsigned __int128)(unint64_t)(2 * v396)
         + (((unint64_t)v354 * (unsigned __int128)(unint64_t)(2 * v648)
           + (unint64_t)v399 * (unsigned __int128)(unint64_t)v399
           + (((unint64_t)v354 * (unsigned __int128)(unint64_t)v354) >> 16)) >> 16)
         + __PAIR128__(0x7FFFFFFFFFFFFF80, ((v354 * 2 * v396) << 40) & 0xFFFE0000000000);
    v438 = v432 + (v437 >> 56);
    v439 = ((__int128)(v432 + (v437 >> 56)) >> 16) & 0xFFFF0000000000;
    v25 = __CFADD__(v436, v439);
    v440 = v436 + v439;
    if (v25)
      v441 = v433 + 1;
    else
      v441 = v433;
    v442 = (unint64_t)v397 * (unsigned __int128)(unint64_t)v397
         - ((unint64_t)v354 * (unsigned __int128)(unint64_t)(2 * v648)
          + (unint64_t)v399 * (unsigned __int128)(unint64_t)v399
          + (((unint64_t)v354 * (unsigned __int128)(unint64_t)v354) >> 16)
          + ((v432 + (v437 >> 56)) >> 56))
         + __PAIR128__(0x8000000000000000, 0x8000);
    v443 = __PAIR128__(v441, v440) + (v442 >> 56) + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000);
    v444 = v443 >> 56;
    v445 = (v437 & 0xFFFFFFFFFFFFFFLL) + ((unint64_t)((v432 + (v437 >> 56)) >> 64) >> 8);
    v25 = __CFADD__(v445, v444);
    v446 = v445 + v444;
    v447 = HIBYTE(*((_QWORD *)&v443 + 1));
    if (v25)
      ++v447;
    *((_QWORD *)&v448 + 1) = v447;
    *(_QWORD *)&v448 = v446;
    v449 = (v448 >> 56) + (v438 & 0xFFFFFFFFFFFFFFLL);
    v450 = v443 & 0xFFFFFFFFFFFFFFLL;
    v451 = v446 & 0xFFFFFFFFFFFFFFLL;
    v452 = v449 * (unsigned __int128)(unint64_t)v399
         + (v446 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)(unint64_t)v354;
    v453 = ((v446 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)(unint64_t)v399
          + (v443 & 0xFFFFFFFFFFFFFFLL) * (unint64_t)v354
          + v449 * (unsigned __int128)(unint64_t)v398
          + ((v449 * (unsigned __int128)(unint64_t)v354) >> 16)) >> 64;
    v454 = (v446 & 0xFFFFFFFFFFFFFFLL) * v399
         + (v443 & 0xFFFFFFFFFFFFFFLL) * v354
         + v449 * v398
         + ((v449 * (unsigned __int128)(unint64_t)v354) >> 16);
    v455 = v442 & 0xFFFFFFFFFFFFFFLL;
    v457 = ((v442 & 0xFFFFFFFFFFFFFFLL) * (unint64_t)v399
          + (v443 & 0xFFFFFFFFFFFFFFLL) * (unint64_t)v398
          + (unint64_t)v451 * (unsigned __int128)(unint64_t)v397
          - v449 * (unsigned __int128)(unint64_t)v354) >> 64;
    v456 = (v442 & 0xFFFFFFFFFFFFFFLL) * v399 + (v443 & 0xFFFFFFFFFFFFFFLL) * v398 + v451 * v397 - v449 * v354;
    v458 = (unint64_t)(unsigned __int16)(((v448 >> 56) + v438) * v399 + v451 * v354) << 40;
    v25 = __CFADD__(v456, v458);
    v459 = v456 + v458;
    if (v25)
      ++v457;
    *((_QWORD *)&v460 + 1) = v453;
    *(_QWORD *)&v460 = v454;
    v461 = __PAIR128__(v457, v459) + (v460 >> 16);
    v463 = (unint64_t)v450 * (unsigned __int128)(unint64_t)v399
         + (unint64_t)v455 * (unsigned __int128)(unint64_t)v354
         + (unint64_t)v451 * (unsigned __int128)(unint64_t)v398
         + v449 * (unsigned __int128)(unint64_t)v397;
    v462 = *((_QWORD *)&v463 + 1);
    v464 = (unint64_t)(unsigned __int16)(v449 * v354) << 40;
    v25 = __CFADD__((_QWORD)v463, v464);
    v465 = v463 + v464;
    if (v25)
      v462 = *((_QWORD *)&v463 + 1) + 1;
    *((_QWORD *)&v466 + 1) = *((_QWORD *)&v461 + 1) + 0x7FFFFFFFFFFFFF80;
    *(_QWORD *)&v466 = v461;
    v467 = __PAIR128__(v462, v465) + (v452 >> 16) + (v466 >> 56);
    v468 = v467 >> 56;
    v25 = __CFADD__(v454, v468);
    v469 = v454 + v468;
    v470 = HIBYTE(*((_QWORD *)&v467 + 1)) + v25 + v453;
    v25 = v455 * v397 >= v469;
    v471 = v455 * v397 - v469;
    v647 = v471 + 0x8000;
    v472 = __PAIR128__((((unint64_t)v455 * (unsigned __int128)(unint64_t)v397) >> 64) - (v470 + !v25), v471)+ __PAIR128__(0x8000000000000000, 0x8000);
    v474 = (unint64_t)v455 * (unsigned __int128)(unint64_t)v398
         + (unint64_t)v450 * (unsigned __int128)(unint64_t)v397
         - v452;
    v473 = *((_QWORD *)&v474 + 1);
    v475 = (unint64_t)(unsigned __int16)v454 << 40;
    v25 = __CFADD__((_QWORD)v474, v475);
    v476 = v474 + v475;
    v477 = (v461 & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v467 + 1) >> 8);
    v478 = (v467 >> 16) & 0xFFFF0000000000;
    if (v25)
      v473 = *((_QWORD *)&v474 + 1) + 1;
    v25 = __CFADD__(v476, v478);
    v479 = v476 + v478;
    if (v25)
      ++v473;
    v649 = v479 + (v472 >> 56) - 0x80000000000000;
    v480 = __PAIR128__(v473, v479) + (v472 >> 56) + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000);
    v481 = v480 >> 56;
    v25 = __CFADD__(v477, v481);
    v482 = v477 + v481;
    v645 = v482;
    v483 = HIBYTE(*((_QWORD *)&v480 + 1));
    if (v25)
      ++v483;
    *((_QWORD *)&v484 + 1) = v483;
    *(_QWORD *)&v484 = v482;
    v646 = (v484 >> 56) + (v467 & 0xFFFFFFFFFFFFFFLL);
    v485 = v449 * (unsigned __int128)(unint64_t)v693 + (unint64_t)v451 * (unsigned __int128)v706;
    v486 = ((unint64_t)v455 * (unsigned __int128)v695) >> 64;
    v487 = v455 * v695;
    v488 = (v449 * (unsigned __int128)v695) >> 64;
    v489 = v449 * v695;
    v490 = ((unint64_t)v455 * (unsigned __int128)(unint64_t)v693) >> 64;
    v491 = v455 * v693;
    v492 = ((unint64_t)v455 * (unsigned __int128)(unint64_t)v697) >> 64;
    v493 = v455 * v697;
    v494 = ((unint64_t)v455 * (unsigned __int128)v706) >> 64;
    v495 = v455 * v706;
    v496 = (v449 * (unsigned __int128)(unint64_t)v697) >> 64;
    v497 = v449 * v697;
    v498 = v449 * v706;
    v499 = (v449 * (unsigned __int128)v706) >> 64;
    *((_QWORD *)&v484 + 1) = v499;
    *(_QWORD *)&v484 = v498;
    v500 = (unint64_t)v451 * (unsigned __int128)(unint64_t)v693
         + (unint64_t)v450 * (unsigned __int128)v706
         + __PAIR128__(v496, v497)
         + ((unsigned __int128)v484 >> 16);
    v501 = (__PAIR128__((((unint64_t)v450 * (unsigned __int128)(unint64_t)v697) >> 64)+ __CFADD__(v491, v450 * v697)+ v490, v491 + v450 * v697)+ (unint64_t)v451 * (unsigned __int128)v695- __PAIR128__(v499, v498)) >> 64;
    v502 = v491 + v450 * v697 + v451 * v695 - v498;
    v503 = (unint64_t)(unsigned __int16)v485 << 40;
    v25 = __CFADD__(v502, v503);
    v504 = v502 + v503;
    if (v25)
      ++v501;
    v505 = __PAIR128__(v501, v504) + (v500 >> 16);
    v506 = (unint64_t)v450 * (unsigned __int128)(unint64_t)v693
         + __PAIR128__(v494, v495)
         + (unint64_t)v451 * (unsigned __int128)(unint64_t)v697
         + __PAIR128__(v488, v489);
    v507 = (unint64_t)(unsigned __int16)v498 << 40;
    v25 = __CFADD__((_QWORD)v506, v507);
    v508 = v506 + v507;
    if (v25)
      v509 = *((_QWORD *)&v506 + 1) + 1;
    else
      v509 = ((unint64_t)v450 * (unsigned __int128)(unint64_t)v693
            + __PAIR128__(v494, v495)
            + (unint64_t)v451 * (unsigned __int128)(unint64_t)v697
            + __PAIR128__(v488, v489)) >> 64;
    v510 = __PAIR128__(v509, v508) + (v485 >> 16);
    *((_QWORD *)&v511 + 1) = *((_QWORD *)&v505 + 1) + 0x7FFFFFFFFFFFFF80;
    *(_QWORD *)&v511 = v504 + (v500 >> 16);
    v512 = v510 + (v511 >> 56);
    *((_QWORD *)&v511 + 1) = (v510 + ((unsigned __int128)v511 >> 56)) >> 64;
    *(_QWORD *)&v511 = v512;
    v513 = (__PAIR128__(v486, v487)
          - (v500
           + ((unsigned __int128)v511 >> 56))
          + __PAIR128__(0x8000000000000000, 0x8000)) >> 64;
    v514 = v487 - (v500 + ((unsigned __int128)v511 >> 56)) + 0x8000;
    v515 = (__PAIR128__(v492, v493) + (unint64_t)v450 * (unsigned __int128)v695 - v485) >> 64;
    v516 = v493 + v450 * v695 - v485;
    v517 = (v505 & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v511 + 1) >> 8);
    *(_QWORD *)&v511 = v512;
    v518 = (unint64_t)(unsigned __int16)v500 << 40;
    v25 = __CFADD__(v516, v518);
    v519 = v516 + v518;
    v520 = (v511 >> 16) & 0xFFFF0000000000;
    if (v25)
      ++v515;
    v25 = __CFADD__(v519, v520);
    v521 = v519 + v520;
    *((_QWORD *)&v523 + 1) = v513;
    *(_QWORD *)&v523 = v514;
    v522 = v523 >> 56;
    if (v25)
      ++v515;
    v25 = __CFADD__(v521, v522);
    v524 = v521 + v522;
    v525 = HIBYTE(v513) + v25 + v515;
    v526 = v524 - 0x80000000000000;
    *((_QWORD *)&v528 + 1) = __CFADD__(v524, 0xFF80000000000000) + v525 + 0x7FFFFFFFFFFFFF7FLL;
    *(_QWORD *)&v528 = v524 - 0x80000000000000;
    v527 = v528 >> 56;
    v25 = __CFADD__(v517, v527);
    v529 = v517 + v527;
    v530 = v512 & 0xFFFFFFFFFFFFFFLL;
    v531 = HIBYTE(*((_QWORD *)&v528 + 1));
    if (v25)
      ++v531;
    *((_QWORD *)&v532 + 1) = v531;
    *(_QWORD *)&v532 = v529;
    v533 = (v532 >> 56) + v530;
    v534 = 2 * v331;
    v535 = v332;
    v536 = v675 & 0xFFFFFFFFFFFFFFLL;
    v537 = (v332 * (unsigned __int128)(unint64_t)(2 * v331)
          + (unint64_t)v536 * (unsigned __int128)(unint64_t)v536
          + ((v535 * (unsigned __int128)v535) >> 16)) >> 64;
    v538 = v332 * 2 * v331 + v536 * v536 + ((v535 * (unsigned __int128)v535) >> 16);
    v539 = v302 & 0xFFFFFFFFFFFFFFLL;
    v540 = 2 * v656;
    v541 = v297 & 0xFFFFFFFFFFFFFFLL;
    v542 = (v302 & 0xFFFFFFFFFFFFFFLL) * (v302 & 0xFFFFFFFFFFFFFFLL)
         - v535 * (unsigned __int128)v535
         + (v297 & 0xFFFFFFFFFFFFFFLL) * (unint64_t)(2 * v656)
         + ((v332 * (unsigned __int128)(unint64_t)(2 * v331)
           + (unint64_t)v536 * (unsigned __int128)(unint64_t)v536
           + ((v535 * (unsigned __int128)v535) >> 16)) >> 16);
    v543 = v332 * 2 * v656;
    v544 = (v543 << 40) & 0xFFFE0000000000;
    v25 = __CFADD__((_QWORD)v542, v544);
    v545 = v542 + v544;
    v546 = v529 & 0xFFFFFFFFFFFFFFLL;
    v709 = v645 & 0xFFFFFFFFFFFFFFLL;
    if (v25)
      v547 = *((_QWORD *)&v542 + 1) + 1;
    else
      v547 = ((unint64_t)v539 * (unsigned __int128)(unint64_t)v539
            - v332 * (unsigned __int128)v332
            + (v297 & 0xFFFFFFFFFFFFFFLL) * (unint64_t)(2 * v656)
            + (__PAIR128__(v537, v538) >> 16)) >> 64;
    v548 = v545 - ((v645 & 0xFFFFFFFFFFFFFFLL) + 2 * v546);
    v549 = (v548 >= 0x200)
         + ((__PAIR128__(v547, v545) - ((v645 & 0xFFFFFFFFFFFFFFuLL) + 2 * v546)) >> 64)
         + 0x7FFFFFFFFFFFFF81;
    v550 = (v332 * (unsigned __int128)(unint64_t)(2 * v659)
          + (unint64_t)v539 * (unsigned __int128)(unint64_t)v540) >> 64;
    v551 = v332 * 2 * v659 + v539 * v540;
    v552 = (unint64_t)(unsigned __int16)(v332 * v332) << 40;
    v25 = __CFADD__(v551, v552);
    v553 = v551 + v552;
    v554 = (v332 * (unsigned __int128)(unint64_t)v540) >> 64;
    if (v25)
      ++v550;
    *((_QWORD *)&v555 + 1) = v554;
    *(_QWORD *)&v555 = v332 * 2 * v656;
    v556 = __PAIR128__(v550, v553) + ((unsigned __int128)v555 >> 16) - (v646 + 2 * v533);
    *((_QWORD *)&v555 + 1) = v549;
    *(_QWORD *)&v555 = v548 - 512;
    v557 = v555 >> 56;
    v558 = ((unint64_t)(v556 + v557) >= 0x200) + ((v556 + ((unsigned __int128)v555 >> 56)) >> 64) + 1;
    v559 = v514 & 0xFFFFFFFFFFFFFFLL;
    v698 = v647 & 0xFFFFFFFFFFFFFFLL;
    v560 = v538 + (v647 & 0xFFFFFFFFFFFFFFLL);
    if (__CFADD__(v538, v647 & 0xFFFFFFFFFFFFFFLL))
      ++v537;
    v25 = __CFADD__(v560, 2 * v559);
    v561 = v560 + 2 * v559;
    if (v25)
      ++v537;
    *((_QWORD *)&v562 + 1) = v558;
    *(_QWORD *)&v562 = v556 + v557 - 512;
    v563 = (unint64_t)v541 * (unsigned __int128)(unint64_t)v541
         - (__PAIR128__(v537, v561)
          + (v562 >> 56))
         + __PAIR128__(0x8000000000000002, 33280);
    v564 = (unint64_t)(unsigned __int16)(v332 * 2 * v302 + v675 * v675 + ((v332 * v332) >> 16)) << 40;
    v25 = __CFADD__(v541 * v534, v564);
    v565 = v541 * v534 + v564;
    v566 = v526 & 0xFFFFFFFFFFFFFFLL;
    v567 = v649 & 0xFFFFFFFFFFFFFFLL;
    v696 = v649 & 0xFFFFFFFFFFFFFFLL;
    v568 = ((unint64_t)v541 * (unsigned __int128)(unint64_t)v534) >> 64;
    if (v25)
      ++v568;
    v569 = v543 + v567;
    if (__CFADD__(v543, v567))
      ++v554;
    v25 = __CFADD__(v569, 2 * v566);
    v570 = v569 + 2 * v566;
    if (v25)
      ++v554;
    v572 = v565 - v570;
    v571 = (__PAIR128__(v568, v565) - __PAIR128__(v554, v570)) >> 64;
    v573 = ((v548 - 512) & 0xFFFFFFFFFFFFFFLL) + (v558 >> 8);
    *((_QWORD *)&v574 + 1) = v558;
    *(_QWORD *)&v574 = v556 + v557 - 512;
    v575 = (v574 >> 16) & 0xFFFF0000000000;
    v25 = __CFADD__(v572, v575);
    v576 = v572 + v575;
    v577 = v563 >> 56;
    if (v25)
      ++v571;
    v579 = (__PAIR128__(HIBYTE(*((_QWORD *)&v563 + 1)) + (unint64_t)__CFADD__(v576, v577) + v571, v576 + v577)
          + __PAIR128__(0x7FFFFFFFFFFFFF81, 0xFF7DFFFFFFFFFE00)) >> 64;
    v578 = v576 + v577 - 0x82000000000200;
    v580 = (__int128)__PAIR128__(v579, v578) >> 56;
    v25 = __CFADD__(v573, v580);
    v581 = v573 + v580;
    v582 = HIBYTE(v579);
    if (v25)
      ++v582;
    *((_QWORD *)&v583 + 1) = v582;
    *(_QWORD *)&v583 = v581;
    v584 = (v583 >> 56) + ((v556 + v557 - 512) & 0xFFFFFFFFFFFFFFLL);
    v585 = *a4 & v669 | (v666 & v668 | v563 & 0xFFFFFFFFFFFFFFLL & ~v668) & ~v669;
    v586 = a4[1] & v669 | (v673 & v668 | v578 & 0xFFFFFFFFFFFFFFLL & ~v668) & ~v669;
    v587 = a4[2] & v669 | (v309 & v668 | v581 & 0xFFFFFFFFFFFFFFLL & ~v668) & ~v669;
    v588 = a4[3] & v669 | (v670 & v668 | v584 & ~v668) & ~v669;
    v589 = *(int8x16_t *)a5;
    v705 = a5[1].i64[0];
    v711 = a5[1].i64[1];
    a1->i64[0] = v585;
    a1->i64[1] = v586;
    a1[1].i64[0] = v587;
    a1[1].i64[1] = v588;
    *((_QWORD *)&v583 + 1) = v651;
    *(_QWORD *)&v583 = v688;
    v694 = (v583 >> 56) + (v653 & 0xFFFFFFFFFFFFFFLL);
    v590 = v559 - (v563 & 0xFFFFFFFFFFFFFFLL) + 0x400000000000004;
    v591 = v566 - (v578 & 0xFFFFFFFFFFFFFFLL) + 0x3FFFBFFFFFFFFFCLL;
    v592 = v546 - (v581 & 0xFFFFFFFFFFFFFFLL) + 0x3FFFFFFFFFFFFFCLL;
    v593 = v533 - v584 + 0x3FFFFFFFFFFFFFCLL;
    v690 = ((unint64_t)v541 * (unsigned __int128)(unint64_t)v590) >> 64;
    v682 = v541 * v590;
    v676 = (unint64_t)v541 * (unsigned __int128)(unint64_t)v591;
    v594 = ((unint64_t)v541 * (unsigned __int128)(unint64_t)v592) >> 64;
    v595 = v541 * v592;
    v667 = v541 * v593;
    v671 = ((unint64_t)v541 * (unsigned __int128)(unint64_t)v593) >> 64;
    v672 = (unint64_t)v539 * (unsigned __int128)(unint64_t)v590;
    v596 = ((unint64_t)v536 * (unsigned __int128)(unint64_t)v590) >> 64;
    v597 = v536 * v590;
    v654 = (v332 * (unsigned __int128)(unint64_t)v590) >> 64;
    v655 = v332 * v590;
    v598 = ((unint64_t)v539 * (unsigned __int128)(unint64_t)v591) >> 64;
    v599 = v539 * v591;
    v660 = ((unint64_t)v539 * (unsigned __int128)(unint64_t)v592) >> 64;
    v657 = v539 * v592;
    v600 = ((unint64_t)v539 * (unsigned __int128)(unint64_t)v593) >> 64;
    v601 = v539 * v593;
    v652 = ((unint64_t)v536 * (unsigned __int128)(unint64_t)v591) >> 64;
    v602 = v536 * v591;
    v603 = ((unint64_t)v536 * (unsigned __int128)(unint64_t)v592) >> 64;
    v604 = v536 * v592;
    v605 = ((unint64_t)v536 * (unsigned __int128)(unint64_t)v593) >> 64;
    v606 = v536 * v593;
    v607 = v332 * (unsigned __int128)(unint64_t)v592
         - v646 * (unsigned __int128)(unint64_t)v699
         - (unint64_t)v709 * (unsigned __int128)(unint64_t)v702;
    v608 = v607 + v606;
    v609 = v674 * (unsigned __int128)(unint64_t)v591
         - ((unint64_t)v709 * (unsigned __int128)(unint64_t)v699
          + (unint64_t)v696 * (unsigned __int128)(unint64_t)v702
          + v646 * (unsigned __int128)(unint64_t)v700);
    v610 = __PAIR128__(v603 + (unint64_t)__CFADD__((_QWORD)v609, v604) + *((_QWORD *)&v609 + 1), (uint64_t)v609 + v604)+ __PAIR128__(v600, v601);
    v611 = v605 + __CFADD__((_QWORD)v607, v606) + *((_QWORD *)&v607 + 1) + 0xFFFFFFFFFFFFFFLL;
    v612 = v674 * (unsigned __int128)(unint64_t)v593
         - v646 * (unsigned __int128)(unint64_t)v702
         + __PAIR128__(0xFFFFFFFFFFFFFFLL, 0);
    v613 = v610 + (v612 >> 16);
    v614 = ((v610 + (v612 >> 16)) >> 64) + 0xFFFEFFFFFFFFFFLL;
    v615 = (__PAIR128__(v596, v597)
          - ((unint64_t)v696 * (unsigned __int128)(unint64_t)v700
           + (unint64_t)v698 * (unsigned __int128)(unint64_t)v699
           + (unint64_t)v709 * (unsigned __int128)(unint64_t)v701)
          + __PAIR128__(v598, v599)
          + __PAIR128__(v594, v595)
          - (v674 * (unsigned __int128)(unint64_t)v593
           - v646 * (unsigned __int128)(unint64_t)v702)) >> 64;
    v616 = v597 - (v696 * v700 + v698 * v699 + v709 * v701) + v599 + v595 - (v674 * v593 - v646 * v702);
    v617 = (unint64_t)(unsigned __int16)v608 << 40;
    v25 = __CFADD__(v616, v617);
    v618 = v616 + v617;
    if (v25)
      ++v615;
    *((_QWORD *)&v619 + 1) = v614;
    *(_QWORD *)&v619 = v613;
    v620 = __PAIR128__(v615, v618) + (v619 >> 16);
    *((_QWORD *)&v619 + 1) = v611;
    *(_QWORD *)&v619 = v608;
    v621 = __PAIR128__(v654, v655)
         - ((unint64_t)v696 * (unsigned __int128)(unint64_t)v699
          + (unint64_t)v698 * (unsigned __int128)(unint64_t)v702
          + (unint64_t)v709 * (unsigned __int128)(unint64_t)v700
          + v646 * (unsigned __int128)(unint64_t)v701)
         + __PAIR128__(v652, v602)
         + __PAIR128__(v660, v657)
         + __PAIR128__(v671, v667)
         + (v619 >> 16);
    v622 = (unint64_t)(unsigned __int16)(v674 * v593 - v646 * v702) << 40;
    v25 = __CFADD__((_QWORD)v621, v622);
    v623 = v621 + v622;
    if (v25)
      v624 = *((_QWORD *)&v621 + 1) + 1;
    else
      v624 = *((_QWORD *)&v621 + 1);
    *((_QWORD *)&v626 + 1) = *((_QWORD *)&v620 + 1) + 0x7FFFFFFFFFFFFF80;
    *(_QWORD *)&v626 = v620;
    v625 = v626 >> 56;
    v25 = __CFADD__(v623, v625);
    v627 = v623 + v625;
    *((_QWORD *)&v626 + 1) = ((unint64_t)(*((_QWORD *)&v620 + 1) + 0x7FFFFFFFFFFFFF80) >> 56)
                           + v25
                           + v624
                           + 0x100000000000000;
    *(_QWORD *)&v626 = v627;
    v628 = (unint64_t)v698 * (unsigned __int128)(unint64_t)v701
         + __PAIR128__(v614, v613)
         + ((unsigned __int128)v626 >> 56);
    v629 = (v672
          - (unint64_t)v696 * (unsigned __int128)(unint64_t)v701
          - (unint64_t)v698 * (unsigned __int128)(unint64_t)v700
          + v676
          - __PAIR128__(v611, v608)) >> 64;
    v630 = v672 - v696 * v701 - v698 * v700 + v676 - v608;
    v631 = (unint64_t)(unsigned __int16)v613 << 40;
    v25 = __CFADD__(v630, v631);
    v632 = v630 + v631;
    v633 = (v620 & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v626 + 1) >> 8);
    *(_QWORD *)&v626 = v627;
    v634 = (v626 >> 16) & 0xFFFF0000000000;
    if (v25)
      ++v629;
    v25 = __CFADD__(v632, v634);
    v635 = v632 + v634;
    if (v25)
      ++v629;
    v636 = __PAIR128__(v629, v635)
         + ((__PAIR128__(v690, v682) - v628 + __PAIR128__(0x8100000000000000, 0x8000)) >> 56)
         + __PAIR128__(0x80FFFFFFFFFFFF7ELL, 0xFF80000000000000);
    v637 = v636 >> 56;
    v25 = __CFADD__(v633, v637);
    v638 = v633 + v637;
    v639.i64[0] = v682 - v628 + 0x8000;
    v639.i64[1] = v636;
    v640 = v627 & 0xFFFFFFFFFFFFFFLL;
    v641 = HIBYTE(*((_QWORD *)&v636 + 1));
    if (v25)
      ++v641;
    *((_QWORD *)&v642 + 1) = v641;
    *(_QWORD *)&v642 = v638;
    v643 = (int8x16_t)vdupq_n_s64(v668);
    a2[1].i64[0] = v705 & v669 | (v679 & v668 | v638 & ~v668 & 0xFFFFFFFFFFFFFFLL) & ~v669;
    a2[1].i64[1] = v711 & v669 | (v686 & v668 | ((v642 >> 56) + v640) & ~v668) & ~v669;
    v644.i64[0] = 0xFFFFFFFFFFFFFFLL;
    v644.i64[1] = 0xFFFFFFFFFFFFFFLL;
    result = vbslq_s8((int8x16_t)vdupq_n_s64(v669), v589, vorrq_s8(vandq_s8(v258, v643), vandq_s8(vbicq_s8(v639, v643), v644)));
    *a2 = result;
    a3->i64[0] = v683 & v669 | (v661 & v668 | v678 & ~v668 & 0xFFFFFFFFFFFFFFLL) & ~v669;
    a3->i64[1] = v685 & v669 | (v662 & v668 | v658 & ~v668 & 0xFFFFFFFFFFFFFFLL) & ~v669;
    a3[1].i64[0] = v680 & v669 | (v663 & v668 | v688 & ~v668 & 0xFFFFFFFFFFFFFFLL) & ~v669;
    a3[1].i64[1] = v665 & v669 | (v664 & v668 | v694 & ~v668) & ~v669;
  }
  return result;
}

int8x16_t p224_point_double(int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, unint64_t *a4, int64x2_t *a5, int64x2_t *a6)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int128 v16;
  unsigned __int128 v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  __int128 v22;
  __int128 v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  BOOL v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  __int128 v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  __int128 v47;
  uint64_t v48;
  signed __int128 v49;
  unsigned __int128 v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  __int128 v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned __int128 v63;
  unsigned __int128 v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unsigned __int128 v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  __int128 v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  __int128 v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  unint64_t v100;
  __int128 v101;
  uint64_t v102;
  unsigned __int128 v103;
  signed __int128 v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  __int128 v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unsigned __int128 v113;
  unsigned __int128 v114;
  uint64_t v115;
  unsigned __int128 v116;
  unint64_t v117;
  unsigned __int128 v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unsigned __int128 v123;
  signed __int128 v124;
  unsigned __int128 v125;
  unsigned __int128 v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  unint64_t v134;
  unsigned __int128 v135;
  uint64_t v136;
  uint64_t v137;
  unint64_t v138;
  __int128 v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  unsigned __int128 v145;
  uint64_t v146;
  uint64_t v147;
  signed __int128 v148;
  uint64_t v149;
  uint64_t v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  unint64_t v155;
  uint64_t v156;
  unint64_t v157;
  uint64_t v158;
  uint64_t v159;
  unint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  unint64_t v164;
  uint64_t v165;
  unint64_t v166;
  uint64_t v167;
  unint64_t v168;
  uint64_t v169;
  unint64_t v170;
  uint64_t v171;
  uint64_t v172;
  unint64_t v173;
  unsigned __int128 v174;
  unint64_t v175;
  uint64_t v176;
  unint64_t v177;
  unsigned __int128 v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  __int128 v186;
  uint64_t v187;
  uint64_t v188;
  unsigned __int128 v189;
  unint64_t v190;
  unint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  unint64_t v196;
  unint64_t v197;
  signed __int128 v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  __int128 v202;
  unint64_t v203;
  uint64_t v204;
  uint64_t v205;
  unint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  unsigned __int128 v213;
  uint64_t v214;
  uint64_t v215;
  unint64_t v216;
  unint64_t v217;
  uint64_t v218;
  unint64_t v219;
  unint64_t v220;
  uint64_t v221;
  unint64_t v222;
  unint64_t v223;
  __int128 v224;
  unsigned __int128 v225;
  uint64_t v226;
  unint64_t v227;
  uint64_t v228;
  unsigned __int128 v229;
  unsigned __int128 v230;
  uint64_t v231;
  unint64_t v232;
  uint64_t v233;
  unint64_t v234;
  unint64_t v235;
  uint64_t v236;
  __int128 v237;
  uint64_t v238;
  unint64_t v239;
  signed __int128 v240;
  uint64_t v241;
  uint64_t v242;
  int8x16_t v243;
  uint64_t v244;
  __int128 v245;
  int8x16_t v246;
  uint64_t v247;
  uint64_t v248;
  int64x2_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  unint64_t v253;
  unint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  unint64_t v259;
  uint64_t v260;
  uint64_t v261;
  unint64_t v262;
  unint64_t v263;
  uint64_t v264;
  uint64_t v265;
  unint64_t v266;
  unsigned __int128 v267;
  unsigned __int128 v268;
  uint64_t v269;
  unint64_t v270;
  unint64_t v271;
  unint64_t v272;
  unint64_t v273;
  uint64_t v274;
  uint64_t v275;
  __int128 v276;
  unint64_t v277;
  unint64_t v278;
  uint64_t v279;
  unint64_t v280;
  unint64_t v281;
  unint64_t v282;
  __int128 v283;
  unsigned __int128 v284;
  uint64_t v285;
  uint64_t v286;
  unint64_t v287;
  unint64_t v288;
  uint64_t v289;
  __int128 v290;
  uint64_t v291;
  uint64_t v292;
  unint64_t v293;
  uint64_t v294;
  uint64_t v295;
  signed __int128 v296;
  int8x16_t v297;
  __int128 v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  unint64_t v303;
  uint64_t v304;
  unint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  unint64_t v310;
  unsigned __int128 v311;
  unint64_t v312;
  unint64_t v313;
  uint64_t v314;
  unint64_t v315;
  unint64_t v316;
  unint64_t v317;
  uint64_t v318;
  uint64_t v319;
  unint64_t v320;
  __int128 v321;
  unint64_t v322;
  uint64_t v323;
  unsigned __int128 v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  unint64_t v328;
  unsigned __int128 v329;
  __int128 v330;
  unsigned __int128 v331;
  uint64_t v332;
  uint64_t v333;
  unint64_t v334;
  unint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  unint64_t v340;
  int8x16_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  unint64_t v345;
  __int128 v346;
  int8x16_t result;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  unint64_t v352;
  uint64_t v353;
  unint64_t v354;
  uint64_t v355;
  unsigned __int128 v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  unint64_t v366;
  unint64_t v368;

  v6 = *a4;
  v7 = a4[1];
  v8 = a6->i64[0];
  v9 = a6->i64[1];
  v10 = a6[1].i64[0];
  v11 = a6[1].i64[1];
  v12 = ((unint64_t)v8 * (unsigned __int128)(unint64_t)v8) >> 64;
  v13 = v8 * v8;
  v14 = 2 * v10 * a6->i64[0];
  v15 = v9 * v9;
  v16 = (unint64_t)v11 * (unsigned __int128)(unint64_t)(2 * a6->i64[0])
      + (unint64_t)(2 * v10) * (unsigned __int128)(unint64_t)v9;
  v17 = (unint64_t)v11 * (unsigned __int128)(unint64_t)(2 * v9)
      + (unint64_t)v10 * (unsigned __int128)(unint64_t)v10;
  v18 = v11 * 2 * v10;
  v19 = ((unint64_t)v11 * (unsigned __int128)(unint64_t)(2 * v10)) >> 64;
  v20 = v11 * v11;
  v21 = ((unint64_t)v11 * (unsigned __int128)(unint64_t)v11) >> 64;
  *((_QWORD *)&v22 + 1) = v21;
  *(_QWORD *)&v22 = v20;
  v23 = v17 + ((unsigned __int128)v22 >> 16);
  v24 = (unint64_t)(unsigned __int16)v20 << 40;
  *((_QWORD *)&v22 + 1) = v19;
  *(_QWORD *)&v22 = v18;
  v25 = v22 >> 16;
  v26 = v19 >> 16;
  v27 = (v18 << 40) & 0xFFFE0000000000;
  v29 = 2 * v9 * a6->i64[0] - v18;
  v28 = ((unint64_t)(2 * v9) * (unsigned __int128)a6->u64[0] - __PAIR128__(v19, v18)) >> 64;
  v30 = (unint64_t)(unsigned __int16)v23 << 40;
  v31 = __CFADD__(v29, v30);
  v32 = v29 + v30;
  if (v31)
    ++v28;
  v34 = v15 + v14 - v20;
  v33 = (__PAIR128__((((unint64_t)(2 * v10) * (unsigned __int128)a6->u64[0]) >> 64)+ __CFADD__(v15, v14)+ (((unint64_t)v9 * (unsigned __int128)(unint64_t)v9) >> 64), v15 + v14)- __PAIR128__(v21, v20)) >> 64;
  if (__CFADD__(v34, v27))
    ++v33;
  v35 = v34 + v27 + (v23 >> 16);
  v36 = ((__PAIR128__(v33, v34 + v27) + ((unsigned __int128)v23 >> 16)) >> 64) + 0x7FFFFFFFFFFFFF80;
  v37 = HIBYTE(v36);
  *((_QWORD *)&v39 + 1) = v36;
  *(_QWORD *)&v39 = v35;
  v38 = v39 >> 56;
  v40 = (v16 + __PAIR128__(v26, v25)) >> 64;
  v41 = v16 + v25 + v24;
  if (__CFADD__(v16 + v25, v24))
    ++v40;
  v43 = (__PAIR128__(v40, v41) + __PAIR128__(v37, v38)) >> 64;
  v42 = v41 + v38;
  v44 = ((__int128)__PAIR128__(v43, v42) >> 16) & 0xFFFF0000000000;
  v31 = __CFADD__(v32, v44);
  v45 = v32 + v44;
  if (v31)
    ++v28;
  v46 = HIBYTE(v43);
  *((_QWORD *)&v47 + 1) = v43;
  *(_QWORD *)&v47 = v42;
  v48 = (v35 & 0xFFFFFFFFFFFFFFLL) + (v43 >> 8);
  v49 = __PAIR128__(v12, v13) - (v23 + __PAIR128__(v46, v47 >> 56)) + __PAIR128__(0x8000000000000000, 0x8000);
  v50 = __PAIR128__(HIBYTE(*((_QWORD *)&v49 + 1)) + (unint64_t)__CFADD__(v45, (unint64_t)(v49 >> 56)) + v28, v45 + (unint64_t)(v49 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000);
  v51 = (unint64_t)((__PAIR128__(HIBYTE(*((_QWORD *)&v49 + 1))+ (unint64_t)__CFADD__(v45, (unint64_t)(v49 >> 56))+ v28, v45 + (unint64_t)(v49 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64) >> 56;
  v52 = (__int128)(__PAIR128__(HIBYTE(*((_QWORD *)&v49 + 1))+ (unint64_t)__CFADD__(v45, (unint64_t)(v49 >> 56))+ v28, v45 + (unint64_t)(v49 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 56;
  v53 = v48 + v52;
  if (__CFADD__(v48, v52))
    v54 = v51 + 1;
  else
    v54 = v51;
  *((_QWORD *)&v55 + 1) = v54;
  *(_QWORD *)&v55 = v53;
  v56 = (v55 >> 56) + (v42 & 0xFFFFFFFFFFFFFFLL);
  v57 = a5->i64[0];
  v58 = a5->i64[1];
  v59 = a5[1].i64[0];
  v60 = a5[1].i64[1];
  v61 = 2 * v59;
  v62 = 2 * v59 * a5->i64[0];
  v63 = (unint64_t)v60 * (unsigned __int128)(unint64_t)(2 * a5->i64[0])
      + (unint64_t)(2 * v59) * (unsigned __int128)(unint64_t)v58;
  v64 = (unint64_t)v60 * (unsigned __int128)(unint64_t)(2 * v58)
      + (unint64_t)v59 * (unsigned __int128)(unint64_t)v59;
  v65 = v60 * 2 * v59;
  v66 = ((unint64_t)v60 * (unsigned __int128)(unint64_t)(2 * v59)) >> 64;
  v67 = v60 * v60;
  v68 = ((unint64_t)v60 * (unsigned __int128)(unint64_t)v60) >> 64;
  *((_QWORD *)&v55 + 1) = v68;
  *(_QWORD *)&v55 = v67;
  v69 = (v64 + ((unsigned __int128)v55 >> 16)) >> 64;
  v70 = v64 + ((unsigned __int128)v55 >> 16);
  v71 = (unint64_t)(2 * v58) * (unsigned __int128)a5->u64[0] - __PAIR128__(v66, v65);
  v72 = (unint64_t)(unsigned __int16)(v64 + WORD1(v67)) << 40;
  v73 = v71 + v72;
  if (__CFADD__((_QWORD)v71, v72))
    v74 = *((_QWORD *)&v71 + 1) + 1;
  else
    v74 = ((unint64_t)(2 * v58) * (unsigned __int128)a5->u64[0] - __PAIR128__(v66, v65)) >> 64;
  v76 = a4[2];
  v75 = a4[3];
  v78 = v58 * v58 + v62;
  v77 = ((unint64_t)v58 * (unsigned __int128)(unint64_t)v58
       + __PAIR128__(((unint64_t)v61 * (unsigned __int128)(unint64_t)v57) >> 64, v62)) >> 64;
  v79 = ((unint64_t)v57 * (unsigned __int128)(unint64_t)v57) >> 64;
  v80 = v57 * v57;
  v31 = v78 >= v67;
  v81 = v78 - v67;
  v82 = (unint64_t)(unsigned __int16)v67 << 40;
  v83 = v77 - (v68 + !v31);
  *((_QWORD *)&v85 + 1) = v66;
  *(_QWORD *)&v85 = v65;
  v84 = v85 >> 16;
  v86 = (v65 << 40) & 0xFFFE0000000000;
  v31 = __CFADD__(v81, v86);
  v87 = v81 + v86;
  *((_QWORD *)&v85 + 1) = v69;
  *(_QWORD *)&v85 = v70;
  v88 = v85 >> 16;
  if (v31)
    ++v83;
  v89 = v87 + v88;
  v90 = ((__PAIR128__(v83, v87) + __PAIR128__(v69 >> 16, v88)) >> 64) + 0x7FFFFFFFFFFFFF80;
  v91 = HIBYTE(v90);
  *((_QWORD *)&v93 + 1) = v90;
  *(_QWORD *)&v93 = v89;
  v92 = v93 >> 56;
  v94 = v63 + v84 + v82;
  if (__CFADD__(v63 + v84, v82))
    v95 = ((v63 + __PAIR128__(v66 >> 16, v84)) >> 64) + 1;
  else
    v95 = (v63 + __PAIR128__(v66 >> 16, v84)) >> 64;
  v97 = v94 + v92;
  v96 = (__PAIR128__(v95, v94) + __PAIR128__(v91, v92)) >> 64;
  v98 = ((__int128)__PAIR128__(v96, v97) >> 16) & 0xFFFF0000000000;
  v31 = __CFADD__(v73, v98);
  v99 = v73 + v98;
  if (v31)
    ++v74;
  v100 = HIBYTE(v96);
  *((_QWORD *)&v101 + 1) = v96;
  *(_QWORD *)&v101 = v97;
  v102 = (v89 & 0xFFFFFFFFFFFFFFLL) + (v96 >> 8);
  v103 = __PAIR128__(v79, v80)
       - (__PAIR128__(v69, v70)
        + __PAIR128__(v100, v101 >> 56))
       + __PAIR128__(0x8000000000000000, 0x8000);
  v104 = __PAIR128__(v74, v99) + (v103 >> 56) + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000);
  v105 = v104 >> 56;
  v31 = __CFADD__(v102, v105);
  v106 = v102 + v105;
  if (v31)
    v107 = HIBYTE(*((_QWORD *)&v104 + 1)) + 1;
  else
    v107 = HIBYTE(*((_QWORD *)&v104 + 1));
  *((_QWORD *)&v108 + 1) = v107;
  *(_QWORD *)&v108 = v106;
  v109 = (v108 >> 56) + (v97 & 0xFFFFFFFFFFFFFFLL);
  v110 = v103 & 0xFFFFFFFFFFFFFFLL;
  v111 = v104 & 0xFFFFFFFFFFFFFFLL;
  v112 = v106 & 0xFFFFFFFFFFFFFFLL;
  v113 = v109 * (unsigned __int128)v76 + (v106 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)v75;
  v114 = (v106 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)v76
       + (v104 & 0xFFFFFFFFFFFFFFLL) * v75
       + v109 * (unsigned __int128)v7
       + ((v109 * (unsigned __int128)v75) >> 16);
  v362 = v103 & 0xFFFFFFFFFFFFFFLL;
  v363 = v106 & 0xFFFFFFFFFFFFFFLL;
  v116 = (v103 & 0xFFFFFFFFFFFFFFLL) * v76
       + (v104 & 0xFFFFFFFFFFFFFFLL) * v7
       + (v106 & 0xFFFFFFFFFFFFFFLL) * (unsigned __int128)v6
       - v109 * (unsigned __int128)v75;
  v115 = *((_QWORD *)&v116 + 1);
  v117 = (unint64_t)(unsigned __int16)v113 << 40;
  if (__CFADD__((_QWORD)v116, v117))
    v115 = *((_QWORD *)&v116 + 1) + 1;
  v118 = __PAIR128__(v115, (unint64_t)v116 + v117) + (v114 >> 16);
  v119 = (unint64_t)(unsigned __int16)(v109 * v75) << 40;
  v121 = ((unint64_t)v111 * (unsigned __int128)v76
        + (unint64_t)v110 * (unsigned __int128)v75
        + (unint64_t)v112 * (unsigned __int128)v7
        + v109 * (unsigned __int128)v6) >> 64;
  v120 = v111 * v76 + v110 * v75 + v112 * v7 + v109 * v6;
  v31 = __CFADD__(v120, v119);
  v122 = v120 + v119;
  if (v31)
    ++v121;
  *((_QWORD *)&v123 + 1) = *((_QWORD *)&v118 + 1) + 0x7FFFFFFFFFFFFF80;
  *(_QWORD *)&v123 = v116 + v117 + (v114 >> 16);
  v124 = __PAIR128__(v121, v122) + (v113 >> 16) + (v123 >> 56);
  v364 = v104 & 0xFFFFFFFFFFFFFFLL;
  v125 = (unint64_t)v110 * (unsigned __int128)v6 - (v114 + ((unsigned __int128)v124 >> 56));
  v126 = (unint64_t)v110 * (unsigned __int128)v7 + (unint64_t)v111 * (unsigned __int128)v6;
  v127 = v50 & 0xFFFFFFFFFFFFFFLL;
  v128 = v53 & 0xFFFFFFFFFFFFFFLL;
  v129 = (unint64_t)(unsigned __int16)v114 << 40;
  v130 = (v118 & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v124 + 1) >> 8);
  v131 = (v124 >> 16) & 0xFFFF0000000000;
  v132 = (v126 - v113) >> 64;
  v31 = __CFADD__(v126 - v113, v129);
  v133 = v126 - v113 + v129;
  if (v31)
    ++v132;
  v31 = __CFADD__(v133, v131);
  v134 = v133 + v131;
  if (v31)
    ++v132;
  v135 = __PAIR128__(v132, v134) + ((v125 + __PAIR128__(0x8000000000000000, 0x8000)) >> 56);
  v355 = v135 - 0x80000000000000;
  v136 = (__int128)(v135 + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 56;
  v137 = v130 + v136;
  if (__CFADD__(v130, v136))
    v138 = ((unint64_t)((v135 + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64) >> 56) + 1;
  else
    v138 = (unint64_t)((v135 + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000)) >> 64) >> 56;
  *((_QWORD *)&v139 + 1) = v138;
  *(_QWORD *)&v139 = v137;
  v351 = v137;
  v353 = (v139 >> 56) + (v124 & 0xFFFFFFFFFFFFFFLL);
  v358 = v128;
  v360 = v50 & 0xFFFFFFFFFFFFFFLL;
  v140 = v7 + 0x3FFFBFFFFFFFFFCLL - v127;
  v141 = v128;
  v142 = v76 - v128 + 0x3FFFFFFFFFFFFFCLL;
  v143 = 3 * (v127 + v7);
  v144 = 3 * (v141 + v76);
  v145 = (unint64_t)v144 * (unsigned __int128)(unint64_t)v140
       + (unint64_t)v142 * (unsigned __int128)(unint64_t)v143;
  v146 = v75 - v56 + 0x3FFFFFFFFFFFFFCLL;
  v147 = 3 * (v75 + v56);
  v148 = (unint64_t)v147 * (unsigned __int128)(unint64_t)v142
       + (unint64_t)v146 * (unsigned __int128)(unint64_t)v144;
  v357 = v56;
  v149 = v6 + 0x400000000000004 - (v49 & 0xFFFFFFFFFFFFFFLL);
  v150 = 3 * ((v49 & 0xFFFFFFFFFFFFFFLL) + v6);
  v151 = ((unint64_t)v144 * (unsigned __int128)(unint64_t)v149) >> 64;
  v152 = v144 * v149;
  v153 = ((unint64_t)v144 * (unsigned __int128)(unint64_t)v142) >> 64;
  v154 = v144 * v142;
  v155 = ((unint64_t)v142 * (unsigned __int128)(unint64_t)v150) >> 64;
  v156 = v142 * v150;
  v157 = ((unint64_t)v150 * (unsigned __int128)(unint64_t)v149) >> 64;
  v158 = v150 * v149;
  v350 = ((unint64_t)v143 * (unsigned __int128)(unint64_t)v149) >> 64;
  v159 = v143 * v149;
  v160 = ((unint64_t)v147 * (unsigned __int128)(unint64_t)v149) >> 64;
  v161 = v147 * v149;
  v162 = ((unint64_t)v140 * (unsigned __int128)(unint64_t)v150) >> 64;
  v163 = v140 * v150;
  v164 = ((unint64_t)v146 * (unsigned __int128)(unint64_t)v150) >> 64;
  v165 = v146 * v150;
  v166 = ((unint64_t)v143 * (unsigned __int128)(unint64_t)v140) >> 64;
  v167 = v143 * v140;
  v168 = ((unint64_t)v147 * (unsigned __int128)(unint64_t)v140) >> 64;
  v169 = v147 * v140;
  v170 = ((unint64_t)v146 * (unsigned __int128)(unint64_t)v143) >> 64;
  v171 = v146 * v143;
  v172 = v147 * v146;
  v173 = ((unint64_t)v147 * (unsigned __int128)(unint64_t)v146) >> 64;
  *((_QWORD *)&v139 + 1) = v173;
  *(_QWORD *)&v139 = v172;
  v174 = __PAIR128__(v170, v171) + __PAIR128__(v153, v154) + __PAIR128__(v168, v169) + ((unsigned __int128)v139 >> 16);
  v176 = v167 + v156 + v152 - v172;
  v175 = (__PAIR128__(v166, v167) + __PAIR128__(v155, v156) + __PAIR128__(v151, v152) - __PAIR128__(v173, v172)) >> 64;
  v177 = (unint64_t)(unsigned __int16)v148 << 40;
  if (__CFADD__(v176, v177))
    ++v175;
  v178 = __PAIR128__(v175, v176 + v177) + (v174 >> 16);
  v180 = (v145 + __PAIR128__(v164, v165) + __PAIR128__(v160, v161)) >> 64;
  v179 = v145 + v165 + v161;
  v181 = (unint64_t)(unsigned __int16)v172 << 40;
  v31 = __CFADD__(v179, v181);
  v182 = v179 + v181;
  v183 = v148 >> 16;
  if (v31)
    ++v180;
  v31 = __CFADD__(v182, v183);
  v184 = v182 + v183;
  *((_QWORD *)&v186 + 1) = *((_QWORD *)&v178 + 1) + 0x7FFFFFFFFFFFFF80;
  *(_QWORD *)&v186 = v178;
  v185 = v186 >> 56;
  v187 = (*((_QWORD *)&v148 + 1) >> 16) + v31 + v180;
  v31 = __CFADD__(v184, v185);
  v188 = v184 + v185;
  *((_QWORD *)&v186 + 1) = ((unint64_t)(*((_QWORD *)&v178 + 1) + 0x7FFFFFFFFFFFFF80) >> 56) + v31 + v187;
  *(_QWORD *)&v186 = v188;
  v189 = __PAIR128__(v157, v158)
       - (v174
        + ((unsigned __int128)v186 >> 56))
       + __PAIR128__(0x8000000000000000, 0x8000);
  v190 = (__PAIR128__(v350 + (unint64_t)__CFADD__(v163, v159) + v162, v163 + v159) - v148) >> 64;
  v191 = (unint64_t)(unsigned __int16)v174 << 40;
  v192 = (v178 & 0xFFFFFFFFFFFFFFLL) + (*((_QWORD *)&v186 + 1) >> 8);
  *(_QWORD *)&v186 = v188;
  v193 = v188 & 0xFFFFFFFFFFFFFFLL;
  v194 = (v186 >> 16) & 0xFFFF0000000000;
  v31 = __CFADD__(v163 + v159 - v148, v191);
  v195 = v163 + v159 - v148 + v191;
  if (v31)
    ++v190;
  v31 = __CFADD__(v195, v194);
  v196 = v195 + v194;
  if (v31)
    v197 = v190 + 1;
  else
    v197 = v190;
  v198 = __PAIR128__(v197, v196) + (v189 >> 56) + __PAIR128__(0x7FFFFFFFFFFFFF7FLL, 0xFF80000000000000);
  v199 = v198 >> 56;
  v31 = __CFADD__(v192, v199);
  v200 = v192 + v199;
  if (v31)
    v201 = HIBYTE(*((_QWORD *)&v198 + 1)) + 1;
  else
    v201 = HIBYTE(*((_QWORD *)&v198 + 1));
  *((_QWORD *)&v202 + 1) = v201;
  *(_QWORD *)&v202 = v200;
  v203 = (v202 >> 56) + v193;
  v204 = 2 * (v198 & 0xFFFFFFFFFFFFFFLL);
  v205 = v200 & 0xFFFFFFFFFFFFFFLL;
  v206 = (v203 * (unsigned __int128)(unint64_t)v204
        + (unint64_t)v205 * (unsigned __int128)(unint64_t)v205
        + ((v203 * (unsigned __int128)v203) >> 16)) >> 64;
  v207 = v203 * v204 + v205 * v205 + ((v203 * (unsigned __int128)v203) >> 16);
  v208 = v198 & 0xFFFFFFFFFFFFFFLL;
  if (__CFADD__(v203 * v203, 8 * (v351 & 0xFFFFFFFFFFFFFFLL)))
    v209 = ((v203 * (unsigned __int128)v203) >> 64) + 1;
  else
    v209 = (v203 * (unsigned __int128)v203) >> 64;
  v210 = 2 * (v200 & 0xFFFFFFFFFFFFFFLL);
  v211 = v189 & 0xFFFFFFFFFFFFFFLL;
  v213 = (unint64_t)v208 * (unsigned __int128)(unint64_t)v208
       - __PAIR128__(v209, v203 * v203 + 8 * (v351 & 0xFFFFFFFFFFFFFFLL))
       + (v189 & 0xFFFFFFFFFFFFFFLL) * (unint64_t)v210
       + ((v203 * (unsigned __int128)(unint64_t)v204
         + (unint64_t)v205 * (unsigned __int128)(unint64_t)v205
         + ((v203 * (unsigned __int128)v203) >> 16)) >> 16);
  v212 = *((_QWORD *)&v213 + 1);
  v214 = v203 * v210;
  v215 = ((v203 * v210) << 40) & 0xFFFE0000000000;
  v216 = v213 + v215;
  if (__CFADD__((_QWORD)v213, v215))
    v212 = *((_QWORD *)&v213 + 1) + 1;
  v31 = v216 >= 0x100;
  v217 = v216 - 256;
  v218 = v31 + v212 + 0x7FFFFFFFFFFFFF80;
  v219 = (unint64_t)(unsigned __int16)(v203 * v203) << 40;
  v220 = (v203 * (unsigned __int128)(2 * ((unint64_t)v189 & 0xFFFFFFFFFFFFFFLL))
        + (unint64_t)v208 * (unsigned __int128)(unint64_t)v210
        - (unint64_t)(8 * v353)) >> 64;
  v221 = v203 * 2 * (v189 & 0xFFFFFFFFFFFFFFLL) + v208 * v210 - 8 * v353;
  v31 = __CFADD__(v221, v219);
  v222 = v221 + v219;
  v223 = (v203 * (unsigned __int128)(unint64_t)v210) >> 64;
  if (v31)
    ++v220;
  *((_QWORD *)&v224 + 1) = v223;
  *(_QWORD *)&v224 = v214;
  v225 = __PAIR128__(v220, v222) + ((unsigned __int128)v224 >> 16);
  *((_QWORD *)&v224 + 1) = v218;
  *(_QWORD *)&v224 = v217;
  v226 = v224 >> 56;
  v227 = (v225 + ((unsigned __int128)v224 >> 56)) >> 64;
  v228 = (v125 + 0x8000) & 0xFFFFFFFFFFFFFFLL;
  if ((unint64_t)(v225 + v226) >= 0x100)
    ++v227;
  if (__CFADD__(v207, 8 * v228))
    ++v206;
  *((_QWORD *)&v229 + 1) = v227;
  *(_QWORD *)&v229 = v225 + v226 - 256;
  v230 = __PAIR128__(v206, v207 + 8 * v228) + (v229 >> 56);
  v31 = __CFADD__(v214, 8 * (v355 & 0xFFFFFFFFFFFFFFLL));
  v231 = v214 + 8 * (v355 & 0xFFFFFFFFFFFFFFLL);
  if (v31)
    ++v223;
  v233 = v211 * v204 - v231;
  v232 = ((unint64_t)v211 * (unsigned __int128)(unint64_t)v204 - __PAIR128__(v223, v231)) >> 64;
  v234 = (unint64_t)(unsigned __int16)v207 << 40;
  v31 = __CFADD__(v233, v234);
  v235 = v233 + v234;
  v236 = (v217 & 0xFFFFFFFFFFFFFFLL) + (v227 >> 8);
  *((_QWORD *)&v237 + 1) = v227;
  *(_QWORD *)&v237 = v225 + v226 - 256;
  v238 = (v237 >> 16) & 0xFFFF0000000000;
  if (v31)
    ++v232;
  v31 = __CFADD__(v235, v238);
  v239 = v235 + v238;
  if (v31)
    ++v232;
  v240 = __PAIR128__(v232, v239)
       + (((unint64_t)v211 * (unsigned __int128)(unint64_t)v211
         - v230
         + __PAIR128__(0x8000000000000001, 33024)) >> 56)
       + __PAIR128__(0x7FFFFFFFFFFFFF80, 0xFF7EFFFFFFFFFF00);
  v241 = v240 >> 56;
  v31 = __CFADD__(v236, v241);
  v242 = v236 + v241;
  v243.i64[0] = v211 * v211 - v230 + 33024;
  v243.i64[1] = v240;
  v244 = HIBYTE(*((_QWORD *)&v240 + 1));
  if (v31)
    ++v244;
  *((_QWORD *)&v245 + 1) = v244;
  *(_QWORD *)&v245 = v242;
  v246.i64[0] = 0xFFFFFFFFFFFFFFLL;
  v246.i64[1] = 0xFFFFFFFFFFFFFFLL;
  *a1 = vandq_s8(v243, v246);
  a1[1].i64[0] = v242 & 0xFFFFFFFFFFFFFFLL;
  a1[1].i64[1] = (v245 >> 56) + ((v225 + v226 - 256) & 0xFFFFFFFFFFFFFFLL);
  v247 = a6->i64[0] + a5->i64[0];
  v248 = a6->i64[1] + a5->i64[1];
  v249 = vaddq_s64(a6[1], a5[1]);
  v250 = v249.i64[1];
  v251 = 2 * v248;
  v252 = v250 * v250;
  v253 = ((unint64_t)v250 * (unsigned __int128)(unint64_t)v250) >> 64;
  v254 = ((unint64_t)(2 * v248) * (unsigned __int128)v249.u64[1]
        + v249.u64[0] * (unsigned __int128)v249.u64[0]
        + (((unint64_t)v250 * (unsigned __int128)(unint64_t)v250) >> 16)) >> 64;
  v255 = 2 * v248 * v249.i64[1]
       + v249.i64[0] * v249.i64[0]
       + (((unint64_t)v250 * (unsigned __int128)(unint64_t)v250) >> 16);
  v256 = 2 * v249.i64[0] * v247;
  v31 = __CFADD__(v248 * v248, v256);
  v257 = v248 * v248 + v256;
  v258 = ((unint64_t)v248 * (unsigned __int128)(unint64_t)v248) >> 64;
  v259 = ((unint64_t)(2 * v249.i64[0]) * (unsigned __int128)(unint64_t)v248) >> 64;
  v260 = 2 * v249.i64[0] * v248;
  v261 = v249.i64[1] * 2 * v249.i64[0];
  v262 = (v249.u64[1] * (unsigned __int128)(unint64_t)(2 * v249.i64[0])) >> 64;
  v263 = (__PAIR128__((((unint64_t)(2 * v249.i64[0]) * (unsigned __int128)(unint64_t)v247) >> 64) + v31 + v258, v257)- __PAIR128__(v253, v252)) >> 64;
  v264 = v257 - v252;
  v265 = (v261 << 40) & 0xFFFE0000000000;
  v31 = __CFADD__(v264, v265);
  v266 = v264 + v265;
  if (v31)
    ++v263;
  *((_QWORD *)&v267 + 1) = v254;
  *(_QWORD *)&v267 = v255;
  v268 = __PAIR128__(v263, v266) + (v267 >> 16) - (unint64_t)(v363 + v358);
  v270 = (__PAIR128__(v259, v260)
        + v249.u64[1] * (unsigned __int128)(unint64_t)(2 * v247)
        + ((v249.u64[1] * (unsigned __int128)(unint64_t)(2 * v249.i64[0])) >> 16)) >> 64;
  v269 = v260 + v249.i64[1] * 2 * v247 + ((v249.u64[1] * (unsigned __int128)(unint64_t)(2 * v249.i64[0])) >> 16);
  v271 = (unint64_t)(unsigned __int16)v252 << 40;
  v31 = __CFADD__(v269, v271);
  v272 = v269 + v271;
  if (v31)
    ++v270;
  v274 = (__PAIR128__(v270, v272) - (v109 + v357)) >> 64;
  v273 = v272 - (v109 + v357);
  *((_QWORD *)&v276 + 1) = ((unint64_t)v268 >= 0x100) + *((_QWORD *)&v268 + 1) + 0x7FFFFFFFFFFFFF80;
  *(_QWORD *)&v276 = v268 - 256;
  v275 = v276 >> 56;
  v31 = __CFADD__(v273, v275);
  v277 = v273 + v275;
  v278 = HIBYTE(*((_QWORD *)&v276 + 1)) + v31 + v274;
  v279 = v362 + (v49 & 0xFFFFFFFFFFFFFFLL);
  v31 = v277 >= 0x100;
  v280 = v277 - 256;
  if (v31)
    ++v278;
  v31 = __CFADD__(v255, v279);
  v281 = v255 + v279;
  *((_QWORD *)&v283 + 1) = v278;
  *(_QWORD *)&v283 = v280;
  v282 = v283 >> 56;
  if (v31)
    ++v254;
  v284 = __PAIR128__(v254, v281) + __PAIR128__(HIBYTE(v278), v282);
  if (__CFADD__(v261, v364 + v360))
    ++v262;
  v286 = v251 * v247 - (v261 + v364 + v360);
  v285 = ((unint64_t)v251 * (unsigned __int128)(unint64_t)v247 - __PAIR128__(v262, v261 + v364 + v360)) >> 64;
  v287 = (unint64_t)(unsigned __int16)v255 << 40;
  v31 = __CFADD__(v286, v287);
  v288 = v286 + v287;
  v289 = ((v268 - 256) & 0xFFFFFFFFFFFFFFLL) + (v278 >> 8);
  *((_QWORD *)&v290 + 1) = v278;
  *(_QWORD *)&v290 = v280;
  v291 = (v290 >> 16) & 0xFFFF0000000000;
  if (v31)
    ++v285;
  v31 = __CFADD__(v288, v291);
  v292 = v288 + v291;
  v293 = ((unint64_t)v247 * (unsigned __int128)(unint64_t)v247) >> 64;
  v294 = v247 * v247;
  v295 = v280 & 0xFFFFFFFFFFFFFFLL;
  if (v31)
    ++v285;
  v296 = __PAIR128__(v293, v294) - v284 + __PAIR128__(0x8000000000000001, 33024);
  v297.i64[1] = v292 + (v296 >> 56) - 0x81000000000100;
  v297.i64[0] = v294 - v284 + 33024;
  *a3 = vandq_s8(v297, v246);
  *((_QWORD *)&v298 + 1) = v297.i64[0];
  *(_QWORD *)&v298 = v289
                   + ((__int128)(__PAIR128__(HIBYTE(*((_QWORD *)&v296 + 1))+ (unint64_t)__CFADD__(v292, (unint64_t)(v296 >> 56))+ v285, v292 + (unint64_t)(v296 >> 56))+ __PAIR128__(0x7FFFFFFFFFFFFF80, 0xFF7EFFFFFFFFFF00)) >> 56);
  a3[1].i64[0] = v298 & 0xFFFFFFFFFFFFFFLL;
  a3[1].i64[1] = (v298 >> 56) + v295;
  v299 = 4 * v228 - a1->i64[0] + 0x400000000000004;
  v300 = 4 * (v355 & 0xFFFFFFFFFFFFFFLL) - a1->i64[1] + 0x3FFFBFFFFFFFFFCLL;
  v301 = 4 * (v351 & 0xFFFFFFFFFFFFFFLL) - a1[1].i64[0] + 0x3FFFFFFFFFFFFFCLL;
  v302 = 4 * v353 - a1[1].i64[1] + 0x3FFFFFFFFFFFFFCLL;
  v368 = ((unint64_t)v211 * (unsigned __int128)(unint64_t)v299) >> 64;
  v366 = ((unint64_t)v208 * (unsigned __int128)(unint64_t)v299) >> 64;
  v359 = v208 * v299;
  v361 = v211 * v299;
  v303 = ((unint64_t)v205 * (unsigned __int128)(unint64_t)v299) >> 64;
  v304 = v205 * v299;
  v356 = (unint64_t)v211 * (unsigned __int128)(unint64_t)v302;
  v349 = v203 * v299;
  v305 = ((unint64_t)v208 * (unsigned __int128)(unint64_t)v302) >> 64;
  v306 = v208 * v302;
  v352 = ((unint64_t)v205 * (unsigned __int128)(unint64_t)v300) >> 64;
  v354 = (v203 * (unsigned __int128)(unint64_t)v299) >> 64;
  v348 = v205 * v300;
  v307 = -8 * v109 * 2 * v363 + v203 * v301 + v205 * v302;
  v309 = (-(v109 * (__int128)8) * v109 + v203 * (unsigned __int128)(unint64_t)v302) >> 64;
  v308 = -8 * v109 * v109 + v203 * v302;
  v310 = ((-(v109 * (__int128)8) * (unint64_t)(2 * v363)
         + v203 * (unsigned __int128)(unint64_t)v301
         + (unint64_t)v205 * (unsigned __int128)(unint64_t)v302) >> 64)
       + 0xFFFFFFFFFFFFFFLL;
  v311 = v203 * (unsigned __int128)(unint64_t)v300
       - (v109 * (unsigned __int128)(unint64_t)(2 * v364)
        + (unint64_t)v363 * (unsigned __int128)(unint64_t)v363)
       * 8
       + (unint64_t)v205 * (unsigned __int128)(unint64_t)v301
       + __PAIR128__(v305, v306);
  *((_QWORD *)&v298 + 1) = v309 + 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)&v298 = v308;
  v312 = v203 * v300 - 8 * (v109 * 2 * v364 + v363 * v363) + v205 * v301 + v306 + (v298 >> 16);
  v313 = ((v311 + ((unsigned __int128)v298 >> 16)) >> 64) + 0xFFFEFFFFFFFFFFLL;
  v315 = (__PAIR128__(v303, v304)
        - ((unint64_t)v362 * (unsigned __int128)(unint64_t)(2 * v363)
         + (unint64_t)v364 * (unsigned __int128)(unint64_t)v364)
        * 8
        + (unint64_t)v208 * (unsigned __int128)(unint64_t)v300
        + (unint64_t)v211 * (unsigned __int128)(unint64_t)v301
        - __PAIR128__(v309 + 0xFFFFFFFFFFFFFFLL, v308)) >> 64;
  v314 = v304 - 8 * (v362 * 2 * v363 + v364 * v364) + v208 * v300 + v211 * v301 - v308;
  v316 = (unint64_t)(unsigned __int16)v307 << 40;
  v31 = __CFADD__(v314, v316);
  v317 = v314 + v316;
  *((_QWORD *)&v298 + 1) = v313;
  *(_QWORD *)&v298 = v312;
  v318 = v298 >> 16;
  if (v31)
    ++v315;
  v319 = v317 + v318;
  v320 = ((__PAIR128__(v315, v317) + __PAIR128__(v313 >> 16, v318)) >> 64) - 0x7F00000000000081;
  *((_QWORD *)&v321 + 1) = v310;
  *(_QWORD *)&v321 = v307;
  v322 = (unint64_t)(unsigned __int16)v308 << 40;
  v324 = __PAIR128__(v354, v349)
       - ((unint64_t)v364 * (unsigned __int128)(unint64_t)(2 * v363)
        + v109 * (unsigned __int128)(unint64_t)(2 * v362))
       * 8
       + __PAIR128__(v352, v348)
       + (unint64_t)v208 * (unsigned __int128)(unint64_t)v301
       + v356
       + ((unsigned __int128)v321 >> 16);
  v323 = *((_QWORD *)&v324 + 1);
  v31 = __CFADD__((_QWORD)v324, v322);
  v325 = v324 + v322;
  *((_QWORD *)&v321 + 1) = v320;
  *(_QWORD *)&v321 = v319;
  v326 = v321 >> 56;
  if (v31)
    v323 = *((_QWORD *)&v324 + 1) + 1;
  v31 = __CFADD__(v325, v326);
  v327 = v325 + v326;
  v328 = HIBYTE(v320) + v31 + v323 + 0x100000000000000;
  v329 = __PAIR128__((unsigned __int128)(-8 * v362 * (__int128)v362) >> 64, -(8 * v362 * v362))
       + __PAIR128__(v368, v361);
  *((_QWORD *)&v330 + 1) = v328;
  *(_QWORD *)&v330 = v327;
  v331 = __PAIR128__(v313, v312) + ((unsigned __int128)v330 >> 56);
  v333 = v359 - 8 * v362 * 2 * v364 + v211 * v300 - v307;
  v332 = (__PAIR128__((unsigned __int128)(-8 * v362 * (__int128)(2 * v364)) >> 64, -(8 * v362 * 2 * v364))
        + __PAIR128__(v366, v359)
        + (unint64_t)v211 * (unsigned __int128)(unint64_t)v300
        - __PAIR128__(v310, v307)) >> 64;
  v334 = (unint64_t)(unsigned __int16)v312 << 40;
  v31 = __CFADD__(v333, v334);
  v335 = v333 + v334;
  *((_QWORD *)&v330 + 1) = v328;
  *(_QWORD *)&v330 = v327;
  v336 = (v330 >> 16) & 0xFFFF0000000000;
  if (v31)
    ++v332;
  v31 = __CFADD__(v335, v336);
  v337 = v335 + v336;
  if (v31)
    ++v332;
  v338 = (v319 & 0xFFFFFFFFFFFFFFLL) + (v328 >> 8);
  v340 = (__PAIR128__(((unint64_t)((v329 - v331 + __PAIR128__(0x8100000000000000, 0x8000)) >> 64) >> 56)+ __CFADD__(v337, (unint64_t)((__int128)(v329 - v331 + __PAIR128__(0x8100000000000000, 0x8000)) >> 56))+ v332, v337 + (unint64_t)((__int128)(v329 - v331 + __PAIR128__(0x8100000000000000, 0x8000)) >> 56))+ __PAIR128__(0x80FFFFFFFFFFFF7ELL, 0xFF80000000000000)) >> 64;
  v339 = v337 + ((__int128)(v329 - v331 + __PAIR128__(0x8100000000000000, 0x8000)) >> 56) - 0x80000000000000;
  v341.i64[0] = v361 - 8 * v362 * v362 - v331 + 0x8000;
  v341.i64[1] = v339;
  v342 = (__int128)__PAIR128__(v340, v339) >> 56;
  v31 = __CFADD__(v338, v342);
  v343 = v338 + v342;
  v344 = v327 & 0xFFFFFFFFFFFFFFLL;
  v345 = HIBYTE(v340);
  if (v31)
    ++v345;
  *((_QWORD *)&v346 + 1) = v345;
  *(_QWORD *)&v346 = v343;
  a2[1].i64[0] = v343 & 0xFFFFFFFFFFFFFFLL;
  a2[1].i64[1] = (v346 >> 56) + v344;
  result = vandq_s8(v341, v246);
  *a2 = result;
  return result;
}

void ec_GFp_nistp224_make_precomp(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, int64x2_t a7)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  int64x2_t *v11;
  int64x2_t *v12;
  unint64_t v13;
  int8x16_t *v14;
  int8x16_t *v15;
  int8x16_t *v16;

  v8 = 0;
  v9 = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 96) = *(_QWORD *)a2 & 0xFFFFFFFFFFFFFFLL;
  v10 = (unint64_t *)(a1 + 96);
  *(_QWORD *)(a1 + 104) = (*(__int128 *)a2 >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 112) = (*(__int128 *)(a2 + 8) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 120) = (*(__int128 *)(a2 + 16) >> 40) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 72) & 0xFFFFFFFFFFFFFFLL;
  v11 = (int64x2_t *)(a1 + 128);
  *(_QWORD *)(a1 + 136) = (*(__int128 *)(a2 + 72) >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 144) = (*(__int128 *)(a2 + 80) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 152) = (*(__int128 *)(a2 + 88) >> 40) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 144) & 0xFFFFFFFFFFFFFFLL;
  v12 = (int64x2_t *)(a1 + 160);
  *(_QWORD *)(a1 + 168) = (*(__int128 *)(a2 + 144) >> 56) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 176) = (*(__int128 *)(a2 + 152) >> 48) & 0xFFFFFFFFFFFFFFLL;
  *(_QWORD *)(a1 + 184) = (*(__int128 *)(a2 + 160) >> 40) & 0xFFFFFFFFFFFFFFLL;
  v13 = 2;
  do
  {
    while (1)
    {
      v14 = (int8x16_t *)(a1 + v8 + 192);
      v15 = (int8x16_t *)(a1 + v8 + 224);
      v16 = (int8x16_t *)(a1 + v8 + 256);
      if ((v13 & 1) != 0)
        break;
      v9 = p224_point_double(v14, v15, v16, (unint64_t *)(a1 + 96 * (v13 >> 1)), (int64x2_t *)(a1 + 96 * (v13 >> 1) + 32), (int64x2_t *)(a1 + 96 * (v13 >> 1) + 64)).u64[0];
      ++v13;
      v8 += 96;
      if (v8 == 1440)
        return;
    }
    v9 = p224_point_add(v14, v15, v16, v10, v11, v12, 0, (unint64_t *)(a1 + v8 + 96), *(double *)&v9, a4, a5, a6, a7, (int8x16_t *)(a1 + v8 + 128), (unint64_t *)(a1 + v8 + 160)).u64[0];
    ++v13;
    v8 += 96;
  }
  while (v8 != 1440);
}

uint64_t p224_select_point(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  v5 = (_QWORD *)(a3 + 48);
  do
  {
    v6 = (((v4 ^ result) - 1) & ~result) >> 63;
    v7 = *(_QWORD *)(a4 + 8);
    *(_QWORD *)a4 |= *(v5 - 6) & v6;
    *(_QWORD *)(a4 + 8) = v7 | *(v5 - 5) & v6;
    v8 = *(_QWORD *)(a4 + 24);
    *(_QWORD *)(a4 + 16) |= *(v5 - 4) & v6;
    *(_QWORD *)(a4 + 24) = v8 | *(v5 - 3) & v6;
    v9 = *(_QWORD *)(a4 + 40);
    *(_QWORD *)(a4 + 32) |= *(v5 - 2) & v6;
    *(_QWORD *)(a4 + 40) = v9 | *(v5 - 1) & v6;
    v10 = *(_QWORD *)(a4 + 56);
    *(_QWORD *)(a4 + 48) |= *v5 & v6;
    *(_QWORD *)(a4 + 56) = v10 | v5[1] & v6;
    v11 = *(_QWORD *)(a4 + 72);
    *(_QWORD *)(a4 + 64) |= v5[2] & v6;
    *(_QWORD *)(a4 + 72) = v11 | v5[3] & v6;
    v12 = *(_QWORD *)(a4 + 88);
    *(_QWORD *)(a4 + 80) |= v5[4] & v6;
    *(_QWORD *)(a4 + 88) = v12 | v5[5] & v6;
    ++v4;
    v5 += 12;
  }
  while (a2 != v4);
  return result;
}

void EC_GFp_nistp256_method_init()
{
  EC_GFp_nistp256_method_storage = (uint64_t)ec_GFp_nistp256_point_get_affine_coordinates;
  qword_253EA7AE0 = (uint64_t)ec_GFp_nistp256_add;
  unk_253EA7AE8 = ec_GFp_nistp256_dbl;
  qword_253EA7AF0 = (uint64_t)ec_GFp_nistp256_point_mul;
  unk_253EA7AF8 = ec_GFp_nistp256_point_mul_base;
  qword_253EA7B08 = (uint64_t)ec_GFp_nistp256_point_mul_public;
  qword_253EA7B28 = (uint64_t)ec_GFp_mont_felem_mul;
  unk_253EA7B30 = ec_GFp_mont_felem_sqr;
  qword_253EA7B38 = (uint64_t)ec_GFp_mont_felem_to_bytes;
  unk_253EA7B40 = ec_GFp_mont_felem_from_bytes;
  qword_253EA7B48 = (uint64_t)ec_GFp_mont_felem_reduce;
  unk_253EA7B50 = ec_GFp_mont_felem_exp;
  qword_253EA7B58 = (uint64_t)ec_simple_scalar_inv0_montgomery;
  unk_253EA7B60 = ec_simple_scalar_to_montgomery_inv_vartime;
  qword_253EA7B68 = (uint64_t)ec_GFp_nistp256_cmp_x_coordinate;
}

uint64_t ec_GFp_nistp256_point_get_affine_coordinates(uint64_t a1, _OWORD *a2, _OWORD *a3, _OWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  int8x8_t v9;
  __int128 v10;
  int v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  int8x16_t *v17;
  int8x16_t v18;
  uint64_t v19;
  int8x16_t v20;
  int8x16_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  _OWORD v25[2];
  _OWORD v26[2];
  _OWORD v27[2];
  _OWORD v28[2];
  _OWORD v29[2];
  _OWORD v30[2];
  _OWORD v31[2];
  _OWORD v32[2];
  _OWORD v33[2];
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v7 = *(unsigned int *)(a1 + 328);
  if ((int)v7 < 1)
    goto LABEL_18;
  if (v7 < 4)
  {
    v8 = 0;
    v9 = 0;
LABEL_15:
    v22 = v7 - v8;
    v23 = (uint64_t *)a2 + v8 + 18;
    do
    {
      v24 = *v23++;
      *(_QWORD *)&v9 |= v24;
      --v22;
    }
    while (v22);
    goto LABEL_17;
  }
  v8 = v7 & 0x7FFFFFFC;
  v17 = (int8x16_t *)(a2 + 10);
  v18 = 0uLL;
  v19 = v7 & 0xFFFFFFFC;
  v20 = 0uLL;
  do
  {
    v18 = vorrq_s8(v17[-1], v18);
    v20 = vorrq_s8(*v17, v20);
    v17 += 2;
    v19 -= 4;
  }
  while (v19);
  v21 = vorrq_s8(v20, v18);
  v9 = vorr_s8(*(int8x8_t *)v21.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
  if (v8 != v7)
    goto LABEL_15;
LABEL_17:
  if (!*(_QWORD *)&v9)
  {
LABEL_18:
    ERR_put_error(15, 0, 119, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/ec/p256.c", 421);
    return 0;
  }
  memset(v25, 0, sizeof(v25));
  v10 = a2[10];
  v26[0] = a2[9];
  v26[1] = v10;
  v34 = 0u;
  v35 = 0u;
  memset(v33, 0, sizeof(v33));
  memset(v32, 0, sizeof(v32));
  memset(v31, 0, sizeof(v31));
  memset(v30, 0, sizeof(v30));
  memset(v29, 0, sizeof(v29));
  memset(v28, 0, sizeof(v28));
  fiat_p256_square((uint64_t *)&v34, (unint64_t *)v26);
  fiat_p256_mul((uint64_t *)&v34, (unint64_t *)&v34, (unint64_t *)v26);
  fiat_p256_square((uint64_t *)v33, (unint64_t *)&v34);
  fiat_p256_mul((uint64_t *)v33, (unint64_t *)v33, (unint64_t *)v26);
  fiat_p256_square((uint64_t *)v32, (unint64_t *)v33);
  fiat_p256_square((uint64_t *)v32, (unint64_t *)v32);
  fiat_p256_square((uint64_t *)v32, (unint64_t *)v32);
  fiat_p256_mul((uint64_t *)v32, (unint64_t *)v32, (unint64_t *)v33);
  fiat_p256_square((uint64_t *)v31, (unint64_t *)v32);
  fiat_p256_square((uint64_t *)v31, (unint64_t *)v31);
  fiat_p256_square((uint64_t *)v31, (unint64_t *)v31);
  fiat_p256_square((uint64_t *)v31, (unint64_t *)v31);
  fiat_p256_square((uint64_t *)v31, (unint64_t *)v31);
  fiat_p256_square((uint64_t *)v31, (unint64_t *)v31);
  fiat_p256_mul((uint64_t *)v31, (unint64_t *)v31, (unint64_t *)v32);
  fiat_p256_square((uint64_t *)v30, (unint64_t *)v31);
  fiat_p256_square((uint64_t *)v30, (unint64_t *)v30);
  fiat_p256_square((uint64_t *)v30, (unint64_t *)v30);
  fiat_p256_mul((uint64_t *)v30, (unint64_t *)v30, (unint64_t *)v33);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v30);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v29, (unint64_t *)v29);
  fiat_p256_mul((uint64_t *)v29, (unint64_t *)v29, (unint64_t *)v30);
  fiat_p256_square((uint64_t *)v28, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v28, (unint64_t *)v28);
  fiat_p256_mul((uint64_t *)v28, (unint64_t *)v28, (unint64_t *)&v34);
  memset(v27, 0, sizeof(v27));
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v28);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_mul((uint64_t *)v27, (unint64_t *)v27, (unint64_t *)v26);
  v11 = 128;
  do
  {
    fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
    --v11;
  }
  while (v11);
  fiat_p256_mul((uint64_t *)v27, (unint64_t *)v27, (unint64_t *)v28);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_mul((uint64_t *)v27, (unint64_t *)v27, (unint64_t *)v28);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_mul((uint64_t *)v27, (unint64_t *)v27, (unint64_t *)v29);
  fiat_p256_square((uint64_t *)v27, (unint64_t *)v27);
  fiat_p256_square((uint64_t *)v25, (unint64_t *)v27);
  if (a3)
  {
    v12 = a2[1];
    v34 = *a2;
    v35 = v12;
    fiat_p256_mul((uint64_t *)&v34, (unint64_t *)&v34, (unint64_t *)v25);
    v13 = v35;
    *a3 = v34;
    a3[1] = v13;
  }
  if (a4)
  {
    v14 = *(_OWORD *)((char *)a2 + 88);
    v34 = *(_OWORD *)((char *)a2 + 72);
    v35 = v14;
    fiat_p256_square((uint64_t *)v25, (unint64_t *)v25);
    fiat_p256_mul((uint64_t *)&v34, (unint64_t *)&v34, (unint64_t *)v26);
    fiat_p256_mul((uint64_t *)&v34, (unint64_t *)&v34, (unint64_t *)v25);
    v15 = v35;
    *a4 = v34;
    a4[1] = v15;
  }
  return 1;
}

double ec_GFp_nistp256_add(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  int8x16_t v9;
  int8x16_t v10;
  __int128 v11;
  __int128 v12;
  double result;
  __int128 v14;
  int8x16_t v15[2];
  int8x16_t v16[2];
  _OWORD v17[2];
  int8x16_t v18;
  __int128 v19;
  int8x16_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v5 = a3[1];
  v22 = *a3;
  v23 = v5;
  v6 = *(__int128 *)((char *)a3 + 88);
  v20 = *(int8x16_t *)((char *)a3 + 72);
  v21 = v6;
  v7 = a3[10];
  v18 = (int8x16_t)a3[9];
  v19 = v7;
  v8 = *(_OWORD *)(a4 + 16);
  v17[0] = *(_OWORD *)a4;
  v17[1] = v8;
  v9 = *(int8x16_t *)(a4 + 88);
  v16[0] = *(int8x16_t *)(a4 + 72);
  v16[1] = v9;
  v10 = *(int8x16_t *)(a4 + 160);
  v15[0] = *(int8x16_t *)(a4 + 144);
  v15[1] = v10;
  fiat_p256_point_add((uint64_t *)&v22, &v20, &v18, (unint64_t *)&v22, (uint64_t)&v20, &v18, 0, (unint64_t *)v17, v16, v15);
  v11 = v23;
  *(_OWORD *)a2 = v22;
  *(_OWORD *)(a2 + 16) = v11;
  v12 = v21;
  *(int8x16_t *)(a2 + 72) = v20;
  *(_OWORD *)(a2 + 88) = v12;
  result = *(double *)v18.i64;
  v14 = v19;
  *(int8x16_t *)(a2 + 144) = v18;
  *(_OWORD *)(a2 + 160) = v14;
  return result;
}

double ec_GFp_nistp256_dbl(uint64_t a1, _OWORD *a2, __int128 *a3)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  double result;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = a3[1];
  v15 = *a3;
  v16 = v4;
  v5 = *(__int128 *)((char *)a3 + 88);
  v13 = *(__int128 *)((char *)a3 + 72);
  v14 = v5;
  v6 = a3[10];
  v11 = a3[9];
  v12 = v6;
  fiat_p256_point_double((uint64_t *)&v15, (uint64_t *)&v13, (uint64_t *)&v11, (unint64_t *)&v15, (unint64_t *)&v13, (unint64_t *)&v11);
  v7 = v16;
  *a2 = v15;
  a2[1] = v7;
  v8 = v14;
  *(_OWORD *)((char *)a2 + 72) = v13;
  *(_OWORD *)((char *)a2 + 88) = v8;
  result = *(double *)&v11;
  v10 = v12;
  a2[9] = v11;
  a2[10] = v10;
  return result;
}

double ec_GFp_nistp256_point_mul(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  __int128 v6;
  __int128 v7;
  int8x16_t v8;
  int8x16_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  int8x16_t *v13;
  int8x16_t *v14;
  int v15;
  unint64_t i;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  unint64_t v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  BOOL v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  BOOL v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  __int128 v70;
  __int128 v71;
  double result;
  __int128 v73;
  unint64_t v75[4];
  int8x16_t v76;
  uint64_t v77;
  uint64_t v78;
  int8x16_t v79;
  uint64_t v80;
  uint64_t v81;
  __int128 v82;
  __int128 v83;
  int8x16_t v84;
  __int128 v85;
  int8x16_t v86;
  __int128 v87;
  _OWORD v88[3];
  _BYTE v89[48];
  _OWORD v90[2];
  _OWORD v91[2];
  int8x16_t v92[92];
  _QWORD v93[9];

  v93[0] = *MEMORY[0x24BDAC8D0];
  bzero(v88, 0x660uLL);
  v6 = a3[1];
  v90[0] = *a3;
  v90[1] = v6;
  v7 = *(_OWORD *)((char *)a3 + 88);
  v91[0] = *(_OWORD *)((char *)a3 + 72);
  v91[1] = v7;
  v8 = *((int8x16_t *)a3 + 9);
  v9 = *((int8x16_t *)a3 + 10);
  v10 = -1440;
  v11 = 2;
  v92[0] = v8;
  v92[1] = v9;
  do
  {
    while (1)
    {
      v12 = &v93[v10 / 8];
      v13 = (int8x16_t *)&v93[v10 / 8 + 4];
      v14 = (int8x16_t *)&v93[v10 / 8 + 8];
      if ((v11 & 1) != 0)
        break;
      fiat_p256_point_double(v12, v13->i64, v14->i64, (unint64_t *)&v88[6 * (v11 >> 1)], (unint64_t *)&v88[6 * (v11 >> 1) + 2], (unint64_t *)&v89[96 * (v11 >> 1) + 16]);
      ++v11;
      v10 += 96;
      if (v11 == 17)
        goto LABEL_5;
    }
    fiat_p256_point_add(v12, v13, v14, (unint64_t *)v90, (uint64_t)v91, v92, 0, (unint64_t *)&v92[v10 / 0x10 + 86], &v92[v10 / 0x10 + 88], &v92[v10 / 0x10 + 90]);
    ++v11;
    v10 += 96;
  }
  while (v11 != 17);
LABEL_5:
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  v15 = 1;
  for (i = 255; i < 0x100; --i)
  {
    if (v15)
    {
      if (-858993459 * i > 0x33333333)
        continue;
    }
    else
    {
      fiat_p256_point_double((uint64_t *)&v82, v84.i64, v86.i64, (unint64_t *)&v82, (unint64_t *)&v84, (unint64_t *)&v86);
      if (-858993459 * i > 0x33333333)
        continue;
    }
    if (i <= 0xFB)
    {
      v17 = 32 * ((*(_QWORD *)(a4 + 8 * ((i + 4) >> 6)) >> (i + 4)) & 1);
      v18 = i + 3;
      goto LABEL_16;
    }
    if ((_DWORD)i == 252)
    {
      v17 = 0;
      v18 = 255;
LABEL_16:
      v19 = (16 * ((*(_QWORD *)(a4 + 8 * (v18 >> 6)) >> v18) & 1)) | v17;
      v20 = i + 2;
LABEL_17:
      v21 = (8 * ((*(_QWORD *)(a4 + 8 * (v20 >> 6)) >> v20) & 1)) | v19;
      v22 = i + 1;
      goto LABEL_18;
    }
    if (i <= 0xFD)
    {
      v19 = 0;
      v20 = 255;
      goto LABEL_17;
    }
    v21 = 0;
    if ((_DWORD)i == 254)
    {
      v22 = 255;
LABEL_18:
      v23 = (*(_QWORD *)(a4 + 8 * (v22 >> 6)) >> v22) & 1;
      v24 = i - 1;
      if ((i - 1) > 0xFF)
        goto LABEL_19;
      goto LABEL_25;
    }
    v23 = 0;
    v24 = i - 1;
    if ((i - 1) > 0xFF)
    {
LABEL_19:
      v25 = 0;
      goto LABEL_26;
    }
LABEL_25:
    v25 = (*(_QWORD *)(a4 + 8 * (v24 >> 6)) >> v24) & 1;
LABEL_26:
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v39 = (4 * v23) | (2 * ((*(_QWORD *)(a4 + ((i >> 3) & 0x1FFFFFFFFFFFFFF8)) >> i) & 1)) | v25 | v21;
    v40 = v21 >> 5;
    v41 = v40 - 1;
    v42 = -(uint64_t)v40;
    v43 = (((v39 ^ 0x3F) & v42 | v39 & v41) & 1) + (((v39 ^ 0x3F) & v42 | v39 & v41) >> 1);
    v44 = v89;
    do
    {
      if (v43 == v37)
        v45 = -1;
      else
        v45 = 0;
      if (v43 == v37)
        v46 = 0;
      else
        v46 = -1;
      v38 = v45 & *(v44 - 6) | v46 & v38;
      v36 = *(v44 - 5) & v45 | v46 & v36;
      v35 = *(v44 - 4) & v45 | v46 & v35;
      v34 = *(v44 - 3) & v45 | v46 & v34;
      v33 = *(v44 - 2) & v45 | v46 & v33;
      v32 = *(v44 - 1) & v45 | v46 & v32;
      v31 = *v44 & v45 | v46 & v31;
      v30 = v44[1] & v45 | v46 & v30;
      v29 = v44[2] & v45 | v46 & v29;
      v28 = v44[3] & v45 | v46 & v28;
      v27 = v44[4] & v45 | v46 & v27;
      v26 = v44[5] & v45 | v46 & v26;
      ++v37;
      v44 += 12;
    }
    while (v37 != 17);
    v75[2] = v35;
    v75[3] = v34;
    v75[0] = v38;
    v75[1] = v36;
    v79.i64[0] = v29;
    v79.i64[1] = v28;
    v80 = v27;
    v81 = v26;
    v47 = __CFADD__(v32, -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v43, v33) >> 64));
    v48 = v32 + -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v43, v33) >> 64);
    v49 = v47;
    v47 = v48 == 0;
    v50 = -v48;
    v52 = (v49 + !v47);
    v51 = v31 + v52;
    v53 = __CFADD__(v31, v52);
    v47 = v51 == 0;
    v54 = -v51;
    v56 = (v53 + !v47);
    v55 = v30 + v56;
    v57 = __CFADD__(v30, v56);
    v47 = v55 == 0;
    v58 = -v55;
    if (v57 + !v47)
      v59 = -1;
    else
      v59 = 0;
    v60 = v59 - v33;
    v47 = __CFADD__(__CFADD__(-v33, v59), v50);
    v61 = __CFADD__(-v33, v59) + v50;
    v47 |= __CFADD__(v59, v61);
    v61 += v59;
    v62 = v58 + __CFADD__(v47, v54) + (v59 & 0xFFFFFFFF00000001);
    v63 = v42;
    v64 = v42 & v60;
    v65 = ~v42;
    v66 = v65 & v33 | v64;
    v67 = v63 & v61 | v65 & v32;
    v68 = v63 & (v47 + v54) | v65 & v31;
    v76.i64[0] = v66;
    v76.i64[1] = v67;
    v69 = v62 & v63 | v65 & v30;
    v77 = v68;
    v78 = v69;
    if (v15)
    {
      v15 = 0;
      *(_QWORD *)&v82 = v38;
      *((_QWORD *)&v82 + 1) = v36;
      *(_QWORD *)&v83 = v35;
      *((_QWORD *)&v83 + 1) = v34;
      v84.i64[0] = v66;
      v84.i64[1] = v67;
      *(_QWORD *)&v85 = v68;
      *((_QWORD *)&v85 + 1) = v69;
      v86.i64[0] = v29;
      v86.i64[1] = v28;
      *(_QWORD *)&v87 = v27;
      *((_QWORD *)&v87 + 1) = v26;
    }
    else
    {
      fiat_p256_point_add((uint64_t *)&v82, &v84, &v86, (unint64_t *)&v82, (uint64_t)&v84, &v86, 0, v75, &v76, &v79);
    }
  }
  v70 = v83;
  *(_OWORD *)a2 = v82;
  *(_OWORD *)(a2 + 16) = v70;
  v71 = v85;
  *(int8x16_t *)(a2 + 72) = v84;
  *(_OWORD *)(a2 + 88) = v71;
  result = *(double *)v86.i64;
  v73 = v87;
  *(int8x16_t *)(a2 + 144) = v86;
  *(_OWORD *)(a2 + 160) = v73;
  return result;
}

double ec_GFp_nistp256_point_mul_base(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __int128 v9;
  int8x16_t v10;
  double result;
  int8x16_t v12;
  unint64_t v13;
  _OWORD v15[2];
  int8x16_t v16[2];
  int8x16_t v17[2];
  __int128 v18;
  __int128 v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v4 = a3[2];
  v13 = a3[3];
  v6 = *a3;
  v5 = a3[1];
  fiat_p256_select_point_affine((v13 >> 60) & 8 | (v4 >> 61) & 0xFFFFFFFFFFFFFFFCLL | (v5 >> 62) & 0xFFFFFFFFFFFFFFFELL | (*a3 >> 63), (uint64_t)&unk_208F2F3F0, (uint64_t)v15);
  v18 = v15[0];
  v19 = v15[1];
  v20 = v16[0];
  v21 = v16[1];
  v22 = v17[0];
  v23 = v17[1];
  fiat_p256_select_point_affine((v13 >> 28) & 8 | (v4 >> 29) & 0xFFFFFFFFFFFFFFFCLL | (v5 >> 30) & 0xFFFFFFFFFFFFFFFELL | (v6 >> 31) & 1, (uint64_t)&fiat_p256_g_pre_comp, (uint64_t)v15);
  fiat_p256_point_add((uint64_t *)&v18, &v20, &v22, (unint64_t *)&v18, (uint64_t)&v20, &v22, 1, (unint64_t *)v15, v16, v17);
  v7 = 158;
  do
  {
    fiat_p256_point_double((uint64_t *)&v18, v20.i64, v22.i64, (unint64_t *)&v18, (unint64_t *)&v20, (unint64_t *)&v22);
    fiat_p256_select_point_affine((8 * ((a3[(v7 + 96) >> 6] >> (v7 - 96)) & 1)) | (4* ((a3[(v7 + 32) >> 6] >> (v7 - 96)) & 1)) | (2 * ((a3[(v7 - 32) >> 6] >> (v7 - 96)) & 1)) | (a3[(v7 - 96) >> 6] >> (v7 - 96)) & 1, (uint64_t)&unk_208F2F3F0, (uint64_t)v15);
    fiat_p256_point_add((uint64_t *)&v18, &v20, &v22, (unint64_t *)&v18, (uint64_t)&v20, &v22, 1, (unint64_t *)v15, v16, v17);
    fiat_p256_select_point_affine((8 * ((*(unint64_t *)((char *)a3 + (((v7 + 64) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v7) & 1)) | (4 * ((*(unint64_t *)((char *)a3 + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v7) & 1)) | (2 * ((*(unint64_t *)((char *)a3 + (((v7 - 64) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v7) & 1)) | (*(unint64_t *)((char *)a3 + (((v7 - 128) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v7) & 1, (uint64_t)&fiat_p256_g_pre_comp, (uint64_t)v15);
    fiat_p256_point_add((uint64_t *)&v18, &v20, &v22, (unint64_t *)&v18, (uint64_t)&v20, &v22, 1, (unint64_t *)v15, v16, v17);
    v8 = v7 - 129;
    --v7;
  }
  while (v8 < 0x20);
  v9 = v19;
  *(_OWORD *)a2 = v18;
  *(_OWORD *)(a2 + 16) = v9;
  v10 = v21;
  *(int8x16_t *)(a2 + 72) = v20;
  *(int8x16_t *)(a2 + 88) = v10;
  result = *(double *)v22.i64;
  v12 = v23;
  *(int8x16_t *)(a2 + 144) = v22;
  *(int8x16_t *)(a2 + 160) = v12;
  return result;
}

double ec_GFp_nistp256_point_mul_public(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, _DWORD *a5)
{
  __int128 v7;
  __int128 v8;
  int8x16_t v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  int v16;
  unint64_t i;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t *v20;
  int8x16_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  unsigned int v30;
  int8x16_t *v31;
  int8x16_t *v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int8 v35;
  BOOL v36;
  uint64_t v37;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  BOOL v44;
  uint64_t v45;
  unsigned __int8 v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int8x16_t v53;
  int8x16_t v54;
  double result;
  int8x16_t v56;
  __int128 v59;
  __int128 v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t v64;
  int8x16_t v65;
  int8x16_t v66;
  _BYTE v67[257];
  unint64_t v68[4];
  int8x16_t v69[2];
  int8x16_t v70[2];
  _OWORD v71[2];
  _OWORD v72[2];
  int8x16_t v73[2];
  uint64_t v74[4];
  int8x16_t v75[2];
  int8x16_t v76[2];
  uint64_t v77[4];
  int8x16_t v78[2];
  int8x16_t v79[2];
  uint64_t v80[4];
  int8x16_t v81[2];
  int8x16_t v82[2];
  uint64_t v83[4];
  int8x16_t v84[2];
  int8x16_t v85[2];
  uint64_t v86[4];
  int8x16_t v87[2];
  int8x16_t v88[2];
  uint64_t v89[4];
  int8x16_t v90[2];
  int8x16_t v91[2];
  uint64_t v92[4];
  int8x16_t v93[2];
  int8x16_t v94[2];
  uint64_t v95;

  v95 = *MEMORY[0x24BDAC8D0];
  v7 = *(_OWORD *)(a4 + 16);
  v71[0] = *(_OWORD *)a4;
  v71[1] = v7;
  v8 = *(_OWORD *)(a4 + 88);
  v72[0] = *(_OWORD *)(a4 + 72);
  v72[1] = v8;
  v9 = *(int8x16_t *)(a4 + 160);
  v73[0] = *(int8x16_t *)(a4 + 144);
  v73[1] = v9;
  fiat_p256_point_double((uint64_t *)v68, v69[0].i64, v70[0].i64, (unint64_t *)v71, (unint64_t *)v72, (unint64_t *)v73);
  fiat_p256_point_add(v74, v75, v76, (unint64_t *)v71, (uint64_t)v72, v73, 0, v68, v69, v70);
  fiat_p256_point_add(v77, v78, v79, (unint64_t *)v74, (uint64_t)v75, v76, 0, v68, v69, v70);
  fiat_p256_point_add(v80, v81, v82, (unint64_t *)v77, (uint64_t)v78, v79, 0, v68, v69, v70);
  fiat_p256_point_add(v83, v84, v85, (unint64_t *)v80, (uint64_t)v81, v82, 0, v68, v69, v70);
  fiat_p256_point_add(v86, v87, v88, (unint64_t *)v83, (uint64_t)v84, v85, 0, v68, v69, v70);
  fiat_p256_point_add(v89, v90, v91, (unint64_t *)v86, (uint64_t)v87, v88, 0, v68, v69, v70);
  fiat_p256_point_add(v92, v93, v94, (unint64_t *)v89, (uint64_t)v90, v91, 0, v68, v69, v70);
  v10 = 0;
  v11 = *a5 & 0x1F;
  v12 = *(int *)(a1 + 264);
  do
  {
    while (1)
    {
      v14 = v11 - 32;
      if (v10 >= 0xFB)
        v14 = v11 & 0xF;
      if ((v11 & 0x10) == 0)
        v14 = v11;
      if ((v11 & 1) != 0)
        v11 -= v14;
      else
        LOBYTE(v14) = 0;
      v67[v10] = v14;
      v15 = (v10 + 5) >> 6;
      if (v15 >= v12)
        break;
      v13 = (*(_QWORD *)&a5[2 * v15] >> (v10 + 5)) & 1;
      v11 = (v11 >> 1) + 16 * v13;
      if (++v10 == 257)
        goto LABEL_12;
    }
    v13 = 0;
    v11 >>= 1;
    ++v10;
  }
  while (v10 != 257);
LABEL_12:
  v65 = 0u;
  v66 = 0u;
  v16 = 1;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  for (i = 256; i != -1; --i)
  {
    if (v16)
    {
      if (i > 0x1F)
        goto LABEL_24;
    }
    else
    {
      fiat_p256_point_double(v61.i64, v63.i64, v65.i64, (unint64_t *)&v61, (unint64_t *)&v63, (unint64_t *)&v65);
      if (i > 0x1F)
        goto LABEL_24;
    }
    v23 = a3[2];
    v22 = a3[3];
    v25 = *a3;
    v24 = a3[1];
    v26 = (8 * ((v22 >> (i + 32)) & 1)) | (4 * ((v23 >> (i + 32)) & 1)) | (2 * ((v24 >> (i + 32)) & 1)) | (*a3 >> (i + 32)) & 1;
    if (v26)
    {
      fiat_p256_point_add(v61.i64, &v63, &v65, (unint64_t *)&v61, (uint64_t)&v63, &v65, 1, (unint64_t *)&fiat_p256_g_pre_comp + 8 * v26 + 112, (int8x16_t *)&fiat_p256_g_pre_comp + 4 * v26 + 58, fiat_p256_one);
      v16 = 0;
    }
    v27 = (8 * ((v22 >> i) & 1)) | (4 * ((v23 >> i) & 1)) | (2 * ((v24 >> i) & 1)) | (v25 >> i) & 1;
    if (v27)
    {
      fiat_p256_point_add(v61.i64, &v63, &v65, (unint64_t *)&v61, (uint64_t)&v63, &v65, 1, (unint64_t *)&fiat_p256_g_pre_comp + 8 * v27 - 8, (int8x16_t *)&fiat_p256_g_pre_comp + 4 * v27 - 2, fiat_p256_one);
      v16 = 0;
    }
LABEL_24:
    v28 = (char)v67[i];
    if (v67[i])
    {
      if (v28 >= 0)
        LOBYTE(v29) = v67[i];
      else
        v29 = -v28;
      v30 = v29 >> 1;
      v31 = (int8x16_t *)&v71[6 * v30];
      v32 = v31 + 2;
      v59 = 0u;
      v60 = 0u;
      if (v28 < 0)
      {
        v33 = v31[2].i64[1];
        v34 = -v32->i64[0];
        v35 = -(uint64_t)((unsigned __int128)-(__int128)__PAIR128__(v13, v32->i64[0]) >> 64);
        v36 = __CFADD__(v33, v35);
        v37 = v33 + v35;
        v38 = v36;
        v36 = v37 == 0;
        v39 = -v37;
        v41 = v31[3].i64[0];
        v40 = v31[3].i64[1];
        v43 = (v38 + !v36);
        v42 = v41 + v43;
        v44 = __CFADD__(v41, v43);
        v36 = v42 == 0;
        v45 = -v42;
        v46 = v44 + !v36;
        v36 = __CFADD__(v40, v46);
        v47 = v40 + v46;
        v48 = v36;
        v36 = v47 == 0;
        v49 = -v47;
        if (v48 + !v36)
          v50 = -1;
        else
          v50 = 0;
        v36 = __CFADD__(__CFADD__(v34, v50), v39);
        v51 = __CFADD__(v34, v50) + v39;
        v52 = v36 | __CFADD__(v50, v51);
        v36 = __CFADD__(v52, v45);
        v13 = v52 + v45;
        *(_QWORD *)&v59 = v34 + v50;
        *((_QWORD *)&v59 + 1) = v50 + v51;
        *(_QWORD *)&v60 = v13;
        *((_QWORD *)&v60 + 1) = v49 + v36 + (v50 & 0xFFFFFFFF00000001);
        v32 = (int8x16_t *)&v59;
        if (v16)
          goto LABEL_13;
LABEL_44:
        fiat_p256_point_add(v61.i64, &v63, &v65, (unint64_t *)&v61, (uint64_t)&v63, &v65, 0, (unint64_t *)v31, v32, &v73[6 * v30]);
      }
      else
      {
        if (!v16)
          goto LABEL_44;
LABEL_13:
        v18 = v31[1];
        v61 = *v31;
        v62 = v18;
        v19 = v32[1];
        v63 = *v32;
        v64 = v19;
        v20 = (int8x16_t *)&v71[6 * v30];
        v21 = v20[5];
        v65 = v20[4];
        v66 = v21;
      }
      v16 = 0;
      continue;
    }
  }
  v53 = v62;
  *(int8x16_t *)a2 = v61;
  *(int8x16_t *)(a2 + 16) = v53;
  v54 = v64;
  *(int8x16_t *)(a2 + 72) = v63;
  *(int8x16_t *)(a2 + 88) = v54;
  result = *(double *)v65.i64;
  v56 = v66;
  *(int8x16_t *)(a2 + 144) = v65;
  *(int8x16_t *)(a2 + 160) = v56;
  return result;
}

BOOL ec_GFp_nistp256_cmp_x_coordinate(uint64_t a1, int8x16_t *a2, __int128 *a3)
{
  uint64_t v3;
  uint64_t v7;
  int8x8_t v8;
  int8x16_t *v9;
  int8x16_t v10;
  uint64_t v11;
  int8x16_t v12;
  int8x16_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int8x16_t v17;
  __int128 v18;
  int8x16_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BOOL8 v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _BOOL8 v38;
  uint64_t v39;
  BOOL v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unsigned __int128 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _BOOL8 v50;
  _BOOL8 v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _BOOL8 v57;
  _BOOL8 v58;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unsigned __int128 v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unsigned __int128 v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t *v85;
  uint64_t v86;
  __int128 *v87;
  unint64_t i;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  _BOOL8 v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _BOOL8 v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  BOOL v114;
  BOOL v115;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  uint64_t v122;
  int8x16_t v123;
  int8x16_t v124;
  __int128 v125;
  __int128 v126;
  _OWORD v127[2];
  uint64_t v128;

  v128 = *MEMORY[0x24BDAC8D0];
  v3 = *(unsigned int *)(a1 + 328);
  if ((int)v3 < 1)
    return 0;
  if (v3 < 4)
  {
    v7 = 0;
    v8 = 0;
LABEL_7:
    v14 = v3 - v7;
    v15 = &a2[9].i64[v7];
    do
    {
      v16 = *v15++;
      *(_QWORD *)&v8 |= v16;
      --v14;
    }
    while (v14);
    goto LABEL_9;
  }
  v7 = v3 & 0x7FFFFFFC;
  v9 = a2 + 10;
  v10 = 0uLL;
  v11 = v3 & 0xFFFFFFFC;
  v12 = 0uLL;
  do
  {
    v10 = vorrq_s8(v9[-1], v10);
    v12 = vorrq_s8(*v9, v12);
    v9 += 2;
    v11 -= 4;
  }
  while (v11);
  v13 = vorrq_s8(v12, v10);
  v8 = vorr_s8(*(int8x8_t *)v13.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  if (v7 != v3)
    goto LABEL_7;
LABEL_9:
  if (!*(_QWORD *)&v8)
    return 0;
  v17 = a2[10];
  v127[0] = a2[9];
  v127[1] = v17;
  fiat_p256_mul((uint64_t *)v127, (unint64_t *)v127, (unint64_t *)v127);
  v18 = a3[1];
  v125 = *a3;
  v126 = v18;
  fiat_p256_mul((uint64_t *)&v125, (unint64_t *)&v125, (unint64_t *)v127);
  v19 = a2[1];
  v123 = *a2;
  v20 = (v123.u64[0] * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v21 = (v123.u64[0] * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v22 = 0xFFFFFFFFLL * v123.i64[0] + __CFADD__(-v123.i64[0], v123.i64[0]) + v21;
  if (__CFADD__(__CFADD__(-v123.i64[0], v123.i64[0]), v21) | __CFADD__(0xFFFFFFFFLL * v123.i64[0], __CFADD__(-v123.i64[0], v123.i64[0]) + v21))v23 = ((v123.u64[0] * (unsigned __int128)0xFFFFFFFFuLL) >> 64) + 1;
  else
    v23 = (v123.u64[0] * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v40 = __CFADD__(v22, v123.i64[1]);
  v24 = v22 + v123.i64[1];
  v25 = v40;
  v26 = 0xFFFFFFFF00000001 * v24;
  v27 = (__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v24) >> 64;
  v28 = v25 + __CFADD__(-v24, v24) + v23;
  v40 = __CFADD__(v28, v27);
  v29 = v28 + v27;
  v30 = v40 - 0xFFFFFFFFLL * v123.i64[0];
  v31 = __CFADD__(v40, 0xFFFFFFFF00000001 * v123.i64[0]);
  v40 = __CFADD__(v26, v20);
  v32 = v26 + v20;
  v33 = v40;
  v40 = __CFADD__(((unint64_t)v24 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFFLL * v24);
  v124 = v19;
  v34 = ((unint64_t)v24 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v35 = ((unint64_t)v24 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v37 = v40 + v30;
  v40 = __CFADD__(v40, v30) | __CFADD__(v35, v37);
  v36 = v35 + v37;
  v38 = v31 + v40 + v32;
  if (__CFADD__(v40, v32) | __CFADD__(v31, v40 + v32))
    v39 = v33 + 1;
  else
    v39 = v33;
  v40 = __CFADD__(v29, v124.i64[0]);
  v41 = v29 + v124.i64[0];
  v42 = v40;
  v43 = v40 + v36;
  v44 = (v41 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v45 = __PAIR128__(v39, __CFADD__(v40, v36)) + __PAIR128__(v34, v38);
  v46 = 0xFFFFFFFF * v41;
  v47 = (__PAIR128__(0xFFFFFFFFLL, -1) * v41) >> 64;
  v48 = v42 + __CFADD__(-(uint64_t)v41, v41) + v36;
  v49 = (__CFADD__(__CFADD__(-(uint64_t)v41, v41), v43) | __CFADD__(v47, __CFADD__(-(uint64_t)v41, v41) + v43))+ (_QWORD)v45;
  v50 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v41, v41), v43) | __CFADD__(v47, __CFADD__(-(uint64_t)v41, v41) + v43), (_QWORD)v45);
  v51 = __CFADD__(0xFFFFFFFF00000001 * v41, *((_QWORD *)&v45 + 1));
  v52 = 0xFFFFFFFF * v41;
  v53 = (v41 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v54 = (v41 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v55 = v48 + v44 + v46;
  v40 = __CFADD__(__CFADD__(v44, v46), v49) | __CFADD__(v54, (__PAIR128__(v49, v44) + (unint64_t)v52) >> 64);
  v56 = v54 + ((__PAIR128__(v49, v44) + (unint64_t)v52) >> 64);
  v57 = v50 + v40 + *((_QWORD *)&v45 + 1);
  if (__CFADD__(v40, *((_QWORD *)&v45 + 1)) | __CFADD__(v50, v40 + *((_QWORD *)&v45 + 1)))
    v58 = v51 + 1;
  else
    v58 = v51;
  v59 = __CFADD__(v55, v124.i64[1]);
  v60 = v55 + v124.i64[1];
  v61 = v59;
  v62 = v59 + v56;
  v63 = ((unint64_t)v60 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v64 = __PAIR128__(v58, __CFADD__(v59, v56)) + __PAIR128__(v53, v57);
  v65 = 0xFFFFFFFF00000001 * v60;
  v66 = -v60;
  v67 = (__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v60) >> 64;
  if (__CFADD__(((unint64_t)v60 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFFLL * v60))
    v68 = (((unint64_t)v60 * (unsigned __int128)0xFFFFFFFFuLL) >> 64) + 1;
  else
    v68 = ((unint64_t)v60 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v40 = __CFADD__(v66, v60);
  v69 = v61 + __CFADD__(v66, v60) + v56 + v67;
  v70 = v68 + (__CFADD__(v40, v62) | __CFADD__(v67, v40 + v62)) + (_QWORD)v64;
  v72 = __CFADD__(__CFADD__(v40, v62) | __CFADD__(v67, v40 + v62), (_QWORD)v64) | __CFADD__(v68, (__CFADD__(v40, v62) | __CFADD__(v67, v40 + v62)) + (_QWORD)v64);
  v71 = *((_QWORD *)&v64 + 1) + v72 + v65;
  if (__CFADD__(v72, v65) | __CFADD__(*((_QWORD *)&v64 + 1), v72 + v65))
    v73 = v63 + 1;
  else
    v73 = v63;
  v75 = v70 - (1 - __CFADD__(v69, 1));
  v74 = (v70 - __PAIR128__(v63, (1 - __CFADD__(v69, 1)))) >> 64;
  v76 = v73
      - __PAIR128__(v67, -(uint64_t)((v71- __PAIR128__(v74, (1 - (__CFADD__(v75, 0xFFFFFFFF00000001) + v74)))) >> 64));
  if (__CFADD__((_QWORD)v76, 0xFFFFFFFFLL) + BYTE8(v76) == 1)
    v77 = -1;
  else
    v77 = 0;
  v78 = v77 & (v69 + 1) | *((_QWORD *)&v76 + 1) & v69;
  v79 = v77 & (v75 - 0xFFFFFFFF) | *((_QWORD *)&v76 + 1) & v70;
  v80 = v77 & (v71 - (1 - (__CFADD__(v75, 0xFFFFFFFF00000001) + v74))) | *((_QWORD *)&v76 + 1) & v71;
  v81 = v77 & (v76 + 0xFFFFFFFF) | v73 & *((_QWORD *)&v76 + 1);
  v123.i64[0] = v78;
  v123.i64[1] = v79;
  v124.i64[0] = v80;
  v124.i64[1] = v81;
  if ((_QWORD)v125 == v78 && *((_QWORD *)&v125 + 1) == v79 && (_QWORD)v126 == v80 && *((_QWORD *)&v126 + 1) == v81)
    return 1;
  v122 = 0;
  v120 = 0u;
  v121 = 0u;
  v118 = 0u;
  v119 = 0u;
  v85 = *(unint64_t **)(a1 + 256);
  if (v3 < 4)
  {
    v86 = 0;
    v87 = &v118;
    i = (int)v3;
    do
    {
LABEL_79:
      v108 = *(_QWORD *)a3;
      a3 = (__int128 *)((char *)a3 + 8);
      v107 = v108;
      v110 = *v85++;
      v109 = v110;
      v40 = __CFADD__(v107, v86);
      v111 = v107 + v86;
      v112 = v40;
      v40 = __CFADD__(v111, v109);
      v113 = v111 + v109;
      if (v40)
        v86 = v112 + 1;
      else
        v86 = v112;
      *(_QWORD *)v87 = v113;
      v87 = (__int128 *)((char *)v87 + 8);
      --i;
    }
    while (i);
    goto LABEL_86;
  }
  v86 = 0;
  v87 = &v118;
  for (i = (int)v3; i >= 4; i -= 4)
  {
    v89 = *((_QWORD *)a3 + 1);
    v40 = __CFADD__(*(_QWORD *)a3, v86);
    v90 = *(_QWORD *)a3 + v86;
    v91 = v40;
    v92 = v85[1];
    v40 = __CFADD__(__CFADD__(v90, *v85), v89) | __CFADD__(v91, (__PAIR128__(v89, v90) + *v85) >> 64);
    v93 = v91 + ((__PAIR128__(v89, v90) + *v85) >> 64);
    v94 = v40;
    v40 = __CFADD__(v93, v92);
    *(_QWORD *)v87 = v90 + *v85;
    *((_QWORD *)v87 + 1) = v93 + v92;
    v95 = *((_QWORD *)a3 + 2);
    v96 = *((_QWORD *)a3 + 3);
    v98 = v40;
    v40 = __CFADD__(v40, v95);
    v97 = v98 + v95;
    v40 |= __CFADD__(v94, v97);
    v97 += v94;
    v99 = v40;
    v100 = v85[2];
    v101 = v85[3];
    v40 = __CFADD__(v101, v96);
    v102 = v101 + v96;
    v103 = v40;
    v40 = __CFADD__(v97, v100);
    v104 = v97 + v100;
    v106 = v40;
    v40 = __CFADD__(v40, v102);
    v105 = v106 + v102;
    v40 |= __CFADD__(v99, v105);
    v105 += v99;
    if (v40)
      v86 = v103 + 1;
    else
      v86 = v103;
    *((_QWORD *)v87 + 2) = v104;
    *((_QWORD *)v87 + 3) = v105;
    a3 += 2;
    v85 += 4;
    v87 += 2;
  }
  if (i)
    goto LABEL_79;
LABEL_86:
  if (v86 || (bn_cmp_words_consttime((uint64_t *)&v118, (int)v3, *(uint64_t **)(a1 + 320), (int)v3) & 0x80000000) == 0)
    return 0;
  v125 = v118;
  v126 = v119;
  fiat_p256_mul((uint64_t *)&v125, (unint64_t *)&v125, (unint64_t *)v127);
  v114 = (_QWORD)v125 == v123.i64[0] && *((_QWORD *)&v125 + 1) == v123.i64[1];
  v115 = v114 && (_QWORD)v126 == v124.i64[0];
  return v115 && *((_QWORD *)&v126 + 1) == v124.i64[1];
}

uint64_t *fiat_p256_mul(uint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _BOOL8 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  _BOOL8 v44;
  uint64_t v45;
  _BOOL8 v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned __int128 v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _BOOL8 v60;
  uint64_t v61;
  unint64_t StatusReg;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  BOOL v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned __int128 v93;
  uint64_t v94;
  unint64_t v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  _BOOL8 v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  uint64_t v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  unint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v146;
  _BOOL8 v147;
  unint64_t v148;
  _BOOL8 v149;
  char v150;
  uint64_t v151;
  _BOOL8 v152;
  uint64_t v153;
  uint64_t v154;
  _BOOL8 v155;
  uint64_t v156;
  uint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t v160;
  unsigned __int128 v161;
  uint64_t v162;
  uint64_t v163;

  v3 = a2[1];
  v5 = a3[2];
  v4 = a3[3];
  v6 = v4 * *a2;
  v7 = (v5 * (unsigned __int128)*a2) >> 64;
  v8 = v5 * *a2;
  v10 = *a3;
  v9 = a3[1];
  v11 = (v9 * (unsigned __int128)*a2) >> 64;
  v12 = v9 * *a2;
  v13 = v10 * *a2;
  v14 = (v10 * (unsigned __int128)*a2) >> 64;
  v15 = (__PAIR128__(v9, v10) * *a2) >> 64;
  v73 = __CFADD__(__CFADD__(v14, v12), v11) | __CFADD__(v8, __CFADD__(v14, v12) + v11);
  v16 = v8 + __CFADD__(v14, v12) + v11;
  v18 = v73;
  v73 = __CFADD__(v73, v7);
  v17 = v18 + v7;
  v73 |= __CFADD__(v6, v17);
  v17 += v6;
  if (v73)
    v19 = ((v4 * (unsigned __int128)*a2) >> 64) + 1;
  else
    v19 = (v4 * (unsigned __int128)*a2) >> 64;
  v20 = (v13 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v21 = 0xFFFFFFFF * v13;
  v22 = -(uint64_t)(v10 * *a2);
  v23 = (v13 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v24 = (__PAIR128__(0xFFFFFFFFLL, -1) * v13) >> 64;
  v25 = v12 + __CFADD__(v22, v13) + v14;
  v73 = __CFADD__(__CFADD__(__CFADD__(v22, v13), v15) | __CFADD__(v24, __CFADD__(v22, v13) + v15), v16);
  v26 = (__CFADD__(__CFADD__(v22, v13), v15) | __CFADD__(v24, __CFADD__(v22, v13) + v15)) + v16;
  v27 = v73;
  v73 = __CFADD__(v17, 0xFFFFFFFF00000001 * v13);
  v28 = v17 - 0xFFFFFFFF * v13;
  v29 = v73;
  v73 = __CFADD__(v20, v19);
  v30 = v20 + v19;
  v31 = v73;
  v32 = (v5 * (unsigned __int128)v3) >> 64;
  v33 = (v9 * (unsigned __int128)v3) >> 64;
  v34 = v9 * v3;
  v35 = (v10 * (unsigned __int128)v3) >> 64;
  v36 = (__PAIR128__(v9, v10) * v3) >> 64;
  v37 = v5 * v3 + __CFADD__(v35, v9 * v3) + v33;
  v38 = v4 * v3
      + (__CFADD__(__CFADD__(v35, v9 * v3), v33) | __CFADD__(v5 * v3, __CFADD__(v35, v9 * v3) + v33))
      + v32;
  if (__CFADD__(__CFADD__(__CFADD__(v35, v9 * v3), v33) | __CFADD__(v5 * v3, __CFADD__(v35, v9 * v3) + v33), v32) | __CFADD__(v4 * v3, (__CFADD__(__CFADD__(v35, v9 * v3), v33) | __CFADD__(v5 * v3, __CFADD__(v35, v9 * v3) + v33))+ v32))v39 = ((v4 * (unsigned __int128)v3) >> 64) + 1;
  else
    v39 = (v4 * (unsigned __int128)v3) >> 64;
  v40 = (v13 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v41 = v25 + v23 + v21;
  v73 = __CFADD__(__CFADD__(v23, v21), v26);
  v42 = __CFADD__(v23, v21) + v26;
  v73 |= __CFADD__(v40, v42);
  v42 += v40;
  v44 = v73;
  v73 = __CFADD__(v73, v28);
  v43 = v44 + v28;
  v73 |= __CFADD__(v27, v43);
  v43 += v27;
  v46 = v73;
  v73 = __CFADD__(v73, v30);
  v45 = v46 + v30;
  v73 |= __CFADD__(v29, v45);
  v45 += v29;
  v47 = v10 * v3;
  v48 = v31 + v73 + v39;
  if (__CFADD__(v73, v39) | __CFADD__(v31, v73 + v39))
    v49 = 1;
  else
    v49 = 0;
  v50 = __PAIR128__(v35, v41) + __PAIR128__(v34, v47);
  v51 = ((__PAIR128__(v35, v41) + __PAIR128__(v34, v47)) >> 64) + v42;
  v52 = (__CFADD__(__CFADD__(v41, v47), v36) | __CFADD__(v42, __CFADD__(v41, v47) + v36)) + v37;
  v53 = __CFADD__(__CFADD__(__CFADD__(v41, v47), v36) | __CFADD__(v42, __CFADD__(v41, v47) + v36), v37);
  v73 = __CFADD__(v45, v38);
  v54 = v45 + v38;
  v55 = v73;
  v56 = 0xFFFFFFFF * v50;
  v57 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v73 = __CFADD__(v52, v43);
  v58 = v52 + v43;
  v60 = v73;
  v73 = __CFADD__(v73, v54);
  v59 = v60 + v54;
  v73 |= __CFADD__(v53, v59);
  v59 += v53;
  v61 = v55 + v73 + v48;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v63 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v64 = v42 + __CFADD__(-(uint64_t)v50, (_QWORD)v50) + *((_QWORD *)&v50 + 1);
  v65 = (__CFADD__(__CFADD__(-(uint64_t)v50, (_QWORD)v50), v51) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (unint64_t)v50) >> 64, __CFADD__(-(uint64_t)v50, (_QWORD)v50)+ v51))+ v58;
  v73 = __CFADD__(v59, 0xFFFFFFFF00000001 * v50);
  v66 = v59 - 0xFFFFFFFF * v50;
  v67 = v73;
  v73 = __CFADD__(v61, v63);
  v68 = v61 + v63;
  v69 = v73;
  v70 = ((unint64_t)v50 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v73 = __CFADD__(__CFADD__(v57, v56), v65) | __CFADD__(v70, __CFADD__(v57, v56) + v65);
  v71 = v70 + __CFADD__(v57, v56) + v65;
  v72 = *((_QWORD *)&v50 + 1) + v73 + v66;
  v75 = __CFADD__(v73, v66) | __CFADD__(*((_QWORD *)&v50 + 1), v73 + v66);
  v73 = __CFADD__(v75, v68) | __CFADD__(v67, v75 + v68);
  v74 = v67 + v75 + v68;
  if (v73)
    v76 = v69 + 1;
  else
    v76 = v69;
  v77 = v64 + v57 + v56;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  v78 = v49 + v73 + v76;
  v80 = a2[2];
  v79 = a2[3];
  v81 = (v4 * (unsigned __int128)v80) >> 64;
  v82 = v4 * v80;
  v83 = (v5 * (unsigned __int128)v80) >> 64;
  v84 = v5 * v80;
  v85 = (v9 * (unsigned __int128)v80) >> 64;
  v86 = v9 * v80;
  v87 = v10 * v80;
  v88 = (v10 * (unsigned __int128)v80) >> 64;
  v89 = v88 + v86;
  v73 = __CFADD__(__CFADD__(v88, v86), v85) | __CFADD__(v84, __CFADD__(v88, v86) + v85);
  v90 = v84 + __CFADD__(v88, v86) + v85;
  v92 = v73 + v83;
  v73 = __CFADD__(v73, v83) | __CFADD__(v82, v92);
  v91 = v82 + v92;
  if (v73)
    ++v81;
  v93 = __PAIR128__(v88, v77) + __PAIR128__(v86, v87);
  v94 = ((__PAIR128__(v88, v77) + __PAIR128__(v86, v87)) >> 64) + v71;
  v96 = (__CFADD__(__CFADD__(v77, v87), v89) | __CFADD__(v71, __CFADD__(v77, v87) + v89)) + v90;
  v73 = __CFADD__(__CFADD__(__CFADD__(v77, v87), v89) | __CFADD__(v71, __CFADD__(v77, v87) + v89), v90) | __CFADD__(v72, v96);
  v95 = v72 + v96;
  v98 = v73 + v91;
  v73 = __CFADD__(v73, v91) | __CFADD__(v74, v98);
  v97 = v74 + v98;
  v100 = v73;
  v73 = __CFADD__(v73, v81);
  v99 = v100 + v81;
  v101 = v73;
  v102 = v99 + v78;
  v103 = 0xFFFFFFFF00000001 * v93;
  v104 = ((unint64_t)v93 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v105 = ((unint64_t)v93 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v106 = -(uint64_t)v93;
  v107 = (__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v93) >> 64;
  if (__CFADD__(((unint64_t)v93 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64, 0xFFFFFFFF * v93))
    ++v105;
  v108 = v71 + __CFADD__(v106, (_QWORD)v93) + *((_QWORD *)&v93 + 1);
  v73 = __CFADD__(__CFADD__(__CFADD__(v106, (_QWORD)v93), v94) | __CFADD__(v107, __CFADD__(v106, (_QWORD)v93) + v94), v95);
  v109 = (__CFADD__(__CFADD__(v106, (_QWORD)v93), v94) | __CFADD__(v107, __CFADD__(v106, (_QWORD)v93) + v94))+ v95;
  v73 |= __CFADD__(v105, v109);
  v109 += v105;
  v110 = v103 + v73 + v97;
  v112 = __CFADD__(v73, v97) | __CFADD__(v103, v73 + v97);
  v111 = v102 + v112 + v104;
  if (__CFADD__(v112, v104) | __CFADD__(v102, v112 + v104))
    v113 = 1;
  else
    v113 = 0;
  v114 = v108 + v107;
  v115 = v101 + __CFADD__(v99, v78) + v113;
  v116 = (v4 * (unsigned __int128)v79) >> 64;
  v117 = v4 * v79;
  v118 = (v5 * (unsigned __int128)v79) >> 64;
  v119 = v5 * v79;
  v120 = (v9 * (unsigned __int128)v79) >> 64;
  v121 = v9 * v79;
  v122 = v10 * v79;
  v123 = (v10 * (unsigned __int128)v79) >> 64;
  v124 = v123 + v121;
  v73 = __CFADD__(__CFADD__(v123, v121), v120) | __CFADD__(v119, __CFADD__(v123, v121) + v120);
  v125 = v119 + __CFADD__(v123, v121) + v120;
  v127 = v73 + v118;
  v73 = __CFADD__(v73, v118) | __CFADD__(v117, v127);
  v126 = v117 + v127;
  if (v73)
    ++v116;
  v73 = __CFADD__(v114, v122);
  v128 = v114 + v122;
  v129 = v121 + v73 + v123;
  v130 = v129 + v109;
  v132 = __CFADD__(v73, v124) | __CFADD__(v109, v73 + v124);
  v73 = __CFADD__(v132, v125);
  v131 = v132 + v125;
  v73 |= __CFADD__(v110, v131);
  v131 += v110;
  v133 = v111 + v73 + v126;
  v134 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v135 = (v128 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v136 = 0xFFFFFFFF * v128;
  v137 = (__PAIR128__(0xFFFFFFFFLL, -1) * v128) >> 64;
  v138 = v109 + __CFADD__(-(uint64_t)v128, v128) + v129;
  v73 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v128, v128), v130) | __CFADD__(v137, __CFADD__(-(uint64_t)v128, v128) + v130), v131);
  v139 = (__CFADD__(__CFADD__(-(uint64_t)v128, v128), v130) | __CFADD__(v137, __CFADD__(-(uint64_t)v128, v128) + v130))+ v131;
  v140 = v73;
  v73 = __CFADD__(v133, 0xFFFFFFFF00000001 * v128);
  v141 = v133 - 0xFFFFFFFF * v128;
  v142 = v73;
  v73 = __CFADD__(v135, v136);
  v143 = v135 + v136;
  v144 = (v128 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v145 = (v128 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v147 = v73;
  v73 = __CFADD__(v73, v139);
  v146 = v147 + v139;
  v73 |= __CFADD__(v145, v146);
  v146 += v145;
  v149 = v73;
  v73 = __CFADD__(v73, v141);
  v148 = v149 + v141;
  v73 |= __CFADD__(v140, v148);
  v148 += v140;
  v152 = v73;
  v150 = __CFADD__(v73, v144) | __CFADD__(v142, v73 + v144);
  v151 = v142 + v152 + v144;
  if (v150)
    v153 = 1;
  else
    v153 = 0;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v134);
  v154 = v150 + v116;
  v155 = __CFADD__(v150, v116);
  v73 = __CFADD__(v151, v154 + v115);
  v156 = v151 + v154 + v115;
  if (v73)
    ++v153;
  v157 = v138 + v143;
  v158 = v155 + __CFADD__(v154, v115) + v153;
  v160 = v146 - (1 - __CFADD__(v157, 1));
  v159 = (v146 - __PAIR128__(v155, (1 - __CFADD__(v157, 1)))) >> 64;
  v161 = (unint64_t)v156
       - __PAIR128__(v154 + v115, -(uint64_t)((v148- __PAIR128__(v159, (1 - (__CFADD__(v160, 0xFFFFFFFF00000001) + v159)))) >> 64));
  if (1
     - (__CFADD__((_QWORD)v161, 0xFFFFFFFFLL)
      + BYTE8(v161))
     + (v158 < (1 - (__CFADD__((_QWORD)v161, 0xFFFFFFFFLL) + BYTE8(v161)))))
  {
    v162 = 0;
  }
  else
  {
    v162 = -1;
  }
  if (1
     - (__CFADD__((_QWORD)v161, 0xFFFFFFFFLL)
      + BYTE8(v161))
     + (v158 < (1 - (__CFADD__((_QWORD)v161, 0xFFFFFFFFLL) + BYTE8(v161)))))
  {
    v163 = -1;
  }
  else
  {
    v163 = 0;
  }
  *result = v162 & (v157 + 1) | v163 & v157;
  result[1] = v162 & (v160 - 0xFFFFFFFF) | v163 & v146;
  result[2] = v162 & (v148 - (1 - (__CFADD__(v160, 0xFFFFFFFF00000001) + v159))) | v163 & v148;
  result[3] = v162 & (v161 + 0xFFFFFFFF) | v163 & v156;
  return result;
}

uint64_t *fiat_p256_square(uint64_t *result, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unsigned __int128 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  _BOOL8 v43;
  uint64_t v44;
  _BOOL8 v45;
  uint64_t v46;
  _BOOL8 v47;
  uint64_t v48;
  unsigned __int128 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _BOOL8 v60;
  uint64_t v61;
  unint64_t StatusReg;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _BOOL8 v74;
  BOOL v75;
  uint64_t v76;
  _BOOL8 v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unsigned __int128 v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  _BOOL8 v107;
  uint64_t v108;
  _BOOL8 v109;
  char v110;
  uint64_t v111;
  _BOOL8 v112;
  uint64_t v113;
  uint64_t v114;
  _BOOL8 v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  _BOOL8 v124;
  unsigned __int128 v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  unint64_t v139;
  _BOOL8 v140;
  unint64_t v141;
  uint64_t v142;
  char v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  _BOOL8 v148;
  unint64_t v149;
  uint64_t v150;
  uint64_t v151;
  unsigned __int128 v152;
  uint64_t v153;
  uint64_t v154;
  BOOL v155;
  uint64_t v156;
  uint64_t v157;
  unint64_t v158;

  v3 = a2[2];
  v2 = a2[3];
  v5 = *a2;
  v4 = a2[1];
  v6 = (*a2 * (unsigned __int128)v2) >> 64;
  v158 = *a2 * v2;
  v7 = (*a2 * (unsigned __int128)v3) >> 64;
  v8 = *a2 * v3;
  v9 = (v5 * (unsigned __int128)v4) >> 64;
  v10 = v5 * v4;
  v11 = v5 * v5;
  v12 = (v5 * (unsigned __int128)v5) >> 64;
  v13 = (__PAIR128__(v4, v5) * v5) >> 64;
  v14 = v9 + __CFADD__(v12, v5 * v4) + v5 * v3;
  v15 = v7
      + (__CFADD__(__CFADD__(v12, v5 * v4), v5 * v3) | __CFADD__(v9, __CFADD__(v12, v5 * v4) + v5 * v3))
      + v158;
  if (__CFADD__(__CFADD__(__CFADD__(v12, v5 * v4), v5 * v3) | __CFADD__(v9, __CFADD__(v12, v5 * v4) + v5 * v3), v158) | __CFADD__(v7, (__CFADD__(__CFADD__(v12, v5 * v4), v5 * v3) | __CFADD__(v9, __CFADD__(v12, v5 * v4) + v5 * v3))+ v158))v16 = v6 + 1;
  else
    v16 = v6;
  v17 = ((unint64_t)v11 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v18 = 0xFFFFFFFFLL * v11;
  v19 = ((unint64_t)v11 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v20 = -(uint64_t)(v5 * v5);
  v21 = v10 + __CFADD__(v20, v11) + v12;
  v22 = (__CFADD__(__CFADD__(v20, v11), v13) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (unint64_t)v11) >> 64, __CFADD__(v20, v11) + v13))+ v14;
  v23 = __CFADD__(__CFADD__(__CFADD__(v20, v11), v13) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (unint64_t)v11) >> 64, __CFADD__(v20, v11) + v13), v14);
  v75 = __CFADD__(v15, 0xFFFFFFFF00000001 * v11);
  v24 = v15 - 0xFFFFFFFFLL * v11;
  v25 = v75;
  v75 = __CFADD__(v17, v16);
  v26 = v17 + v16;
  v27 = v75;
  v28 = (v2 * (unsigned __int128)v4) >> 64;
  v29 = v2 * v4;
  v30 = (v3 * (unsigned __int128)v4) >> 64;
  v31 = v3 * v4;
  v32 = v4 * v4;
  v33 = __PAIR128__(v3 * v4, v9) + v4 * (unsigned __int128)v4;
  v35 = __CFADD__(__CFADD__(v9, v4 * v4), v3 * v4) | __CFADD__((v4 * (unsigned __int128)v4) >> 64, __CFADD__(v9, v4 * v4) + v3 * v4);
  v34 = v30 + v35 + v2 * v4;
  if (__CFADD__(v35, v2 * v4) | __CFADD__(v30, v35 + v2 * v4))
    v36 = v28 + 1;
  else
    v36 = (v2 * (unsigned __int128)v4) >> 64;
  v75 = __CFADD__(v19, v18);
  v37 = ((unint64_t)v11 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v38 = 0xFFFFFFFFLL * v11;
  v39 = ((unint64_t)v11 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v40 = v21 + v19 + v18;
  v75 = __CFADD__(v75, v22) | __CFADD__(v39, (__PAIR128__(v22, v37) + (unint64_t)v38) >> 64);
  v41 = v39 + ((__PAIR128__(v22, v37) + (unint64_t)v38) >> 64);
  v43 = v75;
  v75 = __CFADD__(v75, v24);
  v42 = v43 + v24;
  v75 |= __CFADD__(v23, v42);
  v42 += v23;
  v45 = v75;
  v75 = __CFADD__(v75, v26);
  v44 = v45 + v26;
  v75 |= __CFADD__(v25, v44);
  v44 += v25;
  v47 = v75;
  v75 = __CFADD__(v75, v36);
  v46 = v47 + v36;
  v75 |= __CFADD__(v27, v46);
  v46 += v27;
  v48 = v75;
  v75 = __CFADD__(v40, v10);
  v49 = __PAIR128__(v9, v40) + __PAIR128__(v32, v10);
  v50 = ((__PAIR128__(v9, v40) + __PAIR128__(v32, v10)) >> 64) + v41;
  v51 = (__CFADD__(__CFADD__(v40, v10), (_QWORD)v33) | __CFADD__(v41, __CFADD__(v40, v10) + (_QWORD)v33))+ *((_QWORD *)&v33 + 1);
  v52 = __CFADD__(__CFADD__(v75, (_QWORD)v33) | __CFADD__(v41, v75 + (_QWORD)v33), *((_QWORD *)&v33 + 1));
  v75 = __CFADD__(v44, v34);
  v53 = v44 + v34;
  v54 = v75;
  v55 = 0xFFFFFFFF * v49;
  v56 = ((unint64_t)v49 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v57 = (__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v49) >> 64;
  v75 = __CFADD__(v51, v42);
  v58 = v51 + v42;
  v60 = v75;
  v75 = __CFADD__(v75, v53);
  v59 = v60 + v53;
  v75 |= __CFADD__(v52, v59);
  v59 += v52;
  v61 = v54 + v75 + v46;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v63 = ((unint64_t)v49 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v64 = v41 + __CFADD__(-(uint64_t)v49, (_QWORD)v49) + *((_QWORD *)&v49 + 1);
  v65 = (__CFADD__(__CFADD__(-(uint64_t)v49, (_QWORD)v49), v50) | __CFADD__(v57, __CFADD__(-(uint64_t)v49, (_QWORD)v49)+ v50))+ v58;
  v66 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v49, (_QWORD)v49), v50) | __CFADD__(v57, __CFADD__(-(uint64_t)v49, (_QWORD)v49)+ v50), v58);
  v75 = __CFADD__(v59, 0xFFFFFFFF00000001 * v49);
  v67 = v59 - 0xFFFFFFFF * v49;
  v68 = v75;
  v75 = __CFADD__(v61, v63);
  v69 = v61 + v63;
  v70 = v75;
  v71 = ((unint64_t)v49 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v75 = __CFADD__(__CFADD__(v56, v55), v65) | __CFADD__(v71, __CFADD__(v56, v55) + v65);
  v72 = v71 + __CFADD__(v56, v55) + v65;
  v74 = v75;
  v75 = __CFADD__(v75, v67);
  v73 = v74 + v67;
  v75 |= __CFADD__(v66, v73);
  v73 += v66;
  v77 = v75;
  v75 = __CFADD__(v75, v69);
  v76 = v77 + v69;
  v75 |= __CFADD__(v68, v76);
  v76 += v68;
  if (v75)
    v78 = v70 + 1;
  else
    v78 = v70;
  v79 = v64 + v56 + v55;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  v80 = v48 + v75 + v78;
  v81 = (v2 * (unsigned __int128)v3) >> 64;
  v82 = v2 * v3;
  v83 = (v3 * (unsigned __int128)v3) >> 64;
  v84 = v3 * v3;
  v85 = v7 + v31;
  v75 = __CFADD__(__CFADD__(v7, v31), v84);
  v86 = __CFADD__(v7, v31) + v84;
  v75 |= __CFADD__(v30, v86);
  v86 += v30;
  v87 = v83 + v75 + v82;
  if (__CFADD__(v75, v82) | __CFADD__(v83, v75 + v82))
    v88 = v81 + 1;
  else
    v88 = v81;
  v89 = __PAIR128__(v7, v79) + __PAIR128__(v31, v8);
  v90 = ((__PAIR128__(v7, v79) + __PAIR128__(v31, v8)) >> 64) + v72;
  v92 = (__CFADD__(__CFADD__(v79, v8), v85) | __CFADD__(v72, __CFADD__(v79, v8) + v85)) + v86;
  v75 = __CFADD__(__CFADD__(__CFADD__(v79, v8), v85) | __CFADD__(v72, __CFADD__(v79, v8) + v85), v86) | __CFADD__(v73, v92);
  v91 = v73 + v92;
  v93 = v76 + v75 + v87;
  v94 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v95 = ((unint64_t)v89 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v96 = 0xFFFFFFFF * v89;
  v97 = (__PAIR128__(0xFFFFFFFFLL, -1) * (unint64_t)v89) >> 64;
  v98 = v72 + __CFADD__(-(uint64_t)v89, (_QWORD)v89) + *((_QWORD *)&v89 + 1);
  v75 = __CFADD__(__CFADD__(__CFADD__(-(uint64_t)v89, (_QWORD)v89), v90) | __CFADD__(v97, __CFADD__(-(uint64_t)v89, (_QWORD)v89)+ v90), v91);
  v99 = (__CFADD__(__CFADD__(-(uint64_t)v89, (_QWORD)v89), v90) | __CFADD__(v97, __CFADD__(-(uint64_t)v89, (_QWORD)v89)+ v90))+ v91;
  v100 = v75;
  v75 = __CFADD__(v93, 0xFFFFFFFF00000001 * v89);
  v101 = v93 - 0xFFFFFFFF * v89;
  v102 = v75;
  v75 = __CFADD__(v95, v96);
  v103 = v95 + v96;
  v104 = ((unint64_t)v89 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v105 = ((unint64_t)v89 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v107 = v75;
  v75 = __CFADD__(v75, v99);
  v106 = v107 + v99;
  v75 |= __CFADD__(v105, v106);
  v106 += v105;
  v109 = v75;
  v75 = __CFADD__(v75, v101);
  v108 = v109 + v101;
  v75 |= __CFADD__(v100, v108);
  v108 += v100;
  v112 = v75;
  v110 = __CFADD__(v75, v104) | __CFADD__(v102, v75 + v104);
  v111 = v102 + v112 + v104;
  if (v110)
    v113 = 1;
  else
    v113 = 0;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v94);
  v114 = v110 + v88;
  v115 = __CFADD__(v110, v88);
  v75 = __CFADD__(v111, v114 + v80);
  v116 = v111 + v114 + v80;
  if (v75)
    ++v113;
  v117 = v98 + v103;
  v118 = v115 + __CFADD__(v114, v80) + v113;
  v119 = (v2 * (unsigned __int128)v2) >> 64;
  v120 = v2 * v2;
  v121 = v6 + v29;
  v75 = __CFADD__(__CFADD__(v6, v29), v82) | __CFADD__(v28, __CFADD__(v6, v29) + v82);
  v122 = v28 + __CFADD__(v6, v29) + v82;
  v124 = v75;
  v75 = __CFADD__(v75, v120);
  v123 = v124 + v120;
  v75 |= __CFADD__(v81, v123);
  v123 += v81;
  if (v75)
    ++v119;
  v125 = __PAIR128__(v6, v117) + __PAIR128__(v29, v158);
  v126 = ((__PAIR128__(v6, v117) + __PAIR128__(v29, v158)) >> 64) + v106;
  v75 = __CFADD__(__CFADD__(__CFADD__(v117, v158), v121) | __CFADD__(v106, __CFADD__(v117, v158) + v121), v122) | __CFADD__(v108, (__CFADD__(__CFADD__(v117, v158), v121) | __CFADD__(v106, __CFADD__(v117, v158) + v121))+ v122);
  v127 = v108
       + (__CFADD__(__CFADD__(v117, v158), v121) | __CFADD__(v106, __CFADD__(v117, v158) + v121))
       + v122;
  v128 = v116 + v75 + v123;
  v129 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v130 = ((unint64_t)v125 * (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64;
  v131 = 0xFFFFFFFF * v125;
  v132 = v106 + __CFADD__(-(uint64_t)v125, (_QWORD)v125) + *((_QWORD *)&v125 + 1);
  v133 = (__CFADD__(__CFADD__(-(uint64_t)v125, (_QWORD)v125), v126) | __CFADD__((__PAIR128__(0xFFFFFFFFLL, -1)* (unint64_t)v125) >> 64, __CFADD__(-(uint64_t)v125, (_QWORD)v125)+ v126))+ v127;
  v75 = __CFADD__(v128, 0xFFFFFFFF00000001 * v125);
  v134 = v128 - 0xFFFFFFFF * v125;
  v135 = v75;
  v75 = __CFADD__(v130, v131);
  v136 = v130 + v131;
  v137 = ((unint64_t)v125 * (unsigned __int128)0xFFFFFFFF00000001) >> 64;
  v138 = ((unint64_t)v125 * (unsigned __int128)0xFFFFFFFFuLL) >> 64;
  v140 = v75;
  v75 = __CFADD__(v75, v133);
  v139 = v140 + v133;
  v75 |= __CFADD__(v138, v139);
  v139 += v138;
  v142 = v75 + v134;
  v141 = *((_QWORD *)&v125 + 1) + v142;
  v145 = __CFADD__(v75, v134) | __CFADD__(*((_QWORD *)&v125 + 1), v142);
  v143 = __CFADD__(v145, v137) | __CFADD__(v135, v145 + v137);
  v144 = v135 + v145 + v137;
  if (v143)
    v146 = 1;
  else
    v146 = 0;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), v129);
  v147 = v143 + v119;
  v148 = __CFADD__(v143, v119);
  v149 = v147 + v118;
  v75 = __CFADD__(v144, v147 + v118);
  v150 = v144 + v147 + v118;
  if (v75)
    ++v146;
  v151 = v132 + v136;
  v152 = v139 - __PAIR128__(v148, (1 - __CFADD__(v151, 1)));
  v153 = v150
       - -(uint64_t)((v141
                                    - __PAIR128__(v149, (1- (__CFADD__((_QWORD)v152, 0xFFFFFFFF00000001)+ BYTE8(v152))))) >> 64);
  v154 = -(v148
         + __CFADD__(v147, v118)
         + v146
         + (v148 + (unint64_t)__CFADD__(v147, v118) + v146 < (1
                                                                                    - (__CFADD__(v153, 0xFFFFFFFFLL)
                                                                                     + (((unint64_t)v150
                                                                                       - __PAIR128__(v118, -(uint64_t)((v141 - __PAIR128__(v149, (1 - (__CFADD__((_QWORD)v152, 0xFFFFFFFF00000001) + BYTE8(v152))))) >> 64))) >> 64)))));
  v155 = v154 == 0;
  if ((_BYTE)v154)
    v156 = 0;
  else
    v156 = -1;
  if (v155)
    v157 = 0;
  else
    v157 = -1;
  *result = v156 & (v151 + 1) | v157 & v151;
  result[1] = v156 & (v152 - 0xFFFFFFFF) | v157 & v139;
  result[2] = v156 & (v141 - (1 - (__CFADD__((_QWORD)v152, 0xFFFFFFFF00000001) + BYTE8(v152)))) | v157 & v141;
  result[3] = v156 & (v153 + 0xFFFFFFFFLL) | v157 & v150;
  return result;
}

int8x16_t fiat_p256_point_add(uint64_t *a1, int8x16_t *a2, int8x16_t *a3, unint64_t *a4, uint64_t a5, int8x16_t *a6, int a7, unint64_t *a8, int8x16_t *a9, int8x16_t *a10)
{
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  __int128 v27;
  unint64_t v28;
  unint64_t v29;
  unsigned __int128 v30;
  uint64_t v31;
  uint64_t v32;
  int8x16_t *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unsigned __int128 v43;
  unsigned __int128 v44;
  uint64_t v45;
  BOOL v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unsigned __int128 v57;
  BOOL v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  char v62;
  unsigned __int128 v63;
  char v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  char v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  signed __int128 v80;
  uint64_t *v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unsigned __int128 v91;
  uint64_t v92;
  __int128 v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unsigned __int128 v97;
  unint64_t v98;
  uint64_t v99;
  uint64_t v100;
  int8x16_t result;
  uint64_t v102;
  __int128 v103;
  unint64_t v104;
  unint64_t v105;
  unsigned __int128 v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  uint64_t v113;
  char v114;
  unint64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unsigned __int128 v121;
  uint64_t v122;
  uint64_t v123;
  unsigned __int128 v124;
  unint64_t v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  unsigned __int128 v134;
  char v135;
  uint64_t v136;
  unsigned __int128 v137;
  char v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  uint64_t v146;
  unint64_t v147;
  uint64_t v148;
  unsigned __int128 v149;
  uint64_t v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  uint64_t v155;
  unint64_t v156;
  _BOOL8 v157;
  char v158;
  unint64_t v159;
  unint64_t v160;
  uint64_t v161;
  uint64_t v162;
  unsigned __int128 v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  uint64_t v169;
  unint64_t v170;
  unint64_t v171;
  int8x16_t v172;
  int8x16_t v173;
  int8x16_t v174;
  int8x16_t v175;
  int8x16_t v176;
  int8x16_t v177;
  uint64_t v182;
  uint64_t v183;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  uint64_t v192[4];
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  __int128 v197;
  __int128 v198;
  _OWORD v199[2];
  unint64_t v200[2];
  unsigned __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  unsigned __int128 v205;
  _OWORD v206[2];
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  int8x16_t v211;
  int8x16_t v212;
  __int128 v213;
  unsigned __int128 v214;
  __int128 v215;
  __int128 v216;
  uint64_t v217;

  v217 = *MEMORY[0x24BDAC8D0];
  v215 = 0u;
  v216 = 0u;
  v213 = 0u;
  v214 = 0u;
  v12 = a6->i64[0];
  v13 = a6->i64[1];
  v15 = a6[1].i64[0];
  v14 = a6[1].i64[1];
  v182 = v13 | a6->i64[0] | v15 | v14;
  v16 = a10->i64[0];
  v17 = a10->i64[1];
  v19 = a10[1].i64[0];
  v18 = a10[1].i64[1];
  v183 = v17 | a10->i64[0] | v19 | v18;
  v209 = 0u;
  v210 = 0u;
  v20 = fiat_p256_square((uint64_t *)&v209, (unint64_t *)a6);
  v207 = 0u;
  v208 = 0u;
  memset(v206, 0, sizeof(v206));
  v204 = 0u;
  v205 = 0u;
  if (a7)
  {
    v22 = *a4;
    v23 = a4[1];
    *(_QWORD *)&v207 = *a4;
    *((_QWORD *)&v207 + 1) = v23;
    v25 = a4[2];
    v24 = a4[3];
    *(_QWORD *)&v208 = v25;
    *((_QWORD *)&v208 + 1) = v24;
    *((_QWORD *)&v27 + 1) = v13;
    *(_QWORD *)&v27 = v12;
    v26 = v27 >> 63;
    *((_QWORD *)&v27 + 1) = v15;
    *(_QWORD *)&v27 = v13;
    v28 = v27 >> 63;
    *((_QWORD *)&v27 + 1) = v14;
    *(_QWORD *)&v27 = v15;
    v29 = v27 >> 63;
    v30 = v29
        - __PAIR128__((unint64_t)v20, -(uint64_t)((v28- __PAIR128__(v21, (1 - __CFADD__(v26, 0xFFFFFFFF00000000)))) >> 64));
    if ((v14 < 0)
       + ((unint64_t)v14 >> 63 < (1 - (__CFADD__((_QWORD)v30, 0xFFFFFFFFLL) + BYTE8(v30)))))
    {
      v31 = 0;
    }
    else
    {
      v31 = -1;
    }
    if ((v14 < 0)
       + ((unint64_t)v14 >> 63 < (1 - (__CFADD__((_QWORD)v30, 0xFFFFFFFFLL) + BYTE8(v30)))))
    {
      v32 = -1;
    }
    else
    {
      v32 = 0;
    }
    *(_QWORD *)&v204 = v31 & ((2 * v12) | 1) | v32 & (2 * v12);
    *((_QWORD *)&v204 + 1) = v31 & (v26 - 0x100000000) | v32 & v26;
    *(_QWORD *)&v205 = v31 & (v28 - (1 - __CFADD__(v26, 0xFFFFFFFF00000000))) | v32 & v28;
    *((_QWORD *)&v205 + 1) = v31 & (v30 + 0xFFFFFFFF) | v32 & v29;
    v33 = (int8x16_t *)a5;
    v34 = *(_QWORD *)a5;
    *(_QWORD *)&v206[0] = *(_QWORD *)a5;
    *(_OWORD *)((char *)v206 + 8) = *(_OWORD *)(a5 + 8);
    *((_QWORD *)&v206[1] + 1) = *(_QWORD *)(a5 + 24);
    v35 = *((_QWORD *)&v206[0] + 1);
  }
  else
  {
    v211 = 0uLL;
    v212 = 0uLL;
    fiat_p256_square(v211.i64, (unint64_t *)a10);
    v36 = fiat_p256_mul((uint64_t *)&v207, a4, (unint64_t *)&v211);
    v38 = v16 + v12;
    v39 = v13 + __CFADD__(v16, v12) + v17;
    v40 = v15 + (__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12) + v17)) + v19;
    v41 = v14
        + (__CFADD__(__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12) + v17), v19) | __CFADD__(v15, (__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12)+ v17))+ v19))+ v18;
    if (__CFADD__(__CFADD__(__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12) + v17), v19) | __CFADD__(v15, (__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12)+ v17))+ v19), v18) | __CFADD__(v14, (__CFADD__(__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12) + v17), v19) | __CFADD__(v15, (__CFADD__(__CFADD__(v16, v12), v17) | __CFADD__(v13, __CFADD__(v16, v12) + v17))+ v19))+ v18))v42 = 1;
    else
      v42 = 0;
    v43 = (unint64_t)v39 - __PAIR128__(v37, (1 - __CFADD__(v38, 1)));
    v44 = (unint64_t)v41
        - __PAIR128__((unint64_t)v36, -(uint64_t)(((unint64_t)v40- __PAIR128__(0xFFFFFFFF00000001, (1- (__CFADD__((_QWORD)v43, 0xFFFFFFFF00000001)+ BYTE8(v43))))) >> 64));
    v45 = -(uint64_t)(v42 + (v42 < (1 - (__CFADD__((_QWORD)v44, 0xFFFFFFFFLL) + BYTE8(v44)))));
    v46 = v45 == 0;
    if ((_BYTE)v45)
      v47 = 0;
    else
      v47 = -1;
    if (v46)
      v48 = 0;
    else
      v48 = -1;
    *(_QWORD *)&v204 = v47 & (v38 + 1) | v48 & v38;
    *((_QWORD *)&v204 + 1) = v47 & (v43 - 0xFFFFFFFF) | v48 & v39;
    *(_QWORD *)&v205 = v47 & (v40 - (1 - (__CFADD__((_QWORD)v43, 0xFFFFFFFF00000001) + BYTE8(v43)))) | v48 & v40;
    *((_QWORD *)&v205 + 1) = v47 & (v44 + 0xFFFFFFFF) | v48 & v41;
    fiat_p256_square((uint64_t *)&v204, (unint64_t *)&v204);
    v49 = v204 - v209;
    v50 = *((_QWORD *)&v209 + 1) + -(uint64_t)(((unint64_t)v204 - __PAIR128__(v209, v209)) >> 64);
    v51 = *((_QWORD *)&v204 + 1) - v50;
    v58 = __CFADD__((_QWORD)v210, -(uint64_t)((*((unint64_t *)&v204 + 1) - __PAIR128__(v50, v50)) >> 64));
    v52 = v210 + -(uint64_t)((*((unint64_t *)&v204 + 1) - __PAIR128__(v50, v50)) >> 64);
    v53 = v58;
    v54 = v205 - v52;
    v58 = __CFADD__(*((_QWORD *)&v210 + 1), -(uint64_t)(((unint64_t)v205 - __PAIR128__(v53, v52)) >> 64));
    v55 = *((_QWORD *)&v210 + 1) + -(uint64_t)(((unint64_t)v205 - __PAIR128__(v53, v52)) >> 64);
    v56 = v58;
    v57 = *((unint64_t *)&v205 + 1) - __PAIR128__(v56, v55);
    v58 = __CFADD__(__CFADD__(v49, *((_QWORD *)&v57 + 1)), v51) | __CFADD__(DWORD2(v57), __CFADD__(v49, *((_QWORD *)&v57 + 1)) + v51);
    v59 = DWORD2(v57) + __CFADD__(v49, *((_QWORD *)&v57 + 1)) + v51;
    v60 = v57 + __CFADD__(v58, v54) + (*((_QWORD *)&v57 + 1) & 0xFFFFFFFF00000001);
    v62 = ((unint64_t)(v49 + *((_QWORD *)&v57 + 1)) - __PAIR128__(v211.u64[0], v211.u64[0])) >> 64;
    v61 = v49 + *((_QWORD *)&v57 + 1) - v211.i64[0];
    v63 = (unint64_t)v59
        - __PAIR128__(v211.i64[1] + (unint64_t)-v62, v211.i64[1] + (unint64_t)-v62);
    v64 = ((unint64_t)v58
         + v54
         - __PAIR128__(v212.i64[0] + (unint64_t)-BYTE8(v63), v212.i64[0] + (unint64_t)-BYTE8(v63))) >> 64;
    if (((v60
                          - __PAIR128__(v212.i64[1] + (unint64_t)-v64, v212.i64[1] + (unint64_t)-v64)) >> 64))v65 = -1;
    else
      v65 = 0;
    v66 = __CFADD__(v61, v65) + (_QWORD)v63;
    *(_QWORD *)&v204 = v61 + v65;
    *((_QWORD *)&v204 + 1) = v65 + v66;
    v205 = __PAIR128__(v65 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v61, v65), (_QWORD)v63) | __CFADD__(v65, v66))+ __PAIR128__(v60- (v212.i64[1]+ -(uint64_t)(((unint64_t)v58+ v54- __PAIR128__(v212.i64[0] + (unint64_t)-BYTE8(v63), v212.i64[0] + (unint64_t)-BYTE8(v63))) >> 64)), v58 + v54 - (v212.i64[0] + (unint64_t)-BYTE8(v63)));
    fiat_p256_mul((uint64_t *)v206, (unint64_t *)a10, (unint64_t *)&v211);
    v33 = (int8x16_t *)a5;
    fiat_p256_mul((uint64_t *)v206, (unint64_t *)v206, (unint64_t *)a5);
    v23 = *((_QWORD *)&v207 + 1);
    v22 = v207;
    v24 = *((_QWORD *)&v208 + 1);
    v25 = v208;
    v35 = *((_QWORD *)&v206[0] + 1);
    v34 = *(_QWORD *)&v206[0];
  }
  v211 = 0u;
  v212 = 0u;
  v202 = 0u;
  v203 = 0u;
  fiat_p256_mul((uint64_t *)&v202, a8, (unint64_t *)&v209);
  v68 = v202 - v22;
  v69 = *((_QWORD *)&v202 + 1)
      - (v23
       + -(uint64_t)(((unint64_t)v202 - __PAIR128__(v67, v22)) >> 64));
  v58 = __CFADD__(v25, -(uint64_t)((*((unint64_t *)&v202 + 1)- __PAIR128__(v23+ -(uint64_t)(((unint64_t)v202 - __PAIR128__(v67, v22)) >> 64), v23+ -(uint64_t)(((unint64_t)v202 - __PAIR128__(v67, v22)) >> 64))) >> 64));
  v70 = v25
      + -(uint64_t)((*((unint64_t *)&v202 + 1)
                                   - __PAIR128__(v23+ -(uint64_t)(((unint64_t)v202 - __PAIR128__(v67, v22)) >> 64), v23+ -(uint64_t)(((unint64_t)v202 - __PAIR128__(v67, v22)) >> 64))) >> 64);
  v71 = v58;
  v73 = v203 - v70;
  v72 = ((unint64_t)v203 - __PAIR128__(v71, v70)) >> 64;
  v58 = __CFADD__(v24, -v72);
  v74 = v24 + -v72;
  v75 = v58;
  v76 = *((_QWORD *)&v203 + 1) - v74;
  if (((*((unint64_t *)&v203 + 1) - __PAIR128__(v75, v74)) >> 64))
    v77 = -1;
  else
    v77 = 0;
  v78 = v68 + v77;
  v79 = v77 + __CFADD__(v68, v77) + v69;
  v200[0] = v68 + v77;
  v200[1] = v79;
  v80 = __PAIR128__(v77 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v68, v77), v69) | __CFADD__(v77, __CFADD__(v68, v77) + v69))+ __PAIR128__(v76, v73);
  v201 = __PAIR128__(v77 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v68, v77), v69) | __CFADD__(v77, __CFADD__(v68, v77) + v69))+ __PAIR128__(v76, v73);
  fiat_p256_mul(v211.i64, v200, (unint64_t *)&v204);
  memset(v199, 0, sizeof(v199));
  fiat_p256_mul((uint64_t *)v199, (unint64_t *)a6, (unint64_t *)&v209);
  v197 = 0u;
  v198 = 0u;
  v81 = fiat_p256_mul((uint64_t *)&v197, (unint64_t *)a9, (unint64_t *)v199);
  v84 = v197 - v34;
  v85 = *((_QWORD *)&v197 + 1)
      - (v35
       + -(uint64_t)(((unint64_t)v197 - __PAIR128__(v83, v34)) >> 64));
  v58 = __CFADD__(*(_QWORD *)&v206[1], -(uint64_t)((*((unint64_t *)&v197 + 1)- __PAIR128__(v35+ (unint64_t)-(uint64_t)(((unint64_t)v197- __PAIR128__(v83, v34)) >> 64), v35+ (unint64_t)-(uint64_t)(((unint64_t)v197- __PAIR128__(v83, v34)) >> 64))) >> 64));
  v86 = *(_QWORD *)&v206[1]
      + -(uint64_t)((*((unint64_t *)&v197 + 1)
                                   - __PAIR128__(v35+ (unint64_t)-(uint64_t)(((unint64_t)v197- __PAIR128__(v83, v34)) >> 64), v35+ (unint64_t)-(uint64_t)(((unint64_t)v197- __PAIR128__(v83, v34)) >> 64))) >> 64);
  v87 = v58;
  v88 = v198 - v86;
  v58 = __CFADD__(*((_QWORD *)&v206[1] + 1), -(uint64_t)(((unint64_t)v198 - __PAIR128__(v87, v86)) >> 64));
  v89 = *((_QWORD *)&v206[1] + 1) + -(uint64_t)(((unint64_t)v198 - __PAIR128__(v87, v86)) >> 64);
  v90 = v58;
  v91 = *((unint64_t *)&v198 + 1) - __PAIR128__(v90, v89);
  *((_QWORD *)&v93 + 1) = DWORD2(v91) + __CFADD__(v84, *((_QWORD *)&v91 + 1)) + v85;
  *(_QWORD *)&v93 = v84 + *((_QWORD *)&v91 + 1);
  v92 = v93 >> 63;
  *((_QWORD *)&v93 + 1) = (__CFADD__(__CFADD__(v84, *((_QWORD *)&v91 + 1)), v85) | __CFADD__(DWORD2(v91), __CFADD__(v84, *((_QWORD *)&v91 + 1)) + v85))
                        + v88;
  *(_QWORD *)&v93 = DWORD2(v91) + __CFADD__(v84, *((_QWORD *)&v91 + 1)) + v85;
  v94 = v93 >> 63;
  *((_QWORD *)&v93 + 1) = v91
                        + __CFADD__(__CFADD__(__CFADD__(v84, *((_QWORD *)&v91 + 1)), v85) | __CFADD__(DWORD2(v91), __CFADD__(v84, *((_QWORD *)&v91 + 1)) + v85), v88)+ (*((_QWORD *)&v91 + 1) & 0xFFFFFFFF00000001);
  *(_QWORD *)&v93 = (__CFADD__(__CFADD__(v84, *((_QWORD *)&v91 + 1)), v85) | __CFADD__(DWORD2(v91), __CFADD__(v84, *((_QWORD *)&v91 + 1))+ v85))+ v88;
  v95 = v93 >> 63;
  v96 = v94 - (1 - __CFADD__(v92, 0xFFFFFFFF00000000));
  v97 = v95
      - __PAIR128__(v82, -(uint64_t)((v94- __PAIR128__((unint64_t)v81, (1 - __CFADD__(v92, 0xFFFFFFFF00000000)))) >> 64));
  v98 = v97 + 0xFFFFFFFF;
  if ((v93 < 0)
     + (*((_QWORD *)&v93 + 1) >> 63 < (unint64_t)(1
                                                                        - (__CFADD__((_QWORD)v97, 0xFFFFFFFFLL)
                                                                         + BYTE8(v97)))))
  {
    v99 = 0;
  }
  else
  {
    v99 = -1;
  }
  v193 = ((2 * (v84 + *((_QWORD *)&v91 + 1))) | 1) & v99 | (2 * (v84 + *((_QWORD *)&v91 + 1))) & *((_QWORD *)&v97 + 1);
  v194 = v99 & (v92 - 0x100000000) | *((_QWORD *)&v97 + 1) & v92;
  v195 = v99 & v96 | *((_QWORD *)&v97 + 1) & v94;
  v196 = v99 & v98 | *((_QWORD *)&v97 + 1) & v95;
  v100 = (uint64_t)(((v79 | v78 | v80 | *((_QWORD *)&v80 + 1) | v193 | v194 | v195 | v196) - 1) & ~(v79 | v78 | v80 | *((_QWORD *)&v80 + 1) | v193 | v194 | v195 | v196)) >> 63;
  if (((v183 - 1) & ~v183 | (v182 - 1) & ~v182) < 0)
    v100 = 0;
  if (v100)
  {
    fiat_p256_point_double(a1, a2->i64, a3->i64, a4, (unint64_t *)v33, (unint64_t *)a6);
  }
  else
  {
    *((_QWORD *)&v103 + 1) = v79;
    *(_QWORD *)&v103 = v78;
    v102 = v103 >> 63;
    *((_QWORD *)&v103 + 1) = v80;
    *(_QWORD *)&v103 = v79;
    v104 = v103 >> 63;
    v105 = v80 >> 63;
    v106 = v105
         - __PAIR128__(v98, -(uint64_t)((v104- __PAIR128__(v96, (1 - __CFADD__(v102, 0xFFFFFFFF00000000)))) >> 64));
    if (1
       - (__CFADD__((_QWORD)v106, 0xFFFFFFFFLL)
        + BYTE8(v106))
       + (*((_QWORD *)&v80 + 1) >> 63 < (unint64_t)(1
                                                                          - (__CFADD__((_QWORD)v106, 0xFFFFFFFFLL)
                                                                           + BYTE8(v106)))))
    {
      v107 = 0;
    }
    else
    {
      v107 = -1;
    }
    if (1
       - (__CFADD__((_QWORD)v106, 0xFFFFFFFFLL)
        + BYTE8(v106))
       + (*((_QWORD *)&v80 + 1) >> 63 < (unint64_t)(1
                                                                          - (__CFADD__((_QWORD)v106, 0xFFFFFFFFLL)
                                                                           + BYTE8(v106)))))
    {
      v108 = -1;
    }
    else
    {
      v108 = 0;
    }
    v192[0] = v107 & ((2 * v78) | 1) | v108 & (2 * v78);
    v192[1] = v107 & (v102 - 0x100000000) | v108 & v102;
    v192[2] = v107 & (v104 - (1 - __CFADD__(v102, 0xFFFFFFFF00000000))) | v108 & v104;
    v192[3] = v107 & (v106 + 0xFFFFFFFF) | v108 & v105;
    fiat_p256_square(v192, (unint64_t *)v192);
    v190 = 0u;
    v191 = 0u;
    fiat_p256_mul((uint64_t *)&v190, v200, (unint64_t *)v192);
    v188 = 0u;
    v189 = 0u;
    fiat_p256_mul((uint64_t *)&v188, (unint64_t *)&v207, (unint64_t *)v192);
    fiat_p256_square((uint64_t *)&v215, (unint64_t *)&v193);
    v109 = v215 - v190;
    v110 = *((_QWORD *)&v190 + 1)
         + -(uint64_t)(((unint64_t)v215 - __PAIR128__(v190, v190)) >> 64);
    v111 = *((_QWORD *)&v215 + 1) - v110;
    v58 = __CFADD__((_QWORD)v191, -(uint64_t)((*((unint64_t *)&v215 + 1) - __PAIR128__(v110, v110)) >> 64));
    v112 = v191 + -(uint64_t)((*((unint64_t *)&v215 + 1) - __PAIR128__(v110, v110)) >> 64);
    v113 = v58;
    v115 = v216 - v112;
    v114 = ((unint64_t)v216 - __PAIR128__(v113, v112)) >> 64;
    v58 = __CFADD__(*((_QWORD *)&v191 + 1), -v114);
    v116 = *((_QWORD *)&v191 + 1) + -v114;
    v117 = v58;
    if (((*((unint64_t *)&v216 + 1) - __PAIR128__(v117, v116)) >> 64))
      v118 = -1;
    else
      v118 = 0;
    v119 = v118 + __CFADD__(v109, v118) + v111;
    v120 = v109 + v118 - v188;
    v121 = v119
         - __PAIR128__(v119, *((_QWORD *)&v188 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v109 + v118) - __PAIR128__(v115, v188)) >> 64));
    v123 = ((__CFADD__(__CFADD__(v109, v118), v111) | __CFADD__(v118, __CFADD__(v109, v118) + v111))+ v115- __PAIR128__((unint64_t)v189 + -BYTE8(v121), (unint64_t)v189 + -BYTE8(v121))) >> 64;
    v122 = (__CFADD__(__CFADD__(v109, v118), v111) | __CFADD__(v118, __CFADD__(v109, v118) + v111))+ v115- (v189+ -BYTE8(v121));
    v124 = ((__PAIR128__(v118 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v109, v118), v111) | __CFADD__(v118, __CFADD__(v109, v118) + v111))+ __PAIR128__(*((_QWORD *)&v216 + 1) - v116, v115)) >> 64)- __PAIR128__(*((_QWORD *)&v189 + 1) + (unint64_t)-(char)v123, *((_QWORD *)&v189 + 1) + (unint64_t)-(char)v123);
    v125 = DWORD2(v124) + __CFADD__(v120, *((_QWORD *)&v124 + 1)) + (_QWORD)v121;
    v126 = v124
         + __CFADD__(__CFADD__(__CFADD__(v120, *((_QWORD *)&v124 + 1)), (_QWORD)v121) | __CFADD__(DWORD2(v124), __CFADD__(v120, *((_QWORD *)&v124 + 1))+ (_QWORD)v121), v122)+ (*((_QWORD *)&v124 + 1) & 0xFFFFFFFF00000001);
    v127 = v120 + *((_QWORD *)&v124 + 1) - v188;
    v128 = v125
         - (*((_QWORD *)&v188 + 1)
          + -(uint64_t)(((unint64_t)(v120 + *((_QWORD *)&v124 + 1))
                                       - __PAIR128__(*((_QWORD *)&v124 + 1) & 0xFFFFFFFF00000001, v188)) >> 64));
    LOBYTE(v125) = (v125
                  - __PAIR128__(v125, *((_QWORD *)&v188 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v120 + *((_QWORD *)&v124 + 1))- __PAIR128__(*((_QWORD *)&v124 + 1) & 0xFFFFFFFF00000001, v188)) >> 64))) >> 64;
    v129 = (__CFADD__(__CFADD__(v120, *((_QWORD *)&v124 + 1)), (_QWORD)v121) | __CFADD__(DWORD2(v124), __CFADD__(v120, *((_QWORD *)&v124 + 1))+ (_QWORD)v121))+ v122- (v189+ -(char)v125);
    LOBYTE(v125) = ((unint64_t)(__CFADD__(__CFADD__(v120, *((_QWORD *)&v124 + 1)), (_QWORD)v121) | __CFADD__(DWORD2(v124), __CFADD__(v120, *((_QWORD *)&v124 + 1)) + (_QWORD)v121))
                  + v122
                  - __PAIR128__((unint64_t)v189 + -(char)v125, (unint64_t)v189 + -(char)v125)) >> 64;
    v130 = v126 - (*((_QWORD *)&v189 + 1) + -(char)v125);
    if (((v126
                          - __PAIR128__(*((_QWORD *)&v189 + 1) + (unint64_t)-(char)v125, *((_QWORD *)&v189 + 1) + (unint64_t)-(char)v125)) >> 64))v131 = -1;
    else
      v131 = 0;
    v132 = v127 + v131;
    v133 = v131 + __CFADD__(v127, v131) + v128;
    v134 = __PAIR128__(v131 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v127, v131), v128) | __CFADD__(v131, __CFADD__(v127, v131) + v128))+ __PAIR128__(v130, v129);
    v136 = v188 - (v127 + v131);
    v135 = ((unint64_t)v188 - __PAIR128__(v130, v127 + v131)) >> 64;
    v137 = *((unint64_t *)&v188 + 1)
         - __PAIR128__(v133 + (unint64_t)-v135, v133 + (unint64_t)-v135);
    v138 = ((unint64_t)v189
          - __PAIR128__((unint64_t)v134 + -BYTE8(v137), (unint64_t)v134 + -BYTE8(v137))) >> 64;
    if (((*((unint64_t *)&v189 + 1)
                          - __PAIR128__(*((_QWORD *)&v134 + 1) + (unint64_t)-v138, *((_QWORD *)&v134 + 1) + (unint64_t)-v138)) >> 64))v139 = -1;
    else
      v139 = 0;
    v140 = __CFADD__(v136, v139) + (_QWORD)v137;
    *(_QWORD *)&v213 = v136 + v139;
    *((_QWORD *)&v213 + 1) = v139 + v140;
    v214 = __PAIR128__(v139 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v136, v139), (_QWORD)v137) | __CFADD__(v139, v140))+ __PAIR128__(*((_QWORD *)&v189 + 1)- (*((_QWORD *)&v134 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)v189- __PAIR128__((unint64_t)v134 + -BYTE8(v137), (unint64_t)v134 + -BYTE8(v137))) >> 64)), v189 - (v134 + -BYTE8(v137)));
    fiat_p256_mul((uint64_t *)&v213, (unint64_t *)&v213, (unint64_t *)&v193);
    v186 = 0u;
    v187 = 0u;
    fiat_p256_mul((uint64_t *)&v186, (unint64_t *)v206, (unint64_t *)&v190);
    v142 = v213 - v186;
    v143 = *((_QWORD *)&v213 + 1)
         - (*((_QWORD *)&v186 + 1)
          + -(uint64_t)(((unint64_t)v213 - __PAIR128__(v141, v186)) >> 64));
    v58 = __CFADD__((_QWORD)v187, -(uint64_t)((*((unint64_t *)&v213 + 1)- __PAIR128__(*((_QWORD *)&v186 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)v213- __PAIR128__(v141, v186)) >> 64), *((_QWORD *)&v186 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)v213- __PAIR128__(v141, v186)) >> 64))) >> 64));
    v144 = v187
         + -(uint64_t)((*((unint64_t *)&v213 + 1)
                                      - __PAIR128__(*((_QWORD *)&v186 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)v213- __PAIR128__(v141, v186)) >> 64), *((_QWORD *)&v186 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)v213- __PAIR128__(v141, v186)) >> 64))) >> 64);
    v145 = v58;
    v146 = v214 - v144;
    v58 = __CFADD__(*((_QWORD *)&v187 + 1), -(uint64_t)(((unint64_t)v214 - __PAIR128__(v145, v144)) >> 64));
    v147 = *((_QWORD *)&v187 + 1)
         + -(uint64_t)(((unint64_t)v214 - __PAIR128__(v145, v144)) >> 64);
    v148 = v58;
    v149 = *((unint64_t *)&v214 + 1) - __PAIR128__(v148, v147);
    v150 = __CFADD__(v142, *((_QWORD *)&v149 + 1)) + v143;
    v152 = __CFADD__(__CFADD__(v142, *((_QWORD *)&v149 + 1)), v143) | __CFADD__(DWORD2(v149), v150);
    v151 = v152 + v146;
    v153 = v149 + __CFADD__(v152, v146) + (*((_QWORD *)&v149 + 1) & 0xFFFFFFFF00000001);
    v154 = v142 + *((_QWORD *)&v149 + 1) - v186;
    v155 = DWORD2(v149)
         + v150
         - (*((_QWORD *)&v186 + 1)
          + -(uint64_t)(((unint64_t)(v142 + *((_QWORD *)&v149 + 1)) - __PAIR128__(v186, v186)) >> 64));
    v156 = v187
         + -(uint64_t)(((unint64_t)DWORD2(v149)
                                      + v150
                                      - __PAIR128__(*((_QWORD *)&v186 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v142 + *((_QWORD *)&v149 + 1))- __PAIR128__(v186, v186)) >> 64), *((_QWORD *)&v186 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v142 + *((_QWORD *)&v149 + 1))- __PAIR128__(v186, v186)) >> 64))) >> 64);
    v157 = __CFADD__((_QWORD)v187, -(uint64_t)(((unint64_t)DWORD2(v149)+ v150- __PAIR128__(*((_QWORD *)&v186 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v142 + *((_QWORD *)&v149 + 1))- __PAIR128__(v186, v186)) >> 64), *((_QWORD *)&v186 + 1)+ (unint64_t)-(uint64_t)(((unint64_t)(v142 + *((_QWORD *)&v149 + 1))- __PAIR128__(v186, v186)) >> 64))) >> 64));
    v159 = v151 - v156;
    v158 = (v151 - __PAIR128__(v157, v156)) >> 64;
    v58 = __CFADD__(*((_QWORD *)&v187 + 1), -v158);
    v160 = *((_QWORD *)&v187 + 1) + -v158;
    v161 = v58;
    if (((v153 - __PAIR128__(v161, v160)) >> 64))
      v162 = -1;
    else
      v162 = 0;
    v163 = __PAIR128__(v162 & 0xFFFFFFFF00000001, __CFADD__(__CFADD__(v154, v162), v155) | __CFADD__(v162, __CFADD__(v154, v162) + v155))+ __PAIR128__(v153 - v160, v159);
    if (v182)
      v164 = 0;
    else
      v164 = -1;
    if (v182)
      v165 = -1;
    else
      v165 = 0;
    if (v183)
      v166 = 0;
    else
      v166 = -1;
    if (v183)
      v167 = -1;
    else
      v167 = 0;
    v168 = a4[1] & v166 | v167 & (a8[1] & v164 | v165 & v133);
    v169 = a4[2] & v166 | v167 & (a8[2] & v164 | v165 & v134);
    v170 = a4[3] & v166 | v167 & (a8[3] & v164 | v165 & *((_QWORD *)&v134 + 1));
    *a1 = v166 & *a4 | v167 & (v164 & *a8 | v165 & v132);
    a1[1] = v168;
    a1[2] = v169;
    a1[3] = v170;
    v171 = v33->i64[1] & v166 | (a9->i64[1] & v164 | v165 & (v162 + __CFADD__(v154, v162) + v155)) & v167;
    v172 = (int8x16_t)vdupq_n_s64(v165);
    v173 = (int8x16_t)vdupq_n_s64(v164);
    v174 = (int8x16_t)vdupq_n_s64(v167);
    v175 = (int8x16_t)vdupq_n_s64(v166);
    v176 = vorrq_s8(vandq_s8(v33[1], v175), vandq_s8(vorrq_s8(vandq_s8(a9[1], v173), vandq_s8(v172, (int8x16_t)v163)), v174));
    a2->i64[0] = v33->i64[0] & v166 | (a9->i64[0] & v164 | v165 & (v154 + v162)) & v167;
    a2->i64[1] = v171;
    a2[1] = v176;
    result = vorrq_s8(vandq_s8(*a6, v175), vandq_s8(vorrq_s8(vandq_s8(v211, v172), vandq_s8(*a10, v173)), v174));
    v177 = vorrq_s8(vandq_s8(a6[1], v175), vandq_s8(vorrq_s8(vandq_s8(v212, v172), vandq_s8(a10[1], v173)), v174));
    *a3 = result;
    a3[1] = v177;
  }
  return result;
}

uint64_t *fiat_p256_point_double(uint64_t *a1, uint64_t *a2, uint64_t *a3, unint64_t *a4, unint64_t *a5, unint64_t *a6)
{
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  __int128 v14;
  unint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unsigned __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  _BOOL8 v34;
  uint64_t v35;
  unint64_t v36;
  _BOOL8 v37;
  unint64_t v38;
  _BOOL8 v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unsigned __int128 v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  __int128 v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unsigned __int8 v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _BOOL8 v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _BOOL8 v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _BOOL8 v79;
  unint64_t v80;
  uint64_t v81;
  unsigned __int128 v82;
  unsigned __int128 v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unsigned __int8 v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  __int128 v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  __int128 v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unsigned __int8 v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  uint64_t v135;
  uint64_t v136;
  unsigned __int128 v137;
  __int128 v138;
  __int128 v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  unint64_t v143;
  unsigned __int128 v144;
  uint64_t v145;
  unint64_t v146;
  unint64_t v147;
  uint64_t v148;
  BOOL v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  _BOOL8 v158;
  unint64_t v159;
  unint64_t v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  uint64_t v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  unint64_t v168;
  uint64_t v169;
  unint64_t v170;
  unsigned __int128 v171;
  unsigned __int128 v172;
  uint64_t v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  unsigned __int128 v184;
  unint64_t v185;
  uint64_t v186;
  unint64_t v187;
  unint64_t v188;
  unint64_t v189;
  uint64_t v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  uint64_t v195;
  char v196;
  unint64_t v197;
  unint64_t v198;
  uint64_t v199;
  unsigned __int128 v200;
  unint64_t v201;
  uint64_t v202;
  uint64_t v203;
  unint64_t v204;
  __int128 v205;
  unint64_t v206;
  unint64_t v207;
  unsigned __int8 v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t *result;
  uint64_t v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  unsigned __int8 v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  int v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  int v230;
  uint64_t v231;
  uint64_t v232;
  unsigned __int128 v233;
  uint64_t v234;
  uint64_t v235;
  _BYTE v236[24];
  _OWORD v240[2];
  unint64_t v241[4];
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  _OWORD v246[2];
  _OWORD v247[2];
  __int128 v248;
  __int128 v249;
  uint64_t v250;

  v250 = *MEMORY[0x24BDAC8D0];
  v248 = 0u;
  v249 = 0u;
  memset(v247, 0, sizeof(v247));
  memset(v246, 0, sizeof(v246));
  memset(v240, 0, sizeof(v240));
  fiat_p256_square((uint64_t *)&v248, a6);
  fiat_p256_square((uint64_t *)v247, a5);
  fiat_p256_mul((uint64_t *)v246, a4, (unint64_t *)v247);
  v12 = *a4;
  v13 = a4[1];
  v14 = v248;
  v16 = *a4 - v248;
  v17 = __CFADD__(*((_QWORD *)&v248 + 1), -(uint64_t)((*a4 - __PAIR128__(v15, v248)) >> 64));
  v18 = *((_QWORD *)&v248 + 1) + -(uint64_t)((*a4 - __PAIR128__(v15, v248)) >> 64);
  v19 = v17;
  v20 = v13 - v18;
  v21 = v249;
  v17 = __CFADD__((_QWORD)v249, -(uint64_t)((v13 - __PAIR128__(v19, v18)) >> 64));
  v22 = v249 + -(uint64_t)((v13 - __PAIR128__(v19, v18)) >> 64);
  v23 = v17;
  v24 = a4[2];
  v25 = a4[3];
  v26 = v24 - v22;
  v17 = __CFADD__(*((_QWORD *)&v249 + 1), -(uint64_t)((v24 - __PAIR128__(v23, v22)) >> 64));
  v27 = *((_QWORD *)&v249 + 1) + -(uint64_t)((v24 - __PAIR128__(v23, v22)) >> 64);
  v28 = v17;
  v29 = v25 - __PAIR128__(v28, v27);
  v30 = __CFADD__(v16, *((_QWORD *)&v29 + 1)) + v20;
  v31 = __CFADD__(__CFADD__(v16, *((_QWORD *)&v29 + 1)), v20) | __CFADD__(DWORD2(v29), v30);
  v242 = v16 + *((_QWORD *)&v29 + 1);
  v243 = DWORD2(v29) + v30;
  v244 = v31 + v26;
  v245 = v29 + __CFADD__(v31, v26) + (*((_QWORD *)&v29 + 1) & 0xFFFFFFFF00000001);
  v17 = __CFADD__((_QWORD)v248, v12);
  v32 = v248 + v12;
  v34 = v17;
  v17 = __CFADD__(v17, v13);
  v33 = v34 + v13;
  v35 = v17;
  v36 = v249 + v24;
  v37 = __CFADD__((_QWORD)v249, v24);
  v38 = *((_QWORD *)&v249 + 1) + v25;
  v39 = __CFADD__(*((_QWORD *)&v249 + 1), v25);
  v41 = v33 + *((_QWORD *)&v248 + 1);
  v17 = __CFADD__(__CFADD__(v33, *((_QWORD *)&v248 + 1)), v36) | __CFADD__(v35, (__PAIR128__(v36, v33)+ *((unint64_t *)&v248 + 1)) >> 64);
  v40 = v35 + ((__PAIR128__(v36, v33) + *((unint64_t *)&v248 + 1)) >> 64);
  v43 = v17 + v38;
  v17 = __CFADD__(v17, v38) | __CFADD__(v37, v43);
  v42 = v37 + v43;
  if (v17)
    v44 = v39 + 1;
  else
    v44 = v39;
  v45 = v41 - __PAIR128__(v25, (1 - __CFADD__(v32, 1)));
  v46 = v42
      - -(uint64_t)((v40
                                   - __PAIR128__(0xFFFFFFFF00000001, (1 - (__CFADD__((_QWORD)v45, 0xFFFFFFFF00000001) + BYTE8(v45))))) >> 64);
  v47 = -(uint64_t)(v44
                 + (v44 < (1
                                          - (__CFADD__(v46, 0xFFFFFFFFLL)
                                           + ((v42
                                             - __PAIR128__(DWORD2(v29), -(uint64_t)((v40- __PAIR128__(0xFFFFFFFF00000001, (1- (__CFADD__((_QWORD)v45, 0xFFFFFFFF00000001)+ BYTE8(v45))))) >> 64))) >> 64)))));
  if ((_BYTE)v47)
    v48 = 0;
  else
    v48 = -1;
  if ((_BYTE)v47)
    v49 = -1;
  else
    v49 = 0;
  v50 = v48 & (v32 + 1) | v49 & v32;
  v51 = v48 & (v45 - 0xFFFFFFFF) | v49 & v41;
  v52 = v48 & (v40 - (1 - (__CFADD__((_QWORD)v45, 0xFFFFFFFF00000001) + BYTE8(v45)))) | v49 & v40;
  v53 = v48 & (v46 + 0xFFFFFFFF) | v49 & v42;
  *((_QWORD *)&v55 + 1) = v51;
  *(_QWORD *)&v55 = v50;
  v54 = v55 >> 63;
  *((_QWORD *)&v55 + 1) = v52;
  *(_QWORD *)&v55 = v51;
  v56 = v55 >> 63;
  *((_QWORD *)&v55 + 1) = v53;
  *(_QWORD *)&v55 = v52;
  v57 = v55 >> 63;
  v58 = v56 - (1 - __CFADD__(v54, 0xFFFFFFFF00000000));
  v59 = v57
      - -(uint64_t)((v56 - __PAIR128__(v10, (1 - __CFADD__(v54, 0xFFFFFFFF00000000)))) >> 64);
  v60 = 1
      - (__CFADD__(v59, 0xFFFFFFFFLL)
       + ((v57
         - __PAIR128__(v11, -(uint64_t)((v56- __PAIR128__(v10, (1 - __CFADD__(v54, 0xFFFFFFFF00000000)))) >> 64))) >> 64));
  if ((v53 < 0) + ((unint64_t)v53 >> 63 < v60))
    v61 = 0;
  else
    v61 = -1;
  if ((v53 < 0) + ((unint64_t)v53 >> 63 < v60))
    v62 = -1;
  else
    v62 = 0;
  v63 = ((2 * v50) | 1) & v61 | (2 * v50) & v62;
  v64 = v61 & (v54 - 0x100000000) | v62 & v54;
  v65 = v61 & v58;
  v66 = v61 & v58 | v62 & v56;
  v67 = v62 & v57;
  v68 = v61 & (v59 + 0xFFFFFFFF) | v67;
  v17 = __CFADD__(v63, v50);
  v69 = v63 + v50;
  v71 = v17;
  v17 = __CFADD__(v17, v51);
  v70 = v71 + v51;
  v72 = v17;
  v17 = __CFADD__(v70, v64);
  v73 = v70 + v64;
  v75 = v17;
  v17 = __CFADD__(v17, v52);
  v74 = v75 + v52;
  v17 |= __CFADD__(v72, v74);
  v74 += v72;
  v76 = v17;
  v17 = __CFADD__(v74, v66);
  v77 = v74 + v66;
  v79 = v17;
  v17 = __CFADD__(v17, v53);
  v78 = v79 + v53;
  v17 |= __CFADD__(v76, v78);
  v78 += v76;
  v80 = v17;
  v17 = __CFADD__(v78, v68);
  v81 = v78 + v68;
  if (v17)
    ++v80;
  v82 = (unint64_t)v73 - __PAIR128__(v68, (1 - __CFADD__(v69, 1)));
  v83 = (unint64_t)v81
      - __PAIR128__(v65, -(uint64_t)(((unint64_t)v77- __PAIR128__(v67, (1- (__CFADD__((_QWORD)v82, 0xFFFFFFFF00000001)+ BYTE8(v82))))) >> 64));
  if ((_BYTE)v80 + (v80 < (1 - (__CFADD__((_QWORD)v83, 0xFFFFFFFFLL) + BYTE8(v83)))))
    v84 = 0;
  else
    v84 = -1;
  v241[0] = v84 & (v69 + 1) | v69 & *((_QWORD *)&v83 + 1);
  v241[1] = v84 & (v82 - 0xFFFFFFFF) | *((_QWORD *)&v83 + 1) & v73;
  v241[2] = v84 & (v77 - (1 - (__CFADD__((_QWORD)v82, 0xFFFFFFFF00000001) + BYTE8(v82)))) | *((_QWORD *)&v83 + 1) & v77;
  v241[3] = v84 & (v83 + 0xFFFFFFFF) | *((_QWORD *)&v83 + 1) & v81;
  fiat_p256_mul((uint64_t *)v240, (unint64_t *)&v242, v241);
  fiat_p256_square(a1, (unint64_t *)v240);
  v85 = v246[0] >> 63;
  v86 = *(_OWORD *)((char *)v246 + 8) >> 63;
  v87 = v246[1] >> 63;
  v91 = v87
      - -(uint64_t)((v86 - __PAIR128__(v88, (1 - __CFADD__(v85, 0xFFFFFFFF00000000)))) >> 64);
  v90 = (v87
       - __PAIR128__(v89, -(uint64_t)((v86- __PAIR128__(v88, (1 - __CFADD__(v85, 0xFFFFFFFF00000000)))) >> 64))) >> 64;
  v92 = v91 + 0xFFFFFFFF;
  v93 = 1 - (__CFADD__(v91, 0xFFFFFFFFLL) + v90);
  if ((v246[1] < 0) + (*((_QWORD *)&v246[1] + 1) >> 63 < (unint64_t)v93))
    v94 = 0;
  else
    v94 = -1;
  if ((v246[1] < 0) + (*((_QWORD *)&v246[1] + 1) >> 63 < (unint64_t)v93))
    v95 = -1;
  else
    v95 = 0;
  v96 = v94 & (v85 - 0x100000000) | v95 & v85;
  v97 = v94 & (v86 - (1 - __CFADD__(v85, 0xFFFFFFFF00000000))) | v95 & v86;
  v98 = v94 & v92 | v95 & v87;
  v99 = 2 * (v94 & ((2 * *(_QWORD *)&v246[0]) | 1) | v95 & (2 * *(_QWORD *)&v246[0]));
  *((_QWORD *)&v101 + 1) = v96;
  *(_QWORD *)&v101 = v94 & ((2 * *(_QWORD *)&v246[0]) | 1) | v95 & (2 * *(_QWORD *)&v246[0]);
  v100 = v101 >> 63;
  *((_QWORD *)&v101 + 1) = v97;
  *(_QWORD *)&v101 = v96;
  v102 = v101 >> 63;
  *((_QWORD *)&v101 + 1) = v98;
  *(_QWORD *)&v101 = v97;
  v103 = v101 >> 63;
  v105 = v103
       - -(uint64_t)((v102
                                    - __PAIR128__(v92, (1 - __CFADD__(v100, 0xFFFFFFFF00000000)))) >> 64);
  v104 = (v103
        - __PAIR128__(v95, -(uint64_t)((v102- __PAIR128__(v92, (1 - __CFADD__(v100, 0xFFFFFFFF00000000)))) >> 64))) >> 64;
  v106 = v105 + 0xFFFFFFFF;
  if ((v98 < 0) + ((unint64_t)v98 >> 63 < (1 - (__CFADD__(v105, 0xFFFFFFFFLL) + v104))))
    v107 = 0;
  else
    v107 = -1;
  if ((v98 < 0) + ((unint64_t)v98 >> 63 < (1 - (__CFADD__(v105, 0xFFFFFFFFLL) + v104))))
    v108 = -1;
  else
    v108 = 0;
  v109 = (v99 | 1) & v107 | v99 & v108;
  *(_QWORD *)&v236[8] = v107 & (v102 - (1 - __CFADD__(v100, 0xFFFFFFFF00000000))) | v108 & v102;
  *(_QWORD *)&v236[16] = v107 & v106 | v108 & v103;
  *(_QWORD *)v236 = v107 & (v100 - 0x100000000) | v108 & v100;
  *((_QWORD *)&v111 + 1) = *(_QWORD *)v236;
  *(_QWORD *)&v111 = v109;
  v110 = v111 >> 63;
  v112 = *(__int128 *)v236 >> 63;
  v113 = *(__int128 *)&v236[8] >> 63;
  v114 = v112 - (1 - __CFADD__(v110, 0xFFFFFFFF00000000));
  v116 = v113
       - -(uint64_t)((v112
                                    - __PAIR128__(v106, (1 - __CFADD__(v110, 0xFFFFFFFF00000000)))) >> 64);
  v115 = (v113
        - __PAIR128__(v108, -(uint64_t)((v112- __PAIR128__(v106, (1 - __CFADD__(v110, 0xFFFFFFFF00000000)))) >> 64))) >> 64;
  v117 = v116 + 0xFFFFFFFF;
  v118 = 1 - (__CFADD__(v116, 0xFFFFFFFFLL) + v115);
  if ((*(uint64_t *)&v236[16] < 0) + (*(_QWORD *)&v236[16] >> 63 < (unint64_t)v118))
    v119 = 0;
  else
    v119 = -1;
  if ((*(uint64_t *)&v236[16] < 0) + (*(_QWORD *)&v236[16] >> 63 < (unint64_t)v118))
    v120 = -1;
  else
    v120 = 0;
  v121 = ((2 * v109) | 1) & v119 | (2 * v109) & v120;
  v122 = v119 & (v110 - 0x100000000) | v120 & v110;
  v123 = v119 & v114 | v120 & v112;
  v124 = v119 & v117 | v120 & v113;
  v126 = ((unint64_t)*a1 - __PAIR128__(*a1, v121)) >> 64;
  v125 = *a1 - v121;
  LODWORD(v126) = -(int)v126;
  v17 = __CFADD__(v122, v126);
  v127 = v122 + v126;
  v128 = v17;
  v129 = a1[1] - v127;
  v130 = -(int)(((unint64_t)a1[1] - __PAIR128__(v128, v127)) >> 64);
  v17 = __CFADD__(v123, v130);
  v131 = v123 + v130;
  v132 = v17;
  v133 = a1[2] - v131;
  v134 = -(int)(((unint64_t)a1[2] - __PAIR128__(v132, v131)) >> 64);
  v17 = __CFADD__(v124, v134);
  v135 = v124 + v134;
  v136 = v17;
  v137 = (unint64_t)a1[3] - __PAIR128__(v136, v135);
  *a1 = v125 + *((_QWORD *)&v137 + 1);
  a1[1] = DWORD2(v137) + __CFADD__(v125, *((_QWORD *)&v137 + 1)) + v129;
  a1[2] = (__CFADD__(__CFADD__(v125, *((_QWORD *)&v137 + 1)), v129) | __CFADD__(DWORD2(v137), __CFADD__(v125, *((_QWORD *)&v137 + 1))+ v129))+ v133;
  a1[3] = v137
        + __CFADD__(__CFADD__(__CFADD__(v125, *((_QWORD *)&v137 + 1)), v129) | __CFADD__(DWORD2(v137), __CFADD__(v125, *((_QWORD *)&v137 + 1))+ v129), v133)+ (*((_QWORD *)&v137 + 1) & 0xFFFFFFFF00000001);
  v138 = v247[0];
  v139 = v247[0] + v14;
  v140 = *((_QWORD *)&v247[1] + 1);
  v235 = *(_QWORD *)&v247[1];
  v141 = v21
       + (__CFADD__(__CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14), *((_QWORD *)&v247[0] + 1)) | __CFADD__(*((_QWORD *)&v14 + 1), __CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14) + *((_QWORD *)&v247[0] + 1)))
       + *(_QWORD *)&v247[1];
  v142 = *((_QWORD *)&v21 + 1)
       + (__CFADD__(__CFADD__(__CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14), *((_QWORD *)&v247[0] + 1)) | __CFADD__(*((_QWORD *)&v14 + 1), __CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14) + *((_QWORD *)&v247[0] + 1)), v235) | __CFADD__((_QWORD)v21, (__CFADD__(__CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14), *((_QWORD *)&v247[0] + 1)) | __CFADD__(*((_QWORD *)&v14 + 1), __CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14)+ *((_QWORD *)&v247[0] + 1)))+ v235))+ *((_QWORD *)&v247[1] + 1);
  if (__CFADD__(__CFADD__(__CFADD__(__CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14), *((_QWORD *)&v247[0] + 1)) | __CFADD__(*((_QWORD *)&v14 + 1), __CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14) + *((_QWORD *)&v247[0] + 1)), v235) | __CFADD__((_QWORD)v21, (__CFADD__(__CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14), *((_QWORD *)&v247[0] + 1)) | __CFADD__(*((_QWORD *)&v14 + 1), __CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14) + *((_QWORD *)&v247[0] + 1)))+ v235), v140) | __CFADD__(*((_QWORD *)&v21 + 1), (__CFADD__(__CFADD__(__CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14), *((_QWORD *)&v247[0] + 1)) | __CFADD__(*((_QWORD *)&v14 + 1), __CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14) + *((_QWORD *)&v247[0] + 1)), v235) | __CFADD__((_QWORD)v21, (__CFADD__(__CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14), *((_QWORD *)&v247[0] + 1)) | __CFADD__(*((_QWORD *)&v14 + 1), __CFADD__(*(_QWORD *)&v247[0], (_QWORD)v14) + *((_QWORD *)&v247[0] + 1)))+ v235))+ v140))
    v143 = 1;
  else
    v143 = 0;
  v144 = *((unint64_t *)&v139 + 1) - __PAIR128__(v114, (1 - __CFADD__((_QWORD)v139, 1)));
  v146 = v142
       - -(uint64_t)((v141
                                    - __PAIR128__(v117, (1- (__CFADD__((_QWORD)v144, 0xFFFFFFFF00000001)+ BYTE8(v144))))) >> 64);
  v145 = (v142
        - __PAIR128__(v120, -(uint64_t)((v141- __PAIR128__(v117, (1- (__CFADD__((_QWORD)v144, 0xFFFFFFFF00000001)+ BYTE8(v144))))) >> 64))) >> 64;
  v147 = v146 + 0xFFFFFFFF;
  v148 = -(uint64_t)(v143 + (v143 < (1 - (__CFADD__(v146, 0xFFFFFFFFLL) + v145))));
  v149 = v148 == 0;
  if ((_BYTE)v148)
    v150 = 0;
  else
    v150 = -1;
  if (v149)
    v151 = 0;
  else
    v151 = -1;
  v152 = v150 & (v139 + 1) | v151 & v139;
  v153 = v150 & (v144 - 0xFFFFFFFF) | v151 & *((_QWORD *)&v139 + 1);
  v154 = v150 & (v141 - (1 - (__CFADD__((_QWORD)v144, 0xFFFFFFFF00000001) + BYTE8(v144)))) | v151 & v141;
  v234 = v150 & v147 | v151 & v142;
  v155 = a6[1];
  v157 = (*a6 + *(_OWORD *)a5) >> 64;
  v156 = *a6 + *a5;
  v158 = __CFADD__(__CFADD__(*a6, *a5), a5[1]);
  v159 = a5[2];
  v160 = a5[3];
  v161 = a6[2];
  v162 = a6[3];
  v17 = __CFADD__(v161, v159);
  v163 = v161 + v159;
  v164 = v17;
  v17 = __CFADD__(v162, v160);
  v165 = v162 + v160;
  v166 = v17;
  v168 = v157 + v155;
  v17 = __CFADD__(__CFADD__(v157, v155), v163) | __CFADD__(v158, (__PAIR128__(v163, v157) + v155) >> 64);
  v167 = v158 + ((__PAIR128__(v163, v157) + v155) >> 64);
  v169 = v164 + v17 + v165;
  if (__CFADD__(v17, v165) | __CFADD__(v164, v17 + v165))
    v170 = v166 + 1;
  else
    v170 = v166;
  v171 = v168 - __PAIR128__(v166, (1 - __CFADD__(v156, 1)));
  v172 = (unint64_t)v169
       - __PAIR128__(v151, -(uint64_t)((v167- __PAIR128__(v147, (1- (__CFADD__((_QWORD)v171, 0xFFFFFFFF00000001)+ BYTE8(v171))))) >> 64));
  if ((_BYTE)v170 + (v170 < (1 - (__CFADD__((_QWORD)v172, 0xFFFFFFFFLL) + BYTE8(v172)))))
    v173 = 0;
  else
    v173 = -1;
  v242 = v173 & (v156 + 1) | *((_QWORD *)&v172 + 1) & v156;
  v243 = v173 & (v171 - 0xFFFFFFFF) | *((_QWORD *)&v172 + 1) & v168;
  v244 = v173 & (v167 - (1 - (__CFADD__((_QWORD)v171, 0xFFFFFFFF00000001) + BYTE8(v171)))) | *((_QWORD *)&v172 + 1) & v167;
  v245 = v173 & (v172 + 0xFFFFFFFF) | *((_QWORD *)&v172 + 1) & v169;
  fiat_p256_square(a3, (unint64_t *)&v242);
  v177 = *a3 - v152;
  v178 = a3[1] - (v153 + -(uint64_t)(((unint64_t)*a3 - __PAIR128__(v176, v152)) >> 64));
  v17 = __CFADD__(v154, -(uint64_t)(((unint64_t)a3[1]- __PAIR128__(v153+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v176, v152)) >> 64), v153+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v176, v152)) >> 64))) >> 64));
  v179 = v154
       + -(uint64_t)(((unint64_t)a3[1]
                                    - __PAIR128__(v153+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v176, v152)) >> 64), v153+ (unint64_t)-(uint64_t)(((unint64_t)*a3- __PAIR128__(v176, v152)) >> 64))) >> 64);
  v180 = v17;
  v181 = a3[2] - v179;
  v17 = __CFADD__(v234, -(uint64_t)(((unint64_t)a3[2] - __PAIR128__(v180, v179)) >> 64));
  v182 = v234 + -(uint64_t)(((unint64_t)a3[2] - __PAIR128__(v180, v179)) >> 64);
  v183 = v17;
  v184 = (unint64_t)a3[3] - __PAIR128__(v183, v182);
  v185 = __CFADD__(v177, *((_QWORD *)&v184 + 1)) + v178;
  v186 = __CFADD__(__CFADD__(v177, *((_QWORD *)&v184 + 1)), v178) | __CFADD__(DWORD2(v184), v185);
  *a3 = v177 + *((_QWORD *)&v184 + 1);
  a3[1] = DWORD2(v184) + v185;
  a3[2] = v186 + v181;
  a3[3] = v184 + __CFADD__(v186, v181) + (*((_QWORD *)&v184 + 1) & 0xFFFFFFFF00000001);
  v187 = a1[1];
  v188 = v109 - *a1;
  v17 = __CFADD__(v187, -(uint64_t)(((unint64_t)v109 - __PAIR128__(v186 + v181, *a1)) >> 64));
  v189 = v187 + -(uint64_t)(((unint64_t)v109 - __PAIR128__(v186 + v181, *a1)) >> 64);
  v190 = v17;
  v191 = *(_QWORD *)v236 - v189;
  v192 = a1[2];
  v193 = a1[3];
  v17 = __CFADD__(v192, -(uint64_t)((*(unint64_t *)v236 - __PAIR128__(v190, v189)) >> 64));
  v194 = v192 + -(uint64_t)((*(unint64_t *)v236 - __PAIR128__(v190, v189)) >> 64);
  v195 = v17;
  v197 = *(_QWORD *)&v236[8] - v194;
  v196 = (*(unint64_t *)&v236[8] - __PAIR128__(v195, v194)) >> 64;
  v17 = __CFADD__(v193, -v196);
  v198 = v193 + -v196;
  v199 = v17;
  v200 = *(unint64_t *)&v236[16] - __PAIR128__(v199, v198);
  v201 = __CFADD__(v188, *((_QWORD *)&v200 + 1)) + v191;
  v202 = __CFADD__(__CFADD__(v188, *((_QWORD *)&v200 + 1)), v191) | __CFADD__(DWORD2(v200), v201);
  *a2 = v188 + *((_QWORD *)&v200 + 1);
  a2[1] = DWORD2(v200) + v201;
  a2[2] = v202 + v197;
  a2[3] = v200 + __CFADD__(v202, v197) + (*((_QWORD *)&v200 + 1) & 0xFFFFFFFF00000001);
  v203 = v138 >> 63;
  *((_QWORD *)&v205 + 1) = v235;
  *(_QWORD *)&v205 = *((_QWORD *)&v138 + 1);
  v204 = v205 >> 63;
  *((_QWORD *)&v205 + 1) = v140;
  *(_QWORD *)&v205 = v235;
  v206 = v205 >> 63;
  v207 = v206
       - -(uint64_t)((v204
                                    - __PAIR128__(v174, (1 - __CFADD__(v203, 0xFFFFFFFF00000000)))) >> 64);
  v208 = 1
       - (__CFADD__(v207, 0xFFFFFFFFLL)
        + ((v206
          - __PAIR128__(v175, -(uint64_t)((v204- __PAIR128__(v174, (1 - __CFADD__(v203, 0xFFFFFFFF00000000)))) >> 64))) >> 64));
  if ((v140 < 0) + ((unint64_t)v140 >> 63 < v208))
    v209 = 0;
  else
    v209 = -1;
  if ((v140 < 0) + ((unint64_t)v140 >> 63 < v208))
    v210 = -1;
  else
    v210 = 0;
  *(_QWORD *)&v247[0] = v209 & ((2 * v138) | 1) | v210 & (2 * v138);
  *((_QWORD *)&v247[0] + 1) = v209 & (v203 - 0x100000000) | v210 & v203;
  *(_QWORD *)&v247[1] = v209 & (v204 - (1 - __CFADD__(v203, 0xFFFFFFFF00000000))) | v210 & v204;
  *((_QWORD *)&v247[1] + 1) = v209 & (v207 + 0xFFFFFFFF) | v210 & v206;
  fiat_p256_square((uint64_t *)v247, (unint64_t *)v247);
  result = fiat_p256_mul(a2, (unint64_t *)v240, (unint64_t *)a2);
  v212 = v247[0] >> 63;
  v213 = *(_OWORD *)((char *)v247 + 8) >> 63;
  v214 = v247[1] >> 63;
  v217 = v214
       - -(uint64_t)((v213
                                    - __PAIR128__(v215, (1 - __CFADD__(v212, 0xFFFFFFFF00000000)))) >> 64);
  v218 = 1
       - (__CFADD__(v217, 0xFFFFFFFFLL)
        + ((v214
          - __PAIR128__(v216, -(uint64_t)((v213- __PAIR128__(v215, (1 - __CFADD__(v212, 0xFFFFFFFF00000000)))) >> 64))) >> 64));
  if ((v247[1] < 0) + (*((_QWORD *)&v247[1] + 1) >> 63 < (unint64_t)v218))
    v219 = 0;
  else
    v219 = -1;
  if ((v247[1] < 0) + (*((_QWORD *)&v247[1] + 1) >> 63 < (unint64_t)v218))
    v220 = -1;
  else
    v220 = 0;
  v221 = v219 & (v212 - 0x100000000) | v220 & v212;
  v222 = v219 & (v213 - (1 - __CFADD__(v212, 0xFFFFFFFF00000000))) | v220 & v213;
  v223 = v219 & (v217 + 0xFFFFFFFF) | v220 & v214;
  v224 = *a2 - (v219 & ((2 * *(_QWORD *)&v247[0]) | 1) | v220 & (2 * *(_QWORD *)&v247[0]));
  v225 = a2[1]
       - (v221
        + -(uint64_t)(((unint64_t)*a2
                                     - __PAIR128__(v219 & ((2 * *(_QWORD *)&v247[0]) | 1) | v220 & (unint64_t)(2 * *(_QWORD *)&v247[0]), v219 & ((2 * *(_QWORD *)&v247[0]) | 1) | v220 & (unint64_t)(2 * *(_QWORD *)&v247[0]))) >> 64));
  v226 = -(int)(((unint64_t)a2[1]
               - __PAIR128__(a2[1], v221+ (unint64_t)-(uint64_t)(((unint64_t)*a2- __PAIR128__(v219 & ((2 * *(_QWORD *)&v247[0]) | 1) | v220 & (unint64_t)(2 * *(_QWORD *)&v247[0]), v219 & ((2 * *(_QWORD *)&v247[0]) | 1) | v220 & (unint64_t)(2 * *(_QWORD *)&v247[0]))) >> 64))) >> 64);
  v17 = __CFADD__(v222, v226);
  v227 = v222 + v226;
  v228 = v17;
  v229 = a2[2] - v227;
  v230 = -(int)(((unint64_t)a2[2] - __PAIR128__(v228, v227)) >> 64);
  v17 = __CFADD__(v223, v230);
  v231 = v223 + v230;
  v232 = v17;
  v233 = (unint64_t)a2[3] - __PAIR128__(v232, v231);
  *a2 = v224 + *((_QWORD *)&v233 + 1);
  a2[1] = DWORD2(v233) + __CFADD__(v224, *((_QWORD *)&v233 + 1)) + v225;
  a2[2] = (__CFADD__(__CFADD__(v224, *((_QWORD *)&v233 + 1)), v225) | __CFADD__(DWORD2(v233), __CFADD__(v224, *((_QWORD *)&v233 + 1))+ v225))+ v229;
  a2[3] = v233
        + __CFADD__(__CFADD__(__CFADD__(v224, *((_QWORD *)&v233 + 1)), v225) | __CFADD__(DWORD2(v233), __CFADD__(v224, *((_QWORD *)&v233 + 1))+ v225), v229)+ (*((_QWORD *)&v233 + 1) & 0xFFFFFFFF00000001);
  return result;
}

uint64_t fiat_p256_select_point_affine(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t i;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v3 = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  v4 = a2 + 24;
  for (i = 1; i != 16; ++i)
  {
    if (result == i)
      v6 = -1;
    else
      v6 = 0;
    if (result == i)
      v7 = 0;
    else
      v7 = -1;
    v3 = v6 & *(_QWORD *)(v4 - 24) | v7 & v3;
    v8 = *(_QWORD *)(a3 + 24) & v7 | *(_QWORD *)v4 & v6;
    v9 = (int8x16_t)vdupq_n_s64(v7);
    v10 = (int8x16_t)vdupq_n_s64(v6);
    v11 = vorrq_s8(vandq_s8(*(int8x16_t *)(a3 + 8), v9), vandq_s8(*(int8x16_t *)(v4 - 16), v10));
    *(_QWORD *)a3 = v3;
    *(int8x16_t *)(a3 + 8) = v11;
    *(_QWORD *)(a3 + 24) = v8;
    v12 = vorrq_s8(vandq_s8(*(int8x16_t *)(a3 + 32), v9), vandq_s8(*(int8x16_t *)(v4 + 8), v10));
    v13 = vorrq_s8(vandq_s8(*(int8x16_t *)(a3 + 48), v9), vandq_s8(*(int8x16_t *)(v4 + 24), v10));
    *(int8x16_t *)(a3 + 32) = v12;
    *(int8x16_t *)(a3 + 48) = v13;
    v4 += 64;
  }
  if (result)
    v14 = 0;
  else
    v14 = -1;
  if (result)
    v15 = -1;
  else
    v15 = 0;
  v16 = *(_QWORD *)(a3 + 72) & v14 | v15 & 0xFFFFFFFF00000000;
  v17 = *(_QWORD *)(a3 + 88);
  v18 = *(_QWORD *)(a3 + 80) & v14 | v15;
  *(_QWORD *)(a3 + 64) = v14 & *(_QWORD *)(a3 + 64) | v15 & 1;
  *(_QWORD *)(a3 + 72) = v16;
  *(_QWORD *)(a3 + 80) = v18;
  *(_QWORD *)(a3 + 88) = v17 & v14 | v15 & 0xFFFFFFFE;
  return result;
}

uint64_t PKCS5_pbe2_encrypt_init(uint64_t *a1, EVP_CIPHER_CTX *a2, const EVP_CIPHER *a3, unsigned int a4, void *a5, int a6, const void *a7, size_t a8)
{
  int nid;
  uint64_t result;
  _QWORD *v18;
  _QWORD *v19;
  EVP_MD *v20;
  _OWORD v21[3];
  _OWORD v22[3];
  _OWORD v23[3];
  _OWORD v24[3];
  _OWORD v25[3];
  _OWORD v26[3];
  _OWORD v27[3];
  _OWORD v28[3];
  _OWORD v29[3];
  _BYTE *v30;
  unsigned __int8 iv[16];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  nid = a3->nid;
  if (a3->nid)
  {
    RAND_bytes_with_additional_data((uint64_t)iv, a3->iv_len, (uint64_t)&RAND_bytes_kZeroAdditionalData);
    memset(v29, 0, sizeof(v29));
    memset(v28, 0, sizeof(v28));
    memset(v27, 0, sizeof(v27));
    memset(v26, 0, sizeof(v26));
    memset(v25, 0, sizeof(v25));
    memset(v24, 0, sizeof(v24));
    memset(v23, 0, sizeof(v23));
    memset(v22, 0, sizeof(v22));
    memset(v21, 0, sizeof(v21));
    result = CBB_flush(a1);
    if ((_DWORD)result)
    {
      v30 = 0;
      result = CBB_add_space((uint64_t)a1, &v30, 1);
      if ((_DWORD)result)
      {
        *v30 = 48;
        result = cbb_add_child((uint64_t)a1, (uint64_t)v29, 1u, 1);
        if ((_DWORD)result)
        {
          result = CBB_flush((uint64_t *)v29);
          if ((_DWORD)result)
          {
            v30 = 0;
            result = CBB_add_space((uint64_t)v29, &v30, 1);
            if ((_DWORD)result)
            {
              *v30 = 6;
              result = cbb_add_child((uint64_t)v29, (uint64_t)v28, 1u, 1);
              if ((_DWORD)result)
              {
                v30 = 0;
                result = CBB_add_space((uint64_t)v28, &v30, 9);
                if ((_DWORD)result)
                {
                  v18 = v30;
                  v30[8] = 13;
                  *v18 = 0x5010DF78648862ALL;
                  result = CBB_flush((uint64_t *)v29);
                  if ((_DWORD)result)
                  {
                    v30 = 0;
                    result = CBB_add_space((uint64_t)v29, &v30, 1);
                    if ((_DWORD)result)
                    {
                      *v30 = 48;
                      result = cbb_add_child((uint64_t)v29, (uint64_t)v27, 1u, 1);
                      if ((_DWORD)result)
                      {
                        result = CBB_flush((uint64_t *)v27);
                        if ((_DWORD)result)
                        {
                          v30 = 0;
                          result = CBB_add_space((uint64_t)v27, &v30, 1);
                          if ((_DWORD)result)
                          {
                            *v30 = 48;
                            result = cbb_add_child((uint64_t)v27, (uint64_t)v26, 1u, 1);
                            if ((_DWORD)result)
                            {
                              result = CBB_flush((uint64_t *)v26);
                              if ((_DWORD)result)
                              {
                                v30 = 0;
                                result = CBB_add_space((uint64_t)v26, &v30, 1);
                                if ((_DWORD)result)
                                {
                                  *v30 = 6;
                                  result = cbb_add_child((uint64_t)v26, (uint64_t)v25, 1u, 1);
                                  if ((_DWORD)result)
                                  {
                                    v30 = 0;
                                    result = CBB_add_space((uint64_t)v25, &v30, 9);
                                    if ((_DWORD)result)
                                    {
                                      v19 = v30;
                                      v30[8] = 12;
                                      *v19 = 0x5010DF78648862ALL;
                                      result = CBB_add_asn1((uint64_t *)v26, (uint64_t)v24, 536870928);
                                      if ((_DWORD)result)
                                      {
                                        result = CBB_add_asn1((uint64_t *)v24, (uint64_t)v23, 4);
                                        if ((_DWORD)result)
                                        {
                                          result = CBB_add_bytes((uint64_t)v23, a7, a8);
                                          if ((_DWORD)result)
                                          {
                                            result = CBB_add_asn1_uint64_with_tag((uint64_t)v24, a4, 2);
                                            if ((_DWORD)result)
                                            {
                                              if (nid != 37
                                                || (result = CBB_add_asn1_uint64_with_tag((uint64_t)v24, a3->key_len, 2), (_DWORD)result))
                                              {
                                                result = CBB_add_asn1((uint64_t *)v27, (uint64_t)v22, 536870928);
                                                if ((_DWORD)result)
                                                {
                                                  result = add_cipher_oid((uint64_t *)v22, nid);
                                                  if ((_DWORD)result)
                                                  {
                                                    result = CBB_add_asn1((uint64_t *)v22, (uint64_t)v21, 4);
                                                    if ((_DWORD)result)
                                                    {
                                                      result = CBB_add_bytes((uint64_t)v21, iv, a3->iv_len);
                                                      if ((_DWORD)result)
                                                      {
                                                        result = CBB_flush(a1);
                                                        if ((_DWORD)result)
                                                        {
                                                          v20 = (EVP_MD *)EVP_sha1();
                                                          return pkcs5_pbe2_cipher_init(a2, a3, v20, a4, a5, a6, (uint64_t)a7, a8, iv, a3->iv_len, 1);
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    ERR_put_error(19, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/p5_pbev2.c", 170);
    return 0;
  }
  return result;
}

uint64_t add_cipher_oid(uint64_t *a1, int a2)
{
  unsigned int v3;
  uint64_t result;
  size_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  _BYTE *v9;

  if (a2 <= 418)
  {
    if (a2 == 37)
    {
      v3 = 0;
      v7 = 0u;
      v8 = 0u;
      v6 = 0u;
      result = CBB_flush(a1);
      if (!(_DWORD)result)
        return result;
      goto LABEL_16;
    }
    if (a2 == 44)
    {
      v3 = 1;
      v7 = 0u;
      v8 = 0u;
      v6 = 0u;
      result = CBB_flush(a1);
      if (!(_DWORD)result)
        return result;
      goto LABEL_16;
    }
LABEL_20:
    ERR_put_error(19, 0, 127, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/p5_pbev2.c", 142);
    return 0;
  }
  if (a2 == 419)
  {
    v3 = 2;
    v7 = 0u;
    v8 = 0u;
    v6 = 0u;
    result = CBB_flush(a1);
    if (!(_DWORD)result)
      return result;
    goto LABEL_16;
  }
  if (a2 == 423)
  {
    v3 = 3;
    v7 = 0u;
    v8 = 0u;
    v6 = 0u;
    result = CBB_flush(a1);
    if (!(_DWORD)result)
      return result;
    goto LABEL_16;
  }
  if (a2 != 427)
    goto LABEL_20;
  v3 = 4;
  v7 = 0u;
  v8 = 0u;
  v6 = 0u;
  result = CBB_flush(a1);
  if (!(_DWORD)result)
    return result;
LABEL_16:
  v9 = 0;
  result = CBB_add_space((uint64_t)a1, &v9, 1);
  if ((_DWORD)result)
  {
    *v9 = 6;
    result = cbb_add_child((uint64_t)a1, (uint64_t)&v6, 1u, 1);
    if ((_DWORD)result)
    {
      v5 = kCipherOIDs[24 * v3 + 9];
      v9 = 0;
      result = CBB_add_space((uint64_t)&v6, &v9, v5);
      if ((_DWORD)result)
      {
        memcpy(v9, &kCipherOIDs[24 * v3], v5);
        return CBB_flush(a1) != 0;
      }
    }
  }
  return result;
}

BOOL pkcs5_pbe2_cipher_init(EVP_CIPHER_CTX *a1, const EVP_CIPHER *a2, EVP_MD *md, unsigned int a4, void *key, int len, uint64_t a7, uint64_t a8, unsigned __int8 *iv, uint64_t a10, int enc)
{
  _BOOL8 result;
  int8x16_t keya[4];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  if (a2->iv_len == a10)
  {
    result = PKCS5_PBKDF2_HMAC(key, len, a7, a8, a4, md, a2->key_len, keya);
    if ((_DWORD)result)
      return EVP_CipherInit_ex(a1, a2, 0, (const unsigned __int8 *)keya, iv, enc) != 0;
  }
  else
  {
    ERR_put_error(19, 0, 107, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/p5_pbev2.c", 152);
    return 0;
  }
  return result;
}

BOOL PKCS5_pbe2_decrypt_init(uint64_t a1, EVP_CIPHER_CTX *a2, void *a3, int a4, uint64_t a5)
{
  int v9;
  int v10;
  unint64_t v12;
  unsigned __int8 *v13;
  uint64_t v14;
  uint64_t *v15;
  const EVP_CIPHER *v16;
  const EVP_CIPHER *v17;
  unsigned int v18;
  const EVP_MD *v19;
  int v20;
  BOOL v21;
  int v22;
  const EVP_MD *v24;
  EVP_MD *v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *iv;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unsigned __int8 *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unsigned __int8 *v44;
  unint64_t v45;
  unsigned __int8 *v46;
  unint64_t v47;

  v46 = 0;
  v47 = 0;
  v44 = 0;
  v45 = 0;
  v42 = 0;
  v43 = 0;
  v40 = 0;
  v41 = 0;
  v38 = 0;
  v39 = 0;
  v36 = 0;
  LODWORD(v34) = 0;
  if (!cbs_get_any_asn1_element((unsigned __int8 **)a5, &v46, &v34, &v36, 0, 0, 0))
    goto LABEL_5;
  if ((_DWORD)v34 != 536870928)
    goto LABEL_5;
  if (v47 < v36)
    goto LABEL_5;
  v46 += v36;
  v47 -= v36;
  if (*(_QWORD *)(a5 + 8))
    goto LABEL_5;
  v36 = 0;
  LODWORD(v34) = 0;
  if (!cbs_get_any_asn1_element(&v46, &v44, &v34, &v36, 0, 0, 0))
    goto LABEL_5;
  if ((_DWORD)v34 != 536870928)
    goto LABEL_5;
  if (v45 < v36)
    goto LABEL_5;
  v44 += v36;
  v45 -= v36;
  v36 = 0;
  LODWORD(v34) = 0;
  if (!cbs_get_any_asn1_element(&v46, &v40, &v34, &v36, 0, 0, 0))
    goto LABEL_5;
  if ((_DWORD)v34 != 536870928)
    goto LABEL_5;
  if (v41 < v36)
    goto LABEL_5;
  v40 += v36;
  v41 -= v36;
  if (v47)
    goto LABEL_5;
  v36 = 0;
  LODWORD(v34) = 0;
  if (!cbs_get_any_asn1_element(&v44, &v42, &v34, &v36, 0, 0, 0)
    || (_DWORD)v34 != 6
    || (v12 = v43 - v36, v43 < v36)
    || (v13 = (unsigned __int8 *)(v42 + v36),
        v42 += v36,
        v43 -= v36,
        v36 = 0,
        LODWORD(v34) = 0,
        !cbs_get_any_asn1_element(&v40, &v38, &v34, &v36, 0, 0, 0))
    || (_DWORD)v34 != 6
    || (v14 = v39 - v36, v39 < v36))
  {
LABEL_5:
    v9 = 104;
    v10 = 223;
LABEL_6:
    ERR_put_error(19, 0, v9, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/p5_pbev2.c", v10);
    return 0;
  }
  v15 = (uint64_t *)(v38 + v36);
  v38 += v36;
  v39 -= v36;
  if (v12 != 9 || *(_QWORD *)v13 != 0x5010DF78648862ALL || v13[8] != 12)
  {
    v9 = 128;
    v10 = 229;
    goto LABEL_6;
  }
  v16 = cbs_to_cipher(v15, v14);
  if (!v16)
  {
    v9 = 127;
    v10 = 236;
    goto LABEL_6;
  }
  v17 = v16;
  v36 = 0;
  v37 = 0;
  v34 = 0;
  v35 = 0;
  v33 = 0;
  if (!CBS_get_asn1(&v44, &v36, 536870928)
    || v45
    || !CBS_get_asn1((unsigned __int8 **)&v36, &v34, 4)
    || !CBS_get_asn1_uint64((unsigned __int8 **)&v36, &v33))
  {
    v9 = 104;
    v10 = 247;
    goto LABEL_6;
  }
  v18 = v33;
  if (v33 - 100000001 < 0xFFFFFFFFFA0A1F00)
  {
    v9 = 129;
    v10 = 252;
    goto LABEL_6;
  }
  if (CBS_peek_asn1_tag((unsigned __int8 **)&v36, 2))
  {
    iv = 0;
    if (!CBS_get_asn1_uint64((unsigned __int8 **)&v36, (unint64_t *)&iv))
    {
      v9 = 104;
      v10 = 261;
      goto LABEL_6;
    }
    if (iv != (unsigned __int8 *)v17->key_len)
    {
      v9 = 125;
      v10 = 266;
      goto LABEL_6;
    }
  }
  v19 = EVP_sha1();
  if (!v37)
  {
    v25 = (EVP_MD *)v19;
    goto LABEL_58;
  }
  iv = 0;
  v32 = 0;
  v29 = 0;
  v30 = 0;
  if (!CBS_get_asn1((unsigned __int8 **)&v36, &iv, 536870928)
    || !CBS_get_asn1(&iv, &v29, 6)
    || v37)
  {
    v9 = 104;
    v10 = 277;
    goto LABEL_6;
  }
  if (v30 != 8)
    goto LABEL_71;
  v20 = *(unsigned __int8 *)(v29 + 7);
  v21 = *(_DWORD *)v29 == -2042067414 && *(unsigned __int8 *)(v29 + 4) == 247;
  v22 = v21;
  if (*(_BYTE *)(v29 + 5) != 13 || *(_BYTE *)(v29 + 6) != 2)
    v22 = 0;
  if (v22 != 1 || v20 != 7)
  {
    v21 = v20 == 9;
    v26 = v22 ^ 1;
    if (!v21)
      v26 = 1;
    if ((v26 & 1) == 0)
    {
      v24 = EVP_sha256();
      goto LABEL_67;
    }
LABEL_71:
    v9 = 130;
    v10 = 288;
    goto LABEL_6;
  }
  v24 = EVP_sha1();
LABEL_67:
  v25 = (EVP_MD *)v24;
  v27 = 0;
  v28 = 0;
  if (!CBS_get_asn1(&iv, &v27, 5) || v28 || v32)
  {
    v9 = 104;
    v10 = 297;
    goto LABEL_6;
  }
LABEL_58:
  iv = 0;
  v32 = 0;
  if (!CBS_get_asn1(&v40, &iv, 4) || v41)
  {
    v9 = 130;
    v10 = 309;
    goto LABEL_6;
  }
  return pkcs5_pbe2_cipher_init(a2, v17, v25, v18, a3, a4, v34, v35, iv, v32, 0);
}

const EVP_CIPHER *cbs_to_cipher(uint64_t *a1, uint64_t a2)
{
  int v2;
  _BOOL4 v4;
  int v9;
  uint64_t v10;

  if (a2 == 9)
  {
    v9 = *((unsigned __int8 *)a1 + 8);
    v10 = *a1;
    if (*a1 == 0x104036501488660 && v9 == 2)
    {
      return EVP_aes_128_cbc();
    }
    else
    {
      if (v10 != 0x104036501488660 || v9 != 22)
      {
        if (v10 == 0x104036501488660 && v9 == 42)
          return EVP_aes_256_cbc();
        return 0;
      }
      return EVP_aes_192_cbc();
    }
  }
  else
  {
    if (a2 != 8)
      return 0;
    v2 = *((unsigned __int8 *)a1 + 7);
    v4 = *(_DWORD *)a1 == -2042067414 && *((unsigned __int8 *)a1 + 4) == 247;
    if (*((_BYTE *)a1 + 5) != 13 || *((_BYTE *)a1 + 6) != 3)
      v4 = 0;
    if (!v4 || v2 != 2)
    {
      if (v2 == 7 && v4)
        return EVP_des_ede3_cbc();
      return 0;
    }
    return EVP_rc2_cbc();
  }
}

uint64_t dsa_pub_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  DSA *v6;
  int v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v12;
  void (*v13)(uint64_t);

  if (*(_QWORD *)(a2 + 8))
  {
    v6 = DSA_parse_parameters((unsigned __int8 **)a2);
    if (!v6 || *(_QWORD *)(a2 + 8))
    {
      v7 = 81;
LABEL_12:
      ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_dsa_asn1.c", v7);
LABEL_13:
      DSA_free(v6);
      return 0;
    }
  }
  else
  {
    v8 = (char *)malloc_type_malloc(0x118uLL, 0x30772F57uLL);
    if (!v8)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return 0;
    }
    v9 = v8;
    *(_QWORD *)v8 = 272;
    *(_OWORD *)(v8 + 8) = 0u;
    v6 = (DSA *)(v8 + 8);
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 40) = 0u;
    *(_OWORD *)(v8 + 56) = 0u;
    *(_OWORD *)(v8 + 72) = 0u;
    *(_OWORD *)(v8 + 88) = 0u;
    *(_OWORD *)(v8 + 104) = 0u;
    *(_OWORD *)(v8 + 120) = 0u;
    *(_OWORD *)(v8 + 136) = 0u;
    *(_OWORD *)(v8 + 152) = 0u;
    *(_OWORD *)(v8 + 168) = 0u;
    *(_OWORD *)(v8 + 184) = 0u;
    *(_OWORD *)(v8 + 200) = 0u;
    *(_OWORD *)(v8 + 216) = 0u;
    *(_OWORD *)(v8 + 232) = 0u;
    *(_OWORD *)(v8 + 264) = 0u;
    *((_DWORD *)v8 + 66) = 1;
    *(_OWORD *)(v8 + 248) = 0u;
    if (pthread_rwlock_init((pthread_rwlock_t *)(v8 + 48), 0))
      abort();
    *((_QWORD *)v9 + 34) = 0;
  }
  v10 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v10)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v6->p = 0;
    goto LABEL_13;
  }
  *(_QWORD *)v10 = 24;
  *((_QWORD *)v10 + 2) = 0;
  *((_QWORD *)v10 + 3) = 0x100000000;
  *((_QWORD *)v10 + 1) = 0;
  v6->p = (BIGNUM *)(v10 + 8);
  if (!BN_parse_asn1_unsigned((unsigned __int8 **)a3, (BIGNUM *)(v10 + 8)) || *(_QWORD *)(a3 + 8))
  {
    v7 = 93;
    goto LABEL_12;
  }
  v12 = *(_QWORD *)(a1 + 16);
  if (v12)
  {
    v13 = *(void (**)(uint64_t))(v12 + 160);
    if (v13)
      v13(a1);
  }
  *(_DWORD *)(a1 + 4) = 116;
  *(_QWORD *)(a1 + 8) = v6;
  *(_QWORD *)(a1 + 16) = &dsa_asn1_meth;
  return 1;
}

uint64_t dsa_pub_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  _BOOL4 v4;
  _BYTE *v5;
  _OWORD v7[3];
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];
  _BYTE *v11;

  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)v3 && *(_QWORD *)(v3 + 8) && *(_QWORD *)(v3 + 16) != 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  if (CBB_flush(a1))
  {
    v11 = 0;
    if (CBB_add_space((uint64_t)a1, &v11, 1))
    {
      *v11 = 48;
      if (cbb_add_child((uint64_t)a1, (uint64_t)v10, 1u, 1))
      {
        if (CBB_flush((uint64_t *)v10))
        {
          v11 = 0;
          if (CBB_add_space((uint64_t)v10, &v11, 1))
          {
            *v11 = 48;
            if (cbb_add_child((uint64_t)v10, (uint64_t)v9, 1u, 1))
            {
              if (CBB_flush((uint64_t *)v9))
              {
                v11 = 0;
                if (CBB_add_space((uint64_t)v9, &v11, 1))
                {
                  *v11 = 6;
                  if (cbb_add_child((uint64_t)v9, (uint64_t)v8, 1u, 1))
                  {
                    v11 = 0;
                    if (CBB_add_space((uint64_t)v8, &v11, 7))
                    {
                      v5 = v11;
                      *(_DWORD *)v11 = -834107862;
                      *(_DWORD *)(v5 + 3) = 17053902;
                      if (!v4 || DSA_marshal_parameters((uint64_t *)v9, (uint64_t **)v3))
                      {
                        if (CBB_flush((uint64_t *)v10))
                        {
                          v11 = 0;
                          if (CBB_add_space((uint64_t)v10, &v11, 1))
                          {
                            *v11 = 3;
                            if (cbb_add_child((uint64_t)v10, (uint64_t)v7, 1u, 1))
                            {
                              v11 = 0;
                              if (CBB_add_space((uint64_t)v7, &v11, 1))
                              {
                                *v11 = 0;
                                if (BN_marshal_asn1((uint64_t *)v7, *(uint64_t **)(v3 + 24)))
                                {
                                  if (CBB_flush(a1))
                                    return 1;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_dsa_asn1.c", 121);
  return 0;
}

BOOL dsa_pub_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  _BOOL4 v5;
  int v6;
  int v8;
  int v9;
  int v10;

  v2 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 24);
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
  {
    v5 = v3 != 0;
    if (v2)
      v6 = -1;
    else
      v6 = v5;
    return v6 == 0;
  }
  else
  {
    v8 = *(_DWORD *)(v2 + 16);
    if (v8 == *(_DWORD *)(v3 + 16))
    {
      v9 = bn_cmp_words_consttime(*(uint64_t **)v2, *(int *)(v2 + 8), *(uint64_t **)v3, *(int *)(v3 + 8));
      if (v8)
        v10 = -v9;
      else
        v10 = v9;
      return v10 == 0;
    }
    else
    {
      return 0;
    }
  }
}

uint64_t dsa_priv_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  DSA *v6;
  int v7;
  BN_CTX *v8;
  char *v10;
  char *v11;
  _QWORD *v12;
  _QWORD *v13;
  BIGNUM *v14;
  uint64_t v15;
  void (*v16)(uint64_t);

  v6 = DSA_parse_parameters((unsigned __int8 **)a2);
  if (!v6 || *(_QWORD *)(a2 + 8))
  {
    v7 = 135;
LABEL_4:
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_dsa_asn1.c", v7);
    v8 = 0;
LABEL_5:
    BN_CTX_free(v8);
    DSA_free(v6);
    return 0;
  }
  v10 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v10)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v8 = 0;
    v6->q = 0;
    goto LABEL_5;
  }
  *(_QWORD *)v10 = 24;
  *((_QWORD *)v10 + 2) = 0;
  *((_QWORD *)v10 + 3) = 0x100000000;
  *((_QWORD *)v10 + 1) = 0;
  v6->q = (BIGNUM *)(v10 + 8);
  if (!BN_parse_asn1_unsigned((unsigned __int8 **)a3, (BIGNUM *)(v10 + 8)) || *(_QWORD *)(a3 + 8))
  {
    v7 = 145;
    goto LABEL_4;
  }
  if (!dsa_check_key((const BIGNUM **)v6))
  {
    v7 = 153;
    goto LABEL_4;
  }
  v11 = (char *)malloc_type_malloc(0x38uLL, 0x30772F57uLL);
  if (v11)
  {
    *(_QWORD *)v11 = 48;
    *(_OWORD *)(v11 + 8) = 0u;
    v8 = (BN_CTX *)(v11 + 8);
    *(_OWORD *)(v11 + 24) = 0u;
    *(_OWORD *)(v11 + 34) = 0u;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v8 = 0;
  }
  v12 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v12)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v6->p = 0;
    goto LABEL_5;
  }
  v13 = v12;
  *v12 = 24;
  v12[1] = 0;
  v14 = (BIGNUM *)(v12 + 1);
  v13[2] = 0;
  v13[3] = 0x100000000;
  v6->p = v14;
  if (!v8
    || !BN_mod_exp_mont_consttime(v14, *(const BIGNUM **)&v6->write_params, v6->q, *(const BIGNUM **)&v6->pad, v8, 0))
  {
    goto LABEL_5;
  }
  BN_CTX_free(v8);
  v15 = *(_QWORD *)(a1 + 16);
  if (v15)
  {
    v16 = *(void (**)(uint64_t))(v15 + 160);
    if (v16)
      v16(a1);
  }
  *(_DWORD *)(a1 + 4) = 116;
  *(_QWORD *)(a1 + 8) = v6;
  *(_QWORD *)(a1 + 16) = &dsa_asn1_meth;
  return 1;
}

uint64_t dsa_priv_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t **v2;
  _BYTE *v4;
  _OWORD v6[3];
  _OWORD v7[3];
  _OWORD v8[3];
  _OWORD v9[3];
  _BYTE *v10;

  v2 = *(uint64_t ***)(a2 + 8);
  if (v2 && v2[4])
  {
    memset(v9, 0, sizeof(v9));
    memset(v8, 0, sizeof(v8));
    memset(v7, 0, sizeof(v7));
    memset(v6, 0, sizeof(v6));
    if (!CBB_flush(a1))
      goto LABEL_22;
    v10 = 0;
    if (!CBB_add_space((uint64_t)a1, &v10, 1))
      goto LABEL_22;
    *v10 = 48;
    if (!cbb_add_child((uint64_t)a1, (uint64_t)v9, 1u, 1))
      goto LABEL_22;
    if (!CBB_add_asn1_uint64_with_tag((uint64_t)v9, 0, 2))
      goto LABEL_22;
    if (!CBB_flush((uint64_t *)v9))
      goto LABEL_22;
    v10 = 0;
    if (!CBB_add_space((uint64_t)v9, &v10, 1))
      goto LABEL_22;
    *v10 = 48;
    if (!cbb_add_child((uint64_t)v9, (uint64_t)v8, 1u, 1))
      goto LABEL_22;
    if (!CBB_flush((uint64_t *)v8))
      goto LABEL_22;
    v10 = 0;
    if (!CBB_add_space((uint64_t)v8, &v10, 1))
      goto LABEL_22;
    *v10 = 6;
    if (cbb_add_child((uint64_t)v8, (uint64_t)v7, 1u, 1)
      && (v10 = 0, CBB_add_space((uint64_t)v7, &v10, 7))
      && (v4 = v10,
          *(_DWORD *)v10 = -834107862,
          *(_DWORD *)(v4 + 3) = 17053902,
          DSA_marshal_parameters((uint64_t *)v8, v2))
      && CBB_flush((uint64_t *)v9)
      && (v10 = 0, CBB_add_space((uint64_t)v9, &v10, 1))
      && (*v10 = 4, cbb_add_child((uint64_t)v9, (uint64_t)v6, 1u, 1))
      && BN_marshal_asn1((uint64_t *)v6, v2[4])
      && CBB_flush(a1))
    {
      return 1;
    }
    else
    {
LABEL_22:
      ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_dsa_asn1.c", 194);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 118, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_dsa_asn1.c", 179);
    return 0;
  }
}

uint64_t int_dsa_size(uint64_t a1)
{
  return DSA_size(*(const DSA **)(a1 + 8));
}

uint64_t dsa_bits(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  unint64_t v11;
  _BOOL4 v12;
  _BOOL4 v13;
  _BOOL4 v14;
  _BOOL4 v15;
  _BOOL4 v16;
  _BOOL4 v17;
  unsigned int v18;

  v1 = **(uint64_t ***)(a1 + 8);
  v2 = *((unsigned int *)v1 + 2);
  v3 = v2 & ((int)v2 >> 31);
  v4 = 8 * v2 - 8;
  v5 = *((_DWORD *)v1 + 2);
  while (1)
  {
    v6 = __OFSUB__(v5--, 1);
    if (v5 < 0 != v6)
      break;
    v7 = *v1;
    v8 = *(_QWORD *)(*v1 + v4);
    v4 -= 8;
    if (v8)
    {
      v3 = v5 + 1;
      goto LABEL_8;
    }
  }
  if ((v2 & 0x80000000) == 0)
    return 0;
  v7 = *v1;
LABEL_8:
  v10 = v3 - 1;
  v11 = *(_QWORD *)(v7 + 8 * v10);
  v12 = v11 != 0;
  v13 = HIDWORD(v11) != 0;
  if (HIDWORD(v11))
    v11 >>= 32;
  v14 = v11 >> 16 != 0;
  if (v11 >> 16)
    v11 >>= 16;
  v15 = v11 > 0xFF;
  if (v11 > 0xFF)
    v11 >>= 8;
  v16 = v11 > 0xF;
  if (v11 > 0xF)
    v11 >>= 4;
  v17 = v11 > 3;
  if (v11 > 3)
    v11 >>= 2;
  v18 = v12 | (v10 << 6) | (32 * v13) | (16 * v14) | (8 * v15) | (4 * v16) | (2 * v17);
  if (v11 <= 1)
    return v18;
  else
    return v18 + 1;
}

BOOL dsa_missing_parameters(uint64_t a1)
{
  _QWORD *v1;

  v1 = *(_QWORD **)(a1 + 8);
  return !*v1 || !v1[1] || v1[2] == 0;
}

BIGNUM *dsa_copy_parameters(uint64_t a1, uint64_t a2)
{
  BIGNUM **v2;
  const BIGNUM **v3;
  BIGNUM *result;
  BIGNUM *v5;
  BIGNUM *v6;
  int flags;
  unint64_t *d;
  unint64_t *v9;
  uint64_t v10;
  size_t v11;
  int *p_neg;
  uint64_t v13;
  size_t v14;
  BIGNUM *v15;
  BIGNUM *v16;
  int v17;
  unint64_t *v18;
  unint64_t *v19;
  uint64_t v20;
  size_t v21;
  int *v22;
  uint64_t v23;
  size_t v24;
  BIGNUM *v25;
  BIGNUM *v26;
  int v27;
  unint64_t *v28;
  unint64_t *v29;
  uint64_t v30;
  size_t v31;
  int *v32;
  uint64_t v33;
  size_t v34;

  v2 = *(BIGNUM ***)(a1 + 8);
  v3 = *(const BIGNUM ***)(a2 + 8);
  result = BN_dup(*v3);
  if (!result)
    return result;
  v5 = result;
  v6 = *v2;
  if (*v2)
  {
    flags = v6->flags;
    if ((flags & 2) == 0)
    {
      d = v6->d;
      if (v6->d)
      {
        v10 = *(d - 1);
        v9 = d - 1;
        v11 = v10 + 8;
        if (v10 != -8)
          bzero(v9, v11);
        free(v9);
        flags = v6->flags;
      }
    }
    if ((flags & 1) != 0)
    {
      v13 = *(_QWORD *)&v6[-1].neg;
      p_neg = &v6[-1].neg;
      v14 = v13 + 8;
      if (v13 != -8)
        bzero(p_neg, v14);
      free(p_neg);
      *v2 = v5;
      result = BN_dup(v3[1]);
      if (!result)
        return result;
      goto LABEL_15;
    }
    v6->d = 0;
  }
  *v2 = v5;
  result = BN_dup(v3[1]);
  if (!result)
    return result;
LABEL_15:
  v15 = result;
  v16 = v2[1];
  if (!v16)
    goto LABEL_23;
  v17 = v16->flags;
  if ((v17 & 2) == 0)
  {
    v18 = v16->d;
    if (v16->d)
    {
      v20 = *(v18 - 1);
      v19 = v18 - 1;
      v21 = v20 + 8;
      if (v20 != -8)
        bzero(v19, v21);
      free(v19);
      v17 = v16->flags;
    }
  }
  if ((v17 & 1) == 0)
  {
    v16->d = 0;
LABEL_23:
    v2[1] = v15;
    result = BN_dup(v3[2]);
    if (!result)
      return result;
    goto LABEL_28;
  }
  v23 = *(_QWORD *)&v16[-1].neg;
  v22 = &v16[-1].neg;
  v24 = v23 + 8;
  if (v23 != -8)
    bzero(v22, v24);
  free(v22);
  v2[1] = v15;
  result = BN_dup(v3[2]);
  if (result)
  {
LABEL_28:
    v25 = result;
    v26 = v2[2];
    if (v26)
    {
      v27 = v26->flags;
      if ((v27 & 2) == 0)
      {
        v28 = v26->d;
        if (v26->d)
        {
          v30 = *(v28 - 1);
          v29 = v28 - 1;
          v31 = v30 + 8;
          if (v30 != -8)
            bzero(v29, v31);
          free(v29);
          v27 = v26->flags;
        }
      }
      if ((v27 & 1) != 0)
      {
        v33 = *(_QWORD *)&v26[-1].neg;
        v32 = &v26[-1].neg;
        v34 = v33 + 8;
        if (v33 != -8)
          bzero(v32, v34);
        free(v32);
      }
      else
      {
        v26->d = 0;
      }
    }
    v2[2] = v25;
    return (BIGNUM *)1;
  }
  return result;
}

BOOL dsa_cmp_parameters(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  int v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  int v13;
  int v14;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  _BOOL4 v20;
  int v21;
  int v22;
  int v23;
  int v24;

  v2 = *(uint64_t **)(a1 + 8);
  v3 = *(uint64_t **)(a2 + 8);
  v4 = *v2;
  v5 = *v3;
  if (*v2)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (v4 | v5)
      return 0;
  }
  else
  {
    v7 = *(_DWORD *)(v4 + 16);
    if (v7 != *(_DWORD *)(v5 + 16))
      return 0;
    v8 = bn_cmp_words_consttime(*(uint64_t **)v4, *(int *)(v4 + 8), *(uint64_t **)v5, *(int *)(v5 + 8));
    if (v7 ? -v8 : v8)
      return 0;
  }
  v10 = v2[1];
  v11 = v3[1];
  if (v10)
    v12 = v11 == 0;
  else
    v12 = 1;
  if (v12)
  {
    if (!(v10 | v11))
      goto LABEL_26;
    return 0;
  }
  v13 = *(_DWORD *)(v10 + 16);
  if (v13 != *(_DWORD *)(v11 + 16))
    return 0;
  v14 = bn_cmp_words_consttime(*(uint64_t **)v10, *(int *)(v10 + 8), *(uint64_t **)v11, *(int *)(v11 + 8));
  if (v13 ? -v14 : v14)
    return 0;
LABEL_26:
  v17 = v2[2];
  v18 = v3[2];
  if (v17)
    v19 = v18 == 0;
  else
    v19 = 1;
  if (v19)
  {
    v20 = v18 != 0;
    if (v17)
      v21 = -1;
    else
      v21 = v20;
    return v21 == 0;
  }
  else
  {
    v22 = *(_DWORD *)(v17 + 16);
    if (v22 == *(_DWORD *)(v18 + 16))
    {
      v23 = bn_cmp_words_consttime(*(uint64_t **)v17, *(int *)(v17 + 8), *(uint64_t **)v18, *(int *)(v18 + 8));
      if (v22)
        v24 = -v23;
      else
        v24 = v23;
      return v24 == 0;
    }
    else
    {
      return 0;
    }
  }
}

void int_dsa_free(uint64_t a1)
{
  DSA_free(*(DSA **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
}

uint64_t pkey_ec_init(uint64_t a1)
{
  _QWORD *v2;

  v2 = malloc_type_malloc(0x18uLL, 0x30772F57uLL);
  if (v2)
  {
    *v2 = 16;
    v2[2] = 0;
    v2[1] = 0;
    *(_QWORD *)(a1 + 40) = v2 + 1;
    return 1;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
}

uint64_t pkey_ec_copy(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _OWORD *v5;

  v4 = malloc_type_malloc(0x18uLL, 0x30772F57uLL);
  if (v4)
  {
    *v4 = 16;
    v4[2] = 0;
    v4[1] = 0;
    v5 = v4 + 1;
    *(_QWORD *)(a1 + 40) = v5;
    *v5 = *(_OWORD *)*(_QWORD *)(a2 + 40);
    return 1;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
}

void pkey_ec_cleanup(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  size_t v4;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
  {
    v3 = *(_QWORD *)(v1 - 8);
    v2 = (void *)(v1 - 8);
    v4 = v3 + 8;
    if (v3 != -8)
      bzero(v2, v4);
    free(v2);
  }
}

uint64_t pkey_ec_keygen(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  char *v4;
  EC_KEY *v5;
  uint64_t v6;
  void (*v7)(uint64_t);
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  char v13;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (v3)
  {
    v4 = (char *)malloc_type_malloc(0x40uLL, 0x30772F57uLL);
    if (v4)
      goto LABEL_3;
LABEL_12:
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v5 = 0;
LABEL_13:
    EC_KEY_free(v5);
    return 0;
  }
  v9 = *(_QWORD *)(a1 + 16);
  if (!v9)
  {
    ERR_put_error(6, 0, 124, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec.c", 212);
    return 0;
  }
  v3 = **(_QWORD **)(v9 + 8);
  v4 = (char *)malloc_type_malloc(0x40uLL, 0x30772F57uLL);
  if (!v4)
    goto LABEL_12;
LABEL_3:
  *(_QWORD *)v4 = 56;
  *(_OWORD *)(v4 + 8) = 0u;
  v5 = (EC_KEY *)(v4 + 8);
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *((_QWORD *)v4 + 7) = 0;
  *(_QWORD *)(v4 + 36) = 0x100000004;
  if (!v3)
    goto LABEL_13;
  if (!*(_DWORD *)(v3 + 512))
  {
    v10 = (unsigned int *)(v3 + 540);
    v11 = atomic_load((unsigned int *)(v3 + 540));
    if (v11 != -1)
    {
      while (1)
      {
        v12 = __ldaxr(v10);
        if (v12 == v11)
        {
          if (!__stlxr(v11 + 1, v10))
          {
            v13 = 1;
            goto LABEL_21;
          }
        }
        else
        {
          __clrex();
        }
        v13 = 0;
LABEL_21:
        if ((v13 & 1) == 0)
        {
          v11 = v12;
          if (v12 != -1)
            continue;
        }
        break;
      }
    }
  }
  *(_QWORD *)v5 = v3;
  if (!EC_KEY_generate_key((EC_KEY *)(v4 + 8)))
    goto LABEL_13;
  v6 = *(_QWORD *)(a2 + 16);
  if (v6)
  {
    v7 = *(void (**)(uint64_t))(v6 + 160);
    if (v7)
      v7(a2);
  }
  *(_DWORD *)(a2 + 4) = 408;
  *(_QWORD *)(a2 + 8) = v5;
  *(_QWORD *)(a2 + 16) = &ec_asn1_meth;
  return 1;
}

uint64_t pkey_ec_sign(uint64_t a1, unsigned __int8 *a2, unint64_t *a3, const unsigned __int8 *a4, int a5)
{
  uint64_t v6;
  EC_KEY *v7;
  unint64_t v11;
  uint64_t result;
  unsigned int siglen;

  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(EC_KEY **)(v6 + 8);
  if (!a2)
  {
    *a3 = ECDSA_size(*(const EC_KEY **)(v6 + 8));
    return 1;
  }
  v11 = *a3;
  if (v11 < ECDSA_size(*(const EC_KEY **)(v6 + 8)))
  {
    ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec.c", 120);
    return 0;
  }
  siglen = 0;
  result = ECDSA_sign(0, a4, a5, a2, &siglen, v7);
  if ((_DWORD)result)
  {
    *a3 = siglen;
    return 1;
  }
  return result;
}

uint64_t pkey_ec_verify(uint64_t a1, unsigned __int8 *sig, int siglen, unsigned __int8 *dgst, int dgstlen)
{
  return ECDSA_verify(0, dgst, dgstlen, sig, siglen, *(EC_KEY **)(*(_QWORD *)(a1 + 16) + 8));
}

uint64_t pkey_ec_derive(uint64_t a1, void *out, size_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  EC_KEY *v6;
  unsigned int v7;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  _BOOL4 v19;
  _BOOL4 v20;
  _BOOL4 v21;
  _BOOL4 v22;
  _BOOL4 v23;
  _BOOL4 v24;
  int v25;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && (v4 = *(_QWORD *)(a1 + 24)) != 0)
  {
    v6 = *(EC_KEY **)(v3 + 8);
    if (out)
    {
      v7 = ECDH_compute_key(out, *a3, *(const EC_POINT **)(*(_QWORD *)(v4 + 8) + 8), v6, 0);
      if ((v7 & 0x80000000) != 0)
      {
        return 0;
      }
      else
      {
        *a3 = v7;
        return 1;
      }
    }
    else
    {
      v9 = *(_QWORD *)v6;
      v10 = *(unsigned int *)(*(_QWORD *)v6 + 328);
      v11 = v10 & ((int)v10 >> 31);
      v12 = 8 * v10 - 8;
      v13 = *(_DWORD *)(*(_QWORD *)v6 + 328);
      while (1)
      {
        v14 = __OFSUB__(v13--, 1);
        if (v13 < 0 != v14)
          break;
        v15 = *(_QWORD *)(v9 + 320);
        v16 = *(_QWORD *)(v15 + v12);
        v12 -= 8;
        if (v16)
        {
          v11 = v13 + 1;
          goto LABEL_15;
        }
      }
      if ((v10 & 0x80000000) == 0)
      {
        *a3 = 0;
        return 1;
      }
      v15 = *(_QWORD *)(v9 + 320);
LABEL_15:
      v17 = v11 - 1;
      v18 = *(_QWORD *)(v15 + 8 * v17);
      v19 = v18 != 0;
      v20 = HIDWORD(v18) != 0;
      if (HIDWORD(v18))
        v18 >>= 32;
      v21 = v18 >> 16 != 0;
      if (v18 >> 16)
        v18 >>= 16;
      v22 = v18 > 0xFF;
      if (v18 > 0xFF)
        v18 >>= 8;
      v23 = v18 > 0xF;
      if (v18 > 0xF)
        v18 >>= 4;
      v24 = v18 > 3;
      if (v18 > 3)
        v18 >>= 2;
      v25 = v19 | (v17 << 6) | (32 * v20) | (16 * v21) | (8 * v22) | (4 * v23) | (2 * v24);
      if (v18 > 1)
        ++v25;
      *a3 = (v25 + 7) >> 3;
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 0, 117, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec.c", 141);
    return 0;
  }
}

uint64_t pkey_ec_paramgen(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char *v4;
  EC_KEY *v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  char v10;
  uint64_t v11;
  void (*v12)(uint64_t);

  v2 = *(_QWORD *)(a1 + 40);
  if (!*(_QWORD *)(v2 + 8))
  {
    ERR_put_error(6, 0, 124, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec.c", 231);
    return 0;
  }
  v4 = (char *)malloc_type_malloc(0x40uLL, 0x30772F57uLL);
  if (!v4)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v5 = 0;
    goto LABEL_19;
  }
  *(_QWORD *)v4 = 56;
  *(_OWORD *)(v4 + 8) = 0u;
  v5 = (EC_KEY *)(v4 + 8);
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *((_QWORD *)v4 + 7) = 0;
  *(_QWORD *)(v4 + 36) = 0x100000004;
  v6 = *(_QWORD *)(v2 + 8);
  if (!v6)
  {
LABEL_19:
    EC_KEY_free(v5);
    return 0;
  }
  if (!*(_DWORD *)(v6 + 512))
  {
    v7 = (unsigned int *)(v6 + 540);
    v8 = atomic_load((unsigned int *)(v6 + 540));
    if (v8 != -1)
    {
      while (1)
      {
        v9 = __ldaxr(v7);
        if (v9 == v8)
        {
          if (!__stlxr(v8 + 1, v7))
          {
            v10 = 1;
            goto LABEL_11;
          }
        }
        else
        {
          __clrex();
        }
        v10 = 0;
LABEL_11:
        if ((v10 & 1) == 0)
        {
          v8 = v9;
          if (v9 != -1)
            continue;
        }
        break;
      }
    }
  }
  *(_QWORD *)v5 = v6;
  v11 = *(_QWORD *)(a2 + 16);
  if (v11)
  {
    v12 = *(void (**)(uint64_t))(v11 + 160);
    if (v12)
      v12(a2);
  }
  *(_DWORD *)(a2 + 4) = 408;
  *(_QWORD *)(a2 + 8) = v5;
  *(_QWORD *)(a2 + 16) = &ec_asn1_meth;
  return 1;
}

uint64_t pkey_ec_ctrl(uint64_t a1, int a2, int nid, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t result;

  v4 = *(_QWORD **)(a1 + 40);
  if (a2 <= 2)
  {
    if (a2 != 1)
    {
      if (a2 == 2)
      {
        *a4 = *v4;
        return 1;
      }
      goto LABEL_13;
    }
    if ((*(_DWORD *)a4 - 672) >= 4 && *(_DWORD *)a4 != 64)
    {
      ERR_put_error(6, 0, 111, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec.c", 177);
      return 0;
    }
    *v4 = a4;
    return 1;
  }
  if (a2 == 3)
    return 1;
  if (a2 != 4109)
  {
LABEL_13:
    ERR_put_error(6, 0, 101, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec.c", 202);
    return 0;
  }
  result = (uint64_t)EC_GROUP_new_by_curve_name(nid);
  if (result)
  {
    v4[1] = result;
    return 1;
  }
  return result;
}

uint64_t eckey_pub_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v6;
  const char *v7;
  int v8;
  int v9;
  int v10;
  EC_KEY *v11;
  uint64_t *v13;
  char *v14;
  uint64_t v15;
  void (*v16)(uint64_t);
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  char v20;

  v6 = EC_KEY_parse_curve_name((unsigned __int8 **)a2);
  if (!v6 || *(_QWORD *)(a2 + 8))
  {
    v7 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cr"
         "ypto/evp/p_ec_asn1.c";
    v8 = 6;
    v9 = 102;
    v10 = 99;
LABEL_4:
    ERR_put_error(v8, 0, v9, v7, v10);
    v11 = 0;
LABEL_5:
    EC_KEY_free(v11);
    return 0;
  }
  v13 = v6;
  v14 = (char *)malloc_type_malloc(0x40uLL, 0x30772F57uLL);
  if (!v14)
  {
    v7 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v8 = 14;
    v9 = 65;
    v10 = 247;
    goto LABEL_4;
  }
  *(_QWORD *)v14 = 56;
  *(_OWORD *)(v14 + 8) = 0u;
  v11 = (EC_KEY *)(v14 + 8);
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *((_QWORD *)v14 + 7) = 0;
  *(_QWORD *)(v14 + 36) = 0x100000004;
  if (!*((_DWORD *)v13 + 128))
  {
    v17 = (unsigned int *)v13 + 135;
    v18 = atomic_load((unsigned int *)v13 + 135);
    if (v18 != -1)
    {
      while (1)
      {
        v19 = __ldaxr(v17);
        if (v19 == v18)
        {
          if (!__stlxr(v18 + 1, v17))
          {
            v20 = 1;
            goto LABEL_20;
          }
        }
        else
        {
          __clrex();
        }
        v20 = 0;
LABEL_20:
        if ((v20 & 1) == 0)
        {
          v18 = v19;
          if (v19 != -1)
            continue;
        }
        break;
      }
    }
  }
  *(_QWORD *)v11 = v13;
  if (!EC_KEY_oct2key((const EC_GROUP **)v14 + 1, *(const unsigned __int8 **)a3, *(_QWORD *)(a3 + 8), 0))
    goto LABEL_5;
  v15 = *(_QWORD *)(a1 + 16);
  if (v15)
  {
    v16 = *(void (**)(uint64_t))(v15 + 160);
    if (v16)
      v16(a1);
  }
  *(_DWORD *)(a1 + 4) = 408;
  *(_QWORD *)(a1 + 8) = v11;
  *(_QWORD *)(a1 + 16) = &ec_asn1_meth;
  return 1;
}

uint64_t eckey_pub_encode(uint64_t *a1, uint64_t a2)
{
  const EC_GROUP **v3;
  const EC_GROUP *v4;
  const EC_POINT *v5;
  unsigned __int8 *v6;
  size_t v7;
  size_t v8;
  _OWORD v10[3];
  _OWORD v11[3];
  _OWORD v12[3];
  _OWORD v13[3];
  unsigned __int8 *v14;

  v3 = *(const EC_GROUP ***)(a2 + 8);
  v4 = *v3;
  v5 = v3[1];
  memset(v13, 0, sizeof(v13));
  memset(v12, 0, sizeof(v12));
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  if (CBB_flush(a1))
  {
    v14 = 0;
    if (CBB_add_space((uint64_t)a1, &v14, 1))
    {
      *v14 = 48;
      if (cbb_add_child((uint64_t)a1, (uint64_t)v13, 1u, 1))
      {
        if (CBB_flush((uint64_t *)v13))
        {
          v14 = 0;
          if (CBB_add_space((uint64_t)v13, &v14, 1))
          {
            *v14 = 48;
            if (cbb_add_child((uint64_t)v13, (uint64_t)v12, 1u, 1))
            {
              if (CBB_flush((uint64_t *)v12))
              {
                v14 = 0;
                if (CBB_add_space((uint64_t)v12, &v14, 1))
                {
                  *v14 = 6;
                  if (cbb_add_child((uint64_t)v12, (uint64_t)v11, 1u, 1))
                  {
                    v14 = 0;
                    if (CBB_add_space((uint64_t)v11, &v14, 7))
                    {
                      v6 = v14;
                      *(_DWORD *)v14 = -834107862;
                      *(_DWORD *)(v6 + 3) = 16924110;
                      if (EC_KEY_marshal_curve_name((uint64_t *)v12, (uint64_t)v4))
                      {
                        if (CBB_flush((uint64_t *)v13))
                        {
                          v14 = 0;
                          if (CBB_add_space((uint64_t)v13, &v14, 1))
                          {
                            *v14 = 3;
                            if (cbb_add_child((uint64_t)v13, (uint64_t)v10, 1u, 1))
                            {
                              v14 = 0;
                              if (CBB_add_space((uint64_t)v10, &v14, 1))
                              {
                                *v14 = 0;
                                v7 = EC_POINT_point2oct(v4, v5, POINT_CONVERSION_UNCOMPRESSED, 0, 0, 0);
                                if (v7)
                                {
                                  v8 = v7;
                                  v14 = 0;
                                  if (CBB_add_space((uint64_t)v10, &v14, v7))
                                  {
                                    if (EC_POINT_point2oct(v4, v5, POINT_CONVERSION_UNCOMPRESSED, v14, v8, 0) == v8
                                      && CBB_flush(a1))
                                    {
                                      return 1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec_asn1.c", 85);
  return 0;
}

uint64_t eckey_pub_cmp(uint64_t a1, uint64_t a2, BN_CTX *a3)
{
  uint64_t v3;
  uint64_t v4;
  const EC_GROUP *v5;
  const EC_GROUP **v6;
  BN_CTX *v7;

  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  v5 = *(const EC_GROUP **)v3;
  v6 = *(const EC_GROUP ***)(v3 + 8);
  if (!EC_GROUP_cmp(*(const EC_GROUP **)v3, *(const EC_GROUP **)v4, a3) && !EC_GROUP_cmp(v5, *v6, v7))
    return ec_GFp_simple_points_equal((uint64_t)v5, (int8x16_t *)(v4 + 8), (uint64_t)(v6 + 1)) != 0;
  ERR_put_error(15, 0, 106, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/ec/ec.c", 556);
  return 4294967294;
}

uint64_t eckey_priv_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v6;
  EC_KEY *v8;
  uint64_t v9;
  void (*v10)(uint64_t);

  v6 = EC_KEY_parse_parameters((unsigned __int8 **)a2);
  if (v6 && !*(_QWORD *)(a2 + 8))
  {
    v8 = EC_KEY_parse_private_key((unsigned __int8 **)a3, (uint64_t)v6);
    if (v8 && !*(_QWORD *)(a3 + 8))
    {
      v9 = *(_QWORD *)(a1 + 16);
      if (v9)
      {
        v10 = *(void (**)(uint64_t))(v9 + 160);
        if (v10)
          v10(a1);
      }
      *(_DWORD *)(a1 + 4) = 408;
      *(_QWORD *)(a1 + 8) = v8;
      *(_QWORD *)(a1 + 16) = &ec_asn1_meth;
      return 1;
    }
    else
    {
      ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec_asn1.c", 144);
      EC_KEY_free(v8);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec_asn1.c", 138);
    return 0;
  }
}

uint64_t eckey_priv_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  _BYTE *v5;
  _OWORD v7[3];
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];
  _BYTE *v11;

  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_DWORD *)(v3 + 24);
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  if (CBB_flush(a1))
  {
    v11 = 0;
    if (CBB_add_space((uint64_t)a1, &v11, 1))
    {
      *v11 = 48;
      if (cbb_add_child((uint64_t)a1, (uint64_t)v10, 1u, 1))
      {
        if (CBB_add_asn1_uint64_with_tag((uint64_t)v10, 0, 2))
        {
          if (CBB_flush((uint64_t *)v10))
          {
            v11 = 0;
            if (CBB_add_space((uint64_t)v10, &v11, 1))
            {
              *v11 = 48;
              if (cbb_add_child((uint64_t)v10, (uint64_t)v9, 1u, 1))
              {
                if (CBB_flush((uint64_t *)v9))
                {
                  v11 = 0;
                  if (CBB_add_space((uint64_t)v9, &v11, 1))
                  {
                    *v11 = 6;
                    if (cbb_add_child((uint64_t)v9, (uint64_t)v8, 1u, 1))
                    {
                      v11 = 0;
                      if (CBB_add_space((uint64_t)v8, &v11, 7))
                      {
                        v5 = v11;
                        *(_DWORD *)v11 = -834107862;
                        *(_DWORD *)(v5 + 3) = 16924110;
                        if (EC_KEY_marshal_curve_name((uint64_t *)v9, *(_QWORD *)v3))
                        {
                          if (CBB_flush((uint64_t *)v10))
                          {
                            v11 = 0;
                            if (CBB_add_space((uint64_t)v10, &v11, 1))
                            {
                              *v11 = 4;
                              if (cbb_add_child((uint64_t)v10, (uint64_t)v7, 1u, 1))
                              {
                                if (EC_KEY_marshal_private_key((uint64_t *)v7, (uint64_t *)v3, v4 | 1u)
                                  && CBB_flush(a1))
                                {
                                  return 1;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec_asn1.c", 173);
  return 0;
}

BOOL eckey_set1_tls_encodedpoint(uint64_t a1, const unsigned __int8 *a2, size_t a3)
{
  const EC_GROUP **v3;

  v3 = *(const EC_GROUP ***)(a1 + 8);
  if (v3)
    return EC_KEY_oct2key(v3, a2, a3, 0);
  ERR_put_error(6, 0, 120, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec_asn1.c", 184);
  return 0;
}

size_t eckey_get1_tls_encodedpoint(uint64_t a1, char **a2, uint64_t a3, uint64_t a4, uint64_t a5, BN_CTX *a6)
{
  const EC_GROUP **v6;
  const EC_POINT *v8;

  v6 = *(const EC_GROUP ***)(a1 + 8);
  if (v6)
  {
    v8 = v6[1];
    if (v8 && *v6)
    {
      return EC_POINT_point2buf(*v6, v8, POINT_CONVERSION_UNCOMPRESSED, a2, 0, a6);
    }
    else
    {
      ERR_put_error(15, 0, 114, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/ec/ec_key.c", 414);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 120, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec_asn1.c", 195);
    return 0;
  }
}

uint64_t eckey_opaque(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40);
  if (v1)
    return *(_DWORD *)(v1 + 48) & 1;
  else
    return 0;
}

uint64_t int_ec_size(uint64_t a1)
{
  return ECDSA_size(*(const EC_KEY **)(a1 + 8));
}

uint64_t ec_bits(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  unint64_t v11;
  _BOOL4 v12;
  _BOOL4 v13;
  _BOOL4 v14;
  _BOOL4 v15;
  _BOOL4 v16;
  _BOOL4 v17;
  unsigned int v18;

  v1 = **(_QWORD **)(a1 + 8);
  if (v1)
  {
    v2 = *(unsigned int *)(v1 + 264);
    v3 = v2 & ((int)v2 >> 31);
    v4 = 8 * v2 - 8;
    v5 = *(_DWORD *)(v1 + 264);
    while (1)
    {
      v6 = __OFSUB__(v5--, 1);
      if (v5 < 0 != v6)
        break;
      v7 = *(_QWORD *)(v1 + 256);
      v8 = *(_QWORD *)(v7 + v4);
      v4 -= 8;
      if (v8)
      {
        v3 = v5 + 1;
        goto LABEL_10;
      }
    }
    if ((v2 & 0x80000000) == 0)
      return 0;
    v7 = *(_QWORD *)(v1 + 256);
LABEL_10:
    v10 = v3 - 1;
    v11 = *(_QWORD *)(v7 + 8 * v10);
    v12 = v11 != 0;
    v13 = HIDWORD(v11) != 0;
    if (HIDWORD(v11))
      v11 >>= 32;
    v14 = v11 >> 16 != 0;
    if (v11 >> 16)
      v11 >>= 16;
    v15 = v11 > 0xFF;
    if (v11 > 0xFF)
      v11 >>= 8;
    v16 = v11 > 0xF;
    if (v11 > 0xF)
      v11 >>= 4;
    v17 = v11 > 3;
    if (v11 > 3)
      v11 >>= 2;
    v18 = v12 | (v10 << 6) | (32 * v13) | (16 * v14) | (8 * v15) | (4 * v16) | (2 * v17);
    if (v11 <= 1)
      return v18;
    else
      return v18 + 1;
  }
  else
  {
    ERR_clear_error();
    return 0;
  }
}

BOOL ec_missing_parameters(uint64_t a1)
{
  _QWORD *v1;

  v1 = *(_QWORD **)(a1 + 8);
  return !v1 || *v1 == 0;
}

uint64_t ec_copy_parameters(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  const EC_GROUP **v5;
  uint64_t result;
  char *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  char v11;

  v2 = *(uint64_t **)(a2 + 8);
  if (!v2)
  {
    ERR_put_error(6, 0, 120, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec_asn1.c", 225);
    return 0;
  }
  v3 = *v2;
  if (!*v2)
  {
    ERR_put_error(6, 0, 118, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec_asn1.c", 230);
    return 0;
  }
  v5 = *(const EC_GROUP ***)(a1 + 8);
  if (v5)
  {
    if (*v5)
    {
      if (EC_GROUP_cmp(*v5, (const EC_GROUP *)v3, 0))
      {
        ERR_put_error(15, 0, 130, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/ec/ec_key.c", 216);
        return 0;
      }
      return 1;
    }
    goto LABEL_11;
  }
  v7 = (char *)malloc_type_malloc(0x40uLL, 0x30772F57uLL);
  if (v7)
  {
    *(_QWORD *)v7 = 56;
    *(_OWORD *)(v7 + 8) = 0u;
    v5 = (const EC_GROUP **)(v7 + 8);
    *(_OWORD *)(v7 + 24) = 0u;
    *(_OWORD *)(v7 + 40) = 0u;
    *((_QWORD *)v7 + 7) = 0;
    *(_QWORD *)(v7 + 36) = 0x100000004;
    *(_QWORD *)(a1 + 8) = v7 + 8;
LABEL_11:
    if (*(_DWORD *)(v3 + 512)
      || (v8 = (unsigned int *)(v3 + 540), v9 = atomic_load((unsigned int *)(v3 + 540)), v9 == -1))
    {
LABEL_12:
      *v5 = (const EC_GROUP *)v3;
      return 1;
    }
    while (1)
    {
      v10 = __ldaxr(v8);
      if (v10 == v9)
      {
        if (!__stlxr(v9 + 1, v8))
        {
          v11 = 1;
          goto LABEL_20;
        }
      }
      else
      {
        __clrex();
      }
      v11 = 0;
LABEL_20:
      if ((v11 & 1) == 0)
      {
        v9 = v10;
        if (v10 != -1)
          continue;
      }
      goto LABEL_12;
    }
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  result = 0;
  *(_QWORD *)(a1 + 8) = 0;
  return result;
}

uint64_t ec_cmp_parameters(uint64_t a1, uint64_t a2)
{
  const EC_GROUP **v2;
  const EC_GROUP **v3;
  BOOL v4;
  const EC_GROUP *v6;
  BOOL v7;

  v2 = *(const EC_GROUP ***)(a1 + 8);
  v3 = *(const EC_GROUP ***)(a2 + 8);
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
    return 4294967294;
  v6 = *v3;
  if (*v2)
    v7 = v6 == 0;
  else
    v7 = 1;
  if (v7)
    return 4294967294;
  else
    return EC_GROUP_cmp(*v2, v6, 0) == 0;
}

void int_ec_free(uint64_t a1)
{
  EC_KEY_free(*(EC_KEY **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
}

uint64_t pkey_ed25519_copy()
{
  return 1;
}

uint64_t pkey_ed25519_keygen(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _OWORD *v5;
  uint64_t v6;
  void (*v7)(uint64_t);
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;
  _BYTE v13[32];
  _OWORD data[2];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v3 = malloc_type_malloc(0x49uLL, 0x30772F57uLL);
  if (v3)
  {
    v4 = v3;
    *v3 = 65;
    v5 = v3 + 1;
    v6 = *(_QWORD *)(a2 + 16);
    if (v6)
    {
      v7 = *(void (**)(uint64_t))(v6 + 160);
      if (v7)
      {
        v7(a2);
        *(_QWORD *)(a2 + 8) = 0;
      }
    }
    *(_QWORD *)(a2 + 16) = &ed25519_asn1_meth;
    *(_DWORD *)(a2 + 4) = 949;
    RAND_bytes_with_additional_data((uint64_t)data, 0x20uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
    ED25519_keypair_from_seed((uint64_t)v13, v5, data);
    *((_BYTE *)v4 + 72) = 1;
    v8 = *(_QWORD *)(a2 + 8);
    if (v8)
    {
      v10 = *(_QWORD *)(v8 - 8);
      v9 = (void *)(v8 - 8);
      v11 = v10 + 8;
      if (v10 != -8)
        bzero(v9, v11);
      free(v9);
    }
    *(_QWORD *)(a2 + 8) = v5;
    return 1;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
}

uint64_t pkey_ed25519_sign_message(uint64_t a1, _BYTE *a2, _QWORD *a3, const void *a4, size_t a5)
{
  char *v5;
  int v7;
  int v8;
  uint64_t result;

  v5 = *(char **)(*(_QWORD *)(a1 + 16) + 8);
  if (!v5[64])
  {
    v7 = 130;
    v8 = 49;
    goto LABEL_6;
  }
  if (!a2)
    goto LABEL_9;
  if (*a3 <= 0x3FuLL)
  {
    v7 = 100;
    v8 = 59;
LABEL_6:
    ERR_put_error(6, 0, v7, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ed25519.c", v8);
    return 0;
  }
  result = ED25519_sign(a2, a4, a5, v5);
  if ((_DWORD)result)
  {
LABEL_9:
    *a3 = 64;
    return 1;
  }
  return result;
}

uint64_t pkey_ed25519_verify_message(uint64_t a1, int8x16_t *a2, uint64_t a3, const void *a4, size_t a5)
{
  if (a3 == 64 && ED25519_verify(a4, a5, a2, (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8) + 32)))
    return 1;
  ERR_put_error(6, 0, 131, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ed25519.c", 77);
  return 0;
}

uint64_t ed25519_pub_decode(uint64_t a1, uint64_t a2, __int128 **a3)
{
  __int128 *v5;
  char *v6;
  char *v7;
  __int128 v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  size_t v12;

  if (*(_QWORD *)(a2 + 8))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ed25519_asn1.c", 119);
    return 0;
  }
  else if (a3[1] == (__int128 *)32)
  {
    v5 = *a3;
    v6 = (char *)malloc_type_malloc(0x49uLL, 0x30772F57uLL);
    if (v6)
    {
      *(_QWORD *)v6 = 65;
      v7 = v6 + 8;
      v8 = *v5;
      *(_OWORD *)(v6 + 56) = v5[1];
      *(_OWORD *)(v6 + 40) = v8;
      v6[72] = 0;
      v9 = *(_QWORD *)(a1 + 8);
      if (v9)
      {
        v11 = *(_QWORD *)(v9 - 8);
        v10 = (void *)(v9 - 8);
        v12 = v11 + 8;
        if (v11 != -8)
          bzero(v10, v12);
        free(v10);
      }
      *(_QWORD *)(a1 + 8) = v7;
      return 1;
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ed25519_asn1.c", 55);
    return 0;
  }
}

uint64_t ed25519_pub_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  __int128 v6;
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];
  _OWORD v11[3];
  _BYTE *v12;

  v3 = *(_QWORD *)(a2 + 8);
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  if (CBB_flush(a1))
  {
    v12 = 0;
    if (CBB_add_space((uint64_t)a1, &v12, 1))
    {
      *v12 = 48;
      if (cbb_add_child((uint64_t)a1, (uint64_t)v11, 1u, 1))
      {
        if (CBB_flush((uint64_t *)v11))
        {
          v12 = 0;
          if (CBB_add_space((uint64_t)v11, &v12, 1))
          {
            *v12 = 48;
            if (cbb_add_child((uint64_t)v11, (uint64_t)v10, 1u, 1))
            {
              if (CBB_flush((uint64_t *)v10))
              {
                v12 = 0;
                if (CBB_add_space((uint64_t)v10, &v12, 1))
                {
                  *v12 = 6;
                  if (cbb_add_child((uint64_t)v10, (uint64_t)v9, 1u, 1))
                  {
                    v12 = 0;
                    if (CBB_add_space((uint64_t)v9, &v12, 3))
                    {
                      v4 = v12;
                      *(_WORD *)v12 = 25899;
                      v4[2] = 112;
                      if (CBB_flush((uint64_t *)v11))
                      {
                        v12 = 0;
                        if (CBB_add_space((uint64_t)v11, &v12, 1))
                        {
                          *v12 = 3;
                          if (cbb_add_child((uint64_t)v11, (uint64_t)v8, 1u, 1))
                          {
                            v12 = 0;
                            if (CBB_add_space((uint64_t)v8, &v12, 1))
                            {
                              *v12 = 0;
                              v12 = 0;
                              if (CBB_add_space((uint64_t)v8, &v12, 32))
                              {
                                v5 = v12;
                                v6 = *(_OWORD *)(v3 + 48);
                                *(_OWORD *)v12 = *(_OWORD *)(v3 + 32);
                                *((_OWORD *)v5 + 1) = v6;
                                if (CBB_flush(a1))
                                  return 1;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ed25519_asn1.c", 140);
  return 0;
}

BOOL ed25519_pub_cmp(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = *(_QWORD **)(a2 + 8);
  v4 = v2[4];
  v5 = v2[5];
  v6 = v3[4];
  v7 = v3[5];
  v9 = v2[6];
  v8 = v2[7];
  v11 = v3[6];
  v10 = v3[7];
  return v4 == v6 && v5 == v7 && v9 == v11 && v8 == v10;
}

uint64_t ed25519_priv_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const char *v3;
  int v4;
  int v5;
  int v6;
  uint64_t v10;
  _OWORD *v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  size_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t v22[5];

  v22[4] = *MEMORY[0x24BDAC8D0];
  v19 = 0;
  v20 = 0;
  if (*(_QWORD *)(a2 + 8)
    || (v22[0] = 0,
        v21 = 0,
        !cbs_get_any_asn1_element((unsigned __int8 **)a3, &v19, &v21, v22, 0, 0, 0))
    || v21 != 4
    || (v10 = v20 - v22[0], v20 < v22[0])
    || (v11 = (_OWORD *)(v19 + v22[0]), v19 += v22[0], v20 -= v22[0], *(_QWORD *)(a3 + 8)))
  {
    v3 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cr"
         "ypto/evp/p_ed25519_asn1.c";
    v4 = 6;
    v5 = 102;
    v6 = 163;
LABEL_3:
    ERR_put_error(v4, 0, v5, v3, v6);
    return 0;
  }
  if (v10 != 32)
  {
    v3 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cr"
         "ypto/evp/p_ed25519_asn1.c";
    v4 = 6;
    v5 = 102;
    v6 = 33;
    goto LABEL_3;
  }
  v12 = (char *)malloc_type_malloc(0x49uLL, 0x30772F57uLL);
  if (!v12)
  {
    v3 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v4 = 14;
    v5 = 65;
    v6 = 247;
    goto LABEL_3;
  }
  v13 = v12;
  *(_QWORD *)v12 = 65;
  v14 = v12 + 8;
  ED25519_keypair_from_seed((uint64_t)v22, v12 + 8, v11);
  v13[72] = 1;
  v15 = *(_QWORD *)(a1 + 8);
  if (v15)
  {
    v17 = *(_QWORD *)(v15 - 8);
    v16 = (void *)(v15 - 8);
    v18 = v17 + 8;
    if (v17 != -8)
      bzero(v16, v18);
    free(v16);
  }
  *(_QWORD *)(a1 + 8) = v14;
  return 1;
}

uint64_t ed25519_priv_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE *v4;
  _BYTE *v5;
  __int128 v6;
  int v8;
  int v9;
  _OWORD v10[3];
  _OWORD v11[3];
  _OWORD v12[3];
  _OWORD v13[3];
  _OWORD v14[3];
  _BYTE *v15;

  v2 = *(_QWORD *)(a2 + 8);
  if (*(_BYTE *)(v2 + 64))
  {
    memset(v14, 0, sizeof(v14));
    memset(v13, 0, sizeof(v13));
    memset(v12, 0, sizeof(v12));
    memset(v11, 0, sizeof(v11));
    memset(v10, 0, sizeof(v10));
    if (CBB_flush(a1))
    {
      v15 = 0;
      if (CBB_add_space((uint64_t)a1, &v15, 1))
      {
        *v15 = 48;
        if (cbb_add_child((uint64_t)a1, (uint64_t)v14, 1u, 1))
        {
          if (CBB_add_asn1_uint64_with_tag((uint64_t)v14, 0, 2))
          {
            if (CBB_flush((uint64_t *)v14))
            {
              v15 = 0;
              if (CBB_add_space((uint64_t)v14, &v15, 1))
              {
                *v15 = 48;
                if (cbb_add_child((uint64_t)v14, (uint64_t)v13, 1u, 1))
                {
                  if (CBB_flush((uint64_t *)v13))
                  {
                    v15 = 0;
                    if (CBB_add_space((uint64_t)v13, &v15, 1))
                    {
                      *v15 = 6;
                      if (cbb_add_child((uint64_t)v13, (uint64_t)v12, 1u, 1))
                      {
                        v15 = 0;
                        if (CBB_add_space((uint64_t)v12, &v15, 3))
                        {
                          v4 = v15;
                          *(_WORD *)v15 = 25899;
                          v4[2] = 112;
                          if (CBB_flush((uint64_t *)v14))
                          {
                            v15 = 0;
                            if (CBB_add_space((uint64_t)v14, &v15, 1))
                            {
                              *v15 = 4;
                              if (cbb_add_child((uint64_t)v14, (uint64_t)v11, 1u, 1))
                              {
                                if (CBB_flush((uint64_t *)v11))
                                {
                                  v15 = 0;
                                  if (CBB_add_space((uint64_t)v11, &v15, 1))
                                  {
                                    *v15 = 4;
                                    if (cbb_add_child((uint64_t)v11, (uint64_t)v10, 1u, 1))
                                    {
                                      v15 = 0;
                                      if (CBB_add_space((uint64_t)v10, &v15, 32))
                                      {
                                        v5 = v15;
                                        v6 = *(_OWORD *)(v2 + 16);
                                        *(_OWORD *)v15 = *(_OWORD *)v2;
                                        *((_OWORD *)v5 + 1) = v6;
                                        if (CBB_flush(a1))
                                          return 1;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v8 = 105;
    v9 = 190;
  }
  else
  {
    v8 = 130;
    v9 = 173;
  }
  ERR_put_error(6, 0, v8, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ed25519_asn1.c", v9);
  return 0;
}

uint64_t ed25519_set_priv_raw(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;
  const char *v13;
  int v14;
  int v15;
  int v16;
  _BYTE v17[32];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (a3 != 32)
  {
    v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/evp/p_ed25519_asn1.c";
    v14 = 6;
    v15 = 102;
    v16 = 33;
LABEL_10:
    ERR_put_error(v14, 0, v15, v13, v16);
    return 0;
  }
  v5 = (char *)malloc_type_malloc(0x49uLL, 0x30772F57uLL);
  if (!v5)
  {
    v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v14 = 14;
    v15 = 65;
    v16 = 247;
    goto LABEL_10;
  }
  v6 = v5;
  *(_QWORD *)v5 = 65;
  v7 = v5 + 8;
  ED25519_keypair_from_seed((uint64_t)v17, v5 + 8, a2);
  v6[72] = 1;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v10 = *(_QWORD *)(v8 - 8);
    v9 = (void *)(v8 - 8);
    v11 = v10 + 8;
    if (v10 != -8)
      bzero(v9, v11);
    free(v9);
  }
  *(_QWORD *)(a1 + 8) = v7;
  return 1;
}

uint64_t ed25519_set_pub_raw(uint64_t a1, __int128 *a2, uint64_t a3)
{
  char *v5;
  char *v6;
  __int128 v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;

  if (a3 == 32)
  {
    v5 = (char *)malloc_type_malloc(0x49uLL, 0x30772F57uLL);
    if (v5)
    {
      *(_QWORD *)v5 = 65;
      v6 = v5 + 8;
      v7 = *a2;
      *(_OWORD *)(v5 + 56) = a2[1];
      *(_OWORD *)(v5 + 40) = v7;
      v5[72] = 0;
      v8 = *(_QWORD *)(a1 + 8);
      if (v8)
      {
        v10 = *(_QWORD *)(v8 - 8);
        v9 = (void *)(v8 - 8);
        v11 = v10 + 8;
        if (v10 != -8)
          bzero(v9, v11);
        free(v9);
      }
      *(_QWORD *)(a1 + 8) = v6;
      return 1;
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ed25519_asn1.c", 55);
    return 0;
  }
}

uint64_t ed25519_get_priv_raw(uint64_t a1, _OWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  __int128 v5;

  v3 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v3 + 64))
  {
    if (a2)
    {
      if (*a3 <= 0x1FuLL)
      {
        ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ed25519_asn1.c", 86);
        return 0;
      }
      v5 = *(_OWORD *)(v3 + 16);
      *a2 = *(_OWORD *)v3;
      a2[1] = v5;
    }
    *a3 = 32;
    return 1;
  }
  else
  {
    ERR_put_error(6, 0, 130, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ed25519_asn1.c", 76);
    return 0;
  }
}

uint64_t ed25519_get_pub_raw(uint64_t a1, _OWORD *a2, _QWORD *a3)
{
  uint64_t v4;
  __int128 v5;

  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ed25519_asn1.c", 105);
      return 0;
    }
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(_OWORD *)(v4 + 48);
    *a2 = *(_OWORD *)(v4 + 32);
    a2[1] = v5;
  }
  *a3 = 32;
  return 1;
}

uint64_t ed25519_size()
{
  return 64;
}

uint64_t ed25519_bits()
{
  return 253;
}

void ed25519_free(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  size_t v5;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v4 = *(_QWORD *)(v2 - 8);
    v3 = (void *)(v2 - 8);
    v5 = v4 + 8;
    if (v4 != -8)
      bzero(v3, v5);
    free(v3);
  }
  *(_QWORD *)(a1 + 8) = 0;
}

uint64_t pkey_rsa_init(uint64_t a1)
{
  char *v2;

  v2 = (char *)malloc_type_malloc(0x50uLL, 0x30772F57uLL);
  if (v2)
  {
    *(_QWORD *)v2 = 72;
    *(_OWORD *)(v2 + 12) = 0u;
    *(_OWORD *)(v2 + 44) = 0u;
    *(_OWORD *)(v2 + 28) = 0u;
    *(_OWORD *)(v2 + 60) = 0u;
    *((_DWORD *)v2 + 2) = 2048;
    *((_DWORD *)v2 + 19) = 0;
    *((_DWORD *)v2 + 6) = 1;
    *((_DWORD *)v2 + 12) = -2;
    *(_QWORD *)(a1 + 40) = v2 + 8;
    return 1;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
}

uint64_t pkey_rsa_copy(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  const BIGNUM *v7;
  uint64_t result;
  const void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  size_t v13;
  size_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;

  v4 = (char *)malloc_type_malloc(0x50uLL, 0x30772F57uLL);
  if (!v4)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v5 = v4;
  *(_QWORD *)v4 = 72;
  *(_OWORD *)(v4 + 12) = 0u;
  *(_OWORD *)(v4 + 44) = 0u;
  *(_OWORD *)(v4 + 28) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  *((_DWORD *)v4 + 19) = 0;
  *((_DWORD *)v4 + 2) = 2048;
  *((_DWORD *)v4 + 6) = 1;
  *((_DWORD *)v4 + 12) = -2;
  *(_QWORD *)(a1 + 40) = v4 + 8;
  v6 = *(_QWORD *)(a2 + 40);
  *((_DWORD *)v4 + 2) = *(_DWORD *)v6;
  v7 = *(const BIGNUM **)(v6 + 8);
  if (!v7 || (result = (uint64_t)BN_dup(v7), (*((_QWORD *)v5 + 2) = result) != 0))
  {
    *((_DWORD *)v5 + 6) = *(_DWORD *)(v6 + 16);
    *((_OWORD *)v5 + 2) = *(_OWORD *)(v6 + 24);
    *((_DWORD *)v5 + 12) = *(_DWORD *)(v6 + 40);
    v9 = *(const void **)(v6 + 56);
    if (v9)
    {
      v10 = *((_QWORD *)v5 + 8);
      if (v10)
      {
        v12 = *(_QWORD *)(v10 - 8);
        v11 = (void *)(v10 - 8);
        v13 = v12 + 8;
        if (v12 != -8)
          bzero(v11, v13);
        free(v11);
        v9 = *(const void **)(v6 + 56);
      }
      v14 = *(_QWORD *)(v6 + 64);
      if (v14)
      {
        if (v14 <= 0xFFFFFFFFFFFFFFF7)
        {
          v15 = malloc_type_malloc(v14 + 8, 0x30772F57uLL);
          if (v15)
          {
            *v15 = v14;
            v16 = v15 + 1;
            memcpy(v15 + 1, v9, v14);
            v17 = *(_QWORD *)(v6 + 64);
            *((_QWORD *)v5 + 8) = v16;
            *((_QWORD *)v5 + 9) = v17;
            return 1;
          }
        }
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      }
      result = 0;
      *((_QWORD *)v5 + 8) = 0;
      return result;
    }
    return 1;
  }
  return result;
}

void pkey_rsa_cleanup(uint64_t a1)
{
  _QWORD *v1;
  uint64_t *v2;
  int v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  size_t v12;
  uint64_t *v13;
  uint64_t v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  size_t v18;
  void *v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;

  v1 = *(_QWORD **)(a1 + 40);
  if (v1)
  {
    v2 = (uint64_t *)v1[1];
    if (v2)
    {
      v3 = *((_DWORD *)v2 + 5);
      if ((v3 & 2) == 0)
      {
        v4 = *v2;
        if (*v2)
        {
          v6 = *(_QWORD *)(v4 - 8);
          v5 = (void *)(v4 - 8);
          v7 = v6 + 8;
          if (v6 != -8)
            bzero(v5, v7);
          free(v5);
          v3 = *((_DWORD *)v2 + 5);
        }
      }
      if ((v3 & 1) != 0)
      {
        v14 = *(v2 - 1);
        v13 = v2 - 1;
        v15 = v14 + 8;
        if (v14 != -8)
          bzero(v13, v15);
        free(v13);
        v8 = v1[6];
        if (!v8)
        {
LABEL_11:
          v9 = v1[7];
          if (!v9)
            goto LABEL_12;
          goto LABEL_22;
        }
LABEL_19:
        v17 = *(_QWORD *)(v8 - 8);
        v16 = (void *)(v8 - 8);
        v18 = v17 + 8;
        if (v17 != -8)
          bzero(v16, v18);
        free(v16);
        v9 = v1[7];
        if (!v9)
        {
LABEL_12:
          v11 = *(v1 - 1);
          v10 = v1 - 1;
          v12 = v11 + 8;
          if (v11 == -8)
          {
LABEL_14:
            free(v10);
            return;
          }
LABEL_13:
          bzero(v10, v12);
          goto LABEL_14;
        }
LABEL_22:
        v20 = *(_QWORD *)(v9 - 8);
        v19 = (void *)(v9 - 8);
        v21 = v20 + 8;
        if (v20 != -8)
          bzero(v19, v21);
        free(v19);
        v22 = *(v1 - 1);
        v10 = v1 - 1;
        v12 = v22 + 8;
        if (v22 == -8)
          goto LABEL_14;
        goto LABEL_13;
      }
      *v2 = 0;
    }
    v8 = v1[6];
    if (!v8)
      goto LABEL_11;
    goto LABEL_19;
  }
}

uint64_t pkey_rsa_keygen(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  RSA *v5;
  uint64_t v6;
  void (*v7)(uint64_t);
  _QWORD *v8;
  BIGNUM *v9;

  v3 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(v3 + 8))
    goto LABEL_2;
  v8 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v8)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    result = 0;
    *(_QWORD *)(v3 + 8) = 0;
    return result;
  }
  *v8 = 24;
  v8[2] = 0;
  v8[3] = 0x100000000;
  v8[1] = 0;
  v9 = (BIGNUM *)(v8 + 1);
  *(_QWORD *)(v3 + 8) = v9;
  result = BN_set_word(v9, 0x10001uLL);
  if ((_DWORD)result)
  {
LABEL_2:
    result = (uint64_t)RSA_new_method(0);
    if (result)
    {
      v5 = (RSA *)result;
      if (RSA_generate_key_ex_maybe_fips(result, *(_DWORD *)v3, *(_QWORD *)(v3 + 8), 0, 0))
      {
        v6 = *(_QWORD *)(a2 + 16);
        if (v6)
        {
          v7 = *(void (**)(uint64_t))(v6 + 160);
          if (v7)
            v7(a2);
        }
        *(_DWORD *)(a2 + 4) = 6;
        *(_QWORD *)(a2 + 8) = v5;
        *(_QWORD *)(a2 + 16) = &rsa_asn1_meth;
        return 1;
      }
      else
      {
        RSA_free(v5);
        return 0;
      }
    }
  }
  return result;
}

uint64_t pkey_rsa_sign(uint64_t a1, char *a2, unint64_t *a3, const void *a4, size_t a5)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  unint64_t v13;
  uint64_t result;
  unsigned int *v15;
  int v16;
  uint64_t (*v17)(uint64_t **, unint64_t *, char *);
  unsigned int v18;

  v9 = *(_QWORD *)(a1 + 40);
  v10 = *(_QWORD *)(a1 + 16);
  v12 = *(uint64_t ***)(v10 + 8);
  v11 = *(_QWORD *)(v10 + 16);
  if (v11)
  {
    v11 = *(_QWORD *)(v11 + 120);
    if (v11)
      v11 = ((int (*)(void))v11)();
  }
  if (!a2)
    goto LABEL_13;
  v13 = *a3;
  if (*a3 < v11)
  {
    ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa.c", 181);
    return 0;
  }
  v15 = *(unsigned int **)(v9 + 24);
  if (v15)
  {
    v18 = 0;
    v16 = *(_DWORD *)(v9 + 16);
    if (v16 == 6)
      return RSA_sign_pss_mgf1(v12, a3, a2, v13, (uint64_t)a4, a5, (uint64_t)v15, *(const EVP_MD **)(v9 + 32), *(_DWORD *)(v9 + 40));
    result = 0;
    if (v16 == 1)
    {
      result = rsa_sign_no_self_test(*v15, a4, a5, a2, &v18, v12);
      if ((_DWORD)result)
      {
        v11 = v18;
LABEL_13:
        *a3 = v11;
        return 1;
      }
    }
  }
  else
  {
    v17 = (uint64_t (*)(uint64_t **, unint64_t *, char *))(*v12)[6];
    if (v17)
      return v17(v12, a3, a2);
    else
      return rsa_default_sign_raw(v12, a3, a2, v13, a4, a5, *(_DWORD *)(v9 + 16));
  }
  return result;
}

uint64_t pkey_rsa_verify(uint64_t a1, const unsigned __int8 *a2, const unsigned __int8 *a3, int8x16_t *a4, size_t a5)
{
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  const EVP_MD *v13;
  int v14;
  uint64_t result;
  uint64_t v16;
  int (*v17)(void);
  unint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(void);
  signed int v23;
  uint64_t v24;
  _QWORD *v25;
  BOOL v26;
  int8x16_t *v27;
  unint64_t v28;
  unsigned __int8 v29;
  int8x16_t *v30;
  int8x16_t *v31;
  int8x16_t v32;
  unint64_t v33;
  int8x16_t v34;
  int8x16_t v35;
  unint64_t v36;
  unint64_t v37;
  int8x8_t v38;
  int8x8_t *v39;
  int8x8_t *v40;
  unint64_t v41;
  int8x8_t v42;
  int8x8_t v43;
  int8x8_t v44;
  uint64_t v45;
  size_t v46;
  __int8 *v47;
  __int8 *v48;
  char v49;
  char v50;
  char v51;
  const unsigned __int8 *v52;

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16);
  v12 = *(_QWORD **)(v11 + 8);
  v13 = *(const EVP_MD **)(v10 + 24);
  if (v13)
  {
    v14 = *(_DWORD *)(v10 + 16);
    if (v14 == 6)
      return RSA_verify_pss_mgf1(*(uint64_t ***)(v11 + 8), (uint64_t)a4, a5, v13, *(const EVP_MD **)(v10 + 32), *(_DWORD *)(v10 + 40), a2, a3);
    if (v14 == 1)
      return rsa_verify_no_self_test(v13->type, a4, a5, a2, a3, v12);
    return 0;
  }
  v52 = 0;
  v16 = *(_QWORD *)(v11 + 16);
  if (v16 && (v17 = *(int (**)(void))(v16 + 120)) != 0)
  {
    v18 = v17();
    v19 = *(unsigned __int8 **)(v10 + 48);
    if (v19)
      goto LABEL_19;
  }
  else
  {
    v18 = 0;
    v19 = *(unsigned __int8 **)(v10 + 48);
    if (v19)
      goto LABEL_19;
  }
  v20 = *(_QWORD *)(a1 + 16);
  if (v20 && (v21 = *(_QWORD *)(v20 + 16)) != 0 && (v22 = *(uint64_t (**)(void))(v21 + 120)) != 0)
  {
    v23 = v22();
    if (v23 > 0xFFFFFFF7)
      goto LABEL_15;
    v24 = v23;
    v25 = malloc_type_malloc(v23 + 8, 0x30772F57uLL);
    if (!v25)
      goto LABEL_15;
  }
  else
  {
    v24 = 0;
    v25 = malloc_type_malloc(8uLL, 0x30772F57uLL);
    if (!v25)
    {
LABEL_15:
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      result = 0;
      *(_QWORD *)(v10 + 48) = 0;
      return result;
    }
  }
  *v25 = v24;
  v19 = (unsigned __int8 *)(v25 + 1);
  *(_QWORD *)(v10 + 48) = v25 + 1;
LABEL_19:
  if (rsa_verify_raw_no_self_test((uint64_t)v12, &v52, v19, v18, a2, a3, *(_DWORD *)(v10 + 16)))
    v26 = v52 == (const unsigned __int8 *)a5;
  else
    v26 = 0;
  if (!v26)
    return 0;
  if (!a5)
    return 1;
  v27 = *(int8x16_t **)(v10 + 48);
  if (a5 >= 8)
  {
    if (a5 >= 0x20)
    {
      v28 = a5 & 0xFFFFFFFFFFFFFFE0;
      v30 = a4 + 1;
      v31 = v27 + 1;
      v32 = 0uLL;
      v33 = a5 & 0xFFFFFFFFFFFFFFE0;
      v34 = 0uLL;
      do
      {
        v32 = vorrq_s8(veorq_s8(v31[-1], v30[-1]), v32);
        v34 = vorrq_s8(veorq_s8(*v31, *v30), v34);
        v30 += 2;
        v31 += 2;
        v33 -= 32;
      }
      while (v33);
      v35 = vorrq_s8(v34, v32);
      *(int8x8_t *)v35.i8 = vorr_s8(*(int8x8_t *)v35.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL));
      v36 = v35.i64[0] | HIDWORD(v35.i64[0]) | ((unint64_t)(v35.i64[0] | HIDWORD(v35.i64[0])) >> 16);
      v29 = v36 | BYTE1(v36);
      if (v28 == a5)
        return v29 == 0;
      if ((a5 & 0x18) == 0)
        goto LABEL_37;
    }
    else
    {
      v29 = 0;
      v28 = 0;
    }
    v37 = v28;
    v28 = a5 & 0xFFFFFFFFFFFFFFF8;
    v38 = (int8x8_t)v29;
    v39 = (int8x8_t *)&a4->i8[v37];
    v40 = (int8x8_t *)&v27->i8[v37];
    v41 = v37 - (a5 & 0xFFFFFFFFFFFFFFF8);
    do
    {
      v42 = *v39++;
      v43 = v42;
      v44 = *v40++;
      v38 = vorr_s8(veor_s8(v44, v43), v38);
      v41 += 8;
    }
    while (v41);
    v45 = *(_QWORD *)&v38 | HIDWORD(*(_QWORD *)&v38) | ((*(_QWORD *)&v38 | HIDWORD(*(_QWORD *)&v38)) >> 16);
    v29 = v45 | BYTE1(v45);
    if (v28 == a5)
      return v29 == 0;
    goto LABEL_37;
  }
  v28 = 0;
  v29 = 0;
LABEL_37:
  v46 = a5 - v28;
  v47 = &v27->i8[v28];
  v48 = &a4->i8[v28];
  do
  {
    v50 = *v48++;
    v49 = v50;
    v51 = *v47++;
    v29 |= v51 ^ v49;
    --v46;
  }
  while (v46);
  return v29 == 0;
}

uint64_t pkey_rsa_verify_recover(uint64_t a1, unsigned __int8 *a2, const unsigned __int8 **a3, const unsigned __int8 *a4, const unsigned __int8 *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int (*v14)(void);
  unint64_t v15;
  uint64_t result;
  uint64_t v17;
  int v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(void);
  unsigned int v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;
  int8x16_t *v27;
  unint64_t v28;
  unsigned __int8 v29;
  int8x16_t *v30;
  int8x16_t *v31;
  int8x16_t v32;
  unint64_t v33;
  int8x16_t v34;
  int8x16_t v35;
  unint64_t v36;
  unint64_t v37;
  int8x8_t v38;
  int8x8_t *v39;
  int8x8_t *v40;
  unint64_t v41;
  int8x8_t v42;
  int8x8_t v43;
  int8x8_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  __int8 *v48;
  char v49;
  char v50;
  char v51;
  char v53;
  uint64_t v54;
  char *v55;
  const unsigned __int8 *v56;
  int v57;
  const unsigned __int8 *v58;
  void *v59;

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16);
  v13 = *(_QWORD *)(v11 + 8);
  v12 = *(_QWORD *)(v11 + 16);
  if (v12 && (v14 = *(int (**)(void))(v12 + 120)) != 0)
  {
    v15 = v14();
    if (!a2)
    {
LABEL_4:
      *a3 = (const unsigned __int8 *)v15;
      return 1;
    }
  }
  else
  {
    v15 = 0;
    if (!a2)
      goto LABEL_4;
  }
  if ((unint64_t)*a3 >= v15)
  {
    v17 = *(_QWORD *)(v10 + 24);
    v18 = *(_DWORD *)(v10 + 16);
    if (!v17)
      return rsa_verify_raw_no_self_test(v13, a3, a2, (unint64_t)*a3, a4, a5, v18);
    if (v18 != 1)
      return 0;
    v19 = *(unsigned int *)(v17 + 4);
    v58 = 0;
    v59 = 0;
    v57 = 0;
    if (*(_QWORD *)(v10 + 48))
    {
LABEL_21:
      result = RSA_add_pkcs1_prefix(&v59, (size_t *)&v58, &v57, *(_DWORD *)v17, pkey_rsa_verify_recover_kDummyHash, v19);
      if (!(_DWORD)result)
        return result;
      v56 = 0;
      if (!rsa_verify_raw_no_self_test(v13, &v56, *(unsigned __int8 **)(v10 + 48), v15, a4, a5, 1)
        || v56 != v58)
      {
LABEL_41:
        v53 = 1;
        if (!v57)
          goto LABEL_48;
        goto LABEL_44;
      }
      v26 = (unint64_t)&v56[-v19];
      if (v56 == (const unsigned __int8 *)v19)
      {
LABEL_43:
        v53 = 0;
        if (!v57)
          goto LABEL_48;
LABEL_44:
        if (v59)
        {
          v55 = (char *)v59 - 8;
          v54 = *((_QWORD *)v59 - 1);
          if (v54 != -8)
            bzero(v55, v54 + 8);
          free(v55);
        }
LABEL_48:
        if ((v53 & 1) == 0)
        {
          if ((_DWORD)v19)
            memcpy(a2, &v56[*(_QWORD *)(v10 + 48) - v19], v19);
          *a3 = (const unsigned __int8 *)v19;
          return 1;
        }
        return 0;
      }
      v27 = *(int8x16_t **)(v10 + 48);
      if (v26 < 8)
      {
        v28 = 0;
        v29 = 0;
        goto LABEL_37;
      }
      if (v26 >= 0x20)
      {
        v28 = v26 & 0xFFFFFFFFFFFFFFE0;
        v30 = v27 + 1;
        v31 = (int8x16_t *)((char *)v59 + 16);
        v32 = 0uLL;
        v33 = v26 & 0xFFFFFFFFFFFFFFE0;
        v34 = 0uLL;
        do
        {
          v32 = vorrq_s8(veorq_s8(v31[-1], v30[-1]), v32);
          v34 = vorrq_s8(veorq_s8(*v31, *v30), v34);
          v30 += 2;
          v31 += 2;
          v33 -= 32;
        }
        while (v33);
        v35 = vorrq_s8(v34, v32);
        *(int8x8_t *)v35.i8 = vorr_s8(*(int8x8_t *)v35.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL));
        v36 = v35.i64[0] | HIDWORD(v35.i64[0]) | ((unint64_t)(v35.i64[0] | HIDWORD(v35.i64[0])) >> 16);
        v29 = v36 | BYTE1(v36);
        if (v26 == v28)
          goto LABEL_40;
        if ((v26 & 0x18) == 0)
        {
LABEL_37:
          v46 = v28 + v19 - (_QWORD)v56;
          v47 = (char *)v59 + v28;
          v48 = &v27->i8[v28];
          do
          {
            v50 = *v48++;
            v49 = v50;
            v51 = *v47++;
            v29 |= v51 ^ v49;
          }
          while (!__CFADD__(v46++, 1));
          goto LABEL_40;
        }
      }
      else
      {
        v29 = 0;
        v28 = 0;
      }
      v37 = v28;
      v28 = v26 & 0xFFFFFFFFFFFFFFF8;
      v38 = (int8x8_t)v29;
      v39 = (int8x8_t *)&v27->i8[v37];
      v40 = (int8x8_t *)((char *)v59 + v37);
      v41 = v37 - (v26 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        v42 = *v39++;
        v43 = v42;
        v44 = *v40++;
        v38 = vorr_s8(veor_s8(v44, v43), v38);
        v41 += 8;
      }
      while (v41);
      v45 = *(_QWORD *)&v38 | HIDWORD(*(_QWORD *)&v38) | ((*(_QWORD *)&v38 | HIDWORD(*(_QWORD *)&v38)) >> 16);
      v29 = v45 | BYTE1(v45);
      if (v26 != v28)
        goto LABEL_37;
LABEL_40:
      if (v29)
        goto LABEL_41;
      goto LABEL_43;
    }
    v20 = *(_QWORD *)(a1 + 16);
    if (v20 && (v21 = *(_QWORD *)(v20 + 16)) != 0 && (v22 = *(uint64_t (**)(void))(v21 + 120)) != 0)
    {
      v23 = v22();
      if (v23 > 0xFFFFFFF7)
        goto LABEL_27;
      v24 = (int)v23;
    }
    else
    {
      v24 = 0;
    }
    v25 = malloc_type_malloc(v24 + 8, 0x30772F57uLL);
    if (v25)
    {
      *v25 = v24;
      *(_QWORD *)(v10 + 48) = v25 + 1;
      v17 = *(_QWORD *)(v10 + 24);
      goto LABEL_21;
    }
LABEL_27:
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    result = 0;
    *(_QWORD *)(v10 + 48) = 0;
    return result;
  }
  ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa.c", 253);
  return 0;
}

uint64_t pkey_rsa_encrypt(uint64_t a1, char *a2, unint64_t *a3, const void *a4, size_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int (*v14)(void);
  unint64_t v15;
  uint64_t result;
  int v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(void);
  unsigned int v22;
  uint64_t v23;
  _QWORD *v24;

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16);
  v13 = *(_QWORD *)(v11 + 8);
  v12 = *(_QWORD *)(v11 + 16);
  if (v12 && (v14 = *(int (**)(void))(v12 + 120)) != 0)
  {
    v15 = v14();
    if (!a2)
    {
LABEL_4:
      *a3 = v15;
      return 1;
    }
  }
  else
  {
    v15 = 0;
    if (!a2)
      goto LABEL_4;
  }
  if (*a3 < v15)
  {
    ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa.c", 317);
    return 0;
  }
  v17 = *(_DWORD *)(v10 + 16);
  if (v17 != 4)
    return RSA_encrypt(v13, a3, a2, *a3, a4, a5, v17);
  v18 = *(_BYTE **)(v10 + 48);
  if (!v18)
  {
    v19 = *(_QWORD *)(a1 + 16);
    if (v19 && (v20 = *(_QWORD *)(v19 + 16)) != 0 && (v21 = *(uint64_t (**)(void))(v20 + 120)) != 0)
    {
      v22 = v21();
      if (v22 > 0xFFFFFFF7)
        goto LABEL_22;
      v23 = (int)v22;
    }
    else
    {
      v23 = 0;
    }
    v24 = malloc_type_malloc(v23 + 8, 0x30772F57uLL);
    if (v24)
    {
      *v24 = v23;
      v18 = v24 + 1;
      *(_QWORD *)(v10 + 48) = v18;
      goto LABEL_20;
    }
LABEL_22:
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    result = 0;
    *(_QWORD *)(v10 + 48) = 0;
    return result;
  }
LABEL_20:
  result = RSA_padding_add_PKCS1_OAEP_mgf1(v18, v15, a4, a5, *(void **)(v10 + 56), *(_QWORD *)(v10 + 64), *(EVP_MD **)(v10 + 24), *(EVP_MD **)(v10 + 32));
  if ((_DWORD)result)
    return RSA_encrypt(v13, a3, a2, *a3, *(const void **)(v10 + 48), v15, 3) != 0;
  return result;
}

uint64_t pkey_rsa_decrypt(uint64_t a1, unsigned __int8 *a2, unint64_t *a3, const unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t **v13;
  int (*v14)(void);
  unint64_t v15;
  uint64_t result;
  uint64_t v17;
  unsigned __int8 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(void);
  unsigned int v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16);
  v13 = *(uint64_t ***)(v11 + 8);
  v12 = *(_QWORD *)(v11 + 16);
  if (v12 && (v14 = *(int (**)(void))(v12 + 120)) != 0)
  {
    v15 = v14();
    if (!a2)
    {
LABEL_4:
      *a3 = v15;
      return 1;
    }
  }
  else
  {
    v15 = 0;
    if (!a2)
      goto LABEL_4;
  }
  if (*a3 < v15)
  {
    ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa.c", 349);
    return 0;
  }
  v17 = *(unsigned int *)(v10 + 16);
  if ((_DWORD)v17 != 4)
    return RSA_decrypt(v13, a3, a2, v15, a4, a5, v17);
  v25 = 0;
  v18 = *(unsigned __int8 **)(v10 + 48);
  if (v18)
    goto LABEL_19;
  v19 = *(_QWORD *)(a1 + 16);
  if (v19 && (v20 = *(_QWORD *)(v19 + 16)) != 0 && (v21 = *(uint64_t (**)(void))(v20 + 120)) != 0)
  {
    v22 = v21();
    if (v22 > 0xFFFFFFF7)
    {
LABEL_21:
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      result = 0;
      *(_QWORD *)(v10 + 48) = 0;
      return result;
    }
    v23 = (int)v22;
  }
  else
  {
    v23 = 0;
  }
  v24 = malloc_type_malloc(v23 + 8, 0x30772F57uLL);
  if (!v24)
    goto LABEL_21;
  *v24 = v23;
  v18 = (unsigned __int8 *)(v24 + 1);
  *(_QWORD *)(v10 + 48) = v24 + 1;
LABEL_19:
  result = RSA_decrypt(v13, &v25, v18, v15, a4, a5, 3);
  if ((_DWORD)result)
    return RSA_padding_check_PKCS1_OAEP_mgf1(a2, a3, v15, *(unsigned __int8 **)(v10 + 48), v25, *(const void **)(v10 + 56), *(_QWORD *)(v10 + 64), *(const EVP_MD **)(v10 + 24), *(const EVP_MD **)(v10 + 32)) != 0;
  return result;
}

uint64_t pkey_rsa_ctrl(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v5;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  int v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  size_t v26;

  v5 = *(_QWORD *)(a1 + 40);
  switch(a2)
  {
    case 4097:
      if (a3 > 6 || ((1 << a3) & 0x5A) == 0)
        goto LABEL_21;
      v11 = *(_QWORD *)(v5 + 24);
      if (a3 == 3 && v11)
      {
        ERR_put_error(6, 0, 115, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa.c", 375);
LABEL_21:
        v8 = 109;
        v9 = 403;
        goto LABEL_56;
      }
      if (a3 == 4)
      {
        if ((*(_BYTE *)(a1 + 32) & 0xC0) == 0)
          goto LABEL_21;
      }
      else
      {
        if (a3 != 6)
          goto LABEL_68;
        if ((*(_BYTE *)(a1 + 32) & 0x18) == 0)
          goto LABEL_21;
      }
      if (!v11)
        *(_QWORD *)(v5 + 24) = EVP_sha1();
LABEL_68:
      *(_DWORD *)(v5 + 16) = a3;
      return 1;
    case 4098:
      *(_DWORD *)a4 = *(_DWORD *)(v5 + 16);
      return 1;
    case 4099:
    case 4100:
      if (*(_DWORD *)(v5 + 16) != 6)
      {
        v8 = 116;
        v9 = 420;
        goto LABEL_56;
      }
      if (a2 == 4100)
      {
        *(_DWORD *)a4 = *(_DWORD *)(v5 + 40);
        return 1;
      }
      if (a3 < -2)
        return 0;
      *(_DWORD *)(v5 + 40) = a3;
      return 1;
    case 4101:
      if (a3 <= 255)
      {
        v8 = 112;
        v9 = 435;
        goto LABEL_56;
      }
      *(_DWORD *)v5 = a3;
      return 1;
    case 4102:
      if (!a4)
        return 0;
      v12 = *(uint64_t **)(v5 + 8);
      if (!v12)
        goto LABEL_34;
      v13 = *((_DWORD *)v12 + 5);
      if ((v13 & 2) == 0)
      {
        v14 = *v12;
        if (*v12)
        {
          v16 = *(_QWORD *)(v14 - 8);
          v15 = (void *)(v14 - 8);
          v17 = v16 + 8;
          if (v16 != -8)
            bzero(v15, v17);
          free(v15);
          v13 = *((_DWORD *)v12 + 5);
        }
      }
      if ((v13 & 1) != 0)
      {
        v25 = *(v12 - 1);
        v24 = v12 - 1;
        v26 = v25 + 8;
        if (v25 != -8)
          bzero(v24, v26);
        free(v24);
        *(_QWORD *)(v5 + 8) = a4;
        return 1;
      }
      else
      {
        *v12 = 0;
LABEL_34:
        *(_QWORD *)(v5 + 8) = a4;
        return 1;
      }
    case 4103:
    case 4104:
      if (*(_DWORD *)(v5 + 16) != 4)
      {
        v8 = 115;
        v9 = 452;
        goto LABEL_56;
      }
      if (a2 == 4104)
        goto LABEL_15;
      goto LABEL_48;
    case 4105:
    case 4106:
      if ((*(_DWORD *)(v5 + 16) | 2) != 6)
      {
        v8 = 113;
        v9 = 477;
        goto LABEL_56;
      }
      if (a2 == 4106)
      {
        v10 = *(_QWORD *)(v5 + 32);
        if (!v10)
          goto LABEL_15;
        *(_QWORD *)a4 = v10;
        return 1;
      }
      else
      {
        *(_QWORD *)(v5 + 32) = a4;
        return 1;
      }
    case 4107:
      if (*(_DWORD *)(v5 + 16) != 4)
      {
        v8 = 115;
        v9 = 493;
        goto LABEL_56;
      }
      v18 = *(_QWORD *)(v5 + 56);
      if (v18)
      {
        v20 = *(_QWORD *)(v18 - 8);
        v19 = (void *)(v18 - 8);
        v21 = v20 + 8;
        if (v20 != -8)
          bzero(v19, v21);
        free(v19);
      }
      v22 = *(_QWORD *)(a4 + 8);
      *(_QWORD *)(v5 + 56) = *(_QWORD *)a4;
      *(_QWORD *)(v5 + 64) = v22;
      return 1;
    case 4108:
      if (*(_DWORD *)(v5 + 16) == 4)
      {
        v23 = *(_QWORD *)(v5 + 64);
        *(_QWORD *)a4 = *(_QWORD *)(v5 + 56);
        *(_QWORD *)(a4 + 8) = v23;
        return 1;
      }
      v8 = 115;
      v9 = 505;
      goto LABEL_56;
    default:
      if (a2 == 1)
      {
        if (!a4 || *(_DWORD *)(v5 + 16) != 3)
        {
LABEL_48:
          *(_QWORD *)(v5 + 24) = a4;
          return 1;
        }
        v8 = 115;
        v9 = 375;
      }
      else
      {
        if (a2 == 2)
        {
LABEL_15:
          *(_QWORD *)a4 = *(_QWORD *)(v5 + 24);
          return 1;
        }
        v8 = 101;
        v9 = 512;
      }
LABEL_56:
      ERR_put_error(6, 0, v8, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa.c", v9);
      return 0;
  }
}

uint64_t EVP_PKEY_CTX_set_rsa_padding(uint64_t *a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);

  if (a1 && (v1 = *a1) != 0 && (v2 = *(uint64_t (**)(void))(v1 + 112)) != 0)
  {
    if (*(_DWORD *)v1 == 6)
    {
      if (*((_DWORD *)a1 + 8))
      {
        return v2();
      }
      else
      {
        ERR_put_error(6, 0, 123, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/evp_ctx.c", 201);
        return 0;
      }
    }
    else
    {
      ERR_put_error(6, 0, 125, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/evp_ctx.c", 196);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 101, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/evp_ctx.c", 192);
    return 0;
  }
}

uint64_t rsa_pub_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  RSA *v7;
  uint64_t v8;
  void (*v9)(uint64_t);
  uint64_t v10;
  unint64_t v11;
  int v12;
  unint64_t v13;

  v10 = 0;
  v11 = 0;
  v13 = 0;
  v12 = 0;
  if (cbs_get_any_asn1_element((unsigned __int8 **)a2, &v10, &v12, &v13, 0, 0, 0)
    && v12 == 5
    && v11 >= v13
    && (v10 += v13, (v11 -= v13) == 0)
    && !*(_QWORD *)(a2 + 8))
  {
    v7 = RSA_parse_public_key((unsigned __int8 **)a3);
    if (v7 && !*(_QWORD *)(a3 + 8))
    {
      v8 = *(_QWORD *)(a1 + 16);
      if (v8)
      {
        v9 = *(void (**)(uint64_t))(v8 + 160);
        if (v9)
          v9(a1);
      }
      *(_DWORD *)(a1 + 4) = 6;
      *(_QWORD *)(a1 + 8) = v7;
      *(_QWORD *)(a1 + 16) = &rsa_asn1_meth;
      return 1;
    }
    else
    {
      ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa_asn1.c", 103);
      RSA_free(v7);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa_asn1.c", 97);
    return 0;
  }
}

uint64_t rsa_pub_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  _OWORD v6[3];
  _OWORD v7[3];
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];
  _BYTE *v11;

  v3 = *(_QWORD *)(a2 + 8);
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  memset(v6, 0, sizeof(v6));
  if (CBB_flush(a1))
  {
    v11 = 0;
    if (CBB_add_space((uint64_t)a1, &v11, 1))
    {
      *v11 = 48;
      if (cbb_add_child((uint64_t)a1, (uint64_t)v10, 1u, 1))
      {
        if (CBB_flush((uint64_t *)v10))
        {
          v11 = 0;
          if (CBB_add_space((uint64_t)v10, &v11, 1))
          {
            *v11 = 48;
            if (cbb_add_child((uint64_t)v10, (uint64_t)v9, 1u, 1))
            {
              if (CBB_flush((uint64_t *)v9))
              {
                v11 = 0;
                if (CBB_add_space((uint64_t)v9, &v11, 1))
                {
                  *v11 = 6;
                  if (cbb_add_child((uint64_t)v9, (uint64_t)v8, 1u, 1))
                  {
                    v11 = 0;
                    if (CBB_add_space((uint64_t)v8, &v11, 9))
                    {
                      v4 = v11;
                      *(_QWORD *)v11 = 0x1010DF78648862ALL;
                      v4[8] = 1;
                      if (CBB_flush((uint64_t *)v9))
                      {
                        v11 = 0;
                        if (CBB_add_space((uint64_t)v9, &v11, 1))
                        {
                          *v11 = 5;
                          if (cbb_add_child((uint64_t)v9, (uint64_t)v7, 1u, 1))
                          {
                            if (CBB_flush((uint64_t *)v10))
                            {
                              v11 = 0;
                              if (CBB_add_space((uint64_t)v10, &v11, 1))
                              {
                                *v11 = 3;
                                if (cbb_add_child((uint64_t)v10, (uint64_t)v6, 1u, 1))
                                {
                                  v11 = 0;
                                  if (CBB_add_space((uint64_t)v6, &v11, 1))
                                  {
                                    *v11 = 0;
                                    if (RSA_marshal_public_key((uint64_t *)v6, v3))
                                    {
                                      if (CBB_flush(a1))
                                        return 1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa_asn1.c", 82);
  return 0;
}

BOOL rsa_pub_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  int v7;
  int v8;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  _BOOL4 v14;
  int v15;
  int v16;
  int v17;
  int v18;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(v3 + 8);
  v5 = *(_QWORD *)(v2 + 8);
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (v4 | v5)
      return 0;
  }
  else
  {
    v7 = *(_DWORD *)(v4 + 16);
    if (v7 != *(_DWORD *)(v5 + 16))
      return 0;
    v8 = bn_cmp_words_consttime(*(uint64_t **)v4, *(int *)(v4 + 8), *(uint64_t **)v5, *(int *)(v5 + 8));
    if (v7 ? -v8 : v8)
      return 0;
  }
  v11 = *(_QWORD *)(v3 + 16);
  v12 = *(_QWORD *)(v2 + 16);
  if (v11)
    v13 = v12 == 0;
  else
    v13 = 1;
  if (v13)
  {
    v14 = v12 != 0;
    if (v11)
      v15 = -1;
    else
      v15 = v14;
    return v15 == 0;
  }
  else
  {
    v16 = *(_DWORD *)(v11 + 16);
    if (v16 == *(_DWORD *)(v12 + 16))
    {
      v17 = bn_cmp_words_consttime(*(uint64_t **)v11, *(int *)(v11 + 8), *(uint64_t **)v12, *(int *)(v12 + 8));
      if (v16)
        v18 = -v17;
      else
        v18 = v17;
      return v18 == 0;
    }
    else
    {
      return 0;
    }
  }
}

uint64_t rsa_priv_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  RSA *v7;
  uint64_t v8;
  void (*v9)(uint64_t);
  uint64_t v10;
  unint64_t v11;
  int v12;
  unint64_t v13;

  v10 = 0;
  v11 = 0;
  v13 = 0;
  v12 = 0;
  if (cbs_get_any_asn1_element((unsigned __int8 **)a2, &v10, &v12, &v13, 0, 0, 0)
    && v12 == 5
    && v11 >= v13
    && (v10 += v13, (v11 -= v13) == 0)
    && !*(_QWORD *)(a2 + 8))
  {
    v7 = RSA_parse_private_key((unsigned __int8 **)a3);
    if (v7 && !*(_QWORD *)(a3 + 8))
    {
      v8 = *(_QWORD *)(a1 + 16);
      if (v8)
      {
        v9 = *(void (**)(uint64_t))(v8 + 160);
        if (v9)
          v9(a1);
      }
      *(_DWORD *)(a1 + 4) = 6;
      *(_QWORD *)(a1 + 8) = v7;
      *(_QWORD *)(a1 + 16) = &rsa_asn1_meth;
      return 1;
    }
    else
    {
      ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa_asn1.c", 150);
      RSA_free(v7);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa_asn1.c", 144);
    return 0;
  }
}

uint64_t rsa_priv_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t **v3;
  _BYTE *v4;
  _OWORD v6[3];
  _OWORD v7[3];
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];
  _BYTE *v11;

  v3 = *(uint64_t ***)(a2 + 8);
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  memset(v6, 0, sizeof(v6));
  if (CBB_flush(a1))
  {
    v11 = 0;
    if (CBB_add_space((uint64_t)a1, &v11, 1))
    {
      *v11 = 48;
      if (cbb_add_child((uint64_t)a1, (uint64_t)v10, 1u, 1))
      {
        if (CBB_add_asn1_uint64_with_tag((uint64_t)v10, 0, 2))
        {
          if (CBB_flush((uint64_t *)v10))
          {
            v11 = 0;
            if (CBB_add_space((uint64_t)v10, &v11, 1))
            {
              *v11 = 48;
              if (cbb_add_child((uint64_t)v10, (uint64_t)v9, 1u, 1))
              {
                if (CBB_flush((uint64_t *)v9))
                {
                  v11 = 0;
                  if (CBB_add_space((uint64_t)v9, &v11, 1))
                  {
                    *v11 = 6;
                    if (cbb_add_child((uint64_t)v9, (uint64_t)v8, 1u, 1))
                    {
                      v11 = 0;
                      if (CBB_add_space((uint64_t)v8, &v11, 9))
                      {
                        v4 = v11;
                        *(_QWORD *)v11 = 0x1010DF78648862ALL;
                        v4[8] = 1;
                        if (CBB_flush((uint64_t *)v9))
                        {
                          v11 = 0;
                          if (CBB_add_space((uint64_t)v9, &v11, 1))
                          {
                            *v11 = 5;
                            if (cbb_add_child((uint64_t)v9, (uint64_t)v7, 1u, 1))
                            {
                              if (CBB_flush((uint64_t *)v10))
                              {
                                v11 = 0;
                                if (CBB_add_space((uint64_t)v10, &v11, 1))
                                {
                                  *v11 = 4;
                                  if (cbb_add_child((uint64_t)v10, (uint64_t)v6, 1u, 1))
                                  {
                                    if (RSA_marshal_private_key((uint64_t *)v6, v3)
                                      && CBB_flush(a1))
                                    {
                                      return 1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa_asn1.c", 131);
  return 0;
}

uint64_t rsa_opaque(uint64_t a1)
{
  uint64_t v1;

  v1 = **(_QWORD **)(a1 + 8);
  if (v1)
    return *(_DWORD *)(v1 + 72) & 1;
  else
    return 0;
}

uint64_t int_rsa_size(uint64_t a1)
{
  uint64_t **v1;
  uint64_t (*v2)(void);

  v1 = *(uint64_t ***)(a1 + 8);
  v2 = (uint64_t (*)(void))(*v1)[4];
  if (v2)
    return v2();
  else
    return BN_num_bytes(v1[1]);
}

uint64_t rsa_bits(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  unint64_t v11;
  _BOOL4 v12;
  _BOOL4 v13;
  _BOOL4 v14;
  _BOOL4 v15;
  _BOOL4 v16;
  _BOOL4 v17;
  unsigned int v18;

  v1 = *(uint64_t **)(*(_QWORD *)(a1 + 8) + 8);
  v2 = *((unsigned int *)v1 + 2);
  v3 = v2 & ((int)v2 >> 31);
  v4 = 8 * v2 - 8;
  v5 = *((_DWORD *)v1 + 2);
  while (1)
  {
    v6 = __OFSUB__(v5--, 1);
    if (v5 < 0 != v6)
      break;
    v7 = *v1;
    v8 = *(_QWORD *)(*v1 + v4);
    v4 -= 8;
    if (v8)
    {
      v3 = v5 + 1;
      goto LABEL_8;
    }
  }
  if ((v2 & 0x80000000) == 0)
    return 0;
  v7 = *v1;
LABEL_8:
  v10 = v3 - 1;
  v11 = *(_QWORD *)(v7 + 8 * v10);
  v12 = v11 != 0;
  v13 = HIDWORD(v11) != 0;
  if (HIDWORD(v11))
    v11 >>= 32;
  v14 = v11 >> 16 != 0;
  if (v11 >> 16)
    v11 >>= 16;
  v15 = v11 > 0xFF;
  if (v11 > 0xFF)
    v11 >>= 8;
  v16 = v11 > 0xF;
  if (v11 > 0xF)
    v11 >>= 4;
  v17 = v11 > 3;
  if (v11 > 3)
    v11 >>= 2;
  v18 = v12 | (v10 << 6) | (32 * v13) | (16 * v14) | (8 * v15) | (4 * v16) | (2 * v17);
  if (v11 <= 1)
    return v18;
  else
    return v18 + 1;
}

void int_rsa_free(uint64_t a1)
{
  RSA_free(*(RSA **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
}

uint64_t pkey_x25519_copy()
{
  return 1;
}

uint64_t pkey_x25519_keygen(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _BYTE *v5;
  uint64_t v6;
  void (*v7)(uint64_t);
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;

  v3 = malloc_type_malloc(0x49uLL, 0x30772F57uLL);
  if (v3)
  {
    v4 = v3;
    *v3 = 65;
    v5 = v3 + 1;
    v6 = *(_QWORD *)(a2 + 16);
    if (v6)
    {
      v7 = *(void (**)(uint64_t))(v6 + 160);
      if (v7)
      {
        v7(a2);
        *(_QWORD *)(a2 + 8) = 0;
      }
    }
    *(_QWORD *)(a2 + 16) = &x25519_asn1_meth;
    *(_DWORD *)(a2 + 4) = 948;
    RAND_bytes_with_additional_data((uint64_t)(v4 + 5), 0x20uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
    *((_BYTE *)v4 + 40) |= 7u;
    *((_BYTE *)v4 + 71) = *((_BYTE *)v4 + 71) & 0x3F | 0x80;
    X25519_public_from_private(v5, (__int128 *)(v4 + 5));
    *((_BYTE *)v4 + 72) = 1;
    v8 = *(_QWORD *)(a2 + 8);
    if (v8)
    {
      v10 = *(_QWORD *)(v8 - 8);
      v9 = (void *)(v8 - 8);
      v11 = v10 + 8;
      if (v10 != -8)
        bzero(v9, v11);
      free(v9);
    }
    *(_QWORD *)(a2 + 8) = v5;
    return 1;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
}

uint64_t pkey_x25519_derive(uint64_t a1, int8x16_t *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  unsigned int *v7;
  BOOL v8;

  v3 = *(_QWORD *)(a1 + 16);
  if (!v3 || (v4 = *(_QWORD *)(a1 + 24)) == 0)
  {
    ERR_put_error(6, 0, 117, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519.c", 46);
    return 0;
  }
  v6 = *(_QWORD *)(v3 + 8);
  v7 = *(unsigned int **)(v4 + 8);
  if (v6)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (v8)
  {
    ERR_put_error(6, 0, 117, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519.c", 53);
    return 0;
  }
  if (*(_BYTE *)(v6 + 64))
  {
    if (!a2)
      goto LABEL_16;
    if (*a3 <= 0x1FuLL)
    {
      ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519.c", 64);
      return 0;
    }
    if (!X25519(a2, (__int128 *)(v6 + 32), v7))
    {
      ERR_put_error(6, 0, 134, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519.c", 68);
      return 0;
    }
    else
    {
LABEL_16:
      *a3 = 32;
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 0, 130, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519.c", 58);
    return 0;
  }
}

uint64_t pkey_x25519_ctrl(uint64_t a1, int a2)
{
  if (a2 == 3)
    return 1;
  ERR_put_error(6, 0, 101, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519.c", 85);
  return 0;
}

uint64_t x25519_pub_decode(uint64_t a1, uint64_t a2, __int128 **a3)
{
  __int128 *v5;
  char *v6;
  char *v7;
  __int128 v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  size_t v12;

  if (*(_QWORD *)(a2 + 8))
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519_asn1.c", 133);
    return 0;
  }
  else if (a3[1] == (__int128 *)32)
  {
    v5 = *a3;
    v6 = (char *)malloc_type_malloc(0x49uLL, 0x30772F57uLL);
    if (v6)
    {
      *(_QWORD *)v6 = 65;
      v7 = v6 + 8;
      v8 = *v5;
      *(_OWORD *)(v6 + 24) = v5[1];
      *(_OWORD *)(v6 + 8) = v8;
      v6[72] = 0;
      v9 = *(_QWORD *)(a1 + 8);
      if (v9)
      {
        v11 = *(_QWORD *)(v9 - 8);
        v10 = (void *)(v9 - 8);
        v12 = v11 + 8;
        if (v11 != -8)
          bzero(v10, v12);
        free(v10);
      }
      *(_QWORD *)(a1 + 8) = v7;
      return 1;
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519_asn1.c", 53);
    return 0;
  }
}

uint64_t x25519_pub_encode(uint64_t *a1, uint64_t a2)
{
  _OWORD *v3;
  _BYTE *v4;
  _BYTE *v5;
  __int128 v6;
  _OWORD v8[3];
  _OWORD v9[3];
  _OWORD v10[3];
  _OWORD v11[3];
  _BYTE *v12;

  v3 = *(_OWORD **)(a2 + 8);
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  if (CBB_flush(a1))
  {
    v12 = 0;
    if (CBB_add_space((uint64_t)a1, &v12, 1))
    {
      *v12 = 48;
      if (cbb_add_child((uint64_t)a1, (uint64_t)v11, 1u, 1))
      {
        if (CBB_flush((uint64_t *)v11))
        {
          v12 = 0;
          if (CBB_add_space((uint64_t)v11, &v12, 1))
          {
            *v12 = 48;
            if (cbb_add_child((uint64_t)v11, (uint64_t)v10, 1u, 1))
            {
              if (CBB_flush((uint64_t *)v10))
              {
                v12 = 0;
                if (CBB_add_space((uint64_t)v10, &v12, 1))
                {
                  *v12 = 6;
                  if (cbb_add_child((uint64_t)v10, (uint64_t)v9, 1u, 1))
                  {
                    v12 = 0;
                    if (CBB_add_space((uint64_t)v9, &v12, 3))
                    {
                      v4 = v12;
                      *(_WORD *)v12 = 25899;
                      v4[2] = 110;
                      if (CBB_flush((uint64_t *)v11))
                      {
                        v12 = 0;
                        if (CBB_add_space((uint64_t)v11, &v12, 1))
                        {
                          *v12 = 3;
                          if (cbb_add_child((uint64_t)v11, (uint64_t)v8, 1u, 1))
                          {
                            v12 = 0;
                            if (CBB_add_space((uint64_t)v8, &v12, 1))
                            {
                              *v12 = 0;
                              v12 = 0;
                              if (CBB_add_space((uint64_t)v8, &v12, 32))
                              {
                                v5 = v12;
                                v6 = v3[1];
                                *(_OWORD *)v12 = *v3;
                                *((_OWORD *)v5 + 1) = v6;
                                if (CBB_flush(a1))
                                  return 1;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ERR_put_error(6, 0, 105, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519_asn1.c", 153);
  return 0;
}

BOOL x25519_pub_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(uint64_t **)(a1 + 8);
  v3 = *(uint64_t **)(a2 + 8);
  v4 = *v2;
  v5 = v2[1];
  v6 = *v3;
  v7 = v3[1];
  v9 = v2[2];
  v8 = v2[3];
  v11 = v3[2];
  v10 = v3[3];
  return v4 == v6 && v5 == v7 && v9 == v11 && v8 == v10;
}

uint64_t x25519_priv_decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const char *v3;
  int v4;
  int v5;
  int v6;
  uint64_t v10;
  __int128 *v11;
  char *v12;
  char *v13;
  char *v14;
  __int128 v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  size_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  unint64_t v23;

  v20 = 0;
  v21 = 0;
  if (*(_QWORD *)(a2 + 8)
    || (v23 = 0,
        v22 = 0,
        !cbs_get_any_asn1_element((unsigned __int8 **)a3, &v20, &v22, &v23, 0, 0, 0))
    || v22 != 4
    || (v10 = v21 - v23, v21 < v23)
    || (v11 = (__int128 *)(v20 + v23), v20 += v23, v21 -= v23, *(_QWORD *)(a3 + 8)))
  {
    v3 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cr"
         "ypto/evp/p_x25519_asn1.c";
    v4 = 6;
    v5 = 102;
    v6 = 175;
LABEL_3:
    ERR_put_error(v4, 0, v5, v3, v6);
    return 0;
  }
  if (v10 != 32)
  {
    v3 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cr"
         "ypto/evp/p_x25519_asn1.c";
    v4 = 6;
    v5 = 102;
    v6 = 33;
    goto LABEL_3;
  }
  v12 = (char *)malloc_type_malloc(0x49uLL, 0x30772F57uLL);
  if (!v12)
  {
    v3 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v4 = 14;
    v5 = 65;
    v6 = 247;
    goto LABEL_3;
  }
  v13 = v12;
  *(_QWORD *)v12 = 65;
  v14 = v12 + 8;
  v15 = *v11;
  *(_OWORD *)(v12 + 56) = v11[1];
  *(_OWORD *)(v12 + 40) = v15;
  X25519_public_from_private(v12 + 8, (__int128 *)(v12 + 40));
  v13[72] = 1;
  v16 = *(_QWORD *)(a1 + 8);
  if (v16)
  {
    v18 = *(_QWORD *)(v16 - 8);
    v17 = (void *)(v16 - 8);
    v19 = v18 + 8;
    if (v18 != -8)
      bzero(v17, v19);
    free(v17);
  }
  *(_QWORD *)(a1 + 8) = v14;
  return 1;
}

uint64_t x25519_priv_encode(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  _BYTE *v4;
  _BYTE *v5;
  __int128 v6;
  int v8;
  int v9;
  _OWORD v10[3];
  _OWORD v11[3];
  _OWORD v12[3];
  _OWORD v13[3];
  _OWORD v14[3];
  _BYTE *v15;

  v2 = *(_QWORD *)(a2 + 8);
  if (*(_BYTE *)(v2 + 64))
  {
    memset(v14, 0, sizeof(v14));
    memset(v13, 0, sizeof(v13));
    memset(v12, 0, sizeof(v12));
    memset(v11, 0, sizeof(v11));
    memset(v10, 0, sizeof(v10));
    if (CBB_flush(a1))
    {
      v15 = 0;
      if (CBB_add_space((uint64_t)a1, &v15, 1))
      {
        *v15 = 48;
        if (cbb_add_child((uint64_t)a1, (uint64_t)v14, 1u, 1))
        {
          if (CBB_add_asn1_uint64_with_tag((uint64_t)v14, 0, 2))
          {
            if (CBB_flush((uint64_t *)v14))
            {
              v15 = 0;
              if (CBB_add_space((uint64_t)v14, &v15, 1))
              {
                *v15 = 48;
                if (cbb_add_child((uint64_t)v14, (uint64_t)v13, 1u, 1))
                {
                  if (CBB_flush((uint64_t *)v13))
                  {
                    v15 = 0;
                    if (CBB_add_space((uint64_t)v13, &v15, 1))
                    {
                      *v15 = 6;
                      if (cbb_add_child((uint64_t)v13, (uint64_t)v12, 1u, 1))
                      {
                        v15 = 0;
                        if (CBB_add_space((uint64_t)v12, &v15, 3))
                        {
                          v4 = v15;
                          *(_WORD *)v15 = 25899;
                          v4[2] = 110;
                          if (CBB_flush((uint64_t *)v14))
                          {
                            v15 = 0;
                            if (CBB_add_space((uint64_t)v14, &v15, 1))
                            {
                              *v15 = 4;
                              if (cbb_add_child((uint64_t)v14, (uint64_t)v11, 1u, 1))
                              {
                                if (CBB_flush((uint64_t *)v11))
                                {
                                  v15 = 0;
                                  if (CBB_add_space((uint64_t)v11, &v15, 1))
                                  {
                                    *v15 = 4;
                                    if (cbb_add_child((uint64_t)v11, (uint64_t)v10, 1u, 1))
                                    {
                                      v15 = 0;
                                      if (CBB_add_space((uint64_t)v10, &v15, 32))
                                      {
                                        v5 = v15;
                                        v6 = *(_OWORD *)(v2 + 48);
                                        *(_OWORD *)v15 = *(_OWORD *)(v2 + 32);
                                        *((_OWORD *)v5 + 1) = v6;
                                        if (CBB_flush(a1))
                                          return 1;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v8 = 105;
    v9 = 202;
  }
  else
  {
    v8 = 130;
    v9 = 185;
  }
  ERR_put_error(6, 0, v8, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519_asn1.c", v9);
  return 0;
}

uint64_t x25519_set_priv_raw(uint64_t a1, __int128 *a2, uint64_t a3)
{
  char *v5;
  char *v6;
  char *v7;
  __int128 v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  size_t v12;

  if (a3 == 32)
  {
    v5 = (char *)malloc_type_malloc(0x49uLL, 0x30772F57uLL);
    if (v5)
    {
      v6 = v5;
      *(_QWORD *)v5 = 65;
      v7 = v5 + 8;
      v8 = *a2;
      *(_OWORD *)(v5 + 56) = a2[1];
      *(_OWORD *)(v5 + 40) = v8;
      X25519_public_from_private(v5 + 8, (__int128 *)(v5 + 40));
      v6[72] = 1;
      v9 = *(_QWORD *)(a1 + 8);
      if (v9)
      {
        v11 = *(_QWORD *)(v9 - 8);
        v10 = (void *)(v9 - 8);
        v12 = v11 + 8;
        if (v11 != -8)
          bzero(v10, v12);
        free(v10);
      }
      *(_QWORD *)(a1 + 8) = v7;
      return 1;
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519_asn1.c", 33);
    return 0;
  }
}

uint64_t x25519_set_pub_raw(uint64_t a1, __int128 *a2, uint64_t a3)
{
  char *v5;
  char *v6;
  __int128 v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;

  if (a3 == 32)
  {
    v5 = (char *)malloc_type_malloc(0x49uLL, 0x30772F57uLL);
    if (v5)
    {
      *(_QWORD *)v5 = 65;
      v6 = v5 + 8;
      v7 = *a2;
      *(_OWORD *)(v5 + 24) = a2[1];
      *(_OWORD *)(v5 + 8) = v7;
      v5[72] = 0;
      v8 = *(_QWORD *)(a1 + 8);
      if (v8)
      {
        v10 = *(_QWORD *)(v8 - 8);
        v9 = (void *)(v8 - 8);
        v11 = v10 + 8;
        if (v10 != -8)
          bzero(v9, v11);
        free(v9);
      }
      *(_QWORD *)(a1 + 8) = v6;
      return 1;
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519_asn1.c", 53);
    return 0;
  }
}

uint64_t x25519_get_priv_raw(uint64_t a1, _OWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  __int128 v5;

  v3 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v3 + 64))
  {
    if (a2)
    {
      if (*a3 <= 0x1FuLL)
      {
        ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519_asn1.c", 84);
        return 0;
      }
      v5 = *(_OWORD *)(v3 + 48);
      *a2 = *(_OWORD *)(v3 + 32);
      a2[1] = v5;
    }
    *a3 = 32;
    return 1;
  }
  else
  {
    ERR_put_error(6, 0, 130, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519_asn1.c", 74);
    return 0;
  }
}

uint64_t x25519_get_pub_raw(uint64_t a1, _OWORD *a2, _QWORD *a3)
{
  _OWORD *v4;
  __int128 v5;

  if (a2)
  {
    if (*a3 <= 0x1FuLL)
    {
      ERR_put_error(6, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519_asn1.c", 102);
      return 0;
    }
    v4 = *(_OWORD **)(a1 + 8);
    v5 = v4[1];
    *a2 = *v4;
    a2[1] = v5;
  }
  *a3 = 32;
  return 1;
}

uint64_t x25519_set1_tls_encodedpoint(uint64_t a1, __int128 *a2, uint64_t a3)
{
  char *v5;
  char *v6;
  __int128 v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;

  if (a3 == 32)
  {
    v5 = (char *)malloc_type_malloc(0x49uLL, 0x30772F57uLL);
    if (v5)
    {
      *(_QWORD *)v5 = 65;
      v6 = v5 + 8;
      v7 = *a2;
      *(_OWORD *)(v5 + 24) = a2[1];
      *(_OWORD *)(v5 + 8) = v7;
      v5[72] = 0;
      v8 = *(_QWORD *)(a1 + 8);
      if (v8)
      {
        v10 = *(_QWORD *)(v8 - 8);
        v9 = (void *)(v8 - 8);
        v11 = v10 + 8;
        if (v10 != -8)
          bzero(v9, v11);
        free(v9);
      }
      *(_QWORD *)(a1 + 8) = v6;
      return 1;
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519_asn1.c", 53);
    return 0;
  }
}

uint64_t x25519_get1_tls_encodedpoint(uint64_t a1, _QWORD *a2)
{
  __int128 *v2;
  char *v4;
  char *v5;
  __int128 v6;

  v2 = *(__int128 **)(a1 + 8);
  if (v2)
  {
    v4 = (char *)malloc_type_malloc(0x28uLL, 0x30772F57uLL);
    if (v4)
    {
      *(_QWORD *)v4 = 32;
      v5 = v4 + 8;
      v6 = *v2;
      *(_OWORD *)(v4 + 24) = v2[1];
      *(_OWORD *)(v4 + 8) = v6;
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v5 = 0;
    }
    *a2 = v5;
    return 32 * (v5 != 0);
  }
  else
  {
    ERR_put_error(6, 0, 120, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_x25519_asn1.c", 120);
    return 0;
  }
}

uint64_t x25519_size()
{
  return 32;
}

uint64_t x25519_bits()
{
  return 253;
}

void x25519_free(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  size_t v5;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v4 = *(_QWORD *)(v2 - 8);
    v3 = (void *)(v2 - 8);
    v5 = v4 + 8;
    if (v4 != -8)
      bzero(v3, v5);
    free(v3);
  }
  *(_QWORD *)(a1 + 8) = 0;
}

int RSA_padding_check_PKCS1_type_1(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len)
{
  size_t *v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  if (*(_QWORD *)&rsa_len <= 1uLL)
  {
    ERR_put_error(4, 0, 116, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/padding.c", 101);
    return 0;
  }
  if (**(_BYTE **)&fl || *(_BYTE *)(*(_QWORD *)&fl + 1) != 1)
  {
    ERR_put_error(4, 0, 107, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/padding.c", 107);
    return 0;
  }
  if (*(_QWORD *)&rsa_len < 3uLL)
    goto LABEL_13;
  v6 = *(size_t **)&tlen;
  v7 = 0;
  v8 = *(_QWORD *)&rsa_len - 2;
  while (*(unsigned __int8 *)(*(_QWORD *)&fl + v7 + 2) == 255)
  {
    if (v8 == ++v7)
      goto LABEL_13;
  }
  if (*(_BYTE *)(*(_QWORD *)&fl + v7 + 2))
  {
    ERR_put_error(4, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/padding.c", 119);
    return 0;
  }
  else
  {
    if (v8 == v7)
    {
LABEL_13:
      ERR_put_error(4, 0, 131, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/padding.c", 125);
      return 0;
    }
    if ((unint64_t)(v7 + 2) > 9)
    {
      v9 = *(_QWORD *)&rsa_len - v7 - 3;
      if (v9 <= (unint64_t)f)
      {
        if (*(_QWORD *)&rsa_len - 3 != v7)
          memcpy(to, (const void *)(*(_QWORD *)&fl + v7 + 3), v9);
        *v6 = v9;
        return 1;
      }
      else
      {
        ERR_put_error(4, 0, 113, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/padding.c", 138);
        return 0;
      }
    }
    else
    {
      ERR_put_error(4, 0, 103, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/padding.c", 130);
      return 0;
    }
  }
}

int RSA_padding_add_none(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  if (*(_QWORD *)&fl <= *(_QWORD *)&tlen)
  {
    if (*(_QWORD *)&fl >= *(_QWORD *)&tlen)
    {
      if (*(_QWORD *)&fl)
        memcpy(to, f, *(size_t *)&fl);
      return 1;
    }
    else
    {
      ERR_put_error(4, 0, 116, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/padding.c", 155);
      return 0;
    }
  }
  else
  {
    ERR_put_error(4, 0, 114, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/padding.c", 150);
    return 0;
  }
}

int PKCS1_MGF1(unsigned __int8 *mask, uint64_t len, const unsigned __int8 *seed, uint64_t seedlen, const EVP_MD *dgst)
{
  size_t v8;
  unsigned int v10;
  size_t pkey_type;
  uint64_t final_high;
  _QWORD *v13;
  void *v14;
  uint64_t v15;
  char *v16;
  size_t v17;
  size_t v18;
  int v19;
  _QWORD *v20;
  char *v21;
  uint64_t v22;
  size_t v23;
  unsigned int v25;
  void *v26[2];
  __int128 v27;
  _BYTE __src[64];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)v26 = 0u;
  v27 = 0u;
  if (len)
  {
    v8 = len;
    v10 = 0;
    pkey_type = dgst->pkey_type;
    do
    {
      v25 = bswap32(v10);
      if (v26[0] != dgst)
      {
        final_high = HIDWORD(dgst->final);
        v13 = malloc_type_malloc(final_high + 8, 0x30772F57uLL);
        if (!v13)
        {
          ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
          v19 = 0;
          v20 = v26[1];
          if (v26[1])
            goto LABEL_18;
          goto LABEL_21;
        }
        *v13 = final_high;
        v14 = v13 + 1;
        if (v26[1])
        {
          v16 = (char *)v26[1] - 8;
          v15 = *((_QWORD *)v26[1] - 1);
          if (v15 != -8)
            bzero(v16, v15 + 8);
          free(v16);
        }
        v26[0] = (void *)dgst;
        v26[1] = v14;
      }
      ((void (*)(void **))dgst->flags)(v26);
      (*((void (**)(void **, const unsigned __int8 *, uint64_t))v26[0] + 3))(v26, seed, seedlen);
      (*((void (**)(void **, unsigned int *, uint64_t))v26[0] + 3))(v26, &v25, 4);
      if (v8 < pkey_type)
      {
        (*((void (**)(void **, _BYTE *))v26[0] + 4))(v26, __src);
        v18 = *((unsigned int *)v26[0] + 11);
        if ((_DWORD)v18)
          bzero(v26[1], v18);
        memcpy(mask, __src, v8);
        break;
      }
      (*((void (**)(void **, unsigned __int8 *))v26[0] + 4))(v26, mask);
      v17 = *((unsigned int *)v26[0] + 11);
      if ((_DWORD)v17)
        bzero(v26[1], v17);
      mask += pkey_type;
      ++v10;
      v8 -= pkey_type;
    }
    while (v8);
  }
  v19 = 1;
  v20 = v26[1];
  if (v26[1])
  {
LABEL_18:
    v22 = *(v20 - 1);
    v21 = (char *)(v20 - 1);
    v23 = v22 + 8;
    if (v22 != -8)
      bzero(v21, v23);
    free(v21);
  }
LABEL_21:
  if (*((_QWORD *)&v27 + 1))
    (**((void (***)(_QWORD))&v27 + 1))(v27);
  return v19;
}

uint64_t RSA_verify_PKCS1_PSS_mgf1(uint64_t **a1, uint64_t a2, const EVP_MD *a3, const EVP_MD *a4, unsigned __int8 *a5, int a6)
{
  const EVP_MD *v9;
  size_t pkey_type;
  unsigned int v11;
  const char *v12;
  int v13;
  int v14;
  int v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t (*v25)(void);
  unsigned int v26;
  uint64_t v27;
  _BOOL8 v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  int v32;
  unint64_t v33;
  BOOL v34;
  BOOL v35;
  BOOL v36;
  BOOL v37;
  BOOL v38;
  BOOL v39;
  char v40;
  uint64_t v41;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  _BYTE *v47;
  unsigned __int8 *v48;
  char v49;
  unint64_t v50;
  int v51;
  unint64_t v52;
  int v53;
  int v54;
  void *v55;
  size_t v56;
  uint64_t v57;
  char *v58;
  int8x16_t *v59;
  int8x16_t *v60;
  unint64_t v61;
  int8x16_t v62;
  unint64_t v63;
  int8x8_t *v64;
  int8x8_t *v65;
  unint64_t v66;
  int8x8_t v67;
  unsigned __int8 *v68;
  _QWORD *v69;
  uint64_t v70;
  unint64_t len;
  EVP_MD_CTX ctx;
  unsigned __int8 md[64];
  uint64_t v74;

  v74 = *MEMORY[0x24BDAC8D0];
  if (a4)
    v9 = a4;
  else
    v9 = a3;
  memset(&ctx, 0, sizeof(ctx));
  pkey_type = a3->pkey_type;
  if (a6 == -2)
  {
    v11 = -2;
  }
  else
  {
    v11 = a3->pkey_type;
    if (a6 != -1)
    {
      v11 = a6;
      if (a6 <= -3)
      {
        v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/fipsmodule/rsa/padding.c";
        v13 = 4;
        v14 = 138;
        v15 = 233;
LABEL_42:
        ERR_put_error(v13, 0, v14, v12, v15);
        v41 = 0;
        goto LABEL_43;
      }
    }
  }
  v16 = a1[1];
  v17 = *((unsigned int *)v16 + 2);
  v18 = v17 & ((int)v17 >> 31);
  v19 = 8 * v17 - 8;
  v20 = *((_DWORD *)v16 + 2);
  while (1)
  {
    v21 = __OFSUB__(v20--, 1);
    if (v20 < 0 != v21)
      break;
    v22 = *v16;
    v23 = *(_QWORD *)(*v16 + v19);
    v19 -= 8;
    if (v23)
    {
      v18 = v20 + 1;
      goto LABEL_27;
    }
  }
  if ((v17 & 0x80000000) != 0)
  {
    v22 = *v16;
LABEL_27:
    v32 = v18 - 1;
    v33 = *(_QWORD *)(v22 + 8 * v32);
    v34 = v33 != 0;
    v35 = HIDWORD(v33) != 0;
    if (HIDWORD(v33))
      v33 >>= 32;
    v36 = v33 >> 16 != 0;
    if (v33 >> 16)
      v33 >>= 16;
    v37 = v33 > 0xFF;
    if (v33 > 0xFF)
      v33 >>= 8;
    v38 = v33 > 0xF;
    if (v33 > 0xF)
      v33 >>= 4;
    v39 = v33 > 3;
    if (v33 > 3)
      v33 >>= 2;
    v40 = v34 | ((_BYTE)v32 << 6) | (32 * v35) | (16 * v36) | (8 * v37) | (4 * v38) | (2 * v39);
    if (v33 > 1)
      ++v40;
    v24 = (v40 - 1) & 7;
    v25 = (uint64_t (*)(void))(*a1)[4];
    if (!v25)
    {
LABEL_15:
      v26 = BN_num_bytes(a1[1]);
      if (!(*a5 >> v24))
        goto LABEL_16;
LABEL_41:
      v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src"
            "/crypto/fipsmodule/rsa/padding.c";
      v13 = 4;
      v14 = 122;
      v15 = 240;
      goto LABEL_42;
    }
  }
  else
  {
    v24 = 7;
    v25 = (uint64_t (*)(void))(*a1)[4];
    if (!v25)
      goto LABEL_15;
  }
  v26 = v25();
  if (*a5 >> v24)
    goto LABEL_41;
LABEL_16:
  v27 = v26;
  v28 = v24 == 0;
  if (v24)
    v29 = (unint64_t)a5;
  else
    v29 = (unint64_t)(a5 + 1);
  if (v24)
    v30 = 0;
  else
    v30 = -1;
  v31 = v26 - v28;
  if (v31 < pkey_type + 2 || (v11 & 0x80000000) == 0 && v31 < pkey_type + 2 + v11)
  {
    v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/padding.c";
    v13 = 4;
    v14 = 113;
    v15 = 250;
    goto LABEL_42;
  }
  if (*(unsigned __int8 *)(v31 + v29 - 1) != 188)
  {
    v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/padding.c";
    v13 = 4;
    v14 = 127;
    v15 = 254;
    goto LABEL_42;
  }
  v70 = v30;
  v43 = v31 + ~pkey_type;
  if (v43 > 0xFFFFFFFFFFFFFFF7 || (len = v43, (v44 = (char *)malloc_type_malloc(v43 + 8, 0x30772F57uLL)) == 0))
  {
    v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v13 = 14;
    v14 = 65;
    v15 = 247;
    goto LABEL_42;
  }
  v69 = v44;
  *(_QWORD *)v44 = len;
  v68 = (unsigned __int8 *)(v44 + 8);
  if (!PKCS1_MGF1((unsigned __int8 *)v44 + 8, len, (const unsigned __int8 *)(v29 + len), pkey_type, v9))
    goto LABEL_70;
  if (!len)
    goto LABEL_57;
  if (len < 8 || v68 < &a5[v28 + ~pkey_type + v70 + v27] && v29 < (unint64_t)v69 + v70 + v27 - pkey_type + 7)
  {
    v45 = 0;
    goto LABEL_55;
  }
  if (len >= 0x20)
  {
    v45 = len & 0xFFFFFFFFFFFFFFE0;
    v59 = (int8x16_t *)&a5[v28 + 16];
    v60 = (int8x16_t *)(v69 + 3);
    v61 = len & 0xFFFFFFFFFFFFFFE0;
    do
    {
      v62 = veorq_s8(*v60, *v59);
      v60[-1] = veorq_s8(v60[-1], v59[-1]);
      *v60 = v62;
      v59 += 2;
      v60 += 2;
      v61 -= 32;
    }
    while (v61);
    if (len == v45)
      goto LABEL_57;
    if ((len & 0x18) == 0)
    {
LABEL_55:
      v46 = ~v45 + v70 + v27 - pkey_type;
      v47 = (char *)v69 + v45 + 8;
      v48 = &a5[v45 + v28];
      do
      {
        v49 = *v48++;
        *v47++ ^= v49;
        --v46;
      }
      while (v46);
      goto LABEL_57;
    }
  }
  else
  {
    v45 = 0;
  }
  v63 = v45;
  v45 = len & 0xFFFFFFFFFFFFFFF8;
  v64 = (int8x8_t *)&a5[v63 + v28];
  v65 = (int8x8_t *)((char *)v69 + v63 + 8);
  v66 = v63 - (len & 0xFFFFFFFFFFFFFFF8);
  do
  {
    v67 = *v64++;
    *v65 = veor_s8(*v65, v67);
    ++v65;
    v66 += 8;
  }
  while (v66);
  if (len != v45)
    goto LABEL_55;
LABEL_57:
  if (v24)
    *v68 &= 0xFFu >> (8 - v24);
  v50 = 0;
  do
  {
    v51 = v68[v50];
    v52 = v50 + 1;
    if (v50 >= len - 1)
      break;
    ++v50;
  }
  while (!v51);
  if (v51 != 1)
  {
    v53 = 139;
    v54 = 281;
    goto LABEL_69;
  }
  if ((v11 & 0x80000000) == 0 && ~(unint64_t)v11 + v70 + v27 - pkey_type != v52)
  {
    v53 = 138;
    v54 = 287;
LABEL_69:
    ERR_put_error(4, 0, v53, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/padding.c", v54);
    goto LABEL_70;
  }
  if (!EVP_DigestInit_ex(&ctx, a3, 0)
    || (((void (*)(EVP_MD_CTX *, void *, uint64_t))ctx.digest->init)(&ctx, &kPSSZeroes, 8),
        ((void (*)(EVP_MD_CTX *, uint64_t, size_t))ctx.digest->init)(&ctx, a2, pkey_type),
        ((void (*)(EVP_MD_CTX *, unsigned __int8 *, unint64_t))ctx.digest->init)(&ctx, &v68[v52], len - v52), !EVP_DigestFinal_ex(&ctx, md, 0)))
  {
LABEL_70:
    v41 = 0;
    v55 = v69;
    v56 = *v69 + 8;
    if (*v69 == -8)
      goto LABEL_72;
    goto LABEL_71;
  }
  if ((_DWORD)pkey_type && memcmp(md, (const void *)(v29 + len), pkey_type))
  {
    v53 = 105;
    v54 = 299;
    goto LABEL_69;
  }
  v41 = 1;
  v55 = v69;
  v56 = *v69 + 8;
  if (*v69 != -8)
  {
LABEL_71:
    bzero(v55, v56);
    v55 = v69;
  }
LABEL_72:
  free(v55);
  if (ctx.engine)
  {
    v58 = (char *)ctx.engine - 8;
    v57 = *((_QWORD *)ctx.engine - 1);
    if (v57 != -8)
      bzero((char *)ctx.engine - 8, v57 + 8);
    free(v58);
  }
LABEL_43:
  if (ctx.md_data)
    (*(void (**)(unint64_t))ctx.md_data)(ctx.flags);
  return v41;
}

uint64_t RSA_padding_add_PKCS1_PSS_mgf1(uint64_t **a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, const EVP_MD *a5, unsigned int a6)
{
  const EVP_MD *v6;
  uint64_t *v7;
  uint64_t v8;
  int8x16_t *v13;
  unint64_t v14;
  int8x8_t v15;
  int8x16_t *v16;
  int8x16_t v17;
  unint64_t v18;
  int8x16_t v19;
  int8x16_t v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t *v26;
  int v27;
  BOOL v28;
  const char *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  unsigned int (*v35)(void);
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  char v39;
  unint64_t v40;
  BOOL v41;
  BOOL v42;
  BOOL v43;
  BOOL v44;
  BOOL v45;
  BOOL v46;
  BOOL v47;
  char v48;
  uint64_t v49;
  _QWORD *v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  unsigned __int8 *v55;
  unint64_t v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  unsigned __int8 *v60;
  unint64_t v61;
  unint64_t v62;
  char *v63;
  _BYTE *v64;
  char v65;
  void *v66;
  uint64_t v67;
  size_t v68;
  int8x16_t *v69;
  int8x16_t *v70;
  unint64_t v71;
  int8x16_t v72;
  unint64_t v73;
  int8x8_t *v74;
  int8x8_t *v75;
  unint64_t v76;
  int8x8_t v77;
  unint64_t v78;
  EVP_MD_CTX ctx;

  if (a5)
    v6 = a5;
  else
    v6 = (const EVP_MD *)a4;
  v7 = a1[1];
  v8 = *((unsigned int *)v7 + 2);
  if (!(_DWORD)v8)
    goto LABEL_17;
  v13 = (int8x16_t *)*v7;
  if (v8 < 4)
  {
    v14 = 0;
    v15 = 0;
LABEL_10:
    v21 = (int)v8 - v14;
    v22 = &v13->i64[v14];
    do
    {
      v23 = *v22++;
      *(_QWORD *)&v15 |= v23;
      --v21;
    }
    while (v21);
    goto LABEL_12;
  }
  v14 = (int)v8 & 0xFFFFFFFFFFFFFFFCLL;
  v16 = v13 + 1;
  v17 = 0uLL;
  v18 = v14;
  v19 = 0uLL;
  do
  {
    v17 = vorrq_s8(v16[-1], v17);
    v19 = vorrq_s8(*v16, v19);
    v16 += 2;
    v18 -= 4;
  }
  while (v18);
  v20 = vorrq_s8(v19, v17);
  v15 = vorr_s8(*(int8x8_t *)v20.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL));
  if (v14 != (int)v8)
    goto LABEL_10;
LABEL_12:
  if (!*(_QWORD *)&v15)
  {
LABEL_17:
    v30 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/padding.c";
    v31 = 4;
    v32 = 120;
    v33 = 329;
    goto LABEL_43;
  }
  v24 = *(unsigned int *)(a4 + 4);
  v25 = v8 & ((int)v8 >> 31);
  v26 = &v13->i64[v8 - 1];
  v27 = *((_DWORD *)v7 + 2);
  while (1)
  {
    v28 = __OFSUB__(v27--, 1);
    if (v27 < 0 != v28)
      break;
    if (*v26--)
    {
      v25 = v27 + 1;
      goto LABEL_27;
    }
  }
  if ((v8 & 0x80000000) != 0)
  {
LABEL_27:
    v39 = v25 - 1;
    v40 = v13->u64[v25 - 1];
    v41 = v40 != 0;
    v42 = HIDWORD(v40) != 0;
    if (HIDWORD(v40))
      v40 >>= 32;
    v43 = v40 >> 16 != 0;
    if (v40 >> 16)
      v40 >>= 16;
    v44 = v40 > 0xFF;
    if (v40 > 0xFF)
      v40 >>= 8;
    v45 = v40 > 0xF;
    if (v40 > 0xF)
      v40 >>= 4;
    v46 = v40 > 3;
    if (v40 > 3)
      v40 >>= 2;
    v47 = v40 > 1;
    v48 = v41 | (v39 << 6) | (32 * v42) | (16 * v43) | (8 * v44) | (4 * v45) | (2 * v46);
    if (v47)
      ++v48;
    v34 = (v48 - 1) & 7;
    v35 = (unsigned int (*)(void))(*a1)[4];
    if (!v35)
    {
LABEL_20:
      v36 = BN_num_bytes(a1[1]);
      if (!v34)
        goto LABEL_21;
      goto LABEL_41;
    }
  }
  else
  {
    v34 = 7;
    v35 = (unsigned int (*)(void))(*a1)[4];
    if (!v35)
      goto LABEL_20;
  }
  v36 = v35();
  if (!v34)
  {
LABEL_21:
    *a2++ = 0;
    if (--v36 >= v24 + 2)
      goto LABEL_22;
LABEL_42:
    v30 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/padding.c";
    v31 = 4;
    v32 = 114;
    v33 = 342;
    goto LABEL_43;
  }
LABEL_41:
  if (v36 < v24 + 2)
    goto LABEL_42;
LABEL_22:
  v37 = v24;
  if (a6 == -1)
    goto LABEL_25;
  if (a6 == -2)
  {
    v37 = v36 - v24 - 2;
LABEL_25:
    v38 = v36 - v24;
    if (v36 - v24 - 2 < v37)
    {
LABEL_26:
      v30 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src"
            "/crypto/fipsmodule/rsa/padding.c";
      v31 = 4;
      v32 = 114;
      v33 = 363;
      goto LABEL_43;
    }
    goto LABEL_47;
  }
  if ((a6 & 0x80000000) != 0)
  {
    v30 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/padding.c";
    v31 = 4;
    v32 = 138;
    v33 = 356;
    goto LABEL_43;
  }
  v37 = a6;
  v38 = v36 - v24;
  if (v36 - v24 - 2 < v37)
    goto LABEL_26;
LABEL_47:
  if (v37)
  {
    if (v37 <= 0xFFFFFFFFFFFFFFF7)
    {
      v51 = malloc_type_malloc(v37 + 8, 0x30772F57uLL);
      if (v51)
      {
        *v51 = v37;
        v78 = (unint64_t)(v51 + 1);
        RAND_bytes_with_additional_data((uint64_t)(v51 + 1), v37, (uint64_t)&RAND_bytes_kZeroAdditionalData);
        goto LABEL_53;
      }
    }
    v30 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v31 = 14;
    v32 = 65;
    v33 = 247;
LABEL_43:
    ERR_put_error(v31, 0, v32, v30, v33);
    return 0;
  }
  v78 = 0;
LABEL_53:
  memset(&ctx, 0, sizeof(ctx));
  if (a4)
  {
    v52 = *(unsigned int *)(a4 + 44);
    v53 = (char *)malloc_type_malloc(v52 + 8, 0x30772F57uLL);
    if (!v53)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v49 = 0;
      memset(&ctx, 0, sizeof(ctx));
      v56 = v78;
      goto LABEL_71;
    }
    *(_QWORD *)v53 = v52;
    ctx.digest = (const EVP_MD *)a4;
    ctx.engine = (ENGINE *)(v53 + 8);
  }
  v54 = v38 - 1;
  v55 = &a2[v38 - 1];
  (*(void (**)(EVP_MD_CTX *))(a4 + 16))(&ctx);
  ((void (*)(EVP_MD_CTX *, void *, uint64_t))ctx.digest->init)(&ctx, &kPSSZeroes, 8);
  ((void (*)(EVP_MD_CTX *, uint64_t, uint64_t))ctx.digest->init)(&ctx, a3, v24);
  v56 = v78;
  ((void (*)(EVP_MD_CTX *, unint64_t, unint64_t))ctx.digest->init)(&ctx, v78, v37);
  v57 = EVP_DigestFinal_ex(&ctx, v55, 0);
  EVP_MD_CTX_cleanup(&ctx);
  if (v57 && PKCS1_MGF1(a2, v54, v55, v24, v6))
  {
    v58 = v37 + v24;
    v59 = v36 - (v37 + v24);
    v60 = &a2[v59 - 2];
    *v60 ^= 1u;
    if (!v37)
    {
LABEL_65:
      if (v34)
        *a2 &= 0xFFu >> (8 - v34);
      a2[v36 - 1] = -68;
      v49 = 1;
      goto LABEL_71;
    }
    if (v37 < 8 || (unint64_t)&a2[v36 - 1 - v58] < v78 + v37 && v78 < (unint64_t)&a2[v36 - 1 - v24])
    {
      v61 = 0;
      goto LABEL_63;
    }
    if (v37 >= 0x20)
    {
      v61 = v37 & 0xFFFFFFFFFFFFFFE0;
      v69 = (int8x16_t *)(v78 + 16);
      v70 = (int8x16_t *)&a2[v59 + 15];
      v71 = v37 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v72 = veorq_s8(*v70, *v69);
        v70[-1] = veorq_s8(v70[-1], v69[-1]);
        *v70 = v72;
        v69 += 2;
        v70 += 2;
        v71 -= 32;
      }
      while (v71);
      if (v37 == v61)
        goto LABEL_65;
      if ((v37 & 0x18) == 0)
      {
        v60 += v61;
LABEL_63:
        v62 = v37 - v61;
        v63 = (char *)(v78 + v61);
        v64 = v60 + 1;
        do
        {
          v65 = *v63++;
          *v64++ ^= v65;
          --v62;
        }
        while (v62);
        goto LABEL_65;
      }
    }
    else
    {
      v61 = 0;
    }
    v73 = v61;
    v61 = v37 & 0xFFFFFFFFFFFFFFF8;
    v60 += v37 & 0xFFFFFFFFFFFFFFF8;
    v74 = (int8x8_t *)&a2[~v58 + v73 + v36];
    v75 = (int8x8_t *)(v78 + v73);
    v76 = v73 - (v37 & 0xFFFFFFFFFFFFFFF8);
    do
    {
      v77 = *v75++;
      *v74 = veor_s8(*v74, v77);
      ++v74;
      v76 += 8;
    }
    while (v76);
    if (v37 == v61)
      goto LABEL_65;
    goto LABEL_63;
  }
  v49 = 0;
LABEL_71:
  if (v56)
  {
    v67 = *(_QWORD *)(v56 - 8);
    v66 = (void *)(v56 - 8);
    v68 = v67 + 8;
    if (v67 != -8)
      bzero(v66, v68);
    free(v66);
  }
  return v49;
}

BOOL PKCS5_PBKDF2_HMAC(void *key, int len, uint64_t a3, uint64_t a4, unsigned int a5, EVP_MD *md, size_t a7, int8x16_t *a8)
{
  size_t pkey_type;
  int v14;
  unsigned int v15;
  size_t v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int8x16_t *v26;
  int8x16_t *v27;
  int8x16_t v28;
  unsigned __int8 *v29;
  int8x8_t *v30;
  size_t v31;
  int8x8_t v32;
  size_t v33;
  __int8 *v34;
  unsigned __int8 *v35;
  char v36;
  int v37;
  int v38;
  _BOOL8 v39;
  unsigned int v40;
  size_t v41;
  int v42;
  int v43;
  unsigned int v45;
  unsigned int v46;
  HMAC_CTX ctx;

  *(_QWORD *)&ctx.key[68] = *MEMORY[0x24BDAC8D0];
  pkey_type = md->pkey_type;
  memset(&ctx, 0, 104);
  HMAC_Init_ex(&ctx, key, len, md, 0);
  if (!v14)
  {
LABEL_43:
    v39 = 0;
    goto LABEL_44;
  }
  if (a7)
  {
    if (a5 > 1)
    {
      v15 = 1;
      while (1)
      {
        if (pkey_type >= a7)
          v16 = a7;
        else
          v16 = pkey_type;
        v45 = v15;
        v46 = bswap32(v15);
        HMAC_Init_ex(&ctx, 0, 0, 0, 0);
        if (!v17)
          goto LABEL_43;
        ((void (*)(EVP_MD_CTX *, uint64_t, uint64_t))ctx.md_ctx.digest->init)(&ctx.md_ctx, a3, a4);
        ((void (*)(EVP_MD_CTX *, unsigned int *, uint64_t))ctx.md_ctx.digest->init)(&ctx.md_ctx, &v46, 4);
        HMAC_Final(&ctx, &ctx.key[4], 0);
        if (!v18)
          goto LABEL_43;
        v19 = a5 - 1;
        if (v16)
          break;
        do
        {
          HMAC_Init_ex(&ctx, 0, 0, 0, 0);
          if (!v37)
            goto LABEL_43;
          ((void (*)(EVP_MD_CTX *, unsigned __int8 *, size_t))ctx.md_ctx.digest->init)(&ctx.md_ctx, &ctx.key[4], pkey_type);
          HMAC_Final(&ctx, &ctx.key[4], 0);
          if (!v38)
            goto LABEL_43;
          --v19;
        }
        while (v19);
LABEL_32:
        a8 = (int8x16_t *)((char *)a8 + v16);
        v15 = v45 + 1;
        a7 -= v16;
        if (!a7)
          goto LABEL_33;
      }
      memcpy(a8, &ctx.key[4], v16);
      v20 = 1;
      while (1)
      {
        HMAC_Init_ex(&ctx, 0, 0, 0, 0);
        if (!v21)
          goto LABEL_43;
        ((void (*)(EVP_MD_CTX *, unsigned __int8 *, size_t))ctx.md_ctx.digest->init)(&ctx.md_ctx, &ctx.key[4], pkey_type);
        HMAC_Final(&ctx, &ctx.key[4], 0);
        if (!v22)
          goto LABEL_43;
        if (v16 >= 8)
        {
          if (v16 < 0x20)
          {
            v24 = 0;
LABEL_23:
            v29 = &ctx.key[v24 + 4];
            v30 = (int8x8_t *)&a8->i8[v24];
            v31 = v24 - (v16 & 0xFFFFFFFFFFFFFFF8);
            do
            {
              v32 = *(int8x8_t *)v29;
              v29 += 8;
              *v30 = veor_s8(*v30, v32);
              ++v30;
              v31 += 8;
            }
            while (v31);
            v23 = v16 & 0xFFFFFFFFFFFFFFF8;
            if (v16 == (v16 & 0xFFFFFFFFFFFFFFF8))
              goto LABEL_12;
            goto LABEL_26;
          }
          v25 = v16 & 0xFFFFFFFFFFFFFFE0;
          v26 = a8 + 1;
          v27 = (int8x16_t *)&ctx.key[20];
          do
          {
            v28 = veorq_s8(*v26, *v27);
            v26[-1] = veorq_s8(v26[-1], v27[-1]);
            *v26 = v28;
            v27 += 2;
            v26 += 2;
            v25 -= 32;
          }
          while (v25);
          if (v16 == (v16 & 0xFFFFFFFFFFFFFFE0))
            goto LABEL_12;
          v23 = v16 & 0xFFFFFFFFFFFFFFE0;
          v24 = v16 & 0xFFFFFFFFFFFFFFE0;
          if ((v16 & 0x18) != 0)
            goto LABEL_23;
        }
        else
        {
          v23 = 0;
        }
LABEL_26:
        v33 = v16 - v23;
        v34 = &a8->i8[v23];
        v35 = &ctx.key[v23 + 4];
        do
        {
          v36 = *v35++;
          *v34++ ^= v36;
          --v33;
        }
        while (v33);
LABEL_12:
        if (++v20 == a5)
          goto LABEL_32;
      }
    }
    v40 = 1;
    do
    {
      v41 = pkey_type >= a7 ? a7 : pkey_type;
      v46 = bswap32(v40);
      HMAC_Init_ex(&ctx, 0, 0, 0, 0);
      if (!v42)
        goto LABEL_43;
      ((void (*)(EVP_MD_CTX *, uint64_t, uint64_t))ctx.md_ctx.digest->init)(&ctx.md_ctx, a3, a4);
      ((void (*)(EVP_MD_CTX *, unsigned int *, uint64_t))ctx.md_ctx.digest->init)(&ctx.md_ctx, &v46, 4);
      HMAC_Final(&ctx, &ctx.key[4], 0);
      if (!v43)
        goto LABEL_43;
      if (v41)
        memcpy(a8, &ctx.key[4], v41);
      a8 = (int8x16_t *)((char *)a8 + v41);
      ++v40;
      a7 -= v41;
    }
    while (a7);
  }
LABEL_33:
  v39 = a5 != 0;
LABEL_44:
  HMAC_CTX_cleanup(&ctx);
  return v39;
}

int PEM_bytes_read_bio(unsigned __int8 **pdata, uint64_t *plen, char **pnm, const char *name, BIO *bp, pem_password_cb *cb, void *u)
{
  char *v9;
  int v10;
  int v11;
  char *v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unsigned __int8 *v18;
  char *v19;
  unsigned __int8 *v20;
  char *v21;
  uint64_t v22;
  size_t v23;
  int v24;
  char *v25;
  uint64_t v26;
  size_t v27;
  char *v28;
  uint64_t v29;
  size_t v30;
  uint64_t v31;
  unsigned __int8 *v32;
  uint64_t len;
  unsigned __int8 *data;
  char *header;
  char *namea;
  EVP_CIPHER_INFO cipher;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  memset(&cipher, 0, sizeof(cipher));
  header = 0;
  namea = 0;
  len = 0;
  data = 0;
  if (PEM_read_bio(bp, &namea, &header, &data, &len))
  {
    while (1)
    {
      v9 = namea;
      if (!strcmp(namea, name))
        break;
      if (!strcmp(name, "ANY PRIVATE KEY"))
      {
        if (!strcmp(v9, "ENCRYPTED PRIVATE KEY")
          || !strcmp(v9, "PRIVATE KEY")
          || !strcmp(v9, "RSA PRIVATE KEY")
          || !strcmp(v9, "EC PRIVATE KEY")
          || !strcmp(v9, "DSA PRIVATE KEY"))
        {
          break;
        }
      }
      else
      {
        v10 = strcmp(v9, "X509 CERTIFICATE");
        if (!v10 && !strcmp(name, "CERTIFICATE"))
          break;
        if (!strcmp(v9, "NEW CERTIFICATE REQUEST") && !strcmp(name, "CERTIFICATE REQUEST"))
          break;
        v11 = strcmp(v9, "CERTIFICATE");
        if (!v11 && !strcmp(name, "TRUSTED CERTIFICATE"))
          break;
        if (!v10 && !strcmp(name, "TRUSTED CERTIFICATE")
          || !v11 && !strcmp(name, "PKCS7")
          || !strcmp(v9, "PKCS #7 SIGNED DATA") && !strcmp(name, "PKCS7"))
        {
          break;
        }
      }
      if (v9)
      {
        v13 = *((_QWORD *)v9 - 1);
        v12 = v9 - 8;
        v14 = v13 + 8;
        if (v13 != -8)
          bzero(v12, v14);
        free(v12);
      }
      if (header)
      {
        v16 = header - 8;
        v15 = *((_QWORD *)header - 1);
        if (v15 != -8)
          bzero(v16, v15 + 8);
        free(v16);
      }
      if (data)
      {
        v18 = data - 8;
        v17 = *((_QWORD *)data - 1);
        if (v17 != -8)
          bzero(v18, v17 + 8);
        free(v18);
      }
      if (!PEM_read_bio(bp, &namea, &header, &data, &len))
        goto LABEL_44;
    }
    v19 = header;
    if (PEM_get_EVP_CIPHER_INFO(header, &cipher) && (v20 = data, PEM_do_header(&cipher, data, &len, cb, u)))
    {
      *pdata = v20;
      *plen = len;
      if (pnm)
      {
        *pnm = v9;
        if (v19)
        {
          v22 = *((_QWORD *)v19 - 1);
          v21 = v19 - 8;
          v23 = v22 + 8;
          if (v22 != -8)
            bzero(v21, v23);
          free(v21);
        }
        return 1;
      }
      v24 = 1;
      if (!v9)
        goto LABEL_51;
    }
    else
    {
      v24 = 0;
      if (!v9)
      {
LABEL_51:
        if (v19)
        {
          v29 = *((_QWORD *)v19 - 1);
          v28 = v19 - 8;
          v30 = v29 + 8;
          if (v29 != -8)
            bzero(v28, v30);
          free(v28);
        }
        if ((v24 & 1) == 0 && data)
        {
          v32 = data - 8;
          v31 = *((_QWORD *)data - 1);
          if (v31 != -8)
            bzero(v32, v31 + 8);
          free(v32);
        }
        return v24;
      }
    }
    v26 = *((_QWORD *)v9 - 1);
    v25 = v9 - 8;
    v27 = v26 + 8;
    if (v26 != -8)
      bzero(v25, v27);
    free(v25);
    goto LABEL_51;
  }
LABEL_44:
  if ((ERR_peek_error() & 0xFF000FFF) == 0x900006E)
    ERR_add_error_data(2, "Expecting: ", name);
  return 0;
}

int PEM_read_bio(BIO *bp, char **name, char **header, unsigned __int8 **data, uint64_t *len)
{
  _QWORD *v10;
  BUF_MEM *v11;
  _QWORD *v12;
  BUF_MEM *v13;
  char *v14;
  unsigned __int8 **v15;
  BOOL v16;
  BIO_METHOD *method;
  int (__cdecl *bgets)(BIO *, char *, int);
  int v19;
  BOOL v20;
  size_t v22;
  char *v23;
  BIO_METHOD *v24;
  int v25;
  int (__cdecl *v26)(BIO *, char *, int);
  int v27;
  size_t v28;
  uint64_t v29;
  char *v31;
  char *v32;
  uint64_t v33;
  size_t v34;
  int *p_max;
  uint64_t v36;
  size_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  size_t v41;
  int *v42;
  uint64_t v43;
  size_t v44;
  int v45;
  int v46;
  char *v47;
  char *v48;
  uint64_t v49;
  size_t v50;
  int *v51;
  uint64_t v52;
  size_t v53;
  char *v54;
  char *v55;
  uint64_t v56;
  size_t v57;
  int *v58;
  uint64_t v59;
  size_t v60;
  unsigned __int8 *v61;
  unsigned __int8 *v62;
  uint64_t v63;
  size_t v64;
  char *v65;
  uint64_t v66;
  size_t v67;
  int v69;
  _QWORD *v70;
  int (__cdecl *v71)(BIO *, char *, int);
  int v72;
  size_t v73;
  BOOL v74;
  _BOOL4 v75;
  int v76;
  BUF_MEM *v77;
  int v78;
  int v79;
  BOOL v80;
  size_t v81;
  int v82;
  int v83;
  uint64_t v84;
  unsigned __int8 **v85;
  uint64_t *v86;
  char **v87;
  int outl;
  _BYTE __src[11];
  char v90[245];
  EVP_ENCODE_CTX ctx;

  *(_QWORD *)&ctx.enc_data[48] = *MEMORY[0x24BDAC8D0];
  outl = 0;
  v10 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (v10)
  {
    *v10 = 24;
    v10[1] = 0;
    v11 = (BUF_MEM *)(v10 + 1);
    v10[2] = 0;
    v10[3] = 0;
    v12 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (v12)
      goto LABEL_3;
LABEL_51:
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v13 = 0;
    v14 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (v14)
      goto LABEL_4;
LABEL_52:
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v15 = 0;
    v16 = v13 == 0;
    goto LABEL_53;
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  v11 = 0;
  v12 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v12)
    goto LABEL_51;
LABEL_3:
  *v12 = 24;
  v12[1] = 0;
  v13 = (BUF_MEM *)(v12 + 1);
  v12[2] = 0;
  v12[3] = 0;
  v14 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v14)
    goto LABEL_52;
LABEL_4:
  v87 = name;
  *(_QWORD *)v14 = 24;
  *((_QWORD *)v14 + 1) = 0;
  v15 = (unsigned __int8 **)(v14 + 8);
  *((_QWORD *)v14 + 2) = 0;
  *((_QWORD *)v14 + 3) = 0;
  v16 = v13 == 0;
  if (!v11 || !v13)
  {
LABEL_53:
    if (v11)
    {
      v31 = v11->data;
      if (v31)
      {
        v33 = *((_QWORD *)v31 - 1);
        v32 = v31 - 8;
        v34 = v33 + 8;
        if (v33 != -8)
          bzero(v32, v34);
        free(v32);
      }
      v36 = *(_QWORD *)&v11[-1].max;
      p_max = &v11[-1].max;
      v37 = v36 + 8;
      if (v36 != -8)
        bzero(p_max, v37);
      free(p_max);
    }
    if (!v16)
    {
      v38 = v13->data;
      if (v38)
      {
        v40 = *((_QWORD *)v38 - 1);
        v39 = v38 - 8;
        v41 = v40 + 8;
        if (v40 != -8)
          bzero(v39, v41);
        free(v39);
      }
      v43 = *(_QWORD *)&v13[-1].max;
      v42 = &v13[-1].max;
      v44 = v43 + 8;
      if (v43 != -8)
        bzero(v42, v44);
      free(v42);
    }
    if (!v14)
      return 0;
    goto LABEL_88;
  }
  v85 = data;
  v86 = len;
  memset(&ctx, 0, 56);
  v90[243] = 0;
  if (!bp || (method = bp->method) == 0)
  {
LABEL_71:
    v45 = 115;
    v46 = 148;
LABEL_72:
    ERR_put_error(17, 0, v45, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v46);
LABEL_73:
    ERR_put_error(9, 0, 110, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_lib.c", 629);
    goto LABEL_74;
  }
  while (1)
  {
    bgets = method->bgets;
    if (!bgets)
      goto LABEL_71;
    if (!LODWORD(bp->cb_arg))
    {
      v45 = 114;
      v46 = 152;
      goto LABEL_72;
    }
    v19 = ((uint64_t (*)(BIO *, _BYTE *, uint64_t))bgets)(bp, __src, 254);
    if (v19 < 1)
      goto LABEL_73;
    bp->next_bio = (bio_st *)((char *)bp->next_bio + v19);
    while ((char)__src[v19] <= 32)
    {
      v20 = v19-- <= 0;
      if (v20)
      {
        v19 = -1;
        break;
      }
    }
    __src[v19 + 1] = 10;
    __src[v19 + 2] = 0;
    if (*(_QWORD *)__src == 0x4745422D2D2D2D2DLL && *(_QWORD *)&__src[3] == 0x204E494745422D2DLL)
    {
      v22 = strlen(v90) << 32;
      if (!strncmp(&__src[(uint64_t)(v22 + 0x500000000) >> 32], "-----\n", 6uLL))
        break;
    }
    method = bp->method;
    if (!bp->method)
      goto LABEL_71;
  }
  if (!BUF_MEM_grow(v11, (v22 + 0x900000000) >> 32))
    goto LABEL_74;
  if (v22 != 0x600000000)
    memcpy(v11->data, v90, (uint64_t)(v22 - 0x600000000) >> 32);
  v11->data[(uint64_t)(v22 - 0x600000000) >> 32] = 0;
  if (*(_QWORD *)&v13->max <= 0xFFuLL)
  {
    v23 = (char *)OPENSSL_realloc((_QWORD *)v13->data, 0x158uLL);
    if (!v23)
      goto LABEL_74;
    v13->data = v23;
    *(_QWORD *)&v13->max = 344;
  }
  if (*(_QWORD *)&v13->length <= 0xFFuLL)
    bzero(&v13->data[*(_QWORD *)&v13->length], 256 - *(_QWORD *)&v13->length);
  *(_QWORD *)&v13->length = 256;
  *v13->data = 0;
  v24 = bp->method;
  if (bp->method)
  {
    v25 = 0;
    while (1)
    {
      v26 = v24->bgets;
      if (!v26)
      {
        LODWORD(v29) = v25;
        goto LABEL_99;
      }
      if (!LODWORD(bp->cb_arg))
      {
        ERR_put_error(17, 0, 114, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 152);
LABEL_101:
        v69 = 1;
        goto LABEL_103;
      }
      v27 = ((uint64_t (*)(BIO *, _BYTE *, uint64_t))v26)(bp, __src, 254);
      if (v27 < 1)
        goto LABEL_101;
      bp->next_bio = (bio_st *)((char *)bp->next_bio + v27);
      while ((char)__src[v27] <= 32)
      {
        v20 = v27-- <= 0;
        if (v20)
        {
          v27 = -1;
          break;
        }
      }
      __src[v27 + 1] = 10;
      v28 = (v27 + 2);
      __src[v28] = 0;
      if (__src[0] == 10)
        goto LABEL_101;
      v29 = v25 + (uint64_t)(int)v28;
      if (!BUF_MEM_grow(v13, v29 + 9))
        goto LABEL_74;
      if (*(_QWORD *)__src == 0x444E452D2D2D2D2DLL && __src[8] == 32)
        break;
      memcpy(&v13->data[v25], __src, v28);
      v13->data[v29] = 0;
      v24 = bp->method;
      v25 += v28;
      if (!bp->method)
        goto LABEL_99;
    }
    v69 = 0;
  }
  else
  {
    LODWORD(v29) = 0;
LABEL_99:
    ERR_put_error(17, 0, 115, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 148);
    v69 = 1;
    v25 = v29;
  }
LABEL_103:
  outl = 0;
  if (*((_QWORD *)v14 + 3) <= 0x3FFuLL)
  {
    v70 = OPENSSL_realloc(*((_QWORD **)v14 + 2), 0x558uLL);
    if (!v70)
      goto LABEL_74;
    *((_QWORD *)v14 + 2) = v70;
    *((_QWORD *)v14 + 3) = 1368;
  }
  if ((unint64_t)*v15 <= 0x3FF)
    bzero(&(*v15)[*((_QWORD *)v14 + 2)], 1024 - (_QWORD)*v15);
  *((_QWORD *)v14 + 1) = 1024;
  **((_BYTE **)v14 + 2) = 0;
  if (v69)
  {
    v25 = 0;
    while (bp->method)
    {
      v71 = bp->method->bgets;
      if (!v71)
        break;
      if (!LODWORD(bp->cb_arg))
      {
        outl = v25;
        v78 = 114;
        v79 = 152;
        goto LABEL_139;
      }
      v72 = ((uint64_t (*)(BIO *, _BYTE *, uint64_t))v71)(bp, __src, 254);
      if (v72 < 1)
        goto LABEL_137;
      bp->next_bio = (bio_st *)((char *)bp->next_bio + v72);
      while ((char)__src[v72] <= 32)
      {
        v20 = v72-- <= 0;
        if (v20)
        {
          v72 = -1;
          break;
        }
      }
      __src[v72 + 1] = 10;
      v73 = (v72 + 2);
      __src[v73] = 0;
      v74 = *(_QWORD *)__src == 0x444E452D2D2D2D2DLL && __src[8] == 32;
      v75 = !v74;
      if (v72 > 63 || !v75)
      {
LABEL_137:
        outl = v25;
LABEL_140:
        v77 = v13;
        goto LABEL_141;
      }
      if (!BUF_MEM_grow((BUF_MEM *)(v14 + 8), v25 + v72 + 11))
      {
        outl = v25;
        goto LABEL_74;
      }
      memcpy((void *)(*((_QWORD *)v14 + 2) + v25), __src, v73);
      *(_BYTE *)(*((_QWORD *)v14 + 2) + v25 + (uint64_t)(int)v73) = 0;
      v25 += v73;
      if ((_DWORD)v73 != 65)
      {
        outl = v25;
        __src[0] = 0;
        v76 = BIO_gets(bp, __src, 254);
        if (v76 >= 1)
        {
          while ((char)__src[v76] <= 32)
          {
            v20 = v76-- <= 0;
            if (v20)
            {
              v76 = -1;
              break;
            }
          }
          __src[v76 + 1] = 10;
          __src[v76 + 2] = 0;
        }
        goto LABEL_140;
      }
    }
    outl = v25;
    v78 = 115;
    v79 = 148;
LABEL_139:
    ERR_put_error(17, 0, v78, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v79);
    goto LABEL_140;
  }
  outl = v25;
  v77 = (BUF_MEM *)(v14 + 8);
  v15 = (unsigned __int8 **)v13;
LABEL_141:
  v80 = *(_QWORD *)__src == 0x444E452D2D2D2D2DLL && __src[8] == 32;
  if (!v80
    || (v81 = strlen(v11->data), strncmp(v11->data, &__src[9], (int)v81))
    || strncmp(&__src[(uint64_t)((v81 << 32) + 0x900000000) >> 32], "-----\n", 6uLL))
  {
    v82 = 102;
    v83 = 744;
LABEL_149:
    ERR_put_error(9, 0, v82, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_lib.c", v83);
    v13 = v77;
    goto LABEL_74;
  }
  memset(&ctx, 0, 56);
  if (EVP_DecodeUpdate(&ctx, v15[1], &outl, v15[1], v25) < 0)
  {
    v82 = 100;
    v83 = 752;
    goto LABEL_149;
  }
  if (ctx.enc_data[45] || ctx.num)
  {
    v82 = 100;
    v83 = 757;
    goto LABEL_149;
  }
  v84 = outl;
  if (!outl)
  {
    v13 = v77;
LABEL_74:
    v47 = v11->data;
    if (v47)
    {
      v49 = *((_QWORD *)v47 - 1);
      v48 = v47 - 8;
      v50 = v49 + 8;
      if (v49 != -8)
        bzero(v48, v50);
      free(v48);
    }
    v52 = *(_QWORD *)&v11[-1].max;
    v51 = &v11[-1].max;
    v53 = v52 + 8;
    if (v52 != -8)
      bzero(v51, v53);
    free(v51);
    if (v13)
    {
      v54 = v13->data;
      if (v54)
      {
        v56 = *((_QWORD *)v54 - 1);
        v55 = v54 - 8;
        v57 = v56 + 8;
        if (v56 != -8)
          bzero(v55, v57);
        free(v55);
      }
      v59 = *(_QWORD *)&v13[-1].max;
      v58 = &v13[-1].max;
      v60 = v59 + 8;
      if (v59 != -8)
        bzero(v58, v60);
      free(v58);
    }
LABEL_88:
    v61 = v15[1];
    if (v61)
    {
      v63 = *((_QWORD *)v61 - 1);
      v62 = v61 - 8;
      v64 = v63 + 8;
      if (v63 != -8)
        bzero(v62, v64);
      free(v62);
    }
    v66 = (uint64_t)*(v15 - 1);
    v65 = (char *)(v15 - 1);
    v67 = v66 + 8;
    if (v66 != -8)
      bzero(v65, v67);
    free(v65);
    return 0;
  }
  *v87 = v11->data;
  *header = v77->data;
  *v85 = v15[1];
  *v86 = v84;
  OPENSSL_free(v11);
  OPENSSL_free(v77);
  OPENSSL_free(v15);
  return 1;
}

int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
{
  unsigned __int8 *iv;
  int v7;
  int v8;
  const char *v9;
  int v10;
  const char *v11;
  int v12;
  int v13;
  char v15;
  const EVP_CIPHER *v16;
  size_t iv_len;
  const char *v18;

  cipher->cipher = 0;
  *(_QWORD *)cipher->iv = 0;
  iv = cipher->iv;
  *(_QWORD *)&cipher->iv[8] = 0;
  if (!header)
    return 1;
  if (!*header || *header == 10)
    return 1;
  if (strncmp(header, "Proc-Type: ", 0xBuLL))
  {
    v7 = 109;
    v8 = 438;
LABEL_10:
    ERR_put_error(9, 0, v7, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_lib.c", v8);
    return 0;
  }
  if (header[11] != 52 || header[12] != 44)
    return 0;
  if (strncmp(header + 13, "ENCRYPTED", 9uLL))
  {
    v7 = 108;
    v8 = 451;
    goto LABEL_10;
  }
  v9 = header + 24;
  v10 = *((unsigned __int8 *)v9 - 11);
  if (!*(v9 - 11))
  {
LABEL_19:
    v7 = 112;
    v8 = 458;
    goto LABEL_10;
  }
  while (v10 != 10)
  {
    v10 = *((unsigned __int8 *)++v9 - 11);
    if (!*(v9 - 11))
      goto LABEL_19;
  }
  if (strncmp(v9 - 10, "DEK-Info: ", 0xAuLL))
  {
    v7 = 107;
    v8 = 463;
    goto LABEL_10;
  }
  v11 = v9;
  do
  {
    do
    {
      v18 = v11;
      v13 = *v11++;
      v12 = v13;
    }
    while (v13 == 45);
  }
  while ((v12 - 91) > 0xE5u || (v12 - 58) > 0xFFFFFFF5);
  v15 = v12;
  *((_BYTE *)v11 - 1) = 0;
  v16 = (const EVP_CIPHER *)cipher_by_name(v9);
  cipher->cipher = v16;
  *((_BYTE *)v11 - 1) = v15;
  v18 = v11;
  if (!v16)
  {
    v7 = 114;
    v8 = 483;
    goto LABEL_10;
  }
  iv_len = v16->iv_len;
  if (iv_len <= 7)
  {
    v7 = 114;
    v8 = 490;
    goto LABEL_10;
  }
  return load_iv((uint64_t *)&v18, iv, iv_len);
}

int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned __int8 *data, uint64_t *len, pem_password_cb *callback, void *u)
{
  uint64_t v8;
  int (__cdecl *v9)(char *, int, int, void *);
  int v10;
  int v11;
  const EVP_CIPHER *v12;
  int result;
  ENGINE *v14;
  uint64_t v15;
  int v16;
  int (__cdecl *cleanup)(EVP_CIPHER_CTX *);
  uint64_t v18;
  void *v19;
  int v20;
  int v21;
  int (__cdecl *v22)(EVP_CIPHER_CTX *);
  uint64_t v23;
  void *v24;
  int v25;
  int outl;
  unsigned __int8 dataa[1024];
  __int128 key;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  EVP_CIPHER_CTX ctx;

  *(_QWORD *)&ctx.final[16] = *MEMORY[0x24BDAC8D0];
  outl = 0;
  if (!cipher->cipher)
    return 1;
  v8 = *len;
  v9 = PEM_def_callback;
  if (callback)
    v9 = callback;
  v10 = ((uint64_t (*)(unsigned __int8 *, uint64_t, _QWORD, void *))v9)(dataa, 1024, 0, u);
  if (v10 <= 0)
  {
    v20 = 104;
    v21 = 397;
LABEL_29:
    ERR_put_error(9, 0, v20, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_lib.c", v21);
    return 0;
  }
  v11 = v10;
  v12 = cipher->cipher;
  if (pthread_once(&EVP_md5_once, (void (*)(void))EVP_md5_init))
    abort();
  result = EVP_BytesToKey(v12, (const EVP_MD *)&EVP_md5_storage, cipher->iv, dataa, v11, 1, (unsigned __int8 *)&key, 0);
  if (result)
  {
    v25 = v8;
    memset(&ctx, 0, 152);
    if (EVP_CipherInit_ex(&ctx, cipher->cipher, v14, (const unsigned __int8 *)&key, cipher->iv, 0)
      && EVP_DecryptUpdate(&ctx, data, &outl, data, v8))
    {
      v15 = outl;
      v16 = EVP_DecryptFinal_ex(&ctx, &data[outl], &v25);
      if (ctx.cipher)
      {
        cleanup = ctx.cipher->cleanup;
        if (cleanup)
          ((void (*)(EVP_CIPHER_CTX *))cleanup)(&ctx);
      }
      if (*(_QWORD *)&ctx.encrypt)
      {
        v19 = (void *)(*(_QWORD *)&ctx.encrypt - 8);
        v18 = *(_QWORD *)(*(_QWORD *)&ctx.encrypt - 8);
        if (v18 != -8)
          bzero(v19, v18 + 8);
        free(v19);
      }
      memset(&ctx, 0, 152);
      bzero(dataa, 0x400uLL);
      v30 = 0u;
      v31 = 0u;
      key = 0u;
      v29 = 0u;
      if (v16)
      {
        *len = v25 + v15;
        return 1;
      }
    }
    else
    {
      if (ctx.cipher)
      {
        v22 = ctx.cipher->cleanup;
        if (v22)
          ((void (*)(EVP_CIPHER_CTX *))v22)(&ctx);
      }
      if (*(_QWORD *)&ctx.encrypt)
      {
        v24 = (void *)(*(_QWORD *)&ctx.encrypt - 8);
        v23 = *(_QWORD *)(*(_QWORD *)&ctx.encrypt - 8);
        if (v23 != -8)
          bzero(v24, v23 + 8);
        free(v24);
      }
      memset(&ctx, 0, 152);
      bzero(dataa, 0x400uLL);
      v30 = 0u;
      v31 = 0u;
      key = 0u;
      v29 = 0u;
    }
    v20 = 101;
    v21 = 419;
    goto LABEL_29;
  }
  return result;
}

int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp, char *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  unsigned int nid;
  char **v18;
  const char *v19;
  int v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  int v24;
  unint64_t iv_len;
  BIO *v26;
  int (__cdecl *v27)(char *, int, int, void *);
  int v28;
  uint64_t v29;
  BOOL v30;
  int v31;
  int v32;
  int v33;
  unsigned __int8 *v34;
  uint64_t v35;
  size_t v36;
  const char *v38;
  int v39;
  int v40;
  int v41;
  size_t v42;
  int (__cdecl *bwrite)(BIO *, const char *, int);
  size_t v44;
  int v45;
  int (__cdecl *v46)(BIO *, const char *, int);
  int v47;
  _BYTE *v48;
  _BYTE *v49;
  uint64_t v50;
  unint64_t v51;
  char *v52;
  uint64_t v53;
  char *v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  size_t v63;
  ENGINE *v64;
  char *v65;
  unsigned __int8 *v66;
  unint64_t v67;
  unsigned int v68;
  void (*v69)(_BYTE *);
  uint64_t v70;
  void *v71;
  int v72;
  int v73;
  int (__cdecl *v74)(BIO *, const char *, int);
  int v75;
  size_t v76;
  int (__cdecl *v77)(BIO *, const char *, int);
  int v78;
  int (__cdecl *v79)(BIO *, const char *, int);
  int v80;
  uint64_t v81;
  unsigned __int8 *v82;
  int v83;
  int v84;
  BIO *v85;
  int v86;
  int v87;
  int v88;
  BOOL v89;
  uint64_t v90;
  int v91;
  int (__cdecl *v92)(BIO *, const char *, int);
  const char *v93;
  int v94;
  int v95;
  int v96;
  uint64_t v97;
  int v98;
  int (__cdecl *v99)(BIO *, const char *, int);
  int v100;
  int v101;
  unsigned __int8 *v102;
  char *__s;
  BIO *b;
  _QWORD *v105;
  int outl;
  int v107;
  int v108;
  unsigned __int8 salt[8];
  uint64_t v110;
  unsigned __int8 key[16];
  __int128 v112;
  __int128 v113;
  __int128 v114;
  char v115[1023];
  char v116;
  _BYTE ctx[216];
  uint64_t v118;

  v118 = *MEMORY[0x24BDAC8D0];
  memset(ctx, 0, 152);
  outl = 0;
  v107 = 0;
  v105 = 0;
  if (!enc)
  {
    v19 = 0;
    goto LABEL_8;
  }
  nid = enc->nid;
  if (enc->nid)
  {
    if (nid > 0x3C4)
    {
      if (pthread_rwlock_rdlock(&global_added_lock) || pthread_rwlock_unlock(&global_added_lock))
LABEL_202:
        abort();
    }
    else
    {
      v18 = &kObjects[5 * nid - 5];
      if (*((_DWORD *)v18 + 4))
      {
        v19 = *v18;
        if (!*v18)
          goto LABEL_32;
        goto LABEL_26;
      }
    }
    ERR_put_error(8, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/obj/obj.c", 373);
LABEL_32:
    v31 = 113;
    v32 = 292;
LABEL_34:
    ERR_put_error(9, 0, v31, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_lib.c", v32);
    v33 = 0;
    v23 = 0;
    goto LABEL_35;
  }
  v19 = "UNDEF";
  if (!"UNDEF")
    goto LABEL_32;
LABEL_26:
  if (!cipher_by_name(v19) || enc->iv_len <= 7u)
    goto LABEL_32;
LABEL_8:
  v20 = ((uint64_t (*)(char *, _QWORD))i2d)(x, 0);
  if (v20 < 0)
  {
    v31 = 12;
    v32 = 298;
    goto LABEL_34;
  }
  __s = (char *)name;
  b = bp;
  v21 = (v20 + 20);
  v22 = (unsigned __int8 *)malloc_type_malloc(v21 + 8, 0x30772F57uLL);
  v23 = v22;
  if (!v22)
  {
    v38 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v39 = 14;
    v40 = 65;
    v41 = 247;
    goto LABEL_41;
  }
  *(_QWORD *)v22 = v21;
  v23 = v22 + 8;
  v105 = v22 + 8;
  v24 = ((uint64_t (*)(char *, _QWORD **))i2d)(x, &v105);
  v107 = v24;
  if (!enc)
  {
    v115[0] = 0;
    v26 = b;
    goto LABEL_43;
  }
  iv_len = enc->iv_len;
  v26 = b;
  if (!kstr)
  {
    v27 = PEM_def_callback;
    if (cb)
      v27 = cb;
    kstr = (unsigned __int8 *)v115;
    v28 = ((uint64_t (*)(char *, uint64_t, uint64_t, void *))v27)(v115, 1024, 1, u);
    if (v28 > 0)
    {
      klen = v28;
      goto LABEL_16;
    }
    v38 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/pem/pem_lib.c";
    v39 = 9;
    v40 = 111;
    v41 = 321;
LABEL_41:
    ERR_put_error(v39, 0, v40, v38, v41);
    v33 = 0;
    goto LABEL_35;
  }
LABEL_16:
  RAND_bytes_with_additional_data((uint64_t)salt, iv_len, (uint64_t)&RAND_bytes_kZeroAdditionalData);
  if (pthread_once(&EVP_md5_once, (void (*)(void))EVP_md5_init))
    goto LABEL_202;
  if (!EVP_BytesToKey(enc, (const EVP_MD *)&EVP_md5_storage, salt, kstr, klen, 1, key, 0))
  {
    v33 = 0;
    goto LABEL_35;
  }
  if (kstr == (unsigned __int8 *)v115)
    bzero(&v115[14], 0x3F2uLL);
  strcpy(v115, "Proc-Type: 4,");
  v29 = -1024;
  while (ctx[v29])
  {
    v30 = __CFADD__(v29++, 1);
    if (v30)
      goto LABEL_63;
  }
  v48 = &ctx[v29];
  if ((unint64_t)-v29 >= 2)
  {
    v49 = &ctx[v29 + 1];
    *v48 = 69;
    if (v29 != -2)
    {
      v48 = &ctx[v29 + 2];
      *v49 = 78;
      if (v29 == -3)
        goto LABEL_62;
      v49 = &ctx[v29 + 3];
      *v48 = 67;
      if (v29 != -4)
      {
        v48 = &ctx[v29 + 4];
        *v49 = 82;
        if (v29 == -5)
          goto LABEL_62;
        v49 = &ctx[v29 + 5];
        *v48 = 89;
        if (v29 != -6)
        {
          v48 = &ctx[v29 + 6];
          *v49 = 80;
          if (v29 == -7)
            goto LABEL_62;
          v49 = &ctx[v29 + 7];
          *v48 = 84;
          if (v29 != -8)
          {
            v48 = &ctx[v29 + 8];
            *v49 = 69;
            if (v29 != -9)
            {
              *v48 = 68;
              v48 = &ctx[v29 + 9];
            }
            goto LABEL_62;
          }
        }
      }
    }
    v48 = v49;
  }
LABEL_62:
  *v48 = 0;
LABEL_63:
  v50 = 0;
  while (v115[v50])
  {
    if (++v50 == 1024)
      goto LABEL_70;
  }
  v51 = 1024 - v50;
  v52 = &v115[v50];
  if (v51 >= 2)
    *v52++ = 10;
  *v52 = 0;
LABEL_70:
  v53 = -1024;
  while (ctx[v53])
  {
    v30 = __CFADD__(v53++, 1);
    if (v30)
      goto LABEL_80;
  }
  v54 = &ctx[v53];
  if ((unint64_t)-v53 < 2)
    goto LABEL_79;
  v55 = &ctx[v53 + 1];
  *v54 = 68;
  if (v53 == -2)
    goto LABEL_77;
  v54 = &ctx[v53 + 2];
  *v55 = 69;
  if (v53 != -3)
  {
    v55 = &ctx[v53 + 3];
    *v54 = 75;
    if (v53 == -4)
      goto LABEL_77;
    v54 = &ctx[v53 + 4];
    *v55 = 45;
    if (v53 == -5)
      goto LABEL_79;
    v55 = &ctx[v53 + 5];
    *v54 = 73;
    if (v53 == -6)
      goto LABEL_77;
    v54 = &ctx[v53 + 6];
    *v55 = 110;
    if (v53 == -7)
      goto LABEL_79;
    v55 = &ctx[v53 + 7];
    *v54 = 102;
    if (v53 == -8)
    {
LABEL_77:
      v54 = v55;
      goto LABEL_79;
    }
    v54 = &ctx[v53 + 8];
    *v55 = 111;
    if (v53 != -9)
    {
      *v54 = 58;
      if (v53 == -10)
      {
        v54 = &v116;
      }
      else
      {
        v54 = &ctx[v53 + 10];
        ctx[v53 + 9] = 32;
      }
      v26 = b;
    }
  }
LABEL_79:
  *v54 = 0;
LABEL_80:
  v56 = 0;
  while (v115[v56])
  {
    if (++v56 == 1024)
      goto LABEL_92;
  }
  if ((unint64_t)(1024 - v56) >= 2)
  {
    v57 = 0;
    v58 = 1023 - v56;
    while (v19[v57])
    {
      v115[v57 + v56] = v19[v57];
      ++v57;
      if (!--v58)
      {
        v59 = &v115[v56 + v57];
        goto LABEL_91;
      }
    }
    v56 += v57;
  }
  v59 = &v115[v56];
LABEL_91:
  *v59 = 0;
LABEL_92:
  v60 = 0;
  while (v115[v60])
  {
    if (++v60 == 1024)
      goto LABEL_99;
  }
  v61 = 1024 - v60;
  v62 = &v115[v60];
  if (v61 >= 2)
    *v62++ = 44;
  *v62 = 0;
LABEL_99:
  v63 = strlen(v115);
  if (iv_len <= (1022 - v63) >> 1)
  {
    if ((_DWORD)iv_len)
    {
      v65 = &v115[v63 + 1];
      v66 = salt;
      v67 = iv_len;
      do
      {
        v68 = *v66++;
        *(v65 - 1) = PEM_dek_info_map[(unint64_t)v68 >> 4];
        *v65 = PEM_dek_info_map[v68 & 0xF];
        v65 += 2;
        --v67;
      }
      while (v67);
    }
    *(_WORD *)&v115[2 * iv_len + v63] = 10;
  }
  memset(ctx, 0, 152);
  if (!EVP_CipherInit_ex((EVP_CIPHER_CTX *)ctx, enc, v64, key, salt, 1)
    || !EVP_EncryptUpdate((EVP_CIPHER_CTX *)ctx, v23, &outl, v23, v24)
    || !EVP_EncryptFinal_ex((EVP_CIPHER_CTX *)ctx, &v23[outl], &v107))
  {
    if (*(_QWORD *)ctx)
    {
      v69 = *(void (**)(_BYTE *))(*(_QWORD *)ctx + 40);
      if (v69)
        v69(ctx);
    }
    v33 = *(_DWORD *)&ctx[16];
    if (*(_QWORD *)&ctx[16])
    {
      v71 = (void *)(*(_QWORD *)&ctx[16] - 8);
      v70 = *(_QWORD *)(*(_QWORD *)&ctx[16] - 8);
      if (v70 != -8)
        bzero((void *)(*(_QWORD *)&ctx[16] - 8), v70 + 8);
      free(v71);
      v33 = 0;
    }
    goto LABEL_35;
  }
  v24 = v107 + outl;
  v107 += outl;
  EVP_CIPHER_CTX_cleanup((EVP_CIPHER_CTX *)ctx);
LABEL_43:
  memset(&ctx[160], 0, 56);
  v42 = strlen(__s);
  if (!v26)
    goto LABEL_197;
  if (!v26->method)
    goto LABEL_197;
  bwrite = v26->method->bwrite;
  if (!bwrite)
    goto LABEL_197;
  if (!LODWORD(v26->cb_arg))
    goto LABEL_201;
  v44 = v42;
  v45 = ((uint64_t (*)(BIO *, const char *, uint64_t))bwrite)(v26, "-----BEGIN ", 11);
  if (v45 < 1)
    goto LABEL_199;
  v26->prev_bio = (bio_st *)((char *)v26->prev_bio + v45);
  if (v45 != 11)
    goto LABEL_199;
  if (!v26->method || (v46 = v26->method->bwrite) == 0)
  {
    v72 = 115;
    v73 = 167;
LABEL_131:
    ERR_put_error(17, 0, v72, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v73);
    v47 = -2;
    goto LABEL_132;
  }
  if (!LODWORD(v26->cb_arg))
  {
    v72 = 114;
    v73 = 171;
    goto LABEL_131;
  }
  if ((int)v44 < 1)
  {
    if ((_DWORD)v44)
      goto LABEL_199;
    goto LABEL_133;
  }
  v47 = ((uint64_t (*)(BIO *, char *, size_t))v46)(v26, __s, v44);
  if (v47 >= 1)
  {
    v26->prev_bio = (bio_st *)((char *)v26->prev_bio + v47);
    if (v47 != (_DWORD)v44)
      goto LABEL_199;
    goto LABEL_133;
  }
LABEL_132:
  if (v47 != (_DWORD)v44)
    goto LABEL_199;
LABEL_133:
  if (!v26->method || (v74 = v26->method->bwrite) == 0)
  {
LABEL_197:
    v93 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c";
    v94 = 17;
    v95 = 115;
    v96 = 167;
    goto LABEL_198;
  }
  if (!LODWORD(v26->cb_arg))
    goto LABEL_201;
  v75 = ((uint64_t (*)(BIO *, const char *, uint64_t))v74)(v26, "-----\n", 6);
  if (v75 < 1)
    goto LABEL_199;
  v26->prev_bio = (bio_st *)((char *)v26->prev_bio + v75);
  if (v75 != 6)
    goto LABEL_199;
  v76 = strlen(v115);
  if ((int)v76 >= 1)
  {
    if (v26->method && (v77 = v26->method->bwrite) != 0)
    {
      if (LODWORD(v26->cb_arg))
      {
        v78 = ((uint64_t (*)(BIO *, char *, size_t))v77)(b, v115, v76);
        if (v78 >= 1)
        {
          v26 = b;
          b->prev_bio = (bio_st *)((char *)b->prev_bio + v78);
          goto LABEL_152;
        }
      }
      else
      {
        ERR_put_error(17, 0, 114, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 171);
        v78 = -2;
      }
      v26 = b;
    }
    else
    {
      ERR_put_error(17, 0, 115, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 167);
      v78 = -2;
    }
LABEL_152:
    if (v78 != (_DWORD)v76)
      goto LABEL_199;
    if (!v26->method)
      goto LABEL_197;
    v79 = v26->method->bwrite;
    if (!v79)
      goto LABEL_197;
    if (LODWORD(b->cb_arg))
    {
      v80 = ((uint64_t (*)(BIO *, const char *, uint64_t))v79)(b, "\n", 1);
      if (v80 < 1)
        goto LABEL_199;
      b->prev_bio = (bio_st *)((char *)b->prev_bio + v80);
      if (v80 != 1)
        goto LABEL_199;
      goto LABEL_158;
    }
LABEL_201:
    v93 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c";
    v94 = 17;
    v95 = 114;
    v96 = 171;
    goto LABEL_198;
  }
LABEL_158:
  v102 = (unsigned __int8 *)malloc_type_malloc(0x2008uLL, 0x30772F57uLL);
  if (!v102)
  {
    v93 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v94 = 14;
    v95 = 65;
    v96 = 247;
LABEL_198:
    ERR_put_error(v94, 0, v95, v93, v96);
    goto LABEL_199;
  }
  v81 = v24;
  *(_QWORD *)v102 = 0x2000;
  v82 = v102 + 8;
  if ((int)v81 < 1)
  {
    v84 = 0;
LABEL_186:
    v98 = 0;
    goto LABEL_187;
  }
  v83 = 0;
  v84 = 0;
  v108 = 0;
  v85 = b;
  do
  {
    if (v81 >= 5120)
      v90 = 5120;
    else
      v90 = v81;
    EVP_EncodeUpdate((EVP_ENCODE_CTX *)&ctx[160], v82, &v108, &v23[v83], v90);
    v91 = v108;
    if (!v108)
      goto LABEL_164;
    if (!v85->method || (v92 = v85->method->bwrite) == 0)
    {
      v86 = 115;
      v87 = 167;
LABEL_162:
      ERR_put_error(17, 0, v86, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v87);
      v88 = -2;
      goto LABEL_163;
    }
    if (!LODWORD(v85->cb_arg))
    {
      v86 = 114;
      v87 = 171;
      goto LABEL_162;
    }
    if (v108 < 1)
    {
      v88 = 0;
    }
    else
    {
      v88 = ((uint64_t (*)(BIO *, unsigned __int8 *, _QWORD))v92)(v85, v82, v108);
      v85 = b;
      if (v88 >= 1)
        b->prev_bio = (bio_st *)((char *)b->prev_bio + v88);
    }
LABEL_163:
    if (v88 != v91)
      goto LABEL_182;
LABEL_164:
    v84 += v91;
    v83 += v90;
    v89 = v81 <= v90;
    v81 -= v90;
  }
  while (!v89);
  if (!*(_DWORD *)&ctx[160])
    goto LABEL_186;
  v97 = EVP_EncodeBlock(v82, &ctx[164], *(int *)&ctx[160]);
  v98 = v97 + 1;
  *(_WORD *)&v82[v97] = 10;
  *(_DWORD *)&ctx[160] = 0;
  if ((int)v97 + 1 >= 1 && BIO_write(b, v82, v98) != v98)
  {
LABEL_182:
    if (*(_QWORD *)v102 != -8)
      __memset_chk();
    free(v102);
    goto LABEL_199;
  }
LABEL_187:
  if (*(_QWORD *)v102 != -8)
    __memset_chk();
  free(v102);
  if (!b->method)
    goto LABEL_197;
  v99 = b->method->bwrite;
  if (!v99)
    goto LABEL_197;
  if (!LODWORD(b->cb_arg))
    goto LABEL_201;
  v100 = ((uint64_t (*)(BIO *, const char *, uint64_t))v99)(b, "-----END ", 9);
  if (v100 >= 1)
  {
    b->prev_bio = (bio_st *)((char *)b->prev_bio + v100);
    if (v100 == 9 && BIO_write(b, __s, v44) == (_DWORD)v44 && BIO_write(b, "-----\n", 6) == 6)
    {
      v101 = v98 + v84;
      goto LABEL_200;
    }
  }
LABEL_199:
  ERR_put_error(9, 0, 7, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_lib.c", 589);
  v101 = 0;
LABEL_200:
  v107 = v101;
  v33 = v101 > 0;
LABEL_35:
  v113 = 0u;
  v114 = 0u;
  *(_OWORD *)key = 0u;
  v112 = 0u;
  *(_QWORD *)salt = 0;
  v110 = 0;
  memset(ctx, 0, 152);
  bzero(v115, 0x400uLL);
  if (v23)
  {
    v35 = *((_QWORD *)v23 - 1);
    v34 = v23 - 8;
    v36 = v35 + 8;
    if (v35 != -8)
      bzero(v34, v36);
    free(v34);
  }
  return v33;
}

__int128 *cipher_by_name(const char *a1)
{
  if (!strcmp(a1, "DES-CBC"))
    return (__int128 *)&evp_des_cbc;
  if (!strcmp(a1, "DES-EDE3-CBC"))
    return (__int128 *)&evp_des_ede3_cbc;
  if (!strcmp(a1, "AES-128-CBC"))
  {
    if (!pthread_once(&EVP_aes_128_cbc_once, (void (*)(void))EVP_aes_128_cbc_init))
      return &EVP_aes_128_cbc_storage;
    goto LABEL_15;
  }
  if (!strcmp(a1, "AES-192-CBC"))
  {
    if (!pthread_once(&EVP_aes_192_cbc_once, (void (*)(void))EVP_aes_192_cbc_init))
      return &EVP_aes_192_cbc_storage;
LABEL_15:
    abort();
  }
  if (strcmp(a1, "AES-256-CBC"))
    return 0;
  if (pthread_once(&EVP_aes_256_cbc_once, (void (*)(void))EVP_aes_256_cbc_init))
    goto LABEL_15;
  return &EVP_aes_256_cbc_storage;
}

int PEM_def_callback(char *buf, int num, int w, void *key)
{
  char *v4;
  char *v5;
  uint64_t v7;
  char v8;

  v4 = buf;
  LODWORD(buf) = 0;
  if ((num & 0x80000000) == 0)
  {
    if (v4)
    {
      v5 = (char *)key;
      if (key)
      {
        buf = (char *)strlen((const char *)key);
        if ((unint64_t)buf >= num)
        {
          LODWORD(buf) = 0;
        }
        else
        {
          if (num >= 2)
          {
            v7 = num - 1;
            do
            {
              v8 = *v5;
              if (!*v5)
                break;
              ++v5;
              *v4++ = v8;
              --v7;
            }
            while (v7);
          }
          *v4 = 0;
        }
      }
    }
  }
  return (int)buf;
}

uint64_t load_iv(uint64_t *a1, void *a2, size_t a3)
{
  uint64_t v4;
  unint64_t v7;
  uint64_t v8;
  char v9;
  int v10;

  v4 = *a1;
  if (!a3)
  {
LABEL_13:
    *a1 = v4;
    return 1;
  }
  bzero(a2, a3);
  v7 = 0;
  v8 = 2 * a3;
  if (2 * a3 <= 1)
    v8 = 1;
  while (1)
  {
    v10 = *(char *)(v4 + v7);
    if ((v10 - 58) <= 0xFFFFFFF5)
      break;
    v9 = -48;
LABEL_6:
    *((_BYTE *)a2 + (v7 >> 1)) |= (v9 + (_BYTE)v10) << (~(4 * v7) & 4);
    if (v8 == ++v7)
    {
      v4 += v7;
      goto LABEL_13;
    }
  }
  if ((v10 - 97) < 6)
  {
    v9 = -87;
    goto LABEL_6;
  }
  if ((v10 - 65) < 6)
  {
    v9 = -55;
    goto LABEL_6;
  }
  ERR_put_error(9, 0, 103, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_lib.c", 511);
  return 0;
}

uint64_t do_pk8pkey(BIO *a1, EVP_PKEY *pkey, int a3, int a4, const EVP_CIPHER *a5, const char *a6, int a7, int (__cdecl *a8)(char *buf, int num, int w, void *key), uint64_t a9)
{
  PKCS8_PRIV_KEY_INFO *v16;
  ASN1_VALUE *v17;
  uint64_t v18;
  uint64_t v19;
  X509_SIG *v20;
  uint64_t v21;
  int (__cdecl *v22)(char *, int, int, void *);
  int v23;
  const ASN1_ITEM *v24;
  ASN1_VALUE **p_pval;
  ASN1_VALUE *pval;
  char pass[1024];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v16 = EVP_PKEY2PKCS8(pkey);
  if (v16)
  {
    v17 = (ASN1_VALUE *)v16;
    if (a4 == -1 && !a5)
    {
      if (a3)
        v18 = i2d_PKCS8_PRIV_KEY_INFO_bio(a1, v16);
      else
        v18 = PEM_ASN1_write_bio((i2d_of_void *)pem_write_bio_PKCS8_PRIV_KEY_INFO_i2d, "PRIVATE KEY", a1, (char *)v16, 0, 0, 0, 0, 0);
      v19 = v18;
      *(_QWORD *)pass = v17;
      v24 = &PKCS8_PRIV_KEY_INFO_it;
      p_pval = (ASN1_VALUE **)pass;
      goto LABEL_22;
    }
    if (a6)
    {
      v20 = PKCS8_encrypt(a4, a5, a6, a7, 0, 0, 0, v16);
      if (pass != a6 || !a7)
      {
        pval = v17;
        ASN1_item_ex_free(&pval, &PKCS8_PRIV_KEY_INFO_it);
        if (a3)
        {
LABEL_12:
          v21 = i2d_PKCS8_bio(a1, v20);
LABEL_19:
          v19 = v21;
          pval = (ASN1_VALUE *)v20;
          v24 = &X509_SIG_it;
          p_pval = &pval;
LABEL_22:
          ASN1_item_ex_free(p_pval, v24);
          return v19;
        }
LABEL_18:
        v21 = PEM_ASN1_write_bio((i2d_of_void *)pem_write_bio_PKCS8_i2d, "ENCRYPTED PRIVATE KEY", a1, (char *)v20, 0, 0, 0, 0, 0);
        goto LABEL_19;
      }
LABEL_17:
      __memset_chk();
      pval = v17;
      ASN1_item_ex_free(&pval, &PKCS8_PRIV_KEY_INFO_it);
      if (a3)
        goto LABEL_12;
      goto LABEL_18;
    }
    v22 = PEM_def_callback;
    if (a8)
      v22 = a8;
    v23 = ((uint64_t (*)(char *, uint64_t, uint64_t, uint64_t))v22)(pass, 1024, 1, a9);
    if (v23 >= 1)
    {
      v20 = PKCS8_encrypt(a4, a5, pass, v23, 0, 0, 0, (PKCS8_PRIV_KEY_INFO *)v17);
      goto LABEL_17;
    }
    ERR_put_error(9, 0, 111, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_pk8.c", 122);
    pval = v17;
    ASN1_item_ex_free(&pval, &PKCS8_PRIV_KEY_INFO_it);
  }
  else
  {
    ERR_put_error(9, 0, 106, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_pk8.c", 111);
  }
  return 0;
}

uint64_t pem_write_bio_PKCS8_i2d(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &X509_SIG_it);
}

uint64_t pem_write_bio_PKCS8_PRIV_KEY_INFO_i2d(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &PKCS8_PRIV_KEY_INFO_it);
}

EVP_PKEY *__cdecl PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  char *v7;
  EVP_PKEY *v8;
  PKCS8_PRIV_KEY_INFO *v9;
  ASN1_VALUE *v10;
  EVP_PKEY *v11;
  unsigned int i;
  unsigned int v13;
  char *ptr;
  void (*v15)(EVP_PKEY *);
  STACK **p_attributes;
  STACK *attributes;
  size_t p_data;
  int (__cdecl *v19)(char *, int, int, void *);
  int v20;
  PKCS8_PRIV_KEY_INFO *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  unsigned __int8 *v25;
  uint64_t plen;
  unsigned __int8 *pdata;
  unsigned __int8 *pp;
  char *pnm;
  ASN1_VALUE *v31;
  ASN1_VALUE *pval[129];

  pval[128] = *(ASN1_VALUE **)MEMORY[0x24BDAC8D0];
  pnm = 0;
  plen = 0;
  pdata = 0;
  if (!PEM_bytes_read_bio(&pdata, &plen, &pnm, "ANY PRIVATE KEY", bp, cb, u))
    return 0;
  pp = pdata;
  v7 = pnm;
  if (!strcmp(pnm, "PRIVATE KEY"))
  {
    pval[0] = 0;
    if ((int)asn1_item_ex_d2i((uint64_t)pval, &pp, plen, (uint64_t)&PKCS8_PRIV_KEY_INFO_it, -1, 0, 0, 0, 0) <= 0)
    {
      ASN1_item_ex_free(pval, &PKCS8_PRIV_KEY_INFO_it);
      v9 = (PKCS8_PRIV_KEY_INFO *)pval[0];
      if (!pval[0])
        goto LABEL_50;
    }
    else
    {
      v9 = (PKCS8_PRIV_KEY_INFO *)pval[0];
      if (!pval[0])
        goto LABEL_50;
    }
    v8 = EVP_PKCS82PKEY(v9);
    if (x)
    {
      v11 = *x;
      if (*x)
      {
        for (i = atomic_load((unsigned int *)v11); i != -1; i = v13)
        {
          if (!i)
            abort();
          v13 = __ldaxr((unsigned int *)v11);
          if (v13 == i)
          {
            if (!__stlxr(i - 1, (unsigned int *)v11))
            {
              if (i == 1)
              {
                ptr = v11->pkey.ptr;
                if (ptr)
                {
                  v15 = (void (*)(EVP_PKEY *))*((_QWORD *)ptr + 20);
                  if (v15)
                  {
                    v15(v11);
                    *(_QWORD *)&v11->references = 0;
                    v11->save_type = 0;
                  }
                }
                attributes = v11[-1].attributes;
                p_attributes = &v11[-1].attributes;
                p_data = (size_t)&attributes->data;
                if (attributes != (STACK *)-8)
                  bzero(p_attributes, p_data);
                free(p_attributes);
              }
              break;
            }
          }
          else
          {
            __clrex();
          }
        }
      }
      *x = v8;
    }
    pval[0] = (ASN1_VALUE *)v9;
    ASN1_item_ex_free(pval, &PKCS8_PRIV_KEY_INFO_it);
    if (v8)
      goto LABEL_52;
    goto LABEL_50;
  }
  if (!strcmp(v7, "ENCRYPTED PRIVATE KEY"))
  {
    v31 = 0;
    if ((int)asn1_item_ex_d2i((uint64_t)&v31, &pp, plen, (uint64_t)&X509_SIG_it, -1, 0, 0, 0, 0) <= 0)
    {
      ASN1_item_ex_free(&v31, &X509_SIG_it);
      v10 = v31;
      if (!v31)
        goto LABEL_50;
    }
    else
    {
      v10 = v31;
      if (!v31)
        goto LABEL_50;
    }
    v19 = PEM_def_callback;
    if (cb)
      v19 = cb;
    v20 = ((uint64_t (*)(ASN1_VALUE **, uint64_t, _QWORD, void *))v19)(pval, 1024, 0, u);
    if (v20 < 1)
    {
      ERR_put_error(9, 0, 104, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_pkey.c", 114);
      v31 = v10;
      ASN1_item_ex_free(&v31, &X509_SIG_it);
      goto LABEL_51;
    }
    v21 = PKCS8_decrypt((X509_SIG *)v10, (const char *)pval, v20);
    v31 = v10;
    ASN1_item_ex_free(&v31, &X509_SIG_it);
    __memset_chk();
    if (v21)
    {
      v8 = EVP_PKCS82PKEY(v21);
      if (x)
      {
        if (*x)
          EVP_PKEY_free(*x);
        *x = v8;
      }
      v31 = (ASN1_VALUE *)v21;
      ASN1_item_ex_free(&v31, &PKCS8_PRIV_KEY_INFO_it);
      if (v8)
        goto LABEL_52;
    }
LABEL_50:
    ERR_put_error(9, 0, 12, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pem/pem_pkey.c", 144);
LABEL_51:
    v8 = 0;
    goto LABEL_52;
  }
  if (!strcmp(v7, "RSA PRIVATE KEY"))
  {
    v8 = d2i_PrivateKey(6, x, (const unsigned __int8 **)&pp, plen);
    if (!v8)
      goto LABEL_50;
  }
  else
  {
    if (strcmp(v7, "EC PRIVATE KEY"))
    {
      if (!strcmp(v7, "DSA PRIVATE KEY"))
      {
        v8 = d2i_PrivateKey(116, x, (const unsigned __int8 **)&pp, plen);
        if (v8)
          goto LABEL_52;
      }
      goto LABEL_50;
    }
    v8 = d2i_PrivateKey(408, x, (const unsigned __int8 **)&pp, plen);
    if (!v8)
      goto LABEL_50;
  }
LABEL_52:
  if (pnm)
  {
    v23 = pnm - 8;
    v22 = *((_QWORD *)pnm - 1);
    if (v22 != -8)
      bzero(v23, v22 + 8);
    free(v23);
  }
  if (pdata)
  {
    v25 = pdata - 8;
    v24 = *((_QWORD *)pdata - 1);
    if (v24 != -8)
      bzero(v25, v24 + 8);
    free(v25);
  }
  return v8;
}

uint64_t pkcs12_key_gen(unsigned __int8 *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unsigned int a6, size_t a7, char *a8, uint64_t a9)
{
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  const char *v23;
  int v24;
  int v25;
  int v26;
  unsigned __int8 *v27;
  uint64_t v28;
  size_t v29;
  _QWORD *v30;
  void (**v31)(_QWORD);
  _QWORD *v33;
  void *v34;
  char v35;
  _BYTE *v36;
  unsigned int v37;
  unsigned int v38;
  char v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  unsigned __int8 v45;
  int v46;
  unsigned __int8 v47;
  const char *v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  size_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  unint64_t v61;
  _QWORD *v62;
  char *v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  _QWORD *v69;
  void *v70;
  uint64_t v71;
  char *v72;
  size_t v73;
  size_t v74;
  unsigned int v75;
  size_t v76;
  unint64_t i;
  uint64_t v78;
  _QWORD *v79;
  void *v80;
  uint64_t v81;
  char *v82;
  size_t v83;
  unint64_t v84;
  char v85;
  char *v86;
  unint64_t v87;
  _QWORD *v88;
  int v89;
  unint64_t v90;
  unsigned int v91;
  _QWORD *v92;
  uint64_t v93;
  size_t v94;
  _QWORD *v95;
  uint64_t v96;
  unint64_t v97;
  _QWORD *v98;
  unint64_t v99;
  char *__dst;
  size_t v101;
  void *v102[2];
  __int128 v103;
  __int128 v104;
  void *v105[2];
  __int128 v106;
  _QWORD __src[8];
  char v108[128];
  uint64_t v109;

  v109 = *MEMORY[0x24BDAC8D0];
  if (!a6)
  {
    ERR_put_error(19, 0, 129, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8.c", 115);
    return 0;
  }
  v14 = a1;
  *(_OWORD *)v102 = 0u;
  v103 = 0u;
  if (a1)
  {
    v15 = a2;
    *(_OWORD *)v105 = 0uLL;
    v106 = 0uLL;
    v16 = 2 * a2;
    v104 = 0uLL;
    if ((unint64_t)(2 * a2) >= 0xFFFFFFFFFFFFFFF8)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      goto LABEL_66;
    }
    v33 = malloc_type_malloc(v16 + 8, 0x30772F57uLL);
    if (v33)
    {
      __dst = a8;
      v101 = a7;
      *v33 = v16;
      v34 = v33 + 1;
      v35 = BYTE8(v106);
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      if (v16)
        goto LABEL_66;
      __dst = a8;
      v101 = a7;
      v35 = 0;
      v34 = 0;
    }
    BYTE8(v104) = 0;
    *(_QWORD *)&v104 = 0;
    v105[0] = v34;
    v105[1] = 0;
    *(_QWORD *)&v106 = v16;
    for (BYTE8(v106) = v35 & 0xFC | 1; v15; *(_BYTE *)__src[0] = BYTE1(v37))
    {
      v36 = v14 + 1;
      v37 = *v14;
      if ((char)*v14 < 0)
      {
        if ((v37 & 0xE0) == 0xC0)
        {
          v39 = 0;
          v40 = 128;
          v41 = 31;
          v42 = 1;
        }
        else if ((v37 & 0xF0) == 0xE0)
        {
          v39 = 1;
          v40 = 2048;
          v41 = 15;
          v42 = 2;
        }
        else
        {
          if ((v37 & 0xF8) != 0xF0)
            goto LABEL_57;
          v39 = 0;
          v40 = 0x10000;
          v41 = 7;
          v42 = 3;
        }
        if (v15 == 1 || (*v36 & 0xC0) != 0x80)
        {
LABEL_57:
          v48 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl"
                "/src/crypto/pkcs8/pkcs8.c";
          v49 = 19;
          v50 = 131;
          v51 = 90;
LABEL_58:
          ERR_put_error(v49, 0, v50, v48, v51);
          goto LABEL_59;
        }
        v43 = v41 & v37;
        v44 = *v36 & 0x3F | (v43 << 6);
        if ((v37 & 0xE0) == 0xC0)
        {
          v37 = *v36 & 0x3F | (v43 << 6);
        }
        else
        {
          if (v15 == 2)
            goto LABEL_57;
          v45 = v14[2];
          if ((v45 & 0xC0) != 0x80)
            goto LABEL_57;
          v46 = v45 & 0x3F;
          v43 = v46 | (v44 << 6);
          if ((v39 & 1) != 0)
          {
            v37 = v46 | (v44 << 6);
            v43 = v44;
          }
          else
          {
            if (v15 == 3)
              goto LABEL_57;
            v47 = v14[3];
            if ((v47 & 0xC0) != 0x80)
              goto LABEL_57;
            v37 = v47 & 0x3F | (v43 << 6);
          }
        }
        if (v37 < v40)
          goto LABEL_57;
        if ((v43 & 0x1FFE0) == 0x360)
          goto LABEL_57;
        v38 = v37 - 64976;
        if (v37 - 64976 < 0x20)
          goto LABEL_57;
        if (HIWORD(v37) > 0x10u)
          goto LABEL_57;
        if ((v37 & 0xFFFE) == 0xFFFE)
          goto LABEL_57;
        if (HIWORD(v37))
          goto LABEL_57;
        v15 = v15 - 1 - v42;
        v14 = &v36[v42];
        if (v37 >> 11 == 27)
          goto LABEL_57;
      }
      else
      {
        v38 = v37 - 64976;
        ++v14;
        --v15;
        if (v37 >> 11 == 27)
          goto LABEL_57;
      }
      if (v38 < 0x20)
        goto LABEL_57;
      __src[0] = 0;
      if (!CBB_add_space((uint64_t)&v104, __src, 2))
        goto LABEL_57;
      *(_BYTE *)(__src[0] + 1) = v37;
    }
    __src[0] = 0;
    if (CBB_add_space((uint64_t)&v104, __src, 2))
    {
      *(_BYTE *)(__src[0] + 1) = 0;
      *(_BYTE *)__src[0] = 0;
      if (BYTE8(v104))
      {
        v48 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/bytestring/cbb.c";
        v49 = 14;
        v50 = 66;
        v51 = 127;
        goto LABEL_58;
      }
      if (CBB_flush((uint64_t *)&v104))
      {
        v14 = (unsigned __int8 *)v105[0];
        v18 = (unint64_t)v105[1];
        v19 = a9;
        v20 = *(unsigned int *)(a9 + 40);
        if (!(_DWORD)v20)
          goto LABEL_8;
        goto LABEL_7;
      }
    }
LABEL_59:
    if (!BYTE8(v104) && (BYTE8(v106) & 1) != 0 && v105[0])
    {
      v53 = (char *)v105[0] - 8;
      v52 = *((_QWORD *)v105[0] - 1);
      if (v52 != -8)
        bzero((char *)v105[0] - 8, v52 + 8);
      free(v53);
    }
LABEL_66:
    v17 = 0;
    v30 = v102[1];
    if (!v102[1])
      goto LABEL_18;
    goto LABEL_67;
  }
  __dst = a8;
  v101 = a7;
  v18 = 0;
  v19 = a9;
  v20 = *(unsigned int *)(a9 + 40);
  if ((_DWORD)v20)
LABEL_7:
    __memset_chk();
LABEL_8:
  v21 = a4 + v20 - 1;
  if (v21 < a4 || (v22 = v20 - 1 + v18, __CFADD__(v20 - 1, v18)))
  {
    v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/pkcs8/pkcs8.c";
    v24 = 19;
    v25 = 69;
    v26 = 151;
LABEL_12:
    ERR_put_error(v24, 0, v25, v23, v26);
    v17 = 0;
    goto LABEL_13;
  }
  v57 = v21 / v20 * v20;
  v58 = v22 / v20 * v20;
  v59 = v58 + v57;
  if (__CFADD__(v58, v57))
  {
    v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/pkcs8/pkcs8.c";
    v24 = 19;
    v25 = 69;
    v26 = 158;
    goto LABEL_12;
  }
  if (v59 >= 0xFFFFFFFFFFFFFFF8)
  {
    v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v24 = 14;
    v25 = 65;
    v26 = 247;
    goto LABEL_12;
  }
  v97 = v22 / v20 * v20;
  v99 = v58 + v57;
  v60 = malloc_type_malloc(v59 + 8, 0x30772F57uLL);
  if (!v60)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v17 = 0;
    if (v99)
      goto LABEL_13;
    v62 = 0;
    v22 = v20 - 1 + v18;
    v61 = v97;
    v63 = (char *)(v22 - v97);
    if (v21 == v21 % v20)
      goto LABEL_86;
    goto LABEL_82;
  }
  v61 = v22 / v20 * v20;
  *v60 = v99;
  v62 = v60 + 1;
  v63 = (char *)(v22 % v20);
  if (v21 != v21 % v20)
  {
LABEL_82:
    v64 = 0;
    if (v57 <= 1)
      v65 = 1;
    else
      v65 = v21 / v20 * v20;
    do
    {
      *((_BYTE *)v62 + v64) = *(_BYTE *)(a3 + v64 % a4);
      ++v64;
    }
    while (v65 != v64);
  }
LABEL_86:
  if ((char *)v22 != v63)
  {
    v66 = 0;
    if (v61 <= 1)
      v67 = 1;
    else
      v67 = v61;
    do
    {
      *((_BYTE *)v62 + v66 + v57) = v14[v66 % v18];
      ++v66;
    }
    while (v67 != v66);
  }
  if (!v101)
  {
    v17 = 1;
    goto LABEL_139;
  }
  v98 = v62;
  v96 = v20 & 0xFFFFFFFE;
  while (1)
  {
    if (v102[0] != (void *)v19)
    {
      v68 = *(unsigned int *)(v19 + 44);
      v69 = malloc_type_malloc(v68 + 8, 0x30772F57uLL);
      if (!v69)
      {
LABEL_133:
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        v17 = 0;
        goto LABEL_134;
      }
      *v69 = v68;
      v70 = v69 + 1;
      if (v102[1])
      {
        v72 = (char *)v102[1] - 8;
        v71 = *((_QWORD *)v102[1] - 1);
        if (v71 != -8)
          bzero((char *)v102[1] - 8, v71 + 8);
        free(v72);
      }
      v102[0] = (void *)v19;
      v102[1] = v70;
    }
    (*(void (**)(void **))(v19 + 16))(v102);
    (*((void (**)(void **, char *, unint64_t))v102[0] + 3))(v102, v108, v20);
    (*((void (**)(void **, _QWORD *, unint64_t))v102[0] + 3))(v102, v98, v99);
    (*((void (**)(void **, _QWORD *))v102[0] + 4))(v102, __src);
    v73 = *((unsigned int *)v102[0] + 1);
    v74 = *((unsigned int *)v102[0] + 11);
    if ((_DWORD)v74)
      bzero(v102[1], v74);
    v75 = a6 - 1;
    if (a6 >= 2)
    {
      do
      {
        if (v102[0] != (void *)v19)
        {
          v78 = *(unsigned int *)(v19 + 44);
          v79 = malloc_type_malloc(v78 + 8, 0x30772F57uLL);
          if (!v79)
            goto LABEL_133;
          *v79 = v78;
          v80 = v79 + 1;
          if (v102[1])
          {
            v82 = (char *)v102[1] - 8;
            v81 = *((_QWORD *)v102[1] - 1);
            if (v81 != -8)
              bzero((char *)v102[1] - 8, v81 + 8);
            free(v82);
          }
          v102[0] = (void *)v19;
          v102[1] = v80;
        }
        (*(void (**)(void **))(v19 + 16))(v102);
        (*((void (**)(void **, _QWORD *, size_t))v102[0] + 3))(v102, __src, v73);
        (*((void (**)(void **, _QWORD *))v102[0] + 4))(v102, __src);
        v73 = *((unsigned int *)v102[0] + 1);
        v83 = *((unsigned int *)v102[0] + 11);
        if ((_DWORD)v83)
          bzero(v102[1], v83);
        --v75;
      }
      while (v75);
    }
    if (v101 >= v73)
      v76 = v73;
    else
      v76 = v101;
    if (v76)
      memcpy(__dst, __src, v76);
    v101 -= v76;
    if (!v101)
      break;
    if (!(_DWORD)v20)
      goto LABEL_93;
    if ((_DWORD)v20 == 1)
    {
      for (i = 0; i != v20; ++i)
LABEL_126:
        *((_BYTE *)&v105[-2] + i) = *((_BYTE *)__src + i % v73);
      goto LABEL_127;
    }
    v84 = 0;
    do
    {
      v85 = *((_BYTE *)__src + (v84 + 1) % v73);
      v86 = (char *)&v105[-2] + v84;
      *v86 = *((_BYTE *)__src + v84 % v73);
      v86[1] = v85;
      v84 += 2;
    }
    while (v96 != v84);
    i = v20 & 0xFFFFFFFE;
    if (v96 != v20)
      goto LABEL_126;
LABEL_127:
    if (v99)
    {
      v87 = 0;
      v88 = v98;
      do
      {
        v89 = 1;
        v90 = v20 - 1;
        do
        {
          v91 = v89 + *((unsigned __int8 *)v88 + v90) + *((unsigned __int8 *)&v105[-2] + v90);
          *((_BYTE *)v88 + v90) = v91;
          v89 = v91 >> 8;
          --v90;
        }
        while (v90 < v20);
        v87 += v20;
        v88 = (_QWORD *)((char *)v88 + v20);
      }
      while (v87 < v99);
    }
LABEL_93:
    __dst += v76;
  }
  v17 = 1;
LABEL_134:
  v62 = v98;
LABEL_139:
  if (v62)
  {
    v93 = *(v62 - 1);
    v92 = v62 - 1;
    v94 = v93 + 8;
    if (v93 != -8)
    {
      v95 = v92;
      bzero(v92, v94);
      v92 = v95;
    }
    free(v92);
  }
LABEL_13:
  if (v14)
  {
    v28 = *((_QWORD *)v14 - 1);
    v27 = v14 - 8;
    v29 = v28 + 8;
    if (v28 != -8)
      bzero(v27, v29);
    free(v27);
  }
  v30 = v102[1];
  if (!v102[1])
  {
LABEL_18:
    v31 = (void (**)(_QWORD))*((_QWORD *)&v103 + 1);
    if (*((_QWORD *)&v103 + 1))
      goto LABEL_19;
    return v17;
  }
LABEL_67:
  v55 = *(v30 - 1);
  v54 = (char *)(v30 - 1);
  v56 = v55 + 8;
  if (v55 != -8)
    bzero(v54, v56);
  free(v54);
  v31 = (void (**)(_QWORD))*((_QWORD *)&v103 + 1);
  if (*((_QWORD *)&v103 + 1))
LABEL_19:
    (*v31)(v103);
  return v17;
}

uint64_t pkcs12_pbe_encrypt_init(uint64_t *a1, EVP_CIPHER_CTX *a2, int a3, unsigned int a4, unsigned __int8 *a5, uint64_t a6, const void *a7, size_t a8)
{
  unsigned __int8 *v15;
  uint64_t result;
  size_t v17;
  _OWORD v18[3];
  _OWORD v19[3];
  _OWORD v20[3];
  _OWORD v21[3];
  _BYTE *v22;

  switch(a3)
  {
    case 149:
      v15 = (unsigned __int8 *)&kBuiltinPBE;
      break;
    case 146:
      v15 = (unsigned __int8 *)&unk_24C0D1878;
      break;
    case 144:
      v15 = (unsigned __int8 *)&unk_24C0D1850;
      break;
    default:
      ERR_put_error(19, 0, 119, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8.c", 337);
      return 0;
  }
  memset(v21, 0, sizeof(v21));
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  memset(v18, 0, sizeof(v18));
  result = CBB_flush(a1);
  if ((_DWORD)result)
  {
    v22 = 0;
    result = CBB_add_space((uint64_t)a1, &v22, 1);
    if ((_DWORD)result)
    {
      *v22 = 48;
      result = cbb_add_child((uint64_t)a1, (uint64_t)v21, 1u, 1);
      if ((_DWORD)result)
      {
        result = CBB_flush((uint64_t *)v21);
        if ((_DWORD)result)
        {
          v22 = 0;
          result = CBB_add_space((uint64_t)v21, &v22, 1);
          if ((_DWORD)result)
          {
            *v22 = 6;
            result = cbb_add_child((uint64_t)v21, (uint64_t)v20, 1u, 1);
            if ((_DWORD)result)
            {
              v17 = v15[14];
              v22 = 0;
              result = CBB_add_space((uint64_t)v20, &v22, v17);
              if ((_DWORD)result)
              {
                if ((_DWORD)v17)
                  memcpy(v22, v15 + 4, v17);
                result = CBB_flush((uint64_t *)v21);
                if ((_DWORD)result)
                {
                  v22 = 0;
                  result = CBB_add_space((uint64_t)v21, &v22, 1);
                  if ((_DWORD)result)
                  {
                    *v22 = 48;
                    result = cbb_add_child((uint64_t)v21, (uint64_t)v19, 1u, 1);
                    if ((_DWORD)result)
                    {
                      result = CBB_flush((uint64_t *)v19);
                      if ((_DWORD)result)
                      {
                        v22 = 0;
                        result = CBB_add_space((uint64_t)v19, &v22, 1);
                        if ((_DWORD)result)
                        {
                          *v22 = 4;
                          result = cbb_add_child((uint64_t)v19, (uint64_t)v18, 1u, 1);
                          if ((_DWORD)result)
                          {
                            v22 = 0;
                            result = CBB_add_space((uint64_t)v18, &v22, a8);
                            if ((_DWORD)result)
                            {
                              if (a8)
                                memcpy(v22, a7, a8);
                              result = CBB_add_asn1_uint64_with_tag((uint64_t)v19, a4, 2);
                              if ((_DWORD)result)
                              {
                                result = CBB_flush(a1);
                                if ((_DWORD)result)
                                  return pkcs12_pbe_cipher_init((uint64_t)v15, a2, a4, a5, a6, (uint64_t)a7, a8, 1);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t pkcs12_pbe_cipher_init(uint64_t a1, EVP_CIPHER_CTX *a2, unsigned int a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6, unint64_t a7, int a8)
{
  const EVP_CIPHER *v16;
  uint64_t v17;
  unsigned __int8 iv[16];
  unsigned __int8 key[64];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v16 = (const EVP_CIPHER *)(*(uint64_t (**)(void))(a1 + 16))();
  v17 = (*(uint64_t (**)(void))(a1 + 24))();
  if (pkcs12_key_gen(a4, a5, a6, a7, 1, a3, v16->key_len, (char *)key, v17)
    && pkcs12_key_gen(a4, a5, a6, a7, 2, a3, v16->iv_len, (char *)iv, v17))
  {
    return EVP_CipherInit_ex(a2, v16, 0, key, iv, a8);
  }
  ERR_put_error(19, 0, 110, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8.c", 245);
  return 0;
}

uint64_t pkcs8_pbe_decrypt(unsigned __int8 **a1, _QWORD *a2, unsigned __int8 **a3, uint64_t a4, uint64_t a5, const unsigned __int8 *a6, unint64_t a7)
{
  uint64_t v14;
  uint64_t v15;
  const EVP_CIPHER *cipher;
  int (__cdecl *cleanup)(EVP_CIPHER_CTX *);
  uint64_t v18;
  void *v19;
  uint64_t v21;
  int v22;
  _BOOL4 v24;
  unsigned int v27;
  _QWORD *v28;
  _QWORD *v29;
  unsigned __int8 *v30;
  uint64_t v31;
  int outl[2];
  uint64_t v33;
  unint64_t v34;
  int v35;
  unint64_t v36;
  EVP_CIPHER_CTX ctx;

  *(_QWORD *)&ctx.final[16] = *MEMORY[0x24BDAC8D0];
  memset(&ctx, 0, 152);
  v33 = 0;
  v34 = 0;
  v36 = 0;
  v35 = 0;
  if (!cbs_get_any_asn1_element(a3, &v33, &v35, &v36, 0, 0, 0)
    || v35 != 6
    || (v14 = v34 - v36, v34 < v36))
  {
    ERR_put_error(19, 0, 104, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8.c", 368);
    v15 = 0;
    cipher = ctx.cipher;
    if (!ctx.cipher)
      goto LABEL_7;
    goto LABEL_5;
  }
  v21 = v33 + v36;
  v33 += v36;
  v34 -= v36;
  if (v14 == 9)
  {
    if (*(_QWORD *)v21 == 0x5010DF78648862ALL && *(_BYTE *)(v21 + 8) == 13)
    {
      v27 = 3;
      goto LABEL_33;
    }
    goto LABEL_46;
  }
  if (v14 != 10)
    goto LABEL_46;
  v22 = *(unsigned __int8 *)(v21 + 9);
  v24 = *(_QWORD *)v21 == 0xC010DF78648862ALL && *(_BYTE *)(v21 + 8) == 1;
  if (v24 && v22 == 6)
  {
    v27 = 0;
    goto LABEL_33;
  }
  if (v22 == 1 && v24)
  {
    v27 = 1;
    goto LABEL_33;
  }
  if (v22 != 3)
    LOBYTE(v24) = 0;
  if (!v24)
  {
LABEL_46:
    ERR_put_error(19, 0, 119, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8.c", 380);
    v15 = 0;
    cipher = ctx.cipher;
    if (!ctx.cipher)
      goto LABEL_7;
    goto LABEL_5;
  }
  v27 = 2;
LABEL_33:
  if (!(*((unsigned int (**)(char *, EVP_CIPHER_CTX *, uint64_t, uint64_t, unsigned __int8 **))&kBuiltinPBE
         + 5 * v27
         + 4))((char *)&kBuiltinPBE + 40 * v27, &ctx, a4, a5, a3))
  {
    ERR_put_error(19, 0, 109, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8.c", 385);
    v15 = 0;
    cipher = ctx.cipher;
    if (!ctx.cipher)
      goto LABEL_7;
    goto LABEL_5;
  }
  if (a7 > 0xFFFFFFFFFFFFFFF7 || (v28 = malloc_type_malloc(a7 + 8, 0x30772F57uLL)) == 0)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v15 = 0;
    cipher = ctx.cipher;
    if (!ctx.cipher)
      goto LABEL_7;
    goto LABEL_5;
  }
  v29 = v28;
  *v28 = a7;
  v30 = (unsigned __int8 *)(v28 + 1);
  if (a7 >> 31)
  {
    ERR_put_error(19, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8.c", 395);
  }
  else
  {
    *(_QWORD *)outl = 0;
    if (EVP_DecryptUpdate(&ctx, v30, &outl[1], a6, a7))
    {
      v31 = outl[1];
      if (EVP_DecryptFinal_ex(&ctx, &v30[outl[1]], outl))
      {
        *a1 = v30;
        *a2 = outl[0] + v31;
        v15 = 1;
        cipher = ctx.cipher;
        if (!ctx.cipher)
          goto LABEL_7;
        goto LABEL_5;
      }
    }
  }
  if (*v29 != -8)
    bzero(v29, *v29 + 8);
  free(v29);
  v15 = 0;
  cipher = ctx.cipher;
  if (ctx.cipher)
  {
LABEL_5:
    cleanup = cipher->cleanup;
    if (cleanup)
      ((void (*)(EVP_CIPHER_CTX *))cleanup)(&ctx);
  }
LABEL_7:
  if (*(_QWORD *)&ctx.encrypt)
  {
    v19 = (void *)(*(_QWORD *)&ctx.encrypt - 8);
    v18 = *(_QWORD *)(*(_QWORD *)&ctx.encrypt - 8);
    if (v18 != -8)
      bzero(v19, v18 + 8);
    free(v19);
  }
  return v15;
}

unsigned int *PKCS8_parse_encrypted_private_key(unsigned __int8 **a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  const unsigned __int8 *v6;
  unsigned int *v7;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  size_t v12;
  unsigned __int8 *v13[2];
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;

  v20 = 0;
  v21 = 0;
  v18 = 0;
  v19 = 0;
  v16 = 0;
  v17 = 0;
  v13[0] = 0;
  LODWORD(v15) = 0;
  if (!cbs_get_any_asn1_element(a1, &v20, &v15, (unint64_t *)v13, 0, 0, 0))
    goto LABEL_11;
  if ((_DWORD)v15 != 536870928)
    goto LABEL_11;
  if (v21 < v13[0])
    goto LABEL_11;
  v20 += (unint64_t)v13[0];
  v21 -= (unint64_t)v13[0];
  v13[0] = 0;
  LODWORD(v15) = 0;
  if (!cbs_get_any_asn1_element(&v20, &v18, &v15, (unint64_t *)v13, 0, 0, 0))
    goto LABEL_11;
  if ((_DWORD)v15 != 536870928)
    goto LABEL_11;
  if (v19 < v13[0])
    goto LABEL_11;
  v18 += (unint64_t)v13[0];
  v19 -= (unint64_t)v13[0];
  v13[0] = 0;
  LODWORD(v15) = 0;
  if (!cbs_get_any_asn1_element(&v20, &v16, &v15, (unint64_t *)v13, 0, 0, 0)
    || (_DWORD)v15 != 4
    || (v5 = v17 - v13[0], v17 < v13[0])
    || (v6 = &v13[0][v16], v16 += (uint64_t)v13[0], v17 -= (unint64_t)v13[0], v21))
  {
LABEL_11:
    ERR_put_error(19, 0, 104, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8.c", 424);
    return 0;
  }
  v14 = 0;
  v15 = 0;
  if (!pkcs8_pbe_decrypt(&v15, &v14, &v18, a2, a3, v6, v5))
    return 0;
  v9 = v15;
  v13[0] = v15;
  v13[1] = v14;
  v7 = EVP_parse_private_key(v13);
  if (!v9)
    return v7;
  v11 = *((_QWORD *)v9 - 1);
  v10 = v9 - 8;
  v12 = v11 + 8;
  if (v11 != -8)
    bzero(v10, v12);
  free(v10);
  return v7;
}

BOOL PKCS8_marshal_encrypted_private_key(uint64_t *a1, int a2, const EVP_CIPHER *a3, void *a4, uint64_t a5, _QWORD *a6, unint64_t a7, int a8, uint64_t a9)
{
  unint64_t v10;
  __int128 v16;
  _QWORD *v17;
  _QWORD *v18;
  unsigned int v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned int (*v22)(__int128 *);
  const char *v23;
  int v24;
  int v25;
  int v26;
  _QWORD *v27;
  uint64_t v28;
  unsigned __int8 *v29;
  _BOOL8 v30;
  char *v31;
  uint64_t v32;
  size_t v33;
  const EVP_CIPHER *cipher;
  int (__cdecl *cleanup)(EVP_CIPHER_CTX *);
  uint64_t v36;
  void *v37;
  const unsigned __int8 *v39;
  uint64_t block_size;
  uint64_t v42;
  uint64_t v44;
  uint64_t v45;
  unint64_t *v46;
  BOOL v47;
  unint64_t v48;
  BOOL v49;
  __int128 *v50;
  uint64_t v51;
  size_t v52;
  int inl[2];
  int outl[2];
  unsigned __int8 *out;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  _OWORD v59[3];
  __int128 v60;
  _BYTE v61[32];
  _BYTE *v62;
  EVP_CIPHER_CTX ctx;

  v10 = a7;
  *(_QWORD *)&ctx.final[24] = *MEMORY[0x24BDAC8D0];
  v16 = 0uLL;
  memset(&ctx, 0, 152);
  if (a6)
  {
    v17 = a6;
    v18 = 0;
  }
  else
  {
    if (!a7)
      v10 = 8;
    if (v10 > 0xFFFFFFFFFFFFFFF7 || (v27 = malloc_type_malloc(v10 + 8, 0x30772F57uLL)) == 0)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v30 = 0;
      cipher = ctx.cipher;
      if (!ctx.cipher)
        goto LABEL_36;
      goto LABEL_34;
    }
    *v27 = v10;
    v17 = v27 + 1;
    RAND_bytes_with_additional_data((uint64_t)(v27 + 1), v10, (uint64_t)&RAND_bytes_kZeroAdditionalData);
    v18 = v17;
    v16 = 0uLL;
  }
  *(_OWORD *)v61 = v16;
  *(_OWORD *)&v61[16] = v16;
  if (a8 >= 1)
    v19 = a8;
  else
    v19 = 2048;
  v60 = v16;
  v20 = malloc_type_malloc(0x88uLL, 0x30772F57uLL);
  if (!v20)
  {
    v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v24 = 14;
    v25 = 65;
    v26 = 247;
    goto LABEL_19;
  }
  *v20 = 128;
  BYTE8(v60) = 0;
  *(_QWORD *)&v60 = 0;
  *(_QWORD *)v61 = v20 + 1;
  *(_OWORD *)&v61[8] = xmmword_208F2ADF0;
  v61[24] = 1;
  v21 = *(_QWORD *)(a9 + 16);
  if (!v21 || (v22 = *(unsigned int (**)(__int128 *))(v21 + 56)) == 0)
  {
    v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/evp/evp_asn1.c";
    v24 = 6;
    v25 = 128;
    v26 = 199;
    goto LABEL_19;
  }
  if (!v22(&v60))
    goto LABEL_20;
  if (BYTE8(v60))
  {
    v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/bytestring/cbb.c";
    v24 = 14;
    v25 = 66;
    v26 = 127;
LABEL_19:
    ERR_put_error(v24, 0, v25, v23, v26);
    goto LABEL_20;
  }
  if (!CBB_flush((uint64_t *)&v60))
  {
LABEL_20:
    if (BYTE8(v60) || (v61[24] & 1) == 0 || !*(_QWORD *)v61)
    {
      v30 = 0;
      goto LABEL_27;
    }
    v29 = (unsigned __int8 *)(*(_QWORD *)v61 - 8);
    v28 = *(_QWORD *)(*(_QWORD *)v61 - 8);
    if (v28 != -8)
      bzero((void *)(*(_QWORD *)v61 - 8), v28 + 8);
    v30 = 0;
    goto LABEL_75;
  }
  v39 = *(const unsigned __int8 **)v61;
  *(_QWORD *)inl = *(_QWORD *)&v61[8];
  *(_QWORD *)v61 = 0;
  memset(v59, 0, sizeof(v59));
  if (!CBB_flush(a1))
    goto LABEL_71;
  v62 = 0;
  if (!CBB_add_space((uint64_t)a1, &v62, 1))
    goto LABEL_71;
  *v62 = 48;
  if (!cbb_add_child((uint64_t)a1, (uint64_t)v59, 1u, 1))
    goto LABEL_71;
  if (!(a2 == -1
       ? PKCS5_pbe2_encrypt_init((uint64_t *)v59, &ctx, a3, v19, a4, a5, v17, v10)
       : pkcs12_pbe_encrypt_init((uint64_t *)v59, &ctx, a2, v19, (unsigned __int8 *)a4, a5, v17, v10)))
    goto LABEL_71;
  block_size = ctx.cipher->block_size;
  v42 = *(_QWORD *)inl + block_size;
  if (__CFADD__(*(_QWORD *)inl, block_size))
  {
    ERR_put_error(19, 0, 118, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8.c", 504);
    v30 = 0;
    if (!v39)
      goto LABEL_27;
LABEL_73:
    v51 = *((_QWORD *)v39 - 1);
    v29 = (unsigned __int8 *)(v39 - 8);
    v52 = v51 + 8;
    if (v51 != -8)
      bzero(v29, v52);
LABEL_75:
    free(v29);
    goto LABEL_27;
  }
  v57 = 0u;
  v58 = 0u;
  v56 = 0u;
  *(_QWORD *)outl = 0;
  out = 0;
  if (!CBB_flush((uint64_t *)v59))
    goto LABEL_71;
  v62 = 0;
  if (!CBB_add_space((uint64_t)v59, &v62, 1))
    goto LABEL_71;
  *v62 = 4;
  if (!cbb_add_child((uint64_t)v59, (uint64_t)&v56, 1u, 1)
    || !CBB_reserve((uint64_t)&v56, &out, v42)
    || !EVP_CipherUpdate(&ctx, out, &outl[1], v39, inl[0]))
  {
    goto LABEL_71;
  }
  v44 = outl[1];
  v30 = 0;
  if (!EVP_CipherFinal_ex(&ctx, &out[outl[1]], outl))
    goto LABEL_72;
  v45 = outl[0] + v44;
  v46 = (unint64_t *)&v57 + 1;
  if (BYTE8(v56))
    v46 = (unint64_t *)(v57 + 8);
  v47 = __CFADD__(*v46, v45);
  v48 = *v46 + v45;
  v49 = v47;
  if ((_QWORD)v56 || v49)
  {
LABEL_72:
    if (!v39)
      goto LABEL_27;
    goto LABEL_73;
  }
  v50 = BYTE8(v56) ? (__int128 *)(v57 + 16) : &v58;
  if (v48 > *(_QWORD *)v50)
  {
LABEL_71:
    v30 = 0;
    goto LABEL_72;
  }
  *v46 = v48;
  v30 = CBB_flush(a1) != 0;
  if (v39)
    goto LABEL_73;
LABEL_27:
  if (v18)
  {
    v32 = *(v18 - 1);
    v31 = (char *)(v18 - 1);
    v33 = v32 + 8;
    if (v32 != -8)
      bzero(v31, v33);
    free(v31);
  }
  cipher = ctx.cipher;
  if (ctx.cipher)
  {
LABEL_34:
    cleanup = cipher->cleanup;
    if (cleanup)
      ((void (*)(EVP_CIPHER_CTX *))cleanup)(&ctx);
  }
LABEL_36:
  if (*(_QWORD *)&ctx.encrypt)
  {
    v37 = (void *)(*(_QWORD *)&ctx.encrypt - 8);
    v36 = *(_QWORD *)(*(_QWORD *)&ctx.encrypt - 8);
    if (v36 != -8)
      bzero((void *)(*(_QWORD *)&ctx.encrypt - 8), v36 + 8);
    free(v37);
  }
  return v30;
}

uint64_t pkcs12_pbe_decrypt_init(uint64_t a1, EVP_CIPHER_CTX *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
  int v10;
  int v11;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned __int8 *v16;
  unint64_t v17;
  int v18;
  unint64_t v19;

  v16 = 0;
  v17 = 0;
  v14 = 0;
  v15 = 0;
  v19 = 0;
  LODWORD(v13) = 0;
  if (!cbs_get_any_asn1_element((unsigned __int8 **)a5, &v16, &v13, &v19, 0, 0, 0)
    || (_DWORD)v13 != 536870928
    || v17 < v19
    || (v16 += v19,
        v17 -= v19,
        v19 = 0,
        v18 = 0,
        !cbs_get_any_asn1_element(&v16, &v14, &v18, &v19, 0, 0, 0))
    || v18 != 4
    || v15 < v19
    || (v13 = 0, v14 += v19, v15 -= v19, !CBS_get_asn1_uint64(&v16, &v13))
    || v17
    || *(_QWORD *)(a5 + 8))
  {
    v10 = 104;
    v11 = 265;
LABEL_5:
    ERR_put_error(19, 0, v10, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8.c", v11);
    return 0;
  }
  if (v13 - 100000001 < 0xFFFFFFFFFA0A1F00)
  {
    v10 = 129;
    v11 = 270;
    goto LABEL_5;
  }
  return pkcs12_pbe_cipher_init(a1, a2, v13, a3, a4, v14, v15, 0);
}

EVP_PKEY *__cdecl EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8)
{
  unsigned int v1;
  unsigned int *v2;
  unsigned int i;
  unsigned int v4;
  uint64_t v5;
  void (*v6)(unsigned int *);
  unsigned int *v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned __int8 *out;

  out = 0;
  v1 = ASN1_item_i2d((ASN1_VALUE *)p8, &out, &PKCS8_PRIV_KEY_INFO_it);
  if ((v1 & 0x80000000) != 0)
    return 0;
  v13 = out;
  v14 = v1;
  v2 = EVP_parse_private_key(&v13);
  if (!v2 || v14)
  {
    ERR_put_error(19, 0, 104, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8_x509.c", 115);
    if (v2)
    {
      for (i = atomic_load(v2); i != -1; i = v4)
      {
        if (!i)
          abort();
        v4 = __ldaxr(v2);
        if (v4 == i)
        {
          if (!__stlxr(i - 1, v2))
          {
            if (i == 1)
            {
              v5 = *((_QWORD *)v2 + 2);
              if (v5)
              {
                v6 = *(void (**)(unsigned int *))(v5 + 160);
                if (v6)
                {
                  v6(v2);
                  *((_QWORD *)v2 + 1) = 0;
                  v2[1] = 0;
                }
              }
              v8 = *((_QWORD *)v2 - 1);
              v7 = v2 - 2;
              v9 = v8 + 8;
              if (v8 != -8)
                bzero(v7, v9);
              free(v7);
            }
            break;
          }
        }
        else
        {
          __clrex();
        }
      }
      v2 = 0;
    }
  }
  if (out)
  {
    v11 = out - 8;
    v10 = *((_QWORD *)out - 1);
    if (v10 != -8)
      bzero(v11, v10 + 8);
    free(v11);
  }
  return (EVP_PKEY *)v2;
}

PKCS8_PRIV_KEY_INFO *__cdecl EVP_PKEY2PKCS8(EVP_PKEY *pkey)
{
  _QWORD *v2;
  void *v3;
  char *ptr;
  unsigned int (*v5)(uint64_t *, EVP_PKEY *);
  const char *v6;
  int v7;
  int v8;
  int v9;
  unsigned __int8 *v10;
  uint64_t v11;
  char *v12;
  int v13;
  int v14;
  ASN1_VALUE *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  size_t v18;
  uint64_t v20;
  unsigned __int8 *v21;
  uint64_t v22;
  void *v23[2];
  __int128 v24;
  uint64_t v25;
  ASN1_VALUE *pval;

  v25 = 0;
  *(_OWORD *)v23 = 0u;
  v24 = 0u;
  v2 = malloc_type_malloc(8uLL, 0x30772F57uLL);
  if (v2)
  {
    *v2 = 0;
    v3 = v2 + 1;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v3 = 0;
  }
  LOBYTE(v23[0]) = 0;
  v22 = 0;
  v24 = 0uLL;
  v23[1] = v3;
  LOBYTE(v25) = 1;
  ptr = pkey->pkey.ptr;
  if (!ptr || (v5 = (unsigned int (*)(uint64_t *, EVP_PKEY *))*((_QWORD *)ptr + 7)) == 0)
  {
    v6 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cr"
         "ypto/evp/evp_asn1.c";
    v7 = 6;
    v8 = 128;
    v9 = 199;
    goto LABEL_10;
  }
  if (!v5(&v22, pkey))
  {
LABEL_11:
    v10 = 0;
    goto LABEL_12;
  }
  if (LOBYTE(v23[0]))
  {
    v6 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cr"
         "ypto/bytestring/cbb.c";
    v7 = 14;
    v8 = 66;
    v9 = 127;
LABEL_10:
    ERR_put_error(v7, 0, v8, v6, v9);
    goto LABEL_11;
  }
  if (!CBB_flush(&v22))
    goto LABEL_11;
  v10 = (unsigned __int8 *)v23[1];
  v20 = v24;
  v23[1] = 0;
  if ((v24 & 0x8000000000000000) != 0)
  {
LABEL_12:
    if (!LOBYTE(v23[0]) && (v25 & 1) != 0 && v23[1])
    {
      v12 = (char *)v23[1] - 8;
      v11 = *((_QWORD *)v23[1] - 1);
      if (v11 != -8)
        bzero(v12, v11 + 8);
      free(v12);
    }
    v13 = 105;
    v14 = 134;
    goto LABEL_19;
  }
  v21 = v10;
  pval = 0;
  if ((int)asn1_item_ex_d2i((uint64_t)&pval, &v21, v24, (uint64_t)&PKCS8_PRIV_KEY_INFO_it, -1, 0, 0, 0, 0) <= 0)
    ASN1_item_ex_free(&pval, &PKCS8_PRIV_KEY_INFO_it);
  v15 = pval;
  if (!pval)
  {
    pval = 0;
LABEL_33:
    ASN1_item_ex_free(&pval, &PKCS8_PRIV_KEY_INFO_it);
    v13 = 104;
    v14 = 142;
LABEL_19:
    ERR_put_error(19, 0, v13, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8_x509.c", v14);
    v15 = 0;
    goto LABEL_20;
  }
  if (v21 != &v10[v20])
    goto LABEL_33;
LABEL_20:
  if (v10)
  {
    v17 = *((_QWORD *)v10 - 1);
    v16 = v10 - 8;
    v18 = v17 + 8;
    if (v17 != -8)
      bzero(v16, v18);
    free(v16);
  }
  return (PKCS8_PRIV_KEY_INFO *)v15;
}

PKCS8_PRIV_KEY_INFO *__cdecl PKCS8_decrypt(X509_SIG *p8, const char *pass, int passlen)
{
  uint64_t v5;
  unsigned int v6;
  EVP_PKEY *v7;
  EVP_PKEY *v8;
  PKCS8_PRIV_KEY_INFO *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  uint64_t v12;
  size_t v13;
  unsigned int i;
  unsigned int v15;
  char *ptr;
  void (*v18)(EVP_PKEY *);
  STACK **p_attributes;
  STACK *attributes;
  size_t p_data;
  unsigned __int8 *v22;
  uint64_t v23;
  unsigned __int8 *out;

  if (pass && passlen == -1)
    v5 = strlen(pass);
  else
    v5 = passlen;
  out = 0;
  v6 = ASN1_item_i2d((ASN1_VALUE *)p8, &out, &X509_SIG_it);
  if ((v6 & 0x80000000) != 0)
  {
    v9 = 0;
    v8 = 0;
    v10 = out;
    if (out)
      goto LABEL_14;
    goto LABEL_9;
  }
  v22 = out;
  v23 = v6;
  v7 = (EVP_PKEY *)PKCS8_parse_encrypted_private_key(&v22, (uint64_t)pass, v5);
  v8 = v7;
  if (v7 && !v23)
  {
    v9 = EVP_PKEY2PKCS8(v7);
    v10 = out;
    if (out)
      goto LABEL_14;
LABEL_9:
    if (!v8)
      return v9;
    goto LABEL_17;
  }
  v9 = 0;
  v10 = out;
  if (!out)
    goto LABEL_9;
LABEL_14:
  v12 = *((_QWORD *)v10 - 1);
  v11 = v10 - 8;
  v13 = v12 + 8;
  if (v12 != -8)
    bzero(v11, v13);
  free(v11);
  if (!v8)
    return v9;
LABEL_17:
  for (i = atomic_load((unsigned int *)v8); i != -1; i = v15)
  {
    if (!i)
      abort();
    v15 = __ldaxr((unsigned int *)v8);
    if (v15 == i)
    {
      if (!__stlxr(i - 1, (unsigned int *)v8))
      {
        if (i != 1)
          return v9;
        ptr = v8->pkey.ptr;
        if (ptr)
        {
          v18 = (void (*)(EVP_PKEY *))*((_QWORD *)ptr + 20);
          if (v18)
          {
            v18(v8);
            *(_QWORD *)&v8->references = 0;
            v8->save_type = 0;
          }
        }
        attributes = v8[-1].attributes;
        p_attributes = &v8[-1].attributes;
        p_data = (size_t)&attributes->data;
        if (attributes != (STACK *)-8)
          bzero(p_attributes, p_data);
        free(p_attributes);
        return v9;
      }
    }
    else
    {
      __clrex();
    }
  }
  return v9;
}

X509_SIG *__cdecl PKCS8_encrypt(int pbe_nid, const EVP_CIPHER *cipher, const char *pass, int passlen, unsigned __int8 *salt, int saltlen, int iter, PKCS8_PRIV_KEY_INFO *p8)
{
  unint64_t v10;
  uint64_t v15;
  unsigned int v16;
  unsigned int *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  _QWORD *v20;
  const char *v21;
  int v22;
  int v23;
  unsigned int i;
  unsigned int v25;
  uint64_t v26;
  void (*v27)(unsigned int *);
  unsigned int *v28;
  uint64_t v29;
  size_t v30;
  uint64_t v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  uint64_t v35;
  void *v36;
  unsigned int j;
  unsigned int v38;
  uint64_t v39;
  void (*v40)(unsigned int *);
  unsigned int *v41;
  uint64_t v42;
  size_t v43;
  __int128 v44;
  uint64_t v45;
  size_t v46;
  unsigned __int8 *v47;
  _OWORD v48[3];
  unsigned __int8 *out;

  v10 = *(_QWORD *)&saltlen;
  if (pass && passlen == -1)
    v15 = strlen(pass);
  else
    v15 = passlen;
  out = 0;
  v16 = ASN1_item_i2d((ASN1_VALUE *)p8, &out, &PKCS8_PRIV_KEY_INFO_it);
  if ((v16 & 0x80000000) != 0)
    return 0;
  *(_QWORD *)&v48[0] = out;
  *((_QWORD *)&v48[0] + 1) = v16;
  v17 = EVP_parse_private_key((unsigned __int8 **)v48);
  if (!v17 || *((_QWORD *)&v48[0] + 1))
  {
    ERR_put_error(19, 0, 104, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8_x509.c", 115);
    if (v17)
    {
      for (i = atomic_load(v17); i != -1; i = v25)
      {
        if (!i)
LABEL_70:
          abort();
        v25 = __ldaxr(v17);
        if (v25 == i)
        {
          if (!__stlxr(i - 1, v17))
          {
            if (i == 1)
            {
              v26 = *((_QWORD *)v17 + 2);
              if (v26)
              {
                v27 = *(void (**)(unsigned int *))(v26 + 160);
                if (v27)
                {
                  v27(v17);
                  *((_QWORD *)v17 + 1) = 0;
                  v17[1] = 0;
                }
              }
              v29 = *((_QWORD *)v17 - 1);
              v28 = v17 - 2;
              v30 = v29 + 8;
              if (v29 != -8)
                bzero(v28, v30);
              free(v28);
            }
            break;
          }
        }
        else
        {
          __clrex();
        }
      }
    }
    if (out)
    {
      v32 = out - 8;
      v31 = *((_QWORD *)out - 1);
      if (v31 != -8)
        bzero(v32, v31 + 8);
      free(v32);
    }
    return 0;
  }
  if (out)
  {
    v19 = out - 8;
    v18 = *((_QWORD *)out - 1);
    if (v18 != -8)
      bzero(v19, v18 + 8);
    free(v19);
  }
  memset(v48, 0, sizeof(v48));
  v20 = malloc_type_malloc(0x88uLL, 0x30772F57uLL);
  if (!v20)
  {
    v21 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v22 = 65;
    v23 = 247;
    goto LABEL_38;
  }
  *v20 = 128;
  BYTE8(v48[0]) = 0;
  *(_QWORD *)&v48[0] = 0;
  *(_QWORD *)&v48[1] = v20 + 1;
  *(_OWORD *)((char *)&v48[1] + 8) = xmmword_208F2ADF0;
  BYTE8(v48[2]) = BYTE8(v48[2]) & 0xFC | 1;
  if (!PKCS8_marshal_encrypted_private_key((uint64_t *)v48, pbe_nid, cipher, (void *)pass, v15, salt, v10, iter, (uint64_t)v17))goto LABEL_39;
  if (BYTE8(v48[0]))
  {
    v21 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/bytestring/cbb.c";
    v22 = 66;
    v23 = 127;
LABEL_38:
    ERR_put_error(14, 0, v22, v21, v23);
    goto LABEL_39;
  }
  if (!CBB_flush((uint64_t *)v48))
  {
LABEL_39:
    if (BYTE8(v48[0]) || (BYTE8(v48[2]) & 1) == 0 || !*(_QWORD *)&v48[1])
    {
      v33 = 0;
      goto LABEL_46;
    }
    v36 = (void *)(*(_QWORD *)&v48[1] - 8);
    v35 = *(_QWORD *)(*(_QWORD *)&v48[1] - 8);
    if (v35 != -8)
      bzero(v36, v35 + 8);
    v33 = 0;
    goto LABEL_69;
  }
  v44 = v48[1];
  *(_QWORD *)&v48[1] = 0;
  v47 = (unsigned __int8 *)v44;
  out = 0;
  if ((int)asn1_item_ex_d2i((uint64_t)&out, &v47, *((uint64_t *)&v48[1] + 1), (uint64_t)&X509_SIG_it, -1, 0, 0, 0, 0) < 1)
    ASN1_item_ex_free((ASN1_VALUE **)&out, &X509_SIG_it);
  v33 = out;
  if (!out || v47 != (unsigned __int8 *)(v44 + *((_QWORD *)&v44 + 1)))
  {
    ERR_put_error(19, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/pkcs8/pkcs8_x509.c", 221);
    out = v33;
    ASN1_item_ex_free((ASN1_VALUE **)&out, &X509_SIG_it);
    v33 = 0;
  }
  if ((_QWORD)v44)
  {
    v45 = *(_QWORD *)(v44 - 8);
    v36 = (void *)(v44 - 8);
    v46 = v45 + 8;
    if (v45 != -8)
      bzero(v36, v46);
LABEL_69:
    free(v36);
  }
LABEL_46:
  for (j = atomic_load(v17); j != -1; j = v38)
  {
    if (!j)
      goto LABEL_70;
    v38 = __ldaxr(v17);
    if (v38 == j)
    {
      if (!__stlxr(j - 1, v17))
      {
        if (j == 1)
        {
          v39 = *((_QWORD *)v17 + 2);
          if (v39)
          {
            v40 = *(void (**)(unsigned int *))(v39 + 160);
            if (v40)
            {
              v40(v17);
              *((_QWORD *)v17 + 1) = 0;
              v17[1] = 0;
            }
          }
          v42 = *((_QWORD *)v17 - 1);
          v41 = v17 - 2;
          v43 = v42 + 8;
          if (v42 != -8)
            bzero(v41, v43);
          free(v41);
        }
        return (X509_SIG *)v33;
      }
    }
    else
    {
      __clrex();
    }
  }
  return (X509_SIG *)v33;
}

int X509_policy_check(X509_POLICY_TREE **ptree, int *pexplicit_policy, STACK *certs, STACK *policy_oids, unsigned int flags)
{
  X509_POLICY_TREE **v5;
  X509_POLICY_TREE *v6;
  X509_POLICY_TREE *v7;
  int v8;
  __int16 v10;
  char *v12;
  unint64_t *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  unsigned int v19;
  _QWORD *v20;
  _QWORD *v21;
  char *v22;
  int v23;
  char v24;
  const ASN1_OBJECT ****d2i;
  const ASN1_OBJECT ****v26;
  _BOOL4 v27;
  uint64_t v28;
  const ASN1_OBJECT ***v29;
  unint64_t v30;
  const ASN1_OBJECT **v31;
  int v32;
  unint64_t v33;
  uint64_t v34;
  size_t v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  ASN1_OBJECT *v43;
  unint64_t v44;
  void *v45;
  uint64_t v46;
  size_t v47;
  unint64_t *v48;
  uint64_t v49;
  size_t v50;
  void *v51;
  uint64_t v52;
  size_t v53;
  int v54;
  _DWORD *v55;
  char v56;
  unint64_t *v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  BOOL v62;
  unint64_t v63;
  uint64_t v64;
  const ASN1_OBJECT ***v65;
  int v66;
  unint64_t v67;
  ASN1_VALUE ***v68;
  unint64_t v69;
  ASN1_VALUE ***v70;
  ASN1_VALUE **v71;
  uint64_t v72;
  const ASN1_OBJECT ***v73;
  unint64_t *v74;
  unint64_t v75;
  unint64_t v76;
  ASN1_OBJECT *v77;
  unint64_t v78;
  void *v79;
  uint64_t v80;
  size_t v81;
  unint64_t *v82;
  uint64_t v83;
  size_t v84;
  void *v85;
  uint64_t v86;
  size_t v87;
  char *v88;
  unint64_t *v89;
  uint64_t v90;
  const ASN1_OBJECT **v91;
  ASN1_OBJECT *v92;
  unint64_t *v93;
  unint64_t v94;
  BOOL v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t (*v98)(int *, const ASN1_OBJECT ***);
  int v99;
  unint64_t v100;
  ASN1_VALUE ***v101;
  ASN1_VALUE ***v102;
  ASN1_VALUE **v103;
  unsigned int (*v104)(int *, const ASN1_OBJECT ***);
  const ASN1_OBJECT *v105;
  _QWORD *v106;
  _QWORD *v107;
  ASN1_OBJECT **v108;
  char *v109;
  BOOL v110;
  unint64_t *v111;
  unint64_t v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  void *v119;
  uint64_t v120;
  size_t v121;
  unint64_t *v122;
  uint64_t v123;
  size_t v124;
  unint64_t *v125;
  _QWORD *v126;
  BOOL v127;
  uint64_t v128;
  unint64_t v129;
  const ASN1_OBJECT **v130;
  _QWORD *v131;
  unint64_t *v132;
  uint64_t v133;
  ASN1_OBJECT *v134;
  unint64_t *v135;
  uint64_t v136;
  unint64_t v137;
  uint64_t v138;
  unint64_t v139;
  BOOL v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t (*v143)(int *, const ASN1_OBJECT ***);
  int v144;
  unint64_t v145;
  ASN1_VALUE ***v146;
  unint64_t v147;
  ASN1_VALUE ***v148;
  ASN1_VALUE **v149;
  unint64_t *v150;
  unint64_t v151;
  unint64_t v152;
  ASN1_OBJECT *v153;
  uint64_t v154;
  unsigned int (*v155)(int *, const ASN1_OBJECT ***);
  unint64_t v156;
  void *v157;
  uint64_t v158;
  size_t v159;
  unint64_t *v160;
  uint64_t v161;
  size_t v162;
  void *v163;
  uint64_t v164;
  size_t v165;
  uint64_t v166;
  const ASN1_OBJECT **v167;
  ASN1_OBJECT *v168;
  size_t length;
  unint64_t *v170;
  unint64_t v171;
  BOOL v172;
  unint64_t v173;
  unint64_t v174;
  uint64_t (*v175)(int *, const ASN1_OBJECT ***);
  int v176;
  unint64_t v177;
  ASN1_VALUE ***v178;
  ASN1_VALUE ***v179;
  ASN1_VALUE **v180;
  unsigned int (*v181)(int *, const ASN1_OBJECT ***);
  const ASN1_OBJECT *v182;
  _QWORD *v183;
  _QWORD *v184;
  char *v185;
  ASN1_OBJECT *v186;
  BOOL v187;
  unint64_t *v188;
  char *v189;
  unint64_t *v190;
  unint64_t v191;
  uint64_t v192;
  int v193;
  ASN1_VALUE *v194;
  BOOL v195;
  ASN1_OBJECT *v196;
  BOOL v197;
  char *v198;
  unint64_t **v199;
  uint64_t v200;
  uint64_t *v201;
  const ASN1_OBJECT *v202;
  size_t v203;
  ASN1_VALUE *v204;
  unint64_t *v205;
  _QWORD *v206;
  _QWORD *v207;
  char *v208;
  ASN1_OBJECT *v209;
  unint64_t v210;
  unint64_t v211;
  uint64_t v212;
  void *v213;
  uint64_t v214;
  size_t v215;
  void *v216;
  uint64_t v217;
  size_t v218;
  unint64_t v219;
  unint64_t v220;
  uint64_t v221;
  unint64_t v222;
  void *v223;
  uint64_t v224;
  size_t v225;
  unint64_t *v226;
  uint64_t v227;
  size_t v228;
  unint64_t v229;
  unint64_t v230;
  unint64_t v231;
  ASN1_VALUE *v232;
  BOOL v233;
  ASN1_VALUE *v234;
  uint64_t v235;
  int uint64;
  ASN1_VALUE *v237;
  unint64_t v238;
  uint64_t v239;
  int v240;
  ASN1_VALUE *v241;
  unint64_t v242;
  BUF_MEM *v243;
  BUF_MEM *v244;
  int v245;
  ASN1_VALUE *v246;
  unint64_t v247;
  char *data;
  char *v249;
  uint64_t v250;
  size_t v251;
  int *p_max;
  uint64_t v253;
  size_t v254;
  unint64_t *v255;
  unint64_t v256;
  unint64_t v257;
  ASN1_OBJECT *v258;
  unint64_t v259;
  unint64_t v260;
  ASN1_OBJECT *v261;
  unint64_t v262;
  void *v263;
  uint64_t v264;
  size_t v265;
  unint64_t *v266;
  uint64_t v267;
  size_t v268;
  unint64_t v269;
  unint64_t v270;
  uint64_t v271;
  unint64_t v272;
  void *v273;
  uint64_t v274;
  size_t v275;
  unint64_t *v276;
  uint64_t v277;
  size_t v278;
  char *v279;
  unint64_t v280;
  unint64_t v281;
  uint64_t v282;
  int v283;
  char *v284;
  unint64_t v285;
  void *v286;
  uint64_t v287;
  size_t v288;
  unint64_t *v289;
  uint64_t v290;
  size_t v291;
  void *v292;
  uint64_t v293;
  size_t v294;
  uint64_t v295;
  void *v296;
  uint64_t v297;
  size_t v298;
  char *v299;
  uint64_t v300;
  size_t v301;
  unint64_t v302;
  unint64_t v303;
  unint64_t **v304;
  unint64_t *v305;
  unint64_t v306;
  unint64_t v307;
  uint64_t v308;
  unint64_t v309;
  void *v310;
  uint64_t v311;
  size_t v312;
  unint64_t *v313;
  uint64_t v314;
  size_t v315;
  unint64_t **v316;
  uint64_t v317;
  size_t v318;
  unint64_t v319;
  void *v320;
  uint64_t v321;
  size_t v322;
  unint64_t *v323;
  uint64_t v324;
  size_t v325;
  unint64_t v327;
  uint64_t v328;
  uint64_t v329;
  unint64_t v330;
  uint64_t v331;
  int v332;
  uint64_t *v333;
  uint64_t v334;
  uint64_t v335;
  unint64_t v336;
  uint64_t v337;
  uint64_t *v338;
  uint64_t v339;
  uint64_t v340;
  unint64_t v341;
  unint64_t **v342;
  unint64_t *v343;
  unint64_t v344;
  uint64_t v345;
  unint64_t *v346;
  unint64_t v347;
  ASN1_VALUE *v348;
  unint64_t *v349;
  unint64_t v350;
  BOOL v351;
  unint64_t v352;
  unint64_t v353;
  uint64_t (*v354)(int *, const ASN1_OBJECT ***);
  int v355;
  unint64_t v356;
  ASN1_VALUE ***v357;
  ASN1_VALUE ***v358;
  ASN1_VALUE **v359;
  unsigned int (*v360)(int *, const ASN1_OBJECT ***);
  unint64_t *v361;
  uint64_t v362;
  unint64_t v363;
  uint64_t v364;
  _QWORD *v365;
  _DWORD *v366;
  int v367;
  int *v368;
  STACK *v369;
  X509_POLICY_TREE **v370;
  unint64_t v371;
  char v372;
  unint64_t *v373;
  unint64_t v374;
  unint64_t v375;
  unint64_t v376;
  unint64_t v377;
  unint64_t v378;
  X509_POLICY_TREE *v379;
  uint64_t v380;
  unint64_t **v381;
  uint64_t v382;
  _QWORD *v383;
  int crit;
  ASN1_VALUE *pval;
  uint64_t v386;
  uint64_t v387;
  const ASN1_OBJECT **v388;
  int v389[2];

  *(_QWORD *)&policy_oids->num = 0;
  if (!ptree)
    return 0;
  v5 = ptree;
  v6 = *ptree;
  v7 = (X509_POLICY_TREE *)((char *)*ptree - 2);
  if ((unint64_t)*ptree < 2)
    return 0;
  v10 = (__int16)certs;
  v12 = OPENSSL_sk_new_null();
  if (!v12)
    return 17;
  v13 = (unint64_t *)v12;
  v368 = pexplicit_policy;
  v369 = policy_oids;
  v14 = 0;
  if ((v10 & 0x100) != 0)
    v15 = 0;
  else
    v15 = (char *)v6 + 1;
  if ((v10 & 0x200) != 0)
    v16 = 0;
  else
    v16 = (char *)v6 + 1;
  v376 = (unint64_t)v15;
  v378 = (unint64_t)v16;
  v370 = v5;
  v371 = (unint64_t)v6;
  if ((v10 & 0x400) != 0)
    v17 = 0;
  else
    v17 = (char *)v6 + 1;
  v374 = (unint64_t)v17;
  v373 = (unint64_t *)v12;
  while (1)
  {
    v379 = v7;
    if (*v5 > v7)
      v18 = *((_QWORD *)v5[1] + (_QWORD)v7);
    else
      v18 = 0;
    if (!x509v3_cache_extensions((const void ****)v18))
    {
      v279 = 0;
      v8 = 17;
      goto LABEL_485;
    }
    v19 = *(_DWORD *)(v18 + 48);
    if (!v14)
      break;
LABEL_23:
    v372 = v19;
    v23 = (v19 >> 5) & 1;
    if (!v7)
      LOBYTE(v23) = 0;
    if (v378)
      v24 = 1;
    else
      v24 = v23;
    crit = 0;
    d2i = (const ASN1_OBJECT ****)X509V3_get_d2i(*(STACK **)(*(_QWORD *)v18 + 72), 89, &crit, 0);
    v380 = v18;
    v382 = v14;
    if (d2i)
    {
      v26 = d2i;
      if (!*d2i)
      {
        ERR_put_error(11, 0, 144, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/policy.c", 245);
        goto LABEL_482;
      }
      if (d2i[4] != (const ASN1_OBJECT ***)policyinfo_cmp)
        *((_DWORD *)d2i + 4) = 0;
      d2i[4] = (const ASN1_OBJECT ***)policyinfo_cmp;
      OPENSSL_sk_sort((uint64_t)d2i, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_POLICYINFO_call_cmp_func);
      if (*v26)
      {
        v27 = OBJ_obj2nid(**v26[1]) == 746;
        if ((unint64_t)*v26 >= 2)
        {
          v28 = 0;
          v29 = v26[1];
          do
          {
            v31 = v29[v28 + 1];
            v32 = OBJ_obj2nid(*v31);
            v33 = (unint64_t)*v26;
            v29 = v26[1];
            v34 = (uint64_t)*v29[v28];
            v35 = *(int *)(v34 + 20);
            if ((_DWORD)v35 == (*v31)->length
              && (!(_DWORD)v35 || !memcmp(*(const void **)(v34 + 24), (*v31)->data, v35)))
            {
              ERR_put_error(11, 0, 144, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/policy.c", 260);
              v18 = v380;
              v14 = v382;
              goto LABEL_482;
            }
            if (v32 == 746)
              v27 = 1;
            v30 = v28 + 2;
            ++v28;
          }
          while (v30 < v33);
        }
        v14 = v382;
        v55 = (_DWORD *)(v382 + 8);
        v54 = *(_DWORD *)(v382 + 8);
        if (v27)
          v56 = v24;
        else
          v56 = 0;
        if ((v56 & 1) != 0)
        {
          v18 = v380;
          if (!v54)
            goto LABEL_189;
          goto LABEL_124;
        }
        v18 = v380;
        v57 = *(unint64_t **)v382;
        if (*(_QWORD *)v382)
        {
LABEL_73:
          v366 = v55;
          v367 = v54;
          if (*v57)
          {
            v58 = 0;
            v59 = 0;
            while (1)
            {
              while (1)
              {
                v60 = *(_QWORD *)(v57[1] + 8 * v58);
                v386 = 0;
                pval = *(ASN1_VALUE **)v60;
                if (!v26[4])
                  break;
                v61 = (unint64_t)*v26;
                if (*((_DWORD *)v26 + 4))
                  v62 = 0;
                else
                  v62 = v61 >= 2;
                if (!v62)
                {
                  if (v61)
                  {
                    v63 = 0;
                    while (1)
                    {
                      v64 = v63 + ((v61 - v63 - 1) >> 1);
                      v65 = v26[4];
                      v388 = v26[1][v64];
                      *(_QWORD *)v389 = &pval;
                      v66 = ((uint64_t (*)(int *, const ASN1_OBJECT ***))v65)(v389, &v388);
                      if (v66 >= 1)
                      {
                        v63 = v64 + 1;
                      }
                      else if (v66 < 0)
                      {
                        v61 = v63 + ((v61 - v63 - 1) >> 1);
                      }
                      else
                      {
                        if (v61 - v63 == 1)
                          goto LABEL_75;
                        v61 = v64 + 1;
                      }
                      if (v63 >= v61)
                        goto LABEL_100;
                    }
                  }
                  goto LABEL_100;
                }
                v72 = 0;
                while (1)
                {
                  v73 = v26[4];
                  v388 = v26[1][v72];
                  *(_QWORD *)v389 = &pval;
                  if (!((unsigned int (*)(int *, const ASN1_OBJECT ***))v73)(v389, &v388))
                    break;
                  if (++v72 >= (unint64_t)*v26)
                    goto LABEL_100;
                }
LABEL_75:
                *(_QWORD *)(v57[1] + 8 * v59++) = *(_QWORD *)(v57[1] + 8 * v58);
                if (++v58 >= *v57)
                  goto LABEL_122;
              }
              v67 = (unint64_t)*v26;
              if (*v26)
              {
                v68 = (ASN1_VALUE ***)v26[1];
                if (*v68 != &pval)
                {
                  v69 = 0;
                  v70 = v68 + 1;
                  while (v67 - 1 != v69)
                  {
                    v71 = v70[v69++];
                    if (v71 == &pval)
                    {
                      if (v69 < v67)
                        goto LABEL_75;
                      goto LABEL_100;
                    }
                  }
                  goto LABEL_100;
                }
                goto LABEL_75;
              }
LABEL_100:
              ASN1_OBJECT_free(*(ASN1_OBJECT **)v60);
              v74 = *(unint64_t **)(v60 + 8);
              if (v74)
              {
                v75 = *v74;
                if (*v74)
                {
                  v76 = 0;
                  do
                  {
                    v77 = *(ASN1_OBJECT **)(v74[1] + 8 * v76);
                    if (v77)
                    {
                      ASN1_OBJECT_free(v77);
                      v75 = *v74;
                    }
                    ++v76;
                  }
                  while (v76 < v75);
                }
                v78 = v74[1];
                if (v78)
                {
                  v80 = *(_QWORD *)(v78 - 8);
                  v79 = (void *)(v78 - 8);
                  v81 = v80 + 8;
                  if (v80 != -8)
                    bzero(v79, v81);
                  free(v79);
                }
                v83 = *(v74 - 1);
                v82 = v74 - 1;
                v84 = v83 + 8;
                if (v83 != -8)
                  bzero(v82, v84);
                free(v82);
              }
              v86 = *(_QWORD *)(v60 - 8);
              v85 = (void *)(v60 - 8);
              v87 = v86 + 8;
              if (v86 != -8)
                bzero(v85, v87);
              free(v85);
              if (++v58 >= *v57)
                goto LABEL_122;
            }
          }
          v59 = 0;
LABEL_122:
          *v57 = v59;
          v18 = v380;
          v54 = v367;
          v55 = v366;
        }
      }
      else
      {
        v55 = (_DWORD *)(v14 + 8);
        v54 = *(_DWORD *)(v14 + 8);
        v57 = *(unint64_t **)v14;
        if (v57)
          goto LABEL_73;
      }
      *v55 = 0;
      v14 = v382;
      if (!v54)
      {
LABEL_189:
        pval = (ASN1_VALUE *)v26;
        ASN1_item_ex_free(&pval, &CERTIFICATEPOLICIES_it);
        v13 = v373;
        goto LABEL_190;
      }
LABEL_124:
      v88 = OPENSSL_sk_new_null();
      if (!v88)
        goto LABEL_482;
      v89 = (unint64_t *)v88;
      if (!*v26)
      {
LABEL_168:
        v112 = *v89;
        if (*v89)
        {
          v113 = 0;
          do
          {
            v114 = v112 <= v113 ? 0 : *(_QWORD *)(v89[1] + 8 * v113);
            if (!OPENSSL_sk_insert(*(unint64_t **)v14, v114, **(_QWORD **)v14))
              goto LABEL_470;
            v112 = *v89;
            if (*v89 > v113)
              *(_QWORD *)(v89[1] + 8 * v113) = 0;
          }
          while (++v113 < v112);
        }
        OPENSSL_sk_sort(*(_QWORD *)v14, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_X509_POLICY_NODE_call_cmp_func);
        v115 = *v89;
        if (*v89)
        {
          v116 = 0;
          do
          {
            v117 = *(_QWORD *)(v89[1] + 8 * v116);
            if (v117)
            {
              x509_policy_node_free(v117);
              v115 = *v89;
            }
            ++v116;
          }
          while (v116 < v115);
        }
        v118 = v89[1];
        if (v118)
        {
          v120 = *(_QWORD *)(v118 - 8);
          v119 = (void *)(v118 - 8);
          v121 = v120 + 8;
          if (v120 != -8)
            bzero(v119, v121);
          free(v119);
        }
        v123 = *(v89 - 1);
        v122 = v89 - 1;
        v124 = v123 + 8;
        if (v123 != -8)
          bzero(v122, v124);
        free(v122);
        goto LABEL_189;
      }
      v90 = 0;
      while (2)
      {
        v91 = v26[1][v90];
        if (OBJ_obj2nid(*v91) == 746)
          goto LABEL_128;
        v92 = (ASN1_OBJECT *)*v91;
        v386 = 0;
        v387 = 0;
        pval = (ASN1_VALUE *)v92;
        v93 = *(unint64_t **)v14;
        if (!*(_QWORD *)v14)
          goto LABEL_155;
        if (v93[4])
        {
          v94 = *v93;
          if (*((_DWORD *)v93 + 4))
            v95 = 0;
          else
            v95 = v94 >= 2;
          if (!v95)
          {
            if (v94)
            {
              v96 = 0;
              while (1)
              {
                v97 = v96 + ((v94 - v96 - 1) >> 1);
                v98 = (uint64_t (*)(int *, const ASN1_OBJECT ***))v93[4];
                v388 = *(const ASN1_OBJECT ***)(v93[1] + 8 * v97);
                *(_QWORD *)v389 = &pval;
                v99 = v98(v389, &v388);
                if (v99 >= 1)
                {
                  v96 = v97 + 1;
                }
                else if (v99 < 0)
                {
                  v94 = v96 + ((v94 - v96 - 1) >> 1);
                }
                else
                {
                  if (v94 - v96 == 1)
                    goto LABEL_164;
                  v94 = v97 + 1;
                }
                if (v96 >= v94)
                  goto LABEL_155;
              }
            }
            goto LABEL_155;
          }
          v97 = 0;
          while (1)
          {
            v104 = (unsigned int (*)(int *, const ASN1_OBJECT ***))v93[4];
            v388 = *(const ASN1_OBJECT ***)(v93[1] + 8 * v97);
            *(_QWORD *)v389 = &pval;
            if (!v104(v389, &v388))
              goto LABEL_164;
            if (++v97 >= *v93)
              goto LABEL_155;
          }
        }
        v100 = *v93;
        if (!*v93)
          goto LABEL_155;
        v101 = (ASN1_VALUE ***)v93[1];
        if (*v101 == &pval)
        {
          v97 = 0;
          goto LABEL_164;
        }
        v97 = 0;
        v102 = v101 + 1;
        do
        {
          if (v100 - 1 == v97)
            goto LABEL_155;
          v103 = v102[v97++];
        }
        while (v103 != &pval);
        if (v97 >= v100)
        {
LABEL_155:
          v18 = v380;
          v14 = v382;
        }
        else
        {
LABEL_164:
          v14 = v382;
          v111 = *(unint64_t **)v382;
          if (!*(_QWORD *)v382 || *v111 <= v97)
          {
            v18 = v380;
            v105 = *v91;
            v106 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
            if (!v106)
            {
LABEL_447:
              ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
              goto LABEL_470;
            }
LABEL_157:
            v107 = v106;
            *v106 = 24;
            v106[1] = 0;
            v108 = (ASN1_OBJECT **)(v106 + 1);
            v106[2] = 0;
            v106[3] = 0;
            v106[1] = OBJ_dup(v105);
            v109 = OPENSSL_sk_new_null();
            v107[2] = v109;
            if (*v108)
              v110 = v109 == 0;
            else
              v110 = 1;
            if (v110)
            {
              ASN1_OBJECT_free(*v108);
              v255 = (unint64_t *)v107[2];
              if (v255)
              {
                v256 = *v255;
                if (*v255)
                {
                  v257 = 0;
                  do
                  {
                    v258 = *(ASN1_OBJECT **)(v255[1] + 8 * v257);
                    if (v258)
                    {
                      ASN1_OBJECT_free(v258);
                      v256 = *v255;
                    }
                    ++v257;
                  }
                  while (v257 < v256);
                }
LABEL_460:
                v262 = v255[1];
                if (v262)
                {
                  v264 = *(_QWORD *)(v262 - 8);
                  v263 = (void *)(v262 - 8);
                  v265 = v264 + 8;
                  if (v264 != -8)
                    bzero(v263, v265);
                  free(v263);
                }
                v267 = *(v255 - 1);
                v266 = v255 - 1;
                v268 = v267 + 8;
                if (v267 != -8)
                  bzero(v266, v268);
                free(v266);
              }
LABEL_467:
              if (*v107 != -8)
                __memset_chk();
              free(v107);
LABEL_470:
              v269 = *v89;
              if (*v89)
              {
                v270 = 0;
                do
                {
                  v271 = *(_QWORD *)(v89[1] + 8 * v270);
                  if (v271)
                  {
                    x509_policy_node_free(v271);
                    v269 = *v89;
                  }
                  ++v270;
                }
                while (v270 < v269);
              }
              v272 = v89[1];
              if (v272)
              {
                v274 = *(_QWORD *)(v272 - 8);
                v273 = (void *)(v272 - 8);
                v275 = v274 + 8;
                if (v274 != -8)
                  bzero(v273, v275);
                free(v273);
              }
              v277 = *(v89 - 1);
              v276 = v89 - 1;
              v278 = v277 + 8;
              if (v277 != -8)
                bzero(v276, v278);
              free(v276);
LABEL_482:
              pval = (ASN1_VALUE *)v26;
              ASN1_item_ex_free(&pval, &CERTIFICATEPOLICIES_it);
LABEL_483:
              v13 = v373;
              goto LABEL_484;
            }
            if (!OPENSSL_sk_insert(v89, (uint64_t)v108, *v89))
            {
              ASN1_OBJECT_free((ASN1_OBJECT *)v107[1]);
              v255 = (unint64_t *)v107[2];
              if (v255)
              {
                v259 = *v255;
                if (*v255)
                {
                  v260 = 0;
                  do
                  {
                    v261 = *(ASN1_OBJECT **)(v255[1] + 8 * v260);
                    if (v261)
                    {
                      ASN1_OBJECT_free(v261);
                      v259 = *v255;
                    }
                    ++v260;
                  }
                  while (v260 < v259);
                }
                goto LABEL_460;
              }
              goto LABEL_467;
            }
LABEL_128:
            if (++v90 >= (unint64_t)*v26)
              goto LABEL_168;
            continue;
          }
          v18 = v380;
          if (*(_QWORD *)(v111[1] + 8 * v97))
            goto LABEL_128;
        }
        break;
      }
      v105 = *v91;
      v106 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
      if (!v106)
        goto LABEL_447;
      goto LABEL_157;
    }
    if (crit != -1)
      goto LABEL_483;
    *(_DWORD *)(v14 + 8) = 0;
    v36 = *(unint64_t **)v14;
    v13 = v373;
    if (*(_QWORD *)v14)
    {
      v37 = 0;
      while (1)
      {
        v38 = *v36;
        if (v37 >= *v36)
          break;
        v39 = *(_QWORD *)(v36[1] + 8 * v37);
        if (v39)
        {
          ASN1_OBJECT_free(*(ASN1_OBJECT **)v39);
          v40 = *(unint64_t **)(v39 + 8);
          if (v40)
          {
            v41 = *v40;
            if (*v40)
            {
              v42 = 0;
              do
              {
                v43 = *(ASN1_OBJECT **)(v40[1] + 8 * v42);
                if (v43)
                {
                  ASN1_OBJECT_free(v43);
                  v41 = *v40;
                }
                ++v42;
              }
              while (v42 < v41);
            }
            v44 = v40[1];
            if (v44)
            {
              v46 = *(_QWORD *)(v44 - 8);
              v45 = (void *)(v44 - 8);
              v47 = v46 + 8;
              if (v46 != -8)
                bzero(v45, v47);
              free(v45);
            }
            v49 = *(v40 - 1);
            v48 = v40 - 1;
            v50 = v49 + 8;
            if (v49 != -8)
              bzero(v48, v50);
            free(v48);
          }
          v52 = *(_QWORD *)(v39 - 8);
          v51 = (void *)(v39 - 8);
          v53 = v52 + 8;
          if (v52 != -8)
            bzero(v51, v53);
          free(v51);
          v36 = *(unint64_t **)v14;
        }
        ++v37;
        if (!v36)
          goto LABEL_190;
      }
      if (v38)
      {
        if (8 * v38)
          bzero((void *)v36[1], 8 * v38);
        *v36 = 0;
        *((_DWORD *)v36 + 4) = 0;
      }
    }
LABEL_190:
    if (!v376 && !*(_DWORD *)(v14 + 8))
    {
      v125 = *(unint64_t **)v14;
      if (!*(_QWORD *)v14)
      {
        v279 = 0;
        v8 = 43;
        goto LABEL_521;
      }
      if (!*v125)
      {
        v279 = 0;
        v8 = 43;
LABEL_514:
        v285 = v125[1];
        if (v285)
        {
          v287 = *(_QWORD *)(v285 - 8);
          v286 = (void *)(v285 - 8);
          v288 = v287 + 8;
          if (v287 != -8)
            bzero(v286, v288);
          free(v286);
        }
        v290 = *(v125 - 1);
        v289 = v125 - 1;
        v291 = v290 + 8;
        if (v290 != -8)
          bzero(v289, v291);
        free(v289);
        goto LABEL_521;
      }
    }
    if (!OPENSSL_sk_insert(v13, v14, *v13))
    {
      v279 = 0;
      v8 = 17;
      v125 = *(unint64_t **)v14;
      if (*(_QWORD *)v14)
      {
LABEL_487:
        v280 = *v125;
        if (*v125)
        {
          v281 = 0;
          do
          {
            v282 = *(_QWORD *)(v125[1] + 8 * v281);
            if (v282)
            {
              x509_policy_node_free(v282);
              v280 = *v125;
            }
            ++v281;
          }
          while (v281 < v280);
        }
        goto LABEL_514;
      }
LABEL_521:
      v293 = *(_QWORD *)(v14 - 8);
      v292 = (void *)(v14 - 8);
      v294 = v293 + 8;
      if (v293 != -8)
        bzero(v292, v294);
      free(v292);
LABEL_524:
      if (v279)
      {
        v295 = *((_QWORD *)v279 + 1);
        if (v295)
        {
          v297 = *(_QWORD *)(v295 - 8);
          v296 = (void *)(v295 - 8);
          v298 = v297 + 8;
          if (v297 != -8)
            bzero(v296, v298);
          free(v296);
        }
        v300 = *((_QWORD *)v279 - 1);
        v299 = v279 - 8;
        v301 = v300 + 8;
        if (v300 != -8)
          bzero(v299, v301);
        free(v299);
      }
      goto LABEL_532;
    }
    if (!v379)
    {
      v131 = 0;
      goto LABEL_394;
    }
    crit = 0;
    v126 = X509V3_get_d2i(*(STACK **)(*(_QWORD *)v18 + 72), 747, &crit, 0);
    if (v126)
      v127 = 1;
    else
      v127 = crit == -1;
    if (!v127)
    {
LABEL_496:
      v13 = v373;
LABEL_497:
      *(_QWORD *)&v369->num = v18;
      v8 = 42;
      goto LABEL_532;
    }
    v128 = (uint64_t)v126;
    if (!v126)
      goto LABEL_314;
    if (!*v126)
    {
      ERR_put_error(11, 0, 144, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/policy.c", 369);
LABEL_210:
      v131 = 0;
      v132 = 0;
      goto LABEL_367;
    }
    v129 = 0;
    while (v129 < *(_QWORD *)v128)
    {
      v130 = *(const ASN1_OBJECT ***)(*(_QWORD *)(v128 + 8) + 8 * v129);
      if (OBJ_obj2nid(*v130) != 746)
      {
        ++v129;
        if (OBJ_obj2nid(v130[1]) != 746)
          continue;
      }
      goto LABEL_210;
    }
    if (*(uint64_t (**)(uint64_t **, uint64_t **))(v128 + 32) != compare_issuer_policy)
      *(_DWORD *)(v128 + 16) = 0;
    *(_QWORD *)(v128 + 32) = compare_issuer_policy;
    OPENSSL_sk_sort(v128, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_POLICY_MAPPING_call_cmp_func);
    if (!v374)
    {
      v135 = *(unint64_t **)v14;
      if (v135)
      {
        if (*v135)
        {
          v136 = 0;
          v137 = 0;
          while (1)
          {
            while (1)
            {
              v138 = *(_QWORD *)(v135[1] + 8 * v136);
              pval = *(ASN1_VALUE **)v138;
              v386 = 0;
              if (!*(_QWORD *)(v128 + 32))
                break;
              v139 = *(_QWORD *)v128;
              if (*(_DWORD *)(v128 + 16))
                v140 = 0;
              else
                v140 = v139 >= 2;
              if (!v140)
              {
                if (v139)
                {
                  v141 = 0;
                  while (1)
                  {
                    v142 = v141 + ((v139 - v141 - 1) >> 1);
                    v143 = *(uint64_t (**)(int *, const ASN1_OBJECT ***))(v128 + 32);
                    v388 = *(const ASN1_OBJECT ***)(*(_QWORD *)(v128 + 8) + 8 * v142);
                    *(_QWORD *)v389 = &pval;
                    v144 = v143(v389, &v388);
                    if (v144 >= 1)
                    {
                      v141 = v142 + 1;
                    }
                    else if (v144 < 0)
                    {
                      v139 = v141 + ((v139 - v141 - 1) >> 1);
                    }
                    else
                    {
                      if (v139 - v141 == 1)
                        goto LABEL_241;
                      v139 = v142 + 1;
                    }
                    if (v141 >= v139)
                      goto LABEL_220;
                  }
                }
                goto LABEL_220;
              }
              v154 = 0;
              while (1)
              {
                v155 = *(unsigned int (**)(int *, const ASN1_OBJECT ***))(v128 + 32);
                v388 = *(const ASN1_OBJECT ***)(*(_QWORD *)(v128 + 8) + 8 * v154);
                *(_QWORD *)v389 = &pval;
                if (!v155(v389, &v388))
                  break;
                if ((unint64_t)++v154 >= *(_QWORD *)v128)
                  goto LABEL_220;
              }
LABEL_241:
              ASN1_OBJECT_free(*(ASN1_OBJECT **)v138);
              v150 = *(unint64_t **)(v138 + 8);
              if (v150)
              {
                v151 = *v150;
                if (*v150)
                {
                  v152 = 0;
                  do
                  {
                    v153 = *(ASN1_OBJECT **)(v150[1] + 8 * v152);
                    if (v153)
                    {
                      ASN1_OBJECT_free(v153);
                      v151 = *v150;
                    }
                    ++v152;
                  }
                  while (v152 < v151);
                }
                v156 = v150[1];
                if (v156)
                {
                  v158 = *(_QWORD *)(v156 - 8);
                  v157 = (void *)(v156 - 8);
                  v159 = v158 + 8;
                  if (v158 != -8)
                    bzero(v157, v159);
                  free(v157);
                }
                v161 = *(v150 - 1);
                v160 = v150 - 1;
                v162 = v161 + 8;
                if (v161 != -8)
                  bzero(v160, v162);
                free(v160);
              }
              v164 = *(_QWORD *)(v138 - 8);
              v163 = (void *)(v138 - 8);
              v165 = v164 + 8;
              if (v164 != -8)
                bzero(v163, v165);
              free(v163);
              if (++v136 >= *v135)
                goto LABEL_312;
            }
            v145 = *(_QWORD *)v128;
            if (*(_QWORD *)v128)
            {
              v146 = *(ASN1_VALUE ****)(v128 + 8);
              if (*v146 != &pval)
              {
                v147 = 0;
                v148 = v146 + 1;
                while (v145 - 1 != v147)
                {
                  v149 = v148[v147++];
                  if (v149 == &pval)
                  {
                    if (v147 >= v145)
                      goto LABEL_220;
                    goto LABEL_241;
                  }
                }
                goto LABEL_220;
              }
              goto LABEL_241;
            }
LABEL_220:
            *(_QWORD *)(v135[1] + 8 * v137++) = *(_QWORD *)(v135[1] + 8 * v136);
            if (++v136 >= *v135)
              goto LABEL_312;
          }
        }
        v137 = 0;
LABEL_312:
        *v135 = v137;
        v18 = v380;
      }
      OPENSSL_sk_pop_free_ex((unint64_t *)v128, (void (*)(uint64_t))sk_POLICY_MAPPING_call_free_func, (uint64_t)POLICY_MAPPING_free);
      v14 = v382;
LABEL_314:
      v189 = OPENSSL_sk_new_null();
      if (!v189)
        goto LABEL_496;
      v128 = (uint64_t)v189;
      v132 = 0;
      goto LABEL_316;
    }
    v132 = (unint64_t *)OPENSSL_sk_new_null();
    if (!v132)
      goto LABEL_359;
    if (*(_QWORD *)v128)
    {
      v133 = 0;
      v134 = 0;
      while (2)
      {
        v167 = *(const ASN1_OBJECT ***)(*(_QWORD *)(v128 + 8) + 8 * v133);
        v168 = (ASN1_OBJECT *)*v167;
        if (v134)
        {
          length = v168->length;
          if ((_DWORD)length == v134->length && (!(_DWORD)length || !memcmp(v168->data, v134->data, length)))
            goto LABEL_265;
        }
        v386 = 0;
        v387 = 0;
        pval = (ASN1_VALUE *)v168;
        v170 = *(unint64_t **)v14;
        if (!*(_QWORD *)v14)
          goto LABEL_295;
        if (v170[4])
        {
          v171 = *v170;
          if (*((_DWORD *)v170 + 4))
            v172 = 0;
          else
            v172 = v171 >= 2;
          if (!v172)
          {
            if (v171)
            {
              v173 = 0;
              while (1)
              {
                v174 = v173 + ((v171 - v173 - 1) >> 1);
                v175 = (uint64_t (*)(int *, const ASN1_OBJECT ***))v170[4];
                v388 = *(const ASN1_OBJECT ***)(v170[1] + 8 * v174);
                *(_QWORD *)v389 = &pval;
                v176 = v175(v389, &v388);
                if (v176 >= 1)
                {
                  v173 = v174 + 1;
                }
                else if (v176 < 0)
                {
                  v171 = v173 + ((v171 - v173 - 1) >> 1);
                }
                else
                {
                  if (v171 - v173 == 1)
                    goto LABEL_305;
                  v171 = v174 + 1;
                }
                if (v173 >= v171)
                  goto LABEL_295;
              }
            }
            goto LABEL_295;
          }
          v174 = 0;
          while (1)
          {
            v181 = (unsigned int (*)(int *, const ASN1_OBJECT ***))v170[4];
            v388 = *(const ASN1_OBJECT ***)(v170[1] + 8 * v174);
            *(_QWORD *)v389 = &pval;
            if (!v181(v389, &v388))
              goto LABEL_305;
            if (++v174 >= *v170)
              goto LABEL_295;
          }
        }
        v177 = *v170;
        if (!*v170)
          goto LABEL_295;
        v178 = (ASN1_VALUE ***)v170[1];
        if (*v178 == &pval)
        {
          v174 = 0;
          goto LABEL_305;
        }
        v174 = 0;
        v179 = v178 + 1;
        do
        {
          if (v177 - 1 == v174)
            goto LABEL_295;
          v180 = v179[v174++];
        }
        while (v180 != &pval);
        if (v174 < v177)
        {
LABEL_305:
          v14 = v382;
          v188 = *(unint64_t **)v382;
          if (!*(_QWORD *)v382 || *v188 <= v174)
          {
            v18 = v380;
            if (!*(_DWORD *)(v382 + 8))
            {
LABEL_264:
              v134 = v168;
LABEL_265:
              if ((unint64_t)++v133 >= *(_QWORD *)v128)
                goto LABEL_309;
              continue;
            }
LABEL_297:
            v182 = *v167;
            v183 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
            if (!v183)
            {
              ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
              goto LABEL_366;
            }
            v184 = v183;
            *v183 = 24;
            v183[1] = 0;
            v166 = (uint64_t)(v183 + 1);
            v183[2] = 0;
            v183[3] = 0;
            v183[1] = OBJ_dup(v182);
            v185 = OPENSSL_sk_new_null();
            v184[2] = v185;
            v186 = *(ASN1_OBJECT **)v166;
            if (*(_QWORD *)v166)
              v187 = v185 == 0;
            else
              v187 = 1;
            if (v187)
              goto LABEL_444;
            if (!OPENSSL_sk_insert(v132, v166, *v132))
            {
              v186 = (ASN1_OBJECT *)v184[1];
LABEL_444:
              ASN1_OBJECT_free(v186);
              OPENSSL_sk_pop_free_ex((unint64_t *)v184[2], (void (*)(uint64_t))sk_ASN1_OBJECT_call_free_func, (uint64_t)ASN1_OBJECT_free);
              OPENSSL_free((_QWORD *)v166);
              goto LABEL_366;
            }
            v14 = v382;
LABEL_263:
            *(_DWORD *)(v166 + 16) = 1;
            goto LABEL_264;
          }
          v166 = *(_QWORD *)(v188[1] + 8 * v174);
          v18 = v380;
          if (v166)
            goto LABEL_263;
        }
        else
        {
LABEL_295:
          v18 = v380;
          v14 = v382;
        }
        break;
      }
      if (!*(_DWORD *)(v14 + 8))
        goto LABEL_264;
      goto LABEL_297;
    }
LABEL_309:
    if (!x509_policy_level_add_nodes((unint64_t **)v14, v132))
      goto LABEL_359;
LABEL_316:
    v190 = *(unint64_t **)v14;
    if (*(_QWORD *)v14)
    {
      v191 = 0;
      do
      {
        if (v191 >= *v190)
          break;
        v192 = *(_QWORD *)(v190[1] + 8 * v191);
        if (!*(_DWORD *)(v192 + 16))
        {
          pval = 0;
          v193 = ASN1_item_ex_new(&pval, &POLICY_MAPPING_it);
          v194 = pval;
          if (v193)
            v195 = pval == 0;
          else
            v195 = 1;
          if (v195)
            goto LABEL_365;
          *(_QWORD *)v194 = OBJ_dup(*(const ASN1_OBJECT **)v192);
          v196 = OBJ_dup(*(const ASN1_OBJECT **)v192);
          *((_QWORD *)v194 + 1) = v196;
          if (*(_QWORD *)v194)
            v197 = v196 == 0;
          else
            v197 = 1;
          if (v197 || !OPENSSL_sk_insert((unint64_t *)v128, (uint64_t)v194, *(_QWORD *)v128))
          {
            pval = v194;
            ASN1_item_ex_free(&pval, &POLICY_MAPPING_it);
            v18 = v380;
            goto LABEL_366;
          }
          v190 = *(unint64_t **)v14;
        }
        ++v191;
      }
      while (v190);
    }
    if (*(uint64_t (**)(uint64_t, uint64_t))(v128 + 32) != compare_subject_policy)
      *(_DWORD *)(v128 + 16) = 0;
    *(_QWORD *)(v128 + 32) = compare_subject_policy;
    OPENSSL_sk_sort(v128, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_POLICY_MAPPING_call_cmp_func);
    v131 = OPENSSL_zalloc(0x10uLL);
    v18 = v380;
    if (!v131)
      goto LABEL_367;
    v198 = OPENSSL_sk_new((uint64_t)x509_policy_node_cmp);
    *v131 = v198;
    if (!v198)
    {
      OPENSSL_free(v131);
LABEL_359:
      v131 = 0;
      goto LABEL_367;
    }
    *((_DWORD *)v131 + 2) = *(_DWORD *)(v14 + 8);
    if (!*(_QWORD *)v128)
    {
LABEL_360:
      OPENSSL_sk_sort(*v131, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_X509_POLICY_NODE_call_cmp_func);
      v18 = v380;
      goto LABEL_367;
    }
    v199 = 0;
    v200 = 0;
    while (1)
    {
      v201 = *(uint64_t **)(*(_QWORD *)(v128 + 8) + 8 * v200);
      if (!*(_DWORD *)(v382 + 8))
      {
        v204 = (ASN1_VALUE *)*v201;
        v386 = 0;
        v387 = 0;
        pval = v204;
        *(_QWORD *)v389 = 0;
        if (!OPENSSL_sk_find(*(_QWORD *)v382, (unint64_t *)v389, (uint64_t)&pval, (uint64_t (*)(_QWORD, uint64_t, _QWORD))sk_X509_POLICY_NODE_call_cmp_func))goto LABEL_338;
        v205 = *(unint64_t **)v382;
        if (!*(_QWORD *)v382 || *v205 <= *(_QWORD *)v389 || !*(_QWORD *)(v205[1] + 8 * *(_QWORD *)v389))
          goto LABEL_338;
      }
      if (!v199)
        break;
      v202 = (const ASN1_OBJECT *)v201[1];
      v203 = *((int *)*v199 + 5);
      if ((_DWORD)v203 != v202->length || (_DWORD)v203 && memcmp((const void *)(*v199)[3], v202->data, v203))
        goto LABEL_351;
LABEL_355:
      if (!OPENSSL_sk_insert(v199[1], *v201, *v199[1]))
        goto LABEL_364;
      *v201 = 0;
LABEL_338:
      if ((unint64_t)++v200 >= *(_QWORD *)v128)
        goto LABEL_360;
    }
    v202 = (const ASN1_OBJECT *)v201[1];
LABEL_351:
    v206 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (!v206)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      goto LABEL_364;
    }
    v207 = v206;
    *v206 = 24;
    v206[1] = 0;
    v199 = (unint64_t **)(v206 + 1);
    v206[2] = 0;
    v206[3] = 0;
    v206[1] = OBJ_dup(v202);
    v208 = OPENSSL_sk_new_null();
    v207[2] = v208;
    v209 = (ASN1_OBJECT *)*v199;
    if (!*v199 || !v208)
      goto LABEL_363;
    if (OPENSSL_sk_insert((unint64_t *)*v131, (uint64_t)v199, *(_QWORD *)*v131))
      goto LABEL_355;
    v209 = (ASN1_OBJECT *)v207[1];
LABEL_363:
    ASN1_OBJECT_free(v209);
    OPENSSL_sk_pop_free_ex((unint64_t *)v207[2], (void (*)(uint64_t))sk_ASN1_OBJECT_call_free_func, (uint64_t)ASN1_OBJECT_free);
    OPENSSL_free(v199);
LABEL_364:
    OPENSSL_sk_pop_free_ex((unint64_t *)*v131, (void (*)(uint64_t))sk_X509_POLICY_NODE_call_free_func, (uint64_t)x509_policy_node_free);
    OPENSSL_free(v131);
LABEL_365:
    v18 = v380;
LABEL_366:
    v131 = 0;
    if (v128)
    {
LABEL_367:
      v210 = *(_QWORD *)v128;
      if (*(_QWORD *)v128)
      {
        v211 = 0;
        do
        {
          if (*(_QWORD *)(*(_QWORD *)(v128 + 8) + 8 * v211))
          {
            pval = *(ASN1_VALUE **)(*(_QWORD *)(v128 + 8) + 8 * v211);
            ASN1_item_ex_free(&pval, &POLICY_MAPPING_it);
            v210 = *(_QWORD *)v128;
          }
          ++v211;
        }
        while (v211 < v210);
      }
      v212 = *(_QWORD *)(v128 + 8);
      if (v212)
      {
        v214 = *(_QWORD *)(v212 - 8);
        v213 = (void *)(v212 - 8);
        v215 = v214 + 8;
        if (v214 != -8)
          bzero(v213, v215);
        free(v213);
      }
      v217 = *(_QWORD *)(v128 - 8);
      v216 = (void *)(v128 - 8);
      v218 = v217 + 8;
      if (v217 != -8)
        bzero(v216, v218);
      free(v216);
    }
    v13 = v373;
    if (v132)
    {
      v219 = *v132;
      if (*v132)
      {
        v220 = 0;
        do
        {
          v221 = *(_QWORD *)(v132[1] + 8 * v220);
          if (v221)
          {
            x509_policy_node_free(v221);
            v219 = *v132;
          }
          ++v220;
        }
        while (v220 < v219);
      }
      v222 = v132[1];
      if (v222)
      {
        v224 = *(_QWORD *)(v222 - 8);
        v223 = (void *)(v222 - 8);
        v225 = v224 + 8;
        if (v224 != -8)
          bzero(v223, v225);
        free(v223);
      }
      v227 = *(v132 - 1);
      v226 = v132 - 1;
      v228 = v227 + 8;
      if (v227 != -8)
        bzero(v226, v228);
      free(v226);
    }
    if (!v131)
      goto LABEL_497;
    if ((v372 & 0x20) == 0)
    {
LABEL_394:
      if (v376)
        v229 = v376 - 1;
      else
        v229 = 0;
      v230 = v374 - 1;
      if (!v374)
        v230 = 0;
      v374 = v230;
      v231 = v378 - 1;
      if (!v378)
        v231 = 0;
      v376 = v229;
      v378 = v231;
    }
    v14 = (uint64_t)v131;
    v389[0] = 0;
    v232 = (ASN1_VALUE *)X509V3_get_d2i(*(STACK **)(*(_QWORD *)v18 + 72), 401, v389, 0);
    if (v232)
      v233 = 1;
    else
      v233 = v389[0] == -1;
    if (!v233)
    {
LABEL_484:
      v279 = 0;
      *(_QWORD *)&v369->num = v18;
      v8 = 42;
      goto LABEL_485;
    }
    v234 = v232;
    if (v232)
    {
      v235 = *(_QWORD *)v232;
      if (*(_QWORD *)v232)
      {
        if ((*(_BYTE *)(v235 + 5) & 1) == 0)
        {
          pval = 0;
          uint64 = asn1_string_get_uint64(&pval, (const void **)v235, 2);
          v237 = pval;
          v238 = v376;
          if ((unint64_t)pval >= v376)
            v237 = (ASN1_VALUE *)v376;
          if (uint64)
            v238 = (unint64_t)v237;
          v376 = v238;
          ERR_clear_error();
          v239 = *((_QWORD *)v234 + 1);
          if (!v239)
          {
LABEL_423:
            pval = v234;
            ASN1_item_ex_free(&pval, &POLICY_CONSTRAINTS_it);
            goto LABEL_424;
          }
LABEL_417:
          if ((*(_BYTE *)(v239 + 5) & 1) == 0)
          {
            pval = 0;
            v240 = asn1_string_get_uint64(&pval, (const void **)v239, 2);
            v241 = pval;
            v242 = v374;
            if ((unint64_t)pval >= v374)
              v241 = (ASN1_VALUE *)v374;
            if (v240)
              v242 = (unint64_t)v241;
            v374 = v242;
            ERR_clear_error();
            goto LABEL_423;
          }
        }
        v283 = 517;
      }
      else
      {
        v239 = *((_QWORD *)v232 + 1);
        if (v239)
          goto LABEL_417;
        v283 = 548;
      }
      ERR_put_error(11, 0, 144, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/policy.c", v283);
      pval = v234;
      ASN1_item_ex_free(&pval, &POLICY_CONSTRAINTS_it);
      goto LABEL_484;
    }
LABEL_424:
    v243 = (BUF_MEM *)X509V3_get_d2i(*(STACK **)(*(_QWORD *)v18 + 72), 748, v389, 0);
    v244 = v243;
    if (!v243 && v389[0] != -1)
      goto LABEL_484;
    if (v243)
    {
      if ((*((_BYTE *)&v243->length + 5) & 1) != 0)
      {
        ERR_put_error(11, 0, 144, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/policy.c", 517);
        ASN1_STRING_free(v244);
        goto LABEL_484;
      }
      pval = 0;
      v245 = asn1_string_get_uint64(&pval, (const void **)v243, 2);
      v246 = pval;
      v247 = v378;
      if ((unint64_t)pval >= v378)
        v246 = (ASN1_VALUE *)v378;
      if (v245)
        v247 = (unint64_t)v246;
      v378 = v247;
      ERR_clear_error();
      data = v244->data;
      v5 = v370;
      if (data)
      {
        v250 = *((_QWORD *)data - 1);
        v249 = data - 8;
        v251 = v250 + 8;
        if (v250 != -8)
          bzero(v249, v251);
        free(v249);
      }
      v253 = *(_QWORD *)&v244[-1].max;
      p_max = &v244[-1].max;
      v254 = v253 + 8;
      if (v253 != -8)
        bzero(p_max, v254);
      free(p_max);
      v7 = (X509_POLICY_TREE *)((char *)v379 - 1);
      if ((unint64_t)v379 - 1 >= v371)
      {
LABEL_498:
        if (v376)
        {
          v8 = 0;
          v279 = 0;
          goto LABEL_485;
        }
        if (!v368)
        {
          v279 = 0;
          goto LABEL_561;
        }
        v284 = OPENSSL_sk_dup((uint64_t)v368);
        v279 = v284;
        if (!v284)
        {
          v8 = 17;
          goto LABEL_485;
        }
        if (*((uint64_t (**)(uint64_t, uint64_t))v284 + 4) != asn1_object_cmp)
          *((_DWORD *)v284 + 4) = 0;
        *((_QWORD *)v284 + 4) = asn1_object_cmp;
        OPENSSL_sk_sort((uint64_t)v284, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_ASN1_OBJECT_call_cmp_func);
LABEL_561:
        v327 = *v13;
        v328 = *v13 - 1;
        if (*v13)
          v329 = *(_QWORD *)(v13[1] + 8 * v328);
        else
          v329 = 0;
        if (!*(_DWORD *)(v329 + 8) && (!*(_QWORD *)v329 || !**(_QWORD **)v329))
        {
          v8 = 43;
          goto LABEL_485;
        }
        if (!v279)
          goto LABEL_576;
        v330 = 0;
        v331 = *(_QWORD *)v279;
        while (v330 < *(_QWORD *)v279)
        {
          v332 = OBJ_obj2nid(*(const ASN1_OBJECT **)(*((_QWORD *)v279 + 1) + 8 * v330++));
          if (v332 == 746)
            goto LABEL_576;
        }
        if (!v331 || *(_DWORD *)(v329 + 8))
        {
LABEL_576:
          v8 = 0;
          goto LABEL_485;
        }
        v383 = v131;
        v333 = *(uint64_t **)v329;
        if (*(_QWORD *)v329)
        {
          v334 = *v333;
          if (*v333)
          {
            v335 = v333[1];
            if (v334 == 1)
            {
              v336 = 0;
              goto LABEL_584;
            }
            v337 = 0;
            v336 = v334 & 0xFFFFFFFFFFFFFFFELL;
            do
            {
              v338 = (uint64_t *)(v335 + 8 * v337);
              v340 = *v338;
              v339 = v338[1];
              *(_DWORD *)(v340 + 20) = 1;
              *(_DWORD *)(v339 + 20) = 1;
              v337 += 2;
            }
            while (v337 != v336);
            for (; v334 != v336; ++v336)
LABEL_584:
              *(_DWORD *)(*(_QWORD *)(v335 + 8 * v336) + 20) = 1;
          }
        }
        if (v327)
        {
          v341 = v328;
          v375 = v327;
          while (1)
          {
            if (*v373 <= v341)
              v342 = 0;
            else
              v342 = *(unint64_t ***)(v373[1] + 8 * v341);
            v377 = v341 - 1;
            v343 = *v342;
            if (v341)
            {
              if (v343)
              {
                v344 = 0;
                do
                {
                  if (v344 >= *v343)
                    break;
                  v345 = *(_QWORD *)(v343[1] + 8 * v344);
                  if (*(_DWORD *)(v345 + 20))
                  {
                    v346 = *(unint64_t **)(v345 + 8);
                    if (v346 && *v346)
                    {
                      if (*v373 <= v377)
                        v381 = 0;
                      else
                        v381 = *(unint64_t ***)(v373[1] + 8 * v377);
                      v347 = 0;
                      while (1)
                      {
                        if (v347 >= *v346)
                          goto LABEL_595;
                        v348 = *(ASN1_VALUE **)(v346[1] + 8 * v347);
                        v386 = 0;
                        v387 = 0;
                        pval = v348;
                        v349 = *v381;
                        if (*v381)
                        {
                          if (v349[4])
                          {
                            v350 = *v349;
                            if (*((_DWORD *)v349 + 4))
                              v351 = 0;
                            else
                              v351 = v350 >= 2;
                            if (!v351)
                            {
                              if (v350)
                              {
                                v352 = 0;
                                while (1)
                                {
                                  v353 = v352 + ((v350 - v352 - 1) >> 1);
                                  v354 = (uint64_t (*)(int *, const ASN1_OBJECT ***))v349[4];
                                  v388 = *(const ASN1_OBJECT ***)(v349[1] + 8 * v353);
                                  *(_QWORD *)v389 = &pval;
                                  v355 = v354(v389, &v388);
                                  if (v355 >= 1)
                                  {
                                    v352 = v353 + 1;
                                  }
                                  else if (v355 < 0)
                                  {
                                    v350 = v352 + ((v350 - v352 - 1) >> 1);
                                  }
                                  else
                                  {
                                    if (v350 - v352 == 1)
                                      goto LABEL_633;
                                    v350 = v353 + 1;
                                  }
                                  if (v352 >= v350)
                                    goto LABEL_604;
                                }
                              }
                              goto LABEL_604;
                            }
                            v353 = 0;
                            while (1)
                            {
                              v360 = (unsigned int (*)(int *, const ASN1_OBJECT ***))v349[4];
                              v388 = *(const ASN1_OBJECT ***)(v349[1] + 8 * v353);
                              *(_QWORD *)v389 = &pval;
                              if (!v360(v389, &v388))
                                goto LABEL_633;
                              if (++v353 >= *v349)
                                goto LABEL_604;
                            }
                          }
                          v356 = *v349;
                          if (*v349)
                          {
                            v357 = (ASN1_VALUE ***)v349[1];
                            if (*v357 != &pval)
                            {
                              v353 = 0;
                              v358 = v357 + 1;
                              while (v356 - 1 != v353)
                              {
                                v359 = v358[v353++];
                                if (v359 == &pval)
                                {
                                  if (v353 >= v356)
                                    goto LABEL_604;
                                  goto LABEL_633;
                                }
                              }
                              goto LABEL_604;
                            }
                            v353 = 0;
LABEL_633:
                            v361 = *v381;
                            if (*v381)
                            {
                              if (*v361 > v353)
                              {
                                v362 = *(_QWORD *)(v361[1] + 8 * v353);
                                if (v362)
                                  *(_DWORD *)(v362 + 20) = 1;
                              }
                            }
                          }
                        }
LABEL_604:
                        ++v347;
                        v346 = *(unint64_t **)(v345 + 8);
                        if (!v346)
                          goto LABEL_595;
                      }
                    }
                    if (OPENSSL_sk_find((uint64_t)v279, 0, *(_QWORD *)v345, (uint64_t (*)(_QWORD, uint64_t, _QWORD))sk_ASN1_OBJECT_call_cmp_func))goto LABEL_646;
                  }
LABEL_595:
                  ++v344;
                  v343 = *v342;
                }
                while (*v342);
              }
            }
            else if (v343)
            {
              v363 = 0;
              do
              {
                if (v363 >= *v343)
                  break;
                v364 = *(_QWORD *)(v343[1] + 8 * v363);
                if (*(_DWORD *)(v364 + 20))
                {
                  v365 = *(_QWORD **)(v364 + 8);
                  if (!v365 || !*v365)
                  {
                    if (OPENSSL_sk_find((uint64_t)v279, 0, *(_QWORD *)v364, (uint64_t (*)(_QWORD, uint64_t, _QWORD))sk_ASN1_OBJECT_call_cmp_func))
                    {
LABEL_646:
                      v8 = 0;
                      goto LABEL_648;
                    }
                    v343 = *v342;
                  }
                }
                ++v363;
              }
              while (v343);
            }
            v8 = 43;
            v341 = v377;
            if (v377 >= v375)
              goto LABEL_648;
          }
        }
        v8 = 43;
LABEL_648:
        v13 = v373;
        v14 = (uint64_t)v383;
LABEL_485:
        if (!v14)
          goto LABEL_524;
        v125 = *(unint64_t **)v14;
        if (*(_QWORD *)v14)
          goto LABEL_487;
        goto LABEL_521;
      }
    }
    else
    {
      v5 = v370;
      v7 = (X509_POLICY_TREE *)((char *)v379 - 1);
      if ((unint64_t)v379 - 1 >= v371)
        goto LABEL_498;
    }
  }
  v20 = malloc_type_malloc(0x18uLL, 0x30772F57uLL);
  if (!v20)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    goto LABEL_503;
  }
  v21 = v20;
  *v20 = 16;
  v20[1] = 0;
  v14 = (uint64_t)(v20 + 1);
  v20[2] = 0;
  v22 = OPENSSL_sk_new((uint64_t)x509_policy_node_cmp);
  *(_QWORD *)v14 = v22;
  if (v22)
  {
    *((_DWORD *)v21 + 4) = 1;
    goto LABEL_23;
  }
  OPENSSL_free((_QWORD *)v14);
LABEL_503:
  v8 = 17;
  v13 = v373;
LABEL_532:
  v302 = *v13;
  if (*v13)
  {
    v303 = 0;
    do
    {
      v304 = *(unint64_t ***)(v13[1] + 8 * v303);
      if (v304)
      {
        v305 = *v304;
        if (*v304)
        {
          v306 = *v305;
          if (*v305)
          {
            v307 = 0;
            do
            {
              v308 = *(_QWORD *)(v305[1] + 8 * v307);
              if (v308)
              {
                x509_policy_node_free(v308);
                v306 = *v305;
              }
              ++v307;
            }
            while (v307 < v306);
          }
          v309 = v305[1];
          if (v309)
          {
            v311 = *(_QWORD *)(v309 - 8);
            v310 = (void *)(v309 - 8);
            v312 = v311 + 8;
            if (v311 != -8)
              bzero(v310, v312);
            free(v310);
          }
          v314 = *(v305 - 1);
          v313 = v305 - 1;
          v315 = v314 + 8;
          if (v314 != -8)
            bzero(v313, v315);
          free(v313);
        }
        v317 = (uint64_t)*(v304 - 1);
        v316 = v304 - 1;
        v318 = v317 + 8;
        if (v317 != -8)
          bzero(v316, v318);
        free(v316);
        v302 = *v13;
      }
      ++v303;
    }
    while (v303 < v302);
  }
  v319 = v13[1];
  if (v319)
  {
    v321 = *(_QWORD *)(v319 - 8);
    v320 = (void *)(v319 - 8);
    v322 = v321 + 8;
    if (v321 != -8)
      bzero(v320, v322);
    free(v320);
  }
  v324 = *(v13 - 1);
  v323 = v13 - 1;
  v325 = v324 + 8;
  if (v324 != -8)
    bzero(v323, v325);
  free(v323);
  return v8;
}

uint64_t asn1_object_cmp(uint64_t a1, uint64_t a2)
{
  size_t v2;
  int v3;

  v2 = *(int *)(*(_QWORD *)a1 + 20);
  v3 = *(_DWORD *)(*(_QWORD *)a2 + 20);
  if ((int)v2 < v3)
    return 0xFFFFFFFFLL;
  if ((int)v2 > v3)
    return 1;
  if ((_DWORD)v2)
    return memcmp(*(const void **)(*(_QWORD *)a1 + 24), *(const void **)(*(_QWORD *)a2 + 24), v2);
  return 0;
}

uint64_t x509_policy_node_cmp(uint64_t **a1, uint64_t **a2)
{
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  int v5;

  v2 = **a1;
  v3 = **a2;
  v4 = *(int *)(v2 + 20);
  v5 = *(_DWORD *)(v3 + 20);
  if ((int)v4 < v5)
    return 0xFFFFFFFFLL;
  if ((int)v4 > v5)
    return 1;
  if ((_DWORD)v4)
    return memcmp(*(const void **)(v2 + 24), *(const void **)(v3 + 24), v4);
  return 0;
}

uint64_t policyinfo_cmp(uint64_t **a1, uint64_t **a2)
{
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  int v5;

  v2 = **a1;
  v3 = **a2;
  v4 = *(int *)(v2 + 20);
  v5 = *(_DWORD *)(v3 + 20);
  if ((int)v4 < v5)
    return 0xFFFFFFFFLL;
  if ((int)v4 > v5)
    return 1;
  if ((_DWORD)v4)
    return memcmp(*(const void **)(v2 + 24), *(const void **)(v3 + 24), v4);
  return 0;
}

void x509_policy_node_free(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  ASN1_OBJECT *v5;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  unint64_t *v10;
  uint64_t v11;
  size_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;

  if (a1)
  {
    ASN1_OBJECT_free(*(ASN1_OBJECT **)a1);
    v2 = *(unint64_t **)(a1 + 8);
    if (v2)
    {
      v3 = *v2;
      if (*v2)
      {
        v4 = 0;
        do
        {
          v5 = *(ASN1_OBJECT **)(v2[1] + 8 * v4);
          if (v5)
          {
            ASN1_OBJECT_free(v5);
            v3 = *v2;
          }
          ++v4;
        }
        while (v4 < v3);
      }
      v6 = v2[1];
      if (v6)
      {
        v8 = *(_QWORD *)(v6 - 8);
        v7 = (void *)(v6 - 8);
        v9 = v8 + 8;
        if (v8 != -8)
          bzero(v7, v9);
        free(v7);
      }
      v11 = *(v2 - 1);
      v10 = v2 - 1;
      v12 = v11 + 8;
      if (v11 != -8)
        bzero(v10, v12);
      free(v10);
    }
    v14 = *(_QWORD *)(a1 - 8);
    v13 = (void *)(a1 - 8);
    v15 = v14 + 8;
    if (v14 != -8)
      bzero(v13, v15);
    free(v13);
  }
}

unint64_t *x509_policy_level_add_nodes(unint64_t **a1, unint64_t *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t *result;

  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = 0;
      do
      {
        if (v4 <= v5)
        {
          result = OPENSSL_sk_insert(*a1, 0, **a1);
          if (!result)
            return result;
        }
        else
        {
          result = OPENSSL_sk_insert(*a1, *(_QWORD *)(a2[1] + 8 * v5), **a1);
          if (!result)
            return result;
        }
        v4 = *a2;
        if (*a2 > v5)
          *(_QWORD *)(a2[1] + 8 * v5) = 0;
        ++v5;
      }
      while (v5 < v4);
    }
  }
  OPENSSL_sk_sort((uint64_t)*a1, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_X509_POLICY_NODE_call_cmp_func);
  return (unint64_t *)1;
}

uint64_t sk_POLICYINFO_call_cmp_func(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a3;
  v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sk_X509_POLICY_NODE_call_cmp_func(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a3;
  v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sk_ASN1_OBJECT_call_free_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sk_X509_POLICY_NODE_call_free_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t compare_issuer_policy(uint64_t **a1, uint64_t **a2)
{
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  int v5;

  v2 = **a1;
  v3 = **a2;
  v4 = *(int *)(v2 + 20);
  v5 = *(_DWORD *)(v3 + 20);
  if ((int)v4 < v5)
    return 0xFFFFFFFFLL;
  if ((int)v4 > v5)
    return 1;
  if ((_DWORD)v4)
    return memcmp(*(const void **)(v2 + 24), *(const void **)(v3 + 24), v4);
  return 0;
}

uint64_t compare_subject_policy(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  int v5;

  v2 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  v3 = *(_QWORD *)(*(_QWORD *)a2 + 8);
  v4 = *(int *)(v2 + 20);
  v5 = *(_DWORD *)(v3 + 20);
  if ((int)v4 < v5)
    return 0xFFFFFFFFLL;
  if ((int)v4 > v5)
    return 1;
  if ((_DWORD)v4)
    return memcmp(*(const void **)(v2 + 24), *(const void **)(v3 + 24), v4);
  return 0;
}

uint64_t sk_POLICY_MAPPING_call_cmp_func(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a3;
  v5 = a2;
  return a1(&v5, &v4);
}

uint64_t sk_POLICY_MAPPING_call_free_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t sk_ASN1_OBJECT_call_cmp_func(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a3;
  v5 = a2;
  return a1(&v5, &v4);
}

unsigned int *poly1305_update(unsigned int *result, unsigned int *a2, unint64_t a3)
{
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unint64_t v25;
  unsigned int v26;
  unint64_t v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t i;
  char *v34;
  unint64_t v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;

  v4 = result;
  v40 = *MEMORY[0x24BDAC8D0];
  if (a3 < 0x10)
    goto LABEL_5;
  v5 = result[9];
  v6 = result[10];
  v7 = result[11];
  v8 = result[12];
  v9 = result[13];
LABEL_3:
  v10 = *a2;
  v11 = a2[1];
  v12 = a2[2];
  v13 = a2[3];
  a2 += 4;
  a3 -= 16;
  v14 = (v10 & 0x3FFFFFF) + v5;
  v15 = (((v10 | (unint64_t)(v11 << 32)) >> 26) & 0x3FFFFFF) + v6;
  v4[9] = v14;
  v4[10] = v15;
  v16 = (((v11 | (unint64_t)(v12 << 32)) >> 20) & 0x3FFFFFF) + v7;
  v17 = (((v12 | (unint64_t)(v13 << 32)) >> 14) & 0x3FFFFFF) + v8;
  v4[11] = v16;
  v4[12] = v17;
  v18 = v9 + (v13 >> 8) + 0x1000000;
  for (v4[13] = v18; ; v18 = v4[13] + (v39 >> 8))
  {
    v19 = v4[1];
    v21 = v4[7];
    v20 = v4[8];
    v22 = v4[6];
    v24 = v4[3];
    v23 = v4[4];
    v25 = *v4 * (unint64_t)v14
        + v20 * (unint64_t)v15
        + v21 * (unint64_t)v16
        + v22 * (unint64_t)v17
        + v4[5] * (unint64_t)v18;
    v26 = v4[2];
    v27 = *v4 * (unint64_t)v18;
    v28 = v25 & 0x3FFFFFF;
    v29 = *v4 * (unint64_t)v15
        + v20 * (unint64_t)v16
        + v21 * (unint64_t)v17
        + v22 * (unint64_t)v18
        + v19 * (unint64_t)v14
        + (v25 >> 26);
    v6 = v29 & 0x3FFFFFF;
    result = (unsigned int *)(*v4 * (unint64_t)v16 + v20 * (unint64_t)v17);
    v30 = (unint64_t)result
        + v21 * (unint64_t)v18
        + v19 * (unint64_t)v15
        + v26 * (unint64_t)v14
        + (v29 >> 26);
    v7 = v30 & 0x3FFFFFF;
    v31 = *v4 * (unint64_t)v17
        + v20 * (unint64_t)v18
        + v19 * (unint64_t)v16
        + v26 * (unint64_t)v15
        + v24 * (unint64_t)v14
        + (v30 >> 26);
    v8 = v31 & 0x3FFFFFF;
    v4[11] = v30 & 0x3FFFFFF;
    v4[12] = v31 & 0x3FFFFFF;
    v32 = v27
        + v19 * (unint64_t)v17
        + v26 * (unint64_t)v16
        + v24 * (unint64_t)v15
        + v23 * (unint64_t)v14
        + (v31 >> 26);
    v9 = v32 & 0x3FFFFFF;
    v4[13] = v32 & 0x3FFFFFF;
    v5 = 5 * (v32 >> 26) + v28;
    v4[9] = v5;
    v4[10] = v6;
    if (a3 > 0xF)
      goto LABEL_3;
LABEL_5:
    if (!a3)
      break;
    for (i = 0; i != a3; ++i)
      *((_BYTE *)&v36 + i) = *((_BYTE *)a2 + i);
    *((_BYTE *)&v36 + a3) = 1;
    if ((unint64_t)(i - 1) <= 0xD)
    {
      v34 = (char *)&v36 + i + 1;
      v35 = 14 - a3;
      if (a3 > 0xE)
        v35 = 0;
      bzero(v34, v35 + 1);
    }
    a3 = 0;
    v14 = v4[9] + (v36 & 0x3FFFFFF);
    v15 = (((v36 | ((unint64_t)v37 << 32)) >> 26) & 0x3FFFFFF) + v4[10];
    v16 = (((v37 | ((unint64_t)v38 << 32)) >> 20) & 0x3FFFFFF) + v4[11];
    v17 = (((v38 | ((unint64_t)v39 << 32)) >> 14) & 0x3FFFFFF) + v4[12];
  }
  return result;
}

uint64_t CRYPTO_poly1305_finish(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  _DWORD *v4;
  unint64_t v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  signed int v19;
  uint64_t result;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;

  v3 = -(int)a1 & 0x3FLL;
  v4 = (_DWORD *)(a1 + v3);
  v5 = *(_QWORD *)(a1 + v3 + 72);
  if (v5)
    poly1305_update((unsigned int *)(a1 + v3), v4 + 14, v5);
  v6 = v4[9];
  v7 = v6 & 0x3FFFFFF;
  v8 = v4[10] + (v6 >> 26);
  v9 = v8 & 0x3FFFFFF;
  v10 = v4[11] + (v8 >> 26);
  v11 = v10 & 0x3FFFFFF;
  v12 = v4[12] + (v10 >> 26);
  v13 = v12 & 0x3FFFFFF;
  v14 = v4[13] + (v12 >> 26);
  v15 = 5 * (v14 >> 26) + v7;
  v16 = v9 + ((v15 + 5) >> 26);
  v17 = v11 + (v16 >> 26);
  v18 = v13 + (v17 >> 26);
  v19 = (v14 | 0xFC000000) + (v18 >> 26);
  result = (v19 >> 31);
  v21 = (v19 >> 31) - 1;
  v22 = v21 & 0x3FFFFFF & (v15 + 5) | result & v15;
  v23 = v21 & 0x3FFFFFF & v16 | result & v9;
  v4[9] = v22;
  v4[10] = v23;
  v24 = v21 & 0x3FFFFFF & v17 | result & v11;
  v25 = v21 & 0x3FFFFFF & v18 | result & v13;
  v4[11] = v24;
  v4[12] = v25;
  v26 = v21 & v19 | v14 & result & 0x3FFFFFF;
  v4[13] = v26;
  v27 = v22 | (v23 << 26);
  v28 = v4[20];
  v29 = (v23 >> 6) | (v24 << 20);
  v30 = v4[23];
  v31 = ((v24 >> 12) | (v25 << 14)) + (unint64_t)v4[22];
  v32 = v4[21] + __CFADD__(v27, v28) + v29;
  *a2 = v27 + v28;
  a2[1] = v32;
  v33 = v31 + HIDWORD(v32);
  a2[2] = v33;
  a2[3] = ((v25 >> 18) | (v26 << 8)) + v30 + HIDWORD(v33);
  return result;
}

char **CRYPTO_BUFFER_POOL_new()
{
  char *v0;
  char *v1;
  char **v2;
  char *v3;

  v0 = (char *)malloc_type_malloc(0xE8uLL, 0x30772F57uLL);
  if (v0)
  {
    v1 = v0;
    *(_QWORD *)v0 = 224;
    *(_OWORD *)(v0 + 8) = 0u;
    v2 = (char **)(v0 + 8);
    *(_OWORD *)(v0 + 24) = 0u;
    *(_OWORD *)(v0 + 40) = 0u;
    *(_OWORD *)(v0 + 56) = 0u;
    *(_OWORD *)(v0 + 72) = 0u;
    *(_OWORD *)(v0 + 88) = 0u;
    *(_OWORD *)(v0 + 104) = 0u;
    *(_OWORD *)(v0 + 120) = 0u;
    *(_OWORD *)(v0 + 136) = 0u;
    *(_OWORD *)(v0 + 152) = 0u;
    *(_OWORD *)(v0 + 168) = 0u;
    *(_OWORD *)(v0 + 184) = 0u;
    *(_OWORD *)(v0 + 200) = 0u;
    *(_OWORD *)(v0 + 216) = 0u;
    v3 = OPENSSL_lh_new((uint64_t)CRYPTO_BUFFER_hash, (uint64_t)CRYPTO_BUFFER_cmp);
    *v2 = v3;
    if (v3)
    {
      if (pthread_rwlock_init((pthread_rwlock_t *)(v1 + 16), 0))
        abort();
      RAND_bytes_with_additional_data((uint64_t)(v1 + 216), 0x10uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
      return v2;
    }
    else
    {
      if (*(_QWORD *)v1 != -8)
        __memset_chk();
      free(v1);
      return 0;
    }
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
}

uint64_t CRYPTO_BUFFER_hash(uint64_t a1)
{
  return SIPHASH_24((_QWORD *)(*(_QWORD *)a1 + 208), *(uint64_t **)(a1 + 8), *(_QWORD *)(a1 + 16));
}

uint64_t CRYPTO_BUFFER_cmp(uint64_t a1, uint64_t a2)
{
  size_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != *(_QWORD *)(a2 + 16))
    return 1;
  if (v2)
    return memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), v2);
  return 0;
}

char *crypto_buffer_new(const void *a1, size_t a2, int a3, uint64_t *a4)
{
  uint64_t v8;
  char ***v9;
  char **v10;
  char **v11;
  char *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  char v16;
  pthread_rwlock_t *v17;
  char *v18;
  _QWORD *v19;
  pthread_rwlock_t *v20;
  uint64_t v21;
  uint64_t **v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  char v29;
  _QWORD *v30;
  _QWORD *v31;
  uint64_t v32;
  unsigned int v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  size_t v41;
  _QWORD v43[4];

  if (!a4)
    goto LABEL_23;
  v43[2] = a2;
  v43[3] = 0;
  v43[0] = a4;
  v43[1] = a1;
  if (pthread_rwlock_rdlock((pthread_rwlock_t *)(a4 + 1)))
    goto LABEL_82;
  v8 = *a4;
  v9 = (char ***)(*(_QWORD *)(v8 + 8)
                + 8
                * ((unint64_t)(*(unsigned int (**)(_QWORD *))(*a4 + 40))(v43) % *(_QWORD *)(v8 + 16)));
  v10 = *v9;
  if (!*v9)
    goto LABEL_22;
  if ((*(unsigned int (**)(char *, _QWORD *))(v8 + 32))(*v10, v43))
  {
    do
    {
      v11 = v10;
      v10 = (char **)v10[1];
      if (!v10)
        goto LABEL_22;
    }
    while ((*(unsigned int (**)(char *, _QWORD *))(v8 + 32))(*v10, v43));
    v9 = (char ***)(v11 + 1);
  }
  if (!*v9)
    goto LABEL_22;
  v12 = **v9;
  if (!a3 || !v12)
  {
    if (v12)
      goto LABEL_12;
    goto LABEL_22;
  }
  if (!*((_DWORD *)v12 + 7))
  {
LABEL_22:
    if (pthread_rwlock_unlock((pthread_rwlock_t *)(a4 + 1)))
      goto LABEL_82;
LABEL_23:
    v18 = (char *)malloc_type_malloc(0x28uLL, 0x30772F57uLL);
    if (!v18)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return 0;
    }
    v19 = v18;
    *(_QWORD *)v18 = 32;
    *(_OWORD *)(v18 + 8) = 0u;
    v12 = v18 + 8;
    *(_OWORD *)(v18 + 24) = 0u;
    if (a3)
    {
      *((_QWORD *)v18 + 2) = a1;
      *((_QWORD *)v18 + 3) = a2;
      *((_DWORD *)v18 + 8) = 1;
      *((_DWORD *)v18 + 9) = 1;
      if (!a4)
        return v12;
    }
    else if (a2)
    {
      if (a2 > 0xFFFFFFFFFFFFFFF7 || (v30 = malloc_type_malloc(a2 + 8, 0x30772F57uLL)) == 0)
      {
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        if (*v19 != -8)
          __memset_chk();
        free(v19);
        return 0;
      }
      *v30 = a2;
      v31 = v30 + 1;
      memcpy(v30 + 1, a1, a2);
      v19[2] = v31;
      v19[3] = a2;
      *((_DWORD *)v19 + 8) = 1;
      if (!a4)
        return v12;
    }
    else
    {
      *((_QWORD *)v18 + 2) = 0;
      *((_QWORD *)v18 + 3) = 0;
      *((_DWORD *)v18 + 8) = 1;
      if (!a4)
        return v12;
    }
    *(_QWORD *)v12 = a4;
    v20 = (pthread_rwlock_t *)(a4 + 1);
    if (pthread_rwlock_wrlock((pthread_rwlock_t *)(a4 + 1)))
      goto LABEL_82;
    v21 = *a4;
    v22 = (uint64_t **)(*(_QWORD *)(v21 + 8)
                     + 8
                     * ((unint64_t)(*(unsigned int (**)(char *))(*a4 + 40))(v12)
                      % *(_QWORD *)(v21 + 16)));
    v23 = *v22;
    if (*v22)
    {
      if ((*(unsigned int (**)(uint64_t, char *))(v21 + 32))(*v23, v12))
      {
        do
        {
          v24 = v23;
          v23 = (uint64_t *)v23[1];
          if (!v23)
            goto LABEL_59;
        }
        while ((*(unsigned int (**)(uint64_t, char *))(v21 + 32))(*v23, v12));
        v22 = (uint64_t **)(v24 + 1);
      }
      if (*v22)
      {
        v25 = **v22;
        if (a3 && v25)
        {
          if (*(_DWORD *)(v25 + 28))
            goto LABEL_36;
        }
        else if (v25)
        {
LABEL_36:
          v26 = (unsigned int *)(v25 + 24);
          v27 = atomic_load((unsigned int *)(v25 + 24));
          if (v27 != -1)
          {
            while (1)
            {
              v28 = __ldaxr(v26);
              if (v28 == v27)
              {
                if (!__stlxr(v27 + 1, v26))
                {
                  v29 = 1;
                  goto LABEL_42;
                }
              }
              else
              {
                __clrex();
              }
              v29 = 0;
LABEL_42:
              if ((v29 & 1) == 0)
              {
                v27 = v28;
                if (v28 != -1)
                  continue;
              }
              break;
            }
          }
          if (pthread_rwlock_unlock((pthread_rwlock_t *)(a4 + 1)))
            goto LABEL_82;
          if (!*((_DWORD *)v19 + 9))
            goto LABEL_74;
          goto LABEL_78;
        }
      }
    }
LABEL_59:
    v32 = *a4;
    v33 = (*(uint64_t (**)(char *))(v32 + 40))(v12);
    v34 = (_QWORD *)(*(_QWORD *)(v32 + 8) + 8 * ((unint64_t)v33 % *(_QWORD *)(v32 + 16)));
    v35 = (_QWORD *)*v34;
    if (*v34)
    {
      if (!(*(unsigned int (**)(_QWORD, char *))(v32 + 32))(*v35, v12))
        goto LABEL_64;
      do
      {
        v36 = v35;
        v35 = (_QWORD *)v35[1];
        if (!v35)
        {
          v34 = v36 + 1;
          goto LABEL_67;
        }
      }
      while ((*(unsigned int (**)(_QWORD, char *))(v32 + 32))(*v35, v12));
      v34 = v36 + 1;
LABEL_64:
      if (*v34)
      {
        *(_QWORD *)*v34 = v12;
        goto LABEL_69;
      }
    }
LABEL_67:
    v37 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (v37)
    {
      *v37 = 24;
      v37[1] = v12;
      *((_DWORD *)v37 + 6) = v33;
      v37[2] = 0;
      *v34 = v37 + 1;
      ++*(_QWORD *)v32;
      lh_maybe_resize(v32);
LABEL_69:
      v17 = v20;
      goto LABEL_70;
    }
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    if (pthread_rwlock_unlock(v20))
      goto LABEL_82;
    v25 = 0;
    if (!*((_DWORD *)v19 + 9))
    {
LABEL_74:
      v38 = v19[2];
      if (v38)
      {
        v40 = *(_QWORD *)(v38 - 8);
        v39 = (void *)(v38 - 8);
        v41 = v40 + 8;
        if (v40 != -8)
          bzero(v39, v41);
        free(v39);
      }
    }
LABEL_78:
    if (*v19 != -8)
      __memset_chk();
    free(v19);
    return (char *)v25;
  }
LABEL_12:
  v13 = (unsigned int *)(v12 + 24);
  v14 = atomic_load((unsigned int *)v12 + 6);
  if (v14 != -1)
  {
    while (1)
    {
      v15 = __ldaxr(v13);
      if (v15 == v14)
      {
        if (!__stlxr(v14 + 1, v13))
        {
          v16 = 1;
          goto LABEL_18;
        }
      }
      else
      {
        __clrex();
      }
      v16 = 0;
LABEL_18:
      if ((v16 & 1) == 0)
      {
        v14 = v15;
        if (v15 != -1)
          continue;
      }
      break;
    }
  }
  v17 = (pthread_rwlock_t *)(a4 + 1);
LABEL_70:
  if (pthread_rwlock_unlock(v17))
LABEL_82:
    abort();
  return v12;
}

void CRYPTO_BUFFER_free(unsigned int *a1)
{
  uint64_t *v2;
  unsigned int *v3;
  unsigned int j;
  unsigned int v5;
  unsigned int *v6;
  unsigned int i;
  unsigned int v8;
  uint64_t v9;
  void ***v10;
  void **v11;
  void **v12;
  void **v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  size_t v17;
  unsigned int *v18;
  uint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  size_t v28;

  if (!a1)
    return;
  v2 = *(uint64_t **)a1;
  if (!*(_QWORD *)a1)
  {
    v6 = a1 + 6;
    for (i = atomic_load(a1 + 6); ; i = v8)
    {
      if (i == -1)
        return;
      if (!i)
        goto LABEL_52;
      v8 = __ldaxr(v6);
      if (v8 == i)
      {
        if (!__stlxr(i - 1, v6))
        {
          if (i == 1)
            goto LABEL_34;
          return;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  if (pthread_rwlock_wrlock((pthread_rwlock_t *)(v2 + 1)))
    goto LABEL_52;
  v3 = a1 + 6;
  for (j = atomic_load(a1 + 6); ; j = v5)
  {
    if (j == -1)
      goto LABEL_12;
    if (!j)
      goto LABEL_52;
    v5 = __ldaxr(v3);
    if (v5 != j)
    {
      __clrex();
      continue;
    }
    if (!__stlxr(j - 1, v3))
      break;
  }
  if (j != 1)
  {
LABEL_12:
    if (!pthread_rwlock_unlock((pthread_rwlock_t *)(*(_QWORD *)a1 + 8)))
      return;
LABEL_52:
    abort();
  }
  v9 = *v2;
  v10 = (void ***)(*(_QWORD *)(v9 + 8)
                 + 8
                 * ((unint64_t)(*(unsigned int (**)(unsigned int *))(*v2 + 40))(a1)
                  % *(_QWORD *)(v9 + 16)));
  v11 = *v10;
  if (*v10)
  {
    if ((*(unsigned int (**)(void *, unsigned int *))(v9 + 32))(*v11, a1))
    {
      while (1)
      {
        v12 = v11;
        v11 = (void **)v11[1];
        if (!v11)
          goto LABEL_33;
        if (!(*(unsigned int (**)(void *, unsigned int *))(v9 + 32))(*v11, a1))
        {
          v10 = (void ***)(v12 + 1);
          break;
        }
      }
    }
    v13 = *v10;
    if (*v10)
    {
      if (*v13 == a1)
        goto LABEL_43;
      goto LABEL_33;
    }
  }
  else
  {
    v13 = 0;
  }
  if (v13 == (void **)a1)
  {
LABEL_43:
    v21 = *v2;
    v22 = (_QWORD *)(*(_QWORD *)(v21 + 8)
                   + 8
                   * ((unint64_t)(*(unsigned int (**)(unsigned int *))(v21 + 40))(a1)
                    % *(_QWORD *)(v21 + 16)));
    v23 = (_QWORD *)*v22;
    if (*v22)
    {
      if ((*(unsigned int (**)(_QWORD, unsigned int *))(v21 + 32))(*v23, a1))
      {
        while (1)
        {
          v24 = v23;
          v23 = (_QWORD *)v23[1];
          if (!v23)
            break;
          if (!(*(unsigned int (**)(_QWORD, unsigned int *))(v21 + 32))(*v23, a1))
          {
            v22 = v24 + 1;
            goto LABEL_48;
          }
        }
      }
      else
      {
LABEL_48:
        v25 = (_QWORD *)*v22;
        if (*v22)
        {
          v27 = *(v25 - 1);
          v26 = v25 - 1;
          *v22 = v26[2];
          v28 = v27 + 8;
          if (v27 != -8)
            bzero(v26, v28);
          free(v26);
          --*(_QWORD *)v21;
          lh_maybe_resize(v21);
        }
      }
    }
  }
LABEL_33:
  if (pthread_rwlock_unlock((pthread_rwlock_t *)(*(_QWORD *)a1 + 8)))
    goto LABEL_52;
LABEL_34:
  if (!a1[7])
  {
    v14 = *((_QWORD *)a1 + 1);
    if (v14)
    {
      v16 = *(_QWORD *)(v14 - 8);
      v15 = (void *)(v14 - 8);
      v17 = v16 + 8;
      if (v16 != -8)
        bzero(v15, v17);
      free(v15);
    }
  }
  v19 = *((_QWORD *)a1 - 1);
  v18 = a1 - 2;
  v20 = v19 + 8;
  if (v19 != -8)
    bzero(v18, v20);
  free(v18);
}

uint64_t OPENSSL_tm_to_posix(int *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  __int16 v14;
  signed int v15;
  uint64_t v16;
  __int16 v17;
  int v18;
  unsigned int v19;
  unint64_t v20;
  _BOOL4 v22;
  unint64_t v23;

  result = 0;
  v4 = a1[5];
  if ((unint64_t)(v4 + 1900) >> 4 > 0x270)
    return result;
  v5 = a1[4];
  if (v5 < 0)
    return result;
  v6 = a1[3];
  if (v6 < 1)
    return result;
  v7 = v5;
  if ((unint64_t)v5 > 0xB)
    return 0;
  v8 = v6;
  v10 = a1[1];
  v9 = a1[2];
  v11 = *a1;
  if (((1 << v7) & 0xAD5) != 0)
  {
    if (v8 > 0x1F)
      return 0;
    goto LABEL_10;
  }
  if (((1 << v7) & 0x528) == 0)
  {
    HIDWORD(v20) = -1030792151 * (unsigned __int16)(v4 + 1900);
    LODWORD(v20) = HIDWORD(v20);
    v19 = v20 >> 2;
    v22 = (v4 & 3) == 0 && v19 > 0x28F5C28;
    HIDWORD(v23) = -1030792151 * (unsigned __int16)(v4 + 1900);
    LODWORD(v23) = HIDWORD(v23);
    if ((v23 >> 4) >= 0xA3D70B && !v22)
    {
      if (v8 >= 0x1D)
        return 0;
    }
    else if (v8 >= 0x1E)
    {
      return 0;
    }
    goto LABEL_10;
  }
  if (v8 >= 0x1F)
    return 0;
LABEL_10:
  result = 0;
  if ((int)v11 <= 59 && (int)v10 <= 59 && (int)v9 <= 23 && ((v10 | v9 | v11) & 0x8000000000000000) == 0)
  {
    v12 = v7 + 1;
    v13 = (__PAIR128__(v4 + 1900, v12) - 3) >> 64;
    v14 = v13 - 399;
    if (v13 >= 0)
      v14 = v13;
    v15 = ((5243 * v14) >> 21) + ((5243 * v14) >> 31);
    v16 = v13 - 400 * v15;
    if (v12 <= 2)
      v17 = 9;
    else
      v17 = -3;
    v18 = 26215 * (__int16)(153 * (v17 + v12) + 2);
    *a2 = 60 * (int)v10
        + 3600 * (int)v9
        + v11
        + 86400
        * (v8
         + (int)((v18 >> 17) + (v18 >> 31))
         + 146097 * v15
         + 365 * v16
         + ((int)(((_DWORD)v16 + (((__int16)v16 >> 29) & 3)) << 16) >> 18)
         + (int)(((-5243 * (__int16)v16) >> 19) + ((-5243 * (__int16)v16) >> 31))
         - 1)
        - 0xE79256200;
    return 1;
  }
  return result;
}

uint64_t OPENSSL_posix_to_tm(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned __int16 v16;
  int v17;
  int v18;

  if ((unint64_t)(a1 - 0x3AFFF44180) < 0xFFFFFFB686974280)
    return 0;
  v3 = a1 % 86400 + 86400;
  if (a1 % 86400 >= 0)
    v3 = a1 % 86400;
  v4 = a1 / 86400 + ((a1 % 86400) >> 63);
  v5 = v4 + 719468;
  if (v4 <= -719468)
    v6 = v4 + 573372;
  else
    v6 = v4 + 719468;
  v7 = v6 / 146097;
  v8 = v5 - 146097 * v7;
  v9 = ((int)(((unint64_t)(1282606671 * (int)v8) >> 32) - v8) >> 10)
     + ((((unint64_t)(1282606671 * (int)v8) >> 32) - v8) >> 31)
     + v8
     + (int)v8 / 36524
     + ((int)(((unint64_t)(441679365 * (int)v8) >> 32) - v8) >> 17)
     + ((((unint64_t)(441679365 * (int)v8) >> 32) - v8) >> 31);
  v10 = v9 / 365;
  v11 = v8
      + (int)(((int)(((unint64_t)(1282606671 * v9) >> 32) - v9) >> 10)
            + ((((unint64_t)(1282606671 * v9) >> 32) - v9) >> 31))
      + v9 / 36500
      - 365 * (v9 / 365);
  v12 = (5 * (int)v11 + 2) / 153;
  if (v11 >= 306)
    v13 = -9;
  else
    v13 = 3;
  v14 = v12 + v13;
  v15 = v3 / 0xE10;
  v16 = v3 % 0xE10;
  v17 = v11 + (153 * v12 + 2) / -5 + 1;
  *(_DWORD *)a2 = v16 % 0x3Cu;
  *(_DWORD *)(a2 + 4) = v16 / 0x3Cu;
  v18 = v10 + 400 * v7;
  if (v14 < 3)
    ++v18;
  *(_DWORD *)(a2 + 8) = v15;
  *(_DWORD *)(a2 + 12) = v17;
  *(_DWORD *)(a2 + 16) = v14 - 1;
  *(_DWORD *)(a2 + 20) = v18 - 1900;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return 1;
}

uint64_t OPENSSL_gmtime_adj(int *a1, int a2, uint64_t a3)
{
  uint64_t v6;
  BOOL v7;
  uint64_t v9;

  v9 = 0;
  if (!OPENSSL_tm_to_posix(a1, &v9))
    return 0;
  v6 = v9 + 86400 * a2;
  v7 = v6 >= 1 && (v6 ^ 0x7FFFFFFFFFFFFFFFLL) < a3;
  if (v7 || v6 < 0 && (uint64_t)(0x8000000000000000 - v6) > a3)
    return 0;
  else
    return OPENSSL_posix_to_tm(v6 + a3, (uint64_t)a1);
}

BOOL bn_odd_number_is_obviously_composite(uint64_t a1)
{
  unint64_t v2;
  int8x8_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t *v13;
  unint64_t v14;
  int8x16_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;

  if (*(int *)(a1 + 8) <= 16)
    v2 = 512;
  else
    v2 = 1024;
  v3 = (int8x8_t)3;
  if (!bn_mod_u16_consttime(a1, 3u))
  {
LABEL_5:
    v4 = *(unsigned int *)(a1 + 8);
    if (!(_DWORD)v4)
      goto LABEL_19;
    v5 = *(_QWORD **)a1;
    *(_QWORD *)&v3 ^= **(_QWORD **)a1;
    if ((int)v4 < 2)
      goto LABEL_19;
    if (v4 >= 5)
    {
      v10 = (v4 - 1) & 0xFFFFFFFFFFFFFFFCLL;
      v6 = v10 | 1;
      v11 = 0uLL;
      v12 = (int8x16_t)(unint64_t)v3;
      v13 = (int8x16_t *)(v5 + 3);
      v14 = v10;
      do
      {
        v12 = vorrq_s8(v13[-1], v12);
        v11 = vorrq_s8(*v13, v11);
        v13 += 2;
        v14 -= 4;
      }
      while (v14);
      v15 = vorrq_s8(v11, v12);
      v3 = vorr_s8(*(int8x8_t *)v15.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
      if (v4 - 1 == v10)
        goto LABEL_19;
    }
    else
    {
      v6 = 1;
    }
    v16 = v4 - v6;
    v17 = &v5[v6];
    do
    {
      v18 = *v17++;
      *(_QWORD *)&v3 |= v18;
      --v16;
    }
    while (v16);
LABEL_19:
    if (v3)
      return 1;
    else
      return *(_DWORD *)(a1 + 16) != 0;
  }
  v7 = 2;
  while (v2 != v7)
  {
    v3 = (int8x8_t)kPrimes[v7];
    if (bn_mod_u16_consttime(a1, kPrimes[v7++]) == 0)
    {
      if (v7 - 1 < v2)
        goto LABEL_5;
      return 0;
    }
  }
  return 0;
}

uint64_t bn_miller_rabin_iteration(uint64_t a1, _DWORD *a2, const BIGNUM *a3, uint64_t a4, BN_CTX *ctx)
{
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v14;
  uint64_t result;
  BIGNUM *v16;
  uint64_t v17;
  uint64_t top;
  uint64_t v19;
  int8x16_t *v20;
  uint64_t v21;
  int8x8_t v22;
  uint64_t v23;
  int8x16_t *v24;
  int8x16_t v25;
  unint64_t v26;
  int8x16_t v27;
  int8x16_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  unint64_t *d;
  uint64_t v33;
  uint64_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t *v37;
  unint64_t v38;
  int8x16_t v39;
  uint64_t v40;
  unint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  int8x16_t *v44;
  int8x16_t *v45;
  uint64_t v46;
  int8x16_t v47;
  int8x16_t v48;
  int8x16_t *v49;
  int8x16_t *v50;
  uint64_t v51;
  int8x16_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int neg;
  int v61;
  uint64_t v62;
  uint64_t v63;
  int8x16_t *v64;
  uint64_t v65;
  int8x8_t v66;
  uint64_t v67;
  int8x16_t *v68;
  int8x16_t v69;
  unint64_t v70;
  int8x16_t v71;
  int8x16_t v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t v75;
  unint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t *v81;
  unint64_t v82;
  int8x16_t v83;
  uint64_t v84;
  unint64_t *v85;
  uint64_t v86;
  uint64_t v87;
  int8x16_t *v88;
  int8x16_t *v89;
  uint64_t v90;
  int8x16_t v91;
  int8x16_t v92;
  int8x16_t *v93;
  int8x16_t *v94;
  uint64_t v95;
  int8x16_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  BOOL v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  int8x16_t *v112;
  uint64_t v113;
  int8x8_t v114;
  uint64_t v115;
  int8x16_t *v116;
  int8x16_t v117;
  unint64_t v118;
  int8x16_t v119;
  int8x16_t v120;
  uint64_t v121;
  uint64_t *v122;
  uint64_t v123;
  unint64_t *v124;
  uint64_t v125;
  uint64_t v126;
  int8x16_t v127;
  int8x16_t v128;
  int8x16_t *v129;
  unint64_t v130;
  int8x16_t v131;
  uint64_t v132;
  unint64_t *v133;
  uint64_t v134;
  uint64_t v135;
  int8x16_t *v136;
  int8x16_t *v137;
  uint64_t v138;
  int8x16_t v139;
  int8x16_t v140;
  int8x16_t *v141;
  int8x16_t *v142;
  uint64_t v143;
  int8x16_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t *v147;
  uint64_t *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  int v152;
  uint64_t v153;
  uint64_t v154;
  int8x16_t *v155;
  uint64_t v156;
  int8x8_t v157;
  uint64_t v158;
  int8x16_t *v159;
  int8x16_t v160;
  unint64_t v161;
  int8x16_t v162;
  int8x16_t v163;
  uint64_t v164;
  uint64_t *v165;
  uint64_t v166;
  unint64_t *v167;
  uint64_t v168;
  uint64_t v169;
  int8x16_t v170;
  int8x16_t v171;
  int8x16_t *v172;
  unint64_t v173;
  int8x16_t v174;
  uint64_t v175;
  unint64_t *v176;
  uint64_t v177;
  int8x16_t *v178;
  int8x16_t *v179;
  uint64_t v180;
  int8x16_t v181;
  int8x16_t v182;
  int8x16_t *v183;
  int8x16_t *v184;
  uint64_t v185;
  int8x16_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t *v189;
  uint64_t *v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;

  if (*((_BYTE *)ctx + 40))
  {
LABEL_15:
    result = (uint64_t)BN_CTX_get(ctx);
    if (!result)
      goto LABEL_150;
    goto LABEL_16;
  }
  v10 = *((_QWORD *)ctx + 4);
  v11 = *((_QWORD *)ctx + 2);
  if (v11 != *((_QWORD *)ctx + 3))
  {
    v14 = (_QWORD *)*((_QWORD *)ctx + 1);
    goto LABEL_14;
  }
  if (v11)
    v12 = (3 * v11) >> 1;
  else
    v12 = 32;
  if (v12 > v11 && v12 >> 61 == 0)
  {
    v14 = OPENSSL_realloc(*((_QWORD **)ctx + 1), 8 * v12);
    if (v14)
    {
      *((_QWORD *)ctx + 1) = v14;
      *((_QWORD *)ctx + 3) = v12;
      v11 = *((_QWORD *)ctx + 2);
LABEL_14:
      v14[v11] = v10;
      ++*((_QWORD *)ctx + 2);
      goto LABEL_15;
    }
  }
  *((_WORD *)ctx + 20) = 257;
  result = (uint64_t)BN_CTX_get(ctx);
  if (!result)
    goto LABEL_150;
LABEL_16:
  v16 = (BIGNUM *)result;
  result = BN_mod_exp_mont_consttime((BIGNUM *)result, a3, *(const BIGNUM **)(a1 + 8), (const BIGNUM *)(a4 + 24), ctx, (BN_MONT_CTX *)a4);
  if (!(_DWORD)result)
    goto LABEL_150;
  result = BN_mod_mul_montgomery(v16, v16, (const BIGNUM *)a4, (BN_MONT_CTX *)a4, ctx);
  if (!(_DWORD)result)
    goto LABEL_150;
  v17 = *(_QWORD *)(a1 + 16);
  top = v16->top;
  v19 = *(int *)(v17 + 8);
  if ((int)top >= (int)v19)
  {
    v22 = 0;
    goto LABEL_29;
  }
  v20 = *(int8x16_t **)v17;
  v21 = v19 - top;
  if ((unint64_t)(v19 - top) < 4)
  {
    v22 = 0;
    v23 = v16->top;
LABEL_27:
    v29 = v19 - v23;
    v30 = &v20->i64[v23];
    do
    {
      v31 = *v30++;
      *(_QWORD *)&v22 |= v31;
      --v29;
    }
    while (v29);
    goto LABEL_29;
  }
  v23 = (v21 & 0xFFFFFFFFFFFFFFFCLL) + top;
  v24 = (int8x16_t *)((char *)v20 + 8 * top + 16);
  v25 = 0uLL;
  v26 = v21 & 0xFFFFFFFFFFFFFFFCLL;
  v27 = 0uLL;
  do
  {
    v25 = vorrq_s8(v24[-1], v25);
    v27 = vorrq_s8(*v24, v27);
    v24 += 2;
    v26 -= 4;
  }
  while (v26);
  v28 = vorrq_s8(v27, v25);
  v22 = vorr_s8(*(int8x8_t *)v28.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
  if (v21 != (v21 & 0xFFFFFFFFFFFFFFFCLL))
    goto LABEL_27;
LABEL_29:
  if ((int)v19 < (int)top)
  {
    d = v16->d;
    v33 = top - v19;
    if ((unint64_t)(top - v19) >= 4)
    {
      v34 = (v33 & 0xFFFFFFFFFFFFFFFCLL) + v19;
      v35 = 0uLL;
      v36 = (int8x16_t)(unint64_t)v22;
      v37 = (int8x16_t *)&d[v19 + 2];
      v38 = v33 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v36 = vorrq_s8(v37[-1], v36);
        v35 = vorrq_s8(*v37, v35);
        v37 += 2;
        v38 -= 4;
      }
      while (v38);
      v39 = vorrq_s8(v35, v36);
      v22 = vorr_s8(*(int8x8_t *)v39.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL));
      if (v33 == (v33 & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_37;
    }
    else
    {
      v34 = *(int *)(v17 + 8);
    }
    v40 = top - v34;
    v41 = &d[v34];
    do
    {
      v42 = *v41++;
      *(_QWORD *)&v22 |= v42;
      --v40;
    }
    while (v40);
  }
LABEL_37:
  if ((int)top >= (int)v19)
    v43 = v19;
  else
    v43 = top;
  if ((int)v43 >= 1)
  {
    v44 = (int8x16_t *)v16->d;
    v45 = *(int8x16_t **)v17;
    if (v43 < 4)
    {
      v46 = 0;
LABEL_46:
      v53 = v43 - v46;
      v54 = v46;
      v55 = &v45->i64[v54];
      v56 = &v44->i64[v54];
      do
      {
        v58 = *v56++;
        v57 = v58;
        v59 = *v55++;
        *(_QWORD *)&v22 |= v59 ^ v57;
        --v53;
      }
      while (v53);
      goto LABEL_48;
    }
    v46 = v43 & 0x7FFFFFFC;
    v47 = 0uLL;
    v48 = (int8x16_t)(unint64_t)v22;
    v49 = v44 + 1;
    v50 = v45 + 1;
    v51 = v43 & 0xFFFFFFFC;
    do
    {
      v48 = vorrq_s8(veorq_s8(v50[-1], v49[-1]), v48);
      v47 = vorrq_s8(veorq_s8(*v50, *v49), v47);
      v49 += 2;
      v50 += 2;
      v51 -= 4;
    }
    while (v51);
    v52 = vorrq_s8(v47, v48);
    v22 = vorr_s8(*(int8x8_t *)v52.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL));
    if (v46 != v43)
      goto LABEL_46;
  }
LABEL_48:
  neg = v16->neg;
  v61 = *(_DWORD *)(v17 + 16) ^ neg;
  v62 = *(_QWORD *)(a1 + 24);
  v63 = *(int *)(v62 + 8);
  if ((int)top >= (int)v63)
  {
    v66 = 0;
    goto LABEL_57;
  }
  v64 = *(int8x16_t **)v62;
  v65 = v63 - top;
  if ((unint64_t)(v63 - top) < 4)
  {
    v66 = 0;
    v67 = v16->top;
LABEL_55:
    v73 = v63 - v67;
    v74 = &v64->i64[v67];
    do
    {
      v75 = *v74++;
      *(_QWORD *)&v66 |= v75;
      --v73;
    }
    while (v73);
    goto LABEL_57;
  }
  v67 = (v65 & 0xFFFFFFFFFFFFFFFCLL) + top;
  v68 = (int8x16_t *)((char *)v64 + 8 * top + 16);
  v69 = 0uLL;
  v70 = v65 & 0xFFFFFFFFFFFFFFFCLL;
  v71 = 0uLL;
  do
  {
    v69 = vorrq_s8(v68[-1], v69);
    v71 = vorrq_s8(*v68, v71);
    v68 += 2;
    v70 -= 4;
  }
  while (v70);
  v72 = vorrq_s8(v71, v69);
  v66 = vorr_s8(*(int8x8_t *)v72.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v72, v72, 8uLL));
  if (v65 != (v65 & 0xFFFFFFFFFFFFFFFCLL))
    goto LABEL_55;
LABEL_57:
  if ((int)v63 < (int)top)
  {
    v76 = v16->d;
    v77 = top - v63;
    if ((unint64_t)(top - v63) >= 4)
    {
      v78 = (v77 & 0xFFFFFFFFFFFFFFFCLL) + v63;
      v79 = 0uLL;
      v80 = (int8x16_t)(unint64_t)v66;
      v81 = (int8x16_t *)&v76[v63 + 2];
      v82 = v77 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v80 = vorrq_s8(v81[-1], v80);
        v79 = vorrq_s8(*v81, v79);
        v81 += 2;
        v82 -= 4;
      }
      while (v82);
      v83 = vorrq_s8(v79, v80);
      v66 = vorr_s8(*(int8x8_t *)v83.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v83, v83, 8uLL));
      if (v77 == (v77 & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_65;
    }
    else
    {
      v78 = *(int *)(v62 + 8);
    }
    v84 = top - v78;
    v85 = &v76[v78];
    do
    {
      v86 = *v85++;
      *(_QWORD *)&v66 |= v86;
      --v84;
    }
    while (v84);
  }
LABEL_65:
  v87 = *(_QWORD *)&v22 | v61;
  if ((int)top >= (int)v63)
    v63 = v63;
  else
    v63 = top;
  if ((int)v63 < 1)
    goto LABEL_76;
  v88 = (int8x16_t *)v16->d;
  v89 = *(int8x16_t **)v62;
  if (v63 < 4)
  {
    v90 = 0;
LABEL_74:
    v97 = v63 - v90;
    v98 = v90;
    v99 = &v89->i64[v98];
    v100 = &v88->i64[v98];
    do
    {
      v102 = *v100++;
      v101 = v102;
      v103 = *v99++;
      *(_QWORD *)&v66 |= v103 ^ v101;
      --v97;
    }
    while (v97);
    goto LABEL_76;
  }
  v90 = v63 & 0x7FFFFFFC;
  v91 = 0uLL;
  v92 = (int8x16_t)(unint64_t)v66;
  v93 = v88 + 1;
  v94 = v89 + 1;
  v95 = v63 & 0xFFFFFFFC;
  do
  {
    v92 = vorrq_s8(veorq_s8(v94[-1], v93[-1]), v92);
    v91 = vorrq_s8(veorq_s8(*v94, *v93), v91);
    v93 += 2;
    v94 += 2;
    v95 -= 4;
  }
  while (v95);
  v96 = vorrq_s8(v91, v92);
  v66 = vorr_s8(*(int8x8_t *)v96.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v96, v96, 8uLL));
  if (v90 != v63)
    goto LABEL_74;
LABEL_76:
  if (v87)
    v104 = (*(_QWORD *)&v66 | *(_DWORD *)(v62 + 16) ^ neg) == 0;
  else
    v104 = 1;
  v105 = v104;
  v106 = v105 << 63 >> 63;
  if (*(int *)(a1 + 32) > 1)
  {
    v107 = 1;
    while (1)
    {
      if (*(_DWORD *)(a1 + 36) == v107)
        v108 = ~v106;
      else
        v108 = 0;
      if (v108)
        goto LABEL_149;
      result = BN_mod_mul_montgomery(v16, v16, v16, (BN_MONT_CTX *)a4, ctx);
      if (!(_DWORD)result)
        goto LABEL_150;
      v109 = *(_QWORD *)(a1 + 24);
      v110 = v16->top;
      v111 = *(int *)(v109 + 8);
      if ((int)v110 >= (int)v111)
      {
        v114 = 0;
        goto LABEL_98;
      }
      v112 = *(int8x16_t **)v109;
      v113 = v111 - v110;
      if ((unint64_t)(v111 - v110) < 4)
        break;
      v115 = (v113 & 0xFFFFFFFFFFFFFFFCLL) + v110;
      v116 = (int8x16_t *)((char *)v112 + 8 * v110 + 16);
      v117 = 0uLL;
      v118 = v113 & 0xFFFFFFFFFFFFFFFCLL;
      v119 = 0uLL;
      do
      {
        v117 = vorrq_s8(v116[-1], v117);
        v119 = vorrq_s8(*v116, v119);
        v116 += 2;
        v118 -= 4;
      }
      while (v118);
      v120 = vorrq_s8(v119, v117);
      v114 = vorr_s8(*(int8x8_t *)v120.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v120, v120, 8uLL));
      if (v113 != (v113 & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_96;
LABEL_98:
      if ((int)v111 < (int)v110)
      {
        v124 = v16->d;
        v125 = v110 - v111;
        if ((unint64_t)(v110 - v111) >= 4)
        {
          v126 = (v125 & 0xFFFFFFFFFFFFFFFCLL) + v111;
          v127 = 0uLL;
          v128 = (int8x16_t)(unint64_t)v114;
          v129 = (int8x16_t *)&v124[v111 + 2];
          v130 = v125 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            v128 = vorrq_s8(v129[-1], v128);
            v127 = vorrq_s8(*v129, v127);
            v129 += 2;
            v130 -= 4;
          }
          while (v130);
          v131 = vorrq_s8(v127, v128);
          v114 = vorr_s8(*(int8x8_t *)v131.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v131, v131, 8uLL));
          if (v125 == (v125 & 0xFFFFFFFFFFFFFFFCLL))
            goto LABEL_106;
        }
        else
        {
          v126 = *(int *)(v109 + 8);
        }
        v132 = v110 - v126;
        v133 = &v124[v126];
        do
        {
          v134 = *v133++;
          *(_QWORD *)&v114 |= v134;
          --v132;
        }
        while (v132);
      }
LABEL_106:
      if ((int)v110 >= (int)v111)
        v135 = v111;
      else
        v135 = v110;
      if ((int)v135 >= 1)
      {
        v136 = (int8x16_t *)v16->d;
        v137 = *(int8x16_t **)v109;
        if (v135 < 4)
        {
          v138 = 0;
LABEL_115:
          v145 = v135 - v138;
          v146 = v138;
          v147 = &v137->i64[v146];
          v148 = &v136->i64[v146];
          do
          {
            v150 = *v148++;
            v149 = v150;
            v151 = *v147++;
            *(_QWORD *)&v114 |= v151 ^ v149;
            --v145;
          }
          while (v145);
          goto LABEL_117;
        }
        v138 = v135 & 0x7FFFFFFC;
        v139 = 0uLL;
        v140 = (int8x16_t)(unint64_t)v114;
        v141 = v136 + 1;
        v142 = v137 + 1;
        v143 = v135 & 0xFFFFFFFC;
        do
        {
          v140 = vorrq_s8(veorq_s8(v142[-1], v141[-1]), v140);
          v139 = vorrq_s8(veorq_s8(*v142, *v141), v139);
          v141 += 2;
          v142 += 2;
          v143 -= 4;
        }
        while (v143);
        v144 = vorrq_s8(v139, v140);
        v114 = vorr_s8(*(int8x8_t *)v144.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v144, v144, 8uLL));
        if (v138 != v135)
          goto LABEL_115;
      }
LABEL_117:
      v152 = v16->neg;
      if (!(*(_QWORD *)&v114 | *(_DWORD *)(v109 + 16) ^ v152))
        v106 = -1;
      v153 = *(_QWORD *)(a1 + 16);
      v154 = *(int *)(v153 + 8);
      if ((int)v110 >= (int)v154)
      {
        v157 = 0;
        goto LABEL_128;
      }
      v155 = *(int8x16_t **)v153;
      v156 = v154 - v110;
      if ((unint64_t)(v154 - v110) < 4)
      {
        v157 = 0;
        v158 = v16->top;
LABEL_126:
        v164 = v154 - v158;
        v165 = &v155->i64[v158];
        do
        {
          v166 = *v165++;
          *(_QWORD *)&v157 |= v166;
          --v164;
        }
        while (v164);
        goto LABEL_128;
      }
      v158 = (v156 & 0xFFFFFFFFFFFFFFFCLL) + v110;
      v159 = (int8x16_t *)((char *)v155 + 8 * v110 + 16);
      v160 = 0uLL;
      v161 = v156 & 0xFFFFFFFFFFFFFFFCLL;
      v162 = 0uLL;
      do
      {
        v160 = vorrq_s8(v159[-1], v160);
        v162 = vorrq_s8(*v159, v162);
        v159 += 2;
        v161 -= 4;
      }
      while (v161);
      v163 = vorrq_s8(v162, v160);
      v157 = vorr_s8(*(int8x8_t *)v163.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v163, v163, 8uLL));
      if (v156 != (v156 & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_126;
LABEL_128:
      if ((int)v154 < (int)v110)
      {
        v167 = v16->d;
        v168 = v110 - v154;
        if ((unint64_t)(v110 - v154) >= 4)
        {
          v169 = (v168 & 0xFFFFFFFFFFFFFFFCLL) + v154;
          v170 = 0uLL;
          v171 = (int8x16_t)(unint64_t)v157;
          v172 = (int8x16_t *)&v167[v154 + 2];
          v173 = v168 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            v171 = vorrq_s8(v172[-1], v171);
            v170 = vorrq_s8(*v172, v170);
            v172 += 2;
            v173 -= 4;
          }
          while (v173);
          v174 = vorrq_s8(v170, v171);
          v157 = vorr_s8(*(int8x8_t *)v174.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v174, v174, 8uLL));
          if (v168 == (v168 & 0xFFFFFFFFFFFFFFFCLL))
            goto LABEL_136;
        }
        else
        {
          v169 = *(int *)(v153 + 8);
        }
        v175 = v110 - v169;
        v176 = &v167[v169];
        do
        {
          v177 = *v176++;
          *(_QWORD *)&v157 |= v177;
          --v175;
        }
        while (v175);
      }
LABEL_136:
      if ((int)v110 >= (int)v154)
        v154 = v154;
      else
        v154 = v110;
      if ((int)v154 < 1)
        goto LABEL_147;
      v178 = (int8x16_t *)v16->d;
      v179 = *(int8x16_t **)v153;
      if (v154 >= 4)
      {
        v180 = v154 & 0x7FFFFFFC;
        v181 = 0uLL;
        v182 = (int8x16_t)(unint64_t)v157;
        v183 = v178 + 1;
        v184 = v179 + 1;
        v185 = v154 & 0xFFFFFFFC;
        do
        {
          v182 = vorrq_s8(veorq_s8(v184[-1], v183[-1]), v182);
          v181 = vorrq_s8(veorq_s8(*v184, *v183), v181);
          v183 += 2;
          v184 += 2;
          v185 -= 4;
        }
        while (v185);
        v186 = vorrq_s8(v181, v182);
        v157 = vorr_s8(*(int8x8_t *)v186.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v186, v186, 8uLL));
        if (v180 == v154)
          goto LABEL_147;
      }
      else
      {
        v180 = 0;
      }
      v187 = v154 - v180;
      v188 = v180;
      v189 = &v179->i64[v188];
      v190 = &v178->i64[v188];
      do
      {
        v192 = *v190++;
        v191 = v192;
        v193 = *v189++;
        *(_QWORD *)&v157 |= v193 ^ v191;
        --v187;
      }
      while (v187);
LABEL_147:
      if ((((*(_QWORD *)&v157 | *(_DWORD *)(v153 + 16) ^ v152) == 0) & (unint64_t)~v106) == 0
        && ++v107 < *(_DWORD *)(a1 + 32))
      {
        continue;
      }
      goto LABEL_149;
    }
    v114 = 0;
    v115 = v16->top;
LABEL_96:
    v121 = v111 - v115;
    v122 = &v112->i64[v115];
    do
    {
      v123 = *v122++;
      *(_QWORD *)&v114 |= v123;
      --v121;
    }
    while (v121);
    goto LABEL_98;
  }
LABEL_149:
  *a2 = v106 & 1;
  result = 1;
LABEL_150:
  if (!*((_BYTE *)ctx + 40))
  {
    v194 = *((_QWORD *)ctx + 1);
    v195 = *((_QWORD *)ctx + 2) - 1;
    *((_QWORD *)ctx + 2) = v195;
    *((_QWORD *)ctx + 4) = *(_QWORD *)(v194 + 8 * v195);
  }
  return result;
}

uint64_t BN_primality_test(_DWORD *a1, uint64_t **a2, int a3, char *a4, int a5, uint64_t a6)
{
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t *v25;
  unint64_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  unint64_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t *v34;
  unint64_t v35;
  int8x16_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  unint64_t v40;
  unsigned int v41;
  int8x8_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  BOOL v51;
  uint64_t *v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  BOOL v58;
  _QWORD *v59;
  uint64_t v60;
  unint64_t v61;
  int8x16_t v62;
  unsigned __int128 v63;
  int8x16_t *v64;
  unint64_t v65;
  int8x16_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  BIGNUM *v71;
  BIGNUM *v72;
  uint64_t v73;
  BIGNUM *v74;
  BIGNUM *v75;
  BIGNUM *v76;
  uint64_t v77;
  uint64_t *v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  unint64_t v86;
  _BOOL4 v87;
  _BOOL4 v88;
  _BOOL4 v89;
  _BOOL4 v90;
  _BOOL4 v91;
  _BOOL4 v92;
  int v93;
  int v94;
  int v95;
  unint64_t v96;
  _BOOL4 v97;
  _BOOL4 v98;
  _BOOL4 v99;
  _BOOL4 v100;
  _BOOL4 v101;
  _BOOL4 v102;
  uint64_t v103;
  unsigned int v104;
  uint64_t v105;
  BOOL v106;
  uint64_t v107;
  unsigned int v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  BIGNUM *v114;
  BN_CTX *c;
  int v116;
  int v117;
  uint64_t v118[4];
  int v119;
  unsigned int v120;

  *a1 = 0;
  if (pthread_once(&BN_value_one_once, (void (*)(void))BN_value_one_init))
    goto LABEL_173;
  if (a2)
  {
    v12 = *((_DWORD *)a2 + 4);
    if (v12 == dword_253EA7940)
    {
      v13 = bn_cmp_words_consttime(*a2, *((int *)a2 + 2), (uint64_t *)BN_value_one_storage, dword_253EA7938);
      if (v12)
        v14 = -v13;
      else
        v14 = v13;
      if (v14 < 1)
        return 1;
    }
    else if (v12)
    {
      return 1;
    }
  }
  v15 = *((unsigned int *)a2 + 2);
  if ((int)v15 < 1)
  {
    if (!(_DWORD)v15)
    {
LABEL_83:
      *a1 = v15;
      return 1;
    }
    v18 = **a2 ^ 2;
    goto LABEL_25;
  }
  v16 = *a2;
  v17 = **a2;
  if ((v17 & 1) == 0)
  {
    v18 = v17 ^ 2;
    if ((_DWORD)v15 == 1)
      goto LABEL_25;
    if (v15 < 5)
    {
      v19 = 1;
LABEL_23:
      v28 = v15 - v19;
      v29 = &v16[v19];
      do
      {
        v30 = *v29++;
        v18 |= v30;
        --v28;
      }
      while (v28);
      goto LABEL_25;
    }
    v22 = (v15 - 1) & 0xFFFFFFFFFFFFFFFCLL;
    v19 = v22 | 1;
    v23 = 0uLL;
    v24 = (int8x16_t)(unint64_t)v18;
    v25 = (int8x16_t *)(v16 + 3);
    v26 = v22;
    do
    {
      v24 = vorrq_s8(v25[-1], v24);
      v23 = vorrq_s8(*v25, v23);
      v25 += 2;
      v26 -= 4;
    }
    while (v26);
    v27 = vorrq_s8(v23, v24);
    v18 = (uint64_t)vorr_s8(*(int8x8_t *)v27.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL));
    if (v15 - 1 != v22)
      goto LABEL_23;
LABEL_25:
    if (v18)
    {
LABEL_26:
      LODWORD(v15) = 0;
      goto LABEL_83;
    }
LABEL_82:
    LODWORD(v15) = *((_DWORD *)a2 + 4) == 0;
    goto LABEL_83;
  }
  v20 = v17 ^ 3;
  if ((_DWORD)v15 != 1)
  {
    if (v15 < 5)
    {
      v21 = 1;
LABEL_30:
      v37 = v15 - v21;
      v38 = &v16[v21];
      do
      {
        v39 = *v38++;
        v20 |= v39;
        --v37;
      }
      while (v37);
      goto LABEL_32;
    }
    v31 = (v15 - 1) & 0xFFFFFFFFFFFFFFFCLL;
    v21 = v31 | 1;
    v32 = 0uLL;
    v33 = (int8x16_t)(unint64_t)v20;
    v34 = (int8x16_t *)(v16 + 3);
    v35 = v31;
    do
    {
      v33 = vorrq_s8(v34[-1], v33);
      v32 = vorrq_s8(*v34, v32);
      v34 += 2;
      v35 -= 4;
    }
    while (v35);
    v36 = vorrq_s8(v32, v33);
    v20 = (uint64_t)vorr_s8(*(int8x8_t *)v36.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL));
    if (v15 - 1 != v31)
      goto LABEL_30;
  }
LABEL_32:
  if (!v20 && !*((_DWORD *)a2 + 4))
  {
    v60 = 1;
    *a1 = 1;
    return v60;
  }
  if (a5)
  {
    if ((int)v15 <= 16)
      v40 = 512;
    else
      v40 = 1024;
    v41 = 3;
    if (bn_mod_u16_consttime((uint64_t)a2, 3u))
    {
      v46 = 2;
      do
      {
        if (v40 == v46)
          goto LABEL_47;
        v41 = kPrimes[v46++];
      }
      while (bn_mod_u16_consttime((uint64_t)a2, v41));
      if (v46 - 1 >= v40)
      {
LABEL_47:
        if (a6 && !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a6 + 8))(1, 0xFFFFFFFFLL, a6))
          return 0;
        goto LABEL_49;
      }
    }
    v42 = (int8x8_t)v41;
    v43 = *((unsigned int *)a2 + 2);
    if ((_DWORD)v43)
    {
      v44 = *a2;
      v42 = (int8x8_t)(**a2 ^ v41);
      if ((int)v43 >= 2)
      {
        if (v43 < 5)
        {
          v45 = 1;
LABEL_79:
          v67 = v43 - v45;
          v68 = &v44[v45];
          do
          {
            v69 = *v68++;
            *(_QWORD *)&v42 |= v69;
            --v67;
          }
          while (v67);
          goto LABEL_81;
        }
        v61 = (v43 - 1) & 0xFFFFFFFFFFFFFFFCLL;
        v45 = v61 | 1;
        v62 = 0uLL;
        v63 = (unint64_t)**a2 ^ (unsigned __int128)v41;
        v64 = (int8x16_t *)(v44 + 3);
        v65 = v61;
        do
        {
          v63 = (unsigned __int128)vorrq_s8(v64[-1], (int8x16_t)v63);
          v62 = vorrq_s8(*v64, v62);
          v64 += 2;
          v65 -= 4;
        }
        while (v65);
        v66 = vorrq_s8(v62, (int8x16_t)v63);
        v42 = vorr_s8(*(int8x8_t *)v66.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v66, v66, 8uLL));
        if (v43 - 1 != v61)
          goto LABEL_79;
      }
    }
LABEL_81:
    if (v42)
      goto LABEL_26;
    goto LABEL_82;
  }
LABEL_49:
  if (!a3)
  {
    v47 = *((unsigned int *)a2 + 2);
    v48 = v47 & ((int)v47 >> 31);
    v49 = 8 * v47 - 8;
    v50 = *((_DWORD *)a2 + 2);
    while (1)
    {
      v51 = __OFSUB__(v50--, 1);
      if (v50 < 0 != v51)
        break;
      v52 = *a2;
      v53 = *(uint64_t *)((char *)*a2 + v49);
      v49 -= 8;
      if (v53)
      {
        v48 = v50 + 1;
        goto LABEL_102;
      }
    }
    if ((v47 & 0x80000000) == 0)
    {
      a3 = 34;
      goto LABEL_50;
    }
    v52 = *a2;
LABEL_102:
    v85 = v48 - 1;
    v86 = v52[v85];
    v87 = v86 != 0;
    v88 = HIDWORD(v86) != 0;
    if (HIDWORD(v86))
      v86 >>= 32;
    v89 = v86 >> 16 != 0;
    if (v86 >> 16)
      v86 >>= 16;
    v90 = v86 > 0xFF;
    if (v86 > 0xFF)
      v86 >>= 8;
    v91 = v86 > 0xF;
    if (v86 > 0xF)
      v86 >>= 4;
    v92 = v86 > 3;
    if (v86 > 3)
      v86 >>= 2;
    v93 = v87 | (v85 << 6) | (32 * v88) | (16 * v89) | (8 * v90) | (4 * v91) | (2 * v92);
    if (v86 > 1)
      ++v93;
    if (v93 <= 3746)
    {
      if (v93 <= 1344)
      {
        if (v93 <= 475)
        {
          if (v93 <= 399)
          {
            if (v93 <= 346)
            {
              if (v93 <= 307)
              {
                if (v93 <= 54)
                  a3 = 34;
                else
                  a3 = 27;
              }
              else
              {
                a3 = 8;
              }
            }
            else
            {
              a3 = 7;
            }
          }
          else
          {
            a3 = 6;
          }
        }
        else
        {
          a3 = 5;
        }
      }
      else
      {
        a3 = 4;
      }
    }
    else
    {
      a3 = 3;
    }
  }
LABEL_50:
  if (a4)
  {
    c = 0;
    if (a4[40])
      goto LABEL_87;
  }
  else
  {
    v54 = (char *)malloc_type_malloc(0x38uLL, 0x30772F57uLL);
    if (!v54)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return 0;
    }
    *(_QWORD *)v54 = 48;
    *(_OWORD *)(v54 + 8) = 0u;
    a4 = v54 + 8;
    *(_OWORD *)(v54 + 24) = 0u;
    *(_OWORD *)(v54 + 34) = 0u;
    c = (BN_CTX *)(v54 + 8);
    if (v54[48])
      goto LABEL_87;
  }
  v55 = *((_QWORD *)a4 + 4);
  v56 = *((_QWORD *)a4 + 2);
  if (v56 == *((_QWORD *)a4 + 3))
  {
    if (v56)
      v57 = (3 * v56) >> 1;
    else
      v57 = 32;
    v58 = v57 > v56 && v57 >> 61 == 0;
    if (!v58 || (v59 = OPENSSL_realloc(*((_QWORD **)a4 + 1), 8 * v57)) == 0)
    {
      *((_WORD *)a4 + 20) = 257;
      goto LABEL_87;
    }
    *((_QWORD *)a4 + 1) = v59;
    *((_QWORD *)a4 + 3) = v57;
    v56 = *((_QWORD *)a4 + 2);
  }
  else
  {
    v59 = (_QWORD *)*((_QWORD *)a4 + 1);
  }
  v59[v56] = v55;
  ++*((_QWORD *)a4 + 2);
LABEL_87:
  v71 = BN_CTX_get((BN_CTX *)a4);
  v72 = BN_MONT_CTX_new_consttime((uint64_t)a2, (BN_CTX *)a4);
  v73 = (uint64_t)v72;
  v60 = 0;
  if (v71)
  {
    v114 = v71;
    if (v72)
    {
      v118[0] = (uint64_t)BN_CTX_get((BN_CTX *)a4);
      v74 = BN_CTX_get((BN_CTX *)a4);
      v118[1] = (uint64_t)v74;
      v75 = BN_CTX_get((BN_CTX *)a4);
      v118[2] = (uint64_t)v75;
      v76 = BN_CTX_get((BN_CTX *)a4);
      v60 = 0;
      v118[3] = (uint64_t)v76;
      v113 = v118[0];
      if (v118[0])
      {
        if (v74)
        {
          v60 = 0;
          if (v75)
          {
            v77 = (uint64_t)v76;
            if (v76)
            {
              if (!pthread_once(&BN_value_one_once, (void (*)(void))BN_value_one_init))
              {
                v78 = (uint64_t *)(v73 + 24);
                if (bn_usub_consttime(v118[0], v73 + 24, (uint64_t)&BN_value_one_storage))
                {
                  v120 = BN_count_low_zero_bits(v118[0]);
                  if (bn_rshift_secret_shift((uint64_t)v74, v118[0], v120, (BN_CTX *)a4))
                  {
                    v79 = *(unsigned int *)(v73 + 32);
                    v80 = v79 & ((int)v79 >> 31);
                    v81 = 8 * v79 - 8;
                    v82 = *(_DWORD *)(v73 + 32);
                    while (1)
                    {
                      v51 = __OFSUB__(v82--, 1);
                      if (v82 < 0 != v51)
                        break;
                      v83 = *v78;
                      v84 = *(_QWORD *)(*v78 + v81);
                      v81 -= 8;
                      if (v84)
                      {
                        v80 = v82 + 1;
                        goto LABEL_129;
                      }
                    }
                    if ((v79 & 0x80000000) == 0)
                    {
                      v94 = 0;
                      goto LABEL_141;
                    }
                    v83 = *v78;
LABEL_129:
                    v95 = v80 - 1;
                    v96 = *(_QWORD *)(v83 + 8 * v95);
                    v97 = v96 != 0;
                    v98 = HIDWORD(v96) != 0;
                    if (HIDWORD(v96))
                      v96 >>= 32;
                    v99 = v96 >> 16 != 0;
                    if (v96 >> 16)
                      v96 >>= 16;
                    v100 = v96 > 0xFF;
                    if (v96 > 0xFF)
                      v96 >>= 8;
                    v101 = v96 > 0xF;
                    if (v96 > 0xF)
                      v96 >>= 4;
                    v102 = v96 > 3;
                    if (v96 > 3)
                      v96 >>= 2;
                    v94 = v97 | (v95 << 6) | (32 * v98) | (16 * v99) | (8 * v100) | (4 * v101) | (2 * v102);
                    if (v96 > 1)
                      ++v94;
LABEL_141:
                    v119 = v94;
                    if (bn_one_to_montgomery((uint64_t)v75, v73, (BN_CTX *)a4)
                      && bn_usub_consttime(v77, v73 + 24, (uint64_t)v75))
                    {
                      if (a6)
                      {
                        v103 = 0;
                        v104 = 1;
                        while (1)
                        {
                          v117 = 0;
                          if (!bn_rand_secret_range((uint64_t)v71, &v117, 2uLL, v113))
                            break;
                          v105 = v117;
                          v116 = 0;
                          if (!bn_miller_rabin_iteration((uint64_t)v118, &v116, v71, v73, (BN_CTX *)a4))
                            break;
                          if (!v116)
                            goto LABEL_171;
                          if (!(*(unsigned int (**)(uint64_t, _QWORD, uint64_t))(a6 + 8))(1, v104 - 1, a6))
                            break;
                          v103 += v105;
                          v106 = v104++ >= 0x10;
                          v107 = !v106;
                          v71 = v114;
                          if (!(v107 | ((((v103 - a3) ^ v103 | v103 ^ a3) ^ v103) >> 63)))
                            goto LABEL_165;
                        }
                      }
                      else
                      {
                        v108 = 1;
                        while (1)
                        {
                          v117 = 0;
                          if (!bn_rand_secret_range((uint64_t)v71, &v117, 2uLL, v113))
                            break;
                          v109 = v117;
                          v116 = 0;
                          if (!bn_miller_rabin_iteration((uint64_t)v118, &v116, v71, v73, (BN_CTX *)a4))
                            break;
                          if (!v116)
                          {
LABEL_171:
                            *a1 = 0;
                            v60 = 1;
                            BN_MONT_CTX_free((BN_MONT_CTX *)v73);
                            if (a4[40])
                              goto LABEL_170;
                            goto LABEL_169;
                          }
                          a6 += v109;
                          v106 = v108++ >= 0x10;
                          v110 = !v106;
                          v71 = v114;
                          if (!(v110 | ((((a6 - a3) ^ a6 | a6 ^ a3) ^ a6) >> 63)))
                          {
LABEL_165:
                            v60 = 1;
                            *a1 = 1;
                            BN_MONT_CTX_free((BN_MONT_CTX *)v73);
                            if (a4[40])
                              goto LABEL_170;
                            goto LABEL_169;
                          }
                        }
                      }
                    }
                  }
                }
                v60 = 0;
                goto LABEL_168;
              }
LABEL_173:
              abort();
            }
          }
        }
      }
    }
  }
LABEL_168:
  BN_MONT_CTX_free((BN_MONT_CTX *)v73);
  if (!a4[40])
  {
LABEL_169:
    v111 = *((_QWORD *)a4 + 1);
    v112 = *((_QWORD *)a4 + 2) - 1;
    *((_QWORD *)a4 + 2) = v112;
    *((_QWORD *)a4 + 4) = *(_QWORD *)(v111 + 8 * v112);
  }
LABEL_170:
  BN_CTX_free(c);
  return v60;
}

uint64_t BN_enhanced_miller_rabin_primality_test(int *a1, const BIGNUM *a2, int a3, uint64_t a4, uint64_t a5)
{
  unint64_t top;
  uint64_t *d;
  uint64_t v8;
  BN_MONT_CTX *v14;
  BIGNUM *v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  BN_MONT_CTX *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t *v26;
  int v27;
  uint64_t v28;
  unint64_t v29;
  _BOOL4 v30;
  _BOOL4 v31;
  int v32;
  _BOOL4 v33;
  _BOOL4 v34;
  _BOOL4 v35;
  BOOL v36;
  int v37;
  int v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  _QWORD *v43;
  BIGNUM *v44;
  BIGNUM *v45;
  int v46;
  int v47;
  BIGNUM *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const BIGNUM *v53;
  const BIGNUM *v54;
  BIGNUM *v55;
  int v56;
  BN_MONT_CTX *m_ctx;
  int v58;
  BIGNUM *a;
  const BIGNUM *v60;
  BIGNUM *v61;
  BIGNUM *r;
  uint64_t v63;

  top = a2->top;
  if ((int)top < 1
    || (d = (uint64_t *)a2->d, (*(_BYTE *)a2->d & 1) == 0)
    || (v63 = 3, a2->neg)
    || (int)bn_cmp_words_consttime(d, top, &v63, 1uLL) <= 0)
  {
    ERR_put_error(3, 0, 119, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/prime.c", 807);
    return 0;
  }
  if (a3)
  {
    if (*(_BYTE *)(a4 + 40))
    {
LABEL_9:
      v14 = (BN_MONT_CTX *)BN_CTX_get((BN_CTX *)a4);
      if (!v14)
        goto LABEL_101;
      goto LABEL_10;
    }
  }
  else
  {
    v26 = &d[top - 1];
    v27 = (_DWORD)top << 6;
    do
    {
      v24 = __OFSUB__((_DWORD)top, 1);
      LODWORD(top) = top - 1;
      if (((top & 0x80000000) != 0) != v24)
      {
        a3 = 34;
        if (*(_BYTE *)(a4 + 40))
          goto LABEL_9;
        goto LABEL_46;
      }
      v28 = *v26--;
      v27 -= 64;
    }
    while (!v28);
    v29 = d[top];
    v30 = v29 != 0;
    v31 = HIDWORD(v29) != 0;
    if (HIDWORD(v29))
      v29 >>= 32;
    v32 = 16 * (v29 >> 16 != 0);
    if (v29 >> 16)
      v29 >>= 16;
    v33 = v29 > 0xFF;
    if (v29 > 0xFF)
      v29 >>= 8;
    v34 = v29 > 0xF;
    if (v29 > 0xF)
      v29 >>= 4;
    v35 = v29 > 3;
    if (v29 > 3)
      v29 >>= 2;
    v36 = v29 > 1;
    v37 = v32 | (32 * v31) | (8 * v33) | (4 * v34) | (2 * v35) | v30;
    if (v36)
      ++v37;
    v38 = v37 + v27;
    if (v38 <= 3746)
    {
      if (v38 <= 1344)
      {
        if (v38 <= 475)
        {
          if (v38 <= 399)
          {
            if (v38 <= 346)
            {
              if (v38 <= 307)
              {
                if (v38 <= 54)
                  a3 = 34;
                else
                  a3 = 27;
                if (*(_BYTE *)(a4 + 40))
                  goto LABEL_9;
              }
              else
              {
                a3 = 8;
                if (*(_BYTE *)(a4 + 40))
                  goto LABEL_9;
              }
            }
            else
            {
              a3 = 7;
              if (*(_BYTE *)(a4 + 40))
                goto LABEL_9;
            }
          }
          else
          {
            a3 = 6;
            if (*(_BYTE *)(a4 + 40))
              goto LABEL_9;
          }
        }
        else
        {
          a3 = 5;
          if (*(_BYTE *)(a4 + 40))
            goto LABEL_9;
        }
      }
      else
      {
        a3 = 4;
        if (*(_BYTE *)(a4 + 40))
          goto LABEL_9;
      }
    }
    else
    {
      a3 = 3;
      if (*(_BYTE *)(a4 + 40))
        goto LABEL_9;
    }
  }
LABEL_46:
  v39 = *(_QWORD *)(a4 + 32);
  v40 = *(_QWORD *)(a4 + 16);
  if (v40 != *(_QWORD *)(a4 + 24))
  {
    v43 = *(_QWORD **)(a4 + 8);
LABEL_58:
    v43[v40] = v39;
    ++*(_QWORD *)(a4 + 16);
    v14 = (BN_MONT_CTX *)BN_CTX_get((BN_CTX *)a4);
    if (!v14)
      goto LABEL_101;
    goto LABEL_10;
  }
  if (v40)
    v41 = (3 * v40) >> 1;
  else
    v41 = 32;
  if (v41 > v40 && v41 >> 61 == 0)
  {
    v43 = OPENSSL_realloc(*(_QWORD **)(a4 + 8), 8 * v41);
    if (v43)
    {
      *(_QWORD *)(a4 + 8) = v43;
      *(_QWORD *)(a4 + 24) = v41;
      v40 = *(_QWORD *)(a4 + 16);
      goto LABEL_58;
    }
  }
  *(_WORD *)(a4 + 40) = 257;
  v14 = (BN_MONT_CTX *)BN_CTX_get((BN_CTX *)a4);
  if (!v14)
    goto LABEL_101;
LABEL_10:
  v15 = (BIGNUM *)v14;
  if (v14 != (BN_MONT_CTX *)a2)
  {
    if (!bn_wexpand((uint64_t)v14, a2->top))
      goto LABEL_26;
    v16 = a2->top;
    if ((_DWORD)v16)
    {
      memcpy(v15->d, a2->d, 8 * v16);
      LODWORD(v16) = a2->top;
    }
    v15->top = v16;
    v15->neg = a2->neg;
  }
  if (!BN_sub_word(v15, 1uLL))
    goto LABEL_26;
  v17 = 0;
  v18 = -2;
  do
  {
    while (v17 >> 6 >= v15->top)
    {
      ++v17;
      ++v18;
    }
    v19 = (v15->d[v17 >> 6] >> v17) & 1;
    ++v17;
    ++v18;
  }
  while (!(_DWORD)v19);
  v14 = (BN_MONT_CTX *)BN_CTX_get((BN_CTX *)a4);
  if (v14)
  {
    v20 = v14;
    if (bn_wexpand((uint64_t)v14, v15->top))
    {
      bn_rshift_words(*(int8x16_t **)&v20->ri, (uint64_t)v15->d, v18 + 1, v15->top);
      v20->RR.top = v15->neg;
      v21 = v15->top;
      v22 = 8 * v21 - 8;
      v23 = v15->top;
      while (1)
      {
        v24 = __OFSUB__(v23--, 1);
        if (v23 < 0 != v24)
          break;
        v25 = *(_QWORD *)(*(_QWORD *)&v20->ri + v22);
        v22 -= 8;
        if (v25)
        {
          LODWORD(v20->RR.d) = v23 + 1;
          goto LABEL_67;
        }
      }
      LODWORD(v20->RR.d) = v21 & ((int)v21 >> 31);
      if ((v21 & 0x80000000) == 0)
        v20->RR.top = 0;
LABEL_67:
      v44 = BN_CTX_get((BN_CTX *)a4);
      r = BN_CTX_get((BN_CTX *)a4);
      v61 = BN_CTX_get((BN_CTX *)a4);
      a = BN_CTX_get((BN_CTX *)a4);
      v45 = BN_CTX_get((BN_CTX *)a4);
      v14 = 0;
      v8 = 0;
      v60 = v44;
      if (!v44 || !r || !v61 || !a || !v45)
        goto LABEL_102;
      v55 = v45;
      v14 = (BN_MONT_CTX *)BN_MONT_CTX_new_for_modulus(a2, (BN_CTX *)a4);
      if (v14)
      {
        if (a3 < 1)
        {
          v47 = 0;
LABEL_145:
          *a1 = v47;
          v8 = 1;
        }
        else
        {
          m_ctx = v14;
          if ((v18 + 1) < 2)
          {
            v48 = v61;
            if (a5)
            {
              v52 = 0;
              v53 = v60;
              while (BN_rand_range_ex((uint64_t)v53, 2uLL, (uint64_t)v15)
                   && BN_gcd(r, v53, a2, (BN_CTX *)a4))
              {
                if ((int)BN_cmp_word((uint64_t)r, 1) > 0)
                {
                  v47 = 1;
                  goto LABEL_144;
                }
                v48 = v61;
                if (!BN_mod_exp_mont(v61, v60, (const BIGNUM *)v20, a2, (BN_CTX *)a4, m_ctx))
                  break;
                if (!BN_is_one(&v61->d) && BN_cmp(v61, v15))
                  goto LABEL_91;
                if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a5 + 8))(1, v52, a5))
                  break;
                v52 = (v52 + 1);
                v53 = v60;
                if (a3 == (_DWORD)v52)
                  goto LABEL_124;
              }
            }
            else
            {
              v54 = v60;
              while (1)
              {
                if (!BN_rand_range_ex((uint64_t)v54, 2uLL, (uint64_t)v15)
                  || !BN_gcd(r, v54, a2, (BN_CTX *)a4))
                {
                  goto LABEL_137;
                }
                v47 = 1;
                if ((int)BN_cmp_word((uint64_t)r, 1) > 0)
                  goto LABEL_144;
                if (!BN_mod_exp_mont(v61, v54, (const BIGNUM *)v20, a2, (BN_CTX *)a4, m_ctx))
                  goto LABEL_137;
                if (!BN_is_one(&v61->d) && BN_cmp(v61, v15))
                  break;
                --a3;
                v54 = v60;
                if (!a3)
                {
LABEL_124:
                  v47 = 0;
LABEL_144:
                  v14 = m_ctx;
                  goto LABEL_145;
                }
              }
LABEL_91:
              if (BN_copy(a, v48) && BN_mod_mul(v48, a, a, a2, (BN_CTX *)a4) && (BN_is_one(&v48->d) || BN_copy(a, v48)))
              {
LABEL_95:
                if (BN_copy(v55, a) && BN_sub_word(v55, 1uLL) && BN_gcd(r, v55, a2, (BN_CTX *)a4))
                {
                  if ((int)BN_cmp_word((uint64_t)r, 1) >= 1)
                    v47 = 1;
                  else
                    v47 = 2;
                  goto LABEL_144;
                }
              }
            }
          }
          else
          {
            v46 = 1;
            while (1)
            {
              v56 = v46;
              if (!BN_rand_range_ex((uint64_t)v60, 2uLL, (uint64_t)v15)
                || !BN_gcd(r, v60, a2, (BN_CTX *)a4))
              {
                break;
              }
              v47 = 1;
              if ((int)BN_cmp_word((uint64_t)r, 1) > 0)
                goto LABEL_144;
              v48 = v61;
              if (!BN_mod_exp_mont(v61, v60, (const BIGNUM *)v20, a2, (BN_CTX *)a4, m_ctx))
                break;
              if (!BN_is_one(&v61->d))
              {
                v49 = v18;
                if (BN_cmp(v61, v15))
                {
                  while (1)
                  {
                    v58 = v49;
                    if (!BN_copy(a, v61) || !BN_mod_mul(v61, a, a, a2, (BN_CTX *)a4))
                      goto LABEL_137;
                    if (!BN_cmp(v61, v15))
                      break;
                    if (BN_is_one(&v61->d))
                      goto LABEL_95;
                    --v49;
                    if (v58 == 1)
                      goto LABEL_91;
                  }
                }
              }
              if (a5
                && !(*(unsigned int (**)(uint64_t, _QWORD, uint64_t))(a5 + 8))(1, (v56 - 1), a5))
              {
                break;
              }
              v46 = v56 + 1;
              if (v56 == a3)
                goto LABEL_124;
            }
          }
LABEL_137:
          v8 = 0;
          v14 = m_ctx;
        }
        goto LABEL_102;
      }
      goto LABEL_101;
    }
LABEL_26:
    v8 = 0;
    v14 = 0;
    goto LABEL_102;
  }
LABEL_101:
  v8 = 0;
LABEL_102:
  BN_MONT_CTX_free(v14);
  if (!*(_BYTE *)(a4 + 40))
  {
    v50 = *(_QWORD *)(a4 + 8);
    v51 = *(_QWORD *)(a4 + 16) - 1;
    *(_QWORD *)(a4 + 16) = v51;
    *(_QWORD *)(a4 + 32) = *(_QWORD *)(v50 + 8 * v51);
  }
  return v8;
}

int BIO_printf(BIO *bio, const char *format, ...)
{
  uint64_t v4;
  int (__cdecl *v5)(BIO *, const char *, int);
  int v6;
  int v7;
  size_t v8;
  char *v9;
  _QWORD *v10;
  char *v11;
  uint64_t v12;
  int (__cdecl *bwrite)(BIO *, const char *, int);
  int v14;
  size_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  char __str[256];
  uint64_t v22;
  va_list va;

  va_start(va, format);
  v22 = *MEMORY[0x24BDAC8D0];
  v4 = vsnprintf(__str, 0x100uLL, format, va);
  if ((v4 & 0x80000000) != 0)
    return -1;
  if (v4 > 0xFF)
  {
    v8 = (v4 + 1);
    v9 = (char *)malloc_type_malloc(v8 + 8, 0x30772F57uLL);
    if (!v9)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return -1;
    }
    v10 = v9;
    *(_QWORD *)v9 = v8;
    v11 = v9 + 8;
    v12 = vsnprintf(v9 + 8, v8, format, va);
    if (bio && bio->method && (bwrite = bio->method->bwrite) != 0)
    {
      if (LODWORD(bio->cb_arg))
      {
        if ((int)v12 < 1)
        {
          v7 = 0;
          v15 = *v10 + 8;
          if (*v10 == -8)
            goto LABEL_26;
          goto LABEL_25;
        }
        v14 = ((uint64_t (*)(BIO *, char *, uint64_t))bwrite)(bio, v11, v12);
        v7 = v14;
        if (v14 >= 1)
        {
          bio->prev_bio = (bio_st *)((char *)bio->prev_bio + v14);
          v15 = *v10 + 8;
          if (*v10 == -8)
            goto LABEL_26;
          goto LABEL_25;
        }
LABEL_24:
        v15 = *v10 + 8;
        if (*v10 == -8)
        {
LABEL_26:
          free(v10);
          return v7;
        }
LABEL_25:
        bzero(v10, v15);
        goto LABEL_26;
      }
      v18 = 114;
      v19 = 171;
    }
    else
    {
      v18 = 115;
      v19 = 167;
    }
    ERR_put_error(17, 0, v18, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v19);
    v7 = -2;
    goto LABEL_24;
  }
  if (!bio || !bio->method || (v5 = bio->method->bwrite) == 0)
  {
    v16 = 115;
    v17 = 167;
LABEL_21:
    ERR_put_error(17, 0, v16, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v17);
    return -2;
  }
  if (!LODWORD(bio->cb_arg))
  {
    v16 = 114;
    v17 = 171;
    goto LABEL_21;
  }
  if (!(_DWORD)v4)
    return 0;
  v6 = ((uint64_t (*)(BIO *, char *, uint64_t))v5)(bio, __str, v4);
  v7 = v6;
  if (v6 >= 1)
    bio->prev_bio = (bio_st *)((char *)bio->prev_bio + v6);
  return v7;
}

uint64_t RAND_bytes_with_additional_data(uint64_t result, unint64_t a2, uint64_t a3)
{
  char *v5;
  uint64_t v6;
  char v7;
  int8x16_t v8;
  uint8x8_t v9;
  uint8x8_t v10;
  int16x8_t v11;
  _QWORD *v12;
  _OWORD *v13;
  _DWORD *v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  unint64_t v19;
  int8x16_t v20[3];
  int8x16_t v21[3];
  _OWORD v22[19];
  uint64_t v23;
  int8x16_t bytes;
  char v25;
  _BYTE v26[31];

  *(_QWORD *)&v26[23] = *MEMORY[0x24BDAC8D0];
  if (!a2)
    return result;
  v5 = (char *)result;
  if (pthread_once(&g_pthread_fork_detection_once, (void (*)(void))init_pthread_fork_detection))
    goto LABEL_38;
  v6 = g_atfork_fork_generation;
  if (g_atfork_fork_generation)
  {
    v7 = 0;
    memset(v26, 0, 15);
    v8 = 0uLL;
  }
  else
  {
    if (CCRandomGenerateBytes(&bytes, 0x20uLL))
      goto LABEL_38;
    v8 = bytes;
    v7 = v25;
  }
  bytes = veorq_s8(*(int8x16_t *)a3, v8);
  v25 = *(_BYTE *)(a3 + 16) ^ v7;
  v9.i32[1] = *(_DWORD *)&v26[4];
  v10 = (uint8x8_t)veor_s8(*(int8x8_t *)v26, *(int8x8_t *)(a3 + 17));
  *(uint8x8_t *)v26 = v10;
  v10.i32[0] = *(_DWORD *)(a3 + 25);
  v11 = (int16x8_t)vmovl_u8(v10);
  v9.i32[0] = *(_DWORD *)&v26[8];
  *(int8x8_t *)v11.i8 = veor_s8((int8x8_t)*(_OWORD *)&vmovl_u8(v9), *(int8x8_t *)v11.i8);
  *(_DWORD *)&v26[8] = vmovn_s16(v11).u32[0];
  v26[12] ^= *(_BYTE *)(a3 + 29);
  v26[13] ^= *(_BYTE *)(a3 + 30);
  v26[14] ^= *(_BYTE *)(a3 + 31);
  v23 = 0;
  memset(v22, 0, sizeof(v22));
  if (pthread_once(&g_thread_local_init_once, (void (*)(void))thread_local_init))
LABEL_38:
    abort();
  if (g_thread_local_key_created)
  {
    v12 = pthread_getspecific(g_thread_local_key);
    if (v12)
    {
      v13 = (_OWORD *)v12[1];
      if (v13)
      {
        v14 = (_DWORD *)v13 + 74;
        if (*((_DWORD *)v13 + 74) > 0xFFFu || *((_QWORD *)v13 + 36) != v6 || *((_DWORD *)v13 + 76))
        {
          if (CCRandomGenerateBytes(v21, 0x30uLL) || !ctr_drbg_update((uint64_t)v13, v21, 0x30uLL))
            goto LABEL_38;
          *((_QWORD *)v13 + 35) = 1;
          *v14 = 0;
          *((_QWORD *)v13 + 36) = v6;
          *((_DWORD *)v13 + 76) = 0;
        }
        goto LABEL_26;
      }
    }
  }
  v15 = (char *)malloc_type_malloc(0x140uLL, 0x30772F57uLL);
  if (v15)
  {
    *(_QWORD *)v15 = 312;
    *(_OWORD *)(v15 + 8) = 0u;
    v13 = v15 + 8;
    *(_OWORD *)(v15 + 24) = 0u;
    *(_OWORD *)(v15 + 40) = 0u;
    *(_OWORD *)(v15 + 56) = 0u;
    *(_OWORD *)(v15 + 72) = 0u;
    *(_OWORD *)(v15 + 88) = 0u;
    *(_OWORD *)(v15 + 104) = 0u;
    *(_OWORD *)(v15 + 120) = 0u;
    *(_OWORD *)(v15 + 136) = 0u;
    *(_OWORD *)(v15 + 152) = 0u;
    *(_OWORD *)(v15 + 168) = 0u;
    *(_OWORD *)(v15 + 184) = 0u;
    *(_OWORD *)(v15 + 200) = 0u;
    *(_OWORD *)(v15 + 216) = 0u;
    *(_OWORD *)(v15 + 232) = 0u;
    *(_OWORD *)(v15 + 248) = 0u;
    *((_QWORD *)v15 + 39) = 0;
    *(_OWORD *)(v15 + 264) = 0u;
    *(_OWORD *)(v15 + 280) = 0u;
    *(_OWORD *)(v15 + 296) = 0u;
    if (CRYPTO_set_thread_local(1u, (uint64_t)(v15 + 8), (void (*)(uint64_t))rand_thread_state_free))goto LABEL_20;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  }
  v13 = v22;
LABEL_20:
  *((_DWORD *)v13 + 75) = 0;
  memset(v20, 0, sizeof(v20));
  if (CCRandomGenerateBytes(v21, 0x30uLL) || !CTR_DRBG_init((uint64_t)v13, v21, v20, 0))
    goto LABEL_38;
  v14 = (_DWORD *)v13 + 74;
  *((_DWORD *)v13 + 74) = 0;
  *((_QWORD *)v13 + 36) = v6;
  *((_DWORD *)v13 + 76) = 0;
LABEL_26:
  if (a2 >= 0x10000)
    v16 = 0x10000;
  else
    v16 = a2;
  result = CTR_DRBG_generate((uint64_t)v13, v5, v16, &bytes, 0x20uLL);
  if (!(_DWORD)result)
    goto LABEL_38;
  ++*v14;
  v17 = a2 - v16;
  if (a2 != v16)
  {
    v18 = &v5[v16];
    while (1)
    {
      v19 = v17 >= 0x10000 ? 0x10000 : v17;
      result = CTR_DRBG_generate((uint64_t)v13, v18, v19, &bytes, 0);
      if (!(_DWORD)result)
        break;
      v18 += v19;
      ++*v14;
      v17 -= v19;
      if (!v17)
        return result;
    }
    goto LABEL_38;
  }
  return result;
}

void rand_thread_state_free(_QWORD *a1)
{
  uint64_t v1;
  char *v2;

  if (a1)
  {
    v2 = (char *)(a1 - 1);
    v1 = *(a1 - 1);
    if (v1 != -8)
      bzero(a1 - 1, v1 + 8);
    free(v2);
  }
}

int BN_rand(BIGNUM *rnd, int bits, int top, int bottom)
{
  int v5;
  int v6;
  BIGNUM *v9;
  int v10;
  int v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  unint64_t *d;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;

  if (rnd)
  {
    if ((top - 2) <= 0xFFFFFFFC)
    {
      v5 = 66;
      v6 = 131;
LABEL_9:
      ERR_put_error(3, 0, v5, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/random.c", v6);
      LODWORD(rnd) = 0;
      return (int)rnd;
    }
    if (bottom >= 2)
    {
      v5 = 66;
      v6 = 136;
      goto LABEL_9;
    }
    v9 = rnd;
    if (!bits)
    {
      rnd->neg = 0;
      rnd->top = 0;
LABEL_33:
      LODWORD(rnd) = 1;
      return (int)rnd;
    }
    if (bits >= 2147483585)
    {
      v5 = 102;
      v6 = 146;
      goto LABEL_9;
    }
    v10 = bits >= -63 ? bits + 63 : bits + 126;
    v11 = 1 - bits >= 0 ? -((1 - bits) & 0x3F) : (bits - 1) & 0x3F;
    v12 = (uint64_t)v10 >> 6;
    LODWORD(rnd) = bn_wexpand((uint64_t)rnd, v12);
    if ((_DWORD)rnd)
    {
      v13 = v10 >> 6;
      if (v11 < 63)
        v14 = ~(-1 << (v11 + 1));
      else
        v14 = -1;
      RAND_bytes_with_additional_data((uint64_t)v9->d, 8 * v12, (uint64_t)&RAND_bytes_kZeroAdditionalData);
      d = v9->d;
      v16 = v13 - 1;
      v17 = v9->d[v16] & v14;
      v9->d[v16] = v17;
      if (top != -1)
      {
        if (bits >= 2 && top == 1)
        {
          if (!v11)
          {
            d[v16] = v17 | 1;
            d[v13 - 2] |= 0x8000000000000000;
            goto LABEL_30;
          }
          v18 = 3 << (v11 - 1);
        }
        else
        {
          v18 = 1 << v11;
        }
        d[v16] = v17 | v18;
      }
LABEL_30:
      if (bottom == 1)
        *d |= 1uLL;
      v9->neg = 0;
      v9->top = v13;
      goto LABEL_33;
    }
  }
  return (int)rnd;
}

uint64_t bn_rand_range_words(uint64_t *a1, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  int8x8_t v22;
  unint64_t v23;
  int8x16_t v24;
  unint64_t v25;
  int8x16_t *v26;
  int8x16_t v27;
  int8x16_t v28;
  int v29;
  int v30;
  int v31;
  BOOL v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v37;

  v10 = -8;
  v11 = a4;
  do
  {
    if (!v11)
      goto LABEL_20;
    v12 = v11 - 1;
    v13 = a3[v11 - 1];
    v10 += 8;
    --v11;
  }
  while (!v13);
  if (v12 || *a3 > a2)
  {
    v14 = v13 | (v13 >> 1) | ((v13 | (v13 >> 1)) >> 2);
    v15 = v14 | (v14 >> 4) | ((v14 | (v14 >> 4)) >> 8);
    v16 = v15 | (v15 >> 16);
    if (v10)
      bzero(&a1[v12 + 1], v10);
    v17 = v16 | HIDWORD(v16);
    v18 = 8 * a4 - v10;
    if (a2)
    {
      if (v12)
      {
        v37 = a5;
        v19 = 100;
        while (1)
        {
          if (!--v19)
            goto LABEL_29;
          RAND_bytes_with_additional_data((uint64_t)a1, v18, a5);
          a1[v12] &= v17;
          if (v12 >= 4)
          {
            v24 = 0uLL;
            v25 = v12 & 0xFFFFFFFFFFFFFFFCLL;
            v26 = (int8x16_t *)(a1 + 3);
            v27 = 0uLL;
            do
            {
              v24 = vorrq_s8(v26[-1], v24);
              v27 = vorrq_s8(*v26, v27);
              v26 += 2;
              v25 -= 4;
            }
            while (v25);
            v28 = vorrq_s8(v27, v24);
            v22 = vorr_s8(*(int8x8_t *)v28.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
            v23 = v12 & 0xFFFFFFFFFFFFFFFCLL | 1;
            if (v12 == (v12 & 0xFFFFFFFFFFFFFFFCLL))
              goto LABEL_11;
          }
          else
          {
            v22 = 0;
            v23 = 1;
          }
          do
            *(_QWORD *)&v22 |= a1[v23++];
          while (v12 + 1 != v23);
LABEL_11:
          v20 = (uint64_t)((*(_QWORD *)&v22 - 1) & ~*(_QWORD *)&v22 & (((*a1 - a2) ^ *a1 | *a1 ^ a2) ^ *a1)) >> 63;
          v21 = (bn_cmp_words_consttime(a1, v12 + 1, a3, v12 + 1) >> 31) & ~(_DWORD)v20;
          a5 = v37;
          if (v21)
            return 1;
        }
      }
      v34 = -100;
      while (1)
      {
        v32 = __CFADD__(v34++, 1);
        if (v32)
          break;
        RAND_bytes_with_additional_data((uint64_t)a1, v18, a5);
        *a1 &= v17;
        v35 = (uint64_t)(((*a1 - a2) ^ *a1 | *a1 ^ a2) ^ *a1) >> 63;
        v33 = 1;
        if (((bn_cmp_words_consttime(a1, 1uLL, a3, 1uLL) >> 31) & ~(_DWORD)v35) != 0)
          return v33;
      }
    }
    else
    {
      v31 = -100;
      while (1)
      {
        v32 = __CFADD__(v31++, 1);
        if (v32)
          break;
        RAND_bytes_with_additional_data((uint64_t)a1, v18, a5);
        a1[v12] &= v17;
        if ((int)bn_cmp_words_consttime(a1, v12 + 1, a3, v12 + 1) < 0)
          return 1;
      }
    }
LABEL_29:
    v29 = 115;
    v30 = 271;
  }
  else
  {
LABEL_20:
    v29 = 108;
    v30 = 230;
  }
  ERR_put_error(3, 0, v29, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/random.c", v30);
  return 0;
}

uint64_t BN_rand_range_ex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = bn_wexpand(a1, *(int *)(a3 + 8));
  if ((_DWORD)result)
  {
    result = bn_rand_range_words(*(uint64_t **)a1, a2, *(uint64_t **)a3, *(int *)(a3 + 8), (uint64_t)&BN_rand_range_ex_kDefaultAdditionalData);
    if ((_DWORD)result)
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a3 + 8);
      return 1;
    }
  }
  return result;
}

uint64_t bn_rand_secret_range(uint64_t a1, _DWORD *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t result;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  int8x8_t v26;
  unint64_t v27;
  char v28;
  int8x16_t *v29;
  int8x16_t v30;
  unint64_t v31;
  int8x16_t v32;
  int8x16_t v33;
  uint64_t v34;
  unint64_t v35;

  v8 = 0;
  v9 = *(int *)(a4 + 8);
  v10 = -8;
  do
  {
    if (!(v9 + v8))
      goto LABEL_10;
    v11 = *(_QWORD *)(*(_QWORD *)a4 + 8 * v9 - 8 + 8 * v8--);
    v10 += 8;
  }
  while (!v11);
  v12 = v9 + v8;
  if (!(v9 + v8) && **(_QWORD **)a4 <= a3)
  {
LABEL_10:
    v18 = 230;
    goto LABEL_11;
  }
  v13 = v12 + 1;
  result = bn_wexpand(a1, v12 + 1);
  if (!(_DWORD)result)
    return result;
  v15 = v11 | (v11 >> 1) | ((v11 | (v11 >> 1)) >> 2);
  v16 = v15 | (v15 >> 4) | ((v15 | (v15 >> 4)) >> 8);
  v17 = v16 | (v16 >> 16) | ((v16 | (v16 >> 16)) >> 32);
  if (!v12 && v17 >> 1 < a3)
  {
    v18 = 323;
LABEL_11:
    ERR_put_error(3, 0, 108, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/random.c", v18);
    return 0;
  }
  v35 = v17 >> 1;
  RAND_bytes_with_additional_data(*(_QWORD *)a1, 8 * v9 - v10, (uint64_t)&RAND_bytes_kZeroAdditionalData);
  v19 = *(uint64_t **)a1;
  v20 = *(_QWORD *)a1 + 8 * v9;
  v21 = *(_QWORD *)(v20 + 8 * v8) & v17;
  v22 = v20;
  *(_QWORD *)(v20 + 8 * v8) = v21;
  v23 = *(uint64_t **)a4;
  if (a3)
  {
    if (v12)
    {
      v24 = 8 * v8;
      v25 = v9 + v8;
      if ((unint64_t)(v9 + v8) >= 4)
      {
        v27 = v25 & 0xFFFFFFFFFFFFFFFCLL | 1;
        v29 = (int8x16_t *)(v19 + 3);
        v30 = 0uLL;
        v31 = v25 & 0xFFFFFFFFFFFFFFFCLL;
        v32 = 0uLL;
        do
        {
          v30 = vorrq_s8(v29[-1], v30);
          v32 = vorrq_s8(*v29, v32);
          v29 += 2;
          v31 -= 4;
        }
        while (v31);
        v33 = vorrq_s8(v32, v30);
        v26 = vorr_s8(*(int8x8_t *)v33.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
        if (v25 == (v25 & 0xFFFFFFFFFFFFFFFCLL))
          goto LABEL_23;
      }
      else
      {
        v26 = 0;
        v27 = 1;
      }
      do
        *(_QWORD *)&v26 |= v19[v27++];
      while (v13 != v27);
    }
    else
    {
      v24 = 8 * v8;
      v26 = 0;
    }
LABEL_23:
    v28 = ~((uint64_t)((*(_QWORD *)&v26 - 1) & ~*(_QWORD *)&v26 & (((*v19 - a3) ^ *v19 | *v19 ^ a3) ^ *v19)) >> 63);
    goto LABEL_24;
  }
  v24 = 8 * v8;
  v28 = -1;
LABEL_24:
  v34 = *(_DWORD *)&v28 & (bn_cmp_words_consttime(v19, v13, v23, v13) >> 31);
  *v19 |= a3 & (v34 - 1);
  *(_QWORD *)(v22 + v24) &= -v34 | v35;
  *a2 = v34;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = v9 + v8 + 1;
  return 1;
}

int RSA_check_key(const RSA *a1)
{
  BIGNUM *n;
  ENGINE *engine;
  int v4;
  int v5;
  int v6;
  uint64_t version;
  BN_CTX *v8;
  BN_CTX *v9;
  BIGNUM *v10;
  const BIGNUM *v11;
  BIGNUM *e;
  int v13;
  int v14;
  BIGNUM *v16;
  const BIGNUM *v17;
  BIGNUM *v18;
  const BIGNUM *v19;
  int v20;
  int v21;
  _BOOL4 v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int8x16_t v26;
  unsigned __int128 v27;
  int8x16_t *v28;
  unint64_t v29;
  int8x16_t v30;
  uint64_t v31;
  unint64_t *v32;
  uint64_t v33;
  _BOOL4 v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  int8x16_t v38;
  unsigned __int128 v39;
  int8x16_t *v40;
  unint64_t v41;
  int8x16_t v42;
  uint64_t v43;
  unint64_t *v44;
  uint64_t v45;
  BIGNUM *d;
  _BOOL4 v47;
  uint64_t v48;
  BIGNUM v49;
  BIGNUM v50;
  BIGNUM v51;
  BIGNUM v52;
  BIGNUM v53;
  BIGNUM a;

  if (*(_QWORD *)&a1->pad && (*(_BYTE *)(*(_QWORD *)&a1->pad + 72) & 1) != 0)
    return 1;
  if (!rsa_check_public_key((uint64_t)a1))
    return 0;
  n = a1->n;
  if ((n == 0) == (a1->e != 0))
  {
    v4 = 134;
    v5 = 799;
    goto LABEL_9;
  }
  engine = a1->engine;
  if (!engine)
    return 1;
  if (*((_DWORD *)engine + 4)
    || (version = a1->version) != 0
    && (*(_DWORD *)(version + 16)
     || (bn_cmp_words_consttime(*(uint64_t **)engine, *((int *)engine + 2), *(uint64_t **)version, *(int *)(version + 8)) & 0x80000000) == 0))
  {
    v4 = 147;
    v5 = 807;
LABEL_9:
    ERR_put_error(4, 0, v4, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c", v5);
    return 0;
  }
  if (!n)
    return 1;
  v8 = BN_CTX_new();
  if (v8)
  {
    v9 = v8;
    memset(&a, 0, sizeof(a));
    memset(&v53, 0, sizeof(v53));
    memset(&v52, 0, sizeof(v52));
    memset(&v51, 0, sizeof(v51));
    memset(&v50, 0, sizeof(v50));
    memset(&v49, 0, sizeof(v49));
    v10 = a1->n;
    if (v10->neg
      || (v11 = (const BIGNUM *)a1->version, BN_cmp(a1->n, v11) >= 0)
      || (e = a1->e, e->neg)
      || BN_cmp(a1->e, v11) >= 0)
    {
      v13 = 132;
      v14 = 839;
      goto LABEL_21;
    }
    if (!bn_mul_consttime((uint64_t)&a, (uint64_t)v10, (uint64_t)e, v9))
    {
      v13 = 3;
      v14 = 843;
      goto LABEL_21;
    }
    if (BN_cmp(&a, (const BIGNUM *)a1->version))
    {
      v13 = 132;
      v14 = 847;
      goto LABEL_21;
    }
    v16 = a1->n;
    v17 = BN_value_one();
    if (!bn_usub_consttime((uint64_t)&v52, (uint64_t)v16, (uint64_t)v17)
      || (v18 = a1->e, v19 = BN_value_one(), !bn_usub_consttime((uint64_t)&v51, (uint64_t)v18, (uint64_t)v19)))
    {
      v13 = 3;
      v14 = 857;
      goto LABEL_21;
    }
    v20 = BN_num_bits(&v52);
    v21 = BN_num_bits(&v51);
    if (!bn_mul_consttime((uint64_t)&v53, (uint64_t)a1->engine, (uint64_t)a1->meth, v9)
      || !bn_div_consttime(0, &a, &v53, &v52, v20, v9)
      || !bn_div_consttime(0, &v53, &v53, &v51, v21, v9))
    {
      v13 = 3;
      v14 = 865;
      goto LABEL_21;
    }
    if (a.neg)
    {
      v22 = 1;
      goto LABEL_49;
    }
    if (a.top)
    {
      v23 = *a.d ^ 1;
      if (a.top >= 2)
      {
        if (a.top >= 5u)
        {
          v25 = (a.top - 1) & 0xFFFFFFFFFFFFFFFCLL;
          v24 = v25 | 1;
          v26 = 0uLL;
          v27 = *a.d ^ (unsigned __int128)1uLL;
          v28 = (int8x16_t *)(a.d + 3);
          v29 = v25;
          do
          {
            v27 = (unsigned __int128)vorrq_s8(v28[-1], (int8x16_t)v27);
            v26 = vorrq_s8(*v28, v26);
            v28 += 2;
            v29 -= 4;
          }
          while (v29);
          v30 = vorrq_s8(v26, (int8x16_t)v27);
          v23 = (unint64_t)vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
          if (a.top - 1 == v25)
            goto LABEL_48;
        }
        else
        {
          v24 = 1;
        }
        v31 = a.top - v24;
        v32 = &a.d[v24];
        do
        {
          v33 = *v32++;
          v23 |= v33;
          --v31;
        }
        while (v31);
      }
    }
    else
    {
      v23 = 1;
    }
LABEL_48:
    v22 = v23 != 0;
LABEL_49:
    if (v22)
      goto LABEL_64;
    if (v53.neg)
    {
      v34 = 1;
      goto LABEL_63;
    }
    if (v53.top)
    {
      v35 = *v53.d ^ 1;
      if (v53.top >= 2)
      {
        if (v53.top >= 5u)
        {
          v37 = (v53.top - 1) & 0xFFFFFFFFFFFFFFFCLL;
          v36 = v37 | 1;
          v38 = 0uLL;
          v39 = *v53.d ^ (unsigned __int128)1uLL;
          v40 = (int8x16_t *)(v53.d + 3);
          v41 = v37;
          do
          {
            v39 = (unsigned __int128)vorrq_s8(v40[-1], (int8x16_t)v39);
            v38 = vorrq_s8(*v40, v38);
            v40 += 2;
            v41 -= 4;
          }
          while (v41);
          v42 = vorrq_s8(v38, (int8x16_t)v39);
          v35 = (unint64_t)vorr_s8(*(int8x8_t *)v42.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL));
          if (v53.top - 1 == v37)
            goto LABEL_62;
        }
        else
        {
          v36 = 1;
        }
        v43 = v53.top - v36;
        v44 = &v53.d[v36];
        do
        {
          v45 = *v44++;
          v35 |= v45;
          --v43;
        }
        while (v43);
      }
    }
    else
    {
      v35 = 1;
    }
LABEL_62:
    v34 = v35 != 0;
LABEL_63:
    if (!v34)
    {
      d = a1->d;
      if ((d != 0) != (a1->p == 0) && (d != 0) != (a1->q == 0))
      {
        if (d)
        {
          v48 = 0;
          v47 = 0;
          if (!check_mod_inverse((_BOOL4 *)&v48 + 1, (uint64_t)a1->meth, (uint64_t)d, &v52, v20, v9)
            || !check_mod_inverse((_BOOL4 *)&v48, (uint64_t)a1->meth, (uint64_t)a1->p, &v51, v21, v9)
            || !check_mod_inverse(&v47, (uint64_t)a1->e, (uint64_t)a1->q, a1->n, v20, v9))
          {
            v13 = 3;
            v14 = 890;
            goto LABEL_21;
          }
          if (!HIDWORD(v48) || !(_DWORD)v48 || !v47)
          {
            v13 = 111;
            v14 = 895;
            goto LABEL_21;
          }
        }
        v6 = 1;
        goto LABEL_22;
      }
      v13 = 123;
      v14 = 878;
LABEL_21:
      ERR_put_error(4, 0, v13, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c", v14);
      v6 = 0;
LABEL_22:
      BN_free(&a);
      BN_free(&v53);
      BN_free(&v52);
      BN_free(&v51);
      BN_free(&v50);
      BN_free(&v49);
      BN_CTX_free(v9);
      return v6;
    }
LABEL_64:
    v13 = 119;
    v14 = 871;
    goto LABEL_21;
  }
  return 0;
}

void RSA_free(RSA *r)
{
  unsigned int *p_dmq1;
  unsigned int i;
  unsigned int v4;
  void (*v5)(RSA *);
  uint64_t version;
  int v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;
  void *v12;
  uint64_t v13;
  size_t v14;
  const RSA_METHOD *meth;
  int rsa_pub_dec_high;
  const char *name;
  char *v18;
  uint64_t v19;
  size_t v20;
  int (__cdecl **p_rsa_keygen)(RSA *, int, BIGNUM *, BN_GENCB *);
  int (__cdecl *rsa_keygen)(RSA *, int, BIGNUM *, BN_GENCB *);
  size_t v23;
  ENGINE *engine;
  int v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  size_t v29;
  char *v30;
  uint64_t v31;
  size_t v32;
  BIGNUM *n;
  int flags;
  unint64_t *d;
  unint64_t *v36;
  uint64_t v37;
  size_t v38;
  int *p_neg;
  uint64_t v40;
  size_t v41;
  BIGNUM *e;
  int v43;
  unint64_t *v44;
  unint64_t *v45;
  uint64_t v46;
  size_t v47;
  int *v48;
  uint64_t v49;
  size_t v50;
  BIGNUM *v51;
  int v52;
  unint64_t *v53;
  unint64_t *v54;
  uint64_t v55;
  size_t v56;
  int *v57;
  uint64_t v58;
  size_t v59;
  BIGNUM *p;
  int v61;
  unint64_t *v62;
  unint64_t *v63;
  uint64_t v64;
  size_t v65;
  int *v66;
  uint64_t v67;
  size_t v68;
  BIGNUM *q;
  int v70;
  unint64_t *v71;
  unint64_t *v72;
  uint64_t v73;
  size_t v74;
  int *v75;
  uint64_t v76;
  size_t v77;
  BN_BLINDING **p_mt_blinding;
  BN_BLINDING *mt_blinding;
  size_t v80;

  if (r)
  {
    p_dmq1 = (unsigned int *)&r->dmq1;
    for (i = atomic_load((unsigned int *)&r->dmq1); i != -1; i = v4)
    {
      if (!i)
        abort();
      v4 = __ldaxr(p_dmq1);
      if (v4 == i)
      {
        if (!__stlxr(i - 1, p_dmq1))
        {
          if (i == 1)
          {
            v5 = *(void (**)(RSA *))(*(_QWORD *)&r->pad + 24);
            if (v5)
              v5(r);
            CRYPTO_free_ex_data((int)&g_rsa_ex_data_class, r, (CRYPTO_EX_DATA *)&r->dmp1);
            version = r->version;
            if (version)
            {
              v7 = *(_DWORD *)(version + 20);
              if ((v7 & 2) == 0)
              {
                v8 = *(_QWORD *)version;
                if (*(_QWORD *)version)
                {
                  v10 = *(_QWORD *)(v8 - 8);
                  v9 = (void *)(v8 - 8);
                  v11 = v10 + 8;
                  if (v10 != -8)
                    bzero(v9, v11);
                  free(v9);
                  v7 = *(_DWORD *)(version + 20);
                }
              }
              if ((v7 & 1) != 0)
              {
                v13 = *(_QWORD *)(version - 8);
                v12 = (void *)(version - 8);
                v14 = v13 + 8;
                if (v13 != -8)
                  bzero(v12, v14);
                free(v12);
              }
              else
              {
                *(_QWORD *)version = 0;
              }
            }
            meth = r->meth;
            if (meth)
            {
              rsa_pub_dec_high = HIDWORD(meth->rsa_pub_dec);
              if ((rsa_pub_dec_high & 2) == 0)
              {
                name = meth->name;
                if (meth->name)
                {
                  v19 = *((_QWORD *)name - 1);
                  v18 = (char *)(name - 8);
                  v20 = v19 + 8;
                  if (v19 != -8)
                    bzero(v18, v20);
                  free(v18);
                  rsa_pub_dec_high = HIDWORD(meth->rsa_pub_dec);
                }
              }
              if ((rsa_pub_dec_high & 1) != 0)
              {
                rsa_keygen = meth[-1].rsa_keygen;
                p_rsa_keygen = &meth[-1].rsa_keygen;
                v23 = (size_t)rsa_keygen + 8;
                if (rsa_keygen != (int (__cdecl *)(RSA *, int, BIGNUM *, BN_GENCB *))-8)
                  bzero(p_rsa_keygen, v23);
                free(p_rsa_keygen);
              }
              else
              {
                meth->name = 0;
              }
            }
            engine = r->engine;
            if (engine)
            {
              v25 = *((_DWORD *)engine + 5);
              if ((v25 & 2) == 0)
              {
                v26 = *(_QWORD *)engine;
                if (*(_QWORD *)engine)
                {
                  v28 = *(_QWORD *)(v26 - 8);
                  v27 = (void *)(v26 - 8);
                  v29 = v28 + 8;
                  if (v28 != -8)
                    bzero(v27, v29);
                  free(v27);
                  v25 = *((_DWORD *)engine + 5);
                }
              }
              if ((v25 & 1) != 0)
              {
                v31 = *((_QWORD *)engine - 1);
                v30 = (char *)engine - 8;
                v32 = v31 + 8;
                if (v31 != -8)
                  bzero(v30, v32);
                free(v30);
              }
              else
              {
                *(_QWORD *)engine = 0;
              }
            }
            n = r->n;
            if (n)
            {
              flags = n->flags;
              if ((flags & 2) == 0)
              {
                d = n->d;
                if (n->d)
                {
                  v37 = *(d - 1);
                  v36 = d - 1;
                  v38 = v37 + 8;
                  if (v37 != -8)
                    bzero(v36, v38);
                  free(v36);
                  flags = n->flags;
                }
              }
              if ((flags & 1) != 0)
              {
                v40 = *(_QWORD *)&n[-1].neg;
                p_neg = &n[-1].neg;
                v41 = v40 + 8;
                if (v40 != -8)
                  bzero(p_neg, v41);
                free(p_neg);
              }
              else
              {
                n->d = 0;
              }
            }
            e = r->e;
            if (e)
            {
              v43 = e->flags;
              if ((v43 & 2) == 0)
              {
                v44 = e->d;
                if (e->d)
                {
                  v46 = *(v44 - 1);
                  v45 = v44 - 1;
                  v47 = v46 + 8;
                  if (v46 != -8)
                    bzero(v45, v47);
                  free(v45);
                  v43 = e->flags;
                }
              }
              if ((v43 & 1) != 0)
              {
                v49 = *(_QWORD *)&e[-1].neg;
                v48 = &e[-1].neg;
                v50 = v49 + 8;
                if (v49 != -8)
                  bzero(v48, v50);
                free(v48);
              }
              else
              {
                e->d = 0;
              }
            }
            v51 = r->d;
            if (v51)
            {
              v52 = v51->flags;
              if ((v52 & 2) == 0)
              {
                v53 = v51->d;
                if (v51->d)
                {
                  v55 = *(v53 - 1);
                  v54 = v53 - 1;
                  v56 = v55 + 8;
                  if (v55 != -8)
                    bzero(v54, v56);
                  free(v54);
                  v52 = v51->flags;
                }
              }
              if ((v52 & 1) != 0)
              {
                v58 = *(_QWORD *)&v51[-1].neg;
                v57 = &v51[-1].neg;
                v59 = v58 + 8;
                if (v58 != -8)
                  bzero(v57, v59);
                free(v57);
              }
              else
              {
                v51->d = 0;
              }
            }
            p = r->p;
            if (p)
            {
              v61 = p->flags;
              if ((v61 & 2) == 0)
              {
                v62 = p->d;
                if (p->d)
                {
                  v64 = *(v62 - 1);
                  v63 = v62 - 1;
                  v65 = v64 + 8;
                  if (v64 != -8)
                    bzero(v63, v65);
                  free(v63);
                  v61 = p->flags;
                }
              }
              if ((v61 & 1) != 0)
              {
                v67 = *(_QWORD *)&p[-1].neg;
                v66 = &p[-1].neg;
                v68 = v67 + 8;
                if (v67 != -8)
                  bzero(v66, v68);
                free(v66);
              }
              else
              {
                p->d = 0;
              }
            }
            q = r->q;
            if (q)
            {
              v70 = q->flags;
              if ((v70 & 2) == 0)
              {
                v71 = q->d;
                if (q->d)
                {
                  v73 = *(v71 - 1);
                  v72 = v71 - 1;
                  v74 = v73 + 8;
                  if (v73 != -8)
                    bzero(v72, v74);
                  free(v72);
                  v70 = q->flags;
                }
              }
              if ((v70 & 1) != 0)
              {
                v76 = *(_QWORD *)&q[-1].neg;
                v75 = &q[-1].neg;
                v77 = v76 + 8;
                if (v76 != -8)
                  bzero(v75, v77);
                free(v75);
              }
              else
              {
                q->d = 0;
              }
            }
            rsa_invalidate_key((uint64_t)r);
            pthread_rwlock_destroy((pthread_rwlock_t *)&r->iqmp);
            mt_blinding = r[-1].mt_blinding;
            p_mt_blinding = &r[-1].mt_blinding;
            v80 = (size_t)mt_blinding + 8;
            if (mt_blinding != (BN_BLINDING *)-8)
              bzero(p_mt_blinding, v80);
            free(p_mt_blinding);
          }
          return;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
}

RSA *__cdecl RSA_new_method(ENGINE *engine)
{
  char *v2;
  char *v3;
  RSA *v4;
  __int128 *v5;
  int v6;
  unsigned int (*v7)(RSA *);

  v2 = (char *)malloc_type_malloc(0x188uLL, 0x30772F57uLL);
  if (!v2)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v3 = v2;
  *(_OWORD *)(v2 + 8) = 0u;
  v4 = (RSA *)(v2 + 8);
  *(_QWORD *)v2 = 384;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 168) = 0u;
  *(_OWORD *)(v2 + 184) = 0u;
  *(_OWORD *)(v2 + 200) = 0u;
  *(_OWORD *)(v2 + 216) = 0u;
  *(_OWORD *)(v2 + 232) = 0u;
  *(_OWORD *)(v2 + 248) = 0u;
  *(_OWORD *)(v2 + 264) = 0u;
  *(_OWORD *)(v2 + 280) = 0u;
  *(_OWORD *)(v2 + 296) = 0u;
  *(_OWORD *)(v2 + 312) = 0u;
  *(_OWORD *)(v2 + 328) = 0u;
  *(_OWORD *)(v2 + 344) = 0u;
  *(_OWORD *)(v2 + 360) = 0u;
  *(_OWORD *)(v2 + 376) = 0u;
  if (!engine || (v5 = *(__int128 **)engine, *(_QWORD *)&v4->pad = *(_QWORD *)engine, !v5))
  {
    if (pthread_once(&RSA_default_method_once, (void (*)(void))RSA_default_method_init))
      goto LABEL_14;
    v5 = &RSA_default_method_storage;
    *(_QWORD *)&v4->pad = &RSA_default_method_storage;
  }
  v6 = *((_DWORD *)v5 + 18);
  *((_DWORD *)v3 + 22) = 1;
  *((_DWORD *)v3 + 23) = v6;
  if (pthread_rwlock_init((pthread_rwlock_t *)(v3 + 96), 0))
LABEL_14:
    abort();
  *((_QWORD *)v3 + 10) = 0;
  v7 = *(unsigned int (**)(RSA *))(*((_QWORD *)v3 + 1) + 16);
  if (!v7 || v7(v4))
    return v4;
  CRYPTO_free_ex_data((int)&g_rsa_ex_data_class, v4, (CRYPTO_EX_DATA *)v3 + 5);
  pthread_rwlock_destroy((pthread_rwlock_t *)(v3 + 96));
  if (*(_QWORD *)v3 != -8)
    __memset_chk();
  free(v3);
  return 0;
}

uint64_t RSA_add_pkcs1_prefix(_QWORD *a1, size_t *a2, _DWORD *a3, int a4, const void *a5, size_t a6)
{
  uint64_t result;
  int v13;
  unsigned __int8 *v14;
  size_t v15;
  unint64_t v16;
  const char *v17;
  int v18;
  int v19;
  int v20;
  _QWORD *v21;
  _QWORD *v22;

  result = rsa_check_digest_size(a4, a6);
  if (!(_DWORD)result)
    return result;
  if (a4 > 671)
  {
    switch(a4)
    {
      case 672:
        v13 = 3;
        goto LABEL_14;
      case 673:
        v13 = 4;
        goto LABEL_14;
      case 674:
        v13 = 5;
        goto LABEL_14;
      case 675:
        v13 = 2;
        goto LABEL_14;
      default:
        goto LABEL_23;
    }
  }
  switch(a4)
  {
    case 4:
      v13 = 0;
      break;
    case 64:
      v13 = 1;
      break;
    case 114:
      *a1 = a5;
      *a2 = a6;
      result = 1;
      *a3 = 0;
      return result;
    default:
LABEL_23:
      v17 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src"
            "/crypto/fipsmodule/rsa/rsa.c";
      v18 = 4;
      v19 = 142;
      v20 = 593;
      goto LABEL_24;
  }
LABEL_14:
  v14 = &kPKCS1SigPrefixes[28 * v13];
  v15 = v14[5];
  v16 = v15 + a6;
  if (__CFADD__(v15, a6))
  {
    v17 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/rsa.c";
    v18 = 4;
    v19 = 140;
    v20 = 574;
LABEL_24:
    ERR_put_error(v18, 0, v19, v17, v20);
    return 0;
  }
  if (v16 > 0xFFFFFFFFFFFFFFF7 || (v21 = malloc_type_malloc(v16 + 8, 0x30772F57uLL)) == 0)
  {
    v17 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v18 = 14;
    v19 = 65;
    v20 = 247;
    goto LABEL_24;
  }
  *v21 = v16;
  v22 = v21 + 1;
  memcpy(v21 + 1, v14 + 6, v15);
  if (a6)
    memcpy((char *)v22 + v15, a5, a6);
  *a1 = v22;
  *a2 = v16;
  result = 1;
  *a3 = 1;
  return result;
}

uint64_t rsa_check_digest_size(int a1, uint64_t a2)
{
  unsigned int v2;

  if (a1 > 671)
  {
    switch(a1)
    {
      case 672:
        v2 = 3;
        goto LABEL_15;
      case 673:
        v2 = 4;
        goto LABEL_15;
      case 674:
        v2 = 5;
        goto LABEL_15;
      case 675:
        v2 = 2;
        goto LABEL_15;
      default:
        goto LABEL_13;
    }
  }
  switch(a1)
  {
    case 4:
      v2 = 0;
      goto LABEL_15;
    case 64:
      v2 = 1;
LABEL_15:
      if (kPKCS1SigPrefixes[28 * v2 + 4] == a2)
        return 1;
      ERR_put_error(4, 0, 125, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c", 534);
      return 0;
    case 114:
      if (a2 == 36)
      {
        return 1;
      }
      else
      {
        ERR_put_error(4, 0, 125, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c", 524);
        return 0;
      }
    default:
LABEL_13:
      ERR_put_error(4, 0, 142, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c", 541);
      return 0;
  }
}

uint64_t rsa_sign_no_self_test(uint64_t a1, const void *a2, size_t a3, char *a4, _DWORD *a5, _QWORD *a6)
{
  uint64_t (*v13)(_QWORD *);
  unsigned int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  unint64_t v25;
  _BOOL4 v26;
  _BOOL4 v27;
  _BOOL4 v28;
  _BOOL4 v29;
  _BOOL4 v30;
  _BOOL4 v31;
  int v32;
  unsigned int (*v33)(_QWORD *, unint64_t *, char *, _QWORD, void *, size_t, uint64_t);
  uint64_t v34;
  char *v35;
  unint64_t v36;
  int v37;
  size_t v38;
  void *v39;

  if (!*(_QWORD *)(*a6 + 40))
  {
    v13 = *(uint64_t (**)(_QWORD *))(*a6 + 32);
    if (v13)
    {
      v14 = v13(a6);
    }
    else
    {
      v16 = (uint64_t *)a6[1];
      v17 = *((unsigned int *)v16 + 2);
      v18 = v17 & ((int)v17 >> 31);
      v19 = 8 * v17 - 8;
      v20 = *((_DWORD *)v16 + 2);
      while (1)
      {
        v21 = __OFSUB__(v20--, 1);
        if (v20 < 0 != v21)
          break;
        v22 = *v16;
        v23 = *(_QWORD *)(*v16 + v19);
        v19 -= 8;
        if (v23)
        {
          v18 = v20 + 1;
          goto LABEL_14;
        }
      }
      if ((v17 & 0x80000000) == 0)
      {
        v14 = 0;
        goto LABEL_27;
      }
      v22 = *v16;
LABEL_14:
      v24 = v18 - 1;
      v25 = *(_QWORD *)(v22 + 8 * v24);
      v26 = v25 != 0;
      v27 = HIDWORD(v25) != 0;
      if (HIDWORD(v25))
        v25 >>= 32;
      v28 = v25 >> 16 != 0;
      if (v25 >> 16)
        v25 >>= 16;
      v29 = v25 > 0xFF;
      if (v25 > 0xFF)
        v25 >>= 8;
      v30 = v25 > 0xF;
      if (v25 > 0xF)
        v25 >>= 4;
      v31 = v25 > 3;
      if (v25 > 3)
        v25 >>= 2;
      v32 = v26 | (v24 << 6) | (32 * v27) | (16 * v28) | (8 * v29) | (4 * v30) | (2 * v31);
      if (v25 > 1)
        ++v32;
      v14 = (v32 + 7) >> 3;
    }
LABEL_27:
    v38 = 0;
    v39 = 0;
    v37 = 0;
    v36 = 0;
    if (RSA_add_pkcs1_prefix(&v39, &v38, &v37, a1, a2, a3))
    {
      v33 = *(unsigned int (**)(_QWORD *, unint64_t *, char *, _QWORD, void *, size_t, uint64_t))(*a6 + 48);
      if (v33)
      {
        if (!v33(a6, &v36, a4, v14, v39, v38, 1))
          goto LABEL_34;
      }
      else if (!rsa_default_sign_raw(a6, &v36, a4, v14, v39, v38, 1))
      {
        goto LABEL_34;
      }
      if (!HIDWORD(v36))
      {
        *a5 = v36;
        v15 = 1;
        if (!v37)
          return v15;
        goto LABEL_35;
      }
      ERR_put_error(4, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c", 627);
    }
LABEL_34:
    v15 = 0;
    if (!v37)
      return v15;
LABEL_35:
    if (v39)
    {
      v35 = (char *)v39 - 8;
      v34 = *((_QWORD *)v39 - 1);
      if (v34 != -8)
        bzero((char *)v39 - 8, v34 + 8);
      free(v35);
    }
    return v15;
  }
  if (rsa_check_digest_size(a1, a3))
    return (*(uint64_t (**)(uint64_t, const void *, size_t, char *, _DWORD *, _QWORD *))(*a6 + 40))(a1, a2, a3, a4, a5, a6);
  return 0;
}

BOOL RSA_sign_pss_mgf1(uint64_t **a1, unint64_t *a2, char *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const EVP_MD *a8, unsigned int a9)
{
  unsigned int (*v16)(uint64_t **);
  size_t v17;
  _QWORD *v18;
  const char *v19;
  int v20;
  int v21;
  int v22;
  uint64_t *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  _BOOL8 v31;
  int v32;
  unint64_t v33;
  _BOOL4 v34;
  _BOOL4 v35;
  _BOOL4 v36;
  _BOOL4 v37;
  _BOOL4 v38;
  _BOOL4 v39;
  int v40;
  _QWORD *v41;
  const void *v42;
  uint64_t (*v43)(uint64_t **, unint64_t *, char *, unint64_t, const void *, size_t, uint64_t);
  int v44;
  size_t v45;

  if (*(_DWORD *)(a7 + 4) == a6)
  {
    v16 = (unsigned int (*)(uint64_t **))(*a1)[4];
    if (v16)
    {
      v17 = v16(a1);
      v18 = malloc_type_malloc(v17 + 8, 0x30772F57uLL);
      if (!v18)
      {
LABEL_12:
        v19 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
        v20 = 14;
        v21 = 65;
        v22 = 247;
        goto LABEL_13;
      }
    }
    else
    {
      v23 = a1[1];
      v24 = *((unsigned int *)v23 + 2);
      v25 = v24 & ((int)v24 >> 31);
      v26 = 8 * v24 - 8;
      v27 = *((_DWORD *)v23 + 2);
      while (1)
      {
        v28 = __OFSUB__(v27--, 1);
        if (v27 < 0 != v28)
          break;
        v29 = *v23;
        v30 = *(_QWORD *)(*v23 + v26);
        v26 -= 8;
        if (v30)
        {
          v25 = v27 + 1;
          goto LABEL_15;
        }
      }
      if ((v24 & 0x80000000) == 0)
      {
        v17 = 0;
        v18 = malloc_type_malloc(8uLL, 0x30772F57uLL);
        if (v18)
          goto LABEL_28;
        goto LABEL_12;
      }
      v29 = *v23;
LABEL_15:
      v32 = v25 - 1;
      v33 = *(_QWORD *)(v29 + 8 * v32);
      v34 = v33 != 0;
      v35 = HIDWORD(v33) != 0;
      if (HIDWORD(v33))
        v33 >>= 32;
      v36 = v33 >> 16 != 0;
      if (v33 >> 16)
        v33 >>= 16;
      v37 = v33 > 0xFF;
      if (v33 > 0xFF)
        v33 >>= 8;
      v38 = v33 > 0xF;
      if (v33 > 0xF)
        v33 >>= 4;
      v39 = v33 > 3;
      if (v33 > 3)
        v33 >>= 2;
      v40 = v34 | (v32 << 6) | (32 * v35) | (16 * v36) | (8 * v37) | (4 * v38) | (2 * v39);
      if (v33 > 1)
        ++v40;
      v17 = (v40 + 7) >> 3;
      v18 = malloc_type_malloc(v17 + 8, 0x30772F57uLL);
      if (!v18)
        goto LABEL_12;
    }
LABEL_28:
    v41 = v18;
    *v18 = v17;
    v42 = v18 + 1;
    if (RSA_padding_add_PKCS1_PSS_mgf1(a1, (unsigned __int8 *)v18 + 8, a5, a7, a8, a9))
    {
      v43 = (uint64_t (*)(uint64_t **, unint64_t *, char *, unint64_t, const void *, size_t, uint64_t))(*a1)[6];
      if (v43)
        v44 = v43(a1, a2, a3, a4, v42, v17, 3);
      else
        v44 = rsa_default_sign_raw(a1, a2, a3, a4, v42, v17, 3);
      v31 = v44 != 0;
      v45 = *v41 + 8;
      if (*v41 == -8)
        goto LABEL_36;
    }
    else
    {
      v31 = 0;
      v45 = *v41 + 8;
      if (*v41 == -8)
        goto LABEL_36;
    }
    bzero(v41, v45);
LABEL_36:
    free(v41);
    return v31;
  }
  v19 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cry"
        "pto/fipsmodule/rsa/rsa.c";
  v20 = 4;
  v21 = 125;
  v22 = 652;
LABEL_13:
  ERR_put_error(v20, 0, v21, v19, v22);
  return 0;
}

uint64_t rsa_verify_no_self_test(int a1, const void *a2, size_t a3, const unsigned __int8 *a4, const unsigned __int8 *a5, _QWORD *a6)
{
  uint64_t *v6;
  uint64_t (*v13)(_QWORD *);
  unsigned int v14;
  const char *v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  _BOOL4 v28;
  _BOOL4 v29;
  _BOOL4 v30;
  _BOOL4 v31;
  _BOOL4 v32;
  _BOOL4 v33;
  int v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  const void *v38;
  uint64_t v39;
  size_t v40;
  uint64_t v41;
  char *v42;
  int v44;
  const unsigned __int8 *v45;
  const unsigned __int8 *v46;
  void *__s2;

  v6 = (uint64_t *)a6[1];
  if (!v6 || !a6[2])
  {
    v15 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/rsa.c";
    v16 = 4;
    v17 = 144;
    v18 = 674;
LABEL_44:
    ERR_put_error(v16, 0, v17, v15, v18);
    return 0;
  }
  v13 = *(uint64_t (**)(_QWORD *))(*a6 + 32);
  if (v13)
  {
    v14 = v13(a6);
  }
  else
  {
    v19 = *((unsigned int *)v6 + 2);
    v20 = v19 & ((int)v19 >> 31);
    v21 = 8 * v19 - 8;
    v22 = *((_DWORD *)v6 + 2);
    while (1)
    {
      v23 = __OFSUB__(v22--, 1);
      if (v22 < 0 != v23)
        break;
      v24 = *v6;
      v25 = *(_QWORD *)(*v6 + v21);
      v21 -= 8;
      if (v25)
      {
        v20 = v22 + 1;
        goto LABEL_13;
      }
    }
    if ((v19 & 0x80000000) == 0)
    {
      v14 = 0;
      goto LABEL_26;
    }
    v24 = *v6;
LABEL_13:
    v26 = v20 - 1;
    v27 = *(_QWORD *)(v24 + 8 * (v20 - 1));
    v28 = v27 != 0;
    v29 = HIDWORD(v27) != 0;
    if (HIDWORD(v27))
      v27 >>= 32;
    v30 = v27 >> 16 != 0;
    if (v27 >> 16)
      v27 >>= 16;
    v31 = v27 > 0xFF;
    if (v27 > 0xFF)
      v27 >>= 8;
    v32 = v27 > 0xF;
    if (v27 > 0xF)
      v27 >>= 4;
    v33 = v27 > 3;
    if (v27 > 3)
      v27 >>= 2;
    v34 = v28 | (v26 << 6) | (32 * v29) | (16 * v30) | (8 * v31) | (4 * v32) | (2 * v33);
    if (v27 > 1)
      ++v34;
    v14 = (v34 + 7) >> 3;
  }
LABEL_26:
  v46 = 0;
  __s2 = 0;
  v45 = 0;
  v44 = 0;
  if (a1 == 114 && a3 != 36)
  {
    v15 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/rsa.c";
    v16 = 4;
    v17 = 125;
    v18 = 686;
    goto LABEL_44;
  }
  v35 = v14;
  v36 = malloc_type_malloc(v14 + 8, 0x30772F57uLL);
  if (!v36)
  {
    v15 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v16 = 14;
    v17 = 65;
    v18 = 247;
    goto LABEL_44;
  }
  v37 = v36;
  *v36 = v35;
  v38 = v36 + 1;
  if (rsa_verify_raw_no_self_test((uint64_t)a6, &v45, (unsigned __int8 *)v36 + 8, v35, a4, a5, 1)
    && RSA_add_pkcs1_prefix(&__s2, (size_t *)&v46, &v44, a1, a2, a3))
  {
    if (v45 == v46 && (!v45 || !memcmp(v38, __s2, (size_t)v45)))
    {
      v39 = 1;
      v40 = *v37 + 8;
      if (*v37 == -8)
        goto LABEL_38;
      goto LABEL_37;
    }
    ERR_put_error(4, 0, 105, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c", 706);
  }
  v39 = 0;
  v40 = *v37 + 8;
  if (*v37 != -8)
LABEL_37:
    bzero(v37, v40);
LABEL_38:
  free(v37);
  if (v44 && __s2)
  {
    v42 = (char *)__s2 - 8;
    v41 = *((_QWORD *)__s2 - 1);
    if (v41 != -8)
      bzero((char *)__s2 - 8, v41 + 8);
    free(v42);
  }
  return v39;
}

uint64_t RSA_verify_pss_mgf1(uint64_t **a1, uint64_t a2, uint64_t a3, const EVP_MD *a4, const EVP_MD *a5, int a6, const unsigned __int8 *a7, const unsigned __int8 *a8)
{
  uint64_t (*v15)(uint64_t **);
  unsigned int v16;
  const char *v17;
  int v18;
  int v19;
  int v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  _BOOL4 v31;
  _BOOL4 v32;
  _BOOL4 v33;
  _BOOL4 v34;
  _BOOL4 v35;
  _BOOL4 v36;
  int v37;
  unint64_t v38;
  char *v39;
  _QWORD *v40;
  unsigned __int8 *v41;
  const unsigned __int8 *v42;
  unsigned int (*v43)(uint64_t **);
  uint64_t v44;
  size_t v45;
  uint64_t *v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  unint64_t v54;
  _BOOL4 v55;
  _BOOL4 v56;
  _BOOL4 v57;
  _BOOL4 v58;
  _BOOL4 v59;
  _BOOL4 v60;
  int v61;
  unint64_t v63;

  if (a4->pkey_type == a3)
  {
    v15 = (uint64_t (*)(uint64_t **))(*a1)[4];
    if (v15)
    {
      v16 = v15(a1);
    }
    else
    {
      v21 = a1[1];
      v22 = *((unsigned int *)v21 + 2);
      v23 = v22 & ((int)v22 >> 31);
      v24 = 8 * v22 - 8;
      v25 = *((_DWORD *)v21 + 2);
      while (1)
      {
        v26 = __OFSUB__(v25--, 1);
        if (v25 < 0 != v26)
          break;
        v27 = *v21;
        v28 = *(_QWORD *)(*v21 + v24);
        v24 -= 8;
        if (v28)
        {
          v23 = v25 + 1;
          goto LABEL_12;
        }
      }
      if ((v22 & 0x80000000) == 0)
      {
        v16 = 0;
        goto LABEL_25;
      }
      v27 = *v21;
LABEL_12:
      v29 = v23 - 1;
      v30 = *(_QWORD *)(v27 + 8 * v29);
      v31 = v30 != 0;
      v32 = HIDWORD(v30) != 0;
      if (HIDWORD(v30))
        v30 >>= 32;
      v33 = v30 >> 16 != 0;
      if (v30 >> 16)
        v30 >>= 16;
      v34 = v30 > 0xFF;
      if (v30 > 0xFF)
        v30 >>= 8;
      v35 = v30 > 0xF;
      if (v30 > 0xF)
        v30 >>= 4;
      v36 = v30 > 3;
      if (v30 > 3)
        v30 >>= 2;
      v37 = v31 | (v29 << 6) | (32 * v32) | (16 * v33) | (8 * v34) | (4 * v35) | (2 * v36);
      if (v30 > 1)
        ++v37;
      v16 = (v37 + 7) >> 3;
    }
LABEL_25:
    v38 = v16;
    v63 = v16;
    v39 = (char *)malloc_type_malloc(v16 + 8, 0x30772F57uLL);
    if (v39)
    {
      v40 = v39;
      *(_QWORD *)v39 = v38;
      v41 = (unsigned __int8 *)(v39 + 8);
      if (!rsa_verify_raw_no_self_test((uint64_t)a1, (const unsigned __int8 **)&v63, (unsigned __int8 *)v39 + 8, v38, a7, a8, 3))
      {
        v44 = 0;
        v45 = *v40 + 8;
        if (*v40 == -8)
          goto LABEL_58;
        goto LABEL_57;
      }
      v42 = (const unsigned __int8 *)v63;
      v43 = (unsigned int (*)(uint64_t **))(*a1)[4];
      if (v43)
      {
        if (v42 != (const unsigned __int8 *)v43(a1))
        {
LABEL_40:
          ERR_put_error(4, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c", 747);
          v44 = 0;
          v45 = *v40 + 8;
          if (*v40 == -8)
            goto LABEL_58;
          goto LABEL_57;
        }
      }
      else
      {
        v46 = a1[1];
        v47 = *((unsigned int *)v46 + 2);
        v48 = v47 & ((int)v47 >> 31);
        v49 = 8 * v47 - 8;
        v50 = *((_DWORD *)v46 + 2);
        while (1)
        {
          v26 = __OFSUB__(v50--, 1);
          if (v50 < 0 != v26)
            break;
          v51 = *v46;
          v52 = *(_QWORD *)(*v46 + v49);
          v49 -= 8;
          if (v52)
          {
            v48 = v50 + 1;
            goto LABEL_43;
          }
        }
        if ((v47 & 0x80000000) == 0)
        {
          if (!v63)
            goto LABEL_56;
          goto LABEL_40;
        }
        v51 = *v46;
LABEL_43:
        v53 = v48 - 1;
        v54 = *(_QWORD *)(v51 + 8 * v53);
        v55 = v54 != 0;
        v56 = HIDWORD(v54) != 0;
        if (HIDWORD(v54))
          v54 >>= 32;
        v57 = v54 >> 16 != 0;
        if (v54 >> 16)
          v54 >>= 16;
        v58 = v54 > 0xFF;
        if (v54 > 0xFF)
          v54 >>= 8;
        v59 = v54 > 0xF;
        if (v54 > 0xF)
          v54 >>= 4;
        v60 = v54 > 3;
        if (v54 > 3)
          v54 >>= 2;
        v61 = v55 | (v53 << 6) | (32 * v56) | (16 * v57) | (8 * v58) | (4 * v59) | (2 * v60);
        if (v54 > 1)
          ++v61;
        if (v63 != (v61 + 7) >> 3)
          goto LABEL_40;
      }
LABEL_56:
      v44 = RSA_verify_PKCS1_PSS_mgf1(a1, a2, a4, a5, v41, a6);
      v45 = *v40 + 8;
      if (*v40 == -8)
      {
LABEL_58:
        free(v40);
        return v44;
      }
LABEL_57:
      bzero(v40, v45);
      goto LABEL_58;
    }
    v17 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v18 = 14;
    v19 = 65;
    v20 = 247;
  }
  else
  {
    v17 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/rsa.c";
    v18 = 4;
    v19 = 125;
    v20 = 731;
  }
  ERR_put_error(v18, 0, v19, v17, v20);
  return 0;
}

uint64_t check_mod_inverse(_BOOL4 *a1, uint64_t a2, uint64_t a3, BIGNUM *a4, int a5, BN_CTX *ctx)
{
  uint64_t result;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  BIGNUM *v20;
  _BOOL4 v21;
  uint64_t top;
  unint64_t *d;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  int8x16_t v27;
  unsigned __int128 v28;
  int8x16_t *v29;
  unint64_t v30;
  int8x16_t v31;
  uint64_t v32;
  unint64_t *v33;
  uint64_t v34;

  if (*(_DWORD *)(a3 + 16)
    || a4 && (a4->neg || (int)bn_cmp_words_consttime(*(uint64_t **)a3, *(int *)(a3 + 8), (uint64_t *)a4->d, a4->top) >= 0))
  {
    *a1 = 0;
    return 1;
  }
  if (*((_BYTE *)ctx + 40))
  {
LABEL_23:
    result = (uint64_t)BN_CTX_get(ctx);
    if (!result)
      goto LABEL_27;
LABEL_24:
    if (*(_DWORD *)(a2 + 16) || *(_DWORD *)(a3 + 16))
    {
      ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/mul.c", 524);
      result = 0;
      goto LABEL_27;
    }
    v20 = (BIGNUM *)result;
    result = bn_mul_impl(result, a2, a3, ctx);
    if (!(_DWORD)result)
      goto LABEL_27;
    result = bn_div_consttime(0, v20, v20, a4, a5, ctx);
    if (!(_DWORD)result)
      goto LABEL_27;
    if (v20->neg)
    {
      v21 = 0;
LABEL_46:
      *a1 = v21;
      result = 1;
      goto LABEL_27;
    }
    top = v20->top;
    if ((_DWORD)top)
    {
      d = v20->d;
      v24 = *v20->d ^ 1;
      if ((int)top >= 2)
      {
        if (top >= 5)
        {
          v26 = (top - 1) & 0xFFFFFFFFFFFFFFFCLL;
          v25 = v26 | 1;
          v27 = 0uLL;
          v28 = *v20->d ^ (unsigned __int128)1uLL;
          v29 = (int8x16_t *)(d + 3);
          v30 = v26;
          do
          {
            v28 = (unsigned __int128)vorrq_s8(v29[-1], (int8x16_t)v28);
            v27 = vorrq_s8(*v29, v27);
            v29 += 2;
            v30 -= 4;
          }
          while (v30);
          v31 = vorrq_s8(v27, (int8x16_t)v28);
          v24 = (uint64_t)vorr_s8(*(int8x8_t *)v31.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
          if (top - 1 == v26)
            goto LABEL_45;
        }
        else
        {
          v25 = 1;
        }
        v32 = top - v25;
        v33 = &d[v25];
        do
        {
          v34 = *v33++;
          v24 |= v34;
          --v32;
        }
        while (v32);
      }
    }
    else
    {
      v24 = 1;
    }
LABEL_45:
    v21 = v24 == 0;
    goto LABEL_46;
  }
  v13 = *((_QWORD *)ctx + 4);
  v14 = *((_QWORD *)ctx + 2);
  if (v14 != *((_QWORD *)ctx + 3))
  {
    v17 = (_QWORD *)*((_QWORD *)ctx + 1);
    goto LABEL_22;
  }
  if (v14)
    v15 = (3 * v14) >> 1;
  else
    v15 = 32;
  if (v15 > v14 && v15 >> 61 == 0)
  {
    v17 = OPENSSL_realloc(*((_QWORD **)ctx + 1), 8 * v15);
    if (v17)
    {
      *((_QWORD *)ctx + 1) = v17;
      *((_QWORD *)ctx + 3) = v15;
      v14 = *((_QWORD *)ctx + 2);
LABEL_22:
      v17[v14] = v13;
      ++*((_QWORD *)ctx + 2);
      goto LABEL_23;
    }
  }
  *((_WORD *)ctx + 20) = 257;
  result = (uint64_t)BN_CTX_get(ctx);
  if (result)
    goto LABEL_24;
LABEL_27:
  if (!*((_BYTE *)ctx + 40))
  {
    v18 = *((_QWORD *)ctx + 1);
    v19 = *((_QWORD *)ctx + 2) - 1;
    *((_QWORD *)ctx + 2) = v19;
    *((_QWORD *)ctx + 4) = *(_QWORD *)(v18 + 8 * v19);
  }
  return result;
}

uint64_t RSA_check_fips(RSA *a1)
{
  char *v2;
  BN_CTX *v3;
  const RSA_METHOD *meth;
  uint64_t rsa_pub_enc_low;
  int v6;
  uint64_t v7;
  int rsa_pub_enc;
  BOOL v9;
  const char *name;
  uint64_t v11;
  int v12;
  const char *v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  _BOOL4 v20;
  _BOOL4 v21;
  _BOOL4 v22;
  _BOOL4 v23;
  _BOOL4 v24;
  _BOOL4 v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  unint64_t v31;
  _BOOL4 v32;
  _BOOL4 v33;
  _BOOL4 v34;
  _BOOL4 v35;
  _BOOL4 v36;
  _BOOL4 v37;
  unsigned int v38;
  BIGNUM *version;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  int8x16_t v43;
  unsigned __int128 v44;
  int8x16_t *v45;
  unint64_t v46;
  int8x16_t v47;
  uint64_t v48;
  unint64_t *v49;
  uint64_t v50;
  char v52;
  char flags;
  uint64_t v54;
  unint64_t *v55;
  uint64_t (*v56)(RSA *);
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  unint64_t v66;
  _BOOL4 v67;
  _BOOL4 v68;
  _BOOL4 v69;
  _BOOL4 v70;
  _BOOL4 v71;
  _BOOL4 v72;
  int v73;
  uint64_t v74;
  char *v75;
  _QWORD *v76;
  const unsigned __int8 *v77;
  int v79;
  uint64_t v80;
  BIGNUM a;
  int n[4];
  __int128 v83;
  uint64_t v84;

  v84 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)&a1->pad && (*(_BYTE *)(*(_QWORD *)&a1->pad + 72) & 1) != 0)
  {
    v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/rsa.c";
    v14 = 4;
    v15 = 146;
    v16 = 939;
LABEL_106:
    ERR_put_error(v14, 0, v15, v13, v16);
    return 0;
  }
  if (!RSA_check_key(a1))
    return 0;
  v2 = (char *)malloc_type_malloc(0x38uLL, 0x30772F57uLL);
  if (!v2)
  {
LABEL_105:
    v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v14 = 14;
    v15 = 65;
    v16 = 247;
    goto LABEL_106;
  }
  *(_QWORD *)v2 = 48;
  *(_OWORD *)(v2 + 8) = 0u;
  v3 = (BN_CTX *)(v2 + 8);
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 34) = 0u;
  memset(&a, 0, sizeof(a));
  HIDWORD(v80) = 0;
  meth = a1->meth;
  rsa_pub_enc_low = LODWORD(meth->rsa_pub_enc);
  v6 = rsa_pub_enc_low & ((int)rsa_pub_enc_low >> 31);
  v7 = 8 * rsa_pub_enc_low - 8;
  rsa_pub_enc = (int)meth->rsa_pub_enc;
  while (1)
  {
    v9 = __OFSUB__(rsa_pub_enc--, 1);
    if (rsa_pub_enc < 0 != v9)
      break;
    name = meth->name;
    v11 = *(_QWORD *)&meth->name[v7];
    v7 -= 8;
    if (v11)
    {
      v12 = rsa_pub_enc + 1;
      goto LABEL_13;
    }
  }
  if ((rsa_pub_enc_low & 0x80000000) == 0)
    goto LABEL_66;
  name = meth->name;
  v12 = rsa_pub_enc_low & ((int)rsa_pub_enc_low >> 31);
LABEL_13:
  v18 = v12 - 1;
  v19 = *(_QWORD *)&name[8 * v18];
  v20 = v19 != 0;
  v21 = HIDWORD(v19) != 0;
  if (HIDWORD(v19))
    v19 >>= 32;
  v22 = v19 >> 16 != 0;
  if (v19 >> 16)
    v19 >>= 16;
  v23 = v19 > 0xFF;
  if (v19 > 0xFF)
    v19 >>= 8;
  v24 = v19 > 0xF;
  if (v19 > 0xF)
    v19 >>= 4;
  v25 = v19 > 3;
  if (v19 > 3)
    v19 >>= 2;
  v26 = v20 | (v18 << 6) | (32 * v21) | (16 * v22) | (8 * v23) | (4 * v24) | (2 * v25);
  if (v19 > 1)
    ++v26;
  if (v26 < 0x11)
  {
LABEL_66:
    ERR_put_error(4, 0, 146, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c", 974);
    v17 = 0;
    v52 = 1;
    flags = a.flags;
    if ((a.flags & 2) == 0)
    {
LABEL_67:
      if (a.d)
      {
        v55 = a.d - 1;
        v54 = *(a.d - 1);
        if (v54 != -8)
          bzero(a.d - 1, v54 + 8);
        free(v55);
        flags = a.flags;
      }
    }
    goto LABEL_71;
  }
  v27 = 8 * rsa_pub_enc_low - 8;
  v28 = rsa_pub_enc_low;
  while (1)
  {
    v9 = __OFSUB__(v28--, 1);
    if (v28 < 0 != v9)
      break;
    v29 = *(_QWORD *)&name[v27];
    v27 -= 8;
    if (v29)
    {
      v6 = v28 + 1;
      goto LABEL_31;
    }
  }
  if ((rsa_pub_enc_low & 0x80000000) == 0)
    goto LABEL_44;
LABEL_31:
  v30 = v6 - 1;
  v31 = *(_QWORD *)&name[8 * v30];
  v32 = v31 != 0;
  v33 = HIDWORD(v31) != 0;
  if (HIDWORD(v31))
    v31 >>= 32;
  v34 = v31 >> 16 != 0;
  if (v31 >> 16)
    v31 >>= 16;
  v35 = v31 > 0xFF;
  if (v31 > 0xFF)
    v31 >>= 8;
  v36 = v31 > 0xF;
  if (v31 > 0xF)
    v31 >>= 4;
  v37 = v31 > 3;
  if (v31 > 3)
    v31 >>= 2;
  v38 = v32 | (v30 << 6) | (32 * v33) | (16 * v34) | (8 * v35) | (4 * v36) | (2 * v37);
  if (v31 > 1)
    ++v38;
  if (v38 > 0x100)
    goto LABEL_66;
LABEL_44:
  version = (BIGNUM *)a1->version;
  if (version->top < 1 || (*(_BYTE *)version->d & 1) == 0 || (int)rsa_pub_enc_low < 1 || (*name & 1) == 0)
    goto LABEL_66;
  if (pthread_once(&g_small_factors_once, (void (*)(void))g_small_factors_init))
    abort();
  n[0] = 0;
  if (!bn_gcd_consttime((uint64_t)&a, n, version, (BIGNUM *)&g_small_factors_storage, v3)
    || !BN_lshift(&a, &a, n[0])
    || a.neg
    || !a.top)
  {
    goto LABEL_66;
  }
  v40 = *a.d ^ 1;
  if (a.top >= 2)
  {
    if (a.top < 5u)
    {
      v41 = 1;
LABEL_59:
      v48 = a.top - v41;
      v49 = &a.d[v41];
      do
      {
        v50 = *v49++;
        v40 |= v50;
        --v48;
      }
      while (v48);
      goto LABEL_61;
    }
    v42 = (a.top - 1) & 0xFFFFFFFFFFFFFFFCLL;
    v41 = v42 | 1;
    v43 = 0uLL;
    v44 = *a.d ^ (unsigned __int128)1uLL;
    v45 = (int8x16_t *)(a.d + 3);
    v46 = v42;
    do
    {
      v44 = (unsigned __int128)vorrq_s8(v45[-1], (int8x16_t)v44);
      v43 = vorrq_s8(*v45, v43);
      v45 += 2;
      v46 -= 4;
    }
    while (v46);
    v47 = vorrq_s8(v43, (int8x16_t)v44);
    v40 = (unint64_t)vorr_s8(*(int8x8_t *)v47.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL));
    if (a.top - 1 != v42)
      goto LABEL_59;
  }
LABEL_61:
  if (v40)
    goto LABEL_66;
  if (!BN_enhanced_miller_rabin_primality_test((int *)&v80 + 1, (const BIGNUM *)a1->version, 0, (uint64_t)v3, 0)|| HIDWORD(v80) != 2)
  {
    goto LABEL_66;
  }
  v52 = 0;
  v17 = 1;
  flags = a.flags;
  if ((a.flags & 2) == 0)
    goto LABEL_67;
LABEL_71:
  if ((flags & 1) == 0)
  {
    a.d = 0;
    BN_CTX_free(v3);
    if ((v52 & 1) != 0)
      return v17;
LABEL_77:
    if (!a1->engine || !a1->n)
      return v17;
    *(_OWORD *)n = 0u;
    v83 = 0u;
    v56 = *(uint64_t (**)(RSA *))(*(_QWORD *)&a1->pad + 32);
    if (v56)
    {
      v57 = v56(a1);
    }
    else
    {
      v58 = a1->version;
      v59 = *(unsigned int *)(v58 + 8);
      v60 = v59 & ((int)v59 >> 31);
      v61 = 8 * v59 - 8;
      v62 = *(_DWORD *)(v58 + 8);
      while (1)
      {
        v9 = __OFSUB__(v62--, 1);
        if (v62 < 0 != v9)
          break;
        v63 = *(_QWORD *)v58;
        v64 = *(_QWORD *)(*(_QWORD *)v58 + v61);
        v61 -= 8;
        if (v64)
        {
          v60 = v62 + 1;
          goto LABEL_88;
        }
      }
      if ((v59 & 0x80000000) == 0)
      {
        v57 = 0;
        goto LABEL_101;
      }
      v63 = *(_QWORD *)v58;
LABEL_88:
      v65 = v60 - 1;
      v66 = *(_QWORD *)(v63 + 8 * v65);
      v67 = v66 != 0;
      v68 = HIDWORD(v66) != 0;
      if (HIDWORD(v66))
        v66 >>= 32;
      v69 = v66 >> 16 != 0;
      if (v66 >> 16)
        v66 >>= 16;
      v70 = v66 > 0xFF;
      if (v66 > 0xFF)
        v66 >>= 8;
      v71 = v66 > 0xF;
      if (v66 > 0xF)
        v66 >>= 4;
      v72 = v66 > 3;
      if (v66 > 3)
        v66 >>= 2;
      v73 = v67 | (v65 << 6) | (32 * v68) | (16 * v69) | (8 * v70) | (4 * v71) | (2 * v72);
      if (v66 > 1)
        ++v73;
      v57 = (v73 + 7) >> 3;
    }
LABEL_101:
    LODWORD(v80) = v57;
    v74 = v57;
    v75 = (char *)malloc_type_malloc(v57 + 8, 0x30772F57uLL);
    if (v75)
    {
      v76 = v75;
      *(_QWORD *)v75 = v74;
      v77 = (const unsigned __int8 *)(v75 + 8);
      if (rsa_sign_no_self_test(672, n, 0x20uLL, v75 + 8, &v80, a1))
      {
        if (rsa_verify_no_self_test(672, n, 0x20uLL, v77, (const unsigned __int8 *)v80, a1))
        {
          v17 = 1;
LABEL_111:
          if (*v76 != -8)
            bzero(v76, *v76 + 8);
          free(v76);
          return v17;
        }
        v79 = 1007;
      }
      else
      {
        v79 = 999;
      }
      ERR_put_error(4, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa.c", v79);
      v17 = 0;
      goto LABEL_111;
    }
    goto LABEL_105;
  }
  if (v80 != -8)
    __memset_chk();
  free(&v80);
  BN_CTX_free(v3);
  if ((v52 & 1) == 0)
    goto LABEL_77;
  return v17;
}

double g_small_factors_init()
{
  double result;

  g_small_factors_storage = (uint64_t)&kSmallFactorsLimbs;
  *(_QWORD *)&result = 0x1100000011;
  unk_254541CD8 = xmmword_208F301E0;
  return result;
}

RSA *RSA_parse_public_key(unsigned __int8 **a1)
{
  RSA *v2;
  char *v3;
  char *v4;
  int v5;
  int v6;
  unsigned __int8 *v8;
  unint64_t v9;
  int v10;
  unint64_t v11;

  v2 = RSA_new_method(0);
  if (!v2)
    return v2;
  v8 = 0;
  v9 = 0;
  v11 = 0;
  v10 = 0;
  if (!cbs_get_any_asn1_element(a1, &v8, &v10, &v11, 0, 0, 0) || v10 != 536870928 || v9 < v11)
    goto LABEL_14;
  v8 += v11;
  v9 -= v11;
  v3 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v3)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v2->version = 0;
    goto LABEL_14;
  }
  *(_QWORD *)v3 = 24;
  *((_QWORD *)v3 + 2) = 0;
  *((_QWORD *)v3 + 3) = 0x100000000;
  *((_QWORD *)v3 + 1) = 0;
  v2->version = (uint64_t)(v3 + 8);
  if (!BN_parse_asn1_unsigned(&v8, (BIGNUM *)(v3 + 8)))
  {
LABEL_14:
    v5 = 100;
    v6 = 100;
    goto LABEL_15;
  }
  v4 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v4)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v2->meth = 0;
    goto LABEL_14;
  }
  *(_QWORD *)v4 = 24;
  *((_QWORD *)v4 + 2) = 0;
  *((_QWORD *)v4 + 3) = 0x100000000;
  *((_QWORD *)v4 + 1) = 0;
  v2->meth = (const RSA_METHOD *)(v4 + 8);
  if (!BN_parse_asn1_unsigned(&v8, (BIGNUM *)(v4 + 8)) || v9)
    goto LABEL_14;
  if (!RSA_check_key(v2))
  {
    v5 = 104;
    v6 = 106;
LABEL_15:
    ERR_put_error(4, 0, v5, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_asn1.c", v6);
    RSA_free(v2);
    return 0;
  }
  return v2;
}

uint64_t RSA_marshal_public_key(uint64_t *a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t *v5;
  _OWORD v7[3];
  _BYTE *v8;

  memset(v7, 0, sizeof(v7));
  if (!CBB_flush(a1))
    goto LABEL_11;
  v8 = 0;
  if (!CBB_add_space((uint64_t)a1, &v8, 1))
    goto LABEL_11;
  *v8 = 48;
  if (!cbb_add_child((uint64_t)a1, (uint64_t)v7, 1u, 1))
    goto LABEL_11;
  v4 = *(uint64_t **)(a2 + 8);
  if (!v4)
    goto LABEL_10;
  if (!BN_marshal_asn1((uint64_t *)v7, v4))
    goto LABEL_11;
  v5 = *(uint64_t **)(a2 + 16);
  if (!v5)
  {
LABEL_10:
    ERR_put_error(4, 0, 144, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_asn1.c", 84);
    goto LABEL_11;
  }
  if (BN_marshal_asn1((uint64_t *)v7, v5) && CBB_flush(a1))
    return 1;
LABEL_11:
  ERR_put_error(4, 0, 121, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_asn1.c", 132);
  return 0;
}

uint64_t marshal_integer(uint64_t *a1, uint64_t *a2)
{
  if (a2)
    return BN_marshal_asn1(a1, a2);
  ERR_put_error(4, 0, 144, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_asn1.c", 84);
  return 0;
}

RSA *RSA_parse_private_key(unsigned __int8 **a1)
{
  RSA *v2;
  int v3;
  int v4;
  char *v6;
  char *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  unint64_t v10;
  unsigned __int8 *v11;
  unint64_t v12;
  int v13;
  unint64_t v14;

  v2 = RSA_new_method(0);
  if (v2)
  {
    v11 = 0;
    v12 = 0;
    v10 = 0;
    v14 = 0;
    v13 = 0;
    if (cbs_get_any_asn1_element(a1, &v11, &v13, &v14, 0, 0, 0)
      && v13 == 536870928
      && v12 >= v14
      && (v11 += v14, v12 -= v14, CBS_get_asn1_uint64(&v11, &v10)))
    {
      if (v10)
      {
        v3 = 106;
        v4 = 171;
      }
      else
      {
        v6 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
        if (!v6)
        {
          ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
          v2->version = 0;
          goto LABEL_10;
        }
        *(_QWORD *)v6 = 24;
        *((_QWORD *)v6 + 2) = 0;
        *((_QWORD *)v6 + 3) = 0x100000000;
        *((_QWORD *)v6 + 1) = 0;
        v2->version = (uint64_t)(v6 + 8);
        if (!BN_parse_asn1_unsigned(&v11, (BIGNUM *)(v6 + 8)))
        {
LABEL_10:
          RSA_free(v2);
          return 0;
        }
        v7 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
        if (!v7)
        {
          ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
          v2->meth = 0;
          goto LABEL_10;
        }
        *(_QWORD *)v7 = 24;
        *((_QWORD *)v7 + 2) = 0;
        *((_QWORD *)v7 + 3) = 0x100000000;
        *((_QWORD *)v7 + 1) = 0;
        v2->meth = (const RSA_METHOD *)(v7 + 8);
        if (!BN_parse_asn1_unsigned(&v11, (BIGNUM *)(v7 + 8)))
          goto LABEL_10;
        v8 = BN_new();
        v2->engine = (ENGINE *)v8;
        if (!v8)
          goto LABEL_10;
        if (!BN_parse_asn1_unsigned(&v11, v8))
          goto LABEL_10;
        v9 = BN_new();
        v2->n = v9;
        if (!v9
          || !BN_parse_asn1_unsigned(&v11, v9)
          || !parse_integer(&v11, &v2->e)
          || !parse_integer(&v11, &v2->d)
          || !parse_integer(&v11, &v2->p)
          || !parse_integer(&v11, &v2->q))
        {
          goto LABEL_10;
        }
        if (v12)
        {
          v3 = 100;
          v4 = 187;
        }
        else
        {
          if (RSA_check_key(v2))
            return v2;
          v3 = 104;
          v4 = 192;
        }
      }
    }
    else
    {
      v3 = 100;
      v4 = 166;
    }
    ERR_put_error(4, 0, v3, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_asn1.c", v4);
    goto LABEL_10;
  }
  return v2;
}

uint64_t RSA_marshal_private_key(uint64_t *a1, uint64_t **a2)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  _OWORD v12[3];
  _BYTE *v13;

  memset(v12, 0, sizeof(v12));
  if (!CBB_flush(a1))
    goto LABEL_23;
  v13 = 0;
  if (!CBB_add_space((uint64_t)a1, &v13, 1))
    goto LABEL_23;
  *v13 = 48;
  if (!cbb_add_child((uint64_t)a1, (uint64_t)v12, 1u, 1)
    || !CBB_add_asn1_uint64_with_tag((uint64_t)v12, 0, 2))
  {
    goto LABEL_23;
  }
  v4 = a2[1];
  if (!v4)
    goto LABEL_22;
  if (!BN_marshal_asn1((uint64_t *)v12, v4))
    goto LABEL_23;
  v5 = a2[2];
  if (!v5)
    goto LABEL_22;
  if (!BN_marshal_asn1((uint64_t *)v12, v5))
    goto LABEL_23;
  v6 = a2[3];
  if (!v6)
    goto LABEL_22;
  if (!BN_marshal_asn1((uint64_t *)v12, v6))
    goto LABEL_23;
  v7 = a2[4];
  if (!v7)
    goto LABEL_22;
  if (!BN_marshal_asn1((uint64_t *)v12, v7))
    goto LABEL_23;
  v8 = a2[5];
  if (!v8)
    goto LABEL_22;
  if (!BN_marshal_asn1((uint64_t *)v12, v8))
    goto LABEL_23;
  v9 = a2[6];
  if (!v9)
    goto LABEL_22;
  if (!BN_marshal_asn1((uint64_t *)v12, v9))
    goto LABEL_23;
  v10 = a2[7];
  if (!v10)
  {
LABEL_22:
    ERR_put_error(4, 0, 144, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_asn1.c", 84);
    goto LABEL_23;
  }
  if (BN_marshal_asn1((uint64_t *)v12, v10)
    && marshal_integer((uint64_t *)v12, a2[8])
    && CBB_flush(a1))
  {
    return 1;
  }
LABEL_23:
  ERR_put_error(4, 0, 121, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_asn1.c", 228);
  return 0;
}

uint64_t RSA_padding_add_PKCS1_OAEP_mgf1(_BYTE *a1, unint64_t a2, const void *a3, size_t a4, void *data, size_t count, EVP_MD *type, EVP_MD *a8)
{
  EVP_MD *v15;
  unint64_t pkey_type;
  uint64_t v17;
  const char *v18;
  int v19;
  int v20;
  int v21;
  unint64_t v22;
  uint64_t v23;
  const unsigned __int8 *v24;
  _BYTE *v25;
  const void *v26;
  const unsigned __int8 *v27;
  unint64_t v28;
  void *v29;
  _QWORD *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  _BYTE *v35;
  char *v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  int8x16_t *v41;
  int8x16_t *v42;
  uint64_t v43;
  int8x16_t v44;
  uint64_t v45;
  unsigned __int8 *v46;
  int8x8_t *v47;
  uint64_t v48;
  int8x8_t v49;
  uint64_t v50;
  _BYTE *v51;
  unsigned __int8 *v52;
  char v53;
  int8x16_t *v54;
  int8x16_t *v55;
  unint64_t v56;
  int8x16_t v57;
  unint64_t v58;
  int8x8_t *v59;
  int8x8_t *v60;
  unint64_t v61;
  int8x8_t v62;
  _BYTE *v63;
  EVP_MD *dgst;
  unsigned __int8 mask[16];
  _QWORD v66[7];

  v66[6] = *MEMORY[0x24BDAC8D0];
  if (!type)
  {
    if (pthread_once(&EVP_sha1_once, (void (*)(void))EVP_sha1_init))
      abort();
    type = (EVP_MD *)&EVP_sha1_storage;
  }
  if (a8)
    v15 = a8;
  else
    v15 = type;
  pkey_type = type->pkey_type;
  v17 = 2 * pkey_type;
  if (2 * pkey_type + 2 > a2)
  {
    v18 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/rsa_extra/rsa_crypt.c";
    v19 = 4;
    v20 = 126;
    v21 = 100;
LABEL_36:
    ERR_put_error(v19, 0, v20, v18, v21);
    return 0;
  }
  v22 = a2 - 1;
  v23 = ~v17;
  if (a2 - 1 + ~v17 < a4)
  {
    v18 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/rsa_extra/rsa_crypt.c";
    v19 = 4;
    v20 = 114;
    v21 = 106;
    goto LABEL_36;
  }
  if (v22 < (v17 | 1uLL))
  {
    v18 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/rsa_extra/rsa_crypt.c";
    v19 = 4;
    v20 = 126;
    v21 = 111;
    goto LABEL_36;
  }
  v63 = a1;
  dgst = v15;
  *a1 = 0;
  v24 = a1 + 1;
  v25 = &a1[pkey_type];
  v26 = data;
  v27 = v25 + 1;
  if (!EVP_Digest(v26, count, v25 + 1, 0, type, 0))
    return 0;
  if (v22 - a4 + v23)
    bzero((void *)&v27[pkey_type], v22 - a4 + v23);
  v27[v22 - a4 + ~pkey_type] = 1;
  if (a4)
    memcpy(&v25[a2 - a4 - pkey_type], a3, a4);
  RAND_bytes_with_additional_data((uint64_t)v24, pkey_type, (uint64_t)&RAND_bytes_kZeroAdditionalData);
  v28 = v22 - pkey_type;
  if (v22 - pkey_type > 0xFFFFFFFFFFFFFFF7 || (v29 = malloc_type_malloc(v28 + 8, 0x30772F57uLL)) == 0)
  {
    v18 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v19 = 14;
    v20 = 65;
    v21 = 247;
    goto LABEL_36;
  }
  v30 = v29;
  *(_QWORD *)v29 = v28;
  v31 = (unint64_t)v29 + 8;
  if (!PKCS1_MGF1((unsigned __int8 *)v29 + 8, v22 - pkey_type, v24, pkey_type, dgst))
    goto LABEL_39;
  if (v22 != pkey_type)
  {
    if (v28 <= 1)
      v32 = 1;
    else
      v32 = v22 - pkey_type;
    if (v32 < 8 || v27 < (const unsigned __int8 *)v30 + v32 + 8 && v31 < (unint64_t)&v63[v32 + 1 + pkey_type])
    {
      v33 = 0;
      goto LABEL_29;
    }
    if (v32 >= 0x20)
    {
      v33 = v32 & 0xFFFFFFFFFFFFFFE0;
      v54 = (int8x16_t *)(v30 + 3);
      v55 = (int8x16_t *)&v63[pkey_type + 17];
      v56 = v32 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v57 = veorq_s8(*v55, *v54);
        v55[-1] = veorq_s8(v55[-1], v54[-1]);
        *v55 = v57;
        v54 += 2;
        v55 += 2;
        v56 -= 32;
      }
      while (v56);
      if (v32 == v33)
        goto LABEL_31;
      if ((v32 & 0x18) == 0)
      {
LABEL_29:
        v34 = v32 - v33;
        v35 = &v63[v33 + 1 + pkey_type];
        v36 = (char *)v30 + v33 + 8;
        do
        {
          v37 = *v36++;
          *v35++ ^= v37;
          --v34;
        }
        while (v34);
        goto LABEL_31;
      }
    }
    else
    {
      v33 = 0;
    }
    v58 = v33;
    v33 = v32 & 0xFFFFFFFFFFFFFFF8;
    v59 = (int8x8_t *)((char *)v30 + v58 + 8);
    v60 = (int8x8_t *)&v63[v58 + 1 + pkey_type];
    v61 = v58 - (v32 & 0xFFFFFFFFFFFFFFF8);
    do
    {
      v62 = *v59++;
      *v60 = veor_s8(*v60, v62);
      ++v60;
      v61 += 8;
    }
    while (v61);
    if (v32 != v33)
      goto LABEL_29;
  }
LABEL_31:
  if (PKCS1_MGF1(mask, pkey_type, v27, v22 - pkey_type, dgst))
  {
    if (!(_DWORD)pkey_type)
    {
LABEL_53:
      v39 = 1;
      goto LABEL_54;
    }
    if (pkey_type < 8)
    {
      v38 = 0;
LABEL_51:
      v50 = pkey_type - v38;
      v51 = &v63[v38 + 1];
      v52 = &mask[v38];
      do
      {
        v53 = *v52++;
        *v51++ ^= v53;
        --v50;
      }
      while (v50);
      goto LABEL_53;
    }
    if (pkey_type >= 0x20)
    {
      v38 = pkey_type & 0xFFFFFFE0;
      v41 = (int8x16_t *)v66;
      v42 = (int8x16_t *)(v63 + 17);
      v43 = v38;
      do
      {
        v44 = veorq_s8(*v42, *v41);
        v42[-1] = veorq_s8(v42[-1], v41[-1]);
        *v42 = v44;
        v41 += 2;
        v42 += 2;
        v43 -= 32;
      }
      while (v43);
      if (v38 == pkey_type)
        goto LABEL_53;
      if ((pkey_type & 0x18) == 0)
        goto LABEL_51;
    }
    else
    {
      v38 = 0;
    }
    v45 = v38;
    v38 = pkey_type & 0xFFFFFFF8;
    v46 = &mask[v45];
    v47 = (int8x8_t *)&v63[v45 + 1];
    v48 = v45 - v38;
    do
    {
      v49 = *(int8x8_t *)v46;
      v46 += 8;
      *v47 = veor_s8(*v47, v49);
      ++v47;
      v48 += 8;
    }
    while (v48);
    if (v38 == pkey_type)
      goto LABEL_53;
    goto LABEL_51;
  }
LABEL_39:
  v39 = 0;
LABEL_54:
  if (*v30 != -8)
    bzero(v30, *v30 + 8);
  free(v30);
  return v39;
}

uint64_t RSA_padding_check_PKCS1_OAEP_mgf1(void *a1, unint64_t *a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, const void *a6, size_t a7, const EVP_MD *a8, const EVP_MD *a9)
{
  const EVP_MD *v9;
  const EVP_MD *v17;
  unint64_t pkey_type;
  unint64_t v19;
  _QWORD *v20;
  unsigned __int8 *v21;
  uint64_t v22;
  int8x16_t *v23;
  int8x16_t *v24;
  uint64_t v25;
  int8x16_t v26;
  uint64_t v27;
  int8x8_t *v28;
  int8x8_t *v29;
  uint64_t v30;
  int8x8_t v31;
  uint64_t v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  char v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  _BYTE *v39;
  unsigned __int8 *v40;
  char v41;
  uint64_t v43;
  unsigned __int8 v44;
  uint64_t v45;
  int8x16_t *v46;
  int8x16_t *v47;
  int8x16_t v48;
  uint64_t v49;
  int8x16_t v50;
  int8x16_t v51;
  unint64_t v52;
  uint64_t v53;
  int8x8_t v54;
  int8x8_t *v55;
  unsigned __int8 *v56;
  uint64_t v57;
  int8x8_t v58;
  int8x8_t v59;
  int8x8_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned __int8 *v63;
  char *v64;
  char v65;
  char v66;
  char v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  void *v78;
  int8x16_t *v80;
  int8x16_t *v81;
  unint64_t v82;
  int8x16_t v83;
  unint64_t v84;
  int8x8_t *v85;
  int8x8_t *v86;
  unint64_t v87;
  int8x8_t v88;
  void *__dst;
  _QWORD *v90;
  unint64_t v91;
  unsigned __int8 md[16];
  uint64_t v93;
  unsigned __int8 mask[16];
  _QWORD v95[8];

  v9 = a8;
  v95[6] = *MEMORY[0x24BDAC8D0];
  if (!a8)
  {
    if (pthread_once(&EVP_sha1_once, (void (*)(void))EVP_sha1_init))
      abort();
    v9 = (const EVP_MD *)&EVP_sha1_storage;
  }
  if (a9)
    v17 = a9;
  else
    v17 = v9;
  pkey_type = v9->pkey_type;
  if (2 * pkey_type + 2 > a5)
  {
    ERR_put_error(4, 0, 133, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_crypt.c", 253);
    return 0;
  }
  v91 = a3;
  v19 = ~pkey_type + a5;
  if (v19 > 0xFFFFFFFFFFFFFFF7 || (v20 = malloc_type_malloc(v19 + 8, 0x30772F57uLL)) == 0)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  __dst = a1;
  v90 = v20;
  *v20 = v19;
  v21 = (unsigned __int8 *)(v20 + 1);
  if (!PKCS1_MGF1(mask, pkey_type, &a4[pkey_type + 1], ~pkey_type + a5, v17))
  {
LABEL_68:
    v78 = v90;
    if (*v90 != -8)
    {
      bzero(v90, *v90 + 8);
      v78 = v90;
    }
    free(v78);
    return 0;
  }
  if ((_DWORD)pkey_type)
  {
    if (pkey_type < 8)
    {
      v22 = 0;
      goto LABEL_25;
    }
    if (pkey_type >= 0x20)
    {
      v22 = pkey_type & 0xFFFFFFE0;
      v23 = (int8x16_t *)(a4 + 17);
      v24 = (int8x16_t *)v95;
      v25 = v22;
      do
      {
        v26 = veorq_s8(*v24, *v23);
        v24[-1] = veorq_s8(v24[-1], v23[-1]);
        *v24 = v26;
        v23 += 2;
        v24 += 2;
        v25 -= 32;
      }
      while (v25);
      if (v22 == pkey_type)
        goto LABEL_27;
      if ((pkey_type & 0x18) == 0)
      {
LABEL_25:
        v32 = pkey_type - v22;
        v33 = &mask[v22];
        v34 = &a4[v22 + 1];
        do
        {
          v35 = *v34++;
          *v33++ ^= v35;
          --v32;
        }
        while (v32);
        goto LABEL_27;
      }
    }
    else
    {
      v22 = 0;
    }
    v27 = v22;
    v22 = pkey_type & 0xFFFFFFF8;
    v28 = (int8x8_t *)&a4[v27 + 1];
    v29 = (int8x8_t *)&mask[v27];
    v30 = v27 - v22;
    do
    {
      v31 = *v28++;
      *v29 = veor_s8(*v29, v31);
      ++v29;
      v30 += 8;
    }
    while (v30);
    if (v22 != pkey_type)
      goto LABEL_25;
  }
LABEL_27:
  if (!PKCS1_MGF1(v21, ~pkey_type + a5, mask, pkey_type, v17))
    goto LABEL_68;
  if (!v19)
    goto LABEL_36;
  if (v19 < 8 || v21 < &a4[a5] && &a4[pkey_type + 1] < (unsigned __int8 *)v90 + a5 - pkey_type + 7)
  {
    v36 = 0;
    goto LABEL_33;
  }
  if (v19 >= 0x20)
  {
    v36 = v19 & 0xFFFFFFFFFFFFFFE0;
    v80 = (int8x16_t *)&a4[pkey_type + 17];
    v81 = (int8x16_t *)(v90 + 3);
    v82 = v19 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      v83 = veorq_s8(*v81, *v80);
      v81[-1] = veorq_s8(v81[-1], v80[-1]);
      *v81 = v83;
      v80 += 2;
      v81 += 2;
      v82 -= 32;
    }
    while (v82);
    if (v19 == v36)
      goto LABEL_36;
    if ((v19 & 0x18) == 0)
    {
LABEL_33:
      v37 = v36 + pkey_type + 1;
      v38 = v37 - a5;
      v39 = (char *)v90 + v36 + 8;
      v40 = &a4[v37];
      do
      {
        v41 = *v40++;
        *v39++ ^= v41;
      }
      while (!__CFADD__(v38++, 1));
      goto LABEL_36;
    }
  }
  else
  {
    v36 = 0;
  }
  v84 = v36;
  v36 = v19 & 0xFFFFFFFFFFFFFFF8;
  v85 = (int8x8_t *)&a4[v84 + 1 + pkey_type];
  v86 = (int8x8_t *)((char *)v90 + v84 + 8);
  v87 = v84 - (v19 & 0xFFFFFFFFFFFFFFF8);
  do
  {
    v88 = *v85++;
    *v86 = veor_s8(*v86, v88);
    ++v86;
    v87 += 8;
  }
  while (v87);
  if (v19 != v36)
    goto LABEL_33;
LABEL_36:
  if (!EVP_Digest(a6, a7, md, 0, v9, 0))
    goto LABEL_68;
  if (!(_DWORD)pkey_type)
  {
    v45 = -1;
    goto LABEL_55;
  }
  if (pkey_type >= 8)
  {
    if (pkey_type >= 0x20)
    {
      v43 = pkey_type & 0xFFFFFFE0;
      v46 = (int8x16_t *)(v90 + 3);
      v47 = (int8x16_t *)&v93;
      v48 = 0uLL;
      v49 = v43;
      v50 = 0uLL;
      do
      {
        v48 = vorrq_s8(veorq_s8(v47[-1], v46[-1]), v48);
        v50 = vorrq_s8(veorq_s8(*v47, *v46), v50);
        v46 += 2;
        v47 += 2;
        v49 -= 32;
      }
      while (v49);
      v51 = vorrq_s8(v50, v48);
      *(int8x8_t *)v51.i8 = vorr_s8(*(int8x8_t *)v51.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v51, v51, 8uLL));
      v52 = v51.i64[0] | HIDWORD(v51.i64[0]) | ((unint64_t)(v51.i64[0] | HIDWORD(v51.i64[0])) >> 16);
      v44 = v52 | BYTE1(v52);
      if (v43 == pkey_type)
        goto LABEL_54;
      if ((pkey_type & 0x18) == 0)
        goto LABEL_52;
    }
    else
    {
      v44 = 0;
      v43 = 0;
    }
    v53 = v43;
    v54 = (int8x8_t)v44;
    v43 = pkey_type & 0xFFFFFFF8;
    v55 = (int8x8_t *)((char *)v90 + v53 + 8);
    v56 = &md[v53];
    v57 = v53 - v43;
    do
    {
      v58 = *v55++;
      v59 = v58;
      v60 = *(int8x8_t *)v56;
      v56 += 8;
      v54 = vorr_s8(veor_s8(v60, v59), v54);
      v57 += 8;
    }
    while (v57);
    v61 = *(_QWORD *)&v54 | HIDWORD(*(_QWORD *)&v54) | ((*(_QWORD *)&v54 | HIDWORD(*(_QWORD *)&v54)) >> 16);
    v44 = v61 | BYTE1(v61);
    if (v43 == pkey_type)
      goto LABEL_54;
    goto LABEL_52;
  }
  v43 = 0;
  v44 = 0;
LABEL_52:
  v62 = pkey_type - v43;
  v63 = &md[v43];
  v64 = (char *)v90 + v43 + 8;
  do
  {
    v66 = *v64++;
    v65 = v66;
    v67 = *v63++;
    v44 |= v67 ^ v65;
    --v62;
  }
  while (v62);
LABEL_54:
  v45 = v44 - 1;
LABEL_55:
  v68 = ~((*a4 - 1) & v45) >> 63;
  v69 = -1;
  if (v19 <= pkey_type)
  {
    v70 = 0;
  }
  else
  {
    v70 = 0;
    v71 = ~(2 * pkey_type) + a5;
    do
    {
      v72 = ((v21[pkey_type] ^ 1) - 1) >> 63;
      v70 = v72 & v69 & pkey_type | v70 & ~(v72 & v69);
      v69 &= ~v72;
      if (v21[pkey_type])
        v73 = v69;
      else
        v73 = 0;
      v68 |= v73;
      ++pkey_type;
      --v71;
    }
    while (v71);
  }
  if (v69 | v68)
  {
    v74 = 133;
    v75 = 253;
LABEL_67:
    ERR_put_error(4, 0, v74, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_crypt.c", v75);
    goto LABEL_68;
  }
  v76 = v70 + 1;
  v77 = v19 - (v70 + 1);
  if (v77 > v91)
  {
    v74 = 113;
    v75 = 241;
    goto LABEL_67;
  }
  if (v19 != v76)
    memcpy(__dst, &v21[v76], v19 - (v70 + 1));
  *a2 = v77;
  OPENSSL_free(v21);
  return 1;
}

uint64_t RSA_encrypt(uint64_t a1, unint64_t *a2, char *a3, unint64_t a4, const void *a5, size_t a6, int a7)
{
  unsigned int (*v14)(uint64_t);
  unint64_t v15;
  const char *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v22;
  char *v23;
  BN_CTX *v24;
  _QWORD *v25;
  uint64_t v26;
  BIGNUM *v27;
  BIGNUM *v28;
  _QWORD *v29;
  const unsigned __int8 *v30;
  int v31;
  const BIGNUM *v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  uint64_t v38;
  size_t v39;
  BIGNUM *r;
  unsigned __int8 *to;
  BN_CTX *c;

  if (!*(_QWORD *)(a1 + 8) || !*(_QWORD *)(a1 + 16))
  {
    v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/rsa_extra/rsa_crypt.c";
    v17 = 4;
    v18 = 144;
    v19 = 382;
    goto LABEL_8;
  }
  if (!rsa_check_public_key(a1))
    return 0;
  v14 = *(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 32);
  if (v14)
  {
    v15 = v14(a1);
    if (v15 > a4)
    {
LABEL_6:
      v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src"
            "/crypto/rsa_extra/rsa_crypt.c";
      v17 = 4;
      v18 = 135;
      v19 = 397;
LABEL_8:
      ERR_put_error(v17, 0, v18, v16, v19);
      return 0;
    }
  }
  else
  {
    v15 = BN_num_bytes(*(uint64_t **)(a1 + 8));
    if (v15 > a4)
      goto LABEL_6;
  }
  v22 = (char *)malloc_type_malloc(0x38uLL, 0x30772F57uLL);
  if (!v22)
  {
    v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v17 = 14;
    v18 = 65;
    v19 = 247;
    goto LABEL_8;
  }
  v23 = v22;
  *(_QWORD *)v22 = 48;
  *(_OWORD *)(v22 + 8) = 0u;
  v24 = (BN_CTX *)(v22 + 8);
  *(_OWORD *)(v22 + 24) = 0u;
  *(_OWORD *)(v22 + 34) = 0u;
  v25 = OPENSSL_realloc(0, 0x100uLL);
  if (v25)
  {
    *((_QWORD *)v23 + 4) = 32;
    v25[*((_QWORD *)v23 + 3)] = 0;
    v26 = *((_QWORD *)v23 + 3) + 1;
    *((_QWORD *)v23 + 2) = v25;
    *((_QWORD *)v23 + 3) = v26;
  }
  else
  {
    *((_WORD *)v23 + 24) = 257;
  }
  v27 = BN_CTX_get(v24);
  c = v24;
  v28 = BN_CTX_get(v24);
  v29 = malloc_type_malloc(v15 + 8, 0x30772F57uLL);
  if (!v29)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v30 = 0;
    goto LABEL_25;
  }
  r = v28;
  v20 = 0;
  *v29 = v15;
  to = (unsigned __int8 *)(v29 + 1);
  if (!v27 || !r)
  {
    v30 = (const unsigned __int8 *)(v29 + 1);
    if (v23[48])
      goto LABEL_38;
    goto LABEL_37;
  }
  switch(a7)
  {
    case 4:
      v30 = (const unsigned __int8 *)(v29 + 1);
      v31 = RSA_padding_add_PKCS1_OAEP_mgf1(to, v15, a5, a6, 0, 0, 0, 0);
      break;
    case 3:
      v30 = (const unsigned __int8 *)(v29 + 1);
      v31 = RSA_padding_add_none(to, v15, (const unsigned __int8 *)a5, a6);
      break;
    case 1:
      v30 = (const unsigned __int8 *)(v29 + 1);
      v31 = rsa_padding_add_PKCS1_type_2(to, v15, a5, a6);
      break;
    default:
      ERR_put_error(4, 0, 143, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_crypt.c", 427);
      v20 = 0;
      v30 = to;
      if (v23[48])
        goto LABEL_38;
      goto LABEL_37;
  }
  if (v31 < 1 || !BN_bin2bn(v30, v15, v27))
    goto LABEL_25;
  v32 = *(const BIGNUM **)(a1 + 8);
  if ((bn_cmp_words_consttime((uint64_t *)v27->d, v27->top, (uint64_t *)v32->d, v32->top) & 0x80000000) == 0)
  {
    v33 = 115;
    v34 = 441;
LABEL_35:
    ERR_put_error(4, 0, v33, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_crypt.c", v34);
    goto LABEL_25;
  }
  if (!BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a1 + 288), (int)a1 + 88, v32, c)
    || !BN_mod_exp_mont(r, v27, *(const BIGNUM **)(a1 + 16), (const BIGNUM *)(*(_QWORD *)(a1 + 288) + 24), c, *(BN_MONT_CTX **)(a1 + 288)))
  {
LABEL_25:
    v20 = 0;
    if (v23[48])
      goto LABEL_38;
    goto LABEL_37;
  }
  if (!BN_bn2bin_padded(a3, v15, (uint64_t)r))
  {
    v33 = 68;
    v34 = 453;
    goto LABEL_35;
  }
  *a2 = v15;
  v20 = 1;
  if (!v23[48])
  {
LABEL_37:
    v35 = *((_QWORD *)v23 + 2);
    v36 = *((_QWORD *)v23 + 3) - 1;
    *((_QWORD *)v23 + 3) = v36;
    *((_QWORD *)v23 + 5) = *(_QWORD *)(v35 + 8 * v36);
  }
LABEL_38:
  BN_CTX_free(c);
  if (v30)
  {
    v38 = *((_QWORD *)v30 - 1);
    v37 = (unsigned __int8 *)(v30 - 8);
    v39 = v38 + 8;
    if (v38 != -8)
      bzero(v37, v39);
    free(v37);
  }
  return v20;
}

uint64_t rsa_padding_add_PKCS1_type_2(_WORD *a1, unint64_t a2, const void *a3, size_t a4)
{
  int v4;
  int v5;
  _WORD *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;

  if (a2 <= 0xA)
  {
    v4 = 126;
    v5 = 263;
LABEL_5:
    ERR_put_error(4, 0, v4, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_crypt.c", v5);
    return 0;
  }
  if (a2 - 11 < a4)
  {
    v4 = 114;
    v5 = 268;
    goto LABEL_5;
  }
  *a1 = 512;
  v11 = a1 + 1;
  v12 = a2 - 3;
  RAND_bytes_with_additional_data((uint64_t)(a1 + 1), a2 - 3 - a4, (uint64_t)&RAND_bytes_kZeroAdditionalData);
  v13 = v12 - a4;
  if (v12 != a4)
  {
    v14 = 0;
    do
    {
      while (!*((_BYTE *)v11 + v14))
        RAND_bytes_with_additional_data((uint64_t)v11 + v14, 1uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
      ++v14;
    }
    while (v14 != v13);
  }
  *((_BYTE *)a1 + v13 + 2) = 0;
  if (a4)
    memcpy((char *)a1 + a2 - a4, a3, a4);
  return 1;
}

uint64_t RSA_decrypt(uint64_t **a1, unint64_t *a2, unsigned __int8 *a3, unint64_t a4, const unsigned __int8 *a5, unint64_t a6, uint64_t a7)
{
  int v7;
  uint64_t (*v14)(uint64_t **, unint64_t *, unsigned __int8 *, unint64_t, const unsigned __int8 *, unint64_t, uint64_t);
  unsigned int (*v16)(uint64_t **);
  unint64_t v17;
  const char *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  unsigned __int8 *v23;
  _QWORD *v24;
  unsigned int (*v25)(uint64_t **, unsigned __int8 *, const unsigned __int8 *, unint64_t);
  int v26;
  int v27;
  unsigned __int8 *v28;
  uint64_t v29;
  size_t v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  BOOL v39;
  size_t v40;

  v7 = a7;
  v14 = (uint64_t (*)(uint64_t **, unint64_t *, unsigned __int8 *, unint64_t, const unsigned __int8 *, unint64_t, uint64_t))(*a1)[7];
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = (unsigned int (*)(uint64_t **))(*a1)[4];
  if (!v16)
  {
    v17 = BN_num_bytes(a1[1]);
    if (v17 > a4)
      goto LABEL_5;
LABEL_8:
    v23 = a3;
    if (v7 != 3)
    {
      v24 = malloc_type_malloc(v17 + 8, 0x30772F57uLL);
      if (!v24)
      {
        v18 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
        v19 = 14;
        v20 = 65;
        v21 = 247;
        goto LABEL_6;
      }
      *v24 = v17;
      v23 = (unsigned __int8 *)(v24 + 1);
    }
    if (v17 == a6)
    {
      v25 = (unsigned int (*)(uint64_t **, unsigned __int8 *, const unsigned __int8 *, unint64_t))(*a1)[8];
      if (v25)
      {
        if (!v25(a1, v23, a5, a6))
        {
LABEL_17:
          v22 = 0;
          if (v7 == 3)
            return v22;
LABEL_18:
          if (v23)
          {
            v29 = *((_QWORD *)v23 - 1);
            v28 = v23 - 8;
            v30 = v29 + 8;
            if (v29 != -8)
              bzero(v28, v30);
            free(v28);
          }
          return v22;
        }
      }
      else if (!rsa_default_private_transform((uint64_t)a1, (char *)v23, a5, a6))
      {
        goto LABEL_17;
      }
      switch(v7)
      {
        case 4:
          if (RSA_padding_check_PKCS1_OAEP_mgf1(a3, a2, a6, v23, a6, 0, 0, 0, 0))
          {
            v22 = 1;
            goto LABEL_18;
          }
          break;
        case 3:
          *a2 = a6;
          return 1;
        case 1:
          if ((_DWORD)v17)
          {
            if (v17 > 0xA)
            {
              v33 = 0;
              v34 = -1;
              v35 = 2;
              do
              {
                v36 = (v23[v35] - 1) >> 63;
                v37 = v33 & ~(v36 & v34);
                v33 = v36 & v34 & v35 | v37;
                v34 &= ~v36;
                ++v35;
              }
              while (a6 != v35);
              if (((v33 - 10) & ~v37) < 0 != __OFSUB__(a6, v35)
                || (((v23[1] ^ 2) - 1) & (*v23 - 1) & 0x8000000000000000) == 0
                || v34 == -1)
              {
                v31 = 137;
                v32 = 332;
              }
              else
              {
                v38 = v33 + 1;
                v39 = a6 >= v38;
                v40 = a6 - v38;
                if (v39)
                {
                  if (v40)
                    memcpy(a3, &v23[v38], v40);
                  *a2 = v40;
                  v22 = 1;
                  goto LABEL_18;
                }
                v31 = 137;
                v32 = 340;
              }
            }
            else
            {
              v31 = 126;
              v32 = 295;
            }
          }
          else
          {
            v31 = 120;
            v32 = 286;
          }
          ERR_put_error(4, 0, v31, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_crypt.c", v32);
          break;
        default:
          ERR_put_error(4, 0, 143, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_crypt.c", 516);
          v22 = 0;
          goto LABEL_18;
      }
      v26 = 136;
      v27 = 522;
    }
    else
    {
      v26 = 112;
      v27 = 493;
    }
    ERR_put_error(4, 0, v26, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/rsa_extra/rsa_crypt.c", v27);
    goto LABEL_17;
  }
  v17 = v16(a1);
  if (v17 <= a4)
    goto LABEL_8;
LABEL_5:
  v18 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cry"
        "pto/rsa_extra/rsa_crypt.c";
  v19 = 4;
  v20 = 135;
  v21 = 478;
LABEL_6:
  ERR_put_error(v19, 0, v20, v18, v21);
  return 0;
}

uint64_t rsa_check_public_key(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  uint64_t *v8;
  uint64_t v9;
  int v11;
  unint64_t v12;
  _BOOL4 v13;
  _BOOL4 v14;
  _BOOL4 v15;
  _BOOL4 v16;
  _BOOL4 v17;
  _BOOL4 v18;
  unsigned int v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t *v25;
  uint64_t v26;
  int v27;
  unint64_t v28;
  _BOOL4 v29;
  _BOOL4 v30;
  _BOOL4 v31;
  _BOOL4 v32;
  _BOOL4 v33;
  _BOOL4 v34;
  unsigned int v35;

  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
  {
    ERR_put_error(4, 0, 144, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 78);
    return 0;
  }
  v2 = *(unsigned int *)(v1 + 8);
  v3 = (int)v2;
  v4 = v2 & ((int)v2 >> 31);
  v5 = 8 * v2 - 8;
  v6 = *(_DWORD *)(v1 + 8);
  while (1)
  {
    v7 = __OFSUB__(v6--, 1);
    if (v6 < 0 != v7)
      break;
    v8 = *(uint64_t **)v1;
    v9 = *(_QWORD *)(*(_QWORD *)v1 + v5);
    v5 -= 8;
    if (v9)
    {
      v4 = v6 + 1;
      goto LABEL_9;
    }
  }
  if ((v2 & 0x80000000) == 0)
    goto LABEL_24;
  v8 = *(uint64_t **)v1;
LABEL_9:
  v11 = v4 - 1;
  v12 = v8[v11];
  v13 = v12 != 0;
  v14 = HIDWORD(v12) != 0;
  if (HIDWORD(v12))
    v12 >>= 32;
  v15 = v12 >> 16 != 0;
  if (v12 >> 16)
    v12 >>= 16;
  v16 = v12 > 0xFF;
  if (v12 > 0xFF)
    v12 >>= 8;
  v17 = v12 > 0xF;
  if (v12 > 0xF)
    v12 >>= 4;
  v18 = v12 > 3;
  if (v12 > 3)
    v12 >>= 2;
  v19 = v13 | (v11 << 6) | (32 * v14) | (16 * v15) | (8 * v16) | (4 * v17) | (2 * v18);
  if (v12 > 1)
    ++v19;
  if (v19 > 0x4000)
  {
    ERR_put_error(4, 0, 128, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 86);
    return 0;
  }
  if (v19 <= 0x1FF)
  {
LABEL_24:
    ERR_put_error(4, 0, 126, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 93);
    return 0;
  }
  if ((int)v2 < 1 || (*(_BYTE *)v8 & 1) == 0 || *(_DWORD *)(v1 + 16))
  {
    ERR_put_error(4, 0, 104, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 100);
    return 0;
  }
  v20 = *(_QWORD *)(a1 + 16);
  if (!v20)
  {
    if ((*(_BYTE *)(a1 + 84) & 0x40) == 0)
    {
      ERR_put_error(4, 0, 144, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 140);
      return 0;
    }
    return 1;
  }
  v21 = *(unsigned int *)(v20 + 8);
  v22 = v21 & ((int)v21 >> 31);
  v23 = 8 * v21 - 8;
  v24 = *(_DWORD *)(v20 + 8);
  while (1)
  {
    v7 = __OFSUB__(v24--, 1);
    if (v24 < 0 != v7)
      break;
    v25 = *(uint64_t **)v20;
    v26 = *(_QWORD *)(*(_QWORD *)v20 + v23);
    v23 -= 8;
    if (v26)
    {
      v22 = v24 + 1;
      goto LABEL_38;
    }
  }
  if ((v21 & 0x80000000) == 0)
    goto LABEL_51;
  v25 = *(uint64_t **)v20;
LABEL_38:
  v27 = v22 - 1;
  v28 = v25[v27];
  v29 = v28 != 0;
  v30 = HIDWORD(v28) != 0;
  if (HIDWORD(v28))
    v28 >>= 32;
  v31 = v28 >> 16 != 0;
  if (v28 >> 16)
    v28 >>= 16;
  v32 = v28 > 0xFF;
  if (v28 > 0xFF)
    v28 >>= 8;
  v33 = v28 > 0xF;
  if (v28 > 0xF)
    v28 >>= 4;
  v34 = v28 > 3;
  if (v28 > 3)
    v28 >>= 2;
  v35 = v29 | (v27 << 6) | (32 * v30) | (16 * v31) | (8 * v32) | (4 * v33) | (2 * v34);
  if (v28 > 1)
    ++v35;
  if (v35 < 2 || *(_DWORD *)(v20 + 16) || (int)v21 < 1 || (*(_BYTE *)v25 & 1) == 0)
  {
LABEL_51:
    ERR_put_error(4, 0, 101, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 110);
    return 0;
  }
  if ((*(_BYTE *)(a1 + 84) & 0x80) == 0)
  {
    if (v35 >= 0x22)
    {
      ERR_put_error(4, 0, 101, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 131);
      return 0;
    }
    return 1;
  }
  if ((int)bn_cmp_words_consttime(v8, v3, v25, v21) > 0)
    return 1;
  ERR_put_error(4, 0, 101, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 117);
  return 0;
}

void rsa_invalidate_key(uint64_t a1)
{
  uint64_t *v2;
  int v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  size_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  size_t v11;
  int v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  size_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  size_t v20;
  int v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  size_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  size_t v29;
  int v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  size_t v34;
  uint64_t *v35;
  uint64_t v36;
  size_t v37;
  unint64_t v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  size_t v42;
  _QWORD *v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  size_t v47;

  *(_BYTE *)(a1 + 376) &= ~1u;
  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 288));
  *(_QWORD *)(a1 + 288) = 0;
  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 296));
  *(_QWORD *)(a1 + 296) = 0;
  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 304));
  *(_QWORD *)(a1 + 304) = 0;
  v2 = *(uint64_t **)(a1 + 312);
  if (!v2)
  {
LABEL_9:
    *(_QWORD *)(a1 + 312) = 0;
    v8 = *(uint64_t **)(a1 + 320);
    if (!v8)
      goto LABEL_21;
    goto LABEL_14;
  }
  v3 = *((_DWORD *)v2 + 5);
  if ((v3 & 2) == 0)
  {
    v4 = *v2;
    if (*v2)
    {
      v6 = *(_QWORD *)(v4 - 8);
      v5 = (void *)(v4 - 8);
      v7 = v6 + 8;
      if (v6 != -8)
        bzero(v5, v7);
      free(v5);
      v3 = *((_DWORD *)v2 + 5);
    }
  }
  if ((v3 & 1) == 0)
  {
    *v2 = 0;
    goto LABEL_9;
  }
  v10 = *(v2 - 1);
  v9 = v2 - 1;
  v11 = v10 + 8;
  if (v10 != -8)
    bzero(v9, v11);
  free(v9);
  *(_QWORD *)(a1 + 312) = 0;
  v8 = *(uint64_t **)(a1 + 320);
  if (!v8)
  {
LABEL_21:
    *(_QWORD *)(a1 + 320) = 0;
    v17 = *(uint64_t **)(a1 + 328);
    if (!v17)
      goto LABEL_33;
    goto LABEL_26;
  }
LABEL_14:
  v12 = *((_DWORD *)v8 + 5);
  if ((v12 & 2) == 0)
  {
    v13 = *v8;
    if (*v8)
    {
      v15 = *(_QWORD *)(v13 - 8);
      v14 = (void *)(v13 - 8);
      v16 = v15 + 8;
      if (v15 != -8)
        bzero(v14, v16);
      free(v14);
      v12 = *((_DWORD *)v8 + 5);
    }
  }
  if ((v12 & 1) == 0)
  {
    *v8 = 0;
    goto LABEL_21;
  }
  v19 = *(v8 - 1);
  v18 = v8 - 1;
  v20 = v19 + 8;
  if (v19 != -8)
    bzero(v18, v20);
  free(v18);
  *(_QWORD *)(a1 + 320) = 0;
  v17 = *(uint64_t **)(a1 + 328);
  if (!v17)
  {
LABEL_33:
    *(_QWORD *)(a1 + 328) = 0;
    v26 = *(uint64_t **)(a1 + 336);
    if (!v26)
      goto LABEL_45;
    goto LABEL_38;
  }
LABEL_26:
  v21 = *((_DWORD *)v17 + 5);
  if ((v21 & 2) == 0)
  {
    v22 = *v17;
    if (*v17)
    {
      v24 = *(_QWORD *)(v22 - 8);
      v23 = (void *)(v22 - 8);
      v25 = v24 + 8;
      if (v24 != -8)
        bzero(v23, v25);
      free(v23);
      v21 = *((_DWORD *)v17 + 5);
    }
  }
  if ((v21 & 1) == 0)
  {
    *v17 = 0;
    goto LABEL_33;
  }
  v28 = *(v17 - 1);
  v27 = v17 - 1;
  v29 = v28 + 8;
  if (v28 != -8)
    bzero(v27, v29);
  free(v27);
  *(_QWORD *)(a1 + 328) = 0;
  v26 = *(uint64_t **)(a1 + 336);
  if (!v26)
  {
LABEL_45:
    *(_QWORD *)(a1 + 336) = 0;
    if (!*(_QWORD *)(a1 + 344))
      goto LABEL_52;
    goto LABEL_50;
  }
LABEL_38:
  v30 = *((_DWORD *)v26 + 5);
  if ((v30 & 2) == 0)
  {
    v31 = *v26;
    if (*v26)
    {
      v33 = *(_QWORD *)(v31 - 8);
      v32 = (void *)(v31 - 8);
      v34 = v33 + 8;
      if (v33 != -8)
        bzero(v32, v34);
      free(v32);
      v30 = *((_DWORD *)v26 + 5);
    }
  }
  if ((v30 & 1) == 0)
  {
    *v26 = 0;
    goto LABEL_45;
  }
  v36 = *(v26 - 1);
  v35 = v26 - 1;
  v37 = v36 + 8;
  if (v36 != -8)
    bzero(v35, v37);
  free(v35);
  *(_QWORD *)(a1 + 336) = 0;
  if (*(_QWORD *)(a1 + 344))
  {
LABEL_50:
    v38 = 0;
    do
      BN_BLINDING_free(*(ECDSA_SIG **)(*(_QWORD *)(a1 + 352) + 8 * v38++));
    while (v38 < *(_QWORD *)(a1 + 344));
  }
LABEL_52:
  v39 = *(_QWORD *)(a1 + 352);
  if (v39)
  {
    v41 = *(_QWORD *)(v39 - 8);
    v40 = (void *)(v39 - 8);
    v42 = v41 + 8;
    if (v41 != -8)
      bzero(v40, v42);
    free(v40);
  }
  v43 = (_QWORD *)(a1 + 360);
  *(_QWORD *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 352) = 0;
  v44 = *(_QWORD *)(a1 + 360);
  if (v44)
  {
    v46 = *(_QWORD *)(v44 - 8);
    v45 = (void *)(v44 - 8);
    v47 = v46 + 8;
    if (v46 != -8)
      bzero(v45, v47);
    free(v45);
  }
  *v43 = 0;
  v43[1] = 0;
}

uint64_t rsa_default_sign_raw(_QWORD *a1, unint64_t *a2, char *a3, unint64_t a4, const void *a5, size_t a6, int a7)
{
  unsigned int (*v14)(_QWORD *);
  unint64_t v15;
  const char *v16;
  int v17;
  int v18;
  int v19;
  uint64_t *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unint64_t v29;
  _BOOL4 v30;
  _BOOL4 v31;
  _BOOL4 v32;
  _BOOL4 v33;
  _BOOL4 v34;
  _BOOL4 v35;
  int v36;
  char *v37;
  _QWORD *v38;
  const unsigned __int8 *v39;
  const char *v40;
  int v41;
  int v42;
  uint64_t v43;
  size_t v44;
  unsigned __int8 *v46;
  unsigned int (*v47)(_QWORD *, char *, const unsigned __int8 *, unint64_t);

  v14 = *(unsigned int (**)(_QWORD *))(*a1 + 32);
  if (!v14)
  {
    v20 = (uint64_t *)a1[1];
    v21 = *((unsigned int *)v20 + 2);
    v22 = v21 & ((int)v21 >> 31);
    v23 = 8 * v21 - 8;
    v24 = *((_DWORD *)v20 + 2);
    while (1)
    {
      v25 = __OFSUB__(v24--, 1);
      if (v24 < 0 != v25)
        break;
      v26 = *v20;
      v27 = *(_QWORD *)(*v20 + v23);
      v23 -= 8;
      if (v27)
      {
        v22 = v24 + 1;
        goto LABEL_11;
      }
    }
    if ((v21 & 0x80000000) == 0)
    {
      v15 = 0;
      goto LABEL_24;
    }
    v26 = *v20;
LABEL_11:
    v28 = v22 - 1;
    v29 = *(_QWORD *)(v26 + 8 * v28);
    v30 = v29 != 0;
    v31 = HIDWORD(v29) != 0;
    if (HIDWORD(v29))
      v29 >>= 32;
    v32 = v29 >> 16 != 0;
    if (v29 >> 16)
      v29 >>= 16;
    v33 = v29 > 0xFF;
    if (v29 > 0xFF)
      v29 >>= 8;
    v34 = v29 > 0xF;
    if (v29 > 0xF)
      v29 >>= 4;
    v35 = v29 > 3;
    if (v29 > 3)
      v29 >>= 2;
    v36 = v30 | (v28 << 6) | (32 * v31) | (16 * v32) | (8 * v33) | (4 * v34) | (2 * v35);
    if (v29 > 1)
      ++v36;
    v15 = (v36 + 7) >> 3;
    if (v15 > a4)
      goto LABEL_3;
LABEL_24:
    v37 = (char *)malloc_type_malloc(v15 + 8, 0x30772F57uLL);
    if (!v37)
    {
      v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
      v17 = 14;
      v18 = 65;
      v19 = 247;
      goto LABEL_30;
    }
    v38 = v37;
    *(_QWORD *)v37 = v15;
    v39 = (const unsigned __int8 *)(v37 + 8);
    if (a7 == 3)
    {
      if (v15 < a6)
      {
        v40 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/fipsmodule/rsa/padding.c";
        v41 = 114;
        v42 = 150;
        goto LABEL_34;
      }
      if (v15 > a6)
      {
        v40 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/fipsmodule/rsa/padding.c";
        v41 = 116;
        v42 = 155;
        goto LABEL_34;
      }
      v46 = (unsigned __int8 *)(v37 + 8);
      if (a6)
        goto LABEL_48;
    }
    else
    {
      if (a7 != 1)
      {
        v40 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/fipsmodule/rsa/rsa_impl.c";
        v41 = 143;
        v42 = 463;
        goto LABEL_34;
      }
      if (v15 <= 0xA)
      {
        v40 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/fipsmodule/rsa/padding.c";
        v41 = 126;
        v42 = 78;
LABEL_34:
        ERR_put_error(4, 0, v41, v40, v42);
        goto LABEL_35;
      }
      if (v15 - 11 < a6)
      {
        v40 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/fipsmodule/rsa/padding.c";
        v41 = 118;
        v42 = 83;
        goto LABEL_34;
      }
      *((_WORD *)v37 + 4) = 256;
      if (v15 - 3 != a6)
        memset(v37 + 10, 255, v15 - 3 - a6);
      v39[v15 + ~a6] = 0;
      if (a6)
      {
        v46 = (unsigned __int8 *)&v39[v15 - a6];
LABEL_48:
        memcpy(v46, a5, a6);
      }
    }
    v47 = *(unsigned int (**)(_QWORD *, char *, const unsigned __int8 *, unint64_t))(*a1 + 64);
    if (v47)
    {
      if (!v47(a1, a3, v39, v15))
      {
LABEL_35:
        v43 = 0;
        v44 = *v38 + 8;
        if (*v38 == -8)
        {
LABEL_37:
          free(v38);
          return v43;
        }
LABEL_36:
        bzero(v38, v44);
        goto LABEL_37;
      }
    }
    else if (!rsa_default_private_transform((uint64_t)a1, a3, v39, v15))
    {
      goto LABEL_35;
    }
    *a2 = v15;
    v43 = 1;
    v44 = *v38 + 8;
    if (*v38 == -8)
      goto LABEL_37;
    goto LABEL_36;
  }
  v15 = v14(a1);
  if (v15 <= a4)
    goto LABEL_24;
LABEL_3:
  v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cry"
        "pto/fipsmodule/rsa/rsa_impl.c";
  v17 = 4;
  v18 = 135;
  v19 = 446;
LABEL_30:
  ERR_put_error(v17, 0, v18, v16, v19);
  return 0;
}

uint64_t rsa_verify_raw_no_self_test(uint64_t a1, const unsigned __int8 **a2, unsigned __int8 *a3, unint64_t a4, const unsigned __int8 *a5, const unsigned __int8 *a6, int a7)
{
  unsigned int (*v14)(uint64_t);
  const unsigned __int8 *v15;
  const char *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  unint64_t v31;
  _BOOL4 v32;
  _BOOL4 v33;
  _BOOL4 v34;
  _BOOL4 v35;
  _BOOL4 v36;
  _BOOL4 v37;
  int v38;
  char *v39;
  char *v40;
  BN_CTX *v41;
  _QWORD *v42;
  uint64_t v43;
  BIGNUM *v44;
  BIGNUM *v45;
  char *v46;
  BIGNUM *v47;
  const BIGNUM *v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  size_t v55;
  BN_CTX *c;

  if (!*(_QWORD *)(a1 + 8) || !*(_QWORD *)(a1 + 16))
  {
    v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/rsa_impl.c";
    v17 = 4;
    v18 = 144;
    v19 = 492;
    goto LABEL_8;
  }
  if (!rsa_check_public_key(a1))
    return 0;
  v14 = *(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 32);
  if (v14)
  {
    v15 = (const unsigned __int8 *)v14(a1);
    if ((unint64_t)v15 > a4)
    {
LABEL_6:
      v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src"
            "/crypto/fipsmodule/rsa/rsa_impl.c";
      v17 = 4;
      v18 = 135;
      v19 = 504;
LABEL_8:
      ERR_put_error(v17, 0, v18, v16, v19);
      return 0;
    }
  }
  else
  {
    v22 = *(uint64_t **)(a1 + 8);
    v23 = *((unsigned int *)v22 + 2);
    v24 = v23 & ((int)v23 >> 31);
    v25 = 8 * v23 - 8;
    v26 = *((_DWORD *)v22 + 2);
    while (1)
    {
      v27 = __OFSUB__(v26--, 1);
      if (v26 < 0 != v27)
        break;
      v28 = *v22;
      v29 = *(_QWORD *)(*v22 + v25);
      v25 -= 8;
      if (v29)
      {
        v24 = v26 + 1;
        goto LABEL_18;
      }
    }
    if ((v23 & 0x80000000) == 0)
    {
      v15 = 0;
      goto LABEL_31;
    }
    v28 = *v22;
LABEL_18:
    v30 = v24 - 1;
    v31 = *(_QWORD *)(v28 + 8 * v30);
    v32 = v31 != 0;
    v33 = HIDWORD(v31) != 0;
    if (HIDWORD(v31))
      v31 >>= 32;
    v34 = v31 >> 16 != 0;
    if (v31 >> 16)
      v31 >>= 16;
    v35 = v31 > 0xFF;
    if (v31 > 0xFF)
      v31 >>= 8;
    v36 = v31 > 0xF;
    if (v31 > 0xF)
      v31 >>= 4;
    v37 = v31 > 3;
    if (v31 > 3)
      v31 >>= 2;
    v38 = v32 | (v30 << 6) | (32 * v33) | (16 * v34) | (8 * v35) | (4 * v36) | (2 * v37);
    if (v31 > 1)
      ++v38;
    v15 = (const unsigned __int8 *)((v38 + 7) >> 3);
    if ((unint64_t)v15 > a4)
      goto LABEL_6;
  }
LABEL_31:
  if (v15 != a6)
  {
    v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/rsa_impl.c";
    v17 = 4;
    v18 = 112;
    v19 = 509;
    goto LABEL_8;
  }
  v39 = (char *)malloc_type_malloc(0x38uLL, 0x30772F57uLL);
  if (!v39)
  {
    v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v17 = 14;
    v18 = 65;
    v19 = 247;
    goto LABEL_8;
  }
  v40 = v39;
  *(_QWORD *)v39 = 48;
  *(_OWORD *)(v39 + 8) = 0u;
  v41 = (BN_CTX *)(v39 + 8);
  *(_OWORD *)(v39 + 24) = 0u;
  *(_OWORD *)(v39 + 34) = 0u;
  v42 = OPENSSL_realloc(0, 0x100uLL);
  if (v42)
  {
    *((_QWORD *)v40 + 4) = 32;
    v42[*((_QWORD *)v40 + 3)] = 0;
    v43 = *((_QWORD *)v40 + 3) + 1;
    *((_QWORD *)v40 + 2) = v42;
    *((_QWORD *)v40 + 3) = v43;
  }
  else
  {
    *((_WORD *)v40 + 24) = 257;
  }
  v44 = BN_CTX_get(v41);
  c = v41;
  v45 = BN_CTX_get(v41);
  v46 = 0;
  v20 = 0;
  if (v44 && v45)
  {
    v47 = v45;
    v46 = (char *)a3;
    if (a7 != 3)
    {
      v46 = (char *)OPENSSL_malloc((unint64_t)a6);
      if (!v46)
        goto LABEL_46;
    }
    if (!BN_bin2bn(a5, (int)a6, v44))
      goto LABEL_46;
    v48 = *(const BIGNUM **)(a1 + 8);
    if ((bn_cmp_words_consttime((uint64_t *)v44->d, v44->top, (uint64_t *)v48->d, v48->top) & 0x80000000) != 0)
    {
      if (!BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a1 + 288), (int)a1 + 88, v48, c)
        || !BN_mod_exp_mont(v47, v44, *(const BIGNUM **)(a1 + 16), (const BIGNUM *)(*(_QWORD *)(a1 + 288) + 24), c, *(BN_MONT_CTX **)(a1 + 288)))
      {
        goto LABEL_46;
      }
      if (BN_bn2bin_padded(v46, (unint64_t)a6, (uint64_t)v47))
      {
        if (a7 == 1)
        {
          v20 = RSA_padding_check_PKCS1_type_1(a3, (int)a2, a6, (int)v46, (int)a6);
          if (!(_DWORD)v20)
            ERR_put_error(4, 0, 136, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 572);
          goto LABEL_47;
        }
        if (a7 == 3)
        {
          *a2 = a6;
          v20 = 1;
          goto LABEL_47;
        }
        v49 = 143;
        v50 = 567;
      }
      else
      {
        v49 = 68;
        v50 = 553;
      }
    }
    else
    {
      v49 = 115;
      v50 = 543;
    }
    ERR_put_error(4, 0, v49, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", v50);
LABEL_46:
    v20 = 0;
  }
LABEL_47:
  if (!v40[48])
  {
    v51 = *((_QWORD *)v40 + 2);
    v52 = *((_QWORD *)v40 + 3) - 1;
    *((_QWORD *)v40 + 3) = v52;
    *((_QWORD *)v40 + 5) = *(_QWORD *)(v51 + 8 * v52);
  }
  BN_CTX_free(c);
  if (v46 != (char *)a3 && v46)
  {
    v54 = *((_QWORD *)v46 - 1);
    v53 = v46 - 8;
    v55 = v54 + 8;
    if (v54 != -8)
      bzero(v53, v55);
    free(v53);
  }
  return v20;
}

uint64_t rsa_default_private_transform(uint64_t a1, char *a2, const unsigned __int8 *a3, unint64_t a4)
{
  char *v8;
  char *v9;
  BN_CTX *v10;
  _QWORD *v11;
  uint64_t v12;
  const char *v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  BIGNUM *v19;
  BIGNUM *v20;
  BN_BLINDING *v21;
  BIGNUM *v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int8x8_t v35;
  uint64_t v36;
  int v37;
  int8x16_t *v38;
  int8x16_t v39;
  unint64_t v40;
  int8x16_t v41;
  int8x16_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  BIGNUM *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int8x8_t v52;
  uint64_t v53;
  int8x16_t *v54;
  int8x16_t v55;
  unint64_t v56;
  int8x16_t v57;
  int8x16_t v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;

  if (!*(_QWORD *)(a1 + 8) || !*(_QWORD *)(a1 + 24))
  {
    v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/rsa/rsa_impl.c";
    v14 = 4;
    v15 = 144;
    v16 = 596;
LABEL_7:
    ERR_put_error(v14, 0, v15, v13, v16);
    return 0;
  }
  v62 = 0;
  v8 = (char *)malloc_type_malloc(0x38uLL, 0x30772F57uLL);
  if (!v8)
  {
    v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v14 = 14;
    v15 = 65;
    v16 = 247;
    goto LABEL_7;
  }
  v9 = v8;
  *(_QWORD *)v8 = 48;
  *(_OWORD *)(v8 + 8) = 0u;
  v10 = (BN_CTX *)(v8 + 8);
  *(_OWORD *)(v8 + 24) = 0u;
  *(_OWORD *)(v8 + 34) = 0u;
  v11 = OPENSSL_realloc(0, 0x100uLL);
  if (v11)
  {
    *((_QWORD *)v9 + 4) = 32;
    v11[*((_QWORD *)v9 + 3)] = 0;
    v12 = *((_QWORD *)v9 + 3) + 1;
    *((_QWORD *)v9 + 2) = v11;
    *((_QWORD *)v9 + 3) = v12;
  }
  else
  {
    *((_WORD *)v9 + 24) = 257;
  }
  v19 = BN_CTX_get(v10);
  v20 = BN_CTX_get(v10);
  v17 = 0;
  v21 = 0;
  if (!v19 || (v22 = v20) == 0)
  {
LABEL_19:
    if (v9[48])
      goto LABEL_21;
    goto LABEL_20;
  }
  if (!BN_bin2bn(a3, a4, v19))
    goto LABEL_17;
  if ((int)bn_cmp_words_consttime((uint64_t *)v19->d, v19->top, **(uint64_t ***)(a1 + 8), *(int *)(*(_QWORD *)(a1 + 8) + 8)) >= 0)
  {
    v23 = 115;
    v24 = 628;
LABEL_16:
    ERR_put_error(4, 0, v23, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", v24);
LABEL_17:
    v21 = 0;
LABEL_18:
    v17 = 0;
    goto LABEL_19;
  }
  if (!freeze_private_key(a1, v10))
  {
    v23 = 68;
    v24 = 633;
    goto LABEL_16;
  }
  v28 = *(_DWORD *)(a1 + 84) & 0x48;
  if (!*(_QWORD *)(a1 + 16) && !v28)
  {
    v23 = 130;
    v24 = 649;
    goto LABEL_16;
  }
  if (v28)
  {
    v21 = 0;
  }
  else
  {
    v21 = rsa_blinding_get(a1, &v62);
    if (!v21)
    {
      v37 = 656;
LABEL_67:
      ERR_put_error(4, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", v37);
      goto LABEL_18;
    }
    if (!BN_BLINDING_convert(v19, v21, *(BN_CTX **)(a1 + 16)))
      goto LABEL_18;
  }
  v29 = *(uint64_t **)(a1 + 32);
  if (!v29)
    goto LABEL_55;
  v30 = *(uint64_t **)(a1 + 40);
  if (!v30
    || !*(_QWORD *)(a1 + 16)
    || !*(_QWORD *)(a1 + 48)
    || !*(_QWORD *)(a1 + 56)
    || !*(_QWORD *)(a1 + 64)
    || *((_DWORD *)v30 + 4))
  {
    goto LABEL_55;
  }
  v31 = *(int *)(*(_QWORD *)(a1 + 296) + 32);
  v32 = *((int *)v30 + 2);
  if (v32 <= v31)
    goto LABEL_54;
  v33 = *v30;
  v34 = v32 - v31;
  if ((unint64_t)(v32 - v31) < 4)
  {
    v35 = 0;
    v36 = *(int *)(*(_QWORD *)(a1 + 296) + 32);
LABEL_51:
    v43 = v32 - v36;
    v44 = (uint64_t *)(v33 + 8 * v36);
    do
    {
      v45 = *v44++;
      *(_QWORD *)&v35 |= v45;
      --v43;
    }
    while (v43);
    goto LABEL_53;
  }
  v36 = (v34 & 0xFFFFFFFFFFFFFFFCLL) + v31;
  v38 = (int8x16_t *)(v33 + 8 * v31 + 16);
  v39 = 0uLL;
  v40 = v34 & 0xFFFFFFFFFFFFFFFCLL;
  v41 = 0uLL;
  do
  {
    v39 = vorrq_s8(v38[-1], v39);
    v41 = vorrq_s8(*v38, v41);
    v38 += 2;
    v40 -= 4;
  }
  while (v40);
  v42 = vorrq_s8(v41, v39);
  v35 = vorr_s8(*(int8x8_t *)v42.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v42, v42, 8uLL));
  if (v34 != (v34 & 0xFFFFFFFFFFFFFFFCLL))
    goto LABEL_51;
LABEL_53:
  if (v35)
    goto LABEL_55;
LABEL_54:
  if (*((_DWORD *)v29 + 4))
    goto LABEL_55;
  v48 = *(int *)(*(_QWORD *)(a1 + 304) + 32);
  v49 = *((int *)v29 + 2);
  if (v49 <= v48)
  {
LABEL_77:
    if (!mod_exp(v22, v19, a1, v10))
      goto LABEL_18;
    goto LABEL_56;
  }
  v50 = *v29;
  v51 = v49 - v48;
  if ((unint64_t)(v49 - v48) < 4)
  {
    v52 = 0;
    v53 = *(int *)(*(_QWORD *)(a1 + 304) + 32);
LABEL_74:
    v59 = v49 - v53;
    v60 = (uint64_t *)(v50 + 8 * v53);
    do
    {
      v61 = *v60++;
      *(_QWORD *)&v52 |= v61;
      --v59;
    }
    while (v59);
    goto LABEL_76;
  }
  v53 = (v51 & 0xFFFFFFFFFFFFFFFCLL) + v48;
  v54 = (int8x16_t *)(v50 + 8 * v48 + 16);
  v55 = 0uLL;
  v56 = v51 & 0xFFFFFFFFFFFFFFFCLL;
  v57 = 0uLL;
  do
  {
    v55 = vorrq_s8(v54[-1], v55);
    v57 = vorrq_s8(*v54, v57);
    v54 += 2;
    v56 -= 4;
  }
  while (v56);
  v58 = vorrq_s8(v57, v55);
  v52 = vorr_s8(*(int8x8_t *)v58.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v58, v58, 8uLL));
  if (v51 != (v51 & 0xFFFFFFFFFFFFFFFCLL))
    goto LABEL_74;
LABEL_76:
  if (!*(_QWORD *)&v52)
    goto LABEL_77;
LABEL_55:
  if (!BN_mod_exp_mont_consttime(v22, v19, *(const BIGNUM **)(a1 + 312), *(const BIGNUM **)(a1 + 8), v10, *(BN_MONT_CTX **)(a1 + 288)))goto LABEL_18;
LABEL_56:
  if (*(_QWORD *)(a1 + 16))
  {
    v46 = BN_CTX_get(v10);
    if (!v46
      || (v47 = (uint64_t)v46,
          !BN_mod_exp_mont(v46, v22, *(const BIGNUM **)(a1 + 16), *(const BIGNUM **)(a1 + 8), v10, *(BN_MONT_CTX **)(a1 + 288)))|| !BN_equal_consttime(v47, (uint64_t)v19))
    {
      v37 = 695;
      goto LABEL_67;
    }
  }
  if (!v28 && !BN_mod_mul_montgomery(v22, v22, *((const BIGNUM **)v21 + 1), *(BN_MONT_CTX **)(a1 + 288), v10))
    goto LABEL_18;
  if (!BN_bn2bin_padded(a2, a4, (uint64_t)v22))
  {
    v37 = 713;
    goto LABEL_67;
  }
  v17 = 1;
  if (!v9[48])
  {
LABEL_20:
    v25 = *((_QWORD *)v9 + 2);
    v26 = *((_QWORD *)v9 + 3) - 1;
    *((_QWORD *)v9 + 3) = v26;
    *((_QWORD *)v9 + 5) = *(_QWORD *)(v25 + 8 * v26);
  }
LABEL_21:
  BN_CTX_free(v10);
  if (v21)
  {
    v27 = v62;
    if (v62 == 1024)
    {
      BN_BLINDING_free((ECDSA_SIG *)v21);
    }
    else if (pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 88))
           || (*(_BYTE *)(*(_QWORD *)(a1 + 360) + v27) = 0, pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 88))))
    {
      abort();
    }
  }
  return v17;
}

uint64_t freeze_private_key(uint64_t a1, BN_CTX *a2)
{
  pthread_rwlock_t *v4;
  char v5;
  uint64_t *v6;
  uint64_t v7;
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  unint64_t v14;
  BIGNUM *v15;
  uint64_t v16;
  BIGNUM *v17;
  BIGNUM *v18;
  BIGNUM *v19;

  v4 = (pthread_rwlock_t *)(a1 + 88);
  if (pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 88)))
    goto LABEL_42;
  v5 = *(_BYTE *)(a1 + 376);
  if (pthread_rwlock_unlock(v4))
    goto LABEL_42;
  if ((v5 & 1) != 0)
    return 1;
  if (pthread_rwlock_wrlock(v4))
LABEL_42:
    abort();
  if ((*(_BYTE *)(a1 + 376) & 1) != 0)
    goto LABEL_32;
  if (rsa_check_public_key(a1))
  {
    v6 = *(uint64_t **)(a1 + 288);
    if (v6 || (v6 = BN_MONT_CTX_new_for_modulus(*(const BIGNUM **)(a1 + 8), a2), (*(_QWORD *)(a1 + 288) = v6) != 0))
    {
      if (*(_QWORD *)(a1 + 24) && !*(_QWORD *)(a1 + 312))
      {
        v14 = *((int *)v6 + 8);
        v15 = BN_dup(*(const BIGNUM **)(a1 + 24));
        v12 = v15;
        if (!v15 || !bn_resize_words((uint64_t)v15, v14))
        {
LABEL_33:
          v17 = v12;
LABEL_34:
          BN_free(v17);
          v16 = 0;
          goto LABEL_39;
        }
        *(_QWORD *)(a1 + 312) = v12;
        if (!*(_QWORD *)(a1 + 16))
          goto LABEL_31;
      }
      else if (!*(_QWORD *)(a1 + 16))
      {
        goto LABEL_31;
      }
      v7 = *(_QWORD *)(a1 + 32);
      if (!v7 || !*(_QWORD *)(a1 + 40))
        goto LABEL_31;
      v8 = *(BIGNUM **)(a1 + 296);
      if (v8 || (v8 = BN_MONT_CTX_new_consttime(v7, a2), (*(_QWORD *)(a1 + 296) = v8) != 0))
      {
        v9 = *(BIGNUM **)(a1 + 304);
        if (v9 || (v9 = BN_MONT_CTX_new_consttime(*(_QWORD *)(a1 + 40), a2), (*(_QWORD *)(a1 + 304) = v9) != 0))
        {
          v10 = *(BIGNUM **)(a1 + 48);
          if (!v10 || !*(_QWORD *)(a1 + 56))
            goto LABEL_31;
          if (*(_QWORD *)(a1 + 64))
          {
            if (!ensure_fixed_copy((uint64_t *)(a1 + 320), v10, v8[1].top))
              goto LABEL_38;
          }
          else
          {
            v18 = BN_new();
            v19 = v18;
            if (!v18
              || !bn_mod_inverse_secret_prime(v18, *(const BIGNUM **)(a1 + 40), *(const BIGNUM **)(a1 + 32), a2, *(BN_MONT_CTX **)(a1 + 296)))
            {
              v17 = v19;
              goto LABEL_34;
            }
            *(_QWORD *)(a1 + 64) = v19;
            if (!ensure_fixed_copy((uint64_t *)(a1 + 320), *(BIGNUM **)(a1 + 48), v8[1].top))
              goto LABEL_38;
          }
          if (ensure_fixed_copy((uint64_t *)(a1 + 328), *(BIGNUM **)(a1 + 56), v9[1].top))
          {
            if (!*(_QWORD *)(a1 + 336))
            {
              v11 = BN_new();
              v12 = v11;
              if (v11
                && BN_mod_mul_montgomery(v11, *(const BIGNUM **)(a1 + 64), *(const BIGNUM **)(a1 + 296), *(BN_MONT_CTX **)(a1 + 296), a2))
              {
                *(_QWORD *)(a1 + 336) = v12;
                goto LABEL_31;
              }
              goto LABEL_33;
            }
LABEL_31:
            *(_BYTE *)(a1 + 376) |= 1u;
LABEL_32:
            v16 = 1;
            goto LABEL_39;
          }
        }
      }
    }
  }
LABEL_38:
  v16 = 0;
LABEL_39:
  if (pthread_rwlock_unlock(v4))
    goto LABEL_42;
  return v16;
}

BN_BLINDING *rsa_blinding_get(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  pthread_rwlock_t *v5;
  size_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  size_t v12;
  uint64_t *v13;
  uint64_t v14;
  _BYTE *v15;
  const BIGNUM *v16;
  BIGNUM *v17;
  uint64_t v18;
  _BYTE *v19;
  BN_BLINDING *v20;
  uint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  BIGNUM *v25;
  const BIGNUM *v26;
  BIGNUM *v27;
  int *p_top;
  size_t v29;
  unint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  size_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  size_t v38;
  unint64_t i;
  char *v40;
  uint64_t v41;
  size_t v42;

  if (pthread_once(&g_pthread_fork_detection_once, (void (*)(void))init_pthread_fork_detection)
    || (v4 = g_atfork_fork_generation,
        v5 = (pthread_rwlock_t *)(a1 + 88),
        pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 88))))
  {
LABEL_60:
    abort();
  }
  v6 = *(_QWORD *)(a1 + 344);
  if (*(_QWORD *)(a1 + 368) == v4)
    goto LABEL_13;
  if (v6)
  {
    v7 = *(_QWORD *)(a1 + 352);
    if (v6 == 1)
    {
      v8 = 0;
    }
    else
    {
      v8 = v6 & 0xFFFFFFFFFFFFFFFELL;
      v9 = (uint64_t *)(v7 + 8);
      v10 = v6 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v11 = *v9;
        *(_DWORD *)(*(v9 - 1) + 16) = 31;
        *(_DWORD *)(v11 + 16) = 31;
        v9 += 2;
        v10 -= 2;
      }
      while (v10);
      if (v6 == v8)
        goto LABEL_12;
    }
    v12 = v6 - v8;
    v13 = (uint64_t *)(v7 + 8 * v8);
    do
    {
      v14 = *v13++;
      *(_DWORD *)(v14 + 16) = 31;
      --v12;
    }
    while (v12);
  }
LABEL_12:
  *(_QWORD *)(a1 + 368) = v4;
LABEL_13:
  if (v6)
  {
    v15 = memchr(*(void **)(a1 + 360), 0, v6);
    if (v15)
    {
      *v15 = 1;
      v18 = *(_QWORD *)(a1 + 352);
      v19 = &v15[-*(_QWORD *)(a1 + 360)];
      *a2 = v19;
      v20 = *(BN_BLINDING **)(v18 + 8 * (_QWORD)v19);
      goto LABEL_58;
    }
    if (v6 >= 0x400)
    {
      *a2 = 1024;
      v20 = BN_BLINDING_new(0, v16, v17);
      goto LABEL_58;
    }
  }
  v21 = 2 * v6;
  if (2 * v6 >= 0x400)
    v21 = 1024;
  if (v6)
    v22 = v21;
  else
    v22 = 1;
  v23 = malloc_type_malloc(8 * v22 + 8, 0x30772F57uLL);
  v24 = v23;
  if (!v23)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v25 = (BIGNUM *)malloc_type_malloc(v22 + 8, 0x30772F57uLL);
    if (v25)
      goto LABEL_27;
LABEL_34:
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    if (!v24)
    {
LABEL_57:
      v20 = 0;
      goto LABEL_58;
    }
LABEL_54:
    v41 = *(v24 - 1);
    v40 = (char *)(v24 - 1);
    v42 = v41 + 8;
    if (v41 != -8)
      bzero(v40, v42);
    free(v40);
    goto LABEL_57;
  }
  *v23 = 8 * v22;
  v24 = v23 + 1;
  if (v22)
    bzero(v24, 8 * v22);
  v25 = (BIGNUM *)malloc_type_malloc(v22 + 8, 0x30772F57uLL);
  if (!v25)
    goto LABEL_34;
LABEL_27:
  v27 = v25;
  v25->d = (unint64_t *)v22;
  p_top = &v25->top;
  if (!v24)
    goto LABEL_51;
  v29 = *(_QWORD *)(a1 + 344);
  if (8 * v29)
  {
    v25 = (BIGNUM *)memcpy(v24, *(const void **)(a1 + 352), 8 * v29);
    v29 = *(_QWORD *)(a1 + 344);
  }
  if (v29)
  {
    v25 = (BIGNUM *)memcpy(p_top, *(const void **)(a1 + 360), v29);
    v30 = *(_QWORD *)(a1 + 344);
    if (v30 < v22)
      goto LABEL_37;
    goto LABEL_40;
  }
  v30 = 0;
  if (v22)
  {
LABEL_37:
    while (1)
    {
      v25 = (BIGNUM *)BN_BLINDING_new(v25, v26, (BIGNUM *)v29);
      v24[v30] = v25;
      if (!v25)
        break;
      if (v22 == ++v30)
      {
        v30 = *(_QWORD *)(a1 + 344);
        goto LABEL_40;
      }
    }
    for (i = *(_QWORD *)(a1 + 344); i < v30; ++i)
      BN_BLINDING_free((ECDSA_SIG *)v24[i]);
LABEL_51:
    if (v27->d != (unint64_t *)-8)
      bzero(v27, (size_t)(v27->d + 1));
    free(v27);
    if (!v24)
      goto LABEL_57;
    goto LABEL_54;
  }
LABEL_40:
  bzero((char *)p_top + v30, v22 - v30);
  *((_BYTE *)p_top + *(_QWORD *)(a1 + 344)) = 1;
  v31 = *(_QWORD *)(a1 + 352);
  *a2 = *(_QWORD *)(a1 + 344);
  v20 = (BN_BLINDING *)v24[*(_QWORD *)(a1 + 344)];
  if (v31)
  {
    v33 = *(_QWORD *)(v31 - 8);
    v32 = (void *)(v31 - 8);
    v34 = v33 + 8;
    if (v33 != -8)
      bzero(v32, v34);
    free(v32);
  }
  *(_QWORD *)(a1 + 352) = v24;
  v35 = *(_QWORD *)(a1 + 360);
  if (v35)
  {
    v37 = *(_QWORD *)(v35 - 8);
    v36 = (void *)(v35 - 8);
    v38 = v37 + 8;
    if (v37 != -8)
      bzero(v36, v38);
    free(v36);
  }
  *(_QWORD *)(a1 + 360) = p_top;
  *(_QWORD *)(a1 + 344) = v22;
LABEL_58:
  if (pthread_rwlock_unlock(v5))
    goto LABEL_60;
  return v20;
}

uint64_t mod_exp(BIGNUM *a1, const BIGNUM *a2, uint64_t a3, BN_CTX *ctx)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  _QWORD *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  uint64_t result;
  const BIGNUM *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const BIGNUM *v20;
  BIGNUM *v21;
  uint64_t top;
  uint64_t v23;
  unint64_t *d;
  uint64_t v25;
  int8x8_t v26;
  uint64_t v27;
  int8x16_t *v28;
  int8x16_t v29;
  unint64_t v30;
  int8x16_t v31;
  int8x16_t v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  BIGNUM *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t *v40;
  uint64_t v41;
  int8x8_t v42;
  uint64_t v43;
  int8x16_t *v44;
  int8x16_t v45;
  unint64_t v46;
  int8x16_t v47;
  int8x16_t v48;
  uint64_t v49;
  unint64_t *v50;
  uint64_t v51;
  const BIGNUM *v52;
  BIGNUM *v53;
  BIGNUM *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t *v57;
  uint64_t v58;
  int8x8_t v59;
  uint64_t v60;
  int8x16_t *v61;
  int8x16_t v62;
  unint64_t v63;
  int8x16_t v64;
  int8x16_t v65;
  uint64_t v66;
  unint64_t *v67;
  uint64_t v68;

  if (!*((_BYTE *)ctx + 40))
  {
    v8 = *((_QWORD *)ctx + 4);
    v9 = *((_QWORD *)ctx + 2);
    if (v9 == *((_QWORD *)ctx + 3))
    {
      if (v9)
        v10 = (3 * v9) >> 1;
      else
        v10 = 32;
      v11 = v10 > v9 && v10 >> 61 == 0;
      if (!v11 || (v12 = OPENSSL_realloc(*((_QWORD **)ctx + 1), 8 * v10)) == 0)
      {
        *((_WORD *)ctx + 20) = 257;
        goto LABEL_16;
      }
      *((_QWORD *)ctx + 1) = v12;
      *((_QWORD *)ctx + 3) = v10;
      v9 = *((_QWORD *)ctx + 2);
    }
    else
    {
      v12 = (_QWORD *)*((_QWORD *)ctx + 1);
    }
    v12[v9] = v8;
    ++*((_QWORD *)ctx + 2);
  }
LABEL_16:
  v13 = BN_CTX_get(ctx);
  v14 = BN_CTX_get(ctx);
  result = 0;
  if (!v13)
    goto LABEL_21;
  if (!v14)
    goto LABEL_21;
  result = freeze_private_key(a3, ctx);
  if (!(_DWORD)result)
    goto LABEL_21;
  v16 = *(const BIGNUM **)(a3 + 296);
  if (v16[1].neg)
    goto LABEL_20;
  v19 = *(_QWORD *)(a3 + 288);
  v20 = v16 + 1;
  v21 = *(BIGNUM **)(a3 + 304);
  top = v21[1].top;
  v23 = v16[1].top;
  if (v23 <= top)
    goto LABEL_33;
  d = v20->d;
  v25 = v23 - top;
  if ((unint64_t)(v23 - top) < 4)
  {
    v26 = 0;
    v27 = v21[1].top;
LABEL_30:
    v33 = v23 - v27;
    v34 = &d[v27];
    do
    {
      v35 = *v34++;
      *(_QWORD *)&v26 |= v35;
      --v33;
    }
    while (v33);
    goto LABEL_32;
  }
  v27 = (v25 & 0xFFFFFFFFFFFFFFFCLL) + top;
  v28 = (int8x16_t *)&d[top + 2];
  v29 = 0uLL;
  v30 = v25 & 0xFFFFFFFFFFFFFFFCLL;
  v31 = 0uLL;
  do
  {
    v29 = vorrq_s8(v28[-1], v29);
    v31 = vorrq_s8(*v28, v31);
    v28 += 2;
    v30 -= 4;
  }
  while (v30);
  v32 = vorrq_s8(v31, v29);
  v26 = vorr_s8(*(int8x8_t *)v32.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
  if (v25 != (v25 & 0xFFFFFFFFFFFFFFFCLL))
    goto LABEL_30;
LABEL_32:
  if (v26)
    goto LABEL_20;
LABEL_33:
  result = BN_from_montgomery(v13, a2, *(BN_MONT_CTX **)(a3 + 304), ctx);
  if (!(_DWORD)result)
    goto LABEL_21;
  result = BN_mod_mul_montgomery(v13, v13, v21, (BN_MONT_CTX *)v21, ctx);
  if (!(_DWORD)result)
    goto LABEL_21;
  v36 = v21 + 1;
  result = BN_mod_exp_mont_consttime(v14, v13, *(const BIGNUM **)(a3 + 328), v21 + 1, ctx, *(BN_MONT_CTX **)(a3 + 304));
  if (!(_DWORD)result)
    goto LABEL_21;
  if (v21[1].neg)
    goto LABEL_20;
  v37 = *(_QWORD *)(a3 + 296);
  v38 = *(int *)(v37 + 32);
  v39 = v21[1].top;
  if (v39 <= v38)
    goto LABEL_46;
  v40 = v36->d;
  v41 = v39 - v38;
  if ((unint64_t)(v39 - v38) < 4)
  {
    v42 = 0;
    v43 = *(int *)(v37 + 32);
LABEL_43:
    v49 = v39 - v43;
    v50 = &v40[v43];
    do
    {
      v51 = *v50++;
      *(_QWORD *)&v42 |= v51;
      --v49;
    }
    while (v49);
    goto LABEL_45;
  }
  v43 = (v41 & 0xFFFFFFFFFFFFFFFCLL) + v38;
  v44 = (int8x16_t *)&v40[v38 + 2];
  v45 = 0uLL;
  v46 = v41 & 0xFFFFFFFFFFFFFFFCLL;
  v47 = 0uLL;
  do
  {
    v45 = vorrq_s8(v44[-1], v45);
    v47 = vorrq_s8(*v44, v47);
    v44 += 2;
    v46 -= 4;
  }
  while (v46);
  v48 = vorrq_s8(v47, v45);
  v42 = vorr_s8(*(int8x8_t *)v48.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v48, v48, 8uLL));
  if (v41 != (v41 & 0xFFFFFFFFFFFFFFFCLL))
    goto LABEL_43;
LABEL_45:
  if (v42)
    goto LABEL_20;
LABEL_46:
  v52 = a2;
  v53 = *(BIGNUM **)(a3 + 296);
  result = BN_from_montgomery(v13, v52, (BN_MONT_CTX *)v37, ctx);
  if (!(_DWORD)result)
    goto LABEL_21;
  result = BN_mod_mul_montgomery(v13, v13, v53, (BN_MONT_CTX *)v53, ctx);
  if (!(_DWORD)result)
    goto LABEL_21;
  result = BN_mod_exp_mont_consttime(a1, v13, *(const BIGNUM **)(a3 + 320), v20, ctx, *(BN_MONT_CTX **)(a3 + 296));
  if (!(_DWORD)result)
    goto LABEL_21;
  if (v21[1].neg)
    goto LABEL_20;
  v54 = *(BIGNUM **)(a3 + 296);
  v55 = v54[1].top;
  v56 = v21[1].top;
  if (v56 > v55)
  {
    v57 = v36->d;
    v58 = v56 - v55;
    if ((unint64_t)(v56 - v55) >= 4)
    {
      v60 = (v58 & 0xFFFFFFFFFFFFFFFCLL) + v55;
      v61 = (int8x16_t *)&v57[v55 + 2];
      v62 = 0uLL;
      v63 = v58 & 0xFFFFFFFFFFFFFFFCLL;
      v64 = 0uLL;
      do
      {
        v62 = vorrq_s8(v61[-1], v62);
        v64 = vorrq_s8(*v61, v64);
        v61 += 2;
        v63 -= 4;
      }
      while (v63);
      v65 = vorrq_s8(v64, v62);
      v59 = vorr_s8(*(int8x8_t *)v65.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v65, v65, 8uLL));
      if (v58 == (v58 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_58:
        if (!*(_QWORD *)&v59)
          goto LABEL_59;
LABEL_20:
        ERR_put_error(4, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 740);
        result = 0;
        goto LABEL_21;
      }
    }
    else
    {
      v59 = 0;
      v60 = v54[1].top;
    }
    v66 = v56 - v60;
    v67 = &v57[v60];
    do
    {
      v68 = *v67++;
      *(_QWORD *)&v59 |= v68;
      --v66;
    }
    while (v66);
    goto LABEL_58;
  }
LABEL_59:
  result = BN_from_montgomery(v13, v14, *(BN_MONT_CTX **)(a3 + 296), ctx);
  if ((_DWORD)result)
  {
    result = BN_mod_mul_montgomery(v13, v13, v54, (BN_MONT_CTX *)v54, ctx);
    if ((_DWORD)result)
    {
      result = bn_mod_sub_consttime((uint64_t)a1, (uint64_t)a1, (uint64_t)v13, (uint64_t)v20, ctx);
      if ((_DWORD)result)
      {
        result = BN_mod_mul_montgomery(a1, a1, *(const BIGNUM **)(a3 + 336), *(BN_MONT_CTX **)(a3 + 296), ctx);
        if ((_DWORD)result)
        {
          result = bn_mul_consttime((uint64_t)a1, (uint64_t)a1, (uint64_t)&v21[1], ctx);
          if ((_DWORD)result)
          {
            result = bn_uadd_consttime((uint64_t)a1, (uint64_t)a1, (uint64_t)v14);
            if ((_DWORD)result)
            {
              BN_num_bytes((uint64_t *)(v19 + 24));
              result = bn_resize_words((uint64_t)a1, *(int *)(v19 + 32)) != 0;
            }
          }
        }
      }
    }
  }
LABEL_21:
  if (!*((_BYTE *)ctx + 40))
  {
    v17 = *((_QWORD *)ctx + 1);
    v18 = *((_QWORD *)ctx + 2) - 1;
    *((_QWORD *)ctx + 2) = v18;
    *((_QWORD *)ctx + 4) = *(_QWORD *)(v17 + 8 * v18);
  }
  return result;
}

RSA *RSA_generate_key_ex_maybe_fips(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5)
{
  unsigned int v5;
  RSA *v6;
  int v7;
  int v8;
  int v9;
  RSA *v10;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  _QWORD *v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  _BOOL4 v22;
  _BOOL4 v23;
  _BOOL4 v24;
  _BOOL4 v25;
  _BOOL4 v26;
  _BOOL4 v27;
  unsigned int v28;
  int v29;
  int v30;
  char *v31;
  char *v32;
  BN_CTX *v33;
  _QWORD *v34;
  uint64_t v35;
  BIGNUM *v36;
  BIGNUM *v37;
  BIGNUM *v38;
  BIGNUM *v39;
  BIGNUM *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t top;
  uint64_t v44;
  uint64_t v45;
  uint64_t meth;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  _QWORD *v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  _QWORD *v54;
  unint64_t *d;
  uint64_t e;
  BIGNUM *v57;
  int neg;
  int v59;
  int v60;
  BIGNUM *v61;
  uint64_t v62;
  ENGINE *engine;
  int v64;
  int v65;
  int v66;
  int v67;
  const BIGNUM *version;
  uint64_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  uint64_t *v77;
  int v78;
  uint64_t v79;
  void *v80;
  uint64_t v81;
  size_t v82;
  uint64_t *v83;
  uint64_t v84;
  size_t v85;
  uint64_t *v86;
  int v87;
  uint64_t v88;
  void *v89;
  uint64_t v90;
  size_t v91;
  uint64_t *v92;
  uint64_t v93;
  size_t v94;
  uint64_t *v95;
  int v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  size_t v100;
  uint64_t *v101;
  uint64_t v102;
  size_t v103;
  uint64_t *v104;
  int v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  size_t v109;
  uint64_t *v110;
  uint64_t v111;
  size_t v112;
  uint64_t *v113;
  int v114;
  uint64_t v115;
  void *v116;
  uint64_t v117;
  size_t v118;
  uint64_t *v119;
  uint64_t v120;
  size_t v121;
  uint64_t *v122;
  int v123;
  uint64_t v124;
  void *v125;
  uint64_t v126;
  size_t v127;
  uint64_t *v128;
  uint64_t v129;
  size_t v130;
  uint64_t *v131;
  int v132;
  uint64_t v133;
  void *v134;
  uint64_t v135;
  size_t v136;
  uint64_t *v137;
  uint64_t v138;
  size_t v139;
  uint64_t *v140;
  int v141;
  uint64_t v142;
  void *v143;
  uint64_t v144;
  size_t v145;
  uint64_t *v146;
  uint64_t v147;
  size_t v148;
  uint64_t *v149;
  int v150;
  uint64_t v151;
  void *v152;
  uint64_t v153;
  size_t v154;
  uint64_t *v155;
  uint64_t v156;
  size_t v157;
  uint64_t *v158;
  int v159;
  uint64_t v160;
  void *v161;
  uint64_t v162;
  size_t v163;
  uint64_t *v164;
  uint64_t v165;
  size_t v166;
  uint64_t *v167;
  int v168;
  uint64_t v169;
  void *v170;
  uint64_t v171;
  size_t v172;
  uint64_t *v173;
  uint64_t v174;
  size_t v175;
  uint64_t *v176;
  int v177;
  uint64_t v178;
  void *v179;
  uint64_t v180;
  size_t v181;
  uint64_t *v182;
  uint64_t v183;
  size_t v184;
  BIGNUM *v186;
  int v187;
  int n;
  unsigned int v191;
  BIGNUM *v192;
  int v193;
  unint64_t v194;
  unint64_t v195;
  uint64_t v196;
  uint64_t v197;
  BIGNUM *v198;
  BIGNUM *v200;
  int v201;

  if (!a1)
  {
    ERR_put_error(15, 0, 67, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 1254);
    return 0;
  }
  v5 = a2 & 0xFFFFFF80;
  if ((int)(a2 & 0xFFFFFF80) < 256)
  {
    ERR_clear_error();
    v6 = RSA_new_method(0);
    if (v6)
    {
      ERR_put_error(4, 0, 126, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 1073);
      v7 = ERR_peek_error();
      RSA_free(v6);
      if ((v7 & 0xFF000FFF) != 0x400008D)
        goto LABEL_11;
      ERR_clear_error();
      v6 = RSA_new_method(0);
      if (!v6)
        goto LABEL_161;
      ERR_put_error(4, 0, 126, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 1073);
      v8 = ERR_peek_error();
      RSA_free(v6);
      if ((v8 & 0xFF000FFF) != 0x400008D)
        goto LABEL_11;
      ERR_clear_error();
      v6 = RSA_new_method(0);
      if (!v6)
        goto LABEL_161;
      ERR_put_error(4, 0, 126, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 1073);
      v9 = ERR_peek_error();
      RSA_free(v6);
      if ((v9 & 0xFF000FFF) != 0x400008D)
      {
LABEL_11:
        v10 = 0;
        v6 = 0;
        goto LABEL_298;
      }
      ERR_clear_error();
      v6 = RSA_new_method(0);
      if (v6)
      {
        ERR_put_error(4, 0, 126, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 1073);
        ERR_peek_error();
        RSA_free(v6);
        goto LABEL_11;
      }
    }
LABEL_161:
    v10 = 0;
    goto LABEL_298;
  }
  v191 = a2 & 0xFFFFFF80;
  v12 = 0;
  v187 = (v5 >> 1) - 2048;
  n = 2048 - (v5 >> 1);
  v193 = v5 >> 1;
  v197 = ((v5 >> 1) - 100) >> 6;
  v195 = (v197 + 1);
  v196 = a2 >> 7;
  v194 = (v196 + 1);
  while (1)
  {
    ERR_clear_error();
    v10 = RSA_new_method(0);
    if (!v10)
      goto LABEL_172;
    v13 = *(unsigned int *)(a3 + 8);
    v14 = v13 & ((int)v13 >> 31);
    v15 = 8 * v13 - 8;
    v16 = *(_DWORD *)(a3 + 8);
    while (1)
    {
      v17 = __OFSUB__(v16--, 1);
      if (v16 < 0 != v17)
        break;
      v18 = *(_QWORD **)a3;
      v19 = *(_QWORD *)(*(_QWORD *)a3 + v15);
      v15 -= 8;
      if (v19)
      {
        v14 = v16 + 1;
        goto LABEL_21;
      }
    }
    if ((v13 & 0x80000000) == 0)
      break;
    v18 = *(_QWORD **)a3;
LABEL_21:
    v20 = v14 - 1;
    v21 = v18[v20];
    v22 = v21 != 0;
    v23 = HIDWORD(v21) != 0;
    if (HIDWORD(v21))
      v21 >>= 32;
    v24 = v21 >> 16 != 0;
    if (v21 >> 16)
      v21 >>= 16;
    v25 = v21 > 0xFF;
    if (v21 > 0xFF)
      v21 >>= 8;
    v26 = v21 > 0xF;
    if (v21 > 0xF)
      v21 >>= 4;
    v27 = v21 > 3;
    if (v21 > 3)
      v21 >>= 2;
    v28 = v22 | (v20 << 6) | (32 * v23) | (16 * v24) | (8 * v25) | (4 * v26) | (2 * v27);
    if (v21 > 1)
      ++v28;
    if (v28 < 0x21)
      break;
    v29 = 101;
    v30 = 1084;
LABEL_39:
    ERR_put_error(4, 0, v29, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", v30);
LABEL_146:
    v76 = ERR_peek_error();
    RSA_free(v10);
    v6 = 0;
    v10 = 0;
    if (v12 <= 2 && (v76 & 0xFF000000) == 0x4000000)
    {
      ++v12;
      if ((v76 & 0xFFF) == 0x8D)
        continue;
    }
    goto LABEL_298;
  }
  v31 = (char *)malloc_type_malloc(0x38uLL, 0x30772F57uLL);
  if (!v31)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v29 = 3;
    v30 = 1226;
    goto LABEL_39;
  }
  v32 = v31;
  *(_QWORD *)v31 = 48;
  *(_OWORD *)(v31 + 8) = 0u;
  v33 = (BN_CTX *)(v31 + 8);
  *(_OWORD *)(v31 + 24) = 0u;
  *(_OWORD *)(v31 + 34) = 0u;
  v34 = OPENSSL_realloc(0, 0x100uLL);
  if (v34)
  {
    *((_QWORD *)v32 + 4) = 32;
    v34[*((_QWORD *)v32 + 3)] = 0;
    v35 = *((_QWORD *)v32 + 3) + 1;
    *((_QWORD *)v32 + 2) = v34;
    *((_QWORD *)v32 + 3) = v35;
  }
  else
  {
    *((_WORD *)v32 + 24) = 257;
  }
  v36 = BN_CTX_get(v33);
  v37 = BN_CTX_get(v33);
  v38 = BN_CTX_get(v33);
  v200 = BN_CTX_get(v33);
  v39 = BN_CTX_get(v33);
  v40 = BN_CTX_get(v33);
  v198 = v36;
  if (!v36)
    goto LABEL_143;
  if (!v37)
    goto LABEL_143;
  if (!v38)
    goto LABEL_143;
  if (!v200)
    goto LABEL_143;
  if (!v39)
    goto LABEL_143;
  v41 = (uint64_t)v40;
  if (!v40)
    goto LABEL_143;
  v42 = v197;
  if (v39->top > (int)v197)
    goto LABEL_52;
  if (!bn_wexpand((uint64_t)v39, v195))
    goto LABEL_143;
  top = v39->top;
  v42 = v197;
  if ((int)top <= (int)v197)
  {
    bzero(&v39->d[top], 8 * (v197 - top) + 8);
    v42 = v197;
  }
  v39->top = v195;
LABEL_52:
  v39->d[v42] |= 0x10000000uLL;
  v44 = v196;
  if (*(_DWORD *)(v41 + 8) > (int)v196)
  {
LABEL_57:
    *(_QWORD *)(*(_QWORD *)v41 + 8 * v44) |= 1uLL;
    if (v10->version)
    {
      if (v10->engine)
        goto LABEL_59;
    }
    else
    {
      v48 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
      if (!v48)
      {
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        v10->version = 0;
        goto LABEL_143;
      }
      *v48 = 24;
      v48[2] = 0;
      v48[3] = 0x100000000;
      v48[1] = 0;
      v10->version = (uint64_t)(v48 + 1);
      if (v10->engine)
      {
LABEL_59:
        if (v10->meth)
          goto LABEL_60;
        goto LABEL_74;
      }
    }
    v49 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (!v49)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v10->engine = 0;
      goto LABEL_143;
    }
    *v49 = 24;
    v49[2] = 0;
    v49[3] = 0x100000000;
    v49[1] = 0;
    v10->engine = (ENGINE *)(v49 + 1);
    if (v10->meth)
    {
LABEL_60:
      if (v10->n)
        goto LABEL_61;
      goto LABEL_76;
    }
LABEL_74:
    v50 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (!v50)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v10->meth = 0;
      goto LABEL_143;
    }
    *v50 = 24;
    v50[2] = 0;
    v50[3] = 0x100000000;
    v50[1] = 0;
    v10->meth = (const RSA_METHOD *)(v50 + 1);
    if (v10->n)
    {
LABEL_61:
      if (v10->e)
        goto LABEL_62;
      goto LABEL_78;
    }
LABEL_76:
    v51 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (!v51)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v10->n = 0;
      goto LABEL_143;
    }
    *v51 = 24;
    v51[2] = 0;
    v51[3] = 0x100000000;
    v51[1] = 0;
    v10->n = (BIGNUM *)(v51 + 1);
    if (v10->e)
    {
LABEL_62:
      if (v10->d)
        goto LABEL_63;
      goto LABEL_80;
    }
LABEL_78:
    v52 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (!v52)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v10->e = 0;
      goto LABEL_143;
    }
    *v52 = 24;
    v52[2] = 0;
    v52[3] = 0x100000000;
    v52[1] = 0;
    v10->e = (BIGNUM *)(v52 + 1);
    if (v10->d)
    {
LABEL_63:
      if (v10->p)
        goto LABEL_64;
      goto LABEL_82;
    }
LABEL_80:
    v53 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (!v53)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v10->d = 0;
      goto LABEL_143;
    }
    *v53 = 24;
    v53[2] = 0;
    v53[3] = 0x100000000;
    v53[1] = 0;
    v10->d = (BIGNUM *)(v53 + 1);
    if (v10->p)
    {
LABEL_64:
      meth = (uint64_t)v10->meth;
      if (meth != a3)
        goto LABEL_65;
      goto LABEL_84;
    }
LABEL_82:
    v54 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (!v54)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v10->p = 0;
      goto LABEL_143;
    }
    *v54 = 24;
    v54[2] = 0;
    v54[3] = 0x100000000;
    v54[1] = 0;
    v10->p = (BIGNUM *)(v54 + 1);
    meth = (uint64_t)v10->meth;
    if (meth != a3)
    {
LABEL_65:
      if (!bn_wexpand(meth, *(int *)(a3 + 8)))
        goto LABEL_143;
      v47 = *(int *)(a3 + 8);
      if ((_DWORD)v47)
      {
        memcpy(*(void **)meth, *(const void **)a3, 8 * v47);
        LODWORD(v47) = *(_DWORD *)(a3 + 8);
      }
      *(_DWORD *)(meth + 8) = v47;
      *(_DWORD *)(meth + 16) = *(_DWORD *)(a3 + 16);
      if (!bn_wexpand((uint64_t)v200, 0x20uLL))
        goto LABEL_143;
      goto LABEL_85;
    }
LABEL_84:
    if (!bn_wexpand((uint64_t)v200, 0x20uLL))
      goto LABEL_143;
LABEL_85:
    d = v200->d;
    *((_OWORD *)d + 12) = xmmword_208F302B0;
    *((_OWORD *)d + 13) = unk_208F302C0;
    *((_OWORD *)d + 14) = xmmword_208F302D0;
    *((_OWORD *)d + 15) = unk_208F302E0;
    *((_OWORD *)d + 8) = xmmword_208F30270;
    *((_OWORD *)d + 9) = unk_208F30280;
    *((_OWORD *)d + 10) = xmmword_208F30290;
    *((_OWORD *)d + 11) = unk_208F302A0;
    *((_OWORD *)d + 4) = xmmword_208F30230;
    *((_OWORD *)d + 5) = unk_208F30240;
    *((_OWORD *)d + 6) = xmmword_208F30250;
    *((_OWORD *)d + 7) = unk_208F30260;
    *(_OWORD *)d = kBoringSSLRSASqrtTwo;
    *((_OWORD *)d + 1) = unk_208F30200;
    *((_OWORD *)d + 2) = xmmword_208F30210;
    *((_OWORD *)d + 3) = unk_208F30220;
    v200->top = 32;
    v200->neg = 0;
    if (v191 <= 0xFFF)
    {
      if (BN_rshift(v200, v200, n))
        goto LABEL_95;
      goto LABEL_143;
    }
    if (v191 != 4096 && (!BN_add_word(v200, 1uLL) || !BN_lshift(v200, v200, v187)))
      goto LABEL_143;
LABEL_95:
    v186 = v38;
    v192 = v37;
    while (1)
    {
      if (!generate_prime(v10->n, v193, (BIGNUM *)v10->meth, 0, (uint64_t)v200, (uint64_t)v39, v33, a4)
        || a4 && !(*(unsigned int (**)(uint64_t, _QWORD))(a4 + 8))(3, 0)
        || !generate_prime(v10->e, v193, (BIGNUM *)v10->meth, (uint64_t)v10->n, (uint64_t)v200, (uint64_t)v39, v33, a4)|| a4 && !(*(unsigned int (**)(uint64_t, uint64_t))(a4 + 8))(3, 1))
      {
        goto LABEL_143;
      }
      v57 = v10->n;
      e = (uint64_t)v10->e;
      if (v57)
      {
        if (e)
          break;
      }
      if (v57)
        goto LABEL_114;
      e = 0;
LABEL_116:
      v201 = 0;
      v61 = v192;
      if (pthread_once(&BN_value_one_once, (void (*)(void))BN_value_one_init))
        goto LABEL_300;
      if (!bn_usub_consttime((uint64_t)v192, e, (uint64_t)&BN_value_one_storage))
        goto LABEL_143;
      v62 = (uint64_t)v10->e;
      if (pthread_once(&BN_value_one_once, (void (*)(void))BN_value_one_init))
LABEL_300:
        abort();
      if (!bn_usub_consttime((uint64_t)v186, v62, (uint64_t)&BN_value_one_storage)
        || !bn_lcm_consttime(v198, v192, v186, v33)
        || !bn_mod_inverse_consttime((BIGNUM *)v10->engine, &v201, (BIGNUM *)v10->meth, v198, (uint64_t)v33))
      {
        goto LABEL_143;
      }
      engine = v10->engine;
      if (!engine)
      {
LABEL_133:
        if (!bn_mul_consttime(v10->version, (uint64_t)v10->n, (uint64_t)v10->e, v33)
          || !bn_div_consttime(0, v10->d, (BIGNUM *)v10->engine, v61, v193, v33)
          || !bn_div_consttime(0, v10->p, (BIGNUM *)v10->engine, v186, v193, v33))
        {
          goto LABEL_143;
        }
        version = (const BIGNUM *)v10->version;
        v69 = version->top;
        v70 = 8 * v69 - 8;
        v71 = version->top;
        while (1)
        {
          v17 = __OFSUB__(v71--, 1);
          if (v71 < 0 != v17)
            break;
          v72 = *(unint64_t *)((char *)version->d + v70);
          v70 -= 8;
          if (v72)
          {
            version->top = v71 + 1;
            goto LABEL_152;
          }
        }
        version->top = v69 & ((int)v69 >> 31);
        if ((v69 & 0x80000000) == 0)
          version->neg = 0;
LABEL_152:
        if (BN_num_bits(version) == v191)
        {
          if (!freeze_private_key((uint64_t)v10, v33))
            goto LABEL_143;
          if (RSA_check_key(v10))
          {
            v73 = 0;
            if (v32[48])
              goto LABEL_145;
          }
          else
          {
            ERR_put_error(4, 0, 124, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 1218);
            v73 = 1;
            if (v32[48])
              goto LABEL_145;
          }
        }
        else
        {
          ERR_put_error(4, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 1204);
          v73 = 1;
          if (v32[48])
            goto LABEL_145;
        }
        goto LABEL_144;
      }
      v64 = *((_DWORD *)engine + 4);
      if (v64 == *(_DWORD *)(v41 + 16))
      {
        v65 = bn_cmp_words_consttime(*(uint64_t **)engine, *((int *)engine + 2), *(uint64_t **)v41, *(int *)(v41 + 8));
        if (v64)
          v66 = -v65;
        else
          v66 = v65;
        v61 = v192;
        if (v66 >= 1)
          goto LABEL_133;
      }
      else
      {
        if (v64)
          v67 = -1;
        else
          v67 = 1;
        v61 = v192;
        if (v67 >= 1)
          goto LABEL_133;
      }
    }
    neg = v57->neg;
    if (neg == *(_DWORD *)(e + 16))
    {
      v59 = bn_cmp_words_consttime((uint64_t *)v57->d, v57->top, *(uint64_t **)e, *(int *)(e + 8));
      if (neg)
        v60 = -v59;
      else
        v60 = v59;
      if ((v60 & 0x80000000) == 0)
      {
LABEL_115:
        e = (uint64_t)v57;
        goto LABEL_116;
      }
    }
    else if (!neg)
    {
      goto LABEL_115;
    }
LABEL_114:
    v10->n = (BIGNUM *)e;
    v10->e = v57;
    goto LABEL_116;
  }
  if (bn_wexpand(v41, v194))
  {
    v45 = *(int *)(v41 + 8);
    v44 = v196;
    if ((int)v196 >= (int)v45)
    {
      bzero((void *)(*(_QWORD *)v41 + 8 * v45), 8 * (v196 - v45) + 8);
      v44 = v196;
    }
    *(_DWORD *)(v41 + 8) = v194;
    goto LABEL_57;
  }
LABEL_143:
  ERR_put_error(4, 0, 3, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 1226);
  v73 = 1;
  if (!v32[48])
  {
LABEL_144:
    v74 = *((_QWORD *)v32 + 2);
    v75 = *((_QWORD *)v32 + 3) - 1;
    *((_QWORD *)v32 + 3) = v75;
    *((_QWORD *)v32 + 5) = *(_QWORD *)(v74 + 8 * v75);
  }
LABEL_145:
  BN_CTX_free(v33);
  if (v73)
    goto LABEL_146;
  if (a5 && !RSA_check_fips(v10))
  {
LABEL_172:
    v6 = 0;
  }
  else
  {
    rsa_invalidate_key(a1);
    v77 = *(uint64_t **)(a1 + 8);
    if (v77)
    {
      v78 = *((_DWORD *)v77 + 5);
      if ((v78 & 2) == 0)
      {
        v79 = *v77;
        if (*v77)
        {
          v81 = *(_QWORD *)(v79 - 8);
          v80 = (void *)(v79 - 8);
          v82 = v81 + 8;
          if (v81 != -8)
            bzero(v80, v82);
          free(v80);
          v78 = *((_DWORD *)v77 + 5);
        }
      }
      if ((v78 & 1) != 0)
      {
        v84 = *(v77 - 1);
        v83 = v77 - 1;
        v85 = v84 + 8;
        if (v84 != -8)
          bzero(v83, v85);
        free(v83);
      }
      else
      {
        *v77 = 0;
      }
    }
    *(_QWORD *)(a1 + 8) = v10->version;
    v10->version = 0;
    v86 = *(uint64_t **)(a1 + 16);
    if (v86)
    {
      v87 = *((_DWORD *)v86 + 5);
      if ((v87 & 2) == 0)
      {
        v88 = *v86;
        if (*v86)
        {
          v90 = *(_QWORD *)(v88 - 8);
          v89 = (void *)(v88 - 8);
          v91 = v90 + 8;
          if (v90 != -8)
            bzero(v89, v91);
          free(v89);
          v87 = *((_DWORD *)v86 + 5);
        }
      }
      if ((v87 & 1) != 0)
      {
        v93 = *(v86 - 1);
        v92 = v86 - 1;
        v94 = v93 + 8;
        if (v93 != -8)
          bzero(v92, v94);
        free(v92);
      }
      else
      {
        *v86 = 0;
      }
    }
    *(_QWORD *)(a1 + 16) = v10->meth;
    v10->meth = 0;
    v95 = *(uint64_t **)(a1 + 24);
    if (v95)
    {
      v96 = *((_DWORD *)v95 + 5);
      if ((v96 & 2) == 0)
      {
        v97 = *v95;
        if (*v95)
        {
          v99 = *(_QWORD *)(v97 - 8);
          v98 = (void *)(v97 - 8);
          v100 = v99 + 8;
          if (v99 != -8)
            bzero(v98, v100);
          free(v98);
          v96 = *((_DWORD *)v95 + 5);
        }
      }
      if ((v96 & 1) != 0)
      {
        v102 = *(v95 - 1);
        v101 = v95 - 1;
        v103 = v102 + 8;
        if (v102 != -8)
          bzero(v101, v103);
        free(v101);
      }
      else
      {
        *v95 = 0;
      }
    }
    *(_QWORD *)(a1 + 24) = v10->engine;
    v10->engine = 0;
    v104 = *(uint64_t **)(a1 + 32);
    if (v104)
    {
      v105 = *((_DWORD *)v104 + 5);
      if ((v105 & 2) == 0)
      {
        v106 = *v104;
        if (*v104)
        {
          v108 = *(_QWORD *)(v106 - 8);
          v107 = (void *)(v106 - 8);
          v109 = v108 + 8;
          if (v108 != -8)
            bzero(v107, v109);
          free(v107);
          v105 = *((_DWORD *)v104 + 5);
        }
      }
      if ((v105 & 1) != 0)
      {
        v111 = *(v104 - 1);
        v110 = v104 - 1;
        v112 = v111 + 8;
        if (v111 != -8)
          bzero(v110, v112);
        free(v110);
      }
      else
      {
        *v104 = 0;
      }
    }
    *(_QWORD *)(a1 + 32) = v10->n;
    v10->n = 0;
    v113 = *(uint64_t **)(a1 + 40);
    if (v113)
    {
      v114 = *((_DWORD *)v113 + 5);
      if ((v114 & 2) == 0)
      {
        v115 = *v113;
        if (*v113)
        {
          v117 = *(_QWORD *)(v115 - 8);
          v116 = (void *)(v115 - 8);
          v118 = v117 + 8;
          if (v117 != -8)
            bzero(v116, v118);
          free(v116);
          v114 = *((_DWORD *)v113 + 5);
        }
      }
      if ((v114 & 1) != 0)
      {
        v120 = *(v113 - 1);
        v119 = v113 - 1;
        v121 = v120 + 8;
        if (v120 != -8)
          bzero(v119, v121);
        free(v119);
      }
      else
      {
        *v113 = 0;
      }
    }
    *(_QWORD *)(a1 + 40) = v10->e;
    v10->e = 0;
    v122 = *(uint64_t **)(a1 + 48);
    if (v122)
    {
      v123 = *((_DWORD *)v122 + 5);
      if ((v123 & 2) == 0)
      {
        v124 = *v122;
        if (*v122)
        {
          v126 = *(_QWORD *)(v124 - 8);
          v125 = (void *)(v124 - 8);
          v127 = v126 + 8;
          if (v126 != -8)
            bzero(v125, v127);
          free(v125);
          v123 = *((_DWORD *)v122 + 5);
        }
      }
      if ((v123 & 1) != 0)
      {
        v129 = *(v122 - 1);
        v128 = v122 - 1;
        v130 = v129 + 8;
        if (v129 != -8)
          bzero(v128, v130);
        free(v128);
      }
      else
      {
        *v122 = 0;
      }
    }
    *(_QWORD *)(a1 + 48) = v10->d;
    v10->d = 0;
    v131 = *(uint64_t **)(a1 + 56);
    if (v131)
    {
      v132 = *((_DWORD *)v131 + 5);
      if ((v132 & 2) == 0)
      {
        v133 = *v131;
        if (*v131)
        {
          v135 = *(_QWORD *)(v133 - 8);
          v134 = (void *)(v133 - 8);
          v136 = v135 + 8;
          if (v135 != -8)
            bzero(v134, v136);
          free(v134);
          v132 = *((_DWORD *)v131 + 5);
        }
      }
      if ((v132 & 1) != 0)
      {
        v138 = *(v131 - 1);
        v137 = v131 - 1;
        v139 = v138 + 8;
        if (v138 != -8)
          bzero(v137, v139);
        free(v137);
      }
      else
      {
        *v131 = 0;
      }
    }
    *(_QWORD *)(a1 + 56) = v10->p;
    v10->p = 0;
    v140 = *(uint64_t **)(a1 + 64);
    if (v140)
    {
      v141 = *((_DWORD *)v140 + 5);
      if ((v141 & 2) == 0)
      {
        v142 = *v140;
        if (*v140)
        {
          v144 = *(_QWORD *)(v142 - 8);
          v143 = (void *)(v142 - 8);
          v145 = v144 + 8;
          if (v144 != -8)
            bzero(v143, v145);
          free(v143);
          v141 = *((_DWORD *)v140 + 5);
        }
      }
      if ((v141 & 1) != 0)
      {
        v147 = *(v140 - 1);
        v146 = v140 - 1;
        v148 = v147 + 8;
        if (v147 != -8)
          bzero(v146, v148);
        free(v146);
      }
      else
      {
        *v140 = 0;
      }
    }
    *(_QWORD *)(a1 + 64) = v10->q;
    v10->q = 0;
    BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 288));
    *(_QWORD *)(a1 + 288) = v10[1]._method_mod_n;
    v10[1]._method_mod_n = 0;
    BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 296));
    *(_QWORD *)(a1 + 296) = v10[1]._method_mod_p;
    v10[1]._method_mod_p = 0;
    BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 304));
    *(_QWORD *)(a1 + 304) = v10[1]._method_mod_q;
    v10[1]._method_mod_q = 0;
    v149 = *(uint64_t **)(a1 + 312);
    if (v149)
    {
      v150 = *((_DWORD *)v149 + 5);
      if ((v150 & 2) == 0)
      {
        v151 = *v149;
        if (*v149)
        {
          v153 = *(_QWORD *)(v151 - 8);
          v152 = (void *)(v151 - 8);
          v154 = v153 + 8;
          if (v153 != -8)
            bzero(v152, v154);
          free(v152);
          v150 = *((_DWORD *)v149 + 5);
        }
      }
      if ((v150 & 1) != 0)
      {
        v156 = *(v149 - 1);
        v155 = v149 - 1;
        v157 = v156 + 8;
        if (v156 != -8)
          bzero(v155, v157);
        free(v155);
      }
      else
      {
        *v149 = 0;
      }
    }
    *(_QWORD *)(a1 + 312) = v10[1].bignum_data;
    v10[1].bignum_data = 0;
    v158 = *(uint64_t **)(a1 + 320);
    if (v158)
    {
      v159 = *((_DWORD *)v158 + 5);
      if ((v159 & 2) == 0)
      {
        v160 = *v158;
        if (*v158)
        {
          v162 = *(_QWORD *)(v160 - 8);
          v161 = (void *)(v160 - 8);
          v163 = v162 + 8;
          if (v162 != -8)
            bzero(v161, v163);
          free(v161);
          v159 = *((_DWORD *)v158 + 5);
        }
      }
      if ((v159 & 1) != 0)
      {
        v165 = *(v158 - 1);
        v164 = v158 - 1;
        v166 = v165 + 8;
        if (v165 != -8)
          bzero(v164, v166);
        free(v164);
      }
      else
      {
        *v158 = 0;
      }
    }
    *(_QWORD *)(a1 + 320) = v10[1].blinding;
    v10[1].blinding = 0;
    v167 = *(uint64_t **)(a1 + 328);
    if (v167)
    {
      v168 = *((_DWORD *)v167 + 5);
      if ((v168 & 2) == 0)
      {
        v169 = *v167;
        if (*v167)
        {
          v171 = *(_QWORD *)(v169 - 8);
          v170 = (void *)(v169 - 8);
          v172 = v171 + 8;
          if (v171 != -8)
            bzero(v170, v172);
          free(v170);
          v168 = *((_DWORD *)v167 + 5);
        }
      }
      if ((v168 & 1) != 0)
      {
        v174 = *(v167 - 1);
        v173 = v167 - 1;
        v175 = v174 + 8;
        if (v174 != -8)
          bzero(v173, v175);
        free(v173);
      }
      else
      {
        *v167 = 0;
      }
    }
    *(_QWORD *)(a1 + 328) = v10[1].mt_blinding;
    v10[1].mt_blinding = 0;
    v176 = *(uint64_t **)(a1 + 336);
    if (v176)
    {
      v177 = *((_DWORD *)v176 + 5);
      if ((v177 & 2) == 0)
      {
        v178 = *v176;
        if (*v176)
        {
          v180 = *(_QWORD *)(v178 - 8);
          v179 = (void *)(v178 - 8);
          v181 = v180 + 8;
          if (v180 != -8)
            bzero(v179, v181);
          free(v179);
          v177 = *((_DWORD *)v176 + 5);
        }
      }
      if ((v177 & 1) != 0)
      {
        v183 = *(v176 - 1);
        v182 = v176 - 1;
        v184 = v183 + 8;
        if (v183 != -8)
          bzero(v182, v184);
        free(v182);
      }
      else
      {
        *v176 = 0;
      }
    }
    *(_QWORD *)(a1 + 336) = *(_QWORD *)&v10[2].pad;
    *(_QWORD *)&v10[2].pad = 0;
    *(_BYTE *)(a1 + 376) = *(_BYTE *)(a1 + 376) & 0xFE | (uint64_t)v10[2].e & 1;
    v6 = (RSA *)1;
  }
LABEL_298:
  RSA_free(v10);
  return v6;
}

double RSA_default_method_init()
{
  double result;

  result = 0.0;
  *(__int128 *)((char *)&xmmword_2545732EC + 12) = 0u;
  unk_254573308 = 0u;
  unk_2545732D8 = 0u;
  unk_2545732E8 = 0u;
  RSA_default_method_storage = 0u;
  BYTE4(RSA_default_method_storage) = 1;
  return result;
}

uint64_t ensure_fixed_copy(uint64_t *a1, BIGNUM *a, signed int a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int8x8_t v10;
  unint64_t v11;
  uint64_t v12;
  int8x16_t *v13;
  int8x16_t v14;
  unint64_t v15;
  int8x16_t v16;
  int8x16_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  size_t v25;
  void *v26;
  uint64_t v27;
  size_t v28;

  if (*a1)
    return 1;
  result = (uint64_t)BN_dup(a);
  if (result)
  {
    v6 = result;
    v7 = *(int *)(result + 8);
    if (v7 <= a3)
    {
      if (!bn_wexpand(result, a3))
        goto LABEL_18;
      v12 = *(int *)(v6 + 8);
      if ((_DWORD)v12 != a3)
        bzero((void *)(*(_QWORD *)v6 + 8 * v12), 8 * (a3 - v12));
      goto LABEL_25;
    }
    v8 = *(_QWORD *)result;
    v9 = v7 - a3;
    if (v9 >= 4)
    {
      v11 = (v9 & 0xFFFFFFFFFFFFFFFCLL) + a3;
      v13 = (int8x16_t *)(v8 + 8 * a3 + 16);
      v14 = 0uLL;
      v15 = v9 & 0xFFFFFFFFFFFFFFFCLL;
      v16 = 0uLL;
      do
      {
        v14 = vorrq_s8(v13[-1], v14);
        v16 = vorrq_s8(*v13, v16);
        v13 += 2;
        v15 -= 4;
      }
      while (v15);
      v17 = vorrq_s8(v16, v14);
      v10 = vorr_s8(*(int8x8_t *)v17.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL));
      if (v9 == (v9 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_16:
        if (v10)
        {
          ERR_put_error(3, 0, 102, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/bn.c", 399);
LABEL_18:
          v21 = *(_DWORD *)(v6 + 20);
          if ((v21 & 2) == 0)
          {
            v22 = *(_QWORD *)v6;
            if (*(_QWORD *)v6)
            {
              v24 = *(_QWORD *)(v22 - 8);
              v23 = (void *)(v22 - 8);
              v25 = v24 + 8;
              if (v24 != -8)
                bzero(v23, v25);
              free(v23);
              v21 = *(_DWORD *)(v6 + 20);
            }
          }
          if ((v21 & 1) != 0)
          {
            v27 = *(_QWORD *)(v6 - 8);
            v26 = (void *)(v6 - 8);
            v28 = v27 + 8;
            if (v27 != -8)
              bzero(v26, v28);
            free(v26);
            return 0;
          }
          else
          {
            result = 0;
            *(_QWORD *)v6 = 0;
          }
          return result;
        }
LABEL_25:
        *(_DWORD *)(v6 + 8) = a3;
        *a1 = v6;
        return 1;
      }
    }
    else
    {
      v10 = 0;
      v11 = a3;
    }
    v18 = v7 - v11;
    v19 = (uint64_t *)(v8 + 8 * v11);
    do
    {
      v20 = *v19++;
      *(_QWORD *)&v10 |= v20;
      --v18;
    }
    while (v18);
    goto LABEL_16;
  }
  return result;
}

uint64_t generate_prime(BIGNUM *a1, int a2, BIGNUM *a3, uint64_t a4, uint64_t a5, uint64_t a6, BN_CTX *ctx, uint64_t a8)
{
  int v8;
  int v9;
  uint64_t result;
  BIGNUM *v17;
  uint64_t top;
  unint64_t *d;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int8x16_t v24;
  unsigned __int128 v25;
  int8x16_t *v26;
  unint64_t v27;
  int8x16_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  _BOOL4 v32;
  BIGNUM *v33;
  int v34;
  BOOL v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  const BIGNUM *v45;
  int v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  BOOL v50;
  _QWORD *v51;
  uint64_t v52;
  _BOOL4 v53;
  int v54;
  int v55;
  int v56;
  int neg;
  unint64_t v58;
  int8x8_t v59;
  uint64_t v60;
  unint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x16_t *v68;
  unint64_t v69;
  int8x16_t v70;
  uint64_t v71;
  unint64_t *v72;
  uint64_t v73;
  const BIGNUM *v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  _BOOL4 v80;
  int v81;
  BIGNUM *v82;
  BIGNUM *v84;
  int v85;
  int v86;
  BOOL v87;
  int v88;
  int v89;
  int v90;

  if ((a2 & 0x3F) != 0)
  {
    v8 = 68;
    v9 = 931;
LABEL_5:
    ERR_put_error(4, 0, v8, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", v9);
    return 0;
  }
  if (a2 >= 0x3FFFFFF)
  {
    v8 = 128;
    v9 = 968;
    goto LABEL_5;
  }
  v17 = a3;
  top = a3->top;
  if (!(_DWORD)top)
  {
LABEL_17:
    v32 = 0;
    if (*((_BYTE *)ctx + 40))
      goto LABEL_18;
    goto LABEL_67;
  }
  d = a3->d;
  v21 = *a3->d ^ 3;
  if ((int)top >= 2)
  {
    if (top < 5)
    {
      v22 = 1;
LABEL_14:
      v29 = top - v22;
      v30 = (uint64_t *)&d[v22];
      do
      {
        v31 = *v30++;
        v21 |= v31;
        --v29;
      }
      while (v29);
      goto LABEL_16;
    }
    v23 = (top - 1) & 0xFFFFFFFFFFFFFFFCLL;
    v22 = v23 | 1;
    v24 = 0uLL;
    v25 = *a3->d ^ (unsigned __int128)3uLL;
    v26 = (int8x16_t *)(d + 3);
    v27 = v23;
    do
    {
      v25 = (unsigned __int128)vorrq_s8(v26[-1], (int8x16_t)v25);
      v24 = vorrq_s8(*v26, v24);
      v26 += 2;
      v27 -= 4;
    }
    while (v27);
    v28 = vorrq_s8(v24, (int8x16_t)v25);
    v21 = (uint64_t)vorr_s8(*(int8x8_t *)v28.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
    if (top - 1 != v23)
      goto LABEL_14;
  }
LABEL_16:
  if (v21)
    goto LABEL_17;
  v32 = a3->neg == 0;
  if (*((_BYTE *)ctx + 40))
  {
LABEL_18:
    result = (uint64_t)BN_CTX_get(ctx);
    if (!result)
      goto LABEL_140;
    goto LABEL_19;
  }
LABEL_67:
  v47 = *((_QWORD *)ctx + 4);
  v48 = *((_QWORD *)ctx + 2);
  if (v48 == *((_QWORD *)ctx + 3))
  {
    if (v48)
      v49 = (3 * v48) >> 1;
    else
      v49 = 32;
    v50 = v49 > v48 && v49 >> 61 == 0;
    if (!v50 || (v51 = OPENSSL_realloc(*((_QWORD **)ctx + 1), 8 * v49)) == 0)
    {
      *((_WORD *)ctx + 20) = 257;
      v17 = a3;
      result = (uint64_t)BN_CTX_get(ctx);
      if (!result)
        goto LABEL_140;
      goto LABEL_19;
    }
    *((_QWORD *)ctx + 1) = v51;
    *((_QWORD *)ctx + 3) = v49;
    v48 = *((_QWORD *)ctx + 2);
    v17 = a3;
  }
  else
  {
    v51 = (_QWORD *)*((_QWORD *)ctx + 1);
  }
  v51[v48] = v47;
  ++*((_QWORD *)ctx + 2);
  result = (uint64_t)BN_CTX_get(ctx);
  if (!result)
    goto LABEL_140;
LABEL_19:
  v33 = (BIGNUM *)result;
  v34 = 5 * a2;
  if (v32)
    v34 = 8 * a2;
  if (v34 <= 1)
    v34 = 1;
  v81 = v34 - 1;
  if (!a4)
  {
    v84 = v17;
    v52 = 0;
    if (a5)
      v53 = a1 == 0;
    else
      v53 = 1;
    if (a1)
      v54 = -1;
    else
      v54 = a5 != 0;
    v88 = v54;
    while (1)
    {
      do
      {
        result = BN_rand(a1, a2, 0, 1);
        if (!(_DWORD)result)
          goto LABEL_140;
        if (a8)
        {
          result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(a8 + 8))(0, v52, a8);
          if (!(_DWORD)result)
            goto LABEL_140;
        }
        v56 = v88;
        if (!v53)
        {
          neg = a1->neg;
          if (neg == *(_DWORD *)(a5 + 16))
          {
            v55 = bn_cmp_words_consttime((uint64_t *)a1->d, a1->top, *(uint64_t **)a5, *(int *)(a5 + 8));
            if (neg)
              v56 = -v55;
            else
              v56 = v55;
          }
          else if (neg)
          {
            v56 = -1;
          }
          else
          {
            v56 = 1;
          }
        }
        v52 = (v52 + 1);
      }
      while (v56 < 1);
      v80 = v53;
      v86 = a4;
      v58 = a1->top <= 16 ? 512 : 1024;
      if (!bn_mod_u16_consttime((uint64_t)a1, 3u))
        break;
      v63 = 2;
      while (v58 != v63)
      {
        v59 = (int8x8_t)kPrimes[v63];
        if (bn_mod_u16_consttime((uint64_t)a1, kPrimes[v63++]) == 0)
        {
          if (v63 - 1 < v58)
            goto LABEL_102;
          break;
        }
      }
LABEL_118:
      v90 = 0;
      v74 = BN_value_one();
      if (!bn_usub_consttime((uint64_t)v33, (uint64_t)a1, (uint64_t)v74)
        || !bn_is_relatively_prime(&v90, v33, v84, ctx))
      {
LABEL_142:
        result = 0;
        goto LABEL_140;
      }
      if (v90)
      {
        v89 = 0;
        if (!BN_primality_test(&v89, (uint64_t **)a1, 0, (char *)ctx, 0, a8))
          goto LABEL_142;
        if (v89)
        {
LABEL_144:
          result = 1;
          goto LABEL_140;
        }
      }
LABEL_123:
      v53 = v80;
      if (v86 == v81)
      {
LABEL_143:
        ERR_put_error(4, 0, 141, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/rsa/rsa_impl.c", 1042);
        result = 0;
        goto LABEL_140;
      }
      a4 = (v86 + 1);
      if (a8)
        v75 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a8 + 8))(2, a4, a8);
      else
        v75 = 1;
      result = 0;
      if (!v75)
        goto LABEL_140;
    }
    v59 = (int8x8_t)3;
LABEL_102:
    v60 = a1->top;
    if ((_DWORD)v60)
    {
      v61 = a1->d;
      *(_QWORD *)&v59 ^= *a1->d;
      if ((int)v60 >= 2)
      {
        if (v60 < 5)
        {
          v62 = 1;
LABEL_114:
          v71 = v60 - v62;
          v72 = &v61[v62];
          do
          {
            v73 = *v72++;
            *(_QWORD *)&v59 |= v73;
            --v71;
          }
          while (v71);
          goto LABEL_116;
        }
        v65 = (v60 - 1) & 0xFFFFFFFFFFFFFFFCLL;
        v62 = v65 | 1;
        v66 = 0uLL;
        v67 = (int8x16_t)(unint64_t)v59;
        v68 = (int8x16_t *)(v61 + 3);
        v69 = v65;
        do
        {
          v67 = vorrq_s8(v68[-1], v67);
          v66 = vorrq_s8(*v68, v66);
          v68 += 2;
          v69 -= 4;
        }
        while (v69);
        v70 = vorrq_s8(v66, v67);
        v59 = vorr_s8(*(int8x8_t *)v70.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v70, v70, 8uLL));
        if (v60 - 1 != v65)
          goto LABEL_114;
      }
    }
LABEL_116:
    if (*(_QWORD *)&v59 || a1->neg)
      goto LABEL_123;
    goto LABEL_118;
  }
  if (a5)
    v35 = a1 == 0;
  else
    v35 = 1;
  if (a1)
    v36 = -1;
  else
    v36 = a5 != 0;
  v85 = v36;
  v87 = v35;
  if (a6)
  {
    v82 = v17;
    LODWORD(v37) = 0;
    v38 = 0;
LABEL_32:
    v79 = v37;
    result = BN_rand(a1, a2, 0, 1);
    if (!(_DWORD)result)
      goto LABEL_140;
    while (1)
    {
      if (a8)
      {
        result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(a8 + 8))(0, v38, a8);
        if (!(_DWORD)result)
          goto LABEL_140;
      }
      result = bn_abs_sub_consttime((uint64_t)v33, (uint64_t)a1, a4, ctx);
      if (!(_DWORD)result)
        goto LABEL_140;
      v41 = v33->neg;
      if (v41 == *(_DWORD *)(a6 + 16))
      {
        v42 = bn_cmp_words_consttime((uint64_t *)v33->d, v33->top, *(uint64_t **)a6, *(int *)(a6 + 8));
        if (v41)
          v43 = -v42;
        else
          v43 = v42;
        if (v43 <= 0)
          goto LABEL_38;
      }
      else if (v41)
      {
        goto LABEL_38;
      }
      v40 = v85;
      if (!v87)
      {
        v44 = a1->neg;
        if (v44 == *(_DWORD *)(a5 + 16))
        {
          v39 = bn_cmp_words_consttime((uint64_t *)a1->d, a1->top, *(uint64_t **)a5, *(int *)(a5 + 8));
          if (v44)
            v40 = -v39;
          else
            v40 = v39;
        }
        else if (v44)
        {
          v40 = -1;
        }
        else
        {
          v40 = 1;
        }
      }
      if (v40 >= 1)
      {
        if (!bn_odd_number_is_obviously_composite((uint64_t)a1))
        {
          v90 = 0;
          v45 = BN_value_one();
          if (!bn_usub_consttime((uint64_t)v33, (uint64_t)a1, (uint64_t)v45)
            || !bn_is_relatively_prime(&v90, v33, v82, ctx))
          {
            goto LABEL_142;
          }
          if (v90)
          {
            v89 = 0;
            if (!BN_primality_test(&v89, (uint64_t **)a1, 0, (char *)ctx, 0, a8))
              goto LABEL_142;
            if (v89)
              goto LABEL_144;
          }
        }
        if (v79 == v81)
          goto LABEL_143;
        v37 = (v79 + 1);
        if (a8)
          v46 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a8 + 8))(2, v37, a8);
        else
          v46 = 1;
        result = 0;
        v38 = (v38 + 1);
        if (v46)
          goto LABEL_32;
        goto LABEL_140;
      }
LABEL_38:
      result = BN_rand(a1, a2, 0, 1);
      v38 = (v38 + 1);
      if (!(_DWORD)result)
        goto LABEL_140;
    }
  }
  result = BN_rand(a1, a2, 0, 1);
  if ((_DWORD)result)
  {
    v76 = 0;
    do
    {
      if (a8)
      {
        result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(a8 + 8))(0, v76, a8);
        if (!(_DWORD)result)
          break;
      }
      result = bn_abs_sub_consttime((uint64_t)v33, (uint64_t)a1, a4, ctx);
      if (!(_DWORD)result)
        break;
      result = BN_rand(a1, a2, 0, 1);
      v76 = (v76 + 1);
    }
    while ((_DWORD)result);
  }
LABEL_140:
  if (!*((_BYTE *)ctx + 40))
  {
    v77 = *((_QWORD *)ctx + 1);
    v78 = *((_QWORD *)ctx + 2) - 1;
    *((_QWORD *)ctx + 2) = v78;
    *((_QWORD *)ctx + 4) = *(_QWORD *)(v77 + 8 * v78);
  }
  return result;
}

BOOL x509_rsa_pss_to_ctx(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  uint64_t *v12;
  unsigned __int8 *v13;
  const EVP_MD *digestbyobj;
  uint64_t *v15;
  _BOOL8 v16;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  const EVP_MD *v22;
  const void **v23;
  ASN1_INTEGER *v24;
  uint64_t *v25;
  uint64_t v26;
  unsigned __int8 *v27;
  unsigned __int8 *in;

  v3 = *(_QWORD *)(a2 + 8);
  if (!v3 || *(_DWORD *)v3 != 16)
    goto LABEL_16;
  v6 = *(int **)(v3 + 8);
  v27 = (unsigned __int8 *)*((_QWORD *)v6 + 1);
  v7 = *v6;
  in = 0;
  if ((int)asn1_item_ex_d2i((uint64_t)&in, &v27, v7, (uint64_t)&RSA_PSS_PARAMS_it, -1, 0, 0, 0, 0) > 0)
  {
    v8 = in;
    if (in)
      goto LABEL_5;
LABEL_16:
    ERR_put_error(11, 0, 112, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/rsa_pss.c", 264);
    v8 = 0;
    goto LABEL_17;
  }
  ASN1_item_ex_free((ASN1_VALUE **)&in, (const ASN1_ITEM *)&RSA_PSS_PARAMS_it);
  v8 = in;
  if (!in)
    goto LABEL_16;
LABEL_5:
  v9 = *((_QWORD *)v8 + 1);
  if (!v9)
  {
    ERR_put_error(11, 0, 112, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/rsa_pss.c", 184);
    v15 = *(uint64_t **)v8;
    if (*(_QWORD *)v8)
      goto LABEL_20;
LABEL_26:
    v20 = 170;
    goto LABEL_48;
  }
  if (OBJ_obj2nid(*(const ASN1_OBJECT **)v9) != 911
    || (v10 = *(_QWORD *)(v9 + 8)) == 0
    || *(_DWORD *)v10 != 16
    || (v11 = *(int **)(v10 + 8),
        in = (unsigned __int8 *)*((_QWORD *)v11 + 1),
        (v12 = (uint64_t *)d2i_X509_ALGOR(0, (const unsigned __int8 **)&in, *v11)) == 0))
  {
    ERR_put_error(11, 0, 112, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/rsa_pss.c", 190);
    v9 = 0;
    v15 = *(uint64_t **)v8;
    if (*(_QWORD *)v8)
      goto LABEL_20;
    goto LABEL_26;
  }
  v13 = (unsigned __int8 *)v12;
  digestbyobj = EVP_get_digestbyobj(*v12);
  if (!digestbyobj || (v9 = (uint64_t)digestbyobj, (digestbyobj->type - 672) >= 3))
  {
    ERR_put_error(11, 0, 112, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/rsa_pss.c", 175);
    v9 = 0;
  }
  in = v13;
  ASN1_item_ex_free((ASN1_VALUE **)&in, &X509_ALGOR_it);
  v15 = *(uint64_t **)v8;
  if (!*(_QWORD *)v8)
    goto LABEL_26;
LABEL_20:
  v18 = *v15;
  v19 = *(_DWORD *)(*v15 + 16);
  v20 = 175;
  if (v19 > 256)
  {
    switch(v19)
    {
      case 672:
        v21 = 4;
        break;
      case 673:
        v21 = 5;
        break;
      case 674:
        v21 = 6;
        break;
      case 675:
        v21 = 3;
        break;
      default:
        if (v19 == 257)
        {
          v21 = 0;
        }
        else
        {
          if (v19 != 962)
            goto LABEL_48;
          v21 = 7;
        }
        break;
    }
LABEL_41:
    v22 = (*((const EVP_MD *(**)(void))&nid_to_digest_mapping + 4 * v21 + 1))();
    goto LABEL_42;
  }
  if (v19 > 63)
  {
    if (v19 == 64)
    {
      v21 = 2;
    }
    else
    {
      if (v19 != 114)
        goto LABEL_48;
      v21 = 8;
    }
    goto LABEL_41;
  }
  if (v19)
  {
    if (v19 != 4)
    {
LABEL_48:
      ERR_put_error(11, 0, 112, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/rsa_pss.c", v20);
      goto LABEL_17;
    }
    v21 = 1;
    goto LABEL_41;
  }
  v22 = cbs_to_md(*(_QWORD *)(v18 + 24), *(_DWORD *)(v18 + 20) & ~(*(int *)(v18 + 20) >> 31));
LABEL_42:
  if (!v22 || (v22->type - 672) >= 3)
  {
    v20 = 175;
    goto LABEL_48;
  }
  if (v9)
  {
    if ((const EVP_MD *)v9 != v22)
    {
      v20 = 276;
      goto LABEL_48;
    }
    v26 = 0;
    v23 = (const void **)*((_QWORD *)v8 + 2);
    if (!v23 || !asn1_string_get_uint64(&v26, v23, 2) || v26 != *(_DWORD *)(v9 + 4))
    {
      v20 = 286;
      goto LABEL_48;
    }
    v24 = (ASN1_INTEGER *)*((_QWORD *)v8 + 3);
    if (v24 && ASN1_INTEGER_get(v24) != 1)
    {
      v20 = 295;
      goto LABEL_48;
    }
    v25 = 0;
    if (do_sigver_init(a1, &v25, v9, 0, a3, 1)
      && EVP_PKEY_CTX_set_rsa_padding(v25)
      && EVP_PKEY_CTX_ctrl(v25, 6, 24))
    {
      v16 = EVP_PKEY_CTX_ctrl(v25, 6, 248) != 0;
      goto LABEL_18;
    }
  }
LABEL_17:
  v16 = 0;
LABEL_18:
  in = v8;
  ASN1_item_ex_free((ASN1_VALUE **)&in, (const ASN1_ITEM *)&RSA_PSS_PARAMS_it);
  return v16;
}

uint64_t rsa_pss_cb(int a1, uint64_t a2)
{
  ASN1_VALUE *v2;
  ASN1_VALUE *v3;
  ASN1_VALUE *pval[3];

  if (a1 == 2)
  {
    pval[1] = v2;
    pval[2] = v3;
    pval[0] = *(ASN1_VALUE **)(*(_QWORD *)a2 + 32);
    ASN1_item_ex_free(pval, &X509_ALGOR_it);
  }
  return 1;
}

uint64_t bssl::tls_init_message(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  _QWORD *v7;
  uint64_t result;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  size_t v12;
  _BYTE *v13;

  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  v7 = malloc_type_malloc(0x48uLL, 0x30772F57uLL);
  if (v7)
  {
    *v7 = 64;
    *(_BYTE *)(a2 + 8) = 0;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 16) = v7 + 1;
    *(_OWORD *)(a2 + 24) = xmmword_208F05A00;
    *(_BYTE *)(a2 + 40) = *(_BYTE *)(a2 + 40) & 0xFC | 1;
    v13 = 0;
    if (CBB_add_space(a2, &v13, 1))
    {
      *v13 = a4;
      if (CBB_flush((uint64_t *)a2))
      {
        if (cbb_add_child(a2, a3, 3u, 0))
          return 1;
      }
    }
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  }
  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", 176);
  result = 0;
  if (!*(_BYTE *)(a2 + 8))
  {
    if ((*(_BYTE *)(a2 + 40) & 1) != 0)
    {
      v9 = *(_QWORD *)(a2 + 16);
      if (v9)
      {
        v11 = *(_QWORD *)(v9 - 8);
        v10 = (void *)(v9 - 8);
        v12 = v11 + 8;
        if (v11 != -8)
          bzero(v10, v12);
        free(v10);
      }
    }
    return 0;
  }
  return result;
}

uint64_t bssl::tls_finish_message(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return bssl::CBBFinishArray(a2, a3);
}

uint64_t bssl::tls_add_message(bssl *this, ssl_st *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  unint64_t v10;
  unint64_t method;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  size_t v17;
  uint64_t result;
  _QWORD *v19;
  size_t v20;
  char *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  size_t v27;
  void *v28;
  uint64_t v29;
  size_t v30;
  unint64_t v31;
  unsigned __int8 *v32;
  char v33;
  void (*v34)(uint64_t, _QWORD, uint64_t, _QWORD, SSL_METHOD *, bssl *, _QWORD);
  uint64_t v35;
  unsigned __int16 *v36;
  uint64_t v37;
  size_t v38;
  void *v39;
  unint64_t *v40;
  uint64_t v41;

  v10 = *(_QWORD *)&a2->version;
  method = (unint64_t)a2->method;
  if (*((_QWORD *)this + 19) || **(_QWORD **)(*((_QWORD *)this + 6) + 272))
  {
    while (1)
    {
      if (!method)
        goto LABEL_35;
      v12 = *((_QWORD *)this + 6);
      v13 = *(unint64_t **)(v12 + 232);
      if (v13)
      {
        v14 = *v13;
        v15 = *((unsigned __int16 *)this + 9);
        v16 = v15 >= v14;
        v17 = v15 - v14;
        if (v17 != 0 && v16)
          goto LABEL_9;
        result = bssl::tls_flush_pending_hs_data(this, a2, a3, a4, a5, a6, a7, a8);
        if (!(_DWORD)result)
          return result;
        v12 = *((_QWORD *)this + 6);
        v19 = *(_QWORD **)(v12 + 232);
        if (v19)
          break;
      }
      if (method >= *((unsigned __int16 *)this + 9))
        v20 = *((unsigned __int16 *)this + 9);
      else
        v20 = method;
      v22 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
      if (v22)
      {
        *v22 = 24;
        v22[1] = 0;
        v22[2] = 0;
        v22[3] = 0;
        v21 = (char *)(v10 + v20);
        v23 = *(_QWORD *)(v12 + 232);
        *(_QWORD *)(v12 + 232) = v22 + 1;
        if (v23)
          goto LABEL_20;
      }
      else
      {
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        v21 = (char *)(v10 + v20);
        v23 = *(_QWORD *)(v12 + 232);
        *(_QWORD *)(v12 + 232) = 0;
        if (v23)
        {
LABEL_20:
          v24 = *(_QWORD *)(v23 + 8);
          if (v24)
          {
            v26 = *(_QWORD *)(v24 - 8);
            v25 = (void *)(v24 - 8);
            v27 = v26 + 8;
            if (v26 != -8)
              bzero(v25, v27);
            free(v25);
          }
          v29 = *(_QWORD *)(v23 - 8);
          v28 = (void *)(v23 - 8);
          v30 = v29 + 8;
          if (v29 != -8)
            bzero(v28, v30);
          free(v28);
        }
      }
LABEL_27:
      result = *(_QWORD *)(*((_QWORD *)this + 6) + 232);
      if (result)
      {
        method -= v20;
        result = BUF_MEM_append((unint64_t *)result, (void *)v10, v20);
        v10 = (unint64_t)v21;
        if ((_DWORD)result)
          continue;
      }
      return result;
    }
    v17 = *((unsigned __int16 *)this + 9) - *v19;
LABEL_9:
    if (method >= v17)
      v20 = v17;
    else
      v20 = method;
    v21 = (char *)(v10 + v20);
    goto LABEL_27;
  }
  while (method)
  {
    if (method >= *((unsigned __int16 *)this + 9))
      v31 = *((unsigned __int16 *)this + 9);
    else
      v31 = method;
    v32 = (unsigned __int8 *)(v10 + v31);
    method -= v31;
    v33 = bssl::add_record_to_flight(this, (unsigned __int8 *)0x16, v10, (unsigned __int8 *)v31, a5, a6, a7, a8);
    v10 = (unint64_t)v32;
    if ((v33 & 1) == 0)
      return 0;
  }
LABEL_35:
  v34 = (void (*)(uint64_t, _QWORD, uint64_t, _QWORD, SSL_METHOD *, bssl *, _QWORD))*((_QWORD *)this + 8);
  if (v34)
  {
    v35 = *(_QWORD *)(*((_QWORD *)this + 6) + 280);
    if (v35 && (*(_BYTE *)(v35 + 1569) & 4) != 0 && (*((_BYTE *)this + 164) & 1) == 0)
      v36 = (unsigned __int16 *)(*(_QWORD *)(v35 + 1512) + 4);
    else
      v36 = (unsigned __int16 *)((char *)this + 16);
    v34(1, *v36, 22, *(_QWORD *)&a2->version, a2->method, this, *((_QWORD *)this + 9));
  }
  v37 = *(_QWORD *)(*((_QWORD *)this + 6) + 280);
  if (!v37)
    return 1;
  v39 = *(void **)&a2->version;
  v38 = (size_t)a2->method;
  v40 = *(unint64_t **)(v37 + 408);
  if (!v40 || (result = BUF_MEM_append(v40, v39, v38), (_DWORD)result))
  {
    v41 = *(_QWORD *)(v37 + 416);
    if (v41)
      (*(void (**)(uint64_t, void *, size_t))(v41 + 24))(v37 + 416, v39, v38);
    return 1;
  }
  return result;
}

uint64_t bssl::add_record_to_flight(bssl *this, unsigned __int8 *a2, unint64_t a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  size_t v19;
  void *v20;
  uint64_t v21;
  size_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  unint64_t *v32;
  BOOL v33;
  uint64_t v34;
  unint64_t v35;
  _BOOL4 v36;
  const char *v37;
  int v38;
  int v39;
  uint64_t result;
  unint64_t v41;
  unsigned __int8 v42[8];

  v12 = *((_QWORD *)this + 6);
  v13 = *(uint64_t **)(v12 + 240);
  if (v13)
    goto LABEL_14;
  v14 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (v14)
  {
    *v14 = 24;
    v14[1] = 0;
    v14[2] = 0;
    v14[3] = 0;
    v15 = *(_QWORD *)(v12 + 240);
    *(_QWORD *)(v12 + 240) = v14 + 1;
    if (v15)
      goto LABEL_4;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v15 = *(_QWORD *)(v12 + 240);
    *(_QWORD *)(v12 + 240) = 0;
    if (v15)
    {
LABEL_4:
      v16 = *(_QWORD *)(v15 + 8);
      if (v16)
      {
        v18 = *(_QWORD *)(v16 - 8);
        v17 = (void *)(v16 - 8);
        v19 = v18 + 8;
        if (v18 != -8)
          bzero(v17, v19);
        free(v17);
      }
      v21 = *(_QWORD *)(v15 - 8);
      v20 = (void *)(v15 - 8);
      v22 = v21 + 8;
      if (v21 != -8)
        bzero(v20, v22);
      free(v20);
      v12 = *((_QWORD *)this + 6);
      v13 = *(uint64_t **)(v12 + 240);
      if (!v13)
        return 0;
      goto LABEL_14;
    }
  }
  v12 = *((_QWORD *)this + 6);
  v13 = *(uint64_t **)(v12 + 240);
  if (!v13)
    return 0;
LABEL_14:
  v23 = *(uint64_t **)(v12 + 272);
  if (**(_BYTE **)this)
  {
    if ((*((_BYTE *)v23 + 609) & 1) != 0)
    {
      v24 = *((unsigned __int8 *)v23 + 605) + 13;
      if (*v23)
        goto LABEL_17;
    }
    else
    {
      v24 = 13;
      if (*v23)
      {
LABEL_17:
        v25 = *(unsigned __int8 *)(v23[1] + 2) + v24;
        goto LABEL_35;
      }
    }
    v25 = v24;
    goto LABEL_35;
  }
  if ((*((_BYTE *)v23 + 609) & 1) != 0)
  {
    v26 = *((unsigned __int8 *)v23 + 605);
    v27 = *v23;
    if (*v23)
      goto LABEL_20;
LABEL_28:
    v25 = v26 + 5;
    goto LABEL_35;
  }
  v26 = 0;
  v27 = *v23;
  if (!*v23)
    goto LABEL_28;
LABEL_20:
  v28 = *(unsigned __int8 *)(v23[1] + 2);
  v29 = *((unsigned __int16 *)v23 + 303);
  v30 = 5;
  if (v29 == 772)
    v30 = 6;
  v25 = v26 + v30 + v28;
  if (v29 - 769 >= 4)
  {
    if (v29 == 65277 || v29 == 65279)
      goto LABEL_35;
  }
  else if (v29 > 0x301)
  {
    goto LABEL_35;
  }
  if ((*((_BYTE *)this + 133) & 1) != 0)
    v25 <<= *(_DWORD *)(v27 + 32) != 4;
LABEL_35:
  v32 = (unint64_t *)&a4[v25];
  v33 = __CFADD__(v25, a4);
  v34 = *v13;
  v35 = (unint64_t)v32 + *v13;
  v36 = __CFADD__(*v13, v32);
  if (v33 || v36)
  {
    v37 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc";
    v38 = 16;
    v39 = 154;
    goto LABEL_47;
  }
  *(_QWORD *)v42 = 0;
  if (v13[2] >= v35)
    goto LABEL_53;
  if (v35 >= 0xFFFFFFFFFFFFFFFDLL)
  {
    v37 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/buf/buf.c";
    v38 = 7;
    v39 = 85;
LABEL_47:
    ERR_put_error(v38, 0, 69, v37, v39);
    return 0;
  }
  if (v35 >= 0xBFFFFFFFFFFFFFFDLL)
  {
    v37 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/buf/buf.c";
    v38 = 7;
    v39 = 91;
    goto LABEL_47;
  }
  v41 = (2 * (((v35 + 3) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  result = (uint64_t)OPENSSL_realloc((_QWORD *)v13[1], v41);
  if (result)
  {
    v13[1] = result;
    v13[2] = v41;
    v13 = *(uint64_t **)(*((_QWORD *)this + 6) + 240);
    v34 = *v13;
LABEL_53:
    result = bssl::tls_seal_record(this, (ssl_st *)(v13[1] + v34), v42, v32, a2, a3, a4, a8);
    if ((_DWORD)result)
    {
      **(_QWORD **)(*((_QWORD *)this + 6) + 240) += *(_QWORD *)v42;
      return 1;
    }
  }
  return result;
}

uint64_t bssl::tls_flush_pending_hs_data(bssl *this, ssl_st *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v16;
  uint64_t v17;
  size_t v18;
  void *v19;
  uint64_t v20;
  size_t v21;

  v8 = *((_QWORD *)this + 6);
  v9 = *(_QWORD *)(v8 + 232);
  if (!v9)
    return 1;
  v10 = *(unsigned __int8 **)v9;
  if (!*(_QWORD *)v9)
    return 1;
  *(_QWORD *)(v8 + 232) = 0;
  v11 = *((_QWORD *)this + 19);
  if (!v11)
  {
    v13 = bssl::add_record_to_flight(this, (unsigned __int8 *)0x16, *(_QWORD *)(v9 + 8), v10, a5, a6, a7, a8);
    v14 = *(_QWORD *)(v9 + 8);
    if (!v14)
      goto LABEL_16;
    goto LABEL_13;
  }
  v12 = *(_QWORD *)(*((_QWORD *)this + 6) + 280);
  if (v12 && (*(_BYTE *)(v12 + 1570) & 8) != 0 || (*(unsigned int (**)(void))(v11 + 16))())
  {
    v13 = 1;
    v14 = *(_QWORD *)(v9 + 8);
    if (!v14)
      goto LABEL_16;
LABEL_13:
    v17 = *(_QWORD *)(v14 - 8);
    v16 = (void *)(v14 - 8);
    v18 = v17 + 8;
    if (v17 != -8)
      bzero(v16, v18);
    free(v16);
    goto LABEL_16;
  }
  ERR_put_error(16, 0, 298, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", 257);
  v13 = 0;
  v14 = *(_QWORD *)(v9 + 8);
  if (v14)
    goto LABEL_13;
LABEL_16:
  v20 = *(_QWORD *)(v9 - 8);
  v19 = (void *)(v9 - 8);
  v21 = v20 + 8;
  if (v20 != -8)
    bzero(v19, v21);
  free(v19);
  return v13;
}

uint64_t bssl::tls_add_change_cipher_spec(bssl *this, ssl_st *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  void (*v13)(uint64_t, _QWORD, uint64_t, void *, uint64_t, bssl *, _QWORD);
  uint64_t v14;
  unsigned __int16 *v15;

  if (!bssl::tls_flush_pending_hs_data(this, a2, a3, a4, a5, a6, a7, a8)
    || !*((_QWORD *)this + 19)
    && !bssl::add_record_to_flight(this, (unsigned __int8 *)0x14, (unint64_t)&bssl::tls_add_change_cipher_spec(ssl_st *)::kChangeCipherSpec, (unsigned __int8 *)1, v9, v10, v11, v12))
  {
    return 0;
  }
  v13 = (void (*)(uint64_t, _QWORD, uint64_t, void *, uint64_t, bssl *, _QWORD))*((_QWORD *)this + 8);
  if (!v13)
    return 1;
  v14 = *(_QWORD *)(*((_QWORD *)this + 6) + 280);
  if (v14 && (*(_BYTE *)(v14 + 1569) & 4) != 0 && (*((_BYTE *)this + 164) & 1) == 0)
    v15 = (unsigned __int16 *)(*(_QWORD *)(v14 + 1512) + 4);
  else
    v15 = (unsigned __int16 *)((char *)this + 16);
  v13(1, *v15, 20, &bssl::tls_add_change_cipher_spec(ssl_st *)::kChangeCipherSpec, 1, this, *((_QWORD *)this + 9));
  return 1;
}

uint64_t bssl::tls_flush_flight(bssl *this, ssl_st *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  ssl_st *v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(_QWORD, unint64_t);
  uint64_t v21;
  int v22;
  uint64_t v23;
  BUF_MEM *v24;
  int v25;
  int v26;

  if (!bssl::tls_flush_pending_hs_data(this, a2, a3, a4, a5, a6, a7, a8))
    return 0xFFFFFFFFLL;
  v10 = *((_QWORD *)this + 19);
  if (v10)
  {
    if (*(_DWORD *)(*((_QWORD *)this + 6) + 176))
    {
      ERR_put_error(16, 0, 194, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", 291);
      return 0xFFFFFFFFLL;
    }
    if (!(*(unsigned int (**)(bssl *))(v10 + 24))(this))
    {
      ERR_put_error(16, 0, 298, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", 296);
      return 0xFFFFFFFFLL;
    }
  }
  v12 = *((_QWORD *)this + 6);
  v13 = *(_QWORD **)(v12 + 240);
  if (!v13)
    return 1;
  if (*(_DWORD *)(v12 + 176))
  {
    ERR_put_error(16, 0, 194, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", 306);
    return 0xFFFFFFFFLL;
  }
  if (*v13 >> 31)
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", 312);
    return 0xFFFFFFFFLL;
  }
  if (*(_WORD *)(v12 + 114))
  {
    result = bssl::ssl_write_buffer_flush(this, v9);
    if ((int)result <= 0)
    {
LABEL_35:
      *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 3;
      return result;
    }
  }
  v14 = *((_QWORD *)this + 4);
  if (!v14)
  {
    ERR_put_error(16, 0, 119, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", 327);
    return 0xFFFFFFFFLL;
  }
  v15 = *((_QWORD *)this + 6);
  v16 = *(unsigned int *)(v15 + 248);
  v17 = *(unint64_t **)(v15 + 240);
  v18 = *v17;
  if (*v17 <= v16)
  {
LABEL_25:
    v22 = BIO_flush(v14);
    v23 = *((_QWORD *)this + 6);
    if (v22 <= 0)
    {
      *(_DWORD *)(v23 + 196) = 3;
      return 0xFFFFFFFFLL;
    }
    v24 = *(BUF_MEM **)(v23 + 240);
    *(_QWORD *)(v23 + 240) = 0;
    if (v24)
      ASN1_STRING_free(v24);
    *(_DWORD *)(*((_QWORD *)this + 6) + 248) = 0;
    return 1;
  }
  while (1)
  {
    v19 = *((_QWORD *)this + 4);
    if (!v19
      || !*(_QWORD *)v19
      || (v20 = *(uint64_t (**)(_QWORD, unint64_t))(*(_QWORD *)v19 + 16)) == 0)
    {
      v25 = 115;
      v26 = 167;
LABEL_34:
      ERR_put_error(17, 0, v25, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v26);
      result = 4294967294;
      goto LABEL_35;
    }
    if (!*(_DWORD *)(v19 + 16))
    {
      v25 = 114;
      v26 = 171;
      goto LABEL_34;
    }
    if ((int)v18 - (int)v16 < 1)
      break;
    result = v20(*((_QWORD *)this + 4), v17[1] + v16);
    if ((int)result <= 0)
      goto LABEL_35;
    *(_QWORD *)(v19 + 64) += result;
    v21 = *((_QWORD *)this + 6);
    v16 = (*(_DWORD *)(v21 + 248) + result);
    *(_DWORD *)(v21 + 248) = v16;
    v17 = *(unint64_t **)(v21 + 240);
    v18 = *v17;
    if (*v17 <= v16)
    {
      v14 = *((_QWORD *)this + 4);
      goto LABEL_25;
    }
  }
  result = 0;
  *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 3;
  return result;
}

uint64_t bssl::tls_get_message(uint64_t a1, uint64_t a2)
{
  unint64_t *v2;
  unint64_t v3;
  _BYTE *v4;
  BOOL v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v10;
  int v11;
  __int16 v12;
  void (*v13)(_QWORD, _QWORD, uint64_t);
  uint64_t v14;
  unsigned __int16 *v15;

  v2 = *(unint64_t **)(*(_QWORD *)(a1 + 48) + 224);
  if (!v2)
    return 0;
  v3 = *v2;
  if (!*v2)
    return 0;
  v4 = (_BYTE *)v2[1];
  *(_BYTE *)(a2 + 1) = *v4;
  v5 = v3 >= 4;
  v6 = v3 - 4;
  if (!v5)
    return 0;
  v7 = (v4[1] << 16) | (v4[2] << 8) | v4[3];
  if (v6 < v7)
    return 0;
  *(_QWORD *)(a2 + 8) = v4 + 4;
  *(_QWORD *)(a2 + 16) = v7;
  v10 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(*(_QWORD *)(v10 + 224) + 8);
  *(_QWORD *)(a2 + 32) = (v7 + 4);
  v11 = (*(unsigned __int8 *)(v10 + 220) >> 3) & 1;
  *(_BYTE *)a2 = (*(_BYTE *)(v10 + 220) & 8) != 0;
  v12 = *(_WORD *)(v10 + 220);
  if ((v12 & 0x10) == 0)
  {
    if (!v11)
    {
      v13 = *(void (**)(_QWORD, _QWORD, uint64_t))(a1 + 64);
      if (v13)
      {
        v14 = *(_QWORD *)(v10 + 280);
        if (v14 && (*(_BYTE *)(v14 + 1569) & 4) != 0 && (*(_BYTE *)(a1 + 164) & 1) == 0)
          v15 = (unsigned __int16 *)(*(_QWORD *)(v14 + 1512) + 4);
        else
          v15 = (unsigned __int16 *)(a1 + 16);
        v13(0, *v15, 22);
        v10 = *(_QWORD *)(a1 + 48);
        v12 = *(_WORD *)(v10 + 220);
      }
    }
    *(_WORD *)(v10 + 220) = v12 | 0x10;
  }
  return 1;
}

uint64_t bssl::tls_can_accept_handshake_data(bssl *this, const ssl_st *a2, unsigned __int8 *a3)
{
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;

  v4 = *((_QWORD *)this + 6);
  v5 = *(_QWORD **)(v4 + 224);
  if (!v5 || (v6 = *v5 - 4, *v5 < 4uLL))
  {
    v7 = 4;
    v8 = *(_QWORD *)(v4 + 280);
    if (!v8)
      goto LABEL_11;
LABEL_4:
    if ((*(_BYTE *)(v8 + 1568) & 8) == 0)
    {
      if ((*((_BYTE *)this + 164) & 1) == 0 || (*(_BYTE *)(*((_QWORD *)this + 1) + 236) & 1) != 0)
      {
        LODWORD(v12) = *((_DWORD *)this + 34);
        if (v12 <= 0x4000)
          v12 = 0x4000;
        else
          v12 = v12;
        if (v7 <= v12 + 4)
          return 1;
      }
      else if (v7 <= 0x4004)
      {
        return 1;
      }
      goto LABEL_15;
    }
LABEL_11:
    if (*((_WORD *)this + 8) == 772)
    {
      v10 = 0x4000;
      if ((*((_BYTE *)this + 164) & 1) != 0)
        v10 = 1;
      if (v7 <= v10 + 4)
        return 1;
    }
    else if (v7 <= 4)
    {
      return 1;
    }
LABEL_15:
    ERR_put_error(16, 0, 150, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", 530);
    result = 0;
    LOBYTE(a2->version) = 47;
    return result;
  }
  v9 = (*(unsigned __int8 *)(v5[1] + 1) << 16) | (*(unsigned __int8 *)(v5[1] + 2) << 8) | *(unsigned __int8 *)(v5[1] + 3);
  if (v6 < v9)
  {
    v7 = (v9 + 4);
    v8 = *(_QWORD *)(v4 + 280);
    if (!v8)
      goto LABEL_11;
    goto LABEL_4;
  }
  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", 523);
  result = 0;
  LOBYTE(a2->version) = 80;
  return result;
}

BOOL bssl::tls_has_unprocessed_handshake_data(bssl *this, const ssl_st *a2)
{
  uint64_t v2;
  __int16 v3;
  _QWORD *v4;
  unint64_t v6;

  v2 = *((_QWORD *)this + 6);
  v3 = *(_WORD *)(v2 + 220);
  v4 = *(_QWORD **)(v2 + 224);
  if ((v3 & 0x10) == 0)
  {
    if (v4)
      return *v4 != 0;
    return 0;
  }
  if (!v4)
    return 0;
  if (*v4 < 4uLL)
    return *v4 != 0;
  v6 = (*(unsigned __int8 *)(v4[1] + 1) << 16) | (*(unsigned __int8 *)(v4[1] + 2) << 8) | *(unsigned __int8 *)(v4[1] + 3);
  if (*v4 - 4 >= v6)
    return *v4 > (unint64_t)(v6 + 4);
  else
    return *v4 != 0;
}

unint64_t *bssl::tls_append_handshake_data(uint64_t a1, void *__src, size_t __n)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  size_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;
  unint64_t *result;

  v6 = *(_QWORD *)(a1 + 48);
  if (*(_QWORD *)(v6 + 224))
    goto LABEL_13;
  v7 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (v7)
  {
    *v7 = 24;
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = 0;
    v8 = *(_QWORD *)(v6 + 224);
    *(_QWORD *)(v6 + 224) = v7 + 1;
    if (!v8)
      goto LABEL_13;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v8 = *(_QWORD *)(v6 + 224);
    *(_QWORD *)(v6 + 224) = 0;
    if (!v8)
      goto LABEL_13;
  }
  v9 = *(_QWORD *)(v8 + 8);
  if (v9)
  {
    v11 = *(_QWORD *)(v9 - 8);
    v10 = (void *)(v9 - 8);
    v12 = v11 + 8;
    if (v11 != -8)
      bzero(v10, v12);
    free(v10);
  }
  v14 = *(_QWORD *)(v8 - 8);
  v13 = (void *)(v8 - 8);
  v15 = v14 + 8;
  if (v14 != -8)
    bzero(v13, v15);
  free(v13);
LABEL_13:
  result = *(unint64_t **)(*(_QWORD *)(a1 + 48) + 224);
  if (result)
    return (unint64_t *)(BUF_MEM_append(result, __src, __n) != 0);
  return result;
}

uint64_t bssl::tls_open_handshake(uint64_t a1, uint64_t *a2, ssl_st *a3, char *__s2, unint64_t a5)
{
  uint64_t v10;
  __int16 v11;
  uint64_t result;
  int v13;
  int v14;
  int v15;
  int v16;
  void *v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  char v22;
  BUF_MEM *v23;
  unint64_t *v24;
  void *v25;
  size_t v26;
  char v27;

  *a2 = 0;
  if ((*(_BYTE *)(a1 + 164) & 1) == 0 || (v10 = *(_QWORD *)(a1 + 48), v11 = *(_WORD *)(v10 + 220), (v11 & 4) != 0))
  {
LABEL_19:
    v27 = 0;
    v25 = 0;
    v26 = 0;
    result = bssl::tls_open_record((bssl *)a1, &v27, (uint64_t)&v25, a2, a3, (unsigned __int8 *)__s2, a5);
    if ((_DWORD)result)
      return result;
    if ((*(_BYTE *)(a1 + 164) & 1) != 0 || v27 != 23)
    {
      if (v27 == 22)
      {
        v17 = v25;
        v18 = v26;
        v19 = *(_QWORD *)(a1 + 48);
        if (!*(_QWORD *)(v19 + 224))
        {
          v20 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
          if (v20)
          {
            *v20 = 24;
            v20[1] = 0;
            v21 = v20 + 1;
            v20[2] = 0;
            v20[3] = 0;
          }
          else
          {
            ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
            v21 = 0;
          }
          v23 = *(BUF_MEM **)(v19 + 224);
          *(_QWORD *)(v19 + 224) = v21;
          if (v23)
            ASN1_STRING_free(v23);
        }
        v24 = *(unint64_t **)(*(_QWORD *)(a1 + 48) + 224);
        if (v24 && BUF_MEM_append(v24, v17, v18))
          return 0;
        v22 = 80;
        goto LABEL_30;
      }
    }
    else if (!**(_QWORD **)(*(_QWORD *)(a1 + 48) + 264))
    {
      v15 = 281;
      v16 = 619;
LABEL_29:
      ERR_put_error(16, 0, v15, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", v16);
      v22 = 10;
LABEL_30:
      LOBYTE(a3->version) = v22;
      return 4;
    }
    v15 = 225;
    v16 = 625;
    goto LABEL_29;
  }
  if (a5 <= 4)
  {
    *a2 = 5;
    return 2;
  }
  if (!strncmp("GET ", __s2, 4uLL)
    || !strncmp("POST ", __s2, 5uLL)
    || !strncmp("HEAD ", __s2, 5uLL)
    || !strncmp("PUT ", __s2, 4uLL))
  {
    v13 = 156;
    v14 = 581;
LABEL_17:
    ERR_put_error(16, 0, v13, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", v14);
    LOBYTE(a3->version) = 0;
    return 4;
  }
  if (!strncmp("CONNE", __s2, 5uLL))
  {
    v13 = 155;
    v14 = 586;
    goto LABEL_17;
  }
  if ((*__s2 & 0x80000000) == 0 || __s2[2] != 1 || __s2[3] != 3)
  {
    *(_WORD *)(v10 + 220) = v11 | 4;
    goto LABEL_19;
  }
  result = bssl::read_v2_client_hello((_QWORD *)a1, (unint64_t *)a2, __s2, a5);
  if ((_DWORD)result)
  {
    if ((_DWORD)result == 4)
      LOBYTE(a3->version) = 0;
  }
  else
  {
    *(_WORD *)(*(_QWORD *)(a1 + 48) + 220) |= 4u;
  }
  return result;
}

uint64_t bssl::read_v2_client_hello(_QWORD *a1, unint64_t *a2, _BYTE *a3, unint64_t a4)
{
  unint64_t v4;
  int v5;
  int v6;
  unint64_t v8;
  uint64_t v9;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  void (*v21)(_QWORD, uint64_t, _QWORD, uint64_t, size_t, _QWORD *, _QWORD);
  unint64_t v22;
  size_t v23;
  unint64_t v24;
  size_t v25;
  unint64_t v26;
  unsigned int v27;
  size_t v28;
  __int128 v29;
  uint64_t v30;
  BUF_MEM *v31;
  BUF_MEM *v32;
  uint64_t v33;
  uint64_t v34;
  int v36;
  int v37;
  _QWORD v38[6];
  uint64_t v39[6];
  _OWORD v40[3];
  _BYTE *v41;
  _OWORD v42[2];
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  *a2 = 0;
  if (a4 < 2)
    goto LABEL_62;
  v4 = a3[1] | ((unint64_t)(*a3 & 0x7F) << 8);
  if (v4 > 0x1000)
  {
    v5 = 200;
    v6 = 362;
LABEL_45:
    ERR_put_error(16, 0, v5, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", v6);
    return 4;
  }
  if (v4 <= 2)
  {
    v5 = 199;
    v6 = 369;
    goto LABEL_45;
  }
  v8 = v4 + 2;
  if (a4 >= v4 + 2)
  {
    v11 = a1[6];
    v12 = *(unsigned __int16 *)(v11 + 90);
    if (v12 > 1)
    {
      v13 = *(_QWORD *)(v11 + 80);
      v14 = *(unsigned __int16 *)(v11 + 88);
      v15 = v13 + v14;
      v16 = v12 - 2;
      if (v16 >= v4)
        v17 = a3[1] | ((unint64_t)(*a3 & 0x7F) << 8);
      else
        v17 = v16;
      v18 = *(_QWORD *)(v11 + 280);
      v19 = *(unint64_t **)(v18 + 408);
      if (v19 && !BUF_MEM_append(v19, (void *)(v13 + v14 + 2), v17))
        return 4;
      v20 = *(_QWORD *)(v18 + 416);
      if (v20)
        (*(void (**)(uint64_t, uint64_t, size_t))(v20 + 24))(v18 + 416, v13 + v14 + 2, v17);
      v21 = (void (*)(_QWORD, uint64_t, _QWORD, uint64_t, size_t, _QWORD *, _QWORD))a1[8];
      if (v21)
        v21(0, 2, 0, v13 + v14 + 2, v17, a1, a1[9]);
      if (v17 < 3
        || v17 - 3 < 2
        || v17 - 5 < 2
        || v17 - 7 < 2
        || (v22 = __rev16(*(unsigned __int16 *)(v15 + 5)), v23 = v17 - 9 - v22, v17 - 9 < v22)
        || (v24 = __rev16(*(unsigned __int16 *)(v15 + 7)), v25 = v23 - v24, v23 < v24)
        || (v26 = __rev16(*(unsigned __int16 *)(v15 + 9)), v25 != v26))
      {
        v5 = 137;
        v6 = 402;
        goto LABEL_45;
      }
      v27 = *(unsigned __int16 *)(v15 + 3);
      if (v26 >= 0x20)
        v28 = 32;
      else
        v28 = v26;
      v29 = 0uLL;
      memset(v42, 0, sizeof(v42));
      if (v28)
      {
        memcpy((char *)&v42[2] - v28, (const void *)(v15 + 11 + v22 + v24), v28);
        v29 = 0uLL;
      }
      v40[1] = v29;
      v40[2] = v29;
      v40[0] = v29;
      v30 = a1[6];
      if (!*(_QWORD *)(v30 + 224))
      {
        v31 = BUF_MEM_new();
        v32 = *(BUF_MEM **)(v30 + 224);
        *(_QWORD *)(v30 + 224) = v31;
        if (v32)
          ASN1_STRING_free(v32);
      }
      v33 = *(_QWORD *)(a1[6] + 224);
      if (v33)
      {
        if (BUF_MEM_reserve(v33, (((43691 * v22) >> 16) & 0xFFFELL) + 43))
        {
          if (CBB_init_fixed((uint64_t)v40, *(_QWORD *)(*(_QWORD *)(a1[6] + 224) + 8), *(_QWORD *)(*(_QWORD *)(a1[6] + 224) + 16)))
          {
            v39[0] = 0;
            if (CBB_add_space((uint64_t)v40, v39, 1))
            {
              *(_BYTE *)v39[0] = 1;
              if (CBB_add_u24_length_prefixed((uint64_t *)v40, (uint64_t)v39))
              {
                if (CBB_add_u16((uint64_t)v39, bswap32(v27) >> 16))
                {
                  if (CBB_add_bytes((uint64_t)v39, v42, 0x20uLL))
                  {
                    v38[0] = 0;
                    if (CBB_add_space((uint64_t)v39, v38, 1))
                    {
                      *(_BYTE *)v38[0] = 0;
                      if (CBB_add_u16_length_prefixed(v39, (uint64_t)v38))
                      {
                        if (v22)
                        {
                          v34 = v14 + v13 + 13;
                          while (v22 > 2)
                          {
                            if (!*(_BYTE *)(v34 - 2)
                              && !CBB_add_u16((uint64_t)v38, bswap32(*(unsigned __int16 *)(v34 - 1)) >> 16))
                            {
                              v36 = 68;
                              v37 = 458;
                              goto LABEL_59;
                            }
                            v34 += 3;
                            v22 -= 3;
                            if (!v22)
                              goto LABEL_53;
                          }
                          v36 = 137;
                          v37 = 449;
                        }
                        else
                        {
LABEL_53:
                          v41 = 0;
                          if (CBB_add_space((uint64_t)v39, &v41, 1))
                          {
                            *v41 = 1;
                            v41 = 0;
                            if (CBB_add_space((uint64_t)v39, &v41, 1))
                            {
                              *v41 = 0;
                              if (CBB_finish((uint64_t)v40, 0, *(_QWORD **)(a1[6] + 224)))
                              {
                                *a2 = v8;
                                v9 = 0;
                                *(_WORD *)(a1[6] + 220) |= 8u;
LABEL_61:
                                CBB_cleanup((uint64_t)v40);
                                return v9;
                              }
                            }
                          }
                          v36 = 68;
                          v37 = 467;
                        }
LABEL_59:
                        ERR_put_error(16, 0, v36, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_both.cc", v37);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v9 = 4;
      goto LABEL_61;
    }
LABEL_62:
    abort();
  }
  *a2 = v8;
  return 2;
}

void bssl::tls_next_message(bssl *this, ssl_st *a2)
{
  uint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  size_t v13;
  _QWORD *v14;
  uint64_t v15;
  size_t v16;
  _BYTE v17[32];
  unint64_t v18;

  if (bssl::tls_get_message((uint64_t)this, (uint64_t)v17))
  {
    v3 = *((_QWORD *)this + 6);
    v4 = *(uint64_t **)(v3 + 224);
    if (v4)
    {
      v5 = *v4;
      v6 = v18;
      if (*v4 >= v18)
      {
        if (*v4 == v18)
        {
          v6 = *v4;
        }
        else
        {
          memmove((void *)v4[1], (const void *)(v4[1] + v18), *v4 - v18);
          v3 = *((_QWORD *)this + 6);
          v4 = *(uint64_t **)(v3 + 224);
          v5 = *v4;
        }
        *v4 = v5 - v6;
        *(_WORD *)(v3 + 220) &= ~8u;
        *(_WORD *)(*((_QWORD *)this + 6) + 220) &= ~0x10u;
        v7 = *((_QWORD *)this + 6);
        v8 = *(_QWORD *)(v7 + 280);
        if (!v8 || (*(_BYTE *)(v8 + 1568) & 8) != 0)
        {
          v9 = *(_QWORD **)(v7 + 224);
          if (!*v9)
          {
            *(_QWORD *)(v7 + 224) = 0;
            v10 = v9[1];
            if (v10)
            {
              v12 = *(_QWORD *)(v10 - 8);
              v11 = (void *)(v10 - 8);
              v13 = v12 + 8;
              if (v12 != -8)
                bzero(v11, v13);
              free(v11);
            }
            v15 = *(v9 - 1);
            v14 = v9 - 1;
            v16 = v15 + 8;
            if (v15 != -8)
              bzero(v14, v16);
            free(v14);
          }
        }
      }
    }
  }
}

uint64_t bssl::ssl_tls13_cipher_meets_policy(int a1, int a2)
{
  unsigned int v2;

  v2 = (3u >> ((a1 - 1) & 7)) & 1;
  if ((a1 - 4865) >= 3)
    v2 = 0;
  if (a2 != 1)
    v2 = 0;
  if (a2 == 2)
    v2 = ((a1 - 4865) < 3) & (a1 - 4865);
  if (a2)
    return v2;
  else
    return 1;
}

_DWORD *bssl::ssl_choose_tls13_cipher(unsigned __int16 *a1, unint64_t a2, char a3, unsigned int a4, int a5)
{
  _DWORD *v5;
  unint64_t v6;
  int v10;
  BOOL v11;
  _DWORD *v12;
  int v13;
  unsigned int v14;
  unsigned __int16 v15;
  int v16;
  int v17;
  _DWORD *v20;
  int v21;
  unsigned int v22;
  unsigned __int16 v23;
  int v24;
  _BYTE __key[16];
  unsigned int v27;

  v5 = 0;
  if (a2)
  {
    v6 = a2;
    if ((a2 & 1) == 0)
    {
      v5 = 0;
      v10 = 0;
      if ((a3 & 1) != 0)
      {
        while (1)
        {
          v11 = v6 >= 2;
          v6 -= 2;
          if (!v11)
            return 0;
          v27 = (bswap32(*a1) >> 16) | 0x3000000;
          v12 = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
          if (v12)
          {
            if (v12[5] == 8)
            {
              if (a4 != 772)
                goto LABEL_8;
            }
            else
            {
              v13 = v12[6];
              if (v13 == 16)
              {
                if (a4 < 0x304)
                  goto LABEL_8;
              }
              else
              {
                if (v12[9] == 1)
                  v14 = 768;
                else
                  v14 = 771;
                if (v14 > a4)
                  goto LABEL_8;
              }
              if (v13 == 16)
                v15 = 772;
              else
                v15 = 771;
              if (a4 > v15)
                goto LABEL_8;
            }
            if (!a5)
              goto LABEL_5;
            v16 = *((unsigned __int16 *)v12 + 8);
            if (a5 == 1)
            {
              if ((v16 - 4865) <= 1)
                goto LABEL_5;
            }
            else if (a5 == 2 && v16 == 4866)
            {
LABEL_5:
              if (v10 != 1)
                v5 = v12;
              v10 = 1;
            }
          }
LABEL_8:
          ++a1;
          if (!v6)
            return v5;
        }
      }
      v17 = 0;
      do
      {
        v11 = v6 >= 2;
        v6 -= 2;
        if (!v11)
          return 0;
        v27 = (bswap32(*a1) >> 16) | 0x3000000;
        v20 = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
        if (v20)
        {
          if (v20[5] == 8)
          {
            if (a4 != 772)
              goto LABEL_43;
          }
          else
          {
            v21 = v20[6];
            if (v21 == 16)
            {
              if (a4 < 0x304)
                goto LABEL_43;
            }
            else
            {
              if (v20[9] == 1)
                v22 = 768;
              else
                v22 = 771;
              if (v22 > a4)
                goto LABEL_43;
            }
            if (v21 == 16)
              v23 = 772;
            else
              v23 = 771;
            if (a4 > v23)
              goto LABEL_43;
          }
          if (!a5)
            goto LABEL_34;
          v24 = *((unsigned __int16 *)v20 + 8);
          if (a5 == 2)
          {
            if (v24 == 4866)
              goto LABEL_34;
          }
          else if (a5 == 1 && (v24 - 4865) < 2)
          {
LABEL_34:
            if (v17 != 1 || (v20[7] == 32) > v10)
            {
              LOBYTE(v10) = v20[7] == 32;
              v5 = v20;
            }
            v17 = 1;
          }
        }
LABEL_43:
        ++a1;
      }
      while (v6);
    }
  }
  return v5;
}

void bssl::SSL3_STATE::~SSL3_STATE(bssl::SSL3_STATE *this)
{
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  size_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  size_t v18;
  ssl_session_st *v19;
  unsigned int i;
  unsigned int v21;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v24;
  uint64_t **v25;
  uint64_t **v26;
  uint64_t v27;
  size_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  size_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  size_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  size_t v43;
  void *v44;
  uint64_t v45;
  size_t v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  size_t v51;
  void *v52;
  uint64_t v53;
  size_t v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  size_t v59;
  void *v60;
  uint64_t v61;
  size_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  void **v67;
  void **v68;

  v2 = (_QWORD *)((char *)this + 576);
  v3 = *((_QWORD *)this + 72);
  if (v3)
  {
    v5 = *(_QWORD *)(v3 - 8);
    v4 = (void *)(v3 - 8);
    v6 = v5 + 8;
    if (v5 != -8)
      bzero(v4, v6);
    free(v4);
  }
  *v2 = 0;
  v2[1] = 0;
  v7 = *((_QWORD *)this + 63);
  *((_QWORD *)this + 63) = 0;
  if (v7)
  {
    v9 = *(_QWORD *)(v7 - 8);
    v8 = (void *)(v7 - 8);
    v10 = v9 + 8;
    if (v9 != -8)
      bzero(v8, v10);
    free(v8);
  }
  v11 = *((_QWORD *)this + 61);
  if (v11)
  {
    v13 = *(_QWORD *)(v11 - 8);
    v12 = (void *)(v11 - 8);
    v14 = v13 + 8;
    if (v13 != -8)
      bzero(v12, v14);
    free(v12);
  }
  *((_QWORD *)this + 61) = 0;
  *((_QWORD *)this + 62) = 0;
  v15 = *((_QWORD *)this + 59);
  if (v15)
  {
    v17 = *(_QWORD *)(v15 - 8);
    v16 = (void *)(v15 - 8);
    v18 = v17 + 8;
    if (v17 != -8)
      bzero(v16, v18);
    free(v16);
  }
  *((_QWORD *)this + 59) = 0;
  *((_QWORD *)this + 60) = 0;
  v19 = (ssl_session_st *)*((_QWORD *)this + 58);
  *((_QWORD *)this + 58) = 0;
  if (v19)
  {
    for (i = atomic_load((unsigned int *)v19); i != -1; i = v21)
    {
      if (!i)
        abort();
      v21 = __ldaxr((unsigned int *)v19);
      if (v21 == i)
      {
        if (!__stlxr(i - 1, (unsigned int *)v19))
        {
          if (i == 1)
          {
            ssl_session_st::~ssl_session_st(v19);
            tlsext_tick_lifetime_hint = v19[-1].tlsext_tick_lifetime_hint;
            p_tlsext_tick_lifetime_hint = &v19[-1].tlsext_tick_lifetime_hint;
            v24 = tlsext_tick_lifetime_hint + 8;
            if (tlsext_tick_lifetime_hint != -8)
              bzero(p_tlsext_tick_lifetime_hint, v24);
            free(p_tlsext_tick_lifetime_hint);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  v25 = (uint64_t **)*((_QWORD *)this + 35);
  *((_QWORD *)this + 35) = 0;
  if (v25)
  {
    bssl::SSL_HANDSHAKE::~SSL_HANDSHAKE(v25);
    v27 = (uint64_t)*(v25 - 1);
    v26 = v25 - 1;
    v28 = v27 + 8;
    if (v27 != -8)
      bzero(v26, v28);
    free(v26);
  }
  v29 = *((_QWORD *)this + 34);
  *((_QWORD *)this + 34) = 0;
  if (v29)
  {
    v30 = *(_QWORD *)(v29 + 8);
    if (v30)
    {
      (*(void (**)(uint64_t))(v30 + 24))(v29 + 8);
      *(_QWORD *)(v29 + 8) = 0;
    }
    v32 = *(_QWORD *)(v29 - 8);
    v31 = (void *)(v29 - 8);
    v33 = v32 + 8;
    if (v32 != -8)
      bzero(v31, v33);
    free(v31);
  }
  v34 = *((_QWORD *)this + 33);
  *((_QWORD *)this + 33) = 0;
  if (v34)
  {
    v35 = *(_QWORD *)(v34 + 8);
    if (v35)
    {
      (*(void (**)(uint64_t))(v35 + 24))(v34 + 8);
      *(_QWORD *)(v34 + 8) = 0;
    }
    v37 = *(_QWORD *)(v34 - 8);
    v36 = (void *)(v34 - 8);
    v38 = v37 + 8;
    if (v37 != -8)
      bzero(v36, v38);
    free(v36);
  }
  v39 = *((_QWORD *)this + 30);
  *((_QWORD *)this + 30) = 0;
  if (v39)
  {
    v40 = *(_QWORD *)(v39 + 8);
    if (v40)
    {
      v42 = *(_QWORD *)(v40 - 8);
      v41 = (void *)(v40 - 8);
      v43 = v42 + 8;
      if (v42 != -8)
        bzero(v41, v43);
      free(v41);
    }
    v45 = *(_QWORD *)(v39 - 8);
    v44 = (void *)(v39 - 8);
    v46 = v45 + 8;
    if (v45 != -8)
      bzero(v44, v46);
    free(v44);
  }
  v47 = *((_QWORD *)this + 29);
  *((_QWORD *)this + 29) = 0;
  if (v47)
  {
    v48 = *(_QWORD *)(v47 + 8);
    if (v48)
    {
      v50 = *(_QWORD *)(v48 - 8);
      v49 = (void *)(v48 - 8);
      v51 = v50 + 8;
      if (v50 != -8)
        bzero(v49, v51);
      free(v49);
    }
    v53 = *(_QWORD *)(v47 - 8);
    v52 = (void *)(v47 - 8);
    v54 = v53 + 8;
    if (v53 != -8)
      bzero(v52, v54);
    free(v52);
  }
  v55 = *((_QWORD *)this + 28);
  *((_QWORD *)this + 28) = 0;
  if (v55)
  {
    v56 = *(_QWORD *)(v55 + 8);
    if (v56)
    {
      v58 = *(_QWORD *)(v56 - 8);
      v57 = (void *)(v56 - 8);
      v59 = v58 + 8;
      if (v58 != -8)
        bzero(v57, v59);
      free(v57);
    }
    v61 = *(_QWORD *)(v55 - 8);
    v60 = (void *)(v55 - 8);
    v62 = v61 + 8;
    if (v61 != -8)
      bzero(v60, v62);
    free(v60);
  }
  v63 = *((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = 0;
  if (v63)
  {
    if (*(_QWORD *)(v63 + 8))
    {
      v64 = 0;
      v65 = 0;
      do
      {
        v66 = *(_QWORD *)v63 + v64;
        free(*(void **)(v66 + 8));
        *(_QWORD *)v66 = 0;
        *(_QWORD *)(v66 + 8) = 0;
        *(_QWORD *)(v66 + 16) = 0;
        ++v65;
        v64 += 24;
      }
      while (v65 < *(_QWORD *)(v63 + 8));
    }
    free(*(void **)v63);
    free((void *)v63);
  }
  v67 = (void **)((char *)this + 104);
  if (*((_BYTE *)this + 123))
    free(*v67);
  *((_BYTE *)this + 123) = 0;
  *v67 = 0;
  *(_QWORD *)((char *)this + 110) = 0;
  v68 = (void **)((char *)this + 80);
  if (*((_BYTE *)this + 99))
    free(*v68);
  *((_BYTE *)this + 99) = 0;
  *v68 = 0;
  *(_QWORD *)((char *)this + 86) = 0;
}

uint64_t bssl::tls_new(char **this, ssl_st *a2)
{
  char *v3;
  _QWORD *v4;
  bssl::SSL3_STATE *v5;
  uint64_t *v6;
  char v7;
  _DWORD *v8;
  _DWORD *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;
  char v16;
  _DWORD *v17;
  _DWORD *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  size_t v24;
  uint64_t **v25;
  uint64_t **v26;
  uint64_t v27;
  size_t v28;
  uint64_t **v30;

  v3 = (char *)malloc_type_malloc(0x260uLL, 0x30772F57uLL);
  if (!v3)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v4 = v3;
  *(_QWORD *)v3 = 600;
  *(_OWORD *)(v3 + 8) = 0u;
  v5 = (bssl::SSL3_STATE *)(v3 + 8);
  v3[107] = 0;
  v3[131] = 0;
  *((_QWORD *)v3 + 14) = 0;
  *(_QWORD *)(v3 + 118) = 0;
  *((_DWORD *)v3 + 45) = 0;
  *((_DWORD *)v3 + 46) = 0;
  *((_DWORD *)v3 + 56) = 0;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_OWORD *)(v3 + 86) = 0u;
  *(_OWORD *)(v3 + 136) = 0u;
  *(_OWORD *)(v3 + 152) = 0u;
  *(_OWORD *)(v3 + 161) = 0u;
  *((_QWORD *)v3 + 25) = 0;
  *((_QWORD *)v3 + 26) = 0;
  *(_QWORD *)(v3 + 213) = 0;
  *((_QWORD *)v3 + 24) = 0;
  *((_WORD *)v3 + 114) &= 0x8000u;
  v6 = (uint64_t *)(v3 + 272);
  *(_OWORD *)(v3 + 232) = 0u;
  *(_OWORD *)(v3 + 248) = 0u;
  *((_DWORD *)v3 + 66) = 0;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  *((_OWORD *)v3 + 19) = 0u;
  *((_OWORD *)v3 + 20) = 0u;
  *((_OWORD *)v3 + 21) = 0u;
  *((_OWORD *)v3 + 22) = 0u;
  *((_OWORD *)v3 + 23) = 0u;
  *((_OWORD *)v3 + 24) = 0u;
  *((_OWORD *)v3 + 25) = 0u;
  *((_OWORD *)v3 + 26) = 0u;
  *((_OWORD *)v3 + 27) = 0u;
  *((_OWORD *)v3 + 28) = 0u;
  *(_QWORD *)(v3 + 463) = 0;
  *(_OWORD *)(v3 + 472) = 0u;
  *(_OWORD *)(v3 + 488) = 0u;
  *(_OWORD *)(v3 + 504) = 0u;
  *(_OWORD *)(v3 + 520) = 0u;
  *(_OWORD *)(v3 + 536) = 0u;
  *(_OWORD *)(v3 + 552) = 0u;
  *(_OWORD *)(v3 + 568) = 0u;
  *(_OWORD *)(v3 + 584) = 0u;
  *((_QWORD *)v3 + 75) = 0;
  v7 = **this;
  v8 = malloc_type_malloc(0x270uLL, 0x30772F57uLL);
  if (v8)
  {
    v9 = v8;
    *(_QWORD *)v8 = 616;
    v10 = (char *)(v8 + 2);
    v8[153] = 0;
    bzero(v8 + 2, 0x250uLL);
    *((_BYTE *)v9 + 616) = v7;
    *((_BYTE *)v9 + 617) &= 0xE0u;
    *((_QWORD *)v9 + 75) = 0;
    v9[152] = 0;
    v11 = *v6;
    *v6 = (uint64_t)v10;
    if (!v11)
      goto LABEL_12;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v11 = *v6;
    *v6 = 0;
    if (!v11)
      goto LABEL_12;
  }
  v12 = *(_QWORD *)(v11 + 8);
  if (v12)
  {
    (*(void (**)(uint64_t))(v12 + 24))(v11 + 8);
    *(_QWORD *)(v11 + 8) = 0;
  }
  v14 = *(_QWORD *)(v11 - 8);
  v13 = (void *)(v11 - 8);
  v15 = v14 + 8;
  if (v14 != -8)
    bzero(v13, v15);
  free(v13);
LABEL_12:
  v16 = **this;
  v17 = malloc_type_malloc(0x270uLL, 0x30772F57uLL);
  if (v17)
  {
    v18 = v17;
    *(_QWORD *)v17 = 616;
    v19 = (char *)(v17 + 2);
    v17[153] = 0;
    bzero(v17 + 2, 0x250uLL);
    *((_BYTE *)v18 + 616) = v16;
    *((_BYTE *)v18 + 617) &= 0xE0u;
    *((_QWORD *)v18 + 75) = 0;
    v18[152] = 0;
    v20 = v4[35];
    v4[35] = v19;
    if (!v20)
      goto LABEL_21;
LABEL_16:
    v21 = *(_QWORD *)(v20 + 8);
    if (v21)
    {
      (*(void (**)(uint64_t))(v21 + 24))(v20 + 8);
      *(_QWORD *)(v20 + 8) = 0;
    }
    v23 = *(_QWORD *)(v20 - 8);
    v22 = (void *)(v20 - 8);
    v24 = v23 + 8;
    if (v23 != -8)
      bzero(v22, v24);
    free(v22);
    goto LABEL_21;
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  v20 = v4[35];
  v4[35] = 0;
  if (v20)
    goto LABEL_16;
LABEL_21:
  bssl::ssl_handshake_new((bssl *)this, &v30);
  v25 = (uint64_t **)v4[36];
  v4[36] = v30;
  if (v25)
  {
    bssl::SSL_HANDSHAKE::~SSL_HANDSHAKE(v25);
    v27 = (uint64_t)*(v25 - 1);
    v26 = v25 - 1;
    v28 = v27 + 8;
    if (v27 != -8)
      bzero(v26, v28);
    free(v26);
  }
  if (*v6 && v4[35] && v4[36])
  {
    this[6] = (char *)v5;
    *((_WORD *)this + 8) = 771;
    return 1;
  }
  bssl::SSL3_STATE::~SSL3_STATE(v5);
  if (*v4 != -8)
    __memset_chk();
  free(v4);
  return 0;
}

void bssl::tls_free(bssl *this, ssl_st *a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  size_t v6;

  if (this)
  {
    v3 = *((_QWORD *)this + 6);
    if (v3)
    {
      bssl::SSL3_STATE::~SSL3_STATE(*((bssl::SSL3_STATE **)this + 6));
      v5 = *(_QWORD *)(v3 - 8);
      v4 = (void *)(v3 - 8);
      v6 = v5 + 8;
      if (v5 != -8)
        bzero(v4, v6);
      free(v4);
      *((_QWORD *)this + 6) = 0;
    }
  }
}

uint64_t bssl::tls_write_app_data(bssl *this, _BYTE *a2, unint64_t *a3, uint64_t a4, unint64_t a5)
{
  uint64_t v5;
  int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t result;
  unint64_t v13;
  uint64_t v14;
  int v15;
  _BYTE *v16;
  const unsigned __int8 *v17;
  BOOL v18;
  unsigned int v20;
  unsigned int v21;
  unint64_t v22;
  const unsigned __int8 *v23;
  unint64_t v24;
  unsigned __int16 v25;
  unint64_t v26;

  *a2 = 0;
  v5 = *((_QWORD *)this + 6);
  if (*(_DWORD *)(v5 + 176))
  {
    v6 = 194;
    v7 = 140;
  }
  else
  {
    v8 = *(_QWORD *)(v5 + 144);
    v9 = a5 - v8;
    if (a5 >= v8)
    {
      v13 = a4 + v8;
      if ((*((_BYTE *)this + 164) & 1) != 0
        || (v14 = *(_QWORD *)(v5 + 280)) == 0
        || (v15 = *(_DWORD *)(v14 + 1568), (v15 & 0x400) == 0))
      {
        v16 = (char *)this + 132;
        goto LABEL_12;
      }
      v16 = (char *)this + 132;
      if ((v15 & 0x2000) != 0)
      {
        v20 = *(unsigned __int16 *)(v14 + 1576);
        v21 = *(_DWORD *)(*(_QWORD *)(v14 + 1512) + 372);
        if (v21 <= v20)
        {
LABEL_36:
          *(_QWORD *)(v5 + 144) = v8;
          *(_DWORD *)(v14 + 1568) &= ~0x2000u;
          *a2 = 1;
          return 0xFFFFFFFFLL;
        }
        while (1)
        {
          v22 = *((unsigned __int16 *)this + 9);
          if (v21 - v20 < v22)
            v22 = v21 - v20;
          v23 = (const unsigned __int8 *)(v9 >= v22 ? v22 : v9);
          v26 = 0;
          result = bssl::do_tls_write(this, (ssl_st *)&v26, (unsigned __int8 *)0x17, v13, v23);
          if ((int)result < 1)
            break;
          v24 = v26;
          v18 = v9 >= v26;
          v9 -= v26;
          if (!v18)
            goto LABEL_38;
          v8 += v26;
          v5 = *((_QWORD *)this + 6);
          v14 = *(_QWORD *)(v5 + 280);
          v25 = *(_WORD *)(v14 + 1576) + v26;
          *(_WORD *)(v14 + 1576) = v25;
          if (!v9 || (*v16 & 1) != 0)
            goto LABEL_22;
          v13 += v24;
          v20 = v25;
          v21 = *(_DWORD *)(*(_QWORD *)(v14 + 1512) + 372);
          if (v21 <= v20)
            goto LABEL_36;
        }
      }
      else
      {
LABEL_12:
        while (1)
        {
          v17 = v9 >= *((unsigned __int16 *)this + 9)
              ? (const unsigned __int8 *)*((unsigned __int16 *)this + 9)
              : (const unsigned __int8 *)v9;
          v26 = 0;
          result = bssl::do_tls_write(this, (ssl_st *)&v26, (unsigned __int8 *)0x17, v13, v17);
          if ((int)result < 1)
            break;
          v18 = v9 >= v26;
          v9 -= v26;
          if (!v18)
LABEL_38:
            abort();
          v8 += v26;
          if (!v9 || (*v16 & 1) != 0)
          {
            v5 = *((_QWORD *)this + 6);
LABEL_22:
            *(_QWORD *)(v5 + 144) = 0;
            *a3 = v8;
            return 1;
          }
          v13 += v26;
        }
      }
      *(_QWORD *)(*((_QWORD *)this + 6) + 144) = v8;
      return result;
    }
    v6 = 111;
    v7 = 152;
  }
  ERR_put_error(16, 0, v6, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_pkt.cc", v7);
  return 0xFFFFFFFFLL;
}

uint64_t bssl::do_tls_write(bssl *this, ssl_st *a2, unsigned __int8 *a3, unint64_t a4, const unsigned __int8 *a5)
{
  uint64_t v10;
  unint64_t v11;
  uint64_t result;
  ssl_st *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  const ssl_st *v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  size_t v28;
  const void *v29;
  unint64_t v30;
  uint64_t v31;
  const unsigned __int8 *v32;
  BOOL v33;
  _BOOL4 v34;
  int v35;
  ssl_st *v36;
  int v37;
  uint64_t v38;
  BUF_MEM *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned __int8 v43[8];

  v10 = *((_QWORD *)this + 6);
  v11 = *(_QWORD *)(v10 + 160);
  if (v11
    && (v11 > (unint64_t)a5
     || (*((_BYTE *)this + 132) & 2) == 0 && *(_QWORD *)(v10 + 152) != a4
     || *(unsigned __int8 *)(v10 + 168) != (_DWORD)a3))
  {
    v22 = 118;
    v23 = 212;
LABEL_10:
    ERR_put_error(16, 0, v22, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_pkt.cc", v23);
    return 0xFFFFFFFFLL;
  }
  result = bssl::ssl_write_buffer_flush(this, a2);
  if ((int)result < 1)
    return result;
  v20 = *((_QWORD *)this + 6);
  v21 = *(_QWORD *)(v20 + 160);
  if (v21)
  {
    *(_QWORD *)&a2->version = v21;
    result = 1;
    *(_QWORD *)(v20 + 152) = 0;
    *(_QWORD *)(v20 + 160) = 0;
    return result;
  }
  if ((unint64_t)a5 > 0x4000 || *(_WORD *)(v20 + 114))
  {
    v22 = 68;
    v23 = 232;
    goto LABEL_10;
  }
  if (!bssl::tls_flush_pending_hs_data(this, v13, v14, v15, v16, v17, v18, v19))
    return 0xFFFFFFFFLL;
  v25 = *((_QWORD *)this + 6);
  v26 = *(_QWORD **)(v25 + 240);
  if (v26)
  {
    v27 = *(unsigned int *)(v25 + 248);
    v28 = *v26 - v27;
    if (*v26 < v27)
      goto LABEL_48;
    v29 = (const void *)(v26[1] + v27);
  }
  else
  {
    v28 = 0;
    v29 = 0;
  }
  v30 = v28;
  if (a5)
  {
    v31 = SSL_max_seal_overhead((uint64_t)this);
    v32 = &a5[v31];
    v33 = __CFADD__(v31, a5);
    v30 = (unint64_t)&v32[v28];
    v34 = __CFADD__(v32, v28);
    if (v33 || v34)
    {
      v22 = 69;
      v23 = 256;
      goto LABEL_10;
    }
  }
  if (!v30)
  {
    *(_QWORD *)&a2->version = 0;
    return 1;
  }
  v35 = bssl::ssl_seal_align_prefix_len(this, v24);
  if (!bssl::SSLBuffer::EnsureCap((void **)(v20 + 104), v35 + (int)v28, v30))
    return 0xFFFFFFFFLL;
  if (v28)
  {
    memcpy((void *)(*(_QWORD *)(v20 + 104) + *(unsigned __int16 *)(v20 + 112) + *(unsigned __int16 *)(v20 + 114)), v29, v28);
    v38 = *((_QWORD *)this + 6);
    v39 = *(BUF_MEM **)(v38 + 240);
    *(_QWORD *)(v38 + 240) = 0;
    if (v39)
      ASN1_STRING_free(v39);
    *(_DWORD *)(*((_QWORD *)this + 6) + 248) = 0;
    v40 = *(unsigned __int16 *)(v20 + 114);
    if ((unint64_t)*(unsigned __int16 *)(v20 + 116) - v40 < v28)
      goto LABEL_48;
    *(_WORD *)(v20 + 114) = v40 + v28;
  }
  if (!a5)
    goto LABEL_41;
  *(_QWORD *)v43 = 0;
  if (!bssl::tls_seal_record(this, (ssl_st *)(*(_QWORD *)(v20 + 104)+ *(unsigned __int16 *)(v20 + 112)+ *(unsigned __int16 *)(v20 + 114)), v43, (unint64_t *)(*(unsigned __int16 *)(v20 + 116)- (unint64_t)*(unsigned __int16 *)(v20 + 114)), a3, a4, a5, v37))return 0xFFFFFFFFLL;
  v41 = *(unsigned __int16 *)(v20 + 114);
  if ((unint64_t)*(unsigned __int16 *)(v20 + 116) - v41 < *(_QWORD *)v43)
LABEL_48:
    abort();
  *(_WORD *)(v20 + 114) = v41 + *(_WORD *)v43;
LABEL_41:
  *(_WORD *)(*((_QWORD *)this + 6) + 220) &= ~0x200u;
  result = bssl::ssl_write_buffer_flush(this, v36);
  if ((int)result > 0)
  {
    *(_QWORD *)&a2->version = a5;
    return 1;
  }
  if (a5)
  {
    v42 = *((_QWORD *)this + 6);
    *(_QWORD *)(v42 + 152) = a4;
    *(_QWORD *)(v42 + 160) = a5;
    *(_BYTE *)(*((_QWORD *)this + 6) + 168) = (_BYTE)a3;
  }
  return result;
}

uint64_t bssl::tls_open_app_data(uint64_t a1, _OWORD *a2, uint64_t *a3, ssl_st *a4, unsigned __int8 *a5, unint64_t a6)
{
  uint64_t result;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  __int128 v17;
  char v18;

  v18 = 0;
  v17 = 0uLL;
  result = bssl::tls_open_record((bssl *)a1, &v18, (uint64_t)&v17, a3, a4, a5, a6);
  if (!(_DWORD)result)
  {
    if ((*(_BYTE *)(a1 + 164) & 1) != 0)
    {
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 280);
      if (v10)
        LODWORD(v10) = (*(unsigned __int8 *)(v10 + 1569) >> 2) & 1;
    }
    else
    {
      LODWORD(v10) = 0;
    }
    if (v18 != 23)
    {
      if (v18 == 22)
      {
        if ((*(_BYTE *)(a1 + 164) & 1) != 0 && *(_WORD *)(a1 + 16) != 772)
        {
          ERR_put_error(16, 0, 182, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_pkt.cc", 330);
          v11 = 100;
          goto LABEL_17;
        }
        if ((bssl::tls_append_handshake_data(a1, (void *)v17, *((size_t *)&v17 + 1)) & 1) == 0)
        {
          v11 = 80;
LABEL_17:
          LOBYTE(a4->version) = v11;
          return 4;
        }
        return 1;
      }
      v15 = 225;
      v16 = 343;
LABEL_16:
      ERR_put_error(16, 0, v15, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_pkt.cc", v16);
      v11 = 10;
      goto LABEL_17;
    }
    v12 = *((_QWORD *)&v17 + 1);
    if ((_DWORD)v10)
    {
      v13 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 280);
      v14 = *(unsigned __int16 *)(v13 + 1574);
      if (*((_QWORD *)&v17 + 1) > (unint64_t)(14336 - v14))
      {
        v15 = 300;
        v16 = 350;
        goto LABEL_16;
      }
      *(_WORD *)(v13 + 1574) = v14 + WORD4(v17);
    }
    if (v12)
    {
      result = 0;
      *a2 = v17;
      return result;
    }
    return 1;
  }
  return result;
}

uint64_t bssl::tls_open_change_cipher_spec(uint64_t a1, uint64_t *a2, ssl_st *a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t result;
  void (*v8)(_QWORD, _QWORD, uint64_t);
  uint64_t v9;
  unsigned __int16 *v10;
  _BYTE *v11;
  uint64_t v12;
  char v13;

  v13 = 0;
  v11 = 0;
  v12 = 0;
  result = bssl::tls_open_record((bssl *)a1, &v13, (uint64_t)&v11, a2, a3, a4, a5);
  if (!(_DWORD)result)
  {
    if (v13 == 20)
    {
      if (v12 == 1 && *v11 == 1)
      {
        v8 = *(void (**)(_QWORD, _QWORD, uint64_t))(a1 + 64);
        if (v8)
        {
          v9 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 280);
          if (v9 && (*(_BYTE *)(v9 + 1569) & 4) != 0 && (*(_BYTE *)(a1 + 164) & 1) == 0)
            v10 = (unsigned __int16 *)(*(_QWORD *)(v9 + 1512) + 4);
          else
            v10 = (unsigned __int16 *)(a1 + 16);
          v8(0, *v10, 20);
        }
        return 0;
      }
      else
      {
        ERR_put_error(16, 0, 103, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_pkt.cc", 383);
        LOBYTE(a3->version) = 47;
        return 4;
      }
    }
    else
    {
      ERR_put_error(16, 0, 225, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_pkt.cc", 377);
      LOBYTE(a3->version) = 10;
      return 4;
    }
  }
  return result;
}

void bssl::ssl_send_alert(bssl *this, ssl_st *a2, int a3)
{
  int v4;
  void **v6;
  void **v7;
  uint64_t v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  void **v13;

  v4 = (int)a2;
  v6 = (void **)ERR_save_state();
  v7 = v6;
  v8 = *((_QWORD *)this + 6);
  if (*(_DWORD *)(v8 + 176))
  {
    ERR_put_error(16, 0, 194, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_pkt.cc", 412);
    ERR_restore_state(v7);
    if (!v7)
      return;
  }
  else
  {
    if (a3)
      v9 = 0;
    else
      v9 = v4 == 1;
    if (v9)
      v10 = 1;
    else
      v10 = 2;
    *(_DWORD *)(v8 + 176) = v10;
    *(_WORD *)(v8 + 220) |= 0x800u;
    *(_BYTE *)(*((_QWORD *)this + 6) + 461) = v4;
    *(_BYTE *)(*((_QWORD *)this + 6) + 462) = a3;
    if (*(_WORD *)(*((_QWORD *)this + 6) + 114))
    {
      ERR_restore_state(v6);
      if (!v7)
        return;
    }
    else
    {
      (*(void (**)(bssl *))(*(_QWORD *)this + 80))(this);
      ERR_restore_state(v7);
      if (!v7)
        return;
    }
  }
  if (v7[1])
  {
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = (void **)((char *)*v7 + v11);
      free(v13[1]);
      *v13 = 0;
      v13[1] = 0;
      v13[2] = 0;
      ++v12;
      v11 += 24;
    }
    while (v12 < (unint64_t)v7[1]);
  }
  free(*v7);
  free(v7);
}

uint64_t bssl::tls_dispatch_alert(bssl *this, ssl_st *a2)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(void);
  void (*v8)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, bssl *, _QWORD);
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  void (*v13)(bssl *, uint64_t, _QWORD);
  char v14;

  v3 = *((_QWORD *)this + 19);
  if (v3)
  {
    if (!(*(unsigned int (**)(bssl *, _QWORD, _QWORD))(v3 + 32))(this, *(unsigned int *)(*((_QWORD *)this + 6) + 204), *(unsigned __int8 *)(*((_QWORD *)this + 6) + 462)))
    {
      ERR_put_error(16, 0, 298, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_pkt.cc", 441);
      return 0;
    }
  }
  else
  {
    result = bssl::do_tls_write(this, (ssl_st *)&v14, (unsigned __int8 *)0x15, *((_QWORD *)this + 6) + 461, (const unsigned __int8 *)2);
    if ((int)result < 1)
      return result;
  }
  *(_WORD *)(*((_QWORD *)this + 6) + 220) &= ~0x800u;
  v5 = *((_QWORD *)this + 6);
  if (*(_BYTE *)(v5 + 461) == 2)
  {
    v6 = *((_QWORD *)this + 4);
    if (v6)
    {
      if (*(_QWORD *)v6 && (v7 = *(void (**)(void))(*(_QWORD *)v6 + 48)) != 0)
        v7();
      else
        ERR_put_error(17, 0, 115, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 217);
    }
    v5 = *((_QWORD *)this + 6);
  }
  v8 = (void (*)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, bssl *, _QWORD))*((_QWORD *)this + 8);
  if (v8)
  {
    v9 = v5 + 461;
    v10 = *(_QWORD *)(v5 + 280);
    if (v10 && (*(_BYTE *)(v10 + 1569) & 4) != 0 && (*((_BYTE *)this + 164) & 1) == 0)
      v11 = (unsigned __int16 *)(*(_QWORD *)(v10 + 1512) + 4);
    else
      v11 = (unsigned __int16 *)((char *)this + 16);
    v8(1, *v11, 21, v9, 2, this, *((_QWORD *)this + 9));
    v5 = *((_QWORD *)this + 6);
  }
  v12 = *(unsigned __int16 *)(v5 + 461);
  v13 = (void (*)(bssl *, uint64_t, _QWORD))*((_QWORD *)this + 12);
  if (v13 || (v13 = *(void (**)(bssl *, uint64_t, _QWORD))(*((_QWORD *)this + 13) + 384)) != 0)
    v13(this, 16392, __rev16(v12));
  return 1;
}

unint64_t *ec_simple_scalar_inv0_montgomery(uint64_t a1, unint64_t *a2, int a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v14;
  _QWORD v15[9];

  v15[8] = *MEMORY[0x24BDAC8D0];
  v3 = *(int *)(a1 + 264);
  if (v3 >= 0xA)
    abort();
  if ((_DWORD)v3)
  {
    __memcpy_chk();
    v7 = v14;
    v14 -= 2;
    if ((_DWORD)v3 != 1 && v7 <= 1)
    {
      v9 = v3 - 2;
      v10 = v15;
      do
      {
        v11 = v9;
        if ((*v10++)-- != 0)
          break;
        --v9;
      }
      while (v11);
    }
  }
  return bn_mod_exp_mont_small(a2, a3, v3, (uint64_t)&v14, v3, a1 + 232);
}

uint64_t ec_simple_scalar_to_montgomery_inv_vartime(unsigned int *a1, unint64_t *a2, int8x16_t *a3)
{
  uint64_t v3;
  uint64_t v6;
  int8x8_t v7;
  int8x16_t *v8;
  int8x16_t v9;
  uint64_t v10;
  int8x16_t v11;
  int8x16_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;

  v3 = a1[66];
  if ((int)v3 < 1)
    return 0;
  if (v3 < 4)
  {
    v6 = 0;
    v7 = 0;
LABEL_7:
    v13 = v3 - v6;
    v14 = &a3->i64[v6];
    do
    {
      v15 = *v14++;
      *(_QWORD *)&v7 |= v15;
      --v13;
    }
    while (v13);
    goto LABEL_9;
  }
  v6 = v3 & 0x7FFFFFFC;
  v8 = a3 + 1;
  v9 = 0uLL;
  v10 = v3 & 0xFFFFFFFC;
  v11 = 0uLL;
  do
  {
    v9 = vorrq_s8(v8[-1], v9);
    v11 = vorrq_s8(*v8, v11);
    v8 += 2;
    v10 -= 4;
  }
  while (v10);
  v12 = vorrq_s8(v11, v9);
  v7 = vorr_s8(*(int8x8_t *)v12.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  if (v6 != v3)
    goto LABEL_7;
LABEL_9:
  if (v7)
  {
    (*(void (**)(unsigned int *, unint64_t *))(*(_QWORD *)a1 + 136))(a1, a2);
    bn_from_montgomery_small(a2, (int)a1[66], (uint64_t)a2, (int)a1[66], (uint64_t)(a1 + 58));
    return 1;
  }
  return 0;
}

int SHA1_Update(SHA_CTX *c, const void *data, size_t len)
{
  size_t v3;
  unsigned int *v4;
  unsigned int *v6;
  size_t v7;
  uint64_t num;
  uint64_t v9;

  if (len)
  {
    v3 = len;
    v4 = (unsigned int *)data;
    v6 = c->data;
    v7 = *(_QWORD *)&c->Nl + 8 * len;
    *(_QWORD *)&c->Nl = v7;
    num = c->num;
    if ((_DWORD)num)
    {
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy((char *)v6 + num, data, len);
        c->num += v3;
        return 1;
      }
      v9 = 64 - num;
      if ((_DWORD)num != 64)
        memcpy((char *)v6 + num, data, 64 - num);
      sha1_block_data_order((int *)c, v6, 1);
      v4 = (unsigned int *)((char *)v4 + v9);
      v3 -= v9;
      c->num = 0;
      *(_OWORD *)v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      *((_OWORD *)v6 + 2) = 0u;
      *((_OWORD *)v6 + 3) = 0u;
    }
    if (v3 >= 0x40)
    {
      sha1_block_data_order((int *)c, v4, v3 >> 6);
      v4 = (unsigned int *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->num = v3;
      memcpy(v6, v4, v3);
    }
  }
  return 1;
}

int SHA1_Final(unsigned __int8 *md, SHA_CTX *c)
{
  unsigned int *data;
  int8x8_t v5;
  uint64_t num;
  uint64_t v7;

  data = c->data;
  v5 = *(int8x8_t *)&c->Nl;
  num = c->num;
  *((_BYTE *)c->data + num) = 0x80;
  v7 = num + 1;
  if (num >= 0x38)
  {
    if ((_DWORD)num != 63)
      bzero((char *)data + v7, 63 - num);
    sha1_block_data_order((int *)c, data, 1);
    v7 = 0;
    goto LABEL_6;
  }
  if (num != 55)
LABEL_6:
    bzero((char *)data + v7, 56 - v7);
  *(int32x2_t *)&c->data[14] = vrev64_s32((int32x2_t)vrev32_s8(v5));
  sha1_block_data_order((int *)c, data, 1);
  c->num = 0;
  *(_OWORD *)data = 0u;
  *((_OWORD *)data + 1) = 0u;
  *((_OWORD *)data + 2) = 0u;
  *((_OWORD *)data + 3) = 0u;
  *(_DWORD *)md = bswap32(c->h0);
  *((_DWORD *)md + 1) = bswap32(c->h1);
  *((_DWORD *)md + 2) = bswap32(c->h2);
  *((_DWORD *)md + 3) = bswap32(c->h3);
  *((_DWORD *)md + 4) = bswap32(c->h4);
  return 1;
}

uint64_t sha1_block_data_order(int *a1, unsigned int *a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  unsigned int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  int v56;
  unsigned int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  unsigned int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  unsigned int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  unsigned int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  unsigned int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  int v139;
  int v140;
  int v141;
  int v142;
  int v143;
  int v144;
  int v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  int v151;
  int v152;
  int v153;
  int v154;
  int v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  int v164;
  int v165;
  int v166;
  int v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  int v181;
  int v182;
  int v183;
  int v184;
  int v185;
  int v186;
  int v187;
  int v188;
  int v189;
  int v190;
  int v191;
  int v192;
  int v193;
  int v194;
  int v195;
  int v196;
  int v197;
  int v198;
  int v199;
  int v200;
  int v201;
  int v202;
  int v203;
  int v204;
  int v205;
  int v206;
  int v207;
  int v208;
  int v209;
  int v210;
  int v211;
  int v212;
  int v213;
  int v214;
  int v215;
  int v216;
  int v217;
  int v218;
  int v219;
  int v220;
  int v221;
  int v222;
  int v223;
  int v224;
  int v225;
  int v226;
  int v227;
  int v228;
  int v229;
  int v230;
  int v231;
  int v232;
  int v233;
  int v234;
  int v235;
  int v236;
  int v237;
  int v238;
  int v239;
  int v240;
  int v241;
  int v242;
  int v243;
  int v244;
  int v245;
  int v246;
  int v247;
  int v248;
  int v249;
  int v250;
  int v251;
  int v252;
  int v253;
  int v254;
  int v255;
  int v256;
  int v257;
  int v258;
  int v259;
  int v260;
  int v261;
  int v262;
  int v263;
  int v264;
  int v265;
  int v266;
  int v267;
  int v268;
  int v269;
  int v270;
  int v271;
  int v272;
  int v273;
  int v274;
  int v275;
  int v276;
  int v277;
  int v278;
  int v279;
  int v280;
  int v281;
  int v282;
  int v283;
  int v284;
  int v285;
  int v286;
  int v287;
  int v288;
  int v289;
  int v290;
  int v291;
  int v292;
  int v293;
  int v294;
  int v295;
  int v296;
  int v297;
  int v298;
  int v299;
  int v300;
  int v301;
  int v302;
  int v303;
  int v304;
  int v305;
  int v306;
  int v307;
  int v308;
  int v309;
  int v310;
  uint64_t result;
  int v312;
  int v313;
  int v314;
  int v315;
  int v316;
  int v317;
  int v318;
  int v319;
  int v320;
  int v321;
  int v322;
  int v323;
  int v324;
  int v325;
  int v326;
  int v327;
  int v328;
  int v329;
  int v330;
  int v331;
  int v332;
  int v333;
  int v334;
  int v335;
  int v336;
  int v337;
  int v338;
  int v339;
  int v340;
  int v341;
  int v342;
  int v343;
  int v344;
  int v345;
  int v346;
  int v347;
  int v348;
  int v349;
  int v350;
  int v351;
  int v352;
  int v353;
  int v354;
  int v355;
  int v356;
  int v357;
  int v358;
  int v359;
  int v360;
  int v361;
  int v362;
  int v363;
  int v364;
  int v365;
  int v366;
  int v367;
  int v368;
  int v369;
  int v370;
  int v371;
  int v372;
  int v373;
  int v374;
  int v375;
  int v376;
  int v377;
  int v378;
  int v380;
  int v381;
  uint64_t v382;

  v4 = a1[3];
  v3 = a1[4];
  v6 = a1[1];
  v5 = a1[2];
  v7 = *a1;
  do
  {
    v381 = v3;
    v382 = a3;
    HIDWORD(v8) = v7;
    LODWORD(v8) = v7;
    v9 = bswap32(*a2);
    v10 = (v8 >> 27) + v3 + 1518500249 + (v5 & v6 | v4 & ~v6);
    v11 = bswap32(a2[1]);
    HIDWORD(v8) = v6;
    LODWORD(v8) = v6;
    v12 = v8 >> 2;
    v13 = bswap32(a2[2]);
    v14 = v10 + v9;
    v380 = v7;
    HIDWORD(v8) = v10 + v9;
    LODWORD(v8) = v10 + v9;
    v15 = v8 >> 27;
    HIDWORD(v8) = v7;
    LODWORD(v8) = v7;
    v16 = v8 >> 2;
    v17 = bswap32(a2[3]);
    v18 = v4 + 1518500249 + (v12 & v7 | v5 & ~v7) + v11 + v15;
    HIDWORD(v8) = v18;
    LODWORD(v8) = v18;
    v19 = v8 >> 27;
    HIDWORD(v8) = v14;
    LODWORD(v8) = v14;
    v20 = v8 >> 2;
    v21 = v5 + 1518500249 + v13 + (v16 & v14 | v12 & ~v14) + v19;
    HIDWORD(v8) = v21;
    LODWORD(v8) = v21;
    v22 = v8 >> 27;
    v23 = v12 + 1518500249 + v17 + (v20 & v18 | v16 & ~v18);
    HIDWORD(v8) = v18;
    LODWORD(v8) = v18;
    v24 = v8 >> 2;
    v25 = bswap32(a2[4]);
    v26 = v23 + v22;
    v27 = bswap32(a2[5]);
    v28 = v16 + 1518500249 + v25 + (v24 & v21 | v20 & ~v21);
    HIDWORD(v8) = v21;
    LODWORD(v8) = v21;
    v29 = v8 >> 2;
    HIDWORD(v8) = v26;
    LODWORD(v8) = v26;
    v30 = bswap32(a2[6]);
    v31 = v28 + (v8 >> 27);
    HIDWORD(v8) = v31;
    LODWORD(v8) = v31;
    v32 = v8 >> 27;
    HIDWORD(v8) = v26;
    LODWORD(v8) = v26;
    v33 = v8 >> 2;
    v34 = bswap32(a2[7]);
    v35 = v20 + v27 + 1518500249 + (v29 & v26 | v24 & ~v26) + v32;
    v36 = v24 + v30 + 1518500249 + (v33 & v31 | v29 & ~v31);
    HIDWORD(v8) = v35;
    LODWORD(v8) = v35;
    v37 = v8 >> 27;
    HIDWORD(v8) = v31;
    LODWORD(v8) = v31;
    v38 = v8 >> 2;
    v39 = bswap32(a2[8]);
    v40 = v36 + v37;
    HIDWORD(v8) = v40;
    LODWORD(v8) = v40;
    v41 = v8 >> 27;
    v42 = v29 + v34 + 1518500249 + (v38 & v35 | v33 & ~v35);
    HIDWORD(v8) = v35;
    LODWORD(v8) = v35;
    v43 = v8 >> 2;
    v44 = bswap32(a2[9]);
    v45 = v42 + v41;
    HIDWORD(v8) = v45;
    LODWORD(v8) = v45;
    v46 = v8 >> 27;
    v47 = v39 + 1518500249 + v33 + (v43 & v40 | v38 & ~v40);
    HIDWORD(v8) = v40;
    LODWORD(v8) = v40;
    v48 = v8 >> 2;
    v49 = v47 + v46;
    v50 = bswap32(a2[10]);
    HIDWORD(v8) = v49;
    LODWORD(v8) = v49;
    v51 = v8 >> 27;
    v52 = v48 & v45 | v43 & ~v45;
    HIDWORD(v8) = v45;
    LODWORD(v8) = v45;
    v53 = v8 >> 2;
    v54 = v44 + 1518500249 + v38 + v52 + v51;
    v55 = bswap32(a2[11]);
    HIDWORD(v8) = v49;
    LODWORD(v8) = v49;
    v56 = v8 >> 2;
    HIDWORD(v8) = v54;
    LODWORD(v8) = v54;
    v57 = bswap32(a2[12]);
    v58 = v50 + 1518500249 + v43 + (v53 & v49 | v48 & ~v49) + (v8 >> 27);
    v59 = v55 + 1518500249 + v48 + (v56 & v54 | v53 & ~v54);
    HIDWORD(v8) = v58;
    LODWORD(v8) = v58;
    v60 = v8 >> 27;
    HIDWORD(v8) = v54;
    LODWORD(v8) = v54;
    v61 = v8 >> 2;
    v62 = bswap32(a2[13]);
    v63 = v59 + v60;
    v64 = v57 + 1518500249 + v53 + (v61 & v58 | v56 & ~v58);
    HIDWORD(v8) = v63;
    LODWORD(v8) = v63;
    v65 = v8 >> 27;
    HIDWORD(v8) = v58;
    LODWORD(v8) = v58;
    v66 = v8 >> 2;
    v67 = bswap32(a2[14]);
    v68 = v64 + v65;
    HIDWORD(v8) = v68;
    LODWORD(v8) = v68;
    v69 = v8 >> 27;
    v70 = v62 + 1518500249 + v56 + (v66 & v63 | v61 & ~v63);
    HIDWORD(v8) = v63;
    LODWORD(v8) = v63;
    v71 = v8 >> 2;
    v72 = bswap32(a2[15]);
    v73 = v70 + v69;
    HIDWORD(v8) = v73;
    LODWORD(v8) = v73;
    v74 = v8 >> 27;
    v75 = v67 + 1518500249 + v61 + (v71 & v68 | v66 & ~v68);
    HIDWORD(v8) = v68;
    LODWORD(v8) = v68;
    v76 = v8 >> 2;
    v77 = v76 & v73 | v71 & ~v73;
    HIDWORD(v8) = v73;
    LODWORD(v8) = v73;
    v78 = v8 >> 2;
    v79 = v75 + v74;
    v80 = v72 + 1518500249 + v66 + v77;
    HIDWORD(v8) = v79;
    LODWORD(v8) = v79;
    v81 = v8 >> 27;
    HIDWORD(v8) = v13 ^ v9 ^ v39 ^ v62;
    LODWORD(v8) = HIDWORD(v8);
    v82 = v8 >> 31;
    v83 = v78 & v79 | v76 & ~v79;
    v84 = v80 + v81;
    v85 = v82 + 1518500249 + v71;
    HIDWORD(v8) = v79;
    LODWORD(v8) = v79;
    v86 = v8 >> 2;
    HIDWORD(v8) = v84;
    LODWORD(v8) = v84;
    v87 = v8 >> 27;
    HIDWORD(v8) = v17 ^ v11 ^ v44 ^ v67;
    LODWORD(v8) = HIDWORD(v8);
    v88 = v8 >> 31;
    v89 = v85 + v83 + v87;
    v90 = v88 + 1518500249 + v76 + (v86 & v84 | v78 & ~v84);
    HIDWORD(v8) = v84;
    LODWORD(v8) = v84;
    v91 = v8 >> 2;
    HIDWORD(v8) = v89;
    LODWORD(v8) = v89;
    v92 = v8 >> 27;
    HIDWORD(v8) = v25 ^ v13 ^ v50 ^ v72;
    LODWORD(v8) = HIDWORD(v8);
    v93 = v8 >> 31;
    v94 = v91 & v89 | v86 & ~v89;
    HIDWORD(v8) = v89;
    LODWORD(v8) = v89;
    v95 = v8 >> 2;
    v96 = v90 + v92;
    v97 = v93 + 1518500249 + v78 + v94;
    HIDWORD(v8) = v90 + v92;
    LODWORD(v8) = v90 + v92;
    v98 = v8 >> 27;
    HIDWORD(v8) = v27 ^ v17 ^ v55 ^ v82;
    LODWORD(v8) = HIDWORD(v8);
    v99 = v8 >> 31;
    v100 = v97 + v98;
    HIDWORD(v8) = v96;
    LODWORD(v8) = v96;
    v101 = v8 >> 2;
    v102 = v99 + 1518500249 + v86 + (v95 & v96 | v91 & ~v96);
    HIDWORD(v8) = v30 ^ v25 ^ v57 ^ v88;
    LODWORD(v8) = HIDWORD(v8);
    v103 = v8 >> 31;
    HIDWORD(v8) = v100;
    LODWORD(v8) = v100;
    v104 = v103 + 1859775393 + v91 + (v101 ^ v95 ^ v100);
    v105 = v102 + (v8 >> 27);
    HIDWORD(v8) = v100;
    LODWORD(v8) = v100;
    v106 = v8 >> 2;
    v107 = v34 ^ v27 ^ v62;
    HIDWORD(v8) = v105;
    LODWORD(v8) = v105;
    v108 = v8 >> 27;
    HIDWORD(v8) = v107 ^ v93;
    LODWORD(v8) = v107 ^ v93;
    v109 = v8 >> 31;
    v110 = v109 + 1859775393 + v95 + (v106 ^ v101 ^ v105);
    HIDWORD(v8) = v105;
    LODWORD(v8) = v105;
    v111 = v8 >> 2;
    v112 = v104 + v108;
    HIDWORD(v8) = v39 ^ v30 ^ v67 ^ v99;
    LODWORD(v8) = HIDWORD(v8);
    v113 = v8 >> 31;
    HIDWORD(v8) = v112;
    LODWORD(v8) = v112;
    v114 = v113 + 1859775393 + v101 + (v111 ^ v106 ^ v112);
    v115 = v110 + (v8 >> 27);
    HIDWORD(v8) = v112;
    LODWORD(v8) = v112;
    v116 = v8 >> 2;
    v117 = v44 ^ v34 ^ v72;
    HIDWORD(v8) = v115;
    LODWORD(v8) = v115;
    v118 = v8 >> 27;
    HIDWORD(v8) = v117 ^ v103;
    LODWORD(v8) = v117 ^ v103;
    v119 = v8 >> 31;
    v120 = v119 + 1859775393 + v106 + (v116 ^ v111 ^ v115);
    HIDWORD(v8) = v115;
    LODWORD(v8) = v115;
    v121 = v8 >> 2;
    v122 = v50 ^ v39;
    v123 = v114 + v118;
    HIDWORD(v8) = v122 ^ v82 ^ v109;
    LODWORD(v8) = HIDWORD(v8);
    v124 = v8 >> 31;
    HIDWORD(v8) = v123;
    LODWORD(v8) = v114 + v118;
    v125 = v124 + 1859775393 + v111 + (v121 ^ v116 ^ (v114 + v118));
    v126 = v120 + (v8 >> 27);
    HIDWORD(v8) = v123;
    LODWORD(v8) = v123;
    v127 = v8 >> 2;
    v128 = v55 ^ v44 ^ v88;
    HIDWORD(v8) = v126;
    LODWORD(v8) = v126;
    v129 = v8 >> 27;
    HIDWORD(v8) = v128 ^ v113;
    LODWORD(v8) = v128 ^ v113;
    v130 = v8 >> 31;
    v131 = v130 + 1859775393 + v116 + (v127 ^ v121 ^ v126);
    HIDWORD(v8) = v126;
    LODWORD(v8) = v126;
    v132 = v8 >> 2;
    v133 = v125 + v129;
    HIDWORD(v8) = v57 ^ v50 ^ v93 ^ v119;
    LODWORD(v8) = HIDWORD(v8);
    v134 = v8 >> 31;
    HIDWORD(v8) = v133;
    LODWORD(v8) = v133;
    v135 = v134 + 1859775393 + v121 + (v132 ^ v127 ^ v133);
    v136 = v131 + (v8 >> 27);
    HIDWORD(v8) = v133;
    LODWORD(v8) = v133;
    v137 = v8 >> 2;
    HIDWORD(v8) = v136;
    LODWORD(v8) = v136;
    v138 = v8 >> 27;
    HIDWORD(v8) = v62 ^ v55 ^ v99 ^ v124;
    LODWORD(v8) = HIDWORD(v8);
    v139 = v8 >> 31;
    v140 = v139 + 1859775393 + v127 + (v137 ^ v132 ^ v136);
    HIDWORD(v8) = v136;
    LODWORD(v8) = v136;
    v141 = v8 >> 2;
    v142 = v67 ^ v57;
    v143 = v135 + v138;
    HIDWORD(v8) = v142 ^ v103 ^ v130;
    LODWORD(v8) = HIDWORD(v8);
    v144 = v8 >> 31;
    HIDWORD(v8) = v143;
    LODWORD(v8) = v143;
    v145 = v144 + 1859775393 + v132 + (v141 ^ v137 ^ v143);
    v146 = v140 + (v8 >> 27);
    HIDWORD(v8) = v143;
    LODWORD(v8) = v143;
    v147 = v8 >> 2;
    HIDWORD(v8) = v146;
    LODWORD(v8) = v146;
    v148 = v8 >> 27;
    HIDWORD(v8) = v72 ^ v62 ^ v109 ^ v134;
    LODWORD(v8) = HIDWORD(v8);
    v149 = v8 >> 31;
    v150 = v149 + 1859775393 + v137 + (v147 ^ v141 ^ v146);
    HIDWORD(v8) = v146;
    LODWORD(v8) = v146;
    v151 = v8 >> 2;
    v152 = v145 + v148;
    HIDWORD(v8) = v82 ^ v67 ^ v113 ^ v139;
    LODWORD(v8) = HIDWORD(v8);
    v153 = v8 >> 31;
    HIDWORD(v8) = v152;
    LODWORD(v8) = v152;
    v154 = v153 + 1859775393 + v141 + (v151 ^ v147 ^ v152);
    v155 = v150 + (v8 >> 27);
    HIDWORD(v8) = v152;
    LODWORD(v8) = v152;
    v156 = v8 >> 2;
    HIDWORD(v8) = v155;
    LODWORD(v8) = v155;
    v157 = v8 >> 27;
    HIDWORD(v8) = v88 ^ v72 ^ v119 ^ v144;
    LODWORD(v8) = HIDWORD(v8);
    v158 = v8 >> 31;
    v159 = v158 + 1859775393 + v147 + (v156 ^ v151 ^ v155);
    HIDWORD(v8) = v155;
    LODWORD(v8) = v155;
    v160 = v8 >> 2;
    v161 = v154 + v157;
    HIDWORD(v8) = v93 ^ v82 ^ v124 ^ v149;
    LODWORD(v8) = HIDWORD(v8);
    v162 = v8 >> 31;
    HIDWORD(v8) = v161;
    LODWORD(v8) = v161;
    v163 = v162 + 1859775393 + v151 + (v160 ^ v156 ^ v161);
    v164 = v159 + (v8 >> 27);
    HIDWORD(v8) = v161;
    LODWORD(v8) = v161;
    v165 = v8 >> 2;
    HIDWORD(v8) = v164;
    LODWORD(v8) = v164;
    v166 = v8 >> 27;
    HIDWORD(v8) = v99 ^ v88 ^ v130 ^ v153;
    LODWORD(v8) = HIDWORD(v8);
    v167 = v8 >> 31;
    v168 = v167 + 1859775393 + v156 + (v165 ^ v160 ^ v164);
    HIDWORD(v8) = v164;
    LODWORD(v8) = v164;
    v169 = v8 >> 2;
    v170 = v163 + v166;
    HIDWORD(v8) = v103 ^ v93 ^ v134 ^ v158;
    LODWORD(v8) = HIDWORD(v8);
    v171 = v8 >> 31;
    HIDWORD(v8) = v170;
    LODWORD(v8) = v170;
    v172 = v171 + 1859775393 + v160 + (v169 ^ v165 ^ v170);
    v173 = v168 + (v8 >> 27);
    HIDWORD(v8) = v170;
    LODWORD(v8) = v170;
    v174 = v8 >> 2;
    HIDWORD(v8) = v173;
    LODWORD(v8) = v173;
    v175 = v8 >> 27;
    HIDWORD(v8) = v109 ^ v99 ^ v139 ^ v162;
    LODWORD(v8) = HIDWORD(v8);
    v176 = v8 >> 31;
    v177 = v176 + 1859775393 + v165 + (v174 ^ v169 ^ v173);
    HIDWORD(v8) = v173;
    LODWORD(v8) = v173;
    v178 = v8 >> 2;
    v179 = v172 + v175;
    HIDWORD(v8) = v113 ^ v103 ^ v144 ^ v167;
    LODWORD(v8) = HIDWORD(v8);
    v180 = v8 >> 31;
    HIDWORD(v8) = v179;
    LODWORD(v8) = v179;
    v181 = v180 + 1859775393 + v169 + (v178 ^ v174 ^ v179);
    v182 = v177 + (v8 >> 27);
    HIDWORD(v8) = v179;
    LODWORD(v8) = v179;
    v183 = v8 >> 2;
    HIDWORD(v8) = v182;
    LODWORD(v8) = v182;
    v184 = v8 >> 27;
    HIDWORD(v8) = v119 ^ v109 ^ v149 ^ v171;
    LODWORD(v8) = HIDWORD(v8);
    v185 = v8 >> 31;
    v186 = v185 + 1859775393 + v174 + (v183 ^ v178 ^ v182);
    HIDWORD(v8) = v182;
    LODWORD(v8) = v182;
    v187 = v8 >> 2;
    v188 = v181 + v184;
    HIDWORD(v8) = v124 ^ v113 ^ v153 ^ v176;
    LODWORD(v8) = HIDWORD(v8);
    v189 = v8 >> 31;
    HIDWORD(v8) = v188;
    LODWORD(v8) = v188;
    v190 = v189 + 1859775393 + v178 + (v187 ^ v183 ^ v188);
    v191 = v186 + (v8 >> 27);
    HIDWORD(v8) = v188;
    LODWORD(v8) = v188;
    v192 = v8 >> 2;
    HIDWORD(v8) = v191;
    LODWORD(v8) = v191;
    v193 = v8 >> 27;
    HIDWORD(v8) = v130 ^ v119 ^ v158 ^ v180;
    LODWORD(v8) = HIDWORD(v8);
    v194 = v8 >> 31;
    v195 = v194 + 1859775393 + v183 + (v192 ^ v187 ^ v191);
    HIDWORD(v8) = v191;
    LODWORD(v8) = v191;
    v196 = v8 >> 2;
    v197 = v190 + v193;
    HIDWORD(v8) = v134 ^ v124 ^ v162 ^ v185;
    LODWORD(v8) = HIDWORD(v8);
    v198 = v8 >> 31;
    HIDWORD(v8) = v197;
    LODWORD(v8) = v197;
    v199 = v195 + (v8 >> 27);
    HIDWORD(v8) = v199;
    LODWORD(v8) = v199;
    v200 = v8 >> 27;
    v201 = (v197 | v196) & v192 | v197 & v196;
    HIDWORD(v8) = v197;
    LODWORD(v8) = v197;
    v202 = v8 >> 2;
    HIDWORD(v8) = v139 ^ v130 ^ v167 ^ v189;
    LODWORD(v8) = HIDWORD(v8);
    v203 = v8 >> 31;
    v204 = v198 - 1894007588 + v187 + v201 + v200;
    v205 = (v199 | v202) & v196 | v199 & v202;
    HIDWORD(v8) = v204;
    LODWORD(v8) = v204;
    v206 = v8 >> 27;
    HIDWORD(v8) = v199;
    LODWORD(v8) = v199;
    v207 = v8 >> 2;
    HIDWORD(v8) = v144 ^ v134 ^ v171 ^ v194;
    LODWORD(v8) = HIDWORD(v8);
    v208 = v8 >> 31;
    v209 = v203 - 1894007588 + v192 + v205 + v206;
    v210 = (v204 | v207) & v202 | v204 & v207;
    HIDWORD(v8) = v209;
    LODWORD(v8) = v209;
    v211 = v8 >> 27;
    HIDWORD(v8) = v204;
    LODWORD(v8) = v204;
    v212 = v8 >> 2;
    HIDWORD(v8) = v149 ^ v139 ^ v176 ^ v198;
    LODWORD(v8) = HIDWORD(v8);
    v213 = v8 >> 31;
    v214 = v208 - 1894007588 + v196 + v210 + v211;
    HIDWORD(v8) = v214;
    LODWORD(v8) = v214;
    v215 = v8 >> 27;
    v216 = v213 - 1894007588 + v202 + ((v209 | v212) & v207 | v209 & v212);
    HIDWORD(v8) = v209;
    LODWORD(v8) = v209;
    v217 = v8 >> 2;
    v218 = v216 + v215;
    HIDWORD(v8) = v153 ^ v144 ^ v180 ^ v203;
    LODWORD(v8) = HIDWORD(v8);
    v219 = v8 >> 31;
    HIDWORD(v8) = v218;
    LODWORD(v8) = v218;
    v220 = v8 >> 27;
    v221 = v219 - 1894007588 + v207 + ((v214 | v217) & v212 | v214 & v217);
    HIDWORD(v8) = v214;
    LODWORD(v8) = v214;
    v222 = v8 >> 2;
    v223 = v221 + v220;
    HIDWORD(v8) = v158 ^ v149 ^ v185 ^ v208;
    LODWORD(v8) = HIDWORD(v8);
    v224 = v8 >> 31;
    v225 = (v218 | v222) & v217 | v218 & v222;
    HIDWORD(v8) = v218;
    LODWORD(v8) = v218;
    v226 = v8 >> 2;
    HIDWORD(v8) = v223;
    LODWORD(v8) = v223;
    v227 = v8 >> 27;
    HIDWORD(v8) = v162 ^ v153 ^ v189 ^ v213;
    LODWORD(v8) = HIDWORD(v8);
    v228 = v8 >> 31;
    v229 = v224 - 1894007588 + v212 + v225 + v227;
    HIDWORD(v8) = v229;
    LODWORD(v8) = v229;
    v230 = v8 >> 27;
    v231 = (v223 | v226) & v222 | v223 & v226;
    HIDWORD(v8) = v223;
    LODWORD(v8) = v223;
    v232 = v8 >> 2;
    HIDWORD(v8) = v167 ^ v158 ^ v194 ^ v219;
    LODWORD(v8) = HIDWORD(v8);
    v233 = v8 >> 31;
    v234 = v228 - 1894007588 + v217 + v231 + v230;
    v235 = (v229 | v232) & v226 | v229 & v232;
    HIDWORD(v8) = v234;
    LODWORD(v8) = v234;
    v236 = v8 >> 27;
    HIDWORD(v8) = v229;
    LODWORD(v8) = v229;
    v237 = v8 >> 2;
    HIDWORD(v8) = v171 ^ v162 ^ v198 ^ v224;
    LODWORD(v8) = HIDWORD(v8);
    v238 = v8 >> 31;
    v239 = v233 - 1894007588 + v222 + v235 + v236;
    v240 = (v234 | v237) & v232 | v234 & v237;
    HIDWORD(v8) = v239;
    LODWORD(v8) = v239;
    v241 = v8 >> 27;
    HIDWORD(v8) = v234;
    LODWORD(v8) = v234;
    v242 = v8 >> 2;
    HIDWORD(v8) = v176 ^ v167 ^ v203 ^ v228;
    LODWORD(v8) = HIDWORD(v8);
    v243 = v8 >> 31;
    v244 = v238 - 1894007588 + v226 + v240 + v241;
    HIDWORD(v8) = v244;
    LODWORD(v8) = v244;
    v245 = v8 >> 27;
    v246 = v243 - 1894007588 + v232 + ((v239 | v242) & v237 | v239 & v242);
    HIDWORD(v8) = v239;
    LODWORD(v8) = v239;
    v247 = v8 >> 2;
    v248 = v246 + v245;
    HIDWORD(v8) = v180 ^ v171 ^ v208 ^ v233;
    LODWORD(v8) = HIDWORD(v8);
    v249 = v8 >> 31;
    HIDWORD(v8) = v248;
    LODWORD(v8) = v248;
    v250 = v8 >> 27;
    v251 = v249 - 1894007588 + v237 + ((v244 | v247) & v242 | v244 & v247);
    HIDWORD(v8) = v244;
    LODWORD(v8) = v244;
    v252 = v8 >> 2;
    v253 = v251 + v250;
    HIDWORD(v8) = v185 ^ v176 ^ v213 ^ v238;
    LODWORD(v8) = HIDWORD(v8);
    v254 = v8 >> 31;
    v255 = (v248 | v252) & v247 | v248 & v252;
    HIDWORD(v8) = v248;
    LODWORD(v8) = v248;
    v256 = v8 >> 2;
    HIDWORD(v8) = v253;
    LODWORD(v8) = v253;
    v257 = v8 >> 27;
    HIDWORD(v8) = v189 ^ v180 ^ v219 ^ v243;
    LODWORD(v8) = HIDWORD(v8);
    v258 = v8 >> 31;
    v259 = v254 - 1894007588 + v242 + v255 + v257;
    HIDWORD(v8) = v259;
    LODWORD(v8) = v259;
    v260 = v8 >> 27;
    v261 = (v253 | v256) & v252 | v253 & v256;
    HIDWORD(v8) = v253;
    LODWORD(v8) = v253;
    v262 = v8 >> 2;
    HIDWORD(v8) = v194 ^ v185 ^ v224 ^ v249;
    LODWORD(v8) = HIDWORD(v8);
    v263 = v8 >> 31;
    v264 = v258 - 1894007588 + v247 + v261 + v260;
    v265 = (v259 | v262) & v256 | v259 & v262;
    HIDWORD(v8) = v264;
    LODWORD(v8) = v264;
    v266 = v8 >> 27;
    HIDWORD(v8) = v259;
    LODWORD(v8) = v259;
    v267 = v8 >> 2;
    HIDWORD(v8) = v198 ^ v189 ^ v228 ^ v254;
    LODWORD(v8) = HIDWORD(v8);
    v268 = v8 >> 31;
    v269 = v263 - 1894007588 + v252 + v265 + v266;
    HIDWORD(v8) = v269;
    LODWORD(v8) = v269;
    v270 = v8 >> 27;
    v271 = v268 - 1894007588 + v256 + ((v264 | v267) & v262 | v264 & v267);
    HIDWORD(v8) = v264;
    LODWORD(v8) = v264;
    v272 = v8 >> 2;
    v273 = v271 + v270;
    HIDWORD(v8) = v203 ^ v194 ^ v233 ^ v258;
    LODWORD(v8) = HIDWORD(v8);
    v274 = v8 >> 31;
    HIDWORD(v8) = v273;
    LODWORD(v8) = v273;
    v275 = v8 >> 27;
    v276 = v274 - 1894007588 + v262 + ((v269 | v272) & v267 | v269 & v272);
    HIDWORD(v8) = v269;
    LODWORD(v8) = v269;
    v277 = v8 >> 2;
    v278 = v276 + v275;
    HIDWORD(v8) = v208 ^ v198 ^ v238 ^ v263;
    LODWORD(v8) = HIDWORD(v8);
    v279 = v8 >> 31;
    HIDWORD(v8) = v278;
    LODWORD(v8) = v278;
    v280 = v8 >> 27;
    v281 = v279 - 1894007588 + v267 + ((v273 | v277) & v272 | v273 & v277);
    HIDWORD(v8) = v273;
    LODWORD(v8) = v273;
    v282 = v8 >> 2;
    v283 = v281 + v280;
    HIDWORD(v8) = v213 ^ v203 ^ v243 ^ v268;
    LODWORD(v8) = HIDWORD(v8);
    v284 = v8 >> 31;
    v285 = (v278 | v282) & v277 | v278 & v282;
    HIDWORD(v8) = v278;
    LODWORD(v8) = v278;
    v286 = v8 >> 2;
    HIDWORD(v8) = v283;
    LODWORD(v8) = v283;
    v287 = v8 >> 27;
    HIDWORD(v8) = v219 ^ v208 ^ v249 ^ v274;
    LODWORD(v8) = HIDWORD(v8);
    v288 = v8 >> 31;
    v289 = v284 - 1894007588 + v272 + v285 + v287;
    v290 = (v283 | v286) & v282 | v283 & v286;
    HIDWORD(v8) = v289;
    LODWORD(v8) = v289;
    v291 = v8 >> 27;
    HIDWORD(v8) = v283;
    LODWORD(v8) = v283;
    v292 = v8 >> 2;
    v293 = v288 - 1894007588 + v277 + v290;
    HIDWORD(v8) = v224 ^ v213 ^ v254 ^ v279;
    LODWORD(v8) = HIDWORD(v8);
    v294 = v8 >> 31;
    v295 = v293 + v291;
    HIDWORD(v8) = v295;
    LODWORD(v8) = v295;
    v296 = v294 - 1894007588 + v282 + ((v289 | v292) & v286 | v289 & v292) + (v8 >> 27);
    HIDWORD(v8) = v228 ^ v219 ^ v258 ^ v284;
    LODWORD(v8) = HIDWORD(v8);
    v297 = v8 >> 31;
    HIDWORD(v8) = v289;
    LODWORD(v8) = v289;
    v298 = v8 >> 2;
    v299 = v297 - 899497514 + v286 + (v298 ^ v292 ^ v295);
    HIDWORD(v8) = v296;
    LODWORD(v8) = v296;
    v300 = v8 >> 27;
    HIDWORD(v8) = v295;
    LODWORD(v8) = v295;
    v301 = v8 >> 2;
    v302 = v299 + v300;
    HIDWORD(v8) = v233 ^ v224 ^ v263 ^ v288;
    LODWORD(v8) = HIDWORD(v8);
    v303 = v8 >> 31;
    HIDWORD(v8) = v302;
    LODWORD(v8) = v302;
    v304 = v303 - 899497514 + v292 + (v301 ^ v298 ^ v296) + (v8 >> 27);
    HIDWORD(v8) = v238 ^ v228 ^ v268 ^ v294;
    LODWORD(v8) = HIDWORD(v8);
    v305 = v8 >> 31;
    HIDWORD(v8) = v296;
    LODWORD(v8) = v296;
    v306 = v8 >> 2;
    v307 = v305 - 899497514 + v298 + (v306 ^ v301 ^ v302);
    HIDWORD(v8) = v304;
    LODWORD(v8) = v304;
    v308 = v8 >> 27;
    HIDWORD(v8) = v302;
    LODWORD(v8) = v302;
    v309 = v8 >> 2;
    v310 = v307 + v308;
    HIDWORD(v8) = v243 ^ v233 ^ v274 ^ v297;
    LODWORD(v8) = HIDWORD(v8);
    result = (v8 >> 31);
    HIDWORD(v8) = v310;
    LODWORD(v8) = v310;
    v312 = result - 899497514 + v301 + (v309 ^ v306 ^ v304) + (v8 >> 27);
    HIDWORD(v8) = v249 ^ v238 ^ v279 ^ v303;
    LODWORD(v8) = HIDWORD(v8);
    v313 = v8 >> 31;
    HIDWORD(v8) = v304;
    LODWORD(v8) = v304;
    v314 = v8 >> 2;
    v315 = v313 - 899497514 + v306 + (v314 ^ v309 ^ v310);
    HIDWORD(v8) = v312;
    LODWORD(v8) = v312;
    v316 = v8 >> 27;
    HIDWORD(v8) = v310;
    LODWORD(v8) = v310;
    v317 = v8 >> 2;
    v318 = v315 + v316;
    HIDWORD(v8) = v254 ^ v243 ^ v284 ^ v305;
    LODWORD(v8) = HIDWORD(v8);
    v319 = v8 >> 31;
    HIDWORD(v8) = v318;
    LODWORD(v8) = v318;
    v320 = v258 ^ v249 ^ v288;
    v321 = v319 - 899497514 + v309 + (v317 ^ v314 ^ v312) + (v8 >> 27);
    HIDWORD(v8) = v320 ^ result;
    LODWORD(v8) = v320 ^ result;
    v322 = v8 >> 31;
    HIDWORD(v8) = v312;
    LODWORD(v8) = v312;
    v323 = v8 >> 2;
    v324 = v322 - 899497514 + v314 + (v323 ^ v317 ^ v318);
    HIDWORD(v8) = v321;
    LODWORD(v8) = v321;
    v325 = v8 >> 27;
    HIDWORD(v8) = v318;
    LODWORD(v8) = v318;
    v326 = v8 >> 2;
    v327 = v324 + v325;
    HIDWORD(v8) = v263 ^ v254 ^ v294 ^ v313;
    LODWORD(v8) = HIDWORD(v8);
    v328 = v8 >> 31;
    HIDWORD(v8) = v327;
    LODWORD(v8) = v327;
    v329 = v328 - 899497514 + v317 + (v326 ^ v323 ^ v321) + (v8 >> 27);
    HIDWORD(v8) = v268 ^ v258 ^ v297 ^ v319;
    LODWORD(v8) = HIDWORD(v8);
    v330 = v8 >> 31;
    HIDWORD(v8) = v321;
    LODWORD(v8) = v321;
    v331 = v8 >> 2;
    v332 = v330 - 899497514 + v323 + (v331 ^ v326 ^ v327);
    HIDWORD(v8) = v329;
    LODWORD(v8) = v329;
    v333 = v8 >> 27;
    HIDWORD(v8) = v327;
    LODWORD(v8) = v327;
    v334 = v8 >> 2;
    v335 = v332 + v333;
    HIDWORD(v8) = v274 ^ v263 ^ v303 ^ v322;
    LODWORD(v8) = HIDWORD(v8);
    v336 = v8 >> 31;
    HIDWORD(v8) = v335;
    LODWORD(v8) = v335;
    v337 = v336 - 899497514 + v326 + (v334 ^ v331 ^ v329) + (v8 >> 27);
    HIDWORD(v8) = v279 ^ v268 ^ v305 ^ v328;
    LODWORD(v8) = HIDWORD(v8);
    v338 = v8 >> 31;
    HIDWORD(v8) = v329;
    LODWORD(v8) = v329;
    v339 = v8 >> 2;
    v340 = v338 - 899497514 + v331 + (v339 ^ v334 ^ v335);
    HIDWORD(v8) = v337;
    LODWORD(v8) = v337;
    v341 = v8 >> 27;
    HIDWORD(v8) = v335;
    LODWORD(v8) = v335;
    v342 = v8 >> 2;
    v343 = v340 + v341;
    HIDWORD(v8) = v284 ^ v274 ^ result ^ v330;
    LODWORD(v8) = HIDWORD(v8);
    v344 = v8 >> 31;
    v345 = v342 ^ v339 ^ v337;
    HIDWORD(v8) = v337;
    LODWORD(v8) = v337;
    v346 = v8 >> 2;
    HIDWORD(v8) = v288 ^ v279 ^ v313 ^ v336;
    LODWORD(v8) = HIDWORD(v8);
    v347 = v8 >> 31;
    v348 = v347 - 899497514 + v339 + (v346 ^ v342 ^ v343);
    HIDWORD(v8) = v343;
    LODWORD(v8) = v343;
    v349 = v344 - 899497514 + v334 + v345 + (v8 >> 27);
    HIDWORD(v8) = v294 ^ v284 ^ v319 ^ v338;
    LODWORD(v8) = HIDWORD(v8);
    v350 = v8 >> 31;
    v351 = v297 ^ v288 ^ v322;
    HIDWORD(v8) = v349;
    LODWORD(v8) = v349;
    v352 = v8 >> 27;
    HIDWORD(v8) = v343;
    LODWORD(v8) = v343;
    v353 = v8 >> 2;
    v354 = v348 + v352;
    v355 = v353 ^ v346 ^ v349;
    HIDWORD(v8) = v349;
    LODWORD(v8) = v349;
    v356 = v8 >> 2;
    v357 = v350 - 899497514 + v342 + v355;
    HIDWORD(v8) = v351 ^ v344;
    LODWORD(v8) = v351 ^ v344;
    v358 = v8 >> 31;
    v359 = v358 - 899497514 + v346;
    v360 = v356 ^ v353 ^ v354;
    HIDWORD(v8) = v354;
    LODWORD(v8) = v354;
    v361 = v357 + (v8 >> 27);
    v362 = v303 ^ v294 ^ v328 ^ v347;
    HIDWORD(v8) = v361;
    LODWORD(v8) = v361;
    v363 = v8 >> 27;
    HIDWORD(v8) = v354;
    LODWORD(v8) = v354;
    v364 = v8 >> 2;
    v365 = v359 + v360 + v363;
    HIDWORD(v8) = v362;
    LODWORD(v8) = v362;
    v366 = v8 >> 31;
    HIDWORD(v8) = v365;
    LODWORD(v8) = v365;
    v367 = v366 - 899497514 + v353 + (v364 ^ v356 ^ v361) + (v8 >> 27);
    HIDWORD(v8) = v305 ^ v297 ^ v330 ^ v350;
    LODWORD(v8) = HIDWORD(v8);
    v368 = v8 >> 31;
    HIDWORD(v8) = v361;
    LODWORD(v8) = v361;
    v369 = v8 >> 2;
    HIDWORD(v8) = v367;
    LODWORD(v8) = v367;
    v370 = v368 - 899497514 + v356 + (v369 ^ v364 ^ v365) + (v8 >> 27);
    HIDWORD(v8) = v365;
    LODWORD(v8) = v365;
    v371 = v8 >> 2;
    HIDWORD(v8) = result ^ v303 ^ v336 ^ v358;
    LODWORD(v8) = HIDWORD(v8);
    v372 = (v8 >> 31) - 899497514 + v364 + (v371 ^ v369 ^ v367);
    HIDWORD(v8) = v370;
    LODWORD(v8) = v370;
    v373 = v372 + (v8 >> 27);
    HIDWORD(v8) = v313 ^ v305 ^ v338 ^ v366;
    LODWORD(v8) = HIDWORD(v8);
    v374 = (v8 >> 31) - 899497514;
    HIDWORD(v8) = v367;
    LODWORD(v8) = v367;
    v375 = v8 >> 2;
    HIDWORD(v8) = v373;
    LODWORD(v8) = v373;
    v376 = v374 + v369 + (v375 ^ v371 ^ v370) + (v8 >> 27);
    HIDWORD(v8) = v319 ^ result ^ v344 ^ v368;
    LODWORD(v8) = HIDWORD(v8);
    v377 = v380 - 899497514 + (v8 >> 31);
    HIDWORD(v8) = v370;
    LODWORD(v8) = v370;
    v378 = v8 >> 2;
    v6 += v376;
    HIDWORD(v8) = v376;
    LODWORD(v8) = v376;
    v7 = v377 + v371 + (v378 ^ v375 ^ v373) + (v8 >> 27);
    HIDWORD(v8) = v373;
    LODWORD(v8) = v373;
    v5 += v8 >> 2;
    v4 += v378;
    v3 = v375 + v381;
    *a1 = v7;
    a1[1] = v6;
    a1[2] = v5;
    a1[3] = v4;
    a1[4] = v375 + v381;
    a2 += 16;
    a3 = v382 - 1;
  }
  while (v382 != 1);
  return result;
}

unsigned __int8 *__cdecl SHA256(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  SHA256_CTX v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  memset(&v5.Nl, 0, 76);
  *(_OWORD *)v5.h = xmmword_208F25B20;
  *(_OWORD *)&v5.h[4] = xmmword_208F25B30;
  v5.md_len = 32;
  SHA256_Update(&v5, d, n);
  sha256_final_impl(md, v5.md_len, (int32x2_t *)&v5);
  return md;
}

int SHA256_Update(SHA256_CTX *c, const void *data, size_t len)
{
  size_t v3;
  unsigned int *v4;
  unsigned int *v6;
  size_t v7;
  uint64_t num;
  uint64_t v9;

  if (len)
  {
    v3 = len;
    v4 = (unsigned int *)data;
    v6 = c->data;
    v7 = *(_QWORD *)&c->Nl + 8 * len;
    *(_QWORD *)&c->Nl = v7;
    num = c->num;
    if ((_DWORD)num)
    {
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy((char *)v6 + num, data, len);
        c->num += v3;
        return 1;
      }
      v9 = 64 - num;
      if ((_DWORD)num != 64)
        memcpy((char *)v6 + num, data, 64 - num);
      sha256_block_data_order((unint64_t)c, v6, 1);
      v4 = (unsigned int *)((char *)v4 + v9);
      v3 -= v9;
      c->num = 0;
      *(_OWORD *)v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      *((_OWORD *)v6 + 2) = 0u;
      *((_OWORD *)v6 + 3) = 0u;
    }
    if (v3 >= 0x40)
    {
      sha256_block_data_order((unint64_t)c, v4, v3 >> 6);
      v4 = (unsigned int *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->num = v3;
      memcpy(v6, v4, v3);
    }
  }
  return 1;
}

unint64_t sha256_block_data_order(unint64_t result, unsigned int *a2, uint64_t a3)
{
  unsigned int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  unint64_t v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unint64_t v32;
  int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  unint64_t v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  unint64_t v44;
  int v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  int v50;
  unint64_t v51;
  int v52;
  int v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  unint64_t v57;
  int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  unint64_t v63;
  int v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  unint64_t v69;
  int v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  int v75;
  unint64_t v76;
  int v77;
  int v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  unint64_t v82;
  int v83;
  int v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  unint64_t v88;
  int v89;
  int v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  unint64_t v94;
  int v95;
  unsigned int v96;
  unsigned int v97;
  unsigned int v98;
  int v99;
  unint64_t v100;
  int v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  int v105;
  unint64_t v106;
  int v107;
  unsigned int v108;
  unsigned int v109;
  int *v110;
  uint64_t v111;
  uint64_t v112;
  unsigned int v113;
  unint64_t v114;
  unint64_t v115;
  int v116;
  unsigned int v117;
  int v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  unsigned int v122;
  int v123;
  unint64_t v124;
  int v125;
  int v126;
  int v127;
  int v128;
  uint64_t v129;
  int v130;
  int v131;
  unsigned int v132;
  int v133;
  unint64_t v134;
  unsigned int v135;
  int v136;
  int v137;
  int v138;
  unint64_t v139;
  int v140;
  int v141;
  int v142;
  uint64_t v143;
  unsigned int v144;
  unsigned int v145;
  int v146;
  int v147;
  unint64_t v148;
  int v149;
  uint64_t v150;
  unsigned int v151;
  int v152;
  int v153;
  int v154;
  unint64_t v155;
  int v156;
  int v157;
  int v158;
  uint64_t v159;
  int v160;
  uint64_t v161;
  int v162;
  int v163;
  unsigned int v164;
  int v165;
  int v166;
  int v167;
  unint64_t v168;
  int v169;
  unsigned int v170;
  uint64_t v171;
  unsigned int v172;
  int v173;
  unsigned int v174;
  int v175;
  unint64_t v176;
  uint64_t v177;
  int v178;
  int v179;
  int v180;
  unint64_t v181;
  int v182;
  int v183;
  int v184;
  int v185;
  unsigned int v186;
  int v187;
  unint64_t v188;
  uint64_t v189;
  int v190;
  int v191;
  int v192;
  unint64_t v193;
  int v194;
  int v195;
  int v196;
  unint64_t v197;
  uint64_t v198;
  int v199;
  unint64_t v200;
  int v201;
  int v202;
  unint64_t v203;
  uint64_t v204;
  unint64_t v205;
  int v206;
  _DWORD *v207;
  int v208;
  int v209;
  int v210;
  int v211;
  int v212;
  int v213;
  int v214;
  unsigned int v215;
  unsigned int *v216;
  uint64_t v217;
  _DWORD v218[16];
  uint64_t v219;

  v207 = (_DWORD *)result;
  v219 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v3 = *(_DWORD *)result;
    v4 = *(_DWORD *)(result + 4);
    v6 = *(_DWORD *)(result + 8);
    v5 = *(_DWORD *)(result + 12);
    v8 = *(_DWORD *)(result + 16);
    v7 = *(_DWORD *)(result + 20);
    v9 = *(_DWORD *)(result + 24);
    LODWORD(result) = *(_DWORD *)(result + 28);
    do
    {
      v217 = a3;
      v10 = bswap32(*a2);
      HIDWORD(v11) = v8;
      LODWORD(v11) = v8;
      v12 = (v11 >> 6) ^ __ROR4__(v8, 11);
      v13 = __PAIR64__(v3, __ROR4__(v8, 25));
      v208 = result;
      v14 = result + (v8 & v7) + (v9 & ~v8) + v10 + (v12 ^ v13) + 1116352408;
      LODWORD(v13) = v3;
      v212 = v5;
      v15 = v14 + v5;
      v16 = ((v13 >> 2) ^ __ROR4__(v3, 13) ^ __ROR4__(v3, 22)) + ((v4 ^ v6) & v3 ^ v4 & v6) + v14;
      v17 = bswap32(a2[1]);
      HIDWORD(v13) = v15;
      LODWORD(v13) = v15;
      v218[0] = v10;
      v218[1] = v17;
      v18 = (v13 >> 6) ^ __ROR4__(v15, 11);
      v19 = __PAIR64__(v16, __ROR4__(v15, 25));
      v209 = v9;
      v20 = v9 + v17 + (v7 & ~v15) + (v15 & v8) + 1899447441 + (v18 ^ v19);
      LODWORD(v19) = v16;
      v213 = v6;
      v21 = v20 + v6;
      v22 = ((v19 >> 2) ^ __ROR4__(v16, 13) ^ __ROR4__(v16, 22)) + (v16 & (v3 ^ v4) ^ v3 & v4) + v20;
      v23 = bswap32(a2[2]);
      HIDWORD(v19) = v21;
      LODWORD(v19) = v21;
      v24 = (v19 >> 6) ^ __ROR4__(v21, 11);
      v26 = __PAIR64__(v22, __ROR4__(v21, 25));
      v25 = v24 ^ v26;
      v210 = v7;
      LODWORD(v26) = v22;
      v27 = v7 + v23 + (v8 & ~v21) + (v21 & v15) - 1245643825 + v25;
      v214 = v4;
      v28 = v27 + v4;
      v29 = ((v26 >> 2) ^ __ROR4__(v22, 13) ^ __ROR4__(v22, 22)) + (v22 & (v16 ^ v3) ^ v16 & v3) + v27;
      v30 = bswap32(a2[3]);
      v218[2] = v23;
      v218[3] = v30;
      HIDWORD(v26) = v28;
      LODWORD(v26) = v28;
      v31 = (v26 >> 6) ^ __ROR4__(v28, 11);
      v32 = __PAIR64__(v29, __ROR4__(v28, 25));
      v211 = v8;
      v33 = v8 + v30 + (v15 & ~v28) + (v28 & v21) - 373957723 + (v31 ^ v32);
      LODWORD(v32) = v29;
      v215 = v3;
      v34 = v33 + v3;
      v35 = ((v32 >> 2) ^ __ROR4__(v29, 13) ^ __ROR4__(v29, 22)) + (v29 & (v22 ^ v16) ^ v22 & v16) + v33;
      v36 = bswap32(a2[4]);
      HIDWORD(v32) = v34;
      LODWORD(v32) = v34;
      v37 = (v32 >> 6) ^ __ROR4__(v34, 11);
      v38 = __PAIR64__(v35, __ROR4__(v34, 25));
      v39 = v15 + v36 + (v21 & ~v34) + (v34 & v28) + 961987163 + (v37 ^ v38);
      LODWORD(v38) = v35;
      v40 = v39 + v16;
      v41 = ((v38 >> 2) ^ __ROR4__(v35, 13) ^ __ROR4__(v35, 22)) + (v35 & (v29 ^ v22) ^ v29 & v22) + v39;
      v42 = bswap32(a2[5]);
      v218[4] = v36;
      v218[5] = v42;
      HIDWORD(v38) = v40;
      LODWORD(v38) = v40;
      v43 = (v38 >> 6) ^ __ROR4__(v40, 11);
      v44 = __PAIR64__(v41, __ROR4__(v40, 25));
      v45 = v21 + v42 + (v28 & ~v40) + (v40 & v34) + 1508970993 + (v43 ^ v44);
      LODWORD(v44) = v41;
      v46 = v45 + v22;
      v47 = ((v44 >> 2) ^ __ROR4__(v41, 13) ^ __ROR4__(v41, 22)) + (v41 & (v35 ^ v29) ^ v35 & v29) + v45;
      v48 = bswap32(a2[6]);
      v49 = v48 + v28 + (v34 & ~v46) + (v46 & v40);
      HIDWORD(v44) = v46;
      LODWORD(v44) = v46;
      v50 = (v44 >> 6) ^ __ROR4__(v46, 11);
      v51 = __PAIR64__(v47, __ROR4__(v46, 25));
      v52 = v49 - 1841331548 + (v50 ^ v51);
      LODWORD(v51) = v47;
      v53 = v52 + v29;
      v54 = ((v51 >> 2) ^ __ROR4__(v47, 13) ^ __ROR4__(v47, 22)) + (v47 & (v41 ^ v35) ^ v41 & v35) + v52;
      v55 = bswap32(a2[7]);
      HIDWORD(v51) = v53;
      LODWORD(v51) = v53;
      v218[6] = v48;
      v218[7] = v55;
      v56 = (v51 >> 6) ^ __ROR4__(v53, 11);
      v57 = __PAIR64__(v54, __ROR4__(v53, 25));
      v58 = v55 + v34 + (v40 & ~v53) + (v53 & v46) - 1424204075 + (v56 ^ v57);
      LODWORD(v57) = v54;
      v59 = v58 + v35;
      v60 = ((v57 >> 2) ^ __ROR4__(v54, 13) ^ __ROR4__(v54, 22)) + (v54 & (v47 ^ v41) ^ v47 & v41) + v58;
      HIDWORD(v57) = v59;
      LODWORD(v57) = v59;
      v61 = bswap32(a2[8]);
      v62 = (v57 >> 6) ^ __ROR4__(v59, 11);
      v63 = __PAIR64__(v60, __ROR4__(v59, 25));
      v64 = v61 + v40 + (v46 & ~v59) + (v59 & v53) - 670586216 + (v62 ^ v63);
      LODWORD(v63) = v60;
      v65 = v64 + v41;
      v66 = ((v63 >> 2) ^ __ROR4__(v60, 13) ^ __ROR4__(v60, 22)) + (v60 & (v54 ^ v47) ^ v54 & v47) + v64;
      v67 = bswap32(a2[9]);
      v218[8] = v61;
      v218[9] = v67;
      HIDWORD(v63) = v65;
      LODWORD(v63) = v65;
      v68 = (v63 >> 6) ^ __ROR4__(v65, 11);
      v69 = __PAIR64__(v66, __ROR4__(v65, 25));
      v70 = v67 + v46 + (v53 & ~v65) + (v65 & v59) + 310598401 + (v68 ^ v69);
      LODWORD(v69) = v66;
      v71 = v70 + v47;
      v72 = ((v69 >> 2) ^ __ROR4__(v66, 13) ^ __ROR4__(v66, 22)) + (v66 & (v60 ^ v54) ^ v60 & v54) + v70;
      v73 = bswap32(a2[10]);
      v74 = v73 + v53 + (v59 & ~v71) + (v71 & v65);
      HIDWORD(v69) = v71;
      LODWORD(v69) = v71;
      v75 = (v69 >> 6) ^ __ROR4__(v71, 11);
      v76 = __PAIR64__(v72, __ROR4__(v71, 25));
      v77 = v74 + 607225278 + (v75 ^ v76);
      LODWORD(v76) = v72;
      v78 = v77 + v54;
      v79 = ((v76 >> 2) ^ __ROR4__(v72, 13) ^ __ROR4__(v72, 22)) + (v72 & (v66 ^ v60) ^ v66 & v60) + v77;
      v80 = bswap32(a2[11]);
      v218[10] = v73;
      v218[11] = v80;
      HIDWORD(v76) = v78;
      LODWORD(v76) = v78;
      v81 = (v76 >> 6) ^ __ROR4__(v78, 11);
      v82 = __PAIR64__(v79, __ROR4__(v78, 25));
      v83 = v80 + v59 + (v65 & ~v78) + (v78 & v71) + 1426881987 + (v81 ^ v82);
      LODWORD(v82) = v79;
      v84 = v83 + v60;
      v85 = ((v82 >> 2) ^ __ROR4__(v79, 13) ^ __ROR4__(v79, 22)) + (v79 & (v72 ^ v66) ^ v72 & v66) + v83;
      v86 = bswap32(a2[12]);
      HIDWORD(v82) = v84;
      LODWORD(v82) = v84;
      v87 = (v82 >> 6) ^ __ROR4__(v84, 11);
      v88 = __PAIR64__(v85, __ROR4__(v84, 25));
      v89 = v86 + v65 + (v71 & ~v84) + (v84 & v78) + 1925078388 + (v87 ^ v88);
      LODWORD(v88) = v85;
      v90 = v89 + v66;
      v91 = ((v88 >> 2) ^ __ROR4__(v85, 13) ^ __ROR4__(v85, 22)) + (v85 & (v79 ^ v72) ^ v79 & v72) + v89;
      v92 = bswap32(a2[13]);
      HIDWORD(v88) = v90;
      LODWORD(v88) = v90;
      v218[12] = v86;
      v218[13] = v92;
      v93 = (v88 >> 6) ^ __ROR4__(v90, 11);
      v94 = __PAIR64__(v91, __ROR4__(v90, 25));
      v95 = v92 + v71 + (v78 & ~v90) + (v90 & v84) - 2132889090 + (v93 ^ v94);
      LODWORD(v94) = v91;
      v96 = v95 + v72;
      v97 = ((v94 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v85 ^ v79) ^ v85 & v79) + v95;
      HIDWORD(v94) = v96;
      LODWORD(v94) = v95 + v72;
      v216 = a2;
      v98 = bswap32(a2[14]);
      v99 = (v94 >> 6) ^ __ROR4__(v96, 11);
      v100 = __PAIR64__(v97, __ROR4__(v96, 25));
      v101 = v98 + v78 + (v84 & ~v96) + (v96 & v90) - 1680079193 + (v99 ^ v100);
      LODWORD(v100) = v97;
      v102 = v101 + v79;
      v103 = ((v100 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v85) ^ v91 & v85) + v101;
      v104 = bswap32(a2[15]);
      v218[14] = v98;
      v218[15] = v104;
      HIDWORD(v100) = v102;
      LODWORD(v100) = v102;
      v105 = (v100 >> 6) ^ __ROR4__(v102, 11);
      v106 = __PAIR64__(v103, __ROR4__(v102, 25));
      v107 = v104 + v84 + (v90 & ~v102) + (v102 & v96) - 1046744716 + (v105 ^ v106);
      LODWORD(v106) = v103;
      v108 = v107 + v85;
      v109 = ((v106 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v107;
      v110 = &dword_208F30354;
      v111 = 31;
      do
      {
        v112 = ((int)v111 - 14) & 9;
        v113 = v218[v112];
        v114 = v111 - 15;
        HIDWORD(v115) = v113;
        LODWORD(v115) = v113;
        v116 = (v115 >> 7) ^ __ROR4__(v113, 18);
        v117 = v218[((_BYTE)v111 - 1) & 0xE];
        HIDWORD(v115) = v117;
        LODWORD(v115) = v117;
        v118 = v115 >> 17;
        v119 = __PAIR64__(v108, __ROR4__(v117, 19));
        v120 = (v111 - 15) & 8;
        v121 = (v111 - 15) & 8;
        v122 = (v116 ^ (v113 >> 3)) + v218[((int)v111 - 6) & 9] + v218[v120] + (v118 ^ v119 ^ (v117 >> 10));
        LODWORD(v119) = v108;
        v123 = (v119 >> 6) ^ __ROR4__(v108, 11);
        v124 = __PAIR64__(v109, __ROR4__(v108, 25));
        v125 = *(v110 - 6);
        v126 = (v108 & v102) + v90 + (v96 & ~v108) + *(v110 - 7) + (v123 ^ v124);
        LODWORD(v124) = v109;
        v218[v120] = v122;
        v127 = v126 + v122;
        v128 = ((v124 >> 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22)) + ((v103 ^ v97) & v109 ^ v103 & v97);
        v129 = 4 * (v121 | 2u);
        v130 = v127 + v91;
        HIDWORD(v124) = *(_DWORD *)((char *)v218 + v129);
        LODWORD(v124) = HIDWORD(v124);
        v131 = (v124 >> 7) ^ __ROR4__(HIDWORD(v124), 18) ^ (HIDWORD(v124) >> 3);
        v132 = v218[v111 & 0xF];
        HIDWORD(v124) = v132;
        LODWORD(v124) = v132;
        v133 = v124 >> 17;
        v134 = __PAIR64__(v127 + v91, __ROR4__(v132, 19));
        v135 = v128 + v127;
        v136 = v218[((int)v111 - 5) & 0xALL] + v113 + (v133 ^ v134 ^ (v132 >> 10));
        LODWORD(v134) = v130;
        v137 = (v134 >> 6) ^ __ROR4__(v130, 11);
        v139 = __PAIR64__(v135, __ROR4__(v130, 25));
        v138 = v137 ^ v139;
        v140 = v136 + v131;
        v218[v112] = v140;
        LODWORD(v139) = v135;
        v141 = ((v139 >> 2) ^ __ROR4__(v135, 13) ^ __ROR4__(v135, 22)) + (v135 & (v109 ^ v103) ^ v109 & v103);
        v142 = (v102 & ~v130) + v96 + (v130 & v108) + v125 + v140 + v138;
        v143 = v121 | 3u;
        v144 = v218[v143];
        v145 = v142 + v97;
        HIDWORD(v139) = v144;
        LODWORD(v139) = v144;
        v146 = v139 >> 7;
        HIDWORD(v139) = v122;
        LODWORD(v139) = v122;
        v147 = (v139 >> 17) ^ __ROR4__(v122, 19);
        v148 = __PAIR64__(v145, __ROR4__(v144, 18));
        v149 = v147 ^ (v122 >> 10);
        v150 = 4 * (((int)v111 - 13) & 0xALL);
        v151 = v141 + v142;
        v152 = v218[((int)v111 - 4) & 0xBLL] + *(_DWORD *)((char *)v218 + v150) + (v146 ^ v148 ^ (v144 >> 3)) + v149;
        LODWORD(v148) = v145;
        v153 = (v148 >> 6) ^ __ROR4__(v145, 11);
        v155 = __PAIR64__(v151, __ROR4__(v145, 25));
        v154 = v153 ^ v155;
        v157 = *(v110 - 5);
        v156 = *(v110 - 4);
        *(_DWORD *)((char *)v218 + v150) = v152;
        LODWORD(v155) = v151;
        LODWORD(v150) = (v155 >> 2) ^ __ROR4__(v151, 13) ^ __ROR4__(v151, 22);
        v158 = v157 + v102 + v152 + (v108 & ~v145) + (v145 & v130) + v154;
        v159 = v121 | 4u;
        HIDWORD(v155) = v218[v159];
        LODWORD(v155) = HIDWORD(v155);
        v160 = v155 >> 7;
        HIDWORD(v155) = v218[v121 | 1];
        LODWORD(v155) = HIDWORD(v155);
        v161 = ((int)v111 - 12) & 0xBLL;
        v162 = v160 ^ __ROR4__(v218[v159], 18) ^ (v218[v159] >> 3);
        v163 = v158 + v103;
        v164 = v150 + (v151 & (v135 ^ v109) ^ v135 & v109) + v158;
        v165 = v162
             + v218[((_BYTE)v111 - 3) & 0xC]
             + v218[v161]
             + ((v155 >> 17) ^ __ROR4__(HIDWORD(v155), 19) ^ (HIDWORD(v155) >> 10));
        HIDWORD(v155) = v163;
        LODWORD(v155) = v163;
        v166 = (v155 >> 6) ^ __ROR4__(v163, 11);
        v218[v161] = v165;
        v168 = __PAIR64__(v164, __ROR4__(v163, 25));
        v167 = v166 ^ v168;
        LODWORD(v168) = v164;
        v169 = v156 + v108 + v165 + (v130 & ~v163) + (v163 & v145) + v167;
        v170 = v169 + v109;
        v171 = v121 | 5u;
        v172 = ((v168 >> 2) ^ __ROR4__(v164, 13) ^ __ROR4__(v164, 22)) + (v164 & (v151 ^ v135) ^ v151 & v135) + v169;
        HIDWORD(v168) = v218[v171];
        LODWORD(v168) = HIDWORD(v168);
        v173 = v168 >> 7;
        v174 = *(_DWORD *)((char *)v218 + v129);
        HIDWORD(v168) = v174;
        LODWORD(v168) = v174;
        v175 = v168 >> 17;
        v176 = __PAIR64__(v170, __ROR4__(v174, 19));
        v177 = ((_BYTE)v111 - 11) & 0xC;
        v178 = (v173 ^ __ROR4__(v218[v171], 18) ^ (v218[v171] >> 3))
             + v218[((int)v111 - 2) & 0xDLL]
             + v218[v177]
             + (v175 ^ v176 ^ (v174 >> 10));
        LODWORD(v176) = v170;
        v179 = (v176 >> 6) ^ __ROR4__(v170, 11);
        v181 = __PAIR64__(v172, __ROR4__(v170, 25));
        v180 = v179 ^ v181;
        v182 = *(v110 - 3);
        LODWORD(v129) = *(v110 - 2);
        v218[v177] = v178;
        LODWORD(v181) = v172;
        v183 = v182 + v130 + v178 + (v145 & ~v170) + (v170 & v163) + v180;
        v184 = ((v181 >> 2) ^ __ROR4__(v172, 13) ^ __ROR4__(v172, 22)) + (v172 & (v164 ^ v151) ^ v164 & v151);
        v90 = v183 + v135;
        HIDWORD(v181) = v218[v121 | 6];
        LODWORD(v181) = HIDWORD(v181);
        v185 = (v181 >> 7) ^ __ROR4__(HIDWORD(v181), 18) ^ (HIDWORD(v181) >> 3);
        v186 = v218[v143];
        HIDWORD(v181) = v186;
        LODWORD(v181) = v186;
        v187 = v181 >> 17;
        v188 = __PAIR64__(v183 + v135, __ROR4__(v186, 19));
        v189 = 4 * (((int)v111 - 10) & 0xDLL);
        v91 = v184 + v183;
        v190 = *(_DWORD *)((char *)v218 + v189) + v117 + v185 + (v187 ^ v188 ^ (v186 >> 10));
        LODWORD(v188) = v90;
        *(_DWORD *)((char *)v218 + v189) = v190;
        v191 = (v188 >> 6) ^ __ROR4__(v90, 11);
        v193 = __PAIR64__(v91, __ROR4__(v90, 25));
        v192 = v191 ^ v193;
        LODWORD(v193) = v91;
        v194 = v129 + v190 + v145 + (v163 & ~v90) + (v90 & v170) + v192;
        v96 = v194 + v151;
        v97 = ((v193 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v172 ^ v164) ^ v172 & v164) + v194;
        HIDWORD(v193) = v218[v121 | 7];
        LODWORD(v193) = HIDWORD(v193);
        LODWORD(v150) = v218[v159];
        v195 = (v193 >> 7) ^ __ROR4__(HIDWORD(v193), 18) ^ (HIDWORD(v193) >> 3);
        HIDWORD(v193) = v150;
        LODWORD(v193) = v150;
        v196 = v193 >> 17;
        v197 = __PAIR64__(v96, __ROR4__(v150, 19));
        v198 = 4 * (((_BYTE)v111 - 9) & 0xE);
        LODWORD(v150) = v196 ^ v197 ^ (v150 >> 10);
        LODWORD(v197) = v96;
        v199 = *(_DWORD *)((char *)v218 + v198) + v132 + v195 + v150;
        LODWORD(v150) = (v197 >> 6) ^ __ROR4__(v96, 11);
        v200 = __PAIR64__(v97, __ROR4__(v96, 25));
        LODWORD(v150) = v150 ^ v200;
        *(_DWORD *)((char *)v218 + v198) = v199;
        LODWORD(v200) = v97;
        v201 = *(v110 - 1) + v199 + v163 + (v170 & ~v96) + (v96 & v90) + v150;
        v102 = v201 + v164;
        v103 = ((v200 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v172) ^ v91 & v172) + v201;
        LODWORD(v198) = v218[v121 ^ 8];
        HIDWORD(v200) = v198;
        LODWORD(v200) = v198;
        LODWORD(v189) = (v200 >> 7) ^ __ROR4__(v198, 18);
        LODWORD(v150) = v218[v171];
        HIDWORD(v200) = v150;
        LODWORD(v200) = v150;
        v202 = v200 >> 17;
        LODWORD(v198) = v189 ^ (v198 >> 3);
        v203 = __PAIR64__(v102, __ROR4__(v150, 19));
        v204 = 4 * (((_BYTE)v111 - 8) & 0xF);
        LODWORD(v189) = v202 ^ v203 ^ (v150 >> 10);
        LODWORD(v203) = v102;
        LODWORD(v150) = (v203 >> 6) ^ __ROR4__(v102, 11);
        LODWORD(v198) = *(_DWORD *)((char *)v218 + v204) + v198 + v122 + v189;
        v205 = __PAIR64__(v103, __ROR4__(v102, 25));
        LODWORD(v189) = v150 ^ v205;
        v206 = *v110;
        v110 += 8;
        *(_DWORD *)((char *)v218 + v204) = v198;
        LODWORD(v205) = v103;
        LODWORD(v204) = v206 + v198 + v170 + (v90 & ~v102) + (v102 & v96) + v189;
        v108 = v204 + v172;
        v109 = ((v205 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v204;
        v111 += 8;
      }
      while (v114 < 0x38);
      a2 = v216 + 16;
      v3 = v109 + v215;
      v4 = v103 + v214;
      *v207 = v109 + v215;
      v207[1] = v103 + v214;
      v6 = v97 + v213;
      v5 = v91 + v212;
      v207[2] = v97 + v213;
      v207[3] = v91 + v212;
      v8 = v108 + v211;
      v7 = v102 + v210;
      v207[4] = v108 + v211;
      v207[5] = v102 + v210;
      v9 = v96 + v209;
      result = (v90 + v208);
      v207[6] = v96 + v209;
      v207[7] = result;
      a3 = v217 - 1;
    }
    while (v217 != 1);
  }
  return result;
}

uint64_t sha256_final_impl(_DWORD *a1, unint64_t a2, int32x2_t *a3)
{
  int32x2_t *v6;
  int8x8_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  unint64_t v11;

  v6 = a3 + 5;
  v7 = (int8x8_t)a3[4];
  v8 = a3[13].u32[0];
  a3[5].i8[v8] = 0x80;
  v9 = v8 + 1;
  if (v8 < 0x38)
  {
    if (v8 == 55)
      goto LABEL_7;
  }
  else
  {
    if ((_DWORD)v8 != 63)
      bzero((char *)v6 + v9, 63 - v8);
    sha256_block_data_order((unint64_t)a3, (unsigned int *)v6, 1);
    v9 = 0;
  }
  bzero((char *)v6 + v9, 56 - v9);
LABEL_7:
  a3[12] = vrev64_s32((int32x2_t)vrev32_s8(v7));
  sha256_block_data_order((unint64_t)a3, (unsigned int *)v6, 1);
  result = 0;
  a3[13].i32[0] = 0;
  *(_OWORD *)v6->i8 = 0u;
  *(_OWORD *)v6[2].i8 = 0u;
  *(_OWORD *)v6[4].i8 = 0u;
  *(_OWORD *)v6[6].i8 = 0u;
  if (a2 <= 0x20)
  {
    if (a2 >= 4)
    {
      v11 = a2 >> 2;
      *a1 = bswap32(a3->i32[0]);
      if (a2 >> 2 != 1)
      {
        a1[1] = bswap32(a3->u32[1]);
        if (v11 != 2)
        {
          a1[2] = bswap32(a3[1].u32[0]);
          if (v11 != 3)
          {
            a1[3] = bswap32(a3[1].u32[1]);
            if (v11 != 4)
            {
              a1[4] = bswap32(a3[2].u32[0]);
              if (v11 != 5)
              {
                a1[5] = bswap32(a3[2].u32[1]);
                if (v11 != 6)
                {
                  a1[6] = bswap32(a3[3].u32[0]);
                  if (v11 != 7)
                    a1[7] = bswap32(a3[3].u32[1]);
                }
              }
            }
          }
        }
      }
    }
    return 1;
  }
  return result;
}

int SHA512_Update(SHA512_CTX *c, const void *data, size_t len)
{
  size_t v3;
  unint64_t *v4;
  SHA512state_st::$61765161EF95A25BF6D9F15268D2C4E6 *p_u;
  uint64_t num;
  uint64_t v8;
  size_t v9;
  char *v10;

  if (len)
  {
    v3 = len;
    v4 = (unint64_t *)data;
    p_u = &c->u;
    *(_OWORD *)&c->Nl += __PAIR128__(len >> 61, 8 * len);
    num = c->num;
    if ((_DWORD)num)
    {
      v8 = 128 - num;
      v9 = len - (128 - num);
      if (len < 128 - num)
      {
        memcpy((char *)p_u + num, data, len);
        LODWORD(v3) = c->num + v3;
LABEL_12:
        c->num = v3;
        return 1;
      }
      if ((_DWORD)num != 128)
        memcpy((char *)p_u + num, data, 128 - num);
      c->num = 0;
      v4 = (unint64_t *)((char *)v4 + v8);
      sha512_block_data_order((unint64_t)c, p_u->d, 1);
      v3 = v9;
    }
    if (v3 >= 0x80)
    {
      sha512_block_data_order((unint64_t)c, v4, v3 >> 7);
      v10 = (char *)v4 + v3;
      v3 &= 0x7Fu;
      v4 = (unint64_t *)&v10[-v3];
    }
    if (v3)
    {
      memcpy(p_u, v4, v3);
      goto LABEL_12;
    }
  }
  return 1;
}

uint64_t sha512_final_impl(_QWORD *a1, unint64_t a2, int8x16_t *a3)
{
  int8x16_t *v3;
  unint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  int8x16_t v9;
  unint64_t v10;
  unint64_t v11;

  v3 = a3;
  v6 = (unint64_t *)&a3[5];
  v7 = a3[13].u32[0];
  a3[5].i8[v7] = 0x80;
  v8 = v7 + 1;
  if (v7 < 0x70)
  {
    if (v7 == 111)
      goto LABEL_7;
  }
  else
  {
    if ((_DWORD)v7 != 127)
      bzero((char *)v6 + v8, 127 - v7);
    sha512_block_data_order((unint64_t)v3, v6, 1);
    v8 = 0;
  }
  bzero((char *)v6 + v8, 112 - v8);
LABEL_7:
  v9 = vrev64q_s8(v3[4]);
  v3[12] = vextq_s8(v9, v9, 8uLL);
  sha512_block_data_order((unint64_t)v3, v6, 1);
  if (!a1)
    return 0;
  if (a2 >= 8)
  {
    v10 = a2 >> 3;
    do
    {
      v11 = v3->i64[0];
      v3 = (int8x16_t *)((char *)v3 + 8);
      *a1++ = bswap64(v11);
      --v10;
    }
    while (v10);
  }
  return 1;
}

unint64_t sha512_block_data_order(unint64_t result, unint64_t *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t *v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  char *v80;
  char *v81;
  char *v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  char *v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unint64_t *v132;
  uint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  uint64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;
  unint64_t v141;
  unint64_t v142;

  v123 = (_QWORD *)result;
  if (a3)
  {
    v5 = *(_QWORD *)result;
    v4 = *(_QWORD *)(result + 8);
    v7 = *(_QWORD *)(result + 16);
    v6 = *(_QWORD *)(result + 24);
    v9 = *(_QWORD *)(result + 32);
    v8 = *(_QWORD *)(result + 40);
    v11 = *(_QWORD *)(result + 48);
    v10 = *(_QWORD *)(result + 56);
    do
    {
      v133 = a3;
      v12 = 0;
      v124 = v10;
      v142 = bswap64(*a2);
      v13 = v10
          + (v9 & v8)
          + (v11 & ~v9)
          + v142
          + (__ROR8__(v9, 14) ^ __ROR8__(v9, 18) ^ __ROR8__(v9, 41))
          + 0x428A2F98D728AE22;
      v128 = v6;
      v14 = v13 + v6;
      v15 = (__ROR8__(v5, 28) ^ __ROR8__(v5, 34) ^ __ROR8__(v5, 39)) + ((v4 ^ v7) & v5 ^ v4 & v7) + v13;
      v16 = bswap64(a2[1]);
      v125 = v11;
      v17 = v11
          + v16
          + (v8 & ~v14)
          + (v14 & v9)
          + 0x7137449123EF65CDLL
          + (__ROR8__(v14, 14) ^ __ROR8__(v14, 18) ^ __ROR8__(v14, 41));
      v129 = v7;
      v18 = v17 + v7;
      v19 = (__ROR8__(v15, 28) ^ __ROR8__(v15, 34) ^ __ROR8__(v15, 39)) + (v15 & (v5 ^ v4) ^ v5 & v4) + v17;
      v20 = bswap64(a2[2]);
      v126 = v8;
      v21 = v8
          + v20
          + (v9 & ~v18)
          + (v18 & v14)
          - 0x4A3F043013B2C4D1
          + (__ROR8__(v17 + v7, 14) ^ __ROR8__(v17 + v7, 18) ^ __ROR8__(v18, 41));
      v130 = v4;
      v22 = v21 + v4;
      v23 = (__ROR8__(v19, 28) ^ __ROR8__(v19, 34) ^ __ROR8__(v19, 39)) + (v19 & (v15 ^ v5) ^ v15 & v5) + v21;
      v24 = bswap64(a2[3]);
      v127 = v9;
      v25 = v9
          + v24
          + (v14 & ~v22)
          + (v22 & v18)
          - 0x164A245A7E762444
          + (__ROR8__(v22, 14) ^ __ROR8__(v22, 18) ^ __ROR8__(v22, 41));
      v131 = v5;
      v26 = v25 + v5;
      v27 = (__ROR8__(v23, 28) ^ __ROR8__(v23, 34) ^ __ROR8__(v23, 39)) + (v23 & (v19 ^ v15) ^ v19 & v15) + v25;
      v28 = bswap64(a2[4]);
      v29 = v14
          + v28
          + (v18 & ~v26)
          + (v26 & v22)
          + 0x3956C25BF348B538
          + (__ROR8__(v26, 14) ^ __ROR8__(v26, 18) ^ __ROR8__(v26, 41));
      v30 = v29 + v15;
      v31 = (__ROR8__(v27, 28) ^ __ROR8__(v27, 34) ^ __ROR8__(v27, 39)) + (v27 & (v23 ^ v19) ^ v23 & v19) + v29;
      v32 = bswap64(a2[5]);
      v33 = v32
          + v18
          + (v22 & ~v30)
          + (v30 & v26)
          + 0x59F111F1B605D019
          + (__ROR8__(v30, 14) ^ __ROR8__(v30, 18) ^ __ROR8__(v30, 41));
      v34 = v33 + v19;
      v35 = (__ROR8__(v31, 28) ^ __ROR8__(v31, 34) ^ __ROR8__(v31, 39)) + (v31 & (v27 ^ v23) ^ v27 & v23) + v33;
      v36 = bswap64(a2[6]);
      v37 = v36
          + v22
          + (v26 & ~v34)
          + (v34 & v30)
          - 0x6DC07D5B50E6B065
          + (__ROR8__(v34, 14) ^ __ROR8__(v34, 18) ^ __ROR8__(v34, 41));
      v38 = v37 + v23;
      v39 = (__ROR8__(v35, 28) ^ __ROR8__(v35, 34) ^ __ROR8__(v35, 39)) + (v35 & (v31 ^ v27) ^ v31 & v27) + v37;
      v141 = bswap64(a2[7]);
      v40 = v141
          + v26
          + (v30 & ~v38)
          + (v38 & v34)
          - 0x54E3A12A25927EE8
          + (__ROR8__(v38, 14) ^ __ROR8__(v38, 18) ^ __ROR8__(v38, 41));
      v41 = v40 + v27;
      v42 = (__ROR8__(v39, 28) ^ __ROR8__(v39, 34) ^ __ROR8__(v39, 39)) + (v39 & (v35 ^ v31) ^ v35 & v31) + v40;
      v140 = bswap64(a2[8]);
      v43 = v140
          + v30
          + (v34 & ~v41)
          + (v41 & v38)
          - 0x27F855675CFCFDBELL
          + (__ROR8__(v41, 14) ^ __ROR8__(v41, 18) ^ __ROR8__(v41, 41));
      v44 = v43 + v31;
      v45 = (__ROR8__(v42, 28) ^ __ROR8__(v42, 34) ^ __ROR8__(v42, 39)) + (v42 & (v39 ^ v35) ^ v39 & v35) + v43;
      v139 = bswap64(a2[9]);
      v46 = v139
          + v34
          + (v38 & ~v44)
          + (v44 & v41)
          + 0x12835B0145706FBELL
          + (__ROR8__(v44, 14) ^ __ROR8__(v44, 18) ^ __ROR8__(v44, 41));
      v47 = v46 + v35;
      v48 = (__ROR8__(v45, 28) ^ __ROR8__(v45, 34) ^ __ROR8__(v45, 39)) + (v45 & (v42 ^ v39) ^ v42 & v39) + v46;
      v138 = bswap64(a2[10]);
      v49 = v138
          + v38
          + (v41 & ~v47)
          + (v47 & v44)
          + 0x243185BE4EE4B28CLL
          + (__ROR8__(v47, 14) ^ __ROR8__(v47, 18) ^ __ROR8__(v47, 41));
      v50 = v49 + v39;
      v51 = (__ROR8__(v48, 28) ^ __ROR8__(v48, 34) ^ __ROR8__(v48, 39)) + (v48 & (v45 ^ v42) ^ v45 & v42) + v49;
      v52 = bswap64(a2[11]);
      v53 = v52
          + v41
          + (v44 & ~v50)
          + (v50 & v47)
          + 0x550C7DC3D5FFB4E2
          + (__ROR8__(v50, 14) ^ __ROR8__(v50, 18) ^ __ROR8__(v50, 41));
      v54 = v53 + v42;
      v55 = (__ROR8__(v51, 28) ^ __ROR8__(v51, 34) ^ __ROR8__(v51, 39)) + (v51 & (v48 ^ v45) ^ v48 & v45) + v53;
      v56 = bswap64(a2[12]);
      v57 = v56
          + v44
          + (v47 & ~v54)
          + (v54 & v50)
          + 0x72BE5D74F27B896FLL
          + (__ROR8__(v54, 14) ^ __ROR8__(v54, 18) ^ __ROR8__(v54, 41));
      v58 = v57 + v45;
      v59 = (__ROR8__(v55, 28) ^ __ROR8__(v55, 34) ^ __ROR8__(v55, 39)) + (v55 & (v51 ^ v48) ^ v51 & v48) + v57;
      v60 = bswap64(a2[13]);
      v61 = v60
          + v47
          + (v50 & ~v58)
          + (v58 & v54)
          - 0x7F214E01C4E9694FLL
          + (__ROR8__(v57 + v45, 14) ^ __ROR8__(v57 + v45, 18) ^ __ROR8__(v58, 41));
      v62 = v61 + v48;
      v63 = (__ROR8__(v59, 28) ^ __ROR8__(v59, 34) ^ __ROR8__(v59, 39)) + (v59 & (v55 ^ v51) ^ v55 & v51) + v61;
      v132 = a2;
      v64 = bswap64(a2[14]);
      v65 = v64
          + v50
          + (v54 & ~v62)
          + (v62 & v58)
          - 0x6423F958DA38EDCBLL
          + (__ROR8__(v61 + v48, 14) ^ __ROR8__(v61 + v48, 18) ^ __ROR8__(v62, 41));
      result = v65 + v51;
      v66 = (__ROR8__(v63, 28) ^ __ROR8__(v63, 34) ^ __ROR8__(v63, 39)) + (v63 & (v59 ^ v55) ^ v59 & v55) + v65;
      v67 = bswap64(a2[15]);
      v68 = v67
          + v54
          + (v58 & ~result)
          + (result & v62)
          - 0x3E640E8B3096D96CLL
          + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
      v69 = v68 + v55;
      v70 = (__ROR8__(v66, 28) ^ __ROR8__(v66, 34) ^ __ROR8__(v66, 39)) + (v66 & (v63 ^ v59) ^ v63 & v59) + v68;
      v71 = &qword_208F304F0;
      do
      {
        v136 = v52;
        v137 = v12;
        v72 = (__ROR8__(v16, 1) ^ __ROR8__(v16, 8) ^ (v16 >> 7))
            + v142
            + v139
            + (__ROR8__(v64, 19) ^ __ROR8__(v64, 61) ^ (v64 >> 6));
        v73 = v72
            + v58
            + (v69 & result)
            + (v62 & ~v69)
            + (__ROR8__(v69, 14) ^ __ROR8__(v69, 18) ^ __ROR8__(v69, 41))
            + *(v71 - 15);
        v74 = v73 + v59;
        v75 = v73 + ((v66 ^ v63) & v70 ^ v66 & v63) + (__ROR8__(v70, 28) ^ __ROR8__(v70, 34) ^ __ROR8__(v70, 39));
        v135 = v56;
        v16 += (__ROR8__(v20, 1) ^ __ROR8__(v20, 8) ^ (v20 >> 7))
             + v138
             + (__ROR8__(v67, 19) ^ __ROR8__(v67, 61) ^ (v67 >> 6));
        v76 = v16
            + v62
            + *(v71 - 14)
            + (result & ~v74)
            + (v74 & v69)
            + (__ROR8__(v74, 14) ^ __ROR8__(v74, 18) ^ __ROR8__(v74, 41));
        v77 = v76 + v63;
        v78 = v76 + (v75 & (v70 ^ v66) ^ v70 & v66) + (__ROR8__(v75, 28) ^ __ROR8__(v75, 34) ^ __ROR8__(v75, 39));
        v79 = (__ROR8__(v24, 1) ^ __ROR8__(v24, 8) ^ (v24 >> 7))
            + v20
            + v52
            + (__ROR8__(v72, 19) ^ __ROR8__(v72, 61) ^ (v72 >> 6));
        v80 = (char *)(v79
                     + result
                     + *(v71 - 13)
                     + (v69 & ~v77)
                     + (v77 & v74)
                     + (__ROR8__(v76 + v63, 14) ^ __ROR8__(v76 + v63, 18) ^ __ROR8__(v77, 41)));
        v81 = &v80[v66];
        v82 = &v80[(v78 & (v75 ^ v70) ^ v75 & v70) + (__ROR8__(v78, 28) ^ __ROR8__(v78, 34) ^ __ROR8__(v78, 39))];
        v83 = (__ROR8__(v28, 1) ^ __ROR8__(v28, 8) ^ (v28 >> 7))
            + v24
            + v56
            + (__ROR8__(v16, 19) ^ __ROR8__(v16, 61) ^ (v16 >> 6));
        v84 = v83
            + v69
            + *(v71 - 12)
            + (v74 & ~(unint64_t)v81)
            + ((unint64_t)v81 & v77)
            + (__ROR8__(&v80[v66], 14) ^ __ROR8__(&v80[v66], 18) ^ __ROR8__(&v80[v66], 41));
        v85 = v84 + v70;
        v86 = v84
            + ((unint64_t)v82 & (v78 ^ v75) ^ v78 & v75)
            + (__ROR8__(v82, 28) ^ __ROR8__(v82, 34) ^ __ROR8__(v82, 39));
        v134 = v79;
        v87 = (__ROR8__(v32, 1) ^ __ROR8__(v32, 8) ^ (v32 >> 7))
            + v28
            + v60
            + (__ROR8__(v79, 19) ^ __ROR8__(v79, 61) ^ (v79 >> 6));
        v88 = v74
            + *(v71 - 11)
            + v87
            + (v77 & ~v85)
            + (v85 & (unint64_t)v81)
            + (__ROR8__(v84 + v70, 14) ^ __ROR8__(v84 + v70, 18) ^ __ROR8__(v85, 41));
        v89 = v88 + v75;
        v90 = v88
            + (v86 & ((unint64_t)v82 ^ v78) ^ (unint64_t)v82 & v78)
            + (__ROR8__(v86, 28) ^ __ROR8__(v86, 34) ^ __ROR8__(v86, 39));
        v32 += (__ROR8__(v36, 1) ^ __ROR8__(v36, 8) ^ (v36 >> 7))
             + v64
             + (__ROR8__(v83, 19) ^ __ROR8__(v83, 61) ^ (v83 >> 6));
        v91 = *(v71 - 10)
            + v77
            + v32
            + ((unint64_t)v81 & ~v89)
            + (v89 & v85)
            + (__ROR8__(v89, 14) ^ __ROR8__(v89, 18) ^ __ROR8__(v89, 41));
        v92 = v91 + v78;
        v93 = v91
            + (v90 & (v86 ^ (unint64_t)v82) ^ v86 & (unint64_t)v82)
            + (__ROR8__(v90, 28) ^ __ROR8__(v90, 34) ^ __ROR8__(v90, 39));
        v36 += (__ROR8__(v141, 1) ^ __ROR8__(v141, 8) ^ (v141 >> 7))
             + v67
             + (__ROR8__(v87, 19) ^ __ROR8__(v87, 61) ^ (v87 >> 6));
        v94 = (unint64_t)&v81[*(v71 - 9)
                                   + v36
                                   + (v85 & ~v92)
                                   + (v92 & v89)
                                   + (__ROR8__(v92, 14) ^ __ROR8__(v92, 18) ^ __ROR8__(v92, 41))];
        v95 = &v82[v94];
        v96 = v94 + (v93 & (v90 ^ v86) ^ v90 & v86) + (__ROR8__(v93, 28) ^ __ROR8__(v93, 34) ^ __ROR8__(v93, 39));
        v97 = (__ROR8__(v140, 1) ^ __ROR8__(v140, 8) ^ (v140 >> 7))
            + v141
            + v72
            + (__ROR8__(v32, 19) ^ __ROR8__(v32, 61) ^ (v32 >> 6));
        v98 = v97
            + *(v71 - 8)
            + v85
            + (v89 & ~(unint64_t)v95)
            + ((unint64_t)v95 & v92)
            + (__ROR8__(&v82[v94], 14) ^ __ROR8__(&v82[v94], 18) ^ __ROR8__(v95, 41));
        v99 = v98 + v86;
        v100 = v98 + (v96 & (v93 ^ v90) ^ v93 & v90) + (__ROR8__(v96, 28) ^ __ROR8__(v96, 34) ^ __ROR8__(v96, 39));
        v101 = (__ROR8__(v139, 1) ^ __ROR8__(v139, 8) ^ (v139 >> 7))
             + v140
             + v16
             + (__ROR8__(v36, 19) ^ __ROR8__(v36, 61) ^ (v36 >> 6));
        v102 = v101
             + *(v71 - 7)
             + v89
             + (v92 & ~v99)
             + (v99 & (unint64_t)v95)
             + (__ROR8__(v98 + v86, 14) ^ __ROR8__(v98 + v86, 18) ^ __ROR8__(v99, 41));
        v103 = v102 + v90;
        v104 = v102 + (v100 & (v96 ^ v93) ^ v96 & v93) + (__ROR8__(v100, 28) ^ __ROR8__(v100, 34) ^ __ROR8__(v100, 39));
        v105 = (__ROR8__(v138, 1) ^ __ROR8__(v138, 8) ^ (v138 >> 7))
             + v139
             + v134
             + (__ROR8__(v97, 19) ^ __ROR8__(v97, 61) ^ (v97 >> 6));
        v106 = v105
             + *(v71 - 6)
             + v92
             + ((unint64_t)v95 & ~v103)
             + (v103 & v99)
             + (__ROR8__(v103, 14) ^ __ROR8__(v103, 18) ^ __ROR8__(v103, 41));
        v107 = v106 + v93;
        v108 = v106
             + (v104 & (v100 ^ v96) ^ v100 & v96)
             + (__ROR8__(v104, 28) ^ __ROR8__(v104, 34) ^ __ROR8__(v104, 39));
        v109 = (__ROR8__(v136, 1) ^ __ROR8__(v136, 8) ^ (v136 >> 7))
             + v138
             + v83
             + (__ROR8__(v101, 19) ^ __ROR8__(v101, 61) ^ (v101 >> 6));
        v110 = (uint64_t)&v95[v109
                           + *(v71 - 5)
                           + (v99 & ~v107)
                           + (v107 & v103)
                           + (__ROR8__(v107, 14) ^ __ROR8__(v107, 18) ^ __ROR8__(v107, 41))];
        v111 = v110 + v96;
        v112 = v110
             + (v108 & (v104 ^ v100) ^ v104 & v100)
             + (__ROR8__(v108, 28) ^ __ROR8__(v108, 34) ^ __ROR8__(v108, 39));
        v139 = v105;
        v52 = (__ROR8__(v135, 1) ^ __ROR8__(v135, 8) ^ (v135 >> 7))
            + v136
            + v87
            + (__ROR8__(v105, 19) ^ __ROR8__(v105, 61) ^ (v105 >> 6));
        v113 = v52
             + *(v71 - 4)
             + v99
             + (v103 & ~v111)
             + (v111 & v107)
             + (__ROR8__(v110 + v96, 14) ^ __ROR8__(v110 + v96, 18) ^ __ROR8__(v111, 41));
        v114 = v113 + v100;
        v115 = v113
             + (v112 & (v108 ^ v104) ^ v108 & v104)
             + (__ROR8__(v112, 28) ^ __ROR8__(v112, 34) ^ __ROR8__(v112, 39));
        v138 = v109;
        v28 = v87;
        v56 = (__ROR8__(v60, 1) ^ __ROR8__(v60, 8) ^ (v60 >> 7))
            + v135
            + v32
            + (__ROR8__(v109, 19) ^ __ROR8__(v109, 61) ^ (v109 >> 6));
        v116 = v56
             + *(v71 - 3)
             + v103
             + (v107 & ~v114)
             + (v114 & v111)
             + (__ROR8__(v114, 14) ^ __ROR8__(v114, 18) ^ __ROR8__(v114, 41));
        v58 = v116 + v104;
        v59 = v116
            + (v115 & (v112 ^ v108) ^ v112 & v108)
            + (__ROR8__(v115, 28) ^ __ROR8__(v115, 34) ^ __ROR8__(v115, 39));
        v60 += (__ROR8__(v64, 1) ^ __ROR8__(v64, 8) ^ (v64 >> 7))
             + v36
             + (__ROR8__(v52, 19) ^ __ROR8__(v52, 61) ^ (v52 >> 6));
        v117 = v60
             + *(v71 - 2)
             + v107
             + (v111 & ~v58)
             + (v58 & v114)
             + (__ROR8__(v116 + v104, 14) ^ __ROR8__(v116 + v104, 18) ^ __ROR8__(v58, 41));
        v62 = v117 + v108;
        v63 = v117 + (v59 & (v115 ^ v112) ^ v115 & v112) + (__ROR8__(v59, 28) ^ __ROR8__(v59, 34) ^ __ROR8__(v59, 39));
        v141 = v97;
        v118 = (__ROR8__(v67, 1) ^ __ROR8__(v67, 8) ^ (v67 >> 7)) + v64 + v97;
        v20 = v134;
        v64 = v118 + (__ROR8__(v56, 19) ^ __ROR8__(v56, 61) ^ (v56 >> 6));
        v119 = v64
             + *(v71 - 1)
             + v111
             + (v114 & ~v62)
             + (v62 & v58)
             + (__ROR8__(v62, 14) ^ __ROR8__(v62, 18) ^ __ROR8__(v62, 41));
        result = v119 + v112;
        v66 = v119 + (v63 & (v59 ^ v115) ^ v59 & v115) + (__ROR8__(v63, 28) ^ __ROR8__(v63, 34) ^ __ROR8__(v63, 39));
        v142 = v72;
        v140 = v101;
        v120 = (__ROR8__(v72, 1) ^ __ROR8__(v72, 8) ^ (v72 >> 7)) + v67 + v101;
        v24 = v83;
        v67 = v120 + (__ROR8__(v60, 19) ^ __ROR8__(v60, 61) ^ (v60 >> 6));
        v121 = *v71;
        v71 += 16;
        v122 = v67
             + v121
             + v114
             + (v58 & ~result)
             + (result & v62)
             + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
        v69 = v122 + v115;
        v70 = v122 + (v66 & (v63 ^ v59) ^ v63 & v59) + (__ROR8__(v66, 28) ^ __ROR8__(v66, 34) ^ __ROR8__(v66, 39));
        v12 = v137 + 16;
      }
      while ((unint64_t)(v137 + 16) < 0x40);
      v5 += v70;
      v4 = v66 + v130;
      *v123 = v70 + v131;
      v123[1] = v66 + v130;
      v7 = v63 + v129;
      v6 = v59 + v128;
      v123[2] = v63 + v129;
      v123[3] = v59 + v128;
      v9 = v69 + v127;
      v8 = result + v126;
      v123[4] = v69 + v127;
      v123[5] = result + v126;
      v11 = v62 + v125;
      v10 = v58 + v124;
      a2 = v132 + 16;
      v123[6] = v62 + v125;
      v123[7] = v58 + v124;
      a3 = v133 - 1;
    }
    while (v133 != 1);
  }
  return result;
}

int BN_lshift(BIGNUM *r, const BIGNUM *a, int n)
{
  uint64_t v6;
  int v7;
  int result;
  unint64_t *d;
  unint64_t *v10;
  unint64_t top;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  char *v19;
  unint64_t *v20;
  unint64_t *v21;
  unint64_t *v22;
  BOOL v23;
  BOOL v24;
  BOOL v25;
  BOOL v26;
  BOOL v27;
  unint64_t v28;
  uint64x2_t v29;
  int8x16_t *v30;
  int8x16_t *v31;
  uint64x2_t v32;
  uint64_t v33;
  int8x16_t v34;
  uint64x2_t v35;
  int8x16_t v36;
  int8x16_t v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  BOOL v41;
  unint64_t *v42;
  unint64_t *v43;
  unint64_t *v44;
  unint64_t *v45;
  uint64_t v46;
  __int128 v47;
  unint64_t *v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;

  if (n < 0)
  {
    ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/shift.c", 73);
    return 0;
  }
  r->neg = a->neg;
  v6 = n >> 6;
  v7 = v6 + 1;
  result = bn_wexpand((uint64_t)r, a->top + (int)v6 + 1);
  if (!result)
    return result;
  d = a->d;
  v10 = r->d;
  top = a->top;
  r->d[(int)top + (int)v6] = 0;
  v12 = n & 0x3F;
  if ((n & 0x3F) != 0)
  {
    if ((int)top >= 1)
    {
      if (top < 0x26)
        goto LABEL_39;
      v13 = top - 1;
      v14 = 8 * (top - 1);
      v15 = top;
      if (&d[top - 1 + v14 / 0xFFFFFFFFFFFFFFF8] > &d[top - 1])
        goto LABEL_39;
      v16 = v6 + top;
      if (&v10[v16 - 1 + v14 / 0xFFFFFFFFFFFFFFF8] > &v10[v16 - 1])
        goto LABEL_39;
      v17 = top + v6;
      if (&v10[(int)top + (int)v6 + v14 / 0xFFFFFFFFFFFFFFF8] > &v10[(int)top + (int)v6]
        || v17 - (int)v13 > v17
        || HIDWORD(v13))
      {
        goto LABEL_39;
      }
      v18 = 8 * ((int)top + (int)v6) + 8;
      v19 = (char *)v10 + v18 - v15 * 8;
      v20 = (unint64_t *)((char *)v10 + v18);
      v21 = &v10[v6];
      v22 = &v10[v6 + top];
      v23 = v19 >= (char *)&d[v15] || d >= v20;
      v24 = !v23;
      v25 = v21 >= &d[v15] || d >= v22;
      v26 = !v25;
      v27 = v21 >= v20 || v19 >= (char *)v22;
      if (!v27 || v24 || v26)
      {
LABEL_39:
        v28 = top;
      }
      else
      {
        v28 = top & 1;
        v29 = (uint64x2_t)vdupq_n_s64(v12);
        v30 = (int8x16_t *)&d[v15 - 2];
        v31 = (int8x16_t *)&v10[v16 - 2];
        v32 = (uint64x2_t)vnegq_s64(vdupq_n_s64((64 - v12)));
        v33 = top & 0xFFFFFFFE;
        do
        {
          v34 = *v30--;
          v35 = (uint64x2_t)vextq_s8(v34, v34, 8uLL);
          v36 = (int8x16_t)vshlq_u64(v35, v32);
          *(int8x16_t *)&v10[v17 - 1] = vorrq_s8(*(int8x16_t *)&v10[v17 - 1], vextq_s8(v36, v36, 8uLL));
          v37 = (int8x16_t)vshlq_u64(v35, v29);
          *v31-- = vextq_s8(v37, v37, 8uLL);
          v17 -= 2;
          v33 -= 2;
        }
        while (v33);
        if ((top & 0xFFFFFFFE) == top)
          goto LABEL_49;
      }
      v39 = d - 1;
      do
      {
        v40 = v39[v28];
        v10[(int)v6 + (int)v28] |= v40 >> (64 - (n & 0x3Fu));
        v10[v6 - 1 + v28] = v40 << (n & 0x3F);
        v41 = v28-- > 1;
      }
      while (v41);
    }
  }
  else if ((int)top >= 1)
  {
    if (top >= 0xE)
    {
      v42 = &d[top];
      v43 = &v10[v6 + top];
      v38 = top;
      if ((unint64_t)((char *)v42 - (char *)v43) >= 0x20)
      {
        v38 = top & 3;
        v44 = v42 - 2;
        v45 = v43 - 2;
        v46 = top & 0xFFFFFFFC;
        do
        {
          v47 = *(_OWORD *)v44;
          *((_OWORD *)v45 - 1) = *((_OWORD *)v44 - 1);
          *(_OWORD *)v45 = v47;
          v44 -= 4;
          v45 -= 4;
          v46 -= 4;
        }
        while (v46);
        if ((top & 0x7FFFFFFC) == top)
          goto LABEL_49;
      }
    }
    else
    {
      v38 = top;
    }
    v48 = d - 1;
    do
    {
      v10[v6 - 1 + v38] = v48[v38];
      v41 = v38-- > 1;
    }
    while (v41);
  }
LABEL_49:
  if (n >= 0x40)
  {
    bzero(v10, (8 * v6));
    LODWORD(top) = a->top;
  }
  v49 = top + v7;
  v50 = 8 * (top + v7) - 8;
  v51 = top + v6 + 2;
  while (--v51 >= 1)
  {
    v52 = *(unint64_t *)((char *)r->d + v50);
    v50 -= 8;
    if (v52)
    {
      r->top = v51;
      return 1;
    }
  }
  r->top = v49 & (v49 >> 31);
  if ((v49 & 0x80000000) == 0)
  {
    r->neg = 0;
    return 1;
  }
  return 1;
}

void bn_rshift_words(int8x16_t *__dst, uint64_t a2, unsigned int a3, unint64_t a4)
{
  unint64_t v6;
  uint64_t v7;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64x2_t v12;
  uint64_t v13;
  int8x16_t *v14;
  uint64x2_t v15;
  unint64_t v16;
  int8x16_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  _QWORD *v21;

  v6 = a3 >> 6;
  v7 = a4 - v6;
  if (a4 <= v6)
  {
    if (a4)
      bzero(__dst, 8 * a4);
  }
  else
  {
    v9 = a3 & 0x3F;
    if ((a3 & 0x3F) != 0)
    {
      if (a4 - 1 > v6)
      {
        v10 = ~v6 + a4;
        v11 = a3 >> 6;
        if (v10 < 6)
          goto LABEL_10;
        if (a2 + 8 * a4 > (unint64_t)__dst)
        {
          v11 = a3 >> 6;
          if (a2 + 8 * v6 < (unint64_t)&__dst->u64[-1] + 8 * a4 - 8 * v6)
            goto LABEL_10;
        }
        v12 = (uint64x2_t)vdupq_n_s64((64 - v9));
        v11 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + v6;
        v13 = a2 + 8 * v6 + 16;
        v14 = __dst + 1;
        v15 = (uint64x2_t)vnegq_s64(vdupq_n_s64(v9));
        v16 = v10 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v17 = vorrq_s8((int8x16_t)vshlq_u64(*(uint64x2_t *)(v13 + 8), v12), (int8x16_t)vshlq_u64(*(uint64x2_t *)v13, v15));
          v14[-1] = vorrq_s8((int8x16_t)vshlq_u64(*(uint64x2_t *)(v13 - 8), v12), (int8x16_t)vshlq_u64(*(uint64x2_t *)(v13 - 16), v15));
          *v14 = v17;
          v13 += 32;
          v14 += 2;
          v16 -= 4;
        }
        while (v16);
        if (v10 != (v10 & 0xFFFFFFFFFFFFFFFCLL))
        {
LABEL_10:
          v18 = 8 * v11;
          v19 = &__dst->i8[8 * v11 - 8 * v6];
          v20 = ~v11 + a4;
          v21 = (_QWORD *)(v18 + a2 + 8);
          do
          {
            *(_QWORD *)v19 = (*v21 << (64 - (a3 & 0x3F))) | (*(v21 - 1) >> (a3 & 0x3F));
            v19 += 8;
            ++v21;
            --v20;
          }
          while (v20);
        }
      }
      __dst->i64[a4 - 1 - v6] = *(_QWORD *)(a2 + 8 * (a4 - 1)) >> (a3 & 0x3F);
    }
    else if (8 * v7)
    {
      memmove(__dst, (const void *)(a2 + 8 * v6), 8 * v7);
    }
    if (a3 >= 0x40)
      bzero((char *)__dst + 8 * a4 + -8 * v6, 8 * v6);
  }
}

int BN_rshift(BIGNUM *r, const BIGNUM *a, int n)
{
  int result;
  uint64_t top;
  uint64_t v8;
  int v9;
  BOOL v10;
  uint64_t v11;

  if (n < 0)
  {
    ERR_put_error(3, 0, 109, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/shift.c", 158);
    return 0;
  }
  else
  {
    result = bn_wexpand((uint64_t)r, a->top);
    if (result)
    {
      bn_rshift_words((int8x16_t *)r->d, (uint64_t)a->d, n, a->top);
      r->neg = a->neg;
      top = a->top;
      v8 = 8 * top - 8;
      v9 = a->top;
      while (1)
      {
        v10 = __OFSUB__(v9--, 1);
        if (v9 < 0 != v10)
          break;
        v11 = *(unint64_t *)((char *)r->d + v8);
        v8 -= 8;
        if (v11)
        {
          r->top = v9 + 1;
          return 1;
        }
      }
      r->top = top & ((int)top >> 31);
      if ((top & 0x80000000) == 0)
        r->neg = 0;
      return 1;
    }
  }
  return result;
}

uint64_t bn_rshift_secret_shift(uint64_t a1, uint64_t a2, unsigned int a3, BN_CTX *ctx)
{
  BIGNUM *v8;
  BIGNUM *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  _QWORD *v15;
  signed int v16;
  char v17;
  unsigned int v18;
  int8x16_t *d;
  int8x16_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t *v27;
  int8x16_t *v28;
  unint64_t v29;
  int8x16_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v37;
  uint64_t v38;

  if (!*((_BYTE *)ctx + 40))
  {
    v11 = *((_QWORD *)ctx + 4);
    v12 = *((_QWORD *)ctx + 2);
    if (v12 == *((_QWORD *)ctx + 3))
    {
      if (v12)
        v13 = (3 * v12) >> 1;
      else
        v13 = 32;
      v14 = v13 > v12 && v13 >> 61 == 0;
      if (!v14 || (v15 = OPENSSL_realloc(*((_QWORD **)ctx + 1), 8 * v13)) == 0)
      {
        *((_WORD *)ctx + 20) = 257;
        v8 = BN_CTX_get(ctx);
        if (!v8)
          goto LABEL_45;
        goto LABEL_3;
      }
      *((_QWORD *)ctx + 1) = v15;
      *((_QWORD *)ctx + 3) = v13;
      v12 = *((_QWORD *)ctx + 2);
    }
    else
    {
      v15 = (_QWORD *)*((_QWORD *)ctx + 1);
    }
    v15[v12] = v11;
    ++*((_QWORD *)ctx + 2);
    v8 = BN_CTX_get(ctx);
    if (!v8)
      goto LABEL_45;
    goto LABEL_3;
  }
  v8 = BN_CTX_get(ctx);
  if (!v8)
    goto LABEL_45;
LABEL_3:
  v9 = v8;
  if (a2 == a1)
  {
    if (!a2)
      goto LABEL_42;
    if (!bn_wexpand((uint64_t)v8, *(int *)(a2 + 8)))
    {
LABEL_45:
      a2 = 0;
      if (*((_BYTE *)ctx + 40))
        return a2;
LABEL_46:
      v37 = *((_QWORD *)ctx + 1);
      v38 = *((_QWORD *)ctx + 2) - 1;
      *((_QWORD *)ctx + 2) = v38;
      *((_QWORD *)ctx + 4) = *(_QWORD *)(v37 + 8 * v38);
      return a2;
    }
  }
  else
  {
    if (!bn_wexpand(a1, *(int *)(a2 + 8)))
      goto LABEL_45;
    v10 = *(int *)(a2 + 8);
    if ((_DWORD)v10)
    {
      memcpy(*(void **)a1, *(const void **)a2, 8 * v10);
      LODWORD(v10) = *(_DWORD *)(a2 + 8);
    }
    *(_DWORD *)(a1 + 8) = v10;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    if (!bn_wexpand((uint64_t)v9, (int)v10))
      goto LABEL_45;
  }
  v16 = *(_DWORD *)(a1 + 8);
  a2 = 1;
  if (!v16)
    goto LABEL_42;
  v17 = 0;
  v18 = v16 << 6;
  d = (int8x16_t *)v9->d;
  v20 = *(int8x16_t **)a1;
  do
  {
    bn_rshift_words(d, (uint64_t)v20, 1 << v17, v16);
    v20 = *(int8x16_t **)a1;
    d = (int8x16_t *)v9->d;
    v16 = *(_DWORD *)(a1 + 8);
    if (!v16)
      goto LABEL_24;
    v21 = 0;
    v22 = -(uint64_t)((a3 >> v17) & 1);
    v23 = ((a3 >> v17) & 1) - 1;
    if (v16 < 4)
      goto LABEL_35;
    if (v20 < (int8x16_t *)((char *)d + 8 * v16) && d < (int8x16_t *)((char *)v20 + 8 * v16))
    {
      v21 = 0;
LABEL_35:
      v31 = v16 - v21;
      v32 = v21;
      v33 = (unint64_t *)v20 + v21;
      v34 = &d->i64[v32];
      do
      {
        v35 = *v34++;
        *v33 = *v33 & v23 | v35 & v22;
        ++v33;
        --v31;
      }
      while (v31);
      goto LABEL_24;
    }
    v25 = (int8x16_t)vdupq_n_s64(v22);
    v21 = v16 & 0xFFFFFFFFFFFFFFFCLL;
    v26 = (int8x16_t)vdupq_n_s64(v23);
    v27 = d + 1;
    v28 = v20 + 1;
    v29 = v21;
    do
    {
      v30 = vorrq_s8(vandq_s8(*v28, v26), vandq_s8(*v27, v25));
      v28[-1] = vorrq_s8(vandq_s8(v28[-1], v26), vandq_s8(v27[-1], v25));
      *v28 = v30;
      v27 += 2;
      v28 += 2;
      v29 -= 4;
    }
    while (v29);
    if (v21 != v16)
      goto LABEL_35;
LABEL_24:
    ++v17;
  }
  while (v18 >> v17);
  a2 = 1;
LABEL_42:
  if (!*((_BYTE *)ctx + 40))
    goto LABEL_46;
  return a2;
}

int BN_rshift1(BIGNUM *r, const BIGNUM *a)
{
  int result;
  unint64_t *d;
  uint64_t top;
  unint64_t *v7;
  uint64_t v8;
  BOOL v9;
  unint64_t v10;
  unint64_t *v11;
  int8x16_t *v12;
  unint64_t v13;
  int8x16_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  int v19;
  BOOL v20;

  result = bn_wexpand((uint64_t)r, a->top);
  if (!result)
    return result;
  d = r->d;
  top = a->top;
  if ((_DWORD)top)
  {
    v7 = a->d;
    v8 = (int)top - 1;
    if ((int)top != 1)
    {
      if (top >= 7 && (d < &v7[(int)top] ? (v9 = v7 >= &d[(int)top - 1]) : (v9 = 1), v9))
      {
        v10 = v8 & 0xFFFFFFFFFFFFFFFCLL;
        v11 = v7 + 2;
        v12 = (int8x16_t *)(d + 2);
        v13 = v8 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v14 = vorrq_s8((int8x16_t)vshlq_n_s64(*(int64x2_t *)(v11 + 1), 0x3FuLL), (int8x16_t)vshrq_n_u64(*(uint64x2_t *)v11, 1uLL));
          v12[-1] = vorrq_s8((int8x16_t)vshlq_n_s64(*(int64x2_t *)(v11 - 1), 0x3FuLL), (int8x16_t)vshrq_n_u64(*((uint64x2_t *)v11 - 1), 1uLL));
          *v12 = v14;
          v11 += 4;
          v12 += 2;
          v13 -= 4;
        }
        while (v13);
        if (v8 == v10)
          goto LABEL_17;
      }
      else
      {
        v10 = 0;
      }
      v15 = &d[v10];
      v16 = ~v10 + (int)top;
      v17 = (uint64_t)&v7[v10 + 1];
      do
      {
        *v15++ = *(__int128 *)(v17 - 8) >> 1;
        v17 += 8;
        --v16;
      }
      while (v16);
    }
LABEL_17:
    d[v8] = v7[v8] >> 1;
  }
  r->neg = a->neg;
  v18 = &d[top - 1];
  v19 = top;
  while (1)
  {
    v20 = __OFSUB__(v19--, 1);
    if (v19 < 0 != v20)
      break;
    if (*v18--)
    {
      r->top = v19 + 1;
      return 1;
    }
  }
  r->top = top & ((int)top >> 31);
  if ((top & 0x80000000) == 0)
    r->neg = 0;
  return 1;
}

unint64_t BN_count_low_zero_bits(unint64_t result)
{
  uint64_t v1;
  unint64_t **v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unint64_t v23;

  v1 = *(unsigned int *)(result + 8);
  if ((int)v1 < 1)
    return 0;
  v2 = (unint64_t **)result;
  v3 = 0;
  LODWORD(result) = 0;
  v4 = 0;
  v5 = *v2;
  v6 = v1 << 6;
  do
  {
    v7 = *v5++;
    v8 = (uint64_t)(((v7 << 32) - 1) & ~(v7 << 32)) >> 63;
    v9 = v8 & 0x20;
    v10 = v8 & HIDWORD(v7) | v7 & ~v8;
    v11 = (uint64_t)(((v10 << 48) - 1) & ~(v10 << 48)) >> 63;
    v12 = v11 & 0x10;
    v13 = v11 & (v10 >> 16) | v10 & ~v11;
    v14 = (uint64_t)((v7 - 1) & ~v7) >> 63;
    v15 = (uint64_t)(((v13 << 56) - 1) & ~(v13 << 56)) >> 63;
    v16 = v15 & (v13 >> 8) | v13 & ~v15;
    v17 = v12 | v9 | v15 & 8;
    v18 = (uint64_t)(((v16 << 60) - 1) & ~(v16 << 60)) >> 63;
    v19 = v17 | v18 & 4;
    v20 = v18 & (v16 >> 4) | v16 & ~v18;
    v21 = (((v20 << 62) - 1) & ~(v20 << 62)) >> 63;
    v22 = v21 & 2;
    v23 = (unint64_t)(v21 & (v20 >> 2) | v20 & ~(_DWORD)v21) << 63;
    LODWORD(v21) = v14 | v4;
    v4 |= ~v14;
    result = (v3 | v19 | v22 | (((v23 - 1) & ~v23) >> 63)) & ~(_DWORD)v21 | result;
    v3 += 64;
  }
  while (v6 != v3);
  return result;
}

uint64_t ec_GFp_simple_group_get_curve(uint64_t a1, uint64_t a2, BIGNUM *a3, BIGNUM *a4)
{
  uint64_t result;
  uint64_t v9;
  int len[3];
  unsigned __int8 s[66];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a2 && a1 + 320 != a2)
  {
    result = bn_wexpand(a2, *(int *)(a1 + 328));
    if (!(_DWORD)result)
      return result;
    v9 = *(int *)(a1 + 328);
    if ((_DWORD)v9)
    {
      memcpy(*(void **)a2, *(const void **)(a1 + 320), 8 * v9);
      LODWORD(v9) = *(_DWORD *)(a1 + 328);
    }
    *(_DWORD *)(a2 + 8) = v9;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 336);
  }
  if (!a3
    || (*(_QWORD *)len = 0,
        (*(void (**)(uint64_t, unsigned __int8 *, int *, uint64_t))(*(_QWORD *)a1 + 104))(a1, s, len, a1 + 360), (result = (uint64_t)BN_bin2bn(s, len[0], a3)) != 0))
  {
    if (!a4)
      return 1;
    *(_QWORD *)len = 0;
    (*(void (**)(uint64_t, unsigned __int8 *, int *, uint64_t))(*(_QWORD *)a1 + 104))(a1, s, len, a1 + 432);
    result = (uint64_t)BN_bin2bn(s, len[0], a4);
    if (result)
      return 1;
  }
  return result;
}

BOOL ec_GFp_simple_is_on_curve(uint64_t a1, int8x16_t *a2)
{
  void (*v4)(uint64_t, unint64_t *, int8x16_t *);
  void (*v5)(uint64_t, unint64_t *, unint64_t *, unint64_t *);
  const unint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  const unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t *v22;
  int8x16_t *v23;
  unint64_t v24;
  int8x16_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t *v29;
  uint64_t v30;
  const unint64_t *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t *v40;
  int8x16_t *v41;
  unint64_t v42;
  int8x16_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t *v46;
  unint64_t *v47;
  uint64_t v48;
  const unint64_t *v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  int8x16_t v55;
  int8x16_t v56;
  int8x16_t *v57;
  int8x16_t *v58;
  unint64_t v59;
  int8x16_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t *v63;
  unint64_t *v64;
  uint64_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x16_t *v68;
  int8x16_t *v69;
  unint64_t v70;
  int8x16_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t *v74;
  unint64_t *v75;
  uint64_t v76;
  const unint64_t *v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  int8x16_t v84;
  int8x16_t v85;
  int8x16_t *v86;
  int8x16_t *v87;
  unint64_t v88;
  int8x16_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t *v92;
  unint64_t *v93;
  uint64_t v94;
  const unint64_t *v95;
  uint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  int8x16_t v101;
  int8x16_t v102;
  int8x16_t *v103;
  int8x16_t *v104;
  unint64_t v105;
  int8x16_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t *v109;
  unint64_t *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  int8x8_t v114;
  int8x16_t *v116;
  int8x16_t v117;
  uint64_t v118;
  int8x16_t v119;
  int8x16_t v120;
  uint64_t v121;
  unint64_t *v122;
  uint64_t v123;
  uint64_t v124;
  int8x8_t v125;
  int8x16_t *v126;
  int8x16_t v127;
  uint64_t v128;
  int8x16_t v129;
  int8x16_t v130;
  uint64_t v131;
  uint64_t *v132;
  uint64_t v133;
  _OWORD v135[4];
  uint64_t v136;
  unint64_t bp[2];
  __int128 v138;
  __int128 v139;
  __int128 v140;
  uint64_t v141;
  unint64_t rp[2];
  _OWORD v143[3];
  uint64_t v144;
  unint64_t ap[2];
  _OWORD v146[3];
  uint64_t v147;
  unint64_t v148[2];
  __int128 v149;
  __int128 v150;
  __int128 v151;
  uint64_t v152;

  v5 = *(void (**)(uint64_t, unint64_t *, unint64_t *, unint64_t *))(*(_QWORD *)a1 + 88);
  v4 = *(void (**)(uint64_t, unint64_t *, int8x16_t *))(*(_QWORD *)a1 + 96);
  v147 = 0;
  *(_OWORD *)ap = 0u;
  memset(v146, 0, sizeof(v146));
  v4(a1, ap, a2);
  v144 = 0;
  *(_OWORD *)rp = 0u;
  memset(v143, 0, sizeof(v143));
  v141 = 0;
  v139 = 0u;
  v140 = 0u;
  *(_OWORD *)bp = 0u;
  v138 = 0u;
  v136 = 0;
  memset(v135, 0, sizeof(v135));
  v4(a1, rp, a2 + 9);
  v4(a1, bp, (int8x16_t *)rp);
  v5(a1, (unint64_t *)v135, bp, rp);
  if (!*(_DWORD *)(a1 + 528))
  {
    v5(a1, rp, bp, (unint64_t *)(a1 + 360));
    v152 = 0;
    v150 = 0u;
    v151 = 0u;
    *(_OWORD *)v148 = 0u;
    v149 = 0u;
    v13 = *(const unint64_t **)(a1 + 320);
    v14 = *(int *)(a1 + 328);
    v15 = bn_add_words(ap, ap, rp, *(_DWORD *)(a1 + 328));
    v16 = bn_sub_words(v148, ap, v13, v14);
    if (!(_DWORD)v14)
      goto LABEL_34;
    v17 = v15 - v16;
    v18 = ~(v15 - v16);
    if (v14 >= 4)
    {
      v66 = (int8x16_t)vdupq_n_s64(v17);
      v67 = (int8x16_t)vdupq_n_s64(v18);
      v19 = v14 & 0xFFFFFFFFFFFFFFFCLL;
      v68 = (int8x16_t *)v146;
      v69 = (int8x16_t *)&v149;
      v70 = v14 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v71 = vorrq_s8(vandq_s8(*v69, v67), vandq_s8(*v68, v66));
        v68[-1] = vorrq_s8(vandq_s8(v69[-1], v67), vandq_s8(v68[-1], v66));
        *v68 = v71;
        v68 += 2;
        v69 += 2;
        v70 -= 4;
      }
      while (v70);
      if (v19 == v14)
        goto LABEL_34;
    }
    else
    {
      v19 = 0;
    }
    v72 = v14 - v19;
    v73 = v19;
    v74 = &v148[v19];
    v75 = &ap[v73];
    do
    {
      v76 = *v74++;
      *v75 = v76 & v18 | *v75 & v17;
      ++v75;
      --v72;
    }
    while (v72);
    goto LABEL_34;
  }
  v152 = 0;
  v150 = 0u;
  v151 = 0u;
  *(_OWORD *)v148 = 0u;
  v149 = 0u;
  v6 = *(const unint64_t **)(a1 + 320);
  v7 = *(int *)(a1 + 328);
  v8 = bn_add_words(rp, bp, bp, *(_DWORD *)(a1 + 328));
  v9 = bn_sub_words(v148, rp, v6, v7);
  if ((_DWORD)v7)
  {
    v10 = v8 - v9;
    v11 = ~(v8 - v9);
    if (v7 < 4)
    {
      v12 = 0;
LABEL_11:
      v26 = v7 - v12;
      v27 = v12;
      v28 = &v148[v12];
      v29 = &rp[v27];
      do
      {
        v30 = *v28++;
        *v29 = v30 & v11 | *v29 & v10;
        ++v29;
        --v26;
      }
      while (v26);
      goto LABEL_13;
    }
    v20 = (int8x16_t)vdupq_n_s64(v10);
    v21 = (int8x16_t)vdupq_n_s64(v11);
    v12 = v7 & 0xFFFFFFFFFFFFFFFCLL;
    v22 = (int8x16_t *)v143;
    v23 = (int8x16_t *)&v149;
    v24 = v7 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v25 = vorrq_s8(vandq_s8(*v23, v21), vandq_s8(*v22, v20));
      v22[-1] = vorrq_s8(vandq_s8(v23[-1], v21), vandq_s8(v22[-1], v20));
      *v22 = v25;
      v22 += 2;
      v23 += 2;
      v24 -= 4;
    }
    while (v24);
    if (v12 != v7)
      goto LABEL_11;
  }
LABEL_13:
  v152 = 0;
  v150 = 0u;
  v151 = 0u;
  *(_OWORD *)v148 = 0u;
  v149 = 0u;
  v31 = *(const unint64_t **)(a1 + 320);
  v32 = *(int *)(a1 + 328);
  v33 = bn_add_words(rp, rp, bp, *(_DWORD *)(a1 + 328));
  v34 = bn_sub_words(v148, rp, v31, v32);
  if (!(_DWORD)v32)
    goto LABEL_21;
  v35 = v33 - v34;
  v36 = ~(v33 - v34);
  if (v32 < 4)
  {
    v37 = 0;
LABEL_19:
    v44 = v32 - v37;
    v45 = v37;
    v46 = &v148[v37];
    v47 = &rp[v45];
    do
    {
      v48 = *v46++;
      *v47 = v48 & v36 | *v47 & v35;
      ++v47;
      --v44;
    }
    while (v44);
    goto LABEL_21;
  }
  v38 = (int8x16_t)vdupq_n_s64(v35);
  v39 = (int8x16_t)vdupq_n_s64(v36);
  v37 = v32 & 0xFFFFFFFFFFFFFFFCLL;
  v40 = (int8x16_t *)v143;
  v41 = (int8x16_t *)&v149;
  v42 = v32 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v43 = vorrq_s8(vandq_s8(*v41, v39), vandq_s8(*v40, v38));
    v40[-1] = vorrq_s8(vandq_s8(v41[-1], v39), vandq_s8(v40[-1], v38));
    *v40 = v43;
    v40 += 2;
    v41 += 2;
    v42 -= 4;
  }
  while (v42);
  if (v37 != v32)
    goto LABEL_19;
LABEL_21:
  v152 = 0;
  v150 = 0u;
  v151 = 0u;
  *(_OWORD *)v148 = 0u;
  v149 = 0u;
  v49 = *(const unint64_t **)(a1 + 320);
  v50 = *(int *)(a1 + 328);
  v51 = bn_sub_words(ap, ap, rp, *(_DWORD *)(a1 + 328));
  bn_add_words(v148, ap, v49, v50);
  if ((_DWORD)v50)
  {
    v52 = 0;
    v53 = -(uint64_t)v51;
    v54 = v51 - 1;
    if (v50 < 4)
      goto LABEL_26;
    v55 = (int8x16_t)vdupq_n_s64(v53);
    v56 = (int8x16_t)vdupq_n_s64(v54);
    v52 = v50 & 0xFFFFFFFFFFFFFFFCLL;
    v57 = (int8x16_t *)&v149;
    v58 = (int8x16_t *)v146;
    v59 = v50 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v60 = vorrq_s8(vandq_s8(*v58, v56), vandq_s8(*v57, v55));
      v58[-1] = vorrq_s8(vandq_s8(v58[-1], v56), vandq_s8(v57[-1], v55));
      *v58 = v60;
      v57 += 2;
      v58 += 2;
      v59 -= 4;
    }
    while (v59);
    if (v52 != v50)
    {
LABEL_26:
      v61 = v50 - v52;
      v62 = v52;
      v63 = &ap[v52];
      v64 = &v148[v62];
      do
      {
        v65 = *v64++;
        *v63 = *v63 & v54 | v65 & v53;
        ++v63;
        --v61;
      }
      while (v61);
    }
  }
LABEL_34:
  v5(a1, ap, ap, (unint64_t *)a2);
  v5(a1, rp, (unint64_t *)(a1 + 432), (unint64_t *)v135);
  v152 = 0;
  v150 = 0u;
  v151 = 0u;
  *(_OWORD *)v148 = 0u;
  v149 = 0u;
  v77 = *(const unint64_t **)(a1 + 320);
  v78 = *(int *)(a1 + 328);
  v79 = bn_add_words(ap, ap, rp, *(_DWORD *)(a1 + 328));
  v80 = bn_sub_words(v148, ap, v77, v78);
  if (!(_DWORD)v78)
    goto LABEL_42;
  v81 = v79 - v80;
  v82 = ~(v79 - v80);
  if (v78 < 4)
  {
    v83 = 0;
LABEL_40:
    v90 = v78 - v83;
    v91 = v83;
    v92 = &v148[v83];
    v93 = &ap[v91];
    do
    {
      v94 = *v92++;
      *v93 = v94 & v82 | *v93 & v81;
      ++v93;
      --v90;
    }
    while (v90);
    goto LABEL_42;
  }
  v84 = (int8x16_t)vdupq_n_s64(v81);
  v85 = (int8x16_t)vdupq_n_s64(v82);
  v83 = v78 & 0xFFFFFFFFFFFFFFFCLL;
  v86 = (int8x16_t *)v146;
  v87 = (int8x16_t *)&v149;
  v88 = v78 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v89 = vorrq_s8(vandq_s8(*v87, v85), vandq_s8(*v86, v84));
    v86[-1] = vorrq_s8(vandq_s8(v87[-1], v85), vandq_s8(v86[-1], v84));
    *v86 = v89;
    v86 += 2;
    v87 += 2;
    v88 -= 4;
  }
  while (v88);
  if (v83 != v78)
    goto LABEL_40;
LABEL_42:
  v4(a1, rp, (int8x16_t *)((char *)a2 + 72));
  v152 = 0;
  v150 = 0u;
  v151 = 0u;
  *(_OWORD *)v148 = 0u;
  v149 = 0u;
  v95 = *(const unint64_t **)(a1 + 320);
  v96 = *(int *)(a1 + 328);
  v97 = bn_sub_words(rp, rp, ap, *(_DWORD *)(a1 + 328));
  bn_add_words(v148, rp, v95, v96);
  if ((_DWORD)v96)
  {
    v98 = 0;
    v99 = -(uint64_t)v97;
    v100 = v97 - 1;
    if (v96 < 4)
      goto LABEL_47;
    v101 = (int8x16_t)vdupq_n_s64(v99);
    v102 = (int8x16_t)vdupq_n_s64(v100);
    v98 = v96 & 0xFFFFFFFFFFFFFFFCLL;
    v103 = (int8x16_t *)&v149;
    v104 = (int8x16_t *)v143;
    v105 = v96 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v106 = vorrq_s8(vandq_s8(*v104, v102), vandq_s8(*v103, v101));
      v104[-1] = vorrq_s8(vandq_s8(v104[-1], v102), vandq_s8(v103[-1], v101));
      *v104 = v106;
      v103 += 2;
      v104 += 2;
      v105 -= 4;
    }
    while (v105);
    if (v98 != v96)
    {
LABEL_47:
      v107 = v96 - v98;
      v108 = v98;
      v109 = &rp[v98];
      v110 = &v148[v108];
      do
      {
        v111 = *v110++;
        *v109 = *v109 & v100 | v111 & v99;
        ++v109;
        --v107;
      }
      while (v107);
    }
  }
  v112 = *(unsigned int *)(a1 + 328);
  if ((int)v112 < 1)
    return 1;
  if (v112 < 4)
  {
    v113 = 0;
    v114 = 0;
LABEL_56:
    v121 = v112 - v113;
    v122 = &rp[v113];
    do
    {
      v123 = *v122++;
      *(_QWORD *)&v114 |= v123;
      --v121;
    }
    while (v121);
    goto LABEL_58;
  }
  v113 = v112 & 0x7FFFFFFC;
  v116 = (int8x16_t *)v143;
  v117 = 0uLL;
  v118 = v112 & 0xFFFFFFFC;
  v119 = 0uLL;
  do
  {
    v117 = vorrq_s8(v116[-1], v117);
    v119 = vorrq_s8(*v116, v119);
    v116 += 2;
    v118 -= 4;
  }
  while (v118);
  v120 = vorrq_s8(v119, v117);
  v114 = vorr_s8(*(int8x8_t *)v120.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v120, v120, 8uLL));
  if (v113 != v112)
    goto LABEL_56;
LABEL_58:
  if (v112 < 4)
  {
    v124 = 0;
    v125 = 0;
LABEL_63:
    v131 = v112 - v124;
    v132 = &a2[9].i64[v124];
    do
    {
      v133 = *v132++;
      *(_QWORD *)&v125 |= v133;
      --v131;
    }
    while (v131);
    goto LABEL_65;
  }
  v124 = v112 & 0x7FFFFFFC;
  v126 = a2 + 10;
  v127 = 0uLL;
  v128 = v112 & 0xFFFFFFFC;
  v129 = 0uLL;
  do
  {
    v127 = vorrq_s8(v126[-1], v127);
    v129 = vorrq_s8(*v126, v129);
    v126 += 2;
    v128 -= 4;
  }
  while (v128);
  v130 = vorrq_s8(v129, v127);
  v125 = vorr_s8(*(int8x8_t *)v130.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v130, v130, 8uLL));
  if (v124 != v112)
    goto LABEL_63;
LABEL_65:
  if (v125)
    return *(_QWORD *)&v114 == 0;
  else
    return 1;
}

uint64_t ec_GFp_simple_points_equal(uint64_t a1, int8x16_t *a2, uint64_t a3)
{
  void (*v6)(uint64_t, _OWORD *, uint64_t);
  void (*v7)(uint64_t, unint64_t *, int8x16_t *, int8x16_t *);
  int8x16_t *v8;
  const unint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t *v17;
  int8x16_t *v18;
  unint64_t v19;
  int8x16_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int8x8_t v28;
  char v29;
  int8x16_t *v30;
  int8x16_t v31;
  uint64_t v32;
  int8x16_t v33;
  int8x16_t v34;
  uint64_t v35;
  unint64_t *v36;
  uint64_t v37;
  const unint64_t *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t *v46;
  int8x16_t *v47;
  unint64_t v48;
  int8x16_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int8x8_t v57;
  int8x16_t *v59;
  int8x16_t v60;
  uint64_t v61;
  int8x16_t v62;
  int8x16_t v63;
  uint64_t v64;
  unint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  int8x8_t v68;
  int8x16_t *v69;
  int8x16_t v70;
  uint64_t v71;
  int8x16_t v72;
  int8x16_t v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  char v86;
  char v87;
  char v88;
  char v89;
  _OWORD v90[4];
  uint64_t v91;
  _OWORD v92[4];
  uint64_t v93;
  unint64_t bp[2];
  __int128 v95;
  __int128 v96;
  __int128 v97;
  uint64_t v98;
  unint64_t ap[2];
  _OWORD v100[3];
  uint64_t v101;
  unint64_t rp[2];
  __int128 v103;
  __int128 v104;
  __int128 v105;
  uint64_t v106;

  v7 = *(void (**)(uint64_t, unint64_t *, int8x16_t *, int8x16_t *))(*(_QWORD *)a1 + 88);
  v6 = *(void (**)(uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 96);
  v101 = 0;
  *(_OWORD *)ap = 0u;
  memset(v100, 0, sizeof(v100));
  v98 = 0;
  v96 = 0u;
  v97 = 0u;
  *(_OWORD *)bp = 0u;
  v95 = 0u;
  v93 = 0;
  memset(v92, 0, sizeof(v92));
  v91 = 0;
  v8 = (int8x16_t *)(a3 + 144);
  memset(v90, 0, sizeof(v90));
  v6(a1, v90, a3 + 144);
  v7(a1, ap, a2, (int8x16_t *)v90);
  v6(a1, v92, (uint64_t)a2[9].i64);
  v7(a1, bp, (int8x16_t *)a3, (int8x16_t *)v92);
  v106 = 0;
  v104 = 0u;
  v105 = 0u;
  *(_OWORD *)rp = 0u;
  v103 = 0u;
  v9 = *(const unint64_t **)(a1 + 320);
  v10 = *(int *)(a1 + 328);
  v11 = bn_sub_words(ap, ap, bp, *(_DWORD *)(a1 + 328));
  bn_add_words(rp, ap, v9, v10);
  if ((_DWORD)v10)
  {
    v12 = 0;
    v13 = -(uint64_t)v11;
    v14 = v11 - 1;
    if (v10 < 4)
      goto LABEL_6;
    v15 = (int8x16_t)vdupq_n_s64(v13);
    v16 = (int8x16_t)vdupq_n_s64(v14);
    v12 = v10 & 0xFFFFFFFFFFFFFFFCLL;
    v17 = (int8x16_t *)&v103;
    v18 = (int8x16_t *)v100;
    v19 = v10 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v20 = vorrq_s8(vandq_s8(*v18, v16), vandq_s8(*v17, v15));
      v18[-1] = vorrq_s8(vandq_s8(v18[-1], v16), vandq_s8(v17[-1], v15));
      *v18 = v20;
      v17 += 2;
      v18 += 2;
      v19 -= 4;
    }
    while (v19);
    if (v12 != v10)
    {
LABEL_6:
      v21 = v10 - v12;
      v22 = v12;
      v23 = &ap[v12];
      v24 = &rp[v22];
      do
      {
        v25 = *v24++;
        *v23 = *v23 & v14 | v25 & v13;
        ++v23;
        --v21;
      }
      while (v21);
    }
  }
  v26 = *(unsigned int *)(a1 + 328);
  if ((int)v26 >= 1)
  {
    if (v26 >= 4)
    {
      v27 = v26 & 0x7FFFFFFC;
      v30 = (int8x16_t *)v100;
      v31 = 0uLL;
      v32 = v26 & 0xFFFFFFFC;
      v33 = 0uLL;
      do
      {
        v31 = vorrq_s8(v30[-1], v31);
        v33 = vorrq_s8(*v30, v33);
        v30 += 2;
        v32 -= 4;
      }
      while (v32);
      v34 = vorrq_s8(v33, v31);
      v28 = vorr_s8(*(int8x8_t *)v34.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
      if (v27 == v26)
        goto LABEL_17;
    }
    else
    {
      v27 = 0;
      v28 = 0;
    }
    v35 = v26 - v27;
    v36 = &ap[v27];
    do
    {
      v37 = *v36++;
      *(_QWORD *)&v28 |= v37;
      --v35;
    }
    while (v35);
LABEL_17:
    v29 = ~(*(_QWORD *)&v28 != 0);
    goto LABEL_18;
  }
  v29 = -1;
LABEL_18:
  v7(a1, (unint64_t *)v90, (int8x16_t *)v90, v8);
  v7(a1, ap, (int8x16_t *)((char *)a2 + 72), (int8x16_t *)v90);
  v7(a1, (unint64_t *)v92, (int8x16_t *)v92, a2 + 9);
  v7(a1, bp, (int8x16_t *)(a3 + 72), (int8x16_t *)v92);
  v106 = 0;
  v104 = 0u;
  v105 = 0u;
  *(_OWORD *)rp = 0u;
  v103 = 0u;
  v38 = *(const unint64_t **)(a1 + 320);
  v39 = *(int *)(a1 + 328);
  v40 = bn_sub_words(ap, ap, bp, *(_DWORD *)(a1 + 328));
  bn_add_words(rp, ap, v38, v39);
  if ((_DWORD)v39)
  {
    v41 = 0;
    v42 = -(uint64_t)v40;
    v43 = v40 - 1;
    if (v39 < 4)
      goto LABEL_23;
    v44 = (int8x16_t)vdupq_n_s64(v42);
    v45 = (int8x16_t)vdupq_n_s64(v43);
    v41 = v39 & 0xFFFFFFFFFFFFFFFCLL;
    v46 = (int8x16_t *)&v103;
    v47 = (int8x16_t *)v100;
    v48 = v39 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v49 = vorrq_s8(vandq_s8(*v47, v45), vandq_s8(*v46, v44));
      v47[-1] = vorrq_s8(vandq_s8(v47[-1], v45), vandq_s8(v46[-1], v44));
      *v47 = v49;
      v46 += 2;
      v47 += 2;
      v48 -= 4;
    }
    while (v48);
    if (v41 != v39)
    {
LABEL_23:
      v50 = v39 - v41;
      v51 = v41;
      v52 = &ap[v41];
      v53 = &rp[v51];
      do
      {
        v54 = *v53++;
        *v52 = *v52 & v43 | v54 & v42;
        ++v52;
        --v50;
      }
      while (v50);
    }
  }
  v55 = *(unsigned int *)(a1 + 328);
  if ((int)v55 < 1)
    return 1;
  if (v55 < 4)
  {
    v56 = 0;
    v57 = 0;
LABEL_32:
    v64 = v55 - v56;
    v65 = &ap[v56];
    do
    {
      v66 = *v65++;
      *(_QWORD *)&v57 |= v66;
      --v64;
    }
    while (v64);
    goto LABEL_34;
  }
  v56 = v55 & 0x7FFFFFFC;
  v59 = (int8x16_t *)v100;
  v60 = 0uLL;
  v61 = v55 & 0xFFFFFFFC;
  v62 = 0uLL;
  do
  {
    v60 = vorrq_s8(v59[-1], v60);
    v62 = vorrq_s8(*v59, v62);
    v59 += 2;
    v61 -= 4;
  }
  while (v61);
  v63 = vorrq_s8(v62, v60);
  v57 = vorr_s8(*(int8x8_t *)v63.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v63, v63, 8uLL));
  if (v56 != v55)
    goto LABEL_32;
LABEL_34:
  if (v55 < 4)
  {
    v67 = 0;
    v68 = 0;
LABEL_39:
    v74 = v55 - v67;
    v75 = &a2[9].i64[v67];
    do
    {
      v76 = *v75++;
      *(_QWORD *)&v68 |= v76;
      --v74;
    }
    while (v74);
    goto LABEL_41;
  }
  v67 = v55 & 0x7FFFFFFC;
  v69 = a2 + 10;
  v70 = 0uLL;
  v71 = v55 & 0xFFFFFFFC;
  v72 = 0uLL;
  do
  {
    v70 = vorrq_s8(v69[-1], v70);
    v72 = vorrq_s8(*v69, v72);
    v69 += 2;
    v71 -= 4;
  }
  while (v71);
  v73 = vorrq_s8(v72, v70);
  v68 = vorr_s8(*(int8x8_t *)v73.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v73, v73, 8uLL));
  if (v67 != v55)
    goto LABEL_39;
LABEL_41:
  if (v55 < 2)
  {
    v77 = 0;
    v78 = 0;
LABEL_46:
    v83 = v55 - v77;
    v84 = (uint64_t *)(a3 + 8 * v77 + 144);
    do
    {
      v85 = *v84++;
      v78 |= v85;
      --v83;
    }
    while (v83);
    goto LABEL_48;
  }
  v79 = 0;
  v80 = 0;
  v77 = v55 & 0xFFFFFFFE;
  v81 = (_QWORD *)(a3 + 152);
  v82 = v77;
  do
  {
    v79 |= *(v81 - 1);
    v80 |= *v81;
    v81 += 2;
    v82 -= 2;
  }
  while (v82);
  v78 = v80 | v79;
  if (v77 != v55)
    goto LABEL_46;
LABEL_48:
  v86 = *(_QWORD *)&v68 != 0;
  if (v57)
    v87 = 0;
  else
    v87 = v29;
  v88 = v87 & v86;
  if (v78)
    v89 = v88;
  else
    v89 = ~v86;
  return v89 & 1;
}

uint64_t ec_GFp_simple_cmp_x_coordinate(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v3;
  uint64_t v6;
  int8x8_t v7;
  uint64_t result;
  int8x16_t *v9;
  int8x16_t v10;
  uint64_t v11;
  int8x16_t v12;
  int8x16_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD v18[4];
  uint64_t v19;

  v3 = *(unsigned int *)(a1 + 328);
  if ((int)v3 < 1)
    return 0;
  if (v3 < 4)
  {
    v6 = 0;
    v7 = 0;
LABEL_9:
    v14 = v3 - v6;
    v15 = (uint64_t *)(a2 + 8 * v6 + 144);
    do
    {
      v16 = *v15++;
      *(_QWORD *)&v7 |= v16;
      --v14;
    }
    while (v14);
    goto LABEL_11;
  }
  v6 = v3 & 0x7FFFFFFC;
  v9 = (int8x16_t *)(a2 + 160);
  v10 = 0uLL;
  v11 = v3 & 0xFFFFFFFC;
  v12 = 0uLL;
  do
  {
    v10 = vorrq_s8(v9[-1], v10);
    v12 = vorrq_s8(*v9, v12);
    v9 += 2;
    v11 -= 4;
  }
  while (v11);
  v13 = vorrq_s8(v12, v10);
  v7 = vorr_s8(*(int8x8_t *)v13.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  if (v6 != v3)
    goto LABEL_9;
LABEL_11:
  if (!*(_QWORD *)&v7)
    return 0;
  v19 = 0;
  memset(v18, 0, sizeof(v18));
  result = ec_get_x_coordinate_as_scalar(a1, (unint64_t *)v18, a2);
  if ((_DWORD)result)
  {
    v17 = *(int *)(a1 + 264);
    return !(_DWORD)v17 || memcmp(v18, a3, 8 * v17) == 0;
  }
  return result;
}

void ec_GFp_simple_felem_to_bytes(uint64_t a1, char *a2, unint64_t *a3, int8x16_t *a4)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  _BOOL4 v18;
  _BOOL4 v19;
  _BOOL4 v20;
  _BOOL4 v21;
  _BOOL4 v22;
  _BOOL4 v23;
  int v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  __int8 *v29;
  char v30;
  int8x16_t *v31;
  int8x16_t *v32;
  uint64_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t v36;
  uint64_t v37;
  int8x8_t *v38;
  int8x8_t *v39;
  uint64_t v40;
  int8x8_t v41;

  v5 = *(unsigned int *)(a1 + 328);
  v6 = (int)v5;
  v7 = v5 & ((int)v5 >> 31);
  v8 = 8 * v5 - 8;
  v9 = *(_DWORD *)(a1 + 328);
  while (1)
  {
    v10 = __OFSUB__(v9--, 1);
    if (v9 < 0 != v10)
      break;
    v11 = *(_QWORD *)(a1 + 320);
    v12 = *(_QWORD *)(v11 + v8);
    v8 -= 8;
    if (v12)
    {
      v7 = v9 + 1;
      goto LABEL_8;
    }
  }
  if ((v5 & 0x80000000) == 0)
  {
    v13 = 0;
    v14 = 8 * (int)v5;
    v15 = 0;
    goto LABEL_34;
  }
  v11 = *(_QWORD *)(a1 + 320);
LABEL_8:
  v16 = v7 - 1;
  v17 = *(_QWORD *)(v11 + 8 * v16);
  v18 = v17 != 0;
  v19 = HIDWORD(v17) != 0;
  if (HIDWORD(v17))
    v17 >>= 32;
  v20 = v17 >> 16 != 0;
  if (v17 >> 16)
    v17 >>= 16;
  v21 = v17 > 0xFF;
  if (v17 > 0xFF)
    v17 >>= 8;
  v22 = v17 > 0xF;
  if (v17 > 0xF)
    v17 >>= 4;
  v23 = v17 > 3;
  if (v17 > 3)
    v17 >>= 2;
  v24 = v18 | (v16 << 6) | (32 * v19) | (16 * v20) | (8 * v21) | (4 * v22) | (2 * v23);
  if (v17 > 1)
    ++v24;
  v13 = (v24 + 7) >> 3;
  v14 = 8 * v6;
  if (8 * v6 >= v13)
    v15 = v13;
  else
    v15 = 8 * v6;
  if (!v15)
    goto LABEL_34;
  if (v15 < 8 || (&a2[v13 - v15] < &a4->i8[v15] ? (v25 = &a2[v13] > (char *)a4) : (v25 = 0), v25))
  {
    v26 = 0;
    goto LABEL_32;
  }
  if (v15 >= 0x20)
  {
    v26 = v15 & 0xFFFFFFE0;
    v31 = a4 + 1;
    v32 = (int8x16_t *)&a2[v13 - 16];
    v33 = v26;
    do
    {
      v34 = vrev64q_s8(v31[-1]);
      v35 = vextq_s8(v34, v34, 8uLL);
      v36 = vrev64q_s8(*v31);
      v32[-1] = vextq_s8(v36, v36, 8uLL);
      *v32 = v35;
      v31 += 2;
      v32 -= 2;
      v33 -= 32;
    }
    while (v33);
    if (v15 == v26)
      goto LABEL_34;
    if ((v15 & 0x18) != 0)
      goto LABEL_41;
LABEL_32:
    v27 = v15 - v26;
    v28 = &a2[v13 + ~v26];
    v29 = &a4->i8[v26];
    do
    {
      v30 = *v29++;
      *v28-- = v30;
      --v27;
    }
    while (v27);
    goto LABEL_34;
  }
  v26 = 0;
LABEL_41:
  v37 = v26;
  v26 = v15 & 0xFFFFFFF8;
  v38 = (int8x8_t *)&a4->i8[v37];
  v39 = (int8x8_t *)&a2[v13 - v37 - 8];
  v40 = v37 - v26;
  do
  {
    v41 = *v38++;
    *v39-- = vrev64_s8(v41);
    v40 += 8;
  }
  while (v40);
  if (v15 != v26)
    goto LABEL_32;
LABEL_34:
  if (v14 < v13)
    bzero(a2, v13 - v15);
  *a3 = v13;
}

uint64_t ec_GFp_simple_felem_from_bytes(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, unint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unint64_t v16;
  _BOOL4 v17;
  _BOOL4 v18;
  _BOOL4 v19;
  _BOOL4 v20;
  _BOOL4 v21;
  _BOOL4 v22;
  int v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v32;
  uint64_t v33;
  int64x2_t v34;
  int64x2_t v35;
  int8x16_t *v36;
  int8x16_t *v37;
  int64x2_t v38;
  uint64_t v39;
  int8x16_t v40;

  v6 = *(unsigned int *)(a1 + 328);
  v7 = (int)v6;
  v8 = v6 & ((int)v6 >> 31);
  v9 = 8 * v6 - 8;
  v10 = *(_DWORD *)(a1 + 328);
  while (1)
  {
    v11 = __OFSUB__(v10--, 1);
    if (v10 < 0 != v11)
      break;
    v12 = *(_QWORD *)(a1 + 320);
    v13 = *(_QWORD *)(v12 + v9);
    v9 -= 8;
    if (v13)
    {
      v8 = v10 + 1;
      goto LABEL_9;
    }
  }
  if ((v6 & 0x80000000) != 0)
  {
    v12 = *(_QWORD *)(a1 + 320);
LABEL_9:
    v15 = v8 - 1;
    v16 = *(_QWORD *)(v12 + 8 * v15);
    v17 = v16 != 0;
    v18 = HIDWORD(v16) != 0;
    if (HIDWORD(v16))
      v16 >>= 32;
    v19 = v16 >> 16 != 0;
    if (v16 >> 16)
      v16 >>= 16;
    v20 = v16 > 0xFF;
    if (v16 > 0xFF)
      v16 >>= 8;
    v21 = v16 > 0xF;
    if (v16 > 0xF)
      v16 >>= 4;
    v22 = v16 > 3;
    if (v16 > 3)
      v16 >>= 2;
    v23 = v17 | (v15 << 6) | (32 * v18) | (16 * v19) | (8 * v20) | (4 * v21) | (2 * v22);
    if (v16 > 1)
      ++v23;
    if ((v23 + 7) >> 3 != a4)
      goto LABEL_7;
  }
  else if (a4)
  {
LABEL_7:
    v14 = 324;
LABEL_40:
    ERR_put_error(15, 0, 128, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/ec/simple.c", v14);
    return 0;
  }
  if (a4 > 8 * v7)
    abort();
  v24 = a4 - 8;
  if (a4 < 8)
  {
    v27 = v7;
    v26 = a2;
    v25 = a4;
    goto LABEL_32;
  }
  if (v24 < 0x48
    || &a3[a4] > (unsigned __int8 *)a2 && &a3[a4 & 7] < (unsigned __int8 *)a2 + (a4 & 0xFFFFFFFFFFFFFFF8))
  {
    v25 = a4;
    v26 = a2;
    v27 = v7;
LABEL_28:
    v28 = v25;
    do
    {
      v25 = v28 - 8;
      *v26++ = bswap64(*(_QWORD *)&a3[v28 - 8]);
      --v27;
      v28 = v25;
    }
    while (v25 > 7);
    goto LABEL_32;
  }
  v32 = (v24 >> 3) + 1;
  v33 = v32 & 0x3FFFFFFFFFFFFFFCLL;
  v25 = a4 - v33 * 8;
  v26 = &a2[v33];
  v34 = (int64x2_t)v7;
  v35 = 0uLL;
  v36 = (int8x16_t *)&a3[a4 - 16];
  v37 = (int8x16_t *)(a2 + 2);
  v38.i64[0] = -1;
  v38.i64[1] = -1;
  v39 = v32 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v40 = vrev64q_s8(vextq_s8(v36[-1], v36[-1], 8uLL));
    v37[-1] = vrev64q_s8(vextq_s8(*v36, *v36, 8uLL));
    *v37 = v40;
    v34 = vaddq_s64(v34, v38);
    v35 = vaddq_s64(v35, v38);
    v36 -= 2;
    v37 += 2;
    v39 -= 4;
  }
  while (v39);
  v27 = vaddvq_s64(vaddq_s64(v35, v34));
  if (v32 != (v32 & 0x3FFFFFFFFFFFFFFCLL))
    goto LABEL_28;
LABEL_32:
  if (v25)
  {
    v29 = 0;
    do
    {
      v30 = *a3++;
      v29 = v30 | (unint64_t)(v29 << 8);
      --v25;
    }
    while (v25);
    *v26++ = v29;
    --v27;
  }
  if (8 * v27)
  {
    bzero(v26, 8 * v27);
    v7 = *(int *)(a1 + 328);
  }
  if ((bn_cmp_words_consttime(a2, v7, *(uint64_t **)(a1 + 320), v7) & 0x80000000) == 0)
  {
    v14 = 331;
    goto LABEL_40;
  }
  return 1;
}

double ec_GFp_mont_mul(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  unint64_t v20;
  unint64_t *v21;
  double result;
  unint64_t *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  unint64_t v32;
  _BOOL4 v33;
  _BOOL4 v34;
  _BOOL4 v35;
  _BOOL4 v36;
  _BOOL4 v37;
  _BOOL4 v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  char v42;
  unsigned int v43;
  unsigned int v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  char v54;
  unint64_t v55;
  uint64_t v56;
  char v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  __int128 *v64;
  _OWORD *v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int8x16_t v69;
  int8x16_t v70;
  unint64_t v71;
  int8x16_t *v72;
  int8x16_t *v73;
  int8x16_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t *v77;
  uint64_t *v78;
  uint64_t v79;
  unint64_t i;
  uint64_t v81;
  int8x16_t v82;
  int8x16_t v83;
  unint64_t v84;
  char *v85;
  int8x16_t v86;
  unint64_t v87;
  uint64_t v88;
  int8x16_t v89;
  int8x16_t v90;
  unint64_t v91;
  int8x16_t *v92;
  int8x16_t v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  char v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  _OWORD v106[5];
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  uint64_t v111;
  __int128 v112;
  _OWORD v113[12];
  uint64_t v114;
  _OWORD v115[4];
  uint64_t v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  uint64_t v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  uint64_t v126;
  uint64_t v127;

  v2 = MEMORY[0x24BDAC7A8](a1, a2);
  v4 = v3;
  v6 = v5;
  v7 = v2;
  v127 = *MEMORY[0x24BDAC8D0];
  memset(v113, 0, sizeof(v113));
  v112 = 0u;
  v9 = *(_QWORD *)(v8 + 64);
  v10 = *(_OWORD *)(v8 + 32);
  v115[3] = *(_OWORD *)(v8 + 48);
  v11 = *(_OWORD *)(v8 + 16);
  v115[0] = *(_OWORD *)v8;
  v114 = 0;
  v116 = v9;
  v115[2] = v10;
  v115[1] = v11;
  v12 = *(_OWORD *)(v8 + 72);
  v13 = *(_QWORD *)(v8 + 136);
  v14 = *(_OWORD *)(v8 + 120);
  v119 = *(_OWORD *)(v8 + 104);
  v120 = v14;
  v15 = *(_OWORD *)(v8 + 88);
  v117 = v12;
  v118 = v15;
  v16 = *(_QWORD *)(v8 + 208);
  v17 = *(_OWORD *)(v8 + 144);
  v18 = *(_OWORD *)(v8 + 160);
  v19 = *(_OWORD *)(v8 + 192);
  v124 = *(_OWORD *)(v8 + 176);
  v125 = v19;
  v121 = v13;
  v126 = v16;
  v20 = 2;
  v21 = (unint64_t *)v115;
  v122 = v17;
  v123 = v18;
  do
  {
    while (1)
    {
      v23 = v21 + 27;
      if ((v20 & 1) != 0)
        break;
      ec_GFp_mont_dbl(v7, v23, (unint64_t *)&v113[-1] + 27 * (v20++ >> 1));
      v21 += 27;
      if (v20 == 32)
        goto LABEL_5;
    }
    ec_GFp_mont_add(v7, v23, (unint64_t *)v115, v21);
    ++v20;
    v21 += 27;
  }
  while (v20 != 32);
LABEL_5:
  v24 = *(unsigned int *)(v7 + 264);
  v25 = v24 & ((int)v24 >> 31);
  v26 = 8 * v24 - 8;
  v27 = *(_DWORD *)(v7 + 264);
  v100 = v4;
  while (1)
  {
    v28 = __OFSUB__(v27--, 1);
    if (v27 < 0 != v28)
      break;
    v29 = *(_QWORD *)(v7 + 256);
    v30 = *(_QWORD *)(v29 + v26);
    v26 -= 8;
    if (v30)
    {
      v25 = v27 + 1;
      goto LABEL_11;
    }
  }
  if ((v24 & 0x80000000) == 0)
    goto LABEL_75;
  v29 = *(_QWORD *)(v7 + 256);
LABEL_11:
  v31 = v25 - 1;
  v32 = *(_QWORD *)(v29 + 8 * v31);
  v33 = v32 != 0;
  v34 = HIDWORD(v32) != 0;
  if (HIDWORD(v32))
    v32 >>= 32;
  v35 = v32 >> 16 != 0;
  if (v32 >> 16)
    v32 >>= 16;
  v36 = v32 > 0xFF;
  if (v32 > 0xFF)
    v32 >>= 8;
  v37 = v32 > 0xF;
  if (v32 > 0xF)
    v32 >>= 4;
  v38 = v32 > 3;
  if (v32 > 3)
    v32 >>= 2;
  v39 = v33 | (v31 << 6) | (32 * v34) | (16 * v35) | (8 * v36) | (4 * v37) | (2 * v38);
  v40 = v32 <= 1 ? v39 : v39 + 1;
  if (!v40)
    goto LABEL_75;
  v41 = v40 - 1;
  v42 = 0;
  v43 = v40;
  while (1)
  {
    v101 = v42;
    if ((v42 & 1) != 0)
      break;
    v44 = v41;
    if (-858993459 * v41 >= 0x33333334)
    {
      do
      {
        if (--v41 >= v40)
          goto LABEL_74;
      }
      while (5 * (v41 / 5) != v41);
LABEL_34:
      v43 = v41 + 1;
      v44 = v41;
    }
LABEL_35:
    v45 = *(int *)(v7 + 264);
    if ((unint64_t)(v43 + 3) >> 6 >= v45)
    {
      v47 = 0;
      v46 = v100;
      v48 = v43 + 2;
      v49 = v48 >> 6;
      if (v48 >> 6 >= v45)
      {
LABEL_37:
        v50 = 0;
        v51 = v43 + 1;
        v52 = v51 >> 6;
        if (v51 >> 6 >= v45)
          goto LABEL_38;
        goto LABEL_43;
      }
    }
    else
    {
      v46 = v100;
      v47 = (*(_QWORD *)(v100 + 8 * ((unint64_t)(v43 + 3) >> 6)) >> (v43 + 3)) & 1;
      v48 = v43 + 2;
      v49 = v48 >> 6;
      if (v48 >> 6 >= v45)
        goto LABEL_37;
    }
    v50 = (*(_QWORD *)(v46 + 8 * v49) >> v48) & 1;
    v51 = v43 + 1;
    v52 = v51 >> 6;
    if (v51 >> 6 >= v45)
    {
LABEL_38:
      v53 = 0;
      v54 = v43;
      v55 = (unint64_t)v43 >> 6;
      if (v55 >= v45)
        goto LABEL_39;
      goto LABEL_44;
    }
LABEL_43:
    v53 = (*(_QWORD *)(v46 + 8 * v52) >> v51) & 1;
    v54 = v43;
    v55 = (unint64_t)v43 >> 6;
    if (v55 >= v45)
    {
LABEL_39:
      v56 = 0;
      v57 = v44;
      v58 = (unint64_t)v44 >> 6;
      if (v58 >= v45)
        goto LABEL_40;
      goto LABEL_45;
    }
LABEL_44:
    v56 = (*(_QWORD *)(v46 + 8 * v55) >> v54) & 1;
    v57 = v44;
    v58 = (unint64_t)v44 >> 6;
    if (v58 >= v45)
    {
LABEL_40:
      v59 = 0;
      goto LABEL_46;
    }
LABEL_45:
    v59 = (*(_QWORD *)(v46 + 8 * v58) >> v57) & 1;
LABEL_46:
    v111 = 0;
    v109 = 0u;
    v110 = 0u;
    v107 = 0u;
    v108 = 0u;
    v105 = 0u;
    memset(v106, 0, sizeof(v106));
    v103 = 0u;
    v104 = 0u;
    v102 = 0u;
    v60 = *(int *)(v7 + 328);
    if ((_DWORD)v60)
    {
      v61 = 0;
      v62 = v59 | (2 * v56) | (16 * v47) | (8 * v50) | (4 * v53);
      v63 = v60 & 0xFFFFFFFFFFFFFFFCLL;
      v64 = &v112;
      v65 = v113;
      while (1)
      {
        v66 = ((v61 ^ v62) - 1) >> 63;
        v67 = ~v66;
        if (v60 < 4)
          break;
        v69 = (int8x16_t)vdupq_n_s64(v66);
        v70 = (int8x16_t)vdupq_n_s64(v67);
        v71 = v60 & 0xFFFFFFFFFFFFFFFCLL;
        v72 = (int8x16_t *)&v103;
        v73 = (int8x16_t *)v65;
        do
        {
          v74 = vorrq_s8(vandq_s8(*v72, v70), vandq_s8(*v73, v69));
          v72[-1] = vorrq_s8(vandq_s8(v72[-1], v70), vandq_s8(v73[-1], v69));
          *v72 = v74;
          v73 += 2;
          v72 += 2;
          v71 -= 4;
        }
        while (v71);
        v68 = v60 & 0xFFFFFFFFFFFFFFFCLL;
        if (v63 != v60)
          goto LABEL_54;
LABEL_56:
        if (v60 < 4)
        {
          for (i = 0; i != v60; ++i)
LABEL_61:
            *((_QWORD *)v106 + i + 1) = *((_QWORD *)v106 + i + 1) & v67 | *((_QWORD *)v64 + i + 9) & v66;
          goto LABEL_62;
        }
        v81 = 0;
        v82 = (int8x16_t)vdupq_n_s64(v66);
        v83 = (int8x16_t)vdupq_n_s64(v67);
        v84 = v60 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v85 = (char *)&v102 + v81 * 16;
          v86 = vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v106[v81 + 1] + 8), v83), vandq_s8(*(int8x16_t *)((char *)&v64[v81 + 5] + 8), v82));
          *(int8x16_t *)(v85 + 72) = vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v106[v81] + 8), v83), vandq_s8(*(int8x16_t *)((char *)&v64[v81 + 4] + 8), v82));
          *(int8x16_t *)(v85 + 88) = v86;
          v81 += 2;
          v84 -= 4;
        }
        while (v84);
        i = v60 & 0xFFFFFFFFFFFFFFFCLL;
        if (v63 != v60)
          goto LABEL_61;
LABEL_62:
        if (v60 >= 4)
        {
          v88 = 0;
          v89 = (int8x16_t)vdupq_n_s64(v66);
          v90 = (int8x16_t)vdupq_n_s64(v67);
          v91 = v60 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            v92 = (int8x16_t *)((char *)&v102 + v88 * 16);
            v93 = vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v108 + v88 * 16), v90), vandq_s8((int8x16_t)v64[v88 + 10], v89));
            v92[9] = vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v107 + v88 * 16), v90), vandq_s8((int8x16_t)v64[v88 + 9], v89));
            v92[10] = v93;
            v88 += 2;
            v91 -= 4;
          }
          while (v91);
          v87 = v60 & 0xFFFFFFFFFFFFFFFCLL;
          if (v63 == v60)
            goto LABEL_48;
        }
        else
        {
          v87 = 0;
        }
        do
        {
          *((_QWORD *)&v107 + v87) = *((_QWORD *)&v107 + v87) & v67 | *((_QWORD *)v64 + v87 + 18) & v66;
          ++v87;
        }
        while (v60 != v87);
LABEL_48:
        ++v61;
        v65 = (_OWORD *)((char *)v65 + 216);
        v64 = (__int128 *)((char *)v64 + 216);
        if (v61 == 32)
          goto LABEL_69;
      }
      v68 = 0;
LABEL_54:
      v75 = v60 - v68;
      v76 = 8 * v68;
      v77 = (unint64_t *)&v102 + v68;
      v78 = (uint64_t *)((char *)v64 + v76);
      do
      {
        v79 = *v78++;
        *v77 = *v77 & v67 | v79 & v66;
        ++v77;
        --v75;
      }
      while (v75);
      goto LABEL_56;
    }
LABEL_69:
    if ((v101 & 1) != 0)
    {
      v43 = v44;
      ec_GFp_mont_add(v7, (unint64_t *)v6, (unint64_t *)v6, (unint64_t *)&v102);
      v41 = v43 - 1;
      v42 = 1;
      if (v43 - 1 >= v40)
        return result;
    }
    else
    {
      v94 = v105;
      *(_OWORD *)(v6 + 32) = v104;
      *(_OWORD *)(v6 + 48) = v94;
      *(_QWORD *)(v6 + 64) = *(_QWORD *)&v106[0];
      v95 = v103;
      *(_OWORD *)v6 = v102;
      *(_OWORD *)(v6 + 16) = v95;
      v96 = *(_OWORD *)((char *)&v106[3] + 8);
      *(_OWORD *)(v6 + 104) = *(_OWORD *)((char *)&v106[2] + 8);
      *(_OWORD *)(v6 + 120) = v96;
      *(_QWORD *)(v6 + 136) = *((_QWORD *)&v106[4] + 1);
      v97 = *(_OWORD *)((char *)&v106[1] + 8);
      *(_OWORD *)(v6 + 72) = *(_OWORD *)((char *)v106 + 8);
      *(_OWORD *)(v6 + 88) = v97;
      *(_QWORD *)(v6 + 208) = v111;
      v98 = v110;
      *(_OWORD *)(v6 + 176) = v109;
      *(_OWORD *)(v6 + 192) = v98;
      result = *(double *)&v107;
      v99 = v108;
      *(_OWORD *)(v6 + 144) = v107;
      *(_OWORD *)(v6 + 160) = v99;
      v41 = v44 - 1;
      v42 = 1;
      v43 = v44;
      if (v44 - 1 >= v40)
        return result;
    }
  }
  ec_GFp_mont_dbl(v7, (unint64_t *)v6, (unint64_t *)v6);
  v44 = v41;
  if (-858993459 * v41 < 0x33333334)
    goto LABEL_35;
  while (--v41 < v40)
  {
    ec_GFp_mont_dbl(v7, (unint64_t *)v6, (unint64_t *)v6);
    if (5 * (v41 / 5) == v41)
      goto LABEL_34;
  }
LABEL_74:
  if ((v101 & 1) == 0)
  {
LABEL_75:
    *(_QWORD *)(v6 + 64) = 0;
    result = 0.0;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)(v6 + 48) = 0u;
    *(_OWORD *)v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 104) = 0u;
    *(_OWORD *)(v6 + 120) = 0u;
    *(_QWORD *)(v6 + 136) = 0;
    *(_OWORD *)(v6 + 144) = 0u;
    *(_OWORD *)(v6 + 160) = 0u;
    *(_OWORD *)(v6 + 176) = 0u;
    *(_OWORD *)(v6 + 192) = 0u;
    *(_QWORD *)(v6 + 208) = 0;
  }
  return result;
}

double ec_GFp_mont_mul_base(uint64_t a1, uint64_t a2)
{
  return ec_GFp_mont_mul(a1, a2);
}

double ec_GFp_mont_mul_batch(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t *v39;
  __int128 v40;
  uint64_t v41;
  __int128 v42;
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  int v53;
  BOOL v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  int v58;
  unint64_t v59;
  _BOOL4 v60;
  _BOOL4 v61;
  _BOOL4 v62;
  _BOOL4 v63;
  _BOOL4 v64;
  _BOOL4 v65;
  int v66;
  char v67;
  _OWORD *v68;
  _OWORD *v69;
  unsigned int v70;
  double result;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  _OWORD v85[5];
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  uint64_t v90;
  _OWORD v91[13];
  uint64_t v92;
  _OWORD v93[4];
  uint64_t v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  uint64_t v104;
  _QWORD v105[27];
  _OWORD v106[4];
  uint64_t v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  uint64_t v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  uint64_t v117;
  _OWORD v118[13];
  uint64_t v119;
  _OWORD v120[4];
  uint64_t v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  uint64_t v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  uint64_t v131;
  uint64_t v132;

  v2 = MEMORY[0x24BDAC7A8](a1, a2);
  v78 = v4;
  v79 = v3;
  v6 = v5;
  v80 = v7;
  v9 = v8;
  v11 = v10;
  v12 = v2;
  v132 = *MEMORY[0x24BDAC8D0];
  memset(v91, 0, sizeof(v91));
  v14 = *(_QWORD *)(v13 + 64);
  v15 = *(_OWORD *)(v13 + 32);
  v93[3] = *(_OWORD *)(v13 + 48);
  v16 = *(_OWORD *)(v13 + 16);
  v93[0] = *(_OWORD *)v13;
  v92 = 0;
  v94 = v14;
  v93[2] = v15;
  v93[1] = v16;
  v17 = *(_OWORD *)(v13 + 72);
  v18 = *(_QWORD *)(v13 + 136);
  v19 = *(_OWORD *)(v13 + 120);
  v97 = *(_OWORD *)(v13 + 104);
  v98 = v19;
  v20 = *(_OWORD *)(v13 + 88);
  v95 = v17;
  v96 = v20;
  v21 = *(_QWORD *)(v13 + 208);
  v22 = *(_OWORD *)(v13 + 144);
  v23 = *(_OWORD *)(v13 + 160);
  v24 = *(_OWORD *)(v13 + 192);
  v102 = *(_OWORD *)(v13 + 176);
  v103 = v24;
  v99 = v18;
  v104 = v21;
  v25 = 2;
  v26 = (unint64_t *)v93;
  v100 = v22;
  v101 = v23;
  do
  {
    while (1)
    {
      v27 = v26 + 27;
      if ((v25 & 1) != 0)
        break;
      ec_GFp_mont_dbl(v12, v27, (unint64_t *)v91 + 27 * (v25++ >> 1));
      v26 += 27;
      if (v25 == 17)
        goto LABEL_5;
    }
    ec_GFp_mont_add(v12, v27, (unint64_t *)v93, v26);
    ++v25;
    v26 += 27;
  }
  while (v25 != 17);
LABEL_5:
  memset(v105, 0, sizeof(v105));
  v28 = *(_OWORD *)(v9 + 16);
  v106[0] = *(_OWORD *)v9;
  v29 = *(_OWORD *)(v9 + 32);
  v30 = *(_OWORD *)(v9 + 48);
  v107 = *(_QWORD *)(v9 + 64);
  v106[3] = v30;
  v106[2] = v29;
  v106[1] = v28;
  v31 = *(_OWORD *)(v9 + 72);
  v32 = *(_OWORD *)(v9 + 120);
  v110 = *(_OWORD *)(v9 + 104);
  v111 = v32;
  v33 = *(_OWORD *)(v9 + 88);
  v108 = v31;
  v109 = v33;
  v112 = *(_QWORD *)(v9 + 136);
  v34 = *(_OWORD *)(v9 + 160);
  v113 = *(_OWORD *)(v9 + 144);
  v35 = *(_OWORD *)(v9 + 176);
  v36 = *(_OWORD *)(v9 + 192);
  v117 = *(_QWORD *)(v9 + 208);
  v116 = v36;
  v115 = v35;
  v37 = 2;
  v38 = (unint64_t *)v106;
  v114 = v34;
  do
  {
    while (1)
    {
      v39 = v38 + 27;
      if ((v37 & 1) != 0)
        break;
      ec_GFp_mont_dbl(v12, v39, &v105[27 * (v37++ >> 1)]);
      v38 += 27;
      if (v37 == 17)
        goto LABEL_9;
    }
    ec_GFp_mont_add(v12, v39, (unint64_t *)v106, v38);
    ++v37;
    v38 += 27;
  }
  while (v37 != 17);
LABEL_9:
  if (v6)
  {
    v119 = 0;
    memset(v118, 0, sizeof(v118));
    v40 = *(_OWORD *)(v6 + 16);
    v120[0] = *(_OWORD *)v6;
    v41 = *(_QWORD *)(v6 + 64);
    v42 = *(_OWORD *)(v6 + 48);
    v120[2] = *(_OWORD *)(v6 + 32);
    v120[1] = v40;
    v120[3] = v42;
    v121 = v41;
    v122 = *(_OWORD *)(v6 + 72);
    v126 = *(_QWORD *)(v6 + 136);
    v125 = *(_OWORD *)(v6 + 120);
    v124 = *(_OWORD *)(v6 + 104);
    v123 = *(_OWORD *)(v6 + 88);
    v43 = *(_QWORD *)(v6 + 208);
    v44 = *(_OWORD *)(v6 + 144);
    v45 = *(_OWORD *)(v6 + 160);
    v46 = *(_OWORD *)(v6 + 192);
    v129 = *(_OWORD *)(v6 + 176);
    v130 = v46;
    v131 = v43;
    v47 = (unint64_t *)v120;
    v48 = 2;
    v127 = v44;
    v128 = v45;
    do
    {
      while (1)
      {
        v49 = v47 + 27;
        if ((v48 & 1) != 0)
          break;
        ec_GFp_mont_dbl(v12, v49, (unint64_t *)v118 + 27 * (v48++ >> 1));
        v47 += 27;
        if (v48 == 17)
          goto LABEL_14;
      }
      ec_GFp_mont_add(v12, v49, (unint64_t *)v120, v47);
      ++v48;
      v47 += 27;
    }
    while (v48 != 17);
  }
LABEL_14:
  v50 = *(unsigned int *)(v12 + 264);
  v51 = v50 & ((int)v50 >> 31);
  v52 = 8 * v50 - 8;
  v53 = *(_DWORD *)(v12 + 264);
  while (1)
  {
    v54 = __OFSUB__(v53--, 1);
    if (v53 < 0 != v54)
      break;
    v55 = *(_QWORD *)(v12 + 256);
    v56 = *(_QWORD *)(v55 + v52);
    v52 -= 8;
    if (v56)
    {
      v51 = v53 + 1;
      goto LABEL_21;
    }
  }
  if ((v50 & 0x80000000) == 0)
  {
    v57 = 0;
    goto LABEL_34;
  }
  v55 = *(_QWORD *)(v12 + 256);
LABEL_21:
  v58 = v51 - 1;
  v59 = *(_QWORD *)(v55 + 8 * v58);
  v60 = v59 != 0;
  v61 = HIDWORD(v59) != 0;
  if (HIDWORD(v59))
    v59 >>= 32;
  v62 = v59 >> 16 != 0;
  if (v59 >> 16)
    v59 >>= 16;
  v63 = v59 > 0xFF;
  if (v59 > 0xFF)
    v59 >>= 8;
  v64 = v59 > 0xF;
  if (v59 > 0xF)
    v59 >>= 4;
  v65 = v59 > 3;
  if (v59 > 3)
    v59 >>= 2;
  v66 = v60 | (v58 << 6) | (32 * v61) | (16 * v62) | (8 * v63) | (4 * v64) | (2 * v65);
  if (v59 <= 1)
    v57 = v66;
  else
    v57 = v66 + 1;
LABEL_34:
  v67 = 0;
  v68 = (_OWORD *)(v11 + 72);
  v69 = (_OWORD *)(v11 + 144);
  v70 = v57;
  do
  {
    if ((v67 & 1) != 0)
    {
      while (1)
      {
        ec_GFp_mont_dbl(v12, (unint64_t *)v11, (unint64_t *)v11);
        if (5 * (v70 / 5) == v70)
          break;
        if (--v70 > v57)
          return result;
      }
    }
    else
    {
      while (5 * (v70 / 5) != v70)
      {
        if (--v70 > v57)
        {
          *(_QWORD *)(v11 + 64) = 0;
          result = 0.0;
          *(_OWORD *)(v11 + 32) = 0u;
          *(_OWORD *)(v11 + 48) = 0u;
          *(_OWORD *)v11 = 0u;
          *(_OWORD *)(v11 + 16) = 0u;
          *v68 = 0u;
          *(_OWORD *)(v11 + 88) = 0u;
          *(_OWORD *)(v11 + 104) = 0u;
          *(_OWORD *)(v11 + 120) = 0u;
          *(_QWORD *)(v11 + 136) = 0;
          *v69 = 0u;
          *(_OWORD *)(v11 + 160) = 0u;
          *(_OWORD *)(v11 + 176) = 0u;
          *(_OWORD *)(v11 + 192) = 0u;
          *(_QWORD *)(v11 + 208) = 0;
          return result;
        }
      }
    }
    v90 = 0;
    v88 = 0u;
    v89 = 0u;
    v86 = 0u;
    v87 = 0u;
    v84 = 0u;
    memset(v85, 0, sizeof(v85));
    v82 = 0u;
    v83 = 0u;
    v81 = 0u;
    ec_GFp_mont_batch_get_window(v12, (unint64_t)&v81, (unint64_t)v91, v79, v70);
    if ((v67 & 1) != 0)
    {
      ec_GFp_mont_add(v12, (unint64_t *)v11, (unint64_t *)v11, (unint64_t *)&v81);
    }
    else
    {
      v72 = v84;
      *(_OWORD *)(v11 + 32) = v83;
      *(_OWORD *)(v11 + 48) = v72;
      *(_QWORD *)(v11 + 64) = *(_QWORD *)&v85[0];
      v73 = v82;
      *(_OWORD *)v11 = v81;
      *(_OWORD *)(v11 + 16) = v73;
      v74 = *(_OWORD *)((char *)&v85[3] + 8);
      *(_OWORD *)(v11 + 104) = *(_OWORD *)((char *)&v85[2] + 8);
      *(_OWORD *)(v11 + 120) = v74;
      *(_QWORD *)(v11 + 136) = *((_QWORD *)&v85[4] + 1);
      v75 = *(_OWORD *)((char *)&v85[1] + 8);
      *v68 = *(_OWORD *)((char *)v85 + 8);
      *(_OWORD *)(v11 + 88) = v75;
      *(_QWORD *)(v11 + 208) = v90;
      v76 = v89;
      *(_OWORD *)(v11 + 176) = v88;
      *(_OWORD *)(v11 + 192) = v76;
      v77 = v87;
      *v69 = v86;
      *(_OWORD *)(v11 + 160) = v77;
    }
    ec_GFp_mont_batch_get_window(v12, (unint64_t)&v81, (unint64_t)v105, v80, v70);
    ec_GFp_mont_add(v12, (unint64_t *)v11, (unint64_t *)v11, (unint64_t *)&v81);
    if (v6)
    {
      ec_GFp_mont_batch_get_window(v12, (unint64_t)&v81, (unint64_t)v118, v78, v70);
      ec_GFp_mont_add(v12, (unint64_t *)v11, (unint64_t *)v11, (unint64_t *)&v81);
    }
    --v70;
    v67 = 1;
  }
  while (v70 <= v57);
  return result;
}

unint64_t ec_GFp_mont_batch_get_window(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unsigned int a5)
{
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  int v20;
  char v21;
  unint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  uint64_t *v37;
  uint64_t v38;
  const unint64_t *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t *v44;
  uint64_t *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t *v52;
  uint64_t *v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t *v60;
  uint64_t *v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t *v66;
  uint64_t *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t *v72;
  uint64_t *v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t *v80;
  uint64_t *v81;
  uint64_t v82;
  int8x16_t *v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t *v87;
  uint64_t *v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t *v93;
  uint64_t *v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t *v101;
  uint64_t *v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t *v107;
  uint64_t *v108;
  uint64_t v109;
  int8x16_t *v110;
  unint64_t v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t *v114;
  uint64_t *v115;
  uint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t *v122;
  uint64_t *v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t *v128;
  uint64_t *v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  uint64_t v133;
  unint64_t *v134;
  uint64_t *v135;
  uint64_t v136;
  unint64_t v137;
  unint64_t v138;
  int8x16_t *v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  unint64_t *v143;
  uint64_t *v144;
  uint64_t v145;
  unint64_t v146;
  uint64_t v147;
  uint64_t v148;
  unint64_t *v149;
  uint64_t *v150;
  uint64_t v151;
  unint64_t v152;
  uint64_t v153;
  uint64_t v154;
  unint64_t *v155;
  uint64_t *v156;
  uint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t v160;
  uint64_t v161;
  uint64_t v162;
  unint64_t *v163;
  uint64_t *v164;
  uint64_t v165;
  int8x16_t *v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  unint64_t *v170;
  uint64_t *v171;
  uint64_t v172;
  unint64_t v173;
  uint64_t v174;
  uint64_t v175;
  unint64_t *v176;
  uint64_t *v177;
  uint64_t v178;
  unint64_t v179;
  unint64_t v180;
  unint64_t v181;
  uint64_t v182;
  uint64_t v183;
  unint64_t *v184;
  uint64_t *v185;
  uint64_t v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  unint64_t *v190;
  uint64_t *v191;
  uint64_t v192;
  int8x16_t *v193;
  unint64_t v194;
  uint64_t v195;
  uint64_t v196;
  unint64_t *v197;
  uint64_t *v198;
  uint64_t v199;
  unint64_t v200;
  unint64_t v201;
  unint64_t v202;
  uint64_t v203;
  uint64_t v204;
  unint64_t *v205;
  uint64_t *v206;
  uint64_t v207;
  unint64_t v208;
  uint64_t v209;
  uint64_t v210;
  unint64_t *v211;
  uint64_t *v212;
  uint64_t v213;
  unint64_t v214;
  uint64_t v215;
  uint64_t v216;
  unint64_t *v217;
  uint64_t *v218;
  uint64_t v219;
  unint64_t v220;
  unint64_t v221;
  int8x16_t *v222;
  unint64_t v223;
  uint64_t v224;
  uint64_t v225;
  unint64_t *v226;
  uint64_t *v227;
  uint64_t v228;
  unint64_t v229;
  uint64_t v230;
  uint64_t v231;
  unint64_t *v232;
  uint64_t *v233;
  uint64_t v234;
  unint64_t v235;
  uint64_t v236;
  uint64_t v237;
  unint64_t *v238;
  uint64_t *v239;
  uint64_t v240;
  unint64_t v241;
  unint64_t v242;
  unint64_t v243;
  uint64_t v244;
  uint64_t v245;
  unint64_t *v246;
  uint64_t *v247;
  uint64_t v248;
  int8x16_t *v249;
  unint64_t v250;
  uint64_t v251;
  uint64_t v252;
  unint64_t *v253;
  uint64_t *v254;
  uint64_t v255;
  unint64_t v256;
  uint64_t v257;
  uint64_t v258;
  unint64_t *v259;
  uint64_t *v260;
  uint64_t v261;
  unint64_t v262;
  unint64_t v263;
  unint64_t v264;
  uint64_t v265;
  uint64_t v266;
  unint64_t *v267;
  uint64_t *v268;
  uint64_t v269;
  unint64_t v270;
  uint64_t v271;
  uint64_t v272;
  unint64_t *v273;
  uint64_t *v274;
  uint64_t v275;
  int8x16_t *v276;
  unint64_t v277;
  uint64_t v278;
  uint64_t v279;
  unint64_t *v280;
  uint64_t *v281;
  uint64_t v282;
  unint64_t v283;
  unint64_t v284;
  unint64_t v285;
  uint64_t v286;
  uint64_t v287;
  unint64_t *v288;
  uint64_t *v289;
  uint64_t v290;
  unint64_t v291;
  uint64_t v292;
  uint64_t v293;
  unint64_t *v294;
  uint64_t *v295;
  uint64_t v296;
  unint64_t v297;
  uint64_t v298;
  uint64_t v299;
  unint64_t *v300;
  uint64_t *v301;
  uint64_t v302;
  unint64_t v303;
  unint64_t v304;
  int8x16_t *v305;
  unint64_t v306;
  uint64_t v307;
  uint64_t v308;
  unint64_t *v309;
  uint64_t *v310;
  uint64_t v311;
  unint64_t v312;
  uint64_t v313;
  uint64_t v314;
  unint64_t *v315;
  uint64_t *v316;
  uint64_t v317;
  unint64_t v318;
  uint64_t v319;
  uint64_t v320;
  unint64_t *v321;
  uint64_t *v322;
  uint64_t v323;
  unint64_t v324;
  unint64_t v325;
  unint64_t v326;
  uint64_t v327;
  uint64_t v328;
  unint64_t *v329;
  uint64_t *v330;
  uint64_t v331;
  int8x16_t *v332;
  unint64_t v333;
  uint64_t v334;
  uint64_t v335;
  unint64_t *v336;
  uint64_t *v337;
  uint64_t v338;
  unint64_t v339;
  uint64_t v340;
  uint64_t v341;
  unint64_t *v342;
  uint64_t *v343;
  uint64_t v344;
  unint64_t v345;
  unint64_t v346;
  unint64_t v347;
  uint64_t v348;
  uint64_t v349;
  unint64_t *v350;
  uint64_t *v351;
  uint64_t v352;
  unint64_t v353;
  uint64_t v354;
  uint64_t v355;
  unint64_t *v356;
  uint64_t *v357;
  uint64_t v358;
  int8x16_t *v359;
  unint64_t v360;
  uint64_t v361;
  uint64_t v362;
  unint64_t *v363;
  uint64_t *v364;
  uint64_t v365;
  unint64_t v366;
  unint64_t v367;
  unint64_t v368;
  uint64_t v369;
  uint64_t v370;
  unint64_t *v371;
  uint64_t *v372;
  uint64_t v373;
  int8x16_t *v374;
  unint64_t v375;
  uint64_t v376;
  uint64_t v377;
  unint64_t *v378;
  uint64_t *v379;
  uint64_t v380;
  unint64_t v381;
  uint64_t v382;
  uint64_t v383;
  unint64_t *v384;
  uint64_t *v385;
  uint64_t v386;
  int8x16_t v387;
  uint64_t v388;
  int8x8_t v389;
  unint64_t v390;
  int8x16_t *v391;
  uint64_t v392;
  int8x16_t v393;
  int8x16_t v394;
  uint64_t v395;
  uint64_t *v396;
  uint64_t v397;
  unint64_t result;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  int8x16_t v402;
  int8x16_t *v403;
  uint64_t v404;
  int8x16_t v405;
  uint64_t v406;
  _QWORD *v407;
  unint64_t v408;
  unint64_t v409;
  unint64_t v410;
  int8x16_t v411;
  int8x16_t v412;
  int8x16_t *v413;
  int8x16_t *v414;
  unint64_t v415;
  int8x16_t v416;
  uint64_t v417;
  uint64_t v418;
  unint64_t *v419;
  uint64_t *v420;
  uint64_t v421;
  int8x16_t v422;
  int8x16_t v423;
  int8x16_t *v424;
  int8x16_t *v425;
  unint64_t v426;
  int8x16_t v427;
  int8x16_t v428;
  int8x16_t v429;
  int8x16_t *v430;
  int8x16_t *v431;
  unint64_t v432;
  int8x16_t v433;
  int8x16_t v434;
  int8x16_t v435;
  int8x16_t *v436;
  int8x16_t *v437;
  unint64_t v438;
  int8x16_t v439;
  int8x16_t v440;
  int8x16_t v441;
  int8x16_t *v442;
  int8x16_t *v443;
  unint64_t v444;
  int8x16_t v445;
  int8x16_t v446;
  int8x16_t v447;
  int8x16_t *v448;
  int8x16_t *v449;
  unint64_t v450;
  int8x16_t v451;
  int8x16_t v452;
  int8x16_t v453;
  int8x16_t *v454;
  unint64_t v455;
  int8x16_t *v456;
  int8x16_t v457;
  int8x16_t v458;
  int8x16_t v459;
  int8x16_t v460;
  int8x16_t v461;
  int8x16_t *v462;
  int8x16_t *v463;
  unint64_t v464;
  int8x16_t v465;
  int8x16_t v466;
  int8x16_t v467;
  int8x16_t *v468;
  unint64_t v469;
  int8x16_t v470;
  int8x16_t v471;
  int8x16_t v472;
  int8x16_t v473;
  int8x16_t v474;
  int8x16_t *v475;
  int8x16_t *v476;
  unint64_t v477;
  int8x16_t v478;
  int8x16_t v479;
  int8x16_t v480;
  int8x16_t *v481;
  unint64_t v482;
  int8x16_t *v483;
  int8x16_t v484;
  int8x16_t v485;
  int8x16_t v486;
  int8x16_t v487;
  int8x16_t v488;
  int8x16_t *v489;
  int8x16_t *v490;
  unint64_t v491;
  int8x16_t v492;
  int8x16_t v493;
  int8x16_t v494;
  int8x16_t *v495;
  unint64_t v496;
  int8x16_t v497;
  int8x16_t v498;
  int8x16_t v499;
  int8x16_t v500;
  int8x16_t v501;
  int8x16_t *v502;
  int8x16_t *v503;
  unint64_t v504;
  int8x16_t v505;
  int8x16_t v506;
  int8x16_t v507;
  int8x16_t *v508;
  unint64_t v509;
  int8x16_t *v510;
  int8x16_t v511;
  int8x16_t v512;
  int8x16_t v513;
  int8x16_t v514;
  int8x16_t v515;
  int8x16_t *v516;
  int8x16_t *v517;
  unint64_t v518;
  int8x16_t v519;
  int8x16_t v520;
  int8x16_t v521;
  int8x16_t *v522;
  unint64_t v523;
  int8x16_t v524;
  int8x16_t v525;
  int8x16_t v526;
  int8x16_t v527;
  int8x16_t v528;
  int8x16_t *v529;
  int8x16_t *v530;
  unint64_t v531;
  int8x16_t v532;
  int8x16_t v533;
  int8x16_t v534;
  int8x16_t *v535;
  unint64_t v536;
  int8x16_t *v537;
  int8x16_t v538;
  int8x16_t v539;
  int8x16_t v540;
  int8x16_t v541;
  int8x16_t v542;
  int8x16_t *v543;
  int8x16_t *v544;
  unint64_t v545;
  int8x16_t v546;
  int8x16_t v547;
  int8x16_t v548;
  int8x16_t *v549;
  unint64_t v550;
  int8x16_t v551;
  int8x16_t v552;
  int8x16_t v553;
  int8x16_t v554;
  int8x16_t v555;
  int8x16_t *v556;
  int8x16_t *v557;
  unint64_t v558;
  int8x16_t v559;
  int8x16_t v560;
  int8x16_t v561;
  int8x16_t *v562;
  unint64_t v563;
  int8x16_t *v564;
  int8x16_t v565;
  int8x16_t v566;
  int8x16_t v567;
  int8x16_t v568;
  int8x16_t v569;
  int8x16_t *v570;
  int8x16_t *v571;
  unint64_t v572;
  int8x16_t v573;
  int8x16_t v574;
  int8x16_t v575;
  int8x16_t *v576;
  unint64_t v577;
  int8x16_t v578;
  int8x16_t v579;
  int8x16_t v580;
  int8x16_t v581;
  int8x16_t v582;
  int8x16_t *v583;
  int8x16_t *v584;
  unint64_t v585;
  int8x16_t v586;
  int8x16_t v587;
  int8x16_t v588;
  int8x16_t *v589;
  unint64_t v590;
  int8x16_t *v591;
  int8x16_t v592;
  int8x16_t v593;
  int8x16_t v594;
  int8x16_t v595;
  int8x16_t v596;
  int8x16_t *v597;
  int8x16_t *v598;
  unint64_t v599;
  int8x16_t v600;
  int8x16_t v601;
  int8x16_t v602;
  int8x16_t *v603;
  unint64_t v604;
  int8x16_t v605;
  int8x16_t v606;
  int8x16_t v607;
  int8x16_t v608;
  int8x16_t v609;
  int8x16_t *v610;
  int8x16_t *v611;
  unint64_t v612;
  int8x16_t v613;
  int8x16_t v614;
  int8x16_t v615;
  int8x16_t *v616;
  unint64_t v617;
  int8x16_t *v618;
  int8x16_t v619;
  int8x16_t v620;
  int8x16_t v621;
  int8x16_t v622;
  int8x16_t v623;
  int8x16_t *v624;
  int8x16_t *v625;
  unint64_t v626;
  int8x16_t v627;
  int8x16_t v628;
  int8x16_t v629;
  int8x16_t *v630;
  unint64_t v631;
  int8x16_t v632;
  int8x16_t v633;
  int8x16_t v634;
  int8x16_t v635;
  int8x16_t v636;
  int8x16_t *v637;
  int8x16_t *v638;
  unint64_t v639;
  int8x16_t v640;
  int8x16_t v641;
  int8x16_t v642;
  int8x16_t *v643;
  unint64_t v644;
  int8x16_t *v645;
  int8x16_t v646;
  int8x16_t v647;
  int8x16_t v648;
  int8x16_t v649;
  int8x16_t v650;
  int8x16_t *v651;
  int8x16_t *v652;
  unint64_t v653;
  int8x16_t v654;
  int8x16_t v655;
  int8x16_t v656;
  int8x16_t *v657;
  unint64_t v658;
  int8x16_t v659;
  int8x16_t v660;
  int8x16_t v661;
  int8x16_t v662;
  int8x16_t v663;
  int8x16_t *v664;
  int8x16_t *v665;
  unint64_t v666;
  int8x16_t v667;
  int8x16_t v668;
  int8x16_t v669;
  int8x16_t *v670;
  unint64_t v671;
  int8x16_t *v672;
  int8x16_t v673;
  int8x16_t v674;
  int8x16_t v675;
  int8x16_t v676;
  int8x16_t v677;
  int8x16_t *v678;
  int8x16_t *v679;
  unint64_t v680;
  int8x16_t v681;
  int8x16_t v682;
  int8x16_t v683;
  int8x16_t *v684;
  unint64_t v685;
  int8x16_t v686;
  int8x16_t v687;
  int8x16_t v688;
  int8x16_t v689;
  int8x16_t v690;
  int8x16_t *v691;
  int8x16_t *v692;
  unint64_t v693;
  int8x16_t v694;
  int8x16_t v695;
  int8x16_t v696;
  int8x16_t *v697;
  unint64_t v698;
  int8x16_t *v699;
  int8x16_t v700;
  int8x16_t v701;
  int8x16_t v702;
  int8x16_t v703;
  int8x16_t v704;
  int8x16_t *v705;
  int8x16_t *v706;
  unint64_t v707;
  int8x16_t v708;
  int8x16_t v709;
  int8x16_t v710;
  int8x16_t *v711;
  unint64_t v712;
  int8x16_t v713;
  int8x16_t v714;
  int8x16_t v715;
  int8x16_t v716;
  int8x16_t v717;
  int8x16_t *v718;
  int8x16_t *v719;
  unint64_t v720;
  int8x16_t v721;
  int8x16_t v722;
  int8x16_t v723;
  int8x16_t *v724;
  unint64_t v725;
  int8x16_t *v726;
  int8x16_t v727;
  int8x16_t v728;
  int8x16_t v729;
  int8x16_t v730;
  int8x16_t v731;
  int8x16_t *v732;
  int8x16_t *v733;
  unint64_t v734;
  int8x16_t v735;
  int8x16_t v736;
  int8x16_t v737;
  int8x16_t *v738;
  unint64_t v739;
  int8x16_t v740;
  int8x16_t v741;
  int8x16_t v742;
  int8x16_t v743;
  int8x16_t v744;
  int8x16_t *v745;
  int8x16_t *v746;
  unint64_t v747;
  int8x16_t v748;
  int8x16_t v749;
  int8x16_t v750;
  int8x16_t *v751;
  unint64_t v752;
  int8x16_t v753;
  int8x16_t v754;
  int8x16_t v755;
  int8x16_t v756;
  int8x16_t v757;
  int8x16_t *v758;
  int8x16_t *v759;
  unint64_t v760;
  int8x16_t v761;
  __int128 v762;
  __int128 v763;
  __int128 v764;
  __int128 v765;
  uint64_t v766;

  v7 = *(int *)(a1 + 264);
  if ((unint64_t)(a5 + 4) >> 6 >= v7)
  {
    LODWORD(v8) = 0;
    v9 = a5 + 3;
    v10 = v9 >> 6;
    if (v9 >> 6 >= v7)
    {
LABEL_3:
      LODWORD(v11) = 0;
      v12 = 32 * v8;
      v13 = a5 + 2;
      v14 = v13 >> 6;
      if (v13 >> 6 >= v7)
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  else
  {
    v8 = (*(_QWORD *)(a4 + 8 * ((unint64_t)(a5 + 4) >> 6)) >> (a5 + 4)) & 1;
    v9 = a5 + 3;
    v10 = v9 >> 6;
    if (v9 >> 6 >= v7)
      goto LABEL_3;
  }
  v11 = (*(_QWORD *)(a4 + 8 * v10) >> v9) & 1;
  v12 = 32 * v8;
  v13 = a5 + 2;
  v14 = v13 >> 6;
  if (v13 >> 6 >= v7)
  {
LABEL_4:
    LODWORD(v15) = 0;
    v16 = v12 | (16 * v11);
    v17 = a5 + 1;
    v18 = v17 >> 6;
    if (v17 >> 6 >= v7)
      goto LABEL_5;
    goto LABEL_11;
  }
LABEL_10:
  v15 = (*(_QWORD *)(a4 + 8 * v14) >> v13) & 1;
  v16 = v12 | (16 * v11);
  v17 = a5 + 1;
  v18 = v17 >> 6;
  if (v17 >> 6 >= v7)
  {
LABEL_5:
    v19 = v16 | (8 * v15);
    v20 = 0;
    v21 = a5;
    v22 = (unint64_t)a5 >> 6;
    if (v22 >= v7)
      goto LABEL_6;
    goto LABEL_12;
  }
LABEL_11:
  v19 = v16 | (8 * v15);
  v20 = 4 * ((*(_QWORD *)(a4 + 8 * v18) >> v17) & 1);
  v21 = a5;
  v22 = (unint64_t)a5 >> 6;
  if (v22 >= v7)
  {
LABEL_6:
    v23 = v20 | v19;
    if (!a5)
      goto LABEL_17;
    goto LABEL_13;
  }
LABEL_12:
  v23 = v20 | v19 | (2 * ((*(_QWORD *)(a4 + 8 * v22) >> v21) & 1));
  if (!a5)
    goto LABEL_17;
LABEL_13:
  if ((unint64_t)(a5 - 1) >> 6 >= v7)
    LODWORD(v24) = 0;
  else
    v24 = (*(_QWORD *)(a4 + 8 * ((unint64_t)(a5 - 1) >> 6)) >> (a5 - 1)) & 1;
  v23 = v24 | v23 & 0x3E;
LABEL_17:
  *(_QWORD *)(a2 + 208) = 0;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  v25 = v23;
  v26 = (unint64_t)v23 >> 5;
  v27 = -(uint64_t)v26;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  v28 = *(int *)(a1 + 328);
  if (!(_DWORD)v28)
  {
    v390 = 0;
    v766 = 0;
    v764 = 0uLL;
    v765 = 0uLL;
    v39 = (const unint64_t *)(a2 + 72);
    v762 = 0uLL;
    v763 = 0uLL;
    goto LABEL_337;
  }
  v29 = ((((_DWORD)v26 - 1) & v25 | (v25 ^ 0x3F) & v27) & 1)
      + ((((_DWORD)v26 - 1) & v25 | (v25 ^ 0x3F) & (unint64_t)v27) >> 1);
  v30 = *(unsigned int *)(a1 + 328);
  v31 = (uint64_t)(v29 - 1) >> 63;
  v32 = ~v31;
  if (v28 < 4 || a3 + 8 * v28 > a2 && a2 + 8 * v28 > a3)
  {
    v33 = 0;
LABEL_22:
    v34 = v28 - v33;
    v35 = 8 * v33;
    v36 = (unint64_t *)(a2 + 8 * v33);
    v37 = (uint64_t *)(a3 + v35);
    do
    {
      v38 = *v37++;
      *v36 = *v36 & v32 | v38 & v31;
      ++v36;
      --v34;
    }
    while (v34);
    goto LABEL_24;
  }
  v422 = (int8x16_t)vdupq_n_s64(v31);
  v33 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v423 = (int8x16_t)vdupq_n_s64(v32);
  v424 = (int8x16_t *)(a3 + 16);
  v425 = (int8x16_t *)(a2 + 16);
  v426 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v427 = vorrq_s8(vandq_s8(*v425, v423), vandq_s8(*v424, v422));
    v425[-1] = vorrq_s8(vandq_s8(v425[-1], v423), vandq_s8(v424[-1], v422));
    *v425 = v427;
    v424 += 2;
    v425 += 2;
    v426 -= 4;
  }
  while (v426);
  if (v33 != v28)
    goto LABEL_22;
LABEL_24:
  v39 = (const unint64_t *)(a2 + 72);
  if (v28 < 6 || (v40 = 8 * v28 + 72, (unint64_t)v39 < a3 + v40) && a3 + 72 < a2 + v40)
  {
    v41 = 0;
LABEL_28:
    v42 = v28 - v41;
    v43 = 8 * v41 + 72;
    v44 = (unint64_t *)(a2 + v43);
    v45 = (uint64_t *)(a3 + v43);
    do
    {
      v46 = *v45++;
      *v44 = *v44 & v32 | v46 & v31;
      ++v44;
      --v42;
    }
    while (v42);
    goto LABEL_30;
  }
  v428 = (int8x16_t)vdupq_n_s64(v31);
  v41 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v429 = (int8x16_t)vdupq_n_s64(v32);
  v430 = (int8x16_t *)(a3 + 88);
  v431 = (int8x16_t *)(a2 + 88);
  v432 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v433 = vorrq_s8(vandq_s8(*v431, v429), vandq_s8(*v430, v428));
    v431[-1] = vorrq_s8(vandq_s8(v431[-1], v429), vandq_s8(v430[-1], v428));
    *v431 = v433;
    v430 += 2;
    v431 += 2;
    v432 -= 4;
  }
  while (v432);
  if (v41 != v28)
    goto LABEL_28;
LABEL_30:
  v47 = a2 + 144;
  if (v28 < 6 || (v48 = 8 * v28 + 144, v47 < a3 + v48) && a3 + 144 < a2 + v48)
  {
    v49 = 0;
LABEL_34:
    v50 = v28 - v49;
    v51 = 8 * v49 + 144;
    v52 = (unint64_t *)(a2 + v51);
    v53 = (uint64_t *)(a3 + v51);
    do
    {
      v54 = *v53++;
      *v52 = *v52 & v32 | v54 & v31;
      ++v52;
      --v50;
    }
    while (v50);
    goto LABEL_36;
  }
  v434 = (int8x16_t)vdupq_n_s64(v31);
  v49 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v435 = (int8x16_t)vdupq_n_s64(v32);
  v436 = (int8x16_t *)(a3 + 160);
  v437 = (int8x16_t *)(a2 + 160);
  v438 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v439 = vorrq_s8(vandq_s8(*v437, v435), vandq_s8(*v436, v434));
    v437[-1] = vorrq_s8(vandq_s8(v437[-1], v435), vandq_s8(v436[-1], v434));
    *v437 = v439;
    v436 += 2;
    v437 += 2;
    v438 -= 4;
  }
  while (v438);
  if (v49 != v28)
    goto LABEL_34;
LABEL_36:
  v55 = (uint64_t)((v29 ^ 1) - 1) >> 63;
  v56 = ~v55;
  if (v28 < 6 || 8 * v28 + a3 + 216 > a2 && a3 + 216 < a2 + 8 * v28)
  {
    v57 = 0;
LABEL_40:
    v58 = v28 - v57;
    v59 = 8 * v57;
    v60 = (unint64_t *)(a2 + 8 * v57);
    v61 = (uint64_t *)(v59 + a3 + 216);
    do
    {
      v62 = *v61++;
      *v60 = *v60 & v56 | v62 & v55;
      ++v60;
      --v58;
    }
    while (v58);
    goto LABEL_42;
  }
  v440 = (int8x16_t)vdupq_n_s64(v55);
  v57 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v441 = (int8x16_t)vdupq_n_s64(v56);
  v442 = (int8x16_t *)(a3 + 232);
  v443 = (int8x16_t *)(a2 + 16);
  v444 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v445 = vorrq_s8(vandq_s8(*v443, v441), vandq_s8(*v442, v440));
    v443[-1] = vorrq_s8(vandq_s8(v443[-1], v441), vandq_s8(v442[-1], v440));
    *v443 = v445;
    v442 += 2;
    v443 += 2;
    v444 -= 4;
  }
  while (v444);
  if (v57 != v28)
    goto LABEL_40;
LABEL_42:
  if (v28 < 6 || (unint64_t)v39 < 8 * v28 + a3 + 288 && a3 + 288 < 8 * v28 + a2 + 72)
  {
    v63 = 0;
LABEL_46:
    v64 = v28 - v63;
    v65 = 8 * v63;
    v66 = (unint64_t *)(8 * v63 + a2 + 72);
    v67 = (uint64_t *)(v65 + a3 + 288);
    do
    {
      v68 = *v67++;
      *v66 = *v66 & v56 | v68 & v55;
      ++v66;
      --v64;
    }
    while (v64);
    goto LABEL_48;
  }
  v446 = (int8x16_t)vdupq_n_s64(v55);
  v63 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v447 = (int8x16_t)vdupq_n_s64(v56);
  v448 = (int8x16_t *)(a3 + 304);
  v449 = (int8x16_t *)(a2 + 88);
  v450 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v451 = vorrq_s8(vandq_s8(*v449, v447), vandq_s8(*v448, v446));
    v449[-1] = vorrq_s8(vandq_s8(v449[-1], v447), vandq_s8(v448[-1], v446));
    *v449 = v451;
    v448 += 2;
    v449 += 2;
    v450 -= 4;
  }
  while (v450);
  if (v63 != v28)
    goto LABEL_46;
LABEL_48:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 360 && a3 + 360 < 8 * v28 + a2 + 144)
  {
    v69 = 0;
LABEL_52:
    v70 = v28 - v69;
    v71 = 8 * v69;
    v72 = (unint64_t *)(8 * v69 + a2 + 144);
    v73 = (uint64_t *)(v71 + a3 + 360);
    do
    {
      v74 = *v73++;
      *v72 = *v72 & v56 | v74 & v55;
      ++v72;
      --v70;
    }
    while (v70);
    goto LABEL_54;
  }
  v452 = (int8x16_t)vdupq_n_s64(v55);
  v69 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v453 = (int8x16_t)vdupq_n_s64(v56);
  v454 = (int8x16_t *)(a2 + 160);
  v455 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v456 = (int8x16_t *)(a3 + 360);
  do
  {
    v457 = *v456;
    v458 = v456[1];
    v456 += 2;
    v459 = vorrq_s8(vandq_s8(*v454, v453), vandq_s8(v458, v452));
    v454[-1] = vorrq_s8(vandq_s8(v454[-1], v453), vandq_s8(v457, v452));
    *v454 = v459;
    v454 += 2;
    v455 -= 4;
  }
  while (v455);
  if (v69 != v28)
    goto LABEL_52;
LABEL_54:
  v75 = (uint64_t)((v29 ^ 2) - 1) >> 63;
  v76 = ~v75;
  if (v28 < 6 || 8 * v28 + a3 + 432 > a2 && a3 + 432 < a2 + 8 * v28)
  {
    v77 = 0;
LABEL_58:
    v78 = v28 - v77;
    v79 = 8 * v77;
    v80 = (unint64_t *)(a2 + 8 * v77);
    v81 = (uint64_t *)(v79 + a3 + 432);
    do
    {
      v82 = *v81++;
      *v80 = *v80 & v76 | v82 & v75;
      ++v80;
      --v78;
    }
    while (v78);
    goto LABEL_60;
  }
  v460 = (int8x16_t)vdupq_n_s64(v75);
  v77 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v461 = (int8x16_t)vdupq_n_s64(v76);
  v462 = (int8x16_t *)(a3 + 448);
  v463 = (int8x16_t *)(a2 + 16);
  v464 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v465 = vorrq_s8(vandq_s8(*v463, v461), vandq_s8(*v462, v460));
    v463[-1] = vorrq_s8(vandq_s8(v463[-1], v461), vandq_s8(v462[-1], v460));
    *v463 = v465;
    v462 += 2;
    v463 += 2;
    v464 -= 4;
  }
  while (v464);
  if (v77 != v28)
    goto LABEL_58;
LABEL_60:
  if (v28 < 6
    || (v83 = (int8x16_t *)(a3 + 504), (unint64_t)v39 < 8 * v28 + a3 + 504)
    && (unint64_t)v83 < 8 * v28 + a2 + 72)
  {
    v84 = 0;
LABEL_64:
    v85 = v28 - v84;
    v86 = 8 * v84;
    v87 = (unint64_t *)(8 * v84 + a2 + 72);
    v88 = (uint64_t *)(v86 + a3 + 504);
    do
    {
      v89 = *v88++;
      *v87 = *v87 & v76 | v89 & v75;
      ++v87;
      --v85;
    }
    while (v85);
    goto LABEL_66;
  }
  v84 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v466 = (int8x16_t)vdupq_n_s64(v75);
  v467 = (int8x16_t)vdupq_n_s64(v76);
  v468 = (int8x16_t *)(a2 + 88);
  v469 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v470 = *v83;
    v471 = v83[1];
    v83 += 2;
    v472 = vorrq_s8(vandq_s8(*v468, v467), vandq_s8(v471, v466));
    v468[-1] = vorrq_s8(vandq_s8(v468[-1], v467), vandq_s8(v470, v466));
    *v468 = v472;
    v468 += 2;
    v469 -= 4;
  }
  while (v469);
  if (v84 != v28)
    goto LABEL_64;
LABEL_66:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 576 && a3 + 576 < 8 * v28 + a2 + 144)
  {
    v90 = 0;
LABEL_70:
    v91 = v28 - v90;
    v92 = 8 * v90;
    v93 = (unint64_t *)(8 * v90 + a2 + 144);
    v94 = (uint64_t *)(v92 + a3 + 576);
    do
    {
      v95 = *v94++;
      *v93 = *v93 & v76 | v95 & v75;
      ++v93;
      --v91;
    }
    while (v91);
    goto LABEL_72;
  }
  v473 = (int8x16_t)vdupq_n_s64(v75);
  v90 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v474 = (int8x16_t)vdupq_n_s64(v76);
  v475 = (int8x16_t *)(a3 + 592);
  v476 = (int8x16_t *)(a2 + 160);
  v477 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v478 = vorrq_s8(vandq_s8(*v476, v474), vandq_s8(*v475, v473));
    v476[-1] = vorrq_s8(vandq_s8(v476[-1], v474), vandq_s8(v475[-1], v473));
    *v476 = v478;
    v475 += 2;
    v476 += 2;
    v477 -= 4;
  }
  while (v477);
  if (v90 != v28)
    goto LABEL_70;
LABEL_72:
  v96 = (uint64_t)((v29 ^ 3) - 1) >> 63;
  v97 = ~v96;
  if (v28 < 6 || 8 * v28 + a3 + 648 > a2 && a3 + 648 < a2 + 8 * v28)
  {
    v98 = 0;
LABEL_76:
    v99 = v28 - v98;
    v100 = 8 * v98;
    v101 = (unint64_t *)(a2 + 8 * v98);
    v102 = (uint64_t *)(v100 + a3 + 648);
    do
    {
      v103 = *v102++;
      *v101 = *v101 & v97 | v103 & v96;
      ++v101;
      --v99;
    }
    while (v99);
    goto LABEL_78;
  }
  v479 = (int8x16_t)vdupq_n_s64(v96);
  v98 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v480 = (int8x16_t)vdupq_n_s64(v97);
  v481 = (int8x16_t *)(a2 + 16);
  v482 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v483 = (int8x16_t *)(a3 + 648);
  do
  {
    v484 = *v483;
    v485 = v483[1];
    v483 += 2;
    v486 = vorrq_s8(vandq_s8(*v481, v480), vandq_s8(v485, v479));
    v481[-1] = vorrq_s8(vandq_s8(v481[-1], v480), vandq_s8(v484, v479));
    *v481 = v486;
    v481 += 2;
    v482 -= 4;
  }
  while (v482);
  if (v98 != v28)
    goto LABEL_76;
LABEL_78:
  if (v28 < 6 || (unint64_t)v39 < 8 * v28 + a3 + 720 && a3 + 720 < 8 * v28 + a2 + 72)
  {
    v104 = 0;
LABEL_82:
    v105 = v28 - v104;
    v106 = 8 * v104;
    v107 = (unint64_t *)(8 * v104 + a2 + 72);
    v108 = (uint64_t *)(v106 + a3 + 720);
    do
    {
      v109 = *v108++;
      *v107 = *v107 & v97 | v109 & v96;
      ++v107;
      --v105;
    }
    while (v105);
    goto LABEL_84;
  }
  v487 = (int8x16_t)vdupq_n_s64(v96);
  v104 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v488 = (int8x16_t)vdupq_n_s64(v97);
  v489 = (int8x16_t *)(a3 + 736);
  v490 = (int8x16_t *)(a2 + 88);
  v491 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v492 = vorrq_s8(vandq_s8(*v490, v488), vandq_s8(*v489, v487));
    v490[-1] = vorrq_s8(vandq_s8(v490[-1], v488), vandq_s8(v489[-1], v487));
    *v490 = v492;
    v489 += 2;
    v490 += 2;
    v491 -= 4;
  }
  while (v491);
  if (v104 != v28)
    goto LABEL_82;
LABEL_84:
  if (v28 < 6
    || (v110 = (int8x16_t *)(a3 + 792), v47 < 8 * v28 + a3 + 792) && (unint64_t)v110 < 8 * v28 + a2 + 144)
  {
    v111 = 0;
LABEL_88:
    v112 = v28 - v111;
    v113 = 8 * v111;
    v114 = (unint64_t *)(8 * v111 + a2 + 144);
    v115 = (uint64_t *)(v113 + a3 + 792);
    do
    {
      v116 = *v115++;
      *v114 = *v114 & v97 | v116 & v96;
      ++v114;
      --v112;
    }
    while (v112);
    goto LABEL_90;
  }
  v111 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v493 = (int8x16_t)vdupq_n_s64(v96);
  v494 = (int8x16_t)vdupq_n_s64(v97);
  v495 = (int8x16_t *)(a2 + 160);
  v496 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v497 = *v110;
    v498 = v110[1];
    v110 += 2;
    v499 = vorrq_s8(vandq_s8(*v495, v494), vandq_s8(v498, v493));
    v495[-1] = vorrq_s8(vandq_s8(v495[-1], v494), vandq_s8(v497, v493));
    *v495 = v499;
    v495 += 2;
    v496 -= 4;
  }
  while (v496);
  if (v111 != v28)
    goto LABEL_88;
LABEL_90:
  v117 = (uint64_t)((v29 ^ 4) - 1) >> 63;
  v118 = ~v117;
  if (v28 < 6 || 8 * v28 + a3 + 864 > a2 && a3 + 864 < a2 + 8 * v28)
  {
    v119 = 0;
LABEL_94:
    v120 = v28 - v119;
    v121 = 8 * v119;
    v122 = (unint64_t *)(a2 + 8 * v119);
    v123 = (uint64_t *)(v121 + a3 + 864);
    do
    {
      v124 = *v123++;
      *v122 = *v122 & v118 | v124 & v117;
      ++v122;
      --v120;
    }
    while (v120);
    goto LABEL_96;
  }
  v500 = (int8x16_t)vdupq_n_s64(v117);
  v119 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v501 = (int8x16_t)vdupq_n_s64(v118);
  v502 = (int8x16_t *)(a3 + 880);
  v503 = (int8x16_t *)(a2 + 16);
  v504 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v505 = vorrq_s8(vandq_s8(*v503, v501), vandq_s8(*v502, v500));
    v503[-1] = vorrq_s8(vandq_s8(v503[-1], v501), vandq_s8(v502[-1], v500));
    *v503 = v505;
    v502 += 2;
    v503 += 2;
    v504 -= 4;
  }
  while (v504);
  if (v119 != v28)
    goto LABEL_94;
LABEL_96:
  if (v28 < 6 || (unint64_t)v39 < 8 * v28 + a3 + 936 && a3 + 936 < 8 * v28 + a2 + 72)
  {
    v125 = 0;
LABEL_100:
    v126 = v28 - v125;
    v127 = 8 * v125;
    v128 = (unint64_t *)(8 * v125 + a2 + 72);
    v129 = (uint64_t *)(v127 + a3 + 936);
    do
    {
      v130 = *v129++;
      *v128 = *v128 & v118 | v130 & v117;
      ++v128;
      --v126;
    }
    while (v126);
    goto LABEL_102;
  }
  v506 = (int8x16_t)vdupq_n_s64(v117);
  v125 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v507 = (int8x16_t)vdupq_n_s64(v118);
  v508 = (int8x16_t *)(a2 + 88);
  v509 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v510 = (int8x16_t *)(a3 + 936);
  do
  {
    v511 = *v510;
    v512 = v510[1];
    v510 += 2;
    v513 = vorrq_s8(vandq_s8(*v508, v507), vandq_s8(v512, v506));
    v508[-1] = vorrq_s8(vandq_s8(v508[-1], v507), vandq_s8(v511, v506));
    *v508 = v513;
    v508 += 2;
    v509 -= 4;
  }
  while (v509);
  if (v125 != v28)
    goto LABEL_100;
LABEL_102:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 1008 && a3 + 1008 < 8 * v28 + a2 + 144)
  {
    v131 = 0;
LABEL_106:
    v132 = v28 - v131;
    v133 = 8 * v131;
    v134 = (unint64_t *)(8 * v131 + a2 + 144);
    v135 = (uint64_t *)(v133 + a3 + 1008);
    do
    {
      v136 = *v135++;
      *v134 = *v134 & v118 | v136 & v117;
      ++v134;
      --v132;
    }
    while (v132);
    goto LABEL_108;
  }
  v514 = (int8x16_t)vdupq_n_s64(v117);
  v131 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v515 = (int8x16_t)vdupq_n_s64(v118);
  v516 = (int8x16_t *)(a3 + 1024);
  v517 = (int8x16_t *)(a2 + 160);
  v518 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v519 = vorrq_s8(vandq_s8(*v517, v515), vandq_s8(*v516, v514));
    v517[-1] = vorrq_s8(vandq_s8(v517[-1], v515), vandq_s8(v516[-1], v514));
    *v517 = v519;
    v516 += 2;
    v517 += 2;
    v518 -= 4;
  }
  while (v518);
  if (v131 != v28)
    goto LABEL_106;
LABEL_108:
  v137 = (uint64_t)((v29 ^ 5) - 1) >> 63;
  v138 = ~v137;
  if (v28 < 6
    || (v139 = (int8x16_t *)(a3 + 1080), 8 * v28 + a3 + 1080 > a2) && (unint64_t)v139 < a2 + 8 * v28)
  {
    v140 = 0;
LABEL_112:
    v141 = v28 - v140;
    v142 = 8 * v140;
    v143 = (unint64_t *)(a2 + 8 * v140);
    v144 = (uint64_t *)(v142 + a3 + 1080);
    do
    {
      v145 = *v144++;
      *v143 = *v143 & v138 | v145 & v137;
      ++v143;
      --v141;
    }
    while (v141);
    goto LABEL_114;
  }
  v140 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v520 = (int8x16_t)vdupq_n_s64(v137);
  v521 = (int8x16_t)vdupq_n_s64(v138);
  v522 = (int8x16_t *)(a2 + 16);
  v523 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v524 = *v139;
    v525 = v139[1];
    v139 += 2;
    v526 = vorrq_s8(vandq_s8(*v522, v521), vandq_s8(v525, v520));
    v522[-1] = vorrq_s8(vandq_s8(v522[-1], v521), vandq_s8(v524, v520));
    *v522 = v526;
    v522 += 2;
    v523 -= 4;
  }
  while (v523);
  if (v140 != v28)
    goto LABEL_112;
LABEL_114:
  if (v28 < 6 || (unint64_t)v39 < 8 * v28 + a3 + 1152 && a3 + 1152 < 8 * v28 + a2 + 72)
  {
    v146 = 0;
LABEL_118:
    v147 = v28 - v146;
    v148 = 8 * v146;
    v149 = (unint64_t *)(8 * v146 + a2 + 72);
    v150 = (uint64_t *)(v148 + a3 + 1152);
    do
    {
      v151 = *v150++;
      *v149 = *v149 & v138 | v151 & v137;
      ++v149;
      --v147;
    }
    while (v147);
    goto LABEL_120;
  }
  v527 = (int8x16_t)vdupq_n_s64(v137);
  v146 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v528 = (int8x16_t)vdupq_n_s64(v138);
  v529 = (int8x16_t *)(a3 + 1168);
  v530 = (int8x16_t *)(a2 + 88);
  v531 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v532 = vorrq_s8(vandq_s8(*v530, v528), vandq_s8(*v529, v527));
    v530[-1] = vorrq_s8(vandq_s8(v530[-1], v528), vandq_s8(v529[-1], v527));
    *v530 = v532;
    v529 += 2;
    v530 += 2;
    v531 -= 4;
  }
  while (v531);
  if (v146 != v28)
    goto LABEL_118;
LABEL_120:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 1224 && a3 + 1224 < 8 * v28 + a2 + 144)
  {
    v152 = 0;
LABEL_124:
    v153 = v28 - v152;
    v154 = 8 * v152;
    v155 = (unint64_t *)(8 * v152 + a2 + 144);
    v156 = (uint64_t *)(v154 + a3 + 1224);
    do
    {
      v157 = *v156++;
      *v155 = *v155 & v138 | v157 & v137;
      ++v155;
      --v153;
    }
    while (v153);
    goto LABEL_126;
  }
  v533 = (int8x16_t)vdupq_n_s64(v137);
  v152 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v534 = (int8x16_t)vdupq_n_s64(v138);
  v535 = (int8x16_t *)(a2 + 160);
  v536 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v537 = (int8x16_t *)(a3 + 1224);
  do
  {
    v538 = *v537;
    v539 = v537[1];
    v537 += 2;
    v540 = vorrq_s8(vandq_s8(*v535, v534), vandq_s8(v539, v533));
    v535[-1] = vorrq_s8(vandq_s8(v535[-1], v534), vandq_s8(v538, v533));
    *v535 = v540;
    v535 += 2;
    v536 -= 4;
  }
  while (v536);
  if (v152 != v28)
    goto LABEL_124;
LABEL_126:
  v158 = (uint64_t)((v29 ^ 6) - 1) >> 63;
  v159 = ~v158;
  if (v28 < 6 || 8 * v28 + a3 + 1296 > a2 && a3 + 1296 < a2 + 8 * v28)
  {
    v160 = 0;
LABEL_130:
    v161 = v28 - v160;
    v162 = 8 * v160;
    v163 = (unint64_t *)(a2 + 8 * v160);
    v164 = (uint64_t *)(v162 + a3 + 1296);
    do
    {
      v165 = *v164++;
      *v163 = *v163 & v159 | v165 & v158;
      ++v163;
      --v161;
    }
    while (v161);
    goto LABEL_132;
  }
  v541 = (int8x16_t)vdupq_n_s64(v158);
  v160 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v542 = (int8x16_t)vdupq_n_s64(v159);
  v543 = (int8x16_t *)(a3 + 1312);
  v544 = (int8x16_t *)(a2 + 16);
  v545 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v546 = vorrq_s8(vandq_s8(*v544, v542), vandq_s8(*v543, v541));
    v544[-1] = vorrq_s8(vandq_s8(v544[-1], v542), vandq_s8(v543[-1], v541));
    *v544 = v546;
    v543 += 2;
    v544 += 2;
    v545 -= 4;
  }
  while (v545);
  if (v160 != v28)
    goto LABEL_130;
LABEL_132:
  if (v28 < 6
    || (v166 = (int8x16_t *)(a3 + 1368), (unint64_t)v39 < 8 * v28 + a3 + 1368)
    && (unint64_t)v166 < 8 * v28 + a2 + 72)
  {
    v167 = 0;
LABEL_136:
    v168 = v28 - v167;
    v169 = 8 * v167;
    v170 = (unint64_t *)(8 * v167 + a2 + 72);
    v171 = (uint64_t *)(v169 + a3 + 1368);
    do
    {
      v172 = *v171++;
      *v170 = *v170 & v159 | v172 & v158;
      ++v170;
      --v168;
    }
    while (v168);
    goto LABEL_138;
  }
  v167 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v547 = (int8x16_t)vdupq_n_s64(v158);
  v548 = (int8x16_t)vdupq_n_s64(v159);
  v549 = (int8x16_t *)(a2 + 88);
  v550 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v551 = *v166;
    v552 = v166[1];
    v166 += 2;
    v553 = vorrq_s8(vandq_s8(*v549, v548), vandq_s8(v552, v547));
    v549[-1] = vorrq_s8(vandq_s8(v549[-1], v548), vandq_s8(v551, v547));
    *v549 = v553;
    v549 += 2;
    v550 -= 4;
  }
  while (v550);
  if (v167 != v28)
    goto LABEL_136;
LABEL_138:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 1440 && a3 + 1440 < 8 * v28 + a2 + 144)
  {
    v173 = 0;
LABEL_142:
    v174 = v28 - v173;
    v175 = 8 * v173;
    v176 = (unint64_t *)(8 * v173 + a2 + 144);
    v177 = (uint64_t *)(v175 + a3 + 1440);
    do
    {
      v178 = *v177++;
      *v176 = *v176 & v159 | v178 & v158;
      ++v176;
      --v174;
    }
    while (v174);
    goto LABEL_144;
  }
  v554 = (int8x16_t)vdupq_n_s64(v158);
  v173 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v555 = (int8x16_t)vdupq_n_s64(v159);
  v556 = (int8x16_t *)(a3 + 1456);
  v557 = (int8x16_t *)(a2 + 160);
  v558 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v559 = vorrq_s8(vandq_s8(*v557, v555), vandq_s8(*v556, v554));
    v557[-1] = vorrq_s8(vandq_s8(v557[-1], v555), vandq_s8(v556[-1], v554));
    *v557 = v559;
    v556 += 2;
    v557 += 2;
    v558 -= 4;
  }
  while (v558);
  if (v173 != v28)
    goto LABEL_142;
LABEL_144:
  v179 = (uint64_t)((v29 ^ 7) - 1) >> 63;
  v180 = ~v179;
  if (v28 < 6 || 8 * v28 + a3 + 1512 > a2 && a3 + 1512 < a2 + 8 * v28)
  {
    v181 = 0;
LABEL_148:
    v182 = v28 - v181;
    v183 = 8 * v181;
    v184 = (unint64_t *)(a2 + 8 * v181);
    v185 = (uint64_t *)(v183 + a3 + 1512);
    do
    {
      v186 = *v185++;
      *v184 = *v184 & v180 | v186 & v179;
      ++v184;
      --v182;
    }
    while (v182);
    goto LABEL_150;
  }
  v560 = (int8x16_t)vdupq_n_s64(v179);
  v181 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v561 = (int8x16_t)vdupq_n_s64(v180);
  v562 = (int8x16_t *)(a2 + 16);
  v563 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v564 = (int8x16_t *)(a3 + 1512);
  do
  {
    v565 = *v564;
    v566 = v564[1];
    v564 += 2;
    v567 = vorrq_s8(vandq_s8(*v562, v561), vandq_s8(v566, v560));
    v562[-1] = vorrq_s8(vandq_s8(v562[-1], v561), vandq_s8(v565, v560));
    *v562 = v567;
    v562 += 2;
    v563 -= 4;
  }
  while (v563);
  if (v181 != v28)
    goto LABEL_148;
LABEL_150:
  if (v28 < 6 || (unint64_t)v39 < 8 * v28 + a3 + 1584 && a3 + 1584 < 8 * v28 + a2 + 72)
  {
    v187 = 0;
LABEL_154:
    v188 = v28 - v187;
    v189 = 8 * v187;
    v190 = (unint64_t *)(8 * v187 + a2 + 72);
    v191 = (uint64_t *)(v189 + a3 + 1584);
    do
    {
      v192 = *v191++;
      *v190 = *v190 & v180 | v192 & v179;
      ++v190;
      --v188;
    }
    while (v188);
    goto LABEL_156;
  }
  v568 = (int8x16_t)vdupq_n_s64(v179);
  v187 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v569 = (int8x16_t)vdupq_n_s64(v180);
  v570 = (int8x16_t *)(a3 + 1600);
  v571 = (int8x16_t *)(a2 + 88);
  v572 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v573 = vorrq_s8(vandq_s8(*v571, v569), vandq_s8(*v570, v568));
    v571[-1] = vorrq_s8(vandq_s8(v571[-1], v569), vandq_s8(v570[-1], v568));
    *v571 = v573;
    v570 += 2;
    v571 += 2;
    v572 -= 4;
  }
  while (v572);
  if (v187 != v28)
    goto LABEL_154;
LABEL_156:
  if (v28 < 6
    || (v193 = (int8x16_t *)(a3 + 1656), v47 < 8 * v28 + a3 + 1656) && (unint64_t)v193 < 8 * v28 + a2 + 144)
  {
    v194 = 0;
LABEL_160:
    v195 = v28 - v194;
    v196 = 8 * v194;
    v197 = (unint64_t *)(8 * v194 + a2 + 144);
    v198 = (uint64_t *)(v196 + a3 + 1656);
    do
    {
      v199 = *v198++;
      *v197 = *v197 & v180 | v199 & v179;
      ++v197;
      --v195;
    }
    while (v195);
    goto LABEL_162;
  }
  v194 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v574 = (int8x16_t)vdupq_n_s64(v179);
  v575 = (int8x16_t)vdupq_n_s64(v180);
  v576 = (int8x16_t *)(a2 + 160);
  v577 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v578 = *v193;
    v579 = v193[1];
    v193 += 2;
    v580 = vorrq_s8(vandq_s8(*v576, v575), vandq_s8(v579, v574));
    v576[-1] = vorrq_s8(vandq_s8(v576[-1], v575), vandq_s8(v578, v574));
    *v576 = v580;
    v576 += 2;
    v577 -= 4;
  }
  while (v577);
  if (v194 != v28)
    goto LABEL_160;
LABEL_162:
  v200 = (uint64_t)((v29 ^ 8) - 1) >> 63;
  v201 = ~v200;
  if (v28 < 6 || 8 * v28 + a3 + 1728 > a2 && a3 + 1728 < a2 + 8 * v28)
  {
    v202 = 0;
LABEL_166:
    v203 = v28 - v202;
    v204 = 8 * v202;
    v205 = (unint64_t *)(a2 + 8 * v202);
    v206 = (uint64_t *)(v204 + a3 + 1728);
    do
    {
      v207 = *v206++;
      *v205 = *v205 & v201 | v207 & v200;
      ++v205;
      --v203;
    }
    while (v203);
    goto LABEL_168;
  }
  v581 = (int8x16_t)vdupq_n_s64(v200);
  v202 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v582 = (int8x16_t)vdupq_n_s64(v201);
  v583 = (int8x16_t *)(a3 + 1744);
  v584 = (int8x16_t *)(a2 + 16);
  v585 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v586 = vorrq_s8(vandq_s8(*v584, v582), vandq_s8(*v583, v581));
    v584[-1] = vorrq_s8(vandq_s8(v584[-1], v582), vandq_s8(v583[-1], v581));
    *v584 = v586;
    v583 += 2;
    v584 += 2;
    v585 -= 4;
  }
  while (v585);
  if (v202 != v28)
    goto LABEL_166;
LABEL_168:
  if (v28 < 6 || (unint64_t)v39 < 8 * v28 + a3 + 1800 && a3 + 1800 < 8 * v28 + a2 + 72)
  {
    v208 = 0;
LABEL_172:
    v209 = v28 - v208;
    v210 = 8 * v208;
    v211 = (unint64_t *)(8 * v208 + a2 + 72);
    v212 = (uint64_t *)(v210 + a3 + 1800);
    do
    {
      v213 = *v212++;
      *v211 = *v211 & v201 | v213 & v200;
      ++v211;
      --v209;
    }
    while (v209);
    goto LABEL_174;
  }
  v587 = (int8x16_t)vdupq_n_s64(v200);
  v208 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v588 = (int8x16_t)vdupq_n_s64(v201);
  v589 = (int8x16_t *)(a2 + 88);
  v590 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v591 = (int8x16_t *)(a3 + 1800);
  do
  {
    v592 = *v591;
    v593 = v591[1];
    v591 += 2;
    v594 = vorrq_s8(vandq_s8(*v589, v588), vandq_s8(v593, v587));
    v589[-1] = vorrq_s8(vandq_s8(v589[-1], v588), vandq_s8(v592, v587));
    *v589 = v594;
    v589 += 2;
    v590 -= 4;
  }
  while (v590);
  if (v208 != v28)
    goto LABEL_172;
LABEL_174:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 1872 && a3 + 1872 < 8 * v28 + a2 + 144)
  {
    v214 = 0;
LABEL_178:
    v215 = v28 - v214;
    v216 = 8 * v214;
    v217 = (unint64_t *)(8 * v214 + a2 + 144);
    v218 = (uint64_t *)(v216 + a3 + 1872);
    do
    {
      v219 = *v218++;
      *v217 = *v217 & v201 | v219 & v200;
      ++v217;
      --v215;
    }
    while (v215);
    goto LABEL_180;
  }
  v595 = (int8x16_t)vdupq_n_s64(v200);
  v214 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v596 = (int8x16_t)vdupq_n_s64(v201);
  v597 = (int8x16_t *)(a3 + 1888);
  v598 = (int8x16_t *)(a2 + 160);
  v599 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v600 = vorrq_s8(vandq_s8(*v598, v596), vandq_s8(*v597, v595));
    v598[-1] = vorrq_s8(vandq_s8(v598[-1], v596), vandq_s8(v597[-1], v595));
    *v598 = v600;
    v597 += 2;
    v598 += 2;
    v599 -= 4;
  }
  while (v599);
  if (v214 != v28)
    goto LABEL_178;
LABEL_180:
  v220 = (uint64_t)((v29 ^ 9) - 1) >> 63;
  v221 = ~v220;
  if (v28 < 6
    || (v222 = (int8x16_t *)(a3 + 1944), 8 * v28 + a3 + 1944 > a2) && (unint64_t)v222 < a2 + 8 * v28)
  {
    v223 = 0;
LABEL_184:
    v224 = v28 - v223;
    v225 = 8 * v223;
    v226 = (unint64_t *)(a2 + 8 * v223);
    v227 = (uint64_t *)(v225 + a3 + 1944);
    do
    {
      v228 = *v227++;
      *v226 = *v226 & v221 | v228 & v220;
      ++v226;
      --v224;
    }
    while (v224);
    goto LABEL_186;
  }
  v223 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v601 = (int8x16_t)vdupq_n_s64(v220);
  v602 = (int8x16_t)vdupq_n_s64(v221);
  v603 = (int8x16_t *)(a2 + 16);
  v604 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v605 = *v222;
    v606 = v222[1];
    v222 += 2;
    v607 = vorrq_s8(vandq_s8(*v603, v602), vandq_s8(v606, v601));
    v603[-1] = vorrq_s8(vandq_s8(v603[-1], v602), vandq_s8(v605, v601));
    *v603 = v607;
    v603 += 2;
    v604 -= 4;
  }
  while (v604);
  if (v223 != v28)
    goto LABEL_184;
LABEL_186:
  if (v28 < 6 || (unint64_t)v39 < 8 * v28 + a3 + 2016 && a3 + 2016 < 8 * v28 + a2 + 72)
  {
    v229 = 0;
LABEL_190:
    v230 = v28 - v229;
    v231 = 8 * v229;
    v232 = (unint64_t *)(8 * v229 + a2 + 72);
    v233 = (uint64_t *)(v231 + a3 + 2016);
    do
    {
      v234 = *v233++;
      *v232 = *v232 & v221 | v234 & v220;
      ++v232;
      --v230;
    }
    while (v230);
    goto LABEL_192;
  }
  v608 = (int8x16_t)vdupq_n_s64(v220);
  v229 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v609 = (int8x16_t)vdupq_n_s64(v221);
  v610 = (int8x16_t *)(a3 + 2032);
  v611 = (int8x16_t *)(a2 + 88);
  v612 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v613 = vorrq_s8(vandq_s8(*v611, v609), vandq_s8(*v610, v608));
    v611[-1] = vorrq_s8(vandq_s8(v611[-1], v609), vandq_s8(v610[-1], v608));
    *v611 = v613;
    v610 += 2;
    v611 += 2;
    v612 -= 4;
  }
  while (v612);
  if (v229 != v28)
    goto LABEL_190;
LABEL_192:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 2088 && a3 + 2088 < 8 * v28 + a2 + 144)
  {
    v235 = 0;
LABEL_196:
    v236 = v28 - v235;
    v237 = 8 * v235;
    v238 = (unint64_t *)(8 * v235 + a2 + 144);
    v239 = (uint64_t *)(v237 + a3 + 2088);
    do
    {
      v240 = *v239++;
      *v238 = *v238 & v221 | v240 & v220;
      ++v238;
      --v236;
    }
    while (v236);
    goto LABEL_198;
  }
  v614 = (int8x16_t)vdupq_n_s64(v220);
  v235 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v615 = (int8x16_t)vdupq_n_s64(v221);
  v616 = (int8x16_t *)(a2 + 160);
  v617 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v618 = (int8x16_t *)(a3 + 2088);
  do
  {
    v619 = *v618;
    v620 = v618[1];
    v618 += 2;
    v621 = vorrq_s8(vandq_s8(*v616, v615), vandq_s8(v620, v614));
    v616[-1] = vorrq_s8(vandq_s8(v616[-1], v615), vandq_s8(v619, v614));
    *v616 = v621;
    v616 += 2;
    v617 -= 4;
  }
  while (v617);
  if (v235 != v28)
    goto LABEL_196;
LABEL_198:
  v241 = (uint64_t)((v29 ^ 0xA) - 1) >> 63;
  v242 = ~v241;
  if (v28 < 6 || 8 * v28 + a3 + 2160 > a2 && a3 + 2160 < a2 + 8 * v28)
  {
    v243 = 0;
LABEL_202:
    v244 = v28 - v243;
    v245 = 8 * v243;
    v246 = (unint64_t *)(a2 + 8 * v243);
    v247 = (uint64_t *)(v245 + a3 + 2160);
    do
    {
      v248 = *v247++;
      *v246 = *v246 & v242 | v248 & v241;
      ++v246;
      --v244;
    }
    while (v244);
    goto LABEL_204;
  }
  v622 = (int8x16_t)vdupq_n_s64(v241);
  v243 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v623 = (int8x16_t)vdupq_n_s64(v242);
  v624 = (int8x16_t *)(a3 + 2176);
  v625 = (int8x16_t *)(a2 + 16);
  v626 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v627 = vorrq_s8(vandq_s8(*v625, v623), vandq_s8(*v624, v622));
    v625[-1] = vorrq_s8(vandq_s8(v625[-1], v623), vandq_s8(v624[-1], v622));
    *v625 = v627;
    v624 += 2;
    v625 += 2;
    v626 -= 4;
  }
  while (v626);
  if (v243 != v28)
    goto LABEL_202;
LABEL_204:
  if (v28 < 6
    || (v249 = (int8x16_t *)(a3 + 2232), (unint64_t)v39 < 8 * v28 + a3 + 2232)
    && (unint64_t)v249 < 8 * v28 + a2 + 72)
  {
    v250 = 0;
LABEL_208:
    v251 = v28 - v250;
    v252 = 8 * v250;
    v253 = (unint64_t *)(8 * v250 + a2 + 72);
    v254 = (uint64_t *)(v252 + a3 + 2232);
    do
    {
      v255 = *v254++;
      *v253 = *v253 & v242 | v255 & v241;
      ++v253;
      --v251;
    }
    while (v251);
    goto LABEL_210;
  }
  v250 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v628 = (int8x16_t)vdupq_n_s64(v241);
  v629 = (int8x16_t)vdupq_n_s64(v242);
  v630 = (int8x16_t *)(a2 + 88);
  v631 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v632 = *v249;
    v633 = v249[1];
    v249 += 2;
    v634 = vorrq_s8(vandq_s8(*v630, v629), vandq_s8(v633, v628));
    v630[-1] = vorrq_s8(vandq_s8(v630[-1], v629), vandq_s8(v632, v628));
    *v630 = v634;
    v630 += 2;
    v631 -= 4;
  }
  while (v631);
  if (v250 != v28)
    goto LABEL_208;
LABEL_210:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 2304 && a3 + 2304 < 8 * v28 + a2 + 144)
  {
    v256 = 0;
LABEL_214:
    v257 = v28 - v256;
    v258 = 8 * v256;
    v259 = (unint64_t *)(8 * v256 + a2 + 144);
    v260 = (uint64_t *)(v258 + a3 + 2304);
    do
    {
      v261 = *v260++;
      *v259 = *v259 & v242 | v261 & v241;
      ++v259;
      --v257;
    }
    while (v257);
    goto LABEL_216;
  }
  v635 = (int8x16_t)vdupq_n_s64(v241);
  v256 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v636 = (int8x16_t)vdupq_n_s64(v242);
  v637 = (int8x16_t *)(a3 + 2320);
  v638 = (int8x16_t *)(a2 + 160);
  v639 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v640 = vorrq_s8(vandq_s8(*v638, v636), vandq_s8(*v637, v635));
    v638[-1] = vorrq_s8(vandq_s8(v638[-1], v636), vandq_s8(v637[-1], v635));
    *v638 = v640;
    v637 += 2;
    v638 += 2;
    v639 -= 4;
  }
  while (v639);
  if (v256 != v28)
    goto LABEL_214;
LABEL_216:
  v262 = (uint64_t)((v29 ^ 0xB) - 1) >> 63;
  v263 = ~v262;
  if (v28 < 6 || 8 * v28 + a3 + 2376 > a2 && a3 + 2376 < a2 + 8 * v28)
  {
    v264 = 0;
LABEL_220:
    v265 = v28 - v264;
    v266 = 8 * v264;
    v267 = (unint64_t *)(a2 + 8 * v264);
    v268 = (uint64_t *)(v266 + a3 + 2376);
    do
    {
      v269 = *v268++;
      *v267 = *v267 & v263 | v269 & v262;
      ++v267;
      --v265;
    }
    while (v265);
    goto LABEL_222;
  }
  v641 = (int8x16_t)vdupq_n_s64(v262);
  v264 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v642 = (int8x16_t)vdupq_n_s64(v263);
  v643 = (int8x16_t *)(a2 + 16);
  v644 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v645 = (int8x16_t *)(a3 + 2376);
  do
  {
    v646 = *v645;
    v647 = v645[1];
    v645 += 2;
    v648 = vorrq_s8(vandq_s8(*v643, v642), vandq_s8(v647, v641));
    v643[-1] = vorrq_s8(vandq_s8(v643[-1], v642), vandq_s8(v646, v641));
    *v643 = v648;
    v643 += 2;
    v644 -= 4;
  }
  while (v644);
  if (v264 != v28)
    goto LABEL_220;
LABEL_222:
  if (v28 < 6 || (unint64_t)v39 < 8 * v28 + a3 + 2448 && a3 + 2448 < 8 * v28 + a2 + 72)
  {
    v270 = 0;
LABEL_226:
    v271 = v28 - v270;
    v272 = 8 * v270;
    v273 = (unint64_t *)(8 * v270 + a2 + 72);
    v274 = (uint64_t *)(v272 + a3 + 2448);
    do
    {
      v275 = *v274++;
      *v273 = *v273 & v263 | v275 & v262;
      ++v273;
      --v271;
    }
    while (v271);
    goto LABEL_228;
  }
  v649 = (int8x16_t)vdupq_n_s64(v262);
  v270 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v650 = (int8x16_t)vdupq_n_s64(v263);
  v651 = (int8x16_t *)(a3 + 2464);
  v652 = (int8x16_t *)(a2 + 88);
  v653 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v654 = vorrq_s8(vandq_s8(*v652, v650), vandq_s8(*v651, v649));
    v652[-1] = vorrq_s8(vandq_s8(v652[-1], v650), vandq_s8(v651[-1], v649));
    *v652 = v654;
    v651 += 2;
    v652 += 2;
    v653 -= 4;
  }
  while (v653);
  if (v270 != v28)
    goto LABEL_226;
LABEL_228:
  if (v28 < 6
    || (v276 = (int8x16_t *)(a3 + 2520), v47 < 8 * v28 + a3 + 2520) && (unint64_t)v276 < 8 * v28 + a2 + 144)
  {
    v277 = 0;
LABEL_232:
    v278 = v28 - v277;
    v279 = 8 * v277;
    v280 = (unint64_t *)(8 * v277 + a2 + 144);
    v281 = (uint64_t *)(v279 + a3 + 2520);
    do
    {
      v282 = *v281++;
      *v280 = *v280 & v263 | v282 & v262;
      ++v280;
      --v278;
    }
    while (v278);
    goto LABEL_234;
  }
  v277 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v655 = (int8x16_t)vdupq_n_s64(v262);
  v656 = (int8x16_t)vdupq_n_s64(v263);
  v657 = (int8x16_t *)(a2 + 160);
  v658 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v659 = *v276;
    v660 = v276[1];
    v276 += 2;
    v661 = vorrq_s8(vandq_s8(*v657, v656), vandq_s8(v660, v655));
    v657[-1] = vorrq_s8(vandq_s8(v657[-1], v656), vandq_s8(v659, v655));
    *v657 = v661;
    v657 += 2;
    v658 -= 4;
  }
  while (v658);
  if (v277 != v28)
    goto LABEL_232;
LABEL_234:
  v283 = (uint64_t)((v29 ^ 0xC) - 1) >> 63;
  v284 = ~v283;
  if (v28 < 6 || 8 * v28 + a3 + 2592 > a2 && a3 + 2592 < a2 + 8 * v28)
  {
    v285 = 0;
LABEL_238:
    v286 = v28 - v285;
    v287 = 8 * v285;
    v288 = (unint64_t *)(a2 + 8 * v285);
    v289 = (uint64_t *)(v287 + a3 + 2592);
    do
    {
      v290 = *v289++;
      *v288 = *v288 & v284 | v290 & v283;
      ++v288;
      --v286;
    }
    while (v286);
    goto LABEL_240;
  }
  v662 = (int8x16_t)vdupq_n_s64(v283);
  v285 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v663 = (int8x16_t)vdupq_n_s64(v284);
  v664 = (int8x16_t *)(a3 + 2608);
  v665 = (int8x16_t *)(a2 + 16);
  v666 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v667 = vorrq_s8(vandq_s8(*v665, v663), vandq_s8(*v664, v662));
    v665[-1] = vorrq_s8(vandq_s8(v665[-1], v663), vandq_s8(v664[-1], v662));
    *v665 = v667;
    v664 += 2;
    v665 += 2;
    v666 -= 4;
  }
  while (v666);
  if (v285 != v28)
    goto LABEL_238;
LABEL_240:
  if (v28 < 6 || (unint64_t)v39 < 8 * v28 + a3 + 2664 && a3 + 2664 < 8 * v28 + a2 + 72)
  {
    v291 = 0;
LABEL_244:
    v292 = v28 - v291;
    v293 = 8 * v291;
    v294 = (unint64_t *)(8 * v291 + a2 + 72);
    v295 = (uint64_t *)(v293 + a3 + 2664);
    do
    {
      v296 = *v295++;
      *v294 = *v294 & v284 | v296 & v283;
      ++v294;
      --v292;
    }
    while (v292);
    goto LABEL_246;
  }
  v668 = (int8x16_t)vdupq_n_s64(v283);
  v291 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v669 = (int8x16_t)vdupq_n_s64(v284);
  v670 = (int8x16_t *)(a2 + 88);
  v671 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v672 = (int8x16_t *)(a3 + 2664);
  do
  {
    v673 = *v672;
    v674 = v672[1];
    v672 += 2;
    v675 = vorrq_s8(vandq_s8(*v670, v669), vandq_s8(v674, v668));
    v670[-1] = vorrq_s8(vandq_s8(v670[-1], v669), vandq_s8(v673, v668));
    *v670 = v675;
    v670 += 2;
    v671 -= 4;
  }
  while (v671);
  if (v291 != v28)
    goto LABEL_244;
LABEL_246:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 2736 && a3 + 2736 < 8 * v28 + a2 + 144)
  {
    v297 = 0;
LABEL_250:
    v298 = v28 - v297;
    v299 = 8 * v297;
    v300 = (unint64_t *)(8 * v297 + a2 + 144);
    v301 = (uint64_t *)(v299 + a3 + 2736);
    do
    {
      v302 = *v301++;
      *v300 = *v300 & v284 | v302 & v283;
      ++v300;
      --v298;
    }
    while (v298);
    goto LABEL_252;
  }
  v676 = (int8x16_t)vdupq_n_s64(v283);
  v297 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v677 = (int8x16_t)vdupq_n_s64(v284);
  v678 = (int8x16_t *)(a3 + 2752);
  v679 = (int8x16_t *)(a2 + 160);
  v680 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v681 = vorrq_s8(vandq_s8(*v679, v677), vandq_s8(*v678, v676));
    v679[-1] = vorrq_s8(vandq_s8(v679[-1], v677), vandq_s8(v678[-1], v676));
    *v679 = v681;
    v678 += 2;
    v679 += 2;
    v680 -= 4;
  }
  while (v680);
  if (v297 != v28)
    goto LABEL_250;
LABEL_252:
  v303 = (uint64_t)((v29 ^ 0xD) - 1) >> 63;
  v304 = ~v303;
  if (v28 < 6
    || (v305 = (int8x16_t *)(a3 + 2808), 8 * v28 + a3 + 2808 > a2) && (unint64_t)v305 < a2 + 8 * v28)
  {
    v306 = 0;
LABEL_256:
    v307 = v28 - v306;
    v308 = 8 * v306;
    v309 = (unint64_t *)(a2 + 8 * v306);
    v310 = (uint64_t *)(v308 + a3 + 2808);
    do
    {
      v311 = *v310++;
      *v309 = *v309 & v304 | v311 & v303;
      ++v309;
      --v307;
    }
    while (v307);
    goto LABEL_258;
  }
  v306 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v682 = (int8x16_t)vdupq_n_s64(v303);
  v683 = (int8x16_t)vdupq_n_s64(v304);
  v684 = (int8x16_t *)(a2 + 16);
  v685 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v686 = *v305;
    v687 = v305[1];
    v305 += 2;
    v688 = vorrq_s8(vandq_s8(*v684, v683), vandq_s8(v687, v682));
    v684[-1] = vorrq_s8(vandq_s8(v684[-1], v683), vandq_s8(v686, v682));
    *v684 = v688;
    v684 += 2;
    v685 -= 4;
  }
  while (v685);
  if (v306 != v28)
    goto LABEL_256;
LABEL_258:
  if (v28 < 6 || (unint64_t)v39 < 8 * v28 + a3 + 2880 && a3 + 2880 < 8 * v28 + a2 + 72)
  {
    v312 = 0;
LABEL_262:
    v313 = v28 - v312;
    v314 = 8 * v312;
    v315 = (unint64_t *)(8 * v312 + a2 + 72);
    v316 = (uint64_t *)(v314 + a3 + 2880);
    do
    {
      v317 = *v316++;
      *v315 = *v315 & v304 | v317 & v303;
      ++v315;
      --v313;
    }
    while (v313);
    goto LABEL_264;
  }
  v689 = (int8x16_t)vdupq_n_s64(v303);
  v312 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v690 = (int8x16_t)vdupq_n_s64(v304);
  v691 = (int8x16_t *)(a3 + 2896);
  v692 = (int8x16_t *)(a2 + 88);
  v693 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v694 = vorrq_s8(vandq_s8(*v692, v690), vandq_s8(*v691, v689));
    v692[-1] = vorrq_s8(vandq_s8(v692[-1], v690), vandq_s8(v691[-1], v689));
    *v692 = v694;
    v691 += 2;
    v692 += 2;
    v693 -= 4;
  }
  while (v693);
  if (v312 != v28)
    goto LABEL_262;
LABEL_264:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 2952 && a3 + 2952 < 8 * v28 + a2 + 144)
  {
    v318 = 0;
LABEL_268:
    v319 = v28 - v318;
    v320 = 8 * v318;
    v321 = (unint64_t *)(8 * v318 + a2 + 144);
    v322 = (uint64_t *)(v320 + a3 + 2952);
    do
    {
      v323 = *v322++;
      *v321 = *v321 & v304 | v323 & v303;
      ++v321;
      --v319;
    }
    while (v319);
    goto LABEL_270;
  }
  v695 = (int8x16_t)vdupq_n_s64(v303);
  v318 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v696 = (int8x16_t)vdupq_n_s64(v304);
  v697 = (int8x16_t *)(a2 + 160);
  v698 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v699 = (int8x16_t *)(a3 + 2952);
  do
  {
    v700 = *v699;
    v701 = v699[1];
    v699 += 2;
    v702 = vorrq_s8(vandq_s8(*v697, v696), vandq_s8(v701, v695));
    v697[-1] = vorrq_s8(vandq_s8(v697[-1], v696), vandq_s8(v700, v695));
    *v697 = v702;
    v697 += 2;
    v698 -= 4;
  }
  while (v698);
  if (v318 != v28)
    goto LABEL_268;
LABEL_270:
  v324 = (uint64_t)((v29 ^ 0xE) - 1) >> 63;
  v325 = ~v324;
  if (v28 < 6 || 8 * v28 + a3 + 3024 > a2 && a3 + 3024 < a2 + 8 * v28)
  {
    v326 = 0;
LABEL_274:
    v327 = v28 - v326;
    v328 = 8 * v326;
    v329 = (unint64_t *)(a2 + 8 * v326);
    v330 = (uint64_t *)(v328 + a3 + 3024);
    do
    {
      v331 = *v330++;
      *v329 = *v329 & v325 | v331 & v324;
      ++v329;
      --v327;
    }
    while (v327);
    goto LABEL_276;
  }
  v703 = (int8x16_t)vdupq_n_s64(v324);
  v326 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v704 = (int8x16_t)vdupq_n_s64(v325);
  v705 = (int8x16_t *)(a3 + 3040);
  v706 = (int8x16_t *)(a2 + 16);
  v707 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v708 = vorrq_s8(vandq_s8(*v706, v704), vandq_s8(*v705, v703));
    v706[-1] = vorrq_s8(vandq_s8(v706[-1], v704), vandq_s8(v705[-1], v703));
    *v706 = v708;
    v705 += 2;
    v706 += 2;
    v707 -= 4;
  }
  while (v707);
  if (v326 != v28)
    goto LABEL_274;
LABEL_276:
  if (v28 < 6
    || (v332 = (int8x16_t *)(a3 + 3096), (unint64_t)v39 < 8 * v28 + a3 + 3096)
    && (unint64_t)v332 < 8 * v28 + a2 + 72)
  {
    v333 = 0;
LABEL_280:
    v334 = v28 - v333;
    v335 = 8 * v333;
    v336 = (unint64_t *)(8 * v333 + a2 + 72);
    v337 = (uint64_t *)(v335 + a3 + 3096);
    do
    {
      v338 = *v337++;
      *v336 = *v336 & v325 | v338 & v324;
      ++v336;
      --v334;
    }
    while (v334);
    goto LABEL_282;
  }
  v333 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v709 = (int8x16_t)vdupq_n_s64(v324);
  v710 = (int8x16_t)vdupq_n_s64(v325);
  v711 = (int8x16_t *)(a2 + 88);
  v712 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v713 = *v332;
    v714 = v332[1];
    v332 += 2;
    v715 = vorrq_s8(vandq_s8(*v711, v710), vandq_s8(v714, v709));
    v711[-1] = vorrq_s8(vandq_s8(v711[-1], v710), vandq_s8(v713, v709));
    *v711 = v715;
    v711 += 2;
    v712 -= 4;
  }
  while (v712);
  if (v333 != v28)
    goto LABEL_280;
LABEL_282:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 3168 && a3 + 3168 < 8 * v28 + a2 + 144)
  {
    v339 = 0;
LABEL_286:
    v340 = v28 - v339;
    v341 = 8 * v339;
    v342 = (unint64_t *)(8 * v339 + a2 + 144);
    v343 = (uint64_t *)(v341 + a3 + 3168);
    do
    {
      v344 = *v343++;
      *v342 = *v342 & v325 | v344 & v324;
      ++v342;
      --v340;
    }
    while (v340);
    goto LABEL_288;
  }
  v716 = (int8x16_t)vdupq_n_s64(v324);
  v339 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v717 = (int8x16_t)vdupq_n_s64(v325);
  v718 = (int8x16_t *)(a3 + 3184);
  v719 = (int8x16_t *)(a2 + 160);
  v720 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v721 = vorrq_s8(vandq_s8(*v719, v717), vandq_s8(*v718, v716));
    v719[-1] = vorrq_s8(vandq_s8(v719[-1], v717), vandq_s8(v718[-1], v716));
    *v719 = v721;
    v718 += 2;
    v719 += 2;
    v720 -= 4;
  }
  while (v720);
  if (v339 != v28)
    goto LABEL_286;
LABEL_288:
  v345 = (uint64_t)((v29 ^ 0xF) - 1) >> 63;
  v346 = ~v345;
  if (v28 < 6 || 8 * v28 + a3 + 3240 > a2 && a3 + 3240 < a2 + 8 * v28)
  {
    v347 = 0;
LABEL_292:
    v348 = v28 - v347;
    v349 = 8 * v347;
    v350 = (unint64_t *)(a2 + 8 * v347);
    v351 = (uint64_t *)(v349 + a3 + 3240);
    do
    {
      v352 = *v351++;
      *v350 = *v350 & v346 | v352 & v345;
      ++v350;
      --v348;
    }
    while (v348);
    goto LABEL_294;
  }
  v722 = (int8x16_t)vdupq_n_s64(v345);
  v347 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v723 = (int8x16_t)vdupq_n_s64(v346);
  v724 = (int8x16_t *)(a2 + 16);
  v725 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v726 = (int8x16_t *)(a3 + 3240);
  do
  {
    v727 = *v726;
    v728 = v726[1];
    v726 += 2;
    v729 = vorrq_s8(vandq_s8(*v724, v723), vandq_s8(v728, v722));
    v724[-1] = vorrq_s8(vandq_s8(v724[-1], v723), vandq_s8(v727, v722));
    *v724 = v729;
    v724 += 2;
    v725 -= 4;
  }
  while (v725);
  if (v347 != v28)
    goto LABEL_292;
LABEL_294:
  if (v28 < 6 || (unint64_t)v39 < 8 * v28 + a3 + 3312 && a3 + 3312 < 8 * v28 + a2 + 72)
  {
    v353 = 0;
LABEL_298:
    v354 = v28 - v353;
    v355 = 8 * v353;
    v356 = (unint64_t *)(8 * v353 + a2 + 72);
    v357 = (uint64_t *)(v355 + a3 + 3312);
    do
    {
      v358 = *v357++;
      *v356 = *v356 & v346 | v358 & v345;
      ++v356;
      --v354;
    }
    while (v354);
    goto LABEL_300;
  }
  v730 = (int8x16_t)vdupq_n_s64(v345);
  v353 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v731 = (int8x16_t)vdupq_n_s64(v346);
  v732 = (int8x16_t *)(a3 + 3328);
  v733 = (int8x16_t *)(a2 + 88);
  v734 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v735 = vorrq_s8(vandq_s8(*v733, v731), vandq_s8(*v732, v730));
    v733[-1] = vorrq_s8(vandq_s8(v733[-1], v731), vandq_s8(v732[-1], v730));
    *v733 = v735;
    v732 += 2;
    v733 += 2;
    v734 -= 4;
  }
  while (v734);
  if (v353 != v28)
    goto LABEL_298;
LABEL_300:
  if (v28 < 6
    || (v359 = (int8x16_t *)(a3 + 3384), v47 < 8 * v28 + a3 + 3384) && (unint64_t)v359 < 8 * v28 + a2 + 144)
  {
    v360 = 0;
LABEL_304:
    v361 = v28 - v360;
    v362 = 8 * v360;
    v363 = (unint64_t *)(8 * v360 + a2 + 144);
    v364 = (uint64_t *)(v362 + a3 + 3384);
    do
    {
      v365 = *v364++;
      *v363 = *v363 & v346 | v365 & v345;
      ++v363;
      --v361;
    }
    while (v361);
    goto LABEL_306;
  }
  v360 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v736 = (int8x16_t)vdupq_n_s64(v345);
  v737 = (int8x16_t)vdupq_n_s64(v346);
  v738 = (int8x16_t *)(a2 + 160);
  v739 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v740 = *v359;
    v741 = v359[1];
    v359 += 2;
    v742 = vorrq_s8(vandq_s8(*v738, v737), vandq_s8(v741, v736));
    v738[-1] = vorrq_s8(vandq_s8(v738[-1], v737), vandq_s8(v740, v736));
    *v738 = v742;
    v738 += 2;
    v739 -= 4;
  }
  while (v739);
  if (v360 != v28)
    goto LABEL_304;
LABEL_306:
  v366 = (uint64_t)((v29 ^ 0x10) - 1) >> 63;
  v367 = ~v366;
  if (v28 < 6 || 8 * v28 + a3 + 3456 > a2 && a3 + 3456 < a2 + 8 * v28)
  {
    v368 = 0;
LABEL_310:
    v369 = v28 - v368;
    v370 = 8 * v368;
    v371 = (unint64_t *)(a2 + 8 * v368);
    v372 = (uint64_t *)(v370 + a3 + 3456);
    do
    {
      v373 = *v372++;
      *v371 = *v371 & v367 | v373 & v366;
      ++v371;
      --v369;
    }
    while (v369);
    goto LABEL_312;
  }
  v743 = (int8x16_t)vdupq_n_s64(v366);
  v368 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v744 = (int8x16_t)vdupq_n_s64(v367);
  v745 = (int8x16_t *)(a3 + 3472);
  v746 = (int8x16_t *)(a2 + 16);
  v747 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v748 = vorrq_s8(vandq_s8(*v746, v744), vandq_s8(*v745, v743));
    v746[-1] = vorrq_s8(vandq_s8(v746[-1], v744), vandq_s8(v745[-1], v743));
    *v746 = v748;
    v745 += 2;
    v746 += 2;
    v747 -= 4;
  }
  while (v747);
  if (v368 != v28)
    goto LABEL_310;
LABEL_312:
  if (v28 < 6
    || (v374 = (int8x16_t *)(a3 + 3528), (unint64_t)v39 < 8 * v28 + a3 + 3528)
    && (unint64_t)v374 < 8 * v28 + a2 + 72)
  {
    v375 = 0;
LABEL_316:
    v376 = v28 - v375;
    v377 = 8 * v375;
    v378 = (unint64_t *)(8 * v375 + a2 + 72);
    v379 = (uint64_t *)(v377 + a3 + 3528);
    do
    {
      v380 = *v379++;
      *v378 = *v378 & v367 | v380 & v366;
      ++v378;
      --v376;
    }
    while (v376);
    goto LABEL_318;
  }
  v375 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v749 = (int8x16_t)vdupq_n_s64(v366);
  v750 = (int8x16_t)vdupq_n_s64(v367);
  v751 = (int8x16_t *)(a2 + 88);
  v752 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v753 = *v374;
    v754 = v374[1];
    v374 += 2;
    v755 = vorrq_s8(vandq_s8(*v751, v750), vandq_s8(v754, v749));
    v751[-1] = vorrq_s8(vandq_s8(v751[-1], v750), vandq_s8(v753, v749));
    *v751 = v755;
    v751 += 2;
    v752 -= 4;
  }
  while (v752);
  if (v375 != v28)
    goto LABEL_316;
LABEL_318:
  if (v28 < 6 || v47 < 8 * v28 + a3 + 3600 && a3 + 3600 < 8 * v28 + a2 + 144)
  {
    v381 = 0;
LABEL_322:
    v382 = v28 - v381;
    v383 = 8 * v381;
    v384 = (unint64_t *)(8 * v381 + a2 + 144);
    v385 = (uint64_t *)(v383 + a3 + 3600);
    do
    {
      v386 = *v385++;
      *v384 = *v384 & v367 | v386 & v366;
      ++v384;
      --v382;
    }
    while (v382);
    goto LABEL_324;
  }
  v756 = (int8x16_t)vdupq_n_s64(v366);
  v381 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  v757 = (int8x16_t)vdupq_n_s64(v367);
  v758 = (int8x16_t *)(a3 + 3616);
  v759 = (int8x16_t *)(a2 + 160);
  v760 = v28 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v761 = vorrq_s8(vandq_s8(*v759, v757), vandq_s8(*v758, v756));
    v759[-1] = vorrq_s8(vandq_s8(v759[-1], v757), vandq_s8(v758[-1], v756));
    *v759 = v761;
    v758 += 2;
    v759 += 2;
    v760 -= 4;
  }
  while (v760);
  if (v381 != v28)
    goto LABEL_322;
LABEL_324:
  v766 = 0;
  v387 = 0uLL;
  v764 = 0u;
  v765 = 0u;
  v762 = 0u;
  v763 = 0u;
  if ((int)v28 < 1)
  {
    v390 = 0;
    goto LABEL_337;
  }
  if (v28 >= 4)
  {
    v388 = v28 & 0x7FFFFFFC;
    v391 = (int8x16_t *)(a2 + 88);
    v392 = v28 & 0xFFFFFFFC;
    v393 = 0uLL;
    do
    {
      v387 = vorrq_s8(v391[-1], v387);
      v393 = vorrq_s8(*v391, v393);
      v391 += 2;
      v392 -= 4;
    }
    while (v392);
    v394 = vorrq_s8(v393, v387);
    v389 = vorr_s8(*(int8x8_t *)v394.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v394, v394, 8uLL));
    if (v388 == v30)
      goto LABEL_334;
  }
  else
  {
    v388 = 0;
    v389 = 0;
  }
  v395 = v30 - v388;
  v396 = (uint64_t *)(a2 + 8 * v388 + 72);
  do
  {
    v397 = *v396++;
    *(_QWORD *)&v389 |= v397;
    --v395;
  }
  while (v395);
LABEL_334:
  if (v389)
    v390 = -1;
  else
    v390 = 0;
LABEL_337:
  result = bn_sub_words((unint64_t *)&v762, *(const unint64_t **)(a1 + 320), v39, v28);
  v399 = *(unsigned int *)(a1 + 328);
  v400 = (int)v399;
  if ((int)v399 < 1)
    goto LABEL_345;
  if (v399 < 4)
  {
    v401 = 0;
LABEL_343:
    v406 = v399 - v401;
    v407 = (_QWORD *)&v762 + v401;
    do
    {
      *v407++ &= v390;
      --v406;
    }
    while (v406);
    goto LABEL_345;
  }
  v401 = v399 & 0x7FFFFFFC;
  v402 = (int8x16_t)vdupq_n_s64(v390);
  v403 = (int8x16_t *)&v763;
  v404 = v399 & 0xFFFFFFFC;
  do
  {
    v405 = vandq_s8(*v403, v402);
    v403[-1] = vandq_s8(v403[-1], v402);
    *v403 = v405;
    v403 += 2;
    v404 -= 4;
  }
  while (v404);
  if (v401 != v399)
    goto LABEL_343;
LABEL_345:
  if ((_DWORD)v400)
  {
    v408 = 0;
    v409 = -(v27 & 1);
    v410 = (v27 & 1) - 1;
    if (v400 < 4)
      goto LABEL_350;
    v408 = v400 & 0xFFFFFFFFFFFFFFFCLL;
    v411 = (int8x16_t)vdupq_n_s64(v409);
    v412 = (int8x16_t)vdupq_n_s64(v410);
    v413 = (int8x16_t *)&v763;
    v414 = (int8x16_t *)(a2 + 88);
    v415 = v400 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v416 = vorrq_s8(vandq_s8(*v414, v412), vandq_s8(*v413, v411));
      v414[-1] = vorrq_s8(vandq_s8(v414[-1], v412), vandq_s8(v413[-1], v411));
      *v414 = v416;
      v413 += 2;
      v414 += 2;
      v415 -= 4;
    }
    while (v415);
    if (v408 != v400)
    {
LABEL_350:
      v417 = v400 - v408;
      v418 = 8 * v408;
      v419 = (unint64_t *)(8 * v408 + a2 + 72);
      v420 = (uint64_t *)((char *)&v762 + v418);
      do
      {
        v421 = *v420++;
        *v419 = *v419 & v410 | v421 & v409;
        ++v419;
        --v417;
      }
      while (v417);
    }
  }
  return result;
}

uint64_t ec_GFp_mont_init_precomp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  __int128 *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  int v19;
  unint64_t v20;
  _BOOL4 v21;
  _BOOL4 v22;
  _BOOL4 v23;
  _BOOL4 v24;
  _BOOL4 v25;
  _BOOL4 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  int v30;
  __int128 v31;
  unsigned int v32;
  __int128 v33;
  __int128 v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t (*v41)(uint64_t, uint64_t, __int128 *, uint64_t);
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  unint64_t v58[27];
  unint64_t v59[27];
  unint64_t v60[27];
  unint64_t v61[27];
  unint64_t v62[27];
  unint64_t v63[27];
  unint64_t v64[27];
  unint64_t v65[27];
  unint64_t v66[27];
  unint64_t v67[27];
  unint64_t v68[27];
  unint64_t v69[27];
  unint64_t v70[27];
  unint64_t v71[27];
  unint64_t v72[27];
  unint64_t v73[27];
  unint64_t v74[27];
  unint64_t v75[27];
  unint64_t v76[27];
  unint64_t v77[27];
  unint64_t v78[27];
  unint64_t v79[27];
  unint64_t v80[27];
  unint64_t v81[27];
  unint64_t v82[27];
  unint64_t v83[27];
  unint64_t v84[27];
  unint64_t v85[27];
  unint64_t v86[27];
  unint64_t v87[30];

  v2 = MEMORY[0x24BDAC7A8](a1, a2);
  v4 = v2;
  v87[28] = *MEMORY[0x24BDAC8D0];
  v5 = *(unsigned int *)(v2 + 328);
  v6 = v5 & ((int)v5 >> 31);
  v7 = 8 * v5 - 8;
  v8 = *(_DWORD *)(v2 + 328);
  v43 = v9;
  while (1)
  {
    v10 = __OFSUB__(v8--, 1);
    if (v8 < 0 != v10)
      break;
    v11 = *(_QWORD *)(v2 + 320);
    v12 = *(_QWORD *)(v11 + v7);
    v7 -= 8;
    if (v12)
    {
      v6 = v8 + 1;
      goto LABEL_8;
    }
  }
  if ((v5 & 0x80000000) == 0)
  {
    v13 = v3[11];
    v54 = v3[10];
    v55 = v13;
    v56 = v3[12];
    v57 = *((_QWORD *)v3 + 26);
    v14 = v3[7];
    v50 = v3[6];
    v51 = v14;
    v15 = v3[9];
    v52 = v3[8];
    v53 = v15;
    v16 = v3[3];
    v46 = v3[2];
    v47 = v16;
    v17 = v3[5];
    v48 = v3[4];
    v49 = v17;
    v18 = v3[1];
    v44 = *v3;
    v45 = v18;
    goto LABEL_30;
  }
  v11 = *(_QWORD *)(v2 + 320);
LABEL_8:
  v19 = v6 - 1;
  v20 = *(_QWORD *)(v11 + 8 * v19);
  v21 = v20 != 0;
  v22 = HIDWORD(v20) != 0;
  if (HIDWORD(v20))
    v20 >>= 32;
  v23 = v20 >> 16 != 0;
  if (v20 >> 16)
    v20 >>= 16;
  v24 = v20 > 0xFF;
  if (v20 > 0xFF)
    v20 >>= 8;
  v25 = v20 > 0xF;
  if (v20 > 0xF)
    v20 >>= 4;
  v26 = v20 > 3;
  if (v20 > 3)
    v20 >>= 2;
  v27 = v3[11];
  v54 = v3[10];
  v55 = v27;
  v56 = v3[12];
  v57 = *((_QWORD *)v3 + 26);
  v28 = v3[7];
  v50 = v3[6];
  v51 = v28;
  v29 = v3[9];
  v52 = v3[8];
  v53 = v29;
  v30 = v21 | (v19 << 6) | (32 * v22) | (16 * v23) | (8 * v24) | (4 * v25) | (2 * v26);
  v31 = v3[3];
  if (v20 > 1)
    ++v30;
  v32 = v30 + 4;
  v46 = v3[2];
  v47 = v31;
  v33 = v3[5];
  v48 = v3[4];
  v49 = v33;
  v34 = v3[1];
  v44 = *v3;
  v45 = v34;
  if (v32 < 0xA)
  {
LABEL_30:
    ec_GFp_mont_dbl(v2, v58, (unint64_t *)&v44);
    ec_GFp_mont_add(v4, v59, v58, (unint64_t *)&v44);
    ec_GFp_mont_dbl(v4, v60, v58);
    ec_GFp_mont_add(v4, v61, v60, (unint64_t *)&v44);
    ec_GFp_mont_add(v4, v62, v60, v58);
    ec_GFp_mont_add(v4, v63, v60, v59);
    ec_GFp_mont_dbl(v4, v64, v60);
    ec_GFp_mont_add(v4, v65, v64, (unint64_t *)&v44);
    ec_GFp_mont_add(v4, v66, v64, v58);
    ec_GFp_mont_add(v4, v67, v64, v59);
    ec_GFp_mont_add(v4, v68, v64, v60);
    ec_GFp_mont_add(v4, v69, v64, v61);
    ec_GFp_mont_add(v4, v70, v64, v62);
    ec_GFp_mont_add(v4, v71, v64, v63);
    ec_GFp_mont_dbl(v4, v72, v64);
    ec_GFp_mont_add(v4, v73, v72, (unint64_t *)&v44);
    ec_GFp_mont_add(v4, v74, v72, v58);
    ec_GFp_mont_add(v4, v75, v72, v59);
    ec_GFp_mont_add(v4, v76, v72, v60);
    ec_GFp_mont_add(v4, v77, v72, v61);
    ec_GFp_mont_add(v4, v78, v72, v62);
    ec_GFp_mont_add(v4, v79, v72, v63);
    v40 = v4;
    goto LABEL_31;
  }
  v35 = v32 / 5;
  ec_GFp_mont_dbl(v2, v58, (unint64_t *)&v44);
  v36 = v35 - 1;
  v37 = v36;
  do
  {
    ec_GFp_mont_dbl(v4, v58, v58);
    --v37;
  }
  while (v37);
  ec_GFp_mont_add(v4, v59, v58, (unint64_t *)&v44);
  ec_GFp_mont_dbl(v4, v60, v58);
  v38 = v36;
  do
  {
    ec_GFp_mont_dbl(v4, v60, v60);
    --v38;
  }
  while (v38);
  ec_GFp_mont_add(v4, v61, v60, (unint64_t *)&v44);
  ec_GFp_mont_add(v4, v62, v60, v58);
  ec_GFp_mont_add(v4, v63, v60, v59);
  ec_GFp_mont_dbl(v4, v64, v60);
  v39 = v36;
  do
  {
    ec_GFp_mont_dbl(v4, v64, v64);
    --v39;
  }
  while (v39);
  ec_GFp_mont_add(v4, v65, v64, (unint64_t *)&v44);
  ec_GFp_mont_add(v4, v66, v64, v58);
  ec_GFp_mont_add(v4, v67, v64, v59);
  ec_GFp_mont_add(v4, v68, v64, v60);
  ec_GFp_mont_add(v4, v69, v64, v61);
  ec_GFp_mont_add(v4, v70, v64, v62);
  ec_GFp_mont_add(v4, v71, v64, v63);
  ec_GFp_mont_dbl(v4, v72, v64);
  do
  {
    ec_GFp_mont_dbl(v4, v72, v72);
    --v36;
  }
  while (v36);
  ec_GFp_mont_add(v4, v73, v72, (unint64_t *)&v44);
  ec_GFp_mont_add(v4, v74, v72, v58);
  ec_GFp_mont_add(v4, v75, v72, v59);
  ec_GFp_mont_add(v4, v76, v72, v60);
  ec_GFp_mont_add(v4, v77, v72, v61);
  ec_GFp_mont_add(v4, v78, v72, v62);
  ec_GFp_mont_add(v4, v79, v72, v63);
  v40 = v4;
LABEL_31:
  ec_GFp_mont_add(v40, v80, v72, v64);
  ec_GFp_mont_add(v4, v81, v72, v65);
  ec_GFp_mont_add(v4, v82, v72, v66);
  ec_GFp_mont_add(v4, v83, v72, v67);
  ec_GFp_mont_add(v4, v84, v72, v68);
  ec_GFp_mont_add(v4, v85, v72, v69);
  ec_GFp_mont_add(v4, v86, v72, v70);
  ec_GFp_mont_add(v4, v87, v72, v71);
  v41 = *(uint64_t (**)(uint64_t, uint64_t, __int128 *, uint64_t))(*(_QWORD *)v4 + 8);
  if (v41)
    return v41(v4, v43, &v44, 31);
  ERR_put_error(15, 0, 66, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/ec/ec.c", 607);
  return 0;
}

int8x16_t *ec_GFp_mont_mul_precomp(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, uint64_t a6, int8x16_t *a7, uint64_t a8)
{
  int8x16_t *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unint64_t v24;
  _BOOL4 v25;
  _BOOL4 v26;
  _BOOL4 v27;
  _BOOL4 v28;
  _BOOL4 v29;
  _BOOL4 v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  _OWORD v47[5];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v15 = result;
  v16 = result[20].u32[2];
  v17 = v16 & ((int)v16 >> 31);
  v18 = 8 * v16 - 8;
  v19 = result[20].i32[2];
  while (1)
  {
    v20 = __OFSUB__(v19--, 1);
    if (v19 < 0 != v20)
      break;
    v21 = result[20].i64[0];
    v22 = *(_QWORD *)(v21 + v18);
    v18 -= 8;
    if (v22)
    {
      v17 = v19 + 1;
      goto LABEL_7;
    }
  }
  if ((v16 & 0x80000000) == 0)
    goto LABEL_20;
  v21 = result[20].i64[0];
LABEL_7:
  v23 = v17 - 1;
  v24 = *(_QWORD *)(v21 + 8 * v23);
  v25 = v24 != 0;
  v26 = HIDWORD(v24) != 0;
  if (HIDWORD(v24))
    v24 >>= 32;
  v27 = v24 >> 16 != 0;
  if (v24 >> 16)
    v24 >>= 16;
  v28 = v24 > 0xFF;
  if (v24 > 0xFF)
    v24 >>= 8;
  v29 = v24 > 0xF;
  if (v24 > 0xF)
    v24 >>= 4;
  v30 = v24 > 3;
  if (v24 > 3)
    v24 >>= 2;
  v31 = v25 | (v23 << 6) | (32 * v26) | (16 * v27) | (8 * v28) | (4 * v29) | (2 * v30);
  if (v24 > 1)
    ++v31;
  v32 = v31 + 4;
  if ((v31 + 4) < 5)
  {
LABEL_20:
    *(_QWORD *)(a2 + 64) = 0;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 88) = 0u;
    *(_OWORD *)(a2 + 104) = 0u;
    *(_OWORD *)(a2 + 120) = 0u;
    *(_QWORD *)(a2 + 136) = 0;
    *(_OWORD *)(a2 + 144) = 0u;
    *(_OWORD *)(a2 + 160) = 0u;
    *(_OWORD *)(a2 + 176) = 0u;
    *(_OWORD *)(a2 + 192) = 0u;
    *(_QWORD *)(a2 + 208) = 0;
    return result;
  }
  v52 = 0;
  v50 = 0u;
  v51 = 0u;
  v33 = v32 / 5;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  memset(v47, 0, sizeof(v47));
  v44 = 0u;
  v45 = 0u;
  v43 = 0u;
  v42 = v32 / 5 - 1;
  result = ec_GFp_mont_get_comb_window(result, (unint64_t)&v43, a3, a4, v42);
  v34 = v46;
  *(_OWORD *)(a2 + 32) = v45;
  *(_OWORD *)(a2 + 48) = v34;
  *(_QWORD *)(a2 + 64) = *(_QWORD *)&v47[0];
  v35 = v44;
  *(_OWORD *)a2 = v43;
  *(_OWORD *)(a2 + 16) = v35;
  *(_OWORD *)(a2 + 88) = *(_OWORD *)((char *)&v47[1] + 8);
  *(_OWORD *)(a2 + 104) = *(_OWORD *)((char *)&v47[2] + 8);
  *(_OWORD *)(a2 + 120) = *(_OWORD *)((char *)&v47[3] + 8);
  *(_QWORD *)(a2 + 136) = *((_QWORD *)&v47[4] + 1);
  *(_OWORD *)(a2 + 72) = *(_OWORD *)((char *)v47 + 8);
  *(_QWORD *)(a2 + 208) = v52;
  v36 = v51;
  *(_OWORD *)(a2 + 176) = v50;
  *(_OWORD *)(a2 + 192) = v36;
  v37 = v49;
  *(_OWORD *)(a2 + 144) = v48;
  *(_OWORD *)(a2 + 160) = v37;
  if (a5)
  {
    ec_GFp_mont_get_comb_window(v15, (unint64_t)&v43, a5, a6, v42);
    result = (int8x16_t *)ec_GFp_mont_add((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2, (unint64_t *)&v43);
    if (a7)
    {
      ec_GFp_mont_get_comb_window(v15, (unint64_t)&v43, a7, a8, v42);
      result = (int8x16_t *)ec_GFp_mont_add((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2, (unint64_t *)&v43);
      if (v32 >= 0xA)
      {
        v38 = v33 - 2;
        do
        {
          ec_GFp_mont_dbl((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2);
          v52 = 0;
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v46 = 0u;
          memset(v47, 0, sizeof(v47));
          v44 = 0u;
          v45 = 0u;
          v43 = 0u;
          ec_GFp_mont_get_comb_window(v15, (unint64_t)&v43, a3, a4, v38);
          ec_GFp_mont_add((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2, (unint64_t *)&v43);
          ec_GFp_mont_get_comb_window(v15, (unint64_t)&v43, a5, a6, v38);
          ec_GFp_mont_add((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2, (unint64_t *)&v43);
          ec_GFp_mont_get_comb_window(v15, (unint64_t)&v43, a7, a8, v38);
          result = (int8x16_t *)ec_GFp_mont_add((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2, (unint64_t *)&v43);
          --v38;
        }
        while (v38 < v33);
      }
    }
    else if (v32 >= 0xA)
    {
      v40 = v33 - 2;
      do
      {
        ec_GFp_mont_dbl((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2);
        v52 = 0;
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        v46 = 0u;
        memset(v47, 0, sizeof(v47));
        v44 = 0u;
        v45 = 0u;
        v43 = 0u;
        ec_GFp_mont_get_comb_window(v15, (unint64_t)&v43, a3, a4, v40);
        ec_GFp_mont_add((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2, (unint64_t *)&v43);
        ec_GFp_mont_get_comb_window(v15, (unint64_t)&v43, a5, a6, v40);
        result = (int8x16_t *)ec_GFp_mont_add((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2, (unint64_t *)&v43);
        --v40;
      }
      while (v40 < v33);
    }
  }
  else if (a7)
  {
    ec_GFp_mont_get_comb_window(v15, (unint64_t)&v43, a7, a8, v42);
    result = (int8x16_t *)ec_GFp_mont_add((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2, (unint64_t *)&v43);
    if (v32 >= 0xA)
    {
      v39 = v33 - 2;
      do
      {
        ec_GFp_mont_dbl((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2);
        v52 = 0;
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        v46 = 0u;
        memset(v47, 0, sizeof(v47));
        v44 = 0u;
        v45 = 0u;
        v43 = 0u;
        ec_GFp_mont_get_comb_window(v15, (unint64_t)&v43, a3, a4, v39);
        ec_GFp_mont_add((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2, (unint64_t *)&v43);
        ec_GFp_mont_get_comb_window(v15, (unint64_t)&v43, a7, a8, v39);
        result = (int8x16_t *)ec_GFp_mont_add((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2, (unint64_t *)&v43);
        --v39;
      }
      while (v39 < v33);
    }
  }
  else if (v32 >= 0xA)
  {
    v41 = v33 - 2;
    do
    {
      ec_GFp_mont_dbl((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2);
      v52 = 0;
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      memset(v47, 0, sizeof(v47));
      v44 = 0u;
      v45 = 0u;
      v43 = 0u;
      ec_GFp_mont_get_comb_window(v15, (unint64_t)&v43, a3, a4, v41);
      result = (int8x16_t *)ec_GFp_mont_add((uint64_t)v15, (unint64_t *)a2, (unint64_t *)a2, (unint64_t *)&v43);
      --v41;
    }
    while (v41 < v33);
  }
  return result;
}

int8x16_t *ec_GFp_mont_get_comb_window(int8x16_t *result, unint64_t a2, int8x16_t *a3, uint64_t a4, unsigned int a5)
{
  unint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  int v29;
  unint64_t v30;
  _BOOL4 v31;
  _BOOL4 v32;
  _BOOL4 v33;
  _BOOL4 v34;
  _BOOL4 v35;
  _BOOL4 v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  int8x16_t *v45;
  int8x16_t *v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t *v53;
  uint64_t *v54;
  uint64_t v55;
  unint64_t i;
  int8x16_t *v57;
  int8x16_t v58;
  int8x16_t v59;
  unint64_t v60;
  int8x16_t *v61;
  int8x16_t *v62;
  int8x16_t v63;
  uint64_t v64;
  int8x16_t v65;
  int8x16_t v66;
  unint64_t v67;
  unint64_t v68;
  int8x16_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  unint64_t *v76;
  uint64_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t *v80;
  int8x16_t *v81;
  unint64_t v82;
  int8x16_t v83;

  v5 = result[16].i32[2];
  v6 = result[20].u32[2];
  v7 = v6 & ((int)v6 >> 31);
  v8 = 8 * v6 - 8;
  v9 = result[20].i32[2];
  while (1)
  {
    v10 = __OFSUB__(v9--, 1);
    if (v9 < 0 != v10)
      break;
    v11 = result[20].i64[0];
    v12 = *(_QWORD *)(v11 + v8);
    v8 -= 8;
    if (v12)
    {
      v7 = v9 + 1;
      goto LABEL_13;
    }
  }
  if ((v6 & 0x80000000) != 0)
  {
    v11 = result[20].i64[0];
LABEL_13:
    v29 = v7 - 1;
    v30 = *(_QWORD *)(v11 + 8 * v29);
    v31 = v30 != 0;
    v32 = HIDWORD(v30) != 0;
    if (HIDWORD(v30))
      v30 >>= 32;
    v33 = v30 >> 16 != 0;
    if (v30 >> 16)
      v30 >>= 16;
    v34 = v30 > 0xFF;
    if (v30 > 0xFF)
      v30 >>= 8;
    v35 = v30 > 0xF;
    if (v30 > 0xF)
      v30 >>= 4;
    v36 = v30 > 3;
    if (v30 > 3)
      v30 >>= 2;
    v37 = v31 | (v29 << 6) | (32 * v32) | (16 * v33) | (8 * v34) | (4 * v35) | (2 * v36);
    if (v30 > 1)
      ++v37;
    v13 = (v37 + 4) / 5uLL;
    v14 = a5;
    v15 = (unint64_t)a5 >> 6;
    if (v15 >= v5)
    {
LABEL_7:
      LODWORD(v16) = 0;
      v17 = v13 + v14;
      v18 = (v13 + v14) >> 6;
      if (v18 >= v5)
        goto LABEL_8;
      goto LABEL_27;
    }
  }
  else
  {
    v13 = 0;
    v14 = a5;
    v15 = (unint64_t)a5 >> 6;
    if (v15 >= v5)
      goto LABEL_7;
  }
  v16 = (*(_QWORD *)(a4 + 8 * v15) >> v14) & 1;
  v17 = v13 + v14;
  v18 = (v13 + v14) >> 6;
  if (v18 >= v5)
  {
LABEL_8:
    v19 = 0;
    v20 = v14 + 2 * v13;
    v21 = v20 >> 6;
    if (v20 >> 6 >= v5)
      goto LABEL_9;
    goto LABEL_28;
  }
LABEL_27:
  v19 = 2 * ((*(_QWORD *)(a4 + 8 * v18) >> v17) & 1);
  v20 = v14 + 2 * v13;
  v21 = v20 >> 6;
  if (v20 >> 6 >= v5)
  {
LABEL_9:
    v22 = 0;
    v23 = 3 * v13 + v14;
    v24 = v23 >> 6;
    if (v23 >> 6 >= v5)
      goto LABEL_10;
    goto LABEL_29;
  }
LABEL_28:
  v22 = 4 * ((*(_QWORD *)(a4 + 8 * v21) >> v20) & 1);
  v23 = 3 * v13 + v14;
  v24 = v23 >> 6;
  if (v23 >> 6 >= v5)
  {
LABEL_10:
    v25 = 0;
    v26 = v14 + 4 * v13;
    v27 = v26 >> 6;
    if (v26 >> 6 >= v5)
    {
LABEL_11:
      v28 = 0;
      goto LABEL_31;
    }
    goto LABEL_30;
  }
LABEL_29:
  v25 = 8 * ((*(_QWORD *)(a4 + 8 * v24) >> v23) & 1);
  v26 = v14 + 4 * v13;
  v27 = v26 >> 6;
  if (v26 >> 6 >= v5)
    goto LABEL_11;
LABEL_30:
  v28 = 16 * ((*(_QWORD *)(a4 + 8 * v27) >> v26) & 1);
LABEL_31:
  *(_QWORD *)(a2 + 208) = 0;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  v38 = result[20].i32[2];
  if (!(_DWORD)v38)
    return result;
  v39 = 0;
  v40 = v19 | v16 | v22 | v25 | v28;
  v41 = a2 + 72;
  v42 = v38;
  v43 = 8 * v38 + 72;
  v44 = v38 & 0xFFFFFFFFFFFFFFFCLL;
  v45 = a3 + 1;
  v46 = a3;
  do
  {
    v47 = v39 + 1;
    v48 = ((v40 ^ ((_DWORD)v39 + 1)) - 1) >> 63;
    v49 = ~v48;
    if (v38 < 4
      || (unint64_t)&a3[9 * v39] + 8 * v38 > a2 && (unint64_t)&a3[9 * v39] < a2 + 8 * v38)
    {
      v50 = 0;
LABEL_38:
      v51 = v38 - v50;
      v52 = v50;
      v53 = (unint64_t *)(a2 + 8 * v50);
      v54 = &v46->i64[v52];
      do
      {
        v55 = *v54++;
        *v53 = *v53 & v49 | v55 & v48;
        ++v53;
        --v51;
      }
      while (v51);
      goto LABEL_40;
    }
    v58 = (int8x16_t)vdupq_n_s64(v48);
    v59 = (int8x16_t)vdupq_n_s64(v49);
    v60 = v38 & 0xFFFFFFFFFFFFFFFCLL;
    v61 = (int8x16_t *)(a2 + 16);
    v62 = v45;
    do
    {
      v63 = vorrq_s8(vandq_s8(*v61, v59), vandq_s8(*v62, v58));
      v61[-1] = vorrq_s8(vandq_s8(v61[-1], v59), vandq_s8(v62[-1], v58));
      *v61 = v63;
      v62 += 2;
      v61 += 2;
      v60 -= 4;
    }
    while (v60);
    v50 = v38 & 0xFFFFFFFFFFFFFFFCLL;
    if (v44 != v38)
      goto LABEL_38;
LABEL_40:
    if (v38 < 4)
    {
      i = 0;
      goto LABEL_52;
    }
    v57 = &a3[9 * v39];
    if (v41 < (unint64_t)v57->u64 + v43 && (unint64_t)&v57[4].u64[1] < a2 + v43)
    {
      for (i = 0; i != v38; ++i)
LABEL_52:
        *(_QWORD *)(v41 + 8 * i) = *(_QWORD *)(v41 + 8 * i) & v49 | v46[4].i64[i + 1] & v48;
      goto LABEL_33;
    }
    v64 = 0;
    v65 = (int8x16_t)vdupq_n_s64(v48);
    v66 = (int8x16_t)vdupq_n_s64(v49);
    v67 = v38 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v68 = a2 + v64 * 16;
      v69 = vorrq_s8(vandq_s8(*(int8x16_t *)(a2 + v64 * 16 + 88), v66), vandq_s8(*(int8x16_t *)((char *)&v46[v64 + 5] + 8), v65));
      *(int8x16_t *)(v68 + 72) = vorrq_s8(vandq_s8(*(int8x16_t *)(a2 + v64 * 16 + 72), v66), vandq_s8(*(int8x16_t *)((char *)&v46[v64 + 4] + 8), v65));
      *(int8x16_t *)(v68 + 88) = v69;
      v64 += 2;
      v67 -= 4;
    }
    while (v67);
    i = v38 & 0xFFFFFFFFFFFFFFFCLL;
    if (v44 != v38)
      goto LABEL_52;
LABEL_33:
    v45 += 9;
    v46 += 9;
    v39 = v47;
  }
  while (v47 != 31);
  v70 = (v40 - 1) >> 63;
  v71 = ~v70;
  if (v38 < 6
    || a2 + 144 < (unint64_t)&result[10].u64[v42] && (unint64_t)&result[10] < v42 * 8 + a2 + 144)
  {
    v72 = 0;
    goto LABEL_58;
  }
  v78 = (int8x16_t)vdupq_n_s64(v70);
  v72 = v38 & 0xFFFFFFFFFFFFFFFCLL;
  v79 = (int8x16_t)vdupq_n_s64(v71);
  v80 = (int8x16_t *)(a2 + 160);
  v81 = result + 11;
  v82 = v38 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v83 = vorrq_s8(vandq_s8(*v81, v79), vandq_s8(*v80, v78));
    v80[-1] = vorrq_s8(vandq_s8(v81[-1], v79), vandq_s8(v80[-1], v78));
    *v80 = v83;
    v80 += 2;
    v81 += 2;
    v82 -= 4;
  }
  while (v82);
  if (v72 != v38)
  {
LABEL_58:
    v73 = v38 - v72;
    v74 = 8 * v72;
    v75 = &result[10].i64[v72];
    v76 = (unint64_t *)(v74 + a2 + 144);
    do
    {
      v77 = *v75++;
      *v76 = v77 & v71 | *v76 & v70;
      ++v76;
      --v73;
    }
    while (v73);
  }
  return result;
}

uint64_t SIPHASH_24(_QWORD *a1, uint64_t *a2, unint64_t a3)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v65;

  v3 = a3;
  v4 = a1[1];
  v5 = *a1 ^ 0x736F6D6570736575;
  v6 = v4 ^ 0x646F72616E646F6DLL;
  v7 = *a1 ^ 0x6C7967656E657261;
  v8 = v4 ^ 0x7465646279746573;
  if (a3 < 8)
  {
    v65 = 0;
    if (!a3)
      goto LABEL_5;
    goto LABEL_4;
  }
  do
  {
    v9 = *a2++;
    v10 = (v6 + v5) ^ __ROR8__(v6, 51);
    v11 = (v9 ^ v8) + v7;
    v12 = v11 ^ __ROR8__(v9 ^ v8, 48);
    v13 = v11 + v10;
    v14 = v12 + __ROR8__(v6 + v5, 32);
    v15 = v13 ^ __ROR8__(v10, 47);
    v16 = v14 ^ __ROR8__(v12, 43);
    v17 = v14 + v15;
    v18 = v16 + __ROR8__(v13, 32);
    v19 = v17 ^ __ROR8__(v15, 51);
    v20 = v18 ^ __ROR8__(v16, 48);
    v21 = v18 + v19;
    v22 = v20 + __ROR8__(v17, 32);
    v6 = v21 ^ __ROR8__(v19, 47);
    v8 = v22 ^ __ROR8__(v20, 43);
    v7 = __ROR8__(v21, 32);
    v5 = v22 ^ v9;
    a3 -= 8;
  }
  while (a3 > 7);
  v65 = 0;
  if (a3)
LABEL_4:
    __memcpy_chk();
LABEL_5:
  HIBYTE(v65) = v3;
  v23 = (v65 ^ v8) + v7;
  v24 = (v5 + v6) ^ __ROR8__(v6, 51);
  v25 = v23 ^ __ROR8__(v65 ^ v8, 48);
  v26 = v23 + v24;
  v27 = v25 + __ROR8__(v5 + v6, 32);
  v28 = v26 ^ __ROR8__(v24, 47);
  v29 = v27 ^ __ROR8__(v25, 43);
  v30 = v27 + v28;
  v31 = v29 + __ROR8__(v26, 32);
  v32 = v30 ^ __ROR8__(v28, 51);
  v33 = v31 ^ __ROR8__(v29, 48);
  v34 = v31 + v32;
  v35 = v33 + __ROR8__(v30, 32);
  v36 = v34 ^ __ROR8__(v32, 47);
  v37 = v35 ^ __ROR8__(v33, 43);
  v38 = (v35 ^ v65) + v36;
  v39 = (__ROR8__(v34, 32) ^ 0xFFLL) + v37;
  v40 = v38 ^ __ROR8__(v36, 51);
  v41 = v39 ^ __ROR8__(v37, 48);
  v42 = v40 + v39;
  v43 = v41 + __ROR8__(v38, 32);
  v44 = v42 ^ __ROR8__(v40, 47);
  v45 = v43 ^ __ROR8__(v41, 43);
  v46 = v44 + v43;
  v47 = __ROR8__(v42, 32) + v45;
  v48 = v46 ^ __ROR8__(v44, 51);
  v49 = v47 ^ __ROR8__(v45, 48);
  v50 = v48 + v47;
  v51 = v49 + __ROR8__(v46, 32);
  v52 = v50 ^ __ROR8__(v48, 47);
  v53 = v51 ^ __ROR8__(v49, 43);
  v54 = v52 + v51;
  v55 = __ROR8__(v50, 32) + v53;
  v56 = v54 ^ __ROR8__(v52, 51);
  v57 = v55 ^ __ROR8__(v53, 48);
  v58 = v56 + v55;
  v59 = v57 + __ROR8__(v54, 32);
  v60 = v58 ^ __ROR8__(v56, 47);
  v61 = v59 ^ __ROR8__(v57, 43);
  v62 = __ROR8__(v58, 32) + v61;
  v63 = (v60 + v59) ^ __ROR8__(v60, 51);
  return __ROR8__(v62 ^ __ROR8__(v61, 48), 43) ^ __ROR8__(v63, 47) ^ __ROR8__(v63 + v62, 32) ^ (v63 + v62);
}

BIGNUM *__cdecl BN_mod_sqrt(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
{
  uint64_t top;
  unint64_t *d;
  unint64_t v9;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t *v16;
  unint64_t v17;
  int8x16_t v18;
  uint64_t v19;
  unint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  int8x8_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t *v32;
  unint64_t v33;
  int8x16_t v34;
  uint64_t v35;
  unint64_t *v36;
  uint64_t v37;
  const char *v38;
  int v39;
  int v40;
  int v41;
  BIGNUM *v42;
  _QWORD *v44;
  int flags;
  unint64_t *v46;
  unint64_t *v47;
  uint64_t v48;
  size_t v49;
  int8x16_t *v50;
  int8x16_t v51;
  unint64_t v52;
  int8x16_t v53;
  int8x16_t v54;
  uint64_t v55;
  unint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int *p_neg;
  uint64_t v61;
  size_t v62;
  int *v63;
  unint64_t v64;
  int8x16_t v65;
  unsigned __int128 v66;
  int8x16_t *v67;
  unint64_t v68;
  int8x16_t v69;
  uint64_t v70;
  unint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  BOOL v76;
  _QWORD *v77;
  BIGNUM *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t *v81;
  unint64_t v82;
  uint64_t v83;
  BIGNUM *v84;
  BIGNUM *v85;
  BIGNUM *v86;
  BIGNUM *v87;
  BIGNUM *v88;
  BIGNUM *v89;
  BIGNUM *v90;
  unint64_t v91;
  int v92;
  int v93;
  unint64_t v94;
  int v95;
  int v96;
  unint64_t v97;
  int (__cdecl *v98)(BIGNUM *, const BIGNUM *, const BIGNUM *);
  int8x16_t *v99;
  unint64_t v100;
  int8x8_t v101;
  int8x16_t *v102;
  int8x16_t v103;
  unint64_t v104;
  int8x16_t v105;
  int8x16_t v106;
  unint64_t v107;
  uint64_t *v108;
  uint64_t v109;
  int v110;
  unint64_t v111;
  int8x16_t v112;
  unsigned __int128 v113;
  int8x16_t *v114;
  unint64_t v115;
  int8x16_t v116;
  uint64_t v117;
  unint64_t *v118;
  uint64_t v119;
  int v120;
  unint64_t *v121;
  unint64_t *v122;
  uint64_t v123;
  size_t v124;
  int *v125;
  uint64_t v126;
  size_t v127;
  uint64_t v128;
  uint64_t v129;
  BIGNUM *v130;
  uint64_t v131;
  int8x16_t *v132;
  unint64_t v133;
  int8x8_t v134;
  int8x16_t *v135;
  int8x16_t v136;
  unint64_t v137;
  int8x16_t v138;
  int8x16_t v139;
  uint64_t v140;
  uint64_t *v141;
  uint64_t v142;
  uint64_t v143;
  int8x16_t *v144;
  unint64_t v145;
  int8x8_t v146;
  uint64_t v147;
  int8x16_t *v148;
  unint64_t v149;
  int8x8_t v150;
  int8x16_t *v151;
  int8x16_t v152;
  unint64_t v153;
  int8x16_t v154;
  int8x16_t v155;
  uint64_t v156;
  uint64_t *v157;
  uint64_t v158;
  int8x16_t *v159;
  int8x16_t v160;
  unint64_t v161;
  int8x16_t v162;
  int8x16_t v163;
  uint64_t v164;
  uint64_t *v165;
  uint64_t v166;
  int v167;
  int v168;
  BIGNUM *m;
  BIGNUM *aa;
  BIGNUM *p;
  BIGNUM *r;

  top = n->top;
  if ((int)top < 1)
    goto LABEL_15;
  d = n->d;
  v9 = *n->d;
  if ((v9 & 1) == 0)
    goto LABEL_17;
  v11 = v9 ^ 1;
  if (top < 2)
    goto LABEL_11;
  if (top < 5)
  {
    v12 = 1;
LABEL_9:
    v19 = top - v12;
    v20 = &d[v12];
    do
    {
      v21 = *v20++;
      v11 |= v21;
      --v19;
    }
    while (v19);
    goto LABEL_11;
  }
  v13 = (top - 1) & 0xFFFFFFFFFFFFFFFCLL;
  v12 = v13 | 1;
  v14 = 0uLL;
  v15 = (int8x16_t)(unint64_t)v11;
  v16 = (int8x16_t *)(d + 3);
  v17 = v13;
  do
  {
    v15 = vorrq_s8(v16[-1], v15);
    v14 = vorrq_s8(*v16, v14);
    v16 += 2;
    v17 -= 4;
  }
  while (v17);
  v18 = vorrq_s8(v14, v15);
  v11 = (uint64_t)vorr_s8(*(int8x8_t *)v18.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL));
  if (top - 1 != v13)
    goto LABEL_9;
LABEL_11:
  if (!v11)
  {
LABEL_15:
    if (!(_DWORD)top)
    {
LABEL_26:
      v38 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src"
            "/crypto/fipsmodule/bn/sqrt.c";
      v39 = 3;
      v40 = 114;
      v41 = 88;
LABEL_27:
      ERR_put_error(v39, 0, v40, v38, v41);
      return 0;
    }
    d = n->d;
    v9 = *n->d;
LABEL_17:
    v27 = v9 ^ 2;
    if ((int)top < 2)
      goto LABEL_25;
    if (top >= 5)
    {
      v29 = (top - 1) & 0xFFFFFFFFFFFFFFFCLL;
      v28 = v29 | 1;
      v30 = 0uLL;
      v31 = (int8x16_t)(unint64_t)v27;
      v32 = (int8x16_t *)(d + 3);
      v33 = v29;
      do
      {
        v31 = vorrq_s8(v32[-1], v31);
        v30 = vorrq_s8(*v32, v30);
        v32 += 2;
        v33 -= 4;
      }
      while (v33);
      v34 = vorrq_s8(v30, v31);
      v27 = (uint64_t)vorr_s8(*(int8x8_t *)v34.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
      if (top - 1 == v29)
      {
LABEL_25:
        if (v27)
          goto LABEL_26;
        v42 = ret;
        if (ret)
        {
          if (a->top)
          {
LABEL_32:
            if (BN_set_word(v42, *a->d & 1))
              return v42;
LABEL_37:
            if (v42 != ret)
            {
              flags = v42->flags;
              if ((flags & 2) == 0)
              {
                v46 = v42->d;
                if (v42->d)
                {
                  v48 = *(v46 - 1);
                  v47 = v46 - 1;
                  v49 = v48 + 8;
                  if (v48 != -8)
                    bzero(v47, v49);
                  free(v47);
                  flags = v42->flags;
                }
              }
              if ((flags & 1) != 0)
              {
                v61 = *(_QWORD *)&v42[-1].neg;
                p_neg = &v42[-1].neg;
                v62 = v61 + 8;
                if (v61 != -8)
                  bzero(p_neg, v62);
                v63 = p_neg;
LABEL_158:
                free(v63);
                return 0;
              }
              v42->d = 0;
            }
            return 0;
          }
        }
        else
        {
          v44 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
          if (!v44)
          {
LABEL_86:
            v38 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borings"
                  "sl/src/crypto/mem.c";
            v39 = 14;
            v40 = 65;
            v41 = 247;
            goto LABEL_27;
          }
          *v44 = 24;
          v44[1] = 0;
          v42 = (BIGNUM *)(v44 + 1);
          v44[2] = 0;
          v44[3] = 0x100000000;
          if (a->top)
            goto LABEL_32;
        }
        if (BN_set_word(v42, 0))
          return v42;
        goto LABEL_37;
      }
    }
    else
    {
      v28 = 1;
    }
    v35 = top - v28;
    v36 = &d[v28];
    do
    {
      v37 = *v36++;
      v27 |= v37;
      --v35;
    }
    while (v35);
    goto LABEL_25;
  }
  v22 = a->top;
  if (!(_DWORD)v22)
  {
LABEL_76:
    v78 = ret;
    if (ret)
    {
      if (a->neg)
        goto LABEL_78;
      goto LABEL_82;
    }
    v79 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (v79)
    {
      *v79 = 24;
      v79[1] = 0;
      v78 = (BIGNUM *)(v79 + 1);
      v79[2] = 0;
      v79[3] = 0x100000000;
      if (a->neg)
      {
LABEL_78:
        if (BN_set_word(v78, 0))
          return v78;
        goto LABEL_146;
      }
LABEL_82:
      v80 = a->top;
      if (!(_DWORD)v80)
      {
        v82 = 1;
        goto LABEL_145;
      }
      v81 = a->d;
      v82 = *a->d ^ 1;
      if ((int)v80 < 2)
        goto LABEL_145;
      if (v80 >= 5)
      {
        v111 = (v80 - 1) & 0xFFFFFFFFFFFFFFFCLL;
        v83 = v111 | 1;
        v112 = 0uLL;
        v113 = *a->d ^ (unsigned __int128)1uLL;
        v114 = (int8x16_t *)(v81 + 3);
        v115 = v111;
        do
        {
          v113 = (unsigned __int128)vorrq_s8(v114[-1], (int8x16_t)v113);
          v112 = vorrq_s8(*v114, v112);
          v114 += 2;
          v115 -= 4;
        }
        while (v115);
        v116 = vorrq_s8(v112, (int8x16_t)v113);
        v82 = (unint64_t)vorr_s8(*(int8x8_t *)v116.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v116, v116, 8uLL));
        if (v80 - 1 == v111)
        {
LABEL_145:
          if (BN_set_word(v78, v82 == 0))
            return v78;
LABEL_146:
          v42 = 0;
          if (v78 == ret || !v78)
            return v42;
          v120 = v78->flags;
          if ((v120 & 2) == 0)
          {
            v121 = v78->d;
            if (v78->d)
            {
              v123 = *(v121 - 1);
              v122 = v121 - 1;
              v124 = v123 + 8;
              if (v123 != -8)
                bzero(v122, v124);
              free(v122);
              v120 = v78->flags;
            }
          }
          if ((v120 & 1) == 0)
          {
            v42 = 0;
            v78->d = 0;
            return v42;
          }
          v126 = *(_QWORD *)&v78[-1].neg;
          v125 = &v78[-1].neg;
          v127 = v126 + 8;
          if (v126 != -8)
            bzero(v125, v127);
          v63 = v125;
          goto LABEL_158;
        }
      }
      else
      {
        v83 = 1;
      }
      v117 = v80 - v83;
      v118 = &v81[v83];
      do
      {
        v119 = *v118++;
        v82 |= v119;
        --v117;
      }
      while (v117);
      goto LABEL_145;
    }
    goto LABEL_86;
  }
  v23 = a->top;
  v24 = a->d;
  if (v22 < 4)
  {
    v25 = 0;
    v26 = 0;
LABEL_48:
    v55 = v22 - v25;
    v56 = &v24[v25];
    do
    {
      v57 = *v56++;
      *(_QWORD *)&v26 |= v57;
      --v55;
    }
    while (v55);
    goto LABEL_50;
  }
  v25 = v22 & 0xFFFFFFFFFFFFFFFCLL;
  v50 = (int8x16_t *)(v24 + 2);
  v51 = 0uLL;
  v52 = v22 & 0xFFFFFFFFFFFFFFFCLL;
  v53 = 0uLL;
  do
  {
    v51 = vorrq_s8(v50[-1], v51);
    v53 = vorrq_s8(*v50, v53);
    v50 += 2;
    v52 -= 4;
  }
  while (v52);
  v54 = vorrq_s8(v53, v51);
  v26 = vorr_s8(*(int8x8_t *)v54.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL));
  if (v25 != v22)
    goto LABEL_48;
LABEL_50:
  if (!*(_QWORD *)&v26)
    goto LABEL_76;
  if (a->neg)
    goto LABEL_64;
  v58 = *v24 ^ 1;
  if ((int)v22 >= 2)
  {
    if (v22 < 5)
    {
      v59 = 1;
LABEL_61:
      v70 = v23 - v59;
      v71 = &v24[v59];
      do
      {
        v72 = *v71++;
        v58 |= v72;
        --v70;
      }
      while (v70);
      goto LABEL_63;
    }
    v64 = (v23 - 1) & 0xFFFFFFFFFFFFFFFCLL;
    v59 = v64 | 1;
    v65 = 0uLL;
    v66 = *v24 ^ (unsigned __int128)1uLL;
    v67 = (int8x16_t *)(v24 + 3);
    v68 = v64;
    do
    {
      v66 = (unsigned __int128)vorrq_s8(v67[-1], (int8x16_t)v66);
      v65 = vorrq_s8(*v67, v65);
      v67 += 2;
      v68 -= 4;
    }
    while (v68);
    v69 = vorrq_s8(v65, (int8x16_t)v66);
    v58 = (uint64_t)vorr_s8(*(int8x8_t *)v69.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v69, v69, 8uLL));
    if (v23 - 1 != v64)
      goto LABEL_61;
  }
LABEL_63:
  if (!v58)
    goto LABEL_76;
LABEL_64:
  if (!*((_BYTE *)ctx + 40))
  {
    v73 = *((_QWORD *)ctx + 4);
    v74 = *((_QWORD *)ctx + 2);
    if (v74 == *((_QWORD *)ctx + 3))
    {
      if (v74)
        v75 = (3 * v74) >> 1;
      else
        v75 = 32;
      v76 = v75 > v74 && v75 >> 61 == 0;
      if (!v76 || (v77 = OPENSSL_realloc(*((_QWORD **)ctx + 1), 8 * v75)) == 0)
      {
        *((_WORD *)ctx + 20) = 257;
        goto LABEL_91;
      }
      *((_QWORD *)ctx + 1) = v77;
      *((_QWORD *)ctx + 3) = v75;
      v74 = *((_QWORD *)ctx + 2);
    }
    else
    {
      v77 = (_QWORD *)*((_QWORD *)ctx + 1);
    }
    v77[v74] = v73;
    ++*((_QWORD *)ctx + 2);
  }
LABEL_91:
  v84 = BN_CTX_get(ctx);
  v85 = BN_CTX_get(ctx);
  v86 = BN_CTX_get(ctx);
  v87 = BN_CTX_get(ctx);
  v88 = BN_CTX_get(ctx);
  v89 = BN_CTX_get(ctx);
  if (!v89)
    goto LABEL_166;
  v90 = v89;
  r = v85;
  v42 = ret;
  if (!ret)
  {
    v42 = BN_new();
    if (!v42)
      goto LABEL_164;
  }
  if (!BN_nnmod(v84, a, n, ctx))
    goto LABEL_164;
  v91 = 0;
  do
  {
    do
      ++v91;
    while (v91 >> 6 >= n->top);
  }
  while (((n->d[v91 >> 6] >> v91) & 1) == 0);
  if ((_DWORD)v91 == 2)
  {
    if (!bn_mod_add_consttime((uint64_t)v87, (uint64_t)v84, (uint64_t)v84, (uint64_t)n, ctx))
      goto LABEL_164;
    if (!BN_rshift(v86, n, 3))
      goto LABEL_164;
    v86->neg = 0;
    if (!BN_mod_exp_mont(r, v87, v86, n, ctx, 0)
      || !BN_mod_sqr(v90, r, n, ctx)
      || !BN_mod_mul(v87, v87, v90, n, ctx)
      || !BN_sub_word(v87, 1uLL)
      || !BN_mod_mul(v88, v84, r, n, ctx)
      || !BN_mod_mul(v88, v88, v87, n, ctx)
      || !BN_copy(v42, v88))
    {
      goto LABEL_164;
    }
LABEL_104:
    if (!BN_mod_sqr(v88, v42, n, ctx))
      goto LABEL_164;
    if (BN_cmp(v88, v84))
    {
      v92 = 110;
      v93 = 409;
      goto LABEL_163;
    }
    goto LABEL_167;
  }
  if ((_DWORD)v91 == 1)
  {
    if (!BN_rshift(v86, n, 2))
      goto LABEL_164;
    v86->neg = 0;
    if (!BN_add_word(v86, 1uLL) || !BN_mod_exp_mont(v42, v84, v86, n, ctx, 0))
      goto LABEL_164;
    goto LABEL_104;
  }
  if (!BN_copy(v86, n))
    goto LABEL_164;
  aa = v88;
  p = v87;
  m = v84;
  v86->neg = 0;
  v94 = 2;
  while (1)
  {
    if (v94 > 0x15)
    {
      v95 = BN_num_bits(n);
      if (!BN_rand(v90, v95, 0, 0))
        goto LABEL_164;
      v96 = v90->top;
      v97 = v96;
      if ((bn_cmp_words_consttime((uint64_t *)v90->d, v96, (uint64_t *)n->d, n->top) & 0x80000000) == 0)
      {
        v98 = BN_add;
        if (!n->neg)
          v98 = BN_sub;
        if (!((unsigned int (*)(BIGNUM *, BIGNUM *, const BIGNUM *))v98)(v90, v90, n))
          goto LABEL_164;
        v96 = v90->top;
        v97 = v96;
      }
      if (v96)
      {
        v99 = (int8x16_t *)v90->d;
        if (v97 >= 4)
        {
          v100 = v97 & 0xFFFFFFFFFFFFFFFCLL;
          v102 = v99 + 1;
          v103 = 0uLL;
          v104 = v97 & 0xFFFFFFFFFFFFFFFCLL;
          v105 = 0uLL;
          do
          {
            v103 = vorrq_s8(v102[-1], v103);
            v105 = vorrq_s8(*v102, v105);
            v102 += 2;
            v104 -= 4;
          }
          while (v104);
          v106 = vorrq_s8(v105, v103);
          v101 = vorr_s8(*(int8x8_t *)v106.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v106, v106, 8uLL));
          if (v97 == v100)
          {
LABEL_134:
            if (v101)
              goto LABEL_136;
            goto LABEL_135;
          }
        }
        else
        {
          v100 = 0;
          v101 = 0;
        }
        v107 = v97 - v100;
        v108 = &v99->i64[v100];
        do
        {
          v109 = *v108++;
          *(_QWORD *)&v101 |= v109;
          --v107;
        }
        while (v107);
        goto LABEL_134;
      }
    }
LABEL_135:
    if (!BN_set_word(v90, v94))
      goto LABEL_164;
LABEL_136:
    v110 = bn_jacobi(v90, v86, ctx);
    if (v110 < -1)
      goto LABEL_164;
    if (v110 != 1)
      break;
    if (++v94 == 82)
      goto LABEL_162;
  }
  if (v110 != -1)
  {
    if (!v110)
    {
      v92 = 114;
      v93 = 257;
      goto LABEL_163;
    }
LABEL_162:
    v92 = 115;
    v93 = 267;
    goto LABEL_163;
  }
  if (!BN_rshift(v86, v86, v91) || !BN_mod_exp_mont(v90, v90, v86, n, ctx, 0))
    goto LABEL_164;
  if (!BN_is_one(&v90->d))
  {
    v130 = p;
    if (!BN_rshift1(p, v86))
      goto LABEL_164;
    v131 = p->top;
    if (!(_DWORD)v131)
      goto LABEL_187;
    v132 = (int8x16_t *)p->d;
    if (v131 >= 4)
    {
      v133 = v131 & 0xFFFFFFFFFFFFFFFCLL;
      v135 = v132 + 1;
      v136 = 0uLL;
      v137 = v131 & 0xFFFFFFFFFFFFFFFCLL;
      v138 = 0uLL;
      do
      {
        v136 = vorrq_s8(v135[-1], v136);
        v138 = vorrq_s8(*v135, v138);
        v135 += 2;
        v137 -= 4;
      }
      while (v137);
      v139 = vorrq_s8(v138, v136);
      v134 = vorr_s8(*(int8x8_t *)v139.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v139, v139, 8uLL));
      if (v133 == v131)
      {
LABEL_182:
        v130 = p;
        if (v134)
        {
          if (!BN_mod_exp_mont(aa, m, p, n, ctx, 0))
            goto LABEL_164;
          v143 = aa->top;
          if (!(_DWORD)v143)
            goto LABEL_228;
          v144 = (int8x16_t *)aa->d;
          if (v143 >= 4)
          {
            v145 = v143 & 0xFFFFFFFFFFFFFFFCLL;
            v159 = v144 + 1;
            v160 = 0uLL;
            v161 = v143 & 0xFFFFFFFFFFFFFFFCLL;
            v162 = 0uLL;
            do
            {
              v160 = vorrq_s8(v159[-1], v160);
              v162 = vorrq_s8(*v159, v162);
              v159 += 2;
              v161 -= 4;
            }
            while (v161);
            v163 = vorrq_s8(v162, v160);
            v146 = vorr_s8(*(int8x8_t *)v163.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v163, v163, 8uLL));
            if (v145 == v143)
            {
LABEL_204:
              if (v146)
              {
LABEL_205:
                if (BN_mod_sqr(r, aa, n, ctx) && BN_mod_mul(r, r, m, n, ctx) && BN_mod_mul(aa, aa, m, n, ctx))
                {
                  while (!BN_is_one(&r->d))
                  {
                    if (v91 < 2)
                      goto LABEL_227;
                    if (!BN_mod_sqr(p, r, n, ctx))
                      goto LABEL_164;
                    if (!BN_is_one(&p->d))
                    {
                      if ((_DWORD)v91 == 2)
                      {
LABEL_227:
                        v92 = 110;
                        v93 = 377;
                        goto LABEL_163;
                      }
                      v167 = 2;
                      while (BN_mod_mul(p, p, p, n, ctx))
                      {
                        if (BN_is_one(&p->d))
                          goto LABEL_213;
                        if ((_DWORD)v91 == ++v167)
                          goto LABEL_227;
                      }
                      goto LABEL_164;
                    }
                    v167 = 1;
LABEL_213:
                    if (!BN_copy(p, v90))
                      goto LABEL_164;
                    if ((int)v91 + ~v167 >= 1)
                    {
                      v168 = v91 - v167;
                      while (BN_mod_sqr(p, p, n, ctx))
                      {
                        if (--v168 < 2)
                          goto LABEL_218;
                      }
                      goto LABEL_164;
                    }
LABEL_218:
                    if (BN_mod_mul(v90, p, p, n, ctx))
                    {
                      if (BN_mod_mul(aa, aa, p, n, ctx))
                      {
                        LODWORD(v91) = v167;
                        if (BN_mod_mul(r, r, v90, n, ctx))
                          continue;
                      }
                    }
                    goto LABEL_164;
                  }
                  v88 = aa;
                  v84 = m;
                  if (BN_copy(v42, aa))
                    goto LABEL_104;
                }
                goto LABEL_164;
              }
              goto LABEL_228;
            }
          }
          else
          {
            v145 = 0;
            v146 = 0;
          }
          v164 = v143 - v145;
          v165 = &v144->i64[v145];
          do
          {
            v166 = *v165++;
            *(_QWORD *)&v146 |= v166;
            --v164;
          }
          while (v164);
          goto LABEL_204;
        }
LABEL_187:
        if (!BN_nnmod(v130, m, n, ctx))
          goto LABEL_164;
        v147 = p->top;
        if (!(_DWORD)v147)
          goto LABEL_228;
        v148 = (int8x16_t *)p->d;
        if (v147 >= 4)
        {
          v149 = v147 & 0xFFFFFFFFFFFFFFFCLL;
          v151 = v148 + 1;
          v152 = 0uLL;
          v153 = v147 & 0xFFFFFFFFFFFFFFFCLL;
          v154 = 0uLL;
          do
          {
            v152 = vorrq_s8(v151[-1], v152);
            v154 = vorrq_s8(*v151, v154);
            v151 += 2;
            v153 -= 4;
          }
          while (v153);
          v155 = vorrq_s8(v154, v152);
          v150 = vorr_s8(*(int8x8_t *)v155.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v155, v155, 8uLL));
          if (v149 == v147)
          {
LABEL_196:
            if (v150)
            {
              if (!BN_one((uint64_t)aa))
                goto LABEL_164;
              goto LABEL_205;
            }
LABEL_228:
            v42->neg = 0;
            v42->top = 0;
            if (!*((_BYTE *)ctx + 40))
              goto LABEL_168;
            return v42;
          }
        }
        else
        {
          v149 = 0;
          v150 = 0;
        }
        v156 = v147 - v149;
        v157 = &v148->i64[v149];
        do
        {
          v158 = *v157++;
          *(_QWORD *)&v150 |= v158;
          --v156;
        }
        while (v156);
        goto LABEL_196;
      }
    }
    else
    {
      v133 = 0;
      v134 = 0;
    }
    v140 = v131 - v133;
    v141 = &v132->i64[v133];
    do
    {
      v142 = *v141++;
      *(_QWORD *)&v134 |= v142;
      --v140;
    }
    while (v140);
    goto LABEL_182;
  }
  v92 = 114;
  v93 = 282;
LABEL_163:
  ERR_put_error(3, 0, v92, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/bn/sqrt.c", v93);
LABEL_164:
  if (v42 != ret)
    BN_free(v42);
LABEL_166:
  v42 = 0;
LABEL_167:
  if (!*((_BYTE *)ctx + 40))
  {
LABEL_168:
    v128 = *((_QWORD *)ctx + 1);
    v129 = *((_QWORD *)ctx + 2) - 1;
    *((_QWORD *)ctx + 2) = v129;
    *((_QWORD *)ctx + 4) = *(_QWORD *)(v128 + 8 * v129);
  }
  return v42;
}

void bssl::SSLAEADContext::Create(unsigned int a1@<W0>, unsigned int a2@<W1>, char a3@<W2>, uint64_t a4@<X3>, _BYTE *a5@<X4>, size_t a6@<X5>, const void *a7@<X6>, size_t a8@<X7>, _QWORD *a9@<X8>, void *a10, size_t a11)
{
  __int16 v16;
  unsigned int v19;
  const char *v21;
  int v22;
  int v23;
  int v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  int *v28;
  unsigned int (*v29)(_QWORD *, _BYTE *, size_t, _QWORD);
  _BYTE *v30;
  char v31;
  char v32;
  int v33;
  char v34;
  char v35;
  void *v36;
  unsigned int v37;
  unsigned int v38;
  _QWORD *v39;
  uint64_t v41;
  uint64_t v42;
  int *v43;
  _BYTE __dst[80];
  uint64_t v45;

  v16 = a2;
  v45 = *MEMORY[0x24BDAC8D0];
  v19 = a2;
  if (a2 - 769 >= 4)
  {
    if (a2 == 65277)
    {
      v19 = 771;
    }
    else
    {
      if (a2 != 65279)
      {
LABEL_14:
        v21 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/ssl/ssl_aead_ctx.cc";
        v22 = 16;
        v23 = 68;
        v24 = 70;
LABEL_15:
        ERR_put_error(v22, 0, v23, v21, v24);
        *a9 = 0;
        return;
      }
      v19 = 770;
    }
  }
  v42 = 0;
  v43 = 0;
  v41 = 0;
  if (!bssl::ssl_cipher_get_evp_aead(&v43, &v42, &v41, a4, v19, a3))
    goto LABEL_14;
  if (v41 != a11 || v42 != a8)
    goto LABEL_14;
  if (a8)
  {
    if (a8 + a6 + a11 >= 0x51)
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_aead_ctx.cc", 80);
      *a9 = 0;
      return;
    }
    v36 = a10;
    v38 = a1;
    memcpy(__dst, a7, a8);
    v30 = &__dst[a8];
    if (a6)
      memcpy(v30, a5, a6);
    if (a11)
      memcpy(&v30[a6], a10, a11);
    a5 = __dst;
    a6 += a8 + a11;
    a1 = v38;
    v25 = malloc_type_malloc(0x270uLL, 0x30772F57uLL);
    if (!v25)
      goto LABEL_27;
  }
  else
  {
    v36 = a10;
    v25 = malloc_type_malloc(0x270uLL, 0x30772F57uLL);
    if (!v25)
    {
LABEL_27:
      v21 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
      v22 = 14;
      v23 = 65;
      v24 = 247;
      goto LABEL_15;
    }
  }
  v26 = v25;
  v37 = a1;
  *v25 = 616;
  v25[1] = a4;
  v39 = v25 + 1;
  v27 = v25 + 2;
  bzero(v25 + 2, 0x248uLL);
  *((_WORD *)v26 + 306) = 0;
  *((_WORD *)v26 + 307) = v16;
  *((_BYTE *)v26 + 616) = a3;
  *((_BYTE *)v26 + 617) &= 0xE0u;
  v26[75] = 0;
  *((_DWORD *)v26 + 152) = 0;
  v28 = v43;
  if (a6 == *(unsigned __int8 *)v43)
  {
    *v27 = v43;
    v29 = (unsigned int (*)(_QWORD *, _BYTE *, size_t, _QWORD))*((_QWORD *)v28 + 1);
    if (v29)
    {
      if (!v29(v27, a5, a6, 0))
        goto LABEL_29;
LABEL_33:
      *((_BYTE *)v26 + 613) = *((_BYTE *)v28 + 1);
      if (a8)
      {
        v31 = *((_BYTE *)v26 + 617);
        v32 = 11;
      }
      else
      {
        if (a11)
          memcpy(v26 + 75, v36, a11);
        *((_BYTE *)v26 + 612) = a11;
        v33 = *(_DWORD *)(a4 + 28);
        if ((v33 & 0x20) != 0)
        {
          *((_BYTE *)v26 + 617) |= 4u;
          v33 = *(_DWORD *)(a4 + 28);
          v34 = 8;
        }
        else
        {
          v34 = *((_BYTE *)v26 + 613) - a11;
        }
        *((_BYTE *)v26 + 613) = v34;
        if ((v33 & 0x18) != 0)
          *((_BYTE *)v26 + 617) |= 1u;
        if (v19 < 0x304)
          goto LABEL_45;
        v35 = *((_BYTE *)v26 + 617);
        *((_BYTE *)v26 + 613) = 8;
        v31 = v35 & 0xFE;
        v32 = 20;
      }
      *((_BYTE *)v26 + 617) = v31 | v32;
LABEL_45:
      *a9 = v39;
      return;
    }
    if ((*((unsigned int (**)(_QWORD *, _BYTE *, size_t, _QWORD, _QWORD))v28 + 2))(v27, a5, a6, 0, v37))
      goto LABEL_33;
  }
  else
  {
    ERR_put_error(30, 0, 120, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/aead.c", 78);
  }
LABEL_29:
  *a9 = 0;
  if (*v26 != -8)
    __memset_chk();
  free(v26);
}

uint64_t bssl::SSLAEADContext::ProtocolVersion(bssl::SSLAEADContext *this)
{
  uint64_t result;

  result = *((unsigned __int16 *)this + 303);
  if ((result - 769) >= 4)
  {
    if ((_DWORD)result == 65277)
    {
      return 771;
    }
    else if ((_DWORD)result == 65279)
    {
      return 770;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t bssl::SSLAEADContext::RecordVersion(bssl::SSLAEADContext *this)
{
  unsigned int v1;

  v1 = *((unsigned __int16 *)this + 303);
  if (v1 - 769 < 4)
  {
    if (v1 > 0x303)
      LOWORD(v1) = 771;
    return (unsigned __int16)v1;
  }
  if (*((_WORD *)this + 303))
    return (unsigned __int16)v1;
  if (*((_BYTE *)this + 608))
    return (unsigned __int16)-257;
  else
    return 769;
}

uint64_t bssl::SSLAEADContext::SuffixLen(bssl::SSLAEADContext *this, unint64_t *a2, uint64_t a3, unint64_t a4)
{
  uint64_t (*v5)(char *, uint64_t, unint64_t);
  uint64_t v6;
  BOOL v7;
  uint64_t result;

  if (*(_QWORD *)this)
  {
    v5 = *(uint64_t (**)(char *, uint64_t, unint64_t))(*((_QWORD *)this + 1) + 64);
    if (v5)
    {
      a4 = v5((char *)this + 8, a3, a4);
    }
    else
    {
      v6 = *((unsigned __int8 *)this + 584);
      v7 = __CFADD__(v6, a4);
      a4 += v6;
      if (v7)
      {
        ERR_put_error(30, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/aead.c", 281);
        result = 0;
        *a2 = 0;
        return result;
      }
    }
  }
  result = 1;
  *a2 = a4;
  return result;
}

BOOL bssl::SSLAEADContext::Open(int8x16_t *a1, uint64_t a2, __int8 a3, __int16 a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9)
{
  char *v10;
  size_t v11;
  __int8 v13;
  unint64_t v14;
  BOOL v15;
  unsigned int v16;
  _BOOL8 result;
  uint64_t v18;
  size_t v19;
  unsigned int v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  uint64_t v30;
  int8x8_t *v31;
  int8x8_t *v32;
  uint64_t v33;
  int8x8_t v34;
  uint64_t v35;
  __int8 *v36;
  __int8 *v37;
  char v38;
  int v39;
  size_t v40;
  size_t v41;
  int8x16_t __dst;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t vars0;

  v11 = *((_QWORD *)&a9 + 1);
  v10 = (char *)a9;
  v44.i64[1] = *MEMORY[0x24BDAC8D0];
  if (!a1->i64[0])
  {
    *(_OWORD *)a2 = a9;
    return 1;
  }
  v13 = a1[38].i8[1];
  if ((v13 & 8) != 0)
  {
    v16 = 0;
  }
  else if ((a1[38].i8[1] & 1) != 0)
  {
    v21 = a1[37].u8[13] + (unint64_t)*(unsigned __int8 *)(a1->i64[1] + 2);
    v15 = *((_QWORD *)&a9 + 1) >= v21;
    v16 = DWORD2(a9) - v21;
    if (!v15)
    {
LABEL_16:
      v22 = 256;
LABEL_26:
      ERR_put_error(16, 0, 112, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_aead_ctx.cc", v22);
      return 0;
    }
  }
  else
  {
    v14 = *(unsigned __int8 *)(a1->i64[1] + 2);
    v15 = *((_QWORD *)&a9 + 1) >= v14;
    v16 = DWORD2(a9) - v14;
    if (!v15)
      goto LABEL_16;
  }
  v18 = bswap64(a5);
  if ((a1[38].i8[1] & 0x10) != 0)
  {
LABEL_11:
    v19 = a1[37].u8[12];
    v20 = a1[37].u8[12];
    if ((v13 & 4) == 0)
      goto LABEL_12;
    goto LABEL_18;
  }
  v43.i64[1] = v18;
  v44.i8[0] = a3;
  v44.i8[1] = HIBYTE(a4);
  v44.i8[2] = a4;
  if ((v13 & 8) == 0)
  {
    *(__int16 *)((char *)&v44.i16[1] + 1) = bswap32(v16) >> 16;
    goto LABEL_11;
  }
  v19 = a1[37].u8[12];
  v20 = a1[37].u8[12];
  if ((v13 & 4) == 0)
  {
LABEL_12:
    if (v20)
    {
      memcpy(&__dst, &a1[37], v19);
      if ((v13 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      v19 = 0;
      if ((v13 & 1) != 0)
        goto LABEL_24;
    }
    goto LABEL_21;
  }
LABEL_18:
  v19 -= a1[37].u8[13];
  if (v19)
    bzero(&__dst, v19);
  if ((v13 & 1) != 0)
  {
LABEL_24:
    v24 = a1[37].u8[13];
    v11 = *((_QWORD *)&a9 + 1) - v24;
    if (*((_QWORD *)&a9 + 1) < v24)
    {
      v22 = 283;
      goto LABEL_26;
    }
    if (a1[37].i8[13])
      memcpy(&__dst.i8[v19], (const void *)a9, a1[37].u8[13]);
    v10 = (char *)(a9 + v24);
    v23 = v24 + v19;
    if ((v13 & 4) == 0)
      goto LABEL_47;
    goto LABEL_30;
  }
LABEL_21:
  *(uint64_t *)((char *)__dst.i64 + v19) = v18;
  v23 = a1[37].u8[13] + v19;
  if ((v13 & 4) == 0)
    goto LABEL_47;
LABEL_30:
  if (!v20)
    goto LABEL_47;
  if (v20 < 8)
  {
    v25 = 0;
    goto LABEL_45;
  }
  if (v20 >= 0x20)
  {
    v25 = v20 & 0xE0;
    v26 = veorq_s8(v43, a1[38]);
    __dst = veorq_s8(__dst, a1[37]);
    v43 = v26;
    if (v25 != 32)
    {
      v27 = veorq_s8(v45, a1[40]);
      v44 = veorq_s8(v44, a1[39]);
      v45 = v27;
      if (v25 != 64)
      {
        v28 = veorq_s8(v47, a1[42]);
        v46 = veorq_s8(v46, a1[41]);
        v47 = v28;
        if (v25 != 96)
        {
          v29 = veorq_s8(v49, a1[44]);
          v48 = veorq_s8(v48, a1[43]);
          v49 = v29;
          if (v25 != 128)
            vars0 = veorq_s8(vars0, a1[45]);
        }
      }
    }
    if (v25 == v20)
      goto LABEL_47;
    if ((v20 & 0x18) == 0)
      goto LABEL_45;
  }
  else
  {
    v25 = 0;
  }
  v30 = v25;
  v25 = v20 & 0xF8;
  v31 = (int8x8_t *)&a1[37].i8[v30];
  v32 = (int8x8_t *)&__dst.i8[v30];
  v33 = v30 - v25;
  do
  {
    v34 = *v31++;
    *v32 = veor_s8(*v32, v34);
    ++v32;
    v33 += 8;
  }
  while (v33);
  if (v25 != v20)
  {
LABEL_45:
    v35 = v20 - v25;
    v36 = &__dst.i8[v25];
    v37 = &a1[37].i8[v25];
    do
    {
      v38 = *v37++;
      *v36++ ^= v38;
      --v35;
    }
    while (v35);
  }
LABEL_47:
  v41 = 0;
  v39 = EVP_AEAD_CTX_open(&a1->u8[8], v10, &v41, v11, (uint64_t)&__dst, v23, v10, v11);
  result = v39 != 0;
  if (v39)
  {
    v40 = v41;
    if (v11 < v41)
      v40 = v11;
    *(_QWORD *)a2 = v10;
    *(_QWORD *)(a2 + 8) = v40;
  }
  return result;
}

BOOL bssl::SSLAEADContext::SealScatter(int8x16_t *a1, char *a2, char *__dst, char *a4, __int8 a5, __int16 a6, unint64_t a7, int a8, __int128 a9, char *__len, size_t a11, void *__src, size_t a13, __int128 a14)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(unint64_t *, size_t, size_t);
  char *v23;
  uint64_t v24;
  int v25;
  int v26;
  unint64_t v27;
  BOOL v28;
  __int8 v30;
  unint64_t v31;
  char *v32;
  size_t v33;
  char *v34;
  __int8 v35;
  unint64_t v36;
  unint64_t *v37;
  size_t v38;
  uint64_t v39;
  uint64_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  uint64_t v46;
  int8x8_t *v47;
  int8x8_t *v48;
  uint64_t v49;
  int8x8_t v50;
  uint64_t v51;
  __int8 *v52;
  __int8 *v53;
  char v54;
  size_t v55;
  uint64_t v56;
  uint64_t v57;
  int8x16_t __dsta;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16_t vars0;

  v61.i64[0] = *MEMORY[0x24BDAC8D0];
  if ((a1[38].i8[1] & 1) != 0)
  {
    v20 = a1[37].u8[13];
    v21 = a13;
    if (!a1->i64[0])
      goto LABEL_10;
  }
  else
  {
    v20 = 0;
    v21 = a13;
    if (!a1->i64[0])
      goto LABEL_10;
  }
  v22 = *(uint64_t (**)(unint64_t *, size_t, size_t))(a1->i64[1] + 64);
  if (v22)
  {
    v23 = a4;
    v21 = v22(&a1->u64[1], a11, a13);
    a4 = v23;
  }
  else
  {
    v24 = a1[36].u8[8];
    v21 = v24 + a13;
    if (__CFADD__(v24, a13))
    {
      ERR_put_error(30, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/aead.c", 281);
      v25 = 200;
      v26 = 322;
LABEL_20:
      ERR_put_error(16, 0, v25, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_aead_ctx.cc", v26);
      return 0;
    }
  }
LABEL_10:
  v27 = (unint64_t)&__len[a11];
  if (__len != __dst && (v27 > (unint64_t)__dst ? (v28 = &__dst[a11] > __len) : (v28 = 0), v28)
    || &a2[v20] > __len && v27 > (unint64_t)a2
    || &a4[v21] > __len && v27 > (unint64_t)a4)
  {
    v25 = 189;
    v26 = 328;
    goto LABEL_20;
  }
  if (a1->i64[0])
  {
    v30 = a1[38].i8[1];
    v31 = bswap64(a7);
    if ((v30 & 0x10) != 0)
    {
      v56 = (uint64_t)__src;
      v33 = a1[37].u8[12];
      v55 = v21;
      if ((a1[38].i8[1] & 4) == 0)
      {
LABEL_34:
        v34 = a4;
        if ((_DWORD)v33)
        {
          v35 = v30;
          v36 = v31;
          memcpy(&__dsta, &a1[37], v33);
          goto LABEL_36;
        }
        v33 = 0;
        goto LABEL_40;
      }
    }
    else
    {
      v60.i64[0] = v31;
      v60.i8[8] = a5;
      v60.i8[9] = HIBYTE(a6);
      v60.i8[10] = a6;
      if ((v30 & 8) == 0)
        *(__int16 *)((char *)&v60.i16[5] + 1) = bswap32(a11) >> 16;
      v55 = v21;
      v33 = a1[37].u8[12];
      v56 = (uint64_t)__src;
      if ((v30 & 4) == 0)
        goto LABEL_34;
    }
    v33 -= a1[37].u8[13];
    if (v33)
    {
      v34 = a4;
      v35 = v30;
      v36 = v31;
      bzero(&__dsta, v33);
LABEL_36:
      v31 = v36;
      v30 = v35;
      goto LABEL_40;
    }
    v34 = a4;
LABEL_40:
    v37 = (unint64_t *)((char *)__dsta.u64 + v33);
    if ((v30 & 2) != 0)
    {
      RAND_bytes_with_additional_data((uint64_t)v37, a1[37].u8[13], (uint64_t)&RAND_bytes_kZeroAdditionalData);
      v30 = a1[38].i8[1];
      v38 = a1[37].u8[13];
      if ((v30 & 1) == 0)
        goto LABEL_49;
    }
    else
    {
      *v37 = v31;
      v38 = a1[37].u8[13];
      if ((v30 & 1) == 0)
        goto LABEL_49;
    }
    if (v27 > (unint64_t)a2 && &a2[v38] > __len)
    {
      v25 = 189;
      v26 = 374;
      goto LABEL_20;
    }
    if ((_DWORD)v38)
    {
      memcpy(a2, &__dsta.i8[a1[37].u8[12]], v38);
      v30 = a1[38].i8[1];
    }
LABEL_49:
    if ((v30 & 4) == 0)
      goto LABEL_67;
    v39 = a1[37].u8[12];
    if (!a1[37].i8[12])
      goto LABEL_67;
    if (v39 < 8)
    {
      v40 = 0;
LABEL_65:
      v51 = v39 - v40;
      v52 = &__dsta.i8[v40];
      v53 = &a1[37].i8[v40];
      do
      {
        v54 = *v53++;
        *v52++ ^= v54;
        --v51;
      }
      while (v51);
LABEL_67:
      v57 = 0;
      return EVP_AEAD_CTX_seal_scatter(&a1->i64[1], __dst, v34, &v57, v55, (uint64_t)&__dsta, v33 + v38, __len, a11, v56, a13) != 0;
    }
    if (v39 >= 0x20)
    {
      v40 = v39 & 0xE0;
      v41 = veorq_s8(v59, a1[38]);
      __dsta = veorq_s8(__dsta, a1[37]);
      v59 = v41;
      if (v40 != 32)
      {
        v42 = veorq_s8(v61, a1[40]);
        v60 = veorq_s8(v60, a1[39]);
        v61 = v42;
        if (v40 != 64)
        {
          v43 = veorq_s8(v63, a1[42]);
          v62 = veorq_s8(v62, a1[41]);
          v63 = v43;
          if (v40 != 96)
          {
            v44 = veorq_s8(v65, a1[44]);
            v64 = veorq_s8(v64, a1[43]);
            v65 = v44;
            if (v40 != 128)
            {
              v45 = veorq_s8(vars0, a1[46]);
              v66 = veorq_s8(v66, a1[45]);
              vars0 = v45;
            }
          }
        }
      }
      if (v40 == v39)
        goto LABEL_67;
      if ((v39 & 0x18) == 0)
        goto LABEL_65;
    }
    else
    {
      v40 = 0;
    }
    v46 = v40;
    v40 = v39 & 0xF8;
    v47 = (int8x8_t *)&a1[37].i8[v46];
    v48 = (int8x8_t *)&__dsta.i8[v46];
    v49 = v46 - v40;
    do
    {
      v50 = *v47++;
      *v48 = veor_s8(*v48, v50);
      ++v48;
      v49 += 8;
    }
    while (v49);
    if (v40 == v39)
      goto LABEL_67;
    goto LABEL_65;
  }
  if (a11)
  {
    v32 = a4;
    memmove(__dst, __len, a11);
    a4 = v32;
  }
  if (a13)
    memmove(a4, __src, a13);
  return 1;
}

BOOL bssl::SSLAEADContext::Seal(int8x16_t *a1, char *a2, _QWORD *a3, size_t a4, __int8 a5, __int16 a6, unint64_t a7, int a8, __int128 a9, char *__len, size_t a11)
{
  uint64_t v18;
  uint64_t *v19;
  uint64_t (*v20)(uint64_t *, size_t, _QWORD);
  uint64_t v21;
  size_t v22;
  size_t v23;
  int v24;
  int v25;
  int v26;
  _BOOL8 result;
  __int128 v28;

  if ((a1[38].i8[1] & 1) == 0)
  {
    v18 = 0;
    if (a1->i64[0])
      goto LABEL_3;
LABEL_8:
    v21 = 0;
    v22 = v18 + a11;
    if (__CFADD__(v18, a11))
      goto LABEL_14;
    goto LABEL_12;
  }
  v18 = a1[37].u8[13];
  if (!a1->i64[0])
    goto LABEL_8;
LABEL_3:
  v19 = &a1->i64[1];
  v20 = *(uint64_t (**)(uint64_t *, size_t, _QWORD))(a1->i64[1] + 64);
  if (v20)
  {
    v21 = v20(v19, a11, 0);
    v22 = v18 + a11;
    if (__CFADD__(v18, a11))
      goto LABEL_14;
  }
  else
  {
    v21 = a1[36].u8[8];
    v22 = v18 + a11;
    if (__CFADD__(v18, a11))
    {
LABEL_14:
      v24 = 30;
      v25 = 200;
      v26 = 409;
LABEL_15:
      ERR_put_error(v24, 0, v25, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_aead_ctx.cc", v26);
      return 0;
    }
  }
LABEL_12:
  v23 = v21 + v22;
  if (__CFADD__(v21, v22))
    goto LABEL_14;
  if (v23 > a4)
  {
    v24 = 16;
    v25 = 121;
    v26 = 413;
    goto LABEL_15;
  }
  result = bssl::SSLAEADContext::SealScatter(a1, a2, &a2[v18], &a2[v18 + a11], a5, a6, a7, a8, a9, __len, a11, 0, 0, v28);
  if (result)
  {
    *a3 = v23;
    return 1;
  }
  return result;
}

void bssl::SSL_SESSION_parse(unsigned __int8 **a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, ssl_session_st **a4@<X8>)
{
  char *v8;
  char *v9;
  ssl_session_st *v10;
  _WORD *v11;
  uint64_t *v12;
  unint64_t *v13;
  unint64_t *v14;
  _DWORD *v15;
  int v16;
  int v17;
  unsigned int i;
  unsigned int v19;
  unint64_t v20;
  unsigned __int16 *v21;
  BOOL v22;
  unint64_t v23;
  void *v24;
  size_t v25;
  char v26;
  __int128 v27;
  char v28;
  int v29;
  char *v30;
  unint64_t *v31;
  const void *v32;
  size_t v33;
  char *v34;
  unsigned int *v35;
  char v36;
  unsigned int *v37;
  BOOL v38;
  int v39;
  char v40;
  char v41;
  uint64_t *v42;
  uint64_t v43;
  const void *v44;
  size_t v45;
  int v46;
  int v47;
  int v48;
  char *v49;
  unint64_t v50;
  int v51;
  int v52;
  unsigned __int8 *v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  const void *v57;
  size_t v58;
  unint64_t v59;
  unsigned __int8 *v60[2];
  void *__src;
  size_t __n;
  unsigned __int16 *v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unsigned __int8 *v67;
  unint64_t v68;
  unint64_t __key;
  size_t v70;
  unsigned int v71;

  v8 = (char *)malloc_type_malloc(0x1C8uLL, 0x30772F57uLL);
  if (!v8)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    *a4 = 0;
    return;
  }
  v9 = v8;
  v42 = a3;
  *(_QWORD *)v8 = 448;
  *((_DWORD *)v8 + 2) = 1;
  v10 = (ssl_session_st *)(v8 + 8);
  *(_OWORD *)(v8 + 12) = 0u;
  v11 = v8 + 12;
  *((_QWORD *)v8 + 17) = 0;
  v12 = (uint64_t *)(v8 + 136);
  *(_OWORD *)(v8 + 28) = 0u;
  *(_OWORD *)(v8 + 44) = 0u;
  *(_OWORD *)(v8 + 60) = 0u;
  *(_OWORD *)(v8 + 76) = 0u;
  *(_OWORD *)(v8 + 92) = 0u;
  *(_OWORD *)(v8 + 108) = 0u;
  *(_OWORD *)(v8 + 117) = 0u;
  *((_QWORD *)v8 + 18) = 0;
  *((_QWORD *)v8 + 19) = a2;
  *((_QWORD *)v8 + 23) = 65;
  v13 = (unint64_t *)(v8 + 184);
  *((_QWORD *)v8 + 21) = 0;
  *((_QWORD *)v8 + 22) = 0;
  *((_QWORD *)v8 + 20) = 0;
  *((int32x2_t *)v8 + 24) = vdup_n_s32(0x1C20u);
  *((_QWORD *)v8 + 25) = 0;
  v14 = (unint64_t *)(v8 + 200);
  v15 = v8 + 372;
  v8[368] = 0;
  *((_OWORD *)v8 + 21) = 0u;
  *((_OWORD *)v8 + 22) = 0u;
  *((_OWORD *)v8 + 19) = 0u;
  *((_OWORD *)v8 + 20) = 0u;
  *((_OWORD *)v8 + 17) = 0u;
  *((_OWORD *)v8 + 18) = 0u;
  *((_OWORD *)v8 + 15) = 0u;
  *((_OWORD *)v8 + 16) = 0u;
  *((_OWORD *)v8 + 14) = 0u;
  *(_OWORD *)(v8 + 372) = 0u;
  *(_OWORD *)(v8 + 388) = 0u;
  *(_OWORD *)(v8 + 404) = 0u;
  *((_OWORD *)v8 + 26) = 0u;
  v8[432] &= 0x80u;
  *((_QWORD *)v8 + 55) = 0;
  *((_QWORD *)v8 + 56) = 0;
  *((_QWORD *)v8 + 26) = 0;
  *((_QWORD *)v8 + 27) = 0;
  *((_QWORD *)v8 + 25) = time(0);
  v65 = 0;
  v66 = 0;
  __key = 0;
  LODWORD(v63) = 0;
  if (!cbs_get_any_asn1_element(a1, &v67, &v63, &__key, 0, 0, 0)
    || (_DWORD)v63 != 536870928
    || v68 < __key
    || (v67 += __key, v68 -= __key, !CBS_get_asn1_uint64(&v67, &v66))
    || v66 != 1
    || !CBS_get_asn1_uint64(&v67, &v65)
    || v65 >> 16
    || (unsigned __int16)v65 - 769 >= 4
    && (unsigned __int16)v65 != 65277
    && (unsigned __int16)v65 != 65279)
  {
    v16 = 160;
    v17 = 553;
LABEL_6:
    ERR_put_error(16, 0, v16, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_asn1.cc", v17);
    goto LABEL_7;
  }
  *v11 = v65;
  __key = 0;
  LODWORD(__src) = 0;
  if (!cbs_get_any_asn1_element(&v67, &v63, &__src, &__key, 0, 0, 0))
    goto LABEL_31;
  if ((_DWORD)__src != 4)
    goto LABEL_31;
  v20 = v64 - __key;
  if (v64 < __key
    || (v21 = (unsigned __int16 *)((char *)v63 + __key),
        v63 = (unsigned __int16 *)((char *)v63 + __key),
        v64 -= __key,
        v22 = v20 >= 2,
        v23 = v20 - 2,
        !v22)
    || (v63 = v21 + 1, (v64 = v23) != 0))
  {
LABEL_31:
    v16 = 160;
    v17 = 563;
    goto LABEL_6;
  }
  v71 = (bswap32(*v21) >> 16) | 0x3000000;
  v24 = bsearch(&__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
  *((_QWORD *)v9 + 26) = v24;
  if (!v24)
  {
    v16 = 237;
    v17 = 568;
    goto LABEL_6;
  }
  if (!CBS_get_asn1(&v67, &__key, 4)
    || v70 > 0x20
    || !CBS_get_asn1(&v67, &__src, 4)
    || (v25 = __n, __n >= 0x31))
  {
    v16 = 160;
    v17 = 577;
    goto LABEL_6;
  }
  v26 = v70;
  if (v70)
    memcpy(v9 + 68, (const void *)__key, v70);
  v9[67] = v26;
  if (v25)
    memcpy(v9 + 19, __src, v25);
  v9[18] = v25;
  v59 = 0;
  if (!CBS_get_asn1(&v67, v60, -1610612735)
    || !CBS_get_asn1_uint64(v60, v14)
    || !CBS_get_asn1(&v67, v60, -1610612734)
    || !CBS_get_asn1_uint64(v60, &v59)
    || HIDWORD(v59))
  {
    v16 = 160;
    v17 = 596;
    goto LABEL_6;
  }
  *((_DWORD *)v9 + 48) = v59;
  v56 = 0;
  if (!CBS_get_optional_asn1(&v67, &v57, &v56, -1610612733) || v56 && !v58)
  {
    v16 = 160;
    v17 = 606;
    goto LABEL_6;
  }
  if (!bssl::SSL_SESSION_parse_bounded_octet_string(&v67, v9 + 101, v9 + 100, 0x20u, -1610612732)
    || !bssl::SSL_SESSION_parse_long(&v67, v13))
  {
    goto LABEL_7;
  }
  if (!CBS_get_optional_asn1(&v67, &v55, 0, -1610612730))
  {
    v16 = 160;
    v17 = 623;
    goto LABEL_6;
  }
  if (!bssl::SSL_SESSION_parse_string(&v67, v12)
    || !bssl::SSL_SESSION_parse_u32(&v67, v15, -1610612727, 0)
    || (bssl::SSL_SESSION_parse_octet_string(&v67, (uint64_t *)v9 + 30, -1610612726) & 1) == 0)
  {
    goto LABEL_7;
  }
  if (CBS_peek_asn1_tag(&v67, -1610612723))
  {
    if (!CBS_get_asn1(&v67, v60, -1610612723)
      || !CBS_get_asn1(v60, &v53, 4)
      || v54 != 32
      || v60[1])
    {
      v16 = 160;
      v17 = 641;
      goto LABEL_6;
    }
    v27 = *((_OWORD *)v53 + 1);
    *((_OWORD *)v9 + 17) = *(_OWORD *)v53;
    *((_OWORD *)v9 + 18) = v27;
    v28 = v9[432] | 2;
  }
  else
  {
    v28 = v9[432] & 0xFD;
  }
  v9[432] = v28;
  if (!bssl::SSL_SESSION_parse_bounded_octet_string(&v67, v9 + 304, v9 + 368, 0x40u, -1610612722)
    || !bssl::SSL_SESSION_parse_crypto_buffer(&v67, (unsigned int **)v9 + 32, -1610612721, v42)
    || !bssl::SSL_SESSION_parse_crypto_buffer(&v67, (unsigned int **)v9 + 33, -1610612720, v42))
  {
    goto LABEL_7;
  }
  v52 = 0;
  if (!CBS_get_optional_asn1_BOOL(&v67, &v52, -1610612719, 0))
  {
    v17 = 667;
    goto LABEL_84;
  }
  v9[432] = v9[432] & 0xFE | (v52 != 0);
  if (!bssl::SSL_SESSION_parse_u16(&v67, (_WORD *)v9 + 7, -1610612718))
  {
    v17 = 673;
    goto LABEL_84;
  }
  v53 = 0;
  v54 = 0;
  v51 = 0;
  if (!CBS_get_optional_asn1(&v67, &v53, &v51, -1610612717))
    goto LABEL_85;
  if (!v51)
  {
    v29 = v56;
    goto LABEL_87;
  }
  if (!v54)
  {
LABEL_85:
    v16 = 160;
    v17 = 683;
    goto LABEL_6;
  }
  v29 = v56;
  if (!v56)
  {
    v16 = 160;
    v17 = 687;
    goto LABEL_6;
  }
LABEL_87:
  if (v29 | v51)
  {
    v30 = OPENSSL_sk_new_null();
    v31 = (unint64_t *)*((_QWORD *)v9 + 18);
    *((_QWORD *)v9 + 18) = v30;
    if (v31)
    {
      OPENSSL_sk_pop_free_ex(v31, (void (*)(uint64_t))bssl::internal::DeleterImpl<stack_st_CRYPTO_BUFFER,void>::Free(stack_st_CRYPTO_BUFFER*)::{lambda(void (*)(void *),void *)#1}::__invoke, 0);
      v30 = (char *)*((_QWORD *)v9 + 18);
    }
    if (v30)
    {
      if (!v56)
        goto LABEL_95;
      v32 = v57;
      v33 = v58;
      while (1)
      {
        v34 = crypto_buffer_new(v32, v33, 0, v42);
        if (!v34)
          break;
        v35 = (unsigned int *)v34;
        if (!OPENSSL_sk_insert(*((unint64_t **)v9 + 18), (uint64_t)v34, **((_QWORD **)v9 + 18)))
        {
          CRYPTO_BUFFER_free(v35);
          goto LABEL_7;
        }
LABEL_95:
        if (!v54)
          goto LABEL_99;
        if (!cbs_get_any_asn1_element(&v53, &v49, 0, 0, 0, 0, 0) || (v33 = v50) == 0)
        {
          v16 = 160;
          v17 = 708;
          goto LABEL_6;
        }
        v32 = v49;
      }
    }
    goto LABEL_7;
  }
LABEL_99:
  v48 = 0;
  if (CBS_get_optional_asn1_octet_string(&v67, &v49, &v48, -1610612715))
  {
    v36 = v50;
    if (v48)
    {
      if (v50 < 4)
        goto LABEL_7;
      v37 = (unsigned int *)v49;
      v38 = v50 == 4;
      v49 += 4;
      v50 -= 4;
      *((_DWORD *)v9 + 94) = bswap32(*v37);
      if (!v38)
        goto LABEL_7;
      v36 = 8;
    }
    else if (v50)
    {
      goto LABEL_7;
    }
    v9[432] = v9[432] & 0xF7 | v36;
    v47 = 0;
    if (!CBS_get_optional_asn1_BOOL(&v67, &v47, -1610612714, 1))
    {
      v16 = 160;
      v17 = 734;
      goto LABEL_6;
    }
    v9[432] = v9[432] & 0xEF | (16 * (v47 != 0));
    v46 = 0;
    if (!bssl::SSL_SESSION_parse_u16(&v67, (_WORD *)v9 + 8, -1610612713)
      || !bssl::SSL_SESSION_parse_u32(&v67, (_DWORD *)v9 + 95, -1610612712, 0)
      || !bssl::SSL_SESSION_parse_u32(&v67, (_DWORD *)v9 + 49, -1610612711, *((_DWORD *)v9 + 48))
      || !bssl::SSL_SESSION_parse_octet_string(&v67, (uint64_t *)v9 + 48, -1610612710)
      || !CBS_get_optional_asn1_BOOL(&v67, &v46, -1610612709, 0)
      || (bssl::SSL_SESSION_parse_octet_string(&v67, (uint64_t *)v9 + 55, -1610612708) & 1) == 0)
    {
      v16 = 160;
      v17 = 755;
      goto LABEL_6;
    }
    v43 = 0;
    if (CBS_get_optional_asn1_octet_string(&v67, &v44, (int *)&v43 + 1, -1610612707)
      && bssl::Array<unsigned char>::CopyFrom((uint64_t *)v9 + 50, v44, v45)
      && CBS_get_optional_asn1_octet_string(&v67, &v44, (int *)&v43, -1610612706))
    {
      v39 = bssl::Array<unsigned char>::CopyFrom((uint64_t *)v9 + 52, v44, v45);
      v17 = 768;
      if (v39 && !v68)
      {
        v40 = v9[432] & 0xDF | (32 * (v46 != 0));
        v9[432] = v40;
        v41 = BYTE4(v43);
        if (HIDWORD(v43) == (_DWORD)v43)
        {
          if (!HIDWORD(v43))
          {
LABEL_122:
            v9[432] = v41 | v40 & 0xBF;
            if (((*(uint64_t (**)(ssl_session_st *))(a2 + 48))(v10) & 1) != 0)
            {
              *a4 = v10;
              return;
            }
            v17 = 782;
            goto LABEL_84;
          }
          if (*((_QWORD *)v9 + 49))
          {
            v41 = 64;
            goto LABEL_122;
          }
        }
        v17 = 776;
      }
    }
    else
    {
      v17 = 768;
    }
LABEL_84:
    v16 = 160;
    goto LABEL_6;
  }
LABEL_7:
  *a4 = 0;
  for (i = atomic_load((unsigned int *)v10); i != -1; i = v19)
  {
    if (!i)
      abort();
    v19 = __ldaxr((unsigned int *)v10);
    if (v19 == i)
    {
      if (!__stlxr(i - 1, (unsigned int *)v10))
      {
        if (i == 1)
        {
          ssl_session_st::~ssl_session_st(v10);
          if (*(_QWORD *)v9 != -8)
            __memset_chk();
          free(v9);
        }
        return;
      }
    }
    else
    {
      __clrex();
    }
  }
}

uint64_t bssl::SSL_SESSION_parse_bounded_octet_string(unsigned __int8 **a1, void *a2, _BYTE *a3, unsigned int a4, int a5)
{
  unint64_t v8;
  size_t v9;
  const void *v10;
  uint64_t v12;
  unint64_t v13;
  int v14;
  unsigned __int8 *v15;
  uint64_t v16;
  int v17;
  unint64_t v18;

  v15 = 0;
  v16 = 0;
  v14 = 0;
  if (!CBS_get_optional_asn1(a1, &v15, &v14, a5))
    goto LABEL_8;
  if (!v14)
    goto LABEL_10;
  v18 = 0;
  v17 = 0;
  if (!cbs_get_any_asn1_element(&v15, &v12, &v17, &v18, 0, 0, 0)
    || v17 != 4
    || (v8 = v13, v9 = v13 - v18, v13 < v18)
    || (v10 = (const void *)(v12 + v18), v12 += v18, v13 -= v18, v16)
    || v9 > a4)
  {
LABEL_8:
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_asn1.cc", 485);
    return 0;
  }
  if (v8 != v18)
    memcpy(a2, v10, v9);
  else
LABEL_10:
    LOBYTE(v9) = 0;
  *a3 = v9;
  return 1;
}

uint64_t bssl::SSL_SESSION_parse_long(unsigned __int8 **a1, unint64_t *a2)
{
  unint64_t v3;
  unint64_t v5;
  int v6;
  unsigned __int8 *v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  v6 = 0;
  if (!CBS_get_optional_asn1(a1, &v7, &v6, -1610612731))
    goto LABEL_6;
  if (v6)
  {
    v5 = 0;
    if (!CBS_get_asn1_uint64(&v7, &v5) || v8 || (v3 = v5, (v5 & 0x8000000000000000) != 0))
    {
LABEL_6:
      ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_asn1.cc", 499);
      return 0;
    }
  }
  else
  {
    v3 = 0;
  }
  *a2 = v3;
  return 1;
}

uint64_t bssl::SSL_SESSION_parse_string(unsigned __int8 **a1, uint64_t *a2)
{
  unint64_t v3;
  size_t v4;
  _BYTE *v5;
  int v6;
  uint64_t result;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  unsigned __int8 *v15;
  uint64_t v16;
  int v17;
  unint64_t v18;

  v15 = 0;
  v16 = 0;
  v14 = 0;
  if (!CBS_get_optional_asn1(a1, &v15, &v14, -1610612728))
    goto LABEL_7;
  if (!v14)
  {
    v8 = *a2;
    *a2 = 0;
    if (!v8)
      return 1;
LABEL_11:
    v10 = *(_QWORD *)(v8 - 8);
    v9 = (void *)(v8 - 8);
    v11 = v10 + 8;
    if (v10 != -8)
      bzero(v9, v11);
    free(v9);
    return 1;
  }
  v18 = 0;
  v17 = 0;
  if (!cbs_get_any_asn1_element(&v15, &v12, &v17, &v18, 0, 0, 0)
    || v17 != 4
    || (v3 = v13, v4 = v13 - v18, v13 < v18)
    || (v5 = (_BYTE *)(v12 + v18), v12 += v18, v13 -= v18, v16))
  {
LABEL_7:
    v6 = 422;
LABEL_8:
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_asn1.cc", v6);
    return 0;
  }
  if (v3 != v18 && memchr(v5, 0, v4))
  {
    v6 = 427;
    goto LABEL_8;
  }
  result = (uint64_t)OPENSSL_strndup(v5, v4);
  if (result)
  {
    v8 = *a2;
    *a2 = result;
    if (!v8)
      return 1;
    goto LABEL_11;
  }
  return result;
}

uint64_t bssl::SSL_SESSION_parse_u32(unsigned __int8 **a1, _DWORD *a2, int a3, int a4)
{
  int v6;
  unint64_t v8;
  int v9;
  unsigned __int8 *v10;
  uint64_t v11;

  v10 = 0;
  v11 = 0;
  v9 = 0;
  if (!CBS_get_optional_asn1(a1, &v10, &v9, a3))
    goto LABEL_6;
  if (v9)
  {
    v8 = 0;
    if (!CBS_get_asn1_uint64(&v10, &v8) || v11 || (v6 = v8, HIDWORD(v8)))
    {
LABEL_6:
      ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_asn1.cc", 512);
      return 0;
    }
  }
  else
  {
    v6 = a4;
  }
  *a2 = v6;
  return 1;
}

uint64_t bssl::SSL_SESSION_parse_octet_string(unsigned __int8 **a1, uint64_t *a2, int a3)
{
  size_t v4;
  const void *v5;
  uint64_t result;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  size_t v10;
  _QWORD *v11;
  void *v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  unsigned __int8 *v16;
  uint64_t v17;
  int v18;
  unint64_t v19;

  v16 = 0;
  v17 = 0;
  v15 = 0;
  if (!CBS_get_optional_asn1(a1, &v16, &v15, a3))
    goto LABEL_7;
  if (v15)
  {
    v19 = 0;
    v18 = 0;
    if (!cbs_get_any_asn1_element(&v16, &v13, &v18, &v19, 0, 0, 0)
      || v18 != 4
      || (v4 = v14 - v19, v14 < v19)
      || (v5 = (const void *)(v13 + v19), v13 += v19, v14 -= v19, v17))
    {
LABEL_7:
      ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_asn1.cc", 448);
      return 0;
    }
  }
  else
  {
    v4 = 0;
    v5 = 0;
    v13 = 0;
    v14 = 0;
  }
  v7 = *a2;
  if (*a2)
  {
    v9 = *(_QWORD *)(v7 - 8);
    v8 = (void *)(v7 - 8);
    v10 = v9 + 8;
    if (v9 != -8)
      bzero(v8, v10);
    free(v8);
  }
  *a2 = 0;
  a2[1] = 0;
  if (!v4)
    return 1;
  if (v4 <= 0xFFFFFFFFFFFFFFF7)
  {
    v11 = malloc_type_malloc(v4 + 8, 0x30772F57uLL);
    if (v11)
    {
      *v11 = v4;
      v12 = v11 + 1;
      *a2 = (uint64_t)v12;
      a2[1] = v4;
      memmove(v12, v5, v4);
      return 1;
    }
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  result = 0;
  *a2 = 0;
  return result;
}

BOOL bssl::SSL_SESSION_parse_crypto_buffer(unsigned __int8 **a1, unsigned int **a2, int a3, uint64_t *a4)
{
  unsigned __int8 *v4;
  int v8;
  unint64_t v9;
  unint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  int v13;
  int v14;
  unsigned int v15;
  size_t v18;
  const void *v19;
  char *v20;
  unsigned int *v21;
  unint64_t v22;
  unint64_t v23;
  unsigned __int8 *v24;
  unint64_t v25;
  int v26;
  unint64_t v27;

  v4 = a1[1];
  if (!v4)
    return 1;
  v8 = **a1;
  LODWORD(v9) = v8 & 0x1F;
  if ((_DWORD)v9 == 31)
  {
    v10 = 0;
    v11 = *a1 + 1;
    v12 = v4 - 1;
    while (v12)
    {
      if (v10 >> 57)
        break;
      v13 = *v11;
      if (!v10 && v13 == 128)
        break;
      v9 = v13 & 0x7F | (v10 << 7);
      ++v11;
      --v12;
      v10 = v9;
      if ((v13 & 0x80) == 0)
      {
        if (v9 - 0x20000000 < 0xFFFFFFFFE000001FLL)
          return 1;
        goto LABEL_11;
      }
    }
    return 1;
  }
LABEL_11:
  v14 = v9 | (v8 << 24) & 0xE0000000;
  v15 = v14 & 0xDFFFFFFF;
  if ((v14 & 0xDFFFFFFF) == 0)
    v14 = 0;
  if (!v15 || v14 != a3)
    return 1;
  v22 = 0;
  LODWORD(v27) = 0;
  if (!cbs_get_any_asn1_element(a1, &v24, &v27, &v22, 0, 0, 0))
    goto LABEL_25;
  if ((_DWORD)v27 != a3)
    goto LABEL_25;
  if (v25 < v22)
    goto LABEL_25;
  v24 += v22;
  v25 -= v22;
  v27 = 0;
  v26 = 0;
  if (!cbs_get_any_asn1_element(&v24, &v22, &v26, &v27, 0, 0, 0))
    goto LABEL_25;
  if (v26 == 4 && (v18 = v23 - v27, v23 >= v27) && (v19 = (const void *)(v22 + v27), v22 += v27, v23 -= v27, !v25))
  {
    v20 = crypto_buffer_new(v19, v18, 0, a4);
    v21 = *a2;
    *a2 = (unsigned int *)v20;
    if (v21)
    {
      CRYPTO_BUFFER_free(v21);
      v20 = (char *)*a2;
    }
    return v20 != 0;
  }
  else
  {
LABEL_25:
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_asn1.cc", 466);
    return 0;
  }
}

uint64_t bssl::SSL_SESSION_parse_u16(unsigned __int8 **a1, _WORD *a2, int a3)
{
  __int16 v4;
  unint64_t v6;
  int v7;
  unsigned __int8 *v8;
  uint64_t v9;

  v8 = 0;
  v9 = 0;
  v7 = 0;
  if (!CBS_get_optional_asn1(a1, &v8, &v7, a3))
    goto LABEL_6;
  if (v7)
  {
    v6 = 0;
    if (!CBS_get_asn1_uint64(&v8, &v6) || v9 || (v4 = v6, v6 >= 0x10000))
    {
LABEL_6:
      ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_asn1.cc", 525);
      return 0;
    }
  }
  else
  {
    v4 = 0;
  }
  *a2 = v4;
  return 1;
}

uint64_t bssl::SSL_SESSION_to_bytes_full(uint64_t result, uint64_t *a2, int a3)
{
  uint64_t v3;
  int v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  _QWORD *v11;
  char v12;
  unint64_t i;
  unint64_t *v14;
  uint64_t v15;
  int v16;
  _QWORD v17[6];
  uint64_t v18[6];
  uint64_t v19[6];

  if (result)
  {
    v3 = result;
    if (!*(_QWORD *)(result + 200))
      return 0;
    result = CBB_flush(a2);
    if ((_DWORD)result)
    {
      v19[0] = 0;
      result = CBB_add_space((uint64_t)a2, v19, 1);
      if ((_DWORD)result)
      {
        *(_BYTE *)v19[0] = 48;
        result = cbb_add_child((uint64_t)a2, (uint64_t)v19, 1u, 1);
        if ((_DWORD)result)
        {
          result = CBB_add_asn1_uint64_with_tag((uint64_t)v19, 1uLL, 2);
          if ((_DWORD)result)
          {
            result = CBB_add_asn1_uint64_with_tag((uint64_t)v19, *(unsigned __int16 *)(v3 + 4), 2);
            if ((_DWORD)result)
            {
              result = CBB_flush(v19);
              if ((_DWORD)result)
              {
                v18[0] = 0;
                result = CBB_add_space((uint64_t)v19, v18, 1);
                if ((_DWORD)result)
                {
                  *(_BYTE *)v18[0] = 4;
                  result = cbb_add_child((uint64_t)v19, (uint64_t)v18, 1u, 1);
                  if ((_DWORD)result)
                  {
                    v6 = *(_DWORD *)(*(_QWORD *)(v3 + 200) + 16);
                    v17[0] = 0;
                    result = CBB_add_space((uint64_t)v18, v17, 2);
                    if ((_DWORD)result)
                    {
                      *(_BYTE *)(v17[0] + 1) = v6;
                      *(_BYTE *)v17[0] = BYTE1(v6);
                      v7 = a3 ? 0 : *(unsigned __int8 *)(v3 + 59);
                      result = CBB_add_asn1_octet_string((uint64_t)v19, (const void *)(v3 + 60), v7);
                      if ((_DWORD)result)
                      {
                        result = CBB_add_asn1_octet_string((uint64_t)v19, (const void *)(v3 + 11), *(unsigned __int8 *)(v3 + 10));
                        if ((_DWORD)result)
                        {
                          result = CBB_add_asn1(v19, (uint64_t)v18, -1610612735);
                          if ((_DWORD)result)
                          {
                            result = CBB_add_asn1_uint64_with_tag((uint64_t)v18, *(_QWORD *)(v3 + 192), 2);
                            if ((_DWORD)result)
                            {
                              result = CBB_add_asn1(v19, (uint64_t)v18, -1610612734);
                              if ((_DWORD)result)
                              {
                                result = CBB_add_asn1_uint64_with_tag((uint64_t)v18, *(unsigned int *)(v3 + 184), 2);
                                if ((_DWORD)result)
                                {
                                  v8 = *(_QWORD *)(v3 + 136);
                                  if (!v8
                                    || !*(_QWORD *)v8
                                    || (*(_BYTE *)(v3 + 424) & 2) != 0
                                    || (v9 = **(_QWORD **)(v8 + 8),
                                        result = CBB_add_asn1(v19, (uint64_t)v18, -1610612733),
                                        (_DWORD)result)
                                    && (result = CBB_add_bytes((uint64_t)v18, *(const void **)(v9 + 8), *(_QWORD *)(v9 + 16)), (_DWORD)result))
                                  {
                                    result = CBB_add_asn1(v19, (uint64_t)v18, -1610612732);
                                    if ((_DWORD)result)
                                    {
                                      result = CBB_add_asn1_octet_string((uint64_t)v18, (const void *)(v3 + 93), *(unsigned __int8 *)(v3 + 92));
                                      if ((_DWORD)result)
                                      {
                                        if (!*(_QWORD *)(v3 + 176)
                                          || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612731), (_DWORD)result)
                                          && (result = CBB_add_asn1_uint64_with_tag((uint64_t)v18, *(_QWORD *)(v3 + 176), 2), (_DWORD)result))
                                        {
                                          if (!*(_QWORD *)(v3 + 128)
                                            || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612728), (_DWORD)result)
                                            && (v10 = strlen(*(const char **)(v3 + 128)),
                                                result = CBB_add_asn1_octet_string((uint64_t)v18, *(const void **)(v3 + 128), v10), (_DWORD)result))
                                          {
                                            if (!*(_DWORD *)(v3 + 364)
                                              || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612727), (_DWORD)result)
                                              && (result = CBB_add_asn1_uint64_with_tag((uint64_t)v18, *(unsigned int *)(v3 + 364), 2), (_DWORD)result))
                                            {
                                              if (a3
                                                || !*(_QWORD *)(v3 + 240)
                                                || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612726), (_DWORD)result)
                                                && (result = CBB_add_asn1_octet_string((uint64_t)v18, *(const void **)(v3 + 232), *(_QWORD *)(v3 + 240)), (_DWORD)result))
                                              {
                                                if ((*(_BYTE *)(v3 + 424) & 2) == 0
                                                  || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612723),
                                                      (_DWORD)result)
                                                  && (result = CBB_add_asn1_octet_string((uint64_t)v18, (const void *)(v3 + 264), 0x20uLL), (_DWORD)result))
                                                {
                                                  if (!*(_BYTE *)(v3 + 360)
                                                    || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612722),
                                                        (_DWORD)result)
                                                    && (result = CBB_add_asn1_octet_string((uint64_t)v18, (const void *)(v3 + 296), *(unsigned __int8 *)(v3 + 360)), (_DWORD)result))
                                                  {
                                                    if (!*(_QWORD *)(v3 + 248)
                                                      || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612721),
                                                          (_DWORD)result)
                                                      && (result = CBB_add_asn1_octet_string((uint64_t)v18, *(const void **)(*(_QWORD *)(v3 + 248) + 8), *(_QWORD *)(*(_QWORD *)(v3 + 248) + 16)), (_DWORD)result))
                                                    {
                                                      if (!*(_QWORD *)(v3 + 256)
                                                        || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612720),
                                                            (_DWORD)result)
                                                        && (result = CBB_add_asn1_octet_string((uint64_t)v18, *(const void **)(*(_QWORD *)(v3 + 256) + 8), *(_QWORD *)(*(_QWORD *)(v3 + 256) + 16)), (_DWORD)result))
                                                      {
                                                        if ((*(_BYTE *)(v3 + 424) & 1) == 0
                                                          || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612719),
                                                              (_DWORD)result)
                                                          && (result = CBB_add_asn1_BOOL((uint64_t)v18, 1), (_DWORD)result))
                                                        {
                                                          if (!*(_WORD *)(v3 + 6)
                                                            || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612718),
                                                                (_DWORD)result)
                                                            && (result = CBB_add_asn1_uint64_with_tag((uint64_t)v18, *(unsigned __int16 *)(v3 + 6), 2), (_DWORD)result))
                                                          {
                                                            v11 = *(_QWORD **)(v3 + 136);
                                                            v12 = *(_BYTE *)(v3 + 424);
                                                            if (v11 && (*(_BYTE *)(v3 + 424) & 2) == 0 && *v11 >= 2uLL)
                                                            {
                                                              result = CBB_add_asn1(v19, (uint64_t)v18, -1610612717);
                                                              if (!(_DWORD)result)
                                                                return result;
                                                              for (i = 1; ; ++i)
                                                              {
                                                                v14 = *(unint64_t **)(v3 + 136);
                                                                if (!v14 || i >= *v14)
                                                                  break;
                                                                v15 = *(_QWORD *)(v14[1] + 8 * i);
                                                                v16 = CBB_add_bytes((uint64_t)v18, *(const void **)(v15 + 8), *(_QWORD *)(v15 + 16));
                                                                result = 0;
                                                                if (!v16)
                                                                  return result;
                                                              }
                                                              v12 = *(_BYTE *)(v3 + 424);
                                                            }
                                                            if ((v12 & 8) != 0)
                                                            {
                                                              result = CBB_add_asn1(v19, (uint64_t)v18, -1610612715);
                                                              if (!(_DWORD)result)
                                                                return result;
                                                              result = CBB_add_asn1(v18, (uint64_t)v17, 4);
                                                              if (!(_DWORD)result)
                                                                return result;
                                                              result = CBB_add_u32((uint64_t)v17, *(_DWORD *)(v3 + 368));
                                                              if (!(_DWORD)result)
                                                                return result;
                                                              if ((*(_BYTE *)(v3 + 424) & 0x10) != 0)
                                                                goto LABEL_80;
                                                            }
                                                            else if ((v12 & 0x10) != 0)
                                                            {
LABEL_80:
                                                              if (!*(_WORD *)(v3 + 8)
                                                                || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612713), (_DWORD)result)&& (result = CBB_add_asn1_uint64_with_tag((uint64_t)v18, *(unsigned __int16 *)(v3 + 8), 2), (_DWORD)result))
                                                              {
                                                                if (!*(_DWORD *)(v3 + 372)
                                                                  || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612712), (_DWORD)result)&& (result = CBB_add_asn1_uint64_with_tag((uint64_t)v18, *(unsigned int *)(v3 + 372), 2), (_DWORD)result))
                                                                {
                                                                  if (*(_DWORD *)(v3 + 184) == *(_DWORD *)(v3 + 188)
                                                                    || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612711), (_DWORD)result)&& (result = CBB_add_asn1_uint64_with_tag((uint64_t)v18, *(unsigned int *)(v3 + 188), 2), (_DWORD)result))
                                                                  {
                                                                    if (!*(_QWORD *)(v3 + 384)
                                                                      || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612710), (_DWORD)result)&& (result = CBB_add_asn1_octet_string((uint64_t)v18, *(const void **)(v3 + 376), *(_QWORD *)(v3 + 384)), (_DWORD)result))
                                                                    {
                                                                      if ((*(_BYTE *)(v3 + 424) & 0x20) == 0
                                                                        || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612709), (_DWORD)result)&& (result = CBB_add_asn1_BOOL((uint64_t)v18, 1), (_DWORD)result))
                                                                      {
                                                                        if (!*(_QWORD *)(v3 + 440)
                                                                          || (result = CBB_add_asn1(v19, (uint64_t)v18, -1610612708), (_DWORD)result)&& (result = CBB_add_asn1_octet_string((uint64_t)v18, *(const void **)(v3 + 432), *(_QWORD *)(v3 + 440)), (_DWORD)result))
                                                                        {
                                                                          if ((*(_BYTE *)(v3 + 424) & 0x40) == 0)
                                                                            return CBB_flush(a2);
                                                                          result = CBB_add_asn1(v19, (uint64_t)v18, -1610612707);
                                                                          if ((_DWORD)result)
                                                                          {
                                                                            result = CBB_add_asn1_octet_string((uint64_t)v18, *(const void **)(v3 + 392), *(_QWORD *)(v3 + 400));
                                                                            if ((_DWORD)result)
                                                                            {
                                                                              result = CBB_add_asn1(v19, (uint64_t)v18, -1610612706);
                                                                              if ((_DWORD)result)
                                                                              {
                                                                                result = CBB_add_asn1_octet_string((uint64_t)v18, *(const void **)(v3 + 408), *(_QWORD *)(v3 + 416));
                                                                                if ((_DWORD)result)
                                                                                  return CBB_flush(a2);
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                              return result;
                                                            }
                                                            result = CBB_add_asn1(v19, (uint64_t)v18, -1610612714);
                                                            if (!(_DWORD)result)
                                                              return result;
                                                            result = CBB_add_asn1_BOOL((uint64_t)v18, 0);
                                                            if (!(_DWORD)result)
                                                              return result;
                                                            goto LABEL_80;
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t SSL_SESSION_to_bytes_for_ticket(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v6;
  const char *v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v12;
  void *v13;
  _OWORD v14[3];

  memset(v14, 0, sizeof(v14));
  v6 = malloc_type_malloc(0x108uLL, 0x30772F57uLL);
  if (!v6)
  {
    v7 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v8 = 65;
    v9 = 247;
    goto LABEL_6;
  }
  *v6 = 256;
  BYTE8(v14[0]) = 0;
  *(_QWORD *)&v14[0] = 0;
  *(_QWORD *)&v14[1] = v6 + 1;
  *(_OWORD *)((char *)&v14[1] + 8) = xmmword_208F26740;
  BYTE8(v14[2]) = 1;
  if (!bssl::SSL_SESSION_to_bytes_full(a1, (uint64_t *)v14, 1))
  {
LABEL_7:
    v10 = 0;
    goto LABEL_8;
  }
  if (BYTE8(v14[0]))
  {
    v7 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cr"
         "ypto/bytestring/cbb.c";
    v8 = 66;
    v9 = 127;
LABEL_6:
    ERR_put_error(14, 0, v8, v7, v9);
    goto LABEL_7;
  }
  if (!CBB_flush((uint64_t *)v14))
    goto LABEL_7;
  if ((BYTE8(v14[2]) & 1) != 0)
  {
    v10 = 0;
    if (!a2 || !a3)
      goto LABEL_8;
  }
  else if (!a2)
  {
    goto LABEL_22;
  }
  *a2 = *(_QWORD *)&v14[1];
LABEL_22:
  if (a3)
    *a3 = *((_QWORD *)&v14[1] + 1);
  *(_QWORD *)&v14[1] = 0;
  v10 = 1;
LABEL_8:
  if (BYTE8(v14[0]) || (BYTE8(v14[2]) & 1) == 0 || !*(_QWORD *)&v14[1])
    return v10;
  v13 = (void *)(*(_QWORD *)&v14[1] - 8);
  v12 = *(_QWORD *)(*(_QWORD *)&v14[1] - 8);
  if (v12 != -8)
    bzero(v13, v12 + 8);
  free(v13);
  return v10;
}

ssl_session_st *SSL_SESSION_from_bytes(unsigned __int8 *a1, uint64_t a2, uint64_t a3)
{
  ssl_session_st *v3;
  BOOL v4;
  unsigned int i;
  unsigned int v6;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v9;
  ssl_session_st *v11;
  unsigned __int8 *v12;
  uint64_t v13;

  v12 = a1;
  v13 = a2;
  bssl::SSL_SESSION_parse(&v12, *(_QWORD *)(a3 + 16), *(uint64_t **)(a3 + 704), &v11);
  v3 = v11;
  if (v11)
    v4 = v13 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    ERR_put_error(16, 0, 160, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_asn1.cc", 870);
    for (i = atomic_load((unsigned int *)v3); i != -1; i = v6)
    {
      if (!i)
        abort();
      v6 = __ldaxr((unsigned int *)v3);
      if (v6 == i)
      {
        if (!__stlxr(i - 1, (unsigned int *)v3))
        {
          if (i == 1)
          {
            ssl_session_st::~ssl_session_st(v3);
            tlsext_tick_lifetime_hint = v3[-1].tlsext_tick_lifetime_hint;
            p_tlsext_tick_lifetime_hint = &v3[-1].tlsext_tick_lifetime_hint;
            v9 = tlsext_tick_lifetime_hint + 8;
            if (tlsext_tick_lifetime_hint != -8)
              bzero(p_tlsext_tick_lifetime_hint, v9);
            free(p_tlsext_tick_lifetime_hint);
          }
          return 0;
        }
      }
      else
      {
        __clrex();
      }
    }
    return 0;
  }
  return v3;
}

uint64_t bssl::SSLBuffer::EnsureCap(void **this, int a2, unint64_t a3)
{
  char *v7;
  char *v8;
  uint64_t v9;
  size_t v10;

  if (a3 >= 0x10000)
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_buffer.cc", 52);
    return 0;
  }
  if (*((unsigned __int16 *)this + 6) >= a3)
    return 1;
  if (a3 <= 5)
  {
    v9 = 0;
    v8 = (char *)this + 14;
    v10 = *((unsigned __int16 *)this + 5);
    if (!*((_WORD *)this + 5))
    {
LABEL_10:
      if (*((_BYTE *)this + 19))
        free(*this);
      *this = v8;
      *((_BYTE *)this + 19) = a3 > 5;
      *((_WORD *)this + 4) = v9;
      *((_WORD *)this + 6) = a3;
      return 1;
    }
LABEL_9:
    memmove(&v8[v9], (char *)*this + *((unsigned __int16 *)this + 4), v10);
    goto LABEL_10;
  }
  v7 = (char *)malloc_type_malloc(a3 + 7, 0x4E81ED8uLL);
  if (v7)
  {
    v8 = v7;
    v9 = (-a2 - (int)v7) & 7;
    v10 = *((unsigned __int16 *)this + 5);
    if (!*((_WORD *)this + 5))
      goto LABEL_10;
    goto LABEL_9;
  }
  ERR_put_error(16, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_buffer.cc", 77);
  return 0;
}

uint64_t bssl::ssl_read_buffer_extend_to(bssl *this, ssl_st *a2)
{
  uint64_t v4;
  void **v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v15)(_QWORD, _QWORD);
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(_QWORD, unint64_t);
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  void **v25;

  v4 = *((_QWORD *)this + 6);
  if (!*(_WORD *)(v4 + 90))
  {
    v5 = (void **)(v4 + 80);
    if (*(_BYTE *)(v4 + 99))
      free(*v5);
    *(_BYTE *)(v4 + 99) = 0;
    *v5 = 0;
    *(_QWORD *)(v4 + 86) = 0;
    v4 = *((_QWORD *)this + 6);
  }
  if (**(_BYTE **)this)
    v6 = 16717;
  else
    v6 = (unint64_t)a2;
  v7 = *(_QWORD *)(v4 + 264);
  if ((*(_BYTE *)(v7 + 609) & 1) != 0)
    v8 = *(unsigned __int8 *)(v7 + 605);
  else
    v8 = 0;
  v9 = 13;
  if (!**(_BYTE **)this)
    v9 = 5;
  if (!bssl::SSLBuffer::EnsureCap((void **)(v4 + 80), v8 + v9, v6))
    return 0xFFFFFFFFLL;
  v10 = *((_QWORD *)this + 3);
  if (!v10)
  {
    ERR_put_error(16, 0, 119, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_buffer.cc", 187);
    return 0xFFFFFFFFLL;
  }
  v11 = *((_QWORD *)this + 6);
  if (!**(_BYTE **)this)
  {
    if (v6 > *(unsigned __int16 *)(v11 + 92))
    {
      ERR_put_error(16, 0, 121, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_buffer.cc", 149);
      v12 = 0xFFFFFFFFLL;
      v13 = *((_QWORD *)this + 6);
      if (*(_WORD *)(v13 + 90))
        return v12;
      goto LABEL_46;
    }
    v18 = *(unsigned __int16 *)(v11 + 90);
    if (v6 <= v18)
      return 1;
    while (1)
    {
      v19 = *((_QWORD *)this + 3);
      if (!v19)
        goto LABEL_41;
      if (!*(_QWORD *)v19)
        goto LABEL_41;
      v20 = *(uint64_t (**)(_QWORD, unint64_t))(*(_QWORD *)v19 + 24);
      if (!v20)
        goto LABEL_41;
      if (!*(_DWORD *)(v19 + 16))
        goto LABEL_43;
      if ((int)v6 - (int)v18 < 1)
        goto LABEL_49;
      v21 = v20(*((_QWORD *)this + 3), *(_QWORD *)(v11 + 80) + *(unsigned __int16 *)(v11 + 88) + v18);
      v12 = v21;
      if ((int)v21 <= 0)
        goto LABEL_45;
      *(_QWORD *)(v19 + 56) += v21;
      v22 = *(unsigned __int16 *)(v11 + 90);
      if ((unint64_t)*(unsigned __int16 *)(v11 + 92) - v22 < v21)
        goto LABEL_51;
      LOWORD(v18) = v22 + v21;
      *(_WORD *)(v11 + 90) = v18;
      v18 = (unsigned __int16)v18;
      v12 = 1;
      if (v6 <= (unsigned __int16)v18)
        return v12;
    }
  }
  if (*(_WORD *)(v11 + 90))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_buffer.cc", 130);
    v12 = 0xFFFFFFFFLL;
    v13 = *((_QWORD *)this + 6);
    if (*(_WORD *)(v13 + 90))
      return v12;
    goto LABEL_46;
  }
  if (!*(_QWORD *)v10 || (v15 = *(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v10 + 24)) == 0)
  {
LABEL_41:
    v23 = 115;
    v24 = 129;
LABEL_44:
    ERR_put_error(17, 0, v23, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v24);
    v12 = 4294967294;
LABEL_45:
    *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 2;
    v13 = *((_QWORD *)this + 6);
    if (*(_WORD *)(v13 + 90))
      return v12;
    goto LABEL_46;
  }
  if (!*(_DWORD *)(v10 + 16))
  {
LABEL_43:
    v23 = 114;
    v24 = 133;
    goto LABEL_44;
  }
  if (*(_WORD *)(v11 + 92))
  {
    v16 = v15(*((_QWORD *)this + 3), *(_QWORD *)(v11 + 80) + *(unsigned __int16 *)(v11 + 88));
    v12 = v16;
    if ((int)v16 > 0)
    {
      *(_QWORD *)(v10 + 56) += v16;
      v17 = *(unsigned __int16 *)(v11 + 90);
      if ((unint64_t)*(unsigned __int16 *)(v11 + 92) - v17 < v16)
LABEL_51:
        abort();
      *(_WORD *)(v11 + 90) = v17 + v16;
      return 1;
    }
    goto LABEL_45;
  }
LABEL_49:
  v12 = 0;
  *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 2;
  v13 = *((_QWORD *)this + 6);
  if (*(_WORD *)(v13 + 90))
    return v12;
LABEL_46:
  v25 = (void **)(v13 + 80);
  if (*(_BYTE *)(v13 + 99))
    free(*v25);
  *(_BYTE *)(v13 + 99) = 0;
  *v25 = 0;
  *(_QWORD *)(v13 + 86) = 0;
  return v12;
}

uint64_t bssl::ssl_handle_open_record(bssl *this, _BYTE *a2, int a3, ssl_st *a4, int a5)
{
  uint64_t v10;
  unint64_t v11;
  void **v12;
  uint64_t result;

  *a2 = 0;
  v10 = *((_QWORD *)this + 6);
  v11 = *(unsigned __int16 *)(v10 + 90);
  if (a3 == 2)
    goto LABEL_4;
  if (v11 < (unint64_t)a4)
    abort();
  *(_WORD *)(v10 + 88) += (_WORD)a4;
  LOWORD(v11) = v11 - (_WORD)a4;
  *(_WORD *)(v10 + 90) = v11;
  *(_WORD *)(v10 + 92) -= (_WORD)a4;
  if (!a3)
    return 1;
LABEL_4:
  if (!(_WORD)v11)
  {
    v12 = (void **)(v10 + 80);
    if (*(_BYTE *)(v10 + 99))
      free(*v12);
    *(_BYTE *)(v10 + 99) = 0;
    *v12 = 0;
    *(_QWORD *)(v10 + 86) = 0;
  }
  result = 1;
  switch(a3)
  {
    case 0:
      return result;
    case 1:
      goto LABEL_11;
    case 2:
      result = bssl::ssl_read_buffer_extend_to(this, a4);
      if ((int)result >= 1)
      {
        result = 1;
LABEL_11:
        *a2 = 1;
      }
      return result;
    case 3:
      result = 0;
      *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 6;
      return result;
    case 4:
      if (a5)
        bssl::ssl_send_alert(this, (ssl_st *)2, a5);
      goto LABEL_17;
    default:
LABEL_17:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t bssl::ssl_write_buffer_flush(bssl *this, ssl_st *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 v6;
  uint64_t (*v7)(_QWORD, _QWORD);
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  int v11;
  unsigned __int16 v13;
  uint64_t v14;
  uint64_t (*v15)(_QWORD, _QWORD, _QWORD);
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;

  v2 = *((_QWORD *)this + 4);
  if (!v2)
  {
    ERR_put_error(16, 0, 119, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_buffer.cc", 296);
    return 0xFFFFFFFFLL;
  }
  v4 = *((_QWORD *)this + 6);
  v5 = v4 + 104;
  v6 = *(_WORD *)(v4 + 114);
  if (**(_BYTE **)this)
  {
    if (*(_WORD *)(v4 + 114))
    {
      if (*(_QWORD *)v2 && (v7 = *(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v2 + 16)) != 0)
      {
        if (*(_DWORD *)(v2 + 16))
        {
          v8 = v7(*((_QWORD *)this + 4), *(_QWORD *)(v4 + 104) + *(unsigned __int16 *)(v4 + 112));
          v9 = v8;
          if ((int)v8 > 0)
          {
            *(_QWORD *)(v2 + 64) += v8;
            v11 = *(unsigned __int8 *)(v4 + 123);
            v10 = (_BYTE *)(v4 + 123);
            v9 = 1;
            if (!v11)
              goto LABEL_27;
            goto LABEL_26;
          }
LABEL_25:
          *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 3;
          v21 = *(unsigned __int8 *)(v4 + 123);
          v10 = (_BYTE *)(v4 + 123);
          if (!v21)
          {
LABEL_27:
            *v10 = 0;
            *(_QWORD *)(v5 + 6) = 0;
            *(_QWORD *)v5 = 0;
            return v9;
          }
LABEL_26:
          free(*(void **)v5);
          goto LABEL_27;
        }
        v19 = 114;
        v20 = 171;
      }
      else
      {
        v19 = 115;
        v20 = 167;
      }
      ERR_put_error(17, 0, v19, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v20);
      v9 = 4294967294;
      goto LABEL_25;
    }
    return 1;
  }
  else if (*(_WORD *)(v4 + 114))
  {
    v13 = *(_WORD *)(v4 + 112);
    while (1)
    {
      v14 = *((_QWORD *)this + 4);
      if (!v14
        || !*(_QWORD *)v14
        || (v15 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)v14 + 16)) == 0)
      {
        v22 = 115;
        v23 = 167;
        goto LABEL_32;
      }
      if (!*(_DWORD *)(v14 + 16))
        break;
      v16 = v15(*((_QWORD *)this + 4), *(_QWORD *)v5 + v13, v6);
      v17 = v16;
      if ((int)v16 <= 0)
        goto LABEL_33;
      *(_QWORD *)(v14 + 64) += v16;
      v18 = *(unsigned __int16 *)(v4 + 114);
      if (v16 > v18)
        abort();
      v13 = *(_WORD *)(v4 + 112) + v16;
      *(_WORD *)(v4 + 112) = v13;
      v6 = v18 - v16;
      *(_WORD *)(v4 + 114) = v18 - v16;
      *(_WORD *)(v4 + 116) -= v16;
      if ((_WORD)v18 == (_WORD)v16)
        goto LABEL_20;
    }
    v22 = 114;
    v23 = 171;
LABEL_32:
    ERR_put_error(17, 0, v22, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v23);
    v17 = 4294967294;
LABEL_33:
    *(_DWORD *)(*((_QWORD *)this + 6) + 196) = 3;
    return v17;
  }
  else
  {
LABEL_20:
    if (*(_BYTE *)(v4 + 123))
      free(*(void **)v5);
    *(_BYTE *)(v4 + 123) = 0;
    *(_QWORD *)v5 = 0;
    *(_QWORD *)(v4 + 110) = 0;
    return 1;
  }
}

void bssl::CERT::~CERT(bssl::CERT *this)
{
  unsigned int *v2;
  unsigned int i;
  unsigned int v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t j;
  unsigned int *v8;
  unsigned int k;
  unsigned int v10;
  unsigned int *v11;
  uint64_t v12;
  size_t v13;
  unsigned int *v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  size_t v20;

  (*(void (**)(void))(*((_QWORD *)this + 4) + 16))();
  v2 = (unsigned int *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v2)
  {
    for (i = atomic_load(v2); i != -1; i = v4)
    {
      if (!i)
LABEL_34:
        abort();
      v4 = __ldaxr(v2);
      if (v4 == i)
      {
        if (!__stlxr(i - 1, v2))
        {
          if (i != 1)
            break;
          ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v2);
          v15 = *((_QWORD *)v2 - 1);
          v14 = v2 - 2;
          v16 = v15 + 8;
          if (v15 != -8)
            bzero(v14, v16);
          free(v14);
          v5 = (uint64_t *)((char *)this + 8);
          v6 = *((_QWORD *)this + 2);
          if (v6)
            goto LABEL_11;
          goto LABEL_29;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  v5 = (uint64_t *)((char *)this + 8);
  v6 = *((_QWORD *)this + 2);
  if (v6)
  {
LABEL_11:
    for (j = 0; j < v6; ++j)
    {
      v8 = *(unsigned int **)(*v5 + 8 * j);
      *(_QWORD *)(*v5 + 8 * j) = 0;
      if (v8)
      {
        for (k = atomic_load(v8); k != -1; k = v10)
        {
          if (!k)
            goto LABEL_34;
          v10 = __ldaxr(v8);
          if (v10 == k)
          {
            if (!__stlxr(k - 1, v8))
            {
              if (k == 1)
              {
                ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v8);
                v12 = *((_QWORD *)v8 - 1);
                v11 = v8 - 2;
                v13 = v12 + 8;
                if (v12 != -8)
                  bzero(v11, v13);
                free(v11);
              }
              break;
            }
          }
          else
          {
            __clrex();
          }
        }
        v6 = *((_QWORD *)this + 2);
      }
    }
  }
LABEL_29:
  v17 = *v5;
  if (*v5)
  {
    v19 = *(_QWORD *)(v17 - 8);
    v18 = (void *)(v17 - 8);
    v20 = v19 + 8;
    if (v19 != -8)
      bzero(v18, v20);
    free(v18);
  }
  *v5 = 0;
  v5[1] = 0;
}

void bssl::ssl_cert_dup(bssl *this@<X0>, unint64_t **a2@<X8>)
{
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *v8;
  char *v9;
  char *v10;
  unsigned int **v11;
  unsigned int **v12;
  unint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  unint64_t v17;
  unsigned int *v18;
  unsigned int j;
  unsigned int v20;
  unsigned int *v21;
  uint64_t v22;
  size_t v23;
  ssl_credential_st *v24;
  unsigned int *v25;
  unsigned int k;
  unsigned int v27;
  unsigned int *v28;
  unsigned int m;
  unsigned int v30;
  unsigned int *v31;
  uint64_t v32;
  size_t v33;
  unsigned int i;
  unsigned int v35;
  unsigned int *v36;
  uint64_t v37;
  size_t v38;
  unsigned int *v39;
  uint64_t v40;
  size_t v41;
  __int128 v42;
  unsigned int *v43;
  unsigned int n;
  unsigned int v45;
  unsigned int *v46;
  uint64_t v47;
  size_t v48;
  unint64_t v49;
  unint64_t ii;
  unint64_t v51;
  unsigned int *v52;
  unsigned int jj;
  unsigned int v54;
  unsigned int *v55;
  uint64_t v56;
  size_t v57;
  unint64_t v58;
  void *v59;
  uint64_t v60;
  size_t v61;
  ssl_credential_st *v62;

  v5 = (unint64_t *)malloc_type_malloc(0x88uLL, 0x30772F57uLL);
  if (!v5)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    *a2 = 0;
    return;
  }
  v6 = v5;
  *v5 = 128;
  v7 = *((_QWORD *)this + 4);
  v5[1] = 0;
  v5[2] = 0;
  v8 = v5 + 1;
  v5[3] = 0;
  v9 = (char *)malloc_type_malloc(0x68uLL, 0x30772F57uLL);
  if (v9)
  {
    *(_QWORD *)v9 = 96;
    *((_DWORD *)v9 + 2) = 1;
    v10 = v9 + 8;
    *((_QWORD *)v9 + 11) = 0;
    *((_QWORD *)v9 + 12) = 0;
    *((_QWORD *)v9 + 10) = 0;
    *(_OWORD *)(v9 + 12) = 0u;
    *(_OWORD *)(v9 + 28) = 0u;
    *(_OWORD *)(v9 + 44) = 0u;
    *(_OWORD *)(v9 + 58) = 0u;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v10 = 0;
  }
  v6[4] = (unint64_t)v10;
  v6[5] = v7;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 7) = 0u;
  *((_BYTE *)v6 + 128) = 0;
  if (*(_QWORD *)this)
  {
    v11 = (unsigned int **)*((_QWORD *)this + 1);
    v12 = &v11[*(_QWORD *)this];
    do
    {
      v14 = *v11;
      if (*v11)
      {
        v15 = atomic_load(v14);
        if (v15 != -1)
        {
          do
          {
            v16 = __ldaxr(v14);
            if (v16 == v15)
            {
              if (!__stlxr(v15 + 1, v14))
                break;
            }
            else
            {
              __clrex();
            }
            v15 = v16;
          }
          while (v16 != -1);
        }
        if (!bssl::GrowableArray<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::MaybeGrow(v8))
        {
          for (i = atomic_load(v14); i != -1; i = v35)
          {
            if (!i)
              goto LABEL_104;
            v35 = __ldaxr(v14);
            if (v35 == i)
            {
              if (!__stlxr(i - 1, v14))
              {
                if (i == 1)
                {
                  ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v14);
                  v37 = *((_QWORD *)v14 - 1);
                  v36 = v14 - 2;
                  v38 = v37 + 8;
                  if (v37 != -8)
                    bzero(v36, v38);
                  free(v36);
                }
                goto LABEL_69;
              }
            }
            else
            {
              __clrex();
            }
          }
          goto LABEL_69;
        }
      }
      else if ((bssl::GrowableArray<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::MaybeGrow(v8) & 1) == 0)
      {
        goto LABEL_69;
      }
      v13 = v6[1];
      v17 = v6[2];
      v18 = *(unsigned int **)(v17 + 8 * v13);
      *(_QWORD *)(v17 + 8 * v13) = v14;
      if (v18)
      {
        for (j = atomic_load(v18); j != -1; j = v20)
        {
          if (!j)
LABEL_104:
            abort();
          v20 = __ldaxr(v18);
          if (v20 == j)
          {
            if (!__stlxr(j - 1, v18))
            {
              if (j == 1)
              {
                ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v18);
                v22 = *((_QWORD *)v18 - 1);
                v21 = v18 - 2;
                v23 = v22 + 8;
                if (v22 != -8)
                  bzero(v21, v23);
                free(v21);
              }
              break;
            }
          }
          else
          {
            __clrex();
          }
        }
        v13 = *v8;
      }
      *v8 = v13 + 1;
      ++v11;
    }
    while (v11 != v12);
  }
  ssl_credential_st::Dup(*((ssl_credential_st **)this + 3), (unsigned int **)&v62);
  v24 = v62;
  v62 = 0;
  v25 = (unsigned int *)v6[4];
  v6[4] = (unint64_t)v24;
  if (!v25)
    goto LABEL_67;
  for (k = atomic_load(v25); ; k = v27)
  {
    if (k == -1)
      goto LABEL_41;
    if (!k)
      goto LABEL_104;
    v27 = __ldaxr(v25);
    if (v27 != k)
    {
      __clrex();
      continue;
    }
    if (!__stlxr(k - 1, v25))
      break;
  }
  if (k != 1)
  {
LABEL_41:
    v28 = (unsigned int *)v62;
    v62 = 0;
    if (!v28)
      goto LABEL_66;
    goto LABEL_42;
  }
  ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v25);
  v40 = *((_QWORD *)v25 - 1);
  v39 = v25 - 2;
  v41 = v40 + 8;
  if (v40 != -8)
    bzero(v39, v41);
  free(v39);
  v28 = (unsigned int *)v62;
  v62 = 0;
  if (!v28)
    goto LABEL_66;
LABEL_42:
  for (m = atomic_load(v28); m != -1; m = v30)
  {
    if (!m)
      goto LABEL_104;
    v30 = __ldaxr(v28);
    if (v30 == m)
    {
      if (!__stlxr(m - 1, v28))
      {
        if (m == 1)
        {
          ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v28);
          v32 = *((_QWORD *)v28 - 1);
          v31 = v28 - 2;
          v33 = v32 + 8;
          if (v32 != -8)
            bzero(v31, v33);
          free(v31);
        }
        break;
      }
    }
    else
    {
      __clrex();
    }
  }
LABEL_66:
  v24 = (ssl_credential_st *)v6[4];
LABEL_67:
  if (v24)
  {
    *(_OWORD *)(v6 + 9) = *((_OWORD *)this + 4);
    (*(void (**)(unint64_t *, bssl *))(v6[5] + 24))(v8, this);
    *((_BYTE *)v6 + 96) = *((_BYTE *)this + 88);
    v42 = *(_OWORD *)((char *)this + 89);
    *(_OWORD *)((char *)v6 + 113) = *(_OWORD *)((char *)this + 105);
    *(_OWORD *)((char *)v6 + 97) = v42;
    *a2 = v8;
    return;
  }
LABEL_69:
  *a2 = 0;
  (*(void (**)(unint64_t *))(v6[5] + 16))(v8);
  v43 = (unsigned int *)v6[4];
  v6[4] = 0;
  if (v43)
  {
    for (n = atomic_load(v43); n != -1; n = v45)
    {
      if (!n)
        goto LABEL_104;
      v45 = __ldaxr(v43);
      if (v45 == n)
      {
        if (!__stlxr(n - 1, v43))
        {
          if (n == 1)
          {
            ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v43);
            v47 = *((_QWORD *)v43 - 1);
            v46 = v43 - 2;
            v48 = v47 + 8;
            if (v47 != -8)
              bzero(v46, v48);
            free(v46);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  v49 = v6[3];
  if (v49)
  {
    for (ii = 0; ii < v49; ++ii)
    {
      v51 = v6[2];
      v52 = *(unsigned int **)(v51 + 8 * ii);
      *(_QWORD *)(v51 + 8 * ii) = 0;
      if (v52)
      {
        for (jj = atomic_load(v52); jj != -1; jj = v54)
        {
          if (!jj)
            goto LABEL_104;
          v54 = __ldaxr(v52);
          if (v54 == jj)
          {
            if (!__stlxr(jj - 1, v52))
            {
              if (jj == 1)
              {
                ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v52);
                v56 = *((_QWORD *)v52 - 1);
                v55 = v52 - 2;
                v57 = v56 + 8;
                if (v56 != -8)
                  bzero(v55, v57);
                free(v55);
              }
              break;
            }
          }
          else
          {
            __clrex();
          }
        }
        v49 = v6[3];
      }
    }
  }
  v58 = v6[2];
  if (v58)
  {
    v60 = *(_QWORD *)(v58 - 8);
    v59 = (void *)(v58 - 8);
    v61 = v60 + 8;
    if (v60 != -8)
      bzero(v59, v61);
    free(v59);
  }
  if (*v6 != -8)
    __memset_chk();
  free(v6);
}

uint64_t bssl::ssl_parse_cert_chain(_BYTE *a1, unint64_t **a2, unsigned int **a3, _DWORD *a4, unint64_t *a5, uint64_t *a6)
{
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int *v15;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  size_t v19;
  unint64_t *v20;
  uint64_t v21;
  size_t v22;
  unsigned int *v23;
  unsigned int i;
  unsigned int v25;
  unint64_t v26;
  BOOL v27;
  unint64_t v28;
  unsigned __int8 *v29;
  char *v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t result;
  unint64_t *v34;
  unsigned int *v35;
  unint64_t v36;
  size_t v37;
  char *v38;
  unsigned int *v39;
  unsigned int j;
  unsigned int v41;
  uint64_t v42;
  void (*v43)(unsigned int *);
  unsigned int *v44;
  uint64_t v45;
  size_t v46;
  char *v47;
  unsigned int *v48;
  unint64_t *v49;
  unint64_t v50;
  unint64_t v51;
  unsigned int *v52;
  uint64_t v53;
  void (*v54)(unsigned int *);
  unsigned int *v55;
  uint64_t v56;
  size_t v57;
  unint64_t v58;
  unsigned int k;
  unsigned int v60;
  uint64_t v61;
  void (*v62)(unsigned int *);
  unsigned int *v63;
  uint64_t v64;
  size_t v65;
  unint64_t v66;
  void *v67;
  uint64_t v68;
  size_t v69;
  unint64_t *v70;
  uint64_t v71;
  size_t v72;
  unsigned int *v73;
  unsigned int m;
  unsigned int v75;
  uint64_t v76;
  void (*v77)(unsigned int *);
  unsigned int *v78;
  uint64_t v79;
  size_t v80;
  unint64_t v81;
  unint64_t v82;
  unsigned int *v83;
  unint64_t v84;
  void *v85;
  uint64_t v86;
  size_t v87;
  unint64_t *v88;
  uint64_t v89;
  size_t v90;
  _DWORD *v91;
  unsigned __int8 *v92[2];
  SHA256_CTX c;
  uint64_t v94;

  v94 = *MEMORY[0x24BDAC8D0];
  v12 = *a2;
  *a2 = 0;
  if (v12)
  {
    v13 = *v12;
    if (*v12)
    {
      v14 = 0;
      do
      {
        v15 = *(unsigned int **)(v12[1] + 8 * v14);
        if (v15)
        {
          CRYPTO_BUFFER_free(v15);
          v13 = *v12;
        }
        ++v14;
      }
      while (v14 < v13);
    }
    v16 = v12[1];
    if (v16)
    {
      v18 = *(_QWORD *)(v16 - 8);
      v17 = (void *)(v16 - 8);
      v19 = v18 + 8;
      if (v18 != -8)
        bzero(v17, v19);
      free(v17);
    }
    v21 = *(v12 - 1);
    v20 = v12 - 1;
    v22 = v21 + 8;
    if (v21 != -8)
      bzero(v20, v22);
    free(v20);
  }
  v23 = *a3;
  *a3 = 0;
  if (!v23)
  {
LABEL_23:
    v26 = a5[1];
    v27 = v26 >= 3;
    v28 = v26 - 3;
    if (!v27)
      goto LABEL_26;
    goto LABEL_25;
  }
  for (i = atomic_load(v23); ; i = v25)
  {
    if (i == -1)
      goto LABEL_23;
    if (!i)
LABEL_128:
      abort();
    v25 = __ldaxr(v23);
    if (v25 != i)
    {
      __clrex();
      continue;
    }
    if (!__stlxr(i - 1, v23))
      break;
  }
  if (i != 1)
    goto LABEL_23;
  v53 = *((_QWORD *)v23 + 2);
  if (v53)
  {
    v54 = *(void (**)(unsigned int *))(v53 + 160);
    if (v54)
    {
      v54(v23);
      *((_QWORD *)v23 + 1) = 0;
      v23[1] = 0;
    }
  }
  v56 = *((_QWORD *)v23 - 1);
  v55 = v23 - 2;
  v57 = v56 + 8;
  if (v56 != -8)
    bzero(v55, v57);
  free(v55);
  v58 = a5[1];
  v27 = v58 >= 3;
  v28 = v58 - 3;
  if (!v27)
  {
LABEL_26:
    *a1 = 50;
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", 234);
    return 0;
  }
LABEL_25:
  v29 = (unsigned __int8 *)*a5;
  v30 = (char *)(*a5 + 3);
  *a5 = (unint64_t)v30;
  a5[1] = v28;
  v31 = ((unint64_t)*v29 << 16) | ((unint64_t)v29[1] << 8) | v29[2];
  v27 = v28 >= v31;
  v32 = v28 - v31;
  if (!v27)
    goto LABEL_26;
  *a5 = (unint64_t)&v30[v31];
  a5[1] = v32;
  if (!v31)
    return 1;
  result = (uint64_t)OPENSSL_sk_new_null();
  if (!result)
  {
    *a1 = 80;
    return result;
  }
  v34 = (unint64_t *)result;
  v35 = 0;
  v91 = a4;
  while (2)
  {
    v36 = v31 - 3;
    if (v31 < 3
      || (v37 = ((unint64_t)*v30 << 16) | ((unint64_t)v30[1] << 8) | v30[2],
          v31 = v36 - v37,
          v36 < v37)
      || !v37)
    {
      *a1 = 50;
      ERR_put_error(16, 0, 127, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", 254);
      if (v35)
        goto LABEL_78;
      goto LABEL_116;
    }
    v38 = v30 + 3;
    if (!*v34)
    {
      *(_QWORD *)c.h = v30 + 3;
      *(_QWORD *)&c.h[2] = v37;
      if ((bssl::ssl_cert_skip_to_spki((__int128 *)&c, v92) & 1) != 0)
      {
        v39 = EVP_parse_public_key(v92);
        if (!v35)
          goto LABEL_53;
      }
      else
      {
        ERR_put_error(16, 0, 272, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", 333);
        v39 = 0;
        if (!v35)
          goto LABEL_53;
      }
      for (j = atomic_load(v35); j != -1; j = v41)
      {
        if (!j)
          goto LABEL_128;
        v41 = __ldaxr(v35);
        if (v41 == j)
        {
          if (!__stlxr(j - 1, v35))
          {
            if (j == 1)
            {
              v42 = *((_QWORD *)v35 + 2);
              if (v42)
              {
                v43 = *(void (**)(unsigned int *))(v42 + 160);
                if (v43)
                {
                  v43(v35);
                  *((_QWORD *)v35 + 1) = 0;
                  v35[1] = 0;
                }
              }
              v45 = *((_QWORD *)v35 - 1);
              v44 = v35 - 2;
              v46 = v45 + 8;
              if (v45 != -8)
                bzero(v44, v46);
              free(v44);
            }
            break;
          }
        }
        else
        {
          __clrex();
        }
      }
LABEL_53:
      if (!v39)
      {
        *a1 = 50;
        goto LABEL_116;
      }
      if (v91)
      {
        memset(&c.Nl, 0, 76);
        *(_OWORD *)c.h = xmmword_208F25B20;
        *(_OWORD *)&c.h[4] = xmmword_208F25B30;
        c.md_len = 32;
        SHA256_Update(&c, v38, v37);
        sha256_final_impl(v91, c.md_len, (int32x2_t *)&c);
      }
      v35 = v39;
    }
    v47 = crypto_buffer_new(v38, v37, 0, a6);
    if (!v47)
      goto LABEL_77;
    v48 = (unsigned int *)v47;
    if (!OPENSSL_sk_insert(v34, (uint64_t)v47, *v34))
    {
      CRYPTO_BUFFER_free(v48);
LABEL_77:
      *a1 = 80;
      if (v35)
      {
LABEL_78:
        for (k = atomic_load(v35); k != -1; k = v60)
        {
          if (!k)
            goto LABEL_128;
          v60 = __ldaxr(v35);
          if (v60 == k)
          {
            if (!__stlxr(k - 1, v35))
            {
              if (k == 1)
              {
                v61 = *((_QWORD *)v35 + 2);
                if (v61)
                {
                  v62 = *(void (**)(unsigned int *))(v61 + 160);
                  if (v62)
                  {
                    v62(v35);
                    *((_QWORD *)v35 + 1) = 0;
                    v35[1] = 0;
                  }
                }
                v64 = *((_QWORD *)v35 - 1);
                v63 = v35 - 2;
                v65 = v64 + 8;
                if (v64 != -8)
                  bzero(v63, v65);
                free(v63);
              }
              break;
            }
          }
          else
          {
            __clrex();
          }
        }
      }
LABEL_116:
      v81 = *v34;
      if (*v34)
      {
        v82 = 0;
        do
        {
          v83 = *(unsigned int **)(v34[1] + 8 * v82);
          if (v83)
          {
            CRYPTO_BUFFER_free(v83);
            v81 = *v34;
          }
          ++v82;
        }
        while (v82 < v81);
      }
      v84 = v34[1];
      if (v84)
      {
        v86 = *(_QWORD *)(v84 - 8);
        v85 = (void *)(v84 - 8);
        v87 = v86 + 8;
        if (v86 != -8)
          bzero(v85, v87);
        free(v85);
      }
      v89 = *(v34 - 1);
      v88 = v34 - 1;
      v90 = v89 + 8;
      if (v89 != -8)
        bzero(v88, v90);
      free(v88);
      return 0;
    }
    v30 = &v38[v37];
    if (v31)
      continue;
    break;
  }
  v49 = *a2;
  *a2 = v34;
  if (v49)
  {
    v50 = *v49;
    if (*v49)
    {
      v51 = 0;
      do
      {
        v52 = *(unsigned int **)(v49[1] + 8 * v51);
        if (v52)
        {
          CRYPTO_BUFFER_free(v52);
          v50 = *v49;
        }
        ++v51;
      }
      while (v51 < v50);
    }
    v66 = v49[1];
    if (v66)
    {
      v68 = *(_QWORD *)(v66 - 8);
      v67 = (void *)(v66 - 8);
      v69 = v68 + 8;
      if (v68 != -8)
        bzero(v67, v69);
      free(v67);
    }
    v71 = *(v49 - 1);
    v70 = v49 - 1;
    v72 = v71 + 8;
    if (v71 != -8)
      bzero(v70, v72);
    free(v70);
  }
  v73 = *a3;
  *a3 = v35;
  if (v73)
  {
    for (m = atomic_load(v73); m != -1; m = v75)
    {
      if (!m)
        goto LABEL_128;
      v75 = __ldaxr(v73);
      if (v75 == m)
      {
        if (!__stlxr(m - 1, v73))
        {
          if (m == 1)
          {
            v76 = *((_QWORD *)v73 + 2);
            if (v76)
            {
              v77 = *(void (**)(unsigned int *))(v76 + 160);
              if (v77)
              {
                v77(v73);
                *((_QWORD *)v73 + 1) = 0;
                v73[1] = 0;
              }
            }
            v79 = *((_QWORD *)v73 - 1);
            v78 = v73 - 2;
            v80 = v79 + 8;
            if (v79 != -8)
              bzero(v78, v80);
            free(v78);
          }
          return 1;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  return 1;
}

uint64_t bssl::ssl_cert_skip_to_spki(__int128 *a1, unsigned __int8 **a2)
{
  uint64_t result;
  unint64_t *v4;
  unint64_t *v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  int any_asn1_element;
  unsigned __int8 *v10;
  unint64_t v11;
  __int128 v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  unint64_t v16;

  v12 = *a1;
  v13 = 0;
  LODWORD(v16) = 0;
  if (!cbs_get_any_asn1_element((unsigned __int8 **)&v12, &v10, &v16, &v13, 0, 0, 0)
    || (_DWORD)v16 != 536870928
    || v11 < v13)
  {
    return 0;
  }
  v10 += v13;
  v11 -= v13;
  if (*((_QWORD *)&v12 + 1))
    return 0;
  v16 = 0;
  v15 = 0;
  v13 = 0;
  v14 = 0;
  if (a2)
    v4 = (unint64_t *)a2;
  else
    v4 = &v13;
  if (!cbs_get_any_asn1_element(&v10, v4, &v15, &v16, 0, 0, 0) || v15 != 536870928)
    return 0;
  v5 = &v13;
  if (a2)
    v5 = (unint64_t *)a2;
  v6 = v5[1];
  v7 = v6 >= v16;
  v8 = v6 - v16;
  if (!v7)
    return 0;
  *v4 += v16;
  v5[1] = v8;
  result = CBS_get_optional_asn1(a2, 0, 0, -1610612736);
  if ((_DWORD)result)
  {
    v16 = 0;
    v15 = 0;
    v13 = 0;
    v14 = 0;
    if (cbs_get_any_asn1_element(a2, &v13, &v15, &v16, 0, 0, 0) && v15 == 2 && v14 >= v16)
    {
      v16 = 0;
      v15 = 0;
      v13 = 0;
      v14 = 0;
      if (cbs_get_any_asn1_element(a2, &v13, &v15, &v16, 0, 0, 0) && v15 == 536870928 && v14 >= v16)
      {
        v16 = 0;
        v15 = 0;
        v13 = 0;
        v14 = 0;
        if (cbs_get_any_asn1_element(a2, &v13, &v15, &v16, 0, 0, 0) && v15 == 536870928 && v14 >= v16)
        {
          v16 = 0;
          v15 = 0;
          v13 = 0;
          v14 = 0;
          if (cbs_get_any_asn1_element(a2, &v13, &v15, &v16, 0, 0, 0)
            && v15 == 536870928
            && v14 >= v16)
          {
            v16 = 0;
            v15 = 0;
            v13 = 0;
            v14 = 0;
            any_asn1_element = cbs_get_any_asn1_element(a2, &v13, &v15, &v16, 0, 0, 0);
            result = 0;
            if (any_asn1_element)
            {
              if (v15 == 536870928)
                return v14 >= v16;
            }
          }
          else
          {
            return 0;
          }
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t bssl::ssl_compare_public_and_private_key(bssl *this, const evp_pkey_st *a2, const evp_pkey_st *a3)
{
  char *ptr;
  unsigned int (*v6)(const evp_pkey_st *);
  uint64_t result;
  uint64_t v8;
  uint64_t (*v9)(bssl *, const evp_pkey_st *, const evp_pkey_st *);
  int v10;
  uint64_t (*v11)(bssl *, const evp_pkey_st *, const evp_pkey_st *);
  int v12;
  int v13;
  int v14;

  ptr = a2->pkey.ptr;
  if (ptr)
  {
    v6 = (unsigned int (*)(const evp_pkey_st *))*((_QWORD *)ptr + 14);
    if (v6)
    {
      if (v6(a2))
        return 1;
    }
  }
  if (*((_DWORD *)this + 1) == a2->save_type)
  {
    v8 = *((_QWORD *)this + 2);
    if (v8)
    {
      v9 = *(uint64_t (**)(bssl *, const evp_pkey_st *, const evp_pkey_st *))(v8 + 152);
      if (v9)
      {
        v10 = v9(this, a2, a3);
        if (v10 < 1)
          goto LABEL_12;
        v8 = *((_QWORD *)this + 2);
      }
      v11 = *(uint64_t (**)(bssl *, const evp_pkey_st *, const evp_pkey_st *))(v8 + 40);
      if (v11)
      {
        v10 = v11(this, a2, a3);
LABEL_12:
        v12 = v10 + 2;
        result = 1;
        switch(v12)
        {
          case 0:
            goto LABEL_13;
          case 1:
            goto LABEL_14;
          case 2:
            v13 = 116;
            v14 = 352;
            goto LABEL_15;
          case 3:
            return result;
          default:
            return 0;
        }
        return result;
      }
    }
LABEL_13:
    v13 = 128;
    v14 = 358;
  }
  else
  {
LABEL_14:
    v13 = 115;
    v14 = 355;
  }
LABEL_15:
  ERR_put_error(11, 0, v13, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", v14);
  return 0;
}

uint64_t bssl::ssl_cert_check_key_usage(__int128 *a1, unsigned int a2)
{
  int v3;
  int v4;
  uint64_t result;
  unint64_t v6;
  unsigned __int8 *v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  unsigned __int8 *v11;
  unint64_t v12;
  int v13;
  unsigned __int8 *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unsigned __int8 *v19;
  unint64_t v20;
  unsigned __int8 *v21;
  unint64_t v22;
  int v23;
  unsigned __int8 *v24[2];
  unsigned __int8 *v25[2];
  __int128 v26;
  unint64_t v27;
  unsigned __int8 *v28;
  int v29;
  unint64_t v30;

  v26 = *a1;
  v23 = 0;
  if (!bssl::ssl_cert_skip_to_spki(&v26, v25)
    || (v24[0] = 0,
        LODWORD(v21) = 0,
        v27 = 0,
        v28 = 0,
        !cbs_get_any_asn1_element(v25, &v27, &v21, (unint64_t *)v24, 0, 0, 0))
    || (_DWORD)v21 != 536870928
    || v28 < v24[0]
    || !CBS_get_optional_asn1(v25, 0, 0, -2147483647)
    || !CBS_get_optional_asn1(v25, 0, 0, -2147483646)
    || !CBS_get_optional_asn1(v25, v24, &v23, -1610612733))
  {
    v3 = 272;
    v4 = 383;
    goto LABEL_14;
  }
  if (!v23)
    return 1;
  v27 = 0;
  LODWORD(v19) = 0;
  if (cbs_get_any_asn1_element(v24, &v21, &v19, &v27, 0, 0, 0)
    && (_DWORD)v19 == 536870928
    && v22 >= v27)
  {
    v21 += v27;
    v22 -= v27;
    if (v22)
    {
      while (1)
      {
        v27 = 0;
        LODWORD(v30) = 0;
        if (!cbs_get_any_asn1_element(&v21, &v19, &v30, &v27, 0, 0, 0)
          || (_DWORD)v30 != 536870928
          || v20 < v27
          || (v19 += v27,
              v20 -= v27,
              v27 = 0,
              LODWORD(v30) = 0,
              !cbs_get_any_asn1_element(&v19, &v17, &v30, &v27, 0, 0, 0))
          || (_DWORD)v30 != 6
          || (v6 = v18 - v27, v18 < v27))
        {
LABEL_55:
          v3 = 272;
          v4 = 405;
          goto LABEL_14;
        }
        v7 = (unsigned __int8 *)(v17 + v27);
        v17 += v27;
        v18 -= v27;
        if (v20)
        {
          v8 = *v19;
          LODWORD(v9) = v8 & 0x1F;
          if ((_DWORD)v9 == 31)
          {
            v10 = 0;
            v11 = v19 + 1;
            v12 = v20 - 1;
            while (v12)
            {
              if (v10 >> 57)
                break;
              v13 = *v11;
              if (!v10 && v13 == 128)
                break;
              v9 = v13 & 0x7F | (v10 << 7);
              ++v11;
              --v12;
              v10 = v9;
              if ((v13 & 0x80) == 0)
              {
                if (v9 - 0x20000000 < 0xFFFFFFFFE000001FLL)
                  break;
                goto LABEL_36;
              }
            }
          }
          else
          {
LABEL_36:
            if ((v9 | (v8 << 24) & 0xE0000000) == 1)
            {
              v30 = 0;
              v29 = 0;
              v27 = 0;
              v28 = 0;
              if (!cbs_get_any_asn1_element(&v19, &v27, &v29, &v30, 0, 0, 0)
                || v29 != 1
                || (unint64_t)v28 < v30)
              {
                goto LABEL_55;
              }
            }
          }
        }
        v27 = 0;
        LODWORD(v30) = 0;
        if (!cbs_get_any_asn1_element(&v19, &v15, &v30, &v27, 0, 0, 0))
          goto LABEL_55;
        if ((_DWORD)v30 != 4)
          goto LABEL_55;
        if (v16 < v27)
          goto LABEL_55;
        v15 += v27;
        v16 -= v27;
        if (v20)
          goto LABEL_55;
        if (v6 == 3 && *(_WORD *)v7 == 7509 && v7[2] == 15)
          break;
        result = 1;
        if (!v22)
          return result;
      }
      if (!CBS_get_asn1(&v15, &v27, 3) || v16)
      {
        v3 = 272;
        v4 = 419;
      }
      else if (CBS_is_valid_asn1_bitstring((unsigned __int8 **)&v27))
      {
        if (CBS_asn1_bitstring_has_bit((unsigned __int8 **)&v27, a2))
          return 1;
        v3 = 302;
        v4 = 431;
      }
      else
      {
        v3 = 272;
        v4 = 426;
      }
      goto LABEL_14;
    }
    return 1;
  }
  v3 = 272;
  v4 = 393;
LABEL_14:
  ERR_put_error(16, 0, v3, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", v4);
  return 0;
}

void bssl::ssl_parse_client_CA_list(uint64_t a1@<X0>, _BYTE *a2@<X1>, _QWORD *a3@<X2>, unint64_t **a4@<X8>)
{
  uint64_t *v8;
  char *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unsigned int *v20;
  unint64_t v21;
  size_t v22;
  unsigned __int16 *v23;
  char *v24;
  unsigned int *v25;
  unint64_t v26;
  void *v27;
  uint64_t v28;
  size_t v29;
  unint64_t *v30;
  uint64_t v31;
  size_t v32;

  v8 = *(uint64_t **)(*(_QWORD *)(a1 + 104) + 704);
  v9 = OPENSSL_sk_new_null();
  if (!v9)
  {
    *a2 = 80;
    *a4 = 0;
    return;
  }
  v10 = (unint64_t *)v9;
  v11 = a3[1];
  v12 = v11 - 2;
  if (v11 >= 2
    && (v13 = (unsigned __int16 *)*a3,
        v14 = (unsigned __int16 *)(*a3 + 2),
        *a3 = v14,
        a3[1] = v12,
        v15 = __rev16(*v13),
        v16 = v12 >= v15,
        v17 = v12 - v15,
        v16))
  {
    *a3 = (char *)v14 + v15;
    a3[1] = v17;
    if (v15)
    {
      while (1)
      {
        v21 = v15 - 2;
        if (v15 < 2 || (v22 = __rev16(*v14), v15 = v21 - v22, v21 < v22))
        {
          *a2 = 50;
          ERR_put_error(16, 0, 123, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", 464);
          *a4 = 0;
          v18 = *v10;
          if (*v10)
            goto LABEL_5;
          goto LABEL_24;
        }
        v23 = v14 + 1;
        v24 = crypto_buffer_new(v14 + 1, v22, 0, v8);
        if (!v24)
          break;
        v25 = (unsigned int *)v24;
        if (!OPENSSL_sk_insert(v10, (uint64_t)v24, *v10))
        {
          CRYPTO_BUFFER_free(v25);
          break;
        }
        v14 = (unsigned __int16 *)((char *)v23 + v22);
        if (!v15)
          goto LABEL_16;
      }
      *a2 = 80;
      *a4 = 0;
      v18 = *v10;
      if (*v10)
        goto LABEL_5;
      goto LABEL_24;
    }
LABEL_16:
    if (((**(uint64_t (***)(unint64_t *))(*(_QWORD *)(a1 + 104) + 16))(v10) & 1) != 0)
    {
      *a4 = v10;
      return;
    }
    *a2 = 50;
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", 479);
    *a4 = 0;
    v18 = *v10;
    if (*v10)
      goto LABEL_5;
  }
  else
  {
    *a2 = 50;
    ERR_put_error(16, 0, 162, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", 456);
    *a4 = 0;
    v18 = *v10;
    if (*v10)
    {
LABEL_5:
      v19 = 0;
      do
      {
        v20 = *(unsigned int **)(v10[1] + 8 * v19);
        if (v20)
        {
          CRYPTO_BUFFER_free(v20);
          v18 = *v10;
        }
        ++v19;
      }
      while (v19 < v18);
    }
  }
LABEL_24:
  v26 = v10[1];
  if (v26)
  {
    v28 = *(_QWORD *)(v26 - 8);
    v27 = (void *)(v26 - 8);
    v29 = v28 + 8;
    if (v28 != -8)
      bzero(v27, v29);
    free(v27);
  }
  v31 = *(v10 - 1);
  v30 = v10 - 1;
  v32 = v31 + 8;
  if (v31 != -8)
    bzero(v30, v32);
  free(v30);
}

uint64_t bssl::ssl_add_client_CA_list(_QWORD *a1, uint64_t *a2)
{
  uint64_t result;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  const void *v9;
  size_t v10;
  _BYTE v11[48];
  uint64_t v12[6];
  void *v13;

  result = CBB_flush(a2);
  if ((_DWORD)result)
  {
    result = cbb_add_child((uint64_t)a2, (uint64_t)v12, 2u, 0);
    if ((_DWORD)result)
    {
      v5 = *(unint64_t **)(a1[1] + 80);
      if ((v5 || (v5 = *(unint64_t **)(*(_QWORD *)(*a1 + 104) + 392)) != 0) && (v6 = *v5) != 0)
      {
        v7 = 0;
        while (1)
        {
          if (*v5 <= v7)
          {
            v8 = 0;
            result = CBB_flush(v12);
            if (!(_DWORD)result)
              return result;
          }
          else
          {
            v8 = *(_QWORD *)(v5[1] + 8 * v7);
            result = CBB_flush(v12);
            if (!(_DWORD)result)
              return result;
          }
          result = cbb_add_child((uint64_t)v12, (uint64_t)v11, 2u, 0);
          if (!(_DWORD)result)
            break;
          v9 = *(const void **)(v8 + 8);
          v10 = *(_QWORD *)(v8 + 16);
          v13 = 0;
          result = CBB_add_space((uint64_t)v11, &v13, v10);
          if (!(_DWORD)result)
            break;
          if (v10)
            memcpy(v13, v9, v10);
          if (v6 == ++v7)
            return CBB_flush(a2) != 0;
        }
      }
      else
      {
        return CBB_flush(a2) != 0;
      }
    }
  }
  return result;
}

uint64_t bssl::ssl_check_leaf_certificate(_QWORD *a1, uint64_t a2)
{
  int v2;
  int v3;
  _DWORD *v4;
  int v5;
  int v6;
  uint64_t v8;
  uint64_t v9;
  __int16 *v10;
  uint64_t v11;

  v2 = *(_DWORD *)(a1[192] + 24);
  v3 = *(_DWORD *)(a2 + 4);
  if (v3 == 6)
  {
    if ((v2 & 3) == 0)
    {
LABEL_15:
      ERR_put_error(16, 0, 241, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", 532);
      return 0;
    }
    return 1;
  }
  if (v3 != 949 && v3 != 408 || (v2 & 4) == 0)
    goto LABEL_15;
  if (v3 != 408)
    return 1;
  v4 = *(_DWORD **)(a2 + 8);
  v5 = *(_DWORD *)(*(_QWORD *)v4 + 512);
  if (v5 > 715)
  {
    switch(v5)
    {
      case 716:
        v6 = 25;
        break;
      case 948:
        v6 = 29;
        break;
      case 964:
        v6 = 25497;
        break;
      default:
        goto LABEL_34;
    }
  }
  else
  {
    switch(v5)
    {
      case 415:
        v6 = 23;
        break;
      case 713:
        v6 = 21;
        break;
      case 715:
        v6 = 24;
        break;
      default:
        goto LABEL_34;
    }
  }
  if (v6 != 25497 || *(_WORD *)(*a1 + 16) == 772)
  {
    v8 = a1[1];
    v9 = *(_QWORD *)(v8 + 104);
    if (v9)
    {
      v10 = *(__int16 **)(v8 + 96);
      v11 = 2 * v9;
    }
    else
    {
      v10 = &bssl::kDefaultGroups;
      v11 = 6;
    }
    while ((unsigned __int16)*v10 != v6)
    {
      ++v10;
      v11 -= 2;
      if (!v11)
        goto LABEL_34;
    }
    if (v4[7] == 4)
      return 1;
  }
LABEL_34:
  ERR_put_error(16, 0, 107, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", 544);
  return 0;
}

uint64_t bssl::cert_set_chain_and_key(uint64_t a1, unsigned int **a2, unint64_t a3, evp_pkey_st *a4, uint64_t a5)
{
  int v7;
  int v8;
  uint64_t result;
  const evp_pkey_st *v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned int i;
  unsigned int v17;
  uint64_t v18;
  void (*v19)(uint64_t);
  void *v20;
  uint64_t v21;
  size_t v22;

  if (!a3 || !((unint64_t)a4 | a5))
  {
    v7 = 67;
    v8 = 185;
LABEL_4:
    ERR_put_error(16, 0, v7, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", v8);
    return 0;
  }
  if (a4 && a5)
  {
    v7 = 275;
    v8 = 190;
    goto LABEL_4;
  }
  ssl_credential_st::ClearCertAndKey(*(ssl_credential_st **)(a1 + 24));
  result = SSL_CREDENTIAL_set1_cert_chain(*(_QWORD *)(a1 + 24), a2, a3);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 40))(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32))(a1);
    v14 = *(_QWORD **)(a1 + 24);
    if (a4)
    {
      return SSL_CREDENTIAL_set1_private_key(v14, a4, v13);
    }
    else
    {
      v15 = v14[2];
      v14[2] = 0;
      if (v15)
      {
        for (i = atomic_load((unsigned int *)v15); i != -1; i = v17)
        {
          if (!i)
            abort();
          v17 = __ldaxr((unsigned int *)v15);
          if (v17 == i)
          {
            if (!__stlxr(i - 1, (unsigned int *)v15))
            {
              if (i == 1)
              {
                v18 = *(_QWORD *)(v15 + 16);
                if (v18)
                {
                  v19 = *(void (**)(uint64_t))(v18 + 160);
                  if (v19)
                  {
                    v19(v15);
                    *(_QWORD *)(v15 + 8) = 0;
                    *(_DWORD *)(v15 + 4) = 0;
                  }
                }
                v21 = *(_QWORD *)(v15 - 8);
                v20 = (void *)(v15 - 8);
                v22 = v21 + 8;
                if (v21 != -8)
                  bzero(v20, v22);
                free(v20);
              }
              break;
            }
          }
          else
          {
            __clrex();
          }
        }
      }
      v14[3] = a5;
      return 1;
    }
  }
  return result;
}

void SSL_certs_clear(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  unint64_t v4;
  unint64_t i;
  unsigned int *v6;
  unsigned int j;
  unsigned int v8;
  unsigned int *v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
  {
    v2 = *(_QWORD *)(v1 + 32);
    (*(void (**)(uint64_t))(*(_QWORD *)(v2 + 32) + 8))(v2);
    *(_QWORD *)v2 = 0;
    v3 = (uint64_t *)(v2 + 8);
    v4 = *(_QWORD *)(v2 + 16);
    if (v4)
    {
      for (i = 0; i < v4; ++i)
      {
        v6 = *(unsigned int **)(*v3 + 8 * i);
        *(_QWORD *)(*v3 + 8 * i) = 0;
        if (v6)
        {
          for (j = atomic_load(v6); j != -1; j = v8)
          {
            if (!j)
              abort();
            v8 = __ldaxr(v6);
            if (v8 == j)
            {
              if (!__stlxr(j - 1, v6))
              {
                if (j == 1)
                {
                  ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v6);
                  v10 = *((_QWORD *)v6 - 1);
                  v9 = v6 - 2;
                  v11 = v10 + 8;
                  if (v10 != -8)
                    bzero(v9, v11);
                  free(v9);
                }
                break;
              }
            }
            else
            {
              __clrex();
            }
          }
          v4 = *(_QWORD *)(v2 + 16);
        }
      }
    }
    v12 = *v3;
    if (*v3)
    {
      v14 = *(_QWORD *)(v12 - 8);
      v13 = (void *)(v12 - 8);
      v15 = v14 + 8;
      if (v14 != -8)
        bzero(v13, v15);
      free(v13);
    }
    *v3 = 0;
    *(_QWORD *)(v2 + 16) = 0;
    ssl_credential_st::ClearCertAndKey(*(ssl_credential_st **)(v2 + 24));
  }
}

uint64_t bssl::GrowableArray<std::unique_ptr<ssl_credential_st,bssl::internal::Deleter>>::MaybeGrow(unint64_t *a1)
{
  uint64_t *v2;
  unint64_t v3;
  uint64_t result;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  size_t v8;
  char *v9;
  char *v10;
  const char *v11;
  int v12;
  int v13;
  int v14;
  _QWORD *v15;
  _QWORD *v16;
  unint64_t v17;
  unint64_t i;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int j;
  unsigned int v23;
  unsigned int *v24;
  uint64_t v25;
  size_t v26;
  unint64_t k;
  unsigned int *v28;
  unsigned int m;
  unsigned int v30;
  unsigned int *v31;
  uint64_t v32;
  size_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  size_t v38;

  v2 = (uint64_t *)(a1 + 1);
  v3 = a1[2];
  if (v3)
  {
    if (*a1 < v3)
      return 1;
    if ((v3 & 0x8000000000000000) != 0)
    {
      v11 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/internal.h";
      v12 = 16;
      v13 = 69;
      v14 = 412;
      goto LABEL_54;
    }
    if (v3 >> 60)
    {
      v11 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/internal.h";
      v12 = 16;
      v13 = 69;
      v14 = 297;
LABEL_54:
      ERR_put_error(v12, 0, v13, v11, v14);
      return 0;
    }
    v15 = malloc_type_malloc((16 * v3) | 8, 0x30772F57uLL);
    if (!v15)
    {
      v11 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
      v12 = 14;
      v13 = 65;
      v14 = 247;
      goto LABEL_54;
    }
    *v15 = 16 * v3;
    v16 = v15 + 1;
    bzero(v15 + 1, 16 * v3);
    v17 = a1[2];
    if (v17)
    {
      for (i = 0; i < v17; ++i)
      {
        v19 = i;
        v20 = *(_QWORD *)(*v2 + 8 * i);
        *(_QWORD *)(*v2 + v19 * 8) = 0;
        v21 = (unsigned int *)v16[i];
        v16[v19] = v20;
        if (v21)
        {
          for (j = atomic_load(v21); j != -1; j = v23)
          {
            if (!j)
LABEL_55:
              abort();
            v23 = __ldaxr(v21);
            if (v23 == j)
            {
              if (!__stlxr(j - 1, v21))
              {
                if (j == 1)
                {
                  ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v21);
                  v25 = *((_QWORD *)v21 - 1);
                  v24 = v21 - 2;
                  v26 = v25 + 8;
                  if (v25 != -8)
                    bzero(v24, v26);
                  free(v24);
                }
                break;
              }
            }
            else
            {
              __clrex();
            }
          }
          v17 = a1[2];
        }
      }
      if (v17)
      {
        for (k = 0; k < v17; ++k)
        {
          v28 = *(unsigned int **)(*v2 + 8 * k);
          *(_QWORD *)(*v2 + 8 * k) = 0;
          if (v28)
          {
            for (m = atomic_load(v28); m != -1; m = v30)
            {
              if (!m)
                goto LABEL_55;
              v30 = __ldaxr(v28);
              if (v30 == m)
              {
                if (!__stlxr(m - 1, v28))
                {
                  if (m == 1)
                  {
                    ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v28);
                    v32 = *((_QWORD *)v28 - 1);
                    v31 = v28 - 2;
                    v33 = v32 + 8;
                    if (v32 != -8)
                      bzero(v31, v33);
                    free(v31);
                  }
                  break;
                }
              }
              else
              {
                __clrex();
              }
            }
            v17 = a1[2];
          }
        }
      }
    }
    v34 = 2 * v3;
    v35 = *v2;
    if (*v2)
    {
      v37 = *(_QWORD *)(v35 - 8);
      v36 = (void *)(v35 - 8);
      v38 = v37 + 8;
      if (v37 != -8)
        bzero(v36, v38);
      free(v36);
    }
    a1[1] = (unint64_t)v16;
    a1[2] = v34;
    return 1;
  }
  else
  {
    v5 = *v2;
    if (*v2)
    {
      v7 = *(_QWORD *)(v5 - 8);
      v6 = (void *)(v5 - 8);
      v8 = v7 + 8;
      if (v7 != -8)
        bzero(v6, v8);
      free(v6);
    }
    *v2 = 0;
    v2[1] = 0;
    v9 = (char *)malloc_type_malloc(0x88uLL, 0x30772F57uLL);
    if (v9)
    {
      v10 = v9;
      *(_QWORD *)v9 = 128;
      a1[1] = (unint64_t)(v9 + 8);
      a1[2] = 16;
      *(_OWORD *)(v9 + 120) = 0u;
      *(_OWORD *)(v9 + 104) = 0u;
      *(_OWORD *)(v9 + 88) = 0u;
      *(_OWORD *)(v9 + 72) = 0u;
      *(_OWORD *)(v9 + 56) = 0u;
      *(_OWORD *)(v9 + 40) = 0u;
      *(_OWORD *)(v9 + 24) = 0u;
      result = 1;
      *(_OWORD *)(v10 + 8) = 0u;
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      result = 0;
      *v2 = 0;
    }
  }
  return result;
}

uint64_t bssl::ssl_cipher_get_evp_aead(int **a1, _QWORD *a2, uint64_t *a3, uint64_t a4, unsigned int a5, char a6)
{
  char v9;
  char v10;
  int v11;
  int v12;
  uint64_t v13;
  int *v14;
  int v15;
  uint64_t v16;
  int *v18;
  int *v19;
  int *v20;

  *a1 = 0;
  *a2 = 0;
  *a3 = 0;
  if (a5 == 771)
    v9 = a6;
  else
    v9 = 1;
  if (a5 == 772)
    v10 = a6;
  else
    v10 = 1;
  v11 = *(_DWORD *)(a4 + 32);
  if (v11 == 1)
  {
    v15 = *(_DWORD *)(a4 + 28);
    switch(v15)
    {
      case 4:
        if (a5 != 769)
        {
          v20 = (int *)&aead_aes_256_cbc_sha1_tls;
          goto LABEL_44;
        }
        v18 = (int *)&aead_aes_256_cbc_sha1_tls_implicit_iv;
        break;
      case 2:
        if (a5 != 769)
        {
          v20 = (int *)&aead_aes_128_cbc_sha1_tls;
          goto LABEL_44;
        }
        v18 = (int *)&aead_aes_128_cbc_sha1_tls_implicit_iv;
        break;
      case 1:
        if (a5 == 769)
        {
          *a1 = (int *)&aead_des_ede3_cbc_sha1_tls_implicit_iv;
          v16 = 8;
LABEL_32:
          *a3 = v16;
LABEL_45:
          *a2 = 20;
          return 1;
        }
        v20 = (int *)&aead_des_ede3_cbc_sha1_tls;
LABEL_44:
        *a1 = v20;
        goto LABEL_45;
      default:
        return 0;
    }
    *a1 = v18;
    v16 = 16;
    goto LABEL_32;
  }
  if (v11 == 2)
  {
    if (*(_DWORD *)(a4 + 28) == 2)
    {
      *a1 = (int *)&aead_aes_128_cbc_sha256_tls;
      *a2 = 32;
      return 1;
    }
    return 0;
  }
  if (v11 != 4)
    return 0;
  v12 = *(_DWORD *)(a4 + 28);
  if (v12 == 32)
  {
    v14 = (int *)&aead_chacha20_poly1305;
    v13 = 12;
    goto LABEL_34;
  }
  if (v12 == 16)
  {
    if ((v9 & 1) == 0)
    {
      if (!pthread_once(&EVP_aead_aes_256_gcm_tls12_once, (void (*)(void))EVP_aead_aes_256_gcm_tls12_init))
      {
        v19 = &EVP_aead_aes_256_gcm_tls12_storage;
LABEL_42:
        *a1 = v19;
        *a3 = 4;
        return 1;
      }
LABEL_50:
      abort();
    }
    if ((v10 & 1) == 0)
    {
      v14 = EVP_aead_aes_256_gcm_tls13();
      goto LABEL_48;
    }
    v13 = 4;
    v14 = EVP_aead_aes_256_gcm();
LABEL_34:
    *a1 = v14;
    *a3 = v13;
    if (a5 < 0x304)
      return 1;
    goto LABEL_49;
  }
  if (v12 != 8)
    return 0;
  if ((v9 & 1) == 0)
  {
    if (!pthread_once(&EVP_aead_aes_128_gcm_tls12_once, (void (*)(void))EVP_aead_aes_128_gcm_tls12_init))
    {
      v19 = &EVP_aead_aes_128_gcm_tls12_storage;
      goto LABEL_42;
    }
    goto LABEL_50;
  }
  if ((v10 & 1) != 0)
  {
    v13 = 4;
    v14 = EVP_aead_aes_128_gcm();
    goto LABEL_34;
  }
  v14 = EVP_aead_aes_128_gcm_tls13();
LABEL_48:
  *a1 = v14;
  *a3 = 4;
LABEL_49:
  *a3 = *((unsigned __int8 *)v14 + 1);
  return 1;
}

uint64_t *bssl::ssl_get_handshake_digest(bssl *this, uint64_t a2, const ssl_cipher_st *a3)
{
  int v3;

  v3 = *(_DWORD *)(a2 + 36);
  switch(v3)
  {
    case 4:
      if (pthread_once(&EVP_sha384_once, (void (*)(void))EVP_sha384_init))
        goto LABEL_14;
      return &EVP_sha384_storage;
    case 2:
      if (pthread_once(&EVP_sha256_once, (void (*)(void))EVP_sha256_init))
        goto LABEL_14;
      return &EVP_sha256_storage;
    case 1:
      if (this >= 0x303)
      {
        if (!pthread_once(&EVP_sha256_once, (void (*)(void))EVP_sha256_init))
          return &EVP_sha256_storage;
LABEL_14:
        abort();
      }
      if (pthread_once(&EVP_md5_sha1_once, (void (*)(void))EVP_md5_sha1_init))
        goto LABEL_14;
      return &EVP_md5_sha1_storage;
    default:
      return 0;
  }
}

void bssl::SSLCipherPreferenceList::~SSLCipherPreferenceList(bssl::SSLCipherPreferenceList *this)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  size_t v10;
  void *v11;
  uint64_t v12;
  size_t v13;

  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    v4 = *(_QWORD *)(v2 - 8);
    v3 = (void *)(v2 - 8);
    v5 = v4 + 8;
    if (v4 != -8)
      bzero(v3, v5);
    free(v3);
  }
  v6 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v6)
  {
    v7 = *(_QWORD *)(v6 + 8);
    if (v7)
    {
      v9 = *(_QWORD *)(v7 - 8);
      v8 = (void *)(v7 - 8);
      v10 = v9 + 8;
      if (v9 != -8)
        bzero(v8, v10);
      free(v8);
    }
    v12 = *(_QWORD *)(v6 - 8);
    v11 = (void *)(v6 - 8);
    v13 = v12 + 8;
    if (v12 != -8)
      bzero(v11, v13);
    free(v11);
  }
}

uint64_t bssl::ssl_create_cipher_list(BUF_MEM ***a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  char v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  void **v13;
  int v14;
  char *v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t *v18;
  _BYTE *v19;
  uint64_t *v20;
  unint64_t v21;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  BUF_MEM **v26;
  size_t v27;
  _QWORD *v28;
  _QWORD *v29;
  BUF_MEM *v30;
  char *data;
  char *v32;
  uint64_t v33;
  size_t v34;
  int *p_max;
  uint64_t v36;
  size_t v37;
  void *v38;
  uint64_t v39;
  size_t v40;
  uint64_t v41;
  unint64_t v42;
  void *v43;
  uint64_t v44;
  size_t v45;
  unint64_t *v46;
  uint64_t v47;
  size_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  size_t v52;
  BUF_MEM *v53;
  BUF_MEM **v54;
  BUF_MEM *v55;
  uint64_t *v56;
  void **v57;
  _BYTE __key[16];
  int v59;
  void *v60;
  __int16 v61;
  void **v62;
  uint64_t v63;
  void *v64;
  __int16 v65;
  void **v66;
  void **v67;
  void *v68;
  __int16 v69;
  void **v70;
  void **v71;
  void *v72;
  __int16 v73;
  _WORD *v74;
  void **v75;
  _WORD v76[8];
  _WORD *v77;
  void **v78;
  _WORD v79[8];
  _WORD *v80;
  _WORD *v81;
  _WORD v82[8];
  _WORD *v83;
  _WORD *v84;
  _WORD v85[8];
  _WORD *v86;
  _WORD *v87;
  _WORD v88[8];
  _WORD *v89;
  _WORD *v90;
  _WORD v91[8];
  _WORD *v92;
  _WORD *v93;
  _WORD v94[8];
  _WORD *v95;
  _WORD *v96;
  _WORD v97[8];
  _WORD *v98;
  _WORD *v99;
  _WORD v100[8];
  _WORD *v101;
  _WORD *v102;
  _WORD v103[8];
  _WORD *v104;
  _WORD *v105;
  _WORD v106[8];
  _WORD *v107;
  _WORD *v108;
  _WORD v109[8];
  _WORD *v110;
  _WORD *v111;
  _WORD v112[8];
  _WORD *v113;
  _WORD *v114;
  _WORD v115[8];
  _WORD *v116;
  _WORD *v117;
  _WORD v118[8];
  _WORD *v119;
  _WORD *v120;
  _WORD v121[8];
  _WORD *v122;
  _WORD *v123;
  _WORD v124[8];
  uint64_t v125;
  _WORD *v126;
  uint64_t v127;

  v4 = 0;
  v127 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v5 = a3;
    if (a3)
    {
      v7 = a2;
      v9 = 0;
      v62 = &v64;
      v63 = 0;
      v61 = 0;
      v70 = &v72;
      v71 = &v64;
      v77 = v79;
      v78 = &v72;
      v83 = v85;
      v84 = v79;
      v89 = v91;
      v90 = v85;
      v95 = v97;
      v96 = v91;
      v101 = v103;
      v102 = v97;
      v107 = v109;
      v108 = v103;
      v110 = v112;
      v111 = v106;
      v104 = v106;
      v105 = v100;
      v98 = v100;
      v99 = v94;
      v92 = v94;
      v93 = v88;
      v86 = v88;
      v87 = v82;
      v80 = v82;
      v81 = v76;
      v74 = v76;
      v75 = &v68;
      v66 = &v68;
      v67 = &v60;
      v65 = 0;
      v69 = 0;
      v73 = 0;
      v76[4] = 0;
      v79[4] = 0;
      v82[4] = 0;
      v85[4] = 0;
      v88[4] = 0;
      v91[4] = 0;
      v94[4] = 0;
      v97[4] = 0;
      v100[4] = 0;
      v103[4] = 0;
      v106[4] = 0;
      v109[4] = 0;
      v114 = v109;
      v113 = v115;
      v112[4] = 0;
      v117 = v112;
      v116 = v118;
      v115[4] = 0;
      v120 = v115;
      v119 = v121;
      v118[4] = 0;
      v123 = v118;
      v122 = v124;
      v121[4] = 0;
      v125 = 0;
      v126 = v121;
      v124[4] = 0;
      v56 = (uint64_t *)v124;
      v57 = &v60;
      if (a2)
      {
        v59 = 50380843;
        v60 = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
        v59 = 50380847;
        v64 = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
        v59 = 50380844;
        v68 = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
        v59 = 50380848;
        v72 = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
        v9 = 4;
      }
      v59 = 50384041;
      v10 = 32 * v9;
      *(&v60 + 4 * v9) = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50384040;
      *(void **)((char *)&v60 + (v10 | 0x20)) = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50384044;
      v11 = v9 | 3;
      *(void **)((char *)&v60 + (v10 | 0x40)) = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      if ((v7 & 1) == 0)
      {
        v59 = 50380843;
        *(&v60 + 4 * v11) = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
        v59 = 50380847;
        v12 = &v60 + 4 * v9;
        v12[16] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
        v59 = 50380844;
        v12[20] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
        v59 = 50380848;
        v11 = v9 + 7;
        v12[24] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      }
      v59 = 50380809;
      v13 = &v60 + 4 * v11;
      *v13 = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50380819;
      v13[4] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50380853;
      v13[8] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50380810;
      v13[12] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50380820;
      v13[16] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50380854;
      v13[20] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50380839;
      v13[24] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50331804;
      v13[28] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50331805;
      v13[32] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50331695;
      v13[36] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50331788;
      v13[40] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50331701;
      v13[44] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50331789;
      v13[48] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      v59 = 50331658;
      v13[52] = bsearch(__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
      if (!strncmp((const char *)v5, "DEFAULT", 7uLL))
      {
        if (!bssl::ssl_cipher_process_rulestr("ALL", (uint64_t **)&v57, &v56, a4))
          return 0;
        v14 = *(unsigned __int8 *)(v5 + 7);
        v5 += 7;
        if (v14 == 58)
          ++v5;
        if (!*(_BYTE *)v5)
        {
LABEL_15:
          v15 = OPENSSL_sk_new_null();
          if (v15)
          {
            v16 = (unint64_t *)v15;
            v17 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
            if (v17)
            {
              v18 = v17;
              *v17 = 24;
              v19 = v17 + 1;
              v20 = (uint64_t *)v57;
              if (v57)
              {
                v21 = 0;
                while (1)
                {
                  if (*((_BYTE *)v20 + 8))
                  {
                    if (!OPENSSL_sk_insert(v16, *v20, *v16))
                      goto LABEL_45;
                    v19[v21++] = *((_BYTE *)v20 + 9);
                  }
                  v20 = (uint64_t *)v20[2];
                  if (!v20)
                    goto LABEL_29;
                }
              }
              v21 = 0;
LABEL_29:
              v24 = malloc_type_malloc(0x18uLL, 0x30772F57uLL);
              if (v24)
              {
                v25 = v24;
                *v24 = 16;
                v24[1] = 0;
                v26 = (BUF_MEM **)(v24 + 1);
                v24[2] = 0;
                if (v21 >= 0x18)
                  v27 = 24;
                else
                  v27 = v21;
                if (*v16 == v27)
                {
                  if (!v27)
                  {
                    v29 = 0;
                    *v26 = (BUF_MEM *)v16;
LABEL_72:
                    v25[2] = v29;
                    v54 = *a1;
                    *a1 = v26;
                    if (v54)
                    {
                      OPENSSL_free(v54[1]);
                      v55 = *v54;
                      *v54 = 0;
                      if (v55)
                        ASN1_STRING_free(v55);
                      OPENSSL_free(v54);
                      v26 = *a1;
                    }
                    if (*v26 && *(_QWORD *)&(*v26)->length)
                    {
                      v4 = 1;
                    }
                    else
                    {
                      ERR_put_error(16, 0, 177, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cipher.cc", 1271);
                      v4 = 0;
                    }
                    if (*v18 != -8)
                      __memset_chk();
                    goto LABEL_70;
                  }
                  v28 = malloc_type_malloc(v27 + 8, 0x30772F57uLL);
                  if (v28)
                  {
                    *v28 = v27;
                    v29 = v28 + 1;
                    memmove(v28 + 1, v19, v27);
                    v30 = *v26;
                    *v26 = (BUF_MEM *)v16;
                    if (v30)
                    {
                      data = v30->data;
                      if (data)
                      {
                        v33 = *((_QWORD *)data - 1);
                        v32 = data - 8;
                        v34 = v33 + 8;
                        if (v33 != -8)
                          bzero(v32, v34);
                        free(v32);
                      }
                      v36 = *(_QWORD *)&v30[-1].max;
                      p_max = &v30[-1].max;
                      v37 = v36 + 8;
                      if (v36 != -8)
                        bzero(p_max, v37);
                      free(p_max);
                    }
                    goto LABEL_72;
                  }
                  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
                  v42 = v16[1];
                  if (!v42)
                    goto LABEL_57;
                }
                else
                {
                  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cipher.cc", 736);
                  v42 = v16[1];
                  if (!v42)
                  {
LABEL_57:
                    v47 = *(v16 - 1);
                    v46 = v16 - 1;
                    v48 = v47 + 8;
                    if (v47 != -8)
                      bzero(v46, v48);
                    free(v46);
                    v49 = v25[2];
                    if (v49)
                    {
                      v51 = *(_QWORD *)(v49 - 8);
                      v50 = (void *)(v49 - 8);
                      v52 = v51 + 8;
                      if (v51 != -8)
                        bzero(v50, v52);
                      free(v50);
                    }
                    v53 = *v26;
                    *v26 = 0;
                    if (v53)
                      ASN1_STRING_free(v53);
                    if (*v25 != -8)
                      __memset_chk();
                    free(v25);
                    if (*v18 != -8)
                      __memset_chk();
                    goto LABEL_69;
                  }
                }
                v44 = *(_QWORD *)(v42 - 8);
                v43 = (void *)(v42 - 8);
                v45 = v44 + 8;
                if (v44 != -8)
                  bzero(v43, v45);
                free(v43);
                goto LABEL_57;
              }
              ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
LABEL_45:
              if (*v18 != -8)
                __memset_chk();
              free(v18);
              v23 = v16[1];
              if (v23)
                goto LABEL_48;
            }
            else
            {
              ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
              v23 = v16[1];
              if (v23)
              {
LABEL_48:
                v39 = *(_QWORD *)(v23 - 8);
                v38 = (void *)(v23 - 8);
                v40 = v39 + 8;
                if (v39 != -8)
                  bzero(v38, v40);
                free(v38);
              }
            }
            v41 = *(v16 - 1);
            v18 = v16 - 1;
            if (v41 != -8)
              bzero(v16 - 1, v41 + 8);
LABEL_69:
            v4 = 0;
LABEL_70:
            free(v18);
            return v4;
          }
          return 0;
        }
      }
      else if (!*(_BYTE *)v5)
      {
        goto LABEL_15;
      }
      if (!bssl::ssl_cipher_process_rulestr((char *)v5, (uint64_t **)&v57, &v56, a4))
        return 0;
      goto LABEL_15;
    }
  }
  return v4;
}

uint64_t bssl::ssl_cipher_process_rulestr(char *__s2, uint64_t **a2, uint64_t **a3, int a4)
{
  char v4;
  uint64_t **v5;
  char *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  char v12;
  int v13;
  uint64_t k;
  int v15;
  unsigned int v17;
  BOOL v18;
  uint64_t v19;
  uint64_t *v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int8x16_t v26;
  char v27;
  size_t i;
  int v29;
  int v31;
  uint64_t v32;
  uint64_t v34;
  const char *v35;
  const char *v36;
  uint64_t j;
  const char *v38;
  size_t v39;
  _QWORD *v40;
  int *v41;
  _QWORD *v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  const char *v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v57;
  int v58;
  int8x16_t v59;
  int v60;
  char v61;
  uint64_t v64;
  int8x16_t v65;
  __int16 v66;
  char v67;

  v4 = *__s2;
  if (!*__s2)
    return 1;
  v5 = a3;
  v6 = __s2;
  v7 = 0;
  LOBYTE(v8) = 0;
  while (1)
  {
    if ((v8 & 1) == 0)
      goto LABEL_11;
    if (v4 == 124)
    {
      ++v6;
      v8 = 1;
      goto LABEL_4;
    }
    if (v4 == 93)
    {
      if (*v5)
        *((_BYTE *)*v5 + 9) = 0;
      v9 = *++v6;
      v4 = v9;
      if (!v9)
        return 1;
LABEL_11:
      v8 = 0;
      v10 = 1;
      v11 = 3;
      v12 = 0;
      v13 = 0;
      switch(v4)
      {
        case '!':
          LOBYTE(v8) = 0;
          v11 = 2;
          goto LABEL_19;
        case '"':
        case '#':
        case '$':
        case '%':
        case '&':
        case '\'':
        case '(':
        case ')':
        case '*':
        case ',':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case ';':
        case '<':
        case '=':
        case '>':
        case '?':
          goto LABEL_20;
        case '+':
          LOBYTE(v8) = 0;
          v11 = 4;
          goto LABEL_19;
        case '-':
          goto LABEL_19;
        case '@':
          v11 = 5;
          LOBYTE(v8) = 1;
LABEL_19:
          v12 = v8;
          v8 = 0;
          ++v6;
          v13 = 1;
          v10 = v11;
          break;
        default:
          v12 = 0;
          v13 = 0;
          break;
      }
      goto LABEL_20;
    }
    v12 = 0;
    v8 = 1;
    if ((v4 - 58) > 0xFFFFFFF5)
    {
      v10 = 1;
      v13 = 0;
    }
    else
    {
      v10 = 1;
      v13 = 0;
      if ((v4 & 0xFFFFFFDF) - 91 <= 0xFFFFFFE5)
      {
        v51 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/ssl/ssl_cipher.cc";
        v52 = 16;
        v53 = 224;
        v54 = 983;
        goto LABEL_145;
      }
    }
LABEL_20:
    if (v4 == 58 || (a4 & 1) != 0)
    {
      if (v4 != 58)
        break;
      goto LABEL_3;
    }
    if (v4 > 0x3Bu || ((1 << v4) & 0x800100100000000) == 0)
      break;
LABEL_3:
    ++v6;
LABEL_4:
    v4 = *v6;
    if (!*v6)
    {
      if (v8)
      {
        v51 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/ssl/ssl_cipher.cc";
        v52 = 16;
        v53 = 158;
        v54 = 1127;
        goto LABEL_145;
      }
      return 1;
    }
  }
  v64 = 0;
  v65.i64[0] = -1;
  v65.i64[1] = -1;
  v66 = 0;
  v67 = v13;
  v57 = v8;
  v58 = v7;
  if ((v12 & 1) == 0)
  {
    v60 = v13;
    v61 = 0;
    v55 = v10;
    v24 = 0;
    v25 = 0;
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    v59 = v26;
    v27 = 1;
    while (2)
    {
      for (i = 0; ; ++i)
      {
        v29 = v6[i];
        if ((v29 & 0xFFFFFFDF) - 65 >= 0x1A && (v29 - 48) >= 0xA)
        {
          v31 = v6[i];
          v32 = (1 << (v29 - 45)) & 0x4000000000003;
          if ((v31 - 45) > 0x32 || v32 == 0)
            break;
        }
      }
      if (i)
      {
        if (v31 != 43 && (v27 & 1) != 0)
        {
          v34 = 0;
          while (1)
          {
            v35 = bssl::kCiphers[v34];
            if (!strncmp(v35, v6, i) && !v35[i])
              break;
            v36 = bssl::kCiphers[v34 + 1];
            if (!strncmp(v36, v6, i) && !v36[i])
              break;
            v34 += 5;
            if (v34 == 120)
              goto LABEL_88;
          }
          v25 = LODWORD(bssl::kCiphers[v34 + 2]);
        }
LABEL_88:
        if ((_DWORD)v25)
          goto LABEL_98;
        for (j = 0; j != 116; j += 4)
        {
          v38 = (&bssl::kCipherAliases)[j];
          if (!strncmp(v38, v6, i) && !v38[i])
          {
            v59 = vandq_s8(*(int8x16_t *)&(&bssl::kCipherAliases)[j + 1], v59);
            v65 = v59;
            v60 |= *((unsigned __int8 *)&bssl::kCipherAliases + 8 * j + 26);
            v67 = v60;
            if (v24)
            {
              if (v24 != LOWORD((&bssl::kCipherAliases)[j + 3]))
                goto LABEL_97;
            }
            else
            {
              v24 = LOWORD((&bssl::kCipherAliases)[j + 3]);
            }
            v66 = v24;
            if (v31 == 43)
              goto LABEL_99;
            goto LABEL_102;
          }
        }
        if (a4)
        {
          v51 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl"
                "/src/ssl/ssl_cipher.cc";
          v52 = 16;
          v53 = 158;
          v54 = 1091;
          goto LABEL_145;
        }
LABEL_97:
        v61 = 1;
LABEL_98:
        if (v31 == 43)
        {
LABEL_99:
          v27 = 0;
          v6 += i + 1;
          continue;
        }
LABEL_102:
        v6 += i;
        if ((v61 & 1) == 0)
        {
          v8 = v57;
          v5 = a3;
          bssl::ssl_cipher_apply_rule(v25, (uint64_t)&v64, v55, -1, v57, a2, a3);
          v7 = v58;
          goto LABEL_4;
        }
        v5 = a3;
        goto LABEL_137;
      }
      break;
    }
LABEL_144:
    v51 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/s"
          "sl/ssl_cipher.cc";
    v52 = 16;
    v53 = 158;
    v54 = 1042;
    goto LABEL_145;
  }
  for (k = 0; ; ++k)
  {
    v15 = v6[k];
    if ((v15 & 0xFFFFFFDF) - 65 >= 0x1A && (v15 - 48) >= 0xA)
    {
      v17 = v6[k] - 45;
      v18 = v17 > 0x32;
      v19 = (1 << v17) & 0x4000000000003;
      if (v18 || v19 == 0)
        break;
    }
  }
  if (k != 8)
  {
    if (k)
    {
LABEL_146:
      v51 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src"
            "/ssl/ssl_cipher.cc";
      v52 = 16;
      v53 = 158;
      v54 = 1108;
      goto LABEL_145;
    }
    goto LABEL_144;
  }
  if (strncmp(v6, "STRENGTH", 8uLL))
    goto LABEL_146;
  v21 = *a2;
  if (!*a2)
  {
    v22 = 0;
    v39 = 4;
    v40 = malloc_type_malloc(0xCuLL, 0x30772F57uLL);
    if (!v40)
      goto LABEL_147;
LABEL_109:
    v41 = (int *)v40;
    *v40 = v39;
    v42 = v40 + 1;
    bzero(v40 + 1, v39);
    v43 = *a2;
    v5 = a3;
    if (!*a2)
    {
LABEL_110:
      v6 += 8;
      v44 = v22;
      do
      {
        if (v41[v44 + 2] >= 1)
          bssl::ssl_cipher_apply_rule(0, 0, 4, v44, 0, a2, a3);
        v18 = v44-- <= 0;
      }
      while (!v18);
      if (*(_QWORD *)v41 != -8)
        bzero(v41, *(_QWORD *)v41 + 8);
      free(v41);
      v47 = *v6;
      if (*v6)
      {
        v8 = v57;
        v7 = v58;
        if ((a4 & 1) != 0)
        {
          do
          {
            if (v47 == 58)
              break;
            v48 = *++v6;
            v47 = v48;
          }
          while (v48);
        }
        else
        {
          do
          {
            if (v47 <= 0x3B && ((1 << v47) & 0xC00100100000000) != 0)
              break;
            v49 = *++v6;
            v47 = v49;
          }
          while (v49);
        }
        goto LABEL_4;
      }
LABEL_137:
      v8 = v57;
      v7 = v58;
      goto LABEL_4;
    }
    while (1)
    {
      if (!*((_BYTE *)v43 + 8))
        goto LABEL_116;
      v45 = *v43;
      if (*v43)
      {
        v46 = *(unsigned int *)(v45 + 28);
        if (v46 > 0x20)
          goto LABEL_125;
        if (((1 << v46) & 0x100010010) != 0)
        {
          v45 = 256;
        }
        else if (((1 << v46) & 0x104) != 0)
        {
          v45 = 128;
        }
        else
        {
          if (v46 != 1)
          {
LABEL_125:
            v45 = 0;
            goto LABEL_115;
          }
          v45 = 112;
        }
      }
LABEL_115:
      ++*((_DWORD *)v42 + v45);
LABEL_116:
      v43 = (uint64_t *)v43[2];
      if (!v43)
        goto LABEL_110;
    }
  }
  v22 = 0;
  while (2)
  {
    if (!*((_BYTE *)v21 + 8))
      goto LABEL_44;
    if (!*v21)
    {
      v22 &= ~(v22 >> 31);
      goto LABEL_44;
    }
    v23 = *(unsigned int *)(*v21 + 28);
    if (v23 > 0x20)
      goto LABEL_57;
    if (((1 << v23) & 0x100010010) == 0)
    {
      if (((1 << v23) & 0x104) != 0)
      {
        if (v22 < 128)
          goto LABEL_58;
        goto LABEL_44;
      }
      if (v23 == 1)
      {
        if (v22 >= 112)
          goto LABEL_44;
        goto LABEL_58;
      }
LABEL_57:
      if (v22 < 0)
        goto LABEL_58;
      goto LABEL_44;
    }
    if (v22 >= 256)
      goto LABEL_44;
    if (v23 > 0x20)
      goto LABEL_65;
LABEL_58:
    if (((1 << v23) & 0x100010010) != 0)
    {
      v22 = 256;
      goto LABEL_44;
    }
    if (((1 << v23) & 0x104) != 0)
    {
      v22 = 128;
      goto LABEL_44;
    }
    if (v23 == 1)
      v22 = 112;
    else
LABEL_65:
      v22 = 0;
LABEL_44:
    v21 = (uint64_t *)v21[2];
    if (v21)
      continue;
    break;
  }
  v39 = 4 * (v22 + 1);
  v40 = malloc_type_malloc(v39 + 8, 0x30772F57uLL);
  if (v40)
    goto LABEL_109;
LABEL_147:
  v51 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
  v52 = 14;
  v53 = 65;
  v54 = 247;
LABEL_145:
  ERR_put_error(v52, 0, v53, v51, v54);
  return 0;
}

uint64_t ssl_cipher_id_cmp_void(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  v2 = a1[4];
  v3 = a2[4];
  v4 = v2 > v3;
  if (v2 >= v3)
    v5 = 0;
  else
    v5 = -1;
  if (v4)
    return 1;
  else
    return v5;
}

uint64_t bssl::ssl_cipher_apply_rule(uint64_t result, uint64_t a2, int a3, int a4, char a5, uint64_t **a6, uint64_t **a7)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  BOOL v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _DWORD *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v31;
  int v32;
  uint64_t v34;
  uint64_t *v35;

  if ((_DWORD)result
    || a4 != -1
    || *(_WORD *)(a2 + 24)
    || *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12) && *(_DWORD *)(a2 + 16) && *(_DWORD *)(a2 + 20))
  {
    v7 = *a6;
    v8 = *a7;
    if (a3 == 3)
      v9 = *a7;
    else
      v9 = *a6;
    if (a3 == 3)
      v10 = *a6;
    else
      v10 = *a7;
    if (v10)
      v11 = v9 == 0;
    else
      v11 = 1;
    if (v11)
    {
LABEL_15:
      *a6 = v7;
      *a7 = v8;
      return result;
    }
    while ((_DWORD)result)
    {
      v12 = v9;
      if (a3 == 3)
      {
        while (1)
        {
          v9 = (uint64_t *)v12[3];
          if (*(_DWORD *)(*v12 + 16) == (_DWORD)result)
            break;
          if (v12 != v10)
          {
            v12 = (uint64_t *)v12[3];
            if (v9)
              continue;
          }
          goto LABEL_15;
        }
LABEL_45:
        v16 = v12 + 3;
        v17 = v12 + 2;
      }
      else
      {
        while (1)
        {
          v9 = (uint64_t *)v12[2];
          if (*(_DWORD *)(*v12 + 16) == (_DWORD)result)
            break;
          if (v12 != v10)
          {
            v12 = (uint64_t *)v12[2];
            if (v9)
              continue;
          }
          goto LABEL_15;
        }
        v17 = v12 + 2;
        v16 = v12 + 3;
      }
LABEL_47:
      switch(a3)
      {
        case 4:
          if (*((_BYTE *)v12 + 8))
          {
            if (v8 != v12)
            {
              v20 = *v17;
              if (v7 == v12)
                v7 = (uint64_t *)*v17;
              v21 = (uint64_t *)*v16;
              if (*v16)
              {
                v21[2] = v20;
                v20 = *v17;
              }
              if (v20)
                *(_QWORD *)(v20 + 24) = v21;
              v8[2] = (uint64_t)v12;
              *v16 = (uint64_t)v8;
              v8 = v12;
              *v17 = 0;
            }
            *((_BYTE *)v12 + 9) = 0;
          }
          break;
        case 1:
          if (!*((_BYTE *)v12 + 8))
          {
            if (v8 != v12)
            {
              v18 = *v17;
              if (v7 == v12)
                v7 = (uint64_t *)*v17;
              v19 = (uint64_t *)*v16;
              if (*v16)
              {
                v19[2] = v18;
                v18 = *v17;
              }
              if (v18)
                *(_QWORD *)(v18 + 24) = v19;
              v8[2] = (uint64_t)v12;
              *v16 = (uint64_t)v8;
              v8 = v12;
              *v17 = 0;
            }
            *((_BYTE *)v12 + 8) = 1;
            *((_BYTE *)v12 + 9) = a5;
          }
          break;
        case 3:
          if (*((_BYTE *)v12 + 8))
          {
            if (v7 != v12)
            {
              v22 = *v16;
              if (v8 == v12)
                v8 = (uint64_t *)*v16;
              v23 = *v17;
              if (*v17)
              {
                *(_QWORD *)(v23 + 24) = v22;
                v22 = *v16;
              }
              if (v22)
                *(_QWORD *)(v22 + 16) = v23;
              v7[3] = (uint64_t)v12;
              *v17 = (uint64_t)v7;
              v7 = v12;
              *v16 = 0;
            }
            *((_WORD *)v12 + 4) = 0;
          }
          break;
        case 2:
          v34 = *v17;
          v35 = (uint64_t *)*v16;
          if (v7 == v12)
          {
            v7 = (uint64_t *)*v17;
          }
          else
          {
            v35[2] = v34;
            v34 = *v17;
          }
          if (v8 == v12)
            v8 = v35;
          *((_BYTE *)v12 + 8) = 0;
          if (v34)
          {
            *(_QWORD *)(v34 + 24) = v35;
            v35 = (uint64_t *)*v16;
          }
          if (v35)
            v35[2] = v34;
          *v17 = 0;
          *v16 = 0;
          break;
      }
      if (v12 == v10 || !v9)
        goto LABEL_15;
    }
    if ((a4 & 0x80000000) == 0)
    {
      v12 = v9;
      while (1)
      {
        if (a3 == 3)
          v13 = 3;
        else
          v13 = 2;
        v14 = *v12;
        if (!*v12)
          goto LABEL_41;
        v15 = *(unsigned int *)(v14 + 28);
        if (v15 > 0x20)
          break;
        if (((1 << v15) & 0x100010010) != 0)
        {
          LODWORD(v14) = 256;
        }
        else if (((1 << v15) & 0x104) != 0)
        {
          LODWORD(v14) = 128;
        }
        else
        {
          if (v15 != 1)
            break;
          LODWORD(v14) = 112;
        }
LABEL_41:
        v9 = (uint64_t *)v12[v13];
        if ((_DWORD)v14 == a4)
          goto LABEL_45;
        if (v12 != v10)
        {
          v12 = v9;
          if (v9)
            continue;
        }
        goto LABEL_15;
      }
      LODWORD(v14) = 0;
      goto LABEL_41;
    }
    v12 = v9;
    while (1)
    {
      if (a3 == 3)
        v24 = 3;
      else
        v24 = 2;
      v9 = (uint64_t *)v12[v24];
      v25 = (_DWORD *)*v12;
      v26 = *(_DWORD *)(*v12 + 20);
      if ((v26 & *(_DWORD *)(a2 + 8)) == 0)
        goto LABEL_106;
      v27 = v25[6];
      if ((v27 & *(_DWORD *)(a2 + 12)) == 0)
        goto LABEL_106;
      v28 = v25[7];
      if ((v28 & *(_DWORD *)(a2 + 16)) == 0 || (v25[8] & *(_DWORD *)(a2 + 20)) == 0)
        goto LABEL_106;
      v29 = *(unsigned __int16 *)(a2 + 24);
      if (*(_WORD *)(a2 + 24))
      {
        if (v26 == 8 || v27 == 16)
        {
          if (v29 != 772)
            goto LABEL_106;
        }
        else
        {
          if (v25[9] == 1)
            v31 = 768;
          else
            v31 = 771;
          if (v31 != v29)
            goto LABEL_106;
        }
      }
      v16 = v12 + 3;
      v17 = v12 + 2;
      if (*(_BYTE *)(a2 + 26))
        goto LABEL_47;
      v32 = v25[4];
      if (v28 != 1 && v32 != 50380839)
        goto LABEL_47;
LABEL_106:
      if (v12 != v10)
      {
        v12 = v9;
        if (v9)
          continue;
      }
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t bssl::ssl_get_credential_list(uint64_t a1, uint64_t *a2)
{
  unint64_t *v3;
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  size_t v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;

  v3 = *(unint64_t **)(*(_QWORD *)(a1 + 8) + 32);
  result = (*(uint64_t (**)(void))(v3[4] + 112))();
  if ((_DWORD)result)
  {
    v5 = *v3;
    v6 = v3[3];
    v7 = *(_QWORD *)(v6 + 48);
    if (v7
      && *(_QWORD *)v7
      && **(_QWORD **)(v7 + 8)
      && *(_QWORD *)(v6 + 8)
      && (*(_QWORD *)(v6 + 16) || *(_QWORD *)(v6 + 24))
      && (*(_DWORD *)(v6 + 4) != 1 || *(_QWORD *)(v6 + 56)))
    {
      ++v5;
      v8 = 1;
    }
    else
    {
      v8 = 0;
    }
    v9 = *a2;
    if (*a2)
    {
      v11 = *(_QWORD *)(v9 - 8);
      v10 = (void *)(v9 - 8);
      v12 = v11 + 8;
      if (v11 != -8)
        bzero(v10, v12);
      free(v10);
    }
    *a2 = 0;
    a2[1] = 0;
    if (v5)
    {
      if (v5 >> 61)
      {
        ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/internal.h", 297);
        return 0;
      }
      if (v5 == 0x1FFFFFFFFFFFFFFFLL || (v13 = malloc_type_malloc(8 * v5 + 8, 0x30772F57uLL)) == 0)
      {
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        result = 0;
        *a2 = 0;
        return result;
      }
      *v13 = 8 * v5;
      *a2 = (uint64_t)(v13 + 1);
      a2[1] = v5;
    }
    v14 = *v3;
    if (*v3)
    {
      v15 = 0;
      do
      {
        *(_QWORD *)(*a2 + 8 * v15) = *(_QWORD *)(v3[1] + 8 * v15);
        ++v15;
      }
      while (v14 != v15);
    }
    if ((v8 & 1) != 0)
      *(_QWORD *)(*a2 + 8 * v5 - 8) = v3[3];
    return 1;
  }
  return result;
}

void ssl_credential_st::~ssl_credential_st(ssl_credential_st *this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int *v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  size_t v12;
  unint64_t *v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  size_t v19;
  uint64_t v20;
  unsigned int i;
  unsigned int v22;
  uint64_t v23;
  unsigned int j;
  unsigned int v25;
  uint64_t v26;
  void (*v27)(uint64_t);
  void *v28;
  uint64_t v29;
  size_t v30;
  uint64_t v31;
  void (*v32)(uint64_t);
  void *v33;
  uint64_t v34;
  size_t v35;

  CRYPTO_free_ex_data((int)&g_ex_data_class, this, (CRYPTO_EX_DATA *)((char *)this + 88));
  v2 = (unsigned int *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v2)
    CRYPTO_BUFFER_free(v2);
  v3 = (unsigned int *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (v3)
    CRYPTO_BUFFER_free(v3);
  v4 = (unsigned int *)*((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v4)
    CRYPTO_BUFFER_free(v4);
  v5 = (unint64_t *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v5)
  {
    v6 = *v5;
    if (*v5)
    {
      v7 = 0;
      do
      {
        v8 = *(unsigned int **)(v5[1] + 8 * v7);
        if (v8)
        {
          CRYPTO_BUFFER_free(v8);
          v6 = *v5;
        }
        ++v7;
      }
      while (v7 < v6);
    }
    v9 = v5[1];
    if (v9)
    {
      v11 = *(_QWORD *)(v9 - 8);
      v10 = (void *)(v9 - 8);
      v12 = v11 + 8;
      if (v11 != -8)
        bzero(v10, v12);
      free(v10);
    }
    v14 = *(v5 - 1);
    v13 = v5 - 1;
    v15 = v14 + 8;
    if (v14 != -8)
      bzero(v13, v15);
    free(v13);
  }
  v16 = *((_QWORD *)this + 4);
  if (v16)
  {
    v18 = *(_QWORD *)(v16 - 8);
    v17 = (void *)(v16 - 8);
    v19 = v18 + 8;
    if (v18 != -8)
      bzero(v17, v19);
    free(v17);
  }
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  v20 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v20)
  {
    for (i = atomic_load((unsigned int *)v20); i != -1; i = v22)
    {
      if (!i)
LABEL_56:
        abort();
      v22 = __ldaxr((unsigned int *)v20);
      if (v22 == i)
      {
        if (!__stlxr(i - 1, (unsigned int *)v20))
        {
          if (i != 1)
            break;
          v26 = *(_QWORD *)(v20 + 16);
          if (v26)
          {
            v27 = *(void (**)(uint64_t))(v26 + 160);
            if (v27)
            {
              v27(v20);
              *(_QWORD *)(v20 + 8) = 0;
              *(_DWORD *)(v20 + 4) = 0;
            }
          }
          v29 = *(_QWORD *)(v20 - 8);
          v28 = (void *)(v20 - 8);
          v30 = v29 + 8;
          if (v29 != -8)
            bzero(v28, v30);
          free(v28);
          v23 = *((_QWORD *)this + 1);
          *((_QWORD *)this + 1) = 0;
          if (v23)
            goto LABEL_34;
          return;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  v23 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v23)
  {
LABEL_34:
    for (j = atomic_load((unsigned int *)v23); j != -1; j = v25)
    {
      if (!j)
        goto LABEL_56;
      v25 = __ldaxr((unsigned int *)v23);
      if (v25 == j)
      {
        if (!__stlxr(j - 1, (unsigned int *)v23))
        {
          if (j == 1)
          {
            v31 = *(_QWORD *)(v23 + 16);
            if (v31)
            {
              v32 = *(void (**)(uint64_t))(v31 + 160);
              if (v32)
              {
                v32(v23);
                *(_QWORD *)(v23 + 8) = 0;
                *(_DWORD *)(v23 + 4) = 0;
              }
            }
            v34 = *(_QWORD *)(v23 - 8);
            v33 = (void *)(v23 - 8);
            v35 = v34 + 8;
            if (v34 != -8)
              bzero(v33, v35);
            free(v33);
          }
          return;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
}

void ssl_credential_st::Dup(ssl_credential_st *this@<X0>, unsigned int **a2@<X8>)
{
  char *v4;
  _QWORD *v5;
  int v6;
  unsigned int **v7;
  unsigned int *v8;
  unsigned int **v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int i;
  unsigned int v15;
  uint64_t v16;
  void (*v17)(unsigned int *);
  unsigned int *v18;
  uint64_t v19;
  size_t v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int j;
  unsigned int v26;
  uint64_t v27;
  void (*v28)(uint64_t);
  void *v29;
  uint64_t v30;
  size_t v31;
  uint64_t v32;
  _QWORD *v33;
  const void *v34;
  unint64_t v35;
  void *v36;
  uint64_t v37;
  size_t v38;
  _QWORD *v39;
  void *v40;
  unint64_t *v41;
  char *v42;
  _QWORD *v43;
  unint64_t *v44;
  size_t v45;
  _QWORD *v46;
  _QWORD *v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t m;
  uint64_t v51;
  unsigned int *v52;
  unsigned int v53;
  unsigned int v54;
  char v55;
  unint64_t *v56;
  unint64_t v57;
  unint64_t v58;
  unsigned int *v59;
  unint64_t v60;
  void *v61;
  uint64_t v62;
  size_t v63;
  unint64_t *v64;
  uint64_t v65;
  size_t v66;
  uint64_t v67;
  unsigned int *v68;
  unsigned int v69;
  unsigned int v70;
  char v71;
  unsigned int *v72;
  unsigned int *v73;
  unsigned int *v74;
  unsigned int v75;
  unsigned int v76;
  char v77;
  unsigned int *v78;
  uint64_t v79;
  unsigned int *v80;
  unsigned int v81;
  unsigned int v82;
  char v83;
  unsigned int *v84;
  unsigned int k;
  unsigned int v86;
  uint64_t n;
  unsigned int *v88;
  _QWORD *v89;
  uint64_t v90;
  size_t v91;
  void *__src;

  v4 = (char *)malloc_type_malloc(0x68uLL, 0x30772F57uLL);
  if (!v4)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    *a2 = 0;
    return;
  }
  v5 = v4;
  *(_QWORD *)v4 = 96;
  v6 = *((_DWORD *)this + 1);
  *((_QWORD *)v4 + 10) = 0;
  v7 = (unsigned int **)(v4 + 80);
  *((_DWORD *)v4 + 2) = 1;
  v8 = (unsigned int *)(v4 + 8);
  *((_DWORD *)v4 + 3) = v6;
  *((_OWORD *)v4 + 1) = 0u;
  v9 = (unsigned int **)(v4 + 16);
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *(_OWORD *)(v4 + 58) = 0u;
  *((_QWORD *)v4 + 11) = 0;
  *((_QWORD *)v4 + 12) = 0;
  v10 = (unsigned int *)*((_QWORD *)this + 1);
  if (v10)
  {
    v11 = atomic_load(v10);
    if (v11 != -1)
    {
      do
      {
        v12 = __ldaxr(v10);
        if (v12 == v11)
        {
          if (!__stlxr(v11 + 1, v10))
            break;
        }
        else
        {
          __clrex();
        }
        v11 = v12;
      }
      while (v12 != -1);
    }
  }
  v13 = *v9;
  *v9 = v10;
  if (v13)
  {
    for (i = atomic_load(v13); i != -1; i = v15)
    {
      if (!i)
LABEL_152:
        abort();
      v15 = __ldaxr(v13);
      if (v15 == i)
      {
        if (!__stlxr(i - 1, v13))
        {
          if (i == 1)
          {
            v16 = *((_QWORD *)v13 + 2);
            if (v16)
            {
              v17 = *(void (**)(unsigned int *))(v16 + 160);
              if (v17)
              {
                v17(v13);
                *((_QWORD *)v13 + 1) = 0;
                v13[1] = 0;
              }
            }
            v19 = *((_QWORD *)v13 - 1);
            v18 = v13 - 2;
            v20 = v19 + 8;
            if (v19 != -8)
              bzero(v18, v20);
            free(v18);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  v21 = (unsigned int *)*((_QWORD *)this + 2);
  if (v21)
  {
    v22 = atomic_load(v21);
    if (v22 != -1)
    {
      do
      {
        v23 = __ldaxr(v21);
        if (v23 == v22)
        {
          if (!__stlxr(v22 + 1, v21))
            break;
        }
        else
        {
          __clrex();
        }
        v22 = v23;
      }
      while (v23 != -1);
    }
  }
  v24 = v5[3];
  v5[3] = v21;
  if (v24)
  {
    for (j = atomic_load((unsigned int *)v24); j != -1; j = v26)
    {
      if (!j)
        goto LABEL_152;
      v26 = __ldaxr((unsigned int *)v24);
      if (v26 == j)
      {
        if (!__stlxr(j - 1, (unsigned int *)v24))
        {
          if (j == 1)
          {
            v27 = *(_QWORD *)(v24 + 16);
            if (v27)
            {
              v28 = *(void (**)(uint64_t))(v27 + 160);
              if (v28)
              {
                v28(v24);
                *(_QWORD *)(v24 + 8) = 0;
                *(_DWORD *)(v24 + 4) = 0;
              }
            }
            v30 = *(_QWORD *)(v24 - 8);
            v29 = (void *)(v24 - 8);
            v31 = v30 + 8;
            if (v30 != -8)
              bzero(v29, v31);
            free(v29);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  v33 = v5 + 5;
  v32 = v5[5];
  v34 = (const void *)*((_QWORD *)this + 4);
  v5[4] = *((_QWORD *)this + 3);
  v35 = *((_QWORD *)this + 5);
  if (v32)
  {
    v37 = *(_QWORD *)(v32 - 8);
    v36 = (void *)(v32 - 8);
    v38 = v37 + 8;
    if (v37 != -8)
      bzero(v36, v38);
    free(v36);
  }
  *v33 = 0;
  v5[6] = 0;
  if (v35)
  {
    if ((v35 & 0x8000000000000000) != 0)
    {
      ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/internal.h", 297);
    }
    else
    {
      if (v35 <= 0x7FFFFFFFFFFFFFFBLL)
      {
        v39 = malloc_type_malloc(2 * v35 + 8, 0x30772F57uLL);
        if (v39)
        {
          *v39 = 2 * v35;
          v40 = v39 + 1;
          v5[5] = v40;
          v5[6] = v35;
          memmove(v40, v34, 2 * v35);
          goto LABEL_55;
        }
      }
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      *v33 = 0;
    }
LABEL_131:
    *a2 = 0;
    for (k = atomic_load(v8); k != -1; k = v86)
    {
      if (!k)
        goto LABEL_152;
      v86 = __ldaxr(v8);
      if (v86 == k)
      {
        if (!__stlxr(k - 1, v8))
        {
          if (k == 1)
          {
            ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v8);
            if (*v5 != -8)
              __memset_chk();
            free(v5);
          }
          return;
        }
      }
      else
      {
        __clrex();
      }
    }
    return;
  }
LABEL_55:
  v41 = (unint64_t *)*((_QWORD *)this + 6);
  if (v41)
  {
    v42 = (char *)malloc_type_malloc(0x30uLL, 0x30772F57uLL);
    if (!v42)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      goto LABEL_82;
    }
    v43 = v42;
    *(_OWORD *)(v42 + 8) = 0u;
    v44 = (unint64_t *)(v42 + 8);
    *(_QWORD *)v42 = 40;
    *(_OWORD *)(v42 + 24) = 0u;
    *((_QWORD *)v42 + 5) = 0;
    v45 = 8 * v41[3];
    if (v45 == -8)
      goto LABEL_78;
    if (!v45)
      goto LABEL_79;
    __src = (void *)v41[1];
    v46 = malloc_type_malloc(v45 + 8, 0x30772F57uLL);
    if (!v46)
    {
LABEL_78:
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      goto LABEL_79;
    }
    *v46 = v45;
    v47 = v46 + 1;
    memcpy(v46 + 1, __src, v45);
    v48 = *v41;
    v43[1] = *v41;
    v43[2] = v47;
    *((_DWORD *)v43 + 6) = *((_DWORD *)v41 + 4);
    v49 = v41[4];
    v43[4] = v41[3];
    v43[5] = v49;
    if (v48)
    {
      for (m = 0; m < v48; ++m)
      {
        v51 = v47[m];
        if (v51)
        {
          v52 = (unsigned int *)(v51 + 24);
          v53 = atomic_load((unsigned int *)(v51 + 24));
          if (v53 != -1)
          {
            while (1)
            {
              v54 = __ldaxr(v52);
              if (v54 == v53)
              {
                if (!__stlxr(v53 + 1, v52))
                {
                  v55 = 1;
                  goto LABEL_71;
                }
              }
              else
              {
                __clrex();
              }
              v55 = 0;
LABEL_71:
              if ((v55 & 1) == 0)
              {
                v53 = v54;
                if (v54 != -1)
                  continue;
              }
              break;
            }
          }
          *(_QWORD *)(v43[2] + 8 * m) = v51;
          v47 = (_QWORD *)v43[2];
          if (!v47[m])
          {
            if (!m)
              goto LABEL_149;
            for (n = 0; n != m; ++n)
            {
              v88 = *(unsigned int **)(v43[2] + 8 * n);
              if (v88)
                CRYPTO_BUFFER_free(v88);
            }
            v47 = (_QWORD *)v43[2];
            if (v47)
            {
LABEL_149:
              v90 = *(v47 - 1);
              v89 = v47 - 1;
              v91 = v90 + 8;
              if (v90 != -8)
                bzero(v89, v91);
              free(v89);
            }
LABEL_79:
            if (*v43 != -8)
              __memset_chk();
            free(v43);
LABEL_82:
            v44 = 0;
            break;
          }
          v48 = *v44;
        }
      }
    }
    v56 = (unint64_t *)v5[7];
    v5[7] = v44;
    if (v56)
    {
      v57 = *v56;
      if (*v56)
      {
        v58 = 0;
        do
        {
          v59 = *(unsigned int **)(v56[1] + 8 * v58);
          if (v59)
          {
            CRYPTO_BUFFER_free(v59);
            v57 = *v56;
          }
          ++v58;
        }
        while (v58 < v57);
      }
      v60 = v56[1];
      if (v60)
      {
        v62 = *(_QWORD *)(v60 - 8);
        v61 = (void *)(v60 - 8);
        v63 = v62 + 8;
        if (v62 != -8)
          bzero(v61, v63);
        free(v61);
      }
      v65 = *(v56 - 1);
      v64 = v56 - 1;
      v66 = v65 + 8;
      if (v65 != -8)
        bzero(v64, v66);
      free(v64);
      v44 = (unint64_t *)v5[7];
    }
    if (!v44)
      goto LABEL_131;
  }
  v67 = *((_QWORD *)this + 7);
  if (v67)
  {
    v68 = (unsigned int *)(v67 + 24);
    v69 = atomic_load((unsigned int *)(v67 + 24));
    if (v69 != -1)
    {
      while (1)
      {
        v70 = __ldaxr(v68);
        if (v70 == v69)
        {
          if (!__stlxr(v69 + 1, v68))
          {
            v71 = 1;
            goto LABEL_104;
          }
        }
        else
        {
          __clrex();
        }
        v71 = 0;
LABEL_104:
        if ((v71 & 1) == 0)
        {
          v69 = v70;
          if (v70 != -1)
            continue;
        }
        break;
      }
    }
  }
  v72 = (unsigned int *)v5[8];
  v5[8] = v67;
  if (v72)
    CRYPTO_BUFFER_free(v72);
  v73 = (unsigned int *)*((_QWORD *)this + 9);
  if (v73)
  {
    v74 = v73 + 6;
    v75 = atomic_load(v73 + 6);
    if (v75 != -1)
    {
      while (1)
      {
        v76 = __ldaxr(v74);
        if (v76 == v75)
        {
          if (!__stlxr(v75 + 1, v74))
          {
            v77 = 1;
            goto LABEL_115;
          }
        }
        else
        {
          __clrex();
        }
        v77 = 0;
LABEL_115:
        if ((v77 & 1) == 0)
        {
          v75 = v76;
          if (v76 != -1)
            continue;
        }
        break;
      }
    }
  }
  v78 = *v7;
  *v7 = v73;
  if (v78)
    CRYPTO_BUFFER_free(v78);
  v79 = *((_QWORD *)this + 10);
  if (v79)
  {
    v80 = (unsigned int *)(v79 + 24);
    v81 = atomic_load((unsigned int *)(v79 + 24));
    if (v81 != -1)
    {
      while (1)
      {
        v82 = __ldaxr(v80);
        if (v82 == v81)
        {
          if (!__stlxr(v81 + 1, v80))
          {
            v83 = 1;
            goto LABEL_126;
          }
        }
        else
        {
          __clrex();
        }
        v83 = 0;
LABEL_126:
        if ((v83 & 1) == 0)
        {
          v81 = v82;
          if (v82 != -1)
            continue;
        }
        break;
      }
    }
  }
  v84 = (unsigned int *)v5[11];
  v5[11] = v79;
  if (v84)
    CRYPTO_BUFFER_free(v84);
  *((_WORD *)v5 + 36) = *((_WORD *)this + 32);
  *a2 = v8;
}

uint64_t bssl::Array<unsigned short>::CopyFrom(uint64_t *a1, const void *a2, unint64_t a3)
{
  uint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  _QWORD *v10;
  void *v11;
  uint64_t result;

  v6 = *a1;
  if (*a1)
  {
    v8 = *(_QWORD *)(v6 - 8);
    v7 = (void *)(v6 - 8);
    v9 = v8 + 8;
    if (v8 != -8)
      bzero(v7, v9);
    free(v7);
  }
  *a1 = 0;
  a1[1] = 0;
  if (!a3)
    return 1;
  if ((a3 & 0x8000000000000000) != 0)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/internal.h", 297);
    return 0;
  }
  else
  {
    if (a3 <= 0x7FFFFFFFFFFFFFFBLL)
    {
      v10 = malloc_type_malloc(2 * a3 + 8, 0x30772F57uLL);
      if (v10)
      {
        *v10 = 2 * a3;
        v11 = v10 + 1;
        *a1 = (uint64_t)v11;
        a1[1] = a3;
        memmove(v11, a2, 2 * a3);
        return 1;
      }
    }
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    result = 0;
    *a1 = 0;
  }
  return result;
}

void ssl_credential_st::ClearCertAndKey(ssl_credential_st *this)
{
  uint64_t v2;
  unsigned int i;
  unsigned int v4;
  uint64_t v5;
  unsigned int j;
  unsigned int v7;
  uint64_t v8;
  void (*v9)(uint64_t);
  void *v10;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  void (*v14)(uint64_t);
  void *v15;
  uint64_t v16;
  size_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  unsigned int *v21;
  unint64_t v22;
  void *v23;
  uint64_t v24;
  size_t v25;
  unint64_t *v26;
  uint64_t v27;
  size_t v28;

  v2 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v2)
  {
    for (i = atomic_load((unsigned int *)v2); i != -1; i = v4)
    {
      if (!i)
LABEL_45:
        abort();
      v4 = __ldaxr((unsigned int *)v2);
      if (v4 == i)
      {
        if (!__stlxr(i - 1, (unsigned int *)v2))
        {
          if (i != 1)
            break;
          v13 = *(_QWORD *)(v2 + 16);
          if (v13)
          {
            v14 = *(void (**)(uint64_t))(v13 + 160);
            if (v14)
            {
              v14(v2);
              *(_QWORD *)(v2 + 8) = 0;
              *(_DWORD *)(v2 + 4) = 0;
            }
          }
          v16 = *(_QWORD *)(v2 - 8);
          v15 = (void *)(v2 - 8);
          v17 = v16 + 8;
          if (v16 != -8)
            bzero(v15, v17);
          free(v15);
          v5 = *((_QWORD *)this + 2);
          *((_QWORD *)this + 2) = 0;
          if (v5)
            goto LABEL_11;
          goto LABEL_31;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  v5 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v5)
  {
LABEL_11:
    for (j = atomic_load((unsigned int *)v5); j != -1; j = v7)
    {
      if (!j)
        goto LABEL_45;
      v7 = __ldaxr((unsigned int *)v5);
      if (v7 == j)
      {
        if (!__stlxr(j - 1, (unsigned int *)v5))
        {
          if (j == 1)
          {
            v8 = *(_QWORD *)(v5 + 16);
            if (v8)
            {
              v9 = *(void (**)(uint64_t))(v8 + 160);
              if (v9)
              {
                v9(v5);
                *(_QWORD *)(v5 + 8) = 0;
                *(_DWORD *)(v5 + 4) = 0;
              }
            }
            v11 = *(_QWORD *)(v5 - 8);
            v10 = (void *)(v5 - 8);
            v12 = v11 + 8;
            if (v11 != -8)
              bzero(v10, v12);
            free(v10);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
LABEL_31:
  *((_QWORD *)this + 3) = 0;
  v18 = (unint64_t *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v18)
  {
    v19 = *v18;
    if (*v18)
    {
      v20 = 0;
      do
      {
        v21 = *(unsigned int **)(v18[1] + 8 * v20);
        if (v21)
        {
          CRYPTO_BUFFER_free(v21);
          v19 = *v18;
        }
        ++v20;
      }
      while (v20 < v19);
    }
    v22 = v18[1];
    if (v22)
    {
      v24 = *(_QWORD *)(v22 - 8);
      v23 = (void *)(v22 - 8);
      v25 = v24 + 8;
      if (v24 != -8)
        bzero(v23, v25);
      free(v23);
    }
    v27 = *(v18 - 1);
    v26 = v18 - 1;
    v28 = v27 + 8;
    if (v27 != -8)
      bzero(v26, v28);
    free(v26);
  }
}

uint64_t ssl_credential_st::SetLeafCert(uint64_t a1, uint64_t *a2, int a3)
{
  int v6;
  uint64_t v7;
  unsigned int *v8;
  const evp_pkey_st *v9;
  unsigned int *v10;
  unsigned int v11;
  const evp_pkey_st *v12;
  EVP_PKEY *v13;
  unint64_t *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  int v20;
  unint64_t v21;
  void *v22;
  uint64_t v23;
  size_t v24;
  unint64_t *v25;
  uint64_t v26;
  size_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  unsigned int *v31;
  unint64_t v32;
  void *v33;
  uint64_t v34;
  size_t v35;
  unint64_t *v36;
  uint64_t v37;
  size_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int i;
  unsigned int v42;
  uint64_t v43;
  void (*v44)(unsigned int *);
  unsigned int *v45;
  uint64_t v46;
  size_t v47;
  uint64_t v48;
  unsigned int j;
  unsigned int v50;
  uint64_t v51;
  void (*v52)(uint64_t);
  void *v53;
  uint64_t v54;
  size_t v55;
  __int128 v57;
  unsigned __int8 *v58[2];
  __int128 v59;

  v6 = *(_DWORD *)(a1 + 4);
  v7 = *(_QWORD *)(*a2 + 16);
  *(_QWORD *)&v57 = *(_QWORD *)(*a2 + 8);
  *((_QWORD *)&v57 + 1) = v7;
  v59 = v57;
  if ((bssl::ssl_cert_skip_to_spki(&v59, v58) & 1) == 0)
  {
    ERR_put_error(16, 0, 272, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", 333);
    return 0;
  }
  v8 = EVP_parse_public_key(v58);
  if (!v8)
    return 0;
  v10 = v8;
  v11 = v8[1];
  if (v11 != 6 && v11 != 949)
  {
    if (v11 == 408)
    {
      if (bssl::ssl_cert_check_key_usage(&v57, 0))
        goto LABEL_7;
      v20 = 178;
    }
    else
    {
      v20 = 170;
    }
    ERR_put_error(16, 0, 228, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_credential.cc", v20);
    goto LABEL_26;
  }
LABEL_7:
  if (v6 == 1)
    goto LABEL_13;
  v12 = *(const evp_pkey_st **)(a1 + 16);
  if (!v12 || (bssl::ssl_compare_public_and_private_key((bssl *)v10, v12, v9) & 1) != 0)
    goto LABEL_13;
  if (!a3)
  {
LABEL_26:
    v18 = 0;
    goto LABEL_56;
  }
  ERR_clear_error();
  v13 = *(EVP_PKEY **)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v13)
    EVP_PKEY_free(v13);
LABEL_13:
  v14 = *(unint64_t **)(a1 + 48);
  if (!v14)
  {
    v15 = (unint64_t *)OPENSSL_sk_new_null();
    v14 = v15;
    if (v15 && !OPENSSL_sk_insert(v15, 0, *v15))
    {
      v16 = *v14;
      if (*v14)
      {
        v17 = 0;
        do
        {
          v19 = *(unsigned int **)(v14[1] + 8 * v17);
          if (v19)
          {
            CRYPTO_BUFFER_free(v19);
            v16 = *v14;
          }
          ++v17;
        }
        while (v17 < v16);
      }
      v21 = v14[1];
      if (v21)
      {
        v23 = *(_QWORD *)(v21 - 8);
        v22 = (void *)(v21 - 8);
        v24 = v23 + 8;
        if (v23 != -8)
          bzero(v22, v24);
        free(v22);
      }
      v26 = *(v14 - 1);
      v25 = v14 - 1;
      v27 = v26 + 8;
      if (v26 != -8)
        bzero(v25, v27);
      free(v25);
      v14 = 0;
    }
    v28 = *(unint64_t **)(a1 + 48);
    *(_QWORD *)(a1 + 48) = v14;
    if (v28)
    {
      v29 = *v28;
      if (*v28)
      {
        v30 = 0;
        do
        {
          v31 = *(unsigned int **)(v28[1] + 8 * v30);
          if (v31)
          {
            CRYPTO_BUFFER_free(v31);
            v29 = *v28;
          }
          ++v30;
        }
        while (v30 < v29);
      }
      v32 = v28[1];
      if (v32)
      {
        v34 = *(_QWORD *)(v32 - 8);
        v33 = (void *)(v32 - 8);
        v35 = v34 + 8;
        if (v34 != -8)
          bzero(v33, v35);
        free(v33);
      }
      v37 = *(v28 - 1);
      v36 = v28 - 1;
      v38 = v37 + 8;
      if (v37 != -8)
        bzero(v36, v38);
      free(v36);
      v14 = *(unint64_t **)(a1 + 48);
    }
    if (!v14)
      goto LABEL_26;
  }
  if (*v14)
  {
    CRYPTO_BUFFER_free(*(unsigned int **)v14[1]);
    v39 = *(_QWORD *)(a1 + 48);
    v40 = *a2;
    *a2 = 0;
    if (!v39)
      goto LABEL_54;
  }
  else
  {
    CRYPTO_BUFFER_free(0);
    v39 = *(_QWORD *)(a1 + 48);
    v40 = *a2;
    *a2 = 0;
    if (!v39)
      goto LABEL_54;
  }
  if (*(_QWORD *)v39)
    **(_QWORD **)(v39 + 8) = v40;
LABEL_54:
  if (v6 == 1)
  {
    v18 = 1;
LABEL_56:
    for (i = atomic_load(v10); i != -1; i = v42)
    {
      if (!i)
        goto LABEL_87;
      v42 = __ldaxr(v10);
      if (v42 == i)
      {
        if (!__stlxr(i - 1, v10))
        {
          if (i == 1)
          {
            v43 = *((_QWORD *)v10 + 2);
            if (v43)
            {
              v44 = *(void (**)(unsigned int *))(v43 + 160);
              if (v44)
              {
                v44(v10);
                *((_QWORD *)v10 + 1) = 0;
                v10[1] = 0;
              }
            }
            v46 = *((_QWORD *)v10 - 1);
            v45 = v10 - 2;
            v47 = v46 + 8;
            if (v46 != -8)
              bzero(v45, v47);
            free(v45);
          }
          return v18;
        }
      }
      else
      {
        __clrex();
      }
    }
    return v18;
  }
  v48 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v10;
  if (v48)
  {
    for (j = atomic_load((unsigned int *)v48); j != -1; j = v50)
    {
      if (!j)
LABEL_87:
        abort();
      v50 = __ldaxr((unsigned int *)v48);
      if (v50 == j)
      {
        if (!__stlxr(j - 1, (unsigned int *)v48))
        {
          if (j == 1)
          {
            v51 = *(_QWORD *)(v48 + 16);
            if (v51)
            {
              v52 = *(void (**)(uint64_t))(v51 + 160);
              if (v52)
              {
                v52(v48);
                *(_QWORD *)(v48 + 8) = 0;
                *(_DWORD *)(v48 + 4) = 0;
              }
            }
            v54 = *(_QWORD *)(v48 - 8);
            v53 = (void *)(v48 - 8);
            v55 = v54 + 8;
            if (v54 != -8)
              bzero(v53, v55);
            free(v53);
          }
          return 1;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  return 1;
}

uint64_t ssl_credential_st::AppendIntermediateCert(uint64_t a1, unsigned int **a2)
{
  unint64_t *v3;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int *v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  size_t v12;
  unint64_t *v13;
  uint64_t v14;
  size_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int *v19;
  unint64_t v20;
  void *v21;
  uint64_t v22;
  size_t v23;
  unint64_t *v24;
  uint64_t v25;
  size_t v26;
  unsigned int *v27;

  v3 = *(unint64_t **)(a1 + 48);
  if (v3)
    goto LABEL_30;
  v5 = (unint64_t *)OPENSSL_sk_new_null();
  v3 = v5;
  if (v5 && !OPENSSL_sk_insert(v5, 0, *v5))
  {
    v6 = *v3;
    if (*v3)
    {
      v7 = 0;
      do
      {
        v8 = *(unsigned int **)(v3[1] + 8 * v7);
        if (v8)
        {
          CRYPTO_BUFFER_free(v8);
          v6 = *v3;
        }
        ++v7;
      }
      while (v7 < v6);
    }
    v9 = v3[1];
    if (v9)
    {
      v11 = *(_QWORD *)(v9 - 8);
      v10 = (void *)(v9 - 8);
      v12 = v11 + 8;
      if (v11 != -8)
        bzero(v10, v12);
      free(v10);
    }
    v14 = *(v3 - 1);
    v13 = v3 - 1;
    v15 = v14 + 8;
    if (v14 != -8)
      bzero(v13, v15);
    free(v13);
    v3 = 0;
  }
  v16 = *(unint64_t **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = v3;
  if (v16)
  {
    v17 = *v16;
    if (*v16)
    {
      v18 = 0;
      do
      {
        v19 = *(unsigned int **)(v16[1] + 8 * v18);
        if (v19)
        {
          CRYPTO_BUFFER_free(v19);
          v17 = *v16;
        }
        ++v18;
      }
      while (v18 < v17);
    }
    v20 = v16[1];
    if (v20)
    {
      v22 = *(_QWORD *)(v20 - 8);
      v21 = (void *)(v20 - 8);
      v23 = v22 + 8;
      if (v22 != -8)
        bzero(v21, v23);
      free(v21);
    }
    v25 = *(v16 - 1);
    v24 = v16 - 1;
    v26 = v25 + 8;
    if (v25 != -8)
      bzero(v24, v26);
    free(v24);
    v3 = *(unint64_t **)(a1 + 48);
  }
  if (v3)
  {
LABEL_30:
    v27 = *a2;
    *a2 = 0;
    if (OPENSSL_sk_insert(v3, (uint64_t)v27, *v3))
      return 1;
    if (v27)
      CRYPTO_BUFFER_free(v27);
  }
  return 0;
}

void SSL_CREDENTIAL_free(ssl_credential_st *this)
{
  unsigned int i;
  unsigned int v3;
  char *v4;
  uint64_t v5;
  size_t v6;

  if (this)
  {
    for (i = atomic_load((unsigned int *)this); i != -1; i = v3)
    {
      if (!i)
        abort();
      v3 = __ldaxr((unsigned int *)this);
      if (v3 == i)
      {
        if (!__stlxr(i - 1, (unsigned int *)this))
        {
          if (i == 1)
          {
            ssl_credential_st::~ssl_credential_st(this);
            v5 = *((_QWORD *)this - 1);
            v4 = (char *)this - 8;
            v6 = v5 + 8;
            if (v5 != -8)
              bzero(v4, v6);
            free(v4);
          }
          return;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
}

uint64_t SSL_CREDENTIAL_set1_private_key(_QWORD *a1, evp_pkey_st *a2, const evp_pkey_st *a3)
{
  bssl *v5;
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int i;
  unsigned int v11;
  uint64_t v12;
  void (*v13)(uint64_t);
  void *v14;
  uint64_t v15;
  size_t v16;

  v5 = (bssl *)a1[1];
  if (!v5 || (result = bssl::ssl_compare_public_and_private_key(v5, a2, a3), (_DWORD)result))
  {
    if (a2)
    {
      v7 = atomic_load((unsigned int *)a2);
      if (v7 != -1)
      {
        do
        {
          v8 = __ldaxr((unsigned int *)a2);
          if (v8 == v7)
          {
            if (!__stlxr(v7 + 1, (unsigned int *)a2))
              break;
          }
          else
          {
            __clrex();
          }
          v7 = v8;
        }
        while (v8 != -1);
      }
    }
    v9 = a1[2];
    a1[2] = a2;
    if (v9)
    {
      for (i = atomic_load((unsigned int *)v9); i != -1; i = v11)
      {
        if (!i)
          abort();
        v11 = __ldaxr((unsigned int *)v9);
        if (v11 == i)
        {
          if (!__stlxr(i - 1, (unsigned int *)v9))
          {
            if (i == 1)
            {
              v12 = *(_QWORD *)(v9 + 16);
              if (v12)
              {
                v13 = *(void (**)(uint64_t))(v12 + 160);
                if (v13)
                {
                  v13(v9);
                  *(_QWORD *)(v9 + 8) = 0;
                  *(_DWORD *)(v9 + 4) = 0;
                }
              }
              v15 = *(_QWORD *)(v9 - 8);
              v14 = (void *)(v9 - 8);
              v16 = v15 + 8;
              if (v15 != -8)
                bzero(v14, v16);
              free(v14);
            }
            break;
          }
        }
        else
        {
          __clrex();
        }
      }
    }
    a1[3] = 0;
    return 1;
  }
  return result;
}

BOOL SSL_CREDENTIAL_set1_cert_chain(uint64_t a1, unsigned int **a2, unint64_t a3)
{
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  int v9;
  uint64_t *i;
  uint64_t v11;
  unsigned int *v12;
  BOOL v13;
  unsigned int v15;
  uint64_t v16;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int v19;
  char appended;
  unsigned int *v21;
  unsigned int v22;
  void *v23;
  void *v24;

  if (!a3)
  {
    ERR_put_error(16, 0, 66, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_credential.cc", 282);
    return 0;
  }
  v6 = *a2;
  if (*a2)
  {
    v7 = v6 + 6;
    v8 = atomic_load(v6 + 6);
    if (v8 != -1)
    {
      do
      {
        v15 = __ldaxr(v7);
        if (v15 == v8)
        {
          if (!__stlxr(v8 + 1, v7))
            break;
        }
        else
        {
          __clrex();
        }
        v8 = v15;
      }
      while (v15 != -1);
    }
  }
  v24 = v6;
  v9 = ssl_credential_st::SetLeafCert(a1, (uint64_t *)&v24, 0);
  if (v24)
    CRYPTO_BUFFER_free((unsigned int *)v24);
  if (!v9)
    return 0;
  for (i = *(uint64_t **)(a1 + 48); i; i = *(uint64_t **)(a1 + 48))
  {
    if ((unint64_t)*i < 2)
      break;
    v11 = *i - 1;
    v12 = *(unsigned int **)(i[1] + 8 * v11);
    *i = v11;
    CRYPTO_BUFFER_free(v12);
  }
  if (a3 >= 2)
  {
    v13 = 0;
    v16 = 1;
    do
    {
      v17 = a2[v16];
      if (v17)
      {
        v18 = v17 + 6;
        v19 = atomic_load(v17 + 6);
        if (v19 != -1)
        {
          do
          {
            v22 = __ldaxr(v18);
            if (v22 == v19)
            {
              if (!__stlxr(v19 + 1, v18))
                break;
            }
            else
            {
              __clrex();
            }
            v19 = v22;
          }
          while (v22 != -1);
        }
      }
      v23 = v17;
      appended = ssl_credential_st::AppendIntermediateCert(a1, (unsigned int **)&v23);
      v21 = (unsigned int *)v23;
      v23 = 0;
      if (v21)
        CRYPTO_BUFFER_free(v21);
      if ((appended & 1) == 0)
        break;
      v13 = ++v16 >= a3;
    }
    while (v16 != a3);
  }
  else
  {
    return 1;
  }
  return v13;
}

_QWORD *bssl::SSLKeyShare::Create@<X0>(bssl::SSLKeyShare *this@<X0>, _QWORD *a2@<X8>)
{
  int v2;
  _QWORD *result;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;

  v2 = (int)this;
  result = 0;
  switch(v2)
  {
    case 21:
      if (pthread_once(&EC_group_p224_once, (void (*)(void))EC_group_p224_init))
        goto LABEL_21;
      v5 = malloc_type_malloc(0x28uLL, 0x30772F57uLL);
      if (!v5)
        goto LABEL_20;
      v6 = v5;
      *v5 = 32;
      v5[1] = off_24C0D21B8;
      result = v5 + 1;
      v6[2] = 0;
      v6[3] = EC_group_p224_storage;
      *((_WORD *)v6 + 16) = 21;
LABEL_5:
      *a2 = result;
      break;
    case 22:
    case 26:
    case 27:
    case 28:
      goto LABEL_5;
    case 23:
      if (pthread_once(&EC_group_p256_once, (void (*)(void))EC_group_p256_init))
        goto LABEL_21;
      v9 = malloc_type_malloc(0x28uLL, 0x30772F57uLL);
      if (!v9)
        goto LABEL_20;
      v10 = v9;
      *v9 = 32;
      v9[1] = off_24C0D21B8;
      result = v9 + 1;
      v10[2] = 0;
      v10[3] = EC_group_p256_storage;
      *((_WORD *)v10 + 16) = 23;
      *a2 = result;
      break;
    case 24:
      if (pthread_once(&EC_group_p384_once, (void (*)(void))EC_group_p384_init))
        goto LABEL_21;
      v11 = malloc_type_malloc(0x28uLL, 0x30772F57uLL);
      if (!v11)
        goto LABEL_20;
      v12 = v11;
      *v11 = 32;
      v11[1] = off_24C0D21B8;
      result = v11 + 1;
      v12[2] = 0;
      v12[3] = EC_group_p384_storage;
      *((_WORD *)v12 + 16) = 24;
      *a2 = result;
      break;
    case 25:
      if (pthread_once(&EC_group_p521_once, (void (*)(void))EC_group_p521_init))
LABEL_21:
        abort();
      v13 = malloc_type_malloc(0x28uLL, 0x30772F57uLL);
      if (!v13)
        goto LABEL_20;
      v14 = v13;
      *v13 = 32;
      v13[1] = off_24C0D21B8;
      result = v13 + 1;
      v14[2] = 0;
      v14[3] = EC_group_p521_storage;
      *((_WORD *)v14 + 16) = 25;
      *a2 = result;
      break;
    case 29:
      v8 = malloc_type_malloc(0x30uLL, 0x30772F57uLL);
      if (!v8)
        goto LABEL_20;
      *v8 = 40;
      v8[1] = &off_24C0D2208;
      result = v8 + 1;
      *a2 = result;
      break;
    default:
      if (v2 != 25497)
        goto LABEL_5;
      v7 = malloc_type_malloc(0x1E90uLL, 0x30772F57uLL);
      if (v7)
      {
        *v7 = 7816;
        v7[1] = &off_24C0D2258;
        result = v7 + 1;
        *a2 = result;
      }
      else
      {
LABEL_20:
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        result = 0;
        *a2 = 0;
      }
      break;
  }
  return result;
}

uint64_t bssl::ssl_name_to_group_id(bssl *this, char *__s2, const char *a3)
{
  uint64_t result;
  _WORD *v6;

  result = 0;
  switch((unint64_t)a3)
  {
    case 5uLL:
      if (!strncmp("P-224", __s2, 5uLL))
        goto LABEL_18;
      v6 = &unk_208F30708;
      if (!strncmp("P-256", __s2, 5uLL))
        goto LABEL_18;
      v6 = &unk_208F30750;
      if (!strncmp("P-384", __s2, 5uLL))
        goto LABEL_18;
      v6 = &unk_208F30798;
      if (!strncmp("P-521", __s2, 5uLL))
        goto LABEL_18;
      result = 0;
      break;
    case 6uLL:
      v6 = &unk_208F307E0;
      if (!strncmp("X25519", __s2, 6uLL) || !strncmp("x25519", __s2, 6uLL))
        goto LABEL_18;
      result = 0;
      break;
    case 9uLL:
      if (!strncmp("secp224r1", __s2, 9uLL))
        goto LABEL_18;
      v6 = &unk_208F30750;
      if (!strncmp("secp384r1", __s2, 9uLL))
        goto LABEL_18;
      v6 = &unk_208F30798;
      if (!strncmp("secp521r1", __s2, 9uLL))
        goto LABEL_18;
      result = 0;
      break;
    case 0xAuLL:
      v6 = &unk_208F30708;
      if (!strncmp("prime256v1", __s2, 0xAuLL))
        goto LABEL_18;
      result = 0;
      break;
    case 0x15uLL:
      v6 = &unk_208F30828;
      if (!strncmp("X25519Kyber768Draft00", __s2, 0x15uLL))
      {
LABEL_18:
        *(_WORD *)this = v6[2];
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      return result;
  }
  return result;
}

void bssl::`anonymous namespace'::ECKeyShare::~ECKeyShare(bssl::_anonymous_namespace_::ECKeyShare *this)
{
  uint64_t *v1;
  int v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  size_t v6;
  uint64_t *v7;
  uint64_t v8;
  size_t v9;

  v1 = (uint64_t *)*((_QWORD *)this + 1);
  *(_QWORD *)this = off_24C0D21B8;
  *((_QWORD *)this + 1) = 0;
  if (v1)
  {
    v2 = *((_DWORD *)v1 + 5);
    if ((v2 & 2) == 0)
    {
      v3 = *v1;
      if (*v1)
      {
        v5 = *(_QWORD *)(v3 - 8);
        v4 = (void *)(v3 - 8);
        v6 = v5 + 8;
        if (v5 != -8)
          bzero(v4, v6);
        free(v4);
        v2 = *((_DWORD *)v1 + 5);
      }
    }
    if ((v2 & 1) != 0)
    {
      v8 = *(v1 - 1);
      v7 = v1 - 1;
      v9 = v8 + 8;
      if (v8 != -8)
        bzero(v7, v9);
      free(v7);
    }
    else
    {
      *v1 = 0;
    }
  }
}

{
  uint64_t *v1;
  int v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  size_t v6;
  uint64_t *v7;
  uint64_t v8;
  size_t v9;

  v1 = (uint64_t *)*((_QWORD *)this + 1);
  *(_QWORD *)this = off_24C0D21B8;
  *((_QWORD *)this + 1) = 0;
  if (v1)
  {
    v2 = *((_DWORD *)v1 + 5);
    if ((v2 & 2) == 0)
    {
      v3 = *v1;
      if (*v1)
      {
        v5 = *(_QWORD *)(v3 - 8);
        v4 = (void *)(v3 - 8);
        v6 = v5 + 8;
        if (v5 != -8)
          bzero(v4, v6);
        free(v4);
        v2 = *((_DWORD *)v1 + 5);
      }
    }
    if ((v2 & 1) != 0)
    {
      v8 = *(v1 - 1);
      v7 = v1 - 1;
      v9 = v8 + 8;
      if (v8 != -8)
        bzero(v7, v9);
      free(v7);
    }
    else
    {
      *v1 = 0;
    }
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t bssl::`anonymous namespace'::ECKeyShare::GroupID(bssl::_anonymous_namespace_::ECKeyShare *this)
{
  return *((unsigned __int16 *)this + 12);
}

BOOL bssl::`anonymous namespace'::ECKeyShare::Generate(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t *v6;
  int v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;
  uint64_t *v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  const EC_POINT *v18;
  const EC_GROUP *v19;
  size_t v20;
  size_t v21;
  _BOOL4 v22;
  const char *v23;
  int v24;
  int v25;
  int v26;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  char v31;
  _BOOL8 v32;
  unsigned __int8 *buf;

  v4 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v4)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v5 = 0;
    v6 = *(uint64_t **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = 0;
    if (v6)
      goto LABEL_3;
LABEL_12:
    if (!v5)
      return 0;
    goto LABEL_17;
  }
  *v4 = 24;
  v4[1] = 0;
  v5 = (uint64_t)(v4 + 1);
  v4[2] = 0;
  v4[3] = 0x100000000;
  v6 = *(uint64_t **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v4 + 1;
  if (!v6)
    goto LABEL_12;
LABEL_3:
  v7 = *((_DWORD *)v6 + 5);
  if ((v7 & 2) == 0)
  {
    v8 = *v6;
    if (*v6)
    {
      v10 = *(_QWORD *)(v8 - 8);
      v9 = (void *)(v8 - 8);
      v11 = v10 + 8;
      if (v10 != -8)
        bzero(v9, v11);
      free(v9);
      v7 = *((_DWORD *)v6 + 5);
    }
  }
  if ((v7 & 1) != 0)
  {
    v13 = *(v6 - 1);
    v12 = v6 - 1;
    v14 = v13 + 8;
    if (v13 != -8)
      bzero(v12, v14);
    free(v12);
    v5 = *(_QWORD *)(a1 + 8);
    if (!v5)
      return 0;
  }
  else
  {
    *v6 = 0;
    v5 = *(_QWORD *)(a1 + 8);
    if (!v5)
      return 0;
  }
LABEL_17:
  v15 = *(_QWORD *)(a1 + 16);
  if (!bn_wexpand(v5, *(int *)(v15 + 264))
    || !bn_rand_range_words(*(uint64_t **)v5, 1uLL, *(uint64_t **)(v15 + 256), *(int *)(v15 + 264), (uint64_t)&BN_rand_range_ex_kDefaultAdditionalData))
  {
    return 0;
  }
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 8) = *(_DWORD *)(v15 + 264);
  v16 = *(_QWORD *)(a1 + 16);
  if (!v16)
  {
    v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/ec/ec.c";
    v24 = 15;
    v25 = 67;
    v26 = 469;
LABEL_28:
    ERR_put_error(v24, 0, v25, v23, v26);
    return 0;
  }
  v17 = (char *)malloc_type_malloc(0xE8uLL, 0x30772F57uLL);
  if (!v17)
  {
    v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v24 = 14;
    v25 = 65;
    v26 = 247;
    goto LABEL_28;
  }
  *(_QWORD *)v17 = 224;
  v18 = (const EC_POINT *)(v17 + 8);
  if (!*(_DWORD *)(v16 + 512))
  {
    v28 = (unsigned int *)(v16 + 540);
    v29 = atomic_load((unsigned int *)(v16 + 540));
    if (v29 != -1)
    {
      while (1)
      {
        v30 = __ldaxr(v28);
        if (v30 == v29)
        {
          if (!__stlxr(v29 + 1, v28))
          {
            v31 = 1;
            goto LABEL_36;
          }
        }
        else
        {
          __clrex();
        }
        v31 = 0;
LABEL_36:
        if ((v31 & 1) == 0)
        {
          v29 = v30;
          if (v30 != -1)
            continue;
        }
        break;
      }
    }
  }
  *((_QWORD *)v17 + 1) = v16;
  *((_OWORD *)v17 + 1) = 0u;
  *((_OWORD *)v17 + 2) = 0u;
  *((_OWORD *)v17 + 3) = 0u;
  *((_OWORD *)v17 + 4) = 0u;
  *((_OWORD *)v17 + 5) = 0u;
  *((_OWORD *)v17 + 6) = 0u;
  *((_OWORD *)v17 + 7) = 0u;
  *((_OWORD *)v17 + 8) = 0u;
  *((_OWORD *)v17 + 9) = 0u;
  *((_OWORD *)v17 + 10) = 0u;
  *((_OWORD *)v17 + 11) = 0u;
  *((_OWORD *)v17 + 12) = 0u;
  *((_OWORD *)v17 + 13) = 0u;
  *((_QWORD *)v17 + 28) = 0;
  if (ec_point_mul_no_self_test(*(const EC_GROUP **)(a1 + 16), (uint64_t)v18, *(BN_CTX **)(a1 + 8), 0, 0, 0))
  {
    v19 = *(const EC_GROUP **)(a1 + 16);
    v20 = EC_POINT_point2oct(v19, v18, POINT_CONVERSION_UNCOMPRESSED, 0, 0, 0);
    v22 = v20
       && (v21 = v20, buf = 0, CBB_add_space(a2, &buf, v20))
       && EC_POINT_point2oct(v19, v18, POINT_CONVERSION_UNCOMPRESSED, buf, v21, 0) == v21;
    v32 = v22;
  }
  else
  {
    v32 = 0;
  }
  EC_POINT_free(v18);
  return v32;
}

uint64_t bssl::`anonymous namespace'::ECKeyShare::Encap(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;

  *a4 = 80;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, a3, a4, a5, a6);
  return result;
}

uint64_t bssl::`anonymous namespace'::ECKeyShare::Decap(uint64_t a1, uint64_t a2, _BYTE *a3, const unsigned __int8 *a4, size_t a5)
{
  uint64_t v10;
  char *v11;
  const EC_GROUP **v12;
  uint64_t v13;
  char *v14;
  EC_POINT *v15;
  _QWORD *v16;
  BIGNUM *v17;
  const char *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int flags;
  unint64_t *d;
  unint64_t *v33;
  uint64_t v34;
  size_t v35;
  int *p_neg;
  uint64_t v37;
  size_t v38;
  unsigned int *v40;
  unsigned int v41;
  unsigned int v42;
  char v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int v46;
  char v47;
  int v48;
  unint64_t v49;
  _BOOL4 v50;
  _BOOL4 v51;
  _BOOL4 v52;
  _BOOL4 v53;
  _BOOL4 v54;
  _BOOL4 v55;
  int v56;
  unsigned int v57;
  char *v58;
  unint64_t v59;
  _QWORD *v60;
  char *v61;
  uint64_t v62;
  size_t v63;

  *a3 = 80;
  v10 = *(_QWORD *)(a1 + 16);
  if (!v10)
  {
    ERR_put_error(15, 0, 67, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/ec/ec.c", 469);
    v12 = 0;
    v13 = *(_QWORD *)(a1 + 16);
    if (v13)
      goto LABEL_5;
    goto LABEL_11;
  }
  v11 = (char *)malloc_type_malloc(0xE8uLL, 0x30772F57uLL);
  if (!v11)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v12 = 0;
    v13 = *(_QWORD *)(a1 + 16);
    if (v13)
      goto LABEL_5;
LABEL_11:
    v18 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/ec/ec.c";
    v19 = 15;
    v20 = 67;
    v21 = 469;
    goto LABEL_15;
  }
  *(_QWORD *)v11 = 224;
  v12 = (const EC_GROUP **)(v11 + 8);
  if (!*(_DWORD *)(v10 + 512))
  {
    v40 = (unsigned int *)(v10 + 540);
    v41 = atomic_load((unsigned int *)(v10 + 540));
    if (v41 != -1)
    {
      while (1)
      {
        v42 = __ldaxr(v40);
        if (v42 == v41)
        {
          if (!__stlxr(v41 + 1, v40))
          {
            v43 = 1;
            goto LABEL_54;
          }
        }
        else
        {
          __clrex();
        }
        v43 = 0;
LABEL_54:
        if ((v43 & 1) == 0)
        {
          v41 = v42;
          if (v42 != -1)
            continue;
        }
        break;
      }
    }
  }
  *((_QWORD *)v11 + 1) = v10;
  *((_OWORD *)v11 + 1) = 0u;
  *((_OWORD *)v11 + 2) = 0u;
  *((_OWORD *)v11 + 3) = 0u;
  *((_OWORD *)v11 + 4) = 0u;
  *((_OWORD *)v11 + 5) = 0u;
  *((_OWORD *)v11 + 6) = 0u;
  *((_OWORD *)v11 + 7) = 0u;
  *((_OWORD *)v11 + 8) = 0u;
  *((_OWORD *)v11 + 9) = 0u;
  *((_OWORD *)v11 + 10) = 0u;
  *((_OWORD *)v11 + 11) = 0u;
  *((_OWORD *)v11 + 12) = 0u;
  *((_OWORD *)v11 + 13) = 0u;
  *((_QWORD *)v11 + 28) = 0;
  v13 = *(_QWORD *)(a1 + 16);
  if (!v13)
    goto LABEL_11;
LABEL_5:
  v14 = (char *)malloc_type_malloc(0xE8uLL, 0x30772F57uLL);
  if (!v14)
  {
    v18 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v19 = 14;
    v20 = 65;
    v21 = 247;
LABEL_15:
    ERR_put_error(v19, 0, v20, v18, v21);
    v15 = 0;
    v16 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (!v16)
      goto LABEL_8;
    goto LABEL_16;
  }
  *(_QWORD *)v14 = 224;
  v15 = (EC_POINT *)(v14 + 8);
  if (!*(_DWORD *)(v13 + 512))
  {
    v44 = (unsigned int *)(v13 + 540);
    v45 = atomic_load((unsigned int *)(v13 + 540));
    if (v45 != -1)
    {
      while (1)
      {
        v46 = __ldaxr(v44);
        if (v46 == v45)
        {
          if (!__stlxr(v45 + 1, v44))
          {
            v47 = 1;
            goto LABEL_63;
          }
        }
        else
        {
          __clrex();
        }
        v47 = 0;
LABEL_63:
        if ((v47 & 1) == 0)
        {
          v45 = v46;
          if (v46 != -1)
            continue;
        }
        break;
      }
    }
  }
  *((_QWORD *)v14 + 1) = v13;
  *((_OWORD *)v14 + 1) = 0u;
  *((_OWORD *)v14 + 2) = 0u;
  *((_OWORD *)v14 + 3) = 0u;
  *((_OWORD *)v14 + 4) = 0u;
  *((_OWORD *)v14 + 5) = 0u;
  *((_OWORD *)v14 + 6) = 0u;
  *((_OWORD *)v14 + 7) = 0u;
  *((_OWORD *)v14 + 8) = 0u;
  *((_OWORD *)v14 + 9) = 0u;
  *((_OWORD *)v14 + 10) = 0u;
  *((_OWORD *)v14 + 11) = 0u;
  *((_OWORD *)v14 + 12) = 0u;
  *((_OWORD *)v14 + 13) = 0u;
  *((_QWORD *)v14 + 28) = 0;
  v16 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v16)
  {
LABEL_8:
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v17 = 0;
    if (!v12)
      goto LABEL_28;
    goto LABEL_17;
  }
LABEL_16:
  *v16 = 24;
  v16[1] = 0;
  v17 = (BIGNUM *)(v16 + 1);
  v16[2] = 0;
  v16[3] = 0x100000000;
  if (!v12)
    goto LABEL_28;
LABEL_17:
  if (v15)
  {
    if (!v17)
    {
      v30 = 0;
      EC_POINT_free(v15);
      goto LABEL_45;
    }
    if (a5 && *a4 == 4 && EC_POINT_oct2point(*(const EC_GROUP **)(a1 + 16), (EC_POINT *)v12, a4, a5, 0))
    {
      if (!ec_point_mul_no_self_test(*(const EC_GROUP **)(a1 + 16), (uint64_t)v15, 0, v12, *(char ***)(a1 + 8), 0)|| !EC_POINT_get_affine_coordinates_GFp(*(const EC_GROUP **)(a1 + 16), v15, v17, 0, 0))
      {
        goto LABEL_91;
      }
      v22 = *(_QWORD *)(a1 + 16);
      v23 = *(unsigned int *)(v22 + 328);
      v24 = v23 & ((int)v23 >> 31);
      v25 = 8 * v23 - 8;
      v26 = *(_DWORD *)(v22 + 328);
      while (1)
      {
        v27 = __OFSUB__(v26--, 1);
        if (v26 < 0 != v27)
          break;
        v28 = *(_QWORD *)(v22 + 320);
        v29 = *(_QWORD *)(v28 + v25);
        v25 -= 8;
        if (v29)
        {
          v24 = v26 + 1;
          goto LABEL_68;
        }
      }
      if ((v23 & 0x80000000) == 0)
        goto LABEL_81;
      v28 = *(_QWORD *)(v22 + 320);
LABEL_68:
      v48 = v24 - 1;
      v49 = *(_QWORD *)(v28 + 8 * v48);
      v50 = v49 != 0;
      v51 = HIDWORD(v49) != 0;
      if (HIDWORD(v49))
        v49 >>= 32;
      v52 = v49 >> 16 != 0;
      if (v49 >> 16)
        v49 >>= 16;
      v53 = v49 > 0xFF;
      if (v49 > 0xFF)
        v49 >>= 8;
      v54 = v49 > 0xF;
      if (v49 > 0xF)
        v49 >>= 4;
      v55 = v49 > 3;
      if (v49 > 3)
        v49 >>= 2;
      v56 = v50 | (v48 << 6) | (32 * v51) | (16 * v52) | (8 * v53) | (4 * v54) | (2 * v55);
      if (v49 > 1)
        ++v56;
      v57 = v56 + 7;
      if (v57 < 8)
      {
LABEL_81:
        v58 = 0;
        v59 = 0;
        goto LABEL_84;
      }
      v59 = v57 >> 3;
      v60 = malloc_type_malloc(v59 + 8, 0x30772F57uLL);
      if (!v60)
      {
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        goto LABEL_91;
      }
      *v60 = v59;
      v58 = (char *)(v60 + 1);
LABEL_84:
      if (BN_bn2bin_padded(v58, v59, (uint64_t)v17))
      {
        OPENSSL_free(*(_QWORD **)a2);
        *(_QWORD *)a2 = v58;
        *(_QWORD *)(a2 + 8) = v59;
        v30 = 1;
        goto LABEL_33;
      }
      if (v58)
      {
        v62 = *((_QWORD *)v58 - 1);
        v61 = v58 - 8;
        v63 = v62 + 8;
        if (v62 != -8)
          bzero(v61, v63);
        free(v61);
        v30 = 0;
      }
      else
      {
LABEL_91:
        v30 = 0;
      }
    }
    else
    {
      ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_key_share.cc", 94);
      v30 = 0;
      *a3 = 50;
    }
LABEL_33:
    flags = v17->flags;
    if ((flags & 2) == 0)
    {
      d = v17->d;
      if (v17->d)
      {
        v34 = *(d - 1);
        v33 = d - 1;
        v35 = v34 + 8;
        if (v34 != -8)
          bzero(v33, v35);
        free(v33);
        flags = v17->flags;
      }
    }
    if ((flags & 1) != 0)
    {
      v37 = *(_QWORD *)&v17[-1].neg;
      p_neg = &v17[-1].neg;
      v38 = v37 + 8;
      if (v37 != -8)
        bzero(p_neg, v38);
      free(p_neg);
      if (!v15)
        goto LABEL_44;
    }
    else
    {
      v17->d = 0;
      if (!v15)
        goto LABEL_44;
    }
LABEL_30:
    EC_POINT_free(v15);
    if (!v12)
      return v30;
    goto LABEL_45;
  }
LABEL_28:
  v30 = 0;
  if (v17)
    goto LABEL_33;
  if (v15)
    goto LABEL_30;
LABEL_44:
  if (v12)
LABEL_45:
    EC_POINT_free((EC_POINT *)v12);
  return v30;
}

uint64_t bssl::`anonymous namespace'::ECKeyShare::SerializePrivateKey(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  _BOOL4 v13;
  _BOOL4 v14;
  _BOOL4 v15;
  _BOOL4 v16;
  _BOOL4 v17;
  _BOOL4 v18;
  int v19;
  uint64_t v20;
  uint64_t result;
  char *v22;
  int8x16_t *v23;
  unint64_t v24;
  unint64_t v25;
  unsigned __int8 v26;
  unint64_t v27;
  unint64_t v28;
  int8x16_t *v29;
  int8x16_t v30;
  unint64_t v31;
  int8x16_t v32;
  int8x16_t v33;
  unint64_t v34;
  int8x8_t v35;
  unint64_t v36;
  int8x8_t *v37;
  int8x8_t v38;
  uint64_t v39;
  unint64_t v40;
  __int8 *v41;
  char v42;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  __int8 *v48;
  char v49;
  int8x16_t *v50;
  int8x16_t *v51;
  uint64_t v52;
  int8x16_t v53;
  int8x16_t v54;
  int8x16_t v55;
  uint64_t v56;
  int8x8_t *v57;
  int8x8_t *v58;
  uint64_t v59;
  int8x8_t v60;
  void *v61;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(unsigned int *)(v2 + 264);
  v4 = v3 & ((int)v3 >> 31);
  v5 = 8 * v3 - 8;
  v6 = *(_DWORD *)(v2 + 264);
  while (1)
  {
    v7 = __OFSUB__(v6--, 1);
    if (v6 < 0 != v7)
      break;
    v8 = *(_QWORD *)(v2 + 256);
    v9 = *(_QWORD *)(v8 + v5);
    v5 -= 8;
    if (v9)
    {
      v4 = v6 + 1;
      goto LABEL_8;
    }
  }
  if ((v3 & 0x80000000) == 0)
  {
    v10 = 0;
    goto LABEL_21;
  }
  v8 = *(_QWORD *)(v2 + 256);
LABEL_8:
  v11 = v4 - 1;
  v12 = *(_QWORD *)(v8 + 8 * v11);
  v13 = v12 != 0;
  v14 = HIDWORD(v12) != 0;
  if (HIDWORD(v12))
    v12 >>= 32;
  v15 = v12 >> 16 != 0;
  if (v12 >> 16)
    v12 >>= 16;
  v16 = v12 > 0xFF;
  if (v12 > 0xFF)
    v12 >>= 8;
  v17 = v12 > 0xF;
  if (v12 > 0xF)
    v12 >>= 4;
  v18 = v12 > 3;
  if (v12 > 3)
    v12 >>= 2;
  v19 = v13 | (v11 << 6) | (32 * v14) | (16 * v15) | (8 * v16) | (4 * v17) | (2 * v18);
  if (v12 > 1)
    ++v19;
  v10 = (v19 + 7) >> 3;
LABEL_21:
  v20 = *(_QWORD *)(a1 + 8);
  v61 = 0;
  result = CBB_add_space(a2, &v61, v10);
  if ((_DWORD)result)
  {
    v22 = (char *)v61;
    v23 = *(int8x16_t **)v20;
    v24 = 8 * *(int *)(v20 + 8);
    v25 = v24 - v10;
    if (v24 <= v10)
      goto LABEL_42;
    if (v25 < 8)
    {
      v26 = 0;
      v27 = v10;
      goto LABEL_36;
    }
    if (v25 >= 0x20)
    {
      v28 = v25 & 0xFFFFFFFFFFFFFFE0;
      v29 = (int8x16_t *)((char *)v23 + v10 + 16);
      v30 = 0uLL;
      v31 = v25 & 0xFFFFFFFFFFFFFFE0;
      v32 = 0uLL;
      do
      {
        v30 = vorrq_s8(v29[-1], v30);
        v32 = vorrq_s8(*v29, v32);
        v29 += 2;
        v31 -= 32;
      }
      while (v31);
      v33 = vorrq_s8(v32, v30);
      *(int8x8_t *)v33.i8 = vorr_s8(*(int8x8_t *)v33.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
      v34 = v33.i64[0] | HIDWORD(v33.i64[0]) | ((unint64_t)(v33.i64[0] | HIDWORD(v33.i64[0])) >> 16);
      v26 = v34 | BYTE1(v34);
      if (v25 == v28)
        goto LABEL_39;
      if ((v25 & 0x18) == 0)
      {
        v27 = v10 + v28;
LABEL_36:
        v40 = v27 - v24;
        v41 = &v23->i8[v27];
        do
        {
          v42 = *v41++;
          v26 |= v42;
        }
        while (!__CFADD__(v40++, 1));
        goto LABEL_39;
      }
    }
    else
    {
      v26 = 0;
      v28 = 0;
    }
    v27 = v10 + (v25 & 0xFFFFFFFFFFFFFFF8);
    v35 = (int8x8_t)v26;
    v36 = v28 - (v25 & 0xFFFFFFFFFFFFFFF8);
    v37 = (int8x8_t *)&v23->i8[v10 + v28];
    do
    {
      v38 = *v37++;
      v35 = vorr_s8(v38, v35);
      v36 += 8;
    }
    while (v36);
    v39 = *(_QWORD *)&v35 | HIDWORD(*(_QWORD *)&v35) | ((*(_QWORD *)&v35 | HIDWORD(*(_QWORD *)&v35)) >> 16);
    v26 = v39 | BYTE1(v39);
    if (v25 != (v25 & 0xFFFFFFFFFFFFFFF8))
      goto LABEL_36;
LABEL_39:
    if (v26)
      return 0;
LABEL_42:
    if (v24 >= v10)
      v44 = v10;
    else
      v44 = 8 * *(int *)(v20 + 8);
    if (!v44)
      goto LABEL_52;
    if (v44 < 8 || (char *)v61 + v10 - v44 < &v23->i8[v44] && v23 < (int8x16_t *)((char *)v61 + v10))
    {
      v45 = 0;
      goto LABEL_50;
    }
    if (v44 >= 0x20)
    {
      v45 = v44 & 0xFFFFFFE0;
      v50 = v23 + 1;
      v51 = (int8x16_t *)((char *)v61 + v10 - 16);
      v52 = v45;
      do
      {
        v53 = vrev64q_s8(v50[-1]);
        v54 = vextq_s8(v53, v53, 8uLL);
        v55 = vrev64q_s8(*v50);
        v51[-1] = vextq_s8(v55, v55, 8uLL);
        *v51 = v54;
        v50 += 2;
        v51 -= 2;
        v52 -= 32;
      }
      while (v52);
      if (v44 == v45)
        goto LABEL_52;
      if ((v44 & 0x18) == 0)
      {
LABEL_50:
        v46 = v44 - v45;
        v47 = &v22[v10 + ~v45];
        v48 = &v23->i8[v45];
        do
        {
          v49 = *v48++;
          *v47-- = v49;
          --v46;
        }
        while (v46);
        goto LABEL_52;
      }
    }
    else
    {
      v45 = 0;
    }
    v56 = v45;
    v45 = v44 & 0xFFFFFFF8;
    v57 = (int8x8_t *)&v23->i8[v56];
    v58 = (int8x8_t *)&v22[v10 - v56 - 8];
    v59 = v56 - v45;
    do
    {
      v60 = *v57++;
      *v58-- = vrev64_s8(v60);
      v59 += 8;
    }
    while (v59);
    if (v44 != v45)
      goto LABEL_50;
LABEL_52:
    if (v24 < v10)
      bzero(v22, v10 - v44);
    return 1;
  }
  return result;
}

BOOL bssl::`anonymous namespace'::ECKeyShare::DeserializePrivateKey(uint64_t a1, uint64_t a2)
{
  BIGNUM *v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  uint64_t *v10;
  uint64_t v11;
  size_t v12;

  v3 = BN_bin2bn(*(const unsigned __int8 **)a2, *(_QWORD *)(a2 + 8), 0);
  v4 = *(uint64_t **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v3;
  if (v4)
  {
    v5 = *((_DWORD *)v4 + 5);
    if ((v5 & 2) == 0)
    {
      v6 = *v4;
      if (*v4)
      {
        v8 = *(_QWORD *)(v6 - 8);
        v7 = (void *)(v6 - 8);
        v9 = v8 + 8;
        if (v8 != -8)
          bzero(v7, v9);
        free(v7);
        v5 = *((_DWORD *)v4 + 5);
      }
    }
    if ((v5 & 1) != 0)
    {
      v11 = *(v4 - 1);
      v10 = v4 - 1;
      v12 = v11 + 8;
      if (v11 != -8)
        bzero(v10, v12);
      free(v10);
    }
    else
    {
      *v4 = 0;
    }
    v3 = *(BIGNUM **)(a1 + 8);
  }
  return v3 != 0;
}

uint64_t bssl::SSLKeyShare::SerializePrivateKey()
{
  return 0;
}

uint64_t bssl::SSLKeyShare::DeserializePrivateKey()
{
  return 0;
}

void bssl::`anonymous namespace'::X25519KeyShare::~X25519KeyShare(bssl::_anonymous_namespace_::X25519KeyShare *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t bssl::`anonymous namespace'::X25519KeyShare::GroupID(bssl::_anonymous_namespace_::X25519KeyShare *this)
{
  return 29;
}

BOOL bssl::`anonymous namespace'::X25519KeyShare::Generate(uint64_t a1, uint64_t a2)
{
  __int128 *v4;
  int v5;
  _OWORD *v6;
  __int128 v7;
  _OWORD *v9;
  _OWORD v10[2];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v4 = (__int128 *)(a1 + 8);
  RAND_bytes_with_additional_data(a1 + 8, 0x20uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
  *(_BYTE *)(a1 + 8) |= 7u;
  *(_BYTE *)(a1 + 39) = *(_BYTE *)(a1 + 39) & 0x3F | 0x80;
  X25519_public_from_private(v10, v4);
  v9 = 0;
  v5 = CBB_add_space(a2, &v9, 32);
  if (v5)
  {
    v6 = v9;
    v7 = v10[1];
    *v9 = v10[0];
    v6[1] = v7;
  }
  return v5 != 0;
}

uint64_t bssl::`anonymous namespace'::X25519KeyShare::Encap(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;

  *a4 = 80;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, a3, a4, a5, a6);
  return result;
}

uint64_t bssl::`anonymous namespace'::X25519KeyShare::Decap(uint64_t a1, uint64_t *a2, _BYTE *a3, unsigned int *a4, uint64_t a5)
{
  char *v10;
  _QWORD *v11;
  char *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  size_t v16;

  *a3 = 80;
  v10 = (char *)malloc_type_malloc(0x28uLL, 0x30772F57uLL);
  if (!v10)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v11 = v10;
  *(_QWORD *)v10 = 32;
  v12 = v10 + 8;
  if (a5 != 32 || !X25519((int8x16_t *)(v10 + 8), (__int128 *)(a1 + 8), a4))
  {
    *a3 = 50;
    ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_key_share.cc", 170);
    if (*v11 != -8)
      __memset_chk();
    free(v11);
    return 0;
  }
  v13 = *a2;
  if (*a2)
  {
    v15 = *(_QWORD *)(v13 - 8);
    v14 = (void *)(v13 - 8);
    v16 = v15 + 8;
    if (v15 != -8)
      bzero(v14, v16);
    free(v14);
  }
  *a2 = (uint64_t)v12;
  a2[1] = 32;
  return 1;
}

BOOL bssl::`anonymous namespace'::X25519KeyShare::SerializePrivateKey(uint64_t a1, uint64_t a2)
{
  int v3;
  _OWORD *v4;
  __int128 v5;
  _OWORD *v7;

  v7 = 0;
  v3 = CBB_add_space(a2, &v7, 32);
  if (v3)
  {
    v4 = v7;
    v5 = *(_OWORD *)(a1 + 24);
    *v7 = *(_OWORD *)(a1 + 8);
    v4[1] = v5;
  }
  return v3 != 0;
}

BOOL bssl::`anonymous namespace'::X25519KeyShare::DeserializePrivateKey(uint64_t a1, __int128 **a2)
{
  __int128 *v2;
  __int128 *v3;
  __int128 v4;

  v2 = a2[1];
  if (v2 == (__int128 *)32)
  {
    v3 = *a2;
    *a2 += 2;
    a2[1] = 0;
    v4 = *v3;
    *(_OWORD *)(a1 + 24) = v3[1];
    *(_OWORD *)(a1 + 8) = v4;
  }
  return v2 == (__int128 *)32;
}

void bssl::`anonymous namespace'::X25519Kyber768KeyShare::~X25519Kyber768KeyShare(bssl::_anonymous_namespace_::X25519Kyber768KeyShare *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t bssl::`anonymous namespace'::X25519Kyber768KeyShare::GroupID(bssl::_anonymous_namespace_::X25519Kyber768KeyShare *this)
{
  return 25497;
}

BOOL bssl::`anonymous namespace'::X25519Kyber768KeyShare::Generate(uint64_t a1, uint64_t a2)
{
  __int128 *v4;
  _OWORD *v5;
  __int128 v6;
  int v7;
  _BOOL8 v8;
  char __src[1184];
  _OWORD v11[2];
  void *v12[9];

  v12[8] = *(void **)MEMORY[0x24BDAC8D0];
  v4 = (__int128 *)(a1 + 8);
  RAND_bytes_with_additional_data(a1 + 8, 0x20uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
  *(_BYTE *)(a1 + 8) |= 7u;
  *(_BYTE *)(a1 + 39) = *(_BYTE *)(a1 + 39) & 0x3F | 0x80;
  X25519_public_from_private(v11, v4);
  RAND_bytes_with_additional_data((uint64_t)v12, 0x40uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
  KYBER_generate_key_external_entropy(__src, a1 + 40, (uint64_t)v12);
  v12[0] = 0;
  if (!CBB_add_space(a2, v12, 32))
    return 0;
  v5 = v12[0];
  v6 = v11[1];
  *(_OWORD *)v12[0] = v11[0];
  v5[1] = v6;
  v12[0] = 0;
  v7 = CBB_add_space(a2, v12, 1184);
  v8 = v7 != 0;
  if (v7)
    memcpy(v12[0], __src, 0x4A0uLL);
  return v8;
}

uint64_t bssl::`anonymous namespace'::X25519Kyber768KeyShare::Encap(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unsigned int *v5;
  unsigned int *v6;
  _BYTE *v7;
  _BYTE *v8;
  int8x16_t **v9;
  int8x16_t **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  char *v15;
  int8x16_t *v16;
  _OWORD *v17;
  __int128 v18;
  int8x16_t *v19;
  unint64_t *v20;
  uint64_t v21;
  size_t v22;
  _QWORD v24[2];
  void *__dst;
  char __src[1088];
  _BYTE v27[6208];
  _OWORD v28[2];
  uint64_t v29;

  v2 = MEMORY[0x24BDAC7A8](a1, a2);
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v13 = v2;
  v29 = *MEMORY[0x24BDAC8D0];
  v14 = malloc_type_malloc(0x48uLL, 0x30772F57uLL);
  if (!v14)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v15 = (char *)v14;
  *v14 = 64;
  v16 = (int8x16_t *)(v14 + 1);
  RAND_bytes_with_additional_data(v13 + 8, 0x20uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
  *(_BYTE *)(v13 + 8) |= 7u;
  *(_BYTE *)(v13 + 39) = *(_BYTE *)(v13 + 39) & 0x3F | 0x80;
  X25519_public_from_private(v28, (__int128 *)(v13 + 8));
  if (v4 < 0x4C0
    || (v24[0] = v6 + 8, v24[1] = 1184, v4 != 1216)
    || !X25519(v16, (__int128 *)(v13 + 8), v6)
    || !KYBER_parse_public_key((uint64_t)v27, (uint64_t)v24))
  {
    *v8 = 50;
    ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_key_share.cc", 239);
LABEL_14:
    if (*(_QWORD *)v15 != -8)
      __memset_chk();
    free(v15);
    return 0;
  }
  KYBER_encap(__src, v15 + 40, (uint64_t)v27);
  __dst = 0;
  if (!CBB_add_space(v12, &__dst, 32))
    goto LABEL_14;
  v17 = __dst;
  v18 = v28[1];
  *(_OWORD *)__dst = v28[0];
  v17[1] = v18;
  __dst = 0;
  if (!CBB_add_space(v12, &__dst, 1088))
    goto LABEL_14;
  memcpy(__dst, __src, 0x440uLL);
  v19 = *v10;
  if (*v10)
  {
    v21 = v19[-1].i64[1];
    v20 = &v19[-1].u64[1];
    v22 = v21 + 8;
    if (v21 != -8)
      bzero(v20, v22);
    free(v20);
  }
  *v10 = v16;
  v10[1] = (int8x16_t *)64;
  return 1;
}

uint64_t bssl::`anonymous namespace'::X25519Kyber768KeyShare::Decap(uint64_t a1, uint64_t *a2, _BYTE *a3, uint64_t a4, uint64_t a5)
{
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  size_t v16;

  *a3 = 80;
  v10 = (char *)malloc_type_malloc(0x48uLL, 0x30772F57uLL);
  if (!v10)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v11 = v10;
  *(_QWORD *)v10 = 64;
  v12 = v10 + 8;
  if (a5 != 1120 || !X25519((int8x16_t *)(v10 + 8), (__int128 *)(a1 + 8), (unsigned int *)a4))
  {
    *a3 = 50;
    ERR_put_error(16, 0, 108, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_key_share.cc", 269);
    if (*(_QWORD *)v11 != -8)
      __memset_chk();
    free(v11);
    return 0;
  }
  KYBER_decap(v11 + 40, (unsigned __int8 *)(a4 + 32), (uint8x16_t *)(a1 + 40));
  v13 = *a2;
  if (*a2)
  {
    v15 = *(_QWORD *)(v13 - 8);
    v14 = (void *)(v13 - 8);
    v16 = v15 + 8;
    if (v15 != -8)
      bzero(v14, v16);
    free(v14);
  }
  *a2 = (uint64_t)v12;
  a2[1] = 64;
  return 1;
}

uint64_t bssl::CBBFinishArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  size_t v10;

  if (*(_BYTE *)(a1 + 8))
  {
    ERR_put_error(14, 0, 66, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bytestring/cbb.c", 127);
LABEL_3:
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 201);
    return 0;
  }
  if (!CBB_flush((uint64_t *)a1))
    goto LABEL_3;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = 0;
  v7 = *a2;
  if (*a2)
  {
    v9 = *(_QWORD *)(v7 - 8);
    v8 = (void *)(v7 - 8);
    v10 = v9 + 8;
    if (v9 != -8)
      bzero(v8, v10);
    free(v8);
  }
  *a2 = v5;
  a2[1] = v6;
  return 1;
}

void bssl::ssl_set_read_error(bssl *this, ssl_st *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;

  *((_DWORD *)this + 43) = 2;
  v3 = ERR_save_state();
  v4 = *((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = v3;
  if (v4)
  {
    if (*(_QWORD *)(v4 + 8))
    {
      v5 = 0;
      v6 = 0;
      do
      {
        v7 = *(_QWORD *)v4 + v5;
        free(*(void **)(v7 + 8));
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_QWORD *)(v7 + 16) = 0;
        ++v6;
        v5 += 24;
      }
      while (v6 < *(_QWORD *)(v4 + 8));
    }
    free(*(void **)v4);
    free((void *)v4);
  }
}

uint64_t bssl::ssl_open_handshake(_QWORD *a1, _QWORD *a2, _BYTE *a3)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;

  *a2 = 0;
  v4 = a1[6];
  if (*(_DWORD *)(v4 + 172) == 2)
  {
    ERR_restore_state(*(_QWORD **)(v4 + 184));
    *a3 = 0;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD *))(*a1 + 48))(a1);
    if ((_DWORD)result != 4)
      return result;
    v7 = a1[6];
    *(_DWORD *)(v7 + 172) = 2;
    v8 = ERR_save_state();
    v9 = *(_QWORD *)(v7 + 184);
    *(_QWORD *)(v7 + 184) = v8;
    if (v9)
    {
      if (*(_QWORD *)(v9 + 8))
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v12 = *(_QWORD *)v9 + v10;
          free(*(void **)(v12 + 8));
          *(_QWORD *)v12 = 0;
          *(_QWORD *)(v12 + 8) = 0;
          *(_QWORD *)(v12 + 16) = 0;
          ++v11;
          v10 += 24;
        }
        while (v11 < *(_QWORD *)(v9 + 8));
      }
      free(*(void **)v9);
      free((void *)v9);
    }
  }
  return 4;
}

uint64_t bssl::ssl_open_change_cipher_spec(_QWORD *a1, _QWORD *a2, _BYTE *a3)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;

  *a2 = 0;
  v4 = a1[6];
  if (*(_DWORD *)(v4 + 172) == 2)
  {
    ERR_restore_state(*(_QWORD **)(v4 + 184));
    *a3 = 0;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD *))(*a1 + 56))(a1);
    if ((_DWORD)result != 4)
      return result;
    v7 = a1[6];
    *(_DWORD *)(v7 + 172) = 2;
    v8 = ERR_save_state();
    v9 = *(_QWORD *)(v7 + 184);
    *(_QWORD *)(v7 + 184) = v8;
    if (v9)
    {
      if (*(_QWORD *)(v9 + 8))
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v12 = *(_QWORD *)v9 + v10;
          free(*(void **)(v12 + 8));
          *(_QWORD *)v12 = 0;
          *(_QWORD *)(v12 + 8) = 0;
          *(_QWORD *)(v12 + 16) = 0;
          ++v11;
          v10 += 24;
        }
        while (v11 < *(_QWORD *)(v9 + 8));
      }
      free(*(void **)v9);
      free((void *)v9);
    }
  }
  return 4;
}

uint64_t bssl::ssl_log_secret(uint64_t a1, char *__s, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v4;
  size_t v8;
  size_t v9;
  uint64_t v10;
  _QWORD *v11;
  void *v12;
  char v13;
  size_t v14;
  uint64_t v15;
  uint64_t i;
  unsigned int v17;
  char v18;
  char v19;
  _BYTE *v20;
  char v21;
  _BYTE *v22;
  char v23;
  unsigned int v24;
  unsigned int v25;
  char v26;
  char v27;
  _BYTE *v28;
  char v29;
  _BYTE *v30;
  _QWORD *v31;
  char *v32;
  uint64_t v33;
  size_t v34;
  uint64_t v35;
  char *v36;
  void *v38[2];
  __int128 v39;
  void *v40[2];
  __int128 v41;
  void *__dst;

  if (!*(_QWORD *)(*(_QWORD *)(a1 + 104) + 688))
    return 1;
  v4 = a4;
  v38[0] = 0;
  v38[1] = 0;
  v8 = 2 * a4 + strlen(__s);
  v9 = v8 + 67;
  v39 = 0u;
  *(_OWORD *)v40 = 0u;
  v41 = 0u;
  if (v8 + 67 < 0xFFFFFFFFFFFFFFF8)
  {
    v11 = malloc_type_malloc(v8 + 75, 0x30772F57uLL);
    if (v11)
    {
      *v11 = v9;
      v12 = v11 + 1;
      v13 = BYTE8(v41);
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v10 = 0;
      if (v9)
        goto LABEL_38;
      v13 = 0;
      v12 = 0;
    }
    BYTE8(v39) = 0;
    *(_QWORD *)&v39 = 0;
    v40[0] = v12;
    v40[1] = 0;
    *(_QWORD *)&v41 = v9;
    BYTE8(v41) = v13 & 0xFC | 1;
    v14 = strlen(__s);
    __dst = 0;
    if (CBB_add_space((uint64_t)&v39, &__dst, v14))
    {
      if (v14)
        memcpy(__dst, __s, v14);
      __dst = 0;
      if (CBB_add_space((uint64_t)&v39, &__dst, 1))
      {
        *(_BYTE *)__dst = 32;
        v15 = *(_QWORD *)(a1 + 48);
        __dst = 0;
        if (CBB_add_space((uint64_t)&v39, &__dst, 64))
        {
          for (i = 0; i != 32; ++i)
          {
            v17 = *(unsigned __int8 *)(v15 + 48 + i);
            if (v17 >= 0xA0)
              v18 = 0;
            else
              v18 = -1;
            v19 = ((*(_BYTE *)(v15 + 48 + i) >> 4) | 0x30) & v18 | ((*(_BYTE *)(v15 + 48 + i) >> 4) + 87) & ~v18;
            v20 = __dst;
            __dst = (char *)__dst + 1;
            *v20 = v19;
            if ((v17 & 0xF) >= 0xA)
              v21 = 0;
            else
              v21 = -1;
            v22 = __dst;
            __dst = (char *)__dst + 1;
            *v22 = v21 & (v17 & 0xF | 0x30) | ((v17 & 0xF) + 87) & ~v21;
          }
          __dst = 0;
          if (CBB_add_space((uint64_t)&v39, &__dst, 1))
          {
            *(_BYTE *)__dst = 32;
            __dst = 0;
            if (CBB_add_space((uint64_t)&v39, &__dst, 2 * v4))
            {
              for (; v4; --v4)
              {
                v24 = *a3++;
                v23 = v24;
                v25 = v24 >> 4;
                if (v24 >= 0xA0)
                  v26 = 0;
                else
                  v26 = -1;
                v27 = (v25 | 0x30) & v26 | (v25 + 87) & ~v26;
                v28 = __dst;
                __dst = (char *)__dst + 1;
                *v28 = v27;
                if ((v23 & 0xFu) >= 0xA)
                  v29 = 0;
                else
                  v29 = -1;
                v30 = __dst;
                __dst = (char *)__dst + 1;
                *v30 = v29 & (v23 & 0xF | 0x30) | ((v23 & 0xF) + 87) & ~v29;
              }
              __dst = 0;
              if (CBB_add_space((uint64_t)&v39, &__dst, 1))
              {
                *(_BYTE *)__dst = 0;
                v10 = bssl::CBBFinishArray((uint64_t)&v39, (uint64_t *)v38);
                v31 = v38[0];
                if ((_DWORD)v10)
                  (*(void (**)(uint64_t, void *))(*(_QWORD *)(a1 + 104) + 688))(a1, v38[0]);
                if (v31)
                {
                  v33 = *(v31 - 1);
                  v32 = (char *)(v31 - 1);
                  v34 = v33 + 8;
                  if (v33 != -8)
                    bzero(v32, v34);
                  free(v32);
                }
                goto LABEL_38;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  }
  v10 = 0;
LABEL_38:
  if (!BYTE8(v39) && (BYTE8(v41) & 1) != 0 && v40[0])
  {
    v36 = (char *)v40[0] - 8;
    v35 = *((_QWORD *)v40[0] - 1);
    if (v35 != -8)
      bzero((char *)v40[0] - 8, v35 + 8);
    free(v36);
  }
  return v10;
}

uint64_t bssl::ssl_do_msg_callback(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t (*v5)(_QWORD, _QWORD);
  uint64_t v6;

  v5 = *(uint64_t (**)(_QWORD, _QWORD))(result + 64);
  if (v5)
  {
    if ((_DWORD)a3)
    {
      if ((_DWORD)a3 == 256)
      {
        return ((uint64_t (*)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))v5)(a2, 0, a3, a4, a5, result, *(_QWORD *)(result + 72));
      }
      else
      {
        v6 = *(_QWORD *)(*(_QWORD *)(result + 48) + 280);
        if (v6 && (*(_BYTE *)(v6 + 1569) & 4) != 0 && (*(_BYTE *)(result + 164) & 1) == 0)
          return v5(a2, *(unsigned __int16 *)(*(_QWORD *)(v6 + 1512) + 4));
        else
          return v5(a2, *(unsigned __int16 *)(result + 16));
      }
    }
    else
    {
      return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))v5)(a2, 2, a3, a4, a5, result, *(_QWORD *)(result + 72));
    }
  }
  return result;
}

uint64_t bssl::ssl_get_current_time(uint64_t a1, uint64_t a2)
{
  uint64_t (*v3)(_QWORD, timeval *);
  uint64_t result;
  __darwin_suseconds_t tv_usec;
  timeval v6;

  v3 = *(uint64_t (**)(_QWORD, timeval *))(*(_QWORD *)(a1 + 104) + 696);
  if (v3)
    result = v3(0, &v6);
  else
    result = gettimeofday(&v6, 0);
  if (v6.tv_sec >= 0)
    tv_usec = v6.tv_usec;
  else
    tv_usec = 0;
  *(_QWORD *)a2 = v6.tv_sec & ~(v6.tv_sec >> 63);
  *(_DWORD *)(a2 + 8) = tv_usec;
  return result;
}

void ssl_ctx_st::~ssl_ctx_st(ssl_ctx_st *this)
{
  const EVP_MD *sha1;
  int *p_ctx_size;
  uint64_t v4;
  size_t v5;
  unsigned int *default_passwd_callback_userdata;
  pem_password_cb *default_passwd_callback;
  unsigned int i;
  unsigned int v9;
  uint64_t v10;
  void (*v11)(pem_password_cb *);
  char *v12;
  uint64_t v13;
  size_t v14;
  int (__cdecl *app_verify_callback)(X509_STORE_CTX *, void *);
  char *v16;
  uint64_t v17;
  size_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  size_t v27;
  void *v28;
  uint64_t v29;
  size_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  size_t v34;
  lhash_st *sessions;
  int *p_error;
  uint64_t v37;
  size_t v38;
  STACK *cipher_list_by_id;
  int (__cdecl **p_comp)(const char *const *, const char *const *);
  int (__cdecl *comp)(const char *const *, const char *const *);
  size_t v42;
  STACK *cipher_list;
  int (__cdecl **v44)(const char *const *, const char *const *);
  int (__cdecl *v45)(const char *const *, const char *const *);
  size_t v46;
  bssl::CERT *tlsext_servername_arg;
  char *v48;
  uint64_t v49;
  size_t v50;
  X509_VERIFY_PARAM *param;
  char *name;
  unint64_t v53;
  unsigned int *v54;
  time_t check_time;
  void *v56;
  uint64_t v57;
  size_t v58;
  STACK **p_policies;
  STACK *policies;
  size_t p_data;
  bssl::SSLCipherPreferenceList *v62;
  char *v63;
  uint64_t v64;
  size_t v65;

  SSL_CTX_flush_sessions(this, 0);
  CRYPTO_free_ex_data((int)&bssl::g_ex_data_class_ssl_ctx, this, (CRYPTO_EX_DATA *)&this->default_verify_callback);
  pthread_rwlock_destroy((pthread_rwlock_t *)&this->cert_store);
  OPENSSL_lh_free(&this->comp_methods->num);
  (*(void (**)(ssl_ctx_st *))&this->cipher_list_by_id[4].num)(this);
  sha1 = this[1].sha1;
  if (sha1)
  {
    v4 = *(_QWORD *)&sha1[-1].ctx_size;
    p_ctx_size = &sha1[-1].ctx_size;
    v5 = v4 + 8;
    if (v4 != -8)
      bzero(p_ctx_size, v5);
    free(p_ctx_size);
  }
  this[1].sha1 = 0;
  this[1].extra_certs = 0;
  default_passwd_callback_userdata = (unsigned int *)this[1].default_passwd_callback_userdata;
  this[1].default_passwd_callback_userdata = 0;
  if (default_passwd_callback_userdata)
    bssl::RefCounted<ssl_ech_keys_st>::DecRefInternal(default_passwd_callback_userdata);
  default_passwd_callback = this[1].default_passwd_callback;
  this[1].default_passwd_callback = 0;
  if (default_passwd_callback)
  {
    for (i = atomic_load((unsigned int *)default_passwd_callback); i != -1; i = v9)
    {
      if (!i)
        abort();
      v9 = __ldaxr((unsigned int *)default_passwd_callback);
      if (v9 == i)
      {
        if (!__stlxr(i - 1, (unsigned int *)default_passwd_callback))
        {
          if (i == 1)
          {
            v10 = *((_QWORD *)default_passwd_callback + 2);
            if (v10)
            {
              v11 = *(void (**)(pem_password_cb *))(v10 + 160);
              if (v11)
              {
                v11(default_passwd_callback);
                *((_QWORD *)default_passwd_callback + 1) = 0;
                *((_DWORD *)default_passwd_callback + 1) = 0;
              }
            }
            v13 = *((_QWORD *)default_passwd_callback - 1);
            v12 = (char *)default_passwd_callback - 8;
            v14 = v13 + 8;
            if (v13 != -8)
              bzero(v12, v14);
            free(v12);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  app_verify_callback = this[1].app_verify_callback;
  if (app_verify_callback)
  {
    v17 = *((_QWORD *)app_verify_callback - 1);
    v16 = (char *)app_verify_callback - 8;
    v18 = v17 + 8;
    if (v17 != -8)
      bzero(v16, v18);
    free(v16);
  }
  this[1].app_verify_callback = 0;
  this[1].app_verify_arg = 0;
  v19 = *(_QWORD *)&this[1].stats.sess_cache_full;
  if (v19)
  {
    v21 = *(_QWORD *)(v19 - 8);
    v20 = (void *)(v19 - 8);
    v22 = v21 + 8;
    if (v21 != -8)
      bzero(v20, v22);
    free(v20);
  }
  *(_QWORD *)&this[1].stats.sess_cache_full = 0;
  *(_QWORD *)&this[1].stats.sess_cb_hit = 0;
  v23 = *(_QWORD *)&this[1].stats.sess_accept_renegotiate;
  *(_QWORD *)&this[1].stats.sess_accept_renegotiate = 0;
  if (v23)
  {
    v24 = *(_QWORD *)(v23 + 8);
    if (v24)
    {
      v26 = *(_QWORD *)(v24 - 8);
      v25 = (void *)(v24 - 8);
      v27 = v26 + 8;
      if (v26 != -8)
        bzero(v25, v27);
      free(v25);
    }
    v29 = *(_QWORD *)(v23 - 8);
    v28 = (void *)(v23 - 8);
    v30 = v29 + 8;
    if (v29 != -8)
      bzero(v28, v30);
    free(v28);
  }
  v31 = *(_QWORD *)&this[1].stats.sess_connect;
  if (v31)
  {
    v33 = *(_QWORD *)(v31 - 8);
    v32 = (void *)(v31 - 8);
    v34 = v33 + 8;
    if (v33 != -8)
      bzero(v32, v34);
    free(v32);
  }
  *(_QWORD *)&this[1].stats.sess_connect = 0;
  *(_QWORD *)&this[1].stats.sess_connect_good = 0;
  sessions = this[1].sessions;
  this[1].sessions = 0;
  if (sessions)
  {
    v37 = *(_QWORD *)&sessions[-1].error;
    p_error = &sessions[-1].error;
    v38 = v37 + 8;
    if (v37 != -8)
      bzero(p_error, v38);
    free(p_error);
  }
  cipher_list_by_id = this[1].cipher_list_by_id;
  this[1].cipher_list_by_id = 0;
  if (cipher_list_by_id)
  {
    comp = cipher_list_by_id[-1].comp;
    p_comp = &cipher_list_by_id[-1].comp;
    v42 = (size_t)comp + 8;
    if (comp != (int (__cdecl *)(const char *const *, const char *const *))-8)
      bzero(p_comp, v42);
    free(p_comp);
  }
  cipher_list = this[1].cipher_list;
  this[1].cipher_list = 0;
  if (cipher_list)
  {
    v45 = cipher_list[-1].comp;
    v44 = &cipher_list[-1].comp;
    v46 = (size_t)v45 + 8;
    if (v45 != (int (__cdecl *)(const char *const *, const char *const *))-8)
      bzero(v44, v46);
    free(v44);
  }
  tlsext_servername_arg = (bssl::CERT *)this->tlsext_servername_arg;
  this->tlsext_servername_arg = 0;
  if (tlsext_servername_arg)
  {
    bssl::CERT::~CERT(tlsext_servername_arg);
    v49 = *((_QWORD *)tlsext_servername_arg - 1);
    v48 = (char *)tlsext_servername_arg - 8;
    v50 = v49 + 8;
    if (v49 != -8)
      bzero(v48, v50);
    free(v48);
  }
  param = this->param;
  this->param = 0;
  if (param)
  {
    name = param->name;
    if (param->name)
    {
      v53 = 0;
      do
      {
        v54 = *(unsigned int **)(param->check_time + 8 * v53);
        if (v54)
        {
          CRYPTO_BUFFER_free(v54);
          name = param->name;
        }
        ++v53;
      }
      while (v53 < (unint64_t)name);
    }
    check_time = param->check_time;
    if (check_time)
    {
      v57 = *(_QWORD *)(check_time - 8);
      v56 = (void *)(check_time - 8);
      v58 = v57 + 8;
      if (v57 != -8)
        bzero(v56, v58);
      free(v56);
    }
    policies = param[-1].policies;
    p_policies = &param[-1].policies;
    p_data = (size_t)&policies->data;
    if (policies != (STACK *)-8)
      bzero(p_policies, p_data);
    free(p_policies);
  }
  v62 = (bssl::SSLCipherPreferenceList *)this->sha1;
  this->sha1 = 0;
  if (v62)
  {
    bssl::SSLCipherPreferenceList::~SSLCipherPreferenceList(v62);
    v64 = *((_QWORD *)v62 - 1);
    v63 = (char *)v62 - 8;
    v65 = v64 + 8;
    if (v64 != -8)
      bzero(v63, v65);
    free(v63);
  }
}

SSL_CTX *__cdecl SSL_CTX_new(SSL_METHOD *meth)
{
  char *v2;
  BUF_MEM ***v3;
  unsigned int *v4;
  bssl::CERT **v5;
  _QWORD *v6;
  _QWORD *v7;
  void (__cdecl *ssl_clear)(SSL *);
  bssl::CERT *v9;
  char *v10;
  char *v11;
  bssl::CERT *v12;
  char *v13;
  uint64_t v14;
  size_t v15;
  char *v16;
  BUF_MEM **v17;
  BUF_MEM *v18;
  unint64_t v19;
  unsigned int *v20;
  BUF_MEM *v21;
  int *p_max;
  uint64_t v23;
  size_t v24;
  BUF_MEM **v25;
  uint64_t v26;
  size_t v27;
  unsigned int i;
  unsigned int v29;

  if (!meth)
  {
    ERR_put_error(16, 0, 186, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 567);
    return 0;
  }
  v2 = (char *)malloc_type_malloc(0x308uLL, 0x30772F57uLL);
  if (!v2)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v3 = (BUF_MEM ***)v2;
  *(_QWORD *)v2 = 768;
  *((_DWORD *)v2 + 2) = 1;
  v4 = (unsigned int *)(v2 + 8);
  *((_OWORD *)v2 + 1) = *(_OWORD *)&meth->ssl_new;
  *((_DWORD *)v2 + 58) = 0;
  v2[236] = 2;
  *((_OWORD *)v2 + 15) = 0u;
  *((_OWORD *)v2 + 16) = 0u;
  *((_QWORD *)v2 + 34) = 20480;
  *((_DWORD *)v2 + 74) = 0;
  *(_OWORD *)(v2 + 280) = 0u;
  *((_DWORD *)v2 + 75) = 2;
  *((_QWORD *)v2 + 38) = 0x2A30000001C20;
  *((_QWORD *)v2 + 47) = 0;
  *(_OWORD *)(v2 + 344) = 0u;
  *(_OWORD *)(v2 + 360) = 0u;
  *(_OWORD *)(v2 + 312) = 0u;
  *(_OWORD *)(v2 + 328) = 0u;
  *((_QWORD *)v2 + 51) = 0;
  *((_DWORD *)v2 + 104) = 0;
  *(_OWORD *)(v2 + 392) = 0u;
  *(_QWORD *)(v2 + 420) = 0x1900000000008;
  *((_QWORD *)v2 + 56) = 0;
  *((_DWORD *)v2 + 114) = 0;
  *((_OWORD *)v2 + 27) = 0u;
  *((_OWORD *)v2 + 29) = 0u;
  *((_OWORD *)v2 + 30) = 0u;
  v2[496] = 0;
  *((_WORD *)v2 + 249) = 0x4000;
  *((_OWORD *)v2 + 47) = 0u;
  *(_OWORD *)(v2 + 504) = 0u;
  *(_OWORD *)(v2 + 520) = 0u;
  *(_OWORD *)(v2 + 536) = 0u;
  *(_OWORD *)(v2 + 552) = 0u;
  *(_OWORD *)(v2 + 568) = 0u;
  *(_OWORD *)(v2 + 584) = 0u;
  *(_OWORD *)(v2 + 600) = 0u;
  *(_OWORD *)(v2 + 616) = 0u;
  *(_OWORD *)(v2 + 632) = 0u;
  *(_OWORD *)(v2 + 648) = 0u;
  *(_OWORD *)(v2 + 664) = 0u;
  *(_OWORD *)(v2 + 680) = 0u;
  *(_OWORD *)(v2 + 696) = 0u;
  *(_OWORD *)(v2 + 712) = 0u;
  *(_OWORD *)(v2 + 728) = 0u;
  *((_DWORD *)v2 + 186) = 0;
  *((_WORD *)v2 + 384) &= 0xE000u;
  if (pthread_rwlock_init((pthread_rwlock_t *)(v2 + 32), 0))
LABEL_51:
    abort();
  v5 = (bssl::CERT **)(v3 + 54);
  v3[48] = 0;
  v6 = malloc_type_malloc(0x88uLL, 0x30772F57uLL);
  if (v6)
  {
    v7 = v6;
    *v6 = 128;
    ssl_clear = meth->ssl_clear;
    v6[1] = 0;
    v6[2] = 0;
    v9 = (bssl::CERT *)(v6 + 1);
    v6[3] = 0;
    v10 = (char *)malloc_type_malloc(0x68uLL, 0x30772F57uLL);
    if (v10)
    {
      *(_QWORD *)v10 = 96;
      *((_DWORD *)v10 + 2) = 1;
      v11 = v10 + 8;
      *((_QWORD *)v10 + 11) = 0;
      *((_QWORD *)v10 + 12) = 0;
      *((_QWORD *)v10 + 10) = 0;
      *(_OWORD *)(v10 + 12) = 0u;
      *(_OWORD *)(v10 + 28) = 0u;
      *(_OWORD *)(v10 + 44) = 0u;
      *(_OWORD *)(v10 + 58) = 0u;
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v11 = 0;
    }
    v7[4] = v11;
    v7[5] = ssl_clear;
    *((_OWORD *)v7 + 3) = 0u;
    *((_OWORD *)v7 + 4) = 0u;
    *((_OWORD *)v7 + 5) = 0u;
    *((_OWORD *)v7 + 6) = 0u;
    *((_OWORD *)v7 + 7) = 0u;
    *((_BYTE *)v7 + 128) = 0;
    v12 = *v5;
    *v5 = v9;
    if (!v12)
      goto LABEL_16;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v12 = *v5;
    *v5 = 0;
    if (!v12)
      goto LABEL_16;
  }
  bssl::CERT::~CERT(v12);
  v14 = *((_QWORD *)v12 - 1);
  v13 = (char *)v12 - 8;
  v15 = v14 + 8;
  if (v14 != -8)
    bzero(v13, v15);
  free(v13);
LABEL_16:
  v3[33] = (BUF_MEM **)OPENSSL_lh_new((uint64_t)ssl_session_hash, (uint64_t)ssl_session_cmp);
  v16 = OPENSSL_sk_new_null();
  v17 = v3[50];
  v3[50] = (BUF_MEM **)v16;
  if (v17)
  {
    v18 = *v17;
    if (*v17)
    {
      v19 = 0;
      do
      {
        v20 = (unsigned int *)*((_QWORD *)&v17[1]->length + v19);
        if (v20)
        {
          CRYPTO_BUFFER_free(v20);
          v18 = *v17;
        }
        ++v19;
      }
      while (v19 < (unint64_t)v18);
    }
    v21 = v17[1];
    if (v21)
    {
      v23 = *(_QWORD *)&v21[-1].max;
      p_max = &v21[-1].max;
      v24 = v23 + 8;
      if (v23 != -8)
        bzero(p_max, v24);
      free(p_max);
    }
    v26 = (uint64_t)*(v17 - 1);
    v25 = v17 - 1;
    v27 = v26 + 8;
    if (v26 != -8)
      bzero(v25, v27);
    free(v25);
  }
  if (!*v5
    || !*((_QWORD *)*v5 + 3)
    || !v3[33]
    || !v3[50]
    || !((unsigned int (*)(unsigned int *))v3[3][15])(v4))
  {
LABEL_38:
    for (i = atomic_load(v4); i != -1; i = v29)
    {
      if (!i)
        goto LABEL_51;
      v29 = __ldaxr(v4);
      if (v29 == i)
      {
        if (!__stlxr(i - 1, v4))
        {
          if (i == 1)
          {
            ssl_ctx_st::~ssl_ctx_st((ssl_ctx_st *)v4);
            if (*v3 != (BUF_MEM **)-8)
              __memset_chk();
            free(v3);
          }
          return 0;
        }
      }
      else
      {
        __clrex();
      }
    }
    return 0;
  }
  if (!bssl::ssl_create_cipher_list(v3 + 31, (~*((unsigned __int16 *)v3 + 384) & 0x1800) == 0, (uint64_t)"ALL", 1)|| !SSL_CTX_set_max_proto_version((uint64_t)v4, LOWORD(meth->version))|| !SSL_CTX_set_min_proto_version((uint64_t)v4, LOWORD(meth->version)))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 592);
    goto LABEL_38;
  }
  return (SSL_CTX *)v4;
}

uint64_t ssl_session_hash(const ssl_session_st *a1)
{
  unsigned __int8 *p_dst;
  size_t v2;
  int __dst;

  p_dst = &a1->master_key[40];
  v2 = a1->master_key[39];
  if (v2 <= 3)
  {
    __dst = 0;
    if ((_DWORD)v2)
      memcpy(&__dst, p_dst, v2);
    p_dst = (unsigned __int8 *)&__dst;
  }
  return *(unsigned int *)p_dst;
}

uint64_t ssl_session_cmp(const ssl_session_st *a1, const ssl_session_st *a2)
{
  size_t v2;

  v2 = a1->master_key[39];
  if ((_DWORD)v2 != a2->master_key[39])
    return 1;
  if (a1->master_key[39])
    return memcmp(&a1->master_key[40], &a2->master_key[40], v2);
  return 0;
}

void ssl_st::~ssl_st(ssl_st *this)
{
  bssl::SSL_CONFIG *method;
  char *v3;
  uint64_t v4;
  size_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  unsigned int *v10;
  unsigned int i;
  unsigned int v12;
  unsigned __int8 *packet;
  unsigned int j;
  unsigned int v15;
  unsigned __int8 *v16;
  uint64_t v17;
  size_t v18;
  unsigned int *v19;
  uint64_t v20;
  size_t v21;
  ssl_session_st *init_msg;
  unsigned int k;
  unsigned int v24;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v27;
  BIO *bbio;
  BIO *wbio;
  bssl::SSL_CONFIG *v30;
  char *v31;
  uint64_t v32;
  size_t v33;

  CRYPTO_free_ex_data((int)&bssl::g_ex_data_class_ssl, this, (CRYPTO_EX_DATA *)&this->s2);
  method = (bssl::SSL_CONFIG *)this->method;
  this->method = 0;
  if (method)
  {
    bssl::SSL_CONFIG::~SSL_CONFIG(method);
    v4 = *((_QWORD *)method - 1);
    v3 = (char *)method - 8;
    v5 = v4 + 8;
    if (v4 != -8)
      bzero(v3, v5);
    free(v3);
  }
  if (*(_QWORD *)&this->version)
    (*(void (**)(ssl_st *))(*(_QWORD *)&this->version + 16))(this);
  v6 = *(_QWORD *)&this->read_ahead;
  *(_QWORD *)&this->read_ahead = 0;
  if (v6)
  {
    v8 = *(_QWORD *)(v6 - 8);
    v7 = (void *)(v6 - 8);
    v9 = v8 + 8;
    if (v8 != -8)
      bzero(v7, v9);
    free(v7);
  }
  v10 = *(unsigned int **)&this->packet_length;
  *(_QWORD *)&this->packet_length = 0;
  if (v10)
  {
    for (i = atomic_load(v10); i != -1; i = v12)
    {
      if (!i)
LABEL_56:
        abort();
      v12 = __ldaxr(v10);
      if (v12 == i)
      {
        if (!__stlxr(i - 1, v10))
        {
          if (i != 1)
            break;
          ssl_ctx_st::~ssl_ctx_st((ssl_ctx_st *)v10);
          v20 = *((_QWORD *)v10 - 1);
          v19 = v10 - 2;
          v21 = v20 + 8;
          if (v20 != -8)
            bzero(v19, v21);
          free(v19);
          packet = this->packet;
          this->packet = 0;
          if (packet)
            goto LABEL_21;
          goto LABEL_35;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  packet = this->packet;
  this->packet = 0;
  if (packet)
  {
LABEL_21:
    for (j = atomic_load((unsigned int *)packet); j != -1; j = v15)
    {
      if (!j)
        goto LABEL_56;
      v15 = __ldaxr((unsigned int *)packet);
      if (v15 == j)
      {
        if (!__stlxr(j - 1, (unsigned int *)packet))
        {
          if (j == 1)
          {
            ssl_ctx_st::~ssl_ctx_st((ssl_ctx_st *)packet);
            v17 = *((_QWORD *)packet - 1);
            v16 = packet - 8;
            v18 = v17 + 8;
            if (v17 != -8)
              bzero(v16, v18);
            free(v16);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
LABEL_35:
  init_msg = (ssl_session_st *)this->init_msg;
  this->init_msg = 0;
  if (init_msg)
  {
    for (k = atomic_load((unsigned int *)init_msg); k != -1; k = v24)
    {
      if (!k)
        goto LABEL_56;
      v24 = __ldaxr((unsigned int *)init_msg);
      if (v24 == k)
      {
        if (!__stlxr(k - 1, (unsigned int *)init_msg))
        {
          if (k == 1)
          {
            ssl_session_st::~ssl_session_st(init_msg);
            tlsext_tick_lifetime_hint = init_msg[-1].tlsext_tick_lifetime_hint;
            p_tlsext_tick_lifetime_hint = &init_msg[-1].tlsext_tick_lifetime_hint;
            v27 = tlsext_tick_lifetime_hint + 8;
            if (tlsext_tick_lifetime_hint != -8)
              bzero(p_tlsext_tick_lifetime_hint, v27);
            free(p_tlsext_tick_lifetime_hint);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  bbio = this->bbio;
  this->bbio = 0;
  if (bbio)
    BIO_free(bbio);
  wbio = this->wbio;
  this->wbio = 0;
  if (wbio)
    BIO_free(wbio);
  v30 = (bssl::SSL_CONFIG *)this->method;
  this->method = 0;
  if (v30)
  {
    bssl::SSL_CONFIG::~SSL_CONFIG(v30);
    v32 = *((_QWORD *)v30 - 1);
    v31 = (char *)v30 - 8;
    v33 = v32 + 8;
    if (v32 != -8)
      bzero(v31, v33);
    free(v31);
  }
}

SSL *__cdecl SSL_new(SSL_CTX *ctx)
{
  char *v2;
  _QWORD *v3;
  SSL *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  char v8;
  char v9;
  char *v10;
  char *v11;
  bssl::SSL_CONFIG *v12;
  char *v13;
  uint64_t v14;
  size_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  bssl::CERT *v19;
  bssl::CERT *v20;
  char *v21;
  uint64_t v22;
  size_t v23;
  bssl::CERT *v24;
  char *v25;
  uint64_t v26;
  size_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  int (__cdecl *app_verify_callback)(X509_STORE_CTX *, void *);
  unint64_t app_verify_arg;
  void *v34;
  uint64_t v35;
  size_t v36;
  _QWORD *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  const void *v42;
  size_t v43;
  void *v44;
  uint64_t v45;
  size_t v46;
  _QWORD *v47;
  void *v48;
  lhash_st *sessions;
  uint64_t v50;
  size_t v51;
  size_t v52;
  _QWORD *v53;
  _QWORD *v54;
  _QWORD *v55;
  unsigned int *default_passwd_callback;
  unsigned int v57;
  unsigned int v58;
  char v59;
  uint64_t v60;
  EVP_PKEY *v61;
  bssl::CERT *v63;

  if (!ctx)
  {
    ERR_put_error(16, 0, 185, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 637);
    return 0;
  }
  v2 = (char *)malloc_type_malloc(0xB0uLL, 0x30772F57uLL);
  if (!v2)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v3 = v2;
  *(_QWORD *)v2 = 168;
  *((_QWORD *)v2 + 1) = ctx->cipher_list;
  *((_QWORD *)v2 + 2) = 0;
  v4 = (SSL *)(v2 + 8);
  *((_WORD *)v2 + 12) = 0;
  *((_WORD *)v2 + 13) = WORD1(ctx->tlsext_status_cb);
  *((_QWORD *)v2 + 8) = 0;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *(_OWORD *)(v2 + 72) = *(_OWORD *)ctx->tlsext_tick_key_name;
  *((_DWORD *)v2 + 22) = 1000;
  *((_QWORD *)v2 + 12) = 0;
  *((_QWORD *)v2 + 13) = 0;
  v5 = atomic_load((unsigned int *)ctx);
  if (v5 != -1)
  {
    do
    {
      v16 = __ldaxr((unsigned int *)ctx);
      if (v16 == v5)
      {
        if (!__stlxr(v5 + 1, (unsigned int *)ctx))
          break;
      }
      else
      {
        __clrex();
      }
      v5 = v16;
    }
    while (v16 != -1);
  }
  *((_QWORD *)v2 + 14) = ctx;
  v6 = atomic_load((unsigned int *)ctx);
  if (v6 != -1)
  {
    do
    {
      v17 = __ldaxr((unsigned int *)ctx);
      if (v17 == v6)
      {
        if (!__stlxr(v6 + 1, (unsigned int *)ctx))
          break;
      }
      else
      {
        __clrex();
      }
      v6 = v17;
    }
    while (v17 != -1);
  }
  *((_QWORD *)v2 + 15) = ctx;
  v7 = *((_QWORD *)v2 + 14);
  *((_QWORD *)v2 + 17) = *(_QWORD *)(v7 + 408);
  *((_DWORD *)v2 + 36) = *(_DWORD *)(v7 + 416);
  *((_QWORD *)v2 + 19) = 0;
  *((_QWORD *)v2 + 20) = 0;
  *((_DWORD *)v2 + 42) = 0;
  v8 = v2[172];
  v2[172] = v8 & 0xFE;
  v9 = *(_BYTE *)(v7 + 760) & 2 | v8 & 0xFC;
  v2[172] = v9;
  v2[172] = *(_BYTE *)(v7 + 761) & 4 | v9 & 0xFB;
  *((_QWORD *)v2 + 16) = 0;
  v10 = (char *)malloc_type_malloc(0xF8uLL, 0x30772F57uLL);
  if (v10)
  {
    *(_QWORD *)v10 = 240;
    *((_QWORD *)v10 + 1) = v4;
    v11 = v10 + 8;
    *((_DWORD *)v10 + 4) = 0;
    *(_OWORD *)(v10 + 24) = 0u;
    *(_OWORD *)(v10 + 40) = 0u;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    *(_OWORD *)(v10 + 88) = 0u;
    *(_OWORD *)(v10 + 104) = 0u;
    *(_OWORD *)(v10 + 120) = 0u;
    *(_OWORD *)(v10 + 136) = 0u;
    *(_OWORD *)(v10 + 152) = 0u;
    *(_OWORD *)(v10 + 168) = 0u;
    *(_OWORD *)(v10 + 184) = 0u;
    *(_OWORD *)(v10 + 200) = 0u;
    *(_OWORD *)(v10 + 216) = 0u;
    *(_OWORD *)(v10 + 229) = 0u;
    *(_WORD *)(v10 + 245) = *(_WORD *)(v10 + 245) & 0x1800 | 0xC010;
    v12 = (bssl::SSL_CONFIG *)v3[2];
    v3[2] = v10 + 8;
    if (v12)
      goto LABEL_7;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v11 = 0;
    v12 = (bssl::SSL_CONFIG *)v3[2];
    v3[2] = 0;
    if (v12)
    {
LABEL_7:
      bssl::SSL_CONFIG::~SSL_CONFIG(v12);
      v14 = *((_QWORD *)v12 - 1);
      v13 = (char *)v12 - 8;
      v15 = v14 + 8;
      if (v14 != -8)
        bzero(v13, v15);
      free(v13);
      v11 = (char *)v3[2];
      if (!v11)
        goto LABEL_77;
      goto LABEL_25;
    }
  }
  if (!v11)
    goto LABEL_77;
LABEL_25:
  *((_DWORD *)v11 + 2) = ctx->rsa_md5;
  bssl::ssl_cert_dup((bssl *)ctx->tlsext_servername_arg, (unint64_t **)&v63);
  v18 = v3[2];
  v19 = v63;
  v63 = 0;
  v20 = *(bssl::CERT **)(v18 + 32);
  *(_QWORD *)(v18 + 32) = v19;
  if (v20)
  {
    bssl::CERT::~CERT(v20);
    v22 = *((_QWORD *)v20 - 1);
    v21 = (char *)v20 - 8;
    v23 = v22 + 8;
    if (v22 != -8)
      bzero(v21, v23);
    free(v21);
    v24 = v63;
    v63 = 0;
    if (v24)
    {
      bssl::CERT::~CERT(v24);
      v26 = *((_QWORD *)v24 - 1);
      v25 = (char *)v24 - 8;
      v27 = v26 + 8;
      if (v26 != -8)
        bzero(v25, v27);
      free(v25);
    }
  }
  v28 = v3[2];
  if (!*(_QWORD *)(v28 + 32))
    goto LABEL_77;
  *(_BYTE *)(v28 + 236) = *(_DWORD *)ctx->tlsext_tick_hmac_key;
  *(_QWORD *)(v28 + 40) = *(_QWORD *)&ctx->tlsext_tick_hmac_key[8];
  *(_QWORD *)(v3[2] + 48) = *(_QWORD *)ctx->sid_ctx;
  *(_WORD *)(v3[2] + 237) = *(_WORD *)(v3[2] + 237) & 0xFFDF | (32 * ((uint64_t)ctx[1].comp_methods & 1));
  *(_WORD *)(v3[2] + 237) = *(_WORD *)(v3[2] + 237) & 0xFBFF | (16 * LOWORD(ctx[1].comp_methods)) & 0x400;
  *(_WORD *)(v3[2] + 237) = *(_WORD *)(v3[2] + 237) & 0xF7FF | (uint64_t)ctx[1].comp_methods & 0x800;
  *(_WORD *)(v3[2] + 237) = *(_WORD *)(v3[2] + 237) & 0xEFFF | (uint64_t)ctx[1].comp_methods & 0x1000;
  v29 = v3[2];
  *(_DWORD *)(v29 + 232) = ctx[1].md5;
  v31 = (_QWORD *)(v29 + 96);
  v30 = *(_QWORD *)(v29 + 96);
  app_verify_callback = ctx[1].app_verify_callback;
  app_verify_arg = (unint64_t)ctx[1].app_verify_arg;
  if (v30)
  {
    v35 = *(_QWORD *)(v30 - 8);
    v34 = (void *)(v30 - 8);
    v36 = v35 + 8;
    if (v35 != -8)
      bzero(v34, v36);
    free(v34);
  }
  *v31 = 0;
  *(_QWORD *)(v29 + 104) = 0;
  if (app_verify_arg)
  {
    if ((app_verify_arg & 0x8000000000000000) != 0)
    {
      ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/internal.h", 297);
      goto LABEL_77;
    }
    if (app_verify_arg > 0x7FFFFFFFFFFFFFFBLL
      || (v37 = malloc_type_malloc(2 * app_verify_arg + 8, 0x30772F57uLL)) == 0)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      *v31 = 0;
      goto LABEL_77;
    }
    *v37 = 2 * app_verify_arg;
    v38 = v37 + 1;
    *(_QWORD *)(v29 + 96) = v38;
    *(_QWORD *)(v29 + 104) = app_verify_arg;
    memmove(v38, app_verify_callback, 2 * app_verify_arg);
  }
  v39 = v3[2];
  v41 = (_QWORD *)(v39 + 120);
  v40 = *(_QWORD *)(v39 + 120);
  v42 = *(const void **)&ctx[1].stats.sess_connect;
  v43 = *(_QWORD *)&ctx[1].stats.sess_connect_good;
  if (v40)
  {
    v45 = *(_QWORD *)(v40 - 8);
    v44 = (void *)(v40 - 8);
    v46 = v45 + 8;
    if (v45 != -8)
      bzero(v44, v46);
    free(v44);
  }
  *v41 = 0;
  *(_QWORD *)(v39 + 128) = 0;
  if (v43)
  {
    if (v43 > 0xFFFFFFFFFFFFFFF7 || (v47 = malloc_type_malloc(v43 + 8, 0x30772F57uLL)) == 0)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      *v41 = 0;
      goto LABEL_77;
    }
    *v47 = v43;
    v48 = v47 + 1;
    *(_QWORD *)(v39 + 120) = v48;
    *(_QWORD *)(v39 + 128) = v43;
    memmove(v48, v42, v43);
  }
  if (!bssl::Array<unsigned short>::CopyFrom((uint64_t *)(v3[2] + 192), ctx[1].sha1, (unint64_t)ctx[1].extra_certs))
  {
LABEL_77:
    ssl_st::~ssl_st(v4);
    if (*v3 != -8)
      __memset_chk();
    free(v3);
    return 0;
  }
  sessions = ctx[1].sessions;
  v50 = v3[2];
  if (sessions)
  {
    v51 = strlen((const char *)ctx[1].sessions);
    v52 = v51 + 1;
    if (v51 != -1)
    {
      if (v52 <= 0xFFFFFFFFFFFFFFF7)
      {
        v53 = malloc_type_malloc(v51 + 9, 0x30772F57uLL);
        if (v53)
        {
          *v53 = v52;
          v54 = v53 + 1;
          memcpy(v53 + 1, sessions, v52);
          goto LABEL_61;
        }
      }
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    }
    v54 = 0;
LABEL_61:
    v55 = *(_QWORD **)(v50 + 56);
    *(_QWORD *)(v50 + 56) = v54;
    if (v55)
      OPENSSL_free(v55);
    v50 = v3[2];
    if (!*(_QWORD *)(v50 + 56))
      goto LABEL_77;
  }
  *(_QWORD *)(v50 + 64) = ctx[1].session_cache_size;
  *(_QWORD *)(v3[2] + 72) = ctx[1].session_cache_head;
  *(_WORD *)(v3[2] + 237) = *(_WORD *)(v3[2] + 237) & 0xFFF7 | (LOWORD(ctx[1].comp_methods) >> 1) & 8;
  default_passwd_callback = (unsigned int *)ctx[1].default_passwd_callback;
  if (default_passwd_callback)
  {
    v57 = atomic_load(default_passwd_callback);
    if (v57 != -1)
    {
      while (1)
      {
        v58 = __ldaxr(default_passwd_callback);
        if (v58 == v57)
        {
          if (!__stlxr(v57 + 1, default_passwd_callback))
          {
            v59 = 1;
            goto LABEL_71;
          }
        }
        else
        {
          __clrex();
        }
        v59 = 0;
LABEL_71:
        if ((v59 & 1) == 0)
        {
          v57 = v58;
          if (v58 != -1)
            continue;
        }
        break;
      }
    }
  }
  v60 = v3[2];
  v61 = *(EVP_PKEY **)(v60 + 112);
  *(_QWORD *)(v60 + 112) = default_passwd_callback;
  if (v61)
    EVP_PKEY_free(v61);
  *(_WORD *)(v3[2] + 237) = *(_WORD *)(v3[2] + 237) & 0xFFFD | (LOWORD(ctx[1].comp_methods) >> 2) & 2;
  *(_WORD *)(v3[2] + 237) = *(_WORD *)(v3[2] + 237) & 0xFFFB | (uint64_t)ctx[1].comp_methods & 4;
  *(_WORD *)(v3[2] + 237) = *(_WORD *)(v3[2] + 237) & 0xFFBF | (LOWORD(ctx[1].comp_methods) >> 3) & 0x40;
  v3[20] = ctx->md5;
  if (!(*(unsigned int (**)(SSL *))(v3[1] + 8))(v4)
    || ((*(uint64_t (**)(_QWORD))(*(_QWORD *)(v3[14] + 16) + 88))(*(_QWORD *)(v3[7] + 280)) & 1) == 0)
  {
    goto LABEL_77;
  }
  return v4;
}

void bssl::SSL_CONFIG::~SSL_CONFIG(bssl::SSL_CONFIG *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;
  void *v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  size_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  size_t v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  size_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  size_t v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  size_t v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  size_t v46;
  uint64_t v47;
  unsigned int i;
  unsigned int v49;
  uint64_t v50;
  void (*v51)(uint64_t);
  void *v52;
  uint64_t v53;
  size_t v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  size_t v58;
  unint64_t *v59;
  unint64_t v60;
  unint64_t v61;
  unsigned int *v62;
  unint64_t v63;
  void *v64;
  uint64_t v65;
  size_t v66;
  unint64_t *v67;
  uint64_t v68;
  size_t v69;
  uint64_t v70;
  void *v71;
  uint64_t v72;
  size_t v73;
  bssl::CERT *v74;
  char *v75;
  uint64_t v76;
  size_t v77;
  bssl::SSLCipherPreferenceList *v78;
  char *v79;
  uint64_t v80;
  size_t v81;

  v2 = *(_QWORD *)(*(_QWORD *)this + 104);
  if (v2)
    (*(void (**)(bssl::SSL_CONFIG *))(*(_QWORD *)(v2 + 16) + 96))(this);
  v3 = *((_QWORD *)this + 27);
  if (v3)
  {
    v5 = *(_QWORD *)(v3 - 8);
    v4 = (void *)(v3 - 8);
    v6 = v5 + 8;
    if (v5 != -8)
      bzero(v4, v6);
    free(v4);
  }
  *((_QWORD *)this + 27) = 0;
  *((_QWORD *)this + 28) = 0;
  v7 = *((_QWORD *)this + 26);
  *((_QWORD *)this + 26) = 0;
  if (v7)
  {
    v8 = *(_QWORD *)(v7 + 8);
    if (v8)
    {
      v10 = *(_QWORD *)(v8 - 8);
      v9 = (void *)(v8 - 8);
      v11 = v10 + 8;
      if (v10 != -8)
        bzero(v9, v11);
      free(v9);
    }
    v13 = *(_QWORD *)(v7 - 8);
    v12 = (void *)(v7 - 8);
    v14 = v13 + 8;
    if (v13 != -8)
      bzero(v12, v14);
    free(v12);
  }
  v15 = *((_QWORD *)this + 24);
  if (v15)
  {
    v17 = *(_QWORD *)(v15 - 8);
    v16 = (void *)(v15 - 8);
    v18 = v17 + 8;
    if (v17 != -8)
      bzero(v16, v18);
    free(v16);
  }
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 25) = 0;
  v19 = *((_QWORD *)this + 22);
  if (v19)
  {
    v21 = *(_QWORD *)(v19 - 8);
    v20 = (void *)(v19 - 8);
    v22 = v21 + 8;
    if (v21 != -8)
      bzero(v20, v22);
    free(v20);
  }
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  v23 = *((_QWORD *)this + 20);
  if (v23)
  {
    v25 = *(_QWORD *)(v23 - 8);
    v24 = (void *)(v23 - 8);
    v26 = v25 + 8;
    if (v25 != -8)
      bzero(v24, v26);
    free(v24);
  }
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  v27 = (uint64_t *)((char *)this + 144);
  if (*((_QWORD *)this + 19))
  {
    v28 = 0;
    v29 = 0;
    do
    {
      v30 = (uint64_t *)(*v27 + v28);
      v31 = v30[2];
      if (v31)
      {
        v33 = *(_QWORD *)(v31 - 8);
        v32 = (void *)(v31 - 8);
        v34 = v33 + 8;
        if (v33 != -8)
          bzero(v32, v34);
        free(v32);
      }
      v30[2] = 0;
      v30[3] = 0;
      v35 = *v30;
      if (*v30)
      {
        v37 = *(_QWORD *)(v35 - 8);
        v36 = (void *)(v35 - 8);
        v38 = v37 + 8;
        if (v37 != -8)
          bzero(v36, v38);
        free(v36);
      }
      *v30 = 0;
      v30[1] = 0;
      ++v29;
      v28 += 32;
    }
    while (v29 < *((_QWORD *)this + 19));
  }
  v39 = *v27;
  if (*v27)
  {
    v41 = *(_QWORD *)(v39 - 8);
    v40 = (void *)(v39 - 8);
    v42 = v41 + 8;
    if (v41 != -8)
      bzero(v40, v42);
    free(v40);
  }
  *v27 = 0;
  *((_QWORD *)this + 19) = 0;
  v43 = *((_QWORD *)this + 15);
  if (v43)
  {
    v45 = *(_QWORD *)(v43 - 8);
    v44 = (void *)(v43 - 8);
    v46 = v45 + 8;
    if (v45 != -8)
      bzero(v44, v46);
    free(v44);
  }
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  v47 = *((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = 0;
  if (v47)
  {
    for (i = atomic_load((unsigned int *)v47); i != -1; i = v49)
    {
      if (!i)
        abort();
      v49 = __ldaxr((unsigned int *)v47);
      if (v49 == i)
      {
        if (!__stlxr(i - 1, (unsigned int *)v47))
        {
          if (i == 1)
          {
            v50 = *(_QWORD *)(v47 + 16);
            if (v50)
            {
              v51 = *(void (**)(uint64_t))(v50 + 160);
              if (v51)
              {
                v51(v47);
                *(_QWORD *)(v47 + 8) = 0;
                *(_DWORD *)(v47 + 4) = 0;
              }
            }
            v53 = *(_QWORD *)(v47 - 8);
            v52 = (void *)(v47 - 8);
            v54 = v53 + 8;
            if (v53 != -8)
              bzero(v52, v54);
            free(v52);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  v55 = *((_QWORD *)this + 12);
  if (v55)
  {
    v57 = *(_QWORD *)(v55 - 8);
    v56 = (void *)(v55 - 8);
    v58 = v57 + 8;
    if (v57 != -8)
      bzero(v56, v58);
    free(v56);
  }
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  v59 = (unint64_t *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v59)
  {
    v60 = *v59;
    if (*v59)
    {
      v61 = 0;
      do
      {
        v62 = *(unsigned int **)(v59[1] + 8 * v61);
        if (v62)
        {
          CRYPTO_BUFFER_free(v62);
          v60 = *v59;
        }
        ++v61;
      }
      while (v61 < v60);
    }
    v63 = v59[1];
    if (v63)
    {
      v65 = *(_QWORD *)(v63 - 8);
      v64 = (void *)(v63 - 8);
      v66 = v65 + 8;
      if (v65 != -8)
        bzero(v64, v66);
      free(v64);
    }
    v68 = *(v59 - 1);
    v67 = v59 - 1;
    v69 = v68 + 8;
    if (v68 != -8)
      bzero(v67, v69);
    free(v67);
  }
  v70 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v70)
  {
    v72 = *(_QWORD *)(v70 - 8);
    v71 = (void *)(v70 - 8);
    v73 = v72 + 8;
    if (v72 != -8)
      bzero(v71, v73);
    free(v71);
  }
  v74 = (bssl::CERT *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v74)
  {
    bssl::CERT::~CERT(v74);
    v76 = *((_QWORD *)v74 - 1);
    v75 = (char *)v74 - 8;
    v77 = v76 + 8;
    if (v76 != -8)
      bzero(v75, v77);
    free(v75);
  }
  v78 = (bssl::SSLCipherPreferenceList *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v78)
  {
    bssl::SSLCipherPreferenceList::~SSLCipherPreferenceList(v78);
    v80 = *((_QWORD *)v78 - 1);
    v79 = (char *)v78 - 8;
    v81 = v80 + 8;
    if (v80 != -8)
      bzero(v79, v81);
    free(v79);
  }
}

int SSL_do_handshake(SSL *s)
{
  BOOL *v2;
  bssl *v3;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(SSL *, uint64_t, uint64_t);
  int (__cdecl *handshake_func)(SSL *);
  uint64_t **v8;
  uint64_t **v9;
  uint64_t v10;
  size_t v11;
  char v13;

  *((_DWORD *)s->handshake_func + 49) = 0;
  ERR_clear_error();
  *__error() = 0;
  if (*(_QWORD *)&s->rwstate)
  {
    v3 = (bssl *)*((_QWORD *)s->handshake_func + 35);
    if (v3 && (*((_BYTE *)v3 + 1568) & 8) == 0)
    {
      v13 = 0;
      v4 = bssl::ssl_run_handshake(v3, (bssl::SSL_HANDSHAKE *)&v13, v2);
      if ((BYTE4(s->msg_callback_arg) & 1) != 0)
        v5 = 8194;
      else
        v5 = 4098;
      v6 = *(void (**)(SSL *, uint64_t, uint64_t))&s->init_num;
      if (v6 || (v6 = (void (*)(SSL *, uint64_t, uint64_t))*((_QWORD *)s->packet + 48)) != 0)
        v6(s, v5, v4);
      if ((int)v4 < 1)
        return v4;
      if (!v13)
      {
        handshake_func = s->handshake_func;
        v8 = (uint64_t **)*((_QWORD *)handshake_func + 35);
        *((_QWORD *)handshake_func + 35) = 0;
        if (v8)
        {
          bssl::SSL_HANDSHAKE::~SSL_HANDSHAKE(v8);
          v10 = (uint64_t)*(v8 - 1);
          v9 = v8 - 1;
          v11 = v10 + 8;
          if (v10 != -8)
            bzero(v9, v11);
          free(v9);
        }
        bssl::ssl_maybe_shed_handshake_config((bssl *)s, (ssl_st *)v5);
      }
    }
    LODWORD(v4) = 1;
    return v4;
  }
  ERR_put_error(16, 0, 134, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 859);
  return -1;
}

void bssl::ssl_maybe_shed_handshake_config(bssl *this, ssl_st *a2)
{
  uint64_t v2;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  size_t v7;
  int v8;

  v2 = *((_QWORD *)this + 6);
  if (!*(_QWORD *)(v2 + 280))
  {
    v4 = *((_QWORD *)this + 1);
    if (v4)
    {
      if ((*(_WORD *)(v4 + 237) & 0x80) != 0)
      {
        if ((*((_BYTE *)this + 164) & 1) != 0
          || **(_BYTE **)this
          || (*(_WORD *)(v2 + 220) & 2) != 0 && bssl::ssl_protocol_version(this, a2) > 0x303
          || (v8 = *((_DWORD *)this + 40), v8 != 4) && v8 != 2 && (v8 != 1 || *(_DWORD *)(v2 + 192)))
        {
          *((_QWORD *)this + 1) = 0;
          bssl::SSL_CONFIG::~SSL_CONFIG((bssl::SSL_CONFIG *)v4);
          v6 = *(_QWORD *)(v4 - 8);
          v5 = (void *)(v4 - 8);
          v7 = v6 + 8;
          if (v6 != -8)
            bzero(v5, v7);
          free(v5);
        }
      }
    }
  }
}

int SSL_read(SSL *ssl, void *buf, int num)
{
  size_t v3;
  int result;
  int (__cdecl *handshake_func)(SSL *);
  int (__cdecl *v8)(SSL *);
  size_t v9;
  BOOL v10;
  size_t v11;
  int (__cdecl *v12)(SSL *);
  void **v13;

  if (ssl->msg_callback)
  {
    ERR_put_error(16, 0, 66, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 1055);
    LODWORD(v3) = -1;
    return v3;
  }
  LODWORD(v3) = num;
  result = ssl_read_impl(ssl);
  if (result >= 1)
  {
    if ((int)v3 < 1)
      return v3;
    handshake_func = ssl->handshake_func;
    v3 = *((_QWORD *)handshake_func + 17) >= (unint64_t)v3
       ? v3
       : *((_QWORD *)handshake_func + 17);
    if (!v3)
      return v3;
    memcpy(buf, *((const void **)handshake_func + 16), v3);
    v8 = ssl->handshake_func;
    v9 = *((_QWORD *)v8 + 17);
    v10 = v9 >= v3;
    v11 = v9 - v3;
    if (!v10)
      abort();
    *((_QWORD *)v8 + 16) += v3;
    *((_QWORD *)v8 + 17) = v11;
    v12 = ssl->handshake_func;
    if (*((_QWORD *)v12 + 17) || *((_WORD *)v12 + 45))
      return v3;
    v13 = (void **)((char *)v12 + 80);
    if (*((_BYTE *)v12 + 99))
      free(*v13);
    *((_BYTE *)v12 + 99) = 0;
    *v13 = 0;
    *(_QWORD *)((char *)v12 + 86) = 0;
    return v3;
  }
  return result;
}

uint64_t ssl_read_impl(ssl_st *a1)
{
  uint64_t v1;
  int (__cdecl *handshake_func)(SSL *);
  int v4;
  int v5;
  int (__cdecl *v6)(SSL *);
  uint64_t v7;
  uint64_t v8;
  const ssl_cipher_st *v9;
  int (__cdecl *v10)(SSL *);
  uint64_t v11;
  int v12;
  int (__cdecl *v13)(SSL *);
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  ssl_st *v17;
  int v18;
  int (__cdecl *v19)(SSL *);
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int msg_callback_arg;
  int (__cdecl *v28)(SSL *);
  __int16 v29;
  int (__cdecl *v30)(SSL *);
  uint64_t **v31;
  _QWORD *v32;
  int (__cdecl *v33)(SSL *);
  int v35;
  int v36;
  unsigned __int8 v37;
  unsigned __int8 v38;
  _BYTE v39[16];
  uint64_t v40;
  ssl_st *v41;

  *((_DWORD *)a1->handshake_func + 49) = 0;
  ERR_clear_error();
  *__error() = 0;
  if (!*(_QWORD *)&a1->rwstate)
  {
    v4 = 226;
    v5 = 972;
LABEL_57:
    ERR_put_error(16, 0, v4, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", v5);
    return 0xFFFFFFFFLL;
  }
  handshake_func = a1->handshake_func;
  if (*((_DWORD *)handshake_func + 43) == 2)
  {
    ERR_restore_state(*((_QWORD **)handshake_func + 23));
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    v6 = a1->handshake_func;
    if (*((_QWORD *)v6 + 17))
      return 1;
    if ((*((_WORD *)v6 + 110) & 0x1000) != 0)
    {
      *((_DWORD *)v6 + 49) = 19;
      return 0xFFFFFFFFLL;
    }
    while (1)
    {
      v7 = *((_QWORD *)a1->handshake_func + 35);
      if (!v7 || (*(_WORD *)(v7 + 1568) & 0x1008) != 0)
        break;
      v8 = SSL_do_handshake(a1);
      if ((v8 & 0x80000000) != 0)
        return v8;
      if (!(_DWORD)v8)
      {
        v4 = 215;
        v5 = 996;
        goto LABEL_57;
      }
    }
    if ((*(unsigned int (**)(ssl_st *, _BYTE *))(*(_QWORD *)&a1->version + 24))(a1, v39))
    {
      v10 = a1->handshake_func;
      v11 = *((_QWORD *)v10 + 35);
      if (v11)
      {
        v12 = *(_DWORD *)(v11 + 1568);
        if ((v12 & 8) == 0)
        {
          *(_DWORD *)(v11 + 1568) = v12 & 0xFFFFEFFF;
          continue;
        }
      }
      if (LOWORD(a1->rbio) == 772)
      {
        if ((bssl::tls13_post_handshake((bssl *)a1, (uint64_t)v39, v9) & 1) == 0)
        {
LABEL_70:
          bssl::ssl_set_read_error((bssl *)a1->handshake_func, v17);
          return 0xFFFFFFFFLL;
        }
LABEL_53:
        (*(void (**)(ssl_st *))(*(_QWORD *)&a1->version + 32))(a1);
        continue;
      }
      if ((BYTE4(a1->msg_callback_arg) & 1) != 0)
      {
        v35 = 182;
        v36 = 913;
      }
      else
      {
        if (v39[1] || v40)
        {
          bssl::ssl_send_alert((bssl *)a1, (ssl_st *)2, 50);
          ERR_put_error(16, 0, 110, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 920);
          goto LABEL_70;
        }
        if (LODWORD(a1->msg_callback_arg) == 3)
          goto LABEL_53;
        *((_WORD *)v10 + 110) |= 0x1000u;
        msg_callback_arg = (int)a1->msg_callback_arg;
        if (msg_callback_arg == 4)
          goto LABEL_53;
        v28 = a1->handshake_func;
        v29 = *((_WORD *)v28 + 110);
        if ((v29 & 0x1000) != 0)
        {
          if ((BYTE4(a1->msg_callback_arg) & 1) != 0
            || **(_BYTE **)&a1->version
            || (v29 & 2) != 0 && LOWORD(a1->rbio) == 772
            || !a1->method
            || msg_callback_arg != 2 && (msg_callback_arg != 1 || *((_DWORD *)v28 + 48)))
          {
            v35 = 182;
            v36 = 1780;
          }
          else if (*((_WORD *)v28 + 57) || *((_DWORD *)v28 + 44))
          {
            v35 = 182;
            v36 = 1793;
          }
          else
          {
            if (!*((_QWORD *)v28 + 35))
            {
              bssl::ssl_handshake_new((bssl *)a1, (uint64_t ***)&v41);
              v30 = a1->handshake_func;
              v31 = (uint64_t **)*((_QWORD *)v30 + 35);
              *((_QWORD *)v30 + 35) = v41;
              if (v31)
              {
                bssl::SSL_HANDSHAKE::~SSL_HANDSHAKE(v31);
                OPENSSL_free(v32);
              }
              v33 = a1->handshake_func;
              if (*((_QWORD *)v33 + 35))
              {
                *((_WORD *)v33 + 110) &= ~0x1000u;
                ++*((_DWORD *)a1->handshake_func + 48);
                goto LABEL_53;
              }
LABEL_69:
              bssl::ssl_send_alert((bssl *)a1, (ssl_st *)2, 100);
              goto LABEL_70;
            }
            v35 = 68;
            v36 = 1799;
          }
        }
        else
        {
          v35 = 66;
          v36 = 1775;
        }
      }
      ERR_put_error(16, 0, v35, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", v36);
      goto LABEL_69;
    }
    v38 = 50;
    v13 = a1->handshake_func;
    v14 = *((_QWORD *)v13 + 10);
    v15 = *((unsigned __int16 *)v13 + 44);
    v16 = *((unsigned __int16 *)v13 + 45);
    v41 = 0;
    if (*((_DWORD *)v13 + 43) == 2)
    {
      ERR_restore_state(*((_QWORD **)v13 + 23));
      v38 = 0;
    }
    else
    {
      v18 = (*(uint64_t (**)(ssl_st *, uint64_t, ssl_st **, unsigned __int8 *, uint64_t, uint64_t))(*(_QWORD *)&a1->version + 64))(a1, (uint64_t)v13 + 128, &v41, &v38, v14 + v15, v16);
      if (v18 != 4)
        goto LABEL_28;
      v19 = a1->handshake_func;
      *((_DWORD *)v19 + 43) = 2;
      v20 = ERR_save_state();
      v21 = *((_QWORD *)v19 + 23);
      *((_QWORD *)v19 + 23) = v20;
      if (v21)
      {
        if (*(_QWORD *)(v21 + 8))
        {
          v22 = 0;
          v23 = 0;
          do
          {
            v24 = *(_QWORD *)v21 + v22;
            free(*(void **)(v24 + 8));
            *(_QWORD *)v24 = 0;
            *(_QWORD *)(v24 + 8) = 0;
            *(_QWORD *)(v24 + 16) = 0;
            ++v23;
            v22 += 24;
          }
          while (v23 < *(_QWORD *)(v21 + 8));
        }
        free(*(void **)v21);
        free((void *)v21);
      }
    }
    v18 = 4;
LABEL_28:
    v37 = 0;
    v25 = bssl::ssl_handle_open_record((bssl *)a1, &v37, v18, v41, v38);
    if ((int)v25 < 1)
      return v25;
    v26 = v37;
    if (!v37)
    {
      *((_BYTE *)a1->handshake_func + 212) = 0;
      if (v26 == 1)
        return v1;
    }
  }
}

int SSL_write(SSL *ssl, const void *buf, int num)
{
  int v6;
  int v7;
  int result;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;

  *((_DWORD *)ssl->handshake_func + 49) = 0;
  ERR_clear_error();
  *__error() = 0;
  if (ssl->msg_callback)
  {
    v6 = 66;
    v7 = 1076;
LABEL_3:
    ERR_put_error(16, 0, v6, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", v7);
    return -1;
  }
  if (!*(_QWORD *)&ssl->rwstate)
  {
    v6 = 226;
    v7 = 1081;
    goto LABEL_3;
  }
  v12 = 0;
  v11 = 0;
  if ((num & 0x80000000) == 0)
  {
    while (1)
    {
      v9 = *((_QWORD *)ssl->handshake_func + 35);
      if (v9 && (*(_WORD *)(v9 + 1568) & 0x2008) == 0)
      {
        result = SSL_do_handshake(ssl);
        if (result < 0)
          return result;
        if (!result)
          break;
      }
      result = (*(uint64_t (**)(SSL *, char *, uint64_t *, const void *, _QWORD))(*(_QWORD *)&ssl->version
                                                                                         + 72))(ssl, &v11, &v12, buf, num);
      if (!v11)
      {
        if (result >= 1)
          return v12;
        return result;
      }
    }
    goto LABEL_23;
  }
  v10 = *((_QWORD *)ssl->handshake_func + 35);
  if (!v10 || (*(_WORD *)(v10 + 1568) & 0x2008) != 0)
  {
LABEL_20:
    v6 = 111;
    v7 = 1102;
    goto LABEL_3;
  }
  result = SSL_do_handshake(ssl);
  if ((result & 0x80000000) == 0)
  {
    if (!result)
    {
LABEL_23:
      v6 = 215;
      v7 = 1096;
      goto LABEL_3;
    }
    goto LABEL_20;
  }
  return result;
}

int SSL_shutdown(SSL *s)
{
  int (__cdecl *handshake_func)(SSL *);
  uint64_t v3;
  int v5;
  int v6;

  *((_DWORD *)s->handshake_func + 49) = 0;
  ERR_clear_error();
  *__error() = 0;
  if (!*(_QWORD *)&s->rwstate)
  {
    ERR_put_error(16, 0, 226, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 1148);
    return -1;
  }
  handshake_func = s->handshake_func;
  v3 = *((_QWORD *)handshake_func + 35);
  if (v3 && (*(_BYTE *)(v3 + 1568) & 8) == 0)
    return 1;
  if ((BYTE4(s->msg_callback_arg) & 2) != 0)
  {
    *(_QWORD *)((char *)handshake_func + 172) = 0x100000001;
    return 1;
  }
  v5 = *((_DWORD *)handshake_func + 44);
  if (!v5)
  {
    *((_DWORD *)handshake_func + 44) = 1;
    *((_WORD *)handshake_func + 110) |= 0x800u;
    *((_BYTE *)s->handshake_func + 461) = 1;
    *((_BYTE *)s->handshake_func + 462) = 0;
    if (*((_WORD *)s->handshake_func + 57))
      return -1;
    if ((*(int (**)(SSL *))(*(_QWORD *)&s->version + 80))(s) < 1)
      return -1;
    return *((_DWORD *)s->handshake_func + 43) == 1;
  }
  if (v5 != 1)
  {
    ERR_put_error(16, 0, 194, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/s3_pkt.cc", 412);
    return -1;
  }
  if ((*((_WORD *)handshake_func + 110) & 0x800) != 0)
  {
    if ((*(int (**)(SSL *))(*(_QWORD *)&s->version + 80))(s) < 1)
      return -1;
    return *((_DWORD *)s->handshake_func + 43) == 1;
  }
  v6 = *((_DWORD *)handshake_func + 43);
  if (v6 == 1)
    return *((_DWORD *)s->handshake_func + 43) == 1;
  if (**(_BYTE **)&s->version)
  {
    if (v6 == 2)
    {
      ERR_restore_state(*((_QWORD **)handshake_func + 23));
      return -1;
    }
    *((_DWORD *)handshake_func + 43) = 1;
    return *((_DWORD *)s->handshake_func + 43) == 1;
  }
  if ((int)ssl_read_impl(s) >= 1)
  {
    ERR_put_error(16, 0, 291, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 1195);
    return -1;
  }
  if (*((_DWORD *)s->handshake_func + 43) == 1)
    return *((_DWORD *)s->handshake_func + 43) == 1;
  return -1;
}

uint64_t ssl_str_to_group_ids(bssl **a1, char *__s)
{
  char *v2;
  uint64_t v4;
  unint64_t v5;
  char *v6;
  char *v7;
  _QWORD *v8;
  bssl *v9;
  bssl *i;
  char *v11;
  char *v12;
  const char *v13;
  bssl *v14;
  char *v15;
  uint64_t v16;
  size_t v17;
  char *v19;
  uint64_t v20;
  size_t v21;

  v2 = __s;
  v4 = 0;
  v5 = 0;
  v6 = __s;
  do
  {
    v7 = strchr(v6, 58);
    ++v5;
    v6 = v7 + 1;
    v4 += 2;
  }
  while (v7);
  if (!v5)
  {
    v9 = 0;
    goto LABEL_9;
  }
  if ((v5 & 0x8000000000000000) != 0)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/internal.h", 297);
    return 0;
  }
  if (v5 <= 0x7FFFFFFFFFFFFFFBLL)
  {
    v8 = malloc_type_malloc(v4 + 8, 0x30772F57uLL);
    if (v8)
    {
      *v8 = v4;
      v9 = (bssl *)(v8 + 1);
LABEL_9:
      for (i = v9; ; i = (bssl *)((char *)i + 2))
      {
        v11 = strchr(v2, 58);
        v12 = v11;
        if (v11)
        {
          if (!bssl::ssl_name_to_group_id(i, v2, (const char *)(v11 - v2)))
            goto LABEL_22;
        }
        else
        {
          v13 = (const char *)strlen(v2);
          if (!bssl::ssl_name_to_group_id(i, v2, v13))
          {
LABEL_22:
            ERR_put_error(16, 0, 239, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 2044);
            if (!v9)
              return 0;
            v20 = *((_QWORD *)v9 - 1);
            v19 = (char *)v9 - 8;
            v21 = v20 + 8;
            if (v20 != -8)
              bzero(v19, v21);
            free(v19);
            return 0;
          }
        }
        v2 = v12 + 1;
        if (!v12)
        {
          v14 = *a1;
          if (*a1)
          {
            v16 = *((_QWORD *)v14 - 1);
            v15 = (char *)v14 - 8;
            v17 = v16 + 8;
            if (v16 != -8)
              bzero(v15, v17);
            free(v15);
          }
          *a1 = v9;
          a1[1] = (bssl *)v5;
          return 1;
        }
      }
    }
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  return 0;
}

BOOL SSL_set_tlsext_host_name(uint64_t a1, char *__s)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  size_t v7;
  size_t v8;
  size_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  size_t v16;

  v4 = *(_QWORD *)(a1 + 144);
  *(_QWORD *)(a1 + 144) = 0;
  if (v4)
  {
    v6 = *(_QWORD *)(v4 - 8);
    v5 = (void *)(v4 - 8);
    v7 = v6 + 8;
    if (v6 != -8)
      bzero(v5, v7);
    free(v5);
  }
  if (!__s)
    return 1;
  v8 = strlen(__s);
  if (v8 - 256 <= 0xFFFFFFFFFFFFFF00)
  {
    ERR_put_error(16, 0, 213, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 2265);
    return 0;
  }
  v10 = v8;
  v11 = malloc_type_malloc(v8 + 9, 0x30772F57uLL);
  v12 = v11;
  if (v11)
  {
    *v11 = v10 + 1;
    v12 = v11 + 1;
    memcpy(v11 + 1, __s, v10 + 1);
    v13 = *(_QWORD *)(a1 + 144);
    *(_QWORD *)(a1 + 144) = v12;
    if (!v13)
      return v12 != 0;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v13 = *(_QWORD *)(a1 + 144);
    *(_QWORD *)(a1 + 144) = 0;
    if (!v13)
      return v12 != 0;
  }
  v15 = *(_QWORD *)(v13 - 8);
  v14 = (void *)(v13 - 8);
  v16 = v15 + 8;
  if (v15 != -8)
    bzero(v14, v16);
  free(v14);
  return *(_QWORD *)(a1 + 144) != 0;
}

uint64_t SSL_set_alpn_protos(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v3;
  _BYTE *v6;
  size_t v7;
  size_t v8;
  size_t v9;
  uint64_t v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  size_t v15;
  _QWORD *v16;
  void *v17;

  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return 1;
  if (!a3)
  {
LABEL_10:
    v12 = (_QWORD *)(v3 + 120);
    v11 = *(_QWORD *)(v3 + 120);
    if (v11)
    {
      v14 = *(_QWORD *)(v11 - 8);
      v13 = (void *)(v11 - 8);
      v15 = v14 + 8;
      if (v14 != -8)
        bzero(v13, v15);
      free(v13);
    }
    *v12 = 0;
    *(_QWORD *)(v3 + 128) = 0;
    if (a3)
    {
      if (a3 > 0xFFFFFFFFFFFFFFF7 || (v16 = malloc_type_malloc(a3 + 8, 0x30772F57uLL)) == 0)
      {
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        *v12 = 0;
        return 1;
      }
      *v16 = a3;
      v17 = v16 + 1;
      *(_QWORD *)(v3 + 120) = v17;
      *(_QWORD *)(v3 + 128) = a3;
      memmove(v17, a2, a3);
    }
    return 0;
  }
  v6 = a2;
  v7 = a3;
  while (1)
  {
    v8 = v7 - 1;
    v9 = *v6;
    if (!*v6 || v8 < v9)
      break;
    v6 += v9 + 1;
    v7 = v8 - v9;
    if (!v7)
      goto LABEL_10;
  }
  ERR_put_error(16, 0, 315, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_lib.cc", 2361);
  return 1;
}

void bssl::ssl_pkey_supports_algorithm(bssl *this, const ssl_st *a2, evp_pkey_st *a3)
{
  int v3;
  _DWORD *v6;
  BIO *rbio;
  uint64_t (__cdecl *callback)(bio_st *, int, const char *, int, uint64_t, uint64_t);
  unint64_t v9;
  unsigned int v10;
  int v11;

  v3 = (int)a3;
  if ((int)a3 > 1538)
  {
    switch((int)a3)
    {
      case 2052:
        v6 = &unk_24C0D2338;
        if (a2->type == 6)
          goto LABEL_27;
        break;
      case 2053:
        v6 = &unk_24C0D2358;
        if (a2->type == 6)
          goto LABEL_27;
        break;
      case 2054:
        v6 = &unk_24C0D2378;
        if (a2->type == 6)
          goto LABEL_27;
        break;
      case 2055:
        v6 = &unk_24C0D2418;
        if (a2->type == 949)
          goto LABEL_27;
        break;
      default:
        if ((_DWORD)a3 == 1539)
        {
          v6 = &unk_24C0D23F8;
          if (a2->type == 408)
            goto LABEL_27;
        }
        else if ((_DWORD)a3 == 65281)
        {
          v6 = &bssl::kSignatureAlgorithms;
          if (a2->type == 6)
            goto LABEL_27;
        }
        break;
    }
  }
  else
  {
    if ((int)a3 <= 1026)
    {
      switch((_DWORD)a3)
      {
        case 0x201:
          v6 = &unk_24C0D22B8;
          if (a2->type != 6)
            return;
          break;
        case 0x203:
          v6 = &unk_24C0D2398;
          if (a2->type != 408)
            return;
          break;
        case 0x401:
          v6 = &unk_24C0D22D8;
          if (a2->type != 6)
            return;
          break;
        default:
          return;
      }
    }
    else if ((int)a3 > 1282)
    {
      if ((_DWORD)a3 == 1283)
      {
        v6 = &unk_24C0D23D8;
        if (a2->type != 408)
          return;
      }
      else
      {
        if ((_DWORD)a3 != 1537)
          return;
        v6 = &unk_24C0D2318;
        if (a2->type != 6)
          return;
      }
    }
    else if ((_DWORD)a3 == 1027)
    {
      v6 = &unk_24C0D23B8;
      if (a2->type != 408)
        return;
    }
    else
    {
      if ((_DWORD)a3 != 1281)
        return;
      v6 = &unk_24C0D22F8;
      if (a2->type != 6)
        return;
    }
LABEL_27:
    if (!*((_BYTE *)v6 + 24)
      || ((rbio = a2->rbio) == 0 || (callback = rbio[1].callback) == 0
        ? (v9 = 0)
        : (v9 = ((int (*)(const ssl_st *))callback)(a2)),
          2 * (unint64_t)(*((const EVP_MD *(**)(void))v6 + 2))()->pkey_type + 2 <= v9))
    {
      v10 = *((unsigned __int16 *)this + 8);
      if (v10 - 769 < 4 && v10 > 0x302 && v3 != 65281 && v10 == 772)
      {
        v11 = v6[1];
        if (v11 == 408)
        {
          if (v6[2])
          {
            if (a2->type != 408)
            {
              ERR_put_error(6, 0, 106, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_ec_asn1.c", 320);
              __break(1u);
            }
          }
        }
      }
    }
  }
}

uint64_t bssl::ssl_private_key_sign(uint64_t a1, void *a2, unint64_t *a3, unint64_t a4, evp_pkey_st *a5, const void *a6, size_t a7)
{
  bssl *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned int (*v19)(_BYTE *);
  void *v20;
  uint64_t v21;
  size_t v22;
  unint64_t v23;
  size_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  const ssl_st *v29;
  uint64_t v30;
  void *v31;
  unsigned int v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  size_t v38;
  uint64_t v39;
  _QWORD *v40;
  size_t v41;
  void *v42;
  uint64_t v43;
  size_t v44;
  _QWORD *v45;
  void *v46;
  uint64_t v47;
  _QWORD *v48;
  size_t v49;
  void *v50;
  uint64_t v51;
  size_t v52;
  _QWORD *v53;
  void *v54;
  uint64_t v55;
  char *v56;
  void *v58;
  _BYTE v59[48];
  char *v60;
  size_t v61;

  v14 = *(bssl **)a1;
  v15 = *(_QWORD **)(a1 + 1488);
  v16 = *(_QWORD *)(a1 + 1560);
  v60 = 0;
  v61 = 0;
  if (!v16)
    goto LABEL_22;
  memset(v59, 0, sizeof(v59));
  v17 = malloc_type_malloc(0x48uLL, 0x30772F57uLL);
  if (!v17)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    bssl::ssl_send_alert(v14, (ssl_st *)2, 80);
    if (v59[8])
      goto LABEL_79;
    goto LABEL_30;
  }
  *v17 = 64;
  v59[8] = 0;
  *(_QWORD *)v59 = 0;
  *(_QWORD *)&v59[16] = v17 + 1;
  *(_OWORD *)&v59[24] = xmmword_208F05A00;
  v59[40] = 1;
  v18 = *(_QWORD *)(v15[1] + 16);
  if (!v18 || (v19 = *(unsigned int (**)(_BYTE *))(v18 + 32)) == 0)
  {
    ERR_put_error(6, 0, 128, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/evp_asn1.c", 147);
    goto LABEL_27;
  }
  if (!v19(v59) || (bssl::CBBFinishArray((uint64_t)v59, (uint64_t *)&v60) & 1) == 0)
  {
LABEL_27:
    bssl::ssl_send_alert(v14, (ssl_st *)2, 80);
    if (v59[8])
      goto LABEL_79;
LABEL_30:
    if ((v59[40] & 1) != 0 && *(_QWORD *)&v59[16])
    {
      v28 = (void *)(*(_QWORD *)&v59[16] - 8);
      v27 = *(_QWORD *)(*(_QWORD *)&v59[16] - 8);
      if (v27 != -8)
        bzero(v28, v27 + 8);
      free(v28);
    }
    goto LABEL_79;
  }
  if (!v59[8] && (v59[40] & 1) != 0 && *(_QWORD *)&v59[16])
  {
    v20 = (void *)(*(_QWORD *)&v59[16] - 8);
    v21 = *(_QWORD *)(*(_QWORD *)&v59[16] - 8);
    if (v21 != -8)
    {
      v58 = (void *)(*(_QWORD *)&v59[16] - 8);
      bzero(v20, v21 + 8);
      v20 = v58;
    }
    free(v20);
  }
  if ((*(_BYTE *)(a1 + 1570) & 8) == 0 && *(unsigned __int16 *)(v16 + 72) == (_DWORD)a5)
  {
    v22 = *(_QWORD *)(v16 + 88);
    if (a7 == v22
      && !memcmp(a6, *(const void **)(v16 + 80), v22)
      && v61 == *(_QWORD *)(v16 + 104)
      && !memcmp(v60, *(const void **)(v16 + 96), v61))
    {
      v23 = *(_QWORD *)(v16 + 120);
      if (v23 - 1 < a4)
      {
        *a3 = v23;
        v24 = *(_QWORD *)(v16 + 120);
        if (v24)
          memcpy(a2, *(const void **)(v16 + 112), v24);
        goto LABEL_50;
      }
    }
  }
LABEL_22:
  v25 = v15[3];
  if (!v25)
  {
    v29 = (const ssl_st *)v15[2];
    *a3 = a4;
    memset(v59, 0, 32);
    if (!bssl::setup_ctx(v14, (ssl_st *)v59, v29, a5, 0)
      || !EVP_DigestSign((EVP_MD_CTX *)v59, (uint64_t)a2, (uint64_t)a3, (uint64_t)a6, a7))
    {
      if (*(_QWORD *)&v59[8])
      {
        v34 = (void *)(*(_QWORD *)&v59[8] - 8);
        v33 = *(_QWORD *)(*(_QWORD *)&v59[8] - 8);
        if (v33 != -8)
          bzero(v34, v33 + 8);
        free(v34);
      }
      if (*(_QWORD *)&v59[24])
        (**(void (***)(_QWORD))&v59[24])(*(_QWORD *)&v59[16]);
      goto LABEL_79;
    }
    if (*(_QWORD *)&v59[8])
    {
      v31 = (void *)(*(_QWORD *)&v59[8] - 8);
      v30 = *(_QWORD *)(*(_QWORD *)&v59[8] - 8);
      if (v30 != -8)
        bzero(v31, v30 + 8);
      free(v31);
    }
    if (*(_QWORD *)&v59[24])
      (**(void (***)(_QWORD))&v59[24])(*(_QWORD *)&v59[16]);
    if (!v16)
      goto LABEL_50;
    v32 = *(_DWORD *)(a1 + 1568);
    goto LABEL_49;
  }
  if ((*(_BYTE *)(a1 + 1570) & 2) == 0)
  {
    v26 = (*(uint64_t (**)(bssl *, void *, unint64_t *, unint64_t, evp_pkey_st *, const void *, size_t))v25)(v14, a2, a3, a4, a5, a6, a7);
    if ((_DWORD)v26 != 2)
      goto LABEL_47;
    goto LABEL_46;
  }
  v26 = (*(uint64_t (**)(bssl *, void *, unint64_t *, unint64_t))(v25 + 16))(v14, a2, a3, a4);
  if ((_DWORD)v26 == 2)
LABEL_46:
    ERR_put_error(16, 0, 287, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_privkey.cc", 243);
LABEL_47:
  v32 = *(_DWORD *)(a1 + 1568) & 0xFFFDFFFF | (((_DWORD)v26 == 1) << 17);
  *(_DWORD *)(a1 + 1568) = v32;
  if (v16 && !(_DWORD)v26)
  {
LABEL_49:
    if ((v32 & 0x80000) == 0)
    {
LABEL_50:
      v26 = 0;
      goto LABEL_80;
    }
    *(_WORD *)(v16 + 72) = (_WORD)a5;
    v35 = *(_QWORD *)(v16 + 96);
    if (v35)
    {
      v37 = *(_QWORD *)(v35 - 8);
      v36 = (void *)(v35 - 8);
      v38 = v37 + 8;
      if (v37 != -8)
        bzero(v36, v38);
      free(v36);
    }
    v40 = (_QWORD *)(v16 + 80);
    v39 = *(_QWORD *)(v16 + 80);
    v41 = v61;
    *(_QWORD *)(v16 + 96) = v60;
    *(_QWORD *)(v16 + 104) = v41;
    v60 = 0;
    v61 = 0;
    if (v39)
    {
      v43 = *(_QWORD *)(v39 - 8);
      v42 = (void *)(v39 - 8);
      v44 = v43 + 8;
      if (v43 != -8)
        bzero(v42, v44);
      free(v42);
    }
    *v40 = 0;
    *(_QWORD *)(v16 + 88) = 0;
    if (!a7)
      goto LABEL_69;
    if (a7 <= 0xFFFFFFFFFFFFFFF7)
    {
      v45 = malloc_type_malloc(a7 + 8, 0x30772F57uLL);
      if (v45)
      {
        *v45 = a7;
        v46 = v45 + 1;
        *(_QWORD *)(v16 + 80) = v46;
        *(_QWORD *)(v16 + 88) = a7;
        memmove(v46, a6, a7);
LABEL_69:
        v48 = (_QWORD *)(v16 + 112);
        v47 = *(_QWORD *)(v16 + 112);
        v49 = *a3;
        if (v47)
        {
          v51 = *(_QWORD *)(v47 - 8);
          v50 = (void *)(v47 - 8);
          v52 = v51 + 8;
          if (v51 != -8)
            bzero(v50, v52);
          free(v50);
        }
        *v48 = 0;
        *(_QWORD *)(v16 + 120) = 0;
        if (!v49)
          goto LABEL_50;
        if (v49 <= 0xFFFFFFFFFFFFFFF7)
        {
          v53 = malloc_type_malloc(v49 + 8, 0x30772F57uLL);
          if (v53)
          {
            *v53 = v49;
            v54 = v53 + 1;
            *(_QWORD *)(v16 + 112) = v54;
            *(_QWORD *)(v16 + 120) = v49;
            memmove(v54, a2, v49);
            goto LABEL_50;
          }
        }
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        *v48 = 0;
        goto LABEL_79;
      }
    }
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    *v40 = 0;
LABEL_79:
    v26 = 2;
  }
LABEL_80:
  if (v60)
  {
    v56 = v60 - 8;
    v55 = *((_QWORD *)v60 - 1);
    if (v55 != -8)
      bzero(v56, v55 + 8);
    free(v56);
  }
  return v26;
}

uint64_t bssl::setup_ctx(bssl *this, ssl_st *a2, const ssl_st *a3, evp_pkey_st *a4, int a5)
{
  int v6;
  char v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t (*v15)(void);
  const char *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  ssl_st *v21;
  env_md_ctx_st *v22;
  uint64_t result;
  uint64_t v24;
  uint64_t (*v25)(void);
  uint64_t *v26;

  v6 = (int)a4;
  bssl::ssl_pkey_supports_algorithm(this, a3, a4);
  if ((v9 & 1) == 0)
  {
    v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/s"
          "sl/ssl_privkey.cc";
    v17 = 16;
    v18 = 245;
    v19 = 175;
LABEL_46:
    ERR_put_error(v17, 0, v18, v16, v19);
    return 0;
  }
  if (v6 > 1538)
  {
    switch(v6)
    {
      case 2052:
        v14 = &unk_24C0D2338;
        v15 = (uint64_t (*)(void))EVP_sha256;
        if (!EVP_sha256)
          goto LABEL_34;
        goto LABEL_30;
      case 2053:
        v14 = &unk_24C0D2358;
        v15 = (uint64_t (*)(void))EVP_sha384;
        if (!EVP_sha384)
          goto LABEL_34;
        goto LABEL_30;
      case 2054:
        v14 = &unk_24C0D2378;
        v15 = (uint64_t (*)(void))EVP_sha512;
        if (EVP_sha512)
          goto LABEL_30;
        goto LABEL_34;
      case 2055:
        v14 = &unk_24C0D2418;
        goto LABEL_34;
      default:
        if (v6 == 1539)
          v14 = &unk_24C0D23F8;
        else
          v14 = &bssl::kSignatureAlgorithms;
        v15 = (uint64_t (*)(void))*((_QWORD *)v14 + 2);
        if (!v15)
          goto LABEL_34;
        goto LABEL_30;
    }
  }
  v10 = &unk_24C0D23D8;
  if (v6 != 1283)
    v10 = &unk_24C0D2318;
  v11 = &unk_24C0D23B8;
  if (v6 != 1027)
    v11 = &unk_24C0D22F8;
  if (v6 <= 1282)
    v10 = v11;
  v12 = &unk_24C0D22B8;
  v13 = &unk_24C0D2398;
  if (v6 != 515)
    v13 = &unk_24C0D22D8;
  if (v6 != 513)
    v12 = v13;
  if (v6 <= 1026)
    v14 = v12;
  else
    v14 = v10;
  v15 = (uint64_t (*)(void))*((_QWORD *)v14 + 2);
  if (v15)
  {
LABEL_30:
    v20 = v15();
    v26 = 0;
    v21 = a2;
    v22 = (env_md_ctx_st *)a3;
    if (!a5)
      goto LABEL_35;
LABEL_31:
    result = do_sigver_init(v21, &v26, v20, 0, (uint64_t)v22, 1);
    if (!(_DWORD)result)
      return result;
    goto LABEL_36;
  }
LABEL_34:
  v20 = 0;
  v26 = 0;
  v21 = a2;
  v22 = (env_md_ctx_st *)a3;
  if (a5)
    goto LABEL_31;
LABEL_35:
  result = do_sigver_init(v21, &v26, v20, 0, (uint64_t)v22, 0);
  if (!(_DWORD)result)
    return result;
LABEL_36:
  if (!*((_BYTE *)v14 + 24))
    return 1;
  if (!v26 || (v24 = *v26) == 0 || (v25 = *(uint64_t (**)(void))(v24 + 112)) == 0)
  {
    v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/evp/evp_ctx.c";
    v17 = 6;
    v18 = 101;
    v19 = 192;
    goto LABEL_46;
  }
  if (*(_DWORD *)v24 != 6)
  {
    v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/evp/evp_ctx.c";
    v17 = 6;
    v18 = 125;
    v19 = 196;
    goto LABEL_46;
  }
  if (!*((_DWORD *)v26 + 8))
  {
    v16 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/evp/evp_ctx.c";
    v17 = 6;
    v18 = 123;
    v19 = 201;
    goto LABEL_46;
  }
  result = v25();
  if ((_DWORD)result)
  {
    result = EVP_PKEY_CTX_ctrl(v26, 6, 24);
    if ((_DWORD)result)
      return 1;
  }
  return result;
}

BOOL bssl::ssl_public_key_verify(bssl *a1, int a2, int a3, evp_pkey_st *a4, const ssl_st *a5, uint64_t a6, uint64_t a7)
{
  _BOOL8 v9;
  ENGINE *engine;
  unsigned int (*v11)(void);
  char *v12;
  uint64_t v13;
  size_t v14;
  EVP_MD_CTX v16;

  memset(&v16, 0, sizeof(v16));
  if (bssl::setup_ctx(a1, (ssl_st *)&v16, a5, a4, 1))
  {
    if (*(_QWORD *)(*(_QWORD *)v16.flags + 56))
    {
      ((void (*)(EVP_MD_CTX *, uint64_t, uint64_t))v16.digest->init)(&v16, a6, a7);
      v9 = EVP_DigestVerifyFinal(&v16);
      engine = v16.engine;
      if (!v16.engine)
        goto LABEL_14;
    }
    else
    {
      v11 = *(unsigned int (**)(void))(*(_QWORD *)v16.flags + 64);
      if (v11)
      {
        v9 = v11() != 0;
        engine = v16.engine;
        if (!v16.engine)
          goto LABEL_14;
      }
      else
      {
        ERR_put_error(6, 0, 125, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/digestsign/digestsign.c", 255);
        v9 = 0;
        engine = v16.engine;
        if (!v16.engine)
          goto LABEL_14;
      }
    }
  }
  else
  {
    v9 = 0;
    engine = v16.engine;
    if (!v16.engine)
      goto LABEL_14;
  }
  v13 = *((_QWORD *)engine - 1);
  v12 = (char *)engine - 8;
  v14 = v13 + 8;
  if (v13 != -8)
    bzero(v12, v14);
  free(v12);
LABEL_14:
  if (v16.md_data)
    (*(void (**)(unint64_t))v16.md_data)(v16.flags);
  return v9;
}

uint64_t bssl::ssl_private_key_decrypt(uint64_t *a1, unsigned __int8 *a2, unint64_t *a3, unint64_t a4, const unsigned __int8 *a5, unint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t **v12;

  v6 = a1[186];
  v7 = *(_QWORD *)(v6 + 24);
  if (v7)
  {
    v9 = *a1;
    if ((*((_BYTE *)a1 + 1570) & 2) != 0)
    {
      v10 = (*(uint64_t (**)(uint64_t, unsigned __int8 *))(v7 + 16))(v9, a2);
      if ((_DWORD)v10 != 2)
      {
LABEL_10:
        *((_DWORD *)a1 + 392) = a1[196] & 0xFFFDFFFF | (((_DWORD)v10 == 1) << 17);
        return v10;
      }
    }
    else
    {
      v10 = (*(uint64_t (**)(uint64_t, unsigned __int8 *))(v7 + 8))(v9, a2);
      if ((_DWORD)v10 != 2)
        goto LABEL_10;
    }
    ERR_put_error(16, 0, 287, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_privkey.cc", 303);
    goto LABEL_10;
  }
  v11 = *(_QWORD *)(v6 + 16);
  if (*(_DWORD *)(v11 + 4) == 6)
  {
    v12 = *(uint64_t ***)(v11 + 8);
    if (v12)
      return 2 * (RSA_decrypt(v12, a3, a2, a4, a5, a6, 3) == 0);
  }
  else
  {
    ERR_put_error(6, 0, 107, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/evp/p_rsa_asn1.c", 229);
  }
  ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_privkey.cc", 312);
  return 2;
}

void bssl::SSL_SESSION_dup(bssl *this@<X0>, ssl_session_st *a2@<X1>, ssl_session_st **a3@<X8>)
{
  char v3;
  uint64_t v6;
  char *v7;
  char *v8;
  ssl_session_st *v9;
  _QWORD *v10;
  int v11;
  const void *v12;
  size_t v13;
  size_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  size_t v20;
  unint64_t *v21;
  char *v22;
  _QWORD *v23;
  unint64_t *v24;
  size_t v25;
  const void *v26;
  _QWORD *v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int v35;
  char v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t v39;
  unsigned int *v40;
  unint64_t v41;
  void *v42;
  uint64_t v43;
  size_t v44;
  unint64_t *v45;
  uint64_t v46;
  size_t v47;
  uint64_t v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int v51;
  char v52;
  unsigned int *v53;
  uint64_t v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int v57;
  char v58;
  unsigned int *v59;
  __int128 v60;
  uint64_t v61;
  _QWORD *v62;
  size_t v63;
  const void *v64;
  void *v65;
  uint64_t v66;
  size_t v67;
  _QWORD *v68;
  void *v69;
  char v70;
  char v71;
  size_t v72;
  const void *v73;
  uint64_t v74;
  void *v75;
  uint64_t v76;
  size_t v77;
  _QWORD *v78;
  void *v79;
  size_t v80;
  const void *v81;
  uint64_t v82;
  void *v83;
  uint64_t v84;
  size_t v85;
  _QWORD *v86;
  void *v87;
  size_t v88;
  const void *v89;
  uint64_t v90;
  void *v91;
  uint64_t v92;
  size_t v93;
  _QWORD *v94;
  void *v95;
  size_t v96;
  const void *v97;
  uint64_t v98;
  void *v99;
  uint64_t v100;
  size_t v101;
  _QWORD *v102;
  void *v103;
  unsigned int j;
  unsigned int v105;
  uint64_t i;
  unsigned int *v107;
  _QWORD *v108;
  uint64_t v109;
  size_t v110;
  char v111;

  v3 = (char)a2;
  v6 = *((_QWORD *)this + 18);
  v7 = (char *)malloc_type_malloc(0x1C8uLL, 0x30772F57uLL);
  if (!v7)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    *a3 = 0;
    return;
  }
  v8 = v7;
  *(_QWORD *)v7 = 448;
  *((_DWORD *)v7 + 2) = 1;
  v9 = (ssl_session_st *)(v7 + 8);
  *((_QWORD *)v7 + 17) = 0;
  v10 = v7 + 136;
  *(_OWORD *)(v7 + 12) = 0u;
  *(_OWORD *)(v7 + 28) = 0u;
  *(_OWORD *)(v7 + 44) = 0u;
  *(_OWORD *)(v7 + 60) = 0u;
  *(_OWORD *)(v7 + 76) = 0u;
  *(_OWORD *)(v7 + 92) = 0u;
  *(_OWORD *)(v7 + 108) = 0u;
  *(_OWORD *)(v7 + 117) = 0u;
  *((_QWORD *)v7 + 18) = 0;
  *((_QWORD *)v7 + 19) = v6;
  *((_QWORD *)v7 + 20) = 0;
  *((_QWORD *)v7 + 21) = 0;
  *((_QWORD *)v7 + 22) = 0;
  *((_QWORD *)v7 + 23) = 65;
  *((int32x2_t *)v7 + 24) = vdup_n_s32(0x1C20u);
  *((_QWORD *)v7 + 25) = 0;
  *((_QWORD *)v7 + 26) = 0;
  v7[368] = 0;
  *((_OWORD *)v7 + 21) = 0u;
  *((_OWORD *)v7 + 22) = 0u;
  *((_OWORD *)v7 + 19) = 0u;
  *((_OWORD *)v7 + 20) = 0u;
  *((_OWORD *)v7 + 17) = 0u;
  *((_OWORD *)v7 + 18) = 0u;
  *((_OWORD *)v7 + 15) = 0u;
  *((_OWORD *)v7 + 16) = 0u;
  *((_OWORD *)v7 + 14) = 0u;
  *(_OWORD *)(v7 + 372) = 0u;
  *(_OWORD *)(v7 + 388) = 0u;
  *(_OWORD *)(v7 + 404) = 0u;
  *((_OWORD *)v7 + 26) = 0u;
  v7[432] &= 0x80u;
  *((_QWORD *)v7 + 55) = 0;
  *((_QWORD *)v7 + 56) = 0;
  *((_QWORD *)v7 + 27) = 0;
  *((_QWORD *)v7 + 25) = time(0);
  v11 = v8[432] & 0xEF | (16 * ((*((unsigned __int8 *)this + 424) >> 4) & 1));
  v8[432] = v11;
  *((_WORD *)v8 + 6) = *((_WORD *)this + 2);
  v8[432] = *((_BYTE *)this + 424) & 0x20 | v11 & 0xDF;
  v8[100] = *((_BYTE *)this + 92);
  if (*((_BYTE *)this + 92))
    memcpy(v8 + 101, (char *)this + 93, *((unsigned __int8 *)this + 92));
  v111 = v3;
  v8[18] = *((_BYTE *)this + 10);
  if (*((_BYTE *)this + 10))
    memcpy(v8 + 19, (char *)this + 11, *((unsigned __int8 *)this + 10));
  *((_QWORD *)v8 + 26) = *((_QWORD *)this + 25);
  v12 = (const void *)*((_QWORD *)this + 16);
  if (!v12)
    goto LABEL_19;
  v13 = strlen(*((const char **)this + 16));
  v14 = v13 + 1;
  if (v13 != -1)
  {
    if (v14 <= 0xFFFFFFFFFFFFFFF7)
    {
      v15 = malloc_type_malloc(v13 + 9, 0x30772F57uLL);
      if (v15)
      {
        *v15 = v14;
        v16 = v15 + 1;
        memcpy(v15 + 1, v12, v14);
        v17 = (_QWORD *)*v10;
        *v10 = v16;
        if (!v17)
          goto LABEL_18;
        goto LABEL_15;
      }
    }
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  }
  v16 = 0;
  v17 = (_QWORD *)*v10;
  *v10 = 0;
  if (!v17)
    goto LABEL_18;
LABEL_15:
  v19 = *(v17 - 1);
  v18 = v17 - 1;
  v20 = v19 + 8;
  if (v19 != -8)
    bzero(v18, v20);
  free(v18);
  v16 = (_QWORD *)*v10;
LABEL_18:
  if (!v16)
    goto LABEL_130;
LABEL_19:
  v21 = (unint64_t *)*((_QWORD *)this + 17);
  if (v21)
  {
    v22 = (char *)malloc_type_malloc(0x30uLL, 0x30772F57uLL);
    if (!v22)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      goto LABEL_43;
    }
    v23 = v22;
    *(_OWORD *)(v22 + 8) = 0u;
    v24 = (unint64_t *)(v22 + 8);
    *(_QWORD *)v22 = 40;
    *(_OWORD *)(v22 + 24) = 0u;
    *((_QWORD *)v22 + 5) = 0;
    v25 = 8 * v21[3];
    if (v25 == -8)
      goto LABEL_39;
    if (!v25)
      goto LABEL_40;
    v26 = (const void *)v21[1];
    v27 = malloc_type_malloc(v25 + 8, 0x30772F57uLL);
    if (!v27)
    {
LABEL_39:
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      goto LABEL_40;
    }
    *v27 = v25;
    v28 = v27 + 1;
    memcpy(v27 + 1, v26, v25);
    v29 = *v21;
    v23[1] = *v21;
    v23[2] = v28;
    *((_DWORD *)v23 + 6) = *((_DWORD *)v21 + 4);
    v30 = v21[4];
    v23[4] = v21[3];
    v23[5] = v30;
    if (v29)
    {
      v31 = 0;
      while (1)
      {
        v32 = v28[v31];
        if (v32)
        {
          v33 = (unsigned int *)(v32 + 24);
          v34 = atomic_load((unsigned int *)(v32 + 24));
          if (v34 != -1)
          {
            while (1)
            {
              v35 = __ldaxr(v33);
              if (v35 == v34)
              {
                if (!__stlxr(v34 + 1, v33))
                {
                  v36 = 1;
                  goto LABEL_34;
                }
              }
              else
              {
                __clrex();
              }
              v36 = 0;
LABEL_34:
              if ((v36 & 1) == 0)
              {
                v34 = v35;
                if (v35 != -1)
                  continue;
              }
              break;
            }
          }
          *(_QWORD *)(v23[2] + 8 * v31) = v32;
          v28 = (_QWORD *)v23[2];
          if (!v28[v31])
          {
            if (!v31)
              goto LABEL_148;
            for (i = 0; i != v31; ++i)
            {
              v107 = *(unsigned int **)(v23[2] + 8 * i);
              if (v107)
                CRYPTO_BUFFER_free(v107);
            }
            v28 = (_QWORD *)v23[2];
            if (v28)
            {
LABEL_148:
              v109 = *(v28 - 1);
              v108 = v28 - 1;
              v110 = v109 + 8;
              if (v109 != -8)
                bzero(v108, v110);
              free(v108);
            }
LABEL_40:
            if (*v23 != -8)
              __memset_chk();
            free(v23);
LABEL_43:
            v24 = 0;
            break;
          }
          v29 = *v24;
        }
        if (++v31 >= v29)
          break;
      }
    }
    v37 = (unint64_t *)*((_QWORD *)v8 + 18);
    *((_QWORD *)v8 + 18) = v24;
    if (v37)
    {
      v38 = *v37;
      if (*v37)
      {
        v39 = 0;
        do
        {
          v40 = *(unsigned int **)(v37[1] + 8 * v39);
          if (v40)
          {
            CRYPTO_BUFFER_free(v40);
            v38 = *v37;
          }
          ++v39;
        }
        while (v39 < v38);
      }
      v41 = v37[1];
      if (v41)
      {
        v43 = *(_QWORD *)(v41 - 8);
        v42 = (void *)(v41 - 8);
        v44 = v43 + 8;
        if (v43 != -8)
          bzero(v42, v44);
        free(v42);
      }
      v46 = *(v37 - 1);
      v45 = v37 - 1;
      v47 = v46 + 8;
      if (v46 != -8)
        bzero(v45, v47);
      free(v45);
      v24 = (unint64_t *)*((_QWORD *)v8 + 18);
    }
    if (!v24)
      goto LABEL_130;
  }
  if (!(*(unsigned int (**)(ssl_session_st *, bssl *))(*((_QWORD *)this + 18) + 56))(v9, this))
    goto LABEL_130;
  *((_QWORD *)v8 + 23) = *((_QWORD *)this + 22);
  v48 = *((_QWORD *)this + 32);
  if (v48)
  {
    v49 = (unsigned int *)(v48 + 24);
    v50 = atomic_load((unsigned int *)(v48 + 24));
    if (v50 != -1)
    {
      while (1)
      {
        v51 = __ldaxr(v49);
        if (v51 == v50)
        {
          if (!__stlxr(v50 + 1, v49))
          {
            v52 = 1;
            goto LABEL_66;
          }
        }
        else
        {
          __clrex();
        }
        v52 = 0;
LABEL_66:
        if ((v52 & 1) == 0)
        {
          v50 = v51;
          if (v51 != -1)
            continue;
        }
        break;
      }
    }
  }
  v53 = (unsigned int *)*((_QWORD *)v8 + 33);
  *((_QWORD *)v8 + 33) = v48;
  if (v53)
    CRYPTO_BUFFER_free(v53);
  v54 = *((_QWORD *)this + 31);
  if (v54)
  {
    v55 = (unsigned int *)(v54 + 24);
    v56 = atomic_load((unsigned int *)(v54 + 24));
    if (v56 != -1)
    {
      while (1)
      {
        v57 = __ldaxr(v55);
        if (v57 == v56)
        {
          if (!__stlxr(v56 + 1, v55))
          {
            v58 = 1;
            goto LABEL_77;
          }
        }
        else
        {
          __clrex();
        }
        v58 = 0;
LABEL_77:
        if ((v58 & 1) == 0)
        {
          v56 = v57;
          if (v57 != -1)
            continue;
        }
        break;
      }
    }
  }
  v59 = (unsigned int *)*((_QWORD *)v8 + 32);
  *((_QWORD *)v8 + 32) = v54;
  if (v59)
    CRYPTO_BUFFER_free(v59);
  v60 = *(_OWORD *)((char *)this + 280);
  *((_OWORD *)v8 + 17) = *(_OWORD *)((char *)this + 264);
  *((_OWORD *)v8 + 18) = v60;
  v8[432] = v8[432] & 0xFD | *((_BYTE *)this + 424) & 2;
  *((_WORD *)v8 + 8) = *((_WORD *)this + 4);
  *((_QWORD *)v8 + 24) = *((_QWORD *)this + 23);
  *((_QWORD *)v8 + 25) = *((_QWORD *)this + 24);
  if ((v111 & 2) == 0)
    goto LABEL_82;
  v8[67] = *((_BYTE *)this + 59);
  if (*((_BYTE *)this + 59))
    memcpy(v8 + 68, (char *)this + 60, *((unsigned __int8 *)this + 59));
  *((_WORD *)v8 + 7) = *((_WORD *)this + 3);
  if (*((_BYTE *)this + 360))
  {
    memcpy(v8 + 304, (char *)this + 296, *((unsigned __int8 *)this + 360));
    v70 = *((_BYTE *)this + 360);
  }
  else
  {
    v70 = 0;
  }
  v8[368] = v70;
  *((_DWORD *)v8 + 93) = *((_DWORD *)this + 91);
  *((_QWORD *)v8 + 47) = *((_QWORD *)this + 46);
  v71 = v8[432] & 0xFE | *((_BYTE *)this + 424) & 1;
  v8[432] = v71;
  v8[432] = v71 & 0xBF | *((_BYTE *)this + 424) & 0x40;
  v62 = v8 + 384;
  v73 = (const void *)*((_QWORD *)this + 47);
  v72 = *((_QWORD *)this + 48);
  v74 = *((_QWORD *)v8 + 48);
  if (v74)
  {
    v76 = *(_QWORD *)(v74 - 8);
    v75 = (void *)(v74 - 8);
    v77 = v76 + 8;
    if (v76 != -8)
      bzero(v75, v77);
    free(v75);
  }
  *v62 = 0;
  *((_QWORD *)v8 + 49) = 0;
  if (v72)
  {
    if (v72 > 0xFFFFFFFFFFFFFFF7)
      goto LABEL_129;
    v78 = malloc_type_malloc(v72 + 8, 0x30772F57uLL);
    if (!v78)
      goto LABEL_129;
    *v78 = v72;
    v79 = v78 + 1;
    *((_QWORD *)v8 + 48) = v79;
    *((_QWORD *)v8 + 49) = v72;
    memmove(v79, v73, v72);
  }
  v62 = v8 + 440;
  v81 = (const void *)*((_QWORD *)this + 54);
  v80 = *((_QWORD *)this + 55);
  v82 = *((_QWORD *)v8 + 55);
  if (v82)
  {
    v84 = *(_QWORD *)(v82 - 8);
    v83 = (void *)(v82 - 8);
    v85 = v84 + 8;
    if (v84 != -8)
      bzero(v83, v85);
    free(v83);
  }
  *v62 = 0;
  *((_QWORD *)v8 + 56) = 0;
  if (v80)
  {
    if (v80 > 0xFFFFFFFFFFFFFFF7)
      goto LABEL_129;
    v86 = malloc_type_malloc(v80 + 8, 0x30772F57uLL);
    if (!v86)
      goto LABEL_129;
    *v86 = v80;
    v87 = v86 + 1;
    *((_QWORD *)v8 + 55) = v87;
    *((_QWORD *)v8 + 56) = v80;
    memmove(v87, v81, v80);
  }
  v62 = v8 + 400;
  v89 = (const void *)*((_QWORD *)this + 49);
  v88 = *((_QWORD *)this + 50);
  v90 = *((_QWORD *)v8 + 50);
  if (v90)
  {
    v92 = *(_QWORD *)(v90 - 8);
    v91 = (void *)(v90 - 8);
    v93 = v92 + 8;
    if (v92 != -8)
      bzero(v91, v93);
    free(v91);
  }
  *v62 = 0;
  *((_QWORD *)v8 + 51) = 0;
  if (v88)
  {
    if (v88 > 0xFFFFFFFFFFFFFFF7)
      goto LABEL_129;
    v94 = malloc_type_malloc(v88 + 8, 0x30772F57uLL);
    if (!v94)
      goto LABEL_129;
    *v94 = v88;
    v95 = v94 + 1;
    *((_QWORD *)v8 + 50) = v95;
    *((_QWORD *)v8 + 51) = v88;
    memmove(v95, v89, v88);
  }
  v62 = v8 + 416;
  v97 = (const void *)*((_QWORD *)this + 51);
  v96 = *((_QWORD *)this + 52);
  v98 = *((_QWORD *)v8 + 52);
  if (v98)
  {
    v100 = *(_QWORD *)(v98 - 8);
    v99 = (void *)(v98 - 8);
    v101 = v100 + 8;
    if (v100 != -8)
      bzero(v99, v101);
    free(v99);
  }
  *v62 = 0;
  *((_QWORD *)v8 + 53) = 0;
  if (!v96)
    goto LABEL_82;
  if (v96 <= 0xFFFFFFFFFFFFFFF7)
  {
    v102 = malloc_type_malloc(v96 + 8, 0x30772F57uLL);
    if (v102)
    {
      *v102 = v96;
      v103 = v102 + 1;
      *((_QWORD *)v8 + 52) = v103;
      *((_QWORD *)v8 + 53) = v96;
      memmove(v103, v97, v96);
LABEL_82:
      if ((v111 & 1) == 0)
        goto LABEL_91;
      v62 = v8 + 240;
      v61 = *((_QWORD *)v8 + 30);
      v64 = (const void *)*((_QWORD *)this + 29);
      v63 = *((_QWORD *)this + 30);
      if (v61)
      {
        v66 = *(_QWORD *)(v61 - 8);
        v65 = (void *)(v61 - 8);
        v67 = v66 + 8;
        if (v66 != -8)
          bzero(v65, v67);
        free(v65);
      }
      *v62 = 0;
      *((_QWORD *)v8 + 31) = 0;
      if (!v63)
        goto LABEL_91;
      if (v63 <= 0xFFFFFFFFFFFFFFF7)
      {
        v68 = malloc_type_malloc(v63 + 8, 0x30772F57uLL);
        if (v68)
        {
          *v68 = v63;
          v69 = v68 + 1;
          *((_QWORD *)v8 + 30) = v69;
          *((_QWORD *)v8 + 31) = v63;
          memmove(v69, v64, v63);
LABEL_91:
          v8[432] |= 4u;
          *a3 = v9;
          return;
        }
      }
    }
  }
LABEL_129:
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  *v62 = 0;
LABEL_130:
  *a3 = 0;
  for (j = atomic_load((unsigned int *)v9); j != -1; j = v105)
  {
    if (!j)
      abort();
    v105 = __ldaxr((unsigned int *)v9);
    if (v105 == j)
    {
      if (!__stlxr(j - 1, (unsigned int *)v9))
      {
        if (j == 1)
        {
          ssl_session_st::~ssl_session_st(v9);
          if (*(_QWORD *)v8 != -8)
            __memset_chk();
          free(v8);
        }
        return;
      }
    }
    else
    {
      __clrex();
    }
  }
}

int8x8_t bssl::ssl_session_rebase_time(bssl *this, ssl_st *a2, ssl_session_st *a3)
{
  void (*v4)(_QWORD, timeval *, ssl_session_st *);
  int8x8_t result;
  STACK *v6;
  STACK *cipher_list_by_id;
  BOOL v8;
  unint64_t v9;
  STACK *v10;
  STACK *cipher_list;
  uint64x2_t v12;
  timeval v13;

  v4 = *(void (**)(_QWORD, timeval *, ssl_session_st *))(*((_QWORD *)this + 13) + 696);
  if (v4)
  {
    v4(0, &v13, a3);
    v6 = (STACK *)(v13.tv_sec & ~(v13.tv_sec >> 63));
    cipher_list_by_id = a2->cipher_list_by_id;
    v8 = v6 >= cipher_list_by_id;
    v9 = (char *)v6 - (char *)cipher_list_by_id;
    if (!v8)
    {
LABEL_3:
      a2->cipher_list = 0;
      a2->cipher_list_by_id = v6;
      return result;
    }
  }
  else
  {
    gettimeofday(&v13, 0);
    v6 = (STACK *)(v13.tv_sec & ~(v13.tv_sec >> 63));
    v10 = a2->cipher_list_by_id;
    v8 = v6 >= v10;
    v9 = (char *)v6 - (char *)v10;
    if (!v8)
      goto LABEL_3;
  }
  a2->cipher_list_by_id = v6;
  cipher_list = a2->cipher_list;
  v12.i64[0] = cipher_list;
  v12.i64[1] = HIDWORD(cipher_list);
  result = vbic_s8((int8x8_t)vsub_s32((int32x2_t)cipher_list, vdup_n_s32(v9)), (int8x8_t)vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(v9), v12)));
  a2->cipher_list = (STACK *)result;
  return result;
}

uint64_t bssl::ssl_session_renew_timeout(bssl *this, ssl_st *a2, ssl_session_st *a3)
{
  unsigned int v3;
  uint64_t (*v5)(_QWORD, timeval *);
  uint64_t result;
  STACK *v7;
  STACK *cipher_list_by_id;
  BOOL v9;
  unint64_t v10;
  unsigned int v11;
  STACK *v12;
  unint64_t cipher_list_low;
  unint64_t cipher_list_high;
  unsigned int v15;
  timeval v16;

  v3 = a3;
  v5 = *(uint64_t (**)(_QWORD, timeval *))(*((_QWORD *)this + 13) + 696);
  if (v5)
  {
    result = v5(0, &v16);
    v7 = (STACK *)(v16.tv_sec & ~(v16.tv_sec >> 63));
    cipher_list_by_id = a2->cipher_list_by_id;
    v9 = v7 >= cipher_list_by_id;
    v10 = (char *)v7 - (char *)cipher_list_by_id;
    if (!v9)
    {
LABEL_3:
      v11 = 0;
      a2->cipher_list_by_id = v7;
      HIDWORD(a2->cipher_list) = 0;
LABEL_13:
      if (v11 >= v3)
        v11 = v3;
      LODWORD(a2->cipher_list) = v11;
      return result;
    }
  }
  else
  {
    result = gettimeofday(&v16, 0);
    v7 = (STACK *)(v16.tv_sec & ~(v16.tv_sec >> 63));
    v12 = a2->cipher_list_by_id;
    v9 = v7 >= v12;
    v10 = (char *)v7 - (char *)v12;
    if (!v9)
      goto LABEL_3;
  }
  a2->cipher_list_by_id = v7;
  cipher_list_low = LODWORD(a2->cipher_list);
  cipher_list_high = HIDWORD(a2->cipher_list);
  if (v10 <= cipher_list_low)
    v15 = cipher_list_low - v10;
  else
    v15 = 0;
  if (v10 <= cipher_list_high)
    v11 = cipher_list_high - v10;
  else
    v11 = 0;
  LODWORD(a2->cipher_list) = v15;
  HIDWORD(a2->cipher_list) = v11;
  if (v15 <= v3)
    goto LABEL_13;
  return result;
}

uint64_t bssl::ssl_session_protocol_version(bssl *this, const ssl_session_st *a2)
{
  uint64_t result;

  result = *((unsigned __int16 *)this + 2);
  if ((result - 769) >= 4)
  {
    if ((_DWORD)result == 65277)
    {
      return 771;
    }
    else if ((_DWORD)result == 65279)
    {
      return 770;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t *bssl::ssl_session_get_digest(bssl *this, const ssl_session_st *a2, const ssl_cipher_st *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *((unsigned __int16 *)this + 2);
  if ((v3 - 769) >= 4)
  {
    if (v3 == 65277)
    {
      v4 = *((_QWORD *)this + 25);
      v5 = 771;
    }
    else
    {
      v4 = *((_QWORD *)this + 25);
      if (v3 == 65279)
        v5 = 770;
      else
        v5 = 0;
    }
  }
  else
  {
    v4 = *((_QWORD *)this + 25);
    v5 = *((unsigned __int16 *)this + 2);
  }
  return bssl::ssl_get_handshake_digest((bssl *)v5, v4, a3);
}

uint64_t bssl::ssl_get_new_session(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2;
  uint64_t v4;
  char *v5;
  char *v6;
  ssl_session_st *v7;
  __darwin_time_t *v8;
  char v9;
  void (*v10)(_QWORD, timeval *);
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  unsigned int i;
  unsigned int v16;
  int v18;
  char v19;
  ssl_session_st *v20;
  unsigned int j;
  unsigned int v22;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v25;
  ssl_session_st *v26;
  unsigned int k;
  unsigned int v28;
  uint64_t *v29;
  uint64_t v30;
  size_t v31;
  timeval v32;

  v2 = *(_QWORD *)this;
  if ((*(_BYTE *)(*(_QWORD *)this + 133) & 2) != 0)
  {
    ERR_put_error(16, 0, 209, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_session.cc", 355);
    return 0;
  }
  v4 = *(_QWORD *)(*(_QWORD *)(v2 + 104) + 16);
  v5 = (char *)malloc_type_malloc(0x1C8uLL, 0x30772F57uLL);
  if (!v5)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v6 = v5;
  *(_QWORD *)v5 = 448;
  *((_DWORD *)v5 + 2) = 1;
  v7 = (ssl_session_st *)(v5 + 8);
  *(_OWORD *)(v5 + 12) = 0u;
  *(_OWORD *)(v5 + 28) = 0u;
  *(_OWORD *)(v5 + 44) = 0u;
  *(_OWORD *)(v5 + 60) = 0u;
  *(_OWORD *)(v5 + 76) = 0u;
  *(_OWORD *)(v5 + 92) = 0u;
  *(_OWORD *)(v5 + 108) = 0u;
  *(_OWORD *)(v5 + 117) = 0u;
  *((_QWORD *)v5 + 17) = 0;
  *((_QWORD *)v5 + 18) = 0;
  *((_QWORD *)v5 + 19) = v4;
  *((_QWORD *)v5 + 20) = 0;
  *((_QWORD *)v5 + 21) = 0;
  *((_QWORD *)v5 + 22) = 0;
  *((_QWORD *)v5 + 23) = 65;
  *((int32x2_t *)v5 + 24) = vdup_n_s32(0x1C20u);
  *((_QWORD *)v5 + 25) = 0;
  v8 = (__darwin_time_t *)(v5 + 200);
  v5[368] = 0;
  *((_OWORD *)v5 + 21) = 0u;
  *((_OWORD *)v5 + 22) = 0u;
  *((_OWORD *)v5 + 19) = 0u;
  *((_OWORD *)v5 + 20) = 0u;
  *((_OWORD *)v5 + 17) = 0u;
  *((_OWORD *)v5 + 18) = 0u;
  *((_OWORD *)v5 + 15) = 0u;
  *((_OWORD *)v5 + 16) = 0u;
  *((_OWORD *)v5 + 14) = 0u;
  *(_OWORD *)(v5 + 372) = 0u;
  *(_OWORD *)(v5 + 388) = 0u;
  *(_OWORD *)(v5 + 404) = 0u;
  *((_OWORD *)v5 + 26) = 0u;
  v5[432] &= 0x80u;
  *((_QWORD *)v5 + 55) = 0;
  *((_QWORD *)v5 + 56) = 0;
  *((_QWORD *)v5 + 26) = 0;
  *((_QWORD *)v5 + 27) = 0;
  *((_QWORD *)v5 + 25) = time(0);
  v9 = v6[432] & 0xEF | (16 * (*(_BYTE *)(v2 + 164) & 1));
  v6[432] = v9;
  *((_WORD *)v6 + 6) = *(_WORD *)(v2 + 16);
  v6[432] = v9 & 0xDF | (32 * (*(_QWORD *)(v2 + 152) != 0));
  v10 = *(void (**)(_QWORD, timeval *))(*(_QWORD *)(v2 + 104) + 696);
  if (v10)
    v10(0, &v32);
  else
    gettimeofday(&v32, 0);
  *v8 = v32.tv_sec & ~(v32.tv_sec >> 63);
  v11 = *(unsigned __int16 *)(v2 + 16);
  if (v11 - 769 > 3)
  {
    v12 = *(_QWORD *)(v2 + 112);
  }
  else
  {
    v12 = *(_QWORD *)(v2 + 112);
    if (v11 >= 0x304)
    {
      *((_DWORD *)v6 + 48) = *(_DWORD *)(v12 + 300);
      *((_DWORD *)v6 + 49) = 604800;
      v13 = *(_QWORD *)(*((_QWORD *)this + 1) + 32);
      v14 = *(unsigned __int8 *)(v13 + 88);
      if (v14 > 0x20)
        goto LABEL_11;
      goto LABEL_25;
    }
  }
  v18 = *(_DWORD *)(v12 + 296);
  *((_DWORD *)v6 + 48) = v18;
  *((_DWORD *)v6 + 49) = v18;
  v13 = *(_QWORD *)(*((_QWORD *)this + 1) + 32);
  v14 = *(unsigned __int8 *)(v13 + 88);
  if (v14 > 0x20)
  {
LABEL_11:
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_session.cc", 387);
    for (i = atomic_load((unsigned int *)v7); i != -1; i = v16)
    {
      if (!i)
        goto LABEL_53;
      v16 = __ldaxr((unsigned int *)v7);
      if (v16 == i)
      {
        if (!__stlxr(i - 1, (unsigned int *)v7))
        {
          if (i == 1)
          {
            ssl_session_st::~ssl_session_st(v7);
            if (*(_QWORD *)v6 != -8)
              __memset_chk();
            free(v6);
          }
          return 0;
        }
      }
      else
      {
        __clrex();
      }
    }
    return 0;
  }
LABEL_25:
  if ((_DWORD)v14)
  {
    memcpy(v6 + 101, (const void *)(v13 + 89), v14);
    v19 = *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 1) + 32) + 88);
  }
  else
  {
    v19 = 0;
  }
  v6[100] = v19;
  v6[432] |= 4u;
  *((_QWORD *)v6 + 23) = 65;
  v20 = (ssl_session_st *)*((_QWORD *)this + 188);
  *((_QWORD *)this + 188) = v7;
  if (v20)
  {
    for (j = atomic_load((unsigned int *)v20); j != -1; j = v22)
    {
      if (!j)
LABEL_53:
        abort();
      v22 = __ldaxr((unsigned int *)v20);
      if (v22 == j)
      {
        if (!__stlxr(j - 1, (unsigned int *)v20))
        {
          if (j == 1)
          {
            ssl_session_st::~ssl_session_st(v20);
            tlsext_tick_lifetime_hint = v20[-1].tlsext_tick_lifetime_hint;
            p_tlsext_tick_lifetime_hint = &v20[-1].tlsext_tick_lifetime_hint;
            v25 = tlsext_tick_lifetime_hint + 8;
            if (tlsext_tick_lifetime_hint != -8)
              bzero(p_tlsext_tick_lifetime_hint, v25);
            free(p_tlsext_tick_lifetime_hint);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  v26 = *(ssl_session_st **)(v2 + 88);
  if (v26)
  {
    *(_QWORD *)(v2 + 88) = 0;
    for (k = atomic_load((unsigned int *)v26); k != -1; k = v28)
    {
      if (!k)
        goto LABEL_53;
      v28 = __ldaxr((unsigned int *)v26);
      if (v28 == k)
      {
        if (!__stlxr(k - 1, (unsigned int *)v26))
        {
          if (k == 1)
          {
            ssl_session_st::~ssl_session_st(v26);
            v30 = v26[-1].tlsext_tick_lifetime_hint;
            v29 = &v26[-1].tlsext_tick_lifetime_hint;
            v31 = v30 + 8;
            if (v30 != -8)
              bzero(v29, v31);
            free(v29);
          }
          return 1;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  return 1;
}

void bssl::ssl_set_session(bssl *this, ssl_session_st *a2, ssl_session_st *a3)
{
  ssl_session_st *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int i;
  unsigned int v7;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v10;

  v3 = (ssl_session_st *)*((_QWORD *)this + 11);
  if (v3 != a2)
  {
    if (a2)
    {
      v4 = atomic_load((unsigned int *)a2);
      if (v4 != -1)
      {
        do
        {
          v5 = __ldaxr((unsigned int *)a2);
          if (v5 == v4)
          {
            if (!__stlxr(v4 + 1, (unsigned int *)a2))
              break;
          }
          else
          {
            __clrex();
          }
          v4 = v5;
        }
        while (v5 != -1);
      }
      v3 = (ssl_session_st *)*((_QWORD *)this + 11);
    }
    *((_QWORD *)this + 11) = a2;
    if (v3)
    {
      for (i = atomic_load((unsigned int *)v3); i != -1; i = v7)
      {
        if (!i)
          abort();
        v7 = __ldaxr((unsigned int *)v3);
        if (v7 == i)
        {
          if (!__stlxr(i - 1, (unsigned int *)v3))
          {
            if (i == 1)
            {
              ssl_session_st::~ssl_session_st(v3);
              tlsext_tick_lifetime_hint = v3[-1].tlsext_tick_lifetime_hint;
              p_tlsext_tick_lifetime_hint = &v3[-1].tlsext_tick_lifetime_hint;
              v10 = tlsext_tick_lifetime_hint + 8;
              if (tlsext_tick_lifetime_hint != -8)
                bzero(p_tlsext_tick_lifetime_hint, v10);
              free(p_tlsext_tick_lifetime_hint);
            }
            return;
          }
        }
        else
        {
          __clrex();
        }
      }
    }
  }
}

uint64_t bssl::ssl_ctx_rotate_ticket_encryption_key(bssl *this, ssl_ctx_st *a2)
{
  void (*v3)(_QWORD, timeval *);
  unint64_t v4;
  pthread_rwlock_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  size_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  size_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  size_t v27;
  timeval v29;

  v3 = (void (*)(_QWORD, timeval *))*((_QWORD *)this + 87);
  if (v3)
  {
    v3(0, &v29);
    v4 = v29.tv_sec & ~(v29.tv_sec >> 63);
    v5 = (pthread_rwlock_t *)((char *)this + 24);
    if (pthread_rwlock_rdlock((pthread_rwlock_t *)((char *)this + 24)))
      goto LABEL_33;
  }
  else
  {
    gettimeofday(&v29, 0);
    v4 = v29.tv_sec & ~(v29.tv_sec >> 63);
    v5 = (pthread_rwlock_t *)((char *)this + 24);
    if (pthread_rwlock_rdlock((pthread_rwlock_t *)((char *)this + 24)))
      goto LABEL_33;
  }
  v6 = *((_QWORD *)this + 64);
  if (v6)
  {
    if (*(_QWORD *)(v6 + 48) - 1 >= v4)
    {
      v7 = *((_QWORD *)this + 65);
      if (!v7 || *(_QWORD *)(v7 + 48) > v4)
      {
        if (pthread_rwlock_unlock(v5))
          goto LABEL_33;
        return 1;
      }
    }
  }
  if (pthread_rwlock_unlock(v5) || pthread_rwlock_wrlock(v5))
LABEL_33:
    abort();
  v9 = *((_QWORD *)this + 64);
  if (v9 && *(_QWORD *)(v9 + 48) - 1 >= v4)
  {
LABEL_25:
    v24 = *((_QWORD *)this + 65);
    if (v24 && *(_QWORD *)(v24 + 48) <= v4)
    {
      *((_QWORD *)this + 65) = 0;
      v26 = *(_QWORD *)(v24 - 8);
      v25 = (void *)(v24 - 8);
      v27 = v26 + 8;
      if (v26 != -8)
        bzero(v25, v27);
      free(v25);
    }
    v8 = 1;
    if (!pthread_rwlock_unlock(v5))
      return v8;
    goto LABEL_33;
  }
  v10 = (char *)malloc_type_malloc(0x40uLL, 0x30772F57uLL);
  if (v10)
  {
    v11 = v10;
    *(_QWORD *)v10 = 56;
    *(_OWORD *)(v10 + 8) = 0u;
    v12 = v10 + 8;
    *((_QWORD *)v10 + 7) = 0;
    *(_OWORD *)(v10 + 40) = 0u;
    v13 = (uint64_t)(v10 + 40);
    *(_OWORD *)(v10 + 24) = 0u;
    v14 = (uint64_t)(v10 + 24);
    RAND_bytes_with_additional_data((uint64_t)(v10 + 8), 0x10uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
    RAND_bytes_with_additional_data(v14, 0x10uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
    RAND_bytes_with_additional_data(v13, 0x10uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
    *((_QWORD *)v11 + 7) = v4 + 172800;
    v15 = *((_QWORD *)this + 64);
    if (v15
      && (*(_QWORD *)(v15 + 48) += 172800,
          *((_QWORD *)this + 64) = 0,
          v16 = *((_QWORD *)this + 65),
          *((_QWORD *)this + 65) = v15,
          v16))
    {
      v18 = *(_QWORD *)(v16 - 8);
      v17 = (void *)(v16 - 8);
      v19 = v18 + 8;
      if (v18 != -8)
        bzero(v17, v19);
      free(v17);
      v20 = *((_QWORD *)this + 64);
      *((_QWORD *)this + 64) = v12;
      if (v20)
      {
        v22 = *(_QWORD *)(v20 - 8);
        v21 = (void *)(v20 - 8);
        v23 = v22 + 8;
        if (v22 != -8)
          bzero(v21, v23);
        free(v21);
      }
    }
    else
    {
      *((_QWORD *)this + 64) = v12;
    }
    goto LABEL_25;
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  v8 = 0;
  if (pthread_rwlock_unlock(v5))
    goto LABEL_33;
  return v8;
}

BOOL bssl::ssl_encrypt_ticket(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  ssl_ctx_st *v5;
  uint64_t v6;
  uint64_t v7;
  const unsigned __int8 *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  _BOOL8 v15;
  _QWORD *v17;
  uint64_t v18;
  char *v19;
  BOOL v20;
  uint64_t v21;
  uint64_t (*v22)(uint64_t, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, HMAC_CTX *, uint64_t);
  uint64_t (*v23)(unsigned __int8 *, uint64_t, _QWORD, unsigned int *);
  int v24;
  unsigned int key_length;
  const EVP_CIPHER *v26;
  ENGINE *v27;
  const void *v28;
  const EVP_MD *v29;
  int v30;
  int v31;
  int v32;
  size_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t v39;
  BOOL v40;
  unint64_t v41;
  char v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  unint64_t v49;
  BOOL v50;
  void (*v51)(unsigned __int8 *);
  uint64_t v52;
  void *v53;
  unsigned __int8 *v54;
  uint64_t v55;
  size_t v56;
  unint64_t v58;
  const unsigned __int8 *v59;
  unsigned int len;
  unsigned __int8 *out;
  HMAC_CTX ctx;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v58 = 0;
  v59 = 0;
  if (!SSL_SESSION_to_bytes_for_ticket(a3, &v59, &v58))
    return 0;
  v6 = *a1;
  v7 = *(_QWORD *)(*(_QWORD *)(*a1 + 112) + 712);
  v9 = v58;
  v8 = v59;
  if (!v7)
  {
    v66 = 0;
    v64 = 0u;
    v65 = 0u;
    v63 = 0u;
    memset(&ctx.key[36], 0, 96);
    memset(&ctx, 0, 104);
    if (v58 >> 7 >= 0x1FF)
    {
      *(_QWORD *)&ctx.key[20] = 0;
      if (CBB_add_space(a2, &ctx.key[20], 16))
      {
        **(_OWORD **)&ctx.key[20] = *(_OWORD *)"TICKET TOO LARGE";
LABEL_11:
        v14 = 1;
        goto LABEL_73;
      }
      goto LABEL_72;
    }
    v21 = *(_QWORD *)(v6 + 112);
    v22 = *(uint64_t (**)(uint64_t, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, HMAC_CTX *, uint64_t))(v21 + 528);
    if (v22)
    {
      if ((v22(v6, &ctx.key[4], &ctx.key[20], &ctx.key[36], &ctx, 1) & 0x80000000) != 0)
        goto LABEL_72;
LABEL_25:
      out = 0;
      *(_QWORD *)&ctx.key_length = 0;
      if (!CBB_add_space(a2, &ctx.key_length, 16))
        goto LABEL_72;
      **(_OWORD **)&ctx.key_length = *(_OWORD *)&ctx.key[4];
      if ((*(_DWORD *)(*(_QWORD *)&ctx.key[36] + 20) & 0x3F) != 6)
        goto LABEL_44;
      ctx.key_length = 0;
      v23 = *(uint64_t (**)(unsigned __int8 *, uint64_t, _QWORD, unsigned int *))(*(_QWORD *)&ctx.key[36] + 48);
      if (v23)
      {
        v24 = v23(&ctx.key[36], 25, 0, &ctx.key_length);
        if (v24 != -1)
        {
          if (v24 == 1)
          {
            key_length = ctx.key_length;
LABEL_45:
            v33 = key_length;
            *(_QWORD *)&ctx.key_length = 0;
            if (CBB_add_space(a2, &ctx.key_length, key_length))
            {
              if ((_DWORD)v33)
                memcpy(*(void **)&ctx.key_length, &ctx.key[20], v33);
              if (CBB_reserve(a2, &out, v9 + 32))
              {
                ctx.key_length = 0;
                if (EVP_EncryptUpdate((EVP_CIPHER_CTX *)&ctx.key[36], out, (int *)&ctx.key_length, v8, v9))
                {
                  v34 = (int)ctx.key_length;
                  if (EVP_EncryptFinal_ex((EVP_CIPHER_CTX *)&ctx.key[36], &out[ctx.key_length], (int *)&ctx.key_length))
                  {
                    v35 = (int)ctx.key_length + v34;
                    v36 = *(unsigned __int8 *)(a2 + 8);
                    v37 = (_QWORD *)(a2 + 16);
                    v38 = (_QWORD *)(a2 + 16);
                    if (*(_BYTE *)(a2 + 8))
                      v38 = (_QWORD *)*v37;
                    v14 = 0;
                    v39 = v38[1];
                    v40 = __CFADD__(v35, v39);
                    v41 = v35 + v39;
                    v42 = v40;
                    if (*(_QWORD *)a2 || (v42 & 1) != 0)
                      goto LABEL_73;
                    if (v41 <= v38[2])
                    {
                      v38[1] = v41;
                      len = 0;
                      v43 = (_QWORD *)*v37;
                      if (v36)
                      {
                        v44 = *(_QWORD *)(a2 + 24) + *(unsigned __int8 *)(a2 + 32);
                        v45 = v43[1];
                        v43 = (_QWORD *)(v44 + *v43);
                        v46 = v45 - v44;
                      }
                      else
                      {
                        v46 = *(_QWORD *)(a2 + 24);
                      }
                      ((void (*)(EVP_MD_CTX *, _QWORD *, uint64_t))ctx.md_ctx.digest->init)(&ctx.md_ctx, v43, v46);
                      if (CBB_reserve(a2, &out, 64))
                      {
                        HMAC_Final(&ctx, out, &len);
                        if (v47)
                        {
                          if (*(_BYTE *)(a2 + 8))
                            v37 = (_QWORD *)*v37;
                          v14 = 0;
                          v48 = v37[1];
                          v49 = v48 + len;
                          v50 = __CFADD__(v48, len);
                          if (*(_QWORD *)a2 || v50)
                            goto LABEL_73;
                          if (v49 <= v37[2])
                          {
                            v37[1] = v49;
                            goto LABEL_11;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
LABEL_72:
            v14 = 0;
LABEL_73:
            HMAC_CTX_cleanup(&ctx);
            if (*(_QWORD *)&ctx.key[36])
            {
              v51 = *(void (**)(unsigned __int8 *))(*(_QWORD *)&ctx.key[36] + 40);
              if (v51)
                v51(&ctx.key[36]);
            }
            if (*(_QWORD *)&ctx.key[52])
            {
              v53 = (void *)(*(_QWORD *)&ctx.key[52] - 8);
              v52 = *(_QWORD *)(*(_QWORD *)&ctx.key[52] - 8);
              if (v52 != -8)
                bzero(v53, v52 + 8);
              free(v53);
            }
            goto LABEL_80;
          }
LABEL_44:
          key_length = *(_DWORD *)(*(_QWORD *)&ctx.key[36] + 12);
          goto LABEL_45;
        }
        v31 = 105;
        v32 = 631;
      }
      else
      {
        v31 = 104;
        v32 = 625;
      }
      ERR_put_error(30, 0, v31, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/cipher/cipher.c", v32);
      goto LABEL_44;
    }
    if (!bssl::ssl_ctx_rotate_ticket_encryption_key(*(bssl **)(v6 + 112), v5))
      goto LABEL_72;
    if (!pthread_rwlock_rdlock((pthread_rwlock_t *)(v21 + 24)))
    {
      RAND_bytes_with_additional_data((uint64_t)&ctx.key[20], 0x10uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
      v26 = EVP_aes_128_cbc();
      if (EVP_CipherInit_ex((EVP_CIPHER_CTX *)&ctx.key[36], v26, v27, (const unsigned __int8 *)(*(_QWORD *)(v21 + 512) + 32), &ctx.key[20], 1)&& (v28 = (const void *)(*(_QWORD *)(v21 + 512) + 16), v29 = EVP_sha256(), HMAC_Init_ex(&ctx, v28, 16, v29, 0), v30))
      {
        *(_OWORD *)&ctx.key[4] = *(_OWORD *)*(_QWORD *)(v21 + 512);
        if (!pthread_rwlock_unlock((pthread_rwlock_t *)(v21 + 24)))
          goto LABEL_25;
      }
      else if (!pthread_rwlock_unlock((pthread_rwlock_t *)(v21 + 24)))
      {
        goto LABEL_72;
      }
    }
    abort();
  }
  v10 = (*(uint64_t (**)(uint64_t))v7)(v6);
  v11 = v10 + v9;
  if (__CFADD__(v10, v9))
  {
    v12 = 69;
    v13 = 540;
LABEL_6:
    ERR_put_error(16, 0, v12, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_session.cc", v13);
    v14 = 0;
    goto LABEL_80;
  }
  *(_QWORD *)&ctx.key[36] = 0;
  if (!CBB_reserve(a2, &ctx.key[36], v11))
  {
LABEL_22:
    v14 = 0;
    goto LABEL_80;
  }
  ctx.md = 0;
  if (!(*(unsigned int (**)(uint64_t, _QWORD, HMAC_CTX *, uint64_t, const unsigned __int8 *, unint64_t))(v7 + 8))(v6, *(_QWORD *)&ctx.key[36], &ctx, v11, v8, v9))
  {
    v12 = 276;
    v13 = 552;
    goto LABEL_6;
  }
  v17 = (_QWORD *)(a2 + 16);
  if (*(_BYTE *)(a2 + 8))
    v17 = (_QWORD *)*v17;
  v14 = 0;
  v18 = v17[1];
  v19 = (char *)ctx.md + v18;
  v20 = __CFADD__(v18, ctx.md);
  if (*(_QWORD *)a2 || v20)
    goto LABEL_80;
  if ((unint64_t)v19 > v17[2])
    goto LABEL_22;
  v17[1] = v19;
  v14 = 1;
LABEL_80:
  v15 = v14 != 0;
  if (v8)
  {
    v55 = *((_QWORD *)v8 - 1);
    v54 = (unsigned __int8 *)(v8 - 8);
    v56 = v55 + 8;
    if (v55 != -8)
      bzero(v54, v56);
    free(v54);
  }
  return v15;
}

BOOL bssl::ssl_session_is_context_valid(uint64_t a1, uint64_t a2)
{
  size_t v2;
  uint64_t v3;

  if (!a2)
    return 0;
  v2 = *(unsigned __int8 *)(a2 + 92);
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32);
  if ((_DWORD)v2 != *(unsigned __int8 *)(v3 + 88))
    return 0;
  if (*(_BYTE *)(a2 + 92))
    return memcmp((const void *)(a2 + 93), (const void *)(v3 + 89), v2) == 0;
  return 1;
}

BOOL bssl::ssl_session_is_time_valid(bssl *this, const ssl_st *a2, const ssl_session_st *a3)
{
  void (*v4)(_QWORD, timeval *, const ssl_session_st *);
  unint64_t v5;
  STACK *cipher_list_by_id;
  BOOL v7;
  unint64_t v8;
  unint64_t v10;
  STACK *v11;
  timeval v12;

  if (!a2)
    return 0;
  v4 = *(void (**)(_QWORD, timeval *, const ssl_session_st *))(*((_QWORD *)this + 13) + 696);
  if (v4)
  {
    v4(0, &v12, a3);
    v5 = v12.tv_sec & ~(v12.tv_sec >> 63);
    cipher_list_by_id = a2->cipher_list_by_id;
    v7 = v5 >= (unint64_t)cipher_list_by_id;
    v8 = v5 - (_QWORD)cipher_list_by_id;
    if (!v7)
      return 0;
  }
  else
  {
    gettimeofday(&v12, 0);
    v10 = v12.tv_sec & ~(v12.tv_sec >> 63);
    v11 = a2->cipher_list_by_id;
    v7 = v10 >= (unint64_t)v11;
    v8 = v10 - (_QWORD)v11;
    if (!v7)
      return 0;
  }
  return v8 < LODWORD(a2->cipher_list);
}

uint64_t bssl::ssl_session_is_resumable(_QWORD *a1, uint64_t a2)
{
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(_QWORD, timeval *);
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  _BOOL4 v16;
  unsigned int v17;
  timeval v18;

  if (!a2)
    return 0;
  v4 = *(unsigned __int8 *)(a2 + 92);
  v5 = *(_QWORD *)(a1[1] + 32);
  if ((_DWORD)v4 != *(unsigned __int8 *)(v5 + 88))
    return 0;
  v6 = *a1;
  if (*(_BYTE *)(a2 + 92))
  {
    if (memcmp((const void *)(a2 + 93), (const void *)(v5 + 89), v4))
      return 0;
  }
  if (((*(unsigned __int8 *)(v6 + 164) ^ (*(unsigned __int8 *)(a2 + 424) >> 4)) & 1) != 0)
    return 0;
  v7 = *(void (**)(_QWORD, timeval *))(*(_QWORD *)(v6 + 104) + 696);
  if (v7)
  {
    v7(0, &v18);
    v8 = v18.tv_sec & ~(v18.tv_sec >> 63);
    v9 = *(_QWORD *)(a2 + 192);
    v10 = v8 >= v9;
    v11 = v8 - v9;
    if (!v10)
      return 0;
  }
  else
  {
    gettimeofday(&v18, 0);
    v13 = v18.tv_sec & ~(v18.tv_sec >> 63);
    v14 = *(_QWORD *)(a2 + 192);
    v10 = v13 >= v14;
    v11 = v13 - v14;
    if (!v10)
      return 0;
  }
  if (v11 >= *(unsigned int *)(a2 + 184)
    || *(unsigned __int16 *)(v6 + 16) != *(unsigned __int16 *)(a2 + 4)
    || a1[192] != *(_QWORD *)(a2 + 200))
  {
    return 0;
  }
  v15 = *(_QWORD **)(a2 + 136);
  v16 = !v15 || *v15 == 0;
  v17 = *(unsigned __int8 *)(a2 + 424);
  if ((!v16 || (v17 & 2) != 0) && ((*(unsigned __int16 *)(a1[1] + 237) >> 5) & 1) != ((v17 >> 1) & 1))
    return 0;
  return (*(_QWORD *)(*a1 + 152) == 0) ^ ((v17 & 0x20) >> 5);
}

uint64_t bssl::ssl_get_prev_session(uint64_t *a1, ssl_session_st **a2, char *a3, _BYTE *a4, _QWORD *a5)
{
  char v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  timeval *v15;
  size_t v16;
  uint64_t v17;
  timeval *p_dst;
  unint64_t tv_sec_low;
  pthread_rwlock_t *v20;
  __darwin_time_t *v21;
  __darwin_time_t v22;
  unsigned int v23;
  unsigned int v24;
  char v25;
  uint64_t (*v26)(uint64_t, timeval *, size_t, int *);
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  char v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  char v34;
  pthread_rwlock_t *v35;
  ssl_session_st *tv_sec;
  unsigned int j;
  unsigned int v38;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v41;
  void (*v42)(_QWORD, timeval *);
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unsigned int i;
  unsigned int v50;
  void *v51;
  uint64_t v52;
  size_t v53;
  int v54;
  uint64_t v55;
  ssl_session_st *v56;
  ssl_session_st *v57;
  unsigned int k;
  unsigned int v59;
  uint64_t *v60;
  uint64_t v61;
  size_t v62;
  unsigned int m;
  unsigned int v64;
  uint64_t *v65;
  uint64_t v66;
  size_t v67;
  ssl_session_st *v69;
  char v70;
  ssl_session_st *v71;
  int v72;
  timeval __dst;

  v8 = 0;
  v71 = 0;
  v70 = 0;
  v9 = *a1;
  if ((*(_BYTE *)(*a1 + 129) & 0x40) != 0)
  {
LABEL_10:
    v15 = (timeval *)a5[6];
    v16 = a5[7];
    v71 = 0;
    if (v16 - 33 < 0xFFFFFFFFFFFFFFE0)
      goto LABEL_94;
    goto LABEL_11;
  }
  v10 = a5[13];
  if (!v10)
  {
LABEL_9:
    v8 = 0;
    goto LABEL_10;
  }
  v11 = (char *)a5[12];
  while (1)
  {
    if (v10 < 2)
      goto LABEL_9;
    if ((v10 & 0xFFFFFFFFFFFFFFFELL) == 2)
      goto LABEL_9;
    v12 = v10 - 4;
    v13 = __rev16(*((unsigned __int16 *)v11 + 1));
    if (v12 < v13)
      goto LABEL_9;
    v14 = v11 + 4;
    if (__rev16(*(unsigned __int16 *)v11) == 35)
      break;
    v11 = &v14[v13];
    v10 = v12 - v13;
    if (!v10)
      goto LABEL_9;
  }
  if (!v13)
  {
    v8 = 1;
    v15 = (timeval *)a5[6];
    v16 = a5[7];
    v71 = 0;
    if (v16 - 33 < 0xFFFFFFFFFFFFFFE0)
      goto LABEL_94;
LABEL_11:
    v17 = *(_QWORD *)(v9 + 112);
    if ((*(_BYTE *)(v17 + 293) & 1) == 0)
    {
      p_dst = v15;
      if (v16 <= 3)
      {
        LODWORD(__dst.tv_sec) = 0;
        p_dst = &__dst;
        memcpy(&__dst, v15, v16);
      }
      tv_sec_low = LODWORD(p_dst->tv_sec);
      v20 = (pthread_rwlock_t *)(v17 + 24);
      if (pthread_rwlock_rdlock((pthread_rwlock_t *)(v17 + 24)))
        goto LABEL_124;
      v21 = *(__darwin_time_t **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 112) + 256) + 8)
                                + 8 * (tv_sec_low % *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 112) + 256) + 16)));
      if (v21)
      {
        v22 = *v21;
        if (v16 == *(unsigned __int8 *)(*v21 + 59) && !memcmp(v15, (const void *)(v22 + 60), v16))
        {
LABEL_23:
          v23 = atomic_load((unsigned int *)v22);
          if (v23 != -1)
          {
            while (1)
            {
              v24 = __ldaxr((unsigned int *)v22);
              if (v24 == v23)
              {
                if (!__stlxr(v23 + 1, (unsigned int *)v22))
                {
                  v25 = 1;
                  goto LABEL_29;
                }
              }
              else
              {
                __clrex();
              }
              v25 = 0;
LABEL_29:
              if ((v25 & 1) == 0)
              {
                v23 = v24;
                if (v24 != -1)
                  continue;
              }
              break;
            }
          }
          if (pthread_rwlock_unlock(v20))
LABEL_124:
            abort();
LABEL_70:
          v42 = *(void (**)(_QWORD, timeval *))(*(_QWORD *)(v9 + 104) + 696);
          if (v42)
          {
            v42(0, &__dst);
            v43 = __dst.tv_sec & ~(__dst.tv_sec >> 63);
            v44 = *(_QWORD *)(v22 + 192);
            v45 = v43 >= v44;
            v46 = v43 - v44;
            if (!v45)
              goto LABEL_76;
          }
          else
          {
            gettimeofday(&__dst, 0);
            v47 = __dst.tv_sec & ~(__dst.tv_sec >> 63);
            v48 = *(_QWORD *)(v22 + 192);
            v45 = v47 >= v48;
            v46 = v47 - v48;
            if (!v45)
            {
LABEL_76:
              bssl::remove_session(*(bssl **)(v9 + 112), (ssl_ctx_st *)v22, (ssl_session_st *)1);
              for (i = atomic_load((unsigned int *)v22); i != -1; i = v50)
              {
                if (!i)
                  goto LABEL_124;
                v50 = __ldaxr((unsigned int *)v22);
                if (v50 == i)
                {
                  if (!__stlxr(i - 1, (unsigned int *)v22))
                  {
                    if (i == 1)
                    {
                      ssl_session_st::~ssl_session_st((ssl_session_st *)v22);
                      v52 = *(_QWORD *)(v22 - 8);
                      v51 = (void *)(v22 - 8);
                      v53 = v52 + 8;
                      if (v52 != -8)
                        bzero(v51, v53);
                      free(v51);
                    }
                    goto LABEL_94;
                  }
                }
                else
                {
                  __clrex();
                }
              }
              goto LABEL_94;
            }
          }
          if (v46 < *(unsigned int *)(v22 + 184))
            goto LABEL_95;
          goto LABEL_76;
        }
        while (1)
        {
          v21 = (__darwin_time_t *)v21[1];
          if (!v21)
            break;
          v22 = *v21;
          if (v16 == *(unsigned __int8 *)(*v21 + 59) && !memcmp(v15, (const void *)(v22 + 60), v16))
            goto LABEL_23;
        }
      }
      if (pthread_rwlock_unlock(v20))
        goto LABEL_124;
      v17 = *(_QWORD *)(v9 + 112);
    }
    v26 = *(uint64_t (**)(uint64_t, timeval *, size_t, int *))(v17 + 320);
    if (v26)
    {
      v72 = 1;
      v27 = (unsigned int *)v26(v9, v15, v16, &v72);
      v22 = (__darwin_time_t)v27;
      if (!v27)
        goto LABEL_95;
      if (v27 == (unsigned int *)&bssl::g_pending_session_magic)
      {
        v55 = 10;
        v71 = 0;
        return v55;
      }
      if (v72)
      {
        v28 = atomic_load(v27);
        if (v28 != -1)
        {
          while (1)
          {
            v29 = __ldaxr(v27);
            if (v29 == v28)
            {
              if (!__stlxr(v28 + 1, v27))
              {
                v30 = 1;
                goto LABEL_45;
              }
            }
            else
            {
              __clrex();
            }
            v30 = 0;
LABEL_45:
            if ((v30 & 1) == 0)
            {
              v28 = v29;
              if (v29 != -1)
                continue;
            }
            break;
          }
        }
      }
      v31 = *(_QWORD *)(v9 + 112);
      if ((*(_BYTE *)(v31 + 293) & 2) != 0)
        goto LABEL_70;
      v32 = atomic_load(v27);
      if (v32 == -1)
      {
LABEL_56:
        v35 = (pthread_rwlock_t *)(v31 + 24);
        if (pthread_rwlock_wrlock((pthread_rwlock_t *)(v31 + 24)))
          goto LABEL_124;
        __dst.tv_sec = v22;
        bssl::add_session_locked((uint64_t *)v31, &__dst.tv_sec);
        tv_sec = (ssl_session_st *)__dst.tv_sec;
        if (__dst.tv_sec)
        {
          for (j = atomic_load((unsigned int *)__dst.tv_sec); j != -1; j = v38)
          {
            if (!j)
              goto LABEL_124;
            v38 = __ldaxr((unsigned int *)tv_sec);
            if (v38 == j)
            {
              if (!__stlxr(j - 1, (unsigned int *)tv_sec))
              {
                if (j == 1)
                {
                  ssl_session_st::~ssl_session_st(tv_sec);
                  tlsext_tick_lifetime_hint = tv_sec[-1].tlsext_tick_lifetime_hint;
                  p_tlsext_tick_lifetime_hint = &tv_sec[-1].tlsext_tick_lifetime_hint;
                  v41 = tlsext_tick_lifetime_hint + 8;
                  if (tlsext_tick_lifetime_hint != -8)
                    bzero(p_tlsext_tick_lifetime_hint, v41);
                  free(p_tlsext_tick_lifetime_hint);
                }
                break;
              }
            }
            else
            {
              __clrex();
            }
          }
        }
        if (pthread_rwlock_unlock(v35))
          goto LABEL_124;
        goto LABEL_70;
      }
      while (1)
      {
        v33 = __ldaxr(v27);
        if (v33 == v32)
        {
          if (!__stlxr(v32 + 1, v27))
          {
            v34 = 1;
            goto LABEL_54;
          }
        }
        else
        {
          __clrex();
        }
        v34 = 0;
LABEL_54:
        if ((v34 & 1) == 0)
        {
          v32 = v33;
          if (v33 != -1)
            continue;
        }
        goto LABEL_56;
      }
    }
LABEL_94:
    v22 = 0;
LABEL_95:
    v71 = 0;
    v57 = *a2;
    *a2 = (ssl_session_st *)v22;
    if (!v57)
      goto LABEL_107;
    goto LABEL_96;
  }
  v54 = bssl::ssl_process_ticket(a1, (ssl_ctx_st *)&v71, &v70, v14, v13, a5[6], a5[7]);
  if (v54 != 1)
  {
    if (v54 == 3)
    {
      v55 = 0;
      v56 = v71;
      v71 = 0;
      if (!v56)
        return v55;
      goto LABEL_108;
    }
    v8 = 1;
    v69 = v71;
    v71 = 0;
    v57 = *a2;
    *a2 = v69;
    if (!v57)
    {
LABEL_107:
      *a3 = v8;
      *a4 = v70;
      v55 = 1;
      v56 = v71;
      v71 = 0;
      if (!v56)
        return v55;
      goto LABEL_108;
    }
LABEL_96:
    for (k = atomic_load((unsigned int *)v57); k != -1; k = v59)
    {
      if (!k)
        goto LABEL_124;
      v59 = __ldaxr((unsigned int *)v57);
      if (v59 == k)
      {
        if (!__stlxr(k - 1, (unsigned int *)v57))
        {
          if (k == 1)
          {
            ssl_session_st::~ssl_session_st(v57);
            v61 = v57[-1].tlsext_tick_lifetime_hint;
            v60 = &v57[-1].tlsext_tick_lifetime_hint;
            v62 = v61 + 8;
            if (v61 != -8)
              bzero(v60, v62);
            free(v60);
          }
          goto LABEL_107;
        }
      }
      else
      {
        __clrex();
      }
    }
    goto LABEL_107;
  }
  v55 = 11;
  v56 = v71;
  v71 = 0;
  if (!v56)
    return v55;
LABEL_108:
  for (m = atomic_load((unsigned int *)v56); m != -1; m = v64)
  {
    if (!m)
      goto LABEL_124;
    v64 = __ldaxr((unsigned int *)v56);
    if (v64 == m)
    {
      if (!__stlxr(m - 1, (unsigned int *)v56))
      {
        if (m == 1)
        {
          ssl_session_st::~ssl_session_st(v56);
          v66 = v56[-1].tlsext_tick_lifetime_hint;
          v65 = &v56[-1].tlsext_tick_lifetime_hint;
          v67 = v66 + 8;
          if (v66 != -8)
            bzero(v65, v67);
          free(v65);
        }
        return v55;
      }
    }
    else
    {
      __clrex();
    }
  }
  return v55;
}

void bssl::ssl_update_cache(bssl *this, ssl_st *a2)
{
  ssl_session_st *v2;
  __darwin_time_t v4;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  char v9;
  ssl_session_st *v10;
  unsigned int i;
  unsigned int v12;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v15;
  int v16;
  int v17;
  void (*v18)(_QWORD, timeval *);
  __darwin_time_t v19;
  uint64_t v20;
  int v21;
  int v22;
  unint64_t v23;
  unint64_t j;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  char v29;
  unsigned int k;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  size_t v34;
  ssl_session_st *v35;
  timeval v36;
  uint64_t v37;

  v2 = *(ssl_session_st **)(*((_QWORD *)this + 6) + 464);
  if ((v2[1].sid_ctx[28] & 4) != 0)
    return;
  v4 = *((_QWORD *)this + 14);
  if (!v2->master_key[39] && !v2->prev)
    return;
  v5 = (*((_BYTE *)this + 164) & 1) != 0 ? 2 : 1;
  v6 = *(_DWORD *)(v4 + 292);
  if ((v6 & v5) == 0)
    return;
  if ((v6 & 0x200) == 0 && (*((_BYTE *)this + 164) & 1) != 0)
  {
    v7 = atomic_load((unsigned int *)v2);
    if (v7 != -1)
    {
      while (1)
      {
        v8 = __ldaxr((unsigned int *)v2);
        if (v8 == v7)
        {
          if (!__stlxr(v7 + 1, (unsigned int *)v2))
          {
            v9 = 1;
            goto LABEL_16;
          }
        }
        else
        {
          __clrex();
        }
        v9 = 0;
LABEL_16:
        if ((v9 & 1) == 0)
        {
          v7 = v8;
          if (v8 != -1)
            continue;
        }
        break;
      }
    }
    if (pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 24)))
      goto LABEL_78;
    v35 = v2;
    bssl::add_session_locked((uint64_t *)v4, (uint64_t *)&v35);
    v10 = v35;
    if (v35)
    {
      for (i = atomic_load((unsigned int *)v35); i != -1; i = v12)
      {
        if (!i)
          goto LABEL_78;
        v12 = __ldaxr((unsigned int *)v10);
        if (v12 == i)
        {
          if (!__stlxr(i - 1, (unsigned int *)v10))
          {
            if (i == 1)
            {
              ssl_session_st::~ssl_session_st(v10);
              tlsext_tick_lifetime_hint = v10[-1].tlsext_tick_lifetime_hint;
              p_tlsext_tick_lifetime_hint = &v10[-1].tlsext_tick_lifetime_hint;
              v15 = tlsext_tick_lifetime_hint + 8;
              if (tlsext_tick_lifetime_hint != -8)
                bzero(p_tlsext_tick_lifetime_hint, v15);
              free(p_tlsext_tick_lifetime_hint);
            }
            break;
          }
        }
        else
        {
          __clrex();
        }
      }
    }
    if ((*(_BYTE *)(v4 + 292) & 0x80) != 0)
    {
LABEL_55:
      if (!pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 24)))
        goto LABEL_56;
LABEL_78:
      abort();
    }
    v16 = *(_DWORD *)(v4 + 288);
    if (v16 <= 253)
      v17 = v16 + 1;
    else
      v17 = 0;
    *(_DWORD *)(v4 + 288) = v17;
    if (pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 24)))
      goto LABEL_78;
    if (v16 >= 254)
    {
      v18 = *(void (**)(_QWORD, timeval *))(*((_QWORD *)this + 13) + 696);
      if (v18)
        v18(0, &v36);
      else
        gettimeofday(&v36, 0);
      v19 = v36.tv_sec & ~(v36.tv_sec >> 63);
      v20 = *(_QWORD *)(v4 + 256);
      v36.tv_sec = v4;
      v37 = v20;
      if (v20)
      {
        *(_QWORD *)&v36.tv_usec = v19;
        if (pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 24)))
          goto LABEL_78;
        v21 = *(_DWORD *)(v20 + 24);
        if (v21 == -1)
        {
          v22 = -1;
        }
        else
        {
          v22 = v21 + 1;
          *(_DWORD *)(v20 + 24) = v21 + 1;
        }
        v23 = *(_QWORD *)(v20 + 16);
        if (v23)
        {
          for (j = 0; j < v23; ++j)
          {
            v25 = *(_QWORD *)(*(_QWORD *)(v20 + 8) + 8 * j);
            if (v25)
            {
              do
              {
                v26 = *(_QWORD *)(v25 + 8);
                timeout_doall_arg(*(ssl_session_st **)v25, &v36.tv_sec);
                v25 = v26;
              }
              while (v26);
              v23 = *(_QWORD *)(v20 + 16);
            }
          }
          v22 = *(_DWORD *)(v20 + 24);
        }
        if (v22 != -1)
          *(_DWORD *)(v20 + 24) = v22 - 1;
        lh_maybe_resize(v20);
        goto LABEL_55;
      }
    }
  }
LABEL_56:
  if (*(_QWORD *)(v4 + 304))
  {
    v27 = atomic_load((unsigned int *)v2);
    if (v27 != -1)
    {
      while (1)
      {
        v28 = __ldaxr((unsigned int *)v2);
        if (v28 == v27)
        {
          if (!__stlxr(v27 + 1, (unsigned int *)v2))
          {
            v29 = 1;
            goto LABEL_63;
          }
        }
        else
        {
          __clrex();
        }
        v29 = 0;
LABEL_63:
        if ((v29 & 1) == 0)
        {
          v27 = v28;
          if (v28 != -1)
            continue;
        }
        break;
      }
    }
    if (!(*(unsigned int (**)(bssl *, ssl_session_st *))(v4 + 304))(this, v2))
    {
      for (k = atomic_load((unsigned int *)v2); k != -1; k = v31)
      {
        if (!k)
          goto LABEL_78;
        v31 = __ldaxr((unsigned int *)v2);
        if (v31 == k)
        {
          if (!__stlxr(k - 1, (unsigned int *)v2))
          {
            if (k == 1)
            {
              ssl_session_st::~ssl_session_st(v2);
              v33 = v2[-1].tlsext_tick_lifetime_hint;
              v32 = &v2[-1].tlsext_tick_lifetime_hint;
              v34 = v33 + 8;
              if (v33 != -8)
                bzero(v32, v34);
              free(v32);
            }
            return;
          }
        }
        else
        {
          __clrex();
        }
      }
    }
  }
}

void bssl::add_session_locked(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t **v14;
  uint64_t **v15;
  uint64_t **v16;
  _QWORD *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t **v20;
  uint64_t *v21;
  uint64_t **v22;
  uint64_t *v23;
  uint64_t *v24;

  v4 = *a2;
  v5 = a1[32];
  v6 = (*(uint64_t (**)(uint64_t))(v5 + 40))(*a2);
  v7 = (uint64_t **)(*(_QWORD *)(v5 + 8) + 8 * ((unint64_t)v6 % *(_QWORD *)(v5 + 16)));
  v8 = *v7;
  if (!*v7)
    goto LABEL_15;
  if ((*(unsigned int (**)(uint64_t, uint64_t))(v5 + 32))(*v8, v4))
  {
    while (1)
    {
      v9 = v8;
      v8 = (uint64_t *)v8[1];
      if (!v8)
        break;
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(v5 + 32))(*v8, v4))
      {
        v7 = (uint64_t **)(v9 + 1);
        goto LABEL_6;
      }
    }
    v7 = (uint64_t **)(v9 + 1);
    goto LABEL_15;
  }
LABEL_6:
  v10 = *v7;
  if (!*v7)
  {
LABEL_15:
    v17 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (!v17)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return;
    }
    *v17 = 24;
    v17[1] = v4;
    *((_DWORD *)v17 + 6) = v6;
    v17[2] = 0;
    *v7 = v17 + 1;
    ++*(_QWORD *)v5;
    lh_maybe_resize(v5);
    *a2 = 0;
    goto LABEL_17;
  }
  v11 = *v10;
  *v10 = v4;
  *a2 = v11;
  if (!v11)
    goto LABEL_17;
  if (v11 == v4)
    return;
  v12 = *(uint64_t **)(v11 + 224);
  if (!v12 || (v15 = *(uint64_t ***)(v11 + 216), v13 = v11 + 216, (v14 = v15) == 0))
  {
LABEL_17:
    v18 = *(uint64_t **)(v4 + 224);
    if (v18)
      goto LABEL_18;
    goto LABEL_28;
  }
  v16 = (uint64_t **)(a1 + 34);
  if (v12 == a1 + 35)
  {
    if (v14 != v16)
    {
      *v12 = (uint64_t)v14;
      goto LABEL_36;
    }
    *v14 = 0;
    *v12 = 0;
  }
  else
  {
    if (v14 != v16)
    {
      v12[27] = (uint64_t)v14;
      v14 = *(uint64_t ***)v13;
LABEL_36:
      v14[28] = v12;
      goto LABEL_39;
    }
    *v14 = v12;
    v12[27] = (uint64_t)v14;
  }
LABEL_39:
  *(_QWORD *)v13 = 0;
  *(_QWORD *)(v13 + 8) = 0;
  v18 = *(uint64_t **)(v4 + 224);
  if (v18)
  {
LABEL_18:
    v19 = v4 + 216;
    v20 = *(uint64_t ***)(v4 + 216);
    if (v20)
    {
      v21 = a1 + 35;
      v22 = (uint64_t **)(a1 + 34);
      if (v18 == a1 + 35)
      {
        if (v20 == v22)
        {
          *v22 = 0;
          a1[35] = 0;
        }
        else
        {
          *v21 = (uint64_t)v20;
          v20[28] = v21;
        }
      }
      else if (v20 == v22)
      {
        *v22 = v18;
        v18[27] = (uint64_t)v22;
      }
      else
      {
        v18[27] = (uint64_t)v20;
        *(_QWORD *)(*(_QWORD *)v19 + 224) = v18;
      }
      *(_QWORD *)v19 = 0;
      *(_QWORD *)(v4 + 224) = 0;
    }
  }
LABEL_28:
  v23 = (uint64_t *)a1[34];
  v24 = v23 + 27;
  if (!v23)
  {
    v24 = a1 + 35;
    v23 = a1 + 35;
  }
  *v24 = v4;
  a1[34] = v4;
  *(_QWORD *)(v4 + 216) = a1 + 34;
  *(_QWORD *)(v4 + 224) = v23;
  if (a1[33])
  {
    while (*(_QWORD *)a1[32] > (unint64_t)a1[33]
         && (bssl::remove_session((bssl *)a1, (ssl_ctx_st *)a1[35], 0) & 1) != 0)
      ;
  }
}

void SSL_CTX_flush_sessions(SSL_CTX *ctx, uint64_t tm)
{
  STACK *comp_methods;
  x509_store_st **p_cert_store;
  int comp;
  int v5;
  unint64_t v6;
  unint64_t i;
  char *v8;
  char *v9;
  uint64_t v10[3];

  comp_methods = ctx->comp_methods;
  v10[0] = (uint64_t)ctx;
  v10[2] = (uint64_t)comp_methods;
  if (!comp_methods)
    return;
  v10[1] = tm;
  p_cert_store = &ctx->cert_store;
  if (pthread_rwlock_wrlock((pthread_rwlock_t *)&ctx->cert_store))
LABEL_17:
    abort();
  comp = (int)comp_methods->comp;
  if (comp == -1)
  {
    v5 = -1;
    v6 = *(_QWORD *)&comp_methods->sorted;
    if (!v6)
      goto LABEL_13;
  }
  else
  {
    v5 = comp + 1;
    LODWORD(comp_methods->comp) = comp + 1;
    v6 = *(_QWORD *)&comp_methods->sorted;
    if (!v6)
      goto LABEL_13;
  }
  for (i = 0; i < v6; ++i)
  {
    v8 = comp_methods->data[i];
    if (v8)
    {
      do
      {
        v9 = (char *)*((_QWORD *)v8 + 1);
        timeout_doall_arg(*(ssl_session_st **)v8, v10);
        v8 = v9;
      }
      while (v9);
      v6 = *(_QWORD *)&comp_methods->sorted;
    }
  }
  v5 = (int)comp_methods->comp;
LABEL_13:
  if (v5 != -1)
    LODWORD(comp_methods->comp) = v5 - 1;
  lh_maybe_resize((uint64_t)comp_methods);
  if (pthread_rwlock_unlock((pthread_rwlock_t *)p_cert_store))
    goto LABEL_17;
}

void ssl_session_st::~ssl_session_st(ssl_session_st *this)
{
  sess_cert_st *sess_cert;
  char *v3;
  uint64_t v4;
  size_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  size_t v17;
  unsigned int *tlsext_hostname;
  ssl_session_st *next;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  size_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  unsigned int *v27;
  unint64_t v28;
  void *v29;
  uint64_t v30;
  size_t v31;
  unint64_t *v32;
  uint64_t v33;
  size_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  size_t v38;

  CRYPTO_free_ex_data((int)&bssl::g_ex_data_class, this, (CRYPTO_EX_DATA *)&this->cipher_id);
  (*((void (**)(ssl_session_st *))this->sess_cert + 8))(this);
  sess_cert = this[1].sess_cert;
  if (sess_cert)
  {
    v4 = *((_QWORD *)sess_cert - 1);
    v3 = (char *)sess_cert - 8;
    v5 = v4 + 8;
    if (v4 != -8)
      bzero(v3, v5);
    free(v3);
  }
  this[1].sess_cert = 0;
  this[1].peer = 0;
  v6 = *(_QWORD *)&this[1].sid_ctx[12];
  if (v6)
  {
    v8 = *(_QWORD *)(v6 - 8);
    v7 = (void *)(v6 - 8);
    v9 = v8 + 8;
    if (v8 != -8)
      bzero(v7, v9);
    free(v7);
  }
  *(_QWORD *)&this[1].sid_ctx[12] = 0;
  *(_QWORD *)&this[1].sid_ctx[20] = 0;
  v10 = *(_QWORD *)&this[1].sid_ctx_length;
  if (v10)
  {
    v12 = *(_QWORD *)(v10 - 8);
    v11 = (void *)(v10 - 8);
    v13 = v12 + 8;
    if (v12 != -8)
      bzero(v11, v13);
    free(v11);
  }
  *(_QWORD *)&this[1].sid_ctx_length = 0;
  *(_QWORD *)&this[1].sid_ctx[4] = 0;
  v14 = *(_QWORD *)&this[1].session_id[16];
  if (v14)
  {
    v16 = *(_QWORD *)(v14 - 8);
    v15 = (void *)(v14 - 8);
    v17 = v16 + 8;
    if (v16 != -8)
      bzero(v15, v17);
    free(v15);
  }
  *(_QWORD *)&this[1].session_id[16] = 0;
  *(_QWORD *)&this[1].session_id[24] = 0;
  tlsext_hostname = (unsigned int *)this->tlsext_hostname;
  this->tlsext_hostname = 0;
  if (tlsext_hostname)
    CRYPTO_BUFFER_free(tlsext_hostname);
  next = this->next;
  this->next = 0;
  if (next)
    CRYPTO_BUFFER_free((unsigned int *)next);
  v20 = *(_QWORD *)&this->ex_data.dummy;
  if (v20)
  {
    v22 = *(_QWORD *)(v20 - 8);
    v21 = (void *)(v20 - 8);
    v23 = v22 + 8;
    if (v22 != -8)
      bzero(v21, v23);
    free(v21);
  }
  *(_QWORD *)&this->ex_data.dummy = 0;
  this->prev = 0;
  v24 = *(unint64_t **)&this->sid_ctx[28];
  *(_QWORD *)&this->sid_ctx[28] = 0;
  if (v24)
  {
    v25 = *v24;
    if (*v24)
    {
      v26 = 0;
      do
      {
        v27 = *(unsigned int **)(v24[1] + 8 * v26);
        if (v27)
        {
          CRYPTO_BUFFER_free(v27);
          v25 = *v24;
        }
        ++v26;
      }
      while (v26 < v25);
    }
    v28 = v24[1];
    if (v28)
    {
      v30 = *(_QWORD *)(v28 - 8);
      v29 = (void *)(v28 - 8);
      v31 = v30 + 8;
      if (v30 != -8)
        bzero(v29, v31);
      free(v29);
    }
    v33 = *(v24 - 1);
    v32 = v24 - 1;
    v34 = v33 + 8;
    if (v33 != -8)
      bzero(v32, v34);
    free(v32);
  }
  v35 = *(_QWORD *)&this->sid_ctx[20];
  *(_QWORD *)&this->sid_ctx[20] = 0;
  if (v35)
  {
    v37 = *(_QWORD *)(v35 - 8);
    v36 = (void *)(v35 - 8);
    v38 = v37 + 8;
    if (v37 != -8)
      bzero(v36, v38);
    free(v36);
  }
}

void SSL_SESSION_free(SSL_SESSION *ses)
{
  unsigned int i;
  unsigned int v3;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v6;

  if (ses)
  {
    for (i = atomic_load((unsigned int *)ses); i != -1; i = v3)
    {
      if (!i)
        abort();
      v3 = __ldaxr((unsigned int *)ses);
      if (v3 == i)
      {
        if (!__stlxr(i - 1, (unsigned int *)ses))
        {
          if (i == 1)
          {
            ssl_session_st::~ssl_session_st(ses);
            tlsext_tick_lifetime_hint = ses[-1].tlsext_tick_lifetime_hint;
            p_tlsext_tick_lifetime_hint = &ses[-1].tlsext_tick_lifetime_hint;
            v6 = tlsext_tick_lifetime_hint + 8;
            if (tlsext_tick_lifetime_hint != -8)
              bzero(p_tlsext_tick_lifetime_hint, v6);
            free(p_tlsext_tick_lifetime_hint);
          }
          return;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
}

uint64_t bssl::remove_session(bssl *this, ssl_ctx_st *a2, ssl_session_st *a3)
{
  int v4;
  uint64_t v6;
  ssl_ctx_st ***v7;
  ssl_ctx_st **v8;
  ssl_ctx_st **v9;
  ssl_ctx_st **v10;
  ssl_ctx_st *v11;
  ssl_session_st *v12;
  uint64_t v13;
  ssl_session_st **key_arg;
  ssl_session_st *v15;
  ssl_session_st **v16;
  ssl_session_st **v17;
  uint64_t v18;
  size_t v19;
  EVP_MD *rsa_md5;
  int *p_dummy;
  EVP_MD **v22;
  EVP_MD **v23;
  void (*v25)(bssl *, ssl_session_st *);
  unsigned int i;
  unsigned int v27;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v30;

  if (!a2 || !BYTE3(a2->session_cache_tail))
    return 0;
  v4 = (int)a3;
  if ((_DWORD)a3 && pthread_rwlock_wrlock((pthread_rwlock_t *)((char *)this + 24)))
LABEL_55:
    abort();
  v6 = *((_QWORD *)this + 32);
  v7 = (ssl_ctx_st ***)(*(_QWORD *)(v6 + 8)
                      + 8
                      * ((unint64_t)(*(unsigned int (**)(ssl_ctx_st *))(v6 + 40))(a2)
                       % *(_QWORD *)(v6 + 16)));
  v8 = *v7;
  if (!*v7)
    goto LABEL_13;
  if ((*(unsigned int (**)(ssl_ctx_st *, ssl_ctx_st *))(v6 + 32))(*v8, a2))
  {
    while (1)
    {
      v9 = v8;
      v8 = (ssl_ctx_st **)v8[1];
      if (!v8)
        goto LABEL_13;
      if (!(*(unsigned int (**)(ssl_ctx_st *, ssl_ctx_st *))(v6 + 32))(*v8, a2))
      {
        v7 = (ssl_ctx_st ***)(v9 + 1);
        break;
      }
    }
  }
  v10 = *v7;
  if (!*v7)
  {
LABEL_13:
    v11 = 0;
    v12 = 0;
    goto LABEL_36;
  }
  v11 = *v10;
  v12 = (ssl_session_st *)*v10;
  if (*v10 == a2)
  {
    v13 = *((_QWORD *)this + 32);
    key_arg = (ssl_session_st **)(*(_QWORD *)(v13 + 8)
                                + 8
                                * ((unint64_t)(*(unsigned int (**)(ssl_ctx_st *))(v13 + 40))(a2)
                                 % *(_QWORD *)(v13 + 16)));
    v12 = *key_arg;
    if (*key_arg)
    {
      if ((*(unsigned int (**)(_QWORD, ssl_ctx_st *))(v13 + 32))(*(_QWORD *)&v12->ssl_version, a2))
      {
        while (1)
        {
          v15 = v12;
          v12 = *(ssl_session_st **)v12->key_arg;
          if (!v12)
            break;
          if (!(*(unsigned int (**)(_QWORD, ssl_ctx_st *))(v13 + 32))(*(_QWORD *)&v12->ssl_version, a2))
          {
            key_arg = (ssl_session_st **)v15->key_arg;
            goto LABEL_19;
          }
        }
      }
      else
      {
LABEL_19:
        v16 = (ssl_session_st **)*key_arg;
        if (!*key_arg)
        {
          v12 = 0;
          rsa_md5 = (EVP_MD *)a2->rsa_md5;
          if (!rsa_md5)
            goto LABEL_36;
          goto LABEL_24;
        }
        *key_arg = v16[1];
        v12 = *v16;
        v18 = (uint64_t)*(v16 - 1);
        v17 = v16 - 1;
        v19 = v18 + 8;
        if (v18 != -8)
          bzero(v17, v19);
        free(v17);
        --*(_QWORD *)v13;
        lh_maybe_resize(v13);
      }
    }
    rsa_md5 = (EVP_MD *)a2->rsa_md5;
    if (!rsa_md5)
      goto LABEL_36;
LABEL_24:
    p_dummy = &a2->ex_data.dummy;
    v22 = *(EVP_MD ***)&a2->ex_data.dummy;
    if (!v22)
      goto LABEL_36;
    v23 = (EVP_MD **)((char *)this + 272);
    if (rsa_md5 == (EVP_MD *)((char *)this + 280))
    {
      if (v22 == v23)
      {
        *v22 = 0;
        *(_QWORD *)&rsa_md5->type = 0;
        goto LABEL_35;
      }
      *(_QWORD *)&rsa_md5->type = v22;
    }
    else
    {
      if (v22 == v23)
      {
        *v22 = rsa_md5;
        *(_QWORD *)&rsa_md5[1].ctx_size = v22;
        goto LABEL_35;
      }
      *(_QWORD *)&rsa_md5[1].ctx_size = v22;
      v22 = *(EVP_MD ***)p_dummy;
    }
    v22[28] = rsa_md5;
LABEL_35:
    *(_QWORD *)p_dummy = 0;
    a2->rsa_md5 = 0;
  }
LABEL_36:
  if (v4 && pthread_rwlock_unlock((pthread_rwlock_t *)((char *)this + 24)))
    goto LABEL_55;
  if (v11 != a2)
    return 0;
  v25 = (void (*)(bssl *, ssl_session_st *))*((_QWORD *)this + 39);
  if (v25)
    v25(this, v12);
  if (v12)
  {
    for (i = atomic_load((unsigned int *)v12); i != -1; i = v27)
    {
      if (!i)
        goto LABEL_55;
      v27 = __ldaxr((unsigned int *)v12);
      if (v27 == i)
      {
        if (!__stlxr(i - 1, (unsigned int *)v12))
        {
          if (i == 1)
          {
            ssl_session_st::~ssl_session_st(v12);
            tlsext_tick_lifetime_hint = v12[-1].tlsext_tick_lifetime_hint;
            p_tlsext_tick_lifetime_hint = &v12[-1].tlsext_tick_lifetime_hint;
            v30 = tlsext_tick_lifetime_hint + 8;
            if (tlsext_tick_lifetime_hint != -8)
              bzero(p_tlsext_tick_lifetime_hint, v30);
            free(p_tlsext_tick_lifetime_hint);
          }
          return 1;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  return 1;
}

int SSL_set_session(SSL *to, SSL_SESSION *session)
{
  int (__cdecl *handshake_func)(SSL *);
  uint64_t v3;
  SSL_SESSION *init_msg;
  unsigned int v5;
  unsigned int v6;
  unsigned int i;
  unsigned int v8;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v12;

  handshake_func = to->handshake_func;
  if ((*((_WORD *)handshake_func + 110) & 0x20) != 0
    || (v3 = *((_QWORD *)handshake_func + 35)) == 0
    || *(_DWORD *)(v3 + 20))
  {
LABEL_26:
    abort();
  }
  init_msg = (SSL_SESSION *)to->init_msg;
  if (init_msg != session)
  {
    if (session)
    {
      v5 = atomic_load((unsigned int *)session);
      if (v5 != -1)
      {
        do
        {
          v6 = __ldaxr((unsigned int *)session);
          if (v6 == v5)
          {
            if (!__stlxr(v5 + 1, (unsigned int *)session))
              break;
          }
          else
          {
            __clrex();
          }
          v5 = v6;
        }
        while (v6 != -1);
      }
      init_msg = (SSL_SESSION *)to->init_msg;
    }
    to->init_msg = session;
    if (init_msg)
    {
      for (i = atomic_load((unsigned int *)init_msg); i != -1; i = v8)
      {
        if (!i)
          goto LABEL_26;
        v8 = __ldaxr((unsigned int *)init_msg);
        if (v8 == i)
        {
          if (!__stlxr(i - 1, (unsigned int *)init_msg))
          {
            if (i != 1)
              return 1;
            ssl_session_st::~ssl_session_st(init_msg);
            tlsext_tick_lifetime_hint = init_msg[-1].tlsext_tick_lifetime_hint;
            p_tlsext_tick_lifetime_hint = &init_msg[-1].tlsext_tick_lifetime_hint;
            v12 = tlsext_tick_lifetime_hint + 8;
            if (tlsext_tick_lifetime_hint != -8)
              bzero(p_tlsext_tick_lifetime_hint, v12);
            free(p_tlsext_tick_lifetime_hint);
            return 1;
          }
        }
        else
        {
          __clrex();
        }
      }
    }
  }
  return 1;
}

void timeout_doall_arg(ssl_session_st *a1, uint64_t *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t time_low;
  BOOL v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  STACK *sk;
  STACK **p_ciphers;
  STACK *ciphers;
  STACK *v21;
  void (*v22)(void);
  unsigned int i;
  unsigned int v24;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v27;

  v4 = a2[1];
  if (v4)
  {
    v5 = *(_QWORD *)&a1->compress_meth;
    time_low = LODWORD(a1->time);
    v7 = __CFADD__(v5, time_low);
    v8 = v5 + time_low;
    if (!v7 && v4 <= v8)
      return;
  }
  v9 = a2[2];
  v10 = (_QWORD *)(*(_QWORD *)(v9 + 8)
                 + 8
                 * ((unint64_t)(*(unsigned int (**)(ssl_session_st *))(v9 + 40))(a1)
                  % *(_QWORD *)(v9 + 16)));
  v11 = (_QWORD *)*v10;
  if (*v10)
  {
    if ((*(unsigned int (**)(_QWORD, ssl_session_st *))(v9 + 32))(*v11, a1))
    {
      while (1)
      {
        v12 = v11;
        v11 = (_QWORD *)v11[1];
        if (!v11)
          break;
        if (!(*(unsigned int (**)(_QWORD, ssl_session_st *))(v9 + 32))(*v11, a1))
        {
          v10 = v12 + 1;
          goto LABEL_9;
        }
      }
    }
    else
    {
LABEL_9:
      v13 = (_QWORD *)*v10;
      if (*v10)
      {
        v15 = *(v13 - 1);
        v14 = v13 - 1;
        *v10 = v14[2];
        v16 = v15 + 8;
        if (v15 != -8)
          bzero(v14, v16);
        free(v14);
        --*(_QWORD *)v9;
        lh_maybe_resize(v9);
      }
    }
  }
  v17 = *a2;
  sk = a1->ex_data.sk;
  if (sk)
  {
    p_ciphers = &a1->ciphers;
    ciphers = a1->ciphers;
    if (ciphers)
    {
      v21 = (STACK *)(v17 + 272);
      if (sk == (STACK *)(v17 + 280))
      {
        if (ciphers == v21)
        {
          *(_QWORD *)&ciphers->num = 0;
          *(_QWORD *)&sk->num = 0;
          goto LABEL_23;
        }
        *(_QWORD *)&sk->num = ciphers;
      }
      else
      {
        if (ciphers == v21)
        {
          *(_QWORD *)&ciphers->num = sk;
          sk[6].comp = (int (__cdecl *)(const char *const *, const char *const *))ciphers;
          goto LABEL_23;
        }
        sk[6].comp = (int (__cdecl *)(const char *const *, const char *const *))ciphers;
        ciphers = *p_ciphers;
      }
      *(_QWORD *)&ciphers[7].num = sk;
LABEL_23:
      *p_ciphers = 0;
      a1->ex_data.sk = 0;
      v17 = *a2;
    }
  }
  v22 = *(void (**)(void))(v17 + 312);
  if (v22)
    v22();
  for (i = atomic_load((unsigned int *)a1); i != -1; i = v24)
  {
    if (!i)
      abort();
    v24 = __ldaxr((unsigned int *)a1);
    if (v24 == i)
    {
      if (!__stlxr(i - 1, (unsigned int *)a1))
      {
        if (i == 1)
        {
          ssl_session_st::~ssl_session_st(a1);
          tlsext_tick_lifetime_hint = a1[-1].tlsext_tick_lifetime_hint;
          p_tlsext_tick_lifetime_hint = &a1[-1].tlsext_tick_lifetime_hint;
          v27 = tlsext_tick_lifetime_hint + 8;
          if (tlsext_tick_lifetime_hint != -8)
            bzero(p_tlsext_tick_lifetime_hint, v27);
          free(p_tlsext_tick_lifetime_hint);
        }
        return;
      }
    }
    else
    {
      __clrex();
    }
  }
}

const char *__cdecl SSL_state_string_long(const SSL *s)
{
  uint64_t v1;
  const char *result;
  uint64_t v3;
  char **v4;

  v1 = *((_QWORD *)s->handshake_func + 35);
  if (!v1)
    return "SSL negotiation finished successfully";
  if ((BYTE4(s->msg_callback_arg) & 1) != 0)
  {
    result = "TLS server start_accept";
    switch(*(_DWORD *)(v1 + 20))
    {
      case 0:
        return result;
      case 1:
        result = "TLS server read_client_hello";
        break;
      case 2:
        result = "TLS server read_client_hello_after_ech";
        break;
      case 3:
        result = "TLS server cert_callback";
        break;
      case 4:
        v3 = *(int *)(v1 + 24);
        if (v3 >= 0x11)
        {
          result = "TLS 1.3 server unknown";
        }
        else
        {
          v4 = off_24C0D2438;
LABEL_27:
          result = v4[v3];
        }
        break;
      case 5:
        result = "TLS server select_parameters";
        break;
      case 6:
        result = "TLS server send_server_hello";
        break;
      case 7:
        result = "TLS server send_server_certificate";
        break;
      case 8:
        result = "TLS server send_server_key_exchange";
        break;
      case 9:
        result = "TLS server send_server_hello_done";
        break;
      case 0xA:
        result = "TLS server read_client_certificate";
        break;
      case 0xB:
        result = "TLS server verify_client_certificate";
        break;
      case 0xC:
        result = "TLS server read_client_key_exchange";
        break;
      case 0xD:
        result = "TLS server read_client_certificate_verify";
        break;
      case 0xE:
        result = "TLS server read_change_cipher_spec";
        break;
      case 0xF:
        result = "TLS server process_change_cipher_spec";
        break;
      case 0x10:
        result = "TLS server read_next_proto";
        break;
      case 0x11:
        result = "TLS server read_channel_id";
        break;
      case 0x12:
        result = "TLS server read_client_finished";
        break;
      case 0x13:
        result = "TLS server send_server_finished";
        break;
      case 0x14:
        result = "TLS server finish_server_handshake";
        break;
      case 0x15:
        result = "TLS server done";
        break;
      default:
        result = "TLS server unknown";
        break;
    }
  }
  else
  {
    result = "TLS client start_connect";
    switch(*(_DWORD *)(v1 + 20))
    {
      case 0:
        return result;
      case 1:
        result = "TLS client enter_early_data";
        break;
      case 2:
        result = "TLS client early_reverify_server_certificate";
        break;
      case 3:
        result = "TLS client read_hello_verify_request";
        break;
      case 4:
        result = "TLS client read_server_hello";
        break;
      case 5:
        v3 = *(int *)(v1 + 24);
        if (v3 < 0xF)
        {
          v4 = off_24C0D24C0;
          goto LABEL_27;
        }
        result = "TLS 1.3 client unknown";
        break;
      case 6:
        result = "TLS client read_server_certificate";
        break;
      case 7:
        result = "TLS client read_certificate_status";
        break;
      case 8:
        result = "TLS client verify_server_certificate";
        break;
      case 9:
        result = "TLS client reverify_server_certificate";
        break;
      case 0xA:
        result = "TLS client read_server_key_exchange";
        break;
      case 0xB:
        result = "TLS client read_certificate_request";
        break;
      case 0xC:
        result = "TLS client read_server_hello_done";
        break;
      case 0xD:
        result = "TLS client send_client_certificate";
        break;
      case 0xE:
        result = "TLS client send_client_key_exchange";
        break;
      case 0xF:
        result = "TLS client send_client_certificate_verify";
        break;
      case 0x10:
        result = "TLS client send_client_finished";
        break;
      case 0x11:
        result = "TLS client finish_flight";
        break;
      case 0x12:
        result = "TLS client read_session_ticket";
        break;
      case 0x13:
        result = "TLS client process_change_cipher_spec";
        break;
      case 0x14:
        result = "TLS client read_server_finished";
        break;
      case 0x15:
        result = "TLS client finish_client_handshake";
        break;
      case 0x16:
        result = "TLS client done";
        break;
      default:
        result = "TLS client unknown";
        break;
    }
  }
  return result;
}

const char *__cdecl SSL_alert_desc_string_long(int value)
{
  int v1;
  const char *result;

  v1 = value;
  result = "close notify";
  switch(v1)
  {
    case 0:
      return result;
    case 10:
      result = "unexpected_message";
      break;
    case 20:
      result = "bad record mac";
      break;
    case 21:
      result = "decryption failed";
      break;
    case 22:
      result = "record overflow";
      break;
    case 30:
      result = "decompression failure";
      break;
    case 40:
      result = "handshake failure";
      break;
    case 41:
      result = "no certificate";
      break;
    case 42:
      result = "bad certificate";
      break;
    case 43:
      result = "unsupported certificate";
      break;
    case 44:
      result = "certificate revoked";
      break;
    case 45:
      result = "certificate expired";
      break;
    case 46:
      result = "certificate unknown";
      break;
    case 47:
      result = "illegal parameter";
      break;
    case 48:
      result = "unknown CA";
      break;
    case 49:
      result = "access denied";
      break;
    case 50:
      result = "decode error";
      break;
    case 51:
      result = "decrypt error";
      break;
    case 60:
      result = "export restriction";
      break;
    case 70:
      result = "protocol version";
      break;
    case 71:
      result = "insufficient security";
      break;
    case 80:
      result = "internal error";
      break;
    case 86:
      result = "inappropriate fallback";
      break;
    case 90:
      result = "user canceled";
      break;
    case 100:
      result = "no renegotiation";
      break;
    case 109:
      result = "missing extension";
      break;
    case 110:
      result = "unsupported extension";
      break;
    case 111:
      result = "certificate unobtainable";
      break;
    case 112:
      result = "unrecognized name";
      break;
    case 113:
      result = "bad certificate status response";
      break;
    case 114:
      result = "bad certificate hash value";
      break;
    case 115:
      result = "unknown PSK identity";
      break;
    case 116:
      result = "certificate required";
      break;
    case 120:
      result = "no application protocol";
      break;
    case 121:
      result = "ECH required";
      break;
    default:
      result = "unknown";
      break;
  }
  return result;
}

void bssl::SSLTranscript::~SSLTranscript(bssl::SSLTranscript *this)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  size_t v5;
  void (**v6)(_QWORD);
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;
  void *v12;
  uint64_t v13;
  size_t v14;

  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    v4 = *(_QWORD *)(v2 - 8);
    v3 = (void *)(v2 - 8);
    v5 = v4 + 8;
    if (v4 != -8)
      bzero(v3, v5);
    free(v3);
  }
  v6 = (void (**)(_QWORD))*((_QWORD *)this + 4);
  if (v6)
    (*v6)(*((_QWORD *)this + 3));
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  v7 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v7)
  {
    v8 = *(_QWORD *)(v7 + 8);
    if (v8)
    {
      v10 = *(_QWORD *)(v8 - 8);
      v9 = (void *)(v8 - 8);
      v11 = v10 + 8;
      if (v10 != -8)
        bzero(v9, v11);
      free(v9);
    }
    v13 = *(_QWORD *)(v7 - 8);
    v12 = (void *)(v7 - 8);
    v14 = v13 + 8;
    if (v13 != -8)
      bzero(v12, v14);
    free(v12);
  }
}

BOOL bssl::SSLTranscript::Init(bssl::SSLTranscript *this)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  size_t v8;
  _QWORD *v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;
  void (**v16)(_QWORD);

  v2 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (v2)
  {
    *v2 = 24;
    v2[1] = 0;
    v3 = v2 + 1;
    v2[2] = 0;
    v2[3] = 0;
    v4 = *(_QWORD **)this;
    *(_QWORD *)this = v2 + 1;
    if (!v4)
      goto LABEL_12;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v3 = 0;
    v4 = *(_QWORD **)this;
    *(_QWORD *)this = 0;
    if (!v4)
      goto LABEL_12;
  }
  v5 = v4[1];
  if (v5)
  {
    v7 = *(_QWORD *)(v5 - 8);
    v6 = (void *)(v5 - 8);
    v8 = v7 + 8;
    if (v7 != -8)
      bzero(v6, v8);
    free(v6);
  }
  v10 = *(v4 - 1);
  v9 = v4 - 1;
  v11 = v10 + 8;
  if (v10 != -8)
    bzero(v9, v11);
  free(v9);
  v3 = *(_QWORD **)this;
LABEL_12:
  if (v3)
  {
    v12 = *((_QWORD *)this + 2);
    if (v12)
    {
      v14 = *(_QWORD *)(v12 - 8);
      v13 = (void *)(v12 - 8);
      v15 = v14 + 8;
      if (v14 != -8)
        bzero(v13, v15);
      free(v13);
    }
    v16 = (void (**)(_QWORD))*((_QWORD *)this + 4);
    if (v16)
      (*v16)(*((_QWORD *)this + 3));
    *(_OWORD *)((char *)this + 8) = 0u;
    *(_OWORD *)((char *)this + 24) = 0u;
  }
  return v3 != 0;
}

uint64_t bssl::SSLTranscript::InitHash(uint64_t **this, bssl *a2, const ssl_cipher_st *a3)
{
  uint64_t *handshake_digest;
  uint64_t *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  size_t v12;

  handshake_digest = bssl::ssl_get_handshake_digest(a2, (uint64_t)a3, a3);
  if (this[1] == handshake_digest)
    return 1;
  v5 = handshake_digest;
  v6 = *((unsigned int *)handshake_digest + 11);
  v7 = malloc_type_malloc(v6 + 8, 0x30772F57uLL);
  if (v7)
  {
    *v7 = v6;
    v8 = v7 + 1;
    v9 = this[2];
    if (v9)
    {
      v11 = *(v9 - 1);
      v10 = v9 - 1;
      v12 = v11 + 8;
      if (v11 != -8)
        bzero(v10, v12);
      free(v10);
    }
    this[1] = v5;
    this[2] = v8;
    ((void (*)(char *))v5[2])((char *)this + 8);
    ((void (*)(char *, uint64_t, uint64_t))this[1][3])((char *)this + 8, (*this)[1], **this);
    return 1;
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  return 0;
}

void bssl::SSLTranscript::FreeBuffer(bssl::SSLTranscript *this)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;
  uint64_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  size_t v8;

  v1 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v1)
  {
    v2 = *(_QWORD *)(v1 + 8);
    if (v2)
    {
      v4 = *(_QWORD *)(v2 - 8);
      v3 = (void *)(v2 - 8);
      v5 = v4 + 8;
      if (v4 != -8)
        bzero(v3, v5);
      free(v3);
    }
    v7 = *(_QWORD *)(v1 - 8);
    v6 = (void *)(v1 - 8);
    v8 = v7 + 8;
    if (v7 != -8)
      bzero(v6, v8);
    free(v6);
  }
}

uint64_t bssl::SSLTranscript::UpdateForHelloRetryRequest(bssl::SSLTranscript *this)
{
  char *v2;
  size_t pkey_type;
  size_t final_high;
  uint64_t v5;
  char *v6;
  uint64_t result;
  uint64_t v8;
  char *v9;
  EVP_MD_CTX v10;
  _BYTE __src[64];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)this)
    **(_QWORD **)this = 0;
  memset(&v10, 0, sizeof(v10));
  v2 = (char *)this + 8;
  if (EVP_MD_CTX_copy_ex(&v10, (const EVP_MD_CTX *)((char *)this + 8)))
  {
    ((void (*)(EVP_MD_CTX *, _BYTE *))v10.digest->update)(&v10, __src);
    pkey_type = v10.digest->pkey_type;
    final_high = HIDWORD(v10.digest->final);
    if ((_DWORD)final_high)
      bzero(v10.engine, final_high);
    if (v10.engine)
    {
      v6 = (char *)v10.engine - 8;
      v5 = *((_QWORD *)v10.engine - 1);
      if (v5 != -8)
        bzero(v6, v5 + 8);
      free(v6);
    }
    if (v10.md_data)
      (*(void (**)(unint64_t))v10.md_data)(v10.flags);
    LOWORD(v10.digest) = 254;
    BYTE2(v10.digest) = 0;
    BYTE3(v10.digest) = pkey_type;
    (*(void (**)(char *))(*((_QWORD *)this + 1) + 16))((char *)this + 8);
    if (!*(_QWORD *)this || (result = BUF_MEM_append(*(unint64_t **)this, &v10, 4uLL), (_DWORD)result))
    {
      if (*(_QWORD *)v2)
        (*(void (**)(char *, EVP_MD_CTX *, uint64_t))(*(_QWORD *)v2 + 24))((char *)this + 8, &v10, 4);
      if (!*(_QWORD *)this || (result = BUF_MEM_append(*(unint64_t **)this, __src, pkey_type), (_DWORD)result))
      {
        if (*(_QWORD *)v2)
          (*(void (**)(char *, _BYTE *, size_t))(*(_QWORD *)v2 + 24))((char *)this + 8, __src, pkey_type);
        return 1;
      }
    }
  }
  else
  {
    if (v10.engine)
    {
      v9 = (char *)v10.engine - 8;
      v8 = *((_QWORD *)v10.engine - 1);
      if (v8 != -8)
        bzero(v9, v8 + 8);
      free(v9);
    }
    if (v10.md_data)
      (*(void (**)(unint64_t))v10.md_data)(v10.flags);
    return 0;
  }
  return result;
}

BOOL bssl::SSLTranscript::GetHash(bssl::SSLTranscript *this, unsigned __int8 *a2, unint64_t *a3)
{
  int v5;
  unint64_t pkey_type;
  size_t final_high;
  uint64_t v8;
  char *v9;
  EVP_MD_CTX v11;

  memset(&v11, 0, sizeof(v11));
  v5 = EVP_MD_CTX_copy_ex(&v11, (const EVP_MD_CTX *)((char *)this + 8));
  if (v5)
  {
    ((void (*)(EVP_MD_CTX *, unsigned __int8 *))v11.digest->update)(&v11, a2);
    pkey_type = v11.digest->pkey_type;
    final_high = HIDWORD(v11.digest->final);
    if ((_DWORD)final_high)
      bzero(v11.engine, final_high);
    *a3 = pkey_type;
  }
  if (v11.engine)
  {
    v9 = (char *)v11.engine - 8;
    v8 = *((_QWORD *)v11.engine - 1);
    if (v8 != -8)
      bzero(v9, v8 + 8);
    free(v9);
  }
  if (v11.md_data)
    (*(void (**)(unint64_t))v11.md_data)(v11.flags);
  return v5 != 0;
}

uint64_t bssl::SSLTranscript::Update(uint64_t a1, void *__src, size_t __n)
{
  unint64_t *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v6 = *(unint64_t **)a1;
  if (!v6 || (result = BUF_MEM_append(v6, __src, __n), (_DWORD)result))
  {
    v10 = *(_QWORD *)(a1 + 8);
    v9 = a1 + 8;
    v8 = v10;
    if (v10)
      (*(void (**)(uint64_t, void *, size_t))(v8 + 24))(v9, __src, __n);
    return 1;
  }
  return result;
}

BOOL bssl::SSLTranscript::CopyToHashContext(bssl::SSLTranscript *this, env_md_ctx_st *out, const env_md_st *a3)
{
  _DWORD *v6;
  uint64_t final_high;
  _QWORD *v9;
  ENGINE *v10;
  ENGINE *engine;
  char *v12;
  uint64_t v13;
  size_t v14;
  const char *v15;
  int v16;
  int v17;
  int v18;

  v6 = (_DWORD *)*((_QWORD *)this + 1);
  if (v6 && *v6 == a3->type)
    return EVP_MD_CTX_copy_ex(out, (const EVP_MD_CTX *)((char *)this + 8)) != 0;
  if (*(_QWORD *)this)
  {
    if (out->digest == a3)
    {
LABEL_12:
      ((void (*)(env_md_ctx_st *))a3->flags)(out);
      ((void (*)(env_md_ctx_st *, _QWORD, _QWORD))out->digest->init)(out, *(_QWORD *)(*(_QWORD *)this + 8), **(_QWORD **)this);
      return 1;
    }
    final_high = HIDWORD(a3->final);
    v9 = malloc_type_malloc(final_high + 8, 0x30772F57uLL);
    if (v9)
    {
      *v9 = final_high;
      v10 = (ENGINE *)(v9 + 1);
      engine = out->engine;
      if (engine)
      {
        v13 = *((_QWORD *)engine - 1);
        v12 = (char *)engine - 8;
        v14 = v13 + 8;
        if (v13 != -8)
          bzero(v12, v14);
        free(v12);
      }
      out->digest = a3;
      out->engine = v10;
      goto LABEL_12;
    }
    v15 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v16 = 14;
    v17 = 65;
    v18 = 247;
  }
  else
  {
    v15 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/s"
          "sl/ssl_transcript.cc";
    v16 = 16;
    v17 = 68;
    v18 = 216;
  }
  ERR_put_error(v16, 0, v17, v15, v18);
  return 0;
}

uint64_t bssl::SSLTranscript::GetFinishedMAC(bssl::SSLTranscript *this, int8x16_t *a2, unint64_t *a3, const ssl_session_st *a4, int a5)
{
  const char *v8;
  EVP_MD **v9;
  uint64_t pkey_type;
  size_t final_high;
  uint64_t v12;
  char *v13;
  uint64_t result;
  uint64_t v15;
  char *v16;
  EVP_MD_CTX out;
  _BYTE v18[64];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (a5)
    v8 = "server finished";
  else
    v8 = "client finished";
  memset(&out, 0, sizeof(out));
  v9 = (EVP_MD **)((char *)this + 8);
  if (EVP_MD_CTX_copy_ex(&out, (const EVP_MD_CTX *)((char *)this + 8)))
  {
    ((void (*)(EVP_MD_CTX *, _BYTE *))out.digest->update)(&out, v18);
    pkey_type = out.digest->pkey_type;
    final_high = HIDWORD(out.digest->final);
    if ((_DWORD)final_high)
      bzero(out.engine, final_high);
    if (out.engine)
    {
      v13 = (char *)out.engine - 8;
      v12 = *((_QWORD *)out.engine - 1);
      if (v12 != -8)
        bzero(v13, v12 + 8);
      free(v13);
    }
    if (out.md_data)
      (*(void (**)(unint64_t))out.md_data)(out.flags);
    result = CRYPTO_tls1_prf(*v9, a2, 0xCuLL, (char *)&a4->key_arg[3], a4->key_arg[2], (uint64_t)v8, 15, (uint64_t)v18, pkey_type, 0, 0);
    if ((_DWORD)result == 1)
    {
      *a3 = 12;
      return result;
    }
  }
  else
  {
    if (out.engine)
    {
      v16 = (char *)out.engine - 8;
      v15 = *((_QWORD *)out.engine - 1);
      if (v15 != -8)
        bzero(v16, v15 + 8);
      free(v16);
    }
    if (out.md_data)
      (*(void (**)(unint64_t))out.md_data)(out.flags);
  }
  return 0;
}

uint64_t bssl::ssl_get_version_range(_QWORD *a1, _WORD *a2, __int16 *a3)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v8;
  unsigned int v9;
  _BOOL4 v10;
  uint64_t v11;
  __int16 v12;

  v3 = a1[1];
  v4 = *(_DWORD *)(*a1 + 128);
  if (**(_BYTE **)*a1)
    v4 = *(_DWORD *)(*a1 + 128) & 0xEFFFFFFF | (((v4 >> 26) & 1) << 28);
  v5 = *(unsigned __int16 *)(v3 + 10);
  if (v5 - 769 >= 4)
  {
    if (v5 == 65277)
    {
      v5 = 771;
      v6 = *(unsigned __int16 *)(v3 + 8);
      if (v6 - 769 < 4)
        goto LABEL_15;
      goto LABEL_8;
    }
    if (v5 != 65279)
      goto LABEL_11;
    v5 = 770;
  }
  v6 = *(unsigned __int16 *)(v3 + 8);
  if (v6 - 769 < 4)
    goto LABEL_15;
LABEL_8:
  if (v6 != 65277)
  {
    if (v6 == 65279)
    {
      v6 = 770;
      goto LABEL_15;
    }
LABEL_11:
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_versions.cc", 190);
    return 0;
  }
  v6 = 771;
LABEL_15:
  if (*(_QWORD *)(*a1 + 152))
    v8 = v5 >= 0x304;
  else
    v8 = 1;
  if (v8)
    v9 = v5;
  else
    v9 = 772;
  if (v9 <= 0x301)
  {
    v10 = (v4 & 0x4000000) == 0;
    LOWORD(v9) = 769;
    if (v6 < 0x302)
      goto LABEL_43;
    goto LABEL_26;
  }
  if (v9 == 770)
  {
    v10 = 0;
    if (v6 < 0x302)
      goto LABEL_43;
LABEL_26:
    if ((v4 & 0x10000000) != 0)
    {
      if (v10)
      {
        v11 = 0;
        goto LABEL_54;
      }
      v10 = 0;
      if (v6 < 0x303)
        goto LABEL_43;
    }
    else
    {
      if (!v10)
        LOWORD(v9) = 770;
      v10 = 1;
      if (v6 < 0x303)
      {
LABEL_43:
        if (!v10)
        {
LABEL_44:
          ERR_put_error(16, 0, 280, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_versions.cc", 237);
          return 0;
        }
        goto LABEL_51;
      }
    }
    goto LABEL_39;
  }
  v10 = 0;
  if (v9 <= 0x303)
  {
    LOWORD(v9) = 771;
    if (v6 < 0x303)
      goto LABEL_43;
LABEL_39:
    if ((v4 & 0x8000000) != 0)
    {
      if (v10)
      {
        v11 = 1;
        goto LABEL_54;
      }
      v10 = 0;
      if (v6 < 0x304)
        goto LABEL_43;
    }
    else
    {
      if (!v10)
        LOWORD(v9) = 771;
      v10 = 1;
      if (v6 < 0x304)
        goto LABEL_43;
    }
    goto LABEL_48;
  }
  LOWORD(v9) = 772;
  if (v6 < 0x304)
    goto LABEL_43;
LABEL_48:
  if ((v4 & 0x20000000) == 0)
  {
    LOWORD(v6) = 772;
    if (!v10)
      LOWORD(v9) = 772;
LABEL_51:
    *a2 = v9;
    *a3 = v6;
    return 1;
  }
  if (!v10)
    goto LABEL_44;
  v11 = 2;
LABEL_54:
  v12 = bssl::kProtocolVersions[4 * v11];
  *a2 = v9;
  *a3 = v12;
  return 1;
}

uint64_t bssl::ssl_protocol_version(bssl *this, const ssl_st *a2)
{
  uint64_t result;

  result = *((unsigned __int16 *)this + 8);
  if ((result - 769) >= 4)
  {
    if ((_DWORD)result == 65277)
    {
      return 771;
    }
    else if ((_DWORD)result == 65279)
    {
      return 770;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL bssl::ssl_supports_version(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  unsigned __int16 *v3;
  uint64_t v4;
  int v5;
  int v6;
  BOOL v7;

  v2 = 8;
  if (***(_BYTE ***)a1)
    v2 = 4;
  v3 = (unsigned __int16 *)&bssl::kDTLSVersions;
  if (!***(_BYTE ***)a1)
    v3 = (unsigned __int16 *)&bssl::kTLSVersions;
  v4 = v2 - 2;
  do
  {
    v6 = *v3++;
    v5 = v6;
    v7 = v6 == a2 || v4 == 0;
    v4 -= 2;
  }
  while (!v7);
  if (v5 == a2)
  {
    if (a2 - 769 >= 4)
    {
      if (a2 == 65277)
      {
        a2 = 771;
        if (*(unsigned __int16 *)(a1 + 28) <= 0x303u)
          return a2 <= *(unsigned __int16 *)(a1 + 30);
      }
      else if (a2 == 65279)
      {
        a2 = 770;
        if (*(unsigned __int16 *)(a1 + 28) <= 0x302u)
          return a2 <= *(unsigned __int16 *)(a1 + 30);
      }
    }
    else if (*(unsigned __int16 *)(a1 + 28) <= a2)
    {
      return a2 <= *(unsigned __int16 *)(a1 + 30);
    }
  }
  return 0;
}

uint64_t bssl::ssl_add_supported_versions(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  int v8;
  uint64_t v9;
  unsigned __int16 *v10;
  uint64_t v11;
  int v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t result;
  _BYTE *v19;

  if (***(_BYTE ***)a1)
    v5 = 2;
  else
    v5 = 4;
  if (***(_BYTE ***)a1)
    v6 = (unsigned __int16 *)&bssl::kDTLSVersions;
  else
    v6 = (unsigned __int16 *)&bssl::kTLSVersions;
  v7 = &v6[v5];
  do
  {
    v8 = *v6;
    if (***(_BYTE ***)a1)
      v9 = 4;
    else
      v9 = 8;
    if (***(_BYTE ***)a1)
      v10 = (unsigned __int16 *)&bssl::kDTLSVersions;
    else
      v10 = (unsigned __int16 *)&bssl::kTLSVersions;
    v11 = v9 - 2;
    do
    {
      v13 = *v10++;
      v12 = v13;
      v14 = v13 == v8 || v11 == 0;
      v11 -= 2;
    }
    while (!v14);
    if (v12 != v8)
      goto LABEL_8;
    v15 = *v6;
    if ((v8 - 769) < 4)
      goto LABEL_26;
    if (v8 != 65277)
    {
      if (v8 != 65279)
        goto LABEL_8;
      v15 = 770;
LABEL_26:
      if (*(unsigned __int16 *)(a1 + 28) > v15)
        goto LABEL_8;
      goto LABEL_27;
    }
    v15 = 771;
    if (*(unsigned __int16 *)(a1 + 28) > 0x303u)
      goto LABEL_8;
LABEL_27:
    if (v15 > *(unsigned __int16 *)(a1 + 30))
      goto LABEL_8;
    v16 = *v6;
    if ((v8 - 769) >= 4)
    {
      if (v8 == 65277)
      {
        if (a3 > 0x303)
          goto LABEL_8;
        goto LABEL_33;
      }
      if (v8 != 65279)
        goto LABEL_8;
      v16 = 770;
    }
    if (v16 < a3)
      goto LABEL_8;
LABEL_33:
    v19 = 0;
    result = CBB_add_space(a2, &v19, 2);
    if (!(_DWORD)result)
      return result;
    v19[1] = v8;
    *v19 = BYTE1(v8);
LABEL_8:
    ++v6;
  }
  while (v6 != v7);
  return 1;
}

uint64_t bssl::ssl_negotiate_version(uint64_t a1, _BYTE *a2, _WORD *a3, unsigned __int16 **a4)
{
  uint64_t v5;
  char *v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  uint64_t v11;
  unsigned __int16 *v12;
  int v13;
  int v14;
  BOOL v15;
  unsigned int v16;
  unint64_t v17;
  unsigned __int16 *v18;
  uint64_t result;

  if (***(_BYTE ***)a1)
    v5 = 4;
  else
    v5 = 8;
  v6 = (char *)&bssl::kDTLSVersions;
  if (!***(_BYTE ***)a1)
    v6 = (char *)&bssl::kTLSVersions;
  v7 = (unsigned __int16 *)&v6[v5];
  v8 = v5 - 2;
  v9 = (unsigned __int16 *)v6;
  while (1)
  {
    v10 = *v9;
    v11 = v8;
    v12 = (unsigned __int16 *)v6;
    do
    {
      v14 = *v12++;
      v13 = v14;
      v15 = v14 == v10 || v11 == 0;
      v11 -= 2;
    }
    while (!v15);
    if (v13 != v10)
      goto LABEL_7;
    v16 = *v9;
    if ((v10 - 769) < 4)
      goto LABEL_19;
    if (v10 == 65277)
      break;
    if (v10 != 65279)
      goto LABEL_7;
    v16 = 770;
LABEL_19:
    if (*(unsigned __int16 *)(a1 + 28) <= v16)
      goto LABEL_20;
LABEL_7:
    if (++v9 == v7)
    {
      ERR_put_error(16, 0, 240, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_versions.cc", 328);
      result = 0;
      *a2 = 70;
      return result;
    }
  }
  v16 = 771;
  if (*(unsigned __int16 *)(a1 + 28) > 0x303u)
    goto LABEL_7;
LABEL_20:
  if (v16 > *(unsigned __int16 *)(a1 + 30) || v10 == 772 && (*(_BYTE *)(a1 + 1570) & 0x20) != 0)
    goto LABEL_7;
  v17 = (unint64_t)a4[1];
  if (!v17)
    goto LABEL_7;
  v18 = *a4;
  while (1)
  {
    if (v17 <= 1)
    {
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_versions.cc", 316);
      result = 0;
      *a2 = 50;
      return result;
    }
    if (v10 == bswap32(*v18) >> 16)
      break;
    ++v18;
    v17 -= 2;
    if (!v17)
      goto LABEL_7;
  }
  *a3 = v10;
  return 1;
}

uint64_t SSL_CTX_set_min_proto_version(uint64_t a1, int a2)
{
  _BYTE *v2;
  BOOL v3;
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  int v7;
  int v8;
  BOOL v9;
  __int16 v11;

  v2 = *(_BYTE **)(a1 + 8);
  if (a2 > 65276)
  {
    if (a2 == 65277 || a2 == 65279)
    {
LABEL_3:
      v3 = *v2 == 0;
      v4 = 8;
      if (*v2)
        v4 = 4;
      v5 = (unsigned __int16 *)&bssl::kDTLSVersions;
      if (v3)
        v5 = (unsigned __int16 *)&bssl::kTLSVersions;
      v6 = v4 - 2;
      do
      {
        v8 = *v5++;
        v7 = v8;
        v9 = v8 == a2 || v6 == 0;
        v6 -= 2;
      }
      while (!v9);
      if (v7 == a2)
      {
        *(_WORD *)(a1 + 226) = a2;
        return 1;
      }
    }
LABEL_23:
    ERR_put_error(16, 0, 234, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_versions.cc", 133);
    return 0;
  }
  if ((a2 - 769) < 4)
    goto LABEL_3;
  if (a2)
    goto LABEL_23;
  if (*v2)
    v11 = -257;
  else
    v11 = 769;
  *(_WORD *)(a1 + 226) = v11;
  return 1;
}

uint64_t SSL_CTX_set_max_proto_version(uint64_t a1, int a2)
{
  _BYTE *v2;
  BOOL v3;
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  int v7;
  int v8;
  BOOL v9;
  __int16 v11;

  v2 = *(_BYTE **)(a1 + 8);
  if (a2 > 65276)
  {
    if (a2 == 65277 || a2 == 65279)
    {
LABEL_3:
      v3 = *v2 == 0;
      v4 = 8;
      if (*v2)
        v4 = 4;
      v5 = (unsigned __int16 *)&bssl::kDTLSVersions;
      if (v3)
        v5 = (unsigned __int16 *)&bssl::kTLSVersions;
      v6 = v4 - 2;
      do
      {
        v8 = *v5++;
        v7 = v8;
        v9 = v8 == a2 || v6 == 0;
        v6 -= 2;
      }
      while (!v9);
      if (v7 == a2)
      {
        *(_WORD *)(a1 + 224) = a2;
        return 1;
      }
    }
LABEL_23:
    ERR_put_error(16, 0, 234, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_versions.cc", 133);
    return 0;
  }
  if ((a2 - 769) < 4)
    goto LABEL_3;
  if (a2)
    goto LABEL_23;
  if (*v2)
    v11 = -259;
  else
    v11 = 772;
  *(_WORD *)(a1 + 224) = v11;
  return 1;
}

uint64_t bssl::ssl_crypto_x509_check_client_CA_list(unint64_t *a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v7;
  ASN1_VALUE *pval;

  if (!a1)
    return 1;
  v2 = *a1;
  if (!*a1)
    return 1;
  v3 = 0;
  while (1)
  {
    v4 = *a1 <= v3 ? 0 : *(_QWORD *)(a1[1] + 8 * v3);
    v5 = *(_QWORD *)(v4 + 16);
    v7 = *(unsigned __int8 **)(v4 + 8);
    pval = 0;
    if ((int)asn1_item_ex_d2i((uint64_t)&pval, &v7, v5, (uint64_t)&X509_NAME_it, -1, 0, 0, 0, 0) <= 0)
      ASN1_item_ex_free(&pval, &X509_NAME_it);
    if (!pval)
      break;
    if (v7 != (unsigned __int8 *)(*(_QWORD *)(v4 + 8) + *(_QWORD *)(v4 + 16)))
    {
      ASN1_item_ex_free(&pval, &X509_NAME_it);
      return 0;
    }
    ASN1_item_ex_free(&pval, &X509_NAME_it);
    if (v2 == ++v3)
      return 1;
  }
  return 0;
}

void bssl::ssl_crypto_x509_cert_clear(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  X509 *v5;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  unint64_t *v10;
  uint64_t v11;
  size_t v12;

  X509_free(*(X509 **)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0;
  v2 = *(unint64_t **)(a1 + 40);
  if (v2)
  {
    v3 = *v2;
    if (*v2)
    {
      v4 = 0;
      do
      {
        v5 = *(X509 **)(v2[1] + 8 * v4);
        if (v5)
        {
          X509_free(v5);
          v3 = *v2;
        }
        ++v4;
      }
      while (v4 < v3);
    }
    v6 = v2[1];
    if (v6)
    {
      v8 = *(_QWORD *)(v6 - 8);
      v7 = (void *)(v6 - 8);
      v9 = v8 + 8;
      if (v8 != -8)
        bzero(v7, v9);
      free(v7);
    }
    v11 = *(v2 - 1);
    v10 = v2 - 1;
    v12 = v11 + 8;
    if (v11 != -8)
      bzero(v10, v12);
    free(v10);
  }
  *(_QWORD *)(a1 + 40) = 0;
  X509_free(*(X509 **)(a1 + 56));
  *(_QWORD *)(a1 + 56) = 0;
}

void bssl::ssl_crypto_x509_cert_free(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  X509 *v5;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  unint64_t *v10;
  uint64_t v11;
  size_t v12;

  X509_free(*(X509 **)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0;
  v2 = *(unint64_t **)(a1 + 40);
  if (v2)
  {
    v3 = *v2;
    if (*v2)
    {
      v4 = 0;
      do
      {
        v5 = *(X509 **)(v2[1] + 8 * v4);
        if (v5)
        {
          X509_free(v5);
          v3 = *v2;
        }
        ++v4;
      }
      while (v4 < v3);
    }
    v6 = v2[1];
    if (v6)
    {
      v8 = *(_QWORD *)(v6 - 8);
      v7 = (void *)(v6 - 8);
      v9 = v8 + 8;
      if (v8 != -8)
        bzero(v7, v9);
      free(v7);
    }
    v11 = *(v2 - 1);
    v10 = v2 - 1;
    v12 = v11 + 8;
    if (v11 != -8)
      bzero(v10, v12);
    free(v10);
  }
  *(_QWORD *)(a1 + 40) = 0;
  X509_free(*(X509 **)(a1 + 56));
  *(_QWORD *)(a1 + 56) = 0;
  X509_STORE_free(*(X509_STORE **)(a1 + 80));
}

uint64_t bssl::ssl_crypto_x509_cert_dup(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v2 = *(_QWORD *)(a2 + 80);
  if (v2)
  {
    v3 = (unsigned int *)(v2 + 248);
    v4 = atomic_load(v3);
    if (v4 != -1)
    {
      do
      {
        v5 = __ldaxr(v3);
        if (v5 == v4)
        {
          if (!__stlxr(v4 + 1, v3))
            break;
        }
        else
        {
          __clrex();
        }
        v4 = v5;
      }
      while (v5 != -1);
    }
    *(_QWORD *)(result + 80) = *(_QWORD *)(a2 + 80);
  }
  return result;
}

void bssl::ssl_crypto_x509_cert_flush_cached_chain(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  X509 *v5;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  unint64_t *v10;
  uint64_t v11;
  size_t v12;

  v2 = *(unint64_t **)(a1 + 40);
  if (v2)
  {
    v3 = *v2;
    if (*v2)
    {
      v4 = 0;
      do
      {
        v5 = *(X509 **)(v2[1] + 8 * v4);
        if (v5)
        {
          X509_free(v5);
          v3 = *v2;
        }
        ++v4;
      }
      while (v4 < v3);
    }
    v6 = v2[1];
    if (v6)
    {
      v8 = *(_QWORD *)(v6 - 8);
      v7 = (void *)(v6 - 8);
      v9 = v8 + 8;
      if (v8 != -8)
        bzero(v7, v9);
      free(v7);
    }
    v11 = *(v2 - 1);
    v10 = v2 - 1;
    v12 = v11 + 8;
    if (v11 != -8)
      bzero(v10, v12);
    free(v10);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

void bssl::ssl_crypto_x509_cert_flush_cached_leaf(uint64_t a1)
{
  X509_free(*(X509 **)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0;
}

uint64_t bssl::ssl_crypto_x509_session_cache_objects(bssl *this, ssl_session_st *a2)
{
  _QWORD *v3;
  uint64_t result;
  unint64_t *v5;
  unint64_t *v6;
  X509 *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  X509 *v11;
  unint64_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;
  unint64_t *v16;
  uint64_t v17;
  size_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  X509 *v22;
  unint64_t v23;
  void *v24;
  uint64_t v25;
  size_t v26;
  unint64_t *v27;
  uint64_t v28;
  size_t v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  X509 *v33;
  uint64_t v34;
  uint64_t v35;
  X509 *v36;
  X509 *v37;
  unsigned int *p_valid;
  unsigned int v39;
  unsigned int v40;
  char v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  X509 *v45;
  unsigned int *v46;
  unsigned int v47;
  unsigned int v48;
  char v49;
  unint64_t v50;
  unint64_t v51;
  X509 *v52;
  unint64_t v53;
  void *v54;
  uint64_t v55;
  size_t v56;
  unint64_t *v57;
  uint64_t v58;
  size_t v59;
  unint64_t v60;
  unint64_t v61;
  X509 *v62;
  unint64_t v63;
  void *v64;
  uint64_t v65;
  size_t v66;
  unint64_t *v67;
  uint64_t v68;
  size_t v69;
  unsigned __int8 *v70;
  uint64_t v71;

  v3 = (_QWORD *)*((_QWORD *)this + 17);
  if (v3 && *v3)
  {
    result = (uint64_t)OPENSSL_sk_new_null();
    if (!result)
      return result;
    v5 = (unint64_t *)result;
    if ((*((_BYTE *)this + 424) & 0x10) != 0)
    {
      v6 = (unint64_t *)OPENSSL_sk_new_null();
      if (!v6)
      {
LABEL_99:
        v60 = *v5;
        if (*v5)
        {
          v61 = 0;
          do
          {
            v62 = *(X509 **)(v5[1] + 8 * v61);
            if (v62)
            {
              X509_free(v62);
              v60 = *v5;
            }
            ++v61;
          }
          while (v61 < v60);
        }
        v63 = v5[1];
        if (v63)
        {
          v65 = *(_QWORD *)(v63 - 8);
          v64 = (void *)(v63 - 8);
          v66 = v65 + 8;
          if (v65 != -8)
            bzero(v64, v66);
          free(v64);
        }
        v68 = *(v5 - 1);
        v67 = v5 - 1;
        v69 = v68 + 8;
        if (v68 != -8)
          bzero(v67, v69);
        free(v67);
        return 0;
      }
    }
    else
    {
      v6 = 0;
    }
    v30 = (unint64_t *)*((_QWORD *)this + 17);
    if (v30)
    {
      v31 = *v30;
      if (*v30)
      {
        if (v6)
        {
          v32 = 0;
          v33 = 0;
          while (1)
          {
            if (*v30 <= v32)
              v34 = 0;
            else
              v34 = *(_QWORD *)(v30[1] + 8 * v32);
            v35 = *(_QWORD *)(v34 + 16);
            v70 = *(unsigned __int8 **)(v34 + 8);
            v71 = v35;
            v36 = x509_parse(&v70, v34);
            if (!v36)
              goto LABEL_80;
            v37 = v36;
            if (v71)
              goto LABEL_79;
            p_valid = (unsigned int *)&v36->valid;
            v39 = atomic_load((unsigned int *)&v36->valid);
            if (v39 != -1)
            {
              while (1)
              {
                v40 = __ldaxr(p_valid);
                if (v40 == v39)
                {
                  if (!__stlxr(v39 + 1, p_valid))
                  {
                    v41 = 1;
                    goto LABEL_52;
                  }
                }
                else
                {
                  __clrex();
                }
                v41 = 0;
LABEL_52:
                if ((v41 & 1) == 0)
                {
                  v39 = v40;
                  if (v40 != -1)
                    continue;
                }
                break;
              }
            }
            v7 = v36;
            if (v33)
            {
              if (!OPENSSL_sk_insert(v6, (uint64_t)v36, *v6))
              {
                X509_free(v37);
                goto LABEL_84;
              }
              v7 = v33;
            }
            if (!OPENSSL_sk_insert(v5, (uint64_t)v37, *v5))
            {
              v33 = v7;
LABEL_84:
              X509_free(v37);
              goto LABEL_85;
            }
            ++v32;
            v33 = v7;
            if (v32 == v31)
              goto LABEL_8;
          }
        }
        v42 = 0;
        v33 = 0;
        while (1)
        {
          v43 = *v30 <= v42 ? 0 : *(_QWORD *)(v30[1] + 8 * v42);
          v44 = *(_QWORD *)(v43 + 16);
          v70 = *(unsigned __int8 **)(v43 + 8);
          v71 = v44;
          v45 = x509_parse(&v70, v43);
          if (!v45)
            break;
          v37 = v45;
          if (v71)
          {
LABEL_79:
            X509_free(v37);
            break;
          }
          if (!v33)
          {
            v46 = (unsigned int *)&v45->valid;
            v47 = atomic_load((unsigned int *)&v45->valid);
            v33 = v45;
            if (v47 != -1)
            {
              while (1)
              {
                v48 = __ldaxr(v46);
                if (v48 == v47)
                {
                  if (!__stlxr(v47 + 1, v46))
                  {
                    v49 = 1;
                    goto LABEL_73;
                  }
                }
                else
                {
                  __clrex();
                }
                v49 = 0;
LABEL_73:
                if ((v49 & 1) == 0)
                {
                  v47 = v48;
                  if (v48 != -1)
                    continue;
                }
                v33 = v45;
                break;
              }
            }
          }
          if (!OPENSSL_sk_insert(v5, (uint64_t)v45, *v5))
            goto LABEL_84;
          if (++v42 == v31)
          {
            v6 = 0;
            v7 = v33;
            goto LABEL_8;
          }
        }
LABEL_80:
        ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_x509.cc", 270);
        if (v33)
LABEL_85:
          X509_free(v33);
        if (v6)
        {
          v50 = *v6;
          if (*v6)
          {
            v51 = 0;
            do
            {
              v52 = *(X509 **)(v6[1] + 8 * v51);
              if (v52)
              {
                X509_free(v52);
                v50 = *v6;
              }
              ++v51;
            }
            while (v51 < v50);
          }
          v53 = v6[1];
          if (v53)
          {
            v55 = *(_QWORD *)(v53 - 8);
            v54 = (void *)(v53 - 8);
            v56 = v55 + 8;
            if (v55 != -8)
              bzero(v54, v56);
            free(v54);
          }
          v58 = *(v6 - 1);
          v57 = v6 - 1;
          v59 = v58 + 8;
          if (v58 != -8)
            bzero(v57, v59);
          free(v57);
        }
        goto LABEL_99;
      }
    }
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  v7 = 0;
LABEL_8:
  v8 = (unint64_t *)*((_QWORD *)this + 20);
  if (v8)
  {
    v9 = *v8;
    if (*v8)
    {
      v10 = 0;
      do
      {
        v11 = *(X509 **)(v8[1] + 8 * v10);
        if (v11)
        {
          X509_free(v11);
          v9 = *v8;
        }
        ++v10;
      }
      while (v10 < v9);
    }
    v12 = v8[1];
    if (v12)
    {
      v14 = *(_QWORD *)(v12 - 8);
      v13 = (void *)(v12 - 8);
      v15 = v14 + 8;
      if (v14 != -8)
        bzero(v13, v15);
      free(v13);
    }
    v17 = *(v8 - 1);
    v16 = v8 - 1;
    v18 = v17 + 8;
    if (v17 != -8)
      bzero(v16, v18);
    free(v16);
  }
  *((_QWORD *)this + 20) = v5;
  v19 = (unint64_t *)*((_QWORD *)this + 21);
  if (v19)
  {
    v20 = *v19;
    if (*v19)
    {
      v21 = 0;
      do
      {
        v22 = *(X509 **)(v19[1] + 8 * v21);
        if (v22)
        {
          X509_free(v22);
          v20 = *v19;
        }
        ++v21;
      }
      while (v21 < v20);
    }
    v23 = v19[1];
    if (v23)
    {
      v25 = *(_QWORD *)(v23 - 8);
      v24 = (void *)(v23 - 8);
      v26 = v25 + 8;
      if (v25 != -8)
        bzero(v24, v26);
      free(v24);
    }
    v28 = *(v19 - 1);
    v27 = v19 - 1;
    v29 = v28 + 8;
    if (v28 != -8)
      bzero(v27, v29);
    free(v27);
  }
  *((_QWORD *)this + 21) = v6;
  X509_free(*((X509 **)this + 19));
  *((_QWORD *)this + 19) = v7;
  return 1;
}

uint64_t bssl::ssl_crypto_x509_session_dup(bssl *this, ssl_session_st *a2, const ssl_session_st *a3)
{
  X509 *peer;
  unsigned int *p_valid;
  unsigned int v7;
  uint64_t verify_result;
  uint64_t result;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;

  peer = a2->peer;
  if (peer)
  {
    p_valid = (unsigned int *)&peer->valid;
    v7 = atomic_load((unsigned int *)&peer->valid);
    if (v7 != -1)
    {
      do
      {
        v15 = __ldaxr(p_valid);
        if (v15 == v7)
        {
          if (!__stlxr(v7 + 1, p_valid))
            break;
        }
        else
        {
          __clrex();
        }
        v7 = v15;
      }
      while (v15 != -1);
    }
  }
  *((_QWORD *)this + 19) = peer;
  verify_result = a2->verify_result;
  if (verify_result)
  {
    result = (uint64_t)OPENSSL_sk_dup(verify_result);
    if (!result)
    {
      *((_QWORD *)this + 20) = 0;
      return result;
    }
    v10 = *(_QWORD *)result;
    if (*(_QWORD *)result)
    {
      v11 = 0;
      do
      {
        if (v10 <= v11)
        {
          v12 = 24;
          v13 = atomic_load((unsigned int *)0x18);
          if (v13 != -1)
          {
            do
            {
LABEL_15:
              v14 = __ldaxr((unsigned int *)v12);
              if (v14 == v13)
              {
                if (!__stlxr(v13 + 1, (unsigned int *)v12))
                  break;
              }
              else
              {
                __clrex();
              }
              v13 = v14;
            }
            while (v14 != -1);
          }
        }
        else
        {
          v12 = *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * v11) + 24;
          v13 = atomic_load((unsigned int *)v12);
          if (v13 != -1)
            goto LABEL_15;
        }
        ++v11;
        v10 = *(_QWORD *)result;
      }
      while (v11 < *(_QWORD *)result);
    }
    *((_QWORD *)this + 20) = result;
  }
  v16 = *(_QWORD *)&a2->references;
  if (!v16)
    return 1;
  result = (uint64_t)OPENSSL_sk_dup(v16);
  if (result)
  {
    v17 = *(_QWORD *)result;
    if (*(_QWORD *)result)
    {
      v18 = 0;
      do
      {
        if (v17 <= v18)
        {
          v19 = 24;
          v20 = atomic_load((unsigned int *)0x18);
          if (v20 != -1)
          {
            do
            {
LABEL_36:
              v21 = __ldaxr((unsigned int *)v19);
              if (v21 == v20)
              {
                if (!__stlxr(v20 + 1, (unsigned int *)v19))
                  break;
              }
              else
              {
                __clrex();
              }
              v20 = v21;
            }
            while (v21 != -1);
          }
        }
        else
        {
          v19 = *(_QWORD *)(*(_QWORD *)(result + 8) + 8 * v18) + 24;
          v20 = atomic_load((unsigned int *)v19);
          if (v20 != -1)
            goto LABEL_36;
        }
        ++v18;
        v17 = *(_QWORD *)result;
      }
      while (v18 < *(_QWORD *)result);
    }
    *((_QWORD *)this + 21) = result;
    return 1;
  }
  *((_QWORD *)this + 21) = 0;
  return result;
}

void bssl::ssl_crypto_x509_session_clear(X509 **this, ssl_session_st *a2)
{
  X509 *v3;
  X509_CINF *cert_info;
  unint64_t v5;
  X509 *v6;
  X509_ALGOR *sig_alg;
  ASN1_TYPE **p_parameter;
  ASN1_TYPE *parameter;
  size_t p_value;
  X509_CERT_AUX **p_aux;
  X509_CERT_AUX *aux;
  size_t p_reject;
  X509 *v14;
  X509_CINF *v15;
  unint64_t v16;
  X509 *v17;
  X509_ALGOR *v18;
  ASN1_TYPE **v19;
  ASN1_TYPE *v20;
  size_t v21;
  X509_CERT_AUX **v22;
  X509_CERT_AUX *v23;
  size_t v24;

  X509_free(this[19]);
  this[19] = 0;
  v3 = this[20];
  if (v3)
  {
    cert_info = v3->cert_info;
    if (v3->cert_info)
    {
      v5 = 0;
      do
      {
        v6 = (X509 *)*((_QWORD *)&v3->sig_alg->algorithm + v5);
        if (v6)
        {
          X509_free(v6);
          cert_info = v3->cert_info;
        }
        ++v5;
      }
      while (v5 < (unint64_t)cert_info);
    }
    sig_alg = v3->sig_alg;
    if (sig_alg)
    {
      parameter = sig_alg[-1].parameter;
      p_parameter = &sig_alg[-1].parameter;
      p_value = (size_t)&parameter->value;
      if (parameter != (ASN1_TYPE *)-8)
        bzero(p_parameter, p_value);
      free(p_parameter);
    }
    aux = v3[-1].aux;
    p_aux = &v3[-1].aux;
    p_reject = (size_t)&aux->reject;
    if (aux != (X509_CERT_AUX *)-8)
      bzero(p_aux, p_reject);
    free(p_aux);
  }
  this[20] = 0;
  v14 = this[21];
  if (v14)
  {
    v15 = v14->cert_info;
    if (v14->cert_info)
    {
      v16 = 0;
      do
      {
        v17 = (X509 *)*((_QWORD *)&v14->sig_alg->algorithm + v16);
        if (v17)
        {
          X509_free(v17);
          v15 = v14->cert_info;
        }
        ++v16;
      }
      while (v16 < (unint64_t)v15);
    }
    v18 = v14->sig_alg;
    if (v18)
    {
      v20 = v18[-1].parameter;
      v19 = &v18[-1].parameter;
      v21 = (size_t)&v20->value;
      if (v20 != (ASN1_TYPE *)-8)
        bzero(v19, v21);
      free(v19);
    }
    v23 = v14[-1].aux;
    v22 = &v14[-1].aux;
    v24 = (size_t)&v23->reject;
    if (v23 != (X509_CERT_AUX *)-8)
      bzero(v22, v24);
    free(v22);
  }
  this[21] = 0;
}

uint64_t bssl::ssl_crypto_x509_session_verify_cert_chain(bssl *this, ssl_session_st *a2, bssl::SSL_HANDSHAKE *a3, unsigned __int8 *a4)
{
  STACK *v4;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  X509 *v16;
  X509_STORE *v17;
  X509_STORE *v18;
  char *v19;
  char *v20;
  X509_STORE_CTX *v21;
  X509_STORE *v22;
  char *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t (*v27)(X509_STORE_CTX *, _QWORD);
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v32;
  _BYTE *__s;
  size_t __n;

  *(_BYTE *)a3 = 80;
  v4 = (STACK *)*((_QWORD *)this + 20);
  if (!v4 || !*(_QWORD *)&v4->num)
    return 0;
  v8 = 0;
  v9 = *(_QWORD *)&a2->ssl_version;
  v10 = *(_QWORD *)(*(_QWORD *)&a2->ssl_version + 104);
  if ((*(_BYTE *)(*(_QWORD *)&a2->ssl_version + 164) & 1) != 0)
  {
    v13 = 0;
  }
  else
  {
    v11 = *(_QWORD *)(v9 + 48);
    v12 = *(_QWORD *)(v11 + 280);
    v13 = 0;
    if (v12)
    {
      if (*(_DWORD *)(v11 + 216) == 2)
      {
        v14 = *(_QWORD *)(v12 + 1528);
        v8 = *(_BYTE **)(v14 + 32);
        v13 = *(_QWORD *)(v14 + 40);
      }
      else
      {
        v8 = 0;
        v13 = 0;
      }
    }
  }
  __s = v8;
  __n = v13;
  v16 = (X509 *)*v4->data;
  v17 = *(X509_STORE **)(v10 + 248);
  v18 = *(X509_STORE **)(*(_QWORD *)(*(_QWORD *)a2->key_arg + 32) + 80);
  v19 = (char *)malloc_type_malloc(0x90uLL, 0x30772F57uLL);
  if (v19)
  {
    v20 = v19;
    v32 = v10;
    *(_QWORD *)v19 = 136;
    *(_OWORD *)(v19 + 8) = 0u;
    v21 = (X509_STORE_CTX *)(v19 + 8);
    *(_OWORD *)(v19 + 24) = 0u;
    *(_OWORD *)(v19 + 40) = 0u;
    *(_OWORD *)(v19 + 56) = 0u;
    *(_OWORD *)(v19 + 72) = 0u;
    *(_OWORD *)(v19 + 88) = 0u;
    *(_OWORD *)(v19 + 104) = 0u;
    *(_OWORD *)(v19 + 120) = 0u;
    if (v18)
      v22 = v18;
    else
      v22 = v17;
    *((_QWORD *)v19 + 17) = 0;
    if (!X509_STORE_CTX_init((X509_STORE_CTX *)(v19 + 8), v22, v16, v4))
      goto LABEL_41;
    v23 = (char *)*((_QWORD *)v20 + 17);
    if (!v23)
    {
      v23 = OPENSSL_sk_new_null();
      *((_QWORD *)v20 + 17) = v23;
      if (!v23)
        goto LABEL_41;
    }
    if (*(_QWORD *)v23)
      goto LABEL_18;
    if (!OPENSSL_sk_insert((unint64_t *)v23, 0, 0))
      goto LABEL_41;
    v23 = (char *)*((_QWORD *)v20 + 17);
    if (v23)
    {
      if (*(_QWORD *)v23)
LABEL_18:
        **((_QWORD **)v23 + 1) = v9;
    }
    if ((*(_BYTE *)(v9 + 164) & 1) != 0)
      v24 = "ssl_client";
    else
      v24 = "ssl_server";
    if (X509_STORE_CTX_set_default(v21, v24)
      && x509_verify_param_copy(*((_QWORD *)v20 + 5), *(_QWORD *)(*(_QWORD *)a2->key_arg + 16), 1))
    {
      if (!__n || (v25 = *((_QWORD *)v20 + 5), int_x509_param_set_hosts(v25, 0, __s, __n)))
      {
        v26 = *(_QWORD *)(*(_QWORD *)a2->key_arg + 40);
        if (v26)
          *((_QWORD *)v20 + 7) = v26;
        v27 = *(uint64_t (**)(X509_STORE_CTX *, _QWORD))(v32 + 328);
        if (v27)
          v28 = v27(v21, *(_QWORD *)(v32 + 336));
        else
          v28 = X509_verify_cert(v21);
        v29 = v28;
        v30 = *((int *)v20 + 25);
        *((_QWORD *)this + 22) = v30;
        if (v29 <= 0 && *(_BYTE *)(*(_QWORD *)a2->key_arg + 236))
        {
          v15 = 0;
          *(_BYTE *)a3 = SSL_alert_from_verify_result(v30);
        }
        else
        {
          ERR_clear_error();
          v15 = 1;
        }
        goto LABEL_42;
      }
      *(_BYTE *)(v25 + 88) = 1;
    }
LABEL_41:
    ERR_put_error(16, 0, 11, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_x509.cc", 361);
    v15 = 0;
LABEL_42:
    X509_STORE_CTX_free(v21);
    return v15;
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  ERR_put_error(16, 0, 11, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_x509.cc", 361);
  return 0;
}

void bssl::ssl_crypto_x509_hs_flush_cached_ca_names(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  void *v6;
  uint64_t v7;
  size_t v8;
  unint64_t *v9;
  uint64_t v10;
  size_t v11;
  ASN1_VALUE *pval;

  v2 = *(unint64_t **)(a1 + 1464);
  if (v2)
  {
    v3 = *v2;
    if (*v2)
    {
      v4 = 0;
      do
      {
        if (*(_QWORD *)(v2[1] + 8 * v4))
        {
          pval = *(ASN1_VALUE **)(v2[1] + 8 * v4);
          ASN1_item_ex_free(&pval, &X509_NAME_it);
          v3 = *v2;
        }
        ++v4;
      }
      while (v4 < v3);
    }
    v5 = v2[1];
    if (v5)
    {
      v7 = *(_QWORD *)(v5 - 8);
      v6 = (void *)(v5 - 8);
      v8 = v7 + 8;
      if (v7 != -8)
        bzero(v6, v8);
      free(v6);
    }
    v10 = *(v2 - 1);
    v9 = v2 - 1;
    v11 = v10 + 8;
    if (v10 != -8)
      bzero(v9, v11);
    free(v9);
  }
  *(_QWORD *)(a1 + 1464) = 0;
}

BOOL bssl::ssl_crypto_x509_ssl_new(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  char *v3;
  char *v4;
  uint64_t v5;

  v3 = (char *)malloc_type_malloc(0x68uLL, 0x30772F57uLL);
  v4 = v3;
  if (v3)
  {
    *(_QWORD *)v3 = 96;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 40) = 0u;
    *(_OWORD *)(v3 + 56) = 0u;
    *(_OWORD *)(v3 + 72) = 0u;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_OWORD *)(v3 + 8) = 0u;
    *((_DWORD *)v3 + 8) = -1;
    v5 = *(_QWORD *)this;
    *(_QWORD *)(*((_QWORD *)this + 1) + 16) = v3 + 8;
    x509_verify_param_copy((uint64_t)(v3 + 8), *(_QWORD *)(*(_QWORD *)(v5 + 104) + 464), 0);
    return v4 != 0;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    *(_QWORD *)(*((_QWORD *)this + 1) + 16) = 0;
    return 0;
  }
}

void bssl::ssl_crypto_x509_ssl_config_free(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  void *v6;
  uint64_t v7;
  size_t v8;
  unint64_t *v9;
  uint64_t v10;
  size_t v11;
  ASN1_VALUE *pval;

  v2 = *(unint64_t **)(a1 + 88);
  if (v2)
  {
    v3 = *v2;
    if (*v2)
    {
      v4 = 0;
      do
      {
        if (*(_QWORD *)(v2[1] + 8 * v4))
        {
          pval = *(ASN1_VALUE **)(v2[1] + 8 * v4);
          ASN1_item_ex_free(&pval, &X509_NAME_it);
          v3 = *v2;
        }
        ++v4;
      }
      while (v4 < v3);
    }
    v5 = v2[1];
    if (v5)
    {
      v7 = *(_QWORD *)(v5 - 8);
      v6 = (void *)(v5 - 8);
      v8 = v7 + 8;
      if (v7 != -8)
        bzero(v6, v8);
      free(v6);
    }
    v10 = *(v2 - 1);
    v9 = v2 - 1;
    v11 = v10 + 8;
    if (v10 != -8)
      bzero(v9, v11);
    free(v9);
  }
  *(_QWORD *)(a1 + 88) = 0;
  X509_VERIFY_PARAM_free(*(X509_VERIFY_PARAM **)(a1 + 16));
}

void bssl::ssl_crypto_x509_ssl_flush_cached_client_CA(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  void *v6;
  uint64_t v7;
  size_t v8;
  unint64_t *v9;
  uint64_t v10;
  size_t v11;
  ASN1_VALUE *pval;

  v2 = *(unint64_t **)(a1 + 88);
  if (v2)
  {
    v3 = *v2;
    if (*v2)
    {
      v4 = 0;
      do
      {
        if (*(_QWORD *)(v2[1] + 8 * v4))
        {
          pval = *(ASN1_VALUE **)(v2[1] + 8 * v4);
          ASN1_item_ex_free(&pval, &X509_NAME_it);
          v3 = *v2;
        }
        ++v4;
      }
      while (v4 < v3);
    }
    v5 = v2[1];
    if (v5)
    {
      v7 = *(_QWORD *)(v5 - 8);
      v6 = (void *)(v5 - 8);
      v8 = v7 + 8;
      if (v7 != -8)
        bzero(v6, v8);
      free(v6);
    }
    v10 = *(v2 - 1);
    v9 = v2 - 1;
    v11 = v10 + 8;
    if (v10 != -8)
      bzero(v9, v11);
    free(v9);
  }
  *(_QWORD *)(a1 + 88) = 0;
}

uint64_t bssl::ssl_crypto_x509_ssl_auto_chain_if_needed(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v9;
  X509 *v10;
  X509 *v11;
  char *v12;
  char *v13;
  X509_STORE_CTX *v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  char v24;
  uint64_t v25;
  X509 *v26;
  uint64_t v27;
  unsigned __int8 *v28;
  uint64_t v29;

  v2 = *(_QWORD *)this;
  if ((*(_BYTE *)(*(_QWORD *)this + 132) & 8) != 0)
    return 1;
  v3 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 32) + 24);
  v4 = *(uint64_t **)(v3 + 48);
  if (!v4)
    return 1;
  v5 = *v4;
  if (!*v4)
    return 1;
  v6 = *(_QWORD *)v4[1];
  if (!v6 || !*(_QWORD *)(v3 + 8) || !*(_QWORD *)(v3 + 16) && !*(_QWORD *)(v3 + 24))
    return 1;
  if (*(_DWORD *)(v3 + 4) != 1)
  {
    if (v5 == 1)
      goto LABEL_15;
    return 1;
  }
  if (*(_QWORD *)(v3 + 56))
    v7 = v5 == 1;
  else
    v7 = 0;
  if (!v7)
    return 1;
LABEL_15:
  v9 = *(_QWORD *)(v6 + 16);
  v28 = *(unsigned __int8 **)(v6 + 8);
  v29 = v9;
  v10 = x509_parse(&v28, v6);
  if (!v10)
  {
LABEL_18:
    ERR_put_error(16, 0, 11, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_x509.cc", 427);
    return 0;
  }
  v11 = v10;
  if (v29)
  {
    X509_free(v10);
    goto LABEL_18;
  }
  v12 = (char *)malloc_type_malloc(0x90uLL, 0x30772F57uLL);
  if (v12)
  {
    v13 = v12;
    *(_QWORD *)v12 = 136;
    *(_OWORD *)(v12 + 8) = 0u;
    v14 = (X509_STORE_CTX *)(v12 + 8);
    *(_OWORD *)(v12 + 24) = 0u;
    *(_OWORD *)(v12 + 40) = 0u;
    *(_OWORD *)(v12 + 56) = 0u;
    *(_OWORD *)(v12 + 72) = 0u;
    *(_OWORD *)(v12 + 88) = 0u;
    *(_OWORD *)(v12 + 104) = 0u;
    *(_OWORD *)(v12 + 120) = 0u;
    *((_QWORD *)v12 + 17) = 0;
    if (X509_STORE_CTX_init((X509_STORE_CTX *)(v12 + 8), *(X509_STORE **)(*(_QWORD *)(v2 + 104) + 248), v11, 0))
    {
      X509_verify_cert(v14);
      ERR_clear_error();
      v15 = *((_QWORD *)v13 + 11);
      if (v15)
      {
        v16 = (uint64_t *)OPENSSL_sk_dup(v15);
        if (v16)
        {
          v17 = (unint64_t *)v16;
          v18 = *v16;
          if (*v16)
          {
            v19 = 0;
            while (1)
            {
              v20 = v18 <= v19 ? 0 : *(_QWORD *)(v16[1] + 8 * v19);
              v21 = (unsigned int *)(v20 + 24);
              v22 = atomic_load(v21);
              if (v22 != -1)
                break;
LABEL_25:
              ++v19;
              v18 = *v16;
              if (v19 >= *v16)
                goto LABEL_41;
            }
            while (1)
            {
              v23 = __ldaxr(v21);
              if (v23 == v22)
              {
                if (!__stlxr(v22 + 1, v21))
                {
                  v24 = 1;
                  goto LABEL_35;
                }
              }
              else
              {
                __clrex();
              }
              v24 = 0;
LABEL_35:
              if ((v24 & 1) == 0)
              {
                v22 = v23;
                if (v23 != -1)
                  continue;
              }
              goto LABEL_25;
            }
          }
LABEL_41:
          v26 = (X509 *)OPENSSL_sk_shift(v16);
          X509_free(v26);
          v27 = *(_QWORD *)(v2 + 8);
          if (v27)
            v25 = bssl::ssl_cert_set1_chain(*(_QWORD *)(v27 + 32), v17);
          else
            v25 = 0;
          OPENSSL_sk_pop_free_ex(v17, (void (*)(uint64_t))bssl::internal::DeleterImpl<stack_st_X509,void>::Free(stack_st_X509*)::{lambda(void (*)(void *),void *)#1}::__invoke, 0);
          goto LABEL_45;
        }
      }
    }
    else
    {
      ERR_put_error(16, 0, 11, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_x509.cc", 434);
    }
    v25 = 0;
LABEL_45:
    X509_STORE_CTX_free(v14);
    goto LABEL_46;
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  ERR_put_error(16, 0, 11, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_x509.cc", 434);
  v25 = 0;
LABEL_46:
  X509_free(v11);
  return v25;
}

BOOL bssl::ssl_crypto_x509_ssl_ctx_new(bssl *this, ssl_ctx_st *a2)
{
  char *v3;
  char *v4;
  BOOL v5;

  *((_QWORD *)this + 31) = X509_STORE_new();
  v3 = (char *)malloc_type_malloc(0x68uLL, 0x30772F57uLL);
  if (v3)
  {
    *(_QWORD *)v3 = 96;
    *(_OWORD *)(v3 + 8) = 0u;
    v4 = v3 + 8;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 40) = 0u;
    *(_OWORD *)(v3 + 56) = 0u;
    *(_OWORD *)(v3 + 72) = 0u;
    *(_OWORD *)(v3 + 88) = 0u;
    *((_DWORD *)v3 + 8) = -1;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v4 = 0;
  }
  *((_QWORD *)this + 58) = v4;
  if (v4)
    v5 = *((_QWORD *)this + 31) == 0;
  else
    v5 = 1;
  return !v5;
}

void bssl::ssl_crypto_x509_ssl_ctx_free(bssl *this, ssl_ctx_st *a2)
{
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  unint64_t *v10;
  uint64_t v11;
  size_t v12;
  ASN1_VALUE *pval;

  v3 = (unint64_t *)*((_QWORD *)this + 50);
  if (v3)
  {
    v4 = *v3;
    if (*v3)
    {
      v5 = 0;
      do
      {
        if (*(_QWORD *)(v3[1] + 8 * v5))
        {
          pval = *(ASN1_VALUE **)(v3[1] + 8 * v5);
          ASN1_item_ex_free(&pval, &X509_NAME_it);
          v4 = *v3;
        }
        ++v5;
      }
      while (v5 < v4);
    }
    v6 = v3[1];
    if (v6)
    {
      v8 = *(_QWORD *)(v6 - 8);
      v7 = (void *)(v6 - 8);
      v9 = v8 + 8;
      if (v8 != -8)
        bzero(v7, v9);
      free(v7);
    }
    v11 = *(v3 - 1);
    v10 = v3 - 1;
    v12 = v11 + 8;
    if (v11 != -8)
      bzero(v10, v12);
    free(v10);
  }
  *((_QWORD *)this + 50) = 0;
  X509_VERIFY_PARAM_free(*((X509_VERIFY_PARAM **)this + 58));
  X509_STORE_free(*((X509_STORE **)this + 31));
}

void bssl::ssl_crypto_x509_ssl_ctx_flush_cached_client_CA(bssl *this, ssl_ctx_st *a2)
{
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  unint64_t *v10;
  uint64_t v11;
  size_t v12;
  ASN1_VALUE *pval;

  v3 = (unint64_t *)*((_QWORD *)this + 50);
  if (v3)
  {
    v4 = *v3;
    if (*v3)
    {
      v5 = 0;
      do
      {
        if (*(_QWORD *)(v3[1] + 8 * v5))
        {
          pval = *(ASN1_VALUE **)(v3[1] + 8 * v5);
          ASN1_item_ex_free(&pval, &X509_NAME_it);
          v4 = *v3;
        }
        ++v5;
      }
      while (v5 < v4);
    }
    v6 = v3[1];
    if (v6)
    {
      v8 = *(_QWORD *)(v6 - 8);
      v7 = (void *)(v6 - 8);
      v9 = v8 + 8;
      if (v8 != -8)
        bzero(v7, v9);
      free(v7);
    }
    v11 = *(v3 - 1);
    v10 = v3 - 1;
    v12 = v11 + 8;
    if (v11 != -8)
      bzero(v10, v12);
    free(v10);
  }
  *((_QWORD *)this + 50) = 0;
}

uint64_t bssl::ssl_cert_set1_chain(uint64_t a1, unint64_t *a2)
{
  uint64_t v4;
  uint64_t *i;
  uint64_t v6;
  unsigned int *v7;
  unint64_t v8;
  unint64_t v9;
  X509 *v10;
  int v11;
  char *v12;
  uint64_t v13;
  unsigned __int8 *v14;
  uint64_t v15;
  int appended;
  unsigned int *v17;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  X509 *v22;
  unint64_t v23;
  void *v24;
  uint64_t v25;
  size_t v26;
  unint64_t *v27;
  uint64_t v28;
  size_t v29;
  void *v30;
  unsigned __int8 *out;

  v4 = *(_QWORD *)(a1 + 24);
  for (i = *(uint64_t **)(v4 + 48); i; i = *(uint64_t **)(v4 + 48))
  {
    if ((unint64_t)*i < 2)
      break;
    v6 = *i - 1;
    v7 = *(unsigned int **)(i[1] + 8 * v6);
    *i = v6;
    CRYPTO_BUFFER_free(v7);
  }
  if (a2 && (v8 = *a2) != 0)
  {
    v9 = 0;
    while (1)
    {
      if (*a2 <= v9)
      {
        out = 0;
        v11 = i2d_X509(0, &out);
        if (v11 <= 0)
          return 0;
      }
      else
      {
        v10 = *(X509 **)(a2[1] + 8 * v9);
        out = 0;
        v11 = i2d_X509(v10, &out);
        if (v11 <= 0)
          return 0;
      }
      v12 = crypto_buffer_new(out, v11, 0, 0);
      if (out)
      {
        v14 = out - 8;
        v13 = *((_QWORD *)out - 1);
        if (v13 != -8)
          bzero(out - 8, v13 + 8);
        free(v14);
      }
      if (!v12)
        return 0;
      v15 = *(_QWORD *)(a1 + 24);
      v30 = v12;
      appended = ssl_credential_st::AppendIntermediateCert(v15, (unsigned int **)&v30);
      v17 = (unsigned int *)v30;
      v30 = 0;
      if (v17)
      {
        CRYPTO_BUFFER_free(v17);
        if ((appended & 1) == 0)
          return 0;
      }
      else if (!appended)
      {
        return 0;
      }
      if (v8 == ++v9)
        goto LABEL_21;
    }
  }
  else
  {
LABEL_21:
    v19 = *(unint64_t **)(a1 + 40);
    if (v19)
    {
      v20 = *v19;
      if (*v19)
      {
        v21 = 0;
        do
        {
          v22 = *(X509 **)(v19[1] + 8 * v21);
          if (v22)
          {
            X509_free(v22);
            v20 = *v19;
          }
          ++v21;
        }
        while (v21 < v20);
      }
      v23 = v19[1];
      if (v23)
      {
        v25 = *(_QWORD *)(v23 - 8);
        v24 = (void *)(v23 - 8);
        v26 = v25 + 8;
        if (v25 != -8)
          bzero(v24, v26);
        free(v24);
      }
      v28 = *(v19 - 1);
      v27 = v19 - 1;
      v29 = v28 + 8;
      if (v28 != -8)
        bzero(v27, v29);
      free(v27);
    }
    *(_QWORD *)(a1 + 40) = 0;
    return 1;
  }
}

uint64_t SSL_alert_from_verify_result(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 0x41)
    return 46;
  else
    return dword_208F30988[a1 - 1];
}

void bssl::internal::DeleterImpl<stack_st_X509,void>::Free(stack_st_X509*)::{lambda(void (*)(void *),void *)#1}::__invoke(int a1, X509 *a)
{
  X509_free(a);
}

char *OPENSSL_sk_new(uint64_t a1)
{
  char *v2;
  _QWORD *v3;
  char *v4;
  char *v5;

  v2 = (char *)malloc_type_malloc(0x30uLL, 0x30772F57uLL);
  if (v2)
  {
    v3 = v2;
    *(_QWORD *)v2 = 40;
    *(_OWORD *)(v2 + 8) = 0u;
    v4 = v2 + 8;
    *(_OWORD *)(v2 + 24) = 0u;
    *((_QWORD *)v2 + 5) = 0;
    v5 = (char *)malloc_type_malloc(0x28uLL, 0x30772F57uLL);
    if (v5)
    {
      *(_QWORD *)v5 = 32;
      *(_OWORD *)(v5 + 24) = 0u;
      *(_OWORD *)(v5 + 8) = 0u;
      v3[2] = v5 + 8;
      v3[4] = 4;
      v3[5] = a1;
      return v4;
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      if (*v3 != -8)
        __memset_chk();
      free(v3);
      return 0;
    }
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
}

char *OPENSSL_sk_new_null()
{
  char *v0;
  _QWORD *v1;
  char *v2;
  char *v3;

  v0 = (char *)malloc_type_malloc(0x30uLL, 0x30772F57uLL);
  if (v0)
  {
    v1 = v0;
    *(_QWORD *)v0 = 40;
    *(_OWORD *)(v0 + 8) = 0u;
    v2 = v0 + 8;
    *(_OWORD *)(v0 + 24) = 0u;
    *((_QWORD *)v0 + 5) = 0;
    v3 = (char *)malloc_type_malloc(0x28uLL, 0x30772F57uLL);
    if (v3)
    {
      *(_QWORD *)v3 = 32;
      *(_OWORD *)(v3 + 24) = 0u;
      *(_OWORD *)(v3 + 8) = 0u;
      v1[2] = v3 + 8;
      v1[4] = 4;
      v1[5] = 0;
      return v2;
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      if (*v1 != -8)
        __memset_chk();
      free(v1);
      return 0;
    }
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
}

void OPENSSL_sk_pop_free_ex(unint64_t *a1, void (*a2)(uint64_t), uint64_t a3)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;
  char *v12;
  uint64_t v13;
  size_t v14;

  if (a1)
  {
    v4 = *a1;
    if (*a1)
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)(a1[1] + 8 * v7))
        {
          a2(a3);
          v4 = *a1;
        }
        ++v7;
      }
      while (v7 < v4);
    }
    v8 = a1[1];
    if (v8)
    {
      v10 = *(_QWORD *)(v8 - 8);
      v9 = (void *)(v8 - 8);
      v11 = v10 + 8;
      if (v10 != -8)
        bzero(v9, v11);
      free(v9);
    }
    v13 = *(a1 - 1);
    v12 = (char *)(a1 - 1);
    v14 = v13 + 8;
    if (v13 != -8)
      bzero(v12, v14);
    free(v12);
  }
}

unint64_t *OPENSSL_sk_insert(unint64_t *result, uint64_t a2, unint64_t a3)
{
  unint64_t *v3;
  unint64_t v4;
  unint64_t v7;
  size_t v8;
  unint64_t v9;
  _QWORD *v10;

  if (!result)
    return result;
  v3 = result;
  v4 = *result;
  if (*result >= 0x7FFFFFFF)
  {
    ERR_put_error(14, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/stack/stack.c", 179);
    return 0;
  }
  v7 = result[3];
  if (v7 > v4 + 1)
    goto LABEL_9;
  if ((v7 & 0x8000000000000000) != 0)
    return 0;
  result = OPENSSL_realloc((_QWORD *)result[1], 16 * v7);
  if (result)
  {
    v3[1] = (unint64_t)result;
    v3[3] = 2 * v7;
    v4 = *v3;
LABEL_9:
    if (v4 <= a3)
    {
      v10 = (_QWORD *)(v3[1] + 8 * v4);
    }
    else
    {
      v8 = 8 * (v4 - a3);
      v9 = v3[1];
      if (v8)
      {
        memmove((void *)(v9 + 8 * a3 + 8), (const void *)(v9 + 8 * a3), v8);
        v4 = *v3;
        v9 = v3[1];
      }
      v10 = (_QWORD *)(v9 + 8 * a3);
    }
    *v10 = a2;
    result = (unint64_t *)(v4 + 1);
    *v3 = v4 + 1;
    *((_DWORD *)v3 + 4) = 0;
  }
  return result;
}

uint64_t OPENSSL_sk_delete_ptr(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  _QWORD *v6;
  size_t v7;
  uint64_t v9;

  if (!a1)
    return 0;
  v3 = *a1;
  if (!*a1)
    return 0;
  v5 = 0;
  v6 = (_QWORD *)a1[1];
  v7 = 8 * v3 - 8;
  while (*v6 != a2)
  {
    ++v5;
    v7 -= 8;
    ++v6;
    if (v3 == v5)
      return 0;
  }
  v9 = v3 - 1;
  if (v9 == v5)
    goto LABEL_10;
  if (v7)
  {
    memmove(v6, v6 + 1, v7);
    v5 = *a1 - 1;
LABEL_10:
    *a1 = v5;
    return a2;
  }
  *a1 = v9;
  return a2;
}

uint64_t OPENSSL_sk_find(uint64_t result, unint64_t *a2, uint64_t a3, uint64_t (*a4)(_QWORD, uint64_t, _QWORD))
{
  _QWORD *v6;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  int v15;

  if (!result)
    return result;
  v6 = (_QWORD *)result;
  if (!*(_QWORD *)(result + 32))
  {
    v10 = *(_QWORD *)result;
    if (*(_QWORD *)result)
    {
      v11 = *(_QWORD **)(result + 8);
      if (*v11 == a3)
      {
        v9 = 0;
        result = 1;
        if (!a2)
          return result;
        goto LABEL_28;
      }
      v9 = 0;
      v12 = v11 + 1;
      while (v10 - 1 != v9)
      {
        v13 = v12[v9++];
        if (v13 == a3)
        {
          result = v9 < v10;
          if (a2)
            goto LABEL_28;
          return result;
        }
      }
    }
    return 0;
  }
  if (!a3)
    return 0;
  v8 = *(_QWORD *)result;
  if (*(_DWORD *)(result + 16) || v8 < 2)
  {
    if (v8)
    {
      v14 = 0;
      while (1)
      {
        v9 = v14 + ((v8 - v14 - 1) >> 1);
        v15 = a4(v6[4], a3, *(_QWORD *)(v6[1] + 8 * v9));
        if (v15 >= 1)
        {
          v14 = v9 + 1;
        }
        else if (v15 < 0)
        {
          v8 = v14 + ((v8 - v14 - 1) >> 1);
        }
        else
        {
          if (v8 - v14 == 1)
            goto LABEL_27;
          v8 = v9 + 1;
        }
        if (v14 >= v8)
          return 0;
      }
    }
    return 0;
  }
  v9 = 0;
  while (a4(v6[4], a3, *(_QWORD *)(v6[1] + 8 * v9)))
  {
    if (++v9 >= *v6)
      return 0;
  }
LABEL_27:
  result = 1;
  if (a2)
LABEL_28:
    *a2 = v9;
  return result;
}

uint64_t OPENSSL_sk_shift(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;

  if (!a1)
    return 0;
  v2 = *a1;
  if (!*a1)
    return 0;
  v3 = (uint64_t *)a1[1];
  v4 = *v3;
  v5 = v2 - 1;
  if (v5)
  {
    if (8 * v5)
    {
      memmove(v3, v3 + 1, 8 * v5);
      v5 = *a1 - 1;
    }
  }
  *a1 = v5;
  return v4;
}

char *OPENSSL_sk_dup(uint64_t a1)
{
  char *v2;
  _QWORD *v3;
  char *v4;
  size_t v5;
  const void *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;

  if (!a1)
    return 0;
  v2 = (char *)malloc_type_malloc(0x30uLL, 0x30772F57uLL);
  if (v2)
  {
    v3 = v2;
    *(_OWORD *)(v2 + 8) = 0u;
    v4 = v2 + 8;
    *(_QWORD *)v2 = 40;
    *(_OWORD *)(v2 + 24) = 0u;
    *((_QWORD *)v2 + 5) = 0;
    v5 = 8 * *(_QWORD *)(a1 + 24);
    if (v5 != -8)
    {
      if (!v5)
        goto LABEL_10;
      v6 = *(const void **)(a1 + 8);
      v7 = malloc_type_malloc(v5 + 8, 0x30772F57uLL);
      if (v7)
      {
        *v7 = v5;
        v8 = v7 + 1;
        memcpy(v7 + 1, v6, v5);
        v3[1] = *(_QWORD *)a1;
        v3[2] = v8;
        *((_DWORD *)v3 + 6) = *(_DWORD *)(a1 + 16);
        v9 = *(_QWORD *)(a1 + 32);
        v3[4] = *(_QWORD *)(a1 + 24);
        v3[5] = v9;
        return v4;
      }
    }
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    if (*v3 == -8)
    {
LABEL_11:
      free(v3);
      return 0;
    }
LABEL_10:
    __memset_chk();
    goto LABEL_11;
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  return 0;
}

uint64_t OPENSSL_sk_sort(uint64_t result, uint64_t (*a2)(_QWORD, _QWORD, _QWORD))
{
  uint64_t v2;
  unint64_t v3;
  unint64_t i;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;

  if (result)
  {
    v2 = result;
    if (*(_QWORD *)(result + 32))
    {
      if (!*(_DWORD *)(result + 16))
      {
        v3 = *(_QWORD *)result;
        if (*(_QWORD *)result >= 2uLL)
        {
          for (i = (unint64_t)(*(_QWORD *)result - 2) >> 1; i < v3; --i)
          {
            v6 = (2 * i) | 1;
            if (v6 < v3)
            {
              v7 = 2 * i;
              v8 = i;
              do
              {
                result = a2(*(_QWORD *)(v2 + 32), *(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * v8), *(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * v6));
                if ((int)result >= 0)
                  v9 = v8;
                else
                  v9 = v6;
                if (v7 + 2 < v3)
                {
                  result = a2(*(_QWORD *)(v2 + 32), *(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * v9), *(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * (v7 + 2)));
                  if ((int)result < 0)
                    v9 = v7 + 2;
                }
                if (v8 == v9)
                  break;
                v10 = *(_QWORD *)(v2 + 8);
                v11 = *(_QWORD *)(v10 + 8 * v8);
                *(_QWORD *)(v10 + 8 * v8) = *(_QWORD *)(v10 + 8 * v9);
                *(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * v9) = v11;
                v7 = 2 * v9;
                v6 = (2 * v9) | 1;
                v8 = v9;
              }
              while (v6 < v3);
              v3 = *(_QWORD *)v2;
            }
          }
          v12 = v3 - 1;
          if (v12)
          {
            while (1)
            {
              v13 = *(uint64_t **)(v2 + 8);
              v14 = *v13;
              *v13 = v13[v12];
              *(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * v12) = v14;
              if (v12 == 1)
                break;
              v15 = 0;
              v16 = 0;
              v17 = 1;
              do
              {
                result = a2(*(_QWORD *)(v2 + 32), *(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * v16), *(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * v17));
                if ((int)result >= 0)
                  v18 = v16;
                else
                  v18 = v17;
                v19 = v15 + 2;
                if (v19 < v12)
                {
                  result = a2(*(_QWORD *)(v2 + 32), *(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * v18), *(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * v19));
                  if ((int)result < 0)
                    v18 = v19;
                }
                if (v16 == v18)
                  break;
                v20 = *(_QWORD *)(v2 + 8);
                v21 = *(_QWORD *)(v20 + 8 * v16);
                *(_QWORD *)(v20 + 8 * v16) = *(_QWORD *)(v20 + 8 * v18);
                *(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * v18) = v21;
                v15 = 2 * v18;
                v17 = (2 * v18) | 1;
                v16 = v18;
              }
              while (v17 < v12);
              --v12;
            }
          }
        }
        *(_DWORD *)(v2 + 16) = 1;
      }
    }
  }
  return result;
}

uint64_t bssl::tls1_configure_aead(uint64_t a1, unsigned int a2, const void **a3, uint64_t a4, char *a5, size_t a6)
{
  uint64_t v12;
  unsigned int v13;
  const ssl_cipher_st *v14;
  size_t v15;
  unint64_t v16;
  BOOL v17;
  int v18;
  int v19;
  uint64_t v20;
  unint64_t v22;
  char *v23;
  size_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  size_t v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  size_t v33;
  _QWORD *v34;
  int8x16_t *v35;
  uint64_t v36;
  uint64_t *handshake_digest;
  size_t v38;
  size_t v39;
  _QWORD *v40;
  char *v41;
  uint64_t (*v42)(uint64_t, uint64_t, void **, _QWORD, _QWORD);
  _QWORD *v43;
  uint64_t (*v44)(uint64_t, uint64_t, _QWORD **, _QWORD, _QWORD);
  uint64_t v45;
  char *v46;
  uint64_t v47;
  size_t v48;
  _QWORD *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  size_t v53;
  unint64_t v54;
  void *v55;
  _QWORD *v56;
  unint64_t v57;
  size_t v58;
  void *v59;

  v12 = *(_QWORD *)(a4 + 200);
  v59 = 0;
  v13 = *(unsigned __int16 *)(a1 + 16);
  if (v13 - 769 >= 4)
  {
    if (v13 == 65277)
    {
      v13 = 771;
    }
    else if (v13 == 65279)
    {
      v13 = 770;
    }
    else
    {
      v13 = 0;
    }
  }
  v57 = 0;
  v58 = 0;
  if ((bssl::ssl_cipher_get_evp_aead((int **)&v59, &v58, (uint64_t *)&v57, v12, v13, **(_BYTE **)a1) & 1) == 0)
  {
    v18 = 130;
    v19 = 173;
    goto LABEL_7;
  }
  v15 = v58;
  v16 = *(unsigned __int8 *)v59;
  if (v58)
  {
    v17 = v16 >= v57 + v58;
    v16 -= v57 + v58;
    if (!v17)
    {
      v18 = 68;
      v19 = 183;
LABEL_7:
      ERR_put_error(16, 0, v18, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/t1_enc.cc", v19);
      return 0;
    }
  }
  v22 = (unint64_t)a3[1];
  if (v22)
  {
    v23 = (char *)*a3;
    if (((*(_BYTE *)(a1 + 164) & 1) == 0) == a2)
      goto LABEL_15;
  }
  else
  {
    v29 = 2 * (v57 + v16 + v58);
    v30 = *a3;
    if (*a3)
    {
      v32 = *(v30 - 1);
      v31 = (char *)(v30 - 1);
      v33 = v32 + 8;
      if (v32 != -8)
        bzero(v31, v33);
      free(v31);
    }
    *a3 = 0;
    a3[1] = 0;
    if (v29)
    {
      if (v29 > 0xFFFFFFFFFFFFFFF7 || (v34 = malloc_type_malloc(v29 + 8, 0x30772F57uLL)) == 0)
      {
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        v20 = 0;
        *a3 = 0;
        return v20;
      }
      *v34 = v29;
      v35 = (int8x16_t *)(v34 + 1);
      *a3 = v34 + 1;
      a3[1] = (const void *)v29;
    }
    else
    {
      v35 = 0;
    }
    v36 = *(unsigned __int16 *)(a4 + 4);
    v54 = *(unsigned __int8 *)(a4 + 10);
    if ((v36 - 769) >= 4)
    {
      if ((_DWORD)v36 == 65277)
      {
        v36 = 771;
      }
      else if ((_DWORD)v36 == 65279)
      {
        v36 = 770;
      }
      else
      {
        v36 = 0;
      }
    }
    handshake_digest = bssl::ssl_get_handshake_digest((bssl *)v36, *(_QWORD *)(a4 + 200), v14);
    if (CRYPTO_tls1_prf((EVP_MD *)handshake_digest, v35, v29, (char *)(a4 + 11), v54, (uint64_t)"key expansion", 13, *(_QWORD *)(a1 + 48) + 16, 32, *(_QWORD *)(a1 + 48) + 48, 32) != 1)return 0;
    v23 = (char *)*a3;
    v22 = (unint64_t)a3[1];
    if (((*(_BYTE *)(a1 + 164) & 1) == 0) == a2)
    {
LABEL_15:
      if (v22 >= v15)
        v24 = v15;
      else
        v24 = v22;
      v25 = 2 * v15;
      if (v22 >= 2 * v15)
      {
        v26 = 2 * (v15 + v16);
        if (v22 >= v26)
        {
          v27 = v57;
          v28 = v23;
          goto LABEL_48;
        }
      }
LABEL_73:
      abort();
    }
  }
  if (v22 < v15)
    goto LABEL_73;
  v25 = v16 + 2 * v15;
  if (v22 < v25)
    goto LABEL_73;
  v24 = v22 - v15 >= v15 ? v15 : v22 - v15;
  v27 = v57;
  v26 = v57 + 2 * (v15 + v16);
  if (v22 < v26)
    goto LABEL_73;
  v28 = &v23[v15];
LABEL_48:
  if (v22 - v25 >= v16)
    v38 = v16;
  else
    v38 = v22 - v25;
  v39 = v22 - v26;
  if (v39 >= v27)
    v39 = v27;
  if (a6)
  {
    if (a6 != v27)
      return 0;
  }
  else
  {
    a5 = &v23[v26];
    a6 = v39;
  }
  bssl::SSLAEADContext::Create(a2, *(unsigned __int16 *)(a1 + 16), **(_BYTE **)a1, *(_QWORD *)(a4 + 200), &v23[v25], v38, v28, v24, &v59, a5, a6);
  v40 = v59;
  if (!v59)
    return 0;
  v41 = *(char **)a1;
  if (!a2)
  {
    v44 = (uint64_t (*)(uint64_t, uint64_t, _QWORD **, _QWORD, _QWORD))*((_QWORD *)v41 + 17);
    v59 = 0;
    v56 = v40;
    v20 = v44(a1, 3, &v56, 0, 0);
    v43 = v56;
    v56 = 0;
    if (!v43)
      goto LABEL_67;
LABEL_62:
    v45 = v43[1];
    if (v45)
    {
      (*(void (**)(_QWORD *))(v45 + 24))(v43 + 1);
      v43[1] = 0;
    }
    v47 = *(v43 - 1);
    v46 = (char *)(v43 - 1);
    v48 = v47 + 8;
    if (v47 != -8)
      bzero(v46, v48);
    free(v46);
    goto LABEL_67;
  }
  v42 = (uint64_t (*)(uint64_t, uint64_t, void **, _QWORD, _QWORD))*((_QWORD *)v41 + 18);
  v59 = 0;
  v55 = v40;
  v20 = v42(a1, 3, &v55, 0, 0);
  v43 = v55;
  v55 = 0;
  if (v43)
    goto LABEL_62;
LABEL_67:
  v49 = v59;
  v59 = 0;
  if (v49)
  {
    v50 = v49[1];
    if (v50)
    {
      (*(void (**)(_QWORD *))(v50 + 24))(v49 + 1);
      v49[1] = 0;
    }
    v52 = *(v49 - 1);
    v51 = (char *)(v49 - 1);
    v53 = v52 + 8;
    if (v52 != -8)
      bzero(v51, v53);
    free(v51);
  }
  return v20;
}

uint64_t bssl::tls1_generate_master_secret(uint64_t a1, int8x16_t *a2, char *a3, unint64_t a4)
{
  unint64_t v9;
  unsigned __int8 v10[64];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a1 + 1570) & 1) != 0)
  {
    v9 = 0;
    if (!bssl::SSLTranscript::GetHash((bssl::SSLTranscript *)(a1 + 408), v10, &v9)
      || CRYPTO_tls1_prf(*(EVP_MD **)(a1 + 416), a2, 0x30uLL, a3, a4, (uint64_t)"extended master secret", 22, (uint64_t)v10, v9, 0, 0) != 1)
    {
      return 0;
    }
    return 48;
  }
  if (CRYPTO_tls1_prf(*(EVP_MD **)(a1 + 416), a2, 0x30uLL, a3, a4, (uint64_t)"master secret", 13, *(_QWORD *)(*(_QWORD *)a1 + 48) + 48, 32, *(_QWORD *)(*(_QWORD *)a1 + 48) + 16, 32) == 1)return 48;
  return 0;
}

uint64_t SSL_export_keying_material(uint64_t a1, int8x16_t *a2, const ssl_cipher_st *a3, const void *a4, size_t a5, const void *a6, size_t a7, uint64_t a8)
{
  int v8;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  void *v19;
  const void *v20;
  _BOOL8 v21;
  uint64_t v22;
  const char *v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  char *v28;
  const ssl_cipher_st *v29;
  _QWORD *v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t *handshake_digest;

  v8 = a8;
  v16 = *(_QWORD *)(a1 + 48);
  if ((*(_WORD *)(v16 + 220) & 2) != 0 && *(_WORD *)(a1 + 16) == 772)
  {
    v17 = *(unsigned __int8 *)(v16 + 434);
    if (*(_BYTE *)(v16 + 434))
    {
      if ((_DWORD)a8)
        v18 = a7;
      else
        v18 = 0;
      v19 = (void *)(v16 + 384);
      if ((_DWORD)a8)
        v20 = a6;
      else
        v20 = 0;
      return bssl::tls13_export_keying_material(a1, (uint64_t)a2, a3, v19, v17, a4, a5, a8, v20, v18);
    }
    v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/t1_enc.cc";
    v24 = 16;
    v25 = 284;
    v26 = 339;
LABEL_35:
    ERR_put_error(v24, 0, v25, v23, v26);
    return 0;
  }
  v22 = *(_QWORD *)(v16 + 280);
  if (v22 && (*(_WORD *)(v22 + 1568) & 0x208) == 0)
  {
    v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/t1_enc.cc";
    v24 = 16;
    v25 = 284;
    v26 = 355;
    goto LABEL_35;
  }
  if ((_DWORD)a8)
  {
    if (a7 >= 0x10000)
    {
      v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/t1_enc.cc";
      v24 = 16;
      v25 = 69;
      v26 = 362;
      goto LABEL_35;
    }
    v27 = a7 + 66;
    v28 = (char *)malloc_type_malloc(a7 + 74, 0x30772F57uLL);
    if (!v28)
    {
LABEL_29:
      v23 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
      v24 = 14;
      v25 = 65;
      v26 = 247;
      goto LABEL_35;
    }
  }
  else
  {
    v27 = 64;
    v28 = (char *)malloc_type_malloc(0x48uLL, 0x30772F57uLL);
    if (!v28)
      goto LABEL_29;
  }
  v30 = v28;
  *(_QWORD *)v28 = v27;
  v31 = *(_QWORD *)(a1 + 48);
  v32 = *(_OWORD *)(v31 + 48);
  *(_OWORD *)(v28 + 24) = *(_OWORD *)(v31 + 64);
  *(_OWORD *)(v28 + 8) = v32;
  v33 = *(_QWORD *)(a1 + 48);
  v34 = *(_OWORD *)(v33 + 16);
  *(_OWORD *)(v28 + 56) = *(_OWORD *)(v33 + 32);
  *(_OWORD *)(v28 + 40) = v34;
  if (v8)
  {
    *((_WORD *)v28 + 36) = bswap32(a7) >> 16;
    if (a7)
      memcpy(v28 + 74, a6, a7);
  }
  v35 = *(_QWORD *)(a1 + 48);
  v36 = *(_QWORD *)(v35 + 464);
  if (!v36)
  {
    v37 = *(_QWORD **)(v35 + 280);
    v36 = v37[189];
    if (!v36)
    {
      v36 = v37[188];
      if (!v36)
        v36 = *(_QWORD *)(*v37 + 88);
    }
  }
  v38 = *(unsigned __int16 *)(v36 + 4);
  if ((v38 - 769) >= 4)
  {
    if ((_DWORD)v38 == 65277)
    {
      v38 = 771;
    }
    else if ((_DWORD)v38 == 65279)
    {
      v38 = 770;
    }
    else
    {
      v38 = 0;
    }
  }
  handshake_digest = bssl::ssl_get_handshake_digest((bssl *)v38, *(_QWORD *)(v36 + 200), v29);
  v21 = CRYPTO_tls1_prf((EVP_MD *)handshake_digest, a2, (size_t)a3, (char *)(v36 + 11), *(unsigned __int8 *)(v36 + 10), (uint64_t)a4, a5, (uint64_t)(v30 + 1), v27, 0, 0) == 1;
  if (*v30 != -8)
    bzero(v30, *v30 + 8);
  free(v30);
  return v21;
}

int X509_NAME_print(BIO *bp, X509_NAME *name, int obase)
{
  char *v4;
  char *v5;
  int v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int (__cdecl *bwrite)(BIO *, const char *, int);
  int v13;
  int v14;
  int v15;
  int (__cdecl *v16)(BIO *, const char *, int);
  int v17;
  int v18;
  char *v19;
  uint64_t v20;
  size_t v21;
  int v23;
  int v24;
  uint64_t v25;

  v4 = X509_NAME_oneline(name, 0, 0);
  if (v4)
  {
    v5 = v4;
    if (!*v4)
    {
LABEL_35:
      v18 = 1;
      v20 = *((_QWORD *)v5 - 1);
      v19 = v5 - 8;
      v21 = v20 + 8;
      if (v20 == -8)
        goto LABEL_37;
      goto LABEL_36;
    }
    v6 = (_DWORD)v4 + 1;
    v7 = (unsigned __int8 *)(v4 + 2);
    v8 = (_DWORD)v4 + 1;
    while (1)
    {
      v9 = *(v7 - 1);
      if (*(v7 - 1))
      {
        if (v9 != 47)
          goto LABEL_5;
        if (*v7 - 65 > 0x19
          || (v10 = v7[1], v10 != 61) && ((v10 - 65) > 0x19 || v7[2] != 61))
        {
          v9 = 47;
          goto LABEL_5;
        }
      }
      v11 = v8 - v6;
      if (!bp)
        break;
      if (!bp->method)
        break;
      bwrite = bp->method->bwrite;
      if (!bwrite)
        break;
      if (!LODWORD(bp->cb_arg))
      {
        v14 = 114;
        v15 = 171;
        goto LABEL_21;
      }
      if (v11 < 1)
      {
        if (v11)
          goto LABEL_42;
        goto LABEL_23;
      }
      v13 = ((uint64_t (*)(BIO *))bwrite)(bp);
      if (v13 < 1)
        goto LABEL_22;
      bp->prev_bio = (bio_st *)((char *)bp->prev_bio + v13);
      if (v11 != v13)
        goto LABEL_42;
LABEL_23:
      if (!*(v7 - 1))
        goto LABEL_35;
      if (!bp || !bp->method || (v16 = bp->method->bwrite) == 0)
      {
        v23 = 115;
        v24 = 167;
        goto LABEL_41;
      }
      if (!LODWORD(bp->cb_arg))
      {
        v23 = 114;
        v24 = 171;
LABEL_41:
        ERR_put_error(17, 0, v23, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v24);
LABEL_42:
        ERR_put_error(11, 0, 7, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/t_x509.c", 325);
        v18 = 0;
        v25 = *((_QWORD *)v5 - 1);
        v19 = v5 - 8;
        v21 = v25 + 8;
        if (v25 == -8)
        {
LABEL_37:
          free(v19);
          return v18;
        }
LABEL_36:
        bzero(v19, v21);
        goto LABEL_37;
      }
      v17 = ((uint64_t (*)(BIO *, const char *, uint64_t))v16)(bp, ", ", 2);
      if (v17 < 1)
        goto LABEL_42;
      bp->prev_bio = (bio_st *)((char *)bp->prev_bio + v17);
      if (v17 != 2)
        goto LABEL_42;
      v9 = *(v7 - 1);
      v6 = (int)v7;
LABEL_5:
      ++v7;
      ++v8;
      if (!v9)
        goto LABEL_35;
    }
    v14 = 115;
    v15 = 167;
LABEL_21:
    ERR_put_error(17, 0, v14, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v15);
    v13 = -2;
LABEL_22:
    if (v11 != v13)
      goto LABEL_42;
    goto LABEL_23;
  }
  return 0;
}

uint64_t asn1_item_ex_d2i(uint64_t result, unsigned __int8 **a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, int a8, int a9)
{
  ASN1_TYPE **v10;
  uint64_t v11;
  const char *v12;
  int v13;
  int v14;
  int v16;
  int v18;
  int *v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  char object;
  int v24;
  int v25;
  uint64_t v26;
  unsigned int (*v27)(uint64_t, ASN1_TYPE **, uint64_t, _QWORD);
  char v28;
  uint64_t v29;
  unsigned int (*v30)(uint64_t, ASN1_TYPE **, uint64_t, _QWORD);
  ASN1_TYPE *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t i;
  const ASN1_TEMPLATE *v43;
  _QWORD *v44;
  const ASN1_OBJECT *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  const ASN1_OBJECT *v51;
  int v52;
  uint64_t v53;
  int v54;
  ASN1_VALUE **v55;
  unsigned __int8 *v56;
  int v57;
  uint64_t v58;
  const ASN1_TEMPLATE *v59;
  unsigned __int8 *v60;
  char v61;
  unsigned int (*v62)(uint64_t, ASN1_TYPE **, uint64_t, _QWORD);
  uint64_t omax;
  char omaxa;
  unsigned int v65;
  char v66;
  unsigned __int8 *v67;
  unsigned __int8 *pp;
  uint64_t plength;
  int pclass;
  int ptag;

  if (!result)
    return result;
  v10 = (ASN1_TYPE **)result;
  v66 = 0;
  v65 = 0;
  if (a3 >= 0x3FFFFFFF)
    v11 = 0x3FFFFFFFLL;
  else
    v11 = a3;
  if (a9 >= 30)
  {
    v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/asn1/tasn_dec.c";
    v13 = 192;
    v14 = 222;
    goto LABEL_7;
  }
  result = 0;
  v16 = a7;
  v18 = a9 + 1;
  switch(*(_BYTE *)a4)
  {
    case 0:
      v19 = *(int **)(a4 + 8);
      if (!v19)
        return asn1_d2i_ex_primitive(v10, a2, v11, a4, a5, a6, a7);
      if (a5 != -1 || (_DWORD)a7)
      {
        v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/asn1/tasn_dec.c";
        v13 = 136;
        v14 = 234;
        goto LABEL_7;
      }
      return asn1_template_ex_d2i((uint64_t)v10, a2, v11, v19, 0, a8, a9 + 1);
    case 1:
      v20 = *a2;
      if (a5 == -1)
        v21 = 0;
      else
        v21 = a6;
      ptag = 0;
      if (a5 == -1)
        v22 = 16;
      else
        v22 = a5;
      pclass = 0;
      pp = v20;
      plength = 0;
      object = ASN1_get_object((const unsigned __int8 **)&pp, &plength, &ptag, &pclass, v11);
      if (object < 0)
      {
        v24 = 103;
        v25 = 941;
        goto LABEL_35;
      }
      if ((v22 & 0x80000000) == 0 && (ptag != v22 || pclass != v21))
      {
        if (v16)
          return 0xFFFFFFFFLL;
        v24 = 190;
        v25 = 950;
LABEL_35:
        ERR_put_error(12, 0, v24, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", v25);
        v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/asn1/tasn_dec.c";
        v13 = 158;
        v14 = 367;
        goto LABEL_7;
      }
      omax = plength;
      v67 = pp;
      if ((object & 0x20) == 0)
      {
        v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/asn1/tasn_dec.c";
        v13 = 169;
        v14 = 373;
        goto LABEL_7;
      }
      if (!*v10 && !ASN1_item_ex_new((ASN1_VALUE **)v10, (const ASN1_ITEM *)a4))
      {
        v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/asn1/tasn_dec.c";
        v13 = 158;
        v14 = 378;
        goto LABEL_7;
      }
      v29 = *(_QWORD *)(a4 + 24);
      if (v29 && (v30 = *(unsigned int (**)(uint64_t, ASN1_TYPE **, uint64_t, _QWORD))(v29 + 16)) != 0)
      {
        v62 = v30;
        if (!v30(4, v10, a4, 0))
          goto LABEL_139;
        v61 = 0;
      }
      else
      {
        v62 = 0;
        v61 = 1;
      }
      v41 = *(_QWORD *)(a4 + 8);
      v40 = *(_QWORD *)(a4 + 16);
      if (v40 < 1)
        goto LABEL_110;
      for (i = 0; i < v40; ++i)
      {
        if ((*(_BYTE *)(v41 + 1) & 3) != 0)
        {
          v44 = *(_QWORD **)(v41 + 24);
          v45 = *(const ASN1_OBJECT **)((char *)&(*v10)->type + v44[1]);
          if (v45)
          {
            v46 = OBJ_obj2nid(v45);
            v47 = v44[4];
            if (v47 < 1)
            {
LABEL_76:
              v43 = (const ASN1_TEMPLATE *)v44[5];
              if (!v43)
                goto LABEL_78;
            }
            else
            {
              v43 = (const ASN1_TEMPLATE *)(v44[3] + 8);
              while (LODWORD(v43[-1].item) != v46)
              {
                ++v43;
                if (!--v47)
                  goto LABEL_76;
              }
            }
LABEL_77:
            ASN1_template_free((ASN1_VALUE **)((char *)*v10 + v43->tag), v43);
            goto LABEL_78;
          }
          v43 = (const ASN1_TEMPLATE *)v44[6];
          if (v43)
            goto LABEL_77;
        }
LABEL_78:
        v41 += 32;
        v40 = *(_QWORD *)(a4 + 16);
      }
      v41 = *(_QWORD *)(a4 + 8);
      if (v40 < 1)
      {
LABEL_110:
        LODWORD(v49) = 0;
LABEL_111:
        if (omax)
        {
          v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl"
                "/src/crypto/asn1/tasn_dec.c";
          v13 = 168;
          v14 = 442;
          goto LABEL_7;
        }
LABEL_131:
        v58 = v49;
        if (v40 > v49)
        {
          do
          {
            v59 = asn1_do_adb((ASN1_VALUE **)v10, (const ASN1_TEMPLATE *)v41, 1);
            if (!v59)
              goto LABEL_8;
            v35 = (uint64_t)v59;
            if ((v59->flags & 1) == 0)
            {
              v37 = 121;
              v38 = 461;
              goto LABEL_70;
            }
            ASN1_template_free((ASN1_VALUE **)((char *)*v10 + v59->tag), v59);
            v41 += 32;
          }
          while (*(_QWORD *)(a4 + 16) > ++v58);
        }
        v60 = v67;
        if (asn1_enc_save((ASN1_VALUE **)v10, *a2, (_DWORD)v67 - *(_DWORD *)a2, (const ASN1_ITEM *)a4)
          && ((v61 & 1) != 0 || v62(5, v10, a4, 0)))
        {
          *a2 = v60;
          return 1;
        }
        goto LABEL_139;
      }
      v49 = 0;
      while (1)
      {
        v35 = v41;
        if ((*(_BYTE *)(v41 + 1) & 3) == 0)
          goto LABEL_102;
        v50 = *(_QWORD **)(v41 + 24);
        v51 = *(const ASN1_OBJECT **)((char *)&(*v10)->type + v50[1]);
        if (!v51)
          break;
        v52 = OBJ_obj2nid(v51);
        v53 = v50[4];
        if (v53 < 1)
        {
LABEL_99:
          v35 = v50[5];
          if (!v35)
            goto LABEL_140;
        }
        else
        {
          v35 = v50[3] + 8;
          while (*(_DWORD *)(v35 - 8) != v52)
          {
            v35 += 40;
            if (!--v53)
              goto LABEL_99;
          }
        }
LABEL_102:
        if (!omax)
        {
          v40 = *(_QWORD *)(a4 + 16);
          goto LABEL_131;
        }
        if (*(_QWORD *)(a4 + 16) - 1 == v49)
          v54 = 0;
        else
          v54 = *(_BYTE *)v35 & 1;
        v55 = (ASN1_VALUE **)((char *)*v10 + *(_QWORD *)(v35 + 8));
        v56 = v67;
        v57 = asn1_template_ex_d2i((uint64_t)v55, &v67, omax, (int *)v35, v54, a8, v18);
        if (v57 == -1)
        {
          ASN1_template_free(v55, (const ASN1_TEMPLATE *)v35);
          ++v49;
          v41 += 32;
          v40 = *(_QWORD *)(a4 + 16);
          if (v40 <= v49)
            goto LABEL_111;
        }
        else
        {
          if (!v57)
            goto LABEL_71;
          omax = &v56[omax] - v67;
          ++v49;
          v41 += 32;
          v40 = *(_QWORD *)(a4 + 16);
          if (v40 <= v49)
            goto LABEL_111;
        }
      }
      v35 = v50[6];
      if (v35)
        goto LABEL_102;
LABEL_140:
      v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src"
            "/crypto/asn1/tasn_utl.c";
      v13 = 186;
      v14 = 265;
LABEL_7:
      ERR_put_error(12, 0, v13, v12, v14);
LABEL_8:
      ASN1_item_ex_free((ASN1_VALUE **)v10, (const ASN1_ITEM *)a4);
      ERR_add_error_data(2, "Type=", *(_QWORD *)(a4 + 40));
      return 0;
    case 2:
      if (a5 != -1)
      {
        v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/asn1/tasn_dec.c";
        v13 = 193;
        v14 = 293;
        goto LABEL_7;
      }
      v26 = *(_QWORD *)(a4 + 24);
      if (v26)
      {
        v27 = *(unsigned int (**)(uint64_t, ASN1_TYPE **, uint64_t, _QWORD))(v26 + 16);
        if (v27)
        {
          if (!v27(4, v10, a4, 0))
            goto LABEL_139;
          v28 = 0;
LABEL_57:
          v31 = *v10;
          if (*v10)
          {
            v32 = *(unsigned int *)((char *)&v31->type + *(int *)(a4 + 4));
            if ((v32 & 0x80000000) == 0 && *(_QWORD *)(a4 + 16) > v32)
            {
              ASN1_template_free((ASN1_VALUE **)((char *)v31 + *(_QWORD *)(*(_QWORD *)(a4 + 8) + 32 * v32 + 8)), (const ASN1_TEMPLATE *)(*(_QWORD *)(a4 + 8) + 32 * v32));
              *(int *)((char *)&(*v10)->type + *(int *)(a4 + 4)) = -1;
            }
          }
          else if (!ASN1_item_ex_new((ASN1_VALUE **)v10, (const ASN1_ITEM *)a4))
          {
            v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borings"
                  "sl/src/crypto/asn1/tasn_dec.c";
            v13 = 158;
            v14 = 313;
            goto LABEL_7;
          }
          v67 = *a2;
          v33 = *(_QWORD *)(a4 + 16);
          if (v33 < 1)
          {
            v39 = 0;
            v34 = 0;
          }
          else
          {
            omaxa = v28;
            v34 = 0;
            v35 = *(_QWORD *)(a4 + 8);
            while (1)
            {
              v36 = asn1_template_ex_d2i((uint64_t)*v10 + *(_QWORD *)(v35 + 8), &v67, v11, (int *)v35, 1, a8, v18);
              if (v36 != -1)
                break;
              ++v34;
              v35 += 32;
              v33 = *(_QWORD *)(a4 + 16);
              if (v33 <= v34)
                goto LABEL_115;
            }
            if (!v36)
            {
              v37 = 158;
              v38 = 332;
LABEL_70:
              ERR_put_error(12, 0, v37, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", v38);
LABEL_71:
              ASN1_item_ex_free((ASN1_VALUE **)v10, (const ASN1_ITEM *)a4);
              ERR_add_error_data(4, "Field=", *(_QWORD *)(v35 + 16), ", Type=", *(_QWORD *)(a4 + 40));
              return 0;
            }
            v33 = *(_QWORD *)(a4 + 16);
LABEL_115:
            v39 = v34;
            v28 = omaxa;
          }
          if (v33 == v34)
          {
            if (!v16)
            {
              v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borin"
                    "gssl/src/crypto/asn1/tasn_dec.c";
              v13 = 163;
              v14 = 344;
              goto LABEL_7;
            }
            ASN1_item_ex_free((ASN1_VALUE **)v10, (const ASN1_ITEM *)a4);
            return 0xFFFFFFFFLL;
          }
          *(int *)((char *)&(*v10)->type + *(int *)(a4 + 4)) = v39;
          if ((v28 & 1) != 0 || v27(5, v10, a4, 0))
          {
            *a2 = v67;
            return 1;
          }
LABEL_139:
          v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl"
                "/src/crypto/asn1/tasn_dec.c";
          v13 = 101;
          v14 = 480;
          goto LABEL_7;
        }
      }
      else
      {
        v27 = 0;
      }
      v28 = 1;
      goto LABEL_57;
    case 4:
      if (a5 != -1)
      {
        v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/asn1/tasn_dec.c";
        v13 = 193;
        v14 = 282;
        goto LABEL_7;
      }
      return (*(uint64_t (**)(ASN1_TYPE **, unsigned __int8 **, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a4 + 24) + 16))(v10, a2, v11, a4, a7, 0);
    case 5:
      if (a5 != -1)
      {
        v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/asn1/tasn_dec.c";
        v13 = 193;
        v14 = 247;
        goto LABEL_7;
      }
      v67 = *a2;
      if (!asn1_check_tlen(&v65, &v66, &v67, v11))
      {
        v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/asn1/tasn_dec.c";
        v13 = 158;
        v14 = 255;
        goto LABEL_7;
      }
      if (v66)
      {
        if (v16)
          return 0xFFFFFFFFLL;
        v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/asn1/tasn_dec.c";
        v13 = 156;
        v14 = 265;
        goto LABEL_7;
      }
      if (v65 <= 0x1E)
        v48 = tag2bit[v65];
      else
        v48 = 0;
      if ((v48 & *(int *)(a4 + 4)) != 0)
        return asn1_d2i_ex_primitive(v10, a2, v11, a4, v65, 0, 0);
      if (!v16)
      {
        v12 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/s"
              "rc/crypto/asn1/tasn_dec.c";
        v13 = 157;
        v14 = 274;
        goto LABEL_7;
      }
      return 0xFFFFFFFFLL;
    default:
      return result;
  }
}

uint64_t asn1_template_ex_d2i(uint64_t result, unsigned __int8 **a2, uint64_t omax, int *a4, int a5, int a6, int a7)
{
  ASN1_VALUE **v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  char object;
  uint64_t v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unsigned __int8 *v23;
  unsigned __int8 *pp;
  uint64_t plength;
  int pclass[2];

  if (result)
  {
    v12 = (ASN1_VALUE **)result;
    v13 = *a4;
    if ((*a4 & 0x10) == 0)
      return asn1_template_noexp_d2i((unint64_t **)result, a2, omax, a4, a5, a6, a7);
    v14 = *a2;
    v15 = a4[1];
    plength = 0;
    *(_QWORD *)pclass = 0;
    pp = v14;
    object = ASN1_get_object((const unsigned __int8 **)&pp, &plength, &pclass[1], pclass, omax);
    if (object < 0)
    {
      v21 = 103;
      v22 = 941;
    }
    else
    {
      if (v15 < 0 || pclass[1] == v15 && pclass[0] == (v13 & 0xC0))
      {
        v18 = pp;
        v17 = plength;
        v23 = pp;
        if ((object & 0x20) != 0)
        {
          if (asn1_template_noexp_d2i((unint64_t **)v12, &v23, plength, a4, 0, a6, a7))
          {
            if (!(v18 - v23 + v17))
            {
              *a2 = v23;
              return 1;
            }
            ERR_put_error(12, 0, 119, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", 544);
            ASN1_template_free(v12, (const ASN1_TEMPLATE *)a4);
            return 0;
          }
          v19 = 158;
          v20 = 537;
        }
        else
        {
          v19 = 120;
          v20 = 531;
        }
LABEL_12:
        ERR_put_error(12, 0, v19, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", v20);
        return 0;
      }
      if (a5)
        return 0xFFFFFFFFLL;
      v21 = 190;
      v22 = 950;
    }
    ERR_put_error(12, 0, v21, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", v22);
    v19 = 158;
    v20 = 525;
    goto LABEL_12;
  }
  return result;
}

uint64_t asn1_d2i_ex_primitive(ASN1_TYPE **a1, unsigned __int8 **a2, uint64_t omax, uint64_t a4, int a5, int a6, int a7)
{
  int v9;
  int v14;
  int v15;
  int v16;
  BOOL v17;
  unsigned __int8 *v18;
  char object;
  uint64_t v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  unsigned __int8 *v25;
  unsigned __int8 *v26;
  unsigned __int8 *v27;
  int v28;
  ASN1_TYPE *v29;
  ASN1_INTEGER **p_value;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  unsigned __int8 v35;
  int v36;
  int v37;
  int v38;
  char v39;
  char v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  unsigned __int8 v44;
  int v45;
  unsigned int v46;
  unsigned __int8 v47;
  int v48;
  unsigned __int8 v49;
  BOOL v50;
  BOOL v51;
  BOOL v52;
  unint64_t v53;
  unsigned __int8 *v54;
  int v55;
  unsigned int v56;
  BOOL v57;
  unsigned __int8 *v59;
  unsigned __int8 *v60;
  int v61;
  int v62;
  BOOL v63;
  ASN1_INTEGER *v64;
  ASN1_STRING *v65;
  int ptag[2];
  __int128 plength;
  unsigned __int8 *pp;

  v9 = a5;
  if (*(_BYTE *)a4 == 5)
  {
    v14 = -1;
    if (a5 != -4)
      goto LABEL_10;
  }
  else
  {
    if (*(_DWORD *)(a4 + 4) != -4)
    {
      v14 = a5;
      v9 = *(_DWORD *)(a4 + 4);
      goto LABEL_10;
    }
    v14 = a5;
    if ((a5 & 0x80000000) == 0)
    {
      v15 = 137;
      v16 = 684;
LABEL_25:
      ERR_put_error(12, 0, v15, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", v16);
      return 0;
    }
  }
  if (a7)
  {
    v15 = 135;
    v16 = 688;
    goto LABEL_25;
  }
  v25 = *a2;
  *(_QWORD *)ptag = 0;
  pp = v25;
  if ((ASN1_get_object((const unsigned __int8 **)&pp, (uint64_t *)&plength, &ptag[1], ptag, omax) & 0x80) != 0)
  {
    ERR_put_error(12, 0, 103, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", 941);
    v15 = 158;
    v16 = 694;
    goto LABEL_25;
  }
  if (LOBYTE(ptag[0]) || (v9 = ptag[1], ptag[1] > 0x1Eu) || ((1 << SLOBYTE(ptag[1])) & 0x5FFF147E) == 0)
    v9 = -3;
LABEL_10:
  v17 = v14 == -1;
  v18 = *a2;
  if (v14 == -1)
    v14 = v9;
  if (v17)
    a6 = 0;
  *(_QWORD *)ptag = 0;
  *(_QWORD *)&plength = 0;
  pp = v18;
  object = ASN1_get_object((const unsigned __int8 **)&pp, (uint64_t *)&plength, &ptag[1], ptag, omax);
  if (object < 0)
  {
    v22 = 103;
    v23 = 941;
LABEL_24:
    ERR_put_error(12, 0, v22, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", v23);
    v15 = 158;
    v16 = 709;
    goto LABEL_25;
  }
  if ((v14 & 0x80000000) == 0 && (ptag[1] != v14 || ptag[0] != a6))
  {
    if (a7)
      return 0xFFFFFFFFLL;
    v22 = 190;
    v23 = 950;
    goto LABEL_24;
  }
  v20 = plength;
  v21 = pp;
  if ((v9 + 3) <= 0x14 && ((1 << (v9 + 3)) & 0x180001) != 0)
  {
    if (v9 != -3 && (object & 0x20) == 0)
    {
      v15 = 178;
      v16 = 720;
      goto LABEL_25;
    }
    v26 = *a2;
    v27 = (unsigned __int8 *)(&pp[plength] - *a2);
    v28 = *(_DWORD *)(a4 + 4);
    pp = *a2;
    if (v28 == -4)
      goto LABEL_33;
  }
  else
  {
    if ((object & 0x20) != 0)
    {
      v15 = 179;
      v16 = 731;
      goto LABEL_25;
    }
    v26 = pp;
    v27 = (unsigned __int8 *)plength;
    if (*(_DWORD *)(a4 + 4) == -4)
    {
LABEL_33:
      v29 = *a1;
      if (!*a1)
      {
        *(_QWORD *)&plength = 0;
        if (!ASN1_item_ex_new((ASN1_VALUE **)&plength, (const ASN1_ITEM *)&ASN1_OBJECT_it.sname)
          || (v29 = (ASN1_TYPE *)plength) == 0)
        {
          *(_QWORD *)&plength = 0;
          ASN1_item_ex_free((ASN1_VALUE **)&plength, (const ASN1_ITEM *)&ASN1_OBJECT_it.sname);
          return 0;
        }
        *a1 = (ASN1_TYPE *)plength;
      }
      if (v29->type != v9)
        ASN1_TYPE_set(v29, v9, 0);
      p_value = (ASN1_INTEGER **)&v29->value;
      goto LABEL_44;
    }
  }
  v29 = 0;
  p_value = (ASN1_INTEGER **)a1;
  a1 = 0;
LABEL_44:
  switch(v9)
  {
    case 1:
      if (v27 == (unsigned __int8 *)1)
      {
        *(_DWORD *)p_value = *v26;
        goto LABEL_136;
      }
      ERR_put_error(12, 0, 106, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", 799);
      goto LABEL_138;
    case 2:
    case 10:
      if (!c2i_ASN1_INTEGER(p_value, (const unsigned __int8 **)&pp, (uint64_t)v27))
        goto LABEL_138;
      (*p_value)->type = (*p_value)->type & 0x100 | v9;
      goto LABEL_133;
    case 3:
      if (!c2i_ASN1_BIT_STRING(p_value, (const unsigned __int8 **)&pp, (uint64_t)v27))
        goto LABEL_138;
      goto LABEL_136;
    case 5:
      if (v27)
      {
        ERR_put_error(12, 0, 164, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", 791);
        goto LABEL_138;
      }
      *p_value = (ASN1_INTEGER *)1;
      goto LABEL_133;
    case 6:
      if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)p_value, (const unsigned __int8 **)&pp, (uint64_t)v27))
        goto LABEL_138;
      goto LABEL_136;
    default:
      *(_QWORD *)&plength = v26;
      *((_QWORD *)&plength + 1) = v27;
      switch(v9)
      {
        case 12:
          if (!v27)
            goto LABEL_128;
          v31 = v26;
          v32 = v27;
          v33 = v26;
          while (1)
          {
            v36 = (char)*v33++;
            v35 = v36;
            v34 = v32 - 1;
            if (v36 < 0)
            {
              v37 = v35;
              v38 = v35 & 0xE0;
              if (v38 == 192)
              {
                v39 = 0;
                v40 = 0;
                v41 = 128;
                v42 = 31;
                v43 = 1;
              }
              else if ((v35 & 0xF0) == 0xE0)
              {
                v40 = 0;
                v39 = 1;
                v41 = 2048;
                v42 = 15;
                v43 = 2;
              }
              else
              {
                if ((v35 & 0xF8) != 0xF0)
                  goto LABEL_96;
                v39 = 0;
                v40 = 1;
                v41 = 0x10000;
                v42 = 7;
                v43 = 3;
              }
              if (v32 == (unsigned __int8 *)1)
                goto LABEL_96;
              v44 = v31[1];
              if ((v44 & 0xC0) != 0x80)
                goto LABEL_96;
              v45 = v42 & v37;
              v46 = v44 & 0x3F | (v45 << 6);
              if (v38 != 192)
              {
                if (v32 == (unsigned __int8 *)2)
                  goto LABEL_96;
                v47 = v31[2];
                if ((v47 & 0xC0) != 0x80)
                  goto LABEL_96;
                v48 = v47 & 0x3F | (v46 << 6);
                if ((v39 & 1) != 0)
                {
                  v45 = v44 & 0x3F | (v45 << 6);
                  v46 = v48;
                }
                else
                {
                  if (v32 == (unsigned __int8 *)3)
                    goto LABEL_96;
                  v49 = v31[3];
                  if ((v49 & 0xC0) != 0x80 || (v40 & 1) == 0)
                    goto LABEL_96;
                  v46 = v49 & 0x3F | (v48 << 6);
                  v45 = v48;
                }
              }
              if ((v45 & 0x1FFE0) == 0x360
                || (v46 - 64976 >= 0x20 ? (v50 = v46 > 0x10FFFF) : (v50 = 1),
                    !v50 ? (v51 = (v46 & 0xFFFE) == 65534) : (v51 = 1),
                    !v51 ? (v52 = v46 >= v41) : (v52 = 0),
                    !v52))
              {
LABEL_96:
                ERR_put_error(12, 0, 150, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", 872);
                goto LABEL_138;
              }
              v33 += v43;
              v34 -= v43;
            }
            v31 = v33;
            v32 = v34;
            if (!v34)
              goto LABEL_128;
          }
        case 23:
          if (CBS_parse_rfc5280_time_internal(&plength, 0, 1, 0))
            goto LABEL_128;
          ERR_put_error(12, 0, 148, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", 879);
          goto LABEL_138;
        case 24:
          if (CBS_parse_rfc5280_time_internal(&plength, 1, 0, 0))
            goto LABEL_128;
          ERR_put_error(12, 0, 148, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", 886);
          goto LABEL_138;
        case 28:
          if (!v27)
            goto LABEL_128;
          if ((unint64_t)v27 < 4)
            goto LABEL_115;
          v53 = (unint64_t)v27;
          v54 = v26;
          do
          {
            v55 = (*v54 << 16) | (v54[1] << 8) | v54[2];
            if ((v55 & 0xFFFFF8) == 0xD8)
              break;
            v56 = v54[3] | (v55 << 8);
            v57 = v56 - 64976 < 0x20 || v56 > 0x10FFFF;
            if (v57 || (v56 & 0xFFFE) == 65534)
              break;
            if (v53 == 4)
              goto LABEL_128;
            v53 -= 4;
            v54 += 4;
          }
          while (v53 >= 4);
LABEL_115:
          ERR_put_error(12, 0, 149, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", 863);
          goto LABEL_138;
        case 30:
          if (!v27)
            goto LABEL_128;
          if (v27 == (unsigned __int8 *)1)
            goto LABEL_127;
          v59 = v27;
          v60 = v26;
          break;
        default:
          goto LABEL_128;
      }
      break;
  }
  while (1)
  {
    v61 = *v60;
    if ((v61 & 0xF8) == 0xD8
      || ((v62 = v60[1] | (v61 << 8), (v62 - 64976) >= 0x20) ? (v63 = (v62 & 0xFFFE) == 65534) : (v63 = 1),
          v63))
    {
LABEL_127:
      ERR_put_error(12, 0, 142, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", 854);
      goto LABEL_138;
    }
    if (v59 == (unsigned __int8 *)2)
      break;
    v60 += 2;
    v17 = v59 == (unsigned __int8 *)3;
    v59 -= 2;
    if (v17)
      goto LABEL_127;
  }
LABEL_128:
  v64 = *p_value;
  if (*p_value)
  {
    v64->type = v9;
    goto LABEL_132;
  }
  v65 = ASN1_STRING_type_new(v9);
  if (!v65)
  {
LABEL_138:
    *(_QWORD *)&plength = v29;
    ASN1_item_ex_free((ASN1_VALUE **)&plength, (const ASN1_ITEM *)&ASN1_OBJECT_it.sname);
    if (a1)
      *a1 = 0;
    return 0;
  }
  v64 = v65;
  *p_value = v65;
LABEL_132:
  if (!ASN1_STRING_set(v64, v26, (int)v27))
  {
    ASN1_STRING_free((BUF_MEM *)v64);
    *p_value = 0;
    goto LABEL_138;
  }
LABEL_133:
  if (v9 == 5 && v29)
    v29->value.ptr = 0;
LABEL_136:
  *a2 = &v21[v20];
  return 1;
}

uint64_t asn1_check_tlen(_DWORD *a1, _BYTE *a2, unsigned __int8 **a3, uint64_t omax)
{
  unsigned __int8 *pp;
  uint64_t plength;
  int pclass[2];

  *(_QWORD *)pclass = 0;
  pp = *a3;
  if ((ASN1_get_object((const unsigned __int8 **)&pp, &plength, &pclass[1], pclass, omax) & 0x80) != 0)
  {
    ERR_put_error(12, 0, 103, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", 941);
    return 0;
  }
  else
  {
    if (a2)
      *a2 = pclass[0];
    if (a1)
      *a1 = pclass[1];
    *a3 = pp;
    return 1;
  }
}

uint64_t asn1_template_noexp_d2i(unint64_t **a1, unsigned __int8 **a2, uint64_t a3, int *a4, int a5, int a6, int a7)
{
  int v13;
  int v14;
  unsigned __int8 *v15;
  int v16;
  uint64_t v17;
  uint64_t result;
  int v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  char *v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  unsigned __int8 *pp;
  uint64_t plength;
  int pclass[2];

  v13 = *a4;
  v14 = *a4 & 0xC0;
  v15 = *a2;
  v30 = *a2;
  if ((v13 & 6) == 0)
  {
    v17 = *((_QWORD *)a4 + 3);
    if ((v13 & 8) != 0)
    {
      result = asn1_item_ex_d2i((int)a1, (int)&v30, a3, v17, a4[1], v13 & 0xC0, a5, a6, a7);
      if ((_DWORD)result == -1)
        return result;
      if ((_DWORD)result)
        goto LABEL_33;
      v19 = 634;
    }
    else
    {
      result = asn1_item_ex_d2i((int)a1, (int)&v30, a3, v17, -1, 0, a5, a6, a7);
      if ((_DWORD)result == -1)
        return result;
      if ((_DWORD)result)
        goto LABEL_33;
      v19 = 644;
    }
LABEL_36:
    ERR_put_error(12, 0, 158, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", v19);
    goto LABEL_37;
  }
  if ((v13 & 8) != 0)
  {
    v16 = a4[1];
  }
  else
  {
    v14 = 0;
    if ((v13 & 2) != 0)
      v16 = 17;
    else
      v16 = 16;
  }
  plength = 0;
  *(_QWORD *)pclass = 0;
  pp = v15;
  if ((ASN1_get_object((const unsigned __int8 **)&pp, &plength, &pclass[1], pclass, a3) & 0x80) != 0)
  {
    v25 = 103;
    v26 = 941;
  }
  else
  {
    if (v16 < 0 || pclass[1] == v16 && pclass[0] == v14)
    {
      v20 = plength;
      v30 = pp;
      v21 = *a1;
      if (*a1)
      {
        plength = 0;
        v22 = *v21;
        if (*v21)
        {
          do
          {
            v23 = v22 - 1;
            v24 = *(_QWORD *)(v21[1] + 8 * v23);
            *v21 = v23;
            plength = v24;
            ASN1_item_ex_free((ASN1_VALUE **)&plength, *((const ASN1_ITEM **)a4 + 3));
            v22 = *v21;
          }
          while (*v21);
          v21 = *a1;
        }
        if (!v21)
          goto LABEL_37;
        goto LABEL_29;
      }
      v27 = OPENSSL_sk_new_null();
      *a1 = (unint64_t *)v27;
      if (v27)
      {
LABEL_29:
        if (v20 >= 1)
        {
          while (1)
          {
            v28 = v30;
            plength = 0;
            if (!asn1_item_ex_d2i((int)&plength, (int)&v30, v20, *((_QWORD *)a4 + 3), -1, 0, 0, a6, a7))
            {
              v19 = 620;
              goto LABEL_36;
            }
            v29 = v30;
            if (!OPENSSL_sk_insert(*a1, plength, **a1))
              break;
            v20 = &v28[v20] - v29;
            if (v20 <= 0)
              goto LABEL_33;
          }
          ASN1_item_ex_free((ASN1_VALUE **)&plength, *((const ASN1_ITEM **)a4 + 3));
          goto LABEL_37;
        }
LABEL_33:
        *a2 = v30;
        return 1;
      }
LABEL_37:
      ASN1_template_free((ASN1_VALUE **)a1, (const ASN1_TEMPLATE *)a4);
      return 0;
    }
    if (a5)
      return 0xFFFFFFFFLL;
    v25 = 190;
    v26 = 950;
  }
  ERR_put_error(12, 0, v25, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", v26);
  ERR_put_error(12, 0, 158, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_dec.c", 592);
  return 0;
}

int ASN1_item_i2d(ASN1_VALUE *val, unsigned __int8 **out, const ASN1_ITEM *it)
{
  unsigned int v5;
  int v7;
  _QWORD *v8;
  _QWORD *v9;
  unsigned __int8 *v10;
  int v11;
  int v12;
  void *v13;
  ASN1_VALUE *v14;

  v14 = val;
  if (!out || *out)
    return asn1_item_ex_i2d_opt((unint64_t **)&v14, (void **)out, (uint64_t)it, 0xFFFFFFFFLL, 0, 0);
  v7 = asn1_item_ex_i2d_opt((unint64_t **)&v14, 0, (uint64_t)it, 0xFFFFFFFFLL, 0, 0);
  v5 = v7;
  if (v7 >= 1)
  {
    v8 = malloc_type_malloc(v7 + 8, 0x30772F57uLL);
    if (v8)
    {
      v9 = v8;
      *v8 = v5;
      v10 = (unsigned __int8 *)(v8 + 1);
      v13 = v8 + 1;
      v11 = asn1_item_ex_i2d_opt((unint64_t **)&v14, &v13, (uint64_t)it, 0xFFFFFFFFLL, 0, 0);
      if (v11 <= 0)
      {
        v12 = v11;
        if (*v9 != -8)
          bzero(v9, *v9 + 8);
        free(v9);
        return v12;
      }
      else
      {
        *out = v10;
      }
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return -1;
    }
  }
  return v5;
}

uint64_t asn1_item_ex_i2d_opt(unint64_t **a1, void **a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t v6;
  unint64_t **v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v12;
  const char *v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  const ASN1_OBJECT *v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  const ASN1_OBJECT *v37;
  int v38;
  uint64_t v39;

  v6 = a3;
  v8 = a1;
  if (*(_BYTE *)a3)
  {
    v9 = *a1;
    if (*a1)
    {
      switch(*(_BYTE *)a3)
      {
        case 0:
          goto LABEL_4;
        case 1:
          v16 = *(_QWORD *)(a3 + 24);
          if (v16)
          {
            if ((*(_BYTE *)(v16 + 8) & 2) != 0)
            {
              v17 = *(int *)(v16 + 24);
              v18 = (char *)v9 + v17;
              v12 = *(unint64_t *)((char *)v9 + v17 + 8);
              if (v12)
              {
                if (a2)
                {
                  memcpy(*a2, *(const void **)v18, *(unint64_t *)((char *)v9 + v17 + 8));
                  v12 = *((_QWORD *)v18 + 1);
                  *a2 = (char *)*a2 + v12;
                }
                return v12;
              }
            }
          }
          if ((_DWORD)a4 == -1)
            v19 = 0;
          else
            v19 = a5;
          if ((_DWORD)a4 == -1)
            v20 = 16;
          else
            v20 = a4;
          if (*(uint64_t *)(a3 + 16) < 1)
          {
            v21 = 0;
LABEL_57:
            v32 = ASN1_object_size(1, v21, v20);
            v12 = v32;
            if (a2)
            {
              if ((_DWORD)v32 != -1)
              {
                ASN1_put_object((unsigned __int8 **)a2, 1, v21, v20, v19);
                if (*(uint64_t *)(v6 + 16) >= 1)
                {
                  v33 = 0;
                  v34 = *(_QWORD *)(v6 + 8);
                  do
                  {
                    v35 = v34;
                    if ((*(_BYTE *)(v34 + 1) & 3) != 0)
                    {
                      v36 = *(_QWORD **)(v34 + 24);
                      v37 = *(const ASN1_OBJECT **)((char *)*v8 + v36[1]);
                      if (v37)
                      {
                        v38 = OBJ_obj2nid(v37);
                        v39 = v36[4];
                        if (v39 < 1)
                        {
LABEL_67:
                          v35 = v36[5];
                          if (!v35)
                            goto LABEL_74;
                        }
                        else
                        {
                          v35 = v36[3] + 8;
                          while (*(_DWORD *)(v35 - 8) != v38)
                          {
                            v35 += 40;
                            if (!--v39)
                              goto LABEL_67;
                          }
                        }
                      }
                      else
                      {
                        v35 = v36[6];
                        if (!v35)
                          goto LABEL_74;
                      }
                    }
                    if ((asn1_template_ex_i2d((unint64_t **)((char *)*v8 + *(_QWORD *)(v35 + 8)), (unsigned __int8 **)a2, (int *)v35, 0xFFFFFFFFLL, 0, 0) & 0x80000000) != 0)return 0xFFFFFFFFLL;
                    v34 += 32;
                    ++v33;
                  }
                  while (*(_QWORD *)(v6 + 16) > v33);
                }
              }
            }
            return v12;
          }
          v21 = 0;
          v22 = 0;
          v23 = *(_QWORD *)(a3 + 8);
          while (1)
          {
            v24 = v23;
            if ((*(_BYTE *)(v23 + 1) & 3) != 0)
            {
              v25 = *(_QWORD **)(v23 + 24);
              v26 = *(const ASN1_OBJECT **)((char *)*v8 + v25[1]);
              if (v26)
              {
                v27 = OBJ_obj2nid(v26);
                v28 = v25[4];
                if (v28 < 1)
                {
LABEL_39:
                  v24 = v25[5];
                  if (!v24)
                    goto LABEL_74;
                }
                else
                {
                  v24 = v25[3] + 8;
                  while (*(_DWORD *)(v24 - 8) != v27)
                  {
                    v24 += 40;
                    if (!--v28)
                      goto LABEL_39;
                  }
                }
              }
              else
              {
                v24 = v25[6];
                if (!v24)
                {
LABEL_74:
                  v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/b"
                        "oringssl/src/crypto/asn1/tasn_utl.c";
                  v14 = 186;
                  v15 = 265;
                  goto LABEL_76;
                }
              }
            }
            v12 = 0xFFFFFFFFLL;
            v29 = asn1_template_ex_i2d((unint64_t **)((char *)*v8 + *(_QWORD *)(v24 + 8)), 0, (int *)v24, 0xFFFFFFFFLL, 0, 0);
            if (v29 == -1 || v29 > (v21 ^ 0x7FFFFFFF))
              break;
            v21 += v29;
            v23 += 32;
            if (*(_QWORD *)(v6 + 16) <= ++v22)
              goto LABEL_57;
          }
          break;
        case 2:
          if ((_DWORD)a4 != -1)
          {
            v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borings"
                  "sl/src/crypto/asn1/tasn_enc.c";
            v14 = 193;
            v15 = 171;
            goto LABEL_76;
          }
          v31 = *(unsigned int *)((char *)v9 + *(int *)(a3 + 4));
          if ((v31 & 0x80000000) != 0 || *(_QWORD *)(a3 + 16) <= v31)
          {
            v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borings"
                  "sl/src/crypto/asn1/tasn_enc.c";
            v14 = 163;
            v15 = 176;
          }
          else
          {
            v10 = *(_QWORD *)(a3 + 8) + 32 * v31;
            if ((*(_BYTE *)v10 & 1) == 0)
            {
              a1 = (unint64_t **)((char *)v9 + *(_QWORD *)(v10 + 8));
              a4 = 0xFFFFFFFFLL;
              LOBYTE(a5) = 0;
              a6 = 0;
              return asn1_template_ex_i2d(a1, (unsigned __int8 **)a2, (int *)v10, a4, a5, a6);
            }
            v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borings"
                  "sl/src/crypto/asn1/tasn_enc.c";
            v14 = 193;
            v15 = 181;
          }
          goto LABEL_76;
        case 4:
          if ((_DWORD)a4 != -1)
          {
            v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borings"
                  "sl/src/crypto/asn1/tasn_enc.c";
            v14 = 193;
            v15 = 191;
            goto LABEL_76;
          }
          v12 = (*(uint64_t (**)(unint64_t **, void **, uint64_t))(*(_QWORD *)(a3 + 24) + 24))(a1, a2, a3);
          if ((_DWORD)v12)
            return v12;
          v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl"
                "/src/crypto/asn1/tasn_enc.c";
          v14 = 68;
          v15 = 200;
          goto LABEL_76;
        case 5:
          if ((_DWORD)a4 != -1)
          {
            v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borings"
                  "sl/src/crypto/asn1/tasn_enc.c";
            v14 = 193;
            v15 = 162;
            goto LABEL_76;
          }
          LOBYTE(a5) = 0;
          return asn1_i2d_ex_primitive((ASN1_VALUE **)a1, (unsigned __int8 **)a2, a3, a4, a5, a6);
        default:
          v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl"
                "/src/crypto/asn1/tasn_enc.c";
          v14 = 193;
          v15 = 264;
          goto LABEL_76;
      }
      return v12;
    }
    if (a6)
      return 0;
    v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/asn1/tasn_enc.c";
    v14 = 155;
    v15 = 141;
LABEL_76:
    ERR_put_error(12, 0, v14, v13, v15);
    return 0xFFFFFFFFLL;
  }
LABEL_4:
  v10 = *(_QWORD *)(a3 + 8);
  if (v10)
  {
    if ((*(_BYTE *)v10 & 1) == 0)
      return asn1_template_ex_i2d(a1, (unsigned __int8 **)a2, (int *)v10, a4, a5, a6);
    v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/asn1/tasn_enc.c";
    v14 = 193;
    v15 = 150;
    goto LABEL_76;
  }
  a3 = v6;
  return asn1_i2d_ex_primitive((ASN1_VALUE **)a1, (unsigned __int8 **)a2, a3, a4, a5, a6);
}

uint64_t asn1_template_ex_i2d(unint64_t **a1, unsigned __int8 **pp, int *a3, uint64_t tag, unsigned __int8 a5, int a6)
{
  uint64_t v6;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v15;
  int v16;
  _BOOL8 v17;
  unint64_t *v18;
  int v19;
  int v20;
  unint64_t v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  BOOL v26;
  int v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  signed int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  int v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned __int8 *v44;
  char v45;
  unsigned __int8 *v46;
  uint64_t v47;
  unsigned int v48;
  BOOL v49;
  uint64_t v50;
  unsigned __int8 *v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  uint64_t v57;
  unsigned int v58;
  unsigned __int8 *v59;
  uint64_t v60;
  unsigned int v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  int v68;
  _BOOL4 v69;
  unsigned __int8 *v70;
  int *v71;
  int *v72;
  unint64_t v73;
  _DWORD *v74;
  int v75;
  unsigned __int8 *v76;
  unint64_t v77;
  unint64_t v78;
  const void **v79;
  size_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  unsigned __int8 *v84;

  v6 = tag;
  v10 = *a3;
  if ((*a3 & 0x18) == 0)
  {
    if ((_DWORD)tag == -1)
      v15 = 0;
    else
      v15 = a5 & 0xC0;
    v16 = *a3 & 1 | a6;
    v17 = v16 != 0;
    if ((v10 & 6) == 0)
      goto LABEL_42;
LABEL_11:
    v18 = *a1;
    v82 = 0;
    if (v18)
    {
      if ((v10 & 2) != 0)
        v19 = 17;
      else
        v19 = 16;
      if ((v10 & 0x10) == 0 && (_DWORD)v6 != -1)
        v20 = v6;
      else
        v20 = v19;
      v21 = *v18;
      v22 = 0;
      if (*v18)
      {
        v23 = 0;
        v13 = 0xFFFFFFFFLL;
        while (1)
        {
          v24 = v21 <= v23 ? 0 : *(_QWORD *)(v18[1] + 8 * v23);
          v82 = v24;
          v25 = asn1_item_ex_i2d_opt(&v82, 0, *((_QWORD *)a3 + 3), 0xFFFFFFFFLL, 0, 0);
          v26 = v25 != -1 && v22 <= (v25 ^ 0x7FFFFFFF);
          if (!v26)
            return v13;
          v22 += v25;
          ++v23;
          v21 = *v18;
          if (v23 >= *v18)
          {
            if (v22 < 0)
              return 0xFFFFFFFFLL;
            break;
          }
        }
      }
      v27 = 1;
      if (v20 >= 31)
      {
        v28 = v20;
        do
        {
          ++v27;
          v26 = v28 > 0x7F;
          v28 >>= 7;
        }
        while (v26);
      }
      v29 = v27 + 1;
      if (v22 >= 128)
      {
        v30 = v22;
        do
        {
          ++v29;
          v26 = v30 > 0xFF;
          v30 >>= 8;
        }
        while (v26);
      }
      v13 = 0xFFFFFFFFLL;
      if (v29 < (v22 ^ 0x7FFFFFFF))
      {
        v31 = v29 + v22;
        if (v29 + v22 != -1)
        {
          if ((v10 & 0x10) != 0)
          {
            if (v31 < 0)
              return v13;
            v39 = 1;
            if ((int)v6 >= 31)
            {
              v40 = v6;
              do
              {
                ++v39;
                v26 = v40 > 0x7F;
                v40 >>= 7;
              }
              while (v26);
            }
            v41 = v39 + 1;
            if (v31 >= 128)
            {
              v42 = v31;
              do
              {
                ++v41;
                v26 = v42 > 0xFF;
                v42 >>= 8;
              }
              while (v26);
            }
            v43 = v41 + v31;
            v13 = v41 >= (v31 ^ 0x7FFFFFFF) ? 0xFFFFFFFFLL : v43;
            if (!pp || (_DWORD)v13 == -1)
              return v13;
            ASN1_put_object(pp, 1, v31, v6, v15);
            v31 = v43;
          }
          else
          {
            v13 = (v29 + v22);
            if (!pp)
              return v13;
          }
          v44 = *pp;
          if ((v10 & 0x10) == 0 && (_DWORD)v6 != -1)
            v45 = v15 & 0xC0 | 0x20;
          else
            v45 = 32;
          if (v20 > 30)
          {
            v55 = 0;
            *v44 = v45 | 0x1F;
            v56 = v20;
            do
            {
              ++v55;
              v49 = v56 >= 0x80;
              v56 >>= 7;
            }
            while (v49);
            v44[v55] = v20 & 0x7F;
            if (v55 != 1)
            {
              v57 = v55;
              do
              {
                v20 = v20 >> 7;
                v44[--v57] = v20 | 0x80;
              }
              while (v57 > 1);
            }
            v46 = &v44[v55 + 1];
          }
          else
          {
            *v44 = v45 | v20 & 0x1F;
            v46 = v44 + 1;
          }
          if (v22 >= 128)
          {
            v60 = 1;
            v61 = v22;
            do
            {
              ++v60;
              v26 = v61 > 0xFF;
              v61 >>= 8;
            }
            while (v26);
            *v46 = (v60 - 1) | 0x80;
            v62 = v60;
            v63 = v22;
            do
            {
              v46[(v62 - 2) + 1] = v63;
              v63 >>= 8;
              --v62;
            }
            while (v62 > 1);
            v58 = v31;
            v59 = &v46[v60];
          }
          else
          {
            v58 = v31;
            *v46 = v22;
            v59 = v46 + 1;
          }
          *pp = v59;
          v64 = *((_QWORD *)a3 + 3);
          if ((v10 & 2) != 0 && *v18 > 1)
          {
            v70 = (unsigned __int8 *)OPENSSL_malloc(v22);
            v71 = (int *)OPENSSL_calloc(*v18, 0x10uLL);
            v72 = v71;
            v69 = 0;
            if (v71 && v70)
            {
              v73 = 0;
              v84 = v70;
              v74 = v71 + 2;
              while (v73 < *v18)
              {
                v83 = 0;
                v83 = *(_QWORD *)(v18[1] + 8 * v73);
                *((_QWORD *)v74 - 1) = v84;
                v75 = asn1_item_ex_i2d_opt(&v83, &v84, v64, 0xFFFFFFFFLL, 0, 0);
                *v74 = v75;
                v74 += 4;
                ++v73;
                if (v75 < 0)
                {
                  v69 = 0;
                  goto LABEL_127;
                }
              }
              qsort(v72, *v18, 0x10uLL, (int (__cdecl *)(const void *, const void *))der_cmp);
              v76 = *pp;
              v84 = *pp;
              v77 = *v18;
              if (*v18)
              {
                v78 = 0;
                v79 = (const void **)(v72 + 2);
                do
                {
                  while (1)
                  {
                    v80 = *(int *)v79;
                    if ((_DWORD)v80)
                      break;
                    v84 = v76;
                    ++v78;
                    v79 += 2;
                    if (v78 >= v77)
                      goto LABEL_126;
                  }
                  memcpy(v76, *(v79 - 1), v80);
                  v81 = *(_DWORD *)v79;
                  v79 += 2;
                  v77 = *v18;
                  v76 = &v84[v81];
                  v84 = v76;
                  ++v78;
                }
                while (v78 < v77);
              }
LABEL_126:
              *pp = v76;
              v69 = 1;
            }
LABEL_127:
            OPENSSL_free(v72);
            OPENSSL_free(v70);
          }
          else
          {
            v65 = 0;
            do
            {
              v66 = v65;
              v67 = *v18;
              if (v65 >= *v18)
                break;
              v84 = 0;
              v84 = *(unsigned __int8 **)(v18[1] + 8 * v65);
              v68 = asn1_item_ex_i2d_opt(&v84, pp, v64, 0xFFFFFFFFLL, 0, 0);
              v65 = v66 + 1;
            }
            while ((v68 & 0x80000000) == 0);
            v69 = v66 >= v67;
          }
          if (v69)
            return v58;
          else
            return 0xFFFFFFFFLL;
        }
      }
    }
    else
    {
      if (!v16)
      {
        v11 = 155;
        v12 = 327;
LABEL_4:
        ERR_put_error(12, 0, v11, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_enc.c", v12);
        return 0xFFFFFFFFLL;
      }
      return 0;
    }
    return v13;
  }
  if ((_DWORD)tag != -1)
  {
    v11 = 193;
    v12 = 291;
    goto LABEL_4;
  }
  v6 = a3[1];
  v15 = v10 & 0xC0;
  v16 = *a3 & 1 | a6;
  v17 = v16 != 0;
  if ((v10 & 6) != 0)
    goto LABEL_11;
LABEL_42:
  v32 = *((_QWORD *)a3 + 3);
  if ((v10 & 0x10) != 0)
  {
    v33 = asn1_item_ex_i2d_opt(a1, 0, v32, 0xFFFFFFFFLL, 0, v17);
    if ((int)v33 < 1)
      return v33;
    v34 = 2;
    if ((int)v6 >= 31)
    {
      v35 = v6;
      do
      {
        ++v34;
        v26 = v35 > 0x7F;
        v35 >>= 7;
      }
      while (v26);
    }
    if ((int)v33 >= 128)
    {
      v36 = v33;
      do
      {
        ++v34;
        v26 = v36 > 0xFF;
        v36 >>= 8;
      }
      while (v26);
    }
    if (v34 >= (int)(v33 ^ 0x7FFFFFFF))
      v13 = 0xFFFFFFFFLL;
    else
      v13 = (v34 + v33);
    if (pp && (_DWORD)v13 != -1)
    {
      v37 = *pp;
      if ((int)v6 > 30)
      {
        v47 = 0;
        *v37 = v15 & 0xC0 | 0x3F;
        v48 = v6;
        do
        {
          ++v47;
          v49 = v48 >= 0x80;
          v48 >>= 7;
        }
        while (v49);
        v37[v47] = v6 & 0x7F;
        if (v47 != 1)
        {
          v50 = v47;
          do
          {
            LODWORD(v6) = v6 >> 7;
            v37[--v50] = v6 | 0x80;
          }
          while (v50 > 1);
        }
        v38 = &v37[v47 + 1];
      }
      else
      {
        *v37 = v15 & 0xC0 | 0x20 | v6 & 0x1F;
        v38 = v37 + 1;
      }
      if ((int)v33 >= 128)
      {
        v52 = 1;
        v53 = v33;
        do
        {
          ++v52;
          v26 = v53 > 0xFF;
          v53 >>= 8;
        }
        while (v26);
        *v38 = (v52 - 1) | 0x80;
        v54 = v52;
        do
        {
          v38[(v54 - 2) + 1] = v33;
          LODWORD(v33) = v33 >> 8;
          --v54;
        }
        while (v54 > 1);
        v51 = &v38[v52];
      }
      else
      {
        *v38 = v33;
        v51 = v38 + 1;
      }
      *pp = v51;
      if ((int)asn1_item_ex_i2d_opt(a1, pp, *((_QWORD *)a3 + 3), 0xFFFFFFFFLL, 0, 0) >= 0)
        return v13;
      else
        return 0xFFFFFFFFLL;
    }
    return v13;
  }
  return asn1_item_ex_i2d_opt(a1, pp, v32, v6, v15, v17);
}

uint64_t asn1_i2d_ex_primitive(ASN1_VALUE **a1, unsigned __int8 **a2, uint64_t a3, int a4, char a5, int a6)
{
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned __int8 *v15;
  char v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned int v19;
  BOOL v20;
  uint64_t v21;
  unsigned int v22;
  unsigned __int8 *v23;
  uint64_t v24;
  unsigned int v25;
  BOOL v26;
  uint64_t v27;
  unsigned int v28;
  signed int v30;
  unsigned int v31;
  ASN1_ITEM it;

  *(_DWORD *)&it.itype = *(_DWORD *)(a3 + 4);
  *((_DWORD *)&it.itype + 1) = 0;
  v11 = asn1_ex_i2c(a1, 0, (int *)&it.itype + 1, &it);
  if ((v11 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  if (*((_DWORD *)&it.itype + 1))
  {
    if (a6)
      return 0;
    ERR_put_error(12, 0, 155, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_enc.c", 508);
    return 0xFFFFFFFFLL;
  }
  v12 = v11;
  v13 = *(_DWORD *)&it.itype;
  if (a4 == -1)
    a4 = *(_DWORD *)&it.itype;
  if (a2)
  {
    if ((*(_DWORD *)&it.itype + 3) > 0x14 || ((1 << (it.itype + 3)) & 0x180001) == 0)
    {
      v15 = *a2;
      v16 = a5 & 0xC0;
      if (a4 > 30)
      {
        v18 = 0;
        *v15 = v16 | 0x1F;
        v19 = a4;
        do
        {
          ++v18;
          v20 = v19 >= 0x80;
          v19 >>= 7;
        }
        while (v20);
        v15[v18] = a4 & 0x7F;
        if (v18 != 1)
        {
          v21 = v18;
          v22 = a4;
          do
          {
            v22 >>= 7;
            v15[--v21] = v22 | 0x80;
          }
          while (v21 > 1);
        }
        v17 = &v15[v18 + 1];
      }
      else
      {
        *v15 = a4 & 0x1F | v16;
        v17 = v15 + 1;
      }
      if ((int)v11 >= 128)
      {
        v24 = 1;
        v25 = v11;
        do
        {
          ++v24;
          v26 = v25 > 0xFF;
          v25 >>= 8;
        }
        while (v26);
        *v17 = (v24 - 1) | 0x80;
        v27 = v24;
        v28 = v11;
        do
        {
          v17[(v27 - 2) + 1] = v28;
          v28 >>= 8;
          --v27;
        }
        while (v27 > 1);
        v23 = &v17[v24];
      }
      else
      {
        *v17 = v11;
        v23 = v17 + 1;
      }
      *a2 = v23;
    }
    if (asn1_ex_i2c(a1, *a2, (int *)&it.itype + 1, &it) < 0)
      return 0xFFFFFFFFLL;
    *a2 += v12;
  }
  if ((v13 + 3) > 0x14 || ((1 << (v13 + 3)) & 0x180001) == 0)
  {
    v30 = 2;
    if (a4 >= 31)
    {
      do
      {
        ++v30;
        v26 = a4 > 0x7F;
        a4 = a4 >> 7;
      }
      while (v26);
    }
    if ((int)v12 >= 128)
    {
      v31 = v12;
      do
      {
        ++v30;
        v26 = v31 > 0xFF;
        v31 >>= 8;
      }
      while (v26);
    }
    if (v30 >= (int)(v12 ^ 0x7FFFFFFF))
      return 0xFFFFFFFFLL;
    else
      return (v30 + v12);
  }
  return v12;
}

uint64_t der_cmp(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a2 + 8);
  v4 = (v2 - v3);
  if (v2 >= v3)
    v2 = *(_DWORD *)(a2 + 8);
  if (!v2)
    return v4;
  result = memcmp(*(const void **)a1, *(const void **)a2, v2);
  if (!(_DWORD)result)
    return v4;
  return result;
}

int asn1_ex_i2c(ASN1_VALUE **pval, unsigned __int8 *cont, int *putype, const ASN1_ITEM *it)
{
  uint64_t v4;
  ASN1_VALUE *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  ASN1_VALUE *v15;
  unsigned __int8 **v16;
  int v17;
  int v18;
  char v19;
  char *p_src;
  ASN1_VALUE *v21;
  unsigned __int8 **v22;
  uint64_t v24;
  char __src;
  unsigned __int8 *v26;

  v26 = cont;
  *putype = 0;
  if (*(_BYTE *)v4)
  {
    v5 = *pval;
    if (*pval)
    {
      if (*(_BYTE *)v4 == 5)
      {
        v6 = *((_DWORD *)v5 + 1);
        if (v6 < 0 && v6 != -3)
        {
          v7 = 191;
          v8 = 589;
LABEL_51:
          ERR_put_error(12, 0, v7, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_enc.c", v8);
          return -1;
        }
        if (v6 == 266)
          v13 = 10;
        else
          v13 = v6;
        if (v6 == 258)
          v13 = 2;
        *(_DWORD *)&it->itype = v13;
        __src = 0;
        v12 = v13 - 1;
        if ((v13 - 1) > 9)
        {
LABEL_44:
          p_src = (char *)*((_QWORD *)*pval + 1);
          v14 = *(_DWORD *)*pval;
          if (!cont)
            return v14;
          goto LABEL_48;
        }
LABEL_24:
        v14 = 0;
        switch(v12)
        {
          case 0:
            v18 = *(_DWORD *)pval;
            if (*(_DWORD *)pval == -1)
              goto LABEL_56;
            if (*(_DWORD *)(v4 + 4) == -4)
              goto LABEL_31;
            v24 = *(_QWORD *)(v4 + 32);
            if (v18)
            {
              if (v24 > 0)
                goto LABEL_56;
            }
            else if (!v24)
            {
              goto LABEL_56;
            }
LABEL_31:
            if (v18)
              v19 = -1;
            else
              v19 = 0;
            __src = v19;
            v14 = 1;
            p_src = &__src;
            if (!cont)
              return v14;
            break;
          case 1:
          case 9:
            v15 = *pval;
            if (cont)
              v16 = &v26;
            else
              v16 = 0;
            v17 = i2c_ASN1_INTEGER((ASN1_INTEGER *)v15, v16);
            goto LABEL_40;
          case 2:
            v21 = *pval;
            if (cont)
              v22 = &v26;
            else
              v22 = 0;
            v17 = i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)v21, v22);
LABEL_40:
            if (v17 < 1)
              return -1;
            else
              return v17;
          case 4:
            return v14;
          case 5:
            v14 = *((_DWORD *)*pval + 5);
            if (!v14)
            {
              v7 = 134;
              v8 = 630;
              goto LABEL_51;
            }
            p_src = (char *)*((_QWORD *)*pval + 3);
            if (!cont)
              return v14;
            break;
          default:
            goto LABEL_44;
        }
LABEL_48:
        if (v14)
        {
          memcpy(cont, p_src, v14);
          return v14;
        }
        return v14;
      }
      if (*(_DWORD *)(v4 + 4) != -4)
      {
LABEL_14:
        v11 = *(_DWORD *)&it->itype;
        __src = 0;
        v12 = v11 - 1;
        if ((v11 - 1) > 9)
          goto LABEL_44;
        goto LABEL_24;
      }
LABEL_10:
      v10 = *(_DWORD *)v5;
      if ((*(_DWORD *)v5 & 0x80000000) != 0 && v10 != -3)
      {
        v7 = 191;
        v8 = 614;
        goto LABEL_51;
      }
      *(_DWORD *)&it->itype = v10;
      pval = (ASN1_VALUE **)((char *)v5 + 8);
      __src = 0;
      v12 = v10 - 1;
      goto LABEL_24;
    }
  }
  else
  {
    v9 = *(_DWORD *)(v4 + 4);
    if (v9 == 1)
      goto LABEL_14;
    v5 = *pval;
    if (*pval)
    {
      if (v9 != -4)
        goto LABEL_14;
      goto LABEL_10;
    }
  }
LABEL_56:
  *putype = 1;
  return 0;
}

void ASN1_item_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  const ASN1_ITEM *v2;
  int itype;
  ASN1_VALUE *v5;
  uint64_t utype;
  uint64_t tcount;
  uint64_t v8;
  unsigned int (*v9)(uint64_t, ASN1_VALUE **, const ASN1_ITEM *, _QWORD);
  char v10;
  ASN1_VALUE *v11;
  unint64_t v12;
  unint64_t v13;
  ASN1_VALUE *v14;
  uint64_t v15;
  unsigned int (*v16)(uint64_t, ASN1_VALUE **, const ASN1_ITEM *, _QWORD);
  char v17;
  uint64_t v18;
  void (*v19)(ASN1_VALUE **, const ASN1_ITEM *);
  ASN1_OBJECT **v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  size_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  unsigned int *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  size_t v32;
  char *v33;
  uint64_t v34;
  size_t v35;
  void *v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  size_t v43;
  uint64_t templates;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  const ASN1_OBJECT *v50;
  int v51;
  uint64_t v52;
  unint64_t **v53;
  unint64_t *v54;
  unint64_t v55;
  ASN1_VALUE *v56;
  unint64_t v57;
  void *v58;
  uint64_t v59;
  size_t v60;
  unint64_t *v61;
  uint64_t v62;
  size_t v63;
  char *v64;
  uint64_t v65;
  size_t v66;
  ASN1_VALUE *pvala;

  if (pval)
  {
    v2 = it;
    itype = it->itype;
    if (!it->itype)
      goto LABEL_7;
LABEL_3:
    v5 = *pval;
    if (*pval)
    {
      if (!itype)
      {
        utype = v2->utype;
        if (!utype)
        {
LABEL_39:
          switch(*((_DWORD *)&v2->itype + 1))
          {
            case 0xFFFFFFFC:
              v20 = (ASN1_OBJECT **)*pval;
              if (*pval)
                goto LABEL_41;
              goto LABEL_115;
            case 1:
              goto LABEL_49;
            case 5:
              goto LABEL_115;
            case 6:
              goto LABEL_65;
            default:
              v5 = *pval;
              if (*pval)
                goto LABEL_58;
              goto LABEL_115;
          }
        }
        while ((*(_BYTE *)utype & 6) == 0)
        {
          v2 = *(const ASN1_ITEM **)(utype + 24);
          itype = v2->itype;
          if (v2->itype)
            goto LABEL_3;
LABEL_7:
          utype = v2->utype;
          if (!utype)
            goto LABEL_39;
        }
        v11 = *pval;
        if (!*pval)
          goto LABEL_115;
        v12 = *(_QWORD *)v11;
        if (*(_QWORD *)v11)
        {
          v13 = 0;
          do
          {
            v14 = 0;
            pvala = 0;
            if (v12 > v13)
              v14 = *(ASN1_VALUE **)(*((_QWORD *)v11 + 1) + 8 * v13);
            pvala = v14;
            ASN1_item_ex_free(&pvala, *(const ASN1_ITEM **)(utype + 24));
            ++v13;
            v12 = *(_QWORD *)v11;
          }
          while (v13 < *(_QWORD *)v11);
        }
        v21 = *((_QWORD *)v11 + 1);
        if (v21)
        {
          v23 = *(_QWORD *)(v21 - 8);
          v22 = (void *)(v21 - 8);
          v24 = v23 + 8;
          if (v23 != -8)
            bzero(v22, v24);
          free(v22);
        }
        goto LABEL_111;
      }
      switch(itype)
      {
        case 1:
          if (itype != 1)
            goto LABEL_15;
          tcount = v2->tcount;
          if (!tcount || (*(_BYTE *)(tcount + 8) & 1) == 0)
            goto LABEL_15;
          v37 = (unsigned int *)((char *)v5 + *(int *)(tcount + 12));
          v38 = atomic_load(v37);
          while (2)
          {
            if (v38 == -1)
              return;
            if (!v38)
              abort();
            v39 = __ldaxr(v37);
            if (v39 == v38)
            {
              if (!__stlxr(v38 - 1, v37))
              {
                if (v38 != 1)
                  return;
LABEL_15:
                v8 = v2->tcount;
                if (v8)
                {
                  v9 = *(unsigned int (**)(uint64_t, ASN1_VALUE **, const ASN1_ITEM *, _QWORD))(v8 + 16);
                  if (v9)
                  {
                    if (v9(2, pval, v2, 0) == 2)
                      return;
                    v10 = 0;
                    goto LABEL_52;
                  }
                }
                else
                {
                  v9 = 0;
                }
                v10 = 1;
LABEL_52:
                if (*pval)
                {
                  v26 = v2->tcount;
                  if (v26)
                  {
                    if ((*(_BYTE *)(v26 + 8) & 2) != 0)
                    {
                      v27 = (uint64_t *)((char *)*pval + *(int *)(v26 + 24));
                      v28 = (unsigned int *)v27[2];
                      if (v28)
                      {
                        CRYPTO_BUFFER_free(v28);
                      }
                      else
                      {
                        v40 = *v27;
                        if (*v27)
                        {
                          v42 = *(_QWORD *)(v40 - 8);
                          v41 = (void *)(v40 - 8);
                          v43 = v42 + 8;
                          if (v42 != -8)
                            bzero(v41, v43);
                          free(v41);
                        }
                      }
                      *v27 = 0;
                      v27[1] = 0;
                      v27[2] = 0;
                    }
                  }
                }
                templates = (uint64_t)v2->templates;
                if (templates < 1)
                {
LABEL_108:
                  if ((v10 & 1) == 0)
                    v9(3, pval, v2, 0);
                  goto LABEL_110;
                }
                v45 = 0;
                v46 = v2->utype + 32 * templates;
                while (1)
                {
                  v47 = v46;
                  v46 -= 32;
                  v48 = v46;
                  if ((*(_BYTE *)(v47 - 31) & 3) == 0)
                    goto LABEL_93;
                  v49 = *(_QWORD **)(v47 - 8);
                  v50 = *(const ASN1_OBJECT **)((char *)*pval + v49[1]);
                  if (v50)
                  {
                    v51 = OBJ_obj2nid(v50);
                    v52 = v49[4];
                    if (v52 >= 1)
                    {
                      v48 = v49[3] + 8;
                      while (*(_DWORD *)(v48 - 8) != v51)
                      {
                        v48 += 40;
                        if (!--v52)
                          goto LABEL_90;
                      }
LABEL_93:
                      v53 = (unint64_t **)((char *)*pval + *(_QWORD *)(v48 + 8));
                      if ((*(_BYTE *)v48 & 6) != 0)
                      {
                        v54 = *v53;
                        if (*v53)
                        {
                          if (*v54)
                          {
                            v55 = 0;
                            do
                            {
                              v56 = 0;
                              pvala = 0;
                              if (*v54 > v55)
                                v56 = *(ASN1_VALUE **)(v54[1] + 8 * v55);
                              pvala = v56;
                              ASN1_item_ex_free(&pvala, *(const ASN1_ITEM **)(v48 + 24));
                              ++v55;
                            }
                            while (v55 < *v54);
                          }
                          v57 = v54[1];
                          if (v57)
                          {
                            v59 = *(_QWORD *)(v57 - 8);
                            v58 = (void *)(v57 - 8);
                            v60 = v59 + 8;
                            if (v59 != -8)
                              bzero(v58, v60);
                            free(v58);
                          }
                          v62 = *(v54 - 1);
                          v61 = v54 - 1;
                          v63 = v62 + 8;
                          if (v62 != -8)
                            bzero(v61, v63);
                          free(v61);
                        }
                        *v53 = 0;
                      }
                      else
                      {
                        ASN1_item_ex_free((ASN1_VALUE **)((char *)*pval + *(_QWORD *)(v48 + 8)), *(const ASN1_ITEM **)(v48 + 24));
                      }
                      goto LABEL_83;
                    }
LABEL_90:
                    v48 = v49[5];
                    if (v48)
                      goto LABEL_93;
                  }
                  else
                  {
                    v48 = v49[6];
                    if (v48)
                      goto LABEL_93;
                  }
LABEL_83:
                  if ((uint64_t)v2->templates <= ++v45)
                    goto LABEL_108;
                }
              }
            }
            else
            {
              __clrex();
            }
            v38 = v39;
            continue;
          }
        case 2:
          v15 = v2->tcount;
          if (v15)
          {
            v16 = *(unsigned int (**)(uint64_t, ASN1_VALUE **, const ASN1_ITEM *, _QWORD))(v15 + 16);
            if (v16)
            {
              if (v16(2, pval, v2, 0) == 2)
                return;
              v17 = 0;
              v5 = *pval;
LABEL_44:
              v25 = *(unsigned int *)((char *)v5 + *((int *)&v2->itype + 1));
              if ((v25 & 0x80000000) == 0 && (uint64_t)v2->templates > v25)
                ASN1_template_free((ASN1_VALUE **)((char *)v5 + *(_QWORD *)(v2->utype + 32 * v25 + 8)), (const ASN1_TEMPLATE *)(v2->utype + 32 * v25));
              if ((v17 & 1) == 0)
                v16(3, pval, v2, 0);
LABEL_110:
              v11 = *pval;
              if (!*pval)
              {
LABEL_115:
                *pval = 0;
                return;
              }
LABEL_111:
              v65 = *((_QWORD *)v11 - 1);
              v64 = (char *)v11 - 8;
              v66 = v65 + 8;
              if (v65 != -8)
                bzero(v64, v66);
              v36 = v64;
LABEL_114:
              free(v36);
              goto LABEL_115;
            }
          }
          else
          {
            v16 = 0;
          }
          v17 = 1;
          goto LABEL_44;
        case 4:
          v18 = v2->tcount;
          if (v18)
          {
            v19 = *(void (**)(ASN1_VALUE **, const ASN1_ITEM *))(v18 + 8);
            if (v19)
              v19(pval, v2);
          }
          return;
        case 5:
          if (itype == 5)
          {
LABEL_58:
            v29 = *((_QWORD *)v5 + 1);
            if (v29)
            {
              v31 = *(_QWORD *)(v29 - 8);
              v30 = (void *)(v29 - 8);
              v32 = v31 + 8;
              if (v31 != -8)
                bzero(v30, v32);
              free(v30);
            }
            v34 = *((_QWORD *)v5 - 1);
            v33 = (char *)v5 - 8;
            v35 = v34 + 8;
            if (v34 != -8)
              bzero(v33, v35);
            v36 = v33;
            goto LABEL_114;
          }
          switch(*((_DWORD *)&v2->itype + 1))
          {
            case 0xFFFFFFFC:
              v20 = (ASN1_OBJECT **)*pval;
LABEL_41:
              asn1_type_cleanup(v20);
              OPENSSL_free(*pval);
              goto LABEL_115;
            case 1:
LABEL_49:
              *(_DWORD *)pval = v2->funcs;
              break;
            case 5:
              goto LABEL_115;
            case 6:
LABEL_65:
              ASN1_OBJECT_free((ASN1_OBJECT *)*pval);
              goto LABEL_115;
            default:
              goto LABEL_58;
          }
          return;
        default:
          return;
      }
    }
  }
}

void ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)
{
  ASN1_VALUE *v4;
  unint64_t v5;
  unint64_t v6;
  ASN1_VALUE *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;
  char *v12;
  uint64_t v13;
  size_t v14;
  ASN1_VALUE *pvala;

  if ((tt->flags & 6) != 0)
  {
    v4 = *pval;
    if (*pval)
    {
      v5 = *(_QWORD *)v4;
      if (*(_QWORD *)v4)
      {
        v6 = 0;
        do
        {
          v7 = 0;
          pvala = 0;
          if (v5 > v6)
            v7 = *(ASN1_VALUE **)(*((_QWORD *)v4 + 1) + 8 * v6);
          pvala = v7;
          ASN1_item_ex_free(&pvala, (const ASN1_ITEM *)tt->field_name);
          ++v6;
          v5 = *(_QWORD *)v4;
        }
        while (v6 < *(_QWORD *)v4);
      }
      v8 = *((_QWORD *)v4 + 1);
      if (v8)
      {
        v10 = *(_QWORD *)(v8 - 8);
        v9 = (void *)(v8 - 8);
        v11 = v10 + 8;
        if (v10 != -8)
          bzero(v9, v11);
        free(v9);
      }
      v13 = *((_QWORD *)v4 - 1);
      v12 = (char *)v4 - 8;
      v14 = v13 + 8;
      if (v13 != -8)
        bzero(v12, v14);
      free(v12);
    }
    *pval = 0;
  }
  else
  {
    ASN1_item_ex_free(pval, (const ASN1_ITEM *)tt->field_name);
  }
}

int ASN1_item_ex_new(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  int v2;
  int itype;
  uint64_t utype;
  int v7;
  ASN1_VALUE *v8;
  uint64_t tcount;
  uint64_t (*v10)(uint64_t, ASN1_VALUE **, const ASN1_ITEM *, _QWORD);
  int v11;
  char v12;
  const void *funcs;
  uint64_t v14;
  int v15;
  char v16;
  const void *v17;
  unsigned int (**v18)(ASN1_VALUE **, const ASN1_ITEM *);
  unsigned int (*v19)(ASN1_VALUE **, const ASN1_ITEM *);
  int v20;
  char *v21;
  ASN1_VALUE *v22;
  char *v23;
  int v24;
  _QWORD *v25;
  ASN1_VALUE *v26;
  uint64_t v27;
  _QWORD *v28;
  ASN1_VALUE *v29;
  const void *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char **v35;
  int v36;
  uint64_t v37;
  char *v38;
  int v39;
  char *v40;

  v2 = 1;
  itype = it->itype;
  switch(it->itype)
  {
    case 0:
      utype = it->utype;
      if (utype)
      {
        v7 = *(_DWORD *)utype;
        if ((*(_DWORD *)utype & 1) != 0)
        {
          while (1)
          {
            if ((*(_WORD *)utype & 0x306) != 0)
              goto LABEL_100;
            v23 = *(char **)(utype + 24);
            v24 = *v23;
            if (*v23)
              break;
            utype = *((_QWORD *)v23 + 1);
            if (!utype)
              goto LABEL_97;
          }
          if ((v24 - 1) >= 2)
          {
            if (v24 == 5)
            {
LABEL_97:
              if (*v23 != 5 && *((_DWORD *)v23 + 1) == 1)
              {
                v30 = (const void *)*((_QWORD *)v23 + 4);
LABEL_63:
                *(_DWORD *)pval = (_DWORD)v30;
                return 1;
              }
            }
            else if (v24 != 4)
            {
              return 1;
            }
          }
        }
        else if ((v7 & 0x300) == 0)
        {
          if ((v7 & 6) != 0)
          {
            v8 = (ASN1_VALUE *)OPENSSL_sk_new_null();
            if (!v8)
              return 0;
LABEL_61:
            *pval = v8;
            return 1;
          }
          return ASN1_item_ex_new(pval, *(const ASN1_ITEM **)(utype + 24)) != 0;
        }
LABEL_100:
        *pval = 0;
        return 1;
      }
      if (itype == 5)
        goto LABEL_28;
      v20 = *((_DWORD *)&it->itype + 1);
      switch(v20)
      {
        case -4:
          goto LABEL_59;
        case 1:
          goto LABEL_62;
        case 5:
          v2 = 1;
          *pval = (ASN1_VALUE *)1;
          break;
        case 6:
          goto LABEL_64;
        default:
          goto LABEL_29;
      }
      return v2;
    case 1:
      tcount = it->tcount;
      if (tcount)
      {
        v10 = *(uint64_t (**)(uint64_t, ASN1_VALUE **, const ASN1_ITEM *, _QWORD))(tcount + 16);
        if (v10)
        {
          v11 = v10(0, pval, it, 0);
          if (!v11)
            goto LABEL_95;
          v12 = 0;
          if (v11 == 2)
            return 1;
          funcs = it->funcs;
          if ((unint64_t)funcs > 0xFFFFFFFFFFFFFFF7)
            goto LABEL_53;
        }
        else
        {
          v12 = 1;
          funcs = it->funcs;
          if ((unint64_t)funcs > 0xFFFFFFFFFFFFFFF7)
            goto LABEL_53;
        }
      }
      else
      {
        v10 = 0;
        v12 = 1;
        funcs = it->funcs;
        if ((unint64_t)funcs > 0xFFFFFFFFFFFFFFF7)
          goto LABEL_53;
      }
      v25 = malloc_type_malloc((size_t)funcs + 8, 0x30772F57uLL);
      if (!v25)
        goto LABEL_53;
      *v25 = funcs;
      v26 = (ASN1_VALUE *)(v25 + 1);
      if (funcs)
        bzero(v25 + 1, (size_t)funcs);
      *pval = v26;
      v27 = it->tcount;
      if (it->itype == 1)
      {
        if (!v27)
          goto LABEL_69;
        if ((*(_BYTE *)(v27 + 8) & 1) != 0)
          *(_DWORD *)((char *)v26 + *(int *)(v27 + 12)) = 1;
      }
      else if (!v27)
      {
        goto LABEL_69;
      }
      if ((*(_BYTE *)(v27 + 8) & 2) != 0)
      {
        v31 = (_QWORD *)((char *)v26 + *(int *)(v27 + 24));
        *v31 = 0;
        v31[1] = 0;
        v31[2] = 0;
      }
LABEL_69:
      if ((uint64_t)it->templates >= 1)
      {
        v32 = 0;
        v33 = it->utype;
        while (1)
        {
          v34 = *(_QWORD *)(v33 + 8);
          v35 = (char **)((char *)*pval + v34);
          v36 = *(_DWORD *)v33;
          if ((*(_DWORD *)v33 & 1) != 0)
            break;
          if ((v36 & 0x300) != 0)
            goto LABEL_72;
          if ((v36 & 6) != 0)
          {
            v40 = OPENSSL_sk_new_null();
            if (!v40)
              goto LABEL_91;
            *v35 = v40;
          }
          else if (!ASN1_item_ex_new((ASN1_VALUE **)((char *)*pval + v34), *(const ASN1_ITEM **)(v33 + 24)))
          {
LABEL_91:
            ASN1_item_ex_free(pval, it);
            return 0;
          }
LABEL_73:
          v33 += 32;
          if ((uint64_t)it->templates <= ++v32)
            goto LABEL_92;
        }
        v37 = v33;
        while ((*(_WORD *)v37 & 0x306) == 0)
        {
          v38 = *(char **)(v37 + 24);
          v39 = *v38;
          if (*v38)
          {
            if ((v39 - 1) < 2)
              break;
            if (v39 != 5)
            {
              if (v39 == 4)
                break;
              goto LABEL_73;
            }
LABEL_87:
            if (*v38 != 5 && *((_DWORD *)v38 + 1) == 1)
            {
              *(_DWORD *)v35 = *((_QWORD *)v38 + 4);
              goto LABEL_73;
            }
            break;
          }
          v37 = *((_QWORD *)v38 + 1);
          if (!v37)
            goto LABEL_87;
        }
LABEL_72:
        *v35 = 0;
        goto LABEL_73;
      }
LABEL_92:
      if ((v12 & 1) != 0)
        return 1;
      goto LABEL_93;
    case 2:
      v14 = it->tcount;
      if (v14)
      {
        v10 = *(uint64_t (**)(uint64_t, ASN1_VALUE **, const ASN1_ITEM *, _QWORD))(v14 + 16);
        if (v10)
        {
          v15 = v10(0, pval, it, 0);
          if (!v15)
            goto LABEL_95;
          v16 = 0;
          if (v15 == 2)
            return 1;
          v17 = it->funcs;
          if ((unint64_t)v17 > 0xFFFFFFFFFFFFFFF7)
          {
LABEL_53:
            ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
            *pval = 0;
            return 0;
          }
        }
        else
        {
          v16 = 1;
          v17 = it->funcs;
          if ((unint64_t)v17 > 0xFFFFFFFFFFFFFFF7)
            goto LABEL_53;
        }
      }
      else
      {
        v10 = 0;
        v16 = 1;
        v17 = it->funcs;
        if ((unint64_t)v17 > 0xFFFFFFFFFFFFFFF7)
          goto LABEL_53;
      }
      v28 = malloc_type_malloc((size_t)v17 + 8, 0x30772F57uLL);
      if (!v28)
        goto LABEL_53;
      *v28 = v17;
      v29 = (ASN1_VALUE *)(v28 + 1);
      if (v17)
        bzero(v28 + 1, (size_t)v17);
      *pval = v29;
      *(_DWORD *)((char *)v29 + *((int *)&it->itype + 1)) = -1;
      if ((v16 & 1) != 0)
        return 1;
LABEL_93:
      v2 = 1;
      if (!v10(1, pval, it, 0))
      {
        ASN1_item_ex_free(pval, it);
LABEL_95:
        ERR_put_error(12, 0, 101, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_new.c", 181);
        return 0;
      }
      return v2;
    case 4:
      v18 = (unsigned int (**)(ASN1_VALUE **, const ASN1_ITEM *))it->tcount;
      if (v18)
      {
        v19 = *v18;
        if (v19)
        {
          if (!v19(pval, it))
            return 0;
        }
      }
      return 1;
    case 5:
      if (itype != 5)
      {
        v20 = *((_DWORD *)&it->itype + 1);
        switch(v20)
        {
          case -4:
LABEL_59:
            v8 = (ASN1_VALUE *)OPENSSL_malloc(0x10uLL);
            if (!v8)
              return 0;
            *((_QWORD *)v8 + 1) = 0;
            *(_DWORD *)v8 = -1;
            goto LABEL_61;
          case 1:
LABEL_62:
            v30 = it->funcs;
            goto LABEL_63;
          case 5:
            v2 = 1;
            *pval = (ASN1_VALUE *)1;
            return v2;
          case 6:
LABEL_64:
            v22 = (ASN1_VALUE *)OBJ_get_undef_kUndef;
            goto LABEL_65;
          default:
            goto LABEL_29;
        }
      }
LABEL_28:
      v20 = -1;
LABEL_29:
      v21 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
      if (!v21)
        goto LABEL_53;
      *((_DWORD *)v21 + 2) = 0;
      v22 = (ASN1_VALUE *)(v21 + 8);
      *(_QWORD *)v21 = 24;
      *((_DWORD *)v21 + 3) = v20;
      *((_QWORD *)v21 + 2) = 0;
      *((_QWORD *)v21 + 3) = 0;
LABEL_65:
      *pval = v22;
      return 1;
    default:
      return v2;
  }
}

ASN1_BIT_STRING *ASN1_BIT_STRING_new(void)
{
  char *v0;

  v0 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (v0)
  {
    *(_QWORD *)v0 = 24;
    *((_QWORD *)v0 + 1) = 0x300000000;
    *((_QWORD *)v0 + 2) = 0;
    *((_QWORD *)v0 + 3) = 0;
    return (ASN1_BIT_STRING *)(v0 + 8);
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
}

int asn1_enc_save(ASN1_VALUE **pval, const unsigned __int8 *in, int inlen, const ASN1_ITEM *it)
{
  uint64_t v4;
  uint64_t tcount;
  uint64_t v6;
  size_t v7;
  const unsigned __int8 **v9;
  unsigned int *v10;
  int result;
  const unsigned __int8 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  size_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  char v19;
  _QWORD *v20;
  const unsigned __int8 *v21;

  if (!pval)
    return 1;
  if (!*pval)
    return 1;
  tcount = it->tcount;
  if (!tcount || (*(_BYTE *)(tcount + 8) & 2) == 0)
    return 1;
  v6 = v4;
  v7 = *(_QWORD *)&inlen;
  v9 = (const unsigned __int8 **)((char *)*pval + *(int *)(tcount + 24));
  v10 = (unsigned int *)v9[2];
  if (v10)
  {
    CRYPTO_BUFFER_free(v10);
  }
  else
  {
    v12 = *v9;
    if (*v9)
    {
      v14 = *((_QWORD *)v12 - 1);
      v13 = (unsigned __int8 *)(v12 - 8);
      v15 = v14 + 8;
      if (v14 != -8)
        bzero(v13, v15);
      free(v13);
    }
  }
  *v9 = 0;
  v9[1] = 0;
  v9[2] = 0;
  if (v6)
  {
    v16 = (unsigned int *)(v6 + 24);
    v17 = atomic_load((unsigned int *)(v6 + 24));
    if (v17 != -1)
    {
      while (1)
      {
        v18 = __ldaxr(v16);
        if (v18 == v17)
        {
          if (!__stlxr(v17 + 1, v16))
          {
            v19 = 1;
            goto LABEL_19;
          }
        }
        else
        {
          __clrex();
        }
        v19 = 0;
LABEL_19:
        if ((v19 & 1) == 0)
        {
          v17 = v18;
          if (v18 != -1)
            continue;
        }
        break;
      }
    }
    v9[2] = (const unsigned __int8 *)v6;
    goto LABEL_22;
  }
  if (v7)
  {
    if (v7 <= 0xFFFFFFFFFFFFFFF7)
    {
      v20 = malloc_type_malloc(v7 + 8, 0x30772F57uLL);
      if (v20)
      {
        *v20 = v7;
        v21 = (const unsigned __int8 *)(v20 + 1);
        memcpy(v20 + 1, in, v7);
        in = v21;
LABEL_22:
        *v9 = in;
        v9[1] = (const unsigned __int8 *)v7;
        return 1;
      }
    }
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  }
  result = 0;
  *v9 = 0;
  return result;
}

const ASN1_TEMPLATE *__cdecl asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt, int nullerr)
{
  const char *field_name;
  const ASN1_OBJECT *v5;
  int v6;
  uint64_t v7;

  if ((tt->flags & 0x300) == 0)
    return tt;
  field_name = tt->field_name;
  v5 = *(const ASN1_OBJECT **)((char *)*pval + *((_QWORD *)field_name + 1));
  if (v5)
  {
    v6 = OBJ_obj2nid(v5);
    v7 = *((_QWORD *)field_name + 4);
    if (v7 >= 1)
    {
      tt = (const ASN1_TEMPLATE *)(*((_QWORD *)field_name + 3) + 8);
      while (LODWORD(tt[-1].item) != v6)
      {
        ++tt;
        if (!--v7)
          goto LABEL_7;
      }
      return tt;
    }
LABEL_7:
    tt = (const ASN1_TEMPLATE *)*((_QWORD *)field_name + 5);
    if (tt)
      return tt;
  }
  else
  {
    tt = (const ASN1_TEMPLATE *)*((_QWORD *)field_name + 6);
    if (tt)
      return tt;
  }
  if (nullerr)
    ERR_put_error(12, 0, 186, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/tasn_utl.c", 265);
  return 0;
}

uint64_t thread_local_init()
{
  uint64_t result;

  result = pthread_key_create((pthread_key_t *)&g_thread_local_key, (void (__cdecl *)(void *))thread_local_destructor);
  g_thread_local_key_created = result == 0;
  return result;
}

uint64_t CRYPTO_set_thread_local(unsigned int a1, uint64_t a2, void (*a3)(uint64_t))
{
  char *v6;
  uint64_t v7;
  char *v9;

  if (pthread_once(&g_thread_local_init_once, (void (*)(void))thread_local_init))
    abort();
  if (!g_thread_local_key_created)
    goto LABEL_9;
  v6 = (char *)pthread_getspecific(g_thread_local_key);
  if (!v6)
  {
    v9 = (char *)malloc_type_malloc(0x28uLL, 0x80040B8603338uLL);
    if (!v9)
      goto LABEL_9;
    v6 = v9;
    *((_QWORD *)v9 + 4) = 0;
    *(_OWORD *)v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    if (pthread_setspecific(g_thread_local_key, v9))
    {
      free(v6);
      goto LABEL_9;
    }
  }
  if (!pthread_mutex_lock(&g_destructors_lock))
  {
    v7 = a1;
    g_destructors[v7] = (uint64_t)a3;
    pthread_mutex_unlock(&g_destructors_lock);
    *(_QWORD *)&v6[v7 * 8] = a2;
    return 1;
  }
LABEL_9:
  a3(a2);
  return 0;
}

void thread_local_destructor(_QWORD *a1)
{
  void (*v2)(_QWORD);
  void (*v3)(_QWORD);
  void (*v4)(_QWORD);
  void (*v5)(_QWORD);
  void (*v6)(_QWORD);

  if (a1 && !pthread_mutex_lock(&g_destructors_lock))
  {
    v3 = (void (*)(_QWORD))g_destructors;
    v2 = *(void (**)(_QWORD))algn_253EA7B88;
    v5 = (void (*)(_QWORD))qword_253EA7B90;
    v4 = (void (*)(_QWORD))unk_253EA7B98;
    v6 = (void (*)(_QWORD))off_253EA7BA0;
    pthread_mutex_unlock(&g_destructors_lock);
    if (v3)
      v3(*a1);
    if (v2)
      v2(a1[1]);
    if (v5)
      v5(a1[2]);
    if (v4)
      v4(a1[3]);
    if (v6)
      v6(a1[4]);
    free(a1);
  }
}

uint64_t bssl::tls13_get_cert_verify_signature_input(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  char *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  unint64_t v16;
  _OWORD v17[3];
  void *v18;
  void *__dst[9];

  __dst[8] = *(void **)MEMORY[0x24BDAC8D0];
  memset(v17, 0, sizeof(v17));
  v6 = malloc_type_malloc(0xEAuLL, 0x30772F57uLL);
  if (v6)
  {
    *v6 = 226;
    BYTE8(v17[0]) = 0;
    *(_QWORD *)&v17[0] = 0;
    *(_QWORD *)&v17[1] = v6 + 1;
    *(_OWORD *)((char *)&v17[1] + 8) = xmmword_208F30C50;
    BYTE8(v17[2]) = 1;
    v7 = 64;
    while (1)
    {
      __dst[0] = 0;
      if (!CBB_add_space((uint64_t)v17, __dst, 1))
        break;
      *(_BYTE *)__dst[0] = 32;
      if (!--v7)
      {
        if (a3 > 2)
          break;
        v8 = (int)a3;
        v9 = *(_QWORD *)((char *)&unk_208F30D00 + v8 * 8);
        v10 = off_24C0D28C8[v8];
        __dst[0] = 0;
        if (!CBB_add_space((uint64_t)v17, __dst, v9))
          break;
        memcpy(__dst[0], v10, v9);
        v16 = 0;
        if (!bssl::SSLTranscript::GetHash((bssl::SSLTranscript *)(a1 + 408), (unsigned __int8 *)__dst, &v16))
          break;
        v11 = v16;
        v18 = 0;
        if (!CBB_add_space((uint64_t)v17, &v18, v16))
          break;
        if (v11)
          memcpy(v18, __dst, v11);
        v12 = bssl::CBBFinishArray((uint64_t)v17, a2);
        if (BYTE8(v17[0]))
          return v12;
        goto LABEL_15;
      }
    }
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  }
  v12 = 0;
  if (!BYTE8(v17[0]))
  {
LABEL_15:
    if ((BYTE8(v17[2]) & 1) != 0 && *(_QWORD *)&v17[1])
    {
      v14 = (void *)(*(_QWORD *)&v17[1] - 8);
      v13 = *(_QWORD *)(*(_QWORD *)&v17[1] - 8);
      if (v13 != -8)
        bzero(v14, v13 + 8);
      free(v14);
    }
  }
  return v12;
}

uint64_t bssl::tls13_process_certificate(uint64_t a1, uint64_t a2, char a3)
{
  bssl *v5;
  _BYTE *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unint64_t v16;
  unint64_t v17;
  BOOL v18;
  _BYTE *v19;
  unint64_t v20;
  char *v21;
  unint64_t *v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  unsigned __int16 *v28;
  uint64_t v29;
  unsigned int *v30;
  unsigned __int8 *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  size_t v35;
  unint64_t v36;
  char *v37;
  unint64_t v38;
  char *v39;
  unsigned __int16 *v40;
  char *v41;
  unsigned int *v42;
  unsigned int j;
  unsigned int v44;
  uint64_t v45;
  void (*v46)(unsigned int *);
  unsigned int *v47;
  uint64_t v48;
  size_t v49;
  _DWORD *v50;
  char *v51;
  unsigned int *v52;
  unsigned int v53;
  int v54;
  int v55;
  unint64_t v56;
  _BYTE *v57;
  int v58;
  size_t v59;
  char *v60;
  unint64_t v61;
  uint64_t v62;
  char *v63;
  unsigned int *v64;
  unint64_t v65;
  unint64_t v66;
  unsigned __int16 *v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  unsigned int *v72;
  uint64_t v73;
  unsigned int i;
  unsigned int v75;
  uint64_t v76;
  void (*v77)(uint64_t);
  void *v78;
  uint64_t v79;
  size_t v80;
  uint64_t v81;
  unint64_t *v82;
  unint64_t v83;
  unint64_t v84;
  unsigned int *v85;
  bssl *v86;
  unint64_t v87;
  void *v88;
  uint64_t v89;
  size_t v90;
  unint64_t *v91;
  uint64_t v92;
  size_t v93;
  uint64_t v94;
  _QWORD *v95;
  char v96;
  unsigned int (*v97)(bssl *, SHA256_CTX *, unint64_t, _BYTE *);
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  unsigned int k;
  unsigned int v107;
  uint64_t v108;
  void (*v109)(unsigned int *);
  unsigned int *v110;
  uint64_t v111;
  size_t v112;
  unint64_t v113;
  unint64_t v114;
  unsigned int *v115;
  unint64_t v116;
  void *v117;
  uint64_t v118;
  size_t v119;
  unint64_t *v120;
  uint64_t v121;
  size_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  int v137;
  unsigned __int8 v138;
  unsigned __int8 *v139;
  unsigned __int16 *v140;
  size_t v141;
  unsigned __int16 *v142[2];
  __int128 v143;
  uint64_t v144[2];
  SHA256_CTX c;
  uint64_t v146;

  v146 = *MEMORY[0x24BDAC8D0];
  v5 = *(bssl **)a1;
  v6 = *(_BYTE **)(a2 + 8);
  v7 = *(_QWORD *)(a2 + 16);
  if (*(_BYTE *)(a2 + 1) == 25)
  {
    if (v7 < 2
      || v7 - 2 < 3
      || v7 - 5 < 3
      || v7 - 8 != (((unint64_t)v6[5] << 16) | ((unint64_t)v6[6] << 8) | v6[7]))
    {
      bssl::ssl_send_alert(*(bssl **)a1, (ssl_st *)2, 50);
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 118);
      return 0;
    }
    v7 = (v6[2] << 16) | (v6[3] << 8) | v6[4];
    if (v7 > *((_DWORD *)v5 + 34))
    {
      bssl::ssl_send_alert(*(bssl **)a1, (ssl_st *)2, 47);
      ERR_put_error(16, 0, 293, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 124);
      ERR_add_error_dataf("requested=%u", v8, v9, v10, v11, v12, v13, v14, v7);
      return 0;
    }
    v24 = __rev16(*(unsigned __int16 *)v6);
    v25 = *((_QWORD *)v5 + 13);
    v26 = *(_QWORD *)(v25 + 632);
    if (!v26)
      goto LABEL_142;
    v27 = v6 + 8;
    v28 = (unsigned __int16 *)(*(_QWORD *)(v25 + 640) + 16);
    v29 = 24 * v26;
    while (*v28 != v24)
    {
      v28 += 12;
      v29 -= 24;
      if (!v29)
        goto LABEL_142;
    }
    v97 = (unsigned int (*)(bssl *, SHA256_CTX *, unint64_t, _BYTE *))*((_QWORD *)v28 - 1);
    if (!v97)
    {
LABEL_142:
      bssl::ssl_send_alert(*(bssl **)a1, (ssl_st *)2, 47);
      ERR_put_error(16, 0, 294, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 140);
      ERR_add_error_dataf("alg=%d", v99, v100, v101, v102, v103, v104, v105, v24);
      return 0;
    }
    *(_QWORD *)c.h = 0;
    if (!v97(v5, &c, v7, v27))
    {
      bssl::ssl_send_alert(v5, (ssl_st *)2, 50);
      ERR_put_error(16, 0, 292, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 149);
      ERR_add_error_dataf("alg=%d", v123, v124, v125, v126, v127, v128, v129, v24);
      return 0;
    }
    v15 = *(unsigned int **)c.h;
    if (*(_QWORD *)(*(_QWORD *)c.h + 16) != v7)
    {
      bssl::ssl_send_alert(v5, (ssl_st *)2, 50);
      ERR_put_error(16, 0, 292, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 157);
      ERR_add_error_dataf("alg=%d got=%u expected=%u", v130, v131, v132, v133, v134, v135, v136, v24);
      v23 = 0;
      if (!v15)
        return v23;
      goto LABEL_140;
    }
    v6 = *(_BYTE **)(*(_QWORD *)c.h + 8);
    if (!v7)
      goto LABEL_139;
  }
  else
  {
    v15 = 0;
    if (!v7)
      goto LABEL_139;
  }
  v16 = *v6;
  v17 = v7 - 1 - v16;
  if (v7 - 1 < v16
    || (!*v6 ? (v18 = v17 >= 3) : (v18 = 0),
        !v18
     || (v19 = &v6[v16],
         v20 = v17 - 3,
         v17 - 3 != (((unint64_t)v6[v16 + 1] << 16) | ((unint64_t)v6[v16 + 2] << 8) | v6[v16 + 3]))))
  {
LABEL_139:
    bssl::ssl_send_alert(v5, (ssl_st *)2, 50);
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 177);
    v23 = 0;
    if (!v15)
      return v23;
    goto LABEL_140;
  }
  v21 = OPENSSL_sk_new_null();
  if (!v21)
  {
    bssl::ssl_send_alert(v5, (ssl_st *)2, 80);
    v23 = 0;
    if (!v15)
      return v23;
    goto LABEL_140;
  }
  v22 = (unint64_t *)v21;
  if ((*((_BYTE *)v5 + 164) & 1) != 0)
    v137 = (*(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 237) >> 5) & 1;
  else
    v137 = 0;
  v30 = 0;
  if (!v20)
  {
LABEL_93:
    if (!*v22)
    {
      OPENSSL_sk_pop_free_ex(v22, (void (*)(uint64_t))bssl::internal::DeleterImpl<stack_st_CRYPTO_BUFFER,void>::Free(stack_st_CRYPTO_BUFFER*)::{lambda(void (*)(void *),void *)#1}::__invoke, 0);
      v22 = 0;
    }
    v73 = *(_QWORD *)(a1 + 1496);
    *(_QWORD *)(a1 + 1496) = v30;
    if (v73)
    {
      for (i = atomic_load((unsigned int *)v73); i != -1; i = v75)
      {
        if (!i)
          goto LABEL_189;
        v75 = __ldaxr((unsigned int *)v73);
        if (v75 == i)
        {
          if (!__stlxr(i - 1, (unsigned int *)v73))
          {
            if (i == 1)
            {
              v76 = *(_QWORD *)(v73 + 16);
              if (v76)
              {
                v77 = *(void (**)(uint64_t))(v76 + 160);
                if (v77)
                {
                  v77(v73);
                  *(_QWORD *)(v73 + 8) = 0;
                  *(_DWORD *)(v73 + 4) = 0;
                }
              }
              v79 = *(_QWORD *)(v73 - 8);
              v78 = (void *)(v73 - 8);
              v80 = v79 + 8;
              if (v79 != -8)
                bzero(v78, v80);
              free(v78);
            }
            break;
          }
        }
        else
        {
          __clrex();
        }
      }
    }
    v81 = *(_QWORD *)(a1 + 1504);
    v82 = *(unint64_t **)(v81 + 136);
    *(_QWORD *)(v81 + 136) = v22;
    if (v82)
    {
      v83 = *v82;
      if (*v82)
      {
        v84 = 0;
        do
        {
          v85 = *(unsigned int **)(v82[1] + 8 * v84);
          if (v85)
          {
            CRYPTO_BUFFER_free(v85);
            v83 = *v82;
          }
          ++v84;
        }
        while (v84 < v83);
      }
      v87 = v82[1];
      if (v87)
      {
        v89 = *(_QWORD *)(v87 - 8);
        v88 = (void *)(v87 - 8);
        v90 = v89 + 8;
        if (v89 != -8)
          bzero(v88, v90);
        free(v88);
      }
      v92 = *(v82 - 1);
      v91 = v82 - 1;
      v93 = v92 + 8;
      if (v92 != -8)
        bzero(v91, v93);
      free(v91);
    }
    if (((*(uint64_t (**)(_QWORD))(*(_QWORD *)(*((_QWORD *)v5 + 13) + 16) + 48))(*(_QWORD *)(a1 + 1504)) & 1) != 0)
    {
      v94 = *(_QWORD *)(a1 + 1504);
      v95 = *(_QWORD **)(v94 + 136);
      if (v95 && *v95)
      {
        if (v137)
          v96 = 2;
        else
          v96 = 0;
        *(_BYTE *)(v94 + 424) = *(_BYTE *)(v94 + 424) & 0xFD | v96;
        v23 = 1;
        if (!v15)
          return v23;
      }
      else if ((a3 & 1) != 0)
      {
        *(_QWORD *)(v94 + 176) = 0;
        v23 = 1;
        if (!v15)
          return v23;
      }
      else
      {
        ERR_put_error(16, 0, 192, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 303);
        bssl::ssl_send_alert(v5, (ssl_st *)2, 116);
        v23 = 0;
        if (!v15)
          return v23;
      }
    }
    else
    {
      ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 296);
      bssl::ssl_send_alert(v5, (ssl_st *)2, 50);
      v23 = 0;
      if (!v15)
        return v23;
    }
LABEL_140:
    CRYPTO_BUFFER_free(v15);
    return v23;
  }
  v31 = v19 + 4;
  while (1)
  {
    v32 = v20 - 3;
    if (v20 < 3)
      goto LABEL_146;
    v33 = ((unint64_t)*v31 << 16) | ((unint64_t)v31[1] << 8);
    v34 = v31[2];
    v35 = v33 | v34;
    v18 = v32 >= (v33 | v34);
    v36 = v32 - (v33 | v34);
    if (!v18)
      goto LABEL_146;
    v37 = (char *)(v31 + 3);
    *(_QWORD *)&v143 = v31 + 3;
    *((_QWORD *)&v143 + 1) = v33 | v34;
    v38 = v36 - 2;
    if (v36 < 2
      || (v39 = &v37[v35],
          v40 = (unsigned __int16 *)__rev16(*(unsigned __int16 *)&v37[v35]),
          v20 = v38 - (_QWORD)v40,
          v38 < (unint64_t)v40)
      || (v41 = v39 + 2, v142[0] = (unsigned __int16 *)(v39 + 2), v142[1] = v40, !v35))
    {
LABEL_146:
      bssl::ssl_send_alert(v5, (ssl_st *)2, 50);
      ERR_put_error(16, 0, 127, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 196);
      goto LABEL_147;
    }
    if (!*v22)
      break;
LABEL_61:
    v51 = crypto_buffer_new(v37, v35, 0, *(uint64_t **)(*((_QWORD *)v5 + 13) + 704));
    if (!v51)
      goto LABEL_184;
    v52 = (unsigned int *)v51;
    if (!OPENSSL_sk_insert(v22, (uint64_t)v51, *v22))
    {
      CRYPTO_BUFFER_free(v52);
LABEL_184:
      v86 = v5;
      v58 = 80;
      goto LABEL_119;
    }
    if ((*((_BYTE *)v5 + 164) & 1) != 0)
    {
      LOBYTE(v54) = 0;
      LOBYTE(v55) = 0;
      *(_QWORD *)&c.h[2] = 0;
      *(_QWORD *)&c.h[4] = 0;
    }
    else
    {
      v53 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 237);
      v54 = (v53 >> 2) & 1;
      *(_QWORD *)&c.h[2] = 0;
      *(_QWORD *)&c.h[4] = 0;
      v55 = (v53 >> 1) & 1;
    }
    LOWORD(c.h[0]) = 5;
    HIWORD(c.h[0]) = v54;
    LOWORD(v139) = 18;
    WORD1(v139) = v55;
    v140 = 0;
    v141 = 0;
    v138 = 50;
    v144[0] = (uint64_t)&c;
    v144[1] = (uint64_t)&v139;
    if ((bssl::ssl_parse_extensions(v142, &v138, v144, 2, 0) & 1) == 0)
    {
      v58 = v138;
      goto LABEL_118;
    }
    if (HIBYTE(c.h[0]))
    {
      v56 = *(_QWORD *)&c.h[4];
      if (!*(_QWORD *)&c.h[4])
        goto LABEL_117;
      v57 = (_BYTE *)(*(_QWORD *)&c.h[2])++;
      --*(_QWORD *)&c.h[4];
      v58 = 50;
      if (*v57 != 1)
        goto LABEL_118;
      v59 = v56 - 4;
      if (v56 < 4)
        goto LABEL_118;
      v60 = v57 + 4;
      *(_QWORD *)&c.h[2] = v57 + 4;
      *(_QWORD *)&c.h[4] = v56 - 4;
      v61 = ((unint64_t)v57[1] << 16) | ((unint64_t)v57[2] << 8) | v57[3];
      if (v59 < v61)
        goto LABEL_118;
      *(_QWORD *)&c.h[2] = &v60[v61];
      *(_QWORD *)&c.h[4] = v59 - v61;
      if (!v61 || v59 != v61)
        goto LABEL_118;
      if (*v22 == 1)
      {
        v62 = *(_QWORD *)(a1 + 1504);
        v63 = crypto_buffer_new(v60, v59, 0, *(uint64_t **)(*((_QWORD *)v5 + 13) + 704));
        v64 = *(unsigned int **)(v62 + 256);
        *(_QWORD *)(v62 + 256) = v63;
        if (v64)
          CRYPTO_BUFFER_free(v64);
        if (!*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 256))
        {
LABEL_188:
          v58 = 80;
          goto LABEL_118;
        }
      }
    }
    if (BYTE3(v139))
    {
      v65 = v141 - 2;
      if (v141 >= 2)
      {
        v66 = __rev16(*v140);
        if (v65 >= v66 && v65 == v66 && v66)
        {
          v67 = v140 + 1;
          while (1)
          {
            v18 = v65 >= 2;
            v68 = v65 - 2;
            if (!v18)
              break;
            v69 = __rev16(*v67);
            if (v69 - 1 >= v68)
              break;
            v67 = (unsigned __int16 *)((char *)v67 + v69 + 2);
            v65 = v68 - v69;
            if (!v65)
            {
              if (*v22 == 1)
              {
                v70 = *(_QWORD *)(a1 + 1504);
                v71 = crypto_buffer_new(v140, v141, 0, *(uint64_t **)(*((_QWORD *)v5 + 13) + 704));
                v72 = *(unsigned int **)(v70 + 248);
                *(_QWORD *)(v70 + 248) = v71;
                if (v72)
                  CRYPTO_BUFFER_free(v72);
                if (!*(_QWORD *)(*(_QWORD *)(a1 + 1504) + 248))
                  goto LABEL_188;
              }
              goto LABEL_92;
            }
          }
        }
      }
      ERR_put_error(16, 0, 149, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 270);
LABEL_117:
      v58 = 50;
LABEL_118:
      v86 = v5;
LABEL_119:
      bssl::ssl_send_alert(v86, (ssl_st *)2, v58);
      goto LABEL_147;
    }
LABEL_92:
    v31 = (unsigned __int8 *)v40 + (_QWORD)v41;
    if (!v20)
      goto LABEL_93;
  }
  *(_OWORD *)c.h = v143;
  if ((bssl::ssl_cert_skip_to_spki((__int128 *)&c, &v139) & 1) != 0)
  {
    v42 = EVP_parse_public_key(&v139);
  }
  else
  {
    ERR_put_error(16, 0, 272, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_cert.cc", 333);
    v42 = 0;
  }
  if (v30)
  {
    for (j = atomic_load(v30); j != -1; j = v44)
    {
      if (!j)
LABEL_189:
        abort();
      v44 = __ldaxr(v30);
      if (v44 == j)
      {
        if (!__stlxr(j - 1, v30))
        {
          if (j == 1)
          {
            v45 = *((_QWORD *)v30 + 2);
            if (v45)
            {
              v46 = *(void (**)(unsigned int *))(v45 + 160);
              if (v46)
              {
                v46(v30);
                *((_QWORD *)v30 + 1) = 0;
                v30[1] = 0;
              }
            }
            v48 = *((_QWORD *)v30 - 1);
            v47 = v30 - 2;
            v49 = v48 + 8;
            if (v48 != -8)
              bzero(v47, v49);
            free(v47);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  if (!v42)
  {
    bssl::ssl_send_alert(v5, (ssl_st *)2, 50);
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 204);
    v30 = 0;
    goto LABEL_147;
  }
  if ((bssl::ssl_cert_check_key_usage(&v143, 0) & 1) != 0)
  {
    v35 = *((_QWORD *)&v143 + 1);
    v37 = (char *)v143;
    if (v137)
    {
      v50 = (_DWORD *)(*(_QWORD *)(a1 + 1504) + 264);
      memset(&c.Nl, 0, 76);
      *(_OWORD *)c.h = xmmword_208F25B20;
      *(_OWORD *)&c.h[4] = xmmword_208F25B30;
      c.md_len = 32;
      SHA256_Update(&c, (const void *)v143, *((size_t *)&v143 + 1));
      sha256_final_impl(v50, c.md_len, (int32x2_t *)&c);
      v35 = *((_QWORD *)&v143 + 1);
      v37 = (char *)v143;
    }
    v30 = v42;
    goto LABEL_61;
  }
  bssl::ssl_send_alert(v5, (ssl_st *)2, 47);
  v30 = v42;
LABEL_147:
  if (v30)
  {
    for (k = atomic_load(v30); k != -1; k = v107)
    {
      if (!k)
        goto LABEL_189;
      v107 = __ldaxr(v30);
      if (v107 == k)
      {
        if (!__stlxr(k - 1, v30))
        {
          if (k == 1)
          {
            v108 = *((_QWORD *)v30 + 2);
            if (v108)
            {
              v109 = *(void (**)(unsigned int *))(v108 + 160);
              if (v109)
              {
                v109(v30);
                *((_QWORD *)v30 + 1) = 0;
                v30[1] = 0;
              }
            }
            v111 = *((_QWORD *)v30 - 1);
            v110 = v30 - 2;
            v112 = v111 + 8;
            if (v111 != -8)
              bzero(v110, v112);
            free(v110);
          }
          break;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
  v113 = *v22;
  if (*v22)
  {
    v114 = 0;
    do
    {
      v115 = *(unsigned int **)(v22[1] + 8 * v114);
      if (v115)
      {
        CRYPTO_BUFFER_free(v115);
        v113 = *v22;
      }
      ++v114;
    }
    while (v114 < v113);
  }
  v116 = v22[1];
  if (v116)
  {
    v118 = *(_QWORD *)(v116 - 8);
    v117 = (void *)(v116 - 8);
    v119 = v118 + 8;
    if (v118 != -8)
      bzero(v117, v119);
    free(v117);
  }
  v121 = *(v22 - 1);
  v120 = v22 - 1;
  v122 = v121 + 8;
  if (v121 != -8)
    bzero(v120, v122);
  free(v120);
  v23 = 0;
  if (v15)
    goto LABEL_140;
  return v23;
}

uint64_t bssl::tls13_process_certificate_verify(uint64_t a1, uint64_t a2)
{
  bssl *v3;
  unint64_t v4;
  unsigned __int16 *v5;
  int v6;
  evp_pkey_st *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  __int16 *v11;
  uint64_t v12;
  bssl *v13;
  int v14;
  uint64_t v15;
  int cert_verify_signature_input;
  uint64_t v18;
  int v19;
  void *v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;

  if (!*(_QWORD *)(a1 + 1496))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 323);
    return 0;
  }
  v3 = *(bssl **)a1;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 < 2
    || (v4 & 0xFFFFFFFFFFFFFFFELL) == 2
    || (v5 = *(unsigned __int16 **)(a2 + 8), v6 = v4 - 4, v4 - 4 != __rev16(v5[1])))
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 332);
    v13 = v3;
    v14 = 50;
LABEL_8:
    bssl::ssl_send_alert(v13, (ssl_st *)2, v14);
    return 0;
  }
  v7 = (evp_pkey_st *)(bswap32(*v5) >> 16);
  v8 = (_DWORD)v5 + 4;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(v9 + 200);
  if (v10)
  {
    v11 = *(__int16 **)(v9 + 192);
    v12 = 2 * v10;
  }
  else
  {
    v11 = &bssl::kVerifySignatureAlgorithms;
    v12 = 18;
  }
  while ((unsigned __int16)*v11 != (_DWORD)v7)
  {
    ++v11;
    v12 -= 2;
    if (!v12)
    {
      ERR_put_error(16, 0, 245, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/extensions.cc", 451);
      v13 = v3;
      v14 = 47;
      goto LABEL_8;
    }
  }
  *(_WORD *)(*(_QWORD *)(a1 + 1504) + 8) = (_WORD)v7;
  v23 = 0;
  v24 = 0;
  cert_verify_signature_input = bssl::tls13_get_cert_verify_signature_input(a1, &v23, *((_BYTE *)v3 + 164) & 1);
  v18 = v23;
  if (cert_verify_signature_input)
  {
    if (bssl::ssl_public_key_verify(v3, v8, v6, v7, *(const ssl_st **)(a1 + 1496), v23, v24))
    {
      v15 = 1;
      goto LABEL_22;
    }
    ERR_put_error(16, 0, 114, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 354);
    v19 = 51;
  }
  else
  {
    v19 = 80;
  }
  bssl::ssl_send_alert(v3, (ssl_st *)2, v19);
  v15 = 0;
LABEL_22:
  if (v18)
  {
    v21 = *(_QWORD *)(v18 - 8);
    v20 = (void *)(v18 - 8);
    v22 = v21 + 8;
    if (v21 != -8)
      bzero(v20, v22);
    free(v20);
  }
  return v15;
}

uint64_t bssl::tls13_process_finished(uint64_t a1, uint64_t a2, int a3)
{
  bssl *v5;
  unsigned __int8 *v6;
  unint64_t v7;
  int8x16_t *v8;
  unint64_t v9;
  unsigned __int8 v10;
  char v11;
  uint64_t v12;
  void *v13;
  EVP_MD *v14;
  size_t v15;
  uint64_t pkey_type;
  int8x16_t *v17;
  int8x16_t *v18;
  int8x16_t v19;
  unint64_t v20;
  int8x16_t v21;
  int8x16_t v22;
  unint64_t v23;
  unint64_t v24;
  int8x8_t v25;
  int8x8_t *v26;
  int8x8_t *v27;
  unint64_t v28;
  int8x8_t v29;
  int8x8_t v30;
  int8x8_t v31;
  uint64_t v32;
  unint64_t v33;
  unsigned __int8 *v34;
  __int8 *v35;
  char v36;
  char v37;
  char v38;
  unint64_t v40;
  unsigned int md_len;
  unsigned __int8 md[64];
  unsigned __int8 d[64];
  _BYTE key[64];
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  v5 = *(bssl **)a1;
  if (a3)
  {
    v6 = (unsigned __int8 *)(a1 + 328);
    v7 = *(_QWORD *)(a1 + 32);
    if (*(_QWORD *)(a2 + 16) == v7)
      goto LABEL_3;
LABEL_26:
    bssl::ssl_send_alert(v5, (ssl_st *)2, 51);
    ERR_put_error(16, 0, 142, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 385);
    return 0;
  }
  v11 = *((_BYTE *)v5 + 164);
  v12 = *(_QWORD *)(a1 + 32);
  v40 = 0;
  if (!bssl::SSLTranscript::GetHash((bssl::SSLTranscript *)(a1 + 408), d, &v40))
    return 0;
  v13 = (void *)((v11 & 1) != 0 ? a1 + 136 : a1 + 184);
  v14 = *(EVP_MD **)(a1 + 416);
  v15 = v40;
  pkey_type = v14->pkey_type;
  md_len = 0;
  if (CRYPTO_tls13_hkdf_expand_label((uint64_t)key, pkey_type, v14, v13, v12, "finished", 8uLL, 0, 0) != 1
    || !HMAC(v14, key, pkey_type, d, v15, md, &md_len))
  {
    return 0;
  }
  v7 = md_len;
  v6 = md;
  if (*(_QWORD *)(a2 + 16) != md_len)
    goto LABEL_26;
LABEL_3:
  if (!v7)
    return 1;
  v8 = *(int8x16_t **)(a2 + 8);
  if (v7 < 8)
  {
    v9 = 0;
    v10 = 0;
    goto LABEL_23;
  }
  if (v7 >= 0x20)
  {
    v9 = v7 & 0xFFFFFFFFFFFFFFE0;
    v17 = v8 + 1;
    v18 = (int8x16_t *)(v6 + 16);
    v19 = 0uLL;
    v20 = v7 & 0xFFFFFFFFFFFFFFE0;
    v21 = 0uLL;
    do
    {
      v19 = vorrq_s8(veorq_s8(v18[-1], v17[-1]), v19);
      v21 = vorrq_s8(veorq_s8(*v18, *v17), v21);
      v17 += 2;
      v18 += 2;
      v20 -= 32;
    }
    while (v20);
    v22 = vorrq_s8(v21, v19);
    *(int8x8_t *)v22.i8 = vorr_s8(*(int8x8_t *)v22.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
    v23 = v22.i64[0] | HIDWORD(v22.i64[0]) | ((unint64_t)(v22.i64[0] | HIDWORD(v22.i64[0])) >> 16);
    v10 = v23 | BYTE1(v23);
    if (v7 == v9)
      goto LABEL_25;
    if ((v7 & 0x18) == 0)
    {
LABEL_23:
      v33 = v7 - v9;
      v34 = &v6[v9];
      v35 = &v8->i8[v9];
      do
      {
        v37 = *v35++;
        v36 = v37;
        v38 = *v34++;
        v10 |= v38 ^ v36;
        --v33;
      }
      while (v33);
      goto LABEL_25;
    }
  }
  else
  {
    v10 = 0;
    v9 = 0;
  }
  v24 = v9;
  v9 = v7 & 0xFFFFFFFFFFFFFFF8;
  v25 = (int8x8_t)v10;
  v26 = (int8x8_t *)&v8->i8[v24];
  v27 = (int8x8_t *)&v6[v24];
  v28 = v24 - (v7 & 0xFFFFFFFFFFFFFFF8);
  do
  {
    v29 = *v26++;
    v30 = v29;
    v31 = *v27++;
    v25 = vorr_s8(veor_s8(v31, v30), v25);
    v28 += 8;
  }
  while (v28);
  v32 = *(_QWORD *)&v25 | HIDWORD(*(_QWORD *)&v25) | ((*(_QWORD *)&v25 | HIDWORD(*(_QWORD *)&v25)) >> 16);
  v10 = v32 | BYTE1(v32);
  if (v7 != v9)
    goto LABEL_23;
LABEL_25:
  if (v10)
    goto LABEL_26;
  return 1;
}

uint64_t bssl::tls13_add_certificate(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  size_t v11;
  int v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  const void *v16;
  size_t v17;
  void *v18;
  uint64_t v19;
  size_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  size_t v27;
  uint64_t v28;
  unsigned int (*v29)(_QWORD *, uint64_t *, void *, size_t);
  void *v30;
  const void *v31;
  size_t v32;
  size_t v33;
  size_t v34;
  void *__s2;
  size_t v36;
  uint64_t v37;
  char v38;
  _QWORD *v39;
  size_t v40;
  unsigned __int8 v41;
  void *__dst[6];
  _BYTE v43[48];
  uint64_t v44[6];
  uint64_t v45[6];
  _OWORD v46[3];
  _BYTE *v47;

  v3 = *(_QWORD **)this;
  v4 = *((_QWORD *)this + 186);
  memset(v46, 0, sizeof(v46));
  if ((*((_BYTE *)this + 1570) & 0x10) != 0)
  {
    memset(v46, 0, sizeof(v46));
    v7 = malloc_type_malloc(0x408uLL, 0x30772F57uLL);
    if (!v7)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v6 = 0;
      if (BYTE8(v46[0]))
        return v6;
      goto LABEL_60;
    }
    *v7 = 1024;
    BYTE8(v46[0]) = 0;
    *(_QWORD *)&v46[0] = 0;
    *(_QWORD *)&v46[1] = v7 + 1;
    *(_OWORD *)((char *)&v46[1] + 8) = xmmword_208F30C60;
    BYTE8(v46[2]) = 1;
    v5 = (uint64_t *)v46;
  }
  else
  {
    v5 = v45;
    if (!(*(unsigned int (**)(_QWORD *, _OWORD *, uint64_t *, uint64_t))(*v3 + 88))(v3, v46, v45, 11))
    {
      v6 = 0;
      if (BYTE8(v46[0]))
        return v6;
      goto LABEL_60;
    }
  }
  v44[0] = 0;
  if (!CBB_add_space((uint64_t)v5, v44, 1)
    || (*(_BYTE *)v44[0] = 0, !CBB_flush(v5))
    || !cbb_add_child((uint64_t)v5, (uint64_t)v44, 3u, 0))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 414);
    v6 = 0;
    if (BYTE8(v46[0]))
      return v6;
    goto LABEL_60;
  }
  if (!*((_QWORD *)this + 186))
    goto LABEL_57;
  v8 = *(_QWORD *)(v4 + 48);
  if (v8 && *(_QWORD *)v8)
  {
    v9 = **(_QWORD **)(v8 + 8);
    if (!CBB_flush(v44))
      goto LABEL_59;
  }
  else
  {
    v9 = 0;
    if (!CBB_flush(v44))
      goto LABEL_59;
  }
  if (!cbb_add_child((uint64_t)v44, (uint64_t)v43, 3u, 0))
    goto LABEL_59;
  v10 = *(const void **)(v9 + 8);
  v11 = *(_QWORD *)(v9 + 16);
  __dst[0] = 0;
  if (!CBB_add_space((uint64_t)v43, __dst, v11))
    goto LABEL_59;
  if (v11)
    memcpy(__dst[0], v10, v11);
  if (!CBB_flush(v44) || !cbb_add_child((uint64_t)v44, (uint64_t)__dst, 2u, 0))
  {
LABEL_59:
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 429);
    v6 = 0;
    if (BYTE8(v46[0]))
      return v6;
    goto LABEL_60;
  }
  v12 = *((_DWORD *)this + 392);
  if ((v12 & 4) != 0 && *(_QWORD *)(v4 + 72))
  {
    if (!CBB_add_u16((uint64_t)__dst, 18)
      || !CBB_add_u16_length_prefixed((uint64_t *)__dst, (uint64_t)&v37)
      || !CBB_add_bytes((uint64_t)&v37, *(const void **)(*(_QWORD *)(v4 + 72) + 8), *(_QWORD *)(*(_QWORD *)(v4 + 72) + 16))|| !CBB_flush((uint64_t *)__dst))
    {
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 442);
      v6 = 0;
      if (BYTE8(v46[0]))
        return v6;
      goto LABEL_60;
    }
    v12 = *((_DWORD *)this + 392);
  }
  if ((v12 & 0x80) != 0)
  {
    if (*(_QWORD *)(v4 + 80))
    {
      if (!CBB_add_u16((uint64_t)__dst, 5)
        || !CBB_add_u16_length_prefixed((uint64_t *)__dst, (uint64_t)&v37)
        || (v47 = 0, !CBB_add_space((uint64_t)&v37, &v47, 1))
        || (*v47 = 1, !CBB_add_u24_length_prefixed(&v37, (uint64_t)&__s2))
        || !CBB_add_bytes((uint64_t)&__s2, *(const void **)(*(_QWORD *)(v4 + 80) + 8), *(_QWORD *)(*(_QWORD *)(v4 + 80) + 16))|| !CBB_flush((uint64_t *)__dst))
      {
        ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 457);
        v6 = 0;
        if (BYTE8(v46[0]))
          return v6;
        goto LABEL_60;
      }
    }
  }
  if (*(_DWORD *)(v4 + 4) == 1
    && (!CBB_add_u16((uint64_t)__dst, 34)
     || !CBB_add_u16_length_prefixed((uint64_t *)__dst, (uint64_t)&v37)
     || !CBB_add_bytes((uint64_t)&v37, *(const void **)(*(_QWORD *)(v4 + 56) + 8), *(_QWORD *)(*(_QWORD *)(v4 + 56) + 16))|| !CBB_flush((uint64_t *)__dst)))
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 469);
    v6 = 0;
    if (BYTE8(v46[0]))
      return v6;
    goto LABEL_60;
  }
  v13 = *(unint64_t **)(v4 + 48);
  if (v13)
  {
    v14 = 1;
    while (v14 < *v13)
    {
      v15 = *(_QWORD *)(v13[1] + 8 * v14);
      if (!CBB_flush(v44))
        goto LABEL_72;
      if (!cbb_add_child((uint64_t)v44, (uint64_t)&v37, 3u, 0))
        goto LABEL_72;
      v16 = *(const void **)(v15 + 8);
      v17 = *(_QWORD *)(v15 + 16);
      __s2 = 0;
      if (!CBB_add_space((uint64_t)&v37, &__s2, v17))
        goto LABEL_72;
      if (v17)
        memcpy(__s2, v16, v17);
      __s2 = 0;
      if (!CBB_add_space((uint64_t)v44, &__s2, 2))
      {
LABEL_72:
        ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 481);
        v6 = 0;
        if (BYTE8(v46[0]))
          return v6;
        goto LABEL_60;
      }
      *((_BYTE *)__s2 + 1) = 0;
      *(_BYTE *)__s2 = 0;
      ++v14;
      v13 = *(unint64_t **)(v4 + 48);
      if (!v13)
        break;
    }
  }
  if ((*((_BYTE *)this + 1570) & 0x10) == 0)
  {
LABEL_57:
    v6 = bssl::ssl_add_message_cbb((uint64_t)v3, (uint64_t)v46);
    if (BYTE8(v46[0]))
      return v6;
    goto LABEL_60;
  }
  __s2 = 0;
  v36 = 0;
  if ((bssl::CBBFinishArray((uint64_t)v46, (uint64_t *)&__s2) & 1) == 0)
  {
    v26 = 492;
LABEL_99:
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", v26);
    goto LABEL_100;
  }
  v22 = v3[13];
  v23 = *(_QWORD *)(v22 + 632);
  if (!v23)
    goto LABEL_98;
  v24 = *(_QWORD *)(v22 + 640);
  v25 = 24 * v23;
  while (*(unsigned __int16 *)(v24 + 16) != *((unsigned __int16 *)this + 356))
  {
    v24 += 24;
    v25 -= 24;
    if (!v25)
      goto LABEL_98;
  }
  if (!*(_QWORD *)v24)
  {
LABEL_98:
    v26 = 505;
    goto LABEL_99;
  }
  if (!(*(unsigned int (**)(_QWORD *, _OWORD *, uint64_t *, uint64_t))(*v3 + 88))(v3, v46, v45, 25)
    || !CBB_add_u16((uint64_t)v45, *((_WORD *)this + 356))
    || (v27 = v36, v36 >> 24)
    || !CBB_add_u24((uint64_t)v45, v36)
    || !CBB_add_u24_length_prefixed(v45, (uint64_t)&v37))
  {
    v26 = 517;
    goto LABEL_99;
  }
  v28 = *((_QWORD *)this + 195);
  if (v28)
  {
    if ((*((_BYTE *)this + 1570) & 8) == 0
      && *(unsigned __int16 *)(v28 + 146) == *((unsigned __int16 *)this + 356)
      && *(_QWORD *)(v28 + 160) == v27
      && !memcmp(*(const void **)(v28 + 152), __s2, v27))
    {
      v34 = *(_QWORD *)(v28 + 176);
      if (v34)
      {
        if (!CBB_add_bytes((uint64_t)&v37, *(const void **)(v28 + 168), v34))
        {
          v26 = 528;
          goto LABEL_99;
        }
LABEL_95:
        if ((bssl::ssl_add_message_cbb((uint64_t)v3, (uint64_t)v46) & 1) != 0)
        {
          v6 = 1;
          OPENSSL_free(__s2);
          if (BYTE8(v46[0]))
            return v6;
          goto LABEL_60;
        }
        v26 = 547;
        goto LABEL_99;
      }
    }
  }
  v29 = *(unsigned int (**)(_QWORD *, uint64_t *, void *, size_t))v24;
  v30 = __s2;
  if (!v29(v3, &v37, __s2, v27))
  {
    v26 = 533;
    goto LABEL_99;
  }
  if (!v28 || (*((_BYTE *)this + 1570) & 8) == 0)
    goto LABEL_95;
  *(_WORD *)(v28 + 146) = *((_WORD *)this + 356);
  if (bssl::Array<unsigned char>::CopyFrom((uint64_t *)(v28 + 152), v30, v27))
  {
    v31 = v39;
    if (v38)
    {
      v32 = v40 + v41;
      v31 = (const void *)(v32 + *v39);
      v33 = v39[1] - v32;
    }
    else
    {
      v33 = v40;
    }
    if (bssl::Array<unsigned char>::CopyFrom((uint64_t *)(v28 + 168), v31, v33))
      goto LABEL_95;
  }
LABEL_100:
  v6 = 0;
  OPENSSL_free(__s2);
  if (BYTE8(v46[0]))
    return v6;
LABEL_60:
  if ((BYTE8(v46[2]) & 1) != 0 && *(_QWORD *)&v46[1])
  {
    v19 = *(_QWORD *)(*(_QWORD *)&v46[1] - 8);
    v18 = (void *)(*(_QWORD *)&v46[1] - 8);
    v20 = v19 + 8;
    if (v19 != -8)
      bzero(v18, v20);
    free(v18);
  }
  return v6;
}

uint64_t bssl::tls13_add_certificate_verify(bssl **this, bssl::SSL_HANDSHAKE *a2)
{
  bssl *v3;
  __int16 v4;
  uint64_t v5;
  uint64_t v6;
  int (*v7)(void);
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  char *v15;
  uint64_t v16;
  size_t v17;
  unint64_t *v18;
  unint64_t v19;
  BOOL v20;
  uint64_t *v21;
  _QWORD *v22;
  size_t v23;
  unint64_t v24;
  void *v25;
  _BYTE *v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31[6];
  __int128 v32;
  __int128 v33;
  __int128 v34;

  v3 = *this;
  v33 = 0u;
  v34 = 0u;
  v32 = 0u;
  if ((*(unsigned int (**)(bssl *, __int128 *, uint64_t *, uint64_t))(*(_QWORD *)v3 + 88))(v3, &v32, v31, 15)&& (v4 = *((_WORD *)this + 789), v26 = 0, CBB_add_space((uint64_t)v31, &v26, 2)))
  {
    v26[1] = v4;
    *v26 = HIBYTE(v4);
    v5 = *((_QWORD *)this[186] + 1);
    if (v5 && (v6 = *(_QWORD *)(v5 + 16)) != 0 && (v7 = *(int (**)(void))(v6 + 120)) != 0)
    {
      v8 = v7();
      v24 = 0;
      v25 = 0;
      if (!CBB_flush(v31))
        goto LABEL_15;
    }
    else
    {
      v8 = 0;
      v24 = 0;
      v25 = 0;
      if (!CBB_flush(v31))
      {
LABEL_15:
        v9 = 2;
        bssl::ssl_send_alert(v3, (ssl_st *)2, 80);
        goto LABEL_16;
      }
    }
    if (!cbb_add_child((uint64_t)v31, (uint64_t)&v26, 2u, 0)
      || !CBB_reserve((uint64_t)&v26, &v25, v8))
    {
      goto LABEL_15;
    }
    v22 = 0;
    v23 = 0;
    if ((bssl::tls13_get_cert_verify_signature_input((uint64_t)this, (uint64_t *)&v22, (*((_BYTE *)v3 + 164) & 1) == 0) & 1) != 0)
    {
      v10 = v22;
      v11 = bssl::ssl_private_key_sign((uint64_t)this, v25, &v24, v8, (evp_pkey_st *)*((unsigned __int16 *)this + 789), v22, v23);
      if ((_DWORD)v11)
      {
        v9 = v11;
      }
      else
      {
        v18 = (unint64_t *)&v29;
        if (v27)
          v18 = (unint64_t *)(v28 + 8);
        v19 = *v18 + v24;
        v20 = __CFADD__(*v18, v24);
        v9 = 2;
        if (!v26 && !v20)
        {
          v21 = v27 ? (uint64_t *)(v28 + 16) : &v30;
          if (v19 <= *v21)
          {
            *v18 = v19;
            if (bssl::ssl_add_message_cbb((uint64_t)v3, (uint64_t)&v32))
              v9 = 0;
            else
              v9 = 2;
          }
        }
      }
    }
    else
    {
      v9 = 2;
      bssl::ssl_send_alert(v3, (ssl_st *)2, 80);
      v10 = v22;
    }
    if (v10)
    {
      v16 = *(v10 - 1);
      v15 = (char *)(v10 - 1);
      v17 = v16 + 8;
      if (v16 != -8)
        bzero(v15, v17);
      free(v15);
    }
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 562);
    v9 = 2;
  }
LABEL_16:
  if (BYTE8(v32) || (BYTE8(v34) & 1) == 0 || !(_QWORD)v33)
    return v9;
  v13 = (void *)(v33 - 8);
  v12 = *(_QWORD *)(v33 - 8);
  if (v12 != -8)
    bzero((void *)(v33 - 8), v12 + 8);
  free(v13);
  return v9;
}

uint64_t bssl::tls13_add_finished(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  bssl *v3;
  char v4;
  uint64_t v5;
  char *v6;
  EVP_MD *v7;
  void *v8;
  uint64_t pkey_type;
  size_t v10;
  uint64_t v11;
  void *v13;
  uint64_t v14;
  size_t v15;
  unsigned int md_len;
  void *__dst;
  unsigned __int8 md[64];
  unsigned __int8 d[64];
  __int128 key;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v3 = *(bssl **)this;
  v4 = *(_BYTE *)(*(_QWORD *)this + 164);
  v5 = *((_QWORD *)this + 4);
  __dst = 0;
  if (!bssl::SSLTranscript::GetHash((bssl *)((char *)this + 408), d, (unint64_t *)&__dst)
    || ((v4 & 1) != 0 ? (v6 = (char *)this + 184) : (v6 = (char *)this + 136),
        (v7 = (EVP_MD *)*((_QWORD *)this + 52),
         v8 = __dst,
         pkey_type = v7->pkey_type,
         md_len = 0,
         CRYPTO_tls13_hkdf_expand_label((uint64_t)&key, pkey_type, v7, v6, v5, "finished", 8uLL, 0, 0) != 1)
     || !HMAC(v7, &key, pkey_type, d, (size_t)v8, md, &md_len)))
  {
    bssl::ssl_send_alert(v3, (ssl_st *)2, 80);
    ERR_put_error(16, 0, 142, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 605);
    return 0;
  }
  v10 = md_len;
  v21 = 0u;
  v22 = 0u;
  key = 0u;
  if (!(*(unsigned int (**)(bssl *, __int128 *, unsigned __int8 *, uint64_t))(*(_QWORD *)v3 + 88))(v3, &key, d, 20)|| (__dst = 0, !CBB_add_space((uint64_t)d, &__dst, v10)))
  {
    v11 = 0;
    if (BYTE8(key))
      return v11;
    goto LABEL_16;
  }
  if ((_DWORD)v10)
    memcpy(__dst, md, v10);
  v11 = bssl::ssl_add_message_cbb((uint64_t)v3, (uint64_t)&key);
  if (!BYTE8(key))
  {
LABEL_16:
    if ((BYTE8(v22) & 1) != 0 && (_QWORD)v21)
    {
      v14 = *(_QWORD *)(v21 - 8);
      v13 = (void *)(v21 - 8);
      v15 = v14 + 8;
      if (v14 != -8)
        bzero(v13, v15);
      free(v13);
    }
  }
  return v11;
}

uint64_t bssl::tls13_post_handshake(bssl *this, uint64_t a2, const ssl_cipher_st *a3)
{
  int v4;
  uint64_t v5;
  unsigned __int8 v6;
  unsigned int v7;
  int v8;
  uint64_t result;
  const ssl_cipher_st *v10;
  bssl *v11;
  int v12;
  _BYTE v13[48];
  _OWORD v14[3];
  _BYTE *v15;

  v4 = *(unsigned __int8 *)(a2 + 1);
  v5 = *((_QWORD *)this + 6);
  if (v4 != 24)
  {
    *(_BYTE *)(v5 + 212) = 0;
    if (v4 == 4 && (*((_BYTE *)this + 164) & 1) == 0)
      return bssl::tls13_process_new_session_ticket(this, a2);
    bssl::ssl_send_alert(this, (ssl_st *)2, 10);
    ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 685);
    return 0;
  }
  v6 = *(_BYTE *)(v5 + 212) + 1;
  *(_BYTE *)(v5 + 212) = v6;
  if (*((_QWORD *)this + 19) || v6 >= 0x21u)
  {
    ERR_put_error(16, 0, 260, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 670);
    v11 = this;
    v12 = 10;
LABEL_20:
    bssl::ssl_send_alert(v11, (ssl_st *)2, v12);
    return 0;
  }
  if (*(_QWORD *)(a2 + 16) != 1 || (v7 = **(unsigned __int8 **)(a2 + 8), v7 >= 2))
  {
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_both.cc", 646);
    v11 = this;
    v12 = 50;
    goto LABEL_20;
  }
  v8 = bssl::tls13_rotate_traffic_key((uint64_t)this, 0, a3);
  result = 0;
  if (!v8)
    return result;
  if (v7 != 1 || (*(_WORD *)(*((_QWORD *)this + 6) + 220) & 0x200) != 0)
    return 1;
  memset(v14, 0, sizeof(v14));
  if ((*(unsigned int (**)(bssl *, _OWORD *, _BYTE *, uint64_t))(*(_QWORD *)this + 88))(this, v14, v13, 24))
  {
    v15 = 0;
    if (CBB_add_space((uint64_t)v13, &v15, 1))
    {
      *v15 = 0;
      if (bssl::ssl_add_message_cbb((uint64_t)this, (uint64_t)v14))
      {
        if ((bssl::tls13_rotate_traffic_key((uint64_t)this, 1u, v10) & 1) != 0)
        {
          *(_WORD *)(*((_QWORD *)this + 6) + 220) |= 0x200u;
          CBB_cleanup((uint64_t)v14);
          return 1;
        }
      }
    }
  }
  CBB_cleanup((uint64_t)v14);
  return 0;
}

uint64_t bssl::tls13_client_handshake(bssl *this, ssl_st *a2)
{
  int8x16_t *v3;
  char *v4;
  char *v5;
  char *v6;
  int v7;
  uint64_t v8;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 v19;
  bssl *v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  size_t v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  bssl *v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  unsigned __int16 *v40;
  unsigned __int16 *v41;
  unsigned __int16 *v42;
  char *v43;
  unsigned __int16 *v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t **v47;
  unint64_t *v48;
  unint64_t *v49;
  int v50;
  bssl *v51;
  bssl *v52;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  bssl *v58;
  uint64_t (*v59)(_QWORD, unsigned __int8 *);
  int v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  const char *v64;
  int v65;
  _QWORD *v66;
  uint64_t v67;
  __int16 v68;
  char v69;
  uint64_t v70;
  const void *v71;
  size_t v72;
  int v73;
  bssl *v74;
  int v75;
  uint64_t v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t *v81;
  void *v82;
  uint64_t v83;
  size_t v84;
  int v85;
  uint64_t v86;
  uint64_t (*v87)(_QWORD, _QWORD);
  int v88;
  char *v89;
  char *v90;
  int8x16_t *v91;
  unsigned int **v92;
  uint64_t v93;
  unsigned int *v94;
  unsigned int v95;
  unsigned int v96;
  char v97;
  unsigned int *v98;
  unsigned int i;
  void *v100;
  uint64_t v101;
  size_t v102;
  void *v103;
  uint64_t v104;
  size_t v105;
  unsigned int v106;
  unsigned int *v107;
  uint64_t v108;
  size_t v109;
  uint64_t v110;
  void *v111;
  uint64_t v112;
  size_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  char v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  BOOL v125;
  BOOL v126;
  uint64_t v128;
  uint64_t *v129;
  uint64_t *v130;
  uint64_t v131;
  __int128 v132;
  __int128 v133;
  uint64_t v134;
  bssl::SSL_HANDSHAKE *v135;
  unsigned __int16 *v136;
  uint64_t v137;
  ssl_session_st *v138;
  unint64_t *v139;
  SSL_SESSION *v140;
  SSL_SESSION *v141;
  const ssl_st *v142;
  _BOOL4 v143;
  int8x16_t v144;
  int8x16_t v145;
  int8x16_t v146;
  unint64_t v147;
  uint64_t v148;
  int8x8_t v149;
  int8x8_t *v150;
  int8x8_t *v151;
  uint64_t v152;
  int8x8_t v153;
  int8x8_t v154;
  int8x8_t v155;
  uint64_t v156;
  uint64_t v157;
  __int8 *v158;
  char *v159;
  char v160;
  char v161;
  char v162;
  BOOL v163;
  uint64_t v164;
  uint64_t v165;
  int v166;
  int v167;
  int8x16_t v168;
  int8x16_t v169;
  int8x16_t v170;
  unint64_t v171;
  uint64_t v172;
  int8x8_t v173;
  int8x8_t *v174;
  int8x8_t *v175;
  uint64_t v176;
  int8x8_t v177;
  int8x8_t v178;
  int8x8_t v179;
  uint64_t v180;
  uint64_t v181;
  __int8 *v182;
  char *v183;
  char v184;
  char v185;
  char v186;
  const ssl_cipher_st *v188;
  const ssl_st *v189;
  const ssl_cipher_st *v190;
  int id_high;
  unsigned int v192;
  int v193;
  int v194;
  unsigned int v195;
  bssl *v196;
  int v197;
  size_t v198;
  unsigned __int16 v199;
  const ssl_st *v200;
  _BOOL4 v204;
  bssl *v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  int v209;
  bssl *v210;
  uint64_t v211;
  int v212;
  unsigned __int8 v213;
  uint64_t v214;
  uint64_t v215;
  unint64_t v216;
  _QWORD *v217;
  uint64_t v218;
  uint64_t v219;
  unint64_t v220;
  _QWORD *v221;
  uint64_t v222;
  uint64_t v223;
  bssl *v224;
  const ssl_cipher_st *v225;
  uint64_t *handshake_digest;
  size_t v227;
  const unsigned __int8 *v228;
  char *v229;
  unint64_t *v230;
  int v231;
  void (*v232)(void);
  uint64_t v233;
  bssl::SSL_HANDSHAKE *v234;
  unint64_t v235;
  unsigned __int16 *v236;
  unsigned __int16 *v237;
  unint64_t v238;
  _QWORD *v239;
  unsigned __int16 *v240;
  int v241;
  unsigned int v242;
  unint64_t v243;
  uint64_t v244;
  int8x16_t *v246;
  void *__src;
  char *__srca;
  void *__srcb;
  void *__srcc;
  char *v251;
  char *v252;
  _OWORD *v253;
  _OWORD *v254;
  uint64_t **v255;
  char *v256;
  uint64_t **v257;
  char *v258;
  _WORD v259[4];
  uint64_t v260;
  uint64_t v261;
  BOOL v262;
  char v263[9];
  unsigned __int16 *v264;
  unint64_t v265;
  unsigned __int16 *v266;
  unsigned __int16 *v267;
  unint64_t v268;
  uint64_t v269;
  unsigned __int16 *v270;
  uint64_t v271;
  void *v272;
  size_t v273;
  unsigned __int8 *p_key;
  uint64_t *v275;
  char *v276;
  unsigned __int8 v277[16];
  __int128 v278;
  __int128 v279;
  uint64_t v280;
  unsigned __int16 v281;
  char v282;
  unsigned __int16 *v283;
  uint64_t v284;
  __int128 __key;
  unint64_t **v286;
  _WORD *v287;
  uint64_t v288;

  v3 = (int8x16_t *)((char *)this + 1581);
  v4 = (char *)this + 232;
  v5 = (char *)this + 280;
  v288 = *MEMORY[0x24BDAC8D0];
  v6 = (char *)this + 136;
  v257 = (uint64_t **)((char *)this + 408);
  v258 = (char *)this + 416;
  v254 = (_OWORD *)((char *)this + 456);
  v255 = (uint64_t **)((char *)this + 448);
  v253 = (_OWORD *)((char *)this + 488);
  v251 = (char *)this + 184;
  v252 = (char *)this + 520;
  v256 = (char *)this + 40;
  while (2)
  {
    v7 = *((_DWORD *)this + 6);
    v8 = 1;
    switch(v7)
    {
      case 0:
        v9 = *(unsigned __int16 **)this;
        if (!(*(unsigned int (**)(_QWORD, uint64_t *))(**(_QWORD **)this + 24))(*(_QWORD *)this, &v269))
          goto LABEL_106;
        if ((*((_BYTE *)this + 1569) & 8) == 0
          && !(*(unsigned int (**)(unsigned __int16 *))(*(_QWORD *)v9 + 112))(v9))
        {
          goto LABEL_430;
        }
        LOWORD(v278) = 0;
        v281 = 0;
        v282 = 0;
        v263[0] = 50;
        if ((bssl::ssl_parse_server_hello((uint64_t)v277, v263, (uint64_t)&v269) & 1) == 0)
          goto LABEL_427;
        if ((unsigned __int16)v278 != 771)
          goto LABEL_331;
        if (v282)
          goto LABEL_331;
        v10 = *((unsigned __int8 *)this + 1613);
        if (v280 != v10)
          goto LABEL_331;
        if (!*((_BYTE *)this + 1613))
        {
          v143 = 1;
          goto LABEL_326;
        }
        if (v10 < 8)
        {
          v11 = 0;
          v12 = 0;
LABEL_323:
          v181 = v10 - v11;
          v182 = &v3->i8[v11];
          v183 = (char *)(*((_QWORD *)&v279 + 1) + v11);
          do
          {
            v185 = *v183++;
            v184 = v185;
            v186 = *v182++;
            v12 |= v186 ^ v184;
            --v181;
          }
          while (v181);
          goto LABEL_325;
        }
        if (v10 >= 0x20)
        {
          v11 = v10 & 0xE0;
          v168 = veorq_s8(*v3, **((int8x16_t **)&v279 + 1));
          v169 = veorq_s8(v3[1], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 16));
          if (v11 != 32)
          {
            v168 = vorrq_s8(veorq_s8(v3[2], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 32)), v168);
            v169 = vorrq_s8(veorq_s8(v3[3], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 48)), v169);
            if (v11 != 64)
            {
              v168 = vorrq_s8(veorq_s8(v3[4], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 64)), v168);
              v169 = vorrq_s8(veorq_s8(v3[5], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 80)), v169);
              if (v11 != 96)
              {
                v168 = vorrq_s8(veorq_s8(v3[6], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 96)), v168);
                v169 = vorrq_s8(veorq_s8(v3[7], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 112)), v169);
                if (v11 != 128)
                {
                  v168 = vorrq_s8(veorq_s8(v3[8], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 128)), v168);
                  v169 = vorrq_s8(veorq_s8(v3[9], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 144)), v169);
                  if (v11 != 160)
                  {
                    v168 = vorrq_s8(veorq_s8(v3[10], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 160)), v168);
                    v169 = vorrq_s8(veorq_s8(v3[11], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 176)), v169);
                    if (v11 != 192)
                    {
                      v168 = vorrq_s8(veorq_s8(v3[12], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 192)), v168);
                      v169 = vorrq_s8(veorq_s8(v3[13], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 208)), v169);
                    }
                  }
                }
              }
            }
          }
          v170 = vorrq_s8(v169, v168);
          *(int8x8_t *)v170.i8 = vorr_s8(*(int8x8_t *)v170.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v170, v170, 8uLL));
          v171 = v170.i64[0] | HIDWORD(v170.i64[0]) | ((unint64_t)(v170.i64[0] | HIDWORD(v170.i64[0])) >> 16);
          v12 = v171 | BYTE1(v171);
          if (v11 == v10)
            goto LABEL_325;
          if ((v10 & 0x18) == 0)
            goto LABEL_323;
        }
        else
        {
          v12 = 0;
          v11 = 0;
        }
        v172 = v11;
        v11 = v10 & 0xF8;
        v173 = (int8x8_t)v12;
        v174 = (int8x8_t *)(*((_QWORD *)&v279 + 1) + v172);
        v175 = (int8x8_t *)&v3->i8[v172];
        v176 = v172 - v11;
        do
        {
          v177 = *v174++;
          v178 = v177;
          v179 = *v175++;
          v173 = vorr_s8(veor_s8(v179, v178), v173);
          v176 += 8;
        }
        while (v176);
        v180 = *(_QWORD *)&v173 | HIDWORD(*(_QWORD *)&v173) | ((*(_QWORD *)&v173 | HIDWORD(*(_QWORD *)&v173)) >> 16);
        v12 = v180 | BYTE1(v180);
        if (v11 != v10)
          goto LABEL_323;
LABEL_325:
        v143 = v12 == 0;
LABEL_326:
        if (!v143 || v284 == 0)
        {
LABEL_331:
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", 116);
          v50 = 50;
          v263[0] = 50;
          goto LABEL_428;
        }
        LODWORD(v286) = v281 | 0x3000000;
        v188 = (const ssl_cipher_st *)bsearch(&__key, bssl::kCiphers, 0x18uLL, 0x28uLL, (int (__cdecl *)(const void *, const void *))ssl_cipher_id_cmp_void);
        if (!v188)
          goto LABEL_376;
        v190 = v188;
        id_high = HIDWORD(v188->id);
        if (id_high == 8 || LODWORD(v188->algorithms) == 16)
        {
          v192 = 772;
        }
        else if (HIDWORD(v188->algo_strength) == 1)
        {
          v192 = 768;
        }
        else
        {
          v192 = 771;
        }
        v195 = v9[8];
        if (v195 - 769 >= 4)
        {
          if (v195 == 65277)
          {
            v195 = 771;
          }
          else if (v195 == 65279)
          {
            v195 = 770;
          }
          else
          {
            v195 = 0;
          }
        }
        if (v192 > v195
          || (id_high != 8 ? (LODWORD(v188->algorithms) != 16 ? (v199 = 771) : (v199 = 772)) : (v199 = 772),
              bssl::ssl_protocol_version((bssl *)v9, v189) > v199
           || (bssl::ssl_tls13_cipher_meets_policy(LOWORD(v190->id), *(_DWORD *)(*((_QWORD *)v9 + 1) + 232)) & 1) == 0))
        {
LABEL_376:
          v193 = 242;
          v194 = 203;
LABEL_377:
          ERR_put_error(16, 0, v193, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", v194);
          v51 = (bssl *)v9;
          v50 = 47;
LABEL_429:
          bssl::ssl_send_alert(v51, (ssl_st *)2, v50);
LABEL_430:
          v8 = 0;
          goto LABEL_431;
        }
        *((_QWORD *)this + 192) = v190;
        v204 = (_QWORD)v279 == 32
            && **((_QWORD **)&v278 + 1) == 0x11619AE574AD21CFLL
            && *(_QWORD *)(*((_QWORD *)&v278 + 1) + 8) == 0x91B8651E028C1DBELL
            && *(_QWORD *)(*((_QWORD *)&v278 + 1) + 16) == 0x5E8CBB7A1611A2C2
            && *(_QWORD *)(*((_QWORD *)&v278 + 1) + 24) == 0x9C33A8C8E2099E07;
        v205 = (bssl *)bssl::ssl_protocol_version((bssl *)v9, v200);
        if (!bssl::SSLTranscript::InitHash(v257, v205, v190)
          || v204 && !bssl::SSLTranscript::UpdateForHelloRetryRequest((bssl::SSLTranscript *)v257))
        {
          goto LABEL_430;
        }
        if (*((_QWORD *)this + 191))
        {
          v210 = (bssl *)bssl::ssl_protocol_version((bssl *)v9, a2);
          if (!bssl::SSLTranscript::InitHash(v255, v210, *((const ssl_cipher_st **)this + 192))
            || v204 && !bssl::SSLTranscript::UpdateForHelloRetryRequest((bssl::SSLTranscript *)v255))
          {
            goto LABEL_430;
          }
        }
        v262 = 0;
        if ((bssl::check_ech_confirmation((uint64_t)this, &v262, v263, (uint64_t)v277, v206, v207, v208, v209) & 1) == 0)
          goto LABEL_427;
        v211 = *((_QWORD *)this + 191);
        if (v211)
        {
          if (v262)
            v212 = 1;
          else
            v212 = 2;
          *(_DWORD *)(*((_QWORD *)v9 + 6) + 216) = v212;
        }
        if (v204)
        {
          LODWORD(v266) = 65580;
          v267 = 0;
          v268 = 0;
          *(_DWORD *)&v263[1] = 65587;
          v264 = 0;
          v265 = 0;
          LODWORD(p_key) = 65579;
          v275 = 0;
          v276 = 0;
          if (v211)
            v213 = 1;
          else
            v213 = *(_WORD *)(*((_QWORD *)this + 1) + 237) & 1;
          v259[0] = -499;
          v259[1] = v213;
          v260 = 0;
          v261 = 0;
          *(_QWORD *)&__key = &v266;
          *((_QWORD *)&__key + 1) = &v263[1];
          v286 = (unint64_t **)&p_key;
          v287 = v259;
          if ((bssl::ssl_parse_extensions(&v283, v263, (uint64_t *)&__key, 4, 0) & 1) == 0)
          {
LABEL_427:
            v50 = v263[0];
LABEL_428:
            v51 = (bssl *)v9;
            goto LABEL_429;
          }
          v231 = v263[4];
          if (!BYTE3(v266) && !v263[4])
          {
            v193 = 282;
            v194 = 255;
            goto LABEL_377;
          }
          if (BYTE3(v266))
          {
            v235 = v268 - 2;
            if (v268 < 2
              || (v236 = v267, v237 = v267 + 1, ++v267, v268 -= 2, v238 = __rev16(*v236), v235 < v238)
              || (v267 = (unsigned __int16 *)((char *)v237 + v238), v268 = v235 - v238, !v238)
              || v235 != v238)
            {
              v241 = 264;
LABEL_460:
              ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", v241);
              v51 = (bssl *)v9;
LABEL_187:
              v50 = 50;
              goto LABEL_429;
            }
            OPENSSL_free(*(_QWORD **)v252);
            *(_QWORD *)v252 = 0;
            *((_QWORD *)v252 + 1) = 0;
            v239 = OPENSSL_malloc(v235);
            *(_QWORD *)v252 = v239;
            if (!v239)
              goto LABEL_430;
            *((_QWORD *)this + 66) = v235;
            memmove(v239, v237, v235);
            v231 = v263[4];
          }
          if (v231)
          {
            if (v265 < 2 || (v240 = v264, ++v264, (v265 -= 2) != 0))
            {
              v241 = 278;
              goto LABEL_460;
            }
            v242 = bswap32(*v240);
            v243 = HIWORD(v242);
            if (!bssl::tls1_check_group_id(this, HIWORD(v242)))
            {
              bssl::ssl_send_alert((bssl *)v9, (ssl_st *)2, 47);
              v63 = 243;
              v64 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borin"
                    "gssl/src/ssl/tls13_client.cc";
              v65 = 286;
              goto LABEL_284;
            }
            if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 49) + 16))(*((_QWORD *)this + 49)) == (_DWORD)v243
              || (v244 = *((_QWORD *)this + 50)) != 0
              && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v244 + 16))(v244) == (_DWORD)v243)
            {
              bssl::ssl_send_alert((bssl *)v9, (ssl_st *)2, 47);
              v63 = 243;
              v64 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borin"
                    "gssl/src/ssl/tls13_client.cc";
              v65 = 295;
LABEL_284:
              ERR_put_error(16, 0, v63, v64, v65);
              goto LABEL_430;
            }
            if (!bssl::ssl_setup_key_shares(this, v243))
              goto LABEL_430;
          }
          if (!bssl::ssl_hash_message((uint64_t)this, (uint64_t)&v269)
            || *(_DWORD *)(*((_QWORD *)v9 + 6) + 216) == 1
            && !bssl::SSLTranscript::Update((uint64_t)v255, v272, v273))
          {
            goto LABEL_430;
          }
          if ((*(unsigned int (**)(unsigned __int16 *))(*(_QWORD *)v9 + 40))(v9))
          {
            bssl::ssl_send_alert((bssl *)v9, (ssl_st *)2, 10);
            v63 = 255;
            v64 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borings"
                  "sl/src/ssl/tls13_client.cc";
            v65 = 319;
            goto LABEL_284;
          }
          (*(void (**)(unsigned __int16 *))(*(_QWORD *)v9 + 32))(v9);
          *(_WORD *)(*((_QWORD *)v9 + 6) + 220) |= 0x2000u;
          v8 = 1;
          *((_DWORD *)this + 6) = 1;
          if ((*((_BYTE *)this + 1569) & 4) != 0)
          {
            *(_DWORD *)(*((_QWORD *)v9 + 6) + 256) = 8;
            if (bssl::close_early_data((char ***)this))
              v8 = 13;
            else
              v8 = 0;
          }
        }
        else
        {
          v73 = 2;
LABEL_185:
          *((_DWORD *)this + 6) = v73;
          v8 = 1;
        }
        goto LABEL_431;
      case 1:
        if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 216) == 1
          && !bssl::ssl_encrypt_client_hello((int8x16_t *)this, 0, 0)
          || !bssl::ssl_add_client_hello(this, (bssl::SSL_HANDSHAKE *)a2))
        {
          goto LABEL_430;
        }
        bssl::ssl_done_writing_client_hello(this);
        *((_DWORD *)this + 6) = 2;
        goto LABEL_19;
      case 2:
        v9 = *(unsigned __int16 **)this;
        if (!(*(unsigned int (**)(_QWORD, __int128 *))(**(_QWORD **)this + 24))(*(_QWORD *)this, &__key))
          goto LABEL_106;
        LOWORD(v278) = 0;
        v281 = 0;
        v282 = 0;
        LOBYTE(v259[0]) = 50;
        if ((bssl::ssl_parse_server_hello((uint64_t)v277, v259, (uint64_t)&__key) & 1) == 0)
          goto LABEL_279;
        if ((unsigned __int16)v278 != 771)
          goto LABEL_308;
        if (v282)
          goto LABEL_308;
        v17 = *((unsigned __int8 *)this + 1613);
        if (v280 != v17)
          goto LABEL_308;
        if (!*((_BYTE *)this + 1613))
        {
          if (!v284)
            goto LABEL_308;
          goto LABEL_242;
        }
        if (v17 < 8)
        {
          v18 = 0;
          v19 = 0;
LABEL_301:
          v157 = v17 - v18;
          v158 = &v3->i8[v18];
          v159 = (char *)(*((_QWORD *)&v279 + 1) + v18);
          do
          {
            v161 = *v159++;
            v160 = v161;
            v162 = *v158++;
            v19 |= v162 ^ v160;
            --v157;
          }
          while (v157);
          goto LABEL_303;
        }
        if (v17 >= 0x20)
        {
          v18 = v17 & 0xE0;
          v144 = veorq_s8(*v3, **((int8x16_t **)&v279 + 1));
          v145 = veorq_s8(v3[1], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 16));
          if (v18 != 32)
          {
            v144 = vorrq_s8(veorq_s8(v3[2], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 32)), v144);
            v145 = vorrq_s8(veorq_s8(v3[3], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 48)), v145);
            if (v18 != 64)
            {
              v144 = vorrq_s8(veorq_s8(v3[4], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 64)), v144);
              v145 = vorrq_s8(veorq_s8(v3[5], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 80)), v145);
              if (v18 != 96)
              {
                v144 = vorrq_s8(veorq_s8(v3[6], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 96)), v144);
                v145 = vorrq_s8(veorq_s8(v3[7], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 112)), v145);
                if (v18 != 128)
                {
                  v144 = vorrq_s8(veorq_s8(v3[8], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 128)), v144);
                  v145 = vorrq_s8(veorq_s8(v3[9], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 144)), v145);
                  if (v18 != 160)
                  {
                    v144 = vorrq_s8(veorq_s8(v3[10], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 160)), v144);
                    v145 = vorrq_s8(veorq_s8(v3[11], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 176)), v145);
                    if (v18 != 192)
                    {
                      v144 = vorrq_s8(veorq_s8(v3[12], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 192)), v144);
                      v145 = vorrq_s8(veorq_s8(v3[13], *(int8x16_t *)(*((_QWORD *)&v279 + 1) + 208)), v145);
                    }
                  }
                }
              }
            }
          }
          v146 = vorrq_s8(v145, v144);
          *(int8x8_t *)v146.i8 = vorr_s8(*(int8x8_t *)v146.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v146, v146, 8uLL));
          v147 = v146.i64[0] | HIDWORD(v146.i64[0]) | ((unint64_t)(v146.i64[0] | HIDWORD(v146.i64[0])) >> 16);
          v19 = v147 | BYTE1(v147);
          if (v18 == v17)
            goto LABEL_303;
          if ((v17 & 0x18) == 0)
            goto LABEL_301;
        }
        else
        {
          v19 = 0;
          v18 = 0;
        }
        v148 = v18;
        v18 = v17 & 0xF8;
        v149 = (int8x8_t)v19;
        v150 = (int8x8_t *)(*((_QWORD *)&v279 + 1) + v148);
        v151 = (int8x8_t *)&v3->i8[v148];
        v152 = v148 - v18;
        do
        {
          v153 = *v150++;
          v154 = v153;
          v155 = *v151++;
          v149 = vorr_s8(veor_s8(v155, v154), v149);
          v152 += 8;
        }
        while (v152);
        v156 = *(_QWORD *)&v149 | HIDWORD(*(_QWORD *)&v149) | ((*(_QWORD *)&v149 | HIDWORD(*(_QWORD *)&v149)) >> 16);
        v19 = v156 | BYTE1(v156);
        if (v18 != v17)
          goto LABEL_301;
LABEL_303:
        if (v19)
          v163 = 1;
        else
          v163 = v284 == 0;
        if (v163)
        {
LABEL_308:
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", 116);
          v50 = 50;
          LOBYTE(v259[0]) = 50;
          goto LABEL_428;
        }
LABEL_242:
        if ((_QWORD)v279 == 32)
        {
          v125 = **((_QWORD **)&v278 + 1) == 0x11619AE574AD21CFLL
              && *(_QWORD *)(*((_QWORD *)&v278 + 1) + 8) == 0x91B8651E028C1DBELL;
          v126 = v125 && *(_QWORD *)(*((_QWORD *)&v278 + 1) + 16) == 0x5E8CBB7A1611A2C2;
          if (v126 && *(_QWORD *)(*((_QWORD *)&v278 + 1) + 24) == 0x9C33A8C8E2099E07)
          {
            bssl::ssl_send_alert((bssl *)v9, (ssl_st *)2, 10);
            ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", 373);
            goto LABEL_430;
          }
        }
        if (v281 != *(unsigned __int16 *)(*((_QWORD *)this + 192) + 16))
        {
          ERR_put_error(16, 0, 242, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", 379);
          v51 = (bssl *)v9;
          v50 = 47;
          goto LABEL_429;
        }
        v128 = *((_QWORD *)v9 + 6);
        if (*(_DWORD *)(v128 + 216) != 1)
          goto LABEL_261;
        if ((*(_WORD *)(v128 + 220) & 0x2000) != 0)
        {
          LOBYTE(v269) = 0;
          if ((bssl::check_ech_confirmation((uint64_t)this, (BOOL *)&v269, (char *)v259, (uint64_t)v277, v13, v14, v15, v16) & 1) == 0)goto LABEL_279;
          if (!(_BYTE)v269)
          {
            ERR_put_error(16, 0, 321, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", 393);
            v50 = 47;
            goto LABEL_428;
          }
        }
        v129 = *v255;
        *v255 = 0;
        v130 = *v257;
        *v257 = v129;
        if (v130)
          ASN1_STRING_free((BUF_MEM *)v130);
        EVP_MD_CTX_move((uint64_t)v258, v254);
        *((_DWORD *)this + 94) = *((_DWORD *)this + 95);
        v131 = *((_QWORD *)v9 + 6);
        v132 = v253[1];
        *(_OWORD *)(v131 + 48) = *v253;
        *(_OWORD *)(v131 + 64) = v132;
        v128 = *((_QWORD *)v9 + 6);
LABEL_261:
        v133 = *(_OWORD *)(*((_QWORD *)&v278 + 1) + 16);
        *(_OWORD *)(v128 + 16) = **((_OWORD **)&v278 + 1);
        *(_OWORD *)(v128 + 32) = v133;
        v134 = *((_QWORD *)v9 + 11);
        if (v134)
          LOBYTE(v134) = *(_DWORD *)(*((_QWORD *)v9 + 6) + 216) != 2;
        LODWORD(v269) = 65587;
        v270 = 0;
        v271 = 0;
        LOWORD(v266) = 41;
        WORD1(v266) = v134;
        v267 = 0;
        v268 = 0;
        *(_DWORD *)&v263[1] = 65579;
        v264 = 0;
        v265 = 0;
        p_key = (unsigned __int8 *)&v269;
        v275 = (uint64_t *)&v266;
        v276 = &v263[1];
        if ((bssl::ssl_parse_extensions(&v283, v259, (uint64_t *)&p_key, 3, 0) & 1) == 0)
        {
LABEL_279:
          v50 = LOBYTE(v259[0]);
          goto LABEL_428;
        }
        if (!v263[4] || v265 < 2 || (v136 = v264, ++v264, (v265 -= 2) != 0) || v9[8] != bswap32(*v136) >> 16)
        {
          v193 = 288;
          v194 = 428;
          goto LABEL_377;
        }
        LOBYTE(v259[0]) = 50;
        if (BYTE3(v266))
        {
          if ((bssl::ssl_ext_pre_shared_key_parse_serverhello((uint64_t)this, v259, &v267) & 1) == 0)
            goto LABEL_279;
          v137 = *((_QWORD *)v9 + 11);
          if (*(unsigned __int16 *)(v137 + 4) != v9[8])
          {
            v193 = 188;
            v194 = 442;
            goto LABEL_377;
          }
          if (*(_DWORD *)(*(_QWORD *)(v137 + 200) + 36) != *(_DWORD *)(*((_QWORD *)this + 192) + 36))
          {
            v193 = 268;
            v194 = 448;
            goto LABEL_377;
          }
          if (!bssl::ssl_session_is_context_valid((uint64_t)this, v137))
          {
            v193 = 101;
            v194 = 456;
            goto LABEL_377;
          }
          *(_WORD *)(*((_QWORD *)v9 + 6) + 220) |= 0x40u;
          *((_DWORD *)this + 392) |= 0x400000u;
          bssl::SSL_SESSION_dup(*((bssl **)v9 + 11), 0, (ssl_session_st **)&p_key);
          v139 = (unint64_t *)p_key;
          p_key = 0;
          v140 = (SSL_SESSION *)*((_QWORD *)this + 188);
          *((_QWORD *)this + 188) = v139;
          if (v140)
          {
            SSL_SESSION_free(v140);
            v141 = (SSL_SESSION *)p_key;
            p_key = 0;
            if (v141)
              SSL_SESSION_free(v141);
            v139 = (unint64_t *)*((_QWORD *)this + 188);
          }
          if (!v139)
          {
LABEL_418:
            v51 = (bssl *)v9;
            goto LABEL_421;
          }
          bssl::ssl_set_session((bssl *)v9, 0, v138);
          bssl::ssl_session_renew_timeout((bssl *)v9, *((ssl_st **)this + 188), (ssl_session_st *)*(unsigned int *)(*((_QWORD *)v9 + 14) + 300));
        }
        else if ((bssl::ssl_get_new_session(this, v135) & 1) == 0)
        {
          goto LABEL_418;
        }
        v223 = *((_QWORD *)this + 192);
        *(_QWORD *)(*((_QWORD *)this + 188) + 200) = v223;
        v224 = (bssl *)bssl::ssl_protocol_version((bssl *)v9, v142);
        handshake_digest = bssl::ssl_get_handshake_digest(v224, v223, v225);
        if ((*(_WORD *)(*((_QWORD *)v9 + 6) + 220) & 0x40) != 0)
        {
          v233 = *((_QWORD *)this + 188);
          v228 = (const unsigned __int8 *)(v233 + 11);
          v227 = *(unsigned __int8 *)(v233 + 10);
        }
        else
        {
          v227 = *((unsigned int *)handshake_digest + 1);
          v228 = bssl::kZeroes;
        }
        if (!bssl::tls13_init_key_schedule((uint64_t)this, v228, v227))
          goto LABEL_430;
        if (!BYTE3(v269))
        {
          ERR_put_error(16, 0, 258, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", 495);
          v51 = (bssl *)v9;
          v50 = 109;
          goto LABEL_429;
        }
        p_key = 0;
        v275 = 0;
        LOBYTE(v259[0]) = 50;
        if ((bssl::ssl_ext_key_share_parse_serverhello(this, (uint64_t)&p_key, (char *)v259, &v270) & 1) == 0)
        {
          bssl::ssl_send_alert((bssl *)v9, (ssl_st *)2, LOBYTE(v259[0]));
LABEL_464:
          v8 = 0;
          goto LABEL_465;
        }
        if (!bssl::tls13_advance_key_schedule((uint64_t)this, p_key, (size_t)v275)
          || !bssl::ssl_hash_message((uint64_t)this, (uint64_t)&__key)
          || !bssl::tls13_derive_handshake_secrets(this, v234)
          || ((*((_BYTE *)this + 1569) & 4) == 0 || *((_QWORD *)v9 + 19))
          && !bssl::tls13_set_traffic_key((uint64_t)v9, 2, 1u, *((_QWORD *)this + 188), v6, *((_QWORD *)this + 4)))
        {
          goto LABEL_464;
        }
        v8 = 0;
        if (bssl::tls13_set_traffic_key((uint64_t)v9, 2, 0, *((_QWORD *)this + 188), v251, *((_QWORD *)this + 4)))
        {
          (*(void (**)(unsigned __int16 *))(*(_QWORD *)v9 + 32))(v9);
          *((_DWORD *)this + 6) = 3;
          v8 = 1;
        }
LABEL_465:
        OPENSSL_free(p_key);
        goto LABEL_431;
      case 3:
        v20 = *(bssl **)this;
        if (!(*(unsigned int (**)(_QWORD, unsigned __int8 *))(**(_QWORD **)this + 24))(*(_QWORD *)this, v277))goto LABEL_106;
        if (v277[1] != 8)
          goto LABEL_232;
        v21 = v278 - 2;
        if ((unint64_t)v278 < 2
          || (v22 = __rev16((unsigned __int16)**(_WORD **)&v277[8]), v21 < v22)
          || (*(_QWORD *)&__key = *(_QWORD *)&v277[8] + 2, *((_QWORD *)&__key + 1) = v22, v21 != v22))
        {
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", 551);
          v51 = v20;
          goto LABEL_187;
        }
        if ((bssl::ssl_parse_serverhello_tlsext((uint64_t)this, &__key) & 1) == 0)
        {
          v63 = 190;
          v64 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl"
                "/src/ssl/tls13_client.cc";
          v65 = 557;
          goto LABEL_284;
        }
        v23 = *((_QWORD *)v20 + 6);
        v246 = v3;
        if ((*(_WORD *)(v23 + 220) & 0x400) == 0)
        {
          v24 = *((_QWORD *)this + 188);
          v25 = *(_QWORD *)(v23 + 496);
          __src = *(void **)(v23 + 488);
          v26 = *(_QWORD *)(v24 + 376);
          if (!v26)
          {
LABEL_39:
            *(_QWORD *)(v24 + 376) = 0;
            *(_QWORD *)(v24 + 384) = 0;
            if (!v25)
              goto LABEL_43;
            if (v25 <= 0xFFFFFFFFFFFFFFF7)
            {
              v30 = malloc_type_malloc(v25 + 8, 0x30772F57uLL);
              if (v30)
              {
                *v30 = v25;
                v31 = v30 + 1;
                *(_QWORD *)(v24 + 376) = v31;
                *(_QWORD *)(v24 + 384) = v25;
                memmove(v31, __src, v25);
LABEL_43:
                v3 = v246;
                if (!v277[0])
                {
                  v32 = *((_QWORD *)&v278 + 1);
                  v33 = v279;
                  if (*v257 && !BUF_MEM_append((unint64_t *)*v257, *((void **)&v278 + 1), v279))
                    goto LABEL_430;
                  if (*(_QWORD *)v258)
                    (*(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)v258 + 24))(v258, v32, v33);
                }
                (*(void (**)(bssl *))(*(_QWORD *)v20 + 32))(v20);
                *((_DWORD *)this + 6) = 4;
                v34 = *((_DWORD *)this + 392);
                if ((v34 & 0x400) == 0 || (*(_WORD *)(*((_QWORD *)v20 + 6) + 220) & 0x400) != 0)
                {
                  v8 = 1;
                  goto LABEL_431;
                }
                v35 = *(_QWORD *)this;
                *((_DWORD *)this + 392) = v34 & 0xFFFFDFFF;
                if (*(_QWORD *)(v35 + 152)
                  || bssl::tls13_set_traffic_key(v35, 2, 1u, *((_QWORD *)this + 188), v6, *((_QWORD *)this + 4)))
                {
                  v8 = 13;
                  goto LABEL_431;
                }
                goto LABEL_430;
              }
            }
            ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
            *(_QWORD *)(v24 + 376) = 0;
LABEL_346:
            v196 = v20;
            v197 = 80;
LABEL_352:
            bssl::ssl_send_alert(v196, (ssl_st *)2, v197);
            v8 = 0;
            v3 = v246;
            goto LABEL_431;
          }
LABEL_36:
          v28 = *(_QWORD *)(v26 - 8);
          v27 = (void *)(v26 - 8);
          v29 = v28 + 8;
          if (v28 != -8)
            bzero(v27, v29);
          free(v27);
          goto LABEL_39;
        }
        v164 = *((_QWORD *)this + 189);
        v165 = *((_QWORD *)this + 188);
        if (*(_QWORD *)(v164 + 200) == *(_QWORD *)(v165 + 200))
        {
          v198 = *(_QWORD *)(v164 + 384);
          if (v198 == *(_QWORD *)(v23 + 496)
            && !memcmp(*(const void **)(v164 + 376), *(const void **)(v23 + 488), v198))
          {
            if ((*((_BYTE *)this + 1570) & 0x80) == 0 && (*(_BYTE *)(v165 + 424) & 0x40) == 0)
            {
              *(_BYTE *)(v165 + 424) = *(_BYTE *)(v164 + 424) & 0x40 | *(_BYTE *)(v165 + 424) & 0xBF;
              v214 = *((_QWORD *)this + 188);
              v215 = *((_QWORD *)this + 189);
              v216 = *(_QWORD *)(v215 + 400);
              __srcb = *(void **)(v215 + 392);
              OPENSSL_free(*(_QWORD **)(v214 + 392));
              *(_QWORD *)(v214 + 392) = 0;
              *(_QWORD *)(v214 + 400) = 0;
              if (v216)
              {
                v217 = OPENSSL_malloc(v216);
                *(_QWORD *)(v214 + 392) = v217;
                if (!v217)
                  goto LABEL_346;
                *(_QWORD *)(v214 + 400) = v216;
                memmove(v217, __srcb, v216);
              }
              v218 = *((_QWORD *)this + 188);
              v219 = *((_QWORD *)this + 189);
              v220 = *(_QWORD *)(v219 + 416);
              __srcc = *(void **)(v219 + 408);
              OPENSSL_free(*(_QWORD **)(v218 + 408));
              *(_QWORD *)(v218 + 408) = 0;
              *(_QWORD *)(v218 + 416) = 0;
              if (v220)
              {
                v221 = OPENSSL_malloc(v220);
                *(_QWORD *)(v218 + 408) = v221;
                if (!v221)
                  goto LABEL_346;
                *(_QWORD *)(v218 + 416) = v220;
                memmove(v221, __srcc, v220);
              }
              v222 = *((_QWORD *)v20 + 6);
              v24 = *((_QWORD *)this + 188);
              v25 = *(_QWORD *)(v222 + 496);
              __src = *(void **)(v222 + 488);
              v26 = *(_QWORD *)(v24 + 376);
              if (!v26)
                goto LABEL_39;
              goto LABEL_36;
            }
            v166 = 279;
            v167 = 584;
          }
          else
          {
            v166 = 277;
            v167 = 576;
          }
        }
        else
        {
          v166 = 304;
          v167 = 570;
        }
        ERR_put_error(16, 0, v166, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", v167);
        v196 = v20;
        v197 = 47;
        goto LABEL_352;
      case 4:
        v36 = *(bssl **)this;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x40) != 0)
        {
          if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x400) == 0
            && *(_BYTE *)(*((_QWORD *)v36 + 13) + 488))
          {
            v56 = 7;
            goto LABEL_416;
          }
          v73 = 8;
          goto LABEL_185;
        }
        if (!(*(unsigned int (**)(_QWORD, unsigned __int8 *))(*(_QWORD *)v36 + 24))(*(_QWORD *)this, v277))
        {
LABEL_106:
          v8 = 3;
          goto LABEL_431;
        }
        if (v277[1] != 13)
          goto LABEL_415;
        LODWORD(__key) = 65549;
        *((_QWORD *)&__key + 1) = 0;
        v286 = 0;
        LODWORD(v269) = 65583;
        v270 = 0;
        v271 = 0;
        LOBYTE(v259[0]) = 50;
        if (!(_QWORD)v278)
          goto LABEL_231;
        v37 = **(_BYTE **)&v277[8];
        v38 = v278 - 1 - v37;
        if ((uint64_t)v278 - 1 < v37)
          goto LABEL_231;
        if (**(_BYTE **)&v277[8])
          goto LABEL_231;
        v39 = v38 >= 2;
        v40 = (unsigned __int16 *)(v38 - 2);
        if (!v39)
          goto LABEL_231;
        v41 = (unsigned __int16 *)(*(_QWORD *)&v277[8] + v37 + 1);
        v42 = (unsigned __int16 *)__rev16(*v41);
        if (v40 < v42)
          goto LABEL_231;
        v266 = v41 + 1;
        v267 = v42;
        if (v40 != v42)
          goto LABEL_231;
        p_key = (unsigned __int8 *)&__key;
        v275 = &v269;
        if (!bssl::ssl_parse_extensions(&v266, v259, (uint64_t *)&p_key, 2, 1))
          goto LABEL_231;
        if (!BYTE3(__key))
          goto LABEL_231;
        v43 = (char *)v286 - 2;
        if ((unint64_t)v286 < 2)
          goto LABEL_231;
        v44 = (unsigned __int16 *)*((_QWORD *)&__key + 1);
        v45 = *((_QWORD *)&__key + 1) + 2;
        *((_QWORD *)&__key + 1) += 2;
        v286 = (unint64_t **)((char *)v286 - 2);
        v46 = __rev16(*v44);
        v39 = (unint64_t)v43 >= v46;
        v47 = (unint64_t **)&v43[-v46];
        if (!v39
          || (*((_QWORD *)&__key + 1) = v45 + v46,
              v286 = v47,
              *(_QWORD *)&v263[1] = v45,
              v264 = (unsigned __int16 *)v46,
              (bssl::tls1_parse_peer_sigalgs((unint64_t *)this, (uint64_t)&v263[1]) & 1) == 0))
        {
LABEL_231:
          bssl::ssl_send_alert(v36, (ssl_st *)2, LOBYTE(v259[0]));
          v63 = 137;
          v64 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl"
                "/src/ssl/tls13_client.cc";
          v65 = 660;
          goto LABEL_284;
        }
        if (BYTE3(v269))
        {
          bssl::ssl_parse_client_CA_list((uint64_t)v36, v259, &v270, (unint64_t **)&p_key);
          v48 = (unint64_t *)p_key;
          v49 = (unint64_t *)*((_QWORD *)this + 182);
          *((_QWORD *)this + 182) = p_key;
          if (v49)
          {
            OPENSSL_sk_pop_free_ex(v49, (void (*)(uint64_t))bssl::internal::DeleterImpl<stack_st_CRYPTO_BUFFER,void>::Free(stack_st_CRYPTO_BUFFER*)::{lambda(void (*)(void *),void *)#1}::__invoke, 0);
            v48 = (unint64_t *)*((_QWORD *)this + 182);
          }
          if (!v48)
          {
            v50 = LOBYTE(v259[0]);
            v51 = v36;
            goto LABEL_429;
          }
LABEL_413:
          *((_DWORD *)this + 392) |= 0x20u;
          (*(void (**)(bssl *))(*(_QWORD *)(*((_QWORD *)v36 + 13) + 16) + 80))(this);
          if (!bssl::ssl_hash_message((uint64_t)this, (uint64_t)v277))
            goto LABEL_430;
          (*(void (**)(bssl *))(*(_QWORD *)v36 + 32))(v36);
LABEL_415:
          v56 = 5;
          goto LABEL_416;
        }
        v229 = OPENSSL_sk_new_null();
        v230 = (unint64_t *)*((_QWORD *)this + 182);
        *((_QWORD *)this + 182) = v229;
        if (v230)
        {
          OPENSSL_sk_pop_free_ex(v230, (void (*)(uint64_t))bssl::internal::DeleterImpl<stack_st_CRYPTO_BUFFER,void>::Free(stack_st_CRYPTO_BUFFER*)::{lambda(void (*)(void *),void *)#1}::__invoke, 0);
          v229 = (char *)*((_QWORD *)this + 182);
        }
        if (v229)
          goto LABEL_413;
        v51 = v36;
LABEL_421:
        v50 = 80;
        goto LABEL_429;
      case 5:
        v52 = *(bssl **)this;
        if (!(*(unsigned int (**)(_QWORD, unsigned __int8 *))(**(_QWORD **)this + 24))(*(_QWORD *)this, v277))goto LABEL_106;
        if (v277[1] != 11 && v277[1] != 25)
          goto LABEL_79;
        v8 = 0;
        if (!bssl::tls13_process_certificate((uint64_t)this, (uint64_t)v277, 0))
          goto LABEL_431;
        if (v277[0])
          goto LABEL_86;
        v54 = *((_QWORD *)&v278 + 1);
        v55 = v279;
        if (*v257 && !BUF_MEM_append((unint64_t *)*v257, *((void **)&v278 + 1), v279))
          goto LABEL_430;
        if (*(_QWORD *)v258)
          (*(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)v258 + 24))(v258, v54, v55);
LABEL_86:
        (*(void (**)(bssl *))(*(_QWORD *)v52 + 32))(v52);
        v56 = 6;
        goto LABEL_416;
      case 6:
        v20 = *(bssl **)this;
        if (!(*(unsigned int (**)(_QWORD, unsigned __int8 *))(**(_QWORD **)this + 24))(*(_QWORD *)this, v277))goto LABEL_106;
        v57 = bssl::ssl_verify_peer_cert(this, (bssl::SSL_HANDSHAKE *)a2);
        if (v57 == 1)
          goto LABEL_430;
        if (v57 == 2)
        {
          v8 = 16;
          *((_DWORD *)this + 6) = 6;
          goto LABEL_431;
        }
        if (v277[1] == 15)
        {
          if (!bssl::tls13_process_certificate_verify((uint64_t)this, (uint64_t)v277))
            goto LABEL_430;
          if (v277[0])
            goto LABEL_230;
          v122 = *((_QWORD *)&v278 + 1);
          v123 = v279;
          if (!*v257 || BUF_MEM_append((unint64_t *)*v257, *((void **)&v278 + 1), v279))
          {
            if (*(_QWORD *)v258)
              (*(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)v258 + 24))(v258, v122, v123);
LABEL_230:
            (*(void (**)(bssl *))(*(_QWORD *)v20 + 32))(v20);
            v8 = 1;
            *((_DWORD *)this + 6) = 8;
            goto LABEL_431;
          }
        }
        else
        {
LABEL_232:
          bssl::ssl_send_alert(v20, (ssl_st *)2, 10);
          ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/handshake.cc", 211);
          v121 = v277[1];
LABEL_233:
          ERR_add_error_dataf("got type %d, wanted type %d", v114, v115, v116, v117, v118, v119, v120, v121);
        }
        goto LABEL_430;
      case 7:
        v277[0] = 46;
        v58 = *(bssl **)this;
        v59 = *(uint64_t (**)(_QWORD, unsigned __int8 *))(*((_QWORD *)this + 1) + 48);
        if (!v59 || (v60 = v59(*(_QWORD *)this, v277), v60 == 1))
        {
          ERR_put_error(16, 0, 125, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/handshake.cc", 435);
          v50 = v277[0];
          v51 = v58;
          goto LABEL_429;
        }
        if (v60 == 2)
          v85 = 7;
        else
          v85 = 8;
        if (v60 == 2)
          v8 = 16;
        else
          v8 = 1;
        *((_DWORD *)this + 6) = v85;
        goto LABEL_431;
      case 8:
        v52 = *(bssl **)this;
        if (!(*(unsigned int (**)(_QWORD, unsigned __int8 *))(**(_QWORD **)this + 24))(*(_QWORD *)this, v277))goto LABEL_106;
        if (v277[1] != 20)
        {
LABEL_79:
          bssl::ssl_send_alert(v52, (ssl_st *)2, 10);
          ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/handshake.cc", 211);
          v121 = v277[1];
          goto LABEL_233;
        }
        v8 = 0;
        if (!bssl::tls13_process_finished((uint64_t)this, (uint64_t)v277, 0))
          goto LABEL_431;
        if (v277[0])
          goto LABEL_102;
        v61 = *((_QWORD *)&v278 + 1);
        v62 = v279;
        if (*v257 && !BUF_MEM_append((unint64_t *)*v257, *((void **)&v278 + 1), v279))
          goto LABEL_430;
        if (*(_QWORD *)v258)
          (*(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)v258 + 24))(v258, v61, v62);
LABEL_102:
        if (!bssl::tls13_advance_key_schedule((uint64_t)this, bssl::kZeroes, *(unsigned int *)(*((_QWORD *)this + 52) + 4))|| !bssl::tls13_derive_application_secrets(this, (bssl::SSL_HANDSHAKE *)a2))
        {
          goto LABEL_430;
        }
        if ((*(unsigned int (**)(bssl *))(*(_QWORD *)v52 + 40))(v52))
        {
          bssl::ssl_send_alert(v52, (ssl_st *)2, 10);
          v63 = 255;
          v64 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl"
                "/src/ssl/tls13_client.cc";
          v65 = 772;
          goto LABEL_284;
        }
        (*(void (**)(bssl *))(*(_QWORD *)v52 + 32))(v52);
        v56 = 9;
LABEL_416:
        *((_DWORD *)this + 6) = v56;
        v8 = 1;
        goto LABEL_431;
      case 9:
        v66 = *(_QWORD **)this;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x400) == 0)
          goto LABEL_197;
        if (v66[19])
        {
          *((_DWORD *)this + 392) &= ~0x2000u;
          if (!v66[19])
          {
LABEL_110:
            if (!bssl::tls13_set_traffic_key((uint64_t)v66, 2, 1u, *((_QWORD *)this + 188), v6, *((_QWORD *)this + 4)))goto LABEL_430;
          }
        }
        else
        {
          v278 = 0u;
          v279 = 0u;
          *(_OWORD *)v277 = 0u;
          if (!(*(unsigned int (**)(_QWORD *, unsigned __int8 *, __int128 *, uint64_t))(*v66 + 88))(v66, v277, &__key, 5)|| !bssl::ssl_add_message_cbb((uint64_t)v66, (uint64_t)v277))
          {
LABEL_198:
            if (!v277[8] && (BYTE8(v279) & 1) != 0 && (_QWORD)v278)
            {
              v104 = *(_QWORD *)(v278 - 8);
              v103 = (void *)(v278 - 8);
              v105 = v104 + 8;
              if (v104 != -8)
                bzero(v103, v105);
              free(v103);
            }
            goto LABEL_430;
          }
          if (!v277[8] && (BYTE8(v279) & 1) != 0 && (_QWORD)v278)
          {
            v101 = *(_QWORD *)(v278 - 8);
            v100 = (void *)(v278 - 8);
            v102 = v101 + 8;
            if (v101 != -8)
              bzero(v100, v102);
            free(v100);
          }
          v66 = *(_QWORD **)this;
          *((_DWORD *)this + 392) &= ~0x2000u;
          if (!v66[19])
            goto LABEL_110;
        }
LABEL_197:
        *((_DWORD *)this + 6) = 10;
        goto LABEL_431;
      case 10:
        if ((*(_BYTE *)(*((_QWORD *)this + 188) + 424) & 0x40) == 0)
          goto LABEL_128;
        v67 = *(_QWORD *)this;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x400) != 0)
          goto LABEL_128;
        v278 = 0u;
        v279 = 0u;
        *(_OWORD *)v277 = 0u;
        v68 = *(_WORD *)(*((_QWORD *)this + 1) + 237);
        if (!(*(unsigned int (**)(uint64_t, unsigned __int8 *, __int128 *, uint64_t))(*(_QWORD *)v67 + 88))(v67, v277, &__key, 8))goto LABEL_198;
        if (!CBB_flush((uint64_t *)&__key))
          goto LABEL_198;
        if (!cbb_add_child((uint64_t)&__key, (uint64_t)&v269, 2u, 0))
          goto LABEL_198;
        *(_QWORD *)&v263[1] = 0;
        if (!CBB_add_space((uint64_t)&v269, &v263[1], 2))
          goto LABEL_198;
        v69 = (v68 & 0x2000) != 0 ? -51 : 105;
        *(_BYTE *)(*(_QWORD *)&v263[1] + 1) = v69;
        **(_BYTE **)&v263[1] = 68;
        if (!CBB_flush(&v269))
          goto LABEL_198;
        if (!cbb_add_child((uint64_t)&v269, (uint64_t)&v266, 2u, 0))
          goto LABEL_198;
        v70 = *((_QWORD *)this + 188);
        v71 = *(const void **)(v70 + 392);
        v72 = *(_QWORD *)(v70 + 400);
        *(_QWORD *)&v263[1] = 0;
        if (!CBB_add_space((uint64_t)&v266, &v263[1], v72))
          goto LABEL_198;
        if (v72)
          memcpy(*(void **)&v263[1], v71, v72);
        if (!bssl::ssl_add_message_cbb(v67, (uint64_t)v277))
          goto LABEL_198;
        CBB_cleanup((uint64_t)v277);
LABEL_128:
        v73 = 11;
        goto LABEL_185;
      case 11:
        if ((*((_BYTE *)this + 1568) & 0x20) == 0)
          goto LABEL_136;
        v74 = *(bssl **)this;
        if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 216) == 2)
        {
          SSL_certs_clear(*(_QWORD *)this);
        }
        else
        {
          v86 = *(_QWORD *)(*((_QWORD *)this + 1) + 32);
          v87 = *(uint64_t (**)(_QWORD, _QWORD))(v86 + 64);
          if (v87)
          {
            v88 = v87(*(_QWORD *)this, *(_QWORD *)(v86 + 72));
            if (!v88)
            {
              bssl::ssl_send_alert(v74, (ssl_st *)2, 80);
              v63 = 126;
              v64 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/borin"
                    "gssl/src/ssl/tls13_client.cc";
              v65 = 864;
              goto LABEL_284;
            }
            if (v88 < 0)
            {
              *((_DWORD *)this + 6) = 11;
              v8 = 8;
              goto LABEL_431;
            }
          }
        }
        memset(v277, 0, sizeof(v277));
        if (!bssl::ssl_get_credential_list((uint64_t)this, (uint64_t *)v277))
          goto LABEL_219;
        if (!*(_QWORD *)&v277[8])
          goto LABEL_216;
        __srca = v6;
        v89 = v5;
        v90 = v4;
        v91 = v3;
        v92 = *(unsigned int ***)v277;
        v93 = 8 * *(_QWORD *)&v277[8];
        while (2)
        {
          v94 = *v92;
          ERR_clear_error();
          LOWORD(__key) = 0;
          if (v94[1])
          {
            ERR_put_error(16, 0, 228, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", 838);
LABEL_171:
            ++v92;
            v93 -= 8;
            if (!v93)
              goto LABEL_215;
            continue;
          }
          break;
        }
        if (!bssl::tls1_choose_signature_algorithm((bssl **)this, (uint64_t)v94, (__int16 *)&__key))
          goto LABEL_171;
        v95 = atomic_load(v94);
        if (v95 != -1)
        {
          while (1)
          {
            v96 = __ldaxr(v94);
            if (v96 == v95)
            {
              if (!__stlxr(v95 + 1, v94))
              {
                v97 = 1;
                goto LABEL_180;
              }
            }
            else
            {
              __clrex();
            }
            v97 = 0;
LABEL_180:
            if ((v97 & 1) == 0)
            {
              v95 = v96;
              if (v96 != -1)
                continue;
            }
            break;
          }
        }
        v98 = (unsigned int *)*((_QWORD *)this + 186);
        *((_QWORD *)this + 186) = v94;
        if (v98)
        {
          for (i = atomic_load(v98); i != -1; i = v106)
          {
            if (!i)
              abort();
            v106 = __ldaxr(v98);
            if (v106 == i)
            {
              if (!__stlxr(i - 1, v98))
              {
                if (i == 1)
                {
                  ssl_credential_st::~ssl_credential_st((ssl_credential_st *)v98);
                  v108 = *((_QWORD *)v98 - 1);
                  v107 = v98 - 2;
                  v109 = v108 + 8;
                  if (v108 != -8)
                    bzero(v107, v109);
                  free(v107);
                }
                break;
              }
            }
            else
            {
              __clrex();
            }
          }
        }
        *((_WORD *)this + 789) = __key;
LABEL_215:
        v3 = v91;
        v4 = v90;
        v5 = v89;
        v6 = __srca;
        if (*((_QWORD *)this + 186))
        {
LABEL_216:
          if (bssl::tls13_add_certificate(this, (bssl::SSL_HANDSHAKE *)a2))
          {
            *((_DWORD *)this + 6) = 12;
            v8 = 1;
            v110 = *(_QWORD *)v277;
            if (!*(_QWORD *)v277)
              goto LABEL_431;
          }
          else
          {
LABEL_219:
            v8 = 0;
            v110 = *(_QWORD *)v277;
            if (!*(_QWORD *)v277)
              goto LABEL_431;
          }
        }
        else
        {
          bssl::ssl_send_alert(v74, (ssl_st *)2, 40);
          v8 = 0;
          v110 = *(_QWORD *)v277;
          if (!*(_QWORD *)v277)
            goto LABEL_431;
        }
        v112 = *(_QWORD *)(v110 - 8);
        v111 = (void *)(v110 - 8);
        v113 = v112 + 8;
        if (v112 != -8)
          bzero(v111, v113);
        free(v111);
LABEL_431:
        if (*((_DWORD *)this + 6) != v7)
        {
          v232 = *(void (**)(void))(*(_QWORD *)this + 96);
          if (v232 || (v232 = *(void (**)(void))(*(_QWORD *)(*(_QWORD *)this + 104) + 384)) != 0)
            v232();
        }
        if ((_DWORD)v8 == 1)
          continue;
        return v8;
      case 12:
        if (*((_QWORD *)this + 186)
          && (v75 = bssl::tls13_add_certificate_verify((bssl **)this, (bssl::SSL_HANDSHAKE *)a2)) != 0)
        {
          if (v75 != 1)
            goto LABEL_430;
          v8 = 9;
          *((_DWORD *)this + 6) = 12;
        }
        else
        {
LABEL_136:
          *((_DWORD *)this + 6) = 13;
        }
        goto LABEL_431;
      case 13:
        v76 = *(_QWORD *)this;
        v77 = *((_DWORD *)this + 392);
        *((_DWORD *)this + 392) = v77 | 0x400000;
        if ((v77 & 0x800000) == 0)
          goto LABEL_138;
        v278 = 0u;
        v279 = 0u;
        *(_OWORD *)v277 = 0u;
        if (!(*(unsigned int (**)(uint64_t, unsigned __int8 *, __int128 *, uint64_t))(*(_QWORD *)v76 + 88))(v76, v277, &__key, 203)|| !bssl::tls1_write_channel_id(this, (uint64_t *)&__key, v80, v81)|| !bssl::ssl_add_message_cbb(v76, (uint64_t)v277))
        {
          goto LABEL_198;
        }
        if (!v277[8] && (BYTE8(v279) & 1) != 0 && (_QWORD)v278)
        {
          v83 = *(_QWORD *)(v278 - 8);
          v82 = (void *)(v278 - 8);
          v84 = v83 + 8;
          if (v83 != -8)
            bzero(v82, v84);
          free(v82);
        }
LABEL_138:
        if (!bssl::tls13_add_finished(this, (bssl::SSL_HANDSHAKE *)a2)
          || !bssl::tls13_set_traffic_key(v76, 3, 1u, *((_QWORD *)this + 188), v4, *((_QWORD *)this + 4)))
        {
          goto LABEL_430;
        }
        v78 = bssl::tls13_set_traffic_key(v76, 3, 0, *((_QWORD *)this + 188), v5, *((_QWORD *)this + 4));
        v8 = 0;
        if (!v78)
          goto LABEL_431;
        v79 = *(unsigned int *)(*(_QWORD *)v258 + 4);
        if (v79 >= 0x31)
        {
          v63 = 68;
          v64 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl"
                "/src/ssl/tls13_enc.cc";
          v65 = 309;
          goto LABEL_284;
        }
        v124 = *((_QWORD *)this + 188);
        *(_BYTE *)(v124 + 10) = v79;
        *(_QWORD *)&__key = 0;
        if (!bssl::SSLTranscript::GetHash((bssl::SSLTranscript *)v257, v277, (unint64_t *)&__key)
          || CRYPTO_tls13_hkdf_expand_label(v124 + 11, v79, *((EVP_MD **)this + 52), v256, *((_QWORD *)this + 4), "res master", 0xAuLL, v277, __key) != 1)
        {
          goto LABEL_430;
        }
        *((_DWORD *)this + 6) = 14;
LABEL_19:
        v8 = 4;
        goto LABEL_431;
      case 14:
        return v8;
      default:
        goto LABEL_430;
    }
  }
}

uint64_t bssl::tls13_process_new_session_ticket(bssl *a1, uint64_t a2)
{
  _BOOL8 v2;
  ssl_session_st *v5;
  uint64_t v6;
  unsigned int (*v7)(bssl *, ssl_session_st *);
  unsigned int i;
  unsigned int v9;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v12;
  ssl_session_st *v13;
  __int128 v14;

  if (*(_DWORD *)(*((_QWORD *)a1 + 6) + 176))
    return 1;
  v14 = *(_OWORD *)(a2 + 8);
  bssl::tls13_create_session_with_ticket(a1, (unsigned __int16 **)&v14, &v13);
  v5 = v13;
  v2 = v13 != 0;
  if (v13)
  {
    v6 = *((_QWORD *)a1 + 14);
    if ((*(_BYTE *)(v6 + 292) & 1) == 0
      || (v7 = *(unsigned int (**)(bssl *, ssl_session_st *))(v6 + 304)) == 0
      || !v7(a1, v13))
    {
      for (i = atomic_load((unsigned int *)v5); i != -1; i = v9)
      {
        if (!i)
          abort();
        v9 = __ldaxr((unsigned int *)v5);
        if (v9 == i)
        {
          if (!__stlxr(i - 1, (unsigned int *)v5))
          {
            if (i != 1)
              return v2;
            ssl_session_st::~ssl_session_st(v5);
            tlsext_tick_lifetime_hint = v5[-1].tlsext_tick_lifetime_hint;
            p_tlsext_tick_lifetime_hint = &v5[-1].tlsext_tick_lifetime_hint;
            v12 = tlsext_tick_lifetime_hint + 8;
            if (tlsext_tick_lifetime_hint != -8)
              bzero(p_tlsext_tick_lifetime_hint, v12);
            free(p_tlsext_tick_lifetime_hint);
            return v2;
          }
        }
        else
        {
          __clrex();
        }
      }
    }
  }
  return v2;
}

void bssl::tls13_create_session_with_ticket(bssl *a1@<X0>, unsigned __int16 **a2@<X1>, ssl_session_st **a3@<X8>)
{
  ssl_session_st *v6;
  void (*v7)(_QWORD, char *);
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int32x2_t time;
  uint64x2_t v16;
  unsigned __int16 *v17;
  unsigned int v18;
  ssl_session_st *v19;
  const void *v20;
  unint64_t v21;
  const ssl_cipher_st *v22;
  unint64_t v23;
  unsigned __int16 *v24;
  size_t v25;
  size_t v26;
  int *p_dummy;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  size_t v31;
  _QWORD *v32;
  void *v33;
  unint64_t v34;
  unint64_t v35;
  unsigned __int16 *v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  unsigned int v40;
  ssl_session_st *v41;
  ssl_session_st *v42;
  unsigned int *v43;
  BOOL v44;
  unsigned int v45;
  int v46;
  ssl_session_st *v47;
  ssl_session_st *v48;
  unsigned int i;
  unsigned int v50;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v53;
  const void *v54;
  char v55[17];
  unint64_t v56;
  unsigned __int16 *v57[2];
  ssl_session_st *v58;
  uint64_t v59[2];

  v59[1] = *MEMORY[0x24BDAC8D0];
  bssl::SSL_SESSION_dup(*(bssl **)(*((_QWORD *)a1 + 6) + 464), (ssl_session_st *)2, &v58);
  v6 = v58;
  if (!v58)
  {
    *a3 = 0;
    return;
  }
  v7 = *(void (**)(_QWORD, char *))(*((_QWORD *)a1 + 13) + 696);
  if (v7)
  {
    v7(0, &v55[1]);
    v8 = *(_QWORD *)&v55[1] & ~(*(uint64_t *)&v55[1] >> 63);
    v9 = *(_QWORD *)&v6->compress_meth;
    v10 = v8 >= v9;
    v11 = v8 - v9;
    if (!v10)
      goto LABEL_4;
  }
  else
  {
    gettimeofday((timeval *)&v55[1], 0);
    v8 = *(_QWORD *)&v55[1] & ~(*(uint64_t *)&v55[1] >> 63);
    v14 = *(_QWORD *)&v6->compress_meth;
    v10 = v8 >= v14;
    v11 = v8 - v14;
    if (!v10)
    {
LABEL_4:
      v6->time = 0;
      *(_QWORD *)&v6->compress_meth = v8;
      v12 = (unint64_t)a2[1];
      v13 = v12 - 4;
      if (v12 < 4)
        goto LABEL_37;
      goto LABEL_10;
    }
  }
  *(_QWORD *)&v6->compress_meth = v8;
  time = (int32x2_t)v6->time;
  v16.i64[0] = time.u32[0];
  v16.i64[1] = time.u32[1];
  v6->time = (uint64_t)vbic_s8((int8x8_t)vsub_s32(time, vdup_n_s32(v11)), (int8x8_t)vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(v11), v16)));
  v12 = (unint64_t)a2[1];
  v13 = v12 - 4;
  if (v12 < 4)
    goto LABEL_37;
LABEL_10:
  v17 = *a2;
  *a2 += 2;
  a2[1] = (unsigned __int16 *)v13;
  if (v13 < 4)
    goto LABEL_37;
  v18 = *(_DWORD *)v17;
  v19 = v58;
  *a2 = v17 + 4;
  a2[1] = (unsigned __int16 *)(v12 - 8);
  *(_DWORD *)&v19[1].session_id[8] = bswap32(*((_DWORD *)v17 + 1));
  if (v12 == 8)
    goto LABEL_37;
  v20 = (char *)v17 + 9;
  v21 = v12 - 9;
  *a2 = (unsigned __int16 *)((char *)v17 + 9);
  a2[1] = (unsigned __int16 *)v21;
  v22 = (const ssl_cipher_st *)*((unsigned __int8 *)v17 + 8);
  v23 = v21 - (_QWORD)v22;
  if (v21 < (unint64_t)v22)
    goto LABEL_37;
  v24 = (unsigned __int16 *)((char *)v22 + (_QWORD)v20);
  *a2 = (unsigned __int16 *)((char *)v22 + (_QWORD)v20);
  a2[1] = (unsigned __int16 *)v23;
  v10 = v23 >= 2;
  v25 = v23 - 2;
  if (!v10)
    goto LABEL_37;
  *a2 = v24 + 1;
  a2[1] = (unsigned __int16 *)v25;
  v26 = __rev16(*v24);
  if (v25 < v26)
    goto LABEL_37;
  v54 = v24 + 1;
  *a2 = (unsigned __int16 *)((char *)v24 + v26 + 2);
  a2[1] = (unsigned __int16 *)(v25 - v26);
  p_dummy = &v19->ex_data.dummy;
  v28 = *(_QWORD *)&v19->ex_data.dummy;
  if (v28)
  {
    v30 = *(_QWORD *)(v28 - 8);
    v29 = (void *)(v28 - 8);
    v31 = v30 + 8;
    if (v30 != -8)
      bzero(v29, v31);
    free(v29);
  }
  *(_QWORD *)p_dummy = 0;
  v19->prev = 0;
  if (v26)
  {
    v32 = malloc_type_malloc(v26 + 8, 0x30772F57uLL);
    if (v32)
    {
      *v32 = v26;
      v33 = v32 + 1;
      *(_QWORD *)&v19->ex_data.dummy = v33;
      v19->prev = (ssl_session_st *)v26;
      memmove(v33, v54, v26);
      goto LABEL_23;
    }
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    *(_QWORD *)p_dummy = 0;
LABEL_37:
    bssl::ssl_send_alert(a1, (ssl_st *)2, 50);
    ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", 1110);
    goto LABEL_38;
  }
LABEL_23:
  v34 = (unint64_t)a2[1];
  v35 = v34 - 2;
  if (v34 < 2)
    goto LABEL_37;
  v36 = *a2;
  v37 = *a2 + 1;
  *a2 = v37;
  a2[1] = (unsigned __int16 *)v35;
  v38 = (unsigned __int16 *)__rev16(*v36);
  v10 = v35 >= (unint64_t)v38;
  v39 = (unsigned __int16 *)(v35 - (_QWORD)v38);
  if (!v10)
    goto LABEL_37;
  *a2 = (unsigned __int16 *)((char *)v38 + (_QWORD)v37);
  a2[1] = v39;
  v57[0] = v37;
  v57[1] = v38;
  if (v39)
    goto LABEL_37;
  v40 = bswap32(v18);
  v41 = v58;
  if (LODWORD(v58->time) > v40)
    LODWORD(v58->time) = v40;
  if (bssl::tls13_derive_session_psk((uint64_t)v41, v20, v22))
  {
    *(_WORD *)&v55[3] = 1;
    *(_QWORD *)&v55[9] = 0;
    v56 = 0;
    strcpy(v55, "2*");
    v59[0] = (uint64_t)&v55[1];
    if ((bssl::ssl_parse_extensions(v57, v55, v59, 1, 1) & 1) != 0)
    {
      v42 = v58;
      if (v55[4])
      {
        if (v56 < 4
          || (v43 = *(unsigned int **)&v55[9],
              v44 = v56 == 4,
              *(_QWORD *)&v55[9] += 4,
              v56 -= 4,
              v45 = bswap32(*v43),
              *(_DWORD *)&v58[1].session_id[12] = v45,
              !v44))
        {
          bssl::ssl_send_alert(a1, (ssl_st *)2, 50);
          v46 = 1136;
LABEL_35:
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", v46);
          v47 = 0;
          goto LABEL_56;
        }
        if (*((_QWORD *)a1 + 19) && v45 != -1)
        {
          bssl::ssl_send_alert(a1, (ssl_st *)2, 47);
          v46 = 1145;
          goto LABEL_35;
        }
      }
      SHA256((const unsigned __int8 *)v54, v26, &v42->master_key[40]);
      v47 = v58;
      v58->master_key[39] = 32;
      v47[1].sid_ctx[28] = v47[1].sid_ctx[28] & 0xF3 | 8;
      v58 = 0;
    }
    else
    {
      bssl::ssl_send_alert(a1, (ssl_st *)2, v55[0]);
      v47 = 0;
    }
LABEL_56:
    *a3 = v47;
    v48 = v58;
    v58 = 0;
    if (!v48)
      return;
    goto LABEL_39;
  }
LABEL_38:
  *a3 = 0;
  v48 = v58;
  v58 = 0;
  if (!v48)
    return;
LABEL_39:
  for (i = atomic_load((unsigned int *)v48); i != -1; i = v50)
  {
    if (!i)
      abort();
    v50 = __ldaxr((unsigned int *)v48);
    if (v50 == i)
    {
      if (!__stlxr(i - 1, (unsigned int *)v48))
      {
        if (i == 1)
        {
          ssl_session_st::~ssl_session_st(v48);
          tlsext_tick_lifetime_hint = v48[-1].tlsext_tick_lifetime_hint;
          p_tlsext_tick_lifetime_hint = &v48[-1].tlsext_tick_lifetime_hint;
          v53 = tlsext_tick_lifetime_hint + 8;
          if (tlsext_tick_lifetime_hint != -8)
            bzero(p_tlsext_tick_lifetime_hint, v53);
          free(p_tlsext_tick_lifetime_hint);
        }
        return;
      }
    }
    else
    {
      __clrex();
    }
  }
}

uint64_t bssl::check_ech_confirmation(uint64_t a1, BOOL *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  BOOL v18;
  int v20;
  uint64_t v21;
  uint64_t result;
  char v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a4 + 32) != 32)
    goto LABEL_12;
  v12 = *(uint64_t **)(a4 + 24);
  v13 = *v12;
  v14 = v12[1];
  v16 = v12[2];
  v15 = v12[3];
  v17 = v13 == 0x11619AE574AD21CFLL && v14 == 0x91B8651E028C1DBELL;
  v18 = v17 && v16 == 0x5E8CBB7A1611A2C2;
  if (v18 && v15 == 0x9C33A8C8E2099E07)
  {
    LODWORD(v25) = 130573;
    v26 = 0;
    v27 = 0;
    v24 = &v25;
    result = bssl::ssl_parse_extensions((unsigned __int16 **)(a4 + 64), a3, (uint64_t *)&v24, 1, 1);
    if (!(_DWORD)result)
      return result;
    if (BYTE3(v25))
    {
      if (v27 != 8)
      {
        ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_client.cc", 144);
        result = 0;
        v23 = 50;
LABEL_19:
        *a3 = v23;
        return result;
      }
      v21 = v26 - *(_QWORD *)a4;
      v20 = 1;
      if (*(_QWORD *)(a1 + 1528))
      {
LABEL_16:
        result = bssl::ssl_ech_accept_confirmation(a1, (uint64_t)&v25, 8, (const unsigned __int8 *)(a1 + 488), 0x20uLL, (bssl::SSLTranscript *)(a1 + 448), v20, a8, *(_QWORD *)a4, *(_QWORD *)(a4 + 8), v21);
        if ((result & 1) != 0)
        {
          *a2 = v25 == *(_QWORD *)(*(_QWORD *)a4 + v21);
          return result;
        }
        v23 = 80;
        goto LABEL_19;
      }
    }
  }
  else
  {
LABEL_12:
    v20 = 0;
    if (***(_BYTE ***)a1)
      v21 = 38;
    else
      v21 = 30;
    if (*(_QWORD *)(a1 + 1528))
      goto LABEL_16;
  }
  *a2 = 0;
  return 1;
}

uint64_t bssl::close_early_data(char ***a1)
{
  char **v1;
  char v3;
  _DWORD *v4;
  _DWORD *v5;
  void *v6;
  uint64_t (*v7)(char **, _QWORD, void **, _QWORD, _QWORD);
  int v8;
  char v9;
  _QWORD *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  void *v16;

  v1 = *a1;
  *((_DWORD *)a1 + 392) &= ~0x2000u;
  if (v1[19])
    return 1;
  v3 = **v1;
  v4 = malloc_type_malloc(0x270uLL, 0x30772F57uLL);
  if (!v4)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v5 = v4;
  *(_QWORD *)v4 = 616;
  v6 = v4 + 2;
  v4[153] = 0;
  bzero(v4 + 2, 0x250uLL);
  *((_BYTE *)v5 + 616) = v3;
  *((_BYTE *)v5 + 617) &= 0xE0u;
  *((_QWORD *)v5 + 75) = 0;
  v5[152] = 0;
  v7 = (uint64_t (*)(char **, _QWORD, void **, _QWORD, _QWORD))*((_QWORD *)*v1 + 18);
  v16 = v6;
  v8 = v7(v1, 0, &v16, 0, 0);
  v9 = v8;
  v10 = v16;
  v16 = 0;
  if (v10)
  {
    v11 = v10[1];
    if (v11)
    {
      (*(void (**)(_QWORD *))(v11 + 24))(v10 + 1);
      v10[1] = 0;
    }
    v13 = *(v10 - 1);
    v12 = (char *)(v10 - 1);
    v14 = v13 + 8;
    if (v13 != -8)
      bzero(v12, v14);
    free(v12);
    if ((v9 & 1) != 0)
      goto LABEL_10;
    return 0;
  }
  if (!v8)
    return 0;
LABEL_10:
  v15 = *((_QWORD *)v1[6] + 34);
  if (*(_QWORD *)v15)
    return 1;
  *(_WORD *)(v15 + 606) = *((_WORD *)v1 + 8);
  return 1;
}

BOOL bssl::tls13_init_key_schedule(uint64_t a1, const unsigned __int8 *a2, size_t a3)
{
  uint64_t *v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  size_t v13;
  void *v14;
  uint64_t v15;
  size_t v16;
  const EVP_MD *v17;
  unsigned __int8 *v18;
  _BOOL8 v19;
  unsigned int md_len;

  v6 = (uint64_t *)(a1 + 408);
  v7 = *(unsigned __int16 *)(*(_QWORD *)a1 + 16);
  if ((v7 - 769) < 4)
  {
LABEL_7:
    if (bssl::SSLTranscript::InitHash((uint64_t **)(a1 + 408), (bssl *)v7, *(const ssl_cipher_st **)(a1 + 1536)))goto LABEL_8;
    return 0;
  }
  if ((_DWORD)v7 == 65277)
  {
    v7 = 771;
    goto LABEL_7;
  }
  if ((_DWORD)v7 != 65279)
  {
    if (bssl::SSLTranscript::InitHash((uint64_t **)(a1 + 408), 0, *(const ssl_cipher_st **)(a1 + 1536)))
      goto LABEL_8;
    return 0;
  }
  if (!bssl::SSLTranscript::InitHash((uint64_t **)(a1 + 408), (bssl *)0x302, *(const ssl_cipher_st **)(a1 + 1536)))return 0;
LABEL_8:
  v8 = *(unsigned int *)(*(_QWORD *)(a1 + 416) + 4);
  if (v8 >= 0x31)
    abort();
  *(_QWORD *)(a1 + 32) = v8;
  if ((_DWORD)v8)
    bzero((void *)(a1 + 40), v8);
  if ((*(_BYTE *)(a1 + 1570) & 4) == 0)
  {
    v9 = *v6;
    *v6 = 0;
    if (v9)
    {
      v10 = *(_QWORD *)(v9 + 8);
      if (v10)
      {
        v12 = *(_QWORD *)(v10 - 8);
        v11 = (void *)(v10 - 8);
        v13 = v12 + 8;
        if (v12 != -8)
          bzero(v11, v13);
        free(v11);
      }
      v15 = *(_QWORD *)(v9 - 8);
      v14 = (void *)(v9 - 8);
      v16 = v15 + 8;
      if (v15 != -8)
        bzero(v14, v16);
      free(v14);
      v8 = *(_QWORD *)(a1 + 32);
    }
  }
  v17 = *(const EVP_MD **)(a1 + 416);
  md_len = 0;
  v18 = HMAC(v17, (const void *)(a1 + 40), v8, a2, a3, (unsigned __int8 *)(a1 + 40), &md_len);
  v19 = v18 != 0;
  if (!v18)
    ERR_put_error(31, 0, 28, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/hkdf/hkdf.c", 51);
  return v19;
}

uint64_t bssl::tls13_init_early_key_schedule(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t v5;
  size_t v6;
  size_t v7;
  const EVP_MD *v8;
  unsigned __int8 *v9;
  _BOOL8 v10;
  unsigned int md_len;

  if (*((_QWORD *)a1 + 191))
    v4 = (uint64_t **)(a1 + 448);
  else
    v4 = (uint64_t **)(a1 + 408);
  v5 = *(unsigned __int16 *)(a2 + 4);
  if ((v5 - 769) < 4)
  {
LABEL_10:
    if (bssl::SSLTranscript::InitHash(v4, (bssl *)v5, *(const ssl_cipher_st **)(a2 + 200)))
      goto LABEL_11;
    return 0;
  }
  if ((_DWORD)v5 == 65277)
  {
    v5 = 771;
    goto LABEL_10;
  }
  if ((_DWORD)v5 != 65279)
  {
    if (bssl::SSLTranscript::InitHash(v4, 0, *(const ssl_cipher_st **)(a2 + 200)))
      goto LABEL_11;
    return 0;
  }
  if (!bssl::SSLTranscript::InitHash(v4, (bssl *)0x302, *(const ssl_cipher_st **)(a2 + 200)))
    return 0;
LABEL_11:
  v6 = *((unsigned int *)v4[1] + 1);
  if (v6 >= 0x31)
    abort();
  *((_QWORD *)a1 + 4) = v6;
  if ((_DWORD)v6)
    bzero(a1 + 40, v6);
  v7 = *(unsigned __int8 *)(a2 + 10);
  v8 = (const EVP_MD *)v4[1];
  md_len = 0;
  v9 = HMAC(v8, a1 + 40, v6, (const unsigned __int8 *)(a2 + 11), v7, a1 + 40, &md_len);
  v10 = v9 != 0;
  if (v9)
    return 1;
  ERR_put_error(31, 0, 28, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/hkdf/hkdf.c", 51);
  return v10;
}

BOOL bssl::tls13_advance_key_schedule(uint64_t a1, const unsigned __int8 *a2, size_t a3)
{
  const EVP_MD *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  _BOOL8 v9;
  unsigned int size;
  unsigned int md_len;
  unsigned __int8 md[64];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  size = 0;
  if (!EVP_Digest(0, 0, md, &size, *(const EVP_MD **)(a1 + 416), 0))
    return 0;
  if (CRYPTO_tls13_hkdf_expand_label(a1 + 40, *(_QWORD *)(a1 + 32), *(EVP_MD **)(a1 + 416), (void *)(a1 + 40), *(_QWORD *)(a1 + 32), "derived", 7uLL, md, size) != 1)return 0;
  v6 = *(const EVP_MD **)(a1 + 416);
  v7 = *(_QWORD *)(a1 + 32);
  md_len = 0;
  v8 = HMAC(v6, (const void *)(a1 + 40), v7, a2, a3, (unsigned __int8 *)(a1 + 40), &md_len);
  v9 = v8 != 0;
  if (!v8)
    ERR_put_error(31, 0, 28, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/hkdf/hkdf.c", 51);
  return v9;
}

uint64_t bssl::tls13_set_traffic_key(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, void *a5, size_t a6)
{
  unsigned int v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  size_t v22;
  const ssl_cipher_st *v23;
  uint64_t v24;
  uint64_t *handshake_digest;
  int *v26;
  size_t v27;
  size_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t, void **, void *, size_t);
  int v31;
  _QWORD *v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  size_t v36;
  uint64_t (*v38)(uint64_t, uint64_t, void **, void *, size_t);
  int v39;
  _QWORD *v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  size_t v44;
  void *v45;
  void *v46;
  _QWORD *v47;
  uint64_t v48;
  int *v49;
  _BYTE v50[24];
  _BYTE v51[80];
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v12 = *(unsigned __int16 *)(a4 + 4);
  if (v12 - 769 >= 4)
  {
    if (v12 == 65277)
    {
      v12 = 771;
    }
    else if (v12 == 65279)
    {
      v12 = 770;
    }
    else
    {
      v12 = 0;
    }
  }
  if (*(_QWORD *)(a1 + 152))
  {
    v13 = *(_QWORD *)(a4 + 200);
    v14 = malloc_type_malloc(0x270uLL, 0x30772F57uLL);
    if (!v14)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return 0;
    }
    v15 = v14;
    *v14 = 616;
    v14[1] = v13;
    v16 = v14 + 1;
    bzero(v14 + 2, 0x248uLL);
    *((_WORD *)v15 + 306) = 0;
    *((_WORD *)v15 + 307) = v12;
    *((_BYTE *)v15 + 616) = 0;
    *((_BYTE *)v15 + 617) &= 0xE0u;
    v15[75] = 0;
    *((_DWORD *)v15 + 152) = 0;
    v17 = a5;
    v18 = a6;
    if (a6 > 0x30)
    {
LABEL_5:
      ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_enc.cc", 195);
      v19 = v16[1];
      if (v19)
      {
        (*(void (**)(_QWORD *))(v19 + 24))(v16 + 1);
        v16[1] = 0;
      }
      v21 = *(v16 - 1);
      v20 = v16 - 1;
      v22 = v21 + 8;
      if (v21 != -8)
        bzero(v20, v22);
      free(v20);
      return 0;
    }
  }
  else
  {
    v49 = 0;
    if ((bssl::ssl_cipher_get_evp_aead(&v49, &v48, &v48, *(_QWORD *)(a4 + 200), v12, **(_BYTE **)a1) & 1) == 0)
      return 0;
    v24 = *(unsigned __int16 *)(a4 + 4);
    if ((v24 - 769) >= 4)
    {
      if ((_DWORD)v24 == 65277)
      {
        v24 = 771;
      }
      else if ((_DWORD)v24 == 65279)
      {
        v24 = 770;
      }
      else
      {
        v24 = 0;
      }
    }
    handshake_digest = bssl::ssl_get_handshake_digest((bssl *)v24, *(_QWORD *)(a4 + 200), v23);
    v26 = v49;
    v27 = *(unsigned __int8 *)v49;
    if (CRYPTO_tls13_hkdf_expand_label((uint64_t)v51, v27, (EVP_MD *)handshake_digest, a5, a6, "key", 3uLL, 0, 0) != 1)return 0;
    v28 = *((unsigned __int8 *)v26 + 1);
    if (CRYPTO_tls13_hkdf_expand_label((uint64_t)v50, v28, (EVP_MD *)handshake_digest, a5, a6, "iv", 2uLL, 0, 0) != 1)return 0;
    bssl::SSLAEADContext::Create(a3, *(unsigned __int16 *)(a4 + 4), **(_BYTE **)a1, *(_QWORD *)(a4 + 200), v51, v27, 0, 0, &v47, v50, v28);
    v16 = v47;
    if (!v47)
      return 0;
    v17 = 0;
    v18 = 0;
    if (a6 > 0x30)
      goto LABEL_5;
  }
  v29 = *(char **)a1;
  if (a3)
  {
    v30 = (uint64_t (*)(uint64_t, uint64_t, void **, void *, size_t))*((_QWORD *)v29 + 18);
    v45 = v16;
    v31 = v30(a1, a2, &v45, v17, v18);
    v32 = v45;
    v45 = 0;
    if (v32)
    {
      v33 = v32[1];
      if (v33)
      {
        (*(void (**)(_QWORD *))(v33 + 24))(v32 + 1);
        v32[1] = 0;
      }
      v35 = *(v32 - 1);
      v34 = (char *)(v32 - 1);
      v36 = v35 + 8;
      if (v35 != -8)
        bzero(v34, v36);
      free(v34);
    }
    if (!v31)
      return 0;
    if (a6)
      memmove((void *)(*(_QWORD *)(a1 + 48) + 288), a5, a6);
    *(_BYTE *)(*(_QWORD *)(a1 + 48) + 432) = a6;
    return 1;
  }
  else
  {
    v38 = (uint64_t (*)(uint64_t, uint64_t, void **, void *, size_t))*((_QWORD *)v29 + 17);
    v46 = v16;
    v39 = v38(a1, a2, &v46, v17, v18);
    v40 = v46;
    v46 = 0;
    if (v40)
    {
      v41 = v40[1];
      if (v41)
      {
        (*(void (**)(_QWORD *))(v41 + 24))(v40 + 1);
        v40[1] = 0;
      }
      v43 = *(v40 - 1);
      v42 = (char *)(v40 - 1);
      v44 = v43 + 8;
      if (v43 != -8)
        bzero(v42, v44);
      free(v42);
    }
    if (!v39)
      return 0;
    if (a6)
      memmove((void *)(*(_QWORD *)(a1 + 48) + 336), a5, a6);
    *(_BYTE *)(*(_QWORD *)(a1 + 48) + 433) = a6;
    return 1;
  }
}

uint64_t bssl::tls13_derive_early_secret(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3;
  EVP_MD **v4;
  uint64_t v5;
  unint64_t v7;
  unsigned __int8 v8[64];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)this;
  if ((*(_BYTE *)(*(_QWORD *)this + 164) & 1) != 0 || !*((_QWORD *)this + 191))
    v4 = (EVP_MD **)((char *)this + 408);
  else
    v4 = (EVP_MD **)((char *)this + 448);
  v5 = *((_QWORD *)this + 4);
  v7 = 0;
  if (bssl::SSLTranscript::GetHash((bssl::SSLTranscript *)v4, v8, &v7)
    && CRYPTO_tls13_hkdf_expand_label((uint64_t)this + 88, v5, v4[1], (char *)this + 40, *((_QWORD *)this + 4), "c e traffic", 0xBuLL, v8, v7) == 1)
  {
    return bssl::ssl_log_secret(v3, "CLIENT_EARLY_TRAFFIC_SECRET", (unsigned __int8 *)this + 88, *((_QWORD *)this + 4));
  }
  else
  {
    return 0;
  }
}

uint64_t bssl::tls13_derive_handshake_secrets(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3;
  uint64_t v4;
  bssl::SSLTranscript *v5;
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  unsigned __int8 v9[64];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)this;
  v4 = *((_QWORD *)this + 4);
  v5 = (bssl *)((char *)this + 408);
  v8 = 0;
  if (!bssl::SSLTranscript::GetHash((bssl *)((char *)this + 408), v9, &v8)
    || CRYPTO_tls13_hkdf_expand_label((uint64_t)this + 136, v4, *((EVP_MD **)this + 52), (char *)this + 40, *((_QWORD *)this + 4), "c hs traffic", 0xCuLL, v9, v8) != 1)
  {
    return 0;
  }
  result = bssl::ssl_log_secret(v3, "CLIENT_HANDSHAKE_TRAFFIC_SECRET", (unsigned __int8 *)this + 136, *((_QWORD *)this + 4));
  if (!(_DWORD)result)
    return result;
  v7 = *((_QWORD *)this + 4);
  v8 = 0;
  if (bssl::SSLTranscript::GetHash(v5, v9, &v8))
  {
    if (CRYPTO_tls13_hkdf_expand_label((uint64_t)this + 184, v7, *((EVP_MD **)this + 52), (char *)this + 40, *((_QWORD *)this + 4), "s hs traffic", 0xCuLL, v9, v8) == 1)return bssl::ssl_log_secret(v3, "SERVER_HANDSHAKE_TRAFFIC_SECRET", (unsigned __int8 *)this + 184, *((_QWORD *)this + 4));
    return 0;
  }
  return 0;
}

uint64_t bssl::tls13_derive_application_secrets(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v3;
  bssl::SSLTranscript *v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unsigned __int8 v11[64];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)this;
  v4 = (bssl *)((char *)this + 408);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)this + 48) + 434) = *(_DWORD *)(*((_QWORD *)this + 52) + 4);
  v5 = *((_QWORD *)this + 4);
  v10 = 0;
  if (!bssl::SSLTranscript::GetHash((bssl *)((char *)this + 408), v11, &v10)
    || CRYPTO_tls13_hkdf_expand_label((uint64_t)this + 232, v5, *((EVP_MD **)this + 52), (char *)this + 40, *((_QWORD *)this + 4), "c ap traffic", 0xCuLL, v11, v10) != 1)
  {
    return 0;
  }
  result = bssl::ssl_log_secret(v3, "CLIENT_TRAFFIC_SECRET_0", (unsigned __int8 *)this + 232, *((_QWORD *)this + 4));
  if (!(_DWORD)result)
    return result;
  v7 = *((_QWORD *)this + 4);
  v10 = 0;
  if (!bssl::SSLTranscript::GetHash(v4, v11, &v10)
    || CRYPTO_tls13_hkdf_expand_label((uint64_t)this + 280, v7, *((EVP_MD **)this + 52), (char *)this + 40, *((_QWORD *)this + 4), "s ap traffic", 0xCuLL, v11, v10) != 1)
  {
    return 0;
  }
  result = bssl::ssl_log_secret(v3, "SERVER_TRAFFIC_SECRET_0", (unsigned __int8 *)this + 280, *((_QWORD *)this + 4));
  if (!(_DWORD)result)
    return result;
  v8 = *(_QWORD *)(v3 + 48);
  v9 = *(unsigned __int8 *)(v8 + 434);
  v10 = 0;
  if (bssl::SSLTranscript::GetHash(v4, v11, &v10)
    && CRYPTO_tls13_hkdf_expand_label(v8 + 384, v9, *((EVP_MD **)this + 52), (char *)this + 40, *((_QWORD *)this + 4), "exp master", 0xAuLL, v11, v10) == 1)
  {
    return bssl::ssl_log_secret(v3, "EXPORTER_SECRET", (unsigned __int8 *)(*(_QWORD *)(v3 + 48) + 384), *(unsigned __int8 *)(*(_QWORD *)(v3 + 48) + 434));
  }
  else
  {
    return 0;
  }
}

uint64_t bssl::tls13_rotate_traffic_key(uint64_t a1, unsigned int a2, const ssl_cipher_st *a3)
{
  _QWORD *v5;
  uint64_t v6;
  void *v7;
  size_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *handshake_digest;

  v5 = *(_QWORD **)(a1 + 48);
  v6 = 432;
  if (a2)
  {
    v7 = v5 + 36;
  }
  else
  {
    v6 = 433;
    v7 = v5 + 42;
  }
  v8 = *((unsigned __int8 *)v5 + v6);
  v9 = v5[58];
  if (v9 || (v10 = (_QWORD *)v5[35], (v9 = v10[189]) != 0) || (v9 = v10[188]) != 0)
  {
    v11 = *(unsigned __int16 *)(v9 + 4);
    if ((v11 - 769) < 4)
      goto LABEL_8;
LABEL_12:
    if ((_DWORD)v11 == 65277)
    {
      v11 = 771;
    }
    else if ((_DWORD)v11 == 65279)
    {
      v11 = 770;
    }
    else
    {
      v11 = 0;
    }
    goto LABEL_8;
  }
  v9 = *(_QWORD *)(*v10 + 88);
  v11 = *(unsigned __int16 *)(v9 + 4);
  if ((v11 - 769) >= 4)
    goto LABEL_12;
LABEL_8:
  handshake_digest = bssl::ssl_get_handshake_digest((bssl *)v11, *(_QWORD *)(v9 + 200), a3);
  if (CRYPTO_tls13_hkdf_expand_label((uint64_t)v7, v8, (EVP_MD *)handshake_digest, v7, v8, "traffic upd", 0xBuLL, 0, 0) == 1)return bssl::tls13_set_traffic_key(a1, 3, a2, v9, v7, v8);
  else
    return 0;
}

BOOL bssl::tls13_derive_resumption_secret(bssl *this, bssl::SSL_HANDSHAKE *a2)
{
  uint64_t v2;
  _BOOL8 result;
  uint64_t v5;
  unint64_t v6;
  unsigned __int8 v7[64];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *(unsigned int *)(*((_QWORD *)this + 52) + 4);
  if (v2 < 0x31)
  {
    v5 = *((_QWORD *)this + 188);
    *(_BYTE *)(v5 + 10) = v2;
    v6 = 0;
    result = bssl::SSLTranscript::GetHash((bssl *)((char *)this + 408), v7, &v6);
    if ((_DWORD)result)
      return CRYPTO_tls13_hkdf_expand_label(v5 + 11, v2, *((EVP_MD **)this + 52), (char *)this + 40, *((_QWORD *)this + 4), "res master", 0xAuLL, v7, v6) == 1;
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_enc.cc", 309);
    return 0;
  }
  return result;
}

BOOL bssl::tls13_derive_session_psk(uint64_t a1, const void *a2, const ssl_cipher_st *a3)
{
  uint64_t v6;
  uint64_t *handshake_digest;

  v6 = *(unsigned __int16 *)(a1 + 4);
  if ((v6 - 769) >= 4)
  {
    if ((_DWORD)v6 == 65277)
    {
      v6 = 771;
    }
    else if ((_DWORD)v6 == 65279)
    {
      v6 = 770;
    }
    else
    {
      v6 = 0;
    }
  }
  handshake_digest = bssl::ssl_get_handshake_digest((bssl *)v6, *(_QWORD *)(a1 + 200), a3);
  return CRYPTO_tls13_hkdf_expand_label(a1 + 11, *(unsigned __int8 *)(a1 + 10), (EVP_MD *)handshake_digest, (void *)(a1 + 11), *(unsigned __int8 *)(a1 + 10), "resumption", 0xAuLL, a2, (size_t)a3) == 1;
}

uint64_t bssl::tls13_export_keying_material(uint64_t a1, uint64_t a2, const ssl_cipher_st *a3, void *a4, uint64_t a5, const void *a6, size_t a7, uint64_t a8, const void *a9, size_t a10)
{
  int v12;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  EVP_MD *handshake_digest;
  uint64_t result;
  size_t v22;
  unsigned int pkey_type;
  unsigned int size[2];
  unsigned __int8 v25[64];
  unsigned __int8 v26[64];
  unsigned __int8 md[64];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (a5)
  {
    v12 = a5;
    v16 = *(_QWORD *)(a1 + 48);
    v17 = *(_QWORD *)(v16 + 464);
    if (!v17)
    {
      v18 = *(_QWORD **)(v16 + 280);
      v17 = v18[189];
      if (!v17)
      {
        v17 = v18[188];
        if (!v17)
          v17 = *(_QWORD *)(*v18 + 88);
      }
    }
    v19 = *(unsigned __int16 *)(v17 + 4);
    if ((v19 - 769) >= 4)
    {
      if ((_DWORD)v19 == 65277)
      {
        v19 = 771;
      }
      else if ((_DWORD)v19 == 65279)
      {
        v19 = 770;
      }
      else
      {
        v19 = 0;
      }
    }
    handshake_digest = (EVP_MD *)bssl::ssl_get_handshake_digest((bssl *)v19, *(_QWORD *)(v17 + 200), a3);
    *(_QWORD *)size = 0;
    result = EVP_Digest(a9, a10, md, &size[1], handshake_digest, 0);
    if ((_DWORD)result)
    {
      result = EVP_Digest(0, 0, v26, size, handshake_digest, 0);
      if ((_DWORD)result)
      {
        v22 = size[1];
        pkey_type = handshake_digest->pkey_type;
        return CRYPTO_tls13_hkdf_expand_label((uint64_t)v25, pkey_type, handshake_digest, a4, v12, a6, a7, v26, size[0]) == 1&& CRYPTO_tls13_hkdf_expand_label(a2, (uint64_t)a3, handshake_digest, v25, pkey_type, "exporter", 8uLL, md, v22) == 1;
      }
    }
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_enc.cc", 375);
    return 0;
  }
  return result;
}

uint64_t bssl::tls13_write_psk_binder(uint64_t *a1, bssl::SSLTranscript *a2, const ssl_cipher_st *a3, unint64_t a4, size_t *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v16;
  unsigned __int8 __src[64];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v9 = *a1;
  v10 = *(_QWORD *)(*a1 + 88);
  v11 = *(unsigned __int16 *)(v10 + 4);
  if ((v11 - 769) >= 4)
  {
    if ((_DWORD)v11 == 65277)
    {
      v11 = 771;
    }
    else if ((_DWORD)v11 == 65279)
    {
      v11 = 770;
    }
    else
    {
      v11 = 0;
    }
  }
  v12 = *((unsigned int *)bssl::ssl_get_handshake_digest((bssl *)v11, *(_QWORD *)(v10 + 200), a3) + 1);
  v16 = 0;
  v13 = bssl::tls13_psk_binder(__src, &v16, *(_QWORD *)(v9 + 88), a2, (uint64_t)a3, a4, v12 + 3);
  if (v16 == v12)
    v14 = v13;
  else
    v14 = 0;
  if ((v14 & 1) != 0)
  {
    if (a4 < v12)
      abort();
    if ((_DWORD)v12)
      memcpy((char *)a3 + a4 - v12, __src, v12);
    if (a5)
      *a5 = v12;
  }
  else
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_enc.cc", 472);
  }
  return v14;
}

uint64_t bssl::tls13_psk_binder(unsigned __int8 *a1, _QWORD *a2, uint64_t a3, bssl::SSLTranscript *a4, uint64_t a5, unint64_t a6, unint64_t a7)
{
  uint64_t v14;
  EVP_MD *handshake_digest;
  uint64_t pkey_type;
  size_t v17;
  BOOL v18;
  unint64_t v19;
  const char *v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  unint64_t v26;
  size_t v27;
  size_t final_high;
  uint64_t v29;
  ENGINE *engine;
  char *v31;
  uint64_t v32;
  size_t v33;
  env_md_ctx_st out;
  unsigned int size;
  unsigned int v36;
  unsigned __int8 d[64];
  _OWORD v38[4];
  unsigned __int8 v39[16];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  unsigned __int8 md[64];
  unsigned int md_len[16];
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  v14 = *(unsigned __int16 *)(a3 + 4);
  if ((v14 - 769) >= 4)
  {
    if ((_DWORD)v14 == 65277)
    {
      v14 = 771;
    }
    else if ((_DWORD)v14 == 65279)
    {
      v14 = 770;
    }
    else
    {
      v14 = 0;
    }
  }
  handshake_digest = (EVP_MD *)bssl::ssl_get_handshake_digest((bssl *)v14, *(_QWORD *)(a3 + 200), (const ssl_cipher_st *)a3);
  size = 0;
  v41 = 0u;
  v42 = 0u;
  *(_OWORD *)v39 = 0u;
  v40 = 0u;
  memset(v38, 0, sizeof(v38));
  pkey_type = handshake_digest->pkey_type;
  if (!EVP_Digest(0, 0, md, &size, handshake_digest, 0))
    return 0;
  v17 = *(unsigned __int8 *)(a3 + 10);
  md_len[0] = 0;
  if (!HMAC(handshake_digest, 0, 0, (const unsigned __int8 *)(a3 + 11), v17, v39, md_len))
  {
    v20 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/fipsmodule/hkdf/hkdf.c";
    v21 = 31;
    v22 = 28;
    v23 = 51;
    goto LABEL_11;
  }
  if (CRYPTO_tls13_hkdf_expand_label((uint64_t)v38, pkey_type, handshake_digest, v39, md_len[0], "res binder", 0xAuLL, md, size) != 1)return 0;
  v18 = a6 >= a7;
  v19 = a6 - a7;
  if (!v18)
  {
    v20 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_enc.cc";
    v21 = 16;
    v22 = 68;
    v23 = 434;
LABEL_11:
    ERR_put_error(v21, 0, v22, v20, v23);
    return 0;
  }
  memset(&out, 0, sizeof(out));
  if (!bssl::SSLTranscript::CopyToHashContext(a4, &out, handshake_digest))
  {
    v24 = 0;
    goto LABEL_27;
  }
  if (a6 >= v19)
    v26 = v19;
  else
    v26 = a6;
  ((void (*)(env_md_ctx_st *, uint64_t, unint64_t))out.digest->init)(&out, a5, v26);
  ((void (*)(env_md_ctx_st *, unsigned __int8 *))out.digest->update)(&out, d);
  v27 = out.digest->pkey_type;
  final_high = HIDWORD(out.digest->final);
  if ((_DWORD)final_high)
    bzero(out.engine, final_high);
  v29 = handshake_digest->pkey_type;
  v36 = 0;
  v24 = 0;
  if (CRYPTO_tls13_hkdf_expand_label((uint64_t)md_len, v29, handshake_digest, v38, pkey_type, "finished", 8uLL, 0, 0) != 1)
  {
LABEL_27:
    engine = out.engine;
    if (!out.engine)
      goto LABEL_31;
    goto LABEL_28;
  }
  if (HMAC(handshake_digest, md_len, v29, d, v27, a1, &v36))
  {
    *a2 = v36;
    v24 = 1;
    engine = out.engine;
    if (!out.engine)
      goto LABEL_31;
LABEL_28:
    v32 = *((_QWORD *)engine - 1);
    v31 = (char *)engine - 8;
    v33 = v32 + 8;
    if (v32 != -8)
      bzero(v31, v33);
    free(v31);
    goto LABEL_31;
  }
  v24 = 0;
  engine = out.engine;
  if (out.engine)
    goto LABEL_28;
LABEL_31:
  if (out.md_data)
    (*(void (**)(unint64_t))out.md_data)(out.flags);
  return v24;
}

uint64_t bssl::tls13_verify_psk_binder(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10, int8x16_t a11, int8x16_t a12, int8x16_t a13, int8x16_t a14, int8x16_t a15)
{
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  unint64_t v20;
  BOOL v21;
  unsigned __int8 *v22;
  int v23;
  int v24;
  uint64_t v26;
  unsigned __int8 v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  unint64_t v31;
  uint64_t v32;
  int8x8_t v33;
  int8x8_t *v34;
  int8x8_t *v35;
  uint64_t v36;
  int8x8_t v37;
  int8x8_t v38;
  int8x8_t v39;
  uint64_t v40;
  uint64_t v41;
  __int8 *v42;
  unsigned __int8 *v43;
  char v44;
  char v45;
  char v46;
  uint64_t v47;
  int8x16_t v48[4];
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t vars0;

  v49.i64[1] = *MEMORY[0x24BDAC8D0];
  v47 = 0;
  if (!bssl::tls13_psk_binder((unsigned __int8 *)v48, &v47, a2, (bssl::SSLTranscript *)(a1 + 408), *(_QWORD *)(a3 + 24), *(_QWORD *)(a3 + 32), a4[1] + 2))goto LABEL_4;
  v16 = (unsigned __int8 *)a4[1];
  if (!v16)
    goto LABEL_4;
  v17 = (unsigned __int8 *)*a4;
  v18 = *a4 + 1;
  v19 = v16 - 1;
  *a4 = v18;
  a4[1] = (uint64_t)(v16 - 1);
  v20 = *v17;
  v21 = (unint64_t)v19 >= v20;
  v22 = &v19[-v20];
  if (!v21)
  {
LABEL_4:
    v23 = 68;
    v24 = 497;
LABEL_5:
    ERR_put_error(16, 0, v23, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_enc.cc", v24);
    return 0;
  }
  *a4 = v18 + v20;
  a4[1] = (uint64_t)v22;
  if (v47 != v20)
  {
LABEL_27:
    v23 = 142;
    v24 = 508;
    goto LABEL_5;
  }
  if ((_DWORD)v20)
  {
    if (v20 < 8)
    {
      v26 = 0;
      v27 = 0;
      goto LABEL_24;
    }
    if (v20 >= 0x20)
    {
      v26 = v20 & 0xE0;
      v28 = veorq_s8(v48[0], *(int8x16_t *)(v17 + 1));
      v29 = veorq_s8(v48[1], *(int8x16_t *)(v17 + 17));
      if (v26 != 32)
      {
        v28 = vorrq_s8(veorq_s8(v48[2], *(int8x16_t *)(v17 + 33)), v28);
        v29 = vorrq_s8(veorq_s8(v48[3], *(int8x16_t *)(v17 + 49)), v29);
        if (v26 != 64)
        {
          v28 = vorrq_s8(veorq_s8(v49, *(int8x16_t *)(v17 + 65)), v28);
          v29 = vorrq_s8(veorq_s8(v50, *(int8x16_t *)(v17 + 81)), v29);
          if (v26 != 96)
          {
            v28 = vorrq_s8(veorq_s8(vars0, *(int8x16_t *)(v17 + 97)), v28);
            v29 = vorrq_s8(veorq_s8(a9, *(int8x16_t *)(v17 + 113)), v29);
            if (v26 != 128)
            {
              v28 = vorrq_s8(veorq_s8(a10, *(int8x16_t *)(v17 + 129)), v28);
              v29 = vorrq_s8(veorq_s8(a11, *(int8x16_t *)(v17 + 145)), v29);
              if (v26 != 160)
              {
                v28 = vorrq_s8(veorq_s8(a12, *(int8x16_t *)(v17 + 161)), v28);
                v29 = vorrq_s8(veorq_s8(a13, *(int8x16_t *)(v17 + 177)), v29);
                if (v26 != 192)
                {
                  v28 = vorrq_s8(veorq_s8(a14, *(int8x16_t *)(v17 + 193)), v28);
                  v29 = vorrq_s8(veorq_s8(a15, *(int8x16_t *)(v17 + 209)), v29);
                }
              }
            }
          }
        }
      }
      v30 = vorrq_s8(v29, v28);
      *(int8x8_t *)v30.i8 = vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
      v31 = v30.i64[0] | HIDWORD(v30.i64[0]) | ((unint64_t)(v30.i64[0] | HIDWORD(v30.i64[0])) >> 16);
      v27 = v31 | BYTE1(v31);
      if (v26 == v20)
        goto LABEL_26;
      if ((v20 & 0x18) == 0)
      {
LABEL_24:
        v41 = v20 - v26;
        v42 = &v48[0].i8[v26];
        v43 = &v17[v26 + 1];
        do
        {
          v45 = *v43++;
          v44 = v45;
          v46 = *v42++;
          v27 |= v46 ^ v44;
          --v41;
        }
        while (v41);
        goto LABEL_26;
      }
    }
    else
    {
      v27 = 0;
      v26 = 0;
    }
    v32 = v26;
    v33 = (int8x8_t)v27;
    v26 = v20 & 0xF8;
    v34 = (int8x8_t *)&v17[v32 + 1];
    v35 = (int8x8_t *)((char *)v48 + v32);
    v36 = v32 - v26;
    do
    {
      v37 = *v34++;
      v38 = v37;
      v39 = *v35++;
      v33 = vorr_s8(veor_s8(v39, v38), v33);
      v36 += 8;
    }
    while (v36);
    v40 = *(_QWORD *)&v33 | HIDWORD(*(_QWORD *)&v33) | ((*(_QWORD *)&v33 | HIDWORD(*(_QWORD *)&v33)) >> 16);
    v27 = v40 | BYTE1(v40);
    if (v26 != v20)
      goto LABEL_24;
LABEL_26:
    if (v27)
      goto LABEL_27;
  }
  return 1;
}

BOOL bssl::ssl_ech_accept_confirmation(int a1, uint64_t a2, uint64_t a3, const unsigned __int8 *a4, size_t a5, bssl::SSLTranscript *this, int a7, int a8, uint64_t a9, unint64_t a10, uint64_t a11)
{
  _BOOL8 v11;
  size_t pkey_type;
  size_t final_high;
  const EVP_MD *v20;
  int v21;
  const char *v22;
  size_t v23;
  ENGINE *engine;
  char *v25;
  uint64_t v26;
  size_t v27;
  env_md_ctx_st out;
  unsigned int md_len;
  unsigned __int8 md[64];
  _BYTE v32[64];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (a10 < a11 + 8)
  {
    ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_enc.cc", 533);
    return 0;
  }
  memset(&out, 0, sizeof(out));
  if (bssl::SSLTranscript::CopyToHashContext(this, &out, *((const env_md_st **)this + 1)))
  {
    ((void (*)(env_md_ctx_st *))out.digest->init)(&out);
    ((void (*)(env_md_ctx_st *, void *, uint64_t))out.digest->init)(&out, &bssl::ssl_ech_accept_confirmation(bssl::SSL_HANDSHAKE const*,bssl::Span<unsigned char>,bssl::Span<unsigned char const>,bssl::SSLTranscript const&,BOOL,bssl::Span<unsigned char const>,unsigned long)::kZeros, 8);
    ((void (*)(env_md_ctx_st *, uint64_t, unint64_t))out.digest->init)(&out, a9 + a11 + 8, a10 - (a11 + 8));
    ((void (*)(env_md_ctx_st *, _BYTE *))out.digest->update)(&out, v32);
    pkey_type = out.digest->pkey_type;
    final_high = HIDWORD(out.digest->final);
    if ((_DWORD)final_high)
      bzero(out.engine, final_high);
    v20 = (const EVP_MD *)*((_QWORD *)this + 1);
    v21 = v20->pkey_type;
    md_len = 0;
    if (HMAC(v20, &bssl::ssl_ech_accept_confirmation(bssl::SSL_HANDSHAKE const*,bssl::Span<unsigned char>,bssl::Span<unsigned char const>,bssl::SSLTranscript const&,BOOL,bssl::Span<unsigned char const>,unsigned long)::kZeros, v21, a4, a5, md, &md_len))
    {
      if (a7)
        v22 = "hrr ech accept confirmation";
      else
        v22 = "ech accept confirmation";
      if (a7)
        v23 = 27;
      else
        v23 = 23;
      v11 = CRYPTO_tls13_hkdf_expand_label(a2, a3, *((EVP_MD **)this + 1), md, md_len, v22, v23, v32, pkey_type) == 1;
      engine = out.engine;
      if (!out.engine)
        goto LABEL_21;
LABEL_18:
      v26 = *((_QWORD *)engine - 1);
      v25 = (char *)engine - 8;
      v27 = v26 + 8;
      if (v26 != -8)
        bzero(v25, v27);
      free(v25);
      goto LABEL_21;
    }
    ERR_put_error(31, 0, 28, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/fipsmodule/hkdf/hkdf.c", 51);
    v11 = 0;
    engine = out.engine;
    if (out.engine)
      goto LABEL_18;
  }
  else
  {
    v11 = 0;
    engine = out.engine;
    if (out.engine)
      goto LABEL_18;
  }
LABEL_21:
  if (out.md_data)
    (*(void (**)(unint64_t))out.md_data)(out.flags);
  return v11;
}

uint64_t bssl::tls13_server_handshake(bssl *this, bssl::SSL_HANDSHAKE *a2, BOOL *a3)
{
  char *v4;
  char *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  char options;
  BOOL v10;
  uint64_t *v11;
  uint64_t *v12;
  char *v13;
  pem_password_cb *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  X509_VERIFY_PARAM *param;
  _QWORD *v20;
  uint64_t v21;
  unint64_t msg_callback_arg;
  uint64_t v23;
  uint64_t v24;
  void (__cdecl *msg_callback)(int, int, int, const void *, size_t, SSL *, void *);
  unint64_t v26;
  void (__cdecl *v27)(int, int, int, const void *, size_t, SSL *, void *);
  unint64_t v28;
  pem_password_cb *v29;
  void *v30;
  unsigned int v31;
  char v32;
  SSL_METHOD *v33;
  uint64_t v34;
  uint64_t v35;
  __int16 *v36;
  uint64_t v37;
  uint64_t v38;
  __int16 *v39;
  uint64_t v40;
  __int16 *v41;
  __int16 *v42;
  __int16 *v43;
  uint64_t v44;
  _OWORD *v45;
  size_t v46;
  int v47;
  int v48;
  unsigned int (*v49)(uint64_t, ssl_session_st **);
  char v50;
  int v51;
  int v52;
  uint64_t v53;
  _QWORD *v54;
  int v55;
  uint64_t v56;
  unsigned int v57;
  uint64_t v58;
  unint64_t v59;
  void (__cdecl *v60)(int, int, int, const void *, size_t, SSL *, void *);
  unint64_t v61;
  unint64_t v62;
  unsigned __int8 *v63;
  bssl *v64;
  int method_low;
  char *v66;
  _QWORD *v67;
  uint64_t v68;
  __int128 *v69;
  uint64_t v70;
  __int128 *v71;
  __int128 v72;
  BOOL v73;
  STACK *v74;
  STACK *v75;
  int v76;
  STACK *v77;
  STACK *v78;
  uint64_t v79;
  EVP_MD *v80;
  void *v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t *v84;
  uint64_t v85;
  char v86;
  STACK *extra_certs;
  STACK *comp_methods;
  char *v89;
  uint64_t v90;
  _QWORD *v91;
  void *v92;
  uint64_t v93;
  size_t v94;
  char *v95;
  __int128 v96;
  uint64_t v97;
  const EVP_MD *rsa_md5;
  __int128 v99;
  size_t v100;
  int v101;
  int v102;
  unint64_t v103;
  _QWORD *v104;
  uint64_t (*v105)(_QWORD *, SSL_SESSION *(__cdecl **)(ssl_st *, unsigned __int8 *, int, int *));
  int v106;
  unsigned int v107;
  uint64_t v108;
  unsigned int v109;
  int v110;
  uint64_t v112;
  void *v113;
  _QWORD *app_verify_arg;
  char *v115;
  uint64_t v116;
  size_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned __int16 *v122;
  int v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  char v132;
  int v133;
  int v134;
  STACK *v135;
  STACK *v136;
  unint64_t v137;
  unint64_t v138;
  unsigned __int16 v139;
  __int16 *v140;
  __int16 *v141;
  char *v142;
  uint64_t v143;
  int v144;
  unsigned int v145;
  unsigned int v146;
  char v147;
  ssl_credential_st *v148;
  unsigned int v149;
  int v150;
  uint64_t v151;
  uint64_t v152;
  const void *v153;
  unint64_t v154;
  const ssl_st *v155;
  _QWORD *v156;
  uint64_t v157;
  SSL_CIPHER *(__cdecl *get_cipher);
  unint64_t get_ssl_method;
  _QWORD *v160;
  uint64_t v161;
  uint64_t v162;
  const void *v163;
  unint64_t v164;
  _QWORD *v165;
  unsigned int (*v166)(const EVP_MD **);
  bssl *v167;
  const ssl_cipher_st *v168;
  uint64_t *handshake_digest;
  size_t v170;
  const unsigned __int8 *v171;
  uint64_t v172;
  uint64_t v173;
  int v174;
  BOOL v175;
  unint64_t v176;
  unint64_t v177;
  BOOL v178;
  unint64_t v179;
  int v180;
  int v181;
  _DWORD *v182;
  const ssl_st *v183;
  bssl *v184;
  int v185;
  int v186;
  size_t v187;
  SSL_METHOD *method;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  int8x16_t v193;
  int8x16_t v194;
  int8x16_t v195;
  int8x16_t v196;
  int8x16_t v197;
  int8x16_t v198;
  int8x16_t v199;
  unint64_t v200;
  void *v201;
  SSL_SESSION *v202;
  SSL_SESSION *v203;
  unsigned int i;
  unsigned int v205;
  uint64_t (__cdecl **p_ssl_ctx_callback_ctrl)(SSL_CTX *, int, void (*)(void));
  uint64_t (__cdecl *ssl_ctx_callback_ctrl)(SSL_CTX *, int, void (*)(void));
  size_t v208;
  void (*v209)(void);
  uint64_t v210;
  int get_timeout_low;
  size_t v212;
  size_t v213;
  unint64_t v214;
  void (__cdecl *v215)(int, int, int, const void *, size_t, SSL *, void *);
  unint64_t v216;
  pem_password_cb *v217;
  void *v218;
  unsigned int v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  int8x16_t v224;
  int8x16_t v225;
  int8x16_t v226;
  int8x16_t v227;
  int8x16_t v228;
  int8x16_t v229;
  int8x16_t v230;
  int v231;
  unint64_t ssl_version;
  uint64_t v233;
  int8x16_t *v234;
  ssl3_enc_method *ssl3_enc;
  unint64_t v236;
  unsigned __int8 v237;
  _QWORD *v238;
  _QWORD *v239;
  int8x16_t *v240;
  int8x16_t *v241;
  int8x16_t v242;
  unint64_t v243;
  int8x16_t v244;
  int8x16_t v245;
  unint64_t v246;
  unint64_t v247;
  int8x8_t v248;
  int8x8_t *v249;
  int8x8_t *v250;
  unint64_t v251;
  int8x8_t v252;
  int8x8_t v253;
  int8x8_t v254;
  uint64_t v255;
  unint64_t v256;
  char *v257;
  __int8 *v258;
  char v259;
  char v260;
  char v261;
  char *v263;
  char *v264;
  char *v265;
  _QWORD *v266;
  char *v267;
  char *v268;
  unsigned __int8 *md;
  char *__dst;
  char *v271;
  uint64_t **v272;
  char *v273;
  uint64_t v274[6];
  ssl_ctx_st ses;

  v4 = (char *)this + 232;
  *(_QWORD *)ses.tlsext_tick_hmac_key = *MEMORY[0x24BDAC8D0];
  v272 = (uint64_t **)((char *)this + 408);
  v273 = (char *)this + 136;
  v268 = (char *)this + 280;
  md = (unsigned __int8 *)this + 328;
  __dst = (char *)this + 1581;
  v271 = (char *)this + 88;
  v264 = (char *)this + 184;
  v265 = (char *)this + 616;
  v5 = (char *)this + 416;
  v266 = (_QWORD *)((char *)this + 584);
  v267 = (char *)this + 40;
  while (2)
  {
    v6 = *((_DWORD *)this + 6);
    v7 = 1;
    switch(v6)
    {
      case 0:
        v8 = *(_QWORD *)this;
        if (!bssl::SSL_HANDSHAKE::GetClientHello((uint64_t)this, (uint64_t)&ses.generate_session_id, (uint64_t)&ses.rsa_md5))goto LABEL_526;
        options = ses.options;
        if (*(_QWORD *)(v8 + 152))
          v10 = ses.options == 0;
        else
          v10 = 1;
        if (!v10)
        {
          v123 = 306;
          v124 = 243;
          goto LABEL_287;
        }
        if (ses.options)
          memcpy(__dst, ses.client_CA, ses.options);
        *((_BYTE *)this + 1613) = options;
        ses.app_verify_arg = 0;
        ses.default_passwd_callback = 0;
        if (!bssl::ssl_get_credential_list((uint64_t)this, (uint64_t *)&ses.app_verify_arg))
          goto LABEL_434;
        if (!ses.default_passwd_callback)
        {
          ERR_put_error(16, 0, 174, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 256);
          bssl::ssl_send_alert((bssl *)v8, (ssl_st *)2, 80);
          v7 = 0;
          app_verify_arg = ses.app_verify_arg;
          if (ses.app_verify_arg)
            goto LABEL_261;
          goto LABEL_501;
        }
        v11 = (uint64_t *)ses.app_verify_arg;
        v12 = (uint64_t *)((char *)ses.app_verify_arg + 8 * (uint64_t)ses.default_passwd_callback);
        do
        {
          while (1)
          {
            v118 = *v11;
            ERR_clear_error();
            LOWORD(ses.verify_mode) = 0;
            if (*(_DWORD *)(v118 + 4) != 1)
              break;
            v119 = *((_QWORD *)this + 79);
            v120 = *((_QWORD *)this + 80);
            if (v120)
            {
              v121 = 2 * v120;
              v122 = (unsigned __int16 *)*((_QWORD *)this + 79);
              while (*v122 != *(unsigned __int16 *)(v118 + 64))
              {
                ++v122;
                v121 -= 2;
                if (!v121)
                {
                  v122 = (unsigned __int16 *)(v119 + 2 * v120);
                  break;
                }
              }
              if (v120 != ((uint64_t)v122 - v119) >> 1)
                break;
            }
            ERR_put_error(16, 0, 253, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 220);
            if (++v11 == v12)
              goto LABEL_277;
          }
          if (bssl::tls1_choose_signature_algorithm((bssl **)this, v118, (__int16 *)&ses.verify_mode))
          {
            if (!v118 || (v145 = atomic_load((unsigned int *)v118), v145 == -1))
            {
LABEL_357:
              v148 = (ssl_credential_st *)*((_QWORD *)this + 186);
              *((_QWORD *)this + 186) = v118;
              if (v148)
                SSL_CREDENTIAL_free(v148);
              *((_WORD *)this + 789) = ses.verify_mode;
              if (!*((_QWORD *)this + 186))
                goto LABEL_431;
              goto LABEL_360;
            }
            while (1)
            {
              v146 = __ldaxr((unsigned int *)v118);
              if (v146 == v145)
              {
                if (!__stlxr(v145 + 1, (unsigned int *)v118))
                {
                  v147 = 1;
                  goto LABEL_355;
                }
              }
              else
              {
                __clrex();
              }
              v147 = 0;
LABEL_355:
              if ((v147 & 1) == 0)
              {
                v145 = v146;
                if (v146 != -1)
                  continue;
              }
              goto LABEL_357;
            }
          }
          ++v11;
        }
        while (v11 != v12);
LABEL_277:
        if (!*((_QWORD *)this + 186))
          goto LABEL_431;
LABEL_360:
        v149 = *(unsigned __int16 *)(v8 + 16);
        if (v149 - 769 >= 4)
        {
          if (v149 == 65277)
          {
            v149 = 771;
          }
          else if (v149 == 65279)
          {
            v149 = 770;
          }
          else
          {
            v149 = 0;
          }
        }
        v182 = bssl::ssl_choose_tls13_cipher((unsigned __int16 *)ses.mode, ses.max_cert_list, (~*(unsigned __int16 *)(*(_QWORD *)(v8 + 8) + 237) & 0x1800) == 0, v149, *(_DWORD *)(*(_QWORD *)(v8 + 8) + 232));
        *((_QWORD *)this + 192) = v182;
        if (v182)
        {
          LOBYTE(ses.verify_mode) = 50;
          if ((bssl::ssl_negotiate_alpn(this, &ses.verify_mode, (uint64_t)&ses.rsa_md5) & 1) != 0)
          {
            v184 = (bssl *)bssl::ssl_protocol_version((bssl *)v8, v183);
            if (bssl::SSLTranscript::InitHash(v272, v184, *((const ssl_cipher_st **)this + 192)))
            {
              v7 = 1;
              *((_DWORD *)this + 6) = 1;
              app_verify_arg = ses.app_verify_arg;
              if (ses.app_verify_arg)
                goto LABEL_261;
              goto LABEL_501;
            }
          }
          else
          {
            bssl::ssl_send_alert((bssl *)v8, (ssl_st *)2, LOBYTE(ses.verify_mode));
          }
LABEL_434:
          v7 = 0;
          app_verify_arg = ses.app_verify_arg;
          if (ses.app_verify_arg)
            goto LABEL_261;
        }
        else
        {
          ERR_put_error(16, 0, 184, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 280);
LABEL_431:
          bssl::ssl_send_alert((bssl *)v8, (ssl_st *)2, 40);
          v7 = 0;
          app_verify_arg = ses.app_verify_arg;
          if (ses.app_verify_arg)
            goto LABEL_261;
        }
LABEL_501:
        if (*((_DWORD *)this + 6) != v6)
        {
LABEL_502:
          v209 = *(void (**)(void))(*(_QWORD *)this + 96);
          if (v209 || (v209 = *(void (**)(void))(*(_QWORD *)(*(_QWORD *)this + 104) + 384)) != 0)
            v209();
        }
LABEL_3:
        if ((_DWORD)v7 == 1)
          continue;
        return v7;
      case 1:
        v21 = *(_QWORD *)this;
        if (!bssl::SSL_HANDSHAKE::GetClientHello((uint64_t)this, (uint64_t)&ses.generate_session_id, (uint64_t)&ses.rsa_md5))goto LABEL_526;
        LOBYTE(ses.get_session_cb) = 50;
        msg_callback_arg = (unint64_t)ses.msg_callback_arg;
        if (!ses.msg_callback_arg)
          goto LABEL_52;
        v23 = *(_QWORD *)(v21 + 48);
        v24 = *(_QWORD *)this;
        msg_callback = ses.msg_callback;
        v26 = (unint64_t)ses.msg_callback_arg;
        v27 = ses.msg_callback;
        do
        {
          if (v26 < 2)
            break;
          if ((v26 & 0xFFFFFFFFFFFFFFFELL) == 2)
            break;
          v28 = v26 - 4;
          v29 = (pem_password_cb *)__rev16(*((unsigned __int16 *)v27 + 1));
          if (v28 < (unint64_t)v29)
            break;
          v31 = *(unsigned __int16 *)v27;
          v30 = (char *)v27 + 4;
          if (__rev16(v31) == 41)
          {
            ses.app_verify_arg = v30;
            ses.default_passwd_callback = v29;
            do
            {
              if (msg_callback_arg < 2)
                break;
              if ((msg_callback_arg & 0xFFFFFFFFFFFFFFFELL) == 2)
                break;
              v137 = msg_callback_arg - 4;
              v138 = __rev16(*((unsigned __int16 *)msg_callback + 1));
              if (v137 < v138)
                break;
              if (__rev16(*(unsigned __int16 *)msg_callback) == 45)
              {
                LODWORD(v274[0]) = 0;
                if ((bssl::ssl_ext_pre_shared_key_parse_clienthello((uint64_t)this, (unsigned __int16 **)&ses.verify_mode, &ses.stats.sess_connect_good, v274, &ses.get_session_cb, (uint64_t)&ses.rsa_md5, (unint64_t *)&ses.app_verify_arg) & 1) != 0)
                {
                  if ((*((_BYTE *)this + 1568) & 0x10) == 0)
                  {
                    v33 = 0;
                    v32 = 1;
LABEL_53:
                    if ((bssl::ssl_get_new_session(this, a2) & 1) == 0)
                    {
LABEL_478:
                      bssl::ssl_send_alert((bssl *)v21, (ssl_st *)2, 80);
                      v7 = 0;
                      if (!v33)
                        goto LABEL_501;
                      goto LABEL_481;
                    }
LABEL_54:
                    if ((bssl::ssl_negotiate_alps(this, (char *)&ses.get_session_cb, (uint64_t)&ses.rsa_md5) & 1) != 0)
                    {
                      *(_QWORD *)(*((_QWORD *)this + 188) + 200) = *((_QWORD *)this + 192);
                      v34 = *((_QWORD *)this + 1);
                      v35 = *(_QWORD *)(v34 + 104);
                      if (v35)
                      {
                        v36 = *(__int16 **)(v34 + 96);
                        v37 = *((_QWORD *)this + 188);
                        v38 = *(_QWORD *)this;
                        v39 = (__int16 *)*((_QWORD *)this + 81);
                        v40 = *((_QWORD *)this + 82);
                        if ((*(_BYTE *)(*(_QWORD *)this + 130) & 0x40) == 0)
                        {
LABEL_57:
                          if (v40)
                          {
                            v41 = &v39[v40];
                            v42 = v36;
                            v43 = &v36[v35];
                            goto LABEL_333;
                          }
LABEL_344:
                          ERR_put_error(16, 0, 266, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 466);
                          bssl::ssl_send_alert((bssl *)v21, (ssl_st *)2, 40);
                          v7 = 0;
                          if (!v33)
                            goto LABEL_501;
LABEL_481:
                          for (i = atomic_load((unsigned int *)v33); ; i = v205)
                          {
                            if (i == -1)
                              goto LABEL_501;
                            if (!i)
                              break;
                            v205 = __ldaxr((unsigned int *)v33);
                            if (v205 == i)
                            {
                              if (!__stlxr(i - 1, (unsigned int *)v33))
                              {
                                if (i != 1)
                                  goto LABEL_501;
                                ssl_session_st::~ssl_session_st((ssl_session_st *)v33);
                                ssl_ctx_callback_ctrl = v33[-1].ssl_ctx_callback_ctrl;
                                p_ssl_ctx_callback_ctrl = &v33[-1].ssl_ctx_callback_ctrl;
                                v208 = (size_t)ssl_ctx_callback_ctrl + 8;
                                if (ssl_ctx_callback_ctrl != (uint64_t (__cdecl *)(SSL_CTX *, int, void (*)(void)))-8)
                                  bzero(p_ssl_ctx_callback_ctrl, v208);
                                free(p_ssl_ctx_callback_ctrl);
                                if (*((_DWORD *)this + 6) != v6)
                                  goto LABEL_502;
                                goto LABEL_3;
                              }
                            }
                            else
                            {
                              __clrex();
                            }
                          }
LABEL_597:
                          abort();
                        }
                      }
                      else
                      {
                        v35 = 3;
                        v36 = &bssl::kDefaultGroups;
                        v37 = *((_QWORD *)this + 188);
                        v38 = *(_QWORD *)this;
                        v39 = (__int16 *)*((_QWORD *)this + 81);
                        v40 = *((_QWORD *)this + 82);
                        if ((*(_BYTE *)(*(_QWORD *)this + 130) & 0x40) == 0)
                          goto LABEL_57;
                      }
                      if (!v40)
                        goto LABEL_344;
                      v43 = &v39[v40];
                      v42 = v39;
                      v39 = v36;
                      v41 = &v36[v35];
LABEL_333:
                      while (1)
                      {
                        v139 = *v39;
                        v140 = v42;
                        v141 = v42;
                        if (*v39 != 25497)
                          break;
                        do
                        {
                          if (*v141 == 25497 && *(_WORD *)(v38 + 16) == 772)
                          {
                            v139 = 25497;
                            goto LABEL_341;
                          }
                          ++v141;
                        }
                        while (v141 != v43);
LABEL_332:
                        if (++v39 == v41)
                          goto LABEL_344;
                      }
                      while ((unsigned __int16)*v140 != v139)
                      {
                        if (++v140 == v43)
                          goto LABEL_332;
                      }
LABEL_341:
                      *(_WORD *)(v37 + 6) = v139;
                      LOBYTE(ses.app_verify_arg) = 0;
                      if ((bssl::ssl_ext_key_share_parse_clienthello((uint64_t)this, (BOOL *)&ses.app_verify_arg, 0, &ses.get_session_cb, (uint64_t)&ses.rsa_md5) & 1) != 0)
                      {
                        v263 = v4;
                        if ((*(_BYTE *)(v21 + 164) & 4) == 0)
                        {
                          v142 = v5;
                          v143 = *(_QWORD *)(v21 + 48);
                          v144 = 1;
                          goto LABEL_384;
                        }
                        if ((v32 & 1) != 0)
                        {
                          if (!v33)
                          {
                            v142 = v5;
                            v143 = *(_QWORD *)(v21 + 48);
                            *(_DWORD *)(v143 + 256) = 6;
                            goto LABEL_385;
                          }
                          if (!HIDWORD(v33[1].ssl_ctx_ctrl))
                          {
                            v142 = v5;
                            v143 = *(_QWORD *)(v21 + 48);
                            *(_DWORD *)(v143 + 256) = 7;
                            goto LABEL_385;
                          }
                          v150 = *((_DWORD *)this + 392);
                          if ((v150 & 0x800) == 0)
                          {
                            v142 = v5;
                            v143 = *(_QWORD *)(v21 + 48);
                            v144 = 4;
                            goto LABEL_384;
                          }
                          v143 = *(_QWORD *)(v21 + 48);
                          v142 = v5;
                          if ((v150 & 0x800000) == 0)
                          {
                            v187 = *(_QWORD *)(v143 + 496);
                            if ((int (__cdecl *)(const SSL_CIPHER *, unsigned __int8 *))v187 != v33[1].put_cipher_by_char
                              || memcmp(*(const void **)(v143 + 488), v33[1].get_cipher_by_char, v187))
                            {
                              *(_DWORD *)(v143 + 256) = 9;
                              goto LABEL_385;
                            }
                            v210 = *((_QWORD *)this + 188);
                            get_timeout_low = LOBYTE(v33[1].get_timeout);
                            if (((get_timeout_low ^ *(unsigned __int8 *)(v210 + 424)) & 0x40) != 0
                              || (v212 = *(_QWORD *)(v210 + 400), (int (*)(void))v212 != v33[1].num_ciphers)
                              || memcmp(*(const void **)(v210 + 392), v33[1].ssl_pending, v212))
                            {
                              *(_DWORD *)(v143 + 256) = 14;
                              goto LABEL_385;
                            }
                            if ((*(_DWORD *)(v143 + 252) - 61) <= 0xFFFFFF86)
                            {
                              v231 = 12;
                              goto LABEL_595;
                            }
                            if ((get_timeout_low & 0x20) == 0)
                            {
LABEL_554:
                              if (LOBYTE(ses.app_verify_arg))
                              {
                                *(_DWORD *)(v143 + 256) = 2;
                                *(_WORD *)(v143 + 220) |= 0x400u;
                                v143 = *(_QWORD *)(v21 + 48);
                              }
                              else
                              {
                                *(_DWORD *)(v143 + 256) = 8;
                              }
                              goto LABEL_385;
                            }
                            ssl_version = (unint64_t)v33[1].ssl_version;
                            if (ssl_version)
                            {
                              v233 = *((_QWORD *)this + 1);
                              if (*(_QWORD *)(v233 + 184) == ssl_version)
                              {
                                v234 = *(int8x16_t **)(v233 + 176);
                                ssl3_enc = v33[1].ssl3_enc;
                                if (ssl_version < 8)
                                {
                                  v236 = 0;
                                  v237 = 0;
                                  goto LABEL_591;
                                }
                                if (ssl_version >= 0x20)
                                {
                                  v236 = ssl_version & 0xFFFFFFFFFFFFFFE0;
                                  v240 = v234 + 1;
                                  v241 = (int8x16_t *)((char *)ssl3_enc + 16);
                                  v242 = 0uLL;
                                  v243 = ssl_version & 0xFFFFFFFFFFFFFFE0;
                                  v244 = 0uLL;
                                  do
                                  {
                                    v242 = vorrq_s8(veorq_s8(v241[-1], v240[-1]), v242);
                                    v244 = vorrq_s8(veorq_s8(*v241, *v240), v244);
                                    v240 += 2;
                                    v241 += 2;
                                    v243 -= 32;
                                  }
                                  while (v243);
                                  v245 = vorrq_s8(v244, v242);
                                  *(int8x8_t *)v245.i8 = vorr_s8(*(int8x8_t *)v245.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v245, v245, 8uLL));
                                  v246 = v245.i64[0] | HIDWORD(v245.i64[0]) | ((unint64_t)(v245.i64[0] | HIDWORD(v245.i64[0])) >> 16);
                                  v237 = v246 | BYTE1(v246);
                                  if (ssl_version != v236)
                                  {
                                    if ((ssl_version & 0x18) == 0)
                                      goto LABEL_591;
                                    goto LABEL_588;
                                  }
                                }
                                else
                                {
                                  v237 = 0;
                                  v236 = 0;
LABEL_588:
                                  v247 = v236;
                                  v236 = ssl_version & 0xFFFFFFFFFFFFFFF8;
                                  v248 = (int8x8_t)v237;
                                  v249 = (int8x8_t *)&v234->i8[v247];
                                  v250 = (int8x8_t *)((char *)ssl3_enc + v247);
                                  v251 = v247 - (ssl_version & 0xFFFFFFFFFFFFFFF8);
                                  do
                                  {
                                    v252 = *v249++;
                                    v253 = v252;
                                    v254 = *v250++;
                                    v248 = vorr_s8(veor_s8(v254, v253), v248);
                                    v251 += 8;
                                  }
                                  while (v251);
                                  v255 = *(_QWORD *)&v248 | HIDWORD(*(_QWORD *)&v248) | ((*(_QWORD *)&v248 | HIDWORD(*(_QWORD *)&v248)) >> 16);
                                  v237 = v255 | BYTE1(v255);
                                  if (ssl_version != v236)
                                  {
LABEL_591:
                                    v256 = ssl_version - v236;
                                    v257 = (char *)ssl3_enc + v236;
                                    v258 = &v234->i8[v236];
                                    do
                                    {
                                      v260 = *v258++;
                                      v259 = v260;
                                      v261 = *v257++;
                                      v237 |= v261 ^ v259;
                                      --v256;
                                    }
                                    while (v256);
                                  }
                                }
                                if (!v237)
                                  goto LABEL_554;
                              }
                            }
                            v231 = 13;
LABEL_595:
                            *(_DWORD *)(v143 + 256) = v231;
LABEL_385:
                            v152 = *((_QWORD *)this + 188);
                            v153 = *(const void **)(v143 + 488);
                            v154 = *(_QWORD *)(v143 + 496);
                            OPENSSL_free(*(_QWORD **)(v152 + 376));
                            *(_QWORD *)(v152 + 376) = 0;
                            *(_QWORD *)(v152 + 384) = 0;
                            if (v154)
                            {
                              v156 = OPENSSL_malloc(v154);
                              *(_QWORD *)(v152 + 376) = v156;
                              if (v156)
                              {
                                *(_QWORD *)(v152 + 384) = v154;
                                memmove(v156, v153, v154);
                                goto LABEL_388;
                              }
LABEL_402:
                              bssl::ssl_send_alert((bssl *)v21, (ssl_st *)2, 80);
                              v7 = 0;
                              v4 = v263;
LABEL_437:
                              v5 = v142;
                              if (!v33)
                                goto LABEL_501;
                              goto LABEL_481;
                            }
LABEL_388:
                            if ((*(_WORD *)(*(_QWORD *)(v21 + 48) + 220) & 0x400) != 0)
                            {
                              v157 = *((_QWORD *)this + 188);
                              if ((*(_BYTE *)(v157 + 424) & 0x40) != 0)
                              {
                                get_cipher = v33[1].get_cipher;
                                get_ssl_method = (unint64_t)v33[1].get_ssl_method;
                                OPENSSL_free(*(_QWORD **)(v157 + 408));
                                *(_QWORD *)(v157 + 408) = 0;
                                *(_QWORD *)(v157 + 416) = 0;
                                if (get_ssl_method)
                                {
                                  v160 = OPENSSL_malloc(get_ssl_method);
                                  *(_QWORD *)(v157 + 408) = v160;
                                  if (!v160)
                                    goto LABEL_402;
                                  *(_QWORD *)(v157 + 416) = get_ssl_method;
                                  memmove(v160, get_cipher, get_ssl_method);
                                }
                              }
                            }
                            if ((*(_BYTE *)(v21 + 164) & 4) != 0)
                            {
                              if (*(_QWORD *)(v21 + 152))
                              {
                                v161 = *((_QWORD *)this + 188);
                                v162 = *((_QWORD *)this + 1);
                                v163 = *(const void **)(v162 + 176);
                                v164 = *(_QWORD *)(v162 + 184);
                                OPENSSL_free(*(_QWORD **)(v161 + 432));
                                *(_QWORD *)(v161 + 432) = 0;
                                *(_QWORD *)(v161 + 440) = 0;
                                if (v164)
                                {
                                  v165 = OPENSSL_malloc(v164);
                                  *(_QWORD *)(v161 + 432) = v165;
                                  if (!v165)
                                    goto LABEL_402;
                                  *(_QWORD *)(v161 + 440) = v164;
                                  memmove(v165, v163, v164);
                                }
                              }
                            }
                            v166 = *(unsigned int (**)(const EVP_MD **))(*(_QWORD *)(v21 + 104) + 480);
                            v4 = v263;
                            if (v166 && !v166(&ses.rsa_md5))
                            {
                              ERR_put_error(16, 0, 133, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 549);
                              bssl::ssl_send_alert((bssl *)v21, (ssl_st *)2, 80);
                              v7 = 0;
                              goto LABEL_437;
                            }
                            v167 = (bssl *)bssl::ssl_protocol_version((bssl *)v21, v155);
                            handshake_digest = bssl::ssl_get_handshake_digest(v167, *((_QWORD *)this + 192), v168);
                            v5 = v142;
                            if ((*(_WORD *)(*(_QWORD *)(v21 + 48) + 220) & 0x40) != 0)
                            {
                              v172 = *((_QWORD *)this + 188);
                              v171 = (const unsigned __int8 *)(v172 + 11);
                              v170 = *(unsigned __int8 *)(v172 + 10);
                            }
                            else
                            {
                              v170 = *((unsigned int *)handshake_digest + 1);
                              v171 = bssl::kZeroes;
                            }
                            if (bssl::tls13_init_key_schedule((uint64_t)this, v171, v170)
                              && bssl::ssl_hash_message((uint64_t)this, (uint64_t)&ses.generate_session_id))
                            {
                              v173 = *(_QWORD *)(v21 + 48);
                              if ((*(_WORD *)(v173 + 220) & 0x400) == 0)
                              {
                                if ((*((_BYTE *)this + 1569) & 8) != 0)
                                  *(_WORD *)(v173 + 220) |= 1u;
                                goto LABEL_445;
                              }
                              if ((bssl::tls13_derive_early_secret(this, a2) & 1) != 0)
                              {
LABEL_445:
                                if (LOBYTE(ses.app_verify_arg))
                                {
                                  if (bssl::resolve_ecdhe_secret((uint64_t)this, (uint64_t)&ses.rsa_md5))
                                  {
                                    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 32))(v21);
                                    OPENSSL_free(*((_QWORD **)this + 73));
                                    *v266 = 0;
                                    v266[1] = 0;
                                    v7 = 1;
                                    *((_DWORD *)this + 6) = 4;
                                    if (!v33)
                                      goto LABEL_501;
                                    goto LABEL_481;
                                  }
                                }
                                else
                                {
                                  (*(void (**)(uint64_t))(*(_QWORD *)v21 + 32))(v21);
                                  if (bssl::SSLTranscript::UpdateForHelloRetryRequest((bssl::SSLTranscript *)v272))
                                  {
                                    *((_DWORD *)this + 6) = 2;
                                    v7 = 1;
                                    if (!v33)
                                      goto LABEL_501;
                                    goto LABEL_481;
                                  }
                                }
                              }
                            }
                            v7 = 0;
                            if (!v33)
                              goto LABEL_501;
                            goto LABEL_481;
                          }
                          v144 = 10;
                        }
                        else
                        {
                          v142 = v5;
                          v143 = *(_QWORD *)(v21 + 48);
                          v144 = 5;
                        }
LABEL_384:
                        *(_DWORD *)(v143 + 256) = v144;
                        goto LABEL_385;
                      }
                    }
LABEL_480:
                    bssl::ssl_send_alert((bssl *)v21, (ssl_st *)2, LOBYTE(ses.get_session_cb));
                    v7 = 0;
                    if (!v33)
                      goto LABEL_501;
                    goto LABEL_481;
                  }
                  LOBYTE(ses.ex_data.sk) = 0;
                  ses.method = 0;
                  v185 = bssl::ssl_process_ticket((uint64_t *)this, &ses, &ses.ex_data, *(void **)&ses.verify_mode, *(unint64_t *)ses.sid_ctx, 0, 0);
                  if (v185)
                  {
                    v186 = v185;
                    v33 = 0;
                    if (v185 == 3)
                      LOBYTE(ses.get_session_cb) = 80;
LABEL_469:
                    method = ses.method;
                    ses.method = 0;
                    if (method)
LABEL_470:
                      SSL_SESSION_free((SSL_SESSION *)method);
                    v32 = 1;
                    switch(v186)
                    {
                      case 0:
                        bssl::SSL_SESSION_dup((bssl *)v33, 0, (ssl_session_st **)&ses.app_verify_arg);
                        v201 = ses.app_verify_arg;
                        ses.app_verify_arg = 0;
                        v202 = (SSL_SESSION *)*((_QWORD *)this + 188);
                        *((_QWORD *)this + 188) = v201;
                        if (v202)
                        {
                          SSL_SESSION_free(v202);
                          v203 = (SSL_SESSION *)ses.app_verify_arg;
                          ses.app_verify_arg = 0;
                          if (v203)
                            SSL_SESSION_free(v203);
                          v201 = (void *)*((_QWORD *)this + 188);
                        }
                        if (!v201)
                          goto LABEL_478;
                        *(_WORD *)(*(_QWORD *)(v21 + 48) + 220) |= 0x40u;
                        *((_DWORD *)this + 392) |= 0x400000u;
                        bssl::ssl_session_renew_timeout((bssl *)v21, *((ssl_st **)this + 188), (ssl_session_st *)*(unsigned int *)(*(_QWORD *)(v21 + 112) + 300));
                        break;
                      case 1:
                        *((_DWORD *)this + 6) = 1;
                        v7 = 11;
                        if (!v33)
                          goto LABEL_501;
                        goto LABEL_481;
                      case 2:
                        goto LABEL_53;
                      case 3:
                        goto LABEL_480;
                      default:
                        goto LABEL_54;
                    }
                    goto LABEL_54;
                  }
                  if (bssl::ssl_session_is_resumable(this, (uint64_t)ses.method))
                  {
                    method = ses.method;
                    if (((uint64_t)ses.method[1].get_timeout & 8) == 0)
                    {
                      v33 = 0;
                      ses.method = 0;
                      v186 = 2;
                      goto LABEL_470;
                    }
                    LODWORD(v274[0]) = (LODWORD(v274[0]) - LODWORD(ses.method[1].ssl_ctx_ctrl)) / 0x3E8u;
                    bssl::ssl_get_current_time(v24, (uint64_t)&ses.session_cache_head);
                    a2 = (bssl::SSL_HANDSHAKE *)ses.method;
                    v200 = (char *)ses.session_cache_head - (char *)ses.method->get_timeout;
                    if (!(v200 >> 31))
                    {
                      *(_DWORD *)(v23 + 252) = LODWORD(v274[0]) - v200;
                      if ((bssl::tls13_verify_psk_binder((uint64_t)this, (uint64_t)a2, (uint64_t)&ses.generate_session_id, (uint64_t *)&ses.stats.sess_connect_good, v189, v190, v191, v192, v193, v194, v195, v196, v197, v198, v199) & 1) != 0)
                      {
                        v186 = 0;
                        v33 = ses.method;
                        ses.method = 0;
                      }
                      else
                      {
                        v33 = 0;
                        LOBYTE(ses.get_session_cb) = 51;
                        v186 = 3;
                      }
                      goto LABEL_469;
                    }
                  }
                  v33 = 0;
                  v186 = 2;
                  goto LABEL_469;
                }
LABEL_319:
                v33 = 0;
                goto LABEL_480;
              }
              msg_callback = (void (__cdecl *)(int, int, int, const void *, size_t, SSL *, void *))((char *)msg_callback
                                                                                                  + v138
                                                                                                  + 4);
              msg_callback_arg = v137 - v138;
            }
            while (msg_callback_arg);
            LOBYTE(ses.get_session_cb) = 109;
            ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 322);
            goto LABEL_319;
          }
          v27 = (void (__cdecl *)(int, int, int, const void *, size_t, SSL *, void *))((char *)v29 + (_QWORD)v30);
          v26 = v28 - (_QWORD)v29;
        }
        while (v26);
LABEL_52:
        v32 = 0;
        v33 = 0;
        goto LABEL_53;
      case 2:
        if ((*((_BYTE *)this + 1570) & 8) != 0)
          goto LABEL_99;
        v44 = *(_QWORD *)this;
        memset(&ses.rsa_md5, 0, 48);
        if (!(*(unsigned int (**)(uint64_t, const EVP_MD **, GEN_SESSION_CB *, uint64_t))(*(_QWORD *)v44 + 88))(v44, &ses.rsa_md5, &ses.generate_session_id, 2))goto LABEL_498;
        ses.app_verify_arg = 0;
        if (!CBB_add_space((uint64_t)&ses.generate_session_id, &ses.app_verify_arg, 2))
          goto LABEL_498;
        *((_BYTE *)ses.app_verify_arg + 1) = 3;
        *(_BYTE *)ses.app_verify_arg = 3;
        ses.app_verify_arg = 0;
        if (!CBB_add_space((uint64_t)&ses.generate_session_id, &ses.app_verify_arg, 32))
          goto LABEL_498;
        v45 = ses.app_verify_arg;
        *(_OWORD *)ses.app_verify_arg = bssl::kHelloRetryRequest;
        v45[1] = *(_OWORD *)&qword_208F30CF0;
        if (!CBB_flush((uint64_t *)&ses.generate_session_id))
          goto LABEL_498;
        if (!cbb_add_child((uint64_t)&ses.generate_session_id, (uint64_t)&ses.app_verify_arg, 1u, 0))
          goto LABEL_498;
        v46 = *((unsigned __int8 *)this + 1613);
        *(_QWORD *)&ses.verify_mode = 0;
        if (!CBB_add_space((uint64_t)&ses.app_verify_arg, &ses.verify_mode, v46))
          goto LABEL_498;
        if ((_DWORD)v46)
          memcpy(*(void **)&ses.verify_mode, __dst, v46);
        v47 = *(_DWORD *)(*((_QWORD *)this + 192) + 16);
        *(_QWORD *)&ses.verify_mode = 0;
        if (CBB_add_space((uint64_t)&ses.generate_session_id, &ses.verify_mode, 2)
          && (*(_BYTE *)(*(_QWORD *)&ses.verify_mode + 1) = v47,
              **(_BYTE **)&ses.verify_mode = BYTE1(v47),
              *(_QWORD *)&ses.verify_mode = 0,
              CBB_add_space((uint64_t)&ses.generate_session_id, &ses.verify_mode, 1))
          && (**(_BYTE **)&ses.verify_mode = 0,
              CBB_add_u16_length_prefixed((uint64_t *)&ses.generate_session_id, (uint64_t)&ses.verify_mode))
          && CBB_add_u16((uint64_t)&ses.verify_mode, 43)
          && CBB_add_u16((uint64_t)&ses.verify_mode, 2)
          && CBB_add_u16((uint64_t)&ses.verify_mode, *(_WORD *)(v44 + 16))
          && CBB_add_u16((uint64_t)&ses.verify_mode, 51)
          && CBB_add_u16((uint64_t)&ses.verify_mode, 2)
          && CBB_add_u16((uint64_t)&ses.verify_mode, *(_WORD *)(*((_QWORD *)this + 188) + 6))
          && ((*((_BYTE *)this + 1568) & 1) == 0
           || CBB_add_u16((uint64_t)&ses.verify_mode, 65037)
           && CBB_add_u16((uint64_t)&ses.verify_mode, 8)
           && CBB_add_zeros((uint64_t)&ses.verify_mode, 8uLL)))
        {
          *(_QWORD *)&ses.stats.sess_connect_good = 0;
          *(_QWORD *)&ses.stats.sess_accept_renegotiate = 0;
          if (!(*(unsigned int (**)(uint64_t, const EVP_MD **, int *))(*(_QWORD *)v44 + 96))(v44, &ses.rsa_md5, &ses.stats.sess_connect_good))goto LABEL_509;
          if ((*((_BYTE *)this + 1568) & 1) == 0)
            goto LABEL_82;
          if (*(_QWORD *)&ses.stats.sess_accept_renegotiate <= 7uLL)
            goto LABEL_597;
          if (bssl::ssl_ech_accept_confirmation((int)this, *(_QWORD *)&ses.stats.sess_accept_renegotiate - 8 + *(_QWORD *)&ses.stats.sess_connect_good, 8, (const unsigned __int8 *)(*(_QWORD *)(v44 + 48) + 48), 0x20uLL, (bssl::SSLTranscript *)v272, 1, v48, *(uint64_t *)&ses.stats.sess_connect_good, *(unint64_t *)&ses.stats.sess_accept_renegotiate, *(_QWORD *)&ses.stats.sess_accept_renegotiate - 8))
          {
LABEL_82:
            v49 = *(unsigned int (**)(uint64_t, ssl_session_st **))(*(_QWORD *)v44 + 104);
            ses.session_cache_head = *(ssl_session_st **)&ses.stats.sess_connect_good;
            ses.session_cache_tail = *(ssl_session_st **)&ses.stats.sess_accept_renegotiate;
            *(_QWORD *)&ses.stats.sess_connect_good = 0;
            *(_QWORD *)&ses.stats.sess_accept_renegotiate = 0;
            if (v49(v44, &ses.session_cache_head))
            {
              v50 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v44 + 112))(v44);
              OPENSSL_free(&ses.session_cache_head->ssl_version);
              ses.session_cache_head = 0;
              ses.session_cache_tail = 0;
              if ((v50 & 1) != 0)
              {
                *(_WORD *)(*(_QWORD *)(v44 + 48) + 220) |= 0x2000u;
                *((_DWORD *)this + 6) = 3;
                v7 = 4;
              }
              else
              {
                v7 = 0;
              }
            }
            else
            {
              OPENSSL_free(&ses.session_cache_head->ssl_version);
              v7 = 0;
              ses.session_cache_head = 0;
              ses.session_cache_tail = 0;
            }
          }
          else
          {
LABEL_509:
            v7 = 0;
          }
          OPENSSL_free(*(_QWORD **)&ses.stats.sess_connect_good);
          if (LOBYTE(ses.md5))
            goto LABEL_501;
        }
        else
        {
LABEL_498:
          v7 = 0;
          if (LOBYTE(ses.md5))
            goto LABEL_501;
        }
        if (((uint64_t)ses.info_callback & 1) == 0)
          goto LABEL_501;
        app_verify_arg = &ses.sha1->type;
        if (!ses.sha1)
          goto LABEL_501;
        goto LABEL_261;
      case 3:
        v8 = *(_QWORD *)this;
        if (!(*(unsigned int (**)(_QWORD, GEN_SESSION_CB *))(**(_QWORD **)this + 24))(*(_QWORD *)this, &ses.generate_session_id))goto LABEL_295;
        if (BYTE1(ses.generate_session_id) != 1)
        {
          bssl::ssl_send_alert((bssl *)v8, (ssl_st *)2, 10);
          ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/handshake.cc", 211);
          v132 = BYTE1(ses.generate_session_id);
LABEL_365:
          ERR_add_error_dataf("got type %d, wanted type %d", v125, v126, v127, v128, v129, v130, v131, v132);
          v7 = 0;
          if (*((_DWORD *)this + 6) != v6)
            goto LABEL_502;
          goto LABEL_3;
        }
        ses.app_verify_arg = ses.param;
        ses.default_passwd_callback = *(pem_password_cb **)&ses.quiet_shutdown;
        if (!bssl::ssl_parse_client_hello_with_trailing_data(v8, (unint64_t *)&ses.app_verify_arg, (uint64_t)&ses.rsa_md5)|| ses.default_passwd_callback)
        {
          v133 = 131;
          v134 = 662;
LABEL_321:
          ERR_put_error(16, 0, v133, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", v134);
          v64 = (bssl *)v8;
          method_low = 50;
          goto LABEL_322;
        }
        v58 = *(_QWORD *)(v8 + 48);
        if (*(_DWORD *)(v58 + 216) != 1)
          goto LABEL_520;
        v59 = (unint64_t)ses.msg_callback_arg;
        if (!ses.msg_callback_arg)
        {
LABEL_125:
          ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 673);
          v64 = (bssl *)v8;
          method_low = 109;
          goto LABEL_322;
        }
        v60 = ses.msg_callback;
        while (1)
        {
          if (v59 < 2)
            goto LABEL_125;
          if ((v59 & 0xFFFFFFFFFFFFFFFELL) == 2)
            goto LABEL_125;
          v61 = v59 - 4;
          v62 = __rev16(*((unsigned __int16 *)v60 + 1));
          if (v61 < v62)
            goto LABEL_125;
          v63 = (unsigned __int8 *)v60 + 4;
          if (__rev16(*(unsigned __int16 *)v60) == 65037)
            break;
          v60 = (void (__cdecl *)(int, int, int, const void *, size_t, SSL *, void *))&v63[v62];
          v59 = v61 - v62;
          if (!v59)
            goto LABEL_125;
        }
        if (!v62
          || ((v174 = *v63, v62 >= 3) ? (v175 = v174 == 0) : (v175 = 0),
              !v175
           || v62 - 3 < 2
           || v62 == 5
           || (v62 & 0xFFFE) == 6
           || (v176 = v62 - 8,
               v177 = __rev16(*((unsigned __int16 *)v60 + 5)),
               v178 = v176 >= v177,
               v179 = v176 - v177,
               !v178)
           || v179 < 2))
        {
          v180 = 50;
          v181 = 688;
LABEL_422:
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", v181);
          v64 = (bssl *)v8;
          method_low = v180;
          goto LABEL_322;
        }
        v213 = __rev16(*(unsigned __int16 *)((char *)v60 + v177 + 12));
        if (v179 - 2 != v213)
        {
          v180 = 50;
          v181 = 688;
          goto LABEL_422;
        }
        if (__rev16(*(unsigned __int16 *)((char *)v60 + 5)) != **((unsigned __int16 **)this + 92)
          || __rev16(*(unsigned __int16 *)((char *)v60 + 7)) != **((unsigned __int16 **)this + 91))
        {
          v180 = 47;
          v181 = 697;
          goto LABEL_422;
        }
        v180 = 47;
        v181 = 697;
        if (v177 || *((unsigned __int8 *)v60 + 9) != *((unsigned __int8 *)this + 1580))
          goto LABEL_422;
        LOBYTE(ses.app_verify_arg) = 50;
        if ((bssl::ssl_client_hello_decrypt((int8x16_t *)this, &ses.app_verify_arg, &ses.verify_mode, v266, &ses.rsa_md5, (char *)v60 + v177 + 14, v213) & 1) != 0)
        {
          if ((bssl::SSL_HANDSHAKE::GetClientHello((uint64_t)this, (uint64_t)&ses.generate_session_id, (uint64_t)&ses.rsa_md5) & 1) != 0)
          {
            v58 = *(_QWORD *)(v8 + 48);
LABEL_520:
            if ((*(_WORD *)(v58 + 220) & 0x40) == 0)
            {
LABEL_521:
              if (bssl::resolve_ecdhe_secret((uint64_t)this, (uint64_t)&ses.rsa_md5)
                && bssl::ssl_hash_message((uint64_t)this, (uint64_t)&ses.generate_session_id))
              {
                if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8))
                {
                  bssl::ssl_send_alert((bssl *)v8, (ssl_st *)2, 10);
                  ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 767);
                  v7 = 0;
                  if (*((_DWORD *)this + 6) != v6)
                    goto LABEL_502;
                }
                else
                {
                  (*(void (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
                  OPENSSL_free(*((_QWORD **)this + 73));
                  *v266 = 0;
                  v266[1] = 0;
                  v7 = 1;
                  *((_DWORD *)this + 6) = 4;
                  if (v6 != 4)
                    goto LABEL_502;
                }
              }
              else
              {
LABEL_526:
                v7 = 0;
                if (*((_DWORD *)this + 6) != v6)
                  goto LABEL_502;
              }
              goto LABEL_3;
            }
            v214 = (unint64_t)ses.msg_callback_arg;
            if (ses.msg_callback_arg)
            {
              v215 = ses.msg_callback;
              while (1)
              {
                if (v214 < 2)
                  goto LABEL_535;
                if ((v214 & 0xFFFFFFFFFFFFFFFELL) == 2)
                  goto LABEL_535;
                v216 = v214 - 4;
                v217 = (pem_password_cb *)__rev16(*((unsigned __int16 *)v215 + 1));
                if (v216 < (unint64_t)v217)
                  goto LABEL_535;
                v219 = *(unsigned __int16 *)v215;
                v218 = (char *)v215 + 4;
                if (__rev16(v219) == 41)
                  break;
                v215 = (void (__cdecl *)(int, int, int, const void *, size_t, SSL *, void *))((char *)v217 + (_QWORD)v218);
                v214 = v216 - (_QWORD)v217;
                if (!v214)
                  goto LABEL_535;
              }
              ses.app_verify_arg = v218;
              ses.default_passwd_callback = v217;
              LODWORD(ses.session_cache_head) = 0;
              LOBYTE(ses.method) = 50;
              if ((bssl::ssl_ext_pre_shared_key_parse_clienthello((uint64_t)this, (unsigned __int16 **)&ses.verify_mode, &ses.stats.sess_connect_good, &ses.session_cache_head, &ses, (uint64_t)&ses.rsa_md5, (unint64_t *)&ses.app_verify_arg) & 1) != 0)
              {
                if ((bssl::tls13_verify_psk_binder((uint64_t)this, *((_QWORD *)this + 188), (uint64_t)&ses.generate_session_id, (uint64_t *)&ses.stats.sess_connect_good, v220, v221, v222, v223, v224, v225, v226, v227, v228, v229, v230) & 1) != 0)goto LABEL_521;
                method_low = 51;
              }
              else
              {
                method_low = LOBYTE(ses.method);
              }
LABEL_542:
              v64 = (bssl *)v8;
            }
            else
            {
LABEL_535:
              v123 = 303;
              v124 = 732;
LABEL_287:
              ERR_put_error(16, 0, v123, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", v124);
              v64 = (bssl *)v8;
              method_low = 47;
            }
LABEL_322:
            bssl::ssl_send_alert(v64, (ssl_st *)2, method_low);
            v7 = 0;
            if (*((_DWORD *)this + 6) != v6)
              goto LABEL_502;
            goto LABEL_3;
          }
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 716);
        }
        else
        {
          ERR_put_error(16, 0, 138, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 709);
          bssl::ssl_send_alert((bssl *)v8, (ssl_st *)2, LOBYTE(ses.app_verify_arg));
        }
        v7 = 0;
        if (*((_DWORD *)this + 6) != v6)
          goto LABEL_502;
        goto LABEL_3;
      case 4:
        v66 = v5;
        v67 = *(_QWORD **)this;
        v68 = *(_QWORD *)(*(_QWORD *)this + 48);
        v69 = (__int128 *)(v68 + 16);
        v70 = *((_QWORD *)this + 195);
        if (v70)
        {
          if ((*((_BYTE *)this + 1570) & 8) != 0 || *(_QWORD *)(v70 + 24) != 32)
          {
            RAND_bytes_with_additional_data(v68 + 16, 0x20uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
            if ((*((_BYTE *)this + 1570) & 8) != 0)
            {
              v89 = v4;
              v91 = (_QWORD *)(v70 + 16);
              v90 = *(_QWORD *)(v70 + 16);
              if (v90)
              {
                v93 = *(_QWORD *)(v90 - 8);
                v92 = (void *)(v90 - 8);
                v94 = v93 + 8;
                if (v93 != -8)
                  bzero(v92, v94);
                free(v92);
              }
              *v91 = 0;
              *(_QWORD *)(v70 + 24) = 0;
              v95 = (char *)malloc_type_malloc(0x28uLL, 0x30772F57uLL);
              if (!v95)
              {
                ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
                v7 = 0;
                *v91 = 0;
                v4 = v89;
                v5 = v66;
                if (*((_DWORD *)this + 6) != v6)
                  goto LABEL_502;
                goto LABEL_3;
              }
              *(_QWORD *)v95 = 32;
              *(_QWORD *)(v70 + 16) = v95 + 8;
              *(_QWORD *)(v70 + 24) = 32;
              v96 = *v69;
              *(_OWORD *)(v95 + 24) = *(_OWORD *)(v68 + 32);
              *(_OWORD *)(v95 + 8) = v96;
              v4 = v89;
            }
          }
          else
          {
            v71 = *(__int128 **)(v70 + 16);
            v72 = v71[1];
            *v69 = *v71;
            *(_OWORD *)(v68 + 32) = v72;
          }
        }
        else
        {
          RAND_bytes_with_additional_data(v68 + 16, 0x20uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
        }
        ses.ex_data.sk = 0;
        *(_QWORD *)&ses.ex_data.dummy = 0;
        memset(&ses.generate_session_id, 0, 48);
        if ((*(unsigned int (**)(_QWORD *, GEN_SESSION_CB *, void **, uint64_t))(*v67 + 88))(v67, &ses.generate_session_id, &ses.app_verify_arg, 2))
        {
          ses.rsa_md5 = 0;
          v5 = v66;
          if (!CBB_add_space((uint64_t)&ses.app_verify_arg, &ses.rsa_md5, 2))
            goto LABEL_254;
          BYTE1(ses.rsa_md5->type) = 3;
          LOBYTE(ses.rsa_md5->type) = 3;
          v97 = v67[6];
          ses.rsa_md5 = 0;
          if (!CBB_add_space((uint64_t)&ses.app_verify_arg, &ses.rsa_md5, 32))
            goto LABEL_254;
          rsa_md5 = ses.rsa_md5;
          v99 = *(_OWORD *)(v97 + 32);
          *(_OWORD *)ses.rsa_md5 = *(_OWORD *)(v97 + 16);
          *(_OWORD *)&rsa_md5->flags = v99;
          if (!CBB_flush((uint64_t *)&ses.app_verify_arg))
            goto LABEL_254;
          if (!cbb_add_child((uint64_t)&ses.app_verify_arg, (uint64_t)&ses.stats.sess_connect_good, 1u, 0))
            goto LABEL_254;
          v100 = *((unsigned __int8 *)this + 1613);
          ses.rsa_md5 = 0;
          if (!CBB_add_space((uint64_t)&ses.stats.sess_connect_good, &ses.rsa_md5, v100))
            goto LABEL_254;
          if ((_DWORD)v100)
            memcpy((void *)ses.rsa_md5, __dst, v100);
          v101 = *(_DWORD *)(*((_QWORD *)this + 192) + 16);
          ses.rsa_md5 = 0;
          if (!CBB_add_space((uint64_t)&ses.app_verify_arg, &ses.rsa_md5, 2))
            goto LABEL_254;
          BYTE1(ses.rsa_md5->type) = v101;
          LOBYTE(ses.rsa_md5->type) = BYTE1(v101);
          ses.rsa_md5 = 0;
          if (!CBB_add_space((uint64_t)&ses.app_verify_arg, &ses.rsa_md5, 1))
            goto LABEL_254;
          LOBYTE(ses.rsa_md5->type) = 0;
          if (!CBB_flush((uint64_t *)&ses.app_verify_arg)
            || !cbb_add_child((uint64_t)&ses.app_verify_arg, (uint64_t)&ses.verify_mode, 2u, 0)
            || !bssl::ssl_ext_pre_shared_key_add_serverhello((uint64_t)this, (uint64_t *)&ses.verify_mode)
            || !bssl::ssl_ext_key_share_add_serverhello(this, (uint64_t *)&ses.verify_mode)
            || !CBB_add_u16((uint64_t)&ses.verify_mode, 43)
            || !CBB_add_u16_length_prefixed((uint64_t *)&ses.verify_mode, (uint64_t)&ses.rsa_md5)
            || !CBB_add_u16((uint64_t)&ses.rsa_md5, *(_WORD *)(*(_QWORD *)this + 16))
            || !CBB_flush((uint64_t *)&ses.verify_mode)
            || !(*(unsigned int (**)(_QWORD *, GEN_SESSION_CB *, CRYPTO_EX_DATA *))(*v67 + 96))(v67, &ses.generate_session_id, &ses.ex_data))
          {
            goto LABEL_254;
          }
          if ((*((_BYTE *)this + 1568) & 1) != 0)
          {
            if (*(_BYTE *)*v67)
              v103 = 38;
            else
              v103 = 30;
            v104 = (_QWORD *)(v68 + 40);
            v7 = 0;
            if (!bssl::ssl_ech_accept_confirmation((int)this, (uint64_t)v104, 8, (const unsigned __int8 *)(v67[6] + 48), 0x20uLL, (bssl::SSLTranscript *)v272, 0, v102, (uint64_t)ses.ex_data.sk, *(unint64_t *)&ses.ex_data.dummy, v103))
            {
LABEL_252:
              if (LOBYTE(ses.param))
                goto LABEL_260;
LABEL_255:
              if (((uint64_t)ses.tlsext_servername_arg & 1) != 0 && *(_QWORD *)&ses.quiet_shutdown)
              {
                v113 = (void *)(*(_QWORD *)&ses.quiet_shutdown - 8);
                v112 = *(_QWORD *)(*(_QWORD *)&ses.quiet_shutdown - 8);
                if (v112 != -8)
                  bzero(v113, v112 + 8);
                free(v113);
              }
LABEL_260:
              app_verify_arg = &ses.ex_data.sk->num;
              if (!ses.ex_data.sk)
                goto LABEL_501;
LABEL_261:
              v116 = *(app_verify_arg - 1);
              v115 = (char *)(app_verify_arg - 1);
              v117 = v116 + 8;
              if (v116 != -8)
                bzero(v115, v117);
              free(v115);
              if (*((_DWORD *)this + 6) != v6)
                goto LABEL_502;
              goto LABEL_3;
            }
            if (*(_QWORD *)&ses.ex_data.dummy < v103)
              goto LABEL_597;
            *(_QWORD *)((char *)&ses.ex_data.sk->num + v103) = *v104;
            v5 = v66;
          }
          v105 = *(uint64_t (**)(_QWORD *, SSL_SESSION *(__cdecl **)(ssl_st *, unsigned __int8 *, int, int *)))(*v67 + 104);
          *(CRYPTO_EX_DATA *)&ses.get_session_cb = ses.ex_data;
          ses.ex_data.sk = 0;
          *(_QWORD *)&ses.ex_data.dummy = 0;
          v106 = v105(v67, &ses.get_session_cb);
          OPENSSL_free((_QWORD *)ses.get_session_cb);
          ses.get_session_cb = 0;
          *(_QWORD *)&ses.stats.sess_connect = 0;
          if (!v106)
          {
LABEL_254:
            v7 = 0;
            if (LOBYTE(ses.param))
              goto LABEL_260;
            goto LABEL_255;
          }
          OPENSSL_free(*(_QWORD **)v265);
          *(_QWORD *)v265 = 0;
          *((_QWORD *)v265 + 1) = 0;
          if ((*(_BYTE *)(v67[6] + 221) & 0x20) == 0
            && !(*(unsigned int (**)(_QWORD *))(*v67 + 112))(v67)
            || !bssl::tls13_derive_handshake_secrets(this, a2)
            || !bssl::tls13_set_traffic_key((uint64_t)v67, 2, 1u, *((_QWORD *)this + 188), v264, *((_QWORD *)this + 4))|| !(*(unsigned int (**)(_QWORD *, GEN_SESSION_CB *, void **, uint64_t))(*v67 + 88))(v67, &ses.generate_session_id, &ses.app_verify_arg, 8)|| !bssl::ssl_add_serverhello_tlsext((uint64_t *)this, (uint64_t)&ses.app_verify_arg)|| !bssl::ssl_add_message_cbb((uint64_t)v67, (uint64_t)&ses.generate_session_id))
          {
            goto LABEL_582;
          }
          v107 = *((_DWORD *)this + 392);
          if ((*(_WORD *)(v67[6] + 220) & 0x40) == 0)
          {
            v108 = *((_QWORD *)this + 1);
            v109 = v107 & 0xFFFFFFDF;
            v10 = (v107 & 0x800000) == 0;
            v107 = v107 & 0xFFFFFFDF | (32 * (*(_BYTE *)(v108 + 236) & 1));
            *((_DWORD *)this + 392) = v107;
            v110 = *(_BYTE *)(v108 + 236) & 4;
            if (!v10 && v110 != 0)
              v107 = v109;
            *((_DWORD *)this + 392) = v107;
          }
          if ((v107 & 0x20) != 0)
          {
            if (!(*(unsigned int (**)(_QWORD *, GEN_SESSION_CB *, void **, uint64_t))(*v67 + 88))(v67, &ses.generate_session_id, &ses.app_verify_arg, 13))goto LABEL_582;
            v274[0] = 0;
            if (!CBB_add_space((uint64_t)&ses.app_verify_arg, v274, 1))
              goto LABEL_582;
            *(_BYTE *)v274[0] = 0;
            if (!CBB_add_u16_length_prefixed((uint64_t *)&ses.app_verify_arg, (uint64_t)&ses.rsa_md5)
              || !CBB_add_u16((uint64_t)&ses.rsa_md5, 13)
              || !CBB_add_u16_length_prefixed((uint64_t *)&ses.rsa_md5, (uint64_t)&ses.session_cache_head)
              || !CBB_add_u16_length_prefixed((uint64_t *)&ses.session_cache_head, (uint64_t)&ses)
              || !bssl::tls12_add_verify_sigalgs((uint64_t)this, (uint64_t)&ses))
            {
              goto LABEL_582;
            }
            v238 = (_QWORD *)*((_QWORD *)this + 1);
            v239 = (_QWORD *)v238[10];
            if ((v239 || (v239 = *(_QWORD **)(*(_QWORD *)(*v238 + 104) + 392)) != 0)
              && *v239
              && (!CBB_add_u16((uint64_t)&ses.rsa_md5, 47)
               || !CBB_add_u16_length_prefixed((uint64_t *)&ses.rsa_md5, (uint64_t)v274)
               || !bssl::ssl_add_client_CA_list(this, v274)
               || !CBB_flush((uint64_t *)&ses.rsa_md5)))
            {
              goto LABEL_582;
            }
            if (!bssl::ssl_add_message_cbb((uint64_t)v67, (uint64_t)&ses.generate_session_id))
              goto LABEL_582;
          }
          if ((*(_WORD *)(v67[6] + 220) & 0x40) != 0)
          {
            *((_DWORD *)this + 6) = 6;
            v7 = 1;
            goto LABEL_251;
          }
          if (bssl::tls13_add_certificate(this, a2))
          {
            *((_DWORD *)this + 6) = 5;
            v7 = 1;
          }
          else
          {
LABEL_582:
            v7 = 0;
          }
        }
        else
        {
          v7 = 0;
        }
LABEL_251:
        v5 = v66;
        goto LABEL_252;
      case 5:
        v51 = bssl::tls13_add_certificate_verify((bssl **)this, a2);
        if (v51)
        {
          if (v51 != 1)
            goto LABEL_526;
          v7 = 9;
          *((_DWORD *)this + 6) = 5;
          if (v6 == 5)
            goto LABEL_3;
        }
        else
        {
          *((_DWORD *)this + 6) = 6;
          if (v6 == 6)
            goto LABEL_3;
        }
        goto LABEL_502;
      case 6:
        v52 = *((_DWORD *)this + 392);
        if ((v52 & 0x80000) != 0)
        {
LABEL_99:
          v7 = 17;
          goto LABEL_3;
        }
        v53 = *(_QWORD *)this;
        *((_DWORD *)this + 392) = v52 | 0x400000;
        if (!bssl::tls13_add_finished(this, a2)
          || !bssl::tls13_advance_key_schedule((uint64_t)this, bssl::kZeroes, *(unsigned int *)(*((_QWORD *)this + 52) + 4))|| !bssl::tls13_derive_application_secrets(this, a2)|| !bssl::tls13_set_traffic_key(v53, 3, 1u, *((_QWORD *)this + 188), v268, *((_QWORD *)this + 4)))
        {
          goto LABEL_526;
        }
        *((_DWORD *)this + 6) = 7;
        if ((*((_BYTE *)this + 1570) & 4) != 0)
          v7 = 7;
        else
          v7 = 1;
        if (v6 != 7)
          goto LABEL_502;
        goto LABEL_3;
      case 7:
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x400) == 0)
          goto LABEL_42;
        if (*(_QWORD *)(*(_QWORD *)this + 152))
          goto LABEL_171;
        if (*v272
          && !BUF_MEM_append((unint64_t *)*v272, &bssl::do_send_half_rtt_ticket(bssl::SSL_HANDSHAKE *)::kEndOfEarlyData, 4uLL))
        {
          ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 967);
          v7 = 0;
          if (*((_DWORD *)this + 6) == v6)
            goto LABEL_3;
        }
        else
        {
          if (*(_QWORD *)v5)
            (*(void (**)(char *, void *, uint64_t))(*(_QWORD *)v5 + 24))(v5, &bssl::do_send_half_rtt_ticket(bssl::SSL_HANDSHAKE *)::kEndOfEarlyData, 4);
LABEL_171:
          v79 = *((_QWORD *)this + 4);
          ses.app_verify_arg = 0;
          if (!bssl::SSLTranscript::GetHash((bssl::SSLTranscript *)v272, (unsigned __int8 *)&ses.generate_session_id, (unint64_t *)&ses.app_verify_arg))goto LABEL_526;
          v80 = *(EVP_MD **)v5;
          v81 = ses.app_verify_arg;
          v82 = *(unsigned int *)(*(_QWORD *)v5 + 4);
          ses.verify_mode = 0;
          if (CRYPTO_tls13_hkdf_expand_label((uint64_t)&ses.rsa_md5, v82, v80, v273, v79, "finished", 8uLL, 0, 0) != 1|| !HMAC(v80, &ses.rsa_md5, v82, (const unsigned __int8 *)&ses.generate_session_id, (size_t)v81, md, (unsigned int *)&ses.verify_mode))
          {
            goto LABEL_526;
          }
          if (*((_QWORD *)this + 4) == ses.verify_mode)
          {
            LOWORD(ses.app_verify_arg) = 20;
            BYTE2(ses.app_verify_arg) = 0;
            BYTE3(ses.app_verify_arg) = ses.verify_mode;
            if (*v272 && !BUF_MEM_append((unint64_t *)*v272, &ses.app_verify_arg, 4uLL))
              goto LABEL_526;
            if (*(_QWORD *)v5)
              (*(void (**)(char *, void **, uint64_t))(*(_QWORD *)v5 + 24))(v5, &ses.app_verify_arg, 4);
            v83 = *((_QWORD *)this + 4);
            v84 = (unint64_t *)*((_QWORD *)this + 51);
            if (v84)
            {
              if (!BUF_MEM_append(v84, md, *((_QWORD *)this + 4)))
                goto LABEL_526;
            }
            (*(void (**)(char *, unsigned __int8 *, uint64_t))(*(_QWORD *)v5 + 24))(v5, md, v83);
            v85 = *(unsigned int *)(*(_QWORD *)v5 + 4);
            if (v85 < 0x31)
            {
              v151 = *((_QWORD *)this + 188);
              *(_BYTE *)(v151 + 10) = v85;
              ses.generate_session_id = 0;
              if (!bssl::SSLTranscript::GetHash((bssl::SSLTranscript *)v272, (unsigned __int8 *)&ses.rsa_md5, (unint64_t *)&ses.generate_session_id)|| CRYPTO_tls13_hkdf_expand_label(v151 + 11, v85, *((EVP_MD **)this + 52), v267, *((_QWORD *)this + 4), "res master", 0xAuLL, &ses.rsa_md5, (size_t)ses.generate_session_id) != 1|| (bssl::add_new_session_tickets(this, (bssl::SSL_HANDSHAKE *)&ses.verify_mode, a3) & 1) == 0)
              {
                goto LABEL_526;
              }
LABEL_42:
              *((_DWORD *)this + 6) = 8;
              v7 = 4;
              if (v6 == 8)
                goto LABEL_3;
            }
            else
            {
              ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_enc.cc", 309);
              v7 = 0;
              if (*((_DWORD *)this + 6) == v6)
                goto LABEL_3;
            }
          }
          else
          {
            ERR_put_error(16, 0, 68, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 978);
            v7 = 0;
            if (*((_DWORD *)this + 6) == v6)
              goto LABEL_3;
          }
        }
        goto LABEL_502;
      case 8:
        v56 = *(_QWORD *)this;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x400) == 0)
          goto LABEL_110;
        v7 = 0;
        if (!bssl::tls13_set_traffic_key(*(_QWORD *)this, 1, 0, *((_QWORD *)this + 188), v271, *((_QWORD *)this + 4)))goto LABEL_501;
        *((_DWORD *)this + 392) |= 0x3400u;
LABEL_110:
        if (*(_QWORD *)(v56 + 152))
        {
          v7 = 0;
          if (!bssl::tls13_set_traffic_key(v56, 2, 0, *((_QWORD *)this + 188), v273, *((_QWORD *)this + 4)))goto LABEL_501;
          v57 = 12;
        }
        else
        {
          v57 = 14;
        }
        *((_DWORD *)this + 6) = 9;
        if ((*(_WORD *)(*(_QWORD *)(v56 + 48) + 220) & 0x400) != 0)
          v7 = v57;
        else
          v7 = 1;
        if (*((_DWORD *)this + 6) != v6)
          goto LABEL_502;
        goto LABEL_3;
      case 9:
        v8 = *(_QWORD *)this;
        if (*(_QWORD *)(*(_QWORD *)this + 152))
          goto LABEL_39;
        if ((*(_WORD *)(*(_QWORD *)(v8 + 48) + 220) & 0x400) == 0)
          goto LABEL_202;
        if (!(*(unsigned int (**)(_QWORD, const EVP_MD **))(*(_QWORD *)v8 + 24))(*(_QWORD *)this, &ses.rsa_md5))goto LABEL_295;
        if (BYTE1(ses.rsa_md5) != 5)
          goto LABEL_364;
        if (ses.sha1)
        {
          bssl::ssl_send_alert((bssl *)v8, (ssl_st *)2, 50);
          ERR_put_error(16, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 1051);
          v7 = 0;
          if (*((_DWORD *)this + 6) == v6)
            goto LABEL_3;
        }
        else
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
LABEL_202:
          v7 = 0;
          if (!bssl::tls13_set_traffic_key(v8, 2, 0, *((_QWORD *)this + 188), v273, *((_QWORD *)this + 4)))goto LABEL_501;
LABEL_39:
          *((_DWORD *)this + 6) = 10;
          v7 = 1;
          if (v6 == 10)
            goto LABEL_3;
        }
        goto LABEL_502;
      case 10:
        if ((*(_BYTE *)(*((_QWORD *)this + 188) + 424) & 0x40) == 0)
          goto LABEL_36;
        v8 = *(_QWORD *)this;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 48) + 220) & 0x400) != 0)
          goto LABEL_36;
        if (!(*(unsigned int (**)(_QWORD, const EVP_MD **))(*(_QWORD *)v8 + 24))(*(_QWORD *)this, &ses.rsa_md5))goto LABEL_295;
        if (BYTE1(ses.rsa_md5) != 8)
          goto LABEL_364;
        v13 = (char *)&ses.sha1[-1].ctx_size + 6;
        if (ses.sha1 < (const EVP_MD *)2
          || (v14 = (pem_password_cb *)__rev16((unsigned __int16)ses.md5->type), v13 < (char *)v14)
          || (ses.app_verify_arg = (char *)&ses.md5->type + 2, ses.default_passwd_callback = v14, v13 != (char *)v14))
        {
          v133 = 137;
          v134 = 1084;
          goto LABEL_321;
        }
        if ((*(_WORD *)(*((_QWORD *)this + 1) + 237) & 0x2000) != 0)
          v15 = 17613;
        else
          v15 = 17513;
        LOWORD(ses.generate_session_id) = v15;
        WORD1(ses.generate_session_id) = 1;
        ses.param = 0;
        *(_QWORD *)&ses.quiet_shutdown = 0;
        LOBYTE(ses.stats.sess_connect_good) = 50;
        *(_QWORD *)&ses.verify_mode = &ses.generate_session_id;
        if ((bssl::ssl_parse_extensions((unsigned __int16 **)&ses.app_verify_arg, &ses.stats.sess_connect_good, (uint64_t *)&ses.verify_mode, 1, 0) & 1) == 0)
        {
          method_low = LOBYTE(ses.stats.sess_connect_good);
          goto LABEL_542;
        }
        if (!BYTE3(ses.generate_session_id))
        {
          ERR_put_error(16, 0, 164, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 1102);
          method_low = 109;
          goto LABEL_542;
        }
        v16 = v4;
        v17 = *((_QWORD *)this + 188);
        param = ses.param;
        v18 = *(_QWORD *)&ses.quiet_shutdown;
        OPENSSL_free(*(_QWORD **)(v17 + 408));
        *(_QWORD *)(v17 + 408) = 0;
        *(_QWORD *)(v17 + 416) = 0;
        if (!v18)
          goto LABEL_34;
        v20 = OPENSSL_malloc(v18);
        *(_QWORD *)(v17 + 408) = v20;
        if (!v20)
        {
          method_low = 80;
          v4 = v16;
          goto LABEL_542;
        }
        *(_QWORD *)(v17 + 416) = v18;
        memmove(v20, param, v18);
LABEL_34:
        if ((bssl::ssl_hash_message((uint64_t)this, (uint64_t)&ses.rsa_md5) & 1) == 0)
        {
          method_low = 80;
          v4 = v16;
          goto LABEL_542;
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
        v4 = v16;
LABEL_36:
        *((_DWORD *)this + 6) = 11;
        v7 = 1;
        if (v6 != 11)
          goto LABEL_502;
        goto LABEL_3;
      case 11:
        v8 = *(_QWORD *)this;
        if ((*((_BYTE *)this + 1568) & 0x20) != 0)
        {
          v86 = *(_BYTE *)(*((_QWORD *)this + 1) + 236);
          if (!(*(unsigned int (**)(_QWORD, const EVP_MD **))(*(_QWORD *)v8 + 24))(*(_QWORD *)this, &ses.rsa_md5))goto LABEL_295;
          if (BYTE1(ses.rsa_md5) != 11)
            goto LABEL_364;
          if (!bssl::tls13_process_certificate((uint64_t)this, (uint64_t)&ses.rsa_md5, (v86 & 2) == 0))
            goto LABEL_526;
          if (!LOBYTE(ses.rsa_md5))
          {
            extra_certs = ses.extra_certs;
            comp_methods = ses.comp_methods;
            if (*v272
              && !BUF_MEM_append((unint64_t *)*v272, ses.extra_certs, (size_t)ses.comp_methods))
            {
              goto LABEL_526;
            }
            if (*(_QWORD *)v5)
              (*(void (**)(char *, STACK *, STACK *))(*(_QWORD *)v5 + 24))(v5, extra_certs, comp_methods);
          }
          (*(void (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
          *((_DWORD *)this + 6) = 12;
          if (v6 == 12)
            goto LABEL_3;
        }
        else
        {
          if ((*(_WORD *)(*(_QWORD *)(v8 + 48) + 220) & 0x40) == 0)
            *(_QWORD *)(*((_QWORD *)this + 188) + 176) = 0;
LABEL_133:
          *((_DWORD *)this + 6) = 13;
          if (v6 == 13)
            goto LABEL_3;
        }
        goto LABEL_502;
      case 12:
        v54 = *(_QWORD **)(*((_QWORD *)this + 188) + 136);
        if (!v54 || !*v54)
          goto LABEL_133;
        v8 = *(_QWORD *)this;
        if (!(*(unsigned int (**)(_QWORD, const EVP_MD **))(**(_QWORD **)this + 24))(*(_QWORD *)this, &ses.rsa_md5))goto LABEL_295;
        v55 = bssl::ssl_verify_peer_cert(this, a2);
        if (v55 == 1)
          goto LABEL_526;
        if (v55 == 2)
        {
          v7 = 16;
          *((_DWORD *)this + 6) = 12;
          if (v6 == 12)
            goto LABEL_3;
          goto LABEL_502;
        }
        if (BYTE1(ses.rsa_md5) != 15)
          goto LABEL_364;
        if (!bssl::tls13_process_certificate_verify((uint64_t)this, (uint64_t)&ses.rsa_md5))
          goto LABEL_526;
        if (!LOBYTE(ses.rsa_md5))
        {
          v135 = ses.extra_certs;
          v136 = ses.comp_methods;
          if (*v272
            && !BUF_MEM_append((unint64_t *)*v272, ses.extra_certs, (size_t)ses.comp_methods))
          {
            goto LABEL_526;
          }
          if (*(_QWORD *)v5)
            (*(void (**)(char *, STACK *, STACK *))(*(_QWORD *)v5 + 24))(v5, v135, v136);
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
        *((_DWORD *)this + 6) = 13;
        if (v6 == 13)
          goto LABEL_3;
        goto LABEL_502;
      case 13:
        if ((*((_BYTE *)this + 1570) & 0x80) != 0)
        {
          v8 = *(_QWORD *)this;
          if ((*(unsigned int (**)(_QWORD, const EVP_MD **))(**(_QWORD **)this + 24))(*(_QWORD *)this, &ses.rsa_md5))
          {
            if (BYTE1(ses.rsa_md5) != 203)
            {
LABEL_364:
              bssl::ssl_send_alert((bssl *)v8, (ssl_st *)2, 10);
              ERR_put_error(16, 0, 223, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/handshake.cc", 211);
              v132 = BYTE1(ses.rsa_md5);
              goto LABEL_365;
            }
            if (!bssl::tls1_verify_channel_id(this, (uint64_t)&ses.rsa_md5))
              goto LABEL_526;
            if (!LOBYTE(ses.rsa_md5))
            {
              v77 = ses.extra_certs;
              v78 = ses.comp_methods;
              if (*v272
                && !BUF_MEM_append((unint64_t *)*v272, ses.extra_certs, (size_t)ses.comp_methods))
              {
                goto LABEL_526;
              }
              if (*(_QWORD *)v5)
                (*(void (**)(char *, STACK *, STACK *))(*(_QWORD *)v5 + 24))(v5, v77, v78);
            }
            (*(void (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
            *((_DWORD *)this + 6) = 14;
            if (v6 == 14)
              goto LABEL_3;
          }
          else
          {
LABEL_295:
            v7 = 3;
            if (*((_DWORD *)this + 6) == v6)
              goto LABEL_3;
          }
        }
        else
        {
          *((_DWORD *)this + 6) = 14;
          if (v6 == 14)
            goto LABEL_3;
        }
        goto LABEL_502;
      case 14:
        v8 = *(_QWORD *)this;
        if (!(*(unsigned int (**)(_QWORD, const EVP_MD **))(**(_QWORD **)this + 24))(*(_QWORD *)this, &ses.rsa_md5))goto LABEL_295;
        if (BYTE1(ses.rsa_md5) != 20)
          goto LABEL_364;
        if (!bssl::tls13_process_finished((uint64_t)this, (uint64_t)&ses.rsa_md5, (*(unsigned __int16 *)(*(_QWORD *)(v8 + 48) + 220) >> 10) & 1))goto LABEL_526;
        v7 = 0;
        if (!bssl::tls13_set_traffic_key(v8, 3, 0, *((_QWORD *)this + 188), v4, *((_QWORD *)this + 4)))
          goto LABEL_501;
        if ((*(_WORD *)(*(_QWORD *)(v8 + 48) + 220) & 0x400) != 0)
        {
          v76 = 16;
        }
        else
        {
          if (!LOBYTE(ses.rsa_md5))
          {
            v74 = ses.extra_certs;
            v75 = ses.comp_methods;
            if (*v272
              && !BUF_MEM_append((unint64_t *)*v272, ses.extra_certs, (size_t)ses.comp_methods))
            {
              goto LABEL_526;
            }
            if (*(_QWORD *)v5)
              (*(void (**)(char *, STACK *, STACK *))(*(_QWORD *)v5 + 24))(v5, v74, v75);
          }
          if (!bssl::tls13_derive_resumption_secret(this, a2))
            goto LABEL_526;
          v76 = 15;
        }
        *((_DWORD *)this + 6) = v76;
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
        v7 = 1;
        if (*((_DWORD *)this + 6) == v6)
          goto LABEL_3;
        goto LABEL_502;
      case 15:
        LOBYTE(ses.rsa_md5) = 0;
        v7 = 0;
        if (!bssl::add_new_session_tickets(this, (bssl::SSL_HANDSHAKE *)&ses.rsa_md5, a3))
          goto LABEL_501;
        *((_DWORD *)this + 6) = 16;
        if (LOBYTE(ses.rsa_md5))
          v73 = *(_QWORD *)(*(_QWORD *)this + 152) == 0;
        else
          v73 = 1;
        if (v73)
          v7 = 1;
        else
          v7 = 4;
        if (*((_DWORD *)this + 6) != v6)
          goto LABEL_502;
        goto LABEL_3;
      case 16:
        return v7;
      default:
        goto LABEL_526;
    }
  }
}

BOOL bssl::resolve_ecdhe_secret(uint64_t a1, uint64_t a2)
{
  bssl *v3;
  bssl::SSLKeyShare *v4;
  uint64_t v5;
  _QWORD *v6;
  const void *v7;
  unint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  size_t v12;
  _QWORD *v13;
  size_t v14;
  const void *v15;
  uint64_t v16;
  char *v17;
  _QWORD *v18;
  const unsigned __int8 *v19;
  _BOOL8 v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  char *v24;
  int v25;
  _QWORD *v26;
  uint64_t v27;
  size_t v28;
  uint64_t v29;
  char *v30;
  _QWORD *v31;
  char *v32;
  uint64_t v33;
  size_t v34;
  _QWORD *v36;
  __int128 v37;
  void *v38[4];
  void *v39;
  size_t v40;
  char v41[9];
  uint64_t v42;
  BOOL v43;

  v3 = *(bssl **)a1;
  v4 = (bssl::SSLKeyShare *)*(unsigned __int16 *)(*(_QWORD *)(a1 + 1504) + 6);
  v43 = 0;
  v41[2] = 0;
  *(_WORD *)&v41[3] = 0;
  *(_DWORD *)&v41[5] = 0;
  v42 = 0;
  strcpy(v41, "2");
  if ((bssl::ssl_ext_key_share_parse_clienthello(a1, &v43, (unsigned __int16 **)&v41[1], v41, a2) & 1) == 0)
  {
    bssl::ssl_send_alert(v3, (ssl_st *)2, v41[0]);
    return 0;
  }
  if (!v43)
  {
    bssl::ssl_send_alert(v3, (ssl_st *)2, 47);
    ERR_put_error(16, 0, 243, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls13_server.cc", 62);
    return 0;
  }
  v39 = 0;
  v40 = 0;
  v5 = *(_QWORD *)(a1 + 1560);
  if (v5 && (*(_BYTE *)(a1 + 1570) & 8) == 0 && *(unsigned __int16 *)(v5 + 32) == (_DWORD)v4 && *(_QWORD *)(v5 + 64))
  {
    v6 = (_QWORD *)(a1 + 616);
    v7 = *(const void **)(v5 + 40);
    v8 = *(_QWORD *)(v5 + 48);
    v9 = *(_QWORD *)(a1 + 616);
    if (v9)
    {
      v11 = *(_QWORD *)(v9 - 8);
      v10 = (void *)(v9 - 8);
      v12 = v11 + 8;
      if (v11 != -8)
        bzero(v10, v12);
      free(v10);
    }
    *v6 = 0;
    *(_QWORD *)(a1 + 624) = 0;
    if (v8)
    {
      v13 = OPENSSL_malloc(v8);
      *v6 = v13;
      if (!v13)
      {
LABEL_53:
        bssl::ssl_send_alert(v3, (ssl_st *)2, 80);
        goto LABEL_54;
      }
      *(_QWORD *)(a1 + 624) = v8;
      memmove(v13, v7, v8);
    }
    v15 = *(const void **)(v5 + 56);
    v14 = *(_QWORD *)(v5 + 64);
    if (v39)
    {
      v17 = (char *)v39 - 8;
      v16 = *((_QWORD *)v39 - 1);
      if (v16 != -8)
        bzero(v17, v16 + 8);
      free(v17);
    }
    v39 = 0;
    v40 = 0;
    if (v14)
    {
      if (v14 <= 0xFFFFFFFFFFFFFFF7)
      {
        v18 = malloc_type_malloc(v14 + 8, 0x30772F57uLL);
        if (v18)
        {
          *v18 = v14;
          v19 = (const unsigned __int8 *)(v18 + 1);
          v39 = v18 + 1;
          v40 = v14;
          memmove(v18 + 1, v15, v14);
          goto LABEL_60;
        }
      }
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v39 = 0;
      goto LABEL_53;
    }
    v19 = 0;
LABEL_60:
    v20 = bssl::tls13_advance_key_schedule(a1, v19, v40);
    v31 = v39;
    if (!v39)
      return v20;
    goto LABEL_55;
  }
  memset(v38, 0, sizeof(v38));
  v37 = 0u;
  bssl::SSLKeyShare::Create(v4, &v36);
  v21 = v36;
  if (!v36)
  {
    bssl::ssl_send_alert(v3, (ssl_st *)2, v41[0]);
    if (BYTE8(v37))
      goto LABEL_54;
    goto LABEL_46;
  }
  memset(v38, 0, sizeof(v38));
  v37 = 0u;
  v22 = malloc_type_malloc(0x28uLL, 0x30772F57uLL);
  if (!v22)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
LABEL_42:
    v25 = v41[0];
    goto LABEL_43;
  }
  *v22 = 32;
  BYTE8(v37) = 0;
  *(_QWORD *)&v37 = 0;
  v38[0] = v22 + 1;
  *(_OWORD *)&v38[1] = xmmword_208F1E4E0;
  LOBYTE(v38[3]) = (uint64_t)v38[3] & 0xFC | 1;
  if (!(*(unsigned int (**)(_QWORD *, __int128 *, void **, char *, _QWORD, uint64_t))(*v21 + 32))(v21, &v37, &v39, v41, *(_QWORD *)&v41[1], v42)|| !bssl::CBBFinishArray((uint64_t)&v37, (uint64_t *)(a1 + 616)))
  {
    goto LABEL_42;
  }
  if (!v5
    || (*(_BYTE *)(a1 + 1570) & 8) == 0
    || (*(_WORD *)(v5 + 32) = (_WORD)v4,
        bssl::Array<unsigned char>::CopyFrom((uint64_t *)(v5 + 40), *(const void **)(a1 + 616), *(_QWORD *)(a1 + 624)))&& bssl::Array<unsigned char>::CopyFrom((uint64_t *)(v5 + 56), v39, v40))
  {
    (*(void (**)(_QWORD *))*v21)(v21);
    OPENSSL_free(v21);
    if (!BYTE8(v37) && ((uint64_t)v38[3] & 1) != 0 && v38[0])
    {
      v24 = (char *)v38[0] - 8;
      v23 = *((_QWORD *)v38[0] - 1);
      if (v23 != -8)
        bzero(v24, v23 + 8);
      free(v24);
    }
    v19 = (const unsigned __int8 *)v39;
    goto LABEL_60;
  }
  v25 = 80;
LABEL_43:
  bssl::ssl_send_alert(v3, (ssl_st *)2, v25);
  (*(void (**)(_QWORD *))*v21)(v21);
  v27 = *(v21 - 1);
  v26 = v21 - 1;
  v28 = v27 + 8;
  if (v27 != -8)
    bzero(v26, v28);
  free(v26);
  if (BYTE8(v37))
  {
LABEL_54:
    v20 = 0;
    v31 = v39;
    if (!v39)
      return v20;
    goto LABEL_55;
  }
LABEL_46:
  if (((uint64_t)v38[3] & 1) == 0 || !v38[0])
    goto LABEL_54;
  v30 = (char *)v38[0] - 8;
  v29 = *((_QWORD *)v38[0] - 1);
  if (v29 != -8)
    bzero(v30, v29 + 8);
  free(v30);
  v20 = 0;
  v31 = v39;
  if (v39)
  {
LABEL_55:
    v33 = *(v31 - 1);
    v32 = (char *)(v31 - 1);
    v34 = v33 + 8;
    if (v33 != -8)
      bzero(v32, v34);
    free(v32);
  }
  return v20;
}

uint64_t bssl::add_new_session_tickets(bssl *this, bssl::SSL_HANDSHAKE *a2, BOOL *a3)
{
  uint64_t v5;
  int32x2_t *v6;
  void (*v7)(_QWORD, timeval *, BOOL *);
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  unint64_t v11;
  uint64_t result;
  unint64_t v13;
  int32x2_t v14;
  uint64x2_t v15;
  uint64_t v16;
  ssl_session_st *v17;
  int v18;
  int v19;
  int time;
  int v21;
  int v22;
  const ssl_cipher_st *v23;
  ssl_session_st *v24;
  uint64_t key_arg_length_low;
  uint64_t *handshake_digest;
  unsigned __int8 *v27;
  uint64_t v28;
  __int16 v29;
  void *v30;
  uint64_t v31;
  size_t v32;
  ssl_session_st *v33;
  unsigned int i;
  unsigned int v35;
  uint64_t *p_tlsext_tick_lifetime_hint;
  uint64_t tlsext_tick_lifetime_hint;
  size_t v38;
  _BYTE v39[48];
  uint64_t v40[6];
  _QWORD v41[6];
  _QWORD v42[6];
  uint64_t v43[6];
  timeval v44;
  __int128 v45;
  __int128 v46;
  char v47;
  ssl_session_st *v48;

  if ((*((_BYTE *)this + 1568) & 0x10) != 0)
  {
    v5 = *(_QWORD *)this;
    if ((*(_BYTE *)(*(_QWORD *)this + 129) & 0x40) == 0)
    {
      v6 = (int32x2_t *)*((_QWORD *)this + 188);
      v7 = *(void (**)(_QWORD, timeval *, BOOL *))(*(_QWORD *)(v5 + 104) + 696);
      if (v7)
      {
        v7(0, &v44, a3);
        v8 = v44.tv_sec & ~(v44.tv_sec >> 63);
        v9 = (unint64_t)v6[24];
        v10 = v8 >= v9;
        v11 = v8 - v9;
        if (!v10)
          goto LABEL_5;
      }
      else
      {
        gettimeofday(&v44, 0);
        v8 = v44.tv_sec & ~(v44.tv_sec >> 63);
        v13 = (unint64_t)v6[24];
        v10 = v8 >= v13;
        v11 = v8 - v13;
        if (!v10)
        {
LABEL_5:
          v6[23] = 0;
          v6[24] = (int32x2_t)v8;
          if (!*(_BYTE *)(*(_QWORD *)(v5 + 112) + 228))
            goto LABEL_67;
LABEL_12:
          v16 = 0;
          while (1)
          {
            bssl::SSL_SESSION_dup(*((bssl **)this + 188), (ssl_session_st *)2, &v48);
            if (!v48)
              return 0;
            RAND_bytes_with_additional_data((uint64_t)&v48[1].session_id[8], 4uLL, (uint64_t)&RAND_bytes_kZeroAdditionalData);
            v17 = v48;
            v48[1].sid_ctx[28] |= 8u;
            if ((*(_BYTE *)(v5 + 164) & 4) != 0)
            {
              if (!*(_QWORD *)(v5 + 152))
              {
                v19 = 14336;
                goto LABEL_20;
              }
              if (*(_QWORD *)(*(_QWORD *)(v5 + 8) + 184))
              {
                v19 = -1;
LABEL_20:
                *(_DWORD *)&v17[1].session_id[12] = v19;
                v18 = 1;
                goto LABEL_21;
              }
            }
            v18 = 0;
LABEL_21:
            v47 = v16;
            v45 = 0u;
            v46 = 0u;
            v44 = (timeval)0;
            if (!(*(unsigned int (**)(uint64_t, timeval *, uint64_t *, uint64_t))(*(_QWORD *)v5 + 88))(v5, &v44, v43, 4))goto LABEL_46;
            time = v48->time;
            v42[0] = 0;
            if (!CBB_add_space((uint64_t)v43, v42, 4))
              goto LABEL_46;
            *(_BYTE *)(v42[0] + 3) = time;
            *(_BYTE *)(v42[0] + 2) = BYTE1(time);
            *(_BYTE *)(v42[0] + 1) = BYTE2(time);
            *(_BYTE *)v42[0] = HIBYTE(time);
            v21 = *(_DWORD *)&v48[1].session_id[8];
            v42[0] = 0;
            if (!CBB_add_space((uint64_t)v43, v42, 4))
              goto LABEL_46;
            *(_BYTE *)(v42[0] + 3) = v21;
            *(_BYTE *)(v42[0] + 2) = BYTE1(v21);
            *(_BYTE *)(v42[0] + 1) = BYTE2(v21);
            *(_BYTE *)v42[0] = HIBYTE(v21);
            v22 = 1;
            if (CBB_flush(v43) && cbb_add_child((uint64_t)v43, (uint64_t)v42, 1u, 0))
            {
              v41[0] = 0;
              if (!CBB_add_space((uint64_t)v42, v41, 1))
                goto LABEL_46;
              *(_BYTE *)v41[0] = v47;
              if (!CBB_flush(v43) || !cbb_add_child((uint64_t)v43, (uint64_t)v41, 2u, 0))
                goto LABEL_46;
              v24 = v48;
              key_arg_length_low = LOWORD(v48->key_arg_length);
              if ((key_arg_length_low - 769) >= 4)
              {
                if ((_DWORD)key_arg_length_low == 65277)
                {
                  key_arg_length_low = 771;
                }
                else if ((_DWORD)key_arg_length_low == 65279)
                {
                  key_arg_length_low = 770;
                }
                else
                {
                  key_arg_length_low = 0;
                }
              }
              handshake_digest = bssl::ssl_get_handshake_digest((bssl *)key_arg_length_low, (uint64_t)v48->cipher, v23);
              v27 = &v24->key_arg[3];
              v28 = v24->key_arg[2];
              v22 = 1;
              if (CRYPTO_tls13_hkdf_expand_label((uint64_t)v27, v28, (EVP_MD *)handshake_digest, v27, v28, "resumption", 0xAuLL, &v47, 1uLL) == 1)
              {
                if (!bssl::ssl_encrypt_ticket((uint64_t *)this, (uint64_t)v41, (uint64_t)v48)
                  || !CBB_add_u16_length_prefixed(v43, (uint64_t)v40)
                  || v18
                  && (!CBB_add_u16((uint64_t)v40, 42)
                   || !CBB_add_u16_length_prefixed(v40, (uint64_t)v39)
                   || !CBB_add_u32((uint64_t)v39, *(_DWORD *)&v48[1].session_id[12])
                   || !CBB_flush(v40))
                  || (v29 = *((_BYTE *)this + 1619) & 0xF0 | 0xA,
                      !CBB_add_u16((uint64_t)v40, v29 | (unsigned __int16)(v29 << 8)))
                  || !CBB_add_u16((uint64_t)v40, 0))
                {
LABEL_46:
                  v22 = 1;
                  goto LABEL_47;
                }
                v22 = bssl::ssl_add_message_cbb(v5, (uint64_t)&v44) ^ 1;
              }
            }
LABEL_47:
            if (!LOBYTE(v44.tv_usec) && (BYTE8(v46) & 1) != 0 && (_QWORD)v45)
            {
              v31 = *(_QWORD *)(v45 - 8);
              v30 = (void *)(v45 - 8);
              v32 = v31 + 8;
              if (v31 != -8)
                bzero(v30, v32);
              free(v30);
            }
            v33 = v48;
            v48 = 0;
            if (v33)
            {
              for (i = atomic_load((unsigned int *)v33); i != -1; i = v35)
              {
                if (!i)
                  abort();
                v35 = __ldaxr((unsigned int *)v33);
                if (v35 == i)
                {
                  if (!__stlxr(i - 1, (unsigned int *)v33))
                  {
                    if (i == 1)
                    {
                      ssl_session_st::~ssl_session_st(v33);
                      tlsext_tick_lifetime_hint = v33[-1].tlsext_tick_lifetime_hint;
                      p_tlsext_tick_lifetime_hint = &v33[-1].tlsext_tick_lifetime_hint;
                      v38 = tlsext_tick_lifetime_hint + 8;
                      if (tlsext_tick_lifetime_hint != -8)
                        bzero(p_tlsext_tick_lifetime_hint, v38);
                      free(p_tlsext_tick_lifetime_hint);
                    }
                    break;
                  }
                }
                else
                {
                  __clrex();
                }
              }
            }
            if (v22)
              return 0;
            if (++v16 >= (unint64_t)*(unsigned __int8 *)(*(_QWORD *)(v5 + 112) + 228))
              goto LABEL_67;
          }
        }
      }
      v6[24] = (int32x2_t)v8;
      v14 = v6[23];
      v15.i64[0] = v14.u32[0];
      v15.i64[1] = v14.u32[1];
      v6[23] = (int32x2_t)vbic_s8((int8x8_t)vsub_s32(v14, vdup_n_s32(v11)), (int8x8_t)vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(v11), v15)));
      if (!*(_BYTE *)(*(_QWORD *)(v5 + 112) + 228))
      {
LABEL_67:
        result = 1;
        *(_BYTE *)a2 = 1;
        return result;
      }
      goto LABEL_12;
    }
  }
  *(_BYTE *)a2 = 0;
  return 1;
}

uint64_t EVP_tls_cbc_remove_padding(uint64_t *a1, _QWORD *a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64x2_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t *v15;
  int64x2_t v16;
  int64x2_t v17;
  int64x2_t v18;
  int64x2_t v19;
  int64x2_t v20;
  unint64_t v21;
  int8x16_t v22;
  int64x2_t v23;
  int8x16_t v24;
  int64x2_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int64x2_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int64x2_t v31;
  int8x16_t v32;
  int8x16_t v33;
  uint8x16_t v34;
  uint16x8_t v35;
  uint16x8_t v36;
  uint32x4_t v37;
  int8x16_t v38;
  int8x16_t v39;
  uint32x4_t v40;
  uint32x4_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  uint32x4_t v46;
  int8x16_t v47;
  int8x16_t v48;
  int8x16_t v49;
  unint64_t v50;
  int8x16_t v51;
  int64x2_t v52;
  int64x2_t v53;
  int64x2_t v54;
  int64x2_t v55;
  int8x16_t v56;
  int8x16_t v57;
  int8x8_t v58;
  int8x8_t *v59;
  unint64_t v60;
  int64x2_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x8_t v64;
  uint16x8_t v65;
  uint32x4_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int8x16_t v69;
  uint32x4_t v70;
  int8x16_t v71;
  int8x16_t v72;
  char *v73;
  char v74;
  char v75;
  uint64_t v76;

  if (a6 + 1 > a4)
    return 0;
  v7 = *(unsigned __int8 *)(a4 + a3 - 1);
  v8 = (uint64_t)(((a4 - (a6 + 1 + v7)) ^ a4 | (a6 + 1 + v7) ^ a4) ^ ~a4) >> 63;
  v9 = 256;
  if (a4 < 0x100)
    v9 = a4;
  if (v9)
  {
    if (v9 < 8)
    {
      v10 = 0;
      goto LABEL_17;
    }
    v11 = (uint64x2_t)vdupq_n_s64(v7);
    if (v9 >= 0x10)
    {
      v10 = v9 & 0x1F0;
      v12.i64[0] = -1;
      v12.i64[1] = -1;
      v13.i64[1] = -1;
      v13.i64[0] = (uint64_t)(((a4 - (a6 + 1 + v7)) ^ a4 | (a6 + 1 + v7) ^ a4) ^ ~a4) >> 63;
      v14 = vdupq_n_s8(v7);
      v15 = (int8x16_t *)(a4 + a3 - 16);
      v16 = (int64x2_t)xmmword_208F30EC0;
      v17 = (int64x2_t)xmmword_208F30ED0;
      v18 = (int64x2_t)xmmword_208F30EE0;
      v19 = vdupq_n_s64(0x10uLL);
      v20 = (int64x2_t)xmmword_208F30EF0;
      v21 = v10;
      v22.i64[0] = -1;
      v22.i64[1] = -1;
      v23 = (int64x2_t)xmmword_208F30F00;
      v24.i64[0] = -1;
      v24.i64[1] = -1;
      v25 = (int64x2_t)xmmword_208F30F10;
      v26.i64[0] = -1;
      v26.i64[1] = -1;
      v27.i64[0] = -1;
      v27.i64[1] = -1;
      v28 = (int64x2_t)xmmword_208F08AD0;
      v29.i64[0] = -1;
      v29.i64[1] = -1;
      v30.i64[0] = -1;
      v30.i64[1] = -1;
      v31 = (int64x2_t)xmmword_208F05120;
      do
      {
        v32 = *v15--;
        v33 = vrev64q_s8(v32);
        v34 = (uint8x16_t)veorq_s8(vextq_s8(v33, v33, 8uLL), v14);
        v35 = vmovl_high_u8(v34);
        v36 = vmovl_u8(*(uint8x8_t *)v34.i8);
        v37 = vmovl_u16(*(uint16x4_t *)v36.i8);
        v38.i64[0] = v37.u32[0];
        v38.i64[1] = v37.u32[1];
        v39 = vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v31, v11), v38);
        v40 = vmovl_u16(*(uint16x4_t *)v35.i8);
        v41 = vmovl_high_u16(v36);
        v38.i64[0] = v37.u32[2];
        v38.i64[1] = v37.u32[3];
        v42 = vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v28, v11), v38);
        v38.i64[0] = v41.u32[0];
        v38.i64[1] = v41.u32[1];
        v43 = vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v25, v11), v38);
        v38.i64[0] = v40.u32[0];
        v38.i64[1] = v40.u32[1];
        v44 = vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v20, v11), v38);
        v38.i64[0] = v41.u32[2];
        v38.i64[1] = v41.u32[3];
        v45 = vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v23, v11), v38);
        v46 = vmovl_high_u16(v35);
        v38.i64[0] = v40.u32[2];
        v38.i64[1] = v40.u32[3];
        v47 = vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v18, v11), v38);
        v38.i64[0] = v46.u32[0];
        v38.i64[1] = v46.u32[1];
        v48 = vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v17, v11), v38);
        v38.i64[0] = v46.u32[2];
        v38.i64[1] = v46.u32[3];
        v30 = vandq_s8(vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v16, v11), v38), v30);
        v29 = vandq_s8(v48, v29);
        v27 = vandq_s8(v47, v27);
        v24 = vandq_s8(v45, v24);
        v26 = vandq_s8(v44, v26);
        v22 = vandq_s8(v43, v22);
        v12 = vandq_s8(v42, v12);
        v13 = vandq_s8(v39, v13);
        v25 = vaddq_s64(v25, v19);
        v28 = vaddq_s64(v28, v19);
        v31 = vaddq_s64(v31, v19);
        v23 = vaddq_s64(v23, v19);
        v20 = vaddq_s64(v20, v19);
        v18 = vaddq_s64(v18, v19);
        v17 = vaddq_s64(v17, v19);
        v16 = vaddq_s64(v16, v19);
        v21 -= 16;
      }
      while (v21);
      v49 = vandq_s8(vandq_s8(vandq_s8(v13, v26), vandq_s8(v22, v29)), vandq_s8(vandq_s8(v12, v27), vandq_s8(v24, v30)));
      v8 = (uint64_t)vand_s8(*(int8x8_t *)v49.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL));
      if (v9 == v10)
        goto LABEL_21;
      if ((v9 & 8) == 0)
        goto LABEL_17;
    }
    else
    {
      v10 = 0;
    }
    v50 = v10;
    v51 = (int8x16_t)vdupq_n_s64(v10);
    v10 = v9 & 0x1F8;
    v52 = (int64x2_t)vorrq_s8(v51, (int8x16_t)xmmword_208F30F00);
    v53 = (int64x2_t)vorrq_s8(v51, (int8x16_t)xmmword_208F30F10);
    v54 = (int64x2_t)vorrq_s8(v51, (int8x16_t)xmmword_208F08AD0);
    v55 = (int64x2_t)vorrq_s8(v51, (int8x16_t)xmmword_208F05120);
    v56.i64[1] = -1;
    v56.i64[0] = v8;
    v57.i64[0] = -1;
    v57.i64[1] = -1;
    v58 = vdup_n_s8(v7);
    v59 = (int8x8_t *)(a4 - v50 + a3 - 8);
    v60 = v50 - v10;
    v61 = vdupq_n_s64(8uLL);
    v62.i64[0] = -1;
    v62.i64[1] = -1;
    v63.i64[0] = -1;
    v63.i64[1] = -1;
    do
    {
      v64 = *v59--;
      v65 = vmovl_u8((uint8x8_t)veor_s8(vrev64_s8(v64), v58));
      v66 = vmovl_high_u16(v65);
      v67.i64[0] = v66.u32[2];
      v67.i64[1] = v66.u32[3];
      v68 = v67;
      v67.i64[0] = v66.u32[0];
      v67.i64[1] = v66.u32[1];
      v69 = v67;
      v70 = vmovl_u16(*(uint16x4_t *)v65.i8);
      v67.i64[0] = v70.u32[2];
      v67.i64[1] = v70.u32[3];
      v71 = v67;
      v67.i64[0] = v70.u32[0];
      v67.i64[1] = v70.u32[1];
      v63 = vandq_s8(vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v52, v11), v68), v63);
      v62 = vandq_s8(vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v53, v11), v69), v62);
      v57 = vandq_s8(vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v54, v11), v71), v57);
      v56 = vandq_s8(vornq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v55, v11), v67), v56);
      v53 = vaddq_s64(v53, v61);
      v54 = vaddq_s64(v54, v61);
      v55 = vaddq_s64(v55, v61);
      v52 = vaddq_s64(v52, v61);
      v60 += 8;
    }
    while (v60);
    v72 = vandq_s8(vandq_s8(v56, v62), vandq_s8(v57, v63));
    LOBYTE(v8) = vand_s8(*(int8x8_t *)v72.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v72, v72, 8uLL)).u8[0];
    if (v9 != v10)
    {
LABEL_17:
      v73 = (char *)(a3 + a4 + ~v10);
      do
      {
        v74 = *v73--;
        v75 = v74 ^ ~(_BYTE)v7;
        if (v10 > v7)
          v75 = -1;
        LOBYTE(v8) = v75 & v8;
        ++v10;
      }
      while (v9 != v10);
    }
  }
LABEL_21:
  if ((_BYTE)v8 == 0xFF)
    v76 = -1;
  else
    v76 = 0;
  *a2 = a4 - ((v7 + 1) & v76);
  *a1 = v76;
  return 1;
}

uint64_t EVP_tls_cbc_copy_mac(uint64_t __dst, size_t __n, uint64_t a3, uint64_t a4, size_t a5)
{
  void *v9;
  size_t v10;
  size_t v11;
  size_t v12;
  char v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  uint64_t v20;
  char *p_src;
  char *v23;
  size_t v24;
  uint64_t v25;
  char *v26;
  size_t v27;
  size_t v28;
  size_t v29;
  char *v30;
  char __src;
  _BYTE v32[64];
  uint64_t v33;

  v9 = (void *)__dst;
  v33 = *MEMORY[0x24BDAC8D0];
  v10 = __n + 256;
  if (a5 >= __n + 256)
    v11 = a5 - (__n + 256);
  else
    v11 = 0;
  if (__n)
    __dst = __memset_chk();
  if (v11 >= a5)
  {
    v14 = 0;
    if (__n >= 2)
      goto LABEL_17;
  }
  else
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    if (a5 >= v10)
      v15 = v10;
    else
      v15 = a5;
    v16 = -v15;
    do
    {
      v17 = a5 + v16;
      if (v12 >= __n)
        v18 = __n;
      else
        v18 = 0;
      v19 = v12 - v18;
      v20 = (uint64_t)(((v17 ^ (a4 - __n)) - 1) & ~(v17 ^ (a4 - __n))) >> 63;
      v13 |= v20;
      __dst = v32[v19];
      v32[v19] = ((uint64_t)(((a5 - a4 + v16) ^ v17 | v17 ^ a4) ^ v17) >> 63) & *(_BYTE *)(a3 + a5 + v16) & v13 | __dst;
      v14 |= v20 & v19;
      v12 = v19 + 1;
    }
    while (!__CFADD__(v16++, 1));
    if (__n >= 2)
    {
LABEL_17:
      p_src = &__src;
      v23 = v32;
      v24 = 1;
      do
      {
        v25 = 0;
        v26 = v23;
        v27 = v24;
        do
        {
          if (v27 >= __n)
            v28 = __n;
          else
            v28 = 0;
          v29 = v27 - v28;
          p_src[v25] = v23[v29] & ~((v14 & 1) - 1) | v23[v25] & ((v14 & 1) - 1);
          ++v25;
          v27 = v29 + 1;
        }
        while (__n != v25);
        v24 *= 2;
        v14 >>= 1;
        v30 = p_src;
        v23 = p_src;
        p_src = v26;
      }
      while (v24 < __n);
      return (uint64_t)memcpy(v9, v30, __n);
    }
  }
  v30 = v32;
  if (__n)
    return (uint64_t)memcpy(v9, v30, __n);
  return __dst;
}

uint64_t EVP_tls_cbc_digest_record(_DWORD *a1, unsigned __int8 *a2, uint64_t *a3, const void *a4, char *a5, uint64_t a6, unint64_t a7, uint64_t a8, unsigned int a9)
{
  __int128 v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  __int8 v20;
  uint64_t result;
  __int128 v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  __int8 v27;
  uint8x8_t v28;
  int16x8_t v29;
  size_t v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int v36;
  uint64_t v37;
  int8x16_t v38;
  int64x2_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  size_t v43;
  unint64_t v44;
  unint64_t v45;
  int64x2_t v46;
  int8x16_t v47;
  unint64_t v48;
  unint64_t v49;
  int64x2_t v50;
  int64x2_t v51;
  int64x2_t v52;
  int64x2_t v53;
  int64x2_t v54;
  unint64_t v55;
  int8x8_t *v56;
  int64x2_t v57;
  int8x16_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t v64;
  int8x16_t v65;
  int64x2_t v66;
  int64x2_t v67;
  int64x2_t v68;
  int64x2_t v69;
  int64x2_t v70;
  int64x2_t v71;
  int64x2_t v72;
  int64x2_t v73;
  int64x2_t v74;
  int64x2_t v75;
  int64x2_t v76;
  int64x2_t v77;
  int64x2_t v78;
  int8x16_t *v79;
  unint64_t v80;
  int64x2_t v81;
  int8x16_t v82;
  int8x16_t v83;
  int8x16_t v84;
  int8x16_t v85;
  int8x16_t v86;
  int8x16_t v87;
  int8x16_t v88;
  int8x16_t v89;
  int8x16_t v90;
  int8x16_t v91;
  int8x16_t v92;
  int8x16_t v93;
  int8x16_t v94;
  int8x16_t v95;
  int8x16_t v96;
  int8x16_t v97;
  int64x2_t v98;
  int64x2_t v99;
  int64x2_t v100;
  int64x2_t v101;
  int64x2_t v102;
  int64x2_t v103;
  int64x2_t v104;
  unint64_t v105;
  _BYTE *v106;
  unint64_t v107;
  BOOL v108;
  uint8x8_t v109;
  int16x8_t v110;
  size_t v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  int v116;
  unint64_t v117;
  uint64_t v118;
  int8x16_t v119;
  int64x2_t v120;
  uint64_t v121;
  int8x16_t v122;
  unint64_t num;
  unint64_t v124;
  size_t v125;
  unint64_t v126;
  unint64_t v127;
  int64x2_t v128;
  int8x16_t v129;
  unint64_t v130;
  unint64_t v131;
  int64x2_t v132;
  int64x2_t v133;
  int64x2_t v134;
  int64x2_t v135;
  int64x2_t v136;
  unint64_t v137;
  int8x8_t *v138;
  int64x2_t v139;
  int8x16_t v140;
  int8x16_t v141;
  int8x16_t v142;
  int8x16_t v143;
  int8x16_t v144;
  int8x16_t v145;
  int8x16_t v146;
  int8x16_t v147;
  int64x2_t v148;
  int64x2_t v149;
  int64x2_t v150;
  int64x2_t v151;
  int64x2_t v152;
  int64x2_t v153;
  int64x2_t v154;
  int64x2_t v155;
  int64x2_t v156;
  int64x2_t v157;
  int64x2_t v158;
  int64x2_t v159;
  int64x2_t v160;
  int8x16_t *v161;
  unint64_t v162;
  int64x2_t v163;
  int8x16_t v164;
  int8x16_t v165;
  int8x16_t v166;
  int8x16_t v167;
  int8x16_t v168;
  int8x16_t v169;
  int8x16_t v170;
  int8x16_t v171;
  int8x16_t v172;
  int8x16_t v173;
  int8x16_t v174;
  int8x16_t v175;
  int8x16_t v176;
  int8x16_t v177;
  int8x16_t v178;
  int8x16_t v179;
  int64x2_t v180;
  int64x2_t v181;
  int64x2_t v182;
  int64x2_t v183;
  int64x2_t v184;
  int64x2_t v185;
  int64x2_t v186;
  unint64_t v187;
  _BYTE *v188;
  unint64_t v189;
  int8x16_t v190;
  uint64_t v191;
  int8x16_t v192;
  unsigned __int8 *md;
  unsigned __int8 *mda;
  uint64_t *v195;
  char *v196;
  char *v197;
  unint64_t v198;
  unint64_t v199;
  unint64_t v200;
  unint64_t v201;
  unint64_t v202;
  int64x2_t v203;
  int64x2_t v204;
  int8x16_t v205;
  int8x16_t v206;
  int8x16_t v207;
  int8x16_t v208;
  int8x16_t v209;
  SHA256_CTX c;
  int8x16_t data;
  int8x16_t v212;
  int8x16_t v213[2];
  __int128 v214;
  __int128 v215;
  __int128 v216;
  __int128 v217;
  uint64_t v218;
  int8x16x4_t v219;
  int8x16x4_t v220;
  int8x16x4_t v221;
  int8x16x4_t v222;

  v218 = *MEMORY[0x24BDAC8D0];
  if (*a1 != 672)
  {
    if (*a1 != 64)
    {
      result = 0;
      *a3 = 0;
      return result;
    }
    if (a9 <= 0x40)
    {
      v15 = 0uLL;
      memset(v213, 0, sizeof(v213));
      data = 0u;
      v212 = 0u;
      v16.i64[0] = 0x3636363636363636;
      v16.i64[1] = 0x3636363636363636;
      if (a9)
      {
        __memcpy_chk();
        v16.i64[0] = 0x3636363636363636;
        v16.i64[1] = 0x3636363636363636;
        v17.i64[0] = 0x3636363636363636;
        v17.i64[1] = 0x3636363636363636;
        v18 = veorq_s8(data, v17);
        v19 = veorq_s8(v212, v17);
        v15 = 0uLL;
        v20 = v213[0].i8[0] ^ 0x36;
      }
      else
      {
        v20 = 54;
        v18.i64[0] = 0x3636363636363636;
        v18.i64[1] = 0x3636363636363636;
        v19.i64[0] = 0x3636363636363636;
        v19.i64[1] = 0x3636363636363636;
      }
      data = v18;
      v212 = v19;
      v213[0].i8[0] = v20;
      *(int8x16_t *)((char *)v213 + 1) = veorq_s8(*(int8x16_t *)((char *)v213 + 1), v16);
      v28 = (uint8x8_t)veor_s8(*(int8x8_t *)&v213[1].i8[1], (int8x8_t)0x3636363636363636);
      *(uint8x8_t *)&v213[1].i8[1] = v28;
      v28.i32[0] = *(__int32 *)((char *)&v213[1].i32[2] + 1);
      v29 = (int16x8_t)vmovl_u8(v28);
      *(int8x8_t *)v29.i8 = veor_s8(*(int8x8_t *)v29.i8, (int8x8_t)0x36003600360036);
      *(__int32 *)((char *)&v213[1].i32[2] + 1) = vmovn_s16(v29).u32[0];
      *(__int16 *)((char *)&v213[1].i16[6] + 1) ^= 0x3636u;
      v213[1].i8[15] ^= 0x36u;
      *(_OWORD *)&c.data[10] = v15;
      *(_OWORD *)&c.data[7] = v15;
      *(_OWORD *)&c.data[3] = v15;
      *(_OWORD *)&c.Nh = v15;
      *(_OWORD *)&c.h[5] = v15;
      *(_OWORD *)c.h = xmmword_208F1E4D0;
      c.h[4] = -1009589776;
      SHA1_Update((SHA_CTX *)&c, &data, 0x40uLL);
      SHA1_Update((SHA_CTX *)&c, a4, 0xDuLL);
      if (a7 >= 0x114)
        v30 = a7 - 276;
      else
        v30 = 0;
      SHA1_Update((SHA_CTX *)&c, a5, v30);
      result = 0;
      v31 = a7 - v30;
      if ((a7 - v30) >> 61)
        return result;
      if (c.h[6])
        return result;
      result = 0;
      if (__CFADD__(c.h[5], 8 * v31) || (c.h[5] + 8 * v31) >> 32)
        return result;
      md = a2;
      v195 = a3;
      v32 = 0;
      v33 = 0;
      v34 = 0;
      v196 = &a5[v30];
      v35 = (a6 - v30 + c.data[13] + 72) >> 6;
      v36 = c.h[5] + 8 * (a6 - v30);
      v202 = v35 - 1;
      v216 = 0u;
      v217 = 0u;
      v214 = 0u;
      v215 = 0u;
      v206 = 0u;
      v198 = a6 - v30;
      v200 = (v31 + c.data[13] + 72) >> 6;
      v37 = -(uint64_t)v35;
      v38 = (int8x16_t)xmmword_208F2AF30;
      v39 = vdupq_n_s64(8uLL);
      v204 = v39;
      while (1)
      {
        if (v33 || (v41 = c.data[13]) == 0)
        {
          v41 = 0;
          v42 = v31 - v34;
          if (v31 <= v34)
            goto LABEL_32;
        }
        else
        {
          __memcpy_chk();
          v38 = (int8x16_t)xmmword_208F2AF30;
          v39 = v204;
          v42 = v31 - v34;
          if (v31 <= v34)
            goto LABEL_32;
        }
        if (64 - v41 >= v42)
          v43 = v42;
        else
          v43 = 64 - v41;
        if (v43)
        {
          memcpy((char *)&v214 + v41, &v196[v34], v43);
          v38 = (int8x16_t)xmmword_208F2AF30;
          v39 = v204;
        }
LABEL_32:
        if (v41 <= 0x3F)
        {
          v44 = 64 - v41;
          v45 = v41;
          if (64 - v41 >= 8)
          {
            v46 = vdupq_n_s64(v34 - v41);
            v47 = (int8x16_t)vdupq_n_s64(v198);
            if (v44 >= 0x10)
            {
              v48 = v44 & 0xFFFFFFFFFFFFFFF0;
              v70 = vdupq_n_s64(v41);
              v71 = vaddq_s64(v70, (int64x2_t)xmmword_208F30EC0);
              v72 = vaddq_s64(v70, (int64x2_t)xmmword_208F30ED0);
              v73 = vaddq_s64(v70, (int64x2_t)xmmword_208F30EE0);
              v74 = vaddq_s64(v70, (int64x2_t)xmmword_208F30EF0);
              v75 = vaddq_s64(v70, (int64x2_t)xmmword_208F30F00);
              v76 = vaddq_s64(v70, (int64x2_t)xmmword_208F30F10);
              v77 = vaddq_s64(v70, (int64x2_t)xmmword_208F08AD0);
              v78 = vaddq_s64(v70, (int64x2_t)xmmword_208F05120);
              v49 = v41 + (v44 & 0xFFFFFFFFFFFFFFF0);
              v79 = (int8x16_t *)((char *)&v214 + v41);
              v80 = v44 & 0xFFFFFFFFFFFFFFF0;
              v81.i64[0] = -1;
              v81.i64[1] = -1;
              do
              {
                v82 = (int8x16_t)vaddq_s64(v74, v46);
                v83 = (int8x16_t)vaddq_s64(v73, v46);
                v84 = (int8x16_t)vaddq_s64(v72, v46);
                v85 = (int8x16_t)vaddq_s64(v71, v46);
                v86 = (int8x16_t)vaddq_s64(v78, v46);
                v87 = (int8x16_t)vaddq_s64(v77, v46);
                v88 = (int8x16_t)vaddq_s64(v76, v46);
                v89 = (int8x16_t)vaddq_s64(v75, v46);
                v90 = veorq_s8(v89, v47);
                v91 = veorq_s8(v88, v47);
                v92 = veorq_s8(v87, v47);
                v93 = veorq_s8(v86, v47);
                v94 = veorq_s8(v85, v47);
                v95 = veorq_s8(v84, v47);
                v96 = veorq_s8(v83, v47);
                v97 = veorq_s8(v82, v47);
                v219.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v86, (int64x2_t)v47), v86), v93), v86));
                v219.val[1] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v87, (int64x2_t)v47), v87), v92), v87));
                v219.val[2] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v88, (int64x2_t)v47), v88), v91), v88));
                v219.val[3] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v89, (int64x2_t)v47), v89), v90), v89));
                v87.i64[0] = vqtbl4q_s8(v219, (int8x16_t)xmmword_208F2AF20).u64[0];
                v98 = vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v82, (int64x2_t)v47), v82), v97), v82));
                v99 = vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v83, (int64x2_t)v47), v83), v96), v83));
                v219.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v84, (int64x2_t)v47), v84), v95), v84));
                v219.val[1] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v85, (int64x2_t)v47), v85), v94), v85));
                v82.i64[0] = vqtbl4q_s8(v219, (int8x16_t)xmmword_208F2AF20).u64[0];
                v100 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v93, v81), v93));
                v101 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v92, v81), v92));
                v219.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v91, v81), v91));
                v219.val[1] = (int8x16_t)vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v90, v81), v90));
                v90.i64[0] = vqtbl4q_s8(v219, (int8x16_t)xmmword_208F2AF20).u64[0];
                v102 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v97, v81), v97));
                v103 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v96, v81), v96));
                v219.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v95, v81), v95));
                v219.val[1] = (int8x16_t)vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v94, v81), v94));
                v87.i64[1] = v82.i64[0];
                v90.i64[1] = vqtbl4q_s8(v219, (int8x16_t)xmmword_208F2AF20).u64[0];
                v92.i64[0] = 0x8080808080808080;
                v92.i64[1] = 0x8080808080808080;
                *v79 = vorrq_s8(vandq_s8(*v79, v87), vandq_s8(v90, v92));
                ++v79;
                v104 = vdupq_n_s64(0x10uLL);
                v76 = vaddq_s64(v76, v104);
                v77 = vaddq_s64(v77, v104);
                v78 = vaddq_s64(v78, v104);
                v75 = vaddq_s64(v75, v104);
                v74 = vaddq_s64(v74, v104);
                v73 = vaddq_s64(v73, v104);
                v72 = vaddq_s64(v72, v104);
                v71 = vaddq_s64(v71, v104);
                v80 -= 16;
              }
              while (v80);
              v39 = v204;
              if (v44 == v48)
                goto LABEL_21;
              if ((v44 & 8) != 0)
                goto LABEL_36;
              v45 = v41 + v48;
            }
            else
            {
              v48 = 0;
              v49 = v41;
LABEL_36:
              v45 = v41 + (v44 & 0xFFFFFFFFFFFFFFF8);
              v50 = vdupq_n_s64(v49);
              v51 = vaddq_s64(v50, (int64x2_t)xmmword_208F30F00);
              v52 = vaddq_s64(v50, (int64x2_t)xmmword_208F30F10);
              v53 = vaddq_s64(v50, (int64x2_t)xmmword_208F08AD0);
              v54 = vaddq_s64(v50, (int64x2_t)xmmword_208F05120);
              v55 = v48 - (v44 & 0xFFFFFFFFFFFFFFF8);
              v56 = (int8x8_t *)((char *)&v214 + v41 + v48);
              v57.i64[0] = -1;
              v57.i64[1] = -1;
              do
              {
                v58 = (int8x16_t)vaddq_s64(v54, v46);
                v59 = (int8x16_t)vaddq_s64(v53, v46);
                v60 = (int8x16_t)vaddq_s64(v52, v46);
                v61 = (int8x16_t)vaddq_s64(v51, v46);
                v62 = veorq_s8(v61, v47);
                v63 = veorq_s8(v60, v47);
                v64 = veorq_s8(v59, v47);
                v65 = veorq_s8(v58, v47);
                v221.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v58, (int64x2_t)v47), v58), v65), v58));
                v221.val[1] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v59, (int64x2_t)v47), v59), v64), v59));
                v221.val[2] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v60, (int64x2_t)v47), v60), v63), v60));
                v221.val[3] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v61, (int64x2_t)v47), v61), v62), v61));
                v58.i64[0] = vqtbl4q_s8(v221, v38).u64[0];
                v66 = (int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v63, v57), v63);
                v67 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v65, v57), v65));
                v68 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v64, v57), v64));
                v69 = vcltzq_s64(v66);
                v221.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v62, v57), v62));
                *v56 = vorr_s8(vand_s8(*v56, *(int8x8_t *)v58.i8), vand_s8((int8x8_t)*(_OWORD *)&vqtbl4q_s8(v221, v38), (int8x8_t)0x8080808080808080));
                ++v56;
                v52 = vaddq_s64(v52, v39);
                v53 = vaddq_s64(v53, v39);
                v54 = vaddq_s64(v54, v39);
                v51 = vaddq_s64(v51, v39);
                v55 += 8;
              }
              while (v55);
              if (v44 == (v44 & 0xFFFFFFFFFFFFFFF8))
                goto LABEL_21;
            }
          }
          v105 = v45 - 64;
          v106 = (char *)&v214 + v45;
          v107 = v45 + v34 - v41;
          do
          {
            *v106 = *v106 & ((uint64_t)(((v107 - v198) ^ v107 | v107 ^ v198) ^ v107) >> 63) | ((((v107 ^ v198) - 1) & ~(v107 ^ v198)) >> 56) & 0x80;
            ++v106;
            ++v107;
            v108 = __CFADD__(v105++, 1);
          }
          while (!v108);
        }
LABEL_21:
        v40 = (uint64_t)(((v33 ^ v202) - 1) & v37) >> 63;
        BYTE12(v217) |= v40 & HIBYTE(v36);
        BYTE13(v217) |= v40 & BYTE2(v36);
        BYTE14(v217) |= v40 & BYTE1(v36);
        HIBYTE(v217) |= v40 & v36;
        sha1_block_data_order((int *)&c, (unsigned int *)&v214, 1);
        v38 = (int8x16_t)xmmword_208F2AF30;
        v39 = v204;
        v206 = vorrq_s8(vandq_s8(*(int8x16_t *)c.h, (int8x16_t)vdupq_n_s32(v40)), v206);
        v32 |= c.h[4] & v40;
        v34 = v34 - v41 + 64;
        if (++v33 == v200)
        {
          v208 = vrev32q_s8(v206);
          memset(&c.h[5], 0, 76);
          *(_OWORD *)c.h = xmmword_208F1E4D0;
          v190.i64[0] = 0x6A6A6A6A6A6A6A6ALL;
          v190.i64[1] = 0x6A6A6A6A6A6A6A6ALL;
          data = veorq_s8(data, v190);
          v212 = veorq_s8(v212, v190);
          v209.i32[0] = bswap32(v32);
          c.h[4] = -1009589776;
          v213[0] = veorq_s8(v213[0], v190);
          v213[1] = veorq_s8(v213[1], v190);
          SHA1_Update((SHA_CTX *)&c, &data, 0x40uLL);
          v191 = 20;
          SHA1_Update((SHA_CTX *)&c, &v208, 0x14uLL);
          SHA1_Final(md, (SHA_CTX *)&c);
          goto LABEL_88;
        }
      }
    }
    return 0;
  }
  if (a9 > 0x40)
    return 0;
  v22 = 0uLL;
  memset(v213, 0, sizeof(v213));
  data = 0u;
  v212 = 0u;
  v23.i64[0] = 0x3636363636363636;
  v23.i64[1] = 0x3636363636363636;
  if (a9)
  {
    __memcpy_chk();
    v23.i64[0] = 0x3636363636363636;
    v23.i64[1] = 0x3636363636363636;
    v24.i64[0] = 0x3636363636363636;
    v24.i64[1] = 0x3636363636363636;
    v25 = veorq_s8(data, v24);
    v26 = veorq_s8(v212, v24);
    v22 = 0uLL;
    v27 = v213[0].i8[0] ^ 0x36;
  }
  else
  {
    v27 = 54;
    v25.i64[0] = 0x3636363636363636;
    v25.i64[1] = 0x3636363636363636;
    v26.i64[0] = 0x3636363636363636;
    v26.i64[1] = 0x3636363636363636;
  }
  data = v25;
  v212 = v26;
  v213[0].i8[0] = v27;
  *(int8x16_t *)((char *)v213 + 1) = veorq_s8(*(int8x16_t *)((char *)v213 + 1), v23);
  v109 = (uint8x8_t)veor_s8(*(int8x8_t *)&v213[1].i8[1], (int8x8_t)0x3636363636363636);
  *(uint8x8_t *)&v213[1].i8[1] = v109;
  v109.i32[0] = *(__int32 *)((char *)&v213[1].i32[2] + 1);
  v110 = (int16x8_t)vmovl_u8(v109);
  *(int8x8_t *)v110.i8 = veor_s8(*(int8x8_t *)v110.i8, (int8x8_t)0x36003600360036);
  *(__int32 *)((char *)&v213[1].i32[2] + 1) = vmovn_s16(v110).u32[0];
  *(__int16 *)((char *)&v213[1].i16[6] + 1) ^= 0x3636u;
  v213[1].i8[15] ^= 0x36u;
  *(_OWORD *)&c.data[13] = v22;
  *(_OWORD *)&c.data[6] = v22;
  *(_OWORD *)&c.data[10] = v22;
  *(_OWORD *)&c.Nl = v22;
  *(_OWORD *)&c.data[2] = v22;
  *(_OWORD *)c.h = xmmword_208F25B20;
  *(_OWORD *)&c.h[4] = xmmword_208F25B30;
  c.md_len = 32;
  SHA256_Update(&c, &data, 0x40uLL);
  SHA256_Update(&c, a4, 0xDuLL);
  if (a7 >= 0x120)
    v111 = a7 - 288;
  else
    v111 = 0;
  SHA256_Update(&c, a5, v111);
  result = 0;
  v112 = a7 - v111;
  if (v112 >> 61)
    return result;
  if (c.Nh)
    return result;
  result = 0;
  if (__CFADD__(c.Nl, 8 * v112) || (c.Nl + 8 * v112) >> 32)
    return result;
  mda = a2;
  v195 = a3;
  v113 = 0;
  v114 = 0;
  v197 = &a5[v111];
  v115 = (a6 - v111 + c.num + 72) >> 6;
  v116 = c.Nl + 8 * (a6 - v111);
  v201 = v115 - 1;
  v199 = a6 - v111;
  v216 = 0u;
  v217 = 0u;
  v214 = 0u;
  v215 = 0u;
  v207 = 0u;
  v117 = (v112 + c.num + 72) >> 6;
  v118 = -(uint64_t)v115;
  v119 = (int8x16_t)xmmword_208F2AF30;
  v120 = vdupq_n_s64(8uLL);
  v203 = v120;
  v205 = 0u;
  do
  {
    if (v113 || (num = c.num) == 0)
    {
      num = 0;
      v124 = v112 - v114;
      if (v112 <= v114)
        goto LABEL_69;
    }
    else
    {
      __memcpy_chk();
      v119 = (int8x16_t)xmmword_208F2AF30;
      v120 = v203;
      v124 = v112 - v114;
      if (v112 <= v114)
        goto LABEL_69;
    }
    if (64 - num >= v124)
      v125 = v124;
    else
      v125 = 64 - num;
    if (v125)
    {
      memcpy((char *)&v214 + num, &v197[v114], v125);
      v119 = (int8x16_t)xmmword_208F2AF30;
      v120 = v203;
    }
LABEL_69:
    if (num > 0x3F)
      goto LABEL_58;
    v126 = 64 - num;
    v127 = num;
    if (64 - num < 8)
      goto LABEL_82;
    v128 = vdupq_n_s64(v114 - num);
    v129 = (int8x16_t)vdupq_n_s64(v199);
    if (v126 >= 0x10)
    {
      v130 = v126 & 0xFFFFFFFFFFFFFFF0;
      v152 = vdupq_n_s64(num);
      v153 = vaddq_s64(v152, (int64x2_t)xmmword_208F30EC0);
      v154 = vaddq_s64(v152, (int64x2_t)xmmword_208F30ED0);
      v155 = vaddq_s64(v152, (int64x2_t)xmmword_208F30EE0);
      v156 = vaddq_s64(v152, (int64x2_t)xmmword_208F30EF0);
      v157 = vaddq_s64(v152, (int64x2_t)xmmword_208F30F00);
      v158 = vaddq_s64(v152, (int64x2_t)xmmword_208F30F10);
      v159 = vaddq_s64(v152, (int64x2_t)xmmword_208F08AD0);
      v160 = vaddq_s64(v152, (int64x2_t)xmmword_208F05120);
      v131 = num + (v126 & 0xFFFFFFFFFFFFFFF0);
      v161 = (int8x16_t *)((char *)&v214 + num);
      v162 = v126 & 0xFFFFFFFFFFFFFFF0;
      v163.i64[0] = -1;
      v163.i64[1] = -1;
      do
      {
        v164 = (int8x16_t)vaddq_s64(v156, v128);
        v165 = (int8x16_t)vaddq_s64(v155, v128);
        v166 = (int8x16_t)vaddq_s64(v154, v128);
        v167 = (int8x16_t)vaddq_s64(v153, v128);
        v168 = (int8x16_t)vaddq_s64(v160, v128);
        v169 = (int8x16_t)vaddq_s64(v159, v128);
        v170 = (int8x16_t)vaddq_s64(v158, v128);
        v171 = (int8x16_t)vaddq_s64(v157, v128);
        v172 = veorq_s8(v171, v129);
        v173 = veorq_s8(v170, v129);
        v174 = veorq_s8(v169, v129);
        v175 = veorq_s8(v168, v129);
        v176 = veorq_s8(v167, v129);
        v177 = veorq_s8(v166, v129);
        v178 = veorq_s8(v165, v129);
        v179 = veorq_s8(v164, v129);
        v220.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v168, (int64x2_t)v129), v168), v175), v168));
        v220.val[1] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v169, (int64x2_t)v129), v169), v174), v169));
        v220.val[2] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v170, (int64x2_t)v129), v170), v173), v170));
        v220.val[3] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v171, (int64x2_t)v129), v171), v172), v171));
        v169.i64[0] = vqtbl4q_s8(v220, (int8x16_t)xmmword_208F2AF20).u64[0];
        v180 = vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v164, (int64x2_t)v129), v164), v179), v164));
        v181 = vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v165, (int64x2_t)v129), v165), v178), v165));
        v220.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v166, (int64x2_t)v129), v166), v177), v166));
        v220.val[1] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v167, (int64x2_t)v129), v167), v176), v167));
        v164.i64[0] = vqtbl4q_s8(v220, (int8x16_t)xmmword_208F2AF20).u64[0];
        v182 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v175, v163), v175));
        v183 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v174, v163), v174));
        v220.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v173, v163), v173));
        v220.val[1] = (int8x16_t)vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v172, v163), v172));
        v172.i64[0] = vqtbl4q_s8(v220, (int8x16_t)xmmword_208F2AF20).u64[0];
        v184 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v179, v163), v179));
        v185 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v178, v163), v178));
        v220.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v177, v163), v177));
        v220.val[1] = (int8x16_t)vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v176, v163), v176));
        v169.i64[1] = v164.i64[0];
        v172.i64[1] = vqtbl4q_s8(v220, (int8x16_t)xmmword_208F2AF20).u64[0];
        v174.i64[0] = 0x8080808080808080;
        v174.i64[1] = 0x8080808080808080;
        *v161 = vorrq_s8(vandq_s8(*v161, v169), vandq_s8(v172, v174));
        ++v161;
        v186 = vdupq_n_s64(0x10uLL);
        v158 = vaddq_s64(v158, v186);
        v159 = vaddq_s64(v159, v186);
        v160 = vaddq_s64(v160, v186);
        v157 = vaddq_s64(v157, v186);
        v156 = vaddq_s64(v156, v186);
        v155 = vaddq_s64(v155, v186);
        v154 = vaddq_s64(v154, v186);
        v153 = vaddq_s64(v153, v186);
        v162 -= 16;
      }
      while (v162);
      v120 = v203;
      if (v126 == v130)
        goto LABEL_58;
      if ((v126 & 8) == 0)
      {
        v127 = num + v130;
LABEL_82:
        v187 = v127 - 64;
        v188 = (char *)&v214 + v127;
        v189 = v127 + v114 - num;
        do
        {
          *v188 = *v188 & ((uint64_t)(((v189 - v199) ^ v189 | v189 ^ v199) ^ v189) >> 63) | ((((v189 ^ v199) - 1) & ~(v189 ^ v199)) >> 56) & 0x80;
          ++v188;
          ++v189;
          v108 = __CFADD__(v187++, 1);
        }
        while (!v108);
        goto LABEL_58;
      }
    }
    else
    {
      v130 = 0;
      v131 = num;
    }
    v127 = num + (v126 & 0xFFFFFFFFFFFFFFF8);
    v132 = vdupq_n_s64(v131);
    v133 = vaddq_s64(v132, (int64x2_t)xmmword_208F30F00);
    v134 = vaddq_s64(v132, (int64x2_t)xmmword_208F30F10);
    v135 = vaddq_s64(v132, (int64x2_t)xmmword_208F08AD0);
    v136 = vaddq_s64(v132, (int64x2_t)xmmword_208F05120);
    v137 = v130 - (v126 & 0xFFFFFFFFFFFFFFF8);
    v138 = (int8x8_t *)((char *)&v214 + num + v130);
    v139.i64[0] = -1;
    v139.i64[1] = -1;
    do
    {
      v140 = (int8x16_t)vaddq_s64(v136, v128);
      v141 = (int8x16_t)vaddq_s64(v135, v128);
      v142 = (int8x16_t)vaddq_s64(v134, v128);
      v143 = (int8x16_t)vaddq_s64(v133, v128);
      v144 = veorq_s8(v143, v129);
      v145 = veorq_s8(v142, v129);
      v146 = veorq_s8(v141, v129);
      v147 = veorq_s8(v140, v129);
      v222.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v140, (int64x2_t)v129), v140), v147), v140));
      v222.val[1] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v141, (int64x2_t)v129), v141), v146), v141));
      v222.val[2] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v142, (int64x2_t)v129), v142), v145), v142));
      v222.val[3] = (int8x16_t)vcltzq_s64((int64x2_t)veorq_s8(vorrq_s8(veorq_s8((int8x16_t)vsubq_s64((int64x2_t)v143, (int64x2_t)v129), v143), v144), v143));
      v140.i64[0] = vqtbl4q_s8(v222, v119).u64[0];
      v148 = (int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v145, v139), v145);
      v149 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v147, v139), v147));
      v150 = vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v146, v139), v146));
      v151 = vcltzq_s64(v148);
      v222.val[0] = (int8x16_t)vcltzq_s64((int64x2_t)vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v144, v139), v144));
      *v138 = vorr_s8(vand_s8(*v138, *(int8x8_t *)v140.i8), vand_s8((int8x8_t)*(_OWORD *)&vqtbl4q_s8(v222, v119), (int8x8_t)0x8080808080808080));
      ++v138;
      v134 = vaddq_s64(v134, v120);
      v135 = vaddq_s64(v135, v120);
      v136 = vaddq_s64(v136, v120);
      v133 = vaddq_s64(v133, v120);
      v137 += 8;
    }
    while (v137);
    if (v126 != (v126 & 0xFFFFFFFFFFFFFFF8))
      goto LABEL_82;
LABEL_58:
    v121 = (uint64_t)(((v113 ^ v201) - 1) & v118) >> 63;
    BYTE12(v217) |= v121 & HIBYTE(v116);
    BYTE13(v217) |= v121 & BYTE2(v116);
    BYTE14(v217) |= v121 & BYTE1(v116);
    HIBYTE(v217) |= v121 & v116;
    sha256_block_data_order((unint64_t)&c, (unsigned int *)&v214, 1);
    v119 = (int8x16_t)xmmword_208F2AF30;
    v120 = v203;
    v122 = (int8x16_t)vdupq_n_s32(v121);
    v205 = vorrq_s8(vandq_s8(*(int8x16_t *)&c.h[4], v122), v205);
    v207 = vorrq_s8(vandq_s8(*(int8x16_t *)c.h, v122), v207);
    v114 = v114 - num + 64;
    ++v113;
  }
  while (v113 != v117);
  v208 = vrev32q_s8(v207);
  v209 = vrev32q_s8(v205);
  memset(&c.Nl, 0, 76);
  *(_OWORD *)c.h = xmmword_208F25B20;
  *(_OWORD *)&c.h[4] = xmmword_208F25B30;
  v191 = 32;
  c.md_len = 32;
  v192.i64[0] = 0x6A6A6A6A6A6A6A6ALL;
  v192.i64[1] = 0x6A6A6A6A6A6A6A6ALL;
  data = veorq_s8(data, v192);
  v212 = veorq_s8(v212, v192);
  v213[0] = veorq_s8(v213[0], v192);
  v213[1] = veorq_s8(v213[1], v192);
  SHA256_Update(&c, &data, 0x40uLL);
  SHA256_Update(&c, &v208, 0x20uLL);
  sha256_final_impl(mda, c.md_len, (int32x2_t *)&c);
LABEL_88:
  *v195 = v191;
  return 1;
}

uint64_t bssl::ssl_noop_x509_check_client_CA_names()
{
  return 1;
}

uint64_t bssl::ssl_noop_x509_session_cache_objects(bssl *this, ssl_session_st *a2)
{
  return 1;
}

uint64_t bssl::ssl_noop_x509_session_dup(bssl *this, ssl_session_st *a2, const ssl_session_st *a3)
{
  return 1;
}

uint64_t bssl::ssl_noop_x509_session_verify_cert_chain()
{
  return 0;
}

uint64_t bssl::ssl_noop_x509_ssl_new()
{
  return 1;
}

uint64_t bssl::ssl_noop_x509_ssl_auto_chain_if_needed()
{
  return 1;
}

uint64_t bssl::ssl_noop_x509_ssl_ctx_new(bssl *this, ssl_ctx_st *a2)
{
  return 1;
}

void bssl::tls_on_handshake_complete(bssl *this, ssl_st *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  size_t v7;
  _QWORD *v8;
  uint64_t v9;
  size_t v10;

  v2 = *((_QWORD *)this + 6);
  v3 = *(_QWORD **)(v2 + 224);
  if (v3 && !*v3)
  {
    *(_QWORD *)(v2 + 224) = 0;
    v4 = v3[1];
    if (v4)
    {
      v6 = *(_QWORD *)(v4 - 8);
      v5 = (void *)(v4 - 8);
      v7 = v6 + 8;
      if (v6 != -8)
        bzero(v5, v7);
      free(v5);
    }
    v9 = *(v3 - 1);
    v8 = v3 - 1;
    v10 = v9 + 8;
    if (v9 != -8)
      bzero(v8, v10);
    free(v8);
  }
}

uint64_t bssl::tls_set_read_state(bssl *a1, uint64_t a2, _QWORD **a3)
{
  int v4;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t result;
  uint64_t (**v12)(bssl *, uint64_t, _QWORD);
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  size_t v19;

  v4 = a2;
  v6 = *((_QWORD *)a1 + 6);
  v7 = *(unint64_t **)(v6 + 224);
  if ((*(_WORD *)(v6 + 220) & 0x10) == 0)
  {
    if (!v7 || !*v7)
      goto LABEL_13;
LABEL_11:
    ERR_put_error(16, 0, 255, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_method.cc", 90);
    bssl::ssl_send_alert(a1, (ssl_st *)2, 10);
    return 0;
  }
  if (v7)
  {
    v8 = *v7;
    v9 = *v7 - 4;
    if (*v7 >= 4)
    {
      v10 = (*(unsigned __int8 *)(v7[1] + 1) << 16) | (*(unsigned __int8 *)(v7[1] + 2) << 8) | *(unsigned __int8 *)(v7[1] + 3);
      if (v9 >= v10 && v8 <= (v10 + 4))
        goto LABEL_13;
      goto LABEL_11;
    }
    if (v8)
      goto LABEL_11;
  }
LABEL_13:
  v12 = (uint64_t (**)(bssl *, uint64_t, _QWORD))*((_QWORD *)a1 + 19);
  if (!v12)
    goto LABEL_19;
  v13 = *(_QWORD *)(v6 + 280);
  if (v13 && (*(_BYTE *)(v13 + 1570) & 8) != 0 || (result = (*v12)(a1, a2, **a3), (_DWORD)result))
  {
    if (v4 == 1)
      return 1;
    v6 = *((_QWORD *)a1 + 6);
LABEL_19:
    *(_QWORD *)v6 = 0;
    v14 = *a3;
    *a3 = 0;
    v15 = *(_QWORD *)(v6 + 264);
    *(_QWORD *)(v6 + 264) = v14;
    if (v15)
    {
      v16 = *(_QWORD *)(v15 + 8);
      if (v16)
      {
        (*(void (**)(uint64_t))(v16 + 24))(v15 + 8);
        *(_QWORD *)(v15 + 8) = 0;
      }
      v18 = *(_QWORD *)(v15 - 8);
      v17 = (void *)(v15 - 8);
      v19 = v18 + 8;
      if (v18 != -8)
        bzero(v17, v19);
      free(v17);
    }
    *(_DWORD *)(*((_QWORD *)a1 + 6) + 200) = v4;
    return 1;
  }
  return result;
}

uint64_t bssl::tls_set_write_state(bssl *a1, ssl_st *a2, _QWORD **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  size_t v22;

  result = bssl::tls_flush_pending_hs_data(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    v14 = *((_QWORD *)a1 + 19);
    if (!v14)
      goto LABEL_7;
    v15 = *(_QWORD *)(*((_QWORD *)a1 + 6) + 280);
    if (v15 && (*(_BYTE *)(v15 + 1570) & 8) != 0
      || (result = (*(uint64_t (**)(bssl *, ssl_st *, _QWORD, uint64_t, uint64_t))(v14 + 8))(a1, a2, **a3, a4, a5), (_DWORD)result))
    {
      if ((_DWORD)a2 == 1)
        return 1;
LABEL_7:
      v16 = *((_QWORD *)a1 + 6);
      *(_QWORD *)(v16 + 8) = 0;
      v17 = *a3;
      *a3 = 0;
      v18 = *(_QWORD *)(v16 + 272);
      *(_QWORD *)(v16 + 272) = v17;
      if (v18)
      {
        v19 = *(_QWORD *)(v18 + 8);
        if (v19)
        {
          (*(void (**)(uint64_t))(v19 + 24))(v18 + 8);
          *(_QWORD *)(v18 + 8) = 0;
        }
        v21 = *(_QWORD *)(v18 - 8);
        v20 = (void *)(v18 - 8);
        v22 = v21 + 8;
        if (v21 != -8)
          bzero(v20, v22);
        free(v20);
      }
      *(_DWORD *)(*((_QWORD *)a1 + 6) + 204) = (_DWORD)a2;
      return 1;
    }
  }
  return result;
}

uint64_t bssl::ssl_seal_align_prefix_len(bssl *this, const ssl_st *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  unsigned int v7;
  uint64_t v9;
  int v10;

  v3 = *(uint64_t **)(*((_QWORD *)this + 6) + 272);
  if ((*((_BYTE *)v3 + 609) & 1) != 0)
  {
    v4 = *((unsigned __int8 *)v3 + 605);
    if (**(_BYTE **)this)
      return v4 + 13;
  }
  else
  {
    v4 = 0;
    if (**(_BYTE **)this)
      return v4 + 13;
  }
  result = v4 + 5;
  v6 = *v3;
  if (*v3)
  {
    v7 = *((unsigned __int16 *)v3 + 303);
    if (v7 - 769 >= 4)
    {
      if (v7 == 65277 || v7 == 65279)
        return result;
    }
    else if (v7 > 0x301)
    {
      return result;
    }
    if ((*((_BYTE *)this + 133) & 1) != 0 && *(_DWORD *)(v6 + 32) != 4)
    {
      v9 = v4 + 10;
      v10 = *(_DWORD *)(v6 + 28);
      if (v10 == 1)
      {
        return v9 + 24;
      }
      else if (v10 == 4 || v10 == 2)
      {
        return v9 + 32;
      }
      else
      {
        return v9;
      }
    }
  }
  return result;
}

uint64_t bssl::tls_open_record(bssl *a1, _BYTE *a2, uint64_t a3, uint64_t *a4, ssl_st *a5, unsigned __int8 *a6, unint64_t a7)
{
  uint64_t result;
  const ssl_st *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  char v24;
  unint64_t v25;
  int v26;
  int v27;
  unint64_t v28;
  uint64_t v29;
  void (*v30)(_QWORD, _QWORD, uint64_t, unsigned __int8 *);
  unsigned __int8 *v31;
  __int16 v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  int v37;
  BOOL v38;
  const ssl_st *v39;
  uint64_t v40;
  __int16 v41;
  _QWORD *v42;
  bssl::SSLAEADContext *v43;
  unsigned int v44;
  unint64_t v45;
  unint64_t v46;
  int v47;
  bssl *v48;
  uint64_t v49;
  unsigned int v50;
  char v51;
  __int128 v52;
  unsigned __int8 *v53;
  uint64_t v54;
  int v55;

  *a4 = 0;
  if (*(_DWORD *)(*((_QWORD *)a1 + 6) + 172) == 1)
    return 3;
  if (!bssl::tls_can_accept_handshake_data(a1, a5, (unsigned __int8 *)a3))
    return 4;
  if (a7 <= 2 || a7 - 3 <= 1)
  {
    v17 = 5;
LABEL_7:
    *a4 = v17;
    return 2;
  }
  v18 = *a6;
  v19 = a6[1];
  v20 = a6[2] | (v19 << 8);
  v21 = *((_QWORD *)a1 + 6);
  v22 = *(_QWORD *)(v21 + 264);
  if (!*(_QWORD *)v22)
  {
    if (v19 == 3)
      goto LABEL_19;
LABEL_13:
    ERR_put_error(16, 0, 247, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", 231);
    v24 = 70;
LABEL_22:
    LOBYTE(a5->version) = v24;
    return 4;
  }
  v23 = *(unsigned __int16 *)(v22 + 606);
  if (v23 - 769 >= 4)
  {
    if (!*(_WORD *)(v22 + 606))
    {
      if (*(_BYTE *)(v22 + 608))
        LOWORD(v23) = -257;
      else
        LOWORD(v23) = 769;
    }
  }
  else if (v23 > 0x303)
  {
    LOWORD(v23) = 771;
  }
  if (v20 != (unsigned __int16)v23)
    goto LABEL_13;
LABEL_19:
  v25 = __rev16(*(unsigned __int16 *)(a6 + 3));
  if (v25 >= 0x4141)
  {
    v26 = 146;
    v27 = 238;
LABEL_21:
    ERR_put_error(16, 0, v26, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", v27);
    v24 = 22;
    goto LABEL_22;
  }
  v28 = v25 - (a7 - 5);
  if (v25 > a7 - 5)
  {
    v17 = v25 + 5;
    goto LABEL_7;
  }
  if (a7 >= 5)
    v29 = 5;
  else
    v29 = a7;
  v30 = (void (*)(_QWORD, _QWORD, uint64_t, unsigned __int8 *))*((_QWORD *)a1 + 8);
  v55 = *a6;
  v54 = v29;
  if (v30)
  {
    v30(0, 0, 256, a6);
    v28 = v25 - (a7 - 5);
    v18 = v55;
    v21 = *((_QWORD *)a1 + 6);
  }
  v31 = (unsigned __int8 *)(v28 + a7);
  *a4 = v28 + a7;
  v32 = *(_WORD *)(v21 + 220);
  if ((v32 & 2) != 0)
  {
    v53 = v31;
    v33 = bssl::ssl_protocol_version(a1, v15);
    v31 = v53;
    v18 = v55;
    if (v33 >= 0x304)
    {
      v34 = *(_QWORD *)(v21 + 280);
      if (v34)
      {
        if ((*(_BYTE *)(v34 + 1568) & 8) == 0 && v55 == 20 && (_DWORD)v25 == 1 && a6[5] == 1)
        {
          v35 = ++*(_BYTE *)(v21 + 210);
          if (v35 >= 0x21)
          {
            v36 = 219;
            v37 = 263;
LABEL_74:
            ERR_put_error(16, 0, v36, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", v37);
            v24 = 10;
            goto LABEL_22;
          }
          return 1;
        }
      }
    }
  }
  if ((v32 & 1) != 0 && !**(_QWORD **)(v21 + 264) && v18 == 23)
  {
    v48 = (bssl *)v21;
    return bssl::skip_early_data(v48, a5, v31);
  }
  if (*(_QWORD *)v21 == -1)
  {
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", 280);
    v24 = 80;
    goto LABEL_22;
  }
  *(_QWORD *)&v52 = a6 + 5;
  *((_QWORD *)&v52 + 1) = v25;
  v38 = bssl::SSLAEADContext::Open(*(int8x16_t **)(v21 + 264), a3, v18, v20, *(_QWORD *)v21, (uint64_t)a6, v54, v16, v52);
  v40 = *((_QWORD *)a1 + 6);
  v41 = *(_WORD *)(v40 + 220);
  if (!v38)
  {
    if ((v41 & 1) == 0 || !**(_QWORD **)(v40 + 264))
    {
      ERR_put_error(16, 0, 139, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", 294);
      v24 = 20;
      goto LABEL_22;
    }
    ERR_clear_error();
    v31 = (unsigned __int8 *)*a4;
    v48 = (bssl *)*((_QWORD *)a1 + 6);
    return bssl::skip_early_data(v48, a5, v31);
  }
  *(_WORD *)(v40 + 220) = v41 & 0xFFFE;
  v42 = (_QWORD *)*((_QWORD *)a1 + 6);
  ++*v42;
  v43 = (bssl::SSLAEADContext *)v42[33];
  if (*(_QWORD *)v43)
  {
    v44 = bssl::SSLAEADContext::ProtocolVersion(v43);
    v45 = 0x4000;
    if (v44 > 0x303)
      v45 = 16385;
    v46 = *(_QWORD *)(a3 + 8);
    v47 = v55;
    if (v46 <= v45)
    {
      if (v44 >= 0x304)
      {
        if (v55 == 23)
        {
          while (v46)
          {
            v47 = *(unsigned __int8 *)(*(_QWORD *)a3 + v46 - 1);
            if (v46 >= v46 - 1)
              --v46;
            *(_QWORD *)(a3 + 8) = v46;
            if (v47)
              goto LABEL_65;
          }
          ERR_put_error(16, 0, 139, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", 327);
          v24 = 51;
        }
        else
        {
          ERR_put_error(16, 0, 251, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", 320);
          v24 = 50;
        }
        goto LABEL_22;
      }
      goto LABEL_65;
    }
LABEL_64:
    v26 = 136;
    v27 = 312;
    goto LABEL_21;
  }
  v46 = *(_QWORD *)(a3 + 8);
  v47 = v55;
  if (v46 > 0x4000)
    goto LABEL_64;
LABEL_65:
  v49 = *((_QWORD *)a1 + 6);
  if (v46)
  {
    *(_BYTE *)(v49 + 210) = 0;
  }
  else
  {
    v50 = ++*(_BYTE *)(v49 + 210);
    if (v50 >= 0x21)
    {
      v36 = 219;
      v37 = 340;
      goto LABEL_74;
    }
  }
  if (v47 != 22)
  {
    if (v47 == 21)
      return bssl::ssl_process_alert((uint64_t)a1, a5, *(unsigned __int8 **)a3, v46);
    v51 = v47;
    if (bssl::tls_has_unprocessed_handshake_data(a1, v39))
    {
      v36 = 225;
      v37 = 357;
      goto LABEL_74;
    }
    v49 = *((_QWORD *)a1 + 6);
    LOBYTE(v47) = v51;
  }
  result = 0;
  *(_BYTE *)(v49 + 211) = 0;
  *a2 = v47;
  return result;
}

uint64_t bssl::skip_early_data(bssl *this, ssl_st *a2, unsigned __int8 *a3)
{
  unsigned __int16 v4;

  v4 = *((_WORD *)this + 104) + (_WORD)a3;
  *((_WORD *)this + 104) = v4;
  if ((unint64_t)a3 > v4)
  {
    *((_WORD *)this + 104) = 16385;
LABEL_4:
    ERR_put_error(16, 0, 270, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", 187);
    LOBYTE(a2->version) = 10;
    return 4;
  }
  if (v4 > 0x4000u)
    goto LABEL_4;
  return 1;
}

uint64_t bssl::ssl_process_alert(uint64_t a1, _BYTE *a2, unsigned __int8 *a3, uint64_t a4)
{
  void (*v7)(_QWORD, _QWORD, uint64_t, unsigned __int8 *, uint64_t, uint64_t, _QWORD);
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  void (*v14)(uint64_t, uint64_t, _QWORD);
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v25;

  if (a4 != 2)
  {
    *a2 = 50;
    v10 = 102;
    v11 = 551;
LABEL_25:
    ERR_put_error(16, 0, v10, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", v11);
    return 4;
  }
  v7 = *(void (**)(_QWORD, _QWORD, uint64_t, unsigned __int8 *, uint64_t, uint64_t, _QWORD))(a1 + 64);
  if (v7)
  {
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 280);
    if (v8 && (*(_BYTE *)(v8 + 1569) & 4) != 0 && (*(_BYTE *)(a1 + 164) & 1) == 0)
      v9 = (unsigned __int16 *)(*(_QWORD *)(v8 + 1512) + 4);
    else
      v9 = (unsigned __int16 *)(a1 + 16);
    v7(0, *v9, 21, a3, 2, a1, *(_QWORD *)(a1 + 72));
  }
  v12 = *a3;
  v13 = a3[1];
  v14 = *(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 96);
  if (v14 || (v14 = *(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 104) + 384)) != 0)
    v14(a1, 16388, v13 | (v12 << 8));
  if (v12 == 2)
  {
    ERR_put_error(16, 0, v13 + 1000, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", 592);
    ERR_add_error_dataf("SSL alert number %d", v17, v18, v19, v20, v21, v22, v23, v13);
    *a2 = 0;
    return 4;
  }
  if (v12 != 1)
  {
    *a2 = 47;
    v10 = 227;
    v11 = 599;
    goto LABEL_25;
  }
  v15 = *(_QWORD *)(a1 + 48);
  if (v13)
  {
    if ((*(_WORD *)(v15 + 220) & 2) != 0)
    {
      v16 = *(unsigned __int16 *)(a1 + 16);
      if (v16 - 769 <= 3 && v13 != 90 && v16 >= 0x304)
      {
        *a2 = 50;
        v10 = 102;
        v11 = 578;
        goto LABEL_25;
      }
    }
    v25 = ++*(_BYTE *)(v15 + 211);
    if (v25 >= 5)
    {
      *a2 = 10;
      v10 = 220;
      v11 = 585;
      goto LABEL_25;
    }
    return 1;
  }
  else
  {
    *(_DWORD *)(v15 + 172) = 1;
    return 3;
  }
}

uint64_t bssl::tls_seal_record(bssl *this, ssl_st *a2, unsigned __int8 *a3, unint64_t *a4, unsigned __int8 *a5, unint64_t a6, const unsigned __int8 *a7, int a8)
{
  _BOOL4 v17;
  uint64_t *v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v24;
  _BOOL8 v25;
  const unsigned __int8 *v26;
  uint64_t v27;
  const unsigned __int8 *v28;
  BOOL v29;
  uint64_t (*v30)(uint64_t, const unsigned __int8 *, _BOOL8);
  unint64_t v31;
  uint64_t result;
  char *v33;
  char *v34;
  bssl::SSLAEADContext *v35;
  int v36;
  int v38;
  unint64_t v39;
  int v40;
  char v41;
  unint64_t v42;

  if ((unint64_t *)((char *)a4 + (_QWORD)a2) > (unint64_t *)a6 && &a7[a6] > (const unsigned __int8 *)a2)
  {
    v21 = 189;
    v22 = 516;
LABEL_56:
    ERR_put_error(16, 0, v21, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", v22);
    return 0;
  }
  v17 = (_DWORD)a5 == 23 && (unint64_t)a7 > 1;
  v18 = *(uint64_t **)(*((_QWORD *)this + 6) + 272);
  if (!v17)
    goto LABEL_23;
  v19 = *v18;
  if (!*v18)
    goto LABEL_23;
  v20 = *((unsigned __int16 *)v18 + 303);
  if (v20 - 769 >= 4)
  {
    if (v20 != 65277 && v20 != 65279)
      goto LABEL_21;
LABEL_23:
    if ((*((_BYTE *)v18 + 609) & 1) != 0)
    {
      v24 = *((unsigned __int8 *)v18 + 605) + 5;
      v19 = *v18;
      if (*v18)
        goto LABEL_25;
    }
    else
    {
      v24 = 5;
      v19 = *v18;
      if (*v18)
      {
LABEL_25:
        v20 = *((unsigned __int16 *)v18 + 303);
        goto LABEL_26;
      }
    }
    v27 = 0;
    v28 = &a7[v24];
    if (__CFADD__(v24, a7))
      goto LABEL_55;
    goto LABEL_53;
  }
  if (v20 > 0x301)
    goto LABEL_23;
LABEL_21:
  if ((*((_BYTE *)this + 133) & 1) == 0 || *(_DWORD *)(v19 + 32) == 4)
    goto LABEL_23;
  v36 = *(_DWORD *)(v19 + 28);
  if (v36 == 1)
  {
    v24 = 33;
  }
  else if (v36 == 4 || v36 == 2)
  {
    v24 = 41;
  }
  else
  {
    v24 = 9;
  }
LABEL_26:
  if (v20 - 769 >= 4)
  {
    if (v20 == 65277)
    {
      v25 = 0;
      v26 = a7;
      if (!v17)
        goto LABEL_48;
    }
    else if (v20 == 65279)
    {
      v25 = 0;
      v26 = a7;
      if (!v17)
        goto LABEL_48;
    }
    else
    {
      v25 = 0;
      v26 = a7;
      if (!v17)
        goto LABEL_48;
    }
  }
  else
  {
    v25 = v20 > 0x303;
    v26 = a7;
    if (!v17)
      goto LABEL_48;
  }
  if (v20 - 769 < 4)
  {
    v26 = a7;
    if (v20 > 0x301)
      goto LABEL_48;
    goto LABEL_43;
  }
  v29 = v20 == 65277 || v20 == 65279;
  v26 = a7;
  if (!v29)
  {
LABEL_43:
    v26 = a7;
    if ((*((_BYTE *)this + 133) & 1) != 0)
      v26 = &a7[-(*(_DWORD *)(v19 + 32) != 4)];
  }
LABEL_48:
  v30 = *(uint64_t (**)(uint64_t, const unsigned __int8 *, _BOOL8))(v18[1] + 64);
  if (v30)
  {
    v27 = v30((uint64_t)(v18 + 1), v26, v25);
    v28 = &a7[v24];
    if (__CFADD__(v24, a7))
      goto LABEL_55;
  }
  else
  {
    v27 = *((unsigned __int8 *)v18 + 584) + v25;
    v28 = &a7[v24];
    if (__CFADD__(v24, a7))
    {
LABEL_55:
      v21 = 200;
      v22 = 527;
      goto LABEL_56;
    }
  }
LABEL_53:
  v31 = (unint64_t)&v28[v27];
  if (__CFADD__(v27, v28))
    goto LABEL_55;
  if (v31 > (unint64_t)a4)
  {
    v21 = 121;
    v22 = 531;
    goto LABEL_56;
  }
  v33 = (char *)a2 + v24;
  v34 = (char *)&a7[(_QWORD)a2 + v24];
  if (!v17
    || (v35 = *(bssl::SSLAEADContext **)(*((_QWORD *)this + 6) + 272), !*(_QWORD *)v35)
    || bssl::SSLAEADContext::ProtocolVersion(v35) > 0x301
    || (*((_BYTE *)this + 133) & 1) == 0
    || *(_DWORD *)(**(_QWORD **)(*((_QWORD *)this + 6) + 272) + 32) == 4)
  {
    if ((bssl::do_seal_record(this, a2, v33, v34, a5, (char *)a6, a7, a8) & 1) == 0)
      return 0;
LABEL_67:
    *(_QWORD *)a3 = v31;
    return 1;
  }
  result = bssl::do_seal_record(this, a2, (char *)&a2->type + 1, (char *)&a2->type + 2, (unsigned __int8 *)0x17, (char *)a6, (const unsigned __int8 *)1, a8);
  if ((_DWORD)result)
  {
    v42 = 0;
    if ((bssl::SSLAEADContext::SuffixLen(*(bssl::SSLAEADContext **)(*((_QWORD *)this + 6) + 272), &v42, 1, 0) & 1) == 0)
      return 0;
    v39 = v42;
    result = bssl::do_seal_record(this, (ssl_st *)&v40, v33 + 1, v34, (unsigned __int8 *)0x17, (char *)(a6 + 1), a7 - 1, v38);
    if ((_DWORD)result)
    {
      *(int *)((char *)&a2->type + v39 + 2) = v40;
      *v33 = v41;
      goto LABEL_67;
    }
  }
  return result;
}

uint64_t SSL_max_seal_overhead(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;

  v1 = *(uint64_t **)(*(_QWORD *)(a1 + 48) + 272);
  if (!**(_BYTE **)a1)
  {
    if ((*((_BYTE *)v1 + 609) & 1) != 0)
    {
      v4 = *((unsigned __int8 *)v1 + 605);
      v5 = *v1;
      if (*v1)
      {
LABEL_7:
        v6 = *(unsigned __int8 *)(v1[1] + 2);
        v7 = *((unsigned __int16 *)v1 + 303);
        v8 = 5;
        if (v7 == 772)
          v8 = 6;
        v9 = v4 + v8 + v6;
        if (v7 - 769 >= 4)
        {
          if (v7 == 65277 || v7 == 65279)
            return v9;
        }
        else if (v7 > 0x301)
        {
          return v9;
        }
        if ((*(_BYTE *)(a1 + 133) & 1) != 0)
          return v9 << (*(_DWORD *)(v5 + 32) != 4);
        return v9;
      }
    }
    else
    {
      v4 = 0;
      v5 = *v1;
      if (*v1)
        goto LABEL_7;
    }
    return v4 + 5;
  }
  if ((*((_BYTE *)v1 + 609) & 1) != 0)
  {
    v2 = *((unsigned __int8 *)v1 + 605) + 13;
    if (*v1)
      return *(unsigned __int8 *)(v1[1] + 2) + v2;
  }
  else
  {
    v2 = 13;
    if (*v1)
      return *(unsigned __int8 *)(v1[1] + 2) + v2;
  }
  return v2;
}

uint64_t bssl::do_seal_record(bssl *this, ssl_st *a2, char *a3, char *a4, unsigned __int8 *a5, char *a6, const unsigned __int8 *a7, int a8)
{
  __int8 v10;
  bssl *v12;
  int8x16_t *v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  size_t v16;
  char *v17;
  void (*v18)(unint64_t *, const unsigned __int8 *, size_t);
  uint64_t (*v19)(unint64_t *, const unsigned __int8 *, size_t);
  uint64_t v20;
  void *__src;
  const unsigned __int8 *v22;
  unsigned int v23;
  int v24;
  int v25;
  unint64_t v26;
  void (*v27)(uint64_t, _QWORD, uint64_t, ssl_st *, uint64_t, bssl *, _QWORD);
  uint64_t v28;
  __int128 v30;
  __int128 v31;

  v10 = (char)a5;
  v12 = this;
  HIBYTE(v31) = (_BYTE)a5;
  v13 = *(int8x16_t **)(*((_QWORD *)this + 6) + 272);
  if (!v13->i64[0])
  {
    v16 = 0;
    __src = 0;
    v20 = 0;
    if ((v13[38].i8[1] & 1) == 0)
      goto LABEL_19;
    goto LABEL_14;
  }
  *(_QWORD *)&v31 = this;
  v14 = (unsigned __int8 *)a3;
  v15 = (unsigned __int8 *)a4;
  v16 = v13[37].u16[7] == 772;
  if (v13[37].i16[7] == 772)
    v10 = 23;
  else
    v10 = (char)a5;
  if (v13[37].i16[7] == 772)
    v17 = (char *)&v31 + 15;
  else
    v17 = 0;
  v18 = *(void (**)(unint64_t *, const unsigned __int8 *, size_t))(v13->i64[1] + 64);
  if (v18)
  {
    v18(&v13->u64[1], a7, v16);
    if (!v13->i64[0])
    {
      v20 = v16;
      a4 = (char *)v15;
      a3 = (char *)v14;
      __src = v17;
      v12 = (bssl *)v31;
      if ((v13[38].i8[1] & 1) == 0)
        goto LABEL_19;
      goto LABEL_14;
    }
  }
  v19 = *(uint64_t (**)(unint64_t *, const unsigned __int8 *, size_t))(v13->i64[1] + 64);
  if (v19)
  {
    v20 = v19(&v13->u64[1], a7, v16);
    a4 = (char *)v15;
    a3 = (char *)v14;
    __src = v17;
    v12 = (bssl *)v31;
    if ((v13[38].i8[1] & 1) == 0)
      goto LABEL_19;
LABEL_14:
    v22 = &a7[v20 + v13[37].u8[13]];
    if (v22 < a7)
      goto LABEL_24;
    goto LABEL_20;
  }
  v20 = v13[36].u8[8] + v16;
  a4 = (char *)v15;
  a3 = (char *)v14;
  __src = v17;
  v12 = (bssl *)v31;
  if ((v13[38].i8[1] & 1) != 0)
    goto LABEL_14;
LABEL_19:
  v22 = &a7[v20];
  if (&a7[v20] < a7)
  {
LABEL_24:
    ERR_put_error(16, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/ssl_aead_ctx.cc", 207);
    v24 = 200;
    v25 = 384;
LABEL_34:
    ERR_put_error(16, 0, v24, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/ssl/tls_record.cc", v25);
    return 0;
  }
LABEL_20:
  if ((unint64_t)v22 >= 0xFFFF)
    goto LABEL_24;
  LOBYTE(a2->version) = v10;
  v23 = v13[37].u16[7];
  if (v23 - 769 >= 4)
  {
    if (!v13[37].i16[7])
    {
      if (v13[38].i8[0])
        LOWORD(v23) = -257;
      else
        LOWORD(v23) = 769;
    }
  }
  else if (v23 > 0x303)
  {
    LOWORD(v23) = 771;
  }
  BYTE1(a2->version) = BYTE1(v23);
  BYTE2(a2->version) = v23;
  HIBYTE(a2->version) = BYTE1(v22);
  LOBYTE(a2->type) = (_BYTE)v22;
  v26 = *(_QWORD *)(*((_QWORD *)v12 + 6) + 8);
  if (v26 == -1)
  {
    v24 = 69;
    v25 = 408;
    goto LABEL_34;
  }
  *(_QWORD *)&v30 = a2;
  *((_QWORD *)&v30 + 1) = 5;
  if (!bssl::SSLAEADContext::SealScatter(v13, (char *)&a2->type + 1, a3, a4, v10, v23, v26, a8, v30, a6, (size_t)a7, __src, v16, v31))return 0;
  ++*(_QWORD *)(*((_QWORD *)v12 + 6) + 8);
  v27 = (void (*)(uint64_t, _QWORD, uint64_t, ssl_st *, uint64_t, bssl *, _QWORD))*((_QWORD *)v12 + 8);
  v28 = 1;
  if (v27)
    v27(1, 0, 256, a2, 5, v12, *((_QWORD *)v12 + 9));
  return v28;
}

uint64_t CBS_get_utf8(_QWORD *a1, unsigned int *a2)
{
  uint64_t v2;
  char *v3;
  unsigned int v4;
  uint64_t v5;
  char v7;
  unsigned int v8;
  int v9;
  unsigned __int8 v10;
  int v11;
  int v12;
  BOOL v13;
  BOOL v14;
  unsigned __int8 v16;
  int v17;
  unsigned __int8 v18;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = (char *)(*a1)++;
  a1[1] = v2 - 1;
  v4 = *v3;
  if ((*v3 & 0x80000000) == 0)
  {
LABEL_3:
    *a2 = v4;
    return 1;
  }
  if ((v4 & 0xE0) == 0xC0)
  {
    v7 = 0;
    v8 = 128;
    v9 = 31;
    if (v2 == 1)
      return 0;
  }
  else if ((v4 & 0xF0) == 0xE0)
  {
    v7 = 1;
    v8 = 2048;
    v9 = 15;
    if (v2 == 1)
      return 0;
  }
  else
  {
    v5 = 0;
    if ((v4 & 0xF8) != 0xF0)
      return v5;
    v7 = 0;
    v8 = 0x10000;
    v9 = 7;
    if (v2 == 1)
      return 0;
  }
  *a1 = v3 + 2;
  a1[1] = v2 - 2;
  v10 = v3[1];
  if ((v10 & 0xC0) == 0x80)
  {
    v11 = v9 & v4;
    v12 = v10 & 0x3F | ((v9 & v4) << 6);
    if ((v4 & 0xE0) == 0xC0)
    {
      v4 = v10 & 0x3F | (v11 << 6);
    }
    else
    {
      if (v2 == 2)
        return 0;
      *a1 = v3 + 3;
      a1[1] = v2 - 3;
      v16 = v3[2];
      if ((v16 & 0xC0) != 0x80)
        return 0;
      v17 = v16 & 0x3F;
      v11 = v17 | (v12 << 6);
      if ((v7 & 1) != 0)
      {
        v4 = v17 | (v12 << 6);
        v11 = v12;
      }
      else
      {
        if (v2 == 3)
          return 0;
        *a1 = v3 + 4;
        a1[1] = v2 - 4;
        v18 = v3[3];
        if ((v18 & 0xC0) != 0x80)
          return 0;
        v4 = v18 & 0x3F | (v11 << 6);
      }
    }
    v5 = 0;
    if ((v11 & 0x1FFE0) == 0x360)
      return v5;
    v13 = v4 - 64976 < 0x20 || HIWORD(v4) > 0x10u;
    v14 = v13 || (v4 & 0xFFFE) == 65534;
    if (v14 || v4 < v8)
      return v5;
    goto LABEL_3;
  }
  return 0;
}

uint64_t CBS_get_latin1(_QWORD *a1, _DWORD *a2)
{
  uint64_t v2;
  unsigned __int8 *v3;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = (unsigned __int8 *)(*a1)++;
  a1[1] = v2 - 1;
  *a2 = *v3;
  return 1;
}

uint64_t CBS_get_ucs2_be(unsigned __int8 **a1, int *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t result;
  unsigned __int8 *v6;
  int v7;
  int v8;

  v2 = (unint64_t)a1[1];
  v3 = v2 - 2;
  if (v2 < 2)
    return 0;
  result = 0;
  v6 = *a1;
  *a1 += 2;
  a1[1] = (unsigned __int8 *)v3;
  v7 = *v6;
  if ((v7 & 0xF8) != 0xD8)
  {
    v8 = v6[1] | (v7 << 8);
    if ((v8 - 64976) >= 0x20 && (v8 & 0xFFFE) != 65534)
    {
      *a2 = v8;
      return 1;
    }
  }
  return result;
}

BOOL CBS_get_utf32_be(uint64_t a1, unsigned int *a2)
{
  unint64_t v2;
  unint64_t v3;
  unsigned __int8 *v5;
  int v6;
  unsigned int v7;
  BOOL v8;
  unsigned int v9;
  BOOL v10;
  int v11;

  v2 = *(_QWORD *)(a1 + 8);
  v8 = v2 >= 4;
  v3 = v2 - 4;
  if (!v8)
    return 0;
  v5 = *(unsigned __int8 **)a1;
  *(_QWORD *)a1 += 4;
  *(_QWORD *)(a1 + 8) = v3;
  v6 = (*v5 << 16) | (v5[1] << 8) | v5[2];
  v7 = v5[3] | (v6 << 8);
  *a2 = v7;
  v8 = (~v7 & 0xFFFE) == 0 || v7 >= 0x110000;
  v9 = v7 - 64976;
  v10 = !v8 && v9 > 0x1F;
  v11 = v6 & 0xFFFFF8;
  return v10 && v11 != 216;
}

uint64_t CBB_add_utf8(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  _BYTE *v5;

  result = 0;
  if (a2 >> 11 != 27 && a2 - 64976 >= 0x20 && HIWORD(a2) <= 0x10u && (a2 & 0xFFFE) != 0xFFFE)
  {
    if (a2 <= 0x7F)
    {
      v5 = 0;
      result = CBB_add_space(a1, &v5, 1);
      if ((_DWORD)result)
      {
        *v5 = a2;
        return 1;
      }
      return result;
    }
    if (a2 > 0x7FF)
    {
      if (HIWORD(a2))
      {
        v5 = 0;
        result = CBB_add_space(a1, &v5, 1);
        if ((_DWORD)result)
        {
          *v5 = (a2 >> 18) | 0xF0;
          v5 = 0;
          result = CBB_add_space(a1, &v5, 1);
          if ((_DWORD)result)
          {
            *v5 = (a2 >> 12) & 0x3F | 0x80;
            v5 = 0;
            result = CBB_add_space(a1, &v5, 1);
            if ((_DWORD)result)
            {
              *v5 = (a2 >> 6) & 0x3F | 0x80;
              v5 = 0;
              result = CBB_add_space(a1, &v5, 1);
              if ((_DWORD)result)
                goto LABEL_12;
            }
          }
        }
      }
      else
      {
        v5 = 0;
        result = CBB_add_space(a1, &v5, 1);
        if ((_DWORD)result)
        {
          *v5 = (a2 >> 12) | 0xE0;
          v5 = 0;
          result = CBB_add_space(a1, &v5, 1);
          if ((_DWORD)result)
          {
            *v5 = (a2 >> 6) & 0x3F | 0x80;
            v5 = 0;
            result = CBB_add_space(a1, &v5, 1);
            if ((_DWORD)result)
              *v5 = a2 & 0x3F | 0x80;
          }
        }
      }
    }
    else
    {
      v5 = 0;
      result = CBB_add_space(a1, &v5, 1);
      if ((_DWORD)result)
      {
        *v5 = (a2 >> 6) | 0xC0;
        v5 = 0;
        result = CBB_add_space(a1, &v5, 1);
        if ((_DWORD)result)
LABEL_12:
          *v5 = a2 & 0x3F | 0x80;
      }
    }
  }
  return result;
}

uint64_t CBB_add_latin1(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  char v4;
  uint64_t result;
  _QWORD v6[5];

  if (a2 > 0xFF)
    return 0;
  v6[3] = v2;
  v6[4] = v3;
  v4 = a2;
  v6[0] = 0;
  result = CBB_add_space(a1, v6, 1);
  if ((_DWORD)result)
    *(_BYTE *)v6[0] = v4;
  return result;
}

uint64_t CBB_add_ucs2_be(uint64_t a1, unsigned int a2)
{
  __int16 v2;
  uint64_t result;
  _BYTE *v5;

  if (HIWORD(a2))
    return 0;
  v2 = a2;
  result = 0;
  if (a2 >> 11 != 27 && a2 - 64976 >= 0x20 && (a2 & 0xFFFE) != 0xFFFE)
  {
    v5 = 0;
    result = CBB_add_space(a1, &v5, 2);
    if ((_DWORD)result)
    {
      v5[1] = v2;
      *v5 = HIBYTE(v2);
    }
  }
  return result;
}

uint64_t CBB_add_utf32_be(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  unsigned int v7;
  _QWORD v8[5];

  result = 0;
  if (a2 >> 11 != 27)
  {
    v8[3] = v2;
    v8[4] = v3;
    if (a2 - 64976 >= 0x20)
    {
      v7 = HIWORD(a2);
      if (HIWORD(a2) <= 0x10u && (a2 & 0xFFFE) != 0xFFFE)
      {
        v8[0] = 0;
        result = CBB_add_space(a1, v8, 4);
        if ((_DWORD)result)
        {
          *(_BYTE *)(v8[0] + 3) = a2;
          *(_BYTE *)(v8[0] + 2) = BYTE1(a2);
          *(_BYTE *)(v8[0] + 1) = v7;
          *(_BYTE *)v8[0] = HIBYTE(a2);
        }
      }
    }
  }
  return result;
}

STACK *i2v_AUTHORITY_KEYID(uint64_t a1, int **a2, STACK *a3)
{
  const char *v5;
  char *v6;
  size_t v7;
  int v8;
  char *v9;
  uint64_t v10;
  size_t v11;
  GENERAL_NAMES *v12;
  STACK *v13;
  ASN1_INTEGER *v14;
  STACK *v16;
  unint64_t v17;
  unint64_t v18;
  CONF_VALUE *v19;
  char **data;
  char **v21;
  uint64_t v22;
  size_t v23;
  int (__cdecl **p_comp)(const char *const *, const char *const *);
  int (__cdecl *comp)(const char *const *, const char *const *);
  size_t v26;
  STACK *extlist;

  extlist = a3;
  if (*a2)
  {
    v5 = (const char *)x509v3_bytes_to_hex(*((_BYTE **)*a2 + 1), **a2);
    if (!v5)
      goto LABEL_12;
    v6 = (char *)v5;
    v7 = strlen(v5);
    v8 = x509V3_add_len_value("keyid", v6, v7, 0, (unint64_t **)&extlist);
    v10 = *((_QWORD *)v6 - 1);
    v9 = v6 - 8;
    v11 = v10 + 8;
    if (v10 != -8)
      bzero(v9, v11);
    free(v9);
    if (!v8)
      goto LABEL_12;
  }
  v12 = (GENERAL_NAMES *)a2[1];
  if (v12)
  {
    v13 = i2v_GENERAL_NAMES(0, v12, extlist);
    if (!v13)
      goto LABEL_12;
    extlist = v13;
  }
  v14 = (ASN1_INTEGER *)a2[2];
  if (!v14 || X509V3_add_value_int("serial", v14, &extlist))
    return extlist;
LABEL_12:
  if (a3)
    return 0;
  v16 = extlist;
  if (!extlist)
    return 0;
  v17 = *(_QWORD *)&extlist->num;
  if (*(_QWORD *)&extlist->num)
  {
    v18 = 0;
    do
    {
      v19 = (CONF_VALUE *)v16->data[v18];
      if (v19)
      {
        X509V3_conf_free(v19);
        v17 = *(_QWORD *)&v16->num;
      }
      ++v18;
    }
    while (v18 < v17);
  }
  data = v16->data;
  if (data)
  {
    v22 = (uint64_t)*(data - 1);
    v21 = data - 1;
    v23 = v22 + 8;
    if (v22 != -8)
      bzero(v21, v23);
    free(v21);
  }
  comp = v16[-1].comp;
  p_comp = &v16[-1].comp;
  v26 = (size_t)comp + 8;
  if (comp != (int (__cdecl *)(const char *const *, const char *const *))-8)
    bzero(p_comp, v26);
  free(p_comp);
  return 0;
}

ASN1_VALUE *v2i_AUTHORITY_KEYID(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v4;
  char v5;
  char v6;
  unint64_t v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  const char *v11;
  uint64_t v12;
  char v13;
  unint64_t *v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unsigned __int16 *v20;
  unsigned int v21;
  unsigned int v22;
  ASN1_VALUE *v23;
  _QWORD *v24;
  X509_EXTENSION *v25;
  _BOOL4 v26;
  ASN1_STRING *v27;
  unint64_t *v28;
  ASN1_VALUE *v29;
  ASN1_STRING *v30;
  BOOL v31;
  char *v32;
  ASN1_VALUE *v33;
  unsigned __int8 *data;
  unsigned __int8 *v35;
  uint64_t v36;
  size_t v37;
  uint64_t *p_flags;
  uint64_t flags;
  size_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  size_t v44;
  char *v45;
  uint64_t v46;
  size_t v47;
  ASN1_VALUE *pval;

  if (a3)
  {
    v4 = *a3;
    if (*a3)
    {
      v5 = 0;
      v6 = 0;
      v7 = 0;
      while (1)
      {
        if (v4 <= v7)
        {
          v8 = 0;
          v9 = (const char *)MEMORY[8];
          if (!strcmp(MEMORY[8], "keyid"))
          {
LABEL_14:
            v11 = *(const char **)(v8 + 16);
            if (v11)
            {
              if (!strcmp(v11, "always"))
                v5 = 2;
              else
                v5 = 1;
            }
            else
            {
              v5 = 1;
            }
            goto LABEL_7;
          }
        }
        else
        {
          v8 = *(_QWORD *)(a3[1] + 8 * v7);
          v9 = *(const char **)(v8 + 8);
          if (!strcmp(v9, "keyid"))
            goto LABEL_14;
        }
        if (strcmp(v9, "issuer"))
        {
          ERR_put_error(20, 0, 159, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_akey.c", 160);
          ERR_add_error_data(2, "name=", *(_QWORD *)(v8 + 8));
          return 0;
        }
        v10 = *(const char **)(v8 + 16);
        if (v10)
        {
          if (!strcmp(v10, "always"))
            v6 = 2;
          else
            v6 = 1;
        }
        else
        {
          v6 = 1;
        }
LABEL_7:
        if (v4 == ++v7)
          goto LABEL_20;
      }
    }
  }
  v5 = 0;
  v6 = 0;
LABEL_20:
  if (!a2)
    goto LABEL_38;
  v12 = *(_QWORD *)(a2 + 8);
  if (v12)
  {
    if (v5)
    {
      v13 = v5;
      v14 = *(unint64_t **)(*(_QWORD *)v12 + 72);
      if (v14)
      {
        v15 = 0;
        while (((int)*v14 & (unint64_t)~((uint64_t)(int)*v14 >> 63)) != v15)
        {
          v17 = v15;
          v18 = v14[1];
          v19 = **(_QWORD **)(v18 + 8 * v15);
          if (*(_DWORD *)(v19 + 20) == 3)
          {
            v20 = *(unsigned __int16 **)(v19 + 24);
            v21 = bswap32(*v20) >> 16;
            v22 = bswap32(0x1D55u) >> 16;
            if (v21 == v22)
            {
              v16 = *((unsigned __int8 *)v20 + 2) - 14;
            }
            else if (v21 < v22)
            {
              v16 = -1;
            }
            else
            {
              v16 = 1;
            }
          }
          else
          {
            v16 = -1;
          }
          v15 = v17 + 1;
          if (!v16)
          {
            if ((v17 & 0x80000000) == 0 && *v14 > v17)
            {
              v25 = *(X509_EXTENSION **)(v18 + 8 * v15 - 8);
              if (v25)
              {
                v24 = X509V3_EXT_d2i(v25);
                goto LABEL_46;
              }
            }
            break;
          }
        }
      }
      v24 = 0;
LABEL_46:
      if (v13 == 2 && !v24)
      {
        ERR_put_error(20, 0, 155, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_akey.c", 183);
        return 0;
      }
    }
    else
    {
      v24 = 0;
    }
    v26 = v6 != 0;
    if (v24)
      v26 = 0;
    if (v6 != 2 && !v26)
    {
      pval = 0;
      if (ASN1_item_ex_new(&pval, &AUTHORITY_KEYID_it))
      {
        v27 = 0;
        v28 = 0;
        v23 = pval;
        if (pval)
          goto LABEL_55;
      }
      pval = 0;
      ASN1_item_ex_free(&pval, &X509_NAME_it);
LABEL_79:
      if (v24)
      {
        v41 = v24[1];
        if (v41)
        {
          v43 = *(_QWORD *)(v41 - 8);
          v42 = (void *)(v41 - 8);
          v44 = v43 + 8;
          if (v43 != -8)
            bzero(v42, v44);
          free(v42);
        }
        v46 = *(v24 - 1);
        v45 = (char *)(v24 - 1);
        v47 = v46 + 8;
        if (v46 != -8)
          bzero(v45, v47);
        free(v45);
      }
      return 0;
    }
    v29 = (ASN1_VALUE *)ASN1_item_dup(&X509_NAME_it, *(void **)(*(_QWORD *)v12 + 24));
    v30 = ASN1_STRING_dup(*(ASN1_STRING **)(*(_QWORD *)v12 + 8));
    v27 = v30;
    if (v29)
      v31 = v30 == 0;
    else
      v31 = 1;
    if (v31)
    {
      ERR_put_error(20, 0, 154, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_akey.c", 192);
      pval = v29;
      ASN1_item_ex_free(&pval, &X509_NAME_it);
      if (!v27)
        goto LABEL_79;
    }
    else
    {
      pval = 0;
      if (ASN1_item_ex_new(&pval, &AUTHORITY_KEYID_it))
      {
        v23 = pval;
        if (pval)
        {
          v32 = OPENSSL_sk_new_null();
          if (v32)
          {
            v28 = (unint64_t *)v32;
            pval = 0;
            if (ASN1_item_ex_new(&pval, &GENERAL_NAME_it))
            {
              v33 = pval;
              if (pval)
              {
                if (OPENSSL_sk_insert(v28, (uint64_t)pval, *v28))
                {
                  *(_DWORD *)v33 = 4;
                  *((_QWORD *)v33 + 1) = v29;
LABEL_55:
                  *((_QWORD *)v23 + 1) = v28;
                  *((_QWORD *)v23 + 2) = v27;
                  *(_QWORD *)v23 = v24;
                  return v23;
                }
              }
            }
          }
        }
      }
      pval = v29;
      ASN1_item_ex_free(&pval, &X509_NAME_it);
    }
    data = v27->data;
    if (data)
    {
      v36 = *((_QWORD *)data - 1);
      v35 = data - 8;
      v37 = v36 + 8;
      if (v36 != -8)
        bzero(v35, v37);
      free(v35);
    }
    flags = v27[-1].flags;
    p_flags = &v27[-1].flags;
    v40 = flags + 8;
    if (flags != -8)
      bzero(p_flags, v40);
    free(p_flags);
    goto LABEL_79;
  }
  if (*(_DWORD *)a2 != 1)
  {
LABEL_38:
    ERR_put_error(20, 0, 140, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_akey.c", 170);
    return 0;
  }
  pval = 0;
  if (ASN1_item_ex_new(&pval, &AUTHORITY_KEYID_it))
    return pval;
  else
    return 0;
}

unint64_t *v2i_subject_alt(uint64_t a1, X509V3_CTX *a2, _QWORD *a3)
{
  unint64_t *v5;
  uint64_t v6;
  CONF_VALUE *v7;
  char *name;
  X509V3_EXT_METHOD *v9;
  ASN1_VALUE *v10;
  int v11;
  const char *value;
  const char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  void *v19;
  uint64_t v20;
  size_t v21;
  unint64_t *v22;
  uint64_t v23;
  size_t v24;
  ASN1_VALUE *pval;

  v5 = (unint64_t *)OPENSSL_sk_new_null();
  if (!v5 || !a3 || !*a3)
    return v5;
  v6 = 0;
  while (1)
  {
    v7 = *(CONF_VALUE **)(a3[1] + 8 * v6);
    name = v7->name;
    if (strncmp(name, "email", 5uLL))
      break;
    v11 = name[5];
    if (v11 != 46 && v11 != 0)
      break;
    value = v7->value;
    if (value && !strcmp(value, "copy"))
    {
      if (!copy_email((uint64_t)a2, v5, 0))
        goto LABEL_29;
    }
    else
    {
      if (v11 != 46 && v11 != 0)
        break;
      v15 = v7->value;
      if (!v15 || strcmp(v15, "move"))
        break;
      if (!copy_email((uint64_t)a2, v5, 1))
        goto LABEL_29;
    }
LABEL_8:
    if ((unint64_t)++v6 >= *a3)
      return v5;
  }
  v10 = (ASN1_VALUE *)v2i_GENERAL_NAME_ex(0, v9, a2, v7, 0);
  if (v10 && OPENSSL_sk_insert(v5, (uint64_t)v10, *v5))
    goto LABEL_8;
  pval = v10;
  ASN1_item_ex_free(&pval, &GENERAL_NAME_it);
LABEL_29:
  v16 = *v5;
  if (*v5)
  {
    v17 = 0;
    do
    {
      if (*(_QWORD *)(v5[1] + 8 * v17))
      {
        pval = *(ASN1_VALUE **)(v5[1] + 8 * v17);
        ASN1_item_ex_free(&pval, &GENERAL_NAME_it);
        v16 = *v5;
      }
      ++v17;
    }
    while (v17 < v16);
  }
  v18 = v5[1];
  if (v18)
  {
    v20 = *(_QWORD *)(v18 - 8);
    v19 = (void *)(v18 - 8);
    v21 = v20 + 8;
    if (v20 != -8)
      bzero(v19, v21);
    free(v19);
  }
  v23 = *(v5 - 1);
  v22 = v5 - 1;
  v24 = v23 + 8;
  if (v23 != -8)
    bzero(v22, v24);
  free(v22);
  return 0;
}

unint64_t *v2i_issuer_alt(uint64_t a1, X509V3_CTX *a2, unint64_t *a3)
{
  unint64_t *v5;
  unint64_t i;
  CONF_VALUE *v7;
  char *name;
  X509V3_EXT_METHOD *v9;
  ASN1_VALUE *v10;
  int v11;
  BOOL v12;
  const char *value;
  X509 *issuer_cert;
  STACK *extensions;
  unint64_t v16;
  int v17;
  unint64_t v18;
  char **data;
  uint64_t v20;
  unsigned __int16 *v21;
  unsigned int v22;
  unsigned int v23;
  X509_EXTENSION *v24;
  ASN1_VALUE *v25;
  ASN1_VALUE *v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  CONF_VALUE *v31;
  char *v32;
  X509V3_EXT_METHOD *v33;
  int v34;
  const char *v36;
  const ASN1_ITEM *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  void *v41;
  uint64_t v42;
  size_t v43;
  unint64_t *v44;
  uint64_t v45;
  size_t v46;
  ASN1_VALUE *pval;

  v5 = (unint64_t *)OPENSSL_sk_new_null();
  if (v5)
  {
    if (a2)
    {
      if (a3 && *a3)
      {
        for (i = 0; i < *a3; ++i)
        {
          v7 = *(CONF_VALUE **)(a3[1] + 8 * i);
          name = v7->name;
          if (!strncmp(name, "issuer", 6uLL)
            && ((v11 = name[6], v11 != 46) ? (v12 = v11 == 0) : (v12 = 1),
                v12 && (value = v7->value) != 0 && !strcmp(value, "copy")))
          {
            if (a2->flags != 1)
            {
              issuer_cert = a2->issuer_cert;
              if (!issuer_cert)
                goto LABEL_59;
              extensions = issuer_cert->cert_info->extensions;
              if (extensions)
              {
                v16 = 0;
                while (((int)*(_QWORD *)&extensions->num & (unint64_t)~((uint64_t)(int)*(_QWORD *)&extensions->num >> 63)) != v16)
                {
                  v18 = v16;
                  data = extensions->data;
                  v20 = *(_QWORD *)data[v16];
                  if (*(_DWORD *)(v20 + 20) == 3)
                  {
                    v21 = *(unsigned __int16 **)(v20 + 24);
                    v22 = bswap32(*v21) >> 16;
                    v23 = bswap32(0x1D55u) >> 16;
                    if (v22 == v23)
                    {
                      v17 = *((unsigned __int8 *)v21 + 2) - 17;
                    }
                    else if (v22 < v23)
                    {
                      v17 = -1;
                    }
                    else
                    {
                      v17 = 1;
                    }
                  }
                  else
                  {
                    v17 = -1;
                  }
                  v16 = v18 + 1;
                  if (!v17)
                  {
                    if ((v18 & 0x80000000) != 0)
                      break;
                    if (*(_QWORD *)&extensions->num > v18
                      && (v24 = (X509_EXTENSION *)data[v16 - 1]) != 0
                      && (v25 = (ASN1_VALUE *)X509V3_EXT_d2i(v24)) != 0)
                    {
                      v26 = v25;
                      v27 = *(_QWORD *)v25;
                      if (!*(_QWORD *)v25)
                      {
LABEL_44:
                        pval = v26;
                        ASN1_item_ex_free(&pval, &GENERAL_NAMES_it);
                        break;
                      }
                      v28 = 0;
                      while (1)
                      {
                        v29 = v27 <= v28 ? 0 : *(_QWORD *)(*((_QWORD *)v26 + 1) + 8 * v28);
                        if (!OPENSSL_sk_insert(v5, v29, *v5))
                          break;
                        v27 = *(_QWORD *)v26;
                        if (*(_QWORD *)v26 > v28)
                          *(_QWORD *)(*((_QWORD *)v26 + 1) + 8 * v28) = 0;
                        if (++v28 >= v27)
                          goto LABEL_44;
                      }
                    }
                    else
                    {
                      ERR_put_error(20, 0, 136, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_alt.c", 318);
                      v26 = 0;
                    }
                    pval = v26;
                    v37 = &GENERAL_NAMES_it;
                    goto LABEL_61;
                  }
                }
              }
            }
          }
          else
          {
            v10 = (ASN1_VALUE *)v2i_GENERAL_NAME_ex(0, v9, a2, v7, 0);
            if (!v10 || !OPENSSL_sk_insert(v5, (uint64_t)v10, *v5))
              goto LABEL_60;
          }
        }
      }
    }
    else if (a3)
    {
      v30 = 0;
      while (1)
      {
        if (v30 >= *a3)
          return v5;
        v31 = *(CONF_VALUE **)(a3[1] + 8 * v30);
        v32 = v31->name;
        if (!strncmp(v32, "issuer", 6uLL))
        {
          v34 = v32[6];
          if (v34 == 46 || v34 == 0)
          {
            v36 = v31->value;
            if (v36)
            {
              if (!strcmp(v36, "copy"))
                break;
            }
          }
        }
        v10 = (ASN1_VALUE *)v2i_GENERAL_NAME_ex(0, v33, 0, v31, 0);
        if (v10)
        {
          ++v30;
          if (OPENSSL_sk_insert(v5, (uint64_t)v10, *v5))
            continue;
        }
LABEL_60:
        pval = v10;
        v37 = &GENERAL_NAME_it;
LABEL_61:
        ASN1_item_ex_free(&pval, v37);
        goto LABEL_62;
      }
LABEL_59:
      ERR_put_error(20, 0, 141, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_alt.c", 305);
LABEL_62:
      v38 = *v5;
      if (*v5)
      {
        v39 = 0;
        do
        {
          if (*(_QWORD *)(v5[1] + 8 * v39))
          {
            pval = *(ASN1_VALUE **)(v5[1] + 8 * v39);
            ASN1_item_ex_free(&pval, &GENERAL_NAME_it);
            v38 = *v5;
          }
          ++v39;
        }
        while (v39 < v38);
      }
      v40 = v5[1];
      if (v40)
      {
        v42 = *(_QWORD *)(v40 - 8);
        v41 = (void *)(v40 - 8);
        v43 = v42 + 8;
        if (v42 != -8)
          bzero(v41, v43);
        free(v41);
      }
      v45 = *(v5 - 1);
      v44 = v5 - 1;
      v46 = v45 + 8;
      if (v45 != -8)
        bzero(v44, v46);
      free(v44);
      return 0;
    }
  }
  return v5;
}

STACK *__cdecl i2v_GENERAL_NAMES(STACK *method, GENERAL_NAMES *gen, STACK *extlist)
{
  unint64_t v4;
  unint64_t v5;
  STACK *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  CONF_VALUE *v10;
  char **data;
  char **v12;
  uint64_t v13;
  size_t v14;
  int (__cdecl **p_comp)(const char *const *, const char *const *);
  int (__cdecl *comp)(const char *const *, const char *const *);
  size_t v17;

  if (extlist)
  {
    method = extlist;
    if (gen)
    {
      v4 = 0;
      do
      {
        if (v4 >= *(_QWORD *)&gen->num)
          break;
        method = i2v_GENERAL_NAME((X509V3_EXT_METHOD *)method, (GENERAL_NAME *)gen->data[v4++], method);
      }
      while (method);
    }
    return method;
  }
  if (!gen)
    return (STACK *)OPENSSL_sk_new_null();
  v5 = *(_QWORD *)&gen->num;
  if (!*(_QWORD *)&gen->num)
    return (STACK *)OPENSSL_sk_new_null();
  v6 = 0;
  v7 = 0;
  while (v5 > v7)
  {
    method = i2v_GENERAL_NAME((X509V3_EXT_METHOD *)method, (GENERAL_NAME *)gen->data[v7], v6);
    if (!method)
      goto LABEL_17;
LABEL_14:
    ++v7;
    v5 = *(_QWORD *)&gen->num;
    v6 = method;
    if (v7 >= *(_QWORD *)&gen->num)
      return method;
  }
  method = i2v_GENERAL_NAME((X509V3_EXT_METHOD *)method, 0, v6);
  if (method)
    goto LABEL_14;
LABEL_17:
  if (v6)
  {
    v8 = *(_QWORD *)&v6->num;
    if (*(_QWORD *)&v6->num)
    {
      v9 = 0;
      do
      {
        v10 = (CONF_VALUE *)v6->data[v9];
        if (v10)
        {
          X509V3_conf_free(v10);
          v8 = *(_QWORD *)&v6->num;
        }
        ++v9;
      }
      while (v9 < v8);
    }
    data = v6->data;
    if (data)
    {
      v13 = (uint64_t)*(data - 1);
      v12 = data - 1;
      v14 = v13 + 8;
      if (v13 != -8)
        bzero(v12, v14);
      free(v12);
    }
    comp = v6[-1].comp;
    p_comp = &v6[-1].comp;
    v17 = (size_t)comp + 8;
    if (comp != (int (__cdecl *)(const char *const *, const char *const *))-8)
      bzero(p_comp, v17);
    free(p_comp);
  }
  return 0;
}

STACK *__cdecl i2v_GENERAL_NAME(X509V3_EXT_METHOD *method, GENERAL_NAME *gen, STACK *ret)
{
  const char *v3;
  STACK *result;
  size_t v5;
  char *ptr;
  unsigned __int16 *v7;
  int v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  size_t v63;
  char __str[5];
  STACK *v65;
  char buf[256];
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v65 = ret;
  switch(gen->type)
  {
    case 0:
      v3 = "othername";
      goto LABEL_12;
    case 1:
      if (!x509V3_add_len_value("email", *((_BYTE **)gen->d.ptr + 1), *(int *)gen->d.ptr, 0, (unint64_t **)&v65))return 0;
      return v65;
    case 2:
      if (!x509V3_add_len_value("DNS", *((_BYTE **)gen->d.ptr + 1), *(int *)gen->d.ptr, 0, (unint64_t **)&v65))return 0;
      return v65;
    case 3:
      v3 = "X400Name";
      goto LABEL_12;
    case 4:
      result = (STACK *)X509_NAME_oneline(gen->d.directoryName, buf, 256);
      if (!result)
        return result;
      v5 = strlen(buf);
      if (!x509V3_add_len_value("DirName", buf, v5, 0, (unint64_t **)&v65))
        return 0;
      return v65;
    case 5:
      v3 = "EdiPartyName";
LABEL_12:
      if (x509V3_add_len_value(v3, "<unsupported>", 0xDuLL, 0, (unint64_t **)&v65))
        return v65;
      return 0;
    case 6:
      if (!x509V3_add_len_value("URI", *((_BYTE **)gen->d.ptr + 1), *(int *)gen->d.ptr, 0, (unint64_t **)&v65))return 0;
      return v65;
    case 7:
      ptr = gen->d.ptr;
      v7 = (unsigned __int16 *)*((_QWORD *)ptr + 1);
      v8 = *(_DWORD *)ptr;
      if (v8 == 16)
      {
        buf[0] = 0;
        snprintf(__str, 5uLL, "%X", __rev16(*v7));
        v10 = 0;
        while (buf[v10])
        {
          if (++v10 == 256)
            goto LABEL_36;
        }
        if ((unint64_t)(256 - v10) >= 2)
        {
          v11 = 0;
          v12 = 255 - v10;
          while (__str[v11])
          {
            buf[v11 + v10] = __str[v11];
            ++v11;
            if (!--v12)
            {
              v13 = &buf[v10 + v11];
              goto LABEL_35;
            }
          }
          v10 += v11;
        }
        v13 = &buf[v10];
LABEL_35:
        *v13 = 0;
LABEL_36:
        v14 = 0;
        while (buf[v14])
        {
          if (++v14 == 256)
            goto LABEL_43;
        }
        v15 = 256 - v14;
        v16 = &buf[v14];
        if (v15 >= 2)
          *v16++ = 58;
        *v16 = 0;
LABEL_43:
        snprintf(__str, 5uLL, "%X", __rev16(v7[1]));
        v17 = 0;
        while (buf[v17])
        {
          if (++v17 == 256)
            goto LABEL_55;
        }
        if ((unint64_t)(256 - v17) >= 2)
        {
          v18 = 0;
          v19 = 255 - v17;
          while (__str[v18])
          {
            buf[v18 + v17] = __str[v18];
            ++v18;
            if (!--v19)
            {
              v20 = &buf[v17 + v18];
              goto LABEL_54;
            }
          }
          v17 += v18;
        }
        v20 = &buf[v17];
LABEL_54:
        *v20 = 0;
LABEL_55:
        v21 = 0;
        while (buf[v21])
        {
          if (++v21 == 256)
            goto LABEL_62;
        }
        v22 = 256 - v21;
        v23 = &buf[v21];
        if (v22 >= 2)
          *v23++ = 58;
        *v23 = 0;
LABEL_62:
        snprintf(__str, 5uLL, "%X", __rev16(v7[2]));
        v24 = 0;
        while (buf[v24])
        {
          if (++v24 == 256)
            goto LABEL_74;
        }
        if ((unint64_t)(256 - v24) >= 2)
        {
          v25 = 0;
          v26 = 255 - v24;
          while (__str[v25])
          {
            buf[v25 + v24] = __str[v25];
            ++v25;
            if (!--v26)
            {
              v27 = &buf[v24 + v25];
              goto LABEL_73;
            }
          }
          v24 += v25;
        }
        v27 = &buf[v24];
LABEL_73:
        *v27 = 0;
LABEL_74:
        v28 = 0;
        while (buf[v28])
        {
          if (++v28 == 256)
            goto LABEL_81;
        }
        v29 = 256 - v28;
        v30 = &buf[v28];
        if (v29 >= 2)
          *v30++ = 58;
        *v30 = 0;
LABEL_81:
        snprintf(__str, 5uLL, "%X", __rev16(v7[3]));
        v31 = 0;
        while (buf[v31])
        {
          if (++v31 == 256)
            goto LABEL_93;
        }
        if ((unint64_t)(256 - v31) >= 2)
        {
          v32 = 0;
          v33 = 255 - v31;
          while (__str[v32])
          {
            buf[v32 + v31] = __str[v32];
            ++v32;
            if (!--v33)
            {
              v34 = &buf[v31 + v32];
              goto LABEL_92;
            }
          }
          v31 += v32;
        }
        v34 = &buf[v31];
LABEL_92:
        *v34 = 0;
LABEL_93:
        v35 = 0;
        while (buf[v35])
        {
          if (++v35 == 256)
            goto LABEL_100;
        }
        v36 = 256 - v35;
        v37 = &buf[v35];
        if (v36 >= 2)
          *v37++ = 58;
        *v37 = 0;
LABEL_100:
        snprintf(__str, 5uLL, "%X", __rev16(v7[4]));
        v38 = 0;
        while (buf[v38])
        {
          if (++v38 == 256)
            goto LABEL_112;
        }
        if ((unint64_t)(256 - v38) >= 2)
        {
          v39 = 0;
          v40 = 255 - v38;
          while (__str[v39])
          {
            buf[v39 + v38] = __str[v39];
            ++v39;
            if (!--v40)
            {
              v41 = &buf[v38 + v39];
              goto LABEL_111;
            }
          }
          v38 += v39;
        }
        v41 = &buf[v38];
LABEL_111:
        *v41 = 0;
LABEL_112:
        v42 = 0;
        while (buf[v42])
        {
          if (++v42 == 256)
            goto LABEL_119;
        }
        v43 = 256 - v42;
        v44 = &buf[v42];
        if (v43 >= 2)
          *v44++ = 58;
        *v44 = 0;
LABEL_119:
        snprintf(__str, 5uLL, "%X", __rev16(v7[5]));
        v45 = 0;
        while (buf[v45])
        {
          if (++v45 == 256)
            goto LABEL_131;
        }
        if ((unint64_t)(256 - v45) >= 2)
        {
          v46 = 0;
          v47 = 255 - v45;
          while (__str[v46])
          {
            buf[v46 + v45] = __str[v46];
            ++v46;
            if (!--v47)
            {
              v48 = &buf[v45 + v46];
              goto LABEL_130;
            }
          }
          v45 += v46;
        }
        v48 = &buf[v45];
LABEL_130:
        *v48 = 0;
LABEL_131:
        v49 = 0;
        while (buf[v49])
        {
          if (++v49 == 256)
            goto LABEL_138;
        }
        v50 = 256 - v49;
        v51 = &buf[v49];
        if (v50 >= 2)
          *v51++ = 58;
        *v51 = 0;
LABEL_138:
        snprintf(__str, 5uLL, "%X", __rev16(v7[6]));
        v52 = 0;
        while (buf[v52])
        {
          if (++v52 == 256)
            goto LABEL_150;
        }
        if ((unint64_t)(256 - v52) >= 2)
        {
          v53 = 0;
          v54 = 255 - v52;
          while (__str[v53])
          {
            buf[v53 + v52] = __str[v53];
            ++v53;
            if (!--v54)
            {
              v55 = &buf[v52 + v53];
              goto LABEL_149;
            }
          }
          v52 += v53;
        }
        v55 = &buf[v52];
LABEL_149:
        *v55 = 0;
LABEL_150:
        v56 = 0;
        while (buf[v56])
        {
          if (++v56 == 256)
            goto LABEL_157;
        }
        v57 = 256 - v56;
        v58 = &buf[v56];
        if (v57 >= 2)
          *v58++ = 58;
        *v58 = 0;
LABEL_157:
        snprintf(__str, 5uLL, "%X", __rev16(v7[7]));
        v59 = 0;
        while (buf[v59])
        {
          if (++v59 == 256)
            goto LABEL_169;
        }
        if ((unint64_t)(256 - v59) >= 2)
        {
          v60 = 0;
          v61 = 255 - v59;
          while (__str[v60])
          {
            buf[v60 + v59] = __str[v60];
            ++v60;
            if (!--v61)
            {
              v62 = &buf[v59 + v60];
              goto LABEL_168;
            }
          }
          v59 += v60;
        }
        v62 = &buf[v59];
LABEL_168:
        *v62 = 0;
LABEL_169:
        v63 = strlen(buf);
        if (!x509V3_add_len_value("IP Address", buf, v63, 0, (unint64_t **)&v65))
          return 0;
        return v65;
      }
      if (v8 == 4)
      {
        snprintf(buf, 0x100uLL, "%d.%d.%d.%d", *(unsigned __int8 *)v7, *((unsigned __int8 *)v7 + 1), *((unsigned __int8 *)v7 + 2), *((unsigned __int8 *)v7 + 3));
        goto LABEL_169;
      }
      if (!x509V3_add_len_value("IP Address", "<invalid>", 9uLL, 0, (unint64_t **)&v65))
        return 0;
      return v65;
    case 8:
      OBJ_obj2txt(buf, 256, gen->d.registeredID, 0);
      v9 = strlen(buf);
      if (!x509V3_add_len_value("Registered ID", buf, v9, 0, (unint64_t **)&v65))
        return 0;
      return v65;
    default:
      return v65;
  }
}

int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)
{
  int result;
  char *ptr;
  unsigned __int16 *v6;
  int v7;

  switch(gen->type)
  {
    case 0:
      BIO_printf(out, "othername:<unsupported>");
      goto LABEL_17;
    case 1:
      BIO_printf(out, "email:");
      goto LABEL_10;
    case 2:
      BIO_printf(out, "DNS:");
      goto LABEL_10;
    case 3:
      BIO_printf(out, "X400Name:<unsupported>");
      goto LABEL_17;
    case 4:
      BIO_printf(out, "DirName: ");
      X509_NAME_print_ex(out, gen->d.directoryName, 0, 0x82031FuLL);
      goto LABEL_7;
    case 5:
      BIO_printf(out, "EdiPartyName:<unsupported>");
      goto LABEL_17;
    case 6:
      BIO_printf(out, "URI:");
LABEL_10:
      ASN1_STRING_print(out, gen->d.rfc822Name);
      result = 1;
      break;
    case 7:
      ptr = gen->d.ptr;
      v6 = (unsigned __int16 *)*((_QWORD *)ptr + 1);
      v7 = *(_DWORD *)ptr;
      if (v7 == 16)
      {
        BIO_printf(out, "IP Address");
        BIO_printf(out, ":%X", __rev16(*v6));
        BIO_printf(out, ":%X", __rev16(v6[1]));
        BIO_printf(out, ":%X", __rev16(v6[2]));
        BIO_printf(out, ":%X", __rev16(v6[3]));
        BIO_printf(out, ":%X", __rev16(v6[4]));
        BIO_printf(out, ":%X", __rev16(v6[5]));
        BIO_printf(out, ":%X", __rev16(v6[6]));
        BIO_printf(out, ":%X", __rev16(v6[7]));
        BIO_puts(out, "\n");
        result = 1;
      }
      else
      {
        if (v7 == 4)
          BIO_printf(out, "IP Address:%d.%d.%d.%d");
        else
          BIO_printf(out, "IP Address:<invalid>");
LABEL_17:
        result = 1;
      }
      break;
    case 8:
      BIO_printf(out, "Registered ID");
      i2a_ASN1_OBJECT(out, gen->d.registeredID);
      result = 1;
      break;
    default:
LABEL_7:
      result = 1;
      break;
  }
  return result;
}

GENERAL_NAMES *__cdecl v2i_GENERAL_NAMES(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK *nval)
{
  X509V3_EXT_METHOD *v5;
  unint64_t *v6;
  unint64_t v7;
  ASN1_VALUE *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  size_t v14;
  unint64_t *v15;
  uint64_t v16;
  size_t v17;
  ASN1_VALUE *pval;

  v6 = (unint64_t *)OPENSSL_sk_new_null();
  if (v6 && nval)
  {
    v7 = 0;
    while (v7 < *(_QWORD *)&nval->num)
    {
      v8 = (ASN1_VALUE *)v2i_GENERAL_NAME_ex(0, v5, ctx, (CONF_VALUE *)nval->data[v7], 0);
      if (v8)
      {
        ++v7;
        if (OPENSSL_sk_insert(v6, (uint64_t)v8, *v6))
          continue;
      }
      pval = v8;
      ASN1_item_ex_free(&pval, &GENERAL_NAME_it);
      v9 = *v6;
      if (*v6)
      {
        v10 = 0;
        do
        {
          if (*(_QWORD *)(v6[1] + 8 * v10))
          {
            pval = *(ASN1_VALUE **)(v6[1] + 8 * v10);
            ASN1_item_ex_free(&pval, &GENERAL_NAME_it);
            v9 = *v6;
          }
          ++v10;
        }
        while (v10 < v9);
      }
      v11 = v6[1];
      if (v11)
      {
        v13 = *(_QWORD *)(v11 - 8);
        v12 = (void *)(v11 - 8);
        v14 = v13 + 8;
        if (v13 != -8)
          bzero(v12, v14);
        free(v12);
      }
      v16 = *(v6 - 1);
      v15 = v6 - 1;
      v17 = v16 + 8;
      if (v16 != -8)
        bzero(v15, v17);
      free(v15);
      return 0;
    }
  }
  return (GENERAL_NAMES *)v6;
}

GENERAL_NAME *__cdecl v2i_GENERAL_NAME_ex(GENERAL_NAME *out, X509V3_EXT_METHOD *method, X509V3_CTX *ctx, CONF_VALUE *cnf, int is_nc)
{
  char *value;
  char *name;
  int v10;
  GENERAL_NAME *v11;
  int v12;
  GENERAL_NAME *result;
  _QWORD *v14;
  _QWORD *v15;
  ASN1_VALUE *v16;
  uint64_t *v17;
  int v18;
  char *v19;
  char *v20;
  ASN1_VALUE *v21;
  char *v22;
  char *v23;
  ASN1_TYPE *v24;
  int v25;
  int v26;
  STACK *section;
  STACK *v28;
  unint64_t v29;
  unsigned __int8 *v30;
  int v31;
  const char *v32;
  int v33;
  char *v34;
  unsigned __int8 *i;
  unsigned int v36;
  ASN1_OCTET_STRING *v37;
  ASN1_OBJECT *v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  size_t v42;
  ASN1_OCTET_STRING *v43;
  ASN1_VALUE *pval;

  value = cnf->value;
  if (!value)
  {
    ERR_put_error(20, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_alt.c", 542);
    return 0;
  }
  name = cnf->name;
  if (!strncmp(name, "email", 5uLL) && ((v10 = 1, !name[5]) || name[5] == 46)
    || !strncmp(name, "URI", 3uLL) && ((v10 = 6, !name[3]) || name[3] == 46)
    || !strncmp(name, "DNS", 3uLL) && ((v10 = 2, !name[3]) || name[3] == 46)
    || !strncmp(name, "RID", 3uLL) && ((v10 = 8, !name[3]) || name[3] == 46))
  {
LABEL_24:
    v11 = out;
    if (out)
      goto LABEL_27;
    goto LABEL_25;
  }
  if (x509v3_conf_name_matches(name, "IP"))
  {
    v10 = 7;
    v11 = out;
    if (out)
      goto LABEL_27;
    goto LABEL_25;
  }
  if (x509v3_conf_name_matches(name, "dirName"))
  {
    v10 = 4;
    goto LABEL_24;
  }
  if (!x509v3_conf_name_matches(name, "otherName"))
  {
    ERR_put_error(20, 0, 160, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_alt.c", 562);
    ERR_add_error_data(2, "name=", name);
    return 0;
  }
  v10 = 0;
  v11 = out;
  if (out)
    goto LABEL_27;
LABEL_25:
  pval = 0;
  v12 = ASN1_item_ex_new(&pval, &GENERAL_NAME_it);
  result = 0;
  if (v12)
  {
    v11 = (GENERAL_NAME *)pval;
    if (pval)
    {
LABEL_27:
      switch(v10)
      {
        case 0:
          v19 = strchr(value, 59);
          if (!v19)
            goto LABEL_88;
          v20 = v19;
          pval = 0;
          if (!ASN1_item_ex_new(&pval, &OTHERNAME_it))
            goto LABEL_88;
          v21 = pval;
          if (!pval)
            goto LABEL_88;
          v22 = (char *)OPENSSL_strndup(value, v20 - value);
          if (!v22)
            goto LABEL_87;
          v23 = v22;
          ASN1_OBJECT_free(*(ASN1_OBJECT **)v21);
          *(_QWORD *)v21 = OBJ_txt2obj(v23, 0);
          OPENSSL_free(v23);
          if (!*(_QWORD *)v21
            || (pval = (ASN1_VALUE *)*((_QWORD *)v21 + 1),
                ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&ASN1_OBJECT_it.sname),
                v24 = ASN1_generate_v3(v20 + 1, ctx),
                (*((_QWORD *)v21 + 1) = v24) == 0))
          {
LABEL_87:
            pval = v21;
            ASN1_item_ex_free(&pval, &OTHERNAME_it);
LABEL_88:
            v25 = 148;
            v26 = 517;
            goto LABEL_91;
          }
          v11->type = 0;
          v11->d.ptr = (char *)v21;
          return v11;
        case 1:
        case 2:
        case 6:
          v14 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
          if (v14)
          {
            v15 = v14;
            *v14 = 24;
            v14[1] = 0x1600000000;
            v16 = (ASN1_VALUE *)(v14 + 1);
            v14[2] = 0;
            v17 = v14 + 2;
            v14[3] = 0;
            v18 = strlen(value);
            if (ASN1_STRING_set((ASN1_STRING *)v16, value, v18))
            {
              v11->type = v10;
              goto LABEL_31;
            }
            v39 = *v17;
            if (*v17)
            {
              v41 = *(_QWORD *)(v39 - 8);
              v40 = (void *)(v39 - 8);
              v42 = v41 + 8;
              if (v41 != -8)
                bzero(v40, v42);
              free(v40);
            }
            if (*v15 != -8)
              __memset_chk();
            free(v15);
            if (out)
              return 0;
          }
          else
          {
            ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
            if (out)
              return 0;
          }
          goto LABEL_93;
        case 4:
          pval = 0;
          if (ASN1_item_ex_new(&pval, &X509_NAME_it))
            v16 = pval;
          else
            v16 = 0;
          if (!v16)
            goto LABEL_90;
          section = X509V3_get_section(ctx, value);
          if (!section)
          {
            ERR_put_error(20, 0, 153, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_alt.c", 617);
            ERR_add_error_data(2, "section=", value);
LABEL_90:
            pval = v16;
            ASN1_item_ex_free(&pval, &X509_NAME_it);
            v25 = 105;
            v26 = 510;
LABEL_91:
            ERR_put_error(20, 0, v25, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_alt.c", v26);
            goto LABEL_92;
          }
          v28 = section;
          v29 = 0;
LABEL_57:
          if (v29 < *(_QWORD *)&v28->num)
          {
            v34 = v28->data[v29];
            v30 = (unsigned __int8 *)*((_QWORD *)v34 + 1);
            for (i = v30 + 1; ; ++i)
            {
              v36 = *(i - 1);
              if (v36 > 0x2D)
              {
                if (v36 == 58 || v36 == 46)
                  goto LABEL_48;
              }
              else
              {
                if (!*(i - 1))
                  goto LABEL_50;
                if (v36 == 44)
                {
LABEL_48:
                  if (*i)
                    v30 = i;
LABEL_50:
                  v31 = *v30;
                  if (v31 == 43)
                    v32 = (const char *)(v30 + 1);
                  else
                    v32 = (const char *)v30;
                  if (v31 == 43)
                    v33 = -1;
                  else
                    v33 = 0;
                  ++v29;
                  if (!X509_NAME_add_entry_by_txt((X509_NAME *)v16, v32, 4097, *((const unsigned __int8 **)v34 + 2), -1, -1, v33))goto LABEL_90;
                  goto LABEL_57;
                }
              }
            }
          }
          v11->type = 4;
LABEL_31:
          v11->d.ptr = (char *)v16;
          return v11;
        case 7:
          v11->type = 7;
          if (is_nc)
          {
            v37 = a2i_IPADDRESS_NC(value);
            v11->d.ptr = (char *)v37;
            if (v37)
              return v11;
          }
          else
          {
            v43 = a2i_IPADDRESS(value);
            v11->d.ptr = (char *)v43;
            if (v43)
              return v11;
          }
          ERR_put_error(20, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_alt.c", 502);
          ERR_add_error_data(2, "value=", value);
LABEL_92:
          if (!out)
          {
LABEL_93:
            pval = (ASN1_VALUE *)v11;
            ASN1_item_ex_free(&pval, &GENERAL_NAME_it);
          }
          break;
        case 8:
          v38 = OBJ_txt2obj(value, 0);
          if (v38)
          {
            v11->type = 8;
            v11->d.ptr = (char *)v38;
            return v11;
          }
          ERR_put_error(20, 0, 101, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_alt.c", 485);
          ERR_add_error_data(2, "value=", value);
          if (!out)
            goto LABEL_93;
          return 0;
        default:
          v25 = 161;
          v26 = 522;
          goto LABEL_91;
      }
      return 0;
    }
  }
  return result;
}

uint64_t copy_email(uint64_t a1, unint64_t *a2, int a3)
{
  uint64_t v3;
  uint64_t v5;
  X509_NAME *v6;
  int v7;
  unsigned __int8 *v8;
  STACK *entries;
  uint64_t num;
  int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  char **data;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  ASN1_STRING *v21;
  ASN1_STRING *v22;
  ASN1_VALUE *v23;
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  STACK *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  char **v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  ASN1_STRING *v37;
  ASN1_STRING *v38;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  uint64_t v42;
  size_t v43;
  uint64_t *p_flags;
  uint64_t flags;
  size_t v46;
  ASN1_VALUE *pval;

  if (a1)
  {
    if (*(_DWORD *)a1 == 1)
      return 1;
    v5 = *(_QWORD *)(a1 + 16);
    if (v5)
    {
      v6 = *(X509_NAME **)(*(_QWORD *)v5 + 40);
      v3 = 1;
      if (a3)
        goto LABEL_6;
      goto LABEL_34;
    }
    v25 = *(_QWORD *)(a1 + 24);
    if (v25)
    {
      v6 = *(X509_NAME **)(*(_QWORD *)v25 + 32);
      v3 = 1;
      if (a3)
      {
LABEL_6:
        if (!v6)
          return v3;
        v7 = -1;
        v8 = (unsigned __int8 *)&unk_208F2C000;
        while (2)
        {
          entries = v6->entries;
          if (v6->entries)
            num = entries->num;
          else
            num = 0;
          v11 = v7;
          v12 = v7 + 1;
          do
          {
            if (v12 >= num)
              return 1;
            v14 = v12;
            data = entries->data;
            v16 = *(_QWORD *)data[v12];
            if (*(_DWORD *)(v16 + 20) == 9)
            {
              v17 = *(_QWORD *)(v16 + 24);
              v18 = bswap64(*(_QWORD *)v17);
              v19 = bswap64(0x9010DF78648862AuLL);
              if (v18 == v19)
              {
                v13 = *(unsigned __int8 *)(v17 + 8) - v8[3018];
              }
              else if (v18 < v19)
              {
                v13 = -1;
              }
              else
              {
                v13 = 1;
              }
            }
            else
            {
              v13 = -1;
            }
            ++v12;
            ++v11;
          }
          while (v13);
          if (v11 < 0)
            return 1;
          if (*(_QWORD *)&entries->num <= (unint64_t)v14)
          {
            v20 = 0;
          }
          else
          {
            v20 = data[v14];
            if (v20)
            {
              v21 = (ASN1_STRING *)*((_QWORD *)v20 + 1);
LABEL_27:
              v22 = ASN1_STRING_dup(v21);
              X509_NAME_delete_entry(v6, v11);
              pval = (ASN1_VALUE *)v20;
              ASN1_item_ex_free(&pval, &X509_NAME_ENTRY_it);
              if (!v22)
                goto LABEL_60;
              pval = 0;
              if (!ASN1_item_ex_new(&pval, &GENERAL_NAME_it))
                goto LABEL_64;
              v23 = pval;
              if (!pval)
                goto LABEL_64;
              v7 = v12 - 2;
              *((_QWORD *)pval + 1) = v22;
              *(_DWORD *)v23 = 1;
              v24 = OPENSSL_sk_insert(a2, (uint64_t)v23, *a2);
              v8 = (_BYTE *)&unk_208F2C000;
              if (v24)
                continue;
              goto LABEL_61;
            }
          }
          break;
        }
        v21 = 0;
        goto LABEL_27;
      }
LABEL_34:
      if (!v6)
        return v3;
      LODWORD(v26) = -1;
LABEL_36:
      v27 = v6->entries;
      if (v6->entries)
        v28 = v27->num;
      else
        v28 = 0;
      v29 = (int)v26 + 1;
      while (v29 < v28)
      {
        v26 = v29;
        v31 = v27->data;
        v32 = *(_QWORD *)v31[v29];
        if (*(_DWORD *)(v32 + 20) == 9)
        {
          v33 = *(_QWORD *)(v32 + 24);
          v34 = bswap64(*(_QWORD *)v33);
          v35 = bswap64(0x9010DF78648862AuLL);
          if (v34 == v35)
          {
            v30 = *(unsigned __int8 *)(v33 + 8) - 1;
          }
          else if (v34 < v35)
          {
            v30 = -1;
          }
          else
          {
            v30 = 1;
          }
        }
        else
        {
          v30 = -1;
        }
        v29 = v26 + 1;
        if (!v30)
        {
          if ((v26 & 0x80000000) != 0)
            return 1;
          if (*(_QWORD *)&v27->num > (unint64_t)v26 && (v36 = v31[v26]) != 0)
            v37 = (ASN1_STRING *)*((_QWORD *)v36 + 1);
          else
            v37 = 0;
          v38 = ASN1_STRING_dup(v37);
          if (!v38)
            goto LABEL_60;
          v22 = v38;
          pval = 0;
          if (!ASN1_item_ex_new(&pval, &GENERAL_NAME_it) || (v23 = pval) == 0)
          {
LABEL_64:
            pval = 0;
            ASN1_item_ex_free(&pval, &GENERAL_NAME_it);
            v40 = v22->data;
            if (v40)
            {
              v42 = *((_QWORD *)v40 - 1);
              v41 = v40 - 8;
              v43 = v42 + 8;
              if (v42 != -8)
                bzero(v41, v43);
              free(v41);
            }
            flags = v22[-1].flags;
            p_flags = &v22[-1].flags;
            v46 = flags + 8;
            if (flags != -8)
              bzero(p_flags, v46);
            free(p_flags);
            return 0;
          }
          *((_QWORD *)pval + 1) = v22;
          *(_DWORD *)v23 = 1;
          if (OPENSSL_sk_insert(a2, (uint64_t)v23, *a2))
            goto LABEL_36;
          goto LABEL_61;
        }
      }
      return 1;
    }
  }
  ERR_put_error(20, 0, 145, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_alt.c", 383);
LABEL_60:
  v23 = 0;
LABEL_61:
  pval = v23;
  ASN1_item_ex_free(&pval, &GENERAL_NAME_it);
  return 0;
}

STACK *i2v_BASIC_CONSTRAINTS(uint64_t a1, uint64_t a2, STACK *a3)
{
  char *v4;
  size_t v5;
  STACK *extlist;

  extlist = a3;
  if (*(_DWORD *)a2)
  {
    v4 = "TRUE";
    v5 = 4;
  }
  else
  {
    v4 = "FALSE";
    v5 = 5;
  }
  x509V3_add_len_value("CA", v4, v5, 0, (unint64_t **)&extlist);
  X509V3_add_value_int("pathlen", *(ASN1_INTEGER **)(a2 + 8), &extlist);
  return extlist;
}

ASN1_VALUE *v2i_BASIC_CONSTRAINTS(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  int v4;
  ASN1_VALUE *result;
  ASN1_VALUE *v6;
  unint64_t v7;
  unint64_t v8;
  CONF_VALUE *v9;
  const char *name;
  const char *value;
  ASN1_VALUE *pval;

  pval = 0;
  v4 = ASN1_item_ex_new(&pval, &BASIC_CONSTRAINTS_it);
  result = pval;
  if (v4)
    v6 = pval;
  else
    v6 = 0;
  if (!v6)
    return 0;
  if (a3)
  {
    v7 = *a3;
    if (*a3)
    {
      v8 = 0;
      while (1)
      {
        if (v7 <= v8)
        {
          v9 = 0;
          name = (const char *)MEMORY[8];
          if (strcmp(MEMORY[8], "CA"))
          {
LABEL_11:
            if (strcmp(name, "pathlen"))
            {
              ERR_put_error(20, 0, 123, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_bcons.c", 126);
              ERR_add_error_data(6, "section:", v9->section, ",name:", v9->name, ",value:", v9->value);
              goto LABEL_22;
            }
            if (!X509V3_get_value_int(v9, (ASN1_INTEGER **)v6 + 1))
              goto LABEL_22;
            goto LABEL_8;
          }
        }
        else
        {
          v9 = *(CONF_VALUE **)(a3[1] + 8 * v8);
          name = v9->name;
          if (strcmp(name, "CA"))
            goto LABEL_11;
        }
        value = v9->value;
        if (!value)
        {
          ERR_put_error(20, 0, 120, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_utl.c", 326);
LABEL_21:
          ERR_add_error_data(6, "section:", v9->section, ",name:", v9->name, ",value:", v9->value);
LABEL_22:
          pval = v6;
          ASN1_item_ex_free(&pval, &BASIC_CONSTRAINTS_it);
          return 0;
        }
        if (!X509V3_BOOL_from_string(value, v6))
          goto LABEL_21;
LABEL_8:
        ++v8;
        v7 = *a3;
        if (v8 >= *a3)
          return v6;
      }
    }
  }
  return result;
}

STACK *__cdecl i2v_ASN1_BIT_STRING(X509V3_EXT_METHOD *method, ASN1_BIT_STRING *bits, STACK *extlist)
{
  char *usr_data;
  const char *v4;
  BOOL v5;
  int v8;
  int v9;
  unsigned __int8 *data;
  STACK *v11;

  v11 = extlist;
  usr_data = (char *)method->usr_data;
  v4 = (const char *)*((_QWORD *)usr_data + 1);
  if (v4)
    v5 = bits == 0;
  else
    v5 = 1;
  if (v5)
    return extlist;
  do
  {
    v8 = *(_DWORD *)usr_data + 7;
    if (*(int *)usr_data >= 0)
      v8 = *(_DWORD *)usr_data;
    v9 = v8 >> 3;
    if (bits->length > v9)
    {
      data = bits->data;
      if (data)
      {
        if (((data[v9] >> (~*(_DWORD *)usr_data & 7)) & 1) != 0)
          x509V3_add_len_value(v4, 0, 0, 1, (unint64_t **)&v11);
      }
    }
    v4 = (const char *)*((_QWORD *)usr_data + 4);
    usr_data += 24;
  }
  while (v4);
  return v11;
}

ASN1_BIT_STRING *__cdecl v2i_ASN1_BIT_STRING(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK *nval)
{
  _QWORD *v5;
  _QWORD *v6;
  ASN1_BIT_STRING *v7;
  uint64_t *v8;
  unint64_t v9;
  char *v10;
  char *usr_data;
  const char *v12;
  const char *v13;
  const char **v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  size_t v18;

  v5 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (v5)
  {
    v6 = v5;
    *v5 = 24;
    v5[1] = 0x300000000;
    v7 = (ASN1_BIT_STRING *)(v5 + 1);
    v5[2] = 0;
    v8 = v5 + 2;
    v5[3] = 0;
    if (nval)
    {
      v9 = 0;
      while (v9 < *(_QWORD *)&nval->num)
      {
        v10 = nval->data[v9];
        usr_data = (char *)method->usr_data;
        v12 = (const char *)*((_QWORD *)usr_data + 1);
        if (!v12)
          goto LABEL_13;
        v13 = (const char *)*((_QWORD *)v10 + 1);
        v14 = (const char **)(usr_data + 16);
        while (strcmp(*v14, v13) && strcmp(v12, v13))
        {
          v12 = v14[2];
          v14 += 3;
          if (!v12)
            goto LABEL_13;
        }
        if (!ASN1_BIT_STRING_set_bit(v7, *((_DWORD *)v14 - 4), 1))
          goto LABEL_14;
        ++v9;
        if (!*(v14 - 1))
        {
LABEL_13:
          ERR_put_error(20, 0, 156, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_bitst.c", 123);
          ERR_add_error_data(6, "section:", *(_QWORD *)v10, ",name:", *((_QWORD *)v10 + 1), ",value:", *((_QWORD *)v10 + 2));
LABEL_14:
          v15 = *v8;
          if (*v8)
          {
            v17 = *(_QWORD *)(v15 - 8);
            v16 = (void *)(v15 - 8);
            v18 = v17 + 8;
            if (v17 != -8)
              bzero(v16, v18);
            free(v16);
          }
          if (*v6 != -8)
            __memset_chk();
          free(v6);
          return 0;
        }
      }
    }
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  return v7;
}

STACK *__cdecl X509V3_get_section(X509V3_CTX *ctx, char *section)
{
  X509V3_CONF_METHOD *db_meth;
  STACK *(__cdecl *get_section)(void *, char *);
  uint64_t **v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  _QWORD v9[2];

  db_meth = ctx->db_meth;
  if (db_meth)
  {
    v9[0] = section;
    v9[1] = 0;
    get_section = db_meth->get_section;
    v4 = (uint64_t **)(*((_QWORD *)get_section + 1)
                    + 8
                    * ((unint64_t)lh_CONF_SECTION_call_hash_func(*((uint64_t (**)(uint64_t))get_section + 5), (uint64_t)v9)% *((_QWORD *)get_section + 2)));
    v5 = *v4;
    if (*v4)
    {
      if (lh_CONF_SECTION_call_cmp_func(*((uint64_t (**)(uint64_t, uint64_t))get_section + 4), *v5, (uint64_t)v9))
      {
        while (1)
        {
          v6 = v5;
          v5 = (uint64_t *)v5[1];
          if (!v5)
            break;
          if (!lh_CONF_SECTION_call_cmp_func(*((uint64_t (**)(uint64_t, uint64_t))get_section + 4), *v5, (uint64_t)v9))
          {
            v4 = (uint64_t **)(v6 + 1);
            goto LABEL_7;
          }
        }
      }
      else
      {
LABEL_7:
        if (*v4)
        {
          v7 = **v4;
          if (v7)
            return *(STACK **)(v7 + 8);
        }
      }
    }
  }
  else
  {
    ERR_put_error(20, 0, 147, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_conf.c", 398);
  }
  return 0;
}

uint64_t i2r_certpol(int a1, unint64_t *a2, BIO *bio, int a4)
{
  unint64_t v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  ASN1_OBJECT *v11;
  int nid;
  unsigned __int16 *v13;
  unsigned int v14;
  uint64_t *v15;
  uint64_t v16;
  _QWORD *v17;
  BOOL v18;
  const char *v19;
  int (__cdecl *bwrite)(BIO *, const char *, int);
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  ASN1_INTEGER *v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  size_t v30;
  unint64_t *v31;
  unint64_t v32;
  ASN1_INTEGER *v33;
  int (__cdecl *v34)(BIO *, const char *, int);
  int v35;
  int (__cdecl *v36)(BIO *, const char *, int);
  int v37;
  char *v38;
  char *v39;
  size_t v40;
  char *v41;
  uint64_t v42;
  size_t v43;
  int (__cdecl *v44)(BIO *, const char *, int);
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  int (__cdecl *v51)(BIO *, const char *, int);
  int v52;
  uint64_t v53;
  unint64_t *v55;
  int v57;

  if (a2 && *a2)
  {
    v5 = 0;
    v57 = a4 + 2;
    v6 = a4 + 4;
    v55 = a2;
    while (1)
    {
      v7 = *(_QWORD *)(a2[1] + 8 * v5);
      BIO_printf(bio, "%*sPolicy: ", a4, &byte_208EB9246);
      i2a_ASN1_OBJECT(bio, *(ASN1_OBJECT **)v7);
      BIO_puts(bio, "\n");
      v8 = *(_QWORD **)(v7 + 8);
      if (v8)
      {
        if (*v8)
          break;
      }
LABEL_4:
      ++v5;
      a2 = v55;
      if (v5 >= *v55)
        return 1;
    }
    v9 = 0;
    while (1)
    {
      v10 = *(_QWORD *)(v8[1] + 8 * v9);
      v11 = *(ASN1_OBJECT **)v10;
      if (!*(_QWORD *)v10)
        goto LABEL_25;
      nid = v11->nid;
      if (nid)
      {
        if (nid != 165)
          goto LABEL_13;
      }
      else
      {
        if (pthread_rwlock_rdlock(&global_added_lock) || pthread_rwlock_unlock(&global_added_lock))
LABEL_97:
          abort();
        v13 = (unsigned __int16 *)bsearch(v11, &kNIDsInOIDOrder, 0x371uLL, 2uLL, (int (__cdecl *)(const void *, const void *))obj_cmp);
        if (!v13)
          goto LABEL_25;
        v14 = *v13 - 1;
        if (v14 >= 0x3C4)
          goto LABEL_97;
        nid = (int)kObjects[5 * v14 + 2];
        if (nid != 165)
        {
LABEL_13:
          if (nid == 164)
          {
            BIO_printf(bio, "%*sCPS: %.*s\n", v57, &byte_208EB9246, **(_DWORD **)(v10 + 8), *(const char **)(*(_QWORD *)(v10 + 8) + 8));
            goto LABEL_9;
          }
LABEL_25:
          BIO_printf(bio, "%*sUnknown Qualifier: ", v6, &byte_208EB9246);
          i2a_ASN1_OBJECT(bio, *(ASN1_OBJECT **)v10);
          if (bio && bio->method && (bwrite = bio->method->bwrite) != 0)
          {
            if (LODWORD(bio->cb_arg))
            {
              v21 = ((uint64_t (*)(BIO *, const char *, uint64_t))bwrite)(bio, "\n", 1);
              if (v21 >= 1)
                bio->prev_bio = (bio_st *)((char *)bio->prev_bio + v21);
              goto LABEL_9;
            }
            v22 = 114;
            v23 = 171;
          }
          else
          {
            v22 = 115;
            v23 = 167;
          }
          ERR_put_error(17, 0, v22, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v23);
          goto LABEL_9;
        }
      }
      BIO_printf(bio, "%*sUser Notice:\n", v57, &byte_208EB9246);
      v15 = *(uint64_t **)(v10 + 8);
      v16 = *v15;
      if (!*v15)
        goto LABEL_92;
      BIO_printf(bio, "%*sOrganization: %.*s\n", v6, &byte_208EB9246, **(_DWORD **)v16, *(const char **)(*(_QWORD *)v16 + 8));
      v17 = *(_QWORD **)(v16 + 8);
      if (v17)
      {
        v18 = *v17 > 1uLL;
        v19 = "s";
        if (!v18)
          v19 = &byte_208EB9246;
      }
      else
      {
        v19 = &byte_208EB9246;
      }
      BIO_printf(bio, "%*sNumber%s: ", v6, &byte_208EB9246, v19);
      v24 = *(_QWORD *)(v16 + 8);
      if (v24)
      {
        if (*(_QWORD *)v24)
        {
          v25 = **(ASN1_INTEGER ***)(v24 + 8);
          if (!v25)
          {
            BIO_puts(bio, "(null)");
            v31 = *(unint64_t **)(v16 + 8);
            if (v31)
              break;
            goto LABEL_84;
          }
          v26 = i2s_ASN1_INTEGER(0, v25);
          if (!v26)
            goto LABEL_9;
          v27 = v26;
          BIO_puts(bio, v26);
          v29 = *((_QWORD *)v27 - 1);
          v28 = v27 - 8;
          v30 = v29 + 8;
          if (v29 != -8)
            bzero(v28, v30);
          free(v28);
          v31 = *(unint64_t **)(v16 + 8);
          if (v31)
            break;
        }
      }
LABEL_84:
      if (bio && bio->method && (v51 = bio->method->bwrite) != 0)
      {
        if (!LODWORD(bio->cb_arg))
        {
          ERR_put_error(17, 0, 114, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 171);
          v53 = v15[1];
          if (!v53)
            goto LABEL_9;
LABEL_93:
          BIO_printf(bio, "%*sExplicit Text: %.*s\n", v6, &byte_208EB9246, *(_DWORD *)v53, *(const char **)(v53 + 8));
          goto LABEL_9;
        }
        v52 = ((uint64_t (*)(BIO *, const char *, uint64_t))v51)(bio, "\n", 1);
        if (v52 >= 1)
        {
          bio->prev_bio = (bio_st *)((char *)bio->prev_bio + v52);
          v53 = v15[1];
          if (!v53)
            goto LABEL_9;
          goto LABEL_93;
        }
      }
      else
      {
        ERR_put_error(17, 0, 115, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 167);
      }
LABEL_92:
      v53 = v15[1];
      if (v53)
        goto LABEL_93;
LABEL_9:
      if ((unint64_t)++v9 >= *v8)
        goto LABEL_4;
    }
    v32 = 1;
    while (1)
    {
      if (v32 >= *v31)
        goto LABEL_84;
      v33 = *(ASN1_INTEGER **)(v31[1] + 8 * v32);
      if (!bio)
        break;
      if (!bio->method)
        break;
      v34 = bio->method->bwrite;
      if (!v34)
        break;
      if (LODWORD(bio->cb_arg))
      {
        v35 = ((uint64_t (*)(BIO *, const char *, uint64_t))v34)(bio, ", ", 2);
        if (v35 >= 1)
        {
          bio->prev_bio = (bio_st *)((char *)bio->prev_bio + v35);
          if (v33)
            goto LABEL_62;
          goto LABEL_54;
        }
        goto LABEL_61;
      }
      ERR_put_error(17, 0, 114, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 171);
      if (v33)
      {
LABEL_62:
        v38 = i2s_ASN1_INTEGER(0, v33);
        if (!v38)
          goto LABEL_9;
        v39 = v38;
        v40 = strlen(v38);
        if (v40 >> 31)
        {
          ERR_put_error(17, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 201);
          v42 = *((_QWORD *)v39 - 1);
          v41 = v39 - 8;
          v43 = v42 + 8;
          if (v42 == -8)
            goto LABEL_45;
LABEL_78:
          bzero(v41, v43);
        }
        else
        {
          if (bio && bio->method && (v44 = bio->method->bwrite) != 0)
          {
            if (!LODWORD(bio->cb_arg))
            {
              ERR_put_error(17, 0, 114, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 171);
              v50 = *((_QWORD *)v39 - 1);
              v41 = v39 - 8;
              v43 = v50 + 8;
              if (v50 == -8)
                goto LABEL_45;
              goto LABEL_78;
            }
            if ((_DWORD)v40)
            {
              v45 = ((uint64_t (*)(BIO *, char *))v44)(bio, v39);
              if (v45 >= 1)
              {
                bio->prev_bio = (bio_st *)((char *)bio->prev_bio + v45);
                v46 = *((_QWORD *)v39 - 1);
                v41 = v39 - 8;
                v43 = v46 + 8;
                if (v46 == -8)
                  goto LABEL_45;
                goto LABEL_78;
              }
            }
          }
          else
          {
            ERR_put_error(17, 0, 115, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 167);
          }
          v49 = *((_QWORD *)v39 - 1);
          v41 = v39 - 8;
          v43 = v49 + 8;
          if (v49 != -8)
            goto LABEL_78;
        }
LABEL_45:
        free(v41);
        goto LABEL_46;
      }
LABEL_54:
      if (bio && bio->method && (v36 = bio->method->bwrite) != 0)
      {
        if (LODWORD(bio->cb_arg))
        {
          v37 = ((uint64_t (*)(BIO *, const char *, uint64_t))v36)(bio, "(null)", 6);
          if (v37 >= 1)
            bio->prev_bio = (bio_st *)((char *)bio->prev_bio + v37);
          goto LABEL_46;
        }
        v47 = 114;
        v48 = 171;
      }
      else
      {
        v47 = 115;
        v48 = 167;
      }
      ERR_put_error(17, 0, v47, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v48);
LABEL_46:
      ++v32;
      v31 = *(unint64_t **)(v16 + 8);
      if (!v31)
        goto LABEL_84;
    }
    ERR_put_error(17, 0, 115, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 167);
LABEL_61:
    if (v33)
      goto LABEL_62;
    goto LABEL_54;
  }
  return 1;
}

unint64_t *r2i_certpol(uint64_t a1, X509V3_CTX *a2, const char *a3)
{
  unint64_t *v5;
  STACK *v6;
  STACK *v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  char *v11;
  uint64_t v12;
  STACK *section;
  STACK *v14;
  int v15;
  ASN1_VALUE *v16;
  ASN1_VALUE *v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  ASN1_OBJECT *v21;
  ASN1_OBJECT *v22;
  char *v23;
  uint64_t v24;
  int v25;
  BOOL v26;
  _BYTE *v27;
  STACK *v28;
  STACK *v29;
  int v30;
  ASN1_VALUE *v31;
  ASN1_VALUE *v32;
  ASN1_VALUE *v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  const char *v37;
  ASN1_VALUE *v38;
  STACK *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  ASN1_INTEGER *v44;
  ASN1_INTEGER *v45;
  _QWORD *v46;
  ASN1_STRING *v47;
  ASN1_VALUE *v48;
  const char *v49;
  int v50;
  int v51;
  unint64_t j;
  CONF_VALUE *v53;
  unint64_t v54;
  void *v55;
  uint64_t v56;
  size_t v57;
  unint64_t *v58;
  uint64_t v59;
  size_t v60;
  ASN1_VALUE *v61;
  unint64_t *v62;
  ASN1_OBJECT *v63;
  int v64;
  ASN1_VALUE *v66;
  _QWORD *v67;
  ASN1_STRING *v68;
  int v69;
  unint64_t i;
  CONF_VALUE *v71;
  unint64_t v72;
  char **data;
  char **v74;
  uint64_t v75;
  size_t v76;
  unint64_t *p_comp;
  int (__cdecl *comp)(const char *const *, const char *const *);
  size_t v79;
  int v80;
  int v81;
  unsigned __int8 *v82;
  unsigned __int8 *v83;
  uint64_t v84;
  size_t v85;
  uint64_t *p_flags;
  uint64_t flags;
  size_t v88;
  unint64_t v89;
  unint64_t v90;
  CONF_VALUE *v91;
  unint64_t v92;
  void *v93;
  uint64_t v94;
  size_t v95;
  unint64_t *v96;
  uint64_t v97;
  size_t v98;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  CONF_VALUE *v103;
  char **v104;
  char **v105;
  uint64_t v106;
  size_t v107;
  int (__cdecl **v108)(const char *const *, const char *const *);
  int (__cdecl *v109)(const char *const *, const char *const *);
  size_t v110;
  unint64_t v111;
  unint64_t v112;
  void *v113;
  uint64_t v114;
  size_t v115;
  uint64_t v116;
  X509V3_CTX *v118;
  ASN1_VALUE *v119;
  int v120;
  int v121;
  uint64_t v122;
  STACK *v123;
  STACK *v124;
  ASN1_VALUE *pval;

  v5 = (unint64_t *)OPENSSL_sk_new_null();
  if (!v5)
    return v5;
  v6 = X509V3_parse_list(a3);
  if (!v6)
  {
    ERR_put_error(20, 0, 20, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_cpols.c", 165);
    v72 = *v5;
    if (*v5)
      goto LABEL_174;
    goto LABEL_178;
  }
  v7 = v6;
  v8 = *(_QWORD *)&v6->num;
  if (!*(_QWORD *)&v6->num)
  {
LABEL_114:
    data = v7->data;
    if (data)
    {
      v75 = (uint64_t)*(data - 1);
      v74 = data - 1;
      v76 = v75 + 8;
      if (v75 != -8)
        bzero(v74, v76);
      free(v74);
    }
    comp = v7[-1].comp;
    p_comp = (unint64_t *)&v7[-1].comp;
    v79 = (size_t)comp + 8;
    if (comp != (int (__cdecl *)(const char *const *, const char *const *))-8)
      bzero(p_comp, v79);
    goto LABEL_185;
  }
  v9 = 0;
  v10 = 0;
  while (1)
  {
    while (1)
    {
      if (v8 <= v9)
        v11 = 0;
      else
        v11 = v7->data[v9];
      if (*((_QWORD *)v11 + 2) || (v12 = *((_QWORD *)v11 + 1)) == 0)
      {
        v80 = 131;
        v81 = 172;
        goto LABEL_121;
      }
      if (strcmp(*((const char **)v11 + 1), "ia5org"))
        break;
      v10 = 1;
      if (++v9 >= v8)
        goto LABEL_107;
    }
    if (*(_BYTE *)v12 != 64)
    {
      v21 = OBJ_txt2obj((const char *)v12, 0);
      if (v21)
      {
        v22 = v21;
        pval = 0;
        if (!ASN1_item_ex_new(&pval, &POLICYINFO_it) || (v17 = pval) == 0)
        {
          ASN1_OBJECT_free(v22);
          goto LABEL_162;
        }
        *(_QWORD *)pval = v22;
        goto LABEL_105;
      }
      v80 = 129;
      v81 = 196;
LABEL_121:
      ERR_put_error(20, 0, v80, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_cpols.c", v81);
      ERR_add_error_data(6, "section:", *(_QWORD *)v11, ",name:", *((_QWORD *)v11 + 1), ",value:", *((_QWORD *)v11 + 2));
      goto LABEL_162;
    }
    section = X509V3_get_section(a2, (char *)(v12 + 1));
    if (!section)
    {
      v80 = 134;
      v81 = 184;
      goto LABEL_121;
    }
    v14 = section;
    pval = 0;
    v15 = ASN1_item_ex_new(&pval, &POLICYINFO_it);
    v16 = 0;
    if (!v15)
      goto LABEL_160;
    v17 = pval;
    if (!pval)
      goto LABEL_160;
    v18 = v10 ? 22 : 26;
    v121 = v18;
    v19 = *(_QWORD *)&v14->num;
    if (*(_QWORD *)&v14->num)
      break;
LABEL_104:
    if (!*(_QWORD *)v17)
    {
      ERR_put_error(20, 0, 142, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_cpols.c", 292);
      goto LABEL_159;
    }
LABEL_105:
    if (!OPENSSL_sk_insert(v5, (uint64_t)v17, *v5))
    {
      pval = v17;
      goto LABEL_161;
    }
    v8 = *(_QWORD *)&v7->num;
    if (++v9 >= *(_QWORD *)&v7->num)
    {
LABEL_107:
      if (v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v71 = (CONF_VALUE *)v7->data[i];
          if (v71)
          {
            X509V3_conf_free(v71);
            v8 = *(_QWORD *)&v7->num;
          }
        }
      }
      goto LABEL_114;
    }
  }
  v20 = 0;
  v124 = v14;
  v120 = v10;
  while (1)
  {
    while (v19 <= v20)
    {
      v23 = 0;
      v24 = MEMORY[8];
      if (strcmp(MEMORY[8], "policyIdentifier"))
        goto LABEL_29;
LABEL_88:
      v63 = OBJ_txt2obj(*((const char **)v23 + 2), 0);
      if (!v63)
      {
        v99 = 129;
        v100 = 233;
        goto LABEL_152;
      }
      *(_QWORD *)v17 = v63;
      ++v20;
      v14 = v124;
      v19 = *(_QWORD *)&v124->num;
      if (v20 >= *(_QWORD *)&v124->num)
        goto LABEL_104;
    }
    v23 = v14->data[v20];
    v24 = *((_QWORD *)v23 + 1);
    if (!strcmp((const char *)v24, "policyIdentifier"))
      goto LABEL_88;
LABEL_29:
    if (!strncmp((const char *)v24, "CPS", 3uLL))
    {
      v64 = *(unsigned __int8 *)(v24 + 3);
      if (v64 == 46 || v64 == 0)
        break;
    }
    if (strncmp((const char *)v24, "userNotice", 0xAuLL)
      || ((v25 = *(unsigned __int8 *)(v24 + 10), v25 != 46) ? (v26 = v25 == 0) : (v26 = 1), !v26))
    {
      v99 = 130;
      v100 = 285;
LABEL_152:
      ERR_put_error(20, 0, v99, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_cpols.c", v100);
      ERR_add_error_data(6, "section:", *(_QWORD *)v23, ",name:", *((_QWORD *)v23 + 1), ",value:", *((_QWORD *)v23 + 2));
      goto LABEL_159;
    }
    v27 = (_BYTE *)*((_QWORD *)v23 + 2);
    if (*v27 != 64)
    {
      v99 = 111;
      v100 = 263;
      goto LABEL_152;
    }
    v28 = X509V3_get_section(a2, v27 + 1);
    if (!v28)
    {
      v99 = 134;
      v100 = 270;
      goto LABEL_152;
    }
    v29 = v28;
    pval = 0;
    v30 = ASN1_item_ex_new(&pval, &POLICYQUALINFO_it);
    v31 = 0;
    if (!v30)
      goto LABEL_158;
    v32 = pval;
    if (!pval)
      goto LABEL_158;
    *(_QWORD *)pval = off_24C0C9560;
    pval = 0;
    if (!ASN1_item_ex_new(&pval, &USERNOTICE_it) || (v33 = pval) == 0)
    {
      v31 = v32;
LABEL_158:
      pval = v31;
      ASN1_item_ex_free(&pval, &POLICYQUALINFO_it);
      goto LABEL_159;
    }
    v122 = (uint64_t)v32;
    *((_QWORD *)v32 + 1) = pval;
    v34 = *(_QWORD *)&v29->num;
    if (*(_QWORD *)&v29->num)
    {
      v35 = 0;
      v123 = v29;
      v118 = a2;
      v119 = v17;
      while (1)
      {
        if (v34 <= v35)
        {
          v36 = 0;
          v37 = (const char *)MEMORY[8];
          if (!strcmp(MEMORY[8], "explicitText"))
            goto LABEL_60;
LABEL_46:
          if (!strcmp(v37, "organization"))
          {
            v48 = *(ASN1_VALUE **)v33;
            if (!*(_QWORD *)v33)
            {
              pval = 0;
              if (!ASN1_item_ex_new(&pval, &NOTICEREF_it))
                goto LABEL_157;
              v48 = pval;
              if (!pval)
                goto LABEL_157;
              *(_QWORD *)v33 = pval;
            }
            v47 = *(ASN1_STRING **)v48;
            *(_DWORD *)(*(_QWORD *)v48 + 4) = v121;
            goto LABEL_67;
          }
          if (strcmp(v37, "noticeNumbers"))
          {
            ERR_put_error(20, 0, 130, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_cpols.c", 373);
            ERR_add_error_data(6, "section:", *(_QWORD *)v36, ",name:", *((_QWORD *)v36 + 1), ",value:", *((_QWORD *)v36 + 2));
            goto LABEL_157;
          }
          v38 = *(ASN1_VALUE **)v33;
          if (!*(_QWORD *)v33)
          {
            pval = 0;
            if (!ASN1_item_ex_new(&pval, &NOTICEREF_it))
              goto LABEL_157;
            v38 = pval;
            if (!pval)
              goto LABEL_157;
            *(_QWORD *)v33 = pval;
          }
          v39 = X509V3_parse_list(*((const char **)v36 + 2));
          v40 = (unint64_t *)v39;
          if (!v39 || !*(_QWORD *)&v39->num)
          {
            ERR_put_error(20, 0, 128, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_cpols.c", 362);
            ERR_add_error_data(6, "section:", *(_QWORD *)v36, ",name:", *((_QWORD *)v36 + 1), ",value:", *((_QWORD *)v36 + 2));
            OPENSSL_sk_pop_free_ex(v40, (void (*)(uint64_t))sk_CONF_VALUE_call_free_func, (uint64_t)X509V3_conf_free);
            goto LABEL_157;
          }
          v41 = 0;
          v42 = (unint64_t *)*((_QWORD *)v38 + 1);
          while (1)
          {
            v43 = *v40;
            if (v41 >= *v40)
              break;
            v44 = s2i_ASN1_INTEGER(0, *(char **)(*(_QWORD *)(v40[1] + 8 * v41) + 8));
            if (!v44)
            {
              ERR_put_error(20, 0, 127, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_cpols.c", 398);
              v17 = v119;
LABEL_130:
              v89 = *v40;
              if (*v40)
              {
                v90 = 0;
                do
                {
                  v91 = *(CONF_VALUE **)(v40[1] + 8 * v90);
                  if (v91)
                  {
                    X509V3_conf_free(v91);
                    v89 = *v40;
                  }
                  ++v90;
                }
                while (v90 < v89);
              }
              v92 = v40[1];
              if (v92)
              {
                v94 = *(_QWORD *)(v92 - 8);
                v93 = (void *)(v92 - 8);
                v95 = v94 + 8;
                if (v94 != -8)
                  bzero(v93, v95);
                free(v93);
              }
              v97 = *(v40 - 1);
              v96 = v40 - 1;
              v98 = v97 + 8;
              if (v97 != -8)
                bzero(v96, v98);
              free(v96);
              v31 = (ASN1_VALUE *)v122;
              goto LABEL_158;
            }
            v45 = v44;
            ++v41;
            if (!OPENSSL_sk_insert(v42, (uint64_t)v44, *v42))
            {
              v82 = v45->data;
              v17 = v119;
              if (v82)
              {
                v84 = *((_QWORD *)v82 - 1);
                v83 = v82 - 8;
                v85 = v84 + 8;
                if (v84 != -8)
                  bzero(v83, v85);
                free(v83);
              }
              flags = v45[-1].flags;
              p_flags = &v45[-1].flags;
              v88 = flags + 8;
              if (flags != -8)
                bzero(p_flags, v88);
              free(p_flags);
              goto LABEL_130;
            }
          }
          v17 = v119;
          if (v43)
          {
            for (j = 0; j < v43; ++j)
            {
              v53 = *(CONF_VALUE **)(v40[1] + 8 * j);
              if (v53)
              {
                X509V3_conf_free(v53);
                v43 = *v40;
              }
            }
          }
          v54 = v40[1];
          if (v54)
          {
            v56 = *(_QWORD *)(v54 - 8);
            v55 = (void *)(v54 - 8);
            v57 = v56 + 8;
            if (v56 != -8)
              bzero(v55, v57);
            free(v55);
          }
          v59 = *(v40 - 1);
          v58 = v40 - 1;
          v60 = v59 + 8;
          if (v59 != -8)
            bzero(v58, v60);
          free(v58);
          a2 = v118;
          v29 = v123;
          ++v35;
          v34 = *(_QWORD *)&v123->num;
          if (v35 >= *(_QWORD *)&v123->num)
            break;
        }
        else
        {
          v36 = v29->data[v35];
          v37 = (const char *)*((_QWORD *)v36 + 1);
          if (strcmp(v37, "explicitText"))
            goto LABEL_46;
LABEL_60:
          v46 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
          if (!v46)
          {
            ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
            *((_QWORD *)v33 + 1) = 0;
            goto LABEL_157;
          }
          *v46 = 24;
          v46[1] = 0x1A00000000;
          v47 = (ASN1_STRING *)(v46 + 1);
          v46[2] = 0;
          v46[3] = 0;
          *((_QWORD *)v33 + 1) = v46 + 1;
LABEL_67:
          v49 = (const char *)*((_QWORD *)v36 + 2);
          v50 = strlen(v49);
          v51 = ASN1_STRING_set(v47, v49, v50);
          v29 = v123;
          if (!v51)
            goto LABEL_157;
          ++v35;
          v34 = *(_QWORD *)&v123->num;
          if (v35 >= *(_QWORD *)&v123->num)
            break;
        }
      }
    }
    v61 = *(ASN1_VALUE **)v33;
    if (*(_QWORD *)v33 && (!*((_QWORD *)v61 + 1) || !*(_QWORD *)v61))
    {
      ERR_put_error(20, 0, 138, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_cpols.c", 381);
LABEL_157:
      v31 = (ASN1_VALUE *)v122;
      goto LABEL_158;
    }
    v62 = (unint64_t *)*((_QWORD *)v17 + 1);
    if (!v62)
    {
      v62 = (unint64_t *)OPENSSL_sk_new_null();
      *((_QWORD *)v17 + 1) = v62;
    }
    v10 = v120;
    if (!OPENSSL_sk_insert(v62, v122, *v62))
      goto LABEL_159;
LABEL_26:
    ++v20;
    v14 = v124;
    v19 = *(_QWORD *)&v124->num;
    if (v20 >= *(_QWORD *)&v124->num)
      goto LABEL_104;
  }
  if (!*((_QWORD *)v17 + 1))
    *((_QWORD *)v17 + 1) = OPENSSL_sk_new_null();
  pval = 0;
  if (!ASN1_item_ex_new(&pval, &POLICYQUALINFO_it))
    goto LABEL_159;
  v66 = pval;
  if (!pval || !OPENSSL_sk_insert(*((unint64_t **)v17 + 1), (uint64_t)pval, **((_QWORD **)v17 + 1)))
    goto LABEL_159;
  *(_QWORD *)v66 = off_24C0C9538;
  v67 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (v67)
  {
    *v67 = 24;
    v67[1] = 0x1600000000;
    v68 = (ASN1_STRING *)(v67 + 1);
    v67[2] = 0;
    v67[3] = 0;
    *((_QWORD *)v66 + 1) = v67 + 1;
    v69 = strlen(*((const char **)v23 + 2));
    if (!ASN1_STRING_set(v68, *((const void **)v23 + 2), v69))
      goto LABEL_159;
    goto LABEL_26;
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  *((_QWORD *)v66 + 1) = 0;
LABEL_159:
  v16 = v17;
LABEL_160:
  pval = v16;
LABEL_161:
  ASN1_item_ex_free(&pval, &POLICYINFO_it);
LABEL_162:
  v101 = *(_QWORD *)&v7->num;
  if (*(_QWORD *)&v7->num)
  {
    v102 = 0;
    do
    {
      v103 = (CONF_VALUE *)v7->data[v102];
      if (v103)
      {
        X509V3_conf_free(v103);
        v101 = *(_QWORD *)&v7->num;
      }
      ++v102;
    }
    while (v102 < v101);
  }
  v104 = v7->data;
  if (v104)
  {
    v106 = (uint64_t)*(v104 - 1);
    v105 = v104 - 1;
    v107 = v106 + 8;
    if (v106 != -8)
      bzero(v105, v107);
    free(v105);
  }
  v109 = v7[-1].comp;
  v108 = &v7[-1].comp;
  v110 = (size_t)v109 + 8;
  if (v109 != (int (__cdecl *)(const char *const *, const char *const *))-8)
    bzero(v108, v110);
  free(v108);
  v72 = *v5;
  if (*v5)
  {
LABEL_174:
    v111 = 0;
    do
    {
      if (*(_QWORD *)(v5[1] + 8 * v111))
      {
        pval = *(ASN1_VALUE **)(v5[1] + 8 * v111);
        ASN1_item_ex_free(&pval, &POLICYINFO_it);
        v72 = *v5;
      }
      ++v111;
    }
    while (v111 < v72);
  }
LABEL_178:
  v112 = v5[1];
  if (v112)
  {
    v114 = *(_QWORD *)(v112 - 8);
    v113 = (void *)(v112 - 8);
    v115 = v114 + 8;
    if (v114 != -8)
      bzero(v113, v115);
    free(v113);
  }
  v116 = *(v5 - 1);
  p_comp = v5 - 1;
  if (v116 != -8)
    bzero(v5 - 1, v116 + 8);
  v5 = 0;
LABEL_185:
  free(p_comp);
  return v5;
}

uint64_t sk_CONF_VALUE_call_free_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

unint64_t *v2i_crld(uint64_t a1, X509V3_CTX *a2, _QWORD *a3)
{
  X509V3_EXT_METHOD *v5;
  unint64_t *v6;
  uint64_t v7;
  CONF_VALUE *v8;
  ASN1_VALUE *v9;
  int v10;
  ASN1_VALUE *v11;
  BOOL v12;
  int v13;
  ASN1_VALUE *v14;
  STACK *section;
  STACK *v16;
  ASN1_VALUE **v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  STACK *v24;
  GENERAL_NAMES *v25;
  STACK *v26;
  STACK *v27;
  GENERAL_NAMES *v28;
  unint64_t v29;
  unint64_t v30;
  CONF_VALUE *v31;
  char **data;
  char **v33;
  uint64_t v34;
  size_t v35;
  int (__cdecl **p_comp)(const char *const *, const char *const *);
  int (__cdecl *comp)(const char *const *, const char *const *);
  size_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  void *v42;
  uint64_t v43;
  size_t v44;
  unint64_t *v45;
  uint64_t v46;
  size_t v47;
  ASN1_BIT_STRING **v49;
  ASN1_VALUE *pval;

  v6 = (unint64_t *)OPENSSL_sk_new_null();
  if (!v6)
  {
    pval = 0;
    ASN1_item_ex_free(&pval, &GENERAL_NAME_it);
    pval = 0;
    ASN1_item_ex_free(&pval, &GENERAL_NAMES_it);
    return v6;
  }
  if (a3 && *a3)
  {
    v7 = 0;
    while (1)
    {
      v8 = *(CONF_VALUE **)(a3[1] + 8 * v7);
      if (!v8->value)
        break;
      v9 = (ASN1_VALUE *)v2i_GENERAL_NAME_ex(0, v5, a2, v8, 0);
      if (!v9
        || ((pval = 0, v10 = ASN1_item_ex_new(&pval, &GENERAL_NAMES_it), v11 = pval, v10)
          ? (v12 = pval == 0)
          : (v12 = 1),
            v12))
      {
        v11 = 0;
        goto LABEL_63;
      }
      if (!OPENSSL_sk_insert((unint64_t *)pval, (uint64_t)v9, *(_QWORD *)pval))
        goto LABEL_63;
      pval = 0;
      if (!ASN1_item_ex_new(&pval, &DIST_POINT_it))
        goto LABEL_62;
      v9 = pval;
      if (!pval)
        goto LABEL_63;
      if (!OPENSSL_sk_insert(v6, (uint64_t)pval, *v6))
      {
        pval = v9;
        ASN1_item_ex_free(&pval, &DIST_POINT_it);
        goto LABEL_62;
      }
      pval = 0;
      v13 = ASN1_item_ex_new(&pval, &DIST_POINT_NAME_it);
      v14 = pval;
      if (!v13)
        v14 = 0;
      *(_QWORD *)v9 = v14;
      if (!v14)
      {
LABEL_62:
        v9 = 0;
LABEL_63:
        pval = v9;
        ASN1_item_ex_free(&pval, &GENERAL_NAME_it);
        pval = v11;
        ASN1_item_ex_free(&pval, &GENERAL_NAMES_it);
        v39 = *v6;
        if (*v6)
        {
          v40 = 0;
          do
          {
            if (*(_QWORD *)(v6[1] + 8 * v40))
            {
              pval = *(ASN1_VALUE **)(v6[1] + 8 * v40);
              ASN1_item_ex_free(&pval, &DIST_POINT_it);
              v39 = *v6;
            }
            ++v40;
          }
          while (v40 < v39);
        }
        v41 = v6[1];
        if (v41)
        {
          v43 = *(_QWORD *)(v41 - 8);
          v42 = (void *)(v41 - 8);
          v44 = v43 + 8;
          if (v43 != -8)
            bzero(v42, v44);
          free(v42);
        }
        v46 = *(v6 - 1);
        v45 = v6 - 1;
        v47 = v46 + 8;
        if (v46 != -8)
          bzero(v45, v47);
        free(v45);
        return 0;
      }
      *((_QWORD *)v14 + 1) = v11;
      **(_DWORD **)v9 = 0;
LABEL_52:
      if ((unint64_t)++v7 >= *a3)
        return v6;
    }
    section = X509V3_get_section(a2, v8->name);
    if (!section)
      goto LABEL_61;
    v16 = section;
    pval = 0;
    if (!ASN1_item_ex_new(&pval, &DIST_POINT_it) || (v17 = (ASN1_VALUE **)pval) == 0)
    {
      pval = 0;
      goto LABEL_60;
    }
    v18 = *(_QWORD *)&v16->num;
    if (!*(_QWORD *)&v16->num)
    {
LABEL_51:
      if (!OPENSSL_sk_insert(v6, (uint64_t)v17, *v6))
        goto LABEL_59;
      goto LABEL_52;
    }
    v19 = 0;
    v49 = (ASN1_BIT_STRING **)((char *)pval + 8);
    while (1)
    {
      if (v18 <= v19)
      {
        v20 = 0;
        v21 = set_dist_point_name(v17, a2, 0);
        if (v21 > 0)
          goto LABEL_25;
      }
      else
      {
        v20 = (uint64_t)v16->data[v19];
        v21 = set_dist_point_name(v17, a2, v20);
        if (v21 > 0)
          goto LABEL_25;
      }
      if (v21 < 0)
        goto LABEL_59;
      v22 = *(const char **)(v20 + 8);
      if (!strcmp(v22, "reasons"))
      {
        if (!set_reasons(v49, *(char **)(v20 + 16)))
          goto LABEL_59;
      }
      else if (!strcmp(v22, "CRLissuer"))
      {
        pval = v17[2];
        ASN1_item_ex_free(&pval, &GENERAL_NAMES_it);
        v23 = *(_QWORD *)(v20 + 16);
        if (*(_BYTE *)v23 == 64)
        {
          v24 = X509V3_get_section(a2, (char *)(v23 + 1));
          if (!v24)
            goto LABEL_58;
          v25 = v2i_GENERAL_NAMES(0, a2, v24);
          v17[2] = (ASN1_VALUE *)v25;
          if (!v25)
            goto LABEL_59;
        }
        else
        {
          v26 = X509V3_parse_list((const char *)v23);
          if (!v26)
          {
LABEL_58:
            ERR_put_error(20, 0, 153, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_crld.c", 121);
            v17[2] = 0;
LABEL_59:
            pval = (ASN1_VALUE *)v17;
LABEL_60:
            ASN1_item_ex_free(&pval, &DIST_POINT_it);
LABEL_61:
            v11 = 0;
            goto LABEL_62;
          }
          v27 = v26;
          v28 = v2i_GENERAL_NAMES(0, a2, v26);
          v29 = *(_QWORD *)&v27->num;
          if (*(_QWORD *)&v27->num)
          {
            v30 = 0;
            do
            {
              v31 = (CONF_VALUE *)v27->data[v30];
              if (v31)
              {
                X509V3_conf_free(v31);
                v29 = *(_QWORD *)&v27->num;
              }
              ++v30;
            }
            while (v30 < v29);
          }
          data = v27->data;
          if (data)
          {
            v34 = (uint64_t)*(data - 1);
            v33 = data - 1;
            v35 = v34 + 8;
            if (v34 != -8)
              bzero(v33, v35);
            free(v33);
          }
          comp = v27[-1].comp;
          p_comp = &v27[-1].comp;
          v38 = (size_t)comp + 8;
          if (comp != (int (__cdecl *)(const char *const *, const char *const *))-8)
            bzero(p_comp, v38);
          free(p_comp);
          v17[2] = (ASN1_VALUE *)v28;
          if (!v28)
            goto LABEL_59;
        }
      }
LABEL_25:
      ++v19;
      v18 = *(_QWORD *)&v16->num;
      if (v19 >= *(_QWORD *)&v16->num)
        goto LABEL_51;
    }
  }
  return v6;
}

uint64_t i2r_crldp(int a1, unint64_t *a2, BIO *bp, int a4)
{
  int v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  int v14;
  int v15;
  BIO_METHOD *method;
  int (__cdecl *bwrite)(BIO *, const char *, int);
  int v18;
  unint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  GENERAL_NAME *v24;

  if (a2)
  {
    v7 = a4 + 2;
    v8 = *a2;
    if (bp)
    {
      if (v8)
      {
        v9 = 0;
        while (1)
        {
          BIO_puts(bp, "\n");
          v10 = *(uint64_t **)(a2[1] + 8 * v9);
          if (*v10)
            print_distpoint(bp, *v10, a4);
          v11 = v10[1];
          if (v11)
            print_reasons(bp, "Reasons", v11, a4);
          if (v10[2])
          {
            BIO_printf(bp, "%*sCRL Issuer:\n", a4, &byte_208EB9246);
            v12 = (unint64_t *)v10[2];
            if (v12)
            {
              if (*v12)
                break;
            }
          }
LABEL_5:
          if (++v9 >= *a2)
            return 1;
        }
        v13 = 0;
        while (1)
        {
          BIO_printf(bp, "%*s", v7, &byte_208EB9246);
          if (*v12 <= v13)
          {
            GENERAL_NAME_print(bp, 0);
            method = bp->method;
            if (!bp->method)
              goto LABEL_14;
          }
          else
          {
            GENERAL_NAME_print(bp, *(GENERAL_NAME **)(v12[1] + 8 * v13));
            method = bp->method;
            if (!bp->method)
              goto LABEL_14;
          }
          bwrite = method->bwrite;
          if (!bwrite)
          {
LABEL_14:
            v14 = 115;
            v15 = 167;
            goto LABEL_15;
          }
          if (LODWORD(bp->cb_arg))
          {
            v18 = ((uint64_t (*)(BIO *, const char *, uint64_t))bwrite)(bp, "\n", 1);
            if (v18 >= 1)
              bp->prev_bio = (bio_st *)((char *)bp->prev_bio + v18);
            goto LABEL_16;
          }
          v14 = 114;
          v15 = 171;
LABEL_15:
          ERR_put_error(17, 0, v14, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", v15);
LABEL_16:
          if (++v13 >= *v12)
            goto LABEL_5;
        }
      }
    }
    else if (v8)
    {
      v19 = 0;
      do
      {
        BIO_puts(0, "\n");
        v20 = *(uint64_t **)(a2[1] + 8 * v19);
        if (*v20)
          print_distpoint(0, *v20, a4);
        v21 = v20[1];
        if (v21)
          print_reasons(0, "Reasons", v21, a4);
        if (v20[2])
        {
          BIO_printf(0, "%*sCRL Issuer:\n", a4, &byte_208EB9246);
          v22 = (unint64_t *)v20[2];
          if (v22)
          {
            if (*v22)
            {
              v23 = 0;
              do
              {
                BIO_printf(0, "%*s", v7, &byte_208EB9246);
                v24 = 0;
                if (*v22 > v23)
                  v24 = *(GENERAL_NAME **)(v22[1] + 8 * v23);
                GENERAL_NAME_print(0, v24);
                ERR_put_error(17, 0, 115, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 167);
                ++v23;
              }
              while (v23 < *v22);
            }
          }
        }
        ++v19;
      }
      while (v19 < *a2);
    }
  }
  return 1;
}

ASN1_VALUE *v2i_idp(uint64_t a1, X509V3_CTX *a2, _QWORD *a3)
{
  ASN1_VALUE *v5;
  uint64_t v6;
  const char *v7;
  _DWORD *v8;
  _QWORD *v9;
  char *v10;
  const char *v11;
  int v12;
  ASN1_VALUE *pval;

  pval = 0;
  if (ASN1_item_ex_new(&pval, (const ASN1_ITEM *)&ISSUING_DIST_POINT_it))
    v5 = pval;
  else
    v5 = 0;
  if (!v5)
  {
    pval = 0;
    ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&ISSUING_DIST_POINT_it);
    return v5;
  }
  if (!a3)
    return pval;
  if (*a3)
  {
    v6 = 0;
    while (1)
    {
      v9 = *(_QWORD **)(a3[1] + 8 * v6);
      v11 = (const char *)v9[1];
      v10 = (char *)v9[2];
      v12 = set_dist_point_name((ASN1_VALUE **)v5, a2, (uint64_t)v9);
      if (v12 > 0)
        goto LABEL_13;
      if (v12 < 0)
        goto LABEL_31;
      if (!strcmp(v11, "onlyuser"))
        break;
      if (!strcmp(v11, "onlyCA"))
      {
        v7 = (const char *)v9[2];
        if (!v7)
          goto LABEL_29;
        v8 = (_DWORD *)((char *)v5 + 12);
        goto LABEL_12;
      }
      if (!strcmp(v11, "onlyAA"))
      {
        v7 = (const char *)v9[2];
        if (!v7)
          goto LABEL_29;
        v8 = (_DWORD *)((char *)v5 + 28);
LABEL_12:
        if (!X509V3_BOOL_from_string(v7, v8))
          goto LABEL_30;
        goto LABEL_13;
      }
      if (!strcmp(v11, "indirectCRL"))
      {
        v7 = (const char *)v9[2];
        if (!v7)
        {
LABEL_29:
          ERR_put_error(20, 0, 120, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_utl.c", 326);
LABEL_30:
          ERR_add_error_data(6, "section:", *v9, ",name:", v9[1], ",value:", v9[2]);
          goto LABEL_31;
        }
        v8 = (_DWORD *)((char *)v5 + 24);
        goto LABEL_12;
      }
      if (strcmp(v11, "onlysomereasons"))
      {
        ERR_put_error(20, 0, 123, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_crld.c", 483);
        ERR_add_error_data(6, "section:", *v9, ",name:", v9[1], ",value:", v9[2]);
LABEL_31:
        pval = v5;
        ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&ISSUING_DIST_POINT_it);
        return 0;
      }
      if (!set_reasons((ASN1_BIT_STRING **)v5 + 2, v10))
        goto LABEL_31;
LABEL_13:
      if ((unint64_t)++v6 >= *a3)
        return v5;
    }
    v7 = (const char *)v9[2];
    if (!v7)
      goto LABEL_29;
    v8 = (_DWORD *)((char *)v5 + 8);
    goto LABEL_12;
  }
  return v5;
}

uint64_t i2r_idp(int a1, uint64_t a2, BIO *bio, int a4)
{
  uint64_t v7;
  uint64_t v8;

  v7 = *(_QWORD *)a2;
  if (v7)
    print_distpoint(bio, v7, a4);
  if (*(int *)(a2 + 8) >= 1)
    BIO_printf(bio, "%*sOnly User Certificates\n", a4, &byte_208EB9246);
  if (*(int *)(a2 + 12) >= 1)
    BIO_printf(bio, "%*sOnly CA Certificates\n", a4, &byte_208EB9246);
  if (*(int *)(a2 + 24) >= 1)
    BIO_printf(bio, "%*sIndirect CRL\n", a4, &byte_208EB9246);
  v8 = *(_QWORD *)(a2 + 16);
  if (v8)
    print_reasons(bio, "Only Some Reasons", v8, a4);
  if (*(int *)(a2 + 28) >= 1)
    BIO_printf(bio, "%*sOnly Attribute Certificates\n", a4, &byte_208EB9246);
  if (*(_QWORD *)a2
    || *(int *)(a2 + 8) > 0
    || *(int *)(a2 + 12) > 0
    || *(int *)(a2 + 24) > 0
    || *(_QWORD *)(a2 + 16)
    || *(int *)(a2 + 28) > 0)
  {
    return 1;
  }
  BIO_printf(bio, "%*s<EMPTY>\n", a4, &byte_208EB9246);
  return 1;
}

uint64_t DIST_POINT_set_dpname(uint64_t a1, void *a2)
{
  unint64_t *v3;
  uint64_t result;
  unint64_t v5;
  int v6;
  ASN1_VALUE *pval;

  if (!a1)
    return 1;
  if (*(_DWORD *)a1 == 1)
  {
    v3 = *(unint64_t **)(a1 + 8);
    result = (uint64_t)ASN1_item_dup(&X509_NAME_it, a2);
    *(_QWORD *)(a1 + 16) = result;
    if (!result)
      return result;
    if (v3)
    {
      v5 = 0;
      while (v5 < *v3)
      {
        v6 = X509_NAME_add_entry(*(X509_NAME **)(a1 + 16), *(X509_NAME_ENTRY **)(v3[1] + 8 * v5), -1, v5 == 0);
        ++v5;
        if (!v6)
          goto LABEL_14;
      }
      result = *(_QWORD *)(a1 + 16);
    }
    pval = (ASN1_VALUE *)result;
    if ((asn1_item_ex_i2d_opt((unint64_t **)&pval, 0, (uint64_t)&X509_NAME_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) != 0)
    {
LABEL_14:
      pval = *(ASN1_VALUE **)(a1 + 16);
      ASN1_item_ex_free(&pval, &X509_NAME_it);
      result = 0;
      *(_QWORD *)(a1 + 16) = 0;
      return result;
    }
  }
  return 1;
}

uint64_t set_dist_point_name(ASN1_VALUE **a1, X509V3_CTX *a2, uint64_t a3)
{
  const char *v6;
  uint64_t result;
  uint64_t v8;
  STACK *section;
  GENERAL_NAMES *v10;
  char *v11;
  STACK *v12;
  STACK *v13;
  int v14;
  ASN1_VALUE *v15;
  unint64_t v16;
  unsigned __int8 *v17;
  int v18;
  const char *v19;
  int v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  unsigned __int8 *i;
  unsigned int v26;
  STACK *v27;
  STACK *v28;
  unint64_t v29;
  unint64_t v30;
  CONF_VALUE *v31;
  char **data;
  char **v33;
  uint64_t v34;
  size_t v35;
  int (__cdecl **p_comp)(const char *const *, const char *const *);
  int (__cdecl *comp)(const char *const *, const char *const *);
  size_t v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t v41;
  char **v42;
  char **v43;
  uint64_t v44;
  size_t v45;
  int (__cdecl **v46)(const char *const *, const char *const *);
  int (__cdecl *v47)(const char *const *, const char *const *);
  size_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  void *v52;
  uint64_t v53;
  size_t v54;
  unint64_t *v55;
  uint64_t v56;
  size_t v57;
  int v58;
  ASN1_VALUE *v59;
  ASN1_VALUE *pval;

  v6 = *(const char **)(a3 + 8);
  if (!strncmp(v6, "fullname", 9uLL))
  {
    v8 = *(_QWORD *)(a3 + 16);
    if (!v8)
    {
      ERR_put_error(20, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_crld.c", 141);
      return 0xFFFFFFFFLL;
    }
    if (*(_BYTE *)v8 == 64)
    {
      section = X509V3_get_section(a2, (char *)(v8 + 1));
      if (section)
      {
        v10 = v2i_GENERAL_NAMES(0, a2, section);
        if (!v10)
          return 0xFFFFFFFFLL;
        goto LABEL_50;
      }
    }
    else
    {
      v27 = X509V3_parse_list((const char *)v8);
      if (v27)
      {
        v28 = v27;
        v10 = v2i_GENERAL_NAMES(0, a2, v27);
        v29 = *(_QWORD *)&v28->num;
        if (*(_QWORD *)&v28->num)
        {
          v30 = 0;
          do
          {
            v31 = (CONF_VALUE *)v28->data[v30];
            if (v31)
            {
              X509V3_conf_free(v31);
              v29 = *(_QWORD *)&v28->num;
            }
            ++v30;
          }
          while (v30 < v29);
        }
        data = v28->data;
        if (data)
        {
          v34 = (uint64_t)*(data - 1);
          v33 = data - 1;
          v35 = v34 + 8;
          if (v34 != -8)
            bzero(v33, v35);
          free(v33);
        }
        comp = v28[-1].comp;
        p_comp = &v28[-1].comp;
        v38 = (size_t)comp + 8;
        if (comp != (int (__cdecl *)(const char *const *, const char *const *))-8)
          bzero(p_comp, v38);
        free(p_comp);
        if (!v10)
          return 0xFFFFFFFFLL;
LABEL_50:
        v39 = 0;
        if (!*a1)
          goto LABEL_86;
        goto LABEL_51;
      }
    }
    ERR_put_error(20, 0, 153, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_crld.c", 121);
    return 0xFFFFFFFFLL;
  }
  if (strcmp(v6, "relativename"))
    return 0;
  v11 = *(char **)(a3 + 16);
  if (!v11)
  {
    ERR_put_error(20, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_crld.c", 152);
    return 0xFFFFFFFFLL;
  }
  v12 = X509V3_get_section(a2, v11);
  if (!v12)
  {
    ERR_put_error(20, 0, 153, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_crld.c", 157);
    return 0xFFFFFFFFLL;
  }
  v13 = v12;
  pval = 0;
  v14 = ASN1_item_ex_new(&pval, &X509_NAME_it);
  result = 0xFFFFFFFFLL;
  if (v14)
  {
    v15 = pval;
    if (pval)
    {
      v16 = 0;
      while (1)
      {
        v22 = v16;
        v23 = *(_QWORD *)&v13->num;
        if (v16 >= *(_QWORD *)&v13->num)
        {
LABEL_59:
          v39 = *(unint64_t **)v15;
          *(_QWORD *)v15 = 0;
          pval = v15;
          ASN1_item_ex_free(&pval, &X509_NAME_it);
          if (v22 < v23)
            goto LABEL_71;
          if (!v39)
            return 0xFFFFFFFFLL;
          if (!*v39)
            goto LABEL_77;
          if (*(_DWORD *)(*(_QWORD *)(v39[1] + 8 * *v39 - 8) + 16))
          {
            ERR_put_error(20, 0, 122, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_crld.c", 173);
LABEL_72:
            v49 = *v39;
            if (*v39)
            {
              v50 = 0;
              do
              {
                if (*(_QWORD *)(v39[1] + 8 * v50))
                {
                  pval = *(ASN1_VALUE **)(v39[1] + 8 * v50);
                  ASN1_item_ex_free(&pval, &X509_NAME_ENTRY_it);
                  v49 = *v39;
                }
                ++v50;
              }
              while (v50 < v49);
            }
LABEL_77:
            v51 = v39[1];
            if (v51)
            {
              v53 = *(_QWORD *)(v51 - 8);
              v52 = (void *)(v51 - 8);
              v54 = v53 + 8;
              if (v53 != -8)
                bzero(v52, v54);
              free(v52);
            }
            v56 = *(v39 - 1);
            v55 = v39 - 1;
            v57 = v56 + 8;
            if (v56 != -8)
              bzero(v55, v57);
            free(v55);
            return 0xFFFFFFFFLL;
          }
          v10 = 0;
          if (!*a1)
          {
LABEL_86:
            pval = 0;
            v58 = ASN1_item_ex_new(&pval, &DIST_POINT_NAME_it);
            v59 = pval;
            if (!v58)
              v59 = 0;
            *a1 = v59;
            if (v59)
            {
              if (v10)
              {
                *(_DWORD *)v59 = 0;
                *((_QWORD *)v59 + 1) = v10;
                return 1;
              }
              else
              {
                result = 1;
                *(_DWORD *)v59 = 1;
                *((_QWORD *)v59 + 1) = v39;
              }
              return result;
            }
LABEL_52:
            if (v10)
            {
              v40 = *(_QWORD *)&v10->num;
              if (*(_QWORD *)&v10->num)
              {
                v41 = 0;
                do
                {
                  if (v10->data[v41])
                  {
                    pval = (ASN1_VALUE *)v10->data[v41];
                    ASN1_item_ex_free(&pval, &GENERAL_NAME_it);
                    v40 = *(_QWORD *)&v10->num;
                  }
                  ++v41;
                }
                while (v41 < v40);
              }
              v42 = v10->data;
              if (v42)
              {
                v44 = (uint64_t)*(v42 - 1);
                v43 = v42 - 1;
                v45 = v44 + 8;
                if (v44 != -8)
                  bzero(v43, v45);
                free(v43);
              }
              v47 = v10[-1].comp;
              v46 = &v10[-1].comp;
              v48 = (size_t)v47 + 8;
              if (v47 != (int (__cdecl *)(const char *const *, const char *const *))-8)
                bzero(v46, v48);
              free(v46);
            }
LABEL_71:
            if (v39)
              goto LABEL_72;
            return 0xFFFFFFFFLL;
          }
LABEL_51:
          ERR_put_error(20, 0, 106, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_crld.c", 181);
          goto LABEL_52;
        }
        v24 = v13->data[v16];
        v17 = (unsigned __int8 *)*((_QWORD *)v24 + 1);
        for (i = v17 + 1; ; ++i)
        {
          v26 = *(i - 1);
          if (v26 <= 0x2D)
            break;
          if (v26 == 58 || v26 == 46)
            goto LABEL_15;
LABEL_26:
          ;
        }
        if (!*(i - 1))
          goto LABEL_17;
        if (v26 != 44)
          goto LABEL_26;
LABEL_15:
        if (*i)
          v17 = i;
LABEL_17:
        v18 = *v17;
        if (v18 == 43)
          v19 = (const char *)(v17 + 1);
        else
          v19 = (const char *)v17;
        if (v18 == 43)
          v20 = -1;
        else
          v20 = 0;
        v21 = X509_NAME_add_entry_by_txt((X509_NAME *)v15, v19, 4097, *((const unsigned __int8 **)v24 + 2), -1, -1, v20);
        v16 = v22 + 1;
        if (!v21)
          goto LABEL_59;
      }
    }
  }
  return result;
}

uint64_t set_reasons(ASN1_BIT_STRING **a1, char *line)
{
  uint64_t v2;
  STACK *v4;
  STACK *v5;
  unint64_t v6;
  int *v7;
  unint64_t v8;
  char *v9;
  const char *v10;
  ASN1_BIT_STRING *v11;
  _QWORD *v12;
  int v13;
  unint64_t v14;
  CONF_VALUE *v15;
  char **data;
  char **v17;
  uint64_t v18;
  size_t v19;
  int (__cdecl **p_comp)(const char *const *, const char *const *);
  int (__cdecl *comp)(const char *const *, const char *const *);
  size_t v22;

  if (*a1)
  {
    ERR_put_error(20, 0, 163, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_crld.c", 220);
    return 0;
  }
  v4 = X509V3_parse_list(line);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = 0;
  while (1)
  {
    v8 = *(_QWORD *)&v5->num;
    if (v6 >= *(_QWORD *)&v5->num)
    {
      v2 = 1;
      if (!v8)
        goto LABEL_38;
      goto LABEL_34;
    }
    v9 = v5->data[v6];
    v10 = (const char *)*((_QWORD *)v9 + 1);
    v11 = *a1;
    if (*a1)
    {
      if (!strcmp("unused", *((const char **)v9 + 1)))
        goto LABEL_5;
      goto LABEL_13;
    }
    v12 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (!v12)
      break;
    *v12 = 24;
    v12[1] = 0x300000000;
    v11 = (ASN1_BIT_STRING *)(v12 + 1);
    v12[2] = 0;
    v12[3] = 0;
    *a1 = (ASN1_BIT_STRING *)(v12 + 1);
    if (!strcmp("unused", v10))
    {
LABEL_5:
      v7 = &reason_flags;
      goto LABEL_6;
    }
LABEL_13:
    if (!strcmp("keyCompromise", v10))
    {
      v7 = &dword_24C0D36A8;
    }
    else if (!strcmp("CACompromise", v10))
    {
      v7 = &dword_24C0D36C0;
    }
    else if (!strcmp("affiliationChanged", v10))
    {
      v7 = &dword_24C0D36D8;
    }
    else if (!strcmp("superseded", v10))
    {
      v7 = &dword_24C0D36F0;
    }
    else if (!strcmp("cessationOfOperation", v10))
    {
      v7 = &dword_24C0D3708;
    }
    else if (!strcmp("certificateHold", v10))
    {
      v7 = &dword_24C0D3720;
    }
    else if (!strcmp("privilegeWithdrawn", v10))
    {
      v7 = &dword_24C0D3738;
    }
    else
    {
      v13 = strcmp("AACompromise", v10);
      v7 = &dword_24C0D3750;
      if (v13)
        goto LABEL_33;
    }
LABEL_6:
    ++v6;
    if (!ASN1_BIT_STRING_set_bit(v11, *v7, 1))
      goto LABEL_33;
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  *a1 = 0;
LABEL_33:
  v2 = 0;
  v8 = *(_QWORD *)&v5->num;
  if (!*(_QWORD *)&v5->num)
    goto LABEL_38;
LABEL_34:
  v14 = 0;
  do
  {
    v15 = (CONF_VALUE *)v5->data[v14];
    if (v15)
    {
      X509V3_conf_free(v15);
      v8 = *(_QWORD *)&v5->num;
    }
    ++v14;
  }
  while (v14 < v8);
LABEL_38:
  data = v5->data;
  if (data)
  {
    v18 = (uint64_t)*(data - 1);
    v17 = data - 1;
    v19 = v18 + 8;
    if (v18 != -8)
      bzero(v17, v19);
    free(v17);
  }
  comp = v5[-1].comp;
  p_comp = &v5[-1].comp;
  v22 = (size_t)comp + 8;
  if (comp != (int (__cdecl *)(const char *const *, const char *const *))-8)
    bzero(p_comp, v22);
  free(p_comp);
  return v2;
}

uint64_t dpn_cb(int a1, uint64_t *a2)
{
  uint64_t v2;
  ASN1_VALUE *pval;

  v2 = *a2;
  if (a1 == 3)
  {
    pval = *(ASN1_VALUE **)(v2 + 16);
    ASN1_item_ex_free(&pval, &X509_NAME_it);
    return 1;
  }
  else
  {
    if (a1 == 1)
      *(_QWORD *)(v2 + 16) = 0;
    return 1;
  }
}

uint64_t print_distpoint(BIO *bio, uint64_t a2, int a3)
{
  uint64_t result;
  unint64_t *v7;
  unint64_t v8;
  GENERAL_NAME *v9;
  _BYTE nm[40];

  if (*(_DWORD *)a2)
  {
    memset(&nm[8], 0, 32);
    *(_QWORD *)nm = *(_QWORD *)(a2 + 8);
    BIO_printf(bio, "%*sRelative Name:\n%*s", a3, &byte_208EB9246, a3 + 2, &byte_208EB9246);
    X509_NAME_print_ex(bio, (X509_NAME *)nm, 0, 0x82031FuLL);
    return BIO_puts(bio, "\n");
  }
  else
  {
    result = BIO_printf(bio, "%*sFull Name:\n", a3, &byte_208EB9246);
    v7 = *(unint64_t **)(a2 + 8);
    if (v7 && *v7)
    {
      v8 = 0;
      do
      {
        BIO_printf(bio, "%*s", a3 + 2, &byte_208EB9246);
        if (*v7 > v8)
          v9 = *(GENERAL_NAME **)(v7[1] + 8 * v8);
        else
          v9 = 0;
        GENERAL_NAME_print(bio, v9);
        result = BIO_puts(bio, "\n");
        ++v8;
      }
      while (v8 < *v7);
    }
  }
  return result;
}

uint64_t print_reasons(BIO *a1, const char *a2, uint64_t a3, int a4)
{
  char *v6;
  int v7;
  int v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  _BYTE *v14;
  _BYTE *v15;
  uint64_t v16;

  BIO_printf(a1, "%*s%s:\n%*s", a4, &byte_208EB9246, a2, a4 + 2, &byte_208EB9246);
  if (!a3)
    return BIO_puts(a1, "<EMPTY>\n");
  if (*(int *)a3 < 1)
    return BIO_puts(a1, "<EMPTY>\n");
  v6 = *(char **)(a3 + 8);
  if (!v6)
    return BIO_puts(a1, "<EMPTY>\n");
  v7 = *v6;
  if (v7 < 0)
  {
    BIO_puts(a1, "Unused");
    v8 = *(_DWORD *)a3;
    if (*(int *)a3 < 1)
      return BIO_puts(a1, "\n");
    v9 = *(_BYTE **)(a3 + 8);
    if (!v9)
      goto LABEL_45;
    if ((*v9 & 0x40) == 0)
      goto LABEL_21;
    BIO_puts(a1, ", ");
LABEL_20:
    BIO_puts(a1, "Key Compromise");
    v8 = *(_DWORD *)a3;
    if (*(int *)a3 < 1)
      return BIO_puts(a1, "\n");
LABEL_21:
    v10 = *(_BYTE **)(a3 + 8);
    if (!v10)
      goto LABEL_45;
    if ((*v10 & 0x20) == 0)
    {
LABEL_25:
      v11 = *(_BYTE **)(a3 + 8);
      if (!v11)
        goto LABEL_45;
      if ((*v11 & 0x10) == 0)
      {
LABEL_29:
        v12 = *(_BYTE **)(a3 + 8);
        if (!v12)
          goto LABEL_45;
        if ((*v12 & 8) == 0)
        {
LABEL_33:
          v13 = *(_BYTE **)(a3 + 8);
          if (!v13)
            goto LABEL_45;
          if ((*v13 & 4) == 0)
          {
LABEL_37:
            v14 = *(_BYTE **)(a3 + 8);
            if (!v14)
              goto LABEL_45;
            if ((*v14 & 2) == 0)
              goto LABEL_41;
            BIO_puts(a1, ", ");
LABEL_40:
            BIO_puts(a1, "Certificate Hold");
            v8 = *(_DWORD *)a3;
            if (*(int *)a3 >= 1)
            {
LABEL_41:
              v15 = *(_BYTE **)(a3 + 8);
              if (!v15 || (*v15 & 1) == 0)
                goto LABEL_45;
              BIO_puts(a1, ", ");
              goto LABEL_44;
            }
            return BIO_puts(a1, "\n");
          }
          BIO_puts(a1, ", ");
LABEL_36:
          BIO_puts(a1, "Cessation Of Operation");
          v8 = *(_DWORD *)a3;
          if (*(int *)a3 < 1)
            return BIO_puts(a1, "\n");
          goto LABEL_37;
        }
        BIO_puts(a1, ", ");
LABEL_32:
        BIO_puts(a1, "Superseded");
        v8 = *(_DWORD *)a3;
        if (*(int *)a3 < 1)
          return BIO_puts(a1, "\n");
        goto LABEL_33;
      }
      BIO_puts(a1, ", ");
LABEL_28:
      BIO_puts(a1, "Affiliation Changed");
      v8 = *(_DWORD *)a3;
      if (*(int *)a3 < 1)
        return BIO_puts(a1, "\n");
      goto LABEL_29;
    }
    BIO_puts(a1, ", ");
LABEL_24:
    BIO_puts(a1, "CA Compromise");
    v8 = *(_DWORD *)a3;
    if (*(int *)a3 < 1)
      return BIO_puts(a1, "\n");
    goto LABEL_25;
  }
  if ((v7 & 0x40) != 0)
    goto LABEL_20;
  if ((v7 & 0x20) != 0)
    goto LABEL_24;
  if ((v7 & 0x10) != 0)
    goto LABEL_28;
  if ((v7 & 8) != 0)
    goto LABEL_32;
  if ((v7 & 4) != 0)
    goto LABEL_36;
  if ((v7 & 2) != 0)
    goto LABEL_40;
  if ((v7 & 1) != 0)
  {
LABEL_44:
    BIO_puts(a1, "Privilege Withdrawn");
    v8 = *(_DWORD *)a3;
LABEL_45:
    if (v8 < 2)
      return BIO_puts(a1, "\n");
    v16 = *(_QWORD *)(a3 + 8);
    if (!v16 || (*(char *)(v16 + 1) & 0x80000000) == 0)
      return BIO_puts(a1, "\n");
    BIO_puts(a1, ", ");
    goto LABEL_49;
  }
  if (*(_DWORD *)a3 >= 2u && v6[1] < 0)
  {
LABEL_49:
    BIO_puts(a1, "AA Compromise");
    return BIO_puts(a1, "\n");
  }
  return BIO_puts(a1, "<EMPTY>\n");
}

char *__cdecl i2s_ASN1_ENUMERATED_TABLE(X509V3_EXT_METHOD *meth, ASN1_ENUMERATED *aint)
{
  int64_t v4;
  char *usr_data;
  const char *v6;
  const char **v7;
  uint64_t v8;
  size_t v9;
  size_t v10;
  _QWORD *v11;
  char *v12;
  int64_t v14;

  if (aint)
  {
    v14 = 0;
    if (asn1_string_get_int64(&v14, (const void **)aint, 10))
    {
      v4 = v14;
      usr_data = (char *)meth->usr_data;
      v6 = (const char *)*((_QWORD *)usr_data + 1);
      if (!v6)
        return i2s_ASN1_ENUMERATED(meth, aint);
    }
    else
    {
      ERR_clear_error();
      v4 = -1;
      usr_data = (char *)meth->usr_data;
      v6 = (const char *)*((_QWORD *)usr_data + 1);
      if (!v6)
        return i2s_ASN1_ENUMERATED(meth, aint);
    }
  }
  else
  {
    v4 = 0;
    usr_data = (char *)meth->usr_data;
    v6 = (const char *)*((_QWORD *)usr_data + 1);
    if (!v6)
      return i2s_ASN1_ENUMERATED(meth, aint);
  }
  if (v4 != *(_DWORD *)usr_data)
  {
    v7 = (const char **)(usr_data + 32);
    do
    {
      v6 = *v7;
      if (!*v7)
        return i2s_ASN1_ENUMERATED(meth, aint);
      v8 = *((int *)v7 - 2);
      v7 += 3;
    }
    while (v4 != v8);
  }
  v9 = strlen(v6);
  v10 = v9 + 1;
  if (v9 != -1)
  {
    if (v10 <= 0xFFFFFFFFFFFFFFF7)
    {
      v11 = malloc_type_malloc(v9 + 9, 0x30772F57uLL);
      if (v11)
      {
        *v11 = v10;
        v12 = (char *)(v11 + 1);
        memcpy(v11 + 1, v6, v10);
        return v12;
      }
    }
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  }
  return 0;
}

unint64_t *i2v_EXTENDED_KEY_USAGE(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v4;
  unint64_t v5;
  const ASN1_OBJECT *v6;
  size_t v7;
  unint64_t *v9;
  char buf[80];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v9 = a3;
  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = 0;
      do
      {
        if (v4 > v5)
          v6 = *(const ASN1_OBJECT **)(a2[1] + 8 * v5);
        else
          v6 = 0;
        OBJ_obj2txt(buf, 80, v6, 0);
        v7 = strlen(buf);
        x509V3_add_len_value(0, buf, v7, 0, &v9);
        ++v5;
        v4 = *a2;
      }
      while (v5 < *a2);
      return v9;
    }
  }
  return a3;
}

unint64_t *v2i_EXTENDED_KEY_USAGE(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t *v4;
  unint64_t v5;
  _QWORD *v6;
  const char *v7;
  ASN1_OBJECT *v8;
  unint64_t v9;
  unint64_t v10;
  ASN1_OBJECT *v11;
  unint64_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;
  unint64_t *v16;
  uint64_t v17;
  size_t v18;

  v4 = (unint64_t *)OPENSSL_sk_new_null();
  if (v4 && a3)
  {
    v5 = 0;
    while (v5 < *a3)
    {
      v6 = *(_QWORD **)(a3[1] + 8 * v5);
      v7 = (const char *)v6[2];
      if (!v7)
        v7 = (const char *)v6[1];
      v8 = OBJ_txt2obj(v7, 0);
      if (v8)
      {
        ++v5;
        if (OPENSSL_sk_insert(v4, (uint64_t)v8, *v4))
          continue;
      }
      ASN1_OBJECT_free(v8);
      v9 = *v4;
      if (*v4)
      {
        v10 = 0;
        do
        {
          v11 = *(ASN1_OBJECT **)(v4[1] + 8 * v10);
          if (v11)
          {
            ASN1_OBJECT_free(v11);
            v9 = *v4;
          }
          ++v10;
        }
        while (v10 < v9);
      }
      v12 = v4[1];
      if (v12)
      {
        v14 = *(_QWORD *)(v12 - 8);
        v13 = (void *)(v12 - 8);
        v15 = v14 + 8;
        if (v14 != -8)
          bzero(v13, v15);
        free(v13);
      }
      v17 = *(v4 - 1);
      v16 = v4 - 1;
      v18 = v17 + 8;
      if (v17 != -8)
        bzero(v16, v18);
      free(v16);
      ERR_put_error(20, 0, 129, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_extku.c", 147);
      ERR_add_error_data(6, "section:", *v6, ",name:", v6[1], ",value:", v6[2]);
      return 0;
    }
  }
  return v4;
}

uint64_t GENERAL_NAME_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  ASN1_STRING **v6;
  ASN1_STRING **v7;
  ASN1_STRING *v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  int v12;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 && *(_DWORD *)a1 == *(_DWORD *)a2)
  {
    switch(*(_DWORD *)a1)
    {
      case 0:
        v4 = *(_QWORD *)(a1 + 8);
        if (v4)
        {
          v5 = *(_QWORD *)(a2 + 8);
          if (v5)
          {
            result = OBJ_cmp(*(const ASN1_OBJECT **)v4, *(const ASN1_OBJECT **)v5);
            if (!(_DWORD)result)
              return ASN1_TYPE_cmp(*(int **)(v4 + 8), *(_QWORD *)(v5 + 8));
          }
        }
        return result;
      case 1:
      case 2:
      case 3:
      case 6:
      case 7:
        return ASN1_STRING_cmp(*(ASN1_STRING **)(a1 + 8), *(ASN1_STRING **)(a2 + 8));
      case 4:
        return X509_NAME_cmp(*(const X509_NAME **)(a1 + 8), *(const X509_NAME **)(a2 + 8));
      case 5:
        v6 = *(ASN1_STRING ***)(a1 + 8);
        v7 = *(ASN1_STRING ***)(a2 + 8);
        v8 = *v7;
        if (*v6)
        {
          if (v8 && !ASN1_STRING_cmp(*v6, v8))
            return ASN1_STRING_cmp(v6[1], v7[1]);
        }
        else if (!v8)
        {
          return ASN1_STRING_cmp(v6[1], v7[1]);
        }
        result = 0xFFFFFFFFLL;
        break;
      case 8:
        v9 = *(_QWORD *)(a1 + 8);
        v10 = *(_QWORD *)(a2 + 8);
        v11 = *(int *)(v9 + 20);
        v12 = *(_DWORD *)(v10 + 20);
        if ((int)v11 >= v12)
        {
          if ((int)v11 <= v12)
          {
            if ((_DWORD)v11)
              return memcmp(*(const void **)(v9 + 24), *(const void **)(v10 + 24), v11);
            else
              return 0;
          }
          else
          {
            return 1;
          }
        }
        return result;
      default:
        return result;
    }
  }
  return result;
}

_QWORD *i2s_ASN1_IA5STRING(uint64_t a1, int *a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _BYTE *v6;
  size_t v7;

  if (!a2)
    return 0;
  v3 = *a2;
  if (!(_DWORD)v3)
    return 0;
  v4 = v3 + 1;
  if ((v3 + 1) > 0xFFFFFFF7 || (v5 = malloc_type_malloc(v3 + 9, 0x30772F57uLL)) == 0)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  *v5 = v4;
  v6 = v5 + 1;
  v7 = *a2;
  if ((_DWORD)v7)
  {
    memcpy(v5 + 1, *((const void **)a2 + 1), v7);
    v6[*a2] = 0;
    return v6;
  }
  else
  {
    *v6 = 0;
    return v5 + 1;
  }
}

ASN1_STRING *s2i_ASN1_IA5STRING(uint64_t a1, uint64_t a2, const char *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  ASN1_STRING *v6;
  uint64_t *v7;
  int v8;
  const char *v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  size_t v17;

  if (!a3)
  {
    v10 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/x509/v3_ia5.c";
    v11 = 20;
    v12 = 124;
    v13 = 90;
LABEL_7:
    ERR_put_error(v11, 0, v12, v10, v13);
    return 0;
  }
  v4 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v4)
  {
    v10 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v11 = 14;
    v12 = 65;
    v13 = 247;
    goto LABEL_7;
  }
  v5 = v4;
  *v4 = 24;
  v4[1] = 0x1600000000;
  v6 = (ASN1_STRING *)(v4 + 1);
  v4[2] = 0;
  v7 = v4 + 2;
  v4[3] = 0;
  v8 = strlen(a3);
  if (ASN1_STRING_set(v6, a3, v8))
    return v6;
  v14 = *v7;
  if (*v7)
  {
    v16 = *(_QWORD *)(v14 - 8);
    v15 = (void *)(v14 - 8);
    v17 = v16 + 8;
    if (v16 != -8)
      bzero(v15, v17);
    free(v15);
  }
  if (*v5 != -8)
    __memset_chk();
  free(v5);
  return 0;
}

char *i2v_AUTHORITY_INFO_ACCESS(X509V3_EXT_METHOD *method, _QWORD *a2, unint64_t ret)
{
  unint64_t v4;
  unint64_t v7;
  STACK *v8;
  uint64_t v9;
  STACK *v10;
  char *v11;
  int v12;
  int64_t v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  size_t v29;
  unint64_t v30;
  unint64_t v31;
  CONF_VALUE *v32;
  char **data;
  char **v34;
  uint64_t v35;
  size_t v36;
  int (__cdecl **p_comp)(const char *const *, const char *const *);
  int (__cdecl *comp)(const char *const *, const char *const *);
  size_t v39;
  char buf[80];
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v4 = ret;
  if (!a2 || (v4 = ret, !*a2))
  {
LABEL_41:
    if (!(ret | v4))
      return OPENSSL_sk_new_null();
    return (char *)v4;
  }
  v7 = 0;
  v4 = ret;
  while (1)
  {
    v8 = (STACK *)v4;
    v9 = *(_QWORD *)(a2[1] + 8 * v7);
    v10 = i2v_GENERAL_NAME(method, *(GENERAL_NAME **)(v9 + 8), (STACK *)v4);
    if (!v10)
      break;
    v4 = (unint64_t)v10;
    if (*(_QWORD *)&v10->num <= v7)
      v11 = 0;
    else
      v11 = v10->data[v7];
    OBJ_obj2txt(buf, 80, *(const ASN1_OBJECT **)v9, 0);
    v12 = strlen(buf);
    v13 = ((unint64_t)(strlen(*((const char **)v11 + 1)) + v12) << 32) + 0x500000000;
    if ((unint64_t)v13 > 0xFFFFFFF700000000
      || (v14 = v13 >> 32, (v15 = malloc_type_malloc((v13 >> 32) + 8, 0x30772F57uLL)) == 0))
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v8 = (STACK *)v4;
      break;
    }
    *v15 = v14;
    v16 = v15 + 1;
    if ((unint64_t)v13 >= 0x100000001)
    {
      v17 = v14 - 1;
      v18 = buf;
      v19 = (char *)(v15 + 1);
      do
      {
        v20 = *v18;
        if (!*v18)
          break;
        ++v18;
        *v19++ = v20;
        --v17;
      }
      while (v17);
LABEL_18:
      v21 = 0;
      *v19 = 0;
      while (*((_BYTE *)v15 + v21 + 8))
      {
        if (v14 == ++v21)
          goto LABEL_28;
      }
      v22 = (char *)v15 + v21 + 8;
      if (v14 - v21 >= 2)
      {
        *v22 = 32;
        if (v14 - 2 == v21)
        {
          v22 = (char *)v15 + v21 + 9;
        }
        else
        {
          v22 = (char *)v15 + v21 + 10;
          *((_BYTE *)v15 + v21 + 9) = 45;
          if (v14 - 3 != v21)
          {
            *v22 = 32;
            v22 = (char *)v15 + v21 + 11;
          }
        }
      }
      *v22 = 0;
LABEL_28:
      v23 = *((_QWORD *)v11 + 1);
      v24 = v15 + 1;
      while (*v24)
      {
        ++v24;
        if (!--v14)
          goto LABEL_31;
      }
      if (v14 >= 2)
      {
        v26 = 0;
        do
        {
          if (!*(_BYTE *)(v23 + v26))
            break;
          v24[v26] = *(_BYTE *)(v23 + v26);
          ++v26;
        }
        while (v14 - 1 != v26);
        v24 += v26;
      }
      *v24 = 0;
      v25 = *((_QWORD *)v11 + 1);
      if (!v25)
        goto LABEL_5;
LABEL_39:
      v28 = *(_QWORD *)(v25 - 8);
      v27 = (void *)(v25 - 8);
      v29 = v28 + 8;
      if (v28 != -8)
        bzero(v27, v29);
      free(v27);
      goto LABEL_5;
    }
    v19 = (char *)(v15 + 1);
    if (v13)
      goto LABEL_18;
LABEL_31:
    v25 = *((_QWORD *)v11 + 1);
    if (v25)
      goto LABEL_39;
LABEL_5:
    *((_QWORD *)v11 + 1) = v16;
    if (++v7 >= *a2)
      goto LABEL_41;
  }
  v4 = 0;
  if (!ret && v8)
  {
    v30 = *(_QWORD *)&v8->num;
    if (*(_QWORD *)&v8->num)
    {
      v31 = 0;
      do
      {
        v32 = (CONF_VALUE *)v8->data[v31];
        if (v32)
        {
          X509V3_conf_free(v32);
          v30 = *(_QWORD *)&v8->num;
        }
        ++v31;
      }
      while (v31 < v30);
    }
    data = v8->data;
    if (data)
    {
      v35 = (uint64_t)*(data - 1);
      v34 = data - 1;
      v36 = v35 + 8;
      if (v35 != -8)
        bzero(v34, v36);
      free(v34);
    }
    comp = v8[-1].comp;
    p_comp = &v8[-1].comp;
    v39 = (size_t)comp + 8;
    if (comp != (int (__cdecl *)(const char *const *, const char *const *))-8)
      bzero(p_comp, v39);
    free(p_comp);
    return 0;
  }
  return (char *)v4;
}

unint64_t *v2i_AUTHORITY_INFO_ACCESS(X509V3_EXT_METHOD *a1, X509V3_CTX *a2, _QWORD *a3)
{
  unint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char *section;
  BOOL v11;
  char *v12;
  char *v13;
  const char *v14;
  const char *v15;
  ASN1_OBJECT *v16;
  char *v17;
  uint64_t v18;
  size_t v19;
  char *v20;
  uint64_t v21;
  size_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  void *v26;
  uint64_t v27;
  size_t v28;
  unint64_t *v29;
  uint64_t v30;
  size_t v31;
  CONF_VALUE pval;

  v6 = (unint64_t *)OPENSSL_sk_new_null();
  if (v6 && a3 && *a3)
  {
    v7 = 0;
    while (1)
    {
      v8 = *(_QWORD *)(a3[1] + 8 * v7);
      pval.section = 0;
      v9 = ASN1_item_ex_new((ASN1_VALUE **)&pval, &ACCESS_DESCRIPTION_it);
      section = pval.section;
      v11 = !v9 || pval.section == 0;
      if (v11 || !OPENSSL_sk_insert(v6, (uint64_t)pval.section, *v6))
        break;
      v12 = strchr(*(char **)(v8 + 8), 59);
      if (!v12)
      {
        ERR_put_error(20, 0, 135, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_info.c", 185);
        break;
      }
      v13 = v12;
      pval.section = 0;
      pval.name = v12 + 1;
      pval.value = 0;
      pval.value = *(char **)(v8 + 16);
      if (!v2i_GENERAL_NAME_ex(*((GENERAL_NAME **)section + 1), a1, a2, &pval, 0))
        break;
      v14 = (const char *)OPENSSL_strndup(*(_BYTE **)(v8 + 8), (size_t)&v13[-*(_QWORD *)(v8 + 8)]);
      if (!v14)
        break;
      v15 = v14;
      v16 = OBJ_txt2obj(v14, 0);
      *(_QWORD *)section = v16;
      if (!v16)
      {
        ERR_put_error(20, 0, 101, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_info.c", 200);
        ERR_add_error_data(2, "value=", v15);
        v21 = *((_QWORD *)v15 - 1);
        v20 = (char *)(v15 - 8);
        v22 = v21 + 8;
        if (v21 != -8)
          bzero(v20, v22);
        free(v20);
        break;
      }
      v18 = *((_QWORD *)v15 - 1);
      v17 = (char *)(v15 - 8);
      v19 = v18 + 8;
      if (v18 != -8)
        bzero(v17, v19);
      free(v17);
      if ((unint64_t)++v7 >= *a3)
        return v6;
    }
    v23 = *v6;
    if (*v6)
    {
      v24 = 0;
      do
      {
        if (*(_QWORD *)(v6[1] + 8 * v24))
        {
          pval.section = *(char **)(v6[1] + 8 * v24);
          ASN1_item_ex_free((ASN1_VALUE **)&pval, &ACCESS_DESCRIPTION_it);
          v23 = *v6;
        }
        ++v24;
      }
      while (v24 < v23);
    }
    v25 = v6[1];
    if (v25)
    {
      v27 = *(_QWORD *)(v25 - 8);
      v26 = (void *)(v25 - 8);
      v28 = v27 + 8;
      if (v27 != -8)
        bzero(v26, v28);
      free(v26);
    }
    v30 = *(v6 - 1);
    v29 = v6 - 1;
    v31 = v30 + 8;
    if (v30 != -8)
      bzero(v29, v31);
    free(v29);
    return 0;
  }
  return v6;
}

ASN1_INTEGER *s2i_asn1_int(X509V3_EXT_METHOD *a1, int a2, char *value)
{
  return s2i_ASN1_INTEGER(a1, value);
}

uint64_t ext_cmp(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

void *__cdecl X509V3_EXT_d2i(X509_EXTENSION *ext)
{
  int v2;
  uint64_t *v3;
  uint64_t v4;
  ASN1_OCTET_STRING *value;
  uint64_t length;
  const ASN1_ITEM *v7;
  void *result;
  ASN1_VALUE **__key;
  ASN1_VALUE *pval[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v2 = OBJ_obj2nid(ext->object);
  if (!v2)
    return 0;
  __key = pval;
  if (v2 < 0)
    return 0;
  v16 = 0;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  *(_OWORD *)pval = 0u;
  v11 = 0u;
  LODWORD(pval[0]) = v2;
  v3 = (uint64_t *)bsearch(&__key, &standard_exts, 0x1FuLL, 8uLL, (int (__cdecl *)(const void *, const void *))ext_cmp);
  if (!v3)
    return 0;
  v4 = *v3;
  if (!*v3)
    return 0;
  value = ext->value;
  __key = (ASN1_VALUE **)value->data;
  length = value->length;
  v7 = *(const ASN1_ITEM **)(v4 + 8);
  pval[0] = 0;
  if ((int)asn1_item_ex_d2i((uint64_t)pval, (unsigned __int8 **)&__key, length, (uint64_t)v7, -1, 0, 0, 0, 0) <= 0)
    ASN1_item_ex_free(pval, v7);
  result = pval[0];
  if (pval[0] && __key != (ASN1_VALUE **)&ext->value->data[ext->value->length])
  {
    ASN1_item_ex_free(pval, *(const ASN1_ITEM **)(v4 + 8));
    ERR_put_error(20, 0, 164, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_lib.c", 192);
    return 0;
  }
  return result;
}

void *__cdecl X509V3_get_d2i(STACK *x, int nid, int *crit, int *idx)
{
  int v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  char *v12;
  void *result;
  int v14;
  int v15;
  uint64_t *v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  const ASN1_ITEM *v20;
  ASN1_VALUE **__key;
  ASN1_VALUE *pval[2];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  if (!x)
  {
LABEL_30:
    if (idx)
LABEL_31:
      *idx = -1;
LABEL_32:
    if (!crit)
      return 0;
    result = 0;
    v14 = -1;
LABEL_34:
    *crit = v14;
    return result;
  }
  if (idx)
  {
    v8 = *idx;
    if (*idx < 0)
      v8 = -1;
    v9 = (v8 + 1);
    if (*(_QWORD *)&x->num > v9)
    {
      while (1)
      {
        v10 = x->data[v9];
        if (OBJ_obj2nid(*(const ASN1_OBJECT **)v10) == nid)
          break;
        if (++v9 >= *(_QWORD *)&x->num)
          goto LABEL_30;
      }
      *idx = v9;
      goto LABEL_19;
    }
    goto LABEL_31;
  }
  if (!*(_QWORD *)&x->num)
    goto LABEL_32;
  v11 = 0;
  v12 = 0;
  do
  {
    v10 = x->data[v11];
    if (OBJ_obj2nid(*(const ASN1_OBJECT **)v10) == nid)
    {
      if (v12)
      {
        result = 0;
        if (!crit)
          return result;
        v14 = -2;
        goto LABEL_34;
      }
    }
    else
    {
      v10 = v12;
    }
    ++v11;
    v12 = v10;
  }
  while (v11 < *(_QWORD *)&x->num);
  if (!v10)
    goto LABEL_30;
LABEL_19:
  if (crit)
    *crit = *((_DWORD *)v10 + 2) > 0;
  v15 = OBJ_obj2nid(*(const ASN1_OBJECT **)v10);
  if (!v15)
    return 0;
  __key = pval;
  if (v15 < 0)
    return 0;
  v28 = 0;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  *(_OWORD *)pval = 0u;
  v23 = 0u;
  LODWORD(pval[0]) = v15;
  v16 = (uint64_t *)bsearch(&__key, &standard_exts, 0x1FuLL, 8uLL, (int (__cdecl *)(const void *, const void *))ext_cmp);
  if (!v16)
    return 0;
  v17 = *v16;
  if (!*v16)
    return 0;
  v18 = (int *)*((_QWORD *)v10 + 2);
  __key = (ASN1_VALUE **)*((_QWORD *)v18 + 1);
  v19 = *v18;
  v20 = *(const ASN1_ITEM **)(v17 + 8);
  pval[0] = 0;
  if ((int)asn1_item_ex_d2i((uint64_t)pval, (unsigned __int8 **)&__key, v19, (uint64_t)v20, -1, 0, 0, 0, 0) <= 0)
    ASN1_item_ex_free(pval, v20);
  result = pval[0];
  if (pval[0] && __key != (ASN1_VALUE **)(*(_QWORD *)(*((_QWORD *)v10 + 2) + 8) + **((int **)v10 + 2)))
  {
    ASN1_item_ex_free(pval, *(const ASN1_ITEM **)(v17 + 8));
    ERR_put_error(20, 0, 164, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_lib.c", 192);
    return 0;
  }
  return result;
}

char *v2i_NAME_CONSTRAINTS(X509V3_EXT_METHOD *a1, X509V3_CTX *a2, unint64_t *a3)
{
  char *section;
  unint64_t i;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t **v11;
  char *v12;
  int v13;
  char *v14;
  GENERAL_NAME **v15;
  unint64_t *v16;
  CONF_VALUE v18;
  ASN1_VALUE *pval;

  v18.section = 0;
  if (ASN1_item_ex_new((ASN1_VALUE **)&v18, &NAME_CONSTRAINTS_it))
    section = v18.section;
  else
    section = 0;
  if (!section)
  {
    v18.section = 0;
    ASN1_item_ex_free((ASN1_VALUE **)&v18, &NAME_CONSTRAINTS_it);
    v14 = 0;
    goto LABEL_27;
  }
  if (!a3)
    return v18.section;
  if (*a3)
  {
    for (i = 0; i < *a3; ++i)
    {
      v8 = *(_QWORD *)(a3[1] + 8 * i);
      memset(&v18, 0, sizeof(v18));
      v9 = *(_QWORD *)(v8 + 8);
      if (!strncmp((const char *)v9, "permitted", 9uLL) && *(_BYTE *)(v9 + 9))
      {
        v10 = 10;
        v11 = (unint64_t **)section;
      }
      else
      {
        if (strncmp((const char *)v9, "excluded", 8uLL) || !*(_BYTE *)(v9 + 8))
        {
          ERR_put_error(20, 0, 135, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_ncons.c", 142);
          v14 = 0;
LABEL_26:
          v18.section = section;
          ASN1_item_ex_free((ASN1_VALUE **)&v18, &NAME_CONSTRAINTS_it);
LABEL_27:
          v18.section = v14;
          ASN1_item_ex_free((ASN1_VALUE **)&v18, &GENERAL_SUBTREE_it);
          return 0;
        }
        v10 = 9;
        v11 = (unint64_t **)(section + 8);
      }
      v12 = *(char **)(v8 + 16);
      v18.name = (char *)(v9 + v10);
      v18.value = v12;
      pval = 0;
      v13 = ASN1_item_ex_new(&pval, &GENERAL_SUBTREE_it);
      v14 = (char *)pval;
      if (v13)
        v15 = (GENERAL_NAME **)pval;
      else
        v15 = 0;
      if (!v2i_GENERAL_NAME_ex(*v15, a1, a2, &v18, 1))
        goto LABEL_26;
      v16 = *v11;
      if (!*v11)
      {
        v16 = (unint64_t *)OPENSSL_sk_new_null();
        *v11 = v16;
        if (!v16)
          goto LABEL_26;
      }
      if (!OPENSSL_sk_insert(v16, (uint64_t)v15, *v16))
        goto LABEL_26;
    }
  }
  return section;
}

uint64_t i2r_NAME_CONSTRAINTS(int a1, unint64_t **a2, BIO *bio, int a4)
{
  do_i2r_name_constraints(*a2, bio, a4, "Permitted");
  do_i2r_name_constraints(a2[1], bio, a4, "Excluded");
  return 1;
}

uint64_t NAME_CONSTRAINTS_check(_QWORD *a1, uint64_t a2)
{
  int **v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  BOOL v13;
  char v14;
  uint64_t result;
  int v16;
  int *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t *v31;
  uint64_t v32;
  int **v33;

  v4 = *(int ***)(*a1 + 40);
  if (v4 && *v4)
  {
    v5 = **v4;
    v6 = (uint64_t *)a1[11];
    if (!v6)
      goto LABEL_4;
  }
  else
  {
    v5 = 0;
    v6 = (uint64_t *)a1[11];
    if (!v6)
    {
LABEL_4:
      v7 = 0;
      v8 = *(unint64_t **)a2;
      if (!*(_QWORD *)a2)
        goto LABEL_5;
LABEL_9:
      v9 = *v8;
      v10 = v7 + v5;
      v11 = *(_QWORD **)(a2 + 8);
      if (!v11)
        goto LABEL_11;
      goto LABEL_10;
    }
  }
  v7 = *v6;
  v8 = *(unint64_t **)a2;
  if (*(_QWORD *)a2)
    goto LABEL_9;
LABEL_5:
  v9 = 0;
  v10 = v7 + v5;
  v11 = *(_QWORD **)(a2 + 8);
  if (v11)
LABEL_10:
    v11 = (_QWORD *)*v11;
LABEL_11:
  v12 = (unint64_t)v11 + v9;
  v13 = !is_mul_ok(v12, v10);
  if (v4 && *v4 && v10 < **v4)
    return 1;
  if (v8 && v12 < *v8)
    return 1;
  if (v12)
  {
    v14 = v12 * v10 > 0x100000 || v13;
    if ((v14 & 1) != 0)
      return 1;
  }
  if (v4 && *v4 && **v4 >= 1)
  {
    v32 = 4;
    v33 = v4;
    result = nc_match(&v32, (unint64_t **)a2);
    if ((_DWORD)result)
      return result;
    LODWORD(v32) = 1;
    v16 = -1;
LABEL_28:
    v17 = *v4;
    if (*v4)
      v18 = *v17;
    else
      v18 = 0;
    if (v16 < 0)
      v19 = -1;
    else
      v19 = v16;
    v20 = v19 + 1;
    v21 = -v19;
    while (v20 < v18)
    {
      v23 = v20;
      v24 = *((_QWORD *)v17 + 1);
      v25 = **(_QWORD **)(v24 + 8 * v20);
      if (*(_DWORD *)(v25 + 20) == 9)
      {
        v26 = *(_QWORD *)(v25 + 24);
        v27 = bswap64(*(_QWORD *)v26);
        v28 = bswap64(0x9010DF78648862AuLL);
        if (v27 == v28)
        {
          v22 = *(unsigned __int8 *)(v26 + 8) - 1;
        }
        else if (v27 < v28)
        {
          v22 = -1;
        }
        else
        {
          v22 = 1;
        }
      }
      else
      {
        v22 = -1;
      }
      v20 = v23 + 1;
      --v21;
      if (!v22)
      {
        if (v21 == 1)
          break;
        v16 = -v21;
        if (-v21 < 0 || *(_QWORD *)v17 <= (unint64_t)v23)
        {
          v29 = 0;
        }
        else
        {
          v29 = *(_QWORD *)(v24 + 8 * v23);
          if (v29)
            v29 = *(_QWORD *)(v29 + 8);
        }
        v33 = (int **)v29;
        if (*(_DWORD *)(v29 + 4) != 22)
          return 53;
        result = nc_match(&v32, (unint64_t **)a2);
        if (!(_DWORD)result)
          goto LABEL_28;
        return result;
      }
    }
  }
  v30 = 0;
  while (1)
  {
    v31 = (unint64_t *)a1[11];
    if (!v31 || v30 >= *v31)
      break;
    result = nc_match(*(_DWORD **)(v31[1] + 8 * v30++), (unint64_t **)a2);
    if ((_DWORD)result)
      return result;
  }
  return 0;
}

uint64_t nc_match(_DWORD *a1, unint64_t **a2)
{
  unint64_t *v4;
  unint64_t v5;
  int v6;
  uint64_t *v7;
  uint64_t result;
  unint64_t *v9;
  unint64_t i;
  uint64_t *v11;

  v4 = *a2;
  if (*a2)
  {
    v5 = 0;
    v6 = 0;
    do
    {
      if (v5 >= *v4)
        break;
      v7 = *(uint64_t **)(v4[1] + 8 * v5);
      if (*a1 == *(_DWORD *)*v7)
      {
        if (v7[1] || v7[2])
          return 49;
        if (v6 != 2)
        {
          result = nc_match_single((uint64_t)a1, *v7);
          if ((_DWORD)result)
          {
            if ((_DWORD)result != 47)
              return result;
            v6 = 1;
          }
          else
          {
            v6 = 2;
          }
        }
      }
      ++v5;
      v4 = *a2;
    }
    while (*a2);
    if (v6 != 1)
      goto LABEL_16;
    return 47;
  }
  else
  {
LABEL_16:
    v9 = a2[1];
    if (v9)
    {
      for (i = 0; i < *v9; ++i)
      {
        v11 = *(uint64_t **)(v9[1] + 8 * i);
        if (*a1 == *(_DWORD *)*v11)
        {
          if (v11[1] || v11[2])
            return 49;
          result = nc_match_single((uint64_t)a1, *v11);
          if ((_DWORD)result != 47)
          {
            if (!(_DWORD)result)
              return 48;
            return result;
          }
          v9 = a2[1];
        }
        if (!v9)
          return 0;
      }
    }
    return 0;
  }
}

unint64_t *do_i2r_name_constraints(unint64_t *result, BIO *bio, int a3, const char *a4)
{
  unint64_t *v6;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  const char *v10;
  const char *v11;
  GENERAL_NAME **v12;
  GENERAL_NAME *v13;
  const char *v14;
  const char *v15;
  char *v16;
  char *ptr;
  int v18;
  unsigned __int16 *v19;
  uint64_t v20;

  if (result)
  {
    v6 = result;
    v7 = &byte_208EB9246;
    if (*result)
      result = (unint64_t *)BIO_printf(bio, "%*s%s:\n", a3, &byte_208EB9246, a4);
    if (*v6)
    {
      v8 = 0;
      v9 = (a3 + 2);
      v10 = "%*s";
      v11 = "\n";
      v20 = v9;
      do
      {
        v12 = *(GENERAL_NAME ***)(v6[1] + 8 * v8);
        BIO_printf(bio, v10, v9, v7);
        v13 = *v12;
        if ((*v12)->type == 7)
        {
          v14 = v11;
          v15 = v10;
          v16 = v7;
          ptr = v13->d.ptr;
          v18 = *(_DWORD *)ptr;
          v19 = (unsigned __int16 *)*((_QWORD *)ptr + 1);
          BIO_puts(bio, "IP:");
          if (v18 == 32)
          {
            BIO_printf(bio, "%X", __rev16(*v19));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[1]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[2]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[3]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[4]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[5]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[6]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[7]));
            BIO_puts(bio, "/");
            BIO_printf(bio, "%X", __rev16(v19[8]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[9]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[10]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[11]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[12]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[13]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X", __rev16(v19[14]));
            BIO_puts(bio, ":");
            BIO_printf(bio, "%X");
          }
          else if (v18 == 8)
          {
            BIO_printf(bio, "%d.%d.%d.%d/%d.%d.%d.%d", *(unsigned __int8 *)v19);
          }
          else
          {
            BIO_printf(bio, "IP Address:<invalid>");
          }
          v7 = v16;
          v10 = v15;
          v11 = v14;
          v9 = v20;
        }
        else
        {
          GENERAL_NAME_print(bio, v13);
        }
        result = (unint64_t *)BIO_puts(bio, v11);
        ++v8;
      }
      while (v8 < *v6);
    }
  }
  return result;
}

uint64_t nc_match_single(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int *v4;
  unint64_t v5;
  int *v6;
  int8x16_t *v7;
  size_t v8;
  int8x16_t *v9;
  int8x16_t *v10;
  int8x16_t *v11;
  unint64_t v12;
  size_t v13;
  int8x16_t *v14;
  int8x16_t *v15;
  int64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int *v24;
  unint64_t v25;
  int *v26;
  unint64_t v27;
  unsigned __int8 *v28;
  _BYTE *v29;
  unsigned __int8 *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  size_t v38;
  int *v39;
  unint64_t v40;
  int *v41;
  char *v42;
  unint64_t v43;
  _BYTE *v44;
  _BYTE *v45;
  int64_t v46;
  unint64_t v47;
  char *v48;
  size_t v49;
  unsigned __int8 *v50;
  _BYTE *v51;
  size_t v52;
  BOOL v53;
  _BYTE *v54;
  unsigned __int8 *v55;
  uint64_t v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  unint64_t v62;
  unsigned __int8 *v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  unint64_t v70;
  unsigned __int8 v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int8x16_t *v77;
  int8x16_t *v78;
  int8x16_t v79;
  unint64_t v80;
  int8x16_t v81;
  int8x16_t v82;
  unint64_t v83;
  unint64_t v84;
  int8x8_t v85;
  int8x8_t *v86;
  int8x8_t *v87;
  unint64_t v88;
  int8x8_t v89;
  int8x8_t v90;
  int8x8_t v91;
  uint64_t v92;
  __int8 *v93;
  char *v94;
  __int8 *v95;
  char v96;
  char v97;
  char v98;
  BOOL v99;
  size_t v100;
  size_t v101;
  unsigned __int8 *v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  unint64_t *v108;

  result = 51;
  switch(*(_DWORD *)a2)
  {
    case 1:
      v4 = *(int **)(a1 + 8);
      v5 = *v4;
      if (!(_DWORD)v5)
        return 53;
      v6 = *(int **)(a2 + 8);
      v7 = (int8x16_t *)*((_QWORD *)v4 + 1);
      v8 = *v6;
      v9 = (int8x16_t *)*((_QWORD *)v6 + 1);
      v10 = (int8x16_t *)memchr(v7, 64, *v4);
      if (!v10)
        return 53;
      v11 = v10;
      v12 = (char *)v10 - (char *)v7;
      v13 = v5 - ((char *)v10 - (char *)v7);
      if (v5 < (char *)v10 - (char *)v7)
        return 53;
      v14 = v10;
      if (!(_DWORD)v8)
      {
        v8 = 0;
        goto LABEL_116;
      }
      v15 = (int8x16_t *)memchr(v9, 64, v8);
      if (v15)
      {
        v16 = (char *)v15 - (char *)v9;
        if ((char *)v15 - (char *)v9 <= v8)
        {
          if (v15 == v9)
            goto LABEL_110;
          if (v16 != v12)
            return 47;
          if (v11 == v7)
          {
LABEL_110:
            v99 = v16 == v8;
            v100 = ~v16 + v8;
            if (v99)
              v8 = 0;
            else
              v8 = v100;
            if (v99)
              v9 = v15;
            else
              v9 = (int8x16_t *)&v15->i8[1];
            goto LABEL_116;
          }
          if (v12 < 8)
          {
            v70 = 0;
            v71 = 0;
            goto LABEL_106;
          }
          if (v12 >= 0x20)
          {
            v70 = v12 & 0xFFFFFFFFFFFFFFE0;
            v77 = v9 + 1;
            v78 = v7 + 1;
            v79 = 0uLL;
            v80 = v12 & 0xFFFFFFFFFFFFFFE0;
            v81 = 0uLL;
            do
            {
              v79 = vorrq_s8(veorq_s8(v78[-1], v77[-1]), v79);
              v81 = vorrq_s8(veorq_s8(*v78, *v77), v81);
              v77 += 2;
              v78 += 2;
              v80 -= 32;
            }
            while (v80);
            v82 = vorrq_s8(v81, v79);
            *(int8x8_t *)v82.i8 = vorr_s8(*(int8x8_t *)v82.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v82, v82, 8uLL));
            v83 = v82.i64[0] | HIDWORD(v82.i64[0]) | ((unint64_t)(v82.i64[0] | HIDWORD(v82.i64[0])) >> 16);
            v71 = v83 | BYTE1(v83);
            if (v12 == v70)
              goto LABEL_109;
            if ((v12 & 0x18) == 0)
            {
LABEL_106:
              v93 = &v7->i8[v70];
              v94 = (char *)(&v7->i8[v70] - (__int8 *)v11);
              v95 = &v9->i8[v70];
              do
              {
                v97 = *v95++;
                v96 = v97;
                v98 = *v93++;
                v71 |= v98 ^ v96;
                v53 = __CFADD__(v94++, 1);
              }
              while (!v53);
              goto LABEL_109;
            }
          }
          else
          {
            v71 = 0;
            v70 = 0;
          }
          v84 = v70;
          v70 = v12 & 0xFFFFFFFFFFFFFFF8;
          v85 = (int8x8_t)v71;
          v86 = (int8x8_t *)&v9->i8[v84];
          v87 = (int8x8_t *)&v7->i8[v84];
          v88 = v84 - (v12 & 0xFFFFFFFFFFFFFFF8);
          do
          {
            v89 = *v86++;
            v90 = v89;
            v91 = *v87++;
            v85 = vorr_s8(veor_s8(v91, v90), v85);
            v88 += 8;
          }
          while (v88);
          v92 = *(_QWORD *)&v85 | HIDWORD(*(_QWORD *)&v85) | ((*(_QWORD *)&v85 | HIDWORD(*(_QWORD *)&v85)) >> 16);
          v71 = v92 | BYTE1(v92);
          if (v12 != v70)
            goto LABEL_106;
LABEL_109:
          if (v71)
            return 47;
          goto LABEL_110;
        }
      }
      if (v9->i8[0] == 46)
      {
        if (v13 < v8)
          return 47;
        v17 = &v14->u8[v13 - v8];
        if (v8 <= 1)
          v18 = 1;
        else
          v18 = v8;
        do
        {
          v20 = *v17++;
          v19 = v20;
          v21 = v20 + 32;
          v53 = (v20 - 65) >= 0x1A;
          v23 = v9->u8[0];
          v9 = (int8x16_t *)((char *)v9 + 1);
          v22 = v23;
          if (!v53)
            v19 = v21;
          if ((v22 - 65) < 0x1A)
            v22 += 32;
          if (v19 != v22)
            return 47;
          result = 0;
          --v18;
        }
        while (v18);
        return result;
      }
LABEL_116:
      if (v13)
        v101 = v13 - 1;
      else
        v101 = 0;
      if (v5 == v12)
        v102 = &v7->u8[v12];
      else
        v102 = &v14->u8[1];
      if (v8 != v101)
        return 47;
      if (!v8)
        return 0;
      do
      {
        v104 = v9->u8[0];
        v9 = (int8x16_t *)((char *)v9 + 1);
        v103 = v104;
        v105 = v104 + 32;
        v53 = (v104 - 65) >= 0x1A;
        v107 = *v102++;
        v106 = v107;
        if (!v53)
          v103 = v105;
        if ((v106 - 65) < 0x1A)
          v106 += 32;
        if (v103 != v106)
          return 47;
        result = 0;
        --v8;
      }
      while (v8);
      return result;
    case 2:
      v24 = *(int **)(a2 + 8);
      v25 = *v24;
      if (!(_DWORD)v25)
        return 0;
      v26 = *(int **)(a1 + 8);
      v27 = *v26;
      v28 = (unsigned __int8 *)*((_QWORD *)v26 + 1);
      v29 = (_BYTE *)*((_QWORD *)v24 + 1);
      if (*v29 == 46)
      {
        if (v27 < v25)
          return 47;
        v30 = &v28[v27 - v25];
        if (v25 <= 1)
          v25 = 1;
        do
        {
          v32 = *v30++;
          v31 = v32;
          v33 = v32 + 32;
          v53 = (v32 - 65) >= 0x1A;
          v35 = *v29++;
          v34 = v35;
          if (!v53)
            v31 = v33;
          if ((v34 - 65) < 0x1A)
            v34 += 32;
          if (v31 != v34)
            return 47;
          result = 0;
          --v25;
        }
        while (v25);
      }
      else
      {
        if (v27 <= v25)
        {
          if ((_DWORD)v27 != (_DWORD)v25)
            return 47;
        }
        else
        {
          v62 = ~v25 + v27;
          if (v62 > v27)
            return 47;
          v63 = &v28[v62];
          v64 = *v63;
          v28 = v63 + 1;
          if (v64 != 46)
            return 47;
        }
        if (v25 <= 1)
          v25 = 1;
        do
        {
          v66 = *v28++;
          v65 = v66;
          v67 = v66 + 32;
          v53 = (v66 - 65) >= 0x1A;
          v69 = *v29++;
          v68 = v69;
          if (!v53)
            v65 = v67;
          if ((v68 - 65) < 0x1A)
            v68 += 32;
          if (v65 != v68)
            return 47;
          result = 0;
          --v25;
        }
        while (v25);
      }
      return result;
    case 4:
      v36 = *(_QWORD *)(a1 + 8);
      v37 = *(_QWORD *)(a2 + 8);
      if (*(_DWORD *)(v36 + 8))
      {
        v108 = *(unint64_t **)(a1 + 8);
        if ((asn1_item_ex_i2d_opt(&v108, 0, (uint64_t)&X509_NAME_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) != 0)
          return 17;
      }
      if (*(_DWORD *)(v37 + 8))
      {
        v108 = (unint64_t *)v37;
        if ((asn1_item_ex_i2d_opt(&v108, 0, (uint64_t)&X509_NAME_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) != 0)
          return 17;
      }
      v38 = *(int *)(v37 + 32);
      if ((int)v38 > *(_DWORD *)(v36 + 32)
        || (_DWORD)v38 && memcmp(*(const void **)(v37 + 24), *(const void **)(v36 + 24), v38))
      {
        return 47;
      }
      return 0;
    case 6:
      v39 = *(int **)(a1 + 8);
      v40 = *v39;
      if (!(_DWORD)v40)
        return 53;
      v41 = *(int **)(a2 + 8);
      v42 = (char *)*((_QWORD *)v39 + 1);
      v43 = *v41;
      v44 = (_BYTE *)*((_QWORD *)v41 + 1);
      v45 = memchr(v42, 58, *v39);
      if (!v45)
        return 53;
      v46 = v45 - v42;
      if (v45 - v42 >= v40)
        return 53;
      result = 53;
      v47 = ~v46 + v40;
      if (v47 >= 2)
      {
        v48 = &v42[v46];
        if (v48[1] == 47)
        {
          v49 = v47 - 2;
          if (v47 != 2 && v48[2] == 47)
          {
            v50 = (unsigned __int8 *)(v48 + 3);
            v51 = memchr(v48 + 3, 58, v49);
            v52 = v51 - v50;
            if (v51)
              v53 = v49 >= v52;
            else
              v53 = 0;
            if (v53 || (v54 = memchr(v50, 47, v49)) != 0 && (v52 = v54 - v50, v49 >= v54 - v50))
            {
              v49 = v52;
              if (!v52)
                return 53;
            }
            if ((_DWORD)v43)
            {
              if (*v44 == 46)
              {
                if (v49 >= v43)
                {
                  v55 = &v50[v49 - v43];
                  if (v43 <= 1)
                    v56 = 1;
                  else
                    v56 = v43;
                  while (1)
                  {
                    v58 = *v55++;
                    v57 = v58;
                    v59 = v58 + 32;
                    v53 = (v58 - 65) >= 0x1A;
                    v61 = *v44++;
                    v60 = v61;
                    if (!v53)
                      v57 = v59;
                    if ((v60 - 65) < 0x1A)
                      v60 += 32;
                    if (v57 != v60)
                      break;
                    result = 0;
                    if (!--v56)
                      return result;
                  }
                }
              }
              else if (v49 == v43)
              {
                while (1)
                {
                  v73 = *v44++;
                  v72 = v73;
                  v74 = v73 + 32;
                  v53 = (v73 - 65) >= 0x1A;
                  v76 = *v50++;
                  v75 = v76;
                  if (!v53)
                    v72 = v74;
                  if ((v75 - 65) < 0x1A)
                    v75 += 32;
                  if (v72 != v75)
                    break;
                  result = 0;
                  if (!--v43)
                    return result;
                }
              }
            }
            return 47;
          }
        }
      }
      return result;
    default:
      return result;
  }
}

BOOL i2r_ocsp_acutoff(int a1, int *a2, BIO *bio, int a4)
{
  uint64_t v6;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;

  if (BIO_printf(bio, "%*s", a4, &byte_208EB9246) < 1)
    return 0;
  v6 = *a2;
  *(_QWORD *)&v12 = *((_QWORD *)a2 + 1);
  *((_QWORD *)&v12 + 1) = v6;
  v11 = 0;
  v9 = 0u;
  v10 = 0u;
  v8 = 0u;
  if (CBS_parse_rfc5280_time_internal(&v12, 1, 0, (int *)&v8))
    return BIO_printf(bio, "%s %2d %02d:%02d:%02d %d GMT", mon[(int)v9], HIDWORD(v8), DWORD2(v8), DWORD1(v8), (_DWORD)v8, DWORD1(v9) + 1900) > 0;
  BIO_puts(bio, "Bad time value");
  return 0;
}

ASN1_VALUE *s2i_ocsp_nocheck()
{
  ASN1_VALUE *pval;

  pval = 0;
  if (ASN1_item_ex_new(&pval, (const ASN1_ITEM *)&ASN1_GENERALIZEDTIME_it.sname))
    return pval;
  else
    return 0;
}

uint64_t i2r_ocsp_nocheck()
{
  return 1;
}

STACK *i2v_POLICY_CONSTRAINTS(uint64_t a1, ASN1_INTEGER **a2, STACK *a3)
{
  STACK *extlist;

  extlist = a3;
  X509V3_add_value_int("Require Explicit Policy", *a2, &extlist);
  X509V3_add_value_int("Inhibit Policy Mapping", a2[1], &extlist);
  return extlist;
}

ASN1_INTEGER **v2i_POLICY_CONSTRAINTS(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  int v4;
  ASN1_INTEGER **result;
  ASN1_INTEGER **v6;
  BOOL v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t i;
  CONF_VALUE *v11;
  const char *name;
  ASN1_VALUE *pval;

  pval = 0;
  v4 = ASN1_item_ex_new(&pval, &POLICY_CONSTRAINTS_it);
  result = 0;
  v6 = (ASN1_INTEGER **)pval;
  if (v4)
    v7 = pval == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = (_QWORD *)((char *)pval + 8);
    if (a3)
    {
      v9 = *a3;
      if (*a3)
      {
        for (i = 0; i < *a3; ++i)
        {
          if (v9 <= i)
          {
            v11 = 0;
            name = (const char *)MEMORY[8];
            if (!strcmp(MEMORY[8], "requireExplicitPolicy"))
            {
LABEL_8:
              if (!X509V3_get_value_int(v11, v6))
                goto LABEL_22;
              goto LABEL_9;
            }
          }
          else
          {
            v11 = *(CONF_VALUE **)(a3[1] + 8 * i);
            name = v11->name;
            if (!strcmp(name, "requireExplicitPolicy"))
              goto LABEL_8;
          }
          if (strcmp(name, "inhibitPolicyMapping"))
          {
            ERR_put_error(20, 0, 123, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_pcons.c", 128);
            ERR_add_error_data(6, "section:", v11->section, ",name:", v11->name, ",value:", v11->value);
            goto LABEL_22;
          }
          if (!X509V3_get_value_int(v11, v6 + 1))
            goto LABEL_22;
LABEL_9:
          v9 = *a3;
        }
      }
    }
    if (*v8 || *v6)
    {
      return v6;
    }
    else
    {
      ERR_put_error(20, 0, 117, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_pcons.c", 134);
LABEL_22:
      pval = (ASN1_VALUE *)v6;
      ASN1_item_ex_free(&pval, &POLICY_CONSTRAINTS_it);
      return 0;
    }
  }
  return result;
}

unint64_t *i2v_POLICY_MAPPINGS(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v4;
  const ASN1_OBJECT **v5;
  size_t v6;
  unint64_t *v8;
  char __s[80];
  char buf[80];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = a3;
  if (a2 && *a2)
  {
    v4 = 0;
    do
    {
      v5 = *(const ASN1_OBJECT ***)(a2[1] + 8 * v4);
      OBJ_obj2txt(buf, 80, *v5, 0);
      OBJ_obj2txt(__s, 80, v5[1], 0);
      v6 = strlen(__s);
      x509V3_add_len_value(buf, __s, v6, 0, &v8);
      ++v4;
    }
    while (v4 < *a2);
    return v8;
  }
  return a3;
}

unint64_t *v2i_POLICY_MAPPINGS(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  ASN1_VALUE *v7;
  ASN1_OBJECT *v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;
  unint64_t *v16;
  uint64_t v17;
  size_t v18;
  ASN1_VALUE *pval;

  v4 = (unint64_t *)OPENSSL_sk_new_null();
  if (v4 && a3)
  {
    v5 = 0;
    while (1)
    {
      if (v5 >= *a3)
        return v4;
      v6 = *(_QWORD *)(a3[1] + 8 * v5);
      if (!*(_QWORD *)(v6 + 16) || !*(_QWORD *)(v6 + 8))
        break;
      pval = 0;
      if (!ASN1_item_ex_new(&pval, &POLICY_MAPPING_it) || (v7 = pval) == 0)
      {
        pval = 0;
        goto LABEL_18;
      }
      if (!OPENSSL_sk_insert(v4, (uint64_t)pval, *v4))
      {
        pval = v7;
LABEL_18:
        ASN1_item_ex_free(&pval, &POLICY_MAPPING_it);
        v10 = *v4;
        if (*v4)
        {
LABEL_19:
          v11 = 0;
          do
          {
            if (*(_QWORD *)(v4[1] + 8 * v11))
            {
              pval = *(ASN1_VALUE **)(v4[1] + 8 * v11);
              ASN1_item_ex_free(&pval, &POLICY_MAPPING_it);
              v10 = *v4;
            }
            ++v11;
          }
          while (v11 < v10);
        }
LABEL_23:
        v12 = v4[1];
        if (v12)
        {
          v14 = *(_QWORD *)(v12 - 8);
          v13 = (void *)(v12 - 8);
          v15 = v14 + 8;
          if (v14 != -8)
            bzero(v13, v15);
          free(v13);
        }
        v17 = *(v4 - 1);
        v16 = v4 - 1;
        v18 = v17 + 8;
        if (v17 != -8)
          bzero(v16, v18);
        free(v16);
        return 0;
      }
      *(_QWORD *)v7 = OBJ_txt2obj(*(const char **)(v6 + 8), 0);
      v8 = OBJ_txt2obj(*(const char **)(v6 + 16), 0);
      *((_QWORD *)v7 + 1) = v8;
      if (*(_QWORD *)v7)
      {
        ++v5;
        if (v8)
          continue;
      }
      v9 = 140;
      goto LABEL_14;
    }
    v9 = 126;
LABEL_14:
    ERR_put_error(20, 0, 129, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_pmaps.c", v9);
    ERR_add_error_data(6, "section:", *(_QWORD *)v6, ",name:", *(_QWORD *)(v6 + 8), ",value:", *(_QWORD *)(v6 + 16));
    v10 = *v4;
    if (*v4)
      goto LABEL_19;
    goto LABEL_23;
  }
  return v4;
}

void POLICY_MAPPING_free(POLICY_MAPPING *a)
{
  ASN1_VALUE *pval;

  pval = (ASN1_VALUE *)a;
  ASN1_item_ex_free(&pval, &POLICY_MAPPING_it);
}

BOOL x509v3_cache_extensions(const void ****a1)
{
  pthread_rwlock_t *v2;
  int v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  unsigned __int8 *v7;
  const void **v8;
  unsigned __int8 *d2i;
  unsigned __int8 *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int *v15;
  int *v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  unsigned __int8 *v20;
  uint64_t v21;
  size_t v22;
  int *v23;
  uint64_t v24;
  size_t v25;
  unint64_t *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  int v31;
  int v32;
  unint64_t i;
  ASN1_OBJECT *v34;
  unint64_t v35;
  void *v36;
  uint64_t v37;
  size_t v38;
  unint64_t *v39;
  uint64_t v40;
  size_t v41;
  const void ***v42;
  BOOL v43;
  const void ***v44;
  BOOL v45;
  int v46;
  const void ***v47;
  const void ***v48;
  const void ***v49;
  int v50;
  const void **v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t j;
  _QWORD *v58;
  _DWORD *v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  const void **v63;
  int crit;
  unsigned __int8 *out;

  v2 = (pthread_rwlock_t *)(a1 + 18);
  if (pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 18)))
    goto LABEL_145;
  v3 = *((_DWORD *)a1 + 12);
  if (pthread_rwlock_unlock(v2))
    goto LABEL_145;
  if ((v3 & 0x100) != 0)
    return ((*((_DWORD *)a1 + 12) >> 7) & 1) == 0;
  if (pthread_rwlock_wrlock(v2))
    goto LABEL_145;
  if ((*((_BYTE *)a1 + 49) & 1) != 0)
    goto LABEL_127;
  if (pthread_once(&EVP_sha256_once, (void (*)(void))EVP_sha256_init))
    goto LABEL_145;
  out = 0;
  v4 = i2d_X509((X509 *)a1, &out);
  if ((v4 & 0x80000000) != 0)
    goto LABEL_13;
  v5 = EVP_Digest(out, v4, (unsigned __int8 *)a1 + 104, 0, (const EVP_MD *)&EVP_sha256_storage, 0);
  if (out)
  {
    v7 = out - 8;
    v6 = *((_QWORD *)out - 1);
    if (v6 != -8)
      bzero(v7, v6 + 8);
    free(v7);
  }
  if (!v5)
LABEL_13:
    *((_DWORD *)a1 + 12) |= 0x80u;
  v8 = **a1;
  if (!v8)
  {
LABEL_17:
    *((_DWORD *)a1 + 12) |= 0x40u;
    goto LABEL_19;
  }
  out = 0;
  if (asn1_string_get_int64((int64_t *)&out, v8, 2))
  {
    if (out)
      goto LABEL_19;
    goto LABEL_17;
  }
  ERR_clear_error();
LABEL_19:
  crit = 0;
  d2i = (unsigned __int8 *)X509V3_get_d2i((STACK *)(*a1)[9], 87, &crit, 0);
  if (d2i)
  {
    v10 = d2i;
    v11 = *(_DWORD *)d2i;
    if (*(_DWORD *)d2i)
      *((_DWORD *)a1 + 12) |= 0x10u;
    v12 = *((_QWORD *)d2i + 1);
    if (v12)
    {
      if (!v11 || *(_DWORD *)(v12 + 4) == 258)
      {
        v13 = 0;
        *((_DWORD *)a1 + 12) |= 0x80u;
        goto LABEL_32;
      }
      out = 0;
      if (asn1_string_get_int64((int64_t *)&out, (const void **)v12, 2))
      {
        v13 = (uint64_t)out;
LABEL_32:
        a1[5] = (const void ***)v13;
        out = v10;
        ASN1_item_ex_free((ASN1_VALUE **)&out, &BASIC_CONSTRAINTS_it);
        v14 = 1;
        goto LABEL_33;
      }
      ERR_clear_error();
    }
    v13 = -1;
    goto LABEL_32;
  }
  if (crit == -1)
    goto LABEL_34;
  v14 = 128;
LABEL_33:
  *((_DWORD *)a1 + 12) |= v14;
LABEL_34:
  v15 = (int *)X509V3_get_d2i((STACK *)(*a1)[9], 83, &crit, 0);
  if (!v15)
  {
    if (crit != -1)
      *((_DWORD *)a1 + 12) |= 0x80u;
    goto LABEL_48;
  }
  v16 = v15;
  v17 = *v15;
  if (*v15 >= 1)
  {
    v18 = (unsigned __int8 *)*((_QWORD *)v15 + 1);
    v19 = *v18;
    *((_DWORD *)a1 + 13) = v19;
    if (v17 != 1)
      *((_DWORD *)a1 + 13) = v19 | (v18[1] << 8);
    *((_DWORD *)a1 + 12) |= 2u;
    goto LABEL_42;
  }
  *((_DWORD *)a1 + 13) = 0;
  v18 = (unsigned __int8 *)*((_QWORD *)v15 + 1);
  *((_DWORD *)a1 + 12) |= 2u;
  if (v18)
  {
LABEL_42:
    v21 = *((_QWORD *)v18 - 1);
    v20 = v18 - 8;
    v22 = v21 + 8;
    if (v21 != -8)
      bzero(v20, v22);
    free(v20);
  }
  v24 = *((_QWORD *)v16 - 1);
  v23 = v16 - 2;
  v25 = v24 + 8;
  if (v24 != -8)
    bzero(v23, v25);
  free(v23);
LABEL_48:
  *((_DWORD *)a1 + 14) = 0;
  v26 = (unint64_t *)X509V3_get_d2i((STACK *)(*a1)[9], 126, &crit, 0);
  if (!v26)
  {
    if (crit != -1)
      *((_DWORD *)a1 + 12) |= 0x80u;
    goto LABEL_81;
  }
  v27 = v26;
  *((_DWORD *)a1 + 12) |= 4u;
  v28 = *v26;
  if (!*v26)
    goto LABEL_72;
  v29 = 0;
  do
  {
    if (v28 > v29)
    {
      v31 = OBJ_obj2nid(*(const ASN1_OBJECT **)(v27[1] + 8 * v29));
      v32 = v31 - 129;
LABEL_56:
      v30 = 1;
      switch(v32)
      {
        case 0:
          goto LABEL_52;
        case 1:
          v30 = 2;
          goto LABEL_52;
        case 2:
          v30 = 8;
          goto LABEL_52;
        case 3:
          v30 = 4;
          goto LABEL_52;
        case 4:
          v30 = 64;
          goto LABEL_52;
        case 5:
        case 6:
        case 7:
        case 9:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
          goto LABEL_53;
        case 8:
        case 10:
          v30 = 16;
          goto LABEL_52;
        case 51:
          v30 = 32;
          goto LABEL_52;
        default:
          goto LABEL_59;
      }
      goto LABEL_53;
    }
    v31 = OBJ_obj2nid(0);
    v32 = v31 - 129;
    if ((v31 - 129) <= 0x33)
      goto LABEL_56;
LABEL_59:
    if (v31 == 297)
    {
      v30 = 128;
      goto LABEL_52;
    }
    if (v31 == 910)
    {
      v30 = 256;
LABEL_52:
      *((_DWORD *)a1 + 14) |= v30;
    }
LABEL_53:
    ++v29;
    v28 = *v27;
  }
  while (v29 < *v27);
  if (v28)
  {
    for (i = 0; i < v28; ++i)
    {
      v34 = *(ASN1_OBJECT **)(v27[1] + 8 * i);
      if (v34)
      {
        ASN1_OBJECT_free(v34);
        v28 = *v27;
      }
    }
  }
LABEL_72:
  v35 = v27[1];
  if (v35)
  {
    v37 = *(_QWORD *)(v35 - 8);
    v36 = (void *)(v35 - 8);
    v38 = v37 + 8;
    if (v37 != -8)
      bzero(v36, v38);
    free(v36);
  }
  v40 = *(v27 - 1);
  v39 = v27 - 1;
  v41 = v40 + 8;
  if (v40 != -8)
    bzero(v39, v41);
  free(v39);
LABEL_81:
  v42 = (const void ***)X509V3_get_d2i((STACK *)(*a1)[9], 82, &crit, 0);
  a1[8] = v42;
  if (v42)
    v43 = 1;
  else
    v43 = crit == -1;
  if (!v43)
    *((_DWORD *)a1 + 12) |= 0x80u;
  v44 = (const void ***)X509V3_get_d2i((STACK *)(*a1)[9], 90, &crit, 0);
  a1[9] = v44;
  if (v44)
    v45 = 1;
  else
    v45 = crit == -1;
  if (!v45)
    *((_DWORD *)a1 + 12) |= 0x80u;
  if (!X509_NAME_cmp((const X509_NAME *)(*a1)[5], (const X509_NAME *)(*a1)[3]))
  {
    *((_DWORD *)a1 + 12) |= 0x20u;
    if (!X509_check_akid(a1, (uint64_t)a1[9]))
    {
      v46 = *((_DWORD *)a1 + 12);
      if ((v46 & 2) == 0 || (*((_BYTE *)a1 + 52) & 4) != 0)
        *((_DWORD *)a1 + 12) = v46 | 0x2000;
    }
  }
  v47 = (const void ***)X509V3_get_d2i((STACK *)(*a1)[9], 85, &crit, 0);
  a1[11] = v47;
  if (!v47 && crit != -1)
    *((_DWORD *)a1 + 12) |= 0x80u;
  v48 = (const void ***)X509V3_get_d2i((STACK *)(*a1)[9], 666, &crit, 0);
  a1[12] = v48;
  if (!v48 && crit != -1)
    *((_DWORD *)a1 + 12) |= 0x80u;
  LODWORD(out) = 0;
  v49 = (const void ***)X509V3_get_d2i((STACK *)(*a1)[9], 103, (int *)&out, 0);
  a1[10] = v49;
  if (v49 || (_DWORD)out == -1)
  {
    for (j = 0; v49 && j < (unint64_t)*v49; ++j)
    {
      v58 = v49[1][j];
      v59 = (_DWORD *)*v58;
      if (*v58 && *v59 == 1)
      {
        v60 = (_QWORD *)v58[2];
        if (v60)
        {
          v61 = 0;
          while (*v60 != v61)
          {
            v62 = *(_QWORD *)(v60[1] + 8 * v61++);
            if (*(_DWORD *)v62 == 4)
            {
              v63 = *(const void ***)(v62 + 8);
              if (v63)
                goto LABEL_143;
              break;
            }
          }
        }
        v63 = (*a1)[3];
LABEL_143:
        if (!DIST_POINT_set_dpname((uint64_t)v59, v63))
          goto LABEL_104;
        v49 = a1[10];
      }
    }
  }
  else
  {
LABEL_104:
    *((_DWORD *)a1 + 12) |= 0x80u;
  }
  v50 = 0;
  while (2)
  {
    crit = v50;
    v52 = (*a1)[9];
    if (v52)
    {
      if (v50 >= *(_DWORD *)v52)
        break;
      goto LABEL_115;
    }
    if (v50 < 0)
    {
LABEL_115:
      if ((v50 & 0x80000000) == 0)
      {
        if (v52)
        {
          if ((unint64_t)*v52 > v50)
          {
            v53 = *((_QWORD *)v52[1] + v50);
            if (v53)
            {
              if (*(int *)(v53 + 8) >= 1)
              {
                v54 = OBJ_obj2nid(*(const ASN1_OBJECT **)v53);
                if (v54 <= 400)
                {
                  if ((v54 - 83) > 0x2B || ((1 << (v54 - 83)) & 0x80000000055) == 0)
                  {
LABEL_124:
                    v55 = *((_DWORD *)a1 + 12) | 0x200;
                    goto LABEL_126;
                  }
                }
                else if ((v54 - 747) >= 2 && v54 != 401 && v54 != 666)
                {
                  goto LABEL_124;
                }
              }
            }
          }
        }
      }
      v50 = crit + 1;
      continue;
    }
    break;
  }
  v55 = *((_DWORD *)a1 + 12);
LABEL_126:
  *((_DWORD *)a1 + 12) = v55 | 0x100;
LABEL_127:
  if (pthread_rwlock_unlock(v2))
LABEL_145:
    abort();
  return ((*((_DWORD *)a1 + 12) >> 7) & 1) == 0;
}

