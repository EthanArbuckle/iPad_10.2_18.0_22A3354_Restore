void webrtc::field_trial_list_impl::TypedFieldTrialListWrapper<BOOL>::~TypedFieldTrialListWrapper(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  void *v6;

  *(_QWORD *)a1 = &unk_24C0B1A10;
  v2 = (_QWORD *)(a1 + 96);
  v3 = *(_QWORD **)(a1 + 120);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  *(_QWORD *)(a1 + 8) = &unk_24C0B1A40;
  v5 = *(void **)(a1 + 72);
  if (v5)
    operator delete(v5);
  *(_QWORD *)(a1 + 8) = off_24C0B4170;
  if (*(char *)(a1 + 63) < 0)
  {
    operator delete(*(void **)(a1 + 40));
    v6 = *(void **)(a1 + 16);
    if (!v6)
      goto LABEL_13;
  }
  else
  {
    v6 = *(void **)(a1 + 16);
    if (!v6)
      goto LABEL_13;
  }
  *(_QWORD *)(a1 + 24) = v6;
  operator delete(v6);
LABEL_13:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::field_trial_list_impl::TypedFieldTrialListWrapper<BOOL>::WriteElement(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;
  char v7;
  uint64_t v8;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + (((unint64_t)a3 >> 3) & 0x1FFFFFFFFFFFFFF8));
  v8 = a2;
  v7 = (v3 >> a3) & 1;
  v4 = *(_QWORD *)(a1 + 120);
  if (v4)
    return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(_QWORD *)v4 + 48))(v4, &v8, &v7);
  v6 = std::__throw_bad_function_call[abi:sn180100]();
  return webrtc::field_trial_list_impl::TypedFieldTrialListWrapper<BOOL>::GetList(v6);
}

uint64_t webrtc::field_trial_list_impl::TypedFieldTrialListWrapper<BOOL>::GetList(uint64_t a1)
{
  return a1 + 8;
}

uint64_t webrtc::FieldTrialList<BOOL>::~FieldTrialList(uint64_t a1)
{
  void *v2;
  void *v3;

  *(_QWORD *)a1 = &unk_24C0B1A40;
  v2 = *(void **)(a1 + 64);
  if (v2)
    operator delete(v2);
  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v3 = *(void **)(a1 + 8);
    if (!v3)
      return a1;
    goto LABEL_5;
  }
  v3 = *(void **)(a1 + 8);
  if (v3)
  {
LABEL_5:
    *(_QWORD *)(a1 + 16) = v3;
    operator delete(v3);
  }
  return a1;
}

void webrtc::FieldTrialList<BOOL>::~FieldTrialList(uint64_t a1)
{
  void *v2;
  void *v3;

  *(_QWORD *)a1 = &unk_24C0B1A40;
  v2 = *(void **)(a1 + 64);
  if (v2)
    operator delete(v2);
  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v3 = *(void **)(a1 + 8);
    if (!v3)
      goto LABEL_8;
  }
  else
  {
    v3 = *(void **)(a1 + 8);
    if (!v3)
      goto LABEL_8;
  }
  *(_QWORD *)(a1 + 16) = v3;
  operator delete(v3);
LABEL_8:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialList<BOOL>::Parse(uint64_t a1, size_t __sz)
{
  unint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  int v10;
  char v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  __int128 v22;
  void *__p;
  _QWORD *v25;
  _QWORD *v26;
  __int128 v27;

  *(_BYTE *)(a1 + 58) = 1;
  if (!*(_BYTE *)(__sz + 24))
  {
    *(_QWORD *)(a1 + 72) = 0;
    return 1;
  }
  v26 = 0;
  v27 = 0uLL;
  if (*(char *)(__sz + 23) < 0)
  {
    v3 = *(_QWORD *)(__sz + 8);
    if ((v3 & 0x8000000000000000) != 0 || (__sz = *(_QWORD *)__sz, v3) && !__sz)
    {
      __break(1u);
LABEL_47:
      abort();
    }
  }
  else
  {
    v3 = *(unsigned __int8 *)(__sz + 23);
  }
  rtc::split(__sz, v3, 0x7Cu, (char **)&__p);
  v5 = __p;
  v6 = v25;
  if (__p != v25)
  {
    v7 = 0;
    while (1)
    {
      v8 = (unsigned __int8 *)*v5;
      v9 = v5[1];
      if (v9 == 1)
      {
        v10 = *v8;
        if (v10 != 48)
        {
          if (v10 != 49)
            goto LABEL_42;
          goto LABEL_18;
        }
      }
      else
      {
        if (v9 != 5)
        {
          if (v9 != 4 || *(_DWORD *)v8 != *(_DWORD *)"true")
            goto LABEL_42;
LABEL_18:
          v11 = 0;
          v13 = *((_QWORD *)&v27 + 1);
          v12 = v27;
          if ((_QWORD)v27 == *((_QWORD *)&v27 + 1) << 6)
            goto LABEL_26;
          goto LABEL_33;
        }
        v14 = *(_DWORD *)v8;
        v15 = v8[4];
        if (v14 != *(_DWORD *)"false" || v15 != str_14[4])
        {
LABEL_42:
          *(_BYTE *)(a1 + 57) = 1;
          if (__p)
          {
            v25 = __p;
            operator delete(__p);
            v7 = v26;
          }
          v4 = 0;
          if (v7)
            goto LABEL_40;
          return v4;
        }
      }
      v11 = 1;
      v13 = *((_QWORD *)&v27 + 1);
      v12 = v27;
      if ((_QWORD)v27 == *((_QWORD *)&v27 + 1) << 6)
      {
LABEL_26:
        if ((uint64_t)(v12 + 1) < 0)
          goto LABEL_47;
        v17 = v13 << 7;
        if (v17 <= (v12 & 0xFFFFFFFFFFFFFFC0) + 64)
          v17 = (v12 & 0xFFFFFFFFFFFFFFC0) + 64;
        if (v12 <= 0x3FFFFFFFFFFFFFFELL)
          v18 = v17;
        else
          v18 = 0x7FFFFFFFFFFFFFFFLL;
        std::vector<BOOL>::reserve((uint64_t)&v26, v18);
        v7 = v26;
        v12 = v27;
      }
LABEL_33:
      *(_QWORD *)&v27 = v12 + 1;
      v19 = v12 >> 6;
      v20 = 1 << v12;
      if ((v11 & 1) != 0)
      {
        v7[v19] &= ~v20;
        v5 += 2;
        if (v5 == v6)
          goto LABEL_35;
      }
      else
      {
        v7[v19] |= v20;
        v5 += 2;
        if (v5 == v6)
        {
LABEL_35:
          v5 = __p;
          if (__p)
            goto LABEL_38;
          goto LABEL_39;
        }
      }
    }
  }
  v7 = 0;
  if (__p)
  {
LABEL_38:
    v25 = v5;
    operator delete(v5);
    v7 = v26;
  }
LABEL_39:
  v21 = *(_QWORD **)(a1 + 64);
  *(_QWORD *)(a1 + 64) = v7;
  v26 = v21;
  v22 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)(a1 + 72) = v27;
  v27 = v22;
  v4 = 1;
  v7 = v21;
  if (v21)
LABEL_40:
    operator delete(v7);
  return v4;
}

uint64_t webrtc::FieldTrialList<BOOL>::Size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void std::vector<BOOL>::reserve(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t *v4;
  _QWORD *v5;
  unint64_t v6;
  int v7;
  unint64_t v8;
  int v9;
  int v10;
  _QWORD *v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;

  if (a2 > *(_QWORD *)(a1 + 16) << 6)
  {
    if ((a2 & 0x8000000000000000) != 0)
      abort();
    v3 = ((a2 - 1) >> 6) + 1;
    v4 = (uint64_t *)operator new(8 * v3);
    v5 = *(_QWORD **)a1;
    v6 = *(_QWORD *)(a1 + 8);
    v7 = v6 & 0x3F;
    v8 = (v6 - 1) >> 6;
    if (v6 < 0x41)
      v8 = 0;
    v4[v8] = 0;
    if (v6 > 0x3F || (v6 & 0x3F) != 0)
    {
      v9 = 0;
      v10 = 0;
      v11 = &v5[v6 >> 6];
      v12 = v4;
      v13 = v5;
      do
      {
        v14 = 1 << v9;
        if (((*v13 >> v10) & 1) != 0)
          v15 = *v12 | v14;
        else
          v15 = *v12 & ~v14;
        *v12 = v15;
        v13 += v10 == 63;
        if (v10 == 63)
          v10 = 0;
        else
          ++v10;
        v12 += v9 == 63;
        if (v9 == 63)
          v9 = 0;
        else
          ++v9;
      }
      while (v10 != v7 || v13 != v11);
    }
    *(_QWORD *)a1 = v4;
    *(_QWORD *)(a1 + 16) = v3;
    if (v5)
      operator delete(v5);
  }
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6)::{lambda(void *,int)#1}>,void ()(void *,int)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_BYTE *std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_24C0B1A78;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24C0B1A78;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_6)::{lambda(void *,int)#1}>,void ()(void *,int)>::operator()(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(_DWORD *)(*(_QWORD *)a2 + 44) = *a3;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7)::{lambda(void *,int)#1}>,void ()(void *,int)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_BYTE *std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_24C0B1AC0;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24C0B1AC0;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_7)::{lambda(void *,int)#1}>,void ()(void *,int)>::operator()(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(_DWORD *)(*(_QWORD *)a2 + 48) = *a3;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8)::{lambda(void *,webrtc::TimeDelta)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8)::{lambda(void *,webrtc::TimeDelta)#1}>,void ()(void *,webrtc::TimeDelta)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_BYTE *std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8)::{lambda(void *,webrtc::TimeDelta)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8)::{lambda(void *,webrtc::TimeDelta)#1}>,void ()(void *,webrtc::TimeDelta)>::__clone(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_24C0B1B08;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8)::{lambda(void *,webrtc::TimeDelta)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8)::{lambda(void *,webrtc::TimeDelta)#1}>,void ()(void *,webrtc::TimeDelta)>::__clone(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24C0B1B08;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8)::{lambda(void *,webrtc::TimeDelta)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8>>(std::string_view,webrtc::`anonymous namespace'::GetNetworkConfigs(webrtc::FieldTrialsView const&,BOOL)::$_8)::{lambda(void *,webrtc::TimeDelta)#1}>,void ()(void *,webrtc::TimeDelta)>::operator()(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *(_QWORD *)(*(_QWORD *)a2 + 56) = *a3;
}

uint64_t webrtc::field_trial_list_impl::TypedFieldTrialListWrapper<webrtc::TimeDelta>::~TypedFieldTrialListWrapper(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  void *v6;

  *(_QWORD *)a1 = off_24C0B1B50;
  v2 = (_QWORD *)(a1 + 96);
  v3 = *(_QWORD **)(a1 + 120);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  *(_QWORD *)(a1 + 8) = off_24C0B1B80;
  v5 = *(void **)(a1 + 72);
  if (v5)
  {
    *(_QWORD *)(a1 + 80) = v5;
    operator delete(v5);
  }
  *(_QWORD *)(a1 + 8) = off_24C0B4170;
  if (*(char *)(a1 + 63) < 0)
  {
    operator delete(*(void **)(a1 + 40));
    v6 = *(void **)(a1 + 16);
    if (!v6)
      return a1;
    goto LABEL_10;
  }
  v6 = *(void **)(a1 + 16);
  if (v6)
  {
LABEL_10:
    *(_QWORD *)(a1 + 24) = v6;
    operator delete(v6);
  }
  return a1;
}

void webrtc::field_trial_list_impl::TypedFieldTrialListWrapper<webrtc::TimeDelta>::~TypedFieldTrialListWrapper(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  void *v6;

  *(_QWORD *)a1 = off_24C0B1B50;
  v2 = (_QWORD *)(a1 + 96);
  v3 = *(_QWORD **)(a1 + 120);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  *(_QWORD *)(a1 + 8) = off_24C0B1B80;
  v5 = *(void **)(a1 + 72);
  if (v5)
  {
    *(_QWORD *)(a1 + 80) = v5;
    operator delete(v5);
  }
  *(_QWORD *)(a1 + 8) = off_24C0B4170;
  if (*(char *)(a1 + 63) < 0)
  {
    operator delete(*(void **)(a1 + 40));
    v6 = *(void **)(a1 + 16);
    if (!v6)
      goto LABEL_13;
  }
  else
  {
    v6 = *(void **)(a1 + 16);
    if (!v6)
      goto LABEL_13;
  }
  *(_QWORD *)(a1 + 24) = v6;
  operator delete(v6);
LABEL_13:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::field_trial_list_impl::TypedFieldTrialListWrapper<webrtc::TimeDelta>::WriteElement(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = a1[9];
  if (a3 >= (unint64_t)((a1[10] - v3) >> 3))
  {
    __break(1u);
  }
  else
  {
    v4 = *(_QWORD *)(v3 + 8 * a3);
    v8 = a2;
    v9 = v4;
    v5 = a1[15];
    if (v5)
      return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v5 + 48))(v5, &v8, &v9);
  }
  v7 = std::__throw_bad_function_call[abi:sn180100]();
  return webrtc::field_trial_list_impl::TypedFieldTrialListWrapper<webrtc::TimeDelta>::GetList(v7);
}

uint64_t webrtc::field_trial_list_impl::TypedFieldTrialListWrapper<webrtc::TimeDelta>::GetList(uint64_t a1)
{
  return a1 + 8;
}

uint64_t webrtc::FieldTrialList<webrtc::TimeDelta>::~FieldTrialList(uint64_t a1)
{
  void *v2;
  void *v3;

  *(_QWORD *)a1 = off_24C0B1B80;
  v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(_QWORD *)(a1 + 72) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v3 = *(void **)(a1 + 8);
    if (!v3)
      return a1;
    goto LABEL_5;
  }
  v3 = *(void **)(a1 + 8);
  if (v3)
  {
LABEL_5:
    *(_QWORD *)(a1 + 16) = v3;
    operator delete(v3);
  }
  return a1;
}

void webrtc::FieldTrialList<webrtc::TimeDelta>::~FieldTrialList(uint64_t a1)
{
  void *v2;
  void *v3;

  *(_QWORD *)a1 = off_24C0B1B80;
  v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(_QWORD *)(a1 + 72) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v3 = *(void **)(a1 + 8);
    if (!v3)
      goto LABEL_8;
  }
  else
  {
    v3 = *(void **)(a1 + 8);
    if (!v3)
      goto LABEL_8;
  }
  *(_QWORD *)(a1 + 16) = v3;
  operator delete(v3);
LABEL_8:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialList<webrtc::TimeDelta>::Parse(uint64_t a1, size_t __sz)
{
  unint64_t v3;
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  char *v17;
  char *v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD *v25;
  char *v26;
  uint64_t v27;
  __int128 v28;
  char *v29;
  void *__p;
  char *v32;

  *(_BYTE *)(a1 + 58) = 1;
  if (!*(_BYTE *)(__sz + 24))
  {
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a1 + 64);
    return 1;
  }
  if (*(char *)(__sz + 23) < 0)
  {
    v3 = *(_QWORD *)(__sz + 8);
    if ((v3 & 0x8000000000000000) != 0 || (__sz = *(_QWORD *)__sz, v3) && !__sz)
    {
LABEL_47:
      __break(1u);
LABEL_48:
      abort();
    }
  }
  else
  {
    v3 = *(unsigned __int8 *)(__sz + 23);
  }
  rtc::split(__sz, v3, 0x7Cu, (char **)&__p);
  v5 = (char *)__p;
  v6 = v32;
  if (__p != v32)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    while (1)
    {
      while (1)
      {
        webrtc::ParseTypedParameter<webrtc::TimeDelta>(*(void ***)v5, *((_QWORD *)v5 + 1));
        if (!v11)
        {
          *(_BYTE *)(a1 + 57) = 1;
          if (__p)
          {
            v32 = (char *)__p;
            operator delete(__p);
          }
          v4 = 0;
          if (v7)
            goto LABEL_39;
          return v4;
        }
        v12 = v10;
        if (v8 >= v9)
          break;
        if (!v8)
          goto LABEL_47;
        *(_QWORD *)v8 = v10;
        v8 += 8;
        v5 += 16;
        if (v5 == v6)
        {
LABEL_45:
          v5 = (char *)__p;
          if (__p)
            goto LABEL_37;
          goto LABEL_38;
        }
      }
      v13 = (v8 - v7) >> 3;
      v14 = v13 + 1;
      if ((unint64_t)(v13 + 1) >> 61)
        goto LABEL_48;
      if ((v9 - v7) >> 2 > v14)
        v14 = (v9 - v7) >> 2;
      if ((unint64_t)(v9 - v7) >= 0x7FFFFFFFFFFFFFF8)
        v14 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v14)
        goto LABEL_47;
      if (v14 >> 61)
        std::__throw_bad_array_new_length[abi:sn180100]();
      v15 = 8 * v14;
      v16 = operator new(8 * v14);
      v17 = &v16[8 * v13];
      *(_QWORD *)v17 = v12;
      v18 = v17;
      if (v8 != v7)
      {
        v19 = v8 - v7 - 8;
        if (v19 < 0x168
          || (v22 = (v8 - 8 - v7) & 0xFFFFFFFFFFFFFFF8, &v16[v8 - v7 - 8 - v22] > &v16[v8 - v7 - 8])
          || &v8[-v22 - 8] > v8 - 8
          || (unint64_t)(v7 - v16) < 0x20)
        {
          v20 = v8;
          v18 = &v16[8 * v13];
        }
        else
        {
          v23 = (v19 >> 3) + 1;
          v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
          v20 = &v8[-v24];
          v18 = &v17[-v24];
          v25 = &v16[8 * v13 - 16];
          v26 = v8 - 16;
          v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v28 = *(_OWORD *)v26;
            *(v25 - 1) = *((_OWORD *)v26 - 1);
            *v25 = v28;
            v25 -= 2;
            v26 -= 32;
            v27 -= 4;
          }
          while (v27);
          if (v23 == (v23 & 0x3FFFFFFFFFFFFFFCLL))
            goto LABEL_27;
        }
        do
        {
          v21 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *((_QWORD *)v18 - 1) = v21;
          v18 -= 8;
        }
        while (v20 != v7);
      }
LABEL_27:
      v9 = &v16[v15];
      if (v7)
        operator delete(v7);
      v7 = v18;
      v8 = v17 + 8;
      v5 += 16;
      if (v5 == v6)
        goto LABEL_45;
    }
  }
  v9 = 0;
  v8 = 0;
  v7 = 0;
  if (__p)
  {
LABEL_37:
    v32 = v5;
    operator delete(v5);
  }
LABEL_38:
  v29 = *(char **)(a1 + 64);
  *(_QWORD *)(a1 + 64) = v7;
  *(_QWORD *)(a1 + 72) = v8;
  *(_QWORD *)(a1 + 80) = v9;
  v4 = 1;
  v7 = v29;
  if (v29)
LABEL_39:
    operator delete(v7);
  return v4;
}

uint64_t webrtc::FieldTrialList<webrtc::TimeDelta>::Size(uint64_t a1)
{
  return (*(_QWORD *)(a1 + 72) - *(_QWORD *)(a1 + 64)) >> 3;
}

void webrtc::FieldTrialStructList<webrtc::DegradedCall::TimeScopedNetworkConfig>::~FieldTrialStructList(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  *(_QWORD *)a1 = off_24C0B1BB8;
  v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(_QWORD *)(a1 + 96) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_24C0B3F90;
  v3 = *(_QWORD **)(a1 + 64);
  if (v3)
  {
    v4 = *(_QWORD **)(a1 + 72);
    v5 = *(void **)(a1 + 64);
    if (v4 != v3)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v3);
      v5 = *(void **)(a1 + 64);
    }
    *(_QWORD *)(a1 + 72) = v3;
    operator delete(v5);
  }
  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v8 = *(void **)(a1 + 8);
    if (!v8)
      goto LABEL_16;
  }
  else
  {
    v8 = *(void **)(a1 + 8);
    if (!v8)
      goto LABEL_16;
  }
  *(_QWORD *)(a1 + 16) = v8;
  operator delete(v8);
LABEL_16:
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::FieldTrialStructList<webrtc::DegradedCall::TimeScopedNetworkConfig>::ParseDone(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  char *v8;
  char *v9;
  __n128 v10;
  char *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  void *v20;

  v1 = (_QWORD *)a1[8];
  v2 = (_QWORD *)a1[9];
  if (v1 != v2)
  {
    v4 = -1;
    do
    {
      if (*(_BYTE *)((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 24))(*v1) + 57))
        return;
      if (*(_BYTE *)((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 24))(*v1) + 58))
      {
        v5 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 24))(*v1);
        v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
        if (v4 == -1)
        {
          v4 = v6;
        }
        else if (v4 != v6)
        {
          return;
        }
      }
      ++v1;
    }
    while (v1 != v2);
    if (v4 != -1)
    {
      if (v4)
      {
        if (v4 < 0)
          goto LABEL_30;
        v7 = v4;
        v8 = (char *)operator new((uint64_t)v4 << 6);
        v9 = &v8[64 * (uint64_t)v4];
        v10.n128_u64[0] = 0xFFFFFFFFLL;
        v11 = v8;
        do
        {
          *(_QWORD *)v11 = 0;
          *((_QWORD *)v11 + 1) = 0;
          *((_QWORD *)v11 + 2) = 0;
          *((_QWORD *)v11 + 3) = 0x7FFFFFFFFFFFFFFFLL;
          *((_QWORD *)v11 + 4) = 0;
          *((_DWORD *)v11 + 10) = 0;
          *(_QWORD *)(v11 + 44) = 0xFFFFFFFFLL;
          *((_DWORD *)v11 + 13) = 0;
          *((_QWORD *)v11 + 7) = 0x7FFFFFFFFFFFFFFFLL;
          v11 += 64;
        }
        while (v11 != v9);
        v12 = (_QWORD *)a1[8];
        v13 = (_QWORD *)a1[9];
        if (v12 != v13)
        {
          v14 = v4;
          while (!*(_BYTE *)((*(uint64_t (**)(_QWORD, __n128))(*(_QWORD *)*v12 + 24))(*v12, v10) + 58))
          {
LABEL_17:
            if (++v12 == v13)
              goto LABEL_26;
          }
          v15 = 0;
          v16 = v8;
          while (v7 != v15)
          {
            (*(void (**)(_QWORD, char *, uint64_t))(*(_QWORD *)*v12 + 16))(*v12, v16, v15++);
            v16 += 64;
            if (v14 == v15)
              goto LABEL_17;
          }
          __break(1u);
LABEL_30:
          abort();
        }
      }
      else
      {
        v17 = (uint64_t *)a1[8];
        v18 = (uint64_t *)a1[9];
        while (v17 != v18)
        {
          v19 = *v17++;
          (*(void (**)(uint64_t))(*(_QWORD *)v19 + 24))(v19);
        }
        v8 = 0;
        v9 = 0;
      }
LABEL_26:
      v20 = (void *)a1[11];
      a1[11] = v8;
      a1[12] = v9;
      a1[13] = v9;
      if (v20)
        operator delete(v20);
    }
  }
}

void webrtc::CreatePeerConnectionFactory(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X5>, uint64_t *a7@<X6>, uint64_t *a8@<X7>, uint64_t *a9@<X8>, uint64_t *a10, uint64_t *a11, uint64_t *a12, uint64_t *a13, _QWORD **a14)
{
  _OWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v38;
  void (***v39)(_QWORD);
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  _BYTE v56[216];
  int v57;
  __int16 v58;
  int v59;
  char v60;
  int v61;
  char v62;
  uint64_t v63;
  char v64;
  int v65;
  int v66;
  __int16 v67;
  char v68;
  int v69;
  char v70;
  char v71;
  char v72;
  uint64_t v73;
  int v74;
  char v75;
  char v76;
  uint64_t v77;
  char v78;
  uint64_t v79;
  int v80;
  char v81;
  __int128 v82;
  uint64_t v83;
  char v84;
  __int16 v85;
  char v86;
  __int128 v87;
  int v88;
  _DWORD v89[11];
  _QWORD v90[3];
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;

  if (!*a13)
  {
    v19 = (_OWORD *)operator new();
    *v19 = 0u;
    v19[1] = 0u;
    *(_QWORD *)v19 = &unk_24C0B3F60;
    v20 = *a13;
    *a13 = (uint64_t)v19;
    if (v20)
      (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
  }
  v102 = 0u;
  v101 = 0u;
  v100 = 0u;
  v99 = 0u;
  v98 = 0u;
  v97 = 0u;
  v96 = 0u;
  v95 = 0u;
  v94 = 0u;
  v93 = 0u;
  v92 = 0u;
  v91 = 0u;
  v90[0] = a1;
  v90[1] = a2;
  v90[2] = a3;
  v21 = *a14;
  if (*a14)
  {
    *a14 = 0;
  }
  else
  {
    v21 = (_QWORD *)operator new();
    *v21 = &off_24C0C2148;
  }
  *(_QWORD *)&v92 = v21;
  v22 = (_QWORD *)operator new();
  *v22 = &unk_24C0BBEB0;
  v23 = *a13;
  *a13 = 0;
  *((_QWORD *)&v92 + 1) = v22;
  *((_QWORD *)&v96 + 1) = v23;
  if (a1)
    *(_QWORD *)&v91 = *(_QWORD *)(a1 + 168);
  v24 = *a4;
  *a4 = 0;
  v25 = *a5;
  *a5 = 0;
  *((_QWORD *)&v98 + 1) = v24;
  *(_QWORD *)&v99 = v25;
  v26 = *a6;
  *a6 = 0;
  v27 = *a12;
  *a12 = 0;
  *((_QWORD *)&v99 + 1) = v26;
  *(_QWORD *)&v101 = v27;
  v28 = *a11;
  if (*a11)
  {
    *a11 = 0;
    v29 = *a10;
    *a10 = 0;
    *((_QWORD *)&v100 + 1) = v28;
    *(_QWORD *)&v100 = v29;
    v31 = a8;
    v30 = a9;
    v32 = a7;
  }
  else
  {
    v57 = 48000;
    v58 = 0;
    v59 = 0;
    v60 = 0;
    v61 = 1065353216;
    v62 = 0;
    __asm { FMOV            V0.2S, #1.0 }
    v63 = _D0;
    v64 = 0;
    v65 = 255;
    v66 = 256;
    v67 = 256;
    v68 = 0;
    v69 = 1;
    v70 = 0;
    v71 = 0;
    v72 = 0;
    v73 = 0x300000000;
    v74 = 9;
    v75 = 1;
    v76 = 1;
    v77 = 0x4600000000;
    v78 = 1;
    v79 = 0x3DCCCCCD0000000FLL;
    v80 = 300;
    v81 = 0;
    v82 = xmmword_208F050E0;
    v83 = 0x40400000BF800000;
    v84 = 1;
    v85 = 0;
    v87 = xmmword_208F050F0;
    v88 = -1035468800;
    memset(v89, 0, sizeof(v89));
    v86 = 0;
    v38 = operator new();
    v39 = (void (***)(_QWORD))rtc::RefCountedObject<webrtc::AudioProcessingImpl>::RefCountedObject<webrtc::AudioProcessing::Config &,std::unique_ptr<webrtc::CustomProcessing>,std::unique_ptr<webrtc::CustomProcessing>,std::unique_ptr<webrtc::EchoControlFactory>,webrtc::scoped_refptr<webrtc::EchoDetector>,std::unique_ptr<webrtc::CustomAudioAnalyzer>>(v38, (uint64_t)&v57, (uint64_t *)&v89[3], (uint64_t *)&v89[5], (uint64_t *)&v89[1], (uint64_t *)&v89[7], (uint64_t *)&v89[9]);
    (**v39)(v39);
    v40 = *((_QWORD *)&v100 + 1);
    *((_QWORD *)&v100 + 1) = v38;
    if (v40)
      (*(void (**)(uint64_t))(*(_QWORD *)v40 + 8))(v40);
    v41 = *(_QWORD *)&v89[9];
    *(_QWORD *)&v89[9] = 0;
    v31 = a8;
    v30 = a9;
    if (v41)
      (*(void (**)(uint64_t))(*(_QWORD *)v41 + 32))(v41);
    if (*(_QWORD *)&v89[7])
      (*(void (**)(_QWORD))(**(_QWORD **)&v89[7] + 8))(*(_QWORD *)&v89[7]);
    v42 = *(_QWORD *)&v89[5];
    *(_QWORD *)&v89[5] = 0;
    v32 = a7;
    if (v42)
      (*(void (**)(uint64_t))(*(_QWORD *)v42 + 40))(v42);
    v43 = *(_QWORD *)&v89[3];
    *(_QWORD *)&v89[3] = 0;
    if (v43)
      (*(void (**)(uint64_t))(*(_QWORD *)v43 + 40))(v43);
    v44 = *(_QWORD *)&v89[1];
    *(_QWORD *)&v89[1] = 0;
    if (v44)
      (*(void (**)(uint64_t))(*(_QWORD *)v44 + 16))(v44);
    v45 = v100;
    v46 = *a10;
    *a10 = 0;
    *(_QWORD *)&v100 = v46;
    if (v45)
      (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
  }
  v47 = *v32;
  *v32 = 0;
  v48 = *((_QWORD *)&v101 + 1);
  *((_QWORD *)&v101 + 1) = v47;
  if (v48)
    (*(void (**)(uint64_t))(*(_QWORD *)v48 + 48))(v48);
  v49 = *v31;
  *v31 = 0;
  v50 = v102;
  *(_QWORD *)&v102 = v49;
  if (v50)
    (*(void (**)(uint64_t))(*(_QWORD *)v50 + 8))(v50);
  if (!*((_QWORD *)&v102 + 1))
  {
    v51 = (_QWORD *)operator new();
    *v51 = &off_24C0B3888;
    *((_QWORD *)&v102 + 1) = v51;
  }
  webrtc::PeerConnectionFactoryDependencies::PeerConnectionFactoryDependencies((uint64_t)v56, (uint64_t)v90);
  webrtc::CreateModularPeerConnectionFactory((uint64_t)v56, v30);
  webrtc::PeerConnectionFactoryDependencies::~PeerConnectionFactoryDependencies((webrtc::PeerConnectionFactoryDependencies *)v56);
  webrtc::PeerConnectionFactoryDependencies::~PeerConnectionFactoryDependencies((webrtc::PeerConnectionFactoryDependencies *)v90);
}

uint64_t webrtc::CreateScalabilityStructure@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  if (result < 0x22)
    return (*((uint64_t (**)(void))*(&off_24C0B2458 + (char)result) + 1))();
  *a2 = 0;
  return result;
}

_QWORD *webrtc::`anonymous namespace'::Create<webrtc::ScalableVideoControllerNoLayering>@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  *result = &unk_24C0BFBC0;
  result[1] = 0;
  *((_WORD *)result + 4) = 257;
  *a1 = result;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL1T2>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x200000001;
  *(_QWORD *)(v2 + 8) = 0x200000001;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 3;
  *(_QWORD *)v2 = &unk_24C0BF5D8;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL1T3>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x300000001;
  *(_QWORD *)(v2 + 8) = 0x300000001;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 7;
  *(_QWORD *)v2 = &unk_24C0BF620;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL2T1>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x100000002;
  *(_QWORD *)(v2 + 8) = 0x100000002;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 3;
  *(_QWORD *)v2 = &unk_24C0BF668;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureL2T1>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x100000002;
  *(_QWORD *)(v2 + 8) = 0x100000002;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 3;
  *(_QWORD *)v2 = &unk_24C0BF668;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL2T1Key>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x100000002;
  *(_QWORD *)(v2 + 8) = 0x100000002;
  *(_DWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 3;
  *(_QWORD *)v2 = &unk_24C0BF818;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL2T2>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x200000002;
  *(_QWORD *)(v2 + 8) = 0x200000002;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 15;
  *(_QWORD *)v2 = &unk_24C0BF6B0;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureL2T2>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x200000002;
  *(_QWORD *)(v2 + 8) = 0x200000002;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 15;
  *(_QWORD *)v2 = &unk_24C0BF6B0;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL2T2Key>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x200000002;
  *(_QWORD *)(v2 + 8) = 0x200000002;
  *(_DWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 15;
  *(_QWORD *)v2 = &unk_24C0BF860;
  *a1 = v2;
  return result;
}

_QWORD *webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL2T2KeyShift>@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  *result = &unk_24C0BF9C8;
  result[1] = 0;
  result[2] = 15;
  *a1 = result;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL2T3>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x300000002;
  *(_QWORD *)(v2 + 8) = 0x300000002;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 63;
  *(_QWORD *)v2 = &unk_24C0BF6F8;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureL2T3>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x300000002;
  *(_QWORD *)(v2 + 8) = 0x300000002;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 63;
  *(_QWORD *)v2 = &unk_24C0BF6F8;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL2T3Key>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x300000002;
  *(_QWORD *)(v2 + 8) = 0x300000002;
  *(_DWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 63;
  *(_QWORD *)v2 = &unk_24C0BF8A8;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL3T1>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x100000003;
  *(_QWORD *)(v2 + 8) = 0x100000003;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 7;
  *(_QWORD *)v2 = &unk_24C0BF740;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureL3T1>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x100000003;
  *(_QWORD *)(v2 + 8) = 0x100000003;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 7;
  *(_QWORD *)v2 = &unk_24C0BF740;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL3T1Key>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x100000003;
  *(_QWORD *)(v2 + 8) = 0x100000003;
  *(_DWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 7;
  *(_QWORD *)v2 = &unk_24C0BF8F0;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL3T2>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x200000003;
  *(_QWORD *)(v2 + 8) = 0x200000003;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 63;
  *(_QWORD *)v2 = &unk_24C0BF788;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureL3T2>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x200000003;
  *(_QWORD *)(v2 + 8) = 0x200000003;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 63;
  *(_QWORD *)v2 = &unk_24C0BF788;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL3T2Key>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x200000003;
  *(_QWORD *)(v2 + 8) = 0x200000003;
  *(_DWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 63;
  *(_QWORD *)v2 = &unk_24C0BF938;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL3T3>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x300000003;
  *(_QWORD *)(v2 + 8) = 0x300000003;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 511;
  *(_QWORD *)v2 = &unk_24C0BF7D0;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureL3T3>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x300000003;
  *(_QWORD *)(v2 + 8) = 0x300000003;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 511;
  *(_QWORD *)v2 = &unk_24C0BF7D0;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureL3T3Key>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x300000003;
  *(_QWORD *)(v2 + 8) = 0x300000003;
  *(_DWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 511;
  *(_QWORD *)v2 = &unk_24C0BF980;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureS2T1>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x100000002;
  *(_QWORD *)(v2 + 8) = 0x100000002;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 3;
  *(_QWORD *)v2 = &unk_24C0BFA10;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureS2T1>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x100000002;
  *(_QWORD *)(v2 + 8) = 0x100000002;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 3;
  *(_QWORD *)v2 = &unk_24C0BFA10;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureS2T2>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x200000002;
  *(_QWORD *)(v2 + 8) = 0x200000002;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 15;
  *(_QWORD *)v2 = &unk_24C0BFA58;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureS2T2>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x200000002;
  *(_QWORD *)(v2 + 8) = 0x200000002;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 15;
  *(_QWORD *)v2 = &unk_24C0BFA58;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureS2T3>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x300000002;
  *(_QWORD *)(v2 + 8) = 0x300000002;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 63;
  *(_QWORD *)v2 = &unk_24C0BFAA0;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureS2T3>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x300000002;
  *(_QWORD *)(v2 + 8) = 0x300000002;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 63;
  *(_QWORD *)v2 = &unk_24C0BFAA0;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureS3T1>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x100000003;
  *(_QWORD *)(v2 + 8) = 0x100000003;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 7;
  *(_QWORD *)v2 = &unk_24C0BFAE8;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureS3T1>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x100000003;
  *(_QWORD *)(v2 + 8) = 0x100000003;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 7;
  *(_QWORD *)v2 = &unk_24C0BFAE8;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureS3T2>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x200000003;
  *(_QWORD *)(v2 + 8) = 0x200000003;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 63;
  *(_QWORD *)v2 = &unk_24C0BFB30;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureS3T2>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x200000003;
  *(_QWORD *)(v2 + 8) = 0x200000003;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 63;
  *(_QWORD *)v2 = &unk_24C0BFB30;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::Create<webrtc::ScalabilityStructureS3T3>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x300000003;
  *(_QWORD *)(v2 + 8) = 0x300000003;
  *(_QWORD *)(v2 + 16) = 0x200000001;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 511;
  *(_QWORD *)v2 = &unk_24C0BFB78;
  *a1 = v2;
  return result;
}

double webrtc::`anonymous namespace'::CreateH<webrtc::ScalabilityStructureS3T3>@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v2;
  double result;

  v2 = operator new();
  *(_QWORD *)&result = 0x300000003;
  *(_QWORD *)(v2 + 8) = 0x300000003;
  *(_QWORD *)(v2 + 16) = 0x300000002;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 511;
  *(_QWORD *)v2 = &unk_24C0BFB78;
  *a1 = v2;
  return result;
}

_QWORD *webrtc::CreateVideoRtpDepacketizer@<X0>(rtc::webrtc_checks_impl *a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  switch((int)a1)
  {
    case 0:
      result = (_QWORD *)operator new();
      *result = &unk_24C0C4118;
      *a2 = result;
      break;
    case 1:
      result = (_QWORD *)operator new();
      *result = &unk_24C0C41D8;
      *a2 = result;
      break;
    case 2:
      result = (_QWORD *)operator new();
      *result = &unk_24C0C4208;
      *a2 = result;
      break;
    case 3:
      result = (_QWORD *)operator new();
      *result = &unk_24C0C40E8;
      *a2 = result;
      break;
    case 4:
      result = (_QWORD *)operator new();
      *result = &unk_24C0C4148;
      *a2 = result;
      break;
    case 5:
      result = (_QWORD *)operator new();
      *result = &unk_24C0C4178;
      *a2 = result;
      break;
    default:
      rtc::webrtc_checks_impl::UnreachableCodeReached(a1);
  }
  return result;
}

void WebRtcSpl_CrossCorrelationC(int *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, char a6, int a7)
{
  uint64_t v7;
  int32x4_t v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  int32x4_t v12;
  unint64_t v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;

  if (a5)
  {
    if (a4)
    {
      v7 = 0;
      v8 = vnegq_s32(vdupq_n_s32(a6));
      while (1)
      {
        if (a4 >= 0x10)
        {
          v11 = 0;
          v12 = 0uLL;
          v13 = a4 & 0xFFFFFFFFFFFFFFF0;
          v14 = 0uLL;
          v15 = 0uLL;
          v16 = 0uLL;
          do
          {
            v17 = *(int16x8_t *)(a2 + v11);
            v18 = *(int16x8_t *)(a2 + v11 + 16);
            v19 = *(int16x8_t *)(a3 + v11);
            v20 = *(int16x8_t *)(a3 + v11 + 16);
            v14 = vaddq_s32(vshlq_s32(vmull_high_s16(v19, v17), v8), v14);
            v12 = vaddq_s32(vshlq_s32(vmull_s16(*(int16x4_t *)v19.i8, *(int16x4_t *)v17.i8), v8), v12);
            v16 = vaddq_s32(vshlq_s32(vmull_high_s16(v20, v18), v8), v16);
            v15 = vaddq_s32(vshlq_s32(vmull_s16(*(int16x4_t *)v20.i8, *(int16x4_t *)v18.i8), v8), v15);
            v11 += 32;
            v13 -= 16;
          }
          while (v13);
          v9 = vaddvq_s32(vaddq_s32(vaddq_s32(v15, v12), vaddq_s32(v16, v14)));
          v10 = a4 & 0xFFFFFFFFFFFFFFF0;
          if ((a4 & 0xFFFFFFFFFFFFFFF0) == a4)
            goto LABEL_4;
        }
        else
        {
          v9 = 0;
          v10 = 0;
        }
        do
        {
          v9 += (*(__int16 *)(a3 + 2 * v10) * *(__int16 *)(a2 + 2 * v10)) >> a6;
          ++v10;
        }
        while (a4 != v10);
LABEL_4:
        *a1++ = v9;
        ++v7;
        a3 += 2 * a7;
        if (v7 == a5)
          return;
      }
    }
    bzero(a1, 4 * a5);
  }
}

_QWORD *rtc::CryptString::CryptString(_QWORD *a1, _QWORD *a2)
{
  *a1 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
  return a1;
}

_QWORD *rtc::CryptString::CryptString(_QWORD *a1, uint64_t a2)
{
  *a1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  return a1;
}

void rtc::CryptString::~CryptString(rtc::CryptString *this)
{
  uint64_t v2;

  v2 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
}

double webrtc::CryptoOptions::CryptoOptions(webrtc::CryptoOptions *this)
{
  double result;

  *(_QWORD *)&result = 0x1000100010001;
  *(_DWORD *)this = 65537;
  *((_BYTE *)this + 4) = 0;
  return result;
}

double webrtc::CryptoOptions::CryptoOptions(webrtc::CryptoOptions *this, const webrtc::CryptoOptions *a2)
{
  double result;

  *(_QWORD *)&result = 0x1000100010001;
  *(_DWORD *)this = 65537;
  *((_BYTE *)this + 4) = 0;
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_BYTE *)this + 4) = *((_BYTE *)a2 + 4);
  return result;
}

double webrtc::CryptoOptions::NoGcm@<D0>(uint64_t a1@<X8>)
{
  double result;

  *(_BYTE *)(a1 + 4) = 0;
  *(_QWORD *)&result = 0x1000000010000;
  *(_DWORD *)a1 = 0x10000;
  return result;
}

void webrtc::CryptoOptions::GetSupportedDtlsSrtpCryptoSuites(webrtc::CryptoOptions *this@<X0>, uint64_t a2@<X4>, uint64_t a3@<X5>, uint64_t a4@<X6>, uint64_t a5@<X7>, char **a6@<X8>)
{
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  char *v24;
  unint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  _OWORD *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  int v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  _BYTE *v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  _OWORD *v44;
  char *v45;
  uint64_t v46;
  __int128 v47;
  int v48;
  std::string *v49;
  unsigned __int8 *v50;
  uint64_t v51;

  *a6 = 0;
  a6[1] = 0;
  a6[2] = 0;
  if (*((_BYTE *)this + 1))
  {
    v8 = (char *)operator new(4uLL);
    *(_DWORD *)v8 = 2;
    v9 = v8 + 4;
    a6[1] = v8 + 4;
    a6[2] = v8 + 4;
    *a6 = v8;
    if (*((_BYTE *)this + 2))
      goto LABEL_3;
LABEL_17:
    v15 = v8;
    v16 = v9;
    v17 = v9;
    if (!*(_BYTE *)this)
      goto LABEL_60;
    goto LABEL_18;
  }
  v8 = 0;
  v9 = 0;
  if (!*((_BYTE *)this + 2))
    goto LABEL_17;
LABEL_3:
  v10 = v9 - v8;
  v11 = (v9 - v8) >> 2;
  v12 = v11 + 1;
  if ((unint64_t)(v11 + 1) >> 62)
    goto LABEL_63;
  if (v10 >> 1 > v12)
    v12 = v10 >> 1;
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFFCLL)
    v12 = 0x3FFFFFFFFFFFFFFFLL;
  if (!v12)
    goto LABEL_62;
  if (v12 >> 62)
    goto LABEL_64;
  v13 = 4 * v12;
  v14 = (char *)operator new(4 * v12);
  v15 = &v14[4 * v11];
  v16 = &v14[v13];
  *(_DWORD *)v15 = 1;
  v17 = v15 + 4;
  if (v9 != v8)
  {
    v18 = (v9 - v8 - 4) & 0xFFFFFFFFFFFFFFFCLL;
    v15 = &v14[v10 - v18 - 4];
    memcpy(v15, &v9[-v18 - 4], v18 + 4);
  }
  *a6 = v15;
  a6[2] = v16;
  if (v8)
    operator delete(v8);
  a6[1] = v17;
  if (*(_BYTE *)this)
  {
LABEL_18:
    if (v17 < v16)
    {
      if (!v17)
        goto LABEL_62;
      *(_DWORD *)v17 = 8;
      v19 = v17 + 4;
LABEL_39:
      if (v19 < v16)
      {
        *(_DWORD *)v19 = 7;
        v15 = *a6;
        v17 = v19 + 4;
LABEL_59:
        a6[1] = v17;
        goto LABEL_60;
      }
      v34 = *a6;
      v35 = v19 - *a6;
      v36 = v35 >> 2;
      v37 = (v35 >> 2) + 1;
      if (v37 >> 62)
LABEL_63:
        abort();
      if ((v16 - v34) >> 1 > v37)
        v37 = (v16 - v34) >> 1;
      if ((unint64_t)(v16 - v34) >= 0x7FFFFFFFFFFFFFFCLL)
        v37 = 0x3FFFFFFFFFFFFFFFLL;
      if (v37)
      {
        if (!(v37 >> 62))
        {
          v38 = 4 * v37;
          v39 = operator new(4 * v37);
          v15 = &v39[4 * v36];
          *(_DWORD *)v15 = 7;
          v17 = v15 + 4;
          if (v19 == v34)
            goto LABEL_57;
          v40 = v19 - v34 - 4;
          if (v40 >= 0x2C)
          {
            if ((unint64_t)(&v19[-v35] - v39) >= 0x20)
            {
              v42 = (v40 >> 2) + 1;
              v43 = 4 * (v42 & 0x7FFFFFFFFFFFFFF8);
              v41 = &v19[-v43];
              v15 -= v43;
              v44 = &v39[4 * v36 - 16];
              v45 = v19 - 16;
              v46 = v42 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                v47 = *(_OWORD *)v45;
                *(v44 - 1) = *((_OWORD *)v45 - 1);
                *v44 = v47;
                v44 -= 2;
                v45 -= 32;
                v46 -= 8;
              }
              while (v46);
              if (v42 == (v42 & 0x7FFFFFFFFFFFFFF8))
              {
LABEL_57:
                *a6 = v15;
                a6[2] = &v39[v38];
                if (v34)
                  operator delete(v34);
                goto LABEL_59;
              }
            }
            else
            {
              v41 = v19;
            }
          }
          else
          {
            v41 = v19;
          }
          do
          {
            v48 = *((_DWORD *)v41 - 1);
            v41 -= 4;
            *((_DWORD *)v15 - 1) = v48;
            v15 -= 4;
          }
          while (v41 != v34);
          goto LABEL_57;
        }
LABEL_64:
        std::__throw_bad_array_new_length[abi:sn180100]();
      }
LABEL_62:
      __break(1u);
      goto LABEL_63;
    }
    v20 = (v17 - v15) >> 2;
    v21 = v20 + 1;
    if ((unint64_t)(v20 + 1) >> 62)
      goto LABEL_63;
    if ((v16 - v15) >> 1 > v21)
      v21 = (v16 - v15) >> 1;
    if ((unint64_t)(v16 - v15) >= 0x7FFFFFFFFFFFFFFCLL)
      v21 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v21)
      goto LABEL_62;
    if (v21 >> 62)
      goto LABEL_64;
    v22 = 4 * v21;
    v23 = operator new(4 * v21);
    v24 = &v23[4 * v20];
    v16 = &v23[v22];
    *(_DWORD *)v24 = 8;
    v19 = v24 + 4;
    if (v17 != v15)
    {
      v25 = v17 - v15 - 4;
      if (v25 < 0x2C)
      {
        v26 = v17;
        goto LABEL_36;
      }
      if ((unint64_t)(v15 - v23) < 0x20)
      {
        v26 = v17;
        do
        {
LABEL_36:
          v33 = *((_DWORD *)v26 - 1);
          v26 -= 4;
          *((_DWORD *)v24 - 1) = v33;
          v24 -= 4;
        }
        while (v26 != v15);
        goto LABEL_37;
      }
      v27 = (v25 >> 2) + 1;
      v28 = 4 * (v27 & 0x7FFFFFFFFFFFFFF8);
      v26 = &v17[-v28];
      v24 -= v28;
      v29 = &v23[4 * v20 - 16];
      v30 = v17 - 16;
      v31 = v27 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v32 = *(_OWORD *)v30;
        *(v29 - 1) = *((_OWORD *)v30 - 1);
        *v29 = v32;
        v29 -= 2;
        v30 -= 32;
        v31 -= 8;
      }
      while (v31);
      if (v27 != (v27 & 0x7FFFFFFFFFFFFFF8))
        goto LABEL_36;
    }
LABEL_37:
    *a6 = v24;
    a6[1] = v19;
    a6[2] = v16;
    if (v15)
      operator delete(v15);
    goto LABEL_39;
  }
LABEL_60:
  if (v15 == v17)
  {
    v49 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/crypto/crypto_options.cc", 54, "!crypto_suites.empty()", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a2, a3, a4, a5, v51);
    webrtc::CryptoOptions::operator!=((unsigned __int8 *)v49, v50);
  }
}

BOOL webrtc::CryptoOptions::operator!=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 != *a2 || a1[1] != a2[1] || a1[2] != a2[2] || a1[3] != a2[3] || a1[4] != a2[4];
}

void webrtc::DataChannelController::~DataChannelController(webrtc::DataChannelController *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  _BYTE *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;

  *(_QWORD *)this = off_24C0B2578;
  *((_QWORD *)this + 1) = &unk_24C0B2600;
  v2 = *((_QWORD *)this + 13);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  *((_QWORD *)this + 12) = 0;
  v5 = (_BYTE *)*((_QWORD *)this + 11);
  if (v5)
  {
    *v5 = 0;
    v6 = (unsigned int *)(v5 + 4);
    do
    {
      v7 = __ldaxr(v6);
      v8 = v7 - 1;
    }
    while (__stlxr(v8, v6));
    if (!v8)
      MEMORY[0x20BD0ADEC]();
    *((_QWORD *)this + 11) = 0;
  }
  v9 = *((_QWORD *)this + 6);
  if (v9)
  {
    v10 = *((_QWORD *)this + 7);
    v11 = (void *)*((_QWORD *)this + 6);
    if (v10 != v9)
    {
      do
      {
        v13 = *(_QWORD *)(v10 - 8);
        v10 -= 8;
        v12 = v13;
        if (v13)
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
      }
      while (v10 != v9);
      v11 = (void *)*((_QWORD *)this + 6);
    }
    *((_QWORD *)this + 7) = v9;
    operator delete(v11);
  }
  v14 = (void *)*((_QWORD *)this + 3);
  if (v14)
  {
    *((_QWORD *)this + 4) = v14;
    operator delete(v14);
  }
}

{
  webrtc::DataChannelController::~DataChannelController(this);
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'webrtc::DataChannelController::~DataChannelController(webrtc::DataChannelController *this)
{
  webrtc::DataChannelController::~DataChannelController((webrtc::DataChannelController *)((char *)this - 8));
}

{
  webrtc::DataChannelController::~DataChannelController((webrtc::DataChannelController *)((char *)this - 8));
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::DataChannelController::SendData(uint64_t a1@<X0>, unsigned __int16 a2@<W1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4)
  {
    (*(void (**)(_QWORD *__return_ptr, uint64_t, _QWORD))(*(_QWORD *)v4 + 24))(a3, v4, a2);
  }
  else
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/data_channel_controller.cc");
    *(_DWORD *)a3 = 6;
    *((_BYTE *)a3 + 38) = 0;
    a3[2] = 0;
    a3[3] = 0;
    a3[1] = 0;
    *(_QWORD *)((char *)a3 + 29) = 0;
  }
}

void webrtc::DataChannelController::AddSctpDataStream(uint64_t a1, unsigned __int16 a2)
{
  uint64_t v2;
  void *v3[3];
  char v4;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    (*(void (**)(void **__return_ptr, uint64_t, _QWORD))(*(_QWORD *)v2 + 16))(v3, v2, a2);
    if (v4 < 0)
      operator delete(v3[1]);
  }
}

void webrtc::DataChannelController::RemoveSctpDataStream(uint64_t a1, unsigned __int16 a2)
{
  uint64_t v2;
  void *v3[3];
  char v4;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    (*(void (**)(void **__return_ptr, uint64_t, _QWORD))(*(_QWORD *)v2 + 32))(v3, v2, a2);
    if (v4 < 0)
      operator delete(v3[1]);
  }
}

_QWORD *webrtc::DataChannelController::OnChannelStateChanged(_QWORD *result, uint64_t a2, int a3)
{
  _QWORD *v4;
  int v5;
  unsigned int v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  unint64_t v10;
  unsigned __int16 *v11;
  unint64_t v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  unsigned int v15;
  unsigned __int16 *v16;
  uint64_t v17;
  uint64_t v18;
  int64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  char v30;
  _DWORD *v31;
  _QWORD *v32;
  char v33;
  char v34;
  _QWORD v35[2];
  uint64_t (*v36)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v37)(uint64_t);

  v4 = result;
  v5 = *(_DWORD *)(a2 + 28);
  if (a3 == 3)
  {
    if ((*(_DWORD *)(a2 + 24) & 0xFF0000) != 0)
    {
      v7 = (unsigned __int16)*(_DWORD *)(a2 + 24);
      v9 = (unsigned __int16 *)result[3];
      v8 = (unsigned __int16 *)result[4];
      if (v8 == v9)
      {
        v11 = (unsigned __int16 *)result[4];
        v16 = v11;
      }
      else
      {
        v10 = v8 - v9;
        v11 = (unsigned __int16 *)result[3];
        do
        {
          v12 = v10 >> 1;
          v13 = &v11[v10 >> 1];
          v15 = *v13;
          v14 = v13 + 1;
          v10 += ~(v10 >> 1);
          if (v15 < v7)
            v11 = v14;
          else
            v10 = v12;
        }
        while (v10);
        v16 = v11;
        if (v8 != v11)
        {
          if (*v11 <= v7)
            v16 = v11 + 1;
          else
            v16 = v11;
        }
      }
      v17 = v11 - v9;
      v18 = v16 - v9;
      if (v18 < v17)
      {
        __break(1u);
        return result;
      }
      if (v17 != v18)
      {
        v19 = (char *)v8 - (char *)v16;
        if (v8 != v16)
          memmove(v11, v16, (char *)v8 - (char *)v16);
        v4[4] = (char *)v11 + v19;
      }
    }
    v20 = (_QWORD *)v4[6];
    v21 = (_QWORD *)v4[7];
    if (v20 != v21)
    {
      while (*v20 != a2)
      {
        if (++v20 == v21)
          goto LABEL_29;
      }
    }
    if (v20 == v21)
    {
LABEL_29:
      v20 = (_QWORD *)v4[7];
    }
    else
    {
      v22 = v20 + 1;
      if (v20 + 1 != v21)
      {
        do
        {
          v23 = *(v22 - 1);
          *(v22 - 1) = *v22;
          *v22 = 0;
          if (v23)
            (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
          ++v22;
        }
        while (v22 != v21);
        v21 = (_QWORD *)v4[7];
        v20 = v22 - 1;
      }
      while (v21 != v20)
      {
        v25 = *--v21;
        v24 = v25;
        if (v25)
          (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
      }
      v4[7] = v20;
    }
  }
  else
  {
    v20 = (_QWORD *)result[7];
  }
  v26 = (_QWORD *)v4[6];
  v27 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v4[10] + 512))(v4[10]);
  v28 = (unsigned int *)v4[13];
  if (v28)
  {
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  if (v26 == v20)
    v30 = 1;
  else
    v30 = 2;
  v31 = operator new(0x18uLL);
  *(_QWORD *)v31 = v4;
  v31[2] = v5;
  v31[3] = a3;
  *((_BYTE *)v31 + 16) = v30;
  v32 = (_QWORD *)operator new();
  *v32 = v28;
  v32[1] = v31;
  v32[2] = 24;
  v32[3] = absl::internal_any_invocable::RemoteManagerTrivial;
  v32[4] = absl::internal_any_invocable::RemoteInvoker<false,void,webrtc::DataChannelController::OnChannelStateChanged(webrtc::SctpDataChannel *,webrtc::DataChannelInterface::DataState)::$_1 &&>;
  v35[0] = v32;
  v36 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
  v37 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
  (*(void (**)(uint64_t, _QWORD *, char *, char *))(*(_QWORD *)v27 + 8))(v27, v35, &v34, &v33);
  return (_QWORD *)v36(1, v35, v35);
}

uint64_t webrtc::DataChannelController::buffered_amount(uint64_t a1, unsigned __int16 a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 16);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 56))(result, a2);
  return result;
}

uint64_t webrtc::DataChannelController::buffered_amount_low_threshold(uint64_t a1, unsigned __int16 a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 16);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 64))(result, a2);
  return result;
}

uint64_t webrtc::DataChannelController::SetBufferedAmountLowThreshold(uint64_t a1, unsigned __int16 a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 16);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 72))(result, a2);
  return result;
}

void webrtc::DataChannelController::OnDataReceived(uint64_t a1, int a2, int a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t *v9;

  if ((webrtc::DataChannelController::HandleOpenMessage_n(a1, a2, a3, a4) & 1) == 0)
  {
    v8 = *(uint64_t **)(a1 + 48);
    v9 = *(uint64_t **)(a1 + 56);
    if (v8 != v9)
    {
      while ((*(_DWORD *)(*v8 + 24) & 0xFF0000) == 0 || (unsigned __int16)*(_DWORD *)(*v8 + 24) != a2)
      {
        if (++v8 == v9)
          return;
      }
    }
    if (v8 != v9)
      webrtc::SctpDataChannel::OnDataReceived(*v8, a3, a4);
  }
}

uint64_t webrtc::DataChannelController::HandleOpenMessage_n(uint64_t a1, int a2, int a3, uint64_t *a4)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  _QWORD *v27;
  char v28;
  int v29;
  void *__p;
  char v31;
  uint64_t v32;
  char v33;
  _WORD v34[2];
  char v35;
  char v36;
  char v37;
  char v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  int v43;
  char v44;
  char v45;
  int v46;
  char v47;
  char v48;
  std::string v49;
  char v50;
  __int128 v51;
  uint64_t (*v52)(uint64_t, uint64_t *, __int128 *);
  uint64_t (*v53)(uint64_t);

  result = 0;
  if (a3 == 2 && a4[2])
  {
    if (*(_BYTE *)(*(_QWORD *)(*a4 + 16) + a4[1]) != 3)
      return 0;
    memset(&v49, 0, sizeof(v49));
    v34[0] = 256;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v40 = 0;
    v41 = 0;
    v39 = 0;
    v42 = 0;
    v44 = 0;
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v48 = 0;
    v43 = a2;
    if ((webrtc::ParseDataChannelOpenMessage(a4, &v49, (uint64_t)v34) & 1) != 0)
    {
      v46 = 1;
      webrtc::DataChannelController::CreateDataChannel((uint64_t)&v29, a1, (__int128 *)&v49, (uint64_t)v34);
      v6 = v29;
      if (v29)
      {
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
        {
          rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*> const&)::t, v7, v8, v9, v10, v11, v12, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/data_channel_controller.cc");
        }
        if (v33 && v32)
          (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
      }
      else
      {
        result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 80) + 512))(*(_QWORD *)(a1 + 80));
        v21 = result;
        v22 = *(unsigned int **)(a1 + 104);
        if (v22)
        {
          do
            v23 = __ldxr(v22);
          while (__stxr(v23 + 1, v22));
        }
        if (!v33)
        {
          __break(1u);
          return result;
        }
        v24 = v32;
        v25 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
        v26 = operator new();
        *(_QWORD *)v26 = a1;
        *(_QWORD *)(v26 + 8) = v24;
        *(_BYTE *)(v26 + 16) = v25;
        v27 = (_QWORD *)operator new();
        *v27 = v22;
        v27[1] = v26;
        v27[3] = absl::internal_any_invocable::RemoteManagerNontrivial<webrtc::DataChannelController::HandleOpenMessage_n(int,webrtc::DataMessageType,rtc::CopyOnWriteBuffer const&)::$_0>;
        v27[4] = absl::internal_any_invocable::RemoteInvoker<false,void,webrtc::DataChannelController::HandleOpenMessage_n(int,webrtc::DataMessageType,rtc::CopyOnWriteBuffer const&)::$_0 &&>;
        *(_QWORD *)&v51 = v27;
        v52 = (uint64_t (*)(uint64_t, uint64_t *, __int128 *))_ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
        v53 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
        (*(void (**)(uint64_t, __int128 *, char *, char *))(*(_QWORD *)v21 + 8))(v21, &v51, &v50, &v28);
        v52(1, (uint64_t *)&v51, &v51);
      }
      if (v31 < 0)
        operator delete(__p);
    }
    else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v14, v15, v16, v17, v18, v19, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/data_channel_controller.cc");
    }
    if (SHIBYTE(v41) < 0)
    {
      operator delete(v39);
      if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        return 1;
    }
    else if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      return 1;
    }
    operator delete(v49.__r_.__value_.__l.__data_);
    return 1;
  }
  return result;
}

void `non-virtual thunk to'webrtc::DataChannelController::OnDataReceived(uint64_t a1, int a2, int a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t *v9;

  if ((webrtc::DataChannelController::HandleOpenMessage_n(a1 - 8, a2, a3, a4) & 1) == 0)
  {
    v8 = *(uint64_t **)(a1 + 40);
    v9 = *(uint64_t **)(a1 + 48);
    if (v8 != v9)
    {
      while ((*(_DWORD *)(*v8 + 24) & 0xFF0000) == 0 || (unsigned __int16)*(_DWORD *)(*v8 + 24) != a2)
      {
        if (++v8 == v9)
          return;
      }
    }
    if (v8 != v9)
      webrtc::SctpDataChannel::OnDataReceived(*v8, a3, a4);
  }
}

_QWORD *webrtc::DataChannelController::OnChannelClosing(_QWORD *this, int a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v5;
  _BYTE *v6;

  v2 = (uint64_t *)this[6];
  v3 = (uint64_t *)this[7];
  if (v2 != v3)
  {
    while ((*(_DWORD *)(*v2 + 24) & 0xFF0000) == 0 || (unsigned __int16)*(_DWORD *)(*v2 + 24) != a2)
    {
      if (++v2 == v3)
        return this;
    }
  }
  if (v2 != v3)
  {
    v5 = *v2;
    if ((*(_DWORD *)(*v2 + 136) & 0xFFFFFFFE) != 2)
    {
      *(_BYTE *)(v5 + 236) = 1;
      *(_DWORD *)(v5 + 136) = 2;
      this = *(_QWORD **)(v5 + 120);
      if (this)
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))*this)(this);
      v6 = *(_BYTE **)(v5 + 216);
      if (v6 && *v6)
      {
        this = *(_QWORD **)(v5 + 224);
        if (this)
          return (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*this + 24))(this, v5, *(unsigned int *)(v5 + 136));
      }
    }
  }
  return this;
}

_QWORD *`non-virtual thunk to'webrtc::DataChannelController::OnChannelClosing(_QWORD *this, int a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v5;
  _BYTE *v6;

  v2 = (uint64_t *)this[5];
  v3 = (uint64_t *)this[6];
  if (v2 != v3)
  {
    while ((*(_DWORD *)(*v2 + 24) & 0xFF0000) == 0 || (unsigned __int16)*(_DWORD *)(*v2 + 24) != a2)
    {
      if (++v2 == v3)
        return this;
    }
  }
  if (v2 != v3)
  {
    v5 = *v2;
    if ((*(_DWORD *)(*v2 + 136) & 0xFFFFFFFE) != 2)
    {
      *(_BYTE *)(v5 + 236) = 1;
      *(_DWORD *)(v5 + 136) = 2;
      this = *(_QWORD **)(v5 + 120);
      if (this)
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))*this)(this);
      v6 = *(_BYTE **)(v5 + 216);
      if (v6 && *v6)
      {
        this = *(_QWORD **)(v5 + 224);
        if (this)
          return (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*this + 24))(this, v5, *(unsigned int *)(v5 + 136));
      }
    }
  }
  return this;
}

_QWORD *webrtc::DataChannelController::OnChannelClosed(_QWORD *this, unsigned __int16 a2)
{
  _QWORD *v2;
  unsigned int v3;
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  unint64_t v6;
  unsigned __int16 *v7;
  unint64_t v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  unsigned int v11;
  unsigned __int16 *v12;
  uint64_t v13;
  uint64_t v14;
  int64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (***v24)(_QWORD);
  _BYTE *v25;
  uint64_t v26;

  v2 = this;
  v3 = a2;
  v5 = (unsigned __int16 *)this[3];
  v4 = (unsigned __int16 *)this[4];
  if (v4 == v5)
  {
    v7 = (unsigned __int16 *)this[4];
    v12 = v7;
  }
  else
  {
    v6 = v4 - v5;
    v7 = (unsigned __int16 *)this[3];
    do
    {
      v8 = v6 >> 1;
      v9 = &v7[v6 >> 1];
      v11 = *v9;
      v10 = v9 + 1;
      v6 += ~(v6 >> 1);
      if (v11 < a2)
        v7 = v10;
      else
        v6 = v8;
    }
    while (v6);
    v12 = v7;
    if (v4 != v7)
    {
      if (*v7 <= v3)
        v12 = v7 + 1;
      else
        v12 = v7;
    }
  }
  v13 = v7 - v5;
  v14 = v12 - v5;
  if (v14 < v13)
  {
    __break(1u);
  }
  else
  {
    if (v13 != v14)
    {
      v15 = (char *)v4 - (char *)v12;
      if (v4 != v12)
        this = memmove(v7, v12, (char *)v4 - (char *)v12);
      v2[4] = (char *)v7 + v15;
    }
    v17 = (_QWORD *)v2[6];
    v16 = (_QWORD *)v2[7];
    if (v17 != v16)
    {
      while ((*(_DWORD *)(*v17 + 24) & 0xFF0000) == 0 || v3 != (unsigned __int16)*(_DWORD *)(*v17 + 24))
      {
        if (++v17 == v16)
          return this;
      }
    }
    if (v17 != v16)
    {
      v19 = *v17;
      *v17 = 0;
      v20 = v17 + 1;
      if (v17 + 1 != v16)
      {
        do
        {
          v21 = *(v20 - 1);
          *(v20 - 1) = *v20;
          *v20 = 0;
          if (v21)
            (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
          ++v20;
        }
        while (v20 != v16);
        v16 = (_QWORD *)v2[7];
        v17 = v20 - 1;
      }
      while (v16 != v17)
      {
        v23 = *--v16;
        v22 = v23;
        if (v23)
          (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
      }
      v2[7] = v17;
      if (*(_DWORD *)(v19 + 136) != 3)
      {
        *(_DWORD *)(v19 + 136) = 3;
        v24 = *(void (****)(_QWORD))(v19 + 120);
        if (v24)
          (**v24)(v24);
        v25 = *(_BYTE **)(v19 + 216);
        if (v25 && *v25)
        {
          v26 = *(_QWORD *)(v19 + 224);
          if (v26)
            (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v26 + 24))(v26, v19, *(unsigned int *)(v19 + 136));
        }
      }
      return (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    }
  }
  return this;
}

_QWORD *`non-virtual thunk to'webrtc::DataChannelController::OnChannelClosed(webrtc::DataChannelController *this, unsigned __int16 a2)
{
  return webrtc::DataChannelController::OnChannelClosed((_QWORD *)this - 1, a2);
}

void webrtc::DataChannelController::OnReadyToSend(webrtc::DataChannelController *this)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  webrtc::SctpDataChannel **v5;
  uint64_t v6;
  webrtc::SctpDataChannel *v7;
  uint64_t v8;
  uint64_t v9;
  webrtc::SctpDataChannel **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  webrtc::SctpDataChannel *v18;

  v2 = *((_QWORD *)this + 6);
  v3 = *((_QWORD *)this + 7);
  v4 = v3 - v2;
  if (v3 != v2)
  {
    if ((v4 & 0x8000000000000000) != 0)
      abort();
    v5 = (webrtc::SctpDataChannel **)operator new(v4);
    v6 = 0;
    do
    {
      v7 = *(webrtc::SctpDataChannel **)(v2 + v6);
      v5[(unint64_t)v6 / 8] = v7;
      if (v7)
        (**(void (***)(webrtc::SctpDataChannel *))v7)(v7);
      v6 += 8;
    }
    while (v2 + v6 != v3);
    if (v6)
    {
      v8 = v6 >> 3;
      v9 = v8 * 8;
      v10 = v5;
      do
      {
        if (*((_BYTE *)*v10 + 26))
        {
          webrtc::SctpDataChannel::UpdateState(*v10);
        }
        else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
        {
          v1 = v1 & 0xFFFFFFFF00000000 | 0x561;
          rtc::webrtc_logging_impl::Log("\r\t", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/data_channel_controller.cc");
        }
        ++v10;
        v9 -= 8;
      }
      while (v9);
      do
      {
        v18 = v5[v8 - 1];
        if (v18)
          (*(void (**)(webrtc::SctpDataChannel *))(*(_QWORD *)v18 + 8))(v18);
        --v8;
      }
      while (v8 * 8);
    }
    operator delete(v5);
  }
}

void `non-virtual thunk to'webrtc::DataChannelController::OnReadyToSend(webrtc::DataChannelController *this)
{
  webrtc::DataChannelController::OnReadyToSend((webrtc::DataChannelController *)((char *)this - 8));
}

void webrtc::DataChannelController::OnTransportClosed(_QWORD *a1, int *a2)
{
  char *v2;
  char *v3;
  int *v4;
  _QWORD *v5;
  std::string *v6;
  uint64_t *v7;
  _DWORD *v8;
  std::string *p_p;
  char *v10;
  uint64_t v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  unint64_t v17;
  unsigned __int16 *v18;
  unint64_t v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  unsigned int v22;
  unsigned __int16 *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  std::string *v27;
  uint64_t *v28;
  std::string *v29;
  _QWORD *v30;
  int64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  int v36;
  std::string v37;
  uint64_t v38;
  int v39;
  void *__p;
  char v41;
  _DWORD v42[2];

  v2 = (char *)a1[6];
  v3 = (char *)a1[7];
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  if (v2 == v3)
  {
    if (v2)
      goto LABEL_35;
    return;
  }
  v4 = a2;
  v5 = a1;
  v6 = (std::string *)(a2 + 2);
  v7 = &v38;
  v8 = a2 + 8;
  p_p = (std::string *)&__p;
  v34 = v2;
  do
  {
    v11 = *(_QWORD *)v2;
    v12 = *v4;
    v36 = *v4;
    if (*((char *)v4 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v37, *((const std::string::value_type **)v4 + 1), *((_QWORD *)v4 + 2));
      v12 = v36;
    }
    else
    {
      v37 = *v6;
    }
    *(_DWORD *)v7 = *v8;
    *(_DWORD *)((char *)v7 + 3) = *(_DWORD *)((char *)v8 + 3);
    v39 = v12;
    *p_p = v37;
    memset(&v37, 0, sizeof(v37));
    v42[0] = *v8;
    *(_DWORD *)((char *)v42 + 3) = *(_DWORD *)((char *)v8 + 3);
    webrtc::SctpDataChannel::CloseAbruptlyWithError(v11, (uint64_t)&v39);
    if (v41 < 0)
    {
      operator delete(__p);
      if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_10:
        v13 = *(_DWORD *)(*(_QWORD *)v2 + 24);
        if ((v13 & 0xFF0000) == 0)
          goto LABEL_4;
        goto LABEL_14;
      }
    }
    else if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_10;
    }
    operator delete(v37.__r_.__value_.__l.__data_);
    v13 = *(_DWORD *)(*(_QWORD *)v2 + 24);
    if ((v13 & 0xFF0000) == 0)
      goto LABEL_4;
LABEL_14:
    v14 = (unsigned __int16)v13;
    v16 = (unsigned __int16 *)v5[3];
    v15 = (unsigned __int16 *)v5[4];
    if (v15 == v16)
    {
      v18 = (unsigned __int16 *)v5[4];
      v23 = v18;
    }
    else
    {
      v17 = v15 - v16;
      v18 = (unsigned __int16 *)v5[3];
      do
      {
        v19 = v17 >> 1;
        v20 = &v18[v17 >> 1];
        v22 = *v20;
        v21 = v20 + 1;
        v17 += ~(v17 >> 1);
        if (v22 < v14)
          v18 = v21;
        else
          v17 = v19;
      }
      while (v17);
      v23 = v18;
      if (v15 != v18)
      {
        if (*v18 <= v14)
          v23 = v18 + 1;
        else
          v23 = v18;
      }
    }
    v24 = v18 - v16;
    v25 = v23 - v16;
    if (v25 < v24)
    {
      __break(1u);
      return;
    }
    if (v24 != v25)
    {
      v26 = v3;
      v27 = p_p;
      v28 = v7;
      v29 = v6;
      v30 = v5;
      v31 = (char *)v15 - (char *)v23;
      if (v15 != v23)
        memmove(v18, v23, (char *)v15 - (char *)v23);
      v10 = (char *)v18 + v31;
      v5 = v30;
      v30[4] = v10;
      v6 = v29;
      v7 = v28;
      p_p = v27;
      v3 = v26;
      v4 = a2;
    }
LABEL_4:
    v2 += 8;
  }
  while (v2 != v3);
  v2 = v34;
  if (!v34)
    return;
  do
  {
    v33 = *((_QWORD *)v3 - 1);
    v3 -= 8;
    v32 = v33;
    if (v33)
      (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
  }
  while (v3 != v34);
LABEL_35:
  operator delete(v2);
}

void `non-virtual thunk to'webrtc::DataChannelController::OnTransportClosed(uint64_t a1, int *a2)
{
  webrtc::DataChannelController::OnTransportClosed((_QWORD *)(a1 - 8), a2);
}

_QWORD *webrtc::DataChannelController::OnBufferedAmountLow(_QWORD *this, int a2)
{
  _QWORD **v2;
  _QWORD **v3;
  _DWORD *v5;
  _BYTE *v6;

  v2 = (_QWORD **)this[6];
  v3 = (_QWORD **)this[7];
  if (v2 != v3)
  {
    while (((*v2)[3] & 0xFF0000) == 0 || (unsigned __int16)*((_DWORD *)*v2 + 6) != a2)
    {
      if (++v2 == v3)
        return this;
    }
  }
  if (v2 != v3)
  {
    v5 = *v2;
    this = webrtc::SctpDataChannel::MaybeSendOnBufferedAmountChanged(*v2);
    if (v5[34] == 2 && !*((_BYTE *)v5 + 236))
    {
      if (*((_BYTE *)v5 + 26))
      {
        this = (_QWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)v5 + 184))(v5);
        if (!this)
        {
          *((_BYTE *)v5 + 236) = 1;
          v6 = (_BYTE *)*((_QWORD *)v5 + 27);
          if (v6 && *v6)
            this = (_QWORD *)*((_QWORD *)v5 + 28);
          else
            this = 0;
          if (*((_BYTE *)v5 + 26))
            return (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD))(*this + 16))(this, *((unsigned __int16 *)v5 + 12));
          else
            __break(1u);
        }
      }
    }
  }
  return this;
}

_QWORD *`non-virtual thunk to'webrtc::DataChannelController::OnBufferedAmountLow(_QWORD *this, int a2)
{
  _QWORD **v2;
  _QWORD **v3;
  _DWORD *v5;
  _BYTE *v6;

  v2 = (_QWORD **)this[5];
  v3 = (_QWORD **)this[6];
  if (v2 != v3)
  {
    while (((*v2)[3] & 0xFF0000) == 0 || (unsigned __int16)*((_DWORD *)*v2 + 6) != a2)
    {
      if (++v2 == v3)
        return this;
    }
  }
  if (v2 != v3)
  {
    v5 = *v2;
    this = webrtc::SctpDataChannel::MaybeSendOnBufferedAmountChanged(*v2);
    if (v5[34] == 2 && !*((_BYTE *)v5 + 236))
    {
      if (*((_BYTE *)v5 + 26))
      {
        this = (_QWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)v5 + 184))(v5);
        if (!this)
        {
          *((_BYTE *)v5 + 236) = 1;
          v6 = (_BYTE *)*((_QWORD *)v5 + 27);
          if (v6 && *v6)
            this = (_QWORD *)*((_QWORD *)v5 + 28);
          else
            this = 0;
          if (*((_BYTE *)v5 + 26))
            return (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD))(*this + 16))(this, *((unsigned __int16 *)v5 + 12));
          else
            __break(1u);
        }
      }
    }
  }
  return this;
}

void webrtc::DataChannelController::GetDataChannelStats(webrtc::DataChannelController *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v4;
  uint64_t *i;
  uint64_t v6;
  unint64_t v7;
  __int128 v8;
  uint64_t v9;
  __int128 v10;
  char *v11;
  int v12;
  uint64_t v13;
  __int128 __p;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;

  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  std::vector<webrtc::DataChannelStats>::reserve(a2, (uint64_t)(*((_QWORD *)this + 7) - *((_QWORD *)this + 6)) >> 3);
  v4 = (uint64_t *)*((_QWORD *)this + 6);
  for (i = (uint64_t *)*((_QWORD *)this + 7); v4 != i; ++v4)
  {
    v6 = *v4;
    LODWORD(v13) = *(_DWORD *)(*v4 + 28);
    HIDWORD(v13) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 120))(v6);
    (*(void (**)(__int128 *__return_ptr, uint64_t))(*(_QWORD *)v6 + 48))(&__p, v6);
    (*(void (**)(__int128 *__return_ptr, uint64_t))(*(_QWORD *)v6 + 104))(&v16, v6);
    LODWORD(v18) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 136))(v6);
    DWORD1(v18) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 152))(v6);
    DWORD2(v18) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 168))(v6);
    *(_QWORD *)&v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 160))(v6);
    *((_QWORD *)&v19 + 1) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 176))(v6);
    v7 = *(_QWORD *)(a2 + 8);
    if (v7 >= *(_QWORD *)(a2 + 16))
    {
      v11 = std::vector<webrtc::DataChannelStats>::__push_back_slow_path<webrtc::DataChannelStats>((char **)a2, (uint64_t)&v13);
      v12 = SHIBYTE(v17);
      *(_QWORD *)(a2 + 8) = v11;
      if (v12 < 0)
      {
        operator delete((void *)v16);
        if ((SHIBYTE(v15) & 0x80000000) == 0)
          continue;
LABEL_10:
        operator delete((void *)__p);
        continue;
      }
      if (SHIBYTE(v15) < 0)
        goto LABEL_10;
    }
    else
    {
      if (!v7)
      {
        __break(1u);
        return;
      }
      *(_QWORD *)v7 = v13;
      v8 = __p;
      *(_QWORD *)(v7 + 24) = v15;
      *(_OWORD *)(v7 + 8) = v8;
      v15 = 0;
      __p = 0uLL;
      v9 = v17;
      *(_OWORD *)(v7 + 32) = v16;
      *(_QWORD *)(v7 + 48) = v9;
      v17 = 0;
      v16 = 0uLL;
      v10 = v19;
      *(_OWORD *)(v7 + 56) = v18;
      *(_OWORD *)(v7 + 72) = v10;
      *(_QWORD *)(a2 + 8) = v7 + 88;
      if (SHIBYTE(v15) < 0)
        goto LABEL_10;
    }
  }
}

void std::vector<webrtc::DataChannelStats>::reserve(uint64_t a1, unint64_t a2)
{
  void **v2;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  void **v14;

  v2 = *(void ***)a1;
  if (0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) < a2)
  {
    if (a2 >= 0x2E8BA2E8BA2E8BBLL)
      abort();
    v4 = *(_QWORD *)(a1 + 8);
    v5 = 88 * a2;
    v6 = (char *)operator new(88 * a2);
    v7 = &v6[v5];
    v8 = &v6[v4 - (_QWORD)v2];
    if ((void **)v4 != v2)
    {
      v9 = &v6[v4 - (_QWORD)v2];
      do
      {
        v10 = *(_QWORD *)(v4 - 88);
        v4 -= 88;
        *((_QWORD *)v9 - 11) = v10;
        v9 -= 88;
        v11 = *(_OWORD *)(v4 + 8);
        *((_QWORD *)v9 + 3) = *(_QWORD *)(v4 + 24);
        *(_OWORD *)(v9 + 8) = v11;
        *(_QWORD *)(v4 + 16) = 0;
        *(_QWORD *)(v4 + 24) = 0;
        *(_QWORD *)(v4 + 8) = 0;
        v12 = *(_OWORD *)(v4 + 32);
        *((_QWORD *)v9 + 6) = *(_QWORD *)(v4 + 48);
        *((_OWORD *)v9 + 2) = v12;
        *(_QWORD *)(v4 + 40) = 0;
        *(_QWORD *)(v4 + 48) = 0;
        *(_QWORD *)(v4 + 32) = 0;
        v13 = *(_OWORD *)(v4 + 56);
        *(_OWORD *)(v9 + 72) = *(_OWORD *)(v4 + 72);
        *(_OWORD *)(v9 + 56) = v13;
      }
      while ((void **)v4 != v2);
      v2 = *(void ***)a1;
      v14 = *(void ***)(a1 + 8);
      *(_QWORD *)a1 = v9;
      *(_QWORD *)(a1 + 8) = v8;
      *(_QWORD *)(a1 + 16) = v7;
      while (1)
      {
        if (v14 == v2)
          goto LABEL_15;
        if (*((char *)v14 - 33) < 0)
        {
          operator delete(*(v14 - 7));
          if ((*((char *)v14 - 57) & 0x80000000) == 0)
            goto LABEL_7;
        }
        else if ((*((char *)v14 - 57) & 0x80000000) == 0)
        {
          goto LABEL_7;
        }
        operator delete(*(v14 - 10));
LABEL_7:
        v14 -= 11;
      }
    }
    *(_QWORD *)a1 = v8;
    *(_QWORD *)(a1 + 8) = v8;
    *(_QWORD *)(a1 + 16) = v7;
LABEL_15:
    if (v2)
      operator delete(v2);
  }
}

void webrtc::DataChannelController::CreateDataChannel(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t Sid;
  unsigned int v13;
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  unint64_t v16;
  unint64_t v17;
  unsigned __int16 *v18;
  unsigned __int16 *v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  _QWORD *v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  __int128 *v36;
  _BOOL4 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int *v44;
  unsigned int v45;
  unint64_t v46;
  uint64_t *v47;
  _QWORD *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  char *v56;
  uint64_t *v57;
  char *v58;
  char *v59;
  char *v60;
  unint64_t v61;
  BOOL v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  char *v66;
  char *v67;
  uint64_t v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  char v75;
  uint64_t v76;
  char *v77;
  void *__p[4];
  __int128 v79;

  v8 = *(_DWORD *)(a4 + 52);
  if (v8 != -1)
  {
    if (v8 >= 0x400)
    {
      HIBYTE(__p[2]) = 22;
      if (__p > (void **)"StreamId out of range." || (char *)&__p[2] + 6 <= "StreamId out of range.")
      {
        strcpy((char *)__p, "StreamId out of range.");
        LODWORD(__p[3]) = 0;
        BYTE4(__p[3]) = 0;
        BYTE6(__p[3]) = 0;
        *(_DWORD *)a1 = 4;
        *(_OWORD *)(a1 + 8) = *(_OWORD *)__p;
        *(void **)(a1 + 24) = __p[2];
        *(_DWORD *)(a1 + 32) = 0;
LABEL_44:
        *(_DWORD *)(a1 + 35) = *(_DWORD *)((char *)&__p[3] + 3);
        *(_BYTE *)(a1 + 40) = 0;
        *(_BYTE *)(a1 + 48) = 0;
        return;
      }
      goto LABEL_88;
    }
    v13 = (unsigned __int16)*(_DWORD *)(a4 + 52);
    LOWORD(v79) = *(_DWORD *)(a4 + 52);
    v14 = *(unsigned __int16 **)(a2 + 24);
    v15 = *(unsigned __int16 **)(a2 + 32);
    if (v15 == v14)
    {
      v14 = *(unsigned __int16 **)(a2 + 32);
LABEL_21:
      std::vector<webrtc::StreamId>::emplace<webrtc::StreamId const&>((void **)(a2 + 24), v14, (__int16 *)&v79);
LABEL_22:
      v75 = 0;
      BYTE6(__p[3]) = 0;
      memset(__p, 0, 29);
      *(_DWORD *)(a4 + 52) = v13;
      v22 = *(_QWORD *)(a2 + 88);
      if (!v22)
        goto LABEL_24;
      goto LABEL_23;
    }
    v16 = v15 - v14;
    do
    {
      v17 = v16 >> 1;
      v18 = &v14[v16 >> 1];
      v20 = *v18;
      v19 = v18 + 1;
      v16 += ~(v16 >> 1);
      if (v20 < v13)
        v14 = v19;
      else
        v16 = v17;
    }
    while (v16);
    if (v14 == v15 || *v14 > v13)
      goto LABEL_21;
    HIBYTE(__p[2]) = 18;
    if (__p <= (void **)"StreamId reserved." && (char *)&__p[2] + 2 > "StreamId reserved.")
      goto LABEL_88;
    strcpy((char *)__p, "StreamId reserved.");
    LODWORD(__p[3]) = 0;
    BYTE4(__p[3]) = 0;
    BYTE6(__p[3]) = 0;
    v21 = 4;
LABEL_43:
    *(_DWORD *)a1 = v21;
    *(_OWORD *)(a1 + 8) = *(_OWORD *)__p;
    *(void **)(a1 + 24) = __p[2];
    *(_DWORD *)(a1 + 32) = __p[3];
    goto LABEL_44;
  }
  v9 = *(_QWORD *)(a4 + 68);
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 8) + 152))(*(_QWORD *)(a2 + 80) + 8);
  v11 = v10;
  if ((v10 & 0xFF00000000) != 0 || (v11 = v9, (v9 & 0xFF00000000) != 0))
  {
    Sid = webrtc::SctpSidAllocator::AllocateSid((unsigned __int16 **)(a2 + 24), v11);
    if ((Sid & 0xFF0000) != 0)
    {
      v13 = (unsigned __int16)Sid;
      goto LABEL_22;
    }
    BYTE6(__p[3]) = 0;
    memset(__p, 0, 29);
    v21 = 9;
    goto LABEL_43;
  }
  v13 = 0;
  BYTE6(__p[3]) = 0;
  memset(__p, 0, 29);
  v75 = 1;
  v22 = *(_QWORD *)(a2 + 88);
  if (!v22)
  {
LABEL_24:
    v24 = (_QWORD *)operator new();
    *v24 = 1;
    v25 = (unsigned int *)v24 + 1;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
    v27 = *(_QWORD *)(a2 + 88);
    if (v27)
    {
      v28 = (unsigned int *)(v27 + 4);
      do
      {
        v29 = __ldaxr(v28);
        v30 = v29 - 1;
      }
      while (__stlxr(v30, v28));
      if (!v30)
        MEMORY[0x20BD0ADEC]();
    }
    *(_QWORD *)(a2 + 88) = v24;
    goto LABEL_33;
  }
LABEL_23:
  v23 = atomic_load((unsigned int *)(v22 + 4));
  if (v23 == 1)
    goto LABEL_24;
  v24 = *(_QWORD **)(a2 + 88);
  if (!v24)
  {
    v36 = a3;
    v76 = *(_QWORD *)(a2 + 96);
    goto LABEL_46;
  }
LABEL_33:
  v31 = (unsigned int *)v24 + 1;
  do
    v32 = __ldxr(v31);
  while (__stxr(v32 + 1, v31));
  v76 = *(_QWORD *)(a2 + 96);
  do
    v33 = __ldxr(v31);
  while (__stxr(v33 + 1, v31));
  do
  {
    v34 = __ldaxr(v31);
    v35 = v34 - 1;
  }
  while (__stlxr(v35, v31));
  v36 = a3;
  if (!v35)
    MEMORY[0x20BD0ADEC](v24, 0x1000C404A09149ALL);
LABEL_46:
  v37 = *(_QWORD *)(a2 + 16) != 0;
  v38 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 80) + 512))(*(_QWORD *)(a2 + 80));
  v39 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 80) + 520))(*(_QWORD *)(a2 + 80));
  v40 = operator new();
  *(_QWORD *)&v79 = v24;
  *((_QWORD *)&v79 + 1) = v76;
  webrtc::SctpDataChannel::SctpDataChannel(v40, a4, &v79, v36, v37, v38, v39);
  if ((_QWORD)v79)
  {
    v41 = (unsigned int *)(v79 + 4);
    do
    {
      v42 = __ldaxr(v41);
      v43 = v42 - 1;
    }
    while (__stlxr(v43, v41));
    if (!v43)
      MEMORY[0x20BD0ADEC]();
  }
  *(_QWORD *)v40 = &unk_24C0BFDA8;
  v44 = (unsigned int *)(v40 + 304);
  *(_DWORD *)(v40 + 304) = 0;
  do
    v45 = __ldxr(v44);
  while (__stxr(v45 + 1, v44));
  v47 = *(uint64_t **)(a2 + 56);
  v46 = *(_QWORD *)(a2 + 64);
  if ((unint64_t)v47 >= v46)
  {
    v49 = *(_QWORD *)(a2 + 48);
    v50 = (char *)v47 - v49;
    v51 = ((uint64_t)v47 - v49) >> 3;
    if ((unint64_t)(v51 + 1) >> 61)
      goto LABEL_89;
    v52 = v46 - v49;
    v53 = v52 >> 2;
    if (v52 >> 2 <= (unint64_t)(v51 + 1))
      v53 = v51 + 1;
    v62 = (unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8;
    v54 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v62)
      v54 = v53;
    if (v54)
    {
      v77 = v50;
      if (v54 >> 61)
        std::__throw_bad_array_new_length[abi:sn180100]();
      v55 = 8 * v54;
      v56 = (char *)operator new(8 * v54);
      v57 = (uint64_t *)&v56[8 * v51];
      v58 = &v56[v55];
      *v57 = v40;
      v48 = v57 + 1;
      rtc::RefCountedObject<webrtc::SctpDataChannel>::AddRef(v40);
      v59 = *(char **)(a2 + 48);
      v60 = *(char **)(a2 + 56);
      if (v60 == v59)
      {
        *(_QWORD *)(a2 + 48) = v57;
        *(_QWORD *)(a2 + 56) = v48;
        *(_QWORD *)(a2 + 64) = v58;
      }
      else
      {
        v61 = v60 - v59 - 8;
        if (v61 < 0x78)
          goto LABEL_93;
        v62 = &v60[-(v61 & 0xFFFFFFFFFFFFFFF8) - 8] >= (char *)v57
           || &v77[(_QWORD)v56 - (v61 & 0xFFFFFFFFFFFFFFF8) - 8] >= v60;
        if (!v62)
          goto LABEL_93;
        v63 = (v61 >> 3) + 1;
        v64 = 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
        v65 = &v60[-v64];
        v57 = (uint64_t *)((char *)v57 - v64);
        v66 = &v56[8 * v51 - 16];
        v67 = v60 - 16;
        v68 = v63 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v70 = *((_OWORD *)v67 - 1);
          v69 = *(_OWORD *)v67;
          *((_OWORD *)v67 - 1) = 0uLL;
          *(_OWORD *)v67 = 0uLL;
          *((_OWORD *)v66 - 1) = v70;
          *(_OWORD *)v66 = v69;
          v66 -= 32;
          v67 -= 32;
          v68 -= 4;
        }
        while (v68);
        v60 = v65;
        if (v63 != (v63 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_93:
          do
          {
            v71 = *((_QWORD *)v60 - 1);
            v60 -= 8;
            *(_QWORD *)v60 = 0;
            *--v57 = v71;
          }
          while (v60 != v59);
        }
        v60 = *(char **)(a2 + 48);
        v72 = *(char **)(a2 + 56);
        *(_QWORD *)(a2 + 48) = v57;
        *(_QWORD *)(a2 + 56) = v48;
        *(_QWORD *)(a2 + 64) = v58;
        while (v72 != v60)
        {
          v74 = *((_QWORD *)v72 - 1);
          v72 -= 8;
          v73 = v74;
          if (v74)
            (*(void (**)(uint64_t))(*(_QWORD *)v73 + 8))(v73);
        }
      }
      if (v60)
        operator delete(v60);
      goto LABEL_81;
    }
LABEL_88:
    __break(1u);
LABEL_89:
    abort();
  }
  if (!v47)
    goto LABEL_88;
  *v47 = v40;
  v48 = v47 + 1;
  rtc::RefCountedObject<webrtc::SctpDataChannel>::AddRef(v40);
LABEL_81:
  *(_QWORD *)(a2 + 56) = v48;
  if ((v75 & 1) == 0)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 8))(a2, v13);
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 38) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 29) = 0;
  *(_QWORD *)(a1 + 40) = v40;
  *(_BYTE *)(a1 + 48) = 1;
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
}

void webrtc::DataChannelController::InternalCreateDataChannelWithProxy(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  unsigned int v21;
  _QWORD *v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int *v27;
  unsigned int v28;
  __int128 v29;
  char v30;
  _QWORD v31[4];
  int v32;
  void *__p;
  _BYTE v34[23];
  uint64_t v35;
  char v36;
  __int128 v37;
  char v38;
  std::string v39;
  _QWORD v40[3];
  char v41;
  char v42;
  _QWORD v43[2];

  if (*((int *)a3 + 13) < -1)
  {
LABEL_2:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
    {
      *(_QWORD *)&v37 = "INVALID_PARAMETER";
      *((_QWORD *)&v37 + 1) = 17;
      rtc::webrtc_logging_impl::Log("\r\t\t\v\t", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/data_channel_controller.cc");
    }
    v12 = (char *)operator new(0x19uLL);
    if (v12 > "Invalid DataChannelInit" || v12 + 23 <= "Invalid DataChannelInit")
    {
      strcpy(v12, "Invalid DataChannelInit");
      *(_DWORD *)a4 = 3;
      *(_QWORD *)(a4 + 8) = v12;
      *(_OWORD *)(a4 + 16) = xmmword_208F05110;
      *(_DWORD *)(a4 + 32) = 0;
      *(_BYTE *)(a4 + 36) = 0;
      *(_BYTE *)(a4 + 38) = 0;
      *(_BYTE *)(a4 + 40) = 0;
      *(_BYTE *)(a4 + 48) = 0;
      return;
    }
LABEL_37:
    __break(1u);
    return;
  }
  if (*((_BYTE *)a3 + 16))
  {
    if ((*((_DWORD *)a3 + 3) & 0x80000000) != 0 || *((_BYTE *)a3 + 8))
      goto LABEL_2;
  }
  else if (*((_BYTE *)a3 + 8) && (*((_DWORD *)a3 + 1) & 0x80000000) != 0)
  {
    goto LABEL_2;
  }
  v42 = 0;
  v37 = *a3;
  v38 = *((_BYTE *)a3 + 16);
  if (*((char *)a3 + 47) < 0)
    std::string::__init_copy_ctor_external(&v39, *((const std::string::value_type **)a3 + 3), *((_QWORD *)a3 + 4));
  else
    v39 = *(std::string *)((_BYTE *)a3 + 1);
  v40[0] = *((_QWORD *)a3 + 6);
  *(_QWORD *)((char *)v40 + 5) = *(_QWORD *)((char *)a3 + 53);
  v40[2] = *((_QWORD *)a3 + 8);
  v41 = *((_BYTE *)a3 + 72);
  v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 80) + 520))(*(_QWORD *)(a1 + 80));
  v31[0] = a1;
  v31[1] = a2;
  v31[2] = &v37;
  v31[3] = &v42;
  v32 = 10;
  v34[22] = 0;
  *(_QWORD *)v34 = 0;
  *(_QWORD *)&v34[8] = 0;
  __p = 0;
  *(_QWORD *)&v34[13] = 0;
  LOBYTE(v35) = 0;
  v36 = 0;
  v43[0] = &v32;
  v43[1] = v31;
  (*(void (**)(uint64_t, _QWORD *, void (*)(uint64_t *), char *))(*(_QWORD *)v16 + 96))(v16, v43, rtc::FunctionView<void ()(void)>::CallVoidPtr<webrtc::RTCErrorOr<webrtc::scoped_refptr<webrtc::SctpDataChannel>> rtc::Thread::BlockingCall<webrtc::DataChannelController::InternalCreateDataChannelWithProxy(std::string const&,webrtc::InternalDataChannelInit const&)::$_1,webrtc::RTCErrorOr<webrtc::scoped_refptr<webrtc::SctpDataChannel>>,void>(webrtc::DataChannelController::InternalCreateDataChannelWithProxy(std::string const&,webrtc::InternalDataChannelInit const&)::$_1 &&,webrtc::Location const&)::{lambda(void)#1}>, &v30);
  v17 = v32;
  if (v32)
  {
    v18 = *(_QWORD *)v34;
    *(_QWORD *)(a4 + 8) = __p;
    *(_QWORD *)(a4 + 16) = v18;
    *(_QWORD *)(a4 + 23) = *(_QWORD *)&v34[7];
    LOBYTE(v18) = v34[15];
    *(_QWORD *)v34 = 0;
    *(_QWORD *)&v34[8] = 0;
    __p = 0;
    *(_DWORD *)(a4 + 32) = *(_DWORD *)&v34[16];
    *(_DWORD *)(a4 + 35) = *(_DWORD *)&v34[19];
    *(_DWORD *)a4 = v17;
    *(_BYTE *)(a4 + 31) = v18;
    *(_BYTE *)(a4 + 40) = 0;
    *(_BYTE *)(a4 + 48) = 0;
    if (!v36)
      goto LABEL_32;
    goto LABEL_30;
  }
  *(_BYTE *)(a1 + 72) = 2;
  if (!v36)
    goto LABEL_37;
  v19 = v35;
  v35 = 0;
  v20 = *(unsigned int **)(a1 + 104);
  if (v20)
  {
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  v29 = *(_OWORD *)(v19 + 8);
  v22 = (_QWORD *)operator new();
  *v22 = &off_24C0BFD68;
  v22[1] = 0;
  v22[2] = v19;
  v22[3] = *(_QWORD *)(v19 + 8);
  v23 = operator new();
  *(_DWORD *)v23 = 0;
  *(_BYTE *)(v23 + 4) = 1;
  v22[4] = v23;
  do
    v24 = __ldxr((unsigned int *)v23);
  while (__stxr(v24 + 1, (unsigned int *)v23));
  v22[5] = v20;
  v22[6] = 0;
  v25 = *(_QWORD *)(v19 + 128);
  *(_QWORD *)(v19 + 128) = v22;
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 40))(v25);
  v26 = operator new();
  *(_OWORD *)(v26 + 8) = v29;
  *(_QWORD *)(v26 + 24) = v19;
  *(_QWORD *)v26 = off_24C0BFE98;
  *(_DWORD *)(v26 + 32) = 0;
  v27 = (unsigned int *)(v26 + 32);
  do
    v28 = __ldxr(v27);
  while (__stxr(v28 + 1, v27));
  *(_DWORD *)a4 = 0;
  *(_BYTE *)(a4 + 38) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 29) = 0;
  *(_QWORD *)(a4 + 40) = v26;
  *(_BYTE *)(a4 + 48) = 1;
  if (v36)
  {
LABEL_30:
    if (v35)
      (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
  }
LABEL_32:
  if ((v34[15] & 0x80000000) != 0)
  {
    operator delete(__p);
    if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
LABEL_36:
      operator delete(v39.__r_.__value_.__l.__data_);
  }
  else if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
  {
    goto LABEL_36;
  }
}

void webrtc::DataChannelController::AllocateSctpSids(unsigned __int16 **a1, uint64_t a2)
{
  unsigned __int16 **v3;
  unsigned __int16 *v4;
  webrtc::SctpDataChannel **v5;
  char *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  unsigned __int16 **v10;
  uint64_t Sid;
  webrtc::SctpDataChannel *v12;
  uint64_t *v13;
  unsigned __int16 **v14;
  unsigned __int16 **v15;
  uint64_t v16;
  int64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t *v23;
  webrtc::SctpDataChannel *v24;
  uint64_t *v25;
  int64_t v26;
  unint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  webrtc::SctpDataChannel **v34;
  webrtc::SctpDataChannel **v35;
  webrtc::SctpDataChannel **v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t *v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  webrtc::SctpDataChannel *v49;
  webrtc::SctpDataChannel *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  webrtc::SctpDataChannel *v58;
  uint64_t v59;
  unint64_t v60;
  unsigned __int16 **v61;
  uint64_t v62;
  char *v63;
  webrtc::SctpDataChannel **v64;
  char *v65;
  char *v66;
  char *v67;
  char *v68;
  uint64_t *v69;
  uint64_t v70;
  char *v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  int v76;
  char *v77;
  char *__p;
  char *v79;
  uint64_t v80;
  uint64_t *v81;
  void *__src;
  __int128 v83;

  v3 = a1;
  v4 = a1[2];
  if (v4)
  {
    v76 = (*(uint64_t (**)(unsigned __int16 *))(*(_QWORD *)v4 + 48))(v4);
    v5 = (webrtc::SctpDataChannel **)v3[6];
    if (v5 == (webrtc::SctpDataChannel **)v3[7])
      return;
  }
  else
  {
    v76 = 0;
    v5 = (webrtc::SctpDataChannel **)v3[6];
    if (v5 == (webrtc::SctpDataChannel **)v3[7])
      return;
  }
  v77 = 0;
  __p = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = v3 + 3;
  while (2)
  {
    v79 = v6;
    while (1)
    {
      if (*((_BYTE *)*v5 + 26))
        goto LABEL_7;
      Sid = webrtc::SctpSidAllocator::AllocateSid(v10, a2);
      if ((Sid & 0xFF0000) != 0)
        break;
      if (v8 < v9)
      {
        if (!v8)
          goto LABEL_97;
        v12 = *v5;
        *v5 = 0;
        *v8++ = (uint64_t)v12;
        goto LABEL_32;
      }
      v13 = v9;
      v14 = v10;
      v15 = v3;
      v16 = a2;
      v17 = (char *)v8 - (char *)v7;
      v18 = v8 - v7;
      v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) >> 61)
        goto LABEL_98;
      v20 = (char *)v13 - (char *)v7;
      v21 = ((char *)v13 - (char *)v7) >> 2;
      if (v21 > v19)
        v19 = v21;
      if (v20 >= 0x7FFFFFFFFFFFFFF8)
        v19 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v19)
        goto LABEL_97;
      if (v19 >> 61)
        goto LABEL_99;
      v80 = 8 * v19;
      v22 = (char *)operator new(8 * v19);
      v23 = (uint64_t *)&v22[8 * v18];
      v24 = *v5;
      *v5 = 0;
      *v23 = (uint64_t)v24;
      v25 = v23 + 1;
      v26 = (char *)v8 - (char *)v7;
      if (v8 == v7)
      {
        a2 = v16;
        v3 = v15;
        v10 = v14;
        v6 = v79;
        v9 = (uint64_t *)&v22[v80];
        if (!v7)
          goto LABEL_31;
        goto LABEL_30;
      }
      v27 = v26 - 8;
      if ((unint64_t)(v26 - 8) >= 0x138)
      {
        v40 = (char *)(v8 - 1) - (char *)v7;
        if ((uint64_t *)((char *)v8 - (v40 & 0xFFFFFFFFFFFFFFF8) - 8) > v8 - 1)
        {
          v28 = v8;
        }
        else if (&v22[v17 - 8 - (v40 & 0xFFFFFFFFFFFFFFF8)] > &v22[v17 - 8])
        {
          v28 = v8;
        }
        else
        {
          v41 = v40 & 0xFFFFFFFFFFFFFFF8;
          if ((uint64_t *)((char *)v8 - v41 - 8) >= v23 || (v28 = v8, &v22[v17 - v41 - 8] >= (char *)v8))
          {
            v42 = (v27 >> 3) + 1;
            v43 = 8 * (v42 & 0x3FFFFFFFFFFFFFFCLL);
            v28 = &v8[v43 / 0xFFFFFFFFFFFFFFF8];
            v23 = (uint64_t *)((char *)v23 - v43);
            v44 = &v22[8 * v18 - 16];
            v45 = v8 - 2;
            v46 = v42 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v48 = *((_OWORD *)v45 - 1);
              v47 = *(_OWORD *)v45;
              *((_OWORD *)v45 - 1) = 0uLL;
              *(_OWORD *)v45 = 0uLL;
              *((_OWORD *)v44 - 1) = v48;
              *(_OWORD *)v44 = v47;
              v44 -= 32;
              v45 -= 4;
              v46 -= 4;
            }
            while (v46);
            if (v42 == (v42 & 0x3FFFFFFFFFFFFFFCLL))
              goto LABEL_25;
          }
        }
      }
      else
      {
        v28 = v8;
      }
      do
      {
        v29 = *--v28;
        *v28 = 0;
        *--v23 = v29;
      }
      while (v28 != v7);
LABEL_25:
      v30 = v22;
      v3 = v15;
      v10 = v14;
      do
      {
        v32 = *--v8;
        v31 = v32;
        if (v32)
          (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
      }
      while (v8 != v7);
      v33 = v30;
      a2 = v16;
      v6 = v79;
      v9 = (uint64_t *)&v33[v80];
      if (!v7)
        goto LABEL_31;
LABEL_30:
      operator delete(v7);
LABEL_31:
      v7 = v23;
      v8 = v25;
LABEL_32:
      v34 = (webrtc::SctpDataChannel **)v3[7];
      if (v34 == v5)
        goto LABEL_97;
      v35 = v5 + 1;
      if (v5 + 1 == v34)
      {
        v36 = v5;
      }
      else
      {
        do
        {
          v37 = (uint64_t)*(v35 - 1);
          *(v35 - 1) = *v35;
          *v35 = 0;
          if (v37)
            (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
          ++v35;
        }
        while (v35 != v34);
        v34 = (webrtc::SctpDataChannel **)v3[7];
        v36 = v35 - 1;
      }
      while (v34 != v36)
      {
        v39 = (uint64_t)*--v34;
        v38 = v39;
        if (v39)
          (*(void (**)(uint64_t))(*(_QWORD *)v38 + 8))(v38);
      }
      v3[7] = (unsigned __int16 *)v36;
      if (v36 == v5)
        goto LABEL_79;
    }
    v49 = *v5;
    if (!*((_BYTE *)*v5 + 26))
      *((_BYTE *)v49 + 26) = 1;
    v50 = (webrtc::SctpDataChannel *)(unsigned __int16)Sid;
    *((_WORD *)v49 + 12) = Sid;
    (*((void (**)(unsigned __int16 **, _QWORD))*v3 + 1))(v3, (unsigned __int16)Sid);
    if (v76)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        v75 = v75 & 0xFFFFFFFF00000000 | 0xD09;
        rtc::webrtc_logging_impl::Log("\r\t", v51, v52, v53, v54, v55, v56, v57, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/data_channel_controller.cc");
      }
      webrtc::SctpDataChannel::UpdateState(*v5);
    }
    v58 = *v5;
    if (v79 >= v77)
    {
      v59 = (v79 - __p) >> 4;
      v60 = v59 + 1;
      if (!((unint64_t)(v59 + 1) >> 60))
      {
        v81 = v9;
        if ((v77 - __p) >> 3 > v60)
          v60 = (v77 - __p) >> 3;
        if ((unint64_t)(v77 - __p) >= 0x7FFFFFFFFFFFFFF0)
          v60 = 0xFFFFFFFFFFFFFFFLL;
        if (v60)
        {
          if (v60 >> 60)
LABEL_99:
            std::__throw_bad_array_new_length[abi:sn180100]();
          v61 = v10;
          v62 = 16 * v60;
          v63 = (char *)operator new(16 * v60);
          v64 = (webrtc::SctpDataChannel **)&v63[16 * v59];
          *v64 = v58;
          v64[1] = v50;
          v65 = v79;
          if (v79 == __p)
          {
            v68 = &v63[16 * v59];
            v67 = __p;
            v77 = &v63[v62];
            v6 = (char *)(v64 + 2);
            if (!__p)
            {
LABEL_6:
              __p = v68;
              v10 = v61;
              v9 = v81;
              goto LABEL_7;
            }
          }
          else
          {
            v66 = &v63[16 * v59];
            v67 = __p;
            do
            {
              v68 = v66 - 16;
              *((_OWORD *)v66 - 1) = *((_OWORD *)v65 - 1);
              v65 -= 16;
              v66 -= 16;
            }
            while (v65 != __p);
            v77 = &v63[v62];
            v6 = (char *)(v64 + 2);
            if (!__p)
              goto LABEL_6;
          }
          operator delete(v67);
          goto LABEL_6;
        }
LABEL_97:
        __break(1u);
      }
LABEL_98:
      abort();
    }
    if (!v79)
      goto LABEL_97;
    *(_QWORD *)v79 = v58;
    *((_QWORD *)v79 + 1) = v50;
    v6 = v79 + 16;
LABEL_7:
    if (++v5 != (webrtc::SctpDataChannel **)v3[7])
      continue;
    break;
  }
LABEL_79:
  if (v7 == v8)
  {
    v72 = __p;
    if (!v8)
      goto LABEL_94;
LABEL_93:
    operator delete(v7);
    goto LABEL_94;
  }
  v69 = v7;
  do
  {
    while (1)
    {
      v70 = *v69;
      v71 = (char *)operator new(0x20uLL);
      __src = v71;
      v83 = xmmword_208F051A0;
      if (v71 <= "Failed to allocate SCTP SID" && v71 + 27 > "Failed to allocate SCTP SID")
        goto LABEL_97;
      strcpy(v71, "Failed to allocate SCTP SID");
      webrtc::SctpDataChannel::CloseAbruptlyWithDataChannelFailure(v70, (char *)&__src);
      if (SHIBYTE(v83) < 0)
        break;
      if (++v69 == v8)
        goto LABEL_87;
    }
    operator delete(__src);
    ++v69;
  }
  while (v69 != v8);
LABEL_87:
  v72 = __p;
  if (v7)
  {
    do
    {
      v74 = *--v8;
      v73 = v74;
      if (v74)
        (*(void (**)(uint64_t))(*(_QWORD *)v73 + 8))(v73);
    }
    while (v8 != v7);
    goto LABEL_93;
  }
LABEL_94:
  if (v72)
    operator delete(v72);
}

char *std::vector<webrtc::DataChannelStats>::__push_back_slow_path<webrtc::DataChannelStats>(char **a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v5;
  uint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  __int128 v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  char *v19;

  v2 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x2E8BA2E8BA2E8BALL)
    abort();
  if (0x5D1745D1745D1746 * ((a1[2] - *a1) >> 3) > v3)
    v3 = 0x5D1745D1745D1746 * ((a1[2] - *a1) >> 3);
  if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((a1[2] - *a1) >> 3)) >= 0x1745D1745D1745DLL)
    v5 = 0x2E8BA2E8BA2E8BALL;
  else
    v5 = v3;
  if (!v5)
  {
    __break(1u);
LABEL_25:
    std::__throw_bad_array_new_length[abi:sn180100]();
  }
  if (v5 > 0x2E8BA2E8BA2E8BALL)
    goto LABEL_25;
  v7 = 88 * v5;
  v8 = (char *)operator new(88 * v5);
  v9 = &v8[88 * v2];
  *(_QWORD *)v9 = *(_QWORD *)a2;
  v10 = &v8[v7];
  *(_OWORD *)(v9 + 8) = *(_OWORD *)(a2 + 8);
  *((_QWORD *)v9 + 3) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *((_OWORD *)v9 + 2) = *(_OWORD *)(a2 + 32);
  *((_QWORD *)v9 + 6) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  v11 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(v9 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(v9 + 56) = v11;
  v12 = v9 + 88;
  v13 = *a1;
  v14 = a1[1];
  if (v14 != *a1)
  {
    do
    {
      v15 = *((_QWORD *)v14 - 11);
      v14 -= 88;
      *((_QWORD *)v9 - 11) = v15;
      v9 -= 88;
      v16 = *(_OWORD *)(v14 + 8);
      *((_QWORD *)v9 + 3) = *((_QWORD *)v14 + 3);
      *(_OWORD *)(v9 + 8) = v16;
      *((_QWORD *)v14 + 2) = 0;
      *((_QWORD *)v14 + 3) = 0;
      *((_QWORD *)v14 + 1) = 0;
      v17 = *((_OWORD *)v14 + 2);
      *((_QWORD *)v9 + 6) = *((_QWORD *)v14 + 6);
      *((_OWORD *)v9 + 2) = v17;
      *((_QWORD *)v14 + 5) = 0;
      *((_QWORD *)v14 + 6) = 0;
      *((_QWORD *)v14 + 4) = 0;
      v18 = *(_OWORD *)(v14 + 56);
      *(_OWORD *)(v9 + 72) = *(_OWORD *)(v14 + 72);
      *(_OWORD *)(v9 + 56) = v18;
    }
    while (v14 != v13);
    v14 = *a1;
    v19 = a1[1];
    *a1 = v9;
    a1[1] = v12;
    a1[2] = v10;
    while (1)
    {
      if (v19 == v14)
        goto LABEL_20;
      if (*(v19 - 33) < 0)
      {
        operator delete(*((void **)v19 - 7));
        if ((*(v19 - 57) & 0x80000000) == 0)
          goto LABEL_12;
      }
      else if ((*(v19 - 57) & 0x80000000) == 0)
      {
        goto LABEL_12;
      }
      operator delete(*((void **)v19 - 10));
LABEL_12:
      v19 -= 88;
    }
  }
  *a1 = v9;
  a1[1] = v12;
  a1[2] = v10;
LABEL_20:
  if (v14)
    operator delete(v14);
  return v12;
}

uint64_t absl::internal_any_invocable::RemoteInvoker<false,void,webrtc::DataChannelController::OnChannelStateChanged(webrtc::SctpDataChannel *,webrtc::DataChannelInterface::DataState)::$_1 &&>(uint64_t **a1)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = *a1;
  v2 = **a1;
  *(_BYTE *)(v2 + 72) = *((_BYTE *)*a1 + 16);
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(v2 + 80) + 640))(*(_QWORD *)(v2 + 80), *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 3));
}

uint64_t absl::internal_any_invocable::RemoteInvoker<false,void,webrtc::DataChannelController::HandleOpenMessage_n(int,webrtc::DataMessageType,rtc::CopyOnWriteBuffer const&)::$_0 &&>(uint64_t **a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned int *v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  __int128 v17;
  char v18;
  uint64_t v19;
  char v20;
  _QWORD v21[2];
  uint64_t (*v22)(char, uint64_t *, uint64_t *);
  void (*v23)(webrtc::SctpDataChannel **);

  v1 = *a1;
  v3 = **a1;
  v2 = (*a1)[1];
  if (v2)
  {
    (**(void (***)(uint64_t))v2)((*a1)[1]);
    v4 = *((unsigned __int8 *)v1 + 16);
    *(_BYTE *)(v3 + 72) = 2;
    (**(void (***)(uint64_t))v2)(v2);
    v5 = *(unsigned int **)(v3 + 104);
    if (!v5)
      goto LABEL_4;
  }
  else
  {
    v4 = *((unsigned __int8 *)v1 + 16);
    *(_BYTE *)(v3 + 72) = 2;
    v5 = *(unsigned int **)(v3 + 104);
    if (!v5)
      goto LABEL_4;
  }
  do
    v6 = __ldxr(v5);
  while (__stxr(v6 + 1, v5));
LABEL_4:
  v17 = *(_OWORD *)(v2 + 8);
  v7 = (_QWORD *)operator new();
  *v7 = &off_24C0BFD68;
  v7[1] = 0;
  v7[2] = v2;
  v7[3] = *(_QWORD *)(v2 + 8);
  v8 = operator new();
  *(_DWORD *)v8 = 0;
  *(_BYTE *)(v8 + 4) = 1;
  v7[4] = v8;
  do
    v9 = __ldxr((unsigned int *)v8);
  while (__stxr(v9 + 1, (unsigned int *)v8));
  v7[5] = v5;
  v7[6] = 0;
  v10 = *(_QWORD *)(v2 + 128);
  *(_QWORD *)(v2 + 128) = v7;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
  v11 = operator new();
  *(_OWORD *)(v11 + 8) = v17;
  *(_QWORD *)(v11 + 24) = v2;
  *(_QWORD *)v11 = off_24C0BFE98;
  *(_DWORD *)(v11 + 32) = 0;
  v12 = (unsigned int *)(v11 + 32);
  do
    v13 = __ldxr(v12);
  while (__stxr(v13 + 1, v12));
  v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 8) + 144))(*(_QWORD *)(v3 + 80) + 8);
  v19 = v11;
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v14 + 40))(v14, &v19);
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  (*(void (**)(_QWORD))(**(_QWORD **)(v3 + 80) + 632))(*(_QWORD *)(v3 + 80));
  if (v4)
  {
    v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 80) + 520))(*(_QWORD *)(v3 + 80));
    v21[0] = v2;
    v22 = absl::internal_any_invocable::LocalManagerNontrivial<webrtc::DataChannelController::OnDataChannelOpenMessage(webrtc::scoped_refptr<webrtc::SctpDataChannel>,BOOL)::$_0>;
    v23 = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DataChannelController::OnDataChannelOpenMessage(webrtc::scoped_refptr<webrtc::SctpDataChannel>,BOOL)::$_0 &&>;
    (*(void (**)(uint64_t, _QWORD *, char *, char *))(*(_QWORD *)v15 + 8))(v15, v21, &v20, &v18);
    v22(1, v21, v21);
    v2 = 0;
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  if (v2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return result;
}

uint64_t absl::internal_any_invocable::RemoteManagerNontrivial<webrtc::DataChannelController::HandleOpenMessage_n(int,webrtc::DataMessageType,rtc::CopyOnWriteBuffer const&)::$_0>(uint64_t result, uint64_t *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *a2;
  if ((result & 1) != 0)
  {
    if (v3)
    {
      v4 = *(_QWORD *)(v3 + 8);
      if (v4)
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    *a3 = v3;
  }
  return result;
}

void absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DataChannelController::OnDataChannelOpenMessage(webrtc::scoped_refptr<webrtc::SctpDataChannel>,BOOL)::$_0 &&>(webrtc::SctpDataChannel **a1)
{
  if ((*(unsigned int (**)(webrtc::SctpDataChannel *))(*(_QWORD *)*a1 + 136))(*a1) != 3)
    webrtc::SctpDataChannel::UpdateState(*a1);
}

uint64_t absl::internal_any_invocable::LocalManagerNontrivial<webrtc::DataChannelController::OnDataChannelOpenMessage(webrtc::scoped_refptr<webrtc::SctpDataChannel>,BOOL)::$_0>(char a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t result;

  if ((a1 & 1) == 0)
  {
    v3 = *a2;
    *a2 = 0;
    *a3 = v3;
  }
  result = *a2;
  if (*a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void rtc::FunctionView<void ()(void)>::CallVoidPtr<webrtc::RTCErrorOr<webrtc::scoped_refptr<webrtc::SctpDataChannel>> rtc::Thread::BlockingCall<webrtc::DataChannelController::InternalCreateDataChannelWithProxy(std::string const&,webrtc::InternalDataChannelInit const&)::$_1,webrtc::RTCErrorOr<webrtc::scoped_refptr<webrtc::SctpDataChannel>>,void>(webrtc::DataChannelController::InternalCreateDataChannelWithProxy(std::string const&,webrtc::InternalDataChannelInit const&)::$_1 &&,webrtc::Location const&)::{lambda(void)#1}>(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  void **v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  __int128 v18;
  uint64_t v19;
  _DWORD v20[2];
  uint64_t v21;
  unsigned __int8 v22;
  char v23;
  char v24;
  _QWORD v25[2];
  uint64_t (*v26)(char, uint64_t *, uint64_t *);
  void (*v27)(webrtc::SctpDataChannel **);

  v2 = a1[1];
  v3 = *(_QWORD *)v2;
  webrtc::DataChannelController::CreateDataChannel((uint64_t)&v17, *(_QWORD *)v2, *(__int128 **)(v2 + 8), *(_QWORD *)(v2 + 16));
  v4 = v17;
  if (!v17)
  {
    v11 = *(_QWORD *)(v3 + 16);
    if (v11)
    {
      v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 48))(v11);
      **(_BYTE **)(v2 + 24) = v12;
      if (v12)
      {
        v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 80) + 520))(*(_QWORD *)(v3 + 80));
        if (!v22)
        {
          __break(1u);
          return;
        }
        v14 = v13;
        v15 = v21;
        if (v21)
          (**(void (***)(uint64_t))v21)(v21);
        v25[0] = v15;
        v26 = absl::internal_any_invocable::LocalManagerNontrivial<webrtc::DataChannelController::InternalCreateDataChannelWithProxy(std::string const&,webrtc::InternalDataChannelInit const&)::$_1::operator() const(void)::{lambda(void)#2}>;
        v27 = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DataChannelController::InternalCreateDataChannelWithProxy(std::string const&,webrtc::InternalDataChannelInit const&)::$_1::operator() const(void)::{lambda(void)#2} &&>;
        (*(void (**)(uint64_t, _QWORD *, char *, char *))(*(_QWORD *)v14 + 8))(v14, v25, &v24, &v23);
        v26(1, v25, v25);
      }
    }
    else
    {
      **(_BYTE **)(v2 + 24) = 0;
    }
  }
  v5 = *a1;
  *(_DWORD *)v5 = v4;
  v6 = (void **)(v5 + 8);
  if (*(char *)(v5 + 31) < 0)
    operator delete(*v6);
  *(_OWORD *)v6 = v18;
  *(_QWORD *)(v5 + 24) = v19;
  *(_DWORD *)(v5 + 32) = v20[0];
  *(_DWORD *)(v5 + 35) = *(_DWORD *)((char *)v20 + 3);
  v7 = v22;
  if (*(unsigned __int8 *)(v5 + 48) != v22)
  {
    if (!*(_BYTE *)(v5 + 48))
    {
      v16 = v21;
      v21 = 0;
      *(_QWORD *)(v5 + 40) = v16;
      *(_BYTE *)(v5 + 48) = 1;
      if (!v7)
        return;
      goto LABEL_14;
    }
    v10 = *(_QWORD *)(v5 + 40);
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
    *(_BYTE *)(v5 + 48) = 0;
    goto LABEL_13;
  }
  if (!*(_BYTE *)(v5 + 48) || (v8 = v21, v21 = 0, v9 = *(_QWORD *)(v5 + 40), *(_QWORD *)(v5 + 40) = v8, !v9))
  {
LABEL_13:
    if (!v7)
      return;
    goto LABEL_14;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  if (!v7)
    return;
LABEL_14:
  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
}

void absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DataChannelController::InternalCreateDataChannelWithProxy(std::string const&,webrtc::InternalDataChannelInit const&)::$_1::operator() const(void)::{lambda(void)#2} &&>(webrtc::SctpDataChannel **a1)
{
  if ((*(unsigned int (**)(webrtc::SctpDataChannel *))(*(_QWORD *)*a1 + 136))(*a1) != 3)
    webrtc::SctpDataChannel::UpdateState(*a1);
}

uint64_t absl::internal_any_invocable::LocalManagerNontrivial<webrtc::DataChannelController::InternalCreateDataChannelWithProxy(std::string const&,webrtc::InternalDataChannelInit const&)::$_1::operator() const(void)::{lambda(void)#2}>(char a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t result;

  if ((a1 & 1) == 0)
  {
    v3 = *a2;
    *a2 = 0;
    *a3 = v3;
  }
  result = *a2;
  if (*a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t webrtc::DataChannelInterface::ordered(webrtc::DataChannelInterface *this)
{
  return 0;
}

uint64_t webrtc::DataChannelInterface::maxRetransmitTime(webrtc::DataChannelInterface *this)
{
  return 0;
}

uint64_t webrtc::DataChannelInterface::maxRetransmits(webrtc::DataChannelInterface *this)
{
  return 0;
}

uint64_t webrtc::DataChannelInterface::maxRetransmitsOpt(webrtc::DataChannelInterface *this)
{
  return 0;
}

uint64_t webrtc::DataChannelInterface::maxPacketLifeTime(webrtc::DataChannelInterface *this)
{
  return 0;
}

void webrtc::DataChannelInterface::protocol(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t webrtc::DataChannelInterface::negotiated(webrtc::DataChannelInterface *this)
{
  return 0;
}

uint64_t webrtc::DataChannelInterface::Send()
{
  return 0;
}

uint64_t webrtc::DataChannelInterface::priority(webrtc::DataChannelInterface *this)
{
  return 1;
}

void webrtc::DataChannelInterface::error(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 38) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 29) = 0;
}

void webrtc::PacketQueue::PopFront(webrtc::PacketQueue *this@<X0>, _QWORD *a2@<X8>)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;

  v2 = *((_QWORD *)this + 4);
  v3 = (v2 >> 6) & 0x3FFFFFFFFFFFFF8;
  v4 = *(_QWORD *)(*((_QWORD *)this + 1) + v3);
  v5 = 8 * (v2 & 0x1FF);
  v6 = *(_QWORD *)(v4 + v5);
  *((_QWORD *)this + 6) -= *(_QWORD *)(v6 + 16);
  *(_QWORD *)(v4 + v5) = 0;
  *a2 = v6;
  v7 = *(_QWORD *)(*((_QWORD *)this + 1) + v3);
  if (v7)
  {
    v9 = *(uint64_t **)(v7 + 8 * (v2 & 0x1FF));
    *(_QWORD *)(v7 + 8 * (v2 & 0x1FF)) = 0;
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        v11 = (unsigned int *)(v10 + 24);
        do
        {
          v12 = __ldaxr(v11);
          v13 = v12 - 1;
        }
        while (__stlxr(v13, v11));
        if (!v13)
        {
          v14 = *(_QWORD *)(v10 + 16);
          *(_QWORD *)(v10 + 16) = 0;
          if (v14)
            MEMORY[0x20BD0ADD4](v14, 0x1000C8077774924);
          MEMORY[0x20BD0ADEC](v10, 0x1010C40EE34DA14);
        }
      }
      MEMORY[0x20BD0ADEC](v9, 0x1020C4059E634C0);
      v2 = *((_QWORD *)this + 4);
    }
    v15 = *((_QWORD *)this + 5) - 1;
    v16 = v2 + 1;
    *((_QWORD *)this + 4) = v16;
    *((_QWORD *)this + 5) = v15;
    if (v16 >= 0x400)
    {
      operator delete(**((void ***)this + 1));
      *((_QWORD *)this + 1) += 8;
      *((_QWORD *)this + 4) -= 512;
    }
  }
  else
  {
    __break(1u);
  }
}

void webrtc::PacketQueue::Clear(webrtc::PacketQueue *this)
{
  void **v2;
  void **v3;
  unint64_t v4;
  void **v5;
  uint64_t **v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t **v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v2 = (void **)*((_QWORD *)this + 1);
  v3 = (void **)*((_QWORD *)this + 2);
  if (v3 == v2)
  {
    *((_QWORD *)this + 5) = 0;
    v15 = 0;
    goto LABEL_20;
  }
  v4 = *((_QWORD *)this + 4);
  v5 = &v2[v4 >> 9];
  v6 = (uint64_t **)((char *)*v5 + 8 * (v4 & 0x1FF));
  v7 = *(uint64_t *)((char *)v2 + (((*((_QWORD *)this + 5) + v4) >> 6) & 0x3FFFFFFFFFFFFF8))
     + 8 * ((*((_QWORD *)this + 5) + v4) & 0x1FF);
  if (v6 == (uint64_t **)v7)
  {
LABEL_18:
    *((_QWORD *)this + 5) = 0;
    v15 = (char *)v3 - (char *)v2;
    if (v15 >= 0x11)
    {
      do
      {
        operator delete(*v2);
        v16 = *((_QWORD *)this + 2);
        v2 = (void **)(*((_QWORD *)this + 1) + 8);
        *((_QWORD *)this + 1) = v2;
        v15 = v16 - (_QWORD)v2;
      }
      while (v15 > 0x10);
    }
LABEL_20:
    if (v15 >> 3 == 1)
    {
      v17 = 256;
    }
    else
    {
      if (v15 >> 3 != 2)
      {
LABEL_26:
        *((_QWORD *)this + 6) = 0;
        return;
      }
      v17 = 512;
    }
    *((_QWORD *)this + 4) = v17;
    goto LABEL_26;
  }
  while (v6)
  {
    v8 = *v6;
    *v6 = 0;
    if (v8)
    {
      v9 = *v8;
      if (*v8)
      {
        v10 = (unsigned int *)(v9 + 24);
        do
        {
          v11 = __ldaxr(v10);
          v12 = v11 - 1;
        }
        while (__stlxr(v12, v10));
        if (!v12)
        {
          v13 = *(_QWORD *)(v9 + 16);
          *(_QWORD *)(v9 + 16) = 0;
          if (v13)
            MEMORY[0x20BD0ADD4](v13, 0x1000C8077774924);
          MEMORY[0x20BD0ADEC](v9, 0x1010C40EE34DA14);
        }
      }
      MEMORY[0x20BD0ADEC](v8, 0x1020C4059E634C0);
    }
    if ((char *)++v6 - (_BYTE *)*v5 == 4096)
    {
      v14 = (uint64_t **)v5[1];
      ++v5;
      v6 = v14;
    }
    if (v6 == (uint64_t **)v7)
    {
      v2 = (void **)*((_QWORD *)this + 1);
      v3 = (void **)*((_QWORD *)this + 2);
      goto LABEL_18;
    }
  }
  __break(1u);
}

void std::deque<std::unique_ptr<webrtc::DataBuffer>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  void *v23;
  void *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  int64_t v36;
  char *v37;
  char *v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  BOOL v44;
  int64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  uint64_t v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  char *v58;
  int64_t v59;
  unint64_t v60;
  char *v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  __int128 *v65;
  char *v66;
  uint64_t v67;
  __int128 v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char *v75;
  char *v76;
  char *v77;
  unint64_t v78;
  uint64_t v79;
  __int128 *v80;
  _OWORD *v81;
  uint64_t v82;
  __int128 v83;
  uint64_t v84;
  char *v85;
  char *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  int64_t v92;
  char *v93;
  uint64_t v94;
  uint64_t v95;
  __int128 *v96;
  _OWORD *v97;
  uint64_t v98;
  __int128 v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  uint64_t v103;
  char *v104;
  char *v105;
  int64_t v106;
  unint64_t v107;
  char *v108;
  char *v109;
  uint64_t v110;
  uint64_t v111;
  char *v112;
  __int128 *v113;
  _OWORD *v114;
  uint64_t v115;
  __int128 v116;
  uint64_t v117;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_4;
    v30 = *(char **)a1;
    if ((unint64_t)v7 > *(_QWORD *)a1)
    {
      v31 = (uint64_t)&v7[-*(_QWORD *)a1] >> 3;
      if (v31 >= -1)
        v32 = v31 + 1;
      else
        v32 = v31 + 2;
      v33 = v32 >> 1;
      v34 = -v33;
      v35 = &v7[-8 * v33];
      v36 = v5 - v7;
      if (v5 != v7)
      {
        memmove(&v7[-8 * v33], v7, v5 - v7);
        v7 = *(char **)(a1 + 8);
      }
      v5 = &v35[v36];
      v37 = &v7[8 * v34];
      goto LABEL_32;
    }
    v39 = (v5 - v30) >> 2;
    if (v5 == v30)
      v39 = 1;
    if (v39 >> 61)
      goto LABEL_108;
    v40 = v39 >> 2;
    v41 = 8 * v39;
    v42 = (char *)operator new(8 * v39);
    v43 = &v42[8 * v40];
    v45 = v5 - v7;
    v44 = v5 == v7;
    v5 = v43;
    if (!v44)
    {
      v5 = &v43[v45 & 0xFFFFFFFFFFFFFFF8];
      v46 = v45 - 8;
      if ((unint64_t)(v45 - 8) < 0x38)
      {
        v47 = &v42[8 * v40];
        do
        {
LABEL_91:
          v100 = *(_QWORD *)v7;
          v7 += 8;
          *(_QWORD *)v47 = v100;
          v47 += 8;
        }
        while (v47 != v5);
        goto LABEL_92;
      }
      v93 = &v42[8 * v40];
      v47 = v93;
      if ((unint64_t)(v93 - v7) < 0x20)
        goto LABEL_91;
      v94 = (v46 >> 3) + 1;
      v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      v47 = &v43[v95];
      v7 += v95;
      v96 = (__int128 *)(v6 + 3);
      v97 = v93 + 16;
      v98 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v99 = *v96;
        *(v97 - 1) = *(v96 - 1);
        *v97 = v99;
        v96 += 2;
        v97 += 2;
        v98 -= 4;
      }
      while (v98);
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_91;
    }
LABEL_92:
    *(_QWORD *)a1 = v42;
    *(_QWORD *)(a1 + 8) = v43;
    *(_QWORD *)(a1 + 16) = v5;
    *(_QWORD *)(a1 + 24) = &v42[v41];
    if (v30)
    {
      operator delete(v30);
      v5 = *(char **)(a1 + 16);
    }
LABEL_4:
    if (!v5)
    {
LABEL_107:
      __break(1u);
      goto LABEL_108;
    }
LABEL_5:
    *(_QWORD *)v5 = v8;
LABEL_10:
    *(_QWORD *)(a1 + 16) += 8;
    return;
  }
  v10 = *(char **)(a1 + 16);
  v9 = *(char **)(a1 + 24);
  v12 = *(char **)a1;
  v11 = *(char **)(a1 + 8);
  v13 = v10 - v11;
  v14 = (v10 - v11) >> 3;
  v15 = (uint64_t)&v9[-*(_QWORD *)a1];
  if (v14 < (unint64_t)(v15 >> 3))
  {
    v16 = operator new(0x1000uLL);
    v17 = v16;
    if (v9 != v10)
    {
      if (v10)
      {
        *(_QWORD *)v10 = v16;
        goto LABEL_10;
      }
      goto LABEL_107;
    }
    if (v11 == v12)
    {
      v70 = (v9 - v11) >> 2;
      if (v10 == v11)
        v70 = 1;
      if (v70 >> 61)
        goto LABEL_108;
      v71 = (v70 + 3) >> 2;
      v72 = 8 * v70;
      v73 = (char *)operator new(8 * v70);
      v38 = &v73[8 * v71];
      v74 = v38;
      if (v10 != v11)
      {
        v74 = &v38[8 * v14];
        v75 = &v73[8 * v71];
        v76 = v11;
        if ((unint64_t)(v13 - 8) < 0x38)
          goto LABEL_111;
        v77 = &v73[8 * v71];
        v75 = v77;
        v76 = v11;
        if ((unint64_t)(v77 - v11) < 0x20)
          goto LABEL_111;
        v78 = ((unint64_t)(v13 - 8) >> 3) + 1;
        v79 = 8 * (v78 & 0x3FFFFFFFFFFFFFFCLL);
        v75 = &v38[v79];
        v76 = &v11[v79];
        v80 = (__int128 *)(v11 + 16);
        v81 = v77 + 16;
        v82 = v78 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v83 = *v80;
          *(v81 - 1) = *(v80 - 1);
          *v81 = v83;
          v80 += 2;
          v81 += 2;
          v82 -= 4;
        }
        while (v82);
        if (v78 != (v78 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_111:
          do
          {
            v84 = *(_QWORD *)v76;
            v76 += 8;
            *(_QWORD *)v75 = v84;
            v75 += 8;
          }
          while (v75 != v74);
        }
      }
      *(_QWORD *)a1 = v73;
      *(_QWORD *)(a1 + 8) = v38;
      *(_QWORD *)(a1 + 16) = v74;
      *(_QWORD *)(a1 + 24) = &v73[v72];
      if (v11)
      {
        operator delete(v11);
        v38 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v38 = v11;
    }
    *((_QWORD *)v38 - 1) = v17;
    v85 = *(char **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    *(_QWORD *)(a1 + 8) = v85 - 8;
    v8 = *((_QWORD *)v85 - 1);
    *(_QWORD *)(a1 + 8) = v85;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_4;
    v86 = *(char **)a1;
    if ((unint64_t)v85 > *(_QWORD *)a1)
    {
      v87 = (uint64_t)&v85[-*(_QWORD *)a1] >> 3;
      if (v87 >= -1)
        v88 = v87 + 1;
      else
        v88 = v87 + 2;
      v89 = v88 >> 1;
      v90 = -v89;
      v91 = &v85[-8 * v89];
      v92 = v5 - v85;
      if (v5 != v85)
      {
        memmove(&v85[-8 * v89], v85, v5 - v85);
        v85 = *(char **)(a1 + 8);
      }
      v5 = &v91[v92];
      v37 = &v85[8 * v90];
LABEL_32:
      *(_QWORD *)(a1 + 8) = v37;
      *(_QWORD *)(a1 + 16) = v5;
      goto LABEL_5;
    }
    v101 = (v5 - v86) >> 2;
    if (v5 == v86)
      v101 = 1;
    if (!(v101 >> 61))
    {
      v102 = v101 >> 2;
      v103 = 8 * v101;
      v104 = (char *)operator new(8 * v101);
      v105 = &v104[8 * v102];
      v106 = v5 - v85;
      v44 = v5 == v85;
      v5 = v105;
      if (v44)
        goto LABEL_105;
      v5 = &v105[v106 & 0xFFFFFFFFFFFFFFF8];
      v107 = v106 - 8;
      if ((unint64_t)(v106 - 8) >= 0x38)
      {
        v109 = &v104[8 * v102];
        v108 = v109;
        if ((unint64_t)(v109 - v85) >= 0x20)
        {
          v110 = (v107 >> 3) + 1;
          v111 = 8 * (v110 & 0x3FFFFFFFFFFFFFFCLL);
          v108 = &v105[v111];
          v112 = &v85[v111];
          v113 = (__int128 *)(v85 + 16);
          v114 = v109 + 16;
          v115 = v110 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v116 = *v113;
            *(v114 - 1) = *(v113 - 1);
            *v114 = v116;
            v113 += 2;
            v114 += 2;
            v115 -= 4;
          }
          while (v115);
          v85 = v112;
          if (v110 == (v110 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_105:
            *(_QWORD *)a1 = v104;
            *(_QWORD *)(a1 + 8) = v105;
            *(_QWORD *)(a1 + 16) = v5;
            *(_QWORD *)(a1 + 24) = &v104[v103];
            if (v86)
            {
              operator delete(v86);
              v5 = *(char **)(a1 + 16);
            }
            goto LABEL_4;
          }
        }
      }
      else
      {
        v108 = &v104[8 * v102];
      }
      do
      {
        v117 = *(_QWORD *)v85;
        v85 += 8;
        *(_QWORD *)v108 = v117;
        v108 += 8;
      }
      while (v108 != v5);
      goto LABEL_105;
    }
LABEL_108:
    std::__throw_bad_array_new_length[abi:sn180100]();
  }
  v18 = v15 >> 2;
  if (v9 == v12)
    v19 = 1;
  else
    v19 = v18;
  if (v19 >> 61)
    goto LABEL_108;
  v20 = (char *)operator new(8 * v19);
  v21 = &v20[8 * v14];
  v22 = &v20[8 * v19];
  v23 = operator new(0x1000uLL);
  v24 = v23;
  if (v14 != v19)
    goto LABEL_21;
  if (v13 >= 1)
  {
    v25 = v14 + 2;
    if (v14 >= -1)
      v25 = v14 + 1;
    v21 -= 8 * (v25 >> 1);
LABEL_21:
    *(_QWORD *)v21 = v23;
    v26 = v21 + 8;
    if (v10 != v11)
      goto LABEL_48;
    goto LABEL_22;
  }
  v48 = v13 >> 2;
  if (v10 == v11)
    v48 = 1;
  if (v48 >> 61)
    goto LABEL_108;
  v49 = 8 * v48;
  v21 = (char *)operator new(8 * v48);
  operator delete(v20);
  v22 = &v21[v49];
  v50 = *(char **)(a1 + 8);
  v10 = *(char **)(a1 + 16);
  v20 = v21;
  *(_QWORD *)v21 = v24;
  v26 = v21 + 8;
  if (v10 != v50)
  {
    while (1)
    {
LABEL_48:
      if (v21 == v20)
      {
        if (v26 >= v22)
        {
          v55 = (v22 - v21) >> 2;
          if (v22 == v21)
            v55 = 1;
          if (v55 >> 61)
            goto LABEL_108;
          v56 = (v55 + 3) >> 2;
          v57 = 8 * v55;
          v58 = (char *)operator new(8 * v55);
          v20 = v58;
          v51 = &v58[8 * v56];
          v28 = v51;
          v59 = v26 - v21;
          if (v26 != v21)
          {
            v28 = &v51[v59 & 0xFFFFFFFFFFFFFFF8];
            v60 = v59 - 8;
            v61 = &v58[8 * v56];
            v62 = v21;
            if (v60 < 0x38)
              goto LABEL_112;
            v61 = &v58[8 * v56];
            v62 = v21;
            if ((unint64_t)(v61 - v21) < 0x20)
              goto LABEL_112;
            v63 = (v60 >> 3) + 1;
            v64 = 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
            v61 = &v51[v64];
            v62 = &v21[v64];
            v65 = (__int128 *)(v21 + 16);
            v66 = &v58[8 * v56 + 16];
            v67 = v63 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v68 = *v65;
              *((_OWORD *)v66 - 1) = *(v65 - 1);
              *(_OWORD *)v66 = v68;
              v65 += 2;
              v66 += 32;
              v67 -= 4;
            }
            while (v67);
            if (v63 != (v63 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_112:
              do
              {
                v69 = *(_QWORD *)v62;
                v62 += 8;
                *(_QWORD *)v61 = v69;
                v61 += 8;
              }
              while (v61 != v28);
            }
          }
          v22 = &v58[v57];
          operator delete(v21);
        }
        else
        {
          v53 = (v22 - v26) >> 3;
          if (v53 >= -1)
            v54 = v53 + 1;
          else
            v54 = v53 + 2;
          v28 = &v26[8 * (v54 >> 1)];
          v51 = &v21[8 * (v54 >> 1)];
          if (v26 == v21)
          {
            v20 = v26;
          }
          else
          {
            memmove(&v21[8 * (v54 >> 1)], v21, v26 - v21);
            v20 = v21;
          }
        }
      }
      else
      {
        v51 = v21;
        v28 = v26;
      }
      v52 = *((_QWORD *)v10 - 1);
      v10 -= 8;
      *((_QWORD *)v51 - 1) = v52;
      v27 = v51 - 8;
      v26 = v28;
      v21 = v27;
      if (v10 == *(char **)(a1 + 8))
        goto LABEL_23;
    }
  }
LABEL_22:
  v27 = v21;
  v28 = v26;
LABEL_23:
  v29 = *(char **)a1;
  *(_QWORD *)a1 = v20;
  *(_QWORD *)(a1 + 8) = v27;
  *(_QWORD *)(a1 + 16) = v28;
  *(_QWORD *)(a1 + 24) = v22;
  if (v29)
    operator delete(v29);
}

_DWORD *dcsctp::DataChunk::Parse@<X0>(_DWORD *result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _DWORD *v4;
  unint64_t v5;
  BOOL v6;
  BOOL v7;
  char v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  char v15;
  int v16;
  int v17;
  size_t v18;
  char *v19;
  char *v20;
  void *__src;
  char v22;
  unsigned int v23;

  if (a2)
    v4 = result;
  else
    v4 = 0;
  if (a2 < 0x10
    || *(_BYTE *)v4
    || ((v5 = __rev16(*((unsigned __int16 *)v4 + 1)), v5 >= 0x10) ? (v6 = a2 >= v5) : (v6 = 0),
        v6 ? (v7 = a2 - v5 >= 4) : (v7 = 1),
        v7))
  {
    v8 = 0;
    *(_BYTE *)a3 = 0;
  }
  else
  {
    v9 = *((unsigned __int8 *)v4 + 1);
    v10 = bswap32(v4[1]);
    v11 = bswap32(*((unsigned __int16 *)v4 + 4)) >> 16;
    v12 = bswap32(*((unsigned __int16 *)v4 + 5)) >> 16;
    v13 = (v9 >> 1) & 1;
    v14 = bswap32(v4[3]);
    v15 = v9 & 1;
    v16 = (v9 >> 2) & 1;
    v17 = (v9 >> 3) & 1;
    if (v5 < 0x11)
    {
      v19 = 0;
      v20 = 0;
    }
    else
    {
      v18 = v5 - 16;
      __src = v4 + 4;
      v22 = v17;
      v23 = v10;
      v19 = (char *)operator new(v5 - 16);
      v20 = &v19[v18];
      result = memcpy(v19, __src, v18);
      LOBYTE(v17) = v22;
      v10 = v23;
    }
    *(_DWORD *)(a3 + 8) = v10;
    *(_WORD *)(a3 + 16) = v11;
    *(_WORD *)(a3 + 18) = v12;
    *(_DWORD *)(a3 + 20) = 0;
    *(_DWORD *)(a3 + 24) = 0;
    *(_DWORD *)(a3 + 28) = v14;
    *(_QWORD *)(a3 + 32) = v19;
    *(_QWORD *)(a3 + 40) = v20;
    *(_QWORD *)(a3 + 48) = v20;
    *(_BYTE *)(a3 + 56) = v13;
    *(_BYTE *)(a3 + 57) = v15;
    *(_BYTE *)(a3 + 58) = v16;
    *(_BYTE *)(a3 + 64) = v17;
    v8 = 1;
    *(_QWORD *)a3 = &off_24C0B2738;
  }
  *(_BYTE *)(a3 + 72) = v8;
  return result;
}

void dcsctp::DataChunk::~DataChunk(dcsctp::DataChunk *this)
{
  void *v2;

  *(_QWORD *)this = &unk_24C0B1318;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &unk_24C0B1318;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x20BD0ADECLL);
}

void dcsctp::DataChunk::SerializeTo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  char *v11;
  unint64_t v12;
  __int16 v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  const void *v18;
  size_t v19;
  std::string *v20;
  uint64_t v21;

  v10 = *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32);
  v11 = *(char **)a2;
  v12 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  v13 = v10 + 16;
  v14 = v12 + v10 + 16;
  if (v12 >= v14)
  {
    if (v12 > v14)
      *(_QWORD *)(a2 + 8) = &v11[v14];
  }
  else
  {
    std::vector<unsigned char>::__append((char **)a2, v10 + 16);
    v11 = *(char **)a2;
  }
  v15 = &v11[v12];
  *v15 = 0;
  v15[2] = HIBYTE(v13);
  v15[3] = v13;
  if (v10 >= 0xFFFFFFFFFFFFFFF0)
  {
    v20 = rtc::webrtc_checks_impl::FatalLog("Source/webrtc/net/dcsctp/packet/bounded_byte_writer.h", 59, "data.size() >= FixedSize", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v21);
    dcsctp::DataChunk::ToString((dcsctp::DataChunk *)v20);
  }
  else
  {
    v16 = *(_QWORD *)a2 + v12;
    *(_BYTE *)(v16 + 1) = *(_BYTE *)(a1 + 57) | (2 * (*(_BYTE *)(a1 + 56) != 0)) | (4 * (*(_BYTE *)(a1 + 58) != 0)) | (8 * (*(_BYTE *)(a1 + 64) != 0));
    *(_DWORD *)(v16 + 4) = bswap32(*(_DWORD *)(a1 + 8));
    *(_WORD *)(v16 + 8) = bswap32(*(unsigned __int16 *)(a1 + 16)) >> 16;
    *(_WORD *)(v16 + 10) = bswap32(*(unsigned __int16 *)(a1 + 18)) >> 16;
    *(_DWORD *)(v16 + 12) = bswap32(*(_DWORD *)(a1 + 28));
    v17 = *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32);
    if (v17)
      v18 = *(const void **)(a1 + 32);
    else
      v18 = 0;
    if (v10 >= v17)
      v19 = *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32);
    else
      v19 = v10;
    if (v18)
    {
      if (v19)
        memcpy((void *)(v16 + 16), v18, v19);
    }
  }
}

void dcsctp::DataChunk::ToString(dcsctp::DataChunk *this@<X0>, std::string *a2@<X8>)
{
  char *v5;
  size_t v6;
  uint64_t v7;
  std::string::size_type v8;
  std::string::size_type size;
  _WORD *v10;
  std::string::size_type v11;
  const char *v12;
  const char *v13;
  const char *v14;
  size_t v15;
  size_t v16;
  std::string::size_type v17;
  std::string::size_type v18;
  std::string *v19;
  char *v20;
  std::string::size_type v21;
  std::string::size_type v22;
  std::string::size_type v23;
  std::string *v24;
  char *v25;
  std::string::size_type v26;
  std::string *v27;
  std::string *v28;
  int v29;
  std::string::size_type v30;
  std::string::size_type v31;
  std::string *v32;
  std::string::size_type v33;
  std::string::size_type v34;
  std::string *v35;
  std::string *v36;
  int v37;
  std::string::size_type v38;
  std::string::size_type v39;
  std::string *v40;
  std::string::size_type v41;
  std::string::size_type v42;
  std::string *v43;
  std::string *v44;
  int v45;
  std::string::size_type v46;
  std::string::size_type v47;
  std::string *v48;
  _DWORD *v49;
  std::string::size_type v50;
  std::string *v51;
  std::string *v52;
  int v53;
  std::string::size_type v54;
  std::string::size_type v55;
  std::string *v56;
  std::string::size_type v57;
  std::string::size_type v58;
  std::string v59;

  memset(&v59, 0, sizeof(v59));
  if (&v59 <= (std::string *)"DATA, type=" && (char *)&v59.__r_.__value_.__r.__words[1] + 3 > "DATA, type=")
    goto LABEL_140;
  strcpy((char *)&v59, "DATA, type=");
  *((_BYTE *)&v59.__r_.__value_.__s + 23) = 11;
  v5 = *((_BYTE *)this + 58) ? "unordered" : "ordered";
  v6 = *((_BYTE *)this + 58) ? 9 : 7;
  if ((char *)&v59.__r_.__value_.__r.__words[1] + 3 <= v5 && (char *)&v59.__r_.__value_.__r.__words[1] + v6 + 3 > v5)
    goto LABEL_140;
  memcpy((char *)&v59.__r_.__value_.__r.__words[1] + 3, v5, v6);
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
    v59.__r_.__value_.__l.__size_ = v6 + 11;
  else
    *((_BYTE *)&v59.__r_.__value_.__s + 23) = v6 + 11;
  v7 = (uint64_t)&v59;
  v59.__r_.__value_.__s.__data_[v6 + 11] = 0;
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v8 = 22;
  else
    v8 = (v59.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v59.__r_.__value_.__r.__words[2]);
  else
    size = v59.__r_.__value_.__l.__size_;
  if (v8 - size >= 2)
  {
    if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v7 = 0x7974202C41544144;
    v10 = (_WORD *)(v7 + size);
    if (v7 + size <= (unint64_t)"::" && v10 + 1 > (_WORD *)"::")
      goto LABEL_140;
    *v10 = 14906;
    v11 = size + 2;
    if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
      v59.__r_.__value_.__l.__size_ = size + 2;
    else
      *((_BYTE *)&v59.__r_.__value_.__s + 23) = v11 & 0x7F;
    *(_BYTE *)(v7 + v11) = 0;
  }
  else
  {
    std::string::__grow_by_and_replace(&v59, v8, size - v8 + 2, size, size, 0, 2uLL, "::");
  }
  v12 = "last";
  v13 = "complete";
  if (!*((_BYTE *)this + 57))
  {
    v12 = "middle";
    v13 = "first";
  }
  if (*((_BYTE *)this + 56))
    v14 = v13;
  else
    v14 = v12;
  v15 = strlen(v14);
  v16 = v15;
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = 22;
  else
    v17 = (v59.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v18 = HIBYTE(v59.__r_.__value_.__r.__words[2]);
  else
    v18 = v59.__r_.__value_.__l.__size_;
  if (v17 - v18 >= v15)
  {
    if (v15)
    {
      if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v19 = &v59;
      else
        v19 = (std::string *)v59.__r_.__value_.__r.__words[0];
      v20 = (char *)v19 + v18;
      if ((char *)v19 + v18 <= v14 && &v20[v16] > v14)
        goto LABEL_140;
      memcpy(v20, v14, v16);
      v21 = v18 + v16;
      if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
        v59.__r_.__value_.__l.__size_ = v18 + v16;
      else
        *((_BYTE *)&v59.__r_.__value_.__s + 23) = v21 & 0x7F;
      v19->__r_.__value_.__s.__data_[v21] = 0;
    }
  }
  else
  {
    std::string::__grow_by_and_replace(&v59, v17, v18 + v15 - v17, v18, v18, 0, v15, v14);
  }
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v22 = 22;
  else
    v22 = (v59.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v23 = HIBYTE(v59.__r_.__value_.__r.__words[2]);
  else
    v23 = v59.__r_.__value_.__l.__size_;
  if (v22 - v23 >= 6)
  {
    v24 = &v59;
    if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v24 = (std::string *)v59.__r_.__value_.__r.__words[0];
    v25 = (char *)v24 + v23;
    if ((char *)v24 + v23 <= ", tsn=" && v25 + 6 > ", tsn=")
      goto LABEL_140;
    *((_WORD *)v25 + 2) = 15726;
    *(_DWORD *)v25 = 1936990252;
    v26 = v23 + 6;
    if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
      v59.__r_.__value_.__l.__size_ = v23 + 6;
    else
      *((_BYTE *)&v59.__r_.__value_.__s + 23) = v26 & 0x7F;
    v24->__r_.__value_.__s.__data_[v26] = 0;
  }
  else
  {
    std::string::__grow_by_and_replace(&v59, v22, v23 - v22 + 6, v23, v23, 0, 6uLL, ", tsn=");
  }
  v27 = rtc::StringBuilder::operator<<(&v59, *((_DWORD *)this + 2));
  v28 = v27;
  v29 = SHIBYTE(v27->__r_.__value_.__r.__words[2]);
  if (v29 >= 0)
    v30 = 22;
  else
    v30 = (v27->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v29 >= 0)
    v31 = HIBYTE(v27->__r_.__value_.__r.__words[2]);
  else
    v31 = v27->__r_.__value_.__l.__size_;
  if (v30 - v31 >= 6)
  {
    if (v29 >= 0)
      v32 = v27;
    else
      v32 = (std::string *)v27->__r_.__value_.__r.__words[0];
    v33 = (std::string::size_type)v32 + v31;
    if ((char *)v32 + v31 <= ", sid=" && v33 + 6 > (unint64_t)", sid=")
      goto LABEL_140;
    *(_WORD *)(v33 + 4) = 15716;
    *(_DWORD *)v33 = 1769152556;
    v34 = v31 + 6;
    if (SHIBYTE(v27->__r_.__value_.__r.__words[2]) < 0)
      v27->__r_.__value_.__l.__size_ = v34;
    else
      *((_BYTE *)&v27->__r_.__value_.__s + 23) = v34 & 0x7F;
    v32->__r_.__value_.__s.__data_[v34] = 0;
  }
  else
  {
    std::string::__grow_by_and_replace(v27, v30, v31 - v30 + 6, v31, v31, 0, 6uLL, ", sid=");
  }
  v35 = rtc::StringBuilder::operator<<(v28, *((unsigned __int16 *)this + 8));
  v36 = v35;
  v37 = SHIBYTE(v35->__r_.__value_.__r.__words[2]);
  if (v37 >= 0)
    v38 = 22;
  else
    v38 = (v35->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v37 >= 0)
    v39 = HIBYTE(v35->__r_.__value_.__r.__words[2]);
  else
    v39 = v35->__r_.__value_.__l.__size_;
  if (v38 - v39 >= 6)
  {
    if (v37 >= 0)
      v40 = v35;
    else
      v40 = (std::string *)v35->__r_.__value_.__r.__words[0];
    v41 = (std::string::size_type)v40 + v39;
    if ((char *)v40 + v39 <= ", ssn=" && v41 + 6 > (unint64_t)", ssn=")
      goto LABEL_140;
    *(_WORD *)(v41 + 4) = 15726;
    *(_DWORD *)v41 = 1936924716;
    v42 = v39 + 6;
    if (SHIBYTE(v35->__r_.__value_.__r.__words[2]) < 0)
      v35->__r_.__value_.__l.__size_ = v42;
    else
      *((_BYTE *)&v35->__r_.__value_.__s + 23) = v42 & 0x7F;
    v40->__r_.__value_.__s.__data_[v42] = 0;
  }
  else
  {
    std::string::__grow_by_and_replace(v35, v38, v39 - v38 + 6, v39, v39, 0, 6uLL, ", ssn=");
  }
  v43 = rtc::StringBuilder::operator<<(v36, *((unsigned __int16 *)this + 9));
  v44 = v43;
  v45 = SHIBYTE(v43->__r_.__value_.__r.__words[2]);
  if (v45 >= 0)
    v46 = 22;
  else
    v46 = (v43->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v45 >= 0)
    v47 = HIBYTE(v43->__r_.__value_.__r.__words[2]);
  else
    v47 = v43->__r_.__value_.__l.__size_;
  if (v46 - v47 >= 7)
  {
    if (v45 >= 0)
      v48 = v43;
    else
      v48 = (std::string *)v43->__r_.__value_.__r.__words[0];
    v49 = (_DWORD *)((char *)v48 + v47);
    if ((char *)v48 + v47 <= ", ppid=" && (char *)v49 + 7 > ", ppid=")
      goto LABEL_140;
    *(_DWORD *)((char *)v49 + 3) = 1029990768;
    *v49 = 1886396460;
    v50 = v47 + 7;
    if (SHIBYTE(v43->__r_.__value_.__r.__words[2]) < 0)
      v43->__r_.__value_.__l.__size_ = v50;
    else
      *((_BYTE *)&v43->__r_.__value_.__s + 23) = v50 & 0x7F;
    v48->__r_.__value_.__s.__data_[v50] = 0;
  }
  else
  {
    std::string::__grow_by_and_replace(v43, v46, v47 - v46 + 7, v47, v47, 0, 7uLL, ", ppid=");
  }
  v51 = rtc::StringBuilder::operator<<(v44, *((_DWORD *)this + 7));
  v52 = v51;
  v53 = SHIBYTE(v51->__r_.__value_.__r.__words[2]);
  if (v53 >= 0)
    v54 = 22;
  else
    v54 = (v51->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v53 >= 0)
    v55 = HIBYTE(v51->__r_.__value_.__r.__words[2]);
  else
    v55 = v51->__r_.__value_.__l.__size_;
  if (v54 - v55 < 9)
  {
    std::string::__grow_by_and_replace(v51, v54, v55 - v54 + 9, v55, v55, 0, 9uLL, ", length=");
LABEL_139:
    rtc::StringBuilder::operator<<(v52, *((_QWORD *)this + 5) - *((_QWORD *)this + 4));
    *a2 = v59;
    return;
  }
  if (v53 >= 0)
    v56 = v51;
  else
    v56 = (std::string *)v51->__r_.__value_.__r.__words[0];
  v57 = (std::string::size_type)v56 + v55;
  if ((char *)v56 + v55 > ", length=" || v57 + 9 <= (unint64_t)", length=")
  {
    *(_BYTE *)(v57 + 8) = 61;
    *(_QWORD *)v57 = *(_QWORD *)", length=";
    v58 = v55 + 9;
    if (SHIBYTE(v51->__r_.__value_.__r.__words[2]) < 0)
      v51->__r_.__value_.__l.__size_ = v58;
    else
      *((_BYTE *)&v51->__r_.__value_.__s + 23) = v58 & 0x7F;
    v56->__r_.__value_.__s.__data_[v58] = 0;
    goto LABEL_139;
  }
LABEL_140:
  __break(1u);
}

size_t webrtc::ToString@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  uint64_t v3;
  size_t v4;
  char *v5;
  const char *v6;
  char *v7;
  size_t result;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  unint64_t v14;
  uint64_t v15;
  char *__s;
  __int128 v17;
  uint64_t v18;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  __s = (char *)&v18;
  v17 = xmmword_208F08610;
  LOBYTE(v18) = 0;
  if (a1 == 0x8000000000000000)
  {
    v3 = 0x73706220666E692DLL;
    goto LABEL_6;
  }
  if (!a1)
    goto LABEL_8;
  if (a1 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (__ROR8__(0x1CAC083126E978D5 * a1 + 0x10624DD2F1A9FB8, 3) < 0x4189374BC6A7EFuLL)
    {
      v14 = a1 / 0x3E8uLL;
      if (a1 % 0x3E8uLL > 0x1F3)
        ++v14;
      if (-a1 % 0x3E8uLL <= 0x1F4)
        v15 = 0;
      else
        v15 = -1;
      if (a1 < 0)
        v14 = v15 - -a1 / 0x3E8uLL;
      rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%lld", v14);
      if ((_QWORD)v17 + ~*((_QWORD *)&v17 + 1) >= 5uLL)
        v4 = 5;
      else
        v4 = v17 + ~*((_QWORD *)&v17 + 1);
      v5 = &__s[*((_QWORD *)&v17 + 1)];
      v6 = " kbps";
      goto LABEL_12;
    }
LABEL_8:
    rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%lld", a1);
    if ((_QWORD)v17 + ~*((_QWORD *)&v17 + 1) >= 4uLL)
      v4 = 4;
    else
      v4 = v17 + ~*((_QWORD *)&v17 + 1);
    v5 = &__s[*((_QWORD *)&v17 + 1)];
    v6 = " bps";
LABEL_12:
    memcpy(v5, v6, v4);
    *((_QWORD *)&v17 + 1) += v4;
    __s[*((_QWORD *)&v17 + 1)] = 0;
    goto LABEL_13;
  }
  v3 = 0x73706220666E692BLL;
LABEL_6:
  v18 = v3;
  *((_QWORD *)&v17 + 1) = 8;
  v19 = 0;
LABEL_13:
  v7 = __s;
  if (!__s)
    goto LABEL_38;
  result = strlen(__s);
  if (result >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_39;
  v9 = result;
  if (result > 0x16)
  {
    v10 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17)
      v10 = result | 7;
    v11 = v10 + 1;
    result = (size_t)operator new(v10 + 1);
    *((_QWORD *)a2 + 1) = v9;
    *((_QWORD *)a2 + 2) = v11 | 0x8000000000000000;
    *(_QWORD *)a2 = result;
    a2 = (char *)result;
  }
  else
  {
    a2[23] = result;
  }
  v12 = &a2[v9];
  if (a2 <= v7 && v12 > v7)
  {
LABEL_38:
    __break(1u);
LABEL_39:
    abort();
  }
  if (v9)
    result = (size_t)memmove(a2, v7, v9);
  *v12 = 0;
  return result;
}

{
  const char *v3;
  uint64_t v4;
  char *v5;
  size_t v6;
  size_t result;
  size_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  __int128 v13;
  char __s[8];
  __int16 v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v12 = __s;
  v13 = xmmword_208F08610;
  __s[0] = 0;
  if (a1 == 0x8000000000000000)
  {
    v15 = 29541;
    v3 = "-inf bytes";
    goto LABEL_5;
  }
  if (a1 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v15 = 29541;
    v3 = "+inf bytes";
LABEL_5:
    v4 = *(_QWORD *)v3;
    *((_QWORD *)&v13 + 1) = 10;
    *(_QWORD *)__s = v4;
    v16 = 0;
    v5 = __s;
    goto LABEL_10;
  }
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&v12, "%lld", a1);
  if ((_QWORD)v13 + ~*((_QWORD *)&v13 + 1) >= 6uLL)
    v6 = 6;
  else
    v6 = v13 + ~*((_QWORD *)&v13 + 1);
  memcpy(&v12[*((_QWORD *)&v13 + 1)], " bytes", v6);
  *((_QWORD *)&v13 + 1) += v6;
  v12[*((_QWORD *)&v13 + 1)] = 0;
  v5 = v12;
  if (!v12)
  {
LABEL_21:
    __break(1u);
LABEL_22:
    abort();
  }
LABEL_10:
  result = strlen(v5);
  if (result >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_22;
  v8 = result;
  if (result <= 0x16)
  {
    a2[23] = result;
    v9 = &a2[result];
    if (a2 > v5)
      goto LABEL_18;
    goto LABEL_17;
  }
  v10 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((result | 7) != 0x17)
    v10 = result | 7;
  v11 = v10 + 1;
  result = (size_t)operator new(v10 + 1);
  *((_QWORD *)a2 + 1) = v8;
  *((_QWORD *)a2 + 2) = v11 | 0x8000000000000000;
  *(_QWORD *)a2 = result;
  a2 = (char *)result;
  v9 = (char *)(result + v8);
  if (result <= (unint64_t)v5)
  {
LABEL_17:
    if (v9 <= v5)
      goto LABEL_18;
    goto LABEL_21;
  }
LABEL_18:
  if (v8)
    result = (size_t)memmove(a2, v5, v8);
  *v9 = 0;
  return result;
}

uint64_t dcsctp::DataTracker::Observe(uint64_t a1, unsigned int a2, char a3)
{
  unsigned int v5;
  BOOL v6;
  uint64_t v7;
  _BOOL4 v8;
  int64_t v9;
  int64_t v10;
  int64x2_t *v11;
  int64x2_t *v12;
  int64x2_t *v13;
  size_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t **v17;
  uint64_t **v18;
  unsigned int v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t *v22;
  int64x2_t *v23;
  int64x2_t *v24;
  uint64_t v25;
  unint64_t v26;
  int64x2_t *v27;
  unint64_t v28;
  int64x2_t *v29;
  uint64_t v30;
  int64x2_t *v31;
  int64_t v32;
  unint64_t v34;
  int64x2_t *v35;
  uint64_t *v36;
  uint64_t **v37;
  uint64_t **v38;
  unsigned int v39;
  _DWORD *v40;
  uint64_t v41;
  uint64_t *v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  char *v50;
  int64x2_t *v51;
  int64x2_t *v52;
  uint64_t v53;
  uint64_t v54;
  int64x2_t *v55;
  unint64_t v56;
  int64x2_t *v57;
  int64x2_t *v58;
  _OWORD *v59;
  __int128 v60;
  int v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  int v65;
  int v66;
  int v67;
  uint64_t v68;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  char *v73;
  int64_t *v74;
  char *v75;
  unint64_t v76;
  unint64_t v77;
  char *v78;
  int64x2_t *v79;
  int64_t *v80;
  int64x2_t *v81;
  int64_t *v82;
  int64x2_t *v83;
  int64_t v84;
  void *v85;

  if (*(_BYTE *)(a1 + 52))
  {
    v5 = *(_DWORD *)(a1 + 48);
    v6 = a2 >= v5;
    v7 = a2 - v5;
    v8 = (_DWORD)v7 != 0 && v6;
    if ((_DWORD)v7 != 0x80000000)
      v8 = (int)v7 >= 0;
    if (!v8)
      v7 |= 0xFFFFFFFF00000000;
    v9 = v7 + *(_QWORD *)(a1 + 40);
  }
  else
  {
    v9 = a2;
  }
  *(_QWORD *)(a1 + 40) = v9;
  *(_DWORD *)(a1 + 48) = a2;
  *(_BYTE *)(a1 + 52) = 1;
  v10 = *(_QWORD *)(a1 + 56);
  if (v9 <= v10)
  {
    if (*(_QWORD *)(a1 + 104) <= 0x13uLL)
    {
      v17 = (uint64_t **)(a1 + 96);
      v16 = *(uint64_t **)(a1 + 96);
      if (v16)
      {
        while (1)
        {
          while (1)
          {
            v18 = (uint64_t **)v16;
            v19 = *((_DWORD *)v16 + 7);
            if (v19 <= v9)
              break;
            v16 = *v18;
            v17 = v18;
            if (!*v18)
              goto LABEL_27;
          }
          if (v19 >= v9)
            break;
          v16 = v18[1];
          if (!v16)
          {
            v17 = v18 + 1;
            goto LABEL_27;
          }
        }
      }
      else
      {
        v18 = (uint64_t **)(a1 + 96);
LABEL_27:
        v20 = operator new(0x20uLL);
        v20[7] = v9;
        *(_QWORD *)v20 = 0;
        *((_QWORD *)v20 + 1) = 0;
        *((_QWORD *)v20 + 2) = v18;
        *v17 = (uint64_t *)v20;
        v21 = **(_QWORD **)(a1 + 88);
        if (v21)
        {
          *(_QWORD *)(a1 + 88) = v21;
          v22 = *v17;
        }
        else
        {
          v22 = (uint64_t *)v20;
        }
        std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 96), v22);
        ++*(_QWORD *)(a1 + 104);
      }
    }
    v43 = *(_DWORD *)(a1 + 32);
    if (v43 == 3)
    {
LABEL_67:
      v15 = 0;
      if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72))
        goto LABEL_102;
      goto LABEL_97;
    }
    if (v43 == 2)
    {
      v44 = *(_QWORD *)(a1 + 24);
      if (*(_BYTE *)(v44 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v44 + 136) + 24))(*(_QWORD *)(v44 + 136));
        *(_DWORD *)(v44 + 160) = 0;
        *(_BYTE *)(v44 + 156) = 0;
      }
    }
    v15 = 0;
    *(_DWORD *)(a1 + 32) = 3;
    if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72))
      goto LABEL_102;
LABEL_97:
    v61 = *(_DWORD *)(a1 + 32);
    if (v61 != 3)
    {
      if (v61 == 2)
      {
        v62 = *(_QWORD *)(a1 + 24);
        if (*(_BYTE *)(v62 + 156))
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(v62 + 136) + 24))(*(_QWORD *)(v62 + 136));
          *(_DWORD *)(v62 + 160) = 0;
          *(_BYTE *)(v62 + 156) = 0;
        }
      }
      *(_DWORD *)(a1 + 32) = 3;
    }
    goto LABEL_102;
  }
  if (v9 == v10 + 1)
  {
    *(_QWORD *)(a1 + 56) = v9;
    v12 = *(int64x2_t **)(a1 + 64);
    v11 = *(int64x2_t **)(a1 + 72);
    if (v12 != v11 && v12->i64[0] == v9 + 1)
    {
      *(_QWORD *)(a1 + 56) = v12->i64[1];
      v13 = v12 + 1;
      v14 = (char *)v11 - (char *)&v12[1];
      if (v11 == &v12[1])
        goto LABEL_17;
      goto LABEL_16;
    }
LABEL_96:
    v15 = 1;
    if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72))
      goto LABEL_102;
    goto LABEL_97;
  }
  v23 = *(int64x2_t **)(a1 + 64);
  v24 = *(int64x2_t **)(a1 + 72);
  v25 = (char *)v24 - (char *)v23;
  if (v24 == v23)
    goto LABEL_46;
  v26 = v25 >> 4;
  v27 = *(int64x2_t **)(a1 + 64);
  do
  {
    v28 = v26 >> 1;
    v29 = &v27[v26 >> 1];
    v30 = v29->i64[1] + 1;
    v31 = v29 + 1;
    v26 += ~(v26 >> 1);
    if (v30 < v9)
      v27 = v31;
    else
      v26 = v28;
  }
  while (v26);
  if (v24 == v27)
  {
LABEL_46:
    v34 = *(_QWORD *)(a1 + 80);
    if ((unint64_t)v24 >= v34)
    {
      v45 = v25 >> 4;
      v46 = (v25 >> 4) + 1;
      if (v46 >> 60)
        goto LABEL_156;
      v47 = v34 - (_QWORD)v23;
      if (v47 >> 3 > v46)
        v46 = v47 >> 3;
      if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF0)
        v46 = 0xFFFFFFFFFFFFFFFLL;
      if (!v46)
        goto LABEL_155;
      if (v46 >> 60)
        goto LABEL_157;
      v48 = 16 * v46;
      v49 = (char *)operator new(16 * v46);
      v50 = &v49[v48];
      v51 = (int64x2_t *)&v49[16 * v45];
      *v51 = vdupq_n_s64(v9);
      v35 = v51 + 1;
      if (v24 == v23)
      {
        v52 = (int64x2_t *)&v49[16 * v45];
      }
      else
      {
        do
        {
          v52 = v51 - 1;
          v51[-1] = v24[-1];
          --v24;
          --v51;
        }
        while (v24 != v23);
      }
      *(_QWORD *)(a1 + 64) = v52;
      *(_QWORD *)(a1 + 72) = v35;
      *(_QWORD *)(a1 + 80) = v50;
      if (v23)
        operator delete(v23);
    }
    else
    {
      if (!v24)
      {
LABEL_155:
        __break(1u);
LABEL_156:
        abort();
      }
      v24->i64[0] = v9;
      v24->i64[1] = v9;
      v35 = v24 + 1;
    }
    *(_QWORD *)(a1 + 72) = v35;
    goto LABEL_96;
  }
  v32 = v27->i64[1];
  if (v27->i64[0] > v9 || v32 < v9)
  {
    if (v32 + 1 == v9)
    {
      v12 = v27 + 1;
      if (&v27[1] != v24 && v9 + 1 == v12->i64[0])
      {
        v27->i64[1] = v27[1].i64[1];
        v13 = v27 + 2;
        v14 = (char *)v24 - (char *)&v27[2];
        if (v24 == &v27[2])
        {
LABEL_17:
          *(_QWORD *)(a1 + 72) = (char *)v12 + v14;
          v15 = 1;
          if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72))
            goto LABEL_102;
          goto LABEL_97;
        }
LABEL_16:
        memmove(v12, v13, v14);
        goto LABEL_17;
      }
      v27->i64[1] = v9;
      v15 = 1;
      if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72))
        goto LABEL_102;
      goto LABEL_97;
    }
    if (v27->i64[0] == v9 + 1)
    {
      v27->i64[0] = v9;
      v15 = 1;
      if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72))
        goto LABEL_102;
      goto LABEL_97;
    }
    v53 = (char *)v27 - (char *)v23;
    v54 = v27 - v23;
    v55 = (int64x2_t *)((char *)v23 + (((char *)v27 - (char *)v23) & 0xFFFFFFFFFFFFFFF0));
    v56 = *(_QWORD *)(a1 + 80);
    if ((unint64_t)v24 < v56)
    {
      if (v55 != v24)
      {
        v57 = v55 + 1;
        v58 = v24 - 1;
        v59 = *(_OWORD **)(a1 + 72);
        if ((unint64_t)v24 >= 0x10)
        {
          do
          {
            v60 = (__int128)*v58++;
            *v59++ = v60;
          }
          while (v58 < v24);
        }
        *(_QWORD *)(a1 + 72) = v59;
        if (v24 != v57)
          memmove(&v24[-(v24 - v57)], v55, (char *)v24 - (char *)v57);
        *v55 = vdupq_n_s64(v9);
        v15 = 1;
        if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72))
          goto LABEL_102;
        goto LABEL_97;
      }
      if (v23)
      {
        v24->i64[0] = v9;
        v23[v54].i64[1] = v9;
        *(_QWORD *)(a1 + 72) = v24 + 1;
        v15 = 1;
        if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72))
          goto LABEL_102;
        goto LABEL_97;
      }
      goto LABEL_155;
    }
    v70 = (v25 >> 4) + 1;
    if (v70 >> 60)
      goto LABEL_156;
    v71 = v56 - (_QWORD)v23;
    if (v71 >> 3 > v70)
      v70 = v71 >> 3;
    if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFF0)
      v72 = 0xFFFFFFFFFFFFFFFLL;
    else
      v72 = v70;
    if (v72)
    {
      if (v72 >> 60)
        goto LABEL_157;
      v73 = (char *)operator new(16 * v72);
    }
    else
    {
      v73 = 0;
    }
    v74 = (int64_t *)&v73[16 * v54];
    v75 = &v73[16 * v72];
    if (v54 != v72)
      goto LABEL_146;
    if ((uint64_t)(v53 & 0xFFFFFFFFFFFFFFF0) >= 1)
    {
      v76 = v54 + 2;
      if (v54 >= -1)
        v76 = v54 + 1;
      v74 -= 2 * (v76 >> 1);
      goto LABEL_146;
    }
    if ((unint64_t)v53 < 0x10)
      v77 = 1;
    else
      v77 = (v53 >> 3) & 0xFFFFFFFFFFFFFFFELL;
    if (!(v77 >> 60))
    {
      v78 = (char *)operator new(16 * v77);
      v74 = (int64_t *)&v78[16 * (v77 >> 2)];
      v75 = &v78[16 * v77];
      if (v73)
        operator delete(v73);
LABEL_146:
      if (v74)
      {
        *v74 = v9;
        v74[1] = v9;
        v79 = *(int64x2_t **)(a1 + 64);
        v80 = v74;
        if (v79 != v55)
        {
          v81 = v55;
          v82 = v74;
          do
          {
            v80 = v82 - 2;
            *((int64x2_t *)v82 - 1) = v81[-1];
            --v81;
            v82 -= 2;
          }
          while (v81 != v79);
        }
        v83 = *(int64x2_t **)(a1 + 72);
        v84 = (char *)v83 - (char *)v55;
        if (v83 != v55)
          memmove(v74 + 2, v55, (char *)v83 - (char *)v55);
        v85 = *(void **)(a1 + 64);
        *(_QWORD *)(a1 + 64) = v80;
        *(_QWORD *)(a1 + 72) = (char *)v74 + v84 + 16;
        *(_QWORD *)(a1 + 80) = v75;
        if (!v85)
          goto LABEL_96;
        operator delete(v85);
        v15 = 1;
        if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72))
          goto LABEL_102;
        goto LABEL_97;
      }
      goto LABEL_155;
    }
LABEL_157:
    std::__throw_bad_array_new_length[abi:sn180100]();
  }
  if (*(_QWORD *)(a1 + 104) > 0x13uLL)
    goto LABEL_67;
  v37 = (uint64_t **)(a1 + 96);
  v36 = *(uint64_t **)(a1 + 96);
  if (v36)
  {
    while (1)
    {
      while (1)
      {
        v38 = (uint64_t **)v36;
        v39 = *((_DWORD *)v36 + 7);
        if (v39 <= v9)
          break;
        v36 = *v38;
        v37 = v38;
        if (!*v38)
          goto LABEL_57;
      }
      if (v39 >= v9)
        goto LABEL_67;
      v36 = v38[1];
      if (!v36)
      {
        v37 = v38 + 1;
        goto LABEL_57;
      }
    }
  }
  v38 = (uint64_t **)(a1 + 96);
LABEL_57:
  v40 = operator new(0x20uLL);
  v40[7] = v9;
  *(_QWORD *)v40 = 0;
  *((_QWORD *)v40 + 1) = 0;
  *((_QWORD *)v40 + 2) = v38;
  *v37 = (uint64_t *)v40;
  v41 = **(_QWORD **)(a1 + 88);
  if (v41)
  {
    *(_QWORD *)(a1 + 88) = v41;
    v42 = *v37;
  }
  else
  {
    v42 = (uint64_t *)v40;
  }
  std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 96), v42);
  v15 = 0;
  ++*(_QWORD *)(a1 + 104);
  if (*(_QWORD *)(a1 + 64) != *(_QWORD *)(a1 + 72))
    goto LABEL_97;
LABEL_102:
  if (a3)
  {
    v63 = *(_DWORD *)(a1 + 32);
    if (v63 != 3)
    {
      if (v63 == 2)
      {
        v64 = *(_QWORD *)(a1 + 24);
        if (*(_BYTE *)(v64 + 156))
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(v64 + 136) + 24))(*(_QWORD *)(v64 + 136));
          *(_DWORD *)(v64 + 160) = 0;
          *(_BYTE *)(v64 + 156) = 0;
        }
      }
      *(_DWORD *)(a1 + 32) = 3;
    }
  }
  if (!*(_BYTE *)(a1 + 16))
  {
    *(_BYTE *)(a1 + 16) = 1;
    v67 = *(_DWORD *)(a1 + 32);
    if (v67 == 3)
      return v15;
    if (v67 != 2)
    {
LABEL_116:
      v66 = 3;
      goto LABEL_117;
    }
LABEL_114:
    v68 = *(_QWORD *)(a1 + 24);
    if (*(_BYTE *)(v68 + 156))
    {
      (*(void (**)(_QWORD))(**(_QWORD **)(v68 + 136) + 24))(*(_QWORD *)(v68 + 136));
      *(_DWORD *)(v68 + 160) = 0;
      *(_BYTE *)(v68 + 156) = 0;
    }
    goto LABEL_116;
  }
  v65 = *(_DWORD *)(a1 + 32);
  if (v65 == 2)
    goto LABEL_114;
  if (!v65)
  {
    v66 = 1;
LABEL_117:
    *(_DWORD *)(a1 + 32) = v66;
  }
  return v15;
}

void **dcsctp::DataTracker::HandleForwardTsn(void **result, unsigned int a2)
{
  void **v2;
  unsigned int v3;
  BOOL v4;
  uint64_t v5;
  _BOOL4 v6;
  uint64_t v7;
  void *v8;
  char *v9;
  char *v10;
  unint64_t v11;
  char *v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  _BOOL4 v17;
  BOOL v18;
  int v19;
  int64_t v20;
  char *v21;
  int64_t v22;
  int v23;
  int v24;
  _QWORD **v25;

  v2 = result;
  if (*((_BYTE *)result + 52))
  {
    v3 = *((_DWORD *)result + 12);
    v4 = a2 >= v3;
    v5 = a2 - v3;
    v6 = (_DWORD)v5 != 0 && v4;
    if ((_DWORD)v5 != 0x80000000)
      v6 = (int)v5 >= 0;
    if (!v6)
      v5 |= 0xFFFFFFFF00000000;
    v7 = (uint64_t)result[5] + v5;
  }
  else
  {
    v7 = a2;
  }
  result[5] = (void *)v7;
  *((_DWORD *)result + 12) = a2;
  *((_BYTE *)result + 52) = 1;
  v8 = result[7];
  if (v7 <= (uint64_t)v8)
  {
    v19 = *((_DWORD *)result + 8);
    if (v19 == 3)
      return (void **)(v7 > (uint64_t)v8);
    if (v19 != 2)
    {
LABEL_44:
      v24 = 3;
      goto LABEL_45;
    }
LABEL_42:
    v25 = (_QWORD **)v2[3];
    if (*((_BYTE *)v25 + 156))
    {
      (*(void (**)(_QWORD *))(*v25[17] + 24))(v25[17]);
      *((_DWORD *)v25 + 40) = 0;
      *((_BYTE *)v25 + 156) = 0;
    }
    goto LABEL_44;
  }
  result[7] = (void *)v7;
  v10 = (char *)result[8];
  v9 = (char *)result[9];
  if (v9 == v10)
  {
    v12 = (char *)result[9];
    goto LABEL_25;
  }
  v11 = (v9 - v10) >> 4;
  v12 = (char *)result[8];
  do
  {
    v13 = v11 >> 1;
    v14 = &v12[16 * (v11 >> 1)];
    v15 = *((_QWORD *)v14 + 1);
    v16 = v14 + 16;
    v11 += ~(v11 >> 1);
    if (v15 < v7)
      v12 = v16;
    else
      v11 = v13;
  }
  while (v11);
  if (v9 == v12)
  {
LABEL_25:
    v17 = 0;
    v18 = v10 == v12;
    if (v10 > v12)
      goto LABEL_47;
    goto LABEL_26;
  }
  v17 = *(_QWORD *)v12 <= v7;
  v18 = v10 == v12;
  if (v10 > v12)
    goto LABEL_47;
LABEL_26:
  if (!v18)
  {
    v20 = v9 - v12;
    if (v9 == v12)
    {
      v21 = (char *)result[8];
    }
    else
    {
      result = (void **)memmove(result[8], v12, v9 - v12);
      v21 = (char *)v2[8];
    }
    v9 = &v10[v20];
    v2[9] = &v10[v20];
    v10 = v21;
  }
  if (!v17)
  {
LABEL_34:
    if (v10 != v9 && *(void **)v10 == (char *)v2[7] + 1)
    {
      v2[7] = (void *)*((_QWORD *)v10 + 1);
      v22 = v9 - (v10 + 16);
      if (v9 != v10 + 16)
        memmove(v10, v10 + 16, v9 - (v10 + 16));
      v2[9] = &v10[v22];
    }
    v23 = *((_DWORD *)v2 + 8);
    if (v23 != 2)
    {
      if (!v23)
      {
        v24 = 1;
LABEL_45:
        *((_DWORD *)v2 + 8) = v24;
      }
      return (void **)(v7 > (uint64_t)v8);
    }
    goto LABEL_42;
  }
  if (v10 != v9)
  {
    *(_QWORD *)v10 = v7 + 1;
    goto LABEL_34;
  }
LABEL_47:
  __break(1u);
  return result;
}

void dcsctp::DataTracker::CreateSelectiveAck(dcsctp::DataTracker *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  _QWORD *v9;
  _QWORD **v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD **v13;
  _QWORD *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  _QWORD **v18;
  _QWORD *v19;
  uint64_t v20;

  v5 = &v18;
  v6 = (_QWORD *)*((_QWORD *)this + 12);
  v18 = (_QWORD **)*((_QWORD *)this + 11);
  v19 = v6;
  v7 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  v20 = v7;
  *((_QWORD *)this + 11) = (char *)this + 96;
  if (v7)
    v5 = v6 + 2;
  *v5 = &v19;
  v8 = *((_DWORD *)this + 14);
  dcsctp::DataTracker::CreateGapAckBlocks(this, (char **)&v16);
  v10 = v18;
  v9 = v19;
  v13 = v18;
  v14 = v19;
  v11 = v20;
  v15 = v20;
  if (v20)
  {
    v19[2] = &v14;
    v18 = &v19;
    v19 = 0;
    v20 = 0;
  }
  else
  {
    v13 = &v14;
    v10 = &v14;
  }
  *(_QWORD *)a3 = &off_24C0BEDA0;
  *(_DWORD *)(a3 + 8) = v8;
  *(_DWORD *)(a3 + 12) = a2;
  *(_OWORD *)(a3 + 16) = v16;
  *(_QWORD *)(a3 + 32) = v17;
  *(_QWORD *)(a3 + 40) = v10;
  *(_QWORD *)(a3 + 48) = v9;
  v12 = a3 + 48;
  *(_QWORD *)(a3 + 56) = v11;
  if (v11)
  {
    v9[2] = v12;
    v13 = &v14;
    v14 = 0;
    v15 = 0;
    v9 = 0;
  }
  else
  {
    *(_QWORD *)(a3 + 40) = v12;
  }
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)&v13, v9);
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)&v18, v19);
}

void dcsctp::DataTracker::CreateGapAckBlocks(dcsctp::DataTracker *this@<X0>, char **a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  unint64_t v10;
  char *v11;
  const double *v12;
  int64x2_t v13;
  int32x2_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  char *v19;
  unint64_t v20;
  char *v21;
  char *v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD *v27;
  char *v28;
  uint64_t v29;
  __int128 v30;
  int32x2_t v31;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v5 = *((_QWORD *)this + 8);
  v4 = *((_QWORD *)this + 9);
  v6 = (v4 - v5) >> 4;
  if (v6 >= 0x14)
    v6 = 20;
  if (v6)
  {
    v7 = 4 * v6;
    v8 = (char *)operator new(4 * v6);
    v9 = &v8[v7];
    *a2 = v8;
    a2[1] = v8;
    a2[2] = &v8[v7];
    if (v4 == v5)
      return;
    goto LABEL_7;
  }
  v9 = 0;
  v8 = 0;
  if (v4 != v5)
  {
LABEL_7:
    v10 = 0;
    v11 = v8;
    while (1)
    {
      v12 = (const double *)((char *)this + 56);
      v13 = (int64x2_t)vld1q_dup_f64(v12);
      v14 = vmovn_s64(vabsq_s64(vsubq_s64(*(int64x2_t *)(v5 + 16 * v10), v13)));
      if (v8 >= v9)
        break;
      if (!v8)
        goto LABEL_38;
      *((_WORD *)v8 + 1) = v14.i16[2];
      *(_WORD *)v8 = v14.i16[0];
      v8 += 4;
      a2[1] = v8;
      if (v10 > 0x12)
        return;
LABEL_26:
      if (++v10 >= (v4 - v5) >> 4)
        return;
    }
    v15 = (v8 - v11) >> 2;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 62)
      goto LABEL_39;
    if ((v9 - v11) >> 1 > v16)
      v16 = (v9 - v11) >> 1;
    if ((unint64_t)(v9 - v11) >= 0x7FFFFFFFFFFFFFFCLL)
      v16 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v16)
    {
LABEL_38:
      __break(1u);
LABEL_39:
      abort();
    }
    v31 = v14;
    if (v16 >> 62)
      std::__throw_bad_array_new_length[abi:sn180100]();
    v17 = 4 * v16;
    v18 = operator new(4 * v16);
    v19 = &v18[4 * v15];
    *(_WORD *)v19 = v31.i16[0];
    *((_WORD *)v19 + 1) = v31.i16[2];
    if (v8 == v11)
    {
      v22 = &v18[4 * v15];
      v9 = &v18[v17];
      v8 = v19 + 4;
      *a2 = v19;
      a2[1] = v19 + 4;
      a2[2] = v9;
      if (!v11)
      {
LABEL_25:
        v11 = v22;
        a2[1] = v8;
        if (v10 > 0x12)
          return;
        goto LABEL_26;
      }
LABEL_24:
      operator delete(v11);
      v5 = *((_QWORD *)this + 8);
      v4 = *((_QWORD *)this + 9);
      goto LABEL_25;
    }
    v20 = v8 - v11 - 4;
    if (v20 < 0xBC
      || (v24 = (v8 - 4 - v11) & 0xFFFFFFFFFFFFFFFCLL, &v18[v8 - v11 - 4 - v24] > &v18[v8 - v11 - 4])
      || &v8[-v24 - 4] > v8 - 4
      || (unint64_t)(v11 - v18) < 0x20)
    {
      v21 = v8;
      v22 = &v18[4 * v15];
    }
    else
    {
      v25 = (v20 >> 2) + 1;
      v26 = 4 * (v25 & 0x7FFFFFFFFFFFFFF8);
      v21 = &v8[-v26];
      v22 = &v19[-v26];
      v27 = &v18[4 * v15 - 16];
      v28 = v8 - 16;
      v29 = v25 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v30 = *(_OWORD *)v28;
        *(v27 - 1) = *((_OWORD *)v28 - 1);
        *v27 = v30;
        v27 -= 2;
        v28 -= 32;
        v29 -= 8;
      }
      while (v29);
      if (v25 == (v25 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_23:
        v9 = &v18[v17];
        v8 = v19 + 4;
        *a2 = v22;
        a2[1] = v19 + 4;
        a2[2] = v9;
        if (!v11)
          goto LABEL_25;
        goto LABEL_24;
      }
    }
    do
    {
      v23 = *((_DWORD *)v21 - 1);
      v21 -= 4;
      *((_DWORD *)v22 - 1) = v23;
      v22 -= 4;
    }
    while (v21 != v11);
    goto LABEL_23;
  }
}

uint64_t dcsctp::DcSctpSocket::DcSctpSocket(uint64_t a1, std::string *__src, size_t __len, uint64_t a4, uint64_t *a5, __int128 *a6)
{
  std::string *v6;
  std::string *v13;
  std::string *v14;
  size_t v15;
  size_t v16;
  std::string::size_type v17;
  std::string::size_type size;
  std::string *v19;
  _WORD *v20;
  std::string::size_type v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  std::string::size_type v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  std::string::size_type v47;
  _QWORD *v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  std::string::size_type v56;
  _QWORD *v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  __int16 v62;
  uint64_t v63;
  std::string v65;
  uint64_t v66;
  int v67;
  _QWORD v68[3];
  _QWORD *v69;
  _QWORD v70[3];
  _QWORD *v71;
  _QWORD v72[3];
  _QWORD *v73;
  _QWORD v74[5];

  v74[4] = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = &off_24C0B2768;
  v6 = (std::string *)(a1 + 8);
  if (__len >= 0x7FFFFFFFFFFFFFF8)
LABEL_55:
    abort();
  if (__len > 0x16)
  {
    v15 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v15 = __len | 7;
    v16 = v15 + 1;
    v13 = (std::string *)operator new(v15 + 1);
    v65.__r_.__value_.__l.__size_ = __len;
    v65.__r_.__value_.__r.__words[2] = v16 | 0x8000000000000000;
    v65.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
    v14 = (std::string *)((char *)v13 + __len);
    if (v13 > __src)
      goto LABEL_9;
  }
  else
  {
    *((_BYTE *)&v65.__r_.__value_.__s + 23) = __len;
    v13 = &v65;
    v14 = (std::string *)((char *)&v65 + __len);
    if (&v65 > __src)
      goto LABEL_9;
  }
  if (v14 > __src)
    goto LABEL_54;
LABEL_9:
  if (__len)
    memmove(v13, __src, __len);
  v14->__r_.__value_.__s.__data_[0] = 0;
  if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = 22;
  else
    v17 = (v65.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v65.__r_.__value_.__r.__words[2]);
  else
    size = v65.__r_.__value_.__l.__size_;
  if (v17 - size < 2)
  {
    std::string::__grow_by_and_replace(&v65, v17, size - v17 + 2, size, size, 0, 2uLL, ": ");
    goto LABEL_27;
  }
  v19 = &v65;
  if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v19 = (std::string *)v65.__r_.__value_.__r.__words[0];
  v20 = (_WORD *)((char *)v19 + size);
  if ((char *)v19 + size <= ": " && v20 + 1 > (_WORD *)": ")
  {
LABEL_54:
    __break(1u);
    goto LABEL_55;
  }
  *v20 = 8250;
  v21 = size + 2;
  if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
    v65.__r_.__value_.__l.__size_ = size + 2;
  else
    *((_BYTE *)&v65.__r_.__value_.__s + 23) = v21 & 0x7F;
  v19->__r_.__value_.__s.__data_[v21] = 0;
LABEL_27:
  *v6 = v65;
  v22 = *a5;
  *a5 = 0;
  *(_QWORD *)(a1 + 32) = v22;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_QWORD *)(a1 + 118) = 0;
  v23 = *a6;
  v24 = a6[2];
  *(_OWORD *)(a1 + 144) = a6[1];
  *(_OWORD *)(a1 + 160) = v24;
  *(_OWORD *)(a1 + 128) = v23;
  v25 = a6[3];
  v26 = a6[4];
  v27 = a6[6];
  *(_OWORD *)(a1 + 208) = a6[5];
  *(_OWORD *)(a1 + 224) = v27;
  *(_OWORD *)(a1 + 176) = v25;
  *(_OWORD *)(a1 + 192) = v26;
  v28 = a6[7];
  v29 = a6[8];
  v30 = a6[10];
  *(_OWORD *)(a1 + 272) = a6[9];
  *(_OWORD *)(a1 + 288) = v30;
  *(_OWORD *)(a1 + 240) = v28;
  *(_OWORD *)(a1 + 256) = v29;
  *(_QWORD *)(a1 + 304) = &off_24C0B07D0;
  *(_QWORD *)(a1 + 312) = a4;
  *(_BYTE *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 336) = 0;
  v74[0] = &off_24C0B2878;
  v74[1] = a1;
  v74[3] = v74;
  *(_QWORD *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 352) = &off_24C0B2878;
  *(_QWORD *)(a1 + 360) = a1;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 400) = 0;
  *(_QWORD *)(a1 + 376) = a1 + 352;
  *(_QWORD *)(a1 + 384) = a1 + 392;
  *(_DWORD *)(a1 + 408) = 0;
  v31 = operator new(0x20uLL);
  *v31 = &off_24C0B28C0;
  v31[1] = dcsctp::DcSctpSocket::OnInitTimerExpiry;
  v31[2] = 0;
  v31[3] = a1;
  v73 = v31;
  v35 = *((_DWORD *)a6 + 22);
  v36 = 1000 * v35;
  if (v35 == 0x7FFFFFFF)
    v36 = 0x7FFFFFFFFFFFFFFFLL;
  v37 = *(_QWORD *)((char *)a6 + 156);
  v65.__r_.__value_.__r.__words[0] = v36;
  LODWORD(v65.__r_.__value_.__r.__words[1]) = 1;
  *(std::string::size_type *)((char *)&v65.__r_.__value_.__r.__words[1] + 4) = v37;
  v66 = 0x7FFFFFFFFFFFFFFFLL;
  v67 = 0;
  dcsctp::TimerManager::CreateTimer(a1 + 352, "t1-init", 7uLL, v72, (uint64_t)&v65, v32, v33, v34, (uint64_t *)(a1 + 416));
  v38 = v73;
  if (v73 == v72)
  {
    v39 = 4;
    v38 = v72;
  }
  else
  {
    if (!v73)
      goto LABEL_34;
    v39 = 5;
  }
  (*(void (**)(void))(*v38 + 8 * v39))();
LABEL_34:
  v40 = a1 + 304;
  v41 = operator new(0x20uLL);
  *v41 = &off_24C0B28C0;
  v41[1] = dcsctp::DcSctpSocket::OnCookieTimerExpiry;
  v41[2] = 0;
  v41[3] = a1;
  v71 = v41;
  v45 = *((_DWORD *)a6 + 23);
  v46 = 1000 * v45;
  if (v45 == 0x7FFFFFFF)
    v46 = 0x7FFFFFFFFFFFFFFFLL;
  v47 = *(_QWORD *)((char *)a6 + 156);
  v65.__r_.__value_.__r.__words[0] = v46;
  LODWORD(v65.__r_.__value_.__r.__words[1]) = 1;
  *(std::string::size_type *)((char *)&v65.__r_.__value_.__r.__words[1] + 4) = v47;
  v66 = 0x7FFFFFFFFFFFFFFFLL;
  v67 = 0;
  dcsctp::TimerManager::CreateTimer(a1 + 352, "t1-cookie", 9uLL, v70, (uint64_t)&v65, v42, v43, v44, (uint64_t *)(a1 + 424));
  v48 = v71;
  if (v71 == v70)
  {
    v49 = 4;
    v48 = v70;
  }
  else
  {
    if (!v71)
      goto LABEL_41;
    v49 = 5;
  }
  (*(void (**)(void))(*v48 + 8 * v49))();
LABEL_41:
  v50 = operator new(0x20uLL);
  *v50 = &off_24C0B28C0;
  v50[1] = dcsctp::DcSctpSocket::OnShutdownTimerExpiry;
  v50[2] = 0;
  v50[3] = a1;
  v69 = v50;
  v54 = *((_DWORD *)a6 + 24);
  v55 = 1000 * v54;
  if (v54 == 0x7FFFFFFF)
    v55 = 0x7FFFFFFFFFFFFFFFLL;
  v56 = *(_QWORD *)((char *)a6 + 148);
  v65.__r_.__value_.__r.__words[0] = v55;
  LODWORD(v65.__r_.__value_.__r.__words[1]) = 1;
  *(std::string::size_type *)((char *)&v65.__r_.__value_.__r.__words[1] + 4) = v56;
  v66 = 0x7FFFFFFFFFFFFFFFLL;
  v67 = 0;
  dcsctp::TimerManager::CreateTimer(a1 + 352, "t2-shutdown", 0xBuLL, v68, (uint64_t)&v65, v51, v52, v53, (uint64_t *)(a1 + 432));
  v57 = v69;
  if (v69 == v68)
  {
    v58 = 4;
    v57 = v68;
  }
  else
  {
    if (!v69)
      goto LABEL_48;
    v58 = 5;
  }
  (*(void (**)(void))(*v57 + 8 * v58))();
LABEL_48:
  v59 = operator new(0x20uLL);
  *v59 = &off_24C0B2908;
  v59[1] = dcsctp::DcSctpSocket::OnSentPacket;
  v59[2] = 0;
  v59[3] = a1;
  *(_QWORD *)(a1 + 440) = v40;
  *(_QWORD *)(a1 + 472) = v59;
  if ((*(char *)(a1 + 31) & 0x80000000) == 0)
  {
    v60 = *(unsigned __int8 *)(a1 + 31);
    goto LABEL_53;
  }
  v60 = *(_QWORD *)(a1 + 16);
  if (v60 < 0)
    goto LABEL_54;
  v6 = (std::string *)v6->__r_.__value_.__r.__words[0];
  if (v60)
  {
    if (!v6)
      goto LABEL_54;
  }
LABEL_53:
  v61 = *(_QWORD *)(a1 + 144);
  v62 = *(_WORD *)(a1 + 160);
  v63 = *(_QWORD *)(a1 + 192);
  *(_QWORD *)(a1 + 480) = &off_24C0BB958;
  *(_QWORD *)(a1 + 488) = v6;
  *(_QWORD *)(a1 + 496) = v60;
  *(_QWORD *)(a1 + 504) = v40;
  *(_WORD *)(a1 + 512) = v62;
  *(_DWORD *)(a1 + 516) = 0;
  *(_QWORD *)(a1 + 520) = v6;
  *(_QWORD *)(a1 + 528) = v60;
  *(_QWORD *)(a1 + 536) = v61 - 32;
  *(_QWORD *)(a1 + 568) = 0;
  *(_QWORD *)(a1 + 584) = 0;
  *(_QWORD *)(a1 + 576) = 0;
  *(_QWORD *)(a1 + 552) = 0;
  *(_QWORD *)(a1 + 544) = 0;
  *(_WORD *)(a1 + 560) = 0;
  *(_QWORD *)(a1 + 616) = a1 + 592;
  *(_QWORD *)(a1 + 592) = &off_24C0BBA10;
  *(_QWORD *)(a1 + 600) = a1 + 480;
  *(_QWORD *)(a1 + 624) = 0;
  *(_QWORD *)(a1 + 648) = 0;
  *(_QWORD *)(a1 + 656) = 0;
  *(_QWORD *)(a1 + 640) = a1 + 648;
  *(_QWORD *)(a1 + 632) = v63;
  *(_QWORD *)(a1 + 664) = 0;
  *(_DWORD *)(a1 + 672) = 0;
  *(_QWORD *)(a1 + 680) = 0;
  return a1;
}

void *dcsctp::DcSctpSocket::OnInitTimerExpiry(void **this)
{
  void *result;
  _QWORD **v3;
  _QWORD **v4;
  _DWORD *v5;
  __int128 v6;
  char *v7;
  int v8;
  int v9;
  _BYTE __p[24];
  void (*v11)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  if (*((_BYTE *)this[52] + 156))
  {
    dcsctp::DcSctpSocket::SendInit((dcsctp::DcSctpSocket *)this);
    return 0;
  }
  if (!*((_DWORD *)this + 168))
    return 0;
  v3 = (_QWORD **)this[53];
  if (*((_BYTE *)v3 + 156))
  {
    (*(void (**)(_QWORD *))(*v3[17] + 24))(v3[17]);
    *((_DWORD *)v3 + 40) = 0;
    *((_BYTE *)v3 + 156) = 0;
  }
  v4 = (_QWORD **)this[54];
  if (*((_BYTE *)v4 + 156))
  {
    (*(void (**)(_QWORD *))(*v4[17] + 24))(v4[17]);
    *((_DWORD *)v4 + 40) = 0;
    *((_BYTE *)v4 + 156) = 0;
  }
  result = this[85];
  this[85] = 0;
  if (result)
    result = (void *)(*(uint64_t (**)(void *))(*(_QWORD *)result + 8))(result);
  v11 = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
  v9 = 1;
  __p[23] = 20;
  if (__p <= "No INIT_ACK received" && &__p[20] > "No INIT_ACK received")
    goto LABEL_20;
  strcpy(__p, "No INIT_ACK received");
  v5 = this[42];
  if (v5 >= this[43])
  {
    v7 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>(this + 41, &v11, (uint64_t)&v9);
    v8 = __p[23];
    this[42] = v7;
    if (v8 < 0)
      operator delete(*(void **)__p);
    goto LABEL_18;
  }
  if (!v5)
  {
LABEL_20:
    __break(1u);
    return result;
  }
  *(_QWORD *)v5 = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
  v5[2] = 1;
  v6 = *(_OWORD *)__p;
  *((_QWORD *)v5 + 4) = *(_QWORD *)&__p[16];
  *((_OWORD *)v5 + 1) = v6;
  *((_QWORD *)v5 + 7) = 2;
  this[42] = v5 + 16;
LABEL_18:
  if (!*((_DWORD *)this + 168))
    return 0;
  *((_DWORD *)this + 168) = 0;
  return 0;
}

uint64_t dcsctp::DcSctpSocket::OnCookieTimerExpiry(dcsctp::DcSctpSocket *this)
{
  uint64_t v2;
  uint64_t v3;
  int64_t v4;
  int v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  char *v11;
  int v12;
  uint64_t v13;
  _BYTE v14[24];
  uint64_t v15;
  void (*v16)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  v2 = *((_QWORD *)this + 53);
  if (*(_BYTE *)(v2 + 156))
  {
    v3 = *((_QWORD *)this + 85);
    v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 39) + 56))(*((_QWORD *)this + 39));
    LODWORD(v13) = *(_DWORD *)(v3 + 248);
    v5 = *(_DWORD *)(v3 + 28);
    WORD2(v13) = *(_DWORD *)(v3 + 24);
    HIWORD(v13) = v5;
    *(_QWORD *)v14 = *(_QWORD *)(v3 + 40) & 0xFFFFFFFFFFFFFFFCLL;
    *(_QWORD *)&v14[8] = 0;
    *(_QWORD *)&v14[16] = 0;
    v15 = 0;
    dcsctp::TransmissionControlBlock::SendBufferedPackets(v3, &v13, v4);
    if (*(_QWORD *)&v14[8])
    {
      *(_QWORD *)&v14[16] = *(_QWORD *)&v14[8];
      operator delete(*(void **)&v14[8]);
    }
    return 0;
  }
  if (!*((_DWORD *)this + 168))
    return 0;
  v7 = *((_QWORD *)this + 52);
  if (*(_BYTE *)(v7 + 156))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v7 + 136) + 24))(*(_QWORD *)(v7 + 136));
    *(_DWORD *)(v7 + 160) = 0;
    *(_BYTE *)(v7 + 156) = 0;
    v2 = *((_QWORD *)this + 53);
  }
  if (*(_BYTE *)(v2 + 156))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 136) + 24))(*(_QWORD *)(v2 + 136));
    *(_DWORD *)(v2 + 160) = 0;
    *(_BYTE *)(v2 + 156) = 0;
  }
  v8 = *((_QWORD *)this + 54);
  if (*(_BYTE *)(v8 + 156))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v8 + 136) + 24))(*(_QWORD *)(v8 + 136));
    *(_DWORD *)(v8 + 160) = 0;
    *(_BYTE *)(v8 + 156) = 0;
  }
  result = *((_QWORD *)this + 85);
  *((_QWORD *)this + 85) = 0;
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  v16 = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
  LODWORD(v13) = 1;
  v14[23] = 22;
  if (v14 > "No COOKIE_ACK received" || &v14[22] <= "No COOKIE_ACK received")
  {
    strcpy(v14, "No COOKIE_ACK received");
    v9 = *((_QWORD *)this + 42);
    if (v9 >= *((_QWORD *)this + 43))
    {
      v11 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &v16, (uint64_t)&v13);
      v12 = v14[23];
      *((_QWORD *)this + 42) = v11;
      if (v12 < 0)
        operator delete(*(void **)v14);
LABEL_21:
      if (*((_DWORD *)this + 168))
      {
        *((_DWORD *)this + 168) = 0;
        return 0;
      }
      return 0;
    }
    if (v9)
    {
      *(_QWORD *)v9 = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      *(_DWORD *)(v9 + 8) = 1;
      v10 = *(_OWORD *)v14;
      *(_QWORD *)(v9 + 32) = *(_QWORD *)&v14[16];
      *(_OWORD *)(v9 + 16) = v10;
      *(_QWORD *)(v9 + 56) = 2;
      *((_QWORD *)this + 42) = v9 + 64;
      goto LABEL_21;
    }
  }
  __break(1u);
  return result;
}

char *dcsctp::DcSctpSocket::OnShutdownTimerExpiry(dcsctp::DcSctpSocket *this)
{
  uint64_t v2;
  char *result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  __int128 v18;
  char *v19;
  int v20;
  void (**v21)(dcsctp::UserInitiatedAbortCause *__hidden);
  void *v22;
  __int128 v23;
  void *v24[2];
  uint64_t v25;
  void (*v26)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  int v27;
  void *__p[2];
  uint64_t v29;
  uint64_t v30;
  _BYTE v31[24];

  if (!*(_BYTE *)(*((_QWORD *)this + 54) + 156))
  {
    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 85) + 88))(&v30);
    v24[0] = 0;
    v24[1] = 0;
    v25 = 0;
    v21 = off_24C0C2EF8;
    result = (char *)operator new(0x28uLL);
    v22 = result;
    v23 = xmmword_208F08620;
    if (result > "Too many retransmissions of SHUTDOWN" || result + 36 <= "Too many retransmissions of SHUTDOWN")
    {
      strcpy(result, "Too many retransmissions of SHUTDOWN");
      dcsctp::UserInitiatedAbortCause::SerializeTo((uint64_t)&v21, (uint64_t)v24, v4, v5, v6, v7, v8, v9);
      v10 = v25;
      v11 = *(_OWORD *)v24;
      v24[1] = 0;
      v25 = 0;
      v24[0] = 0;
      v26 = (void (*)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))&off_24C0ACA10;
      LOBYTE(v27) = 1;
      *(_OWORD *)__p = v11;
      v29 = v10;
      v12 = dcsctp::SctpPacket::Builder::Add((uint64_t)&v30, (uint64_t)&v26);
      dcsctp::PacketSender::Send((_QWORD *)this + 55, v12, 1);
      v26 = (void (*)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))&off_24C0ACA10;
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      v21 = off_24C0C2EF8;
      if (SHIBYTE(v23) < 0)
        operator delete(v22);
      if (v24[0])
      {
        v24[1] = v24[0];
        operator delete(v24[0]);
      }
      if (*(_QWORD *)&v31[8])
      {
        *(_QWORD *)&v31[16] = *(_QWORD *)&v31[8];
        operator delete(*(void **)&v31[8]);
      }
      if (!*((_DWORD *)this + 168))
        return 0;
      v13 = *((_QWORD *)this + 52);
      if (*(_BYTE *)(v13 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v13 + 136) + 24))(*(_QWORD *)(v13 + 136));
        *(_DWORD *)(v13 + 160) = 0;
        *(_BYTE *)(v13 + 156) = 0;
      }
      v14 = *((_QWORD *)this + 53);
      if (*(_BYTE *)(v14 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v14 + 136) + 24))(*(_QWORD *)(v14 + 136));
        *(_DWORD *)(v14 + 160) = 0;
        *(_BYTE *)(v14 + 156) = 0;
      }
      v15 = *((_QWORD *)this + 54);
      if (*(_BYTE *)(v15 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v15 + 136) + 24))(*(_QWORD *)(v15 + 136));
        *(_DWORD *)(v15 + 160) = 0;
        *(_BYTE *)(v15 + 156) = 0;
      }
      v16 = *((_QWORD *)this + 85);
      *((_QWORD *)this + 85) = 0;
      if (v16)
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
      v26 = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      LODWORD(v30) = 1;
      result = (char *)operator new(0x20uLL);
      *(_QWORD *)v31 = result;
      *(_OWORD *)&v31[8] = xmmword_208F08630;
      if (result > "No SHUTDOWN_ACK received" || result + 24 <= "No SHUTDOWN_ACK received")
      {
        strcpy(result, "No SHUTDOWN_ACK received");
        v17 = *((_QWORD *)this + 42);
        if (v17 >= *((_QWORD *)this + 43))
        {
          v19 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &v26, (uint64_t)&v30);
          v20 = v31[23];
          *((_QWORD *)this + 42) = v19;
          if (v20 < 0)
            operator delete(*(void **)v31);
LABEL_31:
          if (*((_DWORD *)this + 168))
          {
            result = 0;
            *((_DWORD *)this + 168) = 0;
            return result;
          }
          return 0;
        }
        if (v17)
        {
          *(_QWORD *)v17 = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
          *(_DWORD *)(v17 + 8) = 1;
          v18 = *(_OWORD *)v31;
          *(_QWORD *)(v17 + 32) = *(_QWORD *)&v31[16];
          *(_OWORD *)(v17 + 16) = v18;
          *(_QWORD *)(v17 + 56) = 2;
          *((_QWORD *)this + 42) = v17 + 64;
          goto LABEL_31;
        }
      }
    }
    __break(1u);
    return result;
  }
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 85) + 88))(&v30);
  v2 = *(_QWORD *)(*((_QWORD *)this + 85) + 464);
  v26 = (void (*)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))&unk_24C0C0CB0;
  v27 = v2;
  dcsctp::SctpPacket::Builder::Add((uint64_t)&v30, (uint64_t)&v26);
  dcsctp::PacketSender::Send((_QWORD *)this + 55, (uint64_t)&v30, 1);
  if (*(_QWORD *)&v31[8])
  {
    *(_QWORD *)&v31[16] = *(_QWORD *)&v31[8];
    operator delete(*(void **)&v31[8]);
  }
  return (char *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 85) + 56))(*((_QWORD *)this + 85));
}

uint64_t dcsctp::DcSctpSocket::OnSentPacket(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v20;
  uint64_t v21;

  v5 = result;
  v6 = *(_QWORD *)(result + 32);
  if (v6)
  {
    v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(result + 312) + 56))(*(_QWORD *)(result + 312));
    v10 = v9 / 0x3E8uLL;
    if (v9 % 0x3E8uLL > 0x1F3)
      ++v10;
    if (-v9 % 0x3E8uLL <= 0x1F4)
      v11 = 0;
    else
      v11 = -1;
    if (v9 < 0)
      v12 = v11 - -v9 / 0x3E8uLL;
    else
      v12 = v10;
    if (a3)
      v13 = a2;
    else
      v13 = 0;
    result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 16))(v6, v12, v13, a3);
  }
  if (!a4)
  {
    v14 = *(_QWORD *)(v5 + 680);
    if (v14)
    {
      v15 = *(_QWORD *)(v14 + 1416);
      if (v15)
      {
        v16 = *(_QWORD *)(v14 + 1432);
        if (*(_BYTE *)(v14 + 1424))
        {
          v17 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v14 + 1400) + 56))(*(_QWORD *)(v14 + 1400));
          v18 = *(_QWORD *)(v14 + 1416);
          v15 = 0x7FFFFFFFFFFFFFFFLL;
          if (v18 != 0x7FFFFFFFFFFFFFFFLL && v17 != 0x7FFFFFFFFFFFFFFFLL)
          {
            v15 = 0x8000000000000000;
            v20 = v17 == 0x8000000000000000 || v18 == 0x8000000000000000;
            v21 = v18 + v17;
            if (!v20)
              v15 = v21;
          }
        }
        if (v15 >= 86400000000)
          v15 = 86400000000;
        *(_QWORD *)(v16 + 144) = v15;
        result = dcsctp::Timer::Start(*(dcsctp::Timer **)(v14 + 1432));
      }
    }
    ++*(_QWORD *)(v5 + 40);
  }
  return result;
}

void dcsctp::DcSctpSocket::SendInit(dcsctp::DcSctpSocket *this)
{
  int v2;
  uint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  __int128 v7;
  int v8;
  __int16 v9;
  __int16 v10;
  unint64_t v11;
  void *__p;
  void *v13;
  uint64_t v14;
  void (**v15)(dcsctp::InitChunk *__hidden);
  int v16;
  int v17;
  int v18;
  int v19;
  void *v20[2];
  uint64_t v21;
  __int128 v22;
  uint64_t v23;

  v22 = 0uLL;
  v23 = 0;
  v2 = *((_DWORD *)this + 167);
  v3 = *((_QWORD *)this + 21);
  HIDWORD(v4) = *((_DWORD *)this + 34);
  LODWORD(v4) = HIDWORD(v4);
  v5 = *((_DWORD *)this + 166);
  v6 = v23;
  v7 = v22;
  v23 = 0;
  v22 = 0uLL;
  v14 = 0;
  v15 = &off_24C0B53F8;
  v16 = v2;
  v17 = v3;
  v18 = v4 >> 16;
  v19 = v5;
  *(_OWORD *)v20 = v7;
  v21 = v6;
  v8 = 0;
  LODWORD(v3) = *((_DWORD *)this + 33);
  v9 = *((_DWORD *)this + 32);
  v10 = v3;
  v11 = *((_QWORD *)this + 18) & 0xFFFFFFFFFFFFFFFCLL;
  __p = 0;
  v13 = 0;
  dcsctp::SctpPacket::Builder::Add((uint64_t)&v8, (uint64_t)&v15);
  dcsctp::PacketSender::Send((_QWORD *)this + 55, (uint64_t)&v8, 1);
  if (__p)
  {
    v13 = __p;
    operator delete(__p);
  }
  v15 = &off_24C0B53F8;
  if (v20[0])
  {
    v20[1] = v20[0];
    operator delete(v20[0]);
  }
  if ((_QWORD)v22)
  {
    *((_QWORD *)&v22 + 1) = v22;
    operator delete((void *)v22);
  }
}

void dcsctp::`anonymous namespace'::AddCapabilityParameters(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  char *v13;
  unint64_t v14;
  unint64_t v15;
  _BYTE *v16;
  unint64_t v17;
  uint64_t v18;
  size_t v19;
  char *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  char *v30;
  char *v31;
  char *v32;
  int v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  int v38;
  void (**v39)(dcsctp::SupportedExtensionsParameter *__hidden);
  void *__p;
  uint64_t v41;
  char *v42;

  v12 = operator new(1uLL);
  *v12 = -126;
  v13 = v12 + 1;
  if (*(_BYTE *)(a1 + 164))
  {
    v14 = *(_QWORD *)(a3 + 8) - *(_QWORD *)a3;
    if ((v14 & 3) != 0)
    {
      v15 = (v14 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      if (v15 <= v14)
      {
        if (v15 < v14)
          *(_QWORD *)(a3 + 8) = *(_QWORD *)a3 + v15;
      }
      else
      {
        std::vector<unsigned char>::__append((char **)a3, v15 - v14);
      }
    }
    dcsctp::ForwardTsnSupportedParameter::SerializeTo((uint64_t)&v39, a3);
    v16 = operator new(2uLL);
    v16[1] = -64;
    *v16 = *v12;
    v13 = v16 + 2;
    operator delete(v12);
    v12 = v16;
  }
  if (!*(_BYTE *)(a1 + 165))
  {
    v26 = (uint64_t)v13;
    v23 = v12;
    if (!a2)
      goto LABEL_39;
LABEL_33:
    v33 = *(_DWORD *)(a1 + 168);
    v39 = (void (**)(dcsctp::SupportedExtensionsParameter *__hidden))&unk_24C0C68B8;
    LODWORD(__p) = v33;
    v34 = *(_QWORD *)(a3 + 8) - *(_QWORD *)a3;
    if ((v34 & 3) != 0)
    {
      v35 = (v34 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      if (v35 <= v34)
      {
        if (v35 < v34)
          *(_QWORD *)(a3 + 8) = *(_QWORD *)a3 + v35;
      }
      else
      {
        std::vector<unsigned char>::__append((char **)a3, v35 - v34);
      }
    }
    dcsctp::ZeroChecksumAcceptableChunkParameter::SerializeTo((uint64_t)&v39, a3);
    goto LABEL_39;
  }
  v17 = v13 - v12;
  v18 = v13 - v12 + 1;
  if (v18 < 0)
    goto LABEL_47;
  if (2 * v17 > v18)
    v18 = 2 * v17;
  if (v17 >= 0x3FFFFFFFFFFFFFFFLL)
    v19 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v19 = v18;
  if (!v19)
    goto LABEL_48;
  v38 = a2;
  v20 = (char *)operator new(v19);
  v21 = (unint64_t)&v20[v19];
  v22 = &v20[v17];
  v20[v17] = 64;
  v23 = &v20[v17];
  if (v13 != v12)
  {
    v24 = v20;
    memcpy(v20, v12, v13 - v12);
    v13 = v12;
    v23 = v24;
  }
  operator delete(v13);
  v25 = v22 + 1;
  if ((unint64_t)(v22 + 1) >= v21)
  {
    v27 = v25 - v23;
    v28 = v25 - v23 + 1;
    if (v28 >= 0)
    {
      if (2 * (v21 - (unint64_t)v23) > v28)
        v28 = 2 * (v21 - (_QWORD)v23);
      if (v21 - (unint64_t)v23 >= 0x3FFFFFFFFFFFFFFFLL)
        v29 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v29 = v28;
      if (v29)
      {
        v30 = (char *)operator new(v29);
        v13 = &v30[v29];
        v31 = &v30[v27];
        v30[v27] = -62;
        v26 = (uint64_t)&v30[v27 + 1];
        if (v25 != v23)
        {
          v32 = v30;
          memcpy(v30, v23, v25 - v23);
          v31 = v32;
        }
        operator delete(v23);
        v23 = v31;
        if (!v38)
          goto LABEL_39;
        goto LABEL_33;
      }
LABEL_48:
      __break(1u);
      return;
    }
LABEL_47:
    abort();
  }
  v22[1] = -62;
  v26 = (uint64_t)(v22 + 2);
  v13 = (char *)v21;
  if (v38)
    goto LABEL_33;
LABEL_39:
  v39 = &off_24C0C1B88;
  __p = v23;
  v41 = v26;
  v42 = v13;
  v36 = *(_QWORD *)(a3 + 8) - *(_QWORD *)a3;
  if ((v36 & 3) != 0)
  {
    v37 = (v36 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    if (v37 <= v36)
    {
      if (v37 < v36)
        *(_QWORD *)(a3 + 8) = *(_QWORD *)a3 + v37;
    }
    else
    {
      std::vector<unsigned char>::__append((char **)a3, v37 - v36);
    }
  }
  dcsctp::SupportedExtensionsParameter::SerializeTo((uint64_t)&v39, a3, v6, v7, v8, v9, v10, v11);
  if (__p)
    operator delete(__p);
}

void dcsctp::DcSctpSocket::Connect(dcsctp::DcSctpSocket *this)
{
  *((_BYTE *)this + 320) = 1;
  if (*((_DWORD *)this + 168)
    || (*((_DWORD *)this + 166) = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 0, 0xFFFFFFFFLL), *((_DWORD *)this + 167) = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL), dcsctp::DcSctpSocket::SendInit(this), dcsctp::Timer::Start(*((dcsctp::Timer **)this + 52)), *((_DWORD *)this + 168) == 1))
  {
    dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::DcSctpSocket *)((char *)this + 304));
  }
  else
  {
    *((_DWORD *)this + 168) = 1;
    dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::DcSctpSocket *)((char *)this + 304));
  }
}

uint64_t dcsctp::DcSctpSocket::CreateTransmissionControlBlock(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t result;
  _QWORD v23[3];
  _QWORD *v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  *(_BYTE *)(a1 + 120) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 121) = *(_BYTE *)(a2 + 3);
  *(_DWORD *)(a1 + 122) = *(_DWORD *)(a2 + 4);
  v16 = (_QWORD *)(a1 + 8);
  v17 = operator new();
  v18 = v17;
  if (*(char *)(a1 + 31) < 0)
  {
    v19 = *(_QWORD *)(a1 + 16);
    if (v19 < 0 || (v16 = (_QWORD *)*v16, v19) && !v16)
      __break(1u);
  }
  else
  {
    v19 = *(unsigned __int8 *)(a1 + 31);
  }
  v23[0] = &off_24C0B2830;
  v23[1] = a1;
  v24 = v23;
  dcsctp::TransmissionControlBlock::TransmissionControlBlock(v17, a1 + 352, (uint64_t)v16, v19, a1 + 128, a2, a1 + 304, a1 + 480, a3, 0, a4, 0, a5, 0, a6, a7, a8, a1 + 440, (uint64_t)v23);
  v20 = v24;
  if (v24 == v23)
  {
    v21 = 4;
    v20 = v23;
  }
  else
  {
    if (!v24)
      goto LABEL_11;
    v21 = 5;
  }
  (*(void (**)(void))(*v20 + 8 * v21))();
LABEL_11:
  result = *(_QWORD *)(a1 + 680);
  *(_QWORD *)(a1 + 680) = v18;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void dcsctp::DcSctpSocket::RestoreFromState(uint64_t a1, uint64_t a2)
{
  char *v3;
  unint64_t v4;
  __int128 v5;
  int v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  BOOL v12;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t v15;
  char *v16;
  int v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  _BOOL4 v24;
  uint64_t v25;
  uint64_t (**v26)(uint64_t, uint64_t);
  _QWORD *v27;
  uint64_t (*v28)(uint64_t, uint64_t);
  _BYTE __p[24];
  void (*v30)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  *(_BYTE *)(a1 + 320) = 1;
  if (!*(_DWORD *)(a1 + 672))
  {
    if (*(_DWORD *)a2 != 1)
      goto LABEL_37;
    v7 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 668) = v7;
    v8 = *(_DWORD *)(a2 + 36);
    LODWORD(v30) = *(_DWORD *)(a2 + 32);
    HIDWORD(v30) = v8;
    dcsctp::RRSendQueue::RestoreFromState(a1 + 480, a2);
    dcsctp::DcSctpSocket::CreateTransmissionControlBlock(a1, (uint64_t)&v30, v7, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12), *(_DWORD *)(a2 + 16), 0, *(_QWORD *)(a2 + 24));
    v9 = *(_QWORD *)(a1 + 680);
    *(_BYTE *)(v9 + 424) = *(_BYTE *)(a2 + 88);
    v10 = *(_DWORD *)(a2 + 92);
    if (*(_BYTE *)(v9 + 460))
    {
      v11 = *(_DWORD *)(v9 + 456);
      v12 = v10 >= v11;
      v13 = v10 - v11;
      v14 = (_DWORD)v13 != 0 && v12;
      if ((_DWORD)v13 != 0x80000000)
        v14 = (int)v13 >= 0;
      if (!v14)
        v13 |= 0xFFFFFFFF00000000;
      v15 = v13 + *(_QWORD *)(v9 + 448);
    }
    else
    {
      v15 = *(unsigned int *)(a2 + 92);
    }
    *(_QWORD *)(v9 + 448) = v15;
    *(_DWORD *)(v9 + 456) = v10;
    *(_BYTE *)(v9 + 460) = 1;
    *(_QWORD *)(v9 + 464) = v15;
    v18 = *(_QWORD *)(a2 + 48);
    *(_QWORD *)&v19 = v18;
    *((_QWORD *)&v19 + 1) = HIDWORD(v18);
    *(_OWORD *)(v9 + 984) = v19;
    v20 = *(_QWORD *)(a2 + 56);
    *(_QWORD *)&v19 = v20;
    *((_QWORD *)&v19 + 1) = HIDWORD(v20);
    *(_OWORD *)(v9 + 1000) = v19;
    v21 = *(_DWORD *)(a2 + 40) - 1;
    if (*(_BYTE *)(v9 + 980))
    {
      v22 = *(_DWORD *)(v9 + 976);
      v12 = v21 >= v22;
      v23 = v21 - v22;
      v24 = (_DWORD)v23 != 0 && v12;
      if ((_DWORD)v23 != 0x80000000)
        v24 = (int)v23 >= 0;
      if (!v24)
        v23 |= 0xFFFFFFFF00000000;
      v25 = v23 + *(_QWORD *)(v9 + 968);
    }
    else
    {
      v25 = (*(_DWORD *)(a2 + 40) - 1);
    }
    *(_QWORD *)(v9 + 968) = v25;
    *(_DWORD *)(v9 + 976) = v21;
    *(_BYTE *)(v9 + 980) = 1;
    *(_QWORD *)(v9 + 1064) = v25;
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v9 + 664) + 56))(*(_QWORD *)(v9 + 664), a2);
    if (*(_DWORD *)(a1 + 672) != 3)
      *(_DWORD *)(a1 + 672) = 3;
    v28 = dcsctp::CallbackDeferrer::OnConnected(void)::$_0::__invoke;
    v26 = *(uint64_t (***)(uint64_t, uint64_t))(a1 + 336);
    if ((unint64_t)v26 >= *(_QWORD *)(a1 + 344))
    {
      v27 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::monostate>((void **)(a1 + 328), &v28);
    }
    else
    {
      if (!v26)
        goto LABEL_38;
      *v26 = dcsctp::CallbackDeferrer::OnConnected(void)::$_0::__invoke;
      v26[7] = 0;
      v27 = v26 + 8;
    }
    *(_QWORD *)(a1 + 336) = v27;
    goto LABEL_37;
  }
  v30 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
  LODWORD(v28) = 8;
  v3 = (char *)operator new(0x30uLL);
  *(_QWORD *)__p = v3;
  *(_OWORD *)&__p[8] = xmmword_208F08640;
  if (v3 > "Only closed socket can be restored from state"
    || v3 + 45 <= "Only closed socket can be restored from state")
  {
    strcpy(v3, "Only closed socket can be restored from state");
    v4 = *(_QWORD *)(a1 + 336);
    if (v4 >= *(_QWORD *)(a1 + 344))
    {
      v16 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)(a1 + 328), &v30, (uint64_t)&v28);
      v17 = __p[23];
      *(_QWORD *)(a1 + 336) = v16;
      if (v17 < 0)
        operator delete(*(void **)__p);
      goto LABEL_37;
    }
    if (v4)
    {
      *(_QWORD *)v4 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      *(_DWORD *)(v4 + 8) = 8;
      v5 = *(_OWORD *)__p;
      *(_QWORD *)(v4 + 32) = *(_QWORD *)&__p[16];
      *(_OWORD *)(v4 + 16) = v5;
      *(_QWORD *)(v4 + 56) = 2;
      *(_QWORD *)(a1 + 336) = v4 + 64;
LABEL_37:
      dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::CallbackDeferrer *)(a1 + 304));
      return;
    }
  }
LABEL_38:
  __break(1u);
}

void dcsctp::DcSctpSocket::Shutdown(dcsctp::DcSctpSocket *this)
{
  int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t (**v8)(uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t);

  *((_BYTE *)this + 320) = 1;
  v2 = *((_DWORD *)this + 168);
  if (!*((_QWORD *)this + 85))
  {
    if (v2)
    {
      v4 = *((_QWORD *)this + 52);
      if (*(_BYTE *)(v4 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v4 + 136) + 24))(*(_QWORD *)(v4 + 136));
        *(_DWORD *)(v4 + 160) = 0;
        *(_BYTE *)(v4 + 156) = 0;
      }
      v5 = *((_QWORD *)this + 53);
      if (*(_BYTE *)(v5 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v5 + 136) + 24))(*(_QWORD *)(v5 + 136));
        *(_DWORD *)(v5 + 160) = 0;
        *(_BYTE *)(v5 + 156) = 0;
      }
      v6 = *((_QWORD *)this + 54);
      if (*(_BYTE *)(v6 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v6 + 136) + 24))(*(_QWORD *)(v6 + 136));
        *(_DWORD *)(v6 + 160) = 0;
        *(_BYTE *)(v6 + 156) = 0;
      }
      v7 = *((_QWORD *)this + 85);
      *((_QWORD *)this + 85) = 0;
      if (v7)
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
      v11 = dcsctp::CallbackDeferrer::OnClosed(void)::$_0::__invoke;
      v8 = (uint64_t (**)(uint64_t, uint64_t))*((_QWORD *)this + 42);
      if ((unint64_t)v8 >= *((_QWORD *)this + 43))
      {
        *((_QWORD *)this + 42) = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::monostate>((void **)this + 41, &v11);
        if (!*((_DWORD *)this + 168))
          goto LABEL_8;
      }
      else
      {
        if (!v8)
        {
          __break(1u);
          return;
        }
        *v8 = dcsctp::CallbackDeferrer::OnClosed(void)::$_0::__invoke;
        v8[7] = 0;
        *((_QWORD *)this + 42) = v8 + 8;
        if (!*((_DWORD *)this + 168))
          goto LABEL_8;
      }
      *((_DWORD *)this + 168) = 0;
      dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::DcSctpSocket *)((char *)this + 304));
      return;
    }
LABEL_8:
    dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::DcSctpSocket *)((char *)this + 304));
    return;
  }
  if (v2 != 4)
  {
    if (v2 != 5 && v2 != 7)
    {
      *((_DWORD *)this + 168) = 4;
      goto LABEL_23;
    }
    goto LABEL_8;
  }
LABEL_23:
  v9 = *((_QWORD *)this + 52);
  if (*(_BYTE *)(v9 + 156))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v9 + 136) + 24))(*(_QWORD *)(v9 + 136));
    *(_DWORD *)(v9 + 160) = 0;
    *(_BYTE *)(v9 + 156) = 0;
  }
  v10 = *((_QWORD *)this + 53);
  if (*(_BYTE *)(v10 + 156))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v10 + 136) + 24))(*(_QWORD *)(v10 + 136));
    *(_DWORD *)(v10 + 160) = 0;
    *(_BYTE *)(v10 + 156) = 0;
  }
  dcsctp::DcSctpSocket::MaybeSendShutdownOrAck(this);
  dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::DcSctpSocket *)((char *)this + 304));
}

_QWORD *dcsctp::DcSctpSocket::MaybeSendShutdownOrAck(dcsctp::DcSctpSocket *this)
{
  _QWORD *result;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  int v13;
  void *v14[2];
  void *__p;
  void *v16;

  result = (_QWORD *)*((_QWORD *)this + 85);
  if (!result[144])
  {
    v3 = *((_DWORD *)this + 168);
    if (v3 == 6)
    {
      (*(void (**)(void **__return_ptr))(*result + 88))(v14);
      v12 = &unk_24C0C0C80;
      v8 = dcsctp::SctpPacket::Builder::Add((uint64_t)v14, (uint64_t)&v12);
      dcsctp::PacketSender::Send((_QWORD *)this + 55, v8, 1);
      if (__p)
      {
        v16 = __p;
        operator delete(__p);
      }
      v9 = *((_QWORD *)this + 54);
      v10 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 85) + 56))(*((_QWORD *)this + 85));
      v11 = 86400000000;
      if (v10 < 86400000000)
        v11 = v10;
      *(_QWORD *)(v9 + 144) = v11;
      result = (_QWORD *)dcsctp::Timer::Start(*((dcsctp::Timer **)this + 54));
      if (*((_DWORD *)this + 168) != 7)
        *((_DWORD *)this + 168) = 7;
    }
    else if (v3 == 4)
    {
      (*(void (**)(void **__return_ptr))(*result + 88))(v14);
      v4 = *(_QWORD *)(*((_QWORD *)this + 85) + 464);
      v12 = &unk_24C0C0CB0;
      v13 = v4;
      dcsctp::SctpPacket::Builder::Add((uint64_t)v14, (uint64_t)&v12);
      dcsctp::PacketSender::Send((_QWORD *)this + 55, (uint64_t)v14, 1);
      if (__p)
      {
        v16 = __p;
        operator delete(__p);
      }
      v5 = *((_QWORD *)this + 54);
      v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 85) + 56))(*((_QWORD *)this + 85));
      v7 = 86400000000;
      if (v6 < 86400000000)
        v7 = v6;
      *(_QWORD *)(v5 + 144) = v7;
      result = (_QWORD *)dcsctp::Timer::Start(*((dcsctp::Timer **)this + 54));
      if (*((_DWORD *)this + 168) != 5)
        *((_DWORD *)this + 168) = 5;
    }
  }
  return result;
}

void dcsctp::DcSctpSocket::Close(dcsctp::DcSctpSocket *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (**v15)(uint64_t, uint64_t);
  void (**v16)(dcsctp::UserInitiatedAbortCause *__hidden);
  void *v17[2];
  char v18;
  void *v19[2];
  uint64_t v20;
  void (**v21)(dcsctp::AbortChunk *__hidden);
  char v22;
  void *__p[2];
  uint64_t v24;
  _QWORD v25[2];
  void *v26;
  void *v27;

  *((_BYTE *)this + 320) = 1;
  if (!*((_DWORD *)this + 168))
    goto LABEL_28;
  v2 = *((_QWORD *)this + 85);
  if (v2)
  {
    (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)v2 + 88))(v25);
    v19[0] = 0;
    v19[1] = 0;
    v20 = 0;
    v16 = off_24C0C2EF8;
    v18 = 12;
    if (v17 <= (void **)"Close called" && (char *)&v17[1] + 4 > "Close called")
      goto LABEL_29;
    strcpy((char *)v17, "Close called");
    dcsctp::UserInitiatedAbortCause::SerializeTo((uint64_t)&v16, (uint64_t)v19, v3, v4, v5, v6, v7, v8);
    v9 = v20;
    v10 = *(_OWORD *)v19;
    v19[1] = 0;
    v20 = 0;
    v19[0] = 0;
    v21 = &off_24C0ACA10;
    v22 = 1;
    *(_OWORD *)__p = v10;
    v24 = v9;
    dcsctp::SctpPacket::Builder::Add((uint64_t)v25, (uint64_t)&v21);
    v21 = &off_24C0ACA10;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v16 = off_24C0C2EF8;
    if (v18 < 0)
      operator delete(v17[0]);
    if (v19[0])
    {
      v19[1] = v19[0];
      operator delete(v19[0]);
    }
    dcsctp::PacketSender::Send((_QWORD *)this + 55, (uint64_t)v25, 1);
    if (v26)
    {
      v27 = v26;
      operator delete(v26);
    }
    if (!*((_DWORD *)this + 168))
      goto LABEL_28;
  }
  v11 = *((_QWORD *)this + 52);
  if (*(_BYTE *)(v11 + 156))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v11 + 136) + 24))(*(_QWORD *)(v11 + 136));
    *(_DWORD *)(v11 + 160) = 0;
    *(_BYTE *)(v11 + 156) = 0;
  }
  v12 = *((_QWORD *)this + 53);
  if (*(_BYTE *)(v12 + 156))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v12 + 136) + 24))(*(_QWORD *)(v12 + 136));
    *(_DWORD *)(v12 + 160) = 0;
    *(_BYTE *)(v12 + 156) = 0;
  }
  v13 = *((_QWORD *)this + 54);
  if (*(_BYTE *)(v13 + 156))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v13 + 136) + 24))(*(_QWORD *)(v13 + 136));
    *(_DWORD *)(v13 + 160) = 0;
    *(_BYTE *)(v13 + 156) = 0;
  }
  v14 = *((_QWORD *)this + 85);
  *((_QWORD *)this + 85) = 0;
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  v25[0] = dcsctp::CallbackDeferrer::OnClosed(void)::$_0::__invoke;
  v15 = (uint64_t (**)(uint64_t, uint64_t))*((_QWORD *)this + 42);
  if ((unint64_t)v15 >= *((_QWORD *)this + 43))
  {
    *((_QWORD *)this + 42) = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::monostate>((void **)this + 41, v25);
    if (!*((_DWORD *)this + 168))
    {
LABEL_28:
      dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::DcSctpSocket *)((char *)this + 304));
      return;
    }
LABEL_27:
    *((_DWORD *)this + 168) = 0;
    goto LABEL_28;
  }
  if (v15)
  {
    *v15 = dcsctp::CallbackDeferrer::OnClosed(void)::$_0::__invoke;
    v15[7] = 0;
    *((_QWORD *)this + 42) = v15 + 8;
    if (!*((_DWORD *)this + 168))
      goto LABEL_28;
    goto LABEL_27;
  }
LABEL_29:
  __break(1u);
}

unsigned __int16 *dcsctp::DcSctpSocket::SetStreamPriority(uint64_t a1, unsigned __int16 a2, unsigned __int16 a3)
{
  unsigned __int16 *result;
  uint64_t v5;
  double v6;

  result = dcsctp::RRSendQueue::GetOrCreateStreamInfo(a1 + 480, a2);
  v5 = *((_QWORD *)result + 2);
  *(_WORD *)(v5 + 18) = a3;
  v6 = 1.0 / (double)a3;
  if (!a3)
    v6 = 1000000.0;
  *(double *)(v5 + 24) = v6;
  return result;
}

uint64_t dcsctp::DcSctpSocket::GetStreamPriority(uint64_t a1, unsigned __int16 a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  uint64_t *v6;

  v2 = *(_QWORD *)(a1 + 648);
  if (!v2)
    return *(unsigned __int16 *)(a1 + 512);
  v3 = a1 + 648;
  do
  {
    v4 = *(unsigned __int16 *)(v2 + 32);
    v5 = v4 >= a2;
    if (v4 >= a2)
      v6 = (uint64_t *)v2;
    else
      v6 = (uint64_t *)(v2 + 8);
    if (v5)
      v3 = v2;
    v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 648 && *(unsigned __int16 *)(v3 + 32) <= a2)
    return *(unsigned __int16 *)(*(_QWORD *)(v3 + 56) + 18);
  else
    return *(unsigned __int16 *)(a1 + 512);
}

unint64_t dcsctp::DcSctpSocket::Send(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v11;
  void *__p[2];
  uint64_t v13;
  void *v14[2];
  void *v15;
  void *v16;
  uint64_t v17;

  *(_BYTE *)(a1 + 320) = 1;
  v6 = dcsctp::DcSctpSocket::InternalSend(a1, (unsigned __int16 *)a2, *(_QWORD *)(a3 + 32));
  if (!(_DWORD)v6)
  {
    v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 312) + 56))(*(_QWORD *)(a1 + 312));
    ++*(_QWORD *)(a1 + 48);
    v11 = *a2;
    *(_OWORD *)__p = *(_OWORD *)(a2 + 1);
    v13 = a2[3];
    a2[1] = 0;
    a2[2] = 0;
    a2[3] = 0;
    dcsctp::RRSendQueue::Add(a1 + 480, v7, (uint64_t)&v11, (char *)a3);
    if (__p[0])
      operator delete(__p[0]);
    v8 = *(_QWORD *)(a1 + 680);
    if (v8)
    {
      LODWORD(v14[0]) = *(_DWORD *)(v8 + 248);
      v9 = *(_DWORD *)(v8 + 28);
      WORD2(v14[0]) = *(_DWORD *)(v8 + 24);
      HIWORD(v14[0]) = v9;
      v14[1] = (void *)(*(_QWORD *)(v8 + 40) & 0xFFFFFFFFFFFFFFFCLL);
      v15 = 0;
      v16 = 0;
      v17 = 0;
      dcsctp::TransmissionControlBlock::SendBufferedPackets(v8, v14, v7);
      if (v15)
      {
        v16 = v15;
        operator delete(v15);
      }
    }
  }
  dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::CallbackDeferrer *)(a1 + 304));
  return v6;
}

unint64_t dcsctp::DcSctpSocket::InternalSend(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  unint64_t v4;
  unint64_t result;
  unint64_t v6;
  __int128 v7;
  unint64_t v8;
  __int128 v9;
  unint64_t v10;
  __int128 v11;
  char *v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  int v21;
  char *v22;
  int v23;
  unint64_t v24;
  __int128 v25;
  char *v26;
  int v27;
  int v28;
  _BYTE __p[24];
  void (*v30)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  v4 = *((_QWORD *)a2 + 2) - *((_QWORD *)a2 + 1);
  if (!v4)
  {
    if (a3)
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 312) + 192))(*(_QWORD *)(a1 + 312), a3);
    v30 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
    v28 = 6;
    result = (unint64_t)operator new(0x20uLL);
    *(_QWORD *)__p = result;
    *(_OWORD *)&__p[8] = xmmword_208F05180;
    if (result > (unint64_t)"Unable to send empty message"
      || result + 28 <= (unint64_t)"Unable to send empty message")
    {
      strcpy((char *)result, "Unable to send empty message");
      v8 = *(_QWORD *)(a1 + 336);
      if (v8 < *(_QWORD *)(a1 + 344))
      {
        if (v8)
        {
          *(_QWORD *)v8 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
          *(_DWORD *)(v8 + 8) = 6;
          v9 = *(_OWORD *)__p;
          *(_QWORD *)(v8 + 32) = *(_QWORD *)&__p[16];
          *(_OWORD *)(v8 + 16) = v9;
          *(_QWORD *)(v8 + 56) = 2;
          *(_QWORD *)(a1 + 336) = v8 + 64;
          return 1;
        }
        goto LABEL_59;
      }
      v12 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)(a1 + 328), &v30, (uint64_t)&v28);
      v13 = __p[23];
      *(_QWORD *)(a1 + 336) = v12;
      if (v13 < 0)
        operator delete(*(void **)__p);
      return 1;
    }
LABEL_59:
    __break(1u);
    return result;
  }
  if (v4 <= *(_QWORD *)(a1 + 152))
  {
    if ((*(_DWORD *)(a1 + 672) & 0xFFFFFFFC) == 4)
    {
      if (a3)
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 312) + 192))(*(_QWORD *)(a1 + 312), a3);
      v30 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      v28 = 4;
      result = (unint64_t)operator new(0x38uLL);
      *(_QWORD *)__p = result;
      *(_OWORD *)&__p[8] = xmmword_208F08660;
      if (result > (unint64_t)"Unable to send message as the socket is shutting down"
        || result + 53 <= (unint64_t)"Unable to send message as the socket is shutting down")
      {
        strcpy((char *)result, "Unable to send message as the socket is shutting down");
        v10 = *(_QWORD *)(a1 + 336);
        if (v10 < *(_QWORD *)(a1 + 344))
        {
          if (v10)
          {
            *(_QWORD *)v10 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
            *(_DWORD *)(v10 + 8) = 4;
            v11 = *(_OWORD *)__p;
            *(_QWORD *)(v10 + 32) = *(_QWORD *)&__p[16];
            *(_OWORD *)(v10 + 16) = v11;
            *(_QWORD *)(v10 + 56) = 2;
            *(_QWORD *)(a1 + 336) = v10 + 64;
            return 4;
          }
          goto LABEL_59;
        }
        v22 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)(a1 + 328), &v30, (uint64_t)&v28);
        v23 = __p[23];
        *(_QWORD *)(a1 + 336) = v22;
        if (v23 < 0)
          operator delete(*(void **)__p);
        return 4;
      }
      goto LABEL_59;
    }
    if (*(_QWORD *)(a1 + 624) < *(_QWORD *)(a1 + 176))
    {
      v14 = *(_QWORD *)(a1 + 648);
      if (!v14)
        goto LABEL_62;
      v15 = *a2;
      v16 = a1 + 648;
      do
      {
        v17 = *(unsigned __int16 *)(v14 + 32);
        v18 = v17 >= v15;
        if (v17 >= v15)
          v19 = (uint64_t *)v14;
        else
          v19 = (uint64_t *)(v14 + 8);
        if (v18)
          v16 = v14;
        v14 = *v19;
      }
      while (*v19);
      if (v16 != a1 + 648 && *(unsigned __int16 *)(v16 + 32) <= v15)
      {
        if (*(_QWORD *)(v16 + 160) < *(_QWORD *)(a1 + 184))
          return 0;
      }
      else
      {
LABEL_62:
        if (*(_QWORD *)(a1 + 184))
          return 0;
      }
    }
    if (a3)
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 312) + 192))(*(_QWORD *)(a1 + 312), a3);
    v30 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
    v28 = 7;
    result = (unint64_t)operator new(0x38uLL);
    *(_QWORD *)__p = result;
    *(_OWORD *)&__p[8] = xmmword_208F08650;
    if (result > (unint64_t)"Unable to send message as the send queue is full"
      || result + 48 <= (unint64_t)"Unable to send message as the send queue is full")
    {
      strcpy((char *)result, "Unable to send message as the send queue is full");
      v24 = *(_QWORD *)(a1 + 336);
      if (v24 < *(_QWORD *)(a1 + 344))
      {
        if (v24)
        {
          *(_QWORD *)v24 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
          *(_DWORD *)(v24 + 8) = 7;
          v25 = *(_OWORD *)__p;
          *(_QWORD *)(v24 + 32) = *(_QWORD *)&__p[16];
          *(_OWORD *)(v24 + 16) = v25;
          *(_QWORD *)(v24 + 56) = 2;
          *(_QWORD *)(a1 + 336) = v24 + 64;
          return 3;
        }
        goto LABEL_59;
      }
      v26 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)(a1 + 328), &v30, (uint64_t)&v28);
      v27 = __p[23];
      *(_QWORD *)(a1 + 336) = v26;
      if (v27 < 0)
        operator delete(*(void **)__p);
      return 3;
    }
    goto LABEL_59;
  }
  if (a3)
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 312) + 192))(*(_QWORD *)(a1 + 312), a3);
  v30 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
  v28 = 6;
  result = (unint64_t)operator new(0x28uLL);
  *(_QWORD *)__p = result;
  *(_OWORD *)&__p[8] = xmmword_208F04EE0;
  if (result <= (unint64_t)"Unable to send too large message"
    && result + 32 > (unint64_t)"Unable to send too large message")
  {
    goto LABEL_59;
  }
  strcpy((char *)result, "Unable to send too large message");
  v6 = *(_QWORD *)(a1 + 336);
  if (v6 < *(_QWORD *)(a1 + 344))
  {
    if (v6)
    {
      *(_QWORD *)v6 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      *(_DWORD *)(v6 + 8) = 6;
      v7 = *(_OWORD *)__p;
      *(_QWORD *)(v6 + 32) = *(_QWORD *)&__p[16];
      *(_OWORD *)(v6 + 16) = v7;
      *(_QWORD *)(v6 + 56) = 2;
      *(_QWORD *)(a1 + 336) = v6 + 64;
      return 2;
    }
    goto LABEL_59;
  }
  v20 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)(a1 + 328), &v30, (uint64_t)&v28);
  v21 = __p[23];
  *(_QWORD *)(a1 + 336) = v20;
  if (v21 < 0)
    operator delete(*(void **)__p);
  return 2;
}

void dcsctp::DcSctpSocket::SendMany(uint64_t a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, char **a5@<X8>)
{
  _QWORD *v8;
  char *v10;
  char *v11;
  uint64_t *v12;
  char *v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  _BYTE *v19;
  char *v20;
  int v21;
  char *v22;
  unint64_t v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _OWORD *v28;
  char *v29;
  uint64_t v30;
  __int128 v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  void *__p[2];
  uint64_t v42;
  void *v43[2];
  void *v44;
  void *v45;
  uint64_t v46;

  v8 = (_QWORD *)a1;
  *(_BYTE *)(a1 + 320) = 1;
  v36 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 312) + 56))(*(_QWORD *)(a1 + 312));
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  if (a3)
  {
    if (a3 >> 62)
LABEL_37:
      abort();
    v10 = (char *)operator new(4 * a3);
    v11 = &v10[4 * a3];
    *a5 = v10;
    a5[2] = v11;
    v12 = &a2[4 * a3];
    v35 = (uint64_t)(v8 + 60);
    v13 = v10;
    v38 = v12;
    v39 = a4;
    v37 = v8;
    while (1)
    {
      v14 = dcsctp::DcSctpSocket::InternalSend((uint64_t)v8, (unsigned __int16 *)a2, *(_QWORD *)(a4 + 32));
      if (v10 >= v11)
        break;
      *(_DWORD *)v10 = v14;
      v10 += 4;
      a5[1] = v10;
      if (!v14)
        goto LABEL_31;
LABEL_4:
      a2 += 4;
      if (a2 == v12)
        goto LABEL_33;
    }
    v15 = (v10 - v13) >> 2;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 62)
      goto LABEL_37;
    if ((v11 - v13) >> 1 > v16)
      v16 = (v11 - v13) >> 1;
    if ((unint64_t)(v11 - v13) >= 0x7FFFFFFFFFFFFFFCLL)
      v16 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v16)
    {
      __break(1u);
LABEL_39:
      std::__throw_bad_array_new_length[abi:sn180100]();
    }
    if (v16 >> 62)
      goto LABEL_39;
    v17 = v14;
    v18 = 4 * v16;
    v19 = operator new(4 * v16);
    v20 = &v19[4 * v15];
    v21 = v17;
    *(_DWORD *)v20 = v17;
    v22 = v20 + 4;
    if (v10 == v13)
      goto LABEL_28;
    v23 = v10 - v13 - 4;
    if (v23 < 0xBC)
    {
      v24 = v10;
      goto LABEL_27;
    }
    v25 = (v10 - 4 - v13) & 0xFFFFFFFFFFFFFFFCLL;
    if (&v19[v10 - v13 - 4 - v25] > &v19[v10 - v13 - 4])
    {
      v24 = v10;
    }
    else
    {
      if (&v10[-v25 - 4] <= v10 - 4)
      {
        if ((unint64_t)(v13 - v19) < 0x20)
        {
          v24 = v10;
          goto LABEL_27;
        }
        v26 = (v23 >> 2) + 1;
        v27 = 4 * (v26 & 0x7FFFFFFFFFFFFFF8);
        v24 = &v10[-v27];
        v20 -= v27;
        v28 = &v19[4 * v15 - 16];
        v29 = v10 - 16;
        v30 = v26 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v31 = *(_OWORD *)v29;
          *(v28 - 1) = *((_OWORD *)v29 - 1);
          *v28 = v31;
          v28 -= 2;
          v29 -= 32;
          v30 -= 8;
        }
        while (v30);
        if (v26 != (v26 & 0x7FFFFFFFFFFFFFF8))
          goto LABEL_27;
LABEL_28:
        v11 = &v19[v18];
        *a5 = v20;
        a5[1] = v22;
        a5[2] = v11;
        if (v13)
        {
          operator delete(v13);
          v21 = v17;
        }
        v13 = v20;
        v10 = v22;
        v8 = v37;
        v12 = v38;
        a4 = v39;
        a5[1] = v10;
        if (v21)
          goto LABEL_4;
LABEL_31:
        ++v8[6];
        v40 = *a2;
        *(_OWORD *)__p = *(_OWORD *)(a2 + 1);
        v42 = a2[3];
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
        dcsctp::RRSendQueue::Add(v35, v36, (uint64_t)&v40, (char *)a4);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        goto LABEL_4;
      }
      v24 = v10;
    }
    do
    {
LABEL_27:
      v32 = *((_DWORD *)v24 - 1);
      v24 -= 4;
      *((_DWORD *)v20 - 1) = v32;
      v20 -= 4;
    }
    while (v24 != v13);
    goto LABEL_28;
  }
LABEL_33:
  v33 = v8[85];
  if (v33)
  {
    LODWORD(v43[0]) = *(_DWORD *)(v33 + 248);
    v34 = *(_DWORD *)(v33 + 28);
    WORD2(v43[0]) = *(_DWORD *)(v33 + 24);
    HIWORD(v43[0]) = v34;
    v43[1] = (void *)(*(_QWORD *)(v33 + 40) & 0xFFFFFFFFFFFFFFFCLL);
    v44 = 0;
    v45 = 0;
    v46 = 0;
    dcsctp::TransmissionControlBlock::SendBufferedPackets(v33, v43, v36);
    if (v44)
    {
      v45 = v44;
      operator delete(v44);
    }
  }
  dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::CallbackDeferrer *)(v8 + 38));
}

char *dcsctp::DcSctpSocket::ResetStreams(dcsctp::DcSctpSocket *this, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  char *result;
  unint64_t v10;
  __int128 v11;
  unint64_t v12;
  __int128 v13;
  char *v14;
  int v15;
  char *v16;
  int v17;
  int v18;
  _BYTE __p[24];
  void (*v20)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  *((_BYTE *)this + 320) = 1;
  v4 = *((_QWORD *)this + 85);
  if (v4)
  {
    if (*(_BYTE *)(v4 + 210))
    {
      if (a3)
        v5 = a2;
      else
        v5 = 0;
      if (a3)
      {
        v6 = 2 * a3;
        do
        {
          v7 = *v5++;
          (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(v4 + 1280) + 376) + 32))(*(_QWORD *)(*(_QWORD *)(v4 + 1280) + 376), v7);
          v6 -= 2;
        }
        while (v6);
      }
      dcsctp::DcSctpSocket::MaybeSendResetStreamsRequest(this);
      v8 = 1;
      goto LABEL_26;
    }
    v20 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
    v18 = 8;
    result = (char *)operator new(0x38uLL);
    *(_QWORD *)__p = result;
    *(_OWORD *)&__p[8] = xmmword_208F08670;
    if (result > "Can't reset streams as the peer doesn't support it"
      || result + 50 <= "Can't reset streams as the peer doesn't support it")
    {
      strcpy(result, "Can't reset streams as the peer doesn't support it");
      v12 = *((_QWORD *)this + 42);
      if (v12 >= *((_QWORD *)this + 43))
      {
        v16 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &v20, (uint64_t)&v18);
        v17 = __p[23];
        *((_QWORD *)this + 42) = v16;
        if (v17 < 0)
          operator delete(*(void **)__p);
        goto LABEL_25;
      }
      if (v12)
      {
        *(_QWORD *)v12 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
        *(_DWORD *)(v12 + 8) = 8;
        v13 = *(_OWORD *)__p;
        *(_QWORD *)(v12 + 32) = *(_QWORD *)&__p[16];
        *(_OWORD *)(v12 + 16) = v13;
        *(_QWORD *)(v12 + 56) = 2;
        *((_QWORD *)this + 42) = v12 + 64;
LABEL_25:
        v8 = 2;
        goto LABEL_26;
      }
    }
  }
  else
  {
    v20 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
    v18 = 4;
    result = (char *)operator new(0x38uLL);
    *(_QWORD *)__p = result;
    *(_OWORD *)&__p[8] = xmmword_208F08670;
    if (result > "Can't reset streams as the socket is not connected"
      || result + 50 <= "Can't reset streams as the socket is not connected")
    {
      strcpy(result, "Can't reset streams as the socket is not connected");
      v10 = *((_QWORD *)this + 42);
      if (v10 >= *((_QWORD *)this + 43))
      {
        v14 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &v20, (uint64_t)&v18);
        v15 = __p[23];
        *((_QWORD *)this + 42) = v14;
        if (v15 < 0)
          operator delete(*(void **)__p);
        v8 = 0;
        goto LABEL_26;
      }
      if (v10)
      {
        *(_QWORD *)v10 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
        *(_DWORD *)(v10 + 8) = 4;
        v11 = *(_OWORD *)__p;
        *(_QWORD *)(v10 + 32) = *(_QWORD *)&__p[16];
        *(_OWORD *)(v10 + 16) = v11;
        *(_QWORD *)(v10 + 56) = 2;
        *((_QWORD *)this + 42) = v10 + 64;
        v8 = 0;
LABEL_26:
        dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::DcSctpSocket *)((char *)this + 304));
        return (char *)v8;
      }
    }
  }
  __break(1u);
  return result;
}

void dcsctp::DcSctpSocket::MaybeSendResetStreamsRequest(dcsctp::DcSctpSocket *this)
{
  double StreamResetRequest;
  void *v3[2];
  void *__p;
  void *v5;
  void (**v6)(dcsctp::ReConfigChunk *__hidden);
  void *v7;
  void *v8;
  char v9;

  StreamResetRequest = dcsctp::StreamResetHandler::MakeStreamResetRequest((dcsctp::StreamResetHandler *)(*((_QWORD *)this + 85) + 1240), (uint64_t)&v6);
  if (v9)
  {
    (*(void (**)(void **__return_ptr, double))(**((_QWORD **)this + 85) + 88))(v3, StreamResetRequest);
    dcsctp::SctpPacket::Builder::Add((uint64_t)v3, (uint64_t)&v6);
    dcsctp::PacketSender::Send((_QWORD *)this + 55, (uint64_t)v3, 1);
    if (__p)
    {
      v5 = __p;
      operator delete(__p);
    }
    if (v9)
    {
      v6 = &off_24C0BB340;
      if (v7)
      {
        v8 = v7;
        operator delete(v7);
      }
    }
  }
}

uint64_t dcsctp::DcSctpSocket::state(dcsctp::DcSctpSocket *this)
{
  int v1;

  v1 = *((_DWORD *)this + 168) - 1;
  if (v1 > 6)
    return 0;
  else
    return dword_208F08808[v1];
}

uint64_t dcsctp::DcSctpSocket::SetMaxMessageSize(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 152) = a2;
  return this;
}

uint64_t dcsctp::DcSctpSocket::buffered_amount(uint64_t a1, unsigned __int16 a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  uint64_t *v6;

  v2 = *(_QWORD *)(a1 + 648);
  if (!v2)
    return 0;
  v3 = a1 + 648;
  do
  {
    v4 = *(unsigned __int16 *)(v2 + 32);
    v5 = v4 >= a2;
    if (v4 >= a2)
      v6 = (uint64_t *)v2;
    else
      v6 = (uint64_t *)(v2 + 8);
    if (v5)
      v3 = v2;
    v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 648 && *(unsigned __int16 *)(v3 + 32) <= a2)
    return *(_QWORD *)(v3 + 160);
  else
    return 0;
}

uint64_t dcsctp::DcSctpSocket::buffered_amount_low_threshold(uint64_t a1, unsigned __int16 a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  uint64_t *v6;

  v2 = *(_QWORD *)(a1 + 648);
  if (!v2)
    return 0;
  v3 = a1 + 648;
  do
  {
    v4 = *(unsigned __int16 *)(v2 + 32);
    v5 = v4 >= a2;
    if (v4 >= a2)
      v6 = (uint64_t *)v2;
    else
      v6 = (uint64_t *)(v2 + 8);
    if (v5)
      v3 = v2;
    v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 648 && *(unsigned __int16 *)(v3 + 32) <= a2)
    return *(_QWORD *)(v3 + 168);
  else
    return 0;
}

unsigned __int16 *dcsctp::DcSctpSocket::SetBufferedAmountLowThreshold(uint64_t a1, unsigned __int16 a2, unint64_t a3)
{
  unsigned __int16 *result;
  unsigned __int16 *v5;
  unint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = dcsctp::RRSendQueue::GetOrCreateStreamInfo(a1 + 480, a2);
  v5 = result;
  v6 = *((_QWORD *)result + 15);
  if (*((_QWORD *)result + 16) >= v6 || v6 > a3)
    goto LABEL_7;
  v8 = *((_QWORD *)result + 14);
  if (v8)
  {
    result = (unsigned __int16 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8);
LABEL_7:
    *((_QWORD *)v5 + 16) = a3;
    return result;
  }
  v9 = std::__throw_bad_function_call[abi:sn180100]();
  return (unsigned __int16 *)dcsctp::DcSctpSocket::GetMetrics(v9, v10);
}

uint64_t dcsctp::DcSctpSocket::GetMetrics@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  _OWORD *v3;
  int v4;
  _OWORD *v5;
  int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  __int16 v17;
  __int128 v18;
  int v19;

  v2 = *(_QWORD *)(this + 680);
  if (v2)
  {
    v3 = (_OWORD *)(this + 40);
    v4 = *(_DWORD *)(this + 84);
    v5 = (_OWORD *)(this + 96);
    v6 = (int *)(this + 116);
    v7 = *(_DWORD *)(this + 124);
    v8 = *(_QWORD *)(v2 + 984);
    v9 = *(_QWORD *)(v2 + 352);
    v10 = v9 / 0x3E8uLL;
    if (v9 % 0x3E8uLL > 0x1F3)
      LODWORD(v10) = v10 + 1;
    if (-v9 % 0x3E8uLL <= 0x1F4)
      v11 = 0;
    else
      v11 = -1;
    if (v9 < 0)
      v12 = v11 - -v9 / 0x3E8uLL;
    else
      v12 = v10;
    v13 = *(_QWORD *)(this + 144);
    v14 = v13 - 28;
    v15 = *(_QWORD *)(v2 + 1160);
    v16 = v13 + *(_QWORD *)(this + 624) - 29;
    this = *(_QWORD *)(v2 + 992);
    v17 = *(_WORD *)(v2 + 212);
    v18 = *(_OWORD *)(v2 + 1016);
    *(_OWORD *)a2 = *v3;
    *(_OWORD *)(a2 + 16) = v18;
    *(_QWORD *)(a2 + 32) = v8;
    *(_DWORD *)(a2 + 40) = v12;
    *(_DWORD *)(a2 + 44) = v4;
    *(_QWORD *)(a2 + 48) = v16 / v14 + v15;
    *(_OWORD *)(a2 + 56) = *v5;
    v19 = *v6;
    *(_WORD *)(a2 + 80) = *((_WORD *)v6 + 2);
    *(_DWORD *)(a2 + 72) = this;
    *(_DWORD *)(a2 + 76) = v19;
    *(_WORD *)(a2 + 82) = v17;
    *(_DWORD *)(a2 + 84) = v7;
    *(_BYTE *)(a2 + 88) = 1;
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 88) = 0;
  }
  return this;
}

void dcsctp::DcSctpSocket::HandleTimeout(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  uint64_t *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  unint64_t v24;
  __int128 v25;
  char *v26;
  int v27;
  void (**v28)(dcsctp::UserInitiatedAbortCause *__hidden);
  void *v29;
  __int128 v30;
  void *v31[2];
  uint64_t v32;
  void (*v33)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  char v34;
  void *__p[2];
  uint64_t v36;
  uint64_t v37;
  _BYTE v38[24];

  *(_BYTE *)(a1 + 320) = 1;
  v3 = *(_QWORD *)(a1 + 392);
  if (v3)
  {
    v4 = a1 + 392;
    do
    {
      v5 = *(_DWORD *)(v3 + 32);
      v6 = v5 >= HIDWORD(a2);
      if (v5 >= HIDWORD(a2))
        v7 = (uint64_t *)v3;
      else
        v7 = (uint64_t *)(v3 + 8);
      if (v6)
        v4 = v3;
      v3 = *v7;
    }
    while (*v7);
    if (v4 != a1 + 392 && *(_DWORD *)(v4 + 32) <= HIDWORD(a2))
      dcsctp::Timer::Trigger(*(_QWORD *)(v4 + 40), a2);
  }
  v8 = *(_QWORD *)(a1 + 680);
  if (!v8 || !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v8 + 80))(v8))
    goto LABEL_43;
  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(a1 + 680) + 88))(&v37);
  v31[0] = 0;
  v31[1] = 0;
  v32 = 0;
  v28 = off_24C0C2EF8;
  v9 = (char *)operator new(0x20uLL);
  v29 = v9;
  v30 = xmmword_208F08630;
  if (v9 > "Too many retransmissions" || v9 + 24 <= "Too many retransmissions")
  {
    strcpy(v9, "Too many retransmissions");
    dcsctp::UserInitiatedAbortCause::SerializeTo((uint64_t)&v28, (uint64_t)v31, v10, v11, v12, v13, v14, v15);
    v16 = v32;
    v17 = *(_OWORD *)v31;
    v31[1] = 0;
    v32 = 0;
    v31[0] = 0;
    v33 = (void (*)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))&off_24C0ACA10;
    v34 = 1;
    *(_OWORD *)__p = v17;
    v36 = v16;
    v18 = dcsctp::SctpPacket::Builder::Add((uint64_t)&v37, (uint64_t)&v33);
    dcsctp::PacketSender::Send((_QWORD *)(a1 + 440), v18, 1);
    v33 = (void (*)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))&off_24C0ACA10;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v28 = off_24C0C2EF8;
    if (SHIBYTE(v30) < 0)
      operator delete(v29);
    if (v31[0])
    {
      v31[1] = v31[0];
      operator delete(v31[0]);
    }
    if (*(_QWORD *)&v38[8])
    {
      *(_QWORD *)&v38[16] = *(_QWORD *)&v38[8];
      operator delete(*(void **)&v38[8]);
    }
    if (!*(_DWORD *)(a1 + 672))
      goto LABEL_43;
    v19 = *(_QWORD *)(a1 + 416);
    if (*(_BYTE *)(v19 + 156))
    {
      (*(void (**)(_QWORD))(**(_QWORD **)(v19 + 136) + 24))(*(_QWORD *)(v19 + 136));
      *(_DWORD *)(v19 + 160) = 0;
      *(_BYTE *)(v19 + 156) = 0;
    }
    v20 = *(_QWORD *)(a1 + 424);
    if (*(_BYTE *)(v20 + 156))
    {
      (*(void (**)(_QWORD))(**(_QWORD **)(v20 + 136) + 24))(*(_QWORD *)(v20 + 136));
      *(_DWORD *)(v20 + 160) = 0;
      *(_BYTE *)(v20 + 156) = 0;
    }
    v21 = *(_QWORD *)(a1 + 432);
    if (*(_BYTE *)(v21 + 156))
    {
      (*(void (**)(_QWORD))(**(_QWORD **)(v21 + 136) + 24))(*(_QWORD *)(v21 + 136));
      *(_DWORD *)(v21 + 160) = 0;
      *(_BYTE *)(v21 + 156) = 0;
    }
    v22 = *(_QWORD *)(a1 + 680);
    *(_QWORD *)(a1 + 680) = 0;
    if (v22)
      (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
    v33 = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
    LODWORD(v37) = 1;
    v23 = (char *)operator new(0x20uLL);
    *(_QWORD *)v38 = v23;
    *(_OWORD *)&v38[8] = xmmword_208F08630;
    if (v23 > "Too many retransmissions" || v23 + 24 <= "Too many retransmissions")
    {
      strcpy(v23, "Too many retransmissions");
      v24 = *(_QWORD *)(a1 + 336);
      if (v24 >= *(_QWORD *)(a1 + 344))
      {
        v26 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)(a1 + 328), &v33, (uint64_t)&v37);
        v27 = v38[23];
        *(_QWORD *)(a1 + 336) = v26;
        if (v27 < 0)
          operator delete(*(void **)v38);
        goto LABEL_41;
      }
      if (v24)
      {
        *(_QWORD *)v24 = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
        *(_DWORD *)(v24 + 8) = 1;
        v25 = *(_OWORD *)v38;
        *(_QWORD *)(v24 + 32) = *(_QWORD *)&v38[16];
        *(_OWORD *)(v24 + 16) = v25;
        *(_QWORD *)(v24 + 56) = 2;
        *(_QWORD *)(a1 + 336) = v24 + 64;
LABEL_41:
        if (*(_DWORD *)(a1 + 672))
          *(_DWORD *)(a1 + 672) = 0;
LABEL_43:
        dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::CallbackDeferrer *)(a1 + 304));
        return;
      }
    }
  }
  __break(1u);
}

void dcsctp::DcSctpSocket::ReceivePacket(uint64_t a1, unsigned __int16 *a2, size_t __sz)
{
  dcsctp::CallbackDeferrer *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  BOOL v24;
  int64_t v25;
  unsigned __int8 *v26;
  int v27;
  char *v28;
  unint64_t v29;
  __int128 v30;
  char *v31;
  char *v32;
  int v33;
  void **v34;
  char *v35;
  size_t v36;
  void **v37;
  BOOL v38;
  unsigned __int8 *v39;
  unsigned __int8 *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned __int8 *v45;
  char *v46;
  unsigned __int8 *v47;
  uint64_t v48;
  char *v49;
  _BYTE v50[4];
  unsigned int v51;
  void *v52;
  void *v53;
  void *__p;
  unsigned __int8 *v55;
  char v56;
  void (*v57)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  int v58;
  void **v59;
  _BYTE v60[24];

  v6 = (dcsctp::CallbackDeferrer *)(a1 + 304);
  *(_BYTE *)(a1 + 320) = 1;
  ++*(_QWORD *)(a1 + 96);
  v7 = *(_QWORD *)(a1 + 32);
  if (v7)
  {
    v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 312) + 56))(*(_QWORD *)(a1 + 312));
    v9 = v8 / 0x3E8uLL;
    if (v8 % 0x3E8uLL > 0x1F3)
      ++v9;
    if (-v8 % 0x3E8uLL <= 0x1F4)
      v10 = 0;
    else
      v10 = -1;
    if (v8 < 0)
      v11 = v10 - -v8 / 0x3E8uLL;
    else
      v11 = v9;
    if (__sz)
      v12 = a2;
    else
      v12 = 0;
    (*(void (**)(uint64_t, unint64_t, unsigned __int16 *, size_t))(*(_QWORD *)v7 + 24))(v7, v11, v12, __sz);
  }
  if (__sz)
    v13 = a2;
  else
    v13 = 0;
  dcsctp::SctpPacket::Parse(__sz, v13, a1 + 128, (uint64_t)v50);
  if (!v56)
  {
    v57 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
    LODWORD(v59) = 3;
    v28 = (char *)operator new(0x28uLL);
    *(_QWORD *)v60 = v28;
    *(_OWORD *)&v60[8] = xmmword_208F08620;
    if (v28 <= "Failed to parse received SCTP packet" && v28 + 36 > "Failed to parse received SCTP packet")
      goto LABEL_104;
    strcpy(v28, "Failed to parse received SCTP packet");
    v29 = *(_QWORD *)(a1 + 336);
    if (v29 < *(_QWORD *)(a1 + 344))
      goto LABEL_31;
    goto LABEL_39;
  }
  v19 = *(unsigned int **)(a1 + 680);
  if (v19)
  {
    v20 = v19[60];
    v21 = v51;
    v22 = (unsigned __int8 *)__p;
    v23 = v55;
    v25 = v55 - (_BYTE *)__p;
    v24 = v55 == __p;
    if (v51)
      goto LABEL_20;
LABEL_34:
    if (v25 == 24 && *v22 == 1)
      goto LABEL_67;
    v57 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
    LODWORD(v59) = 3;
    v31 = (char *)operator new(0x50uLL);
    *(_QWORD *)v60 = v31;
    *(_OWORD *)&v60[8] = xmmword_208F08690;
    if (v31 <= "Only a single INIT chunk can be present in packets sent on verification_tag = 0"
      && v31 + 79 > "Only a single INIT chunk can be present in packets sent on verification_tag = 0")
    {
      goto LABEL_104;
    }
    strcpy(v31, "Only a single INIT chunk can be present in packets sent on verification_tag = 0");
    v29 = *(_QWORD *)(a1 + 336);
    if (v29 < *(_QWORD *)(a1 + 344))
      goto LABEL_31;
    goto LABEL_39;
  }
  v20 = 0;
  v21 = v51;
  v22 = (unsigned __int8 *)__p;
  v23 = v55;
  v25 = v55 - (_BYTE *)__p;
  v24 = v55 == __p;
  if (!v51)
    goto LABEL_34;
LABEL_20:
  if (v24)
    v26 = 0;
  else
    v26 = v22;
  v27 = *v26;
  if (v25 != 24 || v27 != 6)
  {
    if (v27 == 10)
      goto LABEL_67;
    if (v27 == 2)
    {
      v20 = *(unsigned int *)(a1 + 668);
      if ((_DWORD)v21 == (_DWORD)v20)
        goto LABEL_67;
LABEL_58:
      rtc::StringFormat((rtc *)"Packet has invalid verification tag: %08x, expected %08x", (char *)&v59, v21, v20);
      if ((v60[15] & 0x80000000) != 0)
      {
        v36 = *(_QWORD *)v60;
        if ((*(_QWORD *)v60 & 0x8000000000000000) != 0)
          goto LABEL_104;
        v37 = v59;
        if (*(_QWORD *)v60)
        {
          if (!v59)
            goto LABEL_104;
        }
      }
      else
      {
        v36 = v60[15];
        v37 = (void **)&v59;
      }
      dcsctp::CallbackDeferrer::OnError((uint64_t)v6, 3, v37, v36);
      if ((v60[15] & 0x80000000) == 0)
        goto LABEL_94;
      v34 = v59;
LABEL_41:
      operator delete(v34);
      goto LABEL_94;
    }
    if (v25 != 24 || v27 != 14)
    {
      if ((_DWORD)v21 == (_DWORD)v20)
        goto LABEL_67;
      goto LABEL_58;
    }
    if ((v26[1] & 1) != 0)
    {
      if (!v19 || (_DWORD)v21 == v19[62])
        goto LABEL_67;
    }
    else if ((_DWORD)v21 == (_DWORD)v20)
    {
      goto LABEL_67;
    }
    v57 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
    LODWORD(v59) = 3;
    v49 = (char *)operator new(0x38uLL);
    *(_QWORD *)v60 = v49;
    *(_OWORD *)&v60[8] = xmmword_208F08670;
    if (v49 <= "SHUTDOWN_COMPLETE chunk verification tag was wrong"
      && v49 + 50 > "SHUTDOWN_COMPLETE chunk verification tag was wrong")
    {
      goto LABEL_104;
    }
    strcpy(v49, "SHUTDOWN_COMPLETE chunk verification tag was wrong");
    v29 = *(_QWORD *)(a1 + 336);
    if (v29 < *(_QWORD *)(a1 + 344))
      goto LABEL_31;
LABEL_39:
    v32 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)(a1 + 328), &v57, (uint64_t)&v59);
    v33 = v60[23];
    *(_QWORD *)(a1 + 336) = v32;
    if ((v33 & 0x80000000) == 0)
      goto LABEL_94;
    v34 = *(void ***)v60;
    goto LABEL_41;
  }
  if ((v26[1] & 1) == 0)
  {
    if ((_DWORD)v21 == (_DWORD)v20)
      goto LABEL_67;
LABEL_48:
    v57 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
    LODWORD(v59) = 3;
    v35 = (char *)operator new(0x28uLL);
    *(_QWORD *)v60 = v35;
    *(_OWORD *)&v60[8] = xmmword_208F08680;
    if (v35 <= "ABORT chunk verification tag was wrong" && v35 + 38 > "ABORT chunk verification tag was wrong")
      goto LABEL_104;
    strcpy(v35, "ABORT chunk verification tag was wrong");
    v29 = *(_QWORD *)(a1 + 336);
    if (v29 < *(_QWORD *)(a1 + 344))
    {
LABEL_31:
      if (v29)
      {
        *(_QWORD *)v29 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
        *(_DWORD *)(v29 + 8) = 3;
        v30 = *(_OWORD *)v60;
        *(_QWORD *)(v29 + 32) = *(_QWORD *)&v60[16];
        *(_OWORD *)(v29 + 16) = v30;
        *(_QWORD *)(v29 + 56) = 2;
        *(_QWORD *)(a1 + 336) = v29 + 64;
        goto LABEL_94;
      }
LABEL_104:
      __break(1u);
      return;
    }
    goto LABEL_39;
  }
  if (v19 && (_DWORD)v21 != v19[62])
    goto LABEL_48;
LABEL_67:
  if (*(_DWORD *)(a1 + 672) == 5)
  {
    v38 = v23 == v22;
    v39 = v23 == v22 ? 0 : v22;
    v40 = &v39[v25];
    if (v38)
    {
      v22 = 0;
    }
    else
    {
      while (*v22)
      {
        v22 += 24;
        if (v22 == v40)
          goto LABEL_82;
      }
    }
    if (v22 != v40)
    {
      (*(void (**)(void ***__return_ptr))(*(_QWORD *)v19 + 88))(&v59);
      v41 = *(_QWORD *)(*(_QWORD *)(a1 + 680) + 464);
      v57 = (void (*)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))&unk_24C0C0CB0;
      v58 = v41;
      dcsctp::SctpPacket::Builder::Add((uint64_t)&v59, (uint64_t)&v57);
      dcsctp::PacketSender::Send((_QWORD *)(a1 + 440), (uint64_t)&v59, 1);
      if (*(_QWORD *)&v60[8])
      {
        *(_QWORD *)&v60[16] = *(_QWORD *)&v60[8];
        operator delete(*(void **)&v60[8]);
      }
      v42 = *(_QWORD *)(a1 + 432);
      v43 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 680) + 56))(*(_QWORD *)(a1 + 680));
      v44 = 86400000000;
      if (v43 < 86400000000)
        v44 = v43;
      *(_QWORD *)(v42 + 144) = v44;
      dcsctp::Timer::Start(*(dcsctp::Timer **)(a1 + 432));
      if (!v56)
        goto LABEL_104;
    }
  }
LABEL_82:
  v45 = (unsigned __int8 *)__p;
  if (v55 == __p)
    v46 = 0;
  else
    v46 = (char *)__p;
  if (v55 != __p)
  {
    v47 = (unsigned __int8 *)&v46[v55 - (_BYTE *)__p];
    while (v56)
    {
      if (dcsctp::DcSctpSocket::Dispatch((dcsctp::DcSctpSocket *)a1, (uint64_t)v50, v45, v14, v15, v16, v17, v18))
      {
        v45 += 24;
        if (v45 != v47)
          continue;
      }
      goto LABEL_90;
    }
    goto LABEL_104;
  }
LABEL_90:
  v48 = *(_QWORD *)(a1 + 680);
  if (v48)
  {
    if (*(_DWORD *)(v48 + 440) == 1)
    {
      dcsctp::Timer::Start(*(dcsctp::Timer **)(v48 + 432));
      *(_DWORD *)(v48 + 440) = 2;
      v48 = *(_QWORD *)(a1 + 680);
    }
    dcsctp::TransmissionControlBlock::MaybeSendSack((dcsctp::TransmissionControlBlock *)v48);
  }
LABEL_94:
  if (v56)
  {
    if (__p)
    {
      v55 = (unsigned __int8 *)__p;
      operator delete(__p);
    }
    if (v52)
    {
      v53 = v52;
      operator delete(v52);
    }
  }
  dcsctp::CallbackDeferrer::TriggerDeferred(v6);
}

BOOL dcsctp::DcSctpSocket::Dispatch(dcsctp::DcSctpSocket *this, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unint64_t v11;
  char *v13;
  unint64_t v14;
  __int128 v15;
  char *v16;
  std::string *v17;
  int v18;
  std::string::size_type v19;
  std::string::size_type size;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  unint64_t v42;
  unint64_t v43;
  char *v44;
  void *v45;
  _QWORD *v46;
  int v47;
  uint64_t v48;
  int64_t v49;
  Timestamp v50;
  uint64_t v51;
  int v52;
  void *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  std::string *v69;
  void **v70;
  uint64_t v71;
  unint64_t v72;
  unsigned int v73;
  _BOOL8 result;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t (**v84)(uint64_t, uint64_t);
  _QWORD *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  std::string *v89;
  int v90;
  unint64_t v91;
  char *p_src;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  BOOL v96;
  BOOL v97;
  int v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;
  void *v103;
  int64_t v104;
  int v105;
  uint64_t (**v106)(uint64_t, uint64_t);
  _QWORD *v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t (**v113)(uint64_t, uint64_t);
  _QWORD *v114;
  int64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  int v124;
  char *v125;
  unint64_t v126;
  __int128 v127;
  int v128;
  char *v129;
  __int128 v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  unint64_t v135;
  __int128 v136;
  std::string *v137;
  std::string::size_type v139;
  char *v140;
  unint64_t v141;
  __int128 v142;
  char *v143;
  unint64_t v144;
  char *v145;
  unint64_t v146;
  __int128 v147;
  char *v148;
  __int128 v149;
  char *v150;
  int v151;
  char *v152;
  int v153;
  uint64_t v154;
  uint64_t v155;
  void **v156;
  void **v158;
  void **v159;
  size_t v161;
  void **v162;
  char *v163;
  int v164;
  char *v165;
  int v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  size_t v171;
  const void *v172;
  unint64_t v173;
  size_t v174;
  void **v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  size_t v183;
  const void *v184;
  char *v185;
  char *v186;
  char *v187;
  __int128 v188;
  uint64_t v189;
  char *v190;
  int v191;
  char *v192;
  int v193;
  uint64_t v194;
  uint64_t v195;
  int v196;
  unsigned __int16 *v197;
  unint64_t v198;
  unint64_t v199;
  BOOL v200;
  BOOL v201;
  int v202;
  char *v203;
  __int128 v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  char *v210;
  unint64_t v211;
  __int128 v212;
  uint64_t v213;
  size_t v214;
  _QWORD *v215;
  int v216;
  char *v217;
  int v218;
  uint64_t v219;
  int v220;
  char *v221;
  unint64_t v222;
  __int128 v223;
  int v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  int v228;
  int v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  void *v236;
  size_t v237;
  char *v238;
  void *v239;
  size_t v240;
  char *v241;
  char *v242;
  uint64_t v243;
  unint64_t v244;
  char *v245;
  __int128 v246;
  size_t v247;
  void **v248;
  int v249;
  uint64_t v250;
  __int128 v251;
  char *v252;
  unint64_t v253;
  __int128 v254;
  char *v255;
  int v256;
  void *v257;
  int v258;
  int v259;
  int v260;
  int v261;
  uint64_t v262;
  uint64_t v263;
  unsigned int v264;
  uint64_t v265;
  char *v266;
  char *v267;
  void *v268;
  uint64_t v269;
  int64_t v270;
  int v271;
  size_t v272;
  const void *v273;
  uint64_t (**v274)(uint64_t, uint64_t);
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  void *v278;
  int v279;
  uint64_t (**v280)(uint64_t, uint64_t);
  _QWORD *v281;
  int v282;
  int v283;
  int v284;
  int v285;
  uint64_t v286;
  uint64_t v287;
  unsigned int v288;
  uint64_t v289;
  int64_t v290;
  char *v291;
  int v292;
  uint64_t v293;
  unint64_t v294;
  void *v295;
  _BYTE *v296;
  void *v297;
  _BYTE *v298;
  uint64_t v299;
  _BYTE v300[32];
  void *v301;
  _BYTE __p[32];
  _QWORD v303[3];
  void *__src;
  _BYTE __len[24];
  char *v306;
  void (**v307)(dcsctp::AbortChunk *__hidden);
  _BYTE v308[24];
  void *v309;
  void *v310;
  _QWORD *v311;
  char v312;
  char v313;
  __int128 v314;
  char *v315;

  v11 = *a3;
  switch(*a3)
  {
    case 0u:
      dcsctp::DataChunk::Parse(*((_DWORD **)a3 + 1), *((_QWORD *)a3 + 2), (uint64_t)&v307);
      if (!v313)
      {
        dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 0);
        goto LABEL_270;
      }
      if (*((_QWORD *)this + 85))
        goto LABEL_178;
      goto LABEL_4;
    case 1u:
      dcsctp::InitChunk::Parse(*((_QWORD *)a3 + 1), *((_QWORD *)a3 + 2), (uint64_t)&v307);
      if (!(_BYTE)v311)
      {
        dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 1);
        goto LABEL_478;
      }
      if (!*(_DWORD *)v308 || !*(_WORD *)&v308[8] || !*(_WORD *)&v308[10])
      {
        LODWORD(v301) = 0;
        v128 = *((_DWORD *)this + 33);
        WORD2(v301) = *((_DWORD *)this + 32);
        HIWORD(v301) = v128;
        *(_QWORD *)__p = *((_QWORD *)this + 18) & 0xFFFFFFFFFFFFFFFCLL;
        memset(&__p[8], 0, 24);
        v314 = 0uLL;
        *(_QWORD *)v300 = off_24C0BAE18;
        v300[31] = 14;
        v315 = 0;
        if (&v300[8] <= "INIT malformed" && &v300[22] > "INIT malformed")
          goto LABEL_565;
        strcpy(&v300[8], "INIT malformed");
        dcsctp::ProtocolViolationCause::SerializeTo((uint64_t)v300, (uint64_t)&v314, v21, v22, v23, v24, v25, v26);
        v129 = v315;
        v130 = v314;
        v315 = 0;
        v314 = 0uLL;
        __src = &off_24C0ACA10;
        __len[0] = 0;
        *(_OWORD *)&__len[8] = v130;
        v306 = v129;
        v131 = dcsctp::SctpPacket::Builder::Add((uint64_t)&v301, (uint64_t)&__src);
        dcsctp::PacketSender::Send((_QWORD *)this + 55, v131, 1);
        __src = &off_24C0ACA10;
        if (*(_QWORD *)&__len[8])
        {
          *(_QWORD *)&__len[16] = *(_QWORD *)&__len[8];
          operator delete(*(void **)&__len[8]);
        }
        *(_QWORD *)v300 = off_24C0BAE18;
        if ((v300[31] & 0x80000000) != 0)
          operator delete(*(void **)&v300[8]);
        if ((_QWORD)v314)
        {
          *((_QWORD *)&v314 + 1) = v314;
          operator delete((void *)v314);
        }
        if (*(_QWORD *)&__p[8])
        {
          *(_QWORD *)&__p[16] = *(_QWORD *)&__p[8];
          operator delete(*(void **)&__p[8]);
        }
        if (*((_DWORD *)this + 168))
        {
          v132 = *((_QWORD *)this + 52);
          if (*(_BYTE *)(v132 + 156))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(v132 + 136) + 24))(*(_QWORD *)(v132 + 136));
            *(_DWORD *)(v132 + 160) = 0;
            *(_BYTE *)(v132 + 156) = 0;
          }
          v133 = *((_QWORD *)this + 53);
          if (*(_BYTE *)(v133 + 156))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(v133 + 136) + 24))(*(_QWORD *)(v133 + 136));
            *(_DWORD *)(v133 + 160) = 0;
            *(_BYTE *)(v133 + 156) = 0;
          }
          v11 = *((_QWORD *)this + 54);
          if (*(_BYTE *)(v11 + 156))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(v11 + 136) + 24))(*(_QWORD *)(v11 + 136));
            *(_DWORD *)(v11 + 160) = 0;
            *(_BYTE *)(v11 + 156) = 0;
          }
          v134 = *((_QWORD *)this + 85);
          *((_QWORD *)this + 85) = 0;
          if (v134)
            (*(void (**)(uint64_t))(*(_QWORD *)v134 + 8))(v134);
          __src = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
          LODWORD(v301) = 6;
          __p[23] = 21;
          if (__p <= "Received invalid INIT" && &__p[21] > "Received invalid INIT")
            goto LABEL_565;
          strcpy(__p, "Received invalid INIT");
          v135 = *((_QWORD *)this + 42);
          if (v135 >= *((_QWORD *)this + 43))
          {
            v165 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &__src, (uint64_t)&v301);
            v166 = __p[23];
            *((_QWORD *)this + 42) = v165;
            if (v166 < 0)
              operator delete(*(void **)__p);
          }
          else
          {
            if (!v135)
              goto LABEL_565;
            *(_QWORD *)v135 = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
            *(_DWORD *)(v135 + 8) = 6;
            v136 = *(_OWORD *)__p;
            *(_QWORD *)(v135 + 32) = *(_QWORD *)&__p[16];
            *(_OWORD *)(v135 + 16) = v136;
            *(_QWORD *)(v135 + 56) = 2;
            *((_QWORD *)this + 42) = v135 + 64;
          }
          if (*((_DWORD *)this + 168))
            *((_DWORD *)this + 168) = 0;
        }
LABEL_478:
        if (!(_BYTE)v311)
          return 1;
        v307 = &off_24C0B53F8;
        v58 = *(void **)&v308[16];
        if (!*(_QWORD *)&v308[16])
          return 1;
        goto LABEL_480;
      }
      v27 = *((_DWORD *)this + 168);
      if ((v27 - 1) < 2)
      {
        v219 = 0;
        v11 = *((unsigned int *)this + 167);
        v220 = *((_DWORD *)this + 166);
      }
      else if (v27)
      {
        if (v27 == 7)
        {
          (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 85) + 88))(&v301);
          __src = &unk_24C0C0C80;
          v28 = dcsctp::SctpPacket::Builder::Add((uint64_t)&v301, (uint64_t)&__src);
          dcsctp::PacketSender::Send((_QWORD *)this + 55, v28, 1);
          if (*(_QWORD *)&__p[8])
          {
            *(_QWORD *)&__p[16] = *(_QWORD *)&__p[8];
            operator delete(*(void **)&__p[8]);
          }
          v29 = *((_QWORD *)this + 54);
          v30 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 85) + 56))(*((_QWORD *)this + 85));
          v31 = 86400000000;
          if (v30 < 86400000000)
            v31 = v30;
          *(_QWORD *)(v29 + 144) = v31;
          dcsctp::Timer::Start(*((dcsctp::Timer **)this + 54));
          goto LABEL_478;
        }
        v225 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL);
        v226 = *((_QWORD *)this + 85);
        if ((_DWORD)v225 != *(_DWORD *)(v226 + 240))
          goto LABEL_455;
        v225 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL);
        v226 = *((_QWORD *)this + 85);
        if ((_DWORD)v225 != *(_DWORD *)(v226 + 240))
          goto LABEL_455;
        v225 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL);
        v226 = *((_QWORD *)this + 85);
        if ((_DWORD)v225 != *(_DWORD *)(v226 + 240))
          goto LABEL_455;
        v225 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL);
        v226 = *((_QWORD *)this + 85);
        if ((_DWORD)v225 != *(_DWORD *)(v226 + 240))
          goto LABEL_455;
        v225 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL);
        v226 = *((_QWORD *)this + 85);
        if ((_DWORD)v225 != *(_DWORD *)(v226 + 240))
          goto LABEL_455;
        v225 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL);
        v226 = *((_QWORD *)this + 85);
        if ((_DWORD)v225 != *(_DWORD *)(v226 + 240))
          goto LABEL_455;
        v225 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL);
        v226 = *((_QWORD *)this + 85);
        if ((_DWORD)v225 == *(_DWORD *)(v226 + 240)
          && (v225 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL), v226 = *((_QWORD *)this + 85), (_DWORD)v225 == *(_DWORD *)(v226 + 240))&& (v225 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL), v226 = *((_QWORD *)this + 85), (_DWORD)v225 == *(_DWORD *)(v226 + 240)))
        {
          v11 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL);
          v226 = *((_QWORD *)this + 85);
        }
        else
        {
LABEL_455:
          v11 = v225;
        }
        v220 = *(_DWORD *)(v226 + 1144) + *(_DWORD *)(v226 + 1064) + 1000001;
        v219 = *(_QWORD *)(v226 + 256);
      }
      else
      {
        v11 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 1, 0xFFFFFFFFLL);
        v220 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(**((_QWORD **)this + 39) + 64))(*((_QWORD *)this + 39), 0, 0xFFFFFFFFLL);
        v219 = 0;
      }
      if (!(_BYTE)v311)
        goto LABEL_565;
      if (!(_BYTE)v311)
        goto LABEL_565;
      v228 = v227;
      v229 = *((_DWORD *)this + 33);
      WORD2(__src) = *((_DWORD *)this + 32);
      LODWORD(__src) = *(_DWORD *)v308;
      HIWORD(__src) = v229;
      *(_QWORD *)__len = *((_QWORD *)this + 18) & 0xFFFFFFFFFFFFFFFCLL;
      *(_QWORD *)&__len[8] = 0;
      *(_QWORD *)&__len[16] = 0;
      v306 = 0;
      v297 = 0;
      v298 = 0;
      v299 = 0;
      v301 = (void *)__PAIR64__(v11, *(unsigned int *)v308);
      *(_DWORD *)__p = *(_DWORD *)&v308[12];
      *(_DWORD *)&__p[4] = v220;
      *(_DWORD *)&__p[8] = *(_DWORD *)&v308[4];
      *(_QWORD *)&__p[16] = v219;
      *(_QWORD *)&__p[24] = v227;
      dcsctp::StateCookie::Serialize((dcsctp::StateCookie *)&v301, (uint64_t)&v295);
      v236 = v295;
      *(_QWORD *)v300 = &off_24C0C1200;
      memset(&v300[8], 0, 24);
      v237 = v296 - (_BYTE *)v295;
      if (v296 == v295)
      {
        v238 = 0;
      }
      else
      {
        if ((v237 & 0x8000000000000000) != 0)
          goto LABEL_569;
        v238 = (char *)operator new(v296 - (_BYTE *)v295);
        *(_QWORD *)&v300[8] = v238;
        *(_QWORD *)&v300[24] = &v238[v237];
        memcpy(v238, v236, v237);
        *(_QWORD *)&v300[16] = &v238[v237];
      }
      dcsctp::StateCookieParameter::SerializeTo((uint64_t)v300, (uint64_t)&v297, v230, v231, v232, v233, v234, v235);
      v314 = 0uLL;
      v315 = 0;
      v239 = v297;
      v240 = v298 - (_BYTE *)v297;
      if (v298 == v297)
      {
LABEL_466:
        if (v238)
          operator delete(v238);
        if (v295)
        {
          v296 = v295;
          operator delete(v295);
        }
        if (v297)
        {
          v298 = v297;
          operator delete(v297);
        }
        v243 = *((_QWORD *)this + 21);
        HIDWORD(v244) = *((_DWORD *)this + 34);
        LODWORD(v244) = HIDWORD(v244);
        v245 = v315;
        v246 = v314;
        v315 = 0;
        v314 = 0uLL;
        v301 = &off_24C0B53C8;
        *(_DWORD *)__p = v11;
        *(_DWORD *)&__p[4] = v243;
        *(_DWORD *)&__p[8] = v244 >> 16;
        *(_DWORD *)&__p[12] = v220;
        *(_OWORD *)&__p[16] = v246;
        v303[0] = v245;
        dcsctp::SctpPacket::Builder::Add((uint64_t)&__src, (uint64_t)&v301);
        dcsctp::PacketSender::Send((_QWORD *)this + 55, (uint64_t)&__src, (v228 & 0x1000000) == 0);
        v301 = &off_24C0B53C8;
        if (*(_QWORD *)&__p[16])
        {
          *(_QWORD *)&__p[24] = *(_QWORD *)&__p[16];
          operator delete(*(void **)&__p[16]);
        }
        if ((_QWORD)v314)
        {
          *((_QWORD *)&v314 + 1) = v314;
          operator delete((void *)v314);
        }
        if (*(_QWORD *)&__len[8])
        {
          *(_QWORD *)&__len[16] = *(_QWORD *)&__len[8];
          operator delete(*(void **)&__len[8]);
        }
        goto LABEL_478;
      }
      if ((v240 & 0x8000000000000000) == 0)
      {
        v241 = (char *)operator new(v298 - (_BYTE *)v297);
        v242 = &v241[v240];
        *(_QWORD *)&v314 = v241;
        v315 = &v241[v240];
        memcpy(v241, v239, v240);
        *((_QWORD *)&v314 + 1) = v242;
        goto LABEL_466;
      }
      goto LABEL_569;
    case 2u:
      dcsctp::InitAckChunk::Parse(*((_QWORD *)a3 + 1), *((_QWORD *)a3 + 2), (uint64_t)&v307);
      if (!(_BYTE)v311)
      {
        dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 2);
        goto LABEL_225;
      }
      if (*((_DWORD *)this + 168) != 1)
        goto LABEL_225;
      *(_QWORD *)__p = 0;
      *(_QWORD *)&__p[8] = 0;
      v301 = 0;
      v11 = (unint64_t)v309 - *(_QWORD *)&v308[16];
      if (v309 == *(void **)&v308[16])
        goto LABEL_391;
      v38 = *(char **)&v308[16];
      do
      {
        if (v11 <= 3)
        {
          rtc::webrtc_checks_impl::FatalLog("Source/webrtc/net/dcsctp/packet/bounded_byte_reader.h", 55, "data.size() >= FixedSize", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v34, v35, v36, v37, v293);
          goto LABEL_569;
        }
        *(_WORD *)v300 = 0;
        *(_WORD *)v300 = bswap32(*(unsigned __int16 *)v38) >> 16;
        v39 = __rev16(*((unsigned __int16 *)v38 + 1));
        if (v11 >= v39)
          v40 = v39;
        else
          v40 = v11;
        if (v40)
          v41 = v38;
        else
          v41 = 0;
        __src = v41;
        *(_QWORD *)__len = v40;
        std::vector<dcsctp::ParameterDescriptor>::emplace_back<unsigned short &,rtc::ArrayView<unsigned char const,-4711l>>(&v301, v300, (uint64_t *)&__src);
        v42 = (unsigned __int16)(v39 + 3) & 0xFFFC;
        v43 = v11 - v42;
        if (v11 <= v42)
          break;
        v44 = &v38[v42];
        if (v43 < v11)
          v11 = v43;
        v38 = v11 ? v44 : 0;
      }
      while (v11);
      v45 = v301;
      if (v301 == *(void **)__p)
      {
LABEL_59:
        v47 = 1;
      }
      else
      {
        v46 = v301;
        while (*(_WORD *)v46 != 7)
        {
          v46 += 3;
          if (v46 == *(_QWORD **)__p)
            goto LABEL_59;
        }
        v197 = (unsigned __int16 *)v46[1];
        v198 = v46[2];
        if (!v198)
          v197 = 0;
        if (v198 < 4
          || __rev16(*v197) != 7
          || ((v199 = __rev16(v197[1]), v199 >= 4) ? (v200 = v198 >= v199) : (v200 = 0),
              v200 ? (v201 = v198 - v199 > 3) : (v201 = 1),
              v201))
        {
          v47 = 0;
          v8 = 1;
        }
        else
        {
          if (v199 < 5)
          {
            v8 = 0;
            v294 = 0;
            v11 = 0;
          }
          else
          {
            v272 = v199 - 4;
            v273 = v197 + 2;
            v11 = (unint64_t)operator new(v199 - 4);
            v294 = v11 + v272;
            memcpy((void *)v11, v273, v272);
            v8 = 0;
          }
          v47 = 0;
        }
      }
      if (v45)
      {
        *(_QWORD *)__p = v45;
        operator delete(v45);
      }
      if (((v8 | v47) & 1) == 0)
      {
        if (!(_BYTE)v311)
          goto LABEL_565;
        v213 = *((_QWORD *)this + 52);
        if (*(_BYTE *)(v213 + 156))
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(v213 + 136) + 24))(*(_QWORD *)(v213 + 136));
          *(_DWORD *)(v213 + 160) = 0;
          *(_BYTE *)(v213 + 156) = 0;
        }
        v214 = v294 - v11;
        if (v294 == v11)
          v215 = 0;
        else
          v215 = (_QWORD *)v11;
        if (v214 >= 9)
        {
          if (!v215)
            goto LABEL_565;
          if (*v215 == 0x3030505443536364)
          {
            v216 = 1;
            goto LABEL_510;
          }
          if (*v215 == 0x4453422D454D414BLL)
          {
            v216 = 2;
            goto LABEL_510;
          }
        }
        v216 = 3;
LABEL_510:
        *((_DWORD *)this + 29) = v216;
        dcsctp::RRSendQueue::Reset((dcsctp::DcSctpSocket *)((char *)this + 480));
        if (!(_BYTE)v311)
          goto LABEL_565;
        v258 = *((_DWORD *)this + 166);
        v259 = *((_DWORD *)this + 167);
        v260 = *(_DWORD *)&v308[12];
        v261 = *(_DWORD *)v308;
        v262 = *(unsigned int *)&v308[4];
        v263 = (*(uint64_t (**)(char *, _QWORD, uint64_t))(*((_QWORD *)this + 38) + 64))((char *)this + 304, 0, 0xFFFFFFFFLL);
        v264 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*((_QWORD *)this + 38) + 64))((char *)this + 304, 1, 0xFFFFFFFFLL);
        dcsctp::DcSctpSocket::CreateTransmissionControlBlock((uint64_t)this, (uint64_t)&__src, v259, v258, v261, v260, v262, v264 | (unint64_t)(v263 << 32));
        if (*((_DWORD *)this + 168) != 2)
          *((_DWORD *)this + 168) = 2;
        v265 = *((_QWORD *)this + 85);
        if (v294 == v11)
        {
          v266 = 0;
          v267 = 0;
          goto LABEL_517;
        }
        if ((v214 & 0x8000000000000000) == 0)
        {
          v266 = (char *)operator new(v214);
          v267 = &v266[v214];
          memcpy(v266, (const void *)v11, v214);
LABEL_517:
          if (*(_BYTE *)(v265 + 1480))
          {
            v268 = *(void **)(v265 + 1456);
            if (v268)
            {
              *(_QWORD *)(v265 + 1464) = v268;
              operator delete(v268);
            }
            *(_QWORD *)(v265 + 1456) = v266;
            *(_QWORD *)(v265 + 1464) = v267;
            *(_QWORD *)(v265 + 1472) = v267;
          }
          else
          {
            *(_QWORD *)(v265 + 1448) = &off_24C0B1730;
            *(_QWORD *)(v265 + 1456) = v266;
            *(_QWORD *)(v265 + 1464) = v267;
            *(_QWORD *)(v265 + 1472) = v267;
            *(_BYTE *)(v265 + 1480) = 1;
          }
          v269 = *((_QWORD *)this + 85);
          v270 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 39) + 56))(*((_QWORD *)this + 39));
          LODWORD(v301) = *(_DWORD *)(v269 + 248);
          v271 = *(_DWORD *)(v269 + 28);
          WORD2(v301) = *(_DWORD *)(v269 + 24);
          HIWORD(v301) = v271;
          *(_QWORD *)__p = *(_QWORD *)(v269 + 40) & 0xFFFFFFFFFFFFFFFCLL;
          memset(&__p[8], 0, 24);
          dcsctp::TransmissionControlBlock::SendBufferedPackets(v269, &v301, v270);
          if (*(_QWORD *)&__p[8])
          {
            *(_QWORD *)&__p[16] = *(_QWORD *)&__p[8];
            operator delete(*(void **)&__p[8]);
          }
          dcsctp::Timer::Start(*((dcsctp::Timer **)this + 53));
          if (v11)
            operator delete((void *)v11);
          goto LABEL_225;
        }
LABEL_569:
        abort();
      }
LABEL_391:
      LODWORD(v301) = *((_DWORD *)this + 167);
      v202 = *((_DWORD *)this + 33);
      WORD2(v301) = *((_DWORD *)this + 32);
      HIWORD(v301) = v202;
      *(_QWORD *)__p = *((_QWORD *)this + 18) & 0xFFFFFFFFFFFFFFFCLL;
      memset(&__p[8], 0, 24);
      v314 = 0uLL;
      *(_QWORD *)v300 = off_24C0BAE18;
      v300[31] = 18;
      v315 = 0;
      if (&v300[8] <= "INIT-ACK malformed" && &v300[26] > "INIT-ACK malformed")
        goto LABEL_565;
      strcpy(&v300[8], "INIT-ACK malformed");
      dcsctp::ProtocolViolationCause::SerializeTo((uint64_t)v300, (uint64_t)&v314, v32, v33, v34, v35, v36, v37);
      v203 = v315;
      v204 = v314;
      v315 = 0;
      v314 = 0uLL;
      __src = &off_24C0ACA10;
      __len[0] = 0;
      *(_OWORD *)&__len[8] = v204;
      v306 = v203;
      v205 = dcsctp::SctpPacket::Builder::Add((uint64_t)&v301, (uint64_t)&__src);
      dcsctp::PacketSender::Send((_QWORD *)this + 55, v205, 1);
      __src = &off_24C0ACA10;
      if (*(_QWORD *)&__len[8])
      {
        *(_QWORD *)&__len[16] = *(_QWORD *)&__len[8];
        operator delete(*(void **)&__len[8]);
      }
      *(_QWORD *)v300 = off_24C0BAE18;
      if ((v300[31] & 0x80000000) != 0)
        operator delete(*(void **)&v300[8]);
      if ((_QWORD)v314)
      {
        *((_QWORD *)&v314 + 1) = v314;
        operator delete((void *)v314);
      }
      if (*(_QWORD *)&__p[8])
      {
        *(_QWORD *)&__p[16] = *(_QWORD *)&__p[8];
        operator delete(*(void **)&__p[8]);
      }
      if (!*((_DWORD *)this + 168))
      {
LABEL_225:
        if (!(_BYTE)v311)
          return 1;
        v307 = &off_24C0B53C8;
        v58 = *(void **)&v308[16];
        if (!*(_QWORD *)&v308[16])
          return 1;
LABEL_480:
        v309 = v58;
        goto LABEL_481;
      }
      v206 = *((_QWORD *)this + 52);
      if (*(_BYTE *)(v206 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v206 + 136) + 24))(*(_QWORD *)(v206 + 136));
        *(_DWORD *)(v206 + 160) = 0;
        *(_BYTE *)(v206 + 156) = 0;
      }
      v207 = *((_QWORD *)this + 53);
      if (*(_BYTE *)(v207 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v207 + 136) + 24))(*(_QWORD *)(v207 + 136));
        *(_DWORD *)(v207 + 160) = 0;
        *(_BYTE *)(v207 + 156) = 0;
      }
      v208 = *((_QWORD *)this + 54);
      if (*(_BYTE *)(v208 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v208 + 136) + 24))(*(_QWORD *)(v208 + 136));
        *(_DWORD *)(v208 + 160) = 0;
        *(_BYTE *)(v208 + 156) = 0;
      }
      v209 = *((_QWORD *)this + 85);
      *((_QWORD *)this + 85) = 0;
      if (v209)
        (*(void (**)(uint64_t))(*(_QWORD *)v209 + 8))(v209);
      v11 = (unint64_t)dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      __src = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      LODWORD(v301) = 6;
      v210 = (char *)operator new(0x28uLL);
      *(_QWORD *)__p = v210;
      *(_OWORD *)&__p[8] = xmmword_208F08680;
      if (v210 <= "InitAck chunk doesn't contain a cookie" && v210 + 38 > "InitAck chunk doesn't contain a cookie")
        goto LABEL_565;
      strcpy(v210, "InitAck chunk doesn't contain a cookie");
      v211 = *((_QWORD *)this + 42);
      if (v211 >= *((_QWORD *)this + 43))
      {
        v217 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &__src, (uint64_t)&v301);
        v218 = __p[23];
        *((_QWORD *)this + 42) = v217;
        if (v218 < 0)
          operator delete(*(void **)__p);
LABEL_428:
        if (*((_DWORD *)this + 168))
          *((_DWORD *)this + 168) = 0;
        goto LABEL_225;
      }
      if (v211)
      {
        *(_QWORD *)v211 = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
        *(_DWORD *)(v211 + 8) = 6;
        v212 = *(_OWORD *)__p;
        *(_QWORD *)(v211 + 32) = *(_QWORD *)&__p[16];
        *(_OWORD *)(v211 + 16) = v212;
        *(_QWORD *)(v211 + 56) = 2;
        *((_QWORD *)this + 42) = v211 + 64;
        goto LABEL_428;
      }
LABEL_565:
      __break(1u);
LABEL_566:
      v291 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, v300, (uint64_t)&__src);
      v292 = __len[23];
      *((_QWORD *)this + 42) = v291;
      if (v292 < 0)
        operator delete(*(void **)__len);
LABEL_560:
      v257 = *(void **)&__p[8];
      if (*(_QWORD *)&__p[8])
      {
        *(_QWORD *)&__p[16] = *(_QWORD *)&__p[8];
        goto LABEL_562;
      }
LABEL_563:
      if (v11)
      {
        v58 = (void *)v11;
LABEL_481:
        operator delete(v58);
      }
      return 1;
    case 3u:
      dcsctp::SackChunk::Parse(*((_QWORD *)a3 + 1), *((_QWORD *)a3 + 2), a5, a6, a7, a8, (uint64_t)&v307);
      if (v312)
      {
        if (*((_QWORD *)this + 85))
        {
          v48 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 39) + 56))(*((_QWORD *)this + 39));
          if (!v312)
            goto LABEL_565;
          v49 = v48;
          dcsctp::ChunkValidators::Clean(&v307, &v301);
          v50.var0 = v49;
          if (dcsctp::RetransmissionQueue::HandleSack((dcsctp::RetransmissionQueue *)(*((_QWORD *)this + 85) + 672), v50, (const dcsctp::SackChunk *)&v301))
          {
            dcsctp::DcSctpSocket::MaybeSendShutdownOrAck(this);
            dcsctp::TransmissionControlBlock::MaybeSendFastRetransmit(*((int64x2_t **)this + 85));
            v51 = *((_QWORD *)this + 85);
            LODWORD(__src) = *(_DWORD *)(v51 + 248);
            v52 = *(_DWORD *)(v51 + 28);
            WORD2(__src) = *(_DWORD *)(v51 + 24);
            HIWORD(__src) = v52;
            *(_QWORD *)__len = *(_QWORD *)(v51 + 40) & 0xFFFFFFFFFFFFFFFCLL;
            *(_QWORD *)&__len[8] = 0;
            *(_QWORD *)&__len[16] = 0;
            v306 = 0;
            dcsctp::TransmissionControlBlock::SendBufferedPackets(v51, &__src, v49);
            if (*(_QWORD *)&__len[8])
            {
              *(_QWORD *)&__len[16] = *(_QWORD *)&__len[8];
              operator delete(*(void **)&__len[8]);
            }
          }
          v301 = &off_24C0BEDA0;
          std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)v303, (_QWORD *)v303[1]);
          v53 = *(void **)&__p[8];
          if (*(_QWORD *)&__p[8])
          {
            *(_QWORD *)&__p[16] = *(_QWORD *)&__p[8];
LABEL_68:
            operator delete(v53);
          }
        }
        else
        {
          v11 = (unint64_t)dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
          __src = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
          LODWORD(v301) = 2;
          v140 = (char *)operator new(0x40uLL);
          *(_QWORD *)__p = v140;
          *(_OWORD *)&__p[8] = xmmword_208F086A0;
          if (v140 <= "Received unexpected commands on socket that is not connected"
            && v140 + 60 > "Received unexpected commands on socket that is not connected")
          {
            goto LABEL_565;
          }
          strcpy(v140, "Received unexpected commands on socket that is not connected");
          v141 = *((_QWORD *)this + 42);
          if (v141 >= *((_QWORD *)this + 43))
          {
            v190 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &__src, (uint64_t)&v301);
            v191 = __p[23];
            *((_QWORD *)this + 42) = v190;
            if (v191 < 0)
            {
              v53 = *(void **)__p;
              goto LABEL_68;
            }
          }
          else
          {
            if (!v141)
              goto LABEL_565;
            *(_QWORD *)v141 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
            *(_DWORD *)(v141 + 8) = 2;
            v142 = *(_OWORD *)__p;
            *(_QWORD *)(v141 + 32) = *(_QWORD *)&__p[16];
            *(_OWORD *)(v141 + 16) = v142;
            *(_QWORD *)(v141 + 56) = 2;
            *((_QWORD *)this + 42) = v141 + 64;
          }
        }
      }
      else
      {
        dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 3);
      }
      if (!v312)
        return 1;
      v307 = &off_24C0BEDA0;
      std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)&v310, v311);
      v58 = *(void **)&v308[8];
      if (!*(_QWORD *)&v308[8])
        return 1;
      goto LABEL_361;
    case 4u:
      dcsctp::HeartbeatRequestChunk::Parse(*((_BYTE **)a3 + 1), *((_QWORD *)a3 + 2), (uint64_t)&v301);
      if (!__p[24])
      {
        dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 4);
        return 1;
      }
      v54 = *((_QWORD *)this + 85);
      if (v54)
      {
        v55 = *(_QWORD *)&__p[16];
        v56 = *(_QWORD *)(v54 + 1400);
        (*(void (**)(void (***__return_ptr)(dcsctp::AbortChunk *__hidden), uint64_t))(*(_QWORD *)v56 + 88))(&v307, v56);
        *(_OWORD *)__len = *(_OWORD *)__p;
        __src = &off_24C0B4A90;
        *(_QWORD *)&__len[16] = v55;
        v57 = dcsctp::SctpPacket::Builder::Add((uint64_t)&v307, (uint64_t)&__src);
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v56 + 96))(v56, v57);
        __src = &off_24C0B4A90;
        if (*(_QWORD *)__len)
        {
          *(_QWORD *)&__len[8] = *(_QWORD *)__len;
          operator delete(*(void **)__len);
        }
        goto LABEL_73;
      }
      v11 = (unint64_t)dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      __src = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      LODWORD(v307) = 2;
      v143 = (char *)operator new(0x40uLL);
      *(_QWORD *)v308 = v143;
      *(_OWORD *)&v308[8] = xmmword_208F086A0;
      if (v143 <= "Received unexpected commands on socket that is not connected"
        && v143 + 60 > "Received unexpected commands on socket that is not connected")
      {
        goto LABEL_565;
      }
      strcpy(v143, "Received unexpected commands on socket that is not connected");
      v144 = *((_QWORD *)this + 42);
      if (v144 >= *((_QWORD *)this + 43))
        goto LABEL_273;
      if (!v144)
        goto LABEL_565;
      goto LABEL_267;
    case 5u:
      dcsctp::HeartbeatAckChunk::Parse(*((_BYTE **)a3 + 1), *((_QWORD *)a3 + 2), (uint64_t)&v307);
      if (!(_BYTE)v309)
      {
        dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 5);
        return 1;
      }
      v65 = *((_QWORD *)this + 85);
      if (v65)
      {
        v301 = &off_24C0B4A90;
        *(_OWORD *)__p = *(_OWORD *)v308;
        *(_QWORD *)&__p[16] = *(_QWORD *)&v308[16];
        dcsctp::HeartbeatHandler::HandleHeartbeatAck(v65 + 1384, (uint64_t)&v301, v59, v60, v61, v62, v63, v64);
        v301 = &off_24C0B4A90;
        v58 = *(void **)__p;
        if (!*(_QWORD *)__p)
          return 1;
        *(_QWORD *)&__p[8] = *(_QWORD *)__p;
        goto LABEL_481;
      }
      v11 = (unint64_t)dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      __src = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      LODWORD(v301) = 2;
      v145 = (char *)operator new(0x40uLL);
      *(_QWORD *)__p = v145;
      *(_OWORD *)&__p[8] = xmmword_208F086A0;
      if (v145 <= "Received unexpected commands on socket that is not connected"
        && v145 + 60 > "Received unexpected commands on socket that is not connected")
      {
        goto LABEL_565;
      }
      strcpy(v145, "Received unexpected commands on socket that is not connected");
      v146 = *((_QWORD *)this + 42);
      if (v146 >= *((_QWORD *)this + 43))
      {
        v192 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &__src, (uint64_t)&v301);
        v193 = __p[23];
        *((_QWORD *)this + 42) = v192;
        if (v193 < 0)
          operator delete(*(void **)__p);
      }
      else
      {
        if (!v146)
          goto LABEL_565;
        *(_QWORD *)v146 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
        *(_DWORD *)(v146 + 8) = 2;
        v147 = *(_OWORD *)__p;
        *(_QWORD *)(v146 + 32) = *(_QWORD *)&__p[16];
        *(_OWORD *)(v146 + 16) = v147;
        *(_QWORD *)(v146 + 56) = 2;
        *((_QWORD *)this + 42) = v146 + 64;
      }
      v58 = *(void **)v308;
      if (!*(_QWORD *)v308)
        return 1;
      goto LABEL_481;
    case 6u:
      dcsctp::AbortChunk::Parse(*((_BYTE **)a3 + 1), *((_QWORD *)a3 + 2), (uint64_t)&v307);
      if (!(_BYTE)v310)
      {
        dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 6);
        return 1;
      }
      dcsctp::ErrorCausesToString((unsigned __int16 **)&v308[8], v66, v67, v68, v69, (std::string *)&v301);
      v11 = __p[15];
      if (*((_QWORD *)this + 85))
      {
        if ((__p[15] & 0x80) != 0)
        {
          v11 = *(_QWORD *)__p;
          if ((*(_QWORD *)__p & 0x8000000000000000) != 0)
            goto LABEL_565;
          v70 = (void **)v301;
          if (*(_QWORD *)__p)
          {
            if (!v301)
              goto LABEL_565;
          }
        }
        else
        {
          v70 = &v301;
        }
        if (*((_DWORD *)this + 168))
        {
          v167 = *((_QWORD *)this + 52);
          if (*(_BYTE *)(v167 + 156))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(v167 + 136) + 24))(*(_QWORD *)(v167 + 136));
            *(_DWORD *)(v167 + 160) = 0;
            *(_BYTE *)(v167 + 156) = 0;
          }
          v168 = *((_QWORD *)this + 53);
          if (*(_BYTE *)(v168 + 156))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(v168 + 136) + 24))(*(_QWORD *)(v168 + 136));
            *(_DWORD *)(v168 + 160) = 0;
            *(_BYTE *)(v168 + 156) = 0;
          }
          v169 = *((_QWORD *)this + 54);
          if (*(_BYTE *)(v169 + 156))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(v169 + 136) + 24))(*(_QWORD *)(v169 + 136));
            *(_DWORD *)(v169 + 160) = 0;
            *(_BYTE *)(v169 + 156) = 0;
          }
          v170 = *((_QWORD *)this + 85);
          *((_QWORD *)this + 85) = 0;
          if (v170)
            (*(void (**)(uint64_t))(*(_QWORD *)v170 + 8))(v170);
          dcsctp::CallbackDeferrer::OnAborted((uint64_t)this + 304, 5, v70, v11);
          if (*((_DWORD *)this + 168))
            *((_DWORD *)this + 168) = 0;
        }
        if ((__p[15] & 0x80000000) == 0)
        {
LABEL_320:
          if ((_BYTE)v310)
          {
            v307 = &off_24C0ACA10;
            v58 = *(void **)&v308[8];
            if (*(_QWORD *)&v308[8])
              goto LABEL_361;
          }
          return 1;
        }
      }
      else if ((__p[15] & 0x80) == 0)
      {
        goto LABEL_320;
      }
      operator delete(v301);
      goto LABEL_320;
    case 7u:
      v71 = *((_QWORD *)a3 + 1);
      v72 = *((_QWORD *)a3 + 2);
      if (!v72)
        v71 = 0;
      if (v72 < 8 || *(_BYTE *)v71 != 7 || v72 != 8 || __rev16(*(unsigned __int16 *)(v71 + 2)) != 8)
      {
        v98 = 7;
        goto LABEL_190;
      }
      v73 = *((_DWORD *)this + 168);
      if (v73 > 7)
        goto LABEL_508;
      result = 1;
      if (((1 << v73) & 0xC7) != 0)
        return result;
      if (v73 == 5)
      {
        (*(void (**)(_QWORD *__return_ptr))(**((_QWORD **)this + 85) + 88))(&v307);
        v301 = &unk_24C0C0C80;
        v75 = dcsctp::SctpPacket::Builder::Add((uint64_t)&v307, (uint64_t)&v301);
        dcsctp::PacketSender::Send((_QWORD *)this + 55, v75, 1);
        if (*(_QWORD *)&v308[8])
        {
          *(_QWORD *)&v308[16] = *(_QWORD *)&v308[8];
          operator delete(*(void **)&v308[8]);
        }
        v76 = *((_QWORD *)this + 54);
        v77 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 85) + 56))(*((_QWORD *)this + 85));
        v78 = 86400000000;
        if (v77 < 86400000000)
          v78 = v77;
        *(_QWORD *)(v76 + 144) = v78;
        dcsctp::Timer::Start(*((dcsctp::Timer **)this + 54));
        if (*((_DWORD *)this + 168) != 7)
          *((_DWORD *)this + 168) = 7;
      }
      else
      {
LABEL_508:
        *((_DWORD *)this + 168) = 6;
        dcsctp::DcSctpSocket::MaybeSendShutdownOrAck(this);
      }
      return 1;
    case 8u:
      v79 = *((_QWORD *)a3 + 1);
      v80 = *((_QWORD *)a3 + 2);
      if (!v80)
        v79 = 0;
      if (v80 < 4 || *(_BYTE *)v79 != 8 || v80 != 4 || __rev16(*(unsigned __int16 *)(v79 + 2)) != 4)
      {
        v98 = 8;
        goto LABEL_190;
      }
      if ((*((_DWORD *)this + 168) | 2) == 7)
      {
        (*(void (**)(_QWORD *__return_ptr))(**((_QWORD **)this + 85) + 88))(&v307);
        v301 = &unk_24C0C0CE0;
        __p[0] = 0;
        dcsctp::SctpPacket::Builder::Add((uint64_t)&v307, (uint64_t)&v301);
        dcsctp::PacketSender::Send((_QWORD *)this + 55, (uint64_t)&v307, 1);
        if (*((_DWORD *)this + 168))
        {
          v81 = *((_QWORD *)this + 52);
          if (*(_BYTE *)(v81 + 156))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(v81 + 136) + 24))(*(_QWORD *)(v81 + 136));
            *(_DWORD *)(v81 + 160) = 0;
            *(_BYTE *)(v81 + 156) = 0;
          }
          v82 = *((_QWORD *)this + 53);
          if (*(_BYTE *)(v82 + 156))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(v82 + 136) + 24))(*(_QWORD *)(v82 + 136));
            *(_DWORD *)(v82 + 160) = 0;
            *(_BYTE *)(v82 + 156) = 0;
          }
          v11 = *((_QWORD *)this + 54);
          if (*(_BYTE *)(v11 + 156))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(v11 + 136) + 24))(*(_QWORD *)(v11 + 136));
            *(_DWORD *)(v11 + 160) = 0;
            *(_BYTE *)(v11 + 156) = 0;
          }
          v83 = *((_QWORD *)this + 85);
          *((_QWORD *)this + 85) = 0;
          if (v83)
            (*(void (**)(uint64_t))(*(_QWORD *)v83 + 8))(v83);
          v301 = dcsctp::CallbackDeferrer::OnClosed(void)::$_0::__invoke;
          v84 = (uint64_t (**)(uint64_t, uint64_t))*((_QWORD *)this + 42);
          if ((unint64_t)v84 >= *((_QWORD *)this + 43))
          {
            v85 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::monostate>((void **)this + 41, &v301);
          }
          else
          {
            if (!v84)
              goto LABEL_565;
            *v84 = dcsctp::CallbackDeferrer::OnClosed(void)::$_0::__invoke;
            v84[7] = 0;
            v85 = v84 + 8;
          }
          *((_QWORD *)this + 42) = v85;
          if (*((_DWORD *)this + 168))
            *((_DWORD *)this + 168) = 0;
        }
LABEL_73:
        v58 = *(void **)&v308[8];
        if (*(_QWORD *)&v308[8])
          goto LABEL_361;
      }
      else
      {
        LODWORD(v307) = *(_DWORD *)(a2 + 4);
        v224 = *((_DWORD *)this + 33);
        WORD2(v307) = *((_DWORD *)this + 32);
        HIWORD(v307) = v224;
        *(_QWORD *)v308 = *((_QWORD *)this + 18) & 0xFFFFFFFFFFFFFFFCLL;
        *(_OWORD *)&v308[8] = 0uLL;
        v309 = 0;
        v301 = &unk_24C0C0CE0;
        __p[0] = 1;
        dcsctp::SctpPacket::Builder::Add((uint64_t)&v307, (uint64_t)&v301);
        dcsctp::PacketSender::Send((_QWORD *)this + 55, (uint64_t)&v307, 1);
        v58 = *(void **)&v308[8];
        if (*(_QWORD *)&v308[8])
          goto LABEL_361;
      }
      return 1;
    case 9u:
      dcsctp::ErrorChunk::Parse(*((_BYTE **)a3 + 1), *((_QWORD *)a3 + 2), (uint64_t)&v307);
      if (!(_BYTE)v309)
      {
        dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 9);
        return 1;
      }
      dcsctp::ErrorCausesToString((unsigned __int16 **)v308, v86, v87, v88, v89, (std::string *)&v301);
      if (!*((_QWORD *)this + 85))
        goto LABEL_328;
      v90 = __p[15];
      if (__p[15] >= 0)
        v11 = __p[15];
      else
        v11 = *(_QWORD *)__p;
      v91 = v11 + 21;
      if (v11 + 21 >= 0x7FFFFFFFFFFFFFF8)
        goto LABEL_569;
      if (v91 > 0x16)
      {
        v154 = (v91 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v91 | 7) != 0x17)
          v154 = v91 | 7;
        v155 = v154 + 1;
        p_src = (char *)operator new(v154 + 1);
        *(_QWORD *)__len = v11 + 21;
        *(_QWORD *)&__len[8] = v155 | 0x8000000000000000;
        __src = p_src;
      }
      else
      {
        *(_QWORD *)__len = 0;
        *(_QWORD *)&__len[8] = 0;
        __src = 0;
        p_src = (char *)&__src;
        __len[15] = v11 + 21;
      }
      v156 = (void **)(p_src + 21);
      if (p_src <= "Peer reported error: " && v156 > (void **)"Peer reported error: ")
        goto LABEL_565;
      qmemcpy(p_src, "Peer reported error: ", 21);
      v158 = v90 >= 0 ? &v301 : (void **)v301;
      v159 = (void **)((char *)v156 + v11);
      if (v158 >= v156 && v159 > v158)
        goto LABEL_565;
      if (v11)
        memmove(v156, v158, v11);
      *(_BYTE *)v159 = 0;
      if ((__len[15] & 0x80000000) != 0)
      {
        v161 = *(_QWORD *)__len;
        if ((*(_QWORD *)__len & 0x8000000000000000) != 0)
          goto LABEL_565;
        v162 = (void **)__src;
        if (*(_QWORD *)__len)
        {
          if (!__src)
            goto LABEL_565;
        }
      }
      else
      {
        v161 = __len[15];
        v162 = &__src;
      }
      dcsctp::CallbackDeferrer::OnError((uint64_t)this + 304, 5, v162, v161);
      if ((__len[15] & 0x80000000) != 0)
        operator delete(__src);
LABEL_328:
      if ((__p[15] & 0x80000000) != 0)
        operator delete(v301);
      if ((_BYTE)v309)
      {
        v307 = &off_24C0B3D70;
        v58 = *(void **)v308;
        if (*(_QWORD *)v308)
        {
          *(_QWORD *)&v308[8] = *(_QWORD *)v308;
          goto LABEL_481;
        }
      }
      return 1;
    case 0xAu:
      v93 = *((_QWORD *)a3 + 1);
      v94 = *((_QWORD *)a3 + 2);
      if (!v94)
        v93 = 0;
      if (v94 < 4
        || *(_BYTE *)v93 != 10
        || ((v95 = __rev16(*(unsigned __int16 *)(v93 + 2)), v95 >= 4) ? (v96 = v94 >= v95) : (v96 = 0),
            v96 ? (v97 = v94 - v95 > 3) : (v97 = 1),
            v97))
      {
        v98 = 10;
        goto LABEL_190;
      }
      if (v95 < 5)
      {
        v173 = 0;
        v11 = 0;
      }
      else
      {
        v171 = v95 - 4;
        v172 = (const void *)(v93 + 4);
        v11 = (unint64_t)operator new(v95 - 4);
        v173 = v11 + v171;
        memcpy((void *)v11, v172, v171);
      }
      if (v173 == v11)
        v194 = 0;
      else
        v194 = v11;
      dcsctp::StateCookie::Deserialize(v194, v173 - v11, (uint64_t)&v307);
      if ((_BYTE)v310)
      {
        v195 = *((_QWORD *)this + 85);
        if (v195)
        {
          v196 = *(_DWORD *)(v195 + 248);
          if (*(_DWORD *)(v195 + 240) == *(_DWORD *)(a2 + 4))
          {
            if (v196 != (_DWORD)v307)
            {
              *((_QWORD *)this + 85) = 0;
              (*(void (**)(uint64_t))(*(_QWORD *)v195 + 8))(v195);
            }
          }
          else if (v196 == (_DWORD)v307 || *(_QWORD *)(v195 + 256) != *(_QWORD *)&v308[16])
          {
            if (v196 == (_DWORD)v307 && !*(_QWORD *)&v308[16])
              goto LABEL_563;
          }
          else
          {
            if (*((_DWORD *)this + 168) == 7)
            {
              LODWORD(v301) = (_DWORD)v307;
              v249 = *((_DWORD *)this + 33);
              WORD2(v301) = *((_DWORD *)this + 32);
              HIWORD(v301) = v249;
              *(_QWORD *)__p = *((_QWORD *)this + 18) & 0xFFFFFFFFFFFFFFFCLL;
              memset(&__p[8], 0, 24);
              __src = &unk_24C0C0C80;
              dcsctp::SctpPacket::Builder::Add((uint64_t)&v301, (uint64_t)&__src);
              memset(v300, 0, 24);
              dcsctp::CookieReceivedWhileShuttingDownCause::SerializeTo((uint64_t)&v314, (uint64_t)v300);
              v250 = *(_QWORD *)&v300[16];
              v251 = *(_OWORD *)v300;
              memset(v300, 0, 24);
              *(_OWORD *)__len = v251;
              __src = &off_24C0B3D70;
              *(_QWORD *)&__len[16] = v250;
              dcsctp::SctpPacket::Builder::Add((uint64_t)&v301, (uint64_t)&__src);
              __src = &off_24C0B3D70;
              if (*(_QWORD *)__len)
              {
                *(_QWORD *)&__len[8] = *(_QWORD *)__len;
                operator delete(*(void **)__len);
              }
              if (*(_QWORD *)v300)
              {
                *(_QWORD *)&v300[8] = *(_QWORD *)v300;
                operator delete(*(void **)v300);
              }
              dcsctp::PacketSender::Send((_QWORD *)this + 55, (uint64_t)&v301, 1);
              *(_QWORD *)v300 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
              LODWORD(__src) = 4;
              v252 = (char *)operator new(0x30uLL);
              *(_QWORD *)__len = v252;
              *(_OWORD *)&__len[8] = xmmword_208F086B0;
              if (v252 > "Received COOKIE-ECHO while shutting down"
                || v252 + 40 <= "Received COOKIE-ECHO while shutting down")
              {
                strcpy(v252, "Received COOKIE-ECHO while shutting down");
                v253 = *((_QWORD *)this + 42);
                if (v253 >= *((_QWORD *)this + 43))
                  goto LABEL_566;
                if (v253)
                {
                  *(_QWORD *)v253 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
                  *(_DWORD *)(v253 + 8) = 4;
                  v254 = *(_OWORD *)__len;
                  *(_QWORD *)(v253 + 32) = *(_QWORD *)&__len[16];
                  *(_OWORD *)(v253 + 16) = v254;
                  *(_QWORD *)(v253 + 56) = 2;
                  *((_QWORD *)this + 42) = v253 + 64;
                  goto LABEL_560;
                }
              }
              goto LABEL_565;
            }
            *((_QWORD *)this + 85) = 0;
            (*(void (**)(uint64_t))(*(_QWORD *)v195 + 8))(v195);
            v301 = dcsctp::CallbackDeferrer::OnConnectionRestarted(void)::$_0::__invoke;
            v274 = (uint64_t (**)(uint64_t, uint64_t))*((_QWORD *)this + 42);
            if ((unint64_t)v274 >= *((_QWORD *)this + 43))
            {
              *((_QWORD *)this + 42) = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::monostate>((void **)this + 41, &v301);
            }
            else
            {
              if (!v274)
                goto LABEL_565;
              *v274 = dcsctp::CallbackDeferrer::OnConnectionRestarted(void)::$_0::__invoke;
              v274[7] = 0;
              *((_QWORD *)this + 42) = v274 + 8;
            }
          }
LABEL_539:
          v275 = *((_QWORD *)this + 52);
          if (*(_BYTE *)(v275 + 156))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(v275 + 136) + 24))(*(_QWORD *)(v275 + 136));
            *(_DWORD *)(v275 + 160) = 0;
            *(_BYTE *)(v275 + 156) = 0;
          }
          v276 = *((_QWORD *)this + 53);
          if (*(_BYTE *)(v276 + 156))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(v276 + 136) + 24))(*(_QWORD *)(v276 + 136));
            *(_DWORD *)(v276 + 160) = 0;
            *(_BYTE *)(v276 + 156) = 0;
          }
          v277 = *((_QWORD *)this + 85);
          if (*((_DWORD *)this + 168) == 3)
          {
LABEL_556:
            if (!v277)
            {
              dcsctp::RRSendQueue::Reset((dcsctp::DcSctpSocket *)((char *)this + 480));
              if (!(_BYTE)v310)
                goto LABEL_565;
              v283 = (int)v307;
              v282 = HIDWORD(v307);
              v285 = *(_DWORD *)v308;
              v284 = *(_DWORD *)&v308[4];
              v286 = *(unsigned int *)&v308[8];
              v287 = (*(uint64_t (**)(char *, _QWORD, uint64_t))(*((_QWORD *)this + 38) + 64))((char *)this + 304, 0, 0xFFFFFFFFLL);
              v288 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*((_QWORD *)this + 38) + 64))((char *)this + 304, 1, 0xFFFFFFFFLL);
              dcsctp::DcSctpSocket::CreateTransmissionControlBlock((uint64_t)this, (uint64_t)&v309, v282, v284, v283, v285, v286, v288 | (unint64_t)(v287 << 32));
              v277 = *((_QWORD *)this + 85);
            }
            (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v277 + 88))(&v301, v277);
            __src = &unk_24C0B1700;
            dcsctp::SctpPacket::Builder::Add((uint64_t)&v301, (uint64_t)&__src);
            v289 = *((_QWORD *)this + 85);
            v290 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 39) + 56))(*((_QWORD *)this + 39));
            dcsctp::TransmissionControlBlock::SendBufferedPackets(v289, &v301, v290);
            goto LABEL_560;
          }
          if (v277 && *(_BYTE *)(v277 + 1480))
          {
            *(_QWORD *)(v277 + 1448) = &off_24C0B1730;
            v278 = *(void **)(v277 + 1456);
            if (v278)
            {
              *(_QWORD *)(v277 + 1464) = v278;
              operator delete(v278);
              v279 = *((_DWORD *)this + 168);
              *(_BYTE *)(v277 + 1480) = 0;
              if (v279 == 3)
                goto LABEL_551;
            }
            else
            {
              *(_BYTE *)(v277 + 1480) = 0;
            }
          }
          *((_DWORD *)this + 168) = 3;
LABEL_551:
          v301 = dcsctp::CallbackDeferrer::OnConnected(void)::$_0::__invoke;
          v280 = (uint64_t (**)(uint64_t, uint64_t))*((_QWORD *)this + 42);
          if ((unint64_t)v280 >= *((_QWORD *)this + 43))
          {
            v281 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::monostate>((void **)this + 41, &v301);
          }
          else
          {
            if (!v280)
              goto LABEL_565;
            *v280 = dcsctp::CallbackDeferrer::OnConnected(void)::$_0::__invoke;
            v280[7] = 0;
            v281 = v280 + 8;
          }
          *((_QWORD *)this + 42) = v281;
          v277 = *((_QWORD *)this + 85);
          goto LABEL_556;
        }
        if (*(_DWORD *)(a2 + 4) == HIDWORD(v307))
          goto LABEL_539;
        rtc::StringFormat((rtc *)"Received CookieEcho with invalid verification tag: %08x, expected %08x", (char *)&v301, *(unsigned int *)(a2 + 4), HIDWORD(v307));
        if ((__p[15] & 0x80000000) != 0)
        {
          v247 = *(_QWORD *)__p;
          if ((*(_QWORD *)__p & 0x8000000000000000) != 0)
            goto LABEL_565;
          v248 = (void **)v301;
          if (*(_QWORD *)__p)
          {
            if (!v301)
              goto LABEL_565;
          }
        }
        else
        {
          v247 = __p[15];
          v248 = &v301;
        }
        dcsctp::CallbackDeferrer::OnError((uint64_t)this + 304, 3, v248, v247);
        if ((__p[15] & 0x80000000) == 0)
          goto LABEL_563;
        v257 = v301;
      }
      else
      {
        __src = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
        LODWORD(v301) = 3;
        v221 = (char *)operator new(0x20uLL);
        *(_QWORD *)__p = v221;
        *(_OWORD *)&__p[8] = xmmword_208F05180;
        if (v221 <= "Failed to parse state cookie" && v221 + 28 > "Failed to parse state cookie")
          goto LABEL_565;
        strcpy(v221, "Failed to parse state cookie");
        v222 = *((_QWORD *)this + 42);
        if (v222 < *((_QWORD *)this + 43))
        {
          if (!v222)
            goto LABEL_565;
          *(_QWORD *)v222 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
          *(_DWORD *)(v222 + 8) = 3;
          v223 = *(_OWORD *)__p;
          *(_QWORD *)(v222 + 32) = *(_QWORD *)&__p[16];
          *(_OWORD *)(v222 + 16) = v223;
          *(_QWORD *)(v222 + 56) = 2;
          *((_QWORD *)this + 42) = v222 + 64;
          goto LABEL_563;
        }
        v255 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &__src, (uint64_t)&v301);
        v256 = __p[23];
        *((_QWORD *)this + 42) = v255;
        if ((v256 & 0x80000000) == 0)
          goto LABEL_563;
        v257 = *(void **)__p;
      }
LABEL_562:
      operator delete(v257);
      goto LABEL_563;
    case 0xBu:
      v99 = *((_QWORD *)a3 + 1);
      v100 = *((_QWORD *)a3 + 2);
      if (!v100)
        v99 = 0;
      if (v100 < 4 || *(_BYTE *)v99 != 11 || v100 != 4 || __rev16(*(unsigned __int16 *)(v99 + 2)) != 4)
      {
        v98 = 11;
        goto LABEL_190;
      }
      if (*((_DWORD *)this + 168) != 2)
        return 1;
      v101 = *((_QWORD *)this + 53);
      if (*(_BYTE *)(v101 + 156))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(v101 + 136) + 24))(*(_QWORD *)(v101 + 136));
        *(_DWORD *)(v101 + 160) = 0;
        *(_BYTE *)(v101 + 156) = 0;
      }
      v102 = *((_QWORD *)this + 85);
      if (*(_BYTE *)(v102 + 1480))
      {
        *(_QWORD *)(v102 + 1448) = &off_24C0B1730;
        v103 = *(void **)(v102 + 1456);
        if (v103)
        {
          *(_QWORD *)(v102 + 1464) = v103;
          operator delete(v103);
        }
        *(_BYTE *)(v102 + 1480) = 0;
      }
      if (*((_DWORD *)this + 168) != 3)
        *((_DWORD *)this + 168) = 3;
      v11 = *((_QWORD *)this + 85);
      v104 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 39) + 56))(*((_QWORD *)this + 39));
      LODWORD(v307) = *(_DWORD *)(v11 + 248);
      v105 = *(_DWORD *)(v11 + 28);
      WORD2(v307) = *(_DWORD *)(v11 + 24);
      HIWORD(v307) = v105;
      *(_QWORD *)v308 = *(_QWORD *)(v11 + 40) & 0xFFFFFFFFFFFFFFFCLL;
      *(_OWORD *)&v308[8] = 0uLL;
      v309 = 0;
      dcsctp::TransmissionControlBlock::SendBufferedPackets(v11, &v307, v104);
      if (*(_QWORD *)&v308[8])
      {
        *(_QWORD *)&v308[16] = *(_QWORD *)&v308[8];
        operator delete(*(void **)&v308[8]);
      }
      v307 = (void (**)(dcsctp::AbortChunk *__hidden))dcsctp::CallbackDeferrer::OnConnected(void)::$_0::__invoke;
      v106 = (uint64_t (**)(uint64_t, uint64_t))*((_QWORD *)this + 42);
      if ((unint64_t)v106 >= *((_QWORD *)this + 43))
      {
        v107 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::monostate>((void **)this + 41, &v307);
      }
      else
      {
        if (!v106)
          goto LABEL_565;
        *v106 = dcsctp::CallbackDeferrer::OnConnected(void)::$_0::__invoke;
        v106[7] = 0;
        v107 = v106 + 8;
      }
      *((_QWORD *)this + 42) = v107;
      return 1;
    case 0xCu:
    case 0xDu:
    case 0xFu:
    case 0x10u:
    case 0x11u:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
    case 0x1Eu:
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x22u:
    case 0x23u:
    case 0x24u:
    case 0x25u:
    case 0x26u:
    case 0x27u:
    case 0x28u:
    case 0x29u:
    case 0x2Au:
    case 0x2Bu:
    case 0x2Cu:
    case 0x2Du:
    case 0x2Eu:
    case 0x2Fu:
    case 0x30u:
    case 0x31u:
    case 0x32u:
    case 0x33u:
    case 0x34u:
    case 0x35u:
    case 0x36u:
    case 0x37u:
    case 0x38u:
    case 0x39u:
    case 0x3Au:
    case 0x3Bu:
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x3Fu:
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
    case 0x46u:
    case 0x47u:
    case 0x48u:
    case 0x49u:
    case 0x4Au:
    case 0x4Bu:
    case 0x4Cu:
    case 0x4Du:
    case 0x4Eu:
    case 0x4Fu:
    case 0x50u:
    case 0x51u:
    case 0x52u:
    case 0x53u:
    case 0x54u:
    case 0x55u:
    case 0x56u:
    case 0x57u:
    case 0x58u:
    case 0x59u:
    case 0x5Au:
    case 0x5Bu:
    case 0x5Cu:
    case 0x5Du:
    case 0x5Eu:
    case 0x5Fu:
    case 0x60u:
    case 0x61u:
    case 0x62u:
    case 0x63u:
    case 0x64u:
    case 0x65u:
    case 0x66u:
    case 0x67u:
    case 0x68u:
    case 0x69u:
    case 0x6Au:
    case 0x6Bu:
    case 0x6Cu:
    case 0x6Du:
    case 0x6Eu:
    case 0x6Fu:
    case 0x70u:
    case 0x71u:
    case 0x72u:
    case 0x73u:
    case 0x74u:
    case 0x75u:
    case 0x76u:
    case 0x77u:
    case 0x78u:
    case 0x79u:
    case 0x7Au:
    case 0x7Bu:
    case 0x7Cu:
    case 0x7Du:
    case 0x7Eu:
    case 0x7Fu:
    case 0x80u:
    case 0x81u:
      goto LABEL_14;
    case 0xEu:
      v108 = *((_QWORD *)a3 + 1);
      v109 = *((_QWORD *)a3 + 2);
      if (!v109)
        v108 = 0;
      if (v109 >= 4 && *(_BYTE *)v108 == 14 && v109 == 4 && __rev16(*(unsigned __int16 *)(v108 + 2)) == 4)
      {
        if (*((_DWORD *)this + 168) != 7)
          return 1;
        v110 = *((_QWORD *)this + 52);
        if (*(_BYTE *)(v110 + 156))
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(v110 + 136) + 24))(*(_QWORD *)(v110 + 136));
          *(_DWORD *)(v110 + 160) = 0;
          *(_BYTE *)(v110 + 156) = 0;
        }
        v111 = *((_QWORD *)this + 53);
        if (*(_BYTE *)(v111 + 156))
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(v111 + 136) + 24))(*(_QWORD *)(v111 + 136));
          *(_DWORD *)(v111 + 160) = 0;
          *(_BYTE *)(v111 + 156) = 0;
        }
        v11 = *((_QWORD *)this + 54);
        if (*(_BYTE *)(v11 + 156))
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(v11 + 136) + 24))(*(_QWORD *)(v11 + 136));
          *(_DWORD *)(v11 + 160) = 0;
          *(_BYTE *)(v11 + 156) = 0;
        }
        v112 = *((_QWORD *)this + 85);
        *((_QWORD *)this + 85) = 0;
        if (v112)
          (*(void (**)(uint64_t))(*(_QWORD *)v112 + 8))(v112);
        v307 = (void (**)(dcsctp::AbortChunk *__hidden))dcsctp::CallbackDeferrer::OnClosed(void)::$_0::__invoke;
        v113 = (uint64_t (**)(uint64_t, uint64_t))*((_QWORD *)this + 42);
        if ((unint64_t)v113 >= *((_QWORD *)this + 43))
        {
          v114 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::monostate>((void **)this + 41, &v307);
        }
        else
        {
          if (!v113)
            goto LABEL_565;
          *v113 = dcsctp::CallbackDeferrer::OnClosed(void)::$_0::__invoke;
          v113[7] = 0;
          v114 = v113 + 8;
        }
        *((_QWORD *)this + 42) = v114;
        if (*((_DWORD *)this + 168))
          *((_DWORD *)this + 168) = 0;
      }
      else
      {
        v98 = 14;
LABEL_190:
        dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, v98);
      }
      return 1;
    case 0x40u:
      dcsctp::IDataChunk::Parse(*((_DWORD **)a3 + 1), *((_QWORD *)a3 + 2), (uint64_t)&v307);
      if (v313)
      {
        if (*((_QWORD *)this + 85))
        {
LABEL_178:
          dcsctp::DcSctpSocket::HandleDataCommon(this, (dcsctp::AnyDataChunk *)&v307);
        }
        else
        {
LABEL_4:
          v11 = (unint64_t)dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
          __src = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
          LODWORD(v301) = 2;
          v13 = (char *)operator new(0x40uLL);
          *(_QWORD *)__p = v13;
          *(_OWORD *)&__p[8] = xmmword_208F086A0;
          if (v13 <= "Received unexpected commands on socket that is not connected"
            && v13 + 60 > "Received unexpected commands on socket that is not connected")
          {
            goto LABEL_565;
          }
          strcpy(v13, "Received unexpected commands on socket that is not connected");
          v14 = *((_QWORD *)this + 42);
          if (v14 >= *((_QWORD *)this + 43))
          {
            v150 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &__src, (uint64_t)&v301);
            v151 = __p[23];
            *((_QWORD *)this + 42) = v150;
            if (v151 < 0)
              operator delete(*(void **)__p);
          }
          else
          {
            if (!v14)
              goto LABEL_565;
            *(_QWORD *)v14 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
            *(_DWORD *)(v14 + 8) = 2;
            v15 = *(_OWORD *)__p;
            *(_QWORD *)(v14 + 32) = *(_QWORD *)&__p[16];
            *(_OWORD *)(v14 + 16) = v15;
            *(_QWORD *)(v14 + 56) = 2;
            *((_QWORD *)this + 42) = v14 + 64;
          }
        }
      }
      else
      {
        dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 64);
      }
LABEL_270:
      if (v313)
      {
        v307 = (void (**)(dcsctp::AbortChunk *__hidden))&unk_24C0B1318;
        v58 = v309;
        if (v309)
        {
          v310 = v309;
          goto LABEL_481;
        }
      }
      return 1;
    case 0x82u:
      v115 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 39) + 56))(*((_QWORD *)this + 39));
      dcsctp::ReConfigChunk::Parse(*((unsigned __int8 **)a3 + 1), *((_QWORD *)a3 + 2), (uint64_t)&v301);
      if (!__p[24])
      {
        dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 130);
        return 1;
      }
      v122 = *((_QWORD *)this + 85);
      if (v122)
      {
        *(_OWORD *)__len = *(_OWORD *)__p;
        __src = &off_24C0BB340;
        *(_QWORD *)&__len[16] = *(_QWORD *)&__p[16];
        dcsctp::StreamResetHandler::HandleReConfig(v122 + 1240, (uint64_t)&__src, v116, v117, v118, v119, v120, v121);
        __src = &off_24C0BB340;
        if (*(_QWORD *)__len)
        {
          *(_QWORD *)&__len[8] = *(_QWORD *)__len;
          operator delete(*(void **)__len);
        }
        dcsctp::DcSctpSocket::MaybeSendResetStreamsRequest(this);
        v123 = *((_QWORD *)this + 85);
        LODWORD(v307) = *(_DWORD *)(v123 + 248);
        v124 = *(_DWORD *)(v123 + 28);
        WORD2(v307) = *(_DWORD *)(v123 + 24);
        HIWORD(v307) = v124;
        *(_QWORD *)v308 = *(_QWORD *)(v123 + 40) & 0xFFFFFFFFFFFFFFFCLL;
        *(_OWORD *)&v308[8] = 0uLL;
        v309 = 0;
        dcsctp::TransmissionControlBlock::SendBufferedPackets(v123, &v307, v115);
        if (*(_QWORD *)&v308[8])
        {
          *(_QWORD *)&v308[16] = *(_QWORD *)&v308[8];
          operator delete(*(void **)&v308[8]);
        }
        dcsctp::DcSctpSocket::MaybeDeliverMessages(this);
        return 1;
      }
      v11 = (unint64_t)dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      __src = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      LODWORD(v307) = 2;
      v148 = (char *)operator new(0x40uLL);
      *(_QWORD *)v308 = v148;
      *(_OWORD *)&v308[8] = xmmword_208F086A0;
      if (v148 <= "Received unexpected commands on socket that is not connected"
        && v148 + 60 > "Received unexpected commands on socket that is not connected")
      {
        goto LABEL_565;
      }
      strcpy(v148, "Received unexpected commands on socket that is not connected");
      v144 = *((_QWORD *)this + 42);
      if (v144 >= *((_QWORD *)this + 43))
      {
LABEL_273:
        v152 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &__src, (uint64_t)&v307);
        v153 = v308[23];
        *((_QWORD *)this + 42) = v152;
        if (v153 < 0)
          operator delete(*(void **)v308);
      }
      else
      {
        if (!v144)
          goto LABEL_565;
LABEL_267:
        *(_QWORD *)v144 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
        *(_DWORD *)(v144 + 8) = 2;
        v149 = *(_OWORD *)v308;
        *(_QWORD *)(v144 + 32) = *(_QWORD *)&v308[16];
        *(_OWORD *)(v144 + 16) = v149;
        *(_QWORD *)(v144 + 56) = 2;
        *((_QWORD *)this + 42) = v144 + 64;
      }
      v58 = *(void **)__p;
      if (!*(_QWORD *)__p)
        return 1;
      goto LABEL_481;
    default:
      if ((_DWORD)v11 == 192)
      {
        dcsctp::ForwardTsnChunk::Parse(*((unsigned __int8 **)a3 + 1), *((_QWORD *)a3 + 2), &v307);
        if (!(_BYTE)v310)
        {
          dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 192);
          goto LABEL_297;
        }
        if (*((_QWORD *)this + 85))
        {
LABEL_13:
          dcsctp::DcSctpSocket::HandleForwardTsnCommon(this, (const dcsctp::AnyForwardTsnChunk *)&v307);
          goto LABEL_297;
        }
      }
      else
      {
        if ((_DWORD)v11 != 194)
        {
LABEL_14:
          if ((v11 & 0x40) != 0)
          {
            v16 = (char *)operator new(0x30uLL);
            if (v16 <= "Received unknown chunk of type: " && v16 + 32 > "Received unknown chunk of type: ")
              goto LABEL_565;
            strcpy(v16, "Received unknown chunk of type: ");
            *(_QWORD *)v300 = v16;
            *(_OWORD *)&v300[8] = xmmword_208F086C0;
            v17 = rtc::StringBuilder::operator<<((std::string *)v300, v11);
            v18 = SHIBYTE(v17->__r_.__value_.__r.__words[2]);
            if (v18 >= 0)
              v19 = 22;
            else
              v19 = (v17->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
            if (v18 >= 0)
              size = HIBYTE(v17->__r_.__value_.__r.__words[2]);
            else
              size = v17->__r_.__value_.__l.__size_;
            if (v19 - size >= 0x1A)
            {
              if (v18 >= 0)
                v137 = v17;
              else
                v137 = (std::string *)v17->__r_.__value_.__r.__words[0];
              if ((char *)v137 + size <= " with report-error bit set"
                && &v137[1].__r_.__value_.__s.__data_[size + 2] > " with report-error bit set")
              {
                goto LABEL_565;
              }
              qmemcpy((char *)v137 + size, " with report-error bit set", 26);
              v139 = size + 26;
              if (SHIBYTE(v17->__r_.__value_.__r.__words[2]) < 0)
                v17->__r_.__value_.__l.__size_ = v139;
              else
                *((_BYTE *)&v17->__r_.__value_.__s + 23) = v139 & 0x7F;
              v137->__r_.__value_.__s.__data_[v139] = 0;
            }
            else
            {
              std::string::__grow_by_and_replace(v17, v19, size - v19 + 26, size, size, 0, 0x1AuLL, " with report-error bit set");
            }
            if ((v300[23] & 0x80000000) != 0)
            {
              v174 = *(_QWORD *)&v300[8];
              if ((*(_QWORD *)&v300[8] & 0x8000000000000000) != 0)
                goto LABEL_565;
              v175 = *(void ***)v300;
              if (*(_QWORD *)&v300[8])
              {
                if (!*(_QWORD *)v300)
                  goto LABEL_565;
              }
            }
            else
            {
              v174 = v300[23];
              v175 = (void **)v300;
            }
            dcsctp::CallbackDeferrer::OnError((uint64_t)this + 304, 3, v175, v174);
            v176 = *((_QWORD *)this + 85);
            if (v176)
            {
              (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)v176 + 88))(&v307);
              v314 = 0uLL;
              v315 = 0;
              v183 = *((_QWORD *)a3 + 2);
              if (v183)
              {
                if ((v183 & 0x8000000000000000) != 0)
                  goto LABEL_569;
                v184 = (const void *)*((_QWORD *)a3 + 1);
                v185 = (char *)operator new(*((_QWORD *)a3 + 2));
                v186 = &v185[v183];
                memcpy(v185, v184, v183);
              }
              else
              {
                v185 = 0;
                v186 = 0;
              }
              __src = &off_24C0C2E68;
              *(_QWORD *)__len = v185;
              *(_QWORD *)&__len[8] = v186;
              *(_QWORD *)&__len[16] = v186;
              dcsctp::UnrecognizedChunkTypeCause::SerializeTo((uint64_t)&__src, (uint64_t)&v314, v177, v178, v179, v180, v181, v182);
              v187 = v315;
              v188 = v314;
              v315 = 0;
              v314 = 0uLL;
              v301 = &off_24C0B3D70;
              *(_OWORD *)__p = v188;
              *(_QWORD *)&__p[16] = v187;
              v189 = dcsctp::SctpPacket::Builder::Add((uint64_t)&v307, (uint64_t)&v301);
              dcsctp::PacketSender::Send((_QWORD *)this + 55, v189, 1);
              v301 = &off_24C0B3D70;
              if (*(_QWORD *)__p)
              {
                *(_QWORD *)&__p[8] = *(_QWORD *)__p;
                operator delete(*(void **)__p);
              }
              if (v185)
                operator delete(v185);
              if ((_QWORD)v314)
              {
                *((_QWORD *)&v314 + 1) = v314;
                operator delete((void *)v314);
              }
              if (*(_QWORD *)&v308[8])
              {
                *(_QWORD *)&v308[16] = *(_QWORD *)&v308[8];
                operator delete(*(void **)&v308[8]);
              }
            }
            if ((v300[23] & 0x80000000) != 0)
              operator delete(*(void **)v300);
          }
          return (v11 & 0x80u) != 0;
        }
        dcsctp::IForwardTsnChunk::Parse(*((unsigned __int8 **)a3 + 1), *((_QWORD *)a3 + 2), &v307);
        if (!(_BYTE)v310)
        {
          dcsctp::DcSctpSocket::ReportFailedToParseChunk(this, 194);
          goto LABEL_297;
        }
        if (*((_QWORD *)this + 85))
          goto LABEL_13;
      }
      v11 = (unint64_t)dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      __src = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
      LODWORD(v301) = 2;
      v125 = (char *)operator new(0x40uLL);
      *(_QWORD *)__p = v125;
      *(_OWORD *)&__p[8] = xmmword_208F086A0;
      if (v125 <= "Received unexpected commands on socket that is not connected"
        && v125 + 60 > "Received unexpected commands on socket that is not connected")
      {
        goto LABEL_565;
      }
      strcpy(v125, "Received unexpected commands on socket that is not connected");
      v126 = *((_QWORD *)this + 42);
      if (v126 >= *((_QWORD *)this + 43))
      {
        v163 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &__src, (uint64_t)&v301);
        v164 = __p[23];
        *((_QWORD *)this + 42) = v163;
        if (v164 < 0)
          operator delete(*(void **)__p);
      }
      else
      {
        if (!v126)
          goto LABEL_565;
        *(_QWORD *)v126 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
        *(_DWORD *)(v126 + 8) = 2;
        v127 = *(_OWORD *)__p;
        *(_QWORD *)(v126 + 32) = *(_QWORD *)&__p[16];
        *(_OWORD *)(v126 + 16) = v127;
        *(_QWORD *)(v126 + 56) = 2;
        *((_QWORD *)this + 42) = v126 + 64;
      }
LABEL_297:
      if (!(_BYTE)v310)
        return 1;
      v307 = (void (**)(dcsctp::AbortChunk *__hidden))&unk_24C0B1348;
      v58 = *(void **)&v308[8];
      if (!*(_QWORD *)&v308[8])
        return 1;
LABEL_361:
      *(_QWORD *)&v308[16] = v58;
      goto LABEL_481;
  }
}

void dcsctp::DcSctpSocket::ReportFailedToParseChunk(dcsctp::DcSctpSocket *this, int a2)
{
  char *v4;
  size_t size;
  std::string *p_p;
  std::string __p;

  v4 = (char *)operator new(0x30uLL);
  if (v4 <= "Failed to parse chunk of type: " && v4 + 31 > "Failed to parse chunk of type: ")
    goto LABEL_10;
  strcpy(v4, "Failed to parse chunk of type: ");
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v4;
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_208F086D0;
  rtc::StringBuilder::operator<<(&__p, a2);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    size = __p.__r_.__value_.__l.__size_;
    if ((__p.__r_.__value_.__l.__size_ & 0x8000000000000000) == 0)
    {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if (!__p.__r_.__value_.__l.__size_ || __p.__r_.__value_.__r.__words[0])
        goto LABEL_8;
    }
LABEL_10:
    __break(1u);
    return;
  }
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  p_p = &__p;
LABEL_8:
  dcsctp::CallbackDeferrer::OnError((uint64_t)this + 304, 3, (void **)&p_p->__r_.__value_.__l.__data_, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void dcsctp::DcSctpSocket::HandleDataCommon(dcsctp::DcSctpSocket *this, dcsctp::AnyDataChunk *a2)
{
  uint64_t v3;
  char v4;
  void *v5;
  __int128 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int v10;
  BOOL v11;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  char *v23;
  unint64_t v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  unint64_t v34;
  __int128 v35;
  char *v36;
  int v37;
  char *v38;
  int v39;
  __int128 v40;
  __int128 v41;
  void *__p;
  __int128 v43;
  __int16 v44;
  char v45;
  void (**v46)(dcsctp::AbortChunk *__hidden);
  _BYTE v47[24];
  uint64_t v48;
  void *v49;
  int v50;
  void *v51[2];
  uint64_t v52;
  uint64_t v53;
  _BYTE v54[24];
  __int16 v55;
  char v56;
  __int128 v57;

  v3 = *((unsigned int *)a2 + 2);
  v4 = *((_BYTE *)a2 + 64);
  v57 = *((_OWORD *)a2 + 1);
  v5 = (void *)*((_QWORD *)a2 + 4);
  v6 = *(_OWORD *)((char *)a2 + 40);
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 5) = 0;
  *((_QWORD *)a2 + 6) = 0;
  v55 = *((_WORD *)a2 + 28);
  v56 = *((_BYTE *)a2 + 58);
  if (v5 == (void *)v6)
  {
    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 85) + 88))(&v53);
    v51[0] = 0;
    v51[1] = 0;
    v52 = 0;
    v49 = &unk_24C0B7938;
    v50 = v3;
    dcsctp::NoUserDataCause::SerializeTo((uint64_t)&v49, (uint64_t)v51);
    v20 = v52;
    v21 = *(_OWORD *)v51;
    v51[1] = 0;
    v52 = 0;
    v51[0] = 0;
    v46 = &off_24C0B3D70;
    *(_OWORD *)v47 = v21;
    *(_QWORD *)&v47[16] = v20;
    v22 = dcsctp::SctpPacket::Builder::Add((uint64_t)&v53, (uint64_t)&v46);
    dcsctp::PacketSender::Send((_QWORD *)this + 55, v22, 1);
    v46 = &off_24C0B3D70;
    if (*(_QWORD *)v47)
    {
      *(_QWORD *)&v47[8] = *(_QWORD *)v47;
      operator delete(*(void **)v47);
    }
    if (v51[0])
    {
      v51[1] = v51[0];
      operator delete(v51[0]);
    }
    if (*(_QWORD *)&v54[8])
    {
      *(_QWORD *)&v54[16] = *(_QWORD *)&v54[8];
      operator delete(*(void **)&v54[8]);
    }
    v46 = (void (**)(dcsctp::AbortChunk *__hidden))dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
    LODWORD(v53) = 6;
    v23 = (char *)operator new(0x28uLL);
    *(_QWORD *)v54 = v23;
    *(_OWORD *)&v54[8] = xmmword_208F086E0;
    if (v23 > "Received DATA chunk with no user data" || v23 + 37 <= "Received DATA chunk with no user data")
    {
      strcpy(v23, "Received DATA chunk with no user data");
      v24 = *((_QWORD *)this + 42);
      if (v24 >= *((_QWORD *)this + 43))
      {
        v36 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &v46, (uint64_t)&v53);
        v37 = v54[23];
        *((_QWORD *)this + 42) = v36;
        if ((v37 & 0x80000000) == 0)
          goto LABEL_70;
        operator delete(*(void **)v54);
        if (!v5)
          return;
LABEL_71:
        operator delete(v5);
        return;
      }
      if (v24)
      {
        *(_QWORD *)v24 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
        *(_DWORD *)(v24 + 8) = 6;
        v25 = *(_OWORD *)v54;
        *(_QWORD *)(v24 + 32) = *(_QWORD *)&v54[16];
        *(_OWORD *)(v24 + 16) = v25;
        *(_QWORD *)(v24 + 56) = 2;
        *((_QWORD *)this + 42) = v24 + 64;
        if (!v5)
          return;
        goto LABEL_71;
      }
    }
    goto LABEL_74;
  }
  v7 = *((_QWORD *)this + 85);
  v8 = *(_QWORD *)(v7 + 656);
  if (v8 >= *(_QWORD *)(v7 + 536))
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v7 + 88))(&v53);
    v51[0] = 0;
    v51[1] = 0;
    v52 = 0;
    dcsctp::OutOfResourceErrorCause::SerializeTo((uint64_t)&v49, (uint64_t)v51);
    v26 = v52;
    v27 = *(_OWORD *)v51;
    v51[1] = 0;
    v52 = 0;
    v51[0] = 0;
    v46 = &off_24C0ACA10;
    v47[0] = 1;
    *(_OWORD *)&v47[8] = v27;
    v48 = v26;
    v28 = dcsctp::SctpPacket::Builder::Add((uint64_t)&v53, (uint64_t)&v46);
    dcsctp::PacketSender::Send((_QWORD *)this + 55, v28, 1);
    v46 = &off_24C0ACA10;
    if (*(_QWORD *)&v47[8])
    {
      *(_QWORD *)&v47[16] = *(_QWORD *)&v47[8];
      operator delete(*(void **)&v47[8]);
    }
    if (v51[0])
    {
      v51[1] = v51[0];
      operator delete(v51[0]);
    }
    if (*(_QWORD *)&v54[8])
    {
      *(_QWORD *)&v54[16] = *(_QWORD *)&v54[8];
      operator delete(*(void **)&v54[8]);
    }
    if (!*((_DWORD *)this + 168))
    {
LABEL_70:
      if (!v5)
        return;
      goto LABEL_71;
    }
    v29 = *((_QWORD *)this + 52);
    if (*(_BYTE *)(v29 + 156))
    {
      (*(void (**)(_QWORD))(**(_QWORD **)(v29 + 136) + 24))(*(_QWORD *)(v29 + 136));
      *(_DWORD *)(v29 + 160) = 0;
      *(_BYTE *)(v29 + 156) = 0;
    }
    v30 = *((_QWORD *)this + 53);
    if (*(_BYTE *)(v30 + 156))
    {
      (*(void (**)(_QWORD))(**(_QWORD **)(v30 + 136) + 24))(*(_QWORD *)(v30 + 136));
      *(_DWORD *)(v30 + 160) = 0;
      *(_BYTE *)(v30 + 156) = 0;
    }
    v31 = *((_QWORD *)this + 54);
    if (*(_BYTE *)(v31 + 156))
    {
      (*(void (**)(_QWORD))(**(_QWORD **)(v31 + 136) + 24))(*(_QWORD *)(v31 + 136));
      *(_DWORD *)(v31 + 160) = 0;
      *(_BYTE *)(v31 + 156) = 0;
    }
    v32 = *((_QWORD *)this + 85);
    *((_QWORD *)this + 85) = 0;
    if (v32)
      (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
    v46 = (void (**)(dcsctp::AbortChunk *__hidden))dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
    LODWORD(v53) = 7;
    v33 = (char *)operator new(0x20uLL);
    *(_QWORD *)v54 = v33;
    *(_OWORD *)&v54[8] = xmmword_208F05190;
    if (v33 > "Reassembly Queue is exhausted" || v33 + 29 <= "Reassembly Queue is exhausted")
    {
      strcpy(v33, "Reassembly Queue is exhausted");
      v34 = *((_QWORD *)this + 42);
      if (v34 >= *((_QWORD *)this + 43))
      {
        v38 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &v46, (uint64_t)&v53);
        v39 = v54[23];
        *((_QWORD *)this + 42) = v38;
        if (v39 < 0)
          operator delete(*(void **)v54);
        goto LABEL_68;
      }
      if (v34)
      {
        *(_QWORD *)v34 = dcsctp::CallbackDeferrer::OnAborted(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
        *(_DWORD *)(v34 + 8) = 7;
        v35 = *(_OWORD *)v54;
        *(_QWORD *)(v34 + 32) = *(_QWORD *)&v54[16];
        *(_OWORD *)(v34 + 16) = v35;
        *(_QWORD *)(v34 + 56) = 2;
        *((_QWORD *)this + 42) = v34 + 64;
LABEL_68:
        if (*((_DWORD *)this + 168))
          *((_DWORD *)this + 168) = 0;
        goto LABEL_70;
      }
    }
LABEL_74:
    __break(1u);
    return;
  }
  if (v8 >= *(_QWORD *)(v7 + 544))
  {
    v9 = v3;
    if (*(_BYTE *)(v7 + 460))
    {
      v10 = *(_DWORD *)(v7 + 456);
      v11 = v3 >= v10;
      v12 = v3 - v10;
      v13 = (_DWORD)v12 != 0 && v11;
      if ((_DWORD)v12 != 0x80000000)
        v13 = (int)v12 >= 0;
      if (!v13)
        v12 |= 0xFFFFFFFF00000000;
      v9 = v12 + *(_QWORD *)(v7 + 448);
    }
    if (v9 != *(_QWORD *)(v7 + 464) + 1)
    {
      *(_DWORD *)(v7 + 440) = 3;
      if (!v5)
        return;
      goto LABEL_71;
    }
  }
  v14 = v3;
  if (*(_BYTE *)(v7 + 460))
  {
    v15 = *(_DWORD *)(v7 + 456);
    v11 = v3 >= v15;
    v16 = v3 - v15;
    v17 = (_DWORD)v16 != 0 && v11;
    if ((_DWORD)v16 != 0x80000000)
      v17 = (int)v16 >= 0;
    if (!v17)
      v16 |= 0xFFFFFFFF00000000;
    v14 = v16 + *(_QWORD *)(v7 + 448);
  }
  v18 = v14 - *(_QWORD *)(v7 + 464);
  if (v18 < 0)
    v18 = *(_QWORD *)(v7 + 464) - v14;
  if (v18 > 0x186A0)
    goto LABEL_70;
  v40 = v6;
  if (!dcsctp::DataTracker::Observe(v7 + 408, v3, v4))
    goto LABEL_70;
  v19 = *((_QWORD *)this + 85) + 520;
  v41 = v57;
  __p = v5;
  v43 = v40;
  v44 = v55;
  v45 = v56;
  dcsctp::ReassemblyQueue::Add(v19, v3, (unsigned __int16 *)&v41);
  if (__p)
  {
    *(_QWORD *)&v43 = __p;
    operator delete(__p);
  }
  dcsctp::DcSctpSocket::MaybeDeliverMessages(this);
}

void dcsctp::DcSctpSocket::MaybeDeliverMessages(dcsctp::DcSctpSocket *this)
{
  _QWORD *v1;
  char *v2;
  char *v3;
  void **v5;
  char *v6;
  unint64_t v7;
  char *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *__p[2];
  uint64_t v13;
  void (*v14)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  v1 = (_QWORD *)*((_QWORD *)this + 85);
  v2 = (char *)v1[71];
  v1[71] = 0;
  v3 = (char *)v1[72];
  v1[73] = 0;
  v1[72] = 0;
  if (v2 == v3)
  {
    if (!v2)
      return;
  }
  else
  {
    v5 = (void **)((char *)this + 328);
    v6 = v2;
    do
    {
      ++*((_QWORD *)this + 13);
      v11 = *(_QWORD *)v6;
      *(_OWORD *)__p = *(_OWORD *)(v6 + 8);
      v13 = *((_QWORD *)v6 + 3);
      *((_QWORD *)v6 + 1) = 0;
      *((_QWORD *)v6 + 2) = 0;
      *((_QWORD *)v6 + 3) = 0;
      v14 = dcsctp::CallbackDeferrer::OnMessageReceived(dcsctp::DcSctpMessage)::$_0::__invoke;
      v7 = *((_QWORD *)this + 42);
      if (v7 >= *((_QWORD *)this + 43))
      {
        v8 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::DcSctpMessage>(v5, &v14, &v11);
        v9 = __p[0];
        *((_QWORD *)this + 42) = v8;
        if (v9)
        {
          __p[1] = v9;
          operator delete(v9);
        }
      }
      else
      {
        if (!v7)
        {
          __break(1u);
          return;
        }
        *(_QWORD *)v7 = dcsctp::CallbackDeferrer::OnMessageReceived(dcsctp::DcSctpMessage)::$_0::__invoke;
        *(_QWORD *)(v7 + 8) = v11;
        *(_QWORD *)(v7 + 24) = 0;
        *(_QWORD *)(v7 + 32) = 0;
        *(_OWORD *)(v7 + 16) = *(_OWORD *)__p;
        *(_QWORD *)(v7 + 32) = v13;
        __p[0] = 0;
        __p[1] = 0;
        v13 = 0;
        *(_QWORD *)(v7 + 56) = 1;
        *((_QWORD *)this + 42) = v7 + 64;
      }
      v6 += 32;
    }
    while (v6 != v3);
    if (!v2)
      return;
    do
    {
      v10 = (void *)*((_QWORD *)v3 - 3);
      if (v10)
      {
        *((_QWORD *)v3 - 2) = v10;
        operator delete(v10);
      }
      v3 -= 32;
    }
    while (v3 != v2);
  }
  operator delete(v2);
}

uint64_t dcsctp::`anonymous namespace'::ComputeCapabilities(uint64_t a1, unsigned int a2, unsigned int a3, unsigned __int16 **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  char *v9;
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  unint64_t v26;
  unint64_t v27;
  BOOL v28;
  BOOL v29;
  char v30;
  char v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  unint64_t v34;
  char *v35;
  unsigned __int16 *v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  char *v40;
  unsigned __int16 *v41;
  char v42;
  _BOOL4 v43;
  size_t v44;
  unsigned __int16 *v45;
  unint64_t v46;
  unsigned __int16 *v47;
  unsigned int v48;
  unint64_t v50;
  unint64_t v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  char *v58;
  char *v59;
  unsigned __int16 *v60;
  unsigned __int16 *v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  char *v68;
  unsigned __int16 *v69;
  unsigned __int16 *v70;
  _BOOL4 v71;
  uint64_t v72;
  unint64_t v73;
  unsigned __int16 *v74;
  unint64_t v76;
  unsigned int v77;
  unsigned int v78;
  char v79;
  uint64_t v80;
  uint64_t v81;
  unsigned __int16 *v83;
  unsigned __int16 *v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  char *v91;
  unsigned __int16 *v92;
  unsigned __int16 *v93;
  int v94;
  uint64_t v95;
  unint64_t v96;
  unsigned __int16 *v97;
  char v98;
  size_t v99;
  const void *v100;
  std::string *v101;
  const dcsctp::AnyForwardTsnChunk *v102;
  uint64_t v103;
  unsigned int v104;
  unsigned int v105;
  unsigned __int16 *v106;
  unsigned __int16 *v107;
  uint64_t v108;
  uint64_t v109;
  unsigned __int16 *v110;
  __int16 v111;

  v14 = *a4;
  v15 = a4[1];
  v107 = 0;
  v108 = 0;
  v106 = 0;
  v16 = (char *)((char *)v15 - (char *)v14);
  if (v15 == v14)
  {
    v23 = 0;
    goto LABEL_36;
  }
  v17 = (char *)v14;
  do
  {
    if ((unint64_t)v16 <= 3)
      goto LABEL_205;
    v111 = 0;
    v111 = bswap32(*(unsigned __int16 *)v17) >> 16;
    v8 = (char *)__rev16(*((unsigned __int16 *)v17 + 1));
    if (v16 >= v8)
      v18 = v8;
    else
      v18 = v16;
    if (v18)
      v19 = (uint64_t)v17;
    else
      v19 = 0;
    v109 = v19;
    v110 = (unsigned __int16 *)v18;
    std::vector<dcsctp::ParameterDescriptor>::emplace_back<unsigned short &,rtc::ArrayView<unsigned char const,-4711l>>((void **)&v106, &v111, &v109);
    v20 = (unsigned __int16)((_WORD)v8 + 3) & 0xFFFC;
    v21 = &v16[-v20];
    if ((unint64_t)v16 <= v20)
      break;
    v22 = &v17[v20];
    if (v21 < v16)
      v16 = v21;
    v17 = v16 ? v22 : 0;
  }
  while (v16);
  v23 = v106;
  if (v106 == v107)
    goto LABEL_36;
  v24 = v106;
  while (*v24 != 32776)
  {
    v24 += 12;
    if (v24 == v107)
      goto LABEL_36;
  }
  v25 = (unsigned __int16 *)*((_QWORD *)v24 + 1);
  v26 = *((_QWORD *)v24 + 2);
  if (!v26)
    v25 = 0;
  if (v26 < 4
    || bswap32(*v25) >> 16 != 32776
    || ((v27 = __rev16(v25[1]), v27 >= 4) ? (v28 = v26 >= v27) : (v28 = 0),
        v28 ? (v29 = v26 - v27 > 3) : (v29 = 1),
        v29))
  {
LABEL_36:
    v30 = 0;
    v31 = 1;
    if (!v23)
      goto LABEL_38;
    goto LABEL_37;
  }
  if (v27 < 5)
  {
    v16 = 0;
    v9 = 0;
  }
  else
  {
    v99 = v27 - 4;
    v100 = v25 + 2;
    v16 = (char *)operator new(v27 - 4);
    v9 = &v16[v99];
    memcpy(v16, v100, v99);
  }
  v31 = 0;
  v30 = 1;
  if (v23)
  {
LABEL_37:
    v107 = v23;
    operator delete(v23);
  }
LABEL_38:
  v104 = a3;
  v105 = a2;
  if (!*(_BYTE *)(a1 + 164))
  {
    v42 = v30 ^ 1;
    if (!*(_BYTE *)(a1 + 165))
      v42 = 1;
    if ((v42 & 1) != 0)
    {
      if ((v31 & 1) != 0)
      {
        v50 = 0;
        v43 = 0;
        v51 = 0;
        goto LABEL_104;
      }
      v43 = 0;
      v50 = 0;
      v44 = v9 - v16;
LABEL_100:
      v58 = (char *)memchr(v16, -126, v44);
      if (v58)
        v59 = v58;
      else
        v59 = v9;
      v51 = (unint64_t)(v59 != v9) << 16;
      goto LABEL_104;
    }
    v43 = 0;
    v44 = v9 - v16;
    goto LABEL_88;
  }
  v32 = *a4;
  v33 = a4[1];
  v107 = 0;
  v108 = 0;
  v106 = 0;
  v34 = (char *)v33 - (char *)v32;
  if (v33 == v32)
  {
    v41 = 0;
LABEL_77:
    v43 = 0;
    goto LABEL_78;
  }
  v35 = (char *)v32;
  do
  {
    if (v34 <= 3)
      goto LABEL_205;
    v111 = 0;
    v111 = bswap32(*(unsigned __int16 *)v35) >> 16;
    v8 = (char *)__rev16(*((unsigned __int16 *)v35 + 1));
    if (v34 >= (unint64_t)v8)
      v36 = (unsigned __int16 *)v8;
    else
      v36 = (unsigned __int16 *)v34;
    if (v36)
      v37 = (uint64_t)v35;
    else
      v37 = 0;
    v109 = v37;
    v110 = v36;
    std::vector<dcsctp::ParameterDescriptor>::emplace_back<unsigned short &,rtc::ArrayView<unsigned char const,-4711l>>((void **)&v106, &v111, &v109);
    v38 = (unsigned __int16)((_WORD)v8 + 3) & 0xFFFC;
    v39 = v34 - v38;
    if (v34 <= v38)
      break;
    v40 = &v35[v38];
    if (v39 < v34)
      v34 = v39;
    v35 = v34 ? v40 : 0;
  }
  while (v34);
  v41 = v106;
  if (v106 == v107)
    goto LABEL_77;
  v45 = v106;
  while ((__int16)*v45 != -16384)
  {
    v45 += 12;
    if (v45 == v107)
      goto LABEL_77;
  }
  v46 = *((_QWORD *)v45 + 2);
  v47 = v46 ? (unsigned __int16 *)*((_QWORD *)v45 + 1) : 0;
  if (v46 < 4 || __rev16(*v47) != 49152)
    goto LABEL_77;
  v48 = __rev16(v47[1]);
  v43 = v46 == 4 && v48 == 4;
LABEL_78:
  if (v41)
  {
    v107 = v41;
    operator delete(v41);
  }
  if ((v31 & 1) == 0)
  {
    v44 = v9 - v16;
    v52 = (char *)memchr(v16, -64, v9 - v16);
    if (v52)
      v53 = v52;
    else
      v53 = v9;
    if (v53 != v9)
      v43 = 1;
    if (!*(_BYTE *)(a1 + 165))
    {
LABEL_96:
      v50 = 0;
      goto LABEL_100;
    }
LABEL_88:
    v54 = (char *)memchr(v16, 64, v44);
    if (v54)
      v55 = v54;
    else
      v55 = v9;
    if (v55 != v9)
    {
      v56 = (char *)memchr(v16, -62, v44);
      if (v56)
        v57 = v56;
      else
        v57 = v9;
      v50 = (unint64_t)(v57 != v9) << 8;
      goto LABEL_100;
    }
    goto LABEL_96;
  }
  v50 = 0;
  v51 = 0;
LABEL_104:
  if (!*(_DWORD *)(a1 + 168))
    goto LABEL_145;
  v60 = *a4;
  v61 = a4[1];
  v107 = 0;
  v108 = 0;
  v106 = 0;
  v62 = (char *)v61 - (char *)v60;
  if (v61 == v60)
  {
    v69 = 0;
LABEL_127:
    v71 = 1;
    if (v69)
    {
LABEL_140:
      v107 = v69;
      operator delete(v69);
    }
  }
  else
  {
    v8 = (char *)v60;
    do
    {
      if (v62 <= 3)
        goto LABEL_205;
      v111 = 0;
      v111 = bswap32(*(unsigned __int16 *)v8) >> 16;
      v63 = __rev16(*((unsigned __int16 *)v8 + 1));
      if (v62 >= v63)
        v64 = v63;
      else
        v64 = v62;
      if (v64)
        v65 = (uint64_t)v8;
      else
        v65 = 0;
      v109 = v65;
      v110 = (unsigned __int16 *)v64;
      std::vector<dcsctp::ParameterDescriptor>::emplace_back<unsigned short &,rtc::ArrayView<unsigned char const,-4711l>>((void **)&v106, &v111, &v109);
      v66 = (unsigned __int16)(v63 + 3) & 0xFFFC;
      v67 = v62 - v66;
      if (v62 <= v66)
        break;
      v68 = &v8[v66];
      if (v67 < v62)
        v62 = v67;
      v8 = v62 ? v68 : 0;
    }
    while (v62);
    v69 = v106;
    if (v106 == v107)
      goto LABEL_127;
    v70 = v106;
    while (*v70 != 32769)
    {
      v70 += 12;
      if (v70 == v107)
        goto LABEL_127;
    }
    v72 = *((_QWORD *)v70 + 1);
    v73 = *((_QWORD *)v70 + 2);
    if (v73)
      v74 = (unsigned __int16 *)*((_QWORD *)v70 + 1);
    else
      v74 = 0;
    if (v73 < 8 || bswap32(*v74) >> 16 != 32769)
    {
      LODWORD(v8) = 0;
      v71 = 0;
LABEL_139:
      if (!v106)
        goto LABEL_141;
      goto LABEL_140;
    }
    LODWORD(v8) = 0;
    if (v73 == 8)
    {
      v71 = 0;
      if (__rev16(v74[1]) == 8)
      {
        v71 = 0;
        LODWORD(v8) = bswap32(*(_DWORD *)(v72 + 4)) != 0;
        if (v106)
          goto LABEL_140;
        goto LABEL_141;
      }
      goto LABEL_139;
    }
    v71 = 0;
    if (v106)
      goto LABEL_140;
  }
LABEL_141:
  if (!(_BYTE)v8 || v71)
  {
LABEL_145:
    v76 = 0;
    v77 = *(unsigned __int16 *)(a1 + 8);
    v78 = *(unsigned __int16 *)(a1 + 10);
    if (v16)
      v79 = v31;
    else
      v79 = 1;
    if ((v79 & 1) != 0)
      goto LABEL_150;
    goto LABEL_149;
  }
  v83 = *a4;
  v84 = a4[1];
  v107 = 0;
  v108 = 0;
  v106 = 0;
  v85 = (char *)v84 - (char *)v83;
  if (v84 != v83)
  {
    v8 = (char *)v83;
    while (v85 > 3)
    {
      v111 = 0;
      v111 = bswap32(*(unsigned __int16 *)v8) >> 16;
      v86 = __rev16(*((unsigned __int16 *)v8 + 1));
      if (v85 >= v86)
        v87 = v86;
      else
        v87 = v85;
      if (v87)
        v88 = (uint64_t)v8;
      else
        v88 = 0;
      v109 = v88;
      v110 = (unsigned __int16 *)v87;
      std::vector<dcsctp::ParameterDescriptor>::emplace_back<unsigned short &,rtc::ArrayView<unsigned char const,-4711l>>((void **)&v106, &v111, &v109);
      v89 = (unsigned __int16)(v86 + 3) & 0xFFFC;
      v90 = v85 - v89;
      if (v85 > v89)
      {
        v91 = &v8[v89];
        if (v90 < v85)
          v85 = v90;
        v8 = v85 ? v91 : 0;
        if (v85)
          continue;
      }
      v92 = v106;
      if (v106 == v107)
        goto LABEL_179;
      v93 = v106;
      while (*v93 != 32769)
      {
        v93 += 12;
        if (v93 == v107)
          goto LABEL_179;
      }
      v95 = *((_QWORD *)v93 + 1);
      v96 = *((_QWORD *)v93 + 2);
      if (v96)
        v97 = (unsigned __int16 *)*((_QWORD *)v93 + 1);
      else
        v97 = 0;
      if (v96 >= 8 && bswap32(*v97) >> 16 == 32769)
      {
        v94 = 0;
        v71 = 1;
        if (v96 == 8 && __rev16(v97[1]) == 8)
        {
          v94 = 0;
          LODWORD(v8) = bswap32(*(_DWORD *)(v95 + 4));
          v71 = (_DWORD)v8 == 0;
        }
      }
      else
      {
        v94 = 0;
        v71 = 1;
      }
      goto LABEL_189;
    }
    goto LABEL_205;
  }
  v92 = 0;
LABEL_179:
  v94 = 1;
LABEL_189:
  if (v92)
  {
    v107 = v92;
    operator delete(v92);
  }
  if (((v71 | v94) & 1) != 0)
  {
    __break(1u);
LABEL_205:
    v101 = rtc::webrtc_checks_impl::FatalLog("Source/webrtc/net/dcsctp/packet/bounded_byte_reader.h", 55, "data.size() >= FixedSize", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v103);
    return dcsctp::DcSctpSocket::HandleForwardTsnCommon((dcsctp::DcSctpSocket *)v101, v102);
  }
  v76 = (unint64_t)((_DWORD)v8 == *(_DWORD *)(a1 + 168)) << 24;
  v77 = *(unsigned __int16 *)(a1 + 8);
  v78 = *(unsigned __int16 *)(a1 + 10);
  if (v16)
    v98 = v31;
  else
    v98 = 1;
  if ((v98 & 1) != 0)
    goto LABEL_150;
LABEL_149:
  operator delete(v16);
LABEL_150:
  if (v78 >= v104)
    v80 = v104;
  else
    v80 = v78;
  if (v77 >= v105)
    v81 = v105;
  else
    v81 = v77;
  return (v51 + v50 + v43 + v76) | (v81 << 32) | (v80 << 48);
}

void dcsctp::DcSctpSocket::HandleForwardTsnCommon(dcsctp::DcSctpSocket *this, const dcsctp::AnyForwardTsnChunk *a2)
{
  uint64_t v3;
  uint64_t v5;
  const void *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  __int128 v15;
  char *v16;
  unint64_t v17;
  __int128 v18;
  char *v19;
  int v20;
  void (*v21)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v22;
  __int128 v23;
  void *v24[2];
  void *v25;
  void (**v26)(dcsctp::AbortChunk *__hidden);
  void *v27[4];
  _QWORD v28[2];
  void *v29;
  void *v30;

  v3 = *((_QWORD *)this + 85);
  if (*(_BYTE *)(v3 + 208))
  {
    if (dcsctp::DataTracker::HandleForwardTsn((void **)(v3 + 408), *((_DWORD *)a2 + 2)))
    {
      v5 = *((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2);
      if (v5)
        v6 = (const void *)*((_QWORD *)a2 + 2);
      else
        v6 = 0;
      dcsctp::ReassemblyQueue::HandleForwardTsn(*((_QWORD *)this + 85) + 520, *((unsigned int *)a2 + 2), v6, 0xAAAAAAAAAAAAAAABLL * (v5 >> 2));
    }
    dcsctp::DcSctpSocket::MaybeDeliverMessages(this);
    return;
  }
  (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)v3 + 88))(v28);
  v24[0] = 0;
  v24[1] = 0;
  v25 = 0;
  v21 = (void (*)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))off_24C0BAE18;
  v7 = (char *)operator new(0x50uLL);
  v22 = v7;
  v23 = xmmword_208F086F0;
  if (v7 <= "I-FORWARD-TSN received, but not indicated during connection establishment"
    && v7 + 73 > "I-FORWARD-TSN received, but not indicated during connection establishment")
  {
    goto LABEL_26;
  }
  strcpy(v7, "I-FORWARD-TSN received, but not indicated during connection establishment");
  dcsctp::ProtocolViolationCause::SerializeTo((uint64_t)&v21, (uint64_t)v24, v8, v9, v10, v11, v12, v13);
  v14 = v25;
  v15 = *(_OWORD *)v24;
  v24[1] = 0;
  v25 = 0;
  v24[0] = 0;
  v26 = &off_24C0ACA10;
  LOBYTE(v27[0]) = 1;
  *(_OWORD *)&v27[1] = v15;
  v27[3] = v14;
  dcsctp::SctpPacket::Builder::Add((uint64_t)v28, (uint64_t)&v26);
  v26 = &off_24C0ACA10;
  if (v27[1])
  {
    v27[2] = v27[1];
    operator delete(v27[1]);
  }
  v21 = (void (*)(unsigned int *, uint64_t, void **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))off_24C0BAE18;
  if (SHIBYTE(v23) < 0)
    operator delete(v22);
  if (v24[0])
  {
    v24[1] = v24[0];
    operator delete(v24[0]);
  }
  dcsctp::PacketSender::Send((_QWORD *)this + 55, (uint64_t)v28, 1);
  v21 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
  LODWORD(v26) = 6;
  v16 = (char *)operator new(0x38uLL);
  v27[0] = v16;
  *(_OWORD *)&v27[1] = xmmword_208F08660;
  if (v16 <= "Received a FORWARD_TSN without announced peer support"
    && v16 + 53 > "Received a FORWARD_TSN without announced peer support")
  {
    goto LABEL_26;
  }
  strcpy(v16, "Received a FORWARD_TSN without announced peer support");
  v17 = *((_QWORD *)this + 42);
  if (v17 >= *((_QWORD *)this + 43))
  {
    v19 = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),dcsctp::CallbackDeferrer::Error>((void **)this + 41, &v21, (uint64_t)&v26);
    v20 = SHIBYTE(v27[2]);
    *((_QWORD *)this + 42) = v19;
    if (v20 < 0)
      operator delete(v27[0]);
    goto LABEL_23;
  }
  if (!v17)
  {
LABEL_26:
    __break(1u);
    return;
  }
  *(_QWORD *)v17 = dcsctp::CallbackDeferrer::OnError(dcsctp::ErrorKind,std::string_view)::$_0::__invoke;
  *(_DWORD *)(v17 + 8) = 6;
  v18 = *(_OWORD *)v27;
  *(void **)(v17 + 32) = v27[2];
  *(_OWORD *)(v17 + 16) = v18;
  *(_QWORD *)(v17 + 56) = 2;
  *((_QWORD *)this + 42) = v17 + 64;
LABEL_23:
  if (v29)
  {
    v30 = v29;
    operator delete(v29);
  }
}

uint64_t dcsctp::DcSctpSocket::GetHandoverReadiness(dcsctp::DcSctpSocket *this)
{
  int v2;
  BOOL v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;

  v2 = *((_DWORD *)this + 168);
  if (v2)
    v3 = v2 == 3;
  else
    v3 = 1;
  v4 = !v3;
  v5 = v4 | (2
           * ((*(uint64_t (**)(char *))(*((_QWORD *)this + 60) + 88))((char *)this + 480) != 0));
  v6 = *((_QWORD *)this + 85);
  if (v6)
  {
    v7 = *(_QWORD *)(v6 + 472);
    v8 = *(_QWORD *)(v6 + 480);
    v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v6 + 1280) + 376) + 40))(*(_QWORD *)(*(_QWORD *)(v6 + 1280) + 376));
    v10 = *(unsigned __int8 *)(v6 + 1360);
    v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v6 + 664) + 40))(*(_QWORD *)(v6 + 664));
    if (*(_BYTE *)(v6 + 1040))
      v12 = ((*(_QWORD *)(v6 + 1144) != 0) << 9) | 0x400;
    else
      v12 = (*(_QWORD *)(v6 + 1144) != 0) << 9;
    if (*(_QWORD *)(v6 + 1208) || *(_QWORD *)(v6 + 1184))
      v12 |= 0x800u;
    if (v9)
      v13 = 16;
    else
      v13 = 0;
    if (v10)
      v13 |= 4u;
    if (*(_BYTE *)(v6 + 648))
      v14 = v11 | 0x40;
    else
      v14 = v11;
    return v13 | (8 * (v7 != v8)) | v14 | v12 | v5;
  }
  return v5;
}

void dcsctp::DcSctpSocket::GetHandoverStateAndClose(dcsctp::DcSctpSocket *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (**v13)(uint64_t, uint64_t);
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[24];
  _OWORD v18[3];
  _BYTE v19[20];
  __int128 v20;
  _OWORD v21[2];
  uint64_t (*v22)(uint64_t, uint64_t);

  *((_BYTE *)this + 320) = 1;
  if ((*(unsigned int (**)(dcsctp::DcSctpSocket *))(*(_QWORD *)this + 160))(this))
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 160) = 0;
LABEL_20:
    dcsctp::CallbackDeferrer::TriggerDeferred((dcsctp::DcSctpSocket *)((char *)this + 304));
    return;
  }
  *(_OWORD *)&v19[4] = 0uLL;
  v20 = 0u;
  memset(v21, 0, sizeof(v21));
  v16 = 0uLL;
  *(_DWORD *)v17 = 0;
  *(_OWORD *)&v17[8] = 0u;
  memset(v18, 0, sizeof(v18));
  v19[0] = 0;
  if (*((_DWORD *)this + 168) != 3)
    goto LABEL_19;
  LODWORD(v16) = 1;
  v4 = *((_QWORD *)this + 85);
  v5 = *(_DWORD *)(v4 + 212);
  *(_DWORD *)&v17[16] = *(_DWORD *)(v4 + 208);
  *(_DWORD *)&v17[20] = v5;
  v6 = *(_DWORD *)(v4 + 248);
  DWORD1(v16) = *(_DWORD *)(v4 + 240);
  HIDWORD(v16) = v6;
  DWORD2(v16) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  *(_DWORD *)v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 32))(v4);
  *(_QWORD *)&v17[8] = *(_QWORD *)(v4 + 256);
  v7 = *(_QWORD *)(v4 + 464);
  v19[0] = *(_BYTE *)(v4 + 424);
  v8 = *(_QWORD *)(v4 + 1368);
  *(_DWORD *)&v19[4] = v7;
  *(_DWORD *)&v19[16] = v8;
  DWORD1(v18[0]) = *(_DWORD *)(v4 + 1312);
  (*(void (**)(_QWORD, __int128 *))(**(_QWORD **)(v4 + 664) + 48))(*(_QWORD *)(v4 + 664), &v16);
  LODWORD(v18[0]) = *(_DWORD *)(v4 + 1144) + *(_DWORD *)(v4 + 1064) + 1;
  *(int32x4_t *)((char *)v18 + 8) = vuzp1q_s32(*(int32x4_t *)(v4 + 984), *(int32x4_t *)(v4 + 1000));
  dcsctp::RRSendQueue::AddHandoverState((uint64_t)this + 480, &v16);
  if (!*((_DWORD *)this + 168))
    goto LABEL_19;
  v9 = *((_QWORD *)this + 52);
  if (*(_BYTE *)(v9 + 156))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v9 + 136) + 24))(*(_QWORD *)(v9 + 136));
    *(_DWORD *)(v9 + 160) = 0;
    *(_BYTE *)(v9 + 156) = 0;
  }
  v10 = *((_QWORD *)this + 53);
  if (*(_BYTE *)(v10 + 156))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v10 + 136) + 24))(*(_QWORD *)(v10 + 136));
    *(_DWORD *)(v10 + 160) = 0;
    *(_BYTE *)(v10 + 156) = 0;
  }
  v11 = *((_QWORD *)this + 54);
  if (*(_BYTE *)(v11 + 156))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v11 + 136) + 24))(*(_QWORD *)(v11 + 136));
    *(_DWORD *)(v11 + 160) = 0;
    *(_BYTE *)(v11 + 156) = 0;
  }
  v12 = *((_QWORD *)this + 85);
  *((_QWORD *)this + 85) = 0;
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  v22 = dcsctp::CallbackDeferrer::OnClosed(void)::$_0::__invoke;
  v13 = (uint64_t (**)(uint64_t, uint64_t))*((_QWORD *)this + 42);
  if ((unint64_t)v13 >= *((_QWORD *)this + 43))
  {
    *((_QWORD *)this + 42) = std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__emplace_back_slow_path<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::monostate>((void **)this + 41, &v22);
    if (*((_DWORD *)this + 168))
LABEL_18:
      *((_DWORD *)this + 168) = 0;
LABEL_19:
    v14 = *(_OWORD *)v17;
    *(_OWORD *)a2 = v16;
    *(_OWORD *)(a2 + 16) = v14;
    *(_QWORD *)(a2 + 32) = *(_QWORD *)&v17[16];
    *(_OWORD *)(a2 + 40) = v18[0];
    *(_QWORD *)(a2 + 56) = *(_QWORD *)&v18[1];
    *(_OWORD *)(a2 + 64) = *(_OWORD *)((char *)&v18[1] + 8);
    *(_QWORD *)(a2 + 80) = *((_QWORD *)&v18[2] + 1);
    memset((char *)&v18[1] + 8, 0, 24);
    v15 = *(_OWORD *)v19;
    *(_DWORD *)(a2 + 104) = *(_DWORD *)&v19[16];
    *(_OWORD *)(a2 + 88) = v15;
    *(_OWORD *)(a2 + 112) = v20;
    *(_QWORD *)(a2 + 128) = *(_QWORD *)&v21[0];
    *(_QWORD *)&v21[0] = 0;
    v20 = 0uLL;
    *(_OWORD *)(a2 + 136) = *(_OWORD *)((char *)v21 + 8);
    *(_QWORD *)(a2 + 152) = *((_QWORD *)&v21[1] + 1);
    *(_BYTE *)(a2 + 160) = 1;
    goto LABEL_20;
  }
  if (v13)
  {
    *v13 = dcsctp::CallbackDeferrer::OnClosed(void)::$_0::__invoke;
    v13[7] = 0;
    *((_QWORD *)this + 42) = v13 + 8;
    if (!*((_DWORD *)this + 168))
      goto LABEL_19;
    goto LABEL_18;
  }
  __break(1u);
}

void dcsctp::DcSctpSocket::~DcSctpSocket(dcsctp::DcSctpSocket *this)
{
  dcsctp::DcSctpSocket::~DcSctpSocket(this);
  JUMPOUT(0x20BD0ADECLL);
}

{
  uint64_t v2;
  dcsctp::DcSctpSocket *v3;
  uint64_t v4;
  void *v5;
  dcsctp::DcSctpSocket *v6;
  uint64_t v7;
  dcsctp::Timer *v8;
  dcsctp::Timer *v9;
  dcsctp::Timer *v10;
  dcsctp::DcSctpSocket *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  *(_QWORD *)this = &off_24C0B2768;
  v2 = *((_QWORD *)this + 85);
  *((_QWORD *)this + 85) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 60) = &off_24C0BB958;
  std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>>>::destroy((uint64_t)this + 640, *((_QWORD **)this + 81));
  v3 = (dcsctp::DcSctpSocket *)*((_QWORD *)this + 77);
  if (v3 == (dcsctp::DcSctpSocket *)((char *)this + 592))
  {
    v4 = 4;
    v3 = (dcsctp::DcSctpSocket *)((char *)this + 592);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_8:
  v5 = (void *)*((_QWORD *)this + 71);
  if (v5)
  {
    *((_QWORD *)this + 72) = v5;
    operator delete(v5);
  }
  v6 = (dcsctp::DcSctpSocket *)*((_QWORD *)this + 59);
  if (v6 == (dcsctp::DcSctpSocket *)((char *)this + 448))
  {
    v7 = 4;
    v6 = (dcsctp::DcSctpSocket *)((char *)this + 448);
  }
  else
  {
    if (!v6)
      goto LABEL_15;
    v7 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v6 + 8 * v7))();
LABEL_15:
  v8 = (dcsctp::Timer *)*((_QWORD *)this + 54);
  *((_QWORD *)this + 54) = 0;
  if (v8)
  {
    dcsctp::Timer::~Timer(v8);
    MEMORY[0x20BD0ADEC]();
  }
  v9 = (dcsctp::Timer *)*((_QWORD *)this + 53);
  *((_QWORD *)this + 53) = 0;
  if (v9)
  {
    dcsctp::Timer::~Timer(v9);
    MEMORY[0x20BD0ADEC]();
  }
  v10 = (dcsctp::Timer *)*((_QWORD *)this + 52);
  *((_QWORD *)this + 52) = 0;
  if (v10)
  {
    dcsctp::Timer::~Timer(v10);
    MEMORY[0x20BD0ADEC]();
  }
  std::__tree<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::__map_value_compare<webrtc::AudioSendStream *,std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::less<webrtc::AudioSendStream *>,true>,std::allocator<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>>>::destroy(*((_QWORD **)this + 49));
  v11 = (dcsctp::DcSctpSocket *)*((_QWORD *)this + 47);
  if (v11 == (dcsctp::DcSctpSocket *)((char *)this + 352))
  {
    v12 = 4;
    v11 = (dcsctp::DcSctpSocket *)((char *)this + 352);
  }
  else
  {
    if (!v11)
      goto LABEL_26;
    v12 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v11 + 8 * v12))();
LABEL_26:
  *((_QWORD *)this + 38) = &off_24C0B07D0;
  v13 = *((_QWORD *)this + 41);
  if (v13)
  {
    std::vector<std::pair<void (*)(absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,dcsctp::DcSctpSocketCallbacks &),absl::variant<absl::monostate,dcsctp::DcSctpMessage,dcsctp::CallbackDeferrer::Error,dcsctp::CallbackDeferrer::StreamReset,webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>>>::__base_destruct_at_end[abi:sn180100]((uint64_t)this + 328, v13);
    operator delete(*((void **)this + 41));
  }
  v14 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

uint64_t dcsctp::DcSctpSocket::options(dcsctp::DcSctpSocket *this)
{
  return (uint64_t)this + 128;
}

uint64_t dcsctp::DcSctpSocket::peer_implementation(dcsctp::DcSctpSocket *this)
{
  return *((unsigned int *)this + 29);
}

void std::__function::__func<dcsctp::DcSctpSocket::CreateTransmissionControlBlock(dcsctp::Capabilities const&,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>)::$_0,std::allocator<dcsctp::DcSctpSocket::CreateTransmissionControlBlock(dcsctp::Capabilities const&,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>)::$_0>,BOOL ()(void)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<dcsctp::DcSctpSocket::CreateTransmissionControlBlock(dcsctp::Capabilities const&,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>)::$_0,std::allocator<dcsctp::DcSctpSocket::CreateTransmissionControlBlock(dcsctp::Capabilities const&,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>)::$_0>,BOOL ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C0B2830;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<dcsctp::DcSctpSocket::CreateTransmissionControlBlock(dcsctp::Capabilities const&,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>)::$_0,std::allocator<dcsctp::DcSctpSocket::CreateTransmissionControlBlock(dcsctp::Capabilities const&,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>)::$_0>,BOOL ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C0B2830;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<dcsctp::DcSctpSocket::CreateTransmissionControlBlock(dcsctp::Capabilities const&,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>)::$_0,std::allocator<dcsctp::DcSctpSocket::CreateTransmissionControlBlock(dcsctp::Capabilities const&,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,webrtc::StrongAlias<dcsctp::VerificationTagTag,unsigned int>,webrtc::StrongAlias<dcsctp::TSNTag,unsigned int>,unsigned long,webrtc::StrongAlias<dcsctp::TieTagTag,unsigned long long>)::$_0>,BOOL ()(void)>::operator()(uint64_t a1)
{
  return *(_DWORD *)(*(_QWORD *)(a1 + 8) + 672) == 3;
}

void std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>>>::destroy(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  if (!a2)
    return;
  std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>>>::destroy(a1, *a2);
  std::__tree<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>,std::__map_value_compare<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>,std::less<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>>,true>,std::allocator<std::__value_type<webrtc::StrongAlias<dcsctp::StreamIDTag,unsigned short>,dcsctp::RRSendQueue::OutgoingStream>>>::destroy(a1, a2[1]);
  a2[5] = &off_24C0BB9E0;
  v4 = (_QWORD *)a2[19];
  if (v4 == a2 + 16)
  {
    v5 = 4;
    v4 = a2 + 16;
    goto LABEL_7;
  }
  if (v4)
  {
    v5 = 5;
LABEL_7:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  std::deque<dcsctp::RRSendQueue::OutgoingStream::Item>::~deque[abi:sn180100]((uint64_t)(a2 + 10));
  v6 = a2[7];
  a2[7] = 0;
  if (v6)
    MEMORY[0x20BD0ADEC](v6, 0x1020C401CCFFAA1);
  operator delete(a2);
}

void std::deque<dcsctp::RRSendQueue::OutgoingStream::Item>::~deque[abi:sn180100](uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  void **v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  void *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    v3 = *(void ***)(a1 + 8);
    *(_QWORD *)(a1 + 40) = 0;
    v11 = 0;
    goto LABEL_13;
  }
  v4 = *(_QWORD *)(a1 + 32);
  v5 = &v2[v4 / 0x2A];
  v6 = (unint64_t)*v5;
  v7 = (unint64_t)*v5 + 96 * (v4 % 0x2A);
  v8 = (unint64_t)v2[(*(_QWORD *)(a1 + 40) + v4) / 0x2A] + 96 * ((*(_QWORD *)(a1 + 40) + v4) % 0x2A);
  if (v7 == v8)
  {
LABEL_11:
    *(_QWORD *)(a1 + 40) = 0;
    v11 = (char *)v3 - (char *)v2;
    if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
    {
      do
      {
        operator delete(*v2);
        v3 = *(void ***)(a1 + 16);
        v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
        *(_QWORD *)(a1 + 8) = v2;
        v11 = (char *)v3 - (char *)v2;
      }
      while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
    }
LABEL_13:
    v12 = v11 >> 3;
    if (v12 == 1)
    {
      v13 = 21;
    }
    else
    {
      if (v12 != 2)
      {
LABEL_19:
        if (v2 != v3)
        {
          do
          {
            v14 = *v2++;
            operator delete(v14);
          }
          while (v2 != v3);
          v16 = *(_QWORD *)(a1 + 8);
          v15 = *(_QWORD *)(a1 + 16);
          if (v15 != v16)
            *(_QWORD *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
        }
        if (*(_QWORD *)a1)
          operator delete(*(void **)a1);
        return;
      }
      v13 = 42;
    }
    *(_QWORD *)(a1 + 32) = v13;
    goto LABEL_19;
  }
  while (v7)
  {
    v9 = *(void **)(v7 + 16);
    if (v9)
    {
      *(_QWORD *)(v7 + 24) = v9;
      operator delete(v9);
      v6 = (unint64_t)*v5;
    }
    v7 += 96;
    if (v7 - v6 == 4032)
    {
      v10 = (unint64_t)v5[1];
      ++v5;
      v6 = v10;
      v7 = v10;
    }
    if (v7 == v8)
    {
      v2 = *(void ***)(a1 + 8);
      v3 = *(void ***)(a1 + 16);
      goto LABEL_11;
    }
  }
  __break(1u);
}

void std::__function::__func<dcsctp::DcSctpSocket::DcSctpSocket(std::string_view,dcsctp::DcSctpSocketCallbacks &,std::unique_ptr<dcsctp::PacketObserver>,dcsctp::DcSctpOptions const&)::$_0,std::allocator<dcsctp::DcSctpSocket::DcSctpSocket(std::string_view,dcsctp::DcSctpSocketCallbacks &,std::unique_ptr<dcsctp::PacketObserver>,dcsctp::DcSctpOptions const&)::$_0>,std::unique_ptr<dcsctp::Timeout> ()(webrtc::TaskQueueBase::DelayPrecision)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<dcsctp::DcSctpSocket::DcSctpSocket(std::string_view,dcsctp::DcSctpSocketCallbacks &,std::unique_ptr<dcsctp::PacketObserver>,dcsctp::DcSctpOptions const&)::$_0,std::allocator<dcsctp::DcSctpSocket::DcSctpSocket(std::string_view,dcsctp::DcSctpSocketCallbacks &,std::unique_ptr<dcsctp::PacketObserver>,dcsctp::DcSctpOptions const&)::$_0>,std::unique_ptr<dcsctp::Timeout> ()(webrtc::TaskQueueBase::DelayPrecision)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C0B2878;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<dcsctp::DcSctpSocket::DcSctpSocket(std::string_view,dcsctp::DcSctpSocketCallbacks &,std::unique_ptr<dcsctp::PacketObserver>,dcsctp::DcSctpOptions const&)::$_0,std::allocator<dcsctp::DcSctpSocket::DcSctpSocket(std::string_view,dcsctp::DcSctpSocketCallbacks &,std::unique_ptr<dcsctp::PacketObserver>,dcsctp::DcSctpOptions const&)::$_0>,std::unique_ptr<dcsctp::Timeout> ()(webrtc::TaskQueueBase::DelayPrecision)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C0B2878;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<dcsctp::DcSctpSocket::DcSctpSocket(std::string_view,dcsctp::DcSctpSocketCallbacks &,std::unique_ptr<dcsctp::PacketObserver>,dcsctp::DcSctpOptions const&)::$_0,std::allocator<dcsctp::DcSctpSocket::DcSctpSocket(std::string_view,dcsctp::DcSctpSocketCallbacks &,std::unique_ptr<dcsctp::PacketObserver>,dcsctp::DcSctpOptions const&)::$_0>,std::unique_ptr<dcsctp::Timeout> ()(webrtc::TaskQueueBase::DelayPrecision)>::operator()(uint64_t a1, unsigned int *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 312) + 32))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 312), *a2);
}

void std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::DcSctpSocket::*)(void),dcsctp::DcSctpSocket*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::DcSctpSocket::*)(void),dcsctp::DcSctpSocket*>>,webrtc::TimeDelta ()(void)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

__n128 std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::DcSctpSocket::*)(void),dcsctp::DcSctpSocket*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::DcSctpSocket::*)(void),dcsctp::DcSctpSocket*>>,webrtc::TimeDelta ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24C0B28C0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::DcSctpSocket::*)(void),dcsctp::DcSctpSocket*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::DcSctpSocket::*)(void),dcsctp::DcSctpSocket*>>,webrtc::TimeDelta ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24C0B28C0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind_front_t<webrtc::TimeDelta (dcsctp::DcSctpSocket::*)(void),dcsctp::DcSctpSocket*>,std::allocator<std::__bind_front_t<webrtc::TimeDelta (dcsctp::DcSctpSocket::*)(void),dcsctp::DcSctpSocket*>>,webrtc::TimeDelta ()(void)>::operator()(_QWORD *a1)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD *);
  _QWORD *v3;

  v1 = a1[2];
  v2 = (uint64_t (*)(_QWORD *))a1[1];
  v3 = (_QWORD *)(a1[3] + (v1 >> 1));
  if ((v1 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *))(*v3 + v2);
  return v2(v3);
}

void std::__function::__func<std::__bind_front_t<void (dcsctp::DcSctpSocket::*)(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus),dcsctp::DcSctpSocket*>,std::allocator<std::__bind_front_t<void (dcsctp::DcSctpSocket::*)(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus),dcsctp::DcSctpSocket*>>,void ()(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

__n128 std::__function::__func<std::__bind_front_t<void (dcsctp::DcSctpSocket::*)(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus),dcsctp::DcSctpSocket*>,std::allocator<std::__bind_front_t<void (dcsctp::DcSctpSocket::*)(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus),dcsctp::DcSctpSocket*>>,void ()(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24C0B2908;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind_front_t<void (dcsctp::DcSctpSocket::*)(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus),dcsctp::DcSctpSocket*>,std::allocator<std::__bind_front_t<void (dcsctp::DcSctpSocket::*)(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus),dcsctp::DcSctpSocket*>>,void ()(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24C0B2908;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind_front_t<void (dcsctp::DcSctpSocket::*)(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus),dcsctp::DcSctpSocket*>,std::allocator<std::__bind_front_t<void (dcsctp::DcSctpSocket::*)(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus),dcsctp::DcSctpSocket*>>,void ()(rtc::ArrayView<unsigned char const,-4711l>,dcsctp::SendPacketStatus)>::operator()(_QWORD *a1, _QWORD *a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t (*v4)(_QWORD *, _QWORD, _QWORD, _QWORD);
  _QWORD *v5;

  v3 = a1[2];
  v4 = (uint64_t (*)(_QWORD *, _QWORD, _QWORD, _QWORD))a1[1];
  v5 = (_QWORD *)(a1[3] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v4 = *(uint64_t (**)(_QWORD *, _QWORD, _QWORD, _QWORD))(*v5 + v4);
  return v4(v5, *a2, a2[1], *a3);
}

void dcsctp::DcSctpSocketFactory::~DcSctpSocketFactory(dcsctp::DcSctpSocketFactory *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t dcsctp::DcSctpSocketFactory::Create@<X0>(std::string *a1@<X1>, size_t a2@<X2>, uint64_t a3@<X3>, uint64_t *a4@<X4>, __int128 *a5@<X5>, uint64_t *a6@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;

  v12 = operator new();
  v13 = *a4;
  *a4 = 0;
  v15 = v13;
  dcsctp::DcSctpSocket::DcSctpSocket(v12, a1, a2, a3, &v15, a5);
  result = v15;
  if (v15)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  *a6 = v12;
  return result;
}

uint64_t webrtc::DcSctpTransport::DcSctpTransport(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  __int128 v11;
  uint64_t v12;
  void **v13;
  int v14;
  std::string::size_type v15;
  char v16;
  uint64_t v17;
  std::string __p;
  _QWORD v20[2];
  _QWORD v21[4];
  _QWORD v22[5];

  v22[4] = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a1 + 32) = sigslot::has_slots<sigslot::single_threaded>::do_signal_disconnect;
  *(_QWORD *)(a1 + 40) = sigslot::has_slots<sigslot::single_threaded>::do_disconnect_all;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 48) = a1 + 56;
  *(_QWORD *)a1 = &off_24C0B2978;
  *(_QWORD *)(a1 + 8) = &unk_24C0B2A88;
  *(_QWORD *)(a1 + 16) = &unk_24C0B2B60;
  *(_QWORD *)(a1 + 24) = sigslot::has_slots<sigslot::single_threaded>::do_signal_connect;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = a3;
  *(_QWORD *)(a1 + 80) = a4;
  v8 = *a2;
  *(_QWORD *)(a1 + 88) = *a2;
  if (v8)
  {
    v9 = (unsigned int *)(v8 + 8);
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  v11 = *(_OWORD *)(a2 + 3);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 1);
  *(_OWORD *)(a1 + 112) = v11;
  *(_QWORD *)(a1 + 128) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 104) + 16))(*(_QWORD *)(a1 + 104));
  v12 = *a5;
  *a5 = 0;
  v22[0] = &off_24C0B2B80;
  v22[1] = a1;
  v22[3] = v22;
  v21[3] = v21;
  v21[0] = &off_24C0B2BC8;
  v21[1] = a1;
  *(_QWORD *)(a1 + 136) = v12;
  *(_QWORD *)(a1 + 144) = a3;
  *(_QWORD *)(a1 + 152) = &off_24C0B2B80;
  *(_QWORD *)(a1 + 176) = a1 + 152;
  *(_QWORD *)(a1 + 160) = a1;
  *(_QWORD *)(a1 + 184) = &off_24C0B2BC8;
  *(_QWORD *)(a1 + 192) = a1;
  v13 = (void **)(a1 + 224);
  *(_QWORD *)(a1 + 208) = a1 + 184;
  *(_QWORD *)(a1 + 216) = 0;
  *(_BYTE *)(a1 + 247) = 15;
  if (a1 + 224 <= (unint64_t)"DcSctpTransport" && a1 + 239 > (unint64_t)"DcSctpTransport")
    goto LABEL_15;
  strcpy((char *)(a1 + 224), "DcSctpTransport");
  *(_OWORD *)(a1 + 248) = 0u;
  *(_QWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_BYTE *)(a1 + 296) = 0;
  memset(&__p, 0, sizeof(__p));
  if (&__p <= (std::string *)v13 && (char *)&__p.__r_.__value_.__r.__words[1] + 7 > (char *)v13)
LABEL_15:
    __break(1u);
  strcpy((char *)&__p, "DcSctpTransport");
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = 15;
  do
    v14 = __ldaxr(&webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::instance_count);
  while (__stlxr(v14 + 1, &webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::instance_count));
  rtc::StringBuilder::operator<<(&__p, v14);
  v20[0] = __p.__r_.__value_.__l.__size_;
  v15 = __p.__r_.__value_.__r.__words[0];
  *(_QWORD *)((char *)v20 + 7) = *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7);
  v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  memset(&__p, 0, sizeof(__p));
  if (*(char *)(a1 + 247) < 0)
    operator delete(*v13);
  v17 = v20[0];
  *(_QWORD *)(a1 + 224) = v15;
  *(_QWORD *)(a1 + 232) = v17;
  *(_QWORD *)(a1 + 239) = *(_QWORD *)((char *)v20 + 7);
  *(_BYTE *)(a1 + 247) = v16;
  webrtc::DcSctpTransport::ConnectTransportSignals(a1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return a1;
}

uint64_t webrtc::DcSctpTransport::ConnectTransportSignals(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  char *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15[3];

  v1 = *(_QWORD *)(this + 80);
  if (v1)
  {
    v2 = this;
    v3 = this + 16;
    v4 = operator new(0x30uLL);
    v4[2] = sigslot::_opaque_connection::emitter<webrtc::DcSctpTransport,rtc::PacketTransportInternal *>;
    v4[3] = v3;
    v4[4] = webrtc::DcSctpTransport::OnTransportWritableState;
    v4[5] = 0;
    v6 = *(_QWORD *)(v1 + 72);
    v5 = (_QWORD *)(v1 + 72);
    *v4 = v6;
    v4[1] = v5;
    *(_QWORD *)(v6 + 8) = v4;
    *v5 = v4;
    ++v5[2];
    (*(void (**)(uint64_t, _QWORD *))(v2 + 24))(v3, v5 - 2);
    v7 = (char *)(*(_QWORD *)(v2 + 80) + 344);
    v8 = (_QWORD *)operator new();
    *v8 = v2;
    v8[2] = absl::internal_any_invocable::LocalManagerTrivial;
    v8[3] = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DcSctpTransport::ConnectTransportSignals(void)::$_1 &,rtc::PacketTransportInternal *,rtc::ReceivedPacket const&>;
    v15[0] = (uint64_t)v8;
    v15[1] = (uint64_t)webrtc::webrtc_function_impl::CallHelpers<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)>::CallVoidPtr<absl::AnyInvocable<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)>>;
    v15[2] = (uint64_t)webrtc::UntypedFunction::PrepareArgs<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&),absl::AnyInvocable<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)>,absl::AnyInvocable<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)>,(void *)0>(absl::AnyInvocable<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)> &&)::{lambda(webrtc::webrtc_function_impl::VoidUnion *)#1}::__invoke;
    webrtc::callback_list_impl::CallbackListReceivers::AddReceiver<webrtc::UntypedFunction::NontrivialUntypedFunctionArgs>(v7, v2, v15, v9, v10, v11, v12, v13);
    v14 = *(_QWORD *)(v2 + 80);
    this = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v14 + 392))(1, v14 + 376, v14 + 376);
    *(_QWORD *)(v14 + 376) = v2;
    *(_QWORD *)(v14 + 392) = absl::internal_any_invocable::LocalManagerTrivial;
    *(_QWORD *)(v14 + 400) = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DcSctpTransport::ConnectTransportSignals(void)::$_2 &&>;
  }
  return this;
}

void webrtc::DcSctpTransport::~DcSctpTransport(webrtc::DcSctpTransport *this)
{
  char *v2;
  uint64_t v3;
  webrtc::DcSctpTransport *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  webrtc::DcSctpTransport *v13;
  uint64_t v14;
  webrtc::DcSctpTransport *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;

  *(_QWORD *)this = &off_24C0B2978;
  *((_QWORD *)this + 1) = &unk_24C0B2A88;
  *((_QWORD *)this + 2) = &unk_24C0B2B60;
  v2 = (char *)this + 16;
  v3 = *((_QWORD *)this + 27);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
  v4 = (webrtc::DcSctpTransport *)*((_QWORD *)this + 41);
  if (v4 == (webrtc::DcSctpTransport *)((char *)this + 304))
  {
    v5 = 4;
    v4 = (webrtc::DcSctpTransport *)((char *)this + 304);
  }
  else
  {
    if (!v4)
      goto LABEL_8;
    v5 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v4 + 8 * v5))();
LABEL_8:
  v6 = (void *)*((_QWORD *)this + 34);
  if (v6)
  {
    *((_QWORD *)this + 35) = v6;
    operator delete(v6);
  }
  v7 = *((_QWORD *)this + 31);
  if (v7)
  {
    v8 = (unsigned int *)(v7 + 24);
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
    {
      v11 = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(v7 + 16) = 0;
      if (v11)
        MEMORY[0x20BD0ADD4](v11, 0x1000C8077774924);
      MEMORY[0x20BD0ADEC](v7, 0x1010C40EE34DA14);
    }
  }
  if ((*((char *)this + 247) & 0x80000000) == 0)
  {
    v12 = *((_QWORD *)this + 27);
    *((_QWORD *)this + 27) = 0;
    if (!v12)
      goto LABEL_20;
    goto LABEL_19;
  }
  operator delete(*((void **)this + 28));
  v12 = *((_QWORD *)this + 27);
  *((_QWORD *)this + 27) = 0;
  if (v12)
LABEL_19:
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
LABEL_20:
  v13 = (webrtc::DcSctpTransport *)*((_QWORD *)this + 26);
  if (v13 == (webrtc::DcSctpTransport *)((char *)this + 184))
  {
    v14 = 4;
    v13 = (webrtc::DcSctpTransport *)((char *)this + 184);
  }
  else
  {
    if (!v13)
      goto LABEL_27;
    v14 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v13 + 8 * v14))();
LABEL_27:
  v15 = (webrtc::DcSctpTransport *)*((_QWORD *)this + 22);
  if (v15 == (webrtc::DcSctpTransport *)((char *)this + 152))
  {
    v16 = 4;
    v15 = (webrtc::DcSctpTransport *)((char *)this + 152);
  }
  else
  {
    if (!v15)
      goto LABEL_32;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_32:
  v17 = *((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  v18 = (unsigned int *)*((_QWORD *)this + 11);
  if (v18)
  {
    v19 = v18 + 2;
    do
    {
      v20 = __ldaxr(v19);
      v21 = v20 - 1;
    }
    while (__stlxr(v21, v19));
    if (!v21)
      (*(void (**)(unsigned int *))(*(_QWORD *)v18 + 8))(v18);
  }
  *((_QWORD *)this + 2) = &unk_24C0ACE30;
  (*((void (**)(char *))this + 5))(v2);
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 48, *((_QWORD **)this + 7));
}

{
  webrtc::DcSctpTransport::~DcSctpTransport(this);
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'webrtc::DcSctpTransport::~DcSctpTransport(webrtc::DcSctpTransport *this)
{
  webrtc::DcSctpTransport::~DcSctpTransport((webrtc::DcSctpTransport *)((char *)this - 8));
}

{
  webrtc::DcSctpTransport::~DcSctpTransport((webrtc::DcSctpTransport *)((char *)this - 16));
}

{
  webrtc::DcSctpTransport::~DcSctpTransport((webrtc::DcSctpTransport *)((char *)this - 8));
  JUMPOUT(0x20BD0ADECLL);
}

{
  webrtc::DcSctpTransport::~DcSctpTransport((webrtc::DcSctpTransport *)((char *)this - 16));
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *webrtc::DcSctpTransport::SetOnConnectedCallback(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *result;
  uint64_t v6;
  uint64_t v7;

  v4 = (_QWORD *)(a1 + 304);
  result = *(_QWORD **)(a1 + 328);
  *(_QWORD *)(a1 + 328) = 0;
  if (result == v4)
  {
    v6 = 4;
    result = v4;
  }
  else
  {
    if (!result)
      goto LABEL_6;
    v6 = 5;
  }
  result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v6))();
LABEL_6:
  v7 = *(_QWORD *)(a2 + 24);
  if (v7)
  {
    if (v7 == a2)
    {
      *(_QWORD *)(a1 + 328) = v4;
      return (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), v4);
    }
    else
    {
      *(_QWORD *)(a1 + 328) = v7;
      *(_QWORD *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 328) = 0;
  }
  return result;
}

uint64_t webrtc::DcSctpTransport::SetDataChannelSink(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 336) = a2;
  if (a2)
  {
    if (*(_BYTE *)(result + 296))
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  }
  return result;
}

uint64_t webrtc::DcSctpTransport::SetDtlsTransport(webrtc::DcSctpTransport *this, rtc::PacketTransportInternal *a2)
{
  _QWORD *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t result;

  v4 = (_QWORD *)*((_QWORD *)this + 10);
  if (v4)
  {
    v5 = (uint64_t *)v4[10];
    if (v5 != v4 + 9)
    {
      while ((webrtc::DcSctpTransport *)v5[3] != (webrtc::DcSctpTransport *)((char *)this + 16))
      {
        v5 = (uint64_t *)v5[1];
        if (v5 == v4 + 9)
          goto LABEL_9;
      }
      v6 = *v5;
      v7 = v5[1];
      *(_QWORD *)(v6 + 8) = v7;
      *(_QWORD *)v5[1] = v6;
      v8 = (uint64_t *)v4[12];
      --v4[11];
      operator delete(v5);
      if (v8 == v5)
        v4[12] = v7;
      (*((void (**)(char *, _QWORD *))this + 4))((char *)this + 16, v4 + 7);
      v4 = (_QWORD *)*((_QWORD *)this + 10);
    }
LABEL_9:
    webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(v4 + 43), this);
    v9 = *((_QWORD *)this + 10);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 392))(1, v9 + 376, v9 + 376);
    *(_QWORD *)(v9 + 392) = absl::internal_any_invocable::EmptyManager;
    *(_QWORD *)(v9 + 400) = 0;
  }
  *((_QWORD *)this + 10) = a2;
  webrtc::DcSctpTransport::ConnectTransportSignals((uint64_t)this);
  result = *((_QWORD *)this + 10);
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    if ((_DWORD)result)
    {
      result = *((_QWORD *)this + 27);
      if (result)
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 64))(result);
        if (!(_DWORD)result)
          return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 27) + 32))(*((_QWORD *)this + 27));
      }
    }
  }
  return result;
}

uint64_t webrtc::DcSctpTransport::Start(webrtc::DcSctpTransport *this, int a2, int a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v16;
  uint64_t v17;
  uint64_t *v18;
  char *v19;
  _QWORD *v20;
  int v21;
  size_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  __int16 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  char v45;
  uint64_t v46;
  int v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  int v52;
  char v53;
  int v54;
  int v55;

  v7 = *((_QWORD *)this + 27);
  if (!v7)
  {
    v37 = -1;
    v40 = 256;
    v43 = xmmword_208F08830;
    v46 = 0xC800007530;
    v47 = 220;
    v48 = xmmword_208F08840;
    v49 = 6;
    v52 = 8;
    v50 = 0xA00000004;
    v54 = 65537;
    v55 = 0;
    v35 = a2;
    v36 = a3;
    v38 = 1191;
    v39 = a4;
    v45 = 1;
    v44 = xmmword_208F08850;
    v51 = 0;
    v53 = 0;
    v42 = xmmword_208F08860;
    v41 = xmmword_208F08870;
    {
      v16 = 0;
      v17 = *((_QWORD *)this + 17);
      v18 = (uint64_t *)((char *)this + 224);
      if ((*((_BYTE *)this + 247) & 0x80) == 0)
      {
LABEL_30:
        (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v17 + 16))(&v34);
        v29 = v34;
        v34 = 0;
        v30 = *((_QWORD *)this + 27);
        *((_QWORD *)this + 27) = v29;
        if (v30)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
          v31 = v34;
          v34 = 0;
          if (v31)
            (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
        }
        if (v16)
          (*(void (**)(_QWORD *))(*v16 + 8))(v16);
        goto LABEL_35;
      }
      goto LABEL_27;
    }
    v19 = (char *)this + 224;
    v20 = (_QWORD *)operator new();
    v16 = v20;
    v21 = *((char *)this + 247);
    if (v21 < 0)
    {
      v22 = *((_QWORD *)this + 29);
      if ((v22 & 0x8000000000000000) != 0)
        goto LABEL_41;
      v19 = *(char **)v19;
      if (v22)
      {
        if (!v19)
          goto LABEL_41;
      }
      *v20 = off_24C0C24B0;
      if (v22 >= 0x7FFFFFFFFFFFFFF8)
        goto LABEL_42;
    }
    else
    {
      v22 = *((unsigned __int8 *)this + 247);
      *v20 = off_24C0C24B0;
    }
    if (v22 > 0x16)
    {
      v25 = (v22 & 0x7FFFFFFFFFFFFFF8) + 8;
      if ((v22 | 7) != 0x17)
        v25 = v22 | 7;
      v26 = v25 + 1;
      v23 = (char *)operator new(v25 + 1);
      v16[2] = v22;
      v16[3] = v26 | 0x8000000000000000;
      v16[1] = v23;
      v24 = &v23[v22];
      if (v23 > v19)
      {
LABEL_24:
        if (v22)
          memmove(v23, v19, v22);
        *v24 = 0;
        v17 = *((_QWORD *)this + 17);
        v18 = (uint64_t *)((char *)this + 224);
        if ((v21 & 0x80) == 0)
          goto LABEL_30;
LABEL_27:
        v27 = *((_QWORD *)this + 29);
        if ((v27 & 0x8000000000000000) == 0)
        {
          v28 = *v18;
          if (!v27 || v28)
            goto LABEL_30;
        }
        goto LABEL_41;
      }
    }
    else
    {
      v23 = (char *)(v20 + 1);
      *((_BYTE *)v16 + 31) = v22;
      v24 = (char *)v16 + v22 + 8;
      if (v16 + 1 > (_QWORD *)v19)
        goto LABEL_24;
    }
    if (v24 <= v19)
      goto LABEL_24;
LABEL_41:
    __break(1u);
LABEL_42:
    abort();
  }
  if (*(_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 72))(v7) == a2
    && *(_DWORD *)((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 27) + 72))(*((_QWORD *)this + 27)) + 4) == a3)
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 27) + 80))(*((_QWORD *)this + 27), a4);
LABEL_35:
    v32 = *((_QWORD *)this + 10);
    if (v32)
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v32 + 24))(v32))
      {
        v33 = *((_QWORD *)this + 27);
        if (v33)
        {
          if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v33 + 64))(v33))
            (*(void (**)(_QWORD))(**((_QWORD **)this + 27) + 32))(*((_QWORD *)this + 27));
        }
      }
    }
    return 1;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v8, v9, v10, v11, v12, v13, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
  return 0;
}

uint64_t webrtc::DcSctpTransport::OpenStream(webrtc::DcSctpTransport *this, unsigned __int16 a2)
{
  char *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unint64_t v7;
  unsigned __int16 *v8;
  unint64_t v9;
  unsigned __int16 *v10;
  unsigned __int16 *v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  unsigned __int16 *v15;
  unint64_t v16;
  unsigned __int16 *v17;
  unsigned __int16 *v18;
  unsigned __int16 *v19;
  uint64_t v20;
  int v21;
  char *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  unint64_t v27;
  char *v28;
  char *v29;
  int64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int16 v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  unint64_t v38;
  unsigned __int16 *v39;
  unsigned __int16 *v40;
  int v41;
  unsigned __int16 v42;
  unsigned __int16 *i;
  int v44;
  void *v45;

  v4 = (char *)*((_QWORD *)this + 34);
  v5 = (unsigned __int16 *)*((_QWORD *)this + 35);
  v6 = (char *)v5 - v4;
  if (v5 == (unsigned __int16 *)v4)
  {
    v8 = (unsigned __int16 *)*((_QWORD *)this + 35);
  }
  else
  {
    v7 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 1);
    v8 = (unsigned __int16 *)*((_QWORD *)this + 34);
    do
    {
      v9 = v7 >> 1;
      v10 = &v8[3 * (v7 >> 1)];
      v12 = *v10;
      v11 = v10 + 3;
      v7 += ~(v7 >> 1);
      if (v12 < a2)
        v8 = v11;
      else
        v7 = v9;
    }
    while (v7);
  }
  v13 = (unsigned __int128)(((char *)v8 - v4) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
  v14 = v13 + (v13 >> 63);
  v15 = (unsigned __int16 *)&v4[6 * v14];
  if (v15 == v5)
  {
    v16 = *((_QWORD *)this + 36);
    if ((unint64_t)v5 < v16)
    {
      if (v4)
      {
        *v5 = a2;
        v22 = &v4[6 * v14];
        *((_WORD *)v22 + 1) = 0;
        v22[4] = 0;
        *((_QWORD *)this + 35) = v5 + 3;
        return 1;
      }
      goto LABEL_56;
    }
  }
  else
  {
    if (*v15 <= a2)
    {
      v29 = &v4[6 * v14];
LABEL_41:
      *((_WORD *)v29 + 1) = 0;
      v29[4] = 0;
      return 1;
    }
    v16 = *((_QWORD *)this + 36);
    if ((unint64_t)v5 < v16)
    {
      v17 = v15 + 3;
      v18 = v5 - 3;
      if ((unint64_t)v5 < 6)
      {
        *((_QWORD *)this + 35) = v5;
        if (v5 == v17)
        {
LABEL_40:
          *v15 = a2;
          v29 = &v4[6 * v14];
          goto LABEL_41;
        }
      }
      else
      {
        v19 = v5 - 3;
        v20 = *((_QWORD *)this + 35);
        do
        {
          v21 = *(_DWORD *)v19;
          *(_WORD *)(v20 + 4) = v19[2];
          *(_DWORD *)v20 = v21;
          v20 += 6;
          v19 += 3;
        }
        while (v19 < v5);
        *((_QWORD *)this + 35) = v20;
        if (v5 == v17)
          goto LABEL_40;
      }
      v32 = v5 - v17;
      do
      {
        *v18 = v15[v32 - 3];
        v33 = v15[v32 - 2];
        *((_BYTE *)v18 + 4) = v15[v32 - 1];
        v18[1] = v33;
        v18 -= 3;
        v32 -= 3;
      }
      while (v32 * 2);
      goto LABEL_40;
    }
  }
  v23 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 1) + 1;
  if (v23 > 0x2AAAAAAAAAAAAAAALL)
    goto LABEL_57;
  v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16 - (_QWORD)v4) >> 1);
  if (2 * v24 > v23)
    v23 = 2 * v24;
  if (v24 >= 0x1555555555555555)
    v25 = 0x2AAAAAAAAAAAAAAALL;
  else
    v25 = v23;
  if (v25)
  {
    if (v25 > 0x2AAAAAAAAAAAAAAALL)
      goto LABEL_58;
    v26 = (char *)operator new(6 * v25);
    v27 = (unint64_t)&v26[6 * v14];
    v28 = &v26[6 * v25];
    if ((char *)v27 != v28)
      goto LABEL_47;
  }
  else
  {
    v26 = 0;
    v27 = 6 * v14;
    v28 = 0;
    if (v27)
      goto LABEL_47;
  }
  v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27 - (_QWORD)v26) >> 1);
  if (v27 > (unint64_t)v26)
  {
    if (v30 >= -1)
      v31 = v30 + 1;
    else
      v31 = v30 + 2;
    v28 = (char *)v27;
    v27 -= 6 * (v31 >> 1);
    goto LABEL_47;
  }
  v34 = 0x5555555555555556 * ((uint64_t)(v27 - (_QWORD)v26) >> 1);
  if ((char *)v27 == v26)
    v34 = 1;
  if (v34 > 0x2AAAAAAAAAAAAAAALL)
LABEL_58:
    std::__throw_bad_array_new_length[abi:sn180100]();
  v35 = v34 >> 2;
  v36 = 6 * v34;
  v37 = (char *)operator new(6 * v34);
  v27 = (unint64_t)&v37[6 * v35];
  v28 = &v37[v36];
  if (v26)
    operator delete(v26);
LABEL_47:
  if (!v27)
  {
LABEL_56:
    __break(1u);
LABEL_57:
    abort();
  }
  *(_WORD *)v27 = a2;
  *(_WORD *)(v27 + 2) = 0;
  *(_BYTE *)(v27 + 4) = 0;
  v38 = v27 + 6;
  v39 = (unsigned __int16 *)*((_QWORD *)this + 34);
  if (v39 != v15)
  {
    v40 = v15;
    do
    {
      v41 = *(_DWORD *)(v40 - 3);
      v40 -= 3;
      v42 = v40[2];
      *(_DWORD *)(v27 - 6) = v41;
      v27 -= 6;
      *(_WORD *)(v27 + 4) = v42;
    }
    while (v40 != v39);
  }
  for (i = (unsigned __int16 *)*((_QWORD *)this + 35); v15 != i; v15 += 3)
  {
    v44 = *(_DWORD *)v15;
    *(_WORD *)(v38 + 4) = v15[2];
    *(_DWORD *)v38 = v44;
    v38 += 6;
  }
  v45 = (void *)*((_QWORD *)this + 34);
  *((_QWORD *)this + 34) = v27;
  *((_QWORD *)this + 35) = v38;
  *((_QWORD *)this + 36) = v28;
  if (v45)
    operator delete(v45);
  return 1;
}

uint64_t webrtc::DcSctpTransport::ResetStream(webrtc::DcSctpTransport *this, unsigned __int16 a2)
{
  uint64_t v3;
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  unint64_t v6;
  unsigned __int16 *v7;
  unint64_t v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  unsigned int v11;
  unsigned __int16 *v12;
  unint64_t v13;
  unsigned __int16 *v14;
  _BYTE *v15;
  int v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int16 v25;

  v3 = *((_QWORD *)this + 27);
  if (!v3)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0;
LABEL_27:
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v18, v19, v20, v21, v22, v23, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
    return 0;
  }
  v25 = a2;
  v4 = (unsigned __int16 *)*((_QWORD *)this + 34);
  v5 = (unsigned __int16 *)*((_QWORD *)this + 35);
  if (v5 == v4)
  {
    v7 = (unsigned __int16 *)*((_QWORD *)this + 35);
    goto LABEL_18;
  }
  v6 = 0xAAAAAAAAAAAAAAABLL * (v5 - v4);
  v7 = (unsigned __int16 *)*((_QWORD *)this + 34);
  do
  {
    v8 = v6 >> 1;
    v9 = &v7[3 * (v6 >> 1)];
    v11 = *v9;
    v10 = v9 + 3;
    v6 += ~(v6 >> 1);
    if (v11 < a2)
      v7 = v10;
    else
      v6 = v8;
  }
  while (v6);
  if (v5 == v7)
  {
LABEL_18:
    if (v5 == v7)
      v12 = (unsigned __int16 *)*((_QWORD *)this + 35);
    else
      v12 = v7;
    if (v12 != v5)
      goto LABEL_13;
    goto LABEL_22;
  }
  if (&v7[3 * (*v7 <= a2)] == v7)
    v12 = (unsigned __int16 *)*((_QWORD *)this + 35);
  else
    v12 = v7;
  if (v12 == v5)
  {
LABEL_22:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0;
    goto LABEL_27;
  }
LABEL_13:
  v13 = 0xAAAAAAAAAAAAAAABLL * (v12 - v4);
  v14 = &v4[3 * v13];
  v16 = *((unsigned __int8 *)v14 + 2);
  v15 = v14 + 1;
  if (v16)
    return 0;
  if (HIBYTE(v4[3 * v13 + 1]))
    return 0;
  if (LOBYTE(v4[3 * v13 + 2]))
    return 0;
  *v15 = 1;
  (*(void (**)(uint64_t, unsigned __int16 *, uint64_t))(*(_QWORD *)v3 + 120))(v3, &v25, 1);
  return 1;
}

void webrtc::DcSctpTransport::SendData(uint64_t a1@<X0>, unsigned __int16 a2@<W1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  unint64_t v13;
  unsigned __int16 *v14;
  unint64_t v15;
  unsigned __int16 *v16;
  unsigned __int16 *v17;
  unsigned int v18;
  unsigned __int16 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _BYTE *v43;
  _QWORD *v44;
  uint64_t v45;
  BOOL v46;
  uint64_t v47;
  uint64_t v48;
  __int128 v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  size_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *__p[2];
  uint64_t v68;
  char v69[4];
  int v70;
  char v71;
  uint64_t v72;
  char v73;
  uint64_t v74;
  __int128 v75;
  uint64_t v76;

  v7 = *(_QWORD *)(a1 + 216);
  if (!v7)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\n\t", v27, v28, v29, v30, v31, v32, v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
    goto LABEL_27;
  }
  v11 = *(unsigned __int16 **)(a1 + 272);
  v12 = *(unsigned __int16 **)(a1 + 280);
  if (v12 == v11)
  {
    v14 = *(unsigned __int16 **)(a1 + 280);
  }
  else
  {
    v13 = 0xAAAAAAAAAAAAAAABLL * (v12 - v11);
    v14 = *(unsigned __int16 **)(a1 + 272);
    do
    {
      v15 = v13 >> 1;
      v16 = &v14[3 * (v13 >> 1)];
      v18 = *v16;
      v17 = v16 + 3;
      v13 += ~(v13 >> 1);
      if (v18 < a2)
        v14 = v17;
      else
        v13 = v15;
    }
    while (v13);
    if (v12 != v14)
    {
      if (&v14[3 * (*v14 <= a2)] == v14)
        v19 = *(unsigned __int16 **)(a1 + 280);
      else
        v19 = v14;
      if (v19 != v12)
        goto LABEL_13;
LABEL_25:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
LABEL_26:
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v20, v21, v22, v23, v24, v25, v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
LABEL_27:
      v34 = 6;
LABEL_28:
      *(_DWORD *)a5 = v34;
      *(_BYTE *)(a5 + 38) = 0;
      *(_QWORD *)(a5 + 16) = 0;
      *(_QWORD *)(a5 + 24) = 0;
      *(_QWORD *)(a5 + 8) = 0;
      *(_QWORD *)(a5 + 29) = 0;
      return;
    }
  }
  if (v12 == v14)
    v19 = *(unsigned __int16 **)(a1 + 280);
  else
    v19 = v14;
  if (v19 == v12)
    goto LABEL_25;
LABEL_13:
  if (LOBYTE(v11[v19 - v11 + 1]) || HIBYTE(v11[v19 - v11 + 1]) || LOBYTE(v11[v19 - v11 + 2]))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
      goto LABEL_26;
    goto LABEL_27;
  }
  v35 = *(_QWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 72))(v7) + 24);
  if (v35 && a4[2] > v35)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long> const&)::t, v36, v37, v38, v39, v40, v41, v42, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
    v34 = 4;
    goto LABEL_28;
  }
  if (*a4)
    v43 = (_BYTE *)(*(_QWORD *)(*a4 + 16) + a4[1]);
  else
    v43 = 0;
  v44 = std::vector<unsigned char>::vector<unsigned char const*,0>(&v75, v43, &v43[a4[2]]);
  if ((_QWORD)v75 == *((_QWORD *)&v75 + 1))
    std::vector<unsigned char>::push_back[abi:sn180100](v44, 0);
  v45 = a4[2];
  if (*(_DWORD *)a3 == 1)
  {
    v46 = v45 == 0;
    v47 = 0x3500000000;
    v48 = 0x3900000000;
  }
  else
  {
    if (*(_DWORD *)a3)
    {
      v47 = 0x3200000000;
      goto LABEL_48;
    }
    v46 = v45 == 0;
    v47 = 0x3300000000;
    v48 = 0x3800000000;
  }
  if (v46)
    v47 = v48;
LABEL_48:
  v49 = v75;
  v50 = v76;
  v76 = 0;
  v75 = 0uLL;
  LOBYTE(v70) = 0;
  v71 = 0;
  LOBYTE(v72) = 0;
  v73 = 0;
  v74 = 0;
  v69[0] = *(_BYTE *)(a3 + 4) ^ 1;
  if (*(_BYTE *)(a3 + 20))
  {
    v51 = *(_DWORD *)(a3 + 16);
    v71 = 1;
    v70 = v51;
  }
  v52 = v47 | a2;
  if (*(_BYTE *)(a3 + 12))
  {
    v53 = *(int *)(a3 + 8);
    v73 = 1;
    v72 = v53;
  }
  v54 = *(_QWORD *)(a1 + 216);
  v66 = v52;
  *(_OWORD *)__p = v49;
  v68 = v50;
  v55 = (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(_QWORD *)v54 + 104))(v54, &v66, v69);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v55 == 3)
  {
    *(_BYTE *)(a1 + 296) = 0;
    *(_DWORD *)a5 = 9;
  }
  else
  {
    if (v55)
    {
      if ((v55 - 1) > 3)
      {
        v58 = "SUCCESS";
        v57 = 7;
      }
      else
      {
        v56 = v55 - 1;
        v57 = *(_QWORD *)((char *)&unk_208F088D0 + v56 * 8);
        v58 = off_24C0B2C00[v56];
      }
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\n\t\v\t", v59, v60, v61, v62, v63, v64, v65, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
      webrtc::RTCError::RTCError(a5, 8, v58, v57);
      goto LABEL_65;
    }
    *(_DWORD *)a5 = 0;
  }
  *(_BYTE *)(a5 + 38) = 0;
  *(_QWORD *)(a5 + 16) = 0;
  *(_QWORD *)(a5 + 24) = 0;
  *(_QWORD *)(a5 + 8) = 0;
  *(_QWORD *)(a5 + 29) = 0;
LABEL_65:
  if ((_QWORD)v75)
  {
    *((_QWORD *)&v75 + 1) = v75;
    operator delete((void *)v75);
  }
}

_QWORD *std::vector<unsigned char>::vector<unsigned char const*,0>(_QWORD *a1, _BYTE *a2, _BYTE *a3)
{
  size_t v4;
  char *v6;
  char *v7;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = a3 - a2;
  if (a3 != a2)
  {
    if ((v4 & 0x8000000000000000) != 0)
      abort();
    v6 = (char *)operator new(a3 - a2);
    *a1 = v6;
    a1[1] = v6;
    v7 = &v6[v4];
    a1[2] = &v6[v4];
    memcpy(v6, a2, v4);
    a1[1] = v7;
  }
  return a1;
}

void std::vector<unsigned char>::push_back[abi:sn180100](_QWORD *a1, char a2)
{
  unint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  size_t v12;
  char *v13;
  char *v14;
  char *v15;
  unint64_t v16;
  __int128 *v17;
  char *v18;
  unint64_t v19;
  __int128 v20;
  char *v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  char *v25;
  char v26;

  v5 = (char *)a1[1];
  v4 = a1[2];
  v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    if (v5)
    {
      *v5 = a2;
      v7 = (uint64_t)(v5 + 1);
      goto LABEL_30;
    }
    goto LABEL_31;
  }
  v8 = (char *)*a1;
  v9 = (unint64_t)&v5[-*a1];
  v10 = v9 + 1;
  if ((uint64_t)(v9 + 1) < 0)
    goto LABEL_32;
  v11 = v4 - (_QWORD)v8;
  if (2 * v11 > v10)
    v10 = 2 * v11;
  if (v11 >= 0x3FFFFFFFFFFFFFFFLL)
    v12 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v12 = v10;
  if (!v12)
  {
LABEL_31:
    __break(1u);
LABEL_32:
    abort();
  }
  v13 = (char *)operator new(v12);
  v14 = &v13[v12];
  v15 = &v13[v9];
  v13[v9] = a2;
  v7 = (uint64_t)&v13[v9 + 1];
  if (v5 != v8)
  {
    if (v9 >= 8 && (unint64_t)(v8 - v13) >= 0x20)
    {
      if (v9 < 0x20)
      {
        v16 = 0;
        goto LABEL_20;
      }
      v16 = v9 & 0xFFFFFFFFFFFFFFE0;
      v17 = (__int128 *)(v5 - 16);
      v18 = &v13[v5 - 16 - v8];
      v19 = v9 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v20 = *v17;
        *((_OWORD *)v18 - 1) = *(v17 - 1);
        *(_OWORD *)v18 = v20;
        v18 -= 32;
        v17 -= 2;
        v19 -= 32;
      }
      while (v19);
      if (v9 == v16)
        goto LABEL_27;
      if ((v9 & 0x18) != 0)
      {
LABEL_20:
        v6 = &v5[-(v9 & 0xFFFFFFFFFFFFFFF8)];
        v15 -= v9 & 0xFFFFFFFFFFFFFFF8;
        v21 = &v5[-v16 - 8];
        v22 = (char *)(v21 - v8);
        v23 = v16 - (v9 & 0xFFFFFFFFFFFFFFF8);
        do
        {
          v24 = *(_QWORD *)v21;
          v21 -= 8;
          *(_QWORD *)&v22[(_QWORD)v13] = v24;
          v22 -= 8;
          v23 += 8;
        }
        while (v23);
        if (v9 == (v9 & 0xFFFFFFFFFFFFFFF8))
          goto LABEL_27;
        goto LABEL_25;
      }
      v15 -= v16;
      v6 = &v5[-v16];
    }
LABEL_25:
    v25 = v15 - 1;
    do
    {
      v26 = *--v6;
      *v25-- = v26;
    }
    while (v6 != v8);
LABEL_27:
    v6 = v8;
    v15 = v13;
  }
  *a1 = v15;
  a1[1] = v7;
  a1[2] = v14;
  if (v6)
    operator delete(v6);
LABEL_30:
  a1[1] = v7;
}

uint64_t webrtc::RTCError::RTCError(uint64_t a1, int a2, char *__src, size_t __len)
{
  char *v5;
  size_t v8;
  size_t v9;
  char *v10;

  *(_DWORD *)a1 = a2;
  v5 = (char *)(a1 + 8);
  if (__len >= 0x7FFFFFFFFFFFFFF8)
LABEL_15:
    abort();
  if (__len > 0x16)
  {
    v8 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v8 = __len | 7;
    v9 = v8 + 1;
    v5 = (char *)operator new(v8 + 1);
    *(_QWORD *)(a1 + 16) = __len;
    *(_QWORD *)(a1 + 24) = v9 | 0x8000000000000000;
    *(_QWORD *)(a1 + 8) = v5;
  }
  else
  {
    *(_BYTE *)(a1 + 31) = __len;
  }
  v10 = &v5[__len];
  if (v5 <= __src && v10 > __src)
  {
    __break(1u);
    goto LABEL_15;
  }
  if (__len)
    memmove(v5, __src, __len);
  *v10 = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 38) = 0;
  return a1;
}

uint64_t webrtc::DcSctpTransport::ReadyToSendData(webrtc::DcSctpTransport *this)
{
  return *((unsigned __int8 *)this + 296);
}

uint64_t webrtc::DcSctpTransport::max_message_size(webrtc::DcSctpTransport *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v1 = *((_QWORD *)this + 27);
  if (v1)
    return *(unsigned int *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 72))(v1) + 24);
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\n\t", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
  return 0;
}

uint64_t webrtc::DcSctpTransport::max_outbound_streams(webrtc::DcSctpTransport *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 27);
  if (result)
    return *(unsigned __int16 *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 72))(result) + 10) | 0x100000000;
  return result;
}

uint64_t webrtc::DcSctpTransport::max_inbound_streams(webrtc::DcSctpTransport *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 27);
  if (result)
    return *(unsigned __int16 *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 72))(result) + 8) | 0x100000000;
  return result;
}

uint64_t webrtc::DcSctpTransport::buffered_amount(webrtc::DcSctpTransport *this, unsigned __int16 a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 27);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 128))(result, a2);
  return result;
}

uint64_t webrtc::DcSctpTransport::buffered_amount_low_threshold(webrtc::DcSctpTransport *this, unsigned __int16 a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 27);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 136))(result, a2);
  return result;
}

uint64_t webrtc::DcSctpTransport::SetBufferedAmountLowThreshold(webrtc::DcSctpTransport *this, unsigned __int16 a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 27);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 144))(result, a2);
  return result;
}

std::string *webrtc::DcSctpTransport::set_debug_name_for_testing(std::string *this, const char *a2)
{
  if (a2)
    return std::string::__assign_external((std::string *)((char *)this + 224), a2);
  __break(1u);
  return this;
}

uint64_t webrtc::DcSctpTransport::SendPacketWithStatus(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  char *v26;
  void *__p;
  void *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  char v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  char v40;

  if (a3 > *(_QWORD *)((*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 216) + 72))(*(_QWORD *)(a1 + 216)) + 16))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
    {
      v24 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc";
      v25 = 3291;
      v26 = &v40;
      (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 216) + 72))(*(_QWORD *)(a1 + 216));
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long> const&)::t, v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
    }
    return 2;
  }
  v13 = *(_QWORD *)(a1 + 80);
  if (!v13 || !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v13 + 24))(v13))
    return 2;
  v14 = *(_QWORD *)(a1 + 80);
  LODWORD(v24) = -1;
  BYTE4(v24) = 0;
  v25 = -1;
  LODWORD(v26) = -1;
  v28 = 0;
  v29 = 0;
  __p = 0;
  v30 = -1;
  v31 = -1;
  v32 = 0;
  v35 = 0;
  v33 = 0;
  v34 = 0;
  v37 = 0;
  v38 = 0;
  v36 = 0;
  v39 = 0;
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, const char **, _QWORD))(*(_QWORD *)v14 + 40))(v14, a2, a3, &v24, 0);
  if (__p)
  {
    v28 = __p;
    operator delete(__p);
  }
  if ((v15 & 0x80000000) == 0)
    return 0;
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 80) + 64))(*(_QWORD *)(a1 + 80));
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v17, v18, v19, v20, v21, v22, v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
  }
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 80) + 64))(*(_QWORD *)(a1 + 80)) - 35 < 2)
    return 1;
  else
    return 2;
}

uint64_t `non-virtual thunk to'webrtc::DcSctpTransport::SendPacketWithStatus(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return webrtc::DcSctpTransport::SendPacketWithStatus(a1 - 8, a2, a3);
}

int64x2_t webrtc::DcSctpTransport::CreateTimeout@<Q0>(uint64_t a1@<X0>, __int32 a2@<W1>, int64x2_t **a3@<X8>)
{
  uint64_t v5;
  int64x2_t *v6;
  uint64_t v7;
  unsigned int v8;
  int64x2_t result;

  v5 = a1 + 144;
  v6 = (int64x2_t *)operator new();
  v6->i64[0] = (uint64_t)&off_24C0C21F0;
  v6->i64[1] = v5;
  v6[1].i32[0] = a2;
  v7 = operator new();
  *(_DWORD *)v7 = 0;
  *(_BYTE *)(v7 + 4) = 1;
  v6[1].i64[1] = v7;
  do
    v8 = __ldxr((unsigned int *)v7);
  while (__stxr(v8 + 1, (unsigned int *)v7));
  result = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
  v6[2] = result;
  v6[3].i64[0] = 0;
  *a3 = v6;
  return result;
}

int64x2_t `non-virtual thunk to'webrtc::DcSctpTransport::CreateTimeout@<Q0>(uint64_t a1@<X0>, __int32 a2@<W1>, int64x2_t **a3@<X8>)
{
  uint64_t v5;
  int64x2_t *v6;
  uint64_t v7;
  unsigned int v8;
  int64x2_t result;

  v5 = a1 + 136;
  v6 = (int64x2_t *)operator new();
  v6->i64[0] = (uint64_t)&off_24C0C21F0;
  v6->i64[1] = v5;
  v6[1].i32[0] = a2;
  v7 = operator new();
  *(_DWORD *)v7 = 0;
  *(_BYTE *)(v7 + 4) = 1;
  v6[1].i64[1] = v7;
  do
    v8 = __ldxr((unsigned int *)v7);
  while (__stxr(v8 + 1, (unsigned int *)v7));
  result = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
  v6[2] = result;
  v6[3].i64[0] = 0;
  *a3 = v6;
  return result;
}

unint64_t webrtc::DcSctpTransport::TimeMillis(webrtc::DcSctpTransport *this)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;

  v1 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 16))(*((_QWORD *)this + 13));
  v2 = v1 / 0x3E8uLL;
  if (v1 % 0x3E8uLL > 0x1F3)
    ++v2;
  if (-v1 % 0x3E8uLL <= 0x1F4)
    v3 = 0;
  else
    v3 = -1;
  if (v1 < 0)
    return v3 - -v1 / 0x3E8uLL;
  else
    return v2;
}

unint64_t `non-virtual thunk to'webrtc::DcSctpTransport::TimeMillis(webrtc::DcSctpTransport *this)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;

  v1 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 12) + 16))(*((_QWORD *)this + 12));
  v2 = v1 / 0x3E8uLL;
  if (v1 % 0x3E8uLL > 0x1F3)
    ++v2;
  if (-v1 % 0x3E8uLL <= 0x1F4)
    v3 = 0;
  else
    v3 = -1;
  if (v1 < 0)
    return v3 - -v1 / 0x3E8uLL;
  else
    return v2;
}

uint64_t webrtc::DcSctpTransport::GetRandomInt(webrtc::DcSctpTransport *this, int a2, int a3)
{
  uint64_t v3;
  unint64_t v4;

  v3 = *((_QWORD *)this + 16) ^ (*((_QWORD *)this + 16) >> 12);
  v4 = v3 ^ (v3 << 25) ^ ((v3 ^ (unint64_t)(v3 << 25)) >> 27);
  *((_QWORD *)this + 16) = v4;
  return ((((1332534557 * v4)
                        + (1332534557 * v4) * (unint64_t)(a3 - a2)) >> 32)
                      + a2);
}

uint64_t `non-virtual thunk to'webrtc::DcSctpTransport::GetRandomInt(webrtc::DcSctpTransport *this, int a2, int a3)
{
  uint64_t v3;
  unint64_t v4;

  v3 = *((_QWORD *)this + 15) ^ (*((_QWORD *)this + 15) >> 12);
  v4 = v3 ^ (v3 << 25) ^ ((v3 ^ (unint64_t)(v3 << 25)) >> 27);
  *((_QWORD *)this + 15) = v4;
  return ((((1332534557 * v4)
                        + (1332534557 * v4) * (unint64_t)(a3 - a2)) >> 32)
                      + a2);
}

uint64_t webrtc::DcSctpTransport::OnTotalBufferedAmountLow(uint64_t this)
{
  if (!*(_BYTE *)(this + 296))
  {
    *(_BYTE *)(this + 296) = 1;
    this = *(_QWORD *)(this + 336);
    if (this)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 40))(this);
  }
  return this;
}

uint64_t `non-virtual thunk to'webrtc::DcSctpTransport::OnTotalBufferedAmountLow(uint64_t this)
{
  if (!*(_BYTE *)(this + 288))
  {
    *(_BYTE *)(this + 288) = 1;
    this = *(_QWORD *)(this + 328);
    if (this)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 40))(this);
  }
  return this;
}

uint64_t webrtc::DcSctpTransport::OnBufferedAmountLow(uint64_t a1, unsigned __int16 a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 336);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 56))(result, a2);
  return result;
}

uint64_t `non-virtual thunk to'webrtc::DcSctpTransport::OnBufferedAmountLow(uint64_t a1, unsigned __int16 a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 328);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 56))(result, a2);
  return result;
}

void webrtc::DcSctpTransport::OnMessageReceived(uint64_t a1, unsigned __int16 *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  uint64_t v16;

  v4 = *((_DWORD *)a2 + 1) - 50;
  if (v4 < 8 && ((0xDFu >> v4) & 1) != 0)
  {
    v12 = dword_208F088F0[v4];
    rtc::CopyOnWriteBuffer::Clear(a1 + 248);
    if ((*((_DWORD *)a2 + 1) & 0xFFFFFFFE) != 0x38)
    {
      v13 = *((_QWORD *)a2 + 1);
      v14 = *((_QWORD *)a2 + 2);
      if (v14 == v13)
        v15 = 0;
      else
        v15 = (const void *)*((_QWORD *)a2 + 1);
      rtc::CopyOnWriteBuffer::AppendData<unsigned char,(void *)0>((rtc::CopyOnWriteBuffer *)(a1 + 248), v15, v14 - v13);
    }
    v16 = *(_QWORD *)(a1 + 336);
    if (v16)
      (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v16 + 16))(v16, *a2, v12, a1 + 248);
  }
  else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
  {
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v5, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
  }
}

_QWORD *rtc::CopyOnWriteBuffer::AppendData<unsigned char,(void *)0>(rtc::CopyOnWriteBuffer *this, const void *a2, size_t a3)
{
  uint64_t v6;
  uint64_t *v7;
  _QWORD *result;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  void *v18;
  unsigned int *v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  size_t v26;
  size_t v27;
  size_t v28;
  size_t v29;
  void *v30;
  void *v31;
  uint64_t v32;

  if (*(_QWORD *)this)
  {
    v6 = *((_QWORD *)this + 2);
    if (*(_QWORD *)(*(_QWORD *)this + 8) - *((_QWORD *)this + 1) <= v6 + a3)
      v7 = (uint64_t *)(v6 + a3);
    else
      v7 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)this + 8) - *((_QWORD *)this + 1));
    result = rtc::CopyOnWriteBuffer::UnshareAndEnsureCapacity((uint64_t *)this, v7);
    v9 = *(_QWORD *)this;
    v10 = *((_QWORD *)this + 2) + *((_QWORD *)this + 1);
    v11 = *(_QWORD *)(*(_QWORD *)this + 8);
    v12 = *(_QWORD *)this;
    if (v11 < v10)
    {
      v13 = v11 + (v11 >> 1);
      if (v13 <= v10)
        v14 = *((_QWORD *)this + 2) + *((_QWORD *)this + 1);
      else
        v14 = v13;
      result = (_QWORD *)operator new[]();
      v15 = result;
      v16 = *(_QWORD *)(v9 + 16);
      if (v16)
      {
        memcpy(result, *(const void **)(v9 + 16), *(_QWORD *)v9);
        *(_QWORD *)(v9 + 16) = v15;
        result = (_QWORD *)MEMORY[0x20BD0ADD4](v16, 0x1000C8077774924);
      }
      else
      {
        *(_QWORD *)(v9 + 16) = result;
      }
      *(_QWORD *)(v9 + 8) = v14;
      v12 = *(_QWORD *)this;
    }
    *(_QWORD *)v9 = v10;
    if (a3)
    {
      v26 = *(_QWORD *)v12;
      v27 = *(_QWORD *)(v12 + 8);
      v28 = *(_QWORD *)v12 + a3;
      if (v27 < v28)
      {
        if (v27 + (v27 >> 1) <= v28)
          v29 = *(_QWORD *)v12 + a3;
        else
          v29 = v27 + (v27 >> 1);
        v30 = (void *)operator new[]();
        v31 = v30;
        v32 = *(_QWORD *)(v12 + 16);
        if (v32)
        {
          memcpy(v30, *(const void **)(v12 + 16), *(_QWORD *)v12);
          *(_QWORD *)(v12 + 16) = v31;
          MEMORY[0x20BD0ADD4](v32, 0x1000C8077774924);
        }
        else
        {
          *(_QWORD *)(v12 + 16) = v30;
        }
        *(_QWORD *)(v12 + 8) = v29;
        v26 = *(_QWORD *)v12;
      }
      result = memcpy((void *)(*(_QWORD *)(v12 + 16) + v26), a2, a3);
      *(_QWORD *)v12 = v28;
    }
    *((_QWORD *)this + 2) += a3;
  }
  else
  {
    result = (_QWORD *)operator new();
    v17 = result;
    *result = a3;
    result[1] = a3;
    if (a3)
    {
      v18 = (void *)operator new[]();
      result = memcpy(v18, a2, a3);
    }
    else
    {
      v18 = 0;
    }
    *((_DWORD *)v17 + 6) = 0;
    v19 = (unsigned int *)(v17 + 3);
    v17[2] = v18;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
    v21 = *(_QWORD *)this;
    if (*(_QWORD *)this)
    {
      v22 = (unsigned int *)(v21 + 24);
      do
      {
        v23 = __ldaxr(v22);
        v24 = v23 - 1;
      }
      while (__stlxr(v24, v22));
      if (!v24)
      {
        v25 = *(_QWORD *)(v21 + 16);
        *(_QWORD *)(v21 + 16) = 0;
        if (v25)
          MEMORY[0x20BD0ADD4](v25, 0x1000C8077774924);
        result = (_QWORD *)MEMORY[0x20BD0ADEC](v21, 0x1010C40EE34DA14);
      }
    }
    *(_QWORD *)this = v17;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = a3;
  }
  return result;
}

void `non-virtual thunk to'webrtc::DcSctpTransport::OnMessageReceived(uint64_t a1, unsigned __int16 *a2)
{
  webrtc::DcSctpTransport::OnMessageReceived(a1 - 8, a2);
}

void webrtc::DcSctpTransport::OnError(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a2 == 7)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) != 0)
      return;
  }
  else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
  {
    return;
  }
  rtc::webrtc_logging_impl::Log("\r\n\t\v\t\v\t", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
}

void `non-virtual thunk to'webrtc::DcSctpTransport::OnError(uint64_t a1, int a2)
{
  webrtc::DcSctpTransport::OnError(a1 - 8, a2);
}

void webrtc::DcSctpTransport::OnAborted(uint64_t a1, int a2, void **a3, size_t a4)
{
  size_t v4;
  void **v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  std::string::size_type v16;
  const char *v17;
  void **p_src;
  void **v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  void **v23;
  std::string::size_type v24;
  std::string *v25;
  void **v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  std::string __p;
  _DWORD v33[2];
  void **__src;
  unint64_t v35;
  unint64_t v36;
  const char *v37;
  std::string v38;
  _BYTE v39[7];
  void **v40;
  size_t v41;

  v4 = a4;
  v5 = a3;
  v40 = a3;
  v41 = a4;
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
  {
    if ((a2 - 1) > 7)
    {
      v17 = "NO_ERROR";
      v16 = 8;
    }
    else
    {
      v15 = a2 - 1;
      v16 = *(_QWORD *)((char *)&unk_208F08950 + v15 * 8);
      v17 = off_24C0B2C60[v15];
    }
    v37 = v17;
    v38.__r_.__value_.__r.__words[0] = v16;
    rtc::webrtc_logging_impl::Log("\r\n\t\v\t\v\t", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
    v5 = v40;
    v4 = v41;
  }
  *(_BYTE *)(a1 + 296) = 0;
  if (v4 > 0x7FFFFFFFFFFFFFF7)
LABEL_47:
    abort();
  if (v4 > 0x16)
  {
    v20 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v20 = v4 | 7;
    v21 = v20 + 1;
    p_src = (void **)operator new(v20 + 1);
    v35 = v4;
    v36 = v21 | 0x8000000000000000;
    __src = p_src;
    v19 = (void **)((char *)p_src + v4);
    if (p_src > v5)
      goto LABEL_14;
  }
  else
  {
    HIBYTE(v36) = v4;
    p_src = (void **)&__src;
    v19 = (void **)((char *)&__src + v4);
    if (&__src > (void ***)v5)
      goto LABEL_14;
  }
  if (v19 > v5)
    goto LABEL_46;
LABEL_14:
  if (v4)
    memmove(p_src, v5, v4);
  *(_BYTE *)v19 = 0;
  v22 = HIBYTE(v36);
  if (SHIBYTE(v36) < 0)
  {
    v24 = v35;
    if ((v35 & 0x8000000000000000) == 0)
    {
      v23 = __src;
      if (!v35 || __src)
      {
        LODWORD(v37) = 11;
        if (v35 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_47;
        if (v35 <= 0x16)
          goto LABEL_18;
        goto LABEL_25;
      }
    }
LABEL_46:
    __break(1u);
    goto LABEL_47;
  }
  LODWORD(v37) = 11;
  v23 = (void **)&__src;
  v24 = HIBYTE(v36);
  if (HIBYTE(v36) <= 0x16uLL)
  {
LABEL_18:
    *((_BYTE *)&v38.__r_.__value_.__s + 23) = v24;
    v25 = &v38;
    v26 = (void **)((char *)&v38.__r_.__value_.__l.__data_ + v24);
    if (&v38 > (std::string *)v23)
      goto LABEL_29;
    goto LABEL_28;
  }
LABEL_25:
  v27 = (v24 & 0x7FFFFFFFFFFFFFF8) + 8;
  if ((v24 | 7) != 0x17)
    v27 = v24 | 7;
  v28 = v27 + 1;
  v25 = (std::string *)operator new(v27 + 1);
  v38.__r_.__value_.__l.__size_ = v24;
  v38.__r_.__value_.__r.__words[2] = v28 | 0x8000000000000000;
  v38.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
  v26 = (void **)((char *)&v25->__r_.__value_.__l.__data_ + v24);
  if (v25 <= (std::string *)v23)
  {
LABEL_28:
    if (v26 <= v23)
      goto LABEL_29;
    goto LABEL_46;
  }
LABEL_29:
  if (v24)
    memmove(v25, v23, v24);
  *(_BYTE *)v26 = 0;
  *(_DWORD *)v39 = 0;
  v39[4] = 0;
  v39[6] = 0;
  if ((v22 & 0x80) == 0)
  {
    *(_DWORD *)v39 = 4;
    v29 = a2 - 3;
    if ((a2 - 3) > 4)
      goto LABEL_33;
LABEL_36:
    *(_WORD *)&v39[4] = word_208F08990[v29];
    v39[6] = 1;
    v30 = *(_QWORD *)(a1 + 336);
    if (!v30)
      goto LABEL_41;
    goto LABEL_37;
  }
  operator delete(__src);
  *(_DWORD *)v39 = 4;
  v29 = a2 - 3;
  if ((a2 - 3) <= 4)
    goto LABEL_36;
LABEL_33:
  v30 = *(_QWORD *)(a1 + 336);
  if (!v30)
    goto LABEL_41;
LABEL_37:
  v31 = (int)v37;
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, v38.__r_.__value_.__l.__data_, v38.__r_.__value_.__l.__size_);
  else
    __p = v38;
  v33[0] = *(_DWORD *)v39;
  *(_DWORD *)((char *)v33 + 3) = *(_DWORD *)&v39[3];
  (*(void (**)(uint64_t, int *))(*(_QWORD *)v30 + 48))(v30, &v31);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_41:
    if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_42;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
LABEL_42:
    operator delete(v38.__r_.__value_.__l.__data_);
}

void `non-virtual thunk to'webrtc::DcSctpTransport::OnAborted(uint64_t a1, int a2, void **a3, size_t a4)
{
  webrtc::DcSctpTransport::OnAborted(a1 - 8, a2, a3, a4);
}

uint64_t webrtc::DcSctpTransport::OnConnected(webrtc::DcSctpTransport *this)
{
  uint64_t v2;
  uint64_t result;

  *((_BYTE *)this + 296) = 1;
  v2 = *((_QWORD *)this + 42);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
  result = *((_QWORD *)this + 41);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

uint64_t `non-virtual thunk to'webrtc::DcSctpTransport::OnConnected(webrtc::DcSctpTransport *this)
{
  uint64_t v2;
  uint64_t result;

  *((_BYTE *)this + 288) = 1;
  v2 = *((_QWORD *)this + 41);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
  result = *((_QWORD *)this + 40);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

uint64_t webrtc::DcSctpTransport::OnClosed(uint64_t this)
{
  *(_BYTE *)(this + 296) = 0;
  return this;
}

uint64_t `non-virtual thunk to'webrtc::DcSctpTransport::OnClosed(uint64_t this)
{
  *(_BYTE *)(this + 288) = 0;
  return this;
}

void webrtc::DcSctpTransport::OnStreamsResetFailed(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (a3)
  {
    v5 = 2 * a3;
    do
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      {
        v3 = v3 & 0xFFFFFFFF00000000 | 0x1182;
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
      }
      a2 += 2;
      v5 -= 2;
    }
    while (v5);
  }
}

void `non-virtual thunk to'webrtc::DcSctpTransport::OnStreamsResetFailed(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (a3)
  {
    v5 = 2 * a3;
    do
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      {
        v3 = v3 & 0xFFFFFFFF00000000 | 0x1182;
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
      }
      a2 += 2;
      v5 -= 2;
    }
    while (v5);
  }
}

void webrtc::DcSctpTransport::OnStreamsResetPerformed(_QWORD *a1, unsigned __int16 *a2, uint64_t a3)
{
  unint64_t v3;
  unsigned __int16 *v4;
  unsigned __int16 *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  unint64_t v16;
  unsigned __int16 *v17;
  unint64_t v18;
  unsigned __int16 *v19;
  unsigned __int16 *v20;
  unsigned int v21;
  unsigned __int16 *v22;
  unsigned __int16 *v23;
  uint64_t v24;
  unsigned __int16 *v25;
  unint64_t v26;
  unint64_t v27;
  unsigned __int16 *v28;
  unsigned __int16 *v29;
  unsigned int v30;
  unsigned __int16 *v31;
  int64_t v32;
  int64_t v33;
  unsigned __int16 *v34;
  unsigned __int16 v35;

  if (a3)
  {
    v4 = a2;
    v6 = &a2[a3];
    while (1)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        v3 = v3 & 0xFFFFFFFF00000000 | 0x11D9;
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v7, v8, v9, v10, v11, v12, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
      }
      v15 = (unsigned __int16 *)a1[34];
      v14 = (unsigned __int16 *)a1[35];
      if (v14 == v15)
      {
        v17 = (unsigned __int16 *)a1[35];
        v22 = v17;
      }
      else
      {
        v16 = 0xAAAAAAAAAAAAAAABLL * (v14 - v15);
        v17 = (unsigned __int16 *)a1[34];
        do
        {
          v18 = v16 >> 1;
          v19 = &v17[3 * (v16 >> 1)];
          v21 = *v19;
          v20 = v19 + 3;
          v16 += ~(v16 >> 1);
          if (v21 < *v4)
            v17 = v20;
          else
            v16 = v18;
        }
        while (v16);
        v22 = (unsigned __int16 *)a1[35];
        if (v14 != v17)
          v22 = &v17[3 * (*v4 >= *v17)];
      }
      if (v22 == v17)
        v17 = (unsigned __int16 *)a1[35];
      if (v17 == v14)
        return;
      v23 = &v15[v17 - v15];
      *((_BYTE *)v23 + 4) = 1;
      if (*((_BYTE *)v23 + 3))
        break;
LABEL_4:
      if (++v4 == v6)
        return;
    }
    v24 = a1[42];
    if (v24)
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 32))(v24, *v4);
      v15 = (unsigned __int16 *)a1[34];
      v25 = (unsigned __int16 *)a1[35];
      v14 = v25;
      if (v25 == v15)
      {
LABEL_29:
        v31 = v25;
        if (v14 != v25)
        {
          v31 = v25 + 3;
          if (*v4 < *v25)
            v31 = v25;
        }
        v32 = 0xAAAAAAAAAAAAAAABLL * (v25 - v15);
        v33 = 0xAAAAAAAAAAAAAAABLL * (v31 - v15);
        if (v33 < v32)
        {
          __break(1u);
          return;
        }
        if (v32 != v33)
        {
          if (v31 != v14)
          {
            v25 = &v15[v25 - v15];
            v34 = v25 + 1;
            do
            {
              *(v34 - 1) = *v31;
              v35 = v31[1];
              *((_BYTE *)v34 + 2) = *((_BYTE *)v31 + 4);
              *v34 = v35;
              v34 += 3;
              v31 += 3;
              v25 += 3;
            }
            while (v31 != v14);
          }
          a1[35] = v25;
        }
        goto LABEL_4;
      }
    }
    else
    {
      v25 = v14;
      if (v14 == v15)
        goto LABEL_29;
    }
    v26 = 0xAAAAAAAAAAAAAAABLL * (v25 - v15);
    v25 = v15;
    do
    {
      v27 = v26 >> 1;
      v28 = &v25[3 * (v26 >> 1)];
      v30 = *v28;
      v29 = v28 + 3;
      v26 += ~(v26 >> 1);
      if (v30 < *v4)
        v25 = v29;
      else
        v26 = v27;
    }
    while (v26);
    goto LABEL_29;
  }
}

void `non-virtual thunk to'webrtc::DcSctpTransport::OnStreamsResetPerformed(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  webrtc::DcSctpTransport::OnStreamsResetPerformed((_QWORD *)(a1 - 8), a2, a3);
}

void webrtc::DcSctpTransport::OnIncomingStreamsReset(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  unint64_t v3;
  unsigned __int16 *v4;
  unsigned __int16 *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  unint64_t v16;
  unsigned __int16 *v17;
  unint64_t v18;
  unsigned __int16 *v19;
  unsigned __int16 *v20;
  unsigned int v21;
  unint64_t v22;
  unsigned __int16 *v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  unint64_t v28;
  unsigned __int16 *v29;
  unint64_t v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  unsigned int v33;
  unsigned __int16 *v34;
  int64_t v35;
  int64_t v36;
  unsigned __int16 *v37;
  unsigned __int16 v38;
  unsigned __int16 v39;

  if (a3)
  {
    v4 = a2;
    v6 = &a2[a3];
    do
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        v3 = v3 & 0xFFFFFFFF00000000 | 0x12B9;
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v7, v8, v9, v10, v11, v12, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/media/sctp/dcsctp_transport.cc");
      }
      v15 = *(unsigned __int16 **)(a1 + 272);
      v14 = *(unsigned __int16 **)(a1 + 280);
      if (v14 == v15)
      {
        v17 = *(unsigned __int16 **)(a1 + 280);
      }
      else
      {
        v16 = 0xAAAAAAAAAAAAAAABLL * (v14 - v15);
        v17 = *(unsigned __int16 **)(a1 + 272);
        do
        {
          v18 = v16 >> 1;
          v19 = &v17[3 * (v16 >> 1)];
          v21 = *v19;
          v20 = v19 + 3;
          v16 += ~(v16 >> 1);
          if (v21 < *v4)
            v17 = v20;
          else
            v16 = v18;
        }
        while (v16);
        if (v14 != v17)
        {
          if (&v17[3 * (*v4 >= *v17)] == v17)
            v17 = *(unsigned __int16 **)(a1 + 280);
          if (v17 == v14)
            return;
          goto LABEL_22;
        }
      }
      if (v14 == v17)
        v17 = *(unsigned __int16 **)(a1 + 280);
      if (v17 == v14)
        return;
LABEL_22:
      v22 = 0xAAAAAAAAAAAAAAABLL * (v17 - v15);
      v23 = &v15[v17 - v15];
      *((_BYTE *)v23 + 3) = 1;
      if (!*((_BYTE *)v23 + 2))
      {
        v39 = *v4;
        (*(void (**)(_QWORD, unsigned __int16 *, uint64_t))(**(_QWORD **)(a1 + 216) + 120))(*(_QWORD *)(a1 + 216), &v39, 1);
        v24 = *(_QWORD *)(a1 + 336);
        if (v24)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 24))(v24, *v4);
      }
      if (LOBYTE(v15[3 * v22 + 2]))
      {
        v25 = *(_QWORD *)(a1 + 336);
        if (v25)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 32))(v25, *v4);
        v27 = *(unsigned __int16 **)(a1 + 272);
        v26 = *(unsigned __int16 **)(a1 + 280);
        if (v26 == v27)
        {
          v29 = *(unsigned __int16 **)(a1 + 280);
          v34 = v29;
        }
        else
        {
          v28 = 0xAAAAAAAAAAAAAAABLL * (v26 - v27);
          v29 = *(unsigned __int16 **)(a1 + 272);
          do
          {
            v30 = v28 >> 1;
            v31 = &v29[3 * (v28 >> 1)];
            v33 = *v31;
            v32 = v31 + 3;
            v28 += ~(v28 >> 1);
            if (v33 < *v4)
              v29 = v32;
            else
              v28 = v30;
          }
          while (v28);
          v34 = v29;
          if (v26 != v29)
          {
            v34 = v29 + 3;
            if (*v4 < *v29)
              v34 = v29;
          }
        }
        v35 = 0xAAAAAAAAAAAAAAABLL * (v29 - v27);
        v36 = 0xAAAAAAAAAAAAAAABLL * (v34 - v27);
        if (v36 < v35)
        {
          __break(1u);
          return;
        }
        if (v35 != v36)
        {
          if (v34 != v26)
          {
            v29 = &v27[v29 - v27];
            v37 = v29 + 1;
            do
            {
              *(v37 - 1) = *v34;
              v38 = v34[1];
              *((_BYTE *)v37 + 2) = *((_BYTE *)v34 + 4);
              *v37 = v38;
              v37 += 3;
              v34 += 3;
              v29 += 3;
            }
            while (v34 != v26);
          }
          *(_QWORD *)(a1 + 280) = v29;
        }
      }
      ++v4;
    }
    while (v4 != v6);
  }
}

void `non-virtual thunk to'webrtc::DcSctpTransport::OnIncomingStreamsReset(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  webrtc::DcSctpTransport::OnIncomingStreamsReset(a1 - 8, a2, a3);
}

uint64_t webrtc::DcSctpTransport::OnTransportWritableState(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 80);
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    if ((_DWORD)result)
    {
      result = *(_QWORD *)(a1 + 216);
      if (result)
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 64))(result);
        if (!(_DWORD)result)
          return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 216) + 32))(*(_QWORD *)(a1 + 216));
      }
    }
  }
  return result;
}

uint64_t dcsctp::DcSctpSocketCallbacks::Now(dcsctp::DcSctpSocketCallbacks *this)
{
  return 1000 * (*(uint64_t (**)(dcsctp::DcSctpSocketCallbacks *))(*(_QWORD *)this + 48))(this);
}

void std::__function::__func<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_0,std::allocator<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_0>,dcsctp::TimeMs ()(void)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_0,std::allocator<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_0>,dcsctp::TimeMs ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C0B2B80;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_0,std::allocator<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_0>,dcsctp::TimeMs ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C0B2B80;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_0,std::allocator<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_0>,dcsctp::TimeMs ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 152))(*(_QWORD *)(a1 + 8));
}

void std::__function::__func<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_1,std::allocator<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_1>,void ()(webrtc::StrongAlias<dcsctp::TimeoutTag,unsigned long long>)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *std::__function::__func<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_1,std::allocator<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_1>,void ()(webrtc::StrongAlias<dcsctp::TimeoutTag,unsigned long long>)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24C0B2BC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_1,std::allocator<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_1>,void ()(webrtc::StrongAlias<dcsctp::TimeoutTag,unsigned long long>)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24C0B2BC8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_1,std::allocator<webrtc::DcSctpTransport::DcSctpTransport(webrtc::Environment const&,rtc::Thread *,rtc::PacketTransportInternal *,std::unique_ptr<dcsctp::DcSctpSocketFactory>)::$_1>,void ()(webrtc::StrongAlias<dcsctp::TimeoutTag,unsigned long long>)>::operator()(uint64_t a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 216) + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 216), *a2);
}

uint64_t sigslot::_opaque_connection::emitter<webrtc::DcSctpTransport,rtc::PacketTransportInternal *>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = a1[1];
  if (v3)
    v4 = v3 - 16;
  else
    v4 = 0;
  v5 = (_QWORD *)(v4 + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v5 + v1);
  return v1(v5);
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DcSctpTransport::ConnectTransportSignals(void)::$_1 &,rtc::PacketTransportInternal *,rtc::ReceivedPacket const&>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 44) == 1)
  {
    result = *(_QWORD *)(*(_QWORD *)result + 216);
    if (result)
      return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)result + 16))(result, *(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  }
  return result;
}

void absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DcSctpTransport::ConnectTransportSignals(void)::$_2 &&>(uint64_t a1)
{
  uint64_t v1;
  int v2;
  void *__p;
  uint64_t v4;
  _BYTE v5[16];

  v1 = *(_QWORD *)(*(_QWORD *)a1 + 336);
  if (v1)
  {
    v2 = 0;
    v5[14] = 0;
    v4 = 0;
    memset(v5, 0, 13);
    __p = 0;
    (*(void (**)(uint64_t, int *))(*(_QWORD *)v1 + 48))(v1, &v2);
    if ((v5[7] & 0x80000000) != 0)
      operator delete(__p);
  }
}

void webrtc::DebugDumpWriterImpl::~DebugDumpWriterImpl(webrtc::DebugDumpWriterImpl *this)
{
  FILE *v2;

  v2 = (FILE *)*((_QWORD *)this + 1);
  if (v2)
  {
    fclose(v2);
    *((_QWORD *)this + 1) = 0;
  }
}

{
  FILE *v2;

  v2 = (FILE *)*((_QWORD *)this + 1);
  if (v2)
  {
    fclose(v2);
    *((_QWORD *)this + 1) = 0;
  }
  JUMPOUT(0x20BD0ADECLL);
}

void **webrtc::Decimator::Decimator(void **this, void *a2)
{
  void **v3;
  char *v4;
  void *v5;
  char *v6;
  int v7;
  __int128 v8;
  _DWORD *v10;
  _DWORD *v11;
  char *v12;
  char *v13;

  *this = a2;
  v3 = this + 1;
  if (a2 == (void *)8)
  {
    v4 = (char *)operator new(0x78uLL);
    v5 = v4;
    v6 = v4 + 120;
    v13 = v4 + 120;
    *(_OWORD *)v4 = xmmword_208F089A0;
    *((_DWORD *)v4 + 4) = 1037275509;
    v4[20] = 1;
    *(_OWORD *)(v4 + 24) = xmmword_208F089A0;
    *((_DWORD *)v4 + 10) = 1037275509;
    v4[44] = 1;
    *((_OWORD *)v4 + 3) = xmmword_208F089A0;
    *((_DWORD *)v4 + 16) = 1037275509;
    v4[68] = 1;
    *(_OWORD *)(v4 + 72) = xmmword_208F089A0;
    *((_DWORD *)v4 + 22) = 1037275509;
    v4[92] = 1;
    *((_OWORD *)v4 + 6) = xmmword_208F089A0;
    *((_DWORD *)v4 + 28) = 1037275509;
    v4[116] = 1;
  }
  else
  {
    if (a2 == (void *)4)
    {
      v4 = (char *)operator new(0x48uLL);
      v5 = v4;
      v6 = v4 + 72;
      v13 = v4 + 72;
      *(_OWORD *)v4 = xmmword_208F089B0;
      v7 = 1048995664;
      *((_DWORD *)v4 + 4) = 1048995664;
      v4[20] = 0;
      *(_OWORD *)(v4 + 24) = xmmword_208F089C0;
      *((_DWORD *)v4 + 10) = 1048995664;
      v4[44] = 0;
      v8 = xmmword_208F089D0;
    }
    else
    {
      v4 = (char *)operator new(0x48uLL);
      v5 = v4;
      v6 = v4 + 72;
      v13 = v4 + 72;
      v8 = xmmword_208F089E0;
      *(_OWORD *)v4 = xmmword_208F089E0;
      v7 = 1047040413;
      *((_DWORD *)v4 + 4) = 1047040413;
      v4[20] = 0;
      *(_OWORD *)(v4 + 24) = xmmword_208F089E0;
      *((_DWORD *)v4 + 10) = 1047040413;
      v4[44] = 0;
    }
    *((_OWORD *)v4 + 3) = v8;
    *((_DWORD *)v4 + 16) = v7;
    v4[68] = 0;
  }
  v11 = v4;
  v12 = v6;
  webrtc::CascadedBiQuadFilter::CascadedBiQuadFilter(v3, (uint64_t *)&v11);
  operator delete(v5);
  if (*this == (void *)8)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    webrtc::CascadedBiQuadFilter::CascadedBiQuadFilter(this + 4, (uint64_t *)&v11);
  }
  else
  {
    v10 = operator new(0x18uLL);
    v12 = (char *)(v10 + 6);
    v13 = (char *)(v10 + 6);
    *(_OWORD *)v10 = xmmword_208F089F0;
    v10[4] = 1061277634;
    *((_BYTE *)v10 + 20) = 0;
    v11 = v10;
    webrtc::CascadedBiQuadFilter::CascadedBiQuadFilter(this + 4, (uint64_t *)&v11);
    operator delete(v10);
  }
  return this;
}

float **webrtc::Decimator::Decimate(_QWORD *a1, float *a2, uint64_t a3, float *a4, uint64_t a5)
{
  float **v8;
  float **result;
  float *v10;
  float *i;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float v27[64];

  v8 = (float **)(a1 + 1);
  if (!a3)
    a2 = 0;
  result = webrtc::CascadedBiQuadFilter::Process(v8, a2, a3, v27, (float **)0x40);
  v10 = (float *)a1[4];
  for (i = (float *)a1[5]; v10 != i; v10 += 9)
  {
    v12 = 0;
    v13 = *v10;
    v14 = v10[1];
    v16 = v10[7];
    v15 = v10[8];
    v17 = v10[5];
    v18 = v10[6];
    v19 = v10[2];
    v20 = -v10[3];
    v21 = -v10[4];
    do
    {
      v22 = v17;
      v23 = v15;
      v15 = v16;
      v17 = v27[v12];
      v16 = (float)((float)((float)((float)(v14 * v22) + (float)(v13 * v17)) + (float)(v19 * v18)) + (float)(v20 * v16))
          + (float)(v21 * v23);
      v27[v12++] = v16;
      v18 = v22;
    }
    while (v12 != 64);
    v10[5] = v17;
    v10[6] = v22;
    v10[7] = v16;
    v10[8] = v15;
  }
  if (a5)
  {
    v24 = 0;
    v25 = *a1;
    v26 = -*a1;
    while ((unint64_t)(v26 + v24 + v25) < 0x40)
    {
      *a4++ = v27[v24];
      v24 += v25;
      if (!--a5)
        return result;
    }
    __break(1u);
  }
  return result;
}

webrtc::DecisionLogic::Config *webrtc::DecisionLogic::Config::Config(webrtc::DecisionLogic::Config *this)
{
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  _QWORD *v6;
  uint64_t *v7;
  webrtc::DecisionLogic::Config *result;
  unint64_t v9;
  void **v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void **v19;
  unint64_t v20;
  unsigned __int8 v21;

  *(_WORD *)this = 257;
  v2 = (char *)this + 1;
  *(_QWORD *)((char *)this + 4) = 0x7D000000055;
  v3 = (char *)this + 4;
  v4 = (char *)this + 8;
  *((_DWORD *)this + 3) = 1000;
  v5 = (char *)this + 12;
  *((_BYTE *)this + 16) = 1;
  v6 = operator new(0xA0uLL);
  *v6 = "enable_stable_delay_mode";
  v6[1] = this;
  v6[2] = webrtc::struct_parser_impl::TypedParser<BOOL>::Parse;
  v6[3] = webrtc::struct_parser_impl::TypedParser<BOOL>::Encode;
  v6[4] = "combine_concealment_decision";
  v6[5] = v2;
  v6[6] = webrtc::struct_parser_impl::TypedParser<BOOL>::Parse;
  v6[7] = webrtc::struct_parser_impl::TypedParser<BOOL>::Encode;
  v6[8] = "packet_history_size_ms";
  v6[9] = v4;
  v6[10] = webrtc::struct_parser_impl::TypedParser<int>::Parse;
  v6[11] = webrtc::struct_parser_impl::TypedParser<int>::Encode;
  v6[12] = "cng_timeout_ms";
  v6[13] = v5;
  v6[14] = webrtc::struct_parser_impl::TypedParser<std::optional<int>>::Parse;
  v6[15] = webrtc::struct_parser_impl::TypedParser<std::optional<int>>::Encode;
  v6[16] = "deceleration_target_level_offset_ms";
  v6[17] = v3;
  v6[18] = webrtc::struct_parser_impl::TypedParser<int>::Parse;
  v6[19] = webrtc::struct_parser_impl::TypedParser<int>::Encode;
  v7 = (uint64_t *)operator new();
  *v7 = (uint64_t)v6;
  v7[1] = (uint64_t)(v6 + 20);
  v7[2] = (uint64_t)(v6 + 20);
  result = (webrtc::DecisionLogic::Config *)webrtc::field_trial::FindFullName((size_t)"WebRTC-Audio-NetEqDecisionLogicConfig", 0x25uLL, (size_t *)&v19);
  if ((char)v21 < 0)
  {
    v9 = v20;
    if ((v20 & 0x8000000000000000) != 0 || (v10 = v19, v20) && !v19)
    {
      __break(1u);
      return result;
    }
  }
  else
  {
    v9 = v21;
    v10 = (void **)&v19;
  }
  webrtc::StructParametersParser::Parse(v7, (uint64_t)v10, v9);
  if ((char)v21 < 0)
    operator delete(v19);
  v11 = (void *)*v7;
  if (*v7)
  {
    v7[1] = (uint64_t)v11;
    operator delete(v11);
  }
  MEMORY[0x20BD0ADEC](v7, 0x20C40960023A9);
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v12, v13, v14, v15, v16, v17, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/decision_logic.cc");
  return this;
}

uint64_t webrtc::DecisionLogic::DecisionLogic(uint64_t a1, char *a2)
{
  char v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  _QWORD *v10;
  _QWORD *v11;
  _BYTE v13[60];
  uint64_t v14;

  v4 = *a2;
  v5 = (_QWORD *)*((_QWORD *)a2 + 2);
  webrtc::DelayManager::Config::Config((webrtc::DelayManager::Config *)v13);
  v14 = *(_QWORD *)(a2 + 4);
  webrtc::DelayManager::Config::Log((webrtc::DelayManager::Config *)v13);
  v6 = operator new();
  webrtc::DelayManager::DelayManager(v6, (uint64_t)v13, *((_QWORD *)a2 + 2));
  v7 = (_QWORD *)operator new();
  *v7 = &unk_24C0B0430;
  v7[1] = 253;
  *(_QWORD *)a1 = &off_24C0B2CE0;
  webrtc::DecisionLogic::Config::Config((webrtc::DecisionLogic::Config *)(a1 + 8));
  *(_QWORD *)(a1 + 32) = v6;
  *(_QWORD *)(a1 + 40) = v7;
  v8 = operator new();
  v9 = *(_DWORD *)(a1 + 16);
  *(_QWORD *)v8 = &off_24C0B86F8;
  *(_QWORD *)(v8 + 8) = v5;
  *(_DWORD *)(v8 + 16) = v9;
  *(_DWORD *)(v8 + 20) = 0;
  *(_QWORD *)(v8 + 24) = 0;
  *(_BYTE *)(v8 + 32) = 0;
  *(_BYTE *)(v8 + 36) = 0;
  *(_QWORD *)(v8 + 56) = 0;
  *(_QWORD *)(v8 + 48) = 0;
  *(_QWORD *)(v8 + 40) = v8 + 48;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_OWORD *)(v8 + 144) = 0u;
  *(_QWORD *)(a1 + 48) = v8;
  *(_QWORD *)(a1 + 56) = v5;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 93) = 0;
  *(_BYTE *)(a1 + 101) = v4 ^ 1;
  v10 = (_QWORD *)operator new();
  v11 = (_QWORD *)operator new();
  *v11 = v5;
  v11[1] = *v5;
  *v10 = v11;
  v10[1] = 6;
  *(_QWORD *)(a1 + 104) = v10;
  *(_DWORD *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 116) = 0;
  return a1;
}

void webrtc::DecisionLogic::~DecisionLogic(webrtc::DecisionLogic *this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = &off_24C0B2CE0;
  v2 = (uint64_t *)*((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v2)
  {
    v3 = *v2;
    *v2 = 0;
    if (v3)
      MEMORY[0x20BD0ADEC](v3, 0x1060C40C2E02434);
    MEMORY[0x20BD0ADEC](v2, 0x1020C40EDED9539);
  }
  v4 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
}

{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = &off_24C0B2CE0;
  v2 = (uint64_t *)*((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v2)
  {
    v3 = *v2;
    *v2 = 0;
    if (v3)
      MEMORY[0x20BD0ADEC](v3, 0x1060C40C2E02434);
    MEMORY[0x20BD0ADEC](v2, 0x1020C40EDED9539);
  }
  v4 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::DecisionLogic::SoftReset(webrtc::DecisionLogic *this)
{
  uint64_t *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;

  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_BYTE *)this + 100) = 0;
  v2 = (uint64_t *)*((_QWORD *)this + 7);
  v3 = (_QWORD *)operator new();
  v4 = (_QWORD *)operator new();
  v5 = *v2;
  *v4 = v2;
  v4[1] = v5;
  *v3 = v4;
  v3[1] = 6;
  v6 = (uint64_t *)*((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = v3;
  if (v6)
  {
    v7 = *v6;
    *v6 = 0;
    if (v7)
      MEMORY[0x20BD0ADEC](v7, 0x1060C40C2E02434);
    MEMORY[0x20BD0ADEC](v6, 0x1020C40EDED9539);
  }
  *((_DWORD *)this + 28) = 0;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 4) + 24))(*((_QWORD *)this + 4));
  (*(void (**)(_QWORD))(**((_QWORD **)this + 5) + 16))(*((_QWORD *)this + 5));
  webrtc::PacketArrivalHistory::Reset(*((webrtc::PacketArrivalHistory **)this + 6));
}

uint64_t webrtc::DecisionLogic::SetSampleRate(uint64_t this, int a2, uint64_t a3)
{
  *(_DWORD *)(this + 64) = a2 / 1000;
  *(_QWORD *)(this + 72) = a3;
  *(_DWORD *)(*(_QWORD *)(this + 48) + 20) = a2 / 1000;
  return this;
}

uint64_t webrtc::DecisionLogic::GetDecision(uint64_t a1, int *a2, _BYTE *a3)
{
  unsigned int v6;
  BOOL v7;
  int v8;
  BOOL v9;
  uint64_t *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t result;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  int v30;
  int v31;
  unint64_t v32;
  unint64_t v33;
  int v34;
  unint64_t v35;
  BOOL v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  unsigned int v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _OWORD v50[6];
  _OWORD v51[6];
  _OWORD v52[6];
  _OWORD v53[6];
  _OWORD v54[6];

  if (!*(_BYTE *)(a1 + 100) || ((v6 = a2[7], v7 = v6 > 7, v8 = (1 << v6) & 0xD8, !v7) ? (v9 = v8 == 0) : (v9 = 1), v9))
  {
    *(_BYTE *)(a1 + 100) = 0;
    v16 = a2[7];
    if ((v16 - 9) < 2)
      goto LABEL_26;
  }
  else
  {
    *(_BYTE *)(a1 + 100) = 1;
    v10 = *(uint64_t **)(a1 + 56);
    v11 = (_QWORD *)operator new();
    v12 = (_QWORD *)operator new();
    v13 = *v10;
    *v12 = v10;
    v12[1] = v13;
    *v11 = v12;
    v11[1] = 5;
    v14 = *(uint64_t **)(a1 + 104);
    *(_QWORD *)(a1 + 104) = v11;
    if (v14)
    {
      v15 = *v14;
      *v14 = 0;
      if (v15)
        MEMORY[0x20BD0ADEC](v15, 0x1060C40C2E02434);
      MEMORY[0x20BD0ADEC](v14, 0x1020C40EDED9539);
    }
    v16 = a2[7];
    if ((v16 - 9) < 2)
      goto LABEL_26;
  }
  if (!*(_BYTE *)(a1 + 9) || (v16 != 1 ? (v17 = v16 == 11) : (v17 = 1), !v17))
  {
    v18 = *((_QWORD *)a2 + 8);
    v19 = *(_QWORD *)(a1 + 40);
    v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v19 + 40))(v19, v20);
    v21 = *(unsigned int *)(a1 + 112);
    if (*(_BYTE *)(a1 + 100))
      v21 = (*(_DWORD *)(a1 + 96) + v21);
    v22 = *(_QWORD *)(a1 + 40);
    if (*(_BYTE *)(a1 + 116))
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v22 + 32))(v22, v18, v21);
      *(_BYTE *)(a1 + 116) = 0;
      *(_BYTE *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 112) = 0;
      v16 = a2[7];
      if (v16 == 13)
        goto LABEL_22;
    }
    else
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v22 + 24))(v22, v18, v21);
      *(_BYTE *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 112) = 0;
      v16 = a2[7];
      if (v16 == 13)
      {
LABEL_22:
        if (*((_BYTE *)a2 + 24))
          return 10;
        else
          return 2;
      }
    }
  }
LABEL_26:
  if (!*((_BYTE *)a2 + 24))
  {
    v27 = *((_OWORD *)a2 + 3);
    v53[2] = *((_OWORD *)a2 + 2);
    v53[3] = v27;
    v28 = *((_OWORD *)a2 + 5);
    v53[4] = *((_OWORD *)a2 + 4);
    v53[5] = v28;
    v29 = *((_OWORD *)a2 + 1);
    v53[0] = *(_OWORD *)a2;
    v53[1] = v29;
    return (*(uint64_t (**)(uint64_t, _OWORD *))(*(_QWORD *)a1 + 200))(a1, v53);
  }
  if (*((_BYTE *)a2 + 21))
  {
    v24 = *((_OWORD *)a2 + 3);
    v54[2] = *((_OWORD *)a2 + 2);
    v54[3] = v24;
    v25 = *((_OWORD *)a2 + 5);
    v54[4] = *((_OWORD *)a2 + 4);
    v54[5] = v25;
    v26 = *((_OWORD *)a2 + 1);
    v54[0] = *(_OWORD *)a2;
    v54[1] = v26;
    return (*(uint64_t (**)(uint64_t, _OWORD *))(*(_QWORD *)a1 + 192))(a1, v54);
  }
  if (!*(_BYTE *)(a1 + 9)
    && (v16 == 11 || v16 == 1)
    && *((_QWORD *)a2 + 5) > (unint64_t)(1000 * *(int *)(a1 + 64)))
  {
    result = 0;
    *a3 = 1;
    return result;
  }
  v30 = *((__int16 *)a2 + 2);
  v31 = *((unsigned __int8 *)a2 + 48);
  v32 = *((_QWORD *)a2 + 8);
  v33 = *((_QWORD *)a2 + 9);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1);
  v34 = *(_DWORD *)(a1 + 64);
  if (*(_BYTE *)(a1 + 9))
    v35 = v33;
  else
    v35 = v32;
  v36 = v35 < v34 * (int)result / 2 && v31 == 0;
  if (v36 && ((v16 - 9) <= 1 && *(_BYTE *)(a1 + 9) || (v16 == 11 || v16 == 1) && v30 < 0x2000))
  {
    v43 = *((_OWORD *)a2 + 3);
    v52[2] = *((_OWORD *)a2 + 2);
    v52[3] = v43;
    v44 = *((_OWORD *)a2 + 5);
    v52[4] = *((_OWORD *)a2 + 4);
    v52[5] = v44;
    v45 = *((_OWORD *)a2 + 1);
    v52[0] = *(_OWORD *)a2;
    v52[1] = v45;
    return (*(uint64_t (**)(uint64_t, _OWORD *))(*(_QWORD *)a1 + 200))(a1, v52);
  }
  if (*((_BYTE *)a2 + 24))
  {
    v37 = *a2;
    v38 = a2[4];
    v39 = *a2 - v38;
    if (*a2 == v38)
    {
      v40 = *((_OWORD *)a2 + 3);
      v51[2] = *((_OWORD *)a2 + 2);
      v51[3] = v40;
      v41 = *((_OWORD *)a2 + 5);
      v51[4] = *((_OWORD *)a2 + 4);
      v51[5] = v41;
      v42 = *((_OWORD *)a2 + 1);
      v51[0] = *(_OWORD *)a2;
      v51[1] = v42;
      return (*(uint64_t (**)(uint64_t, _OWORD *))(*(_QWORD *)a1 + 208))(a1, v51);
    }
    if (v39 == 0x80000000)
    {
      if (v37 <= v38)
        goto LABEL_62;
    }
    else if ((v39 & 0x80000000) != 0)
    {
LABEL_62:
      v47 = *((_OWORD *)a2 + 3);
      v50[2] = *((_OWORD *)a2 + 2);
      v50[3] = v47;
      v48 = *((_OWORD *)a2 + 5);
      v50[4] = *((_OWORD *)a2 + 4);
      v50[5] = v48;
      v49 = *((_OWORD *)a2 + 1);
      v50[0] = *(_OWORD *)a2;
      v50[1] = v49;
      return (*(uint64_t (**)(uint64_t, _OWORD *))(*(_QWORD *)a1 + 216))(a1, v50);
    }
    if (v34)
    {
      v46 = v37 - 5000 * v34;
      if (v38 - v46 == 0x80000000)
      {
        if (v38 <= v46)
          goto LABEL_62;
      }
      else if (v38 == v46 || ((v38 - v46) & 0x80000000) != 0)
      {
        goto LABEL_62;
      }
    }
    return 10;
  }
  __break(1u);
  return result;
}

uint64_t webrtc::DecisionLogic::TargetLevelMs(webrtc::DecisionLogic *this)
{
  uint64_t result;
  unint64_t v3;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 32))(*((_QWORD *)this + 4));
  if (!*((_BYTE *)this + 8))
  {
    v3 = *((_QWORD *)this + 11) / (unint64_t)*((int *)this + 16);
    if ((int)result <= (int)v3)
      return v3;
    else
      return result;
  }
  return result;
}

uint64_t webrtc::DecisionLogic::UnlimitedTargetLevelMs(webrtc::DecisionLogic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 40))(*((_QWORD *)this + 4));
}

uint64_t webrtc::DecisionLogic::GetFilteredBufferLevel(webrtc::DecisionLogic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 5) + 48))(*((_QWORD *)this + 5));
}

uint64_t webrtc::DecisionLogic::PacketArrived(uint64_t a1, int a2, int a3, uint64_t *a4)
{
  uint64_t v6;
  int v7;
  _QWORD *v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  uint64_t v15;
  _BOOL4 v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  BOOL v21;
  _BOOL8 v22;

  *(_BYTE *)(a1 + 116) = (*(unsigned __int8 *)(a1 + 116) | *((unsigned __int8 *)a4 + 16)) != 0;
  if (!a3)
    return 0;
  if (*((_BYTE *)a4 + 14))
    return 0;
  v6 = *a4;
  if (a2 >= 1 && v6 && v6 != *(_QWORD *)(a1 + 88))
  {
    *(_QWORD *)(a1 + 88) = v6;
    (*(void (**)(_QWORD, unint64_t))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32), 1000 * v6 / (unint64_t)a2);
    v6 = *a4;
  }
  webrtc::PacketArrivalHistory::Insert(*(webrtc::PacketArrivalHistory **)(a1 + 48), *((_DWORD *)a4 + 2), v6);
  if (!v7)
    return 0;
  v8 = *(_QWORD **)(a1 + 48);
  if (v8[7] < 2uLL)
    return 0;
  v10 = (*(uint64_t (**)(_QWORD *, _QWORD))(*v8 + 16))(v8, *((unsigned int *)a4 + 2));
  v11 = *(_QWORD *)(a1 + 48);
  if (*(_QWORD *)(v11 + 56))
  {
    v12 = *((unsigned int *)a4 + 2);
    if (*(_BYTE *)(v11 + 36))
    {
      v13 = *(_DWORD *)(v11 + 32);
      v14 = v12 >= v13;
      v15 = v12 - v13;
      v16 = (_DWORD)v15 != 0 && v14;
      if ((_DWORD)v15 != 0x80000000)
        v16 = (int)v15 >= 0;
      if (!v16)
        v15 |= 0xFFFFFFFF00000000;
      v12 = v15 + *(_QWORD *)(v11 + 24);
    }
    v19 = *(_QWORD **)(v11 + 48);
    v17 = (_QWORD *)(v11 + 48);
    v18 = v19;
    if (v19)
    {
      do
      {
        v20 = v18;
        v18 = (_QWORD *)v18[1];
      }
      while (v18);
    }
    else
    {
      do
      {
        v20 = (_QWORD *)v17[2];
        v21 = *v20 == (_QWORD)v17;
        v17 = v20;
      }
      while (v21);
    }
    v22 = v12 != v20[5];
  }
  else
  {
    v22 = 0;
  }
  (*(void (**)(_QWORD, uint64_t, _BOOL8))(**(_QWORD **)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), v10, v22);
  return v10 | 0x100000000;
}

uint64_t webrtc::DecisionLogic::CngOperation(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  if (*(_BYTE *)(a2 + 24))
  {
    v3 = result;
    v4 = *(_DWORD *)a2 + *(_DWORD *)(a2 + 40) - *(_DWORD *)(a2 + 16);
    v5 = *(int *)(result + 64) * (uint64_t)(*(int (**)(uint64_t))(*(_QWORD *)result + 104))(result);
    v6 = v4 + v5;
    if ((int)v5 >= 0)
      v7 = v5;
    else
      v7 = v5 + 1;
    if (-v6 > v7 >> 1)
    {
      *(_QWORD *)(v3 + 80) -= v6;
      if ((_DWORD)v5 == 0x80000000)
      {
LABEL_11:
        *(_QWORD *)(v3 + 80) = 0;
        return 6;
      }
      v4 = -(int)v5;
    }
    if (v4 < 0 && *(_DWORD *)(a2 + 28) == 9)
      return 7;
    goto LABEL_11;
  }
  __break(1u);
  return result;
}

uint64_t webrtc::DecisionLogic::NoPacket(uint64_t a1, uint64_t a2)
{
  int v2;

  v2 = *(_DWORD *)(a2 + 28);
  if (v2 == 9)
    return 7;
  if (v2 == 10)
  {
    if (*(_BYTE *)(a1 + 24)
      && *(_QWORD *)(a2 + 40) > (unint64_t)(*(int *)(a1 + 64) * (uint64_t)*(int *)(a1 + 20)))
    {
      return 2;
    }
    else
    {
      return 8;
    }
  }
  else if (*(_BYTE *)(a2 + 32))
  {
    return 9;
  }
  else
  {
    return 2;
  }
}

uint64_t webrtc::DecisionLogic::ExpectedPacketAvailable(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t v6;
  _QWORD *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  _QWORD *v15;

  if (*(_BYTE *)(a1 + 101) || *(_DWORD *)(a2 + 28) == 1 || *(_BYTE *)(a2 + 32))
    return 0;
  if (!*(_BYTE *)(a1 + 8))
  {
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1);
    v9 = *(_DWORD *)(a1 + 64);
    v10 = v9 * v8;
    if (3 * v9 * v8 / 4 <= (v8 - *(_DWORD *)(a1 + 12)) * v9)
      v11 = (v8 - *(_DWORD *)(a1 + 12)) * v9;
    else
      v11 = 3 * v9 * v8 / 4;
    v12 = v11 + 20 * v9;
    if (v10 <= v12)
      v13 = v12;
    else
      v13 = v10;
    v14 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 48))(*(_QWORD *)(a1 + 40));
    if (v14 < 4 * v13)
    {
      v15 = *(_QWORD **)(a1 + 104);
      if (v15 && **(_QWORD **)*v15 - *(_QWORD *)(*v15 + 8) < v15[1])
        return 0;
      if (v14 < v13)
      {
        if (v14 >= v11)
          return 0;
        return 5;
      }
      return 3;
    }
    return 4;
  }
  v4 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), (*(_DWORD *)a2 - *(_DWORD *)(a2 + 88)));
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1);
  v6 = v5 + (uint64_t)(*(int (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 24))(*(_QWORD *)(a1 + 48)) + 20;
  if (v4 >= 4 * v6)
    return 4;
  v7 = *(_QWORD **)(a1 + 104);
  if (v7 && **(_QWORD **)*v7 - *(_QWORD *)(*v7 + 8) < v7[1])
    return 0;
  if (v6 > v4)
  {
    if (v4 >= v5)
      return 0;
    return 5;
  }
  return 3;
}

uint64_t webrtc::DecisionLogic::FuturePacketAvailable(uint64_t result, uint64_t a2)
{
  _DWORD *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  unsigned int v17;
  int v18;
  unint64_t v19;
  signed int v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _OWORD v24[6];
  _OWORD v25[6];

  v3 = (_DWORD *)result;
  if (!*(_BYTE *)(result + 9))
  {
    v4 = *(_DWORD *)(a2 + 28);
    if ((v4 - 9) > 1)
    {
      if (v4 != 11 && v4 != 1)
        goto LABEL_31;
      if (*(_BYTE *)(a2 + 24))
      {
        v17 = *(_DWORD *)(a2 + 16) - *(_DWORD *)a2;
        v18 = *(_DWORD *)(result + 64);
        if (v17 < 1000 * v18)
        {
          v19 = *(_QWORD *)(a2 + 40);
          if (v19 < v17 && v19 < 100 * v18)
          {
            v20 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(result + 40) + 48))(*(_QWORD *)(result + 40));
            if (v20 < (int)(v3[16] * (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v3 + 104))(v3)))
            {
              v21 = *(_OWORD *)(a2 + 48);
              v24[2] = *(_OWORD *)(a2 + 32);
              v24[3] = v21;
              v22 = *(_OWORD *)(a2 + 80);
              v24[4] = *(_OWORD *)(a2 + 64);
              v24[5] = v22;
              v23 = *(_OWORD *)(a2 + 16);
              v24[0] = *(_OWORD *)a2;
              v24[1] = v23;
              return (*(uint64_t (**)(_DWORD *, _OWORD *))(*(_QWORD *)v3 + 200))(v3, v24);
            }
          }
        }
        goto LABEL_31;
      }
LABEL_37:
      __break(1u);
      return result;
    }
  }
  v5 = 72;
  if (!*(_BYTE *)(result + 9))
    v5 = 64;
  v6 = *(unsigned int *)(a2 + v5);
  v7 = *(_DWORD *)(result + 64);
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 104))(result);
  result = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v3 + 104))(v3);
  if ((int)result <= 50)
    v9 = 50;
  else
    v9 = result;
  if (!*(_BYTE *)(a2 + 24))
    goto LABEL_37;
  v10 = *(_QWORD *)(a2 + 40);
  v11 = (*(_DWORD *)(a2 + 16) - *(_DWORD *)a2);
  v12 = (int)v6 / v7;
  if (v10 < v11 && v12 <= v8 + 50)
    goto LABEL_11;
  if (v12 < v9 - 50)
  {
    if (!*((_BYTE *)v3 + 9))
    {
LABEL_11:
      v13 = *(_OWORD *)(a2 + 48);
      v25[2] = *(_OWORD *)(a2 + 32);
      v25[3] = v13;
      v14 = *(_OWORD *)(a2 + 80);
      v25[4] = *(_OWORD *)(a2 + 64);
      v25[5] = v14;
      v15 = *(_OWORD *)(a2 + 16);
      v25[0] = *(_OWORD *)a2;
      v25[1] = v15;
      return (*(uint64_t (**)(_DWORD *, _OWORD *))(*(_QWORD *)v3 + 200))(v3, v25);
    }
    goto LABEL_17;
  }
  if (*((_BYTE *)v3 + 9))
  {
LABEL_17:
    if (v10 != v11)
      (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)v3 + 5) + 32))(*((_QWORD *)v3 + 5), v6);
    goto LABEL_31;
  }
  v3[28] = v11 - v10;
LABEL_31:
  result = *(unsigned int *)(a2 + 28);
  if ((result - 9) < 3)
    return 0;
  if ((_DWORD)result != 1)
  {
    if (*(_BYTE *)(a2 + 32))
      return 9;
    else
      return 2;
  }
  return result;
}

uint64_t webrtc::DecisionLogic::SetMaximumDelay(webrtc::DecisionLogic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4));
}

uint64_t webrtc::DecisionLogic::SetMinimumDelay(webrtc::DecisionLogic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 56))(*((_QWORD *)this + 4));
}

uint64_t webrtc::DecisionLogic::SetBaseMinimumDelay(webrtc::DecisionLogic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 72))(*((_QWORD *)this + 4));
}

uint64_t webrtc::DecisionLogic::GetBaseMinimumDelay(webrtc::DecisionLogic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 80))(*((_QWORD *)this + 4));
}

uint64_t webrtc::DecisionLogic::AddSampleMemory(uint64_t this, int a2)
{
  *(_DWORD *)(this + 96) += a2;
  return this;
}

uint64_t webrtc::DecisionLogic::PeakFound(webrtc::DecisionLogic *this)
{
  return 0;
}

uint64_t webrtc::DecisionLogic::set_sample_memory(uint64_t this, int a2)
{
  *(_DWORD *)(this + 96) = a2;
  return this;
}

uint64_t webrtc::DecisionLogic::noise_fast_forward(webrtc::DecisionLogic *this)
{
  return *((_QWORD *)this + 10);
}

uint64_t webrtc::DecisionLogic::packet_length_samples(webrtc::DecisionLogic *this)
{
  return *((_QWORD *)this + 11);
}

uint64_t webrtc::DecisionLogic::set_packet_length_samples(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 88) = a2;
  return this;
}

uint64_t webrtc::DecisionLogic::set_prev_time_scale(uint64_t this, char a2)
{
  *(_BYTE *)(this + 100) = a2;
  return this;
}

void webrtc::DecodeSynchronizer::SynchronizedFrameDecodeScheduler::~SynchronizedFrameDecodeScheduler(void (**this)(uint64_t, char *, char *))
{
  *this = (void (*)(uint64_t, char *, char *))&off_24C0B2DD0;
  if (*((_BYTE *)this + 72))
    this[7](1, (char *)this + 40, (char *)this + 40);
}

{
  *this = (void (*)(uint64_t, char *, char *))&off_24C0B2DD0;
  if (*((_BYTE *)this + 72))
    this[7](1, (char *)this + 40, (char *)this + 40);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::DecodeSynchronizer::SynchronizedFrameDecodeScheduler::ScheduledRtpTimestamp(webrtc::DecodeSynchronizer::SynchronizedFrameDecodeScheduler *this)
{
  if (*((_BYTE *)this + 72))
    return *((unsigned int *)this + 4) | 0x100000000;
  else
    return 0;
}

uint64_t webrtc::DecodeSynchronizer::SynchronizedFrameDecodeScheduler::ScheduleFrame(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void (*v10)(_QWORD, _BYTE *, _BYTE *);
  void (*v11)(_QWORD, _BYTE *, uint64_t);
  int v12;
  _QWORD *v13;
  uint64_t result;
  uint64_t v15;
  unint64_t v16;
  uint64_t v18;
  BOOL v19;
  unint64_t v20;
  uint64_t v21;
  __int128 v22;
  void (*v23)(_BYTE *, _QWORD, uint64_t *);
  _BYTE v24[16];
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  _BYTE v28[16];
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  _BYTE v32[16];
  __int128 v33;
  uint64_t v34;

  (*(void (**)(_QWORD, uint64_t, _BYTE *))(a5 + 16))(0, a5, v24);
  v25 = *(_OWORD *)(a5 + 16);
  v10 = (void (*)(_QWORD, _BYTE *, _BYTE *))v25;
  *(_QWORD *)(a5 + 16) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(a5 + 24) = 0;
  LODWORD(v30) = a2;
  *((_QWORD *)&v30 + 1) = a3;
  v31 = a4;
  v10(0, v24, v32);
  v11 = (void (*)(_QWORD, _BYTE *, uint64_t))v25;
  v33 = v25;
  v25 = (unint64_t)absl::internal_any_invocable::EmptyManager;
  v12 = *(unsigned __int8 *)(a1 + 72);
  *(_OWORD *)(a1 + 16) = v30;
  *(_QWORD *)(a1 + 32) = v31;
  if (v12)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 56))(1, a1 + 40, a1 + 40);
    *(_QWORD *)(a1 + 56) = absl::internal_any_invocable::EmptyManager;
    *(_QWORD *)(a1 + 64) = 0;
    ((void (*)(_QWORD, _BYTE *, uint64_t))v33)(0, v32, a1 + 40);
    *(_OWORD *)(a1 + 56) = v33;
  }
  else
  {
    v11(0, v32, a1 + 40);
    *(_OWORD *)(a1 + 56) = v33;
    *(_BYTE *)(a1 + 72) = 1;
  }
  *(_QWORD *)&v33 = absl::internal_any_invocable::EmptyManager;
  *((_QWORD *)&v33 + 1) = 0;
  ((void (*)(uint64_t, _BYTE *, _BYTE *))v25)(1, v24, v24);
  v13 = *(_QWORD **)(a1 + 8);
  result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v13 + 16))(*v13);
  v15 = result;
  v16 = v13[3];
  if (v16 - 0x7FFFFFFFFFFFFFFFLL <= 1)
  {
    result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v13[2] + 24))(v13[2]);
    if (v15 == 0x7FFFFFFFFFFFFFFFLL || result == 0x7FFFFFFFFFFFFFFFLL)
    {
      if (*(_BYTE *)(a1 + 72))
      {
        v18 = *(_QWORD *)(a1 + 24);
        if (v18 == 0x7FFFFFFFFFFFFFFFLL)
          goto LABEL_25;
        goto LABEL_26;
      }
LABEL_30:
      __break(1u);
      return result;
    }
    v19 = result == 0x8000000000000000 || v15 == 0x8000000000000000;
    v16 = result + v15;
    if (v19)
      v16 = 0x8000000000000000;
  }
  if (!*(_BYTE *)(a1 + 72))
    goto LABEL_30;
  v18 = *(_QWORD *)(a1 + 24);
  v20 = v16 - 5000;
  if (v16 == 0x8000000000000000)
    v20 = 0x8000000000000000;
  if (v16 == 0x7FFFFFFFFFFFFFFFLL)
    v21 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v21 = v20;
  if (v18 >= v21)
  {
LABEL_25:
    if (v18 >= v15)
      return result;
  }
LABEL_26:
  v26 = *(_OWORD *)(a1 + 16);
  v27 = *(_QWORD *)(a1 + 32);
  (*(void (**)(_QWORD, uint64_t, _BYTE *))(a1 + 56))(0, a1 + 40, v28);
  v22 = *(_OWORD *)(a1 + 56);
  v29 = v22;
  *(_QWORD *)(a1 + 56) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(a1 + 64) = 0;
  if (*(_BYTE *)(a1 + 72))
    *(_BYTE *)(a1 + 72) = 0;
  v30 = v26;
  v31 = v27;
  ((void (*)(_QWORD, _BYTE *, _BYTE *))v22)(0, v28, v32);
  v23 = (void (*)(_BYTE *, _QWORD, uint64_t *))*((_QWORD *)&v29 + 1);
  v33 = v29;
  v29 = (unint64_t)absl::internal_any_invocable::EmptyManager;
  v34 = v31;
  v23(v32, v30, &v34);
  ((void (*)(uint64_t, _BYTE *, _BYTE *))v33)(1, v32, v32);
  return ((uint64_t (*)(uint64_t, _BYTE *, _BYTE *))v29)(1, v28, v28);
}

uint64_t webrtc::DecodeSynchronizer::SynchronizedFrameDecodeScheduler::CancelOutstanding(uint64_t this)
{
  uint64_t v1;

  if (*(_BYTE *)(this + 72))
  {
    v1 = this;
    this = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(this + 56))(1, this + 40, this + 40);
    *(_BYTE *)(v1 + 72) = 0;
  }
  return this;
}

void webrtc::DecodeSynchronizer::SynchronizedFrameDecodeScheduler::Stop(webrtc::DecodeSynchronizer::SynchronizedFrameDecodeScheduler *this)
{
  _QWORD *v2;
  uint64_t *v3;
  uint64_t *v4;
  _QWORD *v5;
  unint64_t v6;
  BOOL v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  BOOL v12;

  if (!*((_BYTE *)this + 80))
  {
    (*(void (**)(webrtc::DecodeSynchronizer::SynchronizedFrameDecodeScheduler *))(*(_QWORD *)this + 32))(this);
    *((_BYTE *)this + 80) = 1;
    v2 = (_QWORD *)*((_QWORD *)this + 1);
    v3 = (uint64_t *)v2[5];
    if (v3)
    {
      v4 = v2 + 5;
      v5 = (_QWORD *)v2[5];
      do
      {
        v6 = v5[4];
        v7 = v6 >= (unint64_t)this;
        if (v6 >= (unint64_t)this)
          v8 = v5;
        else
          v8 = v5 + 1;
        if (v7)
          v4 = v5;
        v5 = (_QWORD *)*v8;
      }
      while (*v8);
      if (v4 != v2 + 5 && v4[4] <= (unint64_t)this)
      {
        v9 = (uint64_t *)v4[1];
        if (v9)
        {
          do
          {
            v10 = v9;
            v9 = (uint64_t *)*v9;
          }
          while (v9);
        }
        else
        {
          v11 = v4;
          do
          {
            v10 = (uint64_t *)v11[2];
            v12 = *v10 == (_QWORD)v11;
            v11 = v10;
          }
          while (!v12);
        }
        if ((uint64_t *)v2[4] == v4)
          v2[4] = v10;
        --v2[6];
        std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v3, v4);
        operator delete(v4);
        if (!v2[6])
          v2[3] = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
  }
}

unint64_t webrtc::DecodeSynchronizer::CreateSynchronizedFrameScheduler@<X0>(webrtc::DecodeSynchronizer *this@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result;
  unint64_t v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  _QWORD *v17;
  _QWORD v18[2];
  uint64_t (*v19)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v20)(uint64_t);

  result = operator new();
  v5 = result;
  *(_QWORD *)result = &off_24C0B2DD0;
  *(_QWORD *)(result + 8) = this;
  *(_BYTE *)(result + 16) = 0;
  *(_BYTE *)(result + 72) = 0;
  *(_BYTE *)(result + 80) = 0;
  v7 = (uint64_t **)((char *)this + 40);
  v6 = (uint64_t *)*((_QWORD *)this + 5);
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v6;
        v9 = v6[4];
        if (result >= v9)
          break;
        v6 = *v8;
        v7 = v8;
        if (!*v8)
          goto LABEL_8;
      }
      if (v9 >= result)
        break;
      v6 = v8[1];
      if (!v6)
      {
        v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    v8 = (uint64_t **)((char *)this + 40);
LABEL_8:
    v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = v5;
    *v10 = 0;
    v10[1] = 0;
    v10[2] = (uint64_t)v8;
    *v7 = v10;
    v11 = **((_QWORD **)this + 4);
    if (v11)
    {
      *((_QWORD *)this + 4) = v11;
      result = (unint64_t)std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 5), *v7);
      v12 = *((_QWORD *)this + 6);
      *((_QWORD *)this + 6) = v12 + 1;
      if (v12)
        goto LABEL_16;
    }
    else
    {
      result = (unint64_t)std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 5), v10);
      v13 = *((_QWORD *)this + 6);
      *((_QWORD *)this + 6) = v13 + 1;
      if (v13)
        goto LABEL_16;
    }
    if (!*((_BYTE *)this + 56))
    {
      *((_BYTE *)this + 56) = 1;
      v14 = *((_QWORD *)this + 2);
      v15 = (unsigned int *)*((_QWORD *)this + 8);
      if (v15)
      {
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
      v17 = (_QWORD *)operator new();
      *v17 = v15;
      v17[1] = this;
      v17[3] = absl::internal_any_invocable::LocalManagerTrivial;
      v17[4] = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DecodeSynchronizer::ScheduleNextTick(void)::$_1 &&>;
      v18[0] = v17;
      v19 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
      v20 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v14 + 16))(v14, v18);
      result = v19(1, v18, v18);
    }
  }
LABEL_16:
  *a2 = v5;
  return result;
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DecodeSynchronizer::ScheduleNextTick(void)::$_1 &&>(_QWORD **a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t result;
  unint64_t v4;
  BOOL v5;
  _QWORD *v7;
  uint64_t v8;
  __int128 v9;
  void (*v10)(_QWORD *, _QWORD, uint64_t (**)(uint64_t, uint64_t *, _QWORD *));
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  _QWORD *v16;
  __int128 v17;
  uint64_t (*v18)(uint64_t, uint64_t *, _QWORD *);
  _BYTE v19[16];
  __int128 v20;
  __int128 v21;
  uint64_t (*v22)(uint64_t, uint64_t *, _QWORD *);
  _QWORD v23[2];
  __int128 v24;
  uint64_t (*v25)(uint64_t, uint64_t *, _QWORD *);

  v1 = *a1;
  *((_BYTE *)v1 + 56) = 0;
  v2 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 16))(*v1);
  result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v1[2] + 24))(v1[2]);
  v4 = 0x7FFFFFFFFFFFFFFFLL;
  v5 = v2 == 0x7FFFFFFFFFFFFFFFLL || result == 0x7FFFFFFFFFFFFFFFLL;
  if (!v5)
  {
    v4 = 0x8000000000000000;
    if (result != 0x8000000000000000 && v2 != 0x8000000000000000)
      v4 = result + v2;
  }
  v1[3] = v4;
  v7 = (_QWORD *)v1[4];
  if (v7 != v1 + 5)
  {
    do
    {
      v8 = v7[4];
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
      if ((result & 0xFF00000000) != 0)
      {
        if (!*(_BYTE *)(v8 + 72))
        {
          __break(1u);
          return result;
        }
        if (*(_QWORD *)(v8 + 24) < v1[3])
        {
          v17 = *(_OWORD *)(v8 + 16);
          v18 = *(uint64_t (**)(uint64_t, uint64_t *, _QWORD *))(v8 + 32);
          (*(void (**)(_QWORD, uint64_t, _BYTE *))(v8 + 56))(0, v8 + 40, v19);
          v9 = *(_OWORD *)(v8 + 56);
          v20 = v9;
          *(_QWORD *)(v8 + 56) = absl::internal_any_invocable::EmptyManager;
          *(_QWORD *)(v8 + 64) = 0;
          if (*(_BYTE *)(v8 + 72))
            *(_BYTE *)(v8 + 72) = 0;
          v21 = v17;
          v22 = v18;
          ((void (*)(_QWORD, _BYTE *, _QWORD *))v9)(0, v19, v23);
          v10 = (void (*)(_QWORD *, _QWORD, uint64_t (**)(uint64_t, uint64_t *, _QWORD *)))*((_QWORD *)&v20 + 1);
          v24 = v20;
          v20 = (unint64_t)absl::internal_any_invocable::EmptyManager;
          v25 = v22;
          v10(v23, v21, &v25);
          ((void (*)(uint64_t, _QWORD *, _QWORD *))v24)(1, v23, v23);
          result = ((uint64_t (*)(uint64_t, _BYTE *, _BYTE *))v20)(1, v19, v19);
        }
      }
      v11 = (_QWORD *)v7[1];
      if (v11)
      {
        do
        {
          v12 = v11;
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          v12 = (_QWORD *)v7[2];
          v5 = *v12 == (_QWORD)v7;
          v7 = v12;
        }
        while (!v5);
      }
      v7 = v12;
    }
    while (v12 != v1 + 5);
  }
  if (v1[6] && !*((_BYTE *)v1 + 56))
  {
    *((_BYTE *)v1 + 56) = 1;
    v13 = v1[2];
    v14 = (unsigned int *)v1[8];
    if (v14)
    {
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v16 = (_QWORD *)operator new();
    *v16 = v14;
    v16[1] = v1;
    v16[3] = absl::internal_any_invocable::LocalManagerTrivial;
    v16[4] = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DecodeSynchronizer::ScheduleNextTick(void)::$_1 &&>;
    *(_QWORD *)&v21 = v16;
    v22 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
    v23[0] = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
    (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v13 + 16))(v13, &v21);
    return v22(1, (uint64_t *)&v21, &v21);
  }
  return result;
}

void webrtc::DecodeTimePercentileFilter::AddTiming(webrtc::DecodeTimePercentileFilter *this, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  void *v29;
  unint64_t v30;
  char *v31;
  char *v32;
  char *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  char *v41;
  unint64_t v42;
  unint64_t v43;
  BOOL v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  char *v57;
  int64_t v58;
  unint64_t v59;
  char *v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  __int128 *v64;
  char *v65;
  uint64_t v66;
  __int128 v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  unint64_t v75;
  uint64_t v76;
  __int128 *v77;
  _OWORD *v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  char *v87;
  char *v88;
  uint64_t v89;
  __int128 *v90;
  _OWORD *v91;
  uint64_t v92;
  __int128 v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  char *v98;
  char *v99;
  uint64_t v100;
  unint64_t v101;
  __int128 *v102;
  _OWORD *v103;
  uint64_t v104;
  __int128 v105;
  unint64_t v106;
  unint64_t v107;
  char *v108;
  uint64_t v109;

  v109 = a2;
  if (*(int *)this <= 4)
  {
    ++*(_DWORD *)this;
    return;
  }
  v7 = (char *)this + 56;
  v8 = (char *)webrtc::PercentileFilter<long long>::Insert((uint64_t)this + 56, &v109);
  v10 = (char *)*((_QWORD *)this + 2);
  v9 = *((_QWORD *)this + 3);
  v11 = v9 - (_QWORD)v10;
  if ((char *)v9 == v10)
    v12 = 0;
  else
    v12 = 32 * (v9 - (_QWORD)v10) - 1;
  v13 = *((_QWORD *)this + 5);
  v14 = (char *)*((_QWORD *)this + 6);
  v15 = (unint64_t)&v14[v13];
  if ((char *)v12 != &v14[v13])
    goto LABEL_18;
  v16 = v13 >= 0x100;
  v17 = v13 - 256;
  if (!v16)
  {
    v19 = v11 >> 3;
    v20 = *((_QWORD *)this + 4);
    v4 = *((_QWORD *)this + 1);
    if (v11 >> 3 < (unint64_t)((v20 - v4) >> 3))
    {
      v8 = (char *)operator new(0x1000uLL);
      v3 = (unint64_t)v8;
      if (v20 != v9)
      {
        if (!v9)
          goto LABEL_117;
        *(_QWORD *)v9 = v8;
        goto LABEL_16;
      }
      v108 = (char *)this + 56;
      if (v10 == (char *)v4)
      {
        v69 = (v20 - (uint64_t)v10) >> 2;
        if ((char *)v9 == v10)
          v69 = 1;
        if (v69 >> 61)
          goto LABEL_125;
        v70 = (v69 + 3) >> 2;
        v71 = 8 * v69;
        v8 = (char *)operator new(8 * v69);
        v41 = &v8[8 * v70];
        v14 = &v8[v71];
        v72 = v41;
        if ((char *)v9 != v10)
        {
          v72 = &v41[8 * v19];
          v15 = (unint64_t)&v8[8 * v70];
          v73 = v10;
          if ((unint64_t)(v11 - 8) < 0x38)
            goto LABEL_128;
          v74 = &v8[8 * v70];
          v15 = (unint64_t)v74;
          v73 = v10;
          if ((unint64_t)(v74 - v10) < 0x20)
            goto LABEL_128;
          v75 = ((unint64_t)(v11 - 8) >> 3) + 1;
          v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
          v15 = (unint64_t)&v41[v76];
          v73 = &v10[v76];
          v77 = (__int128 *)(v10 + 16);
          v78 = v74 + 16;
          v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v80 = *v77;
            *(v78 - 1) = *(v77 - 1);
            *v78 = v80;
            v77 += 2;
            v78 += 2;
            v79 -= 4;
          }
          while (v79);
          if (v75 != (v75 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_128:
            do
            {
              v81 = *(_QWORD *)v73;
              v73 += 8;
              *(_QWORD *)v15 = v81;
              v15 += 8;
            }
            while ((char *)v15 != v72);
          }
        }
        *((_QWORD *)this + 1) = v8;
        *((_QWORD *)this + 2) = v41;
        *((_QWORD *)this + 3) = v72;
        *((_QWORD *)this + 4) = v14;
        if (v10)
        {
          operator delete(v10);
          v41 = (char *)*((_QWORD *)this + 2);
        }
      }
      else
      {
        v41 = v10;
      }
      *((_QWORD *)v41 - 1) = v3;
      v3 = *((_QWORD *)this + 2);
      v7 = (char *)*((_QWORD *)this + 3);
      *((_QWORD *)this + 2) = v3 - 8;
      v4 = *(_QWORD *)(v3 - 8);
      *((_QWORD *)this + 2) = v3;
      v13 = *((_QWORD *)this + 4);
      if (v7 != (char *)v13)
        goto LABEL_95;
      v10 = (char *)*((_QWORD *)this + 1);
      if (v3 > (unint64_t)v10)
      {
        v82 = (uint64_t)(v3 - (_QWORD)v10) >> 3;
        if (v82 >= -1)
          v83 = v82 + 1;
        else
          v83 = v82 + 2;
        v84 = v83 >> 1;
        v85 = -v84;
        v86 = v3 - 8 * v84;
        v87 = &v7[-v3];
        if (v7 != (char *)v3)
        {
          v8 = (char *)memmove((void *)(v3 - 8 * v84), (const void *)v3, (size_t)&v7[-v3]);
          v3 = *((_QWORD *)this + 2);
        }
        v7 = &v87[v86];
        *((_QWORD *)this + 2) = v3 + 8 * v85;
        *((_QWORD *)this + 3) = &v87[v86];
        goto LABEL_96;
      }
      v95 = (v7 - v10) >> 2;
      if (v7 == v10)
        v95 = 1;
      if (!(v95 >> 61))
      {
        v9 = v95 >> 2;
        v96 = 8 * v95;
        v8 = (char *)operator new(8 * v95);
        v13 = (unint64_t)&v8[8 * v9];
        v14 = &v8[v96];
        v97 = (unint64_t)&v7[-v3];
        v44 = v7 == (char *)v3;
        v7 = (char *)v13;
        if (v44)
          goto LABEL_123;
        v7 = (char *)(v13 + (v97 & 0xFFFFFFFFFFFFFFF8));
        v15 = v97 - 8;
        if (v97 - 8 >= 0x38)
          goto LABEL_118;
        v98 = &v8[8 * v9];
        goto LABEL_122;
      }
LABEL_125:
      std::__throw_bad_array_new_length[abi:sn180100]();
    }
    v108 = (char *)this + 56;
    if (v20 == v4)
      v24 = 1;
    else
      v24 = (v20 - v4) >> 2;
    if (v24 >> 61)
      goto LABEL_125;
    v25 = 8 * v24;
    v107 = v24;
    v3 = (unint64_t)operator new(8 * v24);
    v26 = (char *)(v3 + 8 * v19);
    v27 = v11 >> 3;
    v28 = (char *)(v3 + v25);
    v29 = operator new(0x1000uLL);
    v4 = (uint64_t)v29;
    if (v11 >> 3 == v107)
    {
      if (v11 < 1)
      {
        v48 = v11 >> 2;
        if ((char *)v9 == v10)
          v48 = 1;
        if (v48 >> 61)
          goto LABEL_125;
        v49 = 8 * v48;
        v26 = (char *)operator new(8 * v48);
        operator delete((void *)v3);
        v28 = &v26[v49];
        v50 = *((_QWORD *)this + 2);
        v9 = *((_QWORD *)this + 3);
        v3 = (unint64_t)v26;
        *(_QWORD *)v26 = v4;
        v31 = v26 + 8;
        if (v9 != v50)
        {
          while (1)
          {
LABEL_63:
            if (v26 == (char *)v3)
            {
              if (v31 >= v28)
              {
                v55 = (v28 - v26) >> 2;
                if (v28 == v26)
                  v55 = 1;
                if (v55 >> 61)
                  goto LABEL_125;
                v56 = (v55 + 3) >> 2;
                v4 = 8 * v55;
                v57 = (char *)operator new(8 * v55);
                v3 = (unint64_t)v57;
                v51 = &v57[8 * v56];
                v33 = v51;
                v58 = v31 - v26;
                if (v31 != v26)
                {
                  v33 = &v51[v58 & 0xFFFFFFFFFFFFFFF8];
                  v59 = v58 - 8;
                  v60 = &v57[8 * v56];
                  v61 = v26;
                  if (v59 < 0x38)
                    goto LABEL_129;
                  v60 = &v57[8 * v56];
                  v61 = v26;
                  if ((unint64_t)(v60 - v26) < 0x20)
                    goto LABEL_129;
                  v62 = (v59 >> 3) + 1;
                  v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
                  v60 = &v51[v63];
                  v61 = &v26[v63];
                  v64 = (__int128 *)(v26 + 16);
                  v65 = &v57[8 * v56 + 16];
                  v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    v67 = *v64;
                    *((_OWORD *)v65 - 1) = *(v64 - 1);
                    *(_OWORD *)v65 = v67;
                    v64 += 2;
                    v65 += 32;
                    v66 -= 4;
                  }
                  while (v66);
                  if (v62 != (v62 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_129:
                    do
                    {
                      v68 = *(_QWORD *)v61;
                      v61 += 8;
                      *(_QWORD *)v60 = v68;
                      v60 += 8;
                    }
                    while (v60 != v33);
                  }
                }
                v28 = &v57[v4];
                operator delete(v26);
              }
              else
              {
                v53 = (v28 - v31) >> 3;
                if (v53 >= -1)
                  v54 = v53 + 1;
                else
                  v54 = v53 + 2;
                v33 = &v31[8 * (v54 >> 1)];
                v51 = &v26[8 * (v54 >> 1)];
                if (v31 == v26)
                {
                  v3 = (unint64_t)v31;
                }
                else
                {
                  memmove(&v26[8 * (v54 >> 1)], v26, v31 - v26);
                  v3 = (unint64_t)v26;
                }
              }
            }
            else
            {
              v51 = v26;
              v33 = v31;
            }
            v52 = *(_QWORD *)(v9 - 8);
            v9 -= 8;
            *((_QWORD *)v51 - 1) = v52;
            v32 = v51 - 8;
            v31 = v33;
            v26 = v32;
            if (v9 == *((_QWORD *)this + 2))
              goto LABEL_39;
          }
        }
LABEL_38:
        v32 = v26;
        v33 = v31;
LABEL_39:
        v8 = (char *)*((_QWORD *)this + 1);
        *((_QWORD *)this + 1) = v3;
        *((_QWORD *)this + 2) = v32;
        v9 = (uint64_t)v33;
        *((_QWORD *)this + 3) = v33;
        *((_QWORD *)this + 4) = v28;
        v7 = (char *)this + 56;
        if (v8)
        {
          operator delete(v8);
          v9 = *((_QWORD *)this + 3);
        }
        goto LABEL_17;
      }
      v30 = v27 + 2;
      if (v27 >= -1)
        v30 = v27 + 1;
      v26 -= 8 * (v30 >> 1);
    }
    *(_QWORD *)v26 = v29;
    v31 = v26 + 8;
    if ((char *)v9 != v10)
      goto LABEL_63;
    goto LABEL_38;
  }
  *((_QWORD *)this + 5) = v17;
  v3 = (unint64_t)(v10 + 8);
  v18 = *(void **)v10;
  *((_QWORD *)this + 2) = v10 + 8;
  v13 = *((_QWORD *)this + 4);
  if (v9 != v13)
    goto LABEL_10;
  v34 = (void *)*((_QWORD *)this + 1);
  if (v3 <= (unint64_t)v34)
  {
    v42 = (v9 - (uint64_t)v34) >> 2;
    if ((void *)v9 == v34)
      v42 = 1;
    if (v42 >> 61)
      goto LABEL_125;
    v43 = v42 >> 2;
    v4 = 8 * v42;
    v8 = (char *)operator new(8 * v42);
    v13 = (unint64_t)&v8[8 * v43];
    v14 = &v8[v4];
    v45 = v9 - v3;
    v44 = v9 == v3;
    v9 = v13;
    if (v44)
      goto LABEL_109;
    v9 = v13 + (v45 & 0xFFFFFFFFFFFFFFF8);
    v46 = v45 - 8;
    if (v45 - 8 >= 0x38)
    {
      v88 = &v8[8 * v43];
      v47 = (unint64_t *)v88;
      if ((unint64_t)&v88[-v3] >= 0x20)
      {
        v15 = (v46 >> 3) + 1;
        v89 = 8 * (v15 & 0x3FFFFFFFFFFFFFFCLL);
        v47 = (unint64_t *)(v13 + v89);
        v3 += v89;
        v90 = (__int128 *)(v10 + 24);
        v91 = v88 + 16;
        v92 = v15 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v93 = *v90;
          *(v91 - 1) = *(v90 - 1);
          *v91 = v93;
          v90 += 2;
          v91 += 2;
          v92 -= 4;
        }
        while (v92);
        if (v15 == (v15 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_109:
          *((_QWORD *)this + 1) = v8;
          *((_QWORD *)this + 2) = v13;
          *((_QWORD *)this + 3) = v9;
          *((_QWORD *)this + 4) = v14;
          v7 = (char *)this + 56;
          if (v34)
          {
            operator delete(v34);
            v9 = *((_QWORD *)this + 3);
          }
LABEL_10:
          if (!v9)
            goto LABEL_117;
          goto LABEL_11;
        }
      }
    }
    else
    {
      v47 = (unint64_t *)&v8[8 * v43];
    }
    do
    {
      v94 = *(_QWORD *)v3;
      v3 += 8;
      v15 = v94;
      *v47++ = v94;
    }
    while (v47 != (unint64_t *)v9);
    goto LABEL_109;
  }
  v35 = (uint64_t)(v3 - (_QWORD)v34) >> 3;
  if (v35 >= -1)
    v36 = v35 + 1;
  else
    v36 = v35 + 2;
  v37 = v36 >> 1;
  v4 = -v37;
  v38 = v3 - 8 * v37;
  v39 = v9 - v3;
  if (v9 != v3)
  {
    v8 = (char *)memmove((void *)(v3 - 8 * v37), (const void *)v3, v9 - v3);
    v9 = *((_QWORD *)this + 2);
  }
  v40 = v9 + 8 * v4;
  v9 = v38 + v39;
  *((_QWORD *)this + 2) = v40;
  *((_QWORD *)this + 3) = v38 + v39;
LABEL_11:
  *(_QWORD *)v9 = v18;
LABEL_16:
  v9 = *((_QWORD *)this + 3) + 8;
  *((_QWORD *)this + 3) = v9;
LABEL_17:
  while (1)
  {
    v13 = *((_QWORD *)this + 5);
    v14 = (char *)*((_QWORD *)this + 6);
    v10 = (char *)*((_QWORD *)this + 2);
LABEL_18:
    if ((char *)v9 != v10)
    {
      v15 = *(_QWORD *)&v10[((unint64_t)&v14[v13] >> 5) & 0x7FFFFFFFFFFFFF8];
      if (v15)
        break;
    }
    do
    {
LABEL_117:
      __break(1u);
LABEL_118:
      v99 = &v8[8 * v9];
      v98 = (char *)v13;
      if ((unint64_t)&v99[-v3] < 0x20)
        goto LABEL_130;
      v15 = (v15 >> 3) + 1;
      v100 = 8 * (v15 & 0x3FFFFFFFFFFFFFFCLL);
      v98 = (char *)(v13 + v100);
      v101 = v3 + v100;
      v102 = (__int128 *)(v3 + 16);
      v103 = v99 + 16;
      v104 = v15 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v105 = *v102;
        *(v103 - 1) = *(v102 - 1);
        *v103 = v105;
        v102 += 2;
        v103 += 2;
        v104 -= 4;
      }
      while (v104);
      v3 = v101;
      if (v15 != (v15 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_130:
        do
        {
LABEL_122:
          v106 = *(_QWORD *)v3;
          v3 += 8;
          v15 = v106;
          *(_QWORD *)v98 = v106;
          v98 += 8;
        }
        while (v98 != v7);
      }
LABEL_123:
      *((_QWORD *)this + 1) = v8;
      *((_QWORD *)this + 2) = v13;
      *((_QWORD *)this + 3) = v7;
      *((_QWORD *)this + 4) = v14;
      if (v10)
      {
        operator delete(v10);
        v7 = (char *)*((_QWORD *)this + 3);
      }
LABEL_95:
      ;
    }
    while (!v7);
LABEL_96:
    *(_QWORD *)v7 = v4;
    v9 = *((_QWORD *)this + 3) + 8;
    *((_QWORD *)this + 3) = v9;
    v7 = v108;
  }
  v21 = (_QWORD *)(v15 + 16 * ((_BYTE)v14 + v13));
  *v21 = v109;
  v21[1] = a3;
  *((_QWORD *)this + 6) = v14 + 1;
  if (v14 != (char *)-1)
  {
    v3 = 10001;
    do
    {
      v22 = *(_QWORD *)&v10[(v13 >> 5) & 0x7FFFFFFFFFFFFF8];
      if (a3 - *(_QWORD *)(v22 + 16 * v13 + 8) < 10001)
        break;
      v8 = (char *)webrtc::PercentileFilter<long long>::Erase((uint64_t)v7, (uint64_t *)(v22 + 16 * v13));
      v10 = (char *)*((_QWORD *)this + 2);
      v13 = *((_QWORD *)this + 5);
      v14 = *(char **)&v10[(v13 >> 5) & 0x7FFFFFFFFFFFFF8];
      if (!v14)
        goto LABEL_117;
      v23 = *((_QWORD *)this + 6) - 1;
      *((_QWORD *)this + 5) = ++v13;
      *((_QWORD *)this + 6) = v23;
      if (v13 >= 0x200)
      {
        operator delete(*(void **)v10);
        v10 = (char *)(*((_QWORD *)this + 2) + 8);
        *((_QWORD *)this + 2) = v10;
        v23 = *((_QWORD *)this + 6);
        v13 = *((_QWORD *)this + 5) - 256;
        *((_QWORD *)this + 5) = v13;
      }
    }
    while (v23);
  }
}

uint64_t *webrtc::PercentileFilter<long long>::Insert(uint64_t a1, uint64_t *a2)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t **v9;
  uint64_t v10;
  uint64_t **v11;
  uint64_t *result;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v18;
  _QWORD *v19;
  BOOL v20;
  _QWORD *v22;

  v4 = (uint64_t *)operator new(0x28uLL);
  v5 = v4;
  v6 = *a2;
  v4[4] = *a2;
  v7 = (uint64_t **)(a1 + 16);
  v8 = *(uint64_t **)(a1 + 16);
  if (v8)
  {
    do
    {
      while (1)
      {
        v11 = (uint64_t **)v8;
        if (v6 >= v8[4])
          break;
        v8 = (uint64_t *)*v8;
        v9 = v11;
        if (!*v11)
        {
          *v4 = 0;
          v4[1] = 0;
          v4[2] = (uint64_t)v11;
          *v11 = v4;
          v10 = **(_QWORD **)(a1 + 8);
          if (!v10)
            goto LABEL_9;
          goto LABEL_8;
        }
      }
      v8 = (uint64_t *)v8[1];
    }
    while (v8);
    v9 = v11 + 1;
    *v4 = 0;
    v4[1] = 0;
    v4[2] = (uint64_t)v11;
    v11[1] = v4;
    v10 = **(_QWORD **)(a1 + 8);
    if (v10)
      goto LABEL_8;
  }
  else
  {
    v9 = (uint64_t **)(a1 + 16);
    *v4 = 0;
    v4[1] = 0;
    v4[2] = (uint64_t)v7;
    *v7 = v4;
    v10 = **(_QWORD **)(a1 + 8);
    if (v10)
    {
LABEL_8:
      *(_QWORD *)(a1 + 8) = v10;
      v5 = *v9;
    }
  }
LABEL_9:
  result = std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v5);
  v13 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v13 + 1;
  if (!v13)
  {
    v14 = *(_QWORD **)(a1 + 8);
    *(_QWORD *)(a1 + 32) = v14;
    v15 = (uint64_t)(float)(*(float *)a1 * (float)0);
    v16 = v15;
    if (v15 < 0)
      goto LABEL_26;
    goto LABEL_16;
  }
  v14 = *(_QWORD **)(a1 + 32);
  if (*a2 < v14[4])
    ++*(_QWORD *)(a1 + 40);
  if (v13 != -1)
  {
    v15 = (uint64_t)(float)(*(float *)a1 * (float)v13);
    v16 = v15 - *(_QWORD *)(a1 + 40);
    if (v16 < 0)
    {
      do
      {
LABEL_26:
        v22 = (_QWORD *)*v14;
        if (*v14)
        {
          do
          {
            v19 = v22;
            v22 = (_QWORD *)v22[1];
          }
          while (v22);
        }
        else
        {
          do
          {
            v19 = (_QWORD *)v14[2];
            v20 = *v19 == (_QWORD)v14;
            v14 = v19;
          }
          while (v20);
        }
        v14 = v19;
      }
      while (!__CFADD__(v16++, 1));
      goto LABEL_31;
    }
LABEL_16:
    if (!v16)
      goto LABEL_32;
    do
    {
      v18 = (_QWORD *)v14[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (_QWORD *)v14[2];
          v20 = *v19 == (_QWORD)v14;
          v14 = v19;
        }
        while (!v20);
      }
      v14 = v19;
    }
    while (v16-- > 1);
LABEL_31:
    *(_QWORD *)(a1 + 32) = v19;
LABEL_32:
    *(_QWORD *)(a1 + 40) = v15;
  }
  return result;
}

uint64_t webrtc::PercentileFilter<long long>::Erase(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t *v4;
  uint64_t v6;
  uint64_t *v7;
  _QWORD *v8;
  uint64_t v9;
  BOOL v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  BOOL v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  float v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v25;

  v4 = (uint64_t *)(a1 + 16);
  result = *(_QWORD *)(a1 + 16);
  if (result)
  {
    v6 = *a2;
    v7 = v4;
    v8 = (_QWORD *)result;
    do
    {
      v9 = v8[4];
      v10 = v9 < v6;
      if (v9 >= v6)
        v11 = v8;
      else
        v11 = v8 + 1;
      if (!v10)
        v7 = v8;
      v8 = (_QWORD *)*v11;
    }
    while (*v11);
    if (v7 != v4)
    {
      if (v7[4] != v6)
        return 0;
      v12 = (uint64_t *)v7[1];
      if (v7 == *(uint64_t **)(a1 + 32))
      {
        if (v12)
        {
          do
          {
            v14 = v12;
            v12 = (uint64_t *)*v12;
          }
          while (v12);
        }
        else
        {
          v18 = v7;
          do
          {
            v14 = (uint64_t *)v18[2];
            v16 = *v14 == (_QWORD)v18;
            v18 = v14;
          }
          while (!v16);
        }
        if (*(uint64_t **)(a1 + 8) == v7)
          *(_QWORD *)(a1 + 8) = v14;
        --*(_QWORD *)(a1 + 24);
        std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>((uint64_t *)result, v7);
        operator delete(v7);
        *(_QWORD *)(a1 + 32) = v14;
      }
      else
      {
        if (v12)
        {
          do
          {
            v13 = v12;
            v12 = (uint64_t *)*v12;
          }
          while (v12);
        }
        else
        {
          v15 = v7;
          do
          {
            v13 = (uint64_t *)v15[2];
            v16 = *v13 == (_QWORD)v15;
            v15 = v13;
          }
          while (!v16);
        }
        if (*(uint64_t **)(a1 + 8) == v7)
          *(_QWORD *)(a1 + 8) = v13;
        --*(_QWORD *)(a1 + 24);
        std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>((uint64_t *)result, v7);
        operator delete(v7);
        v17 = *a2;
        v14 = *(uint64_t **)(a1 + 32);
        if (v17 <= v14[4])
          --*(_QWORD *)(a1 + 40);
      }
      v19 = *(_QWORD *)(a1 + 24);
      if (!v19)
        return 1;
      v20 = *(float *)a1 * (float)(unint64_t)(v19 - 1);
      v21 = (uint64_t)v20 - *(_QWORD *)(a1 + 40);
      if (v21 < 0)
      {
        do
        {
          v25 = (uint64_t *)*v14;
          if (*v14)
          {
            do
            {
              v23 = v25;
              v25 = (uint64_t *)v25[1];
            }
            while (v25);
          }
          else
          {
            do
            {
              v23 = (uint64_t *)v14[2];
              v16 = *v23 == (_QWORD)v14;
              v14 = v23;
            }
            while (v16);
          }
          v14 = v23;
        }
        while (!__CFADD__(v21++, 1));
      }
      else
      {
        if (!v21)
          goto LABEL_52;
        do
        {
          v22 = (uint64_t *)v14[1];
          if (v22)
          {
            do
            {
              v23 = v22;
              v22 = (uint64_t *)*v22;
            }
            while (v22);
          }
          else
          {
            do
            {
              v23 = (uint64_t *)v14[2];
              v16 = *v23 == (_QWORD)v14;
              v14 = v23;
            }
            while (!v16);
          }
          v14 = v23;
          v10 = v21-- <= 1;
        }
        while (!v10);
      }
      *(_QWORD *)(a1 + 32) = v23;
LABEL_52:
      *(_QWORD *)(a1 + 40) = (uint64_t)v20;
      return 1;
    }
    return 0;
  }
  return result;
}

void **std::deque<webrtc::DecodeTimePercentileFilter::Sample>::~deque[abi:sn180100](void **result)
{
  void **v1;
  void **v2;
  void **v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  void **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;
  _BYTE *v14;
  _BYTE *v15;

  v1 = result;
  v2 = (void **)result[1];
  v3 = (void **)result[2];
  v4 = (char *)v3 - (char *)v2;
  if (v3 == v2)
  {
    v5 = result + 5;
  }
  else
  {
    v5 = result + 5;
    v6 = (unint64_t)result[4];
    v7 = &v2[v6 >> 8];
    v8 = (uint64_t)*v7;
    v9 = (uint64_t)*v7 + 16 * v6;
    while ((void *)v9 != *(char **)((char *)v2 + ((((unint64_t)result[5] + v6) >> 5) & 0x7FFFFFFFFFFFFF8))
                        + 16 * (*((_BYTE *)result + 40) + v6))
    {
      if (!v9)
      {
        __break(1u);
        return result;
      }
      v9 += 16;
      if (v9 - v8 == 4096)
      {
        v10 = (uint64_t)v7[1];
        ++v7;
        v8 = v10;
        v9 = v10;
      }
    }
  }
  *v5 = 0;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)v1[2];
      v2 = (void **)((char *)v1[1] + 8);
      v1[1] = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v11 = v4 >> 3;
  if (v11 == 1)
  {
    v12 = 128;
  }
  else
  {
    if (v11 != 2)
      goto LABEL_15;
    v12 = 256;
  }
  v1[4] = (void *)v12;
LABEL_15:
  if (v2 != v3)
  {
    do
    {
      v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    v15 = v1[1];
    v14 = v1[2];
    if (v14 != v15)
      v1[2] = &v14[(v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8];
  }
  if (*v1)
    operator delete(*v1);
  return v1;
}

void webrtc::video_coding::DecodedFramesHistory::InsertDecoded(webrtc::video_coding::DecodedFramesHistory *this, unint64_t a2, int a3)
{
  unint64_t v5;
  int v6;
  int v7;
  unint64_t v8;
  int v9;
  int v10;
  _BYTE *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;

  *((_QWORD *)this + 5) = a2;
  *((_BYTE *)this + 48) = 1;
  *((_DWORD *)this + 14) = a3;
  *((_BYTE *)this + 60) = 1;
  v5 = *((_QWORD *)this + 1);
  v6 = a2 % v5;
  if (v6 >= 0)
    v7 = a2 % v5;
  else
    v7 = v6 + v5;
  if (*((_BYTE *)this + 32))
  {
    v8 = *((_QWORD *)this + 3);
    if ((uint64_t)(a2 - v8) >= (uint64_t)v5)
    {
      if (v5)
      {
        v21 = *(_QWORD *)this;
        v22 = v5 >> 6;
        if (v5 >= 0x40)
          bzero(*(void **)this, 8 * v22);
        v19 = v5 & 0x3F;
        if (v19)
        {
          v20 = (_QWORD *)(v21 + 8 * v22);
          goto LABEL_49;
        }
      }
    }
    else
    {
      v9 = v8 % v5;
      if (v9 >= 0)
        v10 = v9;
      else
        v10 = v9 + v5;
      v11 = *(_BYTE **)this;
      if (v10 < 0)
        v12 = -(uint64_t)((63 - v10) >> 6);
      else
        v12 = v10 >> 6;
      v13 = &v11[8 * v12 + 8 * (((v10 & 0x3Fu) + 1) >> 6)];
      v14 = ((_BYTE)v10 + 1) & 0x3F;
      if (v7 <= v10)
      {
        v23 = (*((_QWORD *)this + 1) & 0x3FLL) - v14 + 8 * (&v11[8 * (*((_QWORD *)this + 1) >> 6)] - (_BYTE *)v13);
        if (v23)
        {
          if ((((_BYTE)v10 + 1) & 0x3F) != 0)
          {
            if ((64 - v14) >= v23)
              v24 = (*((_QWORD *)this + 1) & 0x3FLL) - v14 + 8 * (&v11[8 * (*((_QWORD *)this + 1) >> 6)] - (_BYTE *)v13);
            else
              v24 = (64 - v14);
            *v13++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v14 - v24)) & (-1 << v14));
            v23 -= v24;
          }
          if (v23 >= 0x40)
            bzero(v13, 8 * (v23 >> 6));
          if ((v23 & 0x3F) != 0)
            v13[v23 >> 6] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v23 & 0x3F));
        }
        if (v7 < 0)
          v25 = -(uint64_t)((63 - v7) >> 6);
        else
          v25 = v7 >> 6;
        v19 = v7 & 0x3F;
        v26 = v19 | (v25 << 6);
        if (v26)
        {
          v27 = v25 & 0x3FFFFFFFFFFFFFFLL;
          if (v26 >= 0x40)
            bzero(v11, 8 * v27);
          if ((v7 & 0x3F) != 0)
          {
            v20 = &v11[8 * v27];
            goto LABEL_49;
          }
        }
      }
      else
      {
        if (v7 < 0)
          v15 = -(uint64_t)((63 - v7) >> 6);
        else
          v15 = v7 >> 6;
        v16 = (v7 & 0x3F) - v14 + 8 * (&v11[8 * v15] - (_BYTE *)v13);
        if (v16)
        {
          if ((((_BYTE)v10 + 1) & 0x3F) != 0)
          {
            if ((64 - v14) >= v16)
              v17 = v16;
            else
              v17 = (64 - v14);
            *v13++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v14 - v17)) & (-1 << v14));
            v16 -= v17;
          }
          v18 = v16 >> 6;
          if (v16 >= 0x40)
            bzero(v13, 8 * v18);
          LOBYTE(v19) = v16 & 0x3F;
          if ((v16 & 0x3F) != 0)
          {
            v20 = &v13[v18];
LABEL_49:
            *v20 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(char)v19);
          }
        }
      }
    }
  }
  *(_QWORD *)(*(_QWORD *)this + (((unint64_t)v7 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v7;
  *((_QWORD *)this + 3) = a2;
  *((_BYTE *)this + 32) = 1;
}

void webrtc::VCMDecoderDatabase::DeregisterExternalDecoder(webrtc::VCMDecoderDatabase *this, unsigned int a2)
{
  char **v2;
  char *v4;
  unsigned int v5;
  BOOL v6;
  char **v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  BOOL v12;
  uint64_t *v13;
  uint64_t v14;

  v2 = (char **)*((_QWORD *)this + 13);
  if (v2)
  {
    v4 = (char *)this + 104;
    do
    {
      v5 = *((unsigned __int8 *)v2 + 32);
      v6 = v5 >= a2;
      if (v5 >= a2)
        v7 = v2;
      else
        v7 = v2 + 1;
      if (v6)
        v4 = (char *)v2;
      v2 = (char **)*v7;
    }
    while (*v7);
    if (v4 != (char *)this + 104 && v4[32] <= a2)
    {
      if (*((_BYTE *)this + 64))
      {
        v8 = *((_QWORD *)v4 + 5);
        if (*((_QWORD *)this + 2) == v8)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8);
          if (*((char *)this + 55) < 0)
            operator delete(*((void **)this + 4));
          *((_BYTE *)this + 64) = 0;
        }
      }
      v9 = (char *)*((_QWORD *)v4 + 1);
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *(char **)v9;
        }
        while (v9);
      }
      else
      {
        v11 = v4;
        do
        {
          v10 = (char *)*((_QWORD *)v11 + 2);
          v12 = *(_QWORD *)v10 == (_QWORD)v11;
          v11 = v10;
        }
        while (!v12);
      }
      if (*((char **)this + 12) == v4)
        *((_QWORD *)this + 12) = v10;
      v13 = (uint64_t *)*((_QWORD *)this + 13);
      --*((_QWORD *)this + 14);
      std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v13, (uint64_t *)v4);
      v14 = *((_QWORD *)v4 + 5);
      *((_QWORD *)v4 + 5) = 0;
      if (v14)
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
      operator delete(v4);
    }
  }
}

char *webrtc::VCMDecoderDatabase::GetDecoder(webrtc::VCMDecoderDatabase *this, const webrtc::EncodedFrame *a2, webrtc::VCMDecodedFrameCallback *a3)
{
  uint64_t v3;
  BOOL v4;
  char *v5;
  char *result;
  int v11;
  void **v12;

  v3 = *((unsigned __int8 *)a2 + 392);
  v4 = (_DWORD)v3 != *((unsigned __int8 *)this + 1) || *((_BYTE *)this + 2) == 0;
  v5 = (char *)this + 8;
  if (!v4 || (_DWORD)v3 == 0)
  {
    if (!*((_BYTE *)this + 64))
      return 0;
    return v5;
  }
  if (*((_BYTE *)this + 64))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 2) + 48))(*((_QWORD *)this + 2));
    if (*((char *)this + 55) < 0)
      operator delete(*((void **)this + 4));
    *((_BYTE *)this + 64) = 0;
    if (*((_BYTE *)this + 2))
      *((_BYTE *)this + 2) = 0;
  }
  webrtc::VCMDecoderDatabase::CreateAndInitDecoder(this, a2);
  if (!*((_BYTE *)this + 64))
    return 0;
  result = (char *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a3 + 3) + 16))(*((_QWORD *)a3 + 3), v3);
  if (!*((_BYTE *)this + 64))
  {
LABEL_32:
    __break(1u);
    return result;
  }
  *((_QWORD *)this + 1) = a3;
  result = (char *)(*(uint64_t (**)(_QWORD, webrtc::VCMDecodedFrameCallback *))(**((_QWORD **)this + 2) + 40))(*((_QWORD *)this + 2), a3);
  v11 = (int)result;
  if ((*((char *)this + 55) & 0x80000000) == 0)
  {
    v12 = (void **)((char *)this + 32);
    if (!*((_BYTE *)this + 55))
      goto LABEL_22;
    goto LABEL_21;
  }
  v12 = (void **)((char *)this + 32);
  if (*((_QWORD *)this + 5))
LABEL_21:
    result = (char *)(*(uint64_t (**)(_QWORD, void **))(**((_QWORD **)a3 + 3) + 24))(*((_QWORD *)a3 + 3), v12);
LABEL_22:
  if ((v11 & 0x80000000) == 0)
  {
    *(_WORD *)((char *)this + 1) = v3 | 0x100;
    if (*((_BYTE *)this + 64))
      return v5;
    goto LABEL_32;
  }
  if (!*((_BYTE *)this + 64))
    return 0;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 2) + 48))(*((_QWORD *)this + 2));
  if (*((char *)this + 55) < 0)
    operator delete(*v12);
  *((_BYTE *)this + 64) = 0;
  return 0;
}

void webrtc::VCMDecoderDatabase::CreateAndInitDecoder(webrtc::VCMDecoderDatabase *this, const webrtc::EncodedFrame *a2)
{
  unsigned int v2;
  char **v3;
  char **v6;
  unsigned int v7;
  BOOL v8;
  char **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char **v17;
  char **v18;
  unsigned int v19;
  BOOL v20;
  char **v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;

  v2 = *((unsigned __int8 *)a2 + 392);
  v3 = (char **)*((_QWORD *)this + 10);
  if (!v3)
    goto LABEL_12;
  v6 = (char **)((char *)this + 80);
  do
  {
    v7 = *((unsigned __int8 *)v3 + 28);
    v8 = v7 >= v2;
    if (v7 >= v2)
      v9 = v3;
    else
      v9 = v3 + 1;
    if (v8)
      v6 = v3;
    v3 = (char **)*v9;
  }
  while (*v9);
  if (v6 == (char **)((char *)this + 80) || v2 < *((unsigned __int8 *)v6 + 28))
  {
LABEL_12:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v10, v11, v12, v13, v14, v15, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/decoder_database.cc");
    return;
  }
  v17 = (char **)*((_QWORD *)this + 13);
  if (!v17)
    goto LABEL_26;
  v18 = (char **)((char *)this + 104);
  do
  {
    v19 = *((unsigned __int8 *)v17 + 32);
    v20 = v19 >= v2;
    if (v19 >= v2)
      v21 = v17;
    else
      v21 = v17 + 1;
    if (v20)
      v18 = v17;
    v17 = (char **)*v21;
  }
  while (*v21);
  if (v18 == (char **)((char *)this + 104) || v2 < *((unsigned __int8 *)v18 + 32))
  {
LABEL_26:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return;
LABEL_27:
    rtc::webrtc_logging_impl::Log("\r\t", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/decoder_database.cc");
    return;
  }
  v29 = v18[5];
  if (*((_BYTE *)this + 64))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 2) + 48))(*((_QWORD *)this + 2));
    if (*((char *)this + 55) < 0)
      operator delete(*((void **)this + 4));
  }
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = v29;
  *((_BYTE *)this + 24) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_BYTE *)this + 56) = 0;
  *((_BYTE *)this + 64) = 1;
  v30 = *((unsigned int *)a2 + 2);
  if ((int)v30 >= 1)
  {
    v31 = *((unsigned int *)a2 + 3);
    if ((int)v31 >= 1)
    {
      v6[5] = (char *)(v30 | (v31 << 32));
      if (!*((_BYTE *)this + 64))
      {
        __break(1u);
        return;
      }
    }
  }
  if ((webrtc::VCMGenericDecoder::Configure((webrtc::VCMDecoderDatabase *)((char *)this + 8), (const webrtc::VideoDecoder::Settings *)(v6 + 4)) & 1) == 0)
  {
    if (*((_BYTE *)this + 64))
    {
      webrtc::VCMGenericDecoder::~VCMGenericDecoder((webrtc::VCMDecoderDatabase *)((char *)this + 8));
      *((_BYTE *)this + 64) = 0;
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      goto LABEL_27;
  }
}

void webrtc::DecoderDatabase::~DecoderDatabase(webrtc::DecoderDatabase *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24C0B2E10;
  v2 = *((_QWORD *)this + 6);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v3)
    MEMORY[0x20BD0ADEC](v3, 0x1000C40299335D9);
  std::__tree<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>>>::destroy(*((_QWORD *)this + 2));
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24C0B2E10;
  v2 = *((_QWORD *)this + 6);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v3)
    MEMORY[0x20BD0ADEC](v3, 0x1000C40299335D9);
  std::__tree<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>>>::destroy(*((_QWORD *)this + 2));
  JUMPOUT(0x20BD0ADECLL);
}

_BYTE *webrtc::DecoderDatabase::DecoderInfo::DecoderInfo(_BYTE *a1, const std::string::value_type *a2, uint64_t a3, uint64_t a4, uint64_t a5, _BYTE *__src, size_t __len)
{
  _BYTE *v13;
  size_t v14;
  size_t v15;
  _BYTE *v16;
  std::string *v18;
  __int128 v19;
  __int128 v20;
  const std::string::value_type *v21;
  uint64_t v22;
  const std::string::value_type *v23;
  const std::string::value_type *v24;
  const std::string::value_type *v25;
  BOOL v26;
  int v27;
  int v28;
  uint64_t v29;
  const std::string::value_type *v30;
  uint64_t v31;
  int v32;
  int v33;
  char v34;
  unsigned __int8 *v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
LABEL_141:
    abort();
  v13 = a1;
  if (__len > 0x16)
  {
    v14 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v14 = __len | 7;
    v15 = v14 + 1;
    a1 = operator new(v14 + 1);
    *((_QWORD *)v13 + 1) = __len;
    *((_QWORD *)v13 + 2) = v15 | 0x8000000000000000;
    *(_QWORD *)v13 = a1;
  }
  else
  {
    a1[23] = __len;
  }
  v16 = &a1[__len];
  if (a1 <= __src && v16 > __src)
    goto LABEL_140;
  if (__len)
    memmove(a1, __src, __len);
  *v16 = 0;
  v18 = (std::string *)(v13 + 24);
  if (a2[23] < 0)
  {
    std::string::__init_copy_ctor_external(v18, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v19 = *(_OWORD *)a2;
    *((_QWORD *)v13 + 5) = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v18->__r_.__value_.__l.__data_ = v19;
  }
  v20 = *(_OWORD *)(a2 + 24);
  *((_QWORD *)v13 + 9) = 0;
  *((_QWORD *)v13 + 8) = v13 + 72;
  *((_OWORD *)v13 + 3) = v20;
  *((_QWORD *)v13 + 10) = 0;
  v21 = (const std::string::value_type *)*((_QWORD *)a2 + 5);
  if (v21 != a2 + 48)
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::string> const&>((uint64_t **)v13 + 8, (uint64_t *)v13 + 9, (uint64_t)(v21 + 32), (uint64_t)(v21 + 32));
      v24 = (const std::string::value_type *)*((_QWORD *)v21 + 1);
      if (v24)
      {
        do
        {
          v25 = v24;
          v24 = *(const std::string::value_type **)v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          v25 = (const std::string::value_type *)*((_QWORD *)v21 + 2);
          v26 = *(_QWORD *)v25 == (_QWORD)v21;
          v21 = v25;
        }
        while (!v26);
      }
      v21 = v25;
    }
    while (v25 != a2 + 48);
  }
  *((_QWORD *)v13 + 11) = a3;
  *((_QWORD *)v13 + 12) = a4;
  *((_QWORD *)v13 + 13) = a5;
  *((_QWORD *)v13 + 14) = 0;
  if (a2[23] < 0)
  {
    v22 = *((_QWORD *)a2 + 1);
    if (v22 < 0)
      goto LABEL_140;
    v23 = *(const std::string::value_type **)a2;
    if (v22)
    {
      if (!v23)
        goto LABEL_140;
    }
  }
  else
  {
    v22 = *((unsigned __int8 *)a2 + 23);
    v23 = a2;
  }
  if (v22 != 2)
    goto LABEL_40;
  v27 = *(unsigned __int8 *)v23;
  if (v27 != 67)
  {
    if ((v27 - 65) < 0x1A)
      LOBYTE(v27) = v27 + 32;
    if (v27 != 99)
      goto LABEL_40;
  }
  v28 = *((unsigned __int8 *)v23 + 1);
  if (v28 == 78)
    goto LABEL_38;
  if ((v28 - 65) < 0x1A)
    LOBYTE(v28) = v28 + 32;
  if (v28 == 110)
  {
LABEL_38:
    *((_QWORD *)v13 + 15) = *((unsigned int *)a2 + 6) | 0x100000000;
    v29 = *((unsigned __int8 *)a2 + 23);
    v30 = a2;
    v31 = v29;
    if ((a2[23] & 0x80000000) == 0)
      goto LABEL_44;
  }
  else
  {
LABEL_40:
    *((_QWORD *)v13 + 15) = 0;
    v29 = *((unsigned __int8 *)a2 + 23);
    v30 = a2;
    v31 = v29;
    if ((a2[23] & 0x80000000) == 0)
      goto LABEL_44;
  }
  v31 = *((_QWORD *)a2 + 1);
  if (v31 < 0 || (v30 = *(const std::string::value_type **)a2, v31) && !v30)
  {
LABEL_140:
    __break(1u);
    goto LABEL_141;
  }
LABEL_44:
  if (v31 == 2)
  {
    v32 = *(unsigned __int8 *)v30;
    if (v32 == 67)
      goto LABEL_49;
    if ((v32 - 65) < 0x1A)
      LOBYTE(v32) = v32 + 32;
    if (v32 == 99)
    {
LABEL_49:
      v33 = *((unsigned __int8 *)v30 + 1);
      if (v33 == 78)
        goto LABEL_53;
      if ((v33 - 65) < 0x1A)
        LOBYTE(v33) = v33 + 32;
      if (v33 == 110)
      {
LABEL_53:
        v34 = 1;
        goto LABEL_139;
      }
    }
  }
  v35 = (unsigned __int8 *)a2;
  v36 = v29;
  if ((v29 & 0x80) != 0)
  {
    v36 = *((_QWORD *)a2 + 1);
    if (v36 < 0)
      goto LABEL_140;
    v35 = *(unsigned __int8 **)a2;
    if (v36)
    {
      if (!v35)
        goto LABEL_140;
    }
  }
  if (v36 == 15)
  {
    v37 = *v35;
    if (v37 == 116)
      goto LABEL_63;
    if ((v37 - 65) < 0x1A)
      LOBYTE(v37) = v37 + 32;
    if (v37 == 116)
    {
LABEL_63:
      v38 = v35[1];
      if (v38 == 101)
        goto LABEL_118;
      if ((v38 - 65) < 0x1A)
        LOBYTE(v38) = v38 + 32;
      if (v38 == 101)
      {
LABEL_118:
        v39 = v35[2];
        if (v39 == 108)
          goto LABEL_144;
        if ((v39 - 65) < 0x1A)
          LOBYTE(v39) = v39 + 32;
        if (v39 == 108)
        {
LABEL_144:
          v40 = v35[3];
          if (v40 == 101)
            goto LABEL_145;
          if ((v40 - 65) < 0x1A)
            LOBYTE(v40) = v40 + 32;
          if (v40 == 101)
          {
LABEL_145:
            v41 = v35[4];
            if (v41 == 112)
              goto LABEL_146;
            if ((v41 - 65) < 0x1A)
              LOBYTE(v41) = v41 + 32;
            if (v41 == 112)
            {
LABEL_146:
              v42 = v35[5];
              if (v42 == 104)
                goto LABEL_147;
              if ((v42 - 65) < 0x1A)
                LOBYTE(v42) = v42 + 32;
              if (v42 == 104)
              {
LABEL_147:
                v43 = v35[6];
                if (v43 == 111)
                  goto LABEL_148;
                if ((v43 - 65) < 0x1A)
                  LOBYTE(v43) = v43 + 32;
                if (v43 == 111)
                {
LABEL_148:
                  v44 = v35[7];
                  if (v44 == 110)
                    goto LABEL_149;
                  if ((v44 - 65) < 0x1A)
                    LOBYTE(v44) = v44 + 32;
                  if (v44 == 110)
                  {
LABEL_149:
                    v45 = v35[8];
                    if (v45 == 101)
                      goto LABEL_150;
                    if ((v45 - 65) < 0x1A)
                      LOBYTE(v45) = v45 + 32;
                    if (v45 == 101)
                    {
LABEL_150:
                      v46 = v35[9];
                      if (v46 == 45)
                        goto LABEL_151;
                      if ((v46 - 65) < 0x1A)
                        LOBYTE(v46) = v46 + 32;
                      if (v46 == 45)
                      {
LABEL_151:
                        v47 = v35[10];
                        if (v47 == 101)
                          goto LABEL_152;
                        if ((v47 - 65) < 0x1A)
                          LOBYTE(v47) = v47 + 32;
                        if (v47 == 101)
                        {
LABEL_152:
                          v48 = v35[11];
                          if (v48 == 118)
                            goto LABEL_153;
                          if ((v48 - 65) < 0x1A)
                            LOBYTE(v48) = v48 + 32;
                          if (v48 == 118)
                          {
LABEL_153:
                            v49 = v35[12];
                            if (v49 == 101)
                              goto LABEL_154;
                            if ((v49 - 65) < 0x1A)
                              LOBYTE(v49) = v49 + 32;
                            if (v49 == 101)
                            {
LABEL_154:
                              v50 = v35[13];
                              if (v50 == 110)
                                goto LABEL_155;
                              if ((v50 - 65) < 0x1A)
                                LOBYTE(v50) = v50 + 32;
                              if (v50 == 110)
                              {
LABEL_155:
                                v51 = v35[14];
                                if (v51 == 116)
                                  goto LABEL_119;
                                if ((v51 - 65) < 0x1A)
                                  LOBYTE(v51) = v51 + 32;
                                if (v51 == 116)
                                {
LABEL_119:
                                  v34 = 2;
                                  goto LABEL_139;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ((v29 & 0x80) != 0)
  {
    v29 = *((_QWORD *)a2 + 1);
    if (v29 < 0)
      goto LABEL_140;
    a2 = *(const std::string::value_type **)a2;
    if (v29)
    {
      if (!a2)
        goto LABEL_140;
    }
  }
  if (v29 != 3)
    goto LABEL_138;
  v52 = *(unsigned __int8 *)a2;
  if (v52 != 114)
  {
    if ((v52 - 65) < 0x1A)
      LOBYTE(v52) = v52 + 32;
    if (v52 != 114)
      goto LABEL_138;
  }
  v53 = *((unsigned __int8 *)a2 + 1);
  if (v53 != 101)
  {
    if ((v53 - 65) < 0x1A)
      LOBYTE(v53) = v53 + 32;
    if (v53 != 101)
      goto LABEL_138;
  }
  v54 = *((unsigned __int8 *)a2 + 2);
  if (v54 == 100)
    goto LABEL_137;
  if ((v54 - 65) < 0x1A)
    LOBYTE(v54) = v54 + 32;
  if (v54 == 100)
LABEL_137:
    v34 = 3;
  else
LABEL_138:
    v34 = 0;
LABEL_139:
  v13[128] = v34;
  return v13;
}

BOOL webrtc::DecoderDatabase::Empty(webrtc::DecoderDatabase *this)
{
  return *((_QWORD *)this + 3) == 0;
}

uint64_t webrtc::DecoderDatabase::Size(webrtc::DecoderDatabase *this)
{
  return *((unsigned int *)this + 6);
}

void webrtc::DecoderDatabase::SetCodecs(_QWORD *a1@<X0>, _QWORD *a2@<X1>, char **a3@<X8>)
{
  uint64_t *v3;
  unsigned __int8 *v5;
  _QWORD *v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  BOOL v11;
  uint64_t *v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  BOOL v21;
  unint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  _OWORD *v30;
  char *v31;
  uint64_t v32;
  __int128 v33;
  int v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  BOOL v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  unsigned int v40;
  _QWORD *v41;
  uint64_t **v42;
  unsigned int v43;
  unsigned int v44;
  const std::string::value_type *v45;
  size_t v46;
  _BYTE *v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  const void **v53;
  uint64_t *v54;
  const void **v55;
  char *v56;
  std::string *v57;
  __int128 v58;
  std::string *v59;
  __int128 v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  _BYTE *v66;
  int v67;
  uint64_t v68;
  int v69;
  uint64_t *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t *v73;
  char **v74;
  char *v75;
  uint64_t v76;
  _QWORD *v77;
  uint64_t **v79;
  unsigned __int8 *v81;
  std::string v82;
  std::string v83;
  __int128 v84;
  uint64_t *v85;
  uint64_t v86[2];
  __int128 v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  char v91;
  int v92;
  std::string v93;
  std::string __p;
  __int128 v95;
  uint64_t **v96;
  char *v97;
  uint64_t v98;
  __int128 v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  char v103;
  uint64_t *v104;
  uint64_t *v105;

  v3 = a1;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v5 = (unsigned __int8 *)a1[1];
  v79 = (uint64_t **)(a1 + 1);
  v81 = (unsigned __int8 *)(a1 + 2);
  if (v5 != (unsigned __int8 *)(a1 + 2))
  {
    v6 = a2 + 1;
    do
    {
      v7 = v5[32];
      v8 = *v6;
      if (!*v6)
        goto LABEL_15;
      v9 = v6;
      do
      {
        v10 = *(_DWORD *)(v8 + 32);
        v11 = v10 < v7;
        if (v10 >= v7)
          v12 = (uint64_t *)v8;
        else
          v12 = (uint64_t *)(v8 + 8);
        if (!v11)
          v9 = (_QWORD *)v8;
        v8 = *v12;
      }
      while (*v12);
      if (v9 == v6 || *((_DWORD *)v9 + 8) > v7 || (webrtc::operator==((uint64_t)(v9 + 5), v5 + 64) & 1) == 0)
      {
LABEL_15:
        v14 = a3[1];
        v13 = (unint64_t)a3[2];
        if ((unint64_t)v14 >= v13)
        {
          v16 = *a3;
          v17 = v14 - *a3;
          v18 = v17 >> 2;
          v19 = (v17 >> 2) + 1;
          if (v19 >> 62)
            goto LABEL_130;
          v20 = v13 - (_QWORD)v16;
          if (v20 >> 1 > v19)
            v19 = v20 >> 1;
          v21 = (unint64_t)v20 >= 0x7FFFFFFFFFFFFFFCLL;
          v22 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v21)
            v22 = v19;
          if (!v22)
            goto LABEL_129;
          if (v22 >> 62)
            std::__throw_bad_array_new_length[abi:sn180100]();
          v23 = 4 * v22;
          v24 = operator new(4 * v22);
          v25 = &v24[4 * v18];
          *(_DWORD *)v25 = v7;
          v15 = v25 + 4;
          if (v14 != v16)
          {
            v26 = v14 - v16 - 4;
            if (v26 < 0x2C)
              goto LABEL_134;
            if ((unint64_t)(&v14[-v17] - v24) < 0x20)
              goto LABEL_134;
            v27 = (v26 >> 2) + 1;
            v28 = 4 * (v27 & 0x7FFFFFFFFFFFFFF8);
            v29 = &v14[-v28];
            v25 -= v28;
            v30 = &v24[4 * v18 - 16];
            v31 = v14 - 16;
            v32 = v27 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              v33 = *(_OWORD *)v31;
              *(v30 - 1) = *((_OWORD *)v31 - 1);
              *v30 = v33;
              v30 -= 2;
              v31 -= 32;
              v32 -= 8;
            }
            while (v32);
            v14 = v29;
            if (v27 != (v27 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_134:
              do
              {
                v34 = *((_DWORD *)v14 - 1);
                v14 -= 4;
                *((_DWORD *)v25 - 1) = v34;
                v25 -= 4;
              }
              while (v14 != v16);
            }
          }
          *a3 = v25;
          a3[2] = &v24[v23];
          if (v16)
            operator delete(v16);
        }
        else
        {
          if (!v14)
            goto LABEL_129;
          *(_DWORD *)v14 = v7;
          v15 = v14 + 4;
        }
        a3[1] = v15;
      }
      v35 = (unsigned __int8 *)*((_QWORD *)v5 + 1);
      if (v35)
      {
        do
        {
          v36 = v35;
          v35 = *(unsigned __int8 **)v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          v36 = (unsigned __int8 *)*((_QWORD *)v5 + 2);
          v37 = *(_QWORD *)v36 == (_QWORD)v5;
          v5 = v36;
        }
        while (!v37);
      }
      v5 = v36;
    }
    while (v36 != v81);
    v38 = (unsigned __int8 *)*a3;
    v39 = (unsigned __int8 *)a3[1];
    v3 = a1;
    if (*a3 != (char *)v39)
    {
      do
      {
        v40 = *v38;
        v38 += 4;
        (*(void (**)(_QWORD *, _QWORD))(*a1 + 48))(a1, v40);
      }
      while (v38 != v39);
    }
  }
  v41 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v42 = *(uint64_t ***)v81;
      if (*(_QWORD *)v81)
      {
        v43 = *((unsigned __int8 *)v41 + 32);
        do
        {
          v44 = *((unsigned __int8 *)v42 + 32);
          if (v44 <= v43)
          {
            if (v44 >= v43)
              goto LABEL_72;
            ++v42;
          }
          v42 = (uint64_t **)*v42;
        }
        while (v42);
      }
      v45 = (const std::string::value_type *)(v41 + 5);
      if (*((char *)v41 + 63) < 0)
      {
        v46 = v41[6];
        if ((v46 & 0x8000000000000000) != 0 || (v47 = *(_BYTE **)v45, v46) && !v47)
        {
LABEL_129:
          __break(1u);
LABEL_130:
          abort();
        }
      }
      else
      {
        v46 = *((unsigned __int8 *)v41 + 63);
        v47 = v41 + 5;
      }
      webrtc::DecoderDatabase::DecoderInfo::DecoderInfo(&v82, v45, v3[7], v3[8], v3[6], v47, v46);
      v92 = *((_DWORD *)v41 + 8);
      if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&v93, v82.__r_.__value_.__l.__data_, v82.__r_.__value_.__l.__size_);
        if ((SHIBYTE(v83.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_60:
          __p = v83;
          goto LABEL_63;
        }
      }
      else
      {
        v93 = v82;
        if ((SHIBYTE(v83.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_60;
      }
      std::string::__init_copy_ctor_external(&__p, v83.__r_.__value_.__l.__data_, v83.__r_.__value_.__l.__size_);
LABEL_63:
      v95 = v84;
      v97 = 0;
      v98 = 0;
      v96 = (uint64_t **)&v97;
      v48 = v85;
      if (v85 != v86)
      {
        do
        {
          v53 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t **)&v96, (uint64_t *)&v97, &v105, &v104, (uint64_t)(v48 + 4));
          if (*v53)
          {
            v54 = (uint64_t *)v48[1];
            if (!v54)
              goto LABEL_109;
            goto LABEL_103;
          }
          v55 = v53;
          v56 = (char *)operator new(0x50uLL);
          v57 = (std::string *)(v56 + 32);
          if (*((char *)v48 + 55) < 0)
          {
            std::string::__init_copy_ctor_external(v57, (const std::string::value_type *)v48[4], v48[5]);
            v59 = (std::string *)(v56 + 56);
            if ((*((char *)v48 + 79) & 0x80000000) == 0)
            {
LABEL_80:
              v60 = *(_OWORD *)(v48 + 7);
              v59->__r_.__value_.__r.__words[2] = v48[9];
              *(_OWORD *)&v59->__r_.__value_.__l.__data_ = v60;
              goto LABEL_83;
            }
          }
          else
          {
            v58 = *((_OWORD *)v48 + 2);
            *((_QWORD *)v56 + 6) = v48[6];
            *(_OWORD *)&v57->__r_.__value_.__l.__data_ = v58;
            v59 = (std::string *)(v56 + 56);
            if ((*((char *)v48 + 79) & 0x80000000) == 0)
              goto LABEL_80;
          }
          std::string::__init_copy_ctor_external(v59, (const std::string::value_type *)v48[7], v48[8]);
LABEL_83:
          v61 = v105;
          *(_QWORD *)v56 = 0;
          *((_QWORD *)v56 + 1) = 0;
          *((_QWORD *)v56 + 2) = v61;
          *v55 = v56;
          if (*v96)
          {
            v96 = (uint64_t **)*v96;
            v56 = (char *)*v55;
          }
          v62 = (uint64_t)v97;
          v37 = v56 == v97;
          v56[24] = v56 == v97;
          if (v37)
          {
LABEL_102:
            ++v98;
            v54 = (uint64_t *)v48[1];
            if (!v54)
              goto LABEL_109;
            goto LABEL_103;
          }
          while (1)
          {
            v63 = *((_QWORD *)v56 + 2);
            if (*(_BYTE *)(v63 + 24))
              goto LABEL_102;
            v64 = *(char **)(v63 + 16);
            v65 = *(_QWORD *)v64;
            if (*(_QWORD *)v64 != v63)
              break;
            v68 = *((_QWORD *)v64 + 1);
            if (!v68 || (v69 = *(unsigned __int8 *)(v68 + 24), v66 = (_BYTE *)(v68 + 24), v69))
            {
              if (*(char **)v63 == v56)
              {
                *(_BYTE *)(v63 + 24) = 1;
                v64[24] = 0;
                v72 = *(_QWORD *)(v63 + 8);
                *(_QWORD *)v64 = v72;
                if (v72)
                  goto LABEL_100;
              }
              else
              {
                v70 = *(uint64_t **)(v63 + 8);
                v71 = *v70;
                *(_QWORD *)(v63 + 8) = *v70;
                if (v71)
                {
                  *(_QWORD *)(v71 + 16) = v63;
                  v64 = *(char **)(v63 + 16);
                }
                v70[2] = (uint64_t)v64;
                *(_QWORD *)(*(_QWORD *)(v63 + 16) + 8 * (**(_QWORD **)(v63 + 16) != v63)) = v70;
                *v70 = v63;
                *(_QWORD *)(v63 + 16) = v70;
                v64 = (char *)v70[2];
                v63 = *(_QWORD *)v64;
                *((_BYTE *)v70 + 24) = 1;
                v64[24] = 0;
                v72 = *(_QWORD *)(v63 + 8);
                *(_QWORD *)v64 = v72;
                if (v72)
LABEL_100:
                  *(_QWORD *)(v72 + 16) = v64;
              }
              *(_QWORD *)(v63 + 16) = *((_QWORD *)v64 + 2);
              *(_QWORD *)(*((_QWORD *)v64 + 2) + 8 * (**((_QWORD **)v64 + 2) != (_QWORD)v64)) = v63;
              *(_QWORD *)(v63 + 8) = v64;
              *((_QWORD *)v64 + 2) = v63;
              goto LABEL_102;
            }
LABEL_88:
            *(_BYTE *)(v63 + 24) = 1;
            v56 = v64;
            v64[24] = v64 == (char *)v62;
            *v66 = 1;
            if (v64 == (char *)v62)
              goto LABEL_102;
          }
          if (v65)
          {
            v67 = *(unsigned __int8 *)(v65 + 24);
            v66 = (_BYTE *)(v65 + 24);
            if (!v67)
              goto LABEL_88;
          }
          if (*(char **)v63 == v56)
          {
            v76 = *((_QWORD *)v56 + 1);
            *(_QWORD *)v63 = v76;
            if (v76)
            {
              *(_QWORD *)(v76 + 16) = v63;
              v64 = *(char **)(v63 + 16);
            }
            *((_QWORD *)v56 + 2) = v64;
            *(_QWORD *)(*(_QWORD *)(v63 + 16) + 8 * (**(_QWORD **)(v63 + 16) != v63)) = v56;
            *((_QWORD *)v56 + 1) = v63;
            *(_QWORD *)(v63 + 16) = v56;
            v64 = (char *)*((_QWORD *)v56 + 2);
            v56[24] = 1;
            v64[24] = 0;
            v74 = (char **)*((_QWORD *)v64 + 1);
            v75 = *v74;
            *((_QWORD *)v64 + 1) = *v74;
            if (v75)
LABEL_107:
              *((_QWORD *)v75 + 2) = v64;
          }
          else
          {
            *(_BYTE *)(v63 + 24) = 1;
            v64[24] = 0;
            v74 = (char **)*((_QWORD *)v64 + 1);
            v75 = *v74;
            *((_QWORD *)v64 + 1) = *v74;
            if (v75)
              goto LABEL_107;
          }
          v74[2] = (char *)*((_QWORD *)v64 + 2);
          *(_QWORD *)(*((_QWORD *)v64 + 2) + 8 * (**((_QWORD **)v64 + 2) != (_QWORD)v64)) = v74;
          *v74 = v64;
          *((_QWORD *)v64 + 2) = v74;
          ++v98;
          v54 = (uint64_t *)v48[1];
          if (!v54)
          {
            do
            {
LABEL_109:
              v73 = (uint64_t *)v48[2];
              v37 = *v73 == (_QWORD)v48;
              v48 = v73;
            }
            while (!v37);
            goto LABEL_74;
          }
          do
          {
LABEL_103:
            v73 = v54;
            v54 = (uint64_t *)*v54;
          }
          while (v54);
LABEL_74:
          v48 = v73;
        }
        while (v73 != v86);
      }
      v99 = v87;
      v100 = v88;
      v49 = v89;
      v89 = 0;
      v101 = v49;
      v102 = v90;
      v103 = v91;
      std::__tree<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>>>::__emplace_unique_impl<std::pair<int,webrtc::DecoderDatabase::DecoderInfo>>(v79, (uint64_t)&v92);
      v50 = v101;
      v101 = 0;
      if (v50)
        (*(void (**)(uint64_t))(*(_QWORD *)v50 + 8))(v50);
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)&v96, (uint64_t)v97);
      v3 = a1;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v93.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_68:
          v51 = v89;
          v89 = 0;
          if (!v51)
            goto LABEL_70;
          goto LABEL_69;
        }
      }
      else if ((SHIBYTE(v93.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_68;
      }
      operator delete(v93.__r_.__value_.__l.__data_);
      v51 = v89;
      v89 = 0;
      if (v51)
LABEL_69:
        (*(void (**)(uint64_t))(*(_QWORD *)v51 + 8))(v51);
LABEL_70:
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)&v85, v86[0]);
      if ((SHIBYTE(v83.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        if ((SHIBYTE(v82.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_72;
LABEL_122:
        operator delete(v82.__r_.__value_.__l.__data_);
        v52 = (_QWORD *)v41[1];
        if (!v52)
          goto LABEL_125;
        do
        {
LABEL_123:
          v77 = v52;
          v52 = (_QWORD *)*v52;
        }
        while (v52);
        goto LABEL_45;
      }
      operator delete(v83.__r_.__value_.__l.__data_);
      if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_122;
LABEL_72:
      v52 = (_QWORD *)v41[1];
      if (v52)
        goto LABEL_123;
      do
      {
LABEL_125:
        v77 = (_QWORD *)v41[2];
        v37 = *v77 == (_QWORD)v41;
        v41 = v77;
      }
      while (!v37);
LABEL_45:
      v41 = v77;
    }
    while (v77 != a2 + 1);
  }
}

uint64_t webrtc::DecoderDatabase::RegisterPayload(uint64_t this, unsigned int a2, const webrtc::SdpAudioFormat *a3)
{
  uint64_t v4;
  size_t v5;
  const webrtc::SdpAudioFormat *v6;
  uint64_t **v7;
  uint64_t *v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  BOOL v14;
  std::string v15;
  std::string v16;
  __int128 v17;
  uint64_t *v18;
  uint64_t v19[2];
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  char v23;
  unsigned int v24;
  std::string v25;
  std::string __p;
  __int128 v27;
  uint64_t *v28;
  uint64_t v29[2];
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  char v33;

  if (a2 > 0x7F)
    return 0xFFFFFFFFLL;
  v4 = this;
  if (*((char *)a3 + 23) < 0)
  {
    v5 = *((_QWORD *)a3 + 1);
    if ((v5 & 0x8000000000000000) != 0 || (v6 = *(const webrtc::SdpAudioFormat **)a3, v5) && !v6)
    {
      __break(1u);
      return this;
    }
  }
  else
  {
    v5 = *((unsigned __int8 *)a3 + 23);
    v6 = a3;
  }
  webrtc::DecoderDatabase::DecoderInfo::DecoderInfo(&v15, (const std::string::value_type *)a3, *(_QWORD *)(this + 56), *(_QWORD *)(this + 64), *(_QWORD *)(this + 48), v6, v5);
  v24 = a2;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(&v25, v15.__r_.__value_.__l.__data_, v15.__r_.__value_.__l.__size_);
    v7 = (uint64_t **)(v4 + 8);
    if ((SHIBYTE(v16.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_10;
  }
  else
  {
    v25 = v15;
    v7 = (uint64_t **)(v4 + 8);
    if ((SHIBYTE(v16.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_10:
      __p = v16;
      goto LABEL_13;
    }
  }
  std::string::__init_copy_ctor_external(&__p, v16.__r_.__value_.__l.__data_, v16.__r_.__value_.__l.__size_);
LABEL_13:
  v27 = v17;
  v29[0] = 0;
  v29[1] = 0;
  v28 = v29;
  v8 = v18;
  if (v18 != v19)
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::string> const&>(&v28, v29, (uint64_t)(v8 + 4), (uint64_t)(v8 + 4));
      v12 = (uint64_t *)v8[1];
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = (uint64_t *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          v13 = (uint64_t *)v8[2];
          v14 = *v13 == (_QWORD)v8;
          v8 = v13;
        }
        while (!v14);
      }
      v8 = v13;
    }
    while (v13 != v19);
  }
  v30 = v20;
  v31 = v21;
  *((_QWORD *)&v21 + 1) = 0;
  v32 = v22;
  v33 = v23;
  v9 = std::__tree<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>>>::__emplace_unique_impl<std::pair<int,webrtc::DecoderDatabase::DecoderInfo>>(v7, (uint64_t)&v24);
  v10 = *((_QWORD *)&v31 + 1);
  *((_QWORD *)&v31 + 1) = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)&v28, v29[0]);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_18:
      v11 = *((_QWORD *)&v21 + 1);
      *((_QWORD *)&v21 + 1) = 0;
      if (!v11)
        goto LABEL_20;
      goto LABEL_19;
    }
  }
  else if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_18;
  }
  operator delete(v25.__r_.__value_.__l.__data_);
  v11 = *((_QWORD *)&v21 + 1);
  *((_QWORD *)&v21 + 1) = 0;
  if (v11)
LABEL_19:
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
LABEL_20:
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)&v18, v19[0]);
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v16.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
  }
  else if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_22;
  }
  operator delete(v15.__r_.__value_.__l.__data_);
LABEL_22:
  if ((v9 & 1) != 0)
    return 0;
  else
    return 4294967292;
}

uint64_t webrtc::DecoderDatabase::Remove(webrtc::DecoderDatabase *this, unsigned int a2)
{
  uint64_t *v3;
  char *v4;
  char *v6;
  uint64_t *v7;
  unsigned int v8;
  BOOL v9;
  uint64_t **v10;
  uint64_t result;
  char *v12;
  char *v13;
  char *v14;
  BOOL v15;
  uint64_t v16;

  v4 = (char *)this + 16;
  v3 = (uint64_t *)*((_QWORD *)this + 2);
  if (!v3)
    return 4294967291;
  v6 = v4;
  v7 = v3;
  do
  {
    v8 = *((unsigned __int8 *)v7 + 32);
    v9 = v8 >= a2;
    if (v8 >= a2)
      v10 = (uint64_t **)v7;
    else
      v10 = (uint64_t **)(v7 + 1);
    if (v9)
      v6 = (char *)v7;
    v7 = *v10;
  }
  while (*v10);
  if (v6 == v4 || v6[32] > a2)
    return 4294967291;
  v12 = (char *)*((_QWORD *)v6 + 1);
  if (v12)
  {
    do
    {
      v13 = v12;
      v12 = *(char **)v12;
    }
    while (v12);
  }
  else
  {
    v14 = v6;
    do
    {
      v13 = (char *)*((_QWORD *)v14 + 2);
      v15 = *(_QWORD *)v13 == (_QWORD)v14;
      v14 = v13;
    }
    while (!v15);
  }
  if (*((char **)this + 1) == v6)
    *((_QWORD *)this + 1) = v13;
  --*((_QWORD *)this + 3);
  std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v3, (uint64_t *)v6);
  v16 = *((_QWORD *)v6 + 19);
  *((_QWORD *)v6 + 19) = 0;
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)(v6 + 104), *((_QWORD *)v6 + 14));
  if (v6[87] < 0)
  {
    operator delete(*((void **)v6 + 8));
    if ((v6[63] & 0x80000000) == 0)
    {
LABEL_25:
      operator delete(v6);
      if (*((_DWORD *)this + 8) == a2)
        goto LABEL_26;
LABEL_30:
      if (*((_DWORD *)this + 9) != a2)
        return 0;
      goto LABEL_31;
    }
  }
  else if ((v6[63] & 0x80000000) == 0)
  {
    goto LABEL_25;
  }
  operator delete(*((void **)v6 + 5));
  operator delete(v6);
  if (*((_DWORD *)this + 8) != a2)
    goto LABEL_30;
LABEL_26:
  *((_DWORD *)this + 8) = -1;
  if (*((_DWORD *)this + 9) != a2)
    return 0;
LABEL_31:
  result = 0;
  *((_DWORD *)this + 9) = -1;
  return result;
}

double webrtc::DecoderDatabase::RemoveAll(webrtc::DecoderDatabase *this)
{
  _QWORD *v1;
  double result;

  v1 = (_QWORD *)((char *)this + 16);
  std::__tree<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>>>::destroy(*((_QWORD *)this + 2));
  *(v1 - 1) = v1;
  *v1 = 0;
  v1[1] = 0;
  result = NAN;
  v1[2] = -1;
  return result;
}

char *webrtc::DecoderDatabase::GetDecoderInfo(webrtc::DecoderDatabase *this, unsigned int a2)
{
  char *v2;
  char **v3;
  char *v4;
  char *v5;
  unsigned int v6;
  BOOL v7;
  char **v8;
  unsigned int v9;
  char *v10;

  v4 = (char *)*((_QWORD *)this + 2);
  v2 = (char *)this + 16;
  v3 = (char **)v4;
  if (!v4)
    return 0;
  v5 = v2;
  do
  {
    v6 = *((unsigned __int8 *)v3 + 32);
    v7 = v6 >= a2;
    if (v6 >= a2)
      v8 = v3;
    else
      v8 = v3 + 1;
    if (v7)
      v5 = (char *)v3;
    v3 = (char **)*v8;
  }
  while (*v8);
  if (v5 == v2)
    return 0;
  v9 = v5[32];
  v10 = v5 + 40;
  if (v9 <= a2)
    return v10;
  else
    return 0;
}

uint64_t webrtc::DecoderDatabase::SetActiveDecoder(webrtc::DecoderDatabase *this, int a2, BOOL *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  std::string *v15;
  uint64_t v16;

  v6 = (*(uint64_t (**)(webrtc::DecoderDatabase *))(*(_QWORD *)this + 64))(this);
  if (!v6)
    return 4294967291;
  if (*(_BYTE *)(v6 + 128) != 1)
  {
    *a3 = 0;
    v11 = *((_DWORD *)this + 8);
    if ((v11 & 0x80000000) == 0)
    {
      if (v11 == a2)
      {
LABEL_8:
        result = 0;
        *((_DWORD *)this + 8) = v11;
        return result;
      }
      v12 = (*(uint64_t (**)(webrtc::DecoderDatabase *, _QWORD))(*(_QWORD *)this + 64))(this, *((_DWORD *)this + 8));
      v13 = *(_QWORD *)(v12 + 112);
      *(_QWORD *)(v12 + 112) = 0;
      if (v13)
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
    }
    *a3 = 1;
    v11 = a2;
    goto LABEL_8;
  }
  v15 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/decoder_database.cc", 199, "!info->IsComfortNoise()", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v7, v8, v9, v10, v16);
  return webrtc::DecoderDatabase::GetActiveDecoder((webrtc::DecoderDatabase *)v15);
}

uint64_t webrtc::DecoderDatabase::GetActiveDecoder(webrtc::DecoderDatabase *this)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if ((*((_DWORD *)this + 8) & 0x80000000) != 0)
    return 0;
  result = (*(uint64_t (**)(webrtc::DecoderDatabase *, _QWORD))(*(_QWORD *)this + 64))(this, *((_DWORD *)this + 8));
  if (result)
  {
    v2 = result;
    if (*(_BYTE *)(result + 128))
    {
      return 0;
    }
    else
    {
      result = *(_QWORD *)(result + 112);
      if (!result)
      {
        (*(void (**)(uint64_t *__return_ptr, _QWORD, uint64_t, _QWORD, _QWORD))(**(_QWORD **)(v2 + 104) + 48))(&v6, *(_QWORD *)(v2 + 104), v2 + 24, *(_QWORD *)(v2 + 88), *(_QWORD *)(v2 + 96));
        v3 = v6;
        v6 = 0;
        v4 = *(_QWORD *)(v2 + 112);
        *(_QWORD *)(v2 + 112) = v3;
        if (v4)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
          v5 = v6;
          v6 = 0;
          if (v5)
            (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
        }
        return *(_QWORD *)(v2 + 112);
      }
    }
  }
  return result;
}

uint64_t webrtc::DecoderDatabase::SetActiveCngDecoder(webrtc::DecoderDatabase *this, int a2)
{
  int v4;
  uint64_t v5;
  uint64_t result;

  if (!(*(uint64_t (**)(webrtc::DecoderDatabase *))(*(_QWORD *)this + 64))(this))
    return 4294967291;
  v4 = *((_DWORD *)this + 9);
  if ((v4 & 0x80000000) == 0 && v4 != a2)
  {
    v5 = *((_QWORD *)this + 5);
    *((_QWORD *)this + 5) = 0;
    if (v5)
      MEMORY[0x20BD0ADEC](v5, 0x1000C40299335D9);
  }
  result = 0;
  *((_DWORD *)this + 9) = a2;
  return result;
}

uint64_t webrtc::DecoderDatabase::GetActiveCngDecoder(webrtc::DecoderDatabase *this)
{
  uint64_t result;
  uint64_t v3;

  if ((*((_DWORD *)this + 9) & 0x80000000) != 0)
    return 0;
  result = *((_QWORD *)this + 5);
  if (!result)
  {
    result = operator new();
    *(_DWORD *)result = 7777;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 20) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 100) = 0u;
    *(_DWORD *)(result + 116) = 5;
    *(_WORD *)(result + 120) = 0;
    v3 = *((_QWORD *)this + 5);
    *((_QWORD *)this + 5) = result;
    if (v3)
    {
      MEMORY[0x20BD0ADEC](v3, 0x1000C40299335D9);
      return *((_QWORD *)this + 5);
    }
  }
  return result;
}

void std::__tree<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>>>::destroy(uint64_t a1)
{
  uint64_t v2;

  if (a1)
  {
    std::__tree<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>>>::destroy(*(_QWORD *)a1);
    std::__tree<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>>>::destroy(*(_QWORD *)(a1 + 8));
    v2 = *(_QWORD *)(a1 + 152);
    *(_QWORD *)(a1 + 152) = 0;
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1 + 104, *(_QWORD *)(a1 + 112));
    if (*(char *)(a1 + 87) < 0)
    {
      operator delete(*(void **)(a1 + 64));
      if ((*(char *)(a1 + 63) & 0x80000000) == 0)
        goto LABEL_6;
    }
    else if ((*(char *)(a1 + 63) & 0x80000000) == 0)
    {
LABEL_6:
      operator delete((void *)a1);
      return;
    }
    operator delete(*(void **)(a1 + 40));
    operator delete((void *)a1);
  }
}

uint64_t std::__tree<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,webrtc::DecoderDatabase::DecoderInfo>>>::__emplace_unique_impl<std::pair<int,webrtc::DecoderDatabase::DecoderInfo>>(uint64_t **a1, uint64_t a2)
{
  char *v4;
  _QWORD *v5;
  void **v6;
  std::string *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  unsigned int v13;
  _QWORD *v14;
  _QWORD *v15;
  BOOL v16;
  uint64_t *v17;
  unsigned int v18;
  uint64_t *v19;

  v4 = (char *)operator new(0xB0uLL);
  v5 = v4;
  v4[32] = *(_DWORD *)a2;
  v6 = (void **)(v4 + 40);
  if (*(char *)(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(v4 + 40), *(const std::string::value_type **)(a2 + 8), *(_QWORD *)(a2 + 16));
    v7 = (std::string *)(v5 + 8);
    if ((*(char *)(a2 + 55) & 0x80000000) == 0)
      goto LABEL_3;
  }
  else
  {
    *(_OWORD *)v6 = *(_OWORD *)(a2 + 8);
    *((_QWORD *)v4 + 7) = *(_QWORD *)(a2 + 24);
    v7 = (std::string *)(v4 + 64);
    if ((*(char *)(a2 + 55) & 0x80000000) == 0)
    {
LABEL_3:
      *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 32);
      v7->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 48);
      goto LABEL_6;
    }
  }
  std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 32), *(_QWORD *)(a2 + 40));
LABEL_6:
  v5[14] = 0;
  v5[13] = v5 + 14;
  *(_OWORD *)(v5 + 11) = *(_OWORD *)(a2 + 56);
  v5[15] = 0;
  v8 = *(_QWORD **)(a2 + 72);
  if (v8 != (_QWORD *)(a2 + 80))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::string> const&>((uint64_t **)v5 + 13, v5 + 14, (uint64_t)(v8 + 4), (uint64_t)(v8 + 4));
      v14 = (_QWORD *)v8[1];
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          v15 = (_QWORD *)v8[2];
          v16 = *v15 == (_QWORD)v8;
          v8 = v15;
        }
        while (!v16);
      }
      v8 = v15;
    }
    while (v15 != (_QWORD *)(a2 + 80));
  }
  *((_OWORD *)v5 + 8) = *(_OWORD *)(a2 + 96);
  v10 = *(_QWORD *)(a2 + 112);
  v9 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a2 + 120) = 0;
  v5[18] = v10;
  v5[19] = v9;
  v5[20] = *(_QWORD *)(a2 + 128);
  *((_BYTE *)v5 + 168) = *(_BYTE *)(a2 + 136);
  v11 = (uint64_t *)(a1 + 1);
  v12 = a1[1];
  if (v12)
  {
    v13 = *((unsigned __int8 *)v5 + 32);
    while (1)
    {
      while (1)
      {
        v17 = v12;
        v18 = *((unsigned __int8 *)v12 + 32);
        if (v13 >= v18)
          break;
        v12 = (uint64_t *)*v12;
        v11 = v17;
        if (!*v17)
          goto LABEL_22;
      }
      if (v18 >= v13)
        break;
      v12 = (uint64_t *)v12[1];
      if (!v12)
      {
        v11 = v17 + 1;
        goto LABEL_22;
      }
    }
    v5[19] = 0;
    if (v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)(v5 + 13), v5[14]);
    if (*((char *)v5 + 87) < 0)
    {
      operator delete(v7->__r_.__value_.__l.__data_);
      if ((*((char *)v5 + 63) & 0x80000000) == 0)
        goto LABEL_29;
    }
    else if ((*((char *)v5 + 63) & 0x80000000) == 0)
    {
LABEL_29:
      operator delete(v5);
      return 0;
    }
    operator delete(*v6);
    goto LABEL_29;
  }
  v17 = (uint64_t *)(a1 + 1);
LABEL_22:
  *v5 = 0;
  v5[1] = 0;
  v5[2] = v17;
  *v11 = (uint64_t)v5;
  v19 = (uint64_t *)**a1;
  if (v19)
  {
    *a1 = v19;
    v5 = (_QWORD *)*v11;
  }
  std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(a1[1], v5);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return 1;
}

void webrtc::DefaultIceTransportFactory::CreateIceTransport(uint64_t a1@<X1>, int a2@<W2>, uint64_t *a3@<X3>, uint64_t *a4@<X8>)
{
  char *v5;
  size_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  void (**v18)(_anonymous_namespace_::BasicIceControllerFactory *__hidden);
  uint64_t v19;

  v5 = (char *)a1;
  v18 = &off_24C0B2EE8;
  a3[3] = (uint64_t)&v18;
  if (*(char *)(a1 + 23) < 0)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if ((v6 & 0x8000000000000000) != 0 || ((v5 = *(char **)a1, v6) ? (v7 = v5 == 0) : (v7 = 0), v7))
    {
      __break(1u);
      return;
    }
  }
  else
  {
    v6 = *(unsigned __int8 *)(a1 + 23);
  }
  v8 = *a3;
  v9 = a3[1];
  v10 = a3[2];
  v12 = a3[4];
  v11 = a3[5];
  v13 = operator new();
  v19 = 0;
  cricket::P2PTransportChannel::P2PTransportChannel(v13, v5, v6, a2, v8, v9, &v19, v10, (uint64_t)&v18, v12, v11);
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  v14 = operator new();
  *(_QWORD *)(v14 + 16) = v13;
  *(_QWORD *)v14 = off_24C0B2F10;
  *(_DWORD *)(v14 + 24) = 0;
  v15 = (unsigned int *)(v14 + 24);
  do
    v16 = __ldxr(v15);
  while (__stxr(v16 + 1, v15));
  *a4 = v14;
}

void webrtc::DefaultIceTransportFactory::~DefaultIceTransportFactory(webrtc::DefaultIceTransportFactory *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::DefaultIceTransport::internal(webrtc::DefaultIceTransport *this)
{
  return *((_QWORD *)this + 2);
}

void `anonymous namespace'::BasicIceControllerFactory::~BasicIceControllerFactory(_anonymous_namespace_::BasicIceControllerFactory *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t `anonymous namespace'::BasicIceControllerFactory::Create@<X0>(_QWORD *a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t result;

  v4 = operator new();
  result = cricket::BasicIceController::BasicIceController(v4, a1);
  *a2 = result;
  return result;
}

uint64_t rtc::RefCountedObject<webrtc::DefaultIceTransport>::AddRef(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 24);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL rtc::RefCountedObject<webrtc::DefaultIceTransport>::Release(unsigned int *a1)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = a1 + 6;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (a1 && v2 == 1)
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 24))(a1);
  return v2 != 1;
}

_QWORD *rtc::RefCountedObject<webrtc::DefaultIceTransport>::~RefCountedObject(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &unk_24C0B2E88;
  v2 = a1[2];
  a1[2] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

void rtc::RefCountedObject<webrtc::DefaultIceTransport>::~RefCountedObject(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &unk_24C0B2E88;
  v2 = a1[2];
  a1[2] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x20BD0ADECLL);
}

BOOL rtc::RefCountedObject<webrtc::DefaultIceTransport>::HasOneRef(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)(a1 + 24));
  return v1 == 1;
}

void webrtc::DefaultNetEqControllerFactory::~DefaultNetEqControllerFactory(webrtc::DefaultNetEqControllerFactory *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::DefaultNetEqControllerFactory::CreateNetEqController@<X0>(_OWORD *a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[2];

  v4 = operator new();
  v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  result = webrtc::DecisionLogic::DecisionLogic(v4, (char *)v7);
  *a2 = result;
  return result;
}

void webrtc::DefaultNetEqFactory::~DefaultNetEqFactory(webrtc::DefaultNetEqFactory *this)
{
  *(_QWORD *)this = &off_24C0B2F78;
}

{
  *(_QWORD *)this = &off_24C0B2F78;
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::DefaultNetEqFactory::CreateNetEq(uint64_t a1@<X0>, unsigned int *a2@<X1>, void (****a3)(_QWORD)@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v7;
  _QWORD v8[13];

  webrtc::NetEqImpl::Dependencies::Dependencies(v8, (uint64_t)a2, a4, a3, a1 + 8);
  v7 = operator new();
  *a5 = webrtc::NetEqImpl::NetEqImpl(v7, a2, v8, 1);
  webrtc::NetEqImpl::Dependencies::~Dependencies((webrtc::NetEqImpl::Dependencies *)v8);
}

uint64_t webrtc::DefaultOutputRateCalculator::CalculateOutputRateFromRange(uint64_t a1, signed int *a2, uint64_t a3)
{
  int v3;
  signed int *v4;
  uint64_t v5;
  int *v6;
  int v7;
  int v8;
  BOOL v9;
  unsigned int *v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int *v13;
  unsigned int *v14;
  signed int v15;

  if (!a3)
    return 48000;
  if (a3 != 1)
  {
    v4 = a2 + 1;
    v3 = *a2;
    v5 = 4 * a3 - 4;
    v6 = a2 + 1;
    do
    {
      v8 = *v6++;
      v7 = v8;
      v9 = v3 < v8;
      if (v3 <= v8)
        v3 = v7;
      if (v9)
        a2 = v4;
      v4 = v6;
      v5 -= 4;
    }
    while (v5);
  }
  v10 = (unsigned int *)&webrtc::DefaultOutputRateCalculator::CalculateOutputRateFromRange(rtc::ArrayView<int const,-4711l>)::native_rates;
  v11 = 4;
  do
  {
    v12 = v11 >> 1;
    v13 = &v10[v11 >> 1];
    v15 = *v13;
    v14 = v13 + 1;
    v11 += ~(v11 >> 1);
    if (v15 < *a2)
      v10 = v14;
    else
      v11 = v12;
  }
  while (v11);
  return *v10;
}

void webrtc::DefaultOutputRateCalculator::~DefaultOutputRateCalculator(webrtc::DefaultOutputRateCalculator *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

webrtc::DefaultTemporalLayers *webrtc::DefaultTemporalLayers::DefaultTemporalLayers(webrtc::DefaultTemporalLayers *this, uint64_t a2)
{
  uint64_t v2;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _BYTE *v10;
  _BYTE *v11;
  uint64_t i;
  char *v13;
  char *v14;
  char *v15;
  __int128 v16;
  __int128 v17;
  char *v18;
  uint64_t v19;
  __int128 v20;
  char *v21;
  void **v22;
  unint64_t v23;
  char *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  char v36;
  __int128 v37;
  __int128 v38;
  unint64_t v39;
  size_t v40;
  char *v41;
  char v43;
  __int128 v44;
  uint64_t v45;
  void *v46[2];
  __int128 v47;
  uint64_t v48;
  _BYTE v49[32];
  unint64_t v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  _BYTE v54[32];
  unint64_t v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  _BYTE v59[32];
  unint64_t v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;
  _BYTE v64[32];
  unint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  _BYTE v69[32];
  unint64_t v70;
  __int128 v71;
  __int128 v72;
  uint64_t v73;
  _BYTE v74[32];
  unint64_t v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;
  _BYTE v79[32];
  unint64_t v80;
  __int128 v81;
  __int128 v82;
  uint64_t v83;
  _BYTE v84[32];
  uint64_t v85;
  void *v86;
  uint64_t v87;
  char v88;
  __int128 v89;
  uint64_t v90;
  char v91;
  uint64_t v92;
  void *v93;
  uint64_t v94;
  char v95;
  __int128 v96;
  int v97;
  int v98;
  char v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  char v103;
  __int128 v104;
  uint64_t v105;
  char v106;
  uint64_t v107;
  void *v108;
  uint64_t v109;
  char v110;
  __int128 v111;
  int v112;
  int v113;
  char v114;
  uint64_t v115;
  void *v116;
  uint64_t v117;
  char v118;
  __int128 v119;
  uint64_t v120;
  char v121;
  uint64_t v122;
  void *v123;
  uint64_t v124;
  char v125;
  __int128 v126;
  int v127;
  int v128;
  char v129;
  uint64_t v130;
  void *v131;
  uint64_t v132;
  char v133;
  __int128 v134;
  uint64_t v135;
  char v136;
  uint64_t v137;
  void *__p;
  uint64_t v139;
  char v140;
  __int128 v141;
  int v142;
  int v143;
  char v144;
  uint64_t v145;

  v2 = a2;
  v145 = *MEMORY[0x24BDAC8D0];
  if ((int)a2 <= 1)
    a2 = 1;
  else
    a2 = a2;
  *(_QWORD *)this = &off_24C0B2FC8;
  *((_QWORD *)this + 1) = a2;
  switch(*((_QWORD *)this + 1))
  {
    case 1:
      v4 = (char *)operator new(0x50uLL);
      v9 = v4 + 80;
      *((_QWORD *)this + 7) = v4 + 80;
      *(_QWORD *)v4 = 2;
      *((_DWORD *)v4 + 2) = 2;
      v4[48] = 0;
      *(_OWORD *)(v4 + 52) = xmmword_208F08A30;
      *(_QWORD *)(v4 + 68) = 255;
      goto LABEL_7;
    case 2:
      v13 = (char *)operator new(0x140uLL);
      *(_QWORD *)v13 = 4;
      *((_QWORD *)v13 + 1) = 0x200000002;
      v13[48] = 0;
      *(_OWORD *)(v13 + 52) = xmmword_208F08A30;
      *(_QWORD *)(v13 + 68) = 255;
      v13[76] = 1;
      *((_QWORD *)v13 + 10) = 4;
      *((_QWORD *)v13 + 11) = 0x200000000;
      v13[128] = 0;
      *(_OWORD *)(v13 + 132) = xmmword_208F08A70;
      *(_QWORD *)(v13 + 148) = 255;
      v13[156] = 1;
      *((_QWORD *)v13 + 20) = 4;
      *((_QWORD *)v13 + 21) = 0x300000002;
      v13[208] = 0;
      *(_OWORD *)(v13 + 212) = xmmword_208F08A30;
      *(_QWORD *)(v13 + 228) = 255;
      v13[236] = 1;
      *((_QWORD *)v13 + 31) = 0x100000000;
      v13[288] = 0;
      *((_DWORD *)v13 + 77) = 255;
      *((_DWORD *)v13 + 78) = 256;
      v13[316] = 1;
      *((_QWORD *)v13 + 30) = 4;
      *((_QWORD *)this + 6) = v13 + 320;
      *((_QWORD *)this + 7) = v13 + 320;
      *(_OWORD *)(v13 + 292) = xmmword_208F08AB0;
      *((_QWORD *)this + 5) = v13;
      v10 = (_BYTE *)*((_QWORD *)this + 5);
      v11 = (_BYTE *)*((_QWORD *)this + 6);
      i = 7;
      if (v10 == v11)
        goto LABEL_81;
      goto LABEL_74;
    case 3:
      v46[0] = (void *)0x200000002;
      LODWORD(v46[1]) = 2;
      v45 = 6;
      v49[0] = 0;
      *(_OWORD *)&v49[4] = xmmword_208F08A30;
      *(_QWORD *)&v49[20] = 255;
      v49[28] = 1;
      *(_QWORD *)&v51 = 0;
      DWORD2(v51) = 1;
      v50 = 6;
      v54[0] = 0;
      *(_OWORD *)&v54[4] = xmmword_208F08A40;
      *(_DWORD *)&v54[20] = 255;
      *(_DWORD *)&v54[24] = 256;
      v54[28] = 1;
      *(_QWORD *)&v56 = 0x200000000;
      DWORD2(v56) = 2;
      v55 = 6;
      v59[0] = 0;
      *(_OWORD *)&v59[4] = xmmword_208F08A70;
      *(_QWORD *)&v59[20] = 255;
      v59[28] = 1;
      *(_QWORD *)&v61 = 0;
      DWORD2(v61) = 1;
      v60 = 6;
      v64[0] = 0;
      *(_OWORD *)&v64[4] = xmmword_208F08AB0;
      *(_DWORD *)&v64[20] = 255;
      *(_DWORD *)&v64[24] = 256;
      v64[28] = 1;
      *(_QWORD *)&v66 = 0x300000002;
      DWORD2(v66) = 3;
      v65 = 6;
      v69[0] = 0;
      *(_OWORD *)&v69[4] = xmmword_208F08A30;
      *(_QWORD *)&v69[20] = 255;
      v69[28] = 1;
      *(_QWORD *)&v71 = 0;
      DWORD2(v71) = 1;
      v70 = 6;
      v74[0] = 0;
      *(_OWORD *)&v74[4] = xmmword_208F08AB0;
      *(_DWORD *)&v74[20] = 255;
      *(_DWORD *)&v74[24] = 256;
      v74[28] = 1;
      *(_QWORD *)&v76 = 0x100000000;
      DWORD2(v76) = 2;
      v75 = 6;
      v79[0] = 0;
      *(_OWORD *)&v79[4] = xmmword_208F08AA0;
      *(_QWORD *)&v79[20] = 255;
      v79[28] = 1;
      *(_QWORD *)&v81 = 0;
      DWORD2(v81) = 1;
      v80 = 6;
      v84[0] = 0;
      *(_OWORD *)&v84[4] = xmmword_208F08AB0;
      *(_DWORD *)&v84[20] = 255;
      *(_DWORD *)&v84[24] = 256;
      v84[28] = 1;
      v14 = (char *)operator new(0x280uLL);
      *((_QWORD *)this + 5) = v14;
      *((_QWORD *)this + 6) = v14;
      v15 = v14 + 640;
      *((_QWORD *)this + 7) = v14 + 640;
      *(_QWORD *)v14 = 6;
      *(_OWORD *)(v14 + 8) = *(_OWORD *)v46;
      *(_OWORD *)(v14 + 24) = v47;
      *((_QWORD *)v14 + 5) = v48;
      v16 = *(_OWORD *)&v49[16];
      *((_OWORD *)v14 + 3) = *(_OWORD *)v49;
      *((_OWORD *)v14 + 4) = v16;
      *((_QWORD *)v14 + 10) = 0;
      if (v50 >= 2)
      {
        if ((v50 & 1) != 0)
        {
          absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::InitFrom((unint64_t *)v14 + 10, &v50);
        }
        else
        {
          *((_QWORD *)v14 + 10) = v50;
          v17 = v52;
          *(_OWORD *)(v14 + 88) = v51;
          *(_OWORD *)(v14 + 104) = v17;
          *((_QWORD *)v14 + 15) = v53;
        }
      }
      *((_QWORD *)v14 + 20) = 0;
      v25 = *(_OWORD *)&v54[16];
      *((_OWORD *)v14 + 8) = *(_OWORD *)v54;
      *((_OWORD *)v14 + 9) = v25;
      if (v55 >= 2)
      {
        if ((v55 & 1) != 0)
        {
          absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::InitFrom((unint64_t *)v14 + 20, &v55);
        }
        else
        {
          *((_QWORD *)v14 + 20) = v55;
          v26 = v57;
          *(_OWORD *)(v14 + 168) = v56;
          *(_OWORD *)(v14 + 184) = v26;
          *((_QWORD *)v14 + 25) = v58;
        }
      }
      *((_QWORD *)v14 + 30) = 0;
      v27 = *(_OWORD *)&v59[16];
      *((_OWORD *)v14 + 13) = *(_OWORD *)v59;
      *((_OWORD *)v14 + 14) = v27;
      if (v60 >= 2)
      {
        if ((v60 & 1) != 0)
        {
          absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::InitFrom((unint64_t *)v14 + 30, &v60);
        }
        else
        {
          *((_QWORD *)v14 + 30) = v60;
          v28 = v62;
          *(_OWORD *)(v14 + 248) = v61;
          *(_OWORD *)(v14 + 264) = v28;
          *((_QWORD *)v14 + 35) = v63;
        }
      }
      v29 = *(_OWORD *)&v64[16];
      *((_OWORD *)v14 + 18) = *(_OWORD *)v64;
      *((_OWORD *)v14 + 19) = v29;
      *((_QWORD *)v14 + 40) = 0;
      if (v65 >= 2)
      {
        if ((v65 & 1) != 0)
        {
          absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::InitFrom((unint64_t *)v14 + 40, &v65);
        }
        else
        {
          *((_QWORD *)v14 + 40) = v65;
          v30 = v67;
          *(_OWORD *)(v14 + 328) = v66;
          *(_OWORD *)(v14 + 344) = v30;
          *((_QWORD *)v14 + 45) = v68;
        }
      }
      v31 = *(_OWORD *)&v69[16];
      *((_OWORD *)v14 + 23) = *(_OWORD *)v69;
      *((_OWORD *)v14 + 24) = v31;
      *((_QWORD *)v14 + 50) = 0;
      if (v70 >= 2)
      {
        if ((v70 & 1) != 0)
        {
          absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::InitFrom((unint64_t *)v14 + 50, &v70);
        }
        else
        {
          *((_QWORD *)v14 + 50) = v70;
          v32 = v72;
          *(_OWORD *)(v14 + 408) = v71;
          *(_OWORD *)(v14 + 424) = v32;
          *((_QWORD *)v14 + 55) = v73;
        }
      }
      v33 = *(_OWORD *)&v74[16];
      *((_OWORD *)v14 + 28) = *(_OWORD *)v74;
      *((_OWORD *)v14 + 29) = v33;
      *((_QWORD *)v14 + 60) = 0;
      if (v75 >= 2)
      {
        if ((v75 & 1) != 0)
        {
          absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::InitFrom((unint64_t *)v14 + 60, &v75);
        }
        else
        {
          *((_QWORD *)v14 + 60) = v75;
          v34 = v77;
          *(_OWORD *)(v14 + 488) = v76;
          *(_OWORD *)(v14 + 504) = v34;
          *((_QWORD *)v14 + 65) = v78;
        }
      }
      v35 = *(_OWORD *)&v79[16];
      *((_OWORD *)v14 + 33) = *(_OWORD *)v79;
      *((_OWORD *)v14 + 34) = v35;
      *((_QWORD *)v14 + 70) = 0;
      v36 = v80;
      if (v80 < 2)
        goto LABEL_63;
      if ((v80 & 1) != 0)
      {
        absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::InitFrom((unint64_t *)v14 + 70, &v80);
        v43 = v80;
        v44 = *(_OWORD *)&v84[16];
        *((_OWORD *)v14 + 38) = *(_OWORD *)v84;
        *((_OWORD *)v14 + 39) = v44;
        *((_QWORD *)this + 6) = v15;
        if ((v43 & 1) != 0)
          goto LABEL_64;
        goto LABEL_65;
      }
      *((_QWORD *)v14 + 70) = v80;
      v37 = v82;
      *(_OWORD *)(v14 + 568) = v81;
      *(_OWORD *)(v14 + 584) = v37;
      *((_QWORD *)v14 + 75) = v83;
LABEL_63:
      v38 = *(_OWORD *)&v84[16];
      *((_OWORD *)v14 + 38) = *(_OWORD *)v84;
      *((_OWORD *)v14 + 39) = v38;
      *((_QWORD *)this + 6) = v15;
      if ((v36 & 1) == 0)
        goto LABEL_65;
      goto LABEL_64;
    case 4:
      v46[0] = 0;
      v46[1] = 0;
      v45 = 8;
      v49[0] = 0;
      *(_OWORD *)&v49[4] = xmmword_208F08A30;
      *(_QWORD *)&v49[20] = 255;
      v49[28] = 1;
      v51 = 0uLL;
      v50 = 8;
      v54[0] = 0;
      *(_OWORD *)&v54[4] = xmmword_208F08A40;
      *(_DWORD *)&v54[20] = 255;
      *(_DWORD *)&v54[24] = 256;
      v54[28] = 1;
      v56 = 0uLL;
      v55 = 8;
      v59[0] = 0;
      *(_OWORD *)&v59[4] = xmmword_208F08A50;
      *(_QWORD *)&v59[20] = 255;
      v59[28] = 1;
      v61 = 0uLL;
      v60 = 8;
      v64[0] = 0;
      *(_OWORD *)&v64[4] = xmmword_208F08A60;
      *(_DWORD *)&v64[20] = 255;
      *(_DWORD *)&v64[24] = 256;
      v64[28] = 1;
      v66 = 0uLL;
      v65 = 8;
      v69[0] = 0;
      *(_OWORD *)&v69[4] = xmmword_208F08A70;
      *(_QWORD *)&v69[20] = 255;
      v69[28] = 1;
      v71 = 0uLL;
      v70 = 8;
      v74[0] = 0;
      *(_OWORD *)&v74[4] = xmmword_208F08A80;
      *(_DWORD *)&v74[20] = 255;
      *(_DWORD *)&v74[24] = 256;
      v74[28] = 1;
      v75 = 8;
      v76 = 0uLL;
      v79[0] = 0;
      *(_OWORD *)&v79[4] = xmmword_208F08A90;
      *(_QWORD *)&v79[20] = 255;
      v79[28] = 1;
      v81 = 0uLL;
      v80 = 8;
      v84[0] = 0;
      *(_OWORD *)&v84[4] = xmmword_208F08A80;
      *(_DWORD *)&v84[20] = 255;
      *(_DWORD *)&v84[24] = 256;
      v84[28] = 1;
      v87 = 0;
      v86 = 0;
      v85 = 8;
      v88 = 0;
      v89 = xmmword_208F08A30;
      v90 = 255;
      v91 = 1;
      v94 = 0;
      v93 = 0;
      v92 = 8;
      v95 = 0;
      v96 = xmmword_208F08A80;
      v97 = 255;
      v98 = 256;
      v99 = 1;
      v102 = 0;
      v101 = 0;
      v100 = 8;
      v103 = 0;
      v104 = xmmword_208F08A90;
      v105 = 255;
      v106 = 1;
      v109 = 0;
      v108 = 0;
      v107 = 8;
      v110 = 0;
      v111 = xmmword_208F08A80;
      v112 = 255;
      v113 = 256;
      v114 = 1;
      v117 = 0;
      v116 = 0;
      v115 = 8;
      v118 = 0;
      v119 = xmmword_208F08AA0;
      v120 = 255;
      v121 = 1;
      v124 = 0;
      v123 = 0;
      v122 = 8;
      v125 = 0;
      v126 = xmmword_208F08A80;
      v127 = 255;
      v128 = 256;
      v129 = 1;
      v132 = 0;
      v131 = 0;
      v130 = 8;
      v133 = 0;
      v134 = xmmword_208F08A90;
      v135 = 255;
      v136 = 1;
      v139 = 0;
      __p = 0;
      v137 = 8;
      v140 = 0;
      v141 = xmmword_208F08A80;
      v142 = 255;
      v143 = 256;
      v144 = 1;
      v18 = (char *)operator new(0x500uLL);
      v19 = 0;
      *((_QWORD *)this + 5) = v18;
      *((_QWORD *)this + 7) = v18 + 1280;
      do
      {
        v21 = &v18[v19 * 8];
        v22 = &v46[v19 - 1];
        *(_QWORD *)&v18[v19 * 8] = 0;
        v23 = (unint64_t)v46[v19 - 1];
        if (v23 >= 2)
        {
          if ((v23 & 1) != 0)
          {
            absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::InitFrom((unint64_t *)&v18[v19 * 8], (unint64_t *)&v46[v19 - 1]);
          }
          else
          {
            v24 = &v18[v19 * 8];
            *(_QWORD *)v24 = v23;
            *(_OWORD *)(v24 + 8) = *(_OWORD *)&v46[v19];
            *(_OWORD *)(v24 + 24) = *(__int128 *)((char *)&v47 + v19 * 8);
            *((_QWORD *)v24 + 5) = *(_QWORD *)&v49[v19 * 8 - 8];
          }
        }
        v20 = *((_OWORD *)v22 + 4);
        *((_OWORD *)v21 + 3) = *((_OWORD *)v22 + 3);
        *((_OWORD *)v21 + 4) = v20;
        v19 += 10;
      }
      while (v19 != 160);
      *((_QWORD *)this + 6) = v18 + 1280;
      if ((v137 & 1) != 0)
      {
        operator delete(__p);
        if ((v130 & 1) == 0)
        {
LABEL_22:
          if ((v122 & 1) == 0)
            goto LABEL_23;
          goto LABEL_32;
        }
      }
      else if ((v130 & 1) == 0)
      {
        goto LABEL_22;
      }
      operator delete(v131);
      if ((v122 & 1) == 0)
      {
LABEL_23:
        if ((v115 & 1) == 0)
          goto LABEL_24;
        goto LABEL_33;
      }
LABEL_32:
      operator delete(v123);
      if ((v115 & 1) == 0)
      {
LABEL_24:
        if ((v107 & 1) == 0)
          goto LABEL_25;
        goto LABEL_34;
      }
LABEL_33:
      operator delete(v116);
      if ((v107 & 1) == 0)
      {
LABEL_25:
        if ((v100 & 1) == 0)
          goto LABEL_26;
        goto LABEL_35;
      }
LABEL_34:
      operator delete(v108);
      if ((v100 & 1) == 0)
      {
LABEL_26:
        if ((v92 & 1) == 0)
          goto LABEL_27;
        goto LABEL_36;
      }
LABEL_35:
      operator delete(v101);
      if ((v92 & 1) == 0)
      {
LABEL_27:
        if ((v85 & 1) == 0)
          goto LABEL_28;
        goto LABEL_37;
      }
LABEL_36:
      operator delete(v93);
      if ((v85 & 1) == 0)
      {
LABEL_28:
        if ((v80 & 1) == 0)
          goto LABEL_65;
        goto LABEL_64;
      }
LABEL_37:
      operator delete(v86);
      if ((v80 & 1) == 0)
        goto LABEL_65;
LABEL_64:
      operator delete((void *)v81);
LABEL_65:
      if ((v75 & 1) != 0)
      {
        operator delete((void *)v76);
        if ((v70 & 1) == 0)
        {
LABEL_67:
          if ((v65 & 1) == 0)
            goto LABEL_68;
          goto LABEL_90;
        }
      }
      else if ((v70 & 1) == 0)
      {
        goto LABEL_67;
      }
      operator delete((void *)v71);
      if ((v65 & 1) == 0)
      {
LABEL_68:
        if ((v60 & 1) == 0)
          goto LABEL_69;
        goto LABEL_91;
      }
LABEL_90:
      operator delete((void *)v66);
      if ((v60 & 1) == 0)
      {
LABEL_69:
        if ((v55 & 1) == 0)
          goto LABEL_70;
        goto LABEL_92;
      }
LABEL_91:
      operator delete((void *)v61);
      if ((v55 & 1) == 0)
      {
LABEL_70:
        if ((v50 & 1) == 0)
          goto LABEL_71;
        goto LABEL_93;
      }
LABEL_92:
      operator delete((void *)v56);
      if ((v50 & 1) == 0)
      {
LABEL_71:
        if ((v45 & 1) == 0)
          goto LABEL_73;
        goto LABEL_72;
      }
LABEL_93:
      operator delete((void *)v51);
      if ((v45 & 1) != 0)
LABEL_72:
        operator delete(v46[0]);
LABEL_73:
      v10 = (_BYTE *)*((_QWORD *)this + 5);
      v11 = (_BYTE *)*((_QWORD *)this + 6);
      for (i = 7; v10 != v11; v10 += 80)
      {
LABEL_74:
        if ((v10[52] & 2) != 0)
          i &= ~1uLL;
        if ((v10[56] & 2) != 0)
          i &= ~2uLL;
        if ((v10[60] & 2) != 0)
          i &= ~4uLL;
      }
LABEL_81:
      *((_QWORD *)this + 8) = i;
      *((_BYTE *)this + 72) = -1;
      v39 = *((_QWORD *)this + 1);
      if (v39)
      {
        if (v39 >> 62)
          abort();
        v40 = 4 * v39;
        v41 = (char *)operator new(4 * v39);
        bzero(v41, v40);
        v39 = (unint64_t)&v41[v40];
      }
      else
      {
        v41 = 0;
      }
      *((_QWORD *)this + 10) = v41;
      *((_QWORD *)this + 11) = v39;
      *((_QWORD *)this + 12) = v39;
      *((_BYTE *)this + 104) = 1;
      *((_OWORD *)this + 7) = 0u;
      *((_OWORD *)this + 8) = 0u;
      *((_OWORD *)this + 9) = 0u;
      *((_QWORD *)this + 23) = 0;
      if ((int)v2 >= 5)
      {
        rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/default_temporal_layers.cc", 224, "kMaxTemporalStreams >= number_of_temporal_layers", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, v5, v6, v7, v8, 4);
LABEL_98:
        rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/default_temporal_layers.cc", 225, "number_of_temporal_layers >= 0", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, v5, v6, v7, v8, v2);
      }
      if ((v2 & 0x80000000) != 0)
        goto LABEL_98;
      *((_QWORD *)this + 20) = 0;
      *((_QWORD *)this + 21) = 0;
      *((_QWORD *)this + 22) = 0;
      return this;
    default:
      v4 = (char *)operator new(0x50uLL);
      v9 = v4 + 80;
      *((_QWORD *)this + 7) = v4 + 80;
      *(_QWORD *)v4 = 0;
      v4[48] = 1;
      *(_QWORD *)(v4 + 60) = 0;
      *(_QWORD *)(v4 + 52) = 0;
      *(_QWORD *)(v4 + 68) = 255;
LABEL_7:
      v4[76] = 1;
      *((_QWORD *)this + 5) = v4;
      *((_QWORD *)this + 6) = v9;
      v10 = (_BYTE *)*((_QWORD *)this + 5);
      v11 = (_BYTE *)*((_QWORD *)this + 6);
      i = 7;
      if (v10 == v11)
        goto LABEL_81;
      goto LABEL_74;
  }
}

double webrtc::`anonymous namespace'::GetTemporalIds(webrtc::_anonymous_namespace_ *this, uint64_t a2)
{
  _DWORD *v3;
  double result;
  _QWORD *v5;
  _OWORD *v6;
  _OWORD *v7;

  switch(a2)
  {
    case 2:
      v5 = operator new(8uLL);
      *(_QWORD *)this = v5;
      *v5++ = 0x100000000;
      *((_QWORD *)this + 1) = v5;
      *((_QWORD *)this + 2) = v5;
      break;
    case 3:
      v6 = operator new(0x10uLL);
      *(_QWORD *)this = v6;
      *(_QWORD *)&result = 0x200000000;
      *v6++ = xmmword_208F08AC0;
      *((_QWORD *)this + 1) = v6;
      *((_QWORD *)this + 2) = v6;
      break;
    case 4:
      v7 = operator new(0x20uLL);
      *((_QWORD *)this + 1) = v7 + 2;
      *((_QWORD *)this + 2) = v7 + 2;
      *(_QWORD *)&result = 0x300000000;
      *v7 = xmmword_208F08B64;
      v7[1] = unk_208F08B74;
      *(_QWORD *)this = v7;
      break;
    default:
      v3 = operator new(4uLL);
      *(_QWORD *)this = v3;
      *v3++ = 0;
      *((_QWORD *)this + 1) = v3;
      *((_QWORD *)this + 2) = v3;
      break;
  }
  return result;
}

void webrtc::DefaultTemporalLayers::~DefaultTemporalLayers(webrtc::DefaultTemporalLayers *this)
{
  uint64_t v2;
  void **v3;
  void **v4;
  unint64_t v5;
  void **v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  char v23;
  void *v24;

  v2 = *((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void **)*((_QWORD *)this + 15);
  v4 = (void **)*((_QWORD *)this + 16);
  if (v4 == v3)
  {
    v4 = (void **)*((_QWORD *)this + 15);
    *((_QWORD *)this + 19) = 0;
    v11 = 0;
    goto LABEL_16;
  }
  v5 = *((_QWORD *)this + 18);
  v6 = &v3[v5 / 0x2E];
  v7 = (unint64_t)*v6;
  v8 = (unint64_t)*v6 + 88 * (v5 % 0x2E);
  v9 = (unint64_t)v3[(*((_QWORD *)this + 19) + v5) / 0x2E] + 88 * ((*((_QWORD *)this + 19) + v5) % 0x2E);
  if (v8 != v9)
  {
    while (1)
    {
      if (!v8)
      {
        __break(1u);
        return;
      }
      if ((*(_BYTE *)(v8 + 8) & 1) != 0)
      {
        operator delete(*(void **)(v8 + 16));
        v7 = (unint64_t)*v6;
        v8 += 88;
        if (v8 - (_QWORD)*v6 == 4048)
        {
LABEL_12:
          v10 = (unint64_t)v6[1];
          ++v6;
          v7 = v10;
          v8 = v10;
        }
      }
      else
      {
        v8 += 88;
        if (v8 - v7 == 4048)
          goto LABEL_12;
      }
      if (v8 == v9)
      {
        v3 = (void **)*((_QWORD *)this + 15);
        v4 = (void **)*((_QWORD *)this + 16);
        break;
      }
    }
  }
  *((_QWORD *)this + 19) = 0;
  v11 = (char *)v4 - (char *)v3;
  if ((unint64_t)((char *)v4 - (char *)v3) >= 0x11)
  {
    do
    {
      operator delete(*v3);
      v4 = (void **)*((_QWORD *)this + 16);
      v3 = (void **)(*((_QWORD *)this + 15) + 8);
      *((_QWORD *)this + 15) = v3;
      v11 = (char *)v4 - (char *)v3;
    }
    while ((unint64_t)((char *)v4 - (char *)v3) > 0x10);
  }
LABEL_16:
  v12 = v11 >> 3;
  if (v12 == 1)
  {
    v13 = 23;
  }
  else
  {
    if (v12 != 2)
      goto LABEL_22;
    v13 = 46;
  }
  *((_QWORD *)this + 18) = v13;
LABEL_22:
  if (v3 != v4)
  {
    do
    {
      v14 = *v3++;
      operator delete(v14);
    }
    while (v3 != v4);
    v16 = *((_QWORD *)this + 15);
    v15 = *((_QWORD *)this + 16);
    if (v15 != v16)
      *((_QWORD *)this + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  v17 = (void *)*((_QWORD *)this + 14);
  if (v17)
    operator delete(v17);
  if (*((_BYTE *)this + 104))
  {
    v18 = (void *)*((_QWORD *)this + 10);
    if (v18)
    {
      *((_QWORD *)this + 11) = v18;
      operator delete(v18);
    }
  }
  v19 = *((_QWORD *)this + 5);
  if (v19)
  {
    v20 = *((_QWORD *)this + 6);
    v21 = (void *)*((_QWORD *)this + 5);
    if (v20 != v19)
    {
      v22 = *((_QWORD *)this + 6);
      do
      {
        v23 = *(_BYTE *)(v22 - 80);
        v22 -= 80;
        if ((v23 & 1) != 0)
          operator delete(*(void **)(v20 - 72));
        v20 = v22;
      }
      while (v22 != v19);
      v21 = (void *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 6) = v19;
    operator delete(v21);
  }
  v24 = (void *)*((_QWORD *)this + 2);
  if (v24)
  {
    *((_QWORD *)this + 3) = v24;
    operator delete(v24);
  }
}

{
  webrtc::DefaultTemporalLayers::~DefaultTemporalLayers(this);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::DefaultTemporalLayers::StreamCount(webrtc::DefaultTemporalLayers *this)
{
  return 1;
}

uint64_t webrtc::DefaultTemporalLayers::SupportsEncoderFrameDropping(webrtc::DefaultTemporalLayers *this)
{
  return 1;
}

void webrtc::DefaultTemporalLayers::OnRatesUpdated(uint64_t a1, uint64_t a2, char **a3)
{
  std::vector<unsigned int> *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  std::vector<unsigned int>::size_type v9;
  char *v10;
  char *v11;
  int64_t v12;
  char *v13;
  char *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  unint64_t v20;
  uint64_t i;

  v4 = (std::vector<unsigned int> *)(a1 + 80);
  if (*(_BYTE *)(a1 + 104))
  {
    if (v4 != (std::vector<unsigned int> *)a3)
    {
      std::vector<int>::__assign_with_size[abi:sn180100]<int *,int *>((_QWORD *)(a1 + 80), *a3, a3[1], (a3[1] - *a3) >> 2);
      if (!*(_BYTE *)(a1 + 104))
      {
LABEL_22:
        __break(1u);
LABEL_23:
        abort();
      }
    }
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(_QWORD *)(a1 + 80);
    v7 = (*(_QWORD *)(a1 + 88) - v6) >> 2;
    v8 = v5 >= v7;
    v9 = v5 - v7;
    if (v5 > v7)
      goto LABEL_5;
  }
  else
  {
    v4->__begin_ = 0;
    *(_QWORD *)(a1 + 88) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    v11 = *a3;
    v10 = a3[1];
    v12 = v10 - *a3;
    if (v10 != *a3)
    {
      if (v12 < 0)
        goto LABEL_23;
      v13 = (char *)operator new(v10 - *a3);
      *(_QWORD *)(a1 + 80) = v13;
      *(_QWORD *)(a1 + 88) = v13;
      v14 = &v13[4 * (v12 >> 2)];
      *(_QWORD *)(a1 + 96) = v14;
      memcpy(v13, v11, v12);
      *(_QWORD *)(a1 + 88) = v14;
    }
    *(_BYTE *)(a1 + 104) = 1;
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(_QWORD *)(a1 + 80);
    v15 = (*(_QWORD *)(a1 + 88) - v6) >> 2;
    v8 = v5 >= v15;
    v9 = v5 - v15;
    if (v5 > v15)
    {
LABEL_5:
      std::vector<int>::__append(v4, v9);
      v5 = *(_QWORD *)(a1 + 8);
      goto LABEL_12;
    }
  }
  if (!v8)
    *(_QWORD *)(a1 + 88) = v6 + 4 * v5;
LABEL_12:
  if (v5 >= 2)
  {
    if (*(_BYTE *)(a1 + 104))
    {
      v16 = *(_QWORD *)(a1 + 80);
      v17 = (*(_QWORD *)(a1 + 88) - v16) >> 2;
      if (v17 <= 1)
        v18 = 1;
      else
        v18 = (*(_QWORD *)(a1 + 88) - v16) >> 2;
      v19 = (_DWORD *)(v16 + 4);
      v20 = v5 - 1;
      for (i = v18 - 1; v17 && i; --i)
      {
        *v19 += *(v19 - 1);
        ++v19;
        --v17;
        if (!--v20)
          return;
      }
    }
    goto LABEL_22;
  }
}

void webrtc::DefaultTemporalLayers::UpdateConfiguration(webrtc::DefaultTemporalLayers *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int64x2_t v14;
  uint32x4_t v15;
  uint32x4_t v16;
  unint64_t v17;
  uint32x4_t *v18;
  uint32x4_t v19;
  int64x2_t v20;
  _DWORD *v21;
  unsigned int v22;
  _BYTE *v23;
  _BYTE *v24;
  void *v25;

  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 112) = 0;
  *(_BYTE *)(a2 + 116) = 0;
  *(_BYTE *)(a2 + 120) = 0;
  *(_BYTE *)(a2 + 124) = 0;
  *(_BYTE *)(a2 + 128) = 0;
  *(_BYTE *)(a2 + 132) = 0;
  *(_BYTE *)(a2 + 136) = 0;
  *(_BYTE *)(a2 + 140) = 0;
  if (*((_BYTE *)this + 104))
  {
    *(_OWORD *)(a2 + 4) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 68) = 0u;
    *(_OWORD *)(a2 + 84) = 0u;
    *(_OWORD *)(a2 + 36) = 0u;
    *(_OWORD *)(a2 + 52) = 0u;
    *(_OWORD *)(a2 + 20) = 0u;
    *(_BYTE *)(a2 + 112) = 1;
    v3 = *((_QWORD *)this + 1);
    if (v3)
    {
      v4 = *((_QWORD *)this + 10);
      v5 = *((_QWORD *)this + 11) - v4;
      v6 = v5 >> 2;
      v7 = a2 + 24;
      if ((unint64_t)v5 <= 0x17)
      {
        v8 = v3 - 1;
        if (v6 < v3 - 1)
          v8 = v5 >> 2;
        v9 = v8 + 1;
        if (v9 >= 5)
          goto LABEL_18;
        v10 = 0;
        while (1)
        {
          v4 += 4 * v10;
          v6 -= v10;
          v7 = (~(_DWORD)v10 + v3);
          v21 = (_DWORD *)(4 * v10 + a2 + 24);
          v9 = v3 - v10;
          while (v6)
          {
            v22 = *(_DWORD *)v4;
            v4 += 4;
            *(v21 - 5) = v22 / 0x3E8;
            *v21++ = 1 << v7;
            --v6;
            v7 = (v7 - 1);
            if (!--v9)
              goto LABEL_25;
          }
LABEL_17:
          __break(1u);
LABEL_18:
          v11 = v9 & 3;
          if ((v9 & 3) == 0)
            v11 = 4;
          v10 = v9 - v11;
          v12 = (int8x16_t)xmmword_208F08AD0;
          v13 = (int8x16_t)xmmword_208F05120;
          v14 = vdupq_n_s64(v3);
          v15 = (uint32x4_t)vdupq_n_s32(0x10624DD3u);
          v16.i64[0] = 0x100000001;
          v16.i64[1] = 0x100000001;
          v17 = v10;
          v18 = (uint32x4_t *)v4;
          do
          {
            v19 = *v18++;
            *(uint32x4_t *)(v7 - 20) = vshrq_n_u32((uint32x4_t)vuzp2q_s32((int32x4_t)vmull_u32(*(uint32x2_t *)v19.i8, *(uint32x2_t *)v15.i8), (int32x4_t)vmull_high_u32(v19, v15)), 6uLL);
            *(uint32x4_t *)v7 = vshlq_u32(v16, (uint32x4_t)vuzp1q_s32((int32x4_t)vaddq_s64(v14, (int64x2_t)vmvnq_s8(v13)), (int32x4_t)vaddq_s64(v14, (int64x2_t)vmvnq_s8(v12))));
            v7 += 16;
            v20 = vdupq_n_s64(4uLL);
            v12 = (int8x16_t)vaddq_s64((int64x2_t)v12, v20);
            v13 = (int8x16_t)vaddq_s64((int64x2_t)v13, v20);
            v17 -= 4;
          }
          while (v17);
        }
      }
      *(_DWORD *)(a2 + 4) = *(_DWORD *)v4 / 0x3E8u;
      v9 = (1 << (v3 - 1));
      *(_DWORD *)v7 = v9;
      if (v3 != 1)
      {
        if (v6 == 1)
          goto LABEL_17;
        *(_DWORD *)(a2 + 8) = *(_DWORD *)(v4 + 4) / 0x3E8u;
        v9 = 1;
        v7 = (1 << (v3 - 2));
        *(_DWORD *)(a2 + 28) = v7;
        if (v3 != 2)
        {
          if (v6 == 2)
            goto LABEL_17;
          *(_DWORD *)(a2 + 12) = *(_DWORD *)(v4 + 8) / 0x3E8u;
          v9 = 1;
          v7 = (1 << (v3 - 3));
          *(_DWORD *)(a2 + 32) = v7;
          if (v3 != 3)
          {
            if (v6 == 3)
              goto LABEL_17;
            *(_DWORD *)(a2 + 16) = *(_DWORD *)(v4 + 12) / 0x3E8u;
            v9 = 1;
            v7 = (1 << (v3 - 4));
            *(_DWORD *)(a2 + 36) = v7;
            if (v3 != 4)
            {
              if (v6 == 4)
                goto LABEL_17;
              *(_DWORD *)(a2 + 20) = *(_DWORD *)(v4 + 16) / 0x3E8u;
              v7 = 1;
              v4 = (1 << (v3 - 5));
              *(_DWORD *)(a2 + 40) = v4;
              if (v3 != 5)
                goto LABEL_17;
            }
          }
        }
      }
    }
LABEL_25:
    *(_DWORD *)a2 = v3;
    v23 = (_BYTE *)*((_QWORD *)this + 2);
    v24 = (_BYTE *)*((_QWORD *)this + 3);
    *(_DWORD *)(a2 + 44) = (unint64_t)(v24 - v23) >> 2;
    if (v24 != v23)
      memcpy((void *)(a2 + 48), v23, v24 - v23);
    v25 = (void *)*((_QWORD *)this + 10);
    if (v25)
    {
      *((_QWORD *)this + 11) = v25;
      operator delete(v25);
    }
    *((_BYTE *)this + 104) = 0;
  }
}

void webrtc::DefaultTemporalLayers::NextFrameConfig(int64x2_t *this@<X0>, size_t __sz@<X2>, _OWORD *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int v8;
  int v9;
  unsigned int v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  unint64_t v17;
  char v18;
  char v19;
  unsigned __int8 *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char v29;
  char v30;
  char v31;
  uint64_t v32;
  char *v33;
  _BYTE *v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  _OWORD *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  unint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  unint64_t v51;
  uint64_t v52;
  char v53;
  char *v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  BOOL v60;
  unint64_t v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  void *v66;
  void *v67;
  unint64_t v68;
  char *v69;
  char *v70;
  char *v71;
  void *v72;
  void *v73;
  unint64_t v74;
  char *v75;
  char *v76;
  char *v77;
  void *v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  int64_t v85;
  char *v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  uint64_t v93;
  char *v94;
  int64_t v95;
  unint64_t v96;
  char *v97;
  char *v98;
  uint64_t v99;
  uint64_t v100;
  __int128 *v101;
  char *v102;
  uint64_t v103;
  __int128 v104;
  uint64_t v105;
  char *v106;
  unint64_t v107;
  int v108;
  unint64_t v109;
  uint64_t v110;
  char *v111;
  char *v112;
  char *v113;
  BOOL v114;
  int64_t v115;
  unint64_t v116;
  char *v117;
  unint64_t v118;
  uint64_t v119;
  char *v120;
  unint64_t v121;
  unint64_t v122;
  uint64_t v123;
  char *v124;
  char *v125;
  char *v126;
  char *v127;
  char *v128;
  unint64_t v129;
  uint64_t v130;
  __int128 *v131;
  _OWORD *v132;
  uint64_t v133;
  __int128 v134;
  uint64_t v135;
  char *v136;
  char *v137;
  uint64_t v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  unint64_t *v143;
  uint64_t v144;
  __int128 v145;
  __int128 v146;
  uint64_t v147;
  __int128 v148;
  __int128 v149;
  char *v150;
  int v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  char *v156;
  int64_t v157;
  char *v158;
  uint64_t v159;
  uint64_t v160;
  __int128 *v161;
  _OWORD *v162;
  uint64_t v163;
  __int128 v164;
  uint64_t v165;
  unint64_t v166;
  int v167;
  unint64_t v168;
  uint64_t v169;
  char *v170;
  char *v171;
  int64_t v172;
  unint64_t v173;
  char *v174;
  char *v175;
  uint64_t v176;
  uint64_t v177;
  char *v178;
  __int128 *v179;
  _OWORD *v180;
  uint64_t v181;
  __int128 v182;
  uint64_t v183;
  _OWORD *v184;
  char v185;
  char v186;
  char v187;
  _DWORD __sza[3];
  void *__p[2];
  __int128 v190;
  uint64_t v191;
  _BYTE v192[32];
  uint64_t v193;

  v193 = *MEMORY[0x24BDAC8D0];
  v4 = this[4].u8[8];
  v5 = this[2].i64[1];
  v6 = 0xCCCCCCCCCCCCCCCDLL * ((this[3].i64[0] - v5) >> 4);
  v7 = (v4 + 1) % v6;
  this[4].i8[8] = v7;
  v8 = v7;
  if (v6 <= v7)
    goto LABEL_198;
  v9 = __sz;
  v11 = v7;
  v12 = v5 + 80 * v7;
  *(_QWORD *)&__sza[1] = 0;
  if (*(_QWORD *)v12 >= 2uLL)
  {
    if ((*(_QWORD *)v12 & 1) != 0)
    {
      absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::InitFrom((unint64_t *)&__sza[1], (unint64_t *)v12);
      v11 = this[4].u8[8];
    }
    else
    {
      *(_QWORD *)&__sza[1] = *(_QWORD *)v12;
      v13 = *(_OWORD *)(v12 + 8);
      v14 = *(_OWORD *)(v12 + 24);
      v191 = *(_QWORD *)(v12 + 40);
      *(_OWORD *)__p = v13;
      v190 = v14;
    }
  }
  v15 = v5 + 80 * v8;
  v16 = *(_OWORD *)(v15 + 48);
  *(_OWORD *)&v192[16] = *(_OWORD *)(v15 + 64);
  *(_OWORD *)v192 = v16;
  v17 = v11;
  *(_DWORD *)&v192[16] = *(_DWORD *)(this[1].i64[0]
                                   + 4 * (v11 % (unint64_t)((this[1].i64[1] - this[1].i64[0]) >> 2)));
  *(_DWORD *)&v192[20] = *(_DWORD *)&v192[16];
  if (!v11)
  {
    v22 = this[7].i64[1];
    if (this[8].i64[0] != v22)
    {
      v23 = this[9].u64[0];
      v24 = (unint64_t *)(v22 + 8 * (v23 / 0x2E));
      v25 = *v24;
      v26 = *v24 + 88 * (v23 % 0x2E);
      v27 = *(_QWORD *)(v22 + 8 * ((this[9].i64[1] + v23) / 0x2E)) + 88 * ((this[9].i64[1] + v23) % 0x2E);
      while (v26 != v27)
      {
        *(_BYTE *)(v26 + 4) = 1;
        v26 += 88;
        if (v26 - v25 == 4048)
        {
          v28 = v24[1];
          ++v24;
          v25 = v28;
          v26 = v28;
        }
      }
    }
  }
  if ((_DWORD)v4 == 255)
  {
    v192[0] = 0;
    *(_OWORD *)&v192[4] = xmmword_208F08AE0;
    *(_QWORD *)&v192[20] = 0;
    v192[28] = 1;
    v29 = 2;
    v30 = 2;
    v31 = 2;
    goto LABEL_77;
  }
  v18 = v192[8];
  if ((v192[8] & 1) != 0 && (this[4].i8[0] & 2) == 0 && this[10].i64[1] >= v17)
  {
    v18 = v192[8] & 0xFE;
    *(_DWORD *)&v192[8] &= ~1u;
  }
  v19 = v192[12];
  if ((v192[12] & 1) != 0 && (this[4].i8[0] & 4) == 0 && this[11].i64[0] >= v17)
  {
    v19 = v192[12] & 0xFE;
    *(_DWORD *)&v192[12] &= ~1u;
  }
  if ((v192[4] & 1) != 0)
  {
    v32 = this[10].i64[0];
    v33 = (char *)operator new(0x10uLL);
    v21 = v33;
    v34 = v33 + 16;
    *v33 = 1;
    *((_QWORD *)v33 + 1) = v32;
    if ((v18 & 1) == 0)
    {
      v35 = (unsigned __int8 *)(v33 + 16);
      v36 = (unsigned __int8 *)(v33 + 16);
      goto LABEL_40;
    }
  }
  else
  {
    if ((v18 & 1) == 0)
    {
      if ((v19 & 1) == 0)
      {
        v20 = 0;
        v21 = 0;
        goto LABEL_59;
      }
      v35 = 0;
      v36 = 0;
      v21 = 0;
      v47 = this[11].i64[0];
      goto LABEL_47;
    }
    v34 = 0;
    v21 = 0;
  }
  __sza[0] = v9;
  v37 = a3;
  v38 = v34 - v21;
  v39 = (v34 - v21) >> 4;
  v40 = v39 + 1;
  if ((unint64_t)(v39 + 1) >> 60)
    goto LABEL_200;
  if (v38 >> 3 > v40)
    v40 = v38 >> 3;
  if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF0)
    v40 = 0xFFFFFFFFFFFFFFFLL;
  if (!v40)
    goto LABEL_198;
  if (v40 >> 60)
    goto LABEL_199;
  v41 = this[10].i64[1];
  v42 = 16 * v40;
  v43 = (char *)operator new(16 * v40);
  v35 = (unsigned __int8 *)&v43[v42];
  v44 = &v43[16 * v39];
  *v44 = 2;
  *((_QWORD *)v44 + 1) = v41;
  v36 = (unsigned __int8 *)(v44 + 16);
  if (v34 != v21)
  {
    v45 = (v34 - v21 - 16) & 0xFFFFFFFFFFFFFFF0;
    v46 = &v43[v38 - v45 - 16];
    memcpy(v46, &v34[-v45 - 16], v45 + 16);
    v34 = v21;
    v21 = v46;
    a3 = v37;
    v9 = __sza[0];
    if (!v34)
      goto LABEL_40;
    goto LABEL_39;
  }
  v21 = &v43[16 * v39];
  a3 = v37;
  v9 = __sza[0];
  if (v34)
  {
LABEL_39:
    operator delete(v34);
    v19 = v192[12];
  }
LABEL_40:
  if ((v19 & 1) == 0)
  {
    v20 = v36;
    goto LABEL_59;
  }
  v47 = this[11].i64[0];
  if (v36 < v35)
  {
    *v36 = 4;
    *((_QWORD *)v36 + 1) = v47;
    v20 = v36 + 16;
    goto LABEL_59;
  }
LABEL_47:
  v48 = (v36 - (unsigned __int8 *)v21) >> 4;
  v49 = v48 + 1;
  if ((unint64_t)(v48 + 1) >> 60)
LABEL_200:
    abort();
  if ((v35 - (unsigned __int8 *)v21) >> 3 > v49)
    v49 = (v35 - (unsigned __int8 *)v21) >> 3;
  if ((unint64_t)(v35 - (unsigned __int8 *)v21) >= 0x7FFFFFFFFFFFFFF0)
    v49 = 0xFFFFFFFFFFFFFFFLL;
  if (!v49)
    goto LABEL_198;
  if (v49 >> 60)
    goto LABEL_199;
  v50 = (char *)operator new(16 * v49) + 16 * v48;
  *v50 = 4;
  *((_QWORD *)v50 + 1) = v47;
  v20 = (unsigned __int8 *)(v50 + 16);
  if (v36 != (unsigned __int8 *)v21)
  {
    do
    {
      *((_OWORD *)v50 - 1) = *((_OWORD *)v36 - 1);
      v50 -= 16;
      v36 -= 16;
    }
    while (v36 != (unsigned __int8 *)v21);
    v36 = (unsigned __int8 *)v21;
  }
  v21 = v50;
  if (v36)
    operator delete(v36);
LABEL_59:
  v51 = 126 - 2 * __clz((v20 - (unsigned __int8 *)v21) >> 4);
  if (v20 == (unsigned __int8 *)v21)
    v52 = 0;
  else
    v52 = v51;
  std::__introsort<std::_ClassicAlgPolicy,webrtc::DefaultTemporalLayers::UpdateSearchOrder(webrtc::Vp8FrameConfig *)::$_0 &,std::pair<webrtc::Vp8FrameConfig::Vp8BufferReference,unsigned long> *,false>((unint64_t)v21, v20, v52, 1);
  if (v20 != (unsigned __int8 *)v21)
  {
    v192[26] = *v21;
    if ((unint64_t)(v20 - (unsigned __int8 *)v21) >= 0x11)
      v192[27] = v21[16];
    goto LABEL_66;
  }
  if (v20)
LABEL_66:
    operator delete(v21);
  v53 = v192[20];
  v31 = v192[4];
  if (*(_DWORD *)&v192[20])
  {
    v30 = v192[8];
    v53 = (v192[4] & 1) != 0
       && ((v192[8] & 1) == 0 || (this[4].i8[0] & 2) != 0)
       && ((v192[12] & 1) == 0 || (this[4].i8[0] & 4) != 0);
  }
  else
  {
    v30 = v192[8];
  }
  v192[24] = v53;
  this[10] = vaddq_s64(this[10], vdupq_n_s64(1uLL));
  ++this[11].i64[0];
  v29 = v192[12];
LABEL_77:
  v54 = (char *)this[7].i64[1];
  v55 = (char *)this[8].i64[0];
  v56 = (v55 - v54) >> 3;
  v57 = v55 - v54;
  if (v55 == v54)
    v58 = 0;
  else
    v58 = 46 * v56 - 1;
  v59 = this[9].u64[0];
  if (v58 == this[9].i64[1] + v59)
  {
    v60 = v59 >= 0x2E;
    v61 = v59 - 46;
    v186 = v30;
    v187 = v31;
    v185 = v29;
    if (!v60)
    {
      v64 = (char *)this[8].i64[1];
      v65 = (char *)this[7].i64[0];
      if (v56 < (unint64_t)((v64 - v65) >> 3))
      {
        v66 = operator new(0xFD0uLL);
        v67 = v66;
        if (v64 != v55)
        {
          if (v55)
          {
            *(_QWORD *)v55 = v66;
            goto LABEL_160;
          }
LABEL_198:
          __break(1u);
          goto LABEL_199;
        }
        if (v54 == v65)
        {
          v121 = (v64 - v54) >> 2;
          if (v55 == v54)
            v121 = 1;
          if (v121 >> 61)
            goto LABEL_199;
          v122 = (v121 + 3) >> 2;
          v123 = 8 * v121;
          v124 = (char *)operator new(8 * v121);
          v106 = &v124[8 * v122];
          v125 = v106;
          if (v55 != v54)
          {
            v125 = &v106[8 * v56];
            v126 = &v124[8 * v122];
            v127 = v54;
            if ((unint64_t)(v57 - 8) < 0x38)
              goto LABEL_203;
            v128 = &v124[8 * v122];
            v126 = v128;
            v127 = v54;
            if ((unint64_t)(v128 - v54) < 0x20)
              goto LABEL_203;
            v129 = ((unint64_t)(v57 - 8) >> 3) + 1;
            v130 = 8 * (v129 & 0x3FFFFFFFFFFFFFFCLL);
            v126 = &v106[v130];
            v127 = &v54[v130];
            v131 = (__int128 *)(v54 + 16);
            v132 = v128 + 16;
            v133 = v129 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v134 = *v131;
              *(v132 - 1) = *(v131 - 1);
              *v132 = v134;
              v131 += 2;
              v132 += 2;
              v133 -= 4;
            }
            while (v133);
            if (v129 != (v129 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_203:
              do
              {
                v135 = *(_QWORD *)v127;
                v127 += 8;
                *(_QWORD *)v126 = v135;
                v126 += 8;
              }
              while (v126 != v125);
            }
          }
          this[7].i64[0] = (uint64_t)v124;
          this[7].i64[1] = (uint64_t)v106;
          this[8].i64[0] = (uint64_t)v125;
          this[8].i64[1] = (uint64_t)&v124[v123];
          if (v54)
          {
            operator delete(v54);
            v106 = (char *)this[7].i64[1];
          }
        }
        else
        {
          v106 = v54;
        }
        *((_QWORD *)v106 - 1) = v67;
        v137 = (char *)this[7].i64[1];
        v136 = (char *)this[8].i64[0];
        this[7].i64[1] = (uint64_t)(v137 - 8);
        v138 = *((_QWORD *)v137 - 1);
        this[7].i64[1] = (uint64_t)v137;
        if (v136 != (char *)this[8].i64[1])
          goto LABEL_158;
        v150 = (char *)this[7].i64[0];
        if (v137 > v150)
        {
          v151 = v9;
          v152 = (v137 - v150) >> 3;
          if (v152 >= -1)
            v153 = v152 + 1;
          else
            v153 = v152 + 2;
          v154 = v153 >> 1;
          v155 = -v154;
          v156 = &v137[-8 * v154];
          v157 = v136 - v137;
          if (v136 != v137)
          {
            memmove(&v137[-8 * v154], v137, v136 - v137);
            v137 = (char *)this[7].i64[1];
          }
          v136 = &v156[v157];
          this[7].i64[1] = (uint64_t)&v137[8 * v155];
          this[8].i64[0] = (uint64_t)&v156[v157];
          v9 = v151;
          goto LABEL_159;
        }
        v166 = (v136 - v150) >> 2;
        if (v136 == v150)
          v166 = 1;
        if (!(v166 >> 61))
        {
          v167 = v9;
          v168 = v166 >> 2;
          v169 = 8 * v166;
          v170 = (char *)operator new(8 * v166);
          v171 = &v170[8 * v168];
          v172 = v136 - v137;
          v114 = v136 == v137;
          v136 = v171;
          if (v114)
            goto LABEL_196;
          v136 = &v171[v172 & 0xFFFFFFFFFFFFFFF8];
          v173 = v172 - 8;
          if ((unint64_t)(v172 - 8) >= 0x38)
          {
            v175 = &v170[8 * v168];
            v174 = v175;
            if ((unint64_t)(v175 - v137) >= 0x20)
            {
              v176 = (v173 >> 3) + 1;
              v177 = 8 * (v176 & 0x3FFFFFFFFFFFFFFCLL);
              v174 = &v171[v177];
              v178 = &v137[v177];
              v179 = (__int128 *)(v137 + 16);
              v180 = v175 + 16;
              v181 = v176 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v182 = *v179;
                *(v180 - 1) = *(v179 - 1);
                *v180 = v182;
                v179 += 2;
                v180 += 2;
                v181 -= 4;
              }
              while (v181);
              v137 = v178;
              if (v176 == (v176 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_196:
                this[7].i64[0] = (uint64_t)v170;
                this[7].i64[1] = (uint64_t)v171;
                this[8].i64[0] = (uint64_t)v136;
                this[8].i64[1] = (uint64_t)&v170[v169];
                v9 = v167;
                if (v150)
                {
                  operator delete(v150);
                  v136 = (char *)this[8].i64[0];
                }
LABEL_158:
                if (!v136)
                  goto LABEL_198;
LABEL_159:
                *(_QWORD *)v136 = v138;
                goto LABEL_160;
              }
            }
          }
          else
          {
            v174 = &v170[8 * v168];
          }
          do
          {
            v183 = *(_QWORD *)v137;
            v137 += 8;
            *(_QWORD *)v174 = v183;
            v174 += 8;
          }
          while (v174 != v136);
          goto LABEL_196;
        }
LABEL_199:
        std::__throw_bad_array_new_length[abi:sn180100]();
      }
      __sza[0] = v9;
      v184 = a3;
      if (v64 == v65)
        v68 = 1;
      else
        v68 = (v64 - v65) >> 2;
      if (v68 >> 61)
        goto LABEL_199;
      v69 = (char *)operator new(8 * v68);
      v70 = &v69[8 * v56];
      v71 = &v69[8 * v68];
      v72 = operator new(0xFD0uLL);
      v73 = v72;
      if (v56 == v68)
      {
        a3 = v184;
        if (v57 < 1)
        {
          v118 = v57 >> 2;
          if (v55 == v54)
            v118 = 1;
          if (v118 >> 61)
            goto LABEL_199;
          v119 = 8 * v118;
          v70 = (char *)operator new(8 * v118);
          operator delete(v69);
          v71 = &v70[v119];
          v120 = (char *)this[7].i64[1];
          v55 = (char *)this[8].i64[0];
          v69 = v70;
          *(_QWORD *)v70 = v73;
          v75 = v70 + 8;
          if (v55 == v120)
          {
LABEL_99:
            v76 = v70;
            v77 = v75;
            v9 = __sza[0];
LABEL_100:
            v78 = (void *)this[7].i64[0];
            this[7].i64[0] = (uint64_t)v69;
            this[7].i64[1] = (uint64_t)v76;
            v55 = v77;
            this[8].i64[0] = (uint64_t)v77;
            this[8].i64[1] = (uint64_t)v71;
            if (v78)
            {
              operator delete(v78);
              v55 = (char *)this[8].i64[0];
            }
            goto LABEL_161;
          }
        }
        else
        {
          v74 = v56 + 2;
          if (v56 >= -1)
            v74 = v56 + 1;
          v70 -= 8 * (v74 >> 1);
          *(_QWORD *)v70 = v72;
          v75 = v70 + 8;
          if (v55 == v54)
            goto LABEL_99;
        }
      }
      else
      {
        a3 = v184;
        *(_QWORD *)v70 = v72;
        v75 = v70 + 8;
        if (v55 == v54)
          goto LABEL_99;
      }
      v9 = __sza[0];
      while (1)
      {
        if (v70 == v69)
        {
          if (v75 >= v71)
          {
            v91 = (v71 - v70) >> 2;
            if (v71 == v70)
              v91 = 1;
            if (v91 >> 61)
              goto LABEL_199;
            v92 = (v91 + 3) >> 2;
            v93 = 8 * v91;
            v94 = (char *)operator new(8 * v91);
            v69 = v94;
            v87 = &v94[8 * v92];
            v77 = v87;
            v95 = v75 - v70;
            if (v75 != v70)
            {
              v77 = &v87[v95 & 0xFFFFFFFFFFFFFFF8];
              v96 = v95 - 8;
              v97 = &v94[8 * v92];
              v98 = v70;
              if (v96 < 0x38)
                goto LABEL_204;
              v97 = &v94[8 * v92];
              v98 = v70;
              if ((unint64_t)(v97 - v70) < 0x20)
                goto LABEL_204;
              v99 = (v96 >> 3) + 1;
              v100 = 8 * (v99 & 0x3FFFFFFFFFFFFFFCLL);
              v97 = &v87[v100];
              v98 = &v70[v100];
              v101 = (__int128 *)(v70 + 16);
              v102 = &v94[8 * v92 + 16];
              v103 = v99 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v104 = *v101;
                *((_OWORD *)v102 - 1) = *(v101 - 1);
                *(_OWORD *)v102 = v104;
                v101 += 2;
                v102 += 32;
                v103 -= 4;
              }
              while (v103);
              if (v99 != (v99 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_204:
                do
                {
                  v105 = *(_QWORD *)v98;
                  v98 += 8;
                  *(_QWORD *)v97 = v105;
                  v97 += 8;
                }
                while (v97 != v77);
              }
            }
            v71 = &v94[v93];
            operator delete(v70);
            v9 = __sza[0];
          }
          else
          {
            v89 = (v71 - v75) >> 3;
            if (v89 >= -1)
              v90 = v89 + 1;
            else
              v90 = v89 + 2;
            v77 = &v75[8 * (v90 >> 1)];
            v87 = &v70[8 * (v90 >> 1)];
            if (v75 == v70)
            {
              v69 = v75;
            }
            else
            {
              memmove(&v70[8 * (v90 >> 1)], v70, v75 - v70);
              v69 = v70;
            }
          }
        }
        else
        {
          v87 = v70;
          v77 = v75;
        }
        v88 = *((_QWORD *)v55 - 1);
        v55 -= 8;
        *((_QWORD *)v87 - 1) = v88;
        v76 = v87 - 8;
        v75 = v77;
        v70 = v76;
        if (v55 == (char *)this[7].i64[1])
          goto LABEL_100;
      }
    }
    this[9].i64[0] = v61;
    v63 = v54 + 8;
    v62 = *(_QWORD *)v54;
    this[7].i64[1] = (uint64_t)(v54 + 8);
    if (v55 != (char *)this[8].i64[1])
      goto LABEL_84;
    v79 = (char *)this[7].i64[0];
    if (v63 > v79)
    {
      v80 = (v63 - v79) >> 3;
      if (v80 >= -1)
        v81 = v80 + 1;
      else
        v81 = v80 + 2;
      v82 = v81 >> 1;
      v83 = -v82;
      v84 = &v63[-8 * v82];
      v85 = v55 - v63;
      if (v55 != v63)
      {
        memmove(&v63[-8 * v82], v63, v55 - v63);
        v55 = (char *)this[7].i64[1];
      }
      v86 = &v55[8 * v83];
      v55 = &v84[v85];
      this[7].i64[1] = (uint64_t)v86;
      this[8].i64[0] = (uint64_t)&v84[v85];
      goto LABEL_85;
    }
    v107 = (v55 - v79) >> 2;
    if (v55 == v79)
      v107 = 1;
    if (v107 >> 61)
      goto LABEL_199;
    v108 = v9;
    v109 = v107 >> 2;
    v110 = 8 * v107;
    v111 = (char *)operator new(8 * v107);
    v112 = &v111[8 * v109];
    v113 = &v111[v110];
    v115 = v55 - v63;
    v114 = v55 == v63;
    v55 = v112;
    v9 = v108;
    if (!v114)
    {
      v55 = &v112[v115 & 0xFFFFFFFFFFFFFFF8];
      v116 = v115 - 8;
      if ((unint64_t)(v115 - 8) < 0x38)
      {
        v117 = &v111[8 * v109];
        do
        {
LABEL_182:
          v165 = *(_QWORD *)v63;
          v63 += 8;
          *(_QWORD *)v117 = v165;
          v117 += 8;
        }
        while (v117 != v55);
        goto LABEL_183;
      }
      v158 = &v111[8 * v109];
      v117 = v158;
      if ((unint64_t)(v158 - v63) < 0x20)
        goto LABEL_182;
      v159 = (v116 >> 3) + 1;
      v160 = 8 * (v159 & 0x3FFFFFFFFFFFFFFCLL);
      v117 = &v112[v160];
      v63 += v160;
      v161 = (__int128 *)(v54 + 24);
      v162 = v158 + 16;
      v163 = v159 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v164 = *v161;
        *(v162 - 1) = *(v161 - 1);
        *v162 = v164;
        v161 += 2;
        v162 += 2;
        v163 -= 4;
      }
      while (v163);
      if (v159 != (v159 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_182;
    }
LABEL_183:
    this[7].i64[0] = (uint64_t)v111;
    this[7].i64[1] = (uint64_t)v112;
    this[8].i64[0] = (uint64_t)v55;
    this[8].i64[1] = (uint64_t)v113;
    if (v79)
    {
      operator delete(v79);
      v55 = (char *)this[8].i64[0];
    }
LABEL_84:
    if (!v55)
      goto LABEL_198;
LABEL_85:
    *(_QWORD *)v55 = v62;
LABEL_160:
    v55 = (char *)(this[8].i64[0] + 8);
    this[8].i64[0] = (uint64_t)v55;
LABEL_161:
    v54 = (char *)this[7].i64[1];
    v30 = v186;
    v31 = v187;
    v29 = v185;
  }
  if (v55 == v54)
    goto LABEL_198;
  v139 = this[9].i64[1] + this[9].i64[0];
  v140 = *(_QWORD *)&v54[8 * (v139 / 0x2E)];
  if (!v140)
    goto LABEL_198;
  v141 = v139 % 0x2E;
  v142 = v140 + 88 * (v139 % 0x2E);
  *(_DWORD *)v142 = v9;
  *(_BYTE *)(v142 + 4) = 0;
  *(_BYTE *)(v142 + 5) = v30 & 2 | ((v31 & 2) != 0) | (4 * ((v29 & 2) != 0));
  *(_QWORD *)(v142 + 8) = 0;
  v143 = (unint64_t *)(v142 + 8);
  if (*(_QWORD *)&__sza[1] >= 2uLL)
  {
    if ((__sza[1] & 1) != 0)
    {
      absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::InitFrom(v143, (unint64_t *)&__sza[1]);
    }
    else
    {
      *v143 = *(_QWORD *)&__sza[1];
      v144 = v140 + 88 * v141;
      v145 = *(_OWORD *)__p;
      v146 = v190;
      *(_QWORD *)(v144 + 48) = v191;
      *(_OWORD *)(v144 + 16) = v145;
      *(_OWORD *)(v144 + 32) = v146;
    }
  }
  v147 = v140 + 88 * v141;
  v148 = *(_OWORD *)v192;
  *(_OWORD *)(v147 + 72) = *(_OWORD *)&v192[16];
  *(_OWORD *)(v147 + 56) = v148;
  ++this[9].i64[1];
  v149 = *(_OWORD *)&v192[16];
  *a3 = *(_OWORD *)v192;
  a3[1] = v149;
  if ((__sza[1] & 1) != 0)
    operator delete(__p[0]);
}

void webrtc::DefaultTemporalLayers::OnEncodeDone(webrtc::DefaultTemporalLayers *this, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, webrtc::CodecSpecificInfo *a7, uint64_t a8)
{
  uint64_t v10;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _DWORD *v15;
  uint64_t *v16;
  int v17;
  webrtc::GenericFrameInfo *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  webrtc::DefaultTemporalLayers *v26;
  int v27;
  _BYTE *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t *v31;
  char *v32;
  int v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t v37;
  char *v38;
  int v39;
  int v40;
  unsigned int v41;
  _BYTE *v42;
  _BYTE *v43;
  _BYTE *v44;
  _BYTE *v46;
  char v47;
  char v48;
  _BYTE *v49;
  uint64_t v50;
  char v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  int v57;
  int v58;
  uint64_t v59;
  void **v60;
  char *v61;
  unint64_t *v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  void **v69;
  void *v70;
  void *v71;
  void *v72;
  char *v73;
  void **v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  char *v80;
  void **v81;
  __int128 v82;
  char *v83;
  __int128 v84;
  void *v85;
  char *v86;
  void *v87;
  char *v88;
  void *v89;
  char *v90;
  void **v91;
  void **v92;
  void *v93;
  uint64_t *v94;
  uint64_t v95;
  _QWORD *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  char v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  _BYTE *v108;
  int v109;
  char v110;
  _DWORD v111[4];
  uint64_t v112;
  void *v113;
  uint64_t v114;
  void *v115;
  void *__p;
  void **v117;
  uint64_t v118;
  _QWORD v119[3];

  v109 = a5;
  v119[1] = *MEMORY[0x24BDAC8D0];
  if (!a4)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/default_temporal_layers.cc");
    v26 = this;
    v27 = a3;
    goto LABEL_17;
  }
  v10 = *((_QWORD *)this + 19);
  if (!v10)
    goto LABEL_189;
  v12 = *((_QWORD *)this + 18);
  while (1)
  {
    v13 = *(_QWORD *)(*((_QWORD *)this + 15) + 8 * (v12 / 0x2E));
    v14 = v12 % 0x2E;
    v15 = (_DWORD *)(v13 + 88 * (v12 % 0x2E));
    v17 = *v15;
    v16 = (uint64_t *)(v15 + 2);
    if (v17 == a3)
      break;
    if ((*(_BYTE *)v16 & 1) != 0)
    {
      operator delete(*(void **)(v13 + 88 * v14 + 16));
      v10 = *((_QWORD *)this + 19) - 1;
      v12 = *((_QWORD *)this + 18) + 1;
      *((_QWORD *)this + 18) = v12;
      *((_QWORD *)this + 19) = v10;
      if (v12 >= 0x5C)
      {
LABEL_10:
        operator delete(**((void ***)this + 15));
        *((_QWORD *)this + 15) += 8;
        v10 = *((_QWORD *)this + 19);
        v12 = *((_QWORD *)this + 18) - 46;
        *((_QWORD *)this + 18) = v12;
      }
    }
    else
    {
      --v10;
      *((_QWORD *)this + 18) = ++v12;
      *((_QWORD *)this + 19) = v10;
      if (v12 >= 0x5C)
        goto LABEL_10;
    }
    if (!v10)
      goto LABEL_189;
  }
  if (*((_QWORD *)this + 1) == 1)
  {
    *(_WORD *)((char *)a7 + 9) = 255;
    *((_BYTE *)a7 + 12) = 1;
    v18 = (webrtc::CodecSpecificInfo *)((char *)a7 + 1640);
    if (!*((_BYTE *)a7 + 1848))
      goto LABEL_26;
LABEL_25:
    webrtc::GenericFrameInfo::~GenericFrameInfo(v18);
    goto LABEL_26;
  }
  if (!v109)
  {
    v30 = v13 + 88 * v14;
    *((_BYTE *)a7 + 9) = *(_DWORD *)(v30 + 76);
    *((_BYTE *)a7 + 10) = *(_BYTE *)(v30 + 80);
    *((_BYTE *)a7 + 12) = 1;
    v18 = (webrtc::CodecSpecificInfo *)((char *)a7 + 1640);
    if (!*((_BYTE *)a7 + 1848))
      goto LABEL_26;
    goto LABEL_25;
  }
  *((_BYTE *)this + 72) = 0;
  *(_WORD *)((char *)a7 + 9) = 256;
  v28 = (_BYTE *)(v13 + 88 * v14 + 5);
  v29 = *((_QWORD *)this + 8);
  if ((v29 & 1) != 0)
  {
    *((_QWORD *)this + 20) = 0;
    if ((v29 & 2) == 0)
      goto LABEL_82;
LABEL_21:
    *((_QWORD *)this + 21) = 0;
    if ((v29 & 4) != 0)
      goto LABEL_22;
LABEL_83:
    *v28 |= 4u;
    *((_BYTE *)a7 + 12) = 1;
    v18 = (webrtc::CodecSpecificInfo *)((char *)a7 + 1640);
    if (*((_BYTE *)a7 + 1848))
      goto LABEL_25;
  }
  else
  {
    *v28 |= 1u;
    if ((v29 & 2) != 0)
      goto LABEL_21;
LABEL_82:
    *v28 |= 2u;
    if ((v29 & 4) == 0)
      goto LABEL_83;
LABEL_22:
    *((_QWORD *)this + 22) = 0;
    *((_BYTE *)a7 + 12) = 1;
    v18 = (webrtc::CodecSpecificInfo *)((char *)a7 + 1640);
    if (*((_BYTE *)a7 + 1848))
      goto LABEL_25;
  }
LABEL_26:
  *((_QWORD *)a7 + 212) = 0;
  *((_QWORD *)a7 + 215) = 0;
  *(_QWORD *)v18 = 0;
  *((_QWORD *)v18 + 1) = 0;
  v31 = (unint64_t *)((char *)a7 + 1744);
  *((_QWORD *)a7 + 218) = 0;
  *((_QWORD *)a7 + 227) = 0;
  *((_QWORD *)a7 + 229) = 0;
  *((_QWORD *)a7 + 228) = 0;
  *((_QWORD *)a7 + 230) = 0xFFFFFFFFLL;
  *((_BYTE *)a7 + 1848) = 1;
  v32 = (char *)a7 + 48;
  v111[0] = 0;
  if ((v109 & 1) == 0)
  {
    v41 = 0;
    v42 = (_BYTE *)(v13 + 88 * v14);
    v108 = v42 + 68;
    v43 = v42 + 64;
    v44 = v42 + 60;
    while (1)
    {
      LOBYTE(v119[0]) = 0;
      v110 = v109;
      v46 = v44;
      if (v41)
      {
        if (v41 == 2)
        {
          v46 = v108;
        }
        else
        {
          v46 = v43;
          if (v41 != 1)
          {
            v47 = 0;
            v48 = 1;
            goto LABEL_49;
          }
        }
      }
      v48 = 1;
      if ((*v46 & 1) != 0)
      {
        LOBYTE(v119[0]) = 1;
        v50 = *((_QWORD *)a7 + 5);
        *((_QWORD *)a7 + 5) = v50 + 1;
        *((_QWORD *)a7 + v50 + 2) = v41;
        v47 = 1;
        v48 = 0;
        v49 = v44;
        if (!v41)
          goto LABEL_51;
      }
      else
      {
        v47 = 0;
        v49 = v44;
        if (!v41)
          goto LABEL_51;
      }
LABEL_49:
      if (v41 == 2)
      {
        if ((*v108 & 2) != 0)
          goto LABEL_56;
LABEL_52:
        if ((v48 & 1) == 0)
        {
          v51 = 0;
          v52 = *v31;
          if ((*v31 & 1) == 0)
            goto LABEL_57;
          goto LABEL_54;
        }
        v111[0] = v41 + 1;
        if ((int)v41++ >= 2)
          goto LABEL_74;
      }
      else
      {
        v49 = v43;
        if (v41 != 1)
          goto LABEL_52;
LABEL_51:
        if ((*v49 & 2) == 0)
          goto LABEL_52;
LABEL_56:
        v51 = 1;
        v110 = 1;
        v55 = *((_QWORD *)a7 + 9);
        *((_QWORD *)a7 + 9) = v55 + 1;
        *(_QWORD *)&v32[8 * v55] = v41;
        v52 = *v31;
        if ((*v31 & 1) == 0)
        {
LABEL_57:
          v53 = (char *)a7 + 1752;
          v54 = 8;
          goto LABEL_58;
        }
LABEL_54:
        v53 = (char *)*((_QWORD *)a7 + 219);
        v54 = *((_QWORD *)a7 + 220);
LABEL_58:
        if (v52 >> 1 == v54)
        {
          absl::inlined_vector_internal::Storage<webrtc::CodecBufferUsage,8ul,std::allocator<webrtc::CodecBufferUsage>>::EmplaceBackSlow<int &,BOOL &,BOOL &>((uint64_t)a7 + 1744, v111, (char *)v119, &v110);
          v58 = v111[0];
          v41 = ++v111[0];
          if (v58 >= 2)
            goto LABEL_63;
        }
        else
        {
          if (!v53)
            goto LABEL_188;
          v56 = &v53[8 * (v52 >> 1)];
          *(_DWORD *)v56 = v41;
          v56[4] = v47;
          v56[5] = v51;
          *v31 = v52 + 2;
          v57 = v111[0];
          v41 = ++v111[0];
          if (v57 >= 2)
            goto LABEL_63;
        }
      }
    }
  }
  v33 = 0;
  do
  {
    while (1)
    {
      LOBYTE(v119[0]) = 0;
      v110 = 1;
      v34 = *((_QWORD *)a7 + 9);
      *((_QWORD *)a7 + 9) = v34 + 1;
      *(_QWORD *)&v32[8 * v34] = v33;
      v35 = *((_QWORD *)a7 + 218);
      if ((v35 & 1) != 0)
      {
        v36 = (char *)*((_QWORD *)a7 + 219);
        v37 = *((_QWORD *)a7 + 220);
      }
      else
      {
        v36 = (char *)a7 + 1752;
        v37 = 8;
      }
      if (v35 >> 1 != v37)
        break;
      absl::inlined_vector_internal::Storage<webrtc::CodecBufferUsage,8ul,std::allocator<webrtc::CodecBufferUsage>>::EmplaceBackSlow<int &,BOOL &,BOOL &>((uint64_t)a7 + 1744, v111, (char *)v119, &v110);
      v40 = v111[0];
      v33 = ++v111[0];
      if (v40 >= 2)
        goto LABEL_63;
    }
    if (!v36)
      goto LABEL_188;
    v38 = &v36[8 * (v35 >> 1)];
    *(_DWORD *)v38 = v33;
    *((_WORD *)v38 + 2) = 256;
    *v31 = v35 + 2;
    v39 = v111[0];
    v33 = ++v111[0];
  }
  while (v39 < 2);
LABEL_63:
  if ((v109 & 1) == 0)
  {
LABEL_74:
    if ((uint64_t *)((char *)a7 + 1648) != v16)
    {
      v64 = *v16;
      v67 = v16[1];
      v66 = v16 + 1;
      v65 = v67;
      if ((v64 & 1) != 0)
        v68 = v65;
      else
        v68 = (uint64_t)v66;
      absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<webrtc::DecodeTargetIndication>,webrtc::DecodeTargetIndication const*>>((unint64_t *)a7 + 206, v68, v64 >> 1);
    }
    *((_DWORD *)a7 + 411) = *(_DWORD *)(v13 + 88 * v14 + 76);
    if (!*(_BYTE *)(v13 + 88 * v14 + 4))
      goto LABEL_175;
    goto LABEL_179;
  }
  v59 = *((unsigned int *)this + 2);
  if ((int)v59 >= 5)
    goto LABEL_190;
  if ((int)v59 <= 0)
  {
LABEL_191:
    v26 = (webrtc::DefaultTemporalLayers *)rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/default_temporal_layers.cc", 597, "num_layers > 0", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, a5, a6, (uint64_t)a7, a8, v59);
LABEL_17:
    webrtc::DefaultTemporalLayers::OnFrameDropped(v26, v19, v27, v21, v22, v23, v24, v25);
    return;
  }
  v111[1] = *((_DWORD *)this + 2);
  v111[2] = 0;
  v112 = 0;
  v114 = 0;
  v117 = 0;
  v118 = 0;
  __p = 0;
  v111[0] = 0;
  switch((int)v59)
  {
    case 1:
      std::vector<webrtc::FrameDependencyTemplate>::resize((uint64_t)&__p, 2uLL);
      v60 = (void **)__p;
      if (v117 == __p)
        goto LABEL_188;
      *((_DWORD *)__p + 1) = 0;
      if (((_BYTE)v60[1] & 1) != 0)
        operator delete(v60[2]);
      v60[1] = (void *)2;
      *((_DWORD *)v60 + 4) = 2;
      v61 = (char *)__p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 1)
        goto LABEL_188;
      *((_DWORD *)__p + 27) = 0;
      if ((v61[112] & 1) != 0)
        operator delete(*((void **)v61 + 15));
      *((_QWORD *)v61 + 14) = 2;
      *((_DWORD *)v61 + 30) = 2;
      LODWORD(v119[0]) = 1;
      v62 = (unint64_t *)(v61 + 160);
      v63 = 1;
      goto LABEL_149;
    case 2:
      std::vector<webrtc::FrameDependencyTemplate>::resize((uint64_t)&__p, 5uLL);
      v69 = (void **)__p;
      if (v117 == __p)
        goto LABEL_188;
      *((_DWORD *)__p + 1) = 0;
      if (((_BYTE)v69[1] & 1) != 0)
        operator delete(v69[2]);
      v69[1] = (void *)4;
      v69[2] = (void *)0x200000002;
      v70 = __p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 1)
        goto LABEL_188;
      *((_DWORD *)__p + 27) = 0;
      if ((*((_BYTE *)v70 + 112) & 1) != 0)
        operator delete(*((void **)v70 + 15));
      *((_QWORD *)v70 + 14) = 4;
      *((_QWORD *)v70 + 15) = 0x200000002;
      LODWORD(v119[0]) = 2;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v70 + 20, (uint64_t)v119, 1uLL);
      v71 = __p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 2)
        goto LABEL_188;
      *((_DWORD *)__p + 53) = 0;
      if ((*((_BYTE *)v71 + 216) & 1) != 0)
        operator delete(*((void **)v71 + 28));
      *((_QWORD *)v71 + 27) = 4;
      *((_QWORD *)v71 + 28) = 0x300000002;
      LODWORD(v119[0]) = 2;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v71 + 33, (uint64_t)v119, 1uLL);
      v72 = __p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 3)
        goto LABEL_188;
      *((_DWORD *)__p + 79) = 1;
      if ((*((_BYTE *)v72 + 320) & 1) != 0)
        operator delete(*((void **)v72 + 41));
      *((_QWORD *)v72 + 40) = 4;
      *((_QWORD *)v72 + 41) = 0x200000000;
      LODWORD(v119[0]) = 1;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v72 + 46, (uint64_t)v119, 1uLL);
      v73 = (char *)__p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 4)
        goto LABEL_188;
      *((_DWORD *)__p + 105) = 1;
      if ((v73[424] & 1) != 0)
        operator delete(*((void **)v73 + 54));
      *((_QWORD *)v73 + 53) = 4;
      *((_QWORD *)v73 + 54) = 0x100000000;
      v119[0] = 0x100000002;
      v62 = (unint64_t *)(v73 + 472);
      goto LABEL_148;
    case 3:
      std::vector<webrtc::FrameDependencyTemplate>::resize((uint64_t)&__p, 7uLL);
      v74 = (void **)__p;
      if (v117 == __p)
        goto LABEL_188;
      *((_DWORD *)__p + 1) = 0;
      if (((_BYTE)v74[1] & 1) != 0)
        operator delete(v74[2]);
      v74[1] = (void *)6;
      v74[2] = (void *)0x200000002;
      *((_DWORD *)v74 + 6) = 2;
      v75 = __p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 1)
        goto LABEL_188;
      *((_DWORD *)__p + 27) = 0;
      if ((*((_BYTE *)v75 + 112) & 1) != 0)
        operator delete(*((void **)v75 + 15));
      *((_QWORD *)v75 + 14) = 6;
      *((_QWORD *)v75 + 15) = 0x200000002;
      *((_DWORD *)v75 + 32) = 2;
      LODWORD(v119[0]) = 4;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v75 + 20, (uint64_t)v119, 1uLL);
      v76 = __p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 2)
        goto LABEL_188;
      *((_DWORD *)__p + 53) = 0;
      if ((*((_BYTE *)v76 + 216) & 1) != 0)
        operator delete(*((void **)v76 + 28));
      *((_QWORD *)v76 + 27) = 6;
      *((_QWORD *)v76 + 28) = 0x300000002;
      *((_DWORD *)v76 + 58) = 3;
      LODWORD(v119[0]) = 4;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v76 + 33, (uint64_t)v119, 1uLL);
      v77 = __p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 3)
        goto LABEL_188;
      *((_DWORD *)__p + 79) = 1;
      if ((*((_BYTE *)v77 + 320) & 1) != 0)
        operator delete(*((void **)v77 + 41));
      *((_QWORD *)v77 + 40) = 6;
      *((_QWORD *)v77 + 41) = 0x200000000;
      *((_DWORD *)v77 + 84) = 2;
      LODWORD(v119[0]) = 2;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v77 + 46, (uint64_t)v119, 1uLL);
      v78 = __p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 4)
        goto LABEL_188;
      *((_DWORD *)__p + 105) = 1;
      if ((*((_BYTE *)v78 + 424) & 1) != 0)
        operator delete(*((void **)v78 + 54));
      *((_QWORD *)v78 + 53) = 6;
      *((_QWORD *)v78 + 54) = 0x100000000;
      *((_DWORD *)v78 + 110) = 2;
      v119[0] = 0x200000004;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v78 + 59, (uint64_t)v119, 2uLL);
      v79 = __p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 5)
        goto LABEL_188;
      *((_DWORD *)__p + 131) = 2;
      if ((*((_BYTE *)v79 + 528) & 1) != 0)
        operator delete(*((void **)v79 + 67));
      *((_QWORD *)v79 + 66) = 6;
      *((_QWORD *)v79 + 67) = 0;
      *((_DWORD *)v79 + 136) = 1;
      LODWORD(v119[0]) = 1;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v79 + 72, (uint64_t)v119, 1uLL);
      v80 = (char *)__p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 6)
        goto LABEL_188;
      *((_DWORD *)__p + 157) = 2;
      if ((v80[632] & 1) != 0)
        operator delete(*((void **)v80 + 80));
      *((_QWORD *)v80 + 79) = 6;
      *((_QWORD *)v80 + 80) = 0;
      *((_DWORD *)v80 + 162) = 1;
      v119[0] = 0x100000003;
      v62 = (unint64_t *)(v80 + 680);
      goto LABEL_148;
    case 4:
      std::vector<webrtc::FrameDependencyTemplate>::resize((uint64_t)&__p, 8uLL);
      v81 = (void **)__p;
      if (v117 == __p)
        goto LABEL_188;
      *((_DWORD *)__p + 1) = 0;
      if (((_BYTE)v81[1] & 1) != 0)
        operator delete(v81[2]);
      v81[1] = (void *)8;
      *(_QWORD *)&v82 = 0x200000002;
      *((_QWORD *)&v82 + 1) = 0x200000002;
      *((_OWORD *)v81 + 1) = v82;
      v83 = (char *)__p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 1)
        goto LABEL_188;
      *((_DWORD *)__p + 27) = 0;
      if ((v83[112] & 1) != 0)
        operator delete(*((void **)v83 + 15));
      *((_QWORD *)v83 + 14) = 8;
      *(_QWORD *)&v84 = 0x200000002;
      *((_QWORD *)&v84 + 1) = 0x200000002;
      *(_OWORD *)(v83 + 120) = v84;
      LODWORD(v119[0]) = 8;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v83 + 20, (uint64_t)v119, 1uLL);
      v85 = __p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 2)
        goto LABEL_188;
      *((_DWORD *)__p + 53) = 1;
      if ((*((_BYTE *)v85 + 216) & 1) != 0)
        operator delete(*((void **)v85 + 28));
      *((_QWORD *)v85 + 27) = 8;
      *((_OWORD *)v85 + 14) = xmmword_208F08AF0;
      LODWORD(v119[0]) = 4;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v85 + 33, (uint64_t)v119, 1uLL);
      v86 = (char *)__p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 3)
        goto LABEL_188;
      *((_DWORD *)__p + 79) = 1;
      if ((v86[320] & 1) != 0)
        operator delete(*((void **)v86 + 41));
      *((_QWORD *)v86 + 40) = 8;
      *(_OWORD *)(v86 + 328) = xmmword_208F08AF0;
      v119[0] = 0x800000004;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v86 + 46, (uint64_t)v119, 2uLL);
      v87 = __p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 4)
        goto LABEL_188;
      *((_DWORD *)__p + 105) = 2;
      if ((*((_BYTE *)v87 + 424) & 1) != 0)
        operator delete(*((void **)v87 + 54));
      *((_QWORD *)v87 + 53) = 8;
      *((_OWORD *)v87 + 27) = xmmword_208F08B00;
      LODWORD(v119[0]) = 2;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v87 + 59, (uint64_t)v119, 1uLL);
      v88 = (char *)__p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 5)
        goto LABEL_188;
      *((_DWORD *)__p + 131) = 2;
      if ((v88[528] & 1) != 0)
        operator delete(*((void **)v88 + 67));
      *((_QWORD *)v88 + 66) = 8;
      *(_OWORD *)(v88 + 536) = xmmword_208F08B00;
      v119[0] = 0x400000002;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v88 + 72, (uint64_t)v119, 2uLL);
      v89 = __p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 6)
        goto LABEL_188;
      *((_DWORD *)__p + 157) = 3;
      if ((*((_BYTE *)v89 + 632) & 1) != 0)
        operator delete(*((void **)v89 + 80));
      *((_QWORD *)v89 + 79) = 8;
      *((_OWORD *)v89 + 40) = xmmword_208F08B10;
      LODWORD(v119[0]) = 1;
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>((unint64_t *)v89 + 85, (uint64_t)v119, 1uLL);
      v90 = (char *)__p;
      if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((char *)v117 - (_BYTE *)__p) >> 3)) <= 7)
        goto LABEL_188;
      *((_DWORD *)__p + 183) = 3;
      if ((v90[736] & 1) != 0)
        operator delete(*((void **)v90 + 93));
      *((_QWORD *)v90 + 92) = 8;
      *(_OWORD *)(v90 + 744) = xmmword_208F08B10;
      v119[0] = 0x300000001;
      v62 = (unint64_t *)(v90 + 784);
LABEL_148:
      v63 = 2;
LABEL_149:
      absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>(v62, (uint64_t)v119, v63);
      break;
    default:
      break;
  }
  std::optional<webrtc::FrameDependencyStructure>::operator=[abi:sn180100]<webrtc::FrameDependencyStructure,void>((uint64_t)a7 + 1856, (uint64_t)v111);
  v91 = (void **)__p;
  if (__p)
  {
    v92 = v117;
    v93 = __p;
    if (v117 == __p)
    {
LABEL_162:
      v117 = v91;
      operator delete(v93);
      goto LABEL_163;
    }
    while (2)
    {
      if ((*(_BYTE *)(v92 - 3) & 1) != 0)
      {
        operator delete(*(v92 - 2));
        if ((*(_BYTE *)(v92 - 6) & 1) != 0)
          goto LABEL_159;
LABEL_156:
        if ((*(_BYTE *)(v92 - 12) & 1) != 0)
LABEL_160:
          operator delete(*(v92 - 11));
      }
      else
      {
        if ((*(_BYTE *)(v92 - 6) & 1) == 0)
          goto LABEL_156;
LABEL_159:
        operator delete(*(v92 - 5));
        if ((*(_BYTE *)(v92 - 12) & 1) != 0)
          goto LABEL_160;
      }
      v92 -= 13;
      if (v92 == v91)
      {
        v93 = __p;
        goto LABEL_162;
      }
      continue;
    }
  }
LABEL_163:
  if ((v114 & 1) == 0)
  {
    if ((v112 & 1) == 0)
      goto LABEL_165;
LABEL_168:
    operator delete(v113);
    v94 = (uint64_t *)*((_QWORD *)this + 5);
    if (v94 != *((uint64_t **)this + 6))
      goto LABEL_169;
LABEL_188:
    __break(1u);
LABEL_189:
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/default_temporal_layers.cc", 486, "!pending_frames_.empty()", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, (uint64_t)a7, a8, v107);
LABEL_190:
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/default_temporal_layers.cc", 596, "num_layers < 5", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, a5, a6, (uint64_t)a7, a8, v59);
    goto LABEL_191;
  }
  operator delete(v115);
  if ((v112 & 1) != 0)
    goto LABEL_168;
LABEL_165:
  v94 = (uint64_t *)*((_QWORD *)this + 5);
  if (v94 == *((uint64_t **)this + 6))
    goto LABEL_188;
LABEL_169:
  if ((uint64_t *)((char *)a7 + 1648) != v94)
  {
    v95 = *v94;
    v98 = v94[1];
    v96 = v94 + 1;
    v97 = v98;
    if ((v95 & 1) != 0)
      v99 = v97;
    else
      v99 = (uint64_t)v96;
    absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<webrtc::DecodeTargetIndication>,webrtc::DecodeTargetIndication const*>>((unint64_t *)a7 + 206, v99, v95 >> 1);
  }
  *((_DWORD *)a7 + 411) = 0;
  if (*(_BYTE *)(v13 + 88 * v14 + 4))
    goto LABEL_179;
LABEL_175:
  v100 = *(_BYTE *)(v13 + 88 * v14 + 5);
  if ((v100 & 1) == 0)
  {
    if ((*(_BYTE *)(v13 + 88 * v14 + 5) & 2) == 0)
      goto LABEL_177;
LABEL_186:
    *((_QWORD *)this + 21) = 0;
    if ((v100 & 4) == 0)
      goto LABEL_179;
LABEL_178:
    *((_QWORD *)this + 22) = 0;
    goto LABEL_179;
  }
  *((_QWORD *)this + 20) = 0;
  if ((v100 & 2) != 0)
    goto LABEL_186;
LABEL_177:
  if ((v100 & 4) != 0)
    goto LABEL_178;
LABEL_179:
  v101 = *((_QWORD *)this + 18);
  v102 = *(_QWORD *)(*((_QWORD *)this + 15) + 8 * (v101 / 0x2E));
  if (!v102)
    goto LABEL_188;
  if ((*(_BYTE *)(v102 + 88 * (v101 % 0x2E) + 8) & 1) == 0)
  {
    v103 = *((_QWORD *)this + 19) - 1;
    v104 = v101 + 1;
    *((_QWORD *)this + 18) = v104;
    *((_QWORD *)this + 19) = v103;
    if (v104 < 0x5C)
      return;
LABEL_184:
    operator delete(**((void ***)this + 15));
    *((_QWORD *)this + 15) += 8;
    *((_QWORD *)this + 18) -= 46;
    return;
  }
  operator delete(*(void **)(v102 + 88 * (v101 % 0x2E) + 16));
  v105 = *((_QWORD *)this + 19) - 1;
  v106 = *((_QWORD *)this + 18) + 1;
  *((_QWORD *)this + 18) = v106;
  *((_QWORD *)this + 19) = v105;
  if (v106 >= 0x5C)
    goto LABEL_184;
}

void webrtc::DefaultTemporalLayers::OnFrameDropped(webrtc::DefaultTemporalLayers *this, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int *v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  std::string *v20;
  uint64_t v21;

  v8 = *((_QWORD *)this + 19);
  if (!v8)
  {
LABEL_15:
    v20 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/default_temporal_layers.cc", 582, "!pending_frames_.empty()", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v21);
    std::optional<webrtc::FrameDependencyStructure>::operator=[abi:sn180100]<webrtc::FrameDependencyStructure,void>(v20);
    return;
  }
  v11 = *((_QWORD *)this + 18);
  while (1)
  {
    v12 = *(_QWORD *)(*((_QWORD *)this + 15) + 8 * (v11 / 0x2E));
    v13 = v11 % 0x2E;
    v14 = (int *)(v12 + 88 * (v11 % 0x2E));
    v15 = *v14;
    v16 = *((_QWORD *)v14 + 1);
    if (v15 == a3)
      break;
    if ((v16 & 1) != 0)
    {
      operator delete(*(void **)(v12 + 88 * v13 + 16));
      v8 = *((_QWORD *)this + 19) - 1;
      v11 = *((_QWORD *)this + 18) + 1;
      *((_QWORD *)this + 18) = v11;
      *((_QWORD *)this + 19) = v8;
      if (v11 >= 0x5C)
      {
LABEL_9:
        operator delete(**((void ***)this + 15));
        *((_QWORD *)this + 15) += 8;
        v8 = *((_QWORD *)this + 19);
        v11 = *((_QWORD *)this + 18) - 46;
        *((_QWORD *)this + 18) = v11;
      }
    }
    else
    {
      --v8;
      *((_QWORD *)this + 18) = ++v11;
      *((_QWORD *)this + 19) = v8;
      if (v11 >= 0x5C)
        goto LABEL_9;
    }
    if (!v8)
      goto LABEL_15;
  }
  if ((v16 & 1) == 0)
  {
    v17 = v11 + 1;
    *((_QWORD *)this + 18) = v17;
    *((_QWORD *)this + 19) = v8 - 1;
    if (v17 < 0x5C)
      return;
LABEL_14:
    operator delete(**((void ***)this + 15));
    *((_QWORD *)this + 15) += 8;
    *((_QWORD *)this + 18) -= 46;
    return;
  }
  operator delete(*(void **)(v12 + 88 * v13 + 16));
  v18 = *((_QWORD *)this + 19) - 1;
  v19 = *((_QWORD *)this + 18) + 1;
  *((_QWORD *)this + 18) = v19;
  *((_QWORD *)this + 19) = v18;
  if (v19 >= 0x5C)
    goto LABEL_14;
}

__n128 std::optional<webrtc::FrameDependencyStructure>::operator=[abi:sn180100]<webrtc::FrameDependencyStructure,void>(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __n128 result;
  __int128 v10;
  __int128 v11;
  __int128 v12;

  v4 = *(unsigned __int8 *)(a1 + 128);
  v5 = *(_DWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 8) = v5;
  if (v4)
  {
    if (a1 != a2)
    {
      if ((*(_BYTE *)(a1 + 16) & 1) != 0)
        operator delete(*(void **)(a1 + 24));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
      v6 = *(_OWORD *)(a2 + 24);
      v7 = *(_OWORD *)(a2 + 40);
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 40) = v7;
      *(_OWORD *)(a1 + 24) = v6;
      *(_QWORD *)(a2 + 16) = 0;
      if ((*(_BYTE *)(a1 + 64) & 1) != 0)
        operator delete(*(void **)(a1 + 72));
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      v8 = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
      *(_OWORD *)(a1 + 72) = v8;
      *(_QWORD *)(a2 + 64) = 0;
    }
    result.n128_u64[0] = std::vector<webrtc::FrameDependencyTemplate>::__move_assign((void **)(a1 + 104), (__n128 *)(a2 + 104)).n128_u64[0];
  }
  else
  {
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    v10 = *(_OWORD *)(a2 + 24);
    v11 = *(_OWORD *)(a2 + 40);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v11;
    *(_OWORD *)(a1 + 24) = v10;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
    v12 = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = v12;
    *(_QWORD *)(a2 + 64) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    result = *(__n128 *)(a2 + 104);
    *(__n128 *)(a1 + 104) = result;
    *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
    *(_QWORD *)(a2 + 104) = 0;
    *(_QWORD *)(a2 + 112) = 0;
    *(_QWORD *)(a2 + 120) = 0;
    *(_BYTE *)(a1 + 128) = 1;
  }
  return result;
}

void std::vector<webrtc::FrameDependencyTemplate>::resize(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = 0x4EC4EC4EC4EC4EC5 * ((v3 - *(_QWORD *)a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<webrtc::FrameDependencyTemplate>::__append((char **)a1, v6);
    return;
  }
  if (!v5)
  {
    v7 = *(_QWORD *)a1 + 104 * a2;
    while (1)
    {
      if (v3 == v7)
      {
        *(_QWORD *)(a1 + 8) = v7;
        return;
      }
      if ((*(_BYTE *)(v3 - 24) & 1) != 0)
      {
        operator delete(*(void **)(v3 - 16));
        if ((*(_BYTE *)(v3 - 48) & 1) != 0)
        {
LABEL_13:
          operator delete(*(void **)(v3 - 40));
          if ((*(_BYTE *)(v3 - 96) & 1) == 0)
            goto LABEL_6;
          goto LABEL_14;
        }
      }
      else if ((*(_BYTE *)(v3 - 48) & 1) != 0)
      {
        goto LABEL_13;
      }
      if ((*(_BYTE *)(v3 - 96) & 1) == 0)
        goto LABEL_6;
LABEL_14:
      operator delete(*(void **)(v3 - 88));
LABEL_6:
      v3 -= 104;
    }
  }
}

void *absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::InitFrom(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v5;
  void *v6;
  const void *v7;
  unint64_t v8;
  void *result;

  v2 = *a2;
  if (*a2 <= 1)
  {
    __break(1u);
    goto LABEL_11;
  }
  v5 = v2 >> 1;
  if ((v2 & 1) != 0)
  {
    if (v5 <= 0x14)
      v8 = 20;
    else
      v8 = v2 >> 1;
    if (!(v8 >> 62))
    {
      v6 = operator new(4 * v8);
      a1[1] = (unint64_t)v6;
      a1[2] = v8;
      v7 = (const void *)a2[1];
      goto LABEL_9;
    }
LABEL_11:
    std::__throw_bad_array_new_length[abi:sn180100]();
  }
  v6 = a1 + 1;
  v7 = a2 + 1;
LABEL_9:
  result = memcpy(v6, v7, 4 * v5);
  *a1 = *a2;
  return result;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,webrtc::DefaultTemporalLayers::UpdateSearchOrder(webrtc::Vp8FrameConfig *)::$_0 &,std::pair<webrtc::Vp8FrameConfig::Vp8BufferReference,unsigned long> *,false>(unint64_t result, unsigned __int8 *a2, uint64_t a3, char a4)
{
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned __int8 *v12;
  unsigned int v13;
  unint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unsigned int v17;
  unint64_t v18;
  BOOL v19;
  _BOOL4 v20;
  unsigned int v21;
  unint64_t v22;
  unsigned int v23;
  unint64_t v24;
  BOOL v25;
  _BOOL4 v26;
  unsigned int v27;
  unint64_t v28;
  unsigned int v29;
  unint64_t v30;
  _BOOL4 v31;
  unsigned int v32;
  unint64_t v33;
  unsigned int v34;
  unint64_t v35;
  _BOOL4 v36;
  unint64_t v37;
  unsigned int v38;
  unint64_t v39;
  _BOOL4 v40;
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  unsigned int v43;
  unsigned int v44;
  unint64_t v45;
  unsigned int v46;
  unint64_t v47;
  BOOL v48;
  BOOL v49;
  unsigned int v50;
  unint64_t v51;
  _BOOL4 v52;
  unsigned int v53;
  unint64_t v54;
  unsigned int v55;
  unint64_t v56;
  _BOOL4 v57;
  unsigned int v58;
  unint64_t v59;
  _BOOL4 v60;
  unint64_t v61;
  unsigned int v62;
  unint64_t v63;
  _BOOL4 v64;
  unsigned __int8 *v65;
  unsigned __int8 *v66;
  unsigned int v67;
  unsigned int v68;
  unint64_t v69;
  unsigned int v70;
  unint64_t v71;
  BOOL v72;
  BOOL v73;
  unsigned int v74;
  unint64_t v75;
  _BOOL4 v76;
  unsigned int v77;
  unint64_t v78;
  unsigned int v79;
  unint64_t v80;
  _BOOL4 v81;
  unsigned int v82;
  unint64_t v83;
  _BOOL4 v84;
  unsigned int v85;
  unint64_t v86;
  unsigned int v87;
  unint64_t v88;
  BOOL v89;
  unsigned int v90;
  unint64_t v91;
  unsigned __int8 v92;
  unsigned __int8 *v93;
  uint64_t v94;
  unint64_t v95;
  BOOL v96;
  BOOL v97;
  uint64_t v98;
  unsigned __int8 *v99;
  unint64_t v100;
  unsigned int v101;
  unint64_t v102;
  BOOL v103;
  unsigned int v104;
  unint64_t v105;
  _BOOL4 v106;
  _BOOL4 v107;
  unsigned int v108;
  unint64_t v109;
  BOOL v110;
  BOOL v111;
  unsigned __int8 v112;
  unint64_t v113;
  uint64_t v114;
  unsigned __int8 *v115;
  unint64_t v116;
  BOOL v117;
  unsigned int v118;
  unint64_t v119;
  _BOOL4 v120;
  _BOOL4 v121;
  unsigned __int8 *v122;
  BOOL v123;
  BOOL v124;
  unint64_t v125;
  BOOL v126;
  unsigned __int8 *v127;
  BOOL v128;
  unsigned int v129;
  unint64_t v130;
  BOOL v131;
  unsigned __int8 v132;
  unsigned __int8 *v133;
  unint64_t v134;
  _BOOL4 v135;
  unsigned int v136;
  unint64_t v137;
  BOOL v138;
  BOOL v139;
  unsigned int v140;
  unint64_t v141;
  unsigned int v142;
  unint64_t v143;
  _BOOL4 v144;
  BOOL v145;
  unsigned int v146;
  unsigned __int8 *v147;
  _BOOL4 v148;
  unsigned int v149;
  unint64_t v150;
  unsigned int v151;
  unint64_t v152;
  _BOOL4 v153;
  unsigned int v154;
  unint64_t v155;
  unsigned int v156;
  unint64_t v157;
  _BOOL4 v158;
  unsigned int v159;
  unint64_t v160;
  _BOOL4 v161;
  BOOL v162;
  char v163;
  uint64_t v164;
  unsigned __int8 *v165;
  uint64_t v166;
  unsigned int v167;
  unint64_t v168;
  unsigned int v169;
  unint64_t v170;
  _BOOL4 v171;
  _BOOL4 v172;
  uint64_t v173;
  unsigned __int8 *v174;
  unint64_t v175;
  BOOL v176;
  int64_t v177;
  int64_t v178;
  int64_t v179;
  uint64_t v180;
  unsigned __int8 *v181;
  unint64_t v182;
  unsigned int v183;
  unint64_t v184;
  _BOOL4 v185;
  unsigned __int8 *v186;
  unsigned int v187;
  unsigned __int8 *v188;
  unint64_t v189;
  unint64_t v190;
  _BOOL4 v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v195;
  unsigned __int8 v196;
  uint64_t v197;
  int64_t v198;
  unsigned __int8 *v199;
  unsigned int v200;
  unint64_t v201;
  unint64_t v202;
  _BOOL4 v203;
  unsigned __int8 *v204;
  uint64_t v205;
  uint64_t v206;
  unint64_t v207;
  unsigned __int8 *v208;
  unsigned int v209;
  unint64_t v210;
  unsigned int v211;
  unint64_t v212;
  _BOOL4 v213;
  unsigned __int8 *v214;
  unint64_t v215;
  BOOL v216;
  unsigned int v217;
  unint64_t v218;
  _BOOL4 v219;
  uint64_t v220;
  unsigned __int8 *v221;
  unint64_t v222;
  unsigned int v223;
  unint64_t v224;
  _BOOL4 v225;
  _QWORD *v226;
  unint64_t v227;
  _QWORD *v228;
  uint64_t v229;
  unint64_t v231;
  BOOL v232;
  BOOL v233;
  unsigned int v234;
  unsigned __int8 *v235;
  _BOOL4 v236;

  v7 = (unsigned __int8 *)result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = a2 - v8;
    v10 = (a2 - v8) >> 4;
    switch(v10)
    {
      case 0:
      case 1:
        return result;
      case 2:
        v140 = *(a2 - 16);
        v141 = *((_QWORD *)a2 - 1);
        v142 = *v8;
        v143 = *((_QWORD *)v8 + 1);
        v144 = v140 < v142;
        if (v141 != v143)
          v144 = v141 < v143;
        if (v144)
        {
          *v8 = v140;
          *(a2 - 16) = v142;
          *((_QWORD *)v8 + 1) = v141;
          *((_QWORD *)a2 - 1) = v143;
        }
        return result;
      case 3:
        LODWORD(v100) = v8[16];
        v99 = (unsigned __int8 *)*((_QWORD *)v8 + 3);
        LODWORD(v61) = *v8;
        v37 = *((_QWORD *)v8 + 1);
        if (v99 == (unsigned __int8 *)v37)
          v145 = v100 < v61;
        else
          v145 = (unint64_t)v99 < v37;
        v146 = *(a2 - 16);
        v147 = (unsigned __int8 *)*((_QWORD *)a2 - 1);
        v148 = v146 < v100;
        if (v147 != v99)
          v148 = v147 < v99;
        if (v145)
        {
          if (!v148)
            goto LABEL_294;
          *v8 = v146;
          *(a2 - 16) = v61;
          *((_QWORD *)v8 + 1) = v147;
          goto LABEL_298;
        }
        if (v148)
        {
          v8[16] = v146;
          *(a2 - 16) = v100;
          *((_QWORD *)v8 + 3) = v147;
          *((_QWORD *)a2 - 1) = v99;
          v154 = v8[16];
          v155 = *((_QWORD *)v8 + 3);
          goto LABEL_277;
        }
        return result;
      case 4:
        return (unint64_t)std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::DefaultTemporalLayers::UpdateSearchOrder(webrtc::Vp8FrameConfig *)::$_0 &,std::pair<webrtc::Vp8FrameConfig::Vp8BufferReference,unsigned long> *>(v8, v8 + 16, v8 + 32, a2 - 16);
      case 5:
        result = (unint64_t)std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::DefaultTemporalLayers::UpdateSearchOrder(webrtc::Vp8FrameConfig *)::$_0 &,std::pair<webrtc::Vp8FrameConfig::Vp8BufferReference,unsigned long> *>(v8, v8 + 16, v8 + 32, v8 + 48);
        v149 = *(a2 - 16);
        v150 = *((_QWORD *)a2 - 1);
        v151 = v8[48];
        v152 = *((_QWORD *)v8 + 7);
        v153 = v149 < v151;
        if (v150 != v152)
          v153 = v150 < v152;
        if (v153)
        {
          v8[48] = v149;
          *(a2 - 16) = v151;
          *((_QWORD *)v8 + 7) = v150;
          *((_QWORD *)a2 - 1) = v152;
          v154 = v8[48];
          v155 = *((_QWORD *)v8 + 7);
          v156 = v8[32];
          v157 = *((_QWORD *)v8 + 5);
          v158 = v154 < v156;
          if (v155 != v157)
            v158 = v155 < v157;
          if (v158)
          {
            v8[32] = v154;
            v8[48] = v156;
            *((_QWORD *)v8 + 5) = v155;
            *((_QWORD *)v8 + 7) = v157;
            v159 = v8[16];
            v160 = *((_QWORD *)v8 + 3);
            v161 = v154 < v159;
            if (v155 != v160)
              v161 = v155 < v160;
            if (v161)
            {
              v8[16] = v154;
              v8[32] = v159;
              *((_QWORD *)v8 + 3) = v155;
              *((_QWORD *)v8 + 5) = v160;
LABEL_277:
              v217 = *v8;
              v218 = *((_QWORD *)v8 + 1);
              v219 = v154 < v217;
              if (v155 != v218)
                v219 = v155 < v218;
              if (v219)
              {
                *v8 = v154;
                v8[16] = v217;
                *((_QWORD *)v8 + 1) = v155;
                *((_QWORD *)v8 + 3) = v218;
              }
            }
          }
        }
        return result;
      default:
        if (v9 > 383)
        {
          if (!a3)
          {
            if (v8 != a2)
            {
              v177 = (unint64_t)(v10 - 2) >> 1;
              v178 = v177;
              do
              {
                v179 = v178;
                if (v177 >= v178)
                {
                  v180 = (2 * v178) | 1;
                  v181 = &v8[16 * v180];
                  if (2 * v179 + 2 >= v10)
                  {
                    v183 = *v181;
                  }
                  else
                  {
                    v182 = *((_QWORD *)v181 + 1);
                    v183 = v181[16];
                    v184 = *((_QWORD *)v181 + 3);
                    v162 = v182 == v184;
                    v185 = v182 < v184;
                    if (v162)
                      v185 = *v181 < v183;
                    if (v185)
                    {
                      v181 += 16;
                      v180 = 2 * v179 + 2;
                    }
                    else
                    {
                      v183 = *v181;
                    }
                  }
                  v186 = &v8[16 * v179];
                  result = *((_QWORD *)v181 + 1);
                  v187 = *v186;
                  v188 = (unsigned __int8 *)*((_QWORD *)v186 + 1);
                  v162 = result == (_QWORD)v188;
                  LODWORD(result) = result < (unint64_t)v188;
                  if (v162)
                    result = v183 < v187;
                  else
                    result = result;
                  if ((result & 1) == 0)
                  {
                    do
                    {
                      result = (unint64_t)v186;
                      v186 = v181;
                      *(_BYTE *)result = v183;
                      *(_QWORD *)(result + 8) = *((_QWORD *)v181 + 1);
                      if (v177 < v180)
                        break;
                      v192 = (2 * v180) | 1;
                      v181 = &v8[16 * v192];
                      v180 = 2 * v180 + 2;
                      if (v180 < v10)
                      {
                        v183 = *v181;
                        v189 = *((_QWORD *)v181 + 1);
                        v190 = *((_QWORD *)v181 + 3);
                        v162 = v189 == v190;
                        v191 = v189 < v190;
                        if (v162)
                          v191 = v183 < v181[16];
                        if (v191)
                        {
                          v183 = v181[16];
                          v181 += 16;
                        }
                        else
                        {
                          v180 = v192;
                        }
                      }
                      else
                      {
                        v183 = *v181;
                        v180 = v192;
                      }
                      result = *((_QWORD *)v181 + 1);
                      v162 = result == (_QWORD)v188;
                      LODWORD(result) = result < (unint64_t)v188;
                      result = v162 ? v183 < v187 : result;
                    }
                    while ((_DWORD)result != 1);
                    *v186 = v187;
                    *((_QWORD *)v186 + 1) = v188;
                  }
                }
                v178 = v179 - 1;
              }
              while (v179);
              v193 = (unint64_t)v9 >> 4;
              do
              {
                v195 = 0;
                v196 = *v8;
                v197 = *((_QWORD *)v8 + 1);
                v198 = (unint64_t)(v193 - 2) >> 1;
                v199 = v8;
                do
                {
                  while (1)
                  {
                    v204 = &v199[16 * v195 + 16];
                    v205 = (2 * v195) | 1;
                    v195 = 2 * v195 + 2;
                    if (v195 < v193)
                      break;
                    v195 = v205;
                    *v199 = *v204;
                    *((_QWORD *)v199 + 1) = *((_QWORD *)v204 + 1);
                    v199 = v204;
                    if (v205 > v198)
                      goto LABEL_265;
                  }
                  v200 = *v204;
                  v201 = *((_QWORD *)v204 + 1);
                  result = (unint64_t)(v204 + 16);
                  v202 = *((_QWORD *)v204 + 3);
                  v162 = v201 == v202;
                  v203 = v201 < v202;
                  if (v162)
                    v203 = v200 < v204[16];
                  if (v203)
                  {
                    LOBYTE(v200) = v204[16];
                    v204 += 16;
                  }
                  else
                  {
                    v195 = v205;
                  }
                  *v199 = v200;
                  *((_QWORD *)v199 + 1) = *((_QWORD *)v204 + 1);
                  v199 = v204;
                }
                while (v195 <= v198);
LABEL_265:
                if (v204 == a2 - 16)
                {
                  *v204 = v196;
                  *((_QWORD *)v204 + 1) = v197;
                }
                else
                {
                  *v204 = *(a2 - 16);
                  *((_QWORD *)v204 + 1) = *((_QWORD *)a2 - 1);
                  *(a2 - 16) = v196;
                  *((_QWORD *)a2 - 1) = v197;
                  v206 = v204 - v8 + 16;
                  if (v206 >= 17)
                  {
                    v207 = (((unint64_t)v206 >> 4) - 2) >> 1;
                    v208 = &v8[16 * v207];
                    v209 = *v208;
                    v210 = *((_QWORD *)v208 + 1);
                    v211 = *v204;
                    v212 = *((_QWORD *)v204 + 1);
                    v162 = v210 == v212;
                    v213 = v210 < v212;
                    if (v162)
                      v213 = v209 < v211;
                    if (v213)
                    {
                      do
                      {
                        v214 = v204;
                        v204 = v208;
                        *v214 = v209;
                        *((_QWORD *)v214 + 1) = *((_QWORD *)v208 + 1);
                        if (!v207)
                          break;
                        v207 = (v207 - 1) >> 1;
                        v208 = &v8[16 * v207];
                        v209 = *v208;
                        v215 = *((_QWORD *)v208 + 1);
                        v162 = v215 == v212;
                        v216 = v215 < v212;
                        if (v162)
                          v216 = v209 < v211;
                      }
                      while (v216);
                      *v204 = v211;
                      *((_QWORD *)v204 + 1) = v212;
                    }
                  }
                }
                a2 -= 16;
              }
              while (v193-- > 2);
            }
            return result;
          }
          v11 = (unint64_t)v10 >> 1;
          v12 = &v8[16 * ((unint64_t)v10 >> 1)];
          v13 = *(a2 - 16);
          v14 = *((_QWORD *)a2 - 1);
          if ((unint64_t)v9 < 0x801)
          {
            v21 = *v8;
            v22 = *((_QWORD *)v8 + 1);
            v23 = *v12;
            v24 = *((_QWORD *)v12 + 1);
            v25 = v22 < v24;
            if (v22 == v24)
              v25 = v21 < v23;
            v26 = v13 < v21;
            if (v14 != v22)
              v26 = v14 < v22;
            if (v25)
            {
              if (v26)
              {
                *v12 = v13;
                *(a2 - 16) = v23;
                *((_QWORD *)v12 + 1) = v14;
LABEL_54:
                *((_QWORD *)a2 - 1) = v24;
                goto LABEL_55;
              }
              *v12 = v21;
              *v8 = v23;
              *((_QWORD *)v12 + 1) = v22;
              *((_QWORD *)v8 + 1) = v24;
              v58 = *(a2 - 16);
              v59 = *((_QWORD *)a2 - 1);
              v60 = v58 < v23;
              if (v59 != v24)
                v60 = v59 < v24;
              if (v60)
              {
                *v8 = v58;
                *(a2 - 16) = v23;
                *((_QWORD *)v8 + 1) = v59;
                goto LABEL_54;
              }
            }
            else if (v26)
            {
              *v8 = v13;
              *(a2 - 16) = v21;
              *((_QWORD *)v8 + 1) = v14;
              *((_QWORD *)a2 - 1) = v22;
              v32 = *v8;
              v33 = *((_QWORD *)v8 + 1);
              v34 = *v12;
              v35 = *((_QWORD *)v12 + 1);
              v36 = v32 < v34;
              if (v33 != v35)
                v36 = v33 < v35;
              if (v36)
              {
                *v12 = v32;
                *v8 = v34;
                *((_QWORD *)v12 + 1) = v33;
                *((_QWORD *)v8 + 1) = v35;
                --a3;
                v37 = v34;
                if ((a4 & 1) != 0)
                  goto LABEL_56;
                goto LABEL_100;
              }
            }
LABEL_55:
            --a3;
            v37 = *v8;
            if ((a4 & 1) != 0)
              goto LABEL_56;
LABEL_100:
            v95 = *((_QWORD *)v8 - 1);
            v61 = *((_QWORD *)v8 + 1);
            v96 = *(v8 - 16) < v37;
            v162 = v95 == v61;
            v97 = v95 < v61;
            if (!v162)
              v96 = v97;
            if (v96)
              goto LABEL_103;
            v100 = *((_QWORD *)a2 - 1);
            v124 = v37 < *(a2 - 16);
            v162 = v61 == v100;
            LOBYTE(v100) = v61 < v100;
            if (!v162)
              v124 = v100;
            if (v124)
            {
              v99 = v8 + 16;
              do
              {
                if (v99 == a2)
                  goto LABEL_293;
                v125 = *((_QWORD *)v99 + 1);
                LOBYTE(v100) = v37 < *v99;
                v162 = v61 == v125;
                v126 = v61 < v125;
                if (!v162)
                  LOBYTE(v100) = v126;
                v99 += 16;
              }
              while ((v100 & 1) == 0);
              v8 = v99 - 16;
            }
            else
            {
              v127 = v8 + 16;
              do
              {
                v8 = v127;
                if (v127 >= a2)
                  break;
                v100 = *((_QWORD *)v127 + 1);
                v128 = v37 < *v127;
                v162 = v61 == v100;
                LOBYTE(v100) = v61 < v100;
                if (v162)
                  LOBYTE(v100) = v128;
                v127 = v8 + 16;
              }
              while ((v100 & 1) == 0);
            }
            v99 = a2;
            if (v8 < a2)
            {
              v99 = a2;
              while (v99 != v7)
              {
                v129 = *(v99 - 16);
                v99 -= 16;
                v130 = *((_QWORD *)v99 + 1);
                LOBYTE(v100) = v37 < v129;
                v162 = v61 == v130;
                v131 = v61 < v130;
                if (!v162)
                  LOBYTE(v100) = v131;
                if ((v100 & 1) == 0)
                  goto LABEL_161;
              }
              goto LABEL_293;
            }
LABEL_161:
            if (v8 < v99)
            {
              LOBYTE(v100) = *v8;
              v132 = *v99;
              do
              {
                *v8 = v132;
                *v99 = v100;
                v100 = *((_QWORD *)v8 + 1);
                *((_QWORD *)v8 + 1) = *((_QWORD *)v99 + 1);
                *((_QWORD *)v99 + 1) = v100;
                v133 = v8 + 16;
                do
                {
                  if (v133 == a2)
                    goto LABEL_293;
                  LODWORD(v100) = *v133;
                  v134 = *((_QWORD *)v133 + 1);
                  v162 = v61 == v134;
                  v135 = v61 < v134;
                  if (v162)
                    v135 = v37 < v100;
                  v133 += 16;
                }
                while (!v135);
                v8 = v133 - 16;
                do
                {
                  if (v99 == v7)
                    goto LABEL_293;
                  v136 = *(v99 - 16);
                  v99 -= 16;
                  v132 = v136;
                  v137 = *((_QWORD *)v99 + 1);
                  v138 = v37 < v136;
                  v162 = v61 == v137;
                  v139 = v61 < v137;
                  if (v162)
                    v139 = v138;
                }
                while (v139);
              }
              while (v8 < v99);
            }
            if (v8 - 16 != v7)
            {
              *v7 = *(v8 - 16);
              *((_QWORD *)v7 + 1) = *((_QWORD *)v8 - 1);
            }
            a4 = 0;
            *(v8 - 16) = v37;
            *((_QWORD *)v8 - 1) = v61;
            continue;
          }
          v15 = *v12;
          v16 = *((_QWORD *)v12 + 1);
          v17 = *v8;
          v18 = *((_QWORD *)v8 + 1);
          v19 = v16 < v18;
          if (v16 == v18)
            v19 = v15 < v17;
          v20 = v13 < v15;
          if (v14 != v16)
            v20 = v14 < v16;
          if (v19)
          {
            if (v20)
            {
              *v8 = v13;
              *(a2 - 16) = v17;
              *((_QWORD *)v8 + 1) = v14;
LABEL_36:
              *((_QWORD *)a2 - 1) = v18;
              goto LABEL_37;
            }
            *v8 = v15;
            *v12 = v17;
            *((_QWORD *)v8 + 1) = v16;
            *((_QWORD *)v12 + 1) = v18;
            v38 = *(a2 - 16);
            v39 = *((_QWORD *)a2 - 1);
            v40 = v38 < v17;
            if (v39 != v18)
              v40 = v39 < v18;
            if (v40)
            {
              *v12 = v38;
              *(a2 - 16) = v17;
              *((_QWORD *)v12 + 1) = v39;
              goto LABEL_36;
            }
          }
          else if (v20)
          {
            *v12 = v13;
            *(a2 - 16) = v15;
            *((_QWORD *)v12 + 1) = v14;
            *((_QWORD *)a2 - 1) = v16;
            v27 = *v12;
            v28 = *((_QWORD *)v12 + 1);
            v29 = *v8;
            v30 = *((_QWORD *)v8 + 1);
            v31 = v27 < v29;
            if (v28 != v30)
              v31 = v28 < v30;
            if (v31)
            {
              *v8 = v27;
              *v12 = v29;
              *((_QWORD *)v8 + 1) = v28;
              *((_QWORD *)v12 + 1) = v30;
            }
          }
LABEL_37:
          v41 = &v8[16 * v11];
          v44 = *(v41 - 16);
          v42 = v41 - 16;
          v43 = v44;
          v45 = *((_QWORD *)v42 + 1);
          v46 = v8[16];
          v47 = *((_QWORD *)v8 + 3);
          v48 = v44 < v46;
          if (v45 == v47)
            v49 = v48;
          else
            v49 = v45 < v47;
          v50 = *(a2 - 32);
          v51 = *((_QWORD *)a2 - 3);
          v52 = v50 < v43;
          if (v51 != v45)
            v52 = v51 < v45;
          if (v49)
          {
            if (v52)
            {
              v8[16] = v50;
              *(a2 - 32) = v46;
              *((_QWORD *)v8 + 3) = v51;
LABEL_61:
              *((_QWORD *)a2 - 3) = v47;
              goto LABEL_62;
            }
            v8[16] = v43;
            *v42 = v46;
            *((_QWORD *)v8 + 3) = v45;
            *((_QWORD *)v42 + 1) = v47;
            v62 = *(a2 - 32);
            v63 = *((_QWORD *)a2 - 3);
            v64 = v62 < v46;
            if (v63 != v47)
              v64 = v63 < v47;
            if (v64)
            {
              *v42 = v62;
              *(a2 - 32) = v46;
              *((_QWORD *)v42 + 1) = v63;
              goto LABEL_61;
            }
          }
          else if (v52)
          {
            *v42 = v50;
            *(a2 - 32) = v43;
            *((_QWORD *)v42 + 1) = v51;
            *((_QWORD *)a2 - 3) = v45;
            v53 = *v42;
            v54 = *((_QWORD *)v42 + 1);
            v55 = v8[16];
            v56 = *((_QWORD *)v8 + 3);
            v57 = v53 < v55;
            if (v54 != v56)
              v57 = v54 < v56;
            if (v57)
            {
              v8[16] = v53;
              *v42 = v55;
              *((_QWORD *)v8 + 3) = v54;
              *((_QWORD *)v42 + 1) = v56;
            }
          }
LABEL_62:
          v65 = &v8[16 * v11];
          v68 = v65[16];
          v66 = v65 + 16;
          v67 = v68;
          v69 = *((_QWORD *)v66 + 1);
          v70 = v8[32];
          v71 = *((_QWORD *)v8 + 5);
          v72 = v68 < v70;
          if (v69 == v71)
            v73 = v72;
          else
            v73 = v69 < v71;
          v74 = *(a2 - 48);
          v75 = *((_QWORD *)a2 - 5);
          v76 = v74 < v67;
          if (v75 != v69)
            v76 = v75 < v69;
          if (v73)
          {
            if (v76)
            {
              v8[32] = v74;
              *(a2 - 48) = v70;
              *((_QWORD *)v8 + 5) = v75;
LABEL_79:
              *((_QWORD *)a2 - 5) = v71;
              goto LABEL_80;
            }
            v8[32] = v67;
            *v66 = v70;
            *((_QWORD *)v8 + 5) = v69;
            *((_QWORD *)v66 + 1) = v71;
            v82 = *(a2 - 48);
            v83 = *((_QWORD *)a2 - 5);
            v84 = v82 < v70;
            if (v83 != v71)
              v84 = v83 < v71;
            if (v84)
            {
              *v66 = v82;
              *(a2 - 48) = v70;
              *((_QWORD *)v66 + 1) = v83;
              goto LABEL_79;
            }
          }
          else if (v76)
          {
            *v66 = v74;
            *(a2 - 48) = v67;
            *((_QWORD *)v66 + 1) = v75;
            *((_QWORD *)a2 - 5) = v69;
            v77 = *v66;
            v78 = *((_QWORD *)v66 + 1);
            v79 = v8[32];
            v80 = *((_QWORD *)v8 + 5);
            v81 = v77 < v79;
            if (v78 != v80)
              v81 = v78 < v80;
            if (v81)
            {
              v8[32] = v77;
              *v66 = v79;
              *((_QWORD *)v8 + 5) = v78;
              *((_QWORD *)v66 + 1) = v80;
            }
          }
LABEL_80:
          v85 = *v12;
          v86 = *((_QWORD *)v12 + 1);
          v87 = *v42;
          v88 = *((_QWORD *)v42 + 1);
          if (v86 == v88)
            v89 = v85 < v87;
          else
            v89 = v86 < v88;
          v90 = *v66;
          v91 = *((_QWORD *)v66 + 1);
          if (v91 == v86)
            result = v90 < v85;
          else
            result = v91 < v86;
          if (v89)
          {
            if ((result & 1) == 0)
            {
              *v42 = v85;
              *v12 = v87;
              result = v91 == v88 ? v90 < v87 : v91 < v88;
              *((_QWORD *)v42 + 1) = v86;
              *((_QWORD *)v12 + 1) = v88;
              v42 = v12;
              v86 = v91;
              LOBYTE(v85) = v90;
              if ((_DWORD)result != 1)
              {
                v86 = v88;
                LOBYTE(v85) = v87;
                goto LABEL_99;
              }
            }
LABEL_98:
            *v42 = v90;
            *v66 = v87;
            *((_QWORD *)v42 + 1) = v91;
            *((_QWORD *)v66 + 1) = v88;
            goto LABEL_99;
          }
          if (!(_DWORD)result)
            goto LABEL_99;
          *v12 = v90;
          *v66 = v85;
          *((_QWORD *)v12 + 1) = v91;
          *((_QWORD *)v66 + 1) = v86;
          if (v91 == v88)
            result = v90 < v87;
          else
            result = v91 < v88;
          v66 = v12;
          v86 = v88;
          LOBYTE(v85) = v87;
          if ((result & 1) != 0)
            goto LABEL_98;
          v86 = v91;
          LOBYTE(v85) = v90;
LABEL_99:
          v92 = *v8;
          *v8 = v85;
          *v12 = v92;
          v93 = &v8[16 * v11];
          v94 = *((_QWORD *)v8 + 1);
          *((_QWORD *)v8 + 1) = v86;
          *((_QWORD *)v93 + 1) = v94;
          --a3;
          v37 = *v8;
          if ((a4 & 1) == 0)
            goto LABEL_100;
LABEL_56:
          v61 = *((_QWORD *)v8 + 1);
LABEL_103:
          v98 = 0;
          do
          {
            v99 = &v8[v98];
            v100 = (unint64_t)&v8[v98 + 16];
            if ((unsigned __int8 *)v100 == a2)
              goto LABEL_293;
            v101 = *(unsigned __int8 *)v100;
            v102 = *((_QWORD *)v99 + 3);
            v162 = v102 == v61;
            v103 = v102 < v61;
            if (v162)
              v103 = v101 < v37;
            v98 += 16;
          }
          while (v103);
          v99 = &v8[v98];
          v100 = (unint64_t)a2;
          if (v98 != 16)
          {
            while ((unsigned __int8 *)v100 != v8)
            {
              v104 = *(unsigned __int8 *)(v100 - 16);
              v100 -= 16;
              v105 = *(_QWORD *)(v100 + 8);
              v106 = v104 < v37;
              v162 = v105 == v61;
              v107 = v105 < v61;
              if (!v162)
                v106 = v107;
              if (v106)
                goto LABEL_119;
            }
            goto LABEL_293;
          }
          v100 = (unint64_t)a2;
          do
          {
            if ((unint64_t)v99 >= v100)
              break;
            v108 = *(unsigned __int8 *)(v100 - 16);
            v100 -= 16;
            v109 = *(_QWORD *)(v100 + 8);
            v110 = v108 < v37;
            v162 = v109 == v61;
            v111 = v109 < v61;
            if (!v162)
              v110 = v111;
          }
          while (!v110);
LABEL_119:
          if ((unint64_t)v99 >= v100)
          {
            v8 = v99;
            v122 = v99 - 16;
            if (v99 - 16 == v7)
              goto LABEL_134;
          }
          else
          {
            v112 = *(_BYTE *)v100;
            v8 = v99;
            v113 = v100;
            do
            {
              *v8 = v112;
              *(_BYTE *)v113 = v101;
              v114 = *((_QWORD *)v8 + 1);
              *((_QWORD *)v8 + 1) = *(_QWORD *)(v113 + 8);
              *(_QWORD *)(v113 + 8) = v114;
              v115 = v8 + 16;
              do
              {
                if (v115 == a2)
                  goto LABEL_293;
                v101 = *v115;
                v116 = *((_QWORD *)v115 + 1);
                v162 = v116 == v61;
                v117 = v116 < v61;
                if (v162)
                  v117 = v101 < v37;
                v115 += 16;
              }
              while (v117);
              v8 = v115 - 16;
              do
              {
                if ((unsigned __int8 *)v113 == v7)
                  goto LABEL_293;
                v118 = *(unsigned __int8 *)(v113 - 16);
                v113 -= 16;
                v112 = v118;
                v119 = *(_QWORD *)(v113 + 8);
                v120 = v118 < v37;
                v162 = v119 == v61;
                v121 = v119 < v61;
                if (v162)
                  v121 = v120;
              }
              while (!v121);
            }
            while ((unint64_t)v8 < v113);
            v122 = v8 - 16;
            if (v8 - 16 == v7)
              goto LABEL_134;
          }
          *v7 = *(v8 - 16);
          *((_QWORD *)v7 + 1) = *((_QWORD *)v8 - 1);
LABEL_134:
          *(v8 - 16) = v37;
          *((_QWORD *)v8 - 1) = v61;
          if ((unint64_t)v99 < v100)
            goto LABEL_137;
          v123 = std::__insertion_sort_incomplete[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::DefaultTemporalLayers::UpdateSearchOrder(webrtc::Vp8FrameConfig *)::$_0 &,std::pair<webrtc::Vp8FrameConfig::Vp8BufferReference,unsigned long> *>(v7, v122);
          result = std::__insertion_sort_incomplete[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::DefaultTemporalLayers::UpdateSearchOrder(webrtc::Vp8FrameConfig *)::$_0 &,std::pair<webrtc::Vp8FrameConfig::Vp8BufferReference,unsigned long> *>(v8, a2);
          if (!(_DWORD)result)
          {
            if (v123)
              continue;
LABEL_137:
            result = std::__introsort<std::_ClassicAlgPolicy,webrtc::DefaultTemporalLayers::UpdateSearchOrder(webrtc::Vp8FrameConfig *)::$_0 &,std::pair<webrtc::Vp8FrameConfig::Vp8BufferReference,unsigned long> *,false>(v7, v122, a3, a4 & 1);
            a4 = 0;
            continue;
          }
          a2 = v122;
          if (v123)
            return result;
          goto LABEL_2;
        }
        v100 = (unint64_t)(v8 + 16);
        v162 = v8 == a2 || v100 == (_QWORD)a2;
        v163 = v162;
        if ((a4 & 1) != 0)
        {
          if ((v163 & 1) == 0)
          {
            v164 = 0;
            v165 = v8;
            do
            {
              v167 = v165[16];
              v168 = *((_QWORD *)v165 + 3);
              v169 = *v165;
              v170 = *((_QWORD *)v165 + 1);
              v165 = (unsigned __int8 *)v100;
              v171 = v167 < v169;
              v162 = v168 == v170;
              v172 = v168 < v170;
              if (!v162)
                v171 = v172;
              if (v171)
              {
                v173 = v164;
                do
                {
                  v174 = &v8[v173];
                  v174[16] = v169;
                  *((_QWORD *)v174 + 3) = *(_QWORD *)&v8[v173 + 8];
                  if (!v173)
                  {
                    v166 = (uint64_t)v8;
                    goto LABEL_213;
                  }
                  v169 = *(v174 - 16);
                  v175 = *((_QWORD *)v174 - 1);
                  v162 = v168 == v175;
                  v176 = v168 < v175;
                  if (v162)
                    v176 = v167 < v169;
                  v173 -= 16;
                }
                while (v176);
                v166 = (uint64_t)&v8[v173 + 16];
LABEL_213:
                *(_BYTE *)v166 = v167;
                *(_QWORD *)(v166 + 8) = v168;
              }
              v100 = (unint64_t)(v165 + 16);
              v164 += 16;
            }
            while (v165 + 16 != a2);
          }
        }
        else if ((v163 & 1) == 0)
        {
          v99 = 0;
          v37 = (unint64_t)(v8 + 24);
          v61 = -2;
          v220 = 1;
          while (1)
          {
            v221 = &v8[16 * (_QWORD)v99];
            v99 = (unsigned __int8 *)v220;
            LODWORD(v100) = *(unsigned __int8 *)v100;
            v222 = *((_QWORD *)v221 + 3);
            v223 = *v221;
            v224 = *((_QWORD *)v221 + 1);
            v162 = v222 == v224;
            v225 = v222 < v224;
            if (v162)
              v225 = v100 < v223;
            if (v225)
              break;
LABEL_283:
            v220 = (uint64_t)(v99 + 1);
            v100 = (unint64_t)&v8[16 * (_QWORD)(v99 + 1)];
            --v61;
            v37 += 16;
            if ((unsigned __int8 *)v100 == a2)
              return result;
          }
          v226 = (_QWORD *)v37;
          v227 = v61;
          v228 = (_QWORD *)v37;
          while (1)
          {
            *((_BYTE *)v226 - 8) = v223;
            v229 = *(v228 - 2);
            v228 -= 2;
            *v226 = v229;
            if (__CFADD__(v227++, 1))
              break;
            v223 = *((unsigned __int8 *)v226 - 40);
            v231 = *(v226 - 4);
            v232 = v100 < v223;
            v162 = v222 == v231;
            v233 = v222 < v231;
            if (!v162)
              v232 = v233;
            v226 = v228;
            if (!v232)
            {
              *((_BYTE *)v228 - 8) = v100;
              *v228 = v222;
              goto LABEL_283;
            }
          }
LABEL_293:
          __break(1u);
LABEL_294:
          *v7 = v100;
          v7[16] = v61;
          *((_QWORD *)v7 + 1) = v99;
          *((_QWORD *)v7 + 3) = v37;
          v234 = *(a2 - 16);
          v235 = (unsigned __int8 *)*((_QWORD *)a2 - 1);
          v236 = v234 < v61;
          if (v235 != (unsigned __int8 *)v37)
            v236 = (unint64_t)v235 < v37;
          if (v236)
          {
            v7[16] = v234;
            *(a2 - 16) = v61;
            *((_QWORD *)v7 + 3) = v235;
LABEL_298:
            *((_QWORD *)a2 - 1) = v37;
          }
        }
        return result;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::DefaultTemporalLayers::UpdateSearchOrder(webrtc::Vp8FrameConfig *)::$_0 &,std::pair<webrtc::Vp8FrameConfig::Vp8BufferReference,unsigned long> *>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned int v6;
  unint64_t v7;
  unsigned int v8;
  unint64_t v9;
  _BOOL4 v10;
  unsigned int v11;
  unint64_t v12;
  unsigned int v13;
  unint64_t v14;
  BOOL v15;
  unsigned int v16;
  unint64_t v17;
  _BOOL4 v18;
  unsigned __int8 *v19;
  unsigned int v20;
  unsigned int v21;
  _BYTE *v22;
  unint64_t *v23;
  unint64_t v24;
  unsigned int v25;
  unint64_t v26;
  unint64_t *v27;
  BOOL v28;
  unint64_t v29;
  _BOOL4 v30;
  _BYTE *v31;
  unsigned int v32;
  unint64_t v33;
  unsigned int v34;
  unint64_t v35;
  _BOOL4 v36;
  unsigned int v37;
  unint64_t v38;
  unsigned int v39;
  unint64_t v40;
  _BOOL4 v41;
  unsigned int v42;
  unint64_t v43;
  _BOOL4 v44;
  unsigned int v45;
  unint64_t v46;
  _BOOL4 v47;
  unsigned int v48;
  unint64_t v49;
  unsigned int v50;
  unint64_t v51;
  _BOOL4 v52;
  BOOL v53;
  unsigned __int8 *v54;
  uint64_t v55;
  int v56;
  unsigned int v57;
  unint64_t v58;
  unsigned int v59;
  unint64_t v60;
  BOOL v61;
  _BOOL4 v62;
  uint64_t v63;
  unsigned __int8 *v64;
  unint64_t v65;
  BOOL v66;
  unsigned __int8 *v67;
  unsigned int v68;
  unint64_t v69;
  _BOOL4 v70;
  _BOOL4 v71;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 16);
      v7 = *((_QWORD *)a2 - 1);
      v8 = *a1;
      v9 = *((_QWORD *)a1 + 1);
      v10 = v6 < v8;
      if (v7 != v9)
        v10 = v7 < v9;
      if (v10)
      {
        *a1 = v6;
        *(a2 - 16) = v8;
        *((_QWORD *)a1 + 1) = v7;
        *((_QWORD *)a2 - 1) = v9;
      }
      return result;
    case 3:
      v11 = a1[16];
      v12 = *((_QWORD *)a1 + 3);
      v13 = *a1;
      v14 = *((_QWORD *)a1 + 1);
      if (v12 == v14)
        v15 = v11 < v13;
      else
        v15 = v12 < v14;
      v16 = *(a2 - 16);
      v17 = *((_QWORD *)a2 - 1);
      v18 = v16 < v11;
      if (v17 != v12)
        v18 = v17 < v12;
      if (v15)
      {
        if (v18)
        {
          *a1 = v16;
          *(a2 - 16) = v13;
          *((_QWORD *)a1 + 1) = v17;
          *((_QWORD *)a2 - 1) = v14;
        }
        else
        {
          *a1 = v11;
          a1[16] = v13;
          *((_QWORD *)a1 + 1) = v12;
          *((_QWORD *)a1 + 3) = v14;
          v68 = *(a2 - 16);
          v69 = *((_QWORD *)a2 - 1);
          v70 = v68 < v13;
          if (v69 != v14)
            v70 = v69 < v14;
          if (v70)
          {
            a1[16] = v68;
            *(a2 - 16) = v13;
            *((_QWORD *)a1 + 3) = v69;
            *((_QWORD *)a2 - 1) = v14;
          }
        }
      }
      else if (v18)
      {
        a1[16] = v16;
        *(a2 - 16) = v11;
        *((_QWORD *)a1 + 3) = v17;
        *((_QWORD *)a2 - 1) = v12;
        v48 = a1[16];
        v49 = *((_QWORD *)a1 + 3);
        v50 = *a1;
        v51 = *((_QWORD *)a1 + 1);
        v52 = v48 < v50;
        if (v49 != v51)
          v52 = v49 < v51;
        if (v52)
        {
          *a1 = v48;
          a1[16] = v50;
          *((_QWORD *)a1 + 1) = v49;
          *((_QWORD *)a1 + 3) = v51;
        }
      }
      return result;
    case 4:
      std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::DefaultTemporalLayers::UpdateSearchOrder(webrtc::Vp8FrameConfig *)::$_0 &,std::pair<webrtc::Vp8FrameConfig::Vp8BufferReference,unsigned long> *>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::DefaultTemporalLayers::UpdateSearchOrder(webrtc::Vp8FrameConfig *)::$_0 &,std::pair<webrtc::Vp8FrameConfig::Vp8BufferReference,unsigned long> *>(a1, a1 + 16, a1 + 32, a1 + 48);
      v32 = *(a2 - 16);
      v33 = *((_QWORD *)a2 - 1);
      v34 = a1[48];
      v35 = *((_QWORD *)a1 + 7);
      v36 = v32 < v34;
      if (v33 != v35)
        v36 = v33 < v35;
      if (!v36)
        return 1;
      a1[48] = v32;
      *(a2 - 16) = v34;
      *((_QWORD *)a1 + 7) = v33;
      *((_QWORD *)a2 - 1) = v35;
      v37 = a1[48];
      v38 = *((_QWORD *)a1 + 7);
      v39 = a1[32];
      v40 = *((_QWORD *)a1 + 5);
      v41 = v37 < v39;
      if (v38 != v40)
        v41 = v38 < v40;
      if (!v41)
        return 1;
      a1[32] = v37;
      a1[48] = v39;
      *((_QWORD *)a1 + 5) = v38;
      *((_QWORD *)a1 + 7) = v40;
      v42 = a1[16];
      v43 = *((_QWORD *)a1 + 3);
      v44 = v37 < v42;
      if (v38 != v43)
        v44 = v38 < v43;
      if (!v44)
        return 1;
      a1[16] = v37;
      a1[32] = v42;
      *((_QWORD *)a1 + 3) = v38;
      *((_QWORD *)a1 + 5) = v43;
      v45 = *a1;
      v46 = *((_QWORD *)a1 + 1);
      v47 = v37 < v45;
      if (v38 != v46)
        v47 = v38 < v46;
      if (!v47)
        return 1;
      *a1 = v37;
      a1[16] = v45;
      *((_QWORD *)a1 + 1) = v38;
      result = 1;
      *((_QWORD *)a1 + 3) = v46;
      return result;
    default:
      v19 = a1 + 32;
      v20 = a1[32];
      v22 = a1 + 16;
      v21 = a1[16];
      v23 = (unint64_t *)(a1 + 24);
      v24 = *((_QWORD *)a1 + 3);
      v25 = *a1;
      v27 = (unint64_t *)(a1 + 8);
      v26 = *((_QWORD *)a1 + 1);
      v28 = v24 < v26;
      v29 = *((_QWORD *)a1 + 5);
      if (v24 == v26)
        v28 = v21 < v25;
      v30 = v20 < v21;
      if (v29 != v24)
        v30 = v29 < v24;
      if (v28)
      {
        if (v30)
        {
          v31 = a1;
          v22 = a1 + 32;
          v23 = (unint64_t *)(a1 + 40);
LABEL_45:
          *v31 = v20;
          *v22 = v25;
          *v27 = v29;
          *v23 = v26;
          goto LABEL_46;
        }
        *a1 = v21;
        a1[16] = v25;
        if (v29 == v26)
          v71 = v20 < v25;
        else
          v71 = v29 < v26;
        v31 = a1 + 16;
        *((_QWORD *)a1 + 1) = v24;
        *((_QWORD *)a1 + 3) = v26;
        v22 = a1 + 32;
        v27 = (unint64_t *)(a1 + 24);
        v23 = (unint64_t *)(a1 + 40);
        if (v71)
          goto LABEL_45;
      }
      else if (v30)
      {
        *v22 = v20;
        *v19 = v21;
        *v23 = v29;
        *((_QWORD *)a1 + 5) = v24;
        v53 = v20 < v25;
        if (v29 != v26)
          v53 = v29 < v26;
        v31 = a1;
        if (v53)
          goto LABEL_45;
      }
LABEL_46:
      v54 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v55 = 0;
      v56 = 0;
      while (1)
      {
        v57 = *v54;
        v58 = *((_QWORD *)v54 + 1);
        v59 = *v19;
        v60 = *((_QWORD *)v19 + 1);
        v61 = v58 == v60;
        v62 = v58 < v60;
        if (v61)
          v62 = v57 < v59;
        if (v62)
          break;
LABEL_59:
        v19 = v54;
        v55 += 16;
        v54 += 16;
        if (v54 == a2)
          return 1;
      }
      v63 = v55;
      do
      {
        v64 = &a1[v63];
        v64[48] = v59;
        *((_QWORD *)v64 + 7) = *(_QWORD *)&a1[v63 + 40];
        if (v63 == -32)
        {
          *a1 = v57;
          *((_QWORD *)a1 + 1) = v58;
          if (++v56 != 8)
            goto LABEL_59;
          return v54 + 16 == a2;
        }
        v59 = v64[16];
        v65 = *((_QWORD *)v64 + 3);
        v61 = v58 == v65;
        v66 = v58 < v65;
        if (v61)
          v66 = v57 < v59;
        v63 -= 16;
      }
      while (v66);
      v67 = &a1[v63];
      v67[48] = v57;
      *((_QWORD *)v67 + 7) = v58;
      if (++v56 != 8)
        goto LABEL_59;
      return v54 + 16 == a2;
  }
}

unsigned __int8 *std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::DefaultTemporalLayers::UpdateSearchOrder(webrtc::Vp8FrameConfig *)::$_0 &,std::pair<webrtc::Vp8FrameConfig::Vp8BufferReference,unsigned long> *>(unsigned __int8 *result, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  unsigned int v4;
  unint64_t v5;
  unsigned int v6;
  unint64_t v7;
  BOOL v8;
  unsigned int v9;
  unint64_t v10;
  _BOOL4 v11;
  unsigned int v12;
  unint64_t v13;
  unsigned int v14;
  unint64_t v15;
  _BOOL4 v16;
  unsigned int v17;
  _BOOL4 v18;
  unsigned int v19;
  unint64_t v20;
  unsigned int v21;
  _BOOL4 v22;
  unsigned int v23;
  unint64_t v24;
  unsigned int v25;
  unint64_t v26;
  _BOOL4 v27;
  unsigned int v28;
  unint64_t v29;
  unsigned int v30;
  unint64_t v31;
  _BOOL4 v32;

  v4 = *a2;
  v5 = *((_QWORD *)a2 + 1);
  v6 = *result;
  v7 = *((_QWORD *)result + 1);
  if (v5 == v7)
    v8 = v4 < v6;
  else
    v8 = v5 < v7;
  v9 = *a3;
  v10 = *((_QWORD *)a3 + 1);
  v11 = v9 < v4;
  if (v10 != v5)
    v11 = v10 < v5;
  if (v8)
  {
    if (v11)
    {
      *result = v9;
      *a3 = v6;
      *((_QWORD *)result + 1) = v10;
LABEL_18:
      v5 = v7;
      *((_QWORD *)a3 + 1) = v7;
      goto LABEL_20;
    }
    *result = v4;
    *a2 = v6;
    *((_QWORD *)result + 1) = v5;
    *((_QWORD *)a2 + 1) = v7;
    v17 = *a3;
    v5 = *((_QWORD *)a3 + 1);
    v18 = v17 < v6;
    if (v5 != v7)
      v18 = v5 < v7;
    if (v18)
    {
      *a2 = v17;
      *a3 = v6;
      *((_QWORD *)a2 + 1) = v5;
      goto LABEL_18;
    }
  }
  else if (v11)
  {
    *a2 = v9;
    *a3 = v4;
    *((_QWORD *)a2 + 1) = v10;
    *((_QWORD *)a3 + 1) = v5;
    v12 = *a2;
    v13 = *((_QWORD *)a2 + 1);
    v14 = *result;
    v15 = *((_QWORD *)result + 1);
    v16 = v12 < v14;
    if (v13 != v15)
      v16 = v13 < v15;
    if (v16)
    {
      *result = v12;
      *a2 = v14;
      *((_QWORD *)result + 1) = v13;
      *((_QWORD *)a2 + 1) = v15;
      v5 = *((_QWORD *)a3 + 1);
    }
  }
  else
  {
    v5 = *((_QWORD *)a3 + 1);
  }
LABEL_20:
  v19 = *a4;
  v20 = *((_QWORD *)a4 + 1);
  v21 = *a3;
  v22 = v19 < v21;
  if (v20 != v5)
    v22 = v20 < v5;
  if (v22)
  {
    *a3 = v19;
    *a4 = v21;
    *((_QWORD *)a3 + 1) = v20;
    *((_QWORD *)a4 + 1) = v5;
    v23 = *a3;
    v24 = *((_QWORD *)a3 + 1);
    v25 = *a2;
    v26 = *((_QWORD *)a2 + 1);
    v27 = v23 < v25;
    if (v24 != v26)
      v27 = v24 < v26;
    if (v27)
    {
      *a2 = v23;
      *a3 = v25;
      *((_QWORD *)a2 + 1) = v24;
      *((_QWORD *)a3 + 1) = v26;
      v28 = *a2;
      v29 = *((_QWORD *)a2 + 1);
      v30 = *result;
      v31 = *((_QWORD *)result + 1);
      v32 = v28 < v30;
      if (v29 != v31)
        v32 = v29 < v31;
      if (v32)
      {
        *result = v28;
        *a2 = v30;
        *((_QWORD *)result + 1) = v29;
        *((_QWORD *)a2 + 1) = v31;
      }
    }
  }
  return result;
}

__n128 std::vector<webrtc::FrameDependencyTemplate>::__move_assign(void **a1, __n128 *a2)
{
  void **v4;
  void **v5;
  void *v6;
  __n128 result;

  v4 = (void **)*a1;
  if (*a1)
  {
    v5 = (void **)a1[1];
    v6 = *a1;
    if (v5 == v4)
    {
LABEL_13:
      a1[1] = v4;
      operator delete(v6);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
      goto LABEL_14;
    }
    while (1)
    {
      if ((*(_BYTE *)(v5 - 3) & 1) != 0)
      {
        operator delete(*(v5 - 2));
        if ((*(_BYTE *)(v5 - 6) & 1) == 0)
        {
LABEL_7:
          if ((*(_BYTE *)(v5 - 12) & 1) != 0)
            goto LABEL_11;
          goto LABEL_4;
        }
      }
      else if ((*(_BYTE *)(v5 - 6) & 1) == 0)
      {
        goto LABEL_7;
      }
      operator delete(*(v5 - 5));
      if ((*(_BYTE *)(v5 - 12) & 1) != 0)
LABEL_11:
        operator delete(*(v5 - 11));
LABEL_4:
      v5 -= 13;
      if (v5 == v4)
      {
        v6 = *a1;
        goto LABEL_13;
      }
    }
  }
LABEL_14:
  result = *a2;
  *(__n128 *)a1 = *a2;
  a1[2] = (void *)a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

void std::vector<webrtc::FrameDependencyTemplate>::__append(char **a1, unint64_t a2)
{
  char *v4;
  void **v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  void **v11;
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  void **v18;
  uint64_t v19;
  void **v20;
  char *v21;
  __int128 v22;
  __int128 v23;
  void *v24;
  void **v25;

  v5 = (void **)a1[1];
  v4 = a1[2];
  if (0x4EC4EC4EC4EC4EC5 * ((v4 - (char *)v5) >> 3) < a2)
  {
    v6 = 0x4EC4EC4EC4EC4EC5 * (((char *)v5 - *a1) >> 3);
    v7 = v6 + a2;
    if (v6 + a2 <= 0x276276276276276)
    {
      v8 = 0x4EC4EC4EC4EC4EC5 * ((v4 - *a1) >> 3);
      if (2 * v8 > v7)
        v7 = 2 * v8;
      if (v8 >= 0x13B13B13B13B13BLL)
        v9 = 0x276276276276276;
      else
        v9 = v7;
      if (v9)
      {
        if (v9 > 0x276276276276276)
          std::__throw_bad_array_new_length[abi:sn180100]();
        v10 = (char *)operator new(104 * v9);
      }
      else
      {
        v10 = 0;
      }
      v13 = &v10[104 * v6];
      v14 = &v10[104 * v9];
      v15 = 104 * a2;
      v16 = &v13[104 * a2];
      v17 = v13;
      do
      {
        if (!v17)
          goto LABEL_38;
        *((_QWORD *)v17 + 12) = 0;
        *((_OWORD *)v17 + 4) = 0uLL;
        *((_OWORD *)v17 + 5) = 0uLL;
        *((_OWORD *)v17 + 2) = 0uLL;
        *((_OWORD *)v17 + 3) = 0uLL;
        *(_OWORD *)v17 = 0uLL;
        *((_OWORD *)v17 + 1) = 0uLL;
        v17 += 104;
        v15 -= 104;
      }
      while (v15);
      v18 = (void **)*a1;
      if (v5 == (void **)*a1)
      {
        *a1 = v13;
        a1[1] = v16;
        a1[2] = v14;
LABEL_35:
        if (v5)
          operator delete(v5);
        return;
      }
      v19 = 0;
      do
      {
        v20 = &v5[v19];
        v21 = &v13[v19 * 8];
        *((_QWORD *)v21 - 13) = v5[v19 - 13];
        *((_QWORD *)v21 - 12) = v5[v19 - 12];
        v22 = *(_OWORD *)&v5[v19 - 11];
        v23 = *(_OWORD *)&v5[v19 - 9];
        *((_QWORD *)v21 - 7) = v5[v19 - 7];
        *(_OWORD *)(v21 - 72) = v23;
        *(_OWORD *)(v21 - 88) = v22;
        v24 = v5[v19 - 6];
        *(v20 - 12) = 0;
        *((_QWORD *)v21 - 6) = v24;
        *(_OWORD *)(v21 - 40) = *(_OWORD *)&v5[v19 - 5];
        *(v20 - 6) = 0;
        *((_QWORD *)v21 - 3) = v5[v19 - 3];
        *((_OWORD *)v21 - 1) = *(_OWORD *)&v5[v19 - 2];
        *(v20 - 3) = 0;
        v19 -= 13;
      }
      while (&v5[v19] != v18);
      v5 = (void **)*a1;
      v25 = (void **)a1[1];
      *a1 = &v13[v19 * 8];
      a1[1] = v16;
      a1[2] = v14;
      while (1)
      {
        if (v25 == v5)
          goto LABEL_35;
        if ((*(_BYTE *)(v25 - 3) & 1) != 0)
        {
          operator delete(*(v25 - 2));
          if ((*(_BYTE *)(v25 - 6) & 1) != 0)
          {
LABEL_32:
            operator delete(*(v25 - 5));
            if ((*(_BYTE *)(v25 - 12) & 1) == 0)
              goto LABEL_25;
            goto LABEL_33;
          }
        }
        else if ((*(_BYTE *)(v25 - 6) & 1) != 0)
        {
          goto LABEL_32;
        }
        if ((*(_BYTE *)(v25 - 12) & 1) == 0)
          goto LABEL_25;
LABEL_33:
        operator delete(*(v25 - 11));
LABEL_25:
        v25 -= 13;
      }
    }
LABEL_39:
    abort();
  }
  if (!a2)
    goto LABEL_16;
  v11 = &v5[13 * a2];
  v12 = 104 * a2;
  do
  {
    if (!v5)
    {
LABEL_38:
      __break(1u);
      goto LABEL_39;
    }
    v5[12] = 0;
    *((_OWORD *)v5 + 4) = 0uLL;
    *((_OWORD *)v5 + 5) = 0uLL;
    *((_OWORD *)v5 + 2) = 0uLL;
    *((_OWORD *)v5 + 3) = 0uLL;
    *(_OWORD *)v5 = 0uLL;
    *((_OWORD *)v5 + 1) = 0uLL;
    v5 += 13;
    v12 -= 104;
  }
  while (v12);
  v5 = v11;
LABEL_16:
  a1[1] = (char *)v5;
}

void absl::inlined_vector_internal::Storage<int,4ul,std::allocator<int>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<int>,int const*>>(unint64_t *a1, uint64_t a2, unint64_t a3)
{
  int *v4;
  unint64_t v6;
  void **v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int *v16;
  _OWORD *v17;
  __int128 *v18;
  uint64_t v19;
  __int128 v20;
  unint64_t v21;
  _DWORD *v22;
  int v23;
  unint64_t v24;
  char *v25;
  char *v26;
  unint64_t v27;
  int *v28;
  _OWORD *v29;
  __int128 *v30;
  unint64_t v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  int v35;

  v4 = (int *)a2;
  v7 = (void **)(a1 + 1);
  v6 = *a1;
  v8 = *a1 & 1;
  if ((*a1 & 1) == 0)
  {
    v9 = 4;
    v10 = a1 + 1;
    if (a3 <= 4)
      goto LABEL_3;
LABEL_19:
    if (2 * v9 <= a3)
      v24 = a3;
    else
      v24 = 2 * v9;
    if (!(v24 >> 62))
    {
      v25 = (char *)operator new(4 * v24);
      v26 = v25;
      v13 = a3;
      v16 = v4;
      v27 = 0;
      if (a3 < 8)
        goto LABEL_33;
LABEL_28:
      if ((unint64_t)(v26 - (char *)v16) >= 0x20)
      {
        v27 = v13 & 0xFFFFFFFFFFFFFFF8;
        v28 = &v16[v13 & 0xFFFFFFFFFFFFFFF8];
        v29 = v26 + 16;
        v30 = (__int128 *)(v16 + 4);
        v31 = v13 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v32 = *v30;
          *(v29 - 1) = *(v30 - 1);
          *v29 = v32;
          v29 += 2;
          v30 += 2;
          v31 -= 8;
        }
        while (v31);
        if (v13 == v27)
        {
LABEL_36:
          if (v25)
          {
            if (v8)
              operator delete(*v7);
            a1[1] = (unint64_t)v25;
            a1[2] = v24;
            v8 = 1;
          }
          goto LABEL_40;
        }
LABEL_34:
        v33 = v13 - v27;
        v34 = &v26[4 * v27];
        do
        {
          v35 = *v28++;
          *(_DWORD *)v34 = v35;
          v34 += 4;
          --v33;
        }
        while (v33);
        goto LABEL_36;
      }
LABEL_33:
      v28 = v16;
      goto LABEL_34;
    }
LABEL_42:
    std::__throw_bad_array_new_length[abi:sn180100]();
  }
  v10 = (_QWORD *)a1[1];
  v9 = a1[2];
  if (v9 < a3)
    goto LABEL_19;
LABEL_3:
  v11 = v6 >> 1;
  v12 = a3 >= v6 >> 1;
  v13 = a3 - (v6 >> 1);
  if (!v12)
    v13 = 0;
  if (v11 >= a3)
    v14 = a3;
  else
    v14 = v11;
  if (!v14)
  {
    v16 = (int *)a2;
    if (v11 >= a3)
      goto LABEL_40;
    goto LABEL_26;
  }
  v15 = 0;
  if (v14 < 8)
    goto LABEL_14;
  if ((unint64_t)v10 - a2 < 0x20)
    goto LABEL_14;
  v15 = v14 & 0x7FFFFFFFFFFFFFF8;
  v16 = (int *)(a2 + 4 * (v14 & 0x7FFFFFFFFFFFFFF8));
  v17 = v10 + 2;
  v18 = (__int128 *)(a2 + 16);
  v19 = v14 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    v20 = *v18;
    *(v17 - 1) = *(v18 - 1);
    *v17 = v20;
    v17 += 2;
    v18 += 2;
    v19 -= 8;
  }
  while (v19);
  v4 = (int *)(a2 + 4 * (v14 & 0x7FFFFFFFFFFFFFF8));
  if (v14 != v15)
  {
LABEL_14:
    v21 = v14 - v15;
    v22 = (_DWORD *)v10 + v15;
    v16 = v4;
    do
    {
      v23 = *v16++;
      *v22++ = v23;
      --v21;
    }
    while (v21);
  }
  if (v11 < a3)
  {
LABEL_26:
    if (v10)
    {
      v25 = 0;
      v24 = 0;
      v26 = (char *)v10 + 4 * v11;
      v27 = 0;
      if (v13 < 8)
        goto LABEL_33;
      goto LABEL_28;
    }
    __break(1u);
    goto LABEL_42;
  }
LABEL_40:
  *a1 = v8 | (2 * a3);
}

char *absl::inlined_vector_internal::Storage<webrtc::CodecBufferUsage,8ul,std::allocator<webrtc::CodecBufferUsage>>::EmplaceBackSlow<int &,BOOL &,BOOL &>(uint64_t a1, _DWORD *a2, char *a3, char *a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char v16;
  char v17;
  uint64_t v18;
  uint64_t *v19;
  _OWORD *v20;
  __int128 *v21;
  uint64_t v22;
  __int128 v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;

  v9 = a1 + 8;
  v8 = *(_QWORD *)a1;
  if ((*(_QWORD *)a1 & 1) != 0)
  {
    v11 = *(_QWORD *)(a1 + 16);
    if (((v11 >> 60) & 7) != 0)
      std::__throw_bad_array_new_length[abi:sn180100]();
    v9 = *(_QWORD *)(a1 + 8);
    v10 = 2 * v11;
  }
  else
  {
    v10 = 16;
  }
  v12 = v8 >> 1;
  v13 = (char *)operator new(8 * v10);
  v14 = v13;
  v15 = &v13[8 * (v8 >> 1)];
  v16 = *a3;
  v17 = *a4;
  *(_DWORD *)v15 = *a2;
  v15[4] = v16;
  v15[5] = v17;
  if (v8 >= 2)
  {
    v18 = 0;
    if (v8 < 8 || (unint64_t)&v13[-v9] < 0x20)
    {
      v19 = (uint64_t *)v9;
    }
    else
    {
      v18 = v12 & 0x7FFFFFFFFFFFFFFCLL;
      v19 = (uint64_t *)(v9 + 8 * (v12 & 0x7FFFFFFFFFFFFFFCLL));
      v20 = v13 + 16;
      v21 = (__int128 *)(v9 + 16);
      v22 = v12 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v23 = *v21;
        *(v20 - 1) = *(v21 - 1);
        *v20 = v23;
        v20 += 2;
        v21 += 2;
        v22 -= 4;
      }
      while (v22);
      if (v12 == v18)
        goto LABEL_15;
    }
    v24 = v12 - v18;
    v25 = &v13[8 * v18];
    do
    {
      v26 = *v19++;
      *(_QWORD *)v25 = v26;
      v25 += 8;
      --v24;
    }
    while (v24);
  }
LABEL_15:
  if ((v8 & 1) != 0)
  {
    operator delete(*(void **)(a1 + 8));
    v8 = *(_QWORD *)a1;
  }
  *(_QWORD *)(a1 + 8) = v14;
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)a1 = (v8 | 1) + 2;
  return v15;
}

void absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<webrtc::DecodeTargetIndication>,webrtc::DecodeTargetIndication const*>>(unint64_t *a1, uint64_t a2, unint64_t a3)
{
  int *v4;
  unint64_t v6;
  void **v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int *v16;
  _OWORD *v17;
  __int128 *v18;
  uint64_t v19;
  __int128 v20;
  unint64_t v21;
  _DWORD *v22;
  int v23;
  unint64_t v24;
  char *v25;
  char *v26;
  unint64_t v27;
  int *v28;
  _OWORD *v29;
  __int128 *v30;
  unint64_t v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  int v35;

  v4 = (int *)a2;
  v7 = (void **)(a1 + 1);
  v6 = *a1;
  v8 = *a1 & 1;
  if ((*a1 & 1) == 0)
  {
    v9 = 10;
    v10 = a1 + 1;
    if (a3 <= 0xA)
      goto LABEL_3;
LABEL_19:
    if (2 * v9 <= a3)
      v24 = a3;
    else
      v24 = 2 * v9;
    if (!(v24 >> 62))
    {
      v25 = (char *)operator new(4 * v24);
      v26 = v25;
      v13 = a3;
      v16 = v4;
      v27 = 0;
      if (a3 < 8)
        goto LABEL_33;
LABEL_28:
      if ((unint64_t)(v26 - (char *)v16) >= 0x20)
      {
        v27 = v13 & 0xFFFFFFFFFFFFFFF8;
        v28 = &v16[v13 & 0xFFFFFFFFFFFFFFF8];
        v29 = v26 + 16;
        v30 = (__int128 *)(v16 + 4);
        v31 = v13 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v32 = *v30;
          *(v29 - 1) = *(v30 - 1);
          *v29 = v32;
          v29 += 2;
          v30 += 2;
          v31 -= 8;
        }
        while (v31);
        if (v13 == v27)
        {
LABEL_36:
          if (v25)
          {
            if (v8)
              operator delete(*v7);
            a1[1] = (unint64_t)v25;
            a1[2] = v24;
            v8 = 1;
          }
          goto LABEL_40;
        }
LABEL_34:
        v33 = v13 - v27;
        v34 = &v26[4 * v27];
        do
        {
          v35 = *v28++;
          *(_DWORD *)v34 = v35;
          v34 += 4;
          --v33;
        }
        while (v33);
        goto LABEL_36;
      }
LABEL_33:
      v28 = v16;
      goto LABEL_34;
    }
LABEL_42:
    std::__throw_bad_array_new_length[abi:sn180100]();
  }
  v10 = (_QWORD *)a1[1];
  v9 = a1[2];
  if (v9 < a3)
    goto LABEL_19;
LABEL_3:
  v11 = v6 >> 1;
  v12 = a3 >= v6 >> 1;
  v13 = a3 - (v6 >> 1);
  if (!v12)
    v13 = 0;
  if (v11 >= a3)
    v14 = a3;
  else
    v14 = v11;
  if (!v14)
  {
    v16 = (int *)a2;
    if (v11 >= a3)
      goto LABEL_40;
    goto LABEL_26;
  }
  v15 = 0;
  if (v14 < 8)
    goto LABEL_14;
  if ((unint64_t)v10 - a2 < 0x20)
    goto LABEL_14;
  v15 = v14 & 0x7FFFFFFFFFFFFFF8;
  v16 = (int *)(a2 + 4 * (v14 & 0x7FFFFFFFFFFFFFF8));
  v17 = v10 + 2;
  v18 = (__int128 *)(a2 + 16);
  v19 = v14 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    v20 = *v18;
    *(v17 - 1) = *(v18 - 1);
    *v17 = v20;
    v17 += 2;
    v18 += 2;
    v19 -= 8;
  }
  while (v19);
  v4 = (int *)(a2 + 4 * (v14 & 0x7FFFFFFFFFFFFFF8));
  if (v14 != v15)
  {
LABEL_14:
    v21 = v14 - v15;
    v22 = (_DWORD *)v10 + v15;
    v16 = v4;
    do
    {
      v23 = *v16++;
      *v22++ = v23;
      --v21;
    }
    while (v21);
  }
  if (v11 < a3)
  {
LABEL_26:
    if (v10)
    {
      v25 = 0;
      v24 = 0;
      v26 = (char *)v10 + 4 * v11;
      v27 = 0;
      if (v13 < 8)
        goto LABEL_33;
      goto LABEL_28;
    }
    __break(1u);
    goto LABEL_42;
  }
LABEL_40:
  *a1 = v8 | (2 * a3);
}

BOOL webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue::Process(webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue *this)
{
  uint64_t v2;
  unsigned __int8 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  _QWORD *v11;
  _QWORD *v12;
  char v14;
  char v15;
  _QWORD v16[2];
  uint64_t (*v17)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v18)(uint64_t);

  webrtc::FakeNetworkPipe::Process((webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue *)((char *)this + 24));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 120));
  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 16))(*((_QWORD *)this + 13));
  v4 = v3;
  if (v3)
  {
    v5 = v2;
    v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 16))(*((_QWORD *)this + 4));
    v7 = ((v5 - v6 + 500) / 1000) & ~(((v5 - v6 + 500) / 1000) >> 63);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 120));
    v8 = *((_QWORD *)this + 1);
    v9 = (unsigned int *)*((_QWORD *)this + 2);
    if (v9)
    {
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = operator new(0x18uLL);
    *v11 = this;
    v11[1] = v7;
    *((_BYTE *)v11 + 16) = 1;
    v12 = (_QWORD *)operator new();
    *v12 = v9;
    v12[1] = v11;
    v12[2] = 24;
    v12[3] = absl::internal_any_invocable::RemoteManagerTrivial;
    v12[4] = absl::internal_any_invocable::RemoteInvoker<false,void,webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue::Process(void)::$_0 &&>;
    v16[0] = v12;
    v17 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
    v18 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
    (*(void (**)(uint64_t, _QWORD *, char *, char *))(*(_QWORD *)v8 + 8))(v8, v16, &v15, &v14);
    v17(1, v16, v16);
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 120));
  }
  return v4 != 0;
}

void webrtc::DegradedCall::FakeNetworkPipeTransportAdapter::~FakeNetworkPipeTransportAdapter(webrtc::DegradedCall::FakeNetworkPipeTransportAdapter *this)
{
  *(_QWORD *)this = off_24C0B3040;
  webrtc::FakeNetworkPipe::RemoveActiveTransport(*((_QWORD *)this + 1) + 24, *((_QWORD *)this + 4));
}

{
  *(_QWORD *)this = off_24C0B3040;
  webrtc::FakeNetworkPipe::RemoveActiveTransport(*((_QWORD *)this + 1) + 24, *((_QWORD *)this + 4));
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::DegradedCall::FakeNetworkPipeTransportAdapter::SendRtp(uint64_t a1, const void *a2, size_t a3, uint64_t *a4)
{
  webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD v13[2];
  __int16 v14;
  int v15;
  int v16;
  char v17;
  char v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;

  v7 = *(webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue **)(a1 + 8);
  if (!a3)
    a2 = 0;
  webrtc::FakeNetworkPipe::SendRtp((uint64_t)v7 + 24, a2, a3, a4, *(_QWORD *)(a1 + 32));
  webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue::Process(v7);
  v8 = *a4;
  if (*a4 != -1)
  {
    v18 = 0;
    v16 = 0;
    v17 = 0;
    v20 = 0;
    v21 = 0;
    v13[0] = v8;
    v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 16))(*(_QWORD *)(a1 + 24));
    v10 = v9 / 0x3E8uLL;
    if (v9 % 0x3E8uLL > 0x1F3)
      ++v10;
    if (-v9 % 0x3E8uLL <= 0x1F4)
      v11 = 0;
    else
      v11 = -1;
    if (v9 < 0)
      v10 = v11 - -v9 / 0x3E8uLL;
    v13[1] = v10;
    v14 = *(_WORD *)((char *)a4 + 9);
    v19 = a3;
    v15 = 1;
    (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 16) + 168))(*(_QWORD *)(a1 + 16), v13);
  }
  return 1;
}

uint64_t webrtc::DegradedCall::FakeNetworkPipeTransportAdapter::SendRtcp(uint64_t a1, const void *a2, size_t a3)
{
  webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue *v3;

  v3 = *(webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue **)(a1 + 8);
  if (!a3)
    a2 = 0;
  webrtc::FakeNetworkPipe::SendRtcp((uint64_t)v3 + 24, a2, a3, *(_QWORD *)(a1 + 32));
  webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue::Process(v3);
  return 1;
}

uint64_t webrtc::DegradedCall::DegradedCall(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  __int128 v11;
  const void *v12;
  int64_t v13;
  char *v14;
  char *v15;
  const void *v16;
  int64_t v17;
  pthread_mutexattr_t *v18;
  pthread_mutexattr_t *v19;
  uint64_t v20;
  pthread_mutexattr_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  pthread_mutexattr_t *v33;
  uint64_t v34;
  pthread_mutexattr_t v35;
  pthread_mutexattr_t v36;
  pthread_mutexattr_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  unsigned int *v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int *v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  unsigned int *v50;
  unsigned int v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v56;
  int v57;
  _QWORD *v58;
  char v59;
  pthread_mutexattr_t v60;
  pthread_mutexattr_t v61;
  pthread_mutexattr_t v62;
  uint64_t sig;
  pthread_mutexattr_t v64;
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = &off_24C0B3070;
  *(_QWORD *)(a1 + 8) = &unk_24C0B3170;
  if ((v7 & 1) == 0)
  {
    v56 = a2;
    a2 = v56;
    if (v57)
    {
      v58 = (_QWORD *)operator new();
      *v58 = &unk_24C0B13E8;
      webrtc::Clock::GetRealTimeClock(void)::clock = (uint64_t)v58;
      a2 = v56;
    }
  }
  *(_QWORD *)(a1 + 16) = webrtc::Clock::GetRealTimeClock(void)::clock;
  v8 = *a2;
  *a2 = 0;
  *(_QWORD *)(a1 + 24) = v8;
  v9 = operator new();
  *(_DWORD *)v9 = 0;
  *(_BYTE *)(v9 + 4) = 1;
  *(_QWORD *)(a1 + 32) = v9;
  do
    v10 = __ldxr((unsigned int *)v9);
  while (__stxr(v10 + 1, (unsigned int *)v9));
  v11 = 0uLL;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  v12 = *(const void **)a3;
  v13 = *(_QWORD *)(a3 + 8) - *(_QWORD *)a3;
  if (v13)
  {
    if (v13 < 0)
      goto LABEL_34;
    v14 = (char *)operator new(v13);
    *(_QWORD *)(a1 + 48) = v14;
    *(_QWORD *)(a1 + 56) = v14;
    v15 = &v14[64 * (v13 >> 6)];
    *(_QWORD *)(a1 + 64) = v15;
    memcpy(v14, v12, v13);
    *(_QWORD *)(a1 + 56) = v15;
    v11 = 0uLL;
  }
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = a1 + 96;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = a1 + 120;
  *(_OWORD *)(a1 + 136) = v11;
  *(_OWORD *)(a1 + 152) = v11;
  v16 = *(const void **)a4;
  v17 = *(_QWORD *)(a4 + 8) - *(_QWORD *)a4;
  if (v17)
  {
    if (v17 < 0)
      goto LABEL_34;
    v18 = (pthread_mutexattr_t *)operator new(v17);
    *(_QWORD *)(a1 + 144) = v18;
    *(_QWORD *)(a1 + 152) = v18;
    v19 = &v18[4 * (v17 >> 6)];
    *(_QWORD *)(a1 + 160) = v19;
    memcpy(v18, v16, v17);
    *(_QWORD *)(a1 + 152) = v19;
    *(_QWORD *)(a1 + 184) = 0;
    v20 = operator new();
    v21 = v18[1];
    v60 = *v18;
    v61 = v21;
    v62 = v18[2];
    sig = v18[3].__sig;
    *(_QWORD *)v20 = &off_24C0C0D10;
    pthread_mutexattr_init(&v64);
    pthread_mutexattr_setpolicy_np(&v64, 3);
    pthread_mutex_init((pthread_mutex_t *)(v20 + 8), &v64);
    pthread_mutexattr_destroy(&v64);
    *(_DWORD *)(v20 + 72) = 0;
    *(_OWORD *)(v20 + 88) = 0u;
    *(_OWORD *)(v20 + 104) = 0u;
    *(_OWORD *)(v20 + 120) = 0u;
    *(_OWORD *)(v20 + 136) = 0u;
    *(_OWORD *)(v20 + 152) = 0u;
    *(_OWORD *)(v20 + 168) = 0u;
    *(_QWORD *)(v20 + 184) = 0x7FFFFFFFFFFFFFFFLL;
    *(_QWORD *)(v20 + 208) = absl::internal_any_invocable::EmptyManager;
    *(_QWORD *)(v20 + 216) = 0;
    *(_QWORD *)(v20 + 232) = 0;
    *(_DWORD *)(v20 + 240) = 0;
    *(_QWORD *)(v20 + 224) = 0;
    *(_QWORD *)(v20 + 248) = 0x7FFFFFFFFFFFFFFFLL;
    *(_QWORD *)(v20 + 256) = 0;
    *(_BYTE *)(v20 + 264) = 0;
    *(_QWORD *)(v20 + 268) = 0xFFFFFFFFLL;
    *(_QWORD *)(v20 + 296) = 0;
    *(_QWORD *)(v20 + 304) = 1;
    *(_BYTE *)(v20 + 312) = 0;
    *(_OWORD *)(v20 + 320) = xmmword_208F08B90;
    (*(void (**)(uint64_t, pthread_mutexattr_t *))(*(_QWORD *)v20 + 48))(v20, &v60);
    *(_QWORD *)(a1 + 168) = v20;
    v22 = operator new();
    v23 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)v22 = &off_24C0B3EC0;
    *(_QWORD *)(v22 + 8) = v23;
    pthread_mutexattr_init(&v60);
    pthread_mutexattr_setpolicy_np(&v60, 3);
    pthread_mutex_init((pthread_mutex_t *)(v22 + 16), &v60);
    pthread_mutexattr_destroy(&v60);
    *(_QWORD *)(v22 + 80) = v20;
    *(_QWORD *)(v22 + 88) = 0;
    pthread_mutexattr_init(&v60);
    pthread_mutexattr_setpolicy_np(&v60, 3);
    pthread_mutex_init((pthread_mutex_t *)(v22 + 96), &v60);
    pthread_mutexattr_destroy(&v60);
    *(_OWORD *)(v22 + 208) = 0u;
    *(_OWORD *)(v22 + 224) = 0u;
    *(_OWORD *)(v22 + 176) = 0u;
    *(_OWORD *)(v22 + 192) = 0u;
    *(_OWORD *)(v22 + 160) = 0u;
    v24 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v22 + 8) + 16))(*(_QWORD *)(v22 + 8));
    *(_QWORD *)(v22 + 256) = 0;
    *(_QWORD *)(v22 + 264) = 0;
    *(_QWORD *)(v22 + 240) = v24;
    *(_QWORD *)(v22 + 248) = v22 + 256;
    v25 = *(_QWORD *)(a1 + 184);
    *(_QWORD *)(a1 + 184) = v22;
    if (v25)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v25 + 24))(v25);
      v22 = *(_QWORD *)(a1 + 184);
    }
    v26 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 96))(*(_QWORD *)(a1 + 24));
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v22 + 32))(v22, v26);
    if (*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144) >= 0x41uLL)
    {
      v27 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 192))(*(_QWORD *)(a1 + 24));
      v28 = *(unsigned int **)(a1 + 32);
      if (v28)
      {
        do
          v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
      }
      v30 = (_QWORD *)operator new();
      *v30 = v28;
      v30[1] = a1;
      v30[3] = absl::internal_any_invocable::LocalManagerTrivial;
      v30[4] = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DegradedCall::DegradedCall(std::unique_ptr<webrtc::Call>,std::vector<webrtc::DegradedCall::TimeScopedNetworkConfig> const&,std::vector<webrtc::DegradedCall::TimeScopedNetworkConfig> const&)::$_0 &&>;
      v31 = *(_QWORD *)(a1 + 144);
      if (*(_QWORD *)(a1 + 152) == v31)
      {
LABEL_33:
        __break(1u);
LABEL_34:
        abort();
      }
      v32 = *(_QWORD *)(v31 + 56);
      v60.__sig = (uint64_t)v30;
      v61.__sig = (uint64_t)_ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
      *(_QWORD *)v61.__opaque = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
      LOBYTE(v64.__sig) = 0;
      (*(void (**)(uint64_t, pthread_mutexattr_t *, uint64_t, pthread_mutexattr_t *, char *))(*(_QWORD *)v27 + 16))(v27, &v60, v32, &v64, &v59);
      ((void (*)(uint64_t, pthread_mutexattr_t *, pthread_mutexattr_t *))v61.__sig)(1, &v60, &v60);
    }
    v33 = *(pthread_mutexattr_t **)(a1 + 48);
    if (v33 == *(pthread_mutexattr_t **)(a1 + 56))
      return a1;
  }
  else
  {
    *(_QWORD *)(a1 + 184) = 0;
    v33 = *(pthread_mutexattr_t **)(a1 + 48);
    if (v33 == *(pthread_mutexattr_t **)(a1 + 56))
      return a1;
  }
  v34 = operator new();
  v36 = v33[1];
  v35 = v33[2];
  v37 = *v33;
  sig = v33[3].__sig;
  v61 = v36;
  v62 = v35;
  v60 = v37;
  *(_QWORD *)v34 = &off_24C0C0D10;
  pthread_mutexattr_init(&v64);
  pthread_mutexattr_setpolicy_np(&v64, 3);
  pthread_mutex_init((pthread_mutex_t *)(v34 + 8), &v64);
  pthread_mutexattr_destroy(&v64);
  *(_DWORD *)(v34 + 72) = 0;
  *(_OWORD *)(v34 + 88) = 0u;
  *(_OWORD *)(v34 + 104) = 0u;
  *(_OWORD *)(v34 + 120) = 0u;
  *(_OWORD *)(v34 + 136) = 0u;
  *(_OWORD *)(v34 + 152) = 0u;
  *(_OWORD *)(v34 + 168) = 0u;
  *(_QWORD *)(v34 + 184) = 0x7FFFFFFFFFFFFFFFLL;
  *(_QWORD *)(v34 + 208) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(v34 + 216) = 0;
  *(_QWORD *)(v34 + 232) = 0;
  *(_DWORD *)(v34 + 240) = 0;
  *(_QWORD *)(v34 + 224) = 0;
  *(_QWORD *)(v34 + 248) = 0x7FFFFFFFFFFFFFFFLL;
  *(_QWORD *)(v34 + 256) = 0;
  *(_BYTE *)(v34 + 264) = 0;
  *(_QWORD *)(v34 + 268) = 0xFFFFFFFFLL;
  *(_QWORD *)(v34 + 296) = 0;
  *(_QWORD *)(v34 + 304) = 1;
  *(_BYTE *)(v34 + 312) = 0;
  *(_OWORD *)(v34 + 320) = xmmword_208F08B90;
  (*(void (**)(uint64_t, pthread_mutexattr_t *))(*(_QWORD *)v34 + 48))(v34, &v60);
  *(_QWORD *)(a1 + 72) = v34;
  v38 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 192))(*(_QWORD *)(a1 + 24));
  v39 = (_QWORD *)operator new();
  v40 = v39;
  v41 = *(unsigned int **)(a1 + 32);
  if (v41)
  {
    do
      v42 = __ldxr(v41);
    while (__stxr(v42 + 1, v41));
  }
  v43 = *(_QWORD *)(a1 + 16);
  *v39 = v43;
  v39[1] = v38;
  v39[2] = v41;
  v39[3] = &off_24C0B3EC0;
  v39[4] = v43;
  pthread_mutexattr_init(&v60);
  pthread_mutexattr_setpolicy_np(&v60, 3);
  pthread_mutex_init((pthread_mutex_t *)(v40 + 5), &v60);
  pthread_mutexattr_destroy(&v60);
  v40[13] = v34;
  v40[14] = 0;
  pthread_mutexattr_init(&v60);
  pthread_mutexattr_setpolicy_np(&v60, 3);
  pthread_mutex_init((pthread_mutex_t *)(v40 + 15), &v60);
  pthread_mutexattr_destroy(&v60);
  *(_OWORD *)(v40 + 31) = 0u;
  *(_OWORD *)(v40 + 29) = 0u;
  *(_OWORD *)(v40 + 27) = 0u;
  *(_OWORD *)(v40 + 25) = 0u;
  *(_OWORD *)(v40 + 23) = 0u;
  v44 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v40[4] + 16))(v40[4]);
  v40[35] = 0;
  v40[36] = 0;
  v40[33] = v44;
  v40[34] = v40 + 35;
  *((_BYTE *)v40 + 296) = 0;
  *((_BYTE *)v40 + 304) = 0;
  v45 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a1 + 80) = v40;
  if (v45)
  {
    webrtc::FakeNetworkPipe::~FakeNetworkPipe((webrtc::FakeNetworkPipe *)(v45 + 24));
    v46 = *(unsigned int **)(v45 + 16);
    if (v46)
    {
      do
      {
        v47 = __ldaxr(v46);
        v48 = v47 - 1;
      }
      while (__stlxr(v48, v46));
      if (!v48)
        MEMORY[0x20BD0ADEC]();
    }
    MEMORY[0x20BD0ADEC](v45, 0x10E0C40FBA89811);
  }
  if (*(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 48) >= 0x41uLL)
  {
    v49 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 192))(*(_QWORD *)(a1 + 24));
    v50 = *(unsigned int **)(a1 + 32);
    if (v50)
    {
      do
        v51 = __ldxr(v50);
      while (__stxr(v51 + 1, v50));
    }
    v52 = (_QWORD *)operator new();
    *v52 = v50;
    v52[1] = a1;
    v52[3] = absl::internal_any_invocable::LocalManagerTrivial;
    v52[4] = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DegradedCall::DegradedCall(std::unique_ptr<webrtc::Call>,std::vector<webrtc::DegradedCall::TimeScopedNetworkConfig> const&,std::vector<webrtc::DegradedCall::TimeScopedNetworkConfig> const&)::$_1 &&>;
    v53 = *(_QWORD *)(a1 + 48);
    if (*(_QWORD *)(a1 + 56) != v53)
    {
      v54 = *(_QWORD *)(v53 + 56);
      v60.__sig = (uint64_t)v52;
      v61.__sig = (uint64_t)_ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
      *(_QWORD *)v61.__opaque = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
      LOBYTE(v64.__sig) = 0;
      (*(void (**)(uint64_t, pthread_mutexattr_t *, uint64_t, pthread_mutexattr_t *, char *))(*(_QWORD *)v49 + 16))(v49, &v60, v54, &v64, &v59);
      ((void (*)(uint64_t, pthread_mutexattr_t *, pthread_mutexattr_t *))v61.__sig)(1, &v60, &v60);
      return a1;
    }
    goto LABEL_33;
  }
  return a1;
}

void webrtc::DegradedCall::~DegradedCall(webrtc::DegradedCall *this)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  void *v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  char v18;
  unsigned int *v19;

  *(_QWORD *)this = &off_24C0B3070;
  *((_QWORD *)this + 1) = &unk_24C0B3170;
  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 192))(*((_QWORD *)this + 3));
  v3 = (unsigned int *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  v19 = v3;
  (*(void (**)(uint64_t, unsigned int **, uint64_t (*)(uint64_t), char *))(*(_QWORD *)v2 + 96))(v2, &v19, rtc::FunctionView<void ()(void)>::CallVoidPtr<webrtc::DegradedCall::~DegradedCall()::$_1>, &v18);
  v4 = v19;
  if (v19)
  {
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      MEMORY[0x20BD0ADEC]();
  }
  v7 = *((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  v8 = (void *)*((_QWORD *)this + 18);
  if (v8)
  {
    *((_QWORD *)this + 19) = v8;
    operator delete(v8);
  }
  std::__tree<std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>,std::__map_value_compare<webrtc::AudioSendStream *,std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>,std::less<webrtc::AudioSendStream *>,true>,std::allocator<std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>>>::destroy(*((_QWORD **)this + 15));
  std::__tree<std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>,std::__map_value_compare<webrtc::AudioSendStream *,std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>,std::less<webrtc::AudioSendStream *>,true>,std::allocator<std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>>>::destroy(*((_QWORD **)this + 12));
  v9 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v9)
  {
    webrtc::FakeNetworkPipe::~FakeNetworkPipe((webrtc::FakeNetworkPipe *)(v9 + 24));
    v10 = *(unsigned int **)(v9 + 16);
    if (v10)
    {
      do
      {
        v11 = __ldaxr(v10);
        v12 = v11 - 1;
      }
      while (__stlxr(v12, v10));
      if (!v12)
        MEMORY[0x20BD0ADEC]();
    }
    MEMORY[0x20BD0ADEC](v9, 0x10E0C40FBA89811);
  }
  v13 = (void *)*((_QWORD *)this + 6);
  if (v13)
  {
    *((_QWORD *)this + 7) = v13;
    operator delete(v13);
  }
  v14 = (unsigned int *)*((_QWORD *)this + 4);
  if (v14)
  {
    do
    {
      v15 = __ldaxr(v14);
      v16 = v15 - 1;
    }
    while (__stlxr(v16, v14));
    if (!v16)
      MEMORY[0x20BD0ADEC]();
  }
  v17 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 216))(v17);
}

{
  webrtc::DegradedCall::~DegradedCall(this);
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'webrtc::DegradedCall::~DegradedCall(webrtc::DegradedCall *this)
{
  webrtc::DegradedCall::~DegradedCall((webrtc::DegradedCall *)((char *)this - 8));
}

{
  webrtc::DegradedCall::~DegradedCall((webrtc::DegradedCall *)((char *)this - 8));
  JUMPOUT(0x20BD0ADECLL);
}

unint64_t webrtc::DegradedCall::CreateAudioSendStream(webrtc::DegradedCall *this, const webrtc::AudioSendStream::Config *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v10;
  uint64_t v11;
  int64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  int v17;
  std::string *v18;
  __int128 *v19;
  __int128 v20;
  __int128 v21;
  const webrtc::AudioSendStream::Config *v22;
  const webrtc::AudioSendStream::Config *v23;
  const webrtc::AudioSendStream::Config *v24;
  BOOL v25;
  void (***v26)(_QWORD);
  void (***v27)(_QWORD);
  void (***v28)(_QWORD);
  unint64_t v29;
  unint64_t v30;
  uint64_t *v31;
  uint64_t **v32;
  uint64_t **v33;
  unint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t *v38;
  int v39;
  std::string v40;
  std::string v41;
  char v42;
  char *v43;
  char *v44;
  char *v45;
  std::string v46;
  __int128 v47;
  __int128 v48;
  char v49;
  std::string v50;
  char v51;
  int v52;
  std::string v53;
  __int128 v54;
  uint64_t *v55;
  uint64_t v56[2];
  _OWORD v57[2];
  char v58;
  void (***v59)(_QWORD);
  __int128 v60;
  std::string v61;
  int v62;
  char v63;
  void (***v64)(_QWORD);
  void (***v65)(_QWORD);

  if (*((_QWORD *)this + 6) == *((_QWORD *)this + 7))
    return (***((uint64_t (****)(_QWORD, const webrtc::AudioSendStream::Config *))this + 3))(*((_QWORD *)this + 3), a2);
  v4 = *((_QWORD *)this + 10);
  v5 = *((_QWORD *)this + 3);
  v6 = (uint64_t *)operator new();
  v7 = *((_QWORD *)this + 2);
  v8 = (uint64_t *)*((_QWORD *)a2 + 15);
  *v6 = (uint64_t)off_24C0B3040;
  v6[1] = v4;
  v6[2] = v5;
  v6[3] = v7;
  v6[4] = (uint64_t)v8;
  webrtc::FakeNetworkPipe::AddActiveTransport(v4 + 24, v8);
  v39 = *(_DWORD *)a2;
  if (*((char *)a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&v40, *((const std::string::value_type **)a2 + 1), *((_QWORD *)a2 + 2));
    if ((*((char *)a2 + 55) & 0x80000000) == 0)
      goto LABEL_4;
LABEL_7:
    std::string::__init_copy_ctor_external(&v41, *((const std::string::value_type **)a2 + 4), *((_QWORD *)a2 + 5));
    goto LABEL_8;
  }
  v40 = *(std::string *)((char *)a2 + 8);
  if (*((char *)a2 + 55) < 0)
    goto LABEL_7;
LABEL_4:
  v41 = *(std::string *)((char *)a2 + 32);
LABEL_8:
  v42 = *((_BYTE *)a2 + 56);
  v44 = 0;
  v45 = 0;
  v43 = 0;
  v10 = *((_QWORD *)a2 + 8);
  v11 = *((_QWORD *)a2 + 9);
  v12 = v11 - v10;
  if (v11 != v10)
  {
    if (v12 < 0)
      abort();
    v13 = v12 >> 5;
    v14 = (char *)operator new(v12);
    v15 = 0;
    v43 = v14;
    v44 = v14;
    v45 = &v14[32 * v13];
    do
    {
      v18 = (std::string *)&v14[v15];
      v19 = (__int128 *)(v10 + v15);
      if (*(char *)(v10 + v15 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v18, *(const std::string::value_type **)v19, *((_QWORD *)v19 + 1));
      }
      else
      {
        v20 = *v19;
        v18->__r_.__value_.__r.__words[2] = *((_QWORD *)v19 + 2);
        *(_OWORD *)&v18->__r_.__value_.__l.__data_ = v20;
      }
      v16 = &v14[v15];
      v17 = *(_DWORD *)(v10 + v15 + 24);
      v16[28] = *(_BYTE *)(v10 + v15 + 28);
      *((_DWORD *)v16 + 6) = v17;
      v15 += 32;
    }
    while (v10 + v15 != v11);
    v44 = &v14[v15];
  }
  if (*((char *)a2 + 111) < 0)
    std::string::__init_copy_ctor_external(&v46, *((const std::string::value_type **)a2 + 11), *((_QWORD *)a2 + 12));
  else
    v46 = *(std::string *)((char *)a2 + 88);
  v21 = *((_OWORD *)a2 + 8);
  v47 = *((_OWORD *)a2 + 7);
  v48 = v21;
  v49 = *((_BYTE *)a2 + 144);
  v50.__r_.__value_.__s.__data_[0] = 0;
  v51 = 0;
  if (*((_BYTE *)a2 + 176))
  {
    if (*((char *)a2 + 175) < 0)
      std::string::__init_copy_ctor_external(&v50, *((const std::string::value_type **)a2 + 19), *((_QWORD *)a2 + 20));
    else
      v50 = *(std::string *)((char *)a2 + 152);
    v51 = 1;
  }
  LOBYTE(v52) = 0;
  v58 = 0;
  if (*((_BYTE *)a2 + 288))
  {
    v52 = *((_DWORD *)a2 + 46);
    if (*((char *)a2 + 215) < 0)
      std::string::__init_copy_ctor_external(&v53, *((const std::string::value_type **)a2 + 24), *((_QWORD *)a2 + 25));
    else
      v53 = *(std::string *)((_BYTE *)a2 + 8);
    v54 = *(_OWORD *)((char *)a2 + 216);
    v56[0] = 0;
    v56[1] = 0;
    v55 = v56;
    v22 = (const webrtc::AudioSendStream::Config *)*((_QWORD *)a2 + 29);
    if (v22 != (const webrtc::AudioSendStream::Config *)((char *)a2 + 240))
    {
      do
      {
        std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::string> const&>(&v55, v56, (uint64_t)v22 + 32, (uint64_t)v22 + 32);
        v23 = (const webrtc::AudioSendStream::Config *)*((_QWORD *)v22 + 1);
        if (v23)
        {
          do
          {
            v24 = v23;
            v23 = *(const webrtc::AudioSendStream::Config **)v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            v24 = (const webrtc::AudioSendStream::Config *)*((_QWORD *)v22 + 2);
            v25 = *(_QWORD *)v24 == (_QWORD)v22;
            v22 = v24;
          }
          while (!v25);
        }
        v22 = v24;
      }
      while (v24 != (const webrtc::AudioSendStream::Config *)((char *)a2 + 240));
    }
    *(_OWORD *)((char *)v57 + 9) = *(_OWORD *)((char *)a2 + 265);
    v57[0] = *((_OWORD *)a2 + 16);
    v58 = 1;
  }
  v26 = (void (***)(_QWORD))*((_QWORD *)a2 + 37);
  v59 = v26;
  if (v26)
    (**v26)(v26);
  v60 = *((_OWORD *)a2 + 19);
  if (*((char *)a2 + 343) < 0)
    std::string::__init_copy_ctor_external(&v61, *((const std::string::value_type **)a2 + 40), *((_QWORD *)a2 + 41));
  else
    v61 = *(std::string *)((char *)a2 + 320);
  v62 = *((_DWORD *)a2 + 86);
  v63 = *((_BYTE *)a2 + 348);
  v27 = (void (***)(_QWORD))*((_QWORD *)a2 + 44);
  v64 = v27;
  if (v27)
    (**v27)(v27);
  v28 = (void (***)(_QWORD))*((_QWORD *)a2 + 45);
  v65 = v28;
  if (v28)
    (**v28)(v28);
  *((_QWORD *)&v47 + 1) = v6;
  v29 = (***((uint64_t (****)(_QWORD, int *))this + 3))(*((_QWORD *)this + 3), &v39);
  v30 = v29;
  if (v29)
  {
    v32 = (uint64_t **)((char *)this + 96);
    v31 = (uint64_t *)*((_QWORD *)this + 12);
    if (v31)
    {
      while (1)
      {
        while (1)
        {
          v33 = (uint64_t **)v31;
          v34 = v31[4];
          if (v29 >= v34)
            break;
          v31 = *v33;
          v32 = v33;
          if (!*v33)
            goto LABEL_55;
        }
        if (v34 >= v29)
          break;
        v31 = v33[1];
        if (!v31)
        {
          v32 = v33 + 1;
          goto LABEL_55;
        }
      }
    }
    else
    {
      v33 = (uint64_t **)((char *)this + 96);
LABEL_55:
      v35 = (uint64_t *)v33;
      v33 = (uint64_t **)operator new(0x30uLL);
      v33[4] = (uint64_t *)v30;
      v33[5] = 0;
      *v33 = 0;
      v33[1] = 0;
      v33[2] = v35;
      *v32 = (uint64_t *)v33;
      v36 = **((_QWORD **)this + 11);
      v37 = (uint64_t *)v33;
      if (v36)
      {
        *((_QWORD *)this + 11) = v36;
        v37 = *v32;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 12), v37);
      ++*((_QWORD *)this + 13);
    }
    v38 = v33[5];
    v33[5] = v6;
    if (v38)
      (*(void (**)(uint64_t *))(*v38 + 24))(v38);
    webrtc::AudioSendStream::Config::~Config((webrtc::AudioSendStream::Config *)&v39);
  }
  else
  {
    webrtc::AudioSendStream::Config::~Config((webrtc::AudioSendStream::Config *)&v39);
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
  }
  return v30;
}

void webrtc::DegradedCall::DestroyAudioSendStream(uint64_t a1, unint64_t a2)
{
  uint64_t *v4;
  uint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  BOOL v13;
  uint64_t v14;

  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 8))(*(_QWORD *)(a1 + 24));
  v4 = *(uint64_t **)(a1 + 96);
  if (v4)
  {
    v5 = (uint64_t *)(a1 + 96);
    v6 = *(_QWORD **)(a1 + 96);
    do
    {
      v7 = v6[4];
      v8 = v7 >= a2;
      if (v7 >= a2)
        v9 = v6;
      else
        v9 = v6 + 1;
      if (v8)
        v5 = v6;
      v6 = (_QWORD *)*v9;
    }
    while (*v9);
    if (v5 != (uint64_t *)(a1 + 96) && v5[4] <= a2)
    {
      v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        v12 = v5;
        do
        {
          v11 = (uint64_t *)v12[2];
          v13 = *v11 == (_QWORD)v12;
          v12 = v11;
        }
        while (!v13);
      }
      if (*(uint64_t **)(a1 + 88) == v5)
        *(_QWORD *)(a1 + 88) = v11;
      --*(_QWORD *)(a1 + 104);
      std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v4, v5);
      v14 = v5[5];
      v5[5] = 0;
      if (v14)
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
      operator delete(v5);
    }
  }
}

uint64_t webrtc::DegradedCall::CreateAudioReceiveStream(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 16))(*(_QWORD *)(a1 + 24));
}

uint64_t webrtc::DegradedCall::DestroyAudioReceiveStream(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 24))(*(_QWORD *)(a1 + 24));
}

unint64_t webrtc::DegradedCall::CreateVideoSendStream(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t *v27;
  uint64_t **v28;
  uint64_t **v29;
  unint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  _BYTE v36[81];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int16 v41;
  __int128 v42;
  int v43;
  char v44;
  uint64_t v45;
  int v46;
  __int128 v47;
  uint64_t v48;
  _QWORD *v49;
  _QWORD v50[3];
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  int v56;
  char v57;
  uint64_t v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;
  __int128 v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 48) == *(_QWORD *)(a1 + 56))
  {
    v8 = 0;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 80);
    v7 = *(_QWORD *)(a1 + 24);
    v8 = (uint64_t *)operator new();
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(uint64_t **)(a2 + 312);
    *v8 = (uint64_t)off_24C0B3040;
    v8[1] = v6;
    v8[2] = v7;
    v8[3] = v9;
    v8[4] = (uint64_t)v10;
    webrtc::FakeNetworkPipe::AddActiveTransport(v6 + 24, v10);
    *(_QWORD *)(a2 + 312) = v8;
  }
  v11 = *(_QWORD *)(a1 + 24);
  webrtc::RtpConfig::RtpConfig((uint64_t)v36, a2);
  v12 = *(_OWORD *)(a2 + 312);
  v39 = *(_OWORD *)(a2 + 296);
  v40 = v12;
  v13 = *(_OWORD *)(a2 + 280);
  v37 = *(_OWORD *)(a2 + 264);
  v38 = v13;
  v41 = *(_WORD *)(a2 + 328);
  v14 = *(_OWORD *)(a2 + 336);
  *(_QWORD *)(a2 + 336) = 0;
  v42 = v14;
  v43 = *(_DWORD *)(a2 + 352);
  v44 = *(_BYTE *)(a2 + 356);
  v15 = *(_QWORD *)(a2 + 360);
  *(_QWORD *)(a2 + 360) = 0;
  v45 = v15;
  v46 = *a3;
  v47 = *(_OWORD *)(a3 + 2);
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  v16 = *((_QWORD *)a3 + 3);
  v17 = (_QWORD *)*((_QWORD *)a3 + 4);
  *((_QWORD *)a3 + 3) = 0;
  v48 = v16;
  v49 = v17;
  v18 = a3 + 10;
  v19 = *((_QWORD *)a3 + 5);
  v20 = *((_QWORD *)a3 + 6);
  v50[0] = v19;
  v50[1] = v20;
  if (v20)
  {
    *(_QWORD *)(v19 + 16) = v50;
    *((_QWORD *)a3 + 4) = v18;
    *v18 = 0;
    *((_QWORD *)a3 + 6) = 0;
  }
  else
  {
    v49 = v50;
  }
  v50[2] = *((_QWORD *)a3 + 7);
  v21 = *((_OWORD *)a3 + 5);
  v51 = *((_OWORD *)a3 + 4);
  v52 = v21;
  v53 = *((_QWORD *)a3 + 12);
  *((_QWORD *)a3 + 7) = 0;
  v22 = *(_OWORD *)(a3 + 26);
  *((_QWORD *)a3 + 13) = 0;
  *((_QWORD *)a3 + 14) = 0;
  v54 = v22;
  v55 = *(_OWORD *)(a3 + 30);
  *((_QWORD *)a3 + 15) = 0;
  *((_QWORD *)a3 + 16) = 0;
  v23 = a3[34];
  v57 = *((_BYTE *)a3 + 140);
  v56 = v23;
  v24 = *((_QWORD *)a3 + 18);
  *((_QWORD *)a3 + 18) = 0;
  v59 = *(_OWORD *)(a3 + 38);
  v60 = *(_OWORD *)(a3 + 42);
  v25 = *((_QWORD *)a3 + 23);
  v58 = v24;
  v61 = v25;
  *((_QWORD *)a3 + 21) = 0;
  *((_QWORD *)a3 + 22) = 0;
  *((_QWORD *)a3 + 23) = 0;
  v62 = *((_OWORD *)a3 + 12);
  v26 = (*(uint64_t (**)(uint64_t, _BYTE *, int *))(*(_QWORD *)v11 + 32))(v11, v36, &v46);
  webrtc::VideoEncoderConfig::~VideoEncoderConfig((webrtc::VideoEncoderConfig *)&v46);
  if (v45)
    (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
  if ((_QWORD)v42)
    (*(void (**)(_QWORD))(*(_QWORD *)v42 + 8))(v42);
  webrtc::RtpConfig::~RtpConfig((webrtc::RtpConfig *)v36);
  if (!v26)
  {
    if (!v8)
      return v26;
    goto LABEL_24;
  }
  if (v8)
  {
    v28 = (uint64_t **)(a1 + 120);
    v27 = *(uint64_t **)(a1 + 120);
    if (v27)
    {
      while (1)
      {
        while (1)
        {
          v29 = (uint64_t **)v27;
          v30 = v27[4];
          if (v26 >= v30)
            break;
          v27 = *v29;
          v28 = v29;
          if (!*v29)
            goto LABEL_20;
        }
        if (v30 >= v26)
          break;
        v27 = v29[1];
        if (!v27)
        {
          v28 = v29 + 1;
          goto LABEL_20;
        }
      }
    }
    else
    {
      v29 = (uint64_t **)(a1 + 120);
LABEL_20:
      v31 = (uint64_t *)v29;
      v29 = (uint64_t **)operator new(0x30uLL);
      v29[4] = (uint64_t *)v26;
      v29[5] = 0;
      *v29 = 0;
      v29[1] = 0;
      v29[2] = v31;
      *v28 = (uint64_t *)v29;
      v32 = **(_QWORD **)(a1 + 112);
      v33 = (uint64_t *)v29;
      if (v32)
      {
        *(_QWORD *)(a1 + 112) = v32;
        v33 = *v28;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 120), v33);
      ++*(_QWORD *)(a1 + 128);
    }
    v34 = v29[5];
    v29[5] = v8;
    v8 = v34;
    if (v34)
LABEL_24:
      (*(void (**)(uint64_t *))(*v8 + 24))(v8);
  }
  return v26;
}

unint64_t webrtc::DegradedCall::CreateVideoSendStream(uint64_t a1, uint64_t a2, int *a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t **v33;
  uint64_t **v34;
  unint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v41;
  _BYTE v42[81];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int16 v47;
  __int128 v48;
  int v49;
  char v50;
  uint64_t v51;
  int v52;
  __int128 v53;
  uint64_t v54;
  _QWORD *v55;
  _QWORD v56[3];
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  __int128 v60;
  __int128 v61;
  int v62;
  char v63;
  uint64_t v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;
  __int128 v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 48) == *(_QWORD *)(a1 + 56))
  {
    v10 = 0;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 80);
    v9 = *(_QWORD *)(a1 + 24);
    v10 = (uint64_t *)operator new();
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(uint64_t **)(a2 + 312);
    *v10 = (uint64_t)off_24C0B3040;
    v10[1] = v8;
    v10[2] = v9;
    v10[3] = v11;
    v10[4] = (uint64_t)v12;
    webrtc::FakeNetworkPipe::AddActiveTransport(v8 + 24, v12);
    *(_QWORD *)(a2 + 312) = v10;
  }
  v13 = *(_QWORD *)(a1 + 24);
  webrtc::RtpConfig::RtpConfig((uint64_t)v42, a2);
  v14 = *(_OWORD *)(a2 + 312);
  v45 = *(_OWORD *)(a2 + 296);
  v46 = v14;
  v15 = *(_OWORD *)(a2 + 280);
  v43 = *(_OWORD *)(a2 + 264);
  v44 = v15;
  v47 = *(_WORD *)(a2 + 328);
  v16 = *(_OWORD *)(a2 + 336);
  *(_QWORD *)(a2 + 336) = 0;
  v48 = v16;
  v49 = *(_DWORD *)(a2 + 352);
  v50 = *(_BYTE *)(a2 + 356);
  v17 = *(_QWORD *)(a2 + 360);
  *(_QWORD *)(a2 + 360) = 0;
  v51 = v17;
  v52 = *a3;
  v53 = *(_OWORD *)(a3 + 2);
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  v18 = *((_QWORD *)a3 + 3);
  v19 = (_QWORD *)*((_QWORD *)a3 + 4);
  *((_QWORD *)a3 + 3) = 0;
  v54 = v18;
  v55 = v19;
  v20 = a3 + 10;
  v21 = *((_QWORD *)a3 + 5);
  v22 = *((_QWORD *)a3 + 6);
  v56[0] = v21;
  v56[1] = v22;
  if (v22)
  {
    *(_QWORD *)(v21 + 16) = v56;
    *((_QWORD *)a3 + 4) = v20;
    *v20 = 0;
    *((_QWORD *)a3 + 6) = 0;
  }
  else
  {
    v55 = v56;
  }
  v23 = *((_QWORD *)a3 + 7);
  v24 = *((_OWORD *)a3 + 5);
  v57 = *((_OWORD *)a3 + 4);
  v58 = v24;
  v25 = *((_QWORD *)a3 + 12);
  v56[2] = v23;
  v59 = v25;
  *((_QWORD *)a3 + 7) = 0;
  v26 = *(_OWORD *)(a3 + 26);
  *((_QWORD *)a3 + 13) = 0;
  *((_QWORD *)a3 + 14) = 0;
  v60 = v26;
  v61 = *(_OWORD *)(a3 + 30);
  *((_QWORD *)a3 + 15) = 0;
  *((_QWORD *)a3 + 16) = 0;
  LODWORD(v23) = a3[34];
  v63 = *((_BYTE *)a3 + 140);
  v62 = v23;
  v27 = *((_QWORD *)a3 + 18);
  *((_QWORD *)a3 + 18) = 0;
  v65 = *(_OWORD *)(a3 + 38);
  v66 = *(_OWORD *)(a3 + 42);
  v28 = *((_QWORD *)a3 + 23);
  v64 = v27;
  v67 = v28;
  *((_QWORD *)a3 + 21) = 0;
  *((_QWORD *)a3 + 22) = 0;
  *((_QWORD *)a3 + 23) = 0;
  v68 = *((_OWORD *)a3 + 12);
  v29 = *a4;
  *a4 = 0;
  v41 = v29;
  v30 = (*(uint64_t (**)(uint64_t, _BYTE *, int *, uint64_t *))(*(_QWORD *)v13 + 40))(v13, v42, &v52, &v41);
  v31 = v41;
  v41 = 0;
  if (v31)
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
  webrtc::VideoEncoderConfig::~VideoEncoderConfig((webrtc::VideoEncoderConfig *)&v52);
  if (v51)
    (*(void (**)(uint64_t))(*(_QWORD *)v51 + 8))(v51);
  if ((_QWORD)v48)
    (*(void (**)(_QWORD))(*(_QWORD *)v48 + 8))(v48);
  webrtc::RtpConfig::~RtpConfig((webrtc::RtpConfig *)v42);
  if (!v30)
  {
    if (!v10)
      return v30;
    goto LABEL_26;
  }
  if (v10)
  {
    v33 = (uint64_t **)(a1 + 120);
    v32 = *(uint64_t **)(a1 + 120);
    if (v32)
    {
      while (1)
      {
        while (1)
        {
          v34 = (uint64_t **)v32;
          v35 = v32[4];
          if (v30 >= v35)
            break;
          v32 = *v34;
          v33 = v34;
          if (!*v34)
            goto LABEL_22;
        }
        if (v35 >= v30)
          break;
        v32 = v34[1];
        if (!v32)
        {
          v33 = v34 + 1;
          goto LABEL_22;
        }
      }
    }
    else
    {
      v34 = (uint64_t **)(a1 + 120);
LABEL_22:
      v36 = (uint64_t *)v34;
      v34 = (uint64_t **)operator new(0x30uLL);
      v34[4] = (uint64_t *)v30;
      v34[5] = 0;
      *v34 = 0;
      v34[1] = 0;
      v34[2] = v36;
      *v33 = (uint64_t *)v34;
      v37 = **(_QWORD **)(a1 + 112);
      v38 = (uint64_t *)v34;
      if (v37)
      {
        *(_QWORD *)(a1 + 112) = v37;
        v38 = *v33;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 120), v38);
      ++*(_QWORD *)(a1 + 128);
    }
    v39 = v34[5];
    v34[5] = v10;
    v10 = v39;
    if (v39)
LABEL_26:
      (*(void (**)(uint64_t *))(*v10 + 24))(v10);
  }
  return v30;
}

void webrtc::DegradedCall::DestroyVideoSendStream(uint64_t a1, unint64_t a2)
{
  uint64_t *v4;
  uint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  BOOL v13;
  uint64_t v14;

  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 48))(*(_QWORD *)(a1 + 24));
  v4 = *(uint64_t **)(a1 + 120);
  if (v4)
  {
    v5 = (uint64_t *)(a1 + 120);
    v6 = *(_QWORD **)(a1 + 120);
    do
    {
      v7 = v6[4];
      v8 = v7 >= a2;
      if (v7 >= a2)
        v9 = v6;
      else
        v9 = v6 + 1;
      if (v8)
        v5 = v6;
      v6 = (_QWORD *)*v9;
    }
    while (*v9);
    if (v5 != (uint64_t *)(a1 + 120) && v5[4] <= a2)
    {
      v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        v12 = v5;
        do
        {
          v11 = (uint64_t *)v12[2];
          v13 = *v11 == (_QWORD)v12;
          v12 = v11;
        }
        while (!v13);
      }
      if (*(uint64_t **)(a1 + 112) == v5)
        *(_QWORD *)(a1 + 112) = v11;
      --*(_QWORD *)(a1 + 128);
      std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v4, v5);
      v14 = v5[5];
      v5[5] = 0;
      if (v14)
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
      operator delete(v5);
    }
  }
}

uint64_t webrtc::DegradedCall::CreateVideoReceiveStream(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  __int128 v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD v12[2];
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD v18[2];
  _QWORD *v19;
  _QWORD v20[2];
  _QWORD v21[7];
  int v22;
  char v23;
  uint64_t v24;

  v3 = *(_QWORD *)(a1 + 24);
  v4 = *(_OWORD *)(a2 + 16);
  v12[0] = *(_OWORD *)a2;
  v12[1] = v4;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v13 = *(_QWORD *)(a2 + 32);
  v14 = *(_OWORD *)(a2 + 40);
  v15 = *(_OWORD *)(a2 + 56);
  v6 = *(_QWORD *)(a2 + 72);
  v5 = *(int **)(a2 + 80);
  v16 = v6;
  v17 = v18;
  v18[0] = 0;
  v18[1] = 0;
  std::map<int,int>::insert[abi:sn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<int,int>,std::__tree_node<std::__value_type<int,int>,void *> *,long>>>((uint64_t *)&v17, v5, (int *)(a2 + 88));
  v20[0] = 0;
  v20[1] = 0;
  v19 = v20;
  std::set<int>::insert[abi:sn180100]<std::__tree_const_iterator<int,std::__tree_node<int,void *> *,long>>((uint64_t *)&v19, *(int **)(a2 + 104), (int *)(a2 + 112));
  *(_OWORD *)v21 = *(_OWORD *)(a2 + 128);
  *(_QWORD *)((char *)&v21[1] + 5) = *(_QWORD *)(a2 + 141);
  *(_OWORD *)&v21[3] = *(_OWORD *)(a2 + 152);
  *(_QWORD *)(a2 + 152) = 0;
  *(_QWORD *)(a2 + 160) = 0;
  v7 = *(_QWORD *)(a2 + 168);
  v8 = *(_QWORD *)(a2 + 176);
  *(_QWORD *)(a2 + 168) = 0;
  *(_QWORD *)(a2 + 176) = 0;
  v21[5] = v7;
  v21[6] = v8;
  v22 = *(_DWORD *)(a2 + 184);
  v23 = *(_BYTE *)(a2 + 188);
  v9 = *(_QWORD *)(a2 + 192);
  *(_QWORD *)(a2 + 192) = 0;
  v24 = v9;
  v10 = (*(uint64_t (**)(uint64_t, _OWORD *))(*(_QWORD *)v3 + 56))(v3, v12);
  webrtc::VideoReceiveStreamInterface::Config::~Config((webrtc::VideoReceiveStreamInterface::Config *)v12);
  return v10;
}

uint64_t webrtc::DegradedCall::DestroyVideoReceiveStream(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
}

uint64_t webrtc::DegradedCall::CreateFlexfecReceiveStream(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  int64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v11;
  int v12;
  void *__p;
  void *v14;
  char *v15;
  __int128 v16;

  v3 = *(_QWORD *)(a1 + 24);
  v11 = *a2;
  v12 = *((_DWORD *)a2 + 2);
  v14 = 0;
  v15 = 0;
  __p = 0;
  v5 = (_BYTE *)a2[2];
  v4 = (_BYTE *)a2[3];
  v6 = v4 - v5;
  if (v4 != v5)
  {
    if (v6 < 0)
      abort();
    v7 = (char *)operator new(v4 - v5);
    v8 = &v7[4 * (v6 >> 2)];
    __p = v7;
    v15 = v8;
    memcpy(v7, v5, v6);
    v14 = v8;
  }
  v16 = *(_OWORD *)(a2 + 5);
  v9 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 72))(v3, &v11);
  if (__p)
  {
    v14 = __p;
    operator delete(__p);
  }
  return v9;
}

uint64_t webrtc::DegradedCall::DestroyFlexfecReceiveStream(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 80))(*(_QWORD *)(a1 + 24));
}

uint64_t webrtc::DegradedCall::AddAdaptationResource(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 24);
  v3 = *a2;
  *a2 = 0;
  v5 = v3;
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 88))(v2, &v5);
  result = v5;
  if (v5)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  return result;
}

uint64_t webrtc::DegradedCall::Receiver(webrtc::DegradedCall *this)
{
  if (*((_QWORD *)this + 18) == *((_QWORD *)this + 19))
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 96))(*((_QWORD *)this + 3));
  else
    return (uint64_t)this + 8;
}

uint64_t webrtc::DegradedCall::GetTransportControllerSend(webrtc::DegradedCall *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 104))(*((_QWORD *)this + 3));
}

uint64_t webrtc::DegradedCall::GetStats(webrtc::DegradedCall *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 112))(*((_QWORD *)this + 3));
}

uint64_t webrtc::DegradedCall::trials(webrtc::DegradedCall *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 184))(*((_QWORD *)this + 3));
}

uint64_t webrtc::DegradedCall::network_thread(webrtc::DegradedCall *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 192))(*((_QWORD *)this + 3));
}

uint64_t webrtc::DegradedCall::worker_thread(webrtc::DegradedCall *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 200))(*((_QWORD *)this + 3));
}

uint64_t webrtc::DegradedCall::SignalChannelNetworkState(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 120))(*(_QWORD *)(a1 + 24));
}

uint64_t webrtc::DegradedCall::OnAudioTransportOverheadChanged(webrtc::DegradedCall *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 128))(*((_QWORD *)this + 3));
}

uint64_t webrtc::DegradedCall::OnLocalSsrcUpdated(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 136))(*(_QWORD *)(a1 + 24));
}

{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 144))(*(_QWORD *)(a1 + 24));
}

{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 152))(*(_QWORD *)(a1 + 24));
}

uint64_t webrtc::DegradedCall::OnUpdateSyncGroup(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 160))(*(_QWORD *)(a1 + 24));
}

uint64_t webrtc::DegradedCall::OnSentPacket(uint64_t result)
{
  if (*(_QWORD *)(result + 48) == *(_QWORD *)(result + 56))
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(result + 24) + 168))(*(_QWORD *)(result + 24));
  return result;
}

uint64_t webrtc::DegradedCall::DeliverRtpPacket(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  _BYTE v24[16];
  __int128 v25;
  _OWORD v26[2];
  _BYTE v27[22];
  void *__p[2];
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  char v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v7 = *(_QWORD *)(a1 + 184);
  v8 = *(_OWORD *)(a3 + 16);
  v26[0] = *(_OWORD *)a3;
  v26[1] = v8;
  *(_OWORD *)v27 = *(_OWORD *)(a3 + 32);
  *(_QWORD *)&v27[14] = *(_QWORD *)(a3 + 46);
  *(_OWORD *)__p = *(_OWORD *)(a3 + 56);
  *(_QWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 64) = 0;
  v9 = *(_QWORD *)(a3 + 72);
  v10 = *(_QWORD *)(a3 + 80);
  *(_QWORD *)(a3 + 72) = 0;
  v29 = v9;
  v30 = v10;
  v31 = *(_QWORD *)(a3 + 88);
  v11 = *(_OWORD *)(a3 + 96);
  v12 = *(_OWORD *)(a3 + 112);
  *(_QWORD *)(a3 + 96) = 0;
  *(_QWORD *)(a3 + 104) = 0;
  *(_QWORD *)(a3 + 88) = 0;
  v34 = *(_BYTE *)(a3 + 128);
  v32 = v11;
  v33 = v12;
  v13 = *(_QWORD *)(a3 + 136);
  *(_QWORD *)(a3 + 136) = 0;
  v35 = v13;
  (*(void (**)(_QWORD, uint64_t, _BYTE *))(a4 + 16))(0, a4, v24);
  v25 = *(_OWORD *)(a4 + 16);
  *(_QWORD *)(a4 + 16) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(a4 + 24) = 0;
  (*(void (**)(uint64_t, uint64_t, _OWORD *, _BYTE *))(*(_QWORD *)v7 + 8))(v7, a2, v26, v24);
  ((void (*)(uint64_t, _BYTE *, _BYTE *))v25)(1, v24, v24);
  v14 = v35;
  if (v35)
  {
    v15 = (unsigned int *)(v35 + 8);
    do
    {
      v16 = __ldaxr(v15);
      v17 = v16 - 1;
    }
    while (__stlxr(v17, v15));
    if (!v17)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  }
  v18 = v31;
  if (v31)
  {
    v19 = (unsigned int *)(v31 + 24);
    do
    {
      v20 = __ldaxr(v19);
      v21 = v20 - 1;
    }
    while (__stlxr(v21, v19));
    if (!v21)
    {
      v22 = *(_QWORD *)(v18 + 16);
      *(_QWORD *)(v18 + 16) = 0;
      if (v22)
        MEMORY[0x20BD0ADD4](v22, 0x1000C8077774924);
      MEMORY[0x20BD0ADEC](v18, 0x1010C40EE34DA14);
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 48))(*(_QWORD *)(a1 + 184));
}

uint64_t `non-virtual thunk to'webrtc::DegradedCall::DeliverRtpPacket(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  _BYTE v24[16];
  __int128 v25;
  _OWORD v26[2];
  _BYTE v27[22];
  void *__p[2];
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  char v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v7 = *(_QWORD *)(a1 + 176);
  v8 = *(_OWORD *)(a3 + 16);
  v26[0] = *(_OWORD *)a3;
  v26[1] = v8;
  *(_OWORD *)v27 = *(_OWORD *)(a3 + 32);
  *(_QWORD *)&v27[14] = *(_QWORD *)(a3 + 46);
  *(_OWORD *)__p = *(_OWORD *)(a3 + 56);
  *(_QWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 64) = 0;
  v9 = *(_QWORD *)(a3 + 72);
  v10 = *(_QWORD *)(a3 + 80);
  *(_QWORD *)(a3 + 72) = 0;
  v29 = v9;
  v30 = v10;
  v31 = *(_QWORD *)(a3 + 88);
  v11 = *(_OWORD *)(a3 + 96);
  v12 = *(_OWORD *)(a3 + 112);
  *(_QWORD *)(a3 + 96) = 0;
  *(_QWORD *)(a3 + 104) = 0;
  *(_QWORD *)(a3 + 88) = 0;
  v34 = *(_BYTE *)(a3 + 128);
  v32 = v11;
  v33 = v12;
  v13 = *(_QWORD *)(a3 + 136);
  *(_QWORD *)(a3 + 136) = 0;
  v35 = v13;
  (*(void (**)(_QWORD, uint64_t, _BYTE *))(a4 + 16))(0, a4, v24);
  v25 = *(_OWORD *)(a4 + 16);
  *(_QWORD *)(a4 + 16) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(a4 + 24) = 0;
  (*(void (**)(uint64_t, uint64_t, _OWORD *, _BYTE *))(*(_QWORD *)v7 + 8))(v7, a2, v26, v24);
  ((void (*)(uint64_t, _BYTE *, _BYTE *))v25)(1, v24, v24);
  v14 = v35;
  if (v35)
  {
    v15 = (unsigned int *)(v35 + 8);
    do
    {
      v16 = __ldaxr(v15);
      v17 = v16 - 1;
    }
    while (__stlxr(v17, v15));
    if (!v17)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  }
  v18 = v31;
  if (v31)
  {
    v19 = (unsigned int *)(v31 + 24);
    do
    {
      v20 = __ldaxr(v19);
      v21 = v20 - 1;
    }
    while (__stlxr(v21, v19));
    if (!v21)
    {
      v22 = *(_QWORD *)(v18 + 16);
      *(_QWORD *)(v18 + 16) = 0;
      if (v22)
        MEMORY[0x20BD0ADD4](v22, 0x1000C8077774924);
      MEMORY[0x20BD0ADEC](v18, 0x1010C40EE34DA14);
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 176) + 48))(*(_QWORD *)(a1 + 176));
}

uint64_t webrtc::DegradedCall::DeliverRtcpPacket(uint64_t a1, uint64_t *a2)
{
  void (***v3)(_QWORD, uint64_t *);
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v10;
  __int128 v11;

  v3 = *(void (****)(_QWORD, uint64_t *))(a1 + 184);
  v10 = *a2;
  v11 = *(_OWORD *)(a2 + 1);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  (**v3)(v3, &v10);
  v4 = v10;
  if (v10)
  {
    v5 = (unsigned int *)(v10 + 24);
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while (__stlxr(v7, v5));
    if (!v7)
    {
      v8 = *(_QWORD *)(v4 + 16);
      *(_QWORD *)(v4 + 16) = 0;
      if (v8)
        MEMORY[0x20BD0ADD4](v8, 0x1000C8077774924);
      MEMORY[0x20BD0ADEC](v4, 0x1010C40EE34DA14);
    }
  }
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 48))(*(_QWORD *)(a1 + 184));
}

uint64_t `non-virtual thunk to'webrtc::DegradedCall::DeliverRtcpPacket(uint64_t a1, uint64_t *a2)
{
  void (***v3)(_QWORD, uint64_t *);
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v10;
  __int128 v11;

  v3 = *(void (****)(_QWORD, uint64_t *))(a1 + 176);
  v10 = *a2;
  v11 = *(_OWORD *)(a2 + 1);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  (**v3)(v3, &v10);
  v4 = v10;
  if (v10)
  {
    v5 = (unsigned int *)(v10 + 24);
    do
    {
      v6 = __ldaxr(v5);
      v7 = v6 - 1;
    }
    while (__stlxr(v7, v5));
    if (!v7)
    {
      v8 = *(_QWORD *)(v4 + 16);
      *(_QWORD *)(v4 + 16) = 0;
      if (v8)
        MEMORY[0x20BD0ADD4](v8, 0x1000C8077774924);
      MEMORY[0x20BD0ADEC](v4, 0x1010C40EE34DA14);
    }
  }
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 176) + 48))(*(_QWORD *)(a1 + 176));
}

uint64_t webrtc::DegradedCall::SetClientBitratePreferences(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 176))(*(_QWORD *)(a1 + 24));
}

_QWORD *webrtc::DegradedCall::UpdateSendNetworkConfig(webrtc::DegradedCall *this)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  _QWORD *result;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char v11;
  char v12;
  _QWORD v13[2];
  uint64_t (*v14)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v15)(uint64_t);

  v2 = *((_QWORD *)this + 6);
  v3 = (*((_QWORD *)this + 5) + 1) % (unint64_t)((*((_QWORD *)this + 7) - v2) >> 6);
  *((_QWORD *)this + 5) = v3;
  (*(void (**)(_QWORD, unint64_t))(**((_QWORD **)this + 9) + 48))(*((_QWORD *)this + 9), v2 + (v3 << 6));
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 192))(*((_QWORD *)this + 3));
  v5 = (unsigned int *)*((_QWORD *)this + 4);
  if (v5)
  {
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  result = (_QWORD *)operator new();
  *result = v5;
  result[1] = this;
  result[3] = absl::internal_any_invocable::LocalManagerTrivial;
  result[4] = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DegradedCall::UpdateSendNetworkConfig(void)::$_0 &&>;
  v8 = *((_QWORD *)this + 6);
  v9 = *((_QWORD *)this + 5);
  if (v9 >= (*((_QWORD *)this + 7) - v8) >> 6)
  {
    __break(1u);
  }
  else
  {
    v10 = *(_QWORD *)(v8 + (v9 << 6) + 56);
    v13[0] = result;
    v14 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
    v15 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
    v12 = 0;
    (*(void (**)(uint64_t, _QWORD *, uint64_t, char *, char *))(*(_QWORD *)v4 + 16))(v4, v13, v10, &v12, &v11);
    return (_QWORD *)v14(1, v13, v13);
  }
  return result;
}

_QWORD *webrtc::DegradedCall::UpdateReceiveNetworkConfig(webrtc::DegradedCall *this)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  _QWORD *result;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char v11;
  char v12;
  _QWORD v13[2];
  uint64_t (*v14)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v15)(uint64_t);

  v2 = *((_QWORD *)this + 18);
  v3 = (*((_QWORD *)this + 17) + 1) % (unint64_t)((*((_QWORD *)this + 19) - v2) >> 6);
  *((_QWORD *)this + 17) = v3;
  (*(void (**)(_QWORD, unint64_t))(**((_QWORD **)this + 21) + 48))(*((_QWORD *)this + 21), v2 + (v3 << 6));
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 192))(*((_QWORD *)this + 3));
  v5 = (unsigned int *)*((_QWORD *)this + 4);
  if (v5)
  {
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  result = (_QWORD *)operator new();
  *result = v5;
  result[1] = this;
  result[3] = absl::internal_any_invocable::LocalManagerTrivial;
  result[4] = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DegradedCall::UpdateReceiveNetworkConfig(void)::$_0 &&>;
  v8 = *((_QWORD *)this + 18);
  v9 = *((_QWORD *)this + 17);
  if (v9 >= (*((_QWORD *)this + 19) - v8) >> 6)
  {
    __break(1u);
  }
  else
  {
    v10 = *(_QWORD *)(v8 + (v9 << 6) + 56);
    v13[0] = result;
    v14 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
    v15 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
    v12 = 0;
    (*(void (**)(uint64_t, _QWORD *, uint64_t, char *, char *))(*(_QWORD *)v4 + 16))(v4, v13, v10, &v12, &v11);
    return (_QWORD *)v14(1, v13, v13);
  }
  return result;
}

uint64_t absl::internal_any_invocable::RemoteInvoker<false,void,webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue::Process(void)::$_0 &&>(uint64_t result)
{
  _QWORD **v1;
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  char v11;
  _QWORD v12[2];
  uint64_t (*v13)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v14)(uint64_t);
  char v15;

  v1 = *(_QWORD ***)result;
  if (!*(_BYTE *)(*(_QWORD *)result + 16))
    goto LABEL_16;
  v3 = (uint64_t)*v1;
  v2 = v1[1];
  result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)**v1 + 16))(**v1);
  v4 = result / 0x3E8uLL;
  if (result % 0x3E8uLL > 0x1F3)
    ++v4;
  if (-result % 0x3E8uLL <= 0x1F4)
    v5 = 0;
  else
    v5 = -1;
  if (result < 0)
    v4 = v5 - -result / 0x3E8uLL;
  v6 = (char *)v2 + v4;
  if (!*(_BYTE *)(v3 + 304) || (uint64_t)v6 < *(_QWORD *)(v3 + 296))
  {
    *(_QWORD *)(v3 + 296) = v6;
    *(_BYTE *)(v3 + 304) = 1;
    v7 = *(_QWORD *)(v3 + 8);
    v8 = *(unsigned int **)(v3 + 16);
    if (v8)
    {
      do
        v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
    result = operator new();
    *(_QWORD *)result = v8;
    *(_QWORD *)(result + 8) = v3;
    *(_QWORD *)(result + 24) = absl::internal_any_invocable::LocalManagerTrivial;
    *(_QWORD *)(result + 32) = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue::Process(void)::$_0::operator() const(void)::{lambda(void)#2} &&>;
    if (*((_BYTE *)v1 + 16))
    {
      v10 = 1000 * (_QWORD)v1[1];
      v15 = 1;
      v12[0] = result;
      v13 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
      v14 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
      (*(void (**)(uint64_t, _QWORD *, uint64_t, char *, char *))(*(_QWORD *)v7 + 16))(v7, v12, v10, &v15, &v11);
      return v13(1, v12, v12);
    }
LABEL_16:
    __break(1u);
  }
  return result;
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue::Process(void)::$_0::operator() const(void)::{lambda(void)#2} &&>(webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue **a1)
{
  webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue *v1;
  uint64_t result;

  v1 = *a1;
  result = webrtc::DegradedCall::FakeNetworkPipeOnTaskQueue::Process(*a1);
  if ((result & 1) == 0)
  {
    if (*((_BYTE *)v1 + 304))
      *((_BYTE *)v1 + 304) = 0;
  }
  return result;
}

void std::__tree<std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>,std::__map_value_compare<webrtc::AudioSendStream *,std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>,std::less<webrtc::AudioSendStream *>,true>,std::allocator<std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>>>::destroy(_QWORD *a1)
{
  uint64_t v2;

  if (a1)
  {
    std::__tree<std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>,std::__map_value_compare<webrtc::AudioSendStream *,std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>,std::less<webrtc::AudioSendStream *>,true>,std::allocator<std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>>>::destroy(*a1);
    std::__tree<std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>,std::__map_value_compare<webrtc::AudioSendStream *,std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>,std::less<webrtc::AudioSendStream *>,true>,std::allocator<std::__value_type<webrtc::AudioSendStream *,std::unique_ptr<webrtc::DegradedCall::FakeNetworkPipeTransportAdapter>>>>::destroy(a1[1]);
    v2 = a1[5];
    a1[5] = 0;
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
    operator delete(a1);
  }
}

_QWORD *absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DegradedCall::DegradedCall(std::unique_ptr<webrtc::Call>,std::vector<webrtc::DegradedCall::TimeScopedNetworkConfig> const&,std::vector<webrtc::DegradedCall::TimeScopedNetworkConfig> const&)::$_0 &&>(webrtc::DegradedCall **a1)
{
  return webrtc::DegradedCall::UpdateReceiveNetworkConfig(*a1);
}

_QWORD *absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DegradedCall::DegradedCall(std::unique_ptr<webrtc::Call>,std::vector<webrtc::DegradedCall::TimeScopedNetworkConfig> const&,std::vector<webrtc::DegradedCall::TimeScopedNetworkConfig> const&)::$_1 &&>(webrtc::DegradedCall **a1)
{
  return webrtc::DegradedCall::UpdateSendNetworkConfig(*a1);
}

uint64_t rtc::FunctionView<void ()(void)>::CallVoidPtr<webrtc::DegradedCall::~DegradedCall()::$_1>(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)result + 4) = 0;
  return result;
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DegradedCall::UpdateSendNetworkConfig(void)::$_0 &&>(webrtc::DegradedCall **a1)
{
  return webrtc::DegradedCall::UpdateSendNetworkConfig(*a1);
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DegradedCall::UpdateReceiveNetworkConfig(void)::$_0 &&>(webrtc::DegradedCall **a1)
{
  return webrtc::DegradedCall::UpdateReceiveNetworkConfig(*a1);
}

_QWORD *webrtc::DelayBasedBwe::DelayBasedBwe(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t *v11;
  _QWORD *result;
  std::string::size_type size;
  std::string *p_p;
  void *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  std::string __p;

  *(_QWORD *)a1 = &off_24C0B31A0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 40) = 0;
  v7 = a1 + 40;
  *(_DWORD *)(a1 + 44) = 10;
  v8 = a1 + 44;
  *(_QWORD *)(a1 + 48) = 1000000;
  v9 = a1 + 48;
  v10 = operator new(0x60uLL);
  *v10 = "enabled";
  v10[1] = v7;
  v10[2] = webrtc::struct_parser_impl::TypedParser<BOOL>::Parse;
  v10[3] = webrtc::struct_parser_impl::TypedParser<BOOL>::Encode;
  v10[4] = "packet_threshold";
  v10[5] = v8;
  v10[6] = webrtc::struct_parser_impl::TypedParser<int>::Parse;
  v10[7] = webrtc::struct_parser_impl::TypedParser<int>::Encode;
  v10[8] = "time_threshold";
  v10[9] = v9;
  v10[10] = webrtc::struct_parser_impl::TypedParser<webrtc::TimeDelta>::Parse;
  v10[11] = webrtc::struct_parser_impl::TypedParser<webrtc::TimeDelta>::Encode;
  v11 = (uint64_t *)operator new();
  *v11 = (uint64_t)v10;
  v11[1] = (uint64_t)(v10 + 12);
  v11[2] = (uint64_t)(v10 + 12);
  result = (*(_QWORD *(**)(std::string *__return_ptr, uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(&__p, a2, "WebRTC-Bwe-SeparateAudioPackets", 31);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    size = __p.__r_.__value_.__l.__size_;
    if ((__p.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0
      || (p_p = (std::string *)__p.__r_.__value_.__r.__words[0], __p.__r_.__value_.__l.__size_)
      && !__p.__r_.__value_.__r.__words[0])
    {
      __break(1u);
      return result;
    }
  }
  else
  {
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    p_p = &__p;
  }
  webrtc::StructParametersParser::Parse(v11, (uint64_t)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v15 = (void *)*v11;
  if (*v11)
  {
    v11[1] = (uint64_t)v15;
    operator delete(v15);
  }
  MEMORY[0x20BD0ADEC](v11, 0x20C40960023A9);
  *(_OWORD *)(a1 + 56) = xmmword_208F08B90;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 72) = a4;
  v16 = operator new();
  v17 = webrtc::TrendlineEstimator::TrendlineEstimator(v16, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 72));
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 96) = v17;
  v18 = operator new();
  v19 = webrtc::TrendlineEstimator::TrendlineEstimator(v18, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 72));
  v20 = *(_QWORD *)(a1 + 96);
  *(_QWORD *)(a1 + 120) = v19;
  *(_QWORD *)(a1 + 128) = v20;
  *(_QWORD *)(a1 + 136) = 0x8000000000000000;
  *(_BYTE *)(a1 + 144) = 0;
  webrtc::AimdRateControl::AimdRateControl(a1 + 152, a2, 1);
  *(_QWORD *)(a1 + 568) = 0;
  *(_DWORD *)(a1 + 576) = 0;
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    v21 = operator new(0x60uLL);
    *v21 = "enabled";
    v21[1] = v7;
    v21[2] = webrtc::struct_parser_impl::TypedParser<BOOL>::Parse;
    v21[3] = webrtc::struct_parser_impl::TypedParser<BOOL>::Encode;
    v21[4] = "packet_threshold";
    v21[5] = v8;
    v21[6] = webrtc::struct_parser_impl::TypedParser<int>::Parse;
    v21[7] = webrtc::struct_parser_impl::TypedParser<int>::Encode;
    v21[8] = "time_threshold";
    v21[9] = v9;
    v21[10] = webrtc::struct_parser_impl::TypedParser<webrtc::TimeDelta>::Parse;
    v21[11] = webrtc::struct_parser_impl::TypedParser<webrtc::TimeDelta>::Encode;
    v22 = (uint64_t *)operator new();
    *v22 = (uint64_t)v21;
    v22[1] = (uint64_t)(v21 + 12);
    v22[2] = (uint64_t)(v21 + 12);
    webrtc::StructParametersParser::Encode(v22, &__p);
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v23, v24, v25, v26, v27, v28, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/goog_cc/delay_based_bwe.cc");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    v30 = (void *)*v22;
    if (*v22)
    {
      v22[1] = (uint64_t)v30;
      operator delete(v30);
    }
    MEMORY[0x20BD0ADEC](v22, 0x20C40960023A9);
  }
  return (_QWORD *)a1;
}

void webrtc::DelayBasedBwe::~DelayBasedBwe(webrtc::DelayBasedBwe *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)this = &off_24C0B31A0;
  *((_QWORD *)this + 61) = off_24C0B4170;
  if ((*((char *)this + 543) & 0x80000000) == 0)
  {
    v2 = (void *)*((_QWORD *)this + 62);
    if (!v2)
      goto LABEL_4;
    goto LABEL_3;
  }
  operator delete(*((void **)this + 65));
  v2 = (void *)*((_QWORD *)this + 62);
  if (v2)
  {
LABEL_3:
    *((_QWORD *)this + 63) = v2;
    operator delete(v2);
  }
LABEL_4:
  *((_QWORD *)this + 53) = off_24C0B4170;
  if ((*((char *)this + 479) & 0x80000000) == 0)
  {
    v3 = (void *)*((_QWORD *)this + 54);
    if (!v3)
      goto LABEL_7;
    goto LABEL_6;
  }
  operator delete(*((void **)this + 57));
  v3 = (void *)*((_QWORD *)this + 54);
  if (v3)
  {
LABEL_6:
    *((_QWORD *)this + 55) = v3;
    operator delete(v3);
  }
LABEL_7:
  v4 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = 0;
  if (v5)
    MEMORY[0x20BD0ADEC](v5, 0x1000C40B5796951);
  v6 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v6)
    MEMORY[0x20BD0ADEC](v6, 0x1000C40BDE76CD9);
  v7 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v8)
    MEMORY[0x20BD0ADEC](v8, 0x1000C40B5796951);
  v9 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v9)
    MEMORY[0x20BD0ADEC](v9, 0x1000C40BDE76CD9);
}

{
  webrtc::DelayBasedBwe::~DelayBasedBwe(this);
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::DelayBasedBwe::IncomingPacketFeedbackVector(webrtc::TransportPacketsFeedback *this@<X1>, uint64_t a2@<X0>, int64_t a3@<X2>, uint64_t a4@<X3>, int64_t a5@<X4>, char a6@<W5>, _OWORD *a7@<X6>, char a8@<W7>, uint64_t a9@<X8>)
{
  int v17;
  _QWORD *v18;
  int v19;
  uint64_t *v20;
  uint64_t *v21;
  int64_t v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int64_t v39;
  uint64_t v40;
  uint64_t v42;
  uint64_t v43;
  BOOL v44;
  webrtc::InterArrivalDelta **v45;
  Timestamp v46;
  Timestamp v47;
  Timestamp v48;
  uint64_t v49;
  __n128 v50;
  __n128 v51;
  int64_t var0;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD *v84;
  int64_t v85;
  int64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int64_t v92;
  int64_t v93;
  uint64_t v94;
  int64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  int64_t v101;
  uint64_t *v102;
  uint64_t v103;
  uint64_t v104;
  int64_t v105;
  uint64_t v106;
  int64_t v107;
  int64_t v108;
  char v109;
  int64_t v110;
  uint64_t v111;
  char v112;
  uint64_t v113;
  char v114;
  _QWORD *v115;
  int64x2_t v117;
  void *__p;
  _QWORD *v119;
  int v120;
  TimeDelta v121;
  TimeDelta v122;
  int64_t v123;
  uint64_t v124;

  webrtc::TransportPacketsFeedback::SortedByReceiveTime(this, (uint64_t *)&__p);
  if (__p == v119)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v77, v78, v79, v80, v81, v82, v83, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/congestion_controller/goog_cc/delay_based_bwe.cc");
LABEL_95:
    *(_WORD *)a9 = 0;
    *(_QWORD *)(a9 + 8) = 0;
    *(_BYTE *)(a9 + 16) = 0;
    *(_DWORD *)(a9 + 20) = 0;
    v84 = __p;
    if (!__p)
      return;
    goto LABEL_96;
  }
  if (!*(_BYTE *)(a2 + 144))
    *(_BYTE *)(a2 + 144) = 1;
  v17 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 128) + 24))(*(_QWORD *)(a2 + 128));
  v18 = __p;
  v115 = v119;
  if (__p == v119)
    goto LABEL_95;
  v19 = v17;
  v112 = a8;
  v113 = a9;
  v108 = a5;
  v109 = a6;
  v110 = a3;
  v111 = a4;
  v114 = 0;
  v20 = (uint64_t *)(a2 + 88);
  v21 = (uint64_t *)(a2 + 112);
  v117 = vdupq_n_s64(0x8000000000000000);
  do
  {
    v22 = *(_QWORD *)this;
    v23 = *(_QWORD *)(a2 + 136);
    v24 = (unint64_t)(v23 - 0x7FFFFFFFFFFFFFFFLL) < 2 || v22 == 0x7FFFFFFFFFFFFFFFLL;
    if (!v24 && ((v25 = v22 - v23, v22 != 0x8000000000000000) ? (v26 = v25 <= 2000000) : (v26 = 1), v26))
    {
      v27 = *(_QWORD *)(a2 + 96);
      *(_QWORD *)(a2 + 136) = v22;
      v28 = *(unsigned __int8 *)(a2 + 40);
      if (!*(_BYTE *)(a2 + 40))
        goto LABEL_42;
    }
    else
    {
      v29 = operator new();
      *(_OWORD *)v29 = xmmword_208F08BA0;
      *(int64x2_t *)(v29 + 16) = v117;
      *(int64x2_t *)(v29 + 32) = v117;
      *(_OWORD *)(v29 + 48) = xmmword_208F08BB0;
      *(int64x2_t *)(v29 + 64) = v117;
      *(int64x2_t *)(v29 + 80) = v117;
      *(_QWORD *)(v29 + 96) = 0x8000000000000000;
      *(_DWORD *)(v29 + 104) = 0;
      v30 = *v20;
      *v20 = v29;
      if (v30)
        MEMORY[0x20BD0ADEC](v30, 0x1000C40B5796951);
      v31 = operator new();
      *(_OWORD *)v31 = xmmword_208F08BA0;
      *(int64x2_t *)(v31 + 16) = v117;
      *(int64x2_t *)(v31 + 32) = v117;
      *(_OWORD *)(v31 + 48) = xmmword_208F08BB0;
      *(int64x2_t *)(v31 + 64) = v117;
      *(int64x2_t *)(v31 + 80) = v117;
      *(_QWORD *)(v31 + 96) = 0x8000000000000000;
      *(_DWORD *)(v31 + 104) = 0;
      v32 = *v21;
      *v21 = v31;
      if (v32)
        MEMORY[0x20BD0ADEC](v32, 0x1000C40B5796951);
      v33 = operator new();
      webrtc::TrendlineEstimator::TrendlineEstimator(v33, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 72));
      v34 = *(_QWORD *)(a2 + 96);
      *(_QWORD *)(a2 + 96) = v33;
      if (v34)
        (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
      v35 = operator new();
      webrtc::TrendlineEstimator::TrendlineEstimator(v35, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 72));
      v36 = *(_QWORD *)(a2 + 120);
      *(_QWORD *)(a2 + 120) = v35;
      if (v36)
        (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      v27 = *(_QWORD *)(a2 + 96);
      *(_QWORD *)(a2 + 128) = v27;
      *(_QWORD *)(a2 + 136) = v22;
      v28 = *(unsigned __int8 *)(a2 + 40);
      if (!*(_BYTE *)(a2 + 40))
        goto LABEL_42;
    }
    if (!*((_BYTE *)v18 + 48))
    {
      *(_QWORD *)(a2 + 56) = 0;
      v42 = *(_QWORD *)(a2 + 64);
      if (v42 <= v18[9])
        v42 = v18[9];
      *(_QWORD *)(a2 + 64) = v42;
LABEL_41:
      *(_QWORD *)(a2 + 128) = v27;
      goto LABEL_42;
    }
    v27 = *(_QWORD *)(a2 + 120);
    v37 = *(_QWORD *)(a2 + 56);
    *(_QWORD *)(a2 + 56) = v37 + 1;
    if (v37 >= *(int *)(a2 + 44))
    {
      v38 = v18[9];
      v39 = 0x7FFFFFFFFFFFFFFFLL;
      if (v38 != 0x7FFFFFFFFFFFFFFFLL)
      {
        v40 = *(_QWORD *)(a2 + 64);
        if (v40 != 0x8000000000000000)
        {
          v39 = v38 - v40;
          if (v40 == 0x7FFFFFFFFFFFFFFFLL || v38 == 0x8000000000000000)
            v39 = 0x8000000000000000;
        }
      }
      if (v39 > *(_QWORD *)(a2 + 48))
        goto LABEL_41;
    }
LABEL_42:
    v43 = v18[1];
    v121.var0 = 0;
    v122.var0 = 0;
    v120 = 0;
    if (*((_BYTE *)v18 + 48))
      v44 = v28 == 0;
    else
      v44 = 1;
    if (v44)
      v45 = (webrtc::InterArrivalDelta **)(a2 + 88);
    else
      v45 = (webrtc::InterArrivalDelta **)(a2 + 112);
    v46.var0 = *v18;
    v47.var0 = v18[9];
    v48.var0 = v22;
    webrtc::InterArrivalDelta::ComputeDeltas(*v45, v46, v47, v48, v43, &v122, &v121, &v120);
    if (v121.var0 == 0x8000000000000000)
    {
      v50.n128_u64[0] = 0xFFF0000000000000;
      var0 = v122.var0;
      if (v122.var0 == 0x8000000000000000)
        goto LABEL_56;
    }
    else if (v121.var0 == 0x7FFFFFFFFFFFFFFFLL)
    {
      v50.n128_u64[0] = 0x7FF0000000000000;
      var0 = v122.var0;
      if (v122.var0 == 0x8000000000000000)
        goto LABEL_56;
    }
    else
    {
      v50.n128_f64[0] = (double)v121.var0 * 0.001;
      var0 = v122.var0;
      if (v122.var0 == 0x8000000000000000)
      {
LABEL_56:
        v53 = 0xFFF0000000000000;
        goto LABEL_57;
      }
    }
    if (var0 == 0x7FFFFFFFFFFFFFFFLL)
    {
      v53 = 0x7FF0000000000000;
LABEL_57:
      v51.n128_u64[0] = v53;
      goto LABEL_59;
    }
    v51.n128_f64[0] = (double)var0 * 0.001;
LABEL_59:
    v54 = *v18;
    v55 = *v18 / 0x3E8uLL;
    if (*v18 % 0x3E8uLL > 0x1F3)
      ++v55;
    if (-v54 % 0x3E8uLL <= 0x1F4)
      v56 = 0;
    else
      v56 = -1;
    v57 = v56 - -v54 / 0x3E8uLL;
    if (v54 < 0)
      v58 = v57;
    else
      v58 = v55;
    v59 = v18[9];
    v60 = v59 / 0x3E8uLL;
    if (v59 % 0x3E8uLL > 0x1F3)
      ++v60;
    if (-v59 % 0x3E8uLL <= 0x1F4)
      v61 = 0;
    else
      v61 = -1;
    v62 = v61 - -v59 / 0x3E8uLL;
    if (v59 < 0)
      v63 = v62;
    else
      v63 = v60;
    (*(void (**)(uint64_t, unint64_t, unint64_t, uint64_t, uint64_t, __n128, __n128))(*(_QWORD *)v27 + 16))(v27, v58, v63, v43, v49, v50, v51);
    if (v19 == 1)
      v114 |= (*(unsigned int (**)(_QWORD))(**(_QWORD **)(a2 + 128) + 24))(*(_QWORD *)(a2 + 128)) == 0;
    v19 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 128) + 24))(*(_QWORD *)(a2 + 128));
    v18 += 10;
  }
  while (v18 != v115);
  *(_BYTE *)(a2 + 400) = v112;
  *(_OWORD *)(a2 + 208) = *a7;
  v64 = a7[1];
  v65 = a7[2];
  v66 = a7[4];
  *(_OWORD *)(a2 + 256) = a7[3];
  *(_OWORD *)(a2 + 272) = v66;
  *(_OWORD *)(a2 + 224) = v64;
  *(_OWORD *)(a2 + 240) = v65;
  v67 = a7[5];
  v68 = a7[6];
  v69 = a7[7];
  *(_OWORD *)(a2 + 329) = *(_OWORD *)((char *)a7 + 121);
  *(_OWORD *)(a2 + 304) = v68;
  *(_OWORD *)(a2 + 320) = v69;
  *(_OWORD *)(a2 + 288) = v67;
  v70 = *(_QWORD *)this;
  *(_WORD *)a9 = 0;
  *(_QWORD *)(a9 + 8) = 0;
  v71 = (uint64_t *)(a9 + 8);
  *(_BYTE *)(a9 + 16) = 0;
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a2 + 128) + 24))(*(_QWORD *)(a2 + 128)) != 2)
  {
    if (!v109)
    {
      LODWORD(v122.var0) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 128) + 24))(*(_QWORD *)(a2 + 128));
      v123 = v110;
      v124 = v111;
      if (!*(_BYTE *)(a2 + 384))
      {
        v97 = *(_QWORD *)(a2 + 376);
        if ((unint64_t)(v97 - 0x7FFFFFFFFFFFFFFFLL) > 1)
        {
          if ((v70 == 0x7FFFFFFFFFFFFFFFLL || v70 != 0x8000000000000000 && v70 - v97 >= 5000001) && (_BYTE)v111)
          {
            *(_QWORD *)(a2 + 168) = v110;
            *(_BYTE *)(a2 + 384) = 1;
          }
        }
        else if ((_BYTE)v111)
        {
          *(_QWORD *)(a2 + 376) = v70;
        }
      }
      webrtc::AimdRateControl::ChangeBitrate(a2 + 152, (int *)&v122, v70);
      v74 = *(_QWORD *)(a2 + 168);
      *(_QWORD *)(v113 + 8) = v74;
      v75 = *(unsigned __int8 *)(a2 + 384);
      *(_BYTE *)v113 = v75;
      *(_BYTE *)(v113 + 16) = v114 & 1;
      v76 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 128) + 24))(*(_QWORD *)(a2 + 128));
      if (v75)
        goto LABEL_175;
LABEL_176:
      if (v76 != *(_DWORD *)(a2 + 576))
        goto LABEL_177;
      goto LABEL_188;
    }
    *(_WORD *)a9 = 257;
    *(_BYTE *)(a2 + 384) = 1;
    v85 = *(_QWORD *)(a2 + 168);
    if (*(_BYTE *)(a2 + 481))
    {
      v86 = v108;
      if (!*(_BYTE *)(a2 + 344))
        goto LABEL_136;
    }
    else
    {
      v86 = v108;
      if (!*(_BYTE *)(a2 + 344))
      {
LABEL_136:
        if (v86 <= *(_QWORD *)(a2 + 152))
          v74 = *(_QWORD *)(a2 + 152);
        else
          v74 = v86;
        *(_QWORD *)(a2 + 168) = v74;
        *(_QWORD *)(a2 + 360) = v70;
        if (v74 < v85)
          *(_QWORD *)(a2 + 368) = v70;
        *v71 = v74;
        v75 = 1;
        v76 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 128) + 24))(*(_QWORD *)(a2 + 128));
        goto LABEL_175;
      }
      v92 = *(_QWORD *)(a2 + 256);
      if ((unint64_t)(v92 + 0x7FFFFFFFFFFFFFFFLL) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v92 <= v85)
          v93 = *(_QWORD *)(a2 + 168);
        else
          v93 = *(_QWORD *)(a2 + 256);
        if (*(_BYTE *)(a2 + 545))
          v92 = v93;
        if (v92 < v108)
          v86 = v92;
      }
    }
    v94 = *(_QWORD *)(a2 + 248);
    if ((unint64_t)(v94 + 0x7FFFFFFFFFFFFFFFLL) <= 0xFFFFFFFFFFFFFFFDLL && v86 < v85)
    {
      v95 = llround(*(double *)(a2 + 392) * (double)v94);
      if (v86 > v95)
        v95 = v86;
      if (v95 >= v85)
        v86 = *(_QWORD *)(a2 + 168);
      else
        v86 = v95;
    }
    goto LABEL_136;
  }
  if (!(_BYTE)v111)
  {
    if (!*(_BYTE *)(a2 + 384))
      goto LABEL_116;
    v87 = *(_QWORD *)(a2 + 168);
    v88 = v87 >= 0 ? *(_QWORD *)(a2 + 168) : v87 + 1;
    v89 = v88 >> 1;
    if (v70 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v90 = *(_QWORD *)(a2 + 360);
      if (v90 != 0x8000000000000000)
      {
        v91 = *(_QWORD *)(a2 + 408);
        if (v91 >= 200000)
          v91 = 200000;
        if (v91 <= 10000)
          v91 = 10000;
        if ((v70 == 0x8000000000000000 || v90 == 0x7FFFFFFFFFFFFFFFLL || v70 - v90 < v91)
          && (uint64_t)llround((double)v87 * 0.5) < v89)
        {
          goto LABEL_116;
        }
      }
    }
    *(_BYTE *)(a2 + 384) = 1;
    if (*(_BYTE *)(a2 + 481))
    {
      if (!*(_BYTE *)(a2 + 344))
        goto LABEL_169;
    }
    else
    {
      if (!*(_BYTE *)(a2 + 344))
      {
LABEL_169:
        if (v89 <= *(_QWORD *)(a2 + 152))
          v74 = *(_QWORD *)(a2 + 152);
        else
          v74 = v89;
        *(_QWORD *)(a2 + 168) = v74;
        *(_QWORD *)(a2 + 360) = v70;
        if (v74 < v87)
          *(_QWORD *)(a2 + 368) = v70;
        v75 = 1;
        *(_WORD *)v113 = 1;
        *(_QWORD *)(v113 + 8) = v74;
        v76 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 128) + 24))(*(_QWORD *)(a2 + 128));
        goto LABEL_175;
      }
      v98 = *(_QWORD *)(a2 + 256);
      if ((unint64_t)(v98 + 0x7FFFFFFFFFFFFFFFLL) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v98 <= v87)
          v99 = v87;
        else
          v99 = *(_QWORD *)(a2 + 256);
        if (*(_BYTE *)(a2 + 545))
          v98 = v99;
        if (v98 < v89)
          v89 = v98;
      }
    }
    v100 = *(_QWORD *)(a2 + 248);
    if ((unint64_t)(v100 + 0x7FFFFFFFFFFFFFFFLL) <= 0xFFFFFFFFFFFFFFFDLL && v89 < v87)
    {
      v101 = llround(*(double *)(a2 + 392) * (double)v100);
      if (v89 <= v101)
        v89 = v101;
      if (v89 >= v87)
        v89 = v87;
    }
    goto LABEL_169;
  }
  if (v70 != 0x7FFFFFFFFFFFFFFFLL)
  {
    v72 = *(_QWORD *)(a2 + 360);
    if (v72 != 0x8000000000000000)
    {
      v73 = *(_QWORD *)(a2 + 408);
      if (v73 >= 200000)
        v73 = 200000;
      if (v73 <= 10000)
        v73 = 10000;
      if ((v70 == 0x8000000000000000 || v72 == 0x7FFFFFFFFFFFFFFFLL || v70 - v72 < v73)
        && (!*(_BYTE *)(a2 + 384) || (uint64_t)llround((double)*(uint64_t *)(a2 + 168) * 0.5) <= v110))
      {
LABEL_116:
        v75 = 0;
        v76 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 128) + 24))(*(_QWORD *)(a2 + 128));
        goto LABEL_176;
      }
    }
  }
  LODWORD(v122.var0) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 128) + 24))(*(_QWORD *)(a2 + 128));
  v123 = v110;
  v124 = v111;
  if (!*(_BYTE *)(a2 + 384))
  {
    v96 = *(_QWORD *)(a2 + 376);
    if ((unint64_t)(v96 - 0x7FFFFFFFFFFFFFFFLL) > 1)
    {
      if (v70 == 0x7FFFFFFFFFFFFFFFLL || v70 != 0x8000000000000000 && v70 - v96 >= 5000001)
      {
        *(_QWORD *)(a2 + 168) = v110;
        *(_BYTE *)(a2 + 384) = 1;
      }
    }
    else
    {
      *(_QWORD *)(a2 + 376) = v70;
    }
  }
  webrtc::AimdRateControl::ChangeBitrate(a2 + 152, (int *)&v122, v70);
  v74 = *(_QWORD *)(a2 + 168);
  *(_QWORD *)(v113 + 8) = v74;
  v75 = *(unsigned __int8 *)(a2 + 384);
  *(_BYTE *)v113 = v75;
  v76 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 128) + 24))(*(_QWORD *)(a2 + 128));
  if (!v75)
    goto LABEL_176;
LABEL_175:
  if (*(_QWORD *)(a2 + 568) == v74)
    goto LABEL_176;
LABEL_177:
  v102 = (uint64_t *)(a2 + 568);
  if (v75)
    v102 = (uint64_t *)(v113 + 8);
  v103 = *v102;
  v104 = *(_QWORD *)(a2 + 24);
  if (v104)
  {
    v105 = operator new();
    if (rtc::g_clock)
    {
      v106 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
    }
    else
    {
      if (!dword_253EA791C)
        mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
      v106 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
           / dword_253EA791C;
    }
    *(_QWORD *)v105 = &unk_24C0BBD20;
    *(_QWORD *)(v105 + 8) = 1000 * (v106 / 1000000);
    *(_DWORD *)(v105 + 16) = v103;
    *(_DWORD *)(v105 + 20) = v76;
    v122.var0 = v105;
    (*(void (**)(uint64_t, TimeDelta *))(*(_QWORD *)v104 + 40))(v104, &v122);
    v107 = v122.var0;
    v122.var0 = 0;
    if (v107)
      (*(void (**)(int64_t))(*(_QWORD *)v107 + 8))(v107);
  }
  *(_QWORD *)(a2 + 568) = v103;
  *(_DWORD *)(a2 + 576) = v76;
LABEL_188:
  *(_DWORD *)(v113 + 20) = v76;
  v84 = __p;
  if (__p)
  {
LABEL_96:
    v119 = v84;
    operator delete(v84);
  }
}

_QWORD *webrtc::WebRtc_CreateBinaryDelayEstimatorFarend(webrtc *this)
{
  unsigned int v1;
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  BOOL v6;
  _BOOL4 v7;
  int v8;
  uint64_t v9;
  size_t v10;

  if ((int)this < 2)
    return 0;
  v1 = this;
  v2 = malloc_type_malloc(0x18uLL, 0x1010040DD7518FAuLL);
  v3 = v2;
  if (v2)
  {
    *v2 = 0;
    v2[1] = 0;
    *((_DWORD *)v2 + 4) = 0;
    v2[1] = malloc_type_realloc(0, 4 * v1, 0x100004052888210uLL);
    v4 = malloc_type_realloc((void *)*v3, 4 * v1, 0x100004052888210uLL);
    *v3 = v4;
    v5 = v3[1];
    v6 = !v5 || v4 == 0;
    v7 = v6;
    v8 = v6 ? 0 : v1;
    v9 = *((int *)v3 + 4);
    if (v8 > (int)v9)
    {
      v10 = 4 * (v8 - (int)v9);
      bzero((void *)(v5 + 4 * v9), v10);
      bzero((void *)(*v3 + 4 * *((int *)v3 + 4)), v10);
    }
    *((_DWORD *)v3 + 4) = v8;
    if (v7)
    {
      free((void *)v3[1]);
      v3[1] = 0;
      free((void *)*v3);
      free(v3);
      return 0;
    }
  }
  return v3;
}

void **webrtc::WebRtc_CreateBinaryDelayEstimator(unsigned int *a1, int a2)
{
  void **v2;
  void **v5;
  void *v6;

  v2 = 0;
  if (!a1)
    return v2;
  if (a2 < 0)
    return v2;
  v5 = (void **)malloc_type_malloc(0x58uLL, 0x10B004049C60EFCuLL);
  v2 = v5;
  if (!v5)
    return v2;
  v5[10] = a1;
  v5[3] = (void *)(a2 + 1);
  *((_DWORD *)v5 + 11) = 0;
  *((_DWORD *)v5 + 12) = 0;
  *((_DWORD *)v5 + 19) = a2;
  v5[8] = 0;
  *v5 = 0;
  v5[1] = 0;
  v6 = malloc_type_malloc(4 * (a2 + 1), 0x100004052888210uLL);
  v2[2] = v6;
  if (v6)
  {
    if (webrtc::WebRtc_AllocateHistoryBufferMemory((uint64_t)v2, a1[4]))
      return v2;
  }
  free(*v2);
  *v2 = 0;
  free(v2[1]);
  v2[1] = 0;
  free(v2[2]);
  v2[2] = 0;
  free(v2[8]);
  free(v2);
  return 0;
}

uint64_t webrtc::WebRtc_AllocateHistoryBufferMemory(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  size_t v9;
  void *v10;
  uint64_t v11;
  size_t v13;

  v2 = a2;
  v4 = *(_QWORD *)(a1 + 80);
  if (*(_DWORD *)(v4 + 16) != (_DWORD)a2)
  {
    *(_QWORD *)(v4 + 8) = malloc_type_realloc(*(void **)(v4 + 8), 4 * (int)a2, 0x100004052888210uLL);
    v5 = malloc_type_realloc(*(void **)v4, 4 * (int)v2, 0x100004052888210uLL);
    *(_QWORD *)v4 = v5;
    v6 = *(_QWORD *)(v4 + 8);
    if (v5)
      v7 = v6 == 0;
    else
      v7 = 1;
    if (v7)
      v2 = 0;
    else
      v2 = v2;
    v8 = *(int *)(v4 + 16);
    if ((int)v2 > (int)v8)
    {
      v9 = 4 * ((int)v2 - (int)v8);
      bzero((void *)(v6 + 4 * v8), v9);
      bzero((void *)(*(_QWORD *)v4 + 4 * *(int *)(v4 + 16)), v9);
    }
    *(_DWORD *)(v4 + 16) = v2;
  }
  *(_QWORD *)a1 = malloc_type_realloc(*(void **)a1, 4 * ((int)v2 + 1), 0x100004052888210uLL);
  *(_QWORD *)(a1 + 8) = malloc_type_realloc(*(void **)(a1 + 8), 4 * (int)v2, 0x100004052888210uLL);
  v10 = malloc_type_realloc(*(void **)(a1 + 64), 4 * ((int)v2 + 1), 0x100004052888210uLL);
  *(_QWORD *)(a1 + 64) = v10;
  if (*(_QWORD *)a1 && *(_QWORD *)(a1 + 8) && v10)
  {
    v11 = *(int *)(a1 + 28);
    if ((int)v2 <= (int)v11)
    {
LABEL_15:
      *(_DWORD *)(a1 + 28) = v2;
      return v2;
    }
  }
  else
  {
    v2 = 0;
    v11 = *(int *)(a1 + 28);
    if ((int)v11 >= 0)
      goto LABEL_15;
  }
  v13 = 4 * ((int)v2 - (int)v11);
  bzero((void *)(*(_QWORD *)a1 + 4 * v11), v13);
  bzero((void *)(*(_QWORD *)(a1 + 8) + 4 * *(int *)(a1 + 28)), v13);
  bzero((void *)(*(_QWORD *)(a1 + 64) + 4 * *(int *)(a1 + 28)), v13);
  *(_DWORD *)(a1 + 28) = v2;
  return v2;
}

uint64_t webrtc::WebRtc_ProcessBinarySpectrum(uint64_t a1, unsigned int a2, double a3, int8x16_t a4)
{
  uint64_t v4;
  int v5;
  int v8;
  BOOL v9;
  int v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t result;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  uint64_t v22;
  int8x16_t *v23;
  int8x16_t *v24;
  int8x16_t v25;
  uint32x4_t v26;
  uint32x4_t v27;
  uint32x4_t v28;
  uint32x4_t v29;
  uint64_t v30;
  uint64_t v31;
  int *v32;
  int *v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  int *v38;
  int v39;
  int v40;
  char v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  unsigned int v54;
  int *v55;
  int v56;
  int v57;
  _BOOL4 v58;
  int v59;
  int *v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  float v64;
  uint64_t v65;
  int v66;
  int v67;
  int v68;
  float v69;
  float v70;
  float v71;
  uint64_t v72;
  int v73;
  int v74;
  float v75;
  _BOOL4 v76;
  int v77;
  float32x4_t *v78;
  float v79;
  int v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  uint64_t v84;
  int64_t v85;
  float v86;
  float v87;
  int v88;
  int v89;
  int v91;
  uint64_t v92;
  float v93;
  float v94;
  uint64_t v95;
  int64x2_t v96;
  int64x2_t v97;
  int64x2_t v98;
  int64x2_t v99;
  int64x2_t v100;
  int64x2_t v101;
  int64x2_t v102;
  int64x2_t v103;
  uint64_t v104;
  float32x4_t *v105;
  float32x4_t v106;
  int8x8_t v107;
  int8x16_t v108;
  unsigned int v111;
  _BOOL4 v113;
  float v114;

  v4 = *(_QWORD *)(a1 + 80);
  v5 = *(_DWORD *)(v4 + 16);
  if (v5 != *(_DWORD *)(a1 + 28))
    return 0xFFFFFFFFLL;
  v8 = *(_DWORD *)(a1 + 24);
  v9 = __OFSUB__(v8, 1);
  v10 = v8 - 1;
  if (!((v10 < 0) ^ v9 | (v10 == 0)))
  {
    memmove((void *)(*(_QWORD *)(a1 + 16) + 4), *(const void **)(a1 + 16), 4 * v10);
    v11 = *(unsigned int **)(a1 + 16);
    *v11 = a2;
    a2 = v11[*(int *)(a1 + 76)];
    v4 = *(_QWORD *)(a1 + 80);
    v5 = *(_DWORD *)(a1 + 28);
  }
  if (v5 < 1)
  {
LABEL_24:
    v46 = 0;
    v47 = 0x4000;
    result = 0xFFFFFFFFLL;
    v48 = -16384;
    v49 = *(_DWORD *)(a1 + 32);
    if (v49 < 8705)
      goto LABEL_46;
    goto LABEL_39;
  }
  v12 = *(_QWORD *)(v4 + 8);
  v13 = *(_QWORD *)(a1 + 8);
  v14 = v5;
  if (v5 < 4 || (unint64_t)(v13 - v12) < 0x10)
  {
    v16 = 0;
LABEL_14:
    v30 = v14 - v16;
    v31 = 4 * v16;
    v32 = (int *)(v13 + 4 * v16);
    v33 = (int *)(v12 + v31);
    do
    {
      v34 = *v33++;
      v35 = (v34 ^ a2) - ((((v34 ^ a2) >> 1) & 0x5B6DB6DB) + (((v34 ^ a2) >> 2) & 0x9249249));
      v36 = ((v35 + (v35 >> 3)) & 0xC71C71C7) + (((v35 + (v35 >> 3)) & 0xC71C71C7) >> 6);
      *v32++ = ((_BYTE)v36 + (v36 >> 12) + HIBYTE(v36)) & 0x3F;
      --v30;
    }
    while (v30);
    goto LABEL_16;
  }
  v16 = v5 & 0x7FFFFFFC;
  v18 = (int8x16_t)vdupq_n_s32(a2);
  a4 = (int8x16_t)vdupq_n_s32(0x5B6DB6DBu);
  v19 = (int8x16_t)vdupq_n_s32(0x9249249u);
  v20 = (int8x16_t)vdupq_n_s32(0xC71C71C7);
  v21.i64[0] = 0x3F0000003FLL;
  v21.i64[1] = 0x3F0000003FLL;
  v22 = v5 & 0xFFFFFFFC;
  v23 = *(int8x16_t **)(a1 + 8);
  v24 = *(int8x16_t **)(v4 + 8);
  do
  {
    v25 = *v24++;
    v26 = (uint32x4_t)veorq_s8(v25, v18);
    v27 = (uint32x4_t)vsubq_s32((int32x4_t)v26, vaddq_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v26, 1uLL), a4), (int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v26, 2uLL), v19)));
    v28 = (uint32x4_t)vandq_s8((int8x16_t)vsraq_n_u32(v27, v27, 3uLL), v20);
    v29 = vsraq_n_u32(v28, v28, 6uLL);
    *v23++ = vandq_s8((int8x16_t)vsraq_n_u32(vsraq_n_u32(v29, v29, 0xCuLL), v29, 0x18uLL), v21);
    v22 -= 4;
  }
  while (v22);
  if (v16 != v14)
    goto LABEL_14;
LABEL_16:
  v5 = *(_DWORD *)(a1 + 28);
  if (v5 < 1)
    goto LABEL_24;
  v37 = 0;
  v38 = *(int **)v4;
  do
  {
    v39 = v38[v37];
    if (v39 >= 1)
    {
      v40 = *(_DWORD *)(v13 + 4 * v37) << 9;
      v41 = 13 - ((3 * v39) >> 4);
      v42 = *(_DWORD *)(*(_QWORD *)a1 + 4 * v37);
      v9 = __OFSUB__(v40, v42);
      v43 = v40 - v42;
      v44 = -v43 >> v41;
      v45 = v43 >> v41;
      if (v43 < 0 != v9)
        v45 = -v44;
      *(_DWORD *)(*(_QWORD *)a1 + 4 * v37) = v45 + v42;
      v5 = *(_DWORD *)(a1 + 28);
    }
    ++v37;
  }
  while (v37 < v5);
  if (v5 <= 0)
  {
    v46 = 0;
    v47 = 0x4000;
    result = 0xFFFFFFFFLL;
    v48 = -16384;
    v49 = *(_DWORD *)(a1 + 32);
    if (v49 < 8705)
      goto LABEL_46;
  }
  else
  {
    v50 = 0;
    v51 = 0;
    LODWORD(result) = -1;
    v47 = 0x4000;
    do
    {
      v52 = *(_DWORD *)(*(_QWORD *)a1 + 4 * v50);
      if (v52 >= v47)
        result = result;
      else
        result = v50;
      if (v52 < v47)
        v47 = *(_DWORD *)(*(_QWORD *)a1 + 4 * v50);
      if (v52 > v51)
        v51 = *(_DWORD *)(*(_QWORD *)a1 + 4 * v50);
      ++v50;
    }
    while (v5 != v50);
    v46 = 1;
    v48 = v51 - v47;
    v49 = *(_DWORD *)(a1 + 32);
    if (v49 < 8705)
      goto LABEL_46;
  }
LABEL_39:
  if (v48 >= 2817)
  {
    if (v47 <= 7680)
      v53 = 7680;
    else
      v53 = v47;
    v54 = v53 + 1024;
    if (v49 > v54)
    {
      *(_DWORD *)(a1 + 32) = v54;
      v49 = v54;
    }
    v55 = (int *)(a1 + 36);
    v56 = *(_DWORD *)(a1 + 36);
    v57 = v56 + 1;
    *(_DWORD *)(a1 + 36) = v56 + 1;
    goto LABEL_47;
  }
LABEL_46:
  v55 = (int *)(a1 + 36);
  v56 = *(_DWORD *)(a1 + 36);
  v57 = v56 + 1;
  *(_DWORD *)(a1 + 36) = v56 + 1;
  if (v48 < 1025)
  {
    v59 = 0;
    if (!v5)
      goto LABEL_56;
    goto LABEL_53;
  }
LABEL_47:
  v58 = v47 <= v56;
  v59 = v47 < v49 || v58;
  if (!v5)
  {
LABEL_56:
    v62 = 0;
    if (*(_DWORD *)(a1 + 44))
      goto LABEL_57;
LABEL_123:
    v65 = *(unsigned int *)(a1 + 40);
    if (!v59)
      v62 = 0;
    if (v62 == 1)
      goto LABEL_93;
    return v65;
  }
LABEL_53:
  v60 = *(int **)v4;
  v61 = 4 * v5;
  while (*v60 < 1)
  {
    ++v60;
    v61 -= 4;
    if (!v61)
      goto LABEL_56;
  }
  v71 = (float)v48 * 0.000061035;
  v72 = *(int *)(a1 + 40);
  if ((int)v72 <= (int)result)
    v73 = 1000;
  else
    v73 = 10;
  if (*(_DWORD *)(a1 + 52) == (_DWORD)result)
  {
    v74 = *(_DWORD *)(a1 + 60) + 1;
  }
  else
  {
    *(_DWORD *)(a1 + 52) = result;
    v74 = 1;
  }
  *(_DWORD *)(a1 + 60) = v74;
  v78 = *(float32x4_t **)(a1 + 64);
  v79 = v71 + v78->f32[(int)result];
  if (v79 > 3000.0)
    v79 = 3000.0;
  v78->f32[(int)result] = v79;
  *(float *)a4.i32 = v71;
  if (v74 < v73)
    *(float *)a4.i32 = (float)(*(_DWORD *)(*(_QWORD *)a1 + 4 * *(int *)(a1 + 56)) - v47) * 0.000061035;
  if (v46)
  {
    v80 = v72 - 2;
    v81 = v72 + 1;
    v82 = (int)result - 2;
    v83 = (int)result + 1;
    v84 = v5;
    if (v5 >= 4)
    {
      v85 = v5 & 0xFFFFFFFC;
      v96 = vdupq_n_s64(v80);
      v97 = vdupq_n_s64(v81);
      v98 = vdupq_n_s64(result);
      v99 = vdupq_n_s64(v82);
      v100 = vdupq_n_s64(v83);
      v101 = (int64x2_t)xmmword_208F08AD0;
      v102 = (int64x2_t)xmmword_208F05120;
      v103 = vdupq_n_s64(4uLL);
      v104 = v84 & 0xFFFFFFFC;
      v105 = v78;
      v106 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 0);
      do
      {
        v107 = (int8x8_t)vmovn_s32((int32x4_t)vbicq_s8(vandq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgeq_s64(v102, v96), (int32x4_t)vcgeq_s64(v101, v96)), (int8x16_t)vuzp1q_s32((int32x4_t)vcgeq_s64(v97, v102), (int32x4_t)vcgeq_s64(v97, v101))), (int8x16_t)vuzp1q_s32((int32x4_t)vceqq_s64(v102, v98), (int32x4_t)vceqq_s64(v101, v98))));
        v108 = (int8x16_t)vsubq_f32(*v105, vmlaq_f32(vmulq_n_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vand_s8(vbic_s8((int8x8_t)vmovn_s32((int32x4_t)vorrq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_s64(v99, v102), (int32x4_t)vcgtq_s64(v99, v101)), (int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_s64(v102, v100), (int32x4_t)vcgtq_s64(v101, v100)))), v107), (int8x8_t)0x1000100010001))), v71), vcvtq_f32_u32(vmovl_u16((uint16x4_t)vand_s8(v107, (int8x8_t)0x1000100010001))), v106));
        *(int8x16_t *)v105++ = vbicq_s8(v108, (int8x16_t)vcltzq_f32((float32x4_t)v108));
        v101 = vaddq_s64(v101, v103);
        v102 = vaddq_s64(v102, v103);
        v104 -= 4;
      }
      while (v104);
      if (v85 == v84)
        goto LABEL_122;
    }
    else
    {
      v85 = 0;
    }
    do
    {
      v111 = v85 >= v80 && v85 <= v81 && result != v85;
      v113 = v85 < v82 || v85 > v83;
      v114 = v78->f32[v85] - (float)((float)(v71 * (float)(v113 & ~v111)) + (float)(*(float *)a4.i32 * (float)v111));
      if (v114 < 0.0)
        v114 = 0.0;
      v78->f32[v85++] = v114;
    }
    while (v84 != v85);
  }
LABEL_122:
  v62 = 1;
  if (!*(_DWORD *)(a1 + 44))
    goto LABEL_123;
LABEL_57:
  v63 = *(_QWORD *)(a1 + 64);
  v64 = *(float *)(v63 + 4 * *(int *)(a1 + 56));
  v65 = *(unsigned int *)(a1 + 40);
  v66 = result - v65;
  v67 = *(_DWORD *)(a1 + 48);
  v9 = __OFSUB__(result - v65, v67);
  v68 = result - v65 - v67;
  if ((v68 < 0) ^ v9 | (v68 == 0))
  {
    if (v66 < 0)
    {
      v86 = (float)((float)v66 * -0.05) + 0.25;
      if (v86 > 1.0)
        v86 = 1.0;
      v87 = fmaxf(v64 * v86, 1.5);
      v70 = *(float *)(v63 + 4 * (int)result);
      if (v70 < v87)
        goto LABEL_80;
    }
    else
    {
      v75 = fmaxf(v64 * 1.0, 1.5);
      v70 = *(float *)(v63 + 4 * (int)result);
      if (v70 < v75)
        goto LABEL_80;
    }
  }
  else
  {
    v69 = fmaxf(v64 * fmaxf((float)((float)v68 * -0.05) + 1.0, 0.5), 1.5);
    v70 = *(float *)(v63 + 4 * (int)result);
    if (v70 < v69)
      goto LABEL_80;
  }
  if (*(int *)(a1 + 60) >= 11)
  {
    v76 = v70 > *(float *)(a1 + 72);
    v77 = 1;
    goto LABEL_81;
  }
LABEL_80:
  v77 = 0;
  v76 = 0;
LABEL_81:
  if (v59)
    v88 = v77;
  else
    v88 = 0;
  v89 = v77 | v59;
  if ((int)v65 >= 0 || v89 == 0)
    v91 = v88;
  else
    v91 = 1;
  if (!(v76 | v91))
    v62 = 0;
  if (v62 != 1)
    return v65;
LABEL_93:
  if ((_DWORD)result != (_DWORD)v65)
  {
    v92 = *(_QWORD *)(a1 + 64);
    v93 = *(float *)(v92 + 4 * (int)result);
    if (v93 > 250.0)
      v93 = 250.0;
    *(float *)(a1 + 72) = v93;
    v94 = *(float *)(v92 + 4 * (int)result);
    v95 = *(int *)(a1 + 56);
    if (v94 < *(float *)(v92 + 4 * v95))
      *(float *)(v92 + 4 * v95) = v94;
  }
  *(_DWORD *)(a1 + 40) = result;
  if (v47 < v57)
    *v55 = v47;
  *(_DWORD *)(a1 + 56) = result;
  return result;
}

void *webrtc::WebRtc_CreateDelayEstimatorFarend(webrtc *this, webrtc *a2)
{
  unsigned int v3;
  void *v4;
  _QWORD *BinaryDelayEstimatorFarend;
  void *v6;
  void **v8;

  if ((int)this >= 43)
  {
    v3 = this;
    v4 = malloc_type_malloc(0x18uLL, 0x102004014030ADEuLL);
    if (!v4)
      return v4;
    BinaryDelayEstimatorFarend = webrtc::WebRtc_CreateBinaryDelayEstimatorFarend(a2);
    *((_QWORD *)v4 + 2) = BinaryDelayEstimatorFarend;
    v6 = malloc_type_malloc(4 * v3, 0x100004052888210uLL);
    *(_QWORD *)v4 = v6;
    *((_DWORD *)v4 + 3) = v3;
    if (BinaryDelayEstimatorFarend)
    {
      if (v6)
        return v4;
    }
    free(v6);
    *(_QWORD *)v4 = 0;
    v8 = (void **)*((_QWORD *)v4 + 2);
    if (v8)
    {
      free(v8[1]);
      v8[1] = 0;
      free(*v8);
      free(v8);
    }
    free(v4);
  }
  return 0;
}

uint64_t webrtc::BinarySpectrumFix(unsigned __int16 *a1, int32x4_t *a2, int a3, _DWORD *a4)
{
  unsigned int v4;
  uint32x4_t v5;
  uint16x8_t v6;
  uint16x8_t v7;
  uint32x4_t v8;
  uint32x4_t v9;
  int32x4_t v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int32x4_t v19;
  int32x4_t v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  uint16x8_t v32;
  uint16x8_t v33;
  uint32x4_t v34;
  uint32x4_t v35;
  int32x4_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int32x4_t v50;
  int32x4_t v51;
  int8x16_t v52;

  v4 = 15 - a3;
  if (!*a4)
  {
    if (a1[12])
    {
      a2[3].i32[0] = a1[12] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[13])
    {
      a2[3].i32[1] = a1[13] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[14])
    {
      a2[3].i32[2] = a1[14] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[15])
    {
      a2[3].i32[3] = a1[15] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[16])
    {
      a2[4].i32[0] = a1[16] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[17])
    {
      a2[4].i32[1] = a1[17] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[18])
    {
      a2[4].i32[2] = a1[18] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[19])
    {
      a2[4].i32[3] = a1[19] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[20])
    {
      a2[5].i32[0] = a1[20] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[21])
    {
      a2[5].i32[1] = a1[21] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[22])
    {
      a2[5].i32[2] = a1[22] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[23])
    {
      a2[5].i32[3] = a1[23] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[24])
    {
      a2[6].i32[0] = a1[24] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[25])
    {
      a2[6].i32[1] = a1[25] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[26])
    {
      a2[6].i32[2] = a1[26] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[27])
    {
      a2[6].i32[3] = a1[27] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[28])
    {
      a2[7].i32[0] = a1[28] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[29])
    {
      a2[7].i32[1] = a1[29] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[30])
    {
      a2[7].i32[2] = a1[30] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[31])
    {
      a2[7].i32[3] = a1[31] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[32])
    {
      a2[8].i32[0] = a1[32] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[33])
    {
      a2[8].i32[1] = a1[33] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[34])
    {
      a2[8].i32[2] = a1[34] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[35])
    {
      a2[8].i32[3] = a1[35] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[36])
    {
      a2[9].i32[0] = a1[36] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[37])
    {
      a2[9].i32[1] = a1[37] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[38])
    {
      a2[9].i32[2] = a1[38] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[39])
    {
      a2[9].i32[3] = a1[39] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[40])
    {
      a2[10].i32[0] = a1[40] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[41])
    {
      a2[10].i32[1] = a1[41] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[42])
    {
      a2[10].i32[2] = a1[42] << v4 >> 1;
      *a4 = 1;
    }
    if (a1[43])
    {
      a2[10].i32[3] = a1[43] << v4 >> 1;
      *a4 = 1;
    }
  }
  v5 = (uint32x4_t)vdupq_n_s32(v4);
  v6 = *(uint16x8_t *)(a1 + 12);
  v7 = *(uint16x8_t *)(a1 + 20);
  v8 = vmovl_high_u16(v6);
  v9 = vmovl_high_u16(v7);
  v10 = (int32x4_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v6.i8), v5);
  v11 = (int32x4_t)vshlq_u32(v8, v5);
  v12 = (int32x4_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v7.i8), v5);
  v13 = (int32x4_t)vshlq_u32(v9, v5);
  v14 = a2[3];
  v15 = a2[4];
  v16 = a2[5];
  v17 = a2[6];
  v18 = vsubq_s32(v11, v15);
  v19 = vsubq_s32(v10, v14);
  v20 = vsubq_s32(v13, v17);
  v21 = vsubq_s32(v12, v16);
  v22 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v19), (int8x16_t)vnegq_s32(vshrq_n_s32(vnegq_s32(v19), 6uLL)), (int8x16_t)vshrq_n_u32((uint32x4_t)v19, 6uLL)), v14);
  v23 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v18), (int8x16_t)vnegq_s32(vshrq_n_s32(vnegq_s32(v18), 6uLL)), (int8x16_t)vshrq_n_u32((uint32x4_t)v18, 6uLL)), v15);
  v24 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v21), (int8x16_t)vnegq_s32(vshrq_n_s32(vnegq_s32(v21), 6uLL)), (int8x16_t)vshrq_n_u32((uint32x4_t)v21, 6uLL)), v16);
  v25 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v20), (int8x16_t)vnegq_s32(vshrq_n_s32(vnegq_s32(v20), 6uLL)), (int8x16_t)vshrq_n_u32((uint32x4_t)v20, 6uLL)), v17);
  a2[3] = v22;
  a2[4] = v23;
  a2[5] = v24;
  a2[6] = v25;
  v26 = (int8x16_t)vcgtq_s32(v10, v22);
  v27 = (int8x16_t)vcgtq_s32(v11, v23);
  v28 = (int8x16_t)vcgtq_s32(v12, v24);
  v29 = vandq_s8(v26, (int8x16_t)xmmword_208F08C00);
  v30 = vandq_s8((int8x16_t)vcgtq_s32(v13, v25), (int8x16_t)xmmword_208F08C10);
  v31 = vandq_s8(v28, (int8x16_t)xmmword_208F08C20);
  v32 = *(uint16x8_t *)(a1 + 28);
  v33 = *(uint16x8_t *)(a1 + 36);
  v34 = vmovl_high_u16(v32);
  v35 = vmovl_high_u16(v33);
  v36 = (int32x4_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v32.i8), v5);
  v37 = (int32x4_t)vshlq_u32(v34, v5);
  v38 = (int32x4_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v33.i8), v5);
  v39 = (int32x4_t)vshlq_u32(v35, v5);
  v40 = a2[7];
  v41 = a2[8];
  v42 = a2[9];
  v43 = a2[10];
  v44 = vsubq_s32(v37, v41);
  v45 = vsubq_s32(v36, v40);
  v46 = vsubq_s32(v39, v43);
  v47 = vsubq_s32(v38, v42);
  v48 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v45), (int8x16_t)vnegq_s32(vshrq_n_s32(vnegq_s32(v45), 6uLL)), (int8x16_t)vshrq_n_u32((uint32x4_t)v45, 6uLL)), v40);
  v49 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v44), (int8x16_t)vnegq_s32(vshrq_n_s32(vnegq_s32(v44), 6uLL)), (int8x16_t)vshrq_n_u32((uint32x4_t)v44, 6uLL)), v41);
  v50 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v47), (int8x16_t)vnegq_s32(vshrq_n_s32(vnegq_s32(v47), 6uLL)), (int8x16_t)vshrq_n_u32((uint32x4_t)v47, 6uLL)), v42);
  v51 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v46), (int8x16_t)vnegq_s32(vshrq_n_s32(vnegq_s32(v46), 6uLL)), (int8x16_t)vshrq_n_u32((uint32x4_t)v46, 6uLL)), v43);
  a2[7] = v48;
  a2[8] = v49;
  a2[9] = v50;
  a2[10] = v51;
  v52 = vorrq_s8(vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vcgtq_s32(v38, v50), (int8x16_t)xmmword_208F08C60), v31), vorrq_s8(vandq_s8((int8x16_t)vcgtq_s32(v36, v48), (int8x16_t)xmmword_208F08C40), v29)), vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vcgtq_s32(v39, v51), (int8x16_t)xmmword_208F08C50), v30), vorrq_s8(vandq_s8((int8x16_t)vcgtq_s32(v37, v49), (int8x16_t)xmmword_208F08C30), vandq_s8(v27, (int8x16_t)xmmword_208F08BF0))));
  *(int8x8_t *)v52.i8 = vorr_s8(*(int8x8_t *)v52.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL));
  return (v52.i32[0] | v52.i32[1]);
}

void webrtc::WebRtc_FreeDelayEstimator(void **this, void *a2)
{
  void **v3;

  if (this)
  {
    free(*this);
    *this = 0;
    v3 = (void **)this[2];
    if (v3)
    {
      free(*v3);
      *v3 = 0;
      free(v3[1]);
      v3[1] = 0;
      free(v3[2]);
      v3[2] = 0;
      free(v3[8]);
      free(v3);
    }
    free(this);
  }
}

void *webrtc::WebRtc_CreateDelayEstimator(unsigned int **this, void *a2)
{
  int v2;
  void *v4;
  void **BinaryDelayEstimator;
  void *v6;
  void **v8;

  if (this)
  {
    v2 = (int)a2;
    v4 = malloc_type_malloc(0x18uLL, 0x102004014030ADEuLL);
    if (!v4)
      return v4;
    BinaryDelayEstimator = webrtc::WebRtc_CreateBinaryDelayEstimator(this[2], v2);
    *((_QWORD *)v4 + 2) = BinaryDelayEstimator;
    v6 = malloc_type_malloc(4 * *((int *)this + 3), 0x100004052888210uLL);
    *(_QWORD *)v4 = v6;
    *((_DWORD *)v4 + 3) = *((_DWORD *)this + 3);
    if (BinaryDelayEstimator)
    {
      if (v6)
        return v4;
    }
    free(v6);
    *(_QWORD *)v4 = 0;
    v8 = (void **)*((_QWORD *)v4 + 2);
    if (v8)
    {
      free(*v8);
      *v8 = 0;
      free(v8[1]);
      v8[1] = 0;
      free(v8[2]);
      v8[2] = 0;
      free(v8[8]);
      free(v8);
    }
    free(v4);
  }
  return 0;
}

webrtc::DelayManager::Config *webrtc::DelayManager::Config::Config(webrtc::DelayManager::Config *this)
{
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  _QWORD *v8;
  uint64_t *v9;
  webrtc::DelayManager::Config *result;
  unint64_t v11;
  void *p_p;
  void *v13;
  void *__p;
  unint64_t v15;
  unsigned __int8 v16;

  v2 = (char *)this + 8;
  *(_OWORD *)this = xmmword_208F08C70;
  *((_QWORD *)this + 2) = 0x4000000000000000;
  v3 = (char *)this + 16;
  *((_BYTE *)this + 24) = 1;
  *((_DWORD *)this + 8) = 500;
  v4 = (char *)this + 32;
  *((_BYTE *)this + 36) = 1;
  *((_BYTE *)this + 40) = 1;
  v5 = (char *)this + 40;
  *((_QWORD *)this + 6) = 0x3FEFFA43FE5C91D1;
  v6 = (char *)this + 48;
  *((_QWORD *)this + 7) = 0xC800000014;
  v7 = (char *)this + 56;
  *((_DWORD *)this + 16) = 0;
  v8 = operator new(0xE0uLL);
  *v8 = "quantile";
  v8[1] = this;
  v8[2] = webrtc::struct_parser_impl::TypedParser<double>::Parse;
  v8[3] = webrtc::struct_parser_impl::TypedParser<double>::Encode;
  v8[4] = "forget_factor";
  v8[5] = v2;
  v8[6] = webrtc::struct_parser_impl::TypedParser<double>::Parse;
  v8[7] = webrtc::struct_parser_impl::TypedParser<double>::Encode;
  v8[8] = "start_forget_weight";
  v8[9] = v3;
  v8[10] = webrtc::struct_parser_impl::TypedParser<std::optional<double>>::Parse;
  v8[11] = webrtc::struct_parser_impl::TypedParser<std::optional<double>>::Encode;
  v8[12] = "resample_interval_ms";
  v8[13] = v4;
  v8[14] = webrtc::struct_parser_impl::TypedParser<std::optional<int>>::Parse;
  v8[15] = webrtc::struct_parser_impl::TypedParser<std::optional<int>>::Encode;
  v8[16] = "use_reorder_optimizer";
  v8[17] = v5;
  v8[18] = webrtc::struct_parser_impl::TypedParser<BOOL>::Parse;
  v8[19] = webrtc::struct_parser_impl::TypedParser<BOOL>::Encode;
  v8[20] = "reorder_forget_factor";
  v8[21] = v6;
  v8[22] = webrtc::struct_parser_impl::TypedParser<double>::Parse;
  v8[23] = webrtc::struct_parser_impl::TypedParser<double>::Encode;
  v8[24] = "ms_per_loss_percent";
  v8[25] = v7;
  v8[26] = webrtc::struct_parser_impl::TypedParser<int>::Parse;
  v8[27] = webrtc::struct_parser_impl::TypedParser<int>::Encode;
  v9 = (uint64_t *)operator new();
  *v9 = (uint64_t)v8;
  v9[1] = (uint64_t)(v8 + 28);
  v9[2] = (uint64_t)(v8 + 28);
  result = (webrtc::DelayManager::Config *)webrtc::field_trial::FindFullName((size_t)"WebRTC-Audio-NetEqDelayManagerConfig", 0x24uLL, (size_t *)&__p);
  if ((char)v16 < 0)
  {
    v11 = v15;
    if ((v15 & 0x8000000000000000) != 0 || (p_p = __p, v15) && !__p)
    {
      __break(1u);
      return result;
    }
  }
  else
  {
    v11 = v16;
    p_p = &__p;
  }
  webrtc::StructParametersParser::Parse(v9, (uint64_t)p_p, v11);
  if ((char)v16 < 0)
    operator delete(__p);
  v13 = (void *)*v9;
  if (*v9)
  {
    v9[1] = (uint64_t)v13;
    operator delete(v13);
  }
  MEMORY[0x20BD0ADEC](v9, 0x20C40960023A9);
  return this;
}

void webrtc::DelayManager::Config::Log(webrtc::DelayManager::Config *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  _QWORD v11[3];
  _QWORD v12[2];
  _QWORD v13[2];
  _QWORD v14[2];
  _QWORD v15[2];
  _QWORD v16[2];
  uint64_t v17;
  _QWORD *v18;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    v11[0] = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_cod"
             "ing/neteq/delay_manager.cc";
    v11[1] = 497;
    v11[2] = &v10;
    v12[0] = "Delay manager config: quantile=";
    v12[1] = v11;
    v9 = *((_QWORD *)this + 1);
    v13[0] = *(_QWORD *)this;
    v13[1] = v12;
    v14[0] = " forget_factor=";
    v14[1] = v13;
    v15[0] = v9;
    v15[1] = v14;
    v16[0] = " start_forget_weight=";
    v16[1] = v15;
    if (*((_BYTE *)this + 24))
    {
      v17 = *((_QWORD *)this + 2);
      v18 = v16;
    }
    else
    {
      v17 = 0;
      v18 = v16;
    }
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v2, v3, v4, v5, v6, v7, v8, **(_QWORD **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v18[1] + 8) + 8) + 8) + 8));
  }
}

uint64_t webrtc::DelayManager::DelayManager(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v5;
  unsigned int v6;
  void (**v7)(webrtc::DelayManager *__hidden);
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  _OWORD *v12;
  double v13;
  _QWORD *v14;
  _QWORD *v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  double v19;
  _OWORD *v20;
  int v21;

  v5 = *(double *)(a2 + 8);
  v6 = vcvtd_n_s64_f64(*(double *)a2, 0x1EuLL);
  v7 = &off_24C0B31C0;
  *(_QWORD *)a1 = &off_24C0B31C0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 60);
  v8 = vcvtd_n_s64_f64(v5, 0xFuLL);
  v9 = *(unsigned __int8 *)(a2 + 24);
  v10 = *(_QWORD *)(a2 + 32);
  if (*(_BYTE *)(a2 + 24))
    v11 = (double)(int)*(double *)(a2 + 16);
  else
    v11 = 0.0;
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 24) = &off_24C0B4B98;
  v12 = operator new(0x190uLL);
  *(_QWORD *)(a1 + 48) = v12 + 25;
  *v12 = 0u;
  v12[1] = 0u;
  v12[2] = 0u;
  v12[3] = 0u;
  v12[4] = 0u;
  v12[5] = 0u;
  v12[6] = 0u;
  v12[7] = 0u;
  v12[8] = 0u;
  v12[9] = 0u;
  v12[10] = 0u;
  v12[11] = 0u;
  v12[12] = 0u;
  v12[13] = 0u;
  v12[14] = 0u;
  v12[15] = 0u;
  v12[16] = 0u;
  v12[17] = 0u;
  v12[18] = 0u;
  v12[19] = 0u;
  v12[20] = 0u;
  v12[21] = 0u;
  v12[22] = 0u;
  v12[23] = 0u;
  v12[24] = 0u;
  *(_QWORD *)(a1 + 32) = v12;
  *(_QWORD *)(a1 + 40) = v12 + 25;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = v8;
  *(_DWORD *)(a1 + 64) = 0;
  *(double *)(a1 + 72) = v11;
  *(_QWORD *)(a1 + 80) = v9;
  *(_DWORD *)(a1 + 88) = v6;
  *(_QWORD *)(a1 + 92) = v10;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 116) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  if (*(_BYTE *)(a2 + 40))
  {
    v13 = *(double *)(a2 + 48);
    v14 = (_QWORD *)operator new();
    v15 = v14;
    v16 = vcvtd_n_s64_f64(v13, 0xFuLL);
    v17 = *(_DWORD *)(a2 + 56);
    v18 = *(unsigned __int8 *)(a2 + 24);
    if (*(_BYTE *)(a2 + 24))
      v19 = (double)(int)*(double *)(a2 + 16);
    else
      v19 = 0.0;
    *v14 = &off_24C0B4B98;
    v20 = operator new(0x190uLL);
    v15[3] = v20 + 25;
    *v20 = 0u;
    v20[1] = 0u;
    v20[2] = 0u;
    v20[3] = 0u;
    v20[4] = 0u;
    v20[5] = 0u;
    v20[6] = 0u;
    v20[7] = 0u;
    v20[8] = 0u;
    v20[9] = 0u;
    v20[10] = 0u;
    v20[11] = 0u;
    v20[12] = 0u;
    v20[13] = 0u;
    v20[14] = 0u;
    v20[15] = 0u;
    v20[16] = 0u;
    v20[17] = 0u;
    v20[18] = 0u;
    v20[19] = 0u;
    v20[20] = 0u;
    v20[21] = 0u;
    v20[22] = 0u;
    v20[23] = 0u;
    v20[24] = 0u;
    v15[1] = v20;
    v15[2] = v20 + 25;
    *((_DWORD *)v15 + 8) = 0;
    *((_DWORD *)v15 + 9) = v16;
    *((_DWORD *)v15 + 10) = 0;
    *((double *)v15 + 6) = v19;
    v15[7] = v18;
    *((_DWORD *)v15 + 16) = v17;
    *((_BYTE *)v15 + 68) = 0;
    *((_BYTE *)v15 + 72) = 0;
    v7 = *(void (***)(webrtc::DelayManager *__hidden))a1;
  }
  else
  {
    v15 = 0;
  }
  *(_QWORD *)(a1 + 128) = v15;
  v21 = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 136) = v21;
  *(_DWORD *)(a1 + 140) = v21;
  *(_OWORD *)(a1 + 144) = xmmword_208F08C80;
  *(_DWORD *)(a1 + 160) = 0;
  v7[3]((webrtc::DelayManager *)a1);
  return a1;
}

void webrtc::DelayManager::~DelayManager(webrtc::DelayManager *this)
{
  _QWORD *v2;
  void *v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = &off_24C0B31C0;
  v2 = (_QWORD *)*((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v2)
  {
    *v2 = &off_24C0B4B98;
    v3 = (void *)v2[1];
    if (v3)
    {
      v2[2] = v3;
      operator delete(v3);
    }
    MEMORY[0x20BD0ADEC](v2, 0x1090C40E8676ED2);
  }
  v4 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v4)
    MEMORY[0x20BD0ADEC](v4, 0x1060C40C2E02434);
  *((_QWORD *)this + 3) = &off_24C0B4B98;
  v5 = (void *)*((_QWORD *)this + 4);
  if (v5)
  {
    *((_QWORD *)this + 5) = v5;
    operator delete(v5);
  }
}

{
  _QWORD *v2;
  void *v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = &off_24C0B31C0;
  v2 = (_QWORD *)*((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v2)
  {
    *v2 = &off_24C0B4B98;
    v3 = (void *)v2[1];
    if (v3)
    {
      v2[2] = v3;
      operator delete(v3);
    }
    MEMORY[0x20BD0ADEC](v2, 0x1090C40E8676ED2);
  }
  v4 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v4)
    MEMORY[0x20BD0ADEC](v4, 0x1060C40C2E02434);
  *((_QWORD *)this + 3) = &off_24C0B4B98;
  v5 = (void *)*((_QWORD *)this + 4);
  if (v5)
  {
    *((_QWORD *)this + 5) = v5;
    operator delete(v5);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::DelayManager::Update(uint64_t this, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  int v8;
  int *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int *v26;
  int v27;
  int v28;

  v5 = this;
  v6 = *(_QWORD *)(this + 128);
  if (v6)
    v7 = a3 == 0;
  else
    v7 = 1;
  if (v7)
  {
    this = webrtc::UnderrunOptimizer::Update(this + 16, a2);
    if (*(_BYTE *)(v5 + 120))
      v8 = *(_DWORD *)(v5 + 116);
    else
      v8 = 80;
    *(_DWORD *)(v5 + 156) = v8;
    v9 = (int *)(v5 + 156);
    v6 = *(_QWORD *)(v5 + 128);
    if (!v6)
    {
LABEL_37:
      v24 = *(_DWORD *)(v5 + 148);
      v25 = *(_DWORD *)(v5 + 140);
      if (v8 > v25)
        v25 = v8;
      *(_DWORD *)(v5 + 156) = v25;
      *(_DWORD *)(v5 + 160) = v8;
      if (v24 >= 1)
      {
        if (v24 >= v25)
          v26 = v9;
        else
          v26 = (int *)(v5 + 148);
        v25 = *v26;
        *v9 = v25;
      }
      v27 = *(_DWORD *)(v5 + 152);
      if (v27 >= 1)
      {
        v28 = 3 * v27 * *(_DWORD *)(v5 + 8) / 4;
        if (v28 < v25)
          v25 = v28;
        *(_DWORD *)(v5 + 156) = v25;
      }
      return this;
    }
  }
  else
  {
    if (*(_BYTE *)(this + 120))
      v8 = *(_DWORD *)(this + 116);
    else
      v8 = 80;
    *(_DWORD *)(this + 156) = v8;
    v9 = (int *)(this + 156);
  }
  if (a3)
    v10 = a2 / 20;
  else
    v10 = 0;
  v11 = *(_QWORD *)(v6 + 8);
  v12 = *(_QWORD *)(v6 + 16) - v11;
  if (v10 < (int)((unint64_t)v12 >> 2))
  {
    this = webrtc::Histogram::Add(v6, v10);
    v11 = *(_QWORD *)(v6 + 8);
    v12 = *(_QWORD *)(v6 + 16) - v11;
  }
  v13 = v12 >> 2;
  if ((int)(v12 >> 2) < 1)
  {
    v22 = 20;
LABEL_31:
    *(_DWORD *)(v6 + 68) = v22;
    *(_BYTE *)(v6 + 72) = 1;
    v23 = *(_QWORD *)(*(_QWORD *)(v5 + 128) + 68);
    if ((v23 & 0xFF00000000) == 0)
      LODWORD(v23) = 0;
    if (*(_DWORD *)(v5 + 156) <= (int)v23)
      v8 = v23;
    else
      v8 = *(_DWORD *)(v5 + 156);
    *(_DWORD *)(v5 + 156) = v8;
    goto LABEL_37;
  }
  v14 = 0;
  v15 = 0;
  v16 = ((unint64_t)v12 >> 2);
  v17 = -v8;
  v18 = 0x7FFFFFFFFFFFFFFFLL;
  v19 = 0x40000000;
  while (v13 != v14)
  {
    this = v17 & ~(v17 >> 31);
    v20 = *(int *)(v6 + 64);
    v19 -= *(int *)(v11 + 4 * v14);
    v21 = 100 * v20 * v19 + (this << 30);
    if (v21 < v18)
      v15 = v14;
    if (v19)
    {
      if (v21 < v18)
        v18 = 100 * v20 * v19 + (this << 30);
      ++v14;
      v17 += 20;
      if (v16 != v14)
        continue;
    }
    v22 = 20 * v15 + 20;
    goto LABEL_31;
  }
  __break(1u);
  return this;
}

uint64_t webrtc::DelayManager::SetPacketAudioLength(webrtc::DelayManager *this, int a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a2 <= 0)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v4, v5, v6, v7, v8, v9, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/delay_manager.cc");
    return 0xFFFFFFFFLL;
  }
  else
  {
    result = 0;
    *((_DWORD *)this + 38) = a2;
  }
  return result;
}

uint64_t webrtc::DelayManager::Reset(webrtc::DelayManager *this)
{
  _DWORD *v2;
  _DWORD *v3;
  unsigned int v4;
  uint64_t result;
  uint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  unsigned int v9;

  *((_DWORD *)this + 38) = 0;
  v2 = (_DWORD *)*((_QWORD *)this + 4);
  v3 = (_DWORD *)*((_QWORD *)this + 5);
  if (v2 != v3)
  {
    v4 = 16386;
    do
    {
      v4 >>= 1;
      *v2++ = v4 << 16;
    }
    while (v2 != v3);
  }
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 16) = 0;
  result = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (result)
    result = MEMORY[0x20BD0ADEC](result, 0x1060C40C2E02434);
  *((_DWORD *)this + 28) = 0;
  if (*((_BYTE *)this + 120))
    *((_BYTE *)this + 120) = 0;
  *((_DWORD *)this + 39) = 80;
  v6 = *((_QWORD *)this + 16);
  if (v6)
  {
    v7 = *(_DWORD **)(v6 + 8);
    v8 = *(_DWORD **)(v6 + 16);
    if (v7 != v8)
    {
      v9 = 16386;
      do
      {
        v9 >>= 1;
        *v7++ = v9 << 16;
      }
      while (v7 != v8);
    }
    *(_DWORD *)(v6 + 32) = 0;
    *(_DWORD *)(v6 + 40) = 0;
    if (*(_BYTE *)(v6 + 72))
      *(_BYTE *)(v6 + 72) = 0;
  }
  return result;
}

uint64_t webrtc::DelayManager::TargetDelayMs(webrtc::DelayManager *this)
{
  return *((unsigned int *)this + 39);
}

uint64_t webrtc::DelayManager::UnlimitedTargetLevelMs(webrtc::DelayManager *this)
{
  return *((unsigned int *)this + 40);
}

uint64_t webrtc::DelayManager::SetMinimumDelay(webrtc::DelayManager *this, int a2)
{
  int v2;
  int v3;
  int v4;
  int v6;

  if (a2 < 0)
    return 0;
  v2 = *((_DWORD *)this + 38) * *((_DWORD *)this + 2);
  v3 = 3 * v2 / 4;
  if (v2 <= 1)
    v3 = 10000;
  if (*((int *)this + 37) <= 0)
    v4 = 10000;
  else
    v4 = *((_DWORD *)this + 37);
  if (v3 < v4)
    v4 = v3;
  if (v4 < a2)
    return 0;
  v6 = *((_DWORD *)this + 34);
  if (v6 < v4)
    v4 = *((_DWORD *)this + 34);
  if (v6 <= 0)
    v4 = 0;
  if (a2 > v4)
    v4 = a2;
  *((_DWORD *)this + 35) = v4;
  *((_DWORD *)this + 36) = a2;
  return 1;
}

uint64_t webrtc::DelayManager::SetMaximumDelay(webrtc::DelayManager *this, int a2)
{
  int v2;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;

  if (a2)
  {
    v2 = *((_DWORD *)this + 36);
    if (v2 > a2)
      return 0;
  }
  else
  {
    v2 = *((_DWORD *)this + 36);
  }
  *((_DWORD *)this + 37) = a2;
  v4 = *((_DWORD *)this + 34);
  v5 = *((_DWORD *)this + 38) * *((_DWORD *)this + 2);
  v6 = 3 * v5 / 4;
  if (v5 <= 1)
    v6 = 10000;
  if (a2 <= 0)
    v7 = 10000;
  else
    v7 = a2;
  if (v6 < v7)
    v7 = v6;
  if (v4 < v7)
    v7 = *((_DWORD *)this + 34);
  if (v4 <= 0)
    v8 = 0;
  else
    v8 = v7;
  if (v2 <= v8)
    v2 = v8;
  *((_DWORD *)this + 35) = v2;
  return 1;
}

BOOL webrtc::DelayManager::SetBaseMinimumDelay(webrtc::DelayManager *this, unsigned int a2)
{
  int v2;
  int v3;
  int v4;

  if (a2 <= 0x2710)
  {
    v2 = *((_DWORD *)this + 38) * *((_DWORD *)this + 2);
    if (v2 <= 1)
      v3 = 10000;
    else
      v3 = 3 * v2 / 4;
    if (*((int *)this + 37) <= 0)
      v4 = 10000;
    else
      v4 = *((_DWORD *)this + 37);
    if (v3 < v4)
      v4 = v3;
    if ((int)a2 < v4)
      v4 = a2;
    if (!a2)
      v4 = 0;
    if (*((_DWORD *)this + 36) > v4)
      v4 = *((_DWORD *)this + 36);
    *((_DWORD *)this + 34) = a2;
    *((_DWORD *)this + 35) = v4;
  }
  return a2 < 0x2711;
}

uint64_t webrtc::DelayManager::GetBaseMinimumDelay(webrtc::DelayManager *this)
{
  return *((unsigned int *)this + 34);
}

char *webrtc::webrtc_impl::StringToDecodeTargetIndications@<X0>(char *result@<X0>, unint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v3;
  char *v4;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;

  v3 = a2;
  v4 = result;
  *a3 = 0;
  v6 = a3 + 1;
  if (a2 < 0xB)
    goto LABEL_24;
  if (a2 <= 0x14)
    v7 = 20;
  else
    v7 = a2;
  if (v7 >> 62)
    std::__throw_bad_array_new_length[abi:sn180100]();
  result = (char *)operator new(4 * v7);
  a3[1] = (unint64_t)result;
  a3[2] = v7;
  *a3 = 1;
  do
  {
    while (1)
    {
      while (1)
      {
        v8 = *v4;
        v13 = 0;
        if (v8 == 83)
        {
          v9 = 2;
        }
        else if (v8 == 82)
        {
          v9 = 3;
        }
        else
        {
          v9 = 0;
          if (v8 != 68)
            goto LABEL_14;
          v9 = 1;
        }
        v13 = v9;
LABEL_14:
        v10 = *a3;
        v11 = (_QWORD *)a3[1];
        if ((*a3 & 1) != 0)
        {
          v12 = a3[2];
        }
        else
        {
          v11 = v6;
          v12 = 10;
        }
        if (v10 >> 1 != v12)
          break;
        result = absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::EmplaceBackSlow<webrtc::DecodeTargetIndication const&>((uint64_t)a3, &v13);
        ++v4;
        if (!--v3)
          return result;
      }
      if (!v11)
        break;
      *((_DWORD *)v11 + (v10 >> 1)) = v9;
      *a3 = v10 + 2;
      ++v4;
      if (!--v3)
        return result;
    }
    __break(1u);
LABEL_24:
    ;
  }
  while (v3);
  return result;
}

char *absl::inlined_vector_internal::Storage<webrtc::DecodeTargetIndication,10ul,std::allocator<webrtc::DecodeTargetIndication>>::EmplaceBackSlow<webrtc::DecodeTargetIndication const&>(uint64_t a1, _DWORD *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  int *v13;
  _OWORD *v14;
  __int128 *v15;
  uint64_t v16;
  __int128 v17;
  unint64_t v18;
  char *v19;
  int v20;

  v5 = a1 + 8;
  v4 = *(_QWORD *)a1;
  if ((*(_QWORD *)a1 & 1) != 0)
  {
    v7 = *(_QWORD *)(a1 + 16);
    if (((v7 >> 61) & 3) != 0)
      std::__throw_bad_array_new_length[abi:sn180100]();
    v5 = *(_QWORD *)(a1 + 8);
    v6 = 2 * v7;
  }
  else
  {
    v6 = 20;
  }
  v8 = v4 >> 1;
  v9 = (char *)operator new(4 * v6);
  v10 = v9;
  v11 = &v9[4 * (v4 >> 1)];
  *(_DWORD *)v11 = *a2;
  if (v4 >= 2)
  {
    v12 = 0;
    if (v4 < 0x10 || (unint64_t)&v9[-v5] < 0x20)
    {
      v13 = (int *)v5;
    }
    else
    {
      v12 = v8 & 0x7FFFFFFFFFFFFFF8;
      v13 = (int *)(v5 + 4 * (v8 & 0x7FFFFFFFFFFFFFF8));
      v14 = v9 + 16;
      v15 = (__int128 *)(v5 + 16);
      v16 = v8 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v17 = *v15;
        *(v14 - 1) = *(v15 - 1);
        *v14 = v17;
        v14 += 2;
        v15 += 2;
        v16 -= 8;
      }
      while (v16);
      if (v8 == v12)
        goto LABEL_15;
    }
    v18 = v8 - v12;
    v19 = &v9[4 * v12];
    do
    {
      v20 = *v13++;
      *(_DWORD *)v19 = v20;
      v19 += 4;
      --v18;
    }
    while (v18);
  }
LABEL_15:
  if ((v4 & 1) != 0)
  {
    operator delete(*(void **)(a1 + 8));
    v4 = *(_QWORD *)a1;
  }
  *(_QWORD *)(a1 + 8) = v10;
  *(_QWORD *)(a1 + 16) = v6;
  *(_QWORD *)a1 = (v4 | 1) + 2;
  return v11;
}

uint64_t webrtc::WebRtcAgc_CalculateGainTable(webrtc *this, int *a2, int a3, int a4, int a5)
{
  int v5;
  uint64_t v7;
  unint64_t v8;
  int v9;
  __int16 v10;
  int v11;
  unsigned int v12;
  int v13;
  signed int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  signed int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  char v32;
  unsigned int v33;
  BOOL v34;
  unsigned int v35;
  char v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v42;
  signed int v43;
  int v44;
  int v45;

  v5 = ((2 * (int)a2) | 1) / 3;
  if ((v5 & 0xFF80) != 0)
    return 0xFFFFFFFFLL;
  v7 = 0;
  v8 = 1431655766 * ((2 * ((int)a2 - a5)) | 1);
  v9 = (__int16)(WORD2(v8) + (v8 >> 63) + a5 - a3);
  if (a5 - a3 <= v9)
    v10 = v9;
  else
    v10 = a5 - a3;
  v12 = 20 * v11;
  v13 = (v10 << 6) * v11;
  v14 = ((5 * v11) >> 6) & 0xFFFFFF;
  v15 = __clz(v12) + 7;
  v16 = -49311 - (a3 << 14);
  do
  {
    v24 = (49321 * (__int16)(2 * v7 - 2)) | 1;
    v25 = ((int)(((unint64_t)(1431655765 * v24) >> 32) - v24) >> 1)
        + ((((unint64_t)(1431655765 * v24) >> 32) - v24) >> 31)
        + (v5 << 14);
    if (v25 >= 0)
      v26 = ((int)(((unint64_t)(1431655765 * v24) >> 32) - v24) >> 1)
          + ((((unint64_t)(1431655765 * v24) >> 32) - v24) >> 31)
          + (v5 << 14);
    else
      v26 = -v25;
    v28 = (v26 & 0x3FFF)
        + (v27 << 14);
    if (v25 < 0)
    {
      v30 = __clz(v26);
      v31 = 23637 * (v26 >> (15 - v30));
      v32 = 9 - v30;
      v33 = v28 >> (9 - v30);
      if (v30 > 8)
      {
        v31 >>= v30 - 9;
        v33 = v28;
        v32 = 0;
      }
      v34 = v30 > 0xE;
      if (v30 <= 0xE)
        v35 = v31;
      else
        v35 = (23637 * v26) >> 6;
      if (v34)
      {
        v33 = v28;
        v36 = 0;
      }
      else
      {
        v36 = v32;
      }
      v37 = (v33 - v35) >> (8 - v36);
      if (v33 > v35)
        v29 = v37;
      else
        v29 = 0;
    }
    else
    {
      v29 = v28 >> 8;
    }
    v38 = v13 - v29 * v5;
    v39 = __clz(v38 ^ (v38 >> 31)) - 1;
    if (v13 == v29 * v5)
      v40 = 0;
    else
      v40 = v39;
    if (v38 <= v14 && v38 >= -v14)
      v40 = v15;
    v42 = v38 << v40;
    if (v40 <= 8)
      v43 = v12 >> (9 - v40);
    else
      v43 = v12 << (v40 - 9);
    v44 = v42 / v43;
    if (v44 >= 0)
      v45 = (v44 + 1) >> 1;
    else
      v45 = -((1 - v44) >> 1);
    if (a4 && v7 < (__int16)((__int16)((_WORD)a5 << 13) / 24660 + 2))
      v45 = v16 / 20;
    v17 = (54426 * v45 + 0x2000) >> 14;
    if (v45 >= 39001)
      v17 = (54426 * (v45 >> 1) + 4096) >> 13;
    v18 = v17 + 0x40000;
    v19 = (v17 + 0x40000) >> 14;
    v20 = v17 & 0x3FFF;
    if (v20 >= 0x2000)
      v21 = 0x4000 - ((9951 * (0x4000 - v20)) >> 13);
    else
      v21 = (6433 * v20) >> 13;
    v22 = v21 << (v19 - 14);
    v23 = v21 >> (14 - v19);
    if (v18 >> 15 > 6)
      v23 = v22;
    *((_DWORD *)this + v7++) = v23 + (1 << v19);
    v16 += 49321;
  }
  while (v7 != 32);
  return 0;
}

uint64_t webrtc::WebRtcAgc_ProcessVad(uint64_t a1, __int16 *a2, uint64_t a3)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  signed int v12;
  int v13;
  unsigned int v14;
  int v15;
  signed int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  BOOL v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  signed int v27;
  int v28;
  unsigned int v29;
  int v30;
  signed int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  __int16 v37;
  __int16 v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  int v46;
  unsigned int v47;
  int v48;
  unsigned int v49;
  int v50;
  int v51;
  signed int v52;
  BOOL v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  int v57;
  int v58;
  unsigned int v59;
  int v60;
  int v61;
  unsigned int v62;
  int v63;
  int v64;
  unsigned int v65;
  int v66;
  unsigned int v67;
  int v68;
  int v69;
  signed int v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  __int16 v77;
  __int16 v79;
  __int16 v80;
  __int16 v81;
  __int16 v82;
  __int16 v83[8];
  uint64_t v84;

  v84 = *MEMORY[0x24BDAC8D0];
  LOWORD(v5) = *(_WORD *)(a1 + 32);
  if (a3 == 160)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v83[0] = (a2[1] + *a2) >> 1;
      v83[1] = (a2[3] + a2[2]) >> 1;
      v83[2] = (a2[5] + a2[4]) >> 1;
      v83[3] = (a2[7] + a2[6]) >> 1;
      v83[4] = (a2[9] + a2[8]) >> 1;
      v83[5] = (a2[11] + a2[10]) >> 1;
      v83[6] = (a2[13] + a2[12]) >> 1;
      v83[7] = (a2[15] + a2[14]) >> 1;
      WebRtcSpl_DownsampleBy2(v83, 8uLL, &v79, (int *)a1);
      v8 = v79 + (__int16)v5;
      v9 = ((600 * v8) >> 10) - v79;
      v10 = v7 + v8 / 64 * v8;
      v12 = (v8 - (v11 & 0xFFFFFFC0)) * v8;
      v13 = v80 + (__int16)v9;
      v14 = ((600 * v13) >> 10) - v80;
      v15 = v10 + v12 / 64 + v13 / 64 * v13;
      v16 = (v13 - (v10 & 0xFFFFFFC0)) * v13;
      v17 = v16 + 63;
      v18 = v15 + v16 / 64;
      v19 = v81 + (__int16)v14;
      v20 = v82 + (__int16)(((600 * v19) >> 10) - v81);
      v5 = ((600 * v20) >> 10) - v82;
      v7 = v18
         + v19 / 64 * v19
         + (int)((v19 - (v17 & 0xFFFFFFC0)) * v19) / 64
         + v20 / 64 * v20
         + (int)((v20
                - (((v19 - (v17 & 0xFFFFFFC0)) * v19
                  + ((((v19 - (v17 & 0xFFFFFFC0)) * v19) & 0x80000000) != 0 ? 0x3F : 0)) & 0xFFFFFFC0))
               * v20)
         / 64;
      a2 += 16;
      v21 = v6++ >= 9;
    }
    while (!v21);
  }
  else
  {
    v22 = 0;
    v7 = 0;
    do
    {
      WebRtcSpl_DownsampleBy2(a2, 8uLL, &v79, (int *)a1);
      v23 = v79 + (__int16)v5;
      v24 = ((600 * v23) >> 10) - v79;
      v25 = v7 + v23 / 64 * v23;
      v27 = (v23 - (v26 & 0xFFFFFFC0)) * v23;
      v28 = v80 + (__int16)v24;
      v29 = ((600 * v28) >> 10) - v80;
      v30 = v25 + v27 / 64 + v28 / 64 * v28;
      v31 = (v28 - (v25 & 0xFFFFFFC0)) * v28;
      v32 = v31 + 63;
      v33 = v30 + v31 / 64;
      v34 = v81 + (__int16)v29;
      v35 = v82 + (__int16)(((600 * v34) >> 10) - v81);
      v5 = ((600 * v35) >> 10) - v82;
      v7 = v33
         + v34 / 64 * v34
         + (int)((v34 - (v32 & 0xFFFFFFC0)) * v34) / 64
         + v35 / 64 * v35
         + (int)((v35
                - (((v34 - (v32 & 0xFFFFFFC0)) * v34
                  + ((((v34 - (v32 & 0xFFFFFFC0)) * v34) & 0x80000000) != 0 ? 0x3F : 0)) & 0xFFFFFFC0))
               * v35)
         / 64;
      a2 += 8;
      v21 = v22++ >= 9;
    }
    while (!v21);
  }
  *(_WORD *)(a1 + 32) = v5;
  v36 = *(__int16 *)(a1 + 34);
  if (v36 <= 249)
  {
    LOWORD(v36) = v36 + 1;
    *(_WORD *)(a1 + 34) = v36;
  }
  v37 = v7 < 0x10000;
  if (v7 << (16 * v37) >> 24)
    v38 = 16 * v37;
  else
    v38 = (16 * (v7 < 0x10000)) | 8;
  if (!(v7 << v38 >> 28))
    v38 |= 4u;
  if (!(v7 << v38 >> 30))
    v38 |= 2u;
  v39 = (__int16)(((v38 + (((v7 << v38) & 0x80000000) == 0)) << 11) ^ 0x7800);
  v40 = v39 - *(__int16 *)(a1 + 46) + 16 * *(__int16 *)(a1 + 46);
  *(_WORD *)(a1 + 46) = v40 >> 4;
  v41 = (v39 * v39) >> 12;
  v42 = (int)(v41 - *(_DWORD *)(a1 + 48) + 16 * *(_DWORD *)(a1 + 48)) / 16;
  *(_DWORD *)(a1 + 48) = v42;
  v43 = (v42 << 12) - (__int16)(v40 >> 4) * (__int16)(v40 >> 4);
  if ((v43 & 0x80000000) != 0)
  {
    if (v43 == 0x80000000)
      v43 = 0x7FFFFFFF;
    else
      v43 = -v43;
  }
  else if (!v43)
  {
    goto LABEL_32;
  }
  v44 = __clz(v43) - 1;
  v45 = (unsigned __int16)v44;
  v46 = v43 << v44;
  if (v46 >= 2147450880)
    v47 = 2147418112;
  else
    v47 = (v46 + 0x8000) & 0xFFFF0000;
  v48 = (unsigned __int16)v44 >> 1;
  if ((v47 & 0x80000000) != 0)
    v47 = -v47;
  v49 = (v47 >> 17) | 0xFFFFC000;
  v50 = -2 * v49 * v49;
  v51 = (unsigned __int16)(((v50 >> 16) * (v50 >> 16)) >> 15);
  v52 = (v47 >> 1)
      + 1073774592
      + (v50 >> 1)
      + ((v49 * v49) >> 15) * v49
      - 40960 * v51
      + 57344 * (__int16)((int)(v49 * v51) >> 15);
  v53 = v45 == 2 * v48;
  v54 = HIWORD(v52);
  v55 = ((46340 * (v52 >> 16) + 0x8000) >> 15) & 0xFFFE;
  if (!v53)
    v55 = v54;
  v43 = v55 >> v48;
LABEL_32:
  *(_WORD *)(a1 + 52) = v43;
  v56 = (__int16)v36;
  if ((__int16)v36 >= 32766)
    LOWORD(v36) = 32766;
  v57 = (unsigned __int16)v36 + 1;
  if ((v57 & 0x10000) != 0)
  {
    LOWORD(v58) = 0x7FFF;
    *(_WORD *)(a1 + 38) = 0x7FFF;
    *(_DWORD *)(a1 + 40) = 0x7FFFFFFF;
    v59 = -1073680385;
    goto LABEL_39;
  }
  v60 = (__int16)v57;
  v58 = (v39 + *(__int16 *)(a1 + 38) * v56) / (__int16)v57;
  v61 = (int)(v41 + *(_DWORD *)(a1 + 40) * v56) / v60;
  *(_WORD *)(a1 + 38) = v58;
  *(_DWORD *)(a1 + 40) = v61;
  v59 = (v61 << 12) - (__int16)v58 * (__int16)v58;
  if ((v59 & 0x80000000) != 0)
  {
LABEL_39:
    if (v59 == 0x80000000)
      v59 = 0x7FFFFFFF;
    else
      v59 = -v59;
    goto LABEL_42;
  }
  if (!v59)
  {
    *(_WORD *)(a1 + 44) = 0;
    goto LABEL_51;
  }
LABEL_42:
  v62 = __clz(v59) - 1;
  v63 = (unsigned __int16)v62;
  v64 = v59 << v62;
  if (v64 >= 2147450880)
    v65 = 2147418112;
  else
    v65 = (v64 + 0x8000) & 0xFFFF0000;
  v66 = (unsigned __int16)v62 >> 1;
  if ((v65 & 0x80000000) != 0)
    v65 = -v65;
  v67 = (v65 >> 17) | 0xFFFFC000;
  v68 = -2 * v67 * v67;
  v69 = (unsigned __int16)(((v68 >> 16) * (v68 >> 16)) >> 15);
  v70 = (v65 >> 1)
      + 1073774592
      + (v68 >> 1)
      + ((v67 * v67) >> 15) * v67
      - 40960 * v69
      + 57344 * (__int16)((int)(v67 * v69) >> 15);
  v71 = HIWORD(v70);
  v72 = ((46340 * (v70 >> 16) + 0x8000) >> 15) & 0xFFFE;
  if (v63 != 2 * v66)
    v72 = v71;
  v73 = v72 >> v66;
  *(_WORD *)(a1 + 44) = v73;
  if (v73)
  {
    v74 = 12288 * (__int16)(v39 - v58) / (__int16)v73;
    goto LABEL_52;
  }
LABEL_51:
  v74 = 0x7FFFFFFFLL;
LABEL_52:
  v75 = v74 + ((53248 * *(__int16 *)(a1 + 36)) >> 10);
  v76 = v75 >> 6;
  if (v75 >> 6 <= -2048)
    LOWORD(v76) = -2048;
  if (v75 <= 131135)
    v77 = v76;
  else
    v77 = 2048;
  *(_WORD *)(a1 + 36) = v77;
  return v77;
}

uint64_t webrtc::WebRtcAgc_ComputeDigitalGains(uint64_t a1, __int16 **a2, uint64_t a3, int a4, int a5, _DWORD *a6)
{
  uint64_t result;
  char v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  __int16 *v18;
  int16x8_t v19;
  int32x4_t v20;
  int32x4_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int32x4_t v28;
  int32x4_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int32x4_t v32;
  int32x4_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int32x4_t v36;
  int32x4_t v37;
  int16x8_t v38;
  int16x8_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int16x8_t v50;
  int16x8_t v51;
  int32x4_t v52;
  int32x4_t v53;
  int16x8_t v54;
  int16x8_t v55;
  int32x4_t v56;
  int32x4_t v57;
  int16x8_t v58;
  uint64_t v59;
  int v60;
  int v61;
  int v62;
  signed int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  BOOL v75;
  int v76;
  int v77;
  int v78;
  unsigned int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  unsigned int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  unsigned int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  unsigned int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  unsigned int v115;
  int v116;
  uint64_t v117;
  int v118;
  signed int v119;
  int v120;
  unsigned int v121;
  int v122;
  signed int v123;
  unsigned int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  _DWORD v134[10];
  uint64_t v135;

  v135 = *MEMORY[0x24BDAC8D0];
  result = 0xFFFFFFFFLL;
  if (a4 <= 31999)
  {
    if (a4 == 8000)
    {
      v11 = 1;
      v12 = 8;
LABEL_9:
      v13 = webrtc::WebRtcAgc_ProcessVad(a1 + 144, *a2, 10 * v12);
      if (*(__int16 *)(a1 + 234) >= 11)
        v13 = (3 * v13 - *(__int16 *)(a1 + 236)) >> 2;
      if ((__int16)v13 <= 1024)
      {
        if ((__int16)v13 < 0)
        {
          LOWORD(v14) = 0;
          if (*(_WORD *)(a1 + 142) == 3)
            goto LABEL_24;
        }
        else
        {
          v14 = (67108799 * (__int16)v13) >> 10;
          if (*(_WORD *)(a1 + 142) == 3)
            goto LABEL_24;
        }
      }
      else
      {
        LOWORD(v14) = -65;
        if (*(_WORD *)(a1 + 142) == 3)
          goto LABEL_24;
      }
      v15 = *(__int16 *)(a1 + 188);
      if (v15 >= 4000)
      {
        v16 = (unsigned __int16)v15 >> 5;
        v17 = ((v15 + 268431456) * (__int16)v14) >> 12;
        if (v16 <= 0xFC)
          LOWORD(v14) = v17;
      }
      else
      {
        LOWORD(v14) = 0;
      }
      if (a5)
        LOWORD(v14) = 0;
LABEL_24:
      v18 = *a2;
      v19 = *(int16x8_t *)*a2;
      v20 = vmull_high_s16(v19, v19);
      v21 = vmull_s16(*(int16x4_t *)v19.i8, *(int16x4_t *)v19.i8);
      if ((v11 & 1) == 0)
      {
        v22 = *((int16x8_t *)v18 + 1);
        v20 = vmaxq_s32(vmull_high_s16(v22, v22), v20);
        v21 = vmaxq_s32(vmull_s16(*(int16x4_t *)v22.i8, *(int16x4_t *)v22.i8), v21);
      }
      v134[0] = vmaxvq_s32(vmaxq_s32(v21, v20));
      v23 = *(int16x8_t *)&v18[v12];
      v24 = vmull_high_s16(v23, v23);
      v25 = vmull_s16(*(int16x4_t *)v23.i8, *(int16x4_t *)v23.i8);
      if ((v11 & 1) == 0)
      {
        v26 = *(int16x8_t *)&v18[v12 + 8];
        v24 = vmaxq_s32(vmull_high_s16(v26, v26), v24);
        v25 = vmaxq_s32(vmull_s16(*(int16x4_t *)v26.i8, *(int16x4_t *)v26.i8), v25);
      }
      v134[1] = vmaxvq_s32(vmaxq_s32(v25, v24));
      v27 = *(int16x8_t *)&v18[2 * v12];
      v28 = vmull_high_s16(v27, v27);
      v29 = vmull_s16(*(int16x4_t *)v27.i8, *(int16x4_t *)v27.i8);
      if ((v11 & 1) == 0)
      {
        v30 = *(int16x8_t *)((char *)v18 + ((4 * v12) | 0x10));
        v28 = vmaxq_s32(vmull_high_s16(v30, v30), v28);
        v29 = vmaxq_s32(vmull_s16(*(int16x4_t *)v30.i8, *(int16x4_t *)v30.i8), v29);
      }
      v134[2] = vmaxvq_s32(vmaxq_s32(v29, v28));
      v31 = *(int16x8_t *)&v18[3 * v12];
      v32 = vmull_high_s16(v31, v31);
      v33 = vmull_s16(*(int16x4_t *)v31.i8, *(int16x4_t *)v31.i8);
      if ((v11 & 1) == 0)
      {
        v34 = *(int16x8_t *)&v18[3 * v12 + 8];
        v32 = vmaxq_s32(vmull_high_s16(v34, v34), v32);
        v33 = vmaxq_s32(vmull_s16(*(int16x4_t *)v34.i8, *(int16x4_t *)v34.i8), v33);
      }
      v134[3] = vmaxvq_s32(vmaxq_s32(v33, v32));
      v35 = *(int16x8_t *)&v18[4 * v12];
      v36 = vmull_high_s16(v35, v35);
      v37 = vmull_s16(*(int16x4_t *)v35.i8, *(int16x4_t *)v35.i8);
      if ((v11 & 1) == 0)
      {
        v38 = *(int16x8_t *)((char *)v18 + ((8 * v12) | 0x10));
        v36 = vmaxq_s32(vmull_high_s16(v38, v38), v36);
        v37 = vmaxq_s32(vmull_s16(*(int16x4_t *)v38.i8, *(int16x4_t *)v38.i8), v37);
      }
      v134[4] = vmaxvq_s32(vmaxq_s32(v37, v36));
      v39 = *(int16x8_t *)&v18[5 * v12];
      v40 = vmull_high_s16(v39, v39);
      v41 = vmull_s16(*(int16x4_t *)v39.i8, *(int16x4_t *)v39.i8);
      if ((v11 & 1) == 0)
      {
        v42 = *(int16x8_t *)&v18[5 * v12 + 8];
        v40 = vmaxq_s32(vmull_high_s16(v42, v42), v40);
        v41 = vmaxq_s32(vmull_s16(*(int16x4_t *)v42.i8, *(int16x4_t *)v42.i8), v41);
      }
      v134[5] = vmaxvq_s32(vmaxq_s32(v41, v40));
      v43 = *(int16x8_t *)&v18[6 * v12];
      v44 = vmull_high_s16(v43, v43);
      v45 = vmull_s16(*(int16x4_t *)v43.i8, *(int16x4_t *)v43.i8);
      if ((v11 & 1) == 0)
      {
        v46 = *(int16x8_t *)((char *)v18 + ((12 * v12) | 0x10));
        v44 = vmaxq_s32(vmull_high_s16(v46, v46), v44);
        v45 = vmaxq_s32(vmull_s16(*(int16x4_t *)v46.i8, *(int16x4_t *)v46.i8), v45);
      }
      v134[6] = vmaxvq_s32(vmaxq_s32(v45, v44));
      v47 = *(int16x8_t *)&v18[7 * v12];
      v48 = vmull_high_s16(v47, v47);
      v49 = vmull_s16(*(int16x4_t *)v47.i8, *(int16x4_t *)v47.i8);
      if ((v11 & 1) == 0)
      {
        v50 = *(int16x8_t *)&v18[7 * v12 + 8];
        v48 = vmaxq_s32(vmull_high_s16(v50, v50), v48);
        v49 = vmaxq_s32(vmull_s16(*(int16x4_t *)v50.i8, *(int16x4_t *)v50.i8), v49);
      }
      v134[7] = vmaxvq_s32(vmaxq_s32(v49, v48));
      v51 = *(int16x8_t *)&v18[8 * v12];
      v52 = vmull_high_s16(v51, v51);
      v53 = vmull_s16(*(int16x4_t *)v51.i8, *(int16x4_t *)v51.i8);
      if ((v11 & 1) == 0)
      {
        v54 = *(int16x8_t *)((char *)v18 + ((16 * v12) | 0x10));
        v52 = vmaxq_s32(vmull_high_s16(v54, v54), v52);
        v53 = vmaxq_s32(vmull_s16(*(int16x4_t *)v54.i8, *(int16x4_t *)v54.i8), v53);
      }
      v134[8] = vmaxvq_s32(vmaxq_s32(v53, v52));
      v55 = *(int16x8_t *)&v18[9 * v12];
      v56 = vmull_high_s16(v55, v55);
      v57 = vmull_s16(*(int16x4_t *)v55.i8, *(int16x4_t *)v55.i8);
      if ((v11 & 1) == 0)
      {
        v58 = *(int16x8_t *)&v18[9 * v12 + 8];
        v56 = vmaxq_s32(vmull_high_s16(v58, v58), v56);
        v57 = vmaxq_s32(vmull_s16(*(int16x4_t *)v58.i8, *(int16x4_t *)v58.i8), v57);
      }
      v59 = 0;
      *a6 = *(_DWORD *)(a1 + 8);
      v134[9] = vmaxvq_s32(vmaxq_s32(v57, v56));
      do
      {
        v60 = *(_DWORD *)a1;
        v61 = v134[v59];
        v62 = *(_DWORD *)(a1 + 4)
            - 1000 * (*(int *)(a1 + 4) >> 16)
            + ((-1000 * (unsigned __int16)*(_DWORD *)(a1 + 4)) >> 16);
        if (v61 > v62)
          v62 = v134[v59];
        if (v61 > v60)
          v63 = v60 + 500 * ((v61 - v60) >> 16) + ((500 * (unsigned __int16)(v61 - v60)) >> 16);
        else
          v63 = *(_DWORD *)a1
              + (*(int *)a1 >> 16) * (__int16)v14
              + (((unsigned __int16)*(_DWORD *)a1 * (__int16)v14) >> 16);
        *(_DWORD *)a1 = v63;
        *(_DWORD *)(a1 + 4) = v62;
        if (v62 > v63)
          v63 = v62;
        v64 = __clz(v63);
        if (!v63)
          v64 = 31;
        v65 = v63 << v64;
        a6[++v59] = *(_DWORD *)(a1 + 4 * v64 + 12)
                  + (((unint64_t)((v65 >> 19) & 0xFFF)
                    * (*(int *)(a1 + 4 * v64 + 8) - (uint64_t)*(int *)(a1 + 4 * v64 + 12))) >> 12);
      }
      while (v59 != 10);
      v66 = *(_DWORD *)(a1 + 4);
      v67 = __clz(v66);
      if (!v66)
        v67 = 31;
      v68 = (((v67 << 25) - ((v66 << v67 >> 6) & 0x1FF0000)) >> 16)
          - (*(unsigned __int16 *)(a1 + 196)
           + (((v64 << 25) - ((v65 >> 19 << 13) & 0x1FF0000)) >> 16))
          + 1000;
      if ((v68 & 0x8000) != 0)
      {
        *(_WORD *)(a1 + 140) = 0;
        v69 = v68 << 16;
        if ((int)(v68 << 16) < 1)
          goto LABEL_88;
      }
      else
      {
        v68 = (7 * *(__int16 *)(a1 + 140) + (unsigned __int16)v68) >> 3;
        *(_WORD *)(a1 + 140) = v68;
        v69 = v68 << 16;
        if ((int)(v68 << 16) < 1)
          goto LABEL_88;
      }
      v70 = ((2500 - (unsigned __int16)v68) >> 5) + 178;
      if (v69 >> 18 >= 0x271)
        v70 = 178;
      v71 = *(_DWORD *)(a1 + 12);
      v72 = a6[2];
      v73 = a6[1] - v71;
      v74 = (v73 >> 8) * v70;
      v75 = v73 <= 0x800000;
      v76 = (int)(v73 * v70) >> 8;
      if (!v75)
        v76 = v74;
      a6[1] = v76 + v71;
      v77 = *(_DWORD *)(a1 + 12);
      v78 = v72 - v77;
      v79 = ((v72 - v77) >> 8) * v70;
      if (v78 <= 0x800000)
        v80 = (int)(v78 * v70) >> 8;
      else
        v80 = v79;
      a6[2] = v80 + v77;
      v81 = *(_DWORD *)(a1 + 12);
      v82 = a6[4];
      v83 = a6[3] - v81;
      v84 = (v83 >> 8) * v70;
      v75 = v83 <= 0x800000;
      v85 = (int)(v83 * v70) >> 8;
      if (!v75)
        v85 = v84;
      a6[3] = v85 + v81;
      v86 = *(_DWORD *)(a1 + 12);
      v87 = v82 - v86;
      v88 = ((v82 - v86) >> 8) * v70;
      if (v87 <= 0x800000)
        v89 = (int)(v87 * v70) >> 8;
      else
        v89 = v88;
      a6[4] = v89 + v86;
      v90 = *(_DWORD *)(a1 + 12);
      v91 = a6[6];
      v92 = a6[5] - v90;
      v93 = (v92 >> 8) * v70;
      v75 = v92 <= 0x800000;
      v94 = (int)(v92 * v70) >> 8;
      if (!v75)
        v94 = v93;
      a6[5] = v94 + v90;
      v95 = *(_DWORD *)(a1 + 12);
      v96 = v91 - v95;
      v97 = ((v91 - v95) >> 8) * v70;
      if (v96 <= 0x800000)
        v98 = (int)(v96 * v70) >> 8;
      else
        v98 = v97;
      a6[6] = v98 + v95;
      v99 = *(_DWORD *)(a1 + 12);
      v100 = a6[8];
      v101 = a6[7] - v99;
      v102 = (v101 >> 8) * v70;
      v75 = v101 <= 0x800000;
      v103 = (int)(v101 * v70) >> 8;
      if (!v75)
        v103 = v102;
      a6[7] = v103 + v99;
      v104 = *(_DWORD *)(a1 + 12);
      v105 = v100 - v104;
      v106 = ((v100 - v104) >> 8) * v70;
      if (v105 <= 0x800000)
        v107 = (int)(v105 * v70) >> 8;
      else
        v107 = v106;
      a6[8] = v107 + v104;
      v108 = *(_DWORD *)(a1 + 12);
      v109 = a6[10];
      v110 = a6[9] - v108;
      v111 = (v110 >> 8) * v70;
      v75 = v110 <= 0x800000;
      v112 = (int)(v110 * v70) >> 8;
      if (!v75)
        v112 = v111;
      a6[9] = v112 + v108;
      v113 = *(_DWORD *)(a1 + 12);
      v114 = v109 - v113;
      v115 = ((v109 - v113) >> 8) * v70;
      v116 = (int)(v114 * v70) >> 8;
      if (v114 > 0x800000)
        v116 = v115;
      a6[10] = v116 + v113;
LABEL_88:
      v117 = 0;
      do
      {
        v118 = v134[v117++];
        v119 = a6[v117];
        v120 = 16 - (unsigned __int16)(__clz(v119) - 1);
        if (v119 <= 47452159)
          v120 = 10;
        v122 = (v118 >> 12) + 1;
        v123 = 0x7FFFu >> (2 * v120 - 22);
        if (v120 < 12)
          v123 = 0x7FFF << (22 - 2 * v120);
        v121 = ((v119 >> v120) + 1) * ((v119 >> v120) + 1);
        if ((int)((v121 >> 13) * v122 + ((int)((v121 & 0x1FFF) * v122) >> 13)) > v123)
        {
          do
          {
            if (v119 >= 0x800000)
              v119 = 253 * (v119 >> 8);
            else
              v119 = 253 * v119 / 256;
            v124 = ((v119 >> v120) + 1) * ((v119 >> v120) + 1);
          }
          while ((int)((v124 >> 13) * v122 + ((int)((v124 & 0x1FFF) * v122) >> 13)) > v123);
          a6[v117] = v119;
        }
      }
      while (v117 != 10);
      v125 = a6[2];
      if (a6[1] > v125)
      {
        a6[1] = v125;
        v126 = a6[3];
        if (v125 <= v126)
        {
LABEL_102:
          v127 = a6[4];
          if (v126 <= v127)
            goto LABEL_103;
          goto LABEL_114;
        }
      }
      else
      {
        v126 = a6[3];
        if (v125 <= v126)
          goto LABEL_102;
      }
      a6[2] = v126;
      v127 = a6[4];
      if (v126 <= v127)
      {
LABEL_103:
        v128 = a6[5];
        if (v127 <= v128)
          goto LABEL_104;
        goto LABEL_115;
      }
LABEL_114:
      a6[3] = v127;
      v128 = a6[5];
      if (v127 <= v128)
      {
LABEL_104:
        v129 = a6[6];
        if (v128 <= v129)
          goto LABEL_105;
        goto LABEL_116;
      }
LABEL_115:
      a6[4] = v128;
      v129 = a6[6];
      if (v128 <= v129)
      {
LABEL_105:
        v130 = a6[7];
        if (v129 <= v130)
          goto LABEL_106;
        goto LABEL_117;
      }
LABEL_116:
      a6[5] = v129;
      v130 = a6[7];
      if (v129 <= v130)
      {
LABEL_106:
        v131 = a6[8];
        if (v130 <= v131)
          goto LABEL_107;
        goto LABEL_118;
      }
LABEL_117:
      a6[6] = v130;
      v131 = a6[8];
      if (v130 <= v131)
      {
LABEL_107:
        v132 = a6[9];
        if (v131 <= v132)
          goto LABEL_108;
        goto LABEL_119;
      }
LABEL_118:
      a6[7] = v131;
      v132 = a6[9];
      if (v131 <= v132)
      {
LABEL_108:
        v133 = a6[10];
        if (v132 <= v133)
        {
LABEL_110:
          result = 0;
          *(_DWORD *)(a1 + 8) = v133;
          return result;
        }
LABEL_109:
        a6[9] = v133;
        goto LABEL_110;
      }
LABEL_119:
      a6[8] = v132;
      v133 = a6[10];
      if (v132 <= v133)
        goto LABEL_110;
      goto LABEL_109;
    }
    if (a4 != 16000)
      return result;
LABEL_7:
    v11 = 0;
    v12 = 16;
    goto LABEL_9;
  }
  if (a4 == 48000 || a4 == 32000)
    goto LABEL_7;
  return result;
}

BOOL webrtc::rtcp::Dlrr::Parse(webrtc::rtcp::Dlrr *this, const unsigned __int8 *a2, int a3)
{
  unint64_t v3;
  __int16 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v14;
  _DWORD *v15;
  unint64_t v16;
  unsigned int *v17;

  v3 = (43691 * a3) >> 17;
  v4 = (unsigned __int16)a3 % 3u;
  if ((unsigned __int16)a3 % 3u)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/dlrr.cc");
  }
  else
  {
    v14 = *(_DWORD **)this;
    v15 = (_DWORD *)*((_QWORD *)this + 1);
    v16 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v15 - *(_QWORD *)this) >> 2);
    if (v3 <= v16)
    {
      if (v3 < v16)
      {
        v15 = &v14[3 * v3];
        *((_QWORD *)this + 1) = v15;
      }
    }
    else
    {
      std::vector<webrtc::rtcp::ReceiveTimeInfo>::__append((void **)this, v3 - v16);
      v14 = *(_DWORD **)this;
      v15 = (_DWORD *)*((_QWORD *)this + 1);
    }
    if (v14 != v15)
    {
      v17 = (unsigned int *)(a2 + 4);
      do
      {
        *v14 = bswap32(*v17);
        v14[1] = bswap32(v17[1]);
        v14[2] = bswap32(v17[2]);
        v17 += 3;
        v14 += 3;
      }
      while (v14 != v15);
    }
  }
  return v4 == 0;
}

void std::vector<webrtc::rtcp::ReceiveTimeInfo>::__append(void **a1, unint64_t a2)
{
  _BYTE *v4;
  char *v5;
  char *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  int v18;
  void *v19;

  v5 = (char *)a1[1];
  v4 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - v5) >> 2) < a2)
  {
    v6 = (char *)*a1;
    v7 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (_BYTE *)*a1) >> 2);
    v8 = v7 + a2;
    if (v7 + a2 <= 0x1555555555555555)
    {
      v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v6) >> 2);
      if (2 * v9 > v8)
        v8 = 2 * v9;
      if (v9 >= 0xAAAAAAAAAAAAAAALL)
        v10 = 0x1555555555555555;
      else
        v10 = v8;
      if (v10)
      {
        if (v10 > 0x1555555555555555)
          std::__throw_bad_array_new_length[abi:sn180100]();
        v11 = (char *)operator new(12 * v10);
      }
      else
      {
        v11 = 0;
      }
      v13 = &v11[12 * v7];
      v14 = &v11[12 * v10];
      v15 = &v13[12 * a2];
      v16 = v13;
      do
      {
        if (!v16)
          goto LABEL_27;
        *(_QWORD *)v16 = 0;
        *((_DWORD *)v16 + 2) = 0;
        v16 += 12;
      }
      while (v16 != v15);
      while (v5 != v6)
      {
        v17 = *(_QWORD *)(v5 - 12);
        v5 -= 12;
        v18 = *((_DWORD *)v5 + 2);
        *(_QWORD *)(v13 - 12) = v17;
        v13 -= 12;
        *((_DWORD *)v13 + 2) = v18;
      }
      v19 = *a1;
      *a1 = v13;
      a1[1] = v15;
      a1[2] = v14;
      if (v19)
        operator delete(v19);
      return;
    }
LABEL_28:
    abort();
  }
  if (!a2)
    goto LABEL_16;
  v12 = &v5[12 * a2];
  do
  {
    if (!v5)
    {
LABEL_27:
      __break(1u);
      goto LABEL_28;
    }
    *(_QWORD *)v5 = 0;
    *((_DWORD *)v5 + 2) = 0;
    v5 += 12;
  }
  while (v5 != v12);
  v5 = v12;
LABEL_16:
  a1[1] = v5;
}

uint64_t webrtc::DominantNearendDetector::Update(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8;
  unint64_t v9;
  float *v10;
  float *v11;
  float *i;
  float v13;
  float v14;
  float v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  BOOL v25;
  char v26;
  int v27;
  char v28;

  *(_BYTE *)(result + 40) = 0;
  v8 = *(_QWORD *)(result + 32);
  if (v8)
  {
    v9 = 0;
    v10 = (float *)(a2 + 32);
    v11 = (float *)(a4 + 32);
    for (i = (float *)(a6 + 32); ; i += 65)
    {
      v13 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(v10 - 7) + 0.0) + *(v10 - 6)) + *(v10 - 5))
                                                                                                  + *(v10 - 4))
                                                                                          + *(v10 - 3))
                                                                                  + *(v10 - 2))
                                                                          + *(v10 - 1))
                                                                  + *v10)
                                                          + v10[1])
                                                  + v10[2])
                                          + v10[3])
                                  + v10[4])
                          + v10[5])
                  + v10[6])
          + v10[7];
      v14 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(v11 - 7) + 0.0) + *(v11 - 6)) + *(v11 - 5))
                                                                                                  + *(v11 - 4))
                                                                                          + *(v11 - 3))
                                                                                  + *(v11 - 2))
                                                                          + *(v11 - 1))
                                                                  + *v11)
                                                          + v11[1])
                                                  + v11[2])
                                          + v11[3])
                                  + v11[4])
                          + v11[5])
                  + v11[6])
          + v11[7];
      v15 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(i - 7) + 0.0) + *(i - 6)) + *(i - 5))
                                                                                                  + *(i - 4))
                                                                                          + *(i - 3))
                                                                                  + *(i - 2))
                                                                          + *(i - 1))
                                                                  + *i)
                                                          + i[1])
                                                  + i[2])
                                          + i[3])
                                  + i[4])
                          + i[5])
                  + i[6])
          + i[7];
      if (a8)
      {
        if (!*(_BYTE *)(result + 28))
          break;
      }
      if (v14 >= (float)(v13 * *(float *)(result + 8)) || v13 <= (float)(v15 * *(float *)(result + 16)))
        break;
      v16 = *(_QWORD *)(result + 48);
      if (v9 >= (*(_QWORD *)(result + 56) - v16) >> 2)
        goto LABEL_30;
      v17 = *(_DWORD *)(v16 + 4 * v9) + 1;
      *(_DWORD *)(v16 + 4 * v9) = v17;
      if (v17 >= *(_DWORD *)(result + 24))
      {
        v18 = *(_QWORD *)(result + 72);
        if (v9 >= (*(_QWORD *)(result + 80) - v18) >> 2)
          goto LABEL_30;
        *(_DWORD *)(v18 + 4 * v9) = *(_DWORD *)(result + 20);
        v19 = *(_DWORD *)(result + 24);
LABEL_15:
        *(_DWORD *)(v16 + 4 * v9) = v19;
      }
      if (v14 <= (float)(v13 * *(float *)(result + 12)))
      {
        v21 = *(_QWORD *)(result + 72);
        v22 = *(_QWORD *)(result + 80);
      }
      else
      {
        v21 = *(_QWORD *)(result + 72);
        v22 = *(_QWORD *)(result + 80);
        if (v14 > (float)(v15 * *(float *)(result + 16)))
        {
          if (v9 >= (v22 - v21) >> 2)
            goto LABEL_30;
          *(_DWORD *)(v21 + 4 * v9) = 0;
        }
      }
      if (v9 >= (v22 - v21) >> 2)
      {
LABEL_30:
        __break(1u);
        return result;
      }
      v23 = *(_DWORD *)(v21 + 4 * v9);
      v24 = *(_BYTE *)(result + 40) != 0;
      v25 = __OFSUB__(v23, 1);
      v27 = v23 - 1;
      v26 = (v27 < 0) ^ v25 | (v27 == 0);
      if (v26)
        v27 = 0;
      *(_DWORD *)(v21 + 4 * v9) = v27;
      if (v26)
        v28 = v24;
      else
        v28 = 1;
      ++v9;
      *(_BYTE *)(result + 40) = v28;
      v10 += 65;
      v11 += 65;
      if (v8 == v9)
        return result;
    }
    v16 = *(_QWORD *)(result + 48);
    if (v9 >= (*(_QWORD *)(result + 56) - v16) >> 2)
      goto LABEL_30;
    v20 = *(_DWORD *)(v16 + 4 * v9);
    if (v20 <= 1)
      v20 = 1;
    v19 = v20 - 1;
    goto LABEL_15;
  }
  return result;
}

void webrtc::DominantNearendDetector::~DominantNearendDetector(webrtc::DominantNearendDetector *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24C0B3228;
  v2 = (void *)*((_QWORD *)this + 9);
  if (v2)
  {
    *((_QWORD *)this + 10) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 6);
  if (v3)
  {
    *((_QWORD *)this + 7) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24C0B3228;
  v2 = (void *)*((_QWORD *)this + 9);
  if (v2)
  {
    *((_QWORD *)this + 10) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 6);
  if (v3)
  {
    *((_QWORD *)this + 7) = v3;
    operator delete(v3);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::DominantNearendDetector::IsNearendState(webrtc::DominantNearendDetector *this)
{
  return *((unsigned __int8 *)this + 40);
}

void WebRtcSpl_DotProductWithScale(uint64_t a1, uint64_t a2, unint64_t a3, char a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int64x2_t v11;
  int32x4_t v12;
  int64x2_t v13;
  const __int16 *v14;
  const __int16 *v15;
  uint64_t v16;
  int64x2_t v17;
  int64x2_t v18;
  int64x2_t v19;
  int64x2_t v20;
  int64x2_t v21;
  int64x2_t v22;
  const __int16 *v23;
  const __int16 *v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int64x2_t v29;
  int64x2_t v30;
  int64x2_t v31;
  int64x2_t v32;
  int64x2_t v33;
  int64x2_t v34;
  int64x2_t v35;
  int64x2_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int64x2_t v41;
  int64x2_t v42;
  int64x2_t v43;
  int64x2_t v44;
  int64x2_t v45;
  int64x2_t v46;
  int64x2_t v47;
  int64x2_t v48;
  int32x4_t v49;
  int32x4_t v50;
  int32x4_t v51;
  int32x4_t v52;
  unint64_t v53;
  __int16 *v54;
  __int16 *v55;
  uint64_t v56;
  int64x2_t v57;
  int64x2_t v58;
  int32x4_t v59;
  uint64_t v60;
  int16x8_t *v61;
  int16x8_t *v62;
  unint64_t v63;
  int64x2_t v64;
  int64x2_t v65;
  int64x2_t v66;
  int64x2_t v67;
  int64x2_t v68;
  int64x2_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int32x4_t v72;
  int32x4_t v73;
  int32x4_t v74;
  int32x4_t v75;
  int32x4_t v76;
  uint64_t v77;
  uint64_t v78;
  __int16 *v79;
  __int16 *v80;
  int v81;
  int v82;
  int v83;
  int16x8x4_t v84;
  int16x8x4_t v85;
  int16x8x4_t v86;
  int16x8x4_t v87;

  v4 = a3 - 4;
  if (a3 < 4)
  {
    v6 = 0;
    v8 = 0;
    v9 = a3;
    if (!a3)
      goto LABEL_19;
LABEL_12:
    if (v9 >= 0x10)
    {
      v56 = v8 + (v9 & 0xFFFFFFFFFFFFFFF0);
      v57 = 0uLL;
      v58 = (int64x2_t)(unint64_t)v6;
      v59 = vnegq_s32(vdupq_n_s32(a4));
      v60 = 2 * v8 + 16;
      v61 = (int16x8_t *)(a1 + v60);
      v62 = (int16x8_t *)(a2 + v60);
      v63 = v9 & 0xFFFFFFFFFFFFFFF0;
      v64 = 0uLL;
      v65 = 0uLL;
      v66 = 0uLL;
      v67 = 0uLL;
      v68 = 0uLL;
      v69 = 0uLL;
      do
      {
        v70 = v61[-1];
        v71 = v62[-1];
        v72 = vmull_s16(*(int16x4_t *)v71.i8, *(int16x4_t *)v70.i8);
        v73 = vshlq_s32(vmull_high_s16(v71, v70), v59);
        v74 = vshlq_s32(v72, v59);
        v75 = vshlq_s32(vmull_high_s16(*v62, *v61), v59);
        v76 = vshlq_s32(vmull_s16(*(int16x4_t *)v62->i8, *(int16x4_t *)v61->i8), v59);
        v65 = vaddw_high_s32(v65, v73);
        v64 = vaddw_s32(v64, *(int32x2_t *)v73.i8);
        v57 = vaddw_high_s32(v57, v74);
        v58 = vaddw_s32(v58, *(int32x2_t *)v74.i8);
        v69 = vaddw_high_s32(v69, v75);
        v68 = vaddw_s32(v68, *(int32x2_t *)v75.i8);
        v67 = vaddw_high_s32(v67, v76);
        v66 = vaddw_s32(v66, *(int32x2_t *)v76.i8);
        v61 += 2;
        v62 += 2;
        v63 -= 16;
      }
      while (v63);
      v6 = vaddvq_s64(vaddq_s64(vaddq_s64(vaddq_s64(v66, v58), vaddq_s64(v68, v64)), vaddq_s64(vaddq_s64(v67, v57), vaddq_s64(v69, v65))));
      if (v9 == (v9 & 0xFFFFFFFFFFFFFFF0))
LABEL_19:
        __asm { BR              X10 }
    }
    else
    {
      v56 = v8;
    }
    v77 = a3 - v56;
    v78 = 2 * v56;
    v79 = (__int16 *)(a2 + 2 * v56);
    v80 = (__int16 *)(a1 + v78);
    do
    {
      v82 = *v80++;
      v81 = v82;
      v83 = *v79++;
      v6 += (v83 * v81) >> a4;
      --v77;
    }
    while (v77);
    goto LABEL_19;
  }
  if (v4 >= 0x3C)
  {
    v10 = (v4 >> 2) + 1;
    v11 = 0uLL;
    v12 = vnegq_s32(vdupq_n_s32(a4));
    v13 = 0uLL;
    v5 = 4 * (v10 & 0x7FFFFFFFFFFFFFF0);
    v7 = ((v10 & 0x7FFFFFFFFFFFFFF0uLL) >> 4 << 6) | 3;
    v14 = (const __int16 *)(a1 + 64);
    v15 = (const __int16 *)(a2 + 64);
    v16 = v10 & 0x7FFFFFFFFFFFFFF0;
    v17 = 0uLL;
    v18 = 0uLL;
    v19 = 0uLL;
    v20 = 0uLL;
    v21 = 0uLL;
    v22 = 0uLL;
    do
    {
      v23 = v14 - 32;
      v84 = vld4q_s16(v23);
      v85 = vld4q_s16(v14);
      v24 = v15 - 32;
      v86 = vld4q_s16(v24);
      v87 = vld4q_s16(v15);
      v25 = vshlq_s32(vmull_s16(*(int16x4_t *)v86.val[0].i8, *(int16x4_t *)v84.val[0].i8), v12);
      v26 = vshlq_s32(vmull_high_s16(v86.val[0], v84.val[0]), v12);
      v27 = vshlq_s32(vmull_s16(*(int16x4_t *)v87.val[0].i8, *(int16x4_t *)v85.val[0].i8), v12);
      v28 = vshlq_s32(vmull_high_s16(v87.val[0], v85.val[0]), v12);
      v29 = vaddw_s32(v11, *(int32x2_t *)v25.i8);
      v30 = vaddw_high_s32(v13, v25);
      v31 = vaddw_s32(v17, *(int32x2_t *)v26.i8);
      v32 = vaddw_high_s32(v18, v26);
      v33 = vaddw_s32(v19, *(int32x2_t *)v27.i8);
      v34 = vaddw_high_s32(v20, v27);
      v35 = vaddw_s32(v21, *(int32x2_t *)v28.i8);
      v36 = vaddw_high_s32(v22, v28);
      v37 = vshlq_s32(vmull_high_s16(v86.val[1], v84.val[1]), v12);
      v38 = vshlq_s32(vmull_s16(*(int16x4_t *)v86.val[1].i8, *(int16x4_t *)v84.val[1].i8), v12);
      v39 = vshlq_s32(vmull_high_s16(v87.val[1], v85.val[1]), v12);
      v40 = vshlq_s32(vmull_s16(*(int16x4_t *)v87.val[1].i8, *(int16x4_t *)v85.val[1].i8), v12);
      v41 = vaddw_high_s32(v32, v37);
      v42 = vaddw_s32(v31, *(int32x2_t *)v37.i8);
      v43 = vaddw_high_s32(v30, v38);
      v44 = vaddw_s32(v29, *(int32x2_t *)v38.i8);
      v45 = vaddw_high_s32(v36, v39);
      v46 = vaddw_s32(v35, *(int32x2_t *)v39.i8);
      v47 = vaddw_high_s32(v34, v40);
      v48 = vaddw_s32(v33, *(int32x2_t *)v40.i8);
      v49 = vshlq_s32(vmull_s16(*(int16x4_t *)v86.val[2].i8, *(int16x4_t *)v84.val[2].i8), v12);
      v50 = vshlq_s32(vmull_high_s16(v86.val[2], v84.val[2]), v12);
      v51 = vshlq_s32(vmull_s16(*(int16x4_t *)v87.val[2].i8, *(int16x4_t *)v85.val[2].i8), v12);
      v52 = vshlq_s32(vmull_high_s16(v87.val[2], v85.val[2]), v12);
      v84.val[0] = (int16x8_t)vshlq_s32(vmull_high_s16(v86.val[3], v84.val[3]), v12);
      v84.val[3] = (int16x8_t)vshlq_s32(vmull_s16(*(int16x4_t *)v86.val[3].i8, *(int16x4_t *)v84.val[3].i8), v12);
      v84.val[2] = (int16x8_t)vshlq_s32(vmull_high_s16(v87.val[3], v85.val[3]), v12);
      v84.val[1] = (int16x8_t)vshlq_s32(vmull_s16(*(int16x4_t *)v87.val[3].i8, *(int16x4_t *)v85.val[3].i8), v12);
      v18 = vaddw_high_s32(vaddw_high_s32(v41, v50), (int32x4_t)v84.val[0]);
      v17 = vaddw_s32(vaddw_s32(v42, *(int32x2_t *)v50.i8), *(int32x2_t *)v84.val[0].i8);
      v13 = vaddw_high_s32(vaddw_high_s32(v43, v49), (int32x4_t)v84.val[3]);
      v11 = vaddw_s32(vaddw_s32(v44, *(int32x2_t *)v49.i8), *(int32x2_t *)v84.val[3].i8);
      v22 = vaddw_high_s32(vaddw_high_s32(v45, v52), (int32x4_t)v84.val[2]);
      v21 = vaddw_s32(vaddw_s32(v46, *(int32x2_t *)v52.i8), *(int32x2_t *)v84.val[2].i8);
      v14 += 64;
      v20 = vaddw_high_s32(vaddw_high_s32(v47, v51), (int32x4_t)v84.val[1]);
      v15 += 64;
      v19 = vaddw_s32(vaddw_s32(v48, *(int32x2_t *)v51.i8), *(int32x2_t *)v84.val[1].i8);
      v16 -= 16;
    }
    while (v16);
    v6 = vaddvq_s64(vaddq_s64(vaddq_s64(vaddq_s64(v19, v11), vaddq_s64(v21, v17)), vaddq_s64(vaddq_s64(v20, v13), vaddq_s64(v22, v18))));
    if (v10 == (v10 & 0x7FFFFFFFFFFFFFF0))
    {
LABEL_11:
      v8 = a3 & 0xFFFFFFFFFFFFFFFCLL;
      v9 = a3 - (a3 & 0xFFFFFFFFFFFFFFFCLL);
      if (a3 <= (a3 & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_19;
      goto LABEL_12;
    }
  }
  else
  {
    v5 = 0;
    v6 = 0;
    v7 = 3;
  }
  v53 = v5 + 3;
  v54 = (__int16 *)(2 * v5 + a2 + 2);
  v55 = (__int16 *)(2 * v5 + a1 + 4);
  do
  {
    v6 += ((*(v54 - 1) * *(v55 - 2)) >> a4)
        + (uint64_t)((*v54 * *(v55 - 1)) >> a4)
        + ((v54[1] * *v55) >> a4)
        + ((*(__int16 *)(a2 + 2 * v7) * *(__int16 *)(a1 + 2 * v7)) >> a4);
    v5 += 4;
    v7 = v5 | 3;
    v53 += 4;
    v54 += 4;
    v55 += 4;
  }
  while (v53 < a3);
  goto LABEL_11;
}

uint64_t sub_20859E630()
{
  uint64_t v0;

  return v0;
}

uint64_t sub_20859E648()
{
  return 0x7FFFFFFFLL;
}

uint64_t WebRtcSpl_DownsampleFastC(uint64_t a1, unint64_t a2, _WORD *a3, uint64_t a4, int16x8_t *a5, unint64_t a6, int a7, unint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int16x8_t *v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  int v17;
  int32x4_t v18;
  unint64_t v19;
  int16x8_t *v20;
  int16x8_t *v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int16x8_t v25;
  int8x16_t v26;
  int16x8_t v27;
  int8x16_t v28;
  int16x8_t v29;
  unint64_t v30;
  uint64_t v31;
  __int16 *v32;
  __int16 *v33;
  int v34;
  int v35;
  int v36;

  result = 0xFFFFFFFFLL;
  if (a4)
  {
    if (a6)
    {
      v10 = a7;
      v11 = a8 + (a4 - 1) * a7 + 1;
      if (v11 <= a2)
      {
        if (v11 <= a8)
          return 0;
        v12 = a1 + 2 * a8;
        v13 = (int16x8_t *)(v12 - 14);
        v14 = 2 * a7;
        while (1)
        {
          if (a6 >= 0x10)
          {
            v18 = 0uLL;
            v19 = a6 & 0xFFFFFFFFFFFFFFF0;
            v20 = a5 + 1;
            v21 = v13;
            v22 = (int32x4_t)xmmword_208F08DE0;
            v23 = 0uLL;
            v24 = 0uLL;
            do
            {
              v25 = v20[-1];
              v26 = (int8x16_t)vrev64q_s16(*v21);
              v27 = (int16x8_t)vextq_s8(v26, v26, 8uLL);
              v28 = (int8x16_t)vrev64q_s16(v21[-1]);
              v29 = (int16x8_t)vextq_s8(v28, v28, 8uLL);
              v18 = vmlal_high_s16(v18, v27, v25);
              v22 = vmlal_s16(v22, *(int16x4_t *)v27.i8, *(int16x4_t *)v25.i8);
              v24 = vmlal_high_s16(v24, v29, *v20);
              v23 = vmlal_s16(v23, *(int16x4_t *)v29.i8, *(int16x4_t *)v20->i8);
              v21 -= 2;
              v20 += 2;
              v19 -= 16;
            }
            while (v19);
            v17 = vaddvq_s32(vaddq_s32(vaddq_s32(v23, v22), vaddq_s32(v24, v18)));
            v16 = a6 & 0xFFFFFFFFFFFFFFF0;
            if ((a6 & 0xFFFFFFFFFFFFFFF0) == a6)
              goto LABEL_6;
          }
          else
          {
            v16 = 0;
            v17 = 2048;
          }
          v30 = a6 - v16;
          v31 = 2 * v16;
          v32 = &a5->i16[v16];
          v33 = (__int16 *)(v12 - v31);
          do
          {
            v35 = *v32++;
            v34 = v35;
            v36 = *v33--;
            v17 += v36 * v34;
            --v30;
          }
          while (v30);
LABEL_6:
          v15 = v17 >> 12;
          if (v15 <= -32768)
            v15 = -32768;
          if (v15 >= 0x7FFF)
            LOWORD(v15) = 0x7FFF;
          *a3++ = v15;
          a8 += v10;
          v13 = (int16x8_t *)((char *)v13 + v14);
          v12 += v14;
          if (a8 >= v11)
            return 0;
        }
      }
    }
  }
  return result;
}

void webrtc::DspHelper::PeakDetection(webrtc::DspHelper *this, __int16 *a2, uint64_t a3, __int16 *a4, __int16 *a5, unint64_t *a6, __int16 *a7)
{
  __int16 *v9;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  __int16 *v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  __int16 v21;
  uint64_t *v22;
  unint64_t v23;
  __int16 *v24;
  int v25;
  char *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;

  v9 = a2;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = a3 - 1;
  v15 = a3 == 1;
  v28 = (int)a4;
  v29 = 2 * (int)a4;
  if (a3 == 1)
    v16 = (__int16 *)((char *)a2 + 1);
  else
    v16 = a2;
  v17 = (char *)v16 - 1;
  do
  {
    v9 = (__int16 *)((char *)v9 + v15);
    v18 = 0;
    v19 = (unint64_t)v9 - 1;
    if (v9 != (__int16 *)1)
    {
      v20 = 0;
      v21 = 0x8000;
      do
      {
        if (*((__int16 *)this + v20) > v21)
        {
          v18 = v20;
          v21 = *((_WORD *)this + v20);
        }
        ++v20;
      }
      while (v17 != (char *)v20);
    }
    v22 = (uint64_t *)&a5[4 * v11];
    *v22 = v18;
    v23 = v18 - 2;
    if (v18 < 2)
      v23 = 0;
    if (v18 + 2 < v19)
      v19 = v18 + 2;
    if (v11 != v14)
    {
      v13 = v23;
      v12 = v19;
    }
    v24 = v9 - 1;
    if (!v18 || (__int16 *)v18 == v24)
    {
      v25 = *((__int16 *)this + v18);
      if ((__int16 *)v18 == v24)
      {
        v26 = (char *)this + 2 * v18;
        v27 = *((__int16 *)v26 + 1);
        if (v25 <= v27)
        {
          *((_WORD *)a6 + v11) = (v27 + v25) >> 1;
          *v22 = ((2 * v18) | 1) * v28;
          if (v11 == v14)
            goto LABEL_5;
        }
        else
        {
          webrtc::DspHelper::ParabolicFit((webrtc::DspHelper *)(v26 - 2), a4, v22, (unint64_t *)((char *)a6 + 2 * v11), a5);
          if (v11 == v14)
            goto LABEL_5;
        }
      }
      else
      {
        *((_WORD *)a6 + v11) = v25;
        *v22 = v29 * v18;
        if (v11 == v14)
          goto LABEL_5;
      }
    }
    else
    {
      webrtc::DspHelper::ParabolicFit((webrtc::DspHelper *)((char *)this + 2 * v18 - 2), a4, v22, (unint64_t *)((char *)a6 + 2 * v11), a5);
      if (v11 == v14)
        goto LABEL_5;
    }
    bzero((char *)this + 2 * v13, 2 * (v12 - v13) + 2);
LABEL_5:
    ++v11;
    v17 += v15;
  }
  while (v11 <= v14);
}

uint64_t webrtc::DspHelper::ParabolicFit(webrtc::DspHelper *this, __int16 *a2, uint64_t *a3, unint64_t *a4, __int16 *a5)
{
  __int16 v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned __int16 *v14;
  int v15;
  int v16;
  int v17;
  BOOL v18;
  int v19;
  int v20;
  int v21;
  uint64_t result;
  unsigned int v23;
  __int16 *v24;
  uint64_t v25;
  unsigned int v26;
  __int16 v27;
  __int16 *v28;
  __int128 v29;
  int v30;
  __int16 v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  switch((_DWORD)a2)
  {
    case 4:
      *(_QWORD *)&v29 = 0x6000400020000;
      DWORD2(v29) = 655368;
      WORD6(v29) = 12;
      v5 = 14;
      v6 = 8;
      v7 = 7;
      break;
    case 2:
      LODWORD(v29) = 0x40000;
      WORD2(v29) = 8;
      v5 = 12;
      v6 = 4;
      v7 = 3;
      break;
    case 1:
      LOWORD(v29) = 0;
      v5 = 8;
      v6 = 2;
      v7 = 1;
      break;
    default:
      v29 = xmmword_208F08E00;
      v30 = 786443;
      v31 = 13;
      v5 = 15;
      v6 = 12;
      v7 = 11;
      break;
  }
  *((_WORD *)&v29 + v7) = v5;
  *((_WORD *)&v29 + v6) = 16;
  v8 = *(__int16 *)this;
  v9 = *((__int16 *)this + 1);
  v10 = *((__int16 *)this + 2);
  v11 = -3 * v8 + 4 * v9 - v10;
  v12 = v8 - 2 * v9 + v10;
  v13 = 120 * v11;
  v14 = (unsigned __int16 *)&v29 + (int)a2;
  v15 = webrtc::DspHelper::kParabolaCoefficients[3 * *v14];
  v16 = webrtc::DspHelper::kParabolaCoefficients[3 * *(v14 - 1)];
  v17 = v15 - v16;
  v18 = __OFADD__(v16, v15);
  v19 = v16 + v15;
  if (v19 < 0 != v18)
    ++v19;
  v20 = v19 >> 1;
  v21 = -v12;
  result = -(v12 * v20);
  if (v13 >= (int)result)
  {
    result = (__int16)v17;
    if (v13 <= (v20 + (int)result) * v21)
    {
      *(_WORD *)a4 = v9;
      v25 = 2 * (int)a2 * *a3;
    }
    else
    {
      if ((_DWORD)a2 == 1)
      {
        v26 = 1;
      }
      else
      {
        v27 = v20 + 2 * v17;
        v26 = 1;
        while (1)
        {
          result = (v27 * v21);
          if (v13 < (int)result)
            break;
          ++v26;
          v27 += v17;
          if ((_DWORD)a2 == v26)
          {
            v26 = a2;
            break;
          }
        }
      }
      v28 = &webrtc::DspHelper::kParabolaCoefficients[3 * *((unsigned __int16 *)&v29 + (int)(v26 + (_DWORD)a2))];
      *(_WORD *)a4 = (v12 * v28[1] + (v8 << 8) + v11 * v28[2]) / 256;
      v25 = 2 * (int)a2 * *a3 + v26;
    }
  }
  else
  {
    v23 = 1;
    if ((_DWORD)a2 != 1)
    {
      while (1)
      {
        v20 -= v17;
        result = ((__int16)v20 * v21);
        if (v13 > (int)result)
          break;
        if ((_DWORD)a2 == ++v23)
        {
          v23 = a2;
          break;
        }
      }
    }
    v24 = &webrtc::DspHelper::kParabolaCoefficients[3 * *((unsigned __int16 *)&v29 + (int)((_DWORD)a2 - v23))];
    *(_WORD *)a4 = (v12 * v24[1] + (v8 << 8) + v11 * v24[2]) / 256;
    v25 = 2 * (int)a2 * *a3 - v23;
  }
  *a3 = v25;
  return result;
}

void webrtc::DtlsSrtpTransport::SetDtlsTransports(webrtc::DtlsSrtpTransport *this, cricket::DtlsTransportInternal *a2, cricket::DtlsTransportInternal *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  std::string *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  std::string v34;

  if ((*(unsigned int (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)this + 96))(this)
    && (*((cricket::DtlsTransportInternal **)this + 82) != a2 || *((_BYTE *)this + 736)))
  {
    webrtc::SrtpTransport::ResetParams(this);
  }
  if (a2)
  {
    v12 = (*(uint64_t (**)(cricket::DtlsTransportInternal *))(*(_QWORD *)a2 + 16))(a2);
    if (*(char *)(v12 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v34, *(const std::string::value_type **)v12, *(_QWORD *)(v12 + 8));
      if (!a3)
        goto LABEL_18;
    }
    else
    {
      v13 = *(_OWORD *)v12;
      v34.__r_.__value_.__r.__words[2] = *(_QWORD *)(v12 + 16);
      *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v13;
      if (!a3)
        goto LABEL_18;
    }
  }
  else
  {
    *((_BYTE *)&v34.__r_.__value_.__s + 23) = 4;
    if (&v34 <= (std::string *)"null" && (char *)v34.__r_.__value_.__r.__words + 4 > "null")
    {
      __break(1u);
LABEL_44:
      v26 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtls_srtp_transport.cc", 59, "!(IsSrtpActive())", "\t", v8, v9, v10, v11, (uint64_t)"Setting RTCP for DTLS/SRTP after the DTLS is active should never happen.");
      webrtc::DtlsSrtpTransport::SetRtcpMuxEnabled((webrtc::DtlsSrtpTransport *)v26, v27, v28, v29, v30, v31, v32, v33);
      return;
    }
    strcpy((char *)&v34, "null");
    if (!a3)
      goto LABEL_18;
  }
  if (*((cricket::DtlsTransportInternal **)this + 83) != a3
    && (*(unsigned int (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)this + 96))(this))
  {
    goto LABEL_44;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)12,void const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)12,void const*> const&)::t, v14, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtls_srtp_transport.cc");
LABEL_18:
  v15 = *((_QWORD *)this + 83);
  if ((cricket::DtlsTransportInternal *)v15 != a3)
  {
    if (v15)
      webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(v15 + 440), this);
    *((_QWORD *)this + 83) = a3;
    if (a3)
      webrtc::callback_list_impl::CallbackListReceivers::AddReceiver<webrtc::UntypedFunction::TrivialUntypedFunctionArgs<1ul>>((char *)a3 + 440, (uint64_t)this, (uint64_t)this, (uint64_t)webrtc::webrtc_function_impl::CallHelpers<void ()(cricket::DtlsTransportInternal *,webrtc::DtlsTransportState)>::CallInlineStorage<webrtc::DtlsSrtpTransport::SetDtlsTransport(cricket::DtlsTransportInternal *,cricket::DtlsTransportInternal **)::$_0>, v8, v9, v10, v11);
  }
  webrtc::RtpTransport::SetRtcpPacketTransport(this, a3, v6, v7, v8, v9, v10, v11);
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)12,void const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)12,void const*> const&)::t, v16, v17, v18, v19, v20, v21, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtls_srtp_transport.cc");
  v23 = *((_QWORD *)this + 82);
  if ((cricket::DtlsTransportInternal *)v23 != a2)
  {
    if (v23)
      webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(v23 + 440), this);
    *((_QWORD *)this + 82) = a2;
    if (a2)
      webrtc::callback_list_impl::CallbackListReceivers::AddReceiver<webrtc::UntypedFunction::TrivialUntypedFunctionArgs<1ul>>((char *)a2 + 440, (uint64_t)this, (uint64_t)this, (uint64_t)webrtc::webrtc_function_impl::CallHelpers<void ()(cricket::DtlsTransportInternal *,webrtc::DtlsTransportState)>::CallInlineStorage<webrtc::DtlsSrtpTransport::SetDtlsTransport(cricket::DtlsTransportInternal *,cricket::DtlsTransportInternal **)::$_0>, v19, v20, v21, v22);
  }
  webrtc::RtpTransport::SetRtpPacketTransport(this, a2, v17, v18, v19, v20, v21, v22);
  if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)this + 96))(this) & 1) != 0)
    goto LABEL_41;
  if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)this + 48))(this) & 1) == 0)
  {
    v24 = *((_QWORD *)this + 83);
    v25 = *((_QWORD *)this + 82);
    if (!v25)
      goto LABEL_41;
LABEL_35:
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v25 + 24))(v25)
      && (!v24 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v24 + 24))(v24)))
    {
      webrtc::DtlsSrtpTransport::SetupRtpDtlsSrtp(this);
      if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)this + 48))(this) & 1) == 0
        && *((_QWORD *)this + 83))
      {
        webrtc::DtlsSrtpTransport::SetupRtcpDtlsSrtp(this);
      }
    }
    goto LABEL_41;
  }
  v24 = 0;
  v25 = *((_QWORD *)this + 82);
  if (v25)
    goto LABEL_35;
LABEL_41:
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
}

void webrtc::DtlsSrtpTransport::SetRtcpMuxEnabled(webrtc::DtlsSrtpTransport *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v10;
  uint64_t v11;

  v8 = a2;
  *((_BYTE *)this + 248) = a2;
  webrtc::RtpTransport::MaybeSignalReadyToSend(this, a2, a3, a4, a5, a6, a7, a8);
  if (v8 && ((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)this + 96))(this) & 1) == 0)
  {
    if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)this + 48))(this) & 1) != 0)
    {
      v10 = 0;
      v11 = *((_QWORD *)this + 82);
      if (!v11)
        return;
    }
    else
    {
      v10 = *((_QWORD *)this + 83);
      v11 = *((_QWORD *)this + 82);
      if (!v11)
        return;
    }
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11)
      && (!v10 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10)))
    {
      webrtc::DtlsSrtpTransport::SetupRtpDtlsSrtp(this);
      if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)this + 48))(this) & 1) == 0)
      {
        if (*((_QWORD *)this + 83))
          webrtc::DtlsSrtpTransport::SetupRtcpDtlsSrtp(this);
      }
    }
  }
}

void webrtc::DtlsSrtpTransport::UpdateSendEncryptedHeaderExtensionIds(webrtc::DtlsSrtpTransport *a1, uint64_t a2)
{
  void *v4;
  size_t v5;
  const void *v6;
  const void *v7;
  int64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (*((_BYTE *)a1 + 696))
  {
    v4 = (void *)*((_QWORD *)a1 + 84);
    v5 = *((_QWORD *)a1 + 85) - (_QWORD)v4;
    v6 = *(const void **)a2;
    if (v5 == *(_QWORD *)(a2 + 8) - *(_QWORD *)a2 && !memcmp(*((const void **)a1 + 84), v6, v5))
      return;
    if (v4)
    {
      *((_QWORD *)a1 + 85) = v4;
      operator delete(v4);
    }
    *((_BYTE *)a1 + 696) = 0;
  }
  *((_QWORD *)a1 + 84) = 0;
  *((_QWORD *)a1 + 85) = 0;
  *((_QWORD *)a1 + 86) = 0;
  v7 = *(const void **)a2;
  v8 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  if (v8)
  {
    if (v8 < 0)
      abort();
    v9 = (char *)operator new(v8);
    *((_QWORD *)a1 + 84) = v9;
    *((_QWORD *)a1 + 85) = v9;
    v10 = &v9[4 * (v8 >> 2)];
    *((_QWORD *)a1 + 86) = v10;
    memcpy(v9, v7, v8);
    *((_QWORD *)a1 + 85) = v10;
  }
  *((_BYTE *)a1 + 696) = 1;
  if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)a1 + 48))(a1) & 1) != 0)
  {
    v11 = 0;
    v12 = *((_QWORD *)a1 + 82);
    if (!v12)
      return;
  }
  else
  {
    v11 = *((_QWORD *)a1 + 83);
    v12 = *((_QWORD *)a1 + 82);
    if (!v12)
      return;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v12 + 96))(v12)
    && (!v11 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 96))(v11)))
  {
    if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)a1 + 48))(a1) & 1) != 0)
    {
      v13 = 0;
      v14 = *((_QWORD *)a1 + 82);
      if (!v14)
        return;
    }
    else
    {
      v13 = *((_QWORD *)a1 + 83);
      v14 = *((_QWORD *)a1 + 82);
      if (!v14)
        return;
    }
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v14 + 80))(v14) == 2
      && (!v13 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v13 + 80))(v13) == 2))
    {
      webrtc::DtlsSrtpTransport::SetupRtpDtlsSrtp(a1);
    }
  }
}

void webrtc::DtlsSrtpTransport::SetupRtpDtlsSrtp(webrtc::DtlsSrtpTransport *this)
{
  char v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  size_t v13;
  void *v14;
  uint64_t v15;
  size_t v16;
  void *v17;
  int v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  uint64_t v24;

  v22 = 0;
  v23 = 0;
  v24 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  if (&v22 != (void **)((char *)this + 672) && *((_BYTE *)this + 696))
    std::vector<int>::__assign_with_size[abi:sn180100]<int *,int *>(&v22, *((char **)this + 84), *((char **)this + 85), (uint64_t)(*((_QWORD *)this + 85) - *((_QWORD *)this + 84)) >> 2);
  if (&v19 != (void **)((char *)this + 704) && *((_BYTE *)this + 728))
    std::vector<int>::__assign_with_size[abi:sn180100]<int *,int *>(&v19, *((char **)this + 88), *((char **)this + 89), (uint64_t)(*((_QWORD *)this + 89) - *((_QWORD *)this + 88)) >> 2);
  v18 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if (!webrtc::DtlsSrtpTransport::ExtractParams(*((_QWORD *)this + 82), &v18, (uint64_t)&v15, (uint64_t)&v12)|| (webrtc::SrtpTransport::SetRtpParams((uint64_t)this, v18, (uint64_t)v17, v15, (uint64_t *)&v22, v18, (uint64_t)v14, v12, (uint64_t *)&v19), (v2 & 1) == 0))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtls_srtp_transport.cc");
  }
  if (v13)
    bzero(v14, v13);
  v10 = v14;
  v14 = 0;
  if (v10)
    MEMORY[0x20BD0ADD4](v10, 0x1000C8077774924);
  if (v16)
    bzero(v17, v16);
  v11 = v17;
  v17 = 0;
  if (v11)
    MEMORY[0x20BD0ADD4](v11, 0x1000C8077774924);
  if (v19)
  {
    v20 = v19;
    operator delete(v19);
  }
  if (v22)
  {
    v23 = v22;
    operator delete(v22);
  }
}

void webrtc::DtlsSrtpTransport::UpdateRecvEncryptedHeaderExtensionIds(webrtc::DtlsSrtpTransport *a1, uint64_t a2)
{
  void *v4;
  size_t v5;
  const void *v6;
  const void *v7;
  int64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (*((_BYTE *)a1 + 728))
  {
    v4 = (void *)*((_QWORD *)a1 + 88);
    v5 = *((_QWORD *)a1 + 89) - (_QWORD)v4;
    v6 = *(const void **)a2;
    if (v5 == *(_QWORD *)(a2 + 8) - *(_QWORD *)a2 && !memcmp(*((const void **)a1 + 88), v6, v5))
      return;
    if (v4)
    {
      *((_QWORD *)a1 + 89) = v4;
      operator delete(v4);
    }
    *((_BYTE *)a1 + 728) = 0;
  }
  *((_QWORD *)a1 + 88) = 0;
  *((_QWORD *)a1 + 89) = 0;
  *((_QWORD *)a1 + 90) = 0;
  v7 = *(const void **)a2;
  v8 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  if (v8)
  {
    if (v8 < 0)
      abort();
    v9 = (char *)operator new(v8);
    *((_QWORD *)a1 + 88) = v9;
    *((_QWORD *)a1 + 89) = v9;
    v10 = &v9[4 * (v8 >> 2)];
    *((_QWORD *)a1 + 90) = v10;
    memcpy(v9, v7, v8);
    *((_QWORD *)a1 + 89) = v10;
  }
  *((_BYTE *)a1 + 728) = 1;
  if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)a1 + 48))(a1) & 1) != 0)
  {
    v11 = 0;
    v12 = *((_QWORD *)a1 + 82);
    if (!v12)
      return;
  }
  else
  {
    v11 = *((_QWORD *)a1 + 83);
    v12 = *((_QWORD *)a1 + 82);
    if (!v12)
      return;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v12 + 96))(v12)
    && (!v11 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 96))(v11)))
  {
    if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)a1 + 48))(a1) & 1) != 0)
    {
      v13 = 0;
      v14 = *((_QWORD *)a1 + 82);
      if (!v14)
        return;
    }
    else
    {
      v13 = *((_QWORD *)a1 + 83);
      v14 = *((_QWORD *)a1 + 82);
      if (!v14)
        return;
    }
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v14 + 80))(v14) == 2
      && (!v13 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v13 + 80))(v13) == 2))
    {
      webrtc::DtlsSrtpTransport::SetupRtpDtlsSrtp(a1);
    }
  }
}

void webrtc::DtlsSrtpTransport::SetupRtcpDtlsSrtp(webrtc::DtlsSrtpTransport *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  size_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;
  void *v16;
  unsigned int v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;

  if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)this + 96))(this) & 1) == 0)
  {
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    if (&v21 != (void **)((char *)this + 672) && *((_BYTE *)this + 696))
      std::vector<int>::__assign_with_size[abi:sn180100]<int *,int *>(&v21, *((char **)this + 84), *((char **)this + 85), (uint64_t)(*((_QWORD *)this + 85) - *((_QWORD *)this + 84)) >> 2);
    if (&v18 != (void **)((char *)this + 704) && *((_BYTE *)this + 728))
      std::vector<int>::__assign_with_size[abi:sn180100]<int *,int *>(&v18, *((char **)this + 88), *((char **)this + 89), (uint64_t)(*((_QWORD *)this + 89) - *((_QWORD *)this + 88)) >> 2);
    v17 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    if ((!webrtc::DtlsSrtpTransport::ExtractParams(*((_QWORD *)this + 83), &v17, (uint64_t)&v14, (uint64_t)&v11)|| (webrtc::SrtpTransport::SetRtcpParams((uint64_t)this, (char *)v17, (uint64_t)v16, v14, (uint64_t *)&v21, v17, (uint64_t)v13, v11, (uint64_t *)&v18) & 1) == 0)&& (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      rtc::webrtc_logging_impl::Log("\r\t", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtls_srtp_transport.cc");
    }
    if (v12)
      bzero(v13, v12);
    v9 = v13;
    v13 = 0;
    if (v9)
      MEMORY[0x20BD0ADD4](v9, 0x1000C8077774924);
    if (v15)
      bzero(v16, v15);
    v10 = v16;
    v16 = 0;
    if (v10)
      MEMORY[0x20BD0ADD4](v10, 0x1000C8077774924);
    if (v18)
    {
      v19 = v18;
      operator delete(v18);
    }
    if (v21)
    {
      v22 = v21;
      operator delete(v21);
    }
  }
}

uint64_t webrtc::DtlsSrtpTransport::ExtractParams(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  size_t v31;
  size_t v32;
  char *v33;
  size_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  char *v50;
  int v52;
  size_t v53;
  size_t v54;
  char *v55;
  size_t v56;
  size_t v57;
  char *v58;

  v4 = a1;
  if (a1)
  {
    if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1))
      return 0;
    if (((*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)v4 + 128))(v4, a2) & 1) == 0)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      {
        rtc::webrtc_logging_impl::Log("\r\t", v23, v24, v25, v26, v27, v28, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtls_srtp_transport.cc");
        return 0;
      }
      return 0;
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v8, v9, v10, v11, v12, v13, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtls_srtp_transport.cc");
    }
    v15 = *a2 - 1;
    if (v15 >= 8 || ((0xC3u >> v15) & 1) == 0)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      {
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)12,void const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)12,void const*> const&)::t, v16, v17, v18, v19, v20, v21, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtls_srtp_transport.cc");
        return 0;
      }
      return 0;
    }
    v30 = 4 * v15;
    v31 = *(unsigned int *)((char *)&unk_208F08EE4 + v30);
    v32 = *(unsigned int *)((char *)&unk_208F08F04 + v30);
    v33 = (char *)operator new[]();
    if (((*(uint64_t (**)(uint64_t, const char *, uint64_t, _QWORD, _QWORD, _QWORD, char *, _QWORD))(*(_QWORD *)v4 + 176))(v4, "EXTRACTOR-dtls_srtp", 19, 0, 0, 0, v33, 2 * (v32 | v31)) & 1) != 0)
    {
      v56 = v32 | v31;
      v57 = v56;
      v58 = (char *)operator new[]();
      v53 = v56;
      v54 = v56;
      v55 = (char *)operator new[]();
      memcpy(v58, v33, v31);
      memcpy(v55, &v33[v31], v31);
      memcpy(&v58[v31], &v33[2 * v31], v32);
      memcpy(&v55[v31], &v33[(2 * v31) | v32], v32);
      v52 = 0;
      v4 = (*(uint64_t (**)(uint64_t, int *))(*(_QWORD *)v4 + 104))(v4, &v52);
      if ((v4 & 1) != 0)
      {
        if (v52 == 1)
        {
          rtc::BufferT<unsigned char,true>::operator=(a3, (uint64_t)&v53);
          v34 = &v56;
        }
        else
        {
          rtc::BufferT<unsigned char,true>::operator=(a3, (uint64_t)&v56);
          v34 = &v53;
        }
        rtc::BufferT<unsigned char,true>::operator=(a4, (uint64_t)v34);
      }
      else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      {
        rtc::webrtc_logging_impl::Log("\r\t", v42, v43, v44, v45, v46, v47, v48, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtls_srtp_transport.cc");
      }
      v49 = v55;
      if (v54)
        bzero(v55, v54);
      if (v49)
        MEMORY[0x20BD0ADD4](v49, 0x1000C8077774924);
      v50 = v58;
      if (v57)
        bzero(v58, v57);
      if (v50)
        MEMORY[0x20BD0ADD4](v50, 0x1000C8077774924);
    }
    else
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log("\r\t", v35, v36, v37, v38, v39, v40, v41, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtls_srtp_transport.cc");
      v4 = 0;
    }
    bzero(v33, 2 * (v32 | v31));
    MEMORY[0x20BD0ADD4](v33, 0x1000C8077774924);
  }
  return v4;
}

uint64_t rtc::BufferT<unsigned char,true>::operator=(uint64_t a1, uint64_t a2)
{
  size_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
    bzero(*(void **)(a1 + 16), v4);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  if (v5)
    MEMORY[0x20BD0ADD4](v5, 0x1000C8077774924);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  return a1;
}

void webrtc::DtlsSrtpTransport::OnWritableState(webrtc::DtlsSrtpTransport *this, rtc::PacketTransportInternal *a2)
{
  uint64_t v3;
  uint64_t v4;

  if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *, rtc::PacketTransportInternal *))(*(_QWORD *)this + 96))(this, a2) & 1) == 0)
  {
    if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)this + 48))(this) & 1) != 0)
    {
      v3 = 0;
      v4 = *((_QWORD *)this + 82);
      if (!v4)
        return;
    }
    else
    {
      v3 = *((_QWORD *)this + 83);
      v4 = *((_QWORD *)this + 82);
      if (!v4)
        return;
    }
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4)
      && (!v3 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3)))
    {
      webrtc::DtlsSrtpTransport::SetupRtpDtlsSrtp(this);
      if (((*(uint64_t (**)(webrtc::DtlsSrtpTransport *))(*(_QWORD *)this + 48))(this) & 1) == 0)
      {
        if (*((_QWORD *)this + 83))
          webrtc::DtlsSrtpTransport::SetupRtcpDtlsSrtp(this);
      }
    }
  }
}

void webrtc::DtlsSrtpTransport::~DtlsSrtpTransport(webrtc::DtlsSrtpTransport *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24C0B3258;
  v2 = (char *)this + 744;
  v3 = (char *)*((_QWORD *)this + 96);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  if (*((_BYTE *)this + 728))
  {
    v5 = (void *)*((_QWORD *)this + 88);
    if (v5)
    {
      *((_QWORD *)this + 89) = v5;
      operator delete(v5);
    }
  }
  if (*((_BYTE *)this + 696))
  {
    v6 = (void *)*((_QWORD *)this + 84);
    if (v6)
    {
      *((_QWORD *)this + 85) = v6;
      operator delete(v6);
    }
  }
  webrtc::SrtpTransport::~SrtpTransport(this);
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24C0B3258;
  v2 = (char *)this + 744;
  v3 = (char *)*((_QWORD *)this + 96);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
    {
LABEL_6:
      if (*((_BYTE *)this + 728))
      {
        v5 = (void *)*((_QWORD *)this + 88);
        if (v5)
        {
          *((_QWORD *)this + 89) = v5;
          operator delete(v5);
        }
      }
      if (*((_BYTE *)this + 696))
      {
        v6 = (void *)*((_QWORD *)this + 84);
        if (v6)
        {
          *((_QWORD *)this + 85) = v6;
          operator delete(v6);
        }
      }
      webrtc::SrtpTransport::~SrtpTransport(this);
      JUMPOUT(0x20BD0ADECLL);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  goto LABEL_6;
}

uint64_t webrtc::RtpTransport::rtcp_mux_enabled(webrtc::RtpTransport *this)
{
  return *((unsigned __int8 *)this + 248);
}

uint64_t webrtc::RtpTransport::IsReadyToSend(webrtc::RtpTransport *this)
{
  return *((unsigned __int8 *)this + 272);
}

void webrtc::SrtpTransport::~SrtpTransport(webrtc::SrtpTransport *this)
{
  size_t v2;
  uint64_t v3;
  size_t v4;
  uint64_t v5;
  cricket::SrtpSession *v6;
  cricket::SrtpSession *v7;
  cricket::SrtpSession *v8;
  cricket::SrtpSession *v9;

  *(_QWORD *)this = &unk_24C0C1128;
  v2 = *((_QWORD *)this + 77);
  if (v2)
    bzero(*((void **)this + 78), v2);
  v3 = *((_QWORD *)this + 78);
  *((_QWORD *)this + 78) = 0;
  if (v3)
    MEMORY[0x20BD0ADD4](v3, 0x1000C8077774924);
  v4 = *((_QWORD *)this + 74);
  if (v4)
    bzero(*((void **)this + 75), v4);
  v5 = *((_QWORD *)this + 75);
  *((_QWORD *)this + 75) = 0;
  if (v5)
    MEMORY[0x20BD0ADD4](v5, 0x1000C8077774924);
  v6 = (cricket::SrtpSession *)*((_QWORD *)this + 70);
  *((_QWORD *)this + 70) = 0;
  if (v6)
  {
    cricket::SrtpSession::~SrtpSession(v6);
    MEMORY[0x20BD0ADEC]();
  }
  v7 = (cricket::SrtpSession *)*((_QWORD *)this + 69);
  *((_QWORD *)this + 69) = 0;
  if (v7)
  {
    cricket::SrtpSession::~SrtpSession(v7);
    MEMORY[0x20BD0ADEC]();
  }
  v8 = (cricket::SrtpSession *)*((_QWORD *)this + 68);
  *((_QWORD *)this + 68) = 0;
  if (v8)
  {
    cricket::SrtpSession::~SrtpSession(v8);
    MEMORY[0x20BD0ADEC]();
  }
  v9 = (cricket::SrtpSession *)*((_QWORD *)this + 67);
  *((_QWORD *)this + 67) = 0;
  if (v9)
  {
    cricket::SrtpSession::~SrtpSession(v9);
    MEMORY[0x20BD0ADEC]();
  }
  if (*((char *)this + 535) < 0)
    operator delete(*((void **)this + 64));
  webrtc::RtpTransport::~RtpTransport(this);
}

{
  webrtc::SrtpTransport::~SrtpTransport(this);
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::RtpTransport::~RtpTransport(webrtc::RtpTransport *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void (*v12)(uint64_t);
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void (*v16)(uint64_t);
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void (*v20)(uint64_t);
  uint64_t v21;
  uint64_t v22;
  void *v23;
  void (*v24)(uint64_t);
  uint64_t v25;
  uint64_t v26;
  void *v27;
  void (*v28)(uint64_t);
  std::string *v29;
  uint64_t v30;

  *(_QWORD *)this = &unk_24C0BE6C8;
  v2 = *((_QWORD *)this + 63);
  *(_BYTE *)(v2 + 4) = 0;
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
    MEMORY[0x20BD0ADEC]();
  webrtc::RtpDemuxer::~RtpDemuxer((webrtc::RtpTransport *)((char *)this + 280));
  *(_QWORD *)this = &unk_24C0B3300;
  if (*((_BYTE *)this + 240))
    goto LABEL_51;
  v9 = *((_QWORD *)this + 27);
  if (v9)
  {
    v10 = *((_QWORD *)this + 28);
    v11 = (void *)*((_QWORD *)this + 27);
    if (v10 != v9)
    {
      do
      {
        v12 = *(void (**)(uint64_t))(v10 - 8);
        if (v12)
          v12(v10 - 48);
        v10 -= 56;
      }
      while (v10 != v9);
      v11 = (void *)*((_QWORD *)this + 27);
    }
    *((_QWORD *)this + 28) = v9;
    operator delete(v11);
  }
  if (*((_BYTE *)this + 208))
    goto LABEL_51;
  v13 = *((_QWORD *)this + 23);
  if (v13)
  {
    v14 = *((_QWORD *)this + 24);
    v15 = (void *)*((_QWORD *)this + 23);
    if (v14 != v13)
    {
      do
      {
        v16 = *(void (**)(uint64_t))(v14 - 8);
        if (v16)
          v16(v14 - 48);
        v14 -= 56;
      }
      while (v14 != v13);
      v15 = (void *)*((_QWORD *)this + 23);
    }
    *((_QWORD *)this + 24) = v13;
    operator delete(v15);
  }
  if (*((_BYTE *)this + 176))
    goto LABEL_51;
  v17 = *((_QWORD *)this + 19);
  if (v17)
  {
    v18 = *((_QWORD *)this + 20);
    v19 = (void *)*((_QWORD *)this + 19);
    if (v18 != v17)
    {
      do
      {
        v20 = *(void (**)(uint64_t))(v18 - 8);
        if (v20)
          v20(v18 - 48);
        v18 -= 56;
      }
      while (v18 != v17);
      v19 = (void *)*((_QWORD *)this + 19);
    }
    *((_QWORD *)this + 20) = v17;
    operator delete(v19);
  }
  (*((void (**)(uint64_t, char *, char *))this + 17))(1, (char *)this + 120, (char *)this + 120);
  if (*((_BYTE *)this + 112))
    goto LABEL_51;
  v21 = *((_QWORD *)this + 11);
  if (v21)
  {
    v22 = *((_QWORD *)this + 12);
    v23 = (void *)*((_QWORD *)this + 11);
    if (v22 != v21)
    {
      do
      {
        v24 = *(void (**)(uint64_t))(v22 - 8);
        if (v24)
          v24(v22 - 48);
        v22 -= 56;
      }
      while (v22 != v21);
      v23 = (void *)*((_QWORD *)this + 11);
    }
    *((_QWORD *)this + 12) = v21;
    operator delete(v23);
  }
  if (*((_BYTE *)this + 80))
  {
LABEL_51:
    v29 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/callback_list.cc", 21, "!send_in_progress_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v5, v6, v7, v8, v30);
    webrtc::RtpTransportInternal::~RtpTransportInternal((webrtc::RtpTransportInternal *)v29);
  }
  v25 = *((_QWORD *)this + 7);
  if (v25)
  {
    v26 = *((_QWORD *)this + 8);
    v27 = (void *)*((_QWORD *)this + 7);
    if (v26 != v25)
    {
      do
      {
        v28 = *(void (**)(uint64_t))(v26 - 8);
        if (v28)
          v28(v26 - 48);
        v26 -= 56;
      }
      while (v26 != v25);
      v27 = (void *)*((_QWORD *)this + 7);
    }
    *((_QWORD *)this + 8) = v25;
    operator delete(v27);
  }
  *(_QWORD *)this = &unk_24C0ACE30;
  (*((void (**)(webrtc::RtpTransport *))this + 3))(this);
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 32, *((_QWORD **)this + 5));
}

{
  webrtc::RtpTransport::~RtpTransport(this);
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::webrtc_function_impl::CallHelpers<void ()(cricket::DtlsTransportInternal *,webrtc::DtlsTransportState)>::CallInlineStorage<webrtc::DtlsSrtpTransport::SetDtlsTransport(cricket::DtlsTransportInternal *,cricket::DtlsTransportInternal **)::$_0>(webrtc::SrtpTransport **a1, uint64_t a2, int a3)
{
  webrtc::SrtpTransport *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v4 = *a1;
  v5 = *((_QWORD *)*a1 + 96);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
  if (a3 != 2)
  {
    webrtc::SrtpTransport::ResetParams(v4);
    return;
  }
  if (((*(uint64_t (**)(webrtc::SrtpTransport *))(*(_QWORD *)v4 + 96))(v4) & 1) != 0)
    return;
  if (((*(uint64_t (**)(webrtc::SrtpTransport *))(*(_QWORD *)v4 + 48))(v4) & 1) != 0)
  {
    v6 = 0;
    v7 = *((_QWORD *)v4 + 82);
    if (!v7)
      return;
  }
  else
  {
    v6 = *((_QWORD *)v4 + 83);
    v7 = *((_QWORD *)v4 + 82);
    if (!v7)
      return;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7)
    && (!v6 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6)))
  {
    webrtc::DtlsSrtpTransport::SetupRtpDtlsSrtp(v4);
    if (((*(uint64_t (**)(webrtc::SrtpTransport *))(*(_QWORD *)v4 + 48))(v4) & 1) == 0)
    {
      if (*((_QWORD *)v4 + 83))
        webrtc::DtlsSrtpTransport::SetupRtcpDtlsSrtp(v4);
    }
  }
}

uint64_t webrtc::DtlsTransport::DtlsTransport(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  pthread_mutexattr_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = &unk_24C0B3388;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = rtc::Thread::Current((rtc::Thread *)a1);
  pthread_mutexattr_init(&v15);
  pthread_mutexattr_setpolicy_np(&v15, 3);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 24), &v15);
  pthread_mutexattr_destroy(&v15);
  *(_DWORD *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 92) = 0;
  *(_BYTE *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 100) = 0;
  *(_BYTE *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 108) = 0;
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 116) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  v4 = *a2;
  *a2 = 0;
  *(_QWORD *)(a1 + 136) = v4;
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 200))(v4);
  v6 = operator new();
  *(_QWORD *)(v6 + 8) = rtc::Thread::Current((rtc::Thread *)v6);
  *(_QWORD *)(v6 + 16) = v5;
  *(_QWORD *)v6 = off_24C0B33D8;
  *(_DWORD *)(v6 + 24) = 0;
  v12 = (unsigned int *)(v6 + 24);
  *(_QWORD *)(a1 + 144) = v6;
  do
    v13 = __ldxr(v12);
  while (__stxr(v13 + 1, v12));
  webrtc::callback_list_impl::CallbackListReceivers::AddReceiver<webrtc::UntypedFunction::TrivialUntypedFunctionArgs<1ul>>((char *)(*(_QWORD *)(a1 + 136) + 440), a1, (uint64_t)webrtc::webrtc_function_impl::CallHelpers<void ()(cricket::DtlsTransportInternal *,webrtc::DtlsTransportState)>::CallInlineStorage<webrtc::DtlsTransport::DtlsTransport(std::unique_ptr<cricket::DtlsTransportInternal>)::$_0>, v7, v8, v9, v10, v11);
  webrtc::DtlsTransport::UpdateInformation((webrtc::DtlsTransport *)a1);
  return a1;
}

uint64_t webrtc::DtlsTransport::UpdateInformation(webrtc::DtlsTransport *this)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  pthread_mutex_t *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  _QWORD *v25;
  pthread_mutex_t *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t result;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  _QWORD *v43;
  pthread_mutex_t *v44;
  _QWORD *v45;
  _QWORD *v46;
  _QWORD *v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;

  v2 = *((_QWORD *)this + 17);
  if (!v2)
  {
    v6 = (pthread_mutex_t *)((char *)this + 24);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
    *((_DWORD *)this + 22) = 3;
    *((_BYTE *)this + 92) = 0;
    *((_BYTE *)this + 96) = 0;
    *((_BYTE *)this + 100) = 0;
    *((_BYTE *)this + 104) = 0;
    *((_BYTE *)this + 108) = 0;
    *((_BYTE *)this + 112) = 0;
    *((_BYTE *)this + 116) = 0;
    *((_BYTE *)this + 120) = 0;
    v7 = (_QWORD *)*((_QWORD *)this + 16);
    *((_QWORD *)this + 16) = 0;
    if (v7)
    {
      v8 = (_QWORD *)*v7;
      if (*v7)
      {
        v9 = (_QWORD *)v7[1];
        v10 = (_QWORD *)*v7;
        if (v9 == v8)
          goto LABEL_31;
        do
        {
          v12 = *--v9;
          v11 = v12;
          *v9 = 0;
          if (v12)
            (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
        }
        while (v9 != v8);
LABEL_30:
        v10 = (_QWORD *)*v7;
LABEL_31:
        v7[1] = v8;
        operator delete(v10);
      }
LABEL_32:
      MEMORY[0x20BD0ADEC](v7, 0x20C40960023A9);
    }
    return pthread_mutex_unlock(v6);
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 80))(v2) != 2)
  {
    v13 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 17) + 80))(*((_QWORD *)this + 17));
    v6 = (pthread_mutex_t *)((char *)this + 24);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
    *((_DWORD *)this + 22) = v13;
    *((_BYTE *)this + 92) = 0;
    *((_BYTE *)this + 96) = 0;
    *((_BYTE *)this + 100) = 0;
    *((_BYTE *)this + 104) = 0;
    *((_BYTE *)this + 108) = 0;
    *((_BYTE *)this + 112) = 0;
    *((_BYTE *)this + 116) = 0;
    *((_BYTE *)this + 120) = 0;
    v7 = (_QWORD *)*((_QWORD *)this + 16);
    *((_QWORD *)this + 16) = 0;
    if (v7)
    {
      v8 = (_QWORD *)*v7;
      if (*v7)
      {
        v14 = (_QWORD *)v7[1];
        v10 = (_QWORD *)*v7;
        if (v14 == v8)
          goto LABEL_31;
        do
        {
          v16 = *--v14;
          v15 = v16;
          *v14 = 0;
          if (v16)
            (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
        }
        while (v14 != v8);
        goto LABEL_30;
      }
      goto LABEL_32;
    }
    return pthread_mutex_unlock(v6);
  }
  v62 = 0;
  v63 = 0;
  v3 = (*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)this + 17) + 104))(*((_QWORD *)this + 17), (char *)&v63 + 4);
  if (!v3)
  {
LABEL_21:
    v4 = 0;
    v5 = 0;
    goto LABEL_22;
  }
  if (HIDWORD(v63) != 1)
  {
    if (!HIDWORD(v63))
    {
      v4 = 0x100000000;
      v5 = 1;
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  v5 = 0;
  v4 = 0x100000000;
LABEL_22:
  v17 = (*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)this + 17) + 120))(*((_QWORD *)this + 17), (char *)&v62 + 4);
  v18 = v17 & (*(uint64_t (**)(_QWORD, uint64_t *))(**((_QWORD **)this + 17) + 136))(*((_QWORD *)this + 17), &v63);
  if ((v3 & (*(unsigned int (**)(_QWORD, uint64_t *))(**((_QWORD **)this + 17) + 128))(*((_QWORD *)this + 17), &v62) & v18) == 1)
  {
    v19 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 17) + 80))(*((_QWORD *)this + 17));
    v20 = v5 | v4;
    v21 = HIDWORD(v62);
    v22 = v63;
    v23 = v62;
    (*(void (**)(_QWORD **__return_ptr))(**((_QWORD **)this + 17) + 168))(&v61);
    v24 = v21 | 0x100000000;
    v25 = v61;
    v61 = 0;
    v26 = (pthread_mutex_t *)((char *)this + 24);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
    *((_DWORD *)this + 22) = v19;
    *(_QWORD *)((char *)this + 92) = v20;
    *(_QWORD *)((char *)this + 100) = v24;
    *(_QWORD *)((char *)this + 108) = v22 | 0x100000000;
    *((_BYTE *)this + 120) = 1;
    *((_DWORD *)this + 29) = v23;
    v27 = (_QWORD *)*((_QWORD *)this + 16);
    *((_QWORD *)this + 16) = v25;
    if (v27)
    {
      v28 = (_QWORD *)*v27;
      if (*v27)
      {
        v29 = (_QWORD *)v27[1];
        v30 = (_QWORD *)*v27;
        if (v29 != v28)
        {
          do
          {
            v32 = *--v29;
            v31 = v32;
            *v29 = 0;
            if (v32)
              (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
          }
          while (v29 != v28);
          v30 = (_QWORD *)*v27;
        }
        v27[1] = v28;
        operator delete(v30);
      }
      MEMORY[0x20BD0ADEC](v27, 0x20C40960023A9);
    }
    result = pthread_mutex_unlock(v26);
    v51 = v61;
    v61 = 0;
    if (v51)
    {
      v52 = (_QWORD *)*v51;
      if (*v51)
      {
        v53 = (_QWORD *)v51[1];
        v54 = (_QWORD *)*v51;
        if (v53 == v52)
          goto LABEL_65;
        do
        {
          v56 = *--v53;
          v55 = v56;
          *v53 = 0;
          if (v56)
            (*(void (**)(uint64_t))(*(_QWORD *)v55 + 8))(v55);
        }
        while (v53 != v52);
LABEL_64:
        v54 = (_QWORD *)*v51;
LABEL_65:
        v51[1] = v52;
        operator delete(v54);
        return MEMORY[0x20BD0ADEC](v51, 0x20C40960023A9);
      }
      return MEMORY[0x20BD0ADEC](v51, 0x20C40960023A9);
    }
  }
  else
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v34, v35, v36, v37, v38, v39, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtls_transport.cc");
    v41 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 17) + 80))(*((_QWORD *)this + 17));
    v42 = v5 | v4;
    (*(void (**)(_QWORD **__return_ptr))(**((_QWORD **)this + 17) + 168))(&v60);
    v43 = v60;
    v60 = 0;
    v44 = (pthread_mutex_t *)((char *)this + 24);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
    *((_DWORD *)this + 22) = v41;
    *(_QWORD *)((char *)this + 92) = v42;
    *(_QWORD *)((char *)this + 108) = 0;
    *(_QWORD *)((char *)this + 100) = 0;
    *(_QWORD *)((char *)this + 113) = 0;
    v45 = (_QWORD *)*((_QWORD *)this + 16);
    *((_QWORD *)this + 16) = v43;
    if (v45)
    {
      v46 = (_QWORD *)*v45;
      if (*v45)
      {
        v47 = (_QWORD *)v45[1];
        v48 = (_QWORD *)*v45;
        if (v47 != v46)
        {
          do
          {
            v50 = *--v47;
            v49 = v50;
            *v47 = 0;
            if (v50)
              (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
          }
          while (v47 != v46);
          v48 = (_QWORD *)*v45;
        }
        v45[1] = v46;
        operator delete(v48);
      }
      MEMORY[0x20BD0ADEC](v45, 0x20C40960023A9);
    }
    result = pthread_mutex_unlock(v44);
    v51 = v60;
    v60 = 0;
    if (v51)
    {
      v52 = (_QWORD *)*v51;
      if (*v51)
      {
        v57 = (_QWORD *)v51[1];
        v54 = (_QWORD *)*v51;
        if (v57 == v52)
          goto LABEL_65;
        do
        {
          v59 = *--v57;
          v58 = v59;
          *v57 = 0;
          if (v59)
            (*(void (**)(uint64_t))(*(_QWORD *)v58 + 8))(v58);
        }
        while (v57 != v52);
        goto LABEL_64;
      }
      return MEMORY[0x20BD0ADEC](v51, 0x20C40960023A9);
    }
  }
  return result;
}

void webrtc::DtlsTransport::~DtlsTransport(webrtc::DtlsTransport *this)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)this = &unk_24C0B3388;
  v2 = *((_QWORD *)this + 18);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (_QWORD *)*((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v4)
  {
    v5 = (_QWORD *)*v4;
    if (*v4)
    {
      v6 = (_QWORD *)v4[1];
      v7 = (_QWORD *)*v4;
      if (v6 != v5)
      {
        do
        {
          v9 = *--v6;
          v8 = v9;
          *v6 = 0;
          if (v9)
            (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
        }
        while (v6 != v5);
        v7 = (_QWORD *)*v4;
      }
      v4[1] = v5;
      operator delete(v7);
    }
    MEMORY[0x20BD0ADEC](v4, 0x20C40960023A9);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 24));
}

uint64_t webrtc::DtlsTransport::Information@<X0>(webrtc::DtlsTransport *this@<X0>, uint64_t a2@<X8>)
{
  pthread_mutex_t *v4;
  _QWORD *v5;
  rtc::SSLCertChain *v6;

  v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  *(_DWORD *)a2 = *((_DWORD *)this + 22);
  *(_OWORD *)(a2 + 4) = *(_OWORD *)((char *)this + 92);
  *(_OWORD *)(a2 + 20) = *(_OWORD *)((char *)this + 108);
  v5 = (_QWORD *)(a2 + 40);
  v6 = (rtc::SSLCertChain *)*((_QWORD *)this + 16);
  if (v6)
    rtc::SSLCertChain::Clone(v6, v5);
  else
    *v5 = 0;
  return pthread_mutex_unlock(v4);
}

uint64_t webrtc::DtlsTransport::RegisterObserver(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = a2;
  return result;
}

uint64_t webrtc::DtlsTransport::UnregisterObserver(uint64_t this)
{
  *(_QWORD *)(this + 8) = 0;
  return this;
}

uint64_t (***webrtc::DtlsTransport::ice_transport@<X0>(webrtc::DtlsTransport *this@<X0>, _QWORD *a2@<X8>))(_QWORD)
{
  uint64_t (***result)(_QWORD);

  result = (uint64_t (***)(_QWORD))*((_QWORD *)this + 18);
  *a2 = result;
  if (result)
    return (uint64_t (***)(_QWORD))(**result)(result);
  return result;
}

uint64_t webrtc::DtlsTransport::Clear(webrtc::DtlsTransport *this)
{
  int v2;
  uint64_t v3;
  uint64_t result;
  uint64_t (***v5)(_QWORD, _QWORD *);
  BOOL v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[5];
  _QWORD *v14;

  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 17) + 80))(*((_QWORD *)this + 17));
  v3 = *((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *(_QWORD *)(*((_QWORD *)this + 18) + 16) = 0;
  result = webrtc::DtlsTransport::UpdateInformation(this);
  v5 = (uint64_t (***)(_QWORD, _QWORD *))*((_QWORD *)this + 1);
  if (v5)
    v6 = v2 == 3;
  else
    v6 = 1;
  if (!v6)
  {
    (*(void (**)(_QWORD *__return_ptr, webrtc::DtlsTransport *))(*(_QWORD *)this + 40))(v13, this);
    result = (**v5)(v5, v13);
    v7 = v14;
    v14 = 0;
    if (v7)
    {
      v8 = (_QWORD *)*v7;
      if (*v7)
      {
        v9 = (_QWORD *)v7[1];
        v10 = (_QWORD *)*v7;
        if (v9 != v8)
        {
          do
          {
            v12 = *--v9;
            v11 = v12;
            *v9 = 0;
            if (v12)
              (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
          }
          while (v9 != v8);
          v10 = (_QWORD *)*v7;
        }
        v7[1] = v8;
        operator delete(v10);
      }
      return MEMORY[0x20BD0ADEC](v7, 0x20C40960023A9);
    }
  }
  return result;
}

uint64_t rtc::RefCountedObject<webrtc::IceTransportWithPointer>::AddRef(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 24);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL rtc::RefCountedObject<webrtc::IceTransportWithPointer>::Release(unsigned int *a1)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = a1 + 6;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (a1 && v2 == 1)
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 24))(a1);
  return v2 != 1;
}

_QWORD *rtc::RefCountedObject<webrtc::IceTransportWithPointer>::~RefCountedObject(_QWORD *result)
{
  *result = &unk_24C0B5198;
  return result;
}

void rtc::RefCountedObject<webrtc::IceTransportWithPointer>::~RefCountedObject(_QWORD *a1)
{
  *a1 = &unk_24C0B5198;
  JUMPOUT(0x20BD0ADECLL);
}

BOOL rtc::RefCountedObject<webrtc::IceTransportWithPointer>::HasOneRef(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)(a1 + 24));
  return v1 == 1;
}

uint64_t webrtc::webrtc_function_impl::CallHelpers<void ()(cricket::DtlsTransportInternal *,webrtc::DtlsTransportState)>::CallInlineStorage<webrtc::DtlsTransport::DtlsTransport(std::unique_ptr<cricket::DtlsTransportInternal>)::$_0>(webrtc::DtlsTransport **a1)
{
  webrtc::DtlsTransport *v1;
  uint64_t result;
  uint64_t (***v3)(_QWORD, _QWORD *);
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[5];
  _QWORD *v11;

  v1 = *a1;
  result = webrtc::DtlsTransport::UpdateInformation(*a1);
  v3 = (uint64_t (***)(_QWORD, _QWORD *))*((_QWORD *)v1 + 1);
  if (v3)
  {
    (*(void (**)(_QWORD *__return_ptr, webrtc::DtlsTransport *))(*(_QWORD *)v1 + 40))(v10, v1);
    result = (**v3)(v3, v10);
    v4 = v11;
    v11 = 0;
    if (v4)
    {
      v5 = (_QWORD *)*v4;
      if (*v4)
      {
        v6 = (_QWORD *)v4[1];
        v7 = (_QWORD *)*v4;
        if (v6 != v5)
        {
          do
          {
            v9 = *--v6;
            v8 = v9;
            *v6 = 0;
            if (v9)
              (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
          }
          while (v6 != v5);
          v7 = (_QWORD *)*v4;
        }
        v4[1] = v5;
        operator delete(v7);
      }
      return MEMORY[0x20BD0ADEC](v4, 0x20C40960023A9);
    }
  }
  return result;
}

uint64_t cricket::StreamInterfaceChannel::Read(uint64_t a1, void *a2, size_t a3, unint64_t *a4)
{
  int v4;

  v4 = *(_DWORD *)(a1 + 104);
  if (!v4)
    return 3;
  if (v4 == 1)
    return 2;
  if (rtc::BufferQueue::ReadFront((rtc::BufferQueue *)(a1 + 112), a2, a3, a4))
    return 1;
  return 2;
}

uint64_t cricket::StreamInterfaceChannel::Write(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  int v7;
  char v8;
  uint64_t v9;
  int v10;
  void *__p;
  void *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  char v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;

  v7 = -1;
  v8 = 0;
  v9 = -1;
  v10 = -1;
  v12 = 0;
  v13 = 0;
  __p = 0;
  v14 = -1;
  v15 = -1;
  v16 = 0;
  v19 = 0;
  v17 = 0;
  v18 = 0;
  v21 = 0;
  v22 = 0;
  v20 = 0;
  v23 = 0;
  (*(void (**)(_QWORD, uint64_t, uint64_t, int *, _QWORD))(**(_QWORD **)(a1 + 96) + 40))(*(_QWORD *)(a1 + 96), a2, a3, &v7, 0);
  *a4 = a3;
  if (__p)
  {
    v12 = __p;
    operator delete(__p);
  }
  return 1;
}

BOOL cricket::StreamInterfaceChannel::OnPacketReceived(cricket::StreamInterfaceChannel *this, const char *__src, size_t __n)
{
  rtc::BufferQueue *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL8 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(char *, uint64_t, _QWORD);
  _QWORD *v23;
  _QWORD *v24;
  void (*v25)(_QWORD *, cricket::StreamInterfaceChannel *, uint64_t, _QWORD);

  v6 = (cricket::StreamInterfaceChannel *)((char *)this + 112);
  if (*((_QWORD *)this + 21) && (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t", v7, v8, v9, v10, v11, v12, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
  v14 = rtc::BufferQueue::WriteBack(v6, __src, __n, 0);
  if (!v14 && (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
  v22 = (void (*)(char *, uint64_t, _QWORD))*((_QWORD *)this + 11);
  if (v22)
    v22((char *)this + 64, 2, 0);
  v23 = (_QWORD *)*((_QWORD *)this + 4);
  for (*((_QWORD *)this + 6) = v23; v23 != (_QWORD *)((char *)this + 24); v23 = (_QWORD *)*((_QWORD *)this + 6))
  {
    v25 = (void (*)(_QWORD *, cricket::StreamInterfaceChannel *, uint64_t, _QWORD))v23[2];
    v24 = v23 + 2;
    *((_QWORD *)this + 6) = *(v24 - 1);
    v25(v24, this, 2, 0);
  }
  return v14;
}

uint64_t cricket::StreamInterfaceChannel::GetState(cricket::StreamInterfaceChannel *this)
{
  return *((unsigned int *)this + 26);
}

void cricket::StreamInterfaceChannel::Close(cricket::StreamInterfaceChannel *this)
{
  rtc::BufferQueue::Clear((cricket::StreamInterfaceChannel *)((char *)this + 112));
  *((_DWORD *)this + 26) = 0;
}

uint64_t cricket::DtlsTransport::ConnectToIceTransport(cricket::DtlsTransport *this)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  __int128 v26;
  uint64_t (*v27)(_QWORD, _QWORD, _QWORD);
  uint64_t v28;
  uint64_t v29[3];

  v2 = (_QWORD *)*((_QWORD *)this + 60);
  v3 = operator new(0x30uLL);
  v3[2] = sigslot::_opaque_connection::emitter<cricket::DtlsTransport,rtc::PacketTransportInternal *>;
  v3[3] = this;
  v3[4] = cricket::DtlsTransport::OnWritableState;
  v3[5] = 0;
  v4 = v2[9];
  v2 += 9;
  *v3 = v4;
  v3[1] = v2;
  *(_QWORD *)(v4 + 8) = v3;
  *v2 = v3;
  ++v2[2];
  (*((void (**)(cricket::DtlsTransport *, _QWORD *))this + 1))(this, v2 - 2);
  v5 = *((_QWORD *)this + 60);
  *(_QWORD *)&v26 = this;
  v6 = (char *)(v5 + 344);
  v7 = operator new();
  *(_OWORD *)v7 = v26;
  *(_QWORD *)(v7 + 16) = absl::internal_any_invocable::LocalManagerTrivial;
  *(_QWORD *)(v7 + 24) = absl::internal_any_invocable::LocalInvoker<false,void,cricket::DtlsTransport::ConnectToIceTransport(void)::$_0 &,rtc::PacketTransportInternal *,rtc::ReceivedPacket const&>;
  v27 = absl::internal_any_invocable::EmptyManager;
  v28 = 0;
  v29[0] = v7;
  v29[1] = (uint64_t)webrtc::webrtc_function_impl::CallHelpers<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)>::CallVoidPtr<absl::AnyInvocable<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)>>;
  v29[2] = (uint64_t)webrtc::UntypedFunction::PrepareArgs<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&),absl::AnyInvocable<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)>,absl::AnyInvocable<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)>,(void *)0>(absl::AnyInvocable<void ()(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)> &&)::{lambda(webrtc::webrtc_function_impl::VoidUnion *)#1}::__invoke;
  webrtc::callback_list_impl::CallbackListReceivers::AddReceiver<webrtc::UntypedFunction::NontrivialUntypedFunctionArgs>(v6, (uint64_t)this, v29, v8, v9, v10, v11, v12);
  absl::internal_any_invocable::EmptyManager(1, &v26, &v26);
  v13 = (_QWORD *)*((_QWORD *)this + 60);
  v14 = operator new(0x30uLL);
  v14[2] = sigslot::_opaque_connection::emitter<cricket::DtlsTransport,rtc::PacketTransportInternal *,rtc::SentPacket const&>;
  v14[3] = this;
  v14[4] = cricket::DtlsTransport::OnSentPacket;
  v14[5] = 0;
  v15 = v13[30];
  v13 += 30;
  *v14 = v15;
  v14[1] = v13;
  *(_QWORD *)(v15 + 8) = v14;
  *v13 = v14;
  ++v13[2];
  (*((void (**)(cricket::DtlsTransport *, _QWORD *))this + 1))(this, v13 - 2);
  v16 = (_QWORD *)*((_QWORD *)this + 60);
  v17 = operator new(0x30uLL);
  v17[2] = sigslot::_opaque_connection::emitter<cricket::DtlsTransport,rtc::PacketTransportInternal *>;
  v17[3] = this;
  v17[4] = cricket::DtlsTransport::OnReadyToSend;
  v17[5] = 0;
  v18 = v16[16];
  v16 += 16;
  *v17 = v18;
  v17[1] = v16;
  *(_QWORD *)(v18 + 8) = v17;
  *v16 = v17;
  ++v16[2];
  (*((void (**)(cricket::DtlsTransport *, _QWORD *))this + 1))(this, v16 - 2);
  v19 = (_QWORD *)*((_QWORD *)this + 60);
  v20 = operator new(0x30uLL);
  v20[2] = sigslot::_opaque_connection::emitter<cricket::DtlsTransport,rtc::PacketTransportInternal *>;
  v20[3] = this;
  v20[4] = cricket::DtlsTransport::OnReceivingState;
  v20[5] = 0;
  v21 = v19[23];
  v19 += 23;
  *v20 = v21;
  v20[1] = v19;
  *(_QWORD *)(v21 + 8) = v20;
  *v19 = v20;
  ++v19[2];
  (*((void (**)(cricket::DtlsTransport *, _QWORD *))this + 1))(this, v19 - 2);
  v22 = *((_QWORD *)this + 60);
  v23 = operator new(0x30uLL);
  v23[3] = this;
  v23[4] = cricket::DtlsTransport::OnNetworkRouteChanged;
  v23[5] = 0;
  v23[1] = v22 + 296;
  v23[2] = sigslot::_opaque_connection::emitter<cricket::DtlsTransport,std::optional<rtc::NetworkRoute>>;
  v24 = *(_QWORD *)(v22 + 296);
  *v23 = v24;
  *(_QWORD *)(v24 + 8) = v23;
  *(_QWORD *)(v22 + 296) = v23;
  ++*(_QWORD *)(v22 + 312);
  return (*((uint64_t (**)(cricket::DtlsTransport *, uint64_t))this + 1))(this, v22 + 280);
}

void cricket::DtlsTransport::~DtlsTransport(cricket::DtlsTransport *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;

  *(_QWORD *)this = &off_24C0B3460;
  v9 = *((_QWORD *)this + 60);
  if (v9)
    webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(v9 + 344), this);
  v10 = *((_QWORD *)this + 78);
  *((_QWORD *)this + 78) = 0;
  if (v10)
    MEMORY[0x20BD0ADD4](v10, 0x1000C8077774924);
  if (*((char *)this + 607) < 0)
  {
    operator delete(*((void **)this + 73));
    v11 = *((_QWORD *)this + 72);
    *((_QWORD *)this + 72) = 0;
    if (!v11)
      goto LABEL_8;
    goto LABEL_7;
  }
  v11 = *((_QWORD *)this + 72);
  *((_QWORD *)this + 72) = 0;
  if (v11)
LABEL_7:
    MEMORY[0x20BD0ADD4](v11, 0x1000C8077774924);
LABEL_8:
  v12 = *((_QWORD *)this + 67);
  if (v12)
  {
    do
    {
      v13 = __ldaxr((unsigned int *)v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, (unsigned int *)v12));
    if (!v14)
    {
      v15 = *(_QWORD *)(v12 + 8);
      *(_QWORD *)(v12 + 8) = 0;
      if (v15)
        (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
      MEMORY[0x20BD0ADEC](v12, 0x1020C40D5A9D86FLL);
    }
  }
  v16 = (void *)*((_QWORD *)this + 63);
  if (v16)
  {
    *((_QWORD *)this + 64) = v16;
    operator delete(v16);
  }
  v17 = *((_QWORD *)this + 61);
  *((_QWORD *)this + 61) = 0;
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  cricket::DtlsTransportInternal::~DtlsTransportInternal(this, a2, a3, a4, a5, a6, a7, a8);
}

{
  cricket::DtlsTransport::~DtlsTransport(this, a2, a3, a4, a5, a6, a7, a8);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t cricket::DtlsTransport::dtls_state(cricket::DtlsTransport *this)
{
  return *((unsigned int *)this + 119);
}

uint64_t cricket::DtlsTransport::transport_name(cricket::DtlsTransport *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 60) + 16))(*((_QWORD *)this + 60));
}

uint64_t cricket::DtlsTransport::component(cricket::DtlsTransport *this)
{
  return *((unsigned int *)this + 118);
}

uint64_t cricket::DtlsTransport::IsDtlsActive(cricket::DtlsTransport *this)
{
  return *((unsigned __int8 *)this + 528);
}

uint64_t cricket::DtlsTransport::SetLocalCertificate(uint64_t a1, unsigned int **a2)
{
  uint64_t result;
  unsigned int *v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  std::string __p;

  if (*(_BYTE *)(a1 + 528))
  {
    if (*a2 != *(unsigned int **)(a1 + 536))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
        return 0;
      cricket::DtlsTransport::ToString(&__p, (int *)a1);
      rtc::webrtc_logging_impl::Log("\r\n\t", v17, v18, v19, v20, v21, v22, v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      return 0;
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
      return 1;
    cricket::DtlsTransport::ToString(&__p, (int *)a1);
    rtc::webrtc_logging_impl::Log("\r\n\t", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return 1;
LABEL_22:
    operator delete(__p.__r_.__value_.__l.__data_);
    return 1;
  }
  v4 = *a2;
  if (!*a2)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
      return 1;
    cricket::DtlsTransport::ToString(&__p, (int *)a1);
    rtc::webrtc_logging_impl::Log("\r\n\t", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return 1;
    goto LABEL_22;
  }
  do
    v5 = __ldxr(v4);
  while (__stxr(v5 + 1, v4));
  v6 = *(_QWORD *)(a1 + 536);
  if (v6)
  {
    do
    {
      v7 = __ldaxr((unsigned int *)v6);
      v8 = v7 - 1;
    }
    while (__stlxr(v8, (unsigned int *)v6));
    if (!v8)
    {
      v9 = *(_QWORD *)(v6 + 8);
      *(_QWORD *)(v6 + 8) = 0;
      if (v9)
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
      MEMORY[0x20BD0ADEC](v6, 0x1020C40D5A9D86FLL);
    }
  }
  *(_QWORD *)(a1 + 536) = v4;
  result = 1;
  *(_BYTE *)(a1 + 528) = 1;
  return result;
}

void cricket::DtlsTransport::ToString(std::string *this, int *a2)
{
  uint64_t v5;
  char *v6;
  size_t v7;
  BOOL v8;
  std::string::size_type v10;
  std::string::size_type v11;
  std::string *v12;
  char *v13;
  std::string::size_type v14;
  std::string::size_type size;
  std::string::size_type v16;
  std::string *v17;
  _BYTE *v18;
  std::string::size_type v19;
  std::string *v20;
  std::string *v21;
  std::string::size_type v22;
  int v23;
  std::string::size_type v24;
  std::string *v25;
  _BYTE *v26;
  std::string::size_type v27;
  const std::string::value_type *v28;
  std::string::size_type v29;
  int v30;
  std::string::size_type v31;
  std::string *v32;
  std::string::value_type *v33;
  std::string::size_type v34;
  const std::string::value_type *v35;
  std::string::size_type v36;
  int v37;
  std::string::size_type v38;
  std::string *v39;
  std::string::value_type *v40;
  std::string::size_type v41;
  std::string::size_type v42;
  int v43;
  std::string::size_type v44;
  std::string *v45;
  _BYTE *v46;
  std::string::size_type v47;
  std::string v48;

  memset(&v48, 0, sizeof(v48));
  if (&v48 > (std::string *)"DtlsTransport[" || (char *)&v48.__r_.__value_.__r.__words[1] + 6 <= "DtlsTransport[")
  {
    strcpy((char *)&v48, "DtlsTransport[");
    *((_BYTE *)&v48.__r_.__value_.__s + 23) = 14;
    v5 = (*(uint64_t (**)(int *))(*(_QWORD *)a2 + 16))(a2);
    v6 = (char *)v5;
    if (*(char *)(v5 + 23) < 0)
    {
      v7 = *(_QWORD *)(v5 + 8);
      if ((v7 & 0x8000000000000000) != 0)
        goto LABEL_112;
      v6 = *(char **)v5;
      v8 = v7 == 0;
      if (v7 && v6 == 0)
        goto LABEL_112;
    }
    else
    {
      v7 = *(unsigned __int8 *)(v5 + 23);
      v8 = *(_BYTE *)(v5 + 23) == 0;
    }
    v10 = (v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? 22
        : (v48.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    v11 = (v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? HIBYTE(v48.__r_.__value_.__r.__words[2])
        : v48.__r_.__value_.__l.__size_;
    if (v10 - v11 >= v7)
    {
      if (!v8)
      {
        if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v12 = &v48;
        else
          v12 = (std::string *)v48.__r_.__value_.__r.__words[0];
        v13 = (char *)v12 + v11;
        if ((char *)v12 + v11 <= v6 && &v13[v7] > v6)
          goto LABEL_112;
        memmove(v13, v6, v7);
        v14 = v11 + v7;
        if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
          v48.__r_.__value_.__l.__size_ = v11 + v7;
        else
          *((_BYTE *)&v48.__r_.__value_.__s + 23) = v14 & 0x7F;
        v12->__r_.__value_.__s.__data_[v14] = 0;
      }
    }
    else
    {
      std::string::__grow_by_and_replace(&v48, v10, v11 + v7 - v10, v11, v11, 0, v7, v6);
    }
    size = HIBYTE(v48.__r_.__value_.__r.__words[2]);
    if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v16 = 22;
    else
      v16 = (v48.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = v48.__r_.__value_.__l.__size_;
    if (v16 == size)
    {
      std::string::__grow_by_and_replace(&v48, v16, 1uLL, v16, v16, 0, 1uLL, "|");
    }
    else
    {
      v17 = &v48;
      if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v17 = (std::string *)v48.__r_.__value_.__r.__words[0];
      v18 = (char *)v17 + size;
      if ((char *)v17 + size <= "|" && v18 + 1 > "|")
        goto LABEL_112;
      *v18 = 124;
      v19 = size + 1;
      if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
        v48.__r_.__value_.__l.__size_ = v19;
      else
        *((_BYTE *)&v48.__r_.__value_.__s + 23) = v19 & 0x7F;
      v17->__r_.__value_.__s.__data_[v19] = 0;
    }
    v20 = rtc::StringBuilder::operator<<(&v48, a2[118]);
    v21 = v20;
    v22 = HIBYTE(v20->__r_.__value_.__r.__words[2]);
    v23 = (char)v22;
    if ((v22 & 0x80u) == 0)
      v24 = 22;
    else
      v24 = (v20->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if ((v22 & 0x80u) != 0)
      v22 = v20->__r_.__value_.__l.__size_;
    if (v24 == v22)
    {
      std::string::__grow_by_and_replace(v20, v24, 1uLL, v24, v24, 0, 1uLL, "|");
    }
    else
    {
      if (v23 >= 0)
        v25 = v20;
      else
        v25 = (std::string *)v20->__r_.__value_.__r.__words[0];
      v26 = (char *)v25 + v22;
      if ((char *)v25 + v22 <= "|" && v26 + 1 > "|")
        goto LABEL_112;
      *v26 = 124;
      v27 = v22 + 1;
      if (SHIBYTE(v20->__r_.__value_.__r.__words[2]) < 0)
        v20->__r_.__value_.__l.__size_ = v27;
      else
        *((_BYTE *)&v20->__r_.__value_.__s + 23) = v27 & 0x7F;
      v25->__r_.__value_.__s.__data_[v27] = 0;
    }
    v28 = (&off_24C0B3530)[2 * (*(unsigned int (**)(int *))(*(_QWORD *)a2 + 32))(a2)];
    if (v28)
    {
      v29 = HIBYTE(v21->__r_.__value_.__r.__words[2]);
      v30 = (char)v29;
      if ((v29 & 0x80u) == 0)
        v31 = 22;
      else
        v31 = (v21->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
      if ((v29 & 0x80u) != 0)
        v29 = v21->__r_.__value_.__l.__size_;
      if (v31 == v29)
      {
        std::string::__grow_by_and_replace(v21, v31, 1uLL, v31, v31, 0, 1uLL, v28);
      }
      else
      {
        if (v30 >= 0)
          v32 = v21;
        else
          v32 = (std::string *)v21->__r_.__value_.__r.__words[0];
        v33 = (char *)v32 + v29;
        if ((char *)v32 + v29 <= v28 && v33 + 1 > v28)
          goto LABEL_112;
        *v33 = *v28;
        v34 = v29 + 1;
        if (SHIBYTE(v21->__r_.__value_.__r.__words[2]) < 0)
          v21->__r_.__value_.__l.__size_ = v34;
        else
          *((_BYTE *)&v21->__r_.__value_.__s + 23) = v34 & 0x7F;
        v32->__r_.__value_.__s.__data_[v34] = 0;
      }
      v35 = (&off_24C0B3550)[2 * (*(unsigned int (**)(int *))(*(_QWORD *)a2 + 24))(a2)];
      if (v35)
      {
        v36 = HIBYTE(v21->__r_.__value_.__r.__words[2]);
        v37 = (char)v36;
        if ((v36 & 0x80u) == 0)
          v38 = 22;
        else
          v38 = (v21->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if ((v36 & 0x80u) != 0)
          v36 = v21->__r_.__value_.__l.__size_;
        if (v38 == v36)
        {
          std::string::__grow_by_and_replace(v21, v38, 1uLL, v38, v38, 0, 1uLL, v35);
        }
        else
        {
          if (v37 >= 0)
            v39 = v21;
          else
            v39 = (std::string *)v21->__r_.__value_.__r.__words[0];
          v40 = (char *)v39 + v36;
          if ((char *)v39 + v36 <= v35 && v40 + 1 > v35)
            goto LABEL_112;
          *v40 = *v35;
          v41 = v36 + 1;
          if (SHIBYTE(v21->__r_.__value_.__r.__words[2]) < 0)
            v21->__r_.__value_.__l.__size_ = v41;
          else
            *((_BYTE *)&v21->__r_.__value_.__s + 23) = v41 & 0x7F;
          v39->__r_.__value_.__s.__data_[v41] = 0;
        }
        v42 = HIBYTE(v21->__r_.__value_.__r.__words[2]);
        v43 = (char)v42;
        if ((v42 & 0x80u) == 0)
          v44 = 22;
        else
          v44 = (v21->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if ((v42 & 0x80u) != 0)
          v42 = v21->__r_.__value_.__l.__size_;
        if (v44 == v42)
        {
          std::string::__grow_by_and_replace(v21, v44, 1uLL, v44, v44, 0, 1uLL, "]");
LABEL_111:
          *this = v48;
          return;
        }
        if (v43 >= 0)
          v45 = v21;
        else
          v45 = (std::string *)v21->__r_.__value_.__r.__words[0];
        v46 = (char *)v45 + v42;
        if ((char *)v45 + v42 > "]" || v46 + 1 <= "]")
        {
          *v46 = 93;
          v47 = v42 + 1;
          if (SHIBYTE(v21->__r_.__value_.__r.__words[2]) < 0)
            v21->__r_.__value_.__l.__size_ = v47;
          else
            *((_BYTE *)&v21->__r_.__value_.__s + 23) = v47 & 0x7F;
          v45->__r_.__value_.__s.__data_[v47] = 0;
          goto LABEL_111;
        }
      }
    }
  }
LABEL_112:
  __break(1u);
}

uint64_t cricket::DtlsTransport::GetLocalCertificate@<X0>(uint64_t this@<X0>, unsigned int **a2@<X8>)
{
  unsigned int *v2;
  unsigned int v3;

  v2 = *(unsigned int **)(this + 536);
  *a2 = v2;
  if (v2)
  {
    do
      v3 = __ldxr(v2);
    while (__stxr(v3 + 1, v2));
  }
  return this;
}

uint64_t cricket::DtlsTransport::SetDtlsRole(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = result;
  if (*(_QWORD *)(result + 488))
  {
    if (*(_BYTE *)(result + 548))
    {
      if (*(_DWORD *)(result + 544) == a2)
      {
        return 1;
      }
      else
      {
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
          rtc::webrtc_logging_impl::Log("\r\t", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
        return 0;
      }
    }
    else
    {
      __break(1u);
    }
  }
  else
  {
    *(_DWORD *)(result + 544) = a2;
    result = 1;
    *(_BYTE *)(v2 + 548) = 1;
  }
  return result;
}

BOOL cricket::DtlsTransport::GetDtlsRole(uint64_t a1, _DWORD *a2)
{
  int v2;

  v2 = *(unsigned __int8 *)(a1 + 548);
  if (*(_BYTE *)(a1 + 548))
    *a2 = *(_DWORD *)(a1 + 544);
  return v2 != 0;
}

uint64_t cricket::DtlsTransport::GetSslCipherSuite(cricket::DtlsTransport *this, int *a2)
{
  if ((*(unsigned int (**)(cricket::DtlsTransport *))(*(_QWORD *)this + 80))(this) == 2)
    return (*(uint64_t (**)(_QWORD, int *))(**((_QWORD **)this + 61) + 128))(*((_QWORD *)this + 61), a2);
  else
    return 0;
}

unint64_t cricket::DtlsTransport::SetRemoteParameters@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const void *a4@<X3>, size_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  int v14;
  void *v15;
  unint64_t result;

  v14 = BYTE4(a6);
  if (a5)
  {
    v15 = (void *)operator new[]();
    memcpy(v15, a4, a5);
    if (*(_BYTE *)(a1 + 528))
      goto LABEL_3;
LABEL_8:
    if (!v14)
      goto LABEL_15;
    goto LABEL_9;
  }
  v15 = 0;
  if (!*(_BYTE *)(a1 + 528))
    goto LABEL_8;
LABEL_3:
  if (*(_QWORD *)(a1 + 560) != a5)
  {
    if (!v14)
      goto LABEL_15;
    goto LABEL_14;
  }
  if (!v14)
    goto LABEL_15;
  if (memcmp(*(const void **)(a1 + 576), v15, a5))
  {
LABEL_14:
    *(_DWORD *)(a1 + 544) = a6;
    *(_BYTE *)(a1 + 548) = 1;
    goto LABEL_15;
  }
LABEL_9:
  if (((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 112))(a1, a6) & 1) == 0)
  {
    *(_DWORD *)a7 = 3;
    result = (unint64_t)operator new(0x30uLL);
    *(_QWORD *)(a7 + 8) = result;
    *(_OWORD *)(a7 + 16) = xmmword_208F08F30;
    if (result > (unint64_t)"Failed to set SSL role for the transport."
      || result + 41 <= (unint64_t)"Failed to set SSL role for the transport.")
    {
      strcpy((char *)result, "Failed to set SSL role for the transport.");
      goto LABEL_21;
    }
LABEL_23:
    __break(1u);
    goto LABEL_24;
  }
LABEL_15:
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const void *, size_t))(*(_QWORD *)a1 + 184))(a1, a2, a3, a4, a5);
  if ((result & 1) != 0)
  {
    *(_DWORD *)a7 = 0;
    *(_BYTE *)(a7 + 38) = 0;
    *(_QWORD *)(a7 + 16) = 0;
    *(_QWORD *)(a7 + 24) = 0;
    *(_QWORD *)(a7 + 8) = 0;
    *(_QWORD *)(a7 + 29) = 0;
    if (v15)
      goto LABEL_24;
    return result;
  }
  *(_DWORD *)a7 = 3;
  result = (unint64_t)operator new(0x28uLL);
  *(_QWORD *)(a7 + 8) = result;
  *(_OWORD *)(a7 + 16) = xmmword_208F051B0;
  if (result <= (unint64_t)"Failed to apply remote fingerprint."
    && result + 35 > (unint64_t)"Failed to apply remote fingerprint.")
  {
    goto LABEL_23;
  }
  strcpy((char *)result, "Failed to apply remote fingerprint.");
LABEL_21:
  *(_DWORD *)(a7 + 32) = 0;
  *(_BYTE *)(a7 + 36) = 0;
  *(_BYTE *)(a7 + 38) = 0;
  if (v15)
LABEL_24:
    JUMPOUT(0x20BD0ADD4);
  return result;
}

BOOL cricket::DtlsTransport::SetRemoteFingerprint(uint64_t a1, std::string *a2, std::string::size_type a3, const void *a4, size_t a5)
{
  void *v10;
  uint64_t v11;
  uint64_t v12;
  std::string *p_p;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void **v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v49;
  std::string __p;

  if (!a5)
  {
    v10 = 0;
    if (*(_BYTE *)(a1 + 528))
      goto LABEL_3;
LABEL_13:
    if (a3)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      {
        cricket::DtlsTransport::ToString(&__p, (int *)a1);
        rtc::webrtc_logging_impl::Log("\r\n\t", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      v21 = 0;
      if (!v10)
        return v21;
LABEL_44:
      MEMORY[0x20BD0ADD4](v10, 0x1000C8077774924);
      return v21;
    }
    goto LABEL_39;
  }
  v10 = (void *)operator new[]();
  memcpy(v10, a4, a5);
  if (!*(_BYTE *)(a1 + 528))
    goto LABEL_13;
LABEL_3:
  v11 = *(_QWORD *)(a1 + 560);
  if (v11 == a5 && !memcmp(*(const void **)(a1 + 576), v10, a5))
  {
    if (a3)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        cricket::DtlsTransport::ToString(&__p, (int *)a1);
        rtc::webrtc_logging_impl::Log("\r\n\t", v27, v28, v29, v30, v31, v32, v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
          v21 = 1;
          if (!v10)
            return v21;
          goto LABEL_44;
        }
      }
      goto LABEL_43;
    }
LABEL_39:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      cricket::DtlsTransport::ToString(&__p, (int *)a1);
      rtc::webrtc_logging_impl::Log("\r\n\t", v34, v35, v36, v37, v38, v39, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    *(_BYTE *)(a1 + 528) = 0;
LABEL_43:
    v21 = 1;
    if (!v10)
      return v21;
    goto LABEL_44;
  }
  if (!a3)
    goto LABEL_39;
  *(_QWORD *)(a1 + 560) = a5;
  *(_QWORD *)(a1 + 568) = a5;
  v12 = *(_QWORD *)(a1 + 576);
  *(_QWORD *)(a1 + 576) = v10;
  if (v12)
    MEMORY[0x20BD0ADD4](v12, 0x1000C8077774924);
  if (a3 >= 0x7FFFFFFFFFFFFFF8)
LABEL_56:
    abort();
  if (a3 > 0x16)
  {
    v22 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17)
      v22 = a3 | 7;
    v23 = v22 + 1;
    p_p = (std::string *)operator new(v22 + 1);
    __p.__r_.__value_.__l.__size_ = a3;
    __p.__r_.__value_.__r.__words[2] = v23 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    if (p_p > a2)
      goto LABEL_23;
  }
  else
  {
    *((_BYTE *)&__p.__r_.__value_.__s + 23) = a3;
    p_p = &__p;
    if (&__p > a2)
      goto LABEL_23;
  }
  if ((std::string *)((char *)p_p + a3) > a2)
  {
LABEL_55:
    __break(1u);
    goto LABEL_56;
  }
LABEL_23:
  memmove(p_p, a2, a3);
  p_p->__r_.__value_.__s.__data_[a3] = 0;
  v24 = (void **)(a1 + 584);
  if (*(char *)(a1 + 607) < 0)
    operator delete(*v24);
  *(_OWORD *)v24 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  *(_QWORD *)(a1 + 600) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
  v25 = *(_QWORD *)(a1 + 488);
  if (!v25 || v11)
  {
    if (v11 && v25)
    {
      *(_QWORD *)(a1 + 488) = 0;
      (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
      cricket::DtlsTransport::set_dtls_state(a1, 0);
      cricket::DtlsTransport::set_writable(a1, 0);
    }
    if ((cricket::DtlsTransport::SetupDtls((cricket::DtlsTransport *)a1) & 1) != 0)
      return 1;
    cricket::DtlsTransport::set_dtls_state(a1, 4);
    return 0;
  }
  v49 = 0;
  if (*(char *)(a1 + 607) < 0)
  {
    v26 = *(_QWORD *)(a1 + 592);
    if ((v26 & 0x8000000000000000) == 0)
    {
      v24 = (void **)*v24;
      if (!v26 || v24)
        goto LABEL_48;
    }
    goto LABEL_55;
  }
  v26 = *(unsigned __int8 *)(a1 + 607);
LABEL_48:
  if (((*(uint64_t (**)(uint64_t, void **, uint64_t, _QWORD, _QWORD, int *))(*(_QWORD *)v25 + 112))(v25, v24, v26, *(_QWORD *)(a1 + 576), *(_QWORD *)(a1 + 560), &v49) & 1) != 0)return 1;
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
  {
    cricket::DtlsTransport::ToString(&__p, (int *)a1);
    rtc::webrtc_logging_impl::Log("\r\n\t", v41, v42, v43, v44, v45, v46, v47, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  cricket::DtlsTransport::set_dtls_state(a1, 4);
  return v49 == 3;
}

void cricket::DtlsTransport::set_dtls_state(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  _BYTE *v23;
  std::string *v24;
  BOOL v25;
  uint64_t v26;
  std::string __p;
  uint64_t v28;

  if (*(_DWORD *)(a1 + 476) != (_DWORD)a2)
  {
    v4 = *(_QWORD *)(a1 + 640);
    if (v4)
    {
      v5 = operator new();
      if (rtc::g_clock)
      {
        v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
      }
      else
      {
        if (!dword_253EA791C)
          mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
        v6 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
           / dword_253EA791C;
      }
      *(_QWORD *)v5 = &unk_24C0BBD90;
      *(_QWORD *)(v5 + 8) = 1000 * (v6 / 1000000);
      *(_DWORD *)(v5 + 16) = a2;
      v28 = v5;
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v4 + 40))(v4, &v28);
      v7 = v28;
      v28 = 0;
      if (v7)
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
    {
      cricket::DtlsTransport::ToString(&__p, (int *)a1);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v12, v13, v14, v15, v16, v17, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    *(_DWORD *)(a1 + 476) = a2;
    if (*(_BYTE *)(a1 + 464))
    {
      v24 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/callback_list.cc", 72, "!send_in_progress_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v8, v9, v10, v11, v26);
      cricket::DtlsTransport::set_writable((cricket::DtlsTransport *)v24, v25);
    }
    else
    {
      v19 = (_BYTE *)(a1 + 464);
      *(_BYTE *)(a1 + 464) = 1;
      v20 = *(_QWORD *)(a1 + 440);
      v21 = *(_QWORD *)(a1 + 448);
      if (v20 == v21)
      {
        *v19 = 0;
      }
      else
      {
        v22 = 0;
        do
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(v20 + 40))(v20 + 8, a1, a2);
          v23 = *(_BYTE **)v20;
          v20 += 56;
          v22 |= v23 == v19;
        }
        while (v20 != v21);
        *v19 = 0;
        if ((v22 & 1) != 0)
          webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(a1 + 440), (const void *)(a1 + 464));
      }
    }
  }
}

uint64_t cricket::DtlsTransport::set_writable(uint64_t this, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(uint64_t, uint64_t);
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t);
  std::string __p;
  uint64_t v21;

  if (*(unsigned __int8 *)(this + 633) != a2)
  {
    v3 = this;
    v4 = *(_QWORD *)(this + 640);
    if (v4)
    {
      v5 = operator new();
      if (rtc::g_clock)
      {
        v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
      }
      else
      {
        if (!dword_253EA791C)
          mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
        v6 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
           / dword_253EA791C;
      }
      *(_QWORD *)v5 = &unk_24C0BBDC8;
      *(_QWORD *)(v5 + 8) = 1000 * (v6 / 1000000);
      *(_BYTE *)(v5 + 16) = a2;
      v21 = v5;
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v4 + 40))(v4, &v21);
      v7 = v21;
      v21 = 0;
      if (v7)
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
    {
      cricket::DtlsTransport::ToString(&__p, (int *)v3);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v8, v9, v10, v11, v12, v13, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    *(_BYTE *)(v3 + 633) = a2;
    if (a2)
    {
      v15 = *(_QWORD *)(v3 + 136);
      for (*(_QWORD *)(v3 + 152) = v15; v15 != v3 + 128; v15 = *(_QWORD *)(v3 + 152))
      {
        v17 = *(void (**)(uint64_t, uint64_t))(v15 + 16);
        v16 = v15 + 16;
        *(_QWORD *)(v3 + 152) = *(_QWORD *)(v16 - 8);
        v17(v16, v3);
      }
    }
    this = *(_QWORD *)(v3 + 80);
    for (*(_QWORD *)(v3 + 96) = this; this != v3 + 72; this = *(_QWORD *)(v3 + 96))
    {
      v19 = *(void (**)(uint64_t, uint64_t))(this + 16);
      v18 = this + 16;
      *(_QWORD *)(v3 + 96) = *(_QWORD *)(v18 - 8);
      v19(v18, v3);
    }
  }
  return this;
}

uint64_t cricket::DtlsTransport::SetupDtls(cricket::DtlsTransport *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __int128 v48;
  void (*v49)(uint64_t, __int128 *, __int128 *);
  uint64_t v50;
  std::string __p;
  void (*v52)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v53;

  v2 = operator new();
  v3 = *((_QWORD *)this + 60);
  *(_QWORD *)(v2 + 16) = sigslot::_signal_base<sigslot::single_threaded>::do_slot_duplicate;
  *(_QWORD *)(v2 + 24) = v2 + 24;
  *(_QWORD *)(v2 + 32) = v2 + 24;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = v2 + 24;
  *(_BYTE *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 80) = absl::internal_any_invocable::EmptyManager;
  *(_QWORD *)(v2 + 88) = 0;
  *(_QWORD *)v2 = &off_24C0B3418;
  *(_QWORD *)(v2 + 8) = sigslot::_signal_base<sigslot::single_threaded>::do_slot_disconnect;
  *(_QWORD *)(v2 + 96) = v3;
  *(_DWORD *)(v2 + 104) = 2;
  *(_OWORD *)(v2 + 112) = xmmword_208F08F40;
  *(_OWORD *)(v2 + 128) = 0u;
  *(_OWORD *)(v2 + 144) = 0u;
  *(_OWORD *)(v2 + 160) = 0u;
  *(_OWORD *)(v2 + 176) = 0u;
  *(_QWORD *)(v2 + 192) = 0;
  *(_QWORD *)&v48 = this;
  v4 = operator new();
  v53 = v2;
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v48;
  __p.__r_.__value_.__r.__words[2] = (std::string::size_type)absl::internal_any_invocable::LocalManagerTrivial;
  v52 = absl::internal_any_invocable::LocalInvoker<false,void,cricket::DtlsTransport::SetupDtls(void)::$_0 &,rtc::SSLHandshakeError>;
  v49 = (void (*)(uint64_t, __int128 *, __int128 *))absl::internal_any_invocable::EmptyManager;
  v50 = 0;
  rtc::OpenSSLStreamAdapter::OpenSSLStreamAdapter(v4, &v53, (uint64_t)&__p);
  ((void (*)(uint64_t, std::string *, std::string *))__p.__r_.__value_.__r.__words[2])(1, &__p, &__p);
  if (v53)
    (*(void (**)(uint64_t))(*(_QWORD *)v53 + 8))(v53);
  v5 = *((_QWORD *)this + 61);
  *((_QWORD *)this + 61) = v4;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v49(1, &v48, &v48);
  v6 = *((_QWORD *)this + 61);
  if (!v6)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0;
    cricket::DtlsTransport::ToString(&__p, (int *)this);
    rtc::webrtc_logging_impl::Log("\r\n\t", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return 0;
    goto LABEL_26;
  }
  *((_QWORD *)this + 62) = v2;
  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 67) + 8) + 48))(&v47);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v6 + 56))(v6, &v47);
  v7 = v47;
  v47 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 61) + 80))(*((_QWORD *)this + 61), 1);
  result = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 61) + 88))(*((_QWORD *)this + 61), *((unsigned int *)this + 138));
  if (!*((_BYTE *)this + 548))
    goto LABEL_35;
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 61) + 72))(*((_QWORD *)this + 61), *((unsigned int *)this + 136));
  v9 = *((_QWORD *)this + 61);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 80))(1, v9 + 64, v9 + 64);
  *(_QWORD *)(v9 + 64) = this;
  *(_QWORD *)(v9 + 80) = absl::internal_any_invocable::LocalManagerTrivial;
  *(_QWORD *)(v9 + 88) = absl::internal_any_invocable::LocalInvoker<false,void,cricket::DtlsTransport::SetupDtls(void)::$_1 &,int,int>;
  if (*((_QWORD *)this + 70))
  {
    result = *((_QWORD *)this + 61);
    v10 = (_QWORD *)((char *)this + 584);
    if ((*((char *)this + 607) & 0x80000000) == 0)
    {
      v11 = *((unsigned __int8 *)this + 607);
LABEL_18:
      if (((*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(*(_QWORD *)result + 112))(result, v10, v11, *((_QWORD *)this + 72)) & 1) != 0)goto LABEL_19;
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
        return 0;
      cricket::DtlsTransport::ToString(&__p, (int *)this);
      rtc::webrtc_logging_impl::Log("\r\n\t", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        return 0;
LABEL_26:
      operator delete(__p.__r_.__value_.__l.__data_);
      return 0;
    }
    v11 = *((_QWORD *)this + 74);
    if ((v11 & 0x8000000000000000) == 0)
    {
      v10 = (_QWORD *)*v10;
      if (!v11 || v10)
        goto LABEL_18;
    }
LABEL_35:
    __break(1u);
    return result;
  }
LABEL_19:
  if (*((_QWORD *)this + 63) == *((_QWORD *)this + 64))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      cricket::DtlsTransport::ToString(&__p, (int *)this);
      rtc::webrtc_logging_impl::Log("\r\n\t", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else if (((*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)this + 61) + 168))(*((_QWORD *)this + 61), (char *)this + 504) & 1) == 0)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0;
    cricket::DtlsTransport::ToString(&__p, (int *)this);
    rtc::webrtc_logging_impl::Log("\r\n\t", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return 0;
    goto LABEL_26;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    cricket::DtlsTransport::ToString(&__p, (int *)this);
    rtc::webrtc_logging_impl::Log("\r\n\t", v40, v41, v42, v43, v44, v45, v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  cricket::DtlsTransport::MaybeStartDtls(this);
  return 1;
}

uint64_t cricket::DtlsTransport::GetRemoteSSLCertChain@<X0>(cricket::DtlsTransport *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = *((_QWORD *)this + 61);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 120))(result);
  *a2 = 0;
  return result;
}

uint64_t cricket::DtlsTransport::ExportKeyingMaterial(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 488);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 152))(result);
  return result;
}

void cricket::DtlsTransport::MaybeStartDtls(cricket::DtlsTransport *this)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  size_t v40;
  const char *v41;
  const char *v42;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  std::string __p;

  if (!*((_QWORD *)this + 61)
    || !(*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 60) + 24))(*((_QWORD *)this + 60)))
  {
    return;
  }
  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 60) + 224))(*((_QWORD *)this + 60));
  if ((v2 & 0xFF00000000) != 0)
  {
    v3 = 2 * v2;
    if (2 * (int)v2 <= 50)
      v3 = 50;
    if ((int)v2 >= 1500)
      v4 = 3000;
    else
      v4 = v3;
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      cricket::DtlsTransport::ToString(&__p, (int *)this);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v5, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 61) + 96))(*((_QWORD *)this + 61), v4);
  }
  else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    cricket::DtlsTransport::ToString(&__p, (int *)this);
    rtc::webrtc_logging_impl::Log("\r\n\t", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 61) + 104))(*((_QWORD *)this + 61)))
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
    {
      cricket::DtlsTransport::ToString(&__p, (int *)this);
      rtc::webrtc_logging_impl::Log("\r\n\t", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    cricket::DtlsTransport::set_dtls_state((uint64_t)this, 4);
    return;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
  {
    cricket::DtlsTransport::ToString(&__p, (int *)this);
    (*(uint64_t (**)(cricket::DtlsTransport *))(*(_QWORD *)this + 96))(this);
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v26, v27, v28, v29, v30, v31, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  cricket::DtlsTransport::set_dtls_state((uint64_t)this, 1);
  if (*((_QWORD *)this + 76))
  {
    if (!*((_BYTE *)this + 548))
    {
      __break(1u);
      return;
    }
    if (*((_DWORD *)this + 136) == 1)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        cricket::DtlsTransport::ToString(&__p, (int *)this);
        rtc::webrtc_logging_impl::Log("\r\n\t", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      v40 = *((_QWORD *)this + 76);
      if (v40)
        v41 = (const char *)*((_QWORD *)this + 78);
      else
        v41 = 0;
      v42 = v41;
      v43 = *((_QWORD *)this + 76);
      while (v43)
      {
        if (v43 >= 0xD)
        {
          v44 = __rev16(*(unsigned __int16 *)(v42 + 11)) + 13;
          v42 += v44;
          v45 = v43 >= v44;
          v43 -= v44;
          if (v45)
            continue;
        }
        goto LABEL_42;
      }
      if (cricket::StreamInterfaceChannel::OnPacketReceived(*((cricket::StreamInterfaceChannel **)this + 62), v41, v40))
        goto LABEL_45;
LABEL_42:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
        goto LABEL_45;
    }
    else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
    {
LABEL_45:
      *((_QWORD *)this + 76) = 0;
      return;
    }
    cricket::DtlsTransport::ToString(&__p, (int *)this);
    rtc::webrtc_logging_impl::Log("\r\n\t", v46, v47, v48, v49, v50, v51, v52, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_45;
  }
}

uint64_t cricket::DtlsTransport::GetSrtpCryptoSuite(cricket::DtlsTransport *this, int *a2)
{
  if ((*(unsigned int (**)(cricket::DtlsTransport *))(*(_QWORD *)this + 80))(this) == 2)
    return (*(uint64_t (**)(_QWORD, int *))(**((_QWORD **)this + 61) + 176))(*((_QWORD *)this + 61), a2);
  else
    return 0;
}

uint64_t cricket::DtlsTransport::GetSslVersionBytes(cricket::DtlsTransport *this, int *a2)
{
  if ((*(unsigned int (**)(cricket::DtlsTransport *))(*(_QWORD *)this + 80))(this) == 2)
    return (*(uint64_t (**)(_QWORD, int *))(**((_QWORD **)this + 61) + 144))(*((_QWORD *)this + 61), a2);
  else
    return 0;
}

uint64_t cricket::DtlsTransport::GetSslPeerSignatureAlgorithm(cricket::DtlsTransport *this)
{
  if ((*(unsigned int (**)(cricket::DtlsTransport *))(*(_QWORD *)this + 80))(this) == 2)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 61) + 160))(*((_QWORD *)this + 61));
  else
    return 0;
}

unint64_t cricket::DtlsTransport::SendPacket(cricket::DtlsTransport *this, const char *a2, unint64_t a3, const rtc::PacketOptions *a4, char a5)
{
  int v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  std::string __p;
  int v30;

  if (!*((_BYTE *)this + 528))
    return (*(uint64_t (**)(_QWORD, const char *, unint64_t, const rtc::PacketOptions *, _QWORD))(**((_QWORD **)this + 60) + 40))(*((_QWORD *)this + 60), a2, a3, a4, 0);
  v10 = (*(uint64_t (**)(cricket::DtlsTransport *))(*(_QWORD *)this + 80))(this);
  if (v10 == 4)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0xFFFFFFFFLL;
    cricket::DtlsTransport::ToString(&__p, (int *)this);
    rtc::webrtc_logging_impl::Log("\r\n\t", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return 0xFFFFFFFFLL;
LABEL_19:
    operator delete(__p.__r_.__value_.__l.__data_);
    return 0xFFFFFFFFLL;
  }
  if (v10 == 3)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0xFFFFFFFFLL;
    cricket::DtlsTransport::ToString(&__p, (int *)this);
    rtc::webrtc_logging_impl::Log("\r\n\t", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return 0xFFFFFFFFLL;
    goto LABEL_19;
  }
  if (v10 != 2)
    return 0xFFFFFFFFLL;
  if ((a5 & 1) != 0)
  {
    if (a3 < 0xC || (*a2 & 0xC0) != 0x80)
      return 0xFFFFFFFFLL;
    return (*(uint64_t (**)(_QWORD, const char *, unint64_t, const rtc::PacketOptions *, _QWORD))(**((_QWORD **)this + 60) + 40))(*((_QWORD *)this + 60), a2, a3, a4, 0);
  }
  v30 = 0;
  if (a3)
    v11 = a2;
  else
    v11 = 0;
  if (!a3)
    return a3;
  v12 = 0;
  v13 = *((_QWORD *)this + 61);
  __p.__r_.__value_.__r.__words[0] = 0;
  while ((*(unsigned int (**)(uint64_t, const char *, unint64_t, std::string *, int *))(*(_QWORD *)v13 + 32))(v13, &v11[v12], a3 - v12, &__p, &v30) == 1)
  {
    v12 += __p.__r_.__value_.__r.__words[0];
    if (v12 >= a3)
      return a3;
  }
  return 0xFFFFFFFFLL;
}

uint64_t cricket::DtlsTransport::ice_transport(cricket::DtlsTransport *this)
{
  return *((_QWORD *)this + 60);
}

uint64_t cricket::DtlsTransport::receiving(cricket::DtlsTransport *this)
{
  return *((unsigned __int8 *)this + 632);
}

uint64_t cricket::DtlsTransport::writable(cricket::DtlsTransport *this)
{
  return *((unsigned __int8 *)this + 633);
}

uint64_t cricket::DtlsTransport::GetError(cricket::DtlsTransport *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 60) + 64))(*((_QWORD *)this + 60));
}

uint64_t cricket::DtlsTransport::network_route(cricket::DtlsTransport *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 60) + 72))(*((_QWORD *)this + 60));
}

uint64_t cricket::DtlsTransport::GetOption(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 480) + 56))(*(_QWORD *)(a1 + 480));
}

uint64_t cricket::DtlsTransport::SetOption(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 480) + 48))(*(_QWORD *)(a1 + 480));
}

void cricket::DtlsTransport::OnWritableState(cricket::DtlsTransport *this, rtc::PacketTransportInternal *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  std::string __p;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) != 0
    || (cricket::DtlsTransport::ToString(&__p, (int *)this),
        (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 60) + 24))(*((_QWORD *)this + 60)),
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc"), (SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0))
  {
    if (*((_BYTE *)this + 528))
      goto LABEL_4;
LABEL_8:
    v10 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 60) + 24))(*((_QWORD *)this + 60));
    cricket::DtlsTransport::set_writable((uint64_t)this, v10);
    return;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!*((_BYTE *)this + 528))
    goto LABEL_8;
LABEL_4:
  switch((*(unsigned int (**)(cricket::DtlsTransport *))(*(_QWORD *)this + 80))(this))
  {
    case 0u:
      cricket::DtlsTransport::MaybeStartDtls(this);
      return;
    case 2u:
      goto LABEL_8;
    case 3u:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      {
        cricket::DtlsTransport::ToString(&__p, (int *)this);
        rtc::webrtc_logging_impl::Log("\r\n\t", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_14;
      }
      return;
    case 4u:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      {
        cricket::DtlsTransport::ToString(&__p, (int *)this);
        rtc::webrtc_logging_impl::Log("\r\n\t", v18, v19, v20, v21, v22, v23, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
LABEL_14:
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      break;
    default:
      return;
  }
}

uint64_t cricket::DtlsTransport::OnSentPacket(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t, uint64_t);

  v4 = a1 + 240;
  result = *(_QWORD *)(a1 + 248);
  for (*(_QWORD *)(a1 + 264) = result; result != v4; result = *(_QWORD *)(a1 + 264))
  {
    v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(result + 16);
    v7 = result + 16;
    *(_QWORD *)(a1 + 264) = *(_QWORD *)(v7 - 8);
    v8(v7, a1, a3);
  }
  return result;
}

uint64_t cricket::DtlsTransport::OnReadyToSend(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  void (*v4)(uint64_t, _QWORD *);

  result = (*(uint64_t (**)(_QWORD *))(*a1 + 24))(a1);
  if ((_DWORD)result)
  {
    result = a1[17];
    for (a1[19] = result; (_QWORD *)result != a1 + 16; result = a1[19])
    {
      v4 = *(void (**)(uint64_t, _QWORD *))(result + 16);
      v3 = result + 16;
      a1[19] = *(_QWORD *)(v3 - 8);
      v4(v3, a1);
    }
  }
  return result;
}

_QWORD *cricket::DtlsTransport::OnReceivingState(cricket::DtlsTransport *this, rtc::PacketTransportInternal *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *result;
  _QWORD *v11;
  void (*v12)(_QWORD *, cricket::DtlsTransport *);
  std::string __p;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0
    && (cricket::DtlsTransport::ToString(&__p, (int *)this),
        (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 60) + 32))(*((_QWORD *)this + 60)),
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc"), SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0))
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (*((_BYTE *)this + 528))
    {
LABEL_4:
      result = (_QWORD *)(*(uint64_t (**)(cricket::DtlsTransport *))(*(_QWORD *)this + 80))(this);
      if ((_DWORD)result != 2)
        return result;
    }
  }
  else if (*((_BYTE *)this + 528))
  {
    goto LABEL_4;
  }
  result = (_QWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 60) + 32))(*((_QWORD *)this + 60));
  if (*((unsigned __int8 *)this + 632) != (_DWORD)result)
  {
    *((_BYTE *)this + 632) = (_BYTE)result;
    result = (_QWORD *)*((_QWORD *)this + 24);
    for (*((_QWORD *)this + 26) = result;
          result != (_QWORD *)((char *)this + 184);
          result = (_QWORD *)*((_QWORD *)this + 26))
    {
      v12 = (void (*)(_QWORD *, cricket::DtlsTransport *))result[2];
      v11 = result + 2;
      *((_QWORD *)this + 26) = *(v11 - 1);
      v12(v11, this);
    }
  }
  return result;
}

uint64_t cricket::DtlsTransport::OnNetworkRouteChanged(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  uint64_t result;
  void (*v5)(uint64_t, _OWORD *);
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  v6 = *a2;
  v7 = a2[1];
  v8 = *((_QWORD *)a2 + 4);
  v3 = a1 + 296;
  result = *(_QWORD *)(a1 + 304);
  for (*(_QWORD *)(a1 + 320) = result; result != v3; result = *(_QWORD *)(a1 + 320))
  {
    *(_QWORD *)(a1 + 320) = *(_QWORD *)(result + 8);
    v5 = *(void (**)(uint64_t, _OWORD *))(result + 16);
    v9[0] = v6;
    v9[1] = v7;
    v10 = v8;
    v5(result + 16, v9);
  }
  return result;
}

void cricket::StreamInterfaceChannel::~StreamInterfaceChannel(void (**this)(uint64_t, char *, char *))
{
  void (*i)(uint64_t, char *, char *);
  void (*v3)(uint64_t, char *, char *);
  uint64_t v4;
  uint64_t v5;

  *this = (void (*)(uint64_t, char *, char *))&off_24C0B3418;
  rtc::BufferQueue::~BufferQueue((rtc::BufferQueue *)(this + 14));
  *this = (void (*)(uint64_t, char *, char *))&unk_24C0C13F8;
  this[10](1, (char *)this + 64, (char *)this + 64);
  for (i = this[5]; i; i = this[5])
  {
    v3 = this[4];
    v4 = *((_QWORD *)v3 + 3);
    v5 = *(_QWORD *)v3;
    *(_QWORD *)(v5 + 8) = *((_QWORD *)v3 + 1);
    **((_QWORD **)v3 + 1) = v5;
    this[5] = (void (*)(uint64_t, char *, char *))((char *)i - 1);
    operator delete(v3);
    (*(void (**)(uint64_t, char *))(v4 + 16))(v4, (char *)this + 8);
  }
  this[6] = (void (*)(uint64_t, char *, char *))(this + 3);
}

{
  void (*i)(uint64_t, char *, char *);
  void (*v3)(uint64_t, char *, char *);
  uint64_t v4;
  uint64_t v5;

  *this = (void (*)(uint64_t, char *, char *))&off_24C0B3418;
  rtc::BufferQueue::~BufferQueue((rtc::BufferQueue *)(this + 14));
  *this = (void (*)(uint64_t, char *, char *))&unk_24C0C13F8;
  this[10](1, (char *)this + 64, (char *)this + 64);
  for (i = this[5]; i; i = this[5])
  {
    v3 = this[4];
    v4 = *((_QWORD *)v3 + 3);
    v5 = *(_QWORD *)v3;
    *(_QWORD *)(v5 + 8) = *((_QWORD *)v3 + 1);
    **((_QWORD **)v3 + 1) = v5;
    this[5] = (void (*)(uint64_t, char *, char *))((char *)i - 1);
    operator delete(v3);
    (*(void (**)(uint64_t, char *))(v4 + 16))(v4, (char *)this + 8);
  }
  this[6] = (void (*)(uint64_t, char *, char *))(this + 3);
  JUMPOUT(0x20BD0ADECLL);
}

void absl::internal_any_invocable::LocalInvoker<false,void,cricket::DtlsTransport::SetupDtls(void)::$_0 &,rtc::SSLHandshakeError>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  char v13;
  webrtc::callback_list_impl::CallbackListReceivers *v14;
  _BYTE *v15;
  std::string *v16;
  uint64_t v17;

  v8 = *a1;
  if (*(_BYTE *)(*a1 + 432))
  {
    v16 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/callback_list.cc", 72, "!send_in_progress_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v17);
    absl::internal_any_invocable::LocalInvoker<false,void,cricket::DtlsTransport::SetupDtls(void)::$_1 &,int,int>(v16);
  }
  else
  {
    v9 = (_BYTE *)(v8 + 432);
    *(_BYTE *)(v8 + 432) = 1;
    v10 = *(_QWORD *)(v8 + 408);
    v11 = *(_QWORD *)(v8 + 416);
    if (v10 == v11)
    {
      *v9 = 0;
    }
    else
    {
      v13 = 0;
      v14 = (webrtc::callback_list_impl::CallbackListReceivers *)(v8 + 408);
      do
      {
        (*(void (**)(uint64_t, uint64_t))(v10 + 40))(v10 + 8, a2);
        v15 = *(_BYTE **)v10;
        v10 += 56;
        v13 |= v15 == v9;
      }
      while (v10 != v11);
      *v9 = 0;
      if ((v13 & 1) != 0)
        webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers(v14, v9);
    }
  }
}

void absl::internal_any_invocable::LocalInvoker<false,void,cricket::DtlsTransport::SetupDtls(void)::$_1 &,int,int>(uint64_t *a1, char a2, int a3)
{
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  std::string *v21;
  _QWORD *v22;
  _QWORD *v23;
  char v24;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(uint64_t);
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char v59;
  int v60;
  std::string v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  __int16 v66;
  int v67;
  char v68;
  _QWORD v69[6];
  int v70;
  uint64_t v71;
  uint64_t v72;
  _QWORD v73[2];
  std::string __p[85];
  uint64_t v75;

  v4 = a2;
  v75 = *MEMORY[0x24BDAC8D0];
  v5 = *a1;
  if ((a2 & 1) != 0)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      cricket::DtlsTransport::ToString(__p, (int *)v5);
      rtc::webrtc_logging_impl::Log("\r\n\t", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v5 + 488) + 16))(*(_QWORD *)(v5 + 488)) == 2)
    {
      cricket::DtlsTransport::set_dtls_state(v5, 2);
      cricket::DtlsTransport::set_writable(v5, 1);
    }
  }
  if ((v4 & 2) == 0)
    goto LABEL_40;
  v59 = v4;
  v71 = 0;
  v70 = 0;
  v60 = a3;
  v13 = (_BYTE *)(v5 + 368);
  while (1)
  {
    v14 = (*(uint64_t (**)(_QWORD, std::string *, uint64_t, uint64_t *, int *))(**(_QWORD **)(v5 + 488) + 24))(*(_QWORD *)(v5 + 488), __p, 2048, &v71, &v70);
    if (v14 != 1)
      break;
    v15 = v71;
    memset(&v61, 0, sizeof(v61));
    v62 = &unk_24C0ACDA0;
    v68 = 0;
    v66 = 0;
    v67 = 0;
    v63 = 0;
    v64 = 0;
    v65 = 0;
    if (rtc::g_clock)
    {
      v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
    }
    else
    {
      if (!dword_253EA791C)
        mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
      v16 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
          / dword_253EA791C;
    }
    v21 = __p;
    if (!v15)
      v21 = 0;
    v69[0] = v21;
    v69[1] = v15;
    v69[2] = v16 / 1000;
    v69[3] = 1;
    v69[4] = &v61;
    v69[5] = 0x100000000;
    v72 = v5;
    v73[0] = &v72;
    v73[1] = v69;
    if (*(_BYTE *)(v5 + 368))
      rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/callback_list.cc", 72, "!send_in_progress_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v17, v18, v19, v20, v58);
    *(_BYTE *)(v5 + 368) = 1;
    v22 = *(_QWORD **)(v5 + 344);
    v23 = *(_QWORD **)(v5 + 352);
    if (v22 == v23)
    {
      *v13 = 0;
      if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_9;
    }
    else
    {
      v24 = 0;
      do
      {
        rtc::FunctionView<void ()(webrtc::UntypedFunction &)>::CallVoidPtr<void webrtc::CallbackList<rtc::PacketTransportInternal *,rtc::ReceivedPacket const&>::Send<rtc::PacketTransportInternal *,rtc::ReceivedPacket const&>(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)::{lambda(webrtc::UntypedFunction &)#1}>((uint64_t)v73, (uint64_t)(v22 + 1));
        v25 = (_BYTE *)*v22;
        v22 += 7;
        v24 |= v25 == v13;
      }
      while (v22 != v23);
      *v13 = 0;
      if ((v24 & 1) != 0)
        webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers((webrtc::callback_list_impl::CallbackListReceivers *)(v5 + 344), (const void *)(v5 + 368));
      if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
LABEL_9:
        operator delete(v61.__r_.__value_.__l.__data_);
    }
  }
  if (v14)
  {
    a3 = v60;
    v4 = v59;
    if (v14 == 3)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        cricket::DtlsTransport::ToString(&v61, (int *)v5);
        rtc::webrtc_logging_impl::Log("\r\n\t", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
        if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v61.__r_.__value_.__l.__data_);
      }
      v33 = 3;
      goto LABEL_38;
    }
  }
  else
  {
    a3 = v60;
    v4 = v59;
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    {
      cricket::DtlsTransport::ToString(&v61, (int *)v5);
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v34, v35, v36, v37, v38, v39, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v61.__r_.__value_.__l.__data_);
    }
    v33 = 4;
LABEL_38:
    cricket::DtlsTransport::set_writable(v5, 0);
    cricket::DtlsTransport::set_dtls_state(v5, v33);
    v41 = *(void (**)(uint64_t))(v5 + 400);
    if (v41)
    {
      v41(v5 + 376);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 392))(1, v5 + 376, v5 + 376);
      *(_QWORD *)(v5 + 392) = absl::internal_any_invocable::EmptyManager;
      *(_QWORD *)(v5 + 400) = 0;
    }
  }
LABEL_40:
  if ((v4 & 8) != 0)
  {
    cricket::DtlsTransport::set_writable(v5, 0);
    v42 = rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>();
    if (a3)
    {
      if ((v42 & 1) == 0)
      {
        cricket::DtlsTransport::ToString(__p, (int *)v5);
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v43, v44, v45, v46, v47, v48, v49, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p[0].__r_.__value_.__l.__data_);
      }
      v50 = 4;
    }
    else
    {
      if ((v42 & 1) == 0)
      {
        cricket::DtlsTransport::ToString(__p, (int *)v5);
        rtc::webrtc_logging_impl::Log("\r\n\t", v51, v52, v53, v54, v55, v56, v57, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p[0].__r_.__value_.__l.__data_);
      }
      v50 = 3;
    }
    cricket::DtlsTransport::set_dtls_state(v5, v50);
  }
}

uint64_t sigslot::_opaque_connection::emitter<cricket::DtlsTransport,rtc::PacketTransportInternal *>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  _QWORD *v3;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = (_QWORD *)(a1[1] + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v3 + v1);
  return v1(v3);
}

void absl::internal_any_invocable::LocalInvoker<false,void,cricket::DtlsTransport::ConnectToIceTransport(void)::$_0 &,rtc::PacketTransportInternal *,rtc::ReceivedPacket const&>(_QWORD *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  size_t v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  _BYTE *v16;
  _QWORD *v17;
  _QWORD *v18;
  char v19;
  webrtc::callback_list_impl::CallbackListReceivers *v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unsigned __int8 *v30;
  int v31;
  _QWORD *v32;
  _QWORD *v33;
  _BYTE *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  size_t v63;
  unsigned __int8 *v64;
  size_t v65;
  size_t v66;
  size_t v67;
  void *v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  std::string *v86;
  uint64_t v87;
  void *__p;
  unsigned __int8 **v89;
  __int128 v90;
  unsigned __int8 *v91;
  int v92;
  int v93;
  uint64_t v94;
  _QWORD v95[2];

  v9 = *a1;
  if (!*(_BYTE *)(*a1 + 528))
  {
    v95[0] = *a1;
    __p = v95;
    v89 = a3;
    if (!*(_BYTE *)(v9 + 368))
    {
      v16 = (_BYTE *)(v9 + 368);
      *(_BYTE *)(v9 + 368) = 1;
      v17 = *(_QWORD **)(v9 + 344);
      v18 = *(_QWORD **)(v9 + 352);
      if (v17 != v18)
      {
        v19 = 0;
        v20 = (webrtc::callback_list_impl::CallbackListReceivers *)(v9 + 344);
        do
        {
          rtc::FunctionView<void ()(webrtc::UntypedFunction &)>::CallVoidPtr<void webrtc::CallbackList<rtc::PacketTransportInternal *,rtc::ReceivedPacket const&>::Send<rtc::PacketTransportInternal *,rtc::ReceivedPacket const&>(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)::{lambda(webrtc::UntypedFunction &)#1}>((uint64_t)&__p, (uint64_t)(v17 + 1));
          v21 = (_BYTE *)*v17;
          v17 += 7;
          v19 |= v21 == v16;
        }
        while (v17 != v18);
LABEL_14:
        *v16 = 0;
        if ((v19 & 1) != 0)
          webrtc::callback_list_impl::CallbackListReceivers::RemoveReceivers(v20, v16);
        return;
      }
LABEL_30:
      *v16 = 0;
      return;
    }
LABEL_67:
    v86 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/callback_list.cc", 72, "!send_in_progress_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v87);
    sigslot::_opaque_connection::emitter<cricket::DtlsTransport,rtc::PacketTransportInternal *,rtc::SentPacket const&>(v86);
    return;
  }
  v10 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v9 + 80))(*a1);
  if ((v10 - 1) >= 2)
  {
    if (v10)
      return;
    if (*(_QWORD *)(v9 + 488))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
        goto LABEL_40;
      cricket::DtlsTransport::ToString((std::string *)&__p, (int *)v9);
      rtc::webrtc_logging_impl::Log("\r\n\t", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if ((SBYTE7(v90) & 0x80000000) == 0)
        goto LABEL_40;
    }
    else
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        goto LABEL_40;
      cricket::DtlsTransport::ToString((std::string *)&__p, (int *)v9);
      rtc::webrtc_logging_impl::Log("\r\n\t", v49, v50, v51, v52, v53, v54, v55, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if ((SBYTE7(v90) & 0x80000000) == 0)
        goto LABEL_40;
    }
    operator delete(__p);
LABEL_40:
    if ((unint64_t)a3[1] >= 0x12 && **a3 == 22 && (*a3)[13] == 1)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      {
        cricket::DtlsTransport::ToString((std::string *)&__p, (int *)v9);
        rtc::webrtc_logging_impl::Log("\r\n\t", v56, v57, v58, v59, v60, v61, v62, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
        if (SBYTE7(v90) < 0)
          operator delete(__p);
      }
      v64 = *a3;
      v63 = (size_t)a3[1];
      *(_QWORD *)(v9 + 608) = 0;
      if (v63)
      {
        v65 = *(_QWORD *)(v9 + 616);
        if (v65 >= v63)
        {
          v85 = 0;
        }
        else
        {
          v66 = v65 + (v65 >> 1);
          if (v66 <= v63)
            v67 = v63;
          else
            v67 = v66;
          v68 = (void *)operator new[]();
          v69 = v68;
          v70 = *(_QWORD *)(v9 + 624);
          if (v70)
          {
            memcpy(v68, *(const void **)(v9 + 624), *(_QWORD *)(v9 + 608));
            *(_QWORD *)(v9 + 624) = v69;
            MEMORY[0x20BD0ADD4](v70, 0x1000C8077774924);
          }
          else
          {
            *(_QWORD *)(v9 + 624) = v68;
          }
          *(_QWORD *)(v9 + 616) = v67;
          v85 = *(_QWORD *)(v9 + 608);
        }
        memcpy((void *)(*(_QWORD *)(v9 + 624) + v85), v64, v63);
        *(_QWORD *)(v9 + 608) = v63;
      }
      if (!*(_QWORD *)(v9 + 488) && *(_QWORD *)(v9 + 536))
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 112))(v9, 1);
        cricket::DtlsTransport::SetupDtls((cricket::DtlsTransport *)v9);
      }
      return;
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
      return;
    cricket::DtlsTransport::ToString((std::string *)&__p, (int *)v9);
    rtc::webrtc_logging_impl::Log("\r\n\t", v71, v72, v73, v74, v75, v76, v77, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if ((SBYTE7(v90) & 0x80000000) == 0)
      return;
    goto LABEL_59;
  }
  v11 = (size_t)a3[1];
  if (v11 < 0xD || **a3 - 20 > 0x2B)
  {
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v9 + 80))(v9) == 2)
    {
      v29 = (unint64_t)a3[1];
      if (v29 >= 0xC && (**a3 & 0xC0) == 0x80)
      {
        v30 = a3[4];
        v31 = *((_DWORD *)a3 + 10);
        __p = *a3;
        v89 = (unsigned __int8 **)v29;
        v90 = *((_OWORD *)a3 + 1);
        v91 = v30;
        v92 = v31;
        v93 = 2;
        v94 = v9;
        v95[0] = &v94;
        v95[1] = &__p;
        if (!*(_BYTE *)(v9 + 368))
        {
          v16 = (_BYTE *)(v9 + 368);
          *(_BYTE *)(v9 + 368) = 1;
          v32 = *(_QWORD **)(v9 + 344);
          v33 = *(_QWORD **)(v9 + 352);
          if (v32 != v33)
          {
            v19 = 0;
            v20 = (webrtc::callback_list_impl::CallbackListReceivers *)(v9 + 344);
            do
            {
              rtc::FunctionView<void ()(webrtc::UntypedFunction &)>::CallVoidPtr<void webrtc::CallbackList<rtc::PacketTransportInternal *,rtc::ReceivedPacket const&>::Send<rtc::PacketTransportInternal *,rtc::ReceivedPacket const&>(rtc::PacketTransportInternal *,rtc::ReceivedPacket const&)::{lambda(webrtc::UntypedFunction &)#1}>((uint64_t)v95, (uint64_t)(v32 + 1));
              v34 = (_BYTE *)*v32;
              v32 += 7;
              v19 |= v34 == v16;
            }
            while (v32 != v33);
            goto LABEL_14;
          }
          goto LABEL_30;
        }
        goto LABEL_67;
      }
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
        return;
      cricket::DtlsTransport::ToString((std::string *)&__p, (int *)v9);
      rtc::webrtc_logging_impl::Log("\r\n\t", v42, v43, v44, v45, v46, v47, v48, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if ((SBYTE7(v90) & 0x80000000) == 0)
        return;
    }
    else
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
        return;
      cricket::DtlsTransport::ToString((std::string *)&__p, (int *)v9);
      rtc::webrtc_logging_impl::Log("\r\n\t", v35, v36, v37, v38, v39, v40, v41, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
      if ((SBYTE7(v90) & 0x80000000) == 0)
        return;
    }
LABEL_59:
    operator delete(__p);
    return;
  }
  v12 = (char *)*a3;
  v13 = (unint64_t)a3[1];
  while (v13)
  {
    if (v13 >= 0xD)
    {
      v14 = __rev16(*(unsigned __int16 *)(v12 + 11)) + 13;
      v12 += v14;
      v15 = v13 >= v14;
      v13 -= v14;
      if (v15)
        continue;
    }
    goto LABEL_57;
  }
  if (cricket::StreamInterfaceChannel::OnPacketReceived(*(cricket::StreamInterfaceChannel **)(v9 + 496), (const char *)*a3, v11))
  {
    return;
  }
LABEL_57:
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
  {
    cricket::DtlsTransport::ToString((std::string *)&__p, (int *)v9);
    rtc::webrtc_logging_impl::Log("\r\n\t", v78, v79, v80, v81, v82, v83, v84, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/dtls_transport.cc");
    if (SBYTE7(v90) < 0)
      goto LABEL_59;
  }
}

uint64_t sigslot::_opaque_connection::emitter<cricket::DtlsTransport,rtc::PacketTransportInternal *,rtc::SentPacket const&>(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  _QWORD *v3;

  v1 = (uint64_t (*)(_QWORD *))a1[2];
  v2 = a1[3];
  v3 = (_QWORD *)(a1[1] + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v3 + v1);
  return v1(v3);
}

uint64_t sigslot::_opaque_connection::emitter<cricket::DtlsTransport,std::optional<rtc::NetworkRoute>>(_QWORD *a1, uint64_t a2)
{
  uint64_t (*v2)(_QWORD *, _OWORD *);
  uint64_t v3;
  _QWORD *v4;
  __int128 v5;
  _OWORD v7[2];
  uint64_t v8;

  v2 = (uint64_t (*)(_QWORD *, _OWORD *))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _OWORD *))(*v4 + v2);
  v5 = *(_OWORD *)(a2 + 16);
  v7[0] = *(_OWORD *)a2;
  v7[1] = v5;
  v8 = *(_QWORD *)(a2 + 32);
  return v2(v4, v7);
}

void cricket::DtlsTransportInternal::~DtlsTransportInternal(cricket::DtlsTransportInternal *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void (*v12)(uint64_t);
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void (*v16)(uint64_t);
  std::string *v17;
  uint64_t v18;

  *(_QWORD *)this = off_24C0B3580;
  if (*((_BYTE *)this + 464))
    goto LABEL_20;
  v9 = *((_QWORD *)this + 55);
  if (v9)
  {
    v10 = *((_QWORD *)this + 56);
    v11 = (void *)*((_QWORD *)this + 55);
    if (v10 != v9)
    {
      do
      {
        v12 = *(void (**)(uint64_t))(v10 - 8);
        if (v12)
          v12(v10 - 48);
        v10 -= 56;
      }
      while (v10 != v9);
      v11 = (void *)*((_QWORD *)this + 55);
    }
    *((_QWORD *)this + 56) = v9;
    operator delete(v11);
  }
  if (*((_BYTE *)this + 432))
  {
LABEL_20:
    v17 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/callback_list.cc", 21, "!send_in_progress_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v18);
    cricket::DtlsTransportInternal::~DtlsTransportInternal((cricket::DtlsTransportInternal *)v17);
  }
  v13 = *((_QWORD *)this + 51);
  if (v13)
  {
    v14 = *((_QWORD *)this + 52);
    v15 = (void *)*((_QWORD *)this + 51);
    if (v14 != v13)
    {
      do
      {
        v16 = *(void (**)(uint64_t))(v14 - 8);
        if (v16)
          v16(v14 - 48);
        v14 -= 56;
      }
      while (v14 != v13);
      v15 = (void *)*((_QWORD *)this + 51);
    }
    *((_QWORD *)this + 52) = v13;
    operator delete(v15);
  }
  rtc::PacketTransportInternal::~PacketTransportInternal((void (**)(uint64_t, char *, char *))this);
}

void webrtc::DtmfBuffer::~DtmfBuffer(webrtc::DtmfBuffer *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;

  *(_QWORD *)this = &off_24C0B3660;
  if (*((_QWORD *)this + 4))
  {
    v2 = (char *)this + 16;
    v4 = *((_QWORD *)this + 2);
    v3 = (char *)*((_QWORD *)this + 3);
    v5 = *(_QWORD *)v3;
    *(_QWORD *)(v5 + 8) = *(_QWORD *)(v4 + 8);
    **(_QWORD **)(v4 + 8) = v5;
    *((_QWORD *)this + 4) = 0;
    if (v3 != (char *)this + 16)
    {
      do
      {
        v6 = (char *)*((_QWORD *)v3 + 1);
        operator delete(v3);
        v3 = v6;
      }
      while (v6 != v2);
    }
  }
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;

  *(_QWORD *)this = &off_24C0B3660;
  if (*((_QWORD *)this + 4))
  {
    v2 = (char *)this + 16;
    v4 = *((_QWORD *)this + 2);
    v3 = (char *)*((_QWORD *)this + 3);
    v5 = *(_QWORD *)v3;
    *(_QWORD *)(v5 + 8) = *(_QWORD *)(v4 + 8);
    **(_QWORD **)(v4 + 8) = v5;
    *((_QWORD *)this + 4) = 0;
    if (v3 != (char *)this + 16)
    {
      do
      {
        v6 = (char *)*((_QWORD *)v3 + 1);
        operator delete(v3);
        v3 = v6;
      }
      while (v6 != v2);
    }
  }
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *webrtc::DtmfBuffer::Flush(_QWORD *this)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  if (this[4])
  {
    v1 = this;
    v2 = this + 2;
    this = (_QWORD *)this[3];
    v3 = v1[2];
    v4 = *this;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(v3 + 8);
    **(_QWORD **)(v3 + 8) = v4;
    v1[4] = 0;
    if (this != v2)
    {
      do
      {
        v5 = (_QWORD *)this[1];
        operator delete(this);
        this = v5;
      }
      while (v5 != v2);
    }
  }
  return this;
}

uint64_t webrtc::DtmfBuffer::InsertEvent(_QWORD *a1, uint64_t a2)
{
  unsigned int v2;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t *v14;
  uint64_t v15;
  _OWORD *v17;
  uint64_t v18;
  uint64_t **v19;
  unint64_t v20;
  int v21;
  unsigned int (*v22)(uint64_t, uint64_t);

  v2 = *(_DWORD *)(a2 + 4);
  if (v2 <= 0xF && *(_DWORD *)(a2 + 8) <= 0x3Fu)
  {
    v4 = *(_DWORD *)(a2 + 12);
    if ((v4 - 0x10000) > 0xFFFF0000)
    {
      v14 = a1 + 2;
      v15 = a1[3];
      if ((_QWORD *)v15 == a1 + 2)
      {
LABEL_13:
        v17 = operator new(0x28uLL);
        v17[1] = *(_OWORD *)a2;
        *((_DWORD *)v17 + 8) = *(_DWORD *)(a2 + 16);
        v18 = a1[2];
        *(_QWORD *)v17 = v18;
        *((_QWORD *)v17 + 1) = v14;
        *(_QWORD *)(v18 + 8) = v17;
        a1[2] = v17;
        v19 = (uint64_t **)a1[3];
        v20 = a1[4] + 1;
        a1[4] = v20;
        v22 = (unsigned int (*)(uint64_t, uint64_t))webrtc::DtmfBuffer::CompareEvents;
        std::list<webrtc::DtmfEvent>::__sort<BOOL (*)(webrtc::DtmfEvent const&,webrtc::DtmfEvent const&)>(v19, v14, v20, &v22);
      }
      else
      {
        while (*(_DWORD *)(v15 + 20) != v2 || *(_DWORD *)(v15 + 16) != *(_DWORD *)a2)
        {
          v15 = *(_QWORD *)(v15 + 8);
          if ((uint64_t *)v15 == v14)
            goto LABEL_13;
        }
        if (!*(_BYTE *)(v15 + 32))
        {
          v21 = *(_DWORD *)(v15 + 28);
          if (v4 > v21)
            v21 = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(v15 + 28) = v21;
        }
        if (*(_BYTE *)(a2 + 16))
        {
          result = 0;
          *(_BYTE *)(v15 + 32) = 1;
          return result;
        }
      }
      return 0;
    }
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/dtmf_buffer.cc");
  return 3;
}

BOOL webrtc::DtmfBuffer::CompareEvents(_DWORD *a1, _DWORD *a2)
{
  if (*a2 == *a1)
    return a1[1] < a2[1];
  else
    return (*a2 - *a1) < 0x7FFFFFFF;
}

uint64_t webrtc::DtmfBuffer::GetEvent(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t result;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  char v12;
  uint64_t v14;
  unsigned int v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v4 = a1 + 16;
  result = *(_QWORD *)(a1 + 24);
  if (result == v4)
    return 0;
  while (1)
  {
    v8 = *(_DWORD *)(result + 16);
    v9 = *(_DWORD *)(result + 28);
    v10 = v9 + v8;
    v11 = *(unsigned __int8 *)(result + 32);
    if (!*(_BYTE *)(result + 32))
    {
      v10 += *(_DWORD *)(a1 + 8);
      v14 = *(_QWORD *)(result + 8);
      if (v14 != v4)
        break;
    }
    v12 = 0;
    if (v8 <= a2 && v10 >= a2)
      goto LABEL_23;
LABEL_18:
    if (v10 >= a2)
    {
      result = *(_QWORD *)(result + 8);
      if (result == v4)
        return 0;
    }
    else
    {
      if ((v12 & 1) == 0)
      {
        if (a3)
        {
          *(_BYTE *)(a3 + 16) = v11;
          *(_QWORD *)(a3 + 4) = *(_QWORD *)(result + 20);
          *(_DWORD *)(a3 + 12) = v9;
          *(_DWORD *)a3 = v8;
        }
        goto LABEL_30;
      }
      if (result == v4)
        goto LABEL_32;
      v17 = *(_QWORD *)result;
      v18 = *(_QWORD *)(result + 8);
      *(_QWORD *)(v17 + 8) = v18;
      **(_QWORD **)(result + 8) = v17;
      --*(_QWORD *)(a1 + 32);
      operator delete((void *)result);
      result = v18;
      if (v18 == v4)
        return 0;
    }
  }
  v15 = *(_DWORD *)(v14 + 16);
  if (v15 < v10)
    v10 = v15;
  v12 = 1;
  if (v8 > a2 || v10 < a2)
    goto LABEL_18;
LABEL_23:
  if (a3)
  {
    *(_BYTE *)(a3 + 16) = v11;
    *(_QWORD *)(a3 + 4) = *(_QWORD *)(result + 20);
    *(_DWORD *)(a3 + 12) = v9;
    *(_DWORD *)a3 = v8;
    v11 = *(unsigned __int8 *)(result + 32);
  }
  if (!v11 || *(_DWORD *)(a1 + 12) + a2 < v10)
    return 1;
LABEL_30:
  if (result != v4)
  {
    v19 = *(_QWORD *)result;
    *(_QWORD *)(v19 + 8) = *(_QWORD *)(result + 8);
    **(_QWORD **)(result + 8) = v19;
    --*(_QWORD *)(a1 + 32);
    operator delete((void *)result);
    return 1;
  }
LABEL_32:
  __break(1u);
  return result;
}

uint64_t webrtc::DtmfBuffer::Length(webrtc::DtmfBuffer *this)
{
  return *((_QWORD *)this + 4);
}

BOOL webrtc::DtmfBuffer::Empty(webrtc::DtmfBuffer *this)
{
  return *((_QWORD *)this + 4) == 0;
}

uint64_t webrtc::DtmfBuffer::SetSampleRate(webrtc::DtmfBuffer *this, int a2)
{
  uint64_t result;

  result = 4;
  if (a2 <= 31999)
  {
    if (a2 != 8000 && a2 != 16000)
      return result;
LABEL_7:
    result = 0;
    *((_DWORD *)this + 2) = 7 * a2 / 0x64u;
    *((_DWORD *)this + 3) = (unsigned __int16)a2 / 0x64u;
    return result;
  }
  if (a2 == 48000 || a2 == 32000)
    goto LABEL_7;
  return result;
}

uint64_t *std::list<webrtc::DtmfEvent>::__sort<BOOL (*)(webrtc::DtmfEvent const&,webrtc::DtmfEvent const&)>(uint64_t **a1, uint64_t *a2, unint64_t a3, unsigned int (**a4)(uint64_t, uint64_t))
{
  uint64_t **v4;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v11;
  unint64_t v12;
  uint64_t **v13;
  uint64_t **v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;

  v4 = a1;
  if (a3 < 2)
    return (uint64_t *)v4;
  if (a3 == 2)
  {
    v7 = (uint64_t *)*a2;
    if ((*a4)(*a2 + 16, (uint64_t)(a1 + 2)))
    {
      v8 = *v7;
      *(_QWORD *)(v8 + 8) = v7[1];
      *(_QWORD *)v7[1] = v8;
      v9 = *v4;
      v9[1] = (uint64_t)v7;
      *v7 = (uint64_t)v9;
      *v4 = v7;
      v7[1] = (uint64_t)v4;
      return v7;
    }
    return (uint64_t *)v4;
  }
  v11 = a3 >> 1;
  v12 = (a3 >> 1) + 1;
  v13 = a1;
  do
  {
    v13 = (uint64_t **)v13[1];
    --v12;
  }
  while (v12 > 1);
  v14 = (uint64_t **)std::list<webrtc::DtmfEvent>::__sort<BOOL (*)(webrtc::DtmfEvent const&,webrtc::DtmfEvent const&)>(a1, v13, a3 >> 1, a4);
  v4 = (uint64_t **)std::list<webrtc::DtmfEvent>::__sort<BOOL (*)(webrtc::DtmfEvent const&,webrtc::DtmfEvent const&)>(v13, a2, a3 - v11, a4);
  if (!(*a4)((uint64_t)(v4 + 2), (uint64_t)(v14 + 2)))
  {
    v19 = v14[1];
    v15 = (uint64_t *)v4;
    v4 = v14;
    if (v19 == v15)
      return (uint64_t *)v4;
    goto LABEL_15;
  }
  v15 = v4[1];
  if (v15 == a2)
  {
LABEL_11:
    v15 = a2;
  }
  else
  {
    while ((*a4)((uint64_t)(v15 + 2), (uint64_t)(v14 + 2)))
    {
      v15 = (uint64_t *)v15[1];
      if (v15 == a2)
        goto LABEL_11;
    }
  }
  v16 = *v15;
  v17 = *v4;
  v17[1] = *(_QWORD *)(*v15 + 8);
  **(_QWORD **)(v16 + 8) = v17;
  v18 = *v14;
  v19 = v14[1];
  v18[1] = (uint64_t)v4;
  *v4 = v18;
  *v14 = (uint64_t *)v16;
  *(_QWORD *)(v16 + 8) = v14;
  if (v19 != v15)
  {
LABEL_15:
    if (v15 != a2)
    {
      v20 = v15;
      while (1)
      {
        if ((*a4)((uint64_t)(v15 + 2), (uint64_t)(v19 + 2)))
        {
          v21 = (uint64_t *)v15[1];
          if (v21 == a2)
          {
LABEL_21:
            v21 = a2;
          }
          else
          {
            while ((*a4)((uint64_t)(v21 + 2), (uint64_t)(v19 + 2)))
            {
              v21 = (uint64_t *)v21[1];
              if (v21 == a2)
                goto LABEL_21;
            }
          }
          v22 = *v21;
          v23 = *v15;
          *(_QWORD *)(v23 + 8) = *(_QWORD *)(*v21 + 8);
          **(_QWORD **)(v22 + 8) = v23;
          if (v20 == v15)
            v20 = v21;
          v25 = *v19;
          v24 = (uint64_t *)v19[1];
          *(_QWORD *)(v25 + 8) = v15;
          *v15 = v25;
          *v19 = v22;
          *(_QWORD *)(v22 + 8) = v19;
          v19 = v24;
          v15 = v21;
          if (v24 == v20)
            return (uint64_t *)v4;
        }
        else
        {
          v19 = (uint64_t *)v19[1];
          if (v19 == v20)
            return (uint64_t *)v4;
        }
        if (v15 == a2)
          return (uint64_t *)v4;
      }
    }
  }
  return (uint64_t *)v4;
}

uint64_t webrtc::DtmfSender::RegisterObserver(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = a2;
  return result;
}

uint64_t webrtc::DtmfSender::UnregisterObserver(uint64_t this)
{
  *(_QWORD *)(this + 8) = 0;
  return this;
}

uint64_t (***webrtc::DtmfSender::CanInsertDtmf(webrtc::DtmfSender *this))(_QWORD)
{
  uint64_t (***result)(_QWORD);

  result = (uint64_t (***)(_QWORD))*((_QWORD *)this + 3);
  if (result)
    return (uint64_t (***)(_QWORD))(**result)(result);
  return result;
}

uint64_t webrtc::DtmfSender::InsertDtmf(uint64_t a1, __int128 *a2, int a3, int a4, int a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v19;
  std::string *v20;
  char v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const std::string::value_type *v32;
  size_t v33;
  uint64_t v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  _QWORD *v42;
  char v44;
  _QWORD v45[2];
  uint64_t (*v46)(uint64_t, uint64_t *, _QWORD *);
  uint64_t (*v47)(uint64_t);
  char v48;

  if ((a3 - 6001) >= 0xFFFFE8B7 && a4 >= 30 && a5 > 29)
  {
    v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    if ((v19 & 1) != 0)
    {
      v20 = (std::string *)(a1 + 32);
      if ((__int128 *)(a1 + 32) != a2)
      {
        v21 = *((_BYTE *)a2 + 23);
        if ((*(char *)(a1 + 55) & 0x80000000) == 0)
        {
          if ((*((_BYTE *)a2 + 23) & 0x80) != 0)
          {
            std::string::__assign_no_alias<true>(v20, *(char **)a2, *((_QWORD *)a2 + 1));
            *(_DWORD *)(a1 + 56) = a3;
            *(_DWORD *)(a1 + 60) = a4;
            *(_DWORD *)(a1 + 64) = a5;
            v23 = *(_QWORD *)(a1 + 72);
            if (!v23)
              goto LABEL_30;
          }
          else
          {
            v22 = *a2;
            *(_QWORD *)(a1 + 48) = *((_QWORD *)a2 + 2);
            *(_OWORD *)&v20->__r_.__value_.__l.__data_ = v22;
            *(_DWORD *)(a1 + 56) = a3;
            *(_DWORD *)(a1 + 60) = a4;
            *(_DWORD *)(a1 + 64) = a5;
            v23 = *(_QWORD *)(a1 + 72);
            if (!v23)
              goto LABEL_30;
          }
          goto LABEL_29;
        }
        if (v21 >= 0)
          v32 = (const std::string::value_type *)a2;
        else
          v32 = *(const std::string::value_type **)a2;
        if (v21 >= 0)
          v33 = *((unsigned __int8 *)a2 + 23);
        else
          v33 = *((_QWORD *)a2 + 1);
        std::string::__assign_no_alias<false>(v20, v32, v33);
      }
      *(_DWORD *)(a1 + 56) = a3;
      *(_DWORD *)(a1 + 60) = a4;
      *(_DWORD *)(a1 + 64) = a5;
      v23 = *(_QWORD *)(a1 + 72);
      if (!v23)
      {
LABEL_30:
        v34 = operator new();
        v35 = (unsigned int *)v34;
        *(_DWORD *)v34 = 0;
        *(_BYTE *)(v34 + 4) = 1;
        do
          v36 = __ldxr((unsigned int *)v34);
        while (__stxr(v36 + 1, (unsigned int *)v34));
        v37 = *(unsigned int **)(a1 + 72);
        *(_QWORD *)(a1 + 72) = v35;
        if (v37)
        {
          do
          {
            v38 = __ldaxr(v37);
            v39 = v38 - 1;
          }
          while (__stlxr(v39, v37));
          if (!v39)
            MEMORY[0x20BD0ADEC]();
          v35 = *(unsigned int **)(a1 + 72);
          v40 = *(_QWORD *)(a1 + 16);
          if (!v35)
            goto LABEL_40;
        }
        else
        {
          v40 = *(_QWORD *)(a1 + 16);
        }
        do
          v41 = __ldxr(v35);
        while (__stxr(v41 + 1, v35));
LABEL_40:
        v42 = (_QWORD *)operator new();
        *v42 = v35;
        v42[1] = a1;
        v42[3] = absl::internal_any_invocable::LocalManagerTrivial;
        v42[4] = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DtmfSender::QueueInsertDtmf::$_0 &&>;
        v31 = 1;
        v48 = 1;
        v45[0] = v42;
        v46 = _ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
        v47 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
        (*(void (**)(uint64_t, _QWORD *, uint64_t, char *, char *))(*(_QWORD *)v40 + 16))(v40, v45, 1000, &v48, &v44);
        v46(1, v45, v45);
        return v31;
      }
LABEL_29:
      *(_BYTE *)(v23 + 4) = 0;
      goto LABEL_30;
    }
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
      return 0;
    rtc::webrtc_logging_impl::Log("\r\t", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtmf_sender.cc");
    return 0;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
  {
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v7, v8, v9, v10, v11, v12, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtmf_sender.cc");
    return 0;
  }
  return 0;
}

void webrtc::DtmfSender::tones(webrtc::DtmfSender *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 55) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 4), *((_QWORD *)this + 5));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *((_OWORD *)this + 2);
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)this + 6);
  }
}

uint64_t webrtc::DtmfSender::duration(webrtc::DtmfSender *this)
{
  return *((unsigned int *)this + 14);
}

uint64_t webrtc::DtmfSender::inter_tone_gap(webrtc::DtmfSender *this)
{
  return *((unsigned int *)this + 15);
}

uint64_t webrtc::DtmfSender::comma_delay(webrtc::DtmfSender *this)
{
  return *((unsigned int *)this + 16);
}

uint64_t webrtc::DtmfSenderInterface::InsertDtmf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, a2, a3, a4, 2000);
}

void std::string::__erase_external_with_move(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  int v4;
  std::string::size_type size;
  std::string *v6;
  std::string::size_type v7;
  std::string::size_type v8;
  std::string::size_type v9;

  if (!__n)
    return;
  v4 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if (v4 < 0)
  {
    v6 = (std::string *)this->__r_.__value_.__r.__words[0];
    size = this->__r_.__value_.__l.__size_;
    v7 = size - __pos;
    if (size - __pos >= __n)
      v8 = __n;
    else
      v8 = size - __pos;
    if (size - __pos <= __n)
      goto LABEL_8;
  }
  else
  {
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v6 = this;
    v7 = size - __pos;
    if (size - __pos >= __n)
      v8 = __n;
    else
      v8 = HIBYTE(this->__r_.__value_.__r.__words[2]) - __pos;
    if (v7 <= __n)
      goto LABEL_8;
  }
  memmove((char *)v6 + __pos, (char *)v6 + __pos + v8, v7 - v8);
  LOBYTE(v4) = *((_BYTE *)&this->__r_.__value_.__s + 23);
LABEL_8:
  v9 = size - v8;
  if ((v4 & 0x80) != 0)
    this->__r_.__value_.__l.__size_ = v9;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = v9 & 0x7F;
  v6->__r_.__value_.__s.__data_[v9] = 0;
}

uint64_t rtc::RefCountedObject<webrtc::DtmfSender>::AddRef(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 80);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL rtc::RefCountedObject<webrtc::DtmfSender>::Release(unsigned int *a1)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = a1 + 20;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (a1 && v2 == 1)
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 24))(a1);
  return v2 != 1;
}

uint64_t rtc::RefCountedObject<webrtc::DtmfSender>::~RefCountedObject(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)a1 = &unk_24C0B36B0;
  v2 = *(_QWORD *)(a1 + 72);
  if (v2)
  {
    *(_BYTE *)(v2 + 4) = 0;
    do
    {
      v3 = __ldaxr((unsigned int *)v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, (unsigned int *)v2));
    if (!v4)
      MEMORY[0x20BD0ADEC]();
  }
  if (*(char *)(a1 + 55) < 0)
    operator delete(*(void **)(a1 + 32));
  return a1;
}

void rtc::RefCountedObject<webrtc::DtmfSender>::~RefCountedObject(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)a1 = &unk_24C0B36B0;
  v2 = *(_QWORD *)(a1 + 72);
  if (v2)
  {
    *(_BYTE *)(v2 + 4) = 0;
    do
    {
      v3 = __ldaxr((unsigned int *)v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, (unsigned int *)v2));
    if (!v4)
      MEMORY[0x20BD0ADEC]();
  }
  if (*(char *)(a1 + 55) < 0)
    operator delete(*(void **)(a1 + 32));
  JUMPOUT(0x20BD0ADECLL);
}

BOOL rtc::RefCountedObject<webrtc::DtmfSender>::HasOneRef(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)(a1 + 80));
  return v1 == 1;
}

void absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DtmfSender::QueueInsertDtmf(unsigned int)::$_0 &&>(uint64_t *a1)
{
  uint64_t v1;
  std::string *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  std::string::size_type v7;
  unint64_t v8;
  void (***v9)(_QWORD, void **, std::string *);
  uint64_t v10;
  uint64_t v11;
  char v12;
  void *v13;
  uint64_t v14;
  unsigned int v15;
  void (***v16)(_QWORD, void **, void **);
  uint64_t v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  std::string *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  std::string::size_type v29;
  void **v30;
  size_t v31;
  void **v32;
  std::string *v33;
  size_t v34;
  void **v35;
  void **v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  std::string *v42;
  std::string::size_type v43;
  void **v44;
  size_t v45;
  void **v46;
  uint64_t v47;
  unsigned int *v48;
  unsigned int v49;
  _QWORD *v50;
  _BYTE *v51;
  unsigned int v52;
  void *v53[2];
  unint64_t v54;
  char v55;
  void *__p;
  uint64_t v57;
  uint64_t (*v58)(uint64_t, uint64_t *, void **);
  uint64_t (*v59)(uint64_t);

  v1 = *a1;
  v2 = (std::string *)(*a1 + 32);
  v3 = *(unsigned __int8 *)(*a1 + 55);
  if ((*(char *)(*a1 + 55) & 0x80000000) == 0)
  {
    v4 = *a1 + 32;
    v5 = *(unsigned __int8 *)(*a1 + 55);
    if (!*(_BYTE *)(*a1 + 55))
      goto LABEL_13;
    goto LABEL_5;
  }
  v4 = *(_QWORD *)(v1 + 32);
  v5 = *(_QWORD *)(v1 + 40);
  if (v5)
  {
LABEL_5:
    v6 = -1;
    v7 = 1;
    while (2)
    {
      switch(*(_BYTE *)(v4 + v7 - 1))
      {
        case '#':
        case '*':
        case ',':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
          if (v7 - v5 == 1 || !v7)
            break;
          v8 = v7 - 1;
          if ((v3 & 0x80) != 0)
          {
            if (*(_QWORD *)(v1 + 40) < v8)
              goto LABEL_86;
          }
          else if (v3 < v8)
          {
            goto LABEL_86;
          }
          v11 = *a1 + 32;
          if ((v3 & 0x80) != 0)
            v11 = v2->__r_.__value_.__r.__words[0];
          v12 = __toupper(*(char *)(v11 + v7 - 1));
          v13 = memchr(",0123456789*#ABCD", v12, 0x12uLL);
          if (v13)
          {
            v14 = v13 + ~",0123456789*#ABCD";
            if ((_DWORD)v14 == -1)
            {
              v15 = *(_DWORD *)(v1 + 64);
              v16 = *(void (****)(_QWORD, void **, void **))(v1 + 8);
              if (!v16)
                goto LABEL_75;
              goto LABEL_32;
            }
          }
          else
          {
            v14 = 0;
          }
          v17 = *(_QWORD *)(v1 + 24);
          if (v17)
          {
            v18 = *(_DWORD *)(v1 + 60);
            if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v17 + 8))(v17, v14, *(unsigned int *)(v1 + 56)) & 1) != 0)
            {
              v15 = *(_DWORD *)(v1 + 56) + v18;
              v16 = *(void (****)(_QWORD, void **, void **))(v1 + 8);
              if (!v16)
                goto LABEL_75;
LABEL_32:
              v19 = *(unsigned __int8 *)(v1 + 55);
              if (*(char *)(v1 + 55) < 0)
              {
                v20 = *(_QWORD *)(v1 + 40);
                if (v20 < v8)
                  goto LABEL_87;
                v21 = (std::string *)v2->__r_.__value_.__r.__words[0];
              }
              else
              {
                v20 = *(unsigned __int8 *)(v1 + 55);
                v21 = v2;
                if (v8 > v19)
                  goto LABEL_87;
              }
              v29 = v7 - v20;
              v30 = (void **)((char *)&v21->__r_.__value_.__l + v7 - 1);
              v31 = v29 != 1;
              HIBYTE(v58) = v29 != 1;
              v32 = (void **)((unint64_t)&__p | v31);
              if (&__p <= v30 && v32 > v30)
                goto LABEL_86;
              if (v29 != 1)
                memmove(&__p, v30, v31);
              *(_BYTE *)v32 = 0;
              if ((v19 & 0x80) != 0)
              {
                v19 = *(_QWORD *)(v1 + 40);
                if (v19 <= v8
                  || (v33 = (std::string *)v2->__r_.__value_.__r.__words[0],
                      v34 = v19 - v7,
                      v19 - v7 >= 0x7FFFFFFFFFFFFFF8))
                {
LABEL_87:
                  abort();
                }
              }
              else
              {
                v33 = v2;
                if (v8 >= v19)
                  goto LABEL_87;
                v34 = v19 - v7;
                if (v19 - v7 >= 0x7FFFFFFFFFFFFFF8)
                  goto LABEL_87;
              }
              v35 = (void **)((char *)&v33->__r_.__value_.__l.__data_ + v7);
              v52 = v15;
              if (v34 > 0x16)
              {
                v38 = (v34 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v34 | 7) != 0x17)
                  v38 = v34 | 7;
                v39 = v38 + 1;
                v36 = (void **)operator new(v38 + 1);
                v53[1] = (void *)v34;
                v54 = v39 | 0x8000000000000000;
                v53[0] = v36;
                v37 = (char *)v36 + v19;
                if (v36 > v35)
                {
LABEL_58:
                  if (v19 != v7)
                    memmove(v36, v35, v34);
                  v37[v6] = 0;
                  (**v16)(v16, &__p, v53);
                  if (SHIBYTE(v54) < 0)
                  {
                    operator delete(v53[0]);
                    v15 = v52;
                    if ((SHIBYTE(v58) & 0x80000000) == 0)
                    {
LABEL_62:
                      v40 = *(_QWORD *)(v1 + 8);
                      LODWORD(v41) = *(char *)(v1 + 55);
                      if ((v41 & 0x80000000) == 0)
                        goto LABEL_63;
                      goto LABEL_67;
                    }
                  }
                  else
                  {
                    v15 = v52;
                    if ((SHIBYTE(v58) & 0x80000000) == 0)
                      goto LABEL_62;
                  }
                  operator delete(__p);
                  v40 = *(_QWORD *)(v1 + 8);
                  LODWORD(v41) = *(char *)(v1 + 55);
                  if ((v41 & 0x80000000) == 0)
                  {
LABEL_63:
                    v41 = v41;
                    v42 = v2;
                    if (v8 > v41)
                      goto LABEL_87;
LABEL_69:
                    v43 = v7 - v41;
                    v44 = (void **)((char *)&v42->__r_.__value_.__l + v7 - 1);
                    v45 = v43 != 1;
                    HIBYTE(v58) = v43 != 1;
                    v46 = (void **)((unint64_t)&__p | v45);
                    if (&__p <= v44 && v46 > v44)
                      goto LABEL_86;
                    if (v43 != 1)
                      memmove(&__p, v44, v45);
                    *(_BYTE *)v46 = 0;
                    (*(void (**)(uint64_t, void **))(*(_QWORD *)v40 + 8))(v40, &__p);
                    if (SHIBYTE(v58) < 0)
                      operator delete(__p);
LABEL_75:
                    if (*(char *)(v1 + 55) < 0)
                    {
                      if (v7 == -1)
                      {
                        v51 = *(_BYTE **)(v1 + 32);
                        *(_QWORD *)(v1 + 40) = 0;
                        *v51 = 0;
                        v47 = *(_QWORD *)(v1 + 16);
                        v48 = *(unsigned int **)(v1 + 72);
                        if (!v48)
                          goto LABEL_82;
                        goto LABEL_81;
                      }
                    }
                    else if (v7 == -1)
                    {
                      *(_BYTE *)(v1 + 55) = 0;
                      v2->__r_.__value_.__s.__data_[0] = 0;
                      v47 = *(_QWORD *)(v1 + 16);
                      v48 = *(unsigned int **)(v1 + 72);
                      if (!v48)
                        goto LABEL_82;
                      goto LABEL_81;
                    }
                    std::string::__erase_external_with_move(v2, 0, v7);
                    v47 = *(_QWORD *)(v1 + 16);
                    v48 = *(unsigned int **)(v1 + 72);
                    if (!v48)
                    {
LABEL_82:
                      v50 = (_QWORD *)operator new();
                      *v50 = v48;
                      v50[1] = v1;
                      v50[3] = absl::internal_any_invocable::LocalManagerTrivial;
                      v50[4] = absl::internal_any_invocable::LocalInvoker<false,void,webrtc::DtmfSender::QueueInsertDtmf::$_0 &&>;
                      LOBYTE(v53[0]) = 1;
                      __p = v50;
                      v58 = (uint64_t (*)(uint64_t, uint64_t *, void **))_ZN4absl22internal_any_invocable23RemoteManagerNontrivialIZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_EEvNS0_14FunctionToCallEPNS0_15TypeErasedStateESC_;
                      v59 = _ZN4absl22internal_any_invocable13RemoteInvokerILb0EvOZN6webrtc8SafeTaskENS2_13scoped_refptrINS2_21PendingTaskSafetyFlagEEENS_12AnyInvocableIFvvOEEEEUlvE_JEEET0_PNS0_15TypeErasedStateEDpNS0_18ForwardedParameterIT2_E4typeE;
                      (*(void (**)(uint64_t, void **, uint64_t, void **, char *))(*(_QWORD *)v47 + 16))(v47, &__p, 1000 * v15, v53, &v55);
                      v58(1, (uint64_t *)&__p, &__p);
                      return;
                    }
                    do
LABEL_81:
                      v49 = __ldxr(v48);
                    while (__stxr(v49 + 1, v48));
                    goto LABEL_82;
                  }
LABEL_67:
                  v41 = *(_QWORD *)(v1 + 40);
                  if (v41 < v8)
                    goto LABEL_87;
                  v42 = (std::string *)v2->__r_.__value_.__r.__words[0];
                  goto LABEL_69;
                }
              }
              else
              {
                HIBYTE(v54) = v34;
                v36 = v53;
                v37 = (char *)v53 + v19;
                if (v53 > v35)
                  goto LABEL_58;
              }
              if (&v37[-v7] <= (char *)v35)
                goto LABEL_58;
LABEL_86:
              __break(1u);
              goto LABEL_87;
            }
            if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
              return;
          }
          else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) != 0)
          {
            return;
          }
          rtc::webrtc_logging_impl::Log("\r\t", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/dtmf_sender.cc");
          return;
        default:
          ++v7;
          --v6;
          if (v7 - v5 != 1)
            continue;
          goto LABEL_13;
      }
      break;
    }
  }
LABEL_13:
  if ((v3 & 0x80) != 0)
  {
    **(_BYTE **)(v1 + 32) = 0;
    *(_QWORD *)(v1 + 40) = 0;
    v9 = *(void (****)(_QWORD, void **, std::string *))(v1 + 8);
    if (!v9)
      return;
  }
  else
  {
    *(_BYTE *)(v1 + 32) = 0;
    *(_BYTE *)(v1 + 55) = 0;
    v9 = *(void (****)(_QWORD, void **, std::string *))(v1 + 8);
    if (!v9)
      return;
  }
  __p = 0;
  v57 = 0;
  v58 = 0;
  (**v9)(v9, &__p, v2);
  if (SHIBYTE(v58) < 0)
    operator delete(__p);
  v10 = *(_QWORD *)(v1 + 8);
  __p = 0;
  v57 = 0;
  v58 = 0;
  (*(void (**)(uint64_t, void **))(*(_QWORD *)v10 + 8))(v10, &__p);
  if (SHIBYTE(v58) < 0)
    operator delete(__p);
}

uint64_t webrtc::DtmfToneGenerator::Init(webrtc::DtmfToneGenerator *this, int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;

  *((_BYTE *)this + 8) = 0;
  if (a2 <= 31999)
  {
    if (a2 != 8000)
    {
LABEL_8:
      v4 = 1;
      if (a3 > 0xF)
        return 4294967294;
      goto LABEL_13;
    }
    v4 = 0;
    if (a3 <= 0xF)
      goto LABEL_13;
    return 4294967294;
  }
  if (a2 == 32000)
  {
    v4 = 2;
    if (a3 <= 0xF)
      goto LABEL_13;
    return 4294967294;
  }
  if (a2 != 48000)
    goto LABEL_8;
  v4 = 3;
  if (a3 > 0xF)
    return 4294967294;
LABEL_13:
  if (a4 > 0x3F)
    return 4294967294;
  v6 = v4 << 6;
  v7 = 4 * a3;
  *((_DWORD *)this + 3) = *(_DWORD *)((char *)&webrtc::DtmfToneGenerator::kCoeff1 + v6 + v7);
  *((_DWORD *)this + 4) = *(_DWORD *)((char *)&webrtc::DtmfToneGenerator::kCoeff2 + v6 + v7);
  *((_DWORD *)this + 5) = webrtc::DtmfToneGenerator::kAmplitude[a4];
  *((_WORD *)this + 12) = *(_DWORD *)((char *)&webrtc::DtmfToneGenerator::kInitValue1 + v6 + v7);
  *((_WORD *)this + 13) = 0;
  *((_WORD *)this + 14) = *(_DWORD *)((char *)&webrtc::DtmfToneGenerator::kInitValue2 + v6 + v7);
  *((_WORD *)this + 15) = 0;
  *((_BYTE *)this + 8) = 1;
  return 0;
}

uint64_t webrtc::DtmfToneGenerator::Reset(uint64_t this)
{
  *(_BYTE *)(this + 8) = 0;
  return this;
}

uint64_t webrtc::DtmfToneGenerator::Generate(webrtc::DtmfToneGenerator *this, uint64_t a2, webrtc::AudioMultiVector *a3)
{
  uint64_t result;
  int v7;
  int v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  unsigned int v23;
  int v24;
  unsigned int v25;

  if (!*((_BYTE *)this + 8))
    return 0xFFFFFFFFLL;
  if (!a3)
    return 4294967294;
  result = (*(uint64_t (**)(webrtc::AudioMultiVector *))(*(_QWORD *)a3 + 128))(a3);
  if (a2)
  {
    v8 = *((_DWORD *)this + 3);
    v7 = *((_DWORD *)this + 4);
    v9 = (uint64_t *)*((_QWORD *)a3 + 1);
    if (*((uint64_t **)a3 + 2) == v9)
    {
      v23 = ((v8 * *((__int16 *)this + 13) + 0x2000) >> 14) - *((unsigned __int16 *)this + 12);
      v24 = *((__int16 *)this + 15);
      v25 = ((v7 * v24 + 0x2000) >> 14) - *((unsigned __int16 *)this + 14);
      *((_WORD *)this + 12) = *((_WORD *)this + 13);
      *((_WORD *)this + 13) = v23;
      *((_WORD *)this + 14) = v24;
      *((_WORD *)this + 15) = v25;
      __break(1u);
      return result;
    }
    v10 = *((_DWORD *)this + 5);
    v11 = *v9;
    v13 = *(_QWORD *)(*v9 + 16);
    v12 = *(_QWORD *)(*v9 + 24);
    v14 = *(_QWORD *)(v11 + 8);
    v15 = a2;
    do
    {
      v16 = *((__int16 *)this + 13);
      v17 = ((v8 * v16 + 0x2000) >> 14) - *((_WORD *)this + 12);
      v18 = *((__int16 *)this + 15);
      v19 = *((_WORD *)this + 14);
      *((_WORD *)this + 12) = v16;
      *((_WORD *)this + 13) = v17;
      *((_WORD *)this + 14) = v18;
      *((_WORD *)this + 15) = ((v7 * v18 + 0x2000) >> 14) - v19;
      v20 = (v10
                         * ((23171 * v17 + ((__int16)(((v7 * v18 + 0x2000) >> 14) - v19) << 15) + 0x4000) >> 15)
                         + 0x2000) >> 14;
      if (v12 >= v13)
        v21 = v13;
      else
        v21 = 0;
      *(_WORD *)(v14 - 2 * v21 + 2 * v12++) = v20;
      --v15;
    }
    while (v15);
  }
  if ((unint64_t)(*(uint64_t (**)(webrtc::AudioMultiVector *))(*(_QWORD *)a3 + 112))(a3) >= 2)
  {
    v22 = 1;
    do
      (*(void (**)(webrtc::AudioMultiVector *, _QWORD, unint64_t))(*(_QWORD *)a3 + 144))(a3, 0, v22++);
    while (v22 < (*(uint64_t (**)(webrtc::AudioMultiVector *))(*(_QWORD *)a3 + 112))(a3));
  }
  return a2;
}

uint64_t webrtc::DtmfToneGenerator::initialized(webrtc::DtmfToneGenerator *this)
{
  return *((unsigned __int8 *)this + 8);
}

void webrtc::DtmfToneGenerator::~DtmfToneGenerator(webrtc::DtmfToneGenerator *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

float32x4_t *webrtc::EchoAudibility::UpdateRenderNoiseEstimator(float32x4_t *this, const webrtc::SpectrumBuffer *a2, const webrtc::BlockBuffer *a3, char a4, float32x4_t a5)
{
  float32x4_t *v5;
  __int32 v6;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int32 v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  float v20;
  float v21;
  float v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  float *v26;
  float v27;
  float *v28;
  uint64_t v29;
  float v30;
  float v31;
  __int32 v32;
  unint64_t v33;
  uint64_t v34;
  float32x4_t **v35;
  float32x4_t *v36;
  uint64_t v37;
  float32x4_t *v38;
  int v39;

  v5 = this;
  v6 = *((_DWORD *)a2 + 8);
  if (!this->i8[4])
  {
    this->i32[0] = v6;
    this->i8[4] = 1;
    this->i32[2] = *((_DWORD *)a3 + 8);
    return this;
  }
  v8 = this->u8[12];
  if (!this->i8[12] && (a4 & 1) == 0)
  {
    v10 = *((_QWORD *)a3 + 1);
    v9 = *((_QWORD *)a3 + 2);
    v11 = v9 - v10;
    if (v9 == v10)
      goto LABEL_54;
    v12 = *((_DWORD *)a3 + 8);
    v13 = this->i32[2];
    if (v12 != v13)
    {
      v14 = *(unsigned int *)(v10 + 4);
      if ((int)v14 >= 1)
      {
        v15 = v11 >> 5;
        v16 = *(_DWORD *)a3 - 1;
        a5.i32[0] = 10.0;
LABEL_8:
        if (v15 > v13)
        {
          v17 = 0;
          v18 = 0;
          v19 = *(_QWORD *)(v10 + 32 * v13 + 8);
          v20 = 0.0;
          while (1)
          {
            this = (float32x4_t *)((_DWORD)v18 << 6);
            v23 = (int)this;
            if ((*(_QWORD *)(v10 + 32 * v13 + 16) - v19) >> 2 <= (unint64_t)(int)this)
              break;
            this = 0;
            v24 = v19 + 4 * v17;
            v25 = (float *)(v19 + 4 * v23);
            v26 = v25 + 1;
            v27 = v25[1];
            if (v27 >= *v25)
              v28 = v25;
            else
              v28 = v25 + 1;
            if (v27 >= *v25)
              v27 = *v25;
            else
              v26 = v25;
            v29 = 2;
            do
            {
              while (1)
              {
                v30 = *(float *)((char *)&this->f32[2] + v24);
                v31 = *(float *)((char *)&this->f32[3] + v24);
                if (v31 < v30)
                  break;
                if (v30 < v27)
                {
                  v27 = *(float *)((char *)&this->f32[2] + v24);
                  v28 = (float *)((char *)&this->f32[2] + v24);
                }
                if (v31 >= *v26)
                  v26 = (float *)((char *)&this->f32[3] + v24);
                v29 += 2;
                this = (float32x4_t *)((char *)this + 8);
                if (this == (float32x4_t *)248)
                  goto LABEL_10;
              }
              v27 = *v28;
              if (v31 < *v28)
              {
                v27 = *(float *)((char *)&this->f32[3] + v24);
                v28 = (float *)((char *)&this->f32[3] + v24);
              }
              if (v30 >= *v26)
                v26 = &v25[v29];
              v29 += 2;
              this = (float32x4_t *)((char *)this + 8);
            }
            while (this != (float32x4_t *)248);
LABEL_10:
            v21 = fabsf(*v28);
            v22 = fabsf(*v26);
            if (v21 < v22)
              v21 = v22;
            if (v20 < v21)
              v20 = v21;
            ++v18;
            v17 += 64;
            if (v18 == v14)
            {
              v8 = v20 >= 10.0;
              if (v20 >= 10.0)
              {
                if (v16 > v13)
                  ++v13;
                else
                  v13 = 0;
                if (v13 != v12)
                  goto LABEL_8;
              }
              goto LABEL_43;
            }
          }
        }
        goto LABEL_54;
      }
    }
    v8 = 0;
LABEL_43:
    v5->i32[2] = v12;
    v5->i8[12] = v8;
  }
  if (!v8 || (v32 = v5->i32[0], v5->i32[0] == v6))
  {
LABEL_53:
    v5->i32[0] = v6;
    v5->i8[4] = 1;
    return this;
  }
  while (1)
  {
    v33 = v32;
    v34 = *((_QWORD *)a2 + 1);
    if (0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)a2 + 2) - v34) >> 3) <= v33)
      break;
    v35 = (float32x4_t **)(v34 + 24 * (int)v33);
    v36 = *v35;
    v37 = (char *)v35[1] - (char *)*v35;
    if (v37)
      v38 = v36;
    else
      v38 = 0;
    this = webrtc::StationarityEstimator::NoiseSpectrum::Update((float32x4_t *)((char *)v5 + 24), v38, -1057222719 * (v37 >> 2), a5);
    v39 = *(_DWORD *)a2;
    if ((int)v33 > 0)
      v39 = v33;
    v32 = v39 - 1;
    if (v32 == v6)
      goto LABEL_53;
  }
LABEL_54:
  __break(1u);
  return this;
}

void webrtc::AdjustConfig(webrtc *this, const webrtc::EchoCanceller3Config *a2)
{
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  float *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  int v25;
  void (***v26)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v27)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v28)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v29)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v30;
  void (****v31)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v33;
  int v34;
  void (***v35)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v36)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v37)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v38)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v39;
  void (****v40)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v42;
  int v43;
  void (***v44)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v45)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v46)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v47)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v48;
  void (****v49)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v51;
  int v52;
  void (***v53)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v54)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v55)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v56)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v57;
  void (****v58)(webrtc::FieldTrialParameterInterface *__hidden);
  float v60;
  uint64_t v61;
  int v62;
  void (***v63)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v64)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v65)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v66)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v67;
  void (****v68)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v70;
  int v71;
  void (***v72)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v73)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v74)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v75)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v76;
  void (****v77)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v79;
  int v80;
  void (***v81)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v82)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v83)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v84)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v85;
  void (****v86)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v88;
  int v89;
  void (***v90)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v91)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v92)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v93)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v94;
  void (****v95)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v97;
  int v98;
  void (***v99)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v100)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v101)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v102)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v103;
  void (****v104)(webrtc::FieldTrialParameterInterface *__hidden);
  _BOOL4 IsEnabled;
  uint64_t v107;
  int v108;
  void (***v109)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v110)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v111)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v112)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v113;
  void (****v114)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v116;
  int v117;
  void (***v118)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v119)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v120)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v121)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v122;
  void (****v123)(webrtc::FieldTrialParameterInterface *__hidden);
  float v125;
  float v126;
  uint64_t v127;
  char *v128;
  float v129;
  float v130;
  uint64_t v131;
  int v132;
  void (***v133)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v134)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v135)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v136)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v137;
  void (****v138)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v140;
  int v141;
  void (***v142)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v143)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v144)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v145)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v146)(webrtc::FieldTrialParameterInterface *__hidden);
  _QWORD *v147;
  uint64_t v148;
  int v149;
  void (***v150)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v151)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v152)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v153)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v154;
  void (****v155)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v157;
  int v158;
  void (***v159)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v160)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v161)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v162)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v163;
  void (****v164)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v166;
  int v167;
  void (***v168)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v169)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v170)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v171)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v172;
  void (****v173)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v175;
  int v176;
  void (***v177)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v178)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v179)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v180)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v181;
  void (****v182)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v184;
  int v185;
  void (***v186)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v187)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v188)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v189)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v190;
  void (****v191)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v193;
  int v194;
  void (***v195)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v196)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v197)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v198)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v199;
  void (****v200)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v202;
  int v203;
  void (***v204)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v205)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v206)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v207)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v208;
  void (****v209)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v211;
  int v212;
  void (***v213)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v214)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v215)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v216)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v217;
  void (****v218)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v220;
  int v221;
  void (***v222)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v223)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v224)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v225)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v226;
  void (****v227)(webrtc::FieldTrialParameterInterface *__hidden);
  float v229;
  uint64_t v230;
  int v231;
  void (***v232)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v233)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v234)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v235)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v236;
  void (****v237)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v239;
  int v240;
  void (***v241)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v242)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v243)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v244)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v245;
  void (****v246)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v248;
  int v249;
  void (***v250)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v251)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v252)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v253)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v254;
  void (****v255)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v257;
  int v258;
  void (***v259)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v260)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v261)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v262)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v263;
  void (****v264)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v266;
  int v267;
  void (***v268)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v269)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v270)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v271)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v272;
  void (****v273)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v275;
  int v276;
  void (***v277)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v278)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v279)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v280)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v281;
  void (****v282)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v284;
  int v285;
  void (***v286)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v287)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v288)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v289)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v290;
  void (****v291)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v293;
  int v294;
  void (***v295)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v296)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v297)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v298)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v299;
  void (****v300)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v302;
  int v303;
  void (***v304)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v305)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v306)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v307)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v308;
  void (****v309)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v311;
  int v312;
  void (***v313)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v314)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v315)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v316)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v317;
  void (****v318)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v320;
  int v321;
  void (***v322)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v323)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v324)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v325)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v326;
  void (****v327)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v329;
  int v330;
  void (***v331)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v332)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v333)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v334)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v335;
  void (****v336)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v338;
  int v339;
  void (***v340)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v341)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v342)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v343)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v344;
  void (****v345)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v347;
  int v348;
  void (***v349)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v350)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v351)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v352)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v353;
  void (****v354)(webrtc::FieldTrialParameterInterface *__hidden);
  float v356;
  uint64_t v357;
  int v358;
  void (***v359)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v360)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v361)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v362)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v363;
  void (****v364)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v366;
  int v367;
  void (***v368)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v369)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v370)(webrtc::FieldTrialParameterInterface *__hidden);
  void (****v371)(webrtc::FieldTrialParameterInterface *__hidden);
  _DWORD *v372;
  void (****v373)(webrtc::FieldTrialParameterInterface *__hidden);
  float v375;
  char *v376;
  float v377;
  char *v378;
  float v379;
  char *v380;
  float v381;
  char *v382;
  float v383;
  char *v384;
  float v385;
  char *v386;
  float v387;
  char *v388;
  float v389;
  char *v390;
  float v391;
  char *v392;
  float v393;
  char *v394;
  float v395;
  char *v396;
  float v397;
  char *v398;
  float v399;
  char *v400;
  float v401;
  char *v402;
  float v403;
  char *v404;
  int v405;
  char *v406;
  int v407;
  char *v408;
  uint64_t v409;
  char *v410;
  float v411;
  float v412;
  float v413;
  float v414;
  float v415;
  float v416;
  float v417;
  float v418;
  float v419;
  float v420;
  float v421;
  float v422;
  float v423;
  float v424;
  float v425;
  void *v426;
  float *v427;
  float *v428;
  float *v429;
  float *v430;
  float *v431;
  void (**v432)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v433;
  void *v434;
  uint64_t v435;
  void *__p;
  __int128 v437;
  char v438;
  int v439;
  void (**v440)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v441;
  void *v442;
  uint64_t v443;
  void *v444;
  __int128 v445;
  char v446;
  int v447;
  void (**v448)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v449;
  void *v450;
  uint64_t v451;
  void *v452;
  __int128 v453;
  char v454;
  double v455;
  void (**v456)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v457;
  void *v458;
  uint64_t v459;
  void *v460;
  __int128 v461;
  char v462;
  double v463;
  void (**v464)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v465;
  void *v466;
  uint64_t v467;
  void *v468;
  __int128 v469;
  char v470;
  double v471;
  void (**v472)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v473;
  void *v474;
  uint64_t v475;
  void *v476;
  __int128 v477;
  char v478;
  double v479;
  void (**v480)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v481;
  void *v482;
  uint64_t v483;
  void *v484;
  __int128 v485;
  char v486;
  double v487;
  void (**v488)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v489;
  void *v490;
  uint64_t v491;
  void *v492;
  __int128 v493;
  char v494;
  double v495;
  void (**v496)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v497;
  void *v498;
  uint64_t v499;
  void *v500;
  __int128 v501;
  char v502;
  double v503;
  void (**v504)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v505;
  void *v506;
  uint64_t v507;
  void *v508;
  __int128 v509;
  char v510;
  double v511;
  void (**v512)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v513;
  void *v514;
  uint64_t v515;
  void *v516;
  __int128 v517;
  char v518;
  double v519;
  void (**v520)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v521;
  void *v522;
  uint64_t v523;
  void *v524;
  __int128 v525;
  char v526;
  double v527;
  void (**v528)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v529;
  void *v530;
  uint64_t v531;
  void *v532;
  __int128 v533;
  char v534;
  double v535;
  void (**v536)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v537;
  void *v538;
  uint64_t v539;
  void *v540;
  __int128 v541;
  char v542;
  double v543;
  void (**v544)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v545;
  void *v546;
  uint64_t v547;
  void *v548;
  __int128 v549;
  char v550;
  double v551;
  void (**v552)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v553;
  void *v554;
  uint64_t v555;
  void *v556;
  __int128 v557;
  char v558;
  double v559;
  void (**v560)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v561;
  void *v562;
  uint64_t v563;
  void *v564;
  __int128 v565;
  char v566;
  double v567;
  void *v568;
  uint64_t v569;
  unsigned __int8 v570;
  void (**v571)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v572;
  void *v573;
  uint64_t v574;
  void *v575[2];
  char v576;
  char v577;
  double v578;
  void (**v579)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v580;
  void *v581;
  uint64_t v582;
  void *v583[2];
  char v584;
  char v585;
  double v586;
  void *v587;
  uint64_t v588;
  unsigned __int8 v589;
  void (***v590)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v591)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v592)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v593)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v594)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v595)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v596)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v597)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v598)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v599)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v600)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v601)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v602)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v603)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v604)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v605)(webrtc::FieldTrialParameterInterface *__hidden);
  void (***v606)(webrtc::FieldTrialParameterInterface *__hidden);
  uint64_t v607;

  v607 = *MEMORY[0x24BDAC8D0];
  v3 = *((_OWORD *)a2 + 5);
  *((_OWORD *)this + 4) = *((_OWORD *)a2 + 4);
  *((_OWORD *)this + 5) = v3;
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  *((_BYTE *)this + 112) = *((_BYTE *)a2 + 112);
  v4 = *((_OWORD *)a2 + 1);
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_OWORD *)this + 1) = v4;
  v5 = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 3) = v5;
  v6 = *(_OWORD *)((char *)a2 + 120);
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)((char *)a2 + 136);
  *(_OWORD *)((char *)this + 120) = v6;
  v7 = *(_OWORD *)((char *)a2 + 152);
  v8 = *(_OWORD *)((char *)a2 + 168);
  v9 = *(_OWORD *)((char *)a2 + 184);
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)((char *)a2 + 200);
  *(_OWORD *)((char *)this + 184) = v9;
  *(_OWORD *)((char *)this + 168) = v8;
  *(_OWORD *)((char *)this + 152) = v7;
  v10 = *(_OWORD *)((char *)a2 + 216);
  v11 = *(_OWORD *)((char *)a2 + 232);
  *(_OWORD *)((char *)this + 248) = *(_OWORD *)((char *)a2 + 248);
  *(_OWORD *)((char *)this + 232) = v11;
  *(_OWORD *)((char *)this + 216) = v10;
  v12 = *(_OWORD *)((char *)a2 + 264);
  v13 = *(_OWORD *)((char *)a2 + 280);
  v14 = *(_OWORD *)((char *)a2 + 296);
  v15 = *(_OWORD *)((char *)a2 + 312);
  *(_QWORD *)((char *)this + 326) = *(_QWORD *)((char *)a2 + 326);
  *(_OWORD *)((char *)this + 296) = v14;
  *(_OWORD *)((char *)this + 312) = v15;
  *(_OWORD *)((char *)this + 264) = v12;
  *(_OWORD *)((char *)this + 280) = v13;
  v16 = *((_OWORD *)a2 + 22);
  *((_OWORD *)this + 21) = *((_OWORD *)a2 + 21);
  *((_OWORD *)this + 22) = v16;
  *(_OWORD *)((char *)this + 361) = *(_OWORD *)((char *)a2 + 361);
  *((_DWORD *)this + 96) = *((_DWORD *)a2 + 96);
  v17 = *((_QWORD *)a2 + 50);
  *((_QWORD *)this + 49) = *((_QWORD *)a2 + 49);
  *((_QWORD *)this + 50) = v17;
  *((_DWORD *)this + 102) = *((_DWORD *)a2 + 102);
  *(_QWORD *)((char *)this + 412) = *(_QWORD *)((char *)a2 + 412);
  v18 = (float *)((char *)this + 412);
  *((_DWORD *)this + 105) = *((_DWORD *)a2 + 105);
  v19 = *((_QWORD *)a2 + 54);
  *((_QWORD *)this + 53) = *((_QWORD *)a2 + 53);
  *((_QWORD *)this + 54) = v19;
  *((_DWORD *)this + 110) = *((_DWORD *)a2 + 110);
  *(_QWORD *)((char *)this + 444) = *(_QWORD *)((char *)a2 + 444);
  *((_DWORD *)this + 113) = *((_DWORD *)a2 + 113);
  *((_QWORD *)this + 57) = *((_QWORD *)a2 + 57);
  v20 = *((_OWORD *)a2 + 35);
  v21 = *((_OWORD *)a2 + 33);
  *((_OWORD *)this + 34) = *((_OWORD *)a2 + 34);
  *((_OWORD *)this + 35) = v20;
  v22 = *((_OWORD *)a2 + 31);
  *((_OWORD *)this + 32) = *((_OWORD *)a2 + 32);
  *((_OWORD *)this + 33) = v21;
  v23 = *((_OWORD *)a2 + 29);
  *((_OWORD *)this + 30) = *((_OWORD *)a2 + 30);
  *((_OWORD *)this + 31) = v22;
  *((_OWORD *)this + 29) = v23;
  v427 = (float *)((char *)this + 444);
  *(_OWORD *)((char *)this + 569) = *(_OWORD *)((char *)a2 + 569);
  *((_OWORD *)this + 37) = *((_OWORD *)a2 + 37);
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3StereoContentDetectionKillSwitch", 0x2BuLL, (size_t *)&v590);
  v24 = HIBYTE(v592);
  v25 = SHIBYTE(v592);
  v26 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v27 = &v590;
  }
  else
  {
    v24 = (uint64_t)v591;
    v27 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v28 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v27 + v24);
  if (v24 >= 7)
  {
    v29 = v27;
    do
    {
      v30 = memchr(v29, 69, v24 - 6);
      if (!v30)
        break;
      v31 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v30;
      if (*v30 == 1650552389 && *(_DWORD *)((char *)v30 + 3) == 1684368482)
        goto LABEL_13;
      v29 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v30 + 1);
      v24 = (char *)v28 - ((char *)v31 + 1);
    }
    while (v24 > 6);
  }
  v31 = v28;
LABEL_13:
  if (v25 < 0)
    operator delete(v26);
  if (v31 != v28 && v31 == v27)
    *((_BYTE *)this + 592) = 0;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3AntiHowlingMinimizationKillSwitch", 0x2CuLL, (size_t *)&v590);
  v33 = HIBYTE(v592);
  v34 = SHIBYTE(v592);
  v35 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v36 = &v590;
  }
  else
  {
    v33 = (uint64_t)v591;
    v36 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v37 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v36 + v33);
  if (v33 >= 7)
  {
    v38 = v36;
    do
    {
      v39 = memchr(v38, 69, v33 - 6);
      if (!v39)
        break;
      v40 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v39;
      if (*v39 == 1650552389 && *(_DWORD *)((char *)v39 + 3) == 1684368482)
        goto LABEL_30;
      v38 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v39 + 1);
      v33 = (char *)v37 - ((char *)v40 + 1);
    }
    while (v33 > 6);
  }
  v40 = v37;
LABEL_30:
  if (v34 < 0)
    operator delete(v35);
  if (v40 != v37 && v40 == v36)
    *(_QWORD *)((char *)this + 572) = 0x3C23D70A41C80000;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3UseShortConfigChangeDuration", 0x27uLL, (size_t *)&v590);
  v42 = HIBYTE(v592);
  v43 = SHIBYTE(v592);
  v44 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v45 = &v590;
  }
  else
  {
    v42 = (uint64_t)v591;
    v45 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v46 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v45 + v42);
  if (v42 >= 7)
  {
    v47 = v45;
    do
    {
      v48 = memchr(v47, 69, v42 - 6);
      if (!v48)
        break;
      v49 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v48;
      if (*v48 == 1650552389 && *(_DWORD *)((char *)v48 + 3) == 1684368482)
        goto LABEL_47;
      v47 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v48 + 1);
      v42 = (char *)v46 - ((char *)v49 + 1);
    }
    while (v42 > 6);
  }
  v49 = v46;
LABEL_47:
  if (v43 < 0)
    operator delete(v44);
  if (v49 != v46 && v49 == v45)
    *((_QWORD *)this + 27) = 10;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3UseZeroInitialStateDuration", 0x26uLL, (size_t *)&v590);
  v51 = HIBYTE(v592);
  v52 = SHIBYTE(v592);
  v53 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v54 = &v590;
  }
  else
  {
    v51 = (uint64_t)v591;
    v54 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v55 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v54 + v51);
  if (v51 >= 7)
  {
    v56 = v54;
    do
    {
      v57 = memchr(v56, 69, v51 - 6);
      if (!v57)
        break;
      v58 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v57;
      if (*v57 == 1650552389 && *(_DWORD *)((char *)v57 + 3) == 1684368482)
        goto LABEL_64;
      v56 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v57 + 1);
      v51 = (char *)v55 - ((char *)v58 + 1);
    }
    while (v51 > 6);
  }
  v58 = v55;
LABEL_64:
  if (v52 < 0)
  {
    operator delete(v53);
    if (v58 == v55)
      goto LABEL_69;
  }
  else if (v58 == v55)
  {
    goto LABEL_69;
  }
  v60 = 0.0;
  if (v58 == v54)
    goto LABEL_160;
LABEL_69:
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3UseDot1SecondsInitialStateDuration", 0x2DuLL, (size_t *)&v590);
  v61 = HIBYTE(v592);
  v62 = SHIBYTE(v592);
  v63 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v64 = &v590;
  }
  else
  {
    v61 = (uint64_t)v591;
    v64 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v65 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v64 + v61);
  if (v61 >= 7)
  {
    v66 = v64;
    do
    {
      v67 = memchr(v66, 69, v61 - 6);
      if (!v67)
        break;
      v68 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v67;
      if (*v67 == 1650552389 && *(_DWORD *)((char *)v67 + 3) == 1684368482)
        goto LABEL_81;
      v66 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v67 + 1);
      v61 = (char *)v65 - ((char *)v68 + 1);
    }
    while (v61 > 6);
  }
  v68 = v65;
LABEL_81:
  if (v62 < 0)
  {
    operator delete(v63);
    if (v68 == v65)
      goto LABEL_87;
LABEL_85:
    if (v68 == v64)
    {
      v60 = 0.1;
      goto LABEL_160;
    }
    goto LABEL_87;
  }
  if (v68 != v65)
    goto LABEL_85;
LABEL_87:
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3UseDot2SecondsInitialStateDuration", 0x2DuLL, (size_t *)&v590);
  v70 = HIBYTE(v592);
  v71 = SHIBYTE(v592);
  v72 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v73 = &v590;
  }
  else
  {
    v70 = (uint64_t)v591;
    v73 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v74 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v73 + v70);
  if (v70 >= 7)
  {
    v75 = v73;
    do
    {
      v76 = memchr(v75, 69, v70 - 6);
      if (!v76)
        break;
      v77 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v76;
      if (*v76 == 1650552389 && *(_DWORD *)((char *)v76 + 3) == 1684368482)
        goto LABEL_99;
      v75 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v76 + 1);
      v70 = (char *)v74 - ((char *)v77 + 1);
    }
    while (v70 > 6);
  }
  v77 = v74;
LABEL_99:
  if (v71 < 0)
    operator delete(v72);
  if (v77 == v74 || v77 != v73)
  {
    webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3UseDot3SecondsInitialStateDuration", 0x2DuLL, (size_t *)&v590);
    v79 = HIBYTE(v592);
    v80 = SHIBYTE(v592);
    v81 = v590;
    if (SHIBYTE(v592) >= 0)
    {
      v82 = &v590;
    }
    else
    {
      v79 = (uint64_t)v591;
      v82 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
    }
    v83 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v82 + v79);
    if (v79 >= 7)
    {
      v84 = v82;
      do
      {
        v85 = memchr(v84, 69, v79 - 6);
        if (!v85)
          break;
        v86 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v85;
        if (*v85 == 1650552389 && *(_DWORD *)((char *)v85 + 3) == 1684368482)
          goto LABEL_116;
        v84 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v85 + 1);
        v79 = (char *)v83 - ((char *)v86 + 1);
      }
      while (v79 > 6);
    }
    v86 = v83;
LABEL_116:
    if (v80 < 0)
      operator delete(v81);
    if (v86 == v83 || v86 != v82)
    {
      webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3UseDot6SecondsInitialStateDuration", 0x2DuLL, (size_t *)&v590);
      v88 = HIBYTE(v592);
      v89 = SHIBYTE(v592);
      v90 = v590;
      if (SHIBYTE(v592) >= 0)
      {
        v91 = &v590;
      }
      else
      {
        v88 = (uint64_t)v591;
        v91 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
      }
      v92 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v91 + v88);
      if (v88 >= 7)
      {
        v93 = v91;
        do
        {
          v94 = memchr(v93, 69, v88 - 6);
          if (!v94)
            break;
          v95 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v94;
          if (*v94 == 1650552389 && *(_DWORD *)((char *)v94 + 3) == 1684368482)
            goto LABEL_133;
          v93 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v94 + 1);
          v88 = (char *)v92 - ((char *)v95 + 1);
        }
        while (v88 > 6);
      }
      v95 = v92;
LABEL_133:
      if (v89 < 0)
        operator delete(v90);
      if (v95 == v92 || v95 != v91)
      {
        webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3UseDot9SecondsInitialStateDuration", 0x2DuLL, (size_t *)&v590);
        v97 = HIBYTE(v592);
        v98 = SHIBYTE(v592);
        v99 = v590;
        if (SHIBYTE(v592) >= 0)
        {
          v100 = &v590;
        }
        else
        {
          v97 = (uint64_t)v591;
          v100 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
        }
        v101 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v100 + v97);
        if (v97 >= 7)
        {
          v102 = v100;
          do
          {
            v103 = memchr(v102, 69, v97 - 6);
            if (!v103)
              break;
            v104 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v103;
            if (*v103 == 1650552389 && *(_DWORD *)((char *)v103 + 3) == 1684368482)
              goto LABEL_150;
            v102 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v103 + 1);
            v97 = (char *)v101 - ((char *)v104 + 1);
          }
          while (v97 > 6);
        }
        v104 = v101;
LABEL_150:
        if (v98 < 0)
          operator delete(v99);
        if (v104 == v101 || v104 != v100)
        {
          if (webrtc::field_trial::IsEnabled((size_t)"WebRTC-Aec3Use1Dot2SecondsInitialStateDuration", 0x2EuLL))
          {
            v60 = 1.2;
          }
          else if (webrtc::field_trial::IsEnabled((size_t)"WebRTC-Aec3Use1Dot6SecondsInitialStateDuration", 0x2EuLL))
          {
            v60 = 1.6;
          }
          else
          {
            IsEnabled = webrtc::field_trial::IsEnabled((size_t)"WebRTC-Aec3Use2Dot0SecondsInitialStateDuration", 0x2EuLL);
            v60 = 2.0;
            if (!IsEnabled)
              goto LABEL_161;
          }
        }
        else
        {
          v60 = 0.9;
        }
      }
      else
      {
        v60 = 0.6;
      }
    }
    else
    {
      v60 = 0.3;
    }
  }
  else
  {
    v60 = 0.2;
  }
LABEL_160:
  *((float *)this + 56) = v60;
LABEL_161:
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3HighPassFilterEchoReference", 0x26uLL, (size_t *)&v590);
  v107 = HIBYTE(v592);
  v108 = SHIBYTE(v592);
  v109 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v110 = &v590;
  }
  else
  {
    v107 = (uint64_t)v591;
    v110 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v111 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v110 + v107);
  if (v107 >= 7)
  {
    v112 = v110;
    do
    {
      v113 = memchr(v112, 69, v107 - 6);
      if (!v113)
        break;
      v114 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v113;
      if (*v113 == 1650552389 && *(_DWORD *)((char *)v113 + 3) == 1684368482)
        goto LABEL_173;
      v112 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v113 + 1);
      v107 = (char *)v111 - ((char *)v114 + 1);
    }
    while (v107 > 6);
  }
  v114 = v111;
LABEL_173:
  if (v108 < 0)
    operator delete(v109);
  if (v114 != v111 && v114 == v110)
    *((_BYTE *)this + 235) = 1;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EchoSaturationDetectionKillSwitch", 0x2CuLL, (size_t *)&v590);
  v116 = HIBYTE(v592);
  v117 = SHIBYTE(v592);
  v118 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v119 = &v590;
  }
  else
  {
    v116 = (uint64_t)v591;
    v119 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v120 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v119 + v116);
  if (v116 >= 7)
  {
    v121 = v119;
    do
    {
      v122 = memchr(v121, 69, v116 - 6);
      if (!v122)
        break;
      v123 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v122;
      if (*v122 == 1650552389 && *(_DWORD *)((char *)v122 + 3) == 1684368482)
        goto LABEL_190;
      v121 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v122 + 1);
      v116 = (char *)v120 - ((char *)v123 + 1);
    }
    while (v116 > 6);
  }
  v123 = v120;
LABEL_190:
  if (v117 < 0)
    operator delete(v118);
  if (v123 != v120 && v123 == v119)
    *((_BYTE *)this + 284) = 0;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3UseNearendReverbLen", 0x1EuLL, (size_t *)&v587);
  v125 = *((float *)this + 69);
  v579 = off_24C0B4170;
  v580 = 0;
  v582 = 0;
  v581 = 0;
  v584 = 11;
  if (v583 <= (void **)"default_len" && (char *)&v583[1] + 3 > "default_len")
    goto LABEL_789;
  strcpy((char *)v583, "default_len");
  v585 = 0;
  v579 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v586 = v125;
  v126 = *((float *)this + 70);
  v571 = off_24C0B4170;
  v572 = 0;
  v574 = 0;
  v573 = 0;
  v576 = 11;
  if (v575 <= (void **)"nearend_len" && (char *)&v575[1] + 3 > "nearend_len")
    goto LABEL_789;
  strcpy((char *)v575, "nearend_len");
  v577 = 0;
  v571 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v578 = v126;
  v590 = &v579;
  v591 = &v571;
  if ((char)v589 < 0)
  {
    v127 = v588;
    if (v588 < 0)
      goto LABEL_789;
    v128 = (char *)v587;
    if (v588)
    {
      if (!v587)
        goto LABEL_789;
    }
  }
  else
  {
    v127 = v589;
    v128 = (char *)&v587;
  }
  webrtc::ParseFieldTrial(&v590, 2, v128, v127);
  v129 = v586;
  if (v129 > -1.0 && v129 < 1.0)
  {
    v130 = v578;
    if (v130 > -1.0 && v130 < 1.0)
    {
      *((float *)this + 69) = v129;
      *((float *)this + 70) = v130;
    }
  }
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3ConservativeTailFreqResponse", 0x27uLL, (size_t *)&v590);
  v131 = HIBYTE(v592);
  v132 = SHIBYTE(v592);
  v133 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v134 = &v590;
  }
  else
  {
    v131 = (uint64_t)v591;
    v134 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v135 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v134 + v131);
  if (v131 >= 7)
  {
    v136 = v134;
    do
    {
      v137 = memchr(v136, 69, v131 - 6);
      if (!v137)
        break;
      v138 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v137;
      if (*v137 == 1650552389 && *(_DWORD *)((char *)v137 + 3) == 1684368482)
        goto LABEL_221;
      v136 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v137 + 1);
      v131 = (char *)v135 - ((char *)v138 + 1);
    }
    while (v131 > 6);
  }
  v138 = v135;
LABEL_221:
  if (v132 < 0)
    operator delete(v133);
  if (v138 != v135 && v138 == v134)
    *((_BYTE *)this + 287) = 1;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3ConservativeTailFreqResponse", 0x27uLL, (size_t *)&v590);
  v140 = HIBYTE(v592);
  v141 = SHIBYTE(v592);
  v142 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v143 = &v590;
  }
  else
  {
    v140 = (uint64_t)v591;
    v143 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v144 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v143 + v140);
  if (v140 >= 8)
  {
    v146 = v143;
    do
    {
      v147 = memchr(v146, 68, v140 - 7);
      if (!v147)
        break;
      v145 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v147;
      if (*v147 == 0x64656C6261736944)
        goto LABEL_237;
      v146 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v147 + 1);
      v140 = (char *)v144 - ((char *)v145 + 1);
    }
    while (v140 > 7);
    v145 = v144;
LABEL_237:
    if (v141 < 0)
      goto LABEL_238;
  }
  else
  {
    v145 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v143 + v140);
    if (SHIBYTE(v592) < 0)
LABEL_238:
      operator delete(v142);
  }
  if (v145 != v144 && v145 == v143)
    *((_BYTE *)this + 287) = 0;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3ShortHeadroomKillSwitch", 0x22uLL, (size_t *)&v590);
  v148 = HIBYTE(v592);
  v149 = SHIBYTE(v592);
  v150 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v151 = &v590;
  }
  else
  {
    v148 = (uint64_t)v591;
    v151 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v152 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v151 + v148);
  if (v148 >= 7)
  {
    v153 = v151;
    do
    {
      v154 = memchr(v153, 69, v148 - 6);
      if (!v154)
        break;
      v155 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v154;
      if (*v154 == 1650552389 && *(_DWORD *)((char *)v154 + 3) == 1684368482)
        goto LABEL_254;
      v153 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v154 + 1);
      v148 = (char *)v152 - ((char *)v155 + 1);
    }
    while (v148 > 6);
  }
  v155 = v152;
LABEL_254:
  if (v149 < 0)
    operator delete(v150);
  if (v155 != v152 && v155 == v151)
    *((_QWORD *)this + 5) = 128;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3ClampInstQualityToZeroKillSwitch", 0x2BuLL, (size_t *)&v590);
  v157 = HIBYTE(v592);
  v158 = SHIBYTE(v592);
  v159 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v160 = &v590;
  }
  else
  {
    v157 = (uint64_t)v591;
    v160 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v161 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v160 + v157);
  if (v157 >= 7)
  {
    v162 = v160;
    do
    {
      v163 = memchr(v162, 69, v157 - 6);
      if (!v163)
        break;
      v164 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v163;
      if (*v163 == 1650552389 && *(_DWORD *)((char *)v163 + 3) == 1684368482)
        goto LABEL_271;
      v162 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v163 + 1);
      v157 = (char *)v161 - ((char *)v164 + 1);
    }
    while (v157 > 6);
  }
  v164 = v161;
LABEL_271:
  if (v158 < 0)
    operator delete(v159);
  if (v164 != v161 && v164 == v160)
    *((_BYTE *)this + 264) = 0;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3ClampInstQualityToOneKillSwitch", 0x2AuLL, (size_t *)&v590);
  v166 = HIBYTE(v592);
  v167 = SHIBYTE(v592);
  v168 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v169 = &v590;
  }
  else
  {
    v166 = (uint64_t)v591;
    v169 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v170 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v169 + v166);
  if (v166 >= 7)
  {
    v171 = v169;
    do
    {
      v172 = memchr(v171, 69, v166 - 6);
      if (!v172)
        break;
      v173 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v172;
      if (*v172 == 1650552389 && *(_DWORD *)((char *)v172 + 3) == 1684368482)
        goto LABEL_288;
      v171 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v172 + 1);
      v166 = (char *)v170 - ((char *)v173 + 1);
    }
    while (v166 > 6);
  }
  v173 = v170;
LABEL_288:
  if (v167 < 0)
    operator delete(v168);
  if (v173 != v170 && v173 == v169)
    *((_BYTE *)this + 265) = 0;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3OnsetDetectionKillSwitch", 0x23uLL, (size_t *)&v590);
  v175 = HIBYTE(v592);
  v176 = SHIBYTE(v592);
  v177 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v178 = &v590;
  }
  else
  {
    v175 = (uint64_t)v591;
    v178 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v179 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v178 + v175);
  if (v175 >= 7)
  {
    v180 = v178;
    do
    {
      v181 = memchr(v180, 69, v175 - 6);
      if (!v181)
        break;
      v182 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v181;
      if (*v181 == 1650552389 && *(_DWORD *)((char *)v181 + 3) == 1684368482)
        goto LABEL_305;
      v180 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v181 + 1);
      v175 = (char *)v179 - ((char *)v182 + 1);
    }
    while (v175 > 6);
  }
  v182 = v179;
LABEL_305:
  if (v176 < 0)
    operator delete(v177);
  if (v182 != v179 && v182 == v178)
    *((_BYTE *)this + 252) = 0;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceRenderDelayEstimationDownmixing", 0x31uLL, (size_t *)&v590);
  v184 = HIBYTE(v592);
  v185 = SHIBYTE(v592);
  v186 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v187 = &v590;
  }
  else
  {
    v184 = (uint64_t)v591;
    v187 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v188 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v187 + v184);
  if (v184 >= 7)
  {
    v189 = v187;
    do
    {
      v190 = memchr(v189, 69, v184 - 6);
      if (!v190)
        break;
      v191 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v190;
      if (*v190 == 1650552389 && *(_DWORD *)((char *)v190 + 3) == 1684368482)
        goto LABEL_322;
      v189 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v190 + 1);
      v184 = (char *)v188 - ((char *)v191 + 1);
    }
    while (v184 > 6);
  }
  v191 = v188;
LABEL_322:
  if (v185 < 0)
    operator delete(v186);
  if (v191 != v188 && v191 == v187)
    *((_WORD *)this + 44) = 1;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceCaptureDelayEstimationDownmixing", 0x32uLL, (size_t *)&v590);
  v193 = HIBYTE(v592);
  v194 = SHIBYTE(v592);
  v195 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v196 = &v590;
  }
  else
  {
    v193 = (uint64_t)v591;
    v196 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v197 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v196 + v193);
  if (v193 >= 7)
  {
    v198 = v196;
    do
    {
      v199 = memchr(v198, 69, v193 - 6);
      if (!v199)
        break;
      v200 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v199;
      if (*v199 == 1650552389 && *(_DWORD *)((char *)v199 + 3) == 1684368482)
        goto LABEL_339;
      v198 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v199 + 1);
      v193 = (char *)v197 - ((char *)v200 + 1);
    }
    while (v193 > 6);
  }
  v200 = v197;
LABEL_339:
  if (v194 < 0)
    operator delete(v195);
  if (v200 != v197 && v200 == v196)
    *((_WORD *)this + 50) = 1;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceCaptureDelayEstimationLeftRightPrioritization", 0x3FuLL, (size_t *)&v590);
  v202 = HIBYTE(v592);
  v203 = SHIBYTE(v592);
  v204 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v205 = &v590;
  }
  else
  {
    v202 = (uint64_t)v591;
    v205 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v206 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v205 + v202);
  if (v202 >= 7)
  {
    v207 = v205;
    do
    {
      v208 = memchr(v207, 69, v202 - 6);
      if (!v208)
        break;
      v209 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v208;
      if (*v208 == 1650552389 && *(_DWORD *)((char *)v208 + 3) == 1684368482)
        goto LABEL_356;
      v207 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v208 + 1);
      v202 = (char *)v206 - ((char *)v209 + 1);
    }
    while (v202 > 6);
  }
  v209 = v206;
LABEL_356:
  if (v203 < 0)
    operator delete(v204);
  if (v209 != v206 && v209 == v205)
    *((_BYTE *)this + 108) = 1;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3RenderDelayEstimationLeftRightPrioritizationKillSwitch", 0x41uLL, (size_t *)&v590);
  v211 = HIBYTE(v592);
  v212 = SHIBYTE(v592);
  v213 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v214 = &v590;
  }
  else
  {
    v211 = (uint64_t)v591;
    v214 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v215 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v214 + v211);
  if (v211 >= 7)
  {
    v216 = v214;
    do
    {
      v217 = memchr(v216, 69, v211 - 6);
      if (!v217)
        break;
      v218 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v217;
      if (*v217 == 1650552389 && *(_DWORD *)((char *)v217 + 3) == 1684368482)
        goto LABEL_373;
      v216 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v217 + 1);
      v211 = (char *)v215 - ((char *)v218 + 1);
    }
    while (v211 > 6);
  }
  v218 = v215;
LABEL_373:
  if (v212 < 0)
    operator delete(v213);
  if (v218 != v215 && v218 == v214)
    *((_BYTE *)this + 108) = 0;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3SensitiveDominantNearendActivation", 0x2DuLL, (size_t *)&v590);
  v220 = HIBYTE(v592);
  v221 = SHIBYTE(v592);
  v222 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v223 = &v590;
  }
  else
  {
    v220 = (uint64_t)v591;
    v223 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v224 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v223 + v220);
  if (v220 >= 7)
  {
    v225 = v223;
    do
    {
      v226 = memchr(v225, 69, v220 - 6);
      if (!v226)
        break;
      v227 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v226;
      if (*v226 == 1650552389 && *(_DWORD *)((char *)v226 + 3) == 1684368482)
        goto LABEL_390;
      v225 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v226 + 1);
      v220 = (char *)v224 - ((char *)v227 + 1);
    }
    while (v220 > 6);
  }
  v227 = v224;
LABEL_390:
  if (v221 < 0)
  {
    operator delete(v222);
    if (v227 == v224)
      goto LABEL_395;
  }
  else if (v227 == v224)
  {
    goto LABEL_395;
  }
  v229 = 0.5;
  if (v227 == v223)
  {
LABEL_411:
    *((float *)this + 121) = v229;
    goto LABEL_412;
  }
LABEL_395:
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3VerySensitiveDominantNearendActivation", 0x31uLL, (size_t *)&v590);
  v230 = HIBYTE(v592);
  v231 = SHIBYTE(v592);
  v232 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v233 = &v590;
  }
  else
  {
    v230 = (uint64_t)v591;
    v233 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v234 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v233 + v230);
  if (v230 >= 7)
  {
    v235 = v233;
    do
    {
      v236 = memchr(v235, 69, v230 - 6);
      if (!v236)
        break;
      v237 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v236;
      if (*v236 == 1650552389 && *(_DWORD *)((char *)v236 + 3) == 1684368482)
        goto LABEL_407;
      v235 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v236 + 1);
      v230 = (char *)v234 - ((char *)v237 + 1);
    }
    while (v230 > 6);
  }
  v237 = v234;
LABEL_407:
  if (v231 < 0)
    operator delete(v232);
  if (v237 != v234)
  {
    v229 = 0.75;
    if (v237 == v233)
      goto LABEL_411;
  }
LABEL_412:
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3TransparentAntiHowlingGain", 0x25uLL, (size_t *)&v590);
  v239 = HIBYTE(v592);
  v240 = SHIBYTE(v592);
  v241 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v242 = &v590;
  }
  else
  {
    v239 = (uint64_t)v591;
    v242 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v243 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v242 + v239);
  if (v239 >= 7)
  {
    v244 = v242;
    do
    {
      v245 = memchr(v244, 69, v239 - 6);
      if (!v245)
        break;
      v246 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v245;
      if (*v245 == 1650552389 && *(_DWORD *)((char *)v245 + 3) == 1684368482)
        goto LABEL_424;
      v244 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v245 + 1);
      v239 = (char *)v243 - ((char *)v246 + 1);
    }
    while (v239 > 6);
  }
  v246 = v243;
LABEL_424:
  if (v240 < 0)
    operator delete(v241);
  if (v246 != v243 && v246 == v242)
    *((_DWORD *)this + 144) = 1065353216;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceMoreTransparentNormalSuppressorTuning", 0x37uLL, (size_t *)&v590);
  v248 = HIBYTE(v592);
  v249 = SHIBYTE(v592);
  v250 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v251 = &v590;
  }
  else
  {
    v248 = (uint64_t)v591;
    v251 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v252 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v251 + v248);
  if (v248 >= 7)
  {
    v253 = v251;
    do
    {
      v254 = memchr(v253, 69, v248 - 6);
      if (!v254)
        break;
      v255 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v254;
      if (*v254 == 1650552389 && *(_DWORD *)((char *)v254 + 3) == 1684368482)
        goto LABEL_441;
      v253 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v254 + 1);
      v248 = (char *)v252 - ((char *)v255 + 1);
    }
    while (v248 > 6);
  }
  v255 = v252;
LABEL_441:
  if (v249 < 0)
    operator delete(v250);
  v429 = (float *)((char *)this + 400);
  if (v255 != v252 && v255 == v251)
    *(_QWORD *)v429 = 0x3F0000003ECCCCCDLL;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceMoreTransparentNearendSuppressorTuning", 0x38uLL, (size_t *)&v590);
  v257 = HIBYTE(v592);
  v258 = SHIBYTE(v592);
  v259 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v260 = &v590;
  }
  else
  {
    v257 = (uint64_t)v591;
    v260 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v261 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v260 + v257);
  if (v257 >= 7)
  {
    v262 = v260;
    do
    {
      v263 = memchr(v262, 69, v257 - 6);
      if (!v263)
        break;
      v264 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v263;
      if (*v263 == 1650552389 && *(_DWORD *)((char *)v263 + 3) == 1684368482)
        goto LABEL_458;
      v262 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v263 + 1);
      v257 = (char *)v261 - ((char *)v264 + 1);
    }
    while (v257 > 6);
  }
  v264 = v261;
LABEL_458:
  if (v258 < 0)
    operator delete(v259);
  v431 = (float *)((char *)this + 432);
  if (v264 != v261 && v264 == v260)
    *(_QWORD *)v431 = 0x3FA666663FA51EB8;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceMoreTransparentNormalSuppressorHfTuning", 0x39uLL, (size_t *)&v590);
  v266 = HIBYTE(v592);
  v267 = SHIBYTE(v592);
  v268 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v269 = &v590;
  }
  else
  {
    v266 = (uint64_t)v591;
    v269 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v270 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v269 + v266);
  if (v266 >= 7)
  {
    v271 = v269;
    do
    {
      v272 = memchr(v271, 69, v266 - 6);
      if (!v272)
        break;
      v273 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v272;
      if (*v272 == 1650552389 && *(_DWORD *)((char *)v272 + 3) == 1684368482)
        goto LABEL_475;
      v271 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v272 + 1);
      v266 = (char *)v270 - ((char *)v273 + 1);
    }
    while (v266 > 6);
  }
  v273 = v270;
LABEL_475:
  if (v267 < 0)
    operator delete(v268);
  if (v273 != v270 && v273 == v269)
    *(_QWORD *)((char *)this + 412) = 0x3ECCCCCD3E99999ALL;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceMoreTransparentNearendSuppressorHfTuning", 0x3AuLL, (size_t *)&v590);
  v275 = HIBYTE(v592);
  v276 = SHIBYTE(v592);
  v277 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v278 = &v590;
  }
  else
  {
    v275 = (uint64_t)v591;
    v278 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v279 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v278 + v275);
  if (v275 >= 7)
  {
    v280 = v278;
    do
    {
      v281 = memchr(v280, 69, v275 - 6);
      if (!v281)
        break;
      v282 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v281;
      if (*v281 == 1650552389 && *(_DWORD *)((char *)v281 + 3) == 1684368482)
        goto LABEL_492;
      v280 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v281 + 1);
      v275 = (char *)v279 - ((char *)v282 + 1);
    }
    while (v275 > 6);
  }
  v282 = v279;
LABEL_492:
  if (v276 < 0)
    operator delete(v277);
  if (v282 != v279 && v282 == v278)
    *(_QWORD *)((char *)this + 444) = 0x3F8CCCCD3F8B851FLL;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceRapidlyAdjustingNormalSuppressorTunings", 0x39uLL, (size_t *)&v590);
  v284 = HIBYTE(v592);
  v285 = SHIBYTE(v592);
  v286 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v287 = &v590;
  }
  else
  {
    v284 = (uint64_t)v591;
    v287 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v288 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v287 + v284);
  if (v284 >= 7)
  {
    v289 = v287;
    do
    {
      v290 = memchr(v289, 69, v284 - 6);
      if (!v290)
        break;
      v291 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v290;
      if (*v290 == 1650552389 && *(_DWORD *)((char *)v290 + 3) == 1684368482)
        goto LABEL_509;
      v289 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v290 + 1);
      v284 = (char *)v288 - ((char *)v291 + 1);
    }
    while (v284 > 6);
  }
  v291 = v288;
LABEL_509:
  if (v285 < 0)
    operator delete(v286);
  v428 = (float *)((char *)this + 424);
  if (v291 != v288 && v291 == v287)
    *v428 = 2.5;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceRapidlyAdjustingNearendSuppressorTunings", 0x3AuLL, (size_t *)&v590);
  v293 = HIBYTE(v592);
  v294 = SHIBYTE(v592);
  v295 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v296 = &v590;
  }
  else
  {
    v293 = (uint64_t)v591;
    v296 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v297 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v296 + v293);
  if (v293 >= 7)
  {
    v298 = v296;
    do
    {
      v299 = memchr(v298, 69, v293 - 6);
      if (!v299)
        break;
      v300 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v299;
      if (*v299 == 1650552389 && *(_DWORD *)((char *)v299 + 3) == 1684368482)
        goto LABEL_526;
      v298 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v299 + 1);
      v293 = (char *)v297 - ((char *)v300 + 1);
    }
    while (v293 > 6);
  }
  v300 = v297;
LABEL_526:
  if (v294 < 0)
    operator delete(v295);
  v430 = (float *)((char *)this + 456);
  if (v300 != v297 && v300 == v296)
    *v430 = 2.5;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceSlowlyAdjustingNormalSuppressorTunings", 0x38uLL, (size_t *)&v590);
  v302 = HIBYTE(v592);
  v303 = SHIBYTE(v592);
  v304 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v305 = &v590;
  }
  else
  {
    v302 = (uint64_t)v591;
    v305 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v306 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v305 + v302);
  if (v302 >= 7)
  {
    v307 = v305;
    do
    {
      v308 = memchr(v307, 69, v302 - 6);
      if (!v308)
        break;
      v309 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v308;
      if (*v308 == 1650552389 && *(_DWORD *)((char *)v308 + 3) == 1684368482)
        goto LABEL_543;
      v307 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v308 + 1);
      v302 = (char *)v306 - ((char *)v309 + 1);
    }
    while (v302 > 6);
  }
  v309 = v306;
LABEL_543:
  if (v303 < 0)
    operator delete(v304);
  if (v309 != v306 && v309 == v305)
    *((_DWORD *)this + 107) = 1045220557;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceSlowlyAdjustingNearendSuppressorTunings", 0x39uLL, (size_t *)&v590);
  v311 = HIBYTE(v592);
  v312 = SHIBYTE(v592);
  v313 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v314 = &v590;
  }
  else
  {
    v311 = (uint64_t)v591;
    v314 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v315 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v314 + v311);
  if (v311 >= 7)
  {
    v316 = v314;
    do
    {
      v317 = memchr(v316, 69, v311 - 6);
      if (!v317)
        break;
      v318 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v317;
      if (*v317 == 1650552389 && *(_DWORD *)((char *)v317 + 3) == 1684368482)
        goto LABEL_560;
      v316 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v317 + 1);
      v311 = (char *)v315 - ((char *)v318 + 1);
    }
    while (v311 > 6);
  }
  v318 = v315;
LABEL_560:
  if (v312 < 0)
    operator delete(v313);
  if (v318 != v315 && v318 == v314)
    *((_DWORD *)this + 115) = 1045220557;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceConservativeHfSuppression", 0x2BuLL, (size_t *)&v590);
  v320 = HIBYTE(v592);
  v321 = SHIBYTE(v592);
  v322 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v323 = &v590;
  }
  else
  {
    v320 = (uint64_t)v591;
    v323 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v324 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v323 + v320);
  if (v320 >= 7)
  {
    v325 = v323;
    do
    {
      v326 = memchr(v325, 69, v320 - 6);
      if (!v326)
        break;
      v327 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v326;
      if (*v326 == 1650552389 && *(_DWORD *)((char *)v326 + 3) == 1684368482)
        goto LABEL_577;
      v325 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v326 + 1);
      v320 = (char *)v324 - ((char *)v327 + 1);
    }
    while (v320 > 6);
  }
  v327 = v324;
LABEL_577:
  if (v321 < 0)
    operator delete(v322);
  if (v327 != v324 && v327 == v323)
    *((_BYTE *)this + 584) = 1;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceStationarityProperties", 0x28uLL, (size_t *)&v590);
  v329 = HIBYTE(v592);
  v330 = SHIBYTE(v592);
  v331 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v332 = &v590;
  }
  else
  {
    v329 = (uint64_t)v591;
    v332 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v333 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v332 + v329);
  if (v329 >= 7)
  {
    v334 = v332;
    do
    {
      v335 = memchr(v334, 69, v329 - 6);
      if (!v335)
        break;
      v336 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v335;
      if (*v335 == 1650552389 && *(_DWORD *)((char *)v335 + 3) == 1684368482)
        goto LABEL_594;
      v334 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v335 + 1);
      v329 = (char *)v333 - ((char *)v336 + 1);
    }
    while (v329 > 6);
  }
  v336 = v333;
LABEL_594:
  if (v330 < 0)
    operator delete(v331);
  if (v336 != v333 && v336 == v332)
    *((_BYTE *)this + 312) = 1;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceStationarityPropertiesAtInit", 0x2EuLL, (size_t *)&v590);
  v338 = HIBYTE(v592);
  v339 = SHIBYTE(v592);
  v340 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v341 = &v590;
  }
  else
  {
    v338 = (uint64_t)v591;
    v341 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v342 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v341 + v338);
  if (v338 >= 7)
  {
    v343 = v341;
    do
    {
      v344 = memchr(v343, 69, v338 - 6);
      if (!v344)
        break;
      v345 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v344;
      if (*v344 == 1650552389 && *(_DWORD *)((char *)v344 + 3) == 1684368482)
        goto LABEL_611;
      v343 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v344 + 1);
      v338 = (char *)v342 - ((char *)v345 + 1);
    }
    while (v338 > 6);
  }
  v345 = v342;
LABEL_611:
  if (v339 < 0)
    operator delete(v340);
  if (v345 != v342 && v345 == v341)
    *((_BYTE *)this + 313) = 1;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceLowActiveRenderLimit", 0x26uLL, (size_t *)&v590);
  v347 = HIBYTE(v592);
  v348 = SHIBYTE(v592);
  v349 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v350 = &v590;
  }
  else
  {
    v347 = (uint64_t)v591;
    v350 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v351 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v350 + v347);
  if (v347 >= 7)
  {
    v352 = v350;
    do
    {
      v353 = memchr(v352, 69, v347 - 6);
      if (!v353)
        break;
      v354 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v353;
      if (*v353 == 1650552389 && *(_DWORD *)((char *)v353 + 3) == 1684368482)
        goto LABEL_628;
      v352 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v353 + 1);
      v347 = (char *)v351 - ((char *)v354 + 1);
    }
    while (v347 > 6);
  }
  v354 = v351;
LABEL_628:
  if (v348 < 0)
  {
    operator delete(v349);
    if (v354 == v351)
      goto LABEL_634;
  }
  else if (v354 == v351)
  {
LABEL_634:
    webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3EnforceVeryLowActiveRenderLimit", 0x2AuLL, (size_t *)&v590);
    v357 = HIBYTE(v592);
    v358 = SHIBYTE(v592);
    v359 = v590;
    if (SHIBYTE(v592) >= 0)
    {
      v360 = &v590;
    }
    else
    {
      v357 = (uint64_t)v591;
      v360 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
    }
    v361 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v360 + v357);
    if (v357 >= 7)
    {
      v362 = v360;
      do
      {
        v363 = memchr(v362, 69, v357 - 6);
        if (!v363)
          break;
        v364 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v363;
        if (*v363 == 1650552389 && *(_DWORD *)((char *)v363 + 3) == 1684368482)
          goto LABEL_646;
        v362 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v363 + 1);
        v357 = (char *)v361 - ((char *)v364 + 1);
      }
      while (v357 > 6);
    }
    v364 = v361;
LABEL_646:
    if (v358 < 0)
      operator delete(v359);
    if (v364 == v361)
      goto LABEL_651;
    v356 = 30.0;
    if (v364 != v360)
      goto LABEL_651;
    goto LABEL_650;
  }
  if (v354 != v350)
    goto LABEL_634;
  v356 = 50.0;
LABEL_650:
  *((float *)this + 79) = v356;
LABEL_651:
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3NonlinearModeReverbKillSwitch", 0x28uLL, (size_t *)&v590);
  v366 = HIBYTE(v592);
  v367 = SHIBYTE(v592);
  v368 = v590;
  if (SHIBYTE(v592) >= 0)
  {
    v369 = &v590;
  }
  else
  {
    v366 = (uint64_t)v591;
    v369 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v590;
  }
  v370 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v369 + v366);
  if (v366 >= 7)
  {
    v371 = v369;
    do
    {
      v372 = memchr(v371, 69, v366 - 6);
      if (!v372)
        break;
      v373 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))v372;
      if (*v372 == 1650552389 && *(_DWORD *)((char *)v372 + 3) == 1684368482)
        goto LABEL_663;
      v371 = (void (****)(webrtc::FieldTrialParameterInterface *__hidden))((char *)v372 + 1);
      v366 = (char *)v370 - ((char *)v373 + 1);
    }
    while (v366 > 6);
  }
  v373 = v370;
LABEL_663:
  if (v367 < 0)
    operator delete(v368);
  if (v373 != v370 && v373 == v369)
    *((_BYTE *)this + 376) = 0;
  webrtc::field_trial::FindFullName((size_t)"WebRTC-Aec3SuppressorTuningOverride", 0x23uLL, (size_t *)&v568);
  v375 = *v431;
  v560 = off_24C0B4170;
  v561 = 0;
  v563 = 0;
  v562 = 0;
  v376 = (char *)operator new(0x28uLL);
  v564 = v376;
  v565 = xmmword_208F08680;
  if (v376 <= "nearend_tuning_mask_lf_enr_transparent" && v376 + 38 > "nearend_tuning_mask_lf_enr_transparent")
    goto LABEL_789;
  strcpy(v376, "nearend_tuning_mask_lf_enr_transparent");
  v566 = 0;
  v560 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v567 = v375;
  v377 = *((float *)this + 109);
  v552 = off_24C0B4170;
  v553 = 0;
  v555 = 0;
  v554 = 0;
  v378 = (char *)operator new(0x28uLL);
  v556 = v378;
  v557 = xmmword_208F051B0;
  if (v378 <= "nearend_tuning_mask_lf_enr_suppress" && v378 + 35 > "nearend_tuning_mask_lf_enr_suppress")
    goto LABEL_789;
  strcpy(v378, "nearend_tuning_mask_lf_enr_suppress");
  v558 = 0;
  v552 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v559 = v377;
  v379 = *v427;
  v544 = off_24C0B4170;
  v545 = 0;
  v547 = 0;
  v546 = 0;
  v380 = (char *)operator new(0x28uLL);
  v548 = v380;
  v549 = xmmword_208F08680;
  if (v380 <= "nearend_tuning_mask_hf_enr_transparent" && v380 + 38 > "nearend_tuning_mask_hf_enr_transparent")
    goto LABEL_789;
  strcpy(v380, "nearend_tuning_mask_hf_enr_transparent");
  v550 = 0;
  v544 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v551 = v379;
  v381 = *((float *)this + 112);
  v536 = off_24C0B4170;
  v537 = 0;
  v539 = 0;
  v538 = 0;
  v382 = (char *)operator new(0x28uLL);
  v540 = v382;
  v541 = xmmword_208F051B0;
  if (v382 <= "nearend_tuning_mask_hf_enr_suppress" && v382 + 35 > "nearend_tuning_mask_hf_enr_suppress")
    goto LABEL_789;
  strcpy(v382, "nearend_tuning_mask_hf_enr_suppress");
  v542 = 0;
  v536 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v543 = v381;
  v383 = *v430;
  v528 = off_24C0B4170;
  v529 = 0;
  v531 = 0;
  v530 = 0;
  v384 = (char *)operator new(0x20uLL);
  v532 = v384;
  v533 = xmmword_208F05190;
  if (v384 <= "nearend_tuning_max_inc_factor" && v384 + 29 > "nearend_tuning_max_inc_factor")
    goto LABEL_789;
  strcpy(v384, "nearend_tuning_max_inc_factor");
  v534 = 0;
  v528 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v535 = v383;
  v385 = *((float *)this + 115);
  v520 = off_24C0B4170;
  v521 = 0;
  v523 = 0;
  v522 = 0;
  v386 = (char *)operator new(0x28uLL);
  v524 = v386;
  v525 = xmmword_208F04EE0;
  if (v386 <= "nearend_tuning_max_dec_factor_lf" && v386 + 32 > "nearend_tuning_max_dec_factor_lf")
    goto LABEL_789;
  strcpy(v386, "nearend_tuning_max_dec_factor_lf");
  v526 = 0;
  v520 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v527 = v385;
  v387 = *v429;
  v512 = off_24C0B4170;
  v513 = 0;
  v515 = 0;
  v514 = 0;
  v388 = (char *)operator new(0x28uLL);
  v516 = v388;
  v517 = xmmword_208F086E0;
  if (v388 <= "normal_tuning_mask_lf_enr_transparent" && v388 + 37 > "normal_tuning_mask_lf_enr_transparent")
    goto LABEL_789;
  strcpy(v388, "normal_tuning_mask_lf_enr_transparent");
  v518 = 0;
  v512 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v519 = v387;
  v389 = *((float *)this + 101);
  v504 = off_24C0B4170;
  v505 = 0;
  v507 = 0;
  v506 = 0;
  v390 = (char *)operator new(0x28uLL);
  v508 = v390;
  v509 = xmmword_208F094E0;
  if (v390 <= "normal_tuning_mask_lf_enr_suppress" && v390 + 34 > "normal_tuning_mask_lf_enr_suppress")
    goto LABEL_789;
  strcpy(v390, "normal_tuning_mask_lf_enr_suppress");
  v510 = 0;
  v504 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v511 = v389;
  v391 = *v18;
  v496 = off_24C0B4170;
  v497 = 0;
  v499 = 0;
  v498 = 0;
  v392 = (char *)operator new(0x28uLL);
  v500 = v392;
  v501 = xmmword_208F086E0;
  if (v392 <= "normal_tuning_mask_hf_enr_transparent" && v392 + 37 > "normal_tuning_mask_hf_enr_transparent")
    goto LABEL_789;
  strcpy(v392, "normal_tuning_mask_hf_enr_transparent");
  v502 = 0;
  v496 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v503 = v391;
  v393 = *((float *)this + 104);
  v488 = off_24C0B4170;
  v489 = 0;
  v491 = 0;
  v490 = 0;
  v394 = (char *)operator new(0x28uLL);
  v492 = v394;
  v493 = xmmword_208F094E0;
  if (v394 <= "normal_tuning_mask_hf_enr_suppress" && v394 + 34 > "normal_tuning_mask_hf_enr_suppress")
    goto LABEL_789;
  strcpy(v394, "normal_tuning_mask_hf_enr_suppress");
  v494 = 0;
  v488 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v495 = v393;
  v395 = *v428;
  v480 = off_24C0B4170;
  v481 = 0;
  v483 = 0;
  v482 = 0;
  v396 = (char *)operator new(0x20uLL);
  v484 = v396;
  v485 = xmmword_208F05180;
  if (v396 <= "normal_tuning_max_inc_factor" && v396 + 28 > "normal_tuning_max_inc_factor")
    goto LABEL_789;
  strcpy(v396, "normal_tuning_max_inc_factor");
  v486 = 0;
  v480 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v487 = v395;
  v397 = *((float *)this + 107);
  v472 = off_24C0B4170;
  v473 = 0;
  v474 = 0;
  v475 = 0;
  v398 = (char *)operator new(0x20uLL);
  v476 = v398;
  v477 = xmmword_208F05170;
  if (v398 <= "normal_tuning_max_dec_factor_lf" && v398 + 31 > "normal_tuning_max_dec_factor_lf")
    goto LABEL_789;
  strcpy(v398, "normal_tuning_max_dec_factor_lf");
  v478 = 0;
  v472 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v479 = v397;
  v399 = *((float *)this + 121);
  v464 = off_24C0B4170;
  v465 = 0;
  v466 = 0;
  v467 = 0;
  v400 = (char *)operator new(0x30uLL);
  v468 = v400;
  v469 = xmmword_208F086B0;
  if (v400 <= "dominant_nearend_detection_enr_threshold" && v400 + 40 > "dominant_nearend_detection_enr_threshold")
    goto LABEL_789;
  strcpy(v400, "dominant_nearend_detection_enr_threshold");
  v470 = 0;
  v464 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v471 = v399;
  v401 = *((float *)this + 122);
  v456 = off_24C0B4170;
  v457 = 0;
  v458 = 0;
  v459 = 0;
  v402 = (char *)operator new(0x30uLL);
  v460 = v402;
  v461 = xmmword_208F08640;
  if (v402 <= "dominant_nearend_detection_enr_exit_threshold"
    && v402 + 45 > "dominant_nearend_detection_enr_exit_threshold")
  {
    goto LABEL_789;
  }
  strcpy(v402, "dominant_nearend_detection_enr_exit_threshold");
  v462 = 0;
  v456 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v463 = v401;
  v403 = *((float *)this + 123);
  v448 = off_24C0B4170;
  v449 = 0;
  v450 = 0;
  v451 = 0;
  v404 = (char *)operator new(0x30uLL);
  v452 = v404;
  v453 = xmmword_208F086B0;
  if (v404 <= "dominant_nearend_detection_snr_threshold" && v404 + 40 > "dominant_nearend_detection_snr_threshold")
    goto LABEL_789;
  strcpy(v404, "dominant_nearend_detection_snr_threshold");
  v454 = 0;
  v448 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v455 = v403;
  v405 = *((_DWORD *)this + 124);
  v440 = off_24C0B4170;
  v441 = 0;
  v442 = 0;
  v443 = 0;
  v406 = (char *)operator new(0x30uLL);
  v444 = v406;
  v445 = xmmword_208F086B0;
  if (v406 <= "dominant_nearend_detection_hold_duration" && v406 + 40 > "dominant_nearend_detection_hold_duration")
    goto LABEL_789;
  strcpy(v406, "dominant_nearend_detection_hold_duration");
  v446 = 0;
  v440 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B4020;
  v447 = v405;
  v407 = *((_DWORD *)this + 125);
  v432 = off_24C0B4170;
  v433 = 0;
  v434 = 0;
  v435 = 0;
  v408 = (char *)operator new(0x30uLL);
  __p = v408;
  v437 = xmmword_208F094F0;
  if (v408 <= "dominant_nearend_detection_trigger_threshold"
    && v408 + 44 > "dominant_nearend_detection_trigger_threshold")
  {
    goto LABEL_789;
  }
  strcpy(v408, "dominant_nearend_detection_trigger_threshold");
  v438 = 0;
  v432 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B4020;
  v439 = v407;
  v590 = &v560;
  v591 = &v552;
  v592 = &v544;
  v593 = &v536;
  v594 = &v528;
  v595 = &v520;
  v596 = &v512;
  v597 = &v504;
  v598 = &v496;
  v599 = &v488;
  v600 = &v480;
  v601 = &v472;
  v602 = &v464;
  v603 = &v456;
  v604 = &v448;
  v605 = &v440;
  v606 = &v432;
  if (((char)v570 & 0x80000000) == 0)
  {
    v409 = v570;
    v410 = (char *)&v568;
    goto LABEL_707;
  }
  v409 = v569;
  if (v569 < 0 || (v410 = (char *)v568, v569) && !v568)
LABEL_789:
    __break(1u);
LABEL_707:
  webrtc::ParseFieldTrial(&v590, 17, v410, v409);
  v411 = v567;
  *((float *)this + 108) = v411;
  v412 = v559;
  *((float *)this + 109) = v412;
  v413 = v551;
  *((float *)this + 111) = v413;
  v414 = v543;
  *((float *)this + 112) = v414;
  v415 = v535;
  *((float *)this + 114) = v415;
  v416 = v527;
  *((float *)this + 115) = v416;
  v417 = v519;
  *((float *)this + 100) = v417;
  v418 = v511;
  *((float *)this + 101) = v418;
  v419 = v503;
  *((float *)this + 103) = v419;
  v420 = v495;
  *((float *)this + 104) = v420;
  v421 = v487;
  *((float *)this + 106) = v421;
  v422 = v479;
  *((float *)this + 107) = v422;
  v423 = v471;
  *((float *)this + 121) = v423;
  v424 = v463;
  *((float *)this + 122) = v424;
  v425 = v455;
  *((float *)this + 123) = v425;
  *((_DWORD *)this + 124) = v447;
  *((_DWORD *)this + 125) = v439;
  LODWORD(v590) = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = (int)v590;
  v432 = off_24C0B4170;
  if (SHIBYTE(v437) < 0)
    operator delete(__p);
  if (v433)
  {
    v434 = v433;
    operator delete(v433);
  }
  v440 = off_24C0B4170;
  if (SHIBYTE(v445) < 0)
    operator delete(v444);
  if (v441)
  {
    v442 = v441;
    operator delete(v441);
  }
  v448 = off_24C0B4170;
  if (SHIBYTE(v453) < 0)
    operator delete(v452);
  if (v449)
  {
    v450 = v449;
    operator delete(v449);
  }
  v456 = off_24C0B4170;
  if (SHIBYTE(v461) < 0)
    operator delete(v460);
  if (v457)
  {
    v458 = v457;
    operator delete(v457);
  }
  v464 = off_24C0B4170;
  if (SHIBYTE(v469) < 0)
    operator delete(v468);
  if (v465)
  {
    v466 = v465;
    operator delete(v465);
  }
  v472 = off_24C0B4170;
  if (SHIBYTE(v477) < 0)
    operator delete(v476);
  if (v473)
  {
    v474 = v473;
    operator delete(v473);
  }
  v480 = off_24C0B4170;
  if (SHIBYTE(v485) < 0)
    operator delete(v484);
  if (v481)
  {
    v482 = v481;
    operator delete(v481);
  }
  v488 = off_24C0B4170;
  if (SHIBYTE(v493) < 0)
    operator delete(v492);
  if (v489)
  {
    v490 = v489;
    operator delete(v489);
  }
  v496 = off_24C0B4170;
  if (SHIBYTE(v501) < 0)
    operator delete(v500);
  if (v497)
  {
    v498 = v497;
    operator delete(v497);
  }
  v504 = off_24C0B4170;
  if (SHIBYTE(v509) < 0)
    operator delete(v508);
  if (v505)
  {
    v506 = v505;
    operator delete(v505);
  }
  v512 = off_24C0B4170;
  if (SHIBYTE(v517) < 0)
    operator delete(v516);
  if (v513)
  {
    v514 = v513;
    operator delete(v513);
  }
  v520 = off_24C0B4170;
  if (SHIBYTE(v525) < 0)
    operator delete(v524);
  if (v521)
  {
    v522 = v521;
    operator delete(v521);
  }
  v528 = off_24C0B4170;
  if (SHIBYTE(v533) < 0)
    operator delete(v532);
  if (v529)
  {
    v530 = v529;
    operator delete(v529);
  }
  v536 = off_24C0B4170;
  if (SHIBYTE(v541) < 0)
    operator delete(v540);
  if (v537)
  {
    v538 = v537;
    operator delete(v537);
  }
  v544 = off_24C0B4170;
  if (SHIBYTE(v549) < 0)
    operator delete(v548);
  if (v545)
  {
    v546 = v545;
    operator delete(v545);
  }
  v552 = off_24C0B4170;
  if (SHIBYTE(v557) < 0)
    operator delete(v556);
  if (v553)
  {
    v554 = v553;
    operator delete(v553);
  }
  v560 = off_24C0B4170;
  if (SHIBYTE(v565) < 0)
    operator delete(v564);
  if (v561)
  {
    v562 = v561;
    operator delete(v561);
  }
  if ((char)v570 < 0)
  {
    operator delete(v568);
    v571 = off_24C0B4170;
    if ((v576 & 0x80000000) == 0)
    {
LABEL_777:
      v426 = v572;
      if (!v572)
        goto LABEL_779;
      goto LABEL_778;
    }
  }
  else
  {
    v571 = off_24C0B4170;
    if ((v576 & 0x80000000) == 0)
      goto LABEL_777;
  }
  operator delete(v575[0]);
  v426 = v572;
  if (v572)
  {
LABEL_778:
    v573 = v426;
    operator delete(v426);
  }
LABEL_779:
  v579 = off_24C0B4170;
  if (v584 < 0)
    operator delete(v583[0]);
  if (v580)
  {
    v581 = v580;
    operator delete(v580);
  }
  if ((char)v589 < 0)
    operator delete(v587);
}

BOOL webrtc::field_trial::IsEnabled(size_t a1, size_t a2)
{
  uint64_t v2;
  int v3;
  void *v4;
  size_t *v5;
  size_t *v6;
  size_t *v7;
  _DWORD *v8;
  size_t *v9;
  size_t v13[2];
  unsigned __int8 v14;

  webrtc::field_trial::FindFullName(a1, a2, v13);
  v2 = v14;
  v3 = (char)v14;
  v4 = (void *)v13[0];
  if ((v14 & 0x80u) == 0)
  {
    v5 = v13;
  }
  else
  {
    v2 = v13[1];
    v5 = (size_t *)v13[0];
  }
  v6 = (size_t *)((char *)v5 + v2);
  if (v2 >= 7)
  {
    v7 = v5;
    do
    {
      v8 = memchr(v7, 69, v2 - 6);
      if (!v8)
        break;
      v9 = (size_t *)v8;
      if (*v8 == 1650552389 && *(_DWORD *)((char *)v8 + 3) == 1684368482)
        goto LABEL_13;
      v7 = (size_t *)((char *)v8 + 1);
      v2 = (char *)v6 - ((char *)v9 + 1);
    }
    while (v2 > 6);
  }
  v9 = v6;
LABEL_13:
  if (v3 < 0)
    operator delete(v4);
  return v9 != v6 && v9 == v5;
}

void webrtc::`anonymous namespace'::RetrieveFieldTrialValue(size_t a1, size_t a2, float *a3, float a4)
{
  double v6;
  uint64_t v7;
  char *v8;
  float v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void (**v18)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v19;
  void *v20;
  uint64_t v21;
  void *__p;
  __int16 v23;
  double v24;
  char *v25;
  uint64_t v26;
  unsigned __int8 v27;
  size_t v28;
  size_t v29;
  _QWORD v30[2];

  v30[1] = *MEMORY[0x24BDAC8D0];
  v28 = a1;
  v29 = a2;
  webrtc::field_trial::FindFullName(a1, a2, (size_t *)&v25);
  v6 = *a3;
  v23 = 0;
  v20 = 0;
  v21 = 0;
  LOBYTE(__p) = 0;
  v18 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B3FF0;
  v19 = 0;
  v24 = v6;
  v30[0] = &v18;
  if ((char)v27 < 0)
  {
    v7 = v26;
    if (v26 < 0 || (v8 = v25, v26) && !v25)
      __break(1u);
  }
  else
  {
    v7 = v27;
    v8 = (char *)&v25;
  }
  webrtc::ParseFieldTrial(v30, 1, v8, v7);
  v9 = v24;
  v10 = v9 < 0.0 || v9 > a4;
  if (!v10 && *a3 != v9)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t\v\t\a\t\a", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_processing/aec3/echo_canceller3.cc");
    *a3 = v9;
  }
  v18 = off_24C0B4170;
  if ((char)v23 < 0)
    operator delete(__p);
  if (v19)
  {
    v20 = v19;
    operator delete(v19);
  }
  if ((char)v27 < 0)
    operator delete(v25);
}

void webrtc::`anonymous namespace'::RetrieveFieldTrialValue(size_t a1, size_t a2, int a3, int *a4)
{
  int v6;
  uint64_t v7;
  char *v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void (**v17)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v18;
  void *v19;
  uint64_t v20;
  void *__p;
  __int16 v22;
  int v23;
  char *v24;
  uint64_t v25;
  unsigned __int8 v26;
  size_t v27;
  size_t v28;
  _QWORD v29[2];

  v29[1] = *MEMORY[0x24BDAC8D0];
  v27 = a1;
  v28 = a2;
  webrtc::field_trial::FindFullName(a1, a2, (size_t *)&v24);
  v6 = *a4;
  v22 = 0;
  v19 = 0;
  v20 = 0;
  LOBYTE(__p) = 0;
  v17 = (void (**)(webrtc::FieldTrialParameterInterface *__hidden))&unk_24C0B4020;
  v18 = 0;
  v23 = v6;
  v29[0] = &v17;
  if ((char)v26 < 0)
  {
    v7 = v25;
    if (v25 < 0 || (v8 = v24, v25) && !v24)
      __break(1u);
  }
  else
  {
    v7 = v26;
    v8 = (char *)&v24;
  }
  webrtc::ParseFieldTrial(v29, 1, v8, v7);
  if ((v23 & 0x80000000) == 0)
  {
    v9 = (float)v23;
    if ((float)v23 <= (float)a3 && v9 != (float)*a4)
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)11,std::string_view const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double> const&)::t, v10, v11, v12, v13, v14, v15, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_processing/aec3/echo_canceller3.cc");
      *a4 = (int)v9;
    }
  }
  v17 = off_24C0B4170;
  if ((char)v22 < 0)
    operator delete(__p);
  if (v18)
  {
    v19 = v18;
    operator delete(v18);
  }
  if ((char)v26 < 0)
    operator delete(v24);
}

void webrtc::EchoCanceller3::RenderWriter::~RenderWriter(webrtc::EchoCanceller3::RenderWriter *this)
{
  void **v2;
  void **v3;
  void *v4;
  void **v5;
  void *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;

  v2 = (void **)*((_QWORD *)this + 4);
  if (v2)
  {
    v3 = (void **)*((_QWORD *)this + 5);
    v4 = (void *)*((_QWORD *)this + 4);
    if (v3 != v2)
    {
      v5 = (void **)*((_QWORD *)this + 5);
      do
      {
        v8 = (char *)*(v5 - 3);
        v5 -= 3;
        v7 = v8;
        if (v8)
        {
          v9 = (char *)*(v3 - 2);
          v6 = v7;
          if (v9 != v7)
          {
            v10 = (char *)*(v3 - 2);
            do
            {
              v12 = (void *)*((_QWORD *)v10 - 3);
              v10 -= 24;
              v11 = v12;
              if (v12)
              {
                *((_QWORD *)v9 - 2) = v11;
                operator delete(v11);
              }
              v9 = v10;
            }
            while (v10 != v7);
            v6 = *v5;
          }
          *(v3 - 2) = v7;
          operator delete(v6);
        }
        v3 = v5;
      }
      while (v5 != v2);
      v4 = (void *)*((_QWORD *)this + 4);
    }
    *((_QWORD *)this + 5) = v2;
    operator delete(v4);
  }
  v13 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v13)
  {
    v14 = *(_QWORD **)(v13 + 8);
    if (v14)
    {
      v15 = *(_QWORD **)(v13 + 16);
      v16 = *(void **)(v13 + 8);
      if (v15 != v14)
      {
        do
        {
          v18 = *--v15;
          v17 = v18;
          *v15 = 0;
          if (v18)
          {
            v19 = *(void **)v17;
            if (*(_QWORD *)v17)
            {
              *(_QWORD *)(v17 + 8) = v19;
              operator delete(v19);
            }
            MEMORY[0x20BD0ADEC](v17, 0x20C40960023A9);
          }
        }
        while (v15 != v14);
        v16 = *(void **)(v13 + 8);
      }
      *(_QWORD *)(v13 + 16) = v14;
      operator delete(v16);
    }
    MEMORY[0x20BD0ADEC](v13, 0x1020C40E72D6CFBLL);
  }
}

uint64_t webrtc::EchoCanceller3::EchoCanceller3(uint64_t a1, const webrtc::EchoCanceller3Config *a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  unsigned int v12;
  _QWORD *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  BOOL v61;
  uint64_t v62;
  int v63;
  int v64;
  int v65;
  float v66;
  uint64_t v67;
  BOOL v69;
  size_t v70;
  unint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;
  char *v76;
  char *v77;
  char *v78;
  void **v79;
  void **v80;
  int64_t v81;
  void **v82;
  void **v83;
  int64_t v84;
  char *v85;
  uint64_t v86;
  char *v87;
  char *v88;
  char *v89;
  char *v90;
  char *v91;
  _BYTE *v92;
  _BYTE *v93;
  int64_t v94;
  char *v95;
  uint64_t v96;
  unint64_t v97;
  char *v98;
  char *v99;
  unint64_t v100;
  _QWORD *v101;
  void **v102;
  char *v103;
  char *v104;
  int64_t v105;
  unint64_t v106;
  char *v107;
  uint64_t v108;
  char *v109;
  char *v110;
  char *v111;
  char *v112;
  _BYTE *v113;
  _BYTE *v114;
  int64_t v115;
  uint64_t v116;
  void **v117;
  void *v118;
  char *v119;
  char *v120;
  char *v121;
  char *v122;
  void *v123;
  void *v124;
  char *v125;
  void *v126;
  void *v127;
  uint64_t v128;
  unint64_t v129;
  void *v130;
  uint64_t v131;
  char *v132;
  uint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  _QWORD *v137;
  int64_t v138;
  char *v139;
  uint64_t v140;
  char *v141;
  char *v142;
  char *v143;
  char *v144;
  _BYTE *v145;
  _BYTE *v146;
  int64_t v147;
  char *v148;
  void *v149;
  void *v150;
  int v151;
  int v152;
  int v153;
  unint64_t v154;
  size_t v155;
  char *v156;
  char *v157;
  size_t v158;
  unint64_t v159;
  int v160;
  unint64_t v161;
  size_t v162;
  char *v163;
  char *v164;
  size_t v165;
  size_t v166;
  char *v167;
  char *v168;
  uint64_t v169;
  size_t v170;
  char **v171;
  char **v172;
  int64_t v173;
  uint64_t v174;
  char **v175;
  char *v176;
  char *v177;
  uint64_t v178;
  webrtc::BlockDelayBuffer *v179;
  webrtc::BlockDelayBuffer *v180;
  uint64_t v181;
  void **v182;
  void **v183;
  void *v184;
  void **v185;
  void *v186;
  char *v187;
  char *v188;
  char *v189;
  char *v190;
  void *v191;
  void *v192;
  _QWORD *v193;
  _QWORD *v194;
  uint64_t v195;
  unint64_t v196;
  char *v197;
  uint64_t v198;
  char *v199;
  char *v200;
  char *v201;
  char *v202;
  _QWORD *v203;
  int64_t v204;
  char *v205;
  uint64_t v206;
  char *v207;
  char *v208;
  _BYTE *v209;
  _BYTE *v210;
  int64_t v211;
  char *v212;
  char *v213;
  char *v214;
  void *v215;
  void *v216;
  webrtc::HighPassFilter *v217;
  webrtc::HighPassFilter *v218;
  uint64_t v219;
  _QWORD *v220;
  _QWORD *v221;
  void *v222;
  uint64_t v223;
  uint64_t v224;
  void *v225;
  webrtc::EchoCanceller3::RenderWriter *v226;
  webrtc::BlockFramer *v227;
  webrtc::BlockFramer *v228;
  uint64_t v229;
  void **v230;
  void **v231;
  void *v232;
  void **v233;
  void *v234;
  char *v235;
  char *v236;
  char *v237;
  char *v238;
  void *v239;
  void *v240;
  uint64_t v241;
  unint64_t v242;
  char *v243;
  char *v244;
  uint64_t v245;
  void *v246;
  char *v247;
  char *v248;
  int64_t v249;
  char *v250;
  char *v251;
  _QWORD *v252;
  char *v253;
  char *v254;
  char *v255;
  char *v256;
  void *v257;
  void *v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  _QWORD *v267;
  char *v268;
  unint64_t v270;
  size_t __sz;
  void **__p;
  void **__pa;
  char *v274;
  uint64_t v275;
  _QWORD *v276;
  unint64_t v277;
  _QWORD *v278;
  unint64_t v279;
  char *v280;
  void *v281;
  _BYTE *v282;
  size_t v283;
  size_t v284;
  char *v285;
  unint64_t v286;
  unint64_t v287;
  unint64_t v288;
  void **v289;
  _QWORD *v290;
  _QWORD *v291;
  _OWORD v292[7];
  char v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  __int128 v297;
  __int128 v298;
  __int128 v299;
  __int128 v300;
  __int128 v301;
  __int128 v302;
  __int128 v303;
  __int128 v304;
  __int128 v305;
  _QWORD v306[5];
  _OWORD v307[2];
  int v308;
  uint64_t v309;
  uint64_t v310;
  int v311;
  uint64_t v312;
  int v313;
  uint64_t v314;
  uint64_t v315;
  int v316;
  uint64_t v317;
  int v318;
  uint64_t v319;
  __int128 v320;
  __int128 v321;
  __int128 v322;
  __int128 v323;
  __int128 v324;
  __int128 v325;
  _OWORD v326[3];

  *(_QWORD *)a1 = off_24C0B37E8;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v11 = operator new();
  do
    v12 = __ldaxr(&webrtc::EchoCanceller3::instance_count_);
  while (__stlxr(v12 + 1, &webrtc::EchoCanceller3::instance_count_));
  v13 = (_QWORD *)a1;
  *(_QWORD *)(a1 + 48) = v11;
  webrtc::AdjustConfig((webrtc *)(a1 + 56), a2);
  *(_DWORD *)(a1 + 664) = a4;
  *(_DWORD *)(a1 + 668) = a4 / 16000;
  *(_QWORD *)(a1 + 672) = a5;
  *(_QWORD *)(a1 + 688) = a6;
  webrtc::AdjustConfig((webrtc *)v292, a2);
  v14 = v292[5];
  *(_OWORD *)(a1 + 760) = v292[4];
  *(_OWORD *)(a1 + 776) = v14;
  *(_OWORD *)(a1 + 792) = v292[6];
  v15 = v292[1];
  *(_OWORD *)(a1 + 696) = v292[0];
  *(_OWORD *)(a1 + 712) = v15;
  v16 = v292[3];
  *(_OWORD *)(a1 + 728) = v292[2];
  *(_OWORD *)(a1 + 744) = v16;
  v17 = v305;
  v18 = *(_OWORD *)v306;
  v19 = v303;
  *(_OWORD *)(a1 + 976) = v304;
  *(_OWORD *)(a1 + 992) = v17;
  *(_OWORD *)(a1 + 1008) = v18;
  v20 = v301;
  *(_OWORD *)(a1 + 912) = v300;
  *(_OWORD *)(a1 + 928) = v20;
  *(_OWORD *)(a1 + 944) = v302;
  *(_OWORD *)(a1 + 960) = v19;
  v21 = v297;
  *(_OWORD *)(a1 + 848) = v296;
  *(_OWORD *)(a1 + 864) = v21;
  v22 = v299;
  *(_OWORD *)(a1 + 880) = v298;
  *(_OWORD *)(a1 + 896) = v22;
  v23 = v295;
  *(_OWORD *)(a1 + 816) = v294;
  *(_OWORD *)(a1 + 832) = v23;
  v24 = v307[0];
  *(_OWORD *)(a1 + 1032) = *(_OWORD *)&v306[3];
  *(_OWORD *)(a1 + 1048) = v24;
  *(_OWORD *)(a1 + 1057) = *(_OWORD *)((char *)v307 + 9);
  *(_OWORD *)(a1 + 1265) = *(_OWORD *)((char *)v326 + 9);
  v25 = v326[0];
  v26 = v326[2];
  v27 = v324;
  *(_OWORD *)(a1 + 1240) = v325;
  *(_OWORD *)(a1 + 1256) = v25;
  v28 = v322;
  *(_OWORD *)(a1 + 1208) = v323;
  *(_OWORD *)(a1 + 1224) = v27;
  v29 = v320;
  *(_OWORD *)(a1 + 1176) = v321;
  *(_OWORD *)(a1 + 1192) = v28;
  *(_OWORD *)(a1 + 1160) = v29;
  v30 = *(_DWORD *)(a1 + 672);
  *(_BYTE *)(a1 + 808) = v293;
  *(_QWORD *)(a1 + 1022) = *(_QWORD *)((char *)&v306[1] + 6);
  *(_DWORD *)(a1 + 1080) = v308;
  v31 = v310;
  *(_QWORD *)(a1 + 1088) = v309;
  *(_QWORD *)(a1 + 1096) = v31;
  *(_DWORD *)(a1 + 1104) = v311;
  *(_DWORD *)(a1 + 1116) = v313;
  *(_QWORD *)(a1 + 1108) = v312;
  v32 = v315;
  *(_QWORD *)(a1 + 1120) = v314;
  *(_QWORD *)(a1 + 1128) = v32;
  *(_DWORD *)(a1 + 1136) = v316;
  *(_QWORD *)(a1 + 1140) = v317;
  *(_DWORD *)(a1 + 1148) = v318;
  *(_QWORD *)(a1 + 1152) = v319;
  *(_OWORD *)(a1 + 1288) = v26;
  *(_BYTE *)(a1 + 1304) = 0;
  *(_BYTE *)(a1 + 1912) = 0;
  if (*(_BYTE *)(a3 + 608))
  {
    v33 = a1 + 1304;
    *(_OWORD *)(a1 + 1304) = *(_OWORD *)a3;
    v35 = *(_OWORD *)(a3 + 80);
    v34 = *(_OWORD *)(a3 + 96);
    v36 = *(_OWORD *)(a3 + 64);
    *(_BYTE *)(a1 + 1416) = *(_BYTE *)(a3 + 112);
    *(_OWORD *)(a1 + 1384) = v35;
    *(_OWORD *)(a1 + 1400) = v34;
    *(_OWORD *)(a1 + 1368) = v36;
    v37 = *(_OWORD *)(a3 + 16);
    v38 = *(_OWORD *)(a3 + 48);
    *(_OWORD *)(a1 + 1336) = *(_OWORD *)(a3 + 32);
    *(_OWORD *)(a1 + 1352) = v38;
    *(_OWORD *)(a1 + 1320) = v37;
    v39 = *(_OWORD *)(a3 + 168);
    v40 = *(_OWORD *)(a3 + 184);
    v41 = *(_OWORD *)(a3 + 200);
    *(_OWORD *)(a1 + 1456) = *(_OWORD *)(a3 + 152);
    *(_OWORD *)(a1 + 1504) = v41;
    *(_OWORD *)(a1 + 1488) = v40;
    *(_OWORD *)(a1 + 1472) = v39;
    v42 = *(_OWORD *)(a3 + 232);
    v43 = *(_OWORD *)(a3 + 248);
    v44 = *(_OWORD *)(a3 + 264);
    *(_OWORD *)(a1 + 1520) = *(_OWORD *)(a3 + 216);
    *(_OWORD *)(a1 + 1568) = v44;
    *(_OWORD *)(a1 + 1552) = v43;
    *(_OWORD *)(a1 + 1536) = v42;
    v46 = *(_OWORD *)(a3 + 296);
    v45 = *(_OWORD *)(a3 + 312);
    v47 = *(_QWORD *)(a3 + 326);
    *(_OWORD *)(a1 + 1584) = *(_OWORD *)(a3 + 280);
    *(_QWORD *)(a1 + 1630) = v47;
    *(_OWORD *)(a1 + 1616) = v45;
    *(_OWORD *)(a1 + 1600) = v46;
    v48 = *(_OWORD *)(a3 + 120);
    *(_OWORD *)(a1 + 1440) = *(_OWORD *)(a3 + 136);
    *(_OWORD *)(a1 + 1424) = v48;
    v49 = *(_OWORD *)(a3 + 336);
    v50 = *(_OWORD *)(a3 + 352);
    *(_OWORD *)(a1 + 1665) = *(_OWORD *)(a3 + 361);
    *(_OWORD *)(a1 + 1640) = v49;
    *(_OWORD *)(a1 + 1656) = v50;
    *(_DWORD *)(a1 + 1688) = *(_DWORD *)(a3 + 384);
    *(_QWORD *)(a1 + 1696) = *(_QWORD *)(a3 + 392);
    v51 = *(_QWORD *)(a3 + 400);
    *(_DWORD *)(a1 + 1712) = *(_DWORD *)(a3 + 408);
    *(_QWORD *)(a1 + 1704) = v51;
    v52 = *(_QWORD *)(a3 + 412);
    *(_DWORD *)(a1 + 1724) = *(_DWORD *)(a3 + 420);
    *(_QWORD *)(a1 + 1716) = v52;
    *(_QWORD *)(a1 + 1728) = *(_QWORD *)(a3 + 424);
    v53 = *(_QWORD *)(a3 + 432);
    *(_DWORD *)(a1 + 1744) = *(_DWORD *)(a3 + 440);
    *(_QWORD *)(a1 + 1736) = v53;
    v54 = *(_QWORD *)(a3 + 444);
    *(_DWORD *)(a1 + 1756) = *(_DWORD *)(a3 + 452);
    *(_QWORD *)(a1 + 1748) = v54;
    *(_QWORD *)(a1 + 1760) = *(_QWORD *)(a3 + 456);
    v55 = *(_OWORD *)(a3 + 464);
    v56 = *(_OWORD *)(a3 + 480);
    v57 = *(_OWORD *)(a3 + 496);
    *(_OWORD *)(a1 + 1816) = *(_OWORD *)(a3 + 512);
    *(_OWORD *)(a1 + 1800) = v57;
    *(_OWORD *)(a1 + 1784) = v56;
    *(_OWORD *)(a1 + 1768) = v55;
    v58 = *(_OWORD *)(a3 + 528);
    v59 = *(_OWORD *)(a3 + 544);
    v60 = *(_OWORD *)(a3 + 560);
    *(_OWORD *)(a1 + 1873) = *(_OWORD *)(a3 + 569);
    *(_OWORD *)(a1 + 1864) = v60;
    *(_OWORD *)(a1 + 1848) = v59;
    *(_OWORD *)(a1 + 1832) = v58;
    *(_OWORD *)(a1 + 1896) = *(_OWORD *)(a3 + 592);
    *(_BYTE *)(a1 + 1912) = 1;
  }
  else
  {
    v33 = a1 + 696;
  }
  if (*(_BYTE *)(a1 + 1288))
    v61 = 1;
  else
    v61 = v30 <= 1;
  if (v61)
    v62 = a1 + 696;
  else
    v62 = v33;
  *(_QWORD *)(a1 + 1920) = v62;
  v63 = *(unsigned __int8 *)(v62 + 592);
  v64 = *(_DWORD *)(v62 + 596);
  v65 = *(_DWORD *)(v62 + 600);
  v66 = *(float *)(v62 + 604);
  *(_BYTE *)(a1 + 1928) = v63;
  *(_DWORD *)(a1 + 1932) = v64;
  if (v65 < 1)
  {
    *(_BYTE *)(a1 + 1936) = 0;
    *(_BYTE *)(a1 + 1940) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 1936) = (100 * v65) | 0x100000000;
  }
  v67 = 0;
  *(_DWORD *)(a1 + 1944) = (int)(float)(v66 * 100.0);
  if (v30 >= 2 && v63)
  {
    v67 = operator new();
    *(_QWORD *)v67 = 0;
    *(_BYTE *)(v67 + 8) = 0;
  }
  *(_QWORD *)(a1 + 1952) = v67;
  v69 = v30 > 1 && v63 == 0;
  *(_BYTE *)(a1 + 1960) = v69;
  *(_BYTE *)(a1 + 1961) = 0;
  *(_QWORD *)(a1 + 1968) = 0;
  *(_QWORD *)(a1 + 1984) = 0;
  *(_QWORD *)(a1 + 1976) = 0;
  webrtc::BlockFramer::BlockFramer((webrtc::BlockFramer *)(a1 + 1992), *(int *)(a1 + 668), *(_QWORD *)(a1 + 688));
  webrtc::FrameBlocker::FrameBlocker((webrtc::FrameBlocker *)(a1 + 2032), *(int *)(a1 + 668), *(_QWORD *)(a1 + 688));
  *(_QWORD *)(a1 + 2072) = 0;
  v70 = *(int *)(a1 + 668);
  v71 = *(_QWORD *)(a1 + 672);
  v277 = v71;
  if (v71)
  {
    if (v71 > 0xAAAAAAAAAAAAAAALL)
      goto LABEL_59;
    v72 = 24 * v71;
    v73 = (char *)operator new(24 * v71);
    v74 = 0;
    v285 = &v73[v72];
    do
    {
      v75 = &v73[v74];
      *((_QWORD *)v75 + 1) = 0;
      *((_QWORD *)v75 + 2) = 0;
      v76 = v73;
      v77 = (char *)operator new(0x280uLL);
      *(_QWORD *)v75 = v77;
      v78 = v77 + 640;
      *((_QWORD *)v75 + 2) = v77 + 640;
      bzero(v77, 0x280uLL);
      v73 = v76;
      *((_QWORD *)v75 + 1) = v78;
      v74 += 24;
    }
    while (v72 != v74);
    v13 = (_QWORD *)a1;
    v280 = v76;
    if ((_DWORD)v70)
      goto LABEL_29;
LABEL_42:
    v80 = 0;
    v79 = 0;
    goto LABEL_44;
  }
  v285 = 0;
  v280 = 0;
  if (!(_DWORD)v70)
    goto LABEL_42;
LABEL_29:
  if ((v70 & 0x80000000) != 0)
    goto LABEL_59;
  v79 = (void **)operator new(24 * v70);
  v80 = &v79[3 * v70];
  v81 = v285 - v280;
  if (v285 == v280)
  {
    bzero(v79, 24 * ((24 * v70 - 24) / 0x18) + 24);
    v13 = (_QWORD *)a1;
  }
  else
  {
    v283 = v70;
    v288 = 0xAAAAAAAAAAAAAAABLL * (v81 >> 3);
    if (v288 > 0xAAAAAAAAAAAAAAALL)
      goto LABEL_230;
    __p = v79;
    v82 = v79;
    do
    {
      v83 = v80;
      v82[1] = 0;
      v82[2] = 0;
      v84 = v81;
      v85 = (char *)operator new(v81);
      v86 = 0;
      *v82 = v85;
      v82[1] = v85;
      v82[2] = &v85[24 * v288];
      v87 = v280;
      do
      {
        v90 = &v87[v86];
        v91 = &v85[v86];
        *(_QWORD *)v91 = 0;
        *((_QWORD *)v91 + 1) = 0;
        *((_QWORD *)v91 + 2) = 0;
        v93 = *(_BYTE **)&v87[v86];
        v92 = *(_BYTE **)&v87[v86 + 8];
        v94 = v92 - v93;
        if (v92 != v93)
        {
          if (v94 < 0)
            goto LABEL_59;
          v88 = (char *)operator new(v92 - v93);
          *(_QWORD *)v91 = v88;
          *((_QWORD *)v91 + 1) = v88;
          v89 = &v88[4 * (v94 >> 2)];
          *((_QWORD *)v91 + 2) = v89;
          memcpy(v88, v93, v94);
          v87 = v280;
          *((_QWORD *)v91 + 1) = v89;
        }
        v86 += 24;
      }
      while (v90 + 24 != v285);
      v82[1] = &v85[v86];
      v82 += 3;
      v80 = v83;
      v81 = v84;
    }
    while (v82 != v83);
    v13 = (_QWORD *)a1;
    v79 = __p;
    v70 = v283;
  }
LABEL_44:
  v267 = v13 + 260;
  v13[260] = v70;
  v13[261] = v277;
  v13[262] = 160;
  v13[263] = 0;
  v13[265] = 0;
  v13[264] = 0;
  v95 = (char *)operator new(0x960uLL);
  v96 = 0;
  v13[266] = v95;
  v13[267] = v95;
  __pa = v79;
  v274 = v95;
  v268 = v95 + 2400;
  v13[268] = v95 + 2400;
  __sz = (char *)v80 - (char *)v79;
  v97 = 0xAAAAAAAAAAAAAAABLL * (v80 - v79);
  v98 = v280;
  v284 = (size_t)v80;
  v270 = v97;
  do
  {
    v99 = &v274[24 * v96];
    *((_QWORD *)v99 + 1) = 0;
    v278 = v99 + 8;
    *((_QWORD *)v99 + 2) = 0;
    *(_QWORD *)v99 = 0;
    if (v80 != v79)
    {
      v275 = v96;
      if (v97 > 0xAAAAAAAAAAAAAAALL)
        goto LABEL_59;
      v100 = v97;
      v101 = operator new(__sz);
      *(_QWORD *)v99 = v101;
      *v278 = v101;
      *((_QWORD *)v99 + 2) = &v101[3 * v100];
      v102 = v79;
      do
      {
        *v101 = 0;
        v101[1] = 0;
        v101[2] = 0;
        v103 = (char *)*v102;
        v104 = (char *)v102[1];
        v105 = v104 - (_BYTE *)*v102;
        if (v104 != *v102)
        {
          v106 = 0xAAAAAAAAAAAAAAABLL * (v105 >> 3);
          if (v106 > 0xAAAAAAAAAAAAAAALL)
            goto LABEL_59;
          v289 = v102;
          v107 = (char *)operator new(v105);
          v108 = 0;
          *v101 = v107;
          v101[1] = v107;
          v101[2] = &v107[24 * v106];
          do
          {
            v111 = &v103[v108];
            v112 = &v107[v108];
            *(_QWORD *)v112 = 0;
            *((_QWORD *)v112 + 1) = 0;
            *((_QWORD *)v112 + 2) = 0;
            v114 = *(_BYTE **)&v103[v108];
            v113 = *(_BYTE **)&v103[v108 + 8];
            v115 = v113 - v114;
            if (v113 != v114)
            {
              if (v115 < 0)
                goto LABEL_59;
              v109 = (char *)operator new(v113 - v114);
              *(_QWORD *)v112 = v109;
              *((_QWORD *)v112 + 1) = v109;
              v110 = &v109[4 * (v115 >> 2)];
              *((_QWORD *)v112 + 2) = v110;
              memcpy(v109, v114, v115);
              *((_QWORD *)v112 + 1) = v110;
            }
            v108 += 24;
          }
          while (v111 + 24 != v104);
          v101[1] = &v107[v108];
          v80 = (void **)v284;
          v102 = v289;
        }
        v102 += 3;
        v101 += 3;
      }
      while (v102 != v80);
      v98 = v280;
      *v278 = v101;
      v79 = __pa;
      v96 = v275;
      v97 = v270;
    }
    ++v96;
  }
  while (v96 != 100);
  v116 = a1;
  *(_QWORD *)(a1 + 2136) = v268;
  if (v79)
  {
    if (v80 != v79)
    {
      v117 = v80;
      do
      {
        v120 = (char *)*(v117 - 3);
        v117 -= 3;
        v119 = v120;
        if (v120)
        {
          v121 = (char *)*(v80 - 2);
          v118 = v119;
          if (v121 != v119)
          {
            v122 = (char *)*(v80 - 2);
            do
            {
              v124 = (void *)*((_QWORD *)v122 - 3);
              v122 -= 24;
              v123 = v124;
              if (v124)
              {
                *((_QWORD *)v121 - 2) = v123;
                operator delete(v123);
              }
              v121 = v122;
            }
            while (v122 != v119);
            v118 = *v117;
            v79 = __pa;
          }
          *(v80 - 2) = v119;
          operator delete(v118);
        }
        v80 = v117;
      }
      while (v117 != v79);
    }
    operator delete(v79);
    v116 = a1;
    v98 = v280;
  }
  if (v98)
  {
    if (v285 != v98)
    {
      v125 = v285;
      do
      {
        v127 = (void *)*((_QWORD *)v125 - 3);
        v125 -= 24;
        v126 = v127;
        if (v127)
        {
          *((_QWORD *)v285 - 2) = v126;
          operator delete(v126);
        }
        v285 = v125;
        v98 = v280;
      }
      while (v125 != v280);
    }
    operator delete(v98);
  }
  *(_QWORD *)(v116 + 2152) = 0;
  v128 = *(int *)(v116 + 668);
  v129 = *(_QWORD *)(v116 + 672);
  v130 = operator new(0x280uLL);
  bzero(v130, 0x280uLL);
  if (v129)
  {
    if (v129 > 0xAAAAAAAAAAAAAAALL)
      goto LABEL_59;
    v131 = 24 * v129;
    v132 = (char *)operator new(24 * v129);
    v133 = 0;
    v129 = (unint64_t)&v132[24 * v129];
    do
    {
      v134 = &v132[v133];
      *((_QWORD *)v134 + 1) = 0;
      *((_QWORD *)v134 + 2) = 0;
      v135 = (char *)operator new(0x280uLL);
      *(_QWORD *)v134 = v135;
      v136 = v135 + 640;
      *((_QWORD *)v134 + 2) = v135 + 640;
      memcpy(v135, v130, 0x280uLL);
      *((_QWORD *)v134 + 1) = v136;
      v133 += 24;
    }
    while (v131 != v133);
    v116 = a1;
    *(_QWORD *)(a1 + 2160) = 0;
    *(_QWORD *)(a1 + 2168) = 0;
    *(_QWORD *)(a1 + 2176) = 0;
    if (!(_DWORD)v128)
      goto LABEL_100;
  }
  else
  {
    v132 = 0;
    *(_QWORD *)(v116 + 2160) = 0;
    *(_QWORD *)(v116 + 2168) = 0;
    *(_QWORD *)(v116 + 2176) = 0;
    if (!(_DWORD)v128)
      goto LABEL_100;
  }
  if ((v128 & 0x80000000) != 0)
    goto LABEL_59;
  v137 = operator new(24 * v128);
  *(_QWORD *)(v116 + 2160) = v137;
  *(_QWORD *)(v116 + 2168) = v137;
  v290 = &v137[3 * v128];
  *(_QWORD *)(v116 + 2176) = v290;
  v138 = v129 - (_QWORD)v132;
  v281 = v130;
  if ((char *)v129 == v132)
  {
    bzero(v137, 24 * ((24 * v128 - 24) / 0x18uLL) + 24);
  }
  else
  {
    v286 = 0xAAAAAAAAAAAAAAABLL * (v138 >> 3);
    if (v286 > 0xAAAAAAAAAAAAAAALL)
    {
      *v137 = 0;
      v137[1] = 0;
      v137[2] = 0;
      abort();
    }
    do
    {
      v137[1] = 0;
      v137[2] = 0;
      v139 = (char *)operator new(v138);
      v140 = 0;
      *v137 = v139;
      v137[1] = v139;
      v137[2] = &v139[24 * v286];
      do
      {
        v143 = &v132[v140];
        v144 = &v139[v140];
        *(_QWORD *)v144 = 0;
        *((_QWORD *)v144 + 1) = 0;
        *((_QWORD *)v144 + 2) = 0;
        v146 = *(_BYTE **)&v132[v140];
        v145 = *(_BYTE **)&v132[v140 + 8];
        v147 = v145 - v146;
        if (v145 != v146)
        {
          if (v147 < 0)
            goto LABEL_59;
          v141 = (char *)operator new(v145 - v146);
          *(_QWORD *)v144 = v141;
          *((_QWORD *)v144 + 1) = v141;
          v142 = &v141[4 * (v147 >> 2)];
          *((_QWORD *)v144 + 2) = v142;
          memcpy(v141, v146, v147);
          *((_QWORD *)v144 + 1) = v142;
        }
        v140 += 24;
      }
      while (v143 + 24 != (char *)v129);
      v137[1] = &v139[v140];
      v137 += 3;
      v138 = v129 - (_QWORD)v132;
    }
    while (v137 != v290);
  }
  v116 = a1;
  *(_QWORD *)(a1 + 2168) = v290;
  v130 = v281;
LABEL_100:
  if (v132)
  {
    if ((char *)v129 != v132)
    {
      v148 = (char *)v129;
      do
      {
        v150 = (void *)*((_QWORD *)v148 - 3);
        v148 -= 24;
        v149 = v150;
        if (v150)
        {
          *(_QWORD *)(v129 - 16) = v149;
          operator delete(v149);
        }
        v129 = (unint64_t)v148;
      }
      while (v148 != v132);
    }
    operator delete(v132);
    v116 = a1;
  }
  operator delete(v130);
  *(_BYTE *)(v116 + 2184) = 0;
  v151 = *(_DWORD *)(v116 + 668);
  v152 = *(_DWORD *)(v116 + 672);
  *(_DWORD *)(v116 + 2192) = v151;
  *(_DWORD *)(v116 + 2196) = v152;
  v153 = v151 * v152;
  *(_QWORD *)(v116 + 2200) = 0;
  *(_QWORD *)(v116 + 2216) = 0;
  *(_QWORD *)(v116 + 2208) = 0;
  if (v153)
  {
    v154 = (uint64_t)v153 << 6;
    if (v154 >> 62)
      goto LABEL_59;
    v155 = (uint64_t)v153 << 8;
    v156 = (char *)operator new(v155);
    *(_QWORD *)(a1 + 2200) = v156;
    v157 = &v156[4 * v154];
    *(_QWORD *)(a1 + 2216) = v157;
    v158 = v155;
    v116 = a1;
    bzero(v156, v158);
    *(_QWORD *)(a1 + 2208) = v157;
  }
  *(_QWORD *)(v116 + 2224) = 0;
  v159 = *(_QWORD *)(v116 + 688);
  *(_DWORD *)(v116 + 2232) = v151;
  *(_DWORD *)(v116 + 2236) = v159;
  v160 = v151 * v159;
  *(_QWORD *)(v116 + 2240) = 0;
  *(_QWORD *)(v116 + 2256) = 0;
  *(_QWORD *)(v116 + 2248) = 0;
  if (v151 * (_DWORD)v159)
  {
    v161 = (uint64_t)v160 << 6;
    if (v161 >> 62)
      goto LABEL_59;
    v162 = (uint64_t)v160 << 8;
    v163 = (char *)operator new(v162);
    *(_QWORD *)(a1 + 2240) = v163;
    v164 = &v163[4 * v161];
    *(_QWORD *)(a1 + 2256) = v164;
    v165 = v162;
    v116 = a1;
    bzero(v163, v165);
    *(_QWORD *)(a1 + 2248) = v164;
  }
  *(_OWORD *)(v116 + 2280) = 0u;
  *(_OWORD *)(v116 + 2296) = 0u;
  *(_OWORD *)(v116 + 2264) = 0u;
  if (v159)
  {
    if (v159 >> 60)
      goto LABEL_59;
    v166 = 16 * v159;
    v167 = (char *)operator new(v166);
    v168 = &v167[v166];
    bzero(v167, v166);
    *(_QWORD *)(a1 + 2312) = 0;
    *(_QWORD *)(a1 + 2320) = 0;
    *(_QWORD *)(a1 + 2328) = 0;
    if (!v151)
      goto LABEL_126;
  }
  else
  {
    v167 = 0;
    v168 = 0;
    *(_QWORD *)(a1 + 2312) = 0;
    *(_QWORD *)(a1 + 2320) = 0;
    *(_QWORD *)(a1 + 2328) = 0;
    if (!v151)
      goto LABEL_126;
  }
  if (v151 < 0)
    goto LABEL_59;
  v169 = v151;
  v170 = 3 * v151;
  v171 = (char **)operator new(v170 * 8);
  *(_QWORD *)(a1 + 2312) = v171;
  *(_QWORD *)(a1 + 2320) = v171;
  v172 = &v171[v170];
  *(_QWORD *)(a1 + 2328) = &v171[v170];
  v173 = v168 - v167;
  if (v168 == v167)
  {
    bzero(v171, 24 * ((v170 * 8 - 24) / 0x18) + 24);
  }
  else
  {
    if (v173 < 0)
    {
      *v171 = 0;
      v171[1] = 0;
      v171[2] = 0;
      abort();
    }
    v174 = 24 * v169;
    v175 = v171 + 1;
    do
    {
      *v175 = 0;
      v175[1] = 0;
      v176 = (char *)operator new(v173);
      *(v175 - 1) = v176;
      v177 = &v176[16 * (v173 >> 4)];
      v175[1] = v177;
      memcpy(v176, v167, v173);
      *v175 = v177;
      v175 += 3;
      v174 -= 24;
    }
    while (v174);
  }
  *(_QWORD *)(a1 + 2320) = v172;
LABEL_126:
  if (v167)
    operator delete(v167);
  v178 = a1;
  *(_QWORD *)(a1 + 2336) = 0;
  *(_OWORD *)(a1 + 2344) = xmmword_208F04D60;
  *(_QWORD *)(a1 + 2360) = 0;
  *(_WORD *)(a1 + 2368) = 0;
  if (*(_QWORD *)(*(_QWORD *)(a1 + 1920) + 56))
  {
    v179 = (webrtc::BlockDelayBuffer *)operator new();
    v180 = webrtc::BlockDelayBuffer::BlockDelayBuffer(v179, *(_QWORD *)(a1 + 688), *(int *)(a1 + 668), 160, *(_QWORD *)(a1 + 112));
    v181 = *(_QWORD *)(a1 + 2336);
    *(_QWORD *)(a1 + 2336) = v180;
    if (v181)
    {
      v182 = *(void ***)(v181 + 16);
      if (v182)
      {
        v183 = *(void ***)(v181 + 24);
        v184 = *(void **)(v181 + 16);
        if (v183 != v182)
        {
          v185 = *(void ***)(v181 + 24);
          do
          {
            v188 = (char *)*(v185 - 3);
            v185 -= 3;
            v187 = v188;
            if (v188)
            {
              v189 = (char *)*(v183 - 2);
              v186 = v187;
              if (v189 != v187)
              {
                v190 = (char *)*(v183 - 2);
                do
                {
                  v192 = (void *)*((_QWORD *)v190 - 3);
                  v190 -= 24;
                  v191 = v192;
                  if (v192)
                  {
                    *((_QWORD *)v189 - 2) = v191;
                    operator delete(v191);
                  }
                  v189 = v190;
                }
                while (v190 != v187);
                v186 = *v185;
              }
              *(v183 - 2) = v187;
              operator delete(v186);
            }
            v183 = v185;
          }
          while (v185 != v182);
          v184 = *(void **)(v181 + 16);
        }
        *(_QWORD *)(v181 + 24) = v182;
        operator delete(v184);
      }
      MEMORY[0x20BD0ADEC](v181, 0x1020C40C2CF8CA0);
      v178 = a1;
    }
  }
  v193 = (_QWORD *)operator new();
  v194 = v193;
  v282 = *(_BYTE **)(v178 + 1920);
  v195 = *(int *)(v178 + 668);
  v196 = *(_QWORD *)(v178 + 672);
  *v193 = *(_QWORD *)(v178 + 48);
  v193[1] = v195;
  v193[2] = v196;
  v193[3] = 0;
  if (v196)
  {
    if (v196 > 0xAAAAAAAAAAAAAAALL)
      goto LABEL_59;
    v197 = (char *)operator new(24 * v196);
    v198 = 0;
    v199 = &v197[24 * v196];
    do
    {
      v200 = &v197[v198];
      *((_QWORD *)v200 + 1) = 0;
      *((_QWORD *)v200 + 2) = 0;
      v201 = (char *)operator new(0x280uLL);
      *(_QWORD *)v200 = v201;
      v202 = v201 + 640;
      *((_QWORD *)v200 + 2) = v201 + 640;
      bzero(v201, 0x280uLL);
      *((_QWORD *)v200 + 1) = v202;
      v198 += 24;
    }
    while (24 * v196 != v198);
    v178 = a1;
    v194[4] = 0;
    v194[5] = 0;
    v194[6] = 0;
    if (!(_DWORD)v195)
      goto LABEL_164;
  }
  else
  {
    v199 = 0;
    v197 = 0;
    v193[4] = 0;
    v193[5] = 0;
    v193[6] = 0;
    if (!(_DWORD)v195)
      goto LABEL_164;
  }
  v279 = v196;
  if ((v195 & 0x80000000) != 0)
    goto LABEL_59;
  v203 = operator new(24 * v195);
  v194[4] = v203;
  v194[5] = v203;
  v291 = &v203[3 * v195];
  v194[6] = v291;
  v204 = v199 - v197;
  v276 = v194;
  if (v199 == v197)
  {
    bzero(v203, 24 * ((24 * v195 - 24) / 0x18uLL) + 24);
  }
  else
  {
    v287 = 0xAAAAAAAAAAAAAAABLL * (v204 >> 3);
    if (v287 > 0xAAAAAAAAAAAAAAALL)
    {
      *v203 = 0;
      v203[1] = 0;
      v203[2] = 0;
      abort();
    }
    do
    {
      v203[1] = 0;
      v203[2] = 0;
      v205 = (char *)operator new(v204);
      v206 = 0;
      *v203 = v205;
      v203[1] = v205;
      v203[2] = &v205[24 * v287];
      do
      {
        v207 = &v197[v206];
        v208 = &v205[v206];
        *(_QWORD *)v208 = 0;
        *((_QWORD *)v208 + 1) = 0;
        *((_QWORD *)v208 + 2) = 0;
        v210 = *(_BYTE **)&v197[v206];
        v209 = *(_BYTE **)&v197[v206 + 8];
        v211 = v209 - v210;
        if (v209 != v210)
        {
          if (v211 < 0)
            goto LABEL_59;
          v212 = (char *)operator new(v209 - v210);
          *(_QWORD *)v208 = v212;
          *((_QWORD *)v208 + 1) = v212;
          v213 = &v212[4 * (v211 >> 2)];
          *((_QWORD *)v208 + 2) = v213;
          memcpy(v212, v210, v211);
          *((_QWORD *)v208 + 1) = v213;
        }
        v206 += 24;
      }
      while (v207 + 24 != v199);
      v203[1] = &v205[v206];
      v203 += 3;
      v204 = v199 - v197;
    }
    while (v203 != v291);
  }
  v194 = v276;
  v196 = v279;
  v276[5] = v291;
  v178 = a1;
LABEL_164:
  if (v197)
  {
    if (v199 != v197)
    {
      v214 = v199;
      do
      {
        v216 = (void *)*((_QWORD *)v214 - 3);
        v214 -= 24;
        v215 = v216;
        if (v216)
        {
          *((_QWORD *)v199 - 2) = v215;
          operator delete(v215);
        }
        v199 = v214;
      }
      while (v214 != v197);
    }
    operator delete(v197);
  }
  v194[7] = v267;
  if (v282[235])
  {
    v217 = (webrtc::HighPassFilter *)operator new();
    v218 = webrtc::HighPassFilter::HighPassFilter(v217, 16000, v196);
    v219 = v194[3];
    v194[3] = v218;
    if (v219)
    {
      v220 = *(_QWORD **)(v219 + 8);
      if (v220)
      {
        v221 = *(_QWORD **)(v219 + 16);
        v222 = *(void **)(v219 + 8);
        if (v221 != v220)
        {
          do
          {
            v224 = *--v221;
            v223 = v224;
            *v221 = 0;
            if (v224)
            {
              v225 = *(void **)v223;
              if (*(_QWORD *)v223)
              {
                *(_QWORD *)(v223 + 8) = v225;
                operator delete(v225);
              }
              MEMORY[0x20BD0ADEC](v223, 0x20C40960023A9);
            }
          }
          while (v221 != v220);
          v222 = *(void **)(v219 + 8);
        }
        *(_QWORD *)(v219 + 16) = v220;
        operator delete(v222);
        v178 = a1;
      }
      MEMORY[0x20BD0ADEC](v219, 0x1020C40E72D6CFBLL);
    }
  }
  v226 = *(webrtc::EchoCanceller3::RenderWriter **)(v178 + 40);
  *(_QWORD *)(v178 + 40) = v194;
  if (v226)
  {
    webrtc::EchoCanceller3::RenderWriter::~RenderWriter(v226);
    MEMORY[0x20BD0ADEC]();
  }
  if (*(_BYTE *)(*(_QWORD *)(v178 + 1920) + 236))
  {
    v227 = (webrtc::BlockFramer *)operator new();
    v228 = webrtc::BlockFramer::BlockFramer(v227, 1uLL, *(_QWORD *)(v178 + 688));
    v229 = *(_QWORD *)(v178 + 1984);
    *(_QWORD *)(v178 + 1984) = v228;
    if (v229)
    {
      v230 = *(void ***)(v229 + 16);
      if (v230)
      {
        v231 = *(void ***)(v229 + 24);
        v232 = *(void **)(v229 + 16);
        if (v231 != v230)
        {
          v233 = *(void ***)(v229 + 24);
          do
          {
            v236 = (char *)*(v233 - 3);
            v233 -= 3;
            v235 = v236;
            if (v236)
            {
              v237 = (char *)*(v231 - 2);
              v234 = v235;
              if (v237 != v235)
              {
                v238 = (char *)*(v231 - 2);
                do
                {
                  v240 = (void *)*((_QWORD *)v238 - 3);
                  v238 -= 24;
                  v239 = v240;
                  if (v240)
                  {
                    *((_QWORD *)v237 - 2) = v239;
                    operator delete(v239);
                  }
                  v237 = v238;
                }
                while (v238 != v235);
                v234 = *v233;
              }
              *(v231 - 2) = v235;
              operator delete(v234);
            }
            v231 = v233;
          }
          while (v233 != v230);
          v232 = *(void **)(v229 + 16);
        }
        *(_QWORD *)(v229 + 24) = v230;
        operator delete(v232);
      }
      MEMORY[0x20BD0ADEC](v229, 0x1020C40DB654AE0);
    }
    v241 = operator new();
    v242 = *(_QWORD *)(a1 + 688);
    *(_DWORD *)v241 = 1;
    *(_DWORD *)(v241 + 4) = v242;
    *(_QWORD *)(v241 + 16) = 0;
    *(_QWORD *)(v241 + 24) = 0;
    *(_QWORD *)(v241 + 8) = 0;
    if ((_DWORD)v242)
    {
      if (((v242 << 32) & 0x8000000000000000) != 0)
        goto LABEL_59;
      v243 = (char *)operator new((v242 << 8) & 0xFFFFFFFFFFLL);
      *(_QWORD *)(v241 + 8) = v243;
      v244 = &v243[256 * (uint64_t)(int)v242];
      *(_QWORD *)(v241 + 24) = v244;
      bzero(v243, (v242 << 8) & 0xFFFFFFFFFFLL);
      *(_QWORD *)(v241 + 16) = v244;
    }
    v245 = *(_QWORD *)(a1 + 2224);
    *(_QWORD *)(a1 + 2224) = v241;
    if (v245)
    {
      v246 = *(void **)(v245 + 8);
      if (v246)
      {
        *(_QWORD *)(v245 + 16) = v246;
        operator delete(v246);
      }
      MEMORY[0x20BD0ADEC](v245, 0x1080C409938AC02);
      v242 = *(_QWORD *)(a1 + 688);
    }
    if (!v242)
    {
      v247 = 0;
      v79 = (void **)operator new(0x18uLL);
      goto LABEL_217;
    }
    if (!(v242 >> 60))
    {
      v247 = (char *)operator new(16 * v242);
      v248 = &v247[16 * v242];
      bzero(v247, 16 * v242);
      v79 = (void **)operator new(0x18uLL);
      v249 = 16 * v242;
      if (v248 != v247)
      {
        if ((v249 & 0x8000000000000000) == 0)
        {
          v250 = (char *)operator new(v248 - v247);
          *v79 = v250;
          v251 = &v250[16 * (v249 >> 4)];
          v79[2] = v251;
          memcpy(v250, v247, v249);
          v79[1] = v251;
          v252 = v79 + 3;
          v178 = a1;
          v253 = *(char **)(a1 + 2288);
          if (!v253)
          {
LABEL_225:
            *(_QWORD *)(v178 + 2288) = v79;
            *(_QWORD *)(v178 + 2296) = v252;
            *(_QWORD *)(v178 + 2304) = v252;
            if (v247)
              operator delete(v247);
            goto LABEL_227;
          }
LABEL_218:
          v254 = *(char **)(v178 + 2296);
          v255 = v253;
          if (v254 != v253)
          {
            v256 = *(char **)(v178 + 2296);
            do
            {
              v258 = (void *)*((_QWORD *)v256 - 3);
              v256 -= 24;
              v257 = v258;
              if (v258)
              {
                *((_QWORD *)v254 - 2) = v257;
                operator delete(v257);
              }
              v254 = v256;
            }
            while (v256 != v253);
            v178 = a1;
            v255 = *(char **)(a1 + 2288);
          }
          *(_QWORD *)(v178 + 2296) = v253;
          operator delete(v255);
          goto LABEL_225;
        }
LABEL_230:
        *v79 = 0;
        v79[1] = 0;
        v79[2] = 0;
        abort();
      }
LABEL_217:
      *v79 = 0;
      v79[1] = 0;
      v79[2] = 0;
      v252 = v79 + 3;
      v178 = a1;
      v253 = *(char **)(a1 + 2288);
      if (!v253)
        goto LABEL_225;
      goto LABEL_218;
    }
LABEL_59:
    abort();
  }
LABEL_227:
  webrtc::EchoCanceller3::Initialize((webrtc::EchoCanceller3 *)v178);
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long> const&)::t, v259, v260, v261, v262, v263, v264, v265, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_processing/aec3/echo_canceller3.cc");
  return v178;
}

void webrtc::EchoCanceller3::Initialize(webrtc::EchoCanceller3 *this)
{
  uint64_t v2;
  char *v3;
  unint64_t v4;
  char *v5;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  webrtc::FrameBlocker *v9;
  webrtc::FrameBlocker *v10;
  uint64_t v11;
  void **v12;
  void **v13;
  void *v14;
  void **v15;
  void *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  size_t v27;
  char *v28;
  char *v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  int64_t v33;
  unint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  void *v43;
  void *v44;

  if (*((_BYTE *)this + 1960))
  {
    v2 = *((_QWORD *)this + 84);
    *((_QWORD *)this + 85) = v2;
    v3 = (char *)this + 696;
    if (*((_BYTE *)this + 1912))
      v3 = (char *)this + 1304;
  }
  else
  {
    LODWORD(v2) = 1;
    *((_QWORD *)this + 85) = 1;
    v3 = (char *)this + 696;
  }
  *((_QWORD *)this + 240) = v3;
  *((_DWORD *)this + 549) = v2;
  v4 = (uint64_t)(*((_DWORD *)this + 548) * (int)v2) << 6;
  v5 = (char *)*((_QWORD *)this + 276);
  v6 = (char *)*((_QWORD *)this + 275);
  v7 = (v5 - v6) >> 2;
  if (v4 <= v7)
  {
    if (v4 < v7)
    {
      v5 = &v6[4 * v4];
      *((_QWORD *)this + 276) = v5;
    }
  }
  else
  {
    std::vector<float>::__append((uint64_t)this + 2200, v4 - v7);
    v6 = (char *)*((_QWORD *)this + 275);
    v5 = (char *)*((_QWORD *)this + 276);
  }
  v8 = v5 - v6;
  if (v8 >= 1)
    bzero(v6, 4 * (((unint64_t)v8 >> 2) - ((unint64_t)v8 > 3)) + 4);
  v9 = (webrtc::FrameBlocker *)operator new();
  v10 = webrtc::FrameBlocker::FrameBlocker(v9, *((int *)this + 167), *((_QWORD *)this + 85));
  v11 = *((_QWORD *)this + 259);
  *((_QWORD *)this + 259) = v10;
  if (v11)
  {
    v12 = *(void ***)(v11 + 16);
    if (v12)
    {
      v13 = *(void ***)(v11 + 24);
      v14 = *(void **)(v11 + 16);
      if (v13 != v12)
      {
        v15 = *(void ***)(v11 + 24);
        do
        {
          v18 = (char *)*(v15 - 3);
          v15 -= 3;
          v17 = v18;
          if (v18)
          {
            v19 = (char *)*(v13 - 2);
            v16 = v17;
            if (v19 != v17)
            {
              v20 = (char *)*(v13 - 2);
              do
              {
                v22 = (void *)*((_QWORD *)v20 - 3);
                v20 -= 24;
                v21 = v22;
                if (v22)
                {
                  *((_QWORD *)v19 - 2) = v21;
                  operator delete(v21);
                }
                v19 = v20;
              }
              while (v20 != v17);
              v16 = *v15;
            }
            *(v13 - 2) = v17;
            operator delete(v16);
          }
          v13 = v15;
        }
        while (v15 != v12);
        v14 = *(void **)(v11 + 16);
      }
      *(_QWORD *)(v11 + 24) = v12;
      operator delete(v14);
    }
    MEMORY[0x20BD0ADEC](v11, 0x1020C40DB654AE0);
  }
  v23 = webrtc::BlockProcessor::Create(*((webrtc::BlockProcessor **)this + 240), (const webrtc::EchoCanceller3Config *)*((unsigned int *)this + 166), *((_QWORD *)this + 85), *((_QWORD *)this + 86));
  v24 = *((_QWORD *)this + 269);
  *((_QWORD *)this + 269) = v23;
  if (v24)
    (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
  v25 = *((int *)this + 167);
  v26 = *((_QWORD *)this + 85);
  if (v26)
  {
    if (v26 >> 60)
      goto LABEL_54;
    v27 = 16 * v26;
    v28 = (char *)operator new(16 * v26);
    v29 = &v28[v27];
    bzero(v28, v27);
    if ((_DWORD)v25)
      goto LABEL_33;
LABEL_40:
    v31 = 0;
    v32 = 0;
    goto LABEL_41;
  }
  v28 = 0;
  v29 = 0;
  if (!(_DWORD)v25)
    goto LABEL_40;
LABEL_33:
  if ((v25 & 0x80000000) != 0)
LABEL_54:
    abort();
  v30 = operator new(24 * v25);
  v31 = v30;
  v32 = &v30[3 * v25];
  v33 = v29 - v28;
  if (!v33)
  {
    bzero(v30, 24 * ((24 * v25 - 24) / 0x18uLL) + 24);
    v39 = (char *)*((_QWORD *)this + 283);
    if (!v39)
      goto LABEL_49;
    goto LABEL_42;
  }
  if (v33 < 0)
  {
    *v30 = 0;
    v30[1] = 0;
    v30[2] = 0;
    abort();
  }
  v34 = 0;
  v35 = 24 * v25;
  do
  {
    v36 = &v31[v34 / 8];
    v36[1] = 0;
    v36[2] = 0;
    v37 = (char *)operator new(v33);
    *v36 = v37;
    v38 = &v37[16 * (v33 >> 4)];
    v36[2] = v38;
    memcpy(v37, v28, v33);
    v36[1] = v38;
    v34 += 24;
  }
  while (v35 != v34);
LABEL_41:
  v39 = (char *)*((_QWORD *)this + 283);
  if (!v39)
    goto LABEL_49;
LABEL_42:
  v40 = (char *)*((_QWORD *)this + 284);
  v41 = v39;
  if (v40 != v39)
  {
    v42 = (char *)*((_QWORD *)this + 284);
    do
    {
      v44 = (void *)*((_QWORD *)v42 - 3);
      v42 -= 24;
      v43 = v44;
      if (v44)
      {
        *((_QWORD *)v40 - 2) = v43;
        operator delete(v43);
      }
      v40 = v42;
    }
    while (v42 != v39);
    v41 = (char *)*((_QWORD *)this + 283);
  }
  *((_QWORD *)this + 284) = v39;
  operator delete(v41);
LABEL_49:
  *((_QWORD *)this + 283) = v31;
  *((_QWORD *)this + 284) = v32;
  *((_QWORD *)this + 285) = v32;
  if (v28)
    operator delete(v28);
}

void webrtc::EchoCanceller3::~EchoCanceller3(webrtc::EchoCanceller3 *this)
{
  uint64_t v2;
  void **v3;
  void **v4;
  void *v5;
  void **v6;
  void *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  void *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  void *v30;
  void *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  void *v35;
  void **v36;
  void **v37;
  void *v38;
  void **v39;
  void *v40;
  char *v41;
  char *v42;
  char *v43;
  char *v44;
  void *v45;
  void *v46;
  uint64_t v47;
  void **v48;
  void **v49;
  void *v50;
  void **v51;
  void *v52;
  void **v53;
  void **v54;
  void **v55;
  void **v56;
  void *v57;
  char *v58;
  char *v59;
  char *v60;
  char *v61;
  void *v62;
  void *v63;
  uint64_t v64;
  void **v65;
  void **v66;
  void *v67;
  void **v68;
  void *v69;
  char *v70;
  char *v71;
  char *v72;
  char *v73;
  void *v74;
  void *v75;
  void **v76;
  void **v77;
  void *v78;
  void **v79;
  void *v80;
  char *v81;
  char *v82;
  char *v83;
  char *v84;
  void *v85;
  void *v86;
  void **v87;
  void **v88;
  void *v89;
  void **v90;
  void *v91;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  void *v96;
  void *v97;
  uint64_t v98;
  void **v99;
  void **v100;
  void *v101;
  void **v102;
  void *v103;
  char *v104;
  char *v105;
  char *v106;
  char *v107;
  void *v108;
  void *v109;
  uint64_t v110;
  uint64_t v111;
  webrtc::EchoCanceller3::RenderWriter *v112;

  *(_QWORD *)this = off_24C0B37E8;
  v2 = *((_QWORD *)this + 292);
  *((_QWORD *)this + 292) = 0;
  if (v2)
  {
    v3 = *(void ***)(v2 + 16);
    if (v3)
    {
      v4 = *(void ***)(v2 + 24);
      v5 = *(void **)(v2 + 16);
      if (v4 != v3)
      {
        v6 = *(void ***)(v2 + 24);
        do
        {
          v9 = (char *)*(v6 - 3);
          v6 -= 3;
          v8 = v9;
          if (v9)
          {
            v10 = (char *)*(v4 - 2);
            v7 = v8;
            if (v10 != v8)
            {
              v11 = (char *)*(v4 - 2);
              do
              {
                v13 = (void *)*((_QWORD *)v11 - 3);
                v11 -= 24;
                v12 = v13;
                if (v13)
                {
                  *((_QWORD *)v10 - 2) = v12;
                  operator delete(v12);
                }
                v10 = v11;
              }
              while (v11 != v8);
              v7 = *v6;
            }
            *(v4 - 2) = v8;
            operator delete(v7);
          }
          v4 = v6;
        }
        while (v6 != v3);
        v5 = *(void **)(v2 + 16);
      }
      *(_QWORD *)(v2 + 24) = v3;
      operator delete(v5);
    }
    MEMORY[0x20BD0ADEC](v2, 0x1020C40C2CF8CA0);
  }
  v14 = *((_QWORD *)this + 289);
  if (v14)
  {
    v15 = *((_QWORD *)this + 290);
    v16 = (void *)*((_QWORD *)this + 289);
    if (v15 != v14)
    {
      v17 = *((_QWORD *)this + 290);
      do
      {
        v19 = *(void **)(v17 - 24);
        v17 -= 24;
        v18 = v19;
        if (v19)
        {
          *(_QWORD *)(v15 - 16) = v18;
          operator delete(v18);
        }
        v15 = v17;
      }
      while (v17 != v14);
      v16 = (void *)*((_QWORD *)this + 289);
    }
    *((_QWORD *)this + 290) = v14;
    operator delete(v16);
  }
  v20 = *((_QWORD *)this + 286);
  if (v20)
  {
    v21 = *((_QWORD *)this + 287);
    v22 = (void *)*((_QWORD *)this + 286);
    if (v21 != v20)
    {
      v23 = *((_QWORD *)this + 287);
      do
      {
        v25 = *(void **)(v23 - 24);
        v23 -= 24;
        v24 = v25;
        if (v25)
        {
          *(_QWORD *)(v21 - 16) = v24;
          operator delete(v24);
        }
        v21 = v23;
      }
      while (v23 != v20);
      v22 = (void *)*((_QWORD *)this + 286);
    }
    *((_QWORD *)this + 287) = v20;
    operator delete(v22);
  }
  v26 = *((_QWORD *)this + 283);
  if (v26)
  {
    v27 = *((_QWORD *)this + 284);
    v28 = (void *)*((_QWORD *)this + 283);
    if (v27 != v26)
    {
      v29 = *((_QWORD *)this + 284);
      do
      {
        v31 = *(void **)(v29 - 24);
        v29 -= 24;
        v30 = v31;
        if (v31)
        {
          *(_QWORD *)(v27 - 16) = v30;
          operator delete(v30);
        }
        v27 = v29;
      }
      while (v29 != v26);
      v28 = (void *)*((_QWORD *)this + 283);
    }
    *((_QWORD *)this + 284) = v26;
    operator delete(v28);
  }
  v32 = (void *)*((_QWORD *)this + 280);
  if (v32)
  {
    *((_QWORD *)this + 281) = v32;
    operator delete(v32);
  }
  v33 = *((_QWORD *)this + 278);
  *((_QWORD *)this + 278) = 0;
  if (v33)
  {
    v34 = *(void **)(v33 + 8);
    if (v34)
    {
      *(_QWORD *)(v33 + 16) = v34;
      operator delete(v34);
    }
    MEMORY[0x20BD0ADEC](v33, 0x1080C409938AC02);
  }
  v35 = (void *)*((_QWORD *)this + 275);
  if (v35)
  {
    *((_QWORD *)this + 276) = v35;
    operator delete(v35);
  }
  v36 = (void **)*((_QWORD *)this + 270);
  if (v36)
  {
    v37 = (void **)*((_QWORD *)this + 271);
    v38 = (void *)*((_QWORD *)this + 270);
    if (v37 != v36)
    {
      v39 = (void **)*((_QWORD *)this + 271);
      do
      {
        v42 = (char *)*(v39 - 3);
        v39 -= 3;
        v41 = v42;
        if (v42)
        {
          v43 = (char *)*(v37 - 2);
          v40 = v41;
          if (v43 != v41)
          {
            v44 = (char *)*(v37 - 2);
            do
            {
              v46 = (void *)*((_QWORD *)v44 - 3);
              v44 -= 24;
              v45 = v46;
              if (v46)
              {
                *((_QWORD *)v43 - 2) = v45;
                operator delete(v45);
              }
              v43 = v44;
            }
            while (v44 != v41);
            v40 = *v39;
          }
          *(v37 - 2) = v41;
          operator delete(v40);
        }
        v37 = v39;
      }
      while (v39 != v36);
      v38 = (void *)*((_QWORD *)this + 270);
    }
    *((_QWORD *)this + 271) = v36;
    operator delete(v38);
  }
  v47 = *((_QWORD *)this + 269);
  *((_QWORD *)this + 269) = 0;
  if (v47)
    (*(void (**)(uint64_t))(*(_QWORD *)v47 + 8))(v47);
  v48 = (void **)*((_QWORD *)this + 266);
  if (v48)
  {
    v49 = (void **)*((_QWORD *)this + 267);
    v50 = (void *)*((_QWORD *)this + 266);
    if (v49 != v48)
    {
      v51 = (void **)*((_QWORD *)this + 267);
      do
      {
        v54 = (void **)*(v51 - 3);
        v51 -= 3;
        v53 = v54;
        if (v54)
        {
          v55 = (void **)*(v49 - 2);
          v52 = v53;
          if (v55 != v53)
          {
            v56 = (void **)*(v49 - 2);
            do
            {
              v59 = (char *)*(v56 - 3);
              v56 -= 3;
              v58 = v59;
              if (v59)
              {
                v60 = (char *)*(v55 - 2);
                v57 = v58;
                if (v60 != v58)
                {
                  v61 = (char *)*(v55 - 2);
                  do
                  {
                    v63 = (void *)*((_QWORD *)v61 - 3);
                    v61 -= 24;
                    v62 = v63;
                    if (v63)
                    {
                      *((_QWORD *)v60 - 2) = v62;
                      operator delete(v62);
                    }
                    v60 = v61;
                  }
                  while (v61 != v58);
                  v57 = *v56;
                }
                *(v55 - 2) = v58;
                operator delete(v57);
              }
              v55 = v56;
            }
            while (v56 != v53);
            v52 = *v51;
          }
          *(v49 - 2) = v53;
          operator delete(v52);
        }
        v49 = v51;
      }
      while (v51 != v48);
      v50 = (void *)*((_QWORD *)this + 266);
    }
    *((_QWORD *)this + 267) = v48;
    operator delete(v50);
  }
  v64 = *((_QWORD *)this + 259);
  *((_QWORD *)this + 259) = 0;
  if (v64)
  {
    v65 = *(void ***)(v64 + 16);
    if (v65)
    {
      v66 = *(void ***)(v64 + 24);
      v67 = *(void **)(v64 + 16);
      if (v66 != v65)
      {
        v68 = *(void ***)(v64 + 24);
        do
        {
          v71 = (char *)*(v68 - 3);
          v68 -= 3;
          v70 = v71;
          if (v71)
          {
            v72 = (char *)*(v66 - 2);
            v69 = v70;
            if (v72 != v70)
            {
              v73 = (char *)*(v66 - 2);
              do
              {
                v75 = (void *)*((_QWORD *)v73 - 3);
                v73 -= 24;
                v74 = v75;
                if (v75)
                {
                  *((_QWORD *)v72 - 2) = v74;
                  operator delete(v74);
                }
                v72 = v73;
              }
              while (v73 != v70);
              v69 = *v68;
            }
            *(v66 - 2) = v70;
            operator delete(v69);
          }
          v66 = v68;
        }
        while (v68 != v65);
        v67 = *(void **)(v64 + 16);
      }
      *(_QWORD *)(v64 + 24) = v65;
      operator delete(v67);
    }
    MEMORY[0x20BD0ADEC](v64, 0x1020C40DB654AE0);
  }
  v76 = (void **)*((_QWORD *)this + 256);
  if (v76)
  {
    v77 = (void **)*((_QWORD *)this + 257);
    v78 = (void *)*((_QWORD *)this + 256);
    if (v77 != v76)
    {
      v79 = (void **)*((_QWORD *)this + 257);
      do
      {
        v82 = (char *)*(v79 - 3);
        v79 -= 3;
        v81 = v82;
        if (v82)
        {
          v83 = (char *)*(v77 - 2);
          v80 = v81;
          if (v83 != v81)
          {
            v84 = (char *)*(v77 - 2);
            do
            {
              v86 = (void *)*((_QWORD *)v84 - 3);
              v84 -= 24;
              v85 = v86;
              if (v86)
              {
                *((_QWORD *)v83 - 2) = v85;
                operator delete(v85);
              }
              v83 = v84;
            }
            while (v84 != v81);
            v80 = *v79;
          }
          *(v77 - 2) = v81;
          operator delete(v80);
        }
        v77 = v79;
      }
      while (v79 != v76);
      v78 = (void *)*((_QWORD *)this + 256);
    }
    *((_QWORD *)this + 257) = v76;
    operator delete(v78);
  }
  v87 = (void **)*((_QWORD *)this + 251);
  if (v87)
  {
    v88 = (void **)*((_QWORD *)this + 252);
    v89 = (void *)*((_QWORD *)this + 251);
    if (v88 != v87)
    {
      v90 = (void **)*((_QWORD *)this + 252);
      do
      {
        v93 = (char *)*(v90 - 3);
        v90 -= 3;
        v92 = v93;
        if (v93)
        {
          v94 = (char *)*(v88 - 2);
          v91 = v92;
          if (v94 != v92)
          {
            v95 = (char *)*(v88 - 2);
            do
            {
              v97 = (void *)*((_QWORD *)v95 - 3);
              v95 -= 24;
              v96 = v97;
              if (v97)
              {
                *((_QWORD *)v94 - 2) = v96;
                operator delete(v96);
              }
              v94 = v95;
            }
            while (v95 != v92);
            v91 = *v90;
          }
          *(v88 - 2) = v92;
          operator delete(v91);
        }
        v88 = v90;
      }
      while (v90 != v87);
      v89 = (void *)*((_QWORD *)this + 251);
    }
    *((_QWORD *)this + 252) = v87;
    operator delete(v89);
  }
  v98 = *((_QWORD *)this + 248);
  *((_QWORD *)this + 248) = 0;
  if (v98)
  {
    v99 = *(void ***)(v98 + 16);
    if (v99)
    {
      v100 = *(void ***)(v98 + 24);
      v101 = *(void **)(v98 + 16);
      if (v100 != v99)
      {
        v102 = *(void ***)(v98 + 24);
        do
        {
          v105 = (char *)*(v102 - 3);
          v102 -= 3;
          v104 = v105;
          if (v105)
          {
            v106 = (char *)*(v100 - 2);
            v103 = v104;
            if (v106 != v104)
            {
              v107 = (char *)*(v100 - 2);
              do
              {
                v109 = (void *)*((_QWORD *)v107 - 3);
                v107 -= 24;
                v108 = v109;
                if (v109)
                {
                  *((_QWORD *)v106 - 2) = v108;
                  operator delete(v108);
                }
                v106 = v107;
              }
              while (v107 != v104);
              v103 = *v102;
            }
            *(v100 - 2) = v104;
            operator delete(v103);
          }
          v100 = v102;
        }
        while (v102 != v99);
        v101 = *(void **)(v98 + 16);
      }
      *(_QWORD *)(v98 + 24) = v99;
      operator delete(v101);
    }
    MEMORY[0x20BD0ADEC](v98, 0x1020C40DB654AE0);
  }
  v110 = *((_QWORD *)this + 244);
  *((_QWORD *)this + 244) = 0;
  if (v110)
    MEMORY[0x20BD0ADEC](v110, 0x1000C4005A209FELL);
  v111 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v111)
    MEMORY[0x20BD0ADEC](v111, 0xC400A2AC0F1);
  v112 = (webrtc::EchoCanceller3::RenderWriter *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v112)
  {
    webrtc::EchoCanceller3::RenderWriter::~RenderWriter(v112);
    MEMORY[0x20BD0ADEC]();
  }
}

{
  webrtc::EchoCanceller3::~EchoCanceller3(this);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::EchoCanceller3::ProcessCapture(webrtc::EchoCanceller3 *this, webrtc::AudioBuffer *a2, uint64_t a3)
{
  return (*(uint64_t (**)(webrtc::EchoCanceller3 *, webrtc::AudioBuffer *, _QWORD, uint64_t))(*(_QWORD *)this + 24))(this, a2, 0, a3);
}

void webrtc::EchoCanceller3::ProcessCapture(webrtc::EchoCanceller3 *this, webrtc::AudioBuffer *a2, webrtc::AudioBuffer *a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  _QWORD **v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  unint64_t *v41;
  unint64_t *v42;
  char *v43;
  _QWORD **v44;
  _QWORD *v45;
  int v46;
  int v47;
  unint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  _BOOL8 v51;
  uint64_t v52;
  unsigned int v54;

  if (a3 && !*((_QWORD *)this + 248) && (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t", v7, v8, v9, v10, v11, v12, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_processing/aec3/echo_canceller3.cc");
  v54 = a4;
  webrtc::ApiCallJitterMetrics::ReportCaptureCall((webrtc::EchoCanceller3 *)((char *)this + 2344));
  if (*(_QWORD *)(*((_QWORD *)this + 240) + 56))
    webrtc::BlockDelayBuffer::DelaySignal(*((uint64_t **)this + 292), a2);
  v14 = (unint64_t *)((char *)this + 2120);
  if (atomic_load((unint64_t *)this + 265))
  {
    v16 = *((_QWORD *)this + 264);
    v17 = *((_QWORD *)this + 266);
    if (0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 267) - v17) >> 3) > v16)
    {
      v18 = (_QWORD *)(v17 + 24 * v16);
      v19 = *((_QWORD *)this + 270);
      *((_QWORD *)this + 270) = *v18;
      *v18 = v19;
      v20 = *((_QWORD *)this + 271);
      *((_QWORD *)this + 271) = v18[1];
      v18[1] = v20;
      v21 = *((_QWORD *)this + 272);
      *((_QWORD *)this + 272) = v18[2];
      v18[2] = v21;
      do
        v22 = __ldxr(v14);
      while (__stlxr(v22 - 1, v14));
      v23 = *((_QWORD *)this + 264);
      if (v23 + 1 == 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 267) - *((_QWORD *)this + 266)) >> 3))
        v24 = 0;
      else
        v24 = v23 + 1;
      *((_QWORD *)this + 264) = v24;
      if (!*((_BYTE *)this + 2368))
        goto LABEL_29;
LABEL_15:
      ++*((_DWORD *)this + 590);
      *((_BYTE *)this + 2368) = 1;
      if (webrtc::MultiChannelContentDetector::UpdateDetection((uint64_t)this + 1928, (uint64_t)this + 2160))LABEL_16:webrtc::EchoCanceller3::Initialize(this);
      while (1)
      {
        v25 = (unint64_t *)*((_QWORD *)this + 259);
        v26 = (_QWORD **)v25[2];
        if ((_QWORD **)v25[3] == v26)
          break;
        v27 = *v26;
        if (*(_QWORD **)(v25[2] + 8) == v27)
          break;
        if (v27[1] - *v27 == 256)
        {
          v28 = *((_QWORD *)this + 269);
          webrtc::FrameBlocker::ExtractBlock(v25, (uint64_t)this + 2192);
          (*(void (**)(uint64_t, char *))(*(_QWORD *)v28 + 40))(v28, (char *)this + 2192);
        }
        if (!atomic_load(v14))
          goto LABEL_37;
        v30 = *((_QWORD *)this + 264);
        v31 = *((_QWORD *)this + 266);
        if (0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 267) - v31) >> 3) <= v30)
          goto LABEL_46;
        v32 = (_QWORD *)(v31 + 24 * v30);
        v33 = *((_QWORD *)this + 270);
        *((_QWORD *)this + 270) = *v32;
        *v32 = v33;
        v34 = *((_QWORD *)this + 271);
        *((_QWORD *)this + 271) = v32[1];
        v32[1] = v34;
        v35 = *((_QWORD *)this + 272);
        *((_QWORD *)this + 272) = v32[2];
        v32[2] = v35;
        do
          v36 = __ldxr(v14);
        while (__stlxr(v36 - 1, v14));
        v37 = *((_QWORD *)this + 264);
        if (v37 + 1 == 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 267) - *((_QWORD *)this + 266)) >> 3))
          v38 = 0;
        else
          v38 = v37 + 1;
        *((_QWORD *)this + 264) = v38;
        if (*((_BYTE *)this + 2368))
          goto LABEL_15;
LABEL_29:
        if (*((_BYTE *)this + 2369))
        {
          v39 = *((_DWORD *)this + 590);
          v40 = *((_DWORD *)this + 589);
          if (v40 >= v39)
            v40 = *((_DWORD *)this + 590);
          *((_DWORD *)this + 589) = v40;
          if (*((_DWORD *)this + 588) > v39)
            v39 = *((_DWORD *)this + 588);
          *((_DWORD *)this + 588) = v39;
        }
        *((_DWORD *)this + 590) = 1;
        *((_BYTE *)this + 2368) = 1;
        if (webrtc::MultiChannelContentDetector::UpdateDetection((uint64_t)this + 1928, (uint64_t)this + 2160))goto LABEL_16;
      }
    }
    goto LABEL_46;
  }
LABEL_37:
  v41 = (unint64_t *)((char *)this + 2032);
  v42 = (unint64_t *)((char *)this + 1992);
  v43 = (char *)this + 2232;
  v44 = (_QWORD **)*((_QWORD *)this + 256);
  if (*((_QWORD ***)this + 257) == v44 || (v45 = *v44, *(_QWORD **)(*((_QWORD *)this + 256) + 8) == v45))
  {
LABEL_46:
    __break(1u);
    return;
  }
  if (v45[1] - *v45 == 256)
  {
    v46 = *((unsigned __int8 *)this + 1961);
    v47 = *((unsigned __int8 *)this + 2184);
    v48 = (unint64_t *)*((_QWORD *)this + 248);
    v49 = *((_QWORD *)this + 269);
    v50 = *((_QWORD *)this + 278);
    v51 = v47 != 0;
    webrtc::FrameBlocker::ExtractBlock(v41, (uint64_t)v43);
    v52 = v46 ? 1 : v54;
    (*(void (**)(uint64_t, uint64_t, _BOOL8, uint64_t, char *))(*(_QWORD *)v49 + 32))(v49, v52, v51, v50, v43);
    webrtc::BlockFramer::InsertBlock(v42, (uint64_t)v43);
    if (v48)
      webrtc::BlockFramer::InsertBlock(v48, v50);
  }
}

void webrtc::`anonymous namespace'::ProcessCaptureFrameContent(uint64_t a1, uint64_t a2, int a3, unsigned int a4, uint64_t a5, uint64_t a6, unint64_t *a7, unint64_t *a8, unint64_t *a9, uint64_t a10, uint64_t a11, uint64_t *a12, uint64_t a13, uint64_t *a14)
{
  char *v18;
  char *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  _QWORD *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  _QWORD *v37;
  unint64_t *v38;
  uint64_t v39;
  uint64_t *v40;

  v18 = (char *)*a14;
  v19 = (char *)a14[1];
  if (v19 != (char *)*a14)
  {
    v20 = 0;
    do
    {
      v21 = v19 - v18;
      if (v19 == v18)
        goto LABEL_28;
      if (*((_QWORD *)v18 + 1) != *(_QWORD *)v18)
      {
        v22 = 0;
        v23 = 0;
        do
        {
          v24 = *(_QWORD *)(a2 + 88);
          if (!v24)
            v24 = *(_QWORD *)(a2 + 80);
          if (0xAAAAAAAAAAAAAAABLL * (v21 >> 3) <= v20)
            goto LABEL_28;
          v26 = &v18[24 * v20];
          v25 = *(_QWORD *)v26;
          if (v23 >= (uint64_t)(*((_QWORD *)v26 + 1) - *(_QWORD *)v26) >> 4)
            goto LABEL_28;
          v27 = (_QWORD *)(v25 + v22);
          *v27 = *(_QWORD *)(*(_QWORD *)(v24 + 16) + 8 * *(_QWORD *)(v24 + 56) * v23 + 8 * v20) + 320 * a6;
          v27[1] = 80;
          v18 = (char *)*a14;
          v19 = (char *)a14[1];
          v21 = (uint64_t)&v19[-*a14];
          if (v19 == (char *)*a14)
            goto LABEL_28;
          ++v23;
          v22 += 16;
        }
        while (v23 < (uint64_t)(*((_QWORD *)v18 + 1) - *(_QWORD *)v18) >> 4);
      }
    }
    while (++v20 < 0xAAAAAAAAAAAAAAABLL * (v21 >> 3));
  }
  if (!a1)
  {
    webrtc::FrameBlocker::InsertSubFrameAndExtractBlock(a7, a14, a13);
    (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a10 + 32))(a10, a3 | a4, a5, a11, a13);
    v38 = a9;
    v39 = a13;
    v40 = a14;
    goto LABEL_31;
  }
  v28 = (char *)*a12;
  v29 = (char *)a12[1];
  if (v29 != (char *)*a12)
  {
    v30 = 0;
    while (1)
    {
      v31 = v29 - v28;
      if (v29 == v28)
        break;
      if (*((_QWORD *)v28 + 1) != *(_QWORD *)v28)
      {
        v32 = 0;
        v33 = 0;
        do
        {
          v34 = *(_QWORD *)(a1 + 88);
          if (!v34)
            v34 = *(_QWORD *)(a1 + 80);
          if (0xAAAAAAAAAAAAAAABLL * (v31 >> 3) <= v30)
            goto LABEL_28;
          v36 = &v28[24 * v30];
          v35 = *(_QWORD *)v36;
          if (v33 >= (uint64_t)(*((_QWORD *)v36 + 1) - *(_QWORD *)v36) >> 4)
            goto LABEL_28;
          v37 = (_QWORD *)(v35 + v32);
          *v37 = *(_QWORD *)(*(_QWORD *)(v34 + 16) + 8 * *(_QWORD *)(v34 + 56) * v33 + 8 * v30) + 320 * a6;
          v37[1] = 80;
          v28 = (char *)*a12;
          v29 = (char *)a12[1];
          v31 = (uint64_t)&v29[-*a12];
          if (v29 == (char *)*a12)
            goto LABEL_28;
          ++v33;
          v32 += 16;
        }
        while (v33 < (uint64_t)(*((_QWORD *)v28 + 1) - *(_QWORD *)v28) >> 4);
      }
      if (++v30 >= 0xAAAAAAAAAAAAAAABLL * (v31 >> 3))
        goto LABEL_29;
    }
LABEL_28:
    __break(1u);
  }
LABEL_29:
  webrtc::FrameBlocker::InsertSubFrameAndExtractBlock(a7, a14, a13);
  (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a10 + 32))(a10, a3 | a4, a5, a11, a13);
  webrtc::BlockFramer::InsertBlockAndExtractSubFrame(a9, a13, a14);
  v38 = a8;
  v39 = a11;
  v40 = a12;
LABEL_31:
  webrtc::BlockFramer::InsertBlockAndExtractSubFrame(v38, v39, v40);
}

uint64_t webrtc::EchoCanceller3::GetMetrics@<X0>(webrtc::EchoCanceller3 *this@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 269) + 16))(*((_QWORD *)this + 269), a2);
}

uint64_t webrtc::EchoCanceller3::SetAudioBufferDelay(webrtc::EchoCanceller3 *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 269) + 24))(*((_QWORD *)this + 269));
}

uint64_t webrtc::EchoCanceller3::SetCaptureOutputUsage(webrtc::EchoCanceller3 *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 269) + 56))(*((_QWORD *)this + 269));
}

uint64_t webrtc::EchoCanceller3::ActiveProcessing(webrtc::EchoCanceller3 *this)
{
  return 1;
}

unint64_t webrtc::`anonymous namespace'::BufferRenderFrameContent(unint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  _QWORD *v7;
  uint64_t v8;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t **v17;
  uint64_t *v18;
  uint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  float32x4_t *v37;
  unint64_t v38;
  float32x4_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  float32x4_t *v61;
  unint64_t v62;
  float32x4_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  _QWORD *v67;
  _QWORD *v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;

  v7 = *(_QWORD **)a2;
  v8 = *(_QWORD *)(a2 + 8);
  if (v8 != *(_QWORD *)a2 && a7[1] != *a7)
  {
    v11 = (v7[1] - *v7) / 24;
    if (v11 <= (uint64_t)(*(_QWORD *)(*a7 + 8) - *(_QWORD *)*a7) >> 4)
    {
      v41 = 0;
      v42 = 80 * a3;
      while (1)
      {
        result = 0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)v7) >> 3);
        if (result <= v41)
          break;
        v43 = &v7[3 * v41];
        v44 = *v43;
        if (v43[1] != *v43)
        {
          v45 = 0;
          v46 = 0;
          v47 = 0;
          do
          {
            v48 = *(_QWORD *)(v44 + v45);
            if (v42 >= (*(_QWORD *)(v44 + v45 + 8) - v48) >> 2)
              goto LABEL_76;
            result = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a7[1] - *a7) >> 3);
            if (result <= v41)
              goto LABEL_76;
            v50 = (uint64_t *)(*a7 + 24 * v41);
            v49 = *v50;
            result = v50[1] - *v50;
            if (v47 >= (uint64_t)result >> 4)
              goto LABEL_76;
            v51 = (_QWORD *)(v49 + v46);
            *v51 = v48 + 4 * v42;
            v51[1] = 80;
            v7 = *(_QWORD **)a2;
            v8 = *(_QWORD *)(a2 + 8);
            result = 0xAAAAAAAAAAAAAAABLL * ((v8 - *(_QWORD *)a2) >> 3);
            if (result <= v41)
              goto LABEL_76;
            ++v47;
            v44 = v7[3 * v41];
            v46 += 16;
            v45 += 24;
          }
          while (v47 < 0xAAAAAAAAAAAAAAABLL * ((v7[3 * v41 + 1] - v44) >> 3));
        }
        if (++v41 >= result)
        {
LABEL_75:
          webrtc::FrameBlocker::InsertSubFrameAndExtractBlock(a4, a7, a6);
          return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a5 + 40))(a5, a6);
        }
      }
    }
    else if ((result & 1) != 0)
    {
      v12 = (v8 - *(_QWORD *)a2) / 24;
      v13 = 80 * a3;
      v14 = 1.0 / (float)v11;
      v15 = -80 * a3;
      if (v12 <= 1)
        v12 = 1;
      if (v11 <= 1)
      {
        v52 = 0;
        v53 = 320 * a3;
        v54 = (320 * a3) | 0x10;
LABEL_53:
        result = v7[3 * v52];
        if (v7[3 * v52 + 1] != result)
        {
          v55 = *(_QWORD *)result;
          v56 = (uint64_t)(*(_QWORD *)(result + 8) - *(_QWORD *)result) >> 2;
          if (v56 <= v13)
            v56 = v13;
          result = v56 + v15;
          if (result >= 0x4F)
            v57 = 79;
          else
            v57 = result;
          if (v57 > 7)
          {
            v59 = v57 + 1;
            v60 = v59 & 7;
            if ((v59 & 7) == 0)
              v60 = 8;
            v58 = v59 - v60;
            v61 = (float32x4_t *)(v55 + v54);
            v62 = v58;
            do
            {
              v63 = vmulq_n_f32(*v61, v14);
              v61[-1] = vmulq_n_f32(v61[-1], v14);
              *v61 = v63;
              v61 += 2;
              v62 -= 8;
            }
            while (v62);
          }
          else
          {
            v58 = 0;
          }
          v64 = v55 + v53;
          while (result != v58)
          {
            *(float *)(v64 + 4 * v58) = v14 * *(float *)(v64 + 4 * v58);
            if (++v58 == 80)
            {
              if (++v52 != v12)
                goto LABEL_53;
              goto LABEL_69;
            }
          }
        }
      }
      else
      {
        v16 = 0;
        result = 79;
LABEL_9:
        v17 = (uint64_t **)&v7[3 * v16];
        v19 = *v17;
        v18 = v17[1];
        v20 = 0xAAAAAAAAAAAAAAABLL * (v18 - *v17);
        if (v20 <= 1)
          v21 = 1;
        else
          v21 = v20;
        v22 = 1;
LABEL_13:
        if (v22 != v21)
        {
          v23 = &v19[3 * v22];
          v24 = *v23;
          v25 = (v23[1] - *v23) >> 2;
          if (v25 <= v13)
            v26 = 80 * a3;
          else
            v26 = v25;
          v27 = 80 * a3;
          v28 = 320;
          while (v26 != v27)
          {
            v29 = *v19;
            v30 = (v19[1] - *v19) >> 2;
            if (v30 <= v27)
              break;
            *(float *)(v29 + 4 * v27) = *(float *)(v24 + 4 * v27) + *(float *)(v29 + 4 * v27);
            ++v27;
            v28 -= 4;
            if (!v28)
            {
              if (++v22 != v11)
                goto LABEL_13;
              if (v18 != v19)
              {
                if (v30 <= v13)
                  v31 = 80 * a3;
                else
                  v31 = v30;
                v32 = v31 - 80 * a3;
                if (v32 >= 0x4F)
                  v33 = 79;
                else
                  v33 = v32;
                if (v33 > 7)
                {
                  v35 = v33 + 1;
                  v36 = v35 & 7;
                  if ((v35 & 7) == 0)
                    v36 = 8;
                  v34 = v35 - v36;
                  v37 = (float32x4_t *)(v29 + ((320 * a3) | 0x10));
                  v38 = v34;
                  do
                  {
                    v39 = vmulq_n_f32(*v37, v14);
                    v37[-1] = vmulq_n_f32(v37[-1], v14);
                    *v37 = v39;
                    v37 += 2;
                    v38 -= 8;
                  }
                  while (v38);
                }
                else
                {
                  v34 = 0;
                }
                v40 = v29 + 320 * a3;
                while (v32 != v34)
                {
                  *(float *)(v40 + 4 * v34) = v14 * *(float *)(v40 + 4 * v34);
                  if (++v34 == 80)
                  {
                    if (++v16 != v12)
                      goto LABEL_9;
                    goto LABEL_69;
                  }
                }
              }
              break;
            }
          }
        }
      }
    }
    else
    {
      v13 = 80 * a3;
LABEL_69:
      v65 = 0;
      v66 = 0;
      while (1)
      {
        v68 = &v7[v65];
        v67 = (_QWORD *)v7[v65];
        if ((_QWORD *)v68[1] == v67)
          break;
        v70 = v67;
        v69 = *v67;
        if (v13 >= (v70[1] - v69) >> 2)
          break;
        v71 = *a7;
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a7[1] - *a7) >> 3) <= v66)
          break;
        v73 = v71 + v65 * 8;
        v72 = *(_QWORD **)(v71 + v65 * 8);
        if (*(_QWORD **)(v73 + 8) == v72)
          break;
        *v72 = v69 + 4 * v13;
        v72[1] = 80;
        ++v66;
        v7 = *(_QWORD **)a2;
        v65 += 3;
        if (v66 >= 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3))
          goto LABEL_75;
      }
    }
  }
LABEL_76:
  __break(1u);
  return result;
}

uint64_t webrtc::EchoCanceller3::AnalyzeRender(uint64_t this, webrtc::AudioBuffer *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  _QWORD *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *(_QWORD **)(this + 40);
  v3 = v2[1];
  if (v3 == *((_QWORD *)a2 + 8))
  {
    v4 = v2[2];
    if (v3)
      v5 = v4 == 0;
    else
      v5 = 1;
    if (!v5)
    {
      v7 = 0;
LABEL_7:
      v8 = 0;
      v9 = 0;
      while (1)
      {
        v10 = *((_QWORD *)a2 + 11);
        if (!v10)
          v10 = *((_QWORD *)a2 + 10);
        v11 = v2[4];
        if (0xAAAAAAAAAAAAAAABLL * ((v2[5] - v11) >> 3) <= v7)
          goto LABEL_26;
        v13 = (uint64_t *)(v11 + 24 * v7);
        v12 = *v13;
        if (0xAAAAAAAAAAAAAAABLL * ((v13[1] - *v13) >> 3) <= v9)
          goto LABEL_26;
        this = (uint64_t)memmove(*(void **)(v12 + v8), *(const void **)(*(_QWORD *)(v10 + 16) + 8 * *(_QWORD *)(v10 + 56) * v9++ + 8 * v7), 0x280uLL);
        v8 += 24;
        if (v4 == v9)
        {
          if (++v7 != v3)
            goto LABEL_7;
          break;
        }
      }
    }
    this = v2[3];
    if (this)
    {
      v14 = (uint64_t *)v2[4];
      if ((uint64_t *)v2[5] == v14)
        goto LABEL_26;
      this = webrtc::HighPassFilter::Process(this, v14);
    }
    v15 = (_QWORD *)v2[7];
    v16 = v15 + 5;
    v17 = atomic_load(v15 + 5);
    v18 = v15[6];
    v19 = 0xAAAAAAAAAAAAAAABLL * ((v15[7] - v18) >> 3);
    if (v17 == v19)
      return this;
    v20 = v15[3];
    if (v19 > v20)
    {
      v21 = (_QWORD *)(v18 + 24 * v20);
      v22 = v2[4];
      v2[4] = *v21;
      *v21 = v22;
      v23 = v2[5];
      v2[5] = v21[1];
      v21[1] = v23;
      v24 = v2[6];
      v2[6] = v21[2];
      v21[2] = v24;
      do
        v25 = __ldxr(v16);
      while (__stlxr(v25 + 1, v16));
      v26 = v15[3];
      if (v26 + 1 == 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15[7] - v15[6]) >> 3))
        v27 = 0;
      else
        v27 = v26 + 1;
      v15[3] = v27;
      return this;
    }
LABEL_26:
    __break(1u);
  }
  return this;
}

uint64_t webrtc::EchoCanceller3::AnalyzeCapture(uint64_t this, webrtc::AudioBuffer *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  float *v6;
  unint64_t v8;
  float *v9;
  float v10;

  v2 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 8);
  *(_BYTE *)(this + 2184) = 0;
  v3 = *((_QWORD *)a2 + 7);
  if (v3)
  {
    v4 = *((_QWORD *)a2 + 3);
    if (v4)
    {
      v5 = 0;
      while (1)
      {
        v6 = *(float **)(v2 + 8 * v5);
        if (*v6 >= 32700.0 || *v6 <= -32700.0)
          break;
        v8 = 0;
        v9 = v6 + 1;
        while (v4 - 1 != v8)
        {
          v10 = v9[v8++];
          if (v10 >= 32700.0 || v10 <= -32700.0)
          {
            if (v8 < v4)
              goto LABEL_17;
            break;
          }
        }
        if (++v5 == v3)
          return this;
      }
LABEL_17:
      *(_BYTE *)(this + 2184) = 1;
    }
  }
  return this;
}

double webrtc::EchoCanceller3Config::EchoCanceller3Config(webrtc::EchoCanceller3Config *this)
{
  double result;

  *(_OWORD *)this = xmmword_208F09520;
  *((_OWORD *)this + 1) = xmmword_208F09530;
  *((_OWORD *)this + 2) = xmmword_208F09540;
  *((_OWORD *)this + 3) = xmmword_208F08A40;
  *((int32x2_t *)this + 8) = vdup_n_s32(0x3F333333u);
  *((_DWORD *)this + 18) = 1045220557;
  *(_QWORD *)((char *)this + 76) = 0x1400000005;
  *((_WORD *)this + 42) = 0;
  *((_WORD *)this + 44) = 256;
  *((_DWORD *)this + 23) = 1176256512;
  *((_BYTE *)this + 96) = 1;
  *((_WORD *)this + 50) = 256;
  *((_DWORD *)this + 26) = 1176256512;
  *((_BYTE *)this + 108) = 0;
  *((_BYTE *)this + 112) = 1;
  *((_QWORD *)this + 15) = 13;
  *((_OWORD *)this + 8) = xmmword_208F09550;
  *((_DWORD *)this + 36) = 1268328872;
  *((_QWORD *)this + 19) = 13;
  *((_QWORD *)this + 20) = 0x4B9929A83F333333;
  *((_QWORD *)this + 21) = 12;
  *((_OWORD *)this + 11) = xmmword_208F09560;
  *((_DWORD *)this + 48) = 1268328872;
  *((_QWORD *)this + 25) = 12;
  *((_QWORD *)this + 26) = 0x4B9929A83F666666;
  *((_QWORD *)this + 27) = 250;
  *((_QWORD *)this + 28) = 0x1940200000;
  *((_DWORD *)this + 58) = 65792;
  *((_BYTE *)this + 236) = 0;
  *((_QWORD *)this + 30) = 0x408000003F800000;
  *((_DWORD *)this + 62) = 1069547520;
  *((_BYTE *)this + 252) = 1;
  *((_QWORD *)this + 32) = 1;
  *((_WORD *)this + 132) = 257;
  *((_QWORD *)this + 34) = 0x3F547AE13F800000;
  *((_DWORD *)this + 70) = 1062501089;
  *((_DWORD *)this + 71) = 16777217;
  *((_OWORD *)this + 18) = xmmword_208F09570;
  __asm { FMOV            V0.2S, #10.0 }
  *((_QWORD *)this + 38) = _D0;
  *((_WORD *)this + 156) = 0;
  *(_OWORD *)((char *)this + 316) = xmmword_208F09580;
  *((_WORD *)this + 166) = 0;
  *((_QWORD *)this + 42) = 50;
  *(_OWORD *)((char *)this + 344) = xmmword_208F09590;
  *((_QWORD *)this + 45) = 1;
  *((_QWORD *)this + 46) = 1;
  *((_BYTE *)this + 376) = 1;
  *((_DWORD *)this + 96) = -1027600016;
  *((_QWORD *)this + 49) = 4;
  *((_OWORD *)this + 25) = xmmword_208F095A0;
  *((_OWORD *)this + 26) = xmmword_208F095B0;
  *((_OWORD *)this + 27) = xmmword_208F095C0;
  *((_OWORD *)this + 28) = xmmword_208F095D0;
  *((_BYTE *)this + 464) = 1;
  *(_OWORD *)((char *)this + 468) = xmmword_208F095E0;
  *((_DWORD *)this + 121) = 1048576000;
  *((_QWORD *)this + 61) = 0x41F0000041200000;
  *((_QWORD *)this + 62) = 0xC00000032;
  *((_WORD *)this + 252) = 257;
  _Q0 = vdupq_n_s64(1uLL);
  *((int64x2_t *)this + 32) = _Q0;
  *((int64x2_t *)this + 33) = _Q0;
  *((_QWORD *)this + 68) = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)this + 69) = _Q0.i64[0];
  *((_BYTE *)this + 560) = 0;
  result = 0.00781250185;
  *(_OWORD *)((char *)this + 564) = xmmword_208F095F0;
  *((_DWORD *)this + 145) = 925353388;
  *((_BYTE *)this + 584) = 0;
  *((_BYTE *)this + 592) = 1;
  *(_QWORD *)((char *)this + 596) = 0x12C00000000;
  *((_DWORD *)this + 151) = 0x40000000;
  return result;
}

webrtc *WebRtcAecm_Create()
{
  webrtc *v0;
  _QWORD *Core;
  void *v2;
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  void **v7;

  v0 = (webrtc *)malloc_type_calloc(1uLL, 0x188uLL, 0x1020040E14E9EFFuLL);
  Core = webrtc::WebRtcAecm_CreateCore(v0);
  *((_QWORD *)v0 + 48) = Core;
  if (Core)
  {
    v3 = malloc_type_malloc(0x30uLL, 0x1010040521CD160uLL);
    if (v3)
    {
      v4 = v3;
      v5 = malloc_type_malloc(0x1F40uLL, 0x6B6E1D91uLL);
      v4[5] = v5;
      if (v5)
      {
        *((_OWORD *)v4 + 1) = xmmword_208F09640;
        *((_DWORD *)v4 + 8) = 0;
        *v4 = 0;
        v4[1] = 0;
        bzero(v5, 0x1F40uLL);
        *((_QWORD *)v0 + 47) = v4;
        return v0;
      }
      free(v4);
    }
    *((_QWORD *)v0 + 47) = 0;
    Core = (_QWORD *)*((_QWORD *)v0 + 48);
  }
  webrtc::WebRtcAecm_FreeCore((uint64_t)Core, v2);
  v7 = (void **)*((_QWORD *)v0 + 47);
  if (v7)
  {
    free(v7[5]);
    free(v7);
  }
  free(v0);
  return 0;
}

uint64_t WebRtcAecm_Init(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (a2 != 16000 && a2 != 8000)
    return 12004;
  *(_DWORD *)a1 = a2;
  if (webrtc::WebRtcAecm_InitCore(*(_QWORD *)(a1 + 384), a2) == -1)
    return 12000;
  v3 = *(_QWORD *)(a1 + 376);
  *(_DWORD *)(v3 + 32) = 0;
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  bzero(*(void **)(v3 + 40), *(_QWORD *)(v3 + 24) * *(_QWORD *)(v3 + 16));
  result = 0;
  *(_OWORD *)(a1 + 12) = 0u;
  v5 = a1 + 12;
  *(_QWORD *)(v5 + 324) = 42;
  *(_WORD *)(v5 - 4) = 0;
  *(_WORD *)(v5 + 332) = 0;
  *(_WORD *)(v5 + 336) = 0;
  *(_OWORD *)(v5 + 340) = xmmword_208F09650;
  *(_WORD *)(v5 + 356) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 176) = 0u;
  *(_OWORD *)(v5 + 192) = 0u;
  *(_OWORD *)(v5 + 208) = 0u;
  *(_OWORD *)(v5 + 224) = 0u;
  *(_OWORD *)(v5 + 240) = 0u;
  *(_OWORD *)(v5 + 256) = 0u;
  *(_OWORD *)(v5 + 272) = 0u;
  *(_OWORD *)(v5 + 288) = 0u;
  *(_OWORD *)(v5 + 304) = 0u;
  *(_DWORD *)(v5 + 320) = 0;
  *(_WORD *)(v5 + 358) = 3;
  v6 = *(_QWORD *)(v5 + 372) + 17230;
  *(_WORD *)v6 = 1;
  *(_QWORD *)(v6 + 36) = 0x1000C0001000100;
  *(_DWORD *)(v6 + 44) = 83887616;
  return result;
}

uint64_t WebRtcAecm_Process(uint64_t a1, char *a2, char *__src, char *__dst, uint64_t a5, int a6)
{
  char *v6;
  uint64_t v7;
  int v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t i;
  uint64_t v20;
  uint64_t v21;
  _OWORD *v22;
  _OWORD *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int16 v36;
  uint64_t *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  BOOL v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  __int16 v53;
  int v54;
  int v55;
  int v56;
  BOOL v57;
  int v58;
  char *v59;
  __int16 v61;
  __int16 v62;
  unint64_t v63;
  __int16 v64;
  __int16 v65;
  int v66;
  int v67;
  __int16 v68;
  int v69;
  int v70;
  signed int v71;
  uint64_t v72;
  uint64_t v73;
  void *__srca;
  _OWORD __dsta[10];
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 0xFFFFFFFFLL;
  v6 = a2;
  v7 = 12003;
  if (a2 && __dst)
  {
    if (*(_WORD *)(a1 + 336) != 42)
      return 12002;
    if (a5 != 160 && a5 != 80)
      return 12004;
    if (a6 >= 500)
      v11 = 500;
    else
      v11 = a6;
    v12 = v11 & ~(v11 >> 31);
    if (a6 <= 0x1F4)
      v7 = 0;
    else
      v7 = 12100;
    *(_WORD *)(a1 + 346) = v12 + 10;
    v13 = a5 / 0x50u;
    if (*(_DWORD *)(a1 + 356))
    {
      v14 = *(__int16 *)(*(_QWORD *)(a1 + 384) + 568);
      if (__src)
      {
        v6 = __src;
        if (__dst == __src)
          goto LABEL_17;
      }
      else if (__dst == a2)
      {
LABEL_17:
        v15 = *(uint64_t **)(a1 + 376);
        if (v15)
        {
          v16 = *v15;
          if (*((_DWORD *)v15 + 8))
          {
            v17 = v15[2] - v16 + v15[1];
            if (!*(_DWORD *)(a1 + 360))
              goto LABEL_88;
LABEL_85:
            v61 = *(_WORD *)(a1 + 344) + 1;
            *(_WORD *)(a1 + 344) = v61;
            v62 = *(_WORD *)(a1 + 338);
            v63 = v13 / v14;
            if (v62)
            {
              v64 = *(_WORD *)(a1 + 342);
              v65 = *(_WORD *)(a1 + 346);
            }
            else
            {
              v65 = *(_WORD *)(a1 + 346);
              *(_WORD *)(a1 + 342) = v65;
              *(_WORD *)(a1 + 340) = 0;
              v64 = v65;
            }
            v67 = v64 - v65;
            if (v67 < 0)
              v67 = -v67;
            if (fmax((double)v65 * 0.2, 8.0) <= (double)v67)
            {
              *(_WORD *)(a1 + 338) = 0;
            }
            else
            {
              *(_WORD *)(a1 + 340) += v65;
              v68 = v62 + 1;
              *(_WORD *)(a1 + 338) = v68;
              if ((unint64_t)((int)v63 * (uint64_t)v68) >= 6)
              {
                v69 = *(__int16 *)(*(_QWORD *)(a1 + 384) + 568);
                v66 = 3 * *(__int16 *)(a1 + 340) * v69 / (40 * v68);
                if (v66 >= 50)
                  LOWORD(v66) = 50;
                *(_WORD *)(a1 + 8) = v66;
                *(_DWORD *)(a1 + 360) = 0;
                if ((unint64_t)((int)v63 * (uint64_t)v61) <= 0x32)
                  goto LABEL_104;
                goto LABEL_100;
              }
            }
            if ((unint64_t)((int)v63 * (uint64_t)v61) < 0x33)
              return v7;
            v69 = *(__int16 *)(*(_QWORD *)(a1 + 384) + 568);
LABEL_100:
            v70 = 3 * v65 * v69;
            if (v70 >= 2000)
              LOWORD(v66) = 50;
            else
              LOWORD(v66) = v70 / 40;
            *(_WORD *)(a1 + 8) = v66;
            *(_DWORD *)(a1 + 360) = 0;
            goto LABEL_104;
          }
          v17 = v15[1] - v16;
          if (*(_DWORD *)(a1 + 360))
            goto LABEL_85;
        }
        else
        {
          LOWORD(v17) = 0;
          if (*(_DWORD *)(a1 + 360))
            goto LABEL_85;
        }
LABEL_88:
        LOWORD(v66) = *(_WORD *)(a1 + 8);
LABEL_104:
        v71 = ((26215 * (__int16)v17) >> 21) + ((26215 * (__int16)v17) >> 31);
        if ((unsigned __int16)v71 == (unsigned __int16)v66)
        {
LABEL_112:
          *(_DWORD *)(a1 + 356) = 0;
          return v7;
        }
        if (v71 > (__int16)v66)
        {
          if (v15)
          {
            v72 = *v15;
            if (*((_DWORD *)v15 + 8))
              v73 = v15[2] - v72 + v15[1];
            else
              v73 = v15[1] - v72;
          }
          else
          {
            LODWORD(v73) = 0;
          }
          WebRtc_MoveReadPtr((int *)v15, v73 - 80 * (__int16)v66);
          goto LABEL_112;
        }
        return v7;
      }
      memcpy(__dst, v6, 2 * a5);
      goto LABEL_17;
    }
    v18 = 0;
    for (i = 0; v13 != i; ++i)
    {
      __srca = 0;
      v20 = *(_QWORD *)(a1 + 376);
      if (v20)
      {
        v21 = *(_QWORD *)v20;
        if (*(_DWORD *)(v20 + 32))
        {
          if ((int)((*(_QWORD *)(v20 + 16) - (_DWORD)v21 + *(_QWORD *)(v20 + 8)) << 16) > 5177344)
            goto LABEL_27;
        }
        else if ((int)((*(_QWORD *)(v20 + 8) - (_DWORD)v21) << 16) > 5177344)
        {
LABEL_27:
          WebRtc_ReadBuffer((uint64_t *)v20, &__srca, (char *)__dsta, 0x50uLL);
          v22 = (_OWORD *)(a1 + v18);
          v23 = __srca;
          v24 = *((_OWORD *)__srca + 1);
          v22[1] = *(_OWORD *)__srca;
          v22[2] = v24;
          v25 = v23[5];
          v27 = v23[2];
          v26 = v23[3];
          v22[5] = v23[4];
          v22[6] = v25;
          v22[3] = v27;
          v22[4] = v26;
          v28 = v23[9];
          v30 = v23[6];
          v29 = v23[7];
          v22[9] = v23[8];
          v22[10] = v28;
          v22[7] = v30;
          v22[8] = v29;
          if (i != 1)
            goto LABEL_32;
          goto LABEL_28;
        }
      }
      v31 = *(_OWORD *)(a1 + v18 + 128);
      __dsta[6] = *(_OWORD *)(a1 + v18 + 112);
      __dsta[7] = v31;
      v32 = *(_OWORD *)(a1 + v18 + 160);
      __dsta[8] = *(_OWORD *)(a1 + v18 + 144);
      __dsta[9] = v32;
      v33 = *(_OWORD *)(a1 + v18 + 64);
      __dsta[2] = *(_OWORD *)(a1 + v18 + 48);
      __dsta[3] = v33;
      v34 = *(_OWORD *)(a1 + v18 + 96);
      __dsta[4] = *(_OWORD *)(a1 + v18 + 80);
      __dsta[5] = v34;
      v35 = *(_OWORD *)(a1 + v18 + 32);
      __dsta[0] = *(_OWORD *)(a1 + v18 + 16);
      __dsta[1] = v35;
      __srca = __dsta;
      if (i != 1)
      {
LABEL_32:
        if (i || *(_DWORD *)a1 != 8000)
          goto LABEL_74;
        goto LABEL_34;
      }
LABEL_28:
      if (*(_DWORD *)a1 != 16000)
        goto LABEL_74;
LABEL_34:
      v36 = *(_WORD *)(a1 + 346);
      v37 = *(uint64_t **)(a1 + 376);
      if (v37)
      {
        v38 = *((_DWORD *)v37 + 8);
        v39 = *v37;
        v40 = v37[1];
        if (v38)
          v41 = v37[2] - v39 + v40;
        else
          LOWORD(v41) = v40 - v39;
        v42 = (__int16)(8 * v36 * *(_WORD *)(*(_QWORD *)(a1 + 384) + 568) - v41);
        if (v42 >= 80)
          goto LABEL_59;
        v43 = *((_DWORD *)v37 + 4);
        v44 = v38 == 0;
        if (v38)
          v45 = *((_DWORD *)v37 + 4);
        else
          v45 = 0;
        if (v44)
          v46 = *((_DWORD *)v37 + 4);
        else
          v46 = 0;
        v47 = v45 - v39 + v40;
        v48 = v40 - v39 - v46;
        if (v47 >= 80)
          v47 = 80;
        if (v47 <= v48)
          v47 = v48;
        v49 = v47 + v39;
        if (v49 <= v43)
          v50 = 0;
        else
          v50 = *((_DWORD *)v37 + 4);
        v51 = v49 - v50;
        if (v49 > v43 || v51 < 0)
          *((_DWORD *)v37 + 8) = v51 >> 31;
        *v37 = (v43 & (v51 >> 31)) + v51;
      }
      else
      {
        v42 = (__int16)(8 * v36 * *(_WORD *)(*(_QWORD *)(a1 + 384) + 568));
        if (v42 >= 80)
          goto LABEL_59;
      }
      LOWORD(v42) = v42 + 80;
LABEL_59:
      v52 = 8 * *(__int16 *)(a1 + 348) + 2 * (__int16)v42;
      if (v52 >= -9)
        v53 = v52 / 10;
      else
        v53 = 0;
      *(_WORD *)(a1 + 348) = v53;
      v54 = *(_DWORD *)(a1 + 12);
      v55 = (__int16)(v53 - v54);
      if (v55 < 225)
      {
        if (v54 < 1 || v55 > 95 || *(__int16 *)(a1 + 368) >= 225)
        {
LABEL_68:
          *(_DWORD *)(a1 + 352) = 0;
          *(_WORD *)(a1 + 368) = v55;
          goto LABEL_74;
        }
      }
      else if (*(__int16 *)(a1 + 368) < 96)
      {
        goto LABEL_68;
      }
      v56 = *(_DWORD *)(a1 + 352);
      *(_DWORD *)(a1 + 352) = v56 + 1;
      *(_WORD *)(a1 + 368) = v55;
      if (v56 >= 25)
      {
        v57 = __OFSUB__(v53, 160);
        v58 = v53 - 160;
        if ((v58 < 0) ^ v57 | (v58 == 0))
          v58 = 0;
        *(_DWORD *)(a1 + 12) = v58;
      }
LABEL_74:
      if (__src)
        v59 = &__src[v18];
      else
        v59 = 0;
      if (webrtc::WebRtcAecm_ProcessFrame(*(unsigned int **)(a1 + 384), (char *)__srca, &v6[v18], v59, (uint64_t)&__dst[v18]) == -1)return 0xFFFFFFFFLL;
      v18 += 160;
    }
  }
  return v7;
}

void webrtc::EchoControlMobileImpl::~EchoControlMobileImpl(webrtc::EchoControlMobileImpl *this, void *a2)
{
  void *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD **v8;
  _QWORD **v9;
  _QWORD *v10;
  void **v11;

  v3 = (void *)*((_QWORD *)this + 5);
  if (v3)
  {
    *((_QWORD *)this + 6) = v3;
    operator delete(v3);
  }
  v4 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v4)
    MEMORY[0x20BD0ADEC](v4, 0x1000C40D315E998);
  v5 = (_QWORD *)*((_QWORD *)this + 1);
  if (v5)
  {
    v6 = (_QWORD *)*((_QWORD *)this + 2);
    v7 = (void *)*((_QWORD *)this + 1);
    if (v6 != v5)
    {
      do
      {
        v9 = (_QWORD **)*--v6;
        v8 = v9;
        *v6 = 0;
        if (v9)
        {
          v10 = *v8;
          if (*v8)
          {
            webrtc::WebRtcAecm_FreeCore(v10[48], a2);
            v11 = (void **)v10[47];
            if (v11)
            {
              free(v11[5]);
              free(v11);
            }
            free(v10);
          }
          MEMORY[0x20BD0ADEC](v8, 0x80C40B8603338);
        }
      }
      while (v6 != v5);
      v7 = (void *)*((_QWORD *)this + 1);
    }
    *((_QWORD *)this + 2) = v5;
    operator delete(v7);
  }
}

void webrtc::EchoControlMobileImpl::PackRenderAudioBuffer(_QWORD *a1, uint64_t a2, int8x16_t a3, double a4, double a5, double a6, int8x16_t a7, uint64_t a8, _QWORD *a9)
{
  _QWORD *v9;
  _QWORD *v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int8x16_t *v22;
  unint64_t v23;
  __n128 *v24;
  unint64_t v25;
  int8x16_t *v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  unint64_t v33;
  _WORD *v34;
  float *v35;
  float v36;
  char *v37;
  char *v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  unint64_t v45;
  uint64_t v46;
  char *v47;
  _BYTE *v48;
  char *v49;
  uint64_t v50;
  char *v51;
  int64_t v52;
  size_t v53;
  char *v54;
  char *v55;
  BOOL v56;
  uint64_t v57;
  char *v58;
  char *v59;
  __int16 v60;
  char *v61;
  char *v62;
  _WORD *v63;
  char *v64;
  uint64_t v65;
  char *v66;
  __int16 *v67;
  _WORD *v68;
  __int16 v69;
  char *v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  __n128 *v74;
  int8x16_t *v75;
  unint64_t v76;
  __int16 v77;
  size_t v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  int8x16_t v83;
  int v84;
  _WORD __src[164];

  a9[1] = *a9;
  if (a2)
  {
    v9 = a1;
    if (a1[7])
    {
      v10 = a9;
      v11 = 0;
      v12 = 0;
      v13 = 1;
      a7.i32[0] = 0.5;
      v14.i64[0] = 0x8000000080000000;
      v14.i64[1] = 0x8000000080000000;
      v15 = (int8x16_t)vdupq_n_s32(0x46FFFE00u);
      v16.i64[0] = 0xC7000000C7000000;
      v16.i64[1] = 0xC7000000C7000000;
      v17.i64[0] = 0x3F0000003F000000;
      v17.i64[1] = 0x3F0000003F000000;
      v83 = v15;
      v80 = a2;
      while (!v13)
      {
LABEL_5:
        if (++v12 == a2)
          return;
      }
      v81 = v12;
      v18 = 0;
      while (1)
      {
        v19 = v9[11];
        if (v19)
        {
          v20 = v11;
          v21 = v9[9];
          if (!v21)
            goto LABEL_10;
        }
        else
        {
          v21 = v9[9];
          v19 = v9[10];
          v20 = v11;
          if (!v21)
            goto LABEL_10;
        }
        v22 = *(int8x16_t **)(*(_QWORD *)(v19 + 16) + 8 * *(_QWORD *)(v19 + 56) * v20);
        if ((unint64_t)v21 >= 8)
        {
          v23 = v21 & 0xFFFFFFFFFFFFFFF8;
          v24 = (__n128 *)__src;
          v25 = v21 & 0xFFFFFFFFFFFFFFF8;
          v26 = v22;
          do
          {
            v27 = *v26;
            v28 = v26[1];
            v26 += 2;
            v29 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v27, (float32x4_t)v15), v15, v27);
            v30 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v28, (float32x4_t)v15), v15, v28);
            v31 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v16, (float32x4_t)v29), v16, v29);
            v32 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v16, (float32x4_t)v30), v16, v30);
            a3 = (int8x16_t)vuzp1q_s16((int16x8_t)vcvtq_s32_f32(vaddq_f32((float32x4_t)v31, (float32x4_t)vbslq_s8(v14, v17, v31))), (int16x8_t)vcvtq_s32_f32(vaddq_f32((float32x4_t)v32, (float32x4_t)vbslq_s8(v14, v17, v32))));
            *v24++ = (__n128)a3;
            v25 -= 8;
          }
          while (v25);
          if (v21 == v23)
            goto LABEL_26;
        }
        else
        {
          v23 = 0;
        }
        v33 = v21 - v23;
        v34 = &__src[v23];
        v35 = (float *)&v22->i32[v23];
        do
        {
          v36 = *v35++;
          *(float *)a3.i32 = v36;
          if (v36 > 32767.0)
            *(float *)a3.i32 = 32767.0;
          if (*(float *)a3.i32 < -32768.0)
            *(float *)a3.i32 = -32768.0;
          *v34++ = (int)(float)(*(float *)a3.i32 + *(float *)vbslq_s8(v14, a7, a3).i32);
          --v33;
        }
        while (v33);
LABEL_26:
        if (v21 < 1)
          goto LABEL_10;
        v84 = v20;
        v38 = (char *)*v10;
        v37 = (char *)v10[1];
        v39 = (uint64_t)&v37[-*v10];
        v40 = (char *)(*v10 + (v39 & 0xFFFFFFFFFFFFFFFELL));
        v41 = v10[2];
        if (v21 <= (v41 - (uint64_t)v37) >> 1)
        {
          v49 = (char *)&__src[v21];
          v20 = v37 - v40;
          v50 = (v37 - v40) >> 1;
          if (v50 >= v21)
          {
            v55 = (char *)v10[1];
            v57 = 2 * v21;
            v58 = &v37[-2 * v21];
            v59 = v55;
            if (v58 < v37)
            {
LABEL_42:
              while (v59)
              {
                v60 = *(_WORD *)v58;
                v58 += 2;
                *(_WORD *)v59 = v60;
                v59 += 2;
                if (v58 >= v37)
                  goto LABEL_44;
              }
LABEL_66:
              __break(1u);
LABEL_67:
              abort();
            }
          }
          else
          {
            v51 = (char *)&__src[v50];
            v52 = v49 - v51;
            v53 = v49 - v51;
            v54 = v40;
            memmove((void *)v10[1], v51, v53);
            v55 = &v37[v52];
            v10[1] = &v37[v52];
            v56 = v20 < 1;
            a7.i32[0] = 0.5;
            v14.i64[0] = 0x8000000080000000;
            v14.i64[1] = 0x8000000080000000;
            v15 = v83;
            v16.i64[0] = 0xC7000000C7000000;
            v16.i64[1] = 0xC7000000C7000000;
            v17.i64[0] = 0x3F0000003F000000;
            v17.i64[1] = 0x3F0000003F000000;
            LODWORD(v20) = v84;
            if (v56)
              goto LABEL_10;
            v40 = v54;
            v49 = v51;
            v57 = 2 * v21;
            v58 = &v55[-2 * v21];
            v59 = &v37[v52];
            if (v58 < v37)
              goto LABEL_42;
          }
LABEL_44:
          v61 = &v40[v57];
          v10[1] = v59;
          LODWORD(v20) = v84;
          if (v55 != v61)
          {
            v62 = v40;
            memmove(&v55[-2 * ((v55 - v61) >> 1)], v40, v55 - v61);
            v40 = v62;
          }
          a7.i32[0] = 0.5;
          v14.i64[0] = 0x8000000080000000;
          v14.i64[1] = 0x8000000080000000;
          v15 = v83;
          v16.i64[0] = 0xC7000000C7000000;
          v16.i64[1] = 0xC7000000C7000000;
          v17.i64[0] = 0x3F0000003F000000;
          v17.i64[1] = 0x3F0000003F000000;
          if (v49 == (char *)__src)
            goto LABEL_10;
          memmove(v40, __src, v49 - (char *)__src);
          goto LABEL_9;
        }
        v42 = v39 >> 1;
        v43 = (v39 >> 1) + v21;
        if (v43 < 0)
          goto LABEL_67;
        v44 = v10;
        v45 = v41 - (_QWORD)v38;
        if (v45 > v43)
          v43 = v45;
        if (v45 >= 0x7FFFFFFFFFFFFFFELL)
          v46 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v46 = v43;
        if (v46)
        {
          if (v46 < 0)
            std::__throw_bad_array_new_length[abi:sn180100]();
          v47 = v40;
          v48 = operator new(2 * v46);
          v15 = v83;
          v16.i64[0] = 0xC7000000C7000000;
          v16.i64[1] = 0xC7000000C7000000;
          v17.i64[0] = 0x3F0000003F000000;
          v17.i64[1] = 0x3F0000003F000000;
          v40 = v47;
          v42 = v39 >> 1;
        }
        else
        {
          v48 = 0;
        }
        v63 = &v48[2 * v42];
        v64 = &v48[2 * v46];
        v65 = 2 * v21;
        v66 = (char *)&v63[v21];
        v67 = __src;
        v68 = v63;
        v10 = v44;
        v9 = a1;
        do
        {
          if (!v68)
            goto LABEL_66;
          v69 = *v67++;
          *v68++ = v69;
          v65 -= 2;
        }
        while (v65);
        if (v38 != v37)
        {
          if ((unint64_t)(v39 - 2) < 0x1E)
          {
            v70 = v40;
            do
            {
LABEL_60:
              v77 = *((_WORD *)v70 - 1);
              v70 -= 2;
              *--v63 = v77;
            }
            while (v70 != v38);
            goto LABEL_61;
          }
          v70 = v40;
          if ((unint64_t)(&v38[v39 & 0xFFFFFFFFFFFFFFFELL] - &v48[v39 & 0xFFFFFFFFFFFFFFFELL]) < 0x20)
            goto LABEL_60;
          v71 = ((unint64_t)(v39 - 2) >> 1) + 1;
          v72 = 2 * (v71 & 0xFFFFFFFFFFFFFFF0);
          v70 = &v40[-v72];
          v63 = (_WORD *)((char *)v63 - v72);
          v73 = 2 * v42;
          v74 = (__n128 *)&v48[v73 - 16];
          v75 = (int8x16_t *)&v38[v73 - 16];
          v76 = v71 & 0xFFFFFFFFFFFFFFF0;
          do
          {
            a3 = *v75;
            v74[-1] = (__n128)v75[-1];
            *v74 = (__n128)a3;
            v74 -= 2;
            v75 -= 2;
            v76 -= 16;
          }
          while (v76);
          if (v71 != (v71 & 0xFFFFFFFFFFFFFFF0))
            goto LABEL_60;
        }
LABEL_61:
        v78 = v37 - v40;
        if (v78)
        {
          v79 = v64;
          memmove(v66, v40, v78);
          v64 = v79;
          v17.i64[0] = 0x3F0000003F000000;
          v17.i64[1] = 0x3F0000003F000000;
          v16.i64[0] = 0xC7000000C7000000;
          v16.i64[1] = 0xC7000000C7000000;
          v15 = v83;
        }
        *v10 = v63;
        v10[1] = &v66[v78];
        v10[2] = v64;
        a7.i32[0] = 0.5;
        v14.i64[0] = 0x8000000080000000;
        v14.i64[1] = 0x8000000080000000;
        if (!v38)
          goto LABEL_10;
        operator delete(v38);
LABEL_9:
        v17.i64[0] = 0x3F0000003F000000;
        v17.i64[1] = 0x3F0000003F000000;
        v16.i64[0] = 0xC7000000C7000000;
        v16.i64[1] = 0xC7000000C7000000;
        v15 = v83;
        v14.i64[0] = 0x8000000080000000;
        v14.i64[1] = 0x8000000080000000;
        a7.i32[0] = 0.5;
LABEL_10:
        v13 = v9[7];
        v11 = ((int)v20 + 1) % v13;
        if (++v18 >= v13)
        {
          a2 = v80;
          v12 = v81;
          goto LABEL_5;
        }
      }
    }
  }
}

void webrtc::EchoControlMobileImpl::ProcessCaptureAudio(webrtc::EchoControlMobileImpl *this, webrtc::AudioBuffer *a2, __int16 a3, int8x16_t a4, double a5, double a6, double a7, int8x16_t a8)
{
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  int8x16_t *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  __n128 *v26;
  unint64_t v27;
  int8x16_t *v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  int v35;
  unint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  int16x4_t *v45;
  int16x8_t v46;
  float32x4_t v47;
  int32x4_t v48;
  unint64_t v49;
  float *v50;
  char *v51;
  int v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int8x16_t v57;
  __int16 v58;
  _WORD v59[164];

  if (*((_QWORD *)a2 + 7))
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    a8.i32[0] = 0.5;
    v13.i64[0] = 0x8000000080000000;
    v13.i64[1] = 0x8000000080000000;
    v14 = (int8x16_t)vdupq_n_s32(0x46FFFE00u);
    v15.i64[0] = 0xC7000000C7000000;
    v15.i64[1] = 0xC7000000C7000000;
    v16.i64[0] = 0x3F0000003F000000;
    v16.i64[1] = 0x3F0000003F000000;
    v57 = v14;
    v58 = a3;
    do
    {
      if (*((_BYTE *)this + 64))
      {
        v17 = *((_QWORD *)this + 5);
        if (0xCCCCCCCCCCCCCCCDLL * ((*((_QWORD *)this + 6) - v17) >> 6) <= v11)
        {
LABEL_67:
          __break(1u);
          return;
        }
        v18 = (char *)(v17 + 320 * v11);
        v19 = *((_QWORD *)a2 + 11);
        if (v19)
        {
LABEL_6:
          v20 = *(int8x16_t **)(*(_QWORD *)(v19 + 16) + 8 * *(_QWORD *)(v19 + 56) * v11);
          if (!v20)
            goto LABEL_12;
          goto LABEL_7;
        }
      }
      else
      {
        v18 = 0;
        v19 = *((_QWORD *)a2 + 11);
        if (v19)
          goto LABEL_6;
      }
      v20 = *(int8x16_t **)(*(_QWORD *)(*((_QWORD *)a2 + 10) + 16) + 8
                                                                     * *(_QWORD *)(*((_QWORD *)a2 + 10) + 56)
                                                                     * v11);
      if (!v20)
      {
LABEL_12:
        v23 = 0;
        if (v18)
          v24 = v18;
        else
          v24 = 0;
        v25 = 0;
        if (*(_QWORD *)(*((_QWORD *)this + 4) + 8))
          goto LABEL_40;
        goto LABEL_55;
      }
LABEL_7:
      v21 = *((_QWORD *)a2 + 9);
      if (!v21)
        goto LABEL_20;
      if (v21 >= 8)
      {
        v22 = v21 & 0xFFFFFFFFFFFFFFF8;
        v26 = (__n128 *)v59;
        v27 = v21 & 0xFFFFFFFFFFFFFFF8;
        v28 = v20;
        do
        {
          v29 = *v28;
          v30 = v28[1];
          v28 += 2;
          v31 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v29, (float32x4_t)v14), v14, v29);
          v32 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v30, (float32x4_t)v14), v14, v30);
          v33 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v15, (float32x4_t)v31), v15, v31);
          v34 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v15, (float32x4_t)v32), v15, v32);
          a4 = (int8x16_t)vuzp1q_s16((int16x8_t)vcvtq_s32_f32(vaddq_f32((float32x4_t)v33, (float32x4_t)vbslq_s8(v13, v16, v33))), (int16x8_t)vcvtq_s32_f32(vaddq_f32((float32x4_t)v34, (float32x4_t)vbslq_s8(v13, v16, v34))));
          *v26++ = (__n128)a4;
          v27 -= 8;
        }
        while (v27);
        if (v21 == v22)
        {
LABEL_20:
          v23 = (char *)v59;
          if (v18)
            v24 = v18;
          else
            v24 = (char *)v59;
          if (v18)
            v25 = (char *)v59;
          else
            v25 = 0;
          if (*(_QWORD *)(*((_QWORD *)this + 4) + 8))
            goto LABEL_40;
          goto LABEL_55;
        }
      }
      else
      {
        v22 = 0;
      }
      do
      {
        a4.i32[0] = v20->i32[v22];
        if (*(float *)a4.i32 > 32767.0)
          *(float *)a4.i32 = 32767.0;
        if (*(float *)a4.i32 < -32768.0)
          *(float *)a4.i32 = -32768.0;
        v23 = (char *)v59;
        v59[v22++] = (int)(float)(*(float *)a4.i32 + *(float *)vbslq_s8(v13, a8, a4).i32);
      }
      while (v21 != v22);
      if (v18)
        v24 = v18;
      else
        v24 = (char *)v59;
      if (v18)
        v25 = (char *)v59;
      else
        v25 = 0;
      if (*(_QWORD *)(*((_QWORD *)this + 4) + 8))
      {
LABEL_40:
        v35 = a3;
        v36 = 0;
        if (v23)
        {
          while (1)
          {
            v37 = *((_QWORD *)this + 1);
            if (v12 >= (*((_QWORD *)this + 2) - v37) >> 3)
              goto LABEL_67;
            v38 = WebRtcAecm_Process(**(_QWORD **)(v37 + 8 * v12), v24, v25, v23, *((_QWORD *)a2 + 9), v35);
            v39 = *((_QWORD *)a2 + 11);
            if (v39)
            {
              v40 = *((_QWORD *)a2 + 9);
              if (!v40)
                goto LABEL_53;
            }
            else
            {
              v40 = *((_QWORD *)a2 + 9);
              v39 = *((_QWORD *)a2 + 10);
              if (!v40)
                goto LABEL_53;
            }
            v41 = *(_QWORD *)(*(_QWORD *)(v39 + 16) + 8 * *(_QWORD *)(v39 + 56) * v11);
            if (v40 >= 0x10)
            {
              v42 = v40 & 0xFFFFFFFFFFFFFFF0;
              v43 = v41 + 32;
              v44 = v40 & 0xFFFFFFFFFFFFFFF0;
              v45 = (int16x4_t *)(v23 + 16);
              do
              {
                v46 = *(int16x8_t *)v45[-2].i8;
                v47 = vcvtq_f32_s32(vmovl_s16(*v45));
                v48 = vmovl_high_s16(*(int16x8_t *)v45->i8);
                *(float32x4_t *)(v43 - 32) = vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v46.i8));
                *(float32x4_t *)(v43 - 16) = vcvtq_f32_s32(vmovl_high_s16(v46));
                a4 = (int8x16_t)vcvtq_f32_s32(v48);
                *(float32x4_t *)v43 = v47;
                *(int8x16_t *)(v43 + 16) = a4;
                v43 += 64;
                v45 += 4;
                v44 -= 16;
              }
              while (v44);
              if (v40 == v42)
                goto LABEL_53;
            }
            else
            {
              v42 = 0;
            }
            v49 = v40 - v42;
            v50 = (float *)(v41 + 4 * v42);
            v51 = &v23[2 * v42];
            do
            {
              v52 = *(__int16 *)v51;
              v51 += 2;
              *v50++ = (float)v52;
              --v49;
            }
            while (v49);
LABEL_53:
            if (v38)
              return;
            ++v12;
            if (++v36 >= *(_QWORD *)(*((_QWORD *)this + 4) + 8))
              goto LABEL_55;
          }
        }
        do
        {
          v55 = *((_QWORD *)this + 1);
          if (v12 + v36 >= (*((_QWORD *)this + 2) - v55) >> 3)
            goto LABEL_67;
          if (WebRtcAecm_Process(**(_QWORD **)(v55 + 8 * v12 + 8 * v36), v24, v25, 0, *((_QWORD *)a2 + 9), v35))return;
          ++v36;
        }
        while (v36 < *(_QWORD *)(*((_QWORD *)this + 4) + 8));
        v12 += v36;
        if (*((_QWORD *)a2 + 8) < 2uLL)
          goto LABEL_64;
LABEL_56:
        v53 = 1;
        do
        {
          v54 = *((_QWORD *)a2 + 11);
          if (!v54)
            v54 = *((_QWORD *)a2 + 10);
          bzero(*(void **)(*(_QWORD *)(v54 + 16) + v10 * *(_QWORD *)(v54 + 56) + 8 * v53++), 4 * *((_QWORD *)a2 + 9));
        }
        while (v53 < *((_QWORD *)a2 + 8));
        goto LABEL_64;
      }
LABEL_55:
      if (*((_QWORD *)a2 + 8) >= 2uLL)
        goto LABEL_56;
LABEL_64:
      ++v11;
      v10 += 8;
      a3 = v58;
      a8.i32[0] = 0.5;
      v13.i64[0] = 0x8000000080000000;
      v13.i64[1] = 0x8000000080000000;
      v14 = v57;
      v15.i64[0] = 0xC7000000C7000000;
      v15.i64[1] = 0xC7000000C7000000;
      v16.i64[0] = 0x3F0000003F000000;
      v16.i64[1] = 0x3F0000003F000000;
    }
    while (v11 < *((_QWORD *)a2 + 7));
  }
}

void webrtc::EchoControlMobileImpl::Initialize(webrtc::EchoControlMobileImpl *this, int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  char *v12;
  char *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  BOOL v41;
  unint64_t v42;
  uint64_t v43;
  char *v44;
  void *v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  _OWORD *v51;
  uint64_t v52;
  char *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;
  char *v59;
  uint64_t v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;
  char *v64;
  _QWORD **v65;
  _QWORD **v66;
  _QWORD *v67;
  void **v68;
  uint64_t **v69;
  _QWORD **v70;
  _QWORD **v71;
  _QWORD *v72;
  void **v73;
  uint64_t **v74;
  uint64_t v75;
  uint64_t **i;
  uint64_t *v77;
  webrtc *v78;
  void *v79;
  uint64_t *v80;
  _QWORD *v81;
  void **v82;
  __int16 v83;
  char v84;
  __int16 v85;
  int v86;
  uint64_t **v87;
  uint64_t **v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  uint64_t v93;
  _WORD *v94;
  uint64_t v95;

  v8 = a4;
  v13 = (char *)*((_QWORD *)this + 5);
  v12 = (char *)*((_QWORD *)this + 6);
  v14 = 0xCCCCCCCCCCCCCCCDLL * ((v12 - v13) >> 6);
  v15 = a4 - v14;
  if (a4 <= v14)
  {
    if (a4 < v14)
    {
      v12 = &v13[320 * a4];
      *((_QWORD *)this + 6) = v12;
    }
  }
  else
  {
    v16 = *((_QWORD *)this + 7);
    if (0xCCCCCCCCCCCCCCCDLL * ((v16 - (uint64_t)v12) >> 6) >= v15)
    {
      v24 = &v12[320 * v15];
      v27 = 320 * a4 - ((v12 - v13) >> 6 << 6);
      while (v12)
      {
        *((_OWORD *)v12 + 18) = 0uLL;
        *((_OWORD *)v12 + 19) = 0uLL;
        *((_OWORD *)v12 + 16) = 0uLL;
        *((_OWORD *)v12 + 17) = 0uLL;
        *((_OWORD *)v12 + 14) = 0uLL;
        *((_OWORD *)v12 + 15) = 0uLL;
        *((_OWORD *)v12 + 12) = 0uLL;
        *((_OWORD *)v12 + 13) = 0uLL;
        *((_OWORD *)v12 + 10) = 0uLL;
        *((_OWORD *)v12 + 11) = 0uLL;
        *((_OWORD *)v12 + 8) = 0uLL;
        *((_OWORD *)v12 + 9) = 0uLL;
        *((_OWORD *)v12 + 6) = 0uLL;
        *((_OWORD *)v12 + 7) = 0uLL;
        *((_OWORD *)v12 + 4) = 0uLL;
        *((_OWORD *)v12 + 5) = 0uLL;
        *((_OWORD *)v12 + 2) = 0uLL;
        *((_OWORD *)v12 + 3) = 0uLL;
        *(_OWORD *)v12 = 0uLL;
        *((_OWORD *)v12 + 1) = 0uLL;
        v12 += 320;
        v27 -= 320;
        if (!v27)
        {
          *((_QWORD *)this + 6) = v24;
          goto LABEL_23;
        }
      }
LABEL_107:
      __break(1u);
LABEL_108:
      rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_processing/echo_control_mobile_impl.cc", 79, "state_", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v95);
      goto LABEL_109;
    }
    if (a4 > 0xCCCCCCCCCCCCCCLL)
      goto LABEL_109;
    v17 = 0xCCCCCCCCCCCCCCCDLL * ((v16 - (uint64_t)v13) >> 6);
    v18 = 2 * v17;
    if (2 * v17 <= a4)
      v18 = a4;
    if (v17 >= 0x66666666666666)
      v19 = 0xCCCCCCCCCCCCCCLL;
    else
      v19 = v18;
    if (v19 > 0xCCCCCCCCCCCCCCLL)
      goto LABEL_110;
    v20 = 320 * v19;
    v21 = (char *)operator new(320 * v19);
    v22 = &v21[64 * ((v12 - v13) >> 6)];
    v23 = &v21[v20];
    v24 = &v21[320 * v8];
    v25 = 320 * v8 - ((v12 - v13) >> 6 << 6);
    v26 = v22;
    do
    {
      *((_OWORD *)v26 + 18) = 0uLL;
      *((_OWORD *)v26 + 19) = 0uLL;
      *((_OWORD *)v26 + 16) = 0uLL;
      *((_OWORD *)v26 + 17) = 0uLL;
      *((_OWORD *)v26 + 14) = 0uLL;
      *((_OWORD *)v26 + 15) = 0uLL;
      *((_OWORD *)v26 + 12) = 0uLL;
      *((_OWORD *)v26 + 13) = 0uLL;
      *((_OWORD *)v26 + 10) = 0uLL;
      *((_OWORD *)v26 + 11) = 0uLL;
      *((_OWORD *)v26 + 8) = 0uLL;
      *((_OWORD *)v26 + 9) = 0uLL;
      *((_OWORD *)v26 + 6) = 0uLL;
      *((_OWORD *)v26 + 7) = 0uLL;
      *((_OWORD *)v26 + 4) = 0uLL;
      *((_OWORD *)v26 + 5) = 0uLL;
      *((_OWORD *)v26 + 2) = 0uLL;
      *((_OWORD *)v26 + 3) = 0uLL;
      *(_OWORD *)v26 = 0uLL;
      *((_OWORD *)v26 + 1) = 0uLL;
      v26 += 320;
      v25 -= 320;
    }
    while (v25);
    if (v12 != v13)
    {
      do
      {
        v12 -= 320;
        v22 -= 320;
        memcpy(v22, v12, 0x140uLL);
      }
      while (v12 != v13);
      v12 = (char *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 5) = v22;
    *((_QWORD *)this + 6) = v24;
    *((_QWORD *)this + 7) = v23;
    if (v12)
    {
      operator delete(v12);
      v24 = (char *)*((_QWORD *)this + 6);
    }
LABEL_23:
    v13 = (char *)*((_QWORD *)this + 5);
    v12 = v24;
  }
  if (v13 != v12)
    bzero(v13, 320 * ((v12 - v13 - 320) / 0x140uLL) + 320);
  v29 = operator new();
  *(_DWORD *)v29 = a2;
  *(_QWORD *)(v29 + 8) = a3;
  *(_QWORD *)(v29 + 16) = v8;
  v30 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = v29;
  if (v30)
  {
    MEMORY[0x20BD0ADEC](v30, 0x1000C40D315E998);
    v31 = *((_QWORD *)this + 4);
    a3 = *(_QWORD *)(v31 + 8);
    v8 = *(_QWORD *)(v31 + 16);
  }
  v32 = v8 * a3;
  v34 = (char *)*((_QWORD *)this + 1);
  v33 = (char *)*((_QWORD *)this + 2);
  v35 = (char *)(v33 - v34);
  v36 = (v33 - v34) >> 3;
  v37 = v32 - v36;
  if (v32 <= v36)
  {
    if (v32 >= v36)
    {
      v69 = (uint64_t **)*((_QWORD *)this + 2);
    }
    else
    {
      v69 = (uint64_t **)&v34[8 * v32];
      while (v33 != (char *)v69)
      {
        v71 = (_QWORD **)*((_QWORD *)v33 - 1);
        v33 -= 8;
        v70 = v71;
        *(_QWORD *)v33 = 0;
        if (v71)
        {
          v72 = *v70;
          if (*v70)
          {
            webrtc::WebRtcAecm_FreeCore(v72[48], v28);
            v73 = (void **)v72[47];
            if (v73)
            {
              free(v73[5]);
              free(v73);
            }
            free(v72);
          }
          MEMORY[0x20BD0ADEC](v70, 0x80C40B8603338);
        }
      }
      *((_QWORD *)this + 2) = v69;
    }
    goto LABEL_76;
  }
  v38 = *((_QWORD *)this + 3);
  if (v37 > (v38 - (uint64_t)v33) >> 3)
  {
    if (!(v32 >> 61))
    {
      v39 = v38 - (_QWORD)v34;
      v40 = (v38 - (uint64_t)v34) >> 2;
      if (v40 <= v32)
        v40 = v32;
      v41 = v39 >= 0x7FFFFFFFFFFFFFF8;
      v42 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v41)
        v42 = v40;
      if (!(v42 >> 61))
      {
        v43 = 8 * v42;
        v44 = (char *)operator new(8 * v42);
        v46 = (unint64_t)&v44[8 * v36];
        v47 = &v44[8 * v32];
        v48 = 8 * v32 - (_QWORD)v35 - 8;
        v49 = (char *)v46;
        if (v48 < 0x18)
          goto LABEL_113;
        v50 = (v48 >> 3) + 1;
        v49 = (char *)(v46 + 8 * (v50 & 0x3FFFFFFFFFFFFFFCLL));
        v51 = (_OWORD *)(v46 + 16);
        v52 = v50 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          *(v51 - 1) = 0uLL;
          *v51 = 0uLL;
          v51 += 2;
          v52 -= 4;
        }
        while (v52);
        if (v50 != (v50 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_113:
          do
          {
            *(_QWORD *)v49 = 0;
            v49 += 8;
          }
          while (v49 != v47);
        }
        v53 = &v44[v43];
        if (v33 == v34)
        {
          *((_QWORD *)this + 1) = v46;
          *((_QWORD *)this + 2) = v47;
          *((_QWORD *)this + 3) = v53;
        }
        else
        {
          v54 = v33 - v34 - 8;
          if (v54 < 0x78
            || (unint64_t)&v33[-(v54 & 0xFFFFFFFFFFFFFFF8) - 8] < v46
            && &v35[(_QWORD)v44 - (v54 & 0xFFFFFFFFFFFFFFF8) - 8] < v33)
          {
            goto LABEL_114;
          }
          v55 = (v54 >> 3) + 1;
          v56 = 8 * (v55 & 0x3FFFFFFFFFFFFFFCLL);
          v57 = &v33[-v56];
          v46 -= v56;
          v58 = &v44[8 * v36 - 16];
          v59 = v33 - 16;
          v60 = v55 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v62 = *((_OWORD *)v59 - 1);
            v61 = *(_OWORD *)v59;
            *((_OWORD *)v59 - 1) = 0uLL;
            *(_OWORD *)v59 = 0uLL;
            *((_OWORD *)v58 - 1) = v62;
            *(_OWORD *)v58 = v61;
            v58 -= 32;
            v59 -= 32;
            v60 -= 4;
          }
          while (v60);
          v33 = v57;
          if (v55 != (v55 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_114:
            do
            {
              v63 = *((_QWORD *)v33 - 1);
              v33 -= 8;
              *(_QWORD *)v33 = 0;
              *(_QWORD *)(v46 - 8) = v63;
              v46 -= 8;
            }
            while (v33 != v34);
          }
          v33 = (char *)*((_QWORD *)this + 1);
          v64 = (char *)*((_QWORD *)this + 2);
          *((_QWORD *)this + 1) = v46;
          *((_QWORD *)this + 2) = v47;
          *((_QWORD *)this + 3) = v53;
          while (v64 != v33)
          {
            v66 = (_QWORD **)*((_QWORD *)v64 - 1);
            v64 -= 8;
            v65 = v66;
            *(_QWORD *)v64 = 0;
            if (v66)
            {
              v67 = *v65;
              if (*v65)
              {
                webrtc::WebRtcAecm_FreeCore(v67[48], v45);
                v68 = (void **)v67[47];
                if (v68)
                {
                  free(v68[5]);
                  free(v68);
                }
                free(v67);
              }
              MEMORY[0x20BD0ADEC](v65, 0x80C40B8603338);
            }
          }
        }
        if (v33)
          operator delete(v33);
        v69 = (uint64_t **)*((_QWORD *)this + 2);
        goto LABEL_76;
      }
LABEL_110:
      std::__throw_bad_array_new_length[abi:sn180100]();
    }
LABEL_109:
    abort();
  }
  v74 = (uint64_t **)&v33[8 * v37];
  v75 = 8 * v32 - 8 * v36;
  do
  {
    if (!v33)
      goto LABEL_107;
    *(_QWORD *)v33 = 0;
    v33 += 8;
    v75 -= 8;
  }
  while (v75);
  *((_QWORD *)this + 2) = v74;
  v69 = v74;
LABEL_76:
  for (i = (uint64_t **)*((_QWORD *)this + 1); i != v69; ++i)
  {
    v77 = *i;
    if (!*i)
    {
      v77 = (uint64_t *)operator new();
      v78 = WebRtcAecm_Create();
      *v77 = (uint64_t)v78;
      if (!v78)
        goto LABEL_108;
      v80 = *i;
      *i = v77;
      if (v80)
      {
        v81 = (_QWORD *)*v80;
        if (*v80)
        {
          webrtc::WebRtcAecm_FreeCore(v81[48], v79);
          v82 = (void **)v81[47];
          if (v82)
          {
            free(v82[5]);
            free(v82);
          }
          free(v81);
        }
        MEMORY[0x20BD0ADEC](v80, 0x80C40B8603338);
        v77 = *i;
      }
    }
    WebRtcAecm_Init(*v77, a2);
  }
  v83 = *((unsigned __int8 *)this + 4);
  v84 = 0;
  v85 = 0;
  v86 = 1;
  switch(*(_DWORD *)this)
  {
    case 0:
      goto LABEL_95;
    case 1:
      v84 = 0;
      v85 = 1;
      v87 = (uint64_t **)*((_QWORD *)this + 1);
      v88 = (uint64_t **)*((_QWORD *)this + 2);
      if (v87 == v88)
        return;
      goto LABEL_100;
    case 2:
      v84 = 0;
      v85 = 2;
      v87 = (uint64_t **)*((_QWORD *)this + 1);
      v88 = (uint64_t **)*((_QWORD *)this + 2);
      if (v87 == v88)
        return;
      goto LABEL_100;
    case 3:
      v84 = 0;
      v85 = 3;
LABEL_95:
      v87 = (uint64_t **)*((_QWORD *)this + 1);
      v88 = (uint64_t **)*((_QWORD *)this + 2);
      if (v87 != v88)
        goto LABEL_100;
      return;
    case 4:
      v84 = 0;
      v86 = 0;
      v85 = 4;
      v87 = (uint64_t **)*((_QWORD *)this + 1);
      v88 = (uint64_t **)*((_QWORD *)this + 2);
      if (v87 == v88)
        return;
      goto LABEL_100;
    default:
      v86 = 0;
      v85 = -1;
      v84 = 1;
      v87 = (uint64_t **)*((_QWORD *)this + 1);
      v88 = (uint64_t **)*((_QWORD *)this + 2);
      if (v87 == v88)
        return;
      do
      {
LABEL_100:
        v93 = **v87;
        if (v93)
        {
          if (*(_WORD *)(v93 + 336) == 42)
          {
            v94 = (_WORD *)(*(_QWORD *)(v93 + 384) + 17230);
            *v94 = v83;
            if ((v84 & 1) == 0)
            {
              *(_WORD *)(v93 + 370) = v85;
              if (v86)
              {
                v89 = 0x100008000400020uLL >> (16 * v85);
                v90 = 0xC00060003000180uLL >> (16 * v85);
                v91 = 0x6000300018000C0uLL >> (16 * v85);
                v92 = 0x5000280014000A0uLL >> (16 * v85);
              }
              else
              {
                LOWORD(v92) = 2560;
                LOWORD(v91) = 3072;
                LOWORD(v90) = 6144;
                LOWORD(v89) = 512;
              }
              v94[18] = v89;
              v94[19] = v89;
              v94[20] = v90;
              v94[21] = v89;
              v94[22] = v91;
              v94[23] = v92;
            }
          }
        }
        ++v87;
      }
      while (v87 != v88);
      return;
  }
}

uint64_t webrtc::EchoPathDelayEstimator::EchoPathDelayEstimator(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  int v8;
  int v9;
  float v10;
  char v11;
  uint64_t v12;
  int v13;
  void *v14;
  uint64_t v15;
  float *v16;
  uint64_t result;
  _QWORD *v18;
  uint64_t v19;

  v6 = *(_QWORD *)(a3 + 24);
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v6;
  if (v6)
    v7 = 0x40 / v6;
  else
    v7 = 64;
  v8 = *(unsigned __int8 *)(a3 + 100);
  v9 = *(unsigned __int8 *)(a3 + 101);
  v10 = *(float *)(a3 + 104);
  v11 = *(_BYTE *)(a3 + 108);
  *(_QWORD *)(a1 + 64) = 0;
  v12 = a1 + 64;
  *(_QWORD *)(v12 - 48) = v7;
  *(_QWORD *)(v12 - 40) = a4;
  *(float *)(v12 - 32) = 1.0 / (float)a4;
  *(float *)(v12 - 28) = v10 * 64.0;
  *(_BYTE *)(v12 - 24) = v11;
  if (v9)
    v13 = 1;
  else
    v13 = 2;
  if (v8)
    v13 = 0;
  if ((_DWORD)a4 == 1)
    v13 = 2;
  *(_DWORD *)(v12 - 20) = v13;
  *(_QWORD *)(v12 + 32) = 0;
  *(_QWORD *)(v12 + 8) = 0;
  *(_QWORD *)(v12 + 16) = 0;
  *(_DWORD *)(v12 + 24) = 0;
  if (v13 == 1)
  {
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    if (a4)
    {
      std::vector<float>::__append(v12, a4);
      v14 = *(void **)(a1 + 64);
      v15 = *(_QWORD *)(a1 + 72) - (_QWORD)v14;
      if (v15 >= 1)
        bzero(v14, 4 * (((unint64_t)v15 >> 2) - ((unint64_t)v15 > 3)) + 4);
    }
  }
  webrtc::Decimator::Decimator((void **)(a1 + 104), *(void **)(a1 + 8));
  if (*(_QWORD *)(a3 + 24) == 8)
    v16 = (float *)(a3 + 324);
  else
    v16 = (float *)(a3 + 320);
  result = webrtc::MatchedFilter::MatchedFilter(a1 + 160, *(_QWORD *)a1, 0, *(_QWORD *)(a1 + 16), 32, *(_DWORD *)(a3 + 32), 24, *(unsigned __int8 *)(a3 + 112), *v16, *(float *)(a3 + 64), *(float *)(a3 + 68), *(float *)(a3 + 72));
  v18 = *(_QWORD **)(a1 + 192);
  v19 = *(_QWORD *)(a1 + 200) - (_QWORD)v18;
  if (v19)
  {
    webrtc::MatchedFilterLagAggregator::MatchedFilterLagAggregator(a1 + 384, *(_QWORD *)a1, 0xAAAAAAAAAAAAAAABLL * (v19 >> 3) * *(_QWORD *)(a1 + 184) + ((uint64_t)(v18[1] - *v18) >> 2), a3 + 16);
    *(_BYTE *)(a1 + 1448) = 0;
    *(_BYTE *)(a1 + 1480) = 0;
    *(_OWORD *)(a1 + 1488) = 0u;
    *(_OWORD *)(a1 + 1504) = 0u;
    return a1;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void webrtc::EchoPathDelayEstimator::~EchoPathDelayEstimator(webrtc::EchoPathDelayEstimator *this)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v2 = *((_QWORD *)this + 180);
  *((_QWORD *)this + 180) = 0;
  if (v2)
  {
    v3 = *(void **)(v2 + 1008);
    if (v3)
    {
      *(_QWORD *)(v2 + 1016) = v3;
      operator delete(v3);
    }
    MEMORY[0x20BD0ADEC](v2, 0x1010C40BB29770BLL);
  }
  v4 = (void *)*((_QWORD *)this + 51);
  if (v4)
  {
    *((_QWORD *)this + 52) = v4;
    operator delete(v4);
  }
  webrtc::MatchedFilter::~MatchedFilter((webrtc::EchoPathDelayEstimator *)((char *)this + 160));
  v5 = (void *)*((_QWORD *)this + 17);
  if (v5)
  {
    *((_QWORD *)this + 18) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 14);
  if (v6)
  {
    *((_QWORD *)this + 15) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 8);
  if (v7)
  {
    *((_QWORD *)this + 9) = v7;
    operator delete(v7);
  }
}

void webrtc::EchoPathDelayEstimator::Reset(webrtc::EchoPathDelayEstimator *this, int a2)
{
  void *v4;
  uint64_t v5;
  _QWORD *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;

  v4 = (void *)*((_QWORD *)this + 51);
  v5 = *((_QWORD *)this + 52) - (_QWORD)v4;
  if (v5 >= 1)
    bzero(v4, 4 * (((unint64_t)v5 >> 2) - ((unint64_t)v5 > 3)) + 4);
  bzero((char *)this + 432, 0x3ECuLL);
  v6 = (_QWORD *)*((_QWORD *)this + 180);
  if (v6)
  {
    v7 = (void *)v6[126];
    v8 = v6[127] - (_QWORD)v7;
    if (v8 >= 1)
      bzero(v7, 4 * (((unint64_t)v8 >> 2) - ((unint64_t)v8 > 3)) + 4);
    memset((char *)v6 + 4, 255, 0x3E8uLL);
    v6[129] = 0;
  }
  if (a2)
    *((_BYTE *)this + 392) = 0;
  v9 = *((_QWORD *)this + 24);
  v10 = *((_QWORD *)this + 25);
  while (v9 != v10)
  {
    v11 = *(_QWORD *)(v9 + 8) - *(_QWORD *)v9;
    if (v11 >= 1)
      bzero(*(void **)v9, 4 * (((unint64_t)v11 >> 2) - ((unint64_t)v11 > 3)) + 4);
    v9 += 24;
  }
  if (*((_BYTE *)this + 320))
    *((_BYTE *)this + 320) = 0;
  if (*((_BYTE *)this + 304))
    *((_BYTE *)this + 304) = 0;
  v12 = *((_QWORD *)this + 27);
  for (i = *((_QWORD *)this + 28); v12 != i; v12 += 24)
  {
    v14 = *(_QWORD *)(v12 + 8) - *(_QWORD *)v12;
    if (v14 >= 1)
      memset_pattern16(*(void **)v12, &memset_pattern_17, 4 * (((unint64_t)v14 >> 2) - ((unint64_t)v14 > 3)) + 4);
  }
  *((_DWORD *)this + 90) = 0;
  if (*((_BYTE *)this + 1480))
    *((_BYTE *)this + 1480) = 0;
  *((_QWORD *)this + 186) = 0;
}

void webrtc::EchoPathDelayEstimator::EstimateDelay(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  int v9;
  uint64_t *v10;
  float32x4_t *v11;
  float32x4_t *v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  uint64_t v26;
  int v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  float32x4_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t i;
  uint64_t v43;
  float v44;
  float *v45;
  float v46;
  int v47;
  int v48;
  int v49;
  unint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  BOOL v55;
  _BOOL4 v56;
  _BOOL4 v58;
  _BOOL4 v59;
  int v61;
  uint64_t v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  __int128 v68;
  char v69;
  float32x4_t __dst;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86[16];

  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_DWORD *)(a1 + 44);
  if (v9 == 2)
  {
    v43 = 0;
LABEL_16:
    memmove(&__dst, (const void *)(*(_QWORD *)(a3 + 8) + 4 * v43), 0x100uLL);
    goto LABEL_18;
  }
  v10 = (uint64_t *)(a1 + 24);
  if (v9)
  {
    v43 = (int)(webrtc::AlignmentMixer::SelectChannel((uint64_t)v10, a3) << 6);
    goto LABEL_16;
  }
  v11 = *(float32x4_t **)(a3 + 8);
  v12 = *(float32x4_t **)(a3 + 16);
  v13 = (char *)v12 - (char *)v11;
  if (v12 == v11)
  {
LABEL_80:
    __break(1u);
    return;
  }
  v14 = *v11;
  v15 = v11[1];
  v16 = v11[3];
  v72 = v11[2];
  v73 = v16;
  __dst = v14;
  v71 = v15;
  v17 = v11[4];
  v18 = v11[5];
  v19 = v11[7];
  v76 = v11[6];
  v77 = v19;
  v74 = v17;
  v75 = v18;
  v20 = v11[8];
  v21 = v11[9];
  v22 = v11[11];
  v80 = v11[10];
  v81 = v22;
  v78 = v20;
  v79 = v21;
  v23 = v11[12];
  v24 = v11[13];
  v25 = v11[15];
  v84 = v11[14];
  v85 = v25;
  v82 = v23;
  v83 = v24;
  v26 = *v10;
  if ((unint64_t)*v10 >= 2)
  {
    v27 = 0;
    v28 = v13 >> 2;
    v29 = 16;
    v30 = 1;
    do
    {
      v40 = (int)((_DWORD)v30 << 6);
      if (v28 <= v40)
        goto LABEL_80;
      v41 = 4 * ((v27 << 6) + 64);
      if (&__dst >= (float32x4_t *)((char *)&v11[16] + v41) || (float32x4_t *)((char *)v11 + v41) >= v86)
      {
        v31 = (float32x4_t *)((char *)v11 + 4 * v40);
        v32 = vaddq_f32(v31[1], v71);
        __dst = vaddq_f32(*v31, __dst);
        v71 = v32;
        v33 = vaddq_f32(v31[3], v73);
        v72 = vaddq_f32(v31[2], v72);
        v73 = v33;
        v34 = vaddq_f32(v31[5], v75);
        v74 = vaddq_f32(v31[4], v74);
        v75 = v34;
        v35 = vaddq_f32(v31[7], v77);
        v76 = vaddq_f32(v31[6], v76);
        v77 = v35;
        v36 = vaddq_f32(v31[9], v79);
        v78 = vaddq_f32(v31[8], v78);
        v79 = v36;
        v37 = vaddq_f32(v31[11], v81);
        v80 = vaddq_f32(v31[10], v80);
        v81 = v37;
        v38 = vaddq_f32(v31[13], v83);
        v82 = vaddq_f32(v31[12], v82);
        v83 = v38;
        v39 = vaddq_f32(v31[15], v85);
        v84 = vaddq_f32(v31[14], v84);
        v85 = v39;
      }
      else
      {
        for (i = 0; i != 64; ++i)
          __dst.f32[i] = v11[v29].f32[i] + __dst.f32[i];
      }
      ++v30;
      ++v27;
      v29 += 16;
    }
    while (v30 != v26);
  }
  v44 = *(float *)(a1 + 32);
  __dst = vmulq_n_f32(__dst, v44);
  v71 = vmulq_n_f32(v71, v44);
  v72 = vmulq_n_f32(v72, v44);
  v73 = vmulq_n_f32(v73, v44);
  v74 = vmulq_n_f32(v74, v44);
  v75 = vmulq_n_f32(v75, v44);
  v76 = vmulq_n_f32(v76, v44);
  v77 = vmulq_n_f32(v77, v44);
  v78 = vmulq_n_f32(v78, v44);
  v79 = vmulq_n_f32(v79, v44);
  v80 = vmulq_n_f32(v80, v44);
  v81 = vmulq_n_f32(v81, v44);
  v82 = vmulq_n_f32(v82, v44);
  v83 = vmulq_n_f32(v83, v44);
  v84 = vmulq_n_f32(v84, v44);
  v85 = vmulq_n_f32(v85, v44);
LABEL_18:
  if (v8)
    v45 = (float *)v86;
  else
    v45 = 0;
  webrtc::Decimator::Decimate((_QWORD *)(a1 + 104), __dst.f32, 64, v45, v8);
  webrtc::MatchedFilter::Update(a1 + 160, a2, (uint64_t)v45, v8, *(unsigned __int8 *)(a1 + 392), v46);
  LOBYTE(v68) = 0;
  v69 = 0;
  if (*(_BYTE *)(a1 + 304))
  {
    v68 = *(_OWORD *)(a1 + 288);
    v69 = 1;
  }
  webrtc::MatchedFilterLagAggregator::Aggregate(a1 + 384, (int *)&v68, a4);
  if (!*(_BYTE *)(a4 + 32))
  {
    v51 = a1 + 1448;
    goto LABEL_65;
  }
  if (*(_DWORD *)a4 == 1)
  {
    v47 = *(_DWORD *)(a1 + 1436);
    v48 = *(_DWORD *)(a1 + 1496);
    v49 = v48 - v47;
    if (v48 == v47)
    {
      v50 = *(_QWORD *)(a1 + 1512) + 1;
      *(_QWORD *)(a1 + 1512) = v50;
      if (v50 >= 0x1D4D)
        *(_DWORD *)(a1 + 1508) = 0;
      goto LABEL_62;
    }
    *(_QWORD *)(a1 + 1512) = 0;
    v52 = *(_DWORD *)(a1 + 1500);
    v53 = v52 - v47;
    v54 = *(_DWORD *)(a1 + 1504) - v47;
    if (v49 == -1 && v53 == -2)
    {
      v55 = v54 == -3;
      v56 = 1;
    }
    else
    {
      v56 = v49 == -2 && v53 == -1;
      v55 = v54 == -3 && v56;
      if (v49 == 1 && v53 == 2)
      {
        v58 = 1;
        v59 = v54 == 3;
        if (v55)
          goto LABEL_59;
        goto LABEL_55;
      }
    }
    v58 = v49 == 2 && v53 == 1;
    v59 = v54 == 3 && v58;
    if (v55)
      goto LABEL_59;
LABEL_55:
    if (!v59)
    {
      if (!v56 && !v58 || *(_DWORD *)(a1 + 1508))
        goto LABEL_61;
      v61 = 1;
LABEL_60:
      *(_DWORD *)(a1 + 1508) = v61;
LABEL_61:
      *(_DWORD *)(a1 + 1504) = v52;
      *(_DWORD *)(a1 + 1500) = v48;
      *(_DWORD *)(a1 + 1496) = v47;
      goto LABEL_62;
    }
LABEL_59:
    v61 = 2;
    goto LABEL_60;
  }
LABEL_62:
  v62 = *(_QWORD *)(a4 + 8) * *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a4 + 8) = v62;
  v51 = a1 + 1448;
  if (*(_BYTE *)(a1 + 1480) && *(_QWORD *)(a1 + 1456) == v62)
  {
    ++*(_QWORD *)(a1 + 1488);
    goto LABEL_66;
  }
LABEL_65:
  *(_QWORD *)(a1 + 1488) = 0;
LABEL_66:
  v63 = *(_OWORD *)a4;
  v64 = *(_OWORD *)(a4 + 16);
  *(_BYTE *)(v51 + 32) = *(_BYTE *)(a4 + 32);
  *(_OWORD *)v51 = v63;
  *(_OWORD *)(v51 + 16) = v64;
  if (*(_QWORD *)(a1 + 1488) >= 0x7EuLL)
  {
    v65 = *(_QWORD *)(a1 + 192);
    v66 = *(_QWORD *)(a1 + 200);
    while (v65 != v66)
    {
      v67 = *(_QWORD *)(v65 + 8) - *(_QWORD *)v65;
      if (v67 >= 1)
        bzero(*(void **)v65, 4 * (((unint64_t)v67 >> 2) - ((unint64_t)v67 > 3)) + 4);
      v65 += 24;
    }
    if (*(_BYTE *)(a1 + 320))
      *(_BYTE *)(a1 + 320) = 0;
    if (*(_BYTE *)(a1 + 304))
      *(_BYTE *)(a1 + 304) = 0;
    if (*(_BYTE *)(a1 + 1480))
      *(_BYTE *)(a1 + 1480) = 0;
    *(_QWORD *)(a1 + 1488) = 0;
  }
}

uint64_t webrtc::EchoRemover::Create(webrtc::EchoRemover *this, const webrtc::EchoCanceller3Config *a2, unint64_t a3, unint64_t a4)
{
  int v6;
  uint64_t v8;
  __int128 v9;
  const webrtc::EchoCanceller3Config *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  size_t v40;
  char *v41;
  char *v42;
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  size_t v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  uint64_t v58;
  char *v59;
  char *v60;

  v6 = (int)a2;
  v8 = operator new();
  *(_QWORD *)v8 = &off_24C0B3848;
  v9 = *((_OWORD *)this + 1);
  *(_OWORD *)(v8 + 8) = *(_OWORD *)this;
  v10 = (const webrtc::EchoCanceller3Config *)(v8 + 8);
  v11 = *((_OWORD *)this + 5);
  *(_OWORD *)(v8 + 72) = *((_OWORD *)this + 4);
  *(_OWORD *)(v8 + 88) = v11;
  *(_OWORD *)(v8 + 104) = *((_OWORD *)this + 6);
  *(_BYTE *)(v8 + 120) = *((_BYTE *)this + 112);
  *(_OWORD *)(v8 + 24) = v9;
  v12 = *((_OWORD *)this + 3);
  *(_OWORD *)(v8 + 40) = *((_OWORD *)this + 2);
  *(_OWORD *)(v8 + 56) = v12;
  v13 = *(_OWORD *)((char *)this + 296);
  v14 = *(_OWORD *)((char *)this + 312);
  v15 = *(_OWORD *)((char *)this + 264);
  *(_OWORD *)(v8 + 288) = *(_OWORD *)((char *)this + 280);
  *(_OWORD *)(v8 + 304) = v13;
  *(_OWORD *)(v8 + 320) = v14;
  *(_QWORD *)(v8 + 334) = *(_QWORD *)((char *)this + 326);
  v16 = *(_OWORD *)((char *)this + 232);
  *(_OWORD *)(v8 + 224) = *(_OWORD *)((char *)this + 216);
  *(_OWORD *)(v8 + 240) = v16;
  *(_OWORD *)(v8 + 256) = *(_OWORD *)((char *)this + 248);
  *(_OWORD *)(v8 + 272) = v15;
  v17 = *(_OWORD *)((char *)this + 168);
  *(_OWORD *)(v8 + 160) = *(_OWORD *)((char *)this + 152);
  *(_OWORD *)(v8 + 176) = v17;
  v18 = *(_OWORD *)((char *)this + 200);
  *(_OWORD *)(v8 + 192) = *(_OWORD *)((char *)this + 184);
  *(_OWORD *)(v8 + 208) = v18;
  v19 = *(_OWORD *)((char *)this + 136);
  *(_OWORD *)(v8 + 128) = *(_OWORD *)((char *)this + 120);
  *(_OWORD *)(v8 + 144) = v19;
  v20 = *((_OWORD *)this + 22);
  *(_OWORD *)(v8 + 344) = *((_OWORD *)this + 21);
  *(_OWORD *)(v8 + 360) = v20;
  *(_OWORD *)(v8 + 369) = *(_OWORD *)((char *)this + 361);
  *(_DWORD *)(v8 + 392) = *((_DWORD *)this + 96);
  v21 = *((_QWORD *)this + 50);
  *(_QWORD *)(v8 + 400) = *((_QWORD *)this + 49);
  *(_QWORD *)(v8 + 408) = v21;
  *(_DWORD *)(v8 + 416) = *((_DWORD *)this + 102);
  *(_DWORD *)(v8 + 428) = *((_DWORD *)this + 105);
  *(_QWORD *)(v8 + 420) = *(_QWORD *)((char *)this + 412);
  v22 = *((_QWORD *)this + 54);
  *(_QWORD *)(v8 + 432) = *((_QWORD *)this + 53);
  *(_QWORD *)(v8 + 440) = v22;
  *(_DWORD *)(v8 + 448) = *((_DWORD *)this + 110);
  *(_QWORD *)(v8 + 452) = *(_QWORD *)((char *)this + 444);
  *(_DWORD *)(v8 + 460) = *((_DWORD *)this + 113);
  *(_QWORD *)(v8 + 464) = *((_QWORD *)this + 57);
  *(_OWORD *)(v8 + 577) = *(_OWORD *)((char *)this + 569);
  v23 = *((_OWORD *)this + 35);
  v24 = *((_OWORD *)this + 33);
  *(_OWORD *)(v8 + 552) = *((_OWORD *)this + 34);
  *(_OWORD *)(v8 + 568) = v23;
  v25 = *((_OWORD *)this + 31);
  *(_OWORD *)(v8 + 520) = *((_OWORD *)this + 32);
  *(_OWORD *)(v8 + 536) = v24;
  v26 = *((_OWORD *)this + 29);
  *(_OWORD *)(v8 + 488) = *((_OWORD *)this + 30);
  *(_OWORD *)(v8 + 504) = v25;
  *(_OWORD *)(v8 + 472) = v26;
  *(_OWORD *)(v8 + 600) = *((_OWORD *)this + 37);
  *(_BYTE *)(v8 + 616) = 0;
  v27 = operator new();
  do
  *(_QWORD *)(v8 + 624) = v27;
  *(_DWORD *)(v8 + 632) = 0;
  *(_DWORD *)(v8 + 636) = v6;
  *(_QWORD *)(v8 + 640) = a3;
  *(_QWORD *)(v8 + 648) = a4;
  *(_BYTE *)(v8 + 656) = *(_BYTE *)(v8 + 241);
  webrtc::Subtractor::Subtractor(v8 + 664, (uint64_t)this, a3, a4, v27, 0);
  webrtc::SuppressionGain::SuppressionGain(v8 + 1552, (uint64_t)v10, *(_DWORD *)(v8 + 632), v29, a4);
  webrtc::ComfortNoiseGenerator::ComfortNoiseGenerator(v8 + 4128, (uint64_t)v10, *(_DWORD *)(v8 + 632), *(_QWORD *)(v8 + 648));
  webrtc::SuppressionFilter::SuppressionFilter(v8 + 4216, *(_DWORD *)(v8 + 632), *(_DWORD *)(v8 + 636), *(_QWORD *)(v8 + 648));
  *(_DWORD *)(v8 + 4264) = *(_QWORD *)(v8 + 128);
  *(_BYTE *)(v8 + 4780) = 0;
  *(_OWORD *)(v8 + 4761) = 0u;
  *(_OWORD *)(v8 + 4272) = 0u;
  *(_OWORD *)(v8 + 4288) = 0u;
  *(_OWORD *)(v8 + 4304) = 0u;
  *(_OWORD *)(v8 + 4320) = 0u;
  *(_OWORD *)(v8 + 4336) = 0u;
  *(_OWORD *)(v8 + 4352) = 0u;
  *(_OWORD *)(v8 + 4368) = 0u;
  *(_OWORD *)(v8 + 4384) = 0u;
  *(_OWORD *)(v8 + 4400) = 0u;
  *(_OWORD *)(v8 + 4416) = 0u;
  *(_OWORD *)(v8 + 4432) = 0u;
  *(_OWORD *)(v8 + 4448) = 0u;
  *(_OWORD *)(v8 + 4464) = 0u;
  *(_OWORD *)(v8 + 4480) = 0u;
  *(_OWORD *)(v8 + 4496) = 0u;
  *(_OWORD *)(v8 + 4512) = 0u;
  *(_OWORD *)(v8 + 4528) = 0u;
  *(_OWORD *)(v8 + 4544) = 0u;
  *(_OWORD *)(v8 + 4560) = 0u;
  *(_OWORD *)(v8 + 4576) = 0u;
  *(_OWORD *)(v8 + 4592) = 0u;
  *(_OWORD *)(v8 + 4608) = 0u;
  *(_OWORD *)(v8 + 4624) = 0u;
  *(_OWORD *)(v8 + 4640) = 0u;
  *(_OWORD *)(v8 + 4656) = 0u;
  *(_OWORD *)(v8 + 4672) = 0u;
  *(_OWORD *)(v8 + 4688) = 0u;
  *(_OWORD *)(v8 + 4704) = 0u;
  *(_OWORD *)(v8 + 4720) = 0u;
  *(_OWORD *)(v8 + 4736) = 0u;
  *(_OWORD *)(v8 + 4752) = 0u;
  webrtc::ResidualEchoEstimator::ResidualEchoEstimator((webrtc::ResidualEchoEstimator *)(v8 + 4792), v10, a3);
  *(_WORD *)(v8 + 6208) = 256;
  webrtc::AecState::AecState((webrtc::AecState *)(v8 + 6216), v10, *(_QWORD *)(v8 + 648));
  *(_OWORD *)(v8 + 9304) = 0u;
  *(_QWORD *)(v8 + 9326) = 0;
  *(_QWORD *)(v8 + 9320) = 0;
  *(_DWORD *)(v8 + 9312) = 1176256512;
  *(_DWORD *)(v8 + 9328) = 1148846080;
  v30 = *(_QWORD *)(v8 + 648);
  *(_QWORD *)(v8 + 9336) = 0;
  *(_OWORD *)(v8 + 9344) = 0u;
  v31 = v30 << 8;
  if (v30)
  {
    if (HIBYTE(v30))
      goto LABEL_16;
    v32 = (char *)operator new(v30 << 8);
    *(_QWORD *)(v8 + 9336) = v32;
    v33 = &v32[v31];
    *(_QWORD *)(v8 + 9352) = &v32[v31];
    bzero(v32, v30 << 8);
    *(_QWORD *)(v8 + 9344) = v33;
    v34 = (char *)operator new(v30 << 8);
    *(_QWORD *)(v8 + 9360) = v34;
    v35 = &v34[v31];
    *(_QWORD *)(v8 + 9376) = &v34[v31];
    bzero(v34, v30 << 8);
    *(_QWORD *)(v8 + 9368) = v35;
  }
  else
  {
    *(_QWORD *)(v8 + 9376) = 0;
    *(_OWORD *)(v8 + 9360) = 0uLL;
  }
  *(_QWORD *)(v8 + 9384) = 0;
  *(_DWORD *)(v8 + 9392) = 0;
  *(_BYTE *)(v8 + 9396) = 1;
  *(_QWORD *)(v8 + 9400) = 0;
  *(_QWORD *)(v8 + 9416) = 0;
  *(_QWORD *)(v8 + 9408) = 0;
  if (v30 < 3)
  {
    *(_OWORD *)(v8 + 9648) = 0u;
    *(_OWORD *)(v8 + 9632) = 0u;
    *(_OWORD *)(v8 + 9616) = 0u;
    *(_OWORD *)(v8 + 9600) = 0u;
    *(_OWORD *)(v8 + 9584) = 0u;
    *(_OWORD *)(v8 + 9568) = 0u;
    *(_OWORD *)(v8 + 9552) = 0u;
    *(_OWORD *)(v8 + 9536) = 0u;
    *(_OWORD *)(v8 + 9520) = 0u;
    *(_OWORD *)(v8 + 9504) = 0u;
    *(_OWORD *)(v8 + 9488) = 0u;
    *(_OWORD *)(v8 + 9472) = 0u;
    *(_OWORD *)(v8 + 9456) = 0u;
    *(_OWORD *)(v8 + 9440) = 0u;
    *(_OWORD *)(v8 + 9424) = 0u;
    return v8;
  }
  v36 = (char *)operator new(v30 << 8);
  *(_QWORD *)(v8 + 9400) = v36;
  v37 = &v36[v31];
  *(_QWORD *)(v8 + 9416) = &v36[v31];
  bzero(v36, v30 << 8);
  *(_QWORD *)(v8 + 9408) = v37;
  *(_QWORD *)(v8 + 9424) = 0;
  *(_QWORD *)(v8 + 9440) = 0;
  *(_QWORD *)(v8 + 9432) = 0;
  if (v30 >= 0xFC0FC0FC0FC0FDLL)
    goto LABEL_16;
  v38 = (char *)operator new(260 * v30);
  *(_QWORD *)(v8 + 9424) = v38;
  v39 = &v38[260 * v30];
  *(_QWORD *)(v8 + 9440) = v39;
  v40 = 260 * ((260 * v30 - 260) / 0x104) + 260;
  bzero(v38, v40);
  *(_QWORD *)(v8 + 9432) = v39;
  v41 = (char *)operator new(260 * v30);
  *(_QWORD *)(v8 + 9448) = v41;
  v42 = &v41[260 * v30];
  *(_QWORD *)(v8 + 9464) = v42;
  bzero(v41, v40);
  *(_QWORD *)(v8 + 9456) = v42;
  v43 = (char *)operator new(260 * v30);
  *(_QWORD *)(v8 + 9472) = v43;
  v44 = &v43[260 * v30];
  *(_QWORD *)(v8 + 9488) = v44;
  bzero(v43, v40);
  *(_QWORD *)(v8 + 9480) = v44;
  v45 = (char *)operator new(260 * v30);
  *(_QWORD *)(v8 + 9496) = v45;
  v46 = &v45[260 * v30];
  *(_QWORD *)(v8 + 9512) = v46;
  bzero(v45, v40);
  *(_QWORD *)(v8 + 9504) = v46;
  v47 = (char *)operator new(260 * v30);
  *(_QWORD *)(v8 + 9520) = v47;
  v48 = &v47[260 * v30];
  *(_QWORD *)(v8 + 9536) = v48;
  bzero(v47, v40);
  *(_QWORD *)(v8 + 9528) = v48;
  *(_QWORD *)(v8 + 9544) = 0;
  *(_QWORD *)(v8 + 9560) = 0;
  *(_QWORD *)(v8 + 9552) = 0;
  if (v30 >= 0x7E07E07E07E07FLL)
    goto LABEL_16;
  v49 = (char *)operator new(520 * v30);
  *(_QWORD *)(v8 + 9544) = v49;
  v50 = &v49[520 * v30];
  *(_QWORD *)(v8 + 9560) = v50;
  v51 = 520 * ((520 * v30 - 520) / 0x208) + 520;
  bzero(v49, v51);
  *(_QWORD *)(v8 + 9552) = v50;
  v52 = (char *)operator new(520 * v30);
  *(_QWORD *)(v8 + 9568) = v52;
  v53 = &v52[520 * v30];
  *(_QWORD *)(v8 + 9584) = v53;
  bzero(v52, v51);
  *(_QWORD *)(v8 + 9576) = v53;
  v54 = (char *)operator new(520 * v30);
  *(_QWORD *)(v8 + 9592) = v54;
  v55 = &v54[520 * v30];
  *(_QWORD *)(v8 + 9608) = v55;
  bzero(v54, v51);
  *(_QWORD *)(v8 + 9600) = v55;
  v56 = (char *)operator new(520 * v30);
  *(_QWORD *)(v8 + 9616) = v56;
  v57 = &v56[520 * v30];
  *(_QWORD *)(v8 + 9632) = v57;
  bzero(v56, v51);
  *(_QWORD *)(v8 + 9624) = v57;
  *(_QWORD *)(v8 + 9640) = 0;
  *(_QWORD *)(v8 + 9656) = 0;
  *(_QWORD *)(v8 + 9648) = 0;
  if (v30 >= 0x1F53B3A3FA204FLL)
LABEL_16:
    abort();
  v58 = 2092 * v30;
  v59 = (char *)operator new(2092 * v30);
  *(_QWORD *)(v8 + 9640) = v59;
  *(_QWORD *)(v8 + 9656) = &v59[2092 * v30];
  v60 = v59 + 2064;
  do
  {
    *(_QWORD *)v60 = 0;
    *((_QWORD *)v60 + 1) = 0;
    *((_DWORD *)v60 + 6) = 0;
    *((_QWORD *)v60 + 2) = 0;
    v60 += 2092;
    v58 -= 2092;
  }
  while (v58);
  *(_QWORD *)(v8 + 9648) = &v59[2092 * v30];
  return v8;
}

void webrtc::`anonymous namespace'::EchoRemoverImpl::~EchoRemoverImpl(webrtc::_anonymous_namespace_::EchoRemoverImpl *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;

  v2 = (void *)*((_QWORD *)this + 1205);
  if (v2)
  {
    *((_QWORD *)this + 1206) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 1202);
  if (v3)
  {
    *((_QWORD *)this + 1203) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 1199);
  if (v4)
  {
    *((_QWORD *)this + 1200) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 1196);
  if (v5)
  {
    *((_QWORD *)this + 1197) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 1193);
  if (v6)
  {
    *((_QWORD *)this + 1194) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 1190);
  if (v7)
  {
    *((_QWORD *)this + 1191) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 1187);
  if (v8)
  {
    *((_QWORD *)this + 1188) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 1184);
  if (v9)
  {
    *((_QWORD *)this + 1185) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 1181);
  if (v10)
  {
    *((_QWORD *)this + 1182) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 1178);
  if (v11)
  {
    *((_QWORD *)this + 1179) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 1175);
  if (v12)
  {
    *((_QWORD *)this + 1176) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)this + 1170);
  if (v13)
  {
    *((_QWORD *)this + 1171) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 1167);
  if (v14)
  {
    *((_QWORD *)this + 1168) = v14;
    operator delete(v14);
  }
  webrtc::AecState::~AecState((webrtc::_anonymous_namespace_::EchoRemoverImpl *)((char *)this + 6216));
  v15 = *((_QWORD *)this + 530);
  if (v15)
  {
    v16 = *((_QWORD *)this + 531);
    v17 = (void *)*((_QWORD *)this + 530);
    if (v16 != v15)
    {
      v18 = *((_QWORD *)this + 531);
      do
      {
        v20 = *(void **)(v18 - 24);
        v18 -= 24;
        v19 = v20;
        if (v20)
        {
          *(_QWORD *)(v16 - 16) = v19;
          operator delete(v19);
        }
        v16 = v18;
      }
      while (v18 != v15);
      v17 = (void *)*((_QWORD *)this + 530);
    }
    *((_QWORD *)this + 531) = v15;
    operator delete(v17);
  }
  v21 = (void *)*((_QWORD *)this + 523);
  if (v21)
  {
    *((_QWORD *)this + 524) = v21;
    operator delete(v21);
  }
  v22 = (void *)*((_QWORD *)this + 520);
  if (v22)
  {
    *((_QWORD *)this + 521) = v22;
    operator delete(v22);
  }
  v23 = *((_QWORD *)this + 519);
  *((_QWORD *)this + 519) = 0;
  if (v23)
  {
    v24 = *(void **)v23;
    if (*(_QWORD *)v23)
    {
      *(_QWORD *)(v23 + 8) = v24;
      operator delete(v24);
    }
    MEMORY[0x20BD0ADEC](v23, 0x20C40960023A9);
  }
  webrtc::SuppressionGain::~SuppressionGain((webrtc::_anonymous_namespace_::EchoRemoverImpl *)((char *)this + 1552));
  webrtc::Subtractor::~Subtractor((webrtc::_anonymous_namespace_::EchoRemoverImpl *)((char *)this + 664));
  v25 = *((_QWORD *)this + 78);
  *((_QWORD *)this + 78) = 0;
  if (v25)
    MEMORY[0x20BD0ADEC](v25, 0xC400A2AC0F1);
}

{
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::`anonymous namespace'::EchoRemoverImpl::GetMetrics(uint64_t a1, double *a2)
{
  float *v4;
  uint64_t v5;
  float v6;
  unint64_t v7;
  unint64_t v8;
  float *v9;
  float v10;
  float v11;
  float v12;

  *a2 = log10f(*(float *)(a1 + 7544)) * -10.0;
  v4 = *(float **)(a1 + 7600);
  v5 = *(_QWORD *)(a1 + 7608) - (_QWORD)v4;
  if (v5)
  {
    v6 = *v4;
    if ((unint64_t)v5 >= 5)
    {
      v7 = v5 >> 2;
      if (v7 <= 2)
        v7 = 2;
      v8 = v7 - 1;
      v9 = v4 + 1;
      do
      {
        v10 = *v9++;
        v11 = v10;
        if (v10 < v6)
          v6 = v11;
        --v8;
      }
      while (v8);
    }
    v12 = v6 * 3.01029996;
    a2[1] = v12;
  }
  else
  {
    __break(1u);
  }
}

void webrtc::`anonymous namespace'::EchoRemoverImpl::ProcessCapture(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  char *v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  char *v27;
  _BYTE *v28;
  int v29;
  int v30;
  BOOL v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t *v36;
  uint64_t *v37;
  uint64_t *v38;
  char *v39;
  float *v40;
  float v41;
  float v42;
  float v43;
  BOOL v44;
  float *v45;
  BOOL v46;
  char v47;
  char *v48;
  float *v49;
  float *v50;
  float *v51;
  float32x4_t *v52;
  char *v53;
  float *v54;
  float32x4_t *v56;
  size_t v57;
  char *v58;
  float *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  float32x4_t *v63;
  float32x4_t *v64;
  float32x4_t *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  float32x4_t *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  float32x4_t *v73;
  float32x4_t *v74;
  BOOL v76;
  float32x4_t *v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  uint64_t *v111;
  char *v112;
  unint64_t v113;
  uint64_t v114;
  float v115;
  float32x4_t *v116;
  uint64_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  uint64_t v126;
  float v127;
  float32x4_t *v128;
  uint64_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  uint64_t v138;
  float v139;
  unint64_t v140;
  int v141;
  unint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t *v145;
  uint64_t v146;
  _QWORD *v147;
  uint64_t v148;
  char *v149;
  uint64_t v150;
  _BOOL4 v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  int v156;
  __n128 v157;
  float32x4_t v158;
  float32x4_t v159;
  uint64_t v160;
  char *v161;
  uint64_t v162;
  char *v163;
  char *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t *v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  float32x4_t *v177;
  char *v178;
  uint64_t v179;
  unint64_t v180;
  char *v181;
  int8x16_t v183;
  int8x16_t v184;
  int8x16_t v185;
  int8x16_t v186;
  int8x16_t v187;
  int8x16_t v188;
  int8x16_t v189;
  int8x16_t v190;
  int8x16_t v191;
  int8x16_t v192;
  uint64_t v193;
  uint64_t v194;
  float v195;
  float v196;
  float v197;
  char v198;
  uint64_t v199;
  _QWORD *v200;
  uint64_t v201;
  int32x2_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  unint64_t v208;
  char *v209;
  char *v210;
  uint64_t v211;
  unint64_t v212;
  uint64_t v213;
  uint64_t *v214;
  uint64_t *v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t *v218;
  float32x4_t *v219;
  uint64_t *__src;
  _BYTE *v221;
  webrtc::OouraFft *v222;
  unsigned int *v223;
  uint64_t v224;
  uint64_t *v225;
  char *v226;
  char *v227;
  uint64_t *v228;
  uint64_t *v229;
  char *v230;
  unint64_t v231;
  char *v232;
  uint64_t v233;
  char *v234;
  uint64_t v235;
  uint64_t v236;
  unint64_t v237;
  uint64_t *v238;
  __int32 v239;
  float32x4_t v240;
  int v241;
  char v242;
  __int128 v243;
  uint64_t v244;
  int v245;
  uint64_t v246;
  __int128 v247;
  int v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  unint64_t v259;
  int v260;

  v2 = MEMORY[0x24BDAC7A8](a1, a2);
  v259 = v3;
  v260 = v9;
  ++*(_QWORD *)(v2 + 9384);
  v10 = (**(_DWORD **)v6 + *(_DWORD *)(*(_QWORD *)v6 + 36)) % **(_DWORD **)v6;
  v11 = *(_QWORD *)(*(_QWORD *)v6 + 8);
  if (v10 >= (*(_QWORD *)(*(_QWORD *)v6 + 16) - v11) >> 5)
    goto LABEL_182;
  v12 = v8;
  v13 = v7;
  v14 = (uint64_t *)v6;
  v15 = v2;
  v16 = *(_QWORD *)(v2 + 648);
  v245 = 0;
  if (v16)
    v17 = &v258;
  else
    v17 = 0;
  v244 = 0;
  if (v16)
    v18 = (char *)&v257;
  else
    v18 = 0;
  if (v16)
    v19 = &v256;
  else
    v19 = 0;
  v243 = 0uLL;
  if (v16)
    v20 = (char *)&v255;
  else
    v20 = 0;
  v246 = 0;
  v21 = (char *)&v254;
  if (!v16)
    v21 = 0;
  v247 = 0uLL;
  v22 = &v253;
  if (!v16)
    v22 = 0;
  v229 = v22;
  v248 = 0;
  if (v16)
    v23 = &v252;
  else
    v23 = 0;
  v24 = &v251;
  if (!v16)
    v24 = 0;
  v228 = v24;
  if (v16)
    v25 = &v250;
  else
    v25 = 0;
  if (v16)
    v26 = &v249;
  else
    v26 = 0;
  if (v16)
    v27 = &v242;
  else
    v27 = 0;
  if (v16 >= 3)
  {
    v17 = *(uint64_t **)(v15 + 9400);
    v18 = *(char **)(v15 + 9424);
    v19 = *(uint64_t **)(v15 + 9448);
    v20 = *(char **)(v15 + 9472);
    v21 = *(char **)(v15 + 9496);
    v23 = *(uint64_t **)(v15 + 9544);
    v228 = *(uint64_t **)(v15 + 9568);
    v229 = *(uint64_t **)(v15 + 9520);
    v25 = *(uint64_t **)(v15 + 9592);
    v26 = *(uint64_t **)(v15 + 9616);
    v27 = *(char **)(v15 + 9640);
  }
  if (*(_QWORD *)(v8 + 16) == *(_QWORD *)(v8 + 8)
    || *(_QWORD *)(v11 + 32 * v10 + 16) == *(_QWORD *)(v11 + 32 * v10 + 8))
  {
    goto LABEL_182;
  }
  v226 = v18;
  v227 = v27;
  v28 = (_BYTE *)(v15 + 6209);
  *(_BYTE *)(v15 + 8216) = v4;
  v225 = v19;
  v211 = v11;
  v212 = v10;
  v209 = v21;
  v210 = v20;
  v217 = v5;
  v214 = v26;
  v215 = v25;
  if ((_BYTE)v3)
  {
    if (*(_DWORD *)(v15 + 9392))
    {
      LOBYTE(v259) = 0;
    }
    else
    {
      *(_DWORD *)(v15 + 9392) = 3;
      v29 = 2 * *(unsigned __int8 *)(v15 + 93);
        || (rtc::LogMessage::streams_empty_ & 1) == 0)
      {
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long> const&)::t, v3, (uint64_t)v27, v4, v5, v6, v7, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_processing/aec3/echo_remover.cc");
      }
    }
  }
  else if (!HIDWORD(v3))
  {
    goto LABEL_47;
  }
  webrtc::Subtractor::HandleEchoPathChange((_QWORD *)(v15 + 664), (unsigned __int8 *)&v259);
  webrtc::AecState::HandleEchoPathChange(v15 + 6216, (uint64_t)&v259);
  if (HIDWORD(v259))
  {
    *(_BYTE *)(v15 + 2500) = 1;
    *(_DWORD *)(v15 + 2504) = *(_DWORD *)(v15 + 2184);
  }
LABEL_47:
  v30 = *(_DWORD *)(v15 + 9392);
  v31 = __OFSUB__(v30, 1);
  v32 = v30 - 1;
  if (v32 < 0 == v31)
    *(_DWORD *)(v15 + 9392) = v32;
  v240.i64[0] = *(int *)(v15 + 6904);
  v240.i8[8] = 1;
  webrtc::RenderSignalAnalyzer::Update((int *)(v15 + 4264), v14, (int *)&v240);
  if (*(_BYTE *)(v15 + 6856))
  {
    webrtc::Subtractor::ExitInitialState(v15 + 664);
    *(_BYTE *)(v15 + 2500) = 0;
    *(_DWORD *)(v15 + 2504) = 0;
  }
  if (v16)
    v33 = (uint64_t)v227;
  else
    v33 = 0;
  v213 = v15 + 4264;
  v219 = (float32x4_t *)(v15 + 6216);
  v216 = v33;
  webrtc::Subtractor::Process(v15 + 664, (uint64_t)v14, v12, (_QWORD *)(v15 + 4264), v15 + 6216, v33);
  v223 = (unsigned int *)v12;
  v224 = v15;
  v218 = v14;
  if (*(_QWORD *)(v15 + 648))
  {
    v207 = v13;
    v208 = v16;
    v35 = 0;
    v221 = (_BYTE *)(v15 + 6209);
    v222 = (webrtc::OouraFft *)(v15 + 616);
    v36 = v228;
    v37 = v229;
    v38 = v23;
    v39 = v227;
    __src = v17;
    while (*(_BYTE *)(v15 + 656))
    {
      v40 = (float *)&v39[2092 * v35];
      v41 = v40[519];
      v42 = v40[518];
      v43 = v40[520];
      v44 = v41 >= (float)(v42 * 0.9) || v43 <= 57600.0;
      if (v44
        || ((v45 = (float *)&v39[2092 * v35], v45[516] <= 230400.0) ? (v46 = v45[517] <= 230400.0) : (v46 = 0), v46))
      {
        v53 = &v39[2092 * v35];
        v50 = (float *)(v53 + 512);
        v54 = (float *)(v53 + 768);
        if (v28[3187])
          v51 = v50;
        else
          v51 = v54;
        if (v43 < v42 && v41 < v42)
        {
          v47 = 0;
          v50 = v54;
          v237 = v35;
          v52 = (float32x4_t *)&v17[32 * v35];
          if (v51 == v54)
            goto LABEL_79;
          goto LABEL_84;
        }
        goto LABEL_83;
      }
      v47 = 0;
      v48 = &v39[2092 * v35];
      v49 = (float *)(v48 + 512);
      v50 = (float *)(v48 + 768);
      if (v28[3187])
        v51 = v49;
      else
        v51 = v50;
      v237 = v35;
      v52 = (float32x4_t *)&v17[32 * v35];
      if (v51 == v50)
      {
LABEL_79:
        v56 = v52;
        v57 = 256;
        goto LABEL_85;
      }
LABEL_84:
      v52->f32[0] = (float)(*v51 * 0.96774) + (float)(*v50 * 0.032258);
      v52->f32[1] = (float)(v51[1] * 0.93548) + (float)(v50[1] * 0.064516);
      v52->f32[2] = (float)(v51[2] * 0.90323) + (float)(v50[2] * 0.096774);
      v52->f32[3] = (float)(v51[3] * 0.87097) + (float)(v50[3] * 0.12903);
      v52[1].f32[0] = (float)(v51[4] * 0.83871) + (float)(v50[4] * 0.16129);
      v52[1].f32[1] = (float)(v51[5] * 0.80645) + (float)(v50[5] * 0.19355);
      v52[1].f32[2] = (float)(v51[6] * 0.77419) + (float)(v50[6] * 0.22581);
      v52[1].f32[3] = (float)(v51[7] * 0.74194) + (float)(v50[7] * 0.25806);
      v52[2].f32[0] = (float)(v51[8] * 0.70968) + (float)(v50[8] * 0.29032);
      v52[2].f32[1] = (float)(v51[9] * 0.67742) + (float)(v50[9] * 0.32258);
      v52[2].f32[2] = (float)(v51[10] * 0.64516) + (float)(v50[10] * 0.35484);
      v52[2].f32[3] = (float)(v51[11] * 0.6129) + (float)(v50[11] * 0.3871);
      v52[3].f32[0] = (float)(v51[12] * 0.58065) + (float)(v50[12] * 0.41935);
      v52[3].f32[1] = (float)(v51[13] * 0.54839) + (float)(v50[13] * 0.45161);
      v52[3].f32[2] = (float)(v51[14] * 0.51613) + (float)(v50[14] * 0.48387);
      v52[3].f32[3] = (float)(v51[15] * 0.48387) + (float)(v50[15] * 0.51613);
      v52[4].f32[0] = (float)(v51[16] * 0.45161) + (float)(v50[16] * 0.54839);
      v52[4].f32[1] = (float)(v51[17] * 0.41935) + (float)(v50[17] * 0.58065);
      v52[4].f32[2] = (float)(v51[18] * 0.3871) + (float)(v50[18] * 0.6129);
      v52[4].f32[3] = (float)(v51[19] * 0.35484) + (float)(v50[19] * 0.64516);
      v52[5].f32[0] = (float)(v51[20] * 0.32258) + (float)(v50[20] * 0.67742);
      v52[5].f32[1] = (float)(v51[21] * 0.29032) + (float)(v50[21] * 0.70968);
      v52[5].f32[2] = (float)(v51[22] * 0.25806) + (float)(v50[22] * 0.74194);
      v52[5].f32[3] = (float)(v51[23] * 0.22581) + (float)(v50[23] * 0.77419);
      v52[6].f32[0] = (float)(v51[24] * 0.19355) + (float)(v50[24] * 0.80645);
      v52[6].f32[1] = (float)(v51[25] * 0.16129) + (float)(v50[25] * 0.83871);
      v52[6].f32[2] = (float)(v51[26] * 0.12903) + (float)(v50[26] * 0.87097);
      v52[6].f32[3] = (float)(v51[27] * 0.096774) + (float)(v50[27] * 0.90323);
      v52[7].f32[0] = (float)(v51[28] * 0.064516) + (float)(v50[28] * 0.93548);
      v52[7].f32[1] = (float)(v51[29] * 0.032258) + (float)(v50[29] * 0.96774);
      v51 = v50 + 30;
      v56 = (float32x4_t *)((char *)v52 + 120);
      v57 = 136;
LABEL_85:
      memmove(v56, v51, v57);
      v28[3187] = v47;
      v60 = (int)((_DWORD)v237 << 6);
      v61 = *(_QWORD *)(v12 + 8);
      if (v60 >= (*(_QWORD *)(v12 + 16) - v61) >> 2)
        goto LABEL_182;
      v62 = *(_QWORD *)(v15 + 9360);
      if (v237 >= (*(_QWORD *)(v15 + 9368) - v62) >> 8)
        goto LABEL_182;
      v63 = (float32x4_t *)(v61 + 4 * v60);
      v64 = (float32x4_t *)&v23[65 * v237];
      v65 = (float32x4_t *)(v62 + (v237 << 8));
      webrtc::Aec3Fft::PaddedFft(v222, v63, 64, v65, 64, 2, (uint64_t)v64);
      memmove(v65, v63, 0x100uLL);
      v66 = *(_QWORD *)(v15 + 9336);
      if (v237 >= (*(_QWORD *)(v15 + 9344) - v66) >> 8)
        goto LABEL_182;
      v235 = 260 * v237;
      v232 = (char *)v229 + 260 * v237;
      v233 = 260 * v237 + 260;
      v67 = (unint64_t)v229 + v233;
      v68 = 520 * v237 + 520;
      v230 = (char *)v23 + v68;
      v231 = (unint64_t)v228 + v68;
      v69 = (float32x4_t *)(v66 + (v237 << 8));
      v70 = 65 * v237;
      v71 = (uint64_t)&v228[65 * v237];
      webrtc::Aec3Fft::PaddedFft(v222, v52, 64, v69, 64, 2, v71);
      memmove(v69, v52, 0x100uLL);
      v34 = (unint64_t)&v23[65 * v237];
      v72 = 0;
      v73 = (float32x4_t *)(v34 + 260);
      v74 = (float32x4_t *)(v71 + 260);
      v76 = (unint64_t)v232 < v231 && (unint64_t)&v228[65 * v237] < v67;
      if ((unint64_t)&v23[65 * v237] >= v67 || v232 >= v230)
      {
        v12 = (uint64_t)v223;
        v111 = v225;
        v112 = v226;
        v28 = v221;
        v39 = v227;
        v113 = v237;
        if (!v76)
        {
          v78 = (float32x4_t *)((char *)v229 + 260 * v237);
          v79 = vsubq_f32(*v64, *(float32x4_t *)v71);
          v80 = vsubq_f32(v64[1], *(float32x4_t *)(v71 + 16));
          v81 = vsubq_f32(*v73, *v74);
          v82 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 34] + 4), *(float32x4_t *)(v71 + 276));
          *v78 = vmlaq_f32(vmulq_f32(v81, v81), v79, v79);
          v78[1] = vmlaq_f32(vmulq_f32(v82, v82), v80, v80);
          v83 = vsubq_f32(v64[2], *(float32x4_t *)(v71 + 32));
          v84 = vsubq_f32(v64[3], *(float32x4_t *)(v71 + 48));
          v85 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 36] + 4), *(float32x4_t *)(v71 + 292));
          v86 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 38] + 4), *(float32x4_t *)(v71 + 308));
          v78[2] = vmlaq_f32(vmulq_f32(v85, v85), v83, v83);
          v78[3] = vmlaq_f32(vmulq_f32(v86, v86), v84, v84);
          v87 = vsubq_f32(v64[4], *(float32x4_t *)(v71 + 64));
          v88 = vsubq_f32(v64[5], *(float32x4_t *)(v71 + 80));
          v89 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 40] + 4), *(float32x4_t *)(v71 + 324));
          v90 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 42] + 4), *(float32x4_t *)(v71 + 340));
          v78[4] = vmlaq_f32(vmulq_f32(v89, v89), v87, v87);
          v78[5] = vmlaq_f32(vmulq_f32(v90, v90), v88, v88);
          v91 = vsubq_f32(v64[6], *(float32x4_t *)(v71 + 96));
          v92 = vsubq_f32(v64[7], *(float32x4_t *)(v71 + 112));
          v93 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 44] + 4), *(float32x4_t *)(v71 + 356));
          v94 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 46] + 4), *(float32x4_t *)(v71 + 372));
          v78[6] = vmlaq_f32(vmulq_f32(v93, v93), v91, v91);
          v78[7] = vmlaq_f32(vmulq_f32(v94, v94), v92, v92);
          v95 = vsubq_f32(v64[8], *(float32x4_t *)(v71 + 128));
          v96 = vsubq_f32(v64[9], *(float32x4_t *)(v71 + 144));
          v97 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 48] + 4), *(float32x4_t *)(v71 + 388));
          v98 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 50] + 4), *(float32x4_t *)(v71 + 404));
          v78[8] = vmlaq_f32(vmulq_f32(v97, v97), v95, v95);
          v78[9] = vmlaq_f32(vmulq_f32(v98, v98), v96, v96);
          v99 = vsubq_f32(v64[10], *(float32x4_t *)(v71 + 160));
          v100 = vsubq_f32(v64[11], *(float32x4_t *)(v71 + 176));
          v101 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 52] + 4), *(float32x4_t *)(v71 + 420));
          v102 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 54] + 4), *(float32x4_t *)(v71 + 436));
          v78[10] = vmlaq_f32(vmulq_f32(v101, v101), v99, v99);
          v78[11] = vmlaq_f32(vmulq_f32(v102, v102), v100, v100);
          v103 = vsubq_f32(v64[12], *(float32x4_t *)(v71 + 192));
          v104 = vsubq_f32(v64[13], *(float32x4_t *)(v71 + 208));
          v105 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 56] + 4), *(float32x4_t *)(v71 + 452));
          v106 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 58] + 4), *(float32x4_t *)(v71 + 468));
          v78[12] = vmlaq_f32(vmulq_f32(v105, v105), v103, v103);
          v78[13] = vmlaq_f32(vmulq_f32(v106, v106), v104, v104);
          v107 = vsubq_f32(v64[14], *(float32x4_t *)(v71 + 224));
          v108 = vsubq_f32(v64[15], *(float32x4_t *)(v71 + 240));
          v109 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 60] + 4), *(float32x4_t *)(v71 + 484));
          v110 = vsubq_f32(*(float32x4_t *)((char *)&v23[v70 + 62] + 4), *(float32x4_t *)(v71 + 500));
          v78[14] = vmlaq_f32(vmulq_f32(v109, v109), v107, v107);
          v78[15] = vmlaq_f32(vmulq_f32(v110, v110), v108, v108);
          v72 = 64;
        }
      }
      else
      {
        v12 = (uint64_t)v223;
        v111 = v225;
        v112 = v226;
        v28 = v221;
        v39 = v227;
        v113 = v237;
      }
      v114 = 4 * v72;
      v15 = v224;
      do
      {
        v115 = *(float *)((char *)v38 + v114) - *(float *)((char *)v36 + v114);
        *(float *)((char *)v37 + v114) = (float)((float)(*(float *)((char *)v38 + v114 + 260)
                                                       - *(float *)((char *)v36 + v114 + 260))
                                               * (float)(*(float *)((char *)v38 + v114 + 260)
                                                       - *(float *)((char *)v36 + v114 + 260)))
                                       + (float)(v115 * v115);
        v114 += 4;
      }
      while (v114 != 260);
      v116 = (float32x4_t *)&v112[260 * v113];
      if (&v112[v235] >= v230 || v34 >= (unint64_t)&v112[v233])
      {
        v118 = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 34] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 34] + 4)), v64[1], v64[1]);
        *v116 = vmlaq_f32(vmulq_f32(*v73, *v73), *v64, *v64);
        v116[1] = v118;
        v119 = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 38] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 38] + 4)), v64[3], v64[3]);
        v116[2] = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 36] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 36] + 4)), v64[2], v64[2]);
        v116[3] = v119;
        v120 = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 42] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 42] + 4)), v64[5], v64[5]);
        v116[4] = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 40] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 40] + 4)), v64[4], v64[4]);
        v116[5] = v120;
        v121 = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 46] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 46] + 4)), v64[7], v64[7]);
        v116[6] = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 44] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 44] + 4)), v64[6], v64[6]);
        v116[7] = v121;
        v122 = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 50] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 50] + 4)), v64[9], v64[9]);
        v116[8] = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 48] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 48] + 4)), v64[8], v64[8]);
        v116[9] = v122;
        v123 = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 54] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 54] + 4)), v64[11], v64[11]);
        v116[10] = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 52] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 52] + 4)), v64[10], v64[10]);
        v116[11] = v123;
        v124 = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 58] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 58] + 4)), v64[13], v64[13]);
        v116[12] = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 56] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 56] + 4)), v64[12], v64[12]);
        v116[13] = v124;
        v73 = (float32x4_t *)((char *)&v23[65 * v237 + 64] + 4);
        v125 = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 62] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 62] + 4)), v64[15], v64[15]);
        v116[14] = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)&v23[65 * v237 + 60] + 4), *(float32x4_t *)((char *)&v23[65 * v237 + 60] + 4)), v64[14], v64[14]);
        v116[15] = v125;
        v116 += 16;
        v117 = 64;
      }
      else
      {
        v117 = 0;
      }
      v17 = __src;
      v126 = 4 * v117;
      do
      {
        v127 = v73->f32[0];
        v73 = (float32x4_t *)((char *)v73 + 4);
        v116->f32[0] = (float)(v127 * v127) + (float)(*(float *)((char *)v38 + v126) * *(float *)((char *)v38 + v126));
        v116 = (float32x4_t *)((char *)v116 + 4);
        v126 += 4;
      }
      while (v126 != 260);
      v128 = (float32x4_t *)((char *)v111 + 260 * v113);
      if ((unint64_t)v111 + v235 >= v231 || &v228[65 * v237] >= (uint64_t *)((char *)v111 + v233))
      {
        v130 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 276), *(float32x4_t *)(v71 + 276)), *(float32x4_t *)(v71 + 16), *(float32x4_t *)(v71 + 16));
        *v128 = vmlaq_f32(vmulq_f32(*v74, *v74), *(float32x4_t *)v71, *(float32x4_t *)v71);
        v128[1] = v130;
        v131 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 308), *(float32x4_t *)(v71 + 308)), *(float32x4_t *)(v71 + 48), *(float32x4_t *)(v71 + 48));
        v128[2] = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 292), *(float32x4_t *)(v71 + 292)), *(float32x4_t *)(v71 + 32), *(float32x4_t *)(v71 + 32));
        v128[3] = v131;
        v132 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 340), *(float32x4_t *)(v71 + 340)), *(float32x4_t *)(v71 + 80), *(float32x4_t *)(v71 + 80));
        v128[4] = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 324), *(float32x4_t *)(v71 + 324)), *(float32x4_t *)(v71 + 64), *(float32x4_t *)(v71 + 64));
        v128[5] = v132;
        v133 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 372), *(float32x4_t *)(v71 + 372)), *(float32x4_t *)(v71 + 112), *(float32x4_t *)(v71 + 112));
        v128[6] = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 356), *(float32x4_t *)(v71 + 356)), *(float32x4_t *)(v71 + 96), *(float32x4_t *)(v71 + 96));
        v128[7] = v133;
        v134 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 404), *(float32x4_t *)(v71 + 404)), *(float32x4_t *)(v71 + 144), *(float32x4_t *)(v71 + 144));
        v128[8] = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 388), *(float32x4_t *)(v71 + 388)), *(float32x4_t *)(v71 + 128), *(float32x4_t *)(v71 + 128));
        v128[9] = v134;
        v135 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 436), *(float32x4_t *)(v71 + 436)), *(float32x4_t *)(v71 + 176), *(float32x4_t *)(v71 + 176));
        v128[10] = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 420), *(float32x4_t *)(v71 + 420)), *(float32x4_t *)(v71 + 160), *(float32x4_t *)(v71 + 160));
        v128[11] = v135;
        v136 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 468), *(float32x4_t *)(v71 + 468)), *(float32x4_t *)(v71 + 208), *(float32x4_t *)(v71 + 208));
        v128[12] = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 452), *(float32x4_t *)(v71 + 452)), *(float32x4_t *)(v71 + 192), *(float32x4_t *)(v71 + 192));
        v128[13] = v136;
        v74 = (float32x4_t *)(v71 + 516);
        v137 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 500), *(float32x4_t *)(v71 + 500)), *(float32x4_t *)(v71 + 240), *(float32x4_t *)(v71 + 240));
        v128[14] = vmlaq_f32(vmulq_f32(*(float32x4_t *)(v71 + 484), *(float32x4_t *)(v71 + 484)), *(float32x4_t *)(v71 + 224), *(float32x4_t *)(v71 + 224));
        v128[15] = v137;
        v128 += 16;
        v129 = 64;
      }
      else
      {
        v129 = 0;
      }
      v138 = 4 * v129;
      do
      {
        v139 = v74->f32[0];
        v74 = (float32x4_t *)((char *)v74 + 4);
        v128->f32[0] = (float)(v139 * v139) + (float)(*(float *)((char *)v36 + v138) * *(float *)((char *)v36 + v138));
        v128 = (float32x4_t *)((char *)v128 + 4);
        v138 += 4;
      }
      while (v138 != 260);
      v35 = v113 + 1;
      v140 = *(_QWORD *)(v224 + 648);
      v37 = (uint64_t *)((char *)v37 + 260);
      v38 += 65;
      v36 += 65;
      if (v35 >= v140)
      {
        v14 = v218;
        v16 = v208;
        if (v207 && v140)
        {
          v141 = 0;
          v142 = 0;
          do
          {
            memmove((void *)(*(_QWORD *)(v207 + 8) + 4 * v141), v17, 0x100uLL);
            ++v142;
            v141 += 64;
            v17 += 32;
          }
          while (v142 < *(_QWORD *)(v224 + 648));
        }
        goto LABEL_120;
      }
    }
    v58 = &v39[2092 * v35];
    v50 = (float *)(v58 + 512);
    v59 = (float *)(v58 + 768);
    if (v28[3187])
      v51 = v50;
    else
      v51 = v59;
LABEL_83:
    v47 = 1;
    v237 = v35;
    v52 = (float32x4_t *)&v17[32 * v35];
    if (v51 == v50)
      goto LABEL_79;
    goto LABEL_84;
  }
LABEL_120:
  v143 = *(_QWORD *)(v15 + 1488) - *(_QWORD *)(v15 + 1480);
  v144 = 0xAAAAAAAAAAAAAAABLL * (v143 >> 3);
  if (v143)
    v145 = *(uint64_t **)(v15 + 1480);
  else
    v145 = 0;
  v146 = *(_QWORD *)(v15 + 1512) - *(_QWORD *)(v15 + 1504);
  if (v146)
    v147 = *(_QWORD **)(v15 + 1504);
  else
    v147 = 0;
  if (v16)
    v148 = (uint64_t)v225;
  else
    v148 = 0;
  if (v16)
    v149 = v226;
  else
    v149 = 0;
  v150 = (uint64_t)v219;
  webrtc::AecState::Update((uint64_t)v219, v217, v145, v144, v147, 0xAAAAAAAAAAAAAAABLL * (v146 >> 3), v14, v34, v148, v16, v149, v16, v216, v16);
  if (v28[752])
  {
    v151 = v28[249] != 0;
    if (*(_QWORD *)(v12 + 16) == *(_QWORD *)(v12 + 8))
      goto LABEL_182;
  }
  else
  {
    v151 = 0;
    if (*(_QWORD *)(v12 + 16) == *(_QWORD *)(v12 + 8))
    {
LABEL_182:
      __break(1u);
      return;
    }
  }
  v234 = (char *)v148;
  v238 = v23;
  if (v16)
    v152 = (uint64_t)v215;
  else
    v152 = 0;
  if (v16)
    v153 = (uint64_t)v214;
  else
    v153 = 0;
  v154 = v152;
  webrtc::ComfortNoiseGenerator::Compute(v15 + 4128, v28[2007], (uint64_t)v149, v16, v152, v16, v153);
  if (*v28)
  {
    v236 = v153;
    v155 = v15 + 1552;
    v156 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v15 + 4120) + 16))(*(_QWORD *)(v15 + 4120));
    if (v16)
      v160 = (uint64_t)v229;
    else
      v160 = 0;
    if (v16)
      v161 = v210;
    else
      v161 = 0;
    v162 = v16;
    v163 = v209;
    if (!v16)
      v163 = 0;
    v206 = v16;
    v164 = v163;
    v165 = (uint64_t)v14;
    v166 = v160;
    v167 = v162;
    webrtc::ResidualEchoEstimator::Estimate(v15 + 4792, (uint64_t)v219, v165, v160, v162, v149, v162, v156, v157, v158, v159, v161, v162, v163, v206);
    if (v28[752])
    {
      if (v28[249])
      {
        v169 = *(_QWORD *)(v224 + 648);
        v170 = v154;
        if (v169)
        {
          v171 = 0;
          v172 = v225;
          v173 = v15 + 1552;
          v149 = v234;
          v174 = v236;
          v175 = (uint64_t)v164;
          v176 = v166;
          do
          {
            v177 = (float32x4_t *)((char *)v225 + 260 * v171);
            v178 = &v226[260 * v171];
            v179 = 260 * v171 + 260;
            v180 = (unint64_t)&v226[v179];
            v181 = (char *)v225 + v179;
            if ((unint64_t)v177 >= v180 || v178 >= v181)
            {
              v183 = vbslq_s8((int8x16_t)vcgtq_f32(v177[1], *((float32x4_t *)v178 + 1)), *((int8x16_t *)v178 + 1), (int8x16_t)v177[1]);
              *(int8x16_t *)v177 = vbslq_s8((int8x16_t)vcgtq_f32(*v177, *(float32x4_t *)v178), *(int8x16_t *)v178, *(int8x16_t *)v177);
              v177[1] = (float32x4_t)v183;
              v184 = vbslq_s8((int8x16_t)vcgtq_f32(v177[3], *((float32x4_t *)v178 + 3)), *((int8x16_t *)v178 + 3), (int8x16_t)v177[3]);
              v177[2] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v177[2], *((float32x4_t *)v178 + 2)), *((int8x16_t *)v178 + 2), (int8x16_t)v177[2]);
              v177[3] = (float32x4_t)v184;
              v185 = vbslq_s8((int8x16_t)vcgtq_f32(v177[5], *((float32x4_t *)v178 + 5)), *((int8x16_t *)v178 + 5), (int8x16_t)v177[5]);
              v177[4] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v177[4], *((float32x4_t *)v178 + 4)), *((int8x16_t *)v178 + 4), (int8x16_t)v177[4]);
              v177[5] = (float32x4_t)v185;
              v186 = vbslq_s8((int8x16_t)vcgtq_f32(v177[7], *((float32x4_t *)v178 + 7)), *((int8x16_t *)v178 + 7), (int8x16_t)v177[7]);
              v177[6] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v177[6], *((float32x4_t *)v178 + 6)), *((int8x16_t *)v178 + 6), (int8x16_t)v177[6]);
              v177[7] = (float32x4_t)v186;
              v187 = vbslq_s8((int8x16_t)vcgtq_f32(v177[9], *((float32x4_t *)v178 + 9)), *((int8x16_t *)v178 + 9), (int8x16_t)v177[9]);
              v177[8] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v177[8], *((float32x4_t *)v178 + 8)), *((int8x16_t *)v178 + 8), (int8x16_t)v177[8]);
              v177[9] = (float32x4_t)v187;
              v188 = vbslq_s8((int8x16_t)vcgtq_f32(v177[11], *((float32x4_t *)v178 + 11)), *((int8x16_t *)v178 + 11), (int8x16_t)v177[11]);
              v177[10] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v177[10], *((float32x4_t *)v178 + 10)), *((int8x16_t *)v178 + 10), (int8x16_t)v177[10]);
              v177[11] = (float32x4_t)v188;
              v189 = vbslq_s8((int8x16_t)vcgtq_f32(v177[13], *((float32x4_t *)v178 + 13)), *((int8x16_t *)v178 + 13), (int8x16_t)v177[13]);
              v177[12] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v177[12], *((float32x4_t *)v178 + 12)), *((int8x16_t *)v178 + 12), (int8x16_t)v177[12]);
              v177[13] = (float32x4_t)v189;
              v190 = *((int8x16_t *)v178 + 14);
              v191 = *((int8x16_t *)v178 + 15);
              v178 += 256;
              v192 = vbslq_s8((int8x16_t)vcgtq_f32(v177[15], (float32x4_t)v191), v191, (int8x16_t)v177[15]);
              v177[14] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v177[14], (float32x4_t)v190), v190, (int8x16_t)v177[14]);
              v177[15] = (float32x4_t)v192;
              v177 += 16;
              v193 = 64;
            }
            else
            {
              v193 = 0;
            }
            v194 = 4 * v193;
            do
            {
              v195 = *(float *)((char *)v172 + v194);
              v196 = *(float *)v178;
              v178 += 4;
              v197 = v196;
              if (v196 < v195)
                v195 = v197;
              v177->f32[0] = v195;
              v177 = (float32x4_t *)((char *)v177 + 4);
              v194 += 4;
            }
            while (v194 != 260);
            ++v171;
            v172 = (uint64_t *)((char *)v172 + 260);
          }
          while (v171 != v169);
          v198 = (*(unsigned __int8 *)(v224 + 340) | v260) != 0;
          v199 = (uint64_t)v161;
        }
        else
        {
          v198 = (*(unsigned __int8 *)(v224 + 340) | v260) != 0;
          v173 = v15 + 1552;
          v149 = v234;
          v174 = v236;
          v199 = (uint64_t)v161;
          v175 = (uint64_t)v164;
          v176 = v166;
        }
        v239 = 0;
        v15 = v224;
      }
      else
      {
        v15 = v224;
        v198 = (*(unsigned __int8 *)(v224 + 340) | v260) != 0;
        v239 = 0;
        v199 = (uint64_t)v161;
        v176 = (uint64_t)v161;
        v170 = v154;
        v173 = v155;
        v174 = v236;
        v175 = (uint64_t)v164;
      }
    }
    else
    {
      v198 = (*(unsigned __int8 *)(v15 + 340) | v260) != 0;
      v239 = 0;
      v176 = (uint64_t)v161;
      v170 = v154;
      v173 = v15 + 1552;
      v174 = v236;
      v199 = (uint64_t)v161;
      v175 = (uint64_t)v164;
    }
    v200 = *(_QWORD **)(v15 + 4184);
    v201 = 0xFC0FC0FC0FC0FC1 * ((uint64_t)(*(_QWORD *)(v15 + 4192) - (_QWORD)v200) >> 2);
    if (*(_QWORD **)(v15 + 4192) == v200)
      v200 = 0;
    v150 = (uint64_t)v219;
    webrtc::SuppressionGain::GetGain(v173, (uint64_t)v149, v167, v176, v167, v199, v167, v168, v175, v167, v200, v201, v213, v219, (float32x4_t *)(v211 + 32 * v212), v198, (uint64_t)&v239, (uint64_t)&v240);
    v202.i32[0] = v239;
    v203 = (uint64_t)v238;
    if (v151)
      v203 = (uint64_t)v228;
    if (v167)
      v204 = v203;
    else
      v204 = 0;
    v12 = (uint64_t)v223;
    webrtc::SuppressionFilter::ApplyGain((_QWORD *)(v15 + 4216), v170, v202, v167, v174, v167, &v240, v204, v167, v223);
    v14 = v218;
  }
  else
  {
    v241 = 0;
    memset(&v240, 0, 256);
  }
  webrtc::EchoRemoverMetrics::Update(v15 + 9304, v150);
  if (*(_QWORD *)(v12 + 16) == *(_QWORD *)(v12 + 8))
    goto LABEL_182;
  v205 = v14[1];
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v205 + 16) - *(_QWORD *)(v205 + 8)) >> 3) <= (*(_DWORD *)(v205 + 36)
                                                                                                 + *(_DWORD *)(v15 + 6904)
                                                                                                 + *(_DWORD *)v205)
                                                                                                % *(_DWORD *)v205)
    goto LABEL_182;
}

uint64_t webrtc::`anonymous namespace'::EchoRemoverImpl::UpdateEchoLeakageStatus(uint64_t this, char a2)
{
  *(_BYTE *)(this + 6208) = a2;
  return this;
}

uint64_t webrtc::`anonymous namespace'::EchoRemoverImpl::SetCaptureOutputUsage(uint64_t this, char a2)
{
  *(_BYTE *)(this + 6209) = a2;
  return this;
}

unint64_t webrtc::EchoRemoverMetrics::Update(unint64_t result, uint64_t a2)
{
  unint64_t v2;
  int v3;
  float v4;
  float v5;
  float v6;
  float *v7;
  uint64_t v8;
  float v9;
  unint64_t v10;
  unint64_t v11;
  float *v12;
  float v13;
  float v14;
  float v15;
  float v16;
  uint64_t v18;
  float v19;
  float v20;
  float v21;
  uint64_t v23;
  float v24;
  float v25;
  float v26;
  uint64_t v28;
  float v29;
  float v30;
  float v31;
  uint64_t v33;
  float v34;
  float v35;
  uint64_t v37;
  float v38;
  float v39;
  uint64_t v41;
  float v42;
  float v43;

  v2 = result;
  *(_BYTE *)(result + 29) = 0;
  v3 = (*(_DWORD *)result)++;
  if (v3 <= 2496)
  {
    v4 = *(float *)(a2 + 1328);
    v5 = *(float *)(result + 8);
    v6 = *(float *)(result + 12);
    if (v5 > v4)
      v5 = *(float *)(a2 + 1328);
    *(float *)(result + 4) = v4;
    *(float *)(result + 8) = v5;
    if (v6 >= v4)
      v4 = v6;
    *(float *)(result + 12) = v4;
    v7 = *(float **)(a2 + 1384);
    v8 = *(_QWORD *)(a2 + 1392) - (_QWORD)v7;
    if (v8)
    {
      v9 = *v7;
      if ((unint64_t)v8 >= 5)
      {
        v10 = v8 >> 2;
        if (v10 <= 2)
          v10 = 2;
        v11 = v10 - 1;
        v12 = v7 + 1;
        do
        {
          v13 = *v12++;
          v14 = v13;
          if (v13 < v9)
            v9 = v14;
          --v11;
        }
        while (v11);
      }
      v15 = *(float *)(result + 20);
      v16 = *(float *)(result + 24);
      if (v15 > v9)
        v15 = v9;
      *(float *)(result + 16) = v9;
      *(float *)(result + 20) = v15;
      if (v16 >= v9)
        v9 = v16;
      *(float *)(result + 24) = v9;
      *(_BYTE *)(result + 28) = (*(unsigned __int8 *)(result + 28) | *(unsigned __int8 *)(a2 + 2000)) != 0;
    }
    else
    {
      __break(1u);
    }
    return result;
  }
  switch(v3)
  {
    case 2499:
      v18 = atomic_load(&qword_253EA55B0);
      if (v18)
      {
        v19 = (float)(log10f(*(float *)(result + 16) + 1.0e-10) * 10.0) + 0.0;
        v20 = 19.0;
        if (v19 < 19.0)
          v20 = v19;
        if (v19 > 0.0)
          v21 = v20;
        else
          v21 = 0.0;
        result = webrtc::metrics::HistogramAdd(v18, (int)v21);
      }
      else
      {
        while (!__ldaxr(&qword_253EA55B0))
        {
          if (!__stlxr(0, &qword_253EA55B0))
            goto LABEL_38;
        }
        __clrex();
      }
LABEL_38:
      v23 = atomic_load(&qword_253EA55B8);
      if (v23)
      {
        v24 = (float)(log10f(*(float *)(v2 + 24) + 1.0e-10) * 10.0) + 0.0;
        v25 = 19.0;
        if (v24 < 19.0)
          v25 = v24;
        if (v24 > 0.0)
          v26 = v25;
        else
          v26 = 0.0;
        result = webrtc::metrics::HistogramAdd(v23, (int)v26);
      }
      else
      {
        while (!__ldaxr(&qword_253EA55B8))
        {
          if (!__stlxr(0, &qword_253EA55B8))
            goto LABEL_48;
        }
        __clrex();
      }
LABEL_48:
      v28 = atomic_load(&qword_253EA55C0);
      if (v28)
      {
        v29 = (float)(log10f(*(float *)(v2 + 20) + 1.0e-10) * 10.0) + 0.0;
        v30 = 19.0;
        if (v29 < 19.0)
          v30 = v29;
        if (v29 > 0.0)
          v31 = v30;
        else
          v31 = 0.0;
        result = webrtc::metrics::HistogramAdd(v28, (int)v31);
      }
      else
      {
        while (!__ldaxr(&qword_253EA55C0))
        {
          if (!__stlxr(0, &qword_253EA55C0))
            goto LABEL_58;
        }
        __clrex();
      }
LABEL_58:
      *(_DWORD *)v2 = 0;
      *(_OWORD *)(v2 + 4) = xmmword_208F09680;
      *(_QWORD *)(v2 + 20) = 0x447A000000000000;
      *(_WORD *)(v2 + 28) = 256;
      break;
    case 2498:
      v33 = atomic_load(&qword_253EA5598);
      if (v33)
      {
        v34 = (float)(log10f(*(float *)(result + 4) + 1.0e-10) * 10.0) + 30.0;
        v35 = -v34;
        if (v34 <= -59.0)
          v35 = 59.0;
        if (v34 >= 0.0)
          v35 = 0.0;
        result = webrtc::metrics::HistogramAdd(v33, (int)v35);
      }
      else
      {
        while (!__ldaxr(&qword_253EA5598))
        {
          if (!__stlxr(0, &qword_253EA5598))
            goto LABEL_68;
        }
        __clrex();
      }
LABEL_68:
      v37 = atomic_load(&qword_253EA55A0);
      if (v37)
      {
        v38 = (float)(log10f(*(float *)(v2 + 12) + 1.0e-10) * 10.0) + 30.0;
        v39 = -v38;
        if (v38 <= -59.0)
          v39 = 59.0;
        if (v38 >= 0.0)
          v39 = 0.0;
        result = webrtc::metrics::HistogramAdd(v37, (int)v39);
      }
      else
      {
        while (!__ldaxr(&qword_253EA55A0))
        {
          if (!__stlxr(0, &qword_253EA55A0))
            goto LABEL_77;
        }
        __clrex();
      }
LABEL_77:
      v41 = atomic_load(&qword_253EA55A8);
      if (!v41)
      {
        while (!__ldaxr(&qword_253EA55A8))
        {
          if (!__stlxr(0, &qword_253EA55A8))
            return result;
        }
        goto LABEL_27;
      }
      v42 = (float)(log10f(*(float *)(v2 + 8) + 1.0e-10) * 10.0) + 30.0;
      v43 = -v42;
      if (v42 <= -59.0)
        v43 = 59.0;
      if (v42 >= 0.0)
        v43 = 0.0;
      return webrtc::metrics::HistogramAdd(v41, (int)v43);
    case 2497:
      result = atomic_load(&_MergedGlobals_9);
      if (result)
        return webrtc::metrics::HistogramAdd(result, *(_DWORD *)(a2 + 688));
      while (!__ldaxr(&_MergedGlobals_9))
      {
        if (!__stlxr(0, &_MergedGlobals_9))
          return result;
      }
LABEL_27:
      __clrex();
      return result;
    default:
      return result;
  }
  return result;
}

void webrtc::`anonymous namespace'::MediaFactoryImpl::~MediaFactoryImpl(webrtc::_anonymous_namespace_::MediaFactoryImpl *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::`anonymous namespace'::MediaFactoryImpl::CreateCall(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  webrtc::CreateCall(a1, a2);
}

_QWORD *webrtc::`anonymous namespace'::MediaFactoryImpl::CreateMediaEngine@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  void (***v6)(_QWORD);
  void (****v7)(_QWORD);
  void (****v8)(_QWORD);
  uint64_t v9;
  uint64_t v10;
  void (***v11)(_QWORD);
  void (***v12)(_QWORD);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int8x16_t v16;
  _QWORD *result;
  uint64_t v19;
  void (***v20)(_QWORD);
  void (***v21)(_QWORD);

  v5 = *(_QWORD *)(a1 + 24);
  v6 = *(void (****)(_QWORD))(a2 + 144);
  v7 = (void (****)(_QWORD))(a2 + 152);
  v8 = (void (****)(_QWORD))(a2 + 160);
  v9 = *(_QWORD *)(a1 + 8);
  v10 = operator new();
  v11 = *(void (****)(_QWORD))(a2 + 168);
  v12 = *(void (****)(_QWORD))(a2 + 176);
  v20 = v12;
  v21 = v11;
  *(_QWORD *)(a2 + 168) = 0;
  *(_QWORD *)(a2 + 176) = 0;
  v13 = *(_QWORD *)(a2 + 184);
  *(_QWORD *)(a2 + 184) = 0;
  v19 = v13;
  cricket::WebRtcVoiceEngine::WebRtcVoiceEngine(v10, v5, v6, v7, v8, &v21, &v20, &v19, v9);
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  if (v12)
    (*v12)[1](v12);
  if (v11)
    (*v11)[1](v11);
  v14 = *(_QWORD *)(a1 + 8);
  v15 = operator new();
  *(_QWORD *)v15 = &off_24C0C5C60;
  v16 = *(int8x16_t *)(a2 + 192);
  *(_QWORD *)(a2 + 192) = 0;
  *(_QWORD *)(a2 + 200) = 0;
  *(int8x16_t *)(v15 + 8) = vextq_s8(v16, v16, 8uLL);
  *(_QWORD *)(v15 + 24) = 0;
  *(_QWORD *)(v15 + 32) = v14;
  result = (_QWORD *)operator new();
  *result = &off_24C0B6A80;
  result[1] = 0;
  result[2] = v10;
  result[3] = v15;
  *a3 = result;
  return result;
}

uint64_t webrtc::EncodeUsageResource::Create@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  unsigned int *v8;
  unsigned int v9;
  _BYTE v10[24];
  pthread_mutexattr_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v4 = operator new();
  v5 = v4;
  v6 = *a1;
  *a1 = 0;
  v10[23] = 20;
  if (v10 <= "EncoderUsageResource" && &v10[20] > "EncoderUsageResource")
    __break(1u);
  strcpy(v10, "EncoderUsageResource");
  *(_QWORD *)v4 = &unk_24C0C4D88;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *(_OWORD *)(v4 + 8) = 0u;
  pthread_mutexattr_init(&v11);
  pthread_mutexattr_setpolicy_np(&v11, 3);
  pthread_mutex_init((pthread_mutex_t *)(v5 + 8), &v11);
  result = pthread_mutexattr_destroy(&v11);
  *(_OWORD *)(v5 + 72) = *(_OWORD *)v10;
  *(_QWORD *)(v5 + 88) = *(_QWORD *)&v10[16];
  *(_QWORD *)(v5 + 96) = 0;
  *(_BYTE *)(v5 + 128) = 0;
  *(_BYTE *)(v5 + 136) = 0;
  *(_BYTE *)(v5 + 144) = 0;
  *(_QWORD *)v5 = off_24C0B3938;
  *(_QWORD *)(v5 + 104) = 0;
  *(_QWORD *)(v5 + 112) = &unk_24C0B3990;
  *(_QWORD *)(v5 + 120) = v6;
  *(_DWORD *)(v5 + 152) = 0;
  v8 = (unsigned int *)(v5 + 152);
  *a2 = v5;
  do
    v9 = __ldxr(v8);
  while (__stxr(v9 + 1, v8));
  return result;
}

uint64_t webrtc::EncodeUsageResource::AdaptUp(webrtc::EncodeUsageResource *this)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  webrtc::EncodeUsageResource *v5;

  v2 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v3 = *((_QWORD *)this + 13);
  if (v3)
  {
    v5 = this;
    (**(void (***)(webrtc::EncodeUsageResource *))this)(this);
    (*(void (**)(uint64_t, webrtc::EncodeUsageResource **, uint64_t))(*(_QWORD *)v3 + 16))(v3, &v5, 1);
    if (v5)
      (*(void (**)(webrtc::EncodeUsageResource *))(*(_QWORD *)v5 + 8))(v5);
  }
  return pthread_mutex_unlock(v2);
}

uint64_t `non-virtual thunk to'webrtc::EncodeUsageResource::AdaptUp(webrtc::EncodeUsageResource *this)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  void (**v4)(char *);
  char *v6;

  v2 = (pthread_mutex_t *)((char *)this - 104);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this - 104));
  v3 = *((_QWORD *)this - 1);
  if (v3)
  {
    v4 = (void (**)(char *))*((_QWORD *)this - 14);
    v6 = (char *)this - 112;
    (*v4)((char *)this - 112);
    (*(void (**)(uint64_t, char **, uint64_t))(*(_QWORD *)v3 + 16))(v3, &v6, 1);
    if (v6)
      (*(void (**)(char *))(*(_QWORD *)v6 + 8))(v6);
  }
  return pthread_mutex_unlock(v2);
}

uint64_t webrtc::EncodeUsageResource::AdaptDown(webrtc::EncodeUsageResource *this)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  webrtc::EncodeUsageResource *v5;

  v2 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v3 = *((_QWORD *)this + 13);
  if (v3)
  {
    v5 = this;
    (**(void (***)(webrtc::EncodeUsageResource *))this)(this);
    (*(void (**)(uint64_t, webrtc::EncodeUsageResource **, _QWORD))(*(_QWORD *)v3 + 16))(v3, &v5, 0);
    if (v5)
      (*(void (**)(webrtc::EncodeUsageResource *))(*(_QWORD *)v5 + 8))(v5);
  }
  return pthread_mutex_unlock(v2);
}

uint64_t `non-virtual thunk to'webrtc::EncodeUsageResource::AdaptDown(webrtc::EncodeUsageResource *this)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  void (**v4)(char *);
  char *v6;

  v2 = (pthread_mutex_t *)((char *)this - 104);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this - 104));
  v3 = *((_QWORD *)this - 1);
  if (v3)
  {
    v4 = (void (**)(char *))*((_QWORD *)this - 14);
    v6 = (char *)this - 112;
    (*v4)((char *)this - 112);
    (*(void (**)(uint64_t, char **, _QWORD))(*(_QWORD *)v3 + 16))(v3, &v6, 0);
    if (v6)
      (*(void (**)(char *))(*(_QWORD *)v6 + 8))(v6);
  }
  return pthread_mutex_unlock(v2);
}

uint64_t rtc::RefCountedObject<webrtc::EncodeUsageResource>::AddRef(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 152);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL rtc::RefCountedObject<webrtc::EncodeUsageResource>::Release(unsigned int *a1)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = a1 + 38;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (a1 && v2 == 1)
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 24))(a1);
  return v2 != 1;
}

uint64_t rtc::RefCountedObject<webrtc::EncodeUsageResource>::~RefCountedObject(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &unk_24C0B38B8;
  v2 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(a1 + 112) = &unk_24C0B3908;
  *(_QWORD *)(a1 + 120) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *(_QWORD *)a1 = &unk_24C0C4D88;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
  return a1;
}

void rtc::RefCountedObject<webrtc::EncodeUsageResource>::~RefCountedObject(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &unk_24C0B38B8;
  v2 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(a1 + 112) = &unk_24C0B3908;
  *(_QWORD *)(a1 + 120) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *(_QWORD *)a1 = &unk_24C0C4D88;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
  JUMPOUT(0x20BD0ADECLL);
}

BOOL rtc::RefCountedObject<webrtc::EncodeUsageResource>::HasOneRef(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)(a1 + 152));
  return v1 == 1;
}

uint64_t `non-virtual thunk to'rtc::RefCountedObject<webrtc::EncodeUsageResource>::~RefCountedObject(_QWORD *a1)
{
  uint64_t v2;

  *(a1 - 14) = &unk_24C0B38B8;
  v2 = a1[1];
  *a1 = &unk_24C0B3908;
  a1[1] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *(a1 - 14) = &unk_24C0C4D88;
  if (*((char *)a1 - 17) < 0)
    operator delete((void *)*(a1 - 5));
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 - 13));
}

void `non-virtual thunk to'rtc::RefCountedObject<webrtc::EncodeUsageResource>::~RefCountedObject(_QWORD *a1)
{
  uint64_t v2;

  *(a1 - 14) = &unk_24C0B38B8;
  v2 = a1[1];
  *a1 = &unk_24C0B3908;
  a1[1] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *(a1 - 14) = &unk_24C0C4D88;
  if (*((char *)a1 - 17) < 0)
    operator delete((void *)*(a1 - 5));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 - 13));
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::EncodedFrame::delayed_by_retransmission(webrtc::EncodedFrame *this)
{
  return 0;
}

uint64_t webrtc::EncodedFrame::CopyCodecSpecific(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  unint64_t v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  int v22;
  unint64_t v23;
  unsigned __int8 *v24;

  if (a2)
  {
    switch(*(_DWORD *)(a2 + 172))
    {
      case 1:
        if (*(_QWORD *)(a2 + 1936) != 1)
          absl::variant_internal::PerformVisitation<webrtc::Attribute::has_value(void)::$_0,absl::variant<std::optional<BOOL> const*,std::optional<int> const*,std::optional<unsigned int> const*,std::optional<long long> const*,std::optional<unsigned long long> const*,std::optional<double> const*,std::optional<std::string> const*,std::optional<std::vector<BOOL>> const*,std::optional<std::vector<int>> const*,std::optional<std::vector<unsigned int>> const*,std::optional<std::vector<long long>> const*,std::optional<std::vector<unsigned long long>> const*,std::optional<std::vector<double>> const*,std::optional<std::vector<std::string>> const*,std::optional<std::map<std::string,unsigned long long>> const*,std::optional<std::map<std::string,double>> const*> const&>::Run<0ul,18446744073709551615ul>((absl::variant_internal *)result, a2, a3, a4, a5, a6, a7, a8);
        if (*(_DWORD *)(result + 400) != 1)
        {
          *(_WORD *)(result + 409) = 0;
          *(_BYTE *)(result + 411) = -1;
          *(_DWORD *)(result + 400) = 1;
        }
        *(_BYTE *)(result + 408) = *(_BYTE *)(a2 + 296);
        v8 = *(unsigned __int8 *)(a2 + 302);
        if (v8 != 255)
        {
          *(_BYTE *)(result + 409) = v8;
          *(_BYTE *)(result + 410) = *(_BYTE *)(a2 + 303);
        }
        v9 = *(_DWORD *)(a2 + 304);
        if (v9 != -1)
          *(_BYTE *)(result + 411) = v9;
        break;
      case 2:
        if (*(_QWORD *)(a2 + 1936) != 2)
          absl::variant_internal::PerformVisitation<webrtc::Attribute::has_value(void)::$_0,absl::variant<std::optional<BOOL> const*,std::optional<int> const*,std::optional<unsigned int> const*,std::optional<long long> const*,std::optional<unsigned long long> const*,std::optional<double> const*,std::optional<std::string> const*,std::optional<std::vector<BOOL>> const*,std::optional<std::vector<int>> const*,std::optional<std::vector<unsigned int>> const*,std::optional<std::vector<long long>> const*,std::optional<std::vector<unsigned long long>> const*,std::optional<std::vector<double>> const*,std::optional<std::vector<std::string>> const*,std::optional<std::map<std::string,unsigned long long>> const*,std::optional<std::map<std::string,double>> const*> const&>::Run<0ul,18446744073709551615ul>((absl::variant_internal *)result, a2, a3, a4, a5, a6, a7, a8);
        if (*(_DWORD *)(result + 400) != 2)
        {
          *(_BYTE *)(result + 413) = 0;
          *(_WORD *)(result + 415) = 0;
          *(_DWORD *)(result + 400) = 2;
        }
        *(_BYTE *)(result + 409) = *(_BYTE *)(a2 + 296);
        *(_BYTE *)(result + 410) = *(_BYTE *)(a2 + 297);
        *(_BYTE *)(result + 2024) = *(_BYTE *)(a2 + 313);
        if (*(_BYTE *)(a2 + 313))
        {
          v10 = 0;
          do
          {
            *(_BYTE *)(result + 2025 + v10) = *(_BYTE *)(a2 + 314 + v10);
            ++v10;
          }
          while (v10 < *(unsigned __int8 *)(a2 + 313));
        }
        *(_BYTE *)(result + 411) = *(_BYTE *)(a2 + 300);
        v11 = *(unsigned __int8 *)(a2 + 308);
        if (v11 != 255)
        {
          *(_BYTE *)(result + 413) = v11;
          *(_BYTE *)(result + 414) = *(_BYTE *)(a2 + 310);
        }
        if (*(unsigned __int8 *)(a2 + 309) != 255)
        {
          *(_BYTE *)(result + 415) = *(_BYTE *)(a2 + 311);
          v12 = *(unsigned __int8 *)(a2 + 309);
          *(_BYTE *)(result + 196) = 1;
          *(_DWORD *)(result + 192) = v12;
        }
        v13 = *(unsigned __int8 *)(a2 + 312);
        if (v13 != 255)
          *(_BYTE *)(result + 416) = v13;
        if (*(_BYTE *)(a2 + 300))
        {
          *(_QWORD *)(result + 424) = *(_QWORD *)(a2 + 328);
          *(_BYTE *)(result + 440) = *(_BYTE *)(a2 + 344);
          if (*(_BYTE *)(a2 + 344) && *(_QWORD *)(a2 + 328))
          {
            v14 = 0;
            do
            {
              v15 = a2 + 2 * v14;
              v16 = result + 2 * v14;
              *(_WORD *)(v16 + 442) = *(_WORD *)(v15 + 346);
              *(_WORD *)(v16 + 458) = *(_WORD *)(v15 + 362);
              ++v14;
            }
            while (v14 < *(_QWORD *)(a2 + 328));
          }
          v17 = *(_QWORD *)(a2 + 384);
          *(_QWORD *)(result + 480) = v17;
          if (v17)
          {
            v18 = 0;
            v19 = result + 1253;
            v20 = a2 + 1157;
            do
            {
              v21 = (_BYTE *)(result + v18);
              v21[488] = *(_BYTE *)(a2 + v18 + 392);
              v21[743] = *(_BYTE *)(a2 + v18 + 647);
              v22 = *(unsigned __int8 *)(a2 + v18 + 902);
              v21[998] = v22;
              if (v22)
              {
                v23 = 0;
                v24 = v21 + 998;
                do
                {
                  *(_BYTE *)(v19 + v23) = *(_BYTE *)(v20 + v23);
                  ++v23;
                }
                while (v23 < *v24);
              }
              ++v18;
              v19 += 3;
              v20 += 3;
            }
            while (v18 < *(_QWORD *)(result + 480));
          }
        }
        break;
      case 3:
        *(_DWORD *)(result + 400) = 3;
        break;
      case 4:
        *(_DWORD *)(result + 400) = 4;
        break;
      default:
        *(_DWORD *)(result + 400) = 0;
        break;
    }
  }
  return result;
}

void webrtc::EncodedFrame::~EncodedFrame(webrtc::EncodedFrame *this)
{
  *(_QWORD *)this = &off_24C0B39C0;
  if (*((_BYTE *)this + 2384))
    webrtc::FrameDependencyStructure::~FrameDependencyStructure((webrtc::EncodedFrame *)((char *)this + 2256));
  if (*((_BYTE *)this + 2248))
    webrtc::GenericFrameInfo::~GenericFrameInfo((webrtc::EncodedFrame *)((char *)this + 2040));
  webrtc::EncodedImage::~EncodedImage((webrtc::EncodedFrame *)((char *)this + 8));
}

{
  *(_QWORD *)this = &off_24C0B39C0;
  if (*((_BYTE *)this + 2384))
    webrtc::FrameDependencyStructure::~FrameDependencyStructure((webrtc::EncodedFrame *)((char *)this + 2256));
  if (*((_BYTE *)this + 2248))
    webrtc::GenericFrameInfo::~GenericFrameInfo((webrtc::EncodedFrame *)((char *)this + 2040));
  webrtc::EncodedImage::~EncodedImage((webrtc::EncodedFrame *)((char *)this + 8));
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::EncodedFrame::ReceivedTime(webrtc::EncodedFrame *this)
{
  return -1;
}

uint64_t webrtc::EncodedFrame::RenderTime(webrtc::EncodedFrame *this)
{
  return *((_QWORD *)this + 48);
}

uint64_t webrtc::EncodedImageBuffer::data(webrtc::EncodedImageBuffer *this)
{
  return *((_QWORD *)this + 2);
}

{
  return *((_QWORD *)this + 2);
}

uint64_t webrtc::EncodedImageBuffer::size(webrtc::EncodedImageBuffer *this)
{
  return *((_QWORD *)this + 1);
}

double webrtc::EncodedImage::EncodedImage(webrtc::EncodedImage *this)
{
  double result;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 4;
  *((_BYTE *)this + 32) = 0;
  *((_DWORD *)this + 9) = -1;
  *((_BYTE *)this + 40) = -1;
  *((_BYTE *)this + 128) = 0;
  *((_BYTE *)this + 160) = 0;
  *((_BYTE *)this + 168) = 0;
  *((_BYTE *)this + 176) = 0;
  *((_BYTE *)this + 184) = 0;
  *((_BYTE *)this + 188) = 0;
  *((_BYTE *)this + 192) = 0;
  *((_BYTE *)this + 196) = 0;
  *((_QWORD *)this + 27) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_BYTE *)this + 112) = 0;
  result = 0.0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = 0;
  *(_QWORD *)((char *)this + 149) = 0;
  *((_QWORD *)this + 25) = (char *)this + 208;
  *((_BYTE *)this + 224) = 0;
  *((_BYTE *)this + 292) = 0;
  *((_BYTE *)this + 296) = 0;
  *((_BYTE *)this + 298) = 0;
  *((_QWORD *)this + 38) = 0;
  *((_WORD *)this + 156) = 1;
  return result;
}

void webrtc::EncodedImage::~EncodedImage(webrtc::EncodedImage *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;

  v2 = *((_QWORD *)this + 38);
  if (v2)
  {
    do
    {
      v3 = __ldaxr((unsigned int *)v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, (unsigned int *)v2));
    if (!v4)
    {
      v5 = *(_QWORD *)(v2 + 8);
      if (v5)
      {
        v6 = *(_QWORD *)(v2 + 16);
        v7 = *(void **)(v2 + 8);
        if (v6 != v5)
        {
          do
          {
            v8 = *(void **)(v6 - 96);
            if (v8)
            {
              *(_QWORD *)(v6 - 88) = v8;
              operator delete(v8);
            }
            v6 -= 104;
          }
          while (v6 != v5);
          v7 = *(void **)(v2 + 8);
        }
        *(_QWORD *)(v2 + 16) = v5;
        operator delete(v7);
      }
      MEMORY[0x20BD0ADEC](v2, 0x1020C40E72D6CFBLL);
    }
  }
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 200, *((_QWORD **)this + 26));
  v9 = *((_QWORD *)this + 17);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
}

uint64_t rtc::RefCountedObject<webrtc::EncodedImageBuffer>::AddRef(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 24);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL rtc::RefCountedObject<webrtc::EncodedImageBuffer>::Release(unsigned int *a1)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = a1 + 6;
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (a1 && v2 == 1)
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 24))(a1);
  return v2 != 1;
}

uint64_t rtc::RefCountedObject<webrtc::EncodedImageBuffer>::~RefCountedObject(uint64_t a1)
{
  *(_QWORD *)a1 = &unk_24C0B39F8;
  free(*(void **)(a1 + 16));
  return a1;
}

void rtc::RefCountedObject<webrtc::EncodedImageBuffer>::~RefCountedObject(uint64_t a1)
{
  *(_QWORD *)a1 = &unk_24C0B39F8;
  free(*(void **)(a1 + 16));
  JUMPOUT(0x20BD0ADECLL);
}

BOOL rtc::RefCountedObject<webrtc::EncodedImageBuffer>::HasOneRef(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unsigned int *)(a1 + 24));
  return v1 == 1;
}

uint64_t *std::map<int,unsigned long>::insert[abi:sn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<int,unsigned long>,std::__tree_node<std::__value_type<int,unsigned long>,void *> *,long>>>(uint64_t *result, int *a2, int *a3)
{
  uint64_t *v3;
  uint64_t *v4;
  int *v6;
  uint64_t *v7;
  uint64_t *v8;
  int *v9;
  uint64_t *v10;
  _OWORD *v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t *v14;
  int *v15;
  BOOL v16;
  uint64_t *v17;
  uint64_t *v18[9];

  if (a2 != a3)
  {
    v18[7] = v3;
    v18[8] = v4;
    v6 = a2;
    v7 = result;
    v8 = result + 1;
    do
    {
      result = std::__tree<std::__value_type<int,webrtc::SdpAudioFormat>,std::__map_value_compare<int,std::__value_type<int,webrtc::SdpAudioFormat>,std::less<int>,true>,std::allocator<std::__value_type<int,webrtc::SdpAudioFormat>>>::__find_equal<int>(v7, v8, v18, &v17, v6 + 8);
      if (*result)
      {
        v9 = (int *)*((_QWORD *)v6 + 1);
        if (v9)
          goto LABEL_11;
      }
      else
      {
        v10 = result;
        v11 = operator new(0x30uLL);
        v11[2] = *((_OWORD *)v6 + 2);
        v12 = v18[0];
        *(_QWORD *)v11 = 0;
        *((_QWORD *)v11 + 1) = 0;
        *((_QWORD *)v11 + 2) = v12;
        *v10 = (uint64_t)v11;
        v13 = *(_QWORD **)*v7;
        if (v13)
        {
          *v7 = (uint64_t)v13;
          v14 = (uint64_t *)*v10;
        }
        else
        {
          v14 = (uint64_t *)v11;
        }
        result = std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>((uint64_t *)v7[1], v14);
        ++v7[2];
        v9 = (int *)*((_QWORD *)v6 + 1);
        if (v9)
        {
          do
          {
LABEL_11:
            v15 = v9;
            v9 = *(int **)v9;
          }
          while (v9);
          goto LABEL_3;
        }
      }
      do
      {
        v15 = (int *)*((_QWORD *)v6 + 2);
        v16 = *(_QWORD *)v15 == (_QWORD)v6;
        v6 = v15;
      }
      while (!v16);
LABEL_3:
      v6 = v15;
    }
    while (v15 != a3);
  }
  return result;
}

uint64_t webrtc::EncoderBitrateAdjuster::EncoderBitrateAdjuster(uint64_t a1, int *a2, uint64_t a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned int *v9;
  unsigned __int8 *v10;
  int v11;
  unsigned int v12;
  _DWORD *v13;
  unsigned int *v14;
  unsigned int v15;
  _BYTE v17[88];

  webrtc::RateControlSettings::RateControlSettings((uint64_t)v17, a3);
  *(_BYTE *)a1 = v17[79];
  webrtc::VideoEncoder::RateControlParameters::RateControlParameters(a1 + 8);
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 464) = 0;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_OWORD *)(a1 + 680) = 0u;
  v5 = *a2;
  *(_DWORD *)(a1 + 696) = *a2;
  *(_DWORD *)(a1 + 700) = a2[81];
  v6 = *((unsigned __int8 *)a2 + 32);
  if (v5 == 2 && v6 < 2)
  {
    v7 = *((unsigned __int8 *)a2 + 366);
    if (*((_BYTE *)a2 + 366))
    {
      v8 = (unsigned __int8 *)(a2 + 44);
      v9 = (unsigned int *)(a1 + 656);
      v10 = (unsigned __int8 *)(a2 + 44);
      do
      {
        v11 = *v10;
        v10 += 36;
        if (v11)
        {
          v12 = 1000 * a2[4];
          if (v12 <= 1000 * *((_DWORD *)v8 - 2))
            v12 = 1000 * *((_DWORD *)v8 - 2);
          *v9 = v12;
          v9[5] = *((_DWORD *)v8 - 7) * *((_DWORD *)v8 - 8);
        }
        ++v9;
        v8 = v10;
        --v7;
      }
      while (v7);
    }
  }
  else if (*((_BYTE *)a2 + 32))
  {
    v13 = a2 + 37;
    v14 = (unsigned int *)(a1 + 656);
    do
    {
      if (*((_BYTE *)v13 - 80))
      {
        v15 = 1000 * a2[4];
        if (v15 <= 1000 * *(v13 - 22))
          v15 = 1000 * *(v13 - 22);
        *v14 = v15;
        v14[5] = *v13 * *(v13 - 1);
      }
      v13 += 9;
      ++v14;
      --v6;
    }
    while (v6);
  }
  return a1;
}

void webrtc::EncoderBitrateAdjuster::~EncoderBitrateAdjuster(webrtc::EncoderBitrateAdjuster *this)
{
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void **v7;
  void **v8;
  void **v9;
  void **v10;
  void **v11;
  void **v12;
  void **v13;
  void **v14;
  void **v15;
  void **v16;
  void **v17;
  void **v18;
  void **v19;
  void **v20;
  void **v21;

  v2 = (void **)*((_QWORD *)this + 81);
  *((_QWORD *)this + 81) = 0;
  if (v2)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v2);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v2 + 2);
    MEMORY[0x20BD0ADEC](v2, 0x1080C407FFAD1B2);
  }
  v3 = (void **)*((_QWORD *)this + 80);
  *((_QWORD *)this + 80) = 0;
  if (v3)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v3);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v3 + 2);
    MEMORY[0x20BD0ADEC](v3, 0x1080C407FFAD1B2);
  }
  v4 = (void **)*((_QWORD *)this + 79);
  *((_QWORD *)this + 79) = 0;
  if (v4)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v4);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v4 + 2);
    MEMORY[0x20BD0ADEC](v4, 0x1080C407FFAD1B2);
  }
  v5 = (void **)*((_QWORD *)this + 78);
  *((_QWORD *)this + 78) = 0;
  if (v5)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v5);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v5 + 2);
    MEMORY[0x20BD0ADEC](v5, 0x1080C407FFAD1B2);
  }
  v6 = (void **)*((_QWORD *)this + 77);
  *((_QWORD *)this + 77) = 0;
  if (v6)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v6);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v6 + 2);
    MEMORY[0x20BD0ADEC](v6, 0x1080C407FFAD1B2);
  }
  v7 = (void **)*((_QWORD *)this + 76);
  *((_QWORD *)this + 76) = 0;
  if (v7)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v7);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v7 + 2);
    MEMORY[0x20BD0ADEC](v7, 0x1080C407FFAD1B2);
  }
  v8 = (void **)*((_QWORD *)this + 75);
  *((_QWORD *)this + 75) = 0;
  if (v8)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v8);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v8 + 2);
    MEMORY[0x20BD0ADEC](v8, 0x1080C407FFAD1B2);
  }
  v9 = (void **)*((_QWORD *)this + 74);
  *((_QWORD *)this + 74) = 0;
  if (v9)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v9);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v9 + 2);
    MEMORY[0x20BD0ADEC](v9, 0x1080C407FFAD1B2);
  }
  v10 = (void **)*((_QWORD *)this + 73);
  *((_QWORD *)this + 73) = 0;
  if (v10)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v10);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v10 + 2);
    MEMORY[0x20BD0ADEC](v10, 0x1080C407FFAD1B2);
  }
  v11 = (void **)*((_QWORD *)this + 72);
  *((_QWORD *)this + 72) = 0;
  if (v11)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v11);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v11 + 2);
    MEMORY[0x20BD0ADEC](v11, 0x1080C407FFAD1B2);
  }
  v12 = (void **)*((_QWORD *)this + 71);
  *((_QWORD *)this + 71) = 0;
  if (v12)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v12);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v12 + 2);
    MEMORY[0x20BD0ADEC](v12, 0x1080C407FFAD1B2);
  }
  v13 = (void **)*((_QWORD *)this + 70);
  *((_QWORD *)this + 70) = 0;
  if (v13)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v13);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v13 + 2);
    MEMORY[0x20BD0ADEC](v13, 0x1080C407FFAD1B2);
  }
  v14 = (void **)*((_QWORD *)this + 69);
  *((_QWORD *)this + 69) = 0;
  if (v14)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v14);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v14 + 2);
    MEMORY[0x20BD0ADEC](v14, 0x1080C407FFAD1B2);
  }
  v15 = (void **)*((_QWORD *)this + 68);
  *((_QWORD *)this + 68) = 0;
  if (v15)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v15);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v15 + 2);
    MEMORY[0x20BD0ADEC](v15, 0x1080C407FFAD1B2);
  }
  v16 = (void **)*((_QWORD *)this + 67);
  *((_QWORD *)this + 67) = 0;
  if (v16)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v16);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v16 + 2);
    MEMORY[0x20BD0ADEC](v16, 0x1080C407FFAD1B2);
  }
  v17 = (void **)*((_QWORD *)this + 66);
  *((_QWORD *)this + 66) = 0;
  if (v17)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v17);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v17 + 2);
    MEMORY[0x20BD0ADEC](v17, 0x1080C407FFAD1B2);
  }
  v18 = (void **)*((_QWORD *)this + 65);
  *((_QWORD *)this + 65) = 0;
  if (v18)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v18);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v18 + 2);
    MEMORY[0x20BD0ADEC](v18, 0x1080C407FFAD1B2);
  }
  v19 = (void **)*((_QWORD *)this + 64);
  *((_QWORD *)this + 64) = 0;
  if (v19)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v19);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v19 + 2);
    MEMORY[0x20BD0ADEC](v19, 0x1080C407FFAD1B2);
  }
  v20 = (void **)*((_QWORD *)this + 63);
  *((_QWORD *)this + 63) = 0;
  if (v20)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v20);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v20 + 2);
    MEMORY[0x20BD0ADEC](v20, 0x1080C407FFAD1B2);
  }
  v21 = (void **)*((_QWORD *)this + 62);
  *((_QWORD *)this + 62) = 0;
  if (v21)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v21);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v21 + 2);
    MEMORY[0x20BD0ADEC](v21, 0x1080C407FFAD1B2);
  }
  if ((*((_BYTE *)this + 464) & 1) != 0)
  {
    operator delete(*((void **)this + 59));
    if ((*((_BYTE *)this + 440) & 1) == 0)
    {
LABEL_43:
      if ((*((_BYTE *)this + 416) & 1) == 0)
        goto LABEL_44;
      goto LABEL_49;
    }
  }
  else if ((*((_BYTE *)this + 440) & 1) == 0)
  {
    goto LABEL_43;
  }
  operator delete(*((void **)this + 56));
  if ((*((_BYTE *)this + 416) & 1) == 0)
  {
LABEL_44:
    if ((*((_BYTE *)this + 392) & 1) == 0)
      goto LABEL_45;
    goto LABEL_50;
  }
LABEL_49:
  operator delete(*((void **)this + 53));
  if ((*((_BYTE *)this + 392) & 1) == 0)
  {
LABEL_45:
    if ((*((_BYTE *)this + 368) & 1) == 0)
      return;
LABEL_51:
    operator delete(*((void **)this + 47));
    return;
  }
LABEL_50:
  operator delete(*((void **)this + 50));
  if ((*((_BYTE *)this + 368) & 1) != 0)
    goto LABEL_51;
}

void webrtc::EncoderBitrateAdjuster::AdjustRateAllocation(webrtc::EncoderBitrateAdjuster *this@<X0>, const webrtc::VideoEncoder::RateControlParameters *a2@<X1>, unsigned int *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  char *v8;
  unint64_t v9;
  _BYTE *v10;
  char *v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  int v15;
  void **v16;
  uint64_t v17;
  char *v18;
  unint64_t v19;
  char *v20;
  char *v21;
  BOOL v22;
  uint64_t v23;
  int v24;
  void **v25;
  unint64_t v26;
  char *v27;
  char *v28;
  BOOL v29;
  uint64_t v30;
  int v31;
  void **v32;
  unint64_t v33;
  char *v34;
  BOOL v35;
  uint64_t v36;
  int v37;
  void **v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  char *v47;
  uint64_t v48;
  unint64_t v49;
  BOOL v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  char *v55;
  char *v56;
  char *v57;
  __int128 v58;
  char *v59;
  char *v60;
  int v61;
  int v62;
  char *v63;
  int v64;
  int v65;
  double *v66;
  uint64_t v67;
  double v68;
  double v69;
  uint64_t v70;
  char *v71;
  float64x2_t *v72;
  unint64_t v73;
  uint64_t v74;
  void **v75;
  unint64_t v76;
  _QWORD *v77;
  float64x2_t v78;
  uint64_t v79;
  char *v80;
  float64x2_t *v81;
  unint64_t v82;
  double v83;
  uint64_t v84;
  void **v85;
  unint64_t v86;
  _QWORD *v87;
  float64x2_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  void **v92;
  unint64_t v93;
  _QWORD *v94;
  char *v95;
  unsigned int v96;
  double *v97;
  double v98;
  double v99;
  uint64_t v100;
  unint64_t v101;
  double v102;
  uint64_t v103;
  void **v104;
  unint64_t v105;
  _QWORD *v106;
  unsigned int *v107;
  uint64_t v108;
  double v109;
  double v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  double v115;
  double v116;
  double v117;
  uint64_t v118;
  uint64_t v119;
  double v120;
  double v121;
  char *v122;
  unint64_t v123;
  BOOL v124;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  double v135;
  double v136;
  unsigned int v137;
  uint64_t v138;
  unsigned int *v139;
  uint64_t v140;
  unsigned int *v141;
  unsigned int v142;
  uint64_t v143;
  unsigned int *v144;
  uint64_t v145;
  char *v146;
  unsigned int v147;
  uint64_t v148;
  unsigned int *v149;
  uint64_t v150;
  unsigned int v151;
  uint64_t v152;
  unsigned int *v153;
  uint64_t v154;
  unsigned int v155;
  unsigned int v156;
  uint64_t v157;
  unsigned int *v158;
  unsigned int *v159;
  int v160;
  unsigned int v161;
  unsigned int v162;
  unsigned int *v163;
  unsigned int v164;
  unsigned int v165;
  unsigned int v166;
  unsigned int v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  _QWORD *v171;
  char *v172;
  char *v173;
  uint64_t v174;
  _BYTE *v175;
  double v176;
  uint64_t v177;
  uint64_t v178;
  unsigned __int8 *v179;
  double v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  char *v197;
  double v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  double v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  char v218;
  uint64_t v219;
  unint64_t v220;
  unint64_t v221;
  double *v222;
  uint64_t v223;
  _OWORD v226[2];
  uint64_t v227;
  uint64_t v228;

  v228 = *MEMORY[0x24BDAC8D0];
  memcpy((char *)this + 16, (char *)a2 + 8, 0x160uLL);
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v227 = 0;
  memset(v226, 0, sizeof(v226));
  do
  {
    *(_QWORD *)((char *)v226 + v5) = 0;
    v7 = (char *)this + v4;
    v8 = (char *)this + v4 + 376;
    if (!*((_BYTE *)a2 + v6 + 184))
      goto LABEL_14;
    if (!*(_DWORD *)((char *)a2 + v6 + 180))
      goto LABEL_14;
    v9 = *((_QWORD *)v7 + 46);
    if (v9 < 2)
      goto LABEL_14;
    v10 = (char *)this + v4 + 376;
    if ((v9 & 1) != 0)
      v10 = *(_BYTE **)v8;
    if (!*v10)
    {
LABEL_14:
      v16 = *(void ***)((char *)this + v6 + 496);
      if (!v16)
      {
        v12 = 0;
        v18 = (char *)a2 + v6;
        if (!*((_BYTE *)a2 + v6 + 192))
          goto LABEL_29;
        goto LABEL_21;
      }
      v17 = 0;
      *(_QWORD *)((char *)this + v6 + 496) = 0;
LABEL_16:
      webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v16);
      std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v16 + 2);
      MEMORY[0x20BD0ADEC](v16, 0x1080C407FFAD1B2);
      v12 = v17;
      goto LABEL_17;
    }
    *(_QWORD *)((char *)v226 + v5) = 1;
    v11 = (char *)this + v6;
    v12 = 1;
    if (*(_QWORD *)((char *)this + v6 + 496))
      goto LABEL_18;
    v13 = *((_DWORD *)this + 175) == 1;
    v14 = operator new();
    v15 = *((_DWORD *)this + 174);
    *(_OWORD *)v14 = xmmword_208F096B0;
    *(_OWORD *)(v14 + 16) = 0u;
    *(_OWORD *)(v14 + 32) = 0u;
    *(_OWORD *)(v14 + 48) = 0u;
    *(_OWORD *)(v14 + 64) = 0u;
    *(_OWORD *)(v14 + 80) = 0u;
    *(_OWORD *)(v14 + 96) = 0u;
    *(_DWORD *)(v14 + 112) = v15;
    *(_BYTE *)(v14 + 116) = v13;
    *(_QWORD *)(v14 + 128) = 0;
    *(_QWORD *)(v14 + 136) = 0;
    v16 = (void **)*((_QWORD *)v11 + 62);
    *((_QWORD *)v11 + 62) = v14;
    v17 = 1;
    v12 = 1;
    *(_QWORD *)(v14 + 120) = 0;
    if (v16)
      goto LABEL_16;
LABEL_17:
    *((_QWORD *)this + 61) = 0;
LABEL_18:
    v18 = (char *)a2 + v6;
    if (!*((_BYTE *)a2 + v6 + 192))
      goto LABEL_29;
LABEL_21:
    if (*((_DWORD *)v18 + 47))
    {
      v19 = *((_QWORD *)v7 + 46);
      if (v19 >= 4)
      {
        v20 = (char *)this + v4 + 376;
        if ((v19 & 1) != 0)
          v20 = *(char **)v8;
        if (v20[1])
        {
          *(_QWORD *)((char *)v226 + v5) = ++v12;
          v21 = (char *)this + v6;
          if (*(_QWORD *)((char *)this + v6 + 504))
            goto LABEL_33;
          v22 = *((_DWORD *)this + 175) == 1;
          v23 = operator new();
          v24 = *((_DWORD *)this + 174);
          *(_OWORD *)v23 = xmmword_208F096B0;
          *(_OWORD *)(v23 + 16) = 0u;
          *(_OWORD *)(v23 + 32) = 0u;
          *(_OWORD *)(v23 + 48) = 0u;
          *(_OWORD *)(v23 + 64) = 0u;
          *(_OWORD *)(v23 + 80) = 0u;
          *(_OWORD *)(v23 + 96) = 0u;
          *(_DWORD *)(v23 + 112) = v24;
          *(_BYTE *)(v23 + 116) = v22;
          *(_QWORD *)(v23 + 128) = 0;
          *(_QWORD *)(v23 + 136) = 0;
          *(_QWORD *)(v23 + 120) = 0;
          v25 = (void **)*((_QWORD *)v21 + 63);
          *((_QWORD *)v21 + 63) = v23;
          if (!v25)
            goto LABEL_32;
          goto LABEL_31;
        }
      }
    }
LABEL_29:
    v25 = *(void ***)((char *)this + v6 + 504);
    if (!v25)
      goto LABEL_33;
    *(_QWORD *)((char *)this + v6 + 504) = 0;
LABEL_31:
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v25);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v25 + 2);
    MEMORY[0x20BD0ADEC](v25, 0x1080C407FFAD1B2);
LABEL_32:
    *((_QWORD *)this + 61) = 0;
    if (!*((_BYTE *)a2 + v6 + 200))
      goto LABEL_42;
    if (!*(_DWORD *)((char *)a2 + v6 + 196))
      goto LABEL_42;
    v26 = *((_QWORD *)v7 + 46);
    if (v26 < 6)
      goto LABEL_42;
LABEL_33:
    v27 = (char *)this + v4 + 376;
    if ((v26 & 1) != 0)
      v27 = *(char **)v8;
    if (v27[2])
    {
      *(_QWORD *)((char *)v226 + v5) = ++v12;
      v28 = (char *)this + v6;
      if (*(_QWORD *)((char *)this + v6 + 512))
        goto LABEL_46;
      v29 = *((_DWORD *)this + 175) == 1;
      v30 = operator new();
      v31 = *((_DWORD *)this + 174);
      *(_OWORD *)v30 = xmmword_208F096B0;
      *(_OWORD *)(v30 + 16) = 0u;
      *(_OWORD *)(v30 + 32) = 0u;
      *(_OWORD *)(v30 + 48) = 0u;
      *(_OWORD *)(v30 + 64) = 0u;
      *(_OWORD *)(v30 + 80) = 0u;
      *(_OWORD *)(v30 + 96) = 0u;
      *(_DWORD *)(v30 + 112) = v31;
      *(_BYTE *)(v30 + 116) = v29;
      *(_QWORD *)(v30 + 128) = 0;
      *(_QWORD *)(v30 + 136) = 0;
      *(_QWORD *)(v30 + 120) = 0;
      v32 = (void **)*((_QWORD *)v28 + 64);
      *((_QWORD *)v28 + 64) = v30;
      if (!v32)
        goto LABEL_45;
    }
    else
    {
LABEL_42:
      v32 = *(void ***)((char *)this + v6 + 512);
      if (!v32)
        goto LABEL_46;
      *(_QWORD *)((char *)this + v6 + 512) = 0;
    }
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v32);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v32 + 2);
    MEMORY[0x20BD0ADEC](v32, 0x1080C407FFAD1B2);
LABEL_45:
    *((_QWORD *)this + 61) = 0;
    if (!*((_BYTE *)a2 + v6 + 208))
      goto LABEL_55;
    if (!*(_DWORD *)((char *)a2 + v6 + 204))
      goto LABEL_55;
    v33 = *((_QWORD *)v7 + 46);
    if (v33 < 8)
      goto LABEL_55;
LABEL_46:
    if ((v33 & 1) != 0)
      v8 = *(char **)v8;
    if (v8[3])
    {
      *(_QWORD *)((char *)v226 + v5) = v12 + 1;
      v34 = (char *)this + v6;
      if (!*(_QWORD *)((char *)this + v6 + 520))
      {
        v35 = *((_DWORD *)this + 175) == 1;
        v36 = operator new();
        v37 = *((_DWORD *)this + 174);
        *(_OWORD *)v36 = xmmword_208F096B0;
        *(_OWORD *)(v36 + 16) = 0u;
        *(_OWORD *)(v36 + 32) = 0u;
        *(_OWORD *)(v36 + 48) = 0u;
        *(_OWORD *)(v36 + 64) = 0u;
        *(_OWORD *)(v36 + 80) = 0u;
        *(_OWORD *)(v36 + 96) = 0u;
        *(_DWORD *)(v36 + 112) = v37;
        *(_BYTE *)(v36 + 116) = v35;
        *(_QWORD *)(v36 + 128) = 0;
        *(_QWORD *)(v36 + 136) = 0;
        *(_QWORD *)(v36 + 120) = 0;
        v38 = (void **)*((_QWORD *)v34 + 65);
        *((_QWORD *)v34 + 65) = v36;
        if (v38)
          goto LABEL_2;
        goto LABEL_3;
      }
    }
    else
    {
LABEL_55:
      v38 = *(void ***)((char *)this + v6 + 520);
      if (v38)
      {
        *(_QWORD *)((char *)this + v6 + 520) = 0;
LABEL_2:
        webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v38);
        std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v38 + 2);
        MEMORY[0x20BD0ADEC](v38, 0x1080C407FFAD1B2);
LABEL_3:
        *((_QWORD *)this + 61) = 0;
      }
    }
    v6 += 32;
    v5 += 8;
    v4 += 24;
  }
  while (v6 != 160);
  if (rtc::g_clock)
  {
    v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v39 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
        / dword_253EA791C;
  }
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  *a3 = 0;
  *((_BYTE *)a3 + 4) = 0;
  *((_BYTE *)a3 + 8) = 0;
  *((_BYTE *)a3 + 12) = 0;
  *((_BYTE *)a3 + 16) = 0;
  v223 = v39 / 1000000;
  *((_BYTE *)a3 + 20) = 0;
  *((_BYTE *)a3 + 24) = 0;
  *((_BYTE *)a3 + 28) = 0;
  *((_BYTE *)a3 + 32) = 0;
  *((_BYTE *)a3 + 36) = 0;
  *((_BYTE *)a3 + 40) = 0;
  *((_BYTE *)a3 + 44) = 0;
  *((_BYTE *)a3 + 48) = 0;
  *((_BYTE *)a3 + 52) = 0;
  *((_BYTE *)a3 + 56) = 0;
  *((_BYTE *)a3 + 60) = 0;
  *((_BYTE *)a3 + 64) = 0;
  *((_BYTE *)a3 + 68) = 0;
  *((_BYTE *)a3 + 72) = 0;
  *((_BYTE *)a3 + 76) = 0;
  *((_BYTE *)a3 + 80) = 0;
  *((_BYTE *)a3 + 84) = 0;
  *((_BYTE *)a3 + 88) = 0;
  *((_BYTE *)a3 + 92) = 0;
  *((_BYTE *)a3 + 96) = 0;
  *((_BYTE *)a3 + 100) = 0;
  *((_BYTE *)a3 + 104) = 0;
  *((_BYTE *)a3 + 108) = 0;
  *((_BYTE *)a3 + 112) = 0;
  *((_BYTE *)a3 + 116) = 0;
  *((_BYTE *)a3 + 120) = 0;
  *((_BYTE *)a3 + 124) = 0;
  *((_BYTE *)a3 + 128) = 0;
  *((_BYTE *)a3 + 132) = 0;
  *((_BYTE *)a3 + 136) = 0;
  *((_BYTE *)a3 + 140) = 0;
  *((_BYTE *)a3 + 144) = 0;
  *((_BYTE *)a3 + 148) = 0;
  *((_BYTE *)a3 + 152) = 0;
  *((_BYTE *)a3 + 156) = 0;
  *((_BYTE *)a3 + 160) = 0;
  *((_BYTE *)a3 + 164) = 0;
LABEL_76:
  while (2)
  {
    if (v46 >= v47)
    {
      v53 = 0xAAAAAAAAAAAAAAABLL * ((v46 - v45) >> 3) + 1;
      if (v53 > 0xAAAAAAAAAAAAAAALL)
        goto LABEL_316;
      if (0x5555555555555556 * ((v47 - v45) >> 3) > v53)
        v53 = 0x5555555555555556 * ((v47 - v45) >> 3);
      if (0xAAAAAAAAAAAAAAABLL * ((v47 - v45) >> 3) >= 0x555555555555555)
        v53 = 0xAAAAAAAAAAAAAAALL;
      if (!v53)
      {
LABEL_315:
        __break(1u);
LABEL_316:
        std::__throw_bad_array_new_length[abi:sn180100]();
      }
      if (v53 > 0xAAAAAAAAAAAAAAALL)
        std::__throw_bad_array_new_length[abi:sn180100]();
      v54 = 24 * v53;
      v55 = (char *)operator new(24 * v53);
      v56 = &v55[8 * ((v46 - v45) >> 3)];
      *((_QWORD *)v56 + 1) = 0;
      *((_QWORD *)v56 + 2) = 0;
      *(_QWORD *)v56 = 0;
      if (v46 == v45)
      {
        v59 = &v55[8 * ((v46 - v45) >> 3)];
        v47 = &v55[v54];
        v46 = v56 + 24;
        if (!v45)
          goto LABEL_91;
      }
      else
      {
        v57 = &v55[8 * ((v46 - v45) >> 3)];
        do
        {
          v58 = *(_OWORD *)(v46 - 24);
          v59 = v57 - 24;
          *((_QWORD *)v57 - 1) = *((_QWORD *)v46 - 1);
          *(_OWORD *)(v57 - 24) = v58;
          v46 -= 24;
          v57 -= 24;
        }
        while (v46 != v45);
        v47 = &v55[v54];
        v46 = v56 + 24;
        if (!v45)
          goto LABEL_91;
      }
      operator delete(v45);
LABEL_91:
      v45 = v59;
      goto LABEL_92;
    }
    if (!v46)
      goto LABEL_315;
    *(_QWORD *)v46 = 0;
    *((_QWORD *)v46 + 1) = 0;
    *((_QWORD *)v46 + 2) = 0;
    v46 += 24;
LABEL_92:
    if (v45 == v46)
      goto LABEL_315;
    v60 = (char *)a2 + 32 * v44;
    v61 = v60[184];
    if (v60[184])
      v61 = *((_DWORD *)v60 + 45);
    if (v60[192])
    {
      v62 = *((_DWORD *)v60 + 47);
      v63 = (char *)a2 + 32 * v44;
      v64 = v63[200];
      if (v63[200])
        goto LABEL_97;
    }
    else
    {
      v62 = 0;
      v63 = (char *)a2 + 32 * v44;
      v64 = v63[200];
      if (v63[200])
LABEL_97:
        v64 = *((_DWORD *)v63 + 49);
    }
    if (v63[208])
      v65 = *((_DWORD *)v63 + 51);
    else
      v65 = 0;
    v66 = (double *)(v46 - 24);
    v67 = (v62 + v61 + v64 + v65);
    *((_QWORD *)v46 - 1) = v67;
    if (*((_QWORD *)this + 61) <= 0x1DuLL)
    {
      *((_QWORD *)v46 - 2) = 0x3FF3333333333333;
      v68 = 1.2;
      if (2.0 < 1.2)
        v68 = 2.0;
      *v66 = v68;
      v69 = fmax(1.2, 1.0);
      if (v68 <= v69)
        goto LABEL_63;
      goto LABEL_169;
    }
    v70 = *((_QWORD *)v226 + v44);
    if (!v70 || !(_DWORD)v67)
    {
      *((_QWORD *)v46 - 2) = 0x3FF0000000000000;
      v68 = 1.0;
      if (2.0 < 1.0)
        v68 = 2.0;
      *v66 = v68;
      v69 = fmax(1.0, 1.0);
      if (v68 <= v69)
        goto LABEL_63;
      goto LABEL_169;
    }
    v221 = (unint64_t)v47;
    v222 = (double *)(v46 - 24);
    if (v70 == 1)
    {
      v71 = (char *)this + 32 * v44;
      v72 = (float64x2_t *)*((_QWORD *)v71 + 62);
      v73 = *(_QWORD *)&v72[3].f64[1];
      if (v73)
      {
        v220 = v48;
        v74 = v223 - *(_QWORD *)&v72->f64[0];
        v75 = *(void ***)&v72[1].f64[1];
        v76 = *(_QWORD *)&v72[3].f64[0];
        do
        {
          v77 = v75[v76 / 0xAA];
          v78.f64[0] = v72[4].f64[0];
          if (v77[3 * (v76 % 0xAA) + 2] >= v74)
          {
            v102 = v78.f64[0] / (double)v73;
            goto LABEL_157;
          }
          v78.f64[1] = v72[4].f64[1];
          v72[4] = vmaxnmq_f64(vsubq_f64(v78, *(float64x2_t *)&v77[3 * (v76 % 0xAA)]), (float64x2_t)0);
          --v73;
          *(_QWORD *)&v72[3].f64[0] = ++v76;
          *(_QWORD *)&v72[3].f64[1] = v73;
          if (v76 >= 0x154)
          {
            operator delete(*v75);
            v75 = (void **)(*(_QWORD *)&v72[1].f64[1] + 8);
            *(_QWORD *)&v72[1].f64[1] = v75;
            v73 = *(_QWORD *)&v72[3].f64[1];
            v76 = *(_QWORD *)&v72[3].f64[0] - 170;
            *(_QWORD *)&v72[3].f64[0] = v76;
          }
        }
        while (v73);
        v102 = 1.2;
LABEL_157:
        v48 = v220;
        *v222 = v102;
        v100 = *((_QWORD *)v71 + 62);
        v101 = *(_QWORD *)(v100 + 56);
        if (v101)
          goto LABEL_158;
LABEL_163:
        v99 = 1.2;
        *((_QWORD *)v46 - 2) = 0x3FF3333333333333;
        v68 = *((double *)v46 - 3);
        v47 = (char *)v221;
        v97 = (double *)(v46 - 24);
        if (v68 < 1.0)
          goto LABEL_147;
      }
      else
      {
        *v222 = 1.2;
        v100 = *((_QWORD *)v71 + 62);
        v101 = *(_QWORD *)(v100 + 56);
        if (!v101)
          goto LABEL_163;
LABEL_158:
        v103 = v223 - *(_QWORD *)v100;
        v104 = *(void ***)(v100 + 24);
        v105 = *(_QWORD *)(v100 + 48);
        while (1)
        {
          v106 = v104[v105 / 0xAA];
          if (v106[3 * (v105 % 0xAA) + 2] >= v103)
            break;
          *(float64x2_t *)(v100 + 64) = vmaxnmq_f64(vsubq_f64(*(float64x2_t *)(v100 + 64), *(float64x2_t *)&v106[3 * (v105 % 0xAA)]), (float64x2_t)0);
          --v101;
          *(_QWORD *)(v100 + 48) = ++v105;
          *(_QWORD *)(v100 + 56) = v101;
          if (v105 >= 0x154)
          {
            operator delete(*v104);
            v104 = (void **)(*(_QWORD *)(v100 + 24) + 8);
            *(_QWORD *)(v100 + 24) = v104;
            v101 = *(_QWORD *)(v100 + 56);
            v105 = *(_QWORD *)(v100 + 48) - 170;
            *(_QWORD *)(v100 + 48) = v105;
          }
          if (!v101)
            goto LABEL_163;
        }
        v99 = *(double *)(v100 + 72) / (double)v101;
        *((double *)v46 - 2) = v99;
        v68 = *((double *)v46 - 3);
        v47 = (char *)v221;
        v97 = (double *)(v46 - 24);
        if (v68 < 1.0)
          goto LABEL_147;
      }
LABEL_166:
      if (v68 > 2.0)
        v68 = 2.0;
      *v97 = v68;
      v69 = fmax(v99, 1.0);
      if (v68 <= v69)
        goto LABEL_63;
      goto LABEL_169;
    }
    v79 = 0;
    *v66 = 0.0;
    *((_QWORD *)v46 - 2) = 0;
    v220 = v48;
    v216 = v70;
    do
    {
      v217 = v79;
      v80 = (char *)this + 32 * v44 + 8 * v79;
      v81 = (float64x2_t *)*((_QWORD *)v80 + 62);
      v82 = *(_QWORD *)&v81[3].f64[1];
      v83 = 0.0;
      if (v82)
      {
        v84 = v223 - *(_QWORD *)&v81->f64[0];
        v85 = *(void ***)&v81[1].f64[1];
        v86 = *(_QWORD *)&v81[3].f64[0];
        do
        {
          v87 = v85[v86 / 0xAA];
          v88.f64[0] = v81[4].f64[0];
          if (v87[3 * (v86 % 0xAA) + 2] >= v84)
          {
            v83 = v88.f64[0] / (double)v82;
            v218 = 1;
            v48 = v220;
            v89 = *((_QWORD *)v80 + 62);
            v90 = *(_QWORD *)(v89 + 56);
            if (!v90)
              goto LABEL_149;
            goto LABEL_135;
          }
          v88.f64[1] = v81[4].f64[1];
          v81[4] = vmaxnmq_f64(vsubq_f64(v88, *(float64x2_t *)&v87[3 * (v86 % 0xAA)]), (float64x2_t)0);
          --v82;
          *(_QWORD *)&v81[3].f64[0] = ++v86;
          *(_QWORD *)&v81[3].f64[1] = v82;
          if (v86 >= 0x154)
          {
            operator delete(*v85);
            v85 = (void **)(*(_QWORD *)&v81[1].f64[1] + 8);
            *(_QWORD *)&v81[1].f64[1] = v85;
            v82 = *(_QWORD *)&v81[3].f64[1];
            v86 = *(_QWORD *)&v81[3].f64[0] - 170;
            *(_QWORD *)&v81[3].f64[0] = v86;
          }
        }
        while (v82);
        v218 = 0;
        v48 = v220;
        v89 = *((_QWORD *)v80 + 62);
        v90 = *(_QWORD *)(v89 + 56);
        if (v90)
          goto LABEL_135;
LABEL_149:
        *((_QWORD *)v46 - 2) = 0x3FF3333333333333;
        v68 = 1.2;
        v47 = (char *)v221;
        if (2.0 < 1.2)
          v68 = 2.0;
        *v222 = v68;
        v69 = fmax(1.2, 1.0);
        if (v68 <= v69)
        {
LABEL_63:
          v49 = 0;
          goto LABEL_64;
        }
LABEL_169:
        v49 = llround((v68 - v69) * (double)*((uint64_t *)v46 - 1));
LABEL_64:
        v50 = v49 == 0x8000000000000000 || v48 == 0x8000000000000000;
        v51 = v49 + v48;
        if (v50)
          v51 = 0x8000000000000000;
        if (v49 == 0x7FFFFFFFFFFFFFFFLL)
          v52 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v52 = v51;
        if (v48 == 0x7FFFFFFFFFFFFFFFLL)
          v48 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v48 = v52;
        if (++v44 == 5)
          goto LABEL_170;
        goto LABEL_76;
      }
      v218 = 0;
      v89 = *((_QWORD *)v80 + 62);
      v90 = *(_QWORD *)(v89 + 56);
      if (!v90)
        goto LABEL_149;
LABEL_135:
      v91 = v223 - *(_QWORD *)v89;
      v92 = *(void ***)(v89 + 24);
      v93 = *(_QWORD *)(v89 + 48);
      while (1)
      {
        v94 = v92[v93 / 0xAA];
        if (v94[3 * (v93 % 0xAA) + 2] >= v91)
          break;
        *(float64x2_t *)(v89 + 64) = vmaxnmq_f64(vsubq_f64(*(float64x2_t *)(v89 + 64), *(float64x2_t *)&v94[3 * (v93 % 0xAA)]), (float64x2_t)0);
        --v90;
        *(_QWORD *)(v89 + 48) = ++v93;
        *(_QWORD *)(v89 + 56) = v90;
        if (v93 >= 0x154)
        {
          operator delete(*v92);
          v92 = (void **)(*(_QWORD *)(v89 + 24) + 8);
          *(_QWORD *)(v89 + 24) = v92;
          v90 = *(_QWORD *)(v89 + 56);
          v93 = *(_QWORD *)(v89 + 48) - 170;
          *(_QWORD *)(v89 + 48) = v93;
        }
        if (!v90)
          goto LABEL_149;
      }
      if ((v218 & 1) == 0)
        goto LABEL_149;
      if (v217 == 4)
        rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/api/video/video_bitrate_allocation.cc", 55, "temporal_index < kMaxTemporalStreams", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, v40, v41, v42, v43, 4);
      v95 = (char *)a2 + 32 * v44 + 8 * v217;
      if (v95[184])
        v96 = *((_DWORD *)v95 + 45);
      else
        v96 = 0;
      v97 = (double *)(v46 - 24);
      v98 = (double)v96 / (double)*((uint64_t *)v46 - 1);
      v68 = *((double *)v46 - 3) + v98 * v83;
      v99 = *((double *)v46 - 2) + v98 * (*(double *)(v89 + 72) / (double)v90);
      *((double *)v46 - 3) = v68;
      *((double *)v46 - 2) = v99;
      v79 = v217 + 1;
    }
    while (v217 + 1 != v216);
    v47 = (char *)v221;
    if (v68 >= 1.0)
      goto LABEL_166;
LABEL_147:
    *v97 = 1.0;
    if (++v44 != 5)
      continue;
    break;
  }
LABEL_170:
  if (!*(_BYTE *)this)
  {
    v219 = 0;
    v107 = a3;
    if (v48)
      goto LABEL_176;
    goto LABEL_182;
  }
  v107 = a3;
  v108 = *((_QWORD *)a2 + 44);
  v219 = 0x7FFFFFFFFFFFFFFFLL;
  if (v108 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v108 != 0x8000000000000000)
      v108 -= *((unsigned int *)a2 + 44);
    v219 = v108;
  }
  if (!v48)
  {
LABEL_182:
    v110 = 0.0;
    goto LABEL_183;
  }
LABEL_176:
  v109 = INFINITY;
  if (v219 != 0x7FFFFFFFFFFFFFFFLL)
    v109 = (double)v219;
  if (v219 == 0x8000000000000000)
    v109 = -INFINITY;
  v110 = fmin(v109 / (double)v48, 1.0);
LABEL_183:
  v111 = 0;
  v112 = 0;
  v113 = 0;
  while (2)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((v46 - v45) >> 3) == v113)
      goto LABEL_315;
    v114 = &v45[v111];
    v115 = *(double *)&v45[v111];
    v116 = fmax(*(double *)&v45[v111 + 8], 1.0);
    if (v115 <= v116)
    {
      v117 = v110 * (double)0;
      v118 = llround(v117);
      v119 = *((_QWORD *)v114 + 2);
      if (v118 < 1)
        goto LABEL_198;
    }
    else
    {
      v117 = v110 * (double)(uint64_t)llround((v115 - v116) * (double)*((uint64_t *)v114 + 2));
      v118 = llround(v117);
      v119 = *((_QWORD *)v114 + 2);
      if (v118 < 1)
        goto LABEL_198;
    }
    v120 = INFINITY;
    v121 = (double)v119;
    if (v119 == 0x8000000000000000)
      v121 = -INFINITY;
    if (v119 == 0x7FFFFFFFFFFFFFFFLL)
      v121 = INFINITY;
    if (v118 != 0x7FFFFFFFFFFFFFFFLL)
      v120 = (double)v118;
    v117 = v121 / (v120 + v121);
    v115 = v115 * v117;
LABEL_198:
    v122 = (char *)this + 4 * v113;
    v123 = *((unsigned int *)v122 + 164);
    if ((_DWORD)v123)
      v124 = v119 < 1;
    else
      v124 = 1;
    if (!v124 && v119 > v123)
    {
      v135 = (double)v119;
      if (v119 == 0x7FFFFFFFFFFFFFFFLL)
        v135 = INFINITY;
      v136 = v135 / (double)v123;
      if (v136 < v115)
        v115 = v136;
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) == 0)
        goto LABEL_225;
LABEL_207:
      if (*((_QWORD *)v226 + v113) == 1)
        goto LABEL_208;
LABEL_226:
      v133 = *((unsigned __int8 *)a2 + v112 * 4 + 184);
LABEL_227:
      if (v133)
      {
        v142 = *(_DWORD *)((char *)a2 + v112 * 4 + 180);
        v117 = (double)v142 / v115 + 0.5;
        if (v142 >= v117)
          v142 = v117;
        v143 = *v107;
        v144 = &v107[v112];
        if (LOBYTE(v107[v112 + 2]))
          v143 -= v144[1];
        v145 = v143 + v142;
        if (v145 <= 0xFFFFFFFFLL)
        {
          v144[1] = v142;
          *((_BYTE *)v144 + 8) = 1;
          *v107 = v145;
        }
      }
      v146 = (char *)a2 + v112 * 4;
      if (*((_BYTE *)a2 + v112 * 4 + 192))
      {
        v147 = *((_DWORD *)v146 + 47);
        v117 = (double)v147 / v115 + 0.5;
        if (v147 >= v117)
          v147 = v117;
        v148 = *v107;
        v149 = &v107[v112];
        if (LOBYTE(v107[v112 + 4]))
          v148 -= v149[3];
        v150 = v148 + v147;
        if (v150 <= 0xFFFFFFFFLL)
        {
          v149[3] = v147;
          *((_BYTE *)v149 + 16) = 1;
          *v107 = v150;
        }
      }
      if (v146[200])
      {
        v151 = *(_DWORD *)((char *)a2 + v112 * 4 + 196);
        v117 = (double)v151 / v115 + 0.5;
        if (v151 >= v117)
          v151 = v117;
        v152 = *v107;
        v153 = &v107[v112];
        if (LOBYTE(v107[v112 + 6]))
          v152 -= v153[5];
        v154 = v152 + v151;
        if (v154 <= 0xFFFFFFFFLL)
        {
          v153[5] = v151;
          *((_BYTE *)v153 + 24) = 1;
          *v107 = v154;
        }
      }
      if (*((_BYTE *)a2 + v112 * 4 + 208))
      {
        v155 = *(_DWORD *)((char *)a2 + v112 * 4 + 204);
        v117 = (double)v155 / v115 + 0.5;
        if (v155 >= v117)
          v156 = v117;
        else
          v156 = *(_DWORD *)((char *)a2 + v112 * 4 + 204);
        v157 = *v107;
        v158 = &v107[v112];
        v141 = &v107[v112 + 8];
        if (*(_BYTE *)v141)
          v157 -= v158[7];
        v140 = v157 + v156;
        if (v140 <= 0xFFFFFFFFLL)
        {
          v158[7] = v156;
LABEL_256:
          *(_BYTE *)v141 = 1;
          *v107 = v140;
        }
      }
    }
    else
    {
      if (v119 < 1 || (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)0>() & 1) != 0)
        goto LABEL_207;
LABEL_225:
      v221 = v221 & 0xFFFFFFFF00000000 | 0x788;
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)5,unsigned long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double> const&)::t, v126, v127, v128, v129, v130, v131, v132, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/encoder_bitrate_adjuster.cc");
      if (*((_QWORD *)v226 + v113) != 1)
        goto LABEL_226;
LABEL_208:
      v133 = *((unsigned __int8 *)a2 + v112 * 4 + 184);
      if (*((_BYTE *)a2 + v112 * 4 + 184))
      {
        v134 = *((_QWORD *)v114 + 2);
        if (v134 <= *(unsigned int *)((char *)a2 + v112 * 4 + 180))
          goto LABEL_227;
      }
      else
      {
        v134 = *((_QWORD *)v114 + 2);
        if (v134 <= 0)
          goto LABEL_227;
      }
      v117 = (double)v134 / v115 + 0.5;
      if (v134 >= v117)
        v137 = v117;
      else
        v137 = v134;
      v138 = *v107;
      v139 = &v107[v112];
      if (LOBYTE(v107[v112 + 2]))
        v138 -= v139[1];
      v140 = v138 + v137;
      if (v140 <= 0xFFFFFFFFLL)
      {
        v141 = &v107[8 * v113 + 2];
        v139[1] = v137;
        goto LABEL_256;
      }
    }
    v159 = &v107[v112];
    v160 = LOBYTE(v107[v112 + 2]);
    if (LOBYTE(v107[v112 + 2]))
    {
      v161 = v159[1];
      v162 = *((unsigned __int8 *)v159 + 16);
      if (*((_BYTE *)v159 + 16))
        goto LABEL_259;
    }
    else
    {
      v161 = 0;
      v162 = *((unsigned __int8 *)v159 + 16);
      if (*((_BYTE *)v159 + 16))
LABEL_259:
        v162 = v159[3];
    }
    v163 = &v107[v112];
    v164 = *((unsigned __int8 *)v163 + 24);
    if (*((_BYTE *)v163 + 24))
      v164 = v163[5];
    v165 = *((unsigned __int8 *)v163 + 32);
    if (*((_BYTE *)v163 + 32))
      v165 = v163[7];
    if (*((uint64_t *)v114 + 2) < 1)
      goto LABEL_273;
    v166 = v162 + v161 + v164 + v165;
    v167 = *((_DWORD *)v122 + 164);
    if (v166 >= v167)
      goto LABEL_273;
    if (v160)
    {
      v168 = v159[1];
      v169 = (_DWORD)v168 - v166 + v167;
      v170 = *a3 - v168 + v169;
      if (v170 <= 0xFFFFFFFFLL)
        goto LABEL_268;
LABEL_273:
      if (v160)
      {
        v173 = (char *)this + 24 * v113;
        v171 = v173 + 368;
        v172 = v173 + 376;
        LODWORD(v169) = v159[1];
        if ((_DWORD)v169)
          goto LABEL_275;
      }
      else
      {
        v171 = (_QWORD *)((char *)this + v111 + 368);
        v172 = (char *)this + v111 + 376;
      }
    }
    else
    {
      v169 = v167 - v166;
      v170 = *a3 + v169;
      if (v170 > 0xFFFFFFFFLL)
        goto LABEL_273;
LABEL_268:
      v159[1] = v169;
      *((_BYTE *)v159 + 8) = 1;
      *a3 = v170;
      v171 = (_QWORD *)((char *)this + v111 + 368);
      v172 = (char *)this + v111 + 376;
      if ((_DWORD)v169)
      {
LABEL_275:
        v174 = *(_QWORD *)((char *)this + v112 * 4 + 496);
        if (v174)
        {
          if (*v171 <= 1uLL)
            goto LABEL_315;
          v175 = v172;
          if ((*v171 & 1) != 0)
            v175 = *(_BYTE **)v172;
          LOBYTE(v117) = *v175;
          v176 = (double)*(unint64_t *)&v117 / 255.0;
          if (v176 <= 0.0)
          {
            if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
            {
              v220 = v220 & 0xFFFFFFFF00000000 | 0x962;
              rtc::webrtc_logging_impl::Log("\r\t", v181, v182, v183, v184, v185, v186, v187, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/encoder_bitrate_adjuster.cc");
            }
          }
          else
          {
            webrtc::EncoderOvershootDetector::SetTargetRate(v174, v169, v223, v176 * *((double *)a2 + 43));
          }
        }
      }
    }
    if (*((_BYTE *)v159 + 16))
    {
      v177 = v159[3];
      if ((_DWORD)v177)
      {
        v178 = *(_QWORD *)((char *)this + v112 * 4 + 504);
        if (v178)
        {
          if (*v171 < 4uLL)
            goto LABEL_315;
          v179 = (unsigned __int8 *)v172;
          if ((*v171 & 1) != 0)
            v179 = *(unsigned __int8 **)v172;
          v180 = (double)(v179[1] - *v179) / 255.0;
          if (v180 <= 0.0)
          {
            if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
            {
              v220 = v220 & 0xFFFFFFFF00000000 | 0x962;
              rtc::webrtc_logging_impl::Log("\r\t", v188, v189, v190, v191, v192, v193, v194, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/encoder_bitrate_adjuster.cc");
            }
          }
          else
          {
            webrtc::EncoderOvershootDetector::SetTargetRate(v178, v177, v223, v180 * *((double *)a2 + 43));
          }
        }
      }
    }
    if (*((_BYTE *)v163 + 24))
    {
      v195 = v163[5];
      if ((_DWORD)v195)
      {
        v196 = *(_QWORD *)((char *)this + v112 * 4 + 512);
        if (v196)
        {
          if (*v171 < 6uLL)
            goto LABEL_315;
          v197 = v172;
          if ((*v171 & 1) != 0)
            v197 = *(char **)v172;
          v198 = (double)(v197[2] - v197[1]) / 255.0;
          if (v198 <= 0.0)
          {
            if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
            {
              v220 = v220 & 0xFFFFFFFF00000000 | 0x962;
              rtc::webrtc_logging_impl::Log("\r\t", v199, v200, v201, v202, v203, v204, v205, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/encoder_bitrate_adjuster.cc");
            }
          }
          else
          {
            webrtc::EncoderOvershootDetector::SetTargetRate(v196, v195, v223, v198 * *((double *)a2 + 43));
          }
        }
      }
    }
    if (*((_BYTE *)v163 + 32)
      && (v206 = v163[7], (_DWORD)v206)
      && (v207 = *(_QWORD *)((char *)this + v112 * 4 + 520)) != 0)
    {
      if (*v171 < 8uLL)
        goto LABEL_315;
      if ((*v171 & 1) != 0)
        v172 = *(char **)v172;
      v107 = a3;
      v208 = (double)(v172[3] - v172[2]) / 255.0;
      if (v208 <= 0.0)
      {
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        {
          v220 = v220 & 0xFFFFFFFF00000000 | 0x962;
          rtc::webrtc_logging_impl::Log("\r\t", v209, v210, v211, v212, v213, v214, v215, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/encoder_bitrate_adjuster.cc");
        }
      }
      else
      {
        webrtc::EncoderOvershootDetector::SetTargetRate(v207, v206, v223, v208 * *((double *)a2 + 43));
      }
    }
    else
    {
      v107 = a3;
    }
    ++v113;
    v112 += 8;
    v111 += 24;
    if (v112 != 40)
      continue;
    break;
  }
  *((_BYTE *)v107 + 164) = *((_BYTE *)a2 + 340);
  operator delete(v45);
}

void webrtc::EncoderBitrateAdjuster::OnEncoderInfo(webrtc::EncoderBitrateAdjuster *this, const webrtc::VideoEncoder::EncoderInfo *a2, __n128 a3)
{
  unint64_t *v5;
  unint64_t v6;
  __n128 *v7;
  unint64_t v8;
  unint64_t v9;
  void **v10;
  unint64_t v11;
  __n128 *v12;
  unint64_t v13;
  BOOL v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  __n128 *v19;
  __n128 *v20;
  uint64_t v21;
  __n128 v22;
  unint64_t v23;
  char *v24;
  char v25;
  char *v26;
  size_t v27;
  char *v28;
  unint64_t v29;
  char *v30;
  unint64_t v31;
  __n128 *v32;
  __n128 *v33;
  unint64_t v34;
  __n128 v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t *v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  char v43;
  int v44;
  _BYTE *v45;
  _BYTE *v46;
  int64_t v47;
  __n128 *v48;
  __n128 *v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned __int32 *v54;
  unint64_t v55;
  __n128 *v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  __n128 *v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  char *v66;
  __n128 *v67;
  __n128 *v68;
  uint64_t v69;
  __n128 v70;
  unint64_t v71;
  char *v72;
  char v73;
  char *v74;
  size_t v75;
  char *v76;
  unint64_t v77;
  char *v78;
  unsigned __int32 v79;
  unint64_t v80;
  __n128 *v81;
  __n128 *v82;
  unint64_t v83;
  __n128 v84;
  unint64_t v85;
  unint64_t *v86;
  unint64_t *v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  char *v91;
  char v92;
  int v93;
  _BYTE *v94;
  _BYTE *v95;
  int64_t v96;
  __n128 *v97;
  __n128 *v98;
  unint64_t v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unsigned __int32 *v103;
  unint64_t v104;
  __n128 *v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  __n128 *v109;
  unint64_t *v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  uint64_t v114;
  char *v115;
  __n128 *v116;
  __n128 *v117;
  uint64_t v118;
  __n128 v119;
  unint64_t v120;
  char *v121;
  char v122;
  char *v123;
  size_t v124;
  char *v125;
  unint64_t v126;
  char *v127;
  unsigned __int32 v128;
  unint64_t v129;
  __n128 *v130;
  __n128 *v131;
  unint64_t v132;
  __n128 v133;
  unint64_t v134;
  unint64_t *v135;
  unint64_t *v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  char *v140;
  char v141;
  int v142;
  _BYTE *v143;
  _BYTE *v144;
  int64_t v145;
  __n128 *v146;
  __n128 *v147;
  unint64_t v148;
  unint64_t v149;
  uint64_t v150;
  uint64_t v151;
  unsigned __int32 *v152;
  unint64_t v153;
  __n128 *v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  __n128 *v158;
  unint64_t *v159;
  unint64_t v160;
  unint64_t v161;
  unint64_t v162;
  uint64_t v163;
  char *v164;
  __n128 *v165;
  __n128 *v166;
  uint64_t v167;
  __n128 v168;
  unint64_t v169;
  char *v170;
  char v171;
  char *v172;
  size_t v173;
  char *v174;
  unint64_t v175;
  char *v176;
  unsigned __int32 v177;
  unint64_t v178;
  __n128 *v179;
  __n128 *v180;
  unint64_t v181;
  __n128 v182;
  unint64_t v183;
  unint64_t *v184;
  unint64_t *v185;
  unint64_t v186;
  unint64_t v187;
  unint64_t v188;
  char *v189;
  char v190;
  int v191;
  _BYTE *v192;
  _BYTE *v193;
  int64_t v194;
  __n128 *v195;
  __n128 *v196;
  unint64_t v197;
  unint64_t v198;
  uint64_t v199;
  uint64_t v200;
  unsigned __int32 *v201;
  unint64_t v202;
  __n128 *v203;
  unint64_t v204;
  unint64_t v205;
  unint64_t v206;
  __n128 *v207;
  unint64_t *v208;
  unint64_t v209;
  unint64_t v210;
  unint64_t v211;
  uint64_t v212;
  char *v213;
  __n128 *v214;
  __n128 *v215;
  uint64_t v216;
  __n128 v217;
  unint64_t v218;
  char *v219;
  char v220;
  char *v221;
  size_t v222;
  char *v223;
  unint64_t v224;
  char *v225;
  unsigned __int32 v226;
  unint64_t v227;
  __n128 *v228;
  __n128 *v229;
  unint64_t v230;
  __n128 v231;
  unint64_t v232;
  unint64_t *v233;
  unint64_t *v234;
  unint64_t v235;
  unint64_t v236;
  unint64_t v237;
  char *v238;
  char v239;
  int v240;
  _BYTE *v241;
  _BYTE *v242;
  int64_t v243;
  __n128 *v244;
  __n128 *v245;
  unint64_t v246;
  unint64_t v247;
  uint64_t v248;
  uint64_t v249;
  unsigned __int32 *v250;
  unsigned __int32 v251;
  unsigned int v252[42];

  v5 = (unint64_t *)((char *)this + 368);
  if ((char *)this + 368 != (char *)a2 + 56)
  {
    v6 = *((_QWORD *)a2 + 7);
    if ((v6 & 1) != 0)
      v7 = (__n128 *)*((_QWORD *)a2 + 8);
    else
      v7 = (__n128 *)((char *)a2 + 64);
    v8 = v6 >> 1;
    v9 = *((_QWORD *)this + 46);
    v10 = (void **)((char *)this + 376);
    if ((v9 & 1) != 0)
    {
      v12 = (__n128 *)*((_QWORD *)this + 47);
      v11 = *((_QWORD *)this + 48);
      if (v11 >= v8)
      {
LABEL_7:
        v13 = v9 >> 1;
        v14 = v8 >= v9 >> 1;
        v15 = v8 - (v9 >> 1);
        if (!v14)
          v15 = 0;
        if (v13 >= v8)
          v16 = v6 >> 1;
        else
          v16 = v13;
        if (v16)
        {
          v17 = 0;
          if (v16 < 0x20)
            goto LABEL_18;
          if ((unint64_t)((char *)v12 - (char *)v7) < 0x20)
            goto LABEL_18;
          v17 = v16 & 0x7FFFFFFFFFFFFFE0;
          v18 = (char *)v7 + (v16 & 0x7FFFFFFFFFFFFFE0);
          v19 = v12 + 1;
          v20 = v7 + 1;
          v21 = v16 & 0x7FFFFFFFFFFFFFE0;
          do
          {
            a3 = v20[-1];
            v22 = *v20;
            v19[-1] = a3;
            *v19 = v22;
            v19 += 2;
            v20 += 2;
            v21 -= 32;
          }
          while (v21);
          v7 = (__n128 *)((char *)v7 + (v16 & 0x7FFFFFFFFFFFFFE0));
          if (v16 != v17)
          {
LABEL_18:
            v23 = v16 - v17;
            v24 = (char *)v12 + v17;
            v18 = (char *)v7;
            do
            {
              v25 = *v18++;
              *v24++ = v25;
              --v23;
            }
            while (v23);
          }
          if (v13 < v8)
          {
LABEL_21:
            if (!v12)
              goto LABEL_351;
            v26 = 0;
            v27 = 0;
            v28 = (char *)v12 + v13;
            v8 = v15;
            v7 = (__n128 *)v18;
            v29 = 0;
            if (v8 < 8)
              goto LABEL_32;
LABEL_29:
            if ((unint64_t)(v28 - (char *)v7) >= 0x20)
            {
              if (v8 >= 0x20)
              {
                v29 = v8 & 0xFFFFFFFFFFFFFFE0;
                v32 = (__n128 *)(v28 + 16);
                v33 = v7 + 1;
                v34 = v8 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  a3 = v33[-1];
                  v35 = *v33;
                  v32[-1] = a3;
                  *v32 = v35;
                  v32 += 2;
                  v33 += 2;
                  v34 -= 32;
                }
                while (v34);
                if (v8 == v29)
                  goto LABEL_46;
                if ((v8 & 0x18) == 0)
                {
                  v30 = (char *)v7 + v29;
LABEL_44:
                  v41 = v8 - v29;
                  v42 = &v28[v29];
                  do
                  {
                    v43 = *v30++;
                    *v42++ = v43;
                    --v41;
                  }
                  while (v41);
                  goto LABEL_46;
                }
              }
              else
              {
                v29 = 0;
              }
              v36 = v29;
              v29 = v8 & 0xFFFFFFFFFFFFFFF8;
              v30 = (char *)v7 + (v8 & 0xFFFFFFFFFFFFFFF8);
              v37 = (unint64_t *)&v28[v36];
              v38 = (unint64_t *)((char *)v7->n128_u64 + v36);
              v39 = v36 - (v8 & 0xFFFFFFFFFFFFFFF8);
              do
              {
                v40 = *v38++;
                a3.n128_u64[0] = v40;
                *v37++ = v40;
                v39 += 8;
              }
              while (v39);
              if (v8 != v29)
                goto LABEL_44;
LABEL_46:
              v31 = *v5;
              if (v26)
              {
                if ((v31 & 1) != 0)
                  operator delete(*v10);
                *((_QWORD *)this + 47) = v26;
                *((_QWORD *)this + 48) = v27;
                LOBYTE(v31) = 1;
              }
              goto LABEL_50;
            }
LABEL_32:
            v30 = (char *)v7;
            goto LABEL_44;
          }
        }
        else
        {
          v18 = (char *)v7;
          if (v13 < v8)
            goto LABEL_21;
        }
        v31 = *v5;
LABEL_50:
        *v5 = v6 & 0xFFFFFFFFFFFFFFFELL | v31 & 1;
        goto LABEL_51;
      }
    }
    else
    {
      v11 = 16;
      v12 = (__n128 *)((char *)this + 376);
      if (v8 <= 0x10)
        goto LABEL_7;
    }
    if (2 * v11 <= v8)
      v27 = v6 >> 1;
    else
      v27 = 2 * v11;
    v26 = (char *)operator new(v27);
    v28 = v26;
    v29 = 0;
    if (v8 < 8)
      goto LABEL_32;
    goto LABEL_29;
  }
LABEL_51:
  v44 = *((_DWORD *)this + 169);
  if (!v44)
    goto LABEL_69;
  v46 = (_BYTE *)*((_QWORD *)a2 + 22);
  v45 = (_BYTE *)*((_QWORD *)a2 + 23);
  v47 = v45 - v46;
  if (v45 == v46)
  {
    v48 = 0;
    v49 = 0;
  }
  else
  {
    if (v47 < 0)
      goto LABEL_352;
    v48 = (__n128 *)operator new(v45 - v46);
    v49 = &v48[v47 >> 4];
    memcpy(v48, v46, v47);
  }
  v50 = v49 - v48;
  v51 = 126 - 2 * __clz(v50);
  if (v49 == v48)
    v52 = 0;
  else
    v52 = v51;
  a3 = std::__introsort<std::_ClassicAlgPolicy,webrtc::VideoEncoder::EncoderInfo::GetEncoderBitrateLimitsForResolution(int)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits *,false>((uint64_t)v48, v49, v52, 1, a3);
  if (v49 == v48)
  {
    if (v48)
LABEL_68:
      operator delete(v48);
LABEL_69:
    if ((char *)this + 368 == (char *)a2 + 56)
      goto LABEL_121;
LABEL_70:
    v55 = *((_QWORD *)a2 + 10);
    if ((v55 & 1) != 0)
      v56 = (__n128 *)*((_QWORD *)a2 + 11);
    else
      v56 = (__n128 *)((char *)a2 + 88);
    v57 = v55 >> 1;
    v58 = *((_QWORD *)this + 49);
    if ((v58 & 1) != 0)
    {
      v60 = (__n128 *)*((_QWORD *)this + 50);
      v59 = *((_QWORD *)this + 51);
      v61 = (unint64_t *)((char *)this + 392);
      if (v59 >= v57)
      {
LABEL_75:
        v62 = v58 >> 1;
        v14 = v57 >= v58 >> 1;
        v63 = v57 - (v58 >> 1);
        if (!v14)
          v63 = 0;
        if (v62 >= v57)
          v64 = v55 >> 1;
        else
          v64 = v62;
        if (v64)
        {
          v65 = 0;
          if (v64 < 0x20)
            goto LABEL_86;
          if ((unint64_t)((char *)v60 - (char *)v56) < 0x20)
            goto LABEL_86;
          v65 = v64 & 0x7FFFFFFFFFFFFFE0;
          v66 = (char *)v56 + (v64 & 0x7FFFFFFFFFFFFFE0);
          v67 = v60 + 1;
          v68 = v56 + 1;
          v69 = v64 & 0x7FFFFFFFFFFFFFE0;
          do
          {
            a3 = v68[-1];
            v70 = *v68;
            v67[-1] = a3;
            *v67 = v70;
            v67 += 2;
            v68 += 2;
            v69 -= 32;
          }
          while (v69);
          v56 = (__n128 *)((char *)v56 + (v64 & 0x7FFFFFFFFFFFFFE0));
          if (v64 != v65)
          {
LABEL_86:
            v71 = v64 - v65;
            v72 = (char *)v60 + v65;
            v66 = (char *)v56;
            do
            {
              v73 = *v66++;
              *v72++ = v73;
              --v71;
            }
            while (v71);
          }
          if (v62 < v57)
          {
LABEL_89:
            if (!v60)
              goto LABEL_351;
            v74 = 0;
            v75 = 0;
            v76 = (char *)v60 + v62;
            v57 = v63;
            v56 = (__n128 *)v66;
            v77 = 0;
            if (v57 < 8)
              goto LABEL_100;
LABEL_97:
            if ((unint64_t)(v76 - (char *)v56) >= 0x20)
            {
              if (v57 >= 0x20)
              {
                v77 = v57 & 0xFFFFFFFFFFFFFFE0;
                v81 = (__n128 *)(v76 + 16);
                v82 = v56 + 1;
                v83 = v57 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  a3 = v82[-1];
                  v84 = *v82;
                  v81[-1] = a3;
                  *v81 = v84;
                  v81 += 2;
                  v82 += 2;
                  v83 -= 32;
                }
                while (v83);
                if (v57 == v77)
                  goto LABEL_116;
                if ((v57 & 0x18) == 0)
                {
                  v78 = (char *)v56 + v77;
LABEL_114:
                  v90 = v57 - v77;
                  v91 = &v76[v77];
                  do
                  {
                    v92 = *v78++;
                    *v91++ = v92;
                    --v90;
                  }
                  while (v90);
                  goto LABEL_116;
                }
              }
              else
              {
                v77 = 0;
              }
              v85 = v77;
              v77 = v57 & 0xFFFFFFFFFFFFFFF8;
              v78 = (char *)v56 + (v57 & 0xFFFFFFFFFFFFFFF8);
              v86 = (unint64_t *)&v76[v85];
              v87 = (unint64_t *)((char *)v56->n128_u64 + v85);
              v88 = v85 - (v57 & 0xFFFFFFFFFFFFFFF8);
              do
              {
                v89 = *v87++;
                a3.n128_u64[0] = v89;
                *v86++ = v89;
                v88 += 8;
              }
              while (v88);
              if (v57 != v77)
                goto LABEL_114;
LABEL_116:
              v80 = *v61;
              if (v74)
              {
                if ((v80 & 1) != 0)
                  operator delete(*((void **)this + 50));
                *((_QWORD *)this + 50) = v74;
                *((_QWORD *)this + 51) = v75;
                LOBYTE(v80) = 1;
              }
              goto LABEL_120;
            }
LABEL_100:
            v78 = (char *)v56;
            goto LABEL_114;
          }
        }
        else
        {
          v66 = (char *)v56;
          if (v62 < v57)
            goto LABEL_89;
        }
        v80 = *v61;
LABEL_120:
        *v61 = v55 & 0xFFFFFFFFFFFFFFFELL | v80 & 1;
        goto LABEL_121;
      }
    }
    else
    {
      v59 = 16;
      v60 = (__n128 *)((char *)this + 400);
      v61 = (unint64_t *)((char *)this + 392);
      if (v57 <= 0x10)
        goto LABEL_75;
    }
    if (2 * v59 <= v57)
      v75 = v55 >> 1;
    else
      v75 = 2 * v59;
    v74 = (char *)operator new(v75);
    v76 = v74;
    v77 = 0;
    if (v57 < 8)
      goto LABEL_100;
    goto LABEL_97;
  }
  if (v50 <= 1)
    v53 = 1;
  else
    v53 = v49 - v48;
  v54 = &v48->n128_u32[2];
  while ((int)*(v54 - 2) < v44)
  {
    v54 += 4;
    if (!--v53)
      goto LABEL_68;
  }
  v79 = *v54;
  operator delete(v48);
  *((_DWORD *)this + 164) = v79;
  if ((char *)this + 368 != (char *)a2 + 56)
    goto LABEL_70;
LABEL_121:
  v93 = *((_DWORD *)this + 170);
  if (!v93)
    goto LABEL_139;
  v95 = (_BYTE *)*((_QWORD *)a2 + 22);
  v94 = (_BYTE *)*((_QWORD *)a2 + 23);
  v96 = v94 - v95;
  if (v94 == v95)
  {
    v97 = 0;
    v98 = 0;
  }
  else
  {
    if (v96 < 0)
      goto LABEL_352;
    v97 = (__n128 *)operator new(v94 - v95);
    v98 = &v97[v96 >> 4];
    memcpy(v97, v95, v96);
  }
  v99 = v98 - v97;
  v100 = 126 - 2 * __clz(v99);
  if (v98 == v97)
    v101 = 0;
  else
    v101 = v100;
  a3 = std::__introsort<std::_ClassicAlgPolicy,webrtc::VideoEncoder::EncoderInfo::GetEncoderBitrateLimitsForResolution(int)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits *,false>((uint64_t)v97, v98, v101, 1, a3);
  if (v98 == v97)
  {
    if (v97)
LABEL_138:
      operator delete(v97);
LABEL_139:
    if ((char *)this + 368 == (char *)a2 + 56)
      goto LABEL_191;
LABEL_140:
    v104 = *((_QWORD *)a2 + 13);
    if ((v104 & 1) != 0)
      v105 = (__n128 *)*((_QWORD *)a2 + 14);
    else
      v105 = (__n128 *)((char *)a2 + 112);
    v106 = v104 >> 1;
    v107 = *((_QWORD *)this + 52);
    if ((v107 & 1) != 0)
    {
      v109 = (__n128 *)*((_QWORD *)this + 53);
      v108 = *((_QWORD *)this + 54);
      v110 = (unint64_t *)((char *)this + 416);
      if (v108 >= v106)
      {
LABEL_145:
        v111 = v107 >> 1;
        v14 = v106 >= v107 >> 1;
        v112 = v106 - (v107 >> 1);
        if (!v14)
          v112 = 0;
        if (v111 >= v106)
          v113 = v104 >> 1;
        else
          v113 = v111;
        if (v113)
        {
          v114 = 0;
          if (v113 < 0x20)
            goto LABEL_156;
          if ((unint64_t)((char *)v109 - (char *)v105) < 0x20)
            goto LABEL_156;
          v114 = v113 & 0x7FFFFFFFFFFFFFE0;
          v115 = (char *)v105 + (v113 & 0x7FFFFFFFFFFFFFE0);
          v116 = v109 + 1;
          v117 = v105 + 1;
          v118 = v113 & 0x7FFFFFFFFFFFFFE0;
          do
          {
            a3 = v117[-1];
            v119 = *v117;
            v116[-1] = a3;
            *v116 = v119;
            v116 += 2;
            v117 += 2;
            v118 -= 32;
          }
          while (v118);
          v105 = (__n128 *)((char *)v105 + (v113 & 0x7FFFFFFFFFFFFFE0));
          if (v113 != v114)
          {
LABEL_156:
            v120 = v113 - v114;
            v121 = (char *)v109 + v114;
            v115 = (char *)v105;
            do
            {
              v122 = *v115++;
              *v121++ = v122;
              --v120;
            }
            while (v120);
          }
          if (v111 < v106)
          {
LABEL_159:
            if (!v109)
              goto LABEL_351;
            v123 = 0;
            v124 = 0;
            v125 = (char *)v109 + v111;
            v106 = v112;
            v105 = (__n128 *)v115;
            v126 = 0;
            if (v106 < 8)
              goto LABEL_170;
LABEL_167:
            if ((unint64_t)(v125 - (char *)v105) >= 0x20)
            {
              if (v106 >= 0x20)
              {
                v126 = v106 & 0xFFFFFFFFFFFFFFE0;
                v130 = (__n128 *)(v125 + 16);
                v131 = v105 + 1;
                v132 = v106 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  a3 = v131[-1];
                  v133 = *v131;
                  v130[-1] = a3;
                  *v130 = v133;
                  v130 += 2;
                  v131 += 2;
                  v132 -= 32;
                }
                while (v132);
                if (v106 == v126)
                  goto LABEL_186;
                if ((v106 & 0x18) == 0)
                {
                  v127 = (char *)v105 + v126;
LABEL_184:
                  v139 = v106 - v126;
                  v140 = &v125[v126];
                  do
                  {
                    v141 = *v127++;
                    *v140++ = v141;
                    --v139;
                  }
                  while (v139);
                  goto LABEL_186;
                }
              }
              else
              {
                v126 = 0;
              }
              v134 = v126;
              v126 = v106 & 0xFFFFFFFFFFFFFFF8;
              v127 = (char *)v105 + (v106 & 0xFFFFFFFFFFFFFFF8);
              v135 = (unint64_t *)&v125[v134];
              v136 = (unint64_t *)((char *)v105->n128_u64 + v134);
              v137 = v134 - (v106 & 0xFFFFFFFFFFFFFFF8);
              do
              {
                v138 = *v136++;
                a3.n128_u64[0] = v138;
                *v135++ = v138;
                v137 += 8;
              }
              while (v137);
              if (v106 != v126)
                goto LABEL_184;
LABEL_186:
              v129 = *v110;
              if (v123)
              {
                if ((v129 & 1) != 0)
                  operator delete(*((void **)this + 53));
                *((_QWORD *)this + 53) = v123;
                *((_QWORD *)this + 54) = v124;
                LOBYTE(v129) = 1;
              }
              goto LABEL_190;
            }
LABEL_170:
            v127 = (char *)v105;
            goto LABEL_184;
          }
        }
        else
        {
          v115 = (char *)v105;
          if (v111 < v106)
            goto LABEL_159;
        }
        v129 = *v110;
LABEL_190:
        *v110 = v104 & 0xFFFFFFFFFFFFFFFELL | v129 & 1;
        goto LABEL_191;
      }
    }
    else
    {
      v108 = 16;
      v109 = (__n128 *)((char *)this + 424);
      v110 = (unint64_t *)((char *)this + 416);
      if (v106 <= 0x10)
        goto LABEL_145;
    }
    if (2 * v108 <= v106)
      v124 = v104 >> 1;
    else
      v124 = 2 * v108;
    v123 = (char *)operator new(v124);
    v125 = v123;
    v126 = 0;
    if (v106 < 8)
      goto LABEL_170;
    goto LABEL_167;
  }
  if (v99 <= 1)
    v102 = 1;
  else
    v102 = v98 - v97;
  v103 = &v97->n128_u32[2];
  while ((int)*(v103 - 2) < v93)
  {
    v103 += 4;
    if (!--v102)
      goto LABEL_138;
  }
  v128 = *v103;
  operator delete(v97);
  *((_DWORD *)this + 165) = v128;
  if ((char *)this + 368 != (char *)a2 + 56)
    goto LABEL_140;
LABEL_191:
  v142 = *((_DWORD *)this + 171);
  if (!v142)
    goto LABEL_209;
  v144 = (_BYTE *)*((_QWORD *)a2 + 22);
  v143 = (_BYTE *)*((_QWORD *)a2 + 23);
  v145 = v143 - v144;
  if (v143 == v144)
  {
    v146 = 0;
    v147 = 0;
  }
  else
  {
    if (v145 < 0)
      goto LABEL_352;
    v146 = (__n128 *)operator new(v143 - v144);
    v147 = &v146[v145 >> 4];
    memcpy(v146, v144, v145);
  }
  v148 = v147 - v146;
  v149 = 126 - 2 * __clz(v148);
  if (v147 == v146)
    v150 = 0;
  else
    v150 = v149;
  a3 = std::__introsort<std::_ClassicAlgPolicy,webrtc::VideoEncoder::EncoderInfo::GetEncoderBitrateLimitsForResolution(int)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits *,false>((uint64_t)v146, v147, v150, 1, a3);
  if (v147 == v146)
  {
    if (v146)
LABEL_208:
      operator delete(v146);
LABEL_209:
    if ((char *)this + 368 == (char *)a2 + 56)
      goto LABEL_261;
LABEL_210:
    v153 = *((_QWORD *)a2 + 16);
    if ((v153 & 1) != 0)
      v154 = (__n128 *)*((_QWORD *)a2 + 17);
    else
      v154 = (__n128 *)((char *)a2 + 136);
    v155 = v153 >> 1;
    v156 = *((_QWORD *)this + 55);
    if ((v156 & 1) != 0)
    {
      v158 = (__n128 *)*((_QWORD *)this + 56);
      v157 = *((_QWORD *)this + 57);
      v159 = (unint64_t *)((char *)this + 440);
      if (v157 >= v155)
      {
LABEL_215:
        v160 = v156 >> 1;
        v14 = v155 >= v156 >> 1;
        v161 = v155 - (v156 >> 1);
        if (!v14)
          v161 = 0;
        if (v160 >= v155)
          v162 = v153 >> 1;
        else
          v162 = v160;
        if (v162)
        {
          v163 = 0;
          if (v162 < 0x20)
            goto LABEL_226;
          if ((unint64_t)((char *)v158 - (char *)v154) < 0x20)
            goto LABEL_226;
          v163 = v162 & 0x7FFFFFFFFFFFFFE0;
          v164 = (char *)v154 + (v162 & 0x7FFFFFFFFFFFFFE0);
          v165 = v158 + 1;
          v166 = v154 + 1;
          v167 = v162 & 0x7FFFFFFFFFFFFFE0;
          do
          {
            a3 = v166[-1];
            v168 = *v166;
            v165[-1] = a3;
            *v165 = v168;
            v165 += 2;
            v166 += 2;
            v167 -= 32;
          }
          while (v167);
          v154 = (__n128 *)((char *)v154 + (v162 & 0x7FFFFFFFFFFFFFE0));
          if (v162 != v163)
          {
LABEL_226:
            v169 = v162 - v163;
            v170 = (char *)v158 + v163;
            v164 = (char *)v154;
            do
            {
              v171 = *v164++;
              *v170++ = v171;
              --v169;
            }
            while (v169);
          }
          if (v160 < v155)
          {
LABEL_229:
            if (!v158)
              goto LABEL_351;
            v172 = 0;
            v173 = 0;
            v174 = (char *)v158 + v160;
            v155 = v161;
            v154 = (__n128 *)v164;
            v175 = 0;
            if (v155 < 8)
              goto LABEL_240;
LABEL_237:
            if ((unint64_t)(v174 - (char *)v154) >= 0x20)
            {
              if (v155 >= 0x20)
              {
                v175 = v155 & 0xFFFFFFFFFFFFFFE0;
                v179 = (__n128 *)(v174 + 16);
                v180 = v154 + 1;
                v181 = v155 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  a3 = v180[-1];
                  v182 = *v180;
                  v179[-1] = a3;
                  *v179 = v182;
                  v179 += 2;
                  v180 += 2;
                  v181 -= 32;
                }
                while (v181);
                if (v155 == v175)
                  goto LABEL_256;
                if ((v155 & 0x18) == 0)
                {
                  v176 = (char *)v154 + v175;
LABEL_254:
                  v188 = v155 - v175;
                  v189 = &v174[v175];
                  do
                  {
                    v190 = *v176++;
                    *v189++ = v190;
                    --v188;
                  }
                  while (v188);
                  goto LABEL_256;
                }
              }
              else
              {
                v175 = 0;
              }
              v183 = v175;
              v175 = v155 & 0xFFFFFFFFFFFFFFF8;
              v176 = (char *)v154 + (v155 & 0xFFFFFFFFFFFFFFF8);
              v184 = (unint64_t *)&v174[v183];
              v185 = (unint64_t *)((char *)v154->n128_u64 + v183);
              v186 = v183 - (v155 & 0xFFFFFFFFFFFFFFF8);
              do
              {
                v187 = *v185++;
                a3.n128_u64[0] = v187;
                *v184++ = v187;
                v186 += 8;
              }
              while (v186);
              if (v155 != v175)
                goto LABEL_254;
LABEL_256:
              v178 = *v159;
              if (v172)
              {
                if ((v178 & 1) != 0)
                  operator delete(*((void **)this + 56));
                *((_QWORD *)this + 56) = v172;
                *((_QWORD *)this + 57) = v173;
                LOBYTE(v178) = 1;
              }
              goto LABEL_260;
            }
LABEL_240:
            v176 = (char *)v154;
            goto LABEL_254;
          }
        }
        else
        {
          v164 = (char *)v154;
          if (v160 < v155)
            goto LABEL_229;
        }
        v178 = *v159;
LABEL_260:
        *v159 = v153 & 0xFFFFFFFFFFFFFFFELL | v178 & 1;
        goto LABEL_261;
      }
    }
    else
    {
      v157 = 16;
      v158 = (__n128 *)((char *)this + 448);
      v159 = (unint64_t *)((char *)this + 440);
      if (v155 <= 0x10)
        goto LABEL_215;
    }
    if (2 * v157 <= v155)
      v173 = v153 >> 1;
    else
      v173 = 2 * v157;
    v172 = (char *)operator new(v173);
    v174 = v172;
    v175 = 0;
    if (v155 < 8)
      goto LABEL_240;
    goto LABEL_237;
  }
  if (v148 <= 1)
    v151 = 1;
  else
    v151 = v147 - v146;
  v152 = &v146->n128_u32[2];
  while ((int)*(v152 - 2) < v142)
  {
    v152 += 4;
    if (!--v151)
      goto LABEL_208;
  }
  v177 = *v152;
  operator delete(v146);
  *((_DWORD *)this + 166) = v177;
  if ((char *)this + 368 != (char *)a2 + 56)
    goto LABEL_210;
LABEL_261:
  v191 = *((_DWORD *)this + 172);
  if (!v191)
    goto LABEL_279;
  v193 = (_BYTE *)*((_QWORD *)a2 + 22);
  v192 = (_BYTE *)*((_QWORD *)a2 + 23);
  v194 = v192 - v193;
  if (v192 == v193)
  {
    v195 = 0;
    v196 = 0;
  }
  else
  {
    if (v194 < 0)
      goto LABEL_352;
    v195 = (__n128 *)operator new(v192 - v193);
    v196 = &v195[v194 >> 4];
    memcpy(v195, v193, v194);
  }
  v197 = v196 - v195;
  v198 = 126 - 2 * __clz(v197);
  if (v196 == v195)
    v199 = 0;
  else
    v199 = v198;
  a3 = std::__introsort<std::_ClassicAlgPolicy,webrtc::VideoEncoder::EncoderInfo::GetEncoderBitrateLimitsForResolution(int)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits *,false>((uint64_t)v195, v196, v199, 1, a3);
  if (v196 == v195)
  {
    if (v195)
LABEL_278:
      operator delete(v195);
LABEL_279:
    if ((char *)this + 368 == (char *)a2 + 56)
      goto LABEL_331;
LABEL_280:
    v202 = *((_QWORD *)a2 + 19);
    if ((v202 & 1) != 0)
      v203 = (__n128 *)*((_QWORD *)a2 + 20);
    else
      v203 = (__n128 *)((char *)a2 + 160);
    v204 = v202 >> 1;
    v205 = *((_QWORD *)this + 58);
    if ((v205 & 1) != 0)
    {
      v207 = (__n128 *)*((_QWORD *)this + 59);
      v206 = *((_QWORD *)this + 60);
      v208 = (unint64_t *)((char *)this + 464);
      if (v206 >= v204)
      {
LABEL_285:
        v209 = v205 >> 1;
        v14 = v204 >= v205 >> 1;
        v210 = v204 - (v205 >> 1);
        if (!v14)
          v210 = 0;
        if (v209 >= v204)
          v211 = v202 >> 1;
        else
          v211 = v209;
        if (v211)
        {
          v212 = 0;
          if (v211 < 0x20)
            goto LABEL_296;
          if ((unint64_t)((char *)v207 - (char *)v203) < 0x20)
            goto LABEL_296;
          v212 = v211 & 0x7FFFFFFFFFFFFFE0;
          v213 = (char *)v203 + (v211 & 0x7FFFFFFFFFFFFFE0);
          v214 = v207 + 1;
          v215 = v203 + 1;
          v216 = v211 & 0x7FFFFFFFFFFFFFE0;
          do
          {
            a3 = v215[-1];
            v217 = *v215;
            v214[-1] = a3;
            *v214 = v217;
            v214 += 2;
            v215 += 2;
            v216 -= 32;
          }
          while (v216);
          v203 = (__n128 *)((char *)v203 + (v211 & 0x7FFFFFFFFFFFFFE0));
          if (v211 != v212)
          {
LABEL_296:
            v218 = v211 - v212;
            v219 = (char *)v207 + v212;
            v213 = (char *)v203;
            do
            {
              v220 = *v213++;
              *v219++ = v220;
              --v218;
            }
            while (v218);
          }
          if (v209 < v204)
          {
LABEL_299:
            if (v207)
            {
              v221 = 0;
              v222 = 0;
              v223 = (char *)v207 + v209;
              v204 = v210;
              v203 = (__n128 *)v213;
              v224 = 0;
              if (v204 < 8)
                goto LABEL_310;
LABEL_307:
              if ((unint64_t)(v223 - (char *)v203) < 0x20)
              {
LABEL_310:
                v225 = (char *)v203;
                goto LABEL_324;
              }
              if (v204 >= 0x20)
              {
                v224 = v204 & 0xFFFFFFFFFFFFFFE0;
                v228 = (__n128 *)(v223 + 16);
                v229 = v203 + 1;
                v230 = v204 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  a3 = v229[-1];
                  v231 = *v229;
                  v228[-1] = a3;
                  *v228 = v231;
                  v228 += 2;
                  v229 += 2;
                  v230 -= 32;
                }
                while (v230);
                if (v204 == v224)
                  goto LABEL_326;
                if ((v204 & 0x18) == 0)
                {
                  v225 = (char *)v203 + v224;
LABEL_324:
                  v237 = v204 - v224;
                  v238 = &v223[v224];
                  do
                  {
                    v239 = *v225++;
                    *v238++ = v239;
                    --v237;
                  }
                  while (v237);
                  goto LABEL_326;
                }
              }
              else
              {
                v224 = 0;
              }
              v232 = v224;
              v224 = v204 & 0xFFFFFFFFFFFFFFF8;
              v225 = (char *)v203 + (v204 & 0xFFFFFFFFFFFFFFF8);
              v233 = (unint64_t *)&v223[v232];
              v234 = (unint64_t *)((char *)v203->n128_u64 + v232);
              v235 = v232 - (v204 & 0xFFFFFFFFFFFFFFF8);
              do
              {
                v236 = *v234++;
                a3.n128_u64[0] = v236;
                *v233++ = v236;
                v235 += 8;
              }
              while (v235);
              if (v204 != v224)
                goto LABEL_324;
LABEL_326:
              v227 = *v208;
              if (v221)
              {
                if ((v227 & 1) != 0)
                  operator delete(*((void **)this + 59));
                *((_QWORD *)this + 59) = v221;
                *((_QWORD *)this + 60) = v222;
                LOBYTE(v227) = 1;
              }
              goto LABEL_330;
            }
LABEL_351:
            __break(1u);
            goto LABEL_352;
          }
        }
        else
        {
          v213 = (char *)v203;
          if (v209 < v204)
            goto LABEL_299;
        }
        v227 = *v208;
LABEL_330:
        *v208 = v202 & 0xFFFFFFFFFFFFFFFELL | v227 & 1;
        goto LABEL_331;
      }
    }
    else
    {
      v206 = 16;
      v207 = (__n128 *)((char *)this + 472);
      v208 = (unint64_t *)((char *)this + 464);
      if (v204 <= 0x10)
        goto LABEL_285;
    }
    if (2 * v206 <= v204)
      v222 = v202 >> 1;
    else
      v222 = 2 * v206;
    v221 = (char *)operator new(v222);
    v223 = v221;
    v224 = 0;
    if (v204 < 8)
      goto LABEL_310;
    goto LABEL_307;
  }
  if (v197 <= 1)
    v200 = 1;
  else
    v200 = v196 - v195;
  v201 = &v195->n128_u32[2];
  while ((int)*(v201 - 2) < v191)
  {
    v201 += 4;
    if (!--v200)
      goto LABEL_278;
  }
  v226 = *v201;
  operator delete(v195);
  *((_DWORD *)this + 167) = v226;
  if ((char *)this + 368 != (char *)a2 + 56)
    goto LABEL_280;
LABEL_331:
  v240 = *((_DWORD *)this + 173);
  if (!v240)
    goto LABEL_350;
  v242 = (_BYTE *)*((_QWORD *)a2 + 22);
  v241 = (_BYTE *)*((_QWORD *)a2 + 23);
  v243 = v241 - v242;
  if (v241 != v242)
  {
    if ((v243 & 0x8000000000000000) == 0)
    {
      v244 = (__n128 *)operator new(v241 - v242);
      v245 = &v244[v243 >> 4];
      memcpy(v244, v242, v243);
      goto LABEL_336;
    }
LABEL_352:
    abort();
  }
  v244 = 0;
  v245 = 0;
LABEL_336:
  v246 = v245 - v244;
  v247 = 126 - 2 * __clz(v246);
  if (v245 == v244)
    v248 = 0;
  else
    v248 = v247;
  std::__introsort<std::_ClassicAlgPolicy,webrtc::VideoEncoder::EncoderInfo::GetEncoderBitrateLimitsForResolution(int)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits *,false>((uint64_t)v244, v245, v248, 1, a3);
  if (v245 == v244)
  {
    if (v244)
LABEL_348:
      operator delete(v244);
  }
  else
  {
    if (v246 <= 1)
      v249 = 1;
    else
      v249 = v245 - v244;
    v250 = &v244->n128_u32[2];
    while ((int)*(v250 - 2) < v240)
    {
      v250 += 4;
      if (!--v249)
        goto LABEL_348;
    }
    v251 = *v250;
    operator delete(v244);
    *((_DWORD *)this + 168) = v251;
  }
LABEL_350:
  webrtc::EncoderBitrateAdjuster::AdjustRateAllocation(this, (webrtc::EncoderBitrateAdjuster *)((char *)this + 8), v252);
}

void webrtc::EncoderBitrateAdjuster::Reset(webrtc::EncoderBitrateAdjuster *this)
{
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void **v7;
  void **v8;
  void **v9;
  void **v10;
  void **v11;
  void **v12;
  void **v13;
  void **v14;
  void **v15;
  void **v16;
  void **v17;
  void **v18;
  void **v19;
  void **v20;
  void **v21;
  unsigned int v22[42];

  v2 = (void **)*((_QWORD *)this + 62);
  *((_QWORD *)this + 62) = 0;
  if (v2)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v2);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v2 + 2);
    MEMORY[0x20BD0ADEC](v2, 0x1080C407FFAD1B2);
  }
  v3 = (void **)*((_QWORD *)this + 63);
  *((_QWORD *)this + 63) = 0;
  if (v3)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v3);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v3 + 2);
    MEMORY[0x20BD0ADEC](v3, 0x1080C407FFAD1B2);
  }
  v4 = (void **)*((_QWORD *)this + 64);
  *((_QWORD *)this + 64) = 0;
  if (v4)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v4);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v4 + 2);
    MEMORY[0x20BD0ADEC](v4, 0x1080C407FFAD1B2);
  }
  v5 = (void **)*((_QWORD *)this + 65);
  *((_QWORD *)this + 65) = 0;
  if (v5)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v5);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v5 + 2);
    MEMORY[0x20BD0ADEC](v5, 0x1080C407FFAD1B2);
  }
  v6 = (void **)*((_QWORD *)this + 66);
  *((_QWORD *)this + 66) = 0;
  if (v6)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v6);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v6 + 2);
    MEMORY[0x20BD0ADEC](v6, 0x1080C407FFAD1B2);
  }
  v7 = (void **)*((_QWORD *)this + 67);
  *((_QWORD *)this + 67) = 0;
  if (v7)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v7);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v7 + 2);
    MEMORY[0x20BD0ADEC](v7, 0x1080C407FFAD1B2);
  }
  v8 = (void **)*((_QWORD *)this + 68);
  *((_QWORD *)this + 68) = 0;
  if (v8)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v8);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v8 + 2);
    MEMORY[0x20BD0ADEC](v8, 0x1080C407FFAD1B2);
  }
  v9 = (void **)*((_QWORD *)this + 69);
  *((_QWORD *)this + 69) = 0;
  if (v9)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v9);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v9 + 2);
    MEMORY[0x20BD0ADEC](v9, 0x1080C407FFAD1B2);
  }
  v10 = (void **)*((_QWORD *)this + 70);
  *((_QWORD *)this + 70) = 0;
  if (v10)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v10);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v10 + 2);
    MEMORY[0x20BD0ADEC](v10, 0x1080C407FFAD1B2);
  }
  v11 = (void **)*((_QWORD *)this + 71);
  *((_QWORD *)this + 71) = 0;
  if (v11)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v11);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v11 + 2);
    MEMORY[0x20BD0ADEC](v11, 0x1080C407FFAD1B2);
  }
  v12 = (void **)*((_QWORD *)this + 72);
  *((_QWORD *)this + 72) = 0;
  if (v12)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v12);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v12 + 2);
    MEMORY[0x20BD0ADEC](v12, 0x1080C407FFAD1B2);
  }
  v13 = (void **)*((_QWORD *)this + 73);
  *((_QWORD *)this + 73) = 0;
  if (v13)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v13);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v13 + 2);
    MEMORY[0x20BD0ADEC](v13, 0x1080C407FFAD1B2);
  }
  v14 = (void **)*((_QWORD *)this + 74);
  *((_QWORD *)this + 74) = 0;
  if (v14)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v14);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v14 + 2);
    MEMORY[0x20BD0ADEC](v14, 0x1080C407FFAD1B2);
  }
  v15 = (void **)*((_QWORD *)this + 75);
  *((_QWORD *)this + 75) = 0;
  if (v15)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v15);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v15 + 2);
    MEMORY[0x20BD0ADEC](v15, 0x1080C407FFAD1B2);
  }
  v16 = (void **)*((_QWORD *)this + 76);
  *((_QWORD *)this + 76) = 0;
  if (v16)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v16);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v16 + 2);
    MEMORY[0x20BD0ADEC](v16, 0x1080C407FFAD1B2);
  }
  v17 = (void **)*((_QWORD *)this + 77);
  *((_QWORD *)this + 77) = 0;
  if (v17)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v17);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v17 + 2);
    MEMORY[0x20BD0ADEC](v17, 0x1080C407FFAD1B2);
  }
  v18 = (void **)*((_QWORD *)this + 78);
  *((_QWORD *)this + 78) = 0;
  if (v18)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v18);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v18 + 2);
    MEMORY[0x20BD0ADEC](v18, 0x1080C407FFAD1B2);
  }
  v19 = (void **)*((_QWORD *)this + 79);
  *((_QWORD *)this + 79) = 0;
  if (v19)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v19);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v19 + 2);
    MEMORY[0x20BD0ADEC](v19, 0x1080C407FFAD1B2);
  }
  v20 = (void **)*((_QWORD *)this + 80);
  *((_QWORD *)this + 80) = 0;
  if (v20)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v20);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v20 + 2);
    MEMORY[0x20BD0ADEC](v20, 0x1080C407FFAD1B2);
  }
  v21 = (void **)*((_QWORD *)this + 81);
  *((_QWORD *)this + 81) = 0;
  if (v21)
  {
    webrtc::EncoderOvershootDetector::UpdateHistograms((webrtc::EncoderOvershootDetector *)v21);
    std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](v21 + 2);
    MEMORY[0x20BD0ADEC](v21, 0x1080C407FFAD1B2);
  }
  webrtc::EncoderBitrateAdjuster::AdjustRateAllocation(this, (webrtc::EncoderBitrateAdjuster *)((char *)this + 8), v22);
}

double webrtc::EncoderInfoSettings::GetDefaultSinglecastBitrateLimits@<D0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  _OWORD *v3;
  double result;
  _OWORD *v5;

  if (a1 == 2)
  {
    v5 = operator new(0x50uLL);
    a2[2] = v5 + 5;
    *v5 = xmmword_208F096D0;
    v5[1] = xmmword_208F096E0;
    v5[2] = xmmword_208F096F0;
    v5[3] = xmmword_208F09700;
    *(_QWORD *)&result = 0x75300000E1000;
    v5[4] = xmmword_208F09710;
    *a2 = v5;
    a2[1] = v5 + 5;
  }
  else
  {
    if (a1 == 3)
    {
      v3 = operator new(0x50uLL);
      a2[2] = v3 + 5;
      *v3 = xmmword_208F09720;
      v3[1] = xmmword_208F09730;
      v3[2] = xmmword_208F09740;
      v3[3] = xmmword_208F09750;
      *(_QWORD *)&result = 0x8CA00000E1000;
      v3[4] = xmmword_208F09760;
    }
    else
    {
      v3 = operator new(0x50uLL);
      a2[2] = v3 + 5;
      *v3 = xmmword_208F056B0;
      v3[1] = xmmword_208F09770;
      v3[2] = xmmword_208F09780;
      v3[3] = xmmword_208F09790;
      *(_QWORD *)&result = 0xDBBA0000E1000;
      v3[4] = xmmword_208F097A0;
    }
    *a2 = v3;
    a2[1] = v3 + 5;
  }
  return result;
}

void webrtc::EncoderInfoSettings::GetSinglecastBitrateLimitForResolutionWhenQpIsUntrusted(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, __n128 a4@<Q0>)
{
  int v5;
  uint64_t v6;
  const void *v7;
  int64_t v8;
  __n128 *v9;
  __n128 *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 *v17;
  signed __int32 v18;
  __n128 v19;
  char v20;
  unint64_t v21;
  __n128 *v22;
  unint64_t v23;
  __n128 *v24;
  uint64_t v25;
  float v26;
  __n128 *v27;
  double v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  _QWORD v39[3];
  _QWORD v40[2];
  _QWORD v41[2];
  _QWORD v42[4];

  if ((a1 & 0xFF00000000) == 0 || (v5 = a1, (int)a1 <= 0))
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 16) = 0;
    return;
  }
  v7 = *(const void **)a2;
  v6 = *(_QWORD *)(a2 + 8);
  v8 = v6 - *(_QWORD *)a2;
  if (v6 == *(_QWORD *)a2)
  {
    v10 = 0;
    v9 = 0;
  }
  else
  {
    if (v8 < 0)
      goto LABEL_37;
    v9 = (__n128 *)operator new(v6 - *(_QWORD *)a2);
    v10 = &v9[v8 >> 4];
    memcpy(v9, v7, v8);
  }
  v11 = v10 - v9;
  v12 = 126 - 2 * __clz(v11);
  if (v10 == v9)
    v13 = 0;
  else
    v13 = v12;
  std::__introsort<std::_ClassicAlgPolicy,webrtc::EncoderInfoSettings::GetSinglecastBitrateLimitForResolutionWhenQpIsUntrusted(std::optional<int>,std::vector<webrtc::VideoEncoder::ResolutionBitrateLimits> const&)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits*,false>((uint64_t)v9, v10, v13, 1, a4);
  if (v10 != v9)
  {
    v14 = 0;
    v15 = 0;
    if (v11 <= 1)
      v16 = 1;
    else
      v16 = v10 - v9;
    v17 = v9;
    while (1)
    {
      v18 = v17->n128_u32[0];
      ++v17;
      if (v18 >= v5)
        break;
      ++v15;
      v14 -= 0x100000000;
      if (v16 == v15)
        goto LABEL_22;
    }
    if ((_DWORD)v15 == -1)
    {
LABEL_22:
      v19 = v10[-1];
LABEL_23:
      *(__n128 *)a3 = v19;
      goto LABEL_24;
    }
    v21 = -v14 >> 32;
    if (v11 > v21)
    {
      v22 = &v9[v21];
      if (v22->n128_u32[0] == v5)
      {
        v19 = *v22;
        goto LABEL_23;
      }
      v23 = (uint64_t)(0xFFFFFFFF00000000 - v14) >> 32;
      if (v11 > v23)
      {
        v24 = &v9[v23];
        v25 = v24->n128_u32[0];
        v26 = (double)(v5 - (int)v25) / (double)(v22->n128_u32[0] - (int)v25);
        v27 = &v9[v21];
        v28 = 1.0 - v26;
        v29 = (int)((float)((float)v27->n128_i32[1] * v26) + (double)v24->n128_i32[1] * v28);
        v30 = (int)((float)((float)v27->n128_i32[3] * v26) + (double)v24->n128_i32[3] * v28);
        if (v30 < v29)
        {
          if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
          {
            v39[0] = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/"
                     "experiments/encoder_info_settings.cc";
            v39[1] = 1330;
            v39[2] = &v38;
            v40[0] = "BitRate interpolation calculating result is abnormal. ";
            v40[1] = v39;
            v41[0] = " lower_pixel_count = ";
            v41[1] = v40;
            v42[0] = v25;
            v42[1] = v41;
            v42[2] = " upper_pixel_count = ";
            v42[3] = v42;
            rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)7,double>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v31, v32, v33, v34, v35, v36, v37, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/experiments/encoder_info_settings.cc");
          }
          v20 = 0;
          *(_BYTE *)a3 = 0;
          goto LABEL_25;
        }
        *(_DWORD *)a3 = v5;
        *(_DWORD *)(a3 + 4) = v29;
        *(_DWORD *)(a3 + 8) = 30000;
        *(_DWORD *)(a3 + 12) = v30;
LABEL_24:
        v20 = 1;
LABEL_25:
        *(_BYTE *)(a3 + 16) = v20;
        goto LABEL_26;
      }
    }
    __break(1u);
LABEL_37:
    abort();
  }
  *(_BYTE *)a3 = 0;
  *(_BYTE *)(a3 + 16) = 0;
  if (v10)
LABEL_26:
    operator delete(v9);
}

_QWORD *webrtc::EncoderInfoSettings::EncoderInfoSettings(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  void *v19;
  int64_t v20;
  int *v21;
  int *v22;
  char *v23;
  unint64_t v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  BOOL v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  int *v40;
  void *v41;
  _QWORD *v42;
  _QWORD *v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v50;
  int *v51;
  void **v52;
  __int128 v53;
  unint64_t v54;
  void *__p[2];
  uint64_t v56;
  uint64_t v57;
  uint64_t (**v58)();
  void *v59;
  void *v60;
  uint64_t (***v61)();
  void *v62;
  char v63;
  void *v64;
  _QWORD *v65;
  void *v66;
  _BYTE *v67;
  uint64_t v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = off_24C0B3A90;
  *(_QWORD *)(a1 + 8) = off_24C0B4170;
  v8 = a1 + 8;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v9 = (char *)operator new(0x20uLL);
  *(_QWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 48) = xmmword_208F05710;
  if (v9 <= "requested_resolution_alignment" && v9 + 30 > "requested_resolution_alignment")
    goto LABEL_69;
  strcpy(v9, "requested_resolution_alignment");
  *(_QWORD *)(a1 + 80) = off_24C0B4170;
  *(_BYTE *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 8) = &unk_24C0B4140;
  *(_BYTE *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  v10 = (char *)operator new(0x28uLL);
  *(_QWORD *)(a1 + 112) = v10;
  *(_OWORD *)(a1 + 120) = xmmword_208F097B0;
  if (v10 <= "apply_alignment_to_all_simulcast_layers" && v10 + 39 > "apply_alignment_to_all_simulcast_layers")
    goto LABEL_69;
  strcpy(v10, "apply_alignment_to_all_simulcast_layers");
  v50 = (_QWORD *)a1;
  *(_QWORD *)(a1 + 144) = 0;
  *(_WORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 80) = &unk_24C0B41A0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  v11 = (char *)operator new();
  v58 = &off_24C0B3B60;
  LOBYTE(v59) = 0;
  v61 = &v58;
  *(_QWORD *)v11 = &unk_24C0AF318;
  *((_QWORD *)v11 + 1) = off_24C0B4170;
  *((_QWORD *)v11 + 3) = 0;
  *((_QWORD *)v11 + 4) = 0;
  *((_QWORD *)v11 + 2) = 0;
  v11[63] = 17;
  if (v11 + 40 <= "frame_size_pixels" && v11 + 57 > "frame_size_pixels")
    goto LABEL_69;
  strcpy(v11 + 40, "frame_size_pixels");
  *((_WORD *)v11 + 32) = 0;
  v11[66] = 0;
  *((_QWORD *)v11 + 1) = &unk_24C0AF348;
  *((_QWORD *)v11 + 10) = 0;
  *((_QWORD *)v11 + 11) = 0;
  *((_QWORD *)v11 + 9) = 0;
  *((_QWORD *)v11 + 12) = &off_24C0B3B60;
  *((_QWORD *)v11 + 15) = v11 + 96;
  v11[104] = 0;
  __p[0] = v11;
  v12 = (char *)operator new();
  v58 = &off_24C0B3BA8;
  LOBYTE(v59) = 0;
  v61 = &v58;
  *(_QWORD *)v12 = &unk_24C0AF318;
  *((_QWORD *)v12 + 1) = off_24C0B4170;
  *((_QWORD *)v12 + 3) = 0;
  *((_QWORD *)v12 + 4) = 0;
  *((_QWORD *)v12 + 2) = 0;
  v12[63] = 21;
  if (v12 + 40 <= "min_start_bitrate_bps" && v12 + 61 > "min_start_bitrate_bps")
    goto LABEL_69;
  strcpy(v12 + 40, "min_start_bitrate_bps");
  *((_WORD *)v12 + 32) = 0;
  v12[66] = 0;
  *((_QWORD *)v12 + 1) = &unk_24C0AF348;
  *((_QWORD *)v12 + 10) = 0;
  *((_QWORD *)v12 + 11) = 0;
  *((_QWORD *)v12 + 9) = 0;
  *((_QWORD *)v12 + 12) = &off_24C0B3BA8;
  *((_QWORD *)v12 + 15) = v12 + 96;
  v12[104] = 0;
  __p[1] = v12;
  v13 = operator new();
  v58 = &off_24C0B3BF0;
  LOBYTE(v59) = 0;
  v61 = &v58;
  *(_QWORD *)v13 = &unk_24C0AF318;
  *(_QWORD *)(v13 + 8) = off_24C0B4170;
  *(_QWORD *)(v13 + 24) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_QWORD *)(v13 + 16) = 0;
  *(_BYTE *)(v13 + 63) = 15;
  if (v13 + 40 <= (unint64_t)"min_bitrate_bps" && v13 + 55 > (unint64_t)"min_bitrate_bps")
    goto LABEL_69;
  strcpy((char *)(v13 + 40), "min_bitrate_bps");
  *(_WORD *)(v13 + 64) = 0;
  *(_BYTE *)(v13 + 66) = 0;
  *(_QWORD *)(v13 + 8) = &unk_24C0AF348;
  *(_QWORD *)(v13 + 80) = 0;
  *(_QWORD *)(v13 + 88) = 0;
  *(_QWORD *)(v13 + 72) = 0;
  *(_QWORD *)(v13 + 96) = &off_24C0B3BF0;
  *(_QWORD *)(v13 + 120) = v13 + 96;
  *(_BYTE *)(v13 + 104) = 0;
  v56 = v13;
  v14 = operator new();
  v58 = &off_24C0B3C38;
  LOBYTE(v59) = 0;
  v61 = &v58;
  *(_QWORD *)v14 = &unk_24C0AF318;
  *(_QWORD *)(v14 + 8) = off_24C0B4170;
  *(_QWORD *)(v14 + 24) = 0;
  *(_QWORD *)(v14 + 32) = 0;
  *(_QWORD *)(v14 + 16) = 0;
  *(_BYTE *)(v14 + 63) = 15;
  if (v14 + 40 <= (unint64_t)"max_bitrate_bps" && v14 + 55 > (unint64_t)"max_bitrate_bps")
    goto LABEL_69;
  strcpy((char *)(v14 + 40), "max_bitrate_bps");
  *(_WORD *)(v14 + 64) = 0;
  *(_BYTE *)(v14 + 66) = 0;
  *(_QWORD *)(v14 + 8) = &unk_24C0AF348;
  *(_QWORD *)(v14 + 80) = 0;
  *(_QWORD *)(v14 + 88) = 0;
  *(_QWORD *)(v14 + 72) = 0;
  *(_QWORD *)(v14 + 96) = &off_24C0B3C38;
  *(_QWORD *)(v14 + 120) = v14 + 96;
  *(_BYTE *)(v14 + 104) = 0;
  v57 = v14;
  webrtc::FieldTrialStructListBase::FieldTrialStructListBase((uint64_t)&v58, __p, 4);
  v58 = off_24C0B3B30;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(__p, a2, a3, a4);
  v15 = (void *)HIBYTE(v56);
  LOBYTE(v16) = HIBYTE(v56);
  if (v56 < 0)
    v15 = __p[1];
  if (v15)
  {
    *(_QWORD *)&v53 = &v58;
    *((_QWORD *)&v53 + 1) = v8;
    v54 = a1 + 80;
    if ((v56 & 0x8000000000000000) == 0)
    {
LABEL_17:
      v17 = v16;
      v18 = (char *)__p;
      goto LABEL_24;
    }
  }
  else
  {
    (*(void (**)(__int128 *__return_ptr, uint64_t, const char *, uint64_t))(*(_QWORD *)a2 + 16))(&v53, a2, "WebRTC-GetEncoderInfoOverride", 29);
    if (SHIBYTE(v56) < 0)
      operator delete(__p[0]);
    v56 = v54;
    *(_OWORD *)__p = v53;
    v16 = HIBYTE(v54);
    *(_QWORD *)&v53 = &v58;
    *((_QWORD *)&v53 + 1) = v8;
    v54 = a1 + 80;
    if ((v16 & 0x80) == 0)
      goto LABEL_17;
  }
  v17 = (uint64_t)__p[1];
  if (((unint64_t)__p[1] & 0x8000000000000000) != 0 || (v18 = (char *)__p[0], __p[1]) && !__p[0])
  {
LABEL_69:
    __break(1u);
    goto LABEL_70;
  }
LABEL_24:
  webrtc::ParseFieldTrial(&v53, 3, v18, v17);
  v19 = v66;
  v20 = v67 - (_BYTE *)v66;
  if (v67 != v66)
  {
    v52 = (void **)(a1 + 144);
    if ((v20 & 0x8000000000000000) == 0)
    {
      v21 = (int *)operator new(v67 - (_BYTE *)v66);
      v22 = &v21[4 * (v20 >> 4)];
      memcpy(v21, v19, v20);
      v23 = 0;
      v20 = 0;
      v24 = 0;
      v25 = 0;
      v51 = v21;
      while (1)
      {
        while (1)
        {
          v27 = *v21;
          v26 = v21[1];
          v28 = v21[2];
          v29 = v21[3];
          if ((unint64_t)v25 >= v24)
            break;
          if (!v25)
            goto LABEL_69;
          *(_DWORD *)v25 = v27;
          *((_DWORD *)v25 + 1) = v26;
          *((_DWORD *)v25 + 2) = v28;
          *((_DWORD *)v25 + 3) = v29;
          v25 += 16;
          v21 += 4;
          if (v21 == v22)
          {
LABEL_46:
            v40 = v51;
            v41 = *v52;
            v42 = v50;
            if (*v52)
              goto LABEL_47;
            goto LABEL_48;
          }
        }
        v30 = (v25 - v23) >> 4;
        v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) >> 60)
          goto LABEL_70;
        v32 = v24 - (_QWORD)v23;
        if (v32 >> 3 > v31)
          v31 = v32 >> 3;
        v33 = (unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0;
        v34 = 0xFFFFFFFFFFFFFFFLL;
        if (!v33)
          v34 = v31;
        if (!v34)
          goto LABEL_69;
        if (v34 >> 60)
          std::__throw_bad_array_new_length[abi:sn180100]();
        v35 = 16 * v34;
        v36 = (char *)operator new(16 * v34);
        v37 = &v36[16 * v30];
        *(_DWORD *)v37 = v27;
        *((_DWORD *)v37 + 1) = v26;
        *((_DWORD *)v37 + 2) = v28;
        *((_DWORD *)v37 + 3) = v29;
        if (v25 != v23)
          break;
        v39 = &v36[16 * v30];
        v20 = (int64_t)&v36[v35];
        v25 = v37 + 16;
        if (v23)
          goto LABEL_45;
LABEL_27:
        v23 = v39;
        v24 = v20;
        v21 += 4;
        if (v21 == v22)
          goto LABEL_46;
      }
      v38 = &v36[16 * v30];
      do
      {
        v39 = v38 - 16;
        *((_OWORD *)v38 - 1) = *((_OWORD *)v25 - 1);
        v25 -= 16;
        v38 -= 16;
      }
      while (v25 != v23);
      v20 = (int64_t)&v36[v35];
      v25 = v37 + 16;
      if (!v23)
        goto LABEL_27;
LABEL_45:
      operator delete(v23);
      goto LABEL_27;
    }
LABEL_70:
    abort();
  }
  v40 = 0;
  v23 = 0;
  v25 = 0;
  v41 = *(void **)(a1 + 144);
  v42 = (_QWORD *)a1;
  if (v41)
  {
LABEL_47:
    v42[19] = v41;
    operator delete(v41);
  }
LABEL_48:
  v42[18] = v23;
  v42[19] = v25;
  v42[20] = v20;
  v43 = v42;
  if (v40)
    operator delete(v40);
  if (SHIBYTE(v56) < 0)
    operator delete(__p[0]);
  v58 = off_24C0B3B30;
  if (v66)
  {
    v67 = v66;
    operator delete(v66);
  }
  v58 = (uint64_t (**)())off_24C0B3F90;
  v44 = v64;
  if (v64)
  {
    v45 = v65;
    v46 = v64;
    if (v65 != v64)
    {
      do
      {
        v48 = *--v45;
        v47 = v48;
        *v45 = 0;
        if (v48)
          (*(void (**)(uint64_t))(*(_QWORD *)v47 + 8))(v47);
      }
      while (v45 != v44);
      v46 = v64;
    }
    v65 = v44;
    operator delete(v46);
  }
  v58 = (uint64_t (**)())off_24C0B4170;
  if (v63 < 0)
    operator delete(v62);
  if (v59)
  {
    v60 = v59;
    operator delete(v59);
  }
  return v43;
}

uint64_t webrtc::FieldTrialStructList<webrtc::EncoderInfoSettings::BitrateLimit>::~FieldTrialStructList(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  *(_QWORD *)a1 = off_24C0B3B30;
  v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(_QWORD *)(a1 + 96) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_24C0B3F90;
  v3 = *(_QWORD **)(a1 + 64);
  if (v3)
  {
    v4 = *(_QWORD **)(a1 + 72);
    v5 = *(void **)(a1 + 64);
    if (v4 != v3)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v3);
      v5 = *(void **)(a1 + 64);
    }
    *(_QWORD *)(a1 + 72) = v3;
    operator delete(v5);
  }
  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v8 = *(void **)(a1 + 8);
    if (!v8)
      return a1;
    goto LABEL_13;
  }
  v8 = *(void **)(a1 + 8);
  if (v8)
  {
LABEL_13:
    *(_QWORD *)(a1 + 16) = v8;
    operator delete(v8);
  }
  return a1;
}

void webrtc::EncoderInfoSettings::~EncoderInfoSettings(webrtc::EncoderInfoSettings *this)
{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_24C0B3A90;
  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 10) = off_24C0B4170;
  if ((*((char *)this + 135) & 0x80000000) == 0)
  {
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
      goto LABEL_6;
    goto LABEL_5;
  }
  operator delete(*((void **)this + 14));
  v3 = (void *)*((_QWORD *)this + 11);
  if (v3)
  {
LABEL_5:
    *((_QWORD *)this + 12) = v3;
    operator delete(v3);
  }
LABEL_6:
  *((_QWORD *)this + 1) = off_24C0B4170;
  if (*((char *)this + 63) < 0)
  {
    operator delete(*((void **)this + 5));
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  else
  {
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  *((_QWORD *)this + 3) = v4;
  operator delete(v4);
}

{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_24C0B3A90;
  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 10) = off_24C0B4170;
  if ((*((char *)this + 135) & 0x80000000) == 0)
  {
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
      goto LABEL_6;
    goto LABEL_5;
  }
  operator delete(*((void **)this + 14));
  v3 = (void *)*((_QWORD *)this + 11);
  if (v3)
  {
LABEL_5:
    *((_QWORD *)this + 12) = v3;
    operator delete(v3);
  }
LABEL_6:
  *((_QWORD *)this + 1) = off_24C0B4170;
  if (*((char *)this + 63) < 0)
  {
    operator delete(*((void **)this + 5));
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  else
  {
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  *((_QWORD *)this + 3) = v4;
  operator delete(v4);
}

{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_24C0B3A90;
  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 10) = off_24C0B4170;
  if (*((char *)this + 135) < 0)
  {
    operator delete(*((void **)this + 14));
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
    {
LABEL_6:
      *((_QWORD *)this + 1) = off_24C0B4170;
      if (*((char *)this + 63) < 0)
      {
        operator delete(*((void **)this + 5));
        v4 = (void *)*((_QWORD *)this + 2);
        if (!v4)
          goto LABEL_13;
      }
      else
      {
        v4 = (void *)*((_QWORD *)this + 2);
        if (!v4)
          goto LABEL_13;
      }
      *((_QWORD *)this + 3) = v4;
      operator delete(v4);
LABEL_13:
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
      goto LABEL_6;
  }
  *((_QWORD *)this + 12) = v3;
  operator delete(v3);
  goto LABEL_6;
}

void webrtc::SimulcastEncoderAdapterEncoderInfoSettings::~SimulcastEncoderAdapterEncoderInfoSettings(webrtc::SimulcastEncoderAdapterEncoderInfoSettings *this)
{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_24C0B3A90;
  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 10) = off_24C0B4170;
  if ((*((char *)this + 135) & 0x80000000) == 0)
  {
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
      goto LABEL_6;
    goto LABEL_5;
  }
  operator delete(*((void **)this + 14));
  v3 = (void *)*((_QWORD *)this + 11);
  if (v3)
  {
LABEL_5:
    *((_QWORD *)this + 12) = v3;
    operator delete(v3);
  }
LABEL_6:
  *((_QWORD *)this + 1) = off_24C0B4170;
  if (*((char *)this + 63) < 0)
  {
    operator delete(*((void **)this + 5));
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  else
  {
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  *((_QWORD *)this + 3) = v4;
  operator delete(v4);
}

{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_24C0B3A90;
  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 10) = off_24C0B4170;
  if (*((char *)this + 135) < 0)
  {
    operator delete(*((void **)this + 14));
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
    {
LABEL_6:
      *((_QWORD *)this + 1) = off_24C0B4170;
      if (*((char *)this + 63) < 0)
      {
        operator delete(*((void **)this + 5));
        v4 = (void *)*((_QWORD *)this + 2);
        if (!v4)
          goto LABEL_13;
      }
      else
      {
        v4 = (void *)*((_QWORD *)this + 2);
        if (!v4)
          goto LABEL_13;
      }
      *((_QWORD *)this + 3) = v4;
      operator delete(v4);
LABEL_13:
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
      goto LABEL_6;
  }
  *((_QWORD *)this + 12) = v3;
  operator delete(v3);
  goto LABEL_6;
}

void webrtc::LibvpxVp8EncoderInfoSettings::~LibvpxVp8EncoderInfoSettings(webrtc::LibvpxVp8EncoderInfoSettings *this)
{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_24C0B3A90;
  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 10) = off_24C0B4170;
  if ((*((char *)this + 135) & 0x80000000) == 0)
  {
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
      goto LABEL_6;
    goto LABEL_5;
  }
  operator delete(*((void **)this + 14));
  v3 = (void *)*((_QWORD *)this + 11);
  if (v3)
  {
LABEL_5:
    *((_QWORD *)this + 12) = v3;
    operator delete(v3);
  }
LABEL_6:
  *((_QWORD *)this + 1) = off_24C0B4170;
  if (*((char *)this + 63) < 0)
  {
    operator delete(*((void **)this + 5));
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  else
  {
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  *((_QWORD *)this + 3) = v4;
  operator delete(v4);
}

{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_24C0B3A90;
  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 10) = off_24C0B4170;
  if (*((char *)this + 135) < 0)
  {
    operator delete(*((void **)this + 14));
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
    {
LABEL_6:
      *((_QWORD *)this + 1) = off_24C0B4170;
      if (*((char *)this + 63) < 0)
      {
        operator delete(*((void **)this + 5));
        v4 = (void *)*((_QWORD *)this + 2);
        if (!v4)
          goto LABEL_13;
      }
      else
      {
        v4 = (void *)*((_QWORD *)this + 2);
        if (!v4)
          goto LABEL_13;
      }
      *((_QWORD *)this + 3) = v4;
      operator delete(v4);
LABEL_13:
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
      goto LABEL_6;
  }
  *((_QWORD *)this + 12) = v3;
  operator delete(v3);
  goto LABEL_6;
}

void webrtc::LibvpxVp9EncoderInfoSettings::~LibvpxVp9EncoderInfoSettings(webrtc::LibvpxVp9EncoderInfoSettings *this)
{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_24C0B3A90;
  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 10) = off_24C0B4170;
  if ((*((char *)this + 135) & 0x80000000) == 0)
  {
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
      goto LABEL_6;
    goto LABEL_5;
  }
  operator delete(*((void **)this + 14));
  v3 = (void *)*((_QWORD *)this + 11);
  if (v3)
  {
LABEL_5:
    *((_QWORD *)this + 12) = v3;
    operator delete(v3);
  }
LABEL_6:
  *((_QWORD *)this + 1) = off_24C0B4170;
  if (*((char *)this + 63) < 0)
  {
    operator delete(*((void **)this + 5));
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  else
  {
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  *((_QWORD *)this + 3) = v4;
  operator delete(v4);
}

{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_24C0B3A90;
  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 10) = off_24C0B4170;
  if (*((char *)this + 135) < 0)
  {
    operator delete(*((void **)this + 14));
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
    {
LABEL_6:
      *((_QWORD *)this + 1) = off_24C0B4170;
      if (*((char *)this + 63) < 0)
      {
        operator delete(*((void **)this + 5));
        v4 = (void *)*((_QWORD *)this + 2);
        if (!v4)
          goto LABEL_13;
      }
      else
      {
        v4 = (void *)*((_QWORD *)this + 2);
        if (!v4)
          goto LABEL_13;
      }
      *((_QWORD *)this + 3) = v4;
      operator delete(v4);
LABEL_13:
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
      goto LABEL_6;
  }
  *((_QWORD *)this + 12) = v3;
  operator delete(v3);
  goto LABEL_6;
}

void webrtc::LibaomAv1EncoderInfoSettings::~LibaomAv1EncoderInfoSettings(webrtc::LibaomAv1EncoderInfoSettings *this)
{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_24C0B3A90;
  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 10) = off_24C0B4170;
  if ((*((char *)this + 135) & 0x80000000) == 0)
  {
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
      goto LABEL_6;
    goto LABEL_5;
  }
  operator delete(*((void **)this + 14));
  v3 = (void *)*((_QWORD *)this + 11);
  if (v3)
  {
LABEL_5:
    *((_QWORD *)this + 12) = v3;
    operator delete(v3);
  }
LABEL_6:
  *((_QWORD *)this + 1) = off_24C0B4170;
  if (*((char *)this + 63) < 0)
  {
    operator delete(*((void **)this + 5));
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  else
  {
    v4 = (void *)*((_QWORD *)this + 2);
    if (!v4)
      return;
  }
  *((_QWORD *)this + 3) = v4;
  operator delete(v4);
}

{
  void *v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = off_24C0B3A90;
  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 10) = off_24C0B4170;
  if (*((char *)this + 135) < 0)
  {
    operator delete(*((void **)this + 14));
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
    {
LABEL_6:
      *((_QWORD *)this + 1) = off_24C0B4170;
      if (*((char *)this + 63) < 0)
      {
        operator delete(*((void **)this + 5));
        v4 = (void *)*((_QWORD *)this + 2);
        if (!v4)
          goto LABEL_13;
      }
      else
      {
        v4 = (void *)*((_QWORD *)this + 2);
        if (!v4)
          goto LABEL_13;
      }
      *((_QWORD *)this + 3) = v4;
      operator delete(v4);
LABEL_13:
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  else
  {
    v3 = (void *)*((_QWORD *)this + 11);
    if (!v3)
      goto LABEL_6;
  }
  *((_QWORD *)this + 12) = v3;
  operator delete(v3);
  goto LABEL_6;
}

__n128 std::__introsort<std::_ClassicAlgPolicy,webrtc::EncoderInfoSettings::GetSinglecastBitrateLimitForResolutionWhenQpIsUntrusted(std::optional<int>,std::vector<webrtc::VideoEncoder::ResolutionBitrateLimits> const&)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits*,false>(uint64_t a1, __n128 *a2, uint64_t a3, char a4, __n128 result)
{
  __n128 *v9;
  __n128 *v10;
  __n128 *v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  __n128 *v16;
  signed int v17;
  signed __int32 v18;
  signed int v19;
  __n128 *v20;
  __n128 *v21;
  unsigned int *v22;
  __n128 *v23;
  signed int v24;
  signed int v25;
  signed int v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  __n128 *v30;
  unsigned int *v31;
  __n128 *v32;
  signed int v33;
  signed int v34;
  signed int v35;
  __n128 v36;
  __n128 v37;
  __n128 v38;
  signed __int32 v39;
  signed __int32 v40;
  uint64_t v41;
  unsigned int *v42;
  unsigned int *v43;
  __n128 *v44;
  int v45;
  int v46;
  __n128 *v47;
  __n128 *v48;
  int v49;
  int v50;
  __n128 *v51;
  BOOL v52;
  __n128 v53;
  __n128 *v54;
  int v55;
  unsigned int *v56;
  __n128 *v57;
  int v58;
  __n128 *v59;
  int v60;
  int v61;
  __n128 *v62;
  signed int v63;
  signed int v64;
  signed int v65;
  unsigned __int32 v66;
  __n128 *v67;
  __n128 *v68;
  __n128 *v69;
  __n128 *v70;
  signed int v71;
  BOOL v73;
  uint64_t v74;
  __n128 *v75;
  uint64_t v76;
  __n128 *v77;
  signed __int32 v78;
  uint64_t v79;
  signed __int32 v80;
  int64_t v81;
  int64_t v82;
  uint64_t v83;
  unsigned int *v84;
  signed int v85;
  BOOL v86;
  unsigned int *v87;
  signed int v88;
  signed int v89;
  signed int v90;
  unsigned int *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  _OWORD *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  __n128 *v101;
  signed __int32 v102;
  _OWORD *v103;
  uint64_t v104;
  uint64_t v105;
  unsigned int *v106;
  signed __int32 v107;
  uint64_t v108;
  __n128 *v109;
  __n128 *v111;
  signed __int32 v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unsigned int v116;
  unsigned int v117;
  int v118;
  __n128 v119;
  __n128 v120;
  __n128 v121;
  __n128 v122;
  __n128 v123;
  __n128 v124;
  __n128 v125;
  __n128 v126;
  __n128 v127;
  __n128 v128;
  __n128 v129;
  __n128 v130;
  __n128 v131;
  __n128 v132;
  __n128 v133;
  __n128 v134;
  __n128 v135;
  __n128 v136;
  __n128 v137;
  __n128 v138;
  __n128 v139;
  uint64_t v140;
  uint64_t v141;
  __n128 v142;
  __n128 v143;
  unint64_t v144;
  __n128 v145;
  unsigned int v146;
  unsigned int v147;
  unsigned __int32 v148;

BOOL std::__insertion_sort_incomplete[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::EncoderInfoSettings::GetSinglecastBitrateLimitForResolutionWhenQpIsUntrusted(std::optional<int>,std::vector<webrtc::VideoEncoder::ResolutionBitrateLimits> const&)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits*>(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v5;
  _BOOL8 result;
  __n128 *v7;
  __n128 *v8;
  int v9;
  int v10;
  __n128 v11;
  __n128 *v12;
  int v13;
  __n128 *v14;
  int v15;
  signed __int32 v16;
  __n128 v17;
  __n128 *v18;
  __n128 *v19;
  __n128 *v20;
  __n128 *v21;
  int v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;
  __n128 v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  __n128 v31;
  __n128 v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;

  v5 = (a2 - a1) >> 4;
  result = 1;
  switch(v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v7 = (__n128 *)(a2 - 16);
      if (*(_DWORD *)(a2 - 16) < *(_DWORD *)a1)
        goto LABEL_6;
      return result;
    case 3:
      v8 = (__n128 *)(a1 + 16);
      v9 = *(_DWORD *)(a1 + 16);
      v7 = (__n128 *)(a2 - 16);
      v10 = *(_DWORD *)(a2 - 16);
      if (v9 >= *(_DWORD *)a1)
      {
        if (v10 < v9)
        {
          v27 = *v8;
          *v8 = *v7;
          *v7 = v27;
          if (*(_DWORD *)(a1 + 16) < *(_DWORD *)a1)
          {
            v28 = *(__n128 *)a1;
            *(__n128 *)a1 = *v8;
            *v8 = v28;
          }
        }
      }
      else
      {
        if (v10 < v9)
        {
LABEL_6:
          v11 = *(__n128 *)a1;
          *(__n128 *)a1 = *v7;
LABEL_7:
          *v7 = v11;
          return result;
        }
        v31 = *(__n128 *)a1;
        *(__n128 *)a1 = *v8;
        *v8 = v31;
        if ((signed __int32)v7->n128_u32[0] < *(_DWORD *)(a1 + 16))
        {
          v11 = *v8;
          *v8 = *v7;
          goto LABEL_7;
        }
      }
      return result;
    case 4:
      std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::EncoderInfoSettings::GetSinglecastBitrateLimitForResolutionWhenQpIsUntrusted(std::optional<int>,std::vector<webrtc::VideoEncoder::ResolutionBitrateLimits> const&)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits*>((__n128 *)a1, (__n128 *)(a1 + 16), (int *)(a1 + 32), (_OWORD *)(a2 - 16), a3);
      return 1;
    case 5:
      v18 = (__n128 *)(a1 + 16);
      v19 = (__n128 *)(a1 + 32);
      v20 = (__n128 *)(a1 + 48);
      std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::EncoderInfoSettings::GetSinglecastBitrateLimitForResolutionWhenQpIsUntrusted(std::optional<int>,std::vector<webrtc::VideoEncoder::ResolutionBitrateLimits> const&)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits*>((__n128 *)a1, (__n128 *)(a1 + 16), (int *)(a1 + 32), (_OWORD *)(a1 + 48), a3);
      v22 = *(_DWORD *)(a2 - 16);
      v21 = (__n128 *)(a2 - 16);
      if (v22 < *(_DWORD *)(a1 + 48))
      {
        v23 = *v20;
        *v20 = *v21;
        *v21 = v23;
        if ((signed __int32)v20->n128_u32[0] < (signed __int32)v19->n128_u32[0])
        {
          v24 = *v19;
          *v19 = *v20;
          *v20 = v24;
          if ((signed __int32)v19->n128_u32[0] < (signed __int32)v18->n128_u32[0])
          {
            v25 = *v18;
            *v18 = *v19;
            *v19 = v25;
            if (*(_DWORD *)(a1 + 16) < *(_DWORD *)a1)
            {
              v26 = *(__n128 *)a1;
              *(__n128 *)a1 = *v18;
              *v18 = v26;
            }
          }
        }
      }
      return 1;
    default:
      v12 = (__n128 *)(a1 + 32);
      v13 = *(_DWORD *)(a1 + 32);
      v14 = (__n128 *)(a1 + 16);
      v15 = *(_DWORD *)(a1 + 16);
      v16 = *(_DWORD *)a1;
      if (v15 >= *(_DWORD *)a1)
      {
        if (v13 < v15)
        {
          v29 = *v14;
          *v14 = *v12;
          *v12 = v29;
          if ((signed __int32)v14->n128_u32[0] < v16)
          {
            v30 = *(__n128 *)a1;
            *(__n128 *)a1 = *v14;
            *v14 = v30;
          }
        }
      }
      else
      {
        if (v13 >= v15)
        {
          v32 = *(__n128 *)a1;
          *(__n128 *)a1 = *v14;
          *v14 = v32;
          if (v13 >= *(_DWORD *)(a1 + 16))
            goto LABEL_29;
          v17 = *v14;
          *v14 = *v12;
        }
        else
        {
          v17 = *(__n128 *)a1;
          *(__n128 *)a1 = *v12;
        }
        *v12 = v17;
      }
LABEL_29:
      v33 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v34 = 0;
      v35 = 0;
      while (1)
      {
        v37 = *(_DWORD *)v33;
        if (*(_DWORD *)v33 < (signed __int32)v12->n128_u32[0])
        {
          v40 = *(_QWORD *)(v33 + 4);
          v41 = *(_DWORD *)(v33 + 12);
          v38 = v34;
          do
          {
            *(_OWORD *)(a1 + v38 + 48) = *(_OWORD *)(a1 + v38 + 32);
            if (v38 == -32)
            {
              v36 = a1;
              goto LABEL_32;
            }
            v39 = *(_DWORD *)(a1 + v38 + 16);
            v38 -= 16;
          }
          while (v37 < v39);
          v36 = a1 + v38 + 48;
LABEL_32:
          *(_DWORD *)v36 = v37;
          *(_QWORD *)(v36 + 4) = v40;
          *(_DWORD *)(v36 + 12) = v41;
          if (++v35 == 8)
            return v33 + 16 == a2;
        }
        v12 = (__n128 *)v33;
        v34 += 16;
        v33 += 16;
        if (v33 == a2)
          return 1;
      }
  }
}

__n128 std::__sort4[abi:sn180100]<std::_ClassicAlgPolicy,webrtc::EncoderInfoSettings::GetSinglecastBitrateLimitForResolutionWhenQpIsUntrusted(std::optional<int>,std::vector<webrtc::VideoEncoder::ResolutionBitrateLimits> const&)::$_0 &,webrtc::VideoEncoder::ResolutionBitrateLimits*>(__n128 *a1, __n128 *a2, int *a3, _OWORD *a4, __n128 result)
{
  int v5;
  int v6;

  v5 = a2->n128_u32[0];
  v6 = *a3;
  if ((signed __int32)a2->n128_u32[0] >= (signed __int32)a1->n128_u32[0])
  {
    if (v6 < v5)
    {
      result = *a2;
      *a2 = *(__n128 *)a3;
      *(__n128 *)a3 = result;
      if ((signed __int32)a2->n128_u32[0] < (signed __int32)a1->n128_u32[0])
      {
        result = *a1;
        *a1 = *a2;
        *a2 = result;
      }
    }
  }
  else
  {
    if (v6 < v5)
    {
      result = *a1;
      *a1 = *(__n128 *)a3;
LABEL_9:
      *(__n128 *)a3 = result;
      goto LABEL_10;
    }
    result = *a1;
    *a1 = *a2;
    *a2 = result;
    if (*a3 < (signed __int32)a2->n128_u32[0])
    {
      result = *a2;
      *a2 = *(__n128 *)a3;
      goto LABEL_9;
    }
  }
LABEL_10:
  if (*(_DWORD *)a4 < *a3)
  {
    result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (*a3 < (signed __int32)a2->n128_u32[0])
    {
      result = *a2;
      *a2 = *(__n128 *)a3;
      *(__n128 *)a3 = result;
      if ((signed __int32)a2->n128_u32[0] < (signed __int32)a1->n128_u32[0])
      {
        result = *a1;
        *a1 = *a2;
        *a2 = result;
      }
    }
  }
  return result;
}

void webrtc::FieldTrialStructList<webrtc::EncoderInfoSettings::BitrateLimit>::~FieldTrialStructList(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  *(_QWORD *)a1 = off_24C0B3B30;
  v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(_QWORD *)(a1 + 96) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_24C0B3F90;
  v3 = *(_QWORD **)(a1 + 64);
  if (v3)
  {
    v4 = *(_QWORD **)(a1 + 72);
    v5 = *(void **)(a1 + 64);
    if (v4 != v3)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v3);
      v5 = *(void **)(a1 + 64);
    }
    *(_QWORD *)(a1 + 72) = v3;
    operator delete(v5);
  }
  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v8 = *(void **)(a1 + 8);
    if (!v8)
      goto LABEL_16;
  }
  else
  {
    v8 = *(void **)(a1 + 8);
    if (!v8)
      goto LABEL_16;
  }
  *(_QWORD *)(a1 + 16) = v8;
  operator delete(v8);
LABEL_16:
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::FieldTrialStructList<webrtc::EncoderInfoSettings::BitrateLimit>::ParseDone(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  char *v8;
  char *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  void *v18;

  v1 = (_QWORD *)a1[8];
  v2 = (_QWORD *)a1[9];
  if (v1 != v2)
  {
    v4 = -1;
    do
    {
      if (*(_BYTE *)((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 24))(*v1) + 57))
        return;
      if (*(_BYTE *)((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 24))(*v1) + 58))
      {
        v5 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 24))(*v1);
        v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
        if (v4 == -1)
        {
          v4 = v6;
        }
        else if (v4 != v6)
        {
          return;
        }
      }
      ++v1;
    }
    while (v1 != v2);
    if (v4 != -1)
    {
      if (v4)
      {
        if (v4 < 0)
          goto LABEL_28;
        v7 = v4;
        v8 = (char *)operator new(16 * v4);
        bzero(v8, 16 * v4);
        v9 = &v8[16 * v4];
        v10 = (_QWORD *)a1[8];
        v11 = (_QWORD *)a1[9];
        if (v10 != v11)
        {
          v12 = v4;
          while (!*(_BYTE *)((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v10 + 24))(*v10) + 58))
          {
LABEL_15:
            if (++v10 == v11)
              goto LABEL_24;
          }
          v13 = 0;
          v14 = v8;
          while (v7 != v13)
          {
            (*(void (**)(_QWORD, char *, uint64_t))(*(_QWORD *)*v10 + 16))(*v10, v14, v13++);
            v14 += 16;
            if (v12 == v13)
              goto LABEL_15;
          }
          __break(1u);
LABEL_28:
          abort();
        }
      }
      else
      {
        v15 = (uint64_t *)a1[8];
        v16 = (uint64_t *)a1[9];
        while (v15 != v16)
        {
          v17 = *v15++;
          (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
        }
        v8 = 0;
        v9 = 0;
      }
LABEL_24:
      v18 = (void *)a1[11];
      a1[11] = v8;
      a1[12] = v9;
      a1[13] = v9;
      if (v18)
        operator delete(v18);
    }
  }
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0)::{lambda(void *,int)#1}>,void ()(void *,int)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_BYTE *std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_24C0B3B60;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24C0B3B60;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_0)::{lambda(void *,int)#1}>,void ()(void *,int)>::operator()(uint64_t a1, _DWORD **a2, _DWORD *a3)
{
  **a2 = *a3;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1)::{lambda(void *,int)#1}>,void ()(void *,int)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_BYTE *std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_24C0B3BA8;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24C0B3BA8;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_1)::{lambda(void *,int)#1}>,void ()(void *,int)>::operator()(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(_DWORD *)(*(_QWORD *)a2 + 4) = *a3;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2)::{lambda(void *,int)#1}>,void ()(void *,int)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_BYTE *std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_24C0B3BF0;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24C0B3BF0;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_2)::{lambda(void *,int)#1}>,void ()(void *,int)>::operator()(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(_DWORD *)(*(_QWORD *)a2 + 8) = *a3;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3)::{lambda(void *,int)#1}>,void ()(void *,int)>::~__func()
{
  JUMPOUT(0x20BD0ADECLL);
}

_BYTE *std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_24C0B3C38;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3)::{lambda(void *,int)#1}>,void ()(void *,int)>::__clone(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24C0B3C38;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

void std::__function::__func<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3)::{lambda(void *,int)#1},std::allocator<webrtc::FieldTrialListWrapper * webrtc::FieldTrialStructMember<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3,webrtc::field_trial_list_impl::LambdaTypeTraits<webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3>>(std::string_view,webrtc::EncoderInfoSettings::EncoderInfoSettings(webrtc::FieldTrialsView const&,std::string_view)::$_3)::{lambda(void *,int)#1}>,void ()(void *,int)>::operator()(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(_DWORD *)(*(_QWORD *)a2 + 12) = *a3;
}

void webrtc::EncoderOvershootDetector::UpdateHistograms(webrtc::EncoderOvershootDetector *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  int v5;
  const char *v6;
  size_t v7;
  char *v8;
  char *v9;
  char *v10;
  size_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  unint64_t v26;
  char *p_p;
  size_t v28;
  unint64_t v29;
  char *v30;
  size_t v31;
  unint64_t v32;
  char *v33;
  size_t v34;
  unint64_t v35;
  char *v36;
  size_t v37;
  unint64_t v38;
  char *v39;
  size_t v40;
  unint64_t v41;
  char *v42;
  size_t v43;
  unint64_t v44;
  char *v45;
  size_t v46;
  unint64_t v47;
  char *v48;
  size_t v49;
  unint64_t v50;
  char *v51;
  size_t v52;
  unint64_t v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;
  uint64_t v60;
  int v61;
  size_t v62;
  unint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  char *v68;
  int v70;
  size_t v71;
  unint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  char *v77;
  int v79;
  size_t v80;
  unint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  char *v86;
  int v88;
  size_t v89;
  unint64_t v90;
  char *v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  char *v95;
  int v97;
  size_t v98;
  unint64_t v99;
  char *v100;
  uint64_t v101;
  uint64_t v102;
  char *v103;
  char *v104;
  uint64_t v108;
  uint64_t v109;
  char *v110;
  char *v111;
  uint64_t v115;
  uint64_t v116;
  char *v117;
  char *v118;
  uint64_t v122;
  uint64_t v123;
  char *v124;
  char *v125;
  uint64_t v129;
  uint64_t v130;
  char *v131;
  char *v132;
  uint64_t v136;
  uint64_t v137;
  char *v138;
  char *v139;
  int v141;
  size_t v142;
  unint64_t v143;
  char *v144;
  uint64_t v145;
  uint64_t v146;
  char *v147;
  char *v148;
  int v150;
  size_t v151;
  unint64_t v152;
  char *v153;
  uint64_t v154;
  uint64_t v155;
  char *v156;
  char *v157;
  int v159;
  size_t v160;
  unint64_t v161;
  char *v162;
  uint64_t v163;
  uint64_t v164;
  char *v165;
  char *v166;
  int v168;
  size_t v169;
  unint64_t v170;
  char *v171;
  uint64_t v172;
  uint64_t v173;
  char *v174;
  char *v175;
  int v177;
  size_t v178;
  unint64_t v179;
  char *v180;
  uint64_t v181;
  uint64_t v182;
  char *v183;
  char *v184;
  uint64_t v188;
  uint64_t v189;
  char *v190;
  char *v191;
  uint64_t v195;
  uint64_t v196;
  char *v197;
  char *v198;
  uint64_t v202;
  uint64_t v203;
  char *v204;
  char *v205;
  uint64_t v209;
  uint64_t v210;
  char *v211;
  char *v212;
  void *__p;
  size_t v217;
  unint64_t v218;
  void *v219;
  size_t v220;
  uint64_t v221;
  void *v222;
  size_t v223;
  uint64_t v224;

  v1 = *((_QWORD *)this + 15);
  if (!v1)
    return;
  v4 = *((_QWORD *)this + 16);
  v3 = *((_QWORD *)this + 17);
  v5 = *((unsigned __int8 *)this + 116);
  if (*((_BYTE *)this + 116))
    v6 = "WebRTC.Video.Screenshare.RMSEOfEncodingBitrateInKbps.";
  else
    v6 = "WebRTC.Video.RMSEOfEncodingBitrateInKbps.";
  if (*((_BYTE *)this + 116))
    v7 = 53;
  else
    v7 = 41;
  v8 = (char *)operator new((v7 | 7) + 1);
  v9 = v8;
  v223 = v7;
  v224 = (v7 | 7) - 0x7FFFFFFFFFFFFFFFLL;
  v222 = v8;
  if (v8 <= v6 && &v8[v7] > v6)
    goto LABEL_631;
  memcpy(v8, v6, v7);
  v9[v7] = 0;
  v10 = v5 ? "WebRTC.Video.Screenshare.EncodingBitrateOvershoot." : "WebRTC.Video.EncodingBitrateOvershoot.";
  v11 = v5 ? 50 : 38;
  v12 = (char *)operator new((v11 | 7) + 1);
  v13 = v12;
  v220 = v11;
  v221 = (v11 | 7) - 0x7FFFFFFFFFFFFFFFLL;
  v219 = v12;
  if (v12 <= v10 && &v12[v11] > v10)
    goto LABEL_631;
  memcpy(v12, v10, v11);
  v13[v11] = 0;
  v14 = (uint64_t)sqrt((double)(v4 / v1));
  switch(*((_DWORD *)this + 28))
  {
    case 1:
      if (v5)
      {
        v15 = atomic_load(&qword_253EA5610);
        if (v15)
        {
          webrtc::metrics::HistogramAdd(v15, v14);
          goto LABEL_125;
        }
        if (v224 >= 0)
          v25 = HIBYTE(v224);
        else
          v25 = v223;
        v26 = v25 + 3;
        if (v25 + 3 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_632;
        if (v26 > 0x16)
        {
          v55 = (v26 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v26 | 7) != 0x17)
            v55 = v26 | 7;
          v56 = v55 + 1;
          p_p = (char *)operator new(v55 + 1);
          v217 = v25 + 3;
          v218 = v56 | 0x8000000000000000;
          __p = p_p;
        }
        else
        {
          v217 = 0;
          v218 = 0;
          __p = 0;
          p_p = (char *)&__p;
          HIBYTE(v218) = v25 + 3;
        }
        if (v224 >= 0)
          v57 = (char *)&v222;
        else
          v57 = (char *)v222;
        v58 = &p_p[v25];
        if (v57 < p_p || v58 <= v57)
        {
          if (v25)
            memmove(p_p, v57, v25);
          if (v58 > "Vp8" || v58 + 3 <= "Vp8")
          {
            *(_DWORD *)v58 = 3698774;
            if ((SHIBYTE(v218) & 0x80000000) == 0)
              goto LABEL_121;
            if ((v217 & 0x8000000000000000) == 0 && (!v217 || __p))
            {
              operator delete(__p);
LABEL_121:
              while (!__ldaxr(&qword_253EA5610))
              {
                if (!__stlxr(0, &qword_253EA5610))
                  goto LABEL_125;
              }
              __clrex();
LABEL_125:
              v60 = atomic_load(&qword_253EA5620);
              if (!v60)
              {
                v61 = SHIBYTE(v221);
                if (v221 >= 0)
                  v62 = HIBYTE(v221);
                else
                  v62 = v220;
                v63 = v62 + 3;
                if (v62 + 3 <= 0x7FFFFFFFFFFFFFF7)
                {
                  if (v63 > 0x16)
                  {
                    v101 = (v63 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v63 | 7) != 0x17)
                      v101 = v63 | 7;
                    v102 = v101 + 1;
                    v64 = (char *)operator new(v101 + 1);
                    v217 = v62 + 3;
                    v218 = v102 | 0x8000000000000000;
                    __p = v64;
                  }
                  else
                  {
                    v217 = 0;
                    v218 = 0;
                    __p = 0;
                    v64 = (char *)&__p;
                    HIBYTE(v218) = v62 + 3;
                  }
                  if (v61 >= 0)
                    v103 = (char *)&v219;
                  else
                    v103 = (char *)v219;
                  v104 = &v64[v62];
                  if (v103 < v64 || v104 <= v103)
                  {
                    if (v62)
                      memmove(v64, v103, v62);
                    if (v104 > "Vp8" || v104 + 3 <= "Vp8")
                    {
                      *(_DWORD *)v104 = 3698774;
                      if ((SHIBYTE(v218) & 0x80000000) == 0)
                        goto LABEL_265;
                      if ((v217 & 0x8000000000000000) == 0 && (!v217 || __p))
                      {
                        operator delete(__p);
LABEL_265:
                        while (!__ldaxr(&qword_253EA5620))
                        {
                          if (!__stlxr(0, &qword_253EA5620))
                            goto LABEL_626;
                        }
LABEL_625:
                        __clrex();
                        goto LABEL_626;
                      }
                    }
                  }
                  goto LABEL_631;
                }
LABEL_632:
                abort();
              }
              goto LABEL_498;
            }
          }
        }
LABEL_631:
        __break(1u);
        goto LABEL_632;
      }
      v20 = atomic_load(&qword_253EA5608);
      if (v20)
      {
        webrtc::metrics::HistogramAdd(v20, v14);
      }
      else
      {
        if (v224 >= 0)
          v40 = HIBYTE(v224);
        else
          v40 = v223;
        v41 = v40 + 3;
        if (v40 + 3 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_632;
        if (v41 > 0x16)
        {
          v136 = (v41 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v41 | 7) != 0x17)
            v136 = v41 | 7;
          v137 = v136 + 1;
          v42 = (char *)operator new(v136 + 1);
          v217 = v40 + 3;
          v218 = v137 | 0x8000000000000000;
          __p = v42;
        }
        else
        {
          v217 = 0;
          v218 = 0;
          __p = 0;
          v42 = (char *)&__p;
          HIBYTE(v218) = v40 + 3;
        }
        if (v224 >= 0)
          v138 = (char *)&v222;
        else
          v138 = (char *)v222;
        v139 = &v42[v40];
        if (v138 >= v42 && v139 > v138)
          goto LABEL_631;
        if (v40)
          memmove(v42, v138, v40);
        if (v139 <= "Vp8" && v139 + 3 > "Vp8")
          goto LABEL_631;
        *(_DWORD *)v139 = 3698774;
        if ((SHIBYTE(v218) & 0x80000000) == 0)
          goto LABEL_381;
        if ((v217 & 0x8000000000000000) != 0 || v217 && !__p)
          goto LABEL_631;
        operator delete(__p);
LABEL_381:
        while (!__ldaxr(&qword_253EA5608))
        {
          if (!__stlxr(0, &qword_253EA5608))
            goto LABEL_385;
        }
        __clrex();
      }
LABEL_385:
      v60 = atomic_load(&qword_253EA5618);
      if (!v60)
      {
        v141 = SHIBYTE(v221);
        if (v221 >= 0)
          v142 = HIBYTE(v221);
        else
          v142 = v220;
        v143 = v142 + 3;
        if (v142 + 3 <= 0x7FFFFFFFFFFFFFF7)
        {
          if (v143 > 0x16)
          {
            v181 = (v143 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v143 | 7) != 0x17)
              v181 = v143 | 7;
            v182 = v181 + 1;
            v144 = (char *)operator new(v181 + 1);
            v217 = v142 + 3;
            v218 = v182 | 0x8000000000000000;
            __p = v144;
          }
          else
          {
            v217 = 0;
            v218 = 0;
            __p = 0;
            v144 = (char *)&__p;
            HIBYTE(v218) = v142 + 3;
          }
          if (v141 >= 0)
            v183 = (char *)&v219;
          else
            v183 = (char *)v219;
          v184 = &v144[v142];
          if (v183 < v144 || v184 <= v183)
          {
            if (v142)
              memmove(v144, v183, v142);
            if (v184 > "Vp8" || v184 + 3 <= "Vp8")
            {
              *(_DWORD *)v184 = 3698774;
              if ((SHIBYTE(v218) & 0x80000000) == 0)
                goto LABEL_526;
              if ((v217 & 0x8000000000000000) == 0 && (!v217 || __p))
              {
                operator delete(__p);
LABEL_526:
                while (!__ldaxr(&qword_253EA5618))
                {
                  if (!__stlxr(0, &qword_253EA5618))
                    goto LABEL_626;
                }
                goto LABEL_625;
              }
            }
          }
          goto LABEL_631;
        }
        goto LABEL_632;
      }
LABEL_498:
      webrtc::metrics::HistogramAdd(v60, v3 / v1);
LABEL_626:
      if ((SHIBYTE(v221) & 0x80000000) == 0)
      {
        if ((SHIBYTE(v224) & 0x80000000) == 0)
          return;
LABEL_630:
        operator delete(v222);
        return;
      }
      operator delete(v219);
      if (SHIBYTE(v224) < 0)
        goto LABEL_630;
      return;
    case 2:
      if (v5)
      {
        v16 = atomic_load(&qword_253EA55F0);
        if (v16)
        {
          webrtc::metrics::HistogramAdd(v16, v14);
        }
        else
        {
          if (v224 >= 0)
            v28 = HIBYTE(v224);
          else
            v28 = v223;
          v29 = v28 + 3;
          if (v28 + 3 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_632;
          if (v29 > 0x16)
          {
            v65 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v29 | 7) != 0x17)
              v65 = v29 | 7;
            v66 = v65 + 1;
            v30 = (char *)operator new(v65 + 1);
            v217 = v28 + 3;
            v218 = v66 | 0x8000000000000000;
            __p = v30;
          }
          else
          {
            v217 = 0;
            v218 = 0;
            __p = 0;
            v30 = (char *)&__p;
            HIBYTE(v218) = v28 + 3;
          }
          if (v224 >= 0)
            v67 = (char *)&v222;
          else
            v67 = (char *)v222;
          v68 = &v30[v28];
          if (v67 >= v30 && v68 > v67)
            goto LABEL_631;
          if (v28)
            memmove(v30, v67, v28);
          if (v68 <= "Vp9" && v68 + 3 > "Vp9")
            goto LABEL_631;
          *(_DWORD *)v68 = 3764310;
          if ((SHIBYTE(v218) & 0x80000000) == 0)
            goto LABEL_149;
          if ((v217 & 0x8000000000000000) != 0 || v217 && !__p)
            goto LABEL_631;
          operator delete(__p);
LABEL_149:
          while (!__ldaxr(&qword_253EA55F0))
          {
            if (!__stlxr(0, &qword_253EA55F0))
              goto LABEL_153;
          }
          __clrex();
        }
LABEL_153:
        v60 = atomic_load(&qword_253EA5600);
        if (v60)
          goto LABEL_498;
        v70 = SHIBYTE(v221);
        if (v221 >= 0)
          v71 = HIBYTE(v221);
        else
          v71 = v220;
        v72 = v71 + 3;
        if (v71 + 3 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_632;
        if (v72 > 0x16)
        {
          v108 = (v72 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v72 | 7) != 0x17)
            v108 = v72 | 7;
          v109 = v108 + 1;
          v73 = (char *)operator new(v108 + 1);
          v217 = v71 + 3;
          v218 = v109 | 0x8000000000000000;
          __p = v73;
        }
        else
        {
          v217 = 0;
          v218 = 0;
          __p = 0;
          v73 = (char *)&__p;
          HIBYTE(v218) = v71 + 3;
        }
        if (v70 >= 0)
          v110 = (char *)&v219;
        else
          v110 = (char *)v219;
        v111 = &v73[v71];
        if (v110 < v73 || v111 <= v110)
        {
          if (v71)
            memmove(v73, v110, v71);
          if (v111 > "Vp9" || v111 + 3 <= "Vp9")
          {
            *(_DWORD *)v111 = 3764310;
            if ((SHIBYTE(v218) & 0x80000000) == 0)
              goto LABEL_289;
            if ((v217 & 0x8000000000000000) == 0 && (!v217 || __p))
            {
              operator delete(__p);
LABEL_289:
              while (!__ldaxr(&qword_253EA5600))
              {
                if (!__stlxr(0, &qword_253EA5600))
                  goto LABEL_626;
              }
              goto LABEL_625;
            }
          }
        }
      }
      else
      {
        v21 = atomic_load(&qword_253EA55E8);
        if (v21)
        {
          webrtc::metrics::HistogramAdd(v21, v14);
        }
        else
        {
          if (v224 >= 0)
            v43 = HIBYTE(v224);
          else
            v43 = v223;
          v44 = v43 + 3;
          if (v43 + 3 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_632;
          if (v44 > 0x16)
          {
            v145 = (v44 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v44 | 7) != 0x17)
              v145 = v44 | 7;
            v146 = v145 + 1;
            v45 = (char *)operator new(v145 + 1);
            v217 = v43 + 3;
            v218 = v146 | 0x8000000000000000;
            __p = v45;
          }
          else
          {
            v217 = 0;
            v218 = 0;
            __p = 0;
            v45 = (char *)&__p;
            HIBYTE(v218) = v43 + 3;
          }
          if (v224 >= 0)
            v147 = (char *)&v222;
          else
            v147 = (char *)v222;
          v148 = &v45[v43];
          if (v147 >= v45 && v148 > v147)
            goto LABEL_631;
          if (v43)
            memmove(v45, v147, v43);
          if (v148 <= "Vp9" && v148 + 3 > "Vp9")
            goto LABEL_631;
          *(_DWORD *)v148 = 3764310;
          if ((SHIBYTE(v218) & 0x80000000) == 0)
            goto LABEL_409;
          if ((v217 & 0x8000000000000000) != 0 || v217 && !__p)
            goto LABEL_631;
          operator delete(__p);
LABEL_409:
          while (!__ldaxr(&qword_253EA55E8))
          {
            if (!__stlxr(0, &qword_253EA55E8))
              goto LABEL_413;
          }
          __clrex();
        }
LABEL_413:
        v60 = atomic_load(&qword_253EA55F8);
        if (v60)
          goto LABEL_498;
        v150 = SHIBYTE(v221);
        if (v221 >= 0)
          v151 = HIBYTE(v221);
        else
          v151 = v220;
        v152 = v151 + 3;
        if (v151 + 3 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_632;
        if (v152 > 0x16)
        {
          v188 = (v152 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v152 | 7) != 0x17)
            v188 = v152 | 7;
          v189 = v188 + 1;
          v153 = (char *)operator new(v188 + 1);
          v217 = v151 + 3;
          v218 = v189 | 0x8000000000000000;
          __p = v153;
        }
        else
        {
          v217 = 0;
          v218 = 0;
          __p = 0;
          v153 = (char *)&__p;
          HIBYTE(v218) = v151 + 3;
        }
        if (v150 >= 0)
          v190 = (char *)&v219;
        else
          v190 = (char *)v219;
        v191 = &v153[v151];
        if (v190 < v153 || v191 <= v190)
        {
          if (v151)
            memmove(v153, v190, v151);
          if (v191 > "Vp9" || v191 + 3 <= "Vp9")
          {
            *(_DWORD *)v191 = 3764310;
            if ((SHIBYTE(v218) & 0x80000000) == 0)
              goto LABEL_550;
            if ((v217 & 0x8000000000000000) == 0 && (!v217 || __p))
            {
              operator delete(__p);
LABEL_550:
              while (!__ldaxr(&qword_253EA55F8))
              {
                if (!__stlxr(0, &qword_253EA55F8))
                  goto LABEL_626;
              }
              goto LABEL_625;
            }
          }
        }
      }
      goto LABEL_631;
    case 3:
      if (v5)
      {
        v17 = atomic_load(&qword_253EA55D0);
        if (v17)
        {
          webrtc::metrics::HistogramAdd(v17, v14);
        }
        else
        {
          if (v224 >= 0)
            v31 = HIBYTE(v224);
          else
            v31 = v223;
          v32 = v31 + 3;
          if (v31 + 3 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_632;
          if (v32 > 0x16)
          {
            v74 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v32 | 7) != 0x17)
              v74 = v32 | 7;
            v75 = v74 + 1;
            v33 = (char *)operator new(v74 + 1);
            v217 = v31 + 3;
            v218 = v75 | 0x8000000000000000;
            __p = v33;
          }
          else
          {
            v217 = 0;
            v218 = 0;
            __p = 0;
            v33 = (char *)&__p;
            HIBYTE(v218) = v31 + 3;
          }
          if (v224 >= 0)
            v76 = (char *)&v222;
          else
            v76 = (char *)v222;
          v77 = &v33[v31];
          if (v76 >= v33 && v77 > v76)
            goto LABEL_631;
          if (v31)
            memmove(v33, v76, v31);
          if (v77 <= "Av1" && v77 + 3 > "Av1")
            goto LABEL_631;
          *(_DWORD *)v77 = 3241537;
          if ((SHIBYTE(v218) & 0x80000000) == 0)
            goto LABEL_177;
          if ((v217 & 0x8000000000000000) != 0 || v217 && !__p)
            goto LABEL_631;
          operator delete(__p);
LABEL_177:
          while (!__ldaxr(&qword_253EA55D0))
          {
            if (!__stlxr(0, &qword_253EA55D0))
              goto LABEL_181;
          }
          __clrex();
        }
LABEL_181:
        v60 = atomic_load(&qword_253EA55E0);
        if (v60)
          goto LABEL_498;
        v79 = SHIBYTE(v221);
        if (v221 >= 0)
          v80 = HIBYTE(v221);
        else
          v80 = v220;
        v81 = v80 + 3;
        if (v80 + 3 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_632;
        if (v81 > 0x16)
        {
          v115 = (v81 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v81 | 7) != 0x17)
            v115 = v81 | 7;
          v116 = v115 + 1;
          v82 = (char *)operator new(v115 + 1);
          v217 = v80 + 3;
          v218 = v116 | 0x8000000000000000;
          __p = v82;
        }
        else
        {
          v217 = 0;
          v218 = 0;
          __p = 0;
          v82 = (char *)&__p;
          HIBYTE(v218) = v80 + 3;
        }
        if (v79 >= 0)
          v117 = (char *)&v219;
        else
          v117 = (char *)v219;
        v118 = &v82[v80];
        if (v117 < v82 || v118 <= v117)
        {
          if (v80)
            memmove(v82, v117, v80);
          if (v118 > "Av1" || v118 + 3 <= "Av1")
          {
            *(_DWORD *)v118 = 3241537;
            if ((SHIBYTE(v218) & 0x80000000) == 0)
              goto LABEL_313;
            if ((v217 & 0x8000000000000000) == 0 && (!v217 || __p))
            {
              operator delete(__p);
LABEL_313:
              while (!__ldaxr(&qword_253EA55E0))
              {
                if (!__stlxr(0, &qword_253EA55E0))
                  goto LABEL_626;
              }
              goto LABEL_625;
            }
          }
        }
      }
      else
      {
        v22 = atomic_load(&_MergedGlobals_10);
        if (v22)
        {
          webrtc::metrics::HistogramAdd(v22, v14);
        }
        else
        {
          if (v224 >= 0)
            v46 = HIBYTE(v224);
          else
            v46 = v223;
          v47 = v46 + 3;
          if (v46 + 3 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_632;
          if (v47 > 0x16)
          {
            v154 = (v47 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v47 | 7) != 0x17)
              v154 = v47 | 7;
            v155 = v154 + 1;
            v48 = (char *)operator new(v154 + 1);
            v217 = v46 + 3;
            v218 = v155 | 0x8000000000000000;
            __p = v48;
          }
          else
          {
            v217 = 0;
            v218 = 0;
            __p = 0;
            v48 = (char *)&__p;
            HIBYTE(v218) = v46 + 3;
          }
          if (v224 >= 0)
            v156 = (char *)&v222;
          else
            v156 = (char *)v222;
          v157 = &v48[v46];
          if (v156 >= v48 && v157 > v156)
            goto LABEL_631;
          if (v46)
            memmove(v48, v156, v46);
          if (v157 <= "Av1" && v157 + 3 > "Av1")
            goto LABEL_631;
          *(_DWORD *)v157 = 3241537;
          if ((SHIBYTE(v218) & 0x80000000) == 0)
            goto LABEL_437;
          if ((v217 & 0x8000000000000000) != 0 || v217 && !__p)
            goto LABEL_631;
          operator delete(__p);
LABEL_437:
          while (!__ldaxr(&_MergedGlobals_10))
          {
            if (!__stlxr(0, &_MergedGlobals_10))
              goto LABEL_441;
          }
          __clrex();
        }
LABEL_441:
        v60 = atomic_load(&qword_253EA55D8);
        if (v60)
          goto LABEL_498;
        v159 = SHIBYTE(v221);
        if (v221 >= 0)
          v160 = HIBYTE(v221);
        else
          v160 = v220;
        v161 = v160 + 3;
        if (v160 + 3 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_632;
        if (v161 > 0x16)
        {
          v195 = (v161 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v161 | 7) != 0x17)
            v195 = v161 | 7;
          v196 = v195 + 1;
          v162 = (char *)operator new(v195 + 1);
          v217 = v160 + 3;
          v218 = v196 | 0x8000000000000000;
          __p = v162;
        }
        else
        {
          v217 = 0;
          v218 = 0;
          __p = 0;
          v162 = (char *)&__p;
          HIBYTE(v218) = v160 + 3;
        }
        if (v159 >= 0)
          v197 = (char *)&v219;
        else
          v197 = (char *)v219;
        v198 = &v162[v160];
        if (v197 < v162 || v198 <= v197)
        {
          if (v160)
            memmove(v162, v197, v160);
          if (v198 > "Av1" || v198 + 3 <= "Av1")
          {
            *(_DWORD *)v198 = 3241537;
            if ((SHIBYTE(v218) & 0x80000000) == 0)
              goto LABEL_574;
            if ((v217 & 0x8000000000000000) == 0 && (!v217 || __p))
            {
              operator delete(__p);
LABEL_574:
              while (!__ldaxr(&qword_253EA55D8))
              {
                if (!__stlxr(0, &qword_253EA55D8))
                  goto LABEL_626;
              }
              goto LABEL_625;
            }
          }
        }
      }
      goto LABEL_631;
    case 4:
      if (v5)
      {
        v18 = atomic_load(&qword_253EA5630);
        if (v18)
        {
          webrtc::metrics::HistogramAdd(v18, v14);
        }
        else
        {
          if (v224 >= 0)
            v34 = HIBYTE(v224);
          else
            v34 = v223;
          v35 = v34 + 4;
          if (v34 + 4 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_632;
          if (v35 > 0x16)
          {
            v83 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v35 | 7) != 0x17)
              v83 = v35 | 7;
            v84 = v83 + 1;
            v36 = (char *)operator new(v83 + 1);
            v217 = v34 + 4;
            v218 = v84 | 0x8000000000000000;
            __p = v36;
          }
          else
          {
            v217 = 0;
            v218 = 0;
            __p = 0;
            v36 = (char *)&__p;
            HIBYTE(v218) = v34 + 4;
          }
          if (v224 >= 0)
            v85 = (char *)&v222;
          else
            v85 = (char *)v222;
          v86 = &v36[v34];
          if (v85 >= v36 && v86 > v85)
            goto LABEL_631;
          if (v34)
            memmove(v36, v85, v34);
          if (v86 <= "H264" && v86 + 4 > "H264")
            goto LABEL_631;
          strcpy(v86, "H264");
          if ((SHIBYTE(v218) & 0x80000000) == 0)
            goto LABEL_205;
          if ((v217 & 0x8000000000000000) != 0 || v217 && !__p)
            goto LABEL_631;
          operator delete(__p);
LABEL_205:
          while (!__ldaxr(&qword_253EA5630))
          {
            if (!__stlxr(0, &qword_253EA5630))
              goto LABEL_209;
          }
          __clrex();
        }
LABEL_209:
        v60 = atomic_load(&qword_253EA5640);
        if (v60)
          goto LABEL_498;
        v88 = SHIBYTE(v221);
        if (v221 >= 0)
          v89 = HIBYTE(v221);
        else
          v89 = v220;
        v90 = v89 + 4;
        if (v89 + 4 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_632;
        if (v90 > 0x16)
        {
          v122 = (v90 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v90 | 7) != 0x17)
            v122 = v90 | 7;
          v123 = v122 + 1;
          v91 = (char *)operator new(v122 + 1);
          v217 = v89 + 4;
          v218 = v123 | 0x8000000000000000;
          __p = v91;
        }
        else
        {
          v217 = 0;
          v218 = 0;
          __p = 0;
          v91 = (char *)&__p;
          HIBYTE(v218) = v89 + 4;
        }
        if (v88 >= 0)
          v124 = (char *)&v219;
        else
          v124 = (char *)v219;
        v125 = &v91[v89];
        if (v124 < v91 || v125 <= v124)
        {
          if (v89)
            memmove(v91, v124, v89);
          if (v125 > "H264" || v125 + 4 <= "H264")
          {
            strcpy(v125, "H264");
            if ((SHIBYTE(v218) & 0x80000000) == 0)
              goto LABEL_337;
            if ((v217 & 0x8000000000000000) == 0 && (!v217 || __p))
            {
              operator delete(__p);
LABEL_337:
              while (!__ldaxr(&qword_253EA5640))
              {
                if (!__stlxr(0, &qword_253EA5640))
                  goto LABEL_626;
              }
              goto LABEL_625;
            }
          }
        }
      }
      else
      {
        v23 = atomic_load(&qword_253EA5628);
        if (v23)
        {
          webrtc::metrics::HistogramAdd(v23, v14);
        }
        else
        {
          if (v224 >= 0)
            v49 = HIBYTE(v224);
          else
            v49 = v223;
          v50 = v49 + 4;
          if (v49 + 4 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_632;
          if (v50 > 0x16)
          {
            v163 = (v50 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v50 | 7) != 0x17)
              v163 = v50 | 7;
            v164 = v163 + 1;
            v51 = (char *)operator new(v163 + 1);
            v217 = v49 + 4;
            v218 = v164 | 0x8000000000000000;
            __p = v51;
          }
          else
          {
            v217 = 0;
            v218 = 0;
            __p = 0;
            v51 = (char *)&__p;
            HIBYTE(v218) = v49 + 4;
          }
          if (v224 >= 0)
            v165 = (char *)&v222;
          else
            v165 = (char *)v222;
          v166 = &v51[v49];
          if (v165 >= v51 && v166 > v165)
            goto LABEL_631;
          if (v49)
            memmove(v51, v165, v49);
          if (v166 <= "H264" && v166 + 4 > "H264")
            goto LABEL_631;
          strcpy(v166, "H264");
          if ((SHIBYTE(v218) & 0x80000000) == 0)
            goto LABEL_465;
          if ((v217 & 0x8000000000000000) != 0 || v217 && !__p)
            goto LABEL_631;
          operator delete(__p);
LABEL_465:
          while (!__ldaxr(&qword_253EA5628))
          {
            if (!__stlxr(0, &qword_253EA5628))
              goto LABEL_469;
          }
          __clrex();
        }
LABEL_469:
        v60 = atomic_load(&qword_253EA5638);
        if (v60)
          goto LABEL_498;
        v168 = SHIBYTE(v221);
        if (v221 >= 0)
          v169 = HIBYTE(v221);
        else
          v169 = v220;
        v170 = v169 + 4;
        if (v169 + 4 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_632;
        if (v170 > 0x16)
        {
          v202 = (v170 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v170 | 7) != 0x17)
            v202 = v170 | 7;
          v203 = v202 + 1;
          v171 = (char *)operator new(v202 + 1);
          v217 = v169 + 4;
          v218 = v203 | 0x8000000000000000;
          __p = v171;
        }
        else
        {
          v217 = 0;
          v218 = 0;
          __p = 0;
          v171 = (char *)&__p;
          HIBYTE(v218) = v169 + 4;
        }
        if (v168 >= 0)
          v204 = (char *)&v219;
        else
          v204 = (char *)v219;
        v205 = &v171[v169];
        if (v204 < v171 || v205 <= v204)
        {
          if (v169)
            memmove(v171, v204, v169);
          if (v205 > "H264" || v205 + 4 <= "H264")
          {
            strcpy(v205, "H264");
            if ((SHIBYTE(v218) & 0x80000000) == 0)
              goto LABEL_598;
            if ((v217 & 0x8000000000000000) == 0 && (!v217 || __p))
            {
              operator delete(__p);
LABEL_598:
              while (!__ldaxr(&qword_253EA5638))
              {
                if (!__stlxr(0, &qword_253EA5638))
                  goto LABEL_626;
              }
              goto LABEL_625;
            }
          }
        }
      }
      goto LABEL_631;
    case 5:
      if (v5)
      {
        v19 = atomic_load(&qword_253EA5650);
        if (v19)
        {
          webrtc::metrics::HistogramAdd(v19, v14);
        }
        else
        {
          if (v224 >= 0)
            v37 = HIBYTE(v224);
          else
            v37 = v223;
          v38 = v37 + 4;
          if (v37 + 4 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_632;
          if (v38 > 0x16)
          {
            v92 = (v38 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v38 | 7) != 0x17)
              v92 = v38 | 7;
            v93 = v92 + 1;
            v39 = (char *)operator new(v92 + 1);
            v217 = v37 + 4;
            v218 = v93 | 0x8000000000000000;
            __p = v39;
          }
          else
          {
            v217 = 0;
            v218 = 0;
            __p = 0;
            v39 = (char *)&__p;
            HIBYTE(v218) = v37 + 4;
          }
          if (v224 >= 0)
            v94 = (char *)&v222;
          else
            v94 = (char *)v222;
          v95 = &v39[v37];
          if (v94 >= v39 && v95 > v94)
            goto LABEL_631;
          if (v37)
            memmove(v39, v94, v37);
          if (v95 <= "H265" && v95 + 4 > "H265")
            goto LABEL_631;
          strcpy(v95, "H265");
          if ((SHIBYTE(v218) & 0x80000000) == 0)
            goto LABEL_233;
          if ((v217 & 0x8000000000000000) != 0 || v217 && !__p)
            goto LABEL_631;
          operator delete(__p);
LABEL_233:
          while (!__ldaxr(&qword_253EA5650))
          {
            if (!__stlxr(0, &qword_253EA5650))
              goto LABEL_237;
          }
          __clrex();
        }
LABEL_237:
        v60 = atomic_load(&qword_253EA5660);
        if (v60)
          goto LABEL_498;
        v97 = SHIBYTE(v221);
        if (v221 >= 0)
          v98 = HIBYTE(v221);
        else
          v98 = v220;
        v99 = v98 + 4;
        if (v98 + 4 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_632;
        if (v99 > 0x16)
        {
          v129 = (v99 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v99 | 7) != 0x17)
            v129 = v99 | 7;
          v130 = v129 + 1;
          v100 = (char *)operator new(v129 + 1);
          v217 = v98 + 4;
          v218 = v130 | 0x8000000000000000;
          __p = v100;
        }
        else
        {
          v217 = 0;
          v218 = 0;
          __p = 0;
          v100 = (char *)&__p;
          HIBYTE(v218) = v98 + 4;
        }
        if (v97 >= 0)
          v131 = (char *)&v219;
        else
          v131 = (char *)v219;
        v132 = &v100[v98];
        if (v131 < v100 || v132 <= v131)
        {
          if (v98)
            memmove(v100, v131, v98);
          if (v132 > "H265" || v132 + 4 <= "H265")
          {
            strcpy(v132, "H265");
            if ((SHIBYTE(v218) & 0x80000000) == 0)
              goto LABEL_361;
            if ((v217 & 0x8000000000000000) == 0 && (!v217 || __p))
            {
              operator delete(__p);
LABEL_361:
              while (!__ldaxr(&qword_253EA5660))
              {
                if (!__stlxr(0, &qword_253EA5660))
                  goto LABEL_626;
              }
              goto LABEL_625;
            }
          }
        }
      }
      else
      {
        v24 = atomic_load(&qword_253EA5648);
        if (v24)
        {
          webrtc::metrics::HistogramAdd(v24, v14);
        }
        else
        {
          if (v224 >= 0)
            v52 = HIBYTE(v224);
          else
            v52 = v223;
          v53 = v52 + 4;
          if (v52 + 4 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_632;
          if (v53 > 0x16)
          {
            v172 = (v53 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v53 | 7) != 0x17)
              v172 = v53 | 7;
            v173 = v172 + 1;
            v54 = (char *)operator new(v172 + 1);
            v217 = v52 + 4;
            v218 = v173 | 0x8000000000000000;
            __p = v54;
          }
          else
          {
            v217 = 0;
            v218 = 0;
            __p = 0;
            v54 = (char *)&__p;
            HIBYTE(v218) = v52 + 4;
          }
          if (v224 >= 0)
            v174 = (char *)&v222;
          else
            v174 = (char *)v222;
          v175 = &v54[v52];
          if (v174 >= v54 && v175 > v174)
            goto LABEL_631;
          if (v52)
            memmove(v54, v174, v52);
          if (v175 <= "H265" && v175 + 4 > "H265")
            goto LABEL_631;
          strcpy(v175, "H265");
          if ((SHIBYTE(v218) & 0x80000000) == 0)
            goto LABEL_493;
          if ((v217 & 0x8000000000000000) != 0 || v217 && !__p)
            goto LABEL_631;
          operator delete(__p);
LABEL_493:
          while (!__ldaxr(&qword_253EA5648))
          {
            if (!__stlxr(0, &qword_253EA5648))
              goto LABEL_497;
          }
          __clrex();
        }
LABEL_497:
        v60 = atomic_load(&qword_253EA5658);
        if (v60)
          goto LABEL_498;
        v177 = SHIBYTE(v221);
        if (v221 >= 0)
          v178 = HIBYTE(v221);
        else
          v178 = v220;
        v179 = v178 + 4;
        if (v178 + 4 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_632;
        if (v179 > 0x16)
        {
          v209 = (v179 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v179 | 7) != 0x17)
            v209 = v179 | 7;
          v210 = v209 + 1;
          v180 = (char *)operator new(v209 + 1);
          v217 = v178 + 4;
          v218 = v210 | 0x8000000000000000;
          __p = v180;
        }
        else
        {
          v217 = 0;
          v218 = 0;
          __p = 0;
          v180 = (char *)&__p;
          HIBYTE(v218) = v178 + 4;
        }
        if (v177 >= 0)
          v211 = (char *)&v219;
        else
          v211 = (char *)v219;
        v212 = &v180[v178];
        if (v211 < v180 || v212 <= v211)
        {
          if (v178)
            memmove(v180, v211, v178);
          if (v212 > "H265" || v212 + 4 <= "H265")
          {
            strcpy(v212, "H265");
            if ((SHIBYTE(v218) & 0x80000000) == 0)
              goto LABEL_622;
            if ((v217 & 0x8000000000000000) == 0 && (!v217 || __p))
            {
              operator delete(__p);
LABEL_622:
              while (!__ldaxr(&qword_253EA5658))
              {
                if (!__stlxr(0, &qword_253EA5658))
                  goto LABEL_626;
              }
              goto LABEL_625;
            }
          }
        }
      }
      goto LABEL_631;
    default:
      goto LABEL_626;
  }
}

void webrtc::EncoderOvershootDetector::SetTargetRate(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  int8x16_t v11;
  int64x2_t v12;
  void **v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  void **v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v7 = *(_QWORD *)(a1 + 80);
  if (v7)
  {
    v8 = *(_QWORD *)(a1 + 8);
    if (v7 >= 1 && v8 != -1)
    {
      v10 = (unsigned __int128)((a3 - v8) * v7 * (__int128)(uint64_t)0xDF3B645A1CAC0831) >> 64;
      v11 = (int8x16_t)vaddq_s64(vdupq_n_s64((v10 >> 7) + ((unint64_t)v10 >> 63)), *(int64x2_t *)(a1 + 96));
      v12.i64[0] = 0;
      v12.i64[1] = (uint64_t)(-fmin(*(double *)(a1 + 88), 5.0) / *(double *)(a1 + 88) * (double)v7);
      *(int8x16_t *)(a1 + 96) = vbslq_s8((int8x16_t)vcgtq_s64((int64x2_t)v11, v12), v11, (int8x16_t)v12);
    }
    *(_QWORD *)(a1 + 8) = a3;
    goto LABEL_8;
  }
  if (!a2)
  {
LABEL_8:
    *(_QWORD *)(a1 + 80) = a2;
    *(double *)(a1 + 88) = a4;
    return;
  }
  *(_QWORD *)(a1 + 8) = a3;
  v13 = *(void ***)(a1 + 24);
  v14 = *(_QWORD *)(a1 + 32) - (_QWORD)v13;
  if (v14)
  {
    v15 = (_QWORD *)(a1 + 56);
    v16 = *(_QWORD *)(a1 + 48);
    v17 = &v13[v16 / 0xAA];
    v18 = (unint64_t)*v17;
    v19 = (unint64_t)*v17 + 24 * (v16 % 0xAA);
    while ((void *)v19 != (char *)v13[(*(_QWORD *)(a1 + 56) + v16) / 0xAA] + 24 * ((*(_QWORD *)(a1 + 56) + v16) % 0xAA))
    {
      if (!v19)
      {
        __break(1u);
        return;
      }
      v19 += 24;
      if (v19 - v18 == 4080)
      {
        v20 = (unint64_t)v17[1];
        ++v17;
        v18 = v20;
        v19 = v20;
      }
    }
  }
  else
  {
    v15 = (_QWORD *)(a1 + 56);
  }
  *v15 = 0;
  if (v14 >= 0x11)
  {
    do
    {
      operator delete(*v13);
      v21 = *(_QWORD *)(a1 + 32);
      v13 = (void **)(*(_QWORD *)(a1 + 24) + 8);
      *(_QWORD *)(a1 + 24) = v13;
      v14 = v21 - (_QWORD)v13;
    }
    while (v14 > 0x10);
  }
  if (v14 >> 3 == 1)
  {
    v22 = 85;
    goto LABEL_23;
  }
  if (v14 >> 3 == 2)
  {
    v22 = 170;
LABEL_23:
    *(_QWORD *)(a1 + 48) = v22;
  }
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 80) = a2;
  *(double *)(a1 + 88) = a4;
}

void webrtc::EncoderOvershootDetector::OnEncodedFrame(webrtc::EncoderOvershootDetector *this, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int8x16_t v8;
  int64x2_t v9;
  double v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  unint64_t v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int64_t v33;
  uint64_t v34;
  double v35;
  char *v36;
  uint64_t v37;
  char *v38;
  char *v39;
  void *v40;
  void *v41;
  unint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  void *v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  int64_t v54;
  char *v55;
  char *v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  BOOL v62;
  int64_t v63;
  unint64_t v64;
  char *v65;
  unint64_t v66;
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  void *v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  char *v79;
  int64_t v80;
  unint64_t v81;
  char *v82;
  char *v83;
  uint64_t v84;
  uint64_t v85;
  __int128 *v86;
  char *v87;
  uint64_t v88;
  __int128 v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  uint64_t v93;
  char *v94;
  char *v95;
  char *v96;
  char *v97;
  char *v98;
  unint64_t v99;
  uint64_t v100;
  __int128 *v101;
  _OWORD *v102;
  uint64_t v103;
  __int128 v104;
  uint64_t v105;
  char *v106;
  char *v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  char *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  char *v118;
  int64_t v119;
  char *v120;
  uint64_t v121;
  uint64_t v122;
  __int128 *v123;
  _OWORD *v124;
  uint64_t v125;
  __int128 v126;
  uint64_t v127;
  unint64_t v128;
  unint64_t v129;
  uint64_t v130;
  char *v131;
  char *v132;
  int64_t v133;
  unint64_t v134;
  char *v135;
  char *v136;
  uint64_t v137;
  uint64_t v138;
  char *v139;
  __int128 *v140;
  _OWORD *v141;
  uint64_t v142;
  __int128 v143;
  uint64_t v144;
  uint64_t v145;

  v5 = *((_QWORD *)this + 1);
  if (v5 != -1)
  {
    v6 = *((_QWORD *)this + 10);
    if (v6 >= 1)
    {
      v7 = (unsigned __int128)(v6 * (a3 - v5) * (__int128)(uint64_t)0xDF3B645A1CAC0831) >> 64;
      v8 = (int8x16_t)vaddq_s64(vdupq_n_s64((v7 >> 7) + ((unint64_t)v7 >> 63)), *((int64x2_t *)this + 6));
      v9.i64[0] = 0;
      v9.i64[1] = (uint64_t)(-fmin(*((double *)this + 11), 5.0) / *((double *)this + 11) * (double)v6);
      *((int8x16_t *)this + 6) = vbslq_s8((int8x16_t)vcgtq_s64((int64x2_t)v8, v9), v8, (int8x16_t)v9);
    }
  }
  *((_QWORD *)this + 1) = a3;
  v10 = *((double *)this + 11);
  if (v10 > 0.0)
  {
    v11 = *((_QWORD *)this + 10);
    if (v11)
    {
      v12 = (uint64_t)((v10 * 0.5 + (double)v11) / v10);
      if (v12)
      {
        v13 = 8 * a2;
        v14 = *((_QWORD *)this + 12);
        v15 = *((_QWORD *)this + 13);
        v16 = v14 + 8 * a2;
        if (v16 - v12 < v14)
          v14 = v16 - v12;
        if (v16 <= v12)
          v17 = 0;
        else
          v17 = v14;
        v18 = fmax((double)(unint64_t)v13 / (double)v12, 1.0);
        v20 = *((_QWORD *)this + 6);
        v19 = *((_QWORD *)this + 7);
        if (v19)
          v21 = (double)v17 / (double)v12 + 1.0;
        else
          v21 = v18;
        v22 = v15 + v13;
        if (v15 + v13 - v12 < v15)
          v15 = v15 + v13 - v12;
        if (v22 <= v12)
          v15 = 0;
        v23 = v16 - v17;
        if (v19)
          v24 = (double)v15 / (double)v12 + 1.0;
        else
          v24 = v18;
        v25 = (char *)*((_QWORD *)this + 3);
        v26 = (char *)*((_QWORD *)this + 4);
        v27 = (v26 - v25) >> 3;
        *((_QWORD *)this + 12) = v23;
        *((_QWORD *)this + 13) = v22 - v15;
        v28 = (unsigned __int128)((v13 - v12) * (__int128)0x20C49BA5E353F7CFLL) >> 64;
        v29 = (v28 >> 7) + ((unint64_t)v28 >> 63);
        v30 = *((_QWORD *)this + 15);
        v31 = *((_QWORD *)this + 16) + v29 * v29;
        v32 = *((_QWORD *)this + 17) + 100000 * v29 / v12;
        v33 = v26 - v25;
        if (v26 == v25)
          v34 = 0;
        else
          v34 = 170 * v27 - 1;
        v35 = v24 + *((double *)this + 9);
        *((double *)this + 8) = v21 + *((double *)this + 8);
        *((double *)this + 9) = v35;
        *((_QWORD *)this + 16) = v31;
        *((_QWORD *)this + 17) = v32;
        *((_QWORD *)this + 15) = v30 + 1;
        if (v34 != v20 + v19)
        {
LABEL_104:
          if (v26 != v25)
          {
            v109 = v19 + v20;
            v110 = (v19 + v20) / 0xAA;
            v111 = *(_QWORD *)&v25[8 * v110];
            if (v111)
            {
              v112 = v111 + 24 * (v109 - 170 * v110);
              *(double *)v112 = v21;
              *(double *)(v112 + 8) = v24;
              *(_QWORD *)(v112 + 16) = a3;
              *((_QWORD *)this + 7) = v19 + 1;
              return;
            }
          }
          goto LABEL_135;
        }
        if (v20 >= 0xAA)
        {
          *((_QWORD *)this + 6) = v20 - 170;
          v36 = v25 + 8;
          v37 = *(_QWORD *)v25;
          *((_QWORD *)this + 3) = v25 + 8;
          if (v26 != *((char **)this + 5))
            goto LABEL_28;
          v48 = (char *)*((_QWORD *)this + 2);
          if (v36 > v48)
          {
            v49 = (v36 - v48) >> 3;
            if (v49 >= -1)
              v50 = v49 + 1;
            else
              v50 = v49 + 2;
            v51 = v50 >> 1;
            v52 = -v51;
            v53 = &v36[-8 * v51];
            v54 = v26 - v36;
            if (v26 != v36)
            {
              memmove(&v36[-8 * v51], v36, v26 - v36);
              v26 = (char *)*((_QWORD *)this + 3);
            }
            v55 = &v26[8 * v52];
            v26 = &v53[v54];
            *((_QWORD *)this + 3) = v55;
            *((_QWORD *)this + 4) = &v53[v54];
            goto LABEL_29;
          }
          v57 = (v26 - v48) >> 2;
          if (v26 == v48)
            v57 = 1;
          if (!(v57 >> 61))
          {
            v58 = v57 >> 2;
            v59 = 8 * v57;
            v60 = (char *)operator new(8 * v57);
            v61 = &v60[8 * v58];
            v63 = v26 - v36;
            v62 = v26 == v36;
            v26 = v61;
            if (v62)
              goto LABEL_120;
            v26 = &v61[v63 & 0xFFFFFFFFFFFFFFF8];
            v64 = v63 - 8;
            if ((unint64_t)(v63 - 8) >= 0x38)
            {
              v120 = &v60[8 * v58];
              v65 = v120;
              if ((unint64_t)(v120 - v36) >= 0x20)
              {
                v121 = (v64 >> 3) + 1;
                v122 = 8 * (v121 & 0x3FFFFFFFFFFFFFFCLL);
                v65 = &v61[v122];
                v36 += v122;
                v123 = (__int128 *)(v25 + 24);
                v124 = v120 + 16;
                v125 = v121 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  v126 = *v123;
                  *(v124 - 1) = *(v123 - 1);
                  *v124 = v126;
                  v123 += 2;
                  v124 += 2;
                  v125 -= 4;
                }
                while (v125);
                if (v121 == (v121 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_120:
                  *((_QWORD *)this + 2) = v60;
                  *((_QWORD *)this + 3) = v61;
                  *((_QWORD *)this + 4) = v26;
                  *((_QWORD *)this + 5) = &v60[v59];
                  if (v48)
                  {
                    operator delete(v48);
                    v26 = (char *)*((_QWORD *)this + 4);
                  }
LABEL_28:
                  if (v26)
                  {
LABEL_29:
                    *(_QWORD *)v26 = v37;
LABEL_102:
                    v26 = (char *)(*((_QWORD *)this + 4) + 8);
                    *((_QWORD *)this + 4) = v26;
LABEL_103:
                    v20 = *((_QWORD *)this + 6);
                    v19 = *((_QWORD *)this + 7);
                    v25 = (char *)*((_QWORD *)this + 3);
                    goto LABEL_104;
                  }
LABEL_135:
                  __break(1u);
                  goto LABEL_136;
                }
              }
            }
            else
            {
              v65 = &v60[8 * v58];
            }
            do
            {
              v127 = *(_QWORD *)v36;
              v36 += 8;
              *(_QWORD *)v65 = v127;
              v65 += 8;
            }
            while (v65 != v26);
            goto LABEL_120;
          }
LABEL_136:
          std::__throw_bad_array_new_length[abi:sn180100]();
        }
        v38 = (char *)*((_QWORD *)this + 5);
        v39 = (char *)*((_QWORD *)this + 2);
        if (v27 >= (unint64_t)((v38 - v39) >> 3))
        {
          v145 = v26 - v25;
          if (v38 == v39)
            v42 = 1;
          else
            v42 = (v38 - v39) >> 2;
          if (v42 >> 61)
            goto LABEL_136;
          v43 = (char *)operator new(8 * v42);
          v44 = &v43[8 * v27];
          v45 = &v43[8 * v42];
          v46 = operator new(0xFF0uLL);
          if (v27 == v42)
          {
            if (v145 < 1)
            {
              v66 = v145 >> 2;
              if (v26 == v25)
                v66 = 1;
              if (v66 >> 61)
                goto LABEL_136;
              v67 = 8 * v66;
              v44 = (char *)operator new(8 * v66);
              operator delete(v43);
              v45 = &v44[v67];
              v25 = (char *)*((_QWORD *)this + 3);
              v26 = (char *)*((_QWORD *)this + 4);
              v43 = v44;
            }
            else
            {
              v47 = v27 + 2;
              if (v27 >= -1)
                v47 = v27 + 1;
              v44 -= 8 * (v47 >> 1);
            }
          }
          *(_QWORD *)v44 = v46;
          v68 = v44 + 8;
          if (v26 != v25)
          {
            while (1)
            {
              if (v44 == v43)
              {
                if (v68 >= v45)
                {
                  v76 = (v45 - v44) >> 2;
                  if (v45 == v44)
                    v76 = 1;
                  if (v76 >> 61)
                    goto LABEL_136;
                  v77 = (v76 + 3) >> 2;
                  v78 = 8 * v76;
                  v79 = (char *)operator new(8 * v76);
                  v43 = v79;
                  v72 = &v79[8 * v77];
                  v70 = v72;
                  v80 = v68 - v44;
                  if (v68 != v44)
                  {
                    v70 = &v72[v80 & 0xFFFFFFFFFFFFFFF8];
                    v81 = v80 - 8;
                    v82 = &v79[8 * v77];
                    v83 = v44;
                    if (v81 < 0x38)
                      goto LABEL_139;
                    v82 = &v79[8 * v77];
                    v83 = v44;
                    if ((unint64_t)(v82 - v44) < 0x20)
                      goto LABEL_139;
                    v84 = (v81 >> 3) + 1;
                    v85 = 8 * (v84 & 0x3FFFFFFFFFFFFFFCLL);
                    v82 = &v72[v85];
                    v83 = &v44[v85];
                    v86 = (__int128 *)(v44 + 16);
                    v87 = &v79[8 * v77 + 16];
                    v88 = v84 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      v89 = *v86;
                      *((_OWORD *)v87 - 1) = *(v86 - 1);
                      *(_OWORD *)v87 = v89;
                      v86 += 2;
                      v87 += 32;
                      v88 -= 4;
                    }
                    while (v88);
                    if (v84 != (v84 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_139:
                      do
                      {
                        v90 = *(_QWORD *)v83;
                        v83 += 8;
                        *(_QWORD *)v82 = v90;
                        v82 += 8;
                      }
                      while (v82 != v70);
                    }
                  }
                  v45 = &v79[v78];
                  operator delete(v44);
                }
                else
                {
                  v74 = (v45 - v68) >> 3;
                  if (v74 >= -1)
                    v75 = v74 + 1;
                  else
                    v75 = v74 + 2;
                  v70 = &v68[8 * (v75 >> 1)];
                  v72 = &v44[8 * (v75 >> 1)];
                  if (v68 == v44)
                  {
                    v43 = v68;
                  }
                  else
                  {
                    memmove(&v44[8 * (v75 >> 1)], v44, v68 - v44);
                    v43 = v44;
                  }
                }
              }
              else
              {
                v72 = v44;
                v70 = v68;
              }
              v73 = *((_QWORD *)v26 - 1);
              v26 -= 8;
              *((_QWORD *)v72 - 1) = v73;
              v69 = v72 - 8;
              v68 = v70;
              v44 = v69;
              if (v26 == *((char **)this + 3))
                goto LABEL_64;
            }
          }
          v69 = v44;
          v70 = v44 + 8;
LABEL_64:
          v71 = (void *)*((_QWORD *)this + 2);
          *((_QWORD *)this + 2) = v43;
          *((_QWORD *)this + 3) = v69;
          v26 = v70;
          *((_QWORD *)this + 4) = v70;
          *((_QWORD *)this + 5) = v45;
          if (v71)
          {
            operator delete(v71);
            v26 = (char *)*((_QWORD *)this + 4);
          }
          goto LABEL_103;
        }
        v40 = operator new(0xFF0uLL);
        v41 = v40;
        if (v38 != v26)
        {
          if (v26)
          {
            *(_QWORD *)v26 = v40;
            goto LABEL_102;
          }
          goto LABEL_135;
        }
        if (v25 == v39)
        {
          v91 = (v38 - v25) >> 2;
          if (v26 == v25)
            v91 = 1;
          if (v91 >> 61)
            goto LABEL_136;
          v92 = (v91 + 3) >> 2;
          v93 = 8 * v91;
          v94 = (char *)operator new(8 * v91);
          v56 = &v94[8 * v92];
          v95 = v56;
          if (v26 != v25)
          {
            v95 = &v56[8 * v27];
            v96 = &v94[8 * v92];
            v97 = v25;
            if ((unint64_t)(v33 - 8) < 0x38)
              goto LABEL_140;
            v98 = &v94[8 * v92];
            v96 = v98;
            v97 = v25;
            if ((unint64_t)(v98 - v25) < 0x20)
              goto LABEL_140;
            v99 = ((unint64_t)(v33 - 8) >> 3) + 1;
            v100 = 8 * (v99 & 0x3FFFFFFFFFFFFFFCLL);
            v96 = &v56[v100];
            v97 = &v25[v100];
            v101 = (__int128 *)(v25 + 16);
            v102 = v98 + 16;
            v103 = v99 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v104 = *v101;
              *(v102 - 1) = *(v101 - 1);
              *v102 = v104;
              v101 += 2;
              v102 += 2;
              v103 -= 4;
            }
            while (v103);
            if (v99 != (v99 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_140:
              do
              {
                v105 = *(_QWORD *)v97;
                v97 += 8;
                *(_QWORD *)v96 = v105;
                v96 += 8;
              }
              while (v96 != v95);
            }
          }
          *((_QWORD *)this + 2) = v94;
          *((_QWORD *)this + 3) = v56;
          *((_QWORD *)this + 4) = v95;
          *((_QWORD *)this + 5) = &v94[v93];
          if (v25)
          {
            operator delete(v25);
            v56 = (char *)*((_QWORD *)this + 3);
          }
        }
        else
        {
          v56 = v25;
        }
        *((_QWORD *)v56 - 1) = v41;
        v106 = (char *)*((_QWORD *)this + 3);
        v107 = (char *)*((_QWORD *)this + 4);
        *((_QWORD *)this + 3) = v106 - 8;
        v108 = *((_QWORD *)v106 - 1);
        *((_QWORD *)this + 3) = v106;
        if (v107 != *((char **)this + 5))
          goto LABEL_100;
        v113 = (char *)*((_QWORD *)this + 2);
        if (v106 > v113)
        {
          v114 = (v106 - v113) >> 3;
          if (v114 >= -1)
            v115 = v114 + 1;
          else
            v115 = v114 + 2;
          v116 = v115 >> 1;
          v117 = -v116;
          v118 = &v106[-8 * v116];
          v119 = v107 - v106;
          if (v107 != v106)
          {
            memmove(&v106[-8 * v116], v106, v107 - v106);
            v106 = (char *)*((_QWORD *)this + 3);
          }
          v107 = &v118[v119];
          *((_QWORD *)this + 3) = &v106[8 * v117];
          *((_QWORD *)this + 4) = &v118[v119];
          goto LABEL_101;
        }
        v128 = (v107 - v113) >> 2;
        if (v107 == v113)
          v128 = 1;
        if (v128 >> 61)
          goto LABEL_136;
        v129 = v128 >> 2;
        v130 = 8 * v128;
        v131 = (char *)operator new(8 * v128);
        v132 = &v131[8 * v129];
        v133 = v107 - v106;
        v62 = v107 == v106;
        v107 = v132;
        if (!v62)
        {
          v107 = &v132[v133 & 0xFFFFFFFFFFFFFFF8];
          v134 = v133 - 8;
          if ((unint64_t)(v133 - 8) < 0x38)
          {
            v135 = &v131[8 * v129];
            do
            {
LABEL_132:
              v144 = *(_QWORD *)v106;
              v106 += 8;
              *(_QWORD *)v135 = v144;
              v135 += 8;
            }
            while (v135 != v107);
            goto LABEL_133;
          }
          v136 = &v131[8 * v129];
          v135 = v136;
          if ((unint64_t)(v136 - v106) < 0x20)
            goto LABEL_132;
          v137 = (v134 >> 3) + 1;
          v138 = 8 * (v137 & 0x3FFFFFFFFFFFFFFCLL);
          v135 = &v132[v138];
          v139 = &v106[v138];
          v140 = (__int128 *)(v106 + 16);
          v141 = v136 + 16;
          v142 = v137 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v143 = *v140;
            *(v141 - 1) = *(v140 - 1);
            *v141 = v143;
            v140 += 2;
            v141 += 2;
            v142 -= 4;
          }
          while (v142);
          v106 = v139;
          if (v137 != (v137 & 0x3FFFFFFFFFFFFFFCLL))
            goto LABEL_132;
        }
LABEL_133:
        *((_QWORD *)this + 2) = v131;
        *((_QWORD *)this + 3) = v132;
        *((_QWORD *)this + 4) = v107;
        *((_QWORD *)this + 5) = &v131[v130];
        if (v113)
        {
          operator delete(v113);
          v107 = (char *)*((_QWORD *)this + 4);
        }
LABEL_100:
        if (!v107)
          goto LABEL_135;
LABEL_101:
        *(_QWORD *)v107 = v108;
        goto LABEL_102;
      }
    }
  }
}

void **std::deque<webrtc::EncoderOvershootDetector::BitrateUpdate>::~deque[abi:sn180100](void **result)
{
  void **v1;
  void **v2;
  void **v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  void **v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;
  _BYTE *v14;
  _BYTE *v15;

  v1 = result;
  v2 = (void **)result[1];
  v3 = (void **)result[2];
  v4 = (char *)v3 - (char *)v2;
  if (v3 == v2)
  {
    v5 = result + 5;
  }
  else
  {
    v5 = result + 5;
    v6 = (unint64_t)result[4];
    v7 = &v2[v6 / 0xAA];
    v8 = (unint64_t)*v7;
    v9 = (unint64_t)*v7 + 24 * (v6 % 0xAA);
    while ((void *)v9 != (char *)v2[((unint64_t)result[5] + v6) / 0xAA]
                        + 24 * (((unint64_t)result[5] + v6) % 0xAA))
    {
      if (!v9)
      {
        __break(1u);
        return result;
      }
      v9 += 24;
      if (v9 - v8 == 4080)
      {
        v10 = (unint64_t)v7[1];
        ++v7;
        v8 = v10;
        v9 = v10;
      }
    }
  }
  *v5 = 0;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)v1[2];
      v2 = (void **)((char *)v1[1] + 8);
      v1[1] = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v11 = v4 >> 3;
  if (v11 == 1)
  {
    v12 = 85;
  }
  else
  {
    if (v11 != 2)
      goto LABEL_15;
    v12 = 170;
  }
  v1[4] = (void *)v12;
LABEL_15:
  if (v2 != v3)
  {
    do
    {
      v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    v15 = v1[1];
    v14 = v1[2];
    if (v14 != v15)
      v1[2] = &v14[(v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8];
  }
  if (*v1)
    operator delete(*v1);
  return v1;
}

uint64_t webrtc::EncoderRtcpFeedback::EncoderRtcpFeedback(uint64_t a1, uint64_t a2, char a3, size_t __sz, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  const void *v12;
  int64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  unint64_t v19;
  uint64_t v20;
  size_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  void (**v26)(webrtc::FieldTrialParameterInterface *__hidden);
  void *v27;
  void *v28;
  void *__p;
  char v30;
  uint64_t v31;

  *(_QWORD *)a1 = &off_24C0B3C80;
  *(_QWORD *)(a1 + 8) = &unk_24C0B3CB0;
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v12 = *(const void **)__sz;
  v11 = *(_QWORD *)(__sz + 8);
  v13 = v11 - *(_QWORD *)__sz;
  if (v11 != *(_QWORD *)__sz)
  {
    if (v13 < 0)
      goto LABEL_22;
    v14 = (char *)operator new(v11 - *(_QWORD *)__sz);
    *(_QWORD *)(a1 + 24) = v14;
    *(_QWORD *)(a1 + 32) = v14;
    v15 = &v14[4 * (v13 >> 2)];
    *(_QWORD *)(a1 + 40) = v15;
    memcpy(v14, v12, v13);
    *(_QWORD *)(a1 + 32) = v15;
  }
  *(_BYTE *)(a1 + 48) = a3;
  v16 = *(_QWORD *)(a6 + 24);
  if (!v16)
  {
    *(_QWORD *)(a1 + 80) = 0;
    *(_QWORD *)(a1 + 88) = a5;
    if ((a3 & 1) != 0)
      goto LABEL_9;
    goto LABEL_13;
  }
  if (v16 == a6)
  {
    *(_QWORD *)(a1 + 80) = a1 + 56;
    (*(void (**)(_QWORD))(**(_QWORD **)(a6 + 24) + 24))(*(_QWORD *)(a6 + 24));
    *(_QWORD *)(a1 + 88) = a5;
    if ((a3 & 1) != 0)
      goto LABEL_9;
LABEL_13:
    v20 = 1;
    goto LABEL_14;
  }
  *(_QWORD *)(a1 + 80) = v16;
  *(_QWORD *)(a6 + 24) = 0;
  *(_QWORD *)(a1 + 88) = a5;
  if ((a3 & 1) == 0)
    goto LABEL_13;
LABEL_9:
  v18 = *(const void **)__sz;
  v17 = *(_QWORD *)(__sz + 8);
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  v19 = v17 - (_QWORD)v18;
  if (!v19)
    goto LABEL_15;
  if (v19 >= 0x7FFFFFFFFFFFFFFDLL)
LABEL_22:
    abort();
  v20 = v19 >> 2;
LABEL_14:
  v21 = 8 * v20;
  v22 = (char *)operator new(8 * v20);
  *(_QWORD *)(a1 + 96) = v22;
  v23 = &v22[v21];
  *(_QWORD *)(a1 + 112) = &v22[v21];
  bzero(v22, v21);
  *(_QWORD *)(a1 + 104) = v23;
LABEL_15:
  webrtc::KeyframeIntervalSettings::ParseFromFieldTrials((uint64_t)&v26);
  v24 = 300000;
  if ((v31 & 0xFF00000000) != 0)
    v24 = 1000 * (int)v31;
  *(_QWORD *)(a1 + 120) = v24;
  v26 = off_24C0B4170;
  if (v30 < 0)
    operator delete(__p);
  if (v27)
  {
    v28 = v27;
    operator delete(v27);
  }
  return a1;
}

void webrtc::EncoderRtcpFeedback::OnReceivedIntraFrameRequest(webrtc::EncoderRtcpFeedback *this, __int32 a2)
{
  __int32 *v3;
  __int32 *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int32 *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  char *v30;
  uint64_t v31;
  void *__p;
  void *v33;
  uint64_t v34;
  void *v35;
  _DWORD *v36;
  char *v37;

  v3 = (__int32 *)*((_QWORD *)this + 4);
  v4 = wmemchr(*((__int32 **)this + 3), a2, ((uint64_t)v3 - *((_QWORD *)this + 3)) >> 2);
  if (v4)
    v9 = v4;
  else
    v9 = v3;
  if (v9 == *((__int32 **)this + 4))
    goto LABEL_8;
  if (*((_BYTE *)this + 48))
  {
    v10 = ((uint64_t)v9 - *((_QWORD *)this + 3)) >> 2;
    if (v10 > (uint64_t)(*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 3)
    {
      rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/encoder_rtcp_feedback.cc", 62, "ssrc_index <= time_last_packet_delivery_queue_.size()", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long> const&)::t, v5, v6, v7, v8, v10);
LABEL_8:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
        rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v11, v12, v13, v14, v15, v16, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/encoder_rtcp_feedback.cc");
      return;
    }
  }
  else
  {
    v10 = 0;
  }
  v18 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 16))(*((_QWORD *)this + 2));
  v19 = *((_QWORD *)this + 12);
  if (v10 >= (*((_QWORD *)this + 13) - v19) >> 3)
  {
LABEL_35:
    __break(1u);
LABEL_36:
    abort();
  }
  v20 = *((_QWORD *)this + 15);
  v21 = *(_QWORD *)(v19 + 8 * v10);
  v22 = 0x8000000000000000;
  if (v20 != 0x8000000000000000 && v21 != 0x8000000000000000)
    v22 = v21 + v20;
  if (v21 == 0x7FFFFFFFFFFFFFFFLL || v20 == 0x7FFFFFFFFFFFFFFFLL)
    v25 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v25 = v22;
  if (v25 <= v18)
  {
    *(_QWORD *)(v19 + 8 * v10) = v18;
    v27 = *((_QWORD *)this + 3);
    v26 = *((_QWORD *)this + 4);
    v36 = 0;
    v37 = 0;
    v35 = 0;
    v28 = v26 - v27;
    if (v26 == v27)
    {
      v29 = 0;
      v30 = 0;
      if (*((_BYTE *)this + 48))
      {
LABEL_28:
        if (v10 < (v30 - (char *)v29) >> 2)
        {
          v29[v10] = 3;
          (*(void (**)(_QWORD, void **))(**((_QWORD **)this + 11) + 56))(*((_QWORD *)this + 11), &v35);
          v29 = v35;
LABEL_33:
          if (v29)
          {
            v36 = v29;
            operator delete(v29);
          }
          return;
        }
        goto LABEL_35;
      }
    }
    else
    {
      if (v28 < 0)
        goto LABEL_36;
      v29 = operator new(v26 - v27);
      v30 = (char *)&v29[v28 >> 2];
      v35 = v29;
      v37 = v30;
      memset_pattern16(v29, &unk_208F097F0, v28 & 0xFFFFFFFFFFFFFFFCLL);
      v36 = v30;
      if (*((_BYTE *)this + 48))
        goto LABEL_28;
    }
    v31 = *((_QWORD *)this + 11);
    __p = 0;
    v33 = 0;
    v34 = 0;
    (*(void (**)(uint64_t, void **))(*(_QWORD *)v31 + 56))(v31, &__p);
    if (__p)
    {
      v33 = __p;
      operator delete(__p);
    }
    goto LABEL_33;
  }
}

void webrtc::EncoderRtcpFeedback::OnReceivedLossNotification(webrtc::EncoderRtcpFeedback *this, int a2, int a3, int a4, int a5)
{
  _DWORD *v10;
  uint64_t v11;
  _BYTE *v12;
  int v13;
  __int16 v14;
  webrtc::EncoderRtcpFeedback *v15;
  unsigned int v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  BOOL v19;
  _DWORD v20[2];
  int v21;
  void *__p;
  _BYTE *v23;
  void *v24;
  void *v25;
  _DWORD *v26;

  v10 = operator new(4uLL);
  v24 = v10;
  *v10 = a3 | (a4 << 16);
  v25 = v10 + 1;
  v26 = v10 + 1;
  v20[0] = a2;
  v11 = *((_QWORD *)this + 10);
  if (!v11)
    goto LABEL_27;
  (*(void (**)(void **__return_ptr, uint64_t, _DWORD *, void **))(*(_QWORD *)v11 + 48))(&__p, v11, v20, &v24);
  v12 = __p;
  if (__p != v23)
  {
    if ((unint64_t)(v23 - (_BYTE *)__p) > 8)
    {
      v21 = 0;
      v13 = *((_DWORD *)__p + 2);
      v20[0] = *(_DWORD *)__p;
      v20[1] = v13;
      if (*((_BYTE *)__p + 12) && *((_BYTE *)__p + 13))
      {
        v14 = a5 | 0x100;
        LOWORD(v21) = a5 | 0x100;
LABEL_19:
        HIWORD(v21) = v14;
        goto LABEL_20;
      }
      if (*((_BYTE *)__p + 12) && !*((_BYTE *)__p + 13))
      {
        LOWORD(v21) = a5 | 0x100;
        if (a5)
          v14 = 0;
        else
          v14 = 256;
        goto LABEL_19;
      }
      if (*((_BYTE *)__p + 12) || !*((_BYTE *)__p + 13))
      {
        if (a5)
        {
          LOWORD(v21) = 257;
          goto LABEL_20;
        }
      }
      else if (a5)
      {
        v21 = 16843009;
LABEL_20:
        (*(void (**)(_QWORD, _DWORD *))(**((_QWORD **)this + 11) + 64))(*((_QWORD *)this + 11), v20);
        v12 = __p;
        goto LABEL_21;
      }
      v14 = 256;
      goto LABEL_19;
    }
    __break(1u);
LABEL_27:
    v15 = (webrtc::EncoderRtcpFeedback *)std::__throw_bad_function_call[abi:sn180100]();
    return;
  }
LABEL_21:
  if (v12)
  {
    v23 = v12;
    operator delete(v12);
  }
  if (v24)
  {
    v25 = v24;
    operator delete(v24);
  }
}

void `non-virtual thunk to'webrtc::EncoderRtcpFeedback::OnReceivedLossNotification(webrtc::EncoderRtcpFeedback *this, int a2, int a3, int a4, int a5)
{
  webrtc::EncoderRtcpFeedback::OnReceivedLossNotification((webrtc::EncoderRtcpFeedback *)((char *)this - 8), a2, a3, a4, a5);
}

void webrtc::EncoderRtcpFeedback::~EncoderRtcpFeedback(webrtc::EncoderRtcpFeedback *this)
{
  void *v2;
  webrtc::EncoderRtcpFeedback *v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = &off_24C0B3C80;
  *((_QWORD *)this + 1) = &unk_24C0B3CB0;
  v2 = (void *)*((_QWORD *)this + 12);
  if (v2)
  {
    *((_QWORD *)this + 13) = v2;
    operator delete(v2);
  }
  v3 = (webrtc::EncoderRtcpFeedback *)*((_QWORD *)this + 10);
  if (v3 == (webrtc::EncoderRtcpFeedback *)((char *)this + 56))
  {
    v4 = 4;
    v3 = (webrtc::EncoderRtcpFeedback *)((char *)this + 56);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_8:
  v5 = (void *)*((_QWORD *)this + 3);
  if (v5)
  {
    *((_QWORD *)this + 4) = v5;
    operator delete(v5);
  }
}

{
  void *v2;
  webrtc::EncoderRtcpFeedback *v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = &off_24C0B3C80;
  *((_QWORD *)this + 1) = &unk_24C0B3CB0;
  v2 = (void *)*((_QWORD *)this + 12);
  if (v2)
  {
    *((_QWORD *)this + 13) = v2;
    operator delete(v2);
  }
  v3 = (webrtc::EncoderRtcpFeedback *)*((_QWORD *)this + 10);
  if (v3 == (webrtc::EncoderRtcpFeedback *)((char *)this + 56))
  {
    v4 = 4;
    v3 = (webrtc::EncoderRtcpFeedback *)((char *)this + 56);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_8:
  v5 = (void *)*((_QWORD *)this + 3);
  if (v5)
  {
    *((_QWORD *)this + 4) = v5;
    operator delete(v5);
  }
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'webrtc::EncoderRtcpFeedback::~EncoderRtcpFeedback(webrtc::EncoderRtcpFeedback *this)
{
  void *v2;
  webrtc::EncoderRtcpFeedback *v3;
  uint64_t v4;
  void *v5;

  *((_QWORD *)this - 1) = &off_24C0B3C80;
  *(_QWORD *)this = &unk_24C0B3CB0;
  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
  {
    *((_QWORD *)this + 12) = v2;
    operator delete(v2);
  }
  v3 = (webrtc::EncoderRtcpFeedback *)*((_QWORD *)this + 9);
  if (v3 == (webrtc::EncoderRtcpFeedback *)((char *)this + 48))
  {
    v4 = 4;
    v3 = (webrtc::EncoderRtcpFeedback *)((char *)this + 48);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_8:
  v5 = (void *)*((_QWORD *)this + 2);
  if (v5)
  {
    *((_QWORD *)this + 3) = v5;
    operator delete(v5);
  }
}

{
  void *v2;
  webrtc::EncoderRtcpFeedback *v3;
  uint64_t v4;
  void *v5;

  *((_QWORD *)this - 1) = &off_24C0B3C80;
  *(_QWORD *)this = &unk_24C0B3CB0;
  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
  {
    *((_QWORD *)this + 12) = v2;
    operator delete(v2);
  }
  v3 = (webrtc::EncoderRtcpFeedback *)*((_QWORD *)this + 9);
  if (v3 == (webrtc::EncoderRtcpFeedback *)((char *)this + 48))
  {
    v4 = 4;
    v3 = (webrtc::EncoderRtcpFeedback *)((char *)this + 48);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_8:
  v5 = (void *)*((_QWORD *)this + 2);
  if (v5)
  {
    *((_QWORD *)this + 3) = v5;
    operator delete(v5);
  }
  JUMPOUT(0x20BD0ADECLL);
}

void webrtc::VideoEncoder::EncoderInfo::operator=(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  std::string *v5;
  char v6;
  __int128 v7;
  const std::string::value_type *v8;
  size_t v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  BOOL v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  char *v21;
  _OWORD *v22;
  __int128 *v23;
  uint64_t v24;
  __int128 v25;
  unint64_t v26;
  _BYTE *v27;
  char v28;
  char *v29;
  size_t v30;
  char *v31;
  unint64_t v32;
  char *v33;
  uint64_t v34;
  _OWORD *v35;
  __int128 *v36;
  unint64_t v37;
  __int128 v38;
  unint64_t v39;
  char *v40;
  uint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  char v46;
  unint64_t v47;
  char *v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  char *v57;
  _OWORD *v58;
  __int128 *v59;
  uint64_t v60;
  __int128 v61;
  unint64_t v62;
  _BYTE *v63;
  char v64;
  char *v65;
  size_t v66;
  char *v67;
  unint64_t v68;
  char *v69;
  uint64_t v70;
  _OWORD *v71;
  __int128 *v72;
  unint64_t v73;
  __int128 v74;
  unint64_t v75;
  char *v76;
  uint64_t *v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  char *v81;
  char v82;
  unint64_t v83;
  char *v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  char *v93;
  _OWORD *v94;
  __int128 *v95;
  uint64_t v96;
  __int128 v97;
  unint64_t v98;
  _BYTE *v99;
  char v100;
  char *v101;
  size_t v102;
  char *v103;
  unint64_t v104;
  char *v105;
  uint64_t v106;
  _OWORD *v107;
  __int128 *v108;
  unint64_t v109;
  __int128 v110;
  unint64_t v111;
  char *v112;
  uint64_t *v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v116;
  char *v117;
  char v118;
  unint64_t v119;
  char *v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  uint64_t v124;
  unint64_t v125;
  unint64_t v126;
  unint64_t v127;
  uint64_t v128;
  char *v129;
  _OWORD *v130;
  __int128 *v131;
  uint64_t v132;
  __int128 v133;
  unint64_t v134;
  _BYTE *v135;
  char v136;
  char *v137;
  size_t v138;
  char *v139;
  unint64_t v140;
  char *v141;
  uint64_t v142;
  _OWORD *v143;
  __int128 *v144;
  unint64_t v145;
  __int128 v146;
  unint64_t v147;
  char *v148;
  uint64_t *v149;
  unint64_t v150;
  uint64_t v151;
  unint64_t v152;
  char *v153;
  char v154;
  unint64_t v155;
  char *v156;
  unint64_t v157;
  unint64_t v158;
  unint64_t v159;
  uint64_t v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  uint64_t v164;
  char *v165;
  _OWORD *v166;
  __int128 *v167;
  uint64_t v168;
  __int128 v169;
  unint64_t v170;
  _BYTE *v171;
  char v172;
  char *v173;
  size_t v174;
  char *v175;
  unint64_t v176;
  char *v177;
  uint64_t v178;
  _OWORD *v179;
  __int128 *v180;
  unint64_t v181;
  __int128 v182;
  unint64_t v183;
  char *v184;
  uint64_t *v185;
  unint64_t v186;
  uint64_t v187;
  unint64_t v188;
  char *v189;
  char v190;
  uint64_t v191;
  uint64_t v192;

  v4 = *a2;
  *(_QWORD *)(a1 + 14) = *(_QWORD *)((char *)a2 + 14);
  *(_OWORD *)a1 = v4;
  if ((__int128 *)a1 == a2)
  {
LABEL_257:
    *(_WORD *)(a1 + 240) = *((_WORD *)a2 + 120);
    return;
  }
  v5 = (std::string *)(a1 + 24);
  v6 = *((_BYTE *)a2 + 47);
  if (*(char *)(a1 + 47) < 0)
  {
    if (v6 >= 0)
      v8 = (char *)a2 + 24;
    else
      v8 = (const std::string::value_type *)*((_QWORD *)a2 + 3);
    if (v6 >= 0)
      v9 = *((unsigned __int8 *)a2 + 47);
    else
      v9 = *((_QWORD *)a2 + 4);
    std::string::__assign_no_alias<false>(v5, v8, v9);
  }
  else if ((*((_BYTE *)a2 + 47) & 0x80) != 0)
  {
    std::string::__assign_no_alias<true>(v5, *((char **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v7 = *(__int128 *)((char *)a2 + 24);
    *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v7;
  }
  *(_WORD *)(a1 + 48) = *((_WORD *)a2 + 24);
  v10 = *((_QWORD *)a2 + 7);
  if ((v10 & 1) != 0)
    v11 = (char *)*((_QWORD *)a2 + 8);
  else
    v11 = (char *)(a2 + 4);
  v12 = v10 >> 1;
  v13 = *(_QWORD *)(a1 + 56);
  if ((v13 & 1) != 0)
  {
    v15 = *(_QWORD *)(a1 + 64);
    v14 = *(_QWORD *)(a1 + 72);
    if (v14 >= v12)
    {
LABEL_18:
      v16 = v13 >> 1;
      v17 = v12 >= v13 >> 1;
      v18 = v12 - (v13 >> 1);
      if (!v17)
        v18 = 0;
      if (v16 >= v12)
        v19 = v10 >> 1;
      else
        v19 = v16;
      if (v19)
      {
        v20 = 0;
        if (v19 < 0x20)
          goto LABEL_29;
        if ((unint64_t)(v15 - (_QWORD)v11) < 0x20)
          goto LABEL_29;
        v20 = v19 & 0x7FFFFFFFFFFFFFE0;
        v21 = &v11[v19 & 0x7FFFFFFFFFFFFFE0];
        v22 = (_OWORD *)(v15 + 16);
        v23 = (__int128 *)(v11 + 16);
        v24 = v19 & 0x7FFFFFFFFFFFFFE0;
        do
        {
          v25 = *v23;
          *(v22 - 1) = *(v23 - 1);
          *v22 = v25;
          v22 += 2;
          v23 += 2;
          v24 -= 32;
        }
        while (v24);
        v11 += v19 & 0x7FFFFFFFFFFFFFE0;
        if (v19 != v20)
        {
LABEL_29:
          v26 = v19 - v20;
          v27 = (_BYTE *)(v15 + v20);
          v21 = v11;
          do
          {
            v28 = *v21++;
            *v27++ = v28;
            --v26;
          }
          while (v26);
        }
        if (v16 < v12)
        {
LABEL_32:
          if (!v15)
            goto LABEL_258;
          v29 = 0;
          v30 = 0;
          v31 = (char *)(v15 + v16);
          v12 = v18;
          v11 = v21;
          v32 = 0;
          if (v12 < 8)
            goto LABEL_43;
          goto LABEL_40;
        }
      }
      else
      {
        v21 = v11;
        if (v16 < v12)
          goto LABEL_32;
      }
      v34 = *(_QWORD *)(a1 + 56);
      goto LABEL_61;
    }
  }
  else
  {
    v14 = 16;
    v15 = a1 + 64;
    if (v12 <= 0x10)
      goto LABEL_18;
  }
  if (2 * v14 <= v12)
    v30 = v10 >> 1;
  else
    v30 = 2 * v14;
  v29 = (char *)operator new(v30);
  v31 = v29;
  v32 = 0;
  if (v12 < 8)
    goto LABEL_43;
LABEL_40:
  if ((unint64_t)(v31 - v11) < 0x20)
  {
LABEL_43:
    v33 = v11;
    goto LABEL_55;
  }
  if (v12 >= 0x20)
  {
    v32 = v12 & 0xFFFFFFFFFFFFFFE0;
    v35 = v31 + 16;
    v36 = (__int128 *)(v11 + 16);
    v37 = v12 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      v38 = *v36;
      *(v35 - 1) = *(v36 - 1);
      *v35 = v38;
      v35 += 2;
      v36 += 2;
      v37 -= 32;
    }
    while (v37);
    if (v12 == v32)
      goto LABEL_57;
    if ((v12 & 0x18) == 0)
    {
      v33 = &v11[v32];
LABEL_55:
      v44 = v12 - v32;
      v45 = &v31[v32];
      do
      {
        v46 = *v33++;
        *v45++ = v46;
        --v44;
      }
      while (v44);
      goto LABEL_57;
    }
  }
  else
  {
    v32 = 0;
  }
  v39 = v32;
  v32 = v12 & 0xFFFFFFFFFFFFFFF8;
  v33 = &v11[v12 & 0xFFFFFFFFFFFFFFF8];
  v40 = &v31[v39];
  v41 = (uint64_t *)&v11[v39];
  v42 = v39 - (v12 & 0xFFFFFFFFFFFFFFF8);
  do
  {
    v43 = *v41++;
    *(_QWORD *)v40 = v43;
    v40 += 8;
    v42 += 8;
  }
  while (v42);
  if (v12 != v32)
    goto LABEL_55;
LABEL_57:
  v34 = *(_QWORD *)(a1 + 56);
  if (v29)
  {
    if ((v34 & 1) != 0)
      operator delete(*(void **)(a1 + 64));
    *(_QWORD *)(a1 + 64) = v29;
    *(_QWORD *)(a1 + 72) = v30;
    LOBYTE(v34) = 1;
  }
LABEL_61:
  *(_QWORD *)(a1 + 56) = v10 & 0xFFFFFFFFFFFFFFFELL | v34 & 1;
  v47 = *((_QWORD *)a2 + 10);
  if ((v47 & 1) != 0)
    v48 = (char *)*((_QWORD *)a2 + 11);
  else
    v48 = (char *)a2 + 88;
  v49 = v47 >> 1;
  v50 = *(_QWORD *)(a1 + 80);
  if ((v50 & 1) != 0)
  {
    v52 = *(_QWORD *)(a1 + 88);
    v51 = *(_QWORD *)(a1 + 96);
    if (v51 >= v49)
    {
LABEL_66:
      v53 = v50 >> 1;
      v17 = v49 >= v50 >> 1;
      v54 = v49 - (v50 >> 1);
      if (!v17)
        v54 = 0;
      if (v53 >= v49)
        v55 = v47 >> 1;
      else
        v55 = v53;
      if (v55)
      {
        v56 = 0;
        if (v55 < 0x20)
          goto LABEL_77;
        if ((unint64_t)(v52 - (_QWORD)v48) < 0x20)
          goto LABEL_77;
        v56 = v55 & 0x7FFFFFFFFFFFFFE0;
        v57 = &v48[v55 & 0x7FFFFFFFFFFFFFE0];
        v58 = (_OWORD *)(v52 + 16);
        v59 = (__int128 *)(v48 + 16);
        v60 = v55 & 0x7FFFFFFFFFFFFFE0;
        do
        {
          v61 = *v59;
          *(v58 - 1) = *(v59 - 1);
          *v58 = v61;
          v58 += 2;
          v59 += 2;
          v60 -= 32;
        }
        while (v60);
        v48 += v55 & 0x7FFFFFFFFFFFFFE0;
        if (v55 != v56)
        {
LABEL_77:
          v62 = v55 - v56;
          v63 = (_BYTE *)(v52 + v56);
          v57 = v48;
          do
          {
            v64 = *v57++;
            *v63++ = v64;
            --v62;
          }
          while (v62);
        }
        if (v53 < v49)
        {
LABEL_80:
          if (!v52)
            goto LABEL_258;
          v65 = 0;
          v66 = 0;
          v67 = (char *)(v52 + v53);
          v49 = v54;
          v48 = v57;
          v68 = 0;
          if (v49 < 8)
            goto LABEL_91;
          goto LABEL_88;
        }
      }
      else
      {
        v57 = v48;
        if (v53 < v49)
          goto LABEL_80;
      }
      v70 = *(_QWORD *)(a1 + 80);
      goto LABEL_109;
    }
  }
  else
  {
    v51 = 16;
    v52 = a1 + 88;
    if (v49 <= 0x10)
      goto LABEL_66;
  }
  if (2 * v51 <= v49)
    v66 = v47 >> 1;
  else
    v66 = 2 * v51;
  v65 = (char *)operator new(v66);
  v67 = v65;
  v68 = 0;
  if (v49 < 8)
    goto LABEL_91;
LABEL_88:
  if ((unint64_t)(v67 - v48) < 0x20)
  {
LABEL_91:
    v69 = v48;
    goto LABEL_103;
  }
  if (v49 >= 0x20)
  {
    v68 = v49 & 0xFFFFFFFFFFFFFFE0;
    v71 = v67 + 16;
    v72 = (__int128 *)(v48 + 16);
    v73 = v49 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      v74 = *v72;
      *(v71 - 1) = *(v72 - 1);
      *v71 = v74;
      v71 += 2;
      v72 += 2;
      v73 -= 32;
    }
    while (v73);
    if (v49 == v68)
      goto LABEL_105;
    if ((v49 & 0x18) == 0)
    {
      v69 = &v48[v68];
LABEL_103:
      v80 = v49 - v68;
      v81 = &v67[v68];
      do
      {
        v82 = *v69++;
        *v81++ = v82;
        --v80;
      }
      while (v80);
      goto LABEL_105;
    }
  }
  else
  {
    v68 = 0;
  }
  v75 = v68;
  v68 = v49 & 0xFFFFFFFFFFFFFFF8;
  v69 = &v48[v49 & 0xFFFFFFFFFFFFFFF8];
  v76 = &v67[v75];
  v77 = (uint64_t *)&v48[v75];
  v78 = v75 - (v49 & 0xFFFFFFFFFFFFFFF8);
  do
  {
    v79 = *v77++;
    *(_QWORD *)v76 = v79;
    v76 += 8;
    v78 += 8;
  }
  while (v78);
  if (v49 != v68)
    goto LABEL_103;
LABEL_105:
  v70 = *(_QWORD *)(a1 + 80);
  if (v65)
  {
    if ((v70 & 1) != 0)
      operator delete(*(void **)(a1 + 88));
    *(_QWORD *)(a1 + 88) = v65;
    *(_QWORD *)(a1 + 96) = v66;
    LOBYTE(v70) = 1;
  }
LABEL_109:
  *(_QWORD *)(a1 + 80) = v47 & 0xFFFFFFFFFFFFFFFELL | v70 & 1;
  v83 = *((_QWORD *)a2 + 13);
  if ((v83 & 1) != 0)
    v84 = (char *)*((_QWORD *)a2 + 14);
  else
    v84 = (char *)(a2 + 7);
  v85 = v83 >> 1;
  v86 = *(_QWORD *)(a1 + 104);
  if ((v86 & 1) != 0)
  {
    v88 = *(_QWORD *)(a1 + 112);
    v87 = *(_QWORD *)(a1 + 120);
    if (v87 >= v85)
    {
LABEL_114:
      v89 = v86 >> 1;
      v17 = v85 >= v86 >> 1;
      v90 = v85 - (v86 >> 1);
      if (!v17)
        v90 = 0;
      if (v89 >= v85)
        v91 = v83 >> 1;
      else
        v91 = v89;
      if (v91)
      {
        v92 = 0;
        if (v91 < 0x20)
          goto LABEL_125;
        if ((unint64_t)(v88 - (_QWORD)v84) < 0x20)
          goto LABEL_125;
        v92 = v91 & 0x7FFFFFFFFFFFFFE0;
        v93 = &v84[v91 & 0x7FFFFFFFFFFFFFE0];
        v94 = (_OWORD *)(v88 + 16);
        v95 = (__int128 *)(v84 + 16);
        v96 = v91 & 0x7FFFFFFFFFFFFFE0;
        do
        {
          v97 = *v95;
          *(v94 - 1) = *(v95 - 1);
          *v94 = v97;
          v94 += 2;
          v95 += 2;
          v96 -= 32;
        }
        while (v96);
        v84 += v91 & 0x7FFFFFFFFFFFFFE0;
        if (v91 != v92)
        {
LABEL_125:
          v98 = v91 - v92;
          v99 = (_BYTE *)(v88 + v92);
          v93 = v84;
          do
          {
            v100 = *v93++;
            *v99++ = v100;
            --v98;
          }
          while (v98);
        }
        if (v89 < v85)
        {
LABEL_128:
          if (!v88)
            goto LABEL_258;
          v101 = 0;
          v102 = 0;
          v103 = (char *)(v88 + v89);
          v85 = v90;
          v84 = v93;
          v104 = 0;
          if (v85 < 8)
            goto LABEL_139;
          goto LABEL_136;
        }
      }
      else
      {
        v93 = v84;
        if (v89 < v85)
          goto LABEL_128;
      }
      v106 = *(_QWORD *)(a1 + 104);
      goto LABEL_157;
    }
  }
  else
  {
    v87 = 16;
    v88 = a1 + 112;
    if (v85 <= 0x10)
      goto LABEL_114;
  }
  if (2 * v87 <= v85)
    v102 = v83 >> 1;
  else
    v102 = 2 * v87;
  v101 = (char *)operator new(v102);
  v103 = v101;
  v104 = 0;
  if (v85 < 8)
    goto LABEL_139;
LABEL_136:
  if ((unint64_t)(v103 - v84) < 0x20)
  {
LABEL_139:
    v105 = v84;
    goto LABEL_151;
  }
  if (v85 >= 0x20)
  {
    v104 = v85 & 0xFFFFFFFFFFFFFFE0;
    v107 = v103 + 16;
    v108 = (__int128 *)(v84 + 16);
    v109 = v85 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      v110 = *v108;
      *(v107 - 1) = *(v108 - 1);
      *v107 = v110;
      v107 += 2;
      v108 += 2;
      v109 -= 32;
    }
    while (v109);
    if (v85 == v104)
      goto LABEL_153;
    if ((v85 & 0x18) == 0)
    {
      v105 = &v84[v104];
LABEL_151:
      v116 = v85 - v104;
      v117 = &v103[v104];
      do
      {
        v118 = *v105++;
        *v117++ = v118;
        --v116;
      }
      while (v116);
      goto LABEL_153;
    }
  }
  else
  {
    v104 = 0;
  }
  v111 = v104;
  v104 = v85 & 0xFFFFFFFFFFFFFFF8;
  v105 = &v84[v85 & 0xFFFFFFFFFFFFFFF8];
  v112 = &v103[v111];
  v113 = (uint64_t *)&v84[v111];
  v114 = v111 - (v85 & 0xFFFFFFFFFFFFFFF8);
  do
  {
    v115 = *v113++;
    *(_QWORD *)v112 = v115;
    v112 += 8;
    v114 += 8;
  }
  while (v114);
  if (v85 != v104)
    goto LABEL_151;
LABEL_153:
  v106 = *(_QWORD *)(a1 + 104);
  if (v101)
  {
    if ((v106 & 1) != 0)
      operator delete(*(void **)(a1 + 112));
    *(_QWORD *)(a1 + 112) = v101;
    *(_QWORD *)(a1 + 120) = v102;
    LOBYTE(v106) = 1;
  }
LABEL_157:
  *(_QWORD *)(a1 + 104) = v83 & 0xFFFFFFFFFFFFFFFELL | v106 & 1;
  v119 = *((_QWORD *)a2 + 16);
  if ((v119 & 1) != 0)
    v120 = (char *)*((_QWORD *)a2 + 17);
  else
    v120 = (char *)a2 + 136;
  v121 = v119 >> 1;
  v122 = *(_QWORD *)(a1 + 128);
  if ((v122 & 1) != 0)
  {
    v124 = *(_QWORD *)(a1 + 136);
    v123 = *(_QWORD *)(a1 + 144);
    if (v123 >= v121)
    {
LABEL_162:
      v125 = v122 >> 1;
      v17 = v121 >= v122 >> 1;
      v126 = v121 - (v122 >> 1);
      if (!v17)
        v126 = 0;
      if (v125 >= v121)
        v127 = v119 >> 1;
      else
        v127 = v125;
      if (v127)
      {
        v128 = 0;
        if (v127 < 0x20)
          goto LABEL_173;
        if ((unint64_t)(v124 - (_QWORD)v120) < 0x20)
          goto LABEL_173;
        v128 = v127 & 0x7FFFFFFFFFFFFFE0;
        v129 = &v120[v127 & 0x7FFFFFFFFFFFFFE0];
        v130 = (_OWORD *)(v124 + 16);
        v131 = (__int128 *)(v120 + 16);
        v132 = v127 & 0x7FFFFFFFFFFFFFE0;
        do
        {
          v133 = *v131;
          *(v130 - 1) = *(v131 - 1);
          *v130 = v133;
          v130 += 2;
          v131 += 2;
          v132 -= 32;
        }
        while (v132);
        v120 += v127 & 0x7FFFFFFFFFFFFFE0;
        if (v127 != v128)
        {
LABEL_173:
          v134 = v127 - v128;
          v135 = (_BYTE *)(v124 + v128);
          v129 = v120;
          do
          {
            v136 = *v129++;
            *v135++ = v136;
            --v134;
          }
          while (v134);
        }
        if (v125 < v121)
        {
LABEL_176:
          if (!v124)
            goto LABEL_258;
          v137 = 0;
          v138 = 0;
          v139 = (char *)(v124 + v125);
          v121 = v126;
          v120 = v129;
          v140 = 0;
          if (v121 < 8)
            goto LABEL_187;
          goto LABEL_184;
        }
      }
      else
      {
        v129 = v120;
        if (v125 < v121)
          goto LABEL_176;
      }
      v142 = *(_QWORD *)(a1 + 128);
      goto LABEL_205;
    }
  }
  else
  {
    v123 = 16;
    v124 = a1 + 136;
    if (v121 <= 0x10)
      goto LABEL_162;
  }
  if (2 * v123 <= v121)
    v138 = v119 >> 1;
  else
    v138 = 2 * v123;
  v137 = (char *)operator new(v138);
  v139 = v137;
  v140 = 0;
  if (v121 < 8)
    goto LABEL_187;
LABEL_184:
  if ((unint64_t)(v139 - v120) < 0x20)
  {
LABEL_187:
    v141 = v120;
    goto LABEL_199;
  }
  if (v121 >= 0x20)
  {
    v140 = v121 & 0xFFFFFFFFFFFFFFE0;
    v143 = v139 + 16;
    v144 = (__int128 *)(v120 + 16);
    v145 = v121 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      v146 = *v144;
      *(v143 - 1) = *(v144 - 1);
      *v143 = v146;
      v143 += 2;
      v144 += 2;
      v145 -= 32;
    }
    while (v145);
    if (v121 == v140)
      goto LABEL_201;
    if ((v121 & 0x18) == 0)
    {
      v141 = &v120[v140];
LABEL_199:
      v152 = v121 - v140;
      v153 = &v139[v140];
      do
      {
        v154 = *v141++;
        *v153++ = v154;
        --v152;
      }
      while (v152);
      goto LABEL_201;
    }
  }
  else
  {
    v140 = 0;
  }
  v147 = v140;
  v140 = v121 & 0xFFFFFFFFFFFFFFF8;
  v141 = &v120[v121 & 0xFFFFFFFFFFFFFFF8];
  v148 = &v139[v147];
  v149 = (uint64_t *)&v120[v147];
  v150 = v147 - (v121 & 0xFFFFFFFFFFFFFFF8);
  do
  {
    v151 = *v149++;
    *(_QWORD *)v148 = v151;
    v148 += 8;
    v150 += 8;
  }
  while (v150);
  if (v121 != v140)
    goto LABEL_199;
LABEL_201:
  v142 = *(_QWORD *)(a1 + 128);
  if (v137)
  {
    if ((v142 & 1) != 0)
      operator delete(*(void **)(a1 + 136));
    *(_QWORD *)(a1 + 136) = v137;
    *(_QWORD *)(a1 + 144) = v138;
    LOBYTE(v142) = 1;
  }
LABEL_205:
  *(_QWORD *)(a1 + 128) = v119 & 0xFFFFFFFFFFFFFFFELL | v142 & 1;
  v155 = *((_QWORD *)a2 + 19);
  if ((v155 & 1) != 0)
    v156 = (char *)*((_QWORD *)a2 + 20);
  else
    v156 = (char *)(a2 + 10);
  v157 = v155 >> 1;
  v158 = *(_QWORD *)(a1 + 152);
  if ((v158 & 1) == 0)
  {
    v159 = 16;
    v160 = a1 + 160;
    if (v157 <= 0x10)
      goto LABEL_210;
LABEL_228:
    if (2 * v159 <= v157)
      v174 = v155 >> 1;
    else
      v174 = 2 * v159;
    v173 = (char *)operator new(v174);
    v175 = v173;
    v176 = 0;
    if (v157 < 8)
      goto LABEL_235;
    goto LABEL_232;
  }
  v160 = *(_QWORD *)(a1 + 160);
  v159 = *(_QWORD *)(a1 + 168);
  if (v159 < v157)
    goto LABEL_228;
LABEL_210:
  v161 = v158 >> 1;
  v17 = v157 >= v158 >> 1;
  v162 = v157 - (v158 >> 1);
  if (!v17)
    v162 = 0;
  if (v161 >= v157)
    v163 = v155 >> 1;
  else
    v163 = v161;
  if (!v163)
  {
    v165 = v156;
    if (v161 < v157)
      goto LABEL_224;
LABEL_237:
    v178 = *(_QWORD *)(a1 + 152);
LABEL_253:
    *(_QWORD *)(a1 + 152) = v155 & 0xFFFFFFFFFFFFFFFELL | v178 & 1;
    std::vector<webrtc::VideoEncoder::ResolutionBitrateLimits>::__assign_with_size[abi:sn180100]<webrtc::VideoEncoder::ResolutionBitrateLimits*,webrtc::VideoEncoder::ResolutionBitrateLimits*>((_QWORD *)(a1 + 176), *((char **)a2 + 22), *((char **)a2 + 23), (uint64_t)(*((_QWORD *)a2 + 23) - *((_QWORD *)a2 + 22)) >> 4);
    *(_BYTE *)(a1 + 200) = *((_BYTE *)a2 + 200);
    v191 = *((_QWORD *)a2 + 26);
    if ((v191 & 1) != 0)
      v192 = *((_QWORD *)a2 + 27);
    else
      v192 = (uint64_t)a2 + 216;
    absl::inlined_vector_internal::Storage<webrtc::VideoFrameBuffer::Type,5ul,std::allocator<webrtc::VideoFrameBuffer::Type>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<webrtc::VideoFrameBuffer::Type>,webrtc::VideoFrameBuffer::Type const*>>((unint64_t *)(a1 + 208), v192, v191 >> 1);
    goto LABEL_257;
  }
  v164 = 0;
  if (v163 < 0x20)
    goto LABEL_221;
  if ((unint64_t)(v160 - (_QWORD)v156) < 0x20)
    goto LABEL_221;
  v164 = v163 & 0x7FFFFFFFFFFFFFE0;
  v165 = &v156[v163 & 0x7FFFFFFFFFFFFFE0];
  v166 = (_OWORD *)(v160 + 16);
  v167 = (__int128 *)(v156 + 16);
  v168 = v163 & 0x7FFFFFFFFFFFFFE0;
  do
  {
    v169 = *v167;
    *(v166 - 1) = *(v167 - 1);
    *v166 = v169;
    v166 += 2;
    v167 += 2;
    v168 -= 32;
  }
  while (v168);
  v156 += v163 & 0x7FFFFFFFFFFFFFE0;
  if (v163 != v164)
  {
LABEL_221:
    v170 = v163 - v164;
    v171 = (_BYTE *)(v160 + v164);
    v165 = v156;
    do
    {
      v172 = *v165++;
      *v171++ = v172;
      --v170;
    }
    while (v170);
  }
  if (v161 >= v157)
    goto LABEL_237;
LABEL_224:
  if (v160)
  {
    v173 = 0;
    v174 = 0;
    v175 = (char *)(v160 + v161);
    v157 = v162;
    v156 = v165;
    v176 = 0;
    if (v157 < 8)
      goto LABEL_235;
LABEL_232:
    if ((unint64_t)(v175 - v156) < 0x20)
    {
LABEL_235:
      v177 = v156;
      goto LABEL_247;
    }
    if (v157 >= 0x20)
    {
      v176 = v157 & 0xFFFFFFFFFFFFFFE0;
      v179 = v175 + 16;
      v180 = (__int128 *)(v156 + 16);
      v181 = v157 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v182 = *v180;
        *(v179 - 1) = *(v180 - 1);
        *v179 = v182;
        v179 += 2;
        v180 += 2;
        v181 -= 32;
      }
      while (v181);
      if (v157 == v176)
        goto LABEL_249;
      if ((v157 & 0x18) == 0)
      {
        v177 = &v156[v176];
LABEL_247:
        v188 = v157 - v176;
        v189 = &v175[v176];
        do
        {
          v190 = *v177++;
          *v189++ = v190;
          --v188;
        }
        while (v188);
        goto LABEL_249;
      }
    }
    else
    {
      v176 = 0;
    }
    v183 = v176;
    v176 = v157 & 0xFFFFFFFFFFFFFFF8;
    v177 = &v156[v157 & 0xFFFFFFFFFFFFFFF8];
    v184 = &v175[v183];
    v185 = (uint64_t *)&v156[v183];
    v186 = v183 - (v157 & 0xFFFFFFFFFFFFFFF8);
    do
    {
      v187 = *v185++;
      *(_QWORD *)v184 = v187;
      v184 += 8;
      v186 += 8;
    }
    while (v186);
    if (v157 != v176)
      goto LABEL_247;
LABEL_249:
    v178 = *(_QWORD *)(a1 + 152);
    if (v173)
    {
      if ((v178 & 1) != 0)
        operator delete(*(void **)(a1 + 160));
      *(_QWORD *)(a1 + 160) = v173;
      *(_QWORD *)(a1 + 168) = v174;
      LOBYTE(v178) = 1;
    }
    goto LABEL_253;
  }
LABEL_258:
  __break(1u);
}

uint64_t webrtc::VideoEncoderConfig::operator=(uint64_t a1, uint64_t a2)
{
  __int128 *v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;

  v4 = (__int128 *)(a2 + 8);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  v5 = a1 + 8;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)v5);
  v6 = *v4;
  *(_QWORD *)(v5 + 16) = *((_QWORD *)v4 + 2);
  *(_OWORD *)v5 = v6;
  *(_BYTE *)(a2 + 31) = 0;
  *(_BYTE *)(a2 + 8) = 0;
  v7 = a1 + 40;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1 + 32, *(_QWORD *)(a1 + 40));
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  v8 = (_QWORD *)(a2 + 40);
  v9 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 40) = v9;
  v10 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 48) = v10;
  if (v10)
  {
    *(_QWORD *)(v9 + 16) = v7;
    *(_QWORD *)(a2 + 32) = v8;
    *v8 = 0;
    *(_QWORD *)(a2 + 48) = 0;
    if (a1 == a2)
      goto LABEL_10;
  }
  else
  {
    *(_QWORD *)(a1 + 32) = v7;
    if (a1 == a2)
      goto LABEL_10;
  }
  if ((*(_BYTE *)(a1 + 56) & 1) != 0)
    operator delete(*(void **)(a1 + 64));
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  v11 = *(_OWORD *)(a2 + 64);
  v12 = *(_OWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 64) = v11;
  *(_OWORD *)(a1 + 80) = v12;
  *(_QWORD *)(a2 + 56) = 0;
LABEL_10:
  v13 = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = 0;
  v14 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 104) = v13;
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  v15 = *(void **)(a1 + 112);
  if (v15)
  {
    *(_QWORD *)(a1 + 120) = v15;
    operator delete(v15);
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  v16 = *(_DWORD *)(a2 + 136);
  *(_BYTE *)(a1 + 140) = *(_BYTE *)(a2 + 140);
  *(_DWORD *)(a1 + 136) = v16;
  v17 = *(_QWORD *)(a2 + 144);
  *(_QWORD *)(a2 + 144) = 0;
  v18 = *(_QWORD *)(a1 + 144);
  *(_QWORD *)(a1 + 144) = v17;
  if (v18)
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
  v19 = *(void **)(a1 + 168);
  *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
  if (v19)
  {
    *(_QWORD *)(a1 + 176) = v19;
    operator delete(v19);
    *(_QWORD *)(a1 + 168) = 0;
    *(_QWORD *)(a1 + 176) = 0;
    *(_QWORD *)(a1 + 184) = 0;
  }
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
  *(_QWORD *)(a2 + 168) = 0;
  *(_QWORD *)(a2 + 176) = 0;
  *(_QWORD *)(a2 + 184) = 0;
  *(_OWORD *)(a1 + 192) = *(_OWORD *)(a2 + 192);
  return a1;
}

void absl::inlined_vector_internal::Storage<webrtc::VideoFrameBuffer::Type,5ul,std::allocator<webrtc::VideoFrameBuffer::Type>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<webrtc::VideoFrameBuffer::Type>,webrtc::VideoFrameBuffer::Type const*>>(unint64_t *a1, uint64_t a2, unint64_t a3)
{
  int *v4;
  unint64_t v6;
  void **v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int *v16;
  _OWORD *v17;
  __int128 *v18;
  uint64_t v19;
  __int128 v20;
  unint64_t v21;
  _DWORD *v22;
  int v23;
  unint64_t v24;
  char *v25;
  char *v26;
  unint64_t v27;
  int *v28;
  _OWORD *v29;
  __int128 *v30;
  unint64_t v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  int v35;

  v4 = (int *)a2;
  v7 = (void **)(a1 + 1);
  v6 = *a1;
  v8 = *a1 & 1;
  if ((*a1 & 1) == 0)
  {
    v9 = 5;
    v10 = a1 + 1;
    if (a3 <= 5)
      goto LABEL_3;
LABEL_19:
    if (2 * v9 <= a3)
      v24 = a3;
    else
      v24 = 2 * v9;
    if (!(v24 >> 62))
    {
      v25 = (char *)operator new(4 * v24);
      v26 = v25;
      v13 = a3;
      v16 = v4;
      v27 = 0;
      if (a3 < 8)
        goto LABEL_33;
LABEL_28:
      if ((unint64_t)(v26 - (char *)v16) >= 0x20)
      {
        v27 = v13 & 0xFFFFFFFFFFFFFFF8;
        v28 = &v16[v13 & 0xFFFFFFFFFFFFFFF8];
        v29 = v26 + 16;
        v30 = (__int128 *)(v16 + 4);
        v31 = v13 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v32 = *v30;
          *(v29 - 1) = *(v30 - 1);
          *v29 = v32;
          v29 += 2;
          v30 += 2;
          v31 -= 8;
        }
        while (v31);
        if (v13 == v27)
        {
LABEL_36:
          if (v25)
          {
            if (v8)
              operator delete(*v7);
            a1[1] = (unint64_t)v25;
            a1[2] = v24;
            v8 = 1;
          }
          goto LABEL_40;
        }
LABEL_34:
        v33 = v13 - v27;
        v34 = &v26[4 * v27];
        do
        {
          v35 = *v28++;
          *(_DWORD *)v34 = v35;
          v34 += 4;
          --v33;
        }
        while (v33);
        goto LABEL_36;
      }
LABEL_33:
      v28 = v16;
      goto LABEL_34;
    }
LABEL_42:
    std::__throw_bad_array_new_length[abi:sn180100]();
  }
  v10 = (_QWORD *)a1[1];
  v9 = a1[2];
  if (v9 < a3)
    goto LABEL_19;
LABEL_3:
  v11 = v6 >> 1;
  v12 = a3 >= v6 >> 1;
  v13 = a3 - (v6 >> 1);
  if (!v12)
    v13 = 0;
  if (v11 >= a3)
    v14 = a3;
  else
    v14 = v11;
  if (!v14)
  {
    v16 = (int *)a2;
    if (v11 >= a3)
      goto LABEL_40;
    goto LABEL_26;
  }
  v15 = 0;
  if (v14 < 8)
    goto LABEL_14;
  if ((unint64_t)v10 - a2 < 0x20)
    goto LABEL_14;
  v15 = v14 & 0x7FFFFFFFFFFFFFF8;
  v16 = (int *)(a2 + 4 * (v14 & 0x7FFFFFFFFFFFFFF8));
  v17 = v10 + 2;
  v18 = (__int128 *)(a2 + 16);
  v19 = v14 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    v20 = *v18;
    *(v17 - 1) = *(v18 - 1);
    *v17 = v20;
    v17 += 2;
    v18 += 2;
    v19 -= 8;
  }
  while (v19);
  v4 = (int *)(a2 + 4 * (v14 & 0x7FFFFFFFFFFFFFF8));
  if (v14 != v15)
  {
LABEL_14:
    v21 = v14 - v15;
    v22 = (_DWORD *)v10 + v15;
    v16 = v4;
    do
    {
      v23 = *v16++;
      *v22++ = v23;
      --v21;
    }
    while (v21);
  }
  if (v11 < a3)
  {
LABEL_26:
    if (v10)
    {
      v25 = 0;
      v24 = 0;
      v26 = (char *)v10 + 4 * v11;
      v27 = 0;
      if (v13 < 8)
        goto LABEL_33;
      goto LABEL_28;
    }
    __break(1u);
    goto LABEL_42;
  }
LABEL_40:
  *a1 = v8 | (2 * a3);
}

void cricket::EncoderStreamFactory::CreateEncoderStreams(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t v6;
  double v7;
  const std::nothrow_t *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int64_t v18;
  unint64_t v19;
  unint64_t v20;
  unsigned __int8 *v21;
  unint64_t v22;
  int v23;
  unsigned __int8 **v24;
  unsigned __int8 *v25;
  unint64_t v26;
  int v27;
  unsigned __int8 v28;
  int v29;
  unsigned __int8 v30;
  int v31;
  char v32;
  unsigned __int8 *v33;
  int v34;
  unsigned __int8 v35;
  int v36;
  unsigned __int8 v37;
  int v38;
  unsigned __int8 v39;
  int v40;
  unsigned __int8 v41;
  uint64_t v42;
  int IsTemporalLayersSupported;
  uint64_t v44;
  int v45;
  _BOOL4 v46;
  uint64_t v47;
  int v48;
  int v49;
  int v50;
  int v51;
  _BOOL4 v52;
  unint64_t v53;
  __int32 v54;
  int v55;
  int v56;
  int v57;
  char v58;
  unint64_t v59;
  BOOL v60;
  int v61;
  int v62;
  uint64_t v63;
  double v64;
  uint64_t v65;
  int v66;
  int v67;
  unsigned int v68;
  int v69;
  unsigned int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  unint64_t Base2Exponent;
  char v77;
  double v78;
  int v79;
  uint8x8_t v80;
  BOOL v81;
  unint64_t v83;
  int v84;
  unint64_t v85;
  char v87;
  unint64_t v88;
  char v90;
  int v91;
  uint64_t v92;
  int64_t v93;
  unint64_t v94;
  _BYTE *v95;
  _BYTE *v96;
  uint64_t v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  _BYTE *v101;
  int v102;
  uint64_t LayerResolutionFromRequestedResolution;
  unint64_t v104;
  double v105;
  int v106;
  int v107;
  int64_t v108;
  int v109;
  int v110;
  int64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  int v115;
  int v116;
  int v117;
  const float *v118;
  int32x2_t v119;
  int v120;
  unint64_t v121;
  char v122;
  uint64_t *v123;
  unint64_t v124;
  unint64_t v125;
  int v126;
  uint64_t v127;
  int v128;
  int v129;
  int v130;
  unint64_t v131;
  float v132;
  char *v133;
  char *v134;
  int v135;
  unint64_t v136;
  int v137;
  char *v138;
  int v139;
  int v140;
  int *v141;
  unint64_t v142;
  int v143;
  int v144;
  uint64_t v145;
  int *v146;
  int v147;
  unint64_t v148;
  int64x2_t *v149;
  unint64_t v150;
  uint64_t v151;
  uint64_t *v152;
  unint64_t v153;
  int64x2_t v154;
  int64x2_t *v155;
  int64x2_t v156;
  int64x2_t v157;
  uint64_t v158;
  unint64_t *v159;
  unint64_t *v160;
  uint64_t v161;
  uint64_t v162;
  int v163;
  unint64_t v164;
  int v165;
  int v166;
  int v167;
  unint64_t v168;
  int *v169;
  uint64_t v170;
  int v171;
  int v172;
  int v173;
  int v174;
  unint64_t v175;
  int v176;
  int v177;
  __int16 v178;
  char *v179;
  int v180;
  uint64_t v181;
  unint64_t v182;
  uint64_t *v183;
  uint64_t v184;
  int v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t *v188;
  __int128 v189;
  char v190;
  char v191;
  char *v192;
  char *v193;
  char v194[10];
  unsigned __int8 v195;
  _DWORD v196[4];

  LODWORD(v9) = a4;
  LODWORD(v10) = a3;
  v11 = a2;
  webrtc::GetExperimentalMinVideoBitrate(a2, *(_DWORD *)a5);
  v15 = v14;
  v17 = v16;
  v183 = (uint64_t *)a6;
  if (*(_QWORD *)(a5 + 192) >= 2uLL)
  {
    v18 = *(_QWORD *)(a5 + 168);
    v19 = *(_QWORD *)(a5 + 176) - v18;
    if (!v19)
      goto LABEL_342;
    if (!*(_BYTE *)(v18 + 81))
    {
LABEL_61:
      v42 = v11;
      *(_QWORD *)a6 = 0;
      *(_QWORD *)(a6 + 8) = 0;
      *(_QWORD *)(a6 + 16) = 0;
      v186 = a1 + 8;
      v11 = *(_QWORD *)(a5 + 192);
      v184 = v15;
      v6 = 0;
      if (v11)
      {
        v44 = *(_QWORD *)(a5 + 168);
        v18 = 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a5 + 176) - v44) >> 5);
        v19 = v44 + 82;
        do
        {
          if (v18 == v6)
            goto LABEL_342;
          ++v6;
          if (*(_BYTE *)v19)
            goto LABEL_67;
          v19 += 96;
        }
        while (v11 != v6);
        v6 = 0;
      }
LABEL_67:
      v185 = v10;
      v45 = *(_DWORD *)(a1 + 32);
      v181 = v17;
      LODWORD(a6) = IsTemporalLayersSupported;
      if (*(_BYTE *)(a1 + 36))
        v46 = *(_BYTE *)(a1 + 37) != 0;
      else
        v46 = 0;
      v7 = *(double *)(a5 + 160);
      LODWORD(v17) = *(_DWORD *)a5;
      webrtc::RateControlSettings::RateControlSettings((uint64_t)&v188, v42);
      v187 = a1;
      if (v46)
      {
        LODWORD(v10) = v185;
        cricket::GetScreenshareLayers(v11, v185, (int)v9, v45, a6, (char **)&v188, v7);
        v15 = (uint64_t)v183;
      }
      else
      {
        v52 = v191 != 0;
        LODWORD(v10) = v185;
        v53 = cricket::LimitSimulcastLayerCount(v185, (int)v9, v6, v11, v42, v17);
        v54 = v45;
        v15 = (uint64_t)v183;
        cricket::GetNormalSimulcastLayers(v53, v185, (int)v9, v54, a6, v52, v42, v17, (int32x2_t **)&v188, v7);
      }
      v11 = (unint64_t)v188;
      *(_QWORD *)v15 = v188;
      v182 = v189;
      *(_OWORD *)(v15 + 8) = v189;
      if ((_BYTE)v181)
        __asm { BR              X11 }
      v71 = *(_QWORD *)(a5 + 168);
      v72 = *(_QWORD *)(a5 + 176);
      if (v71 == v72)
      {
LABEL_143:
        LODWORD(v184) = 0;
        webrtc::NormalizeSimulcastSizeExperiment::GetBase2Exponent(v42);
        if ((int)v10 >= 16)
        {
LABEL_144:
          v74 = v10;
          LODWORD(v10) = *(_DWORD *)(a5 + 192) - 1;
          Base2Exponent = (unint64_t)webrtc::NormalizeSimulcastSizeExperiment::GetBase2Exponent(v42);
          if (1 << Base2Exponent >= v74 || (Base2Exponent & 0xFF00000000) == 0)
            v77 = v10;
          else
            v77 = Base2Exponent;
          v185 = (-1 << v77) & v74;
        }
LABEL_151:
        LODWORD(a6) = (_DWORD)v9;
        if ((int)v9 < 16)
        {
LABEL_184:
          v91 = v185;
          if (v182 != v11)
          {
            v185 = 0;
            v17 = 0;
            LODWORD(v6) = v91;
            v7 = (double)v91;
            v18 = *(_QWORD *)(a5 + 168);
            v19 = *(_QWORD *)(a5 + 176);
            v15 = (uint64_t)(v182 - v11) / 96 - 1;
            if ((unint64_t)((uint64_t)(v182 - v11) / 96) <= 1)
              v92 = 1;
            else
              v92 = (uint64_t)(v182 - v11) / 96;
            v10 = 92;
            LODWORD(a6) = -1431655765;
            while (1)
            {
              v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v18) >> 5);
              if (v19 <= v17)
                goto LABEL_342;
              v93 = v18 + v10;
              v94 = v11 + v10;
              *(_BYTE *)(v94 - 10) = *(_BYTE *)(v93 - 10);
              *(_WORD *)(v94 - 12) = *(_WORD *)(v93 - 12);
              v18 = *(_QWORD *)(a5 + 168);
              v19 = 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a5 + 176) - v18) >> 5);
              if (v19 <= v17)
                goto LABEL_342;
              if ((uint64_t)(v182 - v11) / 96 == v17)
                goto LABEL_342;
              v95 = (_BYTE *)(v18 + v10);
              v96 = (_BYTE *)(v11 + v10);
              v97 = *((_QWORD *)v95 - 1);
              *v96 = *v95;
              *((_QWORD *)v96 - 1) = v97;
              v18 = *(_QWORD *)(a5 + 168);
              v19 = *(_QWORD *)(a5 + 176);
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v18) >> 5) <= v17)
                goto LABEL_342;
              if (*(_BYTE *)(v18 + v10 - 36))
              {
                v18 = *(_QWORD *)(a5 + 168);
                v19 = *(_QWORD *)(a5 + 176);
                if (v98)
                {
                  v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v18) >> 5);
                  if (v19 <= v17)
                    goto LABEL_342;
                  v18 += v10;
                  v19 = *(unsigned __int8 *)(v18 - 36);
                  if (!*(_BYTE *)(v18 - 36))
                    goto LABEL_342;
                  v99 = v11 + v10;
                  *(_QWORD *)(v99 - 44) = *(_QWORD *)(v18 - 44);
                  *(_BYTE *)(v99 - 36) = 1;
                  v18 = *(_QWORD *)(a5 + 168);
                  v19 = *(_QWORD *)(a5 + 176);
                }
              }
              v100 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v18) >> 5);
              if (v100 <= v17)
                goto LABEL_342;
              v101 = (_BYTE *)(v18 + v10);
              v102 = *(_DWORD *)(v18 + v10 - 76);
              if (v102 >= 1)
                *(_DWORD *)(v11 + v10 - 76) = v102;
              if (*v101)
              {
                LayerResolutionFromRequestedResolution = cricket::EncoderStreamFactory::GetLayerResolutionFromRequestedResolution(v187, v6, (int)v9, *((_QWORD *)v101 - 1));
                v104 = v11 + v10;
                *(_QWORD *)(v104 - 92) = (int)LayerResolutionFromRequestedResolution;
                *(_QWORD *)(v104 - 84) = LayerResolutionFromRequestedResolution >> 32;
                v18 = *(_QWORD *)(a5 + 168);
                v19 = *(_QWORD *)(a5 + 176);
                v100 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v18) >> 5);
              }
              else if ((_DWORD)v184)
              {
                v105 = *(double *)(v18 + v10 - 60);
                if (v105 < 1.0)
                  v105 = 1.0;
                v106 = v6;
                if ((int)v6 >= 17)
                {
                  v106 = (int)(v7 / v105 + 0.5);
                  if (v106 <= 16)
                    v106 = 16;
                }
                *(_QWORD *)(v11 + v10 - 92) = v106;
                v107 = (int)v9;
                if ((int)v9 >= 17)
                {
                  v107 = (int)((double)(int)v9 / v105 + 0.5);
                  if (v107 <= 16)
                    v107 = 16;
                }
                *(_QWORD *)(v11 + v10 - 84) = v107;
              }
              if (v100 <= v17)
                goto LABEL_342;
              v108 = v18 + v10;
              v109 = *(_DWORD *)(v18 + v10 - 72);
              if (v109 >= 1)
                *(_DWORD *)(v11 + v10 - 72) = v109;
              v110 = *(_DWORD *)(v108 - 64);
              if (v110 >= 1)
                *(_DWORD *)(v11 + v10 - 64) = v110;
              v111 = v18 + v10;
              v112 = *(_DWORD *)(v18 + v10 - 68);
              if (v112 >= 1)
                *(_DWORD *)(v11 + v10 - 68) = v112;
              v113 = *(_DWORD *)(v108 - 64);
              if (*(int *)(v108 - 72) < 1)
              {
                if (v113 >= 1)
                {
                  v114 = v11 + v10;
                  v115 = *(_DWORD *)(v11 + v10 - 64);
                  v116 = *(_DWORD *)(v11 + v10 - 72);
                  if (v115 < v116)
                    v116 = *(_DWORD *)(v11 + v10 - 64);
                  *(_DWORD *)(v114 - 72) = v116;
                  if (*(int *)(v111 - 68) < 1)
                  {
                    v117 = 3 * v115 / 4;
                    if (*(_DWORD *)(v114 - 68) > v117)
                      v117 = *(_DWORD *)(v114 - 68);
                  }
                  else
                  {
                    v117 = *(_DWORD *)(v114 - 68);
                  }
                  if (v115 < v117)
                    v117 = v115;
                  if (v117 <= v116)
                    v117 = v116;
                  goto LABEL_240;
                }
              }
              else if (v113 < 1)
              {
                v118 = (const float *)(v11 + v10 - 72);
                v119 = (int32x2_t)vld1_dup_f32(v118);
                *(int32x2_t *)(v11 + v10 - 68) = vmax_s32(*(int32x2_t *)(v11 + v10 - 68), v119);
              }
              else
              {
                if (*(int *)(v111 - 68) >= 1)
                {
                  v114 = v11 + v10;
                  if (*(_DWORD *)(v11 + v10 - 68) >= *(_DWORD *)(v11 + v10 - 72))
                    goto LABEL_241;
LABEL_233:
                  v117 = *(_DWORD *)(v114 - 64);
LABEL_240:
                  *(_DWORD *)(v114 - 68) = v117;
                  goto LABEL_241;
                }
                v120 = 3 * *(_DWORD *)(v11 + v10 - 64) / 4;
                *(_DWORD *)(v11 + v10 - 68) = v120;
                v114 = v11 + v10;
                if (v120 < *(_DWORD *)(v11 + v10 - 72))
                  goto LABEL_233;
              }
LABEL_241:
              if (v15 == v17)
                v185 = *(_DWORD *)(v108 - 64) > 0;
              ++v17;
              v10 += 96;
              if (v92 == v17)
              {
                v121 = v182;
                v122 = v185;
                v123 = v183;
                if (!*(_BYTE *)(v187 + 36))
                  goto LABEL_246;
                goto LABEL_294;
              }
            }
          }
          v122 = 0;
          v121 = v11;
          v123 = v183;
          if (*(_BYTE *)(v187 + 36))
          {
LABEL_294:
            if (v121 == v11)
            {
              v10 = 0;
              v149 = 0;
              goto LABEL_303;
            }
            v148 = (uint64_t)(v121 - v11) / 96;
            if (v148 >> 61)
              abort();
            LODWORD(v11) = 8 * v148;
            v149 = (int64x2_t *)operator new(8 * v148);
            v10 = (uint64_t)&v149->i64[v148];
            bzero(v149, 8 * v148);
            v150 = (v148 - 1) & 0x1FFFFFFFFFFFFFFFLL;
            if (v150 >= 3)
            {
              v153 = v150 + 1;
              v151 = (v150 + 1) & 0x3FFFFFFFFFFFFFFCLL;
              v152 = &v149->i64[v151];
              v154 = (int64x2_t)xmmword_208F05120;
              v155 = v149 + 1;
              v156 = vdupq_n_s64(2uLL);
              v157 = vdupq_n_s64(4uLL);
              v158 = v151;
              do
              {
                v155[-1] = v154;
                *v155 = vaddq_s64(v154, v156);
                v154 = vaddq_s64(v154, v157);
                v155 += 2;
                v158 -= 4;
              }
              while (v158);
              if (v153 == v151)
              {
LABEL_303:
                v188 = v123;
                a6 = (v10 - (uint64_t)v149) >> 3;
                if (v10 - (uint64_t)v149 < 1025)
                {
LABEL_307:
                  std::__stable_sort<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>((unint64_t *)v149, (unint64_t *)v10, &v188, (v10 - (uint64_t)v149) >> 3, 0, 0);
                  if ((int64x2_t *)v10 != v149)
                    goto LABEL_310;
                }
                else
                {
                  v9 = (const std::nothrow_t *)MEMORY[0x24BEDB6B8];
                  v11 = (v10 - (uint64_t)v149) >> 3;
                  while (1)
                  {
                    v159 = (unint64_t *)operator new(8 * v11, v9);
                    if (v159)
                      break;
                    v81 = v11 > 1;
                    v11 >>= 1;
                    if (!v81)
                      goto LABEL_307;
                  }
                  v160 = v159;
                  std::__stable_sort<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>((unint64_t *)v149, (unint64_t *)v10, &v188, (v10 - (uint64_t)v149) >> 3, v159, v11);
                  operator delete(v160);
                  if ((int64x2_t *)v10 != v149)
                  {
LABEL_310:
                    v161 = v149->i64[0];
                    v18 = *v123;
                    v19 = 0xAAAAAAAAAAAAAAABLL * ((v123[1] - *v123) >> 5);
                    if (v19 > v149->i64[0])
                    {
                      if (*(_BYTE *)(v18 + 96 * v161 + 82))
                      {
LABEL_319:
                        operator delete(v149);
                        return;
                      }
                      v162 = 0;
                      v163 = *(_DWORD *)(v18 + 96 * v161 + 20);
                      while (a6 != v162)
                      {
                        v164 = v149->u64[v162];
                        if (v19 <= v164)
                          break;
                        if (*(_BYTE *)(v18 + 96 * v164 + 82))
                        {
                          *(_DWORD *)(v18 + 96 * v164 + 20) = v163;
                          goto LABEL_319;
                        }
                        if (v19 == ++v162)
                          goto LABEL_319;
                      }
                    }
                    goto LABEL_342;
                  }
                }
                do
                {
LABEL_342:
                  __break(1u);
LABEL_343:
                  v175 = 0;
                }
                while (v19 == v18);
                goto LABEL_344;
              }
            }
            else
            {
              v151 = 0;
              v152 = (uint64_t *)v149;
            }
            do
              *v152++ = v151++;
            while (v152 != (uint64_t *)v10);
            goto LABEL_303;
          }
LABEL_246:
          if ((v122 & 1) != 0)
            goto LABEL_294;
          v18 = *(unsigned int *)(a5 + 156);
          if ((int)v18 < 1 || v11 == v121)
            goto LABEL_294;
          v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v121 - v11) >> 5);
          v124 = v19 - 1;
          if (v19 == 1)
          {
            v126 = 0;
            goto LABEL_292;
          }
          if (v19 < 2)
            goto LABEL_342;
          if (v121 - v11 == 192)
          {
            v125 = 0;
            v126 = 0;
          }
          else
          {
            v139 = 0;
            v140 = 0;
            v125 = v124 & 0xFFFFFFFFFFFFFFFELL;
            v141 = (int *)(v11 + 120);
            v142 = v124 & 0xFFFFFFFFFFFFFFFELL;
            do
            {
              v143 = *(v141 - 24);
              v144 = *v141;
              v141 += 48;
              v139 += v143;
              v140 += v144;
              v142 -= 2;
            }
            while (v142);
            v126 = v140 + v139;
            if (v124 == v125)
            {
LABEL_292:
              if (*(_DWORD *)(v121 - 68) + v126 < v18)
                *(_DWORD *)(v121 - 68) = v18 - v126;
              goto LABEL_294;
            }
          }
          v145 = ~v125 - 0x5555555555555555 * ((uint64_t)(v121 - v11) >> 5);
          v146 = (int *)(v11 + 96 * v125 + 24);
          do
          {
            v147 = *v146;
            v146 += 24;
            v126 += v147;
            --v145;
          }
          while (v145);
          goto LABEL_292;
        }
      }
      else
      {
        v73 = *(_QWORD *)(a5 + 168);
        while (*(double *)(v73 + 32) == -1.0)
        {
          v73 += 96;
          if (v73 == v72)
            goto LABEL_143;
        }
        while (1)
        {
          v78 = *(double *)(v71 + 32);
          if (v78 < 1.0)
            v78 = 1.0;
          v60 = round(v78) == v78;
          v79 = (int)v78;
          LODWORD(v78) = (int)v78;
          v80 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v78);
          v80.i16[0] = vaddlv_u8(v80);
          v81 = !v60 || v79 < 1;
          if (v81 || v80.i32[0] >= 2u)
            break;
          v71 += 96;
          if (v71 == v72)
          {
            LODWORD(v184) = 1;
            webrtc::NormalizeSimulcastSizeExperiment::GetBase2Exponent(v42);
            if ((int)v10 >= 16)
              goto LABEL_144;
            goto LABEL_151;
          }
        }
        v83 = (unint64_t)webrtc::NormalizeSimulcastSizeExperiment::GetBase2Exponent(v42);
        v84 = v10;
        v10 = v83 & 0xFF00000000;
        if (v84 >= 16 && v10)
        {
          LODWORD(a6) = *(_DWORD *)(a5 + 192) - 1;
          v85 = (unint64_t)webrtc::NormalizeSimulcastSizeExperiment::GetBase2Exponent(v42);
          if (1 << v85 >= v185 || (v85 & 0xFF00000000) == 0)
            v87 = a6;
          else
            v87 = v85;
          v185 &= -1 << v87;
        }
        LODWORD(v184) = 1;
        if ((int)v9 < 16)
          goto LABEL_184;
        LODWORD(a6) = (_DWORD)v9;
        if (!v10)
          goto LABEL_183;
      }
      LODWORD(v10) = *(_DWORD *)(a5 + 192) - 1;
      v88 = (unint64_t)webrtc::NormalizeSimulcastSizeExperiment::GetBase2Exponent(v42);
      if (1 << v88 >= (int)a6 || (v88 & 0xFF00000000) == 0)
        v90 = v10;
      else
        v90 = v88;
      LODWORD(a6) = (-1 << v90) & a6;
LABEL_183:
      LODWORD(v9) = a6;
      goto LABEL_184;
    }
    v20 = (uint64_t)v19 / 96;
    if (v20 >= 2)
    {
      v21 = (unsigned __int8 *)(v18 + 178);
      v22 = v20 - 1;
      do
      {
        v23 = *v21;
        v21 += 96;
        if (v23)
          goto LABEL_61;
      }
      while (--v22);
    }
  }
  v24 = (unsigned __int8 **)(a1 + 8);
  v18 = *(char *)(a1 + 31);
  v19 = *(unsigned __int8 *)(a1 + 31);
  v25 = (unsigned __int8 *)(a1 + 8);
  v26 = v19;
  if ((v18 & 0x80000000) != 0)
  {
    v26 = *(_QWORD *)(a1 + 16);
    if ((v26 & 0x8000000000000000) != 0)
      goto LABEL_342;
    v25 = *v24;
    if (v26)
    {
      if (!v25)
        goto LABEL_342;
    }
  }
  if (v26 == 3)
  {
    v27 = *v25;
    v28 = cricket::kVp8CodecName;
    if (v27 == cricket::kVp8CodecName)
      goto LABEL_19;
    if ((v27 - 65) < 0x1A)
      LOBYTE(v27) = v27 + 32;
    if (cricket::kVp8CodecName - 65 < 0x1A)
      v28 = cricket::kVp8CodecName + 32;
    if (v27 == v28)
    {
LABEL_19:
      v29 = v25[1];
      v30 = HIBYTE(cricket::kVp8CodecName);
      if (v29 == HIBYTE(cricket::kVp8CodecName))
        goto LABEL_29;
      if ((v29 - 65) < 0x1A)
        LOBYTE(v29) = v29 + 32;
      if (HIBYTE(cricket::kVp8CodecName) - 65 < 0x1A)
        v30 = HIBYTE(cricket::kVp8CodecName) + 32;
      if (v29 == v30)
      {
LABEL_29:
        v31 = v25[2];
        if (v31 == 56)
          goto LABEL_356;
        v32 = (v31 - 65) >= 0x1A ? v25[2] : v31 + 32;
        if (v32 == 56)
          goto LABEL_356;
      }
    }
  }
  v33 = (unsigned __int8 *)(a1 + 8);
  if ((v18 & 0x80000000) != 0)
  {
    v19 = *(_QWORD *)(a1 + 16);
    if ((v19 & 0x8000000000000000) != 0)
      goto LABEL_342;
    v33 = *v24;
    if (v19)
    {
      if (!v33)
        goto LABEL_342;
    }
  }
  if (v19 == 4)
  {
    v34 = *v33;
    v35 = cricket::kH264CodecName[0];
    if (v34 == cricket::kH264CodecName[0])
      goto LABEL_41;
    if ((v34 - 65) < 0x1A)
      LOBYTE(v34) = v34 + 32;
    if (cricket::kH264CodecName[0] - 65 < 0x1A)
      v35 = cricket::kH264CodecName[0] + 32;
    if (v34 == v35)
    {
LABEL_41:
      v36 = v33[1];
      v37 = cricket::kH264CodecName[1];
      if (v36 == cricket::kH264CodecName[1])
        goto LABEL_58;
      if ((v36 - 65) < 0x1A)
        LOBYTE(v36) = v36 + 32;
      if (cricket::kH264CodecName[1] - 65 < 0x1A)
        v37 = cricket::kH264CodecName[1] + 32;
      if (v36 == v37)
      {
LABEL_58:
        v38 = v33[2];
        v39 = cricket::kH264CodecName[2];
        if (v38 == cricket::kH264CodecName[2])
          goto LABEL_357;
        if ((v38 - 65) < 0x1A)
          LOBYTE(v38) = v38 + 32;
        if (cricket::kH264CodecName[2] - 65 < 0x1A)
          v39 = cricket::kH264CodecName[2] + 32;
        if (v38 == v39)
        {
LABEL_357:
          v40 = v33[3];
          v41 = cricket::kH264CodecName[3];
          if (v40 == cricket::kH264CodecName[3])
            goto LABEL_356;
          if ((v40 - 65) < 0x1A)
            LOBYTE(v40) = v40 + 32;
          if (cricket::kH264CodecName[3] - 65 < 0x1A)
            v41 = cricket::kH264CodecName[3] + 32;
          if (v40 == v41)
          {
LABEL_356:
            if (*(_BYTE *)(a1 + 36) && *(_BYTE *)(a1 + 37))
              goto LABEL_61;
          }
        }
      }
    }
  }
  v19 = *(_QWORD *)(a5 + 168);
  v47 = *(_QWORD *)(a5 + 176);
  if (v47 == v19)
    goto LABEL_342;
  v48 = *(_DWORD *)(v19 + 28);
  v49 = *(_DWORD *)(a5 + 156);
  if (v48 < 1)
  {
    if (v49 <= 0)
    {
      v51 = 0;
      v66 = (_DWORD)v9 * v10;
      if (((_DWORD)v9 * v10) >= 0x7E901)
        v67 = 2500;
      else
        v67 = 2000;
      if (v66 <= 0x4B000)
        v67 = 1700;
      if (v66 >= 76801)
        v68 = v67;
      else
        v68 = 600;
      if (v68 <= 0x4B0)
        v69 = 1200;
      else
        v69 = v68;
      if (*(_BYTE *)(a1 + 36))
        v70 = v69;
      else
        v70 = v68;
      v49 = 1000 * v70;
      if ((_BYTE)v17)
LABEL_78:
        __asm { BR              X15 }
    }
    else
    {
      v51 = 1;
      if ((_BYTE)v17)
        goto LABEL_78;
    }
  }
  else
  {
    if (v48 >= v49)
      v50 = *(_DWORD *)(a5 + 156);
    else
      v50 = *(_DWORD *)(v19 + 28);
    if (v49 <= 0)
      v49 = *(_DWORD *)(v19 + 28);
    else
      v49 = v50;
    v51 = 1;
    if ((_BYTE)v17)
      goto LABEL_78;
  }
  v55 = *(_DWORD *)(v19 + 16);
  v56 = *(_DWORD *)(v19 + 20);
  if (v56 < 1)
    v57 = 1;
  else
    v57 = v51;
  v58 = *(_BYTE *)(v19 + 84);
  v196[0] = *(_DWORD *)(v19 + 85);
  *(_DWORD *)((char *)v196 + 3) = *(_DWORD *)(v19 + 88);
  v59 = v19 + 96;
  do
  {
    LOBYTE(v17) = *(_BYTE *)(v59 - 14);
    if ((_BYTE)v17)
      v60 = 1;
    else
      v60 = v59 == v47;
    v59 += 96;
  }
  while (!v60);
  if (v56 >= 1)
    LODWORD(v11) = v56;
  else
    LODWORD(v11) = 30000;
  LODWORD(a6) = v10;
  if (v56 <= v49)
    v61 = v49;
  else
    v61 = v56;
  if (v57)
    LODWORD(v6) = v49;
  else
    LODWORD(v6) = v61;
  if (v55 <= 0)
    v62 = 60;
  else
    v62 = v55;
  v185 = v62;
  LOBYTE(v184) = v58;
  LOBYTE(v182) = *(_BYTE *)(v19 + 92);
  v180 = v51;
  if ((_BYTE)v182)
  {
    v63 = cricket::EncoderStreamFactory::GetLayerResolutionFromRequestedResolution(a1, v10, (int)v9, *(_QWORD *)(v19 + 84));
    v186 = (int)v63;
    v181 = v63 >> 32;
    v18 = *(unsigned __int8 *)(a1 + 31);
    if ((v18 & 0x80) == 0)
    {
LABEL_111:
      v19 = v18;
      v18 = a1 + 8;
      goto LABEL_260;
    }
  }
  else
  {
    v64 = *(double *)(v19 + 32);
    if (v64 <= 1.0)
    {
      v181 = (int)v9;
      v186 = (int)v10;
      if ((v18 & 0x80) == 0)
        goto LABEL_111;
    }
    else
    {
      v186 = (int)v10;
      if ((int)v10 >= 17)
      {
        LODWORD(v65) = (int)((double)(int)v10 / v64 + 0.5);
        if ((int)v65 <= 16)
          v65 = 16;
        else
          v65 = v65;
        v186 = v65;
      }
      if ((int)v9 >= 17)
      {
        LODWORD(v127) = (int)((double)(int)v9 / v64 + 0.5);
        if ((int)v127 <= 16)
          v127 = 16;
        else
          v127 = v127;
        v181 = v127;
        if ((v18 & 0x80) == 0)
          goto LABEL_111;
      }
      else
      {
        v181 = (int)v9;
        if ((v18 & 0x80) == 0)
          goto LABEL_111;
      }
    }
  }
  v19 = *(_QWORD *)(a1 + 16);
  if ((v19 & 0x8000000000000000) != 0)
    goto LABEL_342;
  v18 = (int64_t)*v24;
  if (v19)
  {
    if (!v18)
      goto LABEL_342;
  }
LABEL_260:
  if (v19 != 3)
    goto LABEL_284;
  v128 = *(unsigned __int8 *)v18;
  if (v128 != 86)
  {
    if ((v128 - 65) < 0x1A)
      LOBYTE(v128) = v128 + 32;
    if (v128 != 118)
      goto LABEL_284;
  }
  v129 = *(unsigned __int8 *)(v18 + 1);
  if (v129 != 80)
  {
    if ((v129 - 65) < 0x1A)
      LOBYTE(v129) = v129 + 32;
    if (v129 != 112)
      goto LABEL_284;
  }
  v130 = *(unsigned __int8 *)(v18 + 2);
  if (v130 != 57)
  {
    if ((v130 - 65) < 0x1A)
      LOBYTE(v130) = v130 + 32;
    if (v130 != 57)
    {
LABEL_284:
      LOBYTE(v15) = 0;
      LOBYTE(v10) = 0;
      v18 = *(_QWORD *)(a5 + 168);
      v19 = *(_QWORD *)(a5 + 176);
      if (v19 == v18)
        goto LABEL_342;
      goto LABEL_338;
    }
  }
  (*(void (**)(_QWORD, char *))(**(_QWORD **)(a5 + 144) + 40))(*(_QWORD *)(a5 + 144), v194);
  LOBYTE(v15) = v194[0];
  v131 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a5 + 176) - *(_QWORD *)(a5 + 168)) >> 5);
  if (v131 <= 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a5 + 120) - *(_QWORD *)(a5 + 112)) >> 2))
    v131 = 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a5 + 120) - *(_QWORD *)(a5 + 112)) >> 2);
  if (v131 <= v195)
    LODWORD(v131) = v195;
  if ((int)v9 * (int)v10 >= 1 && (v194[0] > 1u || (int)v131 >= 2))
  {
    v132 = (float)v185;
    if (*(_BYTE *)(a1 + 36))
    {
      webrtc::ConfigureSvcScreenSharing((webrtc *)(int)v10, v132, (int)v9, (int)v131, &v192);
      v133 = v192;
      v134 = v193;
      v135 = v180;
      if (v192 != v193)
        goto LABEL_282;
    }
    else
    {
      LOBYTE(v188) = 0;
      v190 = 0;
      webrtc::ConfigureSvcNormalVideo((int)v10, (int)v9, 0, (int)v131, v194[0], (uint64_t)&v188, &v192, v132);
      v133 = v192;
      v134 = v193;
      v135 = v180;
      if (v192 != v193)
      {
LABEL_282:
        v136 = v134 - v133 - 36;
        if (v136 >= 0x24)
        {
          v166 = 0;
          v167 = 0;
          v168 = v136 / 0x24 + 1;
          v138 = &v133[36 * (v168 & 0xFFFFFFFFFFFFFFELL)];
          v169 = (int *)(v133 + 52);
          v170 = v168 & 0xFFFFFFFFFFFFFFELL;
          do
          {
            v171 = *(v169 - 9);
            v172 = *v169;
            v169 += 18;
            v166 += v171;
            v167 += v172;
            v170 -= 2;
          }
          while (v170);
          v137 = v167 + v166;
          if (v168 == (v168 & 0xFFFFFFFFFFFFFFELL))
            goto LABEL_326;
        }
        else
        {
          v137 = 0;
          v138 = v133;
        }
        do
        {
          v137 += *((_DWORD *)v138 + 4);
          v138 += 36;
        }
        while (v138 != v134);
LABEL_326:
        v165 = 1000 * v137;
        goto LABEL_327;
      }
    }
    v165 = 0;
LABEL_327:
    if (v165 >= (int)v6)
      v173 = v6;
    else
      v173 = v165;
    if (v135)
      v165 = v173;
    if ((int)v11 <= v165)
      LODWORD(v6) = v165;
    else
      LODWORD(v6) = v11;
    if (v133)
      operator delete(v133);
  }
  LOBYTE(v10) = 1;
  v18 = *(_QWORD *)(a5 + 168);
  v19 = *(_QWORD *)(a5 + 176);
  if (v19 == v18)
    goto LABEL_342;
LABEL_338:
  LODWORD(v9) = *(_DWORD *)(v18 + 24);
  LODWORD(a6) = *(_DWORD *)(a1 + 32);
  v7 = *(double *)(a5 + 160);
  v18 = *(_QWORD *)(a5 + 168);
  v19 = *(_QWORD *)(a5 + 176);
  if (!v174)
    goto LABEL_343;
  if (v19 == v18)
    goto LABEL_342;
  if (!*(_BYTE *)(v18 + 56))
    goto LABEL_343;
  v175 = *(_QWORD *)(v18 + 48) & 0xFFFFFFFFFFFFFF00;
  LOBYTE(v10) = 1;
  v15 = *(_QWORD *)(v18 + 48);
  if (v19 == v18)
    goto LABEL_342;
LABEL_344:
  if ((int)v6 >= (int)v9)
    v176 = (int)v9;
  else
    v176 = v6;
  if ((int)v9 >= 1)
    v177 = v176;
  else
    v177 = v6;
  if ((int)v6 < (int)v11)
    LODWORD(v11) = v6;
  v178 = *(_WORD *)(v18 + 80);
  v179 = (char *)operator new(0x60uLL);
  *(_QWORD *)v179 = v186;
  *((_QWORD *)v179 + 1) = v181;
  *((_DWORD *)v179 + 4) = v185;
  *((_DWORD *)v179 + 5) = v11;
  *((_DWORD *)v179 + 6) = v177;
  *((_DWORD *)v179 + 7) = v6;
  *((_QWORD *)v179 + 4) = 0xBFF0000000000000;
  *((_DWORD *)v179 + 10) = a6;
  *((_QWORD *)v179 + 6) = v175 | v15;
  v179[56] = v10;
  *((double *)v179 + 8) = v7;
  v179[72] = 1;
  *((_WORD *)v179 + 40) = v178;
  v179[82] = v17;
  v179[84] = v184;
  *(_DWORD *)(v179 + 85) = v196[0];
  *((_DWORD *)v179 + 22) = *(_DWORD *)((char *)v196 + 3);
  v179[92] = v182;
  v183[1] = (uint64_t)(v179 + 96);
  v183[2] = (uint64_t)(v179 + 96);
  *v183 = (uint64_t)v179;
}

uint64_t cricket::EncoderStreamFactory::GetLayerResolutionFromRequestedResolution(uint64_t a1, int a2, int a3, unint64_t a4)
{
  unsigned int v4;
  int v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v24;
  char v25;
  int v26;
  char v27;
  int v28[2];
  char v29;
  pthread_mutexattr_t v30;
  int v31;
  int v32;
  void *__p;
  void *v34;
  uint64_t v35;
  char v36;
  char v37;
  char v38;
  __int16 v39;
  _QWORD v40[4];
  int v41;
  int v42;
  char v43;
  char v44;
  char v45;
  char v46;
  char v47;
  char v48;
  char v49;
  char v50;
  char v51;
  char v52;
  unint64_t v53;
  int v54;
  char v55;
  char v56;
  uint64_t v57;
  char v58;
  char v59;
  pthread_mutex_t v60;
  uint64_t v61;

  v4 = a4;
  v61 = *MEMORY[0x24BDAC8D0];
  v8 = *(_DWORD *)(a1 + 40);
  v9 = HIDWORD(a4);
  v40[0] = &off_24C0C2F90;
  memset(&v40[1], 0, 24);
  v41 = v8;
  v42 = v8;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0x8000000080000000;
  v54 = 0x7FFFFFFF;
  v55 = 0;
  v56 = 0;
  v57 = 0x7FEFFFFFFFFFFFFFLL;
  v58 = 0;
  v59 = 0;
  pthread_mutexattr_init(&v30);
  pthread_mutexattr_setpolicy_np(&v30, 3);
  pthread_mutex_init(&v60, &v30);
  pthread_mutexattr_destroy(&v30);
  v26 = v9 * v4;
  v27 = 1;
  LOBYTE(v24) = 0;
  v25 = 0;
  LOBYTE(v30.__sig) = 0;
  v30.__opaque[0] = 0;
  LOBYTE(v28[0]) = 0;
  v29 = 0;
  if ((int)v4 >= 1 && (int)v9 >= 1)
  {
    if (v4 <= v9)
      v10 = v9;
    else
      v10 = v4;
    if (v9 >= v4)
      v11 = v4;
    else
      v11 = v9;
    v30.__sig = v10 | (v11 << 32);
    v30.__opaque[0] = 1;
    *(_QWORD *)v28 = v11 | (v10 << 32);
    v29 = 1;
  }
  cricket::VideoAdapter::OnOutputFormatRequest((uint64_t)v40, &v30.__sig, (unsigned int *)&v26, (uint64_t *)v28, (uint64_t)&v26, (uint64_t)&v24);
  if (*(_BYTE *)(a1 + 96))
  {
    LOWORD(v30.__sig) = 0;
    v30.__opaque[0] = 0;
    v30.__opaque[4] = 0;
    v31 = 0x7FFFFFFF;
    v37 = 0;
    v34 = 0;
    v35 = 0;
    __p = 0;
    v36 = 0;
    v38 = 1;
    if (*(_BYTE *)(a1 + 72))
    {
      *(_DWORD *)v30.__opaque = *(_QWORD *)(a1 + 64);
      v30.__opaque[4] = 1;
    }
    if (*(_BYTE *)(a1 + 56))
      v12 = *(_DWORD *)(a1 + 48);
    else
      v12 = 0x7FFFFFFF;
    v39 = 256;
    v13 = *(_DWORD *)(a1 + 40);
    HIDWORD(v30.__sig) = v12;
    v32 = v13;
    cricket::VideoAdapter::OnSinkWants((cricket::VideoAdapter *)v40, (const rtc::VideoSinkWants *)&v30);
    if (__p)
    {
      v34 = __p;
      operator delete(__p);
    }
  }
  LODWORD(v30.__sig) = 0;
  v28[0] = 0;
  v26 = 0;
  v24 = 0;
  if ((cricket::VideoAdapter::AdaptFrameResolution((cricket::VideoAdapter *)v40, a2, a3, 0, (int *)&v30, v28, &v26, &v24) & 1) == 0&& (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
  {
    rtc::webrtc_logging_impl::Log("\r\t", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/video/config/encoder_stream_factory.cc");
  }
  v21 = v26;
  v22 = v24;
  v40[0] = &off_24C0C2F90;
  pthread_mutex_destroy(&v60);
  return v21 | (v22 << 32);
}

uint64_t cricket::`anonymous namespace'::IsTemporalLayersSupported(uint64_t result)
{
  uint64_t v1;
  unsigned __int8 *v2;
  uint64_t v3;
  int v5;
  unsigned __int8 v6;
  int v7;
  unsigned __int8 v8;
  int v9;
  char v10;
  unsigned __int8 *v11;
  uint64_t v12;
  int v13;
  unsigned __int8 v14;
  int v15;
  unsigned __int8 v16;
  int v17;
  char v18;
  int v19;
  unsigned __int8 v20;
  int v21;
  int v22;
  unsigned __int8 v23;
  int v24;

  v1 = *(unsigned __int8 *)(result + 23);
  v2 = (unsigned __int8 *)result;
  v3 = v1;
  if (*(char *)(result + 23) < 0)
  {
    v3 = *(_QWORD *)(result + 8);
    if (v3 < 0)
      goto LABEL_75;
    v2 = *(unsigned __int8 **)result;
    if (v3 && v2 == 0)
      goto LABEL_75;
  }
  if (v3 == 3)
  {
    v5 = *v2;
    v6 = cricket::kVp8CodecName;
    if (v5 == cricket::kVp8CodecName)
      goto LABEL_14;
    if ((v5 - 65) < 0x1A)
      LOBYTE(v5) = v5 + 32;
    if (cricket::kVp8CodecName - 65 < 0x1A)
      v6 = cricket::kVp8CodecName + 32;
    if (v5 == v6)
    {
LABEL_14:
      v7 = v2[1];
      v8 = HIBYTE(cricket::kVp8CodecName);
      if (v7 == HIBYTE(cricket::kVp8CodecName))
        goto LABEL_20;
      if ((v7 - 65) < 0x1A)
        LOBYTE(v7) = v7 + 32;
      if (HIBYTE(cricket::kVp8CodecName) - 65 < 0x1A)
        v8 = HIBYTE(cricket::kVp8CodecName) + 32;
      if (v7 == v8)
      {
LABEL_20:
        v9 = v2[2];
        if (v9 == 56)
          return 1;
        v10 = (v9 - 65) >= 0x1A ? v2[2] : v9 + 32;
        if (v10 == 56)
          return 1;
      }
    }
  }
  v11 = (unsigned __int8 *)result;
  v12 = *(unsigned __int8 *)(result + 23);
  if ((v1 & 0x80) != 0)
  {
    v12 = *(_QWORD *)(result + 8);
    if (v12 < 0)
      goto LABEL_75;
    v11 = *(unsigned __int8 **)result;
    if (v12)
    {
      if (!v11)
        goto LABEL_75;
    }
  }
  if (v12 == 3)
  {
    v13 = *v11;
    v14 = cricket::kVp9CodecName;
    if (v13 == cricket::kVp9CodecName)
      goto LABEL_38;
    if ((v13 - 65) < 0x1A)
      LOBYTE(v13) = v13 + 32;
    if (cricket::kVp9CodecName - 65 < 0x1A)
      v14 = cricket::kVp9CodecName + 32;
    if (v13 == v14)
    {
LABEL_38:
      v15 = v11[1];
      v16 = HIBYTE(cricket::kVp9CodecName);
      if (v15 == HIBYTE(cricket::kVp9CodecName))
        goto LABEL_44;
      if ((v15 - 65) < 0x1A)
        LOBYTE(v15) = v15 + 32;
      if (HIBYTE(cricket::kVp9CodecName) - 65 < 0x1A)
        v16 = HIBYTE(cricket::kVp9CodecName) + 32;
      if (v15 == v16)
      {
LABEL_44:
        v17 = v11[2];
        if (v17 == 57)
          return 1;
        v18 = (v17 - 65) >= 0x1A ? v11[2] : v17 + 32;
        if (v18 == 57)
          return 1;
      }
    }
  }
  if ((v1 & 0x80) != 0 && ((v1 = *(_QWORD *)(result + 8), v1 < 0) || (result = *(_QWORD *)result, v1) && !result))
  {
LABEL_75:
    __break(1u);
  }
  else if (v1 == 3)
  {
    v19 = *(unsigned __int8 *)result;
    v20 = cricket::kAv1CodecName;
    if (v19 != cricket::kAv1CodecName)
    {
      if ((v19 - 65) < 0x1A)
        LOBYTE(v19) = v19 + 32;
      if (cricket::kAv1CodecName - 65 < 0x1A)
        v20 = cricket::kAv1CodecName + 32;
      v21 = v19 - v20;
      if (v21)
        return v21 == 0;
    }
    v22 = *(unsigned __int8 *)(result + 1);
    v23 = HIBYTE(cricket::kAv1CodecName);
    if (v22 != HIBYTE(cricket::kAv1CodecName))
    {
      if ((v22 - 65) < 0x1A)
        LOBYTE(v22) = v22 + 32;
      if (HIBYTE(cricket::kAv1CodecName) - 65 < 0x1A)
        v23 = HIBYTE(cricket::kAv1CodecName) + 32;
      v21 = v22 - v23;
      if (v21)
        return v21 == 0;
    }
    v24 = *(unsigned __int8 *)(result + 2);
    if (v24 == 49)
      return 1;
    if ((v24 - 65) < 0x1A)
      LOBYTE(v24) = v24 + 32;
    v21 = v24 - 49;
    return !v21 || v21 == 0;
  }
  else
  {
    return 0;
  }
  return result;
}

void std::__stable_sort<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(unint64_t *a1, unint64_t *a2, uint64_t **a3, unint64_t a4, unint64_t *a5, uint64_t a6)
{
  unint64_t *v6;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  int v22;
  unint64_t v23;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t *v29;
  unint64_t *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  char v44;
  unint64_t *v45;
  uint64_t v46;
  _OWORD *v47;
  __int128 v48;
  uint64_t v49;
  unint64_t *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _OWORD *v57;
  __int128 v58;

  if (a4 < 2)
    return;
  v9 = a1;
  if (a4 == 2)
  {
    v10 = *(a2 - 1);
    v11 = **a3;
    v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((*a3)[1] - v11) >> 5);
    if (v12 > v10)
    {
      v13 = *a1;
      if (v12 > *a1)
      {
        if (*(_DWORD *)(v11 + 96 * v10 + 28) < *(_DWORD *)(v11 + 96 * v13 + 28))
        {
          *a1 = v10;
          *(a2 - 1) = v13;
        }
        return;
      }
    }
  }
  else
  {
    if ((uint64_t)a4 > 128)
    {
      v26 = a4 >> 1;
      v27 = &a1[a4 >> 1];
      v28 = a4 >> 1;
      if ((uint64_t)a4 > a6)
      {
        std::__stable_sort<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(a1, v27, a3, v28, a5, a6);
        std::__stable_sort<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(&v9[a4 >> 1], a2, a3, a4 - (a4 >> 1), a5, a6);
        std::__inplace_merge<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(v9, &v9[a4 >> 1], a2, a3, a4 >> 1, a4 - (a4 >> 1), a5, a6);
        return;
      }
      std::__stable_sort_move<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(a1, v27, (char ***)a3, v28, a5);
      v6 = &a5[v26];
      std::__stable_sort_move<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(&v9[a4 >> 1], a2, (char ***)a3, a4 - (a4 >> 1), v6);
      v29 = *a3;
      v30 = v6;
      v12 = (unint64_t)a5;
      v10 = (unint64_t)v9;
      v11 = (unint64_t)&a5[a4];
      while (v30 != (unint64_t *)v11)
      {
        v31 = v30;
        v32 = *v30;
        v33 = *v29;
        v34 = 0xAAAAAAAAAAAAAAABLL * ((v29[1] - *v29) >> 5);
        if (v34 <= v32)
          goto LABEL_51;
        v35 = *(_QWORD *)v12;
        if (v34 <= *(_QWORD *)v12)
          goto LABEL_51;
        v36 = *(_DWORD *)(v33 + 96 * v32 + 28);
        v37 = *(_DWORD *)(v33 + 96 * v35 + 28);
        if (v36 < v37)
          v35 = v32;
        v12 += 8 * (v36 >= v37);
        v30 = &v31[v36 < v37];
        *(_QWORD *)v10 = v35;
        v10 += 8;
        ++v9;
        if ((unint64_t *)v12 == v6)
        {
          if (v30 != (unint64_t *)v11)
          {
            v38 = -8;
            if (v36 >= v37)
              v38 = 0;
            v39 = (char *)&a5[a4] - (char *)v31 + v38 - 8;
            if (v39 < 0x78 || (unint64_t)((char *)v9 - (char *)&v31[v36 < v37]) < 0x20)
              goto LABEL_57;
            v40 = 0;
            v41 = (v39 >> 3) + 1;
            v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
            v30 = (unint64_t *)((char *)v30 + v42);
            v43 = (_QWORD *)(v10 + v42);
            v44 = v36 < v37 ? 1 : 2;
            v45 = &v31[v44 & 1];
            v46 = v41 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v47 = (_OWORD *)(v10 + v40 * 8);
              v48 = *(_OWORD *)&v45[v40 + 2];
              *v47 = *(_OWORD *)&v45[v40];
              v47[1] = v48;
              v40 += 4;
              v46 -= 4;
            }
            while (v46);
            v10 = (unint64_t)v43;
            if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_57:
              do
              {
                v49 = *v30++;
                *(_QWORD *)v10 = v49;
                v10 += 8;
              }
              while (v30 != (unint64_t *)v11);
            }
          }
          return;
        }
      }
      if ((unint64_t *)v12 == v6)
        return;
      v11 = (unint64_t)&a5[v26 - 1] - v12;
      if (v11 < 0x38 || (unint64_t)v9 - v12 < 0x20)
      {
        v50 = (unint64_t *)v12;
        v51 = (_QWORD *)v10;
        goto LABEL_49;
      }
      goto LABEL_52;
    }
    if (a1 == a2)
      return;
    v15 = a1 + 1;
    if (a1 + 1 == a2)
      return;
    v10 = 0;
    v11 = **a3;
    v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((*a3)[1] - v11) >> 5);
    v12 = 96;
    v17 = a1;
    while (1)
    {
      v19 = v15;
      v20 = *v15;
      if (v16 <= v20)
        break;
      v21 = *v17;
      if (v16 <= v21)
        break;
      v22 = *(_DWORD *)(v11 + 96 * v20 + 28);
      if (v22 < *(_DWORD *)(v11 + 96 * v21 + 28))
      {
        v23 = v10;
        do
        {
          *(unint64_t *)((char *)a1 + v23 + 8) = v21;
          if (!v23)
          {
            v18 = a1;
            goto LABEL_13;
          }
          v21 = *(unint64_t *)((char *)a1 + v23 - 8);
          if (v16 <= v21)
            goto LABEL_51;
          v23 -= 8;
        }
        while (v22 < *(_DWORD *)(v11 + 96 * v21 + 28));
        v18 = (unint64_t *)((char *)a1 + v23 + 8);
LABEL_13:
        *v18 = v20;
      }
      v15 = v19 + 1;
      v10 += 8;
      v17 = v19;
      if (v19 + 1 == a2)
        return;
    }
  }
LABEL_51:
  __break(1u);
LABEL_52:
  v53 = 0;
  v54 = (v11 >> 3) + 1;
  v55 = 8 * (v54 & 0x3FFFFFFFFFFFFFFCLL);
  v50 = (unint64_t *)(v12 + v55);
  v51 = (_QWORD *)(v10 + v55);
  v56 = v54 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v57 = (_OWORD *)(v10 + v53);
    v58 = *(_OWORD *)(v12 + v53 + 16);
    *v57 = *(_OWORD *)(v12 + v53);
    v57[1] = v58;
    v53 += 32;
    v56 -= 4;
  }
  while (v56);
  if (v54 != (v54 & 0x3FFFFFFFFFFFFFFCLL))
  {
    do
    {
LABEL_49:
      v52 = *v50++;
      *v51++ = v52;
    }
    while (v50 != v6);
  }
}

__n128 std::__stable_sort_move<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(unint64_t *a1, unint64_t *a2, char ***a3, unint64_t a4, unint64_t *a5)
{
  char *v5;
  unint64_t *v6;
  char *v8;
  unint64_t v11;
  char *v12;
  unint64_t v13;
  int v14;
  int v15;
  char **v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  __n128 result;
  char **v30;
  char *v31;
  unint64_t *v32;
  unint64_t *v33;
  char *v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _BOOL4 v43;
  uint64_t v44;
  unint64_t *v45;
  unint64_t *v46;
  uint64_t v47;
  unint64_t *v48;
  __int128 v49;
  unint64_t v50;
  unint64_t *v51;
  char *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t *v58;
  __int128 v59;

  if (!a4)
    return result;
  v6 = a5;
  v8 = (char *)a1;
  if (a4 == 1)
  {
LABEL_10:
    *v6 = *(_QWORD *)v8;
    return result;
  }
  if (a4 == 2)
  {
    v11 = *(a2 - 1);
    v12 = **a3;
    v13 = 0xAAAAAAAAAAAAAAABLL * (((*a3)[1] - v12) >> 5);
    if (v13 > v11 && v13 > *a1)
    {
      v14 = *(_DWORD *)&v12[96 * v11 + 28];
      v15 = *(_DWORD *)&v12[96 * *a1 + 28];
      if (v14 >= v15)
        v11 = *a1;
      *a5 = v11;
      v6 = a5 + 1;
      if (v14 >= v15)
        v8 = (char *)(a2 - 1);
      goto LABEL_10;
    }
  }
  else
  {
    if ((uint64_t)a4 > 8)
    {
      v27 = a4 >> 1;
      v28 = a4 >> 1;
      v5 = (char *)&a1[v28];
      std::__stable_sort<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(a1, &a1[v28], a3, a4 >> 1, a5, a4 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(&v8[v28 * 8], a2, a3, a4 - v27, &v6[v28], a4 - v27);
      v30 = *a3;
      v31 = (char *)v6;
      v12 = v8;
      v32 = (unint64_t *)&v8[v28 * 8];
      while (v32 != a2)
      {
        v33 = v32;
        v11 = *v32;
        v34 = *v30;
        v35 = 0xAAAAAAAAAAAAAAABLL * ((v30[1] - *v30) >> 5);
        if (v35 <= v11)
          goto LABEL_53;
        v36 = *(_QWORD *)v12;
        if (v35 <= *(_QWORD *)v12)
          goto LABEL_53;
        v37 = *(_DWORD *)&v34[96 * v11 + 28];
        v38 = *(_DWORD *)&v34[96 * v36 + 28];
        if (v37 < v38)
          v36 = v11;
        v32 = &v33[v37 < v38];
        v12 += 8 * (v37 >= v38);
        *v6++ = v36;
        v31 += 8;
        if (v12 == v5)
        {
          if (v32 != a2)
          {
            v39 = -8;
            if (v37 >= v38)
              v39 = 0;
            v40 = (char *)a2 - (char *)v33 + v39 - 8;
            if (v40 < 0x68)
              goto LABEL_59;
            if ((unint64_t)(v31 - (char *)&v33[v37 < v38]) < 0x20)
              goto LABEL_59;
            v41 = 0;
            v42 = (v40 >> 3) + 1;
            v43 = v37 < v38;
            v44 = v42 & 0x3FFFFFFFFFFFFFFCLL;
            v45 = &v6[v44];
            v32 = (unint64_t *)((char *)v32 + v44 * 8);
            v46 = &v33[v43];
            v47 = v42 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v48 = &v6[v41];
              result = *(__n128 *)&v46[v41];
              v49 = *(_OWORD *)&v46[v41 + 2];
              *(__n128 *)v48 = result;
              *((_OWORD *)v48 + 1) = v49;
              v41 += 4;
              v47 -= 4;
            }
            while (v47);
            v6 = v45;
            if (v42 != (v42 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_59:
              do
              {
                v50 = *v32++;
                *v6++ = v50;
              }
              while (v32 != a2);
            }
          }
          return result;
        }
      }
      if (v12 == v5)
        return result;
      v11 = &v8[8 * v27] - v12 - 8;
      if (v11 < 0x38 || (unint64_t)(v31 - v12) < 0x20)
      {
        v51 = v6;
        v52 = v12;
        goto LABEL_51;
      }
      goto LABEL_54;
    }
    if (a1 == a2)
      return result;
    v16 = *a3;
    v17 = a1 + 1;
    *a5 = *a1;
    if (a1 + 1 == a2)
      return result;
    v11 = 0;
    v12 = *v16;
    v18 = 0xAAAAAAAAAAAAAAABLL * ((v16[1] - *v16) >> 5);
    v19 = a5;
    while (1)
    {
      v20 = *v17;
      if (v18 <= *v17)
        break;
      v21 = v19 + 1;
      v22 = *v19;
      if (v18 <= *v19)
        break;
      if (*(_DWORD *)&v12[96 * v20 + 28] >= *(_DWORD *)&v12[96 * v22 + 28])
      {
        *v21 = v20;
        ++v17;
        v11 += 8;
        ++v19;
        if (v17 == a2)
          return result;
      }
      else
      {
        v19[1] = v22;
        v23 = a5;
        if (v19 != a5)
        {
          v24 = v11;
          while (v18 > *v17)
          {
            v25 = *(unint64_t *)((char *)a5 + v24 - 8);
            if (v18 <= v25)
              break;
            if (*(_DWORD *)&v12[96 * *v17 + 28] >= *(_DWORD *)&v12[96 * v25 + 28])
            {
              v23 = (unint64_t *)((char *)a5 + v24);
              goto LABEL_28;
            }
            *(unint64_t *)((char *)a5 + v24) = v25;
            v24 -= 8;
            if (!v24)
            {
              v23 = a5;
              goto LABEL_28;
            }
          }
          break;
        }
LABEL_28:
        v26 = *v17++;
        *v23 = v26;
        v11 += 8;
        v19 = v21;
        if (v17 == a2)
          return result;
      }
    }
  }
LABEL_53:
  __break(1u);
LABEL_54:
  v54 = 0;
  v55 = (v11 >> 3) + 1;
  v56 = v55 & 0x3FFFFFFFFFFFFFFCLL;
  v51 = &v6[v56];
  v52 = &v12[v56 * 8];
  v57 = v55 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v58 = &v6[v54];
    result = *(__n128 *)&v12[v54 * 8];
    v59 = *(_OWORD *)&v12[v54 * 8 + 16];
    *(__n128 *)v58 = result;
    *((_OWORD *)v58 + 1) = v59;
    v54 += 4;
    v57 -= 4;
  }
  while (v57);
  if (v55 != (v55 & 0x3FFFFFFFFFFFFFFCLL))
  {
    do
    {
LABEL_51:
      v53 = *(_QWORD *)v52;
      v52 += 8;
      *v51++ = v53;
    }
    while (v52 != v5);
  }
  return result;
}

unint64_t *std::__inplace_merge<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(unint64_t *result, unint64_t *a2, unint64_t *a3, uint64_t **a4, uint64_t a5, uint64_t a6, unint64_t *a7, uint64_t a8)
{
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t *v33;
  int v34;
  char *v35;
  uint64_t v36;
  unint64_t *v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t *v47;
  int v48;
  unint64_t *v49;
  unint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  uint64_t v64;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t *v68;
  unint64_t *v69;
  uint64_t **v70;
  unint64_t *v71;
  uint64_t v72;
  int64_t v73;
  unint64_t v74;
  char *v75;
  unint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  __int128 *v79;
  _OWORD *v80;
  uint64_t v81;
  __int128 v82;
  unint64_t v83;
  unint64_t *v84;
  unint64_t *v85;
  uint64_t v86;
  uint64_t v87;
  __int128 *v88;
  _OWORD *v89;
  uint64_t v90;
  __int128 v91;
  unint64_t v92;
  uint64_t *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  int v97;
  int v98;
  char v99;
  _BOOL4 v100;
  unsigned int v101;
  uint64_t v102;
  unint64_t *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t *v109;
  char *v110;
  unint64_t *v111;
  unint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  __int128 v117;
  unint64_t *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  unint64_t *v125;
  unint64_t *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t **v129;
  uint64_t **v130;

  if (!a6)
    return result;
  v10 = result;
  while (2)
  {
    if (a5 <= a8 || a6 <= a8)
    {
      if (a5 <= a6)
      {
        if (v10 != a2)
        {
          v83 = (char *)a2 - (char *)v10 - 8;
          v84 = a7;
          v85 = v10;
          if (v83 < 0x18)
            goto LABEL_127;
          v84 = a7;
          v85 = v10;
          if ((unint64_t)((char *)a7 - (char *)v10) < 0x20)
            goto LABEL_127;
          v86 = (v83 >> 3) + 1;
          v87 = v86 & 0x3FFFFFFFFFFFFFFCLL;
          v84 = &a7[v87];
          v85 = &v10[v87];
          v88 = (__int128 *)(v10 + 2);
          v89 = a7 + 2;
          v90 = v86 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v91 = *v88;
            *(v89 - 1) = *(v88 - 1);
            *v89 = v91;
            v88 += 2;
            v89 += 2;
            v90 -= 4;
          }
          while (v90);
          if (v86 != (v86 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_127:
            do
            {
              v92 = *v85++;
              *v84++ = v92;
            }
            while (v85 != a2);
          }
          if (v84 != a7)
          {
            v93 = *a4;
            while (a2 != a3)
            {
              v94 = *a2;
              v95 = *v93;
              v96 = 0xAAAAAAAAAAAAAAABLL * ((v93[1] - *v93) >> 5);
              if (v96 <= *a2 || v96 <= *a7)
                goto LABEL_124;
              v97 = *(_DWORD *)(v95 + 96 * v94 + 28);
              v98 = *(_DWORD *)(v95 + 96 * *a7 + 28);
              v99 = v97 < v98;
              v100 = v97 >= v98;
              if (v99)
                v101 = 1;
              else
                v101 = 0;
              if (!v99)
                v94 = *a7;
              a2 += v101;
              a7 += v100;
              *v10++ = v94;
              if (a7 == v84)
                return result;
            }
            return (unint64_t *)memmove(v10, a7, (char *)v84 - (char *)a7);
          }
        }
        return result;
      }
      v73 = (char *)a3 - (char *)a2;
      if (a3 == a2)
        return result;
      v74 = v73 - 8;
      if ((unint64_t)(v73 - 8) < 0x18)
      {
        v75 = (char *)a7;
        v76 = a2;
      }
      else
      {
        v75 = (char *)a7;
        v76 = a2;
        if ((unint64_t)((char *)a7 - (char *)a2) >= 0x20)
        {
          v77 = (v74 >> 3) + 1;
          v78 = v77 & 0x3FFFFFFFFFFFFFFCLL;
          v75 = (char *)&a7[v78];
          v76 = &a2[v78];
          v79 = (__int128 *)(a2 + 2);
          v80 = a7 + 2;
          v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v82 = *v79;
            *(v80 - 1) = *(v79 - 1);
            *v80 = v82;
            v79 += 2;
            v80 += 2;
            v81 -= 4;
          }
          while (v81);
          if (v77 == (v77 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_104:
            if (v75 == (char *)a7)
              return result;
            v103 = a3;
            while (a2 != v10)
            {
              v104 = *((_QWORD *)v75 - 1);
              v105 = **a4;
              v106 = 0xAAAAAAAAAAAAAAABLL * (((*a4)[1] - v105) >> 5);
              if (v106 <= v104)
                goto LABEL_124;
              v107 = *(a2 - 1);
              if (v106 <= v107)
                goto LABEL_124;
              if (*(_DWORD *)(v105 + 96 * v104 + 28) >= *(_DWORD *)(v105 + 96 * v107 + 28))
                v75 -= 8;
              else
                v104 = *--a2;
              *--a3 = v104;
              --v103;
              if (v75 == (char *)a7)
                return result;
            }
            v108 = v75 - (char *)a7 - 8;
            if (v108 >= 0x58 && (unint64_t)(v75 - (char *)v103) >= 0x20)
            {
              v113 = 0;
              v114 = (v108 >> 3) + 1;
              v115 = 8 * (v114 & 0x3FFFFFFFFFFFFFFCLL);
              v109 = &a3[v115 / 0xFFFFFFFFFFFFFFF8];
              v110 = &v75[-v115];
              v116 = v114 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v117 = *(_OWORD *)&v75[v113 * 8 - 16];
                v118 = &a3[v113];
                *((_OWORD *)v118 - 2) = *(_OWORD *)&v75[v113 * 8 - 32];
                *((_OWORD *)v118 - 1) = v117;
                v113 -= 4;
                v116 -= 4;
              }
              while (v116);
              if (v114 == (v114 & 0x3FFFFFFFFFFFFFFCLL))
                return result;
            }
            else
            {
              v109 = a3;
              v110 = v75;
            }
            v111 = v109 - 1;
            do
            {
              v112 = *((_QWORD *)v110 - 1);
              v110 -= 8;
              *v111-- = v112;
            }
            while (v110 != (char *)a7);
            return result;
          }
        }
      }
      do
      {
        v102 = *v76++;
        *(_QWORD *)v75 = v102;
        v75 += 8;
      }
      while (v76 != a3);
      goto LABEL_104;
    }
    if (a5)
    {
      v11 = *a2;
      v12 = **a4;
      v13 = 0xAAAAAAAAAAAAAAABLL * (((*a4)[1] - v12) >> 5);
      if (v13 > *a2)
      {
        v14 = 0;
        v15 = -a5;
        while (1)
        {
          v16 = v10[v14 / 8];
          if (v13 <= v16)
            goto LABEL_124;
          if (*(_DWORD *)(v12 + 96 * v11 + 28) < *(_DWORD *)(v12 + 96 * v16 + 28))
            break;
          v14 += 8;
          if (__CFADD__(v15++, 1))
            return result;
        }
        v18 = &v10[v14 / 8];
        if (-v15 >= a6)
        {
          if (v15 == -1)
          {
            v10[v14 / 8] = v11;
            *a2 = v16;
            return result;
          }
          if (v15 <= 0)
            v44 = -v15;
          else
            v44 = 1 - v15;
          v36 = v44 >> 1;
          v22 = (char *)&v10[(v44 >> 1) + v14 / 8];
          v21 = a2;
          if (a2 != a3)
          {
            v45 = a3 - a2;
            if (v13 > *(_QWORD *)v22)
            {
              v21 = a2;
              while (1)
              {
                v46 = v45 >> 1;
                v47 = &v21[v45 >> 1];
                if (v13 <= *v47)
                  break;
                v48 = *(_DWORD *)(v12 + 96 * *v47 + 28);
                v49 = v47 + 1;
                v45 += ~v46;
                if (v48 < *(_DWORD *)(v12 + 96 * *(_QWORD *)v22 + 28))
                  v21 = v49;
                else
                  v45 = v46;
                if (!v45)
                  goto LABEL_52;
              }
            }
            goto LABEL_124;
          }
LABEL_52:
          v20 = v21 - a2;
          if (v22 != (char *)a2)
            goto LABEL_32;
        }
        else
        {
          if (a6 >= 0)
            v19 = a6;
          else
            v19 = a6 + 1;
          v20 = v19 >> 1;
          v21 = &a2[v19 >> 1];
          v22 = (char *)&v10[v14 / 8];
          v23 = (char *)a2 - (char *)v10 - v14;
          if ((char *)a2 - (char *)v10 != v14)
          {
            if (v13 <= *v21)
              goto LABEL_124;
            v24 = v23 >> 3;
            v25 = (unint64_t)(v23 >> 3) >> 1;
            v26 = &v10[v25];
            v27 = v26[v14 / 8];
            if (v13 <= v27)
              goto LABEL_124;
            v28 = *(_DWORD *)(v12 + 96 * *v21 + 28);
            v29 = *(_DWORD *)(v12 + 96 * v27 + 28);
            v30 = (uint64_t)&v26[v14 / 8 + 1];
            v31 = v24 + ~v25;
            if (v28 >= v29)
              v22 = (char *)v30;
            else
              v22 = (char *)&v10[v14 / 8];
            if (v28 >= v29)
              v25 = v31;
            while (v25)
            {
              v32 = v25 >> 1;
              v33 = (unint64_t *)&v22[8 * (v25 >> 1)];
              if (v13 <= *v33)
                goto LABEL_124;
              v34 = *(_DWORD *)(v12 + 96 * *v33 + 28);
              v35 = (char *)(v33 + 1);
              v25 += ~v32;
              if (v28 < v34)
                v25 = v32;
              else
                v22 = v35;
            }
          }
          v36 = (uint64_t)(v22 - (char *)v10 - v14) >> 3;
          if (v22 != (char *)a2)
          {
LABEL_32:
            v37 = (unint64_t *)v22;
            v38 = (char *)v21 - (char *)a2;
            if (v21 != a2)
            {
              v39 = (unint64_t *)(v22 + 8);
              if (v22 + 8 == (char *)a2)
              {
                v119 = *(_QWORD *)v22;
                v121 = v36;
                v125 = a7;
                v127 = a6;
                v50 = a3;
                v129 = a4;
                v51 = a8;
                v123 = v20;
                memmove(v22, a2, (char *)v21 - (char *)a2);
                v18 = &v10[v14 / 8];
                a6 = v127;
                a4 = v129;
                a8 = v51;
                v36 = v121;
                v20 = v123;
                a3 = v50;
                a7 = v125;
                v37 = (unint64_t *)&v22[v38];
                *(_QWORD *)&v22[v38] = v119;
              }
              else
              {
                v40 = a2 + 1;
                if (a2 + 1 == v21)
                {
                  v52 = *(v21 - 1);
                  v37 = (unint64_t *)(v22 + 8);
                  if (v21 - 1 != (unint64_t *)v22)
                  {
                    v126 = a7;
                    v128 = a6;
                    v53 = a3;
                    v130 = a4;
                    v122 = v36;
                    v124 = v20;
                    v54 = a8;
                    v120 = *(v21 - 1);
                    memmove(v22 + 8, v22, (char *)(v21 - 1) - v22);
                    v20 = v124;
                    a7 = v126;
                    v18 = &v10[v14 / 8];
                    a6 = v128;
                    a4 = v130;
                    a8 = v54;
                    v52 = v120;
                    v36 = v122;
                    a3 = v53;
                  }
                  *(_QWORD *)v22 = v52;
                }
                else
                {
                  v41 = ((char *)a2 - v22) >> 3;
                  if (v41 == v38 >> 3)
                  {
                    do
                    {
                      v42 = *(v39 - 1);
                      *(v39 - 1) = *(v40 - 1);
                      *(v40 - 1) = v42;
                      if (v39 == a2)
                        break;
                      ++v39;
                    }
                    while (v40++ != v21);
                    v37 = a2;
                  }
                  else
                  {
                    v55 = v38 >> 3;
                    v56 = ((char *)a2 - v22) >> 3;
                    do
                    {
                      v57 = v56;
                      v56 = v55;
                      v55 = v57 % v55;
                    }
                    while (v55);
                    if (v56)
                    {
                      v58 = &v22[8 * v56];
                      do
                      {
                        v60 = *((_QWORD *)v58 - 1);
                        v58 -= 8;
                        v59 = v60;
                        v61 = &v58[8 * v41];
                        v62 = v58;
                        do
                        {
                          v63 = v61;
                          *(_QWORD *)v62 = *(_QWORD *)v61;
                          v64 = ((char *)v21 - v61) >> 3;
                          v65 = __OFSUB__(v41, v64);
                          v66 = v41 - v64;
                          v99 = (v66 < 0) ^ v65;
                          v61 = &v22[8 * v66];
                          if (v99)
                            v61 = &v63[8 * v41];
                          v62 = v63;
                        }
                        while (v61 != v58);
                        *(_QWORD *)v63 = v59;
                      }
                      while (v58 != v22);
                    }
                    v37 = (unint64_t *)&v22[8 * (v38 >> 3)];
                  }
                }
              }
            }
LABEL_68:
            a5 = -v36 - v15;
            v67 = a6 - v20;
            if (v36 + v20 >= a6 - (v36 + v20) - v15)
            {
              v70 = a4;
              v71 = a7;
              a5 = v36;
              v72 = a8;
              v10 = v18;
              v67 = v20;
              result = (unint64_t *)std::__inplace_merge<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(v37, v21, a3);
              a3 = v37;
            }
            else
            {
              v68 = &v10[v14 / 8];
              v69 = a3;
              v70 = a4;
              v71 = a7;
              v72 = a8;
              result = (unint64_t *)std::__inplace_merge<std::_ClassicAlgPolicy,cricket::EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(webrtc::FieldTrialsView const&,int,int,webrtc::VideoEncoderConfig const&,std::optional<webrtc::DataRate> const&)::$_1 &,std::__wrap_iter<unsigned long *>>(v68, v22, v37);
              a3 = v69;
              v10 = v37;
              v22 = (char *)v21;
            }
            a6 = v67;
            a2 = (unint64_t *)v22;
            a7 = v71;
            a4 = v70;
            a8 = v72;
            if (v67)
              continue;
            return result;
          }
        }
        v37 = v21;
        goto LABEL_68;
      }
LABEL_124:
      __break(1u);
    }
    return result;
  }
}

__n128 webrtc::EnvironmentFactory::CreateWithDefaults@<Q0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  _OWORD *v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned __int8 v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  unsigned int v16;
  _QWORD *v17;
  unsigned int *v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  __n128 result;
  _QWORD *v23;

  if (a1[1])
  {
    if (a1[2])
      goto LABEL_10;
  }
  else
  {
    v4 = (_OWORD *)operator new();
    *v4 = 0u;
    v4[1] = 0u;
    *(_QWORD *)v4 = &unk_24C0B3F60;
    a1[1] = (uint64_t)v4;
    v5 = operator new();
    *(_DWORD *)(v5 + 8) = 0;
    v6 = (unsigned int *)(v5 + 8);
    v7 = *a1;
    *(_QWORD *)v5 = &off_24C0B3D10;
    *(_QWORD *)(v5 + 16) = v7;
    *(_QWORD *)(v5 + 24) = v4;
    do
      v8 = __ldxr(v6);
    while (__stxr(v8 + 1, v6));
    *a1 = v5;
    if (a1[2])
      goto LABEL_10;
  }
  {
    v23 = (_QWORD *)operator new();
    *v23 = &unk_24C0B13E8;
    webrtc::Clock::GetRealTimeClock(void)::clock = (uint64_t)v23;
  }
  if (webrtc::Clock::GetRealTimeClock(void)::clock)
    a1[2] = webrtc::Clock::GetRealTimeClock(void)::clock;
LABEL_10:
  if (a1[3])
  {
    v10 = a1[4];
    if (v10)
    {
LABEL_12:
      v11 = *a1;
      goto LABEL_19;
    }
  }
  else
  {
    v12 = (_QWORD *)operator new();
    *v12 = &off_24C0C2148;
    a1[3] = (uint64_t)v12;
    v13 = operator new();
    *(_DWORD *)(v13 + 8) = 0;
    v14 = (unsigned int *)(v13 + 8);
    v15 = *a1;
    *(_QWORD *)v13 = &off_24C0B3D30;
    *(_QWORD *)(v13 + 16) = v15;
    *(_QWORD *)(v13 + 24) = v12;
    do
      v16 = __ldxr(v14);
    while (__stxr(v16 + 1, v14));
    *a1 = v13;
    v10 = a1[4];
    if (v10)
      goto LABEL_12;
  }
  v17 = (_QWORD *)operator new();
  *v17 = &unk_24C0BBE70;
  a1[4] = (uint64_t)v17;
  v11 = operator new();
  *(_DWORD *)(v11 + 8) = 0;
  v18 = (unsigned int *)(v11 + 8);
  v19 = *a1;
  *(_QWORD *)v11 = &off_24C0B3D50;
  *(_QWORD *)(v11 + 16) = v19;
  *(_QWORD *)(v11 + 24) = v17;
  do
    v20 = __ldxr(v18);
  while (__stxr(v20 + 1, v18));
  v10 = a1[4];
LABEL_19:
  *a1 = 0;
  v21 = a1[3];
  *(_QWORD *)a2 = v11;
  result = *(__n128 *)(a1 + 1);
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v21;
  *(_QWORD *)(a2 + 32) = v10;
  return result;
}

uint64_t webrtc::EnvironmentFactory::Create@<X0>(webrtc::EnvironmentFactory *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  __int128 v5;
  __n128 v6;
  uint64_t result;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;

  v2 = *(_QWORD *)this;
  v11 = v2;
  if (v2)
  {
    v3 = (unsigned int *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = *(_OWORD *)((char *)this + 24);
  v12 = *(_OWORD *)((char *)this + 8);
  v13 = v5;
  v6 = webrtc::EnvironmentFactory::CreateWithDefaults(&v11, a2);
  result = v11;
  if (v11)
  {
    v8 = (unsigned int *)(v11 + 8);
    do
    {
      v9 = __ldaxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
      return (*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)result + 8))(result, v6);
  }
  return result;
}

_QWORD *webrtc::`anonymous namespace'::Store<webrtc::FieldTrialsView const>(std::unique_ptr<webrtc::FieldTrialsView const>,webrtc::scoped_refptr<rtc::RefCountedBase const> &)::StorageNode::~StorageNode(_QWORD *a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  *a1 = &off_24C0B3D10;
  v2 = a1[3];
  a1[3] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (unsigned int *)a1[2];
  if (v3)
  {
    v4 = v3 + 2;
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
  }
  return a1;
}

void webrtc::`anonymous namespace'::Store<webrtc::FieldTrialsView const>(std::unique_ptr<webrtc::FieldTrialsView const>,webrtc::scoped_refptr<rtc::RefCountedBase const> &)::StorageNode::~StorageNode(_QWORD *a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  *a1 = &off_24C0B3D10;
  v2 = a1[3];
  a1[3] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (unsigned int *)a1[2];
  if (v3)
  {
    v4 = v3 + 2;
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
  }
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *webrtc::`anonymous namespace'::Store<webrtc::TaskQueueFactory>(std::unique_ptr<webrtc::TaskQueueFactory>,webrtc::scoped_refptr<rtc::RefCountedBase const> &)::StorageNode::~StorageNode(_QWORD *a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  *a1 = &off_24C0B3D30;
  v2 = a1[3];
  a1[3] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (unsigned int *)a1[2];
  if (v3)
  {
    v4 = v3 + 2;
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
  }
  return a1;
}

void webrtc::`anonymous namespace'::Store<webrtc::TaskQueueFactory>(std::unique_ptr<webrtc::TaskQueueFactory>,webrtc::scoped_refptr<rtc::RefCountedBase const> &)::StorageNode::~StorageNode(_QWORD *a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  *a1 = &off_24C0B3D30;
  v2 = a1[3];
  a1[3] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (unsigned int *)a1[2];
  if (v3)
  {
    v4 = v3 + 2;
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
  }
  JUMPOUT(0x20BD0ADECLL);
}

_QWORD *webrtc::`anonymous namespace'::Store<webrtc::RtcEventLog>(std::unique_ptr<webrtc::RtcEventLog>,webrtc::scoped_refptr<rtc::RefCountedBase const> &)::StorageNode::~StorageNode(_QWORD *a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  *a1 = &off_24C0B3D50;
  v2 = a1[3];
  a1[3] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (unsigned int *)a1[2];
  if (v3)
  {
    v4 = v3 + 2;
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
  }
  return a1;
}

void webrtc::`anonymous namespace'::Store<webrtc::RtcEventLog>(std::unique_ptr<webrtc::RtcEventLog>,webrtc::scoped_refptr<rtc::RefCountedBase const> &)::StorageNode::~StorageNode(_QWORD *a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  *a1 = &off_24C0B3D50;
  v2 = a1[3];
  a1[3] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (unsigned int *)a1[2];
  if (v3)
  {
    v4 = v3 + 2;
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
  }
  JUMPOUT(0x20BD0ADECLL);
}

float std::array<float,65ul>::fill[abi:sn180100](_DWORD *a1, _DWORD *a2)
{
  float result;

  *a1 = *a2;
  a1[1] = *a2;
  a1[2] = *a2;
  a1[3] = *a2;
  a1[4] = *a2;
  a1[5] = *a2;
  a1[6] = *a2;
  a1[7] = *a2;
  a1[8] = *a2;
  a1[9] = *a2;
  a1[10] = *a2;
  a1[11] = *a2;
  a1[12] = *a2;
  a1[13] = *a2;
  a1[14] = *a2;
  a1[15] = *a2;
  a1[16] = *a2;
  a1[17] = *a2;
  a1[18] = *a2;
  a1[19] = *a2;
  a1[20] = *a2;
  a1[21] = *a2;
  a1[22] = *a2;
  a1[23] = *a2;
  a1[24] = *a2;
  a1[25] = *a2;
  a1[26] = *a2;
  a1[27] = *a2;
  a1[28] = *a2;
  a1[29] = *a2;
  a1[30] = *a2;
  a1[31] = *a2;
  a1[32] = *a2;
  a1[33] = *a2;
  a1[34] = *a2;
  a1[35] = *a2;
  a1[36] = *a2;
  a1[37] = *a2;
  a1[38] = *a2;
  a1[39] = *a2;
  a1[40] = *a2;
  a1[41] = *a2;
  a1[42] = *a2;
  a1[43] = *a2;
  a1[44] = *a2;
  a1[45] = *a2;
  a1[46] = *a2;
  a1[47] = *a2;
  a1[48] = *a2;
  a1[49] = *a2;
  a1[50] = *a2;
  a1[51] = *a2;
  a1[52] = *a2;
  a1[53] = *a2;
  a1[54] = *a2;
  a1[55] = *a2;
  a1[56] = *a2;
  a1[57] = *a2;
  a1[58] = *a2;
  a1[59] = *a2;
  a1[60] = *a2;
  a1[61] = *a2;
  a1[62] = *a2;
  a1[63] = *a2;
  result = *(float *)a2;
  a1[64] = *a2;
  return result;
}

float webrtc::ErlEstimator::Update(uint64_t a1, unint64_t **a2, float *a3, unint64_t a4, char *__src, float result)
{
  unint64_t v10;
  char *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t v36;
  float v37;
  unint64_t v38;
  float32x4_t *v39;
  float *v40;
  uint64_t v41;
  uint64_t v42;
  float *v43;
  float *v44;
  float *v45;
  float32x4_t *v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;
  int8x16_t v53;
  int8x16_t v54;
  int8x16_t v55;
  uint64_t v56;
  uint64_t v57;
  __int32 v58;
  uint64_t v59;
  int32x4_t *v60;
  float v61;
  float v62;
  uint64_t v63;
  float v64;
  float v65;
  float *v66;
  int32x4_t v67;
  int32x4_t v68;
  int32x4_t v69;
  int32x4_t v70;
  int32x4_t v71;
  int32x4_t v72;
  int32x4_t v73;
  int32x4_t v74;
  float32x4_t v75;
  int8x16_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t v81;
  int8x16_t v82;
  int8x16_t v83;
  int8x16_t v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  int v104;
  float *v105;
  BOOL v106;
  float v107;
  int8x16_t v108;
  float32x4_t v109;
  int8x16_t v110;
  float32x4_t v111;
  int8x16_t v112;
  float32x4_t v113;
  int8x16_t v114;
  float32x4_t v115;
  int8x16_t v116;
  float32x4_t v117;
  int8x16_t v118;
  float32x4_t v119;
  int8x16_t v120;
  float32x4_t v121;
  int8x16_t v122;
  float32x4_t v123;
  int v124;
  _OWORD __dst[17];

  v11 = (char *)*a2;
  v10 = (unint64_t)a2[1];
  v12 = *a2;
  v13 = v10;
  if (v10 < 0x40)
  {
LABEL_5:
    if (v13)
    {
      v14 = __clz(__rbit64(*v12 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v13)));
      if ((*v12 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v13)) != 0)
        v15 = v14;
      else
        v15 = v13;
    }
    else
    {
      v15 = 0;
    }
  }
  else
  {
    v13 = (unint64_t)a2[1];
    v12 = *a2;
    while (!*v12)
    {
      ++v12;
      v13 -= 64;
      if (v13 <= 0x3F)
        goto LABEL_5;
    }
    v15 = __clz(__rbit64(*v12));
  }
  v17 = &(*a2)[v10 >> 6] == v12 && (v10 & 0x3F) == (_DWORD)v15;
  v18 = *(_QWORD *)(a1 + 528) + 1;
  *(_QWORD *)(a1 + 528) = v18;
  if (v18 >= *(_QWORD *)a1 && !v17)
  {
    memcpy(__dst, __src, 0x104uLL);
    if (v10 >= 2)
    {
      v19 = v15 + 8 * ((char *)v12 - v11);
      v20 = &__src[260 * v19];
      v22 = *(int8x16_t *)v20;
      v21 = *((int8x16_t *)v20 + 1);
      v24 = *((int8x16_t *)v20 + 2);
      v23 = *((int8x16_t *)v20 + 3);
      v26 = *((int8x16_t *)v20 + 4);
      v25 = *((int8x16_t *)v20 + 5);
      v28 = *((int8x16_t *)v20 + 6);
      v27 = *((int8x16_t *)v20 + 7);
      v30 = *((int8x16_t *)v20 + 8);
      v29 = *((int8x16_t *)v20 + 9);
      v32 = *((int8x16_t *)v20 + 10);
      v31 = *((int8x16_t *)v20 + 11);
      v34 = *((int8x16_t *)v20 + 12);
      v33 = *((int8x16_t *)v20 + 13);
      v36 = *((int8x16_t *)v20 + 14);
      v35 = *((int8x16_t *)v20 + 15);
      v37 = *((float *)v20 + 64);
      v38 = v19 + 1;
      if (v38 < v10)
      {
        v39 = (float32x4_t *)&__src[260 * v15 + 2080 * (_QWORD)v12 - 2080 * (_QWORD)v11 + 260];
        do
        {
          if (((*(_QWORD *)&v11[(v38 >> 3) & 0x1FFFFFFFFFFFFFF8] >> v38) & 1) != 0)
          {
            v35 = vbslq_s8((int8x16_t)vcgtq_f32(v39[15], (float32x4_t)v35), (int8x16_t)v39[15], v35);
            v36 = vbslq_s8((int8x16_t)vcgtq_f32(v39[14], (float32x4_t)v36), (int8x16_t)v39[14], v36);
            v33 = vbslq_s8((int8x16_t)vcgtq_f32(v39[13], (float32x4_t)v33), (int8x16_t)v39[13], v33);
            v34 = vbslq_s8((int8x16_t)vcgtq_f32(v39[12], (float32x4_t)v34), (int8x16_t)v39[12], v34);
            v31 = vbslq_s8((int8x16_t)vcgtq_f32(v39[11], (float32x4_t)v31), (int8x16_t)v39[11], v31);
            v32 = vbslq_s8((int8x16_t)vcgtq_f32(v39[10], (float32x4_t)v32), (int8x16_t)v39[10], v32);
            v29 = vbslq_s8((int8x16_t)vcgtq_f32(v39[9], (float32x4_t)v29), (int8x16_t)v39[9], v29);
            v30 = vbslq_s8((int8x16_t)vcgtq_f32(v39[8], (float32x4_t)v30), (int8x16_t)v39[8], v30);
            v27 = vbslq_s8((int8x16_t)vcgtq_f32(v39[7], (float32x4_t)v27), (int8x16_t)v39[7], v27);
            v28 = vbslq_s8((int8x16_t)vcgtq_f32(v39[6], (float32x4_t)v28), (int8x16_t)v39[6], v28);
            v25 = vbslq_s8((int8x16_t)vcgtq_f32(v39[5], (float32x4_t)v25), (int8x16_t)v39[5], v25);
            v26 = vbslq_s8((int8x16_t)vcgtq_f32(v39[4], (float32x4_t)v26), (int8x16_t)v39[4], v26);
            v23 = vbslq_s8((int8x16_t)vcgtq_f32(v39[3], (float32x4_t)v23), (int8x16_t)v39[3], v23);
            v24 = vbslq_s8((int8x16_t)vcgtq_f32(v39[2], (float32x4_t)v24), (int8x16_t)v39[2], v24);
            v21 = vbslq_s8((int8x16_t)vcgtq_f32(v39[1], (float32x4_t)v21), (int8x16_t)v39[1], v21);
            v22 = vbslq_s8((int8x16_t)vcgtq_f32(*v39, (float32x4_t)v22), *(int8x16_t *)v39, v22);
            if (v37 < v39[16].f32[0])
              v37 = v39[16].f32[0];
          }
          ++v38;
          v39 = (float32x4_t *)((char *)v39 + 260);
        }
        while (v38 < v10);
      }
      __dst[0] = v22;
      __dst[1] = v21;
      __dst[2] = v24;
      __dst[3] = v23;
      __dst[4] = v26;
      __dst[5] = v25;
      __dst[6] = v28;
      __dst[7] = v27;
      __dst[8] = v30;
      __dst[9] = v29;
      __dst[10] = v32;
      __dst[11] = v31;
      __dst[12] = v34;
      __dst[13] = v33;
      __dst[14] = v36;
      __dst[15] = v35;
      *(float *)&__dst[16] = v37;
    }
    if (a4 >= 2)
    {
      v40 = a3 + 65;
      memmove(&v108, a3, 0x104uLL);
      v41 = 0;
      v42 = 1;
      do
      {
        v43 = &a3[65 * v41];
        v44 = v43 + 130;
        v45 = v43 + 65;
        if (&v108 >= (int8x16_t *)v44 || v45 >= (float *)&v124)
        {
          v47 = (float32x4_t *)&a3[65 * v42];
          v48 = vbslq_s8((int8x16_t)vcgtq_f32(v47[1], v109), (int8x16_t)v47[1], (int8x16_t)v109);
          v108 = vbslq_s8((int8x16_t)vcgtq_f32(*v47, (float32x4_t)v108), *(int8x16_t *)v47, v108);
          v109 = (float32x4_t)v48;
          v49 = vbslq_s8((int8x16_t)vcgtq_f32(v47[3], v111), (int8x16_t)v47[3], (int8x16_t)v111);
          v110 = vbslq_s8((int8x16_t)vcgtq_f32(v47[2], (float32x4_t)v110), (int8x16_t)v47[2], v110);
          v111 = (float32x4_t)v49;
          v50 = vbslq_s8((int8x16_t)vcgtq_f32(v47[5], v113), (int8x16_t)v47[5], (int8x16_t)v113);
          v112 = vbslq_s8((int8x16_t)vcgtq_f32(v47[4], (float32x4_t)v112), (int8x16_t)v47[4], v112);
          v113 = (float32x4_t)v50;
          v51 = vbslq_s8((int8x16_t)vcgtq_f32(v47[7], v115), (int8x16_t)v47[7], (int8x16_t)v115);
          v114 = vbslq_s8((int8x16_t)vcgtq_f32(v47[6], (float32x4_t)v114), (int8x16_t)v47[6], v114);
          v115 = (float32x4_t)v51;
          v52 = vbslq_s8((int8x16_t)vcgtq_f32(v47[9], v117), (int8x16_t)v47[9], (int8x16_t)v117);
          v116 = vbslq_s8((int8x16_t)vcgtq_f32(v47[8], (float32x4_t)v116), (int8x16_t)v47[8], v116);
          v117 = (float32x4_t)v52;
          v53 = vbslq_s8((int8x16_t)vcgtq_f32(v47[11], v119), (int8x16_t)v47[11], (int8x16_t)v119);
          v118 = vbslq_s8((int8x16_t)vcgtq_f32(v47[10], (float32x4_t)v118), (int8x16_t)v47[10], v118);
          v119 = (float32x4_t)v53;
          v54 = vbslq_s8((int8x16_t)vcgtq_f32(v47[13], v121), (int8x16_t)v47[13], (int8x16_t)v121);
          v120 = vbslq_s8((int8x16_t)vcgtq_f32(v47[12], (float32x4_t)v120), (int8x16_t)v47[12], v120);
          v121 = (float32x4_t)v54;
          v55 = vbslq_s8((int8x16_t)vcgtq_f32(v47[15], v123), (int8x16_t)v47[15], (int8x16_t)v123);
          v122 = vbslq_s8((int8x16_t)vcgtq_f32(v47[14], (float32x4_t)v122), (int8x16_t)v47[14], v122);
          v123 = (float32x4_t)v55;
          v56 = 64;
        }
        else
        {
          v56 = 0;
        }
        v57 = v56;
        do
        {
          v58 = v108.i32[v57];
          if (*(float *)&v58 < v40[v57])
            v58 = SLODWORD(v40[v57]);
          v108.i32[v57++] = v58;
        }
        while (v57 != 65);
        ++v42;
        ++v41;
        v40 += 65;
      }
      while (v42 != a4);
      a3 = (float *)&v108;
    }
    v59 = 0;
    v60 = (int32x4_t *)(a1 + 268);
    do
    {
      v61 = a3[v59 + 1];
      if (v61 > 44015000.0)
      {
        v62 = *(float *)((char *)__dst + v59 * 4 + 4) / v61;
        v63 = a1 + v59 * 4;
        v64 = *(float *)(a1 + v59 * 4 + 12);
        if (v62 < v64)
        {
          *(_DWORD *)(v63 + 268) = 1000;
          v65 = v64 + (float)((float)(v62 - v64) * 0.1);
          if (v65 < 0.01)
            v65 = 0.01;
          *(float *)(v63 + 12) = v65;
        }
      }
      ++v59;
    }
    while (v59 != 63);
    v66 = (float *)(a1 + 520);
    v67.i64[0] = -1;
    v67.i64[1] = -1;
    v68 = vaddq_s32(*(int32x4_t *)(a1 + 284), v67);
    *v60 = vaddq_s32(*v60, v67);
    *(int32x4_t *)(a1 + 284) = v68;
    v69 = vaddq_s32(*(int32x4_t *)(a1 + 316), v67);
    *(int32x4_t *)(a1 + 300) = vaddq_s32(*(int32x4_t *)(a1 + 300), v67);
    *(int32x4_t *)(a1 + 316) = v69;
    v70 = vaddq_s32(*(int32x4_t *)(a1 + 348), v67);
    *(int32x4_t *)(a1 + 332) = vaddq_s32(*(int32x4_t *)(a1 + 332), v67);
    *(int32x4_t *)(a1 + 348) = v70;
    v71 = vaddq_s32(*(int32x4_t *)(a1 + 380), v67);
    *(int32x4_t *)(a1 + 364) = vaddq_s32(*(int32x4_t *)(a1 + 364), v67);
    *(int32x4_t *)(a1 + 380) = v71;
    v72 = vaddq_s32(*(int32x4_t *)(a1 + 412), v67);
    *(int32x4_t *)(a1 + 396) = vaddq_s32(*(int32x4_t *)(a1 + 396), v67);
    *(int32x4_t *)(a1 + 412) = v72;
    v73 = vaddq_s32(*(int32x4_t *)(a1 + 444), v67);
    *(int32x4_t *)(a1 + 428) = vaddq_s32(*(int32x4_t *)(a1 + 428), v67);
    *(int32x4_t *)(a1 + 444) = v73;
    v74 = vaddq_s32(*(int32x4_t *)(a1 + 476), v67);
    *(int32x4_t *)(a1 + 460) = vaddq_s32(*(int32x4_t *)(a1 + 460), v67);
    *(int32x4_t *)(a1 + 476) = v74;
    *(int32x4_t *)(a1 + 492) = vaddq_s32(*(int32x4_t *)(a1 + 492), v67);
    *(int32x2_t *)(a1 + 508) = vadd_s32(*(int32x2_t *)(a1 + 508), (int32x2_t)-1);
    --*(_DWORD *)(a1 + 516);
    v75 = (float32x4_t)vdupq_n_s32(0x447A0000u);
    v76 = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 284)), *(int8x16_t *)(a1 + 28), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 28), *(float32x4_t *)(a1 + 28)), v75));
    *(int8x16_t *)(a1 + 12) = vbslq_s8((int8x16_t)vcgtzq_s32(*v60), *(int8x16_t *)(a1 + 12), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 12), *(float32x4_t *)(a1 + 12)), v75));
    *(int8x16_t *)(a1 + 28) = v76;
    v77 = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 316)), *(int8x16_t *)(a1 + 60), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 60), *(float32x4_t *)(a1 + 60)), v75));
    *(int8x16_t *)(a1 + 44) = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 300)), *(int8x16_t *)(a1 + 44), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 44), *(float32x4_t *)(a1 + 44)), v75));
    *(int8x16_t *)(a1 + 60) = v77;
    v78 = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 348)), *(int8x16_t *)(a1 + 92), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 92), *(float32x4_t *)(a1 + 92)), v75));
    *(int8x16_t *)(a1 + 76) = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 332)), *(int8x16_t *)(a1 + 76), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 76), *(float32x4_t *)(a1 + 76)), v75));
    *(int8x16_t *)(a1 + 92) = v78;
    v79 = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 380)), *(int8x16_t *)(a1 + 124), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 124), *(float32x4_t *)(a1 + 124)), v75));
    *(int8x16_t *)(a1 + 108) = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 364)), *(int8x16_t *)(a1 + 108), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 108), *(float32x4_t *)(a1 + 108)), v75));
    *(int8x16_t *)(a1 + 124) = v79;
    v80 = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 412)), *(int8x16_t *)(a1 + 156), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 156), *(float32x4_t *)(a1 + 156)), v75));
    *(int8x16_t *)(a1 + 140) = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 396)), *(int8x16_t *)(a1 + 140), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 140), *(float32x4_t *)(a1 + 140)), v75));
    *(int8x16_t *)(a1 + 156) = v80;
    v81 = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 444)), *(int8x16_t *)(a1 + 188), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 188), *(float32x4_t *)(a1 + 188)), v75));
    *(int8x16_t *)(a1 + 172) = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 428)), *(int8x16_t *)(a1 + 172), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 172), *(float32x4_t *)(a1 + 172)), v75));
    *(int8x16_t *)(a1 + 188) = v81;
    v82 = *(int8x16_t *)(a1 + 204);
    v83 = (int8x16_t)vminnmq_f32(vaddq_f32((float32x4_t)v82, (float32x4_t)v82), v75);
    v84 = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 476)), *(int8x16_t *)(a1 + 220), (int8x16_t)vminnmq_f32(vaddq_f32(*(float32x4_t *)(a1 + 220), *(float32x4_t *)(a1 + 220)), v75));
    *(int8x16_t *)(a1 + 204) = vbslq_s8((int8x16_t)vcgtzq_s32(*(int32x4_t *)(a1 + 460)), v82, v83);
    *(int8x16_t *)(a1 + 220) = v84;
    v85 = *(float *)(a1 + 236);
    v86 = *(float *)(a1 + 240);
    v87 = fminf(v85 + v85, 1000.0);
    if (*(int *)(a1 + 492) <= 0)
      v85 = v87;
    v88 = fminf(v86 + v86, 1000.0);
    if (*(int *)(a1 + 496) <= 0)
      v86 = v88;
    *(float *)(a1 + 236) = v85;
    *(float *)(a1 + 240) = v86;
    v89 = *(float *)(a1 + 244);
    v90 = *(float *)(a1 + 248);
    v91 = fminf(v89 + v89, 1000.0);
    if (*(int *)(a1 + 500) <= 0)
      v89 = v91;
    v92 = fminf(v90 + v90, 1000.0);
    if (*(int *)(a1 + 504) <= 0)
      v90 = v92;
    *(float *)(a1 + 244) = v89;
    *(float *)(a1 + 248) = v90;
    v93 = *(float *)(a1 + 252);
    v94 = *(float *)(a1 + 256);
    v95 = fminf(v93 + v93, 1000.0);
    if (*(int *)(a1 + 508) <= 0)
      v93 = v95;
    v96 = fminf(v94 + v94, 1000.0);
    if (*(int *)(a1 + 512) <= 0)
      v94 = v96;
    *(float *)(a1 + 252) = v93;
    *(float *)(a1 + 256) = v94;
    v97 = *(float *)(a1 + 260);
    v98 = fminf(v97 + v97, 1000.0);
    if (*(int *)(a1 + 516) <= 0)
      v97 = v98;
    *(float *)(a1 + 260) = v97;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
    *(float *)(a1 + 264) = v97;
    v99 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*a3 + 0.0) + a3[1]) + a3[2]) + a3[3]) + a3[4]) + a3[5]) + a3[6]) + a3[7]) + a3[8]) + a3[9]) + a3[10]) + a3[11]) + a3[12]) + a3[13]) + a3[14]) + a3[15]) + a3[16]) + a3[17]) + a3[18]) + a3[19]) + a3[20]) + a3[21]) + a3[22]) + a3[23]) + a3[24]) + a3[25]) + a3[26]) + a3[27]) + a3[28]) + a3[29]) + a3[30])
                                                                                                + a3[31])
                                                                                        + a3[32])
                                                                                + a3[33])
                                                                        + a3[34])
                                                                + a3[35])
                                                        + a3[36])
                                                + a3[37])
                                        + a3[38])
                                + a3[39])
                        + a3[40])
                + a3[41])
        + a3[42];
    v100 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v99 + a3[43]) + a3[44]) + a3[45]) + a3[46]) + a3[47]) + a3[48]) + a3[49]) + a3[50]) + a3[51]) + a3[52])
                                                                                                 + a3[53])
                                                                                         + a3[54])
                                                                                 + a3[55])
                                                                         + a3[56])
                                                                 + a3[57])
                                                         + a3[58])
                                                 + a3[59])
                                         + a3[60])
                                 + a3[61])
                         + a3[62])
                 + a3[63])
         + a3[64];
    if (v100 > 2861000000.0)
    {
      v101 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(float *)__dst + 0.0) + *((float *)__dst + 1)) + *((float *)__dst + 2)) + *((float *)__dst + 3)) + *(float *)&__dst[1]) + *((float *)&__dst[1] + 1)) + *((float *)&__dst[1] + 2)) + *((float *)&__dst[1] + 3)) + *(float *)&__dst[2]) + *((float *)&__dst[2] + 1)) + *((float *)&__dst[2] + 2)) + *((float *)&__dst[2] + 3)) + *(float *)&__dst[3]) + *((float *)&__dst[3] + 1)) + *((float *)&__dst[3] + 2)) + *((float *)&__dst[3] + 3)) + *(float *)&__dst[4]) + *((float *)&__dst[4] + 1)) + *((float *)&__dst[4] + 2)) + *((float *)&__dst[4] + 3)) + *(float *)&__dst[5]) + *((float *)&__dst[5] + 1)) + *((float *)&__dst[5] + 2)) + *((float *)&__dst[5] + 3)) + *(float *)&__dst[6]) + *((float *)&__dst[6] + 1)) + *((float *)&__dst[6] + 2)) + *((float *)&__dst[6] + 3)) + *(float *)&__dst[7]) + *((float *)&__dst[7] + 1)) + *((float *)&__dst[7] + 2)) + *((float *)&__dst[7] + 3)) + *(float *)&__dst[8]) + *((float *)&__dst[8] + 1)) + *((float *)&__dst[8] + 2)) + *((float *)&__dst[8] + 3)) + *(float *)&__dst[9]) + *((float *)&__dst[9] + 1)) + *((float *)&__dst[9] + 2)) + *((float *)&__dst[9] + 3)) + *(float *)&__dst[10]) + *((float *)&__dst[10] + 1)) + *((float *)&__dst[10] + 2)) + *((float *)&__dst[10] + 3)) + *(float *)&__dst[11]) + *((float *)&__dst[11] + 1)) + *((float *)&__dst[11] + 2)) + *((float *)&__dst[11] + 3)) + *(float *)&__dst[12]) + *((float *)&__dst[12] + 1)) + *((float *)&__dst[12] + 2)) + *((float *)&__dst[12] + 3)) + *(float *)&__dst[13]) + *((float *)&__dst[13] + 1)) + *((float *)&__dst[13] + 2))
                                                                                           + *((float *)&__dst[13] + 3))
                                                                                   + *(float *)&__dst[14])
                                                                           + *((float *)&__dst[14] + 1))
                                                                   + *((float *)&__dst[14] + 2))
                                                           + *((float *)&__dst[14] + 3))
                                                   + *(float *)&__dst[15])
                                           + *((float *)&__dst[15] + 1))
                                   + *((float *)&__dst[15] + 2))
                           + *((float *)&__dst[15] + 3))
                   + *(float *)&__dst[16])
           / v100;
      v102 = *v66;
      if (v101 < *v66)
      {
        *(_DWORD *)(a1 + 524) = 1000;
        v103 = v102 + (float)((float)(v101 - v102) * 0.1);
        if (v103 < 0.01)
          v103 = 0.01;
        *(float *)(a1 + 520) = v103;
      }
    }
    v104 = *(_DWORD *)(a1 + 524);
    v105 = (float *)(a1 + 520);
    v106 = __OFSUB__(v104--, 1);
    *(_DWORD *)(a1 + 524) = v104;
    if ((v104 < 0) ^ v106 | (v104 == 0))
    {
      v107 = *v66 + *v66;
      if (v107 < 1000.0)
        v105 = &v107;
    }
    result = *v105;
    *v66 = *v105;
  }
  return result;
}

webrtc::ErleEstimator *webrtc::ErleEstimator::ErleEstimator(webrtc::ErleEstimator *this, uint64_t a2, float32x2_t *a3, unint64_t a4)
{
  webrtc::FullBandErleEstimator *v7;
  double v8;
  int32x2_t v9;
  webrtc::SignalDependentErleEstimator **v10;
  webrtc::SignalDependentErleEstimator *v11;
  int32x2_t v12;
  int32x2_t v13;
  webrtc::SignalDependentErleEstimator *v14;

  *(_QWORD *)this = a2;
  v7 = (webrtc::ErleEstimator *)((char *)this + 8);
  webrtc::FullBandErleEstimator::FullBandErleEstimator((webrtc::ErleEstimator *)((char *)this + 8), a3 + 30, a4);
  webrtc::SubbandErleEstimator::SubbandErleEstimator((webrtc::ErleEstimator *)((char *)this + 112), (const webrtc::EchoCanceller3Config *)a3, a4, v8, v9);
  v10 = (webrtc::SignalDependentErleEstimator **)((char *)this + 624);
  *((_OWORD *)this + 39) = 0u;
  if (*(_QWORD *)&a3[32] >= 2uLL)
  {
    v11 = (webrtc::SignalDependentErleEstimator *)operator new();
    webrtc::SignalDependentErleEstimator::SignalDependentErleEstimator(v11, (const webrtc::EchoCanceller3Config *)a3, a4, v12, v13);
    v14 = *v10;
    *v10 = v11;
    if (v14)
    {
      webrtc::SignalDependentErleEstimator::~SignalDependentErleEstimator(v14);
      MEMORY[0x20BD0ADEC]();
    }
  }
  webrtc::FullBandErleEstimator::Reset(v7);
  webrtc::SubbandErleEstimator::Reset((webrtc::ErleEstimator *)((char *)this + 112));
  if (*v10)
    webrtc::SignalDependentErleEstimator::Reset(*v10);
  *((_QWORD *)this + 79) = 0;
  return this;
}

void webrtc::ErleEstimator::~ErleEstimator(webrtc::ErleEstimator *this)
{
  webrtc::SignalDependentErleEstimator *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v2 = (webrtc::SignalDependentErleEstimator *)*((_QWORD *)this + 78);
  *((_QWORD *)this + 78) = 0;
  if (v2)
  {
    webrtc::SignalDependentErleEstimator::~SignalDependentErleEstimator(v2);
    MEMORY[0x20BD0ADEC]();
  }
  webrtc::SubbandErleEstimator::~SubbandErleEstimator((webrtc::ErleEstimator *)((char *)this + 112));
  v3 = (void *)*((_QWORD *)this + 11);
  if (v3)
  {
    *((_QWORD *)this + 12) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 8);
  if (v4)
  {
    *((_QWORD *)this + 9) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 5);
  if (v5)
  {
    *((_QWORD *)this + 6) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 2);
  if (v6)
  {
    *((_QWORD *)this + 3) = v6;
    operator delete(v6);
  }
}

unint64_t *webrtc::ErleEstimator::Update(unint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, float *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t *a11)
{
  unint64_t v11;
  unint64_t *v18;
  uint64_t v19;
  double v20;
  uint64_t v21;
  unint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v11 = result[79] + 1;
  result[79] = v11;
  if (v11 >= *result)
  {
    v18 = result;
    webrtc::SubbandErleEstimator::Update(result + 14, (uint64_t)a5, a6, a7, a9, a10, a11);
    v21 = v18[78];
    if (v21)
    {
      v22 = v18 + 60;
      v23 = v18[60];
      v24 = 0xFC0FC0FC0FC0FC1 * ((uint64_t)(v18[61] - v23) >> 2);
      if (v18[61] == v23)
        v23 = 0;
      v25 = 63;
      if (*((_BYTE *)v18 + 112))
        v22 = v18 + 63;
      else
        v25 = 60;
      v26 = v18[v25];
      v28 = v22[1] - v26;
      v27 = v28 == 0;
      v29 = 0xFC0FC0FC0FC0FC1 * (v28 >> 2);
      if (v27)
        v30 = 0;
      else
        v30 = v26;
      if (a4)
        v31 = a3;
      else
        v31 = 0;
      webrtc::SignalDependentErleEstimator::Update(v21, a2, v31, a4, a5, a6, a7, v20, v19, a9, a10, v23, v24, v30, v29, a11);
    }
    return (unint64_t *)webrtc::FullBandErleEstimator::Update((uint64_t)(v18 + 1), a5, 0x41uLL, a6, a7, a9, a10, a11);
  }
  return result;
}

void dcsctp::ErrorCausesToString(unsigned __int16 **a1@<X0>, uint64_t a2@<X4>, uint64_t a3@<X5>, uint64_t a4@<X6>, std::string *p_p_new_stuff@<X7>, std::string *a6@<X8>)
{
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unint64_t v9;
  char *v10;
  std::string::size_type v11;
  std::string::size_type v12;
  std::string::size_type v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  const char *v20;
  std::string::size_type v21;
  int v22;
  std::string::size_type size;
  std::string::size_type v24;
  char *v25;
  std::string *v26;
  std::string::size_type v28;
  char *v29;
  unint64_t v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  unsigned int v33;
  int v35;
  std::string::size_type v36;
  std::string::size_type v37;
  std::string::size_type v38;
  char *v39;
  std::string::size_type v40;
  std::string *v41;
  unsigned __int16 *v42;
  unsigned __int16 *v43;
  size_t v44;
  BOOL v45;
  unsigned __int16 *v46;
  unsigned __int16 *v47;
  unsigned int v48;
  BOOL v49;
  int v50;
  std::string::size_type v51;
  std::string::size_type v52;
  unsigned __int16 *v53;
  unsigned int v54;
  BOOL v55;
  int v56;
  std::string::size_type v57;
  std::string::size_type v58;
  unsigned __int16 *v59;
  unint64_t v60;
  BOOL v61;
  BOOL v62;
  int v63;
  std::string::size_type v64;
  std::string::size_type v65;
  unsigned __int16 *v66;
  unint64_t v67;
  BOOL v68;
  BOOL v69;
  int v70;
  std::string::size_type v71;
  std::string::size_type v72;
  unsigned __int16 *v73;
  unsigned int v74;
  BOOL v75;
  int v76;
  std::string::size_type v77;
  std::string::size_type v78;
  unsigned __int16 *v79;
  unint64_t v80;
  BOOL v81;
  BOOL v82;
  int v83;
  std::string::size_type v84;
  std::string::size_type v85;
  unsigned __int16 *v86;
  unsigned __int16 *v87;
  unsigned int v88;
  BOOL v89;
  int v90;
  std::string::size_type v91;
  std::string::size_type v92;
  unsigned __int16 *v93;
  unsigned int v94;
  BOOL v95;
  int v96;
  std::string::size_type v97;
  std::string::size_type v98;
  unsigned __int16 *v99;
  unint64_t v100;
  BOOL v101;
  BOOL v102;
  int v103;
  std::string::size_type v104;
  std::string::size_type v105;
  unsigned __int16 *v106;
  unsigned __int16 *v107;
  size_t v108;
  BOOL v109;
  unsigned __int16 *v110;
  unsigned __int16 *v111;
  size_t v112;
  BOOL v113;
  std::string *v114;
  char *v115;
  std::string::size_type v116;
  std::string *v117;
  char *v118;
  std::string::size_type v119;
  std::string *v120;
  char *v121;
  std::string::size_type v122;
  std::string *v123;
  char *v124;
  std::string::size_type v125;
  std::string *v126;
  char *v127;
  std::string::size_type v128;
  std::string *v129;
  char *v130;
  std::string::size_type v131;
  std::string *v132;
  char *v133;
  std::string::size_type v134;
  std::string *v135;
  char *v136;
  std::string::size_type v137;
  std::string *v138;
  char *v139;
  std::string::size_type v140;
  std::string *v141;
  char *v142;
  std::string::size_type v143;
  _OWORD *v144;
  int v145;
  std::string::size_type v146;
  std::string::size_type v147;
  int v148;
  std::string::size_type v149;
  std::string::size_type v150;
  int v151;
  std::string::size_type v152;
  std::string::size_type v153;
  std::string::size_type v154;
  std::string::size_type v155;
  std::string *v156;
  char *v157;
  std::string::size_type v158;
  std::string::size_type v159;
  std::string::size_type v160;
  std::string *v161;
  char *v162;
  std::string::size_type v163;
  std::string::size_type v164;
  std::string::size_type v165;
  std::string *v166;
  char *v167;
  std::string::size_type v168;
  std::string *v169;
  char *v170;
  std::string::size_type v171;
  std::string *v172;
  char *v173;
  std::string::size_type v174;
  std::string *v175;
  char *v176;
  std::string::size_type v177;
  unsigned int v178;
  unsigned __int8 v179;
  size_t v180;
  BOOL v181;
  unsigned int v182;
  std::string::size_type v183;
  std::string::size_type v184;
  std::string *v185;
  char *v186;
  std::string::size_type v187;
  unsigned __int8 v188;
  size_t v189;
  BOOL v190;
  const char *v191;
  size_t v192;
  const void *v193;
  void *v194;
  std::string::size_type v195;
  size_t v196;
  const void *v197;
  std::string::size_type v198;
  std::string::size_type v199;
  std::string::size_type v200;
  std::string *v201;
  char *v202;
  std::string::size_type v203;
  size_t v204;
  const void *v205;
  std::string::size_type v206;
  unsigned int v207;
  size_t v208;
  const void *v209;
  std::string::size_type v210;
  unsigned __int8 v211;
  size_t v212;
  BOOL v213;
  std::string::size_type v214;
  std::string::size_type v215;
  std::string *v216;
  std::string *v217;
  char *v218;
  std::string::size_type v219;
  void *v220;
  std::string *v221;
  void (**v222)(dcsctp::RestartOfAnAssociationWithNewAddressesCause *__hidden);
  std::string *v223;
  char *v224;
  char *v225;
  uint64_t v226;
  std::string v227;
  std::string __p_new_stuff;
  std::string v229;
  std::string::size_type v230;
  char v231;

  memset(&v227, 0, sizeof(v227));
  v7 = *a1;
  v8 = a1[1];
  v225 = 0;
  v226 = 0;
  v224 = 0;
  v9 = (char *)v8 - (char *)v7;
  if (v8 != v7)
  {
    v10 = (char *)v7;
    do
    {
      if (v9 <= 3)
        goto LABEL_585;
      LOWORD(__p_new_stuff.__r_.__value_.__l.__data_) = 0;
      LOWORD(__p_new_stuff.__r_.__value_.__l.__data_) = bswap32(*(unsigned __int16 *)v10) >> 16;
      v11 = __rev16(*((unsigned __int16 *)v10 + 1));
      if (v9 >= v11)
        v12 = v11;
      else
        v12 = v9;
      if (v12)
        v13 = (std::string::size_type)v10;
      else
        v13 = 0;
      v229.__r_.__value_.__r.__words[0] = v13;
      v229.__r_.__value_.__l.__size_ = v12;
      std::vector<dcsctp::ParameterDescriptor>::emplace_back<unsigned short &,rtc::ArrayView<unsigned char const,-4711l>>((void **)&v224, &__p_new_stuff, (uint64_t *)&v229);
      v14 = (unsigned __int16)(v11 + 3) & 0xFFFC;
      v15 = v9 - v14;
      if (v9 <= v14)
        break;
      v16 = &v10[v14];
      if (v15 < v9)
        v9 = v15;
      v10 = v9 ? v16 : 0;
    }
    while (v9);
  }
  v17 = v225;
  if (v225 == v224)
  {
LABEL_580:
    *a6 = v227;
    memset(&v227, 0, sizeof(v227));
    if (v17)
    {
      v225 = v17;
      operator delete(v17);
      if (SHIBYTE(v227.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v227.__r_.__value_.__l.__data_);
    }
    return;
  }
  v223 = a6;
  v18 = 0;
  v19 = 0;
  v20 = "Unhandled parameter of type: ";
  v222 = &off_24C0BB898;
  while (2)
  {
    if (!v19)
      goto LABEL_42;
    size = HIBYTE(v227.__r_.__value_.__r.__words[2]);
    if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v24 = 22;
    else
      v24 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = v227.__r_.__value_.__l.__size_;
    if (v24 == size)
    {
      std::string::__grow_by_and_replace(&v227, v24, 1uLL, v24, v24, 0, 1uLL, "\n");
      v25 = v224;
      if (0xAAAAAAAAAAAAAAABLL * ((v225 - v224) >> 3) <= v19)
        goto LABEL_584;
      goto LABEL_43;
    }
    if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v26 = &v227;
    else
      v26 = (std::string *)v227.__r_.__value_.__r.__words[0];
    if ((char *)v26 + size <= "\n" && (char *)&v26->__r_.__value_.__l.__data_ + size + 1 > "\n")
      goto LABEL_584;
    v26->__r_.__value_.__s.__data_[size] = 10;
    v28 = size + 1;
    if ((SHIBYTE(v227.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      *((_BYTE *)&v227.__r_.__value_.__s + 23) = v28 & 0x7F;
      v26->__r_.__value_.__s.__data_[v28] = 0;
LABEL_42:
      v25 = v224;
      if (0xAAAAAAAAAAAAAAABLL * ((v225 - v224) >> 3) <= v19)
        goto LABEL_584;
      goto LABEL_43;
    }
    v227.__r_.__value_.__l.__size_ = v28;
    v26->__r_.__value_.__s.__data_[v28] = 0;
    v25 = v224;
    if (0xAAAAAAAAAAAAAAABLL * ((v225 - v224) >> 3) <= v19)
      goto LABEL_584;
LABEL_43:
    v29 = &v25[v18];
    v30 = *(_QWORD *)&v25[v18 + 16];
    switch(*(_WORD *)&v25[v18])
    {
      case 1:
        v31 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (v30)
        {
          v32 = v31;
        }
        else
        {
          v31 = 0;
          v32 = 0;
        }
        if (v30 >= 8 && __rev16(*v32) == 1)
        {
          v33 = __rev16(v32[1]);
          if (v30 == 8 && v33 == 8)
          {
            v178 = bswap32(v31[2]);
            v229.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24C0B54A8;
            LOWORD(v229.__r_.__value_.__r.__words[1]) = HIWORD(v178);
            v229.__r_.__value_.__s.__data_[16] = 1;
            dcsctp::InvalidStreamIdentifierCause::ToString((dcsctp::InvalidStreamIdentifierCause *)&v229, &__p_new_stuff);
            v179 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
            if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
            {
LABEL_449:
              v180 = __p_new_stuff.__r_.__value_.__l.__size_;
              if ((__p_new_stuff.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
                goto LABEL_584;
              p_p_new_stuff = (std::string *)__p_new_stuff.__r_.__value_.__r.__words[0];
              v181 = __p_new_stuff.__r_.__value_.__l.__size_ == 0;
              if (__p_new_stuff.__r_.__value_.__l.__size_)
              {
                if (!__p_new_stuff.__r_.__value_.__r.__words[0])
                  goto LABEL_584;
              }
            }
            else
            {
LABEL_454:
              v180 = v179;
              v181 = v179 == 0;
              p_p_new_stuff = &__p_new_stuff;
            }
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v183 = 22;
            else
              v183 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v184 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
            else
              v184 = v227.__r_.__value_.__l.__size_;
            if (v183 - v184 >= v180)
            {
              if (!v181)
              {
                if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v185 = &v227;
                else
                  v185 = (std::string *)v227.__r_.__value_.__r.__words[0];
                v186 = (char *)v185 + v184;
                if ((std::string *)((char *)v185 + v184) <= p_p_new_stuff && &v186[v180] > (char *)p_p_new_stuff)
                  goto LABEL_584;
                memmove(v186, p_p_new_stuff, v180);
                v187 = v184 + v180;
                if (SHIBYTE(v227.__r_.__value_.__r.__words[2]) < 0)
                  v227.__r_.__value_.__l.__size_ = v184 + v180;
                else
                  *((_BYTE *)&v227.__r_.__value_.__s + 23) = v187 & 0x7F;
                v185->__r_.__value_.__s.__data_[v187] = 0;
              }
            }
            else
            {
              std::string::__grow_by_and_replace(&v227, v183, v184 + v180 - v183, v184, v184, 0, v180, (const std::string::value_type *)p_p_new_stuff);
            }
            if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
            {
              v220 = (void *)__p_new_stuff.__r_.__value_.__r.__words[0];
LABEL_577:
              operator delete(v220);
            }
LABEL_23:
            ++v19;
            v17 = v224;
            v18 += 24;
            if (v19 >= 0xAAAAAAAAAAAAAAABLL * ((v225 - v224) >> 3))
            {
              a6 = v223;
              goto LABEL_580;
            }
            continue;
          }
        }
        v35 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
        if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v36 = 22;
        else
          v36 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v37 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
        else
          v37 = v227.__r_.__value_.__l.__size_;
        if (v36 - v37 < 0x24)
        {
          std::string::__grow_by_and_replace(&v227, v36, v37 - v36 + 36, v37, v37, 0, 0x24uLL, "Failed to parse error cause of type ");
LABEL_420:
          v22 = 1;
          goto LABEL_22;
        }
        v114 = (std::string *)v227.__r_.__value_.__r.__words[0];
        if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v114 = &v227;
        v115 = (char *)v114 + v37;
        if ((char *)v114 + v37 > "Failed to parse error cause of type "
          || v115 + 36 <= "Failed to parse error cause of type ")
        {
          qmemcpy(v115, "Failed to parse error cause of type ", 36);
          v116 = v37 + 36;
          if (v35 < 0)
            v227.__r_.__value_.__l.__size_ = v37 + 36;
          else
            *((_BYTE *)&v227.__r_.__value_.__s + 23) = v116 & 0x7F;
          v114->__r_.__value_.__s.__data_[v116] = 0;
          goto LABEL_420;
        }
LABEL_584:
        __break(1u);
LABEL_585:
        v221 = rtc::webrtc_checks_impl::FatalLog("Source/webrtc/net/dcsctp/packet/bounded_byte_reader.h", 55, "data.size() >= FixedSize", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a2, a3, a4, (uint64_t)p_p_new_stuff, (uint64_t)v222);
        dcsctp::ErrorChunk::Parse(v221);
        return;
      case 2:
        v42 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (v30)
          v43 = v42;
        else
          v43 = 0;
        dcsctp::MissingMandatoryParameterCause::Parse(v43, v30, (uint64_t)&v229);
        if (!v231)
        {
          v145 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v146 = 22;
          else
            v146 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v147 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v147 = v227.__r_.__value_.__l.__size_;
          if (v146 - v147 >= 0x24)
          {
            v169 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v169 = &v227;
            v170 = (char *)v169 + v147;
            if ((char *)v169 + v147 <= "Failed to parse error cause of type "
              && v170 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v170, "Failed to parse error cause of type ", 36);
            v171 = v147 + 36;
            if (v145 < 0)
            {
              v227.__r_.__value_.__l.__size_ = v147 + 36;
              v169->__r_.__value_.__s.__data_[v171] = 0;
              rtc::StringBuilder::operator<<(&v227, 2);
              if (!v231)
                goto LABEL_23;
            }
            else
            {
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v171 & 0x7F;
              v169->__r_.__value_.__s.__data_[v171] = 0;
              rtc::StringBuilder::operator<<(&v227, 2);
              if (!v231)
                goto LABEL_23;
            }
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v146, v147 - v146 + 36, v147, v147, 0, 0x24uLL, "Failed to parse error cause of type ");
            rtc::StringBuilder::operator<<(&v227, 2);
            if (!v231)
              goto LABEL_23;
          }
LABEL_547:
          v229.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24C0B7540;
          if (v229.__r_.__value_.__l.__size_)
          {
            v229.__r_.__value_.__r.__words[2] = v229.__r_.__value_.__l.__size_;
            operator delete((void *)v229.__r_.__value_.__l.__size_);
          }
          goto LABEL_23;
        }
        (*(void (**)(std::string *__return_ptr, std::string *))(v229.__r_.__value_.__r.__words[0] + 24))(&__p_new_stuff, &v229);
        if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
        {
          v44 = __p_new_stuff.__r_.__value_.__l.__size_;
          if ((__p_new_stuff.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
            goto LABEL_584;
          p_p_new_stuff = (std::string *)__p_new_stuff.__r_.__value_.__r.__words[0];
          v45 = __p_new_stuff.__r_.__value_.__l.__size_ == 0;
          if (__p_new_stuff.__r_.__value_.__l.__size_)
          {
            if (!__p_new_stuff.__r_.__value_.__r.__words[0])
              goto LABEL_584;
          }
        }
        else
        {
          v44 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
          v45 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) == 0;
          p_p_new_stuff = &__p_new_stuff;
        }
        if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v154 = 22;
        else
          v154 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v155 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
        else
          v155 = v227.__r_.__value_.__l.__size_;
        if (v154 - v155 >= v44)
        {
          if (!v45)
          {
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v156 = &v227;
            else
              v156 = (std::string *)v227.__r_.__value_.__r.__words[0];
            v157 = (char *)v156 + v155;
            if ((std::string *)((char *)v156 + v155) <= p_p_new_stuff && &v157[v44] > (char *)p_p_new_stuff)
              goto LABEL_584;
            memmove(v157, p_p_new_stuff, v44);
            v158 = v155 + v44;
            if (SHIBYTE(v227.__r_.__value_.__r.__words[2]) < 0)
              v227.__r_.__value_.__l.__size_ = v155 + v44;
            else
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v158 & 0x7F;
            v156->__r_.__value_.__s.__data_[v158] = 0;
          }
        }
        else
        {
          std::string::__grow_by_and_replace(&v227, v154, v155 + v44 - v154, v155, v155, 0, v44, (const std::string::value_type *)p_p_new_stuff);
        }
        if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p_new_stuff.__r_.__value_.__l.__data_);
        if (v231)
          goto LABEL_547;
        goto LABEL_23;
      case 3:
        v46 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (v30)
        {
          v47 = v46;
        }
        else
        {
          v46 = 0;
          v47 = 0;
        }
        if (v30 < 8 || __rev16(*v47) != 3 || ((v48 = __rev16(v47[1]), v30 == 8) ? (v49 = v48 == 8) : (v49 = 0), !v49))
        {
          v50 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v51 = 22;
          else
            v51 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v52 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v52 = v227.__r_.__value_.__l.__size_;
          if (v51 - v52 >= 0x24)
          {
            v117 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v117 = &v227;
            v118 = (char *)v117 + v52;
            if ((char *)v117 + v52 <= "Failed to parse error cause of type "
              && v118 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v118, "Failed to parse error cause of type ", 36);
            v119 = v52 + 36;
            if (v50 < 0)
              v227.__r_.__value_.__l.__size_ = v52 + 36;
            else
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v119 & 0x7F;
            v117->__r_.__value_.__s.__data_[v119] = 0;
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v51, v52 - v51 + 36, v52, v52, 0, 0x24uLL, "Failed to parse error cause of type ");
          }
          v22 = 3;
          goto LABEL_22;
        }
        v182 = bswap32(*((_DWORD *)v46 + 1));
        v229.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24C0C11D0;
        LODWORD(v229.__r_.__value_.__r.__words[1]) = v182;
        v229.__r_.__value_.__s.__data_[16] = 1;
        dcsctp::StaleCookieErrorCause::ToString((dcsctp::StaleCookieErrorCause *)&v229, &__p_new_stuff);
        v179 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_449;
        goto LABEL_454;
      case 4:
        v53 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (!v30)
          v53 = 0;
        if (v30 < 4 || __rev16(*v53) != 4 || ((v54 = __rev16(v53[1]), v30 == 4) ? (v55 = v54 == 4) : (v55 = 0), !v55))
        {
          v56 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v57 = 22;
          else
            v57 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v58 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v58 = v227.__r_.__value_.__l.__size_;
          if (v57 - v58 >= 0x24)
          {
            v120 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v120 = &v227;
            v121 = (char *)v120 + v58;
            if ((char *)v120 + v58 <= "Failed to parse error cause of type "
              && v121 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v121, "Failed to parse error cause of type ", 36);
            v122 = v58 + 36;
            if (v56 < 0)
              v227.__r_.__value_.__l.__size_ = v58 + 36;
            else
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v122 & 0x7F;
            v120->__r_.__value_.__s.__data_[v122] = 0;
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v57, v58 - v57 + 36, v58, v58, 0, 0x24uLL, "Failed to parse error cause of type ");
          }
          v22 = 4;
          goto LABEL_22;
        }
        dcsctp::OutOfResourceErrorCause::ToString((char *)&v229);
        v188 = HIBYTE(v229.__r_.__value_.__r.__words[2]);
        if ((SHIBYTE(v229.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_481;
        goto LABEL_472;
      case 5:
        v59 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (!v30)
          v59 = 0;
        if (v30 < 4
          || __rev16(*v59) != 5
          || ((v60 = __rev16(v59[1]), v60 >= 4) ? (v61 = v30 >= v60) : (v61 = 0),
              v61 ? (v62 = v30 - v60 > 3) : (v62 = 1),
              v62))
        {
          v63 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v64 = 22;
          else
            v64 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v65 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v65 = v227.__r_.__value_.__l.__size_;
          if (v64 - v65 >= 0x24)
          {
            v123 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v123 = &v227;
            v124 = (char *)v123 + v65;
            if ((char *)v123 + v65 <= "Failed to parse error cause of type "
              && v124 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v124, "Failed to parse error cause of type ", 36);
            v125 = v65 + 36;
            if (v63 < 0)
              v227.__r_.__value_.__l.__size_ = v65 + 36;
            else
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v125 & 0x7F;
            v123->__r_.__value_.__s.__data_[v125] = 0;
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v64, v65 - v64 + 36, v65, v65, 0, 0x24uLL, "Failed to parse error cause of type ");
          }
          v22 = 5;
          goto LABEL_22;
        }
        v191 = v20;
        if (v60 < 5)
        {
          v194 = 0;
          v195 = 0;
        }
        else
        {
          v192 = v60 - 4;
          v193 = v59 + 2;
          v194 = operator new(v60 - 4);
          v195 = (std::string::size_type)v194 + v192;
          memcpy(v194, v193, v192);
        }
        v229.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24C0C2EC8;
        v229.__r_.__value_.__l.__size_ = (std::string::size_type)v194;
        v229.__r_.__value_.__r.__words[2] = v195;
        v230 = v195;
        v231 = 1;
        dcsctp::UnresolvableAddressCause::ToString((char *)&__p_new_stuff);
        v211 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
        if ((SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_520;
        goto LABEL_514;
      case 6:
        v66 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (!v30)
          v66 = 0;
        if (v30 < 4
          || __rev16(*v66) != 6
          || ((v67 = __rev16(v66[1]), v67 >= 4) ? (v68 = v30 >= v67) : (v68 = 0),
              v68 ? (v69 = v30 - v67 > 3) : (v69 = 1),
              v69))
        {
          v70 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v71 = 22;
          else
            v71 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v72 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v72 = v227.__r_.__value_.__l.__size_;
          if (v71 - v72 >= 0x24)
          {
            v126 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v126 = &v227;
            v127 = (char *)v126 + v72;
            if ((char *)v126 + v72 <= "Failed to parse error cause of type "
              && v127 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v127, "Failed to parse error cause of type ", 36);
            v128 = v72 + 36;
            if (v70 < 0)
              v227.__r_.__value_.__l.__size_ = v72 + 36;
            else
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v128 & 0x7F;
            v126->__r_.__value_.__s.__data_[v128] = 0;
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v71, v72 - v71 + 36, v72, v72, 0, 0x24uLL, "Failed to parse error cause of type ");
          }
          v22 = 6;
          goto LABEL_22;
        }
        v191 = v20;
        if (v67 < 5)
        {
          v198 = 0;
          v194 = 0;
        }
        else
        {
          v196 = v67 - 4;
          v197 = v66 + 2;
          v194 = operator new(v67 - 4);
          v198 = (std::string::size_type)v194 + v196;
          memcpy(v194, v197, v196);
        }
        v229.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24C0C2E68;
        v229.__r_.__value_.__l.__size_ = (std::string::size_type)v194;
        v229.__r_.__value_.__r.__words[2] = v198;
        v230 = v198;
        v231 = 1;
        dcsctp::UnrecognizedChunkTypeCause::ToString((dcsctp::UnrecognizedChunkTypeCause *)&v229, &__p_new_stuff);
        v211 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_514;
        goto LABEL_520;
      case 7:
        v73 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (!v30)
          v73 = 0;
        if (v30 < 4 || __rev16(*v73) != 7 || ((v74 = __rev16(v73[1]), v30 == 4) ? (v75 = v74 == 4) : (v75 = 0), !v75))
        {
          v76 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v77 = 22;
          else
            v77 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v78 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v78 = v227.__r_.__value_.__l.__size_;
          if (v77 - v78 >= 0x24)
          {
            v129 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v129 = &v227;
            v130 = (char *)v129 + v78;
            if ((char *)v129 + v78 <= "Failed to parse error cause of type "
              && v130 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v130, "Failed to parse error cause of type ", 36);
            v131 = v78 + 36;
            if (v76 < 0)
              v227.__r_.__value_.__l.__size_ = v78 + 36;
            else
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v131 & 0x7F;
            v129->__r_.__value_.__s.__data_[v131] = 0;
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v77, v78 - v77 + 36, v78, v78, 0, 0x24uLL, "Failed to parse error cause of type ");
          }
          v22 = 7;
          goto LABEL_22;
        }
        __p_new_stuff.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24C0B5478;
        __p_new_stuff.__r_.__value_.__s.__data_[8] = 1;
        dcsctp::InvalidMandatoryParameterCause::ToString((uint64_t)&v229);
        v188 = HIBYTE(v229.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(v229.__r_.__value_.__r.__words[2]) < 0)
          goto LABEL_472;
        goto LABEL_481;
      case 8:
        v79 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (!v30)
          v79 = 0;
        if (v30 < 4
          || __rev16(*v79) != 8
          || ((v80 = __rev16(v79[1]), v80 >= 4) ? (v81 = v30 >= v80) : (v81 = 0),
              v81 ? (v82 = v30 - v80 > 3) : (v82 = 1),
              v82))
        {
          v83 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v84 = 22;
          else
            v84 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v85 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v85 = v227.__r_.__value_.__l.__size_;
          if (v84 - v85 >= 0x24)
          {
            v132 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v132 = &v227;
            v133 = (char *)v132 + v85;
            if ((char *)v132 + v85 <= "Failed to parse error cause of type "
              && v133 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v133, "Failed to parse error cause of type ", 36);
            v134 = v85 + 36;
            if (v83 < 0)
              v227.__r_.__value_.__l.__size_ = v85 + 36;
            else
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v134 & 0x7F;
            v132->__r_.__value_.__s.__data_[v134] = 0;
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v84, v85 - v84 + 36, v85, v85, 0, 0x24uLL, "Failed to parse error cause of type ");
          }
          v22 = 8;
          goto LABEL_22;
        }
        v191 = v20;
        if (v80 < 5)
        {
          v194 = 0;
          v206 = 0;
        }
        else
        {
          v204 = v80 - 4;
          v205 = v79 + 2;
          v194 = operator new(v80 - 4);
          v206 = (std::string::size_type)v194 + v204;
          memcpy(v194, v205, v204);
        }
        v229.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24C0C2E98;
        v229.__r_.__value_.__l.__size_ = (std::string::size_type)v194;
        v229.__r_.__value_.__r.__words[2] = v206;
        v230 = v206;
        v231 = 1;
        dcsctp::UnrecognizedParametersCause::ToString((uint64_t)&__p_new_stuff);
        v211 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
        if ((SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_520;
        goto LABEL_514;
      case 9:
        v86 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (v30)
        {
          v87 = v86;
        }
        else
        {
          v86 = 0;
          v87 = 0;
        }
        if (v30 < 8 || __rev16(*v87) != 9 || ((v88 = __rev16(v87[1]), v30 == 8) ? (v89 = v88 == 8) : (v89 = 0), !v89))
        {
          v90 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v91 = 22;
          else
            v91 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v92 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v92 = v227.__r_.__value_.__l.__size_;
          if (v91 - v92 >= 0x24)
          {
            v135 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v135 = &v227;
            v136 = (char *)v135 + v92;
            if ((char *)v135 + v92 <= "Failed to parse error cause of type "
              && v136 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v136, "Failed to parse error cause of type ", 36);
            v137 = v92 + 36;
            if (v90 < 0)
              v227.__r_.__value_.__l.__size_ = v92 + 36;
            else
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v137 & 0x7F;
            v135->__r_.__value_.__s.__data_[v137] = 0;
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v91, v92 - v91 + 36, v92, v92, 0, 0x24uLL, "Failed to parse error cause of type ");
          }
          v22 = 9;
          goto LABEL_22;
        }
        v207 = bswap32(*((_DWORD *)v86 + 1));
        v229.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24C0B7938;
        LODWORD(v229.__r_.__value_.__r.__words[1]) = v207;
        v229.__r_.__value_.__s.__data_[16] = 1;
        dcsctp::NoUserDataCause::ToString(&v229, &__p_new_stuff);
        v179 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
        if ((SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_454;
        goto LABEL_449;
      case 0xA:
        v93 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (!v30)
          v93 = 0;
        if (v30 < 4 || __rev16(*v93) != 10 || ((v94 = __rev16(v93[1]), v30 == 4) ? (v95 = v94 == 4) : (v95 = 0), !v95))
        {
          v96 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v97 = 22;
          else
            v97 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v98 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v98 = v227.__r_.__value_.__l.__size_;
          if (v97 - v98 >= 0x24)
          {
            v138 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v138 = &v227;
            v139 = (char *)v138 + v98;
            if ((char *)v138 + v98 <= "Failed to parse error cause of type "
              && v139 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v139, "Failed to parse error cause of type ", 36);
            v140 = v98 + 36;
            if (v96 < 0)
              v227.__r_.__value_.__l.__size_ = v98 + 36;
            else
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v140 & 0x7F;
            v138->__r_.__value_.__s.__data_[v140] = 0;
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v97, v98 - v97 + 36, v98, v98, 0, 0x24uLL, "Failed to parse error cause of type ");
          }
          v22 = 10;
          goto LABEL_22;
        }
        __p_new_stuff.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_24C0B1760;
        __p_new_stuff.__r_.__value_.__s.__data_[8] = 1;
        dcsctp::CookieReceivedWhileShuttingDownCause::ToString((uint64_t)&v229);
        v188 = HIBYTE(v229.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(v229.__r_.__value_.__r.__words[2]) < 0)
        {
LABEL_472:
          v189 = v229.__r_.__value_.__l.__size_;
          if ((v229.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
            goto LABEL_584;
          p_p_new_stuff = (std::string *)v229.__r_.__value_.__r.__words[0];
          v190 = v229.__r_.__value_.__l.__size_ == 0;
          if (v229.__r_.__value_.__l.__size_)
          {
            if (!v229.__r_.__value_.__r.__words[0])
              goto LABEL_584;
          }
        }
        else
        {
LABEL_481:
          v189 = v188;
          v190 = v188 == 0;
          p_p_new_stuff = &v229;
        }
        if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v199 = 22;
        else
          v199 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v200 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
        else
          v200 = v227.__r_.__value_.__l.__size_;
        if (v199 - v200 >= v189)
        {
          if (!v190)
          {
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v201 = &v227;
            else
              v201 = (std::string *)v227.__r_.__value_.__r.__words[0];
            v202 = (char *)v201 + v200;
            if ((std::string *)((char *)v201 + v200) <= p_p_new_stuff && &v202[v189] > (char *)p_p_new_stuff)
              goto LABEL_584;
            memmove(v202, p_p_new_stuff, v189);
            v203 = v200 + v189;
            if (SHIBYTE(v227.__r_.__value_.__r.__words[2]) < 0)
              v227.__r_.__value_.__l.__size_ = v200 + v189;
            else
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v203 & 0x7F;
            v201->__r_.__value_.__s.__data_[v203] = 0;
          }
        }
        else
        {
          std::string::__grow_by_and_replace(&v227, v199, v200 + v189 - v199, v200, v200, 0, v189, (const std::string::value_type *)p_p_new_stuff);
        }
        if (SHIBYTE(v229.__r_.__value_.__r.__words[2]) < 0)
        {
          v220 = (void *)v229.__r_.__value_.__r.__words[0];
          goto LABEL_577;
        }
        goto LABEL_23;
      case 0xB:
        v99 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (!v30)
          v99 = 0;
        if (v30 < 4
          || __rev16(*v99) != 11
          || ((v100 = __rev16(v99[1]), v100 >= 4) ? (v101 = v30 >= v100) : (v101 = 0),
              v101 ? (v102 = v30 - v100 > 3) : (v102 = 1),
              v102))
        {
          v103 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v104 = 22;
          else
            v104 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v105 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v105 = v227.__r_.__value_.__l.__size_;
          if (v104 - v105 >= 0x24)
          {
            v141 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v141 = &v227;
            v142 = (char *)v141 + v105;
            if ((char *)v141 + v105 <= "Failed to parse error cause of type "
              && v142 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v142, "Failed to parse error cause of type ", 36);
            v143 = v105 + 36;
            if (v103 < 0)
              v227.__r_.__value_.__l.__size_ = v105 + 36;
            else
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v143 & 0x7F;
            v141->__r_.__value_.__s.__data_[v143] = 0;
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v104, v105 - v104 + 36, v105, v105, 0, 0x24uLL, "Failed to parse error cause of type ");
          }
          v22 = 11;
LABEL_22:
          rtc::StringBuilder::operator<<(&v227, v22);
        }
        else
        {
          v191 = v20;
          if (v100 < 5)
          {
            v194 = 0;
            v210 = 0;
          }
          else
          {
            v208 = v100 - 4;
            v209 = v99 + 2;
            v194 = operator new(v100 - 4);
            v210 = (std::string::size_type)v194 + v208;
            memcpy(v194, v209, v208);
          }
          v229.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24C0BB898;
          v229.__r_.__value_.__l.__size_ = (std::string::size_type)v194;
          v229.__r_.__value_.__r.__words[2] = v210;
          v230 = v210;
          v231 = 1;
          dcsctp::RestartOfAnAssociationWithNewAddressesCause::ToString((uint64_t)&__p_new_stuff);
          v211 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
          if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
          {
LABEL_514:
            v212 = __p_new_stuff.__r_.__value_.__l.__size_;
            if ((__p_new_stuff.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
              goto LABEL_584;
            p_p_new_stuff = (std::string *)__p_new_stuff.__r_.__value_.__r.__words[0];
            v213 = __p_new_stuff.__r_.__value_.__l.__size_ == 0;
            v20 = v191;
            if (__p_new_stuff.__r_.__value_.__l.__size_)
            {
              if (!__p_new_stuff.__r_.__value_.__r.__words[0])
                goto LABEL_584;
            }
          }
          else
          {
LABEL_520:
            v212 = v211;
            v213 = v211 == 0;
            p_p_new_stuff = &__p_new_stuff;
            v20 = v191;
          }
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v214 = 22;
          else
            v214 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v215 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v215 = v227.__r_.__value_.__l.__size_;
          if (v214 - v215 >= v212)
          {
            if (!v213)
            {
              v216 = (std::string *)v227.__r_.__value_.__r.__words[0];
              if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v216 = &v227;
              v217 = v216;
              v218 = (char *)v216 + v215;
              if ((std::string *)((char *)v216 + v215) <= p_p_new_stuff && &v218[v212] > (char *)p_p_new_stuff)
                goto LABEL_584;
              memmove(v218, p_p_new_stuff, v212);
              v219 = v215 + v212;
              if (SHIBYTE(v227.__r_.__value_.__r.__words[2]) < 0)
                v227.__r_.__value_.__l.__size_ = v215 + v212;
              else
                *((_BYTE *)&v227.__r_.__value_.__s + 23) = v219 & 0x7F;
              v217->__r_.__value_.__s.__data_[v219] = 0;
              v20 = "Unhandled parameter of type: ";
            }
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v214, v215 + v212 - v214, v215, v215, 0, v212, (const std::string::value_type *)p_p_new_stuff);
          }
          if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p_new_stuff.__r_.__value_.__l.__data_);
          if (v194)
            operator delete(v194);
        }
        goto LABEL_23;
      case 0xC:
        v106 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (v30)
          v107 = v106;
        else
          v107 = 0;
        dcsctp::UserInitiatedAbortCause::Parse(v107, v30, (uint64_t)&v229);
        if (v231)
        {
          (*(void (**)(std::string *__return_ptr, std::string *))(v229.__r_.__value_.__r.__words[0] + 24))(&__p_new_stuff, &v229);
          if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
          {
            v108 = __p_new_stuff.__r_.__value_.__l.__size_;
            if ((__p_new_stuff.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
              goto LABEL_584;
            p_p_new_stuff = (std::string *)__p_new_stuff.__r_.__value_.__r.__words[0];
            v109 = __p_new_stuff.__r_.__value_.__l.__size_ == 0;
            if (__p_new_stuff.__r_.__value_.__l.__size_)
            {
              if (!__p_new_stuff.__r_.__value_.__r.__words[0])
                goto LABEL_584;
            }
          }
          else
          {
            v108 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
            v109 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) == 0;
            p_p_new_stuff = &__p_new_stuff;
          }
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v159 = 22;
          else
            v159 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v160 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v160 = v227.__r_.__value_.__l.__size_;
          if (v159 - v160 >= v108)
          {
            if (!v109)
            {
              if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v161 = &v227;
              else
                v161 = (std::string *)v227.__r_.__value_.__r.__words[0];
              v162 = (char *)v161 + v160;
              if ((std::string *)((char *)v161 + v160) <= p_p_new_stuff && &v162[v108] > (char *)p_p_new_stuff)
                goto LABEL_584;
              memmove(v162, p_p_new_stuff, v108);
              v163 = v160 + v108;
              if (SHIBYTE(v227.__r_.__value_.__r.__words[2]) < 0)
                v227.__r_.__value_.__l.__size_ = v160 + v108;
              else
                *((_BYTE *)&v227.__r_.__value_.__s + 23) = v163 & 0x7F;
              v161->__r_.__value_.__s.__data_[v163] = 0;
            }
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v159, v160 + v108 - v159, v160, v160, 0, v108, (const std::string::value_type *)p_p_new_stuff);
          }
          if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p_new_stuff.__r_.__value_.__l.__data_);
          if (!v231)
            goto LABEL_23;
        }
        else
        {
          v148 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v149 = 22;
          else
            v149 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v150 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v150 = v227.__r_.__value_.__l.__size_;
          if (v149 - v150 >= 0x24)
          {
            v172 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v172 = &v227;
            v173 = (char *)v172 + v150;
            if ((char *)v172 + v150 <= "Failed to parse error cause of type "
              && v173 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v173, "Failed to parse error cause of type ", 36);
            v174 = v150 + 36;
            if (v148 < 0)
            {
              v227.__r_.__value_.__l.__size_ = v150 + 36;
              v172->__r_.__value_.__s.__data_[v174] = 0;
              rtc::StringBuilder::operator<<(&v227, 12);
              if (!v231)
                goto LABEL_23;
            }
            else
            {
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v174 & 0x7F;
              v172->__r_.__value_.__s.__data_[v174] = 0;
              rtc::StringBuilder::operator<<(&v227, 12);
              if (!v231)
                goto LABEL_23;
            }
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v149, v150 - v149 + 36, v150, v150, 0, 0x24uLL, "Failed to parse error cause of type ");
            rtc::StringBuilder::operator<<(&v227, 12);
            if (!v231)
              goto LABEL_23;
          }
        }
        v229.__r_.__value_.__r.__words[0] = (std::string::size_type)off_24C0C2EF8;
        if ((SHIBYTE(v230) & 0x80000000) == 0)
          goto LABEL_23;
        goto LABEL_562;
      case 0xD:
        v110 = (unsigned __int16 *)*((_QWORD *)v29 + 1);
        if (v30)
          v111 = v110;
        else
          v111 = 0;
        dcsctp::ProtocolViolationCause::Parse(v111, v30, (uint64_t)&v229);
        if (v231)
        {
          (*(void (**)(std::string *__return_ptr, std::string *))(v229.__r_.__value_.__r.__words[0] + 24))(&__p_new_stuff, &v229);
          if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
          {
            v112 = __p_new_stuff.__r_.__value_.__l.__size_;
            if ((__p_new_stuff.__r_.__value_.__l.__size_ & 0x8000000000000000) != 0)
              goto LABEL_584;
            p_p_new_stuff = (std::string *)__p_new_stuff.__r_.__value_.__r.__words[0];
            v113 = __p_new_stuff.__r_.__value_.__l.__size_ == 0;
            if (__p_new_stuff.__r_.__value_.__l.__size_)
            {
              if (!__p_new_stuff.__r_.__value_.__r.__words[0])
                goto LABEL_584;
            }
          }
          else
          {
            v112 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]);
            v113 = HIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) == 0;
            p_p_new_stuff = &__p_new_stuff;
          }
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v164 = 22;
          else
            v164 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v165 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v165 = v227.__r_.__value_.__l.__size_;
          if (v164 - v165 >= v112)
          {
            if (!v113)
            {
              if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v166 = &v227;
              else
                v166 = (std::string *)v227.__r_.__value_.__r.__words[0];
              v167 = (char *)v166 + v165;
              if ((std::string *)((char *)v166 + v165) <= p_p_new_stuff && &v167[v112] > (char *)p_p_new_stuff)
                goto LABEL_584;
              memmove(v167, p_p_new_stuff, v112);
              v168 = v165 + v112;
              if (SHIBYTE(v227.__r_.__value_.__r.__words[2]) < 0)
                v227.__r_.__value_.__l.__size_ = v165 + v112;
              else
                *((_BYTE *)&v227.__r_.__value_.__s + 23) = v168 & 0x7F;
              v166->__r_.__value_.__s.__data_[v168] = 0;
            }
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v164, v165 + v112 - v164, v165, v165, 0, v112, (const std::string::value_type *)p_p_new_stuff);
          }
          if (SHIBYTE(__p_new_stuff.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p_new_stuff.__r_.__value_.__l.__data_);
          if (!v231)
            goto LABEL_23;
        }
        else
        {
          v151 = SHIBYTE(v227.__r_.__value_.__r.__words[2]);
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v152 = 22;
          else
            v152 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v153 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          else
            v153 = v227.__r_.__value_.__l.__size_;
          if (v152 - v153 >= 0x24)
          {
            v175 = (std::string *)v227.__r_.__value_.__r.__words[0];
            if ((v227.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v175 = &v227;
            v176 = (char *)v175 + v153;
            if ((char *)v175 + v153 <= "Failed to parse error cause of type "
              && v176 + 36 > "Failed to parse error cause of type ")
            {
              goto LABEL_584;
            }
            qmemcpy(v176, "Failed to parse error cause of type ", 36);
            v177 = v153 + 36;
            if (v151 < 0)
            {
              v227.__r_.__value_.__l.__size_ = v153 + 36;
              v175->__r_.__value_.__s.__data_[v177] = 0;
              rtc::StringBuilder::operator<<(&v227, 13);
              if (!v231)
                goto LABEL_23;
            }
            else
            {
              *((_BYTE *)&v227.__r_.__value_.__s + 23) = v177 & 0x7F;
              v175->__r_.__value_.__s.__data_[v177] = 0;
              rtc::StringBuilder::operator<<(&v227, 13);
              if (!v231)
                goto LABEL_23;
            }
          }
          else
          {
            std::string::__grow_by_and_replace(&v227, v152, v153 - v152 + 36, v153, v153, 0, 0x24uLL, "Failed to parse error cause of type ");
            rtc::StringBuilder::operator<<(&v227, 13);
            if (!v231)
              goto LABEL_23;
          }
        }
        v229.__r_.__value_.__r.__words[0] = (std::string::size_type)off_24C0BAE18;
        if (SHIBYTE(v230) < 0)
LABEL_562:
          operator delete((void *)v229.__r_.__value_.__l.__size_);
        goto LABEL_23;
      default:
        if (SHIBYTE(v227.__r_.__value_.__r.__words[2]) < 0)
        {
          v38 = v227.__r_.__value_.__l.__size_;
          v21 = (v227.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
          if (v21 - v227.__r_.__value_.__l.__size_ < 0x1D)
            goto LABEL_20;
          v41 = (std::string *)v227.__r_.__value_.__r.__words[0];
          v144 = (_OWORD *)(v227.__r_.__value_.__r.__words[0] + v227.__r_.__value_.__l.__size_);
          if (v227.__r_.__value_.__r.__words[0] + v227.__r_.__value_.__l.__size_ <= (unint64_t)v20
            && (char *)v144 + 29 > v20)
          {
            goto LABEL_584;
          }
          *v144 = *(_OWORD *)v20;
          *(_OWORD *)((char *)v144 + 13) = *(_OWORD *)(v20 + 13);
          v40 = v38 + 29;
          v227.__r_.__value_.__l.__size_ = v38 + 29;
        }
        else
        {
          v38 = HIBYTE(v227.__r_.__value_.__r.__words[2]);
          if (HIBYTE(v227.__r_.__value_.__r.__words[2]) < 0x17u)
          {
            v21 = 22;
LABEL_20:
            std::string::__grow_by_and_replace(&v227, v21, v38 - v21 + 29, v38, v38, 0, 0x1DuLL, v20);
            goto LABEL_21;
          }
          v39 = (char *)&v227 + HIBYTE(v227.__r_.__value_.__r.__words[2]);
          if (v39 <= v20 && v39 + 29 > v20)
            goto LABEL_584;
          *(_OWORD *)v39 = *(_OWORD *)v20;
          *(_OWORD *)(v39 + 13) = *(_OWORD *)(v20 + 13);
          v40 = v38 + 29;
          *((_BYTE *)&v227.__r_.__value_.__s + 23) = (v38 + 29) & 0x7F;
          v41 = &v227;
        }
        v41->__r_.__value_.__s.__data_[v40] = 0;
LABEL_21:
        v22 = *(unsigned __int16 *)&v25[v18];
        goto LABEL_22;
    }
  }
}

_BYTE *dcsctp::ErrorChunk::Parse@<X0>(_BYTE *result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _BYTE *v4;
  int v5;
  unint64_t v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  unsigned __int16 *v10;
  unsigned __int16 *v11;
  size_t v12;
  unint64_t v13;
  unsigned __int16 *v14;
  unint64_t v15;
  unint64_t v17;
  char *v18;
  char *v19;

  if (a2)
    v4 = result;
  else
    v4 = 0;
  if (a2 < 4
    || *v4 != 9
    || ((v5 = v4[3], v6 = v5 | (v4[2] << 8), (v5 & 3) == 0)
      ? (v7 = v6 >= 4)
      : (v7 = 0),
        v7 ? (v8 = a2 >= v6) : (v8 = 0),
        v8 ? (v9 = a2 - v6 >= 4) : (v9 = 1),
        v9))
  {
LABEL_17:
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 32) = 0;
    return result;
  }
  v10 = (unsigned __int16 *)(v4 + 4);
  if (v6 <= 4)
    v11 = 0;
  else
    v11 = v10;
  v12 = v6 - 4;
  if (v6 != 4)
  {
    v13 = v6 - 4;
    v14 = v11;
    while (v13 >= 4)
    {
      v15 = __rev16(v14[1]);
      if (v15 < 4 || v13 < v15)
        break;
      v17 = (unsigned __int16)(v15 + 3) & 0xFFFC;
      if (v13 > v17)
      {
        v14 = (unsigned __int16 *)((char *)v14 + v17);
        if (v13 - v17 < v13)
          v13 -= v17;
        if (v13)
          continue;
      }
      if ((v12 & 0x8000000000000000) != 0)
        abort();
      v18 = (char *)operator new(v12);
      v19 = &v18[v12];
      result = memcpy(v18, v11, v12);
      goto LABEL_36;
    }
    goto LABEL_17;
  }
  v18 = 0;
  v19 = 0;
LABEL_36:
  *(_QWORD *)a3 = &off_24C0B3D70;
  *(_QWORD *)(a3 + 8) = v18;
  *(_QWORD *)(a3 + 16) = v19;
  *(_QWORD *)(a3 + 24) = v19;
  *(_BYTE *)(a3 + 32) = 1;
  return result;
}

void dcsctp::ErrorChunk::~ErrorChunk(dcsctp::ErrorChunk *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C0B3D70;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_24C0B3D70;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x20BD0ADECLL);
}

void dcsctp::ErrorChunk::SerializeTo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE *v9;
  _BYTE *v10;
  char *v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  const void *v15;
  char *v16;
  uint64_t v17;

  v9 = *(_BYTE **)(a1 + 8);
  v10 = *(_BYTE **)(a1 + 16);
  v11 = *(char **)a2;
  v12 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  v13 = v10 - v9 + 4;
  if (v12 >= v12 + v13)
  {
    if (v12 > v12 + v13)
      *(_QWORD *)(a2 + 8) = &v11[v12 + v13];
  }
  else
  {
    std::vector<unsigned char>::__append((char **)a2, v10 - v9 + 4);
    v11 = *(char **)a2;
  }
  v14 = &v11[v12];
  *v14 = 9;
  v14[2] = BYTE1(v13);
  v14[3] = v13;
  if ((unint64_t)(v10 - v9) >= 0xFFFFFFFFFFFFFFFCLL)
  {
    rtc::webrtc_checks_impl::FatalLog("Source/webrtc/net/dcsctp/packet/bounded_byte_writer.h", 59, "data.size() >= FixedSize", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, a5, a6, a7, a8, v17);
    dcsctp::ErrorChunk::ToString(v16);
  }
  else
  {
    if (v10 == v9)
      v15 = 0;
    else
      v15 = v9;
    if (v10 != v9)
    {
      if (v15)
        memcpy((void *)(*(_QWORD *)a2 + v12 + 4), v15, v10 - v9);
    }
  }
}

void dcsctp::ErrorChunk::ToString(char *a1@<X8>)
{
  a1[23] = 5;
  if (a1 <= "ERROR" && a1 + 5 > "ERROR")
    __break(1u);
  else
    strcpy(a1, "ERROR");
}

rtc::Event *rtc::Event::Event(rtc::Event *this, char a2, char a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  pthread_condattr_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  *((_BYTE *)this + 112) = a2;
  *((_BYTE *)this + 113) = a3;
  if (pthread_mutex_init((pthread_mutex_t *)this, 0))
  {
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/event.cc", 87, "pthread_mutex_init(&event_mutex_, nullptr) == 0", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v4, v5, v6, v7, v17);
    goto LABEL_6;
  }
  if (pthread_condattr_init(&v18))
  {
LABEL_6:
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/event.cc", 89, "pthread_condattr_init(&cond_attr) == 0", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v8, v9, v10, v11, v17);
LABEL_7:
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/event.cc", 93, "pthread_cond_init(&event_cond_, &cond_attr) == 0", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v12, v13, v14, v15, v17);
  }
  if (pthread_cond_init((pthread_cond_t *)((char *)this + 64), &v18))
    goto LABEL_7;
  pthread_condattr_destroy(&v18);
  return this;
}

rtc::Event *rtc::Event::Event(rtc::Event *this)
{
  return rtc::Event::Event(this, 0, 0);
}

void rtc::Event::~Event(rtc::Event *this)
{
  pthread_mutex_destroy((pthread_mutex_t *)this);
  pthread_cond_destroy((pthread_cond_t *)((char *)this + 64));
}

uint64_t rtc::Event::Set(rtc::Event *this)
{
  pthread_mutex_lock((pthread_mutex_t *)this);
  *((_BYTE *)this + 113) = 1;
  pthread_cond_broadcast((pthread_cond_t *)((char *)this + 64));
  return pthread_mutex_unlock((pthread_mutex_t *)this);
}

uint64_t rtc::Event::Wait(rtc::Event *this, TimeDelta a2, TimeDelta a3)
{
  uint64_t v3;
  __darwin_time_t v7;
  int64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  __darwin_time_t v13;
  int64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  BOOL v22;
  BOOL v24;
  BOOL v26;
  uint64_t v27;
  uint64_t v29;
  timespec v30;
  char v31;
  timespec v32;
  char v33;
  timespec v34;
  char v35;
  timeval v36;

  if (a3.var0 >= a2.var0)
  {
    v12 = 0;
    v11 = 0;
    v10 = 0;
    if (a2.var0 != 0x7FFFFFFFFFFFFFFFLL)
      goto LABEL_6;
LABEL_12:
    v15 = 0;
    v16 = 0;
    v17 = 0;
    if (!v18)
      goto LABEL_14;
    goto LABEL_13;
  }
  gettimeofday(&v36, 0);
  v7 = v36.tv_sec + a3.var0 / 1000000;
  v8 = a3.var0 % 1000000 + v36.tv_usec;
  if (v8 <= 999999)
  {
    v9 = 1000 * v8;
  }
  else
  {
    ++v7;
    v9 = 1000 * v8 - 1000000000;
  }
  v29 = v9;
  v10 = v7 & 0xFFFFFFFFFFFFFF00;
  v11 = v7;
  v12 = 1;
  if (a2.var0 == 0x7FFFFFFFFFFFFFFFLL)
    goto LABEL_12;
LABEL_6:
  gettimeofday(&v36, 0);
  v13 = v36.tv_sec + a2.var0 / 1000000;
  v14 = a2.var0 % 1000000 + v36.tv_usec;
  if (v14 <= 999999)
  {
    v3 = 1000 * v14;
  }
  else
  {
    ++v13;
    v3 = 1000 * v14 - 1000000000;
  }
  v15 = v13 & 0xFFFFFFFFFFFFFF00;
  v16 = v13;
  v17 = 1;
  if (v18)
LABEL_13:
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 16))(v18);
LABEL_14:
  pthread_mutex_lock((pthread_mutex_t *)this);
  if (a3.var0 >= a2.var0)
  {
    v34.tv_sec = v16 | v15;
    v34.tv_nsec = v3;
    v35 = v17;
    if (*((_BYTE *)this + 113))
      goto LABEL_60;
    if (!v17)
      goto LABEL_36;
    while (1)
    {
      v19 = pthread_cond_timedwait((pthread_cond_t *)((char *)this + 64), (pthread_mutex_t *)this, &v34);
      if (*((_BYTE *)this + 113) || v19 != 0)
        break;
      while (!v35)
      {
LABEL_36:
        v19 = pthread_cond_wait((pthread_cond_t *)((char *)this + 64), (pthread_mutex_t *)this);
        if (*((_BYTE *)this + 113))
          v24 = 0;
        else
          v24 = v19 == 0;
        if (!v24)
          goto LABEL_58;
      }
    }
  }
  else
  {
    v32.tv_sec = v10 | v11;
    v32.tv_nsec = v29;
    v33 = v12;
    if (*((_BYTE *)this + 113))
      goto LABEL_60;
    if (!v12)
      goto LABEL_22;
    while (1)
    {
      v19 = pthread_cond_timedwait((pthread_cond_t *)((char *)this + 64), (pthread_mutex_t *)this, &v32);
      v20 = *((unsigned __int8 *)this + 113);
      if (*((_BYTE *)this + 113) || v19 != 0)
        break;
      while (!v33)
      {
LABEL_22:
        v19 = pthread_cond_wait((pthread_cond_t *)((char *)this + 64), (pthread_mutex_t *)this);
        v20 = *((unsigned __int8 *)this + 113);
        if (*((_BYTE *)this + 113))
          v22 = 0;
        else
          v22 = v19 == 0;
        if (!v22)
          goto LABEL_43;
      }
    }
LABEL_43:
    if (v19 == 60)
    {
      v30.tv_sec = v16 | v15;
      v30.tv_nsec = v3;
      v31 = v17;
      if (v20)
        goto LABEL_60;
      if (!v17)
        goto LABEL_51;
      while (1)
      {
        v19 = pthread_cond_timedwait((pthread_cond_t *)((char *)this + 64), (pthread_mutex_t *)this, &v30);
        if (*((_BYTE *)this + 113) || v19 != 0)
          break;
        while (!v31)
        {
LABEL_51:
          v19 = pthread_cond_wait((pthread_cond_t *)((char *)this + 64), (pthread_mutex_t *)this);
          if (*((_BYTE *)this + 113))
            v26 = 0;
          else
            v26 = v19 == 0;
          if (!v26)
            goto LABEL_58;
        }
      }
    }
  }
LABEL_58:
  if (v19)
  {
    v27 = 0;
    goto LABEL_63;
  }
LABEL_60:
  if (!*((_BYTE *)this + 112))
    *((_BYTE *)this + 113) = 0;
  v27 = 1;
LABEL_63:
  pthread_mutex_unlock((pthread_mutex_t *)this);
  return v27;
}

__n128 webrtc::EventLogWriter::MaybeLogEncoderConfig(uint64_t *a1, uint64_t a2)
{
  int v4;
  BOOL v5;
  int v6;
  BOOL v7;
  int v8;
  int v9;
  __n128 result;
  int v11;
  float v12;
  float v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t *v19;
  _QWORD *v20;
  __int128 v21;
  __int128 v22;
  _QWORD *v23;

  v4 = *(unsigned __int8 *)(a2 + 40);
  if (*((_BYTE *)a1 + 64))
    v5 = v4 == 0;
  else
    v5 = 1;
  if (v5)
  {
    if ((*((_BYTE *)a1 + 64) != 0) != (v4 != 0))
      goto LABEL_41;
  }
  else if (a1[7] != *(_QWORD *)(a2 + 32))
  {
    goto LABEL_41;
  }
  v6 = *(unsigned __int8 *)(a2 + 27);
  if (*((_BYTE *)a1 + 51))
    v7 = v6 == 0;
  else
    v7 = 1;
  if (v7)
  {
    if ((*((_BYTE *)a1 + 51) != 0) != (v6 != 0))
      goto LABEL_41;
  }
  else if (*((unsigned __int8 *)a1 + 50) != *(unsigned __int8 *)(a2 + 26))
  {
    goto LABEL_41;
  }
  if (*((_BYTE *)a1 + 49) && *(_BYTE *)(a2 + 25))
  {
    if (*((unsigned __int8 *)a1 + 48) != *(unsigned __int8 *)(a2 + 24))
      goto LABEL_41;
  }
  else if ((*((_BYTE *)a1 + 49) != 0) != (*(_BYTE *)(a2 + 25) != 0))
  {
    goto LABEL_41;
  }
  if (*((_BYTE *)a1 + 36) && *(_BYTE *)(a2 + 12))
  {
    if (*((_DWORD *)a1 + 8) != *(_DWORD *)(a2 + 8))
      goto LABEL_41;
  }
  else if ((*((_BYTE *)a1 + 36) != 0) != (*(_BYTE *)(a2 + 12) != 0))
  {
    goto LABEL_41;
  }
  if (*((_BYTE *)a1 + 28))
  {
    if (*(_BYTE *)(a2 + 4))
    {
      v8 = *((_DWORD *)a1 + 6);
      v9 = v8 - *(_DWORD *)a2;
      if (v9 < 0)
        v9 = *(_DWORD *)a2 - v8;
      result.n128_f32[0] = *((float *)a1 + 3) * (float)v8;
      v11 = (int)result.n128_f32[0];
      if (*((_DWORD *)a1 + 2) < (int)result.n128_f32[0])
        v11 = *((_DWORD *)a1 + 2);
      if (v9 >= v11)
        goto LABEL_41;
    }
  }
  else if (*(_BYTE *)(a2 + 4))
  {
    goto LABEL_41;
  }
  if (*((_BYTE *)a1 + 44))
  {
    if (!*(_BYTE *)(a2 + 20))
      return result;
    v12 = *((float *)a1 + 10);
    v13 = vabds_f32(v12, *(float *)(a2 + 16));
    result.n128_f32[0] = v12 * *((float *)a1 + 4);
    if (v13 < result.n128_f32[0])
      return result;
  }
  else if (!*(_BYTE *)(a2 + 20))
  {
    return result;
  }
LABEL_41:
  v14 = operator new();
  v15 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v14 = *(_OWORD *)a2;
  *(_OWORD *)(v14 + 16) = v15;
  *(_OWORD *)(v14 + 32) = *(_OWORD *)(a2 + 32);
  *(_BYTE *)(v14 + 48) = *(_BYTE *)(a2 + 48);
  v16 = *a1;
  v17 = (_QWORD *)operator new();
  if (rtc::g_clock)
  {
    v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)rtc::g_clock + 16))(rtc::g_clock);
  }
  else
  {
    if (!dword_253EA791C)
      mach_timebase_info((mach_timebase_info_t)&rtc::SystemTimeNanos(void)::timebase);
    v18 = (uint64_t)(mach_absolute_time() * rtc::SystemTimeNanos(void)::timebase)
        / dword_253EA791C;
  }
  v19 = a1 + 3;
  *v17 = &unk_24C0BBC40;
  v17[1] = 1000 * (v18 / 1000000);
  v17[2] = v14;
  v23 = v17;
  (*(void (**)(uint64_t, _QWORD **))(*(_QWORD *)v16 + 40))(v16, &v23);
  v20 = v23;
  v23 = 0;
  if (v20)
    (*(void (**)(_QWORD *))(*v20 + 8))(v20);
  result = *(__n128 *)a2;
  v21 = *(_OWORD *)(a2 + 16);
  v22 = *(_OWORD *)(a2 + 32);
  *((_BYTE *)v19 + 48) = *(_BYTE *)(a2 + 48);
  *((_OWORD *)v19 + 1) = v21;
  *((_OWORD *)v19 + 2) = v22;
  *(__n128 *)v19 = result;
  return result;
}

void webrtc::Expand::~Expand(webrtc::Expand *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)this = &off_24C0B3DA0;
  v1 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v1)
  {
    v2 = v1 - 16;
    v3 = *(_QWORD *)(v1 - 8);
    if (v3)
    {
      v4 = v3 << 7;
      v5 = v1 - 88;
      do
      {
        v6 = (_QWORD *)(v5 + v4);
        v7 = *(_QWORD *)(v5 + v4 + 48);
        v6[5] = &off_24C0AEF80;
        v6[6] = 0;
        if (v7)
          MEMORY[0x20BD0ADD4](v7, 0x1000C80BDFB0063);
        v8 = v6[1];
        *(_QWORD *)(v5 + v4) = &off_24C0AEF80;
        v6[1] = 0;
        if (v8)
          MEMORY[0x20BD0ADD4](v8, 0x1000C80BDFB0063);
        v4 -= 128;
      }
      while (v4);
    }
    MEMORY[0x20BD0ADD4](v2, 0x1090C806E96DF6FLL);
  }
}

{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)this = &off_24C0B3DA0;
  v1 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v1)
  {
    v2 = v1 - 16;
    v3 = *(_QWORD *)(v1 - 8);
    if (v3)
    {
      v4 = v3 << 7;
      v5 = v1 - 88;
      do
      {
        v6 = (_QWORD *)(v5 + v4);
        v7 = *(_QWORD *)(v5 + v4 + 48);
        v6[5] = &off_24C0AEF80;
        v6[6] = 0;
        if (v7)
          MEMORY[0x20BD0ADD4](v7, 0x1000C80BDFB0063);
        v8 = v6[1];
        *(_QWORD *)(v5 + v4) = &off_24C0AEF80;
        v6[1] = 0;
        if (v8)
          MEMORY[0x20BD0ADD4](v8, 0x1000C80BDFB0063);
        v4 -= 128;
      }
      while (v4);
    }
    MEMORY[0x20BD0ADD4](v2, 0x1090C806E96DF6FLL);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::Expand::Reset(uint64_t this)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_BYTE *)(this + 24) = 1;
  *(_DWORD *)(this + 40) = 0;
  *(_QWORD *)(this + 72) = 0;
  if (*(_QWORD *)(this + 32))
  {
    v1 = 0;
    v2 = 0;
    do
    {
      v3 = *(_QWORD *)(this + 128) + v1;
      *(_QWORD *)(v3 + 64) = 0;
      *(_QWORD *)(v3 + 72) = 0;
      v4 = *(_QWORD *)(this + 128) + v1;
      *(_QWORD *)(v4 + 104) = 0;
      *(_QWORD *)(v4 + 112) = 0;
      ++v2;
      v1 += 128;
    }
    while (v2 < *(_QWORD *)(this + 32));
  }
  return this;
}

uint64_t webrtc::Expand::Process(webrtc::Expand *this, webrtc::AudioMultiVector *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int *v19;
  uint64_t v20;
  __int16 *v21;
  int v22;
  uint64_t v23;
  _WORD *v24;
  _WORD *v25;
  unint64_t v26;
  uint64_t v27;
  _WORD *v28;
  _WORD *v29;
  int v30;
  int16x8_t *v31;
  int v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  signed int v38;
  int32x4_t v39;
  int v40;
  int v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  unsigned int v46;
  uint32x4_t v47;
  unint64_t v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v57;
  int v59;
  unint64_t v60;
  unsigned int v61;
  char v62;
  int v63;
  __int16 *v64;
  unsigned int v65;
  unsigned int v66;
  __int32 v67;
  __int32 v68;
  __int32 v69;
  __int32 v70;
  __int32 v71;
  int32x4_t v72;
  __int32 v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  int v81;
  uint64_t v82;
  unsigned int v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  int v88;
  signed int v89;
  unint64_t v90;
  unint64_t v91;
  int v92;
  uint64_t v93;
  signed int v94;
  char v95;
  int v96;
  int v97;
  int v98;
  __int16 v99;
  int v100;
  int v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  int v105;
  int v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  unint64_t v110;
  uint64_t v111;
  unint64_t v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unsigned int v118;
  uint64_t v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  uint64_t v124;
  unint64_t v125;
  unint64_t v126;
  BOOL v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  BOOL v131;
  int32x4_t v132;
  unint64_t v133;
  int v134;
  uint64_t v135;
  int v136;
  unsigned int v137;
  int v138;
  char v139;
  uint64_t v140;
  uint64_t v141;
  signed int v142;
  signed int v143;
  signed int v144;
  signed int v145;
  unsigned int v146;
  int v147;
  unsigned int v148;
  unint64_t v149;
  const __int16 *v150;
  int v151;
  int v152;
  int v153;
  BOOL v154;
  _QWORD *v155;
  unsigned int v156;
  int v157;
  unsigned int v158;
  int v159;
  int v160;
  int v161;
  __int16 v162;
  _QWORD *v163;
  uint64_t v164;
  const __int16 *v165;
  const __int16 *v166;
  unint64_t v167;
  int32x4_t v168;
  int16x4_t *v169;
  int16x8_t *v170;
  unint64_t v171;
  int16x8_t v172;
  unint64_t v173;
  uint64_t v174;
  __int16 *v175;
  __int16 *v176;
  int v177;
  uint64_t v178;
  __int16 v179;
  __int16 v180;
  unint64_t v181;
  __int16 v182;
  __int16 v183;
  int16x8_t *v184;
  int16x8_t v185;
  int16x8_t v186;
  unint64_t v187;
  int16x8_t v188;
  int16x8_t v189;
  int16x8_t v190;
  int16x8_t *v191;
  int16x8_t v192;
  int16x8_t v193;
  unint64_t v194;
  int16x8_t v195;
  int16x8_t v196;
  int16x8_t v197;
  int v198;
  __int16 v201;
  uint64_t v202;
  unint64_t v203;
  unsigned int v204;
  char v205;
  int *v206;
  int v207;
  uint64_t *v208;
  unint64_t v209;
  uint64_t v210;
  unsigned int v211;
  signed int v212;
  unsigned int v213;
  BOOL v214;
  int v215;
  uint64_t i;
  int v217;
  __int16 v218;
  __int16 v219;
  int16x4_t v220;
  int8x16_t v221;
  int8x16_t v222;
  int8x16_t v223;
  const __int16 *v224;
  int16x4_t v225;
  int32x4_t v226;
  int16x4_t v227;
  int32x4_t v228;
  const __int16 *v229;
  int16x4_t v230;
  int32x4_t v231;
  const __int16 *v232;
  int16x4_t v233;
  int32x4_t v234;
  const __int16 *v235;
  int16x4_t v236;
  int32x4_t v237;
  const __int16 *v238;
  int16x4_t v239;
  int32x4_t v240;
  const __int16 *v241;
  int16x4_t v242;
  int32x4_t v243;
  uint64_t v244;
  int32x4_t v245;
  int8x16_t v246;
  int16x8_t v247;
  int32x4_t v248;
  int32x4_t v249;
  int8x16_t v250;
  int16x8_t v251;
  int32x4_t v252;
  int32x4_t v253;
  int32x4_t v254;
  int8x16_t v255;
  int16x8_t v256;
  int16x4_t *v257;
  unsigned int v258;
  uint64_t v259;
  int v260;
  unsigned int v261;
  unsigned int v262;
  int32x4_t v263;
  unint64_t v264;
  int16x4_t v265;
  int v266;
  int v267;
  unint64_t v268;
  unint64_t v269;
  unint64_t v270;
  uint64_t v271;
  uint64_t v272;
  int v273;
  BOOL v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  unint64_t v279;
  unint64_t v280;
  unint64_t v281;
  unint64_t v282;
  unint64_t v283;
  int16x4_t *v284;
  uint64_t v285;
  uint64_t v286;
  unint64_t v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  int16x4_t *v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  unint64_t v296;
  unint64_t v297;
  unint64_t v298;
  unint64_t v299;
  unint64_t v300;
  uint64_t v301;
  uint64_t v302;
  unint64_t v303;
  unint64_t v304;
  unint64_t v305;
  unint64_t v306;
  unint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  unint64_t v311;
  unint64_t v312;
  unint64_t v313;
  unint64_t v314;
  unint64_t v315;
  int16x4_t *v316;
  unsigned int v317;
  int16x4_t *v318;
  unsigned int v319;
  int v320;
  int v321;
  __int16 v322;
  __int16 v323;
  __int16 *v324;
  __int16 *v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  _QWORD *v329;
  uint64_t v330;
  uint64_t v331;
  unint64_t v332;
  uint64_t v333;
  uint64_t v334;
  int16x8_t *p_dst;
  int v336;
  unint64_t v337;
  int v338;
  unint64_t v339;
  unsigned int v340;
  unsigned int v341;
  unsigned int v342;
  unint64_t v343;
  int32x4_t v344;
  int32x4_t v345;
  unint64_t v346;
  int16x8_t *v347;
  int16x4_t *v348;
  int16x8_t v349;
  int16x8_t v350;
  int32x4_t v351;
  int32x4_t v352;
  int32x4_t v353;
  int32x4_t v354;
  int32x4_t v355;
  unint64_t v356;
  uint64_t v357;
  _WORD *v358;
  __int16 *v359;
  int v360;
  __int16 *v361;
  int v362;
  int v363;
  int v364;
  int v365;
  int v366;
  int v367;
  __int16 *v368;
  int v369;
  __int16 *v370;
  unint64_t v371;
  char *v372;
  unint64_t v373;
  int v374;
  uint64_t v375;
  int v376;
  uint64_t v377;
  uint64_t v378;
  unsigned int v379;
  char v380;
  unsigned int v381;
  uint64_t v382;
  __int16 *v383;
  int v384;
  unsigned int v385;
  unint64_t v386;
  unint64_t v387;
  unint64_t v388;
  unsigned int v389;
  unsigned int v390;
  __int16 v391;
  int16x8_t v392;
  int16x8_t v393;
  int16x8_t v394;
  int16x8_t v395;
  int16x4_t *v396;
  int16x8_t *v397;
  unint64_t v398;
  int16x8_t v399;
  int16x8_t v400;
  int16x8_t v401;
  int16x8_t v402;
  unint64_t v403;
  uint64_t v404;
  __int16 *v405;
  __int16 *v406;
  int v407;
  int v408;
  int v409;
  uint64_t v410;
  int v411;
  unsigned int v412;
  unint64_t v413;
  int v414;
  unint64_t v415;
  int16x4_t *v416;
  int16x8_t v417;
  int16x8_t v418;
  unint64_t v419;
  __int16 *v420;
  unint64_t v421;
  int v422;
  int32x4_t v423;
  int32x4_t v424;
  int32x4_t v425;
  int32x4_t v426;
  unint64_t v427;
  int16x4_t *v428;
  int32x4_t v429;
  int32x4_t v430;
  int16x8_t v431;
  int16x8_t v432;
  unint64_t v433;
  __int16 *v434;
  int v435;
  int v436;
  unsigned int v437;
  unint64_t v438;
  unint64_t v439;
  int16x8_t *v440;
  int16x8_t *v441;
  int16x8_t v442;
  unint64_t v443;
  uint64_t v444;
  __int16 *v445;
  __int16 *v446;
  __int16 v447;
  uint64_t v448;
  int v449;
  int v450;
  unint64_t v451;
  uint64_t v453;
  uint64_t v454;
  unint64_t v455;
  unint64_t v456;
  int v457;
  uint32x4_t v458;
  int16x8_t *v459;
  unint64_t v460;
  uint32x4_t v461;
  uint32x4_t v462;
  uint32x4_t v463;
  uint16x8_t v464;
  uint16x8_t v465;
  unint64_t v466;
  __int16 *v467;
  int v468;
  uint64_t v469;
  uint64_t v470;
  unint64_t v471;
  unint64_t v472;
  int v473;
  uint32x4_t v474;
  int16x8_t *v475;
  unint64_t v476;
  uint32x4_t v477;
  uint32x4_t v478;
  uint32x4_t v479;
  uint16x8_t v480;
  uint16x8_t v481;
  unint64_t v482;
  __int16 *v483;
  int v484;
  uint64_t v485;
  uint64_t v486;
  unint64_t v487;
  unint64_t v488;
  int v489;
  uint32x4_t v490;
  int16x8_t *v491;
  unint64_t v492;
  uint32x4_t v493;
  uint32x4_t v494;
  uint32x4_t v495;
  uint16x8_t v496;
  uint16x8_t v497;
  unint64_t v498;
  __int16 *v499;
  int v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  unint64_t v504;
  unint64_t v505;
  unint64_t v506;
  int32x4_t v507;
  int v508;
  void *__src;
  uint64_t v510;
  unint64_t v511;
  unint64_t v512;
  unsigned int v513;
  int32x4_t v514;
  uint64_t v515;
  uint64_t *v516;
  unsigned int v517;
  unint64_t v518;
  int16x8_t *v519;
  int v520;
  unint64_t v521;
  int v522;
  uint64_t v523;
  unint64_t v524;
  uint64_t v525;
  unint64_t v526;
  __int8 *v527;
  uint64_t v528;
  uint64_t v529;
  unint64_t v530;
  char *v531;
  unint64_t v532;
  unint64_t v533;
  _QWORD *v534;
  unint64_t v535;
  unint64_t v536;
  unint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  unsigned __int16 v541;
  unsigned __int16 v542;
  unsigned __int16 v543;
  unint64_t v544;
  int v545;
  _BYTE v546[16];
  int v547;
  uint64_t v548;
  int16x8_t __dst;
  _BYTE v550[7184];
  int32x4_t v551[32];
  uint64_t v552;
  uint64_t v553;
  int v554;
  int16x8_t v555[16];
  _BYTE v556[1252];
  _BYTE v557[226];
  unsigned __int16 v558;
  unsigned __int16 v559;
  unsigned __int16 v560;
  unsigned __int16 v561;
  unsigned __int16 v562;
  unsigned __int16 v563;
  unsigned __int16 v564;
  unsigned __int16 v565;
  unsigned __int16 v566;
  unsigned __int16 v567;
  unsigned __int16 v568;
  _QWORD v569[3];
  uint64_t v570;
  uint64_t v571;
  uint64_t v572;
  _QWORD v573[12];
  __int16 v574;
  __int16 v575;
  __int16 v576;
  __int16 v577;
  __int16 v578;
  __int16 v579;
  __int16 v580[6];
  uint32x4_t v581;
  uint64_t v582;

  v2 = MEMORY[0x24BDAC7A8](this, a2);
  v534 = v3;
  v4 = v2;
  v582 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(v2 + 64);
  v6 = *(_DWORD *)(v2 + 28);
  v7 = v6 / 8000;
  v540 = v2;
  v522 = v6 / 8000;
  if (!*(_BYTE *)(v2 + 24))
  {
    v17 = *(_QWORD *)(v2 + 72);
    if (v17)
    {
      v18 = 0;
      v19 = *(int **)(v2 + 8);
      do
      {
        v20 = v17 - v18;
        if (v17 - v18 >= 0x100)
          v20 = 256;
        *((_WORD *)v19 + 2) = (*((_WORD *)v19 + 2) + 2);
        if (v20)
        {
          v21 = &v551[0].i16[v18];
          v22 = *v19;
          v23 = v20;
          do
          {
            v22 += *((__int16 *)v19 + 2);
            *v21++ = webrtc::RandomVector::kRandomTable[v22];
            --v23;
          }
          while (v23);
          *v19 = v22;
        }
        v18 += v20;
      }
      while (v18 < v17);
    }
    goto LABEL_341;
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 16) + 120))(*(_QWORD *)(v2 + 16));
  v8 = operator new[]();
  v9 = *(_QWORD **)(*(_QWORD *)(v4 + 16) + 8);
  if (*(_QWORD **)(*(_QWORD *)(v4 + 16) + 16) == v9)
  {
LABEL_553:
    __break(1u);
    JUMPOUT(0x2085C2914);
  }
  v501 = v5;
  v10 = v4;
  v11 = 4 * v7;
  v528 = v7 << 8;
  v12 = v8;
  (*(void (**)(_QWORD))(*(_QWORD *)*v9 + 32))(*v9);
  *(_QWORD *)(v10 + 104) = 0xFFFFFFFF00000001;
  *(_BYTE *)(v10 + 112) = 0;
  *(_WORD *)(*(_QWORD *)(v10 + 8) + 4) = 1;
  *(_DWORD *)(v10 + 40) = 0;
  v13 = *(_QWORD *)(v10 + 32);
  if (v13)
  {
    v14 = *(_QWORD *)(v540 + 128);
    v15 = *(_QWORD *)(*(_QWORD *)(v540 + 48) + 16);
    if (v13 == 1)
    {
      v16 = 0;
LABEL_18:
      v27 = v13 - v16;
      v28 = (_WORD *)(v15 + 56 * v16 + 50);
      v29 = (_WORD *)(v14 + (v16 << 7));
      do
      {
        v29[17] = 0x4000;
        *v29 = 0x4000;
        v29 += 64;
        *v28 = 0;
        v28 += 28;
        --v27;
      }
      while (v27);
      goto LABEL_20;
    }
    v16 = v13 & 0xFFFFFFFFFFFFFFFELL;
    v24 = (_WORD *)(v14 + 128);
    v25 = (_WORD *)(v15 + 106);
    v26 = v13 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      *(v24 - 47) = 0x4000;
      v24[17] = 0x4000;
      *(v24 - 64) = 0x4000;
      *v24 = 0x4000;
      v24 += 128;
      *(v25 - 28) = 0;
      *v25 = 0;
      v25 += 56;
      v26 -= 2;
    }
    while (v26);
    if (v13 != v16)
      goto LABEL_18;
  }
LABEL_20:
  v30 = *(_DWORD *)(v540 + 28);
  if (v30 == 8000)
  {
    v31 = (int16x8_t *)&webrtc::DspHelper::kDownsample8kHzTbl;
    v32 = 2;
    v33 = 3;
  }
  else
  {
    if (v30 == 32000)
    {
      v31 = (int16x8_t *)&webrtc::DspHelper::kDownsample32kHzTbl;
      v32 = 8;
    }
    else
    {
      if (v30 == 16000)
      {
        v31 = (int16x8_t *)&webrtc::DspHelper::kDownsample16kHzTbl;
        v32 = 4;
        v33 = 5;
        goto LABEL_28;
      }
      v31 = (int16x8_t *)&webrtc::DspHelper::kDownsample48kHzTbl;
      v32 = 12;
    }
    v33 = 7;
  }
LABEL_28:
  v34 = 5 * v7;
  v35 = 20 * v7;
  v36 = 120 * v7;
  WebRtcSpl_DownsampleFastC(v12 + 2 * v528 - 2 * (124 * v32), (124 * v32), v557, 124, v31, v33, v32, 0);
  v37 = WebRtcSpl_MaxAbsValueW16C((int16x8_t *)v557, 0x7CuLL);
  v38 = 17 - __clz(v37 ^ (v37 >> 31));
  if (!v37)
    v38 = 16;
  if (v38 < 1)
  {
    v46 = -v38;
    v47 = (uint32x4_t)vdupq_n_s32(v46);
    *(int16x8_t *)v557 = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v557), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)v557), v47));
    *(int16x8_t *)&v557[16] = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[16]), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[16]), v47));
    *(int16x8_t *)&v557[32] = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[32]), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[32]), v47));
    *(int16x8_t *)&v557[48] = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[48]), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[48]), v47));
    *(int16x8_t *)&v557[64] = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[64]), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[64]), v47));
    *(int16x8_t *)&v557[80] = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[80]), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[80]), v47));
    *(int16x8_t *)&v557[96] = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[96]), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[96]), v47));
    *(_WORD *)&v557[224] = *(unsigned __int16 *)&v557[224] << v46;
    v558 <<= v46;
    v559 <<= v46;
    v560 <<= v46;
    v561 <<= v46;
    v562 <<= v46;
    v563 <<= v46;
    v564 <<= v46;
    v565 <<= v46;
    v566 <<= v46;
    v40 = v567 << v46;
    v41 = v568 << v46;
    *(int16x8_t *)&v557[112] = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[112]), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[112]), v47));
    *(int16x8_t *)&v557[128] = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[128]), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[128]), v47));
    *(int16x8_t *)&v557[144] = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[144]), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[144]), v47));
    *(int16x8_t *)&v557[160] = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[160]), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[160]), v47));
    *(int16x8_t *)&v557[176] = vuzp1q_s16((int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[176]), v47), (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[176]), v47));
    v42 = (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[192]), v47);
    v43 = (int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[192]), v47);
    v44 = (int16x8_t)vshlq_u32(vmovl_high_u16(*(uint16x8_t *)&v557[208]), v47);
    v45 = (int16x8_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)&v557[208]), v47);
  }
  else
  {
    v39 = vnegq_s32(vdupq_n_s32(v38));
    *(int16x8_t *)v557 = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)v557), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)v557), v39));
    *(int16x8_t *)&v557[16] = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[16]), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[16]), v39));
    *(int16x8_t *)&v557[32] = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[32]), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[32]), v39));
    *(int16x8_t *)&v557[48] = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[48]), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[48]), v39));
    *(int16x8_t *)&v557[64] = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[64]), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[64]), v39));
    *(int16x8_t *)&v557[80] = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[80]), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[80]), v39));
    *(int16x8_t *)&v557[96] = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[96]), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[96]), v39));
    *(_WORD *)&v557[224] = *(__int16 *)&v557[224] >> v38;
    v558 = (__int16)v558 >> v38;
    v559 = (__int16)v559 >> v38;
    v560 = (__int16)v560 >> v38;
    v561 = (__int16)v561 >> v38;
    v562 = (__int16)v562 >> v38;
    v563 = (__int16)v563 >> v38;
    v564 = (__int16)v564 >> v38;
    v565 = (__int16)v565 >> v38;
    v566 = (__int16)v566 >> v38;
    v40 = (__int16)v567 >> v38;
    v41 = (__int16)v568 >> v38;
    *(int16x8_t *)&v557[112] = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[112]), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[112]), v39));
    *(int16x8_t *)&v557[128] = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[128]), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[128]), v39));
    *(int16x8_t *)&v557[144] = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[144]), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[144]), v39));
    *(int16x8_t *)&v557[160] = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[160]), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[160]), v39));
    *(int16x8_t *)&v557[176] = vuzp1q_s16((int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[176]), v39), (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[176]), v39));
    v42 = (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[192]), v39);
    v43 = (int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[192]), v39);
    v44 = (int16x8_t)vshlq_s32(vmovl_high_s16(*(int16x8_t *)&v557[208]), v39);
    v45 = (int16x8_t)vshlq_s32(vmovl_s16(*(int16x4_t *)&v557[208]), v39);
  }
  *(int16x8_t *)&v557[192] = vuzp1q_s16(v43, v42);
  *(int16x8_t *)&v557[208] = vuzp1q_s16(v45, v44);
  v567 = v40;
  v48 = 20 * v7;
  v49 = (__int16)v41;
  v568 = v41;
  v50 = vmaxvq_s16(vmaxq_s16(vmaxq_s16(*(int16x8_t *)&v557[192], vmaxq_s16(*(int16x8_t *)&v557[160], *(int16x8_t *)&v557[128])), vmaxq_s16(*(int16x8_t *)&v557[208], vmaxq_s16(*(int16x8_t *)&v557[176], *(int16x8_t *)&v557[144]))));
  v51 = vminvq_s16(vminq_s16(vminq_s16(*(int16x8_t *)&v557[192], vminq_s16(*(int16x8_t *)&v557[160], *(int16x8_t *)&v557[128])), vminq_s16(*(int16x8_t *)&v557[208], vminq_s16(*(int16x8_t *)&v557[176], *(int16x8_t *)&v557[144]))));
  v52 = *(__int16 *)&v557[224];
  if (*(__int16 *)&v557[224] < v51)
    v51 = *(__int16 *)&v557[224];
  if (*(__int16 *)&v557[224] <= v50)
    v52 = v50;
  v53 = (__int16)v558;
  if ((__int16)v558 < v51)
    v51 = (__int16)v558;
  if ((__int16)v558 > v52)
    v52 = (__int16)v558;
  if ((__int16)v559 < v51)
    v51 = (__int16)v559;
  if ((__int16)v559 > v52)
    v52 = (__int16)v559;
  if ((__int16)v560 < v51)
    v51 = (__int16)v560;
  if ((__int16)v560 > v52)
    v52 = (__int16)v560;
  if ((__int16)v561 < v51)
    v51 = (__int16)v561;
  if ((__int16)v561 > v52)
    v52 = (__int16)v561;
  if ((__int16)v562 < v51)
    v51 = (__int16)v562;
  if ((__int16)v562 > v52)
    v52 = (__int16)v562;
  if ((__int16)v563 < v51)
    v51 = (__int16)v563;
  if ((__int16)v563 > v52)
    v52 = (__int16)v563;
  if ((__int16)v564 < v51)
    v51 = (__int16)v564;
  if ((__int16)v564 > v52)
    v52 = (__int16)v564;
  if ((__int16)v565 < v51)
    v51 = (__int16)v565;
  if ((__int16)v565 > v52)
    v52 = (__int16)v565;
  if ((__int16)v566 < v51)
    v51 = (__int16)v566;
  if ((__int16)v566 > v52)
    v52 = (__int16)v566;
  if ((__int16)v567 < v51)
    v51 = (__int16)v567;
  if ((__int16)v567 > v52)
    v52 = (__int16)v567;
  if ((__int16)v41 < v51)
    v51 = (__int16)v41;
  if ((__int16)v41 <= v52)
    v49 = v52;
  v54 = vmaxvq_s16(vmaxq_s16(vmaxq_s16(*(int16x8_t *)&v557[194], vmaxq_s16(*(int16x8_t *)&v557[162], vmaxq_s16(*(int16x8_t *)&v557[130], vmaxq_s16(*(int16x8_t *)&v557[98], vmaxq_s16(*(int16x8_t *)&v557[66], vmaxq_s16(*(int16x8_t *)&v557[34], *(int16x8_t *)&v557[2])))))), vmaxq_s16(*(int16x8_t *)&v557[210], vmaxq_s16(*(int16x8_t *)&v557[178], vmaxq_s16(*(int16x8_t *)&v557[146], vmaxq_s16(*(int16x8_t *)&v557[114], vmaxq_s16(*(int16x8_t *)&v557[82], vmaxq_s16(*(int16x8_t *)&v557[50], *(int16x8_t *)&v557[18]))))))));
  v55 = vminvq_s16(vminq_s16(vminq_s16(*(int16x8_t *)&v557[194], vminq_s16(*(int16x8_t *)&v557[162], vminq_s16(*(int16x8_t *)&v557[130], vminq_s16(*(int16x8_t *)&v557[98], vminq_s16(*(int16x8_t *)&v557[66], vminq_s16(*(int16x8_t *)&v557[34], *(int16x8_t *)&v557[2])))))), vminq_s16(*(int16x8_t *)&v557[210], vminq_s16(*(int16x8_t *)&v557[178], vminq_s16(*(int16x8_t *)&v557[146], vminq_s16(*(int16x8_t *)&v557[114], vminq_s16(*(int16x8_t *)&v557[82], vminq_s16(*(int16x8_t *)&v557[50], *(int16x8_t *)&v557[18]))))))));
  if ((__int16)v558 < v55)
    v55 = (__int16)v558;
  if ((__int16)v558 <= v54)
    v53 = v54;
  if (v51 < -v49 || v51 == v49)
    v57 = v51;
  else
    v57 = v49;
  if (v55 < -v53 || v55 == v53)
    v53 = v55;
  v59 = v53 * v57;
  if (v59 < 0)
    v59 = -v59;
  v60 = (60 * (unint64_t)v59) >> 31;
  v61 = 32 - __clz(v60);
  if ((_DWORD)v60)
    v62 = v61;
  else
    v62 = 0;
  WebRtcSpl_CrossCorrelationC(v551[0].i32, (uint64_t)&v557[128], (uint64_t)&v557[108], 0x3CuLL, 54, v62, -1);
  v63 = WebRtcSpl_MaxAbsValueW32C(v551, 0x36uLL);
  v65 = __clz(v63 ^ (v63 >> 31));
  v66 = (19 - v65) & ~((int)(19 - v65) >> 31);
  if (!v63)
    v66 = 18;
  v67 = v551[12].i32[0] >> v66;
  if (v551[12].i32[0] >> v66 <= -32768)
    v67 = -32768;
  if (v67 >= 0x7FFF)
    LOWORD(v67) = 0x7FFF;
  v574 = v67;
  v68 = v551[12].i32[1] >> v66;
  if (v551[12].i32[1] >> v66 <= -32768)
    v68 = -32768;
  if (v68 >= 0x7FFF)
    LOWORD(v68) = 0x7FFF;
  v575 = v68;
  v69 = v551[12].i32[2] >> v66;
  if (v551[12].i32[2] >> v66 <= -32768)
    v69 = -32768;
  if (v69 >= 0x7FFF)
    LOWORD(v69) = 0x7FFF;
  v576 = v69;
  v70 = v551[12].i32[3] >> v66;
  if (v551[12].i32[3] >> v66 <= -32768)
    v70 = -32768;
  if (v70 >= 0x7FFF)
    LOWORD(v70) = 0x7FFF;
  v577 = v70;
  v71 = v551[13].i32[0] >> v66;
  if (v551[13].i32[0] >> v66 <= -32768)
    v71 = -32768;
  if (v71 >= 0x7FFF)
    LOWORD(v71) = 0x7FFF;
  v578 = v71;
  v72 = vnegq_s32(vdupq_n_s32(v66));
  v573[0] = vqmovn_s32(vshlq_s32(v551[0], v72));
  v573[1] = vqmovn_s32(vshlq_s32(v551[1], v72));
  v573[2] = vqmovn_s32(vshlq_s32(v551[2], v72));
  v573[3] = vqmovn_s32(vshlq_s32(v551[3], v72));
  v573[4] = vqmovn_s32(vshlq_s32(v551[4], v72));
  v573[5] = vqmovn_s32(vshlq_s32(v551[5], v72));
  v573[6] = vqmovn_s32(vshlq_s32(v551[6], v72));
  v573[7] = vqmovn_s32(vshlq_s32(v551[7], v72));
  v573[8] = vqmovn_s32(vshlq_s32(v551[8], v72));
  v573[9] = vqmovn_s32(vshlq_s32(v551[9], v72));
  v573[10] = vqmovn_s32(vshlq_s32(v551[10], v72));
  v573[11] = vqmovn_s32(vshlq_s32(v551[11], v72));
  v73 = v551[13].i32[1] >> v66;
  if (v73 <= -32768)
    v73 = -32768;
  if (v73 >= 0x7FFF)
    LOWORD(v73) = 0x7FFF;
  v579 = v73;
  webrtc::DspHelper::PeakDetection((webrtc::DspHelper *)v573, (__int16 *)0x33, 3, (__int16 *)(v6 / 8000), (__int16 *)&v570, (unint64_t *)&v541, v64);
  v74 = v570 + v35;
  v570 = v74;
  v75 = v571 + v35;
  v571 += v35;
  v76 = v572 + v35;
  v572 += v35;
  v77 = v36 - 1;
  v78 = v74 - v11;
  if (v78 <= v35)
    v78 = 20 * v7;
  v79 = v74 + v11;
  if (v79 >= v77)
    v80 = v36 - 1;
  else
    v80 = v79;
  if (v78 > v80)
  {
    v78 = 0;
    v81 = 0x7FFFFFFF;
    v82 = v7;
    goto LABEL_136;
  }
  v82 = v7;
  if ((v6 + 7999) >= 0x3E7F)
  {
    v453 = v12 - 40 * v7 + 2 * v528;
    v454 = 0x7FFFFFFFFFFFFFFFLL * v78;
    v81 = 0x7FFFFFFF;
    v455 = v78;
    v78 = 0;
    while (v48 >= 0x10)
    {
      v458 = 0uLL;
      v459 = (int16x8_t *)(v453 + 16);
      v460 = v48 & 0xFFFFFFFFFFFFFFF0;
      v461 = 0uLL;
      v462 = 0uLL;
      v463 = 0uLL;
      do
      {
        v464 = (uint16x8_t)vabdq_s16(v459[-1], *(int16x8_t *)((char *)&v459[-1] + v454 * 2));
        v465 = (uint16x8_t)vabdq_s16(*v459, *(int16x8_t *)((char *)v459 + v454 * 2));
        v461 = vaddw_high_u16(v461, v464);
        v458 = vaddw_u16(v458, *(uint16x4_t *)v464.i8);
        v463 = vaddw_high_u16(v463, v465);
        v462 = vaddw_u16(v462, *(uint16x4_t *)v465.i8);
        v459 += 2;
        v460 -= 16;
      }
      while (v460);
      v457 = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)v462, (int32x4_t)v458), vaddq_s32((int32x4_t)v463, (int32x4_t)v461)));
      v456 = v48 & 0xFFFFFFFFFFFFFFF0;
      if (v48 != (v48 & 0xFFFFFFFFFFFFFFF0))
        goto LABEL_517;
LABEL_509:
      if (v457 < v81)
      {
        v78 = v455;
        v81 = v457;
      }
      ++v455;
      --v454;
      if (v455 > v80)
        goto LABEL_136;
    }
    v456 = 0;
    v457 = 0;
LABEL_517:
    v466 = -20 * v7 + v456;
    v467 = (__int16 *)(v453 + 2 * v456);
    do
    {
      v468 = *v467 - v467[v454];
      if (v468 < 0)
        v468 = v467[v454] - *v467;
      v457 += v468;
      ++v467;
      v131 = __CFADD__(v466++, 1);
    }
    while (!v131);
    goto LABEL_509;
  }
  v81 = 0;
LABEL_136:
  v569[0] = v78;
  v83 = __clz(v81 ^ (v81 >> 31));
  v84 = (17 - v83) & ~((int)(17 - v83) >> 31);
  if (!v81)
    v84 = 16;
  v85 = v75 - v11;
  if (v85 <= v35)
    v85 = 20 * v7;
  v86 = v75 + v11;
  if (v86 >= v77)
    v87 = v36 - 1;
  else
    v87 = v86;
  v529 = v12;
  if (v85 > v87)
  {
    v85 = 0;
    v88 = 0x7FFFFFFF;
    goto LABEL_147;
  }
  if ((v6 + 7999) >= 0x3E7F)
  {
    v469 = v12 - 40 * (int)v82 + 2 * v528;
    v470 = 0x7FFFFFFFFFFFFFFFLL * v85;
    v88 = 0x7FFFFFFF;
    v471 = v85;
    v85 = 0;
    while (v48 >= 0x10)
    {
      v474 = 0uLL;
      v475 = (int16x8_t *)(v469 + 16);
      v476 = v48 & 0xFFFFFFFFFFFFFFF0;
      v477 = 0uLL;
      v478 = 0uLL;
      v479 = 0uLL;
      do
      {
        v480 = (uint16x8_t)vabdq_s16(v475[-1], *(int16x8_t *)((char *)&v475[-1] + v470 * 2));
        v481 = (uint16x8_t)vabdq_s16(*v475, *(int16x8_t *)((char *)v475 + v470 * 2));
        v477 = vaddw_high_u16(v477, v480);
        v474 = vaddw_u16(v474, *(uint16x4_t *)v480.i8);
        v479 = vaddw_high_u16(v479, v481);
        v478 = vaddw_u16(v478, *(uint16x4_t *)v481.i8);
        v475 += 2;
        v476 -= 16;
      }
      while (v476);
      v473 = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)v478, (int32x4_t)v474), vaddq_s32((int32x4_t)v479, (int32x4_t)v477)));
      v472 = v48 & 0xFFFFFFFFFFFFFFF0;
      if (v48 != (v48 & 0xFFFFFFFFFFFFFFF0))
        goto LABEL_532;
LABEL_524:
      if (v473 < v88)
      {
        v85 = v471;
        v88 = v473;
      }
      ++v471;
      --v470;
      v12 = v529;
      if (v471 > v87)
        goto LABEL_147;
    }
    v472 = 0;
    v473 = 0;
LABEL_532:
    v482 = -20 * (int)v82 + v472;
    v483 = (__int16 *)(v469 + 2 * v472);
    do
    {
      v484 = *v483 - v483[v470];
      if (v484 < 0)
        v484 = v483[v470] - *v483;
      v473 += v484;
      ++v483;
      v131 = __CFADD__(v482++, 1);
    }
    while (!v131);
    goto LABEL_524;
  }
  v88 = 0;
LABEL_147:
  v569[1] = v85;
  v89 = 17 - __clz(v88 ^ (v88 >> 31));
  if (!v88)
    v89 = 16;
  if (v89 <= v84)
    v89 = v84;
  v90 = v76 - v11;
  if (v90 <= v35)
    v90 = 20 * v7;
  v91 = v76 + v11;
  if (v91 >= v77)
    v91 = v36 - 1;
  if (v90 > v91)
  {
    v90 = 0;
    v92 = 0x7FFFFFFF;
    v4 = v540;
    v93 = v12;
    goto LABEL_159;
  }
  v4 = v540;
  v93 = v12;
  if ((v6 + 7999) >= 0x3E7F)
  {
    v485 = v12 - 40 * (int)v82 + 2 * v528;
    v486 = 0x7FFFFFFFFFFFFFFFLL * v90;
    v92 = 0x7FFFFFFF;
    v487 = v90;
    v90 = 0;
    while (v48 >= 0x10)
    {
      v490 = 0uLL;
      v491 = (int16x8_t *)(v485 + 16);
      v492 = v48 & 0xFFFFFFFFFFFFFFF0;
      v493 = 0uLL;
      v494 = 0uLL;
      v495 = 0uLL;
      do
      {
        v496 = (uint16x8_t)vabdq_s16(v491[-1], *(int16x8_t *)((char *)&v491[-1] + v486 * 2));
        v497 = (uint16x8_t)vabdq_s16(*v491, *(int16x8_t *)((char *)v491 + v486 * 2));
        v493 = vaddw_high_u16(v493, v496);
        v490 = vaddw_u16(v490, *(uint16x4_t *)v496.i8);
        v495 = vaddw_high_u16(v495, v497);
        v494 = vaddw_u16(v494, *(uint16x4_t *)v497.i8);
        v491 += 2;
        v492 -= 16;
      }
      while (v492);
      v489 = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)v494, (int32x4_t)v490), vaddq_s32((int32x4_t)v495, (int32x4_t)v493)));
      v488 = v48 & 0xFFFFFFFFFFFFFFF0;
      if (v48 != (v48 & 0xFFFFFFFFFFFFFFF0))
        goto LABEL_547;
LABEL_539:
      if (v489 < v92)
      {
        v90 = v487;
        v92 = v489;
      }
      ++v487;
      --v486;
      if (v487 > v91)
        goto LABEL_159;
    }
    v488 = 0;
    v489 = 0;
LABEL_547:
    v498 = -20 * (int)v82 + v488;
    v499 = (__int16 *)(v485 + 2 * v488);
    do
    {
      v500 = *v499 - v499[v486];
      if (v500 < 0)
        v500 = v499[v486] - *v499;
      v489 += v500;
      ++v499;
      v131 = __CFADD__(v498++, 1);
    }
    while (!v131);
    goto LABEL_539;
  }
  v92 = 0;
LABEL_159:
  v569[2] = v90;
  v94 = 17 - __clz(v92 ^ (v92 >> 31));
  if (!v92)
    v94 = 16;
  if (v94 <= v89)
    v95 = v89;
  else
    v95 = v94;
  v96 = v81 >> v95;
  if (v96 <= -32768)
    v96 = -32768;
  if (v96 >= 0x7FFF)
    v97 = 0x7FFF;
  else
    v97 = v96;
  v98 = v88 >> v95;
  if (v88 >> v95 <= -32768)
    v98 = -32768;
  if (v98 >= 0x7FFF)
    v99 = 0x7FFF;
  else
    v99 = v98;
  v100 = v92 >> v95;
  if (v92 >> v95 <= -32768)
    v100 = -32768;
  if (v100 >= 0x7FFF)
    LOWORD(v100) = 0x7FFF;
  if (v97 > 0)
  {
    v101 = (v541 << 16) / (unsigned __int16)v97;
    if (v101 == 0x80000000)
      v102 = -1;
    else
      v102 = 0;
    if (v99 > 0)
      goto LABEL_183;
LABEL_194:
    if (v542)
      v106 = 0x7FFFFFFF;
    else
      v106 = 0;
    if (v106 > v101)
      v104 = 1;
    else
      v104 = v102;
    if (v106 > v101)
      v101 = v106;
    if ((__int16)v100 > 0)
      goto LABEL_189;
LABEL_203:
    if (v543)
      v105 = 0x7FFFFFFF;
    else
      v105 = 0;
    goto LABEL_206;
  }
  if (v541)
    v101 = 0x7FFFFFFF;
  else
    v101 = 0;
  v102 = 0;
  if (v99 <= 0)
    goto LABEL_194;
LABEL_183:
  v103 = (v542 << 16) / (unsigned __int16)v99;
  if (v103 > v101)
    v104 = 1;
  else
    v104 = v102;
  if (v103 > v101)
    v101 = v103;
  if ((__int16)v100 <= 0)
    goto LABEL_203;
LABEL_189:
  v105 = (v543 << 16) / (unsigned __int16)v100;
LABEL_206:
  v154 = v105 <= v101;
  v107 = 2;
  if (v154)
    v107 = v104;
  v108 = v107;
  v109 = v569[v108];
  v110 = *(uint64_t *)((char *)&v570 + v108 * 8);
  if (v109 <= v110)
    v111 = *(uint64_t *)((char *)&v570 + v108 * 8);
  else
    v111 = v569[v108];
  *(_QWORD *)(v4 + 72) = v111;
  v112 = v109 + 10;
  if (v109 + 10 >= v36)
    v112 = 120 * v7;
  if (v112 <= 60 * v7)
    v112 = 60 * v7;
  v532 = v112;
  v526 = v109;
  if (((int)v109 - (int)v110) << 16 > -65536)
    v113 = (__int16)(v109 - v110);
  else
    v113 = -(__int16)(v109 - v110);
  if (*(_QWORD *)(v4 + 32))
  {
    v114 = 160 * v7;
    v115 = (v113 + 1);
    if (v110 >= v109)
      v116 = v109;
    else
      v116 = v110;
    v117 = v528 - v532 - v116;
    v519 = (int16x8_t *)(v93 + 2 * (v117 - v115));
    v521 = v116;
    v518 = v116 + v532 + v115 - 1;
    v118 = 32 - __clz(v532 ^ ((int)v532 >> 31));
    if (!(_DWORD)v532)
      v118 = 31;
    v517 = v118;
    v119 = v93 + 2 * (v528 - v532);
    v120 = v110 + v109;
    v121 = (v110 + v526) >> 1;
    v122 = v526 << (v526 < 0x28);
    v123 = v122 + 30;
    v505 = v122 - 226;
    v124 = 2 * v528;
    v125 = v93 + 2 * v528;
    v516 = (uint64_t *)(v125 - 12);
    v126 = v125 - 268;
    v515 = v125 - 256;
    v127 = v526 == v110;
    if (v526 <= v110)
      v128 = v120 + 1;
    else
      v128 = v120 - 1;
    v129 = v128 >> 1;
    v513 = v6 + 7999;
    if (v127)
      v130 = v526;
    else
      v130 = v121;
    if (v127)
      v129 = v526;
    v511 = v129;
    v512 = v130;
    v131 = (unint64_t)v555 >= v125 || v126 >= (unint64_t)v556;
    v510 = v93 + 2 * v117;
    __src = (void *)(v93 + 2 * (v528 - v114));
    v132 = vdupq_n_s32(0x7FFF7FFu);
    v506 = v123;
    v503 = 2 * v123;
    v504 = v93 + v124 - 2 * v526;
    v535 = 32 * v34;
    v133 = v114 | 6;
    v134 = !v131;
    v508 = v134;
    v502 = v93 + v124 - 2 * v526 + 16;
    v507 = v132;
    v538 = *(_QWORD *)(v4 + 128);
    v135 = v93;
    v136 = WebRtcSpl_MaxAbsValueW16C(v519, v518);
    v137 = 32 - __clz(v136 * v136);
    if (!v136)
      v137 = 31;
    v138 = v137 + v517;
    if (v138 <= 31)
      LOBYTE(v138) = 31;
    v139 = v138 - 31;
    WebRtcSpl_CrossCorrelationC((int *)v557, v119, v510, v532, v115, v138 - 31, -1);
    v140 = 0;
    v141 = 0;
    v142 = 0x80000000;
    do
    {
      if (*(_DWORD *)&v557[4 * v141] > v142)
      {
        v140 = v141;
        v142 = *(_DWORD *)&v557[4 * v141];
      }
      ++v141;
    }
    while (v115 != v141);
    WebRtcSpl_DotProductWithScale(v119, v119, v532, v139);
    v144 = v143;
    WebRtcSpl_DotProductWithScale(v135 + 2 * (v528 - v532 - (v521 + v140)), v135 + 2 * (v528 - v532 - (v521 + v140)), v532, v139);
    if (v144 >= 1 && v145 >= 1)
    {
      v146 = __clz(v144);
      v147 = (17 - v146) & ~((int)(17 - v146) >> 31);
      v148 = __clz(v145);
      WebRtcSpl_SqrtFloor((v144 >> (((((17 - v148) & ~((int)(17 - v148) >> 31)) + v147) & 1) + v147))* (v145 >> ((17 - v148) & ~((int)(17 - v148) >> 31))));
      v135 = v529;
    }
    v523 = *(_QWORD *)(v540 + 64);
    v525 = *(_QWORD *)(v540 + 72);
    v149 = v523 + v525;
    v150 = (const __int16 *)(v135 + 2 * (v528 - (v523 + v525)));
    WebRtcSpl_DotProductWithScale((uint64_t)v150, (uint64_t)v150, v523 + v525, v139);
    v152 = v151;
    WebRtcSpl_DotProductWithScale((uint64_t)&v150[-v526], (uint64_t)&v150[-v526], v523 + v525, v139);
    v154 = v152 / 4 >= v153 || v152 <= v153 / 4;
    if (v154)
    {
      *(_QWORD *)(v538 + 64) = 0;
      *(_QWORD *)(v538 + 72) = 0;
      webrtc::AudioVector::PushBack((_QWORD *)(v538 + 40), v150, v149);
      v155 = (_QWORD *)v540;
      webrtc::AudioVector::CopyTo((webrtc::AudioVector *)(v538 + 40), (webrtc::AudioVector *)(v538 + 80));
      goto LABEL_276;
    }
    v156 = __clz(v153 ^ (v153 >> 31));
    v157 = (17 - v156) & ~((int)(17 - v156) >> 31);
    if (v153)
      v158 = v157;
    else
      v158 = 16;
    v159 = v153 >> v158;
    if ((unsigned __int16)(v153 >> v158))
    {
      if (v158 >= 0xE)
        v160 = v152 >> (v158 - 13);
      else
        v160 = v152 << (13 - v158);
      v161 = v160 / (__int16)v159;
    }
    else
    {
      v161 = 0x7FFFFFFF;
    }
    v155 = (_QWORD *)v540;
    v162 = WebRtcSpl_SqrtFloor(v161 << 13);
    *(_QWORD *)(v538 + 64) = 0;
    *(_QWORD *)(v538 + 72) = 0;
    webrtc::AudioVector::PushBack((_QWORD *)(v538 + 40), v150, v149);
    v163 = (_QWORD *)(v538 + 80);
    *(_QWORD *)(v538 + 104) = 0;
    *(_QWORD *)(v538 + 112) = 0;
    if (v149)
    {
      v164 = (*(uint64_t (**)(uint64_t))(*v163 + 144))(v538 + 80);
      webrtc::AudioVector::InsertZerosByPushBack((webrtc::AudioVector *)(v538 + 80), v149, v164);
    }
    v165 = (const __int16 *)operator new[]();
    v166 = v165;
    if (v149)
    {
      if (v149 >= 0x10)
      {
        v167 = v149 & 0xFFFFFFFFFFFFFFF0;
        v168 = vdupq_n_s32(v162);
        v169 = (int16x4_t *)(v502 - 2 * v149);
        v170 = (int16x8_t *)(v165 + 8);
        v171 = v149 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          v172 = vrshrn_high_n_s32(vrshrn_n_s32(vmulq_s32(v168, vmovl_s16(*v169)), 0xDuLL), vmulq_s32(v168, vmovl_high_s16(*(int16x8_t *)v169->i8)), 0xDuLL);
          v170[-1] = vrshrn_high_n_s32(vrshrn_n_s32(vmulq_s32(v168, vmovl_s16(v169[-2])), 0xDuLL), vmulq_s32(v168, vmovl_high_s16(*(int16x8_t *)v169[-2].i8)), 0xDuLL);
          *v170 = v172;
          v169 += 4;
          v170 += 2;
          v171 -= 16;
        }
        while (v171);
        if (v149 == v167)
          goto LABEL_275;
      }
      else
      {
        v167 = 0;
      }
      v173 = v523 + v525 - v167;
      v174 = 2 * v167;
      v175 = (__int16 *)&v165[v167];
      v176 = (__int16 *)(v504 + v174 - 2 * v149);
      do
      {
        v177 = *v176++;
        *v175++ = (v162 * v177 + 4096) >> 13;
        --v173;
      }
      while (v173);
    }
LABEL_275:
    webrtc::AudioVector::OverwriteAt(v163, v165, v149, 0);
    MEMORY[0x20BD0ADD4](v166, 0x1000C80BDFB0063);
LABEL_276:
    v155[10] = v526;
    v155[11] = v512;
    v155[12] = v511;
    v178 = operator new[]();
    bzero((void *)v178, (320 * v82) | 0xC);
    memcpy((void *)(v178 + 12), __src, 320 * v82);
    if (v513 >= 0x3E7F)
    {
      v184 = (int16x8_t *)(v178 + 28);
      v185.i64[0] = 0x8000800080008000;
      v185.i64[1] = 0x8000800080008000;
      v186.i64[0] = 0x8000800080008000;
      v186.i64[1] = 0x8000800080008000;
      v187 = v535;
      v188.i64[0] = 0x8000800080008000;
      v188.i64[1] = 0x8000800080008000;
      v189.i64[0] = 0x8000800080008000;
      v189.i64[1] = 0x8000800080008000;
      do
      {
        v190 = v184[-1];
        v185 = vminq_s16(v190, v185);
        v189 = vminq_s16(*v184, v189);
        v186 = vmaxq_s16(v190, v186);
        v188 = vmaxq_s16(*v184, v188);
        v184 += 2;
        v187 -= 16;
      }
      while (v187);
      v180 = vminvq_s16(vminq_s16(v185, v189));
      v179 = vmaxvq_s16(vmaxq_s16(v186, v188));
      if (v133 >= 0x10)
        goto LABEL_283;
    }
    else
    {
      v179 = 0x8000;
      v180 = 0x7FFF;
      if (v133 >= 0x10)
      {
LABEL_283:
        v191 = (int16x8_t *)(v178 + 16);
        v192.i64[0] = 0x8000800080008000;
        v192.i64[1] = 0x8000800080008000;
        v193.i64[0] = 0x8000800080008000;
        v193.i64[1] = 0x8000800080008000;
        v194 = v535;
        v195.i64[0] = 0x8000800080008000;
        v195.i64[1] = 0x8000800080008000;
        v196.i64[0] = 0x8000800080008000;
        v196.i64[1] = 0x8000800080008000;
        do
        {
          v197 = v191[-1];
          v192 = vminq_s16(v197, v192);
          v196 = vminq_s16(*v191, v196);
          v193 = vmaxq_s16(v197, v193);
          v195 = vmaxq_s16(*v191, v195);
          v191 += 2;
          v194 -= 16;
        }
        while (v194);
        v182 = vminvq_s16(vminq_s16(v192, v196));
        v183 = vmaxvq_s16(vmaxq_s16(v193, v195));
        v181 = v535;
        goto LABEL_286;
      }
    }
    v181 = 0;
    v182 = 0x7FFF;
    v183 = 0x8000;
    while (1)
    {
LABEL_286:
      v198 = *(__int16 *)(v178 + 2 * v181);
      if (v198 < v182)
        v182 = *(_WORD *)(v178 + 2 * v181);
      if (v198 > v183)
        v183 = *(_WORD *)(v178 + 2 * v181);
      if (v133 == ++v181)
      {
        if (v180 >= -v179 && v180 != v179)
          v180 = v179;
        if (v182 < -v183 || v182 == v183)
          v201 = v182;
        else
          v201 = v183;
        LODWORD(v202) = v201 * v180;
        if ((int)v202 >= 0)
          v202 = v202;
        else
          v202 = -(int)v202;
        v203 = (v535 * v202) >> 31;
        v204 = 32 - __clz(v203 ^ ((int)v203 >> 31));
        if ((_DWORD)v203)
          v205 = v204;
        else
          v205 = 0;
        WebRtcSpl_CrossCorrelationC(v581.i32, v178 + 12, v178 + 12, v535, 7, v205, -1);
        MEMORY[0x20BD0ADD4](v178, 0x1000C80BDFB0063);
        if (v581.i32[0] >= 1 && WebRtcSpl_LevinsonDurbin(&v581, (_WORD *)(v538 + 2), v580, 6uLL) != 1)
        {
          *(_WORD *)(v538 + 2) = 4096;
          *(_QWORD *)(v538 + 4) = 0;
          *(_DWORD *)(v538 + 12) = 0;
        }
        if (v506 > 0x100)
        {
          memcpy(v551, webrtc::RandomVector::kRandomTable, sizeof(v551));
          v206 = (int *)v155[1];
          *((_WORD *)v206 + 2) = (*((_WORD *)v206 + 2) + 2);
          if (v505)
          {
            v207 = *v206;
            v208 = &v552;
            v209 = v505;
            do
            {
              v207 += *((__int16 *)v206 + 2);
              *(_WORD *)v208 = webrtc::RandomVector::kRandomTable[v207];
              v208 = (uint64_t *)((char *)v208 + 2);
              --v209;
            }
            while (v209);
            *v206 = v207;
          }
        }
        else
        {
          memcpy(v551, webrtc::RandomVector::kRandomTable, v503);
        }
        v210 = *v516;
        *(_DWORD *)(v538 + 24) = *((_DWORD *)v516 + 2);
        *(_QWORD *)(v538 + 16) = v210;
        v553 = *(_QWORD *)v126;
        v554 = *(_DWORD *)(v126 + 8);
        v211 = *(unsigned __int16 *)(v515 - 2);
        v212 = *(unsigned __int16 *)(v515 - 6);
        v213 = *(unsigned __int16 *)(v515 - 10);
        v214 = (unint64_t)v555 >= v538 + 16 || v538 + 2 >= (unint64_t)v556;
        v215 = v508;
        if (!v214)
          v215 = 1;
        if (v215 == 1)
        {
          for (i = 12; i != 268; i += 2)
          {
            v217 = *(__int16 *)(v126 + i);
            v218 = *(_WORD *)(v126 + i - 4);
            v219 = *(_WORD *)(v126 + i - 8);
            v220.i16[0] = v211;
            v220.i16[1] = v218;
            v220.i16[2] = v212;
            v220.i16[3] = v219;
            v212 = vaddvq_s32(vmull_s16(v220, *(int16x4_t *)(v538 + 4)))
                 + v217 * *(__int16 *)(v538 + 2)
                 + *(__int16 *)(v126 + i - 12) * *(__int16 *)(v538 + 14)
                 + (__int16)v213 * *(__int16 *)(v538 + 12);
            if (v212 <= -134217728)
              v212 = -134217728;
            if (v212 >= 134215679)
              v212 = 134215679;
            *(_WORD *)((char *)&v553 + i) = (v212 + 2048) >> 12;
            LOWORD(v211) = v217;
            LOWORD(v213) = v219;
            LOWORD(v212) = v218;
          }
        }
        else
        {
          v221 = (int8x16_t)vdupq_n_s16(v213);
          v222 = (int8x16_t)vdupq_n_s16(v212);
          v223 = (int8x16_t)vdupq_n_s16(v211);
          v224 = (const __int16 *)(v538 + 2);
          v225 = vld1_dup_s16(v224++);
          v226 = vmovl_s16(v225);
          v227 = vld1_dup_s16(v224);
          v228 = vmovl_s16(v227);
          v229 = (const __int16 *)(v538 + 6);
          v230 = vld1_dup_s16(v229);
          v231 = vmovl_s16(v230);
          v232 = (const __int16 *)(v538 + 8);
          v233 = vld1_dup_s16(v232);
          v234 = vmovl_s16(v233);
          v235 = (const __int16 *)(v538 + 10);
          v236 = vld1_dup_s16(v235);
          v237 = vmovl_s16(v236);
          v238 = (const __int16 *)(v538 + 12);
          v239 = vld1_dup_s16(v238);
          v240 = vmovl_s16(v239);
          v241 = (const __int16 *)(v538 + 14);
          v242 = vld1_dup_s16(v241);
          v243 = vmovl_s16(v242);
          v244 = 12;
          v245.i64[0] = 0xF8000000F8000000;
          v245.i64[1] = 0xF8000000F8000000;
          do
          {
            v246 = *(int8x16_t *)(v126 + v244);
            v247 = (int16x8_t)vextq_s8(v223, v246, 0xEuLL);
            v248 = vmovl_s16(*(int16x4_t *)v247.i8);
            v249 = vmlaq_s32(vmulq_s32(vmovl_high_s16((int16x8_t)v246), v226), vmovl_high_s16(v247), v228);
            v250 = *(int8x16_t *)(v126 + v244 - 4);
            v251 = (int16x8_t)vextq_s8(v222, v250, 0xEuLL);
            v252 = vmlaq_s32(vmlaq_s32(vmulq_s32(vmovl_s16(*(int16x4_t *)v246.i8), v226), v248, v228), vmovl_s16(*(int16x4_t *)v250.i8), v231);
            v253 = vmovl_s16(*(int16x4_t *)v251.i8);
            v254 = vmlaq_s32(vmlaq_s32(v249, vmovl_high_s16((int16x8_t)v250), v231), vmovl_high_s16(v251), v234);
            v255 = *(int8x16_t *)(v126 + v244 - 8);
            v256 = (int16x8_t)vextq_s8(v221, v255, 0xEuLL);
            *(int16x8_t *)((char *)&v553 + v244) = vrshrn_high_n_s32(vrshrn_n_s32(vminq_s32(vmaxq_s32(vmlaq_s32(vmlaq_s32(vmlaq_s32(vmlaq_s32(v252, v253, v234), vmovl_s16(*(int16x4_t *)v255.i8), v237), vmovl_s16(*(int16x4_t *)v256.i8), v240), vmovl_s16(*(int16x4_t *)(v126 + v244 - 12)), v243), v245), v507), 0xCuLL), vminq_s32(vmaxq_s32(vmlaq_s32(
                                                           vmlaq_s32(vmlaq_s32(v254, vmovl_high_s16((int16x8_t)v255), v237), vmovl_high_s16(v256), v240), vmovl_high_s16(*(int16x8_t *)(v126 + v244 - 12)), v243), v245), v507), 0xCuLL);
            v244 += 16;
            v221 = v255;
            v222 = v250;
            v223 = v246;
          }
          while (v244 != 268);
        }
        v257 = (int16x4_t *)v555;
        v258 = WebRtcSpl_MaxAbsValueW16C(v555, 0x80uLL);
        v259 = 0;
        v260 = (64 - 2 * (unsigned __int16)__clz(v258)) & 0xFFFE;
        if (v260 <= 24)
          v260 = 24;
        v261 = v260 - 24;
        if (v258 == 0x7FFF)
          v262 = 8;
        else
          v262 = v261;
        v263 = vdupq_n_s32(v262);
        v264 = -4;
        do
        {
          v265 = *v257++;
          v259 += vaddlvq_u32(vshlq_u32((uint32x4_t)vmull_s16(v265, v265), (uint32x4_t)vnegq_s32(v263)));
          v264 += 4;
        }
        while (v264 < 0x7C);
        __asm { BR              X11 }
      }
    }
  }
  MEMORY[0x20BD0ADD4](v93, 0x1000C80BDFB0063);
  *(_BYTE *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 120) = 0;
  v5 = v501;
LABEL_341:
  v266 = *(_DWORD *)(v4 + 104) + *(_DWORD *)(v4 + 108);
  *(_DWORD *)(v4 + 108) = v266;
  if (v266 < 1)
  {
    v267 = 1;
  }
  else
  {
    if (v266 == 1)
      goto LABEL_346;
    v267 = -1;
  }
  *(_DWORD *)(v4 + 104) = v267;
LABEL_346:
  if (*(_QWORD *)(v4 + 32))
  {
    v268 = 0;
    v527 = &__dst.i8[2 * v5];
    v269 = *(_QWORD *)(v4 + 8 * v266 + 80);
    v270 = v269 + *(_QWORD *)(v4 + 64);
    v530 = *(_QWORD *)(v4 + 72) - v269;
    v531 = (char *)&v544 + 2 * v269;
    v533 = v269;
    v520 = (_DWORD)v269 << 10;
    v271 = 2 * v5;
    v524 = -2 * v5;
    v537 = v269 & 0xFFFFFFFFFFFFFFF0;
    v514 = vdupq_n_s32(0x100020u);
    v536 = v270;
    while (1)
    {
      v272 = *(_QWORD *)(v4 + 128);
      v273 = *(_DWORD *)(v4 + 108);
      v539 = v272;
      if (v273 == 2)
        break;
      if (v273 == 1)
      {
        v284 = (int16x4_t *)operator new[]();
        if (v270)
        {
          v301 = v539 + (v268 << 7);
          v302 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v301 + 40) + 144))(v301 + 40);
          if (v302 - v530 >= v270)
            v303 = v270;
          else
            v303 = v302 - v530;
          v304 = *(_QWORD *)(v301 + 56);
          v305 = (*(_QWORD *)(v301 + 64) + v530) % v304;
          v306 = v304 - v305;
          if (v304 - v305 >= v303)
            v307 = v303;
          else
            v307 = v304 - v305;
          memcpy(v284, (const void *)(*(_QWORD *)(v301 + 48) + 2 * v305), 2 * v307);
          if (v303 > v306)
            memcpy((char *)v284 + 2 * v307, *(const void **)(v301 + 48), 2 * (v303 - v307));
          v292 = (int16x4_t *)operator new[]();
          v309 = *(_QWORD *)(v301 + 80);
          v308 = v301 + 80;
          v310 = (*(uint64_t (**)(uint64_t))(v309 + 144))(v308);
          if (v310 - v530 >= v536)
            v311 = v536;
          else
            v311 = v310 - v530;
          v312 = *(_QWORD *)(v308 + 16);
          v313 = (*(_QWORD *)(v308 + 24) + v530) % v312;
          v314 = v312 - v313;
          if (v312 - v313 >= v311)
            v315 = v311;
          else
            v315 = v312 - v313;
          memcpy(v292, (const void *)(*(_QWORD *)(v308 + 8) + 2 * v313), 2 * v315);
          if (v311 > v314)
            memcpy((char *)v292 + 2 * v315, *(const void **)(v308 + 8), 2 * (v311 - v315));
          v270 = v536;
        }
        else
        {
          v292 = (int16x4_t *)operator new[]();
        }
        v316 = v284;
        v317 = 3;
        v318 = v292;
        v319 = 2;
LABEL_402:
        WebRtcSpl_ScaleAndAddVectorsWithRoundC(v316, v317, v318, 1u, v319, &__dst, v270);
        MEMORY[0x20BD0ADD4](v292, 0x1000C80BDFB0063);
        MEMORY[0x20BD0ADD4](v284, 0x1000C80BDFB0063);
        goto LABEL_403;
      }
      if (v273)
        v274 = 1;
      else
        v274 = v270 == 0;
      if (!v274)
      {
        v275 = v272 + (v268 << 7);
        v277 = *(_QWORD *)(v275 + 40);
        v276 = v275 + 40;
        v278 = (*(uint64_t (**)(uint64_t))(v277 + 144))(v276);
        v279 = v278 - v530 >= v270 ? v270 : v278 - v530;
        v280 = *(_QWORD *)(v276 + 16);
        v281 = (*(_QWORD *)(v276 + 24) + v530) % v280;
        v282 = v280 - v281;
        v283 = v280 - v281 >= v279 ? v279 : v280 - v281;
        memcpy(&__dst, (const void *)(*(_QWORD *)(v276 + 8) + 2 * v281), 2 * v283);
        v272 = v539;
        if (v279 > v282)
        {
          memcpy((char *)&__dst + 2 * v283, *(const void **)(v276 + 8), 2 * (v279 - v283));
LABEL_403:
          v272 = v539;
        }
      }
      v320 = *(_DWORD *)(v540 + 28);
      switch(v320)
      {
        case 8000:
          v321 = 5461;
          v322 = -5461;
          v323 = 27307;
          break;
        case 32000:
          v321 = 1560;
          v322 = -1560;
          v323 = 31208;
          break;
        case 16000:
          v321 = 2979;
          v322 = -2979;
          v323 = 29789;
          break;
        default:
          v321 = 1057;
          v322 = -1057;
          v323 = 31711;
          break;
      }
      v324 = (__int16 *)(v272 + (v268 << 7));
      v325 = v324 + 17;
      if (*v324 >= 820 && v324[17] > 0x2000)
      {
        v326 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v540 + 16) + 120))(*(_QWORD *)(v540 + 16));
        v325 = v324 + 17;
        v272 = v539;
        v327 = *(_QWORD *)(v540 + 64);
        if (v327)
        {
          v328 = *(_QWORD *)(*(_QWORD *)(v540 + 16) + 8);
          if (v268 >= (*(_QWORD *)(*(_QWORD *)(v540 + 16) + 16) - v328) >> 3)
            goto LABEL_553;
          v329 = *(_QWORD **)(v328 + 8 * v268);
          v330 = v329[3];
          v331 = -v327;
          v332 = v329[2];
          v333 = v329[1] + 2 * v326 + 2 * v330;
          v334 = v326 + v330;
          p_dst = &__dst;
          v336 = v321;
          do
          {
            if (v334 + v331 >= v332)
              v337 = v332;
            else
              v337 = 0;
            v338 = p_dst->i16[0];
            p_dst = (int16x8_t *)((char *)p_dst + 2);
            *(_WORD *)(v333 - 2 * v337 + 2 * v331) = (((v338 * *v324) >> 14) * (__int16)v336
                                                                  + v323 * *(__int16 *)(v333 - 2 * v337 + 2 * v331)
                                                                  + 0x4000) >> 15;
            v323 += v322;
            v336 += v321;
            v131 = __CFADD__(v331++, 1);
          }
          while (!v131);
        }
      }
      v339 = *((_QWORD *)v324 + 2);
      v545 = *((_DWORD *)v324 + 6);
      v544 = v339;
      v340 = 1 << (v324[15] - 1);
      if (v324[15] <= 0)
        v340 = 0;
      v4 = v540;
      v270 = v536;
      if (v533)
      {
        v341 = (unsigned __int16)v324[15];
        v342 = *(__int16 *)(v272 + (v268 << 7) + 28);
        if (v533 < 0x10)
        {
          v343 = 0;
          goto LABEL_429;
        }
        v344 = vdupq_n_s32(v340);
        v345 = vdupq_n_s32(v341);
        v346 = v537;
        v347 = (int16x8_t *)&v557[16];
        v348 = (int16x4_t *)&v551[1];
        do
        {
          v349 = *(int16x8_t *)v348[-2].i8;
          v350 = vdupq_n_s16(v342);
          v351 = vmlal_s16(v344, *(int16x4_t *)v350.i8, *(int16x4_t *)v349.i8);
          v352 = vmlal_high_s16(v344, v350, v349);
          v353 = vmlal_s16(v344, *(int16x4_t *)v350.i8, *v348);
          v354 = vmlal_high_s16(v344, v350, *(int16x8_t *)v348->i8);
          v355 = vnegq_s32(v345);
          v347[-1] = vuzp1q_s16((int16x8_t)vshlq_s32(v351, v355), (int16x8_t)vshlq_s32(v352, v355));
          *v347 = vuzp1q_s16((int16x8_t)vshlq_s32(v353, v355), (int16x8_t)vshlq_s32(v354, v355));
          v348 += 4;
          v347 += 2;
          v346 -= 16;
        }
        while (v346);
        v343 = v537;
        if (v533 != v537)
        {
LABEL_429:
          v356 = v533 - v343;
          v357 = v343;
          v358 = &v557[2 * v343];
          v359 = &v551[0].i16[v357];
          do
          {
            v360 = *v359++;
            *v358++ = (int)(v340 + v360 * v342) >> v341;
            --v356;
          }
          while (v356);
        }
        v361 = (__int16 *)(v272 + (v268 << 7));
        v362 = v361[1];
        v363 = v361[7];
        v364 = v361[6];
        v365 = v361[5];
        v366 = v361[4];
        v367 = v361[3];
        v368 = (__int16 *)v557;
        v369 = v361[2];
        v370 = (__int16 *)&v544 + 3;
        v371 = v533;
        v372 = (char *)&v544 + 6;
        LOWORD(v373) = HIWORD(v545);
        do
        {
          v374 = *((__int16 *)v372 + 1);
          v372 += 2;
          v375 = *(v370 - 3) * (uint64_t)v363
               + *(v370 - 2) * (uint64_t)v364
               + *(v370 - 1) * (uint64_t)v365
               + *v370 * (uint64_t)v366
               + v374 * (uint64_t)v367
               + (__int16)v373 * (uint64_t)v369;
          v376 = *v368++;
          v377 = v376 * (uint64_t)v362 - v375;
          if (v377 <= -134217728)
            v377 = -134217728;
          if (v377 >= 134215679)
            v377 = 134215679;
          v373 = (unint64_t)(v377 + 2048) >> 12;
          v370[3] = v373;
          v370 = (__int16 *)v372;
          --v371;
        }
        while (v371);
      }
      v378 = *(_QWORD *)v531;
      *((_DWORD *)v324 + 6) = *((_DWORD *)v531 + 2);
      *((_QWORD *)v324 + 2) = v378;
      LODWORD(v378) = *(_DWORD *)(v540 + 72);
      v379 = 32 - __clz(v378 ^ ((int)v378 >> 31));
      if ((_DWORD)v378)
        v380 = v379;
      else
        v380 = 31;
      v381 = 0x100u >> (v380 - 5);
      if (*(_BYTE *)(v540 + 112))
        v381 = 0;
      v382 = v272 + (v268 << 7);
      v384 = *(__int16 *)(v382 + 32);
      v383 = (__int16 *)(v382 + 32);
      v385 = (unsigned __int16)*v325;
      LODWORD(v386) = (*v325 - v384) >> (13 - v380);
      v387 = (int)v386;
      if (v533 >= (int)v386)
        v386 = (int)v386;
      else
        v386 = v533;
      if (v386)
      {
        v388 = 0;
        v389 = 0x4000 - v385;
        if (v386 < 0x10)
          goto LABEL_451;
        if (v524 < 0x20)
          goto LABEL_451;
        v388 = v386 & 0xFFFFFFFFFFFFFFF0;
        v390 = v389 + v381 * (v386 & 0xFFFFFFF0);
        v391 = v385 - v381 * (v386 & 0xFFF0);
        v392 = vdupq_n_s16(8 * v381);
        v393 = vmlaq_s16(vdupq_n_s16(v389), vdupq_n_s16(v381), (int16x8_t)xmmword_208F08E10);
        v394 = vmlaq_s16(vdupq_n_s16(v385), vdupq_n_s16(-v381), (int16x8_t)xmmword_208F08E10);
        v395 = vdupq_n_s16(-8 * v381);
        v396 = (int16x4_t *)&v547;
        v397 = (int16x8_t *)v550;
        v398 = v386 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          v399 = vaddq_s16(v393, v392);
          v400 = vaddq_s16(v394, v395);
          v401 = vrshrn_high_n_s32(vrshrn_n_s32(vmlal_s16(vmull_s16(*(int16x4_t *)&v397[-1].i8[v271], *(int16x4_t *)v394.i8), v396[-2], *(int16x4_t *)v393.i8), 0xEuLL), vmlal_high_s16(vmull_high_s16(*(int16x8_t *)((char *)&v397[-1] + v271), v394), *(int16x8_t *)v396[-2].i8, v393), 0xEuLL);
          v402 = vrshrn_high_n_s32(vrshrn_n_s32(vmlal_s16(vmull_s16(*(int16x4_t *)&v397->i8[v271], *(int16x4_t *)v400.i8), *v396, *(int16x4_t *)v399.i8), 0xEuLL), vmlal_high_s16(vmull_high_s16(*(int16x8_t *)((char *)v397 + v271), v400), *(int16x8_t *)v396->i8, v399), 0xEuLL);
          v397[-1] = v401;
          *v397 = v402;
          v393 = vaddq_s16(v399, v392);
          v394 = vaddq_s16(v400, v395);
          v397 += 2;
          v396 += 4;
          v398 -= 16;
        }
        while (v398);
        v389 = v390;
        LOWORD(v385) = v391;
        if (v386 != v388)
        {
LABEL_451:
          v403 = v386 - v388;
          v404 = 2 * v388;
          v405 = &__dst.i16[v388];
          v406 = (__int16 *)&v546[v404];
          v391 = v385;
          do
          {
            v407 = *v406++;
            *v405 = (v407 * (__int16)v389 + v405[(unint64_t)v271 / 2] * v391 + 0x2000) >> 14;
            ++v405;
            v391 -= v381;
            v389 += v381;
            --v403;
          }
          while (v403);
        }
        *v325 = v391;
        if (v533 <= v387)
        {
LABEL_454:
          v408 = *(_DWORD *)(v540 + 40);
          if (v408 == 3)
            goto LABEL_461;
          goto LABEL_455;
        }
      }
      else
      {
        v391 = *v325;
        *v325 = v385;
        if (v533 <= v387)
          goto LABEL_454;
      }
      if (v381)
      {
        v391 = *v383;
        *v325 = *v383;
      }
      WebRtcSpl_ScaleAndAddVectorsWithRoundC((int16x4_t *)&v527[2 * v386], v391, (int16x4_t *)&v546[2 * v386], (__int16)(0x4000 - v391), 0xEu, (int16x8_t *)((char *)&__dst + 2 * v386), v533 - v386);
      v272 = v539;
      v408 = *(_DWORD *)(v540 + 40);
      if (v408 == 3)
      {
LABEL_461:
        v409 = 1049;
        goto LABEL_462;
      }
LABEL_455:
      if (v408 == 7)
      {
        v409 = 2097;
LABEL_462:
        v410 = v272 + (v268 << 7);
        v411 = v409 / v522;
        if (*(_DWORD *)(v410 + 124) > v411)
          v411 = *(_DWORD *)(v410 + 124);
        *(_DWORD *)(v410 + 124) = v411;
        goto LABEL_465;
      }
      if (!v408 && *(_BYTE *)(v272 + (v268 << 7) + 120))
        goto LABEL_490;
LABEL_465:
      if (!v533)
      {
        if (*(_BYTE *)(v540 + 112))
          goto LABEL_490;
        v414 = *(_DWORD *)(v272 + (v268 << 7) + 124);
        goto LABEL_486;
      }
      v412 = *v324;
      if (v533 < 0x10)
      {
        v413 = 0;
LABEL_476:
        v419 = v533 - v413;
        v420 = &__dst.i16[v413];
        do
        {
          *v420 = (*v420 * v412 + 0x2000) >> 14;
          ++v420;
          --v419;
        }
        while (v419);
        goto LABEL_478;
      }
      v415 = v537;
      v416 = (int16x4_t *)v550;
      do
      {
        v417 = vdupq_n_s16(v412);
        v418 = vrshrn_high_n_s32(vrshrn_n_s32(vmull_s16(*(int16x4_t *)v417.i8, *v416), 0xEuLL), vmull_high_s16(v417, *(int16x8_t *)v416->i8), 0xEuLL);
        *(int16x8_t *)v416[-2].i8 = vrshrn_high_n_s32(vrshrn_n_s32(vmull_s16(*(int16x4_t *)v417.i8, v416[-2]), 0xEuLL), vmull_high_s16(v417, *(int16x8_t *)v416[-2].i8), 0xEuLL);
        *(int16x8_t *)v416->i8 = v418;
        v416 += 4;
        v415 -= 16;
      }
      while (v415);
      v413 = v537;
      if (v533 != v537)
        goto LABEL_476;
LABEL_478:
      if (*(_BYTE *)(v540 + 112))
        goto LABEL_490;
      v414 = *(_DWORD *)(v272 + (v268 << 7) + 124);
      if (v533 >= 0x10)
      {
        v422 = 1048608 - v414 * v537;
        v423 = vdupq_n_s32(-v414);
        v424 = vmlaq_s32(v514, v423, (int32x4_t)xmmword_208F08E20);
        v425 = vmlaq_s32(v514, v423, (int32x4_t)xmmword_208F071C0);
        v426 = vdupq_n_s32(-8 * v414);
        v427 = v537;
        v428 = (int16x4_t *)v550;
        do
        {
          v429 = vaddq_s32(v424, v426);
          v430 = vaddq_s32(v425, v426);
          v431 = vrshrn_high_n_s32(vrshrn_n_s32(vmulq_s32(vshrq_n_s32(v425, 6uLL), vmovl_s16(v428[-2])), 0xEuLL), vmulq_s32(vshrq_n_s32(v424, 6uLL), vmovl_high_s16(*(int16x8_t *)v428[-2].i8)), 0xEuLL);
          v432 = vrshrn_high_n_s32(vrshrn_n_s32(vmulq_s32(vshrq_n_s32(v430, 6uLL), vmovl_s16(*v428)), 0xEuLL), vmulq_s32(vshrq_n_s32(v429, 6uLL), vmovl_high_s16(*(int16x8_t *)v428->i8)), 0xEuLL);
          *(int16x8_t *)v428[-2].i8 = v431;
          *(int16x8_t *)v428->i8 = v432;
          v425 = vaddq_s32(v430, v426);
          v424 = vaddq_s32(v429, v426);
          v428 += 4;
          v427 -= 16;
        }
        while (v427);
        v421 = v537;
        if (v533 == v537)
          goto LABEL_486;
      }
      else
      {
        v421 = 0;
        v422 = 1048608;
      }
      v433 = v533 - v421;
      v434 = &__dst.i16[v421];
      do
      {
        *v434 = ((v422 >> 6) * *v434 + 0x2000) >> 14;
        ++v434;
        v422 -= v414;
        --v433;
      }
      while (v433);
LABEL_486:
      v435 = (int)(1065353216 - ((v520 * v414) & 0xFFFF0000)) >> 16;
      v436 = *v324;
      v437 = (v435 * v436 + 0x2000) >> 14;
      if (v408 >= 4 && v436 <= (__int16)v437)
        LOWORD(v437) = 0;
      *v324 = v437;
LABEL_490:
      webrtc::BackgroundNoise::GenerateBackgroundNoise(*(_QWORD *)(v540 + 48), (int16x4_t *)v551, 750, v268, *(unsigned int *)(*(_QWORD *)(v540 + 128) + (v268 << 7) + 124), v408 > 199, v533, (uint64_t)&v544);
      if (!v533)
        goto LABEL_498;
      if (v533 < 0x10)
      {
        v438 = 0;
LABEL_496:
        v443 = v533 - v438;
        v444 = v438;
        v445 = (__int16 *)&v546[2 * v438 + 4];
        v446 = &__dst.i16[v444];
        do
        {
          v447 = *v445++;
          *v446++ += v447;
          --v443;
        }
        while (v443);
        goto LABEL_498;
      }
      v439 = v537;
      v440 = (int16x8_t *)&v548;
      v441 = (int16x8_t *)v550;
      do
      {
        v442 = vaddq_s16(*v440, *v441);
        v441[-1] = vaddq_s16(v440[-1], v441[-1]);
        *v441 = v442;
        v441 += 2;
        v440 += 2;
        v439 -= 16;
      }
      while (v439);
      v438 = v537;
      if (v533 != v537)
        goto LABEL_496;
LABEL_498:
      if (!v268)
        (*(void (**)(_QWORD *, unint64_t))(*v534 + 128))(v534, v533);
      v448 = v534[1];
      if (v268 >= (v534[2] - v448) >> 3)
        goto LABEL_553;
      (*(void (**)(_QWORD, int16x8_t *, unint64_t, _QWORD))(**(_QWORD **)(v448 + 8 * v268) + 128))(*(_QWORD *)(v448 + 8 * v268), &__dst, v533, 0);
      if (++v268 >= *(_QWORD *)(v540 + 32))
        goto LABEL_502;
    }
    v284 = (int16x4_t *)operator new[]();
    if (v270)
    {
      v285 = v539 + (v268 << 7);
      v286 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v285 + 40) + 144))(v285 + 40);
      if (v286 - v530 >= v270)
        v287 = v270;
      else
        v287 = v286 - v530;
      v288 = *(_QWORD *)(v285 + 56);
      v289 = (*(_QWORD *)(v285 + 64) + v530) % v288;
      v290 = v288 - v289;
      if (v288 - v289 >= v287)
        v291 = v287;
      else
        v291 = v288 - v289;
      memcpy(v284, (const void *)(*(_QWORD *)(v285 + 48) + 2 * v289), 2 * v291);
      if (v287 > v290)
        memcpy((char *)v284 + 2 * v291, *(const void **)(v285 + 48), 2 * (v287 - v291));
      v292 = (int16x4_t *)operator new[]();
      v294 = *(_QWORD *)(v285 + 80);
      v293 = v285 + 80;
      v295 = (*(uint64_t (**)(uint64_t))(v294 + 144))(v293);
      if (v295 - v530 >= v536)
        v296 = v536;
      else
        v296 = v295 - v530;
      v297 = *(_QWORD *)(v293 + 16);
      v298 = (*(_QWORD *)(v293 + 24) + v530) % v297;
      v299 = v297 - v298;
      if (v297 - v298 >= v296)
        v300 = v296;
      else
        v300 = v297 - v298;
      memcpy(v292, (const void *)(*(_QWORD *)(v293 + 8) + 2 * v298), 2 * v300);
      if (v296 > v299)
        memcpy((char *)v292 + 2 * v300, *(const void **)(v293 + 8), 2 * (v296 - v300));
      v270 = v536;
    }
    else
    {
      v292 = (int16x4_t *)operator new[]();
    }
    v316 = v284;
    v317 = 1;
    v318 = v292;
    v319 = 1;
    goto LABEL_402;
  }
LABEL_502:
  v449 = *(_DWORD *)(v4 + 40);
  if (v449 < 200)
    v450 = v449 + 1;
  else
    v450 = 200;
  *(_DWORD *)(v4 + 40) = v450;
  v451 = *(_QWORD *)(v4 + 120) + (*(uint64_t (**)(_QWORD *))(*v534 + 120))(v534);
  if (v451 >= 2 * *(int *)(v4 + 28))
    v451 = 2 * *(int *)(v4 + 28);
  *(_QWORD *)(v4 + 120) = v451;
  return 0;
}

uint64_t webrtc::Expand::SetParametersForNormalAfterExpand(webrtc::Expand *this)
{
  uint64_t result;
  uint64_t v3;
  unint64_t v4;
  int v5;

  *((_QWORD *)this + 13) = 0;
  *((_BYTE *)this + 112) = 1;
  result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 7) + 48))(*((_QWORD *)this + 7), *((unsigned int *)this + 30), *((unsigned int *)this + 7));
  v3 = *((_QWORD *)this + 7);
  v4 = 1000 * (*(_QWORD *)(v3 + 16) - *(_QWORD *)(v3 + 264)) / (unint64_t)*((int *)this + 7);
  if ((int)v4 < 150 || !*(_BYTE *)(v3 + 504))
    goto LABEL_5;
  v5 = *(_DWORD *)(v3 + 148) + v4;
  ++*(_DWORD *)(v3 + 144);
  *(_DWORD *)(v3 + 148) = v5;
  result = atomic_load(&webrtc::StatisticsCalculator::EndExpandEvent(int)::atomic_histogram_pointer);
  if (result)
  {
    result = webrtc::metrics::HistogramAdd(result, v4);
LABEL_5:
    *(_QWORD *)(v3 + 264) = *(_QWORD *)(v3 + 16);
    return result;
  }
  while (!__ldaxr(&webrtc::StatisticsCalculator::EndExpandEvent(int)::atomic_histogram_pointer))
  {
    if (!__stlxr(0, &webrtc::StatisticsCalculator::EndExpandEvent(int)::atomic_histogram_pointer))
      goto LABEL_5;
  }
  __clrex();
  *(_QWORD *)(v3 + 264) = *(_QWORD *)(v3 + 16);
  return result;
}

unint64_t webrtc::Expand::SetParametersForMergeAfterExpand(unint64_t this)
{
  uint64_t v1;
  unint64_t v2;
  int v3;

  *(_QWORD *)(this + 104) = 0xFFFFFFFF00000001;
  *(_BYTE *)(this + 112) = 1;
  v1 = *(_QWORD *)(this + 56);
  v2 = 1000 * (*(_QWORD *)(v1 + 16) - *(_QWORD *)(v1 + 264)) / (unint64_t)*(int *)(this + 28);
  if ((int)v2 < 150 || !*(_BYTE *)(v1 + 504))
    goto LABEL_5;
  v3 = *(_DWORD *)(v1 + 148) + v2;
  ++*(_DWORD *)(v1 + 144);
  *(_DWORD *)(v1 + 148) = v3;
  this = atomic_load(&webrtc::StatisticsCalculator::EndExpandEvent(int)::atomic_histogram_pointer);
  if (this)
  {
    this = webrtc::metrics::HistogramAdd(this, v2);
LABEL_5:
    *(_QWORD *)(v1 + 264) = *(_QWORD *)(v1 + 16);
    return this;
  }
  while (!__ldaxr(&webrtc::StatisticsCalculator::EndExpandEvent(int)::atomic_histogram_pointer))
  {
    if (!__stlxr(0, &webrtc::StatisticsCalculator::EndExpandEvent(int)::atomic_histogram_pointer))
      goto LABEL_5;
  }
  __clrex();
  *(_QWORD *)(v1 + 264) = *(_QWORD *)(v1 + 16);
  return this;
}

uint64_t webrtc::Expand::overlap_length(webrtc::Expand *this)
{
  return *((_QWORD *)this + 8);
}

uint64_t webrtc::ExpandFactory::Create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  uint64_t v13;
  void (**v14)(webrtc::Expand *__hidden);
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;

  v13 = operator new();
  v14 = &off_24C0B3DA0;
  *(_QWORD *)v13 = &off_24C0B3DA0;
  *(_QWORD *)(v13 + 8) = a4;
  *(_QWORD *)(v13 + 16) = a3;
  *(_BYTE *)(v13 + 24) = 1;
  *(_DWORD *)(v13 + 28) = a6;
  *(_QWORD *)(v13 + 32) = a7;
  *(_DWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 48) = a2;
  *(_QWORD *)(v13 + 56) = a5;
  *(_QWORD *)(v13 + 64) = a6 / 1600;
  *(_QWORD *)(v13 + 120) = 0;
  *(_QWORD *)(v13 + 104) = 0;
  *(_BYTE *)(v13 + 112) = 0;
  v15 = (_QWORD *)operator new[]();
  *v15 = 128;
  v15[1] = a7;
  v16 = v15 + 2;
  if (a7)
  {
    v17 = &v16[16 * a7];
    v18 = v15 + 2;
    do
    {
      *(_WORD *)v18 = 0x4000;
      *(_QWORD *)((char *)v18 + 28) = 0;
      v18[5] = &off_24C0AEF80;
      v19 = (_QWORD *)operator new[]();
      v18[6] = v19;
      *(_OWORD *)(v18 + 7) = xmmword_208F05090;
      v18[9] = 10;
      *v19 = 0;
      v19[1] = 0;
      *(_QWORD *)((char *)v19 + 14) = 0;
      (*(void (**)(_QWORD *))(v18[5] + 16))(v18 + 5);
      v18[10] = &off_24C0AEF80;
      v20 = v18 + 10;
      v21 = (_QWORD *)operator new[]();
      v20[1] = v21;
      *((_OWORD *)v20 + 1) = xmmword_208F05090;
      v20[4] = 10;
      *v21 = 0;
      v21[1] = 0;
      *(_QWORD *)((char *)v21 + 14) = 0;
      (*(void (**)(_QWORD *))(*v20 + 16))(v20);
      *((_BYTE *)v20 + 40) = 0;
      *((_DWORD *)v20 + 11) = 0;
      *(_QWORD *)((char *)v20 - 78) = 0;
      *(_QWORD *)((char *)v20 - 62) = 0;
      *(_QWORD *)((char *)v20 - 70) = 0;
      *((_WORD *)v20 - 27) = 0;
      v18 = v20 + 6;
    }
    while (v18 != v17);
    v14 = *(void (***)(webrtc::Expand *__hidden))v13;
  }
  *(_QWORD *)(v13 + 128) = v16;
  *(_QWORD *)(v13 + 88) = 0;
  *(_QWORD *)(v13 + 96) = 0;
  *(_QWORD *)(v13 + 80) = 0;
  v14[2]((webrtc::Expand *)v13);
  return v13;
}

void webrtc::ExpandFactory::~ExpandFactory(webrtc::ExpandFactory *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::ExpandUmaLogger::UpdateSampleCounter(uint64_t this, unint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;

  v3 = this;
  if (*(_BYTE *)(this + 56) && *(_QWORD *)(this + 48) <= a2 && *(_DWORD *)(this + 72) == a3)
  {
    *(_QWORD *)(this + 64) = a2;
    *(_DWORD *)(this + 72) = a3;
  }
  else
  {
    *(_QWORD *)(this + 64) = a2;
    *(_DWORD *)(this + 72) = a3;
    *(_QWORD *)(this + 48) = a2;
    *(_BYTE *)(this + 56) = 1;
  }
  if (****(_QWORD ****)(this + 40) - *(_QWORD *)(**(_QWORD **)(this + 40) + 8) >= *(_QWORD *)(*(_QWORD *)(this + 40)
                                                                                               + 8))
  {
    *(_QWORD *)(this + 48) = a2;
    *(_BYTE *)(this + 56) = 1;
    if (*(char *)(this + 23) < 0)
    {
      v4 = *(_QWORD *)(this + 8);
      if (v4 < 0 || v4 && !*(_QWORD *)this)
      {
        __break(1u);
        goto LABEL_17;
      }
    }
    v5 = *(uint64_t **)(this + 32);
    v6 = 1000 * *(_DWORD *)(this + 24) / *((_DWORD *)v5 + 2);
    v7 = (_QWORD *)operator new();
    this = operator new();
    v8 = *v5;
    *(_QWORD *)this = v5;
    *(_QWORD *)(this + 8) = v8;
    *v7 = this;
    v7[1] = v6;
    v9 = *(uint64_t **)(v3 + 40);
    *(_QWORD *)(v3 + 40) = v7;
    if (v9)
    {
      v10 = *v9;
      *v9 = 0;
      if (v10)
        MEMORY[0x20BD0ADEC](v10, 0x1060C40C2E02434);
LABEL_17:
      JUMPOUT(0x20BD0ADECLL);
    }
  }
  return this;
}

void webrtc::rtcp::ExtendedReports::~ExtendedReports(webrtc::rtcp::ExtendedReports *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24C0B3E10;
  if (*((_BYTE *)this + 80))
  {
    v2 = (void *)*((_QWORD *)this + 7);
    if (v2)
    {
      *((_QWORD *)this + 8) = v2;
      operator delete(v2);
    }
  }
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
  {
    *((_QWORD *)this + 5) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24C0B3E10;
  if (*((_BYTE *)this + 80))
  {
    v2 = (void *)*((_QWORD *)this + 7);
    if (v2)
    {
      *((_QWORD *)this + 8) = v2;
      operator delete(v2);
    }
  }
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
  {
    *((_QWORD *)this + 5) = v3;
    operator delete(v3);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::rtcp::ExtendedReports::Parse(webrtc::rtcp::ExtendedReports *this, const webrtc::rtcp::CommonHeader *a2)
{
  unint64_t v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v14;
  void **v15;
  void *v16;
  unint64_t v17;
  unsigned int *v18;
  unsigned int *v19;
  uint64_t v20;
  unsigned int *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v3 = *((_DWORD *)a2 + 1);
  if (v3 <= 3)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      goto LABEL_3;
    return 0;
  }
  v14 = (unsigned int *)*((_QWORD *)a2 + 1);
  *((_DWORD *)this + 2) = bswap32(*v14);
  if (*((_BYTE *)this + 24))
    *((_BYTE *)this + 24) = 0;
  *((_QWORD *)this + 5) = *((_QWORD *)this + 4);
  v15 = (void **)((char *)this + 56);
  if (*((_BYTE *)this + 80))
  {
    v16 = *v15;
    if (*v15)
    {
      *((_QWORD *)this + 8) = v16;
      operator delete(v16);
      v14 = (unsigned int *)*((_QWORD *)a2 + 1);
      v3 = *((_DWORD *)a2 + 1);
    }
    *((_BYTE *)this + 80) = 0;
  }
  v11 = 1;
  if (v3 >= 8)
  {
    v17 = (unint64_t)v14 + v3;
    v18 = v14 + 2;
    v19 = v14 + 1;
    while (1)
    {
      v20 = __rev16(*((unsigned __int16 *)v19 + 1));
      v21 = &v18[v20];
      if ((unint64_t)v21 > v17)
      {
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
LABEL_3:
          rtc::webrtc_logging_impl::Log("\r\t", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/extended_reports.cc");
        return 0;
      }
      v22 = *(unsigned __int8 *)v19;
      switch(v22)
      {
        case 42:
          if (*((_BYTE *)this + 80))
          {
            v30 = *v15;
            if (*v15)
            {
              *((_QWORD *)this + 8) = v30;
              operator delete(v30);
            }
          }
          *v15 = 0;
          *((_QWORD *)this + 8) = 0;
          *((_QWORD *)this + 9) = 0;
          *((_BYTE *)this + 80) = 1;
          if ((_DWORD)v20)
          {
            v31 = (unsigned __int8 *)v19 + 7;
            do
            {
              v32 = *(v31 - 3);
              v33 = (*(v31 - 2) << 16) | (*(v31 - 1) << 8);
              v34 = *v31;
              v31 += 4;
              webrtc::rtcp::TargetBitrate::AddTargetBitrate((webrtc::rtcp::ExtendedReports *)((char *)this + 56), v32 >> 4, v32 & 0xF, v33 | v34);
              --v20;
            }
            while (v20);
          }
          break;
        case 5:
          if (*((_QWORD *)this + 4) == *((_QWORD *)this + 5))
          {
            webrtc::rtcp::Dlrr::Parse((webrtc::rtcp::ExtendedReports *)((char *)this + 32), (const unsigned __int8 *)v19, v20);
            break;
          }
          if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
LABEL_13:
            rtc::webrtc_logging_impl::Log("\r\t", v23, v24, v25, v26, v27, v28, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/extended_reports.cc");
          break;
        case 4:
          if ((_DWORD)v20 != 2)
          {
            if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
              rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v42, v43, v44, v45, v46, v47, v48, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/extended_reports.cc");
            break;
          }
          if (!*((_BYTE *)this + 24))
          {
            *((_QWORD *)this + 2) = 0;
            *((_BYTE *)this + 24) = 1;
            *((_QWORD *)this + 2) = bswap64(*(_QWORD *)(v19 + 1));
            break;
          }
          if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
            goto LABEL_13;
          break;
        default:
          if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
          {
            v2 = v2 & 0xFFFFFFFF00000000 | 0x2DA;
            rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v35, v36, v37, v38, v39, v40, v41, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/extended_reports.cc");
          }
          break;
      }
      v18 = v21 + 1;
      v19 = v21;
      if ((unint64_t)(v21 + 1) > v17)
        return 1;
    }
  }
  return v11;
}

void webrtc::rtcp::Dlrr::AddDlrrItem(void **a1, uint64_t *a2)
{
  unint64_t v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  int v17;

  v5 = (char *)a1[1];
  v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 < v4)
  {
    if (v5)
    {
      v6 = *a2;
      *((_DWORD *)v5 + 2) = *((_DWORD *)a2 + 2);
      *(_QWORD *)v5 = v6;
      v7 = v5 + 12;
LABEL_4:
      a1[1] = v7;
      return;
    }
    goto LABEL_18;
  }
  v8 = (char *)*a1;
  v9 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (_BYTE *)*a1) >> 2);
  v10 = v9 + 1;
  if (v9 + 1 > 0x1555555555555555)
    goto LABEL_19;
  v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - (_QWORD)v8) >> 2);
  if (2 * v11 > v10)
    v10 = 2 * v11;
  if (v11 >= 0xAAAAAAAAAAAAAAALL)
    v12 = 0x1555555555555555;
  else
    v12 = v10;
  if (!v12)
  {
LABEL_18:
    __break(1u);
LABEL_19:
    abort();
  }
  if (v12 > 0x1555555555555555)
    std::__throw_bad_array_new_length[abi:sn180100]();
  v13 = 12 * v12;
  v14 = (char *)operator new(12 * v12);
  v15 = &v14[12 * v9];
  *(_QWORD *)v15 = *a2;
  *((_DWORD *)v15 + 2) = *((_DWORD *)a2 + 2);
  v7 = v15 + 12;
  if (v5 != v8)
  {
    do
    {
      v16 = *(_QWORD *)(v5 - 12);
      v5 -= 12;
      v17 = *((_DWORD *)v5 + 2);
      *(_QWORD *)(v15 - 12) = v16;
      v15 -= 12;
      *((_DWORD *)v15 + 2) = v17;
    }
    while (v5 != v8);
    v5 = v8;
  }
  *a1 = v15;
  a1[1] = v7;
  a1[2] = &v14[v13];
  if (!v5)
    goto LABEL_4;
  operator delete(v5);
  a1[1] = v7;
}

void webrtc::rtcp::ExtendedReports::SetTargetBitrate(webrtc::rtcp::ExtendedReports *this, char **a2)
{
  char **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int64_t v13;
  char *v14;
  char *v15;

  v4 = (char **)((char *)this + 56);
  if (!*((_BYTE *)this + 80))
    goto LABEL_7;
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/extended_reports.cc");
  if (*((_BYTE *)this + 80))
  {
    if (v4 != a2)
      std::vector<webrtc::rtcp::TargetBitrate::BitrateItem>::__assign_with_size[abi:sn180100]<webrtc::rtcp::TargetBitrate::BitrateItem*,webrtc::rtcp::TargetBitrate::BitrateItem*>(v4, *a2, a2[1], (a2[1] - *a2) >> 3);
  }
  else
  {
LABEL_7:
    *v4 = 0;
    v4[1] = 0;
    v4[2] = 0;
    v12 = *a2;
    v13 = a2[1] - *a2;
    if (v13)
    {
      if (v13 < 0)
        abort();
      v14 = (char *)operator new(v13);
      *((_QWORD *)this + 7) = v14;
      *((_QWORD *)this + 8) = v14;
      v15 = &v14[8 * (v13 >> 3)];
      *((_QWORD *)this + 9) = v15;
      memcpy(v14, v12, v13);
      *((_QWORD *)this + 8) = v15;
    }
    *((_BYTE *)this + 80) = 1;
  }
}

uint64_t webrtc::rtcp::ExtendedReports::BlockLength(webrtc::rtcp::ExtendedReports *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (*((_BYTE *)this + 80))
    v1 = ((uint64_t)(*((_QWORD *)this + 8) - *((_QWORD *)this + 7)) >> 1) + 4;
  else
    v1 = 0;
  v2 = *((_QWORD *)this + 5) - *((_QWORD *)this + 4) + 4;
  if (*((_QWORD *)this + 5) == *((_QWORD *)this + 4))
    v2 = 0;
  v3 = 20;
  if (!*((_BYTE *)this + 24))
    v3 = 8;
  return v2 + v3 + v1;
}

uint64_t webrtc::rtcp::ExtendedReports::Create(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5, void (*a6)(uint64_t, uint64_t))
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const float *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  uint64_t v23;
  char *v24;
  unsigned int *v25;
  unsigned int *v26;
  _DWORD *v27;
  uint64_t v28;
  BOOL v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  unint64_t v43;
  int8x16_t v44;
  int8x16_t v45;
  const float *v46;
  const float *v47;
  unsigned __int128 v48;
  int8x16_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  int8x8_t v56;
  const float *v57;
  unint64_t v58;
  unint64_t v59;
  int v60;
  std::string *v61;
  int8x16x2_t v62;
  int8x16x2_t v63;
  int8x16x2_t v64;
  int8x16x2_t v65;
  int8x16x2_t v66;
  int8x16x2_t v67;
  int8x16x2_t v68;
  int8x16x4_t v69;

  v12 = *a3;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) + v12 <= a4)
  {
LABEL_4:
    v13 = *a3;
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    *(_BYTE *)(a2 + *a3) = 0x80;
    *(_BYTE *)(*a3 + a2 + 1) = -49;
    *(_BYTE *)(*a3 + a2 + 2) = (unint64_t)(v15 - 4) >> 10;
    *(_BYTE *)(*a3 + a2 + 3) = (unint64_t)(v15 - 4) >> 2;
    v20 = *a3 + 4;
    *a3 = v20;
    *(_DWORD *)(a2 + v20) = bswap32(*(_DWORD *)(a1 + 8));
    v21 = (char *)(*a3 + 4);
    *a3 = (uint64_t)v21;
    if (*(_BYTE *)(a1 + 24))
    {
      v22 = &v21[a2];
      *(_DWORD *)v22 = 33554436;
      v23 = *(_QWORD *)(a1 + 16);
      v22[4] = HIBYTE(v23);
      v22[5] = BYTE6(v23);
      v22[6] = BYTE5(v23);
      v22[7] = BYTE4(v23);
      *((_DWORD *)v22 + 2) = bswap32(*(_DWORD *)(a1 + 16));
      v21 = (char *)(*a3 + 12);
      *a3 = (uint64_t)v21;
    }
    if (*(_QWORD *)(a1 + 32) != *(_QWORD *)(a1 + 40))
    {
      v24 = &v21[a2];
      *(_WORD *)v24 = 5;
      *((_WORD *)v24 + 1) = bswap32((*(_DWORD *)(a1 + 40) - *(_DWORD *)(a1 + 32)) >> 2) >> 16;
      v25 = *(unsigned int **)(a1 + 32);
      v26 = *(unsigned int **)(a1 + 40);
      if (v25 == v26)
      {
        v28 = *(_QWORD *)(a1 + 32);
      }
      else
      {
        v27 = v24 + 4;
        do
        {
          *v27 = bswap32(*v25);
          v27[1] = bswap32(v25[1]);
          v27[2] = bswap32(v25[2]);
          v27 += 3;
          v25 += 3;
        }
        while (v25 != v26);
        v28 = *(_QWORD *)(a1 + 32);
        v25 = *(unsigned int **)(a1 + 40);
      }
      v31 = (char *)v25 - v28;
      v30 = v31 == 0;
      v32 = v31 + 4;
      if (v30)
        v32 = 0;
      v21 = &v32[*a3];
      *a3 = (uint64_t)v21;
    }
    if (!*(_BYTE *)(a1 + 80))
      goto LABEL_39;
    v33 = &v21[a2];
    *(_WORD *)v33 = 42;
    *((_WORD *)v33 + 1) = bswap32(((((*(_DWORD *)(a1 + 64) - *(_DWORD *)(a1 + 56)) >> 1) + 4) >> 2) - 1) >> 16;
    v35 = *(_QWORD *)(a1 + 56);
    v34 = *(_QWORD *)(a1 + 64);
    if (v35 == v34)
    {
LABEL_37:
      if (!*(_BYTE *)(a1 + 80))
      {
        __break(1u);
LABEL_42:
        v61 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/extended_reports.cc", 153, "*index == index_end", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long> const&)::t, v16, (uint64_t)v17, v18, v19, (uint64_t)v21);
        return external_hmac_alloc(v61);
      }
      v21 = (char *)(*a3 + ((uint64_t)(*(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56)) >> 1) + 4);
      *a3 = (uint64_t)v21;
LABEL_39:
      if (v21 == (char *)(v14 + v13))
        return 1;
      goto LABEL_42;
    }
    v36 = v34 - v35 - 8;
    if (v36 < 0x40)
    {
      v37 = 4;
      goto LABEL_36;
    }
    v38 = v36 >> 3;
    if ((unint64_t)&v21[a2 + 4] < (v36 & 0xFFFFFFFFFFFFFFF8) + v35 + 8
      && v35 < (unint64_t)&v21[4 * v38 + 8 + a2])
    {
      v37 = 4;
      goto LABEL_36;
    }
    v39 = v38 + 1;
    if (v36 >= 0x80)
    {
      v41 = 16;
      if ((v39 & 0xF) != 0)
        v41 = v39 & 0xF;
      v40 = v39 - v41;
      v42 = &v21[a2 + 4];
      v43 = v35 + 4;
      v16 = v38 + 1;
      do
      {
        v64 = *(int8x16x2_t *)(v43 - 4);
        v65 = *(int8x16x2_t *)(v43 + 28);
        v67 = *(int8x16x2_t *)(v43 + 60);
        v68 = *(int8x16x2_t *)(v43 + 92);
        v44 = vqtbl2q_s8(v67, (int8x16_t)xmmword_208F09860);
        v44.i32[3] = vqtbl2q_s8(v68, (int8x16_t)xmmword_208F09850).i32[3];
        v45.i32[0] = vqtbl2q_s8(v64, (int8x16_t)xmmword_208F09880).u32[0];
        v45.i32[1] = vqtbl2q_s8(v65, (int8x16_t)xmmword_208F09870).i32[1];
        v45.i64[1] = v44.i64[1];
        v67.val[0] = vqtbl2q_s8(v67, (int8x16_t)xmmword_208F098A0);
        v67.val[0].i32[3] = vqtbl2q_s8(v68, (int8x16_t)xmmword_208F09890).i32[3];
        v64.val[0].i32[0] = vqtbl2q_s8(v64, (int8x16_t)xmmword_208F098C0).u32[0];
        v64.val[0].i32[1] = vqtbl2q_s8(v65, (int8x16_t)xmmword_208F098B0).i32[1];
        v64.val[0].i64[1] = v67.val[0].i64[1];
        v46 = (const float *)v43;
        v64.val[1] = (int8x16_t)vld2q_f32(v46);
        v46 += 8;
        v65.val[0] = (int8x16_t)vld2q_f32(v46);
        v67.val[1] = vorrq_s8(vshlq_n_s8(v45, 4uLL), v64.val[0]);
        v47 = (const float *)(v43 + 64);
        v65.val[1] = (int8x16_t)vld2q_f32(v47);
        v17 = (const float *)(v43 + 96);
        v48 = (unsigned __int128)vld2q_f32(v17);
        v69.val[0] = (int8x16_t)vshrq_n_u32((uint32x4_t)v64.val[1], 0x10uLL);
        v69.val[3] = (int8x16_t)vshrq_n_u32((uint32x4_t)v48, 0x10uLL);
        v69.val[2] = (int8x16_t)vshrq_n_u32((uint32x4_t)v65.val[1], 0x10uLL);
        v69.val[1] = (int8x16_t)vshrq_n_u32((uint32x4_t)v65.val[0], 0x10uLL);
        v68.val[0] = vqtbl4q_s8(v69, (int8x16_t)xmmword_208F05040);
        v69.val[0] = (int8x16_t)vshrq_n_u32((uint32x4_t)v64.val[1], 8uLL);
        v69.val[3] = (int8x16_t)vshrq_n_u32((uint32x4_t)v48, 8uLL);
        v69.val[2] = (int8x16_t)vshrq_n_u32((uint32x4_t)v65.val[1], 8uLL);
        v69.val[1] = (int8x16_t)vshrq_n_u32((uint32x4_t)v65.val[0], 8uLL);
        v68.val[1] = vqtbl4q_s8(v69, (int8x16_t)xmmword_208F05040);
        v67.val[0] = (int8x16_t)v48;
        v49 = vqtbl4q_s8(*(int8x16x4_t *)v64.val[1].i8, (int8x16_t)xmmword_208F05040);
        vst4q_s8(v42, *(int8x16x4_t *)v67.val[1].i8);
        v42 += 64;
        v43 += 128;
        v16 -= 16;
      }
      while (v41 != v16);
      if (v41 < 9)
      {
        v35 += 8 * v40;
        v37 = 4 * v40 + 4;
        do
        {
LABEL_36:
          v33[v37] = *(_BYTE *)(v35 + 1) | (16 * *(_BYTE *)v35);
          v21 = &v33[v37 | 1];
          v60 = *(_DWORD *)(v35 + 4);
          *v21 = BYTE2(v60);
          v21[1] = BYTE1(v60);
          v21[2] = v60;
          v37 += 4;
          v35 += 8;
        }
        while (v35 != v34);
        goto LABEL_37;
      }
    }
    else
    {
      v40 = 0;
    }
    v50 = 8;
    if ((v39 & 7) != 0)
      v50 = v39 & 7;
    v51 = v39 - v50;
    v37 = 4 * (v39 - v50) + 4;
    v52 = v35 + 8 * v51;
    v53 = &v21[4 * v40 + 4 + a2];
    v54 = v35 + 8 * v40 + 4;
    v55 = ~v38 + v40 + v50;
    do
    {
      v62 = *(int8x16x2_t *)(v54 - 4);
      v63 = *(int8x16x2_t *)(v54 + 28);
      v56.i32[0] = vqtbl2q_s8(v62, (int8x16_t)xmmword_208F09880).u32[0];
      v56.i32[1] = vqtbl2q_s8(v63, (int8x16_t)xmmword_208F09870).i32[1];
      v62.val[0].i32[0] = vqtbl2q_s8(v62, (int8x16_t)xmmword_208F098C0).u32[0];
      v62.val[0].i32[1] = vqtbl2q_s8(v63, (int8x16_t)xmmword_208F098B0).i32[1];
      *(int8x8_t *)v63.val[0].i8 = vorr_s8(vshl_n_s8(v56, 4uLL), *(int8x8_t *)v62.val[0].i8);
      v57 = (const float *)v54;
      v62.val[0] = (int8x16_t)vld2q_f32(v57);
      v57 += 8;
      v62.val[1] = (int8x16_t)vld2q_f32(v57);
      v66.val[0] = (int8x16_t)vshrq_n_u32((uint32x4_t)v62.val[0], 0x10uLL);
      v66.val[1] = (int8x16_t)vshrq_n_u32((uint32x4_t)v62.val[1], 0x10uLL);
      v63.val[1].i64[0] = vqtbl2q_s8(v66, (int8x16_t)xmmword_208F05050).u64[0];
      v66.val[0] = (int8x16_t)vshrq_n_u32((uint32x4_t)v62.val[0], 8uLL);
      v66.val[1] = (int8x16_t)vshrq_n_u32((uint32x4_t)v62.val[1], 8uLL);
      v58 = vqtbl2q_s8(v66, (int8x16_t)xmmword_208F05050).u64[0];
      v59 = vqtbl2q_s8(v62, (int8x16_t)xmmword_208F05050).u64[0];
      vst4_s8(v53, (int8x8x4_t)v63);
      v53 += 32;
      v54 += 64;
      v55 += 8;
    }
    while (v55);
    v35 = v52;
    goto LABEL_36;
  }
  while (*a3)
  {
    a6(a5, a2);
    *a3 = 0;
    if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) <= a4)
      goto LABEL_4;
  }
  return 0;
}

uint64_t external_hmac_alloc(uint64_t *a1, int a2, int a3)
{
  uint64_t result;
  uint64_t v7;

  result = 2;
  if (a2 <= 20 && a3 <= 20)
  {
    v7 = operator new[]();
    result = 0;
    *a1 = v7;
    *(_QWORD *)v7 = external_hmac;
    *(_QWORD *)(v7 + 8) = v7 + 32;
    *(_DWORD *)(v7 + 16) = a3;
    *(_DWORD *)(v7 + 20) = a2;
    *(_DWORD *)(v7 + 24) = 0;
  }
  return result;
}

uint64_t external_hmac_dealloc(uint64_t a1)
{
  *(_QWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  MEMORY[0x20BD0ADD4]();
  return 0;
}

uint64_t external_hmac_init(void *a1, const unsigned __int8 *a2, int a3)
{
  uint64_t result;

  if (a3 > 20)
    return 2;
  memcpy(a1, a2, a3);
  result = 0;
  *((_DWORD *)a1 + 5) = a3;
  return result;
}

uint64_t external_hmac_start(void *a1)
{
  return 0;
}

uint64_t external_hmac_update(void *a1, const unsigned __int8 *a2)
{
  return 0;
}

uint64_t external_hmac_compute(void *a1, const unsigned __int8 *a2, int a3, int a4, unsigned __int8 *__dst)
{
  memcpy(__dst, &kExternalHmacFakeTag, a4);
  return 0;
}

uint64_t external_crypto_init(void)
{
  uint64_t result;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  result = srtp_replace_auth_type((uint64_t)external_hmac, 4);
  if ((_DWORD)result)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)3>() & 1) == 0)
      rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int> const&)::t, v1, v2, v3, v4, v5, v6, v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/pc/external_hmac.cc");
    return 1;
  }
  return result;
}

void webrtc::FakeNetworkPipe::~FakeNetworkPipe(webrtc::FakeNetworkPipe *this)
{
  void **v2;
  void **v3;
  void **v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)this = &off_24C0B3EC0;
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 248, *((_QWORD **)this + 32));
  v2 = (void **)((char *)this + 160);
  std::deque<webrtc::FakeNetworkPipe::StoredPacket>::clear((_QWORD *)this + 20);
  v3 = (void **)*((_QWORD *)this + 21);
  v4 = (void **)*((_QWORD *)this + 22);
  if (v3 != v4)
  {
    do
    {
      v5 = *v3++;
      operator delete(v5);
    }
    while (v3 != v4);
    v7 = *((_QWORD *)this + 21);
    v6 = *((_QWORD *)this + 22);
    if (v6 != v7)
      *((_QWORD *)this + 22) = v6 + ((v7 - v6 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*v2)
    operator delete(*v2);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 96));
  v8 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 16));
}

{
  webrtc::FakeNetworkPipe::~FakeNetworkPipe(this);
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FakeNetworkPipe::SetReceiver(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;

  v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  *(_QWORD *)(a1 + 88) = a2;
  return pthread_mutex_unlock(v4);
}

uint64_t webrtc::FakeNetworkPipe::AddActiveTransport(uint64_t a1, uint64_t *a2)
{
  pthread_mutex_t *v4;
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;

  v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v5 = *(uint64_t **)(a1 + 256);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= (unint64_t)a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_8;
      }
      if (v8 >= (unint64_t)a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    v6 = (uint64_t **)(a1 + 256);
    v7 = (uint64_t **)(a1 + 256);
LABEL_8:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = a2;
    v7[5] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = **(_QWORD **)(a1 + 248);
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *(_QWORD *)(a1 + 248) = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 256), v11);
    ++*(_QWORD *)(a1 + 264);
  }
  v7[5] = (uint64_t *)((char *)v7[5] + 1);
  return pthread_mutex_unlock(v4);
}

uint64_t webrtc::FakeNetworkPipe::RemoveActiveTransport(uint64_t a1, unint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  BOOL v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  BOOL v19;
  std::string *v21;
  uint64_t v22;

  v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v9 = *(uint64_t **)(a1 + 256);
  if (!v9)
    goto LABEL_23;
  v10 = (uint64_t *)(a1 + 256);
  v11 = *(_QWORD **)(a1 + 256);
  do
  {
    v12 = v11[4];
    v13 = v12 >= a2;
    if (v12 >= a2)
      v14 = v11;
    else
      v14 = v11 + 1;
    if (v13)
      v10 = v11;
    v11 = (_QWORD *)*v14;
  }
  while (*v14);
  if (v10 == (uint64_t *)(a1 + 256) || v10[4] > a2)
  {
LABEL_23:
    v21 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/call/fake_network_pipe.cc", 132, "it != active_transports_.end()", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v5, v6, v7, v8, v22);
    return webrtc::FakeNetworkPipe::SendRtp(v21);
  }
  else
  {
    v15 = v10[5] - 1;
    v10[5] = v15;
    if (v15)
    {
      return pthread_mutex_unlock(v4);
    }
    else
    {
      v16 = (uint64_t *)v10[1];
      if (v16)
      {
        do
        {
          v17 = v16;
          v16 = (uint64_t *)*v16;
        }
        while (v16);
      }
      else
      {
        v18 = v10;
        do
        {
          v17 = (uint64_t *)v18[2];
          v19 = *v17 == (_QWORD)v18;
          v18 = v17;
        }
        while (!v19);
      }
      if (*(uint64_t **)(a1 + 248) == v10)
        *(_QWORD *)(a1 + 248) = v17;
      --*(_QWORD *)(a1 + 264);
      std::__tree_remove[abi:sn180100]<std::__tree_node_base<void *> *>(v9, v10);
      operator delete(v10);
      return pthread_mutex_unlock(v4);
    }
  }
}

uint64_t webrtc::FakeNetworkPipe::SendRtp(uint64_t a1, const void *a2, size_t a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v10;
  void *v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  char v20[16];
  char v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;

  if (a3)
  {
    v10 = operator new();
    *(_QWORD *)v10 = a3;
    *(_QWORD *)(v10 + 8) = a3;
    v11 = (void *)operator new[]();
    *(_QWORD *)(v10 + 16) = v11;
    *(_DWORD *)(v10 + 24) = 0;
    v12 = (unsigned int *)(v10 + 24);
    v22 = v10;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    memcpy(v11, a2, a3);
    v23 = 0;
    v24 = a3;
  }
  else
  {
    v22 = 0;
    v23 = 0;
    v24 = 0;
  }
  *(_QWORD *)v20 = *a4;
  *(_QWORD *)&v20[5] = *(_QWORD *)((char *)a4 + 5);
  v21 = 1;
  webrtc::FakeNetworkPipe::EnqueuePacket(a1, (uint64_t)&v22, v20, 0, a5);
  v14 = v22;
  if (v22)
  {
    v15 = (unsigned int *)(v22 + 24);
    do
    {
      v16 = __ldaxr(v15);
      v17 = v16 - 1;
    }
    while (__stlxr(v17, v15));
    if (!v17)
    {
      v18 = *(_QWORD *)(v14 + 16);
      *(_QWORD *)(v14 + 16) = 0;
      if (v18)
        MEMORY[0x20BD0ADD4](v18, 0x1000C8077774924);
      MEMORY[0x20BD0ADEC](v14, 0x1010C40EE34DA14);
    }
  }
  return 1;
}

uint64_t webrtc::FakeNetworkPipe::EnqueuePacket(uint64_t a1, uint64_t a2, char *a3, char a4, uint64_t a5)
{
  pthread_mutex_t *v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  int v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v32;
  int v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  uint64_t v39;
  int v40;
  char v41;
  char v42;
  uint64_t v43;
  _QWORD v44[8];
  void *__p;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v10 = (pthread_mutex_t *)(a1 + 96);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  v12 = *(_QWORD *)a2;
  v13 = *(_OWORD *)(a2 + 8);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v14 = a3[16];
  if (a3[16])
  {
    v15 = *a3;
    v32 = *(_QWORD *)(a3 + 1);
    v33 = *(_DWORD *)(a3 + 9);
    v34 = v12;
    v35 = v13;
    v36 = v11;
    v37 = v11;
    v38 = 0;
    v41 = 0;
    if (!v14)
      goto LABEL_4;
    goto LABEL_3;
  }
  v15 = 0;
  v34 = v12;
  v35 = v13;
  v36 = v11;
  v37 = v11;
  v38 = 0;
  v41 = 0;
  if (v14)
  {
LABEL_3:
    v38 = v15;
    v39 = v32;
    v40 = v33;
    v41 = 1;
  }
LABEL_4:
  v42 = a4;
  v49 = 0;
  v44[0] = 0;
  v43 = 0;
  *(_QWORD *)((char *)v44 + 5) = 0;
  v50 = a5;
  v16 = webrtc::FakeNetworkPipe::EnqueuePacket((_QWORD *)a1, &v34);
  if (v49)
  {
    v17 = v48;
    if (v48)
    {
      v18 = (unsigned int *)(v48 + 8);
      do
      {
        v19 = __ldaxr(v18);
        v20 = v19 - 1;
      }
      while (__stlxr(v20, v18));
      if (!v20)
        (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
    }
    v21 = v47;
    if (v47)
    {
      v22 = (unsigned int *)(v47 + 24);
      do
      {
        v23 = __ldaxr(v22);
        v24 = v23 - 1;
      }
      while (__stlxr(v24, v22));
      if (!v24)
      {
        v25 = *(_QWORD *)(v21 + 16);
        *(_QWORD *)(v21 + 16) = 0;
        if (v25)
          MEMORY[0x20BD0ADD4](v25, 0x1000C8077774924);
        MEMORY[0x20BD0ADEC](v21, 0x1010C40EE34DA14);
      }
    }
    if (__p)
    {
      v46 = __p;
      operator delete(__p);
    }
  }
  v26 = v34;
  if (v34)
  {
    v27 = (unsigned int *)(v34 + 24);
    do
    {
      v28 = __ldaxr(v27);
      v29 = v28 - 1;
    }
    while (__stlxr(v29, v27));
    if (!v29)
    {
      v30 = *(_QWORD *)(v26 + 16);
      *(_QWORD *)(v26 + 16) = 0;
      if (v30)
        MEMORY[0x20BD0ADD4](v30, 0x1000C8077774924);
      MEMORY[0x20BD0ADEC](v26, 0x1010C40EE34DA14);
    }
  }
  pthread_mutex_unlock(v10);
  return v16;
}

uint64_t webrtc::FakeNetworkPipe::SendRtcp(uint64_t a1, const void *a2, size_t a3, uint64_t a4)
{
  uint64_t v8;
  void *v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  char v18[24];
  uint64_t v19;
  uint64_t v20;
  size_t v21;

  if (a3)
  {
    v8 = operator new();
    *(_QWORD *)v8 = a3;
    *(_QWORD *)(v8 + 8) = a3;
    v9 = (void *)operator new[]();
    *(_QWORD *)(v8 + 16) = v9;
    *(_DWORD *)(v8 + 24) = 0;
    v10 = (unsigned int *)(v8 + 24);
    v19 = v8;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    memcpy(v9, a2, a3);
    v20 = 0;
    v21 = a3;
  }
  else
  {
    v19 = 0;
    v20 = 0;
    v21 = 0;
  }
  v18[0] = 0;
  v18[16] = 0;
  webrtc::FakeNetworkPipe::EnqueuePacket(a1, (uint64_t)&v19, v18, 1, a4);
  v12 = v19;
  if (v19)
  {
    v13 = (unsigned int *)(v19 + 24);
    do
    {
      v14 = __ldaxr(v13);
      v15 = v14 - 1;
    }
    while (__stlxr(v15, v13));
    if (!v15)
    {
      v16 = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(v12 + 16) = 0;
      if (v16)
        MEMORY[0x20BD0ADD4](v16, 0x1000C8077774924);
      MEMORY[0x20BD0ADEC](v12, 0x1010C40EE34DA14);
    }
  }
  return 1;
}

uint64_t webrtc::FakeNetworkPipe::DeliverRtpPacket(uint64_t a1, int a2, __int128 *a3)
{
  pthread_mutex_t *v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v33;
  char v34;
  __int128 v35;
  __int128 v36;
  _BYTE v37[22];
  uint64_t v38[5];
  char v39;
  char v40;
  char v41;
  int v42;
  uint64_t v43;
  char v44;
  __int128 v45;
  __int128 v46;
  _BYTE v47[22];
  void *__p[2];
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  char v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v6 = (pthread_mutex_t *)(a1 + 96);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  v35 = *a3;
  v36 = a3[1];
  *(_OWORD *)v37 = a3[2];
  *(_QWORD *)&v37[14] = *(_QWORD *)((char *)a3 + 46);
  v8 = *(__int128 *)((char *)a3 + 56);
  *((_QWORD *)a3 + 7) = 0;
  *((_QWORD *)a3 + 8) = 0;
  v9 = *((_QWORD *)a3 + 9);
  v10 = *((_QWORD *)a3 + 10);
  *((_QWORD *)a3 + 9) = 0;
  v11 = *((_QWORD *)a3 + 11);
  v12 = *((_QWORD *)a3 + 12);
  *((_QWORD *)a3 + 11) = 0;
  *((_QWORD *)a3 + 12) = 0;
  v13 = *((_QWORD *)a3 + 13);
  v14 = *((_QWORD *)a3 + 14);
  *((_QWORD *)a3 + 13) = 0;
  v34 = *((_BYTE *)a3 + 128);
  v33 = *((_QWORD *)a3 + 15);
  v15 = *((_QWORD *)a3 + 17);
  *((_QWORD *)a3 + 17) = 0;
  v38[0] = v11;
  if (v11)
  {
    v16 = (unsigned int *)(v11 + 24);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v45 = v35;
  v38[1] = v12;
  v38[2] = v13;
  v38[3] = v7;
  v38[4] = v7;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = a2;
  v43 = v14;
  v44 = 1;
  v46 = v36;
  *(_OWORD *)v47 = *(_OWORD *)v37;
  *(_QWORD *)&v47[14] = *(_QWORD *)&v37[14];
  *(_OWORD *)__p = v8;
  v49 = v9;
  v50 = v10;
  v51 = v11;
  v52 = v12;
  v53 = v13;
  v54 = v14;
  v55 = v33;
  v56 = v34;
  v57 = v15;
  v58 = 1;
  v59 = 0;
  webrtc::FakeNetworkPipe::EnqueuePacket((_QWORD *)a1, v38);
  if (v58)
  {
    v18 = v57;
    if (v57)
    {
      v19 = (unsigned int *)(v57 + 8);
      do
      {
        v20 = __ldaxr(v19);
        v21 = v20 - 1;
      }
      while (__stlxr(v21, v19));
      if (!v21)
        (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
    }
    v22 = v51;
    if (v51)
    {
      v23 = (unsigned int *)(v51 + 24);
      do
      {
        v24 = __ldaxr(v23);
        v25 = v24 - 1;
      }
      while (__stlxr(v25, v23));
      if (!v25)
      {
        v26 = *(_QWORD *)(v22 + 16);
        *(_QWORD *)(v22 + 16) = 0;
        if (v26)
          MEMORY[0x20BD0ADD4](v26, 0x1000C8077774924);
        MEMORY[0x20BD0ADEC](v22, 0x1010C40EE34DA14);
      }
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  v27 = v38[0];
  if (v38[0])
  {
    v28 = (unsigned int *)(v38[0] + 24);
    do
    {
      v29 = __ldaxr(v28);
      v30 = v29 - 1;
    }
    while (__stlxr(v30, v28));
    if (!v30)
    {
      v31 = *(_QWORD *)(v27 + 16);
      *(_QWORD *)(v27 + 16) = 0;
      if (v31)
        MEMORY[0x20BD0ADD4](v31, 0x1000C8077774924);
      MEMORY[0x20BD0ADEC](v27, 0x1010C40EE34DA14);
    }
  }
  return pthread_mutex_unlock(v6);
}

uint64_t webrtc::FakeNetworkPipe::EnqueuePacket(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char v10;
  __int128 v11;
  char v12;
  int v13;
  int v14;
  char v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  char *v19;
  char *v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  unint64_t v24;
  BOOL v25;
  unint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  char *v32;
  void *v33;
  void *v34;
  unint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  void *v39;
  void *v40;
  unint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  void *v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  int64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  char *v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  __int128 *v68;
  char *v69;
  uint64_t v70;
  __int128 v71;
  uint64_t v72;
  char *v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  char *v77;
  char *v78;
  char *v79;
  BOOL v80;
  int64_t v81;
  unint64_t v82;
  char *v83;
  unint64_t v84;
  uint64_t v85;
  char *v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  char *v90;
  char *v91;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  unint64_t v96;
  uint64_t v97;
  __int128 *v98;
  _OWORD *v99;
  uint64_t v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  char *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  __int128 v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t (***v115)(_QWORD, _QWORD *);
  uint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  uint64_t *v120;
  unsigned int *v121;
  unsigned int *v122;
  unsigned int v123;
  unsigned int v124;
  uint64_t v125;
  unsigned int *v126;
  unsigned int v127;
  unsigned int v128;
  uint64_t v129;
  void *v130;
  uint64_t v131;
  unsigned int *v132;
  unsigned int v133;
  unsigned int v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  char *v148;
  int64_t v149;
  char *v150;
  uint64_t v151;
  uint64_t v152;
  __int128 *v153;
  _OWORD *v154;
  uint64_t v155;
  __int128 v156;
  uint64_t v157;
  unint64_t v158;
  unint64_t v159;
  uint64_t v160;
  char *v161;
  char *v162;
  char *v163;
  int64_t v164;
  unint64_t v165;
  char *v166;
  char *v167;
  uint64_t v168;
  uint64_t v169;
  char *v170;
  __int128 *v171;
  _OWORD *v172;
  uint64_t v173;
  __int128 v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  int v178;
  int v179;
  uint64_t v180;
  uint64_t v181;
  _QWORD *v182;
  uint64_t v183;
  int v184;
  char v185;
  int v186;
  char v187;
  uint64_t v188;
  char v189;
  size_t v190;
  __int128 v191;
  __int128 v192;
  size_t __sz;
  __int128 v194;
  _QWORD v195[3];
  __int128 v196;
  __int128 v197;
  char v198;
  __int128 v199;
  __int128 v200;
  _OWORD v201[2];
  uint64_t v202;
  int v203;
  uint64_t v204;

  v5 = a1;
  v204 = *MEMORY[0x24BDAC8D0];
  v6 = a2[1];
  v7 = a2[2];
  v8 = *a2;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v9 = *((unsigned __int8 *)a2 + 56);
  if (*((_BYTE *)a2 + 56))
  {
    v10 = *((_BYTE *)a2 + 40);
    v202 = *(uint64_t *)((char *)a2 + 41);
    v203 = *(_DWORD *)((char *)a2 + 49);
  }
  else
  {
    v10 = 0;
  }
  v11 = *(_OWORD *)(a2 + 3);
  v12 = *((_BYTE *)a2 + 64);
  v13 = *((_DWORD *)a2 + 17);
  v196 = *(_OWORD *)(a2 + 9);
  v14 = *((unsigned __int8 *)a2 + 232);
  if (*((_BYTE *)a2 + 232))
  {
    v15 = *((_BYTE *)a2 + 88);
    v16 = *(_OWORD *)((char *)a2 + 105);
    v199 = *(_OWORD *)((char *)a2 + 89);
    v200 = v16;
    v201[0] = *(_OWORD *)((char *)a2 + 121);
    *(_QWORD *)((char *)v201 + 13) = *(uint64_t *)((char *)a2 + 134);
    v17 = *((_OWORD *)a2 + 9);
    a2[18] = 0;
    a2[19] = 0;
    v3 = a2[20];
    a1 = (_QWORD *)a2[21];
    a2[20] = 0;
    v2 = a2[22];
    v191 = *(_OWORD *)(a2 + 23);
    v192 = v17;
    a2[23] = 0;
    a2[24] = 0;
    a2[22] = 0;
    v18 = *(_OWORD *)(a2 + 25);
    v198 = *((_BYTE *)a2 + 216);
    v197 = v18;
    v4 = a2[28];
    a2[28] = 0;
  }
  else
  {
    v15 = 0;
  }
  v19 = (char *)v5[21];
  v20 = (char *)v5[22];
  v21 = v20 - v19;
  v22 = a2[30];
  if (v20 == v19)
    v23 = 0;
  else
    v23 = 2 * (v20 - v19) - 1;
  v24 = v5[24];
  if (v23 == v5[25] + v24)
  {
    v25 = v24 >= 0x10;
    v26 = v24 - 16;
    v194 = v11;
    __sz = a2[30];
    v189 = v15;
    v188 = v6;
    v186 = v14;
    v187 = v10;
    v184 = v13;
    v185 = v12;
    v182 = a1;
    v183 = v2;
    v190 = v4;
    if (!v25)
    {
      v178 = v9;
      v30 = v21 >> 3;
      v31 = (char *)v5[23];
      v32 = (char *)v5[20];
      v177 = v3;
      if (v21 >> 3 < (unint64_t)((v31 - v32) >> 3))
      {
        v33 = operator new(0x1000uLL);
        v34 = v33;
        if (v31 != v20)
        {
          v11 = v194;
          if (!v20)
            goto LABEL_156;
          *(_QWORD *)v20 = v33;
          v20 = (char *)(v5[22] + 8);
          v5[22] = v20;
          v9 = v178;
          v3 = v177;
          v4 = v190;
          goto LABEL_90;
        }
        v11 = v194;
        if (v19 == v32)
        {
          v87 = (v31 - v19) >> 2;
          if (v20 == v19)
            v87 = 1;
          if (v87 >> 61)
            goto LABEL_157;
          v88 = (v87 + 3) >> 2;
          v89 = 8 * v87;
          v90 = (char *)operator new(8 * v87);
          v73 = &v90[8 * v88];
          v91 = &v90[v89];
          v92 = v73;
          v11 = v194;
          v4 = v190;
          if (v20 != v19)
          {
            v92 = &v73[8 * v30];
            v93 = &v90[8 * v88];
            v94 = v19;
            if ((unint64_t)(v21 - 8) < 0x38)
              goto LABEL_160;
            v95 = &v90[8 * v88];
            v93 = v95;
            v94 = v19;
            if ((unint64_t)(v95 - v19) < 0x20)
              goto LABEL_160;
            v96 = ((unint64_t)(v21 - 8) >> 3) + 1;
            v97 = 8 * (v96 & 0x3FFFFFFFFFFFFFFCLL);
            v93 = &v73[v97];
            v94 = &v19[v97];
            v98 = (__int128 *)(v19 + 16);
            v99 = v95 + 16;
            v100 = v96 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v101 = *v98;
              *(v99 - 1) = *(v98 - 1);
              *v99 = v101;
              v98 += 2;
              v99 += 2;
              v100 -= 4;
            }
            while (v100);
            if (v96 != (v96 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_160:
              do
              {
                v102 = *(_QWORD *)v94;
                v94 += 8;
                *(_QWORD *)v93 = v102;
                v93 += 8;
              }
              while (v93 != v92);
            }
          }
          v5[20] = v90;
          v5[21] = v73;
          v5[22] = v92;
          v5[23] = v91;
          if (v19)
          {
            operator delete(v19);
            v11 = v194;
            v73 = (char *)v5[21];
          }
        }
        else
        {
          v73 = v19;
          v4 = v190;
        }
        *((_QWORD *)v73 - 1) = v34;
        v103 = (char *)v5[21];
        v104 = (char *)v5[22];
        v5[21] = v103 - 8;
        v105 = *((_QWORD *)v103 - 1);
        v5[21] = v103;
        v9 = v178;
        if (v104 != (char *)v5[23])
          goto LABEL_88;
        v143 = (char *)v5[20];
        if (v103 > v143)
        {
          v144 = (v103 - v143) >> 3;
          if (v144 >= -1)
            v145 = v144 + 1;
          else
            v145 = v144 + 2;
          v146 = v145 >> 1;
          v147 = -v146;
          v148 = &v103[-8 * v146];
          v149 = v104 - v103;
          if (v104 != v103)
          {
            memmove(&v103[-8 * v146], v103, v104 - v103);
            v11 = v194;
            v103 = (char *)v5[21];
          }
          v104 = &v148[v149];
          v5[21] = &v103[8 * v147];
          v5[22] = &v148[v149];
          v9 = v178;
          v4 = v190;
LABEL_89:
          *(_QWORD *)v104 = v105;
          v20 = (char *)(v5[22] + 8);
          v5[22] = v20;
          v3 = v177;
LABEL_90:
          v22 = __sz;
          goto LABEL_91;
        }
        v158 = (v104 - v143) >> 2;
        if (v104 == v143)
          v158 = 1;
        if (!(v158 >> 61))
        {
          v159 = v158 >> 2;
          v160 = 8 * v158;
          v161 = (char *)operator new(8 * v158);
          v162 = &v161[8 * v159];
          v163 = &v161[v160];
          v164 = v104 - v103;
          v80 = v104 == v103;
          v104 = v162;
          v11 = v194;
          v4 = v190;
          if (v80)
            goto LABEL_154;
          v104 = &v162[v164 & 0xFFFFFFFFFFFFFFF8];
          v165 = v164 - 8;
          if ((unint64_t)(v164 - 8) >= 0x38)
          {
            v167 = &v161[8 * v159];
            v166 = v167;
            if ((unint64_t)(v167 - v103) >= 0x20)
            {
              v168 = (v165 >> 3) + 1;
              v169 = 8 * (v168 & 0x3FFFFFFFFFFFFFFCLL);
              v166 = &v162[v169];
              v170 = &v103[v169];
              v171 = (__int128 *)(v103 + 16);
              v172 = v167 + 16;
              v173 = v168 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v174 = *v171;
                *(v172 - 1) = *(v171 - 1);
                *v172 = v174;
                v171 += 2;
                v172 += 2;
                v173 -= 4;
              }
              while (v173);
              v103 = v170;
              if (v168 == (v168 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_154:
                v5[20] = v161;
                v5[21] = v162;
                v5[22] = v104;
                v5[23] = v163;
                v9 = v178;
                if (v143)
                {
                  operator delete(v143);
                  v11 = v194;
                  v104 = (char *)v5[22];
                }
LABEL_88:
                if (!v104)
                  goto LABEL_156;
                goto LABEL_89;
              }
            }
          }
          else
          {
            v166 = &v161[8 * v159];
          }
          do
          {
            v175 = *(_QWORD *)v103;
            v103 += 8;
            *(_QWORD *)v166 = v175;
            v166 += 8;
          }
          while (v166 != v104);
          goto LABEL_154;
        }
LABEL_157:
        std::__throw_bad_array_new_length[abi:sn180100]();
      }
      v181 = v8;
      v176 = v7;
      if (v31 == v32)
        v35 = 1;
      else
        v35 = (v31 - v32) >> 2;
      if (v35 >> 61)
        goto LABEL_157;
      v36 = (char *)operator new(8 * v35);
      v37 = &v36[8 * v30];
      v38 = &v36[8 * v35];
      v39 = operator new(0x1000uLL);
      v40 = v39;
      if (v30 == v35)
      {
        v7 = v176;
        if (v21 < 1)
        {
          v84 = v21 >> 2;
          if (v20 == v19)
            v84 = 1;
          if (v84 >> 61)
            goto LABEL_157;
          v85 = 8 * v84;
          v37 = (char *)operator new(8 * v84);
          operator delete(v36);
          v38 = &v37[v85];
          v86 = (char *)v5[21];
          v20 = (char *)v5[22];
          v36 = v37;
          *(_QWORD *)v37 = v40;
          v42 = v37 + 8;
          v11 = v194;
          if (v20 == v86)
          {
LABEL_29:
            v43 = v37;
            v44 = v42;
            v22 = __sz;
LABEL_30:
            v45 = (void *)v5[20];
            v5[20] = v36;
            v5[21] = v43;
            v20 = v44;
            v5[22] = v44;
            v5[23] = v38;
            v9 = v178;
            v8 = v181;
            v3 = v177;
            v4 = v190;
            if (v45)
            {
              operator delete(v45);
              v11 = v194;
              v20 = (char *)v5[22];
            }
            goto LABEL_91;
          }
        }
        else
        {
          v41 = v30 + 2;
          if (v30 >= -1)
            v41 = v30 + 1;
          v37 -= 8 * (v41 >> 1);
          *(_QWORD *)v37 = v39;
          v42 = v37 + 8;
          v11 = v194;
          if (v20 == v19)
            goto LABEL_29;
        }
      }
      else
      {
        v7 = v176;
        *(_QWORD *)v37 = v39;
        v42 = v37 + 8;
        v11 = v194;
        if (v20 == v19)
          goto LABEL_29;
      }
      v22 = __sz;
      while (1)
      {
        if (v37 == v36)
        {
          if (v42 >= v38)
          {
            v58 = (v38 - v37) >> 2;
            if (v38 == v37)
              v58 = 1;
            if (v58 >> 61)
              goto LABEL_157;
            v59 = (v58 + 3) >> 2;
            v60 = 8 * v58;
            v61 = (char *)operator new(8 * v58);
            v36 = v61;
            v54 = &v61[8 * v59];
            v44 = v54;
            v62 = v42 - v37;
            if (v42 != v37)
            {
              v44 = &v54[v62 & 0xFFFFFFFFFFFFFFF8];
              v63 = v62 - 8;
              v64 = &v61[8 * v59];
              v65 = v37;
              if (v63 < 0x38)
                goto LABEL_161;
              v64 = &v61[8 * v59];
              v65 = v37;
              if ((unint64_t)(v64 - v37) < 0x20)
                goto LABEL_161;
              v66 = (v63 >> 3) + 1;
              v67 = 8 * (v66 & 0x3FFFFFFFFFFFFFFCLL);
              v64 = &v54[v67];
              v65 = &v37[v67];
              v68 = (__int128 *)(v37 + 16);
              v69 = &v61[8 * v59 + 16];
              v70 = v66 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v71 = *v68;
                *((_OWORD *)v69 - 1) = *(v68 - 1);
                *(_OWORD *)v69 = v71;
                v68 += 2;
                v69 += 32;
                v70 -= 4;
              }
              while (v70);
              if (v66 != (v66 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_161:
                do
                {
                  v72 = *(_QWORD *)v65;
                  v65 += 8;
                  *(_QWORD *)v64 = v72;
                  v64 += 8;
                }
                while (v64 != v44);
              }
            }
            v38 = &v61[v60];
            operator delete(v37);
            v11 = v194;
            v22 = __sz;
          }
          else
          {
            v56 = (v38 - v42) >> 3;
            if (v56 >= -1)
              v57 = v56 + 1;
            else
              v57 = v56 + 2;
            v44 = &v42[8 * (v57 >> 1)];
            v54 = &v37[8 * (v57 >> 1)];
            if (v42 == v37)
            {
              v36 = v42;
            }
            else
            {
              memmove(&v37[8 * (v57 >> 1)], v37, v42 - v37);
              v11 = v194;
              v36 = v37;
            }
          }
        }
        else
        {
          v54 = v37;
          v44 = v42;
        }
        v55 = *((_QWORD *)v20 - 1);
        v20 -= 8;
        *((_QWORD *)v54 - 1) = v55;
        v43 = v54 - 8;
        v42 = v44;
        v37 = v43;
        if (v20 == (char *)v5[21])
          goto LABEL_30;
      }
    }
    v27 = v3;
    v180 = v8;
    v5[24] = v26;
    v28 = v19 + 8;
    v29 = *(_QWORD *)v19;
    v5[21] = v19 + 8;
    if (v20 != (char *)v5[23])
      goto LABEL_14;
    v46 = (char *)v5[20];
    if (v28 > v46)
    {
      v47 = (v28 - v46) >> 3;
      if (v47 >= -1)
        v48 = v47 + 1;
      else
        v48 = v47 + 2;
      v49 = v48 >> 1;
      v50 = -v49;
      v51 = &v28[-8 * v49];
      v52 = v20 - v28;
      if (v20 != v28)
      {
        memmove(&v28[-8 * v49], v28, v20 - v28);
        v11 = v194;
        v20 = (char *)v5[21];
      }
      v53 = &v20[8 * v50];
      v20 = &v51[v52];
      v5[21] = v53;
      v5[22] = &v51[v52];
      v3 = v27;
      v22 = __sz;
LABEL_15:
      *(_QWORD *)v20 = v29;
      v20 = (char *)(v5[22] + 8);
      v5[22] = v20;
      v8 = v180;
      v4 = v190;
LABEL_91:
      v19 = (char *)v5[21];
      v15 = v189;
      v6 = v188;
      v14 = v186;
      v10 = v187;
      v13 = v184;
      v12 = v185;
      a1 = v182;
      v2 = v183;
      goto LABEL_92;
    }
    v179 = v9;
    v74 = (v20 - v46) >> 2;
    if (v20 == v46)
      v74 = 1;
    if (v74 >> 61)
      goto LABEL_157;
    v75 = v74 >> 2;
    v76 = 8 * v74;
    v77 = (char *)operator new(8 * v74);
    v78 = &v77[8 * v75];
    v79 = &v77[v76];
    v81 = v20 - v28;
    v80 = v20 == v28;
    v20 = v78;
    v11 = v194;
    v22 = __sz;
    if (!v80)
    {
      v20 = &v78[v81 & 0xFFFFFFFFFFFFFFF8];
      v82 = v81 - 8;
      if ((unint64_t)(v81 - 8) < 0x38)
      {
        v83 = &v77[8 * v75];
        do
        {
LABEL_140:
          v157 = *(_QWORD *)v28;
          v28 += 8;
          *(_QWORD *)v83 = v157;
          v83 += 8;
        }
        while (v83 != v20);
        goto LABEL_141;
      }
      v150 = &v77[8 * v75];
      v83 = v150;
      if ((unint64_t)(v150 - v28) < 0x20)
        goto LABEL_140;
      v151 = (v82 >> 3) + 1;
      v152 = 8 * (v151 & 0x3FFFFFFFFFFFFFFCLL);
      v83 = &v78[v152];
      v28 += v152;
      v153 = (__int128 *)(v19 + 24);
      v154 = v150 + 16;
      v155 = v151 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v156 = *v153;
        *(v154 - 1) = *(v153 - 1);
        *v154 = v156;
        v153 += 2;
        v154 += 2;
        v155 -= 4;
      }
      while (v155);
      if (v151 != (v151 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_140;
    }
LABEL_141:
    v5[20] = v77;
    v5[21] = v78;
    v5[22] = v20;
    v5[23] = v79;
    v9 = v179;
    if (v46)
    {
      operator delete(v46);
      v11 = v194;
      v20 = (char *)v5[22];
    }
LABEL_14:
    v3 = v27;
    if (!v20)
      goto LABEL_156;
    goto LABEL_15;
  }
LABEL_92:
  if (v20 == v19)
    goto LABEL_156;
  v106 = v5[25] + v5[24];
  v107 = *(_QWORD *)&v19[(v106 >> 1) & 0x7FFFFFFFFFFFFFF8];
  if (!v107)
    goto LABEL_156;
  v108 = v106 & 0xF;
  v109 = v107 + (v108 << 8);
  *(_QWORD *)v109 = v8;
  *(_QWORD *)(v109 + 8) = v6;
  *(_QWORD *)(v109 + 16) = v7;
  *(_OWORD *)(v109 + 24) = v11;
  *(_BYTE *)(v109 + 40) = 0;
  *(_BYTE *)(v109 + 56) = 0;
  if (v9)
  {
    *(_BYTE *)(v109 + 40) = v10;
    *(_QWORD *)(v109 + 41) = v202;
    *(_DWORD *)(v109 + 49) = v203;
    *(_BYTE *)(v109 + 56) = 1;
  }
  *(_BYTE *)(v109 + 64) = v12;
  *(_DWORD *)(v109 + 68) = v13;
  *(_OWORD *)(v109 + 72) = v196;
  *(_BYTE *)(v109 + 88) = 0;
  *(_BYTE *)(v109 + 232) = 0;
  if (v14)
  {
    v110 = v200;
    *(_OWORD *)(v109 + 89) = v199;
    *(_BYTE *)(v109 + 88) = v15;
    *(_OWORD *)(v109 + 105) = v110;
    *(_OWORD *)(v109 + 121) = v201[0];
    *(_QWORD *)(v109 + 134) = *(_QWORD *)((char *)v201 + 13);
    *(_OWORD *)(v109 + 144) = v192;
    *(_QWORD *)(v109 + 160) = v3;
    *(_QWORD *)(v109 + 168) = a1;
    *(_QWORD *)(v109 + 176) = v2;
    *(_OWORD *)(v109 + 184) = v191;
    *(_OWORD *)(v109 + 200) = v197;
    *(_BYTE *)(v109 + 216) = v198;
    *(_QWORD *)(v109 + 224) = v4;
    *(_BYTE *)(v109 + 232) = 1;
  }
  *(_QWORD *)(v109 + 240) = v22;
  *(_BYTE *)(v107 + (v108 << 8) + 248) = 0;
  v112 = v5[24];
  v111 = v5[25];
  v5[25] = v111 + 1;
  v113 = v111 + v112;
  v114 = *(_QWORD *)(v5[21] + ((v113 >> 1) & 0x7FFFFFFFFFFFFFF8));
  v115 = (uint64_t (***)(_QWORD, _QWORD *))v5[10];
  v195[0] = v7;
  v195[1] = v11;
  v195[2] = v114 + ((v113 & 0xF) << 8);
  v116 = (**v115)(v115, v195);
  if ((v116 & 1) == 0)
  {
    v117 = v5[25];
    if (v117)
    {
      v118 = v117 + v5[24] - 1;
      v119 = *(_QWORD *)(v5[21] + ((v118 >> 1) & 0x7FFFFFFFFFFFFFF8));
      if (v119)
      {
        v120 = (uint64_t *)(v119 + ((v118 & 0xF) << 8));
        if (*((_BYTE *)v120 + 232))
        {
          v121 = (unsigned int *)v120[28];
          if (v121)
          {
            v122 = v121 + 2;
            do
            {
              v123 = __ldaxr(v122);
              v124 = v123 - 1;
            }
            while (__stlxr(v124, v122));
            if (!v124)
              (*(void (**)(unsigned int *))(*(_QWORD *)v121 + 8))(v121);
          }
          v125 = v120[22];
          if (v125)
          {
            v126 = (unsigned int *)(v125 + 24);
            do
            {
              v127 = __ldaxr(v126);
              v128 = v127 - 1;
            }
            while (__stlxr(v128, v126));
            if (!v128)
            {
              v129 = *(_QWORD *)(v125 + 16);
              *(_QWORD *)(v125 + 16) = 0;
              if (v129)
                MEMORY[0x20BD0ADD4](v129, 0x1000C8077774924);
              MEMORY[0x20BD0ADEC](v125, 0x1010C40EE34DA14);
            }
          }
          v130 = (void *)v120[18];
          if (v130)
          {
            v120[19] = (uint64_t)v130;
            operator delete(v130);
          }
        }
        v131 = *v120;
        if (*v120)
        {
          v132 = (unsigned int *)(v131 + 24);
          do
          {
            v133 = __ldaxr(v132);
            v134 = v133 - 1;
          }
          while (__stlxr(v134, v132));
          if (!v134)
          {
            v135 = *(_QWORD *)(v131 + 16);
            *(_QWORD *)(v131 + 16) = 0;
            if (v135)
              MEMORY[0x20BD0ADD4](v135, 0x1000C8077774924);
            MEMORY[0x20BD0ADEC](v131, 0x1010C40EE34DA14);
          }
        }
        v137 = v5[21];
        v136 = v5[22];
        v138 = v136 - v137;
        v80 = v136 == v137;
        v140 = v5[24];
        v139 = v5[25];
        v5[25] = v139 - 1;
        v141 = 2 * v138 - 1;
        if (v80)
          v141 = 0;
        if ((unint64_t)(v141 - (v139 + v140) + 1) >= 0x20)
        {
          operator delete(*(void **)(v136 - 8));
          v5[22] -= 8;
        }
        ++v5[27];
        return v116;
      }
    }
LABEL_156:
    __break(1u);
  }
  return v116;
}

uint64_t webrtc::FakeNetworkPipe::DeliverRtcpPacket(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  char v27;
  char v28;
  uint64_t v29;
  _QWORD v30[8];
  void *__p;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v21 = *a2;
  v3 = *((_QWORD *)a2 + 2);
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  v4 = (pthread_mutex_t *)(a1 + 96);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
  v22 = v21;
  v23 = v3;
  v24 = v5;
  v25 = v5;
  v26 = 0;
  v27 = 0;
  v28 = 1;
  v35 = 0;
  v36 = 0;
  v30[0] = 0;
  v29 = 0;
  *(_QWORD *)((char *)v30 + 5) = 0;
  webrtc::FakeNetworkPipe::EnqueuePacket((_QWORD *)a1, (uint64_t *)&v22);
  if (v35)
  {
    v6 = v34;
    if (v34)
    {
      v7 = (unsigned int *)(v34 + 8);
      do
      {
        v8 = __ldaxr(v7);
        v9 = v8 - 1;
      }
      while (__stlxr(v9, v7));
      if (!v9)
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    }
    v10 = v33;
    if (v33)
    {
      v11 = (unsigned int *)(v33 + 24);
      do
      {
        v12 = __ldaxr(v11);
        v13 = v12 - 1;
      }
      while (__stlxr(v13, v11));
      if (!v13)
      {
        v14 = *(_QWORD *)(v10 + 16);
        *(_QWORD *)(v10 + 16) = 0;
        if (v14)
          MEMORY[0x20BD0ADD4](v14, 0x1000C8077774924);
        MEMORY[0x20BD0ADEC](v10, 0x1010C40EE34DA14);
      }
    }
    if (__p)
    {
      v32 = __p;
      operator delete(__p);
    }
  }
  v15 = v22;
  if ((_QWORD)v22)
  {
    v16 = (unsigned int *)(v22 + 24);
    do
    {
      v17 = __ldaxr(v16);
      v18 = v17 - 1;
    }
    while (__stlxr(v18, v16));
    if (!v18)
    {
      v19 = *(_QWORD *)(v15 + 16);
      *(_QWORD *)(v15 + 16) = 0;
      if (v19)
        MEMORY[0x20BD0ADD4](v19, 0x1000C8077774924);
      MEMORY[0x20BD0ADEC](v15, 0x1010C40EE34DA14);
    }
  }
  return pthread_mutex_unlock(v4);
}

uint64_t webrtc::FakeNetworkPipe::AverageDelay(webrtc::FakeNetworkPipe *this)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (pthread_mutex_t *)((char *)this + 96);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 96));
  v3 = *((_QWORD *)this + 28);
  if (v3)
  {
    v4 = *((_QWORD *)this + 29) / (1000 * v3);
    pthread_mutex_unlock(v2);
    return v4;
  }
  else
  {
    pthread_mutex_unlock(v2);
    return 0;
  }
}

void webrtc::FakeNetworkPipe::Process(webrtc::FakeNetworkPipe *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  void **v16;
  void **v17;
  void **v18;
  uint64_t v19;
  unint64_t v20;
  char **v21;
  char *v22;
  uint64_t *v23;
  uint64_t v24;
  char *v25;
  __int128 v26;
  pthread_mutex_t *v27;
  __n128 v28;
  unint64_t v29;
  unint64_t v30;
  unsigned int *v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  void **v52;
  void *v53;
  void *v54;
  unint64_t v55;
  char *v56;
  char *v57;
  void *v58;
  void *v59;
  unint64_t v60;
  char *v61;
  void **v62;
  uint64_t v63;
  unint64_t v64;
  char *v65;
  unint64_t v66;
  uint64_t v67;
  char *v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  char *v76;
  int64_t v77;
  unint64_t v78;
  char *v79;
  char *v80;
  uint64_t v81;
  uint64_t v82;
  __int128 *v83;
  char *v84;
  uint64_t v85;
  __int128 v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  void **v90;
  void **v91;
  char *v92;
  int64_t v93;
  unint64_t v94;
  char *v95;
  void **v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  void **v100;
  BOOL v101;
  char *v102;
  void **v103;
  unint64_t v104;
  uint64_t v105;
  __int128 *v106;
  char *v107;
  uint64_t v108;
  __int128 v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  _BYTE *v115;
  uint64_t v116;
  uint64_t v117;
  unsigned int *v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int *v121;
  unsigned int v122;
  unsigned int v123;
  uint64_t v124;
  unsigned int *v125;
  unsigned int v126;
  unsigned int v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  __int128 *v132;
  void **v133;
  uint64_t v134;
  __int128 v135;
  unint64_t v136;
  _QWORD *v137;
  uint64_t v138;
  char *v139;
  uint64_t v140;
  char *v141;
  uint64_t v142;
  char *v143;
  char *v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  uint64_t v148;
  __int128 v149;
  uint64_t v150;
  uint64_t v151;
  _BYTE *v152;
  unint64_t v153;
  char *v154;
  unsigned int *v155;
  unsigned int *v156;
  unsigned int v157;
  unsigned int v158;
  char *v159;
  uint64_t v160;
  unsigned int *v161;
  unsigned int v162;
  unsigned int v163;
  uint64_t v164;
  void *v165;
  uint64_t v166;
  unsigned int *v167;
  unsigned int v168;
  unsigned int v169;
  uint64_t v170;
  unint64_t v171;
  unint64_t v172;
  _QWORD *v173;
  char *v174;
  unint64_t v175;
  BOOL v176;
  _QWORD *v177;
  uint64_t v178;
  uint64_t v179;
  void *v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  unsigned int *v185;
  unsigned int v186;
  unsigned int v187;
  uint64_t v188;
  uint64_t v189;
  const void *v190;
  int64_t v191;
  char *v192;
  char *v193;
  unsigned int *v194;
  unsigned int v195;
  unsigned int *v196;
  unsigned int v197;
  __n128 v198;
  uint64_t v199;
  unsigned int *v200;
  unsigned int v201;
  unsigned int v202;
  uint64_t v203;
  unsigned int *v204;
  unsigned int v205;
  unsigned int v206;
  uint64_t v207;
  uint64_t v208;
  unsigned int *v209;
  unsigned int v210;
  unsigned int v211;
  uint64_t v212;
  unsigned int *v213;
  unsigned int v214;
  unsigned int v215;
  uint64_t v216;
  uint64_t v217;
  unsigned int *v218;
  unsigned int v219;
  unsigned int v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t *v223;
  unint64_t v224;
  void *v225;
  void *v226;
  uint64_t v227;
  pthread_mutex_t *v228;
  unint64_t v229;
  void **__p;
  char *__pa;
  void **__pb;
  uint64_t v233;
  _QWORD *v234;
  uint64_t v235;
  _QWORD *v236;
  char v237;
  char v238;
  __int128 v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  __int128 v244;
  int v245;
  char v246;
  int v247;
  pthread_mutex_t *v248;
  char *v249;
  uint64_t v250;
  pthread_mutex_t *v251;
  unsigned int *v252;
  int v253;
  uint64_t v254;
  uint64_t v255;
  char *v256;
  _OWORD v257[2];
  _QWORD v258[9];
  char v259;
  char v260;
  unsigned int v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  _BYTE v265[22];
  void *v266[2];
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  __int128 v270;
  __int128 v271;
  char v272;
  uint64_t v273;
  char v274;
  unint64_t v275;
  __n128 v276;
  __n128 (*v277)(uint64_t, __n128 *, __n128 *);
  uint64_t (*v278)();
  void *v279[2];
  __int128 v280;
  _BYTE v281[22];
  void *v282;
  void *v283;
  char *v284;
  uint64_t v285;
  uint64_t v286;
  __int128 v287;
  __int128 v288;
  char v289;
  uint64_t v290;
  uint64_t v291;
  int v292;
  char v293;
  uint64_t v294;

  v294 = *MEMORY[0x24BDAC8D0];
  v228 = (pthread_mutex_t *)((char *)this + 96);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 96));
  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
  if (v2 - *((_QWORD *)this + 30) >= 5000001)
  {
    if (*((_QWORD *)this + 25))
    {
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
      {
LABEL_5:
        *((_QWORD *)this + 30) = v2;
        goto LABEL_6;
      }
    }
    else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    {
      goto LABEL_5;
    }
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)3,long long>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*> const&)::t, v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/call/fake_network_pipe.cc");
    goto LABEL_5;
  }
LABEL_6:
  (*(void (**)(void **__return_ptr, _QWORD, uint64_t))(**((_QWORD **)this + 10) + 8))(v279, *((_QWORD *)this + 10), v2);
  v14 = v279[0];
  v236 = v279[1];
  if (v279[0] != v279[1])
  {
    v15 = 0;
    v249 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    while (1)
    {
      v19 = *((_QWORD *)this + 21);
      if (*((_QWORD *)this + 22) == v19)
        goto LABEL_306;
      v20 = *((_QWORD *)this + 24);
      v21 = (char **)(v19 + 8 * (v20 >> 4));
      v22 = *v21;
      v23 = (uint64_t *)&(*v21)[256 * (v20 & 0xF)];
      v24 = *(_QWORD *)(v19 + (((*((_QWORD *)this + 25) + v20) >> 1) & 0x7FFFFFFFFFFFFFF8))
          + (((*((_QWORD *)this + 25) + v20) & 0xF) << 8);
      if (v23 != (uint64_t *)v24)
      {
        while ((uint64_t *)v14[1] != v23)
        {
          v23 += 32;
          if ((char *)v23 - v22 == 4096)
          {
            v25 = v21[1];
            ++v21;
            v22 = v25;
            v23 = (uint64_t *)v25;
          }
          if (v23 == (uint64_t *)v24)
            goto LABEL_306;
        }
      }
      if (v23 == (uint64_t *)v24)
        goto LABEL_306;
      v255 = *v23;
      v244 = *(_OWORD *)(v23 + 1);
      *v23 = 0;
      v23[1] = 0;
      v23[2] = 0;
      v247 = *((unsigned __int8 *)v23 + 56);
      if (*((_BYTE *)v23 + 56))
      {
        v238 = *((_BYTE *)v23 + 40);
        v291 = *(uint64_t *)((char *)v23 + 41);
        v292 = *(_DWORD *)((char *)v23 + 49);
      }
      else
      {
        v238 = 0;
      }
      v241 = v23[4];
      v242 = v23[3];
      v246 = *((_BYTE *)v23 + 64);
      v245 = *((_DWORD *)v23 + 17);
      v257[0] = *(_OWORD *)(v23 + 9);
      v253 = *((unsigned __int8 *)v23 + 232);
      if (*((_BYTE *)v23 + 232))
      {
        v237 = *((_BYTE *)v23 + 88);
        v26 = *(_OWORD *)((char *)v23 + 105);
        *(_OWORD *)&v258[2] = *(_OWORD *)((char *)v23 + 89);
        *(_OWORD *)&v258[4] = v26;
        *(_OWORD *)&v258[6] = *(_OWORD *)((char *)v23 + 121);
        *(_QWORD *)((char *)&v258[7] + 5) = *(uint64_t *)((char *)v23 + 134);
        v27 = (pthread_mutex_t *)v23[18];
        v248 = (pthread_mutex_t *)v23[19];
        v23[18] = 0;
        v23[19] = 0;
        v240 = v23[20];
        v235 = v23[21];
        v23[20] = 0;
        v254 = v23[22];
        v239 = *(_OWORD *)(v23 + 23);
        v23[23] = 0;
        v23[24] = 0;
        v23[22] = 0;
        v28 = *(__n128 *)(v23 + 25);
        LOBYTE(v277) = *((_BYTE *)v23 + 216);
        v276 = v28;
        v251 = v27;
        v252 = (unsigned int *)v23[28];
        v23[28] = 0;
        v243 = v23[30];
        *((_BYTE *)v23 + 248) = 1;
        if (!*((_QWORD *)this + 25))
          goto LABEL_52;
      }
      else
      {
        v237 = 0;
        v243 = v23[30];
        *((_BYTE *)v23 + 248) = 1;
        if (!*((_QWORD *)this + 25))
          goto LABEL_52;
      }
      v29 = *((_QWORD *)this + 24);
      do
      {
        v30 = *(_QWORD *)(*((_QWORD *)this + 21) + ((v29 >> 1) & 0x7FFFFFFFFFFFFFF8)) + ((v29 & 0xF) << 8);
        if (!*(_BYTE *)(v30 + 248))
          break;
        if (*(_BYTE *)(v30 + 232))
        {
          v31 = *(unsigned int **)(v30 + 224);
          if (v31)
          {
            v32 = v31 + 2;
            do
            {
              v33 = __ldaxr(v32);
              v34 = v33 - 1;
            }
            while (__stlxr(v34, v32));
            if (!v34)
              (*(void (**)(unsigned int *))(*(_QWORD *)v31 + 8))(v31);
          }
          v35 = *(_QWORD *)(v30 + 176);
          if (v35)
          {
            v36 = (unsigned int *)(v35 + 24);
            do
            {
              v37 = __ldaxr(v36);
              v38 = v37 - 1;
            }
            while (__stlxr(v38, v36));
            if (!v38)
            {
              v39 = *(_QWORD *)(v35 + 16);
              *(_QWORD *)(v35 + 16) = 0;
              if (v39)
                MEMORY[0x20BD0ADD4](v39, 0x1000C8077774924);
              MEMORY[0x20BD0ADEC](v35, 0x1010C40EE34DA14);
            }
          }
          v40 = *(void **)(v30 + 144);
          if (v40)
          {
            *(_QWORD *)(v30 + 152) = v40;
            operator delete(v40);
          }
        }
        v41 = *(_QWORD *)v30;
        if (*(_QWORD *)v30)
        {
          v42 = (unsigned int *)(v41 + 24);
          do
          {
            v43 = __ldaxr(v42);
            v44 = v43 - 1;
          }
          while (__stlxr(v44, v42));
          if (!v44)
          {
            v45 = *(_QWORD *)(v41 + 16);
            *(_QWORD *)(v41 + 16) = 0;
            if (v45)
              MEMORY[0x20BD0ADD4](v45, 0x1000C8077774924);
            MEMORY[0x20BD0ADEC](v41, 0x1010C40EE34DA14);
          }
        }
        v46 = *((_QWORD *)this + 25) - 1;
        v29 = *((_QWORD *)this + 24) + 1;
        *((_QWORD *)this + 24) = v29;
        *((_QWORD *)this + 25) = v46;
        if (v29 >= 0x20)
        {
          operator delete(**((void ***)this + 21));
          *((_QWORD *)this + 21) += 8;
          v46 = *((_QWORD *)this + 25);
          v29 = *((_QWORD *)this + 24) - 16;
          *((_QWORD *)this + 24) = v29;
        }
      }
      while (v46);
LABEL_52:
      v47 = *v14;
      if (*v14 != -1)
      {
        v48 = 2 * ((char *)v16 - (char *)v17) - 1;
        v49 = (char *)v16 - (char *)v17;
        if (v16 == v17)
          v48 = 0;
        if (v48 != v15)
        {
          if (v16 == v17)
            goto LABEL_305;
          goto LABEL_140;
        }
        v50 = v49 >> 3;
        v234 = v14;
        v233 = *v14;
        if (v49 >> 3 < (unint64_t)((v249 - (char *)v18) >> 3))
        {
          v51 = v15;
          v52 = v18;
          v53 = operator new(0xF80uLL);
          v54 = v53;
          if (v249 != (char *)v16)
          {
            v47 = v233;
            if (!v16)
              goto LABEL_305;
            *v16++ = v53;
            v18 = v52;
            v15 = v51;
            if (v16 == v17)
              goto LABEL_305;
            goto LABEL_140;
          }
          if (v17 != v52)
          {
            *(v17 - 1) = v53;
            v62 = v17;
            goto LABEL_81;
          }
          v98 = (v249 - (char *)v17) >> 2;
          if (v16 == v17)
            v98 = 1;
          if (v98 >> 61)
            goto LABEL_307;
          v99 = (v98 + 3) >> 2;
          v250 = v98;
          v100 = (void **)operator new(8 * v98);
          v52 = v100;
          v62 = &v100[v99];
          v101 = v16 == v17;
          v65 = (char *)v62;
          if (!v101)
          {
            v65 = (char *)&v62[v50];
            v102 = (char *)&v100[v99];
            v103 = v17;
            if ((unint64_t)(v49 - 8) < 0x38)
              goto LABEL_312;
            v102 = (char *)&v100[v99];
            v103 = v17;
            if ((unint64_t)(v102 - (char *)v17) < 0x20)
              goto LABEL_312;
            v104 = ((unint64_t)(v49 - 8) >> 3) + 1;
            v105 = v104 & 0x3FFFFFFFFFFFFFFCLL;
            v102 = (char *)&v62[v105];
            v103 = &v17[v105];
            v106 = (__int128 *)(v17 + 2);
            v107 = (char *)&v100[v99 + 2];
            v108 = v104 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v109 = *v106;
              *((_OWORD *)v107 - 1) = *(v106 - 1);
              *(_OWORD *)v107 = v109;
              v106 += 2;
              v107 += 32;
              v108 -= 4;
            }
            while (v108);
            if (v104 != (v104 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_312:
              do
              {
                v110 = (uint64_t)*v103++;
                *(_QWORD *)v102 = v110;
                v102 += 8;
              }
              while (v102 != v65);
            }
          }
          v14 = v234;
          if (v17)
            operator delete(v17);
          v91 = v52;
          *(v62 - 1) = v54;
          v249 = (char *)&v52[v250];
          if (v65 != v249)
          {
LABEL_138:
            v17 = v62;
            v52 = v91;
            if (!v65)
              goto LABEL_305;
LABEL_139:
            *(_QWORD *)v65 = v54;
            v16 = (void **)(v65 + 8);
            v18 = v52;
            v15 = v51;
            v47 = v233;
            if (v16 == v17)
              goto LABEL_305;
            goto LABEL_140;
          }
LABEL_81:
          if (v62 > v52)
          {
            v63 = v62 - v52;
            if (v63 >= -1)
              v64 = v63 + 1;
            else
              v64 = v63 + 2;
            v17 = &v62[-(v64 >> 1)];
            if (v249 != (char *)v62)
              memmove(v17, v62, v249 - (char *)v62);
            v65 = (char *)v17 + v249 - (char *)v62;
            goto LABEL_139;
          }
          v88 = (v249 - (char *)v52) >> 2;
          if (v249 == (char *)v52)
            v88 = 1;
          if (v88 >> 61)
            goto LABEL_307;
          v89 = v88 >> 2;
          __pa = (char *)(8 * v88);
          v90 = (void **)operator new(8 * v88);
          v91 = v90;
          v92 = (char *)&v90[v89];
          v65 = v92;
          v93 = v249 - (char *)v62;
          if (v249 != (char *)v62)
          {
            v65 = &v92[v93 & 0xFFFFFFFFFFFFFFF8];
            v94 = v93 - 8;
            if (v94 < 0x38 || (unint64_t)((char *)&v90[v89] - (char *)v62) < 0x20)
            {
              v95 = (char *)&v90[v89];
              v96 = v62;
              goto LABEL_121;
            }
            v130 = (v94 >> 3) + 1;
            v131 = v130 & 0x3FFFFFFFFFFFFFFCLL;
            v95 = &v92[v131 * 8];
            v96 = &v62[v131];
            v132 = (__int128 *)(v62 + 2);
            v133 = &v90[v89 + 2];
            v134 = v130 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v135 = *v132;
              *((_OWORD *)v133 - 1) = *(v132 - 1);
              *(_OWORD *)v133 = v135;
              v132 += 2;
              v133 += 4;
              v134 -= 4;
            }
            while (v134);
            if (v130 != (v130 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_121:
                v97 = (uint64_t)*v96++;
                *(_QWORD *)v95 = v97;
                v95 += 8;
              }
              while (v95 != v65);
            }
          }
          v249 = &__pa[(_QWORD)v90];
          if (v52)
            operator delete(v52);
          v62 = (void **)v92;
          v14 = v234;
          goto LABEL_138;
        }
        v229 = v15;
        __p = v18;
        if (v249 == (char *)v18)
          v55 = 1;
        else
          v55 = (v249 - (char *)v18) >> 2;
        if (v55 >> 61)
          goto LABEL_307;
        v56 = (char *)operator new(8 * v55);
        v57 = &v56[8 * v50];
        v249 = &v56[8 * v55];
        v58 = operator new(0xF80uLL);
        v59 = v58;
        if (v50 == v55)
        {
          if (v49 >= 1)
          {
            v60 = v50 + 2;
            if (v50 >= -1)
              v60 = v50 + 1;
            v57 -= 8 * (v60 >> 1);
            goto LABEL_74;
          }
          v66 = v49 >> 2;
          if (v16 == v17)
            v66 = 1;
          if (v66 >> 61)
            goto LABEL_307;
          v67 = 8 * v66;
          v57 = (char *)operator new(8 * v66);
          operator delete(v56);
          v249 = &v57[v67];
          v56 = v57;
          *(_QWORD *)v57 = v59;
          v61 = v57 + 8;
          while (v16 != v17)
          {
LABEL_95:
            if (v57 == v56)
            {
              if (v61 >= v249)
              {
                v73 = (v249 - v57) >> 2;
                if (v249 == v57)
                  v73 = 1;
                if (v73 >> 61)
                  goto LABEL_307;
                v74 = (v73 + 3) >> 2;
                v75 = 8 * v73;
                v76 = (char *)operator new(8 * v73);
                v56 = v76;
                v68 = &v76[8 * v74];
                v69 = v68;
                v77 = v61 - v57;
                if (v61 != v57)
                {
                  v69 = &v68[v77 & 0xFFFFFFFFFFFFFFF8];
                  v78 = v77 - 8;
                  v79 = &v76[8 * v74];
                  v80 = v57;
                  if (v78 < 0x38)
                    goto LABEL_313;
                  v79 = &v76[8 * v74];
                  v80 = v57;
                  if ((unint64_t)(v79 - v57) < 0x20)
                    goto LABEL_313;
                  v81 = (v78 >> 3) + 1;
                  v82 = 8 * (v81 & 0x3FFFFFFFFFFFFFFCLL);
                  v79 = &v68[v82];
                  v80 = &v57[v82];
                  v83 = (__int128 *)(v57 + 16);
                  v84 = &v76[8 * v74 + 16];
                  v85 = v81 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    v86 = *v83;
                    *((_OWORD *)v84 - 1) = *(v83 - 1);
                    *(_OWORD *)v84 = v86;
                    v83 += 2;
                    v84 += 32;
                    v85 -= 4;
                  }
                  while (v85);
                  if (v81 != (v81 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_313:
                    do
                    {
                      v87 = *(_QWORD *)v80;
                      v80 += 8;
                      *(_QWORD *)v79 = v87;
                      v79 += 8;
                    }
                    while (v79 != v69);
                  }
                }
                v249 = &v76[v75];
                operator delete(v57);
                v14 = v234;
              }
              else
              {
                v71 = (v249 - v61) >> 3;
                if (v71 >= -1)
                  v72 = v71 + 1;
                else
                  v72 = v71 + 2;
                v69 = &v61[8 * (v72 >> 1)];
                v68 = &v57[8 * (v72 >> 1)];
                if (v61 == v57)
                {
                  v56 = v61;
                }
                else
                {
                  memmove(&v57[8 * (v72 >> 1)], v57, v61 - v57);
                  v56 = v57;
                }
              }
            }
            else
            {
              v68 = v57;
              v69 = v61;
            }
            v70 = (uint64_t)*--v16;
            *((_QWORD *)v68 - 1) = v70;
            v57 = v68 - 8;
            v61 = v69;
          }
        }
        else
        {
LABEL_74:
          *(_QWORD *)v57 = v58;
          v61 = v57 + 8;
          if (v16 != v17)
            goto LABEL_95;
        }
        if (__p)
          operator delete(__p);
        v16 = (void **)v61;
        v17 = (void **)v57;
        v18 = (void **)v56;
        v15 = v229;
        v47 = v233;
        if (v61 == (char *)v17)
        {
LABEL_305:
          __break(1u);
LABEL_306:
          rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/call/fake_network_pipe.cc", 272, "packet_it != packets_in_flight_.end()", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v10, v11, v12, v13, v227);
LABEL_307:
          std::__throw_bad_array_new_length[abi:sn180100]();
        }
LABEL_140:
        v111 = *(uint64_t *)((char *)v17 + ((v15 >> 1) & 0x7FFFFFFFFFFFFFF8));
        if (!v111)
          goto LABEL_305;
        v112 = v47 - v242;
        v113 = v111 + 248 * (v15 & 0xF);
        *(_QWORD *)v113 = v255;
        *(_OWORD *)(v113 + 8) = v244;
        *(_QWORD *)(v113 + 24) = v242;
        *(_QWORD *)(v113 + 32) = v112 + v241;
        *(_BYTE *)(v113 + 40) = 0;
        v114 = v113 + 40;
        *(_BYTE *)(v113 + 56) = 0;
        v115 = (_BYTE *)(v113 + 56);
        if (v247)
        {
          *(_BYTE *)v114 = v238;
          *(_QWORD *)(v114 + 1) = v291;
          *(_DWORD *)(v114 + 9) = v292;
          *v115 = 1;
        }
        v116 = v111 + 248 * (v15 & 0xF);
        *(_BYTE *)(v116 + 88) = 0;
        v117 = v116 + 88;
        *(_BYTE *)(v117 - 24) = v246;
        *(_DWORD *)(v117 - 20) = v245;
        *(_OWORD *)(v117 - 16) = v257[0];
        *(_BYTE *)(v117 + 144) = 0;
        if (v253)
        {
          *(_BYTE *)v117 = v237;
          *(_OWORD *)(v117 + 1) = *(_OWORD *)&v258[2];
          *(_OWORD *)(v117 + 17) = *(_OWORD *)&v258[4];
          *(_OWORD *)(v117 + 33) = *(_OWORD *)&v258[6];
          *(_QWORD *)(v117 + 46) = *(_QWORD *)((char *)&v258[7] + 5);
          *(_QWORD *)(v117 + 56) = v251;
          *(_QWORD *)(v117 + 64) = v248;
          *(_QWORD *)(v117 + 72) = v240;
          *(_QWORD *)(v117 + 80) = v235;
          *(_QWORD *)(v117 + 88) = v254;
          *(_OWORD *)(v117 + 96) = v239;
          *(__n128 *)(v117 + 112) = v276;
          *(_BYTE *)(v117 + 128) = (_BYTE)v277;
          *(_QWORD *)(v117 + 136) = v252;
          *(_BYTE *)(v117 + 144) = 1;
          v239 = 0u;
          v248 = 0;
          v251 = 0;
          v252 = 0;
          v254 = 0;
          v240 = 0;
        }
        v255 = 0;
        *(_QWORD *)(v111 + 248 * (v15++ & 0xF) + 240) = v243;
        *((_QWORD *)this + 29) += v112;
        ++*((_QWORD *)this + 28);
        if (!v253)
          goto LABEL_160;
LABEL_146:
        if (v252)
        {
          v118 = v252 + 2;
          do
          {
            v119 = __ldaxr(v118);
            v120 = v119 - 1;
          }
          while (__stlxr(v120, v118));
          if (!v120)
            (*(void (**)(unsigned int *))(*(_QWORD *)v252 + 8))(v252);
        }
        if (v254)
        {
          v121 = (unsigned int *)(v254 + 24);
          do
          {
            v122 = __ldaxr(v121);
            v123 = v122 - 1;
          }
          while (__stlxr(v123, v121));
          if (!v123)
          {
            v124 = *(_QWORD *)(v254 + 16);
            *(_QWORD *)(v254 + 16) = 0;
            if (v124)
              MEMORY[0x20BD0ADD4](v124, 0x1000C8077774924);
            MEMORY[0x20BD0ADEC](v254, 0x1010C40EE34DA14);
          }
        }
        if (v251)
        {
          operator delete(v251);
          v248 = v251;
        }
        goto LABEL_160;
      }
      ++*((_QWORD *)this + 27);
      if (v253)
        goto LABEL_146;
LABEL_160:
      if (v255)
      {
        v125 = (unsigned int *)(v255 + 24);
        do
        {
          v126 = __ldaxr(v125);
          v127 = v126 - 1;
        }
        while (__stlxr(v127, v125));
        v128 = v255;
        if (!v127)
        {
          v129 = *(_QWORD *)(v255 + 16);
          *(_QWORD *)(v255 + 16) = 0;
          if (v129)
          {
            MEMORY[0x20BD0ADD4](v129, 0x1000C8077774924);
            v128 = v255;
          }
          MEMORY[0x20BD0ADEC](v128, 0x1010C40EE34DA14);
        }
      }
      v14 += 2;
      if (v14 == v236)
      {
        v14 = v279[0];
        if (v279[0])
          goto LABEL_171;
        goto LABEL_172;
      }
    }
  }
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  if (v279[0])
  {
LABEL_171:
    v279[1] = v14;
    operator delete(v14);
  }
LABEL_172:
  pthread_mutex_unlock(v228);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  if (v15)
  {
    v136 = 0;
    v256 = (char *)this + 256;
    __pb = v18;
    do
    {
      v137 = v17[v136 >> 4];
      v138 = v136 & 0xF;
      v139 = (char *)&v137[31 * v138];
      v140 = *(_QWORD *)v139;
      *(_QWORD *)v139 = 0;
      v258[2] = v140;
      *(_OWORD *)&v258[3] = *(_OWORD *)(v139 + 8);
      *((_QWORD *)v139 + 1) = 0;
      *((_QWORD *)v139 + 2) = 0;
      *(_OWORD *)&v258[5] = *(_OWORD *)(v139 + 24);
      LOBYTE(v258[7]) = 0;
      v259 = 0;
      if (v139[56])
      {
        v141 = (char *)&v137[31 * v138];
        v142 = *((_QWORD *)v141 + 5);
        *(_QWORD *)((char *)&v258[7] + 5) = *(_QWORD *)(v141 + 45);
        v258[7] = v142;
        v259 = 1;
      }
      v143 = (char *)&v137[31 * v138];
      v260 = v143[64];
      v261 = *((_DWORD *)v143 + 17);
      v262 = *(_OWORD *)(v143 + 72);
      LOBYTE(v263) = 0;
      v274 = 0;
      if (v143[232])
      {
        v144 = (char *)&v137[31 * v138];
        v145 = *(_OWORD *)(v144 + 88);
        v146 = *(_OWORD *)(v144 + 104);
        v147 = *(_OWORD *)(v144 + 120);
        *(_QWORD *)&v265[14] = *(_QWORD *)(v144 + 134);
        v264 = v146;
        *(_OWORD *)v265 = v147;
        v263 = v145;
        *(_OWORD *)v266 = *((_OWORD *)v144 + 9);
        v267 = *((_QWORD *)v144 + 20);
        *((_QWORD *)v144 + 18) = 0;
        *((_QWORD *)v144 + 19) = 0;
        *((_QWORD *)v144 + 20) = 0;
        v268 = *((_QWORD *)v144 + 21);
        v148 = *((_QWORD *)v144 + 22);
        *((_QWORD *)v144 + 22) = 0;
        v269 = v148;
        v270 = *(_OWORD *)(v144 + 184);
        *((_QWORD *)v144 + 23) = 0;
        *((_QWORD *)v144 + 24) = 0;
        v149 = *(_OWORD *)(v144 + 200);
        v272 = v144[216];
        v271 = v149;
        v150 = *((_QWORD *)v144 + 28);
        *((_QWORD *)v144 + 28) = 0;
        v273 = v150;
        v274 = 1;
      }
      v151 = 248 * v138;
      v275 = v137[31 * v138 + 30];
      v152 = v17[v136 >> 4];
      if (!v152)
        goto LABEL_305;
      v153 = v15;
      if (v152[248 * v138 + 232])
      {
        v154 = &v152[248 * v138];
        v155 = (unsigned int *)*((_QWORD *)v154 + 28);
        if (v155)
        {
          v156 = v155 + 2;
          do
          {
            v157 = __ldaxr(v156);
            v158 = v157 - 1;
          }
          while (__stlxr(v158, v156));
          if (!v158)
            (*(void (**)(unsigned int *))(*(_QWORD *)v155 + 8))(v155);
        }
        v159 = v154 + 88;
        v160 = *((_QWORD *)v154 + 22);
        if (v160)
        {
          v161 = (unsigned int *)(v160 + 24);
          do
          {
            v162 = __ldaxr(v161);
            v163 = v162 - 1;
          }
          while (__stlxr(v163, v161));
          if (!v163)
          {
            v164 = *(_QWORD *)(v160 + 16);
            *(_QWORD *)(v160 + 16) = 0;
            if (v164)
              MEMORY[0x20BD0ADD4](v164, 0x1000C8077774924);
            MEMORY[0x20BD0ADEC](v160, 0x1010C40EE34DA14);
          }
        }
        v165 = (void *)*((_QWORD *)v159 + 7);
        if (v165)
        {
          *((_QWORD *)v159 + 8) = v165;
          operator delete(v165);
        }
      }
      v166 = *(_QWORD *)&v152[v151];
      if (v166)
      {
        v167 = (unsigned int *)(v166 + 24);
        do
        {
          v168 = __ldaxr(v167);
          v169 = v168 - 1;
        }
        while (__stlxr(v169, v167));
        if (!v169)
        {
          v170 = *(_QWORD *)(v166 + 16);
          *(_QWORD *)(v166 + 16) = 0;
          if (v170)
            MEMORY[0x20BD0ADD4](v170, 0x1000C8077774924);
          MEMORY[0x20BD0ADEC](v166, 0x1010C40EE34DA14);
        }
      }
      if (v136 + 1 >= 0x20)
      {
        v180 = *v17++;
        operator delete(v180);
        v136 -= 15;
        v171 = v153;
        v172 = v275;
        if (v275)
        {
LABEL_205:
          v173 = *(_QWORD **)v256;
          if (*(_QWORD *)v256)
          {
            v174 = (char *)this + 256;
            do
            {
              v175 = v173[4];
              v176 = v175 >= v172;
              if (v175 >= v172)
                v177 = v173;
              else
                v177 = v173 + 1;
              if (v176)
                v174 = (char *)v173;
              v173 = (_QWORD *)*v177;
            }
            while (*v177);
            if (v174 != v256 && v172 >= *((_QWORD *)v174 + 4))
            {
              v178 = v258[2];
              if (v260)
              {
                if (v258[2])
                  v178 = *(_QWORD *)(v258[2] + 16) + v258[3];
                if (v258[4])
                  v179 = v178;
                else
                  v179 = 0;
                (*(void (**)(unint64_t, uint64_t))(*(_QWORD *)v172 + 8))(v172, v179);
                if (!v274)
                  goto LABEL_278;
              }
              else
              {
                if (v258[2])
                  v178 = *(_QWORD *)(v258[2] + 16) + v258[3];
                if (v258[4])
                  v222 = v178;
                else
                  v222 = 0;
                v291 = -1;
                v292 = 0;
                v293 = 0;
                v223 = &v258[7];
                if (!v259)
                  v223 = &v291;
                v258[0] = *v223;
                *(_QWORD *)((char *)v258 + 5) = *(uint64_t *)((char *)v223 + 5);
                (**(void (***)(unint64_t, uint64_t))v172)(v172, v222);
                if (!v274)
                  goto LABEL_278;
              }
              goto LABEL_264;
            }
          }
          goto LABEL_263;
        }
      }
      else
      {
        ++v136;
        v171 = v153;
        v172 = v275;
        if (v275)
          goto LABEL_205;
      }
      v181 = *((_QWORD *)this + 11);
      if (v181)
      {
        v182 = -1;
        if (BYTE8(v262) && (_QWORD)v262 != -1)
        {
          if ((uint64_t)(v258[6] - v258[5]) < 0)
            rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/call/fake_network_pipe.cc", 329, "queue_time_us >= 0", _ZZN3rtc18webrtc_checks_impl11LogStreamerIJEE4CallIJEEEvPKciS5_DpRKT_E1t, v10, v11, v12, v13, v227);
          v182 = v258[6] - v258[5] + v262 + 1000 * *((_QWORD *)this + 26);
        }
        if (v260)
        {
          v183 = v258[2];
          memset(&v258[2], 0, 24);
          *(_QWORD *)&v257[0] = v183;
          *(_OWORD *)((char *)v257 + 8) = *(_OWORD *)&v258[3];
          (**(void (***)(uint64_t, _OWORD *))v181)(v181, v257);
          v184 = *(_QWORD *)&v257[0];
          if (*(_QWORD *)&v257[0])
          {
            v185 = (unsigned int *)(*(_QWORD *)&v257[0] + 24);
            do
            {
              v186 = __ldaxr(v185);
              v187 = v186 - 1;
            }
            while (__stlxr(v187, v185));
            if (!v187)
            {
              v188 = *(_QWORD *)(v184 + 16);
              *(_QWORD *)(v184 + 16) = 0;
              if (v188)
                MEMORY[0x20BD0ADD4](v188, 0x1000C8077774924);
              MEMORY[0x20BD0ADEC](v184, 0x1010C40EE34DA14);
              if (!v274)
                goto LABEL_278;
LABEL_264:
              v208 = v273;
              if (v273)
              {
                v209 = (unsigned int *)(v273 + 8);
                do
                {
                  v210 = __ldaxr(v209);
                  v211 = v210 - 1;
                }
                while (__stlxr(v211, v209));
                if (!v211)
                  (*(void (**)(uint64_t))(*(_QWORD *)v208 + 8))(v208);
              }
              v212 = v269;
              if (v269)
              {
                v213 = (unsigned int *)(v269 + 24);
                do
                {
                  v214 = __ldaxr(v213);
                  v215 = v214 - 1;
                }
                while (__stlxr(v215, v213));
                if (!v215)
                {
                  v216 = *(_QWORD *)(v212 + 16);
                  *(_QWORD *)(v212 + 16) = 0;
                  if (v216)
                    MEMORY[0x20BD0ADD4](v216, 0x1000C8077774924);
                  MEMORY[0x20BD0ADEC](v212, 0x1010C40EE34DA14);
                }
              }
              if (v266[0])
              {
                v266[1] = v266[0];
                operator delete(v266[0]);
              }
              goto LABEL_278;
            }
          }
        }
        else
        {
          if (!v274)
            goto LABEL_278;
          *(_QWORD *)&v271 = v182;
          v189 = v261;
          *(_OWORD *)v279 = v263;
          v280 = v264;
          *(_OWORD *)v281 = *(_OWORD *)v265;
          *(_QWORD *)&v281[14] = *(_QWORD *)&v265[14];
          v283 = 0;
          v284 = 0;
          v282 = 0;
          v190 = v266[0];
          v191 = (char *)v266[1] - (char *)v266[0];
          if (v266[1] != v266[0])
          {
            if (v191 < 0)
              abort();
            v192 = (char *)operator new((char *)v266[1] - (char *)v266[0]);
            v193 = &v192[4 * (v191 >> 2)];
            v282 = v192;
            v284 = v193;
            memcpy(v192, v190, v191);
            v283 = v193;
            v171 = v153;
          }
          v285 = v268;
          v286 = v269;
          if (v269)
          {
            v194 = (unsigned int *)(v269 + 24);
            do
              v195 = __ldxr(v194);
            while (__stxr(v195 + 1, v194));
          }
          v287 = v270;
          v288 = v271;
          v289 = v272;
          v290 = v273;
          v18 = __pb;
          if (v273)
          {
            v196 = (unsigned int *)(v273 + 8);
            do
              v197 = __ldxr(v196);
            while (__stxr(v197 + 1, v196));
          }
          v278 = absl::internal_any_invocable::LocalInvoker<false,BOOL,webrtc::FakeNetworkPipe::DeliverNetworkPacket(webrtc::NetworkPacket *)::$_0 &,webrtc::RtpPacketReceived const&>;
          v277 = absl::internal_any_invocable::LocalManagerTrivial;
          (*(void (**)(uint64_t, uint64_t, void **, __n128 *))(*(_QWORD *)v181 + 8))(v181, v189, v279, &v276);
          v198 = v277(1, &v276, &v276);
          v199 = v290;
          if (v290)
          {
            v200 = (unsigned int *)(v290 + 8);
            do
            {
              v201 = __ldaxr(v200);
              v202 = v201 - 1;
            }
            while (__stlxr(v202, v200));
            if (!v202)
              (*(void (**)(uint64_t, __n128))(*(_QWORD *)v199 + 8))(v199, v198);
          }
          v203 = v286;
          if (v286)
          {
            v204 = (unsigned int *)(v286 + 24);
            do
            {
              v205 = __ldaxr(v204);
              v206 = v205 - 1;
            }
            while (__stlxr(v206, v204));
            if (!v206)
            {
              v207 = *(_QWORD *)(v203 + 16);
              *(_QWORD *)(v203 + 16) = 0;
              if (v207)
                MEMORY[0x20BD0ADD4](v207, 0x1000C8077774924, v198);
              MEMORY[0x20BD0ADEC](v203, 0x1010C40EE34DA14, v198);
            }
          }
          if (v282)
          {
            v283 = v282;
            operator delete(v282);
          }
        }
      }
LABEL_263:
      if (v274)
        goto LABEL_264;
LABEL_278:
      v217 = v258[2];
      if (v258[2])
      {
        v218 = (unsigned int *)(v258[2] + 24);
        do
        {
          v219 = __ldaxr(v218);
          v220 = v219 - 1;
        }
        while (__stlxr(v220, v218));
        if (!v220)
        {
          v221 = *(_QWORD *)(v217 + 16);
          *(_QWORD *)(v217 + 16) = 0;
          if (v221)
            MEMORY[0x20BD0ADD4](v221, 0x1000C8077774924);
          MEMORY[0x20BD0ADEC](v217, 0x1010C40EE34DA14);
        }
      }
      v15 = v171 - 1;
    }
    while (v15);
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 16));
  v224 = (char *)v16 - (char *)v17;
  if ((unint64_t)((char *)v16 - (char *)v17) >= 0x11)
  {
    do
    {
      v225 = *v17++;
      operator delete(v225);
      v224 -= 8;
    }
    while (v224 > 0x10);
  }
  while (v17 != v16)
  {
    v226 = *v17++;
    operator delete(v226);
  }
  if (v18)
    operator delete(v18);
}

uint64_t webrtc::FakeNetworkPipe::TimeUntilNextProcess(webrtc::FakeNetworkPipe *this)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = (pthread_mutex_t *)((char *)this + 96);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 96));
  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 16))(*((_QWORD *)this + 10));
  if (v4)
  {
    v5 = v3;
    v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1));
    v7 = ((v5 - v6 + 500) / 1000) & ~(((v5 - v6 + 500) / 1000) >> 63) & 0x7FFFFFFFFFFFFF00;
    v8 = (((v5 - v6 + 500) / 1000) & ~(((v5 - v6 + 500) / 1000) >> 63));
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  pthread_mutex_unlock(v2);
  return v7 | v8;
}

void std::deque<webrtc::FakeNetworkPipe::StoredPacket>::clear(_QWORD *a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  void **v5;
  char *v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  char *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  if (v3 == v2)
  {
    a1[5] = 0;
    v24 = 0;
  }
  else
  {
    v4 = a1[4];
    v5 = &v2[v4 >> 4];
    v6 = (char *)*v5 + 256 * (v4 & 0xF);
    v7 = *(uint64_t *)((char *)v2 + (((a1[5] + v4) >> 1) & 0x7FFFFFFFFFFFFFF8)) + 256 * ((a1[5] + v4) & 0xF);
    if (v6 != (char *)v7)
    {
      while (v6)
      {
        if (v6[232])
        {
          v8 = (unsigned int *)*((_QWORD *)v6 + 28);
          if (v8)
          {
            v9 = v8 + 2;
            do
            {
              v10 = __ldaxr(v9);
              v11 = v10 - 1;
            }
            while (__stlxr(v11, v9));
            if (!v11)
              (*(void (**)(unsigned int *))(*(_QWORD *)v8 + 8))(v8);
          }
          v12 = *((_QWORD *)v6 + 22);
          if (v12)
          {
            v13 = (unsigned int *)(v12 + 24);
            do
            {
              v14 = __ldaxr(v13);
              v15 = v14 - 1;
            }
            while (__stlxr(v15, v13));
            if (!v15)
            {
              v16 = *(_QWORD *)(v12 + 16);
              *(_QWORD *)(v12 + 16) = 0;
              if (v16)
                MEMORY[0x20BD0ADD4](v16, 0x1000C8077774924);
              MEMORY[0x20BD0ADEC](v12, 0x1010C40EE34DA14);
            }
          }
          v17 = (void *)*((_QWORD *)v6 + 18);
          if (v17)
          {
            *((_QWORD *)v6 + 19) = v17;
            operator delete(v17);
          }
        }
        v18 = *(_QWORD *)v6;
        if (*(_QWORD *)v6)
        {
          v19 = (unsigned int *)(v18 + 24);
          do
          {
            v20 = __ldaxr(v19);
            v21 = v20 - 1;
          }
          while (__stlxr(v21, v19));
          if (!v21)
          {
            v22 = *(_QWORD *)(v18 + 16);
            *(_QWORD *)(v18 + 16) = 0;
            if (v22)
              MEMORY[0x20BD0ADD4](v22, 0x1000C8077774924);
            MEMORY[0x20BD0ADEC](v18, 0x1010C40EE34DA14);
          }
        }
        v6 += 256;
        if (v6 - (_BYTE *)*v5 == 4096)
        {
          v23 = (char *)v5[1];
          ++v5;
          v6 = v23;
        }
        if (v6 == (char *)v7)
        {
          v2 = (void **)a1[1];
          v3 = (void **)a1[2];
          goto LABEL_31;
        }
      }
      __break(1u);
      return;
    }
LABEL_31:
    a1[5] = 0;
    v24 = (char *)v3 - (char *)v2;
    if (v24 >= 0x11)
    {
      do
      {
        operator delete(*v2);
        v25 = a1[2];
        v2 = (void **)(a1[1] + 8);
        a1[1] = v2;
        v24 = v25 - (_QWORD)v2;
      }
      while (v24 > 0x10);
    }
  }
  if (v24 >> 3 == 1)
  {
    v26 = 8;
  }
  else
  {
    if (v24 >> 3 != 2)
      return;
    v26 = 16;
  }
  a1[4] = v26;
}

uint64_t absl::internal_any_invocable::LocalInvoker<false,BOOL,webrtc::FakeNetworkPipe::DeliverNetworkPacket(webrtc::NetworkPacket *)::$_0 &,webrtc::RtpPacketReceived const&>()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)4,unsigned int>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)1,int> const&)::t, v0, v1, v2, v3, v4, v5, v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/call/fake_network_pipe.cc");
  return 0;
}

uint64_t webrtc::rnn_vad::FeaturesExtractor::FeaturesExtractor(uint64_t a1, __int16 *a2)
{
  _QWORD *v4;
  char *v5;
  char *v6;
  __int16 v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  void *v14;
  uint64_t v15;

  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 20) = 1065167899;
  *(_QWORD *)(a1 + 24) = 0;
  v4 = (_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 32) = 0;
  v5 = (char *)operator new(0xD80uLL);
  *(_QWORD *)(a1 + 48) = v5 + 3456;
  *(_QWORD *)(a1 + 56) = v5 + 3456;
  *(_QWORD *)(a1 + 40) = v5;
  bzero(v5, 0xD80uLL);
  *(_QWORD *)(a1 + 64) = v5;
  v6 = (char *)operator new(0xD80uLL);
  *(_QWORD *)(a1 + 72) = v6;
  *(_QWORD *)(a1 + 88) = v6 + 3456;
  bzero(v6, 0xD80uLL);
  *(_QWORD *)(a1 + 80) = v6 + 3456;
  *(_QWORD *)(a1 + 96) = v6;
  v7 = *a2;
  *(_BYTE *)(a1 + 106) = *((_BYTE *)a2 + 2);
  *(_WORD *)(a1 + 104) = v7;
  *(_QWORD *)(a1 + 108) = 0;
  webrtc::rnn_vad::AutoCorrelationCalculator::AutoCorrelationCalculator((webrtc::rnn_vad::AutoCorrelationCalculator *)(a1 + 120));
  v8 = (char *)operator new(0x604uLL);
  *(_QWORD *)(a1 + 176) = v8;
  v9 = v8 + 1540;
  *(_QWORD *)(a1 + 192) = v8 + 1540;
  bzero(v8, 0x604uLL);
  *(_QWORD *)(a1 + 184) = v9;
  v10 = (char *)operator new(0x6C0uLL);
  *(_QWORD *)(a1 + 200) = v10;
  v11 = v10 + 1728;
  *(_QWORD *)(a1 + 216) = v10 + 1728;
  bzero(v10, 0x6C0uLL);
  *(_QWORD *)(a1 + 208) = v11;
  v12 = (char *)operator new(0x24CuLL);
  *(_QWORD *)(a1 + 224) = v12;
  v13 = v12 + 588;
  *(_QWORD *)(a1 + 240) = v12 + 588;
  bzero(v12, 0x24CuLL);
  *(_QWORD *)(a1 + 232) = v13;
  *(_QWORD *)(a1 + 248) = *(_QWORD *)(a1 + 40) + 1536;
  webrtc::rnn_vad::SpectralFeaturesExtractor::SpectralFeaturesExtractor((webrtc::rnn_vad::SpectralFeaturesExtractor *)(a1 + 256));
  v14 = *(void **)(a1 + 40);
  v15 = *(_QWORD *)(a1 + 48) - (_QWORD)v14;
  if (v15 >= 1)
    bzero(v14, 4 * (((unint64_t)v15 >> 2) - ((unint64_t)v15 > 3)) + 4);
  bzero((void *)(a1 + 3476), 0x384uLL);
  if (*(_BYTE *)a1)
  {
    *v4 = 0;
    v4[1] = 0;
  }
  return a1;
}

void webrtc::rnn_vad::FeaturesExtractor::~FeaturesExtractor(webrtc::rnn_vad::FeaturesExtractor *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  webrtc::rnn_vad::SpectralFeaturesExtractor::~SpectralFeaturesExtractor((webrtc::rnn_vad::FeaturesExtractor *)((char *)this + 256));
  v2 = (void *)*((_QWORD *)this + 28);
  if (v2)
  {
    *((_QWORD *)this + 29) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 25);
  if (v3)
  {
    *((_QWORD *)this + 26) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 22);
  if (v4)
  {
    *((_QWORD *)this + 23) = v4;
    operator delete(v4);
  }
  webrtc::rnn_vad::AutoCorrelationCalculator::~AutoCorrelationCalculator((webrtc::rnn_vad::FeaturesExtractor *)((char *)this + 120));
  v5 = (void *)*((_QWORD *)this + 9);
  if (v5)
  {
    *((_QWORD *)this + 10) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 5);
  if (v6)
  {
    *((_QWORD *)this + 6) = v6;
    operator delete(v6);
  }
}

BOOL webrtc::rnn_vad::FeaturesExtractor::CheckSilenceComputeFeatures(uint64_t a1, float *a2, float32x2_t *a3)
{
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  void *v18;
  float *v19;
  double v20;
  int8x16_t v21;
  double v22;
  double v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  int v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  float v32[240];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)a1)
  {
    v6 = 0;
    v7 = *(float *)(a1 + 4);
    v8 = *(float *)(a1 + 8);
    v9 = *(float *)(a1 + 32);
    v10 = *(float *)(a1 + 36);
    v11 = *(float *)(a1 + 24);
    v12 = *(float *)(a1 + 28);
    v13 = *(float *)(a1 + 12);
    v14 = -*(float *)(a1 + 16);
    v15 = -*(float *)(a1 + 20);
    do
    {
      v16 = v11;
      v11 = a2[v6];
      v17 = v9;
      v9 = (float)((float)((float)((float)(v8 * v16) + (float)(v7 * v11)) + (float)(v13 * v12)) + (float)(v14 * v9))
         + (float)(v15 * v10);
      v32[v6++] = v9;
      v12 = v16;
      v10 = v17;
    }
    while (v6 != 240);
    *(float *)(a1 + 32) = v9;
    *(float *)(a1 + 36) = v17;
    *(float *)(a1 + 24) = v11;
    *(float *)(a1 + 28) = v16;
    memmove(*(void **)(a1 + 40), (const void *)(*(_QWORD *)(a1 + 40) + 960), 0x9C0uLL);
    v18 = (void *)(*(_QWORD *)(a1 + 40) + 2496);
    v19 = v32;
  }
  else
  {
    memmove(*(void **)(a1 + 40), (const void *)(*(_QWORD *)(a1 + 40) + 960), 0x9C0uLL);
    v18 = (void *)(*(_QWORD *)(a1 + 40) + 2496);
    v19 = a2;
  }
  memcpy(v18, v19, 0x3C0uLL);
  webrtc::rnn_vad::ComputeAndPostProcessLpcCoefficients(*(float **)(a1 + 64), 864, v32, v20, v21, v22, v23, v24, v25, v26);
  webrtc::rnn_vad::ComputeLpResidual(v32, *(_QWORD *)(a1 + 64), 864, *(_QWORD *)(a1 + 96), 0x360uLL);
  v27 = webrtc::rnn_vad::PitchEstimator::Estimate((uint64_t *)(a1 + 104), *(_QWORD *)(a1 + 96));
  *(_DWORD *)(a1 + 4376) = v27;
  a3[20].f32[0] = (float)(v27 - 300) * 0.01;
  if (v27 >= 0)
    v28 = v27;
  else
    v28 = v27 + 1;
  v29 = 384 - (v28 >> 1);
  if (v29 > 0x35F)
    v30 = 0;
  else
    v30 = *(_QWORD *)(a1 + 64) + 4 * v29;
  return webrtc::rnn_vad::SpectralFeaturesExtractor::CheckSilenceComputeFeatures((float32x4_t *)(a1 + 256), *(_QWORD *)(a1 + 248), v30, (uint64_t)&a3[3], (float *)a3, (float *)&a3[11], (float *)&a3[14], a3 + 17, (float *)&a3[20] + 1);
}

uint64_t webrtc::FecControllerDefault::FecControllerDefault(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t *v5;
  unsigned int *v6;
  unsigned int v7;
  __int128 v8;
  uint64_t v9;
  pthread_mutexattr_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = &off_24C0B3F10;
  v4 = *a2;
  *(_QWORD *)(a1 + 8) = *a2;
  v5 = (uint64_t *)(a1 + 8);
  if (v4)
  {
    v6 = (unsigned int *)(v4 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  v8 = *(_OWORD *)(a2 + 3);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 1);
  *(_OWORD *)(a1 + 32) = v8;
  *(_QWORD *)(a1 + 48) = a3;
  pthread_mutexattr_init(&v11);
  pthread_mutexattr_setpolicy_np(&v11, 3);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 56), &v11);
  pthread_mutexattr_destroy(&v11);
  v9 = operator new();
  *(_QWORD *)(a1 + 120) = webrtc::media_optimization::VCMLossProtectionLogic::VCMLossProtectionLogic(v9, v5);
  *(_QWORD *)(a1 + 128) = 1460;
  *(float *)(a1 + 136) = webrtc::FecControllerDefault::GetProtectionOverheadRateThreshold((webrtc::FecControllerDefault *)a1);
  return a1;
}

float webrtc::FecControllerDefault::GetProtectionOverheadRateThreshold(webrtc::FecControllerDefault *this)
{
  void **v1;
  float v2;
  float v3;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *__p[2];
  char v23;

  (*(void (**)(void **__return_ptr, _QWORD, const char *, uint64_t))(**((_QWORD **)this + 2) + 16))(__p, *((_QWORD *)this + 2), "WebRTC-ProtectionOverheadRateThreshold", 38);
  if (v23 >= 0)
    v1 = __p;
  else
    v1 = (void **)__p[0];
  v2 = strtof((const char *)v1, 0);
  if ((v23 & 0x80000000) == 0)
  {
    v3 = 1.0;
    if (v2 > 0.0 && v2 <= 1.0)
      goto LABEL_22;
LABEL_10:
    v5 = v2 >= 0.0 && v2 <= v3;
    if (!v5 && (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      rtc::webrtc_logging_impl::Log("\r\t", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/fec_controller_default.cc");
    return 0.5;
  }
  operator delete(__p[0]);
  v3 = 1.0;
  if (v2 <= 0.0 || v2 > 1.0)
    goto LABEL_10;
LABEL_22:
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    return v2;
  rtc::webrtc_logging_impl::Log("\r\t\a", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/fec_controller_default.cc");
  return v2;
}

void webrtc::FecControllerDefault::~FecControllerDefault(webrtc::FecControllerDefault *this)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int **v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;

  *(_QWORD *)this = &off_24C0B3F10;
  v2 = *((_QWORD *)this + 15);
  v3 = *(_QWORD *)(v2 + 40);
  *(_QWORD *)(v2 + 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (unsigned int **)*((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;
  if (v4)
  {
    v5 = v4[5];
    v4[5] = 0;
    if (v5)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v5 + 8))(v5);
      v6 = v4[5];
      v4[5] = 0;
      if (v6)
        (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
    v7 = *v4;
    if (*v4)
    {
      v8 = v7 + 2;
      do
      {
        v9 = __ldaxr(v8);
        v10 = v9 - 1;
      }
      while (__stlxr(v10, v8));
      if (!v10)
        (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
    }
    MEMORY[0x20BD0ADEC](v4, 0x1060C401E828CA0);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 56));
  v11 = (unsigned int *)*((_QWORD *)this + 1);
  if (v11)
  {
    v12 = v11 + 2;
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      (*(void (**)(unsigned int *))(*(_QWORD *)v11 + 8))(v11);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  unsigned int **v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;

  *(_QWORD *)this = &off_24C0B3F10;
  v2 = *((_QWORD *)this + 15);
  v3 = *(_QWORD *)(v2 + 40);
  *(_QWORD *)(v2 + 40) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (unsigned int **)*((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;
  if (v4)
  {
    v5 = v4[5];
    v4[5] = 0;
    if (v5)
    {
      (*(void (**)(unsigned int *))(*(_QWORD *)v5 + 8))(v5);
      v6 = v4[5];
      v4[5] = 0;
      if (v6)
        (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
    v7 = *v4;
    if (*v4)
    {
      v8 = v7 + 2;
      do
      {
        v9 = __ldaxr(v8);
        v10 = v9 - 1;
      }
      while (__stlxr(v10, v8));
      if (!v10)
        (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
    }
    MEMORY[0x20BD0ADEC](v4, 0x1060C401E828CA0);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 56));
  v11 = (unsigned int *)*((_QWORD *)this + 1);
  if (v11)
  {
    v12 = v11 + 2;
    do
    {
      v13 = __ldaxr(v12);
      v14 = v13 - 1;
    }
    while (__stlxr(v14, v12));
    if (!v14)
      (*(void (**)(unsigned int *))(*(_QWORD *)v11 + 8))(v11);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FecControllerDefault::SetProtectionCallback(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = a2;
  return result;
}

uint64_t webrtc::FecControllerDefault::SetEncodingData(webrtc::FecControllerDefault *this, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  pthread_mutex_t *v10;
  uint64_t v11;
  int v12;

  v10 = (pthread_mutex_t *)((char *)this + 56);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 56));
  v11 = *((_QWORD *)this + 15);
  *(_QWORD *)(v11 + 360) = a2;
  *(_QWORD *)(v11 + 368) = a3;
  if (a4 <= 1)
    v12 = 1;
  else
    v12 = a4;
  *(_DWORD *)(v11 + 376) = v12;
  *((_QWORD *)this + 16) = a5;
  return pthread_mutex_unlock(v10);
}

uint64_t webrtc::FecControllerDefault::UpdateFecRates(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  float v10;
  int v11;
  pthread_mutex_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  float v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  float v26;
  int v28;
  uint64_t v29;
  _DWORD v30[3];
  _DWORD v31[3];

  v8 = a2;
  v10 = (float)a2 / 1000.0;
  if (a3 <= 1)
    v11 = 1;
  else
    v11 = a3;
  v12 = (pthread_mutex_t *)(a1 + 56);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  v13 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(v13 + 96) = a6;
  *(float *)(v13 + 108) = v10;
  *(float *)(v13 + 112) = (float)v11;
  v14 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 16))(*(_QWORD *)(a1 + 24));
  v15 = v14 / 0x3E8uLL;
  if (v14 % 0x3E8uLL > 0x1F3)
    ++v15;
  if (-v14 % 0x3E8uLL <= 0x1F4)
    v16 = 0;
  else
    v16 = -1;
  if (v14 < 0)
    v17 = v16 - -v14 / 0x3E8uLL;
  else
    v17 = v15;
  v18 = webrtc::media_optimization::VCMLossProtectionLogic::FilteredLoss(v13, v17, 2, a4);
  v19 = *(_QWORD *)(a1 + 120);
  v20 = (float)v18 / 255.0;
  *(float *)(v19 + 104) = v20;
  v21 = *(_DWORD **)(v19 + 40);
  if (v21 && v21[7] != 3)
  {
    *(_QWORD *)(v19 + 48) = *(_QWORD *)(v19 + 96);
    v22 = v19 + 48;
    *(_BYTE *)(v22 + 32) = *(_BYTE *)(v22 + 73);
    *(_BYTE *)(v22 + 33) = *(_BYTE *)(v22 + 72);
    v23 = *(_QWORD *)(v22 + 320);
    *(_WORD *)(v22 + 34) = *(_QWORD *)(v22 + 312);
    v24 = *(_DWORD *)(v22 + 60);
    *(float *)(v22 + 8) = v20;
    *(_DWORD *)(v22 + 12) = v24;
    *(_QWORD *)(v22 + 24) = *(_QWORD *)(v22 + 64);
    v25 = *(_DWORD *)(v22 + 300);
    *(_DWORD *)(v22 + 16) = *(_DWORD *)(v22 + 288);
    *(_DWORD *)(v22 + 20) = v25;
    *(_WORD *)(v22 + 36) = v23;
    *(_DWORD *)(v22 + 40) = *(_DWORD *)(v22 + 328);
    (*(void (**)(_DWORD *))(*(_QWORD *)v21 + 16))(v21);
    v30[0] = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 120) + 40) + 32))(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 40));
    v31[0] = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 120) + 40) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 40));
    v31[1] = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 120) + 40) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 40));
    v30[1] = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 120) + 40) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 40));
    pthread_mutex_unlock(v12);
    v31[2] = 0;
    v30[2] = 0;
    v29 = 0;
    v28 = 0;
    (***(void (****)(_QWORD, _DWORD *, _DWORD *, char *, uint64_t *, int *))(a1 + 48))(*(_QWORD *)(a1 + 48), v31, v30, (char *)&v29 + 4, &v29, &v28);
    if (v28 + (_DWORD)v29 + HIDWORD(v29))
      v26 = (float)(v28 + v29) / (float)(v28 + v29 + HIDWORD(v29));
    else
      v26 = 0.0;
    if (*(float *)(a1 + 136) < v26)
      v26 = *(float *)(a1 + 136);
    return ((1.0 - v26) * (double)v8);
  }
  else
  {
    pthread_mutex_unlock(v12);
  }
  return v8;
}

uint64_t webrtc::FecControllerDefault::SetProtectionMethod(webrtc::FecControllerDefault *this, int a2, int a3)
{
  int v4;
  int v5;
  int v6;
  pthread_mutex_t *v7;

  if ((a2 & a3) != 0)
    v4 = 2;
  else
    v4 = 0;
  if (a2)
    v5 = 1;
  else
    v5 = 3;
  if (a3)
    v6 = v4;
  else
    v6 = v5;
  v7 = (pthread_mutex_t *)((char *)this + 56);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 56));
  webrtc::media_optimization::VCMLossProtectionLogic::SetMethod(*((_QWORD **)this + 15), v6);
  return pthread_mutex_unlock(v7);
}

uint64_t webrtc::FecControllerDefault::UpdateWithEncodedData(uint64_t a1, unint64_t a2, int a3)
{
  pthread_mutex_t *v6;
  unint64_t v7;
  float v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  float v16;
  uint64_t v17;
  float v18;
  float v19;
  uint64_t v21;
  unint64_t v22;
  float v23;
  uint64_t v24;
  float v25;
  float v26;

  v6 = (pthread_mutex_t *)(a1 + 56);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  if (a2)
  {
    v7 = *(_QWORD *)(a1 + 128);
    if (v7)
    {
      v8 = (float)a2;
      v9 = (float)a2 / (float)v7;
      v10 = *(_QWORD *)(a1 + 120);
      v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 16))(*(_QWORD *)(a1 + 24));
      v12 = v11 / 0x3E8uLL;
      v13 = v11 % 0x3E8uLL;
      if (a3 == 3)
      {
        if (v13 > 0x1F3)
          ++v12;
        if (-v11 % 0x3E8uLL <= 0x1F4)
          v14 = 0;
        else
          v14 = -1;
        if (v11 < 0)
          v15 = v14 - -v11 / 0x3E8uLL;
        else
          v15 = v12;
        v16 = *(float *)(v10 + 348);
        if (v16 != -1.0)
        {
          v17 = v15 - *(_QWORD *)(v10 + 144);
          v18 = *(float *)(v10 + 344);
          if (v17 != 1)
            v18 = powf(v18, (float)v17);
          v9 = (float)(v9 * (float)(1.0 - v18)) + (float)(v18 * v16);
        }
        v19 = *(float *)(v10 + 352);
        if (v9 <= v19 || v19 == -1.0)
          v19 = v9;
        *(float *)(v10 + 348) = v19;
        *(_QWORD *)(v10 + 144) = v15;
        goto LABEL_25;
      }
      if (v13 > 0x1F3)
        ++v12;
      if (-v11 % 0x3E8uLL <= 0x1F4)
        v21 = 0;
      else
        v21 = -1;
      if (v11 < 0)
        v22 = v21 - -v11 / 0x3E8uLL;
      else
        v22 = v12;
      v23 = *(float *)(v10 + 336);
      if (v23 != -1.0)
      {
        v24 = v22 - *(_QWORD *)(v10 + 136);
        v25 = *(float *)(v10 + 332);
        if (v24 != 1)
          v25 = powf(v25, (float)v24);
        v9 = (float)(v9 * (float)(1.0 - v25)) + (float)(v25 * v23);
      }
      v26 = *(float *)(v10 + 340);
      if (v9 <= v26 || v26 == -1.0)
        v26 = v9;
      *(float *)(v10 + 336) = v26;
      *(_QWORD *)(v10 + 136) = v22;
    }
    else if (a3 == 3)
    {
      v8 = (float)a2;
LABEL_25:
      *(float *)(*(_QWORD *)(a1 + 120) + 116) = v8;
    }
  }
  return pthread_mutex_unlock(v6);
}

uint64_t webrtc::FecControllerDefault::UseLossVectorMask(webrtc::FecControllerDefault *this)
{
  return 0;
}

uint64_t *rtc::CopyOnWriteBuffer::SetData<unsigned char,(void *)0>(uint64_t *result, void *__src, uint64_t *__n)
{
  uint64_t *v5;
  unsigned int v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  size_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  unsigned int *v16;
  unsigned int v17;
  _QWORD *v18;
  unsigned int *v19;
  unsigned int v20;
  BOOL v21;
  uint64_t *v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t v27;
  size_t v28;

  v5 = result;
  if (!*result)
  {
    if (!__n)
    {
      *result = 0;
      goto LABEL_42;
    }
    v14 = operator new();
    *(_QWORD *)v14 = __n;
    *(_QWORD *)(v14 + 8) = __n;
    v15 = (void *)operator new[]();
    *(_QWORD *)(v14 + 16) = v15;
    result = (uint64_t *)memcpy(v15, __src, (size_t)__n);
    *(_DWORD *)(v14 + 24) = 0;
    v16 = (unsigned int *)(v14 + 24);
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    v18 = (_QWORD *)*v5;
    if (!*v5)
      goto LABEL_36;
    v19 = (unsigned int *)(v18 + 3);
    do
    {
      v20 = __ldaxr(v19);
      v21 = --v20 == 0;
    }
    while (__stlxr(v20, v19));
    goto LABEL_31;
  }
  v6 = atomic_load((unsigned int *)(*result + 24));
  if (v6 != 1)
  {
    v14 = operator new();
    v22 = (uint64_t *)*v5;
    if (*v5)
      v22 = (uint64_t *)(v22[1] - v5[1]);
    if (__n <= v22)
      result = v22;
    else
      result = __n;
    *(_QWORD *)v14 = __n;
    *(_QWORD *)(v14 + 8) = result;
    if (result)
      result = (uint64_t *)operator new[]();
    *(_QWORD *)(v14 + 16) = result;
    if (__n)
      result = (uint64_t *)memcpy(result, __src, (size_t)__n);
    *(_DWORD *)(v14 + 24) = 0;
    v23 = (unsigned int *)(v14 + 24);
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
    v18 = (_QWORD *)*v5;
    if (!*v5)
      goto LABEL_36;
    v25 = (unsigned int *)(v18 + 3);
    do
    {
      v26 = __ldaxr(v25);
      v21 = --v26 == 0;
    }
    while (__stlxr(v26, v25));
LABEL_31:
    if (v21)
    {
      v27 = v18[2];
      v18[2] = 0;
      if (v27)
        MEMORY[0x20BD0ADD4](v27, 0x1000C8077774924);
      result = (uint64_t *)MEMORY[0x20BD0ADEC](v18, 0x1010C40EE34DA14);
    }
LABEL_36:
    *v5 = v14;
    goto LABEL_42;
  }
  v7 = *result;
  *(_QWORD *)*result = 0;
  if (__n)
  {
    v8 = *(_QWORD *)(v7 + 8);
    if (v8 >= (unint64_t)__n)
    {
      v28 = 0;
    }
    else
    {
      v9 = v8 + (v8 >> 1);
      if (v9 <= (unint64_t)__n)
        v10 = (size_t)__n;
      else
        v10 = v9;
      v11 = (void *)operator new[]();
      v12 = v11;
      v13 = *(_QWORD *)(v7 + 16);
      if (v13)
      {
        memcpy(v11, *(const void **)(v7 + 16), *(_QWORD *)v7);
        *(_QWORD *)(v7 + 16) = v12;
        MEMORY[0x20BD0ADD4](v13, 0x1000C8077774924);
      }
      else
      {
        *(_QWORD *)(v7 + 16) = v11;
      }
      *(_QWORD *)(v7 + 8) = v10;
      v28 = *(_QWORD *)v7;
    }
    result = (uint64_t *)memcpy((void *)(*(_QWORD *)(v7 + 16) + v28), __src, (size_t)__n);
    *(_QWORD *)v7 = __n;
  }
LABEL_42:
  v5[1] = 0;
  v5[2] = (uint64_t)__n;
  return result;
}

float32_t webrtc::WebRtc_rdft(webrtc *this, int a2, float *a3, int64x2_t *a4, float *a5, float *a6, float32x4_t a7)
{
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  float *v15;
  float32x4_t v16;
  uint64_t v17;
  float *v18;
  float *v19;
  float *v20;
  unint64_t v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  unint64_t v31;
  float v32;
  float v33;
  float *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  float *v38;
  __float2 v39;
  float *v40;
  float *v41;
  float v42;
  float v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  __float2 v47;
  float v48;
  float v49;
  unint64_t v50;
  uint64_t v51;
  float *v52;
  float *v53;
  float *v54;
  unint64_t v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float *v65;
  float *v66;
  float32x4_t v67;
  double v68;
  float32x4_t v69;
  double v70;
  double v71;
  float32x4_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  float *v78;
  uint64_t v79;
  uint64_t v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float *v88;
  float v89;
  float v90;
  float *v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  unint64_t i;
  float *v98;
  float *v99;
  float v100;
  float v101;
  float v102;
  int v104;

  v12 = a4->i64[0];
  v13 = (unint64_t)this >> 2;
  if ((unint64_t)this <= 4 * a4->i64[0])
  {
    v14 = a4->u64[1];
    if ((unint64_t)this <= 4 * v14)
      goto LABEL_3;
LABEL_15:
    a4->i64[1] = v13;
    if ((unint64_t)this < 8)
    {
      v14 = v13;
      if ((a2 & 0x80000000) == 0)
        goto LABEL_4;
    }
    else
    {
      v104 = a2;
      v41 = &a5[v12];
      v42 = (float)((unint64_t)this >> 3);
      v43 = 0.7854 / v42;
      a7.f32[0] = cosf((float)(0.7854 / v42) * v42);
      *v41 = a7.f32[0];
      a7.f32[0] = a7.f32[0] * 0.5;
      v41[(unint64_t)this >> 3] = a7.f32[0];
      if ((unint64_t)this >= 0x10)
      {
        if ((unint64_t)this >> 3 <= 2)
          v44 = 2;
        else
          v44 = (unint64_t)this >> 3;
        v45 = 4 * v13 - 4;
        v46 = 1;
        do
        {
          v47 = __sincosf_stret(v43 * (float)v46);
          v41[v46] = v47.__cosval * 0.5;
          a7.f32[0] = v47.__sinval * 0.5;
          *(float *)((char *)v41 + v45) = v47.__sinval * 0.5;
          ++v46;
          v45 -= 4;
        }
        while (v44 != v46);
      }
      v14 = v13;
      if ((v104 & 0x80000000) == 0)
        goto LABEL_4;
    }
    goto LABEL_29;
  }
  a4->i64[0] = v13;
  a4->i64[1] = 1;
  if ((unint64_t)this >= 0xC)
  {
    v31 = (unint64_t)this >> 3;
    v32 = (float)((unint64_t)this >> 3);
    v33 = 0.7854 / v32;
    *(_QWORD *)a5 = 1065353216;
    a7.f32[0] = cosf((float)(0.7854 / v32) * v32);
    v34 = &a5[v31];
    *v34 = a7.f32[0];
    v34[1] = a7.f32[0];
    if ((unint64_t)this >= 0x18)
    {
      v35 = 4 * v13 - 8;
      v36 = 2;
      v37 = 2;
      do
      {
        v39 = __sincosf_stret(v33 * (float)v36);
        v40 = &a5[v37];
        *v40 = v39.__cosval;
        v40[1] = v39.__sinval;
        *(__float2 *)((char *)a5 + v35) = v39;
        v36 += 2;
        v35 -= 8;
        v37 += 2;
      }
      while (v36 < v31);
    }
  }
  v12 = v13;
  v14 = a4->u64[1];
  if ((unint64_t)this > 4 * v14)
    goto LABEL_15;
LABEL_3:
  if ((a2 & 0x80000000) == 0)
  {
LABEL_4:
    if ((unint64_t)this < 5)
    {
      if (this == (webrtc *)4)
    }
    else
    {
      if (this != (webrtc *)5)
      {
        v17 = 0;
        v18 = &a5[v12];
        v19 = &a3[(_QWORD)this - 1];
        v20 = a3 + 3;
        v21 = 2;
        do
        {
          v17 += 2 * v14 / ((unint64_t)this >> 1);
          v22 = 0.5 - v18[v14 - v17];
          v23 = v18[v17];
          v24 = *(v20 - 1);
          v25 = v24 - *(v19 - 1);
          v26 = *v20 + *v19;
          v27 = (float)(v22 * v25) - (float)(v23 * v26);
          v28 = (float)(v23 * v25) + (float)(v22 * v26);
          v29 = *v20 - v28;
          *(v20 - 1) = v24 - v27;
          *v20 = v29;
          v30 = *v19 - v28;
          *(v19 - 1) = *(v19 - 1) + v27;
          *v19 = v30;
          v21 += 2;
          v19 -= 2;
          v20 += 2;
        }
        while (v21 < (unint64_t)this >> 1);
      }
    }
    v48 = a3[1];
    v49 = *a3 - v48;
    a7.f32[0] = *a3 + v48;
    *a3 = a7.f32[0];
    a3[1] = v49;
    return a7.f32[0];
  }
LABEL_29:
  a7.f32[0] = (float)(*a3 - a3[1]) * 0.5;
  *a3 = *a3 - a7.f32[0];
  a3[1] = a7.f32[0];
  if ((unint64_t)this >= 5)
  {
    a3[1] = -a7.f32[0];
    v50 = (unint64_t)this >> 1;
    if (this != (webrtc *)5)
    {
      v51 = 0;
      v52 = &a5[v12];
      v53 = &a3[(_QWORD)this - 1];
      v54 = a3 + 3;
      v55 = 2;
      do
      {
        v51 += 2 * v14 / v50;
        v56 = 0.5 - v52[v14 - v51];
        v57 = v52[v51];
        v58 = *(v54 - 1);
        v59 = v58 - *(v53 - 1);
        v60 = *v54 + *v53;
        v61 = (float)(v57 * v60) + (float)(v56 * v59);
        v62 = (float)(v56 * v60) - (float)(v57 * v59);
        v63 = v62 - *v54;
        *(v54 - 1) = v58 - v61;
        *v54 = v63;
        v64 = v62 - *v53;
        *(v53 - 1) = *(v53 - 1) + v61;
        *v53 = v64;
        v55 += 2;
        v53 -= 2;
        v54 += 2;
      }
      while (v55 < v50);
    }
    a3[v50 + 1] = -a3[v50 + 1];
    if ((unint64_t)this < 9)
    {
      v75 = 2;
    }
    else
    {
      if ((unint64_t)this < 0x21)
      {
        v75 = 8;
        if (this == (webrtc *)32)
        {
LABEL_42:
          if (v75)
          {
            v76 = 0;
            v77 = 3 * v75;
            v78 = a3 + 1;
            v79 = 2 * v75;
            v80 = v75;
            do
            {
              v81 = *(v78 - 1);
              v82 = v78[v80 - 1];
              v83 = v81 + v82;
              v84 = v78[v75];
              v85 = (float)-*v78 - v84;
              v86 = v81 - v82;
              v87 = v84 - *v78;
              v88 = &v78[v79];
              v89 = v78[v79 - 1];
              v90 = v78[2 * v75];
              v91 = &v78[v77];
              v92 = v78[v77 - 1];
              v93 = v78[3 * v75];
              v94 = v89 + v92;
              v95 = v89 - v92;
              *(v78 - 1) = v83 + v94;
              *v78 = v85 - (float)(v90 + v93);
              *(v88 - 1) = v83 - v94;
              *v88 = v85 + (float)(v90 + v93);
              v78[v80 - 1] = v86 - (float)(v90 - v93);
              v78[v75] = v87 - v95;
              v96 = v86 + (float)(v90 - v93);
              a7.f32[0] = v87 + v95;
              *(v91 - 1) = v96;
              *v91 = v87 + v95;
              v76 += 2;
              v78 += 2;
            }
            while (v76 < v75);
          }
          return a7.f32[0];
        }
        goto LABEL_47;
      }
      v73 = 8;
      v74 = 32;
      do
      {
        v75 = v74;
        v74 = 4 * v75;
        v73 = v75;
      }
      while (4 * v75 < (unint64_t)this);
    }
    if (this == (webrtc *)(4 * v75))
      goto LABEL_42;
LABEL_47:
    if (v75)
    {
      for (i = 0; i < v75; i += 2)
      {
        v98 = &a3[i];
        v99 = &a3[v75 + i];
        v100 = v98[1];
        v101 = v99[1];
        v102 = *v98 - *v99;
        a7.f32[0] = *v98 + *v99;
        *v98 = a7.f32[0];
        v98[1] = (float)-v100 - v101;
        *v99 = v102;
        v99[1] = v101 - v100;
      }
    }
    return a7.f32[0];
  }
  if (this == (webrtc *)4)
  return a7.f32[0];
}

unint64_t webrtc::`anonymous namespace'::bitrv2(unint64_t this, int64x2_t *a2, unint64_t *a3, float *a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int64x2_t v7;
  unint64_t v8;
  int64x2_t *v9;
  int64x2_t v10;
  int64x2_t *v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;

  a2->i64[0] = 0;
  if (this >= 9)
  {
    v4 = 1;
    while (1)
    {
      v5 = v4;
      this >>= 1;
      if (v4)
      {
        if (v4 >= 4)
        {
          v6 = v4 & 0xFFFFFFFFFFFFFFFCLL;
          v7 = vdupq_n_s64(this);
          v8 = v5 & 0xFFFFFFFFFFFFFFFCLL;
          v9 = a2;
          do
          {
            v10 = vaddq_s64(v9[1], v7);
            v11 = (int64x2_t *)((char *)v9 + 8 * v5);
            *v11 = vaddq_s64(*v9, v7);
            v11[1] = v10;
            v9 += 2;
            v8 -= 4;
          }
          while (v8);
          if (v5 == v6)
            goto LABEL_3;
        }
        else
        {
          v6 = 0;
        }
        v12 = v5 - v6;
        v13 = &a2->i64[v6 + v5];
        v14 = &a2->i64[v6];
        do
        {
          v15 = *v14++;
          *v13++ = v15 + this;
          --v12;
        }
        while (v12);
      }
LABEL_3:
      v4 = 2 * v5;
      if (16 * v5 >= this)
      {
        v16 = 4 * v5;
        if (16 * v5 == this)
        {
          if (v4)
            goto LABEL_17;
        }
        else if (v4)
        {
          v36 = &a3[2 * v5];
          v37 = 1;
          do
          {
            v38 = 0;
            v39 = 4 * a2->i64[v37];
            v40 = (char *)v36 + v39;
            v41 = (char *)a3 + v39;
            do
            {
              v42 = 8 * v38;
              v43 = a2->i64[v38] + 2 * v37;
              this = 4 * v43;
              v44 = *(_QWORD *)&v41[8 * v38];
              *(_QWORD *)&v41[v42] = *(unint64_t *)((char *)a3 + 4 * v43);
              *(unint64_t *)((char *)a3 + 4 * v43) = v44;
              v45 = 4 * (v43 + v16);
              v46 = *(_QWORD *)&v40[8 * v38];
              *(_QWORD *)&v40[v42] = *(unint64_t *)((char *)a3 + v45);
              *(unint64_t *)((char *)a3 + v45) = v46;
              ++v38;
            }
            while (v37 != v38);
            ++v37;
          }
          while (v37 != v4);
        }
        return this;
      }
    }
  }
  if (this == 8)
  {
    v16 = 2;
    v4 = 1;
LABEL_17:
    v17 = 0;
    v18 = 4 * v4;
    do
    {
      if (v17)
      {
        v23 = 0;
        v19 = a2->i64[v17];
        v24 = (char *)&a3[12 * v16 / 8] + 4 * v19;
        this = (unint64_t)&a3[v16] + 4 * v19;
        v25 = (char *)&a3[v16 / 2] + 4 * v19;
        v26 = (char *)a3 + 4 * v19;
        do
        {
          v27 = 8 * v23;
          v28 = a2->i64[v23] + 2 * v17;
          v29 = *(_QWORD *)&v26[8 * v23];
          *(_QWORD *)&v26[v27] = *(unint64_t *)((char *)a3 + 4 * v28);
          *(unint64_t *)((char *)a3 + 4 * v28) = v29;
          v30 = v28 + v18;
          v31 = *(_QWORD *)&v25[8 * v23];
          *(_QWORD *)&v25[v27] = *(unint64_t *)((char *)a3 + 4 * v30);
          *(unint64_t *)((char *)a3 + 4 * v30) = v31;
          v32 = v30 - v16;
          v33 = *(_QWORD *)(this + 8 * v23);
          *(_QWORD *)(this + v27) = *(unint64_t *)((char *)a3 + 4 * v32);
          *(unint64_t *)((char *)a3 + 4 * v32) = v33;
          v34 = 4 * (v32 + v18);
          v35 = *(_QWORD *)&v24[8 * v23];
          *(_QWORD *)&v24[v27] = *(unint64_t *)((char *)a3 + v34);
          *(unint64_t *)((char *)a3 + v34) = v35;
          ++v23;
        }
        while (v17 != v23);
      }
      else
      {
        v19 = a2->i64[0];
      }
      v20 = v19 + 2 * (v17 + v4);
      v21 = v20 + v16;
      v20 *= 4;
      v21 *= 4;
      v22 = *(unint64_t *)((char *)a3 + v20);
      *(unint64_t *)((char *)a3 + v20) = *(unint64_t *)((char *)a3 + v21);
      *(unint64_t *)((char *)a3 + v21) = v22;
      ++v17;
    }
    while (v17 != v4);
  }
  return this;
}

float32_t webrtc::`anonymous namespace'::cftfsub(webrtc::_anonymous_namespace_ *this, float *a2, float *a3, float *a4, float32x4_t a5)
{
  float *v8;
  float32x4_t v9;
  double v10;
  float32x4_t v11;
  double v12;
  double v13;
  float32x4_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  float *v20;
  uint64_t v21;
  uint64_t v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float *v30;
  float v31;
  float v32;
  float *v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  unint64_t i;
  float *v40;
  float *v41;
  float v42;
  float v43;
  float v44;

  if ((unint64_t)this < 9)
  {
    v17 = 2;
    goto LABEL_7;
  }
  if ((unint64_t)this >= 0x21)
  {
    v15 = 8;
    v16 = 32;
    do
    {
      v17 = v16;
      v16 = 4 * v17;
      v15 = v17;
    }
    while (4 * v17 < (unint64_t)this);
LABEL_7:
    if (this == (webrtc::_anonymous_namespace_ *)(4 * v17))
      goto LABEL_8;
    goto LABEL_13;
  }
  v17 = 8;
  if (this == (webrtc::_anonymous_namespace_ *)32)
  {
LABEL_8:
    if (v17)
    {
      v18 = 0;
      v19 = 3 * v17;
      v20 = a2 + 1;
      v21 = 2 * v17;
      v22 = v17;
      do
      {
        v23 = *(v20 - 1);
        v24 = v20[v22 - 1];
        v25 = v23 + v24;
        v26 = v20[v17];
        v27 = *v20 + v26;
        v28 = v23 - v24;
        v29 = *v20 - v26;
        v30 = &v20[v21];
        v31 = v20[v21 - 1];
        v32 = v20[2 * v17];
        v33 = &v20[v19];
        v34 = v20[v19 - 1];
        v35 = v20[3 * v17];
        v36 = v31 + v34;
        v37 = v31 - v34;
        *(v20 - 1) = v25 + v36;
        *v20 = v27 + (float)(v32 + v35);
        *(v30 - 1) = v25 - v36;
        *v30 = v27 - (float)(v32 + v35);
        v20[v22 - 1] = v28 - (float)(v32 - v35);
        v20[v17] = v29 + v37;
        v38 = v28 + (float)(v32 - v35);
        a5.f32[0] = v29 - v37;
        *(v33 - 1) = v38;
        *v33 = v29 - v37;
        v18 += 2;
        v20 += 2;
      }
      while (v18 < v17);
    }
    return a5.f32[0];
  }
LABEL_13:
  if (v17)
  {
    for (i = 0; i < v17; i += 2)
    {
      v40 = &a2[i];
      v41 = &a2[v17 + i];
      v42 = v40[1];
      v43 = v41[1];
      v44 = *v40 - *v41;
      a5.f32[0] = *v40 + *v41;
      *v40 = a5.f32[0];
      v40[1] = v42 + v43;
      *v41 = v44;
      v41[1] = v42 - v43;
    }
  }
  return a5.f32[0];
}

float webrtc::`anonymous namespace'::cft1st(webrtc::_anonymous_namespace_ *this, float *a2, float *a3, float *a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float result;
  float *v40;
  float *v41;
  unint64_t i;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;

  v4 = a2[1];
  v5 = a2[2];
  v6 = a2[3];
  v7 = *a2 + v5;
  v8 = v4 + v6;
  v9 = *a2 - v5;
  v10 = v4 - v6;
  v11 = a2[4];
  v12 = a2[5];
  v13 = a2[6];
  v14 = a2[7];
  v15 = v11 + v13;
  v16 = v12 + v14;
  v17 = v11 - v13;
  v18 = v12 - v14;
  *a2 = v7 + v15;
  a2[1] = v8 + v16;
  a2[4] = v7 - v15;
  a2[5] = v8 - v16;
  a2[2] = v9 - v18;
  a2[3] = v10 + v17;
  a2[6] = v9 + v18;
  a2[7] = v10 - v17;
  v19 = a3[2];
  v20 = a2[8];
  v21 = a2[9];
  v22 = a2[10];
  v23 = a2[11];
  v24 = v20 + v22;
  v25 = v21 + v23;
  v26 = v20 - v22;
  v27 = v21 - v23;
  v28 = a2[12];
  v29 = a2[13];
  v30 = a2[14];
  v31 = a2[15];
  v32 = v28 + v30;
  v33 = v29 + v31;
  v34 = v28 - v30;
  v35 = v29 - v31;
  a2[8] = v24 + v32;
  a2[9] = v25 + v33;
  a2[12] = v33 - v25;
  a2[13] = v24 - v32;
  a2[10] = v19 * (float)((float)(v26 - v35) - (float)(v27 + v34));
  a2[11] = v19 * (float)((float)(v27 + v34) + (float)(v26 - v35));
  v36 = v26 + v35;
  v37 = v34 - v27;
  v38 = v19 * (float)(v37 - v36);
  result = v19 * (float)(v37 + v36);
  a2[14] = v38;
  a2[15] = result;
  if ((unint64_t)this >= 0x11)
  {
    v40 = a2 + 31;
    v41 = a3 + 3;
    for (i = 16; i < (unint64_t)this; i += 16)
    {
      v43 = *(v41 - 1);
      v44 = *v41;
      v45 = a3[i / 4];
      v46 = a3[i / 4 + 1];
      v47 = v45 - (float)((float)(v44 + v44) * v46);
      v48 = -(float)(v46 - (float)((float)(v44 + v44) * v45));
      v49 = *(v40 - 15);
      v50 = *(v40 - 14);
      v51 = *(v40 - 13);
      v52 = *(v40 - 12);
      v53 = v49 + v51;
      v54 = v50 + v52;
      v55 = v49 - v51;
      v56 = v50 - v52;
      v57 = *(v40 - 11);
      v58 = *(v40 - 10);
      v59 = *(v40 - 9);
      v60 = *(v40 - 8);
      v61 = v57 + v59;
      v62 = v58 + v60;
      v63 = v57 - v59;
      v64 = v58 - v60;
      *(v40 - 15) = v53 + v61;
      *(v40 - 14) = v54 + v62;
      v65 = v53 - v61;
      v66 = v54 - v62;
      *(v40 - 11) = (float)(v43 * v65) - (float)(v44 * v66);
      *(v40 - 10) = (float)(v44 * v65) + (float)(v43 * v66);
      *(v40 - 13) = (float)(v45 * (float)(v55 - v64)) - (float)(v46 * (float)(v56 + v63));
      *(v40 - 12) = (float)(v46 * (float)(v55 - v64)) + (float)(v45 * (float)(v56 + v63));
      *(v40 - 9) = (float)(v47 * (float)(v55 + v64)) - (float)(v48 * (float)(v56 - v63));
      *(v40 - 8) = (float)(v48 * (float)(v55 + v64)) + (float)(v47 * (float)(v56 - v63));
      v67 = a3[i / 4 + 2];
      v68 = a3[i / 4 + 3];
      v69 = v67 - (float)((float)(v43 + v43) * v68);
      v70 = -(float)(v68 - (float)((float)(v43 + v43) * v67));
      v71 = *(v40 - 7);
      v72 = *(v40 - 6);
      v73 = *(v40 - 5);
      v74 = *(v40 - 4);
      v75 = v71 + v73;
      v76 = v72 + v74;
      v77 = v71 - v73;
      v78 = v72 - v74;
      v80 = *(v40 - 2);
      v79 = *(v40 - 1);
      v81 = *(v40 - 3);
      v82 = v81 + v79;
      v83 = v80 + *v40;
      v84 = v81 - v79;
      v85 = v80 - *v40;
      *(v40 - 7) = v75 + v82;
      *(v40 - 6) = v76 + v83;
      v86 = v75 - v82;
      v87 = v76 - v83;
      *(v40 - 3) = (float)-(float)(v43 * v87) - (float)(v44 * v86);
      *(v40 - 2) = (float)(v43 * v86) - (float)(v44 * v87);
      *(v40 - 5) = (float)(v67 * (float)(v77 - v85)) - (float)(v68 * (float)(v78 + v84));
      *(v40 - 4) = (float)(v68 * (float)(v77 - v85)) + (float)(v67 * (float)(v78 + v84));
      result = (float)(v70 * (float)(v77 + v85)) + (float)(v69 * (float)(v78 - v84));
      *(v40 - 1) = (float)(v69 * (float)(v77 + v85)) - (float)(v70 * (float)(v78 - v84));
      *v40 = result;
      v40 += 16;
      v41 += 2;
    }
  }
  return result;
}

unint64_t webrtc::`anonymous namespace'::cftmdl(unint64_t this, unint64_t a2, float *a3, float *a4, float *a5, float32x4_t a6, float32x4_t a7, double a8, float32x4_t a9, double a10, double a11, float32x4_t a12)
{
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  float *v18;
  float *v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float *v26;
  float v27;
  float v28;
  float *v29;
  float v30;
  float v31;
  float v32;
  float v33;
  unint64_t v34;
  float v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  float *v39;
  uint64_t v40;
  float *v41;
  float v42;
  float v43;
  uint64_t v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float *v49;
  float *v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  float *v79;
  float *v80;
  uint64_t v81;
  float *v82;
  unint64_t v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  float v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  float *v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  unint64_t v114;
  unint64_t v115;
  float *v116;
  float *v117;
  float v118;
  float v119;
  uint64_t v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float *v125;
  float *v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;
  unint64_t v147;
  float *v148;
  float *v149;
  float v150;
  float v151;
  uint64_t v152;
  float v153;
  float v154;
  float v155;
  float v156;
  float *v157;
  float *v158;
  float v159;
  float v160;
  float v161;
  float v162;
  float v163;
  float v164;
  float v165;
  float v166;
  float v167;
  float v168;
  unint64_t v169;
  unint64_t v170;
  unint64_t v171;
  uint64_t v172;
  char *v173;
  unint64_t v174;
  char *v175;
  unint64_t v176;
  unint64_t v177;
  char *v178;
  unint64_t v179;
  unint64_t v180;
  unint64_t v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  unint64_t v188;
  unint64_t v189;
  BOOL v190;
  BOOL v191;
  BOOL v192;
  BOOL v193;
  BOOL v194;
  BOOL v195;
  BOOL v196;
  BOOL v197;
  BOOL v198;
  BOOL v199;
  BOOL v200;
  BOOL v201;
  BOOL v202;
  BOOL v203;
  BOOL v204;
  BOOL v205;
  BOOL v206;
  BOOL v207;
  BOOL v208;
  BOOL v209;
  BOOL v210;
  BOOL v211;
  BOOL v212;
  BOOL v213;
  BOOL v214;
  BOOL v215;
  BOOL v216;
  BOOL v217;
  BOOL v218;
  BOOL v219;
  BOOL v220;
  BOOL v221;
  BOOL v222;
  unint64_t v223;
  BOOL v224;
  BOOL v225;
  BOOL v226;
  BOOL v227;
  BOOL v228;
  BOOL v229;
  BOOL v230;
  BOOL v231;
  BOOL v232;
  BOOL v233;
  BOOL v234;
  BOOL v235;
  BOOL v236;
  BOOL v237;
  BOOL v238;
  BOOL v239;
  BOOL v240;
  BOOL v241;
  BOOL v242;
  BOOL v243;
  BOOL v244;
  BOOL v245;
  float *v246;
  unint64_t v247;
  uint64_t v248;
  float32x4_t v249;
  float32x4_t v250;
  float32x4_t v251;
  float *v252;
  float *v253;
  float *v254;
  float32x4_t v255;
  float32x4_t v256;
  float32x4_t v257;
  float32x4_t v258;
  unint64_t v259;
  unint64_t v260;
  uint64_t v261;
  char *v262;
  unint64_t v263;
  char *v264;
  unint64_t v265;
  char *v266;
  char *v267;
  unint64_t v268;
  unint64_t v269;
  unint64_t v270;
  unint64_t v271;
  unint64_t v272;
  unint64_t v273;
  unint64_t v274;
  unint64_t v275;
  unint64_t v276;
  unint64_t v277;
  BOOL v279;
  BOOL v281;
  BOOL v283;
  BOOL v285;
  BOOL v287;
  BOOL v289;
  BOOL v291;
  BOOL v293;
  BOOL v295;
  BOOL v297;
  BOOL v299;
  BOOL v301;
  BOOL v303;
  BOOL v305;
  BOOL v307;
  BOOL v309;
  BOOL v311;
  BOOL v313;
  BOOL v315;
  BOOL v317;
  BOOL v319;
  BOOL v321;
  BOOL v323;
  BOOL v325;
  BOOL v327;
  BOOL v329;
  BOOL v331;
  BOOL v332;
  BOOL v333;
  float *v334;
  unint64_t v335;
  uint64_t v336;
  float32x4_t v337;
  float32x4_t v338;
  float32x4_t v339;
  float *v340;
  float *v341;
  float *v342;
  float32x4_t v343;
  float32x4_t v344;
  float32x4_t v345;
  float32x4_t v346;
  unint64_t v347;
  float *v348;
  uint64_t v349;
  unint64_t v350;
  unint64_t v351;
  unint64_t v352;
  char *v353;
  unint64_t v354;
  unint64_t v355;
  unint64_t v356;
  unint64_t v357;
  unint64_t v358;
  unint64_t v359;
  unint64_t v360;
  unint64_t v361;
  unint64_t v362;
  unint64_t v363;
  unint64_t v364;
  char *v365;
  unint64_t v366;
  unint64_t v367;
  unint64_t v368;
  BOOL v370;
  BOOL v372;
  BOOL v374;
  BOOL v376;
  BOOL v378;
  BOOL v380;
  BOOL v382;
  BOOL v384;
  BOOL v386;
  BOOL v388;
  BOOL v390;
  BOOL v392;
  BOOL v394;
  BOOL v396;
  BOOL v398;
  BOOL v400;
  BOOL v402;
  BOOL v404;
  BOOL v406;
  BOOL v408;
  BOOL v410;
  BOOL v412;
  BOOL v414;
  BOOL v416;
  BOOL v418;
  BOOL v420;
  BOOL v422;
  BOOL v423;
  uint64_t v424;
  unint64_t v425;
  float *v426;
  const float *v427;
  float *v428;
  float *v429;
  float32x4_t v430;
  float32x4_t v431;
  float *v432;
  float32x4_t v433;
  float32x4_t v434;
  float32x4_t v435;
  unint64_t v436;
  float *v437;
  float *v438;
  float *v439;
  float *v440;
  float *v441;
  unint64_t v442;
  unint64_t v443;
  unint64_t v444;
  unint64_t v445;
  unint64_t v446;
  char *v447;
  unint64_t v448;
  unint64_t v449;
  unint64_t v450;
  uint64_t v451;
  unint64_t v452;
  char *v453;
  unint64_t v454;
  unint64_t v455;
  unint64_t v456;
  char *v457;
  char *v458;
  unint64_t v459;
  unint64_t v460;
  unint64_t v461;
  BOOL v463;
  BOOL v465;
  BOOL v467;
  BOOL v469;
  BOOL v471;
  BOOL v473;
  BOOL v475;
  BOOL v477;
  BOOL v479;
  BOOL v481;
  BOOL v483;
  BOOL v485;
  BOOL v487;
  BOOL v489;
  BOOL v491;
  BOOL v493;
  BOOL v495;
  BOOL v497;
  BOOL v499;
  BOOL v501;
  BOOL v503;
  BOOL v505;
  BOOL v507;
  BOOL v509;
  BOOL v511;
  BOOL v513;
  BOOL v515;
  BOOL v516;
  uint64_t v517;
  unint64_t v518;
  float32x4_t v519;
  float32x4_t v520;
  float32x4_t v521;
  float32x4_t v522;
  float32x4_t v523;
  char *v524;
  char *v525;
  char *v526;
  char *v527;
  char *v528;
  float *v529;
  float *v530;
  char *v531;
  float *v532;
  char *v533;
  char *v534;
  char *v535;
  float *v536;
  float *v537;
  float *v538;
  char *v539;
  char *v540;
  char *v541;
  float *v542;
  char *v543;
  char *v544;
  BOOL v545;
  BOOL v546;
  BOOL v547;
  BOOL v548;
  BOOL v549;
  BOOL v550;
  unint64_t v551;
  BOOL v552;
  BOOL v553;
  BOOL v554;
  BOOL v555;
  BOOL v556;
  BOOL v557;
  BOOL v558;
  BOOL v559;
  BOOL v560;
  BOOL v561;
  BOOL v562;
  BOOL v563;
  BOOL v564;
  BOOL v565;
  BOOL v566;
  BOOL v567;
  BOOL v568;
  BOOL v569;
  BOOL v570;
  BOOL v571;
  BOOL v572;
  BOOL v573;
  BOOL v574;
  BOOL v575;
  BOOL v576;
  BOOL v577;
  BOOL v578;
  float *v579;
  float *v580;
  unint64_t v581;
  float *v582;
  unint64_t v583;
  unint64_t v585;
  BOOL v586;
  unint64_t v587;
  uint64_t v588;
  float *v589;
  uint64_t v590;
  unint64_t v591;
  uint64_t v592;
  unint64_t v593;
  uint64_t v594;
  uint64_t v595;
  unint64_t v596;
  BOOL v597;
  unint64_t v598;
  BOOL v599;
  BOOL v600;
  unint64_t v601;
  BOOL v602;
  BOOL v603;
  unint64_t v604;
  BOOL v605;
  float *v606;
  BOOL v607;
  float *v608;
  BOOL v609;
  BOOL v610;
  float *v611;
  BOOL v612;
  BOOL v613;
  float *v614;
  BOOL v615;
  BOOL v616;
  unint64_t v617;
  BOOL v618;
  BOOL v619;
  float *v620;
  BOOL v621;
  BOOL v622;
  float *v623;
  BOOL v624;
  BOOL v625;
  float *v626;
  BOOL v627;
  BOOL v628;
  uint64_t v629;
  float *v630;
  BOOL v631;
  BOOL v632;
  uint64_t v633;
  BOOL v634;
  BOOL v635;
  uint64_t v636;
  BOOL v637;
  BOOL v638;
  float32x4x2_t v639;
  float32x4x2_t v640;
  float32x4x2_t v641;
  float32x4x2_t v642;
  float32x4x2_t v643;
  float32x4x2_t v644;
  float32x4x2_t v645;
  float32x4x2_t v646;
  float32x4x2_t v647;
  float32x4x2_t v648;
  float32x4x2_t v649;
  float32x4x2_t v650;
  float32x4x2_t v651;
  float32x4x2_t v652;
  float32x4x2_t v653;
  float32x4x2_t v654;
  float32x4x2_t v655;
  float32x4x2_t v656;

  v12 = a2;
  v13 = 4 * a2;
  v14 = 8 * a2;
  v582 = a4;
  v583 = this;
  v595 = 4 * a2;
  if (!a2)
    goto LABEL_6;
  v15 = a2 - 1;
  if (a2 - 1 < 0x46)
  {
    v16 = 0;
    goto LABEL_4;
  }
  v16 = 0;
  v347 = (4 * v15) & 0xFFFFFFFFFFFFFFF8;
  if ((float *)((char *)a3 + v347) < a3)
    goto LABEL_4;
  v348 = a3 + 1;
  if ((float *)((char *)a3 + v347 + 4) < a3 + 1)
    goto LABEL_4;
  if ((float *)((char *)&a3[v14 / 4] + v347) < &a3[v14 / 4])
    goto LABEL_4;
  if ((float *)((char *)&a3[v14 / 4 + 1] + v347) < &a3[v14 / 4 + 1])
    goto LABEL_4;
  if ((char *)a3 + v13 + v347 < (char *)a3 + v13)
    goto LABEL_4;
  if ((char *)v348 + v13 + v347 < (char *)v348 + v13)
    goto LABEL_4;
  v349 = 3 * a2;
  if ((float *)((char *)&v348[3 * a2] + v347) < &v348[3 * a2]
    || (float *)((char *)&a3[v349] + v347) < &a3[v349]
    || v15 >> 62)
  {
    goto LABEL_4;
  }
  v16 = 0;
  v350 = (v13 - 4) & 0xFFFFFFFFFFFFFFF8;
  v351 = (unint64_t)a3 + ((v13 - 4) | 4);
  v352 = (unint64_t)(a3 + 1);
  v353 = (char *)a3 + v350;
  v354 = (unint64_t)a3 + v350 + 8;
  v355 = (unint64_t)&a3[v14 / 4];
  v356 = v14 + v350;
  v357 = (unint64_t)a3 + v356 + 4;
  v358 = (unint64_t)&a3[v14 / 4 + 1];
  v359 = (unint64_t)a3 + v356 + 8;
  v360 = (unint64_t)a3 + v13;
  v361 = (unint64_t)&v353[v13 + 4];
  v362 = (unint64_t)a3 + v13 + 4;
  v363 = (unint64_t)&v353[v13 + 8];
  v364 = (unint64_t)&a3[3 * a2];
  v365 = &v353[12 * v12];
  v366 = (unint64_t)(v365 + 4);
  v367 = (unint64_t)&a3[3 * v12 + 1];
  v368 = (unint64_t)(v365 + 8);
  v370 = v357 > (unint64_t)a3 && v355 < v351;
  v637 = v370;
  v372 = v359 > (unint64_t)a3 && v358 < v351;
  v634 = v372;
  v374 = v361 > (unint64_t)a3 && v360 < v351;
  v631 = v374;
  v376 = v363 > (unint64_t)a3 && v362 < v351;
  v627 = v376;
  v378 = v366 > (unint64_t)a3 && v364 < v351;
  v624 = v378;
  v380 = v368 > (unint64_t)a3 && v367 < v351;
  v621 = v380;
  v382 = v352 < v357 && v355 < v354;
  v618 = v382;
  v384 = v352 < v359 && v358 < v354;
  v615 = v384;
  v386 = v352 < v361 && v360 < v354;
  v612 = v386;
  v388 = v352 < v363 && v362 < v354;
  v609 = v388;
  v390 = v352 < v366 && v364 < v354;
  v392 = v352 < v368 && v367 < v354;
  v394 = v355 < v359 && v358 < v357;
  v396 = v355 < v361 && v360 < v357;
  v398 = v355 < v363 && v362 < v357;
  v400 = v355 < v366 && v364 < v357;
  v402 = v355 < v368 && v367 < v357;
  v404 = v358 < v361 && v360 < v359;
  v406 = v358 < v363 && v362 < v359;
  v408 = v358 < v366 && v364 < v359;
  v410 = v358 < v368 && v367 < v359;
  v412 = v360 < v363 && v362 < v361;
  v414 = v360 < v366 && v364 < v361;
  v416 = v360 < v368 && v367 < v361;
  v418 = v362 < v366 && v364 < v363;
  v420 = v362 < v368 && v367 < v363;
  v422 = v364 < v368 && v367 < v366;
  v423 = v352 < v351 && v354 > (unint64_t)a3;
  if (v423
    || v637
    || v634
    || v631
    || v627
    || v624
    || v621
    || v618
    || v615
    || v612
    || v609
    || v390
    || v392
    || v394
    || v396
    || v398
    || v400
    || v402
    || v404
    || v406)
  {
    a4 = v582;
    this = v583;
    v12 = a2;
    v13 = v595;
    goto LABEL_4;
  }
  this = v583;
  if (v408)
  {
    a4 = v582;
    v12 = a2;
    v13 = v595;
LABEL_4:
    v17 = 3 * v12;
    v18 = &a3[v16 + 1];
    v19 = &a3[v16 + 1 + v12];
    do
    {
      v20 = *(v18 - 1);
      v21 = *(v19 - 1);
      v22 = v20 + v21;
      v23 = *v18 + *v19;
      v24 = v20 - v21;
      v25 = *v18 - *v19;
      v26 = &v18[v14 / 4];
      v27 = v18[v14 / 4 - 1];
      v28 = v18[v14 / 4];
      v29 = &v18[v17];
      v30 = v18[v17 - 1];
      v31 = v18[3 * v12];
      v32 = v27 + v30;
      v33 = v27 - v30;
      *(v18 - 1) = v22 + v32;
      *v18 = v23 + (float)(v28 + v31);
      v18 += 2;
      *(v26 - 1) = v22 - v32;
      *v26 = v23 - (float)(v28 + v31);
      *(v19 - 1) = v24 - (float)(v28 - v31);
      *v19 = v25 + v33;
      *(v29 - 1) = v24 + (float)(v28 - v31);
      *v29 = v25 - v33;
      v16 += 2;
      v19 += 2;
    }
    while (v16 < v12);
    goto LABEL_6;
  }
  v12 = a2;
  if (v410)
  {
    a4 = v582;
    v13 = v595;
    goto LABEL_4;
  }
  a4 = v582;
  v13 = v595;
  if (v412)
    goto LABEL_4;
  if (v414)
    goto LABEL_4;
  if (v416)
    goto LABEL_4;
  if (v418)
    goto LABEL_4;
  if (v420)
    goto LABEL_4;
  if (v422)
    goto LABEL_4;
  v424 = (v15 >> 1) + 1;
  v16 = 2 * (v424 & 0xFFFFFFFFFFFFFFFCLL);
  v425 = v424 & 0xFFFFFFFFFFFFFFFCLL;
  v426 = a3;
  do
  {
    v427 = v426;
    v639 = vld2q_f32(v427);
    v428 = (float *)&v427[v349];
    v429 = &v426[(unint64_t)v595 / 4];
    v641 = vld2q_f32(v429);
    v430 = vaddq_f32(v639.val[0], v641.val[0]);
    v431 = vaddq_f32(v639.val[1], v641.val[1]);
    v432 = &v426[v14 / 4];
    v644 = vld2q_f32(v432);
    v433 = vsubq_f32(v639.val[0], v641.val[0]);
    a6 = vsubq_f32(v639.val[1], v641.val[1]);
    *(float32x4x2_t *)((char *)&v639 + 16) = vld2q_f32(v428);
    v641.val[1] = vaddq_f32(v644.val[0], v639.val[1]);
    v434 = vaddq_f32(v644.val[1], v641.val[0]);
    v435 = vsubq_f32(v644.val[0], v639.val[1]);
    v639.val[1] = vsubq_f32(v644.val[1], v641.val[0]);
    a12 = vaddq_f32(v430, v641.val[1]);
    v644.val[1] = vaddq_f32(v431, v434);
    vst2q_f32(v426, *(float32x4x2_t *)a12.f32);
    v426 += 8;
    v641.val[0] = vsubq_f32(v430, v641.val[1]);
    v641.val[1] = vsubq_f32(v431, v434);
    vst2q_f32(v432, v641);
    v641.val[0] = vsubq_f32(v433, v639.val[1]);
    a9 = vaddq_f32(a6, v435);
    vst2q_f32(v429, *(float32x4x2_t *)(&a9 - 1));
    a7 = vaddq_f32(v433, v639.val[1]);
    v641.val[0] = vsubq_f32(a6, v435);
    vst2q_f32(v428, *(float32x4x2_t *)a7.f32);
    v425 -= 4;
  }
  while (v425);
  if (v424 != (v424 & 0xFFFFFFFFFFFFFFFCLL))
    goto LABEL_4;
LABEL_6:
  v34 = 5 * v12;
  if (v13 >= 5 * v12)
    goto LABEL_11;
  v35 = a4[2];
  v36 = v12 - 1;
  if (v12 - 1 < 0x3E
    || (v436 = (4 * v36) & 0xFFFFFFFFFFFFFFF8, v437 = &a3[4 * v12], (float *)((char *)v437 + v436) < v437)
    || (float *)((char *)v437 + v436 + 4) < v437 + 1
    || (v438 = &a3[6 * v12], (float *)((char *)v438 + v436) < v438)
    || (float *)((char *)v438 + v436 + 4) < v438 + 1
    || (v439 = &a3[5 * v12], (float *)((char *)v439 + v436) < v439)
    || (float *)((char *)v439 + v436 + 4) < v439 + 1
    || (v440 = &a3[7 * v12], (float *)((char *)v440 + v436 + 4) < v440 + 1)
    || (float *)((char *)v440 + v436) < v440
    || v36 >> 62)
  {
    v37 = v13;
    goto LABEL_9;
  }
  v441 = &a3[4 * v12];
  v442 = (v13 - 4) & 0xFFFFFFFFFFFFFFF8;
  v443 = (unint64_t)v441 + v442 + 4;
  v444 = (unint64_t)(v441 + 1);
  v445 = (unint64_t)v441 + v442 + 8;
  v446 = (unint64_t)&a3[6 * v12];
  v447 = (char *)&a3[6 * v12] + v442;
  v448 = (unint64_t)(v447 + 4);
  v449 = v446 + 4;
  v450 = (unint64_t)(v447 + 8);
  v451 = v13 + v12;
  v452 = (unint64_t)&a3[v451];
  v453 = (char *)&a3[v451] + v442;
  v454 = (unint64_t)(v453 + 4);
  v455 = (unint64_t)&a3[v451 + 1];
  v456 = (unint64_t)(v453 + 8);
  v457 = (char *)a3 + 32 * v12 - v13;
  v458 = &v457[v442];
  v459 = (unint64_t)(v458 + 4);
  v460 = (unint64_t)(v457 + 4);
  v461 = (unint64_t)(v458 + 8);
  v463 = (unint64_t)v441 < v448 && v446 < v443;
  v638 = v463;
  v465 = (unint64_t)v441 < v450 && v449 < v443;
  v635 = v465;
  v467 = (unint64_t)v441 < v454 && v452 < v443;
  v632 = v467;
  v469 = (unint64_t)v441 < v456 && v455 < v443;
  v628 = v469;
  v471 = (unint64_t)v441 < v459 && (unint64_t)v457 < v443;
  v625 = v471;
  v473 = (unint64_t)v441 < v461 && v460 < v443;
  v622 = v473;
  v475 = v444 < v448 && v446 < v445;
  v619 = v475;
  v477 = v444 < v450 && v449 < v445;
  v616 = v477;
  v479 = v444 < v454 && v452 < v445;
  v613 = v479;
  v481 = v444 < v456 && v455 < v445;
  v610 = v481;
  v483 = v444 < v459 && (unint64_t)v457 < v445;
  v607 = v483;
  v485 = v444 < v461 && v460 < v445;
  v605 = v485;
  v487 = v446 < v450 && v449 < v448;
  v603 = v487;
  v489 = v446 < v454 && v452 < v448;
  v600 = v489;
  v491 = v446 < v456 && v455 < v448;
  v493 = v446 < v459 && (unint64_t)v457 < v448;
  v495 = v446 < v461 && v460 < v448;
  v497 = v449 < v454 && v452 < v450;
  v499 = v449 < v456 && v455 < v450;
  v501 = v449 < v459 && (unint64_t)v457 < v450;
  v503 = v449 < v461 && v460 < v450;
  v505 = v452 < v456 && v455 < v454;
  v507 = v452 < v459 && (unint64_t)v457 < v454;
  v509 = v452 < v461 && v460 < v454;
  v511 = v455 < v459 && (unint64_t)v457 < v456;
  v513 = v455 < v461 && v460 < v456;
  v515 = (unint64_t)v457 < v461 && v460 < v459;
  v516 = v444 >= v443 || (unint64_t)v441 >= v445;
  if (!v516 || v638)
  {
    v37 = v595;
    this = v583;
    v12 = a2;
LABEL_9:
    v38 = v37 + 1;
    v39 = &a3[v37];
    v40 = 12 * v12 + 4;
    v41 = &a3[v37 + 1 + v12];
    do
    {
      v42 = *(v41 - 1);
      v43 = *v39 + v42;
      v44 = (4 * v38 - 4) | 4;
      v45 = *(float *)((char *)a3 + v44);
      v46 = v45 + *v41;
      v47 = *v39 - v42;
      v48 = v45 - *v41;
      v49 = &v39[v14 / 4];
      v50 = (float *)((char *)v39 + v40);
      v51 = v39[3 * v12];
      v52 = *(float *)((char *)v39 + v40);
      v53 = v39[v14 / 4];
      v54 = v39[v14 / 4 + 1];
      v55 = v53 + v51;
      v56 = v53 - v51;
      *v39 = v43 + v55;
      v39 += 2;
      *(float *)((char *)a3 + v44) = v46 + (float)(v54 + v52);
      *v49 = (float)(v54 + v52) - v46;
      v49[1] = v43 - v55;
      v57 = v47 - (float)(v54 - v52);
      *(v41 - 1) = v35 * (float)(v57 - (float)(v48 + v56));
      *v41 = v35 * (float)((float)(v48 + v56) + v57);
      v58 = v47 + (float)(v54 - v52);
      v59 = v56 - v48;
      v60 = v38 + 1;
      v38 += 2;
      *(v50 - 1) = v35 * (float)(v59 - v58);
      *v50 = v35 * (float)(v59 + v58);
      v41 += 2;
    }
    while (v60 < v34);
    goto LABEL_11;
  }
  v12 = a2;
  if (v635
    || v632
    || v628
    || v625
    || v622
    || v619
    || v616
    || v613
    || v610
    || v607
    || v605
    || v603
    || v600
    || v491
    || v493
    || v495)
  {
    v37 = v595;
    this = v583;
    goto LABEL_9;
  }
  this = v583;
  if (v497 || v499 || v501)
  {
    v37 = v595;
    goto LABEL_9;
  }
  if (v503 || v505 || v507 || v509 || v511 || v513)
  {
    v37 = v595;
    goto LABEL_9;
  }
  v37 = v595;
  if (v515)
    goto LABEL_9;
  v517 = (v36 >> 1) + 1;
  v37 = v595 + 2 * (v517 & 0xFFFFFFFFFFFFFFFCLL);
  v518 = v517 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v640 = vld2q_f32(v437);
    v642 = vld2q_f32(v439);
    v643 = vld2q_f32(v438);
    v647 = vld2q_f32(v440);
    v519 = vaddq_f32(v640.val[0], v642.val[0]);
    v520 = vaddq_f32(v640.val[1], v642.val[1]);
    v521 = vaddq_f32(v643.val[0], v647.val[0]);
    v522 = vaddq_f32(v643.val[1], v647.val[1]);
    v650.val[0] = vaddq_f32(v519, v521);
    v650.val[1] = vaddq_f32(v520, v522);
    vst2q_f32(v437, v650);
    v437 += 8;
    v650.val[0] = vsubq_f32(v640.val[0], v642.val[0]);
    v640.val[0] = vsubq_f32(v640.val[1], v642.val[1]);
    v640.val[1] = vsubq_f32(v643.val[0], v647.val[0]);
    v642.val[0] = vsubq_f32(v522, v520);
    v642.val[1] = vsubq_f32(v519, v521);
    vst2q_f32(v438, v642);
    v438 += 8;
    v642.val[0] = vsubq_f32(v643.val[1], v647.val[1]);
    v642.val[1] = vsubq_f32(v650.val[0], v642.val[0]);
    v643.val[0] = vaddq_f32(v640.val[0], v640.val[1]);
    a12 = vmulq_n_f32(vsubq_f32(v642.val[1], v643.val[0]), v35);
    v523 = vmulq_n_f32(vaddq_f32(v643.val[0], v642.val[1]), v35);
    vst2q_f32(v439, *(float32x4x2_t *)a12.f32);
    v439 += 8;
    a9 = vaddq_f32(v650.val[0], v642.val[0]);
    v640.val[0] = vsubq_f32(v640.val[1], v640.val[0]);
    v642.val[1] = vmulq_n_f32(vsubq_f32(v640.val[0], a9), v35);
    a7 = vaddq_f32(v640.val[0], a9);
    v643.val[0] = vmulq_n_f32(a7, v35);
    vst2q_f32(v440, *(float32x4x2_t *)((char *)&v642 + 16));
    v440 += 8;
    v518 -= 4;
  }
  while (v518);
  if (v517 != (v517 & 0xFFFFFFFFFFFFFFFCLL))
    goto LABEL_9;
LABEL_11:
  if (v14 < this)
  {
    v61 = 0;
    v636 = 0;
    v594 = 13 * v12;
    v62 = 12 * v12;
    v63 = (12 * v12) | 2;
    v64 = ~(12 * v12);
    v65 = (v12 << 6) - v595;
    v66 = 13 * v12;
    v67 = (v12 << 6) - v14;
    v629 = 52 * v12 + 4;
    v68 = 12 * v12;
    v69 = (48 * v12) | 4;
    v581 = (v12 << 62) - v14;
    v70 = (48 * v12) | 8;
    v71 = 52 * v12 + 8;
    v72 = v14 + v12;
    v73 = 11 * v12;
    v74 = 44 * v12 + 4;
    v75 = v14 + v12;
    v76 = v595 + v12;
    v77 = 2 * (v595 + v12);
    v78 = v73 * 4 + 8;
    v79 = &a3[v77];
    v80 = &a3[v73];
    v81 = v62 + 4;
    v544 = (char *)a3 + ((32 * a2) | 4);
    v540 = (char *)a3 + ((8 * v76) | 4);
    v82 = v582;
    v530 = &a3[v77 + 2];
    v83 = v583;
    v84 = a2;
    v536 = &a3[v75 + 1];
    v529 = &a3[v75 + 2];
    v534 = (char *)a3 + v74;
    v528 = (char *)a3 + v78;
    v543 = (char *)a3 + v69;
    v527 = (char *)a3 + v70;
    v539 = (char *)a3 + (v67 | 4);
    v526 = (char *)a3 + v67 + 8;
    v535 = (char *)a3 + v629;
    v525 = (char *)a3 + v71;
    v533 = (char *)a3 + v65 + 4;
    v524 = (char *)a3 + v65 + 8;
    v85 = -(uint64_t)v14;
    v86 = 32 * a2;
    v590 = v14 | 2;
    this = v14 + 2;
    v588 = v64;
    v589 = a3 + 1;
    v630 = &a3[v68];
    v633 = v64;
    v591 = v72;
    v592 = v63;
    v87 = v63;
    v88 = v594;
    v580 = v630;
    v531 = (char *)a3 + v65;
    v532 = v80;
    v623 = (float *)((char *)a3 + v67);
    v626 = (float *)((char *)a3 + v65);
    v541 = (char *)a3 + v67;
    v542 = v79;
    v537 = &a3[v66];
    v538 = &a3[v75];
    v617 = ~v14;
    v620 = &a3[v66];
    v587 = ~v14;
    v89 = v72;
    v579 = &a3[8 * a2];
    v611 = v80;
    v614 = v579;
    v606 = &a3[v75];
    v608 = v79;
    v90 = v14;
    do
    {
      v91 = v636;
      if (v88 <= v87)
        v92 = v87;
      else
        v92 = v88;
      v593 = v92;
      v604 = this;
      if (v89 > this)
        this = v89;
      v93 = v14 * v61;
      v94 = v591 + v14 * v61;
      v95 = v590 + v14 * v61;
      if (v94 <= v95)
        v96 = v590 + v14 * v61;
      else
        v96 = v591 + v14 * v61;
      v97 = v86 * v61;
      if (v94 <= v95)
        v98 = v590 + v14 * v61;
      else
        v98 = v591 + v14 * v61;
      if (v94 <= v95)
        v94 = v590 + v14 * v61;
      v99 = v594 + v93;
      v100 = v592 + v93;
      if (v99 <= v100)
        v101 = v100;
      else
        v101 = v99;
      v601 = v101;
      if (v99 <= v100)
        v102 = v100;
      else
        v102 = v99;
      v596 = v102;
      if (v99 <= v100)
        v103 = v100;
      else
        v103 = v99;
      v598 = v103;
      v636 += 2;
      a6.f32[0] = v82[v91 + 2];
      v104 = v82[v91 + 3];
      v105 = v90 + v84;
      if (v90 < v90 + v84)
      {
        v106 = v587 + v85 * v61;
        v107 = v96 + v106;
        v108 = &v82[2 * v636];
        a7.f32[0] = *v108;
        v109 = v108[1];
        a9.f32[0] = *v108 - (float)((float)(v104 + v104) * v109);
        v110 = -v109;
        v111 = -(float)(v109 - (float)((float)(v104 + v104) * *v108));
        v112 = -v104;
        v113 = -v111;
        v114 = v90;
        v585 = v107;
        if (v107 < 0x2E)
          goto LABEL_38;
        v170 = (unint64_t)v579 + v97;
        v171 = v94 + v106;
        v172 = 8 * ((v94 + v106) >> 1);
        v114 = v90;
        if ((char *)v579 + v97 + v172 < (char *)v579 + v97)
          goto LABEL_38;
        v173 = &v544[v97];
        v114 = v90;
        if (&v544[v97 + v172] < &v544[v97])
          goto LABEL_38;
        v174 = (unint64_t)v542 + v97;
        v114 = v90;
        if ((char *)v542 + v97 + v172 < (char *)v542 + v97)
          goto LABEL_38;
        v175 = &v540[v97];
        v114 = v90;
        if (&v540[v97 + v172] < &v540[v97])
          goto LABEL_38;
        v176 = (unint64_t)v538 + v97;
        v114 = v90;
        if ((char *)v538 + v97 + v172 < (char *)v538 + v97)
          goto LABEL_38;
        v177 = (unint64_t)v536 + v97;
        v114 = v90;
        if ((char *)v536 + v97 + v172 < (char *)v536 + v97)
          goto LABEL_38;
        v178 = &v534[v97];
        v114 = v90;
        if (&v534[v97 + v172] < &v534[v97])
          goto LABEL_38;
        v179 = (unint64_t)v532 + v97;
        v114 = v90;
        if ((char *)v532 + v97 + v172 < (char *)v532 + v97)
          goto LABEL_38;
        v114 = v90;
        if (v171 >> 62)
          goto LABEL_38;
        v180 = (4 * (v98 + v587 + v581 * v61)) & 0xFFFFFFFFFFFFFFF8;
        v181 = (unint64_t)&v173[v180];
        v182 = (unint64_t)a3 + ((32 * a2) | 8) + v97 + v180;
        v183 = this;
        v184 = (unint64_t)&v175[v180];
        v185 = (unint64_t)v530 + v97 + v180;
        v186 = v177 + v180;
        v187 = (unint64_t)v529 + v97 + v180;
        v188 = (unint64_t)&v178[v180];
        v189 = (unint64_t)&v528[v97 + v180];
        v190 = v170 >= v184 || v174 >= v181;
        v191 = !v190;
        v569 = v191;
        v192 = v170 >= v185 || (unint64_t)v175 >= v181;
        v193 = !v192;
        v571 = v193;
        v194 = v170 >= v186 || v176 >= v181;
        v195 = !v194;
        v573 = v195;
        v196 = v170 >= v187 || v177 >= v181;
        v197 = !v196;
        v575 = v197;
        v198 = v170 >= v188 || v179 >= v181;
        v199 = !v198;
        v577 = v199;
        v200 = v170 >= v189 || (unint64_t)v178 >= v181;
        v201 = !v200;
        v567 = v201;
        v202 = (unint64_t)v173 >= v184 || v174 >= v182;
        v203 = !v202;
        v565 = v203;
        v204 = (unint64_t)v173 >= v185 || (unint64_t)v175 >= v182;
        v205 = !v204;
        v563 = v205;
        v206 = (unint64_t)v173 >= v186 || v176 >= v182;
        v207 = !v206;
        v561 = v207;
        v208 = (unint64_t)v173 >= v187 || v177 >= v182;
        v209 = !v208;
        v559 = v209;
        v210 = (unint64_t)v173 >= v188 || v179 >= v182;
        v211 = !v210;
        v557 = v211;
        v212 = (unint64_t)v173 >= v189 || (unint64_t)v178 >= v182;
        v213 = !v212;
        v555 = v213;
        v214 = v174 >= v185 || (unint64_t)v175 >= v184;
        v215 = !v214;
        v553 = v215;
        v216 = v174 >= v186 || v176 >= v184;
        v217 = !v216;
        v552 = v217;
        v218 = v174 >= v187 || v177 >= v184;
        v219 = !v218;
        v550 = v219;
        v220 = v174 >= v188 || v179 >= v184;
        v221 = !v220;
        v549 = v221;
        v222 = v174 >= v189 || (unint64_t)v178 >= v184;
        v223 = v183;
        v85 = -(uint64_t)v14;
        v224 = !v222;
        v225 = (unint64_t)v175 >= v186 || v176 >= v185;
        v226 = !v225;
        v548 = v226;
        v227 = (unint64_t)v175 >= v187 || v177 >= v185;
        v228 = !v227;
        v547 = v228;
        v229 = (unint64_t)v175 >= v188 || v179 >= v185;
        v230 = !v229;
        v546 = v230;
        v231 = (unint64_t)v175 >= v189 || (unint64_t)v178 >= v185;
        v232 = !v231;
        v233 = v176 >= v187 || v177 >= v186;
        v234 = !v233;
        v545 = v234;
        v235 = v176 >= v188 || v179 >= v186;
        v236 = !v235;
        v237 = v176 >= v189 || (unint64_t)v178 >= v186;
        v238 = !v237;
        v239 = v177 >= v188 || v179 >= v187;
        v240 = !v239;
        v241 = v177 >= v189 || (unint64_t)v178 >= v187;
        v83 = v583;
        v84 = a2;
        v242 = !v241;
        v190 = v179 >= v189;
        v82 = v582;
        v243 = v190 || (unint64_t)v178 >= v188;
        v244 = !v243;
        v245 = (unint64_t)v173 >= v181 || v170 >= v182;
        v114 = v90;
        if (!v245)
          goto LABEL_38;
        v114 = v90;
        if (v569)
          goto LABEL_38;
        v114 = v90;
        if (v571)
          goto LABEL_38;
        v114 = v90;
        if (v573)
          goto LABEL_38;
        v114 = v90;
        if (v575)
          goto LABEL_38;
        v114 = v90;
        if (v577)
          goto LABEL_38;
        v114 = v90;
        if (v567)
          goto LABEL_38;
        v114 = v90;
        if (v565)
          goto LABEL_38;
        v114 = v90;
        if (v563)
          goto LABEL_38;
        v114 = v90;
        if (v561)
          goto LABEL_38;
        v114 = v90;
        if (v559)
          goto LABEL_38;
        v114 = v90;
        if (v557)
          goto LABEL_38;
        v114 = v90;
        if (v555)
          goto LABEL_38;
        v114 = v90;
        if (v553)
          goto LABEL_38;
        v114 = v90;
        if (v552)
          goto LABEL_38;
        v114 = v90;
        if (v550)
          goto LABEL_38;
        v114 = v90;
        if (v549)
          goto LABEL_38;
        v114 = v90;
        if (v224)
          goto LABEL_38;
        v114 = v90;
        if (v548)
          goto LABEL_38;
        v114 = v90;
        if (v547)
          goto LABEL_38;
        v114 = v90;
        if (v546)
          goto LABEL_38;
        v114 = v90;
        if (v232)
          goto LABEL_38;
        v114 = v90;
        if (v545)
          goto LABEL_38;
        v114 = v90;
        if (v236)
          goto LABEL_38;
        v114 = v90;
        if (v238)
          goto LABEL_38;
        v114 = v90;
        if (v240)
          goto LABEL_38;
        v114 = v90;
        if (v242)
          goto LABEL_38;
        v114 = v90;
        if (v244)
          goto LABEL_38;
        v246 = v614;
        v247 = (((v223 + v617) >> 1) + 1) & 0xFFFFFFFFFFFFFFFCLL;
        v248 = (v585 >> 1) + 1;
        v114 = v90 + 2 * (v248 & 0xFFFFFFFFFFFFFFFCLL);
        v249 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 0);
        v250 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 0);
        v251 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a9.f32, 0);
        v253 = v608;
        v252 = v611;
        v254 = v606;
        do
        {
          v648 = vld2q_f32(v246);
          v651 = vld2q_f32(v254);
          v653 = vld2q_f32(v253);
          v255 = vaddq_f32(v648.val[0], v651.val[0]);
          v655 = vld2q_f32(v252);
          v256 = vaddq_f32(v648.val[1], v651.val[1]);
          v257 = vsubq_f32(v648.val[0], v651.val[0]);
          v648.val[0] = vsubq_f32(v648.val[1], v651.val[1]);
          v648.val[1] = vaddq_f32(v653.val[0], v655.val[0]);
          v651.val[0] = vaddq_f32(v653.val[1], v655.val[1]);
          v645.val[0] = vaddq_f32(v255, v648.val[1]);
          v645.val[1] = vaddq_f32(v256, v651.val[0]);
          vst2q_f32(v246, v645);
          v246 += 8;
          v651.val[1] = vsubq_f32(v653.val[0], v655.val[0]);
          v648.val[1] = vsubq_f32(v255, v648.val[1]);
          v651.val[0] = vsubq_f32(v256, v651.val[0]);
          v645.val[0] = vmlaq_f32(vmulq_n_f32(v651.val[0], v112), v648.val[1], v249);
          v645.val[1] = vmlaq_f32(vmulq_n_f32(v648.val[1], v104), v651.val[0], v249);
          vst2q_f32(v253, v645);
          v253 += 8;
          v648.val[1] = vsubq_f32(v653.val[1], v655.val[1]);
          v651.val[0] = vsubq_f32(v257, v648.val[1]);
          v653.val[0] = vaddq_f32(v648.val[0], v651.val[1]);
          v653.val[1] = vmlaq_f32(vmulq_n_f32(v653.val[0], v110), v651.val[0], v250);
          v258 = vmlaq_f32(vmulq_n_f32(v651.val[0], v109), v653.val[0], v250);
          vst2q_f32(v254, *(float32x4x2_t *)((char *)&v653 + 16));
          v254 += 8;
          v648.val[1] = vaddq_f32(v257, v648.val[1]);
          v648.val[0] = vsubq_f32(v648.val[0], v651.val[1]);
          v651.val[0] = vmlaq_f32(vmulq_n_f32(v648.val[0], v113), v648.val[1], v251);
          v651.val[1] = vmlaq_f32(vmulq_n_f32(v648.val[1], v111), v648.val[0], v251);
          vst2q_f32(v252, v651);
          v252 += 8;
          v247 -= 4;
        }
        while (v247);
        if (v248 != (v248 & 0xFFFFFFFFFFFFFFFCLL))
        {
LABEL_38:
          v115 = v114 + 1;
          v116 = &a3[v114];
          v117 = &v589[v84 + v114];
          do
          {
            v118 = *(v117 - 1);
            v119 = *v116 + v118;
            v120 = (4 * v115 - 4) | 4;
            v121 = *(float *)((char *)a3 + v120);
            v122 = v121 + *v117;
            v123 = *v116 - v118;
            v124 = v121 - *v117;
            v125 = &v116[v14 / 4];
            v126 = (float *)((char *)v116 + v81);
            v127 = *(float *)((char *)v116 + v81 - 4);
            v128 = *(float *)((char *)v116 + v81);
            v129 = v116[v14 / 4];
            v130 = v116[v14 / 4 + 1];
            v131 = v129 + v127;
            v132 = v129 - v127;
            *v116 = v119 + v131;
            v116 += 2;
            *(float *)((char *)a3 + v120) = v122 + (float)(v130 + v128);
            v133 = v119 - v131;
            v134 = v122 - (float)(v130 + v128);
            *v125 = (float)(v134 * v112) + (float)(a6.f32[0] * v133);
            v125[1] = (float)(v104 * v133) + (float)(a6.f32[0] * v134);
            *(v117 - 1) = (float)((float)(v124 + v132) * v110)
                        + (float)(a7.f32[0] * (float)(v123 - (float)(v130 - v128)));
            *v117 = (float)(v109 * (float)(v123 - (float)(v130 - v128))) + (float)(a7.f32[0] * (float)(v124 + v132));
            v135 = v123 + (float)(v130 - v128);
            v136 = v124 - v132;
            v137 = v115 + 1;
            v115 += 2;
            *(v126 - 1) = (float)(v136 * v113) + (float)(a9.f32[0] * v135);
            *v126 = (float)(v111 * v135) + (float)(a9.f32[0] * v136);
            v117 += 2;
          }
          while (v137 < v105);
        }
      }
      v138 = v90 + v595;
      v139 = v90 + v595 + v84;
      if (v90 + v595 >= v139)
        goto LABEL_13;
      v140 = v588 + v85 * v61;
      a7.f32[0] = *(float *)((char *)v82 + ((8 * v636) | 8));
      v141 = v601 + v140;
      v142 = *(float *)((char *)v82 + ((8 * v636) | 0xC));
      a9.f32[0] = a7.f32[0] - (float)((float)(a6.f32[0] + a6.f32[0]) * v142);
      v143 = -v142;
      v144 = -(float)(v142 - (float)((float)(a6.f32[0] + a6.f32[0]) * a7.f32[0]));
      a12.f32[0] = -v104;
      v145 = -a6.f32[0];
      v146 = -v144;
      if (v601 + v140 >= 0x2E)
      {
        v259 = (unint64_t)v580 + v97;
        v260 = v598 + v140;
        v261 = 8 * ((v598 + v140) >> 1);
        if ((char *)v580 + v97 + v261 >= (char *)v580 + v97)
        {
          v262 = &v543[v97];
          if (&v543[v97 + v261] >= &v543[v97])
          {
            v263 = (unint64_t)&v541[v97];
            if (&v541[v97 + v261] >= &v541[v97])
            {
              v264 = &v539[v97];
              if (&v539[v97 + v261] >= &v539[v97])
              {
                v265 = (unint64_t)v537 + v97;
                if ((char *)v537 + v97 + v261 >= (char *)v537 + v97)
                {
                  v266 = &v535[v97];
                  if (&v535[v97 + v261] >= &v535[v97])
                  {
                    v267 = &v533[v97];
                    if (&v533[v97 + v261] >= &v533[v97])
                    {
                      v268 = (unint64_t)&v531[v97];
                      if (&v531[v97 + v261] >= &v531[v97] && !(v260 >> 62))
                      {
                        v551 = v141;
                        v269 = (4 * (v596 + v588 + v581 * v61)) & 0xFFFFFFFFFFFFFFF8;
                        v270 = (unint64_t)&v262[v269];
                        v271 = (unint64_t)&v527[v97 + v269];
                        v272 = (unint64_t)&v264[v269];
                        v273 = (unint64_t)&v526[v97 + v269];
                        v274 = (unint64_t)&v266[v269];
                        v275 = (unint64_t)&v525[v97 + v269];
                        v276 = (unint64_t)&v267[v269];
                        v277 = (unint64_t)&v524[v97 + v269];
                        v279 = v259 < (unint64_t)&v264[v269] && v263 < v270;
                        v599 = v279;
                        v281 = v259 < v273 && (unint64_t)v264 < v270;
                        v283 = v259 < v274 && v265 < v270;
                        v602 = v283;
                        v285 = v259 < v275 && (unint64_t)v266 < v270;
                        v597 = v285;
                        v287 = v259 < v276 && v268 < v270;
                        v586 = v287;
                        v289 = v259 < v277 && (unint64_t)v267 < v270;
                        v578 = v289;
                        v291 = (unint64_t)v262 < v272 && v263 < v271;
                        v576 = v291;
                        v293 = (unint64_t)v262 < v273 && (unint64_t)v264 < v271;
                        v574 = v293;
                        v295 = (unint64_t)v262 < v274 && v265 < v271;
                        v572 = v295;
                        v297 = (unint64_t)v262 < v275 && (unint64_t)v266 < v271;
                        v570 = v297;
                        v299 = (unint64_t)v262 < v276 && v268 < v271;
                        v568 = v299;
                        v301 = (unint64_t)v262 < v277 && (unint64_t)v267 < v271;
                        v566 = v301;
                        v303 = v263 < v273 && (unint64_t)v264 < v272;
                        v564 = v303;
                        v305 = v263 < v274 && v265 < v272;
                        v562 = v305;
                        v307 = v263 < v275 && (unint64_t)v266 < v272;
                        v560 = v307;
                        v309 = v263 < v276 && v268 < v272;
                        v558 = v309;
                        v311 = v263 < v277 && (unint64_t)v267 < v272;
                        v313 = (unint64_t)v264 < v274 && v265 < v273;
                        v556 = v313;
                        v315 = (unint64_t)v264 < v275 && (unint64_t)v266 < v273;
                        v554 = v315;
                        v317 = (unint64_t)v264 < v276 && v268 < v273;
                        v319 = (unint64_t)v264 < v277 && (unint64_t)v267 < v273;
                        v321 = v265 < v275 && (unint64_t)v266 < v274;
                        v323 = v265 < v276 && v268 < v274;
                        v325 = v265 < v277 && (unint64_t)v267 < v274;
                        v327 = (unint64_t)v266 < v276 && v268 < v275;
                        v329 = (unint64_t)v266 < v277 && (unint64_t)v267 < v275;
                        v331 = v268 < v277 && (unint64_t)v267 < v276;
                        v332 = (unint64_t)v262 >= v270 || v259 >= v271;
                        if (!v332 || v599)
                        {
                          v82 = v582;
                          v83 = v583;
                          v84 = a2;
                          v85 = -(uint64_t)v14;
                        }
                        else
                        {
                          v333 = v281;
                          v82 = v582;
                          v83 = v583;
                          v85 = -(uint64_t)v14;
                          if (v333
                            || v602
                            || v597
                            || v586
                            || v578
                            || v576
                            || v574
                            || v572
                            || v570
                            || v568
                            || v566
                            || v564
                            || v562
                            || v560
                            || v558
                            || v311
                            || v556
                            || v554
                            || v317
                            || v319
                            || v321
                            || v323
                            || v325
                            || v327
                            || v329)
                          {
                            v84 = a2;
                          }
                          else
                          {
                            v84 = a2;
                            if (!v331)
                            {
                              v334 = v630;
                              v335 = (((v593 + v633) >> 1) + 1) & 0xFFFFFFFFFFFFFFFCLL;
                              v336 = (v551 >> 1) + 1;
                              v138 += 2 * (v336 & 0xFFFFFFFFFFFFFFFCLL);
                              v337 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a12.f32, 0);
                              v338 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 0);
                              v339 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a9.f32, 0);
                              v341 = v623;
                              v340 = v626;
                              v342 = v620;
                              do
                              {
                                v649 = vld2q_f32(v334);
                                v652 = vld2q_f32(v342);
                                v654 = vld2q_f32(v341);
                                v343 = vaddq_f32(v649.val[0], v652.val[0]);
                                v656 = vld2q_f32(v340);
                                v344 = vaddq_f32(v649.val[1], v652.val[1]);
                                v345 = vsubq_f32(v649.val[0], v652.val[0]);
                                v649.val[0] = vsubq_f32(v649.val[1], v652.val[1]);
                                v649.val[1] = vaddq_f32(v654.val[0], v656.val[0]);
                                v652.val[0] = vaddq_f32(v654.val[1], v656.val[1]);
                                v646.val[0] = vaddq_f32(v343, v649.val[1]);
                                v646.val[1] = vaddq_f32(v344, v652.val[0]);
                                vst2q_f32(v334, v646);
                                v334 += 8;
                                v652.val[1] = vsubq_f32(v654.val[0], v656.val[0]);
                                v649.val[1] = vsubq_f32(v343, v649.val[1]);
                                v652.val[0] = vsubq_f32(v344, v652.val[0]);
                                v646.val[0] = vmlaq_f32(vmulq_n_f32(v652.val[0], v145), v649.val[1], v337);
                                v646.val[1] = vmlaq_f32(vmulq_n_f32(v649.val[1], a6.f32[0]), v652.val[0], v337);
                                vst2q_f32(v341, v646);
                                v341 += 8;
                                v649.val[1] = vsubq_f32(v654.val[1], v656.val[1]);
                                v652.val[0] = vsubq_f32(v345, v649.val[1]);
                                v654.val[0] = vaddq_f32(v649.val[0], v652.val[1]);
                                v654.val[1] = vmlaq_f32(vmulq_n_f32(v654.val[0], v143), v652.val[0], v338);
                                v346 = vmlaq_f32(vmulq_n_f32(v652.val[0], v142), v654.val[0], v338);
                                vst2q_f32(v342, *(float32x4x2_t *)((char *)&v654 + 16));
                                v342 += 8;
                                v649.val[1] = vaddq_f32(v345, v649.val[1]);
                                v649.val[0] = vsubq_f32(v649.val[0], v652.val[1]);
                                v652.val[0] = vmlaq_f32(vmulq_n_f32(v649.val[0], v146), v649.val[1], v339);
                                v652.val[1] = vmlaq_f32(vmulq_n_f32(v649.val[1], v144), v649.val[0], v339);
                                vst2q_f32(v340, v652);
                                v340 += 8;
                                v335 -= 4;
                              }
                              while (v335);
                              if (v336 == (v336 & 0xFFFFFFFFFFFFFFFCLL))
                                goto LABEL_13;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v147 = v138 + 1;
      v148 = &a3[v138];
      v149 = &v589[v84 + v138];
      do
      {
        v150 = *(v149 - 1);
        v151 = *v148 + v150;
        v152 = (4 * v147 - 4) | 4;
        v153 = *(float *)((char *)a3 + v152);
        v154 = v153 + *v149;
        v155 = *v148 - v150;
        v156 = v153 - *v149;
        v157 = &v148[v14 / 4];
        v158 = (float *)((char *)v148 + v81);
        v159 = *(float *)((char *)v148 + v81 - 4);
        v160 = *(float *)((char *)v148 + v81);
        v161 = v148[v14 / 4];
        v162 = v148[v14 / 4 + 1];
        v163 = v161 + v159;
        v164 = v161 - v159;
        *v148 = v151 + v163;
        v148 += 2;
        *(float *)((char *)a3 + v152) = v154 + (float)(v162 + v160);
        v165 = v151 - v163;
        v166 = v154 - (float)(v162 + v160);
        *v157 = (float)(v166 * v145) + (float)(a12.f32[0] * v165);
        v157[1] = (float)(a6.f32[0] * v165) + (float)(a12.f32[0] * v166);
        *(v149 - 1) = (float)((float)(v156 + v164) * v143) + (float)(a7.f32[0] * (float)(v155 - (float)(v162 - v160)));
        *v149 = (float)(v142 * (float)(v155 - (float)(v162 - v160))) + (float)(a7.f32[0] * (float)(v156 + v164));
        v167 = v155 + (float)(v162 - v160);
        v168 = v156 - v164;
        v169 = v147 + 1;
        v147 += 2;
        *(v158 - 1) = (float)(v168 * v146) + (float)(a9.f32[0] * v167);
        *v158 = (float)(v144 * v167) + (float)(a9.f32[0] * v168);
        v149 += 2;
      }
      while (v169 < v139);
LABEL_13:
      v90 += v14;
      ++v61;
      v606 = (float *)((char *)v606 + v86);
      v608 = (float *)((char *)v608 + v86);
      v611 = (float *)((char *)v611 + v86);
      v614 = (float *)((char *)v614 + v86);
      v89 += v14;
      this = v604 + v14;
      v617 -= v14;
      v620 = (float *)((char *)v620 + v86);
      v623 = (float *)((char *)v623 + v86);
      v626 = (float *)((char *)v626 + v86);
      v630 = (float *)((char *)v630 + v86);
      v88 += v14;
      v87 += v14;
      v633 -= v14;
    }
    while (v90 < v83);
  }
  return this;
}

webrtc::FftBuffer *webrtc::FftBuffer::FftBuffer(webrtc::FftBuffer *this, unint64_t a2, unint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  _QWORD *v9;
  void **v10;
  void **v11;
  int64_t v12;
  uint64_t v13;
  char **v14;
  char *v15;
  char *v16;
  _BYTE *v17;

  *(_DWORD *)this = a2;
  v5 = (_QWORD *)((char *)this + 8);
  if (a3)
  {
    if (a3 > 0x7E07E07E07E07ELL)
      goto LABEL_22;
    v6 = 520 * a3;
    v7 = (char *)operator new(520 * a3);
    v8 = &v7[v6];
    bzero(v7, 520 * ((v6 - 520) / 0x208uLL) + 520);
    *v5 = 0;
    v5[1] = 0;
    v5[2] = 0;
    if (a2)
    {
LABEL_4:
      if (a2 < 0xAAAAAAAAAAAAAABLL)
      {
        v9 = operator new(24 * a2);
        v10 = (void **)v9;
        *((_QWORD *)this + 1) = v9;
        *((_QWORD *)this + 2) = v9;
        v11 = (void **)&v9[3 * a2];
        *((_QWORD *)this + 3) = v11;
        v12 = v8 - v7;
        if (v12)
        {
          if ((unint64_t)(0xFC0FC0FC0FC0FC1 * (v12 >> 3)) > 0x7E07E07E07E07ELL)
          {
            *v9 = 0;
            v9[1] = 0;
            v9[2] = 0;
            abort();
          }
          v13 = 24 * a2;
          v14 = (char **)(v9 + 1);
          do
          {
            *v14 = 0;
            v14[1] = 0;
            v15 = (char *)operator new(v12);
            *(v14 - 1) = v15;
            v16 = &v15[8 * (v12 >> 3)];
            v14[1] = v16;
            memcpy(v15, v7, v12);
            *v14 = v16;
            v14 += 3;
            v13 -= 24;
          }
          while (v13);
        }
        else
        {
          bzero(v9, 24 * ((24 * a2 - 24) / 0x18) + 24);
        }
        *((_QWORD *)this + 2) = v11;
        if (v7)
          goto LABEL_15;
        goto LABEL_16;
      }
LABEL_22:
      abort();
    }
  }
  else
  {
    v8 = 0;
    v7 = 0;
    *v5 = 0;
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 3) = 0;
    if (a2)
      goto LABEL_4;
  }
  v11 = 0;
  v10 = 0;
  if (v7)
  {
LABEL_15:
    operator delete(v7);
    v10 = (void **)*((_QWORD *)this + 1);
    v11 = (void **)*((_QWORD *)this + 2);
  }
LABEL_16:
  for (*((_QWORD *)this + 4) = 0; v10 != v11; v10 += 3)
  {
    v17 = v10[1];
    if (*v10 != v17)
      bzero(*v10, 520 * ((v17 - (_BYTE *)*v10 - 520) / 0x208uLL) + 520);
  }
  return this;
}

size_t webrtc::field_trial::FindFullName@<X0>(size_t result@<X0>, size_t a2@<X1>, size_t *a3@<X8>)
{
  uint64_t v4;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  unint64_t v10;
  BOOL v11;
  _BYTE *v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  size_t *v21;
  void *__s1;
  size_t __n;

  __s1 = (void *)result;
  v4 = webrtc::field_trial::trials_init_string;
  if (!webrtc::field_trial::trials_init_string
    || (result = strlen((const char *)webrtc::field_trial::trials_init_string)) == 0)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    return result;
  }
  v6 = result;
  __n = a2;
  v21 = a3;
  v7 = 0;
  while (1)
  {
    result = (size_t)memchr((void *)(v4 + v7), 47, v6 - v7);
    if (result)
      v8 = result - v4;
    else
      v8 = -1;
    v9 = v8 == -1 || v8 == v7;
    v10 = v8 + 1;
    v11 = !v9 && v6 > v10;
    if (!v11
      || ((v12 = (_BYTE *)(v4 + v10), (result = (size_t)memchr((void *)(v4 + v10), 47, v6 - v10)) == 0)
        ? (v13 = -1)
        : (v13 = result - v4),
          v13 != -1 ? (v14 = v13 == v10) : (v14 = 1),
          v14))
    {
LABEL_36:
      *v21 = 0;
      v21[1] = 0;
      v21[2] = 0;
      return result;
    }
    v15 = v8 - v7;
    if (v6 - v7 < v8 - v7)
      v15 = v6 - v7;
    if (v15 < 0)
      goto LABEL_47;
    v16 = v6 - v10 >= v13 + ~v8 ? v13 + ~v8 : v6 - v10;
    if ((v16 & 0x8000000000000000) != 0)
      goto LABEL_47;
    if (__n == v15)
    {
      result = memcmp(__s1, (const void *)(v4 + v7), __n);
      if (!(_DWORD)result)
        break;
    }
    v7 = v13 + 1;
    if (v13 + 1 >= v6)
      goto LABEL_36;
  }
  if (v16 >= 0x7FFFFFFFFFFFFFF8)
LABEL_48:
    abort();
  if (v16 > 0x16)
  {
    v17 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17)
      v17 = v16 | 7;
    v18 = v17 + 1;
    result = (size_t)operator new(v17 + 1);
    v21[1] = v16;
    v21[2] = v18 | 0x8000000000000000;
    *v21 = result;
  }
  else
  {
    result = (size_t)v21;
    *((_BYTE *)v21 + 23) = v16;
  }
  v19 = (_BYTE *)(result + v16);
  if (result <= (unint64_t)v12 && v19 > v12)
  {
LABEL_47:
    __break(1u);
    goto LABEL_48;
  }
  if (v16)
    result = (size_t)memmove((void *)result, v12, v16);
  *v19 = 0;
  return result;
}

void webrtc::field_trial::InitFieldTrialsFromString(webrtc::field_trial *this, const char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    rtc::webrtc_logging_impl::Log("\r\t\t", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/system_wrappers/source/field_trial.cc");
  webrtc::field_trial::trials_init_string = (uint64_t)this;
}

void webrtc::FieldTrialBasedConfig::GetValue(char *__src@<X1>, size_t __len@<X2>, size_t *a3@<X8>)
{
  char *p_p;
  size_t v7;
  size_t v8;
  char *v9;
  size_t v11;
  void *v12;
  void *__p;
  size_t v14;
  unint64_t v15;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
LABEL_21:
    abort();
  if (__len > 0x16)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    p_p = (char *)operator new(v7 + 1);
    v14 = __len;
    v15 = v8 | 0x8000000000000000;
    __p = p_p;
  }
  else
  {
    HIBYTE(v15) = __len;
    p_p = (char *)&__p;
  }
  v9 = &p_p[__len];
  if (p_p <= __src && v9 > __src)
  {
LABEL_20:
    __break(1u);
    goto LABEL_21;
  }
  if (__len)
    memmove(p_p, __src, __len);
  *v9 = 0;
  if (SHIBYTE(v15) < 0)
  {
    v11 = v14;
    if ((v14 & 0x8000000000000000) == 0)
    {
      v12 = __p;
      if (!v14 || __p)
        goto LABEL_18;
    }
    goto LABEL_20;
  }
  v11 = HIBYTE(v15);
  v12 = &__p;
LABEL_18:
  webrtc::field_trial::FindFullName((size_t)v12, v11, a3);
  if (SHIBYTE(v15) < 0)
    operator delete(__p);
}

void webrtc::FieldTrialBasedConfig::~FieldTrialBasedConfig(webrtc::FieldTrialBasedConfig *this)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = &unk_24C0B4260;
  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    v3 = *((_QWORD *)this + 2);
    v4 = (void *)*((_QWORD *)this + 1);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 1);
    }
    *((_QWORD *)this + 2) = v2;
    operator delete(v4);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *(_QWORD *)this = &unk_24C0B4260;
  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    v3 = *((_QWORD *)this + 2);
    v4 = (void *)*((_QWORD *)this + 1);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0)
          operator delete(*(void **)(v3 - 24));
        v3 -= 24;
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 1);
    }
    *((_QWORD *)this + 2) = v2;
    operator delete(v4);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialStructListBase::Parse()
{
  return 1;
}

void webrtc::FieldTrialStructListBase::~FieldTrialStructListBase(webrtc::FieldTrialStructListBase *this)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_24C0B3F90;
  v2 = (_QWORD *)*((_QWORD *)this + 8);
  if (v2)
  {
    v3 = (_QWORD *)*((_QWORD *)this + 9);
    v4 = (void *)*((_QWORD *)this + 8);
    if (v3 != v2)
    {
      do
      {
        v6 = *--v3;
        v5 = v6;
        *v3 = 0;
        if (v6)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 8);
    }
    *((_QWORD *)this + 9) = v2;
    operator delete(v4);
  }
  *(_QWORD *)this = off_24C0B4170;
  if (*((char *)this + 55) < 0)
  {
    operator delete(*((void **)this + 4));
    v7 = (void *)*((_QWORD *)this + 1);
    if (!v7)
      return;
  }
  else
  {
    v7 = (void *)*((_QWORD *)this + 1);
    if (!v7)
      return;
  }
  *((_QWORD *)this + 2) = v7;
  operator delete(v7);
}

{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = off_24C0B3F90;
  v2 = (_QWORD *)*((_QWORD *)this + 8);
  if (v2)
  {
    v3 = (_QWORD *)*((_QWORD *)this + 9);
    v4 = (void *)*((_QWORD *)this + 8);
    if (v3 != v2)
    {
      do
      {
        v6 = *--v3;
        v5 = v6;
        *v3 = 0;
        if (v6)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 8);
    }
    *((_QWORD *)this + 9) = v2;
    operator delete(v4);
  }
  *(_QWORD *)this = off_24C0B4170;
  if (*((char *)this + 55) < 0)
  {
    operator delete(*((void **)this + 4));
    v7 = (void *)*((_QWORD *)this + 1);
    if (!v7)
      goto LABEL_14;
  }
  else
  {
    v7 = (void *)*((_QWORD *)this + 1);
    if (!v7)
      goto LABEL_14;
  }
  *((_QWORD *)this + 2) = v7;
  operator delete(v7);
LABEL_14:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialParameter<BOOL>::Parse(uint64_t result, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;

  v2 = a2[24];
  if (!a2[24])
    return v2;
  if ((char)a2[23] < 0)
  {
    v3 = *((_QWORD *)a2 + 1);
    if (v3 < 0 || (a2 = *(unsigned __int8 **)a2, v3) && !a2)
    {
      __break(1u);
      return result;
    }
  }
  else
  {
    v3 = a2[23];
  }
  if (v3 == 1)
  {
    v4 = *a2;
    if (v4 != 48)
    {
      if (v4 != 49)
        return 0;
      goto LABEL_14;
    }
  }
  else
  {
    if (v3 != 5)
    {
      if (v3 != 4 || *(_DWORD *)a2 != 1702195828)
        return 0;
LABEL_14:
      *(_BYTE *)(result + 57) = 1;
      return 1;
    }
    v2 = 0;
    if (*(_DWORD *)a2 != 1936482662 || a2[4] != 101)
      return v2;
  }
  *(_BYTE *)(result + 57) = 0;
  return 1;
}

uint64_t webrtc::FieldTrialParameter<double>::Parse(uint64_t result, _BYTE *__src)
{
  uint64_t v2;
  size_t v3;
  uint64_t v4;
  char v5;

  if (!__src[24])
    return 0;
  v2 = result;
  if (((char)__src[23] & 0x80000000) == 0)
  {
    v3 = __src[23];
    goto LABEL_7;
  }
  v3 = *((_QWORD *)__src + 1);
  if ((v3 & 0x8000000000000000) == 0)
  {
    __src = *(_BYTE **)__src;
    if (!v3 || __src)
    {
LABEL_7:
      v4 = webrtc::ParseTypedParameter<double>(__src, v3);
      if (v5)
      {
        *(_QWORD *)(v2 + 64) = v4;
        return 1;
      }
      return 0;
    }
  }
  __break(1u);
  return result;
}

uint64_t webrtc::ParseTypedParameter<double>(char *__src, size_t __len)
{
  char *v4;
  size_t v5;
  size_t v6;
  char *v7;
  void **v9;
  int v10;
  int v11;
  uint64_t result;
  void *__p[2];
  int64_t v14;
  __int16 v15;
  double v16;

  v15 = 0;
  if (__len >= 0x7FFFFFFFFFFFFFF8)
LABEL_24:
    abort();
  if (__len > 0x16)
  {
    v5 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v5 = __len | 7;
    v6 = v5 + 1;
    v4 = (char *)operator new(v5 + 1);
    __p[1] = (void *)__len;
    v14 = v6 | 0x8000000000000000;
    __p[0] = v4;
  }
  else
  {
    HIBYTE(v14) = __len;
    v4 = (char *)__p;
  }
  v16 = 0.0;
  v7 = &v4[__len];
  if (v4 <= __src && v7 > __src)
  {
    __break(1u);
    goto LABEL_24;
  }
  if (__len)
    memmove(v4, __src, __len);
  *v7 = 0;
  if (v14 >= 0)
    v9 = __p;
  else
    v9 = (void **)__p[0];
  v10 = sscanf((const char *)v9, "%lf%1s", &v16, &v15);
  v11 = v10;
  if ((SHIBYTE(v14) & 0x80000000) == 0)
  {
    if (v10 >= 1)
      goto LABEL_18;
LABEL_21:
    *(double *)&result = 0.0;
    return result;
  }
  operator delete(__p[0]);
  if (v11 < 1)
    goto LABEL_21;
LABEL_18:
  if (v15 == 37)
    *(double *)&result = v16 / 100.0;
  else
    *(double *)&result = v16;
  return result;
}

uint64_t webrtc::FieldTrialParameter<int>::Parse(uint64_t result, _BYTE *__src)
{
  uint64_t v2;
  size_t v3;
  unint64_t v4;

  if (!__src[24])
    return 0;
  v2 = result;
  if ((char)__src[23] < 0)
  {
    v3 = *((_QWORD *)__src + 1);
    if ((v3 & 0x8000000000000000) != 0 || (__src = *(_BYTE **)__src, v3) && !__src)
    {
      __break(1u);
      return result;
    }
  }
  else
  {
    v3 = __src[23];
  }
  v4 = webrtc::ParseTypedParameter<int>(__src, v3);
  if (!HIDWORD(v4))
    return 0;
  *(_DWORD *)(v2 + 60) = v4;
  return 1;
}

uint64_t webrtc::ParseTypedParameter<int>(char *__src, size_t __len)
{
  char *v4;
  size_t v5;
  size_t v6;
  char *v7;
  void **v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *__p[2];
  int64_t v17;
  uint64_t v18;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
LABEL_25:
    abort();
  if (__len > 0x16)
  {
    v5 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v5 = __len | 7;
    v6 = v5 + 1;
    v4 = (char *)operator new(v5 + 1);
    __p[1] = (void *)__len;
    v17 = v6 | 0x8000000000000000;
    __p[0] = v4;
  }
  else
  {
    HIBYTE(v17) = __len;
    v4 = (char *)__p;
  }
  v18 = 0;
  v7 = &v4[__len];
  if (v4 <= __src && v7 > __src)
  {
    __break(1u);
    goto LABEL_25;
  }
  if (__len)
    memmove(v4, __src, __len);
  *v7 = 0;
  if (v17 >= 0)
    v9 = __p;
  else
    v9 = (void **)__p[0];
  v10 = sscanf((const char *)v9, "%lld", &v18);
  v11 = v10;
  if (SHIBYTE(v17) < 0)
  {
    operator delete(__p[0]);
    if (v11 != 1)
      goto LABEL_21;
  }
  else if (v10 != 1)
  {
    goto LABEL_21;
  }
  if (!((v18 < (uint64_t)0xFFFFFFFF80000000) | (2 * (v18 > 0x7FFFFFFF))))
  {
    v14 = v18 & 0xFFFFFF00;
    v13 = v18;
    v12 = 0x100000000;
    return v13 | v12 | v14;
  }
LABEL_21:
  v12 = 0;
  v13 = 0;
  v14 = 0;
  return v13 | v12 | v14;
}

uint64_t webrtc::FieldTrialParameter<unsigned int>::Parse(uint64_t result, _BYTE *__src)
{
  uint64_t v2;
  size_t v3;
  unint64_t v4;

  if (!__src[24])
    return 0;
  v2 = result;
  if ((char)__src[23] < 0)
  {
    v3 = *((_QWORD *)__src + 1);
    if ((v3 & 0x8000000000000000) != 0 || (__src = *(_BYTE **)__src, v3) && !__src)
    {
      __break(1u);
      return result;
    }
  }
  else
  {
    v3 = __src[23];
  }
  v4 = webrtc::ParseTypedParameter<unsigned int>(__src, v3);
  if (!HIDWORD(v4))
    return 0;
  *(_DWORD *)(v2 + 60) = v4;
  return 1;
}

uint64_t webrtc::ParseTypedParameter<unsigned int>(char *__src, size_t __len)
{
  char *v4;
  size_t v5;
  size_t v6;
  char *v7;
  void **v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *__p[2];
  int64_t v17;
  uint64_t v18;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
LABEL_25:
    abort();
  if (__len > 0x16)
  {
    v5 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v5 = __len | 7;
    v6 = v5 + 1;
    v4 = (char *)operator new(v5 + 1);
    __p[1] = (void *)__len;
    v17 = v6 | 0x8000000000000000;
    __p[0] = v4;
  }
  else
  {
    HIBYTE(v17) = __len;
    v4 = (char *)__p;
  }
  v18 = 0;
  v7 = &v4[__len];
  if (v4 <= __src && v7 > __src)
  {
    __break(1u);
    goto LABEL_25;
  }
  if (__len)
    memmove(v4, __src, __len);
  *v7 = 0;
  if (v17 >= 0)
    v9 = __p;
  else
    v9 = (void **)__p[0];
  v10 = sscanf((const char *)v9, "%lld", &v18);
  v11 = v10;
  if (SHIBYTE(v17) < 0)
  {
    operator delete(__p[0]);
    if (v11 != 1)
      goto LABEL_21;
  }
  else if (v10 != 1)
  {
    goto LABEL_21;
  }
  if (!(((unint64_t)v18 >> 63) | (2 * (v18 > 0xFFFFFFFFLL))))
  {
    v14 = v18 & 0xFFFFFF00;
    v13 = v18;
    v12 = 0x100000000;
    return v13 | v12 | v14;
  }
LABEL_21:
  v12 = 0;
  v13 = 0;
  v14 = 0;
  return v13 | v12 | v14;
}

uint64_t webrtc::FieldTrialConstrained<double>::Parse(uint64_t result, _BYTE *__src)
{
  uint64_t v2;
  size_t v3;
  double v4;
  char v5;

  if (!__src[24])
    return 0;
  v2 = result;
  if ((char)__src[23] < 0)
  {
    v3 = *((_QWORD *)__src + 1);
    if ((v3 & 0x8000000000000000) != 0 || (__src = *(_BYTE **)__src, v3) && !__src)
    {
      __break(1u);
      return result;
    }
  }
  else
  {
    v3 = __src[23];
  }
  v4 = COERCE_DOUBLE(webrtc::ParseTypedParameter<double>(__src, v3));
  if (!v5 || *(_BYTE *)(v2 + 80) && *(double *)(v2 + 72) > v4 || *(_BYTE *)(v2 + 96) && *(double *)(v2 + 88) < v4)
    return 0;
  *(double *)(v2 + 64) = v4;
  return 1;
}

uint64_t webrtc::FieldTrialConstrained<int>::Parse(uint64_t result, _BYTE *__src)
{
  uint64_t v2;
  size_t v3;
  unint64_t v4;

  if (!__src[24])
    return 0;
  v2 = result;
  if ((char)__src[23] < 0)
  {
    v3 = *((_QWORD *)__src + 1);
    if ((v3 & 0x8000000000000000) != 0 || (__src = *(_BYTE **)__src, v3) && !__src)
    {
      __break(1u);
      return result;
    }
  }
  else
  {
    v3 = __src[23];
  }
  v4 = webrtc::ParseTypedParameter<int>(__src, v3);
  if (!HIDWORD(v4)
    || *(_BYTE *)(v2 + 68) && *(_DWORD *)(v2 + 64) > (int)v4
    || *(_BYTE *)(v2 + 76) && *(_DWORD *)(v2 + 72) < (int)v4)
  {
    return 0;
  }
  *(_DWORD *)(v2 + 60) = v4;
  return 1;
}

uint64_t webrtc::FieldTrialOptional<double>::Parse(uint64_t result, char *__src)
{
  uint64_t v2;
  size_t v3;
  uint64_t v4;
  char v5;

  v2 = result;
  if (__src[24])
  {
    if (__src[23] < 0)
    {
      v3 = *((_QWORD *)__src + 1);
      if ((v3 & 0x8000000000000000) != 0 || (__src = *(char **)__src, v3) && !__src)
      {
        __break(1u);
        return result;
      }
    }
    else
    {
      v3 = __src[23];
    }
    v4 = webrtc::ParseTypedParameter<double>(__src, v3);
    if (v5)
    {
      *(_QWORD *)(v2 + 64) = v4;
      result = 1;
      *(_BYTE *)(v2 + 72) = 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (*(_BYTE *)(result + 72))
      *(_BYTE *)(result + 72) = 0;
    return 1;
  }
  return result;
}

uint64_t webrtc::FieldTrialOptional<int>::Parse(uint64_t result, char *__src)
{
  uint64_t v2;
  size_t v3;
  unint64_t v4;

  v2 = result;
  if (__src[24])
  {
    if (__src[23] < 0)
    {
      v3 = *((_QWORD *)__src + 1);
      if ((v3 & 0x8000000000000000) != 0 || (__src = *(char **)__src, v3) && !__src)
      {
        __break(1u);
        return result;
      }
    }
    else
    {
      v3 = __src[23];
    }
    v4 = webrtc::ParseTypedParameter<int>(__src, v3);
    if (HIDWORD(v4))
    {
      *(_DWORD *)(v2 + 60) = v4;
      result = 1;
      *(_BYTE *)(v2 + 64) = 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (*(_BYTE *)(result + 64))
      *(_BYTE *)(result + 64) = 0;
    return 1;
  }
  return result;
}

uint64_t webrtc::FieldTrialOptional<unsigned int>::Parse(uint64_t result, char *__src)
{
  uint64_t v2;
  size_t v3;
  unint64_t v4;

  v2 = result;
  if (__src[24])
  {
    if (__src[23] < 0)
    {
      v3 = *((_QWORD *)__src + 1);
      if ((v3 & 0x8000000000000000) != 0 || (__src = *(char **)__src, v3) && !__src)
      {
        __break(1u);
        return result;
      }
    }
    else
    {
      v3 = __src[23];
    }
    v4 = webrtc::ParseTypedParameter<unsigned int>(__src, v3);
    if (HIDWORD(v4))
    {
      *(_DWORD *)(v2 + 60) = v4;
      result = 1;
      *(_BYTE *)(v2 + 64) = 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (*(_BYTE *)(result + 64))
      *(_BYTE *)(result + 64) = 0;
    return 1;
  }
  return result;
}

void webrtc::ParseFieldTrial(_QWORD *a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t *v7;
  _QWORD *v8;
  size_t v9;
  uint64_t v10;
  _QWORD *v11;
  size_t v12;
  BOOL v13;
  uint64_t *v14;
  uint64_t **v15;
  uint64_t **v16;
  unint64_t v17;
  const void *v18;
  size_t v19;
  int v20;
  int v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  _BYTE *v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t **v38;
  uint64_t **v39;
  unint64_t v40;
  const void *v41;
  size_t v42;
  int v43;
  int v44;
  uint64_t *v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  int v50;
  char *v51;
  unint64_t v52;
  size_t v53;
  int v54;
  unint64_t v55;
  size_t v56;
  char *v57;
  unint64_t v58;
  char v59;
  char v60;
  uint64_t *v61;
  _BYTE *v62;
  size_t v63;
  __int128 *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t **v68;
  unint64_t v69;
  size_t v70;
  int v71;
  size_t v72;
  size_t v73;
  int v74;
  uint64_t *v75;
  char v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char v84;
  __int128 *p_dst;
  uint64_t v86;
  uint64_t v87;
  char v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t **v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  size_t v104;
  char *v105;
  BOOL v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  size_t v110;
  __int128 *v111;
  size_t v112;
  unint64_t v113;
  __int128 *v114;
  char *v115;
  unint64_t v116;
  __int128 *v117;
  size_t v119;
  unint64_t v120;
  uint64_t v121;
  uint64_t v122;
  unint64_t v123;
  size_t v124;
  unint64_t v125;
  char *v126;
  size_t v127;
  unint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  uint64_t *v133;
  __int128 *v134;
  _WORD *v135;
  size_t v136;
  uint64_t **v137;
  uint64_t *v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v144;
  unint64_t v145;
  unint64_t v146;
  uint64_t v147;
  _QWORD *v148;
  char v149;
  uint64_t *__s2;
  char *__s2a;
  uint64_t **v152;
  __int128 __dst;
  int64_t v154;
  void *v155[2];
  int64_t v156;
  char v157;
  void *__p[2];
  unint64_t v159;
  char v160;
  __int128 v161;
  unint64_t v162;
  char v163;
  char *v164;
  size_t v165;
  uint64_t **v166;
  uint64_t *v167;
  uint64_t v168;
  char *v169;
  uint64_t v170;

  v169 = a3;
  v170 = a4;
  v167 = 0;
  v168 = 0;
  v152 = &v167;
  v166 = &v167;
  if (!a2)
  {
    v47 = a4;
    v147 = 0;
    if (!a4)
      goto LABEL_294;
    goto LABEL_90;
  }
  v4 = 0;
  v5 = a1;
  v146 = (unint64_t)&a1[a2];
  v147 = 0;
  do
  {
    v148 = v5;
    v6 = *v5;
    *(_BYTE *)(v6 + 56) = 1;
    v7 = *(uint64_t **)(v6 + 8);
    __s2 = *(uint64_t **)(v6 + 16);
    if (v7 == __s2)
    {
      v8 = (_QWORD *)(v6 + 32);
      if (*(char *)(v6 + 55) < 0)
      {
        v9 = *(_QWORD *)(v6 + 40);
        if (!v9)
        {
LABEL_3:
          v147 = v6;
          goto LABEL_4;
        }
        if ((v9 & 0x8000000000000000) != 0)
          goto LABEL_298;
        v8 = (_QWORD *)*v8;
        if (!v8)
          goto LABEL_298;
      }
      else
      {
        v9 = *(unsigned __int8 *)(v6 + 55);
        if (!*(_BYTE *)(v6 + 55))
          goto LABEL_3;
      }
      v37 = v167;
      v38 = v152;
LABEL_69:
      v39 = v38;
      if (v37)
      {
        do
        {
          v38 = (uint64_t **)v37;
          v41 = (const void *)v37[4];
          v40 = v37[5];
          if (v40 >= v9)
            v42 = v9;
          else
            v42 = v37[5];
          v43 = memcmp(v8, (const void *)v37[4], v42);
          if (v43)
          {
            if (v43 < 0)
              goto LABEL_68;
          }
          else if (v40 > v9)
          {
LABEL_68:
            v37 = *v38;
            goto LABEL_69;
          }
          v44 = memcmp(v41, v8, v42);
          if (v44)
          {
            if ((v44 & 0x80000000) == 0)
              goto LABEL_86;
          }
          else if (v40 >= v9)
          {
            goto LABEL_86;
          }
          v37 = v38[1];
        }
        while (v37);
        v39 = v38 + 1;
      }
      v45 = (uint64_t *)v38;
      v38 = (uint64_t **)operator new(0x38uLL);
      v38[4] = v8;
      v38[5] = (uint64_t *)v9;
      v38[6] = 0;
      *v38 = 0;
      v38[1] = 0;
      v38[2] = v45;
      *v39 = (uint64_t *)v38;
      v46 = (uint64_t *)v38;
      if (*v166)
      {
        v166 = (uint64_t **)*v166;
        v46 = *v39;
      }
      std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(v167, v46);
      v4 = ++v168;
LABEL_86:
      v38[6] = (uint64_t *)v6;
    }
    else
    {
      do
      {
        v10 = *v7;
        *(_BYTE *)(v10 + 56) = 1;
        v11 = (_QWORD *)(v10 + 32);
        if (*(char *)(v10 + 55) < 0)
        {
          v12 = *(_QWORD *)(v10 + 40);
          if ((v12 & 0x8000000000000000) != 0)
            goto LABEL_298;
          v11 = (_QWORD *)*v11;
          v13 = v12 && v11 == 0;
          if (v13)
            goto LABEL_298;
        }
        else
        {
          v12 = *(unsigned __int8 *)(v10 + 55);
        }
        v14 = v167;
        v15 = v152;
LABEL_23:
        v16 = v15;
        if (v14)
        {
          do
          {
            v15 = (uint64_t **)v14;
            v18 = (const void *)v14[4];
            v17 = v14[5];
            if (v17 >= v12)
              v19 = v12;
            else
              v19 = v14[5];
            v20 = memcmp(v11, (const void *)v14[4], v19);
            if (v20)
            {
              if (v20 < 0)
                goto LABEL_22;
            }
            else if (v12 < v17)
            {
LABEL_22:
              v14 = *v15;
              goto LABEL_23;
            }
            v21 = memcmp(v18, v11, v19);
            if (v21)
            {
              if ((v21 & 0x80000000) == 0)
                goto LABEL_13;
            }
            else if (v17 >= v12)
            {
              goto LABEL_13;
            }
            v14 = v15[1];
          }
          while (v14);
          v16 = v15 + 1;
        }
        v22 = (uint64_t *)v15;
        v15 = (uint64_t **)operator new(0x38uLL);
        v15[4] = v11;
        v15[5] = (uint64_t *)v12;
        v15[6] = 0;
        *v15 = 0;
        v15[1] = 0;
        v15[2] = v22;
        *v16 = (uint64_t *)v15;
        v23 = (uint64_t *)v15;
        if (*v166)
        {
          v166 = (uint64_t **)*v166;
          v23 = *v16;
        }
        v24 = v167;
        *((_BYTE *)v23 + 24) = v23 == v167;
        if (v23 != v24)
        {
          do
          {
            v25 = v23[2];
            if (*(_BYTE *)(v25 + 24))
              break;
            v26 = *(uint64_t **)(v25 + 16);
            v27 = *v26;
            if (*v26 == v25)
            {
              v30 = v26[1];
              if (!v30 || (v31 = *(unsigned __int8 *)(v30 + 24), v28 = (_BYTE *)(v30 + 24), v31))
              {
                if (*(uint64_t **)v25 == v23)
                {
                  *(_BYTE *)(v25 + 24) = 1;
                  *((_BYTE *)v26 + 24) = 0;
                  v34 = *(_QWORD *)(v25 + 8);
                  *v26 = v34;
                  if (v34)
                    goto LABEL_53;
                }
                else
                {
                  v32 = *(uint64_t **)(v25 + 8);
                  v33 = *v32;
                  *(_QWORD *)(v25 + 8) = *v32;
                  if (v33)
                  {
                    *(_QWORD *)(v33 + 16) = v25;
                    v26 = *(uint64_t **)(v25 + 16);
                  }
                  v32[2] = (uint64_t)v26;
                  *(_QWORD *)(*(_QWORD *)(v25 + 16) + 8 * (**(_QWORD **)(v25 + 16) != v25)) = v32;
                  *v32 = v25;
                  *(_QWORD *)(v25 + 16) = v32;
                  v26 = (uint64_t *)v32[2];
                  v25 = *v26;
                  *((_BYTE *)v32 + 24) = 1;
                  *((_BYTE *)v26 + 24) = 0;
                  v34 = *(_QWORD *)(v25 + 8);
                  *v26 = v34;
                  if (v34)
LABEL_53:
                    *(_QWORD *)(v34 + 16) = v26;
                }
                *(_QWORD *)(v25 + 16) = v26[2];
                *(_QWORD *)(v26[2] + 8 * (*(_QWORD *)v26[2] != (_QWORD)v26)) = v25;
                *(_QWORD *)(v25 + 8) = v26;
LABEL_11:
                v26[2] = v25;
                break;
              }
            }
            else if (!v27 || (v29 = *(unsigned __int8 *)(v27 + 24), v28 = (_BYTE *)(v27 + 24), v29))
            {
              if (*(uint64_t **)v25 == v23)
              {
                v36 = v23[1];
                *(_QWORD *)v25 = v36;
                if (v36)
                {
                  *(_QWORD *)(v36 + 16) = v25;
                  v26 = *(uint64_t **)(v25 + 16);
                }
                v23[2] = (uint64_t)v26;
                *(_QWORD *)(*(_QWORD *)(v25 + 16) + 8 * (**(_QWORD **)(v25 + 16) != v25)) = v23;
                v23[1] = v25;
                *(_QWORD *)(v25 + 16) = v23;
                v26 = (uint64_t *)v23[2];
                *((_BYTE *)v23 + 24) = 1;
                *((_BYTE *)v26 + 24) = 0;
                v25 = v26[1];
                v35 = *(uint64_t **)v25;
                v26[1] = *(_QWORD *)v25;
                if (!v35)
                  goto LABEL_10;
              }
              else
              {
                *(_BYTE *)(v25 + 24) = 1;
                *((_BYTE *)v26 + 24) = 0;
                v25 = v26[1];
                v35 = *(uint64_t **)v25;
                v26[1] = *(_QWORD *)v25;
                if (!v35)
                  goto LABEL_10;
              }
              v35[2] = (uint64_t)v26;
LABEL_10:
              *(_QWORD *)(v25 + 16) = v26[2];
              *(_QWORD *)(v26[2] + 8 * (*(_QWORD *)v26[2] != (_QWORD)v26)) = v25;
              *(_QWORD *)v25 = v26;
              goto LABEL_11;
            }
            *(_BYTE *)(v25 + 24) = 1;
            v23 = v26;
            *((_BYTE *)v26 + 24) = v26 == v24;
            *v28 = 1;
          }
          while (v26 != v24);
        }
        v168 = ++v4;
LABEL_13:
        v15[6] = (uint64_t *)v10;
        ++v7;
      }
      while (v7 != __s2);
    }
LABEL_4:
    v5 = v148 + 1;
  }
  while (v148 + 1 != (_QWORD *)v146);
  v47 = v170;
  if (!v170)
    goto LABEL_294;
LABEL_90:
  v149 = 0;
  __s2a = v169;
  while (2)
  {
    v48 = 0;
    v49 = __s2a;
    while (1)
    {
      v50 = __s2a[v48];
      if (v50 == 44 || v50 == 58)
        break;
      if (v47 == ++v48)
      {
        v51 = &__s2a[v47];
        goto LABEL_98;
      }
    }
    v51 = &__s2a[v48];
LABEL_98:
    if (v51 == &__s2a[v47])
      v52 = -1;
    else
      v52 = v51 - __s2a;
    if (v47 >= v52)
      v53 = v52;
    else
      v53 = v47;
    if ((v53 & 0x8000000000000000) != 0 || !__s2a && v53)
      goto LABEL_298;
    v164 = __s2a;
    v165 = v53;
    LOBYTE(v161) = 0;
    v163 = 0;
    if (v52 == -1)
    {
      v59 = 0;
      v47 = 0;
      v60 = 1;
      __s2a = &byte_208EB9246;
      v61 = v167;
      if (!v167)
        goto LABEL_165;
      goto LABEL_140;
    }
    if (v47 <= v52)
      goto LABEL_298;
    v54 = __s2a[v52];
    v55 = v52 + 1;
    v56 = v47 - v55;
    if (v54 != 58)
    {
      if ((v56 & 0x8000000000000000) != 0)
        goto LABEL_298;
      v59 = 0;
      __s2a += v55;
      v60 = 1;
      v47 -= v55;
      v61 = v167;
      if (!v167)
        goto LABEL_165;
      goto LABEL_140;
    }
    if ((v56 & 0x8000000000000000) != 0)
      goto LABEL_298;
    v57 = &__s2a[v55];
    if (v47 == v55)
    {
      v58 = -1;
    }
    else
    {
      v62 = memchr(&__s2a[v55], 44, v47 - v55);
      if (v62)
        v58 = v62 - v57;
      else
        v58 = -1;
    }
    if (v56 >= v58)
      v63 = v58;
    else
      v63 = v56;
    if (v63 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_299;
    if (v63 > 0x16)
    {
      v66 = (v63 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v63 | 7) != 0x17)
        v66 = v63 | 7;
      v67 = v66 + 1;
      v64 = (__int128 *)operator new(v66 + 1);
      *((_QWORD *)&v161 + 1) = v63;
      v162 = v67 | 0x8000000000000000;
      *(_QWORD *)&v161 = v64;
      v65 = (char *)v64 + v63;
      if (v64 > (__int128 *)v57)
        goto LABEL_132;
LABEL_131:
      if (v65 > v57)
        goto LABEL_298;
      goto LABEL_132;
    }
    HIBYTE(v162) = v63;
    v64 = &v161;
    v65 = (char *)&v161 + v63;
    if (&v161 <= (__int128 *)v57)
      goto LABEL_131;
LABEL_132:
    if (v63)
      memmove(v64, v57, v63);
    *v65 = 0;
    v59 = 1;
    v163 = 1;
    if (v58 == -1)
    {
      v60 = 0;
      v47 = 0;
      __s2a = &byte_208EB9246;
      v61 = v167;
      if (!v167)
        goto LABEL_165;
    }
    else
    {
      if (v56 <= v58)
        goto LABEL_299;
      v47 = v56 - (v58 + 1);
      if (v47 < 0)
        goto LABEL_298;
      v60 = 0;
      __s2a = &v57[v58 + 1];
      v61 = v167;
      if (!v167)
        goto LABEL_165;
    }
LABEL_140:
    v68 = v152;
    while (2)
    {
      while (2)
      {
        v69 = v61[5];
        if (v53 >= v69)
          v70 = v61[5];
        else
          v70 = v53;
        v71 = memcmp((const void *)v61[4], v49, v70);
        if (v71)
        {
          if ((v71 & 0x80000000) == 0)
            break;
          goto LABEL_141;
        }
        if (v69 < v53)
        {
LABEL_141:
          v61 = (uint64_t *)v61[1];
          if (!v61)
            goto LABEL_150;
          continue;
        }
        break;
      }
      v68 = (uint64_t **)v61;
      v61 = (uint64_t *)*v61;
      if (v61)
        continue;
      break;
    }
LABEL_150:
    if (v68 == v152)
      goto LABEL_165;
    v72 = (size_t)v68[5];
    if (v72 >= v53)
      v73 = v53;
    else
      v73 = (size_t)v68[5];
    v74 = memcmp(v49, v68[4], v73);
    if (v74)
    {
      if ((v74 & 0x80000000) == 0)
        goto LABEL_156;
LABEL_165:
      if (v147)
        v84 = v59;
      else
        v84 = 1;
      if (v53 && (v84 & 1) == 0)
      {
        if (v53 <= 0x7FFFFFFFFFFFFFF7)
        {
          if (v53 > 0x16)
          {
            v86 = (v53 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v53 | 7) != 0x17)
              v86 = v53 | 7;
            v87 = v86 + 1;
            p_dst = (__int128 *)operator new(v86 + 1);
            *((_QWORD *)&__dst + 1) = v53;
            v154 = v87 | 0x8000000000000000;
            *(_QWORD *)&__dst = p_dst;
            if (p_dst <= (__int128 *)v49)
              goto LABEL_180;
            goto LABEL_181;
          }
          HIBYTE(v154) = v53;
          p_dst = &__dst;
          if (&__dst > (__int128 *)v49)
            goto LABEL_181;
LABEL_180:
          if ((char *)p_dst + v53 <= v49)
          {
LABEL_181:
            memmove(p_dst, v49, v53);
            *((_BYTE *)p_dst + v53) = 0;
            *(_OWORD *)v155 = __dst;
            v156 = v154;
            __dst = 0uLL;
            v154 = 0;
            v157 = 1;
            v88 = (*(uint64_t (**)(uint64_t, void **))(*(_QWORD *)v147 + 16))(v147, v155);
            if (v157 && SHIBYTE(v156) < 0)
              operator delete(v155[0]);
            if (SHIBYTE(v154) < 0)
            {
              operator delete((void *)__dst);
              if ((v88 & 1) == 0)
                goto LABEL_192;
            }
            else
            {
              if ((v88 & 1) != 0)
                goto LABEL_201;
LABEL_192:
              if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
              {
                v145 = v145 & 0xFFFFFFFF00000000 | 0x2C2;
LABEL_194:
                rtc::webrtc_logging_impl::Log("\r\t\v\t\v\t", v77, v78, v79, v80, v81, v82, v83, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/experiments/field_trial_parser.cc");
              }
            }
            goto LABEL_201;
          }
LABEL_298:
          __break(1u);
        }
LABEL_299:
        abort();
      }
      if (!v53)
      {
        if ((v149 & 1) == 0)
          goto LABEL_188;
        goto LABEL_200;
      }
      if ((*v49 == 95) | v149 & 1)
        goto LABEL_201;
LABEL_188:
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
      {
        __dst = 0uLL;
        v154 = 0;
        v96 = v166;
        if (v166 != v152)
          goto LABEL_205;
LABEL_196:
        if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
        {
          v144 = v144 & 0xFFFFFFFF00000000 | 0x339;
          rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v97, v98, v99, v100, v101, v102, v103, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/experiments/field_trial_parser.cc");
        }
        if (SHIBYTE(v154) < 0)
          operator delete((void *)__dst);
LABEL_200:
        v149 = 1;
        goto LABEL_201;
      }
      v146 = v146 & 0xFFFFFFFF00000000 | 0x301;
      rtc::webrtc_logging_impl::Log("\r\t\v\t\v\t", v89, v90, v91, v92, v93, v94, v95, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/experiments/field_trial_parser.cc");
      __dst = 0uLL;
      v154 = 0;
      v96 = v166;
      if (v166 == v152)
        goto LABEL_196;
LABEL_205:
      while (2)
      {
        v105 = (char *)v96[4];
        v104 = (size_t)v96[5];
        if (v105)
          v106 = 1;
        else
          v106 = v104 == 0;
        if (!v106)
          goto LABEL_298;
        v108 = *((_QWORD *)&__dst + 1);
        v107 = v154;
        if (v154 >= 0)
          v109 = 22;
        else
          v109 = (v154 & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if (v154 >= 0)
          v110 = HIBYTE(v154);
        else
          v110 = *((_QWORD *)&__dst + 1);
        if (v109 - v110 < v104)
        {
          v108 = v110 + v104;
          if (0x7FFFFFFFFFFFFFF6 - v109 < v110 + v104 - v109)
            goto LABEL_299;
          if (v154 >= 0)
            v111 = &__dst;
          else
            v111 = (__int128 *)__dst;
          v112 = 0x7FFFFFFFFFFFFFF7;
          if (v109 >= 0x3FFFFFFFFFFFFFF3)
          {
LABEL_226:
            v114 = (__int128 *)operator new(v112);
            if (!v110)
              goto LABEL_230;
          }
          else
          {
            v113 = 2 * v109;
            if (v108 > 2 * v109)
              v113 = v110 + v104;
            if (v113 < 0x17)
            {
              v112 = 23;
              goto LABEL_226;
            }
            v120 = (v113 & 0xFFFFFFFFFFFFFFF8) + 8;
            v121 = v113 | 7;
            if (v121 == 23)
              v121 = v120;
            v112 = v121 + 1;
            v114 = (__int128 *)operator new(v121 + 1);
            if (!v110)
            {
LABEL_230:
              v115 = (char *)v114 + v110;
              if ((char *)v114 + v110 <= v105 && &v115[v104] > v105)
                goto LABEL_298;
              memcpy(v115, v105, v104);
              if (v109 != 22)
                operator delete(v111);
              v107 = v112 | 0x8000000000000000;
              *((_QWORD *)&__dst + 1) = v110 + v104;
              v154 = v112 | 0x8000000000000000;
              *(_QWORD *)&__dst = v114;
              *((_BYTE *)v114 + v108) = 0;
              v116 = (v112 | 0x8000000000000000) >> 56;
              goto LABEL_252;
            }
          }
          if (v111 >= v114 && (__int128 *)((char *)v114 + v110) > v111)
            goto LABEL_298;
          memmove(v114, v111, v110);
          goto LABEL_230;
        }
        if (v104)
        {
          if (v154 >= 0)
            v117 = &__dst;
          else
            v117 = (__int128 *)__dst;
          if ((char *)v117 + v110 <= v105 && (char *)v117 + v110 + v104 > v105)
            goto LABEL_298;
          memmove((char *)v117 + v110, v96[4], (size_t)v96[5]);
          v119 = v110 + v104;
          if (SHIBYTE(v154) < 0)
            *((_QWORD *)&__dst + 1) = v110 + v104;
          else
            HIBYTE(v154) = v119 & 0x7F;
          *((_BYTE *)v117 + v119) = 0;
          v116 = HIBYTE(v154);
          v108 = *((_QWORD *)&__dst + 1);
          v107 = v154;
        }
        else
        {
          v116 = HIBYTE(v154);
        }
LABEL_252:
        v122 = (v107 & 0x7FFFFFFFFFFFFFFFLL) - 1;
        if ((v116 & 0x80u) == 0)
          v123 = 22;
        else
          v123 = v122;
        if ((v116 & 0x80u) == 0)
          v124 = v116;
        else
          v124 = v108;
        if (v123 - v124 >= 2)
        {
          v134 = (__int128 *)__dst;
          if ((v116 & 0x80u) == 0)
            v134 = &__dst;
          v135 = (_WORD *)((char *)v134 + v124);
          if ((char *)v134 + v124 <= ", " && v135 + 1 > (_WORD *)", ")
            goto LABEL_298;
          *v135 = 8236;
          v136 = v124 + 2;
          if (SHIBYTE(v154) < 0)
          {
            *((_QWORD *)&__dst + 1) = v124 + 2;
            *((_BYTE *)v134 + v136) = 0;
            v133 = v96[1];
            if (!v133)
              goto LABEL_291;
          }
          else
          {
            HIBYTE(v154) = v136 & 0x7F;
            *((_BYTE *)v134 + v136) = 0;
            v133 = v96[1];
            if (!v133)
              goto LABEL_291;
          }
        }
        else
        {
          v125 = v124 + 2;
          if (0x7FFFFFFFFFFFFFF6 - v123 < v124 + 2 - v123)
            goto LABEL_299;
          if ((v116 & 0x80u) == 0)
            v126 = (char *)&__dst;
          else
            v126 = (char *)__dst;
          v127 = 0x7FFFFFFFFFFFFFF7;
          if (v123 < 0x3FFFFFFFFFFFFFF3)
          {
            v128 = 2 * v123;
            if (v125 > 2 * v123)
              v128 = v124 + 2;
            v129 = (v128 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v128 | 7) != 0x17)
              v129 = v128 | 7;
            if (v128 >= 0x17)
              v127 = v129 + 1;
            else
              v127 = 23;
          }
          v130 = (char *)operator new(v127);
          v131 = v130;
          if (v124)
          {
            if (v126 >= v130 && &v130[v124] > v126)
              goto LABEL_298;
            memmove(v130, v126, v124);
          }
          v132 = &v131[v124];
          if (&v131[v124] <= ", " && v132 + 2 > ", ")
            goto LABEL_298;
          *(_WORD *)v132 = 8236;
          if (v123 != 22)
            operator delete(v126);
          *((_QWORD *)&__dst + 1) = v124 + 2;
          v154 = v127 | 0x8000000000000000;
          *(_QWORD *)&__dst = v131;
          v131[v125] = 0;
          v133 = v96[1];
          if (!v133)
          {
            do
            {
LABEL_291:
              v137 = (uint64_t **)v96[2];
              v13 = *v137 == (uint64_t *)v96;
              v96 = v137;
            }
            while (!v13);
            goto LABEL_204;
          }
        }
        do
        {
          v137 = (uint64_t **)v133;
          v133 = (uint64_t *)*v133;
        }
        while (v133);
LABEL_204:
        v96 = v137;
        if (v137 == v152)
          goto LABEL_196;
        continue;
      }
    }
    if (v53 < v72)
      goto LABEL_165;
LABEL_156:
    v75 = v68[6];
    LOBYTE(__p[0]) = 0;
    v160 = 0;
    if ((v60 & 1) == 0)
    {
      *(_OWORD *)__p = v161;
      v159 = v162;
      v162 = 0;
      v161 = 0uLL;
      v160 = 1;
    }
    v76 = (*(uint64_t (**)(uint64_t *, void **))(*v75 + 16))(v75, __p);
    if (v160 && SHIBYTE(v159) < 0)
      operator delete(__p[0]);
    if ((v76 & 1) == 0 && (rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
    {
      v141 = v141 & 0xFFFFFFFF00000000 | 0x29A;
      goto LABEL_194;
    }
LABEL_201:
    if (v163 && SHIBYTE(v162) < 0)
      operator delete((void *)v161);
    if (v47)
      continue;
    break;
  }
LABEL_294:
  v138 = a1;
  if (a2)
  {
    v139 = 8 * a2;
    do
    {
      v140 = *v138++;
      (*(void (**)(uint64_t))(*(_QWORD *)v140 + 24))(v140);
      v139 -= 8;
    }
    while (v139);
  }
  std::__tree<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::__map_value_compare<webrtc::AudioSendStream *,std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>,std::less<webrtc::AudioSendStream *>,true>,std::allocator<std::__value_type<webrtc::AudioSendStream *,webrtc::internal::AudioState::StreamProperties>>>::destroy(v167);
}

uint64_t webrtc::FieldTrialFlag::Parse(uint64_t result, unsigned __int8 *a2)
{
  uint64_t v2;
  int v3;

  if (!a2[24])
  {
LABEL_14:
    *(_BYTE *)(result + 57) = 1;
    return 1;
  }
  if ((char)a2[23] < 0)
  {
    v2 = *((_QWORD *)a2 + 1);
    if (v2 < 0 || (a2 = *(unsigned __int8 **)a2, v2) && !a2)
    {
      __break(1u);
      return result;
    }
  }
  else
  {
    v2 = a2[23];
  }
  if (v2 == 1)
  {
    v3 = *a2;
    if (v3 != 48)
    {
      if (v3 != 49)
        return 0;
      goto LABEL_14;
    }
  }
  else
  {
    if (v2 != 5)
    {
      if (v2 != 4 || *(_DWORD *)a2 != 1702195828)
        return 0;
      goto LABEL_14;
    }
    if (*(_DWORD *)a2 != 1936482662 || a2[4] != 101)
      return 0;
  }
  *(_BYTE *)(result + 57) = 0;
  return 1;
}

uint64_t webrtc::AbstractFieldTrialEnum::AbstractFieldTrialEnum(uint64_t a1, char *__src, size_t __len, int a4, const void ***a5)
{
  char *v10;
  char *v11;
  size_t v12;
  size_t v13;
  uint64_t *v14;
  uint64_t **v15;
  const void ***v16;
  const void **v17;
  const void **v18;
  const void **v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  _QWORD *v25;
  size_t v26;
  size_t v27;
  const void *v28;
  size_t v29;
  int v30;
  const void **v31;
  const void **v32;
  char *v33;
  std::string *v34;
  __int128 v35;
  uint64_t v36;
  uint64_t *v37;
  const void ***v38;
  uint64_t **v39;
  uint64_t *v40;
  int v41;
  uint64_t **v42;
  uint64_t **v43;
  uint64_t *v44;
  int v45;
  _DWORD *v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t *v49;
  uint64_t *v50;
  uint64_t v52;

  *(_QWORD *)a1 = off_24C0B4170;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  if (__len >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_56;
  if (__len <= 0x16)
  {
    v10 = (char *)(a1 + 32);
    *(_BYTE *)(a1 + 55) = __len;
    v11 = (char *)(a1 + 32 + __len);
    if (a1 + 32 > (unint64_t)__src)
      goto LABEL_9;
    goto LABEL_8;
  }
  v12 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((__len | 7) != 0x17)
    v12 = __len | 7;
  v13 = v12 + 1;
  v10 = (char *)operator new(v12 + 1);
  *(_QWORD *)(a1 + 40) = __len;
  *(_QWORD *)(a1 + 48) = v13 | 0x8000000000000000;
  *(_QWORD *)(a1 + 32) = v10;
  v11 = &v10[__len];
  if (v10 <= __src)
  {
LABEL_8:
    if (v11 <= __src)
      goto LABEL_9;
LABEL_55:
    __break(1u);
LABEL_56:
    abort();
  }
LABEL_9:
  if (__len)
    memmove(v10, __src, __len);
  *v11 = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)a1 = off_24C0B41D0;
  *(_DWORD *)(a1 + 60) = a4;
  *(_QWORD *)(a1 + 72) = 0;
  v14 = (uint64_t *)(a1 + 72);
  *(_QWORD *)(a1 + 64) = a1 + 72;
  v15 = (uint64_t **)(a1 + 64);
  *(_QWORD *)(a1 + 80) = 0;
  v18 = *a5;
  v16 = a5 + 1;
  v17 = v18;
  if (v18 == (const void **)v16)
  {
    *(_QWORD *)(a1 + 96) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 88) = a1 + 96;
    return a1;
  }
  do
  {
    v19 = v17 + 4;
    v20 = *v14;
    v21 = a1 + 72;
    if (*v15 != v14)
    {
      v22 = *v14;
      v23 = a1 + 72;
      if (v20)
      {
        do
        {
          v21 = v22;
          v22 = *(_QWORD *)(v22 + 8);
        }
        while (v22);
      }
      else
      {
        do
        {
          v21 = *(_QWORD *)(v23 + 16);
          v24 = *(_QWORD *)v21 == v23;
          v23 = v21;
        }
        while (v24);
      }
      v25 = (_QWORD *)(v21 + 32);
      if (*(char *)(v21 + 55) < 0)
      {
        v26 = *(_QWORD *)(v21 + 40);
        if ((v26 & 0x8000000000000000) != 0)
          goto LABEL_55;
        v25 = (_QWORD *)*v25;
        if (v26)
        {
          if (!v25)
            goto LABEL_55;
        }
      }
      else
      {
        v26 = *(unsigned __int8 *)(v21 + 55);
      }
      if (*((char *)v17 + 55) < 0)
      {
        v27 = (size_t)v17[5];
        if ((v27 & 0x8000000000000000) != 0)
          goto LABEL_55;
        v28 = *v19;
        if (v27)
        {
          if (!v28)
            goto LABEL_55;
        }
      }
      else
      {
        v27 = *((unsigned __int8 *)v17 + 55);
        v28 = v17 + 4;
      }
      if (v27 >= v26)
        v29 = v26;
      else
        v29 = v27;
      v30 = memcmp(v25, v28, v29);
      if (v30)
      {
        if ((v30 & 0x80000000) == 0)
          goto LABEL_34;
      }
      else if (v26 >= v27)
      {
LABEL_34:
        v31 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(a1 + 64, &v52, v17 + 4);
        if (*v31)
          goto LABEL_39;
        goto LABEL_42;
      }
    }
    if (v20)
    {
      v52 = v21;
      v31 = (const void **)(v21 + 8);
      if (*(_QWORD *)(v21 + 8))
        goto LABEL_39;
    }
    else
    {
      v52 = a1 + 72;
      v31 = (const void **)(a1 + 72);
      if (*v14)
      {
LABEL_39:
        v32 = (const void **)v17[1];
        if (v32)
          goto LABEL_48;
        goto LABEL_50;
      }
    }
LABEL_42:
    v33 = (char *)operator new(0x40uLL);
    v34 = (std::string *)(v33 + 32);
    if (*((char *)v17 + 55) < 0)
    {
      std::string::__init_copy_ctor_external(v34, (const std::string::value_type *)v17[4], (std::string::size_type)v17[5]);
    }
    else
    {
      v35 = *(_OWORD *)v19;
      *((_QWORD *)v33 + 6) = v17[6];
      *(_OWORD *)&v34->__r_.__value_.__l.__data_ = v35;
    }
    *((_DWORD *)v33 + 14) = *((_DWORD *)v17 + 14);
    v36 = v52;
    *(_QWORD *)v33 = 0;
    *((_QWORD *)v33 + 1) = 0;
    *((_QWORD *)v33 + 2) = v36;
    *v31 = v33;
    v37 = (uint64_t *)**v15;
    if (v37)
    {
      *v15 = v37;
      v33 = (char *)*v31;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 72), (uint64_t *)v33);
    ++*(_QWORD *)(a1 + 80);
    v32 = (const void **)v17[1];
    if (v32)
    {
      do
      {
LABEL_48:
        v38 = (const void ***)v32;
        v32 = (const void **)*v32;
      }
      while (v32);
      goto LABEL_13;
    }
    do
    {
LABEL_50:
      v38 = (const void ***)v17[2];
      v24 = *v38 == v17;
      v17 = (const void **)v38;
    }
    while (!v24);
LABEL_13:
    v17 = (const void **)v38;
  }
  while (v38 != v16);
  *(_QWORD *)(a1 + 96) = 0;
  v39 = (uint64_t **)(a1 + 96);
  v40 = *(uint64_t **)(a1 + 64);
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 88) = a1 + 96;
  if (v40 != v14)
  {
    v41 = *((_DWORD *)v40 + 14);
    v42 = (uint64_t **)(a1 + 96);
    v43 = (uint64_t **)(a1 + 96);
LABEL_62:
    v46 = operator new(0x20uLL);
    v46[7] = v41;
    *(_QWORD *)v46 = 0;
    *((_QWORD *)v46 + 1) = 0;
    *((_QWORD *)v46 + 2) = v43;
    *v42 = (uint64_t *)v46;
    v47 = **(_QWORD **)(a1 + 88);
    if (v47)
    {
      *(_QWORD *)(a1 + 88) = v47;
      v48 = *v42;
    }
    else
    {
      v48 = (uint64_t *)v46;
    }
    std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 96), v48);
    ++*(_QWORD *)(a1 + 104);
    while (1)
    {
      v49 = (uint64_t *)v40[1];
      if (v49)
      {
        do
        {
          v50 = v49;
          v49 = (uint64_t *)*v49;
        }
        while (v49);
      }
      else
      {
        do
        {
          v50 = (uint64_t *)v40[2];
          v24 = *v50 == (_QWORD)v40;
          v40 = v50;
        }
        while (!v24);
      }
      if (v50 == v14)
        break;
      v44 = *v39;
      v40 = v50;
      v41 = *((_DWORD *)v50 + 14);
      v42 = (uint64_t **)(a1 + 96);
      v43 = (uint64_t **)(a1 + 96);
      if (!*v39)
        goto LABEL_62;
      while (1)
      {
        while (1)
        {
          v43 = (uint64_t **)v44;
          v45 = *((_DWORD *)v44 + 7);
          if (v41 >= v45)
            break;
          v44 = *v43;
          v42 = v43;
          if (!*v43)
            goto LABEL_62;
        }
        if (v45 >= v41)
          break;
        v44 = v43[1];
        if (!v44)
        {
          v42 = v43 + 1;
          goto LABEL_62;
        }
      }
    }
  }
  return a1;
}

void webrtc::AbstractFieldTrialEnum::~AbstractFieldTrialEnum(webrtc::AbstractFieldTrialEnum *this)
{
  void *v2;

  *(_QWORD *)this = off_24C0B41D0;
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 88, *((_QWORD **)this + 12));
  std::__tree<rtc::SocketAddress>::destroy((uint64_t)this + 64, *((char **)this + 9));
  *(_QWORD *)this = off_24C0B4170;
  if (*((char *)this + 55) < 0)
  {
    operator delete(*((void **)this + 4));
    v2 = (void *)*((_QWORD *)this + 1);
    if (!v2)
      return;
  }
  else
  {
    v2 = (void *)*((_QWORD *)this + 1);
    if (!v2)
      return;
  }
  *((_QWORD *)this + 2) = v2;
  operator delete(v2);
}

{
  void *v2;

  *(_QWORD *)this = off_24C0B41D0;
  std::__tree<sigslot::_signal_base_interface *>::destroy((uint64_t)this + 88, *((_QWORD **)this + 12));
  std::__tree<rtc::SocketAddress>::destroy((uint64_t)this + 64, *((char **)this + 9));
  *(_QWORD *)this = off_24C0B4170;
  if (*((char *)this + 55) < 0)
  {
    operator delete(*((void **)this + 4));
    v2 = (void *)*((_QWORD *)this + 1);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = (void *)*((_QWORD *)this + 1);
    if (!v2)
      goto LABEL_6;
  }
  *((_QWORD *)this + 2) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t *webrtc::AbstractFieldTrialEnum::Parse(uint64_t *result, _BYTE *__src)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  int v6;
  size_t v7;
  uint64_t *v8;
  size_t v9;
  BOOL v10;
  int v11;
  uint64_t *v12;
  size_t v13;
  size_t v15;
  size_t v16;
  size_t v18;
  _QWORD *v19;
  size_t v20;
  size_t v21;
  unint64_t v22;
  size_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  BOOL v27;
  uint64_t *v28;
  char v29;

  if (!__src[24])
    return 0;
  v2 = (uint64_t *)__src;
  v3 = (uint64_t)result;
  v5 = result + 9;
  v4 = (uint64_t *)result[9];
  v6 = (char)__src[23];
  if (!v4)
    goto LABEL_63;
  v7 = __src[23];
  v8 = *(uint64_t **)__src;
  v9 = *((_QWORD *)__src + 1);
  if (v9)
    v10 = v8 == 0;
  else
    v10 = 0;
  v11 = !v10;
  v29 = v11;
  if ((v6 & 0x80000000) == 0)
  {
    v12 = result + 9;
    while (1)
    {
      result = v4 + 4;
      if (*((char *)v4 + 55) < 0)
      {
        v13 = v4[5];
        if ((v13 & 0x8000000000000000) != 0)
          goto LABEL_84;
        result = (uint64_t *)*result;
        if (v13 && result == 0)
          goto LABEL_84;
      }
      else
      {
        v13 = *((unsigned __int8 *)v4 + 55);
      }
      if (v7 >= v13)
        v15 = v13;
      else
        v15 = v6;
      result = (uint64_t *)memcmp(result, v2, v15);
      if ((_DWORD)result)
      {
        if ((result & 0x80000000) != 0)
          goto LABEL_11;
LABEL_26:
        v12 = v4;
        v4 = (uint64_t *)*v4;
        if (!v4)
          goto LABEL_47;
      }
      else
      {
        if (v13 >= v7)
          goto LABEL_26;
LABEL_11:
        v4 = (uint64_t *)v4[1];
        if (!v4)
          goto LABEL_47;
      }
    }
  }
  if ((v9 & 0x8000000000000000) != 0)
  {
    if (*((char *)v4 + 55) < 0 && (v4[5] & 0x8000000000000000) == 0)
      __break(1u);
    goto LABEL_84;
  }
  if (!v11)
  {
LABEL_84:
    __break(1u);
    return result;
  }
  v12 = result + 9;
  do
  {
    while (1)
    {
      result = v4 + 4;
      if (*((char *)v4 + 55) < 0)
      {
        v16 = v4[5];
        if ((v16 & 0x8000000000000000) != 0)
          goto LABEL_84;
        result = (uint64_t *)*result;
        if (v16 && result == 0)
          goto LABEL_84;
      }
      else
      {
        v16 = *((unsigned __int8 *)v4 + 55);
      }
      v18 = v9 >= v16 ? v16 : v9;
      result = (uint64_t *)memcmp(result, v8, v18);
      if ((_DWORD)result)
        break;
      if (v16 >= v9)
        goto LABEL_46;
LABEL_31:
      v4 = (uint64_t *)v4[1];
      if (!v4)
        goto LABEL_47;
    }
    if ((result & 0x80000000) != 0)
      goto LABEL_31;
LABEL_46:
    v12 = v4;
    v4 = (uint64_t *)*v4;
  }
  while (v4);
LABEL_47:
  if (v5 == v12)
    goto LABEL_63;
  result = v2;
  if (v6 < 0)
  {
    if ((v9 & 0x8000000000000000) != 0)
      goto LABEL_84;
    result = v8;
    v7 = v9;
    if ((v29 & 1) == 0)
      goto LABEL_84;
  }
  v19 = v12 + 4;
  if (*((char *)v12 + 55) < 0)
  {
    v20 = v12[5];
    if ((v20 & 0x8000000000000000) == 0)
    {
      v19 = (_QWORD *)*v19;
      if (!v20 || v19)
        goto LABEL_56;
    }
    goto LABEL_84;
  }
  v20 = *((unsigned __int8 *)v12 + 55);
LABEL_56:
  if (v20 >= v7)
    v21 = v7;
  else
    v21 = v20;
  result = (uint64_t *)memcmp(result, v19, v21);
  if (!(_DWORD)result)
  {
    if (v7 < v20)
      goto LABEL_63;
LABEL_61:
    LODWORD(v22) = *((_DWORD *)v12 + 14);
    goto LABEL_80;
  }
  if ((result & 0x80000000) == 0)
    goto LABEL_61;
LABEL_63:
  if (v6 < 0)
  {
    v23 = v2[1];
    if ((v23 & 0x8000000000000000) == 0)
    {
      v2 = (uint64_t *)*v2;
      if (!v23 || v2)
        goto LABEL_68;
    }
    goto LABEL_84;
  }
  v23 = v6;
LABEL_68:
  v22 = webrtc::ParseTypedParameter<int>((char *)v2, v23);
  if (!HIDWORD(v22))
    return 0;
  v24 = *(_QWORD *)(v3 + 96);
  if (!v24)
    return 0;
  v25 = v3 + 96;
  do
  {
    v26 = *(_DWORD *)(v24 + 28);
    v27 = v26 < (int)v22;
    if (v26 >= (int)v22)
      v28 = (uint64_t *)v24;
    else
      v28 = (uint64_t *)(v24 + 8);
    if (!v27)
      v25 = v24;
    v24 = *v28;
  }
  while (*v28);
  if (v25 == v3 + 96 || *(_DWORD *)(v25 + 28) > (int)v22)
    return 0;
LABEL_80:
  *(_DWORD *)(v3 + 60) = v22;
  return (uint64_t *)1;
}

void webrtc::FieldTrialFlag::~FieldTrialFlag(void **this)
{
  void *v2;

  *this = off_24C0B4170;
  if (*((char *)this + 55) < 0)
  {
    operator delete(this[4]);
    v2 = this[1];
    if (!v2)
      return;
  }
  else
  {
    v2 = this[1];
    if (!v2)
      return;
  }
  this[2] = v2;
  operator delete(v2);
}

{
  void *v2;

  *this = off_24C0B4170;
  if (*((char *)this + 55) < 0)
  {
    operator delete(this[4]);
    v2 = this[1];
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = this[1];
    if (!v2)
      goto LABEL_6;
  }
  this[2] = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialParameter<BOOL>::~FieldTrialParameter(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
LABEL_3:
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void webrtc::FieldTrialParameter<BOOL>::~FieldTrialParameter(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 16) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialParameter<double>::~FieldTrialParameter(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
LABEL_3:
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void webrtc::FieldTrialParameter<double>::~FieldTrialParameter(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 16) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialParameter<int>::~FieldTrialParameter(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
LABEL_3:
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void webrtc::FieldTrialParameter<int>::~FieldTrialParameter(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 16) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialParameter<unsigned int>::~FieldTrialParameter(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
LABEL_3:
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void webrtc::FieldTrialParameter<unsigned int>::~FieldTrialParameter(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 16) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialConstrained<double>::~FieldTrialConstrained(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
LABEL_3:
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void webrtc::FieldTrialConstrained<double>::~FieldTrialConstrained(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 16) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialConstrained<int>::~FieldTrialConstrained(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
LABEL_3:
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void webrtc::FieldTrialConstrained<int>::~FieldTrialConstrained(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 16) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialOptional<double>::~FieldTrialOptional(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
LABEL_3:
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void webrtc::FieldTrialOptional<double>::~FieldTrialOptional(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 16) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialOptional<int>::~FieldTrialOptional(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
LABEL_3:
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void webrtc::FieldTrialOptional<int>::~FieldTrialOptional(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 16) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialOptional<unsigned int>::~FieldTrialOptional(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
LABEL_3:
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void webrtc::FieldTrialOptional<unsigned int>::~FieldTrialOptional(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 16) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t *std::set<int>::insert[abi:sn180100]<std::__tree_const_iterator<int,std::__tree_node<int,void *> *,long>>(uint64_t *result, int *a2, int *a3)
{
  uint64_t *v3;
  uint64_t *v4;
  int *v6;
  uint64_t *v7;
  uint64_t *v8;
  int *v9;
  uint64_t *v10;
  _DWORD *v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t *v14;
  int *v15;
  BOOL v16;
  uint64_t *v17;
  uint64_t *v18[9];

  if (a2 != a3)
  {
    v18[7] = v3;
    v18[8] = v4;
    v6 = a2;
    v7 = result;
    v8 = result + 1;
    do
    {
      result = std::__tree<int>::__find_equal<int>(v7, v8, v18, &v17, v6 + 7);
      if (*result)
      {
        v9 = (int *)*((_QWORD *)v6 + 1);
        if (v9)
          goto LABEL_11;
      }
      else
      {
        v10 = result;
        v11 = operator new(0x20uLL);
        v11[7] = v6[7];
        v12 = v18[0];
        *(_QWORD *)v11 = 0;
        *((_QWORD *)v11 + 1) = 0;
        *((_QWORD *)v11 + 2) = v12;
        *v10 = (uint64_t)v11;
        v13 = *(_QWORD **)*v7;
        if (v13)
        {
          *v7 = (uint64_t)v13;
          v14 = (uint64_t *)*v10;
        }
        else
        {
          v14 = (uint64_t *)v11;
        }
        result = std::__tree_balance_after_insert[abi:sn180100]<std::__tree_node_base<void *> *>((uint64_t *)v7[1], v14);
        ++v7[2];
        v9 = (int *)*((_QWORD *)v6 + 1);
        if (v9)
        {
          do
          {
LABEL_11:
            v15 = v9;
            v9 = *(int **)v9;
          }
          while (v9);
          goto LABEL_3;
        }
      }
      do
      {
        v15 = (int *)*((_QWORD *)v6 + 2);
        v16 = *(_QWORD *)v15 == (_QWORD)v6;
        v6 = v15;
      }
      while (!v16);
LABEL_3:
      v6 = v15;
    }
    while (v15 != a3);
  }
  return result;
}

uint64_t *std::__tree<int>::__find_equal<int>(_QWORD *a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, int *a5)
{
  uint64_t *v5;
  int v6;
  int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  BOOL v15;
  int v16;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *v23;
  int v24;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = *((_DWORD *)a2 + 7), *a5 < v7))
  {
    v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (uint64_t *)*a2;
      do
      {
        v10 = v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      v14 = a2;
      do
      {
        v10 = (uint64_t *)v14[2];
        v15 = *v10 == (_QWORD)v14;
        v14 = v10;
      }
      while (v15);
    }
    v16 = *a5;
    if (*((_DWORD *)v10 + 7) < *a5)
      goto LABEL_17;
    v18 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v19 = (uint64_t *)v18;
          v20 = *(_DWORD *)(v18 + 28);
          if (v16 >= v20)
            break;
          v18 = *v19;
          v5 = v19;
          if (!*v19)
            goto LABEL_25;
        }
        if (v20 >= v16)
          break;
        v5 = v19 + 1;
        v18 = v19[1];
      }
      while (v18);
LABEL_25:
      *a3 = v19;
      return v5;
    }
    else
    {
      *a3 = v5;
      return a1 + 1;
    }
  }
  else if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return (uint64_t *)a4;
  }
  else
  {
    v11 = a2[1];
    if (v11)
    {
      v12 = (uint64_t *)a2[1];
      do
      {
        v13 = v12;
        v12 = (uint64_t *)*v12;
      }
      while (v12);
    }
    else
    {
      v21 = a2;
      do
      {
        v13 = (uint64_t *)v21[2];
        v15 = *v13 == (_QWORD)v21;
        v21 = v13;
      }
      while (!v15);
    }
    if (v13 == v5 || v6 < *((_DWORD *)v13 + 7))
    {
      if (v11)
      {
        *a3 = v13;
        return v13;
      }
      else
      {
        *a3 = a2;
        return a2 + 1;
      }
    }
    else
    {
      v22 = *v5;
      if (*v5)
      {
        do
        {
          while (1)
          {
            v23 = (uint64_t *)v22;
            v24 = *(_DWORD *)(v22 + 28);
            if (v6 >= v24)
              break;
            v22 = *v23;
            v5 = v23;
            if (!*v23)
              goto LABEL_41;
          }
          if (v24 >= v6)
            break;
          v5 = v23 + 1;
          v22 = v23[1];
        }
        while (v22);
LABEL_41:
        *a3 = v23;
        return v5;
      }
      else
      {
        *a3 = v5;
        return a1 + 1;
      }
    }
  }
}

void webrtc::ParseTypedParameter<webrtc::DataRate>(void **__src, size_t __len)
{
  unsigned __int16 *p_p;
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  BOOL v8;
  double v9;
  double v10;
  void *__p;
  uint64_t v12;
  unsigned __int8 v13;
  char v14;

  if (!v14)
    return;
  p_p = (unsigned __int16 *)&__p;
  if ((char)v13 < 0)
  {
    v4 = v12;
    if (!v12)
      goto LABEL_22;
    if (v12 < 0 || (v3 = __p) == 0)
    {
LABEL_32:
      __break(1u);
      return;
    }
  }
  else
  {
    v3 = &__p;
    v4 = v13;
    if (!v13)
      goto LABEL_22;
  }
  if (v4 != 4 || *v3 != 1936745067)
  {
    v5 = v13;
    if ((v13 & 0x80) == 0
      || (v5 = v12, (v12 & 0x8000000000000000) == 0) && ((p_p = (unsigned __int16 *)__p, !v12) || __p))
    {
      if (v5 != 3 || ((v6 = *p_p, v7 = *((unsigned __int8 *)p_p + 2), v6 == 28770) ? (v8 = v7 == 115) : (v8 = 0), !v8))
      {
        if ((v13 & 0x80) == 0)
          return;
        goto LABEL_28;
      }
      v9 = v10;
      if (v10 == INFINITY)
      {
LABEL_23:
        if ((v13 & 0x80) == 0)
          return;
        goto LABEL_28;
      }
      goto LABEL_26;
    }
    goto LABEL_32;
  }
LABEL_22:
  v9 = v10 * 1000.0;
  if (v10 * 1000.0 == INFINITY)
    goto LABEL_23;
LABEL_26:
  if (v9 == -INFINITY)
  {
    if ((v13 & 0x80) == 0)
      return;
    goto LABEL_28;
  }
  if ((v13 & 0x80) != 0)
LABEL_28:
    operator delete(__p);
}

void webrtc::ParseTypedParameter<webrtc::DataSize>(void **__src, size_t __len)
{
  unsigned __int8 *p_p;
  uint64_t v3;
  int v4;
  int v5;
  BOOL v6;
  double v7;
  void *__p;
  uint64_t v9;
  unsigned __int8 v10;
  char v11;

  if (!v11)
    return;
  if ((char)v10 < 0)
  {
    v3 = v9;
    if (!v9)
      goto LABEL_17;
    if (v9 < 0 || (p_p = (unsigned __int8 *)__p) == 0)
    {
      __break(1u);
      return;
    }
  }
  else
  {
    if (!v10)
      goto LABEL_17;
    p_p = (unsigned __int8 *)&__p;
    v3 = v10;
  }
  if (v3 != 5 || ((v4 = *(_DWORD *)p_p, v5 = p_p[4], v4 == 1702132066) ? (v6 = v5 == 115) : (v6 = 0), !v6))
  {
    if ((v10 & 0x80) == 0)
      return;
    goto LABEL_15;
  }
LABEL_17:
  if (v7 == INFINITY)
  {
    if ((v10 & 0x80) != 0)
LABEL_15:
      operator delete(__p);
  }
  else if (v7 == -INFINITY)
  {
    if ((v10 & 0x80) != 0)
      goto LABEL_15;
  }
  else if ((v10 & 0x80) != 0)
  {
    goto LABEL_15;
  }
}

void webrtc::ParseTypedParameter<webrtc::TimeDelta>(void **__src, size_t __len)
{
  _WORD *p_p;
  _BYTE *v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  int v7;
  int v8;
  _WORD *v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  double v14;
  void *__p;
  uint64_t v16;
  unsigned __int8 v17;
  char v18;

  if (!v18)
    return;
  p_p = &__p;
  v3 = &__p;
  v4 = v17;
  if ((char)v17 < 0)
  {
    v4 = v16;
    if (v16 < 0)
      goto LABEL_46;
    v3 = __p;
    if (v16)
    {
      if (!__p)
        goto LABEL_46;
    }
  }
  if (v4 == 1 && *v3 == 115)
    goto LABEL_27;
  v5 = (int *)&__p;
  v6 = v17;
  if ((v17 & 0x80) != 0)
  {
    v6 = v16;
    if (v16 < 0)
      goto LABEL_46;
    v5 = (int *)__p;
    if (v16)
    {
      if (!__p)
        goto LABEL_46;
    }
  }
  if (v6 == 7)
  {
    v7 = *v5;
    v8 = *(int *)((char *)v5 + 3);
    if (v7 == 1868785011 && v8 == 1935961711)
    {
LABEL_27:
      v13 = v14 * 1000000.0;
      if (v14 * 1000000.0 != INFINITY)
        goto LABEL_38;
      goto LABEL_28;
    }
  }
  v10 = &__p;
  v11 = v17;
  if ((v17 & 0x80) != 0)
  {
    v11 = v16;
    if (v16 < 0 || (v10 = __p, v16) && !__p)
    {
LABEL_46:
      __break(1u);
      return;
    }
  }
  if (v11 != 2 || *v10 != 29557)
  {
    if ((v17 & 0x80) == 0)
    {
      v12 = v17;
      if (!v17)
        goto LABEL_37;
      goto LABEL_33;
    }
    v12 = v16;
    if (!v16)
      goto LABEL_37;
    if ((v16 & 0x8000000000000000) == 0)
    {
      p_p = __p;
      if (__p)
      {
LABEL_33:
        if (v12 != 2 || *p_p != 29549)
        {
          if ((v17 & 0x80) == 0)
            return;
          goto LABEL_40;
        }
LABEL_37:
        v13 = v14 * 1000.0;
        if (v14 * 1000.0 != INFINITY)
          goto LABEL_38;
LABEL_28:
        if ((v17 & 0x80) == 0)
          return;
        goto LABEL_40;
      }
    }
    goto LABEL_46;
  }
  v13 = v14;
  if (v14 == INFINITY)
    goto LABEL_28;
LABEL_38:
  if (v13 == -INFINITY)
  {
    if ((v17 & 0x80) == 0)
      return;
    goto LABEL_40;
  }
  if ((v17 & 0x80) != 0)
LABEL_40:
    operator delete(__p);
}

uint64_t webrtc::FieldTrialOptional<webrtc::DataRate>::Parse(uint64_t result, _BYTE *__src)
{
  uint64_t v2;
  size_t v3;
  uint64_t v4;
  char v5;

  v2 = result;
  if (!__src[24])
  {
    if (*(_BYTE *)(result + 72))
    {
      *(_BYTE *)(result + 72) = 0;
      return 1;
    }
    return 1;
  }
  if ((char)__src[23] < 0)
  {
    v3 = *((_QWORD *)__src + 1);
    if ((v3 & 0x8000000000000000) != 0 || (__src = *(_BYTE **)__src, v3) && !__src)
    {
      __break(1u);
      return result;
    }
  }
  else
  {
    v3 = __src[23];
  }
  webrtc::ParseTypedParameter<webrtc::DataRate>((void **)__src, v3);
  if (v5)
  {
    if (!*(_BYTE *)(v2 + 72))
      *(_BYTE *)(v2 + 72) = 1;
    *(_QWORD *)(v2 + 64) = v4;
    return 1;
  }
  return 0;
}

uint64_t webrtc::FieldTrialOptional<webrtc::TimeDelta>::Parse(uint64_t result, _BYTE *__src)
{
  uint64_t v2;
  size_t v3;
  uint64_t v4;
  char v5;

  v2 = result;
  if (!__src[24])
  {
    if (*(_BYTE *)(result + 72))
    {
      *(_BYTE *)(result + 72) = 0;
      return 1;
    }
    return 1;
  }
  if ((char)__src[23] < 0)
  {
    v3 = *((_QWORD *)__src + 1);
    if ((v3 & 0x8000000000000000) != 0 || (__src = *(_BYTE **)__src, v3) && !__src)
    {
      __break(1u);
      return result;
    }
  }
  else
  {
    v3 = __src[23];
  }
  webrtc::ParseTypedParameter<webrtc::TimeDelta>((void **)__src, v3);
  if (v5)
  {
    if (!*(_BYTE *)(v2 + 72))
      *(_BYTE *)(v2 + 72) = 1;
    *(_QWORD *)(v2 + 64) = v4;
    return 1;
  }
  return 0;
}

void webrtc::`anonymous namespace'::ParseValueWithUnit(uint64_t a1, void **__src, size_t __len)
{
  unint64_t v7;
  void **p_p;
  void **v9;
  size_t v10;
  size_t v11;
  const char *v12;
  int v13;
  int v14;
  size_t v15;
  size_t v16;
  __int128 *v17;
  _BYTE *v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  void *__p;
  __int128 v23;
  unint64_t v24;
  void *v25;
  char __s;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  if (__len == 4)
  {
    if (*(_DWORD *)__src != 1718511917)
      goto LABEL_10;
    v7 = 0xFFF0000000000000;
    goto LABEL_42;
  }
  if (__len == 3)
  {
    if (*(_WORD *)__src != 28265 || *((_BYTE *)__src + 2) != 102)
    {
LABEL_10:
      v25 = 0;
      __s = 0;
      HIBYTE(v23) = __len;
      p_p = &__p;
      v9 = (void **)((char *)&__p + __len);
      if (&__p > __src)
        goto LABEL_20;
      goto LABEL_19;
    }
    v7 = 0x7FF0000000000000;
LABEL_42:
    *(_QWORD *)a1 = v7;
    *(_QWORD *)(a1 + 8) = 0;
    *(_WORD *)(a1 + 31) = 256;
    return;
  }
  v25 = 0;
  __s = 0;
  if (__len > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_44;
  if (__len > 0x16)
  {
    v10 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v10 = __len | 7;
    v11 = v10 + 1;
    p_p = (void **)operator new(v10 + 1);
    *(_QWORD *)&v23 = __len;
    *((_QWORD *)&v23 + 1) = v11 | 0x8000000000000000;
    __p = p_p;
    v9 = (void **)((char *)p_p + __len);
    if (p_p > __src)
      goto LABEL_20;
  }
  else
  {
    HIBYTE(v23) = __len;
    p_p = &__p;
    v9 = (void **)((char *)&__p + __len);
    if (&__p > __src)
      goto LABEL_20;
  }
LABEL_19:
  if (v9 > __src)
    goto LABEL_43;
LABEL_20:
  if (__len)
    memmove(p_p, __src, __len);
  *(_BYTE *)v9 = 0;
  if (v23 >= 0)
    v12 = (const char *)&__p;
  else
    v12 = (const char *)__p;
  v13 = sscanf(v12, "%lf%7s", &v25, &__s);
  v14 = v13;
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (v13 >= 1)
      goto LABEL_27;
LABEL_32:
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 32) = 0;
    return;
  }
  operator delete(__p);
  if (v14 < 1)
    goto LABEL_32;
LABEL_27:
  __p = v25;
  v15 = strlen(&__s);
  if (v15 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_44;
  v16 = v15;
  if (v15 > 0x16)
  {
    v20 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v20 = v15 | 7;
    v21 = v20 + 1;
    v17 = (__int128 *)operator new(v20 + 1);
    *((_QWORD *)&v23 + 1) = v16;
    v24 = v21 | 0x8000000000000000;
    *(_QWORD *)&v23 = v17;
    v18 = (char *)v17 + v16;
    v19 = (char *)v17 + v16 > &__s;
    if (v17 > (__int128 *)&__s)
      goto LABEL_37;
  }
  else
  {
    HIBYTE(v24) = v15;
    v17 = &v23;
    v18 = (char *)&v23 + v16;
    v19 = (char *)&v23 + v16 > &__s;
    if (&v23 > (__int128 *)&__s)
      goto LABEL_37;
  }
  if (v19)
  {
LABEL_43:
    __break(1u);
LABEL_44:
    abort();
  }
LABEL_37:
  if (v16)
    memcpy(v17, &__s, v16);
  *v18 = 0;
  *(_QWORD *)a1 = __p;
  *(_OWORD *)(a1 + 8) = v23;
  *(_QWORD *)(a1 + 24) = v24;
  *(_BYTE *)(a1 + 32) = 1;
}

uint64_t webrtc::FieldTrialOptional<webrtc::DataRate>::~FieldTrialOptional(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
LABEL_3:
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void webrtc::FieldTrialOptional<webrtc::DataRate>::~FieldTrialOptional(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 16) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialOptional<webrtc::TimeDelta>::~FieldTrialOptional(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      return a1;
    goto LABEL_3;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
LABEL_3:
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void webrtc::FieldTrialOptional<webrtc::TimeDelta>::~FieldTrialOptional(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_24C0B4170;
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  else
  {
    v2 = *(void **)(a1 + 8);
    if (!v2)
      goto LABEL_6;
  }
  *(_QWORD *)(a1 + 16) = v2;
  operator delete(v2);
LABEL_6:
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::FieldTrialsRegistry::Lookup(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
}

FILE *webrtc::`anonymous namespace'::FileOpen(void **a1, size_t __n, int a3, int *a4)
{
  _BYTE *v8;
  void **v9;
  void **v10;
  size_t v11;
  size_t v12;
  void **v13;
  const char *v14;
  FILE *v15;
  FILE *v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *__p[2];
  int64_t v24;

  if (!__n)
  {
    HIBYTE(v24) = 0;
    v10 = __p;
    goto LABEL_14;
  }
  v8 = memchr(a1, 0, __n);
  if (v8 && v8 - (_BYTE *)a1 != -1)
    goto LABEL_27;
  if (__n >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_28;
  if (__n >= 0x17)
  {
    v11 = (__n & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__n | 7) != 0x17)
      v11 = __n | 7;
    v12 = v11 + 1;
    v9 = (void **)operator new(v11 + 1);
    __p[1] = (void *)__n;
    v24 = v12 | 0x8000000000000000;
    __p[0] = v9;
    v10 = (void **)((char *)v9 + __n);
    if (v9 > a1)
      goto LABEL_13;
  }
  else
  {
    HIBYTE(v24) = __n;
    v9 = __p;
    v10 = (void **)((char *)__p + __n);
    if (__p > a1)
      goto LABEL_13;
  }
  if (v10 > a1)
  {
    __break(1u);
LABEL_27:
    v18 = std::string_view::find_first_of[abi:sn180100](a1, __n);
    rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/system/file_wrapper.cc", 34, "file_name_utf8.find_first_of('\\0') == absl::string_view::npos", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)9,char const*> const&)::t, v19, v20, v21, v22, v18);
LABEL_28:
    abort();
  }
LABEL_13:
  memmove(v9, a1, __n);
LABEL_14:
  *(_BYTE *)v10 = 0;
  if (v24 >= 0)
    v13 = __p;
  else
    v13 = (void **)__p[0];
  if (a3)
    v14 = "rb";
  else
    v14 = "wb";
  v15 = fopen((const char *)v13, v14);
  v16 = v15;
  if (a4 && !v15)
    *a4 = *__error();
  if (SHIBYTE(v24) < 0)
    operator delete(__p[0]);
  return v16;
}

uint64_t std::string_view::find_first_of[abi:sn180100](void *a1, size_t __n)
{
  _BYTE *v3;

  if (!__n)
    return -1;
  v3 = memchr(a1, 0, __n);
  if (v3)
    return v3 - (_BYTE *)a1;
  else
    return -1;
}

webrtc::FilterAnalyzer *webrtc::FilterAnalyzer::FilterAnalyzer(webrtc::FilterAnalyzer *this, const webrtc::EchoCanceller3Config *a2, unint64_t a3)
{
  uint64_t v6;
  unsigned int v7;
  int v8;
  size_t v9;
  char *v10;
  char *v11;
  char **v12;
  char **v13;
  int64_t v14;
  uint64_t v15;
  char **v16;
  char *v17;
  char *v18;
  _QWORD *v19;
  int v20;
  float v21;
  int v22;
  float v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  int v30;
  char *v31;
  __int128 v33;

  v6 = operator new();
  do
    v7 = __ldaxr(&webrtc::FilterAnalyzer::instance_count_);
  while (__stlxr(v7 + 1, &webrtc::FilterAnalyzer::instance_count_));
  *(_QWORD *)this = v6;
  *((_BYTE *)this + 8) = *((_BYTE *)a2 + 285);
  *((_DWORD *)this + 3) = *((_DWORD *)a2 + 68);
  v8 = *((_DWORD *)a2 + 30) << 6;
  if (v8)
  {
    if (v8 < 0)
      goto LABEL_28;
    v9 = 4 * v8;
    v10 = (char *)operator new(v9);
    bzero(v10, v9);
    v11 = &v10[v9];
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 4) = 0;
    if (!a3)
      goto LABEL_16;
  }
  else
  {
    v11 = 0;
    v10 = 0;
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 4) = 0;
    if (!a3)
      goto LABEL_16;
  }
  if (a3 >= 0xAAAAAAAAAAAAAABLL)
    goto LABEL_28;
  v12 = (char **)operator new(24 * a3);
  *((_QWORD *)this + 2) = v12;
  *((_QWORD *)this + 3) = v12;
  v13 = &v12[3 * a3];
  *((_QWORD *)this + 4) = v13;
  v14 = v11 - v10;
  if (v14)
  {
    if (v14 < 0)
    {
      *v12 = 0;
      v12[1] = 0;
      v12[2] = 0;
      abort();
    }
    v15 = 24 * a3;
    v16 = v12 + 1;
    do
    {
      *v16 = 0;
      v16[1] = 0;
      v17 = (char *)operator new(v14);
      *(v16 - 1) = v17;
      v18 = &v17[4 * (v14 >> 2)];
      v16[1] = v18;
      memcpy(v17, v10, v14);
      *v16 = v18;
      v16 += 3;
      v15 -= 24;
    }
    while (v15);
  }
  else
  {
    bzero(v12, 24 * ((24 * a3 - 24) / 0x18) + 24);
  }
  *((_QWORD *)this + 3) = v13;
LABEL_16:
  if (v10)
    operator delete(v10);
  *((_QWORD *)this + 5) = 0;
  v19 = (_QWORD *)((char *)this + 40);
  v20 = *((_DWORD *)a2 + 42);
  v21 = *((float *)a2 + 79);
  v22 = *((_DWORD *)a2 + 68);
  *(_QWORD *)((char *)&v33 + 4) = 0;
  HIDWORD(v33) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 8) = 0;
  if (!a3)
  {
    *v19 = 0;
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 7) = 0;
    *((_QWORD *)this + 12) = 0;
    *((_QWORD *)this + 13) = 0;
    *((_QWORD *)this + 11) = 0;
    *((_DWORD *)this + 28) = 0;
    return this;
  }
  if (a3 >= 0x333333333333334)
LABEL_28:
    abort();
  v23 = (float)(v21 * v21) * 64.0;
  v24 = (char *)operator new(80 * a3);
  *((_QWORD *)this + 8) = v24;
  v25 = &v24[80 * a3];
  *((_QWORD *)this + 10) = v25;
  v26 = v24;
  do
  {
    *(_DWORD *)v26 = v22;
    *((_QWORD *)v26 + 1) = 0;
    *((_DWORD *)v26 + 4) = v20;
    v26[20] = 0;
    v26[24] = 0;
    *((_DWORD *)v26 + 7) = 0;
    *((_DWORD *)v26 + 8) = 0;
    *(_OWORD *)(v26 + 36) = v33;
    *((_DWORD *)v26 + 13) = 0;
    *((float *)v26 + 14) = v23;
    *((_QWORD *)v26 + 8) = 0;
    *((_DWORD *)v26 + 18) = -10;
    v26 += 80;
  }
  while (v26 != v25);
  *((_QWORD *)this + 9) = v25;
  v27 = (char *)operator new(4 * a3);
  *((_QWORD *)this + 11) = v27;
  v28 = &v27[4 * a3];
  *((_QWORD *)this + 13) = v28;
  bzero(v27, 4 * a3);
  v29 = 0;
  *((_QWORD *)this + 12) = v28;
  *((_DWORD *)this + 28) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *v19 = 0;
  v30 = *((_DWORD *)this + 3);
  do
  {
    v31 = &v24[v29];
    *((_QWORD *)v31 + 1) = 0;
    *(_DWORD *)v31 = v30;
    v31[24] = 0;
    *((_DWORD *)v31 + 7) = 0;
    *((_DWORD *)v31 + 8) = 0;
    *((_QWORD *)v31 + 8) = 0;
    *((_QWORD *)v31 + 5) = 0;
    *((_QWORD *)v31 + 6) = 0;
    v29 += 80;
    *((_DWORD *)v31 + 18) = -10;
  }
  while (80 * a3 != v29);
  if ((uint64_t)(4 * a3) >= 1)
    bzero(v27, 4 * (((4 * a3) >> 2) - (4 * a3 > 3)) + 4);
  return this;
}

void webrtc::FilterAnalyzer::~FilterAnalyzer(webrtc::FilterAnalyzer *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;

  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
  {
    *((_QWORD *)this + 12) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 8);
  if (v3)
  {
    *((_QWORD *)this + 9) = v3;
    operator delete(v3);
  }
  v4 = *((_QWORD *)this + 2);
  if (v4)
  {
    v5 = *((_QWORD *)this + 3);
    v6 = (void *)*((_QWORD *)this + 2);
    if (v5 != v4)
    {
      v7 = *((_QWORD *)this + 3);
      do
      {
        v9 = *(void **)(v7 - 24);
        v7 -= 24;
        v8 = v9;
        if (v9)
        {
          *(_QWORD *)(v5 - 16) = v8;
          operator delete(v8);
        }
        v5 = v7;
      }
      while (v7 != v4);
      v6 = (void *)*((_QWORD *)this + 2);
    }
    *((_QWORD *)this + 3) = v4;
    operator delete(v6);
  }
  v10 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v10)
    MEMORY[0x20BD0ADEC](v10, 0xC400A2AC0F1);
}

void webrtc::FilterAnalyzer::Update(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, unsigned __int8 *a5, float *a6)
{
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  float32x4_t *v32;
  uint64_t v33;
  uint64_t v34;
  float32x4_t *v35;
  unint64_t v36;
  float32x4_t v37;
  float *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  float v49;
  unint64_t v50;
  uint64_t v51;
  float v52;
  float v53;
  int v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  float *v59;
  float *v60;
  unint64_t *v61;
  float v62;
  float v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  float *v68;
  float v69;
  float v70;
  unint64_t v71;
  unint64_t v72;
  float v73;
  _BYTE *v74;
  float v75;
  _BOOL4 v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  BOOL v84;
  float *v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  uint64_t v91;
  _DWORD *v92;
  int v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unsigned __int8 v99;
  _DWORD *v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int *v106;
  unint64_t v107;
  uint64_t j;
  float v109;
  float v110;
  float v111;
  int v112;
  int v113;
  unint64_t v114;
  float *v115;
  unint64_t *v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  float v120;
  unint64_t v121;
  uint64_t v122;
  float v123;
  float v124;
  int v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  float *v130;
  float *v131;
  unint64_t *v132;
  float v133;
  float v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  float *v139;
  float v140;
  float v141;
  unint64_t v142;
  unint64_t v143;
  float v144;
  _BYTE *v145;
  float v146;
  _BOOL4 v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  unint64_t v153;
  unint64_t v154;
  BOOL v155;
  float *v156;
  float v157;
  float v158;
  float v159;
  float v160;
  float v161;
  uint64_t v162;
  _DWORD *v163;
  int v164;
  uint64_t v165;
  int v166;
  uint64_t v167;
  int *v168;
  unint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t i;
  float v173;
  int v174;
  int v175;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  _QWORD *v182;

  v7 = *(_QWORD *)(a1 + 56);
  v8 = ((uint64_t)(a2[1] - *a2) >> 2) - 1;
  if (v7 < v8)
    v9 = v7 + 1;
  else
    v9 = 0;
  ++*(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 48) = v9;
  v10 = v9 + 63;
  if (v8 < v9 + 63)
    v10 = v8;
  *(_QWORD *)(a1 + 56) = v10;
  if (a3)
    v11 = a2;
  else
    v11 = 0;
  v182 = v11;
  v13 = *(_QWORD *)(a1 + 16);
  v12 = *(_QWORD *)(a1 + 24);
  if (a3)
  {
    v14 = 0;
    v180 = (float32x4_t)vdupq_n_s32(0xBEB8B076);
    v181 = (float32x4_t)vdupq_n_s32(0x3F4B005Bu);
    v179 = (float32x4_t)vdupq_n_s32(0xBEF0E273);
    do
    {
      v15 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
      if (v15 <= v14)
        goto LABEL_206;
      v16 = (_QWORD *)(v13 + 24 * v14);
      v17 = &v182[3 * v14];
      v18 = (v17[1] - *v17) >> 2;
      v19 = (uint64_t)(v16[1] - *v16) >> 2;
      if (v18 <= v19)
      {
        if (v18 < v19)
          v16[1] = *v16 + 4 * v18;
      }
      else
      {
        std::vector<float>::__append((uint64_t)v16, v18 - v19);
        v13 = *(_QWORD *)(a1 + 16);
        v12 = *(_QWORD *)(a1 + 24);
        v15 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v13) >> 3);
      }
      if (v15 <= v14)
        goto LABEL_206;
      v20 = *(_QWORD *)(v13 + 24 * v14);
      v21 = *(_QWORD *)(a1 + 48);
      v22 = *(_QWORD *)(a1 + 56);
      v23 = 4 * v22 - 4 * v21 + 4;
      if (v23 >= 1)
      {
        v24 = *(_QWORD *)(a1 + 48);
        v25 = *(_QWORD *)(a1 + 56);
        v26 = v12;
        bzero((void *)(v20 + 4 * v21), 4 * (((unint64_t)v23 >> 2) - ((unint64_t)v23 > 3)) + 4);
        v12 = v26;
        v22 = v25;
        v21 = v24;
      }
      v27 = 2;
      if (v21 > 2)
        v27 = v21;
      if (v27 <= v22)
      {
        v28 = *v17;
        v29 = v22 + 1;
        v30 = v22 + 1 <= v27 + 1 ? v27 + 1 : v22 + 1;
        v31 = v30 - v27;
        if (v31 < 8)
          goto LABEL_34;
        v32 = (float32x4_t *)(v20 + 4 * v27);
        if (v29 <= v27 + 1)
          v29 = v27 + 1;
        v33 = 4 * v29;
        v34 = v28 + 4 * v27;
        if ((unint64_t)v32 < v28 + v33 && v34 - 8 < (unint64_t)(v20 + v33))
          goto LABEL_34;
        v27 += v31 & 0xFFFFFFFFFFFFFFF8;
        v35 = v32 + 1;
        v36 = v31 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v37 = vmlaq_f32(vmlaq_f32(vmlaq_f32(*v35, v181, *(float32x4_t *)(v34 + 16)), v180, *(float32x4_t *)(v34 + 12)), v179, *(float32x4_t *)(v34 + 8));
          v35[-1] = vmlaq_f32(vmlaq_f32(vmlaq_f32(v35[-1], v181, *(float32x4_t *)v34), v180, *(float32x4_t *)(v34 - 4)), v179, *(float32x4_t *)(v34 - 8));
          *v35 = v37;
          v34 += 32;
          v35 += 2;
          v36 -= 8;
        }
        while (v36);
        if (v31 != (v31 & 0xFFFFFFFFFFFFFFF8))
        {
LABEL_34:
          v38 = (float *)(v28 + 4 * v27);
          do
          {
            *(float *)(v20 + 4 * v27) = (float)((float)(*(float *)(v20 + 4 * v27) + (float)(*v38 * 0.79297))
                                              + (float)(*(v38 - 1) * -0.36072))
                                      + (float)(*(v38 - 2) * -0.47048);
            ++v27;
            ++v38;
          }
          while (v27 <= v22);
        }
      }
      ++v14;
    }
    while (v14 != a3);
    if (v12 != v13)
    {
      v39 = *(_QWORD *)(a1 + 64);
      v40 = (*(_QWORD *)(a1 + 72) - v39) / 80;
      v41 = (v12 - v13) / 24;
      v42 = *a4;
      v43 = 4 * v21;
      if (v40 <= v41)
      {
        v44 = 0;
        while (1)
        {
          if (v44 == v40)
            goto LABEL_206;
          v45 = v39 + 80 * v44;
          v46 = *(_QWORD *)(v45 + 8);
          v47 = *(_QWORD *)(v13 + 24 * v44);
          v48 = (*(_QWORD *)(v13 + 24 * v44 + 8) - v47) >> 2;
          if (*(_QWORD *)(v13 + 24 * v44 + 8) == v47)
            v47 = 0;
          if (v48 - 1 < v46)
            v46 = v48 - 1;
          if (v21 <= v22)
          {
            v49 = *(float *)(v47 + 4 * v46) * *(float *)(v47 + 4 * v46);
            v50 = v21;
            do
            {
              if ((float)(*(float *)(v47 + 4 * v50) * *(float *)(v47 + 4 * v50)) > v49)
              {
                v46 = v50;
                v49 = *(float *)(v47 + 4 * v50) * *(float *)(v47 + 4 * v50);
              }
              ++v50;
            }
            while (v50 <= v22);
          }
          *(_QWORD *)(v45 + 8) = v46;
          v51 = *(_QWORD *)(a1 + 88);
          if (v44 >= (*(_QWORD *)(a1 + 96) - v51) >> 2)
            goto LABEL_206;
          *(_DWORD *)(v51 + 4 * v44) = v46 >> 6;
          if (*(_QWORD *)(a1 + 40) >= 0x4E3uLL)
          {
            if (*(_BYTE *)(v39 + 80 * v44 + 20))
              break;
          }
          v52 = *(float *)v45;
          if (*(float *)v45 != 0.0)
          {
            v53 = fabsf(*(float *)(v47 + 4 * v46));
            if (v52 < v53)
              v52 = v53;
            goto LABEL_59;
          }
LABEL_60:
          if (*(_BYTE *)(a1 + 8) && v52 != 0.0)
          {
            if (v52 < 0.01)
              v52 = 0.01;
            *(float *)v45 = v52;
          }
          *(_DWORD *)(v39 + 80 * v44 + 16) = (int)(float)((float)(unint64_t)((uint64_t)(v182[3 * v44 + 1]
                                                                                            - v182[3 * v44]) >> 2)
                                                        * 0.015625);
          v54 = *(_DWORD *)(v51 + 4 * v44);
          v55 = (*(_DWORD *)(v42 + 36) - v54 + *(_DWORD *)v42) % *(_DWORD *)v42;
          v56 = *(_QWORD *)(v42 + 8);
          if (v55 >= (*(_QWORD *)(v42 + 16) - v56) >> 5)
            goto LABEL_206;
          v57 = v39 + 80 * v44;
          v58 = *(_QWORD *)(a1 + 56);
          v59 = (float *)(v57 + 28);
          v60 = (float *)(v57 + 32);
          v61 = (unint64_t *)(v57 + 40);
          if (v21)
          {
            v62 = *v59;
            v63 = *v60;
            v64 = *v61;
            if (*v61 >= v58 + 1)
              v65 = v58 + 1;
            else
              v65 = *v61;
            if (v65 <= v21)
              goto LABEL_85;
LABEL_81:
            v67 = v65 - v21;
            v68 = (float *)(v47 + v43);
            do
            {
              v69 = *v68++;
              v70 = fabsf(v69);
              v62 = v62 + v70;
              if (v63 < v70)
                v63 = v70;
              --v67;
            }
            while (v67);
            goto LABEL_85;
          }
          *(_QWORD *)v59 = 0;
          v64 = v46 - 64;
          if (v46 < 0x40)
            v64 = 0;
          *v61 = v64;
          if (v48 - 129 >= v46)
            v66 = v46 + 128;
          else
            v66 = 0;
          *(_QWORD *)(v39 + 80 * v44 + 48) = v66;
          v63 = 0.0;
          v62 = 0.0;
          if (v64 >= v58 + 1)
            v65 = v58 + 1;
          else
            v65 = v64;
          if (v65)
            goto LABEL_81;
LABEL_85:
          v71 = *(_QWORD *)(v39 + 80 * v44 + 48);
          if (v71 <= v21)
            v72 = v21;
          else
            v72 = *(_QWORD *)(v39 + 80 * v44 + 48);
          for (; v72 <= v58; ++v72)
          {
            v73 = fabsf(*(float *)(v47 + 4 * v72));
            v62 = v62 + v73;
            if (v63 < v73)
              v63 = v73;
          }
          v74 = (_BYTE *)(v57 + 24);
          *v59 = v62;
          *v60 = v63;
          if (v48 - 1 == v58)
          {
            v75 = fabsf(*(float *)(v47 + 4 * v46));
            v76 = v75 > (float)((float)(v62 / (float)(v64 + v48 - v71)) * 10.0);
            if (v75 <= (float)(v63 + v63))
              v76 = 0;
            *v74 = v76;
            if (!v76)
              goto LABEL_41;
          }
          else if (!*v74)
          {
            goto LABEL_41;
          }
          v77 = v56 + 32 * v55;
          v78 = *(unsigned int *)(v77 + 4);
          if ((int)v78 > 0)
          {
            v79 = 0;
            v81 = v77 + 8;
            v80 = *(_QWORD *)(v77 + 8);
            v82 = (*(_QWORD *)(v81 + 8) - v80) >> 2;
            v83 = 1;
            v84 = 1;
            while (v82 > (int)v79)
            {
              v85 = (float *)(v80 + 4 * (int)v79);
              v86 = v85[11];
              v87 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*v85 * *v85) + 0.0) + (float)(v85[1] * v85[1])) + (float)(v85[2] * v85[2])) + (float)(v85[3] * v85[3])) + (float)(v85[4] * v85[4])) + (float)(v85[5] * v85[5])) + (float)(v85[6] * v85[6])) + (float)(v85[7] * v85[7])) + (float)(v85[8] * v85[8])) + (float)(v85[9] * v85[9])) + (float)(v85[10] * v85[10]))
                                                                                                  + (float)(v86 * v86))
                                                                                          + (float)(v85[12] * v85[12]))
                                                                                  + (float)(v85[13] * v85[13]))
                                                                          + (float)(v85[14] * v85[14]))
                                                                  + (float)(v85[15] * v85[15]))
                                                          + (float)(v85[16] * v85[16]))
                                                  + (float)(v85[17] * v85[17]))
                                          + (float)(v85[18] * v85[18]))
                                  + (float)(v85[19] * v85[19]))
                          + (float)(v85[20] * v85[20]))
                  + (float)(v85[21] * v85[21]);
              v88 = v85[33];
              v89 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v87 + (float)(v85[22] * v85[22])) + (float)(v85[23] * v85[23])) + (float)(v85[24] * v85[24])) + (float)(v85[25] * v85[25])) + (float)(v85[26] * v85[26])) + (float)(v85[27] * v85[27])) + (float)(v85[28] * v85[28])) + (float)(v85[29] * v85[29])) + (float)(v85[30] * v85[30])) + (float)(v85[31] * v85[31])) + (float)(v85[32] * v85[32]))
                                                                                                  + (float)(v88 * v88))
                                                                                          + (float)(v85[34] * v85[34]))
                                                                                  + (float)(v85[35] * v85[35]))
                                                                          + (float)(v85[36] * v85[36]))
                                                                  + (float)(v85[37] * v85[37]))
                                                          + (float)(v85[38] * v85[38]))
                                                  + (float)(v85[39] * v85[39]))
                                          + (float)(v85[40] * v85[40]))
                                  + (float)(v85[41] * v85[41]))
                          + (float)(v85[42] * v85[42]))
                  + (float)(v85[43] * v85[43]);
              v90 = v85[55];
              if ((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v89 + (float)(v85[44] * v85[44])) + (float)(v85[45] * v85[45])) + (float)(v85[46] * v85[46])) + (float)(v85[47] * v85[47])) + (float)(v85[48] * v85[48])) + (float)(v85[49] * v85[49])) + (float)(v85[50] * v85[50])) + (float)(v85[51] * v85[51])) + (float)(v85[52] * v85[52])) + (float)(v85[53] * v85[53]))
                                                                                                 + (float)(v85[54] * v85[54]))
                                                                                         + (float)(v90 * v90))
                                                                                 + (float)(v85[56] * v85[56]))
                                                                         + (float)(v85[57] * v85[57]))
                                                                 + (float)(v85[58] * v85[58]))
                                                         + (float)(v85[59] * v85[59]))
                                                 + (float)(v85[60] * v85[60]))
                                         + (float)(v85[61] * v85[61]))
                                 + (float)(v85[62] * v85[62]))
                         + (float)(v85[63] * v85[63])) <= *(float *)(v39 + 80 * v44 + 56))
              {
                v84 = v83 < v78;
                v79 += 64;
                ++v83;
                if (v78 << 6 != v79)
                  continue;
              }
              v91 = v39 + 80 * v44;
              v93 = *(_DWORD *)(v91 + 72);
              v92 = (_DWORD *)(v91 + 72);
              if (v93 != v54)
                goto LABEL_40;
              if (v84)
                ++*(_QWORD *)(v39 + 80 * v44 + 64);
              goto LABEL_41;
            }
            goto LABEL_206;
          }
          v94 = v39 + 80 * v44;
          v95 = *(_DWORD *)(v94 + 72);
          v92 = (_DWORD *)(v94 + 72);
          if (v95 != v54)
          {
LABEL_40:
            *(_QWORD *)(v39 + 80 * v44 + 64) = 0;
            *v92 = v54;
          }
LABEL_41:
          *(_BYTE *)(v39 + 80 * v44 + 20) = *(_QWORD *)(v39 + 80 * v44 + 64) > 0x177uLL;
          if (++v44 == a3)
            goto LABEL_109;
        }
        v52 = fabsf(*(float *)(v47 + 4 * v46));
LABEL_59:
        *(float *)v45 = v52;
        goto LABEL_60;
      }
      v114 = 0;
      while (1)
      {
        if (v114 == v40 || v114 == v41)
          goto LABEL_206;
        v115 = (float *)(v39 + 80 * v114);
        v116 = (unint64_t *)(v115 + 2);
        v117 = *(_QWORD *)(v13 + 24 * v114);
        v118 = (*(_QWORD *)(v13 + 24 * v114 + 8) - v117) >> 2;
        if (*(_QWORD *)(v13 + 24 * v114 + 8) == v117)
          v117 = 0;
        v119 = *v116;
        if (v118 - 1 < *v116)
          v119 = v118 - 1;
        if (v21 <= v22)
        {
          v120 = *(float *)(v117 + 4 * v119) * *(float *)(v117 + 4 * v119);
          v121 = v21;
          do
          {
            if ((float)(*(float *)(v117 + 4 * v121) * *(float *)(v117 + 4 * v121)) > v120)
            {
              v119 = v121;
              v120 = *(float *)(v117 + 4 * v121) * *(float *)(v117 + 4 * v121);
            }
            ++v121;
          }
          while (v121 <= v22);
        }
        *v116 = v119;
        v122 = *(_QWORD *)(a1 + 88);
        if (v114 >= (*(_QWORD *)(a1 + 96) - v122) >> 2)
          goto LABEL_206;
        *(_DWORD *)(v122 + 4 * v114) = v119 >> 6;
        if (*(_QWORD *)(a1 + 40) >= 0x4E3uLL)
        {
          if (*(_BYTE *)(v39 + 80 * v114 + 20))
            break;
        }
        v123 = *v115;
        if (*v115 != 0.0)
        {
          v124 = fabsf(*(float *)(v117 + 4 * v119));
          if (v123 < v124)
            v123 = v124;
          goto LABEL_145;
        }
LABEL_146:
        if (*(_BYTE *)(a1 + 8) && v123 != 0.0)
        {
          if (v123 < 0.01)
            v123 = 0.01;
          *v115 = v123;
        }
        *(_DWORD *)(v39 + 80 * v114 + 16) = (int)(float)((float)(unint64_t)((uint64_t)(v182[3 * v114 + 1]
                                                                                           - v182[3 * v114]) >> 2)
                                                       * 0.015625);
        v125 = *(_DWORD *)(v122 + 4 * v114);
        v126 = (*(_DWORD *)(v42 + 36) - v125 + *(_DWORD *)v42) % *(_DWORD *)v42;
        v127 = *(_QWORD *)(v42 + 8);
        if (v126 >= (*(_QWORD *)(v42 + 16) - v127) >> 5)
          goto LABEL_206;
        v128 = v39 + 80 * v114;
        v129 = *(_QWORD *)(a1 + 56);
        v130 = (float *)(v128 + 28);
        v131 = (float *)(v128 + 32);
        v132 = (unint64_t *)(v128 + 40);
        if (v21)
        {
          v133 = *v130;
          v134 = *v131;
          v135 = *v132;
          if (*v132 >= v129 + 1)
            v136 = v129 + 1;
          else
            v136 = *v132;
          if (v136 <= v21)
            goto LABEL_171;
LABEL_167:
          v138 = v136 - v21;
          v139 = (float *)(v117 + v43);
          do
          {
            v140 = *v139++;
            v141 = fabsf(v140);
            v133 = v133 + v141;
            if (v134 < v141)
              v134 = v141;
            --v138;
          }
          while (v138);
          goto LABEL_171;
        }
        *(_QWORD *)v130 = 0;
        v135 = v119 - 64;
        if (v119 < 0x40)
          v135 = 0;
        *v132 = v135;
        if (v118 - 129 >= v119)
          v137 = v119 + 128;
        else
          v137 = 0;
        *(_QWORD *)(v39 + 80 * v114 + 48) = v137;
        v134 = 0.0;
        v133 = 0.0;
        if (v135 >= v129 + 1)
          v136 = v129 + 1;
        else
          v136 = v135;
        if (v136)
          goto LABEL_167;
LABEL_171:
        v142 = *(_QWORD *)(v39 + 80 * v114 + 48);
        if (v142 <= v21)
          v143 = v21;
        else
          v143 = *(_QWORD *)(v39 + 80 * v114 + 48);
        for (; v143 <= v129; ++v143)
        {
          v144 = fabsf(*(float *)(v117 + 4 * v143));
          v133 = v133 + v144;
          if (v134 < v144)
            v134 = v144;
        }
        v145 = (_BYTE *)(v128 + 24);
        *v130 = v133;
        *v131 = v134;
        if (v118 - 1 == v129)
        {
          v146 = fabsf(*(float *)(v117 + 4 * v119));
          v147 = v146 > (float)((float)(v133 / (float)(v135 + v118 - v142)) * 10.0);
          if (v146 <= (float)(v134 + v134))
            v147 = 0;
          *v145 = v147;
          if (!v147)
            goto LABEL_126;
        }
        else if (!*v145)
        {
          goto LABEL_126;
        }
        v148 = v127 + 32 * v126;
        v149 = *(unsigned int *)(v148 + 4);
        if ((int)v149 >= 1)
        {
          v150 = 0;
          v152 = v148 + 8;
          v151 = *(_QWORD *)(v148 + 8);
          v153 = (*(_QWORD *)(v152 + 8) - v151) >> 2;
          v154 = 1;
          v155 = 1;
          while (v153 > (int)v150)
          {
            v156 = (float *)(v151 + 4 * (int)v150);
            v157 = v156[11];
            v158 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*v156 * *v156) + 0.0) + (float)(v156[1] * v156[1])) + (float)(v156[2] * v156[2])) + (float)(v156[3] * v156[3])) + (float)(v156[4] * v156[4])) + (float)(v156[5] * v156[5])) + (float)(v156[6] * v156[6])) + (float)(v156[7] * v156[7])) + (float)(v156[8] * v156[8])) + (float)(v156[9] * v156[9])) + (float)(v156[10] * v156[10]))
                                                                                                 + (float)(v157 * v157))
                                                                                         + (float)(v156[12] * v156[12]))
                                                                                 + (float)(v156[13] * v156[13]))
                                                                         + (float)(v156[14] * v156[14]))
                                                                 + (float)(v156[15] * v156[15]))
                                                         + (float)(v156[16] * v156[16]))
                                                 + (float)(v156[17] * v156[17]))
                                         + (float)(v156[18] * v156[18]))
                                 + (float)(v156[19] * v156[19]))
                         + (float)(v156[20] * v156[20]))
                 + (float)(v156[21] * v156[21]);
            v159 = v156[33];
            v160 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v158 + (float)(v156[22] * v156[22])) + (float)(v156[23] * v156[23])) + (float)(v156[24] * v156[24])) + (float)(v156[25] * v156[25])) + (float)(v156[26] * v156[26])) + (float)(v156[27] * v156[27])) + (float)(v156[28] * v156[28])) + (float)(v156[29] * v156[29])) + (float)(v156[30] * v156[30])) + (float)(v156[31] * v156[31])) + (float)(v156[32] * v156[32]))
                                                                                                 + (float)(v159 * v159))
                                                                                         + (float)(v156[34] * v156[34]))
                                                                                 + (float)(v156[35] * v156[35]))
                                                                         + (float)(v156[36] * v156[36]))
                                                                 + (float)(v156[37] * v156[37]))
                                                         + (float)(v156[38] * v156[38]))
                                                 + (float)(v156[39] * v156[39]))
                                         + (float)(v156[40] * v156[40]))
                                 + (float)(v156[41] * v156[41]))
                         + (float)(v156[42] * v156[42]))
                 + (float)(v156[43] * v156[43]);
            v161 = v156[55];
            if ((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v160 + (float)(v156[44] * v156[44])) + (float)(v156[45] * v156[45])) + (float)(v156[46] * v156[46])) + (float)(v156[47] * v156[47])) + (float)(v156[48] * v156[48])) + (float)(v156[49] * v156[49])) + (float)(v156[50] * v156[50])) + (float)(v156[51] * v156[51])) + (float)(v156[52] * v156[52])) + (float)(v156[53] * v156[53]))
                                                                                               + (float)(v156[54] * v156[54]))
                                                                                       + (float)(v161 * v161))
                                                                               + (float)(v156[56] * v156[56]))
                                                                       + (float)(v156[57] * v156[57]))
                                                               + (float)(v156[58] * v156[58]))
                                                       + (float)(v156[59] * v156[59]))
                                               + (float)(v156[60] * v156[60]))
                                       + (float)(v156[61] * v156[61]))
                               + (float)(v156[62] * v156[62]))
                       + (float)(v156[63] * v156[63])) <= *(float *)(v39 + 80 * v114 + 56))
            {
              v155 = v154 < v149;
              v150 += 64;
              ++v154;
              if (v149 << 6 != v150)
                continue;
            }
            v162 = v39 + 80 * v114;
            v164 = *(_DWORD *)(v162 + 72);
            v163 = (_DWORD *)(v162 + 72);
            if (v164 != v125)
              goto LABEL_125;
            if (v155)
              ++*(_QWORD *)(v39 + 80 * v114 + 64);
            goto LABEL_126;
          }
          goto LABEL_206;
        }
        v165 = v39 + 80 * v114;
        v166 = *(_DWORD *)(v165 + 72);
        v163 = (_DWORD *)(v165 + 72);
        if (v166 != v125)
        {
LABEL_125:
          *(_QWORD *)(v39 + 80 * v114 + 64) = 0;
          *v163 = v125;
        }
LABEL_126:
        *(_BYTE *)(v39 + 80 * v114 + 20) = *(_QWORD *)(v39 + 80 * v114 + 64) > 0x177uLL;
        if (++v114 == a3)
          goto LABEL_109;
      }
      v123 = fabsf(*(float *)(v117 + 4 * v119));
LABEL_145:
      *v115 = v123;
      goto LABEL_146;
    }
    goto LABEL_206;
  }
  if (v12 == v13)
  {
LABEL_206:
    __break(1u);
    return;
  }
LABEL_109:
  v97 = *(_QWORD *)(a1 + 64);
  v96 = *(_QWORD *)(a1 + 72);
  v98 = v96 - v97;
  if (v96 == v97)
    goto LABEL_206;
  v99 = *(_BYTE *)(v97 + 20);
  *a5 = v99;
  *a6 = *(float *)v97;
  v100 = *(_DWORD **)(a1 + 88);
  v101 = *(_QWORD *)(a1 + 96) - (_QWORD)v100;
  if (!v101)
    goto LABEL_206;
  *(_DWORD *)(a1 + 112) = *v100;
  if (a3 >= 2)
  {
    v102 = v98 / 80;
    v103 = v101 >> 2;
    if (v102 <= 1)
      v104 = 1;
    else
      v104 = v102;
    if (v102 > v103)
    {
      if (v103 <= 1)
        v167 = 1;
      else
        v167 = v101 >> 2;
      v168 = v100 + 1;
      v169 = a3 - 1;
      v170 = v97 + 80;
      v171 = v167 - 1;
      for (i = v104 - 1; i; --i)
      {
        v99 = (v99 | *(unsigned __int8 *)(v170 + 20)) != 0;
        *a5 = v99;
        v173 = *a6;
        if (*a6 < *(float *)v170)
          v173 = *(float *)v170;
        *a6 = v173;
        if (!v171)
          break;
        v175 = *v168++;
        v174 = v175;
        if (v175 >= *(_DWORD *)(a1 + 112))
          v174 = *(_DWORD *)(a1 + 112);
        *(_DWORD *)(a1 + 112) = v174;
        v170 += 80;
        --v171;
        if (!--v169)
          return;
      }
    }
    else
    {
      v105 = v97 + 80;
      v106 = v100 + 1;
      v107 = a3 - 1;
      for (j = v104 - 1; j; --j)
      {
        v99 = (v99 | *(unsigned __int8 *)(v105 + 20)) != 0;
        *a5 = v99;
        v109 = *a6;
        v110 = *(float *)v105;
        v105 += 80;
        v111 = v110;
        if (*a6 < v110)
          v109 = v111;
        *a6 = v109;
        v113 = *v106++;
        v112 = v113;
        if (v113 >= *(_DWORD *)(a1 + 112))
          v112 = *(_DWORD *)(a1 + 112);
        *(_DWORD *)(a1 + 112) = v112;
        if (!--v107)
          return;
      }
    }
    goto LABEL_206;
  }
}

unint64_t WebRtcSpl_FilterAR(uint64_t a1, unint64_t a2, __int16 *a3, unint64_t a4, char *__dst, unint64_t a6, _OWORD *a7, int a8, uint64_t a9, uint64_t a10)
{
  unint64_t v12;
  uint64_t v13;
  char *v14;
  __int16 *v15;
  _WORD *v16;
  _WORD *v17;
  unint64_t v18;
  uint64_t v19;
  int16x8_t *v20;
  int16x8_t *v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  __int16 *v29;
  uint64_t v30;
  int16x8_t *v31;
  int16x8_t *v32;
  int16x8_t *v33;
  int64x2_t v34;
  int32x4_t v35;
  int32x4_t v36;
  unint64_t v37;
  int32x4_t v38;
  int32x4_t v39;
  int64x2_t v40;
  int16x8_t *v41;
  unint64_t v42;
  int64x2_t v43;
  int64x2_t v44;
  int64x2_t v45;
  int64x2_t v46;
  int64x2_t v47;
  int64x2_t v48;
  int16x8_t v49;
  int8x16_t v50;
  int16x8_t v51;
  int8x16_t v52;
  int16x8_t v53;
  uint32x4_t v54;
  uint32x4_t v55;
  uint32x4_t v56;
  uint32x4_t v57;
  int8x16_t v58;
  int16x8_t v59;
  int8x16_t v60;
  int16x8_t v61;
  __int16 *v62;
  __int16 *v63;
  unint64_t v64;
  int v65;
  int v66;
  int v67;
  int v68;
  unint64_t v69;
  __int16 *v70;
  char *v71;
  int16x8_t *v72;
  unint64_t v73;
  unint64_t v74;
  int32x4_t v75;
  int64x2_t v76;
  int32x4_t v77;
  unint64_t v78;
  int32x4_t v79;
  int32x4_t v80;
  int64x2_t v81;
  int16x8_t *v82;
  int16x8_t *v83;
  int16x8_t *v84;
  int64x2_t v85;
  int64x2_t v86;
  int64x2_t v87;
  int64x2_t v88;
  int64x2_t v89;
  int64x2_t v90;
  int16x8_t v91;
  int8x16_t v92;
  int16x8_t v93;
  int8x16_t v94;
  int16x8_t v95;
  uint32x4_t v96;
  uint32x4_t v97;
  uint32x4_t v98;
  uint32x4_t v99;
  int8x16_t v100;
  int16x8_t v101;
  int8x16_t v102;
  int16x8_t v103;
  unint64_t v104;
  int v105;
  int v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  size_t v115;
  uint64_t v116;
  _OWORD *v117;
  _OWORD *v118;
  unint64_t v119;
  __int128 v120;
  __int128 v121;
  uint64_t v122;
  char *v123;
  __int128 *v124;
  uint64_t v125;
  _OWORD *v126;
  __int128 *v127;
  char *v128;
  unint64_t v129;
  __int128 v130;
  __int128 v131;
  unint64_t v132;
  uint64_t v133;
  __int16 *v134;
  __int16 *v135;
  __int16 v136;
  uint64_t v137;
  __int16 v138;

  if (a4)
  {
    v12 = 0;
    v13 = 2 * a6 - 2;
    v14 = &__dst[v13];
    v15 = (__int16 *)((char *)a7 + v13);
    v16 = (_WORD *)a10;
    v17 = (_WORD *)a9;
    v18 = a2 - 1;
    v19 = 2 * a6 - 16;
    v20 = (int16x8_t *)((char *)a7 + v19);
    v21 = (int16x8_t *)&__dst[v19];
    while (1)
    {
      v23 = v12;
      v24 = *a3++;
      v25 = (v24 << 12);
      if (v12 < a2)
        v26 = v12 + 1;
      else
        v26 = a2;
      if (v26 < 2)
      {
        v28 = 0;
        v31 = (int16x8_t *)(a1 + 2);
        v12 = v23 + 1;
        if (v23 + 1 >= a2)
          goto LABEL_3;
        goto LABEL_18;
      }
      v27 = (int)v23;
      if (v26 < 0x11)
        break;
      v32 = (int16x8_t *)(a9 - 16 + 2 * (int)v23);
      v33 = (int16x8_t *)(a10 - 16 + 2 * (int)v23);
      v34 = (int64x2_t)(unint64_t)v25;
      v35 = 0uLL;
      v36 = 0uLL;
      v37 = (v26 - 1) & 0xFFFFFFFFFFFFFFF0;
      v38 = 0uLL;
      v39 = 0uLL;
      v40 = 0uLL;
      v27 = (int)v23 - v37;
      v29 = (__int16 *)(a1 + 2 + 2 * v37);
      v30 = v37 | 1;
      v41 = (int16x8_t *)(a1 + 18);
      v42 = v37;
      v43 = 0uLL;
      v44 = 0uLL;
      v45 = 0uLL;
      v46 = 0uLL;
      v47 = 0uLL;
      v48 = 0uLL;
      do
      {
        v49 = v41[-1];
        v50 = (int8x16_t)vrev64q_s16(*v32);
        v51 = (int16x8_t)vextq_s8(v50, v50, 8uLL);
        v52 = (int8x16_t)vrev64q_s16(v32[-1]);
        v53 = (int16x8_t)vextq_s8(v52, v52, 8uLL);
        v54 = (uint32x4_t)vmull_high_s16(v51, v49);
        v55 = (uint32x4_t)vmull_s16(*(int16x4_t *)v51.i8, *(int16x4_t *)v49.i8);
        v56 = (uint32x4_t)vmull_high_s16(v53, *v41);
        v57 = (uint32x4_t)vmull_s16(*(int16x4_t *)v53.i8, *(int16x4_t *)v41->i8);
        v44 = (int64x2_t)vsubw_high_u32((uint64x2_t)v44, v54);
        v43 = (int64x2_t)vsubw_u32((uint64x2_t)v43, *(uint32x2_t *)v54.i8);
        v40 = (int64x2_t)vsubw_high_u32((uint64x2_t)v40, v55);
        v34 = (int64x2_t)vsubw_u32((uint64x2_t)v34, *(uint32x2_t *)v55.i8);
        v48 = (int64x2_t)vsubw_high_u32((uint64x2_t)v48, v56);
        v47 = (int64x2_t)vsubw_u32((uint64x2_t)v47, *(uint32x2_t *)v56.i8);
        v46 = (int64x2_t)vsubw_high_u32((uint64x2_t)v46, v57);
        v45 = (int64x2_t)vsubw_u32((uint64x2_t)v45, *(uint32x2_t *)v57.i8);
        v58 = (int8x16_t)vrev64q_s16(*v33);
        v59 = (int16x8_t)vextq_s8(v58, v58, 8uLL);
        v60 = (int8x16_t)vrev64q_s16(v33[-1]);
        v61 = (int16x8_t)vextq_s8(v60, v60, 8uLL);
        v36 = vmlsl_high_s16(v36, v59, v49);
        v35 = vmlsl_s16(v35, *(int16x4_t *)v59.i8, *(int16x4_t *)v49.i8);
        v39 = vmlsl_high_s16(v39, v61, *v41);
        v38 = vmlsl_s16(v38, *(int16x4_t *)v61.i8, *(int16x4_t *)v41->i8);
        v32 -= 2;
        v41 += 2;
        v33 -= 2;
        v42 -= 16;
      }
      while (v42);
      v25 = vaddvq_s64(vaddq_s64(vaddq_s64(vaddq_s64(v45, v34), vaddq_s64(v47, v43)), vaddq_s64(vaddq_s64(v46, v40), vaddq_s64(v48, v44))));
      v28 = vaddvq_s32(vaddq_s32(vaddq_s32(v38, v35), vaddq_s32(v39, v36)));
      if (v26 - 1 != v37)
        goto LABEL_15;
LABEL_17:
      v31 = (int16x8_t *)(a1 + 2 * v26);
      v12 = v23 + 1;
      if (v23 + 1 >= a2)
        goto LABEL_3;
LABEL_18:
      v69 = ~v23 + a2;
      if (v69 >= 0x10)
      {
        v74 = v18 & 0xFFFFFFFFFFFFFFF0;
        v75 = (int32x4_t)v28;
        v76 = (int64x2_t)(unint64_t)v25;
        v77 = 0uLL;
        v78 = 2 * (v69 & 0xFFFFFFFFFFFFFFF0);
        v70 = &v15[v78 / 0xFFFFFFFFFFFFFFFELL];
        v71 = &v14[-v78];
        v79 = 0uLL;
        v80 = 0uLL;
        v81 = 0uLL;
        v72 = (int16x8_t *)((char *)v31 + v78);
        v73 = v12 + (v69 & 0xFFFFFFFFFFFFFFF0);
        v82 = v31 + 1;
        v83 = v21;
        v84 = v20;
        v85 = 0uLL;
        v86 = 0uLL;
        v87 = 0uLL;
        v88 = 0uLL;
        v89 = 0uLL;
        v90 = 0uLL;
        do
        {
          v91 = v82[-1];
          v92 = (int8x16_t)vrev64q_s16(*v83);
          v93 = (int16x8_t)vextq_s8(v92, v92, 8uLL);
          v94 = (int8x16_t)vrev64q_s16(v83[-1]);
          v95 = (int16x8_t)vextq_s8(v94, v94, 8uLL);
          v96 = (uint32x4_t)vmull_high_s16(v93, v91);
          v97 = (uint32x4_t)vmull_s16(*(int16x4_t *)v93.i8, *(int16x4_t *)v91.i8);
          v98 = (uint32x4_t)vmull_high_s16(v95, *v82);
          v99 = (uint32x4_t)vmull_s16(*(int16x4_t *)v95.i8, *(int16x4_t *)v82->i8);
          v86 = (int64x2_t)vsubw_high_u32((uint64x2_t)v86, v96);
          v85 = (int64x2_t)vsubw_u32((uint64x2_t)v85, *(uint32x2_t *)v96.i8);
          v81 = (int64x2_t)vsubw_high_u32((uint64x2_t)v81, v97);
          v76 = (int64x2_t)vsubw_u32((uint64x2_t)v76, *(uint32x2_t *)v97.i8);
          v90 = (int64x2_t)vsubw_high_u32((uint64x2_t)v90, v98);
          v89 = (int64x2_t)vsubw_u32((uint64x2_t)v89, *(uint32x2_t *)v98.i8);
          v88 = (int64x2_t)vsubw_high_u32((uint64x2_t)v88, v99);
          v87 = (int64x2_t)vsubw_u32((uint64x2_t)v87, *(uint32x2_t *)v99.i8);
          v100 = (int8x16_t)vrev64q_s16(*v84);
          v101 = (int16x8_t)vextq_s8(v100, v100, 8uLL);
          v102 = (int8x16_t)vrev64q_s16(v84[-1]);
          v103 = (int16x8_t)vextq_s8(v102, v102, 8uLL);
          v77 = vmlsl_high_s16(v77, v101, v91);
          v75 = vmlsl_s16(v75, *(int16x4_t *)v101.i8, *(int16x4_t *)v91.i8);
          v80 = vmlsl_high_s16(v80, v103, *v82);
          v79 = vmlsl_s16(v79, *(int16x4_t *)v103.i8, *(int16x4_t *)v82->i8);
          v82 += 2;
          v84 -= 2;
          v83 -= 2;
          v74 -= 16;
        }
        while (v74);
        v25 = vaddvq_s64(vaddq_s64(vaddq_s64(vaddq_s64(v87, v76), vaddq_s64(v89, v85)), vaddq_s64(vaddq_s64(v88, v81), vaddq_s64(v90, v86))));
        v28 = vaddvq_s32(vaddq_s32(vaddq_s32(v79, v75), vaddq_s32(v80, v77)));
        if (v69 == (v69 & 0xFFFFFFFFFFFFFFF0))
          goto LABEL_3;
      }
      else
      {
        v70 = v15;
        v71 = v14;
        v72 = v31;
        v73 = v12;
      }
      v104 = a2 - v73;
      do
      {
        v106 = v72->i16[0];
        v72 = (int16x8_t *)((char *)v72 + 2);
        v105 = v106;
        v107 = *(__int16 *)v71;
        v71 -= 2;
        v25 -= (v107 * v105);
        v108 = *v70--;
        v28 -= v108 * v105;
        --v104;
      }
      while (v104);
LABEL_3:
      v22 = v25 + (v28 >> 12);
      *v17++ = (unint64_t)(v22 + 2048) >> 12;
      *v16++ = v22 - ((v22 + 2048) & 0xF000);
      --v18;
      if (v12 == a4)
        goto LABEL_26;
    }
    v28 = 0;
    v29 = (__int16 *)(a1 + 2);
    v30 = 1;
LABEL_15:
    v62 = (__int16 *)(a10 - 2 + 2 * v27);
    v63 = (__int16 *)(a9 - 2 + 2 * v27);
    v64 = v26 - v30;
    do
    {
      v66 = *v29++;
      v65 = v66;
      v67 = *v63--;
      v25 -= (v67 * v65);
      v68 = *v62--;
      v28 -= v68 * v65;
      --v64;
    }
    while (v64);
    goto LABEL_17;
  }
LABEL_26:
  v109 = a6 - a4;
  if (a6 <= a4)
  {
    v114 = 2 * (a4 - (a2 - 1));
    v115 = 2 * (a2 - 1);
    memcpy(__dst, (const void *)(a9 + v114), v115);
    memcpy(a7, (const void *)(a10 + v114), v115);
    return a4;
  }
  if (v109 < 0x18)
  {
    v110 = 0;
LABEL_29:
    v111 = v110 + a4;
    v112 = 2 * v110;
    do
    {
      *(_WORD *)&__dst[v112] = *(_WORD *)&__dst[2 * v111];
      *(_WORD *)((char *)a7 + v112) = *((_WORD *)a7 + v111++);
      v112 += 2;
    }
    while (a6 != v111);
    goto LABEL_31;
  }
  v110 = 0;
  v116 = 2 * a4;
  if ((char *)a7 - __dst - 2 * a4 < 0x20)
    goto LABEL_29;
  if ((unint64_t)((char *)a7 + v116 - __dst) < 0x20)
    goto LABEL_29;
  if ((unint64_t)((char *)a7 - __dst) < 0x20)
    goto LABEL_29;
  if ((unint64_t)(v116 + 31) < 0x20)
    goto LABEL_29;
  v110 = v109 & 0xFFFFFFFFFFFFFFF0;
  v117 = a7 + 1;
  v118 = __dst + 16;
  v119 = v109 & 0xFFFFFFFFFFFFFFF0;
  do
  {
    v120 = *(_OWORD *)((char *)v118 + 2 * a4);
    *(v118 - 1) = *(_OWORD *)((char *)v118 + v116 - 16);
    *v118 = v120;
    v121 = *(_OWORD *)((char *)v117 + 2 * a4);
    *(v117 - 1) = *(_OWORD *)((char *)v117 + v116 - 16);
    *v117 = v121;
    v117 += 2;
    v118 += 2;
    v119 -= 16;
  }
  while (v119);
  if (v109 != v110)
    goto LABEL_29;
LABEL_31:
  if (!a4)
    return a4;
  if (a4 < 0x18)
  {
    v113 = 0;
LABEL_51:
    v132 = v113 - a4;
    v133 = 2 * v113;
    v134 = (__int16 *)(a10 + 2 * v113);
    v135 = (__int16 *)(a9 + v133);
    do
    {
      v136 = *v135++;
      v137 = 2 * v132;
      *(_WORD *)&__dst[2 * a6 + v137] = v136;
      v138 = *v134++;
      *(_WORD *)((char *)a7 + 2 * a6 + v137) = v138;
    }
    while (!__CFADD__(v132++, 1));
    return a4;
  }
  v113 = 0;
  v122 = (uint64_t)a7 + 2 * a6 + -2 * a4;
  v123 = &__dst[2 * a6 + -2 * a4];
  if ((unint64_t)(v122 - (_QWORD)v123) < 0x20)
    goto LABEL_51;
  if ((unint64_t)&v123[-a9] < 0x20)
    goto LABEL_51;
  if ((unint64_t)(a10 - (_QWORD)v123) < 0x20)
    goto LABEL_51;
  if ((unint64_t)(v122 - a9) < 0x20)
    goto LABEL_51;
  if ((unint64_t)(v122 - a10) < 0x20)
    goto LABEL_51;
  v113 = a4 & 0xFFFFFFFFFFFFFFF0;
  v124 = (__int128 *)(a9 + 16);
  v125 = 2 * a6 - 2 * a4 + 16;
  v126 = (_OWORD *)((char *)a7 + v125);
  v127 = (__int128 *)(a10 + 16);
  v128 = &__dst[v125];
  v129 = a4 & 0xFFFFFFFFFFFFFFF0;
  do
  {
    v130 = *v124;
    *((_OWORD *)v128 - 1) = *(v124 - 1);
    *(_OWORD *)v128 = v130;
    v131 = *v127;
    v124 += 2;
    *(v126 - 1) = *(v127 - 1);
    *v126 = v131;
    v126 += 2;
    v127 += 2;
    v128 += 32;
    v129 -= 16;
  }
  while (v129);
  if (v113 != a4)
    goto LABEL_51;
  return a4;
}

void *WebRtcIsac_WeightingFilter()
{
  uint64_t v0;
  _OWORD *v1;
  _OWORD *v2;
  void *v3;
  void *v4;
  const void *v5;
  _BYTE *v6;
  int v7;
  _OWORD *v8;
  _OWORD *v9;
  uint64_t v10;
  _OWORD *v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  unint64_t v37;
  _BYTE *v38;
  float64x2_t v39;
  double *v40;
  uint64_t v41;
  int8x16_t v42;
  double v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  uint64_t v47;
  double v48;
  int8x16_t v49;
  double v50;
  int8x16_t v51;
  int8x16_t v52;
  int8x16_t v53;
  uint64_t v54;
  double v55;
  int8x16_t v56;
  double v57;
  float64x2_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t v61;
  uint64_t v62;
  double v63;
  int8x16_t v64;
  double v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x16_t v68;
  uint64_t v69;
  double v70;
  int8x16_t v71;
  double v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t v75;
  uint64_t v76;
  double v77;
  int8x16_t v78;
  double v79;
  int8x16_t v80;
  int8x16_t v81;
  int8x16_t v82;
  uint64_t v83;
  double v84;
  int8x16_t v85;
  double v86;
  int8x16_t v87;
  int8x16_t v88;
  int8x16_t v89;
  double v90;
  __int128 v91;
  __int128 v92;
  _OWORD *v94;
  _OWORD *v95;
  void *v96;
  void *__dst;
  double v98[233];
  double v99;
  double v100;
  double v101;
  double v102;
  double v103;
  double v104;
  uint64_t v105;
  __int128 v106;
  __int128 v107;
  uint64_t v108;
  uint64_t v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  _OWORD v113[123];
  _OWORD v114[120];
  double v115[7];
  uint64_t v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  _BYTE v120[1920];
  _BYTE v121[1920];
  uint64_t v122;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v96 = v3;
  __dst = v4;
  v5 = (const void *)v0;
  v122 = *MEMORY[0x24BDAC8D0];
  memcpy(v120, v1, sizeof(v120));
  v6 = v121;
  memcpy(v121, v5, sizeof(v121));
  memcpy(v2, v121, 0x780uLL);
  v7 = 0;
  v106 = 0u;
  v107 = 0u;
  v109 = 0;
  v110 = v2[123];
  v111 = v2[124];
  v112 = v2[125];
  v94 = v2 + 126;
  v95 = v2 + 123;
  v113[120] = v2[126];
  v113[121] = v2[127];
  v113[122] = v2[128];
  v8 = v113;
  v9 = v2 + 130;
  v10 = 496;
  v11 = v114;
  v108 = 0;
  v105 = 0x3FF0000000000000;
  do
  {
    v37 = 0;
    v38 = &v120[v10];
    do
    {
      v39 = vmulq_f64((float64x2_t)v9[v37 / 0x10], *(float64x2_t *)&v38[v37]);
      v40 = &v98[v37 / 8];
      *(float64x2_t *)v40 = vmulq_f64((float64x2_t)v9[v37 / 0x10 - 1], *(float64x2_t *)&v38[v37 - 16]);
      *((float64x2_t *)v40 + 1) = v39;
      v37 += 32;
    }
    while (v37 != 1920);
    v41 = 0;
    v42 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(v98[0] * v98[0]), 0);
    v43 = 0.0;
    do
    {
      v44 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v41 + 1], *(float64x2_t *)&v98[v41 + 1]);
      v45 = vextq_s8(v42, v44, 8uLL);
      v42 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v41 + 3], *(float64x2_t *)&v98[v41 + 3]);
      v46 = vextq_s8(v44, v42, 8uLL);
      v43 = v43 + *(double *)v45.i64 + *(double *)&v45.i64[1] + *(double *)v46.i64 + *(double *)&v46.i64[1];
      v41 += 4;
    }
    while (v41 != 236);
    v47 = 0;
    v48 = v103 * v103 + v102 * v102 + *(double *)&v42.i64[1] + v43;
    v49 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(v98[0] * v98[1]), 0);
    v50 = 0.0;
    do
    {
      v51 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v47 + 1], *(float64x2_t *)&v98[v47 + 2]);
      v52 = vextq_s8(v49, v51, 8uLL);
      v49 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v47 + 3], *(float64x2_t *)&v98[v47 + 4]);
      v53 = vextq_s8(v51, v49, 8uLL);
      v50 = v50 + *(double *)v52.i64 + *(double *)&v52.i64[1] + *(double *)v53.i64 + *(double *)&v53.i64[1];
      v47 += 4;
    }
    while (v47 != 236);
    v54 = 0;
    v55 = v102 * v103 + *(double *)&v49.i64[1] + v50 + v103 * v104;
    v56 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(v98[0] * v98[2]), 0);
    v57 = 0.0;
    do
    {
      v58 = *(float64x2_t *)&v98[v54 + 3];
      v59 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v54 + 1], v58);
      v60 = vextq_s8(v56, v59, 8uLL);
      v56 = (int8x16_t)vmulq_f64(v58, *(float64x2_t *)&v98[v54 + 5]);
      v61 = vextq_s8(v59, v56, 8uLL);
      v57 = v57 + *(double *)v60.i64 + *(double *)&v60.i64[1] + *(double *)v61.i64 + *(double *)&v61.i64[1];
      v54 += 4;
    }
    while (v54 != 236);
    v62 = 0;
    v63 = *(double *)&v56.i64[1] + v57 + v102 * v104;
    v64 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(v98[0] * v98[3]), 0);
    v65 = 0.0;
    do
    {
      v66 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v62 + 1], *(float64x2_t *)&v98[v62 + 4]);
      v67 = vextq_s8(v64, v66, 8uLL);
      v64 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v62 + 3], *(float64x2_t *)&v98[v62 + 6]);
      v68 = vextq_s8(v66, v64, 8uLL);
      v65 = v65 + *(double *)v67.i64 + *(double *)&v67.i64[1] + *(double *)v68.i64 + *(double *)&v68.i64[1];
      v62 += 4;
    }
    while (v62 != 236);
    v69 = 0;
    v70 = v65 + *(double *)&v64.i64[1];
    v71 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(v98[0] * v98[4]), 0);
    v72 = 0.0;
    do
    {
      v73 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v69 + 1], *(float64x2_t *)&v98[v69 + 5]);
      v74 = vextq_s8(v71, v73, 8uLL);
      v71 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v69 + 3], *(float64x2_t *)&v98[v69 + 7]);
      v75 = vextq_s8(v73, v71, 8uLL);
      v72 = v72 + *(double *)v74.i64 + *(double *)&v74.i64[1] + *(double *)v75.i64 + *(double *)&v75.i64[1];
      v69 += 4;
    }
    while (v69 != 232);
    v76 = 0;
    v77 = v100 * v103 + v99 * v102 + *(double *)&v71.i64[1] + v72 + v101 * v104;
    v78 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(v98[0] * v98[5]), 0);
    v79 = 0.0;
    do
    {
      v80 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v76 + 1], *(float64x2_t *)&v98[v76 + 6]);
      v81 = vextq_s8(v78, v80, 8uLL);
      v78 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v76 + 3], *(float64x2_t *)&v98[v76 + 8]);
      v82 = vextq_s8(v80, v78, 8uLL);
      v79 = v79 + *(double *)v81.i64 + *(double *)&v81.i64[1] + *(double *)v82.i64 + *(double *)&v82.i64[1];
      v76 += 4;
    }
    while (v76 != 232);
    v83 = 0;
    v84 = v99 * v103 + *(double *)&v78.i64[1] + v79 + v100 * v104;
    v85 = (int8x16_t)vdupq_lane_s64(COERCE__INT64(v98[0] * v98[6]), 0);
    v86 = 0.0;
    do
    {
      v87 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v83 + 1], *(float64x2_t *)&v98[v83 + 7]);
      v88 = vextq_s8(v85, v87, 8uLL);
      v85 = (int8x16_t)vmulq_f64(*(float64x2_t *)&v98[v83 + 3], *(float64x2_t *)&v98[v83 + 9]);
      v89 = vextq_s8(v87, v85, 8uLL);
      v86 = v86 + *(double *)v88.i64 + *(double *)&v88.i64[1] + *(double *)v89.i64 + *(double *)&v89.i64[1];
      v83 += 4;
    }
    while (v83 != 232);
    v90 = (v48 + v104 * v104) * 1.01 + 1.0;
    v116 = 0x3FF0000000000000;
    if (v90 >= 1.0e-10)
    {
      v12 = -v55 / v90;
      v13 = v90 + v55 * v12;
      *(double *)v85.i64 = v63 + v12 * v55;
      v14 = -*(double *)v85.i64 / v13;
      v15 = v12 + v14 * v12;
      v16 = v70 + v15 * v63 + v14 * v55;
      v17 = v13 + v14 * *(double *)v85.i64;
      *(double *)v85.i64 = -v16 / v17;
      v18 = v15 + *(double *)v85.i64 * v14;
      v19 = v14 + *(double *)v85.i64 * v15;
      v20 = v77 + v18 * v70 + v19 * v63 + *(double *)v85.i64 * v55;
      v21 = v17 + *(double *)v85.i64 * v16;
      v22 = -v20 / v21;
      v23 = v18 + v22 * *(double *)v85.i64;
      *(double *)v85.i64 = *(double *)v85.i64 + v22 * v18;
      v24 = v19 + v22 * v19;
      v25 = v84 + v23 * v77 + v24 * v70 + *(double *)v85.i64 * v63 + v22 * v55;
      v26 = v21 + v22 * v20;
      v27 = -v25 / v26;
      v28 = v23 + v27 * v22;
      v29 = v22 + v27 * v23;
      v30 = v24 + v27 * *(double *)v85.i64;
      *(double *)v85.i64 = *(double *)v85.i64 + v27 * v24;
      v31 = -(*(double *)&v85.i64[1]
            + v86
            + v99 * v104
            + v28 * v84
            + v30 * v77
            + *(double *)v85.i64 * v70
            + v29 * v63
            + v27 * v55)
          / (v26 + v27 * v25);
      v32 = v28 + v31 * v27;
      v33 = v30 + v31 * v29;
      v34 = v29 + v31 * v30;
      *(double *)&v117 = v32;
      *((double *)&v117 + 1) = v33;
      v35 = *(double *)v85.i64 + v31 * *(double *)v85.i64;
      *((double *)&v118 + 1) = v34;
      *(double *)&v118 = v35;
      v36 = v27 + v31 * v28;
      *(double *)&v119 = v36;
      *((double *)&v119 + 1) = v31;
    }
    else
    {
      v118 = 0u;
      v119 = 0u;
      v31 = 0.0;
      v36 = 0.0;
      v34 = 0.0;
      v35 = 0.0;
      v117 = 0u;
      v33 = 0.0;
      v32 = 0.0;
    }
    v115[0] = 1.0;
    v115[1] = v32 * 0.9;
    v115[2] = v33 * 0.81;
    v115[3] = v35 * 0.729;
    v115[4] = v34 * 0.6561;
    v115[5] = v36 * 0.59049;
    v115[6] = v31 * 0.531441;
    WebRtcIsac_ZeroPoleFilter((uint64_t)v6, (double *)&v116, v115, (unint64_t)v8);
    WebRtcIsac_ZeroPoleFilter((uint64_t)v6, v115, (double *)&v105, (unint64_t)v11);
    v6 += 480;
    v8 += 30;
    v11 += 30;
    ++v7;
    v10 += 480;
  }
  while (v7 != 4);
  v91 = v113[118];
  *v95 = v113[117];
  v95[1] = v91;
  v95[2] = v113[119];
  v92 = v114[118];
  *v94 = v114[117];
  v94[1] = v92;
  v94[2] = v114[119];
  memcpy(v96, v113, 0x780uLL);
  return memcpy(__dst, v114, 0x780uLL);
}

uint64_t WebRtcIsac_ZeroPoleFilter(uint64_t result, double *a2, double *a3, unint64_t a4)
{
  unint64_t v4;
  _BOOL4 v6;
  BOOL v7;
  uint64_t v8;
  const double *v9;
  float64x2_t v10;
  float64x2_t v11;
  const double *v12;
  float64x2_t v13;
  const double *v14;
  float64x2_t v15;
  const double *v16;
  float64x2_t v17;
  const double *v18;
  float64x2_t v19;
  const double *v20;
  float64x2_t v21;
  uint64_t v22;
  uint64_t i;
  double v24;
  double v25;
  uint64_t j;
  uint64_t v27;
  double v28;
  double v29;
  double v30;
  double *v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;

  v4 = a4 + 480;
  v6 = (unint64_t)(a2 + 7) > a4 && v4 > (unint64_t)a2;
  v7 = result - 48 < v4 && result + 480 > a4;
  if (v7 || v6)
  {
    for (i = 0; i != 480; i += 8)
      *(double *)(a4 + i) = *(double *)(result + i) * *a2
                          + a2[1] * *(double *)(result + i - 8)
                          + a2[2] * *(double *)(result + i - 16)
                          + a2[3] * *(double *)(result + i - 24)
                          + a2[4] * *(double *)(result + i - 32)
                          + a2[5] * *(double *)(result + i - 40)
                          + a2[6] * *(double *)(result + i - 48);
  }
  else
  {
    v8 = 0;
    v9 = a2;
    v10 = vld1q_dup_f64(v9++);
    v11 = vld1q_dup_f64(v9);
    v12 = a2 + 2;
    v13 = vld1q_dup_f64(v12);
    v14 = a2 + 3;
    v15 = vld1q_dup_f64(v14);
    v16 = a2 + 4;
    v17 = vld1q_dup_f64(v16);
    v18 = a2 + 5;
    v19 = vld1q_dup_f64(v18);
    v20 = a2 + 6;
    v21 = vld1q_dup_f64(v20);
    do
    {
      v22 = result - 24;
      *(float64x2_t *)(a4 + v8) = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(*(float64x2_t *)(result + v8), v10), *(float64x2_t *)(v22 + v8 + 16), v11), *(float64x2_t *)(v22 + v8 + 8), v13), *(float64x2_t *)(v22 + v8), v15), *(float64x2_t *)(v22 + v8 - 8), v17), *(float64x2_t *)(v22 + v8 - 16), v19), *(float64x2_t *)(v22 + v8 - 24), v21);
      v8 += 16;
    }
    while (v8 != 480);
  }
  v24 = *a3;
  if (*a3 <= 0.9999 || v24 >= 1.0001)
  {
    v27 = 0;
    v28 = 1.0 / v24;
    v29 = -v28;
    v30 = *(double *)(a4 - 8);
    do
    {
      v31 = (double *)(a4 + v27);
      v32 = v28 * *(double *)(a4 + v27);
      *v31 = v32;
      v33 = v32 + a3[1] * v29 * v30;
      *v31 = v33;
      v34 = v33 + a3[2] * v29 * *(double *)(a4 + v27 - 16);
      *v31 = v34;
      v35 = *(double *)(a4 + v27 - 32);
      v36 = v34 + a3[3] * v29 * *(double *)(a4 + v27 - 24);
      *v31 = v36;
      v37 = v36 + a3[4] * v29 * v35;
      *v31 = v37;
      v38 = *(double *)(a4 + v27 - 48);
      v39 = v37 + a3[5] * v29 * *(double *)(a4 + v27 - 40);
      *v31 = v39;
      v30 = v39 + a3[6] * v29 * v38;
      *v31 = v30;
      v27 += 8;
    }
    while (v27 != 480);
  }
  else
  {
    v25 = *(double *)(a4 - 8);
    for (j = -48; j != 432; j += 8)
    {
      v25 = *(double *)(a4 + j + 48)
          - (a3[1] * v25
           + a3[2] * *(double *)(a4 + j + 32)
           + a3[3] * *(double *)(a4 + j + 24)
           + a3[4] * *(double *)(a4 + j + 16)
           + a3[5] * *(double *)(a4 + j + 8)
           + a3[6] * *(double *)(a4 + j));
      *(double *)(a4 + j + 48) = v25;
    }
  }
  return result;
}

void webrtc::rtcp::Fir::~Fir(webrtc::rtcp::Fir *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C0B4290;
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_24C0B4290;
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::rtcp::Fir::Parse(webrtc::rtcp::Fir *this, const webrtc::rtcp::CommonHeader *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _BYTE *v19;
  char v20;

  v2 = *((unsigned int *)a2 + 1);
  if (v2 <= 0xF)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      return 0;
LABEL_10:
    rtc::webrtc_logging_impl::Log("\r\t", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/fir.cc");
    return 0;
  }
  if ((v2 & 7) != 0)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
      return 0;
    goto LABEL_10;
  }
  v12 = (unsigned int *)*((_QWORD *)a2 + 1);
  v15 = *((_QWORD *)this + 2);
  v13 = (char *)this + 16;
  v14 = v15;
  *((_DWORD *)v13 - 2) = bswap32(*v12);
  *((_DWORD *)v13 - 1) = bswap32(v12[1]);
  v16 = (unint64_t)(v2 - 8) >> 3;
  v17 = *((_QWORD *)v13 + 1);
  v18 = (v17 - v15) >> 3;
  if (v16 <= v18)
  {
    if (v16 < v18)
    {
      v17 = v14 + 8 * v16;
      *((_QWORD *)this + 3) = v17;
    }
  }
  else
  {
    std::vector<webrtc::rtcp::Fir::Request>::__append((void **)v13, v16 - v18);
    v14 = *((_QWORD *)this + 2);
    v17 = *((_QWORD *)this + 3);
  }
  if (v14 != v17)
  {
    v19 = v12 + 3;
    do
    {
      *(_DWORD *)v14 = bswap32(*((_DWORD *)v19 - 1));
      v20 = *v19;
      v19 += 8;
      *(_BYTE *)(v14 + 4) = v20;
      v14 += 8;
    }
    while (v14 != v17);
  }
  return 1;
}

uint64_t webrtc::rtcp::Fir::BlockLength(webrtc::rtcp::Fir *this)
{
  return *((_QWORD *)this + 3) - *((_QWORD *)this + 2) + 12;
}

uint64_t webrtc::rtcp::Fir::Create(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5, void (*a6)(uint64_t, uint64_t))
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t i;
  uint64_t v25;
  std::string *v27;

  v12 = *a3;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) + v12 <= a4)
  {
LABEL_4:
    v13 = *a3;
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) + v13;
    v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    *(_BYTE *)(a2 + *a3) = -124;
    *(_BYTE *)(*a3 + a2 + 1) = -50;
    *(_BYTE *)(*a3 + a2 + 2) = (unint64_t)(v15 - 4) >> 10;
    *(_BYTE *)(*a3 + a2 + 3) = (unint64_t)(v15 - 4) >> 2;
    v20 = *a3 + 4;
    *a3 = v20;
    v21 = (_DWORD *)(a2 + v20);
    *v21 = bswap32(*(_DWORD *)(a1 + 8));
    v21[1] = bswap32(*(_DWORD *)(a1 + 12));
    v22 = *a3 + 8;
    *a3 = v22;
    v23 = *(_QWORD *)(a1 + 16);
    for (i = *(_QWORD *)(a1 + 24); v23 != i; v23 += 8)
    {
      *(_DWORD *)(a2 + v22) = bswap32(*(_DWORD *)v23);
      *(_BYTE *)(a2 + 4 + *a3) = *(_BYTE *)(v23 + 4);
      v25 = a2 + *a3;
      *(_WORD *)(v25 + 5) = 0;
      *(_BYTE *)(v25 + 7) = 0;
      v22 = *a3 + 8;
      *a3 = v22;
    }
    if (v22 == v14)
    {
      return 1;
    }
    else
    {
      v27 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/rtcp_packet/fir.cc", 109, "*index == index_end", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long> const&)::t, v16, v17, v18, v19, v22);
      return std::vector<webrtc::rtcp::Fir::Request>::__append(v27);
    }
  }
  else
  {
    while (*a3)
    {
      a6(a5, a2);
      *a3 = 0;
      if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) <= a4)
        goto LABEL_4;
    }
    return 0;
  }
}

void std::vector<webrtc::rtcp::Fir::Request>::__append(void **a1, unint64_t a2)
{
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  _BYTE *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  int v17;
  char v18;
  void *v19;

  v5 = a1[1];
  v4 = a1[2];
  if (a2 > (v4 - v5) >> 3)
  {
    v6 = *a1;
    v7 = (v5 - (_BYTE *)*a1) >> 3;
    v8 = v7 + a2;
    if (!((v7 + a2) >> 61))
    {
      v9 = v4 - v6;
      if (v9 >> 2 > v8)
        v8 = v9 >> 2;
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
        v10 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v10 = v8;
      if (v10)
      {
        if (v10 >> 61)
          std::__throw_bad_array_new_length[abi:sn180100]();
        v11 = (char *)operator new(8 * v10);
      }
      else
      {
        v11 = 0;
      }
      v13 = &v11[8 * v7];
      v14 = &v11[8 * v10];
      v15 = &v13[8 * a2];
      v16 = v13;
      do
      {
        if (!v16)
          goto LABEL_27;
        *(_DWORD *)v16 = 0;
        v16[4] = 0;
        v16 += 8;
      }
      while (v16 != v15);
      while (v5 != v6)
      {
        v17 = *((_DWORD *)v5 - 2);
        v5 -= 8;
        v18 = v5[4];
        *((_DWORD *)v13 - 2) = v17;
        v13 -= 8;
        v13[4] = v18;
      }
      v19 = *a1;
      *a1 = v13;
      a1[1] = v15;
      a1[2] = v14;
      if (v19)
        operator delete(v19);
      return;
    }
LABEL_28:
    abort();
  }
  if (!a2)
    goto LABEL_16;
  v12 = &v5[8 * a2];
  do
  {
    if (!v5)
    {
LABEL_27:
      __break(1u);
      goto LABEL_28;
    }
    *(_DWORD *)v5 = 0;
    v5[4] = 0;
    v5 += 8;
  }
  while (v5 != v12);
  v5 = v12;
LABEL_16:
  a1[1] = v5;
}

uint64_t webrtc::FixedDigitalLevelEstimator::ComputeLevel@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float *v27;
  float *v28;
  uint64_t v29;
  float v30;
  float v31;
  float *v32;
  uint64_t v33;
  float v34;
  float v35;
  float *v36;
  uint64_t v37;
  float v38;
  float v39;
  float *v40;
  uint64_t v41;
  float v42;
  float v43;
  float *v44;
  uint64_t v45;
  float v46;
  float v47;
  float *v48;
  uint64_t v49;
  float v50;
  float v51;
  float *v52;
  uint64_t v53;
  float v54;
  float v55;
  float *v56;
  uint64_t v57;
  float v58;
  float v59;
  float *v60;
  uint64_t v61;
  float v62;
  float v63;
  float *v64;
  uint64_t v65;
  float v66;
  float v67;
  float *v68;
  uint64_t v69;
  float v70;
  float v71;
  float *v72;
  uint64_t v73;
  float v74;
  float v75;
  float *v76;
  uint64_t v77;
  float v78;
  float v79;
  float *v80;
  uint64_t v81;
  float v82;
  float v83;
  float *v84;
  uint64_t v85;
  float v86;
  float v87;
  float *v88;
  uint64_t v89;
  float v90;
  float v91;
  float *v92;
  uint64_t v93;
  float v94;
  float v95;
  float *v96;
  uint64_t v97;
  float v98;
  float v99;
  float *v100;
  uint64_t v101;
  float v102;
  float v103;
  float *v104;
  uint64_t v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;

  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  v3 = *((unsigned int *)a2 + 2);
  if ((int)v3 < 1 || (v4 = *(unsigned int *)(result + 16), (int)v4 < 1))
  {
    v13 = 0.0;
    v15 = 0.0;
    v17 = 0.0;
    v19 = 0.0;
    v21 = 0.0;
    v23 = 0.0;
    v25 = 0.0;
    v26 = 0.0;
    v24 = 0.0;
    v22 = 0.0;
    v20 = 0.0;
    v18 = 0.0;
    v16 = 0.0;
    v14 = 0.0;
    goto LABEL_125;
  }
  v5 = 0;
  v6 = *a2;
  v7 = 0.0;
  v8 = 0.0;
  v9 = 0.0;
  v10 = 0.0;
  v11 = 0.0;
  v12 = 0.0;
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  v20 = 0.0;
  v21 = 0.0;
  v22 = 0.0;
  v23 = 0.0;
  v24 = 0.0;
  v25 = 0.0;
  v26 = 0.0;
  do
  {
    v27 = *(float **)(v6 + 8 * v5);
    v28 = v27;
    v29 = v4;
    do
    {
      v30 = *v28++;
      v31 = fabsf(v30);
      if (v26 < v31)
        v26 = v31;
      --v29;
    }
    while (v29);
    *(float *)a3 = v26;
    v32 = &v27[v4];
    v33 = v4;
    do
    {
      v34 = *v32++;
      v35 = fabsf(v34);
      if (v25 < v35)
        v25 = v35;
      --v33;
    }
    while (v33);
    *(float *)(a3 + 4) = v25;
    v36 = &v27[2 * v4];
    v37 = v4;
    do
    {
      v38 = *v36++;
      v39 = fabsf(v38);
      if (v24 < v39)
        v24 = v39;
      --v37;
    }
    while (v37);
    *(float *)(a3 + 8) = v24;
    v40 = &v27[3 * v4];
    v41 = v4;
    do
    {
      v42 = *v40++;
      v43 = fabsf(v42);
      if (v23 < v43)
        v23 = v43;
      --v41;
    }
    while (v41);
    *(float *)(a3 + 12) = v23;
    v44 = &v27[4 * v4];
    v45 = v4;
    do
    {
      v46 = *v44++;
      v47 = fabsf(v46);
      if (v22 < v47)
        v22 = v47;
      --v45;
    }
    while (v45);
    *(float *)(a3 + 16) = v22;
    v48 = &v27[5 * v4];
    v49 = v4;
    do
    {
      v50 = *v48++;
      v51 = fabsf(v50);
      if (v21 < v51)
        v21 = v51;
      --v49;
    }
    while (v49);
    *(float *)(a3 + 20) = v21;
    v52 = &v27[6 * v4];
    v53 = v4;
    do
    {
      v54 = *v52++;
      v55 = fabsf(v54);
      if (v20 < v55)
        v20 = v55;
      --v53;
    }
    while (v53);
    *(float *)(a3 + 24) = v20;
    v56 = &v27[7 * v4];
    v57 = v4;
    do
    {
      v58 = *v56++;
      v59 = fabsf(v58);
      if (v19 < v59)
        v19 = v59;
      --v57;
    }
    while (v57);
    *(float *)(a3 + 28) = v19;
    v60 = &v27[8 * v4];
    v61 = v4;
    do
    {
      v62 = *v60++;
      v63 = fabsf(v62);
      if (v18 < v63)
        v18 = v63;
      --v61;
    }
    while (v61);
    *(float *)(a3 + 32) = v18;
    v64 = &v27[9 * v4];
    v65 = v4;
    do
    {
      v66 = *v64++;
      v67 = fabsf(v66);
      if (v17 < v67)
        v17 = v67;
      --v65;
    }
    while (v65);
    *(float *)(a3 + 36) = v17;
    v68 = &v27[10 * v4];
    v69 = v4;
    do
    {
      v70 = *v68++;
      v71 = fabsf(v70);
      if (v16 < v71)
        v16 = v71;
      --v69;
    }
    while (v69);
    *(float *)(a3 + 40) = v16;
    v72 = &v27[11 * v4];
    v73 = v4;
    do
    {
      v74 = *v72++;
      v75 = fabsf(v74);
      if (v15 < v75)
        v15 = v75;
      --v73;
    }
    while (v73);
    *(float *)(a3 + 44) = v15;
    v76 = &v27[12 * v4];
    v77 = v4;
    do
    {
      v78 = *v76++;
      v79 = fabsf(v78);
      if (v14 < v79)
        v14 = v79;
      --v77;
    }
    while (v77);
    *(float *)(a3 + 48) = v14;
    v80 = &v27[13 * v4];
    v81 = v4;
    do
    {
      v82 = *v80++;
      v83 = fabsf(v82);
      if (v13 < v83)
        v13 = v83;
      --v81;
    }
    while (v81);
    *(float *)(a3 + 52) = v13;
    v84 = &v27[14 * v4];
    v85 = v4;
    do
    {
      v86 = *v84++;
      v87 = fabsf(v86);
      if (v12 < v87)
        v12 = v87;
      --v85;
    }
    while (v85);
    *(float *)(a3 + 56) = v12;
    v88 = &v27[15 * v4];
    v89 = v4;
    do
    {
      v90 = *v88++;
      v91 = fabsf(v90);
      if (v11 < v91)
        v11 = v91;
      --v89;
    }
    while (v89);
    *(float *)(a3 + 60) = v11;
    v92 = &v27[16 * v4];
    v93 = v4;
    do
    {
      v94 = *v92++;
      v95 = fabsf(v94);
      if (v10 < v95)
        v10 = v95;
      --v93;
    }
    while (v93);
    *(float *)(a3 + 64) = v10;
    v96 = &v27[17 * v4];
    v97 = v4;
    do
    {
      v98 = *v96++;
      v99 = fabsf(v98);
      if (v9 < v99)
        v9 = v99;
      --v97;
    }
    while (v97);
    *(float *)(a3 + 68) = v9;
    v100 = &v27[18 * v4];
    v101 = v4;
    do
    {
      v102 = *v100++;
      v103 = fabsf(v102);
      if (v8 < v103)
        v8 = v103;
      --v101;
    }
    while (v101);
    *(float *)(a3 + 72) = v8;
    v104 = &v27[19 * v4];
    v105 = v4;
    do
    {
      v106 = *v104++;
      v107 = fabsf(v106);
      if (v7 < v107)
        v7 = v107;
      --v105;
    }
    while (v105);
    *(float *)(a3 + 76) = v7;
    ++v5;
  }
  while (v5 != v3);
  if (v26 < v25)
  {
    *(float *)a3 = v25;
    v26 = v25;
    if (v25 >= v24)
    {
LABEL_87:
      if (v24 >= v23)
        goto LABEL_88;
      goto LABEL_108;
    }
  }
  else if (v25 >= v24)
  {
    goto LABEL_87;
  }
  *(float *)(a3 + 4) = v24;
  v25 = v24;
  if (v24 >= v23)
  {
LABEL_88:
    if (v23 >= v22)
      goto LABEL_89;
    goto LABEL_109;
  }
LABEL_108:
  *(float *)(a3 + 8) = v23;
  v24 = v23;
  if (v23 >= v22)
  {
LABEL_89:
    if (v22 >= v21)
      goto LABEL_90;
    goto LABEL_110;
  }
LABEL_109:
  *(float *)(a3 + 12) = v22;
  v23 = v22;
  if (v22 >= v21)
  {
LABEL_90:
    if (v21 >= v20)
      goto LABEL_91;
    goto LABEL_111;
  }
LABEL_110:
  *(float *)(a3 + 16) = v21;
  v22 = v21;
  if (v21 >= v20)
  {
LABEL_91:
    if (v20 >= v19)
      goto LABEL_92;
    goto LABEL_112;
  }
LABEL_111:
  *(float *)(a3 + 20) = v20;
  v21 = v20;
  if (v20 >= v19)
  {
LABEL_92:
    if (v19 >= v18)
      goto LABEL_93;
    goto LABEL_113;
  }
LABEL_112:
  *(float *)(a3 + 24) = v19;
  v20 = v19;
  if (v19 >= v18)
  {
LABEL_93:
    if (v18 >= v17)
      goto LABEL_94;
    goto LABEL_114;
  }
LABEL_113:
  *(float *)(a3 + 28) = v18;
  v19 = v18;
  if (v18 >= v17)
  {
LABEL_94:
    if (v17 >= v16)
      goto LABEL_95;
    goto LABEL_115;
  }
LABEL_114:
  *(float *)(a3 + 32) = v17;
  v18 = v17;
  if (v17 >= v16)
  {
LABEL_95:
    if (v16 >= v15)
      goto LABEL_96;
    goto LABEL_116;
  }
LABEL_115:
  *(float *)(a3 + 36) = v16;
  v17 = v16;
  if (v16 >= v15)
  {
LABEL_96:
    if (v15 >= v14)
      goto LABEL_97;
    goto LABEL_117;
  }
LABEL_116:
  *(float *)(a3 + 40) = v15;
  v16 = v15;
  if (v15 >= v14)
  {
LABEL_97:
    if (v14 >= v13)
      goto LABEL_98;
    goto LABEL_118;
  }
LABEL_117:
  *(float *)(a3 + 44) = v14;
  v15 = v14;
  if (v14 >= v13)
  {
LABEL_98:
    if (v13 >= v12)
      goto LABEL_99;
    goto LABEL_119;
  }
LABEL_118:
  *(float *)(a3 + 48) = v13;
  v14 = v13;
  if (v13 >= v12)
  {
LABEL_99:
    if (v12 >= v11)
      goto LABEL_100;
    goto LABEL_120;
  }
LABEL_119:
  *(float *)(a3 + 52) = v12;
  v13 = v12;
  if (v12 >= v11)
  {
LABEL_100:
    if (v11 >= v10)
      goto LABEL_101;
    goto LABEL_121;
  }
LABEL_120:
  *(float *)(a3 + 56) = v11;
  if (v11 >= v10)
  {
LABEL_101:
    if (v10 >= v9)
      goto LABEL_102;
    goto LABEL_122;
  }
LABEL_121:
  *(float *)(a3 + 60) = v10;
  if (v10 >= v9)
  {
LABEL_102:
    if (v9 >= v8)
      goto LABEL_103;
LABEL_123:
    *(float *)(a3 + 68) = v8;
    if (v8 >= v7)
      goto LABEL_125;
    goto LABEL_124;
  }
LABEL_122:
  *(float *)(a3 + 64) = v9;
  if (v9 < v8)
    goto LABEL_123;
LABEL_103:
  if (v8 < v7)
LABEL_124:
    *(float *)(a3 + 72) = v7;
LABEL_125:
  v108 = *(float *)(result + 8);
  if (v26 <= v108)
    v109 = (float)(v108 * 0.99713) + (float)(v26 * 0.0028741);
  else
    v109 = v26 + (float)(v108 * 0.0);
  *(float *)a3 = v109;
  if (v25 <= v109)
    v110 = (float)(v109 * 0.99713) + (float)(v25 * 0.0028741);
  else
    v110 = v25 + (float)(v109 * 0.0);
  *(float *)(a3 + 4) = v110;
  if (v24 <= v110)
    v111 = (float)(v110 * 0.99713) + (float)(v24 * 0.0028741);
  else
    v111 = v24 + (float)(v110 * 0.0);
  *(float *)(a3 + 8) = v111;
  if (v23 <= v111)
    v112 = (float)(v111 * 0.99713) + (float)(v23 * 0.0028741);
  else
    v112 = v23 + (float)(v111 * 0.0);
  *(float *)(a3 + 12) = v112;
  if (v22 <= v112)
    v113 = (float)(v112 * 0.99713) + (float)(v22 * 0.0028741);
  else
    v113 = v22 + (float)(v112 * 0.0);
  *(float *)(a3 + 16) = v113;
  if (v21 <= v113)
    v114 = (float)(v113 * 0.99713) + (float)(v21 * 0.0028741);
  else
    v114 = v21 + (float)(v113 * 0.0);
  *(float *)(a3 + 20) = v114;
  if (v20 <= v114)
    v115 = (float)(v114 * 0.99713) + (float)(v20 * 0.0028741);
  else
    v115 = v20 + (float)(v114 * 0.0);
  *(float *)(a3 + 24) = v115;
  if (v19 <= v115)
    v116 = (float)(v115 * 0.99713) + (float)(v19 * 0.0028741);
  else
    v116 = v19 + (float)(v115 * 0.0);
  *(float *)(a3 + 28) = v116;
  if (v18 <= v116)
    v117 = (float)(v116 * 0.99713) + (float)(v18 * 0.0028741);
  else
    v117 = v18 + (float)(v116 * 0.0);
  *(float *)(a3 + 32) = v117;
  if (v17 <= v117)
    v118 = (float)(v117 * 0.99713) + (float)(v17 * 0.0028741);
  else
    v118 = v17 + (float)(v117 * 0.0);
  *(float *)(a3 + 36) = v118;
  if (v16 <= v118)
    v119 = (float)(v118 * 0.99713) + (float)(v16 * 0.0028741);
  else
    v119 = v16 + (float)(v118 * 0.0);
  *(float *)(a3 + 40) = v119;
  if (v15 <= v119)
    v120 = (float)(v119 * 0.99713) + (float)(v15 * 0.0028741);
  else
    v120 = v15 + (float)(v119 * 0.0);
  *(float *)(a3 + 44) = v120;
  if (v14 <= v120)
    v121 = (float)(v120 * 0.99713) + (float)(v14 * 0.0028741);
  else
    v121 = v14 + (float)(v120 * 0.0);
  *(float *)(a3 + 48) = v121;
  if (v13 <= v121)
    v122 = (float)(v121 * 0.99713) + (float)(v13 * 0.0028741);
  else
    v122 = v13 + (float)(v121 * 0.0);
  *(float *)(a3 + 52) = v122;
  v123 = *(float *)(a3 + 56);
  v124 = *(float *)(a3 + 60);
  if (v123 <= v122)
    v125 = (float)(v122 * 0.99713) + (float)(v123 * 0.0028741);
  else
    v125 = v123 + (float)(v122 * 0.0);
  *(float *)(a3 + 56) = v125;
  if (v124 <= v125)
    v126 = (float)(v125 * 0.99713) + (float)(v124 * 0.0028741);
  else
    v126 = v124 + (float)(v125 * 0.0);
  *(float *)(a3 + 60) = v126;
  v127 = *(float *)(a3 + 64);
  v128 = *(float *)(a3 + 68);
  if (v127 <= v126)
    v129 = (float)(v126 * 0.99713) + (float)(v127 * 0.0028741);
  else
    v129 = v127 + (float)(v126 * 0.0);
  *(float *)(a3 + 64) = v129;
  if (v128 <= v129)
    v130 = (float)(v129 * 0.99713) + (float)(v128 * 0.0028741);
  else
    v130 = v128 + (float)(v129 * 0.0);
  *(float *)(a3 + 68) = v130;
  v131 = *(float *)(a3 + 72);
  v132 = *(float *)(a3 + 76);
  if (v131 <= v130)
    v133 = (float)(v130 * 0.99713) + (float)(v131 * 0.0028741);
  else
    v133 = v131 + (float)(v130 * 0.0);
  *(float *)(a3 + 72) = v133;
  if (v132 <= v133)
    v134 = (float)(v133 * 0.99713) + (float)(v132 * 0.0028741);
  else
    v134 = v132 + (float)(v133 * 0.0);
  *(float *)(a3 + 76) = v134;
  *(float *)(result + 8) = v134;
  return result;
}

void webrtc::Flexfec03HeaderReader::~Flexfec03HeaderReader(webrtc::Flexfec03HeaderReader *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::Flexfec03HeaderReader::ReadFecHeader(webrtc::Flexfec03HeaderReader *this, webrtc::ForwardErrorCorrection::ReceivedFecPacket *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  char *v12;
  int v13;
  uint64_t v14;
  unsigned int v16;
  unsigned int v17;
  int v18;
  char v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v2 = (uint64_t *)*((_QWORD *)a2 + 20);
  if ((unint64_t)v2[3] <= 0x12)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      goto LABEL_17;
    return 0;
  }
  v11 = v2[1];
  if (!v11)
  {
    v12 = 0;
    LOBYTE(v13) = MEMORY[0];
    if ((MEMORY[0] & 0x80000000) == 0)
      goto LABEL_6;
LABEL_12:
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
      goto LABEL_17;
    return 0;
  }
  rtc::CopyOnWriteBuffer::UnshareAndEnsureCapacity(v2 + 1, (uint64_t *)(*(_QWORD *)(v11 + 8) - v2[2]));
  v12 = (char *)(*(_QWORD *)(v2[1] + 16) + v2[2]);
  v13 = *v12;
  if (v13 < 0)
    goto LABEL_12;
LABEL_6:
  if ((v13 & 0x40) == 0)
  {
    if (v12[8] == 1)
    {
      if (*(_QWORD *)(*((_QWORD *)a2 + 20) + 24) > 0x13uLL)
      {
        v16 = *((_DWORD *)v12 + 3);
        v17 = *((unsigned __int16 *)v12 + 8);
        v18 = v12[18];
        v19 = 2 * v12[19];
        v12[18] = (unsigned __int16)((2 * v12[19]) | (v12[18] << 9)) >> 8;
        v12[19] = v19;
        if (v18 < 0)
        {
          v22 = 20;
          v23 = 2;
        }
        else
        {
          if (*(_QWORD *)(*((_QWORD *)a2 + 20) + 24) < 0x18uLL)
            return 0;
          v20 = v12[20];
          v12[19] = ((v20 & 0x40) != 0) | v19;
          v21 = 4
              * ((v20 << 24) | (v12[21] << 16) | (v12[22] << 8) | v12[23]);
          *((_DWORD *)v12 + 5) = bswap32(v21);
          if (v20 < 0)
          {
            v22 = 24;
            v23 = 6;
          }
          else
          {
            if (*(_QWORD *)(*((_QWORD *)a2 + 20) + 24) <= 0x1FuLL)
            {
              if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
                return 0;
              goto LABEL_17;
            }
            v24 = v12[24];
            if ((v24 & 0x80000000) == 0)
            {
              if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
                return 0;
              goto LABEL_17;
            }
            v12[23] = (v24 >> 5) & 3 | v21;
            *((_QWORD *)v12 + 3) = bswap64(8* webrtc::ByteReader<unsigned long long,8u,false>::ReadBigEndian((unint64_t *)v12 + 3));
            v22 = 32;
            v23 = 14;
          }
        }
        *((_QWORD *)a2 + 5) = v22;
        LODWORD(v25) = bswap32(v16);
        WORD2(v25) = bswap32(v17) >> 16;
        *((_QWORD *)&v25 + 1) = 18;
        v26 = v23;
        v14 = 1;
        absl::inlined_vector_internal::Storage<webrtc::ForwardErrorCorrection::ProtectedStream,4ul,std::allocator<webrtc::ForwardErrorCorrection::ProtectedStream>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<webrtc::ForwardErrorCorrection::ProtectedStream>,webrtc::ForwardErrorCorrection::ProtectedStream const*>>((unint64_t *)a2 + 6, &v25, 1uLL);
        *((_QWORD *)a2 + 19) = *(_QWORD *)(*((_QWORD *)a2 + 20) + 24) - *((_QWORD *)a2 + 5);
        return v14;
      }
      if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) != 0)
        return 0;
    }
    else if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
    {
      return 0;
    }
LABEL_17:
    rtc::webrtc_logging_impl::Log("\r\t", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/flexfec_03_header_reader_writer.cc");
    return 0;
  }
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) == 0)
    goto LABEL_17;
  return 0;
}

unint64_t webrtc::ByteReader<unsigned long long,8u,false>::ReadBigEndian(unint64_t *a1)
{
  return bswap64(*a1);
}

void webrtc::Flexfec03HeaderWriter::~Flexfec03HeaderWriter(webrtc::Flexfec03HeaderWriter *this)
{
  JUMPOUT(0x20BD0ADECLL);
}

uint64_t webrtc::Flexfec03HeaderWriter::MinPacketMaskSize(webrtc::Flexfec03HeaderWriter *this, const unsigned __int8 *a2, uint64_t a3)
{
  if (a3 == 6)
  {
    if ((a2[5] & 3) == 0)
      return 6;
    return 14;
  }
  if (a3 != 2)
    return 14;
  if ((a2[1] & 1) != 0)
    return 6;
  else
    return 2;
}

uint64_t webrtc::Flexfec03HeaderWriter::FecHeaderSize(webrtc::Flexfec03HeaderWriter *this, unint64_t a2)
{
  uint64_t v2;

  v2 = 32;
  if (a2 < 7)
    v2 = 24;
  if (a2 >= 3)
    return v2;
  else
    return 20;
}

void webrtc::Flexfec03HeaderWriter::FinalizeFecHeader(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  __int16 v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned __int8 v20;
  char v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  std::string *v25;
  __int128 *v26;
  unint64_t v27;

  if (a3 == 1)
  {
    v9 = *a2;
    v10 = *((_WORD *)a2 + 2);
    v11 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
    v12 = *((_QWORD *)a2 + 2);
    v13 = *(_QWORD *)(a4 + 8);
    if (v13)
    {
      rtc::CopyOnWriteBuffer::UnshareAndEnsureCapacity((uint64_t *)(a4 + 8), (uint64_t *)(*(_QWORD *)(v13 + 8) - *(_QWORD *)(a4 + 16)));
      v13 = *(_QWORD *)(*(_QWORD *)(a4 + 8) + 16) + *(_QWORD *)(a4 + 16);
    }
    *(_BYTE *)v13 &= 0x3Fu;
    *(_DWORD *)(v13 + 8) = 1;
    *(_BYTE *)(v13 + 12) = HIBYTE(v9);
    *(_BYTE *)(v13 + 13) = BYTE2(v9);
    *(_BYTE *)(v13 + 14) = BYTE1(v9);
    *(_BYTE *)(v13 + 15) = v9;
    *(_BYTE *)(v13 + 16) = HIBYTE(v10);
    *(_BYTE *)(v13 + 17) = v10;
    if (v12 == 2)
    {
      v22 = *v11;
      v23 = (v11[1] | (v22 << 8)) >> 1;
      v24 = v22 >> 1;
      *(_BYTE *)(v13 + 18) = v24;
      *(_BYTE *)(v13 + 19) = v23;
      if ((v11[1] & 1) != 0)
        *(_DWORD *)(v13 + 20) = 192;
      else
        *(_BYTE *)(v13 + 18) = v24 | 0x80;
    }
    else if (v12 == 6)
    {
      v14 = v11[2];
      v15 = (v11[3] << 16) | (v14 << 24);
      v16 = v11[5] | (v11[4] << 8);
      v17 = (v11[3] << 16) | (v11[4] << 8);
      v18 = (v11[1] | (*v11 << 8)) >> 1;
      *(_BYTE *)(v13 + 18) = *v11 >> 1;
      *(_BYTE *)(v13 + 19) = v18;
      v19 = v14 >> 2;
      *(_BYTE *)(v13 + 20) = v14 >> 2;
      *(_BYTE *)(v13 + 21) = v15 >> 18;
      *(_BYTE *)(v13 + 22) = v17 >> 10;
      *(_BYTE *)(v13 + 23) = v16 >> 2;
      if ((v11[1] & 1) != 0)
      {
        LOBYTE(v19) = v19 | 0x40;
        *(_BYTE *)(v13 + 20) = v19;
      }
      v20 = v11[5];
      if ((v20 & 3) != 0)
      {
        *(_QWORD *)(v13 + 24) = 0;
        if ((v20 & 2) != 0)
          v21 = -64;
        else
          v21 = 0x80;
        *(_BYTE *)(v13 + 24) = v21;
        if ((v20 & 1) != 0)
          *(_BYTE *)(v13 + 24) = v21 | 0x20;
      }
      else
      {
        *(_BYTE *)(v13 + 20) = v19 | 0x80;
      }
    }
  }
  else
  {
    v25 = rtc::webrtc_checks_impl::FatalLog("/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/modules/rtp_rtcp/source/flexfec_03_header_reader_writer.cc", 251, "protected_streams.size() == 1", rtc::webrtc_checks_impl::LogStreamer<>::CallCheckOp<rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int>>(char const*,int,char const*,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)5,unsigned long>,rtc::webrtc_checks_impl::Val<(rtc::webrtc_checks_impl::CheckArgType)1,int> const&)::t, a5, a6, a7, a8, a3);
    absl::inlined_vector_internal::Storage<webrtc::ForwardErrorCorrection::ProtectedStream,4ul,std::allocator<webrtc::ForwardErrorCorrection::ProtectedStream>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<webrtc::ForwardErrorCorrection::ProtectedStream>,webrtc::ForwardErrorCorrection::ProtectedStream const*>>((unint64_t *)v25, v26, v27);
  }
}

void absl::inlined_vector_internal::Storage<webrtc::ForwardErrorCorrection::ProtectedStream,4ul,std::allocator<webrtc::ForwardErrorCorrection::ProtectedStream>>::Assign<absl::inlined_vector_internal::IteratorValueAdapter<std::allocator<webrtc::ForwardErrorCorrection::ProtectedStream>,webrtc::ForwardErrorCorrection::ProtectedStream const*>>(unint64_t *a1, __int128 *a2, unint64_t a3)
{
  unint64_t v6;
  void **v7;
  unint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  __int128 v15;
  _QWORD *v16;
  unint64_t v17;
  _QWORD *v18;
  __int128 v19;
  unint64_t v20;

  v7 = (void **)(a1 + 1);
  v6 = *a1;
  if ((*a1 & 1) != 0)
  {
    v9 = (_QWORD *)a1[1];
    v8 = a1[2];
    if (v8 >= a3)
      goto LABEL_3;
  }
  else
  {
    v8 = 4;
    v9 = a1 + 1;
    if (a3 <= 4)
    {
LABEL_3:
      v10 = v6 >> 1;
      v11 = a3 >= v6 >> 1;
      v12 = a3 - (v6 >> 1);
      if (!v11)
        v12 = 0;
      if (v10 >= a3)
        v13 = a3;
      else
        v13 = v10;
      if (v13)
      {
        v14 = v9;
        do
        {
          v15 = *a2;
          v14[2] = *((_QWORD *)a2 + 2);
          *(_OWORD *)v14 = v15;
          v14 += 3;
          a2 = (__int128 *)((char *)a2 + 24);
          --v13;
        }
        while (v13);
      }
      if (v10 >= a3)
      {
        v20 = *a1;
        goto LABEL_26;
      }
      if (v9)
      {
        v16 = 0;
        v17 = 0;
        v18 = &v9[3 * v10];
        goto LABEL_20;
      }
      __break(1u);
LABEL_28:
      std::__throw_bad_array_new_length[abi:sn180100]();
    }
  }
  if (2 * v8 <= a3)
    v17 = a3;
  else
    v17 = 2 * v8;
  if (v17 >= 0xAAAAAAAAAAAAAABLL)
    goto LABEL_28;
  v16 = operator new(24 * v17);
  v18 = v16;
  v12 = a3;
  do
  {
LABEL_20:
    v19 = *a2;
    v18[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)v18 = v19;
    v18 += 3;
    a2 = (__int128 *)((char *)a2 + 24);
    --v12;
  }
  while (v12);
  v20 = *a1;
  if (v16)
  {
    if ((v20 & 1) != 0)
      operator delete(*v7);
    a1[1] = (unint64_t)v16;
    a1[2] = v17;
    LOBYTE(v20) = 1;
  }
LABEL_26:
  *a1 = v20 & 1 | (2 * a3);
}

uint64_t webrtc::FlexfecReceiveStreamImpl::FlexfecReceiveStreamImpl(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, unint64_t a5)
{
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  int v24;
  _QWORD *v25;
  unint64_t v26;
  size_t v27;
  size_t v28;
  size_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  size_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  size_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  pthread_mutex_t *v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v64;
  int *v65;
  void *v66[2];
  unint64_t v67;
  char *__s;
  __int128 v69;
  _QWORD v70[3];
  _QWORD *v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  _BYTE v79[29];
  uint64_t v80;
  _QWORD v81[3];
  int v82;
  char v83;
  char v84;
  __int16 v85;
  void *__p;
  uint64_t v87;
  uint64_t v88;
  char v89;
  uint64_t v90;

  v90 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = &off_24C0B4320;
  *(_QWORD *)(a1 + 8) = &unk_24C0B4368;
  v9 = a3[1];
  *(_DWORD *)(a1 + 16) = v9;
  v10 = *a3;
  *(_DWORD *)(a1 + 20) = *a3;
  if (v10 < 0)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      goto LABEL_12;
    goto LABEL_13;
  }
  if (!v9)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      goto LABEL_12;
    goto LABEL_13;
  }
  v11 = *((_QWORD *)a3 + 2);
  v12 = *((_QWORD *)a3 + 3);
  if (v11 == v12)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
LABEL_12:
      rtc::webrtc_logging_impl::Log("\r\t", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/call/flexfec_receive_stream_impl.cc");
LABEL_13:
    v20 = 0;
    goto LABEL_14;
  }
  if ((unint64_t)(v12 - v11) >= 5)
  {
    if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)2>() & 1) == 0)
      goto LABEL_12;
    goto LABEL_13;
  }
  v64 = operator new();
  v65 = (int *)*((_QWORD *)a3 + 2);
  if (*((int **)a3 + 3) == v65)
    goto LABEL_75;
  webrtc::FlexfecReceiver::FlexfecReceiver(v64, a2, a3[1], *v65, a4);
LABEL_14:
  *(_QWORD *)(a1 + 24) = v20;
  v21 = operator new();
  v70[0] = &off_24C0BB148;
  v71 = v70;
  webrtc::ReceiveStatisticsLocked::ReceiveStatisticsLocked(v21, a2, v70);
  v22 = v71;
  if (v71 == v70)
  {
    v23 = 4;
    v22 = v70;
  }
  else
  {
    if (!v71)
      goto LABEL_19;
    v23 = 5;
  }
  (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_19:
  *(_QWORD *)(a1 + 32) = v21;
  v24 = a3[2];
  v25 = (_QWORD *)*((_QWORD *)a3 + 6);
  v81[2] = 0;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v72 = 0u;
  v73 = 0u;
  v74 = 0u;
  v76 = 0u;
  v77 = 0u;
  v78 = 0u;
  memset(v79, 0, sizeof(v79));
  v80 = 0;
  v81[0] = 0;
  *(_DWORD *)((char *)v81 + 7) = 0;
  v87 = 0;
  v88 = 0;
  __p = 0;
  v89 = 0;
  LOWORD(v70[0]) = 256;
  v70[1] = a2;
  v70[2] = v21;
  v71 = v25;
  v75 = a5;
  v82 = v24;
  v26 = operator new();
  *(_QWORD *)(a1 + 40) = webrtc::ModuleRtpRtcpImpl2::ModuleRtpRtcpImpl2(v26, (uint64_t)v70);
  if (SHIBYTE(v88) < 0)
    operator delete(__p);
  if (v80)
    (*(void (**)(uint64_t))(*(_QWORD *)v80 + 8))(v80);
  *(_QWORD *)(a1 + 48) = 0;
  if ((rtc::LogMessage::IsNoop<(rtc::LoggingSeverity)1>() & 1) != 0)
  {
LABEL_59:
    v55 = *(_QWORD *)(a1 + 40);
    v56 = a3[10];
    v57 = (pthread_mutex_t *)(v55 + 128);
    pthread_mutex_lock((pthread_mutex_t *)(v55 + 128));
    if (v56)
      goto LABEL_60;
    goto LABEL_70;
  }
  __s = (char *)v70;
  strcpy((char *)v70, "{payload_type: ");
  v69 = xmmword_208F09F90;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%d", *a3);
  if ((_QWORD)v69 + ~*((_QWORD *)&v69 + 1) >= 0xFuLL)
    v27 = 15;
  else
    v27 = v69 + ~*((_QWORD *)&v69 + 1);
  memcpy(&__s[*((_QWORD *)&v69 + 1)], ", remote_ssrc: ", v27);
  *((_QWORD *)&v69 + 1) += v27;
  __s[*((_QWORD *)&v69 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", a3[1]);
  if ((_QWORD)v69 + ~*((_QWORD *)&v69 + 1) >= 0xEuLL)
    v28 = 14;
  else
    v28 = v69 + ~*((_QWORD *)&v69 + 1);
  memcpy(&__s[*((_QWORD *)&v69 + 1)], ", local_ssrc: ", v28);
  *((_QWORD *)&v69 + 1) += v28;
  __s[*((_QWORD *)&v69 + 1)] = 0;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", a3[2]);
  if ((_QWORD)v69 + ~*((_QWORD *)&v69 + 1) >= 0x1AuLL)
    v29 = 26;
  else
    v29 = v69 + ~*((_QWORD *)&v69 + 1);
  memcpy(&__s[*((_QWORD *)&v69 + 1)], ", protected_media_ssrcs: [", v29);
  *((_QWORD *)&v69 + 1) += v29;
  __s[*((_QWORD *)&v69 + 1)] = 0;
  v30 = *((_QWORD *)a3 + 2);
  v31 = *((_QWORD *)a3 + 3);
  v32 = (v31 - v30) >> 2;
  if ((unint64_t)(v31 - v30) < 5)
  {
    v36 = 0;
    if (v30 == v31)
      goto LABEL_45;
  }
  else
  {
    v33 = 0;
    do
    {
      if (v32 <= v33)
        goto LABEL_75;
      rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *(_DWORD *)(v30 + 4 * v33));
      if ((_QWORD)v69 + ~*((_QWORD *)&v69 + 1) >= 2uLL)
        v34 = 2;
      else
        v34 = v69 + ~*((_QWORD *)&v69 + 1);
      memcpy(&__s[*((_QWORD *)&v69 + 1)], ", ", v34);
      *((_QWORD *)&v69 + 1) += v34;
      __s[*((_QWORD *)&v69 + 1)] = 0;
      v30 = *((_QWORD *)a3 + 2);
      v35 = *((_QWORD *)a3 + 3);
      v32 = (v35 - v30) >> 2;
      v36 = v33 + 1;
      v37 = v33 + 2;
      ++v33;
    }
    while (v37 < v32);
    if (v30 == v35)
      goto LABEL_45;
  }
  if (v32 <= v36)
    goto LABEL_75;
  rtc::SimpleStringBuilder::AppendFormat((rtc::SimpleStringBuilder *)&__s, "%u", *(_DWORD *)(v30 + 4 * v36));
LABEL_45:
  v38 = v69;
  v39 = *((_QWORD *)&v69 + 1) + 1;
  memcpy(&__s[*((_QWORD *)&v69 + 1)], "}", v69 != *((_QWORD *)&v69 + 1) + 1);
  v40 = *((_QWORD *)&v69 + 1);
  if (v38 != v39)
    v40 = *((_QWORD *)&v69 + 1) + 1;
  *((_QWORD *)&v69 + 1) = v40;
  __s[v40] = 0;
  v41 = __s;
  if (!__s)
    goto LABEL_75;
  v42 = strlen(__s);
  if (v42 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v50 = (char *)v42;
  if (v42 <= 0x16)
  {
    HIBYTE(v67) = v42;
    v51 = (char *)v66;
    v52 = (char *)v66 + (_QWORD)v50;
    if (v66 > (void **)__s)
      goto LABEL_56;
    goto LABEL_55;
  }
  v53 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v42 | 7) != 0x17)
    v53 = v42 | 7;
  v54 = v53 + 1;
  v51 = (char *)operator new(v53 + 1);
  v66[1] = v50;
  v67 = v54 | 0x8000000000000000;
  v66[0] = v51;
  v52 = &v50[(_QWORD)v51];
  if (v51 <= v41)
  {
LABEL_55:
    if (v52 <= v41)
      goto LABEL_56;
LABEL_75:
    __break(1u);
  }
LABEL_56:
  if (v50)
    memmove(v51, v41, (size_t)v50);
  *v52 = 0;
  rtc::webrtc_logging_impl::Log(rtc::webrtc_logging_impl::LogStreamer<>::Call<rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*>>(rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)13,rtc::webrtc_logging_impl::LogMetadata>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)9,char const*>,rtc::webrtc_logging_impl::Val<(rtc::webrtc_logging_impl::LogArgType)10,std::string const*> const&)::t, v43, v44, v45, v46, v47, v48, v49, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/webrtc/call/flexfec_receive_stream_impl.cc");
  if ((SHIBYTE(v67) & 0x80000000) == 0)
    goto LABEL_59;
  operator delete(v66[0]);
  v55 = *(_QWORD *)(a1 + 40);
  v56 = a3[10];
  v57 = (pthread_mutex_t *)(v55 + 128);
  pthread_mutex_lock((pthread_mutex_t *)(v55 + 128));
  if (v56)
  {
LABEL_60:
    if (!*(_DWORD *)(v55 + 64))
    {
      v58 = *(_QWORD *)(v55 + 88) / 2;
      v59 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v55 + 48) + 16))(*(_QWORD *)(v55 + 48));
      v60 = v59 + v58;
      if (v59 == 0x8000000000000000)
        v60 = 0x8000000000000000;
      if (v59 == 0x7FFFFFFFFFFFFFFFLL)
        v60 = 0x7FFFFFFFFFFFFFFFLL;
      if (!*(_BYTE *)(v55 + 208))
        *(_BYTE *)(v55 + 208) = 1;
      *(_QWORD *)(v55 + 200) = v60;
      v61 = *(_QWORD *)(v55 + 120);
      if (v61)
      {
        v70[0] = v58;
        (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v61 + 48))(v61, v70);
      }
    }
    goto LABEL_72;
  }
LABEL_70:
  if (*(_BYTE *)(v55 + 208))
    *(_BYTE *)(v55 + 208) = 0;
LABEL_72:
  *(_DWORD *)(v55 + 64) = v56;
  pthread_mutex_unlock(v57);
  return a1;
}

void webrtc::FlexfecReceiveStreamImpl::~FlexfecReceiveStreamImpl(webrtc::FlexfecReceiveStreamImpl *this)
{
  uint64_t v2;
  webrtc::ModuleRtpRtcpImpl2 *v3;
  uint64_t v4;
  webrtc::FlexfecReceiver *v5;

  *(_QWORD *)this = &off_24C0B4320;
  *((_QWORD *)this + 1) = &unk_24C0B4368;
  v2 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (webrtc::ModuleRtpRtcpImpl2 *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v3)
  {
    webrtc::ModuleRtpRtcpImpl2::~ModuleRtpRtcpImpl2(v3);
    MEMORY[0x20BD0ADEC]();
  }
  v4 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = (webrtc::FlexfecReceiver *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v5)
  {
    webrtc::FlexfecReceiver::~FlexfecReceiver(v5);
    MEMORY[0x20BD0ADEC]();
  }
}

{
  uint64_t v2;
  webrtc::ModuleRtpRtcpImpl2 *v3;
  uint64_t v4;
  webrtc::FlexfecReceiver *v5;

  *(_QWORD *)this = &off_24C0B4320;
  *((_QWORD *)this + 1) = &unk_24C0B4368;
  v2 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (webrtc::ModuleRtpRtcpImpl2 *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v3)
  {
    webrtc::ModuleRtpRtcpImpl2::~ModuleRtpRtcpImpl2(v3);
    MEMORY[0x20BD0ADEC]();
  }
  v4 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = (webrtc::FlexfecReceiver *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v5)
  {
    webrtc::FlexfecReceiver::~FlexfecReceiver(v5);
    MEMORY[0x20BD0ADEC]();
  }
  JUMPOUT(0x20BD0ADECLL);
}

void `non-virtual thunk to'webrtc::FlexfecReceiveStreamImpl::~FlexfecReceiveStreamImpl(webrtc::FlexfecReceiveStreamImpl *this)
{
  uint64_t v2;
  webrtc::ModuleRtpRtcpImpl2 *v3;
  uint64_t v4;
  webrtc::FlexfecReceiver *v5;

  *((_QWORD *)this - 1) = &off_24C0B4320;
  *(_QWORD *)this = &unk_24C0B4368;
  v2 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (webrtc::ModuleRtpRtcpImpl2 *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v3)
  {
    webrtc::ModuleRtpRtcpImpl2::~ModuleRtpRtcpImpl2(v3);
    MEMORY[0x20BD0ADEC]();
  }
  v4 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = (webrtc::FlexfecReceiver *)*((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v5)
  {
    webrtc::FlexfecReceiver::~FlexfecReceiver(v5);
    MEMORY[0x20BD0ADEC]();
  }
}

{
  webrtc::FlexfecReceiveStreamImpl::~FlexfecReceiveStreamImpl((webrtc::FlexfecReceiveStreamImpl *)((char *)this - 8));
}

void webrtc::FlexfecReceiveStreamImpl::OnRtpPacket(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    if (!*(_BYTE *)(a2 + 128))
    {
      webrtc::FlexfecReceiver::AddReceivedPacket(*(_QWORD *)(a1 + 24), a2, &v7);
      v5 = v7;
      if (v7)
      {
        webrtc::FlexfecReceiver::ProcessReceivedPacket(v2, v7);
        v6 = *(_QWORD *)(v5 + 32);
        if (v6)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
        MEMORY[0x20BD0ADEC](v5, 0x1020C40615C549ELL);
      }
    }
    if (*(_DWORD *)(a2 + 12) == *(_DWORD *)(a1 + 16))
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 16))(*(_QWORD *)(a1 + 32) + 8, a2);
  }
}

uint64_t webrtc::FlexfecReceiveStreamImpl::SetPayloadType(uint64_t this, int a2)
{
  *(_DWORD *)(this + 20) = a2;
  return this;
}

uint64_t webrtc::FlexfecReceiveStreamImpl::payload_type(webrtc::FlexfecReceiveStreamImpl *this)
{
  return *((unsigned int *)this + 5);
}

uint64_t webrtc::FlexfecReceiveStreamImpl::SetRtcpMode(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v3 = *(_QWORD *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 128));
  if (a2)
  {
    if (!*(_DWORD *)(v3 + 64))
    {
      v4 = *(_QWORD *)(v3 + 88) / 2;
      v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 48) + 16))(*(_QWORD *)(v3 + 48));
      v6 = v5 + v4;
      if (v5 == 0x8000000000000000)
        v6 = 0x8000000000000000;
      if (v5 == 0x7FFFFFFFFFFFFFFFLL)
        v6 = 0x7FFFFFFFFFFFFFFFLL;
      if (!*(_BYTE *)(v3 + 208))
        *(_BYTE *)(v3 + 208) = 1;
      *(_QWORD *)(v3 + 200) = v6;
      v7 = *(_QWORD *)(v3 + 120);
      if (v7)
      {
        v9 = v4;
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v7 + 48))(v7, &v9);
      }
    }
  }
  else if (*(_BYTE *)(v3 + 208))
  {
    *(_BYTE *)(v3 + 208) = 0;
  }
  *(_DWORD *)(v3 + 64) = a2;
  return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 128));
}

uint64_t webrtc::FlexfecReceiveStreamImpl::GetStats(webrtc::FlexfecReceiveStreamImpl *this)
{
  return *((_QWORD *)this + 4);
}

double webrtc::FlexfecReceiver::FlexfecReceiver(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  double result;

  *(_DWORD *)a1 = a3;
  *(_DWORD *)(a1 + 4) = a4;
  v10 = operator new();
  *(_OWORD *)(v10 + 8) = xmmword_208F09F80;
  *(_QWORD *)v10 = &unk_24C0B42C0;
  v11 = operator new();
  *(int64x2_t *)(v11 + 8) = vdupq_n_s64(0x30uLL);
  *(_QWORD *)(v11 + 24) = 32;
  *(_QWORD *)v11 = &unk_24C0B42E8;
  v12 = operator new();
  *(_DWORD *)v12 = a3;
  *(_DWORD *)(v12 + 4) = a4;
  *(_QWORD *)(v12 + 8) = v10;
  *(_QWORD *)(v12 + 16) = v11;
  v13 = operator new(0x780uLL);
  *v13 = &off_24C0B43E8;
  v13[1] = 0;
  v13[2] = 0;
  v13[3] = 0;
  *((_DWORD *)v13 + 8) = 0;
  v13[5] = &off_24C0B43E8;
  v13[6] = 0;
  v13[7] = 0;
  v13[8] = 0;
  *((_DWORD *)v13 + 18) = 0;
  v13[10] = &off_24C0B43E8;
  v13[11] = 0;
  v13[12] = 0;
  v13[13] = 0;
  *((_DWORD *)v13 + 28) = 0;
  v13[15] = &off_24C0B43E8;
  v13[16] = 0;
  *((_DWORD *)v13 + 38) = 0;
  v13[17] = 0;
  v13[18] = 0;
  v13[20] = &off_24C0B43E8;
  v13[21] = 0;
  *((_DWORD *)v13 + 48) = 0;
  v13[22] = 0;
  v13[23] = 0;
  v13[25] = &off_24C0B43E8;
  v13[26] = 0;
  *((_DWORD *)v13 + 58) = 0;
  v13[27] = 0;
  v13[28] = 0;
  v13[30] = &off_24C0B43E8;
  v13[31] = 0;
  *((_DWORD *)v13 + 68) = 0;
  v13[32] = 0;
  v13[33] = 0;
  v13[35] = &off_24C0B43E8;
  v13[36] = 0;
  *((_DWORD *)v13 + 78) = 0;
  v13[37] = 0;
  v13[38] = 0;
  v13[40] = &off_24C0B43E8;
  v13[41] = 0;
  *((_DWORD *)v13 + 88) = 0;
  v13[42] = 0;
  v13[43] = 0;
  v13[45] = &off_24C0B43E8;
  v13[46] = 0;
  *((_DWORD *)v13 + 98) = 0;
  v13[47] = 0;
  v13[48] = 0;
  v13[50] = &off_24C0B43E8;
  v13[51] = 0;
  *((_DWORD *)v13 + 108) = 0;
  v13[52] = 0;
  v13[53] = 0;
  v13[55] = &off_24C0B43E8;
  v13[56] = 0;
  *((_DWORD *)v13 + 118) = 0;
  v13[57] = 0;
  v13[58] = 0;
  v13[60] = &off_24C0B43E8;
  v13[61] = 0;
  *((_DWORD *)v13 + 128) = 0;
  v13[62] = 0;
  v13[63] = 0;
  v13[65] = &off_24C0B43E8;
  v13[67] = 0;
  v13[66] = 0;
  *((_DWORD *)v13 + 138) = 0;
  v13[68] = 0;
  v13[70] = &off_24C0B43E8;
  v13[72] = 0;
  v13[71] = 0;
  *((_DWORD *)v13 + 148) = 0;
  v13[73] = 0;
  v13[75] = &off_24C0B43E8;
  v13[77] = 0;
  v13[76] = 0;
  *((_DWORD *)v13 + 158) = 0;
  v13[78] = 0;
  v13[80] = &off_24C0B43E8;
  v13[82] = 0;
  v13[81] = 0;
  *((_DWORD *)v13 + 168) = 0;
  v13[83] = 0;
  v13[85] = &off_24C0B43E8;
  v13[87] = 0;
  v13[86] = 0;
  *((_DWORD *)v13 + 178) = 0;
  v13[88] = 0;
  v13[90] = &off_24C0B43E8;
  v13[92] = 0;
  v13[91] = 0;
  *((_DWORD *)v13 + 188) = 0;
  v13[93] = 0;
  v13[95] = &off_24C0B43E8;
  v13[97] = 0;
  v13[96] = 0;
  *((_DWORD *)v13 + 198) = 0;
  v13[98] = 0;
  v13[100] = &off_24C0B43E8;
  v13[102] = 0;
  v13[101] = 0;
  *((_DWORD *)v13 + 208) = 0;
  v13[103] = 0;
  v13[105] = &off_24C0B43E8;
  v13[107] = 0;
  v13[106] = 0;
  *((_DWORD *)v13 + 218) = 0;
  v13[108] = 0;
  v13[110] = &off_24C0B43E8;
  v13[112] = 0;
  v13[111] = 0;
  *((_DWORD *)v13 + 228) = 0;
  v13[113] = 0;
  v13[115] = &off_24C0B43E8;
  v13[117] = 0;
  v13[116] = 0;
  *((_DWORD *)v13 + 238) = 0;
  v13[118] = 0;
  v13[120] = &off_24C0B43E8;
  v13[122] = 0;
  v13[121] = 0;
  *((_DWORD *)v13 + 248) = 0;
  v13[123] = 0;
  v13[125] = &off_24C0B43E8;
  v13[127] = 0;
  v13[126] = 0;
  *((_DWORD *)v13 + 258) = 0;
  v13[128] = 0;
  v13[130] = &off_24C0B43E8;
  v13[132] = 0;
  v13[131] = 0;
  *((_DWORD *)v13 + 268) = 0;
  v13[133] = 0;
  v13[135] = &off_24C0B43E8;
  v13[137] = 0;
  v13[136] = 0;
  *((_DWORD *)v13 + 278) = 0;
  v13[138] = 0;
  v13[140] = &off_24C0B43E8;
  v13[142] = 0;
  v13[141] = 0;
  *((_DWORD *)v13 + 288) = 0;
  v13[143] = 0;
  v13[145] = &off_24C0B43E8;
  v13[147] = 0;
  v13[146] = 0;
  *((_DWORD *)v13 + 298) = 0;
  v13[148] = 0;
  v13[150] = &off_24C0B43E8;
  v13[152] = 0;
  v13[151] = 0;
  *((_DWORD *)v13 + 308) = 0;
  v13[153] = 0;
  v13[155] = &off_24C0B43E8;
  v13[157] = 0;
  v13[156] = 0;
  *((_DWORD *)v13 + 318) = 0;
  v13[158] = 0;
  v13[160] = &off_24C0B43E8;
  v13[162] = 0;
  v13[161] = 0;
  *((_DWORD *)v13 + 328) = 0;
  v13[163] = 0;
  v13[165] = &off_24C0B43E8;
  v13[167] = 0;
  v13[166] = 0;
  *((_DWORD *)v13 + 338) = 0;
  v13[168] = 0;
  v13[170] = &off_24C0B43E8;
  v13[172] = 0;
  v13[171] = 0;
  *((_DWORD *)v13 + 348) = 0;
  v13[173] = 0;
  v13[175] = &off_24C0B43E8;
  v13[177] = 0;
  v13[176] = 0;
  *((_DWORD *)v13 + 358) = 0;
  v13[178] = 0;
  v13[180] = &off_24C0B43E8;
  v13[182] = 0;
  v13[181] = 0;
  *((_DWORD *)v13 + 368) = 0;
  v13[183] = 0;
  v13[185] = &off_24C0B43E8;
  v13[187] = 0;
  v13[186] = 0;
  *((_DWORD *)v13 + 378) = 0;
  v13[188] = 0;
  v13[190] = &off_24C0B43E8;
  v13[192] = 0;
  v13[191] = 0;
  *((_DWORD *)v13 + 388) = 0;
  v13[193] = 0;
  v13[195] = &off_24C0B43E8;
  v13[197] = 0;
  v13[196] = 0;
  *((_DWORD *)v13 + 398) = 0;
  v13[198] = 0;
  v13[200] = &off_24C0B43E8;
  v13[202] = 0;
  v13[201] = 0;
  *((_DWORD *)v13 + 408) = 0;
  v13[203] = 0;
  v13[205] = &off_24C0B43E8;
  v13[207] = 0;
  v13[206] = 0;
  *((_DWORD *)v13 + 418) = 0;
  v13[208] = 0;
  v13[210] = &off_24C0B43E8;
  v13[212] = 0;
  v13[211] = 0;
  *((_DWORD *)v13 + 428) = 0;
  v13[213] = 0;
  v13[215] = &off_24C0B43E8;
  v13[217] = 0;
  v13[216] = 0;
  *((_DWORD *)v13 + 438) = 0;
  v13[218] = 0;
  v13[220] = &off_24C0B43E8;
  v13[222] = 0;
  v13[221] = 0;
  *((_DWORD *)v13 + 448) = 0;
  v13[223] = 0;
  v13[225] = &off_24C0B43E8;
  v13[227] = 0;
  v13[226] = 0;
  *((_DWORD *)v13 + 458) = 0;
  v13[228] = 0;
  v13[230] = &off_24C0B43E8;
  v13[232] = 0;
  v13[231] = 0;
  *((_DWORD *)v13 + 468) = 0;
  v13[233] = 0;
  v13[235] = &off_24C0B43E8;
  v13[237] = 0;
  v13[236] = 0;
  *((_DWORD *)v13 + 478) = 0;
  v13[238] = 0;
  *(_QWORD *)(v12 + 24) = v13;
  *(_QWORD *)(v12 + 32) = v13 + 240;
  *(_QWORD *)(v12 + 40) = v13 + 240;
  *(_QWORD *)(v12 + 48) = v12 + 48;
  *(_QWORD *)(v12 + 56) = v12 + 48;
  *(_QWORD *)(v12 + 64) = 0;
  *(_QWORD *)(v12 + 648) = 0;
  *(_QWORD *)(a1 + 8) = v12;
  *(_QWORD *)(a1 + 16) = a1 + 16;
  *(_QWORD *)(a1 + 24) = a1 + 16;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = a5;
  *(_QWORD *)(a1 + 48) = a2;
  *(_QWORD *)(a1 + 56) = 0x8000000000000000;
  result = 0.0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 96) = 0x8000000000000000;
  return result;
}

void webrtc::FlexfecReceiver::~FlexfecReceiver(webrtc::FlexfecReceiver *this)
{
  char *v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  webrtc::ForwardErrorCorrection *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;

  if (*((_QWORD *)this + 4))
  {
    v2 = (char *)this + 16;
    v3 = *((_QWORD *)this + 2);
    v4 = (char *)*((_QWORD *)this + 3);
    v5 = *(_QWORD *)v4;
    *(_QWORD *)(v5 + 8) = *(_QWORD *)(v3 + 8);
    **(_QWORD **)(v3 + 8) = v5;
    *((_QWORD *)this + 4) = 0;
    if (v4 != (char *)this + 16)
    {
      do
      {
        v8 = (char *)*((_QWORD *)v4 + 1);
        v7 = *((_QWORD *)v4 + 2);
        *((_QWORD *)v4 + 2) = 0;
        if (v7)
        {
          v9 = *(_QWORD *)(v7 + 16);
          if (v9)
            (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
          MEMORY[0x20BD0ADEC](v7, 0x1020C407D5D75B9);
        }
        operator delete(v4);
        v4 = v8;
      }
      while (v8 != v2);
    }
  }
  v6 = (webrtc::ForwardErrorCorrection *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v6)
  {
    webrtc::ForwardErrorCorrection::~ForwardErrorCorrection(v6);
    MEMORY[0x20BD0ADEC]();
  }
}

