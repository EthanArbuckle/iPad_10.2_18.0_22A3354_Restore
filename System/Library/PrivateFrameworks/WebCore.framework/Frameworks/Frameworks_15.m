uint64_t X509_check_akid(_QWORD *a1, uint64_t a2)
{
  ASN1_STRING *v4;
  ASN1_STRING *v5;
  ASN1_STRING *v7;
  ASN1_STRING *v8;
  int v9;
  int v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  const X509_NAME *v14;

  if (!a2)
    return 0;
  v4 = *(ASN1_STRING **)a2;
  if (*(_QWORD *)a2)
  {
    v5 = (ASN1_STRING *)a1[8];
    if (v5)
    {
      if (ASN1_STRING_cmp(v4, v5))
        return 30;
    }
  }
  v7 = *(ASN1_STRING **)(a2 + 16);
  if (v7)
  {
    v8 = *(ASN1_STRING **)(*a1 + 8);
    v9 = v8->type & 0x100;
    if (v9 == (v7->type & 0x100))
    {
      v10 = ASN1_STRING_cmp(v8, v7);
      if (v9)
      {
        if (v10 < 0)
          return 31;
        if (v10)
          v10 = -1;
        else
          v10 = 0;
      }
      if (!v10)
        goto LABEL_14;
    }
    return 31;
  }
LABEL_14:
  v11 = *(_QWORD **)(a2 + 8);
  if (v11)
  {
    v12 = 0;
    while (*v11 != v12)
    {
      v13 = *(_QWORD *)(v11[1] + 8 * v12++);
      if (*(_DWORD *)v13 == 4)
      {
        v14 = *(const X509_NAME **)(v13 + 8);
        if (!v14 || !X509_NAME_cmp(v14, *(const X509_NAME **)(*a1 + 24)))
          return 0;
        return 31;
      }
    }
  }
  return 0;
}

BOOL check_purpose_ssl_client(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  _BOOL8 result;

  v3 = *(_DWORD *)(a2 + 48);
  if ((v3 & 4) != 0 && (*(_BYTE *)(a2 + 56) & 2) == 0)
    return 0;
  result = 1;
  if (!a3 && (v3 & 2) != 0)
    return (*(_BYTE *)(a2 + 52) & 0x88) != 0;
  return result;
}

BOOL check_purpose_ssl_server(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  _BOOL8 result;

  v3 = *(_DWORD *)(a2 + 48);
  if ((v3 & 4) != 0 && (*(_BYTE *)(a2 + 56) & 1) == 0)
    return 0;
  result = 1;
  if (!a3 && (v3 & 2) != 0)
    return (*(_BYTE *)(a2 + 52) & 0xA8) != 0;
  return result;
}

uint64_t check_purpose_ns_ssl_server(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  uint64_t result;

  v3 = *(_DWORD *)(a2 + 48);
  if ((v3 & 4) != 0 && (*(_BYTE *)(a2 + 56) & 1) == 0)
    return 0;
  result = 1;
  if (!a3 && (v3 & 2) != 0)
    return (*(_DWORD *)(a2 + 52) >> 5) & 1;
  return result;
}

BOOL check_purpose_smime_sign(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  _BOOL8 result;

  v3 = *(_DWORD *)(a2 + 48);
  if ((v3 & 4) != 0 && (*(_BYTE *)(a2 + 56) & 4) == 0)
    return 0;
  result = 1;
  if (!a3 && (v3 & 2) != 0)
    return (*(_BYTE *)(a2 + 52) & 0xC0) != 0;
  return result;
}

uint64_t check_purpose_smime_encrypt(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  uint64_t result;

  v3 = *(_DWORD *)(a2 + 48);
  if ((v3 & 4) != 0 && (*(_BYTE *)(a2 + 56) & 4) == 0)
    return 0;
  result = 1;
  if (!a3 && (v3 & 2) != 0)
    return (*(_DWORD *)(a2 + 52) >> 5) & 1;
  return result;
}

uint64_t check_purpose_crl_sign(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3 && (*(_BYTE *)(a2 + 48) & 2) != 0)
    return (*(_DWORD *)(a2 + 52) >> 1) & 1;
  else
    return 1;
}

uint64_t no_check()
{
  return 1;
}

uint64_t check_purpose_timestamp_sign(uint64_t a1, _DWORD *a2, int a3)
{
  uint64_t result;
  int v4;
  unint64_t *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;

  if (a3)
    return 1;
  v4 = a2[12];
  if ((v4 & 2) == 0)
  {
    if ((v4 & 4) == 0)
      return 0;
    goto LABEL_12;
  }
  result = 0;
  if ((v4 & 4) != 0 && (a2[13] & 0xFFFFFF3F) == 0 && (a2[13] & 0xC0) != 0)
  {
LABEL_12:
    if (a2[14] == 64)
    {
      v6 = *(unint64_t **)(*(_QWORD *)a2 + 72);
      if (v6)
      {
        v7 = 0;
        while (((int)*v6 & (unint64_t)~((uint64_t)(int)*v6 >> 63)) != v7)
        {
          v9 = v7;
          v10 = v6[1];
          v11 = **(_QWORD **)(v10 + 8 * v7);
          if (*(_DWORD *)(v11 + 20) == 3)
          {
            v12 = *(unsigned __int16 **)(v11 + 24);
            v13 = bswap32(*v12) >> 16;
            v14 = bswap32(0x1D55u) >> 16;
            if (v13 == v14)
            {
              v8 = *((unsigned __int8 *)v12 + 2) - 37;
            }
            else if (v13 < v14)
            {
              v8 = -1;
            }
            else
            {
              v8 = 1;
            }
          }
          else
          {
            v8 = -1;
          }
          v7 = v9 + 1;
          if (!v8)
          {
            if ((v9 & 0x80000000) != 0)
              return 1;
            if (*v6 > v9)
            {
              v15 = *(_QWORD *)(v10 + 8 * v7 - 8);
              if (v15)
              {
                if (*(int *)(v15 + 8) >= 1)
                  return 1;
              }
            }
            return 0;
          }
        }
      }
      return 1;
    }
    return 0;
  }
  return result;
}

void *i2s_ASN1_OCTET_STRING_cb(uint64_t a1, int *a2)
{
  return x509v3_bytes_to_hex(*((_BYTE **)a2 + 1), *a2);
}

ASN1_STRING *s2i_skey_id(int a1, uint64_t a2, char *__s1)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  _QWORD *v10;
  ASN1_STRING *v11;
  uint64_t *v12;
  uint64_t v13;
  int *v14;
  const void *v15;
  size_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  size_t v24;
  unsigned int size;
  unsigned __int8 md[64];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  size = 0;
  if (!strcmp(__s1, "hash"))
  {
    v10 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (!v10)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      return 0;
    }
    v7 = v10;
    *v10 = 24;
    v10[1] = 0x400000000;
    v11 = (ASN1_STRING *)(v10 + 1);
    v10[2] = 0;
    v12 = v10 + 2;
    v10[3] = 0;
    if (a2)
    {
      if (*(_DWORD *)a2 == 1)
        return v11;
      v13 = *(_QWORD *)(a2 + 24);
      if (v13)
      {
        v14 = *(int **)(*(_QWORD *)(*(_QWORD *)v13 + 40) + 8);
        if (v14)
          goto LABEL_11;
LABEL_22:
        v20 = 136;
LABEL_24:
        ERR_put_error(20, 0, 144, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_skey.c", v20);
        goto LABEL_25;
      }
      v19 = *(_QWORD *)(a2 + 16);
      if (v19)
      {
        v14 = *(int **)(*(_QWORD *)(*(_QWORD *)v19 + 48) + 8);
        if (v14)
        {
LABEL_11:
          v15 = (const void *)*((_QWORD *)v14 + 1);
          v16 = *v14;
          if (pthread_once(&EVP_sha1_once, (void (*)(void))EVP_sha1_init))
            abort();
          if (EVP_Digest(v15, v16, md, &size, (const EVP_MD *)&EVP_sha1_storage, 0) && ASN1_STRING_set(v11, md, size))
            return v11;
LABEL_25:
          v21 = *v12;
          if (*v12)
          {
            v23 = *(_QWORD *)(v21 - 8);
            v22 = (void *)(v21 - 8);
            v24 = v23 + 8;
            if (v23 != -8)
              bzero(v22, v24);
            free(v22);
          }
          if (*v7 != -8)
            __memset_chk();
          goto LABEL_31;
        }
        goto LABEL_22;
      }
    }
    v20 = 125;
    goto LABEL_24;
  }
  *(_QWORD *)md = 0;
  v5 = x509v3_hex_to_bytes(__s1, md);
  if (!v5)
    return 0;
  v6 = v5;
  if (*(_QWORD *)md >> 31)
  {
    ERR_put_error(20, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_skey.c", 84);
    v8 = *(v6 - 1);
    v7 = v6 - 1;
    v9 = v8 + 8;
    if (v8 == -8)
      goto LABEL_31;
    goto LABEL_19;
  }
  v17 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v17)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v18 = *(v6 - 1);
    v7 = v6 - 1;
    v9 = v18 + 8;
    if (v18 == -8)
    {
LABEL_31:
      free(v7);
      return 0;
    }
LABEL_19:
    bzero(v7, v9);
    goto LABEL_31;
  }
  *(_QWORD *)v17 = 24;
  *((_DWORD *)v17 + 2) = *(_DWORD *)md;
  v11 = (ASN1_STRING *)(v17 + 8);
  *((_DWORD *)v17 + 3) = 4;
  *((_QWORD *)v17 + 2) = v6;
  *((_QWORD *)v17 + 3) = 0;
  return v11;
}

uint64_t x509V3_add_len_value(const char *a1, _BYTE *a2, size_t a3, int a4, unint64_t **a5)
{
  unint64_t *v9;
  size_t v11;
  size_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  char *v19;
  unint64_t *v21;
  unint64_t v22;
  void *v23;
  uint64_t v24;
  size_t v25;
  unint64_t *v26;
  uint64_t v27;
  size_t v28;
  void *v29;
  uint64_t v30;
  size_t v31;
  _QWORD *v32;
  uint64_t v33;
  size_t v34;
  _QWORD *v35;
  uint64_t v36;
  size_t v37;

  v9 = *a5;
  if (a1)
  {
    v11 = strlen(a1);
    v12 = v11 + 1;
    if (v11 != -1)
    {
      if (v12 <= 0xFFFFFFFFFFFFFFF7)
      {
        v13 = malloc_type_malloc(v11 + 9, 0x30772F57uLL);
        if (v13)
        {
          *v13 = v12;
          v14 = v13 + 1;
          memcpy(v13 + 1, a1, v12);
          if (!a4)
            goto LABEL_6;
LABEL_10:
          v16 = 0;
          goto LABEL_11;
        }
      }
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    }
    v15 = 0;
    v14 = 0;
    goto LABEL_18;
  }
  v14 = 0;
  if (a4)
    goto LABEL_10;
LABEL_6:
  if (a3 && memchr(a2, 0, a3))
  {
    ERR_put_error(20, 0, 163, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_utl.c", 104);
    v15 = 0;
LABEL_18:
    v16 = 0;
    goto LABEL_19;
  }
  v16 = OPENSSL_strndup(a2, a3);
  if (!v16)
  {
    v15 = 0;
    goto LABEL_19;
  }
LABEL_11:
  v17 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (v17)
  {
    v18 = v17;
    *v17 = 24;
    v17[1] = 0;
    v15 = (uint64_t)(v17 + 1);
    v17[2] = 0;
    v17[3] = 0;
    if (*a5 || (v19 = OPENSSL_sk_new_null(), (*a5 = (unint64_t *)v19) != 0))
    {
      v18[1] = 0;
      v18[2] = v14;
      v18[3] = v16;
      if (OPENSSL_sk_insert(*a5, v15, **a5))
        return 1;
    }
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v15 = 0;
  }
LABEL_19:
  if (!v9)
  {
    v21 = *a5;
    if (*a5)
    {
      v22 = v21[1];
      if (v22)
      {
        v24 = *(_QWORD *)(v22 - 8);
        v23 = (void *)(v22 - 8);
        v25 = v24 + 8;
        if (v24 != -8)
          bzero(v23, v25);
        free(v23);
      }
      v27 = *(v21 - 1);
      v26 = v21 - 1;
      v28 = v27 + 8;
      if (v27 != -8)
        bzero(v26, v28);
      free(v26);
    }
    *a5 = 0;
  }
  if (v15)
  {
    v30 = *(_QWORD *)(v15 - 8);
    v29 = (void *)(v15 - 8);
    v31 = v30 + 8;
    if (v30 != -8)
      bzero(v29, v31);
    free(v29);
  }
  if (v14)
  {
    v33 = *(v14 - 1);
    v32 = v14 - 1;
    v34 = v33 + 8;
    if (v33 != -8)
      bzero(v32, v34);
    free(v32);
  }
  if (v16)
  {
    v36 = *(v16 - 1);
    v35 = v16 - 1;
    v37 = v36 + 8;
    if (v36 != -8)
      bzero(v35, v37);
    free(v35);
  }
  return 0;
}

void X509V3_conf_free(CONF_VALUE *val)
{
  char *name;
  char *v3;
  uint64_t v4;
  size_t v5;
  char *value;
  char *v7;
  uint64_t v8;
  size_t v9;
  char *section;
  char *v11;
  uint64_t v12;
  size_t v13;
  char **p_value;
  char *v15;
  size_t v16;

  if (val)
  {
    name = val->name;
    if (name)
    {
      v4 = *((_QWORD *)name - 1);
      v3 = name - 8;
      v5 = v4 + 8;
      if (v4 != -8)
        bzero(v3, v5);
      free(v3);
    }
    value = val->value;
    if (value)
    {
      v8 = *((_QWORD *)value - 1);
      v7 = value - 8;
      v9 = v8 + 8;
      if (v8 != -8)
        bzero(v7, v9);
      free(v7);
    }
    section = val->section;
    if (val->section)
    {
      v12 = *((_QWORD *)section - 1);
      v11 = section - 8;
      v13 = v12 + 8;
      if (v12 != -8)
        bzero(v11, v13);
      free(v11);
    }
    v15 = val[-1].value;
    p_value = &val[-1].value;
    v16 = (size_t)(v15 + 8);
    if (v15 != (char *)-8)
      bzero(p_value, v16);
    free(p_value);
  }
}

char *__cdecl i2s_ASN1_ENUMERATED(X509V3_EXT_METHOD *meth, ASN1_ENUMERATED *aint)
{
  char *v2;
  BIGNUM *v3;
  BIGNUM *v4;
  uint64_t top;
  int8x16_t *d;
  unint64_t v7;
  int8x8_t v8;
  int v9;
  int v10;
  int8x16_t *v12;
  int8x16_t v13;
  unint64_t v14;
  int8x16_t v15;
  int8x16_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;
  char *v21;
  int flags;
  unint64_t *v23;
  unint64_t *v24;
  uint64_t v25;
  size_t v26;
  int *p_neg;
  uint64_t v28;
  size_t v29;

  v2 = (char *)aint;
  if (!aint)
    return v2;
  if ((aint->type & 0xFFFFFEFF) != 0xA)
  {
    v9 = 195;
    v10 = 446;
LABEL_10:
    ERR_put_error(12, 0, v9, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/a_int.c", v10);
    return 0;
  }
  v3 = BN_bin2bn(aint->data, aint->length, 0);
  if (!v3)
  {
    v9 = 105;
    v10 = 452;
    goto LABEL_10;
  }
  v4 = v3;
  if ((v2[5] & 1) == 0)
    goto LABEL_21;
  top = v3->top;
  if (!(_DWORD)top)
    goto LABEL_19;
  d = (int8x16_t *)v3->d;
  if (top < 4)
  {
    v7 = 0;
    v8 = 0;
LABEL_15:
    v17 = top - v7;
    v18 = &d->i64[v7];
    do
    {
      v19 = *v18++;
      *(_QWORD *)&v8 |= v19;
      --v17;
    }
    while (v17);
    goto LABEL_17;
  }
  v7 = top & 0xFFFFFFFFFFFFFFFCLL;
  v12 = d + 1;
  v13 = 0uLL;
  v14 = top & 0xFFFFFFFFFFFFFFFCLL;
  v15 = 0uLL;
  do
  {
    v13 = vorrq_s8(v12[-1], v13);
    v15 = vorrq_s8(*v12, v15);
    v12 += 2;
    v14 -= 4;
  }
  while (v14);
  v16 = vorrq_s8(v15, v13);
  v8 = vorr_s8(*(int8x8_t *)v16.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL));
  if (v7 != top)
    goto LABEL_15;
LABEL_17:
  if (!*(_QWORD *)&v8)
  {
LABEL_19:
    v20 = 0;
    goto LABEL_20;
  }
  v20 = 1;
LABEL_20:
  v3->neg = v20;
LABEL_21:
  v21 = bignum_to_string(v3);
  flags = v4->flags;
  if ((flags & 2) == 0)
  {
    v23 = v4->d;
    if (v4->d)
    {
      v25 = *(v23 - 1);
      v24 = v23 - 1;
      v26 = v25 + 8;
      if (v25 != -8)
        bzero(v24, v26);
      free(v24);
      flags = v4->flags;
    }
  }
  if ((flags & 1) != 0)
  {
    v28 = *(_QWORD *)&v4[-1].neg;
    p_neg = &v4[-1].neg;
    v29 = v28 + 8;
    if (v28 != -8)
      bzero(p_neg, v29);
    free(p_neg);
    return v21;
  }
  else
  {
    v4->d = 0;
    return v21;
  }
}

char *bignum_to_string(const BIGNUM *a1)
{
  uint64_t top;
  int v2;
  uint64_t v3;
  int v4;
  BOOL v5;
  unint64_t *d;
  uint64_t v7;
  int v8;
  unint64_t v9;
  _BOOL4 v10;
  _BOOL4 v11;
  _BOOL4 v12;
  _BOOL4 v13;
  _BOOL4 v14;
  _BOOL4 v15;
  unsigned int v16;
  char *v18;
  char *v19;
  size_t v20;
  unint64_t v21;
  size_t v22;
  char *v23;
  char *v24;
  _BYTE *v25;
  char *v26;
  uint64_t v27;
  size_t v28;
  _BYTE *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  size_t v37;

  top = a1->top;
  v2 = top & ((int)top >> 31);
  v3 = 8 * top - 8;
  v4 = a1->top;
  while (1)
  {
    v5 = __OFSUB__(v4--, 1);
    if (v4 < 0 != v5)
      break;
    d = a1->d;
    v7 = *(unint64_t *)((char *)a1->d + v3);
    v3 -= 8;
    if (v7)
    {
      v2 = v4 + 1;
      goto LABEL_7;
    }
  }
  if ((top & 0x80000000) == 0)
    return BN_bn2dec(a1);
  d = a1->d;
LABEL_7:
  v8 = v2 - 1;
  v9 = d[v8];
  v10 = v9 != 0;
  v11 = HIDWORD(v9) != 0;
  if (HIDWORD(v9))
    v9 >>= 32;
  v12 = v9 >> 16 != 0;
  if (v9 >> 16)
    v9 >>= 16;
  v13 = v9 > 0xFF;
  if (v9 > 0xFF)
    v9 >>= 8;
  v14 = v9 > 0xF;
  if (v9 > 0xF)
    v9 >>= 4;
  v15 = v9 > 3;
  if (v9 > 3)
    v9 >>= 2;
  v16 = v10 | (v8 << 6) | (32 * v11) | (16 * v12) | (8 * v13) | (4 * v14) | (2 * v15);
  if (v9 > 1)
    ++v16;
  if (v16 <= 0x1F)
    return BN_bn2dec(a1);
  v18 = BN_bn2hex(a1);
  if (!v18)
    return 0;
  v19 = v18;
  v20 = strlen(v18);
  v21 = v20 + 3;
  if (v20 + 3 > 0xFFFFFFFFFFFFFFF7 || (v22 = v20, (v23 = (char *)malloc_type_malloc(v20 + 11, 0x30772F57uLL)) == 0))
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v27 = *((_QWORD *)v19 - 1);
    v26 = v19 - 8;
    v28 = v27 + 8;
    if (v27 != -8)
      bzero(v26, v28);
    free(v26);
    return 0;
  }
  *(_QWORD *)v23 = v21;
  v24 = v23 + 8;
  if (*v19 != 45)
  {
    if (v21 < 2)
    {
      v29 = v23 + 8;
      if (!v21)
        goto LABEL_56;
    }
    else
    {
      v23[8] = 48;
      if (v22 == -1)
      {
        v29 = v23 + 9;
      }
      else
      {
        v29 = v23 + 10;
        v23[9] = 120;
      }
    }
    *v29 = 0;
    v30 = v19;
    goto LABEL_45;
  }
  if (v21 >= 2)
  {
    v23[8] = 45;
    if (v22 == -1)
    {
      v25 = v23 + 9;
    }
    else
    {
      v23[9] = 48;
      if (v22)
      {
        v25 = v23 + 11;
        v23[10] = 120;
      }
      else
      {
        v25 = v23 + 10;
      }
    }
    goto LABEL_44;
  }
  v25 = v23 + 8;
  if (v21)
  {
LABEL_44:
    *v25 = 0;
    v30 = v19 + 1;
LABEL_45:
    v31 = 0;
    while (v24[v31])
    {
      if (v22 + 3 == ++v31)
        goto LABEL_56;
    }
    if (v22 - v31 + 3 < 2)
    {
      v34 = &v24[v31];
    }
    else
    {
      v32 = 0;
      v33 = v22 - v31 + 2;
      do
      {
        if (!v30[v32])
          break;
        v24[v32 + v31] = v30[v32];
        ++v32;
        --v33;
      }
      while (v33);
      v34 = &v24[v31 + v32];
    }
    *v34 = 0;
  }
LABEL_56:
  v36 = *((_QWORD *)v19 - 1);
  v35 = v19 - 8;
  v37 = v36 + 8;
  if (v36 != -8)
    bzero(v35, v37);
  free(v35);
  return v24;
}

char *__cdecl i2s_ASN1_INTEGER(X509V3_EXT_METHOD *meth, ASN1_INTEGER *aint)
{
  char *v2;
  BIGNUM *v3;
  BIGNUM *v4;
  uint64_t top;
  int8x16_t *d;
  unint64_t v7;
  int8x8_t v8;
  int v9;
  int v10;
  int8x16_t *v12;
  int8x16_t v13;
  unint64_t v14;
  int8x16_t v15;
  int8x16_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;
  char *v21;
  int flags;
  unint64_t *v23;
  unint64_t *v24;
  uint64_t v25;
  size_t v26;
  int *p_neg;
  uint64_t v28;
  size_t v29;

  v2 = (char *)aint;
  if (!aint)
    return v2;
  if ((aint->type & 0xFFFFFEFF) != 2)
  {
    v9 = 195;
    v10 = 446;
LABEL_10:
    ERR_put_error(12, 0, v9, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/a_int.c", v10);
    return 0;
  }
  v3 = BN_bin2bn(aint->data, aint->length, 0);
  if (!v3)
  {
    v9 = 105;
    v10 = 452;
    goto LABEL_10;
  }
  v4 = v3;
  if ((v2[5] & 1) == 0)
    goto LABEL_21;
  top = v3->top;
  if (!(_DWORD)top)
    goto LABEL_19;
  d = (int8x16_t *)v3->d;
  if (top < 4)
  {
    v7 = 0;
    v8 = 0;
LABEL_15:
    v17 = top - v7;
    v18 = &d->i64[v7];
    do
    {
      v19 = *v18++;
      *(_QWORD *)&v8 |= v19;
      --v17;
    }
    while (v17);
    goto LABEL_17;
  }
  v7 = top & 0xFFFFFFFFFFFFFFFCLL;
  v12 = d + 1;
  v13 = 0uLL;
  v14 = top & 0xFFFFFFFFFFFFFFFCLL;
  v15 = 0uLL;
  do
  {
    v13 = vorrq_s8(v12[-1], v13);
    v15 = vorrq_s8(*v12, v15);
    v12 += 2;
    v14 -= 4;
  }
  while (v14);
  v16 = vorrq_s8(v15, v13);
  v8 = vorr_s8(*(int8x8_t *)v16.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL));
  if (v7 != top)
    goto LABEL_15;
LABEL_17:
  if (!*(_QWORD *)&v8)
  {
LABEL_19:
    v20 = 0;
    goto LABEL_20;
  }
  v20 = 1;
LABEL_20:
  v3->neg = v20;
LABEL_21:
  v21 = bignum_to_string(v3);
  flags = v4->flags;
  if ((flags & 2) == 0)
  {
    v23 = v4->d;
    if (v4->d)
    {
      v25 = *(v23 - 1);
      v24 = v23 - 1;
      v26 = v25 + 8;
      if (v25 != -8)
        bzero(v24, v26);
      free(v24);
      flags = v4->flags;
    }
  }
  if ((flags & 1) != 0)
  {
    v28 = *(_QWORD *)&v4[-1].neg;
    p_neg = &v4[-1].neg;
    v29 = v28 + 8;
    if (v28 != -8)
      bzero(p_neg, v29);
    free(p_neg);
    return v21;
  }
  else
  {
    v4->d = 0;
    return v21;
  }
}

ASN1_INTEGER *__cdecl s2i_ASN1_INTEGER(X509V3_EXT_METHOD *meth, char *value)
{
  char *v2;
  _QWORD *v3;
  BIGNUM *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int flags;
  unint64_t *d;
  unint64_t *v11;
  uint64_t v12;
  size_t v13;
  BIGNUM *v14;
  int v15;
  unint64_t *v16;
  unint64_t *v17;
  uint64_t v18;
  size_t v19;
  int *v20;
  uint64_t v21;
  size_t v22;
  uint64_t top;
  unint64_t *v24;
  unint64_t v25;
  int8x8_t v26;
  BOOL v27;
  ASN1_STRING *v28;
  BIGNUM *v29;
  int *p_neg;
  uint64_t v31;
  size_t v32;
  int8x16_t *v34;
  int8x16_t v35;
  unint64_t v36;
  int8x16_t v37;
  int8x16_t v38;
  uint64_t v39;
  unint64_t *v40;
  uint64_t v41;
  int v42;
  unint64_t *v43;
  unint64_t *v44;
  uint64_t v45;
  size_t v46;
  int *v47;
  uint64_t v48;
  size_t v49;
  BIGNUM *a;

  if (!value)
  {
    v5 = 126;
    v6 = 237;
LABEL_45:
    ERR_put_error(20, (int)value, v5, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_utl.c", v6);
    return 0;
  }
  v2 = value;
  v3 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (v3)
  {
    *v3 = 24;
    v3[1] = 0;
    v4 = (BIGNUM *)(v3 + 1);
    v3[2] = 0;
    v3[3] = 0x100000000;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v4 = 0;
  }
  a = v4;
  v7 = *v2;
  if (v7 == 45)
    ++v2;
  if (*v2 == 48 && (v2[1] | 0x20) == 0x78)
  {
    v2 += 2;
    v8 = BN_hex2bn(&a, v2);
    if (!v8)
      goto LABEL_23;
  }
  else
  {
    if (strlen(v2) > 0x2000)
    {
      if (v4)
      {
        flags = v4->flags;
        if ((flags & 2) == 0)
        {
          d = v4->d;
          if (v4->d)
          {
            v12 = *(d - 1);
            v11 = d - 1;
            v13 = v12 + 8;
            if (v12 != -8)
              bzero(v11, v13);
            free(v11);
            flags = v4->flags;
          }
        }
        if ((flags & 1) != 0)
        {
          v31 = *(_QWORD *)&v4[-1].neg;
          p_neg = &v4[-1].neg;
          v32 = v31 + 8;
          if (v31 != -8)
            bzero(p_neg, v32);
          free(p_neg);
        }
        else
        {
          v4->d = 0;
        }
      }
      LODWORD(value) = 0;
      v5 = 127;
      v6 = 265;
      goto LABEL_45;
    }
    v8 = BN_dec2bn(&a, v2);
    if (!v8)
      goto LABEL_23;
  }
  if (v2[v8])
  {
LABEL_23:
    v14 = a;
    if (a)
    {
      v15 = a->flags;
      if ((v15 & 2) == 0)
      {
        v16 = a->d;
        if (a->d)
        {
          v18 = *(v16 - 1);
          v17 = v16 - 1;
          v19 = v18 + 8;
          if (v18 != -8)
            bzero(v17, v19);
          free(v17);
          v15 = v14->flags;
        }
      }
      if ((v15 & 1) != 0)
      {
        v21 = *(_QWORD *)&v14[-1].neg;
        v20 = &v14[-1].neg;
        v22 = v21 + 8;
        if (v21 != -8)
          bzero(v20, v22);
        free(v20);
      }
      else
      {
        v14->d = 0;
      }
    }
    LODWORD(value) = 0;
    v5 = 102;
    v6 = 273;
    goto LABEL_45;
  }
  if (v7 != 45 || (top = a->top, !(_DWORD)top))
  {
    v27 = 1;
    v28 = bn_to_asn1_string((uint64_t *)a, 0, 2);
    v29 = a;
    if (!a)
      goto LABEL_60;
    goto LABEL_53;
  }
  v24 = a->d;
  if (top < 4)
  {
    v25 = 0;
    v26 = 0;
LABEL_50:
    v39 = top - v25;
    v40 = &v24[v25];
    do
    {
      v41 = *v40++;
      *(_QWORD *)&v26 |= v41;
      --v39;
    }
    while (v39);
    goto LABEL_52;
  }
  v25 = top & 0xFFFFFFFFFFFFFFFCLL;
  v34 = (int8x16_t *)(v24 + 2);
  v35 = 0uLL;
  v36 = top & 0xFFFFFFFFFFFFFFFCLL;
  v37 = 0uLL;
  do
  {
    v35 = vorrq_s8(v34[-1], v35);
    v37 = vorrq_s8(*v34, v37);
    v34 += 2;
    v36 -= 4;
  }
  while (v36);
  v38 = vorrq_s8(v37, v35);
  v26 = vorr_s8(*(int8x8_t *)v38.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL));
  if (v25 != top)
    goto LABEL_50;
LABEL_52:
  v27 = *(_QWORD *)&v26 == 0;
  v28 = bn_to_asn1_string((uint64_t *)a, 0, 2);
  v29 = a;
  if (!a)
    goto LABEL_60;
LABEL_53:
  v42 = v29->flags;
  if ((v42 & 2) == 0)
  {
    v43 = v29->d;
    if (v29->d)
    {
      v45 = *(v43 - 1);
      v44 = v43 - 1;
      v46 = v45 + 8;
      if (v45 != -8)
        bzero(v44, v46);
      free(v44);
      v42 = v29->flags;
    }
  }
  if ((v42 & 1) != 0)
  {
    v48 = *(_QWORD *)&v29[-1].neg;
    v47 = &v29[-1].neg;
    v49 = v48 + 8;
    if (v48 != -8)
      bzero(v47, v49);
    free(v47);
    if (v28)
      goto LABEL_61;
LABEL_66:
    ERR_put_error(20, 0, 103, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_utl.c", 284);
    return v28;
  }
  v29->d = 0;
LABEL_60:
  if (!v28)
    goto LABEL_66;
LABEL_61:
  if (v27)
    return v28;
  v28->type |= 0x100u;
  return v28;
}

int X509V3_add_value_int(const char *name, ASN1_INTEGER *aint, STACK **extlist)
{
  BIGNUM *v6;
  BIGNUM *v7;
  uint64_t top;
  int8x16_t *d;
  unint64_t v10;
  int8x8_t v11;
  int v13;
  int v14;
  int8x16_t *v15;
  int8x16_t v16;
  unint64_t v17;
  int8x16_t v18;
  int8x16_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;
  char *v24;
  int flags;
  unint64_t *v26;
  unint64_t *v27;
  uint64_t v28;
  size_t v29;
  int *p_neg;
  uint64_t v31;
  size_t v32;
  size_t v33;
  int v34;
  char *v35;
  uint64_t v36;
  size_t v37;

  if (!aint)
    return 1;
  if ((aint->type & 0xFFFFFEFF) != 2)
  {
    v13 = 195;
    v14 = 446;
LABEL_11:
    ERR_put_error(12, 0, v13, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/asn1/a_int.c", v14);
    return 0;
  }
  v6 = BN_bin2bn(aint->data, aint->length, 0);
  if (!v6)
  {
    v13 = 105;
    v14 = 452;
    goto LABEL_11;
  }
  v7 = v6;
  if ((aint->type & 0x100) != 0)
  {
    top = v6->top;
    if (!(_DWORD)top)
      goto LABEL_20;
    d = (int8x16_t *)v6->d;
    if (top >= 4)
    {
      v10 = top & 0xFFFFFFFFFFFFFFFCLL;
      v15 = d + 1;
      v16 = 0uLL;
      v17 = top & 0xFFFFFFFFFFFFFFFCLL;
      v18 = 0uLL;
      do
      {
        v16 = vorrq_s8(v15[-1], v16);
        v18 = vorrq_s8(*v15, v18);
        v15 += 2;
        v17 -= 4;
      }
      while (v17);
      v19 = vorrq_s8(v18, v16);
      v11 = vorr_s8(*(int8x8_t *)v19.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL));
      if (v10 == top)
      {
LABEL_18:
        if (v11)
        {
          v23 = 1;
LABEL_21:
          v6->neg = v23;
          goto LABEL_22;
        }
LABEL_20:
        v23 = 0;
        goto LABEL_21;
      }
    }
    else
    {
      v10 = 0;
      v11 = 0;
    }
    v20 = top - v10;
    v21 = &d->i64[v10];
    do
    {
      v22 = *v21++;
      *(_QWORD *)&v11 |= v22;
      --v20;
    }
    while (v20);
    goto LABEL_18;
  }
LABEL_22:
  v24 = bignum_to_string(v6);
  flags = v7->flags;
  if ((flags & 2) == 0)
  {
    v26 = v7->d;
    if (v7->d)
    {
      v28 = *(v26 - 1);
      v27 = v26 - 1;
      v29 = v28 + 8;
      if (v28 != -8)
        bzero(v27, v29);
      free(v27);
      flags = v7->flags;
    }
  }
  if ((flags & 1) != 0)
  {
    v31 = *(_QWORD *)&v7[-1].neg;
    p_neg = &v7[-1].neg;
    v32 = v31 + 8;
    if (v31 != -8)
      bzero(p_neg, v32);
    free(p_neg);
    if (!v24)
      return 0;
  }
  else
  {
    v7->d = 0;
    if (!v24)
      return 0;
  }
  v33 = strlen(v24);
  v34 = x509V3_add_len_value(name, v24, v33, 0, (unint64_t **)extlist);
  v36 = *((_QWORD *)v24 - 1);
  v35 = v24 - 8;
  v37 = v36 + 8;
  if (v36 != -8)
    bzero(v35, v37);
  free(v35);
  return v34;
}

uint64_t X509V3_BOOL_from_string(const char *a1, _DWORD *a2)
{
  if (!strcmp(a1, "TRUE")
    || !strcmp(a1, "true")
    || !strcmp(a1, "Y")
    || !strcmp(a1, "y")
    || !strcmp(a1, "YES")
    || !strcmp(a1, "yes"))
  {
    *a2 = 255;
    return 1;
  }
  else if (!strcmp(a1, "FALSE")
         || !strcmp(a1, "false")
         || !strcmp(a1, "N")
         || !strcmp(a1, "n")
         || !strcmp(a1, "NO")
         || !strcmp(a1, "no"))
  {
    *a2 = 0;
    return 1;
  }
  else
  {
    ERR_put_error(20, 0, 120, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_utl.c", 319);
    return 0;
  }
}

int X509V3_get_value_int(CONF_VALUE *value, ASN1_INTEGER **aint)
{
  ASN1_INTEGER *v4;
  ASN1_INTEGER *v5;
  ASN1_INTEGER *v6;
  unsigned __int8 *data;
  unsigned __int8 *v8;
  uint64_t v9;
  size_t v10;
  uint64_t *p_flags;
  uint64_t flags;
  size_t v13;

  v4 = s2i_ASN1_INTEGER((X509V3_EXT_METHOD *)value, value->value);
  if (v4)
  {
    v5 = v4;
    v6 = *aint;
    if (*aint)
    {
      data = v6->data;
      if (data)
      {
        v9 = *((_QWORD *)data - 1);
        v8 = data - 8;
        v10 = v9 + 8;
        if (v9 != -8)
          bzero(v8, v10);
        free(v8);
      }
      flags = v6[-1].flags;
      p_flags = &v6[-1].flags;
      v13 = flags + 8;
      if (flags != -8)
        bzero(p_flags, v13);
      free(p_flags);
    }
    *aint = v5;
    return 1;
  }
  else
  {
    ERR_add_error_data(6, "section:", value->section, ",name:", value->name, ",value:", value->value);
    return 0;
  }
}

STACK *__cdecl X509V3_parse_list(STACK *line)
{
  STACK *v1;
  size_t v2;
  size_t v3;
  _QWORD *v4;
  _QWORD *v5;
  char *v6;
  const char *v7;
  char *v8;
  int v9;
  size_t v10;
  unsigned int v11;
  int v13;
  int v14;
  size_t v15;
  size_t v16;
  int v17;
  BOOL v18;
  int v19;
  int v20;
  size_t v21;
  size_t v22;
  int v23;
  BOOL v24;
  int v25;
  int v26;
  size_t v27;
  size_t v28;
  int v29;
  BOOL v30;
  int v31;
  int v32;
  int v33;
  int v34;
  size_t v35;
  size_t v36;
  int v37;
  BOOL v38;
  size_t v39;
  const char *v40;
  char *v41;
  int v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  CONF_VALUE *v46;
  int v47;
  size_t v48;
  size_t v49;
  int v50;
  BOOL v51;
  unint64_t v52;
  void *v53;
  uint64_t v54;
  size_t v55;
  unint64_t *v56;
  uint64_t v57;
  size_t v58;
  void *v59;

  v59 = 0;
  if (!line)
    return line;
  v1 = line;
  v2 = strlen((const char *)line);
  v3 = v2 + 1;
  if (v2 == -1)
    return 0;
  if (v3 > 0xFFFFFFFFFFFFFFF7 || (v4 = malloc_type_malloc(v2 + 9, 0x30772F57uLL)) == 0)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v5 = v4;
  *v4 = v3;
  v6 = (char *)(v4 + 1);
  memcpy(v4 + 1, v1, v3);
  v7 = 0;
  v8 = v6;
  v9 = 1;
  while (1)
  {
    v11 = *v6;
    if (v11 <= 0xD && ((1 << v11) & 0x2401) != 0)
      break;
    if (v9 == 2)
    {
      if (v11 == 44)
      {
        *v6 = 0;
        v19 = *v8;
        if (*v8)
        {
          while (v19 == 32 || (v19 - 14) >= 0xFFFFFFFB)
          {
            v20 = *++v8;
            v19 = v20;
            if (!v20)
              goto LABEL_72;
          }
          v21 = strlen(v8);
          do
          {
            v22 = v21 - 1;
            if (v21 == 1)
              goto LABEL_7;
            v23 = v8[v21 - 1];
            v24 = v23 == 32 || (v23 - 14) > 0xFFFFFFFA;
            --v21;
          }
          while (v24);
          v8[v22 + 1] = 0;
          if (*v8)
          {
LABEL_7:
            v10 = strlen(v8);
            x509V3_add_len_value(v7, v8, v10, 0, (unint64_t **)&v59);
            v7 = 0;
            v8 = v6 + 1;
            goto LABEL_8;
          }
        }
LABEL_72:
        v32 = 126;
        v33 = 405;
        goto LABEL_77;
      }
      v9 = 2;
      ++v6;
    }
    else if (v11 == 44)
    {
      *v6 = 0;
      v25 = *v8;
      if (!*v8)
      {
LABEL_74:
        v32 = 125;
        v33 = 389;
        goto LABEL_77;
      }
      v7 = v8;
      while (v25 == 32 || (v25 - 14) >= 0xFFFFFFFB)
      {
        v26 = *(unsigned __int8 *)++v7;
        v25 = v26;
        if (!v26)
          goto LABEL_74;
      }
      v27 = strlen(v7);
      while (1)
      {
        v28 = v27 - 1;
        if (v27 == 1)
          break;
        v29 = v7[v27 - 1];
        v30 = v29 == 32 || (v29 - 14) > 0xFFFFFFFA;
        --v27;
        if (!v30)
        {
          v7[v28 + 1] = 0;
          if (!*v7)
            goto LABEL_74;
          break;
        }
      }
      v8 = v6 + 1;
      v9 = 1;
      x509V3_add_len_value(v7, 0, 0, 1, (unint64_t **)&v59);
      ++v6;
    }
    else if (v11 == 58)
    {
      *v6 = 0;
      v13 = *v8;
      if (!*v8)
      {
LABEL_73:
        v32 = 125;
        v33 = 377;
        goto LABEL_77;
      }
      v7 = v8;
      while (v13 == 32 || (v13 - 14) >= 0xFFFFFFFB)
      {
        v14 = *(unsigned __int8 *)++v7;
        v13 = v14;
        if (!v14)
          goto LABEL_73;
      }
      v15 = strlen(v7);
      while (1)
      {
        v16 = v15 - 1;
        if (v15 == 1)
          break;
        v17 = v7[v15 - 1];
        v18 = v17 == 32 || (v17 - 14) > 0xFFFFFFFA;
        --v15;
        if (!v18)
        {
          v7[v16 + 1] = 0;
          if (!*v7)
            goto LABEL_73;
          break;
        }
      }
      v8 = v6 + 1;
      v9 = 2;
      ++v6;
    }
    else
    {
LABEL_8:
      v9 = 1;
      ++v6;
    }
  }
  v31 = *v8;
  if (v9 == 2)
  {
    if (!*v8)
    {
LABEL_60:
      v32 = 126;
      v33 = 421;
LABEL_77:
      ERR_put_error(20, 0, v32, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_utl.c", v33);
      if (*v5 != -8)
        bzero(v5, *v5 + 8);
      free(v5);
      v43 = (unint64_t *)v59;
      if (v59)
      {
        v44 = *(_QWORD *)v59;
        if (*(_QWORD *)v59)
        {
          v45 = 0;
          do
          {
            v46 = *(CONF_VALUE **)(v43[1] + 8 * v45);
            if (v46)
            {
              X509V3_conf_free(v46);
              v44 = *v43;
            }
            ++v45;
          }
          while (v45 < v44);
        }
        v52 = v43[1];
        if (v52)
        {
          v54 = *(_QWORD *)(v52 - 8);
          v53 = (void *)(v52 - 8);
          v55 = v54 + 8;
          if (v54 != -8)
            bzero(v53, v55);
          free(v53);
        }
        v57 = *(v43 - 1);
        v56 = v43 - 1;
        v58 = v57 + 8;
        if (v57 != -8)
          bzero(v56, v58);
        free(v56);
      }
      return 0;
    }
    while (v31 == 32 || (v31 - 14) >= 0xFFFFFFFB)
    {
      v34 = *++v8;
      v31 = v34;
      if (!v34)
        goto LABEL_60;
    }
    v35 = strlen(v8);
    while (1)
    {
      v36 = v35 - 1;
      if (v35 == 1)
        break;
      v37 = v8[v35 - 1];
      v38 = v37 == 32 || (v37 - 14) > 0xFFFFFFFA;
      --v35;
      if (!v38)
      {
        v8[v36 + 1] = 0;
        if (!*v8)
          goto LABEL_60;
        break;
      }
    }
    v39 = strlen(v8);
    v40 = v7;
    v41 = v8;
    v42 = 0;
  }
  else
  {
    if (!*v8)
    {
LABEL_76:
      v32 = 125;
      v33 = 431;
      goto LABEL_77;
    }
    while (v31 == 32 || (v31 - 14) >= 0xFFFFFFFB)
    {
      v47 = *++v8;
      v31 = v47;
      if (!v47)
        goto LABEL_76;
    }
    v48 = strlen(v8);
    while (1)
    {
      v49 = v48 - 1;
      if (v48 == 1)
        break;
      v50 = v8[v48 - 1];
      v51 = v50 == 32 || (v50 - 14) > 0xFFFFFFFA;
      --v48;
      if (!v51)
      {
        v8[v49 + 1] = 0;
        if (!*v8)
          goto LABEL_76;
        break;
      }
    }
    v40 = v8;
    v41 = 0;
    v39 = 0;
    v42 = 1;
  }
  x509V3_add_len_value(v40, v41, v39, v42, (unint64_t **)&v59);
  if (*v5 != -8)
    bzero(v5, *v5 + 8);
  free(v5);
  return (STACK *)v59;
}

void *x509v3_bytes_to_hex(_BYTE *a1, uint64_t a2)
{
  unint64_t v2;
  const char *v3;
  int v4;
  int v5;
  uint64_t v6;
  char *v7;
  _QWORD *v11;
  void *v12;
  char v13;
  char v14;
  uint64_t v15;
  _BYTE *v16;
  char v17;
  char v18;
  __int128 v19;
  void *v20[2];
  __int128 v21;
  char *v22;

  *(_OWORD *)v20 = 0u;
  v21 = 0u;
  v2 = 3 * a2 + 1;
  v19 = 0u;
  if (v2 >= 0xFFFFFFFFFFFFFFF8)
  {
    v3 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v4 = 65;
    v5 = 247;
LABEL_3:
    ERR_put_error(14, 0, v4, v3, v5);
    goto LABEL_4;
  }
  v11 = malloc_type_malloc(3 * a2 + 9, 0x30772F57uLL);
  if (v11)
  {
    *v11 = v2;
    v12 = v11 + 1;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    if (v2)
      goto LABEL_4;
    v12 = 0;
  }
  BYTE8(v19) = 0;
  *(_QWORD *)&v19 = 0;
  v20[0] = v12;
  v20[1] = 0;
  *(_QWORD *)&v21 = v2;
  BYTE8(v21) = 1;
  if (a2)
  {
    v13 = x509v3_bytes_to_hex_hex[(unint64_t)*a1 >> 4];
    v22 = 0;
    if (!CBB_add_space((uint64_t)&v19, &v22, 1))
      goto LABEL_4;
    *v22 = v13;
    v14 = x509v3_bytes_to_hex_hex[*a1 & 0xF];
    v22 = 0;
    if (!CBB_add_space((uint64_t)&v19, &v22, 1))
      goto LABEL_4;
    *v22 = v14;
    v15 = a2 - 1;
    if (v15)
    {
      v16 = a1 + 1;
      do
      {
        v22 = 0;
        if (!CBB_add_space((uint64_t)&v19, &v22, 1))
          goto LABEL_4;
        *v22 = 58;
        v17 = x509v3_bytes_to_hex_hex[(unint64_t)*v16 >> 4];
        v22 = 0;
        if (!CBB_add_space((uint64_t)&v19, &v22, 1))
          goto LABEL_4;
        *v22 = v17;
        v18 = x509v3_bytes_to_hex_hex[*v16 & 0xF];
        v22 = 0;
        if (!CBB_add_space((uint64_t)&v19, &v22, 1))
          goto LABEL_4;
        *v22 = v18;
        ++v16;
      }
      while (--v15);
    }
  }
  v22 = 0;
  if (CBB_add_space((uint64_t)&v19, &v22, 1))
  {
    *v22 = 0;
    if (BYTE8(v19))
    {
      v3 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/"
           "crypto/bytestring/cbb.c";
      v4 = 66;
      v5 = 127;
      goto LABEL_3;
    }
    if (CBB_flush((uint64_t *)&v19))
      return v20[0];
  }
LABEL_4:
  if (!BYTE8(v19) && (BYTE8(v21) & 1) != 0 && v20[0])
  {
    v7 = (char *)v20[0] - 8;
    v6 = *((_QWORD *)v20[0] - 1);
    if (v6 != -8)
      bzero(v7, v6 + 8);
    free(v7);
  }
  return 0;
}

_QWORD *x509v3_hex_to_bytes(const char *a1, _QWORD *a2)
{
  const char *v3;
  size_t v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _BYTE *v8;
  int v9;
  int v10;
  char v11;
  char v12;
  const char *v13;
  int v14;
  int v15;
  int v16;

  if (!a1)
  {
    v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/c"
          "rypto/x509/v3_utl.c";
    v14 = 20;
    v15 = 124;
    v16 = 502;
    goto LABEL_26;
  }
  v3 = a1;
  v4 = strlen(a1) >> 1;
  v5 = malloc_type_malloc(v4 + 8, 0x30772F57uLL);
  if (!v5)
  {
    v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c";
    v14 = 14;
    v15 = 65;
    v16 = 247;
LABEL_26:
    ERR_put_error(v14, 0, v15, v13, v16);
    return 0;
  }
  v6 = v5;
  *v5 = v4;
  v7 = v5 + 1;
  v8 = v5 + 1;
LABEL_4:
  ++v3;
  while (1)
  {
    v9 = *((unsigned __int8 *)v3 - 1);
    if (!*(v3 - 1))
      break;
    ++v3;
    if (v9 != 58)
    {
      v10 = *((unsigned __int8 *)v3 - 1);
      if (!*(v3 - 1))
      {
        ERR_put_error(20, 0, 146, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/v3_utl.c", 515);
        OPENSSL_free(v7);
        return 0;
      }
      if ((v9 - 58) > 0xFFFFFFF5)
      {
        v11 = -48;
        if ((v10 - 58) > 0xFFFFFFF5)
          goto LABEL_17;
        goto LABEL_13;
      }
      if ((v9 - 97) >= 6)
      {
        if ((v9 - 65) <= 5)
        {
          v11 = -55;
          if ((v10 - 58) > 0xFFFFFFF5)
            goto LABEL_17;
          goto LABEL_13;
        }
      }
      else
      {
        v11 = -87;
        if ((v10 - 58) > 0xFFFFFFF5)
        {
LABEL_17:
          v12 = -48;
          goto LABEL_20;
        }
LABEL_13:
        if ((v10 - 97) < 6)
        {
          v12 = -87;
LABEL_20:
          *v8++ = (v12 + v10) | (16 * (v11 + v9));
          goto LABEL_4;
        }
        if ((v10 - 65) <= 5)
        {
          v12 = -55;
          goto LABEL_20;
        }
      }
      if (*v5 != -8)
        bzero(v5, *v5 + 8);
      free(v6);
      v13 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src"
            "/crypto/x509/v3_utl.c";
      v14 = 20;
      v15 = 118;
      v16 = 540;
      goto LABEL_26;
    }
  }
  if (a2)
    *a2 = v8 - (_BYTE *)v7;
  return v5 + 1;
}

BOOL x509v3_conf_name_matches(const char *a1, char *__s)
{
  size_t v4;

  v4 = strlen(__s);
  if (strncmp(a1, __s, v4))
    return 0;
  return !a1[v4] || a1[v4] == 46;
}

uint64_t do_x509_check(uint64_t a1, void *a2, size_t a3, uint64_t a4, int a5, _QWORD *a6)
{
  BOOL (*v12)(const void *, size_t, void *, uint64_t);
  BOOL (*v13)(const void *, size_t, void *, uint64_t);
  int v14;
  int v15;
  int v16;
  uint64_t (*v17)(void);
  _BOOL4 v18;
  int v19;
  ASN1_VALUE *d2i;
  ASN1_VALUE *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  X509_NAME *v27;
  int v28;
  ASN1_STRING *v29;
  uint64_t v30;
  unsigned int index_by_NID;
  STACK *entries;
  char *v33;
  int v34;
  int v35;
  _BOOL4 v37;
  ASN1_VALUE *pval;

  v12 = equal_case;
  v13 = (BOOL (*)(const void *, size_t, void *, uint64_t))equal_nocase;
  if ((a4 & 2) == 0)
    v13 = (BOOL (*)(const void *, size_t, void *, uint64_t))equal_wildcard;
  if (a5 == 2)
    v14 = 22;
  else
    v14 = 4;
  if (a5 == 2)
  {
    v12 = v13;
    v15 = 13;
  }
  else
  {
    v15 = 0;
  }
  if (a5 == 1)
    v16 = 22;
  else
    v16 = v14;
  if (a5 == 1)
    v17 = (uint64_t (*)(void))equal_email;
  else
    v17 = (uint64_t (*)(void))v12;
  v18 = a5 == 1 || a5 == 2;
  v37 = v18;
  if (a5 == 1)
    v19 = 48;
  else
    v19 = v15;
  d2i = (ASN1_VALUE *)X509V3_get_d2i(*(STACK **)(*(_QWORD *)a1 + 72), 85, 0, 0);
  if (!d2i)
  {
    if (((!v37 | ((a4 & 0x20) >> 5)) & 1) == 0)
    {
      v27 = *(X509_NAME **)(*(_QWORD *)a1 + 40);
      if (v27)
      {
        v28 = -1;
        while (1)
        {
          index_by_NID = X509_NAME_get_index_by_NID(v27, v19, v28);
          if ((index_by_NID & 0x80000000) != 0)
            break;
          v28 = index_by_NID;
          entries = v27->entries;
          if (v27->entries
            && *(_QWORD *)&entries->num > (unint64_t)index_by_NID
            && (v33 = entries->data[index_by_NID]) != 0)
          {
            v29 = (ASN1_STRING *)*((_QWORD *)v33 + 1);
          }
          else
          {
            v29 = 0;
          }
          v30 = do_check_string(v29, -1, v17, a4, a5, a2, a3, a6);
          if ((_DWORD)v30)
            return v30;
        }
      }
      else
      {
        v34 = -1;
        while (1)
        {
          v35 = X509_NAME_get_index_by_NID(0, v19, v34);
          if (v35 < 0)
            break;
          v34 = v35;
          v30 = do_check_string(0, -1, v17, a4, a5, a2, a3, a6);
          if ((_DWORD)v30)
            return v30;
        }
      }
    }
    return 0;
  }
  v21 = d2i;
  v22 = *(_QWORD *)d2i;
  if (!*(_QWORD *)d2i)
  {
LABEL_28:
    v26 = 0;
    goto LABEL_40;
  }
  v23 = 0;
  while (1)
  {
    v24 = *(_QWORD *)(*((_QWORD *)v21 + 1) + 8 * v23);
    if (*(_DWORD *)v24 == a5)
      break;
LABEL_24:
    if (++v23 >= v22)
      goto LABEL_28;
  }
  v25 = do_check_string(*(ASN1_STRING **)(v24 + 8), v16, v17, a4, a5, a2, a3, a6);
  if (!(_DWORD)v25)
  {
    v22 = *(_QWORD *)v21;
    goto LABEL_24;
  }
  v26 = v25;
LABEL_40:
  pval = v21;
  ASN1_item_ex_free(&pval, &GENERAL_NAMES_it);
  return v26;
}

uint64_t X509_check_ip(uint64_t a1, const void *a2, size_t a3)
{
  ASN1_VALUE *d2i;
  ASN1_VALUE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  const void *v12;
  int v13;
  int v14;
  BOOL v15;
  uint64_t i;
  uint64_t v17;
  ASN1_VALUE *pval;

  if (!a2)
    return 4294967294;
  d2i = (ASN1_VALUE *)X509V3_get_d2i(*(STACK **)(*(_QWORD *)a1 + 72), 85, 0, 0);
  if (d2i)
  {
    v6 = d2i;
    v7 = *(_QWORD *)d2i;
    if (a3)
    {
      if (v7)
      {
        v8 = 0;
        v9 = *((_QWORD *)d2i + 1);
        while (1)
        {
          v10 = *(_QWORD *)(v9 + 8 * v8);
          if (*(_DWORD *)v10 == 7)
          {
            v11 = *(int **)(v10 + 8);
            v12 = (const void *)*((_QWORD *)v11 + 1);
            if (v12)
            {
              v13 = *v11;
              if (*v11)
              {
                v14 = v11[1];
                v15 = v13 == (_DWORD)a3 && v14 == 4;
                if (v15 && !memcmp(v12, a2, a3))
                  break;
              }
            }
          }
          if (v7 == ++v8)
            goto LABEL_22;
        }
        v17 = 1;
        goto LABEL_23;
      }
    }
    else if (v7)
    {
      for (i = 0; i != v7; ++i)
        ;
    }
LABEL_22:
    v17 = 0;
LABEL_23:
    pval = v6;
    ASN1_item_ex_free(&pval, &GENERAL_NAMES_it);
    return v17;
  }
  return 0;
}

uint64_t x509v3_a2i_ipadd(_BYTE *a1, char *__s)
{
  char *v2;
  int v4;
  char v5;
  char v6;
  char v7;
  uint64_t result;
  char *v9;
  char *v10;
  char *v11;
  char v12;
  char v13;
  char v14;
  char *v15;
  int v16;
  int v17;
  __int16 v18;
  char *v19;
  int64_t v20;
  char v21;
  unsigned __int8 v22;
  __int16 v23;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  __int128 __src;
  int v33;
  size_t __n;
  uint64_t v35;

  v2 = __s;
  v35 = *MEMORY[0x24BDAC8D0];
  if (strchr(__s, 58))
  {
    __src = 0uLL;
    v33 = 0;
    __n = 0xFFFFFFFFLL;
    if (!v2)
    {
      ERR_put_error(13, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/conf/conf.c", 601);
      return 0;
    }
    v4 = 0;
    while (1)
    {
      while (1)
      {
        v9 = strchr(v2, 58);
        v10 = v9;
        if (v9 != v2)
        {
          if (*v2)
            break;
        }
        if (v4 == 16)
          return 0;
        v16 = __n;
        if ((_DWORD)__n != -1)
        {
LABEL_35:
          if (v16 != v4)
            return 0;
          v17 = HIDWORD(__n);
          if (SHIDWORD(__n) > 2)
            return 0;
          goto LABEL_39;
        }
        LODWORD(__n) = v4;
        v17 = HIDWORD(__n);
        if (SHIDWORD(__n) > 2)
          return 0;
LABEL_39:
        HIDWORD(__n) = v17 + 1;
        v2 = v10 + 1;
        if (!v10)
          goto LABEL_54;
      }
      v11 = v9;
      if (!v9)
        v11 = &v2[strlen(v2)];
      if (v4 == 16)
        return 0;
      if (v11 == v2)
      {
        v16 = __n;
        if ((_DWORD)__n != -1)
          goto LABEL_35;
        LODWORD(__n) = v4;
        v17 = HIDWORD(__n);
        if (SHIDWORD(__n) > 2)
          return 0;
        goto LABEL_39;
      }
      if ((unint64_t)(v11 - v2) < 5)
      {
        v18 = 0;
        v19 = (char *)&__src + v4;
        v20 = v2 - v11;
        do
        {
          v26 = *v2++;
          v25 = v26;
          if ((v26 - 58) > 0xFFFFFFF5)
          {
            v21 = -48;
          }
          else if ((v25 - 97) >= 6)
          {
            if ((v25 - 65) > 5)
              return 0;
            v21 = -55;
          }
          else
          {
            v21 = -87;
          }
          v22 = v21 + v25;
          v23 = 16 * v18;
          v18 = (16 * v18) | v22;
        }
        while (!__CFADD__(v20++, 1));
        *v19 = HIBYTE(v23);
        v19[1] = v18;
        v4 = v33 + 2;
        v33 += 2;
        v2 = v10 + 1;
        if (!v10)
          goto LABEL_54;
      }
      else
      {
        if (v4 > 12)
          return 0;
        if (*v11)
          return 0;
        v30 = 0;
        v31 = 0;
        if (sscanf(v2, "%d.%d.%d.%d", (char *)&v31 + 4, &v31, (char *)&v30 + 4, &v30) != 4)
          return 0;
        if (HIDWORD(v31) > 0xFF)
          return 0;
        v12 = v31;
        if ((v31 & 0x80000000) != 0)
          return 0;
        if ((int)v31 > 255)
          return 0;
        v13 = BYTE4(v30);
        if (v30 < 0)
          return 0;
        if (SHIDWORD(v30) > 255)
          return 0;
        v14 = v30;
        if ((v30 & 0x80000000) != 0 || (int)v30 >= 256)
          return 0;
        v15 = (char *)&__src + v4;
        *v15 = BYTE4(v31);
        v15[1] = v12;
        v15[2] = v13;
        v15[3] = v14;
        v4 = v33 + 4;
        v33 += 4;
        v2 = v10 + 1;
        if (!v10)
        {
LABEL_54:
          v27 = __n;
          if ((_DWORD)__n == -1)
          {
            if (v4 != 16)
              return 0;
          }
          else
          {
            if (v4 > 15 || SHIDWORD(__n) > 3)
              return 0;
            if (HIDWORD(__n) == 2)
            {
              if ((_DWORD)__n && v4 != (_DWORD)__n)
                return 0;
            }
            else
            {
              if (HIDWORD(__n) == 3)
              {
                if (v4 <= 0)
                  goto LABEL_69;
                return 0;
              }
              if (!(_DWORD)__n || v4 == (_DWORD)__n)
                return 0;
            }
LABEL_69:
            if ((__n & 0x80000000) == 0)
            {
              if ((_DWORD)__n)
              {
                memcpy(a1, &__src, __n);
                v28 = v27;
              }
              else
              {
                v28 = 0;
              }
              v29 = &a1[v28];
              bzero(v29, (16 - v4));
              if (v4 != (_DWORD)v27)
                memcpy(&v29[-v4 + 16], (char *)&__src + v28, v4 - (int)v27);
              return 16;
            }
          }
          *(_OWORD *)a1 = __src;
          return 16;
        }
      }
    }
  }
  LODWORD(__src) = 0;
  v31 = 0;
  HIDWORD(v30) = 0;
  if (sscanf(v2, "%d.%d.%d.%d", &__src, (char *)&v31 + 4, &v31, (char *)&v30 + 4) != 4)
    return 0;
  if (__src > 0xFF)
    return 0;
  v5 = BYTE4(v31);
  if (v31 < 0)
    return 0;
  if (SHIDWORD(v31) > 255)
    return 0;
  v6 = v31;
  if ((v31 & 0x80000000) != 0)
    return 0;
  if ((int)v31 > 255)
    return 0;
  v7 = BYTE4(v30);
  if (v30 < 0 || SHIDWORD(v30) > 255)
    return 0;
  *a1 = __src;
  a1[1] = v5;
  a1[2] = v6;
  result = 4;
  a1[3] = v7;
  return result;
}

ASN1_OCTET_STRING *__cdecl a2i_IPADDRESS(const char *ipasc)
{
  int v1;
  int v2;
  char *v3;
  _QWORD *v4;
  ASN1_OCTET_STRING *v5;
  uint64_t *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  size_t v10;
  _BYTE data[16];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v1 = x509v3_a2i_ipadd(data, (char *)ipasc);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v3)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v4 = v3;
  *((_QWORD *)v3 + 1) = 0x400000000;
  v5 = (ASN1_OCTET_STRING *)(v3 + 8);
  *(_QWORD *)v3 = 24;
  *((_QWORD *)v3 + 2) = 0;
  v6 = (uint64_t *)(v3 + 16);
  *((_QWORD *)v3 + 3) = 0;
  if (!ASN1_STRING_set((ASN1_STRING *)(v3 + 8), data, v2))
  {
    v7 = *v6;
    if (*v6)
    {
      v9 = *(_QWORD *)(v7 - 8);
      v8 = (void *)(v7 - 8);
      v10 = v9 + 8;
      if (v9 != -8)
        bzero(v8, v10);
      free(v8);
    }
    if (*v4 != -8)
      __memset_chk();
    free(v4);
    return 0;
  }
  return v5;
}

ASN1_OCTET_STRING *__cdecl a2i_IPADDRESS_NC(const char *ipasc)
{
  char *v2;
  ASN1_OCTET_STRING *v3;
  char *v4;
  size_t v5;
  size_t v6;
  _QWORD *v7;
  _QWORD *v8;
  char *v9;
  char *v10;
  int v11;
  int v12;
  int v13;
  char *v14;
  uint64_t *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  size_t v19;
  _BYTE data[32];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v2 = strchr((char *)ipasc, 47);
  v3 = 0;
  if (!ipasc)
    return v3;
  v4 = v2;
  if (!v2)
    return v3;
  v5 = strlen(ipasc);
  v6 = v5 + 1;
  if (v5 == -1)
    return 0;
  if (v6 > 0xFFFFFFFFFFFFFFF7 || (v7 = malloc_type_malloc(v5 + 9, 0x30772F57uLL)) == 0)
  {
LABEL_19:
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v8 = v7;
  *v7 = v6;
  v9 = (char *)(v7 + 1);
  memcpy(v7 + 1, ipasc, v6);
  v10 = &v9[v4 - ipasc];
  *v10 = 0;
  v11 = x509v3_a2i_ipadd(data, v9);
  if (!v11)
  {
    if (*v8 != -8)
      bzero(v8, *v8 + 8);
    goto LABEL_24;
  }
  v12 = v11;
  v13 = x509v3_a2i_ipadd(&data[v11], v10 + 1);
  if (*v8 != -8)
    bzero(v8, *v8 + 8);
  free(v8);
  v3 = 0;
  if (v13 && v12 == v13)
  {
    v14 = (char *)malloc_type_malloc(0x20uLL, 0x30772F57uLL);
    if (v14)
    {
      v8 = v14;
      *((_QWORD *)v14 + 1) = 0x400000000;
      v3 = (ASN1_OCTET_STRING *)(v14 + 8);
      *(_QWORD *)v14 = 24;
      *((_QWORD *)v14 + 2) = 0;
      v15 = (uint64_t *)(v14 + 16);
      *((_QWORD *)v14 + 3) = 0;
      if (!ASN1_STRING_set((ASN1_STRING *)(v14 + 8), data, 2 * v12))
      {
        v16 = *v15;
        if (*v15)
        {
          v18 = *(_QWORD *)(v16 - 8);
          v17 = (void *)(v16 - 8);
          v19 = v18 + 8;
          if (v18 != -8)
            bzero(v17, v19);
          free(v17);
        }
        if (*v8 != -8)
          __memset_chk();
LABEL_24:
        free(v8);
        return 0;
      }
      return v3;
    }
    goto LABEL_19;
  }
  return v3;
}

BOOL equal_email(_BYTE *a1, size_t a2, _BYTE *__s2, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  int v9;
  int v10;
  size_t v12;

  if (a2 != a4)
    return 0;
  v4 = -1;
  do
  {
    v5 = v4;
    if (a2 + v4 == -1)
      goto LABEL_19;
    if (a1[a2 + v4] == 64)
      break;
    --v4;
  }
  while (__s2[a2 + v5] != 64);
  if (!v5)
  {
LABEL_18:
    v12 = a2 + v5;
    if (!v12)
    {
LABEL_19:
      v12 = a2;
      if (!a2)
        return 1;
    }
    return memcmp(a1, __s2, v12) == 0;
  }
  v6 = &a1[a2];
  v7 = v5;
  while (1)
  {
    v9 = v6[v7];
    if (!v6[v7])
      return 0;
    v10 = __s2[a2 + v7];
    if (v9 != v10)
    {
      if ((v9 - 65) < 0x1A)
        v9 += 32;
      if ((v10 - 65) < 0x1A)
        v10 += 32;
      if (v9 != v10)
        return 0;
    }
    if (__CFADD__(v7++, 1))
      goto LABEL_18;
  }
}

uint64_t equal_nocase(_BYTE *a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  int v5;
  int v6;

  if (a2 == a4)
  {
    if (!a2)
      return 1;
    while (1)
    {
      v5 = *a1;
      if (!*a1)
        break;
      v6 = *a3;
      if (v5 != v6)
      {
        if ((v5 - 65) < 0x1A)
          v5 += 32;
        if ((v6 - 65) < 0x1A)
          v6 += 32;
        if (v5 != v6)
          break;
      }
      ++a1;
      ++a3;
      if (!--a2)
        return 1;
    }
  }
  return 0;
}

uint64_t equal_wildcard(char *a1, unint64_t a2, char *a3, unint64_t a4)
{
  unint64_t v4;
  char *v5;
  uint64_t result;
  int v8;
  int v9;
  int v10;
  char *v11;
  int v12;
  unint64_t v13;
  char *v14;
  int v15;
  _BOOL4 v16;
  BOOL v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int64_t v24;
  char *v25;
  _BYTE *v26;
  char *v27;
  char *v28;
  int v29;
  int v30;
  unsigned __int8 *v31;
  char *v32;
  uint64_t v33;
  unsigned __int8 *v34;
  int v35;
  int v36;
  unsigned __int8 *v37;
  unint64_t v38;
  uint64_t v39;
  int v40;
  BOOL v41;

  v4 = a4;
  v5 = a3;
  if (a4 >= 2 && *a3 == 46)
    goto LABEL_3;
  if (!a2)
    return a4 == 0;
  v10 = 0;
  v11 = 0;
  v12 = 1;
  v13 = a2;
  v14 = a1;
  do
  {
    v15 = *v14;
    if (v15 == 42)
    {
      if (v13 == 1)
      {
        v16 = 1;
        if (v11)
          goto LABEL_3;
      }
      else
      {
        v16 = v14[1] == 46;
        if (v11)
          goto LABEL_3;
      }
      if ((((v12 & 8 | v10) == 0) & v12 & v16) != 1)
        goto LABEL_3;
      v10 = 0;
      v12 &= ~1u;
      v11 = v14;
    }
    else
    {
      v17 = (v15 - 58) > 0xFFFFFFF5 || (v15 & 0xFFFFFFDF) - 91 >= 0xFFFFFFE6;
      if (v17)
      {
        if ((v12 & 1) != 0 && v13 >= 4)
        {
          v18 = *v14;
          if ((v18 - 65) < 0x1A)
            v18 += 32;
          if (v18 == 120)
          {
            v19 = v14[1];
            if ((v19 - 65) < 0x1A)
              v19 += 32;
            if (v19 == 110)
            {
              v20 = v14[2];
              if ((v20 - 65) < 0x1A)
                v20 += 32;
              if (v20 == 45)
              {
                v21 = v14[3];
                if ((v21 - 65) < 0x1A)
                  v21 += 32;
                if (v21 == 45)
                  v12 = 8;
              }
            }
          }
        }
        v12 &= 0xFFFFFFFA;
      }
      else if (v15 == 45)
      {
        if ((v12 & 1) != 0)
          goto LABEL_3;
        v12 |= 4u;
      }
      else
      {
        v22 = v12 & 5;
        if (v15 != 46 || v22 != 0)
          goto LABEL_3;
        ++v10;
        v12 = 1;
      }
    }
    ++v14;
    --v13;
  }
  while (v13);
  if ((v12 & 5) != 0 || v10 < 2 || !v11)
  {
LABEL_3:
    if (a2 != a4)
      return 0;
    if (a4)
    {
      while (1)
      {
        v8 = *a1;
        if (!*a1)
          break;
        v9 = *v5;
        if (v8 != v9)
        {
          if ((v8 - 65) < 0x1A)
            v8 += 32;
          if ((v9 - 65) < 0x1A)
            v9 += 32;
          if (v8 != v9)
            break;
        }
        ++a1;
        ++v5;
        if (!--v4)
          return 1;
      }
      return 0;
    }
    return 1;
  }
  else
  {
    v24 = v11 - a1;
    v25 = &a1[a2 + ~(unint64_t)v11];
    if ((unint64_t)&v11[~(unint64_t)v11 + a2] > a4)
      return 0;
    if (v24)
    {
      v26 = (_BYTE *)(a1 - v11);
      v27 = a1;
      v28 = a3;
      do
      {
        v29 = *v27;
        if (!*v27)
          return 0;
        v30 = *v28;
        if (v29 != v30)
        {
          if ((v29 - 65) < 0x1A)
            v29 += 32;
          if ((v30 - 65) < 0x1A)
            v30 += 32;
          if (v29 != v30)
            return 0;
        }
        ++v27;
        ++v28;
        v17 = __CFADD__(v26++, 1);
      }
      while (!v17);
    }
    v31 = (unsigned __int8 *)(v11 + 1);
    if (v25)
    {
      v32 = &a3[a4];
      v33 = v11 - &a1[a2] + 1;
      v34 = v31;
      do
      {
        v35 = v32[v33];
        if (!v32[v33])
          return 0;
        v36 = *v34;
        if (v35 != v36)
        {
          if ((v35 - 65) < 0x1A)
            v35 += 32;
          if ((v36 - 65) < 0x1A)
            v36 += 32;
          if (v35 != v36)
            return 0;
        }
        ++v34;
        v17 = __CFADD__(v33++, 1);
      }
      while (!v17);
    }
    if (v24 || *v31 != 46)
    {
      if (a4 >= 4)
      {
        result = OPENSSL_strncasecmp(a3, "xn--", 4);
        if (!(_DWORD)result)
          return result;
      }
    }
    else if ((char *)a4 == v25)
    {
      return 0;
    }
    v37 = (unsigned __int8 *)&v5[v24];
    v38 = v4 - (_QWORD)v25;
    if (&v5[v4 - (_QWORD)v25] != &v5[v24 + 1])
    {
      if (v38 == v24)
        return 1;
LABEL_96:
      v39 = v4 - a2 + 1;
      result = 1;
      while (1)
      {
        v40 = *v37;
        v41 = v40 != 45 && (v40 - 48) >= 0xA;
        if (v41 && (v40 & 0xFFFFFFDF) - 65 > 0x19)
          break;
        ++v37;
        if (!--v39)
          return result;
      }
      return 0;
    }
    result = 1;
    if (v38 != v24 && *v37 != 42)
      goto LABEL_96;
  }
  return result;
}

BOOL equal_case(const void *a1, size_t __n, void *__s2, uint64_t a4)
{
  if (__n != a4)
    return 0;
  if (__n)
    return memcmp(a1, __s2, __n) == 0;
  return 1;
}

uint64_t do_check_string(ASN1_STRING *in, int a2, uint64_t (*a3)(void), uint64_t a4, int a5, void *__s2, size_t __n, _QWORD *a8)
{
  unsigned __int8 *data;
  uint64_t v15;
  unsigned int v17;
  unsigned __int8 *v18;
  size_t v19;
  unint64_t v20;
  unsigned __int8 *v21;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  BOOL v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  unsigned __int8 *v33;
  uint64_t v34;
  size_t v35;
  unsigned __int8 *out;

  data = in->data;
  if (!data || !in->length)
    return 0;
  if (a2 >= 1)
  {
    if (in->type == a2)
    {
      if (a2 == 22)
      {
        v15 = a3();
        if (!a8)
          return v15;
LABEL_28:
        if ((int)v15 >= 1)
        {
          v25 = OPENSSL_strndup(in->data, in->length);
          *a8 = v25;
          if (!v25)
            return 0xFFFFFFFFLL;
        }
        return v15;
      }
      if (in->length == (_DWORD)__n && (!__n || !memcmp(data, __s2, __n)))
      {
        v15 = 1;
        if (!a8)
          return v15;
        goto LABEL_28;
      }
    }
    return 0;
  }
  out = 0;
  v17 = ASN1_STRING_to_UTF8(&out, in);
  if ((v17 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  if (a5 != 2)
  {
    v19 = v17;
    v18 = out;
    goto LABEL_23;
  }
  v18 = out;
  if (!v17)
    goto LABEL_56;
  v19 = v17;
  v20 = v17 - 1;
  if (out[v20] != 46)
    v20 = v17;
  if (v20 < 2)
  {
    v21 = out;
LABEL_32:
    if (!v20)
    {
      v15 = 0;
      goto LABEL_58;
    }
    goto LABEL_35;
  }
  if (*out == 42)
  {
    v21 = out;
    if (out[1] == 46)
    {
      v21 = out + 2;
      v20 -= 2;
      goto LABEL_32;
    }
  }
  else
  {
    v21 = out;
  }
LABEL_35:
  v26 = 0;
  v27 = 0;
  v28 = 0;
  while (1)
  {
    v29 = v21[v27];
    if ((v29 - 58) > 0xFFFFFFF5 || (v29 & 0xFFFFFFDF) - 91 > 0xFFFFFFE5)
      goto LABEL_37;
    if (v21[v27] <= 0x39u)
      break;
    if (v29 != 58 && v29 != 95)
      goto LABEL_55;
LABEL_37:
    v26 = ++v27 >= v20;
    if (v20 == v27)
      goto LABEL_55;
  }
  if (v29 == 45)
  {
    if (v27 <= v28)
      goto LABEL_55;
    goto LABEL_37;
  }
  if (v29 == 46 && v27 < v20 - 1 && v27 > v28)
  {
    v28 = v27 + 1;
    goto LABEL_37;
  }
LABEL_55:
  if (!v26)
  {
LABEL_56:
    v15 = 0;
    goto LABEL_57;
  }
LABEL_23:
  v23 = ((uint64_t (*)(unsigned __int8 *, size_t, void *, size_t, uint64_t))a3)(v18, v19, __s2, __n, a4);
  v15 = v23;
  if (a8)
  {
    if ((int)v23 >= 1)
    {
      v24 = OPENSSL_strndup(v18, v19);
      *a8 = v24;
      if (!v24)
        return 0xFFFFFFFFLL;
    }
  }
LABEL_57:
  if (!v18)
    return v15;
LABEL_58:
  v34 = *((_QWORD *)v18 - 1);
  v33 = v18 - 8;
  v35 = v34 + 8;
  if (v34 != -8)
    bzero(v33, v35);
  free(v33);
  return v15;
}

uint64_t ec_GFp_mont_mul_public_batch(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _DWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v25;
  int v26;
  unint64_t v27;
  _BOOL4 v28;
  _BOOL4 v29;
  _BOOL4 v30;
  _BOOL4 v31;
  _BOOL4 v32;
  _BOOL4 v33;
  int v34;
  unint64_t v35;
  uint64_t v36;
  int v37;
  unint64_t v38;
  int v39;
  unint64_t v40;
  uint64_t v41;
  _BYTE *v42;
  uint64_t v43;
  _DWORD *v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  _OWORD *v50;
  _OWORD *v51;
  int v52;
  unint64_t v53;
  unsigned int v54;
  _QWORD *v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  _QWORD *v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  uint64_t v70;
  int8x8_t v71;
  unint64_t v72;
  int8x16_t v73;
  uint64_t v74;
  int8x16_t *v75;
  int8x16_t v76;
  int8x16_t v77;
  uint64_t v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int8x16_t v83;
  uint64_t v84;
  int8x16_t *v85;
  int8x16_t v86;
  uint64_t v87;
  _QWORD *v88;
  uint64_t v89;
  unsigned int v90;
  char *v91;
  char *v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  char *v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  uint64_t v112;
  uint64_t v113;
  int8x8_t v114;
  unint64_t v115;
  int8x16_t v116;
  uint64_t v117;
  int8x16_t *v118;
  int8x16_t v119;
  int8x16_t v120;
  uint64_t v121;
  uint64_t *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  int8x16_t v126;
  uint64_t v127;
  int8x16_t *v128;
  int8x16_t v129;
  uint64_t v130;
  _QWORD *v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  _QWORD *v144;
  uint64_t v145;
  size_t v146;
  _BYTE *v147;
  uint64_t v148;
  size_t v149;
  _QWORD *v151;
  _BYTE *v152;
  uint64_t v153;
  _QWORD *v154;
  _QWORD *v155;
  _DWORD *v156;
  char *v157;
  unint64_t v158;
  _BYTE *v159;
  unint64_t v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  _OWORD v165[5];
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;
  _QWORD v171[283];
  char v172;
  _BYTE v173[1603];

  v2 = MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v156 = v3;
  v11 = v10;
  v12 = v2;
  *(_QWORD *)&v173[1587] = *MEMORY[0x24BDAC8D0];
  v13 = *(unsigned int *)(v2 + 264);
  v14 = v13 & ((int)v13 >> 31);
  v15 = 8 * v13 - 8;
  v16 = *(_DWORD *)(v2 + 264);
  while (1)
  {
    v17 = __OFSUB__(v16--, 1);
    if (v16 < 0 != v17)
      break;
    v18 = *(_QWORD *)(v2 + 256);
    v19 = *(_QWORD *)(v18 + v15);
    v15 -= 8;
    if (v19)
    {
      v14 = v16 + 1;
      goto LABEL_14;
    }
  }
  if ((v13 & 0x80000000) == 0)
  {
    v20 = 0;
    if (v4 >= 4)
      goto LABEL_7;
LABEL_28:
    v21 = 0;
    v154 = 0;
    v157 = &v172;
    v159 = v173;
    v35 = v20;
    v160 = v20 + 1;
    if (!v3)
      goto LABEL_42;
    goto LABEL_29;
  }
  v18 = *(_QWORD *)(v2 + 256);
LABEL_14:
  v26 = v14 - 1;
  v27 = *(_QWORD *)(v18 + 8 * v26);
  v28 = v27 != 0;
  v29 = HIDWORD(v27) != 0;
  if (HIDWORD(v27))
    v27 >>= 32;
  v30 = v27 >> 16 != 0;
  if (v27 >> 16)
    v27 >>= 16;
  v31 = v27 > 0xFF;
  if (v27 > 0xFF)
    v27 >>= 8;
  v32 = v27 > 0xF;
  if (v27 > 0xF)
    v27 >>= 4;
  v33 = v27 > 3;
  if (v27 > 3)
    v27 >>= 2;
  v34 = v28 | (v26 << 6) | (32 * v29) | (16 * v30) | (8 * v31) | (4 * v32) | (2 * v33);
  if (v27 <= 1)
    v20 = v34;
  else
    v20 = v34 + 1;
  if (v4 < 4)
    goto LABEL_28;
LABEL_7:
  if (v4 >= 0x7BE2F6CE27AEB4)
  {
    ERR_put_error(14, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 261);
    v21 = 0;
    goto LABEL_11;
  }
  v22 = 529 * v4;
  v23 = malloc_type_malloc(529 * v4 + 8, 0x30772F57uLL);
  v21 = v23;
  if (v23)
  {
    *v23 = v22;
    v21 = v23 + 1;
    bzero(v23 + 1, 529 * v5);
    if (v5 >= 0x25ED097B425ED1)
      goto LABEL_11;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    if (v5 >= 0x25ED097B425ED1)
    {
LABEL_11:
      ERR_put_error(14, 0, 69, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 261);
      v24 = 0;
      v25 = 0;
      if (!v21)
        goto LABEL_130;
      goto LABEL_127;
    }
  }
  v151 = malloc_type_malloc((1728 * v5) | 8, 0x30772F57uLL);
  v25 = v151;
  if (!v151)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    v24 = 0;
    if (!v21)
      goto LABEL_130;
    goto LABEL_127;
  }
  *v151 = 1728 * v5;
  v152 = v151 + 1;
  bzero(v151 + 1, 1728 * v5);
  if (!v21)
  {
    v24 = 0;
    v153 = *((_QWORD *)v152 - 1);
    v147 = v152 - 8;
    v149 = v153 + 8;
    if (v153 == -8)
      goto LABEL_133;
    goto LABEL_132;
  }
  v154 = v152;
  v157 = v152;
  v35 = v20;
  v159 = v21;
  v160 = v20 + 1;
  if (v156)
  {
LABEL_29:
    if ((_DWORD)v35 != -1)
    {
      v36 = 0;
      v37 = *v156 & 0x1F;
      v38 = *(int *)(v12 + 264);
      do
      {
        while (1)
        {
          v39 = v37 - 32;
          v40 = v36 + 5;
          if (v36 + 5 >= v35)
            v39 = v37 & 0xF;
          if ((v37 & 0x10) == 0)
            v39 = v37;
          if ((v37 & 1) != 0)
            v37 -= v39;
          else
            LOBYTE(v39) = 0;
          *((_BYTE *)&v171[216] + v36 + 7) = v39;
          if (v40 >> 6 >= v38)
            break;
          v37 = (v37 >> 1) + 16 * ((*(_QWORD *)&v156[2 * (v40 >> 6)] >> v40) & 1);
          if (v160 == ++v36)
            goto LABEL_41;
        }
        v37 >>= 1;
        ++v36;
      }
      while (v160 != v36);
    }
LABEL_41:
    compute_precomp(v12, (uint64_t)v171, v12 + 16);
  }
LABEL_42:
  v155 = v21;
  v158 = v5;
  if (v5)
  {
    if ((_DWORD)v35 == -1)
    {
      v49 = (uint64_t)v157;
      v48 = v5;
      do
      {
        compute_precomp(v12, v49, v9);
        v9 += 216;
        v49 += 1728;
        --v48;
      }
      while (v48);
    }
    else
    {
      v41 = 0;
      v42 = v159;
      do
      {
        v43 = 0;
        v44 = (_DWORD *)(v7 + 72 * v41);
        v45 = *v44 & 0x1F;
        do
        {
          while (1)
          {
            v46 = v45 - 32;
            v47 = v43 + 5;
            if (v43 + 5 >= v35)
              v46 = v45 & 0xF;
            if ((v45 & 0x10) == 0)
              v46 = v45;
            if ((v45 & 1) != 0)
              v45 -= v46;
            else
              LOBYTE(v46) = 0;
            v42[v43] = v46;
            if (v47 >> 6 >= *(int *)(v12 + 264))
              break;
            v45 = (v45 >> 1) + 16 * ((*(_QWORD *)&v44[2 * (v47 >> 6)] >> v47) & 1);
            if (v160 == ++v43)
              goto LABEL_45;
          }
          v45 >>= 1;
          ++v43;
        }
        while (v160 != v43);
LABEL_45:
        compute_precomp(v12, (uint64_t)&v157[1728 * v41], v9 + 216 * v41);
        ++v41;
        v42 += 529;
      }
      while (v41 != v5);
    }
  }
  v170 = 0;
  v168 = 0u;
  v169 = 0u;
  v166 = 0u;
  v167 = 0u;
  v164 = 0u;
  memset(v165, 0, sizeof(v165));
  v162 = 0u;
  v163 = 0u;
  v161 = 0u;
  if ((_DWORD)v35 != -1)
  {
    v50 = (_OWORD *)(v11 + 72);
    v51 = (_OWORD *)(v11 + 144);
    v52 = 1;
    v53 = v158;
    while (1)
    {
      if (v52)
      {
        if (!v156)
          goto LABEL_92;
      }
      else
      {
        ec_GFp_mont_dbl(v12, (unint64_t *)v11, (unint64_t *)v11);
        if (!v156)
          goto LABEL_92;
      }
      v54 = *((char *)&v171[216] + v35 + 7);
      if (!*((_BYTE *)&v171[216] + v35 + 7))
        goto LABEL_92;
      if ((v54 & 0x80000000) == 0)
      {
        v55 = &v171[27 * (v54 >> 1)];
        v56 = *((_OWORD *)v55 + 3);
        v163 = *((_OWORD *)v55 + 2);
        v164 = v56;
        *(_QWORD *)&v165[0] = v55[8];
        v57 = *((_OWORD *)v55 + 1);
        v161 = *(_OWORD *)v55;
        v162 = v57;
        v58 = *(_OWORD *)(v55 + 11);
        v59 = *(_OWORD *)(v55 + 15);
        *(_OWORD *)((char *)&v165[2] + 8) = *(_OWORD *)(v55 + 13);
        *(_OWORD *)((char *)&v165[3] + 8) = v59;
        *((_QWORD *)&v165[4] + 1) = v55[17];
        *(_OWORD *)((char *)v165 + 8) = *(_OWORD *)(v55 + 9);
        *(_OWORD *)((char *)&v165[1] + 8) = v58;
        v170 = v55[26];
        v60 = *((_OWORD *)v55 + 12);
        v168 = *((_OWORD *)v55 + 11);
        v169 = v60;
        v61 = *((_OWORD *)v55 + 10);
        v166 = *((_OWORD *)v55 + 9);
        v167 = v61;
        goto LABEL_90;
      }
      v62 = &v171[27 * (-v54 >> 1)];
      v63 = *((_OWORD *)v62 + 3);
      v163 = *((_OWORD *)v62 + 2);
      v164 = v63;
      *(_QWORD *)&v165[0] = v62[8];
      v64 = *((_OWORD *)v62 + 1);
      v161 = *(_OWORD *)v62;
      v162 = v64;
      v65 = *(_OWORD *)(v62 + 11);
      v66 = *(_OWORD *)(v62 + 15);
      *(_OWORD *)((char *)&v165[2] + 8) = *(_OWORD *)(v62 + 13);
      *(_OWORD *)((char *)&v165[3] + 8) = v66;
      *((_QWORD *)&v165[4] + 1) = v62[17];
      *(_OWORD *)((char *)v165 + 8) = *(_OWORD *)(v62 + 9);
      *(_OWORD *)((char *)&v165[1] + 8) = v65;
      v170 = v62[26];
      v67 = *((_OWORD *)v62 + 12);
      v168 = *((_OWORD *)v62 + 11);
      v169 = v67;
      v68 = *((_OWORD *)v62 + 10);
      v166 = *((_OWORD *)v62 + 9);
      v167 = v68;
      v69 = *(unsigned int *)(v12 + 328);
      if ((int)v69 < 1)
      {
        v72 = 0;
        goto LABEL_82;
      }
      if (v69 >= 4)
      {
        v70 = v69 & 0x7FFFFFFC;
        v73 = 0uLL;
        v74 = v69 & 0xFFFFFFFC;
        v75 = (int8x16_t *)((char *)&v165[1] + 8);
        v76 = 0uLL;
        do
        {
          v73 = vorrq_s8(v75[-1], v73);
          v76 = vorrq_s8(*v75, v76);
          v75 += 2;
          v74 -= 4;
        }
        while (v74);
        v77 = vorrq_s8(v76, v73);
        v71 = vorr_s8(*(int8x8_t *)v77.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v77, v77, 8uLL));
        if (v70 == v69)
          goto LABEL_79;
      }
      else
      {
        v70 = 0;
        v71 = 0;
      }
      v78 = v69 - v70;
      v79 = (uint64_t *)v165 + v70 + 1;
      do
      {
        v80 = *v79++;
        *(_QWORD *)&v71 |= v80;
        --v78;
      }
      while (v78);
LABEL_79:
      if (v71)
        v72 = -1;
      else
        v72 = 0;
LABEL_82:
      bn_sub_words((unint64_t *)v165 + 1, *(const unint64_t **)(v12 + 320), (const unint64_t *)v165 + 1, v69);
      v81 = *(unsigned int *)(v12 + 328);
      if ((int)v81 < 1)
        goto LABEL_90;
      if (v81 < 4)
      {
        v82 = 0;
LABEL_88:
        v87 = v81 - v82;
        v88 = (_QWORD *)v165 + v82 + 1;
        do
        {
          *v88++ &= v72;
          --v87;
        }
        while (v87);
        goto LABEL_90;
      }
      v82 = v81 & 0x7FFFFFFC;
      v83 = (int8x16_t)vdupq_n_s64(v72);
      v84 = v81 & 0xFFFFFFFC;
      v85 = (int8x16_t *)((char *)&v165[1] + 8);
      do
      {
        v86 = vandq_s8(*v85, v83);
        v85[-1] = vandq_s8(v85[-1], v83);
        *v85 = v86;
        v85 += 2;
        v84 -= 4;
      }
      while (v84);
      if (v82 != v81)
        goto LABEL_88;
LABEL_90:
      if (!v52)
      {
        ec_GFp_mont_add(v12, (unint64_t *)v11, (unint64_t *)v11, (unint64_t *)&v161);
LABEL_92:
        if (v53)
          goto LABEL_93;
        goto LABEL_62;
      }
      v52 = 0;
      *(_QWORD *)(v11 + 64) = *(_QWORD *)&v165[0];
      *(_QWORD *)(v11 + 136) = *((_QWORD *)&v165[4] + 1);
      *(_QWORD *)(v11 + 208) = v170;
      v138 = v164;
      *(_OWORD *)(v11 + 32) = v163;
      *(_OWORD *)(v11 + 48) = v138;
      v139 = v162;
      *(_OWORD *)v11 = v161;
      *(_OWORD *)(v11 + 16) = v139;
      v140 = *(_OWORD *)((char *)&v165[3] + 8);
      *(_OWORD *)(v11 + 104) = *(_OWORD *)((char *)&v165[2] + 8);
      *(_OWORD *)(v11 + 120) = v140;
      v141 = *(_OWORD *)((char *)&v165[1] + 8);
      *v50 = *(_OWORD *)((char *)v165 + 8);
      *(_OWORD *)(v11 + 88) = v141;
      v142 = v169;
      *(_OWORD *)(v11 + 176) = v168;
      *(_OWORD *)(v11 + 192) = v142;
      v143 = v167;
      *v51 = v166;
      *(_OWORD *)(v11 + 160) = v143;
      if (v53)
      {
LABEL_93:
        v89 = 0;
        while (1)
        {
          v90 = (char)v159[529 * v89 + v35];
          if (v159[529 * v89 + v35])
            break;
LABEL_96:
          if (++v89 == v53)
            goto LABEL_62;
        }
        v91 = &v157[1728 * v89];
        if ((v90 & 0x80000000) == 0)
        {
          v92 = &v91[216 * (v90 >> 1)];
          v161 = *(_OWORD *)v92;
          v93 = *((_OWORD *)v92 + 1);
          v94 = *((_OWORD *)v92 + 2);
          v95 = *((_OWORD *)v92 + 3);
          *(_QWORD *)&v165[0] = *((_QWORD *)v92 + 8);
          v163 = v94;
          v164 = v95;
          v162 = v93;
          v96 = *(_OWORD *)(v92 + 104);
          v97 = *(_OWORD *)(v92 + 120);
          v98 = *(_OWORD *)(v92 + 88);
          *((_QWORD *)&v165[4] + 1) = *((_QWORD *)v92 + 17);
          *(_OWORD *)((char *)&v165[2] + 8) = v96;
          *(_OWORD *)((char *)&v165[3] + 8) = v97;
          *(_OWORD *)((char *)&v165[1] + 8) = v98;
          *(_OWORD *)((char *)v165 + 8) = *(_OWORD *)(v92 + 72);
          v100 = *((_OWORD *)v92 + 11);
          v99 = *((_OWORD *)v92 + 12);
          v101 = *((_OWORD *)v92 + 10);
          v170 = *((_QWORD *)v92 + 26);
          v168 = v100;
          v169 = v99;
          v167 = v101;
          v166 = *((_OWORD *)v92 + 9);
          goto LABEL_120;
        }
        v102 = &v91[216 * (-v90 >> 1)];
        v161 = *(_OWORD *)v102;
        v103 = *((_OWORD *)v102 + 1);
        v104 = *((_OWORD *)v102 + 2);
        v105 = *((_OWORD *)v102 + 3);
        *(_QWORD *)&v165[0] = *((_QWORD *)v102 + 8);
        v163 = v104;
        v164 = v105;
        v162 = v103;
        v106 = *(_OWORD *)(v102 + 104);
        v107 = *(_OWORD *)(v102 + 120);
        v108 = *(_OWORD *)(v102 + 88);
        *((_QWORD *)&v165[4] + 1) = *((_QWORD *)v102 + 17);
        *(_OWORD *)((char *)&v165[2] + 8) = v106;
        *(_OWORD *)((char *)&v165[3] + 8) = v107;
        *(_OWORD *)((char *)&v165[1] + 8) = v108;
        *(_OWORD *)((char *)v165 + 8) = *(_OWORD *)(v102 + 72);
        v110 = *((_OWORD *)v102 + 11);
        v109 = *((_OWORD *)v102 + 12);
        v111 = *((_OWORD *)v102 + 10);
        v170 = *((_QWORD *)v102 + 26);
        v168 = v110;
        v169 = v109;
        v167 = v111;
        v166 = *((_OWORD *)v102 + 9);
        v112 = *(unsigned int *)(v12 + 328);
        if ((int)v112 < 1)
        {
          v115 = 0;
        }
        else
        {
          if (v112 < 4)
          {
            v113 = 0;
            v114 = 0;
            goto LABEL_107;
          }
          v113 = v112 & 0x7FFFFFFC;
          v116 = 0uLL;
          v117 = v112 & 0xFFFFFFFC;
          v118 = (int8x16_t *)((char *)&v165[1] + 8);
          v119 = 0uLL;
          do
          {
            v116 = vorrq_s8(v118[-1], v116);
            v119 = vorrq_s8(*v118, v119);
            v118 += 2;
            v117 -= 4;
          }
          while (v117);
          v120 = vorrq_s8(v119, v116);
          v114 = vorr_s8(*(int8x8_t *)v120.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v120, v120, 8uLL));
          if (v113 != v112)
          {
LABEL_107:
            v121 = v112 - v113;
            v122 = (uint64_t *)v165 + v113 + 1;
            do
            {
              v123 = *v122++;
              *(_QWORD *)&v114 |= v123;
              --v121;
            }
            while (v121);
          }
          if (v114)
            v115 = -1;
          else
            v115 = 0;
        }
        bn_sub_words((unint64_t *)v165 + 1, *(const unint64_t **)(v12 + 320), (const unint64_t *)v165 + 1, v112);
        v124 = *(unsigned int *)(v12 + 328);
        if ((int)v124 < 1)
          goto LABEL_120;
        if (v124 < 4)
        {
          v125 = 0;
          goto LABEL_118;
        }
        v125 = v124 & 0x7FFFFFFC;
        v126 = (int8x16_t)vdupq_n_s64(v115);
        v127 = v124 & 0xFFFFFFFC;
        v128 = (int8x16_t *)((char *)&v165[1] + 8);
        do
        {
          v129 = vandq_s8(*v128, v126);
          v128[-1] = vandq_s8(v128[-1], v126);
          *v128 = v129;
          v128 += 2;
          v127 -= 4;
        }
        while (v127);
        if (v125 != v124)
        {
LABEL_118:
          v130 = v124 - v125;
          v131 = (_QWORD *)v165 + v125 + 1;
          do
          {
            *v131++ &= v115;
            --v130;
          }
          while (v130);
        }
LABEL_120:
        if (v52)
        {
          v52 = 0;
          *(_QWORD *)(v11 + 64) = *(_QWORD *)&v165[0];
          *(_QWORD *)(v11 + 136) = *((_QWORD *)&v165[4] + 1);
          *(_QWORD *)(v11 + 208) = v170;
          v132 = v164;
          *(_OWORD *)(v11 + 32) = v163;
          *(_OWORD *)(v11 + 48) = v132;
          v133 = v162;
          *(_OWORD *)v11 = v161;
          *(_OWORD *)(v11 + 16) = v133;
          v134 = *(_OWORD *)((char *)&v165[3] + 8);
          *(_OWORD *)(v11 + 104) = *(_OWORD *)((char *)&v165[2] + 8);
          *(_OWORD *)(v11 + 120) = v134;
          v135 = *(_OWORD *)((char *)&v165[1] + 8);
          *v50 = *(_OWORD *)((char *)v165 + 8);
          *(_OWORD *)(v11 + 88) = v135;
          v136 = v169;
          *(_OWORD *)(v11 + 176) = v168;
          *(_OWORD *)(v11 + 192) = v136;
          v137 = v167;
          *v51 = v166;
          *(_OWORD *)(v11 + 160) = v137;
        }
        else
        {
          ec_GFp_mont_add(v12, (unint64_t *)v11, (unint64_t *)v11, (unint64_t *)&v161);
        }
        v53 = v158;
        goto LABEL_96;
      }
LABEL_62:
      if (--v35 >= v160)
      {
        if (!v52)
          goto LABEL_126;
        break;
      }
    }
  }
  *(_QWORD *)(v11 + 64) = 0;
  *(_OWORD *)(v11 + 32) = 0u;
  *(_OWORD *)(v11 + 48) = 0u;
  *(_OWORD *)v11 = 0u;
  *(_OWORD *)(v11 + 16) = 0u;
  *(_OWORD *)(v11 + 72) = 0u;
  *(_OWORD *)(v11 + 88) = 0u;
  *(_OWORD *)(v11 + 104) = 0u;
  *(_OWORD *)(v11 + 120) = 0u;
  *(_QWORD *)(v11 + 136) = 0;
  *(_OWORD *)(v11 + 144) = 0u;
  *(_OWORD *)(v11 + 160) = 0u;
  *(_OWORD *)(v11 + 176) = 0u;
  *(_OWORD *)(v11 + 192) = 0u;
  *(_QWORD *)(v11 + 208) = 0;
LABEL_126:
  v24 = 1;
  v25 = v154;
  v21 = v155;
  if (!v155)
    goto LABEL_130;
LABEL_127:
  v145 = *(v21 - 1);
  v144 = v21 - 1;
  v146 = v145 + 8;
  if (v145 != -8)
    bzero(v144, v146);
  free(v144);
LABEL_130:
  if (v25)
  {
    v148 = *(v25 - 1);
    v147 = v25 - 1;
    v149 = v148 + 8;
    if (v148 == -8)
    {
LABEL_133:
      free(v147);
      return v24;
    }
LABEL_132:
    bzero(v147, v149);
    goto LABEL_133;
  }
  return v24;
}

unint64_t compute_precomp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _OWORD v15[13];
  uint64_t v16;

  *(_OWORD *)a2 = *(_OWORD *)a3;
  v5 = *(_OWORD *)(a3 + 16);
  v6 = *(_OWORD *)(a3 + 32);
  v7 = *(_OWORD *)(a3 + 48);
  *(_QWORD *)(a2 + 64) = *(_QWORD *)(a3 + 64);
  *(_OWORD *)(a2 + 32) = v6;
  *(_OWORD *)(a2 + 48) = v7;
  *(_OWORD *)(a2 + 16) = v5;
  v8 = *(_OWORD *)(a3 + 104);
  v9 = *(_OWORD *)(a3 + 120);
  v10 = *(_QWORD *)(a3 + 136);
  *(_OWORD *)(a2 + 88) = *(_OWORD *)(a3 + 88);
  *(_QWORD *)(a2 + 136) = v10;
  *(_OWORD *)(a2 + 120) = v9;
  *(_OWORD *)(a2 + 104) = v8;
  *(_OWORD *)(a2 + 72) = *(_OWORD *)(a3 + 72);
  v12 = *(_OWORD *)(a3 + 176);
  v11 = *(_OWORD *)(a3 + 192);
  v13 = *(_OWORD *)(a3 + 160);
  *(_QWORD *)(a2 + 208) = *(_QWORD *)(a3 + 208);
  *(_OWORD *)(a2 + 176) = v12;
  *(_OWORD *)(a2 + 192) = v11;
  *(_OWORD *)(a2 + 160) = v13;
  *(_OWORD *)(a2 + 144) = *(_OWORD *)(a3 + 144);
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  ec_GFp_mont_dbl(a1, (unint64_t *)v15, (unint64_t *)a3);
  ec_GFp_mont_add(a1, (unint64_t *)(a2 + 216), (unint64_t *)a2, (unint64_t *)v15);
  ec_GFp_mont_add(a1, (unint64_t *)(a2 + 432), (unint64_t *)(a2 + 216), (unint64_t *)v15);
  ec_GFp_mont_add(a1, (unint64_t *)(a2 + 648), (unint64_t *)(a2 + 432), (unint64_t *)v15);
  ec_GFp_mont_add(a1, (unint64_t *)(a2 + 864), (unint64_t *)(a2 + 648), (unint64_t *)v15);
  ec_GFp_mont_add(a1, (unint64_t *)(a2 + 1080), (unint64_t *)(a2 + 864), (unint64_t *)v15);
  ec_GFp_mont_add(a1, (unint64_t *)(a2 + 1296), (unint64_t *)(a2 + 1080), (unint64_t *)v15);
  return ec_GFp_mont_add(a1, (unint64_t *)(a2 + 1512), (unint64_t *)(a2 + 1296), (unint64_t *)v15);
}

int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b)
{
  size_t entries_low;
  int entries;
  int result;
  const X509_NAME *v7;

  if (!a->hash || a->modified)
  {
    v7 = a;
    if ((asn1_item_ex_i2d_opt((unint64_t **)&v7, 0, (uint64_t)&X509_NAME_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) != 0)
      return -2;
  }
  if (!b->hash || b->modified)
  {
    v7 = b;
    if ((asn1_item_ex_i2d_opt((unint64_t **)&v7, 0, (uint64_t)&X509_NAME_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) != 0)
      return -2;
  }
  entries_low = SLODWORD(a[1].entries);
  entries = (int)b[1].entries;
  result = entries_low - entries;
  if ((_DWORD)entries_low == entries)
  {
    if ((_DWORD)entries_low)
      return memcmp((const void *)a->hash, (const void *)b->hash, entries_low);
    else
      return 0;
  }
  return result;
}

int X509_subject_name_cmp(const X509 *a, const X509 *b)
{
  X509_NAME *subject;
  X509_NAME *v3;
  size_t entries_low;
  int entries;
  int result;
  X509_NAME *v7;

  subject = a->cert_info->subject;
  v3 = b->cert_info->subject;
  if (!subject->hash || subject->modified)
  {
    v7 = a->cert_info->subject;
    if ((asn1_item_ex_i2d_opt((unint64_t **)&v7, 0, (uint64_t)&X509_NAME_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) != 0)
      return -2;
  }
  if (!v3->hash || v3->modified)
  {
    v7 = v3;
    if ((asn1_item_ex_i2d_opt((unint64_t **)&v7, 0, (uint64_t)&X509_NAME_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) != 0)
      return -2;
  }
  entries_low = SLODWORD(subject[1].entries);
  entries = (int)v3[1].entries;
  result = entries_low - entries;
  if ((_DWORD)entries_low == entries)
  {
    if ((_DWORD)entries_low)
      return memcmp((const void *)subject->hash, (const void *)v3->hash, entries_low);
    else
      return 0;
  }
  return result;
}

int X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b)
{
  X509_NAME *issuer;
  X509_NAME *v3;
  size_t entries_low;
  int entries;
  int result;
  X509_NAME *v7;

  issuer = a->crl->issuer;
  v3 = b->crl->issuer;
  if (!issuer->hash || issuer->modified)
  {
    v7 = a->crl->issuer;
    if ((asn1_item_ex_i2d_opt((unint64_t **)&v7, 0, (uint64_t)&X509_NAME_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) != 0)
      return -2;
  }
  if (!v3->hash || v3->modified)
  {
    v7 = v3;
    if ((asn1_item_ex_i2d_opt((unint64_t **)&v7, 0, (uint64_t)&X509_NAME_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) != 0)
      return -2;
  }
  entries_low = SLODWORD(issuer[1].entries);
  entries = (int)v3[1].entries;
  result = entries_low - entries;
  if ((_DWORD)entries_low == entries)
  {
    if ((_DWORD)entries_low)
      return memcmp((const void *)issuer->hash, (const void *)v3->hash, entries_low);
    else
      return 0;
  }
  return result;
}

int X509_cmp(const X509 *a, const X509 *b)
{
  unint64_t v4;
  unint64_t v5;

  x509v3_cache_extensions((const void ****)a);
  x509v3_cache_extensions((const void ****)b);
  v4 = bswap64((unint64_t)a->skid);
  v5 = bswap64((unint64_t)b->skid);
  if (v4 == v5)
  {
    v4 = bswap64((unint64_t)a->akid);
    v5 = bswap64((unint64_t)b->akid);
    if (v4 == v5)
    {
      v4 = bswap64((unint64_t)a->policy_cache);
      v5 = bswap64((unint64_t)b->policy_cache);
      if (v4 == v5)
      {
        v4 = bswap64(*(_QWORD *)a->sha1_hash);
        v5 = bswap64(*(_QWORD *)b->sha1_hash);
        if (v4 == v5)
          return 0;
      }
    }
  }
  if (v4 < v5)
    return -1;
  return 1;
}

X509_STORE *X509_STORE_new(void)
{
  char *v0;
  unsigned int *v1;
  X509_STORE *v2;
  pthread_rwlock_t *v3;
  char *v4;
  char *v5;
  unsigned int *v7;
  unsigned int i;
  unsigned int v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  void (*v15)(_QWORD);
  void *v16;
  uint64_t v17;
  size_t v18;
  unint64_t v19;
  void *v20;
  uint64_t v21;
  size_t v22;
  unint64_t *v23;
  uint64_t v24;
  size_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  unint64_t v30;
  void *v31;
  uint64_t v32;
  size_t v33;
  unint64_t *v34;
  uint64_t v35;
  size_t v36;

  v0 = (char *)malloc_type_malloc(0x108uLL, 0x30772F57uLL);
  if (v0)
  {
    v1 = (unsigned int *)v0;
    *(_QWORD *)v0 = 256;
    *(_OWORD *)(v0 + 8) = 0u;
    v2 = (X509_STORE *)(v0 + 8);
    *(_OWORD *)(v0 + 248) = 0u;
    *(_OWORD *)(v0 + 24) = 0u;
    *(_OWORD *)(v0 + 40) = 0u;
    *(_OWORD *)(v0 + 56) = 0u;
    *(_OWORD *)(v0 + 72) = 0u;
    *(_OWORD *)(v0 + 88) = 0u;
    *(_OWORD *)(v0 + 104) = 0u;
    *(_OWORD *)(v0 + 120) = 0u;
    *(_OWORD *)(v0 + 136) = 0u;
    *(_OWORD *)(v0 + 152) = 0u;
    *(_OWORD *)(v0 + 168) = 0u;
    *(_OWORD *)(v0 + 184) = 0u;
    *(_OWORD *)(v0 + 200) = 0u;
    *(_OWORD *)(v0 + 216) = 0u;
    *((_DWORD *)v0 + 64) = 1;
    v3 = (pthread_rwlock_t *)(v0 + 16);
    *(_OWORD *)(v0 + 232) = 0u;
    if (pthread_rwlock_init((pthread_rwlock_t *)(v0 + 16), 0))
LABEL_54:
      abort();
    *((_QWORD *)v1 + 1) = OPENSSL_sk_new((uint64_t)x509_object_cmp_sk);
    *((_QWORD *)v1 + 27) = OPENSSL_sk_new_null();
    v4 = (char *)malloc_type_malloc(0x68uLL, 0x30772F57uLL);
    if (v4)
    {
      *(_QWORD *)v4 = 96;
      *(_OWORD *)(v4 + 8) = 0u;
      v5 = v4 + 8;
      *(_OWORD *)(v4 + 24) = 0u;
      *(_OWORD *)(v4 + 40) = 0u;
      *(_OWORD *)(v4 + 56) = 0u;
      *(_OWORD *)(v4 + 72) = 0u;
      *(_OWORD *)(v4 + 88) = 0u;
      *((_DWORD *)v4 + 8) = -1;
      *((_QWORD *)v1 + 28) = v4 + 8;
      if (!*((_QWORD *)v1 + 1))
      {
LABEL_11:
        v7 = v1 + 64;
        for (i = atomic_load(v1 + 64); i != -1; i = v9)
        {
          if (!i)
            goto LABEL_54;
          v9 = __ldaxr(v7);
          if (v9 == i)
          {
            if (!__stlxr(i - 1, v7))
            {
              if (i == 1)
              {
                pthread_rwlock_destroy(v3);
                v10 = (unint64_t *)*((_QWORD *)v1 + 27);
                if (v10)
                {
                  v11 = *v10;
                  if (*v10)
                  {
                    v12 = 0;
                    do
                    {
                      v13 = v10[1];
                      v14 = *(_QWORD *)(v13 + 8 * v12);
                      if (v14)
                      {
                        if (*(_QWORD *)v14)
                        {
                          v15 = *(void (**)(_QWORD))(*(_QWORD *)v14 + 8);
                          if (v15)
                            v15(*(_QWORD *)(v13 + 8 * v12));
                        }
                        v17 = *(_QWORD *)(v14 - 8);
                        v16 = (void *)(v14 - 8);
                        v18 = v17 + 8;
                        if (v17 != -8)
                          bzero(v16, v18);
                        free(v16);
                        v11 = *v10;
                      }
                      ++v12;
                    }
                    while (v12 < v11);
                  }
                  v19 = v10[1];
                  if (v19)
                  {
                    v21 = *(_QWORD *)(v19 - 8);
                    v20 = (void *)(v19 - 8);
                    v22 = v21 + 8;
                    if (v21 != -8)
                      bzero(v20, v22);
                    free(v20);
                  }
                  v24 = *(v10 - 1);
                  v23 = v10 - 1;
                  v25 = v24 + 8;
                  if (v24 != -8)
                    bzero(v23, v25);
                  free(v23);
                }
                v26 = *(unint64_t **)&v2->cache;
                if (v26)
                {
                  v27 = *v26;
                  if (*v26)
                  {
                    v28 = 0;
                    do
                    {
                      v29 = *(char **)(v26[1] + 8 * v28);
                      if (v29)
                      {
                        X509_OBJECT_free(v29);
                        v27 = *v26;
                      }
                      ++v28;
                    }
                    while (v28 < v27);
                  }
                  v30 = v26[1];
                  if (v30)
                  {
                    v32 = *(_QWORD *)(v30 - 8);
                    v31 = (void *)(v30 - 8);
                    v33 = v32 + 8;
                    if (v32 != -8)
                      bzero(v31, v33);
                    free(v31);
                  }
                  v35 = *(v26 - 1);
                  v34 = v26 - 1;
                  v36 = v35 + 8;
                  if (v35 != -8)
                    bzero(v34, v36);
                  free(v34);
                }
                X509_VERIFY_PARAM_free(*((X509_VERIFY_PARAM **)v1 + 28));
                if (*(_QWORD *)v1 != -8)
                  __memset_chk();
                free(v1);
              }
              return 0;
            }
          }
          else
          {
            __clrex();
          }
        }
        return 0;
      }
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v5 = 0;
      *((_QWORD *)v1 + 28) = 0;
      if (!*((_QWORD *)v1 + 1))
        goto LABEL_11;
    }
    if (v5 && *((_QWORD *)v1 + 27))
      return v2;
    goto LABEL_11;
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  return 0;
}

uint64_t x509_object_cmp_sk(const X509_CRL ***a1, const X509_CRL ***a2)
{
  const X509_CRL **v2;
  const X509_CRL **v3;
  int v4;
  int v5;
  uint64_t result;

  v2 = *a1;
  v3 = *a2;
  v4 = *(_DWORD *)*a1;
  v5 = *(_DWORD *)*a2;
  result = (v4 - v5);
  if (v4 == v5)
  {
    if (v4 == 2)
    {
      return X509_CRL_cmp(v2[1], v3[1]);
    }
    else if (v4 == 1)
    {
      return X509_subject_name_cmp((const X509 *)v2[1], (const X509 *)v3[1]);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void X509_STORE_free(X509_STORE *v)
{
  unsigned int *p_references;
  unsigned int i;
  unsigned int v4;
  int (__cdecl *check_crl)(X509_STORE_CTX *, X509_CRL *);
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(_QWORD);
  void *v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  size_t v17;
  char *v18;
  uint64_t v19;
  size_t v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  unint64_t v25;
  void *v26;
  uint64_t v27;
  size_t v28;
  unint64_t *v29;
  uint64_t v30;
  size_t v31;
  int *v32;
  uint64_t v33;
  size_t v34;

  if (v)
  {
    p_references = (unsigned int *)&v[1].references;
    for (i = atomic_load((unsigned int *)&v[1].references); i != -1; i = v4)
    {
      if (!i)
        abort();
      v4 = __ldaxr(p_references);
      if (v4 == i)
      {
        if (!__stlxr(i - 1, p_references))
        {
          if (i == 1)
          {
            pthread_rwlock_destroy((pthread_rwlock_t *)&v->objs);
            check_crl = v[1].check_crl;
            if (check_crl)
            {
              v6 = *(_QWORD *)check_crl;
              if (*(_QWORD *)check_crl)
              {
                v7 = 0;
                do
                {
                  v8 = *((_QWORD *)check_crl + 1);
                  v9 = *(_QWORD *)(v8 + 8 * v7);
                  if (v9)
                  {
                    if (*(_QWORD *)v9)
                    {
                      v10 = *(void (**)(_QWORD))(*(_QWORD *)v9 + 8);
                      if (v10)
                        v10(*(_QWORD *)(v8 + 8 * v7));
                    }
                    v12 = *(_QWORD *)(v9 - 8);
                    v11 = (void *)(v9 - 8);
                    v13 = v12 + 8;
                    if (v12 != -8)
                      bzero(v11, v13);
                    free(v11);
                    v6 = *(_QWORD *)check_crl;
                  }
                  ++v7;
                }
                while (v7 < v6);
              }
              v14 = *((_QWORD *)check_crl + 1);
              if (v14)
              {
                v16 = *(_QWORD *)(v14 - 8);
                v15 = (void *)(v14 - 8);
                v17 = v16 + 8;
                if (v16 != -8)
                  bzero(v15, v17);
                free(v15);
              }
              v19 = *((_QWORD *)check_crl - 1);
              v18 = (char *)check_crl - 8;
              v20 = v19 + 8;
              if (v19 != -8)
                bzero(v18, v20);
              free(v18);
            }
            v21 = *(unint64_t **)&v->cache;
            if (*(_QWORD *)&v->cache)
            {
              v22 = *v21;
              if (*v21)
              {
                v23 = 0;
                do
                {
                  v24 = *(char **)(v21[1] + 8 * v23);
                  if (v24)
                  {
                    X509_OBJECT_free(v24);
                    v22 = *v21;
                  }
                  ++v23;
                }
                while (v23 < v22);
              }
              v25 = v21[1];
              if (v25)
              {
                v27 = *(_QWORD *)(v25 - 8);
                v26 = (void *)(v25 - 8);
                v28 = v27 + 8;
                if (v27 != -8)
                  bzero(v26, v28);
                free(v26);
              }
              v30 = *(v21 - 1);
              v29 = v21 - 1;
              v31 = v30 + 8;
              if (v30 != -8)
                bzero(v29, v31);
              free(v29);
            }
            X509_VERIFY_PARAM_free((X509_VERIFY_PARAM *)v[1].cert_crl);
            v33 = *(_QWORD *)&v[-1].references;
            v32 = &v[-1].references;
            v34 = v33 + 8;
            if (v33 != -8)
              bzero(v32, v34);
            free(v32);
          }
          return;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
}

void X509_OBJECT_free(char *a1)
{
  char *v2;
  uint64_t v3;
  size_t v4;
  uint64_t v5;
  ASN1_VALUE *pval;

  if (a1)
  {
    if (*(_DWORD *)a1 == 2)
    {
      pval = (ASN1_VALUE *)*((_QWORD *)a1 + 1);
      ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&X509_CRL_INFO_it.sname);
      *(_QWORD *)a1 = 0;
      *((_QWORD *)a1 + 1) = 0;
      v5 = *((_QWORD *)a1 - 1);
      v2 = a1 - 8;
      v4 = v5 + 8;
      if (v5 == -8)
        goto LABEL_7;
    }
    else
    {
      if (*(_DWORD *)a1 == 1)
        X509_free(*((X509 **)a1 + 1));
      *(_QWORD *)a1 = 0;
      *((_QWORD *)a1 + 1) = 0;
      v3 = *((_QWORD *)a1 - 1);
      v2 = a1 - 8;
      v4 = v3 + 8;
      if (v3 == -8)
        goto LABEL_7;
    }
    bzero(v2, v4);
LABEL_7:
    free(v2);
  }
}

uint64_t X509_STORE_CTX_get_by_subject(uint64_t **a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v6;
  pthread_rwlock_t *v7;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int (*v12)(uint64_t **, uint64_t *);
  unint64_t v13;
  _QWORD **v14;
  _QWORD **v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t (*v19)(uint64_t **, uint64_t *);
  int v20;
  _QWORD *v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  int (*v25)(void);
  int v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  uint64_t result;
  unsigned int v31;
  char v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int v35;
  char v36;
  _QWORD v38[2];
  __int128 v39;
  _OWORD v40[4];
  _OWORD v41[6];
  uint64_t v42;
  uint64_t v43;
  _OWORD *v44;
  uint64_t v45;
  uint64_t *v46;
  _OWORD v47[5];
  uint64_t v48;
  _OWORD v49[21];
  uint64_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v6 = *a1;
  v7 = (pthread_rwlock_t *)(*a1 + 1);
  if (pthread_rwlock_wrlock(v7))
LABEL_71:
    abort();
  v38[0] = 0;
  v38[1] = 0;
  v8 = *v6;
  v44 = 0;
  v50 = 0;
  memset(v49, 0, sizeof(v49));
  v48 = 0;
  memset(v47, 0, sizeof(v47));
  v43 = a2;
  if (a2 == 2)
  {
    v44 = v47;
    *(_QWORD *)&v47[0] = &v39;
    v9 = v40;
  }
  else
  {
    if (a2 != 1)
      goto LABEL_34;
    v44 = v49;
    *(_QWORD *)&v49[0] = v41;
    v9 = (_QWORD *)&v41[2] + 1;
  }
  v42 = 0;
  memset(v41, 0, sizeof(v41));
  v39 = 0uLL;
  memset(v40, 0, sizeof(v40));
  *v9 = a3;
  OPENSSL_sk_sort(v8, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_X509_OBJECT_call_cmp_func);
  if (v8)
  {
    if (*(_QWORD *)(v8 + 32))
    {
      v10 = *(_QWORD *)v8;
      if (*(_DWORD *)(v8 + 16) || v10 < 2)
      {
        if (v10)
        {
          v18 = 0;
          do
          {
            v11 = v18 + ((v10 - v18 - 1) >> 1);
            v19 = *(uint64_t (**)(uint64_t **, uint64_t *))(v8 + 32);
            v45 = *(_QWORD *)(*(_QWORD *)(v8 + 8) + 8 * v11);
            v46 = &v43;
            v20 = v19(&v46, &v45);
            if (v20 >= 1)
            {
              v18 = v11 + 1;
            }
            else if (v20 < 0)
            {
              v10 = v18 + ((v10 - v18 - 1) >> 1);
            }
            else
            {
              if (v10 - v18 == 1)
                goto LABEL_20;
              v10 = v11 + 1;
            }
          }
          while (v18 < v10);
        }
      }
      else
      {
        v11 = 0;
        while (1)
        {
          v12 = *(unsigned int (**)(uint64_t **, uint64_t *))(v8 + 32);
          v45 = *(_QWORD *)(*(_QWORD *)(v8 + 8) + 8 * v11);
          v46 = &v43;
          if (!v12(&v46, &v45))
            break;
          if (++v11 >= *(_QWORD *)v8)
            goto LABEL_34;
        }
LABEL_20:
        if ((_DWORD)v11 != -1)
        {
          v17 = (int)v11;
          if (*(_QWORD *)v8 > (unint64_t)(int)v11)
            goto LABEL_33;
        }
      }
    }
    else
    {
      v13 = *(_QWORD *)v8;
      if (*(_QWORD *)v8)
      {
        v14 = *(_QWORD ***)(v8 + 8);
        if (*v14 == &v43)
        {
          v17 = 0;
          if (*(_QWORD *)v8)
          {
LABEL_33:
            v21 = *(_QWORD **)(*(_QWORD *)(v8 + 8) + 8 * v17);
            goto LABEL_35;
          }
        }
        else
        {
          v11 = 0;
          v15 = v14 + 1;
          while (v13 - 1 != v11)
          {
            v16 = v15[v11++];
            if (v16 == &v43)
            {
              if (v11 >= v13)
                break;
              goto LABEL_20;
            }
          }
        }
      }
    }
  }
LABEL_34:
  v21 = 0;
LABEL_35:
  if (pthread_rwlock_unlock(v7))
    goto LABEL_71;
  if (a2 == 2 || !v21)
  {
    v22 = (unint64_t *)v6[26];
    if (v22)
    {
      v23 = 0;
      do
      {
        if (v23 >= *v22)
          break;
        v24 = *(_QWORD *)(v22[1] + 8 * v23);
        if (*(_QWORD *)v24)
        {
          v25 = *(int (**)(void))(*(_QWORD *)v24 + 24);
          if (v25)
          {
            if (v25() > 0)
            {
              v21 = v38;
              goto LABEL_48;
            }
            v22 = (unint64_t *)v6[26];
          }
        }
        ++v23;
      }
      while (v22);
    }
    if (!v21)
      return 0;
  }
LABEL_48:
  v26 = *(_DWORD *)v21;
  *(_DWORD *)a4 = *(_DWORD *)v21;
  v27 = v21[1];
  *(_QWORD *)(a4 + 8) = v27;
  if (v26 == 2)
  {
    v33 = (unsigned int *)(v27 + 24);
    v34 = atomic_load(v33);
    result = 1;
    if (v34 == -1)
      return result;
    while (1)
    {
      v35 = __ldaxr(v33);
      if (v35 == v34)
      {
        if (!__stlxr(v34 + 1, v33))
        {
          v36 = 1;
          goto LABEL_65;
        }
      }
      else
      {
        __clrex();
      }
      v36 = 0;
LABEL_65:
      if ((v36 & 1) == 0)
      {
        v34 = v35;
        if (v35 != -1)
          continue;
      }
      return result;
    }
  }
  if (v26 != 1)
    return 1;
  v28 = (unsigned int *)(v27 + 24);
  v29 = atomic_load(v28);
  result = 1;
  if (v29 != -1)
  {
    while (1)
    {
      v31 = __ldaxr(v28);
      if (v31 == v29)
      {
        if (!__stlxr(v29 + 1, v28))
        {
          v32 = 1;
          goto LABEL_56;
        }
      }
      else
      {
        __clrex();
      }
      v32 = 0;
LABEL_56:
      if ((v32 & 1) == 0)
      {
        v29 = v31;
        if (v31 != -1)
          continue;
      }
      return result;
    }
  }
  return result;
}

uint64_t x509_store_add(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v6;
  const X509_CRL **v7;
  ASN1_VALUE *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  char v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  char v17;
  pthread_rwlock_t *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unsigned int (*v22)(ASN1_VALUE **, uint64_t *);
  unint64_t v23;
  ASN1_VALUE **v24;
  _QWORD *v25;
  ASN1_VALUE *v26;
  unint64_t v27;
  uint64_t (*v28)(ASN1_VALUE **, uint64_t *);
  int v29;
  const X509_CRL *v30;
  const X509_CRL *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const X509_CRL **v43;
  int v44;
  int v45;
  X509_CRL *v46;
  X509_CRL *v47;
  BOOL v48;
  BOOL v49;
  uint64_t v52;
  ASN1_VALUE *pval;

  if (!a2)
    return 0;
  v6 = malloc_type_malloc(0x18uLL, 0x30772F57uLL);
  if (v6)
  {
    v7 = (const X509_CRL **)v6;
    *v6 = 16;
    v6[1] = 0;
    v8 = (ASN1_VALUE *)(v6 + 1);
    v6[2] = 0;
    if (a3)
    {
      *((_DWORD *)v6 + 2) = 2;
      v6[2] = a2;
      v9 = (unsigned int *)(a2 + 24);
      v10 = atomic_load((unsigned int *)(a2 + 24));
      if (v10 != -1)
      {
        while (1)
        {
          v11 = __ldaxr(v9);
          if (v11 == v10)
          {
            if (!__stlxr(v10 + 1, v9))
            {
              v12 = 1;
              goto LABEL_10;
            }
          }
          else
          {
            __clrex();
          }
          v12 = 0;
LABEL_10:
          if ((v12 & 1) == 0)
          {
            v10 = v11;
            if (v11 != -1)
              continue;
          }
          goto LABEL_23;
        }
      }
      goto LABEL_23;
    }
    *((_DWORD *)v6 + 2) = 1;
    v6[2] = a2;
    v14 = (unsigned int *)(a2 + 24);
    v15 = atomic_load((unsigned int *)(a2 + 24));
    if (v15 == -1)
    {
LABEL_23:
      v18 = (pthread_rwlock_t *)(a1 + 8);
      if (pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 8)))
        goto LABEL_99;
      v19 = *(_QWORD *)a1;
      OPENSSL_sk_sort(*(_QWORD *)a1, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_X509_OBJECT_call_cmp_func);
      if (!v19)
        goto LABEL_87;
      if (*(_QWORD *)(v19 + 32))
      {
        v20 = *(_QWORD *)v19;
        if (*(_DWORD *)(v19 + 16) || v20 < 2)
        {
          if (v20)
          {
            v27 = 0;
            while (1)
            {
              v21 = v27 + ((v20 - v27 - 1) >> 1);
              v28 = *(uint64_t (**)(ASN1_VALUE **, uint64_t *))(v19 + 32);
              v52 = *(_QWORD *)(*(_QWORD *)(v19 + 8) + 8 * v21);
              pval = v8;
              v29 = v28(&pval, &v52);
              if (v29 >= 1)
              {
                v27 = v21 + 1;
              }
              else if (v29 < 0)
              {
                v20 = v27 + ((v20 - v27 - 1) >> 1);
              }
              else
              {
                if (v20 - v27 == 1)
                  goto LABEL_38;
                v20 = v21 + 1;
              }
              if (v27 >= v20)
                goto LABEL_87;
            }
          }
          goto LABEL_87;
        }
        v21 = 0;
        while (1)
        {
          v22 = *(unsigned int (**)(ASN1_VALUE **, uint64_t *))(v19 + 32);
          v52 = *(_QWORD *)(*(_QWORD *)(v19 + 8) + 8 * v21);
          pval = v8;
          if (!v22(&pval, &v52))
            break;
          if (++v21 >= *(_QWORD *)v19)
            goto LABEL_87;
        }
      }
      else
      {
        v23 = *(_QWORD *)v19;
        if (!*(_QWORD *)v19)
          goto LABEL_87;
        v24 = *(ASN1_VALUE ***)(v19 + 8);
        if (*v24 == v8)
        {
          v21 = 0;
          if ((*(_DWORD *)v8 - 1) <= 1)
            goto LABEL_65;
LABEL_51:
          if (*(_QWORD *)(*(_QWORD *)(v19 + 8) + 8 * v21))
          {
LABEL_52:
            if (!pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 8)))
            {
              v13 = 1;
              goto LABEL_90;
            }
LABEL_99:
            abort();
          }
LABEL_87:
          v13 = (uint64_t)OPENSSL_sk_insert(*(unint64_t **)a1, (uint64_t)v8, **(_QWORD **)a1);
          if (!pthread_rwlock_unlock(v18))
          {
            if (v13)
              return 1;
LABEL_90:
            if (*(_DWORD *)v8 == 2)
            {
              pval = (ASN1_VALUE *)v7[2];
              ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&X509_CRL_INFO_it.sname);
              if (*v7 == (const X509_CRL *)-8)
                goto LABEL_95;
            }
            else
            {
              if (*(_DWORD *)v8 == 1)
                X509_free((X509 *)v7[2]);
              if (*v7 == (const X509_CRL *)-8)
                goto LABEL_95;
            }
            __memset_chk();
LABEL_95:
            free(v7);
            return v13;
          }
          goto LABEL_99;
        }
        v21 = 0;
        v25 = v24 + 1;
        do
        {
          if (v23 - 1 == v21)
            goto LABEL_87;
          v26 = (ASN1_VALUE *)v25[v21++];
        }
        while (v26 != v8);
        if (v21 >= v23)
          goto LABEL_87;
      }
LABEL_38:
      v23 = *(_QWORD *)v19;
      if ((*(_DWORD *)v8 - 1) >= 2)
      {
        if (v23 <= v21)
          goto LABEL_87;
        goto LABEL_51;
      }
      while (1)
      {
LABEL_65:
        if (v21 >= v23)
          goto LABEL_87;
        v43 = *(const X509_CRL ***)(*(_QWORD *)(v19 + 8) + 8 * v21);
        v44 = *(_DWORD *)v43;
        if (*(_DWORD *)v43 != *(_DWORD *)v8)
          goto LABEL_87;
        if (v44 == 2)
        {
          v45 = X509_CRL_cmp(v43[1], v7[2]);
        }
        else
        {
          if (v44 != 1)
            goto LABEL_73;
          v45 = X509_subject_name_cmp((const X509 *)v43[1], (const X509 *)v7[2]);
        }
        if (v45)
          goto LABEL_87;
        v44 = *(_DWORD *)v8;
LABEL_73:
        if (v44 == 2)
        {
          v30 = v43[1];
          v31 = v7[2];
          v32 = *(uint64_t *)((char *)&v30[1].signature + 4);
          v33 = *(uint64_t *)((char *)&v31[1].signature + 4);
          v34 = *(_QWORD *)(&v30[1].references + 1);
          v35 = *(_QWORD *)(&v31[1].references + 1);
          v36 = *(uint64_t *)((char *)&v30[2].crl + 4);
          v37 = *(uint64_t *)((char *)&v31[2].crl + 4);
          v38 = *(uint64_t *)((char *)&v30[2].sig_alg + 4);
          v39 = *(uint64_t *)((char *)&v31[2].sig_alg + 4);
          if (v32 == v33 && v34 == v35 && v36 == v37 && v38 == v39)
            goto LABEL_52;
        }
        else
        {
          if (v44 != 1)
            goto LABEL_52;
          v46 = (X509_CRL *)v43[1];
          v47 = (X509_CRL *)v7[2];
          x509v3_cache_extensions((const void ****)v46);
          x509v3_cache_extensions((const void ****)v47);
          v48 = v46[3].sig_alg == v47[3].sig_alg && v46[3].signature == v47[3].signature;
          v49 = v48 && *(_QWORD *)&v46[3].references == *(_QWORD *)&v47[3].references;
          if (v49 && v46[4].crl == v47[4].crl)
            goto LABEL_52;
        }
        ++v21;
        v23 = *(_QWORD *)v19;
      }
    }
    while (1)
    {
      v16 = __ldaxr(v14);
      if (v16 == v15)
      {
        if (!__stlxr(v15 + 1, v14))
        {
          v17 = 1;
          goto LABEL_21;
        }
      }
      else
      {
        __clrex();
      }
      v17 = 0;
LABEL_21:
      if ((v17 & 1) == 0)
      {
        v15 = v16;
        if (v16 != -1)
          continue;
      }
      goto LABEL_23;
    }
  }
  ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
  return 0;
}

unint64_t *X509_STORE_CTX_get1_certs(uint64_t **a1, uint64_t a2)
{
  unint64_t *v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  X509 *v14;
  unint64_t v15;
  void *v16;
  uint64_t v17;
  size_t v18;
  unint64_t *v19;
  uint64_t v20;
  size_t v21;
  uint64_t v23;
  X509 *a;
  int v25;
  ASN1_VALUE *pval;

  v4 = (unint64_t *)OPENSSL_sk_new_null();
  if (!v4)
    return v4;
  v25 = 0;
  if (pthread_rwlock_wrlock((pthread_rwlock_t *)(*a1 + 1)))
    goto LABEL_40;
  v5 = x509_object_idx_cnt(**a1, 1u, a2, &v25);
  if ((v5 & 0x80000000) == 0)
  {
LABEL_4:
    if (v25 < 1)
    {
LABEL_15:
      if (!pthread_rwlock_unlock((pthread_rwlock_t *)(*a1 + 1)))
        return v4;
    }
    else
    {
      v6 = 0;
      v7 = v5;
      while (1)
      {
        v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(**a1 + 8) + 8 * v7) + 8);
        if (!OPENSSL_sk_insert(v4, v8, *v4))
          break;
        v9 = (unsigned int *)(v8 + 24);
        v10 = atomic_load((unsigned int *)(v8 + 24));
        if (v10 != -1)
        {
          do
          {
            v11 = __ldaxr(v9);
            if (v11 == v10)
            {
              if (!__stlxr(v10 + 1, v9))
                break;
            }
            else
            {
              __clrex();
            }
            v10 = v11;
          }
          while (v11 != -1);
        }
        ++v6;
        ++v7;
        if (v6 >= v25)
          goto LABEL_15;
      }
      if (!pthread_rwlock_unlock((pthread_rwlock_t *)(*a1 + 1)))
      {
        v12 = *v4;
        if (*v4)
        {
          v13 = 0;
          do
          {
            v14 = *(X509 **)(v4[1] + 8 * v13);
            if (v14)
            {
              X509_free(v14);
              v12 = *v4;
            }
            ++v13;
          }
          while (v13 < v12);
        }
        goto LABEL_32;
      }
    }
LABEL_40:
    abort();
  }
  v23 = 0;
  a = 0;
  if (pthread_rwlock_unlock((pthread_rwlock_t *)(*a1 + 1)))
    goto LABEL_40;
  if (X509_STORE_CTX_get_by_subject(a1, 1u, a2, (uint64_t)&v23))
  {
    if ((_DWORD)v23 == 2)
    {
      pval = (ASN1_VALUE *)a;
      ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&X509_CRL_INFO_it.sname);
    }
    else if ((_DWORD)v23 == 1)
    {
      X509_free(a);
    }
    if (pthread_rwlock_wrlock((pthread_rwlock_t *)(*a1 + 1)))
      goto LABEL_40;
    v5 = x509_object_idx_cnt(**a1, 1u, a2, &v25);
    if ((v5 & 0x80000000) == 0)
      goto LABEL_4;
    if (pthread_rwlock_unlock((pthread_rwlock_t *)(*a1 + 1)))
      goto LABEL_40;
  }
LABEL_32:
  v15 = v4[1];
  if (v15)
  {
    v17 = *(_QWORD *)(v15 - 8);
    v16 = (void *)(v15 - 8);
    v18 = v17 + 8;
    if (v17 != -8)
      bzero(v16, v18);
    free(v16);
  }
  v20 = *(v4 - 1);
  v19 = v4 - 1;
  v21 = v20 + 8;
  if (v20 != -8)
    bzero(v19, v21);
  free(v19);
  return 0;
}

uint64_t x509_object_idx_cnt(uint64_t a1, unsigned int a2, uint64_t a3, int *a4)
{
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int (*v9)(uint64_t **, uint64_t *);
  unint64_t v10;
  _QWORD **v11;
  _QWORD **v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t (*v15)(uint64_t **, uint64_t *);
  int v16;
  unint64_t v18;
  unint64_t v19;
  int v20;
  const X509_CRL **v21;
  int v22;
  int v23;
  __int128 v24;
  _OWORD v25[4];
  _OWORD v26[6];
  uint64_t v27;
  uint64_t v28;
  X509 *b;
  uint64_t v30;
  uint64_t *v31;
  _OWORD v32[5];
  uint64_t v33;
  _OWORD v34[21];
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  b = 0;
  v35 = 0;
  memset(v34, 0, sizeof(v34));
  v33 = 0;
  memset(v32, 0, sizeof(v32));
  v28 = a2;
  if (a2 == 2)
  {
    b = (X509 *)v32;
    *(_QWORD *)&v32[0] = &v24;
    v6 = v25;
  }
  else
  {
    if (a2 != 1)
      return 0xFFFFFFFFLL;
    b = (X509 *)v34;
    *(_QWORD *)&v34[0] = v26;
    v6 = (_QWORD *)&v26[2] + 1;
  }
  v27 = 0;
  memset(v26, 0, sizeof(v26));
  v24 = 0uLL;
  memset(v25, 0, sizeof(v25));
  *v6 = a3;
  OPENSSL_sk_sort(a1, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_X509_OBJECT_call_cmp_func);
  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_QWORD *)(a1 + 32))
  {
    v7 = *(_QWORD *)a1;
    if (!*(_DWORD *)(a1 + 16) && v7 >= 2)
    {
      v8 = 0;
      while (1)
      {
        v9 = *(unsigned int (**)(uint64_t **, uint64_t *))(a1 + 32);
        v30 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v8);
        v31 = &v28;
        if (!v9(&v31, &v30))
          break;
        if (++v8 >= *(_QWORD *)a1)
          return 0xFFFFFFFFLL;
      }
      goto LABEL_32;
    }
    if (v7)
    {
      v14 = 0;
      do
      {
        v8 = v14 + ((v7 - v14 - 1) >> 1);
        v15 = *(uint64_t (**)(uint64_t **, uint64_t *))(a1 + 32);
        v30 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v8);
        v31 = &v28;
        v16 = v15(&v31, &v30);
        if (v16 >= 1)
        {
          v14 = v8 + 1;
        }
        else if (v16 < 0)
        {
          v7 = v14 + ((v7 - v14 - 1) >> 1);
        }
        else
        {
          if (v7 - v14 == 1)
            goto LABEL_32;
          v7 = v8 + 1;
        }
      }
      while (v14 < v7);
    }
    return 0xFFFFFFFFLL;
  }
  v10 = *(_QWORD *)a1;
  if (!*(_QWORD *)a1)
    return 0xFFFFFFFFLL;
  v11 = *(_QWORD ***)(a1 + 8);
  if (*v11 == &v28)
  {
    v8 = 0;
    goto LABEL_32;
  }
  v8 = 0;
  v12 = v11 + 1;
  do
  {
    if (v10 - 1 == v8)
      return 0xFFFFFFFFLL;
    v13 = v12[v8++];
  }
  while (v13 != &v28);
  if (v8 >= v10)
    return 0xFFFFFFFFLL;
LABEL_32:
  if (a4)
  {
    *a4 = 1;
    v18 = v8 + 1;
    v19 = *(_QWORD *)a1;
    if (v8 + 1 < *(_QWORD *)a1)
    {
      v20 = 1;
      do
      {
        v21 = *(const X509_CRL ***)(*(_QWORD *)(a1 + 8) + 8 * v18);
        v22 = *(_DWORD *)v21;
        if (*(_DWORD *)v21 != (_DWORD)v28)
          return v8;
        if (v22 == 2)
        {
          v23 = X509_CRL_cmp(v21[1], (const X509_CRL *)b);
        }
        else
        {
          if (v22 != 1)
            goto LABEL_35;
          v23 = X509_subject_name_cmp((const X509 *)v21[1], b);
        }
        if (v23)
          return v8;
        v20 = *a4;
        v19 = *(_QWORD *)a1;
LABEL_35:
        *a4 = ++v20;
        ++v18;
      }
      while (v18 < v19);
    }
  }
  return v8;
}

unint64_t *X509_STORE_CTX_get1_crls(uint64_t **a1, uint64_t a2)
{
  unint64_t *v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;
  unint64_t *v16;
  uint64_t v17;
  size_t v18;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  X509 *a;
  int v24;
  ASN1_VALUE *pval;

  v4 = (unint64_t *)OPENSSL_sk_new_null();
  if (!v4)
    return v4;
  v24 = 0;
  v22 = 0;
  a = 0;
  if (X509_STORE_CTX_get_by_subject(a1, 2u, a2, (uint64_t)&v22))
  {
    if ((_DWORD)v22 == 2)
    {
      pval = (ASN1_VALUE *)a;
      ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&X509_CRL_INFO_it.sname);
    }
    else if ((_DWORD)v22 == 1)
    {
      X509_free(a);
    }
    if (pthread_rwlock_wrlock((pthread_rwlock_t *)(*a1 + 1)))
      goto LABEL_36;
    v5 = x509_object_idx_cnt(**a1, 2u, a2, &v24);
    if ((v5 & 0x80000000) == 0)
    {
      if (v24 < 1)
      {
LABEL_19:
        if (!pthread_rwlock_unlock((pthread_rwlock_t *)(*a1 + 1)))
          return v4;
      }
      else
      {
        v6 = 0;
        v7 = v5;
        while (1)
        {
          v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(**a1 + 8) + 8 * v7) + 8);
          v9 = (unsigned int *)(v8 + 24);
          v10 = atomic_load((unsigned int *)(v8 + 24));
          if (v10 != -1)
          {
            do
            {
              v11 = __ldaxr(v9);
              if (v11 == v10)
              {
                if (!__stlxr(v10 + 1, v9))
                  break;
              }
              else
              {
                __clrex();
              }
              v10 = v11;
            }
            while (v11 != -1);
          }
          if (!OPENSSL_sk_insert(v4, v8, *v4))
            break;
          ++v6;
          ++v7;
          if (v6 >= v24)
            goto LABEL_19;
        }
        if (!pthread_rwlock_unlock((pthread_rwlock_t *)(*a1 + 1)))
        {
          pval = (ASN1_VALUE *)v8;
          ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&X509_CRL_INFO_it.sname);
          v20 = *v4;
          if (*v4)
          {
            v21 = 0;
            do
            {
              if (*(_QWORD *)(v4[1] + 8 * v21))
              {
                pval = *(ASN1_VALUE **)(v4[1] + 8 * v21);
                ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&X509_CRL_INFO_it.sname);
                v20 = *v4;
              }
              ++v21;
            }
            while (v21 < v20);
          }
          goto LABEL_22;
        }
      }
LABEL_36:
      abort();
    }
    if (pthread_rwlock_unlock((pthread_rwlock_t *)(*a1 + 1)))
      goto LABEL_36;
  }
LABEL_22:
  v12 = v4[1];
  if (v12)
  {
    v14 = *(_QWORD *)(v12 - 8);
    v13 = (void *)(v12 - 8);
    v15 = v14 + 8;
    if (v14 != -8)
      bzero(v13, v15);
    free(v13);
  }
  v17 = *(v4 - 1);
  v16 = v4 - 1;
  v18 = v17 + 8;
  if (v17 != -8)
    bzero(v16, v18);
  free(v16);
  return 0;
}

int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
{
  X509_NAME *v6;
  ASN1_VALUE *v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int (*v12)(_QWORD **, uint64_t *);
  unint64_t v13;
  _QWORD **v14;
  _QWORD **v15;
  _QWORD *v16;
  BOOL v17;
  unint64_t v18;
  uint64_t (*v19)(_QWORD **, uint64_t *);
  int v20;
  unint64_t v21;
  unint64_t *v22;
  uint64_t v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  char v27;
  unsigned int *v29;
  unsigned int v30;
  unsigned int v31;
  char v32;
  uint64_t v33;
  const void ****v34;
  _OWORD v35[2];
  uint64_t v36;
  X509_NAME *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  _QWORD v42[2];
  uint64_t v43;
  _QWORD *v44;
  ASN1_VALUE *pval;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v33 = 0;
  v34 = 0;
  v6 = x->cert_info->issuer;
  if (!X509_STORE_CTX_get_by_subject((uint64_t **)ctx, 1u, (uint64_t)v6, (uint64_t)&v33))
    return 0;
  v7 = (ASN1_VALUE *)v34;
  if (!x509_check_issued_with_callback((uint64_t)ctx, (const void ****)x, v34))
  {
    if ((_DWORD)v33 == 2)
    {
      pval = v7;
      ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&X509_CRL_INFO_it.sname);
    }
    else if ((_DWORD)v33 == 1)
    {
      X509_free((X509 *)v7);
    }
    if (pthread_rwlock_wrlock((pthread_rwlock_t *)&ctx->ctx->objs))
      goto LABEL_67;
    v9 = *(_QWORD *)&ctx->ctx->cache;
    v65 = 0u;
    v66 = 0u;
    v63 = 0u;
    v64 = 0u;
    v62 = 0u;
    v61 = 0u;
    v60 = 0u;
    v59 = 0u;
    v58 = 0u;
    v57 = 0u;
    v56 = 0u;
    v55 = 0u;
    v54 = 0u;
    v53 = 0u;
    v52 = 0u;
    v51 = 0u;
    v50 = 0u;
    v49 = 0u;
    v48 = 0u;
    v47 = 0u;
    v46 = 0u;
    v42[0] = 1;
    v42[1] = &pval;
    pval = (ASN1_VALUE *)v35;
    memset(v35, 0, sizeof(v35));
    v36 = 0;
    v38 = 0u;
    v39 = 0u;
    v40 = 0u;
    v41 = 0;
    v37 = v6;
    OPENSSL_sk_sort(v9, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_X509_OBJECT_call_cmp_func);
    if (v9)
    {
      if (*(_QWORD *)(v9 + 32))
      {
        v10 = *(_QWORD *)v9;
        if (!*(_DWORD *)(v9 + 16) && v10 >= 2)
        {
          v11 = 0;
          while (1)
          {
            v12 = *(unsigned int (**)(_QWORD **, uint64_t *))(v9 + 32);
            v43 = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 8 * v11);
            v44 = v42;
            if (!v12(&v44, &v43))
              goto LABEL_34;
            if (++v11 >= *(_QWORD *)v9)
              goto LABEL_54;
          }
        }
        if (v10)
        {
          v18 = 0;
          do
          {
            v11 = v18 + ((v10 - v18 - 1) >> 1);
            v19 = *(uint64_t (**)(_QWORD **, uint64_t *))(v9 + 32);
            v43 = *(_QWORD *)(*(_QWORD *)(v9 + 8) + 8 * v11);
            v44 = v42;
            v20 = v19(&v44, &v43);
            if (v20 >= 1)
            {
              v18 = v11 + 1;
            }
            else if (v20 < 0)
            {
              v10 = v18 + ((v10 - v18 - 1) >> 1);
            }
            else
            {
              if (v10 - v18 == 1)
                goto LABEL_34;
              v10 = v11 + 1;
            }
          }
          while (v18 < v10);
        }
      }
      else
      {
        v13 = *(_QWORD *)v9;
        if (*(_QWORD *)v9)
        {
          v14 = *(_QWORD ***)(v9 + 8);
          if (*v14 != v42)
          {
            v11 = 0;
            v15 = v14 + 1;
            do
            {
              if (v13 - 1 == v11)
                goto LABEL_54;
              v16 = v15[v11++];
            }
            while (v16 != v42);
            v17 = v11 >= v13;
            goto LABEL_35;
          }
          LODWORD(v11) = 0;
LABEL_34:
          v17 = 0;
LABEL_35:
          v8 = 0;
          if (!v17 && v11 != 0xFFFFFFFFLL)
          {
            v21 = (int)v11;
            do
            {
              v22 = *(unint64_t **)&ctx->ctx->cache;
              if (!v22)
                goto LABEL_54;
              if (v21 >= *v22)
                goto LABEL_54;
              v23 = *(_QWORD *)(v22[1] + 8 * v21);
              if (*(_DWORD *)v23 != 1 || X509_NAME_cmp(v6, *(const X509_NAME **)(**(_QWORD **)(v23 + 8) + 40)))
                goto LABEL_54;
              ++v21;
            }
            while (!x509_check_issued_with_callback((uint64_t)ctx, (const void ****)x, *(const void *****)(v23 + 8)));
            *issuer = *(X509 **)(v23 + 8);
            if (*(_DWORD *)v23 != 2)
            {
              if (*(_DWORD *)v23 == 1)
              {
                v24 = (unsigned int *)(*(_QWORD *)(v23 + 8) + 24);
                v25 = atomic_load(v24);
                v8 = 1;
                if (v25 != -1)
                {
                  while (1)
                  {
                    v26 = __ldaxr(v24);
                    if (v26 == v25)
                    {
                      if (!__stlxr(v25 + 1, v24))
                      {
                        v27 = 1;
                        goto LABEL_51;
                      }
                    }
                    else
                    {
                      __clrex();
                    }
                    v27 = 0;
LABEL_51:
                    if ((v27 & 1) == 0)
                    {
                      v25 = v26;
                      if (v26 != -1)
                        continue;
                    }
                    goto LABEL_55;
                  }
                }
              }
              else
              {
                v8 = 1;
              }
              goto LABEL_55;
            }
            v29 = (unsigned int *)(*(_QWORD *)(v23 + 8) + 24);
            v30 = atomic_load(v29);
            v8 = 1;
            if (v30 != -1)
            {
              while (1)
              {
                v31 = __ldaxr(v29);
                if (v31 == v30)
                {
                  if (!__stlxr(v30 + 1, v29))
                  {
                    v32 = 1;
                    goto LABEL_63;
                  }
                }
                else
                {
                  __clrex();
                }
                v32 = 0;
LABEL_63:
                if ((v32 & 1) == 0)
                {
                  v30 = v31;
                  if (v31 != -1)
                    continue;
                }
                break;
              }
            }
          }
LABEL_55:
          if (!pthread_rwlock_unlock((pthread_rwlock_t *)&ctx->ctx->objs))
            return v8;
LABEL_67:
          abort();
        }
      }
    }
LABEL_54:
    v8 = 0;
    goto LABEL_55;
  }
  *issuer = (X509 *)v7;
  return 1;
}

uint64_t sk_X509_OBJECT_call_cmp_func(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a3;
  v5 = a2;
  return a1(&v5, &v4);
}

char *__cdecl X509_NAME_oneline(X509_NAME *a, char *buf, int size)
{
  char *v3;
  X509_NAME *v4;
  BUF_MEM *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  STACK *entries;
  int v11;
  unint64_t v12;
  pthread_rwlock_t *v13;
  unint64_t v14;
  char *v15;
  unsigned int v16;
  char *v17;
  pthread_rwlock_t *v18;
  X509_NAME *v19;
  char *v20;
  unsigned int v21;
  unsigned int *v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t i;
  __int128 v29;
  uint64_t v30;
  int v31;
  int v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  _BYTE *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  int *v42;
  uint64_t v43;
  BUF_MEM *v44;
  char *data;
  int v46;
  BUF_MEM *v47;
  char *v48;
  uint64_t v49;
  size_t v50;
  int *p_max;
  uint64_t v52;
  size_t v53;
  int *v54;
  int v56;
  char *v57;
  BUF_MEM *str;
  unint64_t v59;
  char bufa[80];
  __int128 v61;
  uint64_t v62;

  v3 = buf;
  v4 = a;
  v62 = *MEMORY[0x24BDAC8D0];
  if (buf)
  {
    if (size >= 1)
    {
      if (a)
      {
        v5 = 0;
        goto LABEL_10;
      }
      if (size < 2)
      {
        *buf = 0;
        return v3;
      }
      *buf = 78;
      v41 = buf + 1;
      if (size == 2)
      {
LABEL_113:
        *v41 = 0;
        return v3;
      }
      buf[1] = 79;
      if (size == 3)
      {
        buf[2] = 0;
        return v3;
      }
      buf[2] = 32;
      if (size == 4)
      {
        buf[3] = 0;
        return v3;
      }
      buf[3] = 88;
      if (size == 5)
      {
        buf[4] = 0;
        return v3;
      }
      buf[4] = 53;
      if (size == 6)
      {
        buf[5] = 0;
        return v3;
      }
      buf[5] = 48;
      if (size == 7)
      {
        buf[6] = 0;
        return v3;
      }
      buf[6] = 57;
      if (size == 8)
      {
        buf[7] = 0;
        return v3;
      }
      buf[7] = 95;
      if (size == 9)
      {
        buf[8] = 0;
        return v3;
      }
      buf[8] = 78;
      if (size == 10)
      {
        buf[9] = 0;
        return v3;
      }
      buf[9] = 65;
      if (size == 11)
      {
        buf[10] = 0;
        return v3;
      }
      buf[10] = 77;
      if (size == 12)
      {
        v41 = buf + 11;
        goto LABEL_113;
      }
LABEL_78:
      v3[11] = 69;
      v3[12] = 0;
      return v3;
    }
    return 0;
  }
  v6 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
  if (!v6)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
  v7 = v6;
  *v6 = 24;
  v6[1] = 0;
  v5 = (BUF_MEM *)(v6 + 1);
  v6[2] = 0;
  v6[3] = 0;
  v8 = OPENSSL_realloc(0, 0x10CuLL);
  if (!v8)
  {
    v44 = v5;
    data = v5->data;
    if (data)
    {
LABEL_83:
      v47 = v44;
      v49 = *((_QWORD *)data - 1);
      v48 = data - 8;
      v50 = v49 + 8;
      if (v49 != -8)
        bzero(v48, v50);
      free(v48);
      v44 = v47;
    }
LABEL_86:
    v52 = *(_QWORD *)&v44[-1].max;
    p_max = &v44[-1].max;
    v53 = v52 + 8;
    if (v52 != -8)
    {
      v54 = p_max;
      bzero(p_max, v53);
      p_max = v54;
    }
    free(p_max);
    return 0;
  }
  v7[2] = v8;
  v7[3] = 268;
  v9 = v7[1];
  if (v9 <= 0xC7)
  {
    bzero((char *)v8 + v9, 200 - v9);
    v8 = (_QWORD *)v7[2];
  }
  size = 200;
  *(_QWORD *)&v5->length = 200;
  *(_BYTE *)v8 = 0;
  if (!v4)
  {
    v3 = (char *)v7[2];
    if (*v7 != -8)
      __memset_chk();
    free(v7);
    qmemcpy(v3, "NO X509_NAM", 11);
    goto LABEL_78;
  }
LABEL_10:
  v57 = v3;
  str = v5;
  entries = v4->entries;
  if (v4->entries)
  {
    v56 = size;
    v11 = 0;
    v12 = 0;
    v13 = &global_added_lock;
    while (1)
    {
      if (v12 >= *(_QWORD *)&entries->num)
        goto LABEL_65;
      v15 = entries->data[v12];
      v16 = OBJ_obj2nid(*(const ASN1_OBJECT **)v15);
      if (v16)
      {
        if (v16 > 0x3C4)
        {
          if (pthread_rwlock_rdlock(v13) || pthread_rwlock_unlock(v13))
            abort();
        }
        else if (LODWORD(kObjects[5 * v16 - 3]))
        {
          v17 = kObjects[5 * v16 - 5];
          if (v17)
            goto LABEL_24;
          goto LABEL_23;
        }
        ERR_put_error(8, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/obj/obj.c", 373);
      }
LABEL_23:
      v17 = bufa;
      OBJ_obj2txt(bufa, 80, *(const ASN1_OBJECT **)v15, 0);
LABEL_24:
      v59 = v12;
      v18 = v13;
      v19 = v4;
      v20 = v17;
      v21 = strlen(v17);
      v22 = (unsigned int *)*((_QWORD *)v15 + 1);
      v23 = *v22;
      if ((int)v23 > 0x100000)
      {
        v46 = 121;
        goto LABEL_81;
      }
      v24 = v21;
      v25 = v22[1];
      v26 = *((_QWORD *)v22 + 1);
      if ((v23 & 3) != 0 || v25 != 27)
        goto LABEL_36;
      v61 = 0uLL;
      if ((int)v23 < 1)
        goto LABEL_43;
      for (i = 0; i != v23; ++i)
      {
        if (*(_BYTE *)(v26 + i))
          *(_DWORD *)((unint64_t)&v61 & 0xFFFFFFFFFFFFFFF3 | (4 * (i & 3))) = 1;
      }
      if (!(DWORD1(v61) | v61 | DWORD2(v61)))
      {
LABEL_43:
        v61 = xmmword_208F08B10;
        if ((int)v23 < 1)
        {
LABEL_44:
          v31 = 0;
          goto LABEL_45;
        }
      }
      else
      {
LABEL_36:
        *(_QWORD *)&v29 = 0x100000001;
        *((_QWORD *)&v29 + 1) = 0x100000001;
        v61 = v29;
        if ((int)v23 < 1)
          goto LABEL_44;
      }
      v30 = 0;
      v31 = 0;
      do
      {
        if (*(_DWORD *)((unint64_t)&v61 & 0xFFFFFFFFFFFFFFF3 | (4 * (v30 & 3))))
        {
          if (*(unsigned __int8 *)(v26 + v30) - 127 >= 0xFFFFFFA1)
            ++v31;
          else
            v31 += 4;
        }
        ++v30;
      }
      while (v23 != v30);
LABEL_45:
      v32 = v11 + v21 + v31 + 2;
      if (v32 > 0x100000)
      {
        v46 = 157;
LABEL_81:
        ERR_put_error(11, 0, 135, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x509_obj.c", v46);
        v44 = str;
        if (!str)
          return 0;
        data = str->data;
        if (!data)
          goto LABEL_86;
        goto LABEL_83;
      }
      if (str)
      {
        if (!BUF_MEM_grow(str, v11 + v21 + v31 + 3))
        {
          v44 = str;
          data = str->data;
          if (data)
            goto LABEL_83;
          goto LABEL_86;
        }
        v33 = str->data;
      }
      else
      {
        v33 = v57;
        if (v32 >= v56)
        {
          v3 = v57;
          if (v59)
            return v3;
          goto LABEL_73;
        }
      }
      v34 = &v33[v11];
      *v34 = 47;
      v35 = v34 + 1;
      if (v24)
        memcpy(v35, v20, v24);
      v36 = &v35[v24];
      *v36 = 61;
      v37 = v36 + 1;
      if ((int)v23 < 1)
      {
        v4 = v19;
        v13 = v18;
        v14 = v59;
      }
      else
      {
        v38 = 0;
        v39 = *(_QWORD *)(*((_QWORD *)v15 + 1) + 8);
        v4 = v19;
        v13 = v18;
        v14 = v59;
        do
        {
          if (*(_DWORD *)((unint64_t)&v61 & 0xFFFFFFFFFFFFFFF3 | (4 * (v38 & 3))))
          {
            v40 = *(unsigned __int8 *)(v39 + v38);
            if ((v40 - 127) > 0xFFFFFFA0)
            {
              *v37++ = v40;
            }
            else
            {
              *(_WORD *)v37 = 30812;
              v37[2] = X509_NAME_oneline_hex[v40 >> 4];
              v37[3] = X509_NAME_oneline_hex[v40 & 0xF];
              v37 += 4;
            }
          }
          ++v38;
        }
        while (v23 != v38);
      }
      *v37 = 0;
      v12 = v14 + 1;
      entries = v4->entries;
      v11 = v32;
      if (!v4->entries)
        goto LABEL_65;
    }
  }
  v12 = 0;
LABEL_65:
  if (str)
  {
    v42 = &str[-1].max;
    v43 = *(_QWORD *)&str[-1].max;
    v3 = str->data;
    if (v43 != -8)
    {
      bzero(v42, v43 + 8);
      v42 = &str[-1].max;
    }
    free(v42);
    if (!v12)
      goto LABEL_73;
  }
  else
  {
    v3 = v57;
    if (!v12)
LABEL_73:
      *v3 = 0;
  }
  return v3;
}

int X509_check_trust(X509 *x, int id, int flags)
{
  uint64_t (**v5)(uint64_t, uint64_t);
  int result;
  unint64_t **v7;
  unint64_t v8;
  unint64_t *v9;
  int v10;
  unint64_t **v11;
  unint64_t v12;
  unint64_t *v13;
  int v14;
  unint64_t v15;
  unint64_t *v16;
  int v17;
  _BOOL4 v18;
  unint64_t v19;
  unint64_t *v20;
  int v21;

  v5 = (uint64_t (**)(uint64_t, uint64_t))&trstandard;
  result = 1;
  switch(id)
  {
    case -1:
      return result;
    case 0:
      v7 = *(unint64_t ***)&x->sha1_hash[8];
      if (!v7)
        goto LABEL_25;
      v8 = 0;
      while (1)
      {
        v9 = v7[1];
        if (!v9 || v8 >= *v9)
          break;
        v10 = OBJ_obj2nid(*(const ASN1_OBJECT **)(v9[1] + 8 * v8++));
        if (v10 == 910)
          return 2;
      }
      v15 = 0;
      while (1)
      {
        v16 = *v7;
        if (!*v7 || v15 >= *v16)
          break;
        v17 = OBJ_obj2nid(*(const ASN1_OBJECT **)(v16[1] + 8 * v15++));
        if (v17 == 910)
          return 1;
      }
LABEL_25:
      v18 = x509v3_cache_extensions((const void ****)x);
      result = 3;
      if (v18)
      {
        if ((x->ex_data.dummy & 0x2000) != 0)
          return 1;
        else
          return 3;
      }
      return result;
    case 1:
      return v5[1]((uint64_t)v5, (uint64_t)x);
    case 2:
      v5 = (uint64_t (**)(uint64_t, uint64_t))&unk_24C0D48B8;
      return v5[1]((uint64_t)v5, (uint64_t)x);
    case 3:
      v5 = (uint64_t (**)(uint64_t, uint64_t))&unk_24C0D48D0;
      return v5[1]((uint64_t)v5, (uint64_t)x);
    case 4:
      v5 = (uint64_t (**)(uint64_t, uint64_t))&unk_24C0D48E8;
      return v5[1]((uint64_t)v5, (uint64_t)x);
    case 5:
      v5 = (uint64_t (**)(uint64_t, uint64_t))&unk_24C0D4900;
      return v5[1]((uint64_t)v5, (uint64_t)x);
    case 8:
      v5 = (uint64_t (**)(uint64_t, uint64_t))&unk_24C0D4918;
      return v5[1]((uint64_t)v5, (uint64_t)x);
    default:
      v11 = *(unint64_t ***)&x->sha1_hash[8];
      if (!v11)
        return 3;
      v12 = 0;
      break;
  }
  while (1)
  {
    v13 = v11[1];
    if (!v13 || v12 >= *v13)
      break;
    v14 = OBJ_obj2nid(*(const ASN1_OBJECT **)(v13[1] + 8 * v12++));
    if (v14 == id)
      return 2;
  }
  v19 = 0;
  while (1)
  {
    v20 = *v11;
    if (!*v11 || v19 >= *v20)
      break;
    v21 = OBJ_obj2nid(*(const ASN1_OBJECT **)(v20[1] + 8 * v19++));
    if (v21 == id)
      return 1;
  }
  return 3;
}

uint64_t trust_compat(uint64_t a1, uint64_t a2)
{
  _BOOL4 v3;
  uint64_t result;

  v3 = x509v3_cache_extensions((const void ****)a2);
  result = 3;
  if (v3)
  {
    if ((*(_BYTE *)(a2 + 49) & 0x20) != 0)
      return 1;
    else
      return 3;
  }
  return result;
}

uint64_t trust_1oidany(uint64_t a1, uint64_t a2)
{
  unint64_t **v3;
  unint64_t v4;
  int v5;
  unint64_t *v6;
  int v7;
  uint64_t result;
  _BOOL4 v9;
  unint64_t v10;
  unint64_t *v11;
  int v12;

  v3 = *(unint64_t ***)(a2 + 136);
  if (v3 && (*v3 || v3[1]))
  {
    v4 = 0;
    v5 = *(_DWORD *)(a1 + 16);
    while (1)
    {
      v6 = v3[1];
      if (!v6 || v4 >= *v6)
        break;
      v7 = OBJ_obj2nid(*(const ASN1_OBJECT **)(v6[1] + 8 * v4++));
      if (v7 == v5)
        return 2;
    }
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      if (!*v3 || v10 >= *v11)
        break;
      v12 = OBJ_obj2nid(*(const ASN1_OBJECT **)(v11[1] + 8 * v10++));
      if (v12 == v5)
        return 1;
    }
    return 3;
  }
  else
  {
    v9 = x509v3_cache_extensions((const void ****)a2);
    result = 3;
    if (v9)
    {
      if ((*(_BYTE *)(a2 + 49) & 0x20) != 0)
        return 1;
      else
        return 3;
    }
  }
  return result;
}

int X509_verify_cert(X509_STORE_CTX *ctx)
{
  int v2;
  int v3;
  STACK *crls;
  int v5;
  int v6;
  char *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  char v12;
  X509 *cert;
  uint64_t *v14;
  X509 *v15;
  int (__cdecl *check_issued)(X509_STORE_CTX *, X509 *, X509 *);
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int comp;
  int v21;
  const void ****v22;
  X509 *trusted_issuer;
  unint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int *v29;
  unsigned int v30;
  unsigned int v31;
  char v32;
  int (__cdecl *v33)(X509_STORE_CTX *, X509 *, X509 *);
  int v34;
  int v35;
  unint64_t v36;
  uint64_t v37;
  X509 *v38;
  int (__cdecl *v39)(X509_STORE_CTX *, X509 *, X509 *);
  uint64_t v40;
  unsigned int v41;
  int v42;
  unint64_t v43;
  X509 *v44;
  X509 *v45;
  int (__cdecl *v46)(X509_STORE_CTX *, X509 *, X509 *);
  unint64_t get_issuer_low;
  uint64_t v48;
  X509 *v49;
  int v50;
  unsigned int v51;
  uint64_t v52;
  unint64_t *v53;
  unint64_t *v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  BOOL v60;
  unsigned int *v61;
  unsigned int v62;
  unsigned int v63;
  char v64;
  uint64_t v65;
  X509 *v66;
  int v67;
  int (__cdecl *v68)(X509_STORE_CTX *, X509 *, X509 *);
  int v69;
  int (__cdecl *v70)(X509_STORE_CTX *, X509 *, X509 *);
  uint64_t v71;
  X509 *v72;
  int (__cdecl *v73)(X509_STORE_CTX *, X509 *, X509 *);
  int v74;
  int v75;
  int v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  char v82;
  uint64_t v83;
  void *v84;
  uint64_t v85;
  size_t v86;
  uint64_t *v87;
  uint64_t v88;
  size_t v89;
  int (__cdecl *v90)(X509_STORE_CTX *, X509 *, X509 *);
  int v91;
  int v92;

  if (!*(_QWORD *)&ctx->current_method)
  {
    v2 = 122;
    v3 = 183;
    goto LABEL_7;
  }
  if (ctx->check_issued)
  {
    v2 = 66;
    v3 = 191;
LABEL_7:
    ERR_put_error(11, 0, v2, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x509_vfy.c", v3);
    v5 = 0;
    v6 = 65;
    goto LABEL_8;
  }
  crls = ctx->crls;
  if ((BYTE1(crls->data) & 0x30) != 0)
  {
    v2 = 66;
    v3 = 201;
    goto LABEL_7;
  }
  v8 = OPENSSL_sk_new_null();
  ctx->check_issued = (int (__cdecl *)(X509_STORE_CTX *, X509 *, X509 *))v8;
  if (!v8 || !OPENSSL_sk_insert((unint64_t *)v8, *(_QWORD *)&ctx->current_method, *(_QWORD *)v8))
    goto LABEL_22;
  v9 = (unsigned int *)(*(_QWORD *)&ctx->current_method + 24);
  v10 = atomic_load(v9);
  if (v10 != -1)
  {
    while (1)
    {
      v11 = __ldaxr(v9);
      if (v11 == v10)
      {
        if (!__stlxr(v10 + 1, v9))
        {
          v12 = 1;
          goto LABEL_18;
        }
      }
      else
      {
        __clrex();
      }
      v12 = 0;
LABEL_18:
      if ((v12 & 1) == 0)
      {
        v10 = v11;
        if (v11 != -1)
          continue;
      }
      break;
    }
  }
  LODWORD(ctx->get_issuer) = 1;
  cert = ctx->cert;
  if (cert)
  {
    v14 = (uint64_t *)OPENSSL_sk_dup((uint64_t)cert);
    if (!v14)
    {
LABEL_22:
      v15 = 0;
      HIDWORD(ctx->check_revocation) = 17;
LABEL_23:
      X509_free(v15);
      v5 = 0;
      goto LABEL_24;
    }
  }
  else
  {
    v14 = 0;
  }
  check_issued = ctx->check_issued;
  if (!check_issued)
  {
    LODWORD(v17) = 0;
    goto LABEL_31;
  }
  v17 = *(_QWORD *)check_issued;
  v18 = (int)(*(_QWORD *)check_issued - 1);
  if (*(_QWORD *)check_issued <= v18)
  {
LABEL_31:
    v19 = 0;
    goto LABEL_32;
  }
  v19 = *(_QWORD *)(*((_QWORD *)check_issued + 1) + 8 * v18);
LABEL_32:
  comp = (int)crls->comp;
  if (comp <= 2147483644)
    v21 = comp + 2;
  else
    v21 = 0x7FFFFFFF;
  v92 = v21;
  if (v21 > (int)v17)
  {
    if (v14)
    {
      while (1)
      {
        v22 = (const void ****)v19;
        if (!x509v3_cache_extensions((const void ****)v19))
          goto LABEL_200;
        if ((*(_BYTE *)(v19 + 49) & 0x20) != 0)
          goto LABEL_75;
        if ((BYTE1(ctx->crls->data) & 0x80) != 0)
        {
          trusted_issuer = get_trusted_issuer(ctx, (X509 *)v19);
          if (trusted_issuer)
          {
            v21 = v92;
            goto LABEL_214;
          }
        }
        v24 = *v14;
        if (!*v14)
          goto LABEL_75;
        v25 = 0;
        while (1)
        {
          if (v24 <= v25)
          {
            v19 = 0;
            if (X509_NAME_cmp(*(const X509_NAME **)(MEMORY[0] + 40), (const X509_NAME *)(*v22)[3]))
            {
LABEL_46:
              v26 = 29;
              goto LABEL_56;
            }
          }
          else
          {
            v19 = *(_QWORD *)(v14[1] + 8 * v25);
            if (X509_NAME_cmp(*(const X509_NAME **)(*(_QWORD *)v19 + 40), (const X509_NAME *)(*v22)[3]))
              goto LABEL_46;
          }
          if (x509v3_cache_extensions((const void ****)v19) && x509v3_cache_extensions(v22))
          {
            v27 = (uint64_t)v22[9];
            if (!v27 || (v26 = X509_check_akid((_QWORD *)v19, v27)) == 0)
            {
              if ((*(_BYTE *)(v19 + 48) & 2) == 0 || (*(_BYTE *)(v19 + 52) & 4) != 0)
                break;
              v26 = 32;
            }
          }
          else
          {
            v26 = 1;
          }
LABEL_56:
          if (((uint64_t)ctx->crls->data & 1) != 0)
          {
            HIDWORD(ctx->check_revocation) = v26;
            ctx->get_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL **, X509 *))v22;
            v28 = ((uint64_t (*)(_QWORD, X509_STORE_CTX *))ctx->other_ctx)(0, ctx);
            if (v28 >= 2)
              goto LABEL_223;
            if (v28)
              break;
          }
          ++v25;
          v24 = *v14;
          if (v25 >= *v14)
            goto LABEL_75;
        }
        v21 = v92;
        if (!OPENSSL_sk_insert((unint64_t *)ctx->check_issued, v19, *(_QWORD *)ctx->check_issued))
        {
          v5 = 0;
          v15 = 0;
          HIDWORD(ctx->check_revocation) = 17;
          v82 = 1;
          v83 = v14[1];
          if (v83)
            goto LABEL_205;
          goto LABEL_208;
        }
        v29 = (unsigned int *)(v19 + 24);
        v30 = atomic_load((unsigned int *)(v19 + 24));
        if (v30 != -1)
        {
          while (1)
          {
            v31 = __ldaxr(v29);
            if (v31 == v30)
            {
              if (!__stlxr(v30 + 1, v29))
              {
                v32 = 1;
                goto LABEL_66;
              }
            }
            else
            {
              __clrex();
            }
            v32 = 0;
LABEL_66:
            if ((v32 & 1) == 0)
            {
              v30 = v31;
              if (v31 != -1)
                continue;
            }
            break;
          }
        }
        OPENSSL_sk_delete_ptr(v14, v19);
        ++LODWORD(ctx->get_issuer);
        LODWORD(v17) = v17 + 1;
        if ((_DWORD)v17 == v92)
        {
          LODWORD(v17) = v92;
          goto LABEL_76;
        }
      }
    }
    if (!x509v3_cache_extensions((const void ****)v19))
    {
LABEL_200:
      v15 = 0;
LABEL_201:
      v74 = 41;
      goto LABEL_202;
    }
    if ((*(_BYTE *)(v19 + 49) & 0x20) != 0)
    {
LABEL_75:
      v21 = v92;
    }
    else if ((BYTE1(ctx->crls->data) & 0x80) != 0)
    {
      trusted_issuer = get_trusted_issuer(ctx, (X509 *)v19);
      if (trusted_issuer)
LABEL_214:
        X509_free(trusted_issuer);
    }
  }
LABEL_76:
  v15 = 0;
  v91 = 0;
  v33 = ctx->check_issued;
  v34 = v17;
LABEL_77:
  if (v33)
  {
    v35 = *(_QWORD *)v33 - 1;
    v36 = v35;
    if (*(_QWORD *)v33 <= (unint64_t)v35)
      v37 = 0;
    else
      v37 = *(_QWORD *)(*((_QWORD *)v33 + 1) + 8 * v35);
  }
  else
  {
    v37 = 0;
    v35 = -1;
    v36 = -1;
  }
  if (!x509v3_cache_extensions((const void ****)v37))
    goto LABEL_201;
  if ((*(_BYTE *)(v37 + 49) & 0x20) == 0)
  {
    v38 = (X509 *)v37;
    if (v34 < v21)
      goto LABEL_102;
    goto LABEL_108;
  }
  v39 = ctx->check_issued;
  if (!v39 || !*(_QWORD *)v39)
  {
    v15 = 0;
LABEL_97:
    --LODWORD(ctx->get_issuer);
    v42 = v34 - 1;
    LODWORD(v17) = v17 - 1;
    if (v39 && (v43 = v34 - 2, *(_QWORD *)v39 > v43))
    {
      v38 = *(X509 **)(*((_QWORD *)v39 + 1) + 8 * v43);
      --v34;
      if (v42 < v21)
        goto LABEL_102;
    }
    else
    {
      v38 = 0;
      --v34;
      if (v42 < v21)
        goto LABEL_102;
    }
    goto LABEL_108;
  }
  v40 = *(_QWORD *)v39 - 1;
  if (*(_QWORD *)v39 != 1)
  {
    v15 = *(X509 **)(*((_QWORD *)v39 + 1) + 8 * v40);
    *(_QWORD *)v39 = v40;
    goto LABEL_97;
  }
  v38 = get_trusted_issuer(ctx, (X509 *)v37);
  if (v38 && !X509_cmp((const X509 *)v37, v38))
  {
    X509_free((X509 *)v37);
    v73 = ctx->check_issued;
    if (v73 && *(_QWORD *)v73 > v36)
      *(_QWORD *)(*((_QWORD *)v73 + 1) + 8 * v36) = v38;
    LODWORD(ctx->get_issuer) = 0;
    if (v34 < v21)
    {
      while (1)
      {
LABEL_102:
        if (!x509v3_cache_extensions((const void ****)v38))
          goto LABEL_201;
        if ((v38->ex_data.dummy & 0x2000) != 0)
          goto LABEL_108;
        v44 = get_trusted_issuer(ctx, v38);
        if (!v44)
          goto LABEL_108;
        v45 = v44;
        if (!OPENSSL_sk_insert((unint64_t *)ctx->check_issued, (uint64_t)v44, *(_QWORD *)ctx->check_issued))
          break;
        ++v34;
        v38 = v45;
        if (v21 == v34)
        {
          v34 = v21;
          v38 = v45;
          goto LABEL_108;
        }
      }
      X509_free(v45);
      goto LABEL_181;
    }
  }
  else
  {
    X509_free(v38);
    ctx->get_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL **, X509 *))v37;
    LODWORD(ctx->check_revocation) = v35;
    HIDWORD(ctx->check_revocation) = 18;
    v41 = ((uint64_t (*)(_QWORD, X509_STORE_CTX *))ctx->other_ctx)(0, ctx);
    if (v41 >= 2)
      goto LABEL_223;
    if (!v41)
      goto LABEL_203;
    v91 = 1;
    v38 = (X509 *)v37;
    if (v34 < v21)
      goto LABEL_102;
  }
LABEL_108:
  v46 = ctx->check_issued;
  if (!v46)
  {
LABEL_117:
    if ((BYTE2(ctx->crls->data) & 8) == 0)
      goto LABEL_153;
    if (((uint64_t)ctx->get_issuer & 0x80000000) != 0)
      goto LABEL_182;
    goto LABEL_119;
  }
  get_issuer_low = SLODWORD(ctx->get_issuer);
  while (1)
  {
    v48 = *(_QWORD *)v46;
    if (get_issuer_low >= *(_QWORD *)v46)
      break;
    v49 = *(X509 **)(*((_QWORD *)v46 + 1) + 8 * get_issuer_low);
    v50 = X509_check_trust(v49, ctx->crls->num_alloc, 0);
    if (v50 == 2)
    {
      ctx->get_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL **, X509 *))v49;
      LODWORD(ctx->check_revocation) = get_issuer_low;
      HIDWORD(ctx->check_revocation) = 28;
      v51 = ((uint64_t (*)(_QWORD, X509_STORE_CTX *))ctx->other_ctx)(0, ctx);
      if (v51 >= 2)
        goto LABEL_223;
      if (!v51)
        goto LABEL_203;
    }
    else if (v50 == 1)
    {
      goto LABEL_182;
    }
    ++get_issuer_low;
    v46 = ctx->check_issued;
    if (!v46)
      goto LABEL_117;
  }
  if ((BYTE2(ctx->crls->data) & 8) == 0)
    goto LABEL_153;
  if (SLODWORD(ctx->get_issuer) >= (int)v48)
  {
    if (v48)
    {
      v52 = **((_QWORD **)v46 + 1);
      v53 = X509_STORE_CTX_get1_certs((uint64_t **)ctx, *(_QWORD *)(*(_QWORD *)v52 + 40));
      if (!v53)
        goto LABEL_153;
      goto LABEL_120;
    }
LABEL_119:
    v52 = 0;
    v53 = X509_STORE_CTX_get1_certs((uint64_t **)ctx, *(_QWORD *)(MEMORY[0] + 40));
    if (!v53)
      goto LABEL_153;
LABEL_120:
    v54 = v53;
    v55 = *v53;
    if (!*v53)
      goto LABEL_152;
    v56 = 0;
    do
    {
      if (v55 <= v56)
        v57 = 0;
      else
        v57 = *(_QWORD *)(v54[1] + 8 * v56);
      x509v3_cache_extensions((const void ****)v57);
      x509v3_cache_extensions((const void ****)v52);
      v60 = *(_QWORD *)(v57 + 104) == *(_QWORD *)(v52 + 104)
         && *(_QWORD *)(v57 + 112) == *(_QWORD *)(v52 + 112)
         && *(_QWORD *)(v57 + 120) == *(_QWORD *)(v52 + 120)
         && *(_QWORD *)(v57 + 128) == *(_QWORD *)(v52 + 128);
      v55 = *v54;
      if (v60)
        break;
      ++v56;
    }
    while (v56 < v55);
    if (v56 >= v55)
    {
LABEL_152:
      OPENSSL_sk_pop_free_ex(v54, (void (*)(uint64_t))sk_X509_call_free_func, (uint64_t)X509_free);
      goto LABEL_153;
    }
    v61 = (unsigned int *)(v57 + 24);
    v62 = atomic_load((unsigned int *)(v57 + 24));
    if (v62 != -1)
    {
      while (1)
      {
        v63 = __ldaxr(v61);
        if (v63 == v62)
        {
          if (!__stlxr(v62 + 1, v61))
          {
            v64 = 1;
            goto LABEL_143;
          }
        }
        else
        {
          __clrex();
        }
        v64 = 0;
LABEL_143:
        if ((v64 & 1) == 0)
        {
          v62 = v63;
          if (v63 != -1)
            continue;
        }
        OPENSSL_sk_pop_free_ex(v54, (void (*)(uint64_t))sk_X509_call_free_func, (uint64_t)X509_free);
        if (v57)
          goto LABEL_218;
LABEL_153:
        if (((uint64_t)ctx->crls->data & 0x108000) == 0)
        {
          v65 = v17 + 4294967294;
          do
          {
            while (1)
            {
              if ((int)v17 < 2)
                goto LABEL_175;
              v67 = v17;
              v68 = ctx->check_issued;
              if (v68)
              {
                if (*(_QWORD *)v68 > (unint64_t)v65)
                  break;
              }
              v66 = get_trusted_issuer(ctx, 0);
              --v65;
              LODWORD(v17) = v17 - 1;
              if (v66)
                goto LABEL_160;
            }
            v66 = get_trusted_issuer(ctx, *(X509 **)(*((_QWORD *)v68 + 1) + 8 * v65--));
            LODWORD(v17) = v17 - 1;
          }
          while (!v66);
LABEL_160:
          X509_free(v66);
          if (v34 >= v67)
          {
            v69 = v34 + 1;
            do
            {
              while (1)
              {
                v70 = ctx->check_issued;
                if (v70)
                {
                  if (*(_QWORD *)v70)
                    break;
                }
                X509_free(0);
                if (--v69 <= v67)
                  goto LABEL_166;
              }
              v71 = *(_QWORD *)v70 - 1;
              v72 = *(X509 **)(*((_QWORD *)v70 + 1) + 8 * v71);
              *(_QWORD *)v70 = v71;
              X509_free(v72);
              --v69;
            }
            while (v69 > v67);
LABEL_166:
            v34 = v17;
          }
          v33 = ctx->check_issued;
          v21 = v92;
          if (v33)
            LODWORD(ctx->get_issuer) = *(_QWORD *)v33;
          else
            LODWORD(ctx->get_issuer) = 0;
          goto LABEL_77;
        }
LABEL_175:
        if (v91)
          goto LABEL_190;
        if (!v15
          || !x509_check_issued_with_callback((uint64_t)ctx, (const void ****)v38, (const void ****)v15))
        {
          if (SLODWORD(ctx->get_issuer) >= v34)
            v76 = 20;
          else
            v76 = 2;
          HIDWORD(ctx->check_revocation) = v76;
          ctx->get_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL **, X509 *))v38;
          goto LABEL_188;
        }
        if (OPENSSL_sk_insert((unint64_t *)ctx->check_issued, (uint64_t)v15, *(_QWORD *)ctx->check_issued))
        {
          LODWORD(ctx->get_issuer) = ++v34;
          ctx->get_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL **, X509 *))v15;
          HIDWORD(ctx->check_revocation) = 19;
          v15 = 0;
LABEL_188:
          LODWORD(ctx->check_revocation) = v34 - 1;
          v77 = ((uint64_t (*)(_QWORD, X509_STORE_CTX *))ctx->other_ctx)(0, ctx);
          if (v77 >= 2)
LABEL_223:
            abort();
          if (!v77)
            goto LABEL_203;
LABEL_190:
          v75 = 1;
          if (!check_chain_extensions((uint64_t)ctx))
            goto LABEL_203;
          goto LABEL_191;
        }
LABEL_181:
        v74 = 17;
LABEL_202:
        HIDWORD(ctx->check_revocation) = v74;
        goto LABEL_203;
      }
    }
    OPENSSL_sk_pop_free_ex(v54, (void (*)(uint64_t))sk_X509_call_free_func, (uint64_t)X509_free);
LABEL_218:
    v90 = ctx->check_issued;
    if (v90 && *(_QWORD *)v90)
      **((_QWORD **)v90 + 1) = v57;
    X509_free((X509 *)v52);
    LODWORD(ctx->get_issuer) = 0;
    v75 = v91;
    if (check_chain_extensions((uint64_t)ctx))
      goto LABEL_191;
LABEL_203:
    if (v14)
    {
      v5 = 0;
      v82 = 1;
      v83 = v14[1];
      if (!v83)
        goto LABEL_208;
      goto LABEL_205;
    }
    goto LABEL_23;
  }
LABEL_182:
  v75 = v91;
  if (!check_chain_extensions((uint64_t)ctx))
    goto LABEL_203;
LABEL_191:
  if (!check_id((uint64_t)ctx)
    || !check_revocation((uint64_t)ctx)
    || !internal_verify((uint64_t)ctx)
    || !check_name_constraints((uint64_t)ctx)
    || !v75 && !check_policy((uint64_t)ctx, v78, v79, v80, v81))
  {
    goto LABEL_203;
  }
  if (v14)
  {
    v82 = 0;
    v5 = 1;
    v83 = v14[1];
    if (!v83)
      goto LABEL_208;
LABEL_205:
    v85 = *(_QWORD *)(v83 - 8);
    v84 = (void *)(v83 - 8);
    v86 = v85 + 8;
    if (v85 != -8)
      bzero(v84, v86);
    free(v84);
LABEL_208:
    v88 = *(v14 - 1);
    v87 = v14 - 1;
    v89 = v88 + 8;
    if (v88 != -8)
      bzero(v87, v89);
    free(v87);
    X509_free(v15);
    if ((v82 & 1) != 0)
    {
LABEL_24:
      if (!HIDWORD(ctx->check_revocation))
      {
        v6 = 1;
LABEL_8:
        HIDWORD(ctx->check_revocation) = v6;
      }
    }
  }
  else
  {
    X509_free(v15);
    return 1;
  }
  return v5;
}

X509 *get_trusted_issuer(X509_STORE_CTX *ctx, X509 *x)
{
  X509_VERIFY_PARAM *param;
  char *name;
  char *v6;
  _BYTE *v7;
  int v8;
  unint64_t ex_flags;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  char v14;
  X509 *issuer;

  param = ctx->param;
  if (!param)
  {
    issuer = 0;
    if (X509_STORE_CTX_get1_issuer(&issuer, ctx, x))
      return issuer;
    else
      return 0;
  }
  name = param->name;
  if (!param->name)
    return 0;
  v6 = 0;
  while (1)
  {
    if (name <= v6)
    {
      v7 = 0;
      if (X509_NAME_cmp(*(const X509_NAME **)(MEMORY[0] + 40), x->cert_info->issuer))
      {
LABEL_7:
        v8 = 29;
        goto LABEL_17;
      }
    }
    else
    {
      v7 = *(_BYTE **)(param->check_time + 8 * (_QWORD)v6);
      if (X509_NAME_cmp(*(const X509_NAME **)(*(_QWORD *)v7 + 40), x->cert_info->issuer))
        goto LABEL_7;
    }
    if (x509v3_cache_extensions((const void ****)v7) && x509v3_cache_extensions((const void ****)x))
    {
      ex_flags = x->ex_flags;
      if (!ex_flags || (v8 = X509_check_akid(v7, ex_flags)) == 0)
      {
        if ((v7[48] & 2) == 0 || (v7[52] & 4) != 0)
          break;
        v8 = 32;
      }
    }
    else
    {
      v8 = 1;
    }
LABEL_17:
    if (((uint64_t)ctx->crls->data & 1) != 0)
    {
      HIDWORD(ctx->check_revocation) = v8;
      ctx->get_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL **, X509 *))x;
      v10 = ((uint64_t (*)(_QWORD, X509_STORE_CTX *))ctx->other_ctx)(0, ctx);
      if (v10 >= 2)
        abort();
      if (v10)
        break;
    }
    ++v6;
    name = param->name;
    if (v6 >= param->name)
      return 0;
  }
  v11 = (unsigned int *)(v7 + 24);
  v12 = atomic_load((unsigned int *)v7 + 6);
  if (v12 != -1)
  {
    while (1)
    {
      v13 = __ldaxr(v11);
      if (v13 == v12)
      {
        if (!__stlxr(v12 + 1, v11))
        {
          v14 = 1;
          goto LABEL_26;
        }
      }
      else
      {
        __clrex();
      }
      v14 = 0;
LABEL_26:
      if ((v14 & 1) == 0)
      {
        v12 = v13;
        if (v13 != -1)
          continue;
      }
      return (X509 *)v7;
    }
  }
  return (X509 *)v7;
}

uint64_t x509_check_issued_with_callback(uint64_t a1, const void ****a2, const void ****a3)
{
  int v6;
  uint64_t v7;
  uint64_t result;

  if (X509_NAME_cmp((const X509_NAME *)(*a3)[5], (const X509_NAME *)(*a2)[3]))
  {
    v6 = 29;
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) & 1) == 0)
      return 0;
    goto LABEL_14;
  }
  if (x509v3_cache_extensions(a3) && x509v3_cache_extensions(a2))
  {
    v7 = (uint64_t)a2[9];
    if (!v7 || (v6 = X509_check_akid(a3, v7)) == 0)
    {
      if (((_BYTE)a3[6] & 2) == 0 || (*((_BYTE *)a3 + 52) & 4) != 0)
        return 1;
      v6 = 32;
    }
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) & 1) == 0)
      return 0;
  }
  else
  {
    v6 = 1;
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) & 1) == 0)
      return 0;
  }
LABEL_14:
  *(_DWORD *)(a1 + 92) = v6;
  *(_QWORD *)(a1 + 96) = a2;
  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2)
    abort();
  return result;
}

uint64_t check_chain_extensions(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t result;
  BOOL (**v8)(uint64_t, uint64_t, int);
  BOOL (**v9)(uint64_t, uint64_t, int);
  _QWORD *v10;
  uint64_t v11;
  int v12;
  int v13;
  BOOL (**v14)(uint64_t, uint64_t, int);
  BOOL (**v15)(uint64_t, uint64_t, int);
  int v16;
  int64_t v17;
  uint64_t v18;
  int v19;
  _QWORD *v20;
  uint64_t v21;
  int v22;
  BOOL (**v23)(uint64_t, uint64_t, int);
  BOOL (**v24)(uint64_t, uint64_t, int);
  int v25;
  uint64_t v26;

  if (*(int *)(a1 + 72) < 1)
    return 1;
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_DWORD *)(v2 + 16);
  v4 = *(_QWORD *)(a1 + 80);
  if (v4 && *(_QWORD *)v4)
  {
    v5 = **(_QWORD **)(v4 + 8);
    if ((*(_BYTE *)(v2 + 8) & 0x10) != 0)
      goto LABEL_5;
LABEL_8:
    v6 = *(_DWORD *)(v2 + 16);
    if ((*(_BYTE *)(v5 + 49) & 2) != 0)
    {
      *(_QWORD *)(a1 + 88) = 0x2200000000;
      *(_QWORD *)(a1 + 96) = v5;
      result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
      if (result > 1)
        goto LABEL_113;
      if (!(_DWORD)result)
        return result;
      v6 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 16);
    }
    if (v6 < 1)
      goto LABEL_26;
    goto LABEL_13;
  }
  v5 = 0;
  if ((*(_BYTE *)(v2 + 8) & 0x10) == 0)
    goto LABEL_8;
LABEL_5:
  if (v3 < 1)
    goto LABEL_26;
LABEL_13:
  if (x509v3_cache_extensions((const void ****)v5))
  {
    v8 = (BOOL (**)(uint64_t, uint64_t, int))&xstandard;
    v9 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47F0;
    switch(v3)
    {
      case -1:
        goto LABEL_26;
      case 1:
        goto LABEL_22;
      case 2:
        v8 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4778;
        goto LABEL_22;
      case 3:
        v8 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4790;
        goto LABEL_22;
      case 4:
        v8 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47A8;
        goto LABEL_22;
      case 5:
        v8 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47C0;
        goto LABEL_22;
      case 6:
        v8 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47D8;
        goto LABEL_22;
      case 7:
        goto LABEL_23;
      case 8:
        v8 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4808;
        goto LABEL_22;
      case 9:
        v8 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4820;
LABEL_22:
        v9 = v8;
LABEL_23:
        if (!v9[1]((uint64_t)v9, v5, 0))
          break;
        goto LABEL_26;
      default:
        break;
    }
  }
  *(_QWORD *)(a1 + 88) = 0x1A00000000;
  *(_QWORD *)(a1 + 96) = v5;
  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
  if (result > 1)
    goto LABEL_113;
  if (!(_DWORD)result)
    return result;
LABEL_26:
  if (*(int *)(a1 + 72) > 1)
  {
    v10 = *(_QWORD **)(a1 + 80);
    if (v10 && *v10 >= 2uLL)
    {
      v11 = *(_QWORD *)(v10[1] + 8);
      v12 = *(_DWORD *)(v5 + 48);
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) & 0x10) != 0)
        goto LABEL_35;
    }
    else
    {
      v11 = 0;
      v12 = *(_DWORD *)(v5 + 48);
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) & 0x10) != 0)
        goto LABEL_35;
    }
    if ((*(_BYTE *)(v11 + 49) & 2) != 0)
    {
      *(_QWORD *)(a1 + 88) = 0x2200000001;
      *(_QWORD *)(a1 + 96) = v11;
      result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
      if (result > 1)
        goto LABEL_113;
      if (!(_DWORD)result)
        return result;
    }
LABEL_35:
    if (!x509v3_cache_extensions((const void ****)v11)
      || (v13 = *(_DWORD *)(v11 + 48), (v13 & 2) != 0) && (*(_BYTE *)(v11 + 52) & 4) == 0
      || (~v13 & 0x2040) != 0 && (*(_DWORD *)(v11 + 48) & 0x11) != 0x11)
    {
      *(_QWORD *)(a1 + 88) = 0x1800000001;
      *(_QWORD *)(a1 + 96) = v11;
      result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
      if (result > 1)
        goto LABEL_113;
      if (!(_DWORD)result)
        return result;
    }
    if (*(int *)(*(_QWORD *)(a1 + 32) + 16) >= 1)
    {
      if (!x509v3_cache_extensions((const void ****)v11))
        goto LABEL_59;
      v14 = (BOOL (**)(uint64_t, uint64_t, int))&xstandard;
      v15 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47F0;
      switch(v3)
      {
        case -1:
          break;
        case 1:
          goto LABEL_52;
        case 2:
          v14 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4778;
          goto LABEL_52;
        case 3:
          v14 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4790;
          goto LABEL_52;
        case 4:
          v14 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47A8;
          goto LABEL_52;
        case 5:
          v14 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47C0;
          goto LABEL_52;
        case 6:
          v14 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47D8;
          goto LABEL_52;
        case 7:
          goto LABEL_58;
        case 8:
          v14 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4808;
          goto LABEL_52;
        case 9:
          v14 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4820;
LABEL_52:
          v16 = *(_DWORD *)(v11 + 48);
          if ((v16 & 2) != 0 && (*(_BYTE *)(v11 + 52) & 4) == 0)
            goto LABEL_59;
          if ((~v16 & 0x2040) != 0)
          {
            v15 = v14;
            if ((*(_DWORD *)(v11 + 48) & 0x11) != 0x11)
              goto LABEL_59;
          }
          else
          {
            v15 = v14;
          }
LABEL_58:
          if (!v15[1]((uint64_t)v15, v11, 1))
          {
LABEL_59:
            *(_QWORD *)(a1 + 88) = 0x1A00000001;
            *(_QWORD *)(a1 + 96) = v11;
            result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
            if (result <= 1)
            {
              if (!(_DWORD)result)
                return result;
              break;
            }
LABEL_113:
            abort();
          }
          return result;
        default:
          goto LABEL_59;
      }
    }
    if (*(int *)(a1 + 72) < 3)
      return 1;
    v17 = ((*(_DWORD *)(v11 + 48) & 0x20) == 0) + (unint64_t)((v12 & 0x20) == 0);
    v18 = 2;
    while (1)
    {
      v20 = *(_QWORD **)(a1 + 80);
      if (v20 && *v20 > (unint64_t)v18)
      {
        v21 = *(_QWORD *)(v20[1] + 8 * v18);
        if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) & 0x10) != 0)
          goto LABEL_75;
      }
      else
      {
        v21 = 0;
        if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) & 0x10) != 0)
          goto LABEL_75;
      }
      if ((*(_BYTE *)(v21 + 49) & 2) != 0)
      {
        *(_DWORD *)(a1 + 88) = v18;
        *(_DWORD *)(a1 + 92) = 34;
        *(_QWORD *)(a1 + 96) = v21;
        result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
        if (result >= 2)
          goto LABEL_113;
        if (!(_DWORD)result)
          return result;
      }
LABEL_75:
      if (!x509v3_cache_extensions((const void ****)v21)
        || (v22 = *(_DWORD *)(v21 + 48), (v22 & 2) != 0) && (*(_BYTE *)(v21 + 52) & 4) == 0
        || (~v22 & 0x2040) != 0 && (*(_DWORD *)(v21 + 48) & 0x11) != 0x11)
      {
        *(_DWORD *)(a1 + 88) = v18;
        *(_DWORD *)(a1 + 92) = 24;
        *(_QWORD *)(a1 + 96) = v21;
        result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
        if (result >= 2)
          goto LABEL_113;
        if (!(_DWORD)result)
          return result;
      }
      if (*(int *)(*(_QWORD *)(a1 + 32) + 16) >= 1)
      {
        if (x509v3_cache_extensions((const void ****)v21))
        {
          v23 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47F0;
          v24 = (BOOL (**)(uint64_t, uint64_t, int))&xstandard;
          switch(v3)
          {
            case -1:
              break;
            case 1:
              goto LABEL_96;
            case 2:
              v24 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4778;
              v25 = *(_DWORD *)(v21 + 48);
              if ((v25 & 2) == 0)
                goto LABEL_100;
              goto LABEL_97;
            case 3:
              v24 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4790;
              v25 = *(_DWORD *)(v21 + 48);
              if ((v25 & 2) == 0)
                goto LABEL_100;
              goto LABEL_97;
            case 4:
              v24 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47A8;
              v25 = *(_DWORD *)(v21 + 48);
              if ((v25 & 2) == 0)
                goto LABEL_100;
              goto LABEL_97;
            case 5:
              v24 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47C0;
              v25 = *(_DWORD *)(v21 + 48);
              if ((v25 & 2) == 0)
                goto LABEL_100;
              goto LABEL_97;
            case 6:
              v24 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D47D8;
              v25 = *(_DWORD *)(v21 + 48);
              if ((v25 & 2) == 0)
                goto LABEL_100;
              goto LABEL_97;
            case 7:
              goto LABEL_102;
            case 8:
              v24 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4808;
LABEL_96:
              v25 = *(_DWORD *)(v21 + 48);
              if ((v25 & 2) != 0)
                goto LABEL_97;
              goto LABEL_100;
            case 9:
              v24 = (BOOL (**)(uint64_t, uint64_t, int))&unk_24C0D4820;
              v25 = *(_DWORD *)(v21 + 48);
              if ((v25 & 2) == 0)
                goto LABEL_100;
LABEL_97:
              if ((*(_BYTE *)(v21 + 52) & 4) == 0)
                goto LABEL_105;
LABEL_100:
              if ((~v25 & 0x2040) == 0)
              {
                if (v24[1]((uint64_t)v24, v21, 1))
                  break;
                goto LABEL_105;
              }
              v23 = v24;
              if ((v25 & 0x11) != 0x11)
                goto LABEL_105;
LABEL_102:
              if (!v23[1]((uint64_t)v23, v21, 1))
                goto LABEL_105;
              break;
            default:
              goto LABEL_105;
          }
        }
        else
        {
LABEL_105:
          *(_DWORD *)(a1 + 88) = v18;
          *(_DWORD *)(a1 + 92) = 26;
          *(_QWORD *)(a1 + 96) = v21;
          result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
          if (result >= 2)
            goto LABEL_113;
          if (!(_DWORD)result)
            return result;
        }
      }
      v19 = *(_DWORD *)(v21 + 48);
      if ((v19 & 0x20) == 0)
      {
        v26 = *(_QWORD *)(v21 + 40);
        if (v26 != -1 && v26 + 1 < v17)
        {
          *(_DWORD *)(a1 + 88) = v18;
          *(_DWORD *)(a1 + 92) = 25;
          *(_QWORD *)(a1 + 96) = v21;
          result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
          if (result >= 2)
            goto LABEL_113;
          if (!(_DWORD)result)
            return result;
          v19 = *(_DWORD *)(v21 + 48);
        }
      }
      v17 += (v19 & 0x20) == 0;
      ++v18;
      result = 1;
      if (v18 >= *(int *)(a1 + 72))
        return result;
    }
  }
  return 1;
}

uint64_t check_id(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  char *v9;
  size_t v10;
  size_t v11;
  uint64_t v12;
  void *v13;
  size_t v14;
  const void *v15;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v2 + 88))
  {
    *(_QWORD *)(a1 + 96) = v3;
    *(_QWORD *)(a1 + 88) = 0x4100000000;
    result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
    if (result >= 2)
      goto LABEL_29;
    if (!(_DWORD)result)
      return result;
  }
  v5 = *(uint64_t **)(v2 + 40);
  if (v5)
  {
    v6 = *v5;
    if (*v5)
    {
      v7 = 0;
      do
      {
        v8 = *(unint64_t **)(v2 + 40);
        if (v8)
        {
          if (*v8 > v7)
          {
            v9 = *(char **)(v8[1] + 8 * v7);
            v10 = strlen(v9);
            if (v9)
            {
              v11 = v10;
              v12 = *(unsigned int *)(v2 + 48);
              if ((!v10 || !memchr(v9, 0, v10)) && (int)do_x509_check(v3, v9, v11, v12, 2, 0) > 0)
                goto LABEL_17;
            }
          }
        }
        ++v7;
      }
      while (v6 != v7);
      *(_QWORD *)(a1 + 96) = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 88) = 0x3E00000000;
      result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
      if (result >= 2)
        goto LABEL_29;
      if (!(_DWORD)result)
        return result;
    }
  }
LABEL_17:
  v13 = *(void **)(v2 + 56);
  if (v13)
  {
    if ((v14 = *(_QWORD *)(v2 + 64)) != 0 && memchr(*(void **)(v2 + 56), 0, *(_QWORD *)(v2 + 64))
      || (int)do_x509_check(v3, v13, v14, 0, 1, 0) <= 0)
    {
      *(_QWORD *)(a1 + 96) = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 88) = 0x3F00000000;
      result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
      if (result >= 2)
        goto LABEL_29;
      if (!(_DWORD)result)
        return result;
    }
  }
  v15 = *(const void **)(v2 + 72);
  if (v15 && (int)X509_check_ip(v3, v15, *(_QWORD *)(v2 + 80)) <= 0)
  {
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 88) = 0x4000000000;
    result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
    if (result < 2)
    {
      if (!(_DWORD)result)
        return result;
      return 1;
    }
LABEL_29:
    abort();
  }
  return 1;
}

uint64_t check_revocation(uint64_t a1)
{
  uint64_t v1;
  int v4;
  int *v5;
  int v6;
  BOOL v7;
  unint64_t v8;
  BOOL v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  ASN1_VALUE *pval;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if ((v1 & 4) == 0)
    return 1;
  if ((v1 & 8) == 0)
  {
    v4 = 0;
    goto LABEL_7;
  }
  v5 = *(int **)(a1 + 80);
  if (v5)
  {
    v6 = *v5;
    v7 = __OFSUB__(v6, 1);
    v4 = v6 - 1;
    if (v4 < 0 == v7)
    {
LABEL_7:
      v8 = 0;
      v9 = 0;
      v10 = (v4 + 1);
      v11 = v4;
      do
      {
        *(_DWORD *)(a1 + 88) = v8;
        v19 = 0;
        v12 = *(unint64_t **)(a1 + 80);
        if (v12 && *v12 > v8)
          v13 = *(_QWORD *)(v12[1] + 8 * v8);
        else
          v13 = 0;
        *(_QWORD *)(a1 + 96) = v13;
        *(_QWORD *)(a1 + 112) = 0;
        *(_DWORD *)(a1 + 120) = 0;
        v14 = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(a1 + 56))(a1, &v19, v13);
        if ((_DWORD)v14)
        {
          *(_QWORD *)(a1 + 104) = v19;
          if (!(*(unsigned int (**)(uint64_t))(a1 + 64))(a1))
            goto LABEL_24;
          v15 = v19;
          if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) & 0x10) == 0 && (*(_BYTE *)(v19 + 29) & 2) != 0)
          {
            *(_DWORD *)(a1 + 92) = 36;
            v16 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
            if (v16 >= 2)
              goto LABEL_31;
            if (!v16)
              goto LABEL_24;
          }
          pval = 0;
          if (!crl_lookup(v15, (ASN1_STRING ***)&pval, *(ASN1_STRING **)(*(_QWORD *)v13 + 8), *(const X509_NAME **)(*(_QWORD *)v13 + 24)))goto LABEL_21;
          *(_DWORD *)(a1 + 92) = 23;
          v17 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
          if (v17 >= 2)
            goto LABEL_31;
          if (v17)
LABEL_21:
            v18 = 1;
          else
LABEL_24:
            v18 = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 92) = 3;
          v18 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 48))(v14, a1);
          if (v18 >= 2)
LABEL_31:
            abort();
        }
        pval = (ASN1_VALUE *)v19;
        ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&X509_CRL_INFO_it.sname);
        *(_QWORD *)(a1 + 104) = 0;
        if (!v18)
          break;
        v9 = v8++ >= v11;
      }
      while (v10 != v8);
      return v9;
    }
  }
  return 1;
}

uint64_t internal_verify(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  _DWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  _QWORD *v11;
  uint64_t result;
  unint64_t *v13;
  uint64_t v14;
  EVP_PKEY *v15;
  time_t *v16;
  time_t v17;
  time_t v18;
  int *v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  BOOL v23;
  int v24;
  BOOL v25;
  time_t v26;

  v2 = *(unint64_t **)(a1 + 80);
  if (!v2)
  {
    LODWORD(v3) = 0;
    v6 = 0;
    LODWORD(v4) = -1;
    *(_DWORD *)(a1 + 88) = -1;
    v5 = (_DWORD *)(a1 + 88);
    if (!X509_NAME_cmp(*(const X509_NAME **)(MEMORY[0] + 40), *(const X509_NAME **)(MEMORY[0] + 24)))
      goto LABEL_4;
LABEL_13:
    v8 = 29;
LABEL_14:
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if ((v9 & 1) == 0)
      goto LABEL_21;
    goto LABEL_15;
  }
  v3 = *v2;
  LODWORD(v4) = *v2 - 1;
  *(_DWORD *)(a1 + 88) = v4;
  v5 = (_DWORD *)(a1 + 88);
  if (v3 <= (int)v4)
  {
    v6 = 0;
    if (!X509_NAME_cmp(*(const X509_NAME **)(MEMORY[0] + 40), *(const X509_NAME **)(MEMORY[0] + 24)))
      goto LABEL_4;
    goto LABEL_13;
  }
  v6 = *(_QWORD **)(v2[1] + 8 * (int)v4);
  if (X509_NAME_cmp(*(const X509_NAME **)(*v6 + 40), *(const X509_NAME **)(*v6 + 24)))
    goto LABEL_13;
LABEL_4:
  if (x509v3_cache_extensions((const void ****)v6) && x509v3_cache_extensions((const void ****)v6))
  {
    v7 = v6[9];
    if (!v7 || (v8 = X509_check_akid(v6, v7)) == 0)
    {
      if ((v6[6] & 2) == 0 || (*((_BYTE *)v6 + 52) & 4) != 0)
        goto LABEL_17;
      v8 = 32;
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      if ((v9 & 1) != 0)
        goto LABEL_15;
LABEL_21:
      if ((v9 & 0x80000) != 0)
        goto LABEL_36;
      goto LABEL_24;
    }
    goto LABEL_14;
  }
  v8 = 1;
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if ((v9 & 1) == 0)
    goto LABEL_21;
LABEL_15:
  *(_DWORD *)(a1 + 92) = v8;
  *(_QWORD *)(a1 + 96) = v6;
  v10 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
  if (v10 >= 2)
    goto LABEL_77;
  if (v10)
  {
LABEL_17:
    v11 = v6;
    goto LABEL_33;
  }
  if ((*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) & 0x80000) != 0)
    goto LABEL_36;
LABEL_24:
  if ((int)v3 > 1)
  {
    v4 = (v3 - 2);
    *(_DWORD *)(a1 + 88) = v4;
    v13 = *(unint64_t **)(a1 + 80);
    if (v13 && *v13 > v4)
      goto LABEL_32;
    v11 = 0;
    while (1)
    {
LABEL_33:
      if ((v4 & 0x80000000) != 0)
        return 1;
      *v5 = v4;
      if (v11 == v6 && (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 9) & 0x40) == 0)
      {
LABEL_36:
        v11 = v6;
        goto LABEL_47;
      }
      if (!v6)
        goto LABEL_45;
      v14 = *(_QWORD *)(*v6 + 48);
      if (!v14)
        goto LABEL_45;
      v15 = *(EVP_PKEY **)(v14 + 16);
      if (!v15)
        break;
      if (X509_ALGOR_cmp((_QWORD *)v11[1], *(_QWORD **)(*v11 + 16)))
      {
        ERR_put_error(11, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x_all.c", 75);
      }
      else if (ASN1_item_verify(&X509_CINF_it, (X509_ALGOR *)v11[1], (ASN1_BIT_STRING *)v11[2], (void *)*v11, v15) > 0)
      {
        goto LABEL_47;
      }
      *(_DWORD *)(a1 + 92) = 7;
      *(_QWORD *)(a1 + 96) = v11;
      result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
      if (result >= 2)
        goto LABEL_77;
LABEL_46:
      if (!(_DWORD)result)
        return result;
LABEL_47:
      v16 = *(time_t **)(a1 + 32);
      v17 = v16[1];
      if ((v17 & 0x200000) != 0)
        goto LABEL_69;
      if ((v17 & 2) != 0)
        v18 = *v16;
      else
        v18 = time(0);
      v19 = **(int ***)(*v11 + 32);
      v26 = 0;
      v20 = ASN1_TIME_to_posix(v19, &v26);
      if ((_DWORD)v20)
      {
        if (v26 <= v18)
          goto LABEL_57;
        *(_DWORD *)(a1 + 92) = 9;
        *(_QWORD *)(a1 + 96) = v11;
        result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
        if (result >= 2)
          goto LABEL_77;
      }
      else
      {
        *(_DWORD *)(a1 + 92) = 13;
        *(_QWORD *)(a1 + 96) = v11;
        result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 48))(v20, a1);
        if (result >= 2)
          goto LABEL_77;
      }
      if (!(_DWORD)result)
        return result;
LABEL_57:
      v21 = *(int **)(*(_QWORD *)(*v11 + 32) + 8);
      v26 = 0;
      v22 = ASN1_TIME_to_posix(v21, &v26);
      if ((_DWORD)v22)
        v23 = v26 <= v18;
      else
        v23 = 0;
      v24 = v23;
      if (!(_DWORD)v22)
      {
        *(_DWORD *)(a1 + 92) = 14;
        *(_QWORD *)(a1 + 96) = v11;
        result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 48))(v22, a1);
        if (result >= 2)
          goto LABEL_77;
        if (!(_DWORD)result)
          return result;
      }
      if (v24)
      {
        *(_DWORD *)(a1 + 92) = 10;
        *(_QWORD *)(a1 + 96) = v11;
        result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
        if (result >= 2)
          goto LABEL_77;
        if (!(_DWORD)result)
          return result;
      }
LABEL_69:
      *(_QWORD *)(a1 + 96) = v11;
      result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 48))(1, a1);
      if (result >= 2)
        goto LABEL_77;
      if (!(_DWORD)result)
        return result;
      v25 = __OFSUB__((_DWORD)v4, 1);
      v4 = (v4 - 1);
      if (((v4 & 0x80000000) != 0) == v25)
      {
        v13 = *(unint64_t **)(a1 + 80);
        if (v13)
        {
          v6 = v11;
          v11 = 0;
          if (*v13 > v4)
LABEL_32:
            v11 = *(_QWORD **)(v13[1] + 8 * v4);
        }
        else
        {
          v6 = v11;
          v11 = 0;
        }
      }
    }
    ERR_put_error(11, 0, 125, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x_pubkey.c", 162);
LABEL_45:
    *(_DWORD *)(a1 + 92) = 6;
    *(_QWORD *)(a1 + 96) = v6;
    result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
    if (result >= 2)
      goto LABEL_77;
    goto LABEL_46;
  }
  *(_DWORD *)(a1 + 92) = 21;
  *(_QWORD *)(a1 + 96) = v6;
  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2)
LABEL_77:
    abort();
  return result;
}

uint64_t check_name_constraints(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t result;
  uint64_t v13;
  _QWORD *v14;
  _QWORD **v15;
  int v16;
  _QWORD *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int16 *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  ASN1_STRING *v30;
  unsigned int v31;
  unint64_t v32;
  unsigned __int8 *v33;
  int v34;
  BOOL v35;
  unint64_t v36;
  unint64_t v37;
  int v38;
  uint64_t v42;
  unsigned __int8 *v43;
  unsigned __int8 *out;

  v1 = *(uint64_t **)(a1 + 80);
  if (!v1)
    return 1;
  v2 = *v1;
  if ((int)*v1 < 1)
    return 1;
  v4 = 0;
  v5 = (v2 - 1);
  do
  {
    v6 = v2;
    v2 = v5;
    v7 = *(uint64_t **)(a1 + 80);
    if (v7 && *v7 > (unint64_t)v2)
    {
      v8 = *(_QWORD *)(v7[1] + 8 * v2);
      if (v2)
        goto LABEL_10;
    }
    else
    {
      v8 = 0;
      if (v2)
      {
LABEL_10:
        if ((*(_BYTE *)(v8 + 48) & 0x20) != 0)
          goto LABEL_4;
      }
    }
    if (v7)
    {
      v9 = *v7;
      if (v6 < (int)*v7)
        goto LABEL_18;
    }
    else
    {
      LODWORD(v9) = 0;
      if (v6 < 0)
      {
        do
        {
LABEL_18:
          LODWORD(v9) = v9 - 1;
          v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 8 * v9) + 96);
          if (v10)
          {
            v11 = NAME_CONSTRAINTS_check((_QWORD *)v8, v10);
            if (v11)
            {
              if (v11 == 17)
              {
LABEL_97:
                result = 0;
                *(_DWORD *)(a1 + 92) = 17;
                return result;
              }
              *(_DWORD *)(a1 + 88) = v2;
              *(_DWORD *)(a1 + 92) = v11;
              *(_QWORD *)(a1 + 96) = v8;
              result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
              if (result >= 2)
                goto LABEL_98;
              if (!(_DWORD)result)
                return result;
            }
            v4 = 1;
          }
        }
        while ((int)v9 > v6);
      }
    }
LABEL_4:
    v5 = v2 - 1;
  }
  while (v2 > 0);
  v13 = *(_QWORD *)(a1 + 80);
  if (!v13 || !*(_QWORD *)v13)
  {
    v14 = 0;
    if (v4)
      goto LABEL_29;
    return 1;
  }
  v14 = **(_QWORD ***)(v13 + 8);
  if (!v4)
    return 1;
LABEL_29:
  if (v14[11])
    return 1;
  v15 = *(_QWORD ***)(*v14 + 40);
  if (!v15)
    return 1;
  v16 = -1;
  while (2)
  {
    v17 = *v15;
    if (*v15)
      v18 = *(int *)v17;
    else
      v18 = 0;
    if (v16 < 0)
      v19 = -1;
    else
      v19 = v16;
    v20 = v19 + 1;
    v21 = -v19;
    do
    {
      if (v20 >= v18)
        return 1;
      v23 = v20;
      v24 = v17[1];
      v25 = **(_QWORD **)(v24 + 8 * v20);
      if (*(_DWORD *)(v25 + 20) == 3)
      {
        v26 = *(unsigned __int16 **)(v25 + 24);
        v27 = bswap32(*v26) >> 16;
        v28 = bswap32(0x455u) >> 16;
        if (v27 == v28)
        {
          v22 = *((unsigned __int8 *)v26 + 2) - 3;
        }
        else if (v27 < v28)
        {
          v22 = -1;
        }
        else
        {
          v22 = 1;
        }
      }
      else
      {
        v22 = -1;
      }
      v20 = v23 + 1;
      --v21;
    }
    while (v22);
    if (v21 == 1)
      return 1;
    v16 = -v21;
    if (-v21 < 0
      || *v17 <= (unint64_t)v23
      || (v29 = *(_QWORD *)(v24 + 8 * v23)) == 0)
    {
      v30 = 0;
    }
    else
    {
      v30 = *(ASN1_STRING **)(v29 + 8);
    }
    out = 0;
    v31 = ASN1_STRING_to_UTF8(&out, v30);
    if ((v31 & 0x80000000) != 0)
      goto LABEL_97;
    if (!v31)
    {
      v34 = 0;
      goto LABEL_89;
    }
    v32 = v31;
    if (out[v31 - 1] == 46)
      v32 = v31 - 1;
    if (v32 < 2)
    {
      v33 = out;
      goto LABEL_65;
    }
    if (*out == 42)
    {
      v33 = out;
      if (out[1] == 46)
      {
        v33 = out + 2;
        v32 -= 2;
LABEL_65:
        if (!v32)
        {
          v34 = 0;
          goto LABEL_90;
        }
      }
    }
    else
    {
      v33 = out;
    }
    v35 = 0;
    v36 = 0;
    v37 = 0;
    while (2)
    {
      v38 = v33[v36];
      if ((v38 - 58) > 0xFFFFFFF5 || (v38 & 0xFFFFFFDF) - 91 > 0xFFFFFFE5)
      {
LABEL_70:
        v35 = ++v36 >= v32;
        if (v32 == v36)
          goto LABEL_88;
        continue;
      }
      break;
    }
    if (v33[v36] > 0x39u)
    {
      if (v38 != 58 && v38 != 95)
        goto LABEL_88;
      goto LABEL_70;
    }
    if (v38 == 45)
    {
      if (v36 <= v37)
        goto LABEL_88;
      goto LABEL_70;
    }
    if (v38 == 46 && v36 < v32 - 1 && v36 > v37)
    {
      v37 = v36 + 1;
      goto LABEL_70;
    }
LABEL_88:
    v34 = v35;
LABEL_89:
    if (out)
    {
LABEL_90:
      v43 = out - 8;
      v42 = *((_QWORD *)out - 1);
      if (v42 != -8)
        bzero(out - 8, v42 + 8);
      free(v43);
    }
    if (!v34)
      continue;
    break;
  }
  *(_QWORD *)(a1 + 88) = 0x43FFFFFFFFLL;
  *(_QWORD *)(a1 + 96) = v14;
  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2)
LABEL_98:
    abort();
  if ((_DWORD)result)
    return 1;
  return result;
}

uint64_t check_policy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  int v6;
  uint64_t result;
  STACK policy_oids;

  *(_QWORD *)&policy_oids.num = 0;
  v6 = X509_policy_check(*(X509_POLICY_TREE ***)(a1 + 80), *(int **)(*(_QWORD *)(a1 + 32) + 32), *(STACK **)(*(_QWORD *)(a1 + 32) + 8), &policy_oids, a5);
  if (!v6)
    return 1;
  *(_QWORD *)(a1 + 96) = *(_QWORD *)&policy_oids.num;
  *(_DWORD *)(a1 + 92) = v6;
  if (v6 == 17)
    return 0;
  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2)
    abort();
  return result;
}

void X509_STORE_CTX_free(X509_STORE_CTX *ctx)
{
  int (__cdecl *check_issued)(X509_STORE_CTX *, X509 *, X509 *);
  unint64_t v3;
  unint64_t v4;
  X509 *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  char *v10;
  uint64_t v11;
  size_t v12;
  int *p_dummy;
  uint64_t v14;
  size_t v15;

  if (ctx)
  {
    CRYPTO_free_ex_data((int)&g_ex_data_class_1, ctx, (CRYPTO_EX_DATA *)&ctx->cleanup);
    X509_VERIFY_PARAM_free((X509_VERIFY_PARAM *)ctx->crls);
    check_issued = ctx->check_issued;
    if (check_issued)
    {
      v3 = *(_QWORD *)check_issued;
      if (*(_QWORD *)check_issued)
      {
        v4 = 0;
        do
        {
          v5 = *(X509 **)(*((_QWORD *)check_issued + 1) + 8 * v4);
          if (v5)
          {
            X509_free(v5);
            v3 = *(_QWORD *)check_issued;
          }
          ++v4;
        }
        while (v4 < v3);
      }
      v6 = *((_QWORD *)check_issued + 1);
      if (v6)
      {
        v8 = *(_QWORD *)(v6 - 8);
        v7 = (void *)(v6 - 8);
        v9 = v8 + 8;
        if (v8 != -8)
          bzero(v7, v9);
        free(v7);
      }
      v11 = *((_QWORD *)check_issued - 1);
      v10 = (char *)check_issued - 8;
      v12 = v11 + 8;
      if (v11 != -8)
        bzero(v10, v12);
      free(v10);
    }
    ctx->cleanup = 0;
    *(_OWORD *)&ctx->get_crl = 0u;
    *(_OWORD *)&ctx->cert_crl = 0u;
    *(_OWORD *)&ctx->verify_cb = 0u;
    *(_OWORD *)&ctx->check_issued = 0u;
    *(_OWORD *)&ctx->crls = 0u;
    *(_OWORD *)&ctx->other_ctx = 0u;
    *(_OWORD *)&ctx->ctx = 0u;
    *(_OWORD *)&ctx->cert = 0u;
    v14 = *(_QWORD *)&ctx[-1].ex_data.dummy;
    p_dummy = &ctx[-1].ex_data.dummy;
    v15 = v14 + 8;
    if (v14 != -8)
      bzero(p_dummy, v15);
    free(p_dummy);
  }
}

int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509, STACK *chain)
{
  int (__cdecl **p_cleanup)(X509_STORE_CTX *);
  int (__cdecl *check_issued)(X509_STORE_CTX *, X509 *, X509 *);
  unint64_t v10;
  unint64_t v11;
  X509 *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  size_t v16;
  char *v17;
  uint64_t v18;
  size_t v19;
  char *v20;
  int (__cdecl *cert_crl)(X509_STORE_CTX *, X509_CRL *, X509 *);
  int8x16_t v22;
  int (__cdecl *v23)(int, X509_STORE_CTX *);
  int result;
  STACK *crls;

  p_cleanup = &ctx->cleanup;
  CRYPTO_free_ex_data((int)&g_ex_data_class_1, ctx, (CRYPTO_EX_DATA *)&ctx->cleanup);
  X509_VERIFY_PARAM_free((X509_VERIFY_PARAM *)ctx->crls);
  check_issued = ctx->check_issued;
  if (check_issued)
  {
    v10 = *(_QWORD *)check_issued;
    if (*(_QWORD *)check_issued)
    {
      v11 = 0;
      do
      {
        v12 = *(X509 **)(*((_QWORD *)check_issued + 1) + 8 * v11);
        if (v12)
        {
          X509_free(v12);
          v10 = *(_QWORD *)check_issued;
        }
        ++v11;
      }
      while (v11 < v10);
    }
    v13 = *((_QWORD *)check_issued + 1);
    if (v13)
    {
      v15 = *(_QWORD *)(v13 - 8);
      v14 = (void *)(v13 - 8);
      v16 = v15 + 8;
      if (v15 != -8)
        bzero(v14, v16);
      free(v14);
    }
    v18 = *((_QWORD *)check_issued - 1);
    v17 = (char *)check_issued - 8;
    v19 = v18 + 8;
    if (v18 != -8)
      bzero(v17, v19);
    free(v17);
  }
  *(_OWORD *)&ctx->ctx = 0u;
  *(_OWORD *)&ctx->cert = 0u;
  *(_OWORD *)&ctx->get_crl = 0u;
  *(_OWORD *)&ctx->cert_crl = 0u;
  *(_OWORD *)&ctx->verify_cb = 0u;
  *(_OWORD *)&ctx->check_issued = 0u;
  *(_OWORD *)&ctx->crls = 0u;
  *(_OWORD *)&ctx->other_ctx = 0u;
  ctx->cleanup = 0;
  ctx->ctx = store;
  *(_QWORD *)&ctx->current_method = x509;
  ctx->cert = (X509 *)chain;
  if (store)
  {
    v20 = (char *)malloc_type_malloc(0x68uLL, 0x30772F57uLL);
    if (v20)
    {
      *(_QWORD *)v20 = 96;
      *(_OWORD *)(v20 + 24) = 0u;
      *(_OWORD *)(v20 + 40) = 0u;
      *(_OWORD *)(v20 + 56) = 0u;
      *(_OWORD *)(v20 + 72) = 0u;
      *(_OWORD *)(v20 + 88) = 0u;
      *(_OWORD *)(v20 + 8) = 0u;
      *((_DWORD *)v20 + 8) = -1;
      ctx->crls = (STACK *)(v20 + 8);
      cert_crl = store[1].cert_crl;
      ctx->other_ctx = store[1].cleanup;
      if (x509_verify_param_copy((uint64_t)(v20 + 8), (uint64_t)cert_crl, 0)
        && x509_verify_param_copy((uint64_t)ctx->crls, (uint64_t)&kDefaultParam, 0))
      {
        v22.i64[0] = (uint64_t)null_callback;
        v22.i64[1] = (uint64_t)get_crl;
        *(int8x16_t *)&ctx->other_ctx = vbslq_s8((int8x16_t)vceqzq_s64(*(int64x2_t *)&store[1].cleanup), v22, *(int8x16_t *)&store[1].cleanup);
        v23 = *(int (__cdecl **)(int, X509_STORE_CTX *))&store[1].ex_data.dummy;
        if (!v23)
          v23 = (int (__cdecl *)(int, X509_STORE_CTX *))check_crl;
        ctx->verify_cb = v23;
        return 1;
      }
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      ctx->crls = 0;
    }
  }
  else
  {
    ERR_put_error(11, 0, 67, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x509_vfy.c", 1538);
  }
  CRYPTO_free_ex_data((int)&g_ex_data_class_1, ctx, (CRYPTO_EX_DATA *)p_cleanup);
  crls = ctx->crls;
  if (crls)
    X509_VERIFY_PARAM_free((X509_VERIFY_PARAM *)crls);
  result = 0;
  ctx->cleanup = 0;
  *(_OWORD *)&ctx->get_crl = 0u;
  *(_OWORD *)&ctx->cert_crl = 0u;
  *(_OWORD *)&ctx->verify_cb = 0u;
  *(_OWORD *)&ctx->check_issued = 0u;
  *(_OWORD *)&ctx->crls = 0u;
  *(_OWORD *)&ctx->other_ctx = 0u;
  *(_OWORD *)&ctx->ctx = 0u;
  *(_OWORD *)&ctx->cert = 0u;
  return result;
}

uint64_t get_crl(uint64_t a1, ASN1_VALUE **a2, uint64_t a3)
{
  ASN1_VALUE *v6;
  unint64_t *v8;
  BOOL v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  void *v14;
  uint64_t v15;
  size_t v16;
  unint64_t *v17;
  uint64_t v18;
  size_t v19;
  ASN1_VALUE *v20;
  int v21;
  uint64_t v22;
  ASN1_VALUE *pval;

  v22 = 0;
  v21 = 0;
  v20 = 0;
  if (!get_crl_sk(a1, &v20, &v22, &v21, *(_QWORD **)(a1 + 24)))
  {
    v8 = X509_STORE_CTX_get1_crls((uint64_t **)a1, *(_QWORD *)(*(_QWORD *)a3 + 24));
    v6 = v20;
    if (v8)
      v9 = 1;
    else
      v9 = v20 == 0;
    if (!v9)
      goto LABEL_15;
    v10 = v8;
    get_crl_sk(a1, &v20, &v22, &v21, v8);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        v12 = 0;
        do
        {
          if (*(_QWORD *)(v10[1] + 8 * v12))
          {
            pval = *(ASN1_VALUE **)(v10[1] + 8 * v12);
            ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&X509_CRL_INFO_it.sname);
            v11 = *v10;
          }
          ++v12;
        }
        while (v12 < v11);
      }
      v13 = v10[1];
      if (v13)
      {
        v15 = *(_QWORD *)(v13 - 8);
        v14 = (void *)(v13 - 8);
        v16 = v15 + 8;
        if (v15 != -8)
          bzero(v14, v16);
        free(v14);
      }
      v18 = *(v10 - 1);
      v17 = v10 - 1;
      v19 = v18 + 8;
      if (v18 != -8)
        bzero(v17, v19);
      free(v17);
    }
  }
  v6 = v20;
  if (!v20)
    return 0;
LABEL_15:
  *(_QWORD *)(a1 + 112) = v22;
  *(_DWORD *)(a1 + 120) = v21;
  *a2 = v6;
  return 1;
}

uint64_t check_crl(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t result;
  uint64_t v13;
  EVP_PKEY *v14;

  v4 = *(uint64_t **)(a1 + 80);
  if (v4)
  {
    v5 = *v4;
    v6 = *(_QWORD *)(a1 + 112);
    if (v6)
      goto LABEL_30;
  }
  else
  {
    LODWORD(v5) = 0;
    v6 = *(_QWORD *)(a1 + 112);
    if (v6)
      goto LABEL_30;
  }
  v7 = *(int *)(a1 + 88);
  v8 = v5 - 1;
  if ((int)v7 < v8)
  {
    if (!v4)
      return 1;
    if (*v4 <= (unint64_t)(v7 + 1))
      return 1;
    v6 = *(_QWORD *)(v4[1] + 8 * (v7 + 1));
    if (!v6)
      return 1;
    goto LABEL_30;
  }
  if (!v4 || *v4 <= (unint64_t)v8)
  {
    v6 = 0;
    if (!X509_NAME_cmp(*(const X509_NAME **)(MEMORY[0] + 40), *(const X509_NAME **)(MEMORY[0] + 24)))
      goto LABEL_13;
LABEL_22:
    v10 = 29;
    goto LABEL_23;
  }
  v6 = *(_QWORD *)(v4[1] + 8 * v8);
  if (X509_NAME_cmp(*(const X509_NAME **)(*(_QWORD *)v6 + 40), *(const X509_NAME **)(*(_QWORD *)v6 + 24)))
    goto LABEL_22;
LABEL_13:
  if (!x509v3_cache_extensions((const void ****)v6) || !x509v3_cache_extensions((const void ****)v6))
  {
    v10 = 1;
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) & 1) == 0)
      goto LABEL_28;
    goto LABEL_24;
  }
  v9 = *(_QWORD *)(v6 + 72);
  if (v9)
  {
    v10 = X509_check_akid((_QWORD *)v6, v9);
    if (v10)
    {
LABEL_23:
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) & 1) == 0)
        goto LABEL_28;
      goto LABEL_24;
    }
  }
  if ((*(_BYTE *)(v6 + 48) & 2) == 0 || (*(_BYTE *)(v6 + 52) & 4) != 0)
    goto LABEL_30;
  v10 = 32;
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) & 1) == 0)
  {
LABEL_28:
    *(_DWORD *)(a1 + 92) = 33;
    result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
    if (result >= 2)
      goto LABEL_56;
    if (!(_DWORD)result)
      return result;
    goto LABEL_30;
  }
LABEL_24:
  *(_DWORD *)(a1 + 92) = v10;
  *(_QWORD *)(a1 + 96) = v6;
  v11 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
  if (v11 >= 2)
    goto LABEL_56;
  if (!v11)
    goto LABEL_28;
LABEL_30:
  if ((*(_BYTE *)(v6 + 48) & 2) == 0 || (*(_BYTE *)(v6 + 52) & 2) != 0)
    goto LABEL_36;
  *(_DWORD *)(a1 + 92) = 35;
  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2)
    goto LABEL_56;
  if ((_DWORD)result)
  {
LABEL_36:
    if ((*(_BYTE *)(a1 + 120) & 0x80) != 0)
      goto LABEL_37;
    *(_DWORD *)(a1 + 92) = 44;
    result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
    if (result >= 2)
      goto LABEL_56;
    if ((_DWORD)result)
    {
LABEL_37:
      if ((*(_BYTE *)(a2 + 48) & 2) == 0)
        goto LABEL_59;
      *(_DWORD *)(a1 + 92) = 41;
      result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
      if (result >= 2)
        goto LABEL_56;
      if ((_DWORD)result)
      {
LABEL_59:
        if ((*(_BYTE *)(a1 + 120) & 0x40) != 0 || (result = check_crl_time(a1, a2, 1), (_DWORD)result))
        {
          v13 = *(_QWORD *)(*(_QWORD *)v6 + 48);
          if (v13)
          {
            v14 = *(EVP_PKEY **)(v13 + 16);
            if (v14)
            {
              if (X509_ALGOR_cmp(*(_QWORD **)(a2 + 8), *(_QWORD **)(*(_QWORD *)a2 + 8)))
              {
                ERR_put_error(11, 0, 137, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x_crl.c", 319);
              }
              else if (ASN1_item_verify(&X509_CRL_INFO_it, *(X509_ALGOR **)(a2 + 8), *(ASN1_BIT_STRING **)(a2 + 16), *(void **)a2, v14) > 0)
              {
                return 1;
              }
              *(_DWORD *)(a1 + 92) = 8;
              result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
              if (result < 2)
              {
                if (!(_DWORD)result)
                  return result;
                return 1;
              }
LABEL_56:
              abort();
            }
            ERR_put_error(11, 0, 125, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x_pubkey.c", 162);
          }
          *(_DWORD *)(a1 + 92) = 6;
          result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
          if (result >= 2)
            goto LABEL_56;
          if ((_DWORD)result)
            return 1;
        }
      }
    }
  }
  return result;
}

int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)
{
  if (!strcmp(name, "default"))
    return x509_verify_param_copy((uint64_t)ctx->crls, (uint64_t)&kDefaultParam, 0);
  if (!strcmp(name, "pkcs7") || !strcmp(name, "smime_sign"))
    return x509_verify_param_copy((uint64_t)ctx->crls, (uint64_t)&kSMIMESignParam, 0);
  if (!strcmp(name, "ssl_client"))
    return x509_verify_param_copy((uint64_t)ctx->crls, (uint64_t)&kSSLClientParam, 0);
  if (!strcmp(name, "ssl_server"))
    return x509_verify_param_copy((uint64_t)ctx->crls, (uint64_t)&kSSLServerParam, 0);
  return 0;
}

BOOL get_crl_sk(uint64_t a1, ASN1_VALUE **a2, _QWORD *a3, int *a4, _QWORD *a5)
{
  int v5;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  int v11;
  time_t *v12;
  time_t v13;
  time_t v14;
  int *v15;
  BOOL v16;
  int *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  uint64_t v26;
  _BOOL4 v27;
  unint64_t v28;
  _QWORD *v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  size_t v33;
  unsigned int v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  const X509_NAME *v42;
  const X509_NAME *v43;
  unint64_t *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t *v47;
  unint64_t *v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  unsigned int *v54;
  unsigned int v55;
  unsigned int v56;
  unint64_t v58;
  _QWORD *v62;
  int v63;
  int v64;
  unsigned int *v65;
  uint64_t v66;
  time_t v67;
  ASN1_VALUE *pval[2];
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  __int128 v72;

  v5 = *a4;
  if (a5)
  {
    if (*a5)
    {
      v62 = 0;
      v8 = 0;
      v9 = *(_QWORD *)(a1 + 96);
      v65 = 0;
      v66 = v9;
      while (1)
      {
        v10 = *(unsigned int **)(a5[1] + 8 * v8);
        if ((v10[12] & 0x62) != 0
          || X509_NAME_cmp(*(const X509_NAME **)(*(_QWORD *)v9 + 24), *(const X509_NAME **)(*(_QWORD *)v10 + 16)))
        {
          goto LABEL_5;
        }
        if ((*((_BYTE *)v10 + 29) & 2) != 0)
          v11 = 32;
        else
          v11 = 288;
        v12 = *(time_t **)(a1 + 32);
        v13 = v12[1];
        if ((v13 & 0x200000) != 0)
        {
LABEL_28:
          v11 |= 0x40u;
          goto LABEL_29;
        }
        if ((v13 & 2) != 0)
          v14 = *v12;
        else
          v14 = time(0);
        v15 = *(int **)(*(_QWORD *)v10 + 24);
        pval[0] = 0;
        if (ASN1_TIME_to_posix(v15, pval))
          v16 = (uint64_t)pval[0] <= v14;
        else
          v16 = 0;
        if (v16)
        {
          v17 = *(int **)(*(_QWORD *)v10 + 32);
          if (!v17)
            goto LABEL_28;
          v67 = 0;
          v71 = 0;
          v69 = 0u;
          v70 = 0u;
          *(_OWORD *)pval = 0u;
          v18 = v17[1];
          if (v18 == 24)
          {
            v21 = *((_QWORD *)v17 + 1);
            v22 = *v17;
            *(_QWORD *)&v72 = v21;
            *((_QWORD *)&v72 + 1) = v22;
            if (!CBS_parse_rfc5280_time_internal(&v72, 1, 0, (int *)pval))
              goto LABEL_29;
          }
          else
          {
            if (v18 != 23)
              goto LABEL_29;
            v19 = *((_QWORD *)v17 + 1);
            v20 = *v17;
            *(_QWORD *)&v72 = v19;
            *((_QWORD *)&v72 + 1) = v20;
            if (!CBS_parse_rfc5280_time_internal(&v72, 0, 0, (int *)pval))
              goto LABEL_29;
          }
          if (OPENSSL_tm_to_posix((int *)pval, &v67) && v67 > v14)
            goto LABEL_28;
        }
LABEL_29:
        v23 = *(_QWORD *)(*(_QWORD *)v10 + 16);
        v24 = *(int *)(a1 + 88);
        v25 = *(unint64_t **)(a1 + 80);
        if (v25)
        {
          v26 = *v25 - 1;
          v27 = v26 != v24;
          if (v26 == v24)
            v28 = *(int *)(a1 + 88);
          else
            v28 = v24 + 1;
          if (*v25 <= v28)
          {
            v29 = 0;
            if (X509_check_akid(0, *((_QWORD *)v10 + 4)))
            {
LABEL_37:
              v30 = *(int **)(a1 + 80);
              if (!v30)
                goto LABEL_4;
              v31 = v24 + v27 + 1;
              while (1)
              {
                if (v31 >= *v30)
                  goto LABEL_4;
                if ((v29 = *(_QWORD **)(*((_QWORD *)v30 + 1) + 8 * v31),
                      v32 = *(_QWORD *)(*v29 + 40),
                      *(_QWORD *)(v32 + 24))
                  && !*(_DWORD *)(v32 + 8)
                  || (pval[0] = *(ASN1_VALUE **)(*v29 + 40),
                      (asn1_item_ex_i2d_opt((unint64_t **)pval, 0, (uint64_t)&X509_NAME_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) == 0))
                {
                  if (*(_QWORD *)(v23 + 24) && !*(_DWORD *)(v23 + 8)
                    || (pval[0] = (ASN1_VALUE *)v23,
                        (asn1_item_ex_i2d_opt((unint64_t **)pval, 0, (uint64_t)&X509_NAME_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) == 0))
                  {
                    v33 = *(int *)(v32 + 32);
                    if ((_DWORD)v33 == *(_DWORD *)(v23 + 32)
                      && (!(_DWORD)v33 || !memcmp(*(const void **)(v32 + 24), *(const void **)(v23 + 24), v33))
                      && !X509_check_akid(v29, *((_QWORD *)v10 + 4)))
                    {
                      break;
                    }
                  }
                }
                v30 = *(int **)(a1 + 80);
                ++v31;
                if (!v30)
                  goto LABEL_4;
              }
              v34 = v10[12];
              v63 = v5;
              v64 = v11 | 0xC;
              if ((v34 & 0x10) != 0)
                goto LABEL_99;
              goto LABEL_54;
            }
          }
          else
          {
            v29 = *(_QWORD **)(v25[1] + 8 * v28);
            if (X509_check_akid(v29, *((_QWORD *)v10 + 4)))
              goto LABEL_37;
          }
        }
        else
        {
          v29 = 0;
          v27 = v24 != -1;
          if (X509_check_akid(0, *((_QWORD *)v10 + 4)))
            goto LABEL_37;
        }
        v34 = v10[12];
        v63 = v5;
        v64 = v11 | 0x1C;
        if ((v34 & 0x10) != 0)
          goto LABEL_99;
LABEL_54:
        if ((*(_BYTE *)(v66 + 48) & 0x10) != 0)
        {
          if ((v34 & 4) != 0)
            goto LABEL_99;
        }
        else if ((v34 & 8) != 0)
        {
          goto LABEL_99;
        }
        v35 = *(unint64_t **)(v66 + 80);
        if (v35)
        {
          v36 = 0;
          do
          {
            if (v36 >= *v35)
              break;
            v37 = *(uint64_t **)(v35[1] + 8 * v36);
            if (v37[1] && v37[2])
            {
              v38 = (uint64_t *)*((_QWORD *)v10 + 5);
              if (!v38)
                goto LABEL_98;
              v39 = *v37;
              v40 = *v38;
              if (!*v37 || v40 == 0)
                goto LABEL_98;
              if (*(_DWORD *)v39 == 1)
              {
                v42 = *(const X509_NAME **)(v39 + 16);
                if (v42)
                {
                  if (*(_DWORD *)v40 != 1)
                  {
                    v39 = *v38;
LABEL_88:
                    v49 = *(unint64_t **)(v39 + 8);
                    if (v49)
                    {
                      v50 = *v49;
                      if (*v49)
                      {
                        v51 = 0;
                        while (1)
                        {
                          v52 = *(_QWORD *)(v49[1] + 8 * v51);
                          if (*(_DWORD *)v52 == 4)
                          {
                            if (!X509_NAME_cmp(v42, *(const X509_NAME **)(v52 + 8)))
                              goto LABEL_98;
                            v50 = *v49;
                          }
                          if (++v51 >= v50)
                            goto LABEL_60;
                        }
                      }
                    }
                    goto LABEL_60;
                  }
                  v43 = *(const X509_NAME **)(v40 + 16);
                  if (v43 && !X509_NAME_cmp(*(const X509_NAME **)(v39 + 16), v43))
                    goto LABEL_98;
                }
              }
              else
              {
                if (*(_DWORD *)v40 != 1)
                {
                  v44 = *(unint64_t **)(v39 + 8);
                  if (v44)
                  {
                    v58 = 0;
                    do
                    {
                      if (v58 >= *v44)
                        break;
                      v45 = 0;
                      v46 = *(_QWORD *)(v44[1] + 8 * v58);
                      while (1)
                      {
                        v47 = *(unint64_t **)(v40 + 8);
                        if (!v47 || v45 >= *v47)
                          break;
                        if (!GENERAL_NAME_cmp(v46, *(_QWORD *)(v47[1] + 8 * v45++)))
                          goto LABEL_98;
                      }
                      ++v58;
                      v44 = *(unint64_t **)(v39 + 8);
                    }
                    while (v44);
                  }
                  goto LABEL_60;
                }
                v42 = *(const X509_NAME **)(v40 + 16);
                if (v42)
                  goto LABEL_88;
              }
            }
LABEL_60:
            ++v36;
            v35 = *(unint64_t **)(v66 + 80);
          }
          while (v35);
        }
        v53 = (_QWORD *)*((_QWORD *)v10 + 5);
        if (!v53 || !*v53)
LABEL_98:
          v64 |= 0x80u;
LABEL_99:
        v5 = v63;
        if (v64 < v63)
        {
LABEL_4:
          v9 = v66;
          goto LABEL_5;
        }
        if (v64 == v63 && v65)
        {
          LODWORD(pval[0]) = 0;
          LODWORD(v72) = 0;
          if (ASN1_TIME_diff(pval, &v72, *(int **)(*(_QWORD *)v65 + 24), *(int **)(*(_QWORD *)v10 + 24)))
          {
            v9 = v66;
            if (SLODWORD(pval[0]) > 0 || (int)v72 >= 1)
            {
              v5 = v64;
              v65 = v10;
              v62 = v29;
            }
            goto LABEL_5;
          }
        }
        else
        {
          v5 = v64;
          v65 = v10;
          v62 = v29;
        }
        v9 = v66;
LABEL_5:
        if ((unint64_t)++v8 >= *a5)
          goto LABEL_111;
      }
    }
    v62 = 0;
    v65 = 0;
LABEL_111:
    if (v65)
    {
      if (*a2)
      {
        pval[0] = *a2;
        ASN1_item_ex_free(pval, (const ASN1_ITEM *)&X509_CRL_INFO_it.sname);
      }
      *a2 = (ASN1_VALUE *)v65;
      *a3 = v62;
      *a4 = v5;
      v54 = v65 + 6;
      v55 = atomic_load(v65 + 6);
      if (v55 != -1)
      {
        do
        {
          v56 = __ldaxr(v54);
          if (v56 == v55)
          {
            if (!__stlxr(v55 + 1, v54))
              return v5 > 447;
          }
          else
          {
            __clrex();
          }
          v55 = v56;
        }
        while (v56 != -1);
      }
    }
  }
  return v5 > 447;
}

uint64_t check_crl_time(uint64_t a1, uint64_t a2, int a3)
{
  time_t *v3;
  time_t v4;
  time_t v8;
  int *v9;
  uint64_t result;
  int *v11;
  int *v12;
  int v13;
  time_t v14;

  v3 = *(time_t **)(a1 + 32);
  v4 = v3[1];
  if ((v4 & 0x200000) != 0)
    return 1;
  if (a3)
    *(_QWORD *)(a1 + 104) = a2;
  if ((v4 & 2) == 0)
  {
    v8 = time(0);
    v9 = *(int **)(*(_QWORD *)a2 + 24);
    v14 = 0;
    if (ASN1_TIME_to_posix(v9, &v14))
      goto LABEL_6;
LABEL_12:
    if (!a3)
      return 0;
    *(_DWORD *)(a1 + 92) = 15;
    result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
    if (result >= 2)
      goto LABEL_29;
    if (!(_DWORD)result)
      return result;
    goto LABEL_15;
  }
  v8 = *v3;
  v11 = *(int **)(*(_QWORD *)a2 + 24);
  v14 = 0;
  if (!ASN1_TIME_to_posix(v11, &v14))
    goto LABEL_12;
LABEL_6:
  if (v14 > v8)
  {
    if (!a3)
      return 0;
    *(_DWORD *)(a1 + 92) = 11;
    result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
    if (result >= 2)
      goto LABEL_29;
    if (!(_DWORD)result)
      return result;
  }
LABEL_15:
  v12 = *(int **)(*(_QWORD *)a2 + 32);
  if (!v12)
    goto LABEL_18;
  v14 = 0;
  if (!ASN1_TIME_to_posix(v12, &v14))
  {
    if (a3)
    {
      v13 = 16;
      goto LABEL_24;
    }
    return 0;
  }
  if (v14 > v8)
  {
LABEL_18:
    if (!a3)
      return 1;
LABEL_26:
    *(_QWORD *)(a1 + 104) = 0;
    return 1;
  }
  if (!a3)
    return 0;
  v13 = 12;
LABEL_24:
  *(_DWORD *)(a1 + 92) = v13;
  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 48))(0, a1);
  if (result >= 2)
LABEL_29:
    abort();
  if ((_DWORD)result)
    goto LABEL_26;
  return result;
}

uint64_t sk_X509_call_free_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  ASN1_OBJECT *v5;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  unint64_t *v10;
  uint64_t v11;
  size_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  size_t v19;
  unint64_t v20;
  void *v21;
  uint64_t v22;
  size_t v23;
  unint64_t *v24;
  uint64_t v25;
  size_t v26;
  char *name;
  char *v28;
  uint64_t v29;
  size_t v30;
  unint64_t inh_flags;
  void *v32;
  uint64_t v33;
  size_t v34;
  STACK **p_policies;
  STACK *policies;
  size_t p_data;

  if (param)
  {
    v2 = *(unint64_t **)&param->purpose;
    if (v2)
    {
      v3 = *v2;
      if (*v2)
      {
        v4 = 0;
        do
        {
          v5 = *(ASN1_OBJECT **)(v2[1] + 8 * v4);
          if (v5)
          {
            ASN1_OBJECT_free(v5);
            v3 = *v2;
          }
          ++v4;
        }
        while (v4 < v3);
      }
      v6 = v2[1];
      if (v6)
      {
        v8 = *(_QWORD *)(v6 - 8);
        v7 = (void *)(v6 - 8);
        v9 = v8 + 8;
        if (v8 != -8)
          bzero(v7, v9);
        free(v7);
      }
      v11 = *(v2 - 1);
      v10 = v2 - 1;
      v12 = v11 + 8;
      if (v11 != -8)
        bzero(v10, v12);
      free(v10);
    }
    v13 = *(unint64_t **)&param->depth;
    if (v13)
    {
      v14 = *v13;
      if (*v13)
      {
        v15 = 0;
        do
        {
          v16 = *(_QWORD *)(v13[1] + 8 * v15);
          if (v16)
          {
            v18 = *(_QWORD *)(v16 - 8);
            v17 = (void *)(v16 - 8);
            v19 = v18 + 8;
            if (v18 != -8)
              bzero(v17, v19);
            free(v17);
            v14 = *v13;
          }
          ++v15;
        }
        while (v15 < v14);
      }
      v20 = v13[1];
      if (v20)
      {
        v22 = *(_QWORD *)(v20 - 8);
        v21 = (void *)(v20 - 8);
        v23 = v22 + 8;
        if (v22 != -8)
          bzero(v21, v23);
        free(v21);
      }
      v25 = *(v13 - 1);
      v24 = v13 - 1;
      v26 = v25 + 8;
      if (v25 != -8)
        bzero(v24, v26);
      free(v24);
    }
    name = param[1].name;
    if (name)
    {
      v29 = *((_QWORD *)name - 1);
      v28 = name - 8;
      v30 = v29 + 8;
      if (v29 != -8)
        bzero(v28, v30);
      free(v28);
    }
    inh_flags = param[1].inh_flags;
    if (inh_flags)
    {
      v33 = *(_QWORD *)(inh_flags - 8);
      v32 = (void *)(inh_flags - 8);
      v34 = v33 + 8;
      if (v33 != -8)
        bzero(v32, v34);
      free(v32);
    }
    policies = param[-1].policies;
    p_policies = &param[-1].policies;
    p_data = (size_t)&policies->data;
    if (policies != (STACK *)-8)
      bzero(p_policies, p_data);
    free(p_policies);
  }
}

uint64_t x509_verify_param_copy(uint64_t a1, uint64_t a2, int a3)
{
  int v6;
  BOOL v7;
  int v8;
  BOOL v9;
  int v10;
  BOOL v11;
  int v12;
  int v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t *v18;
  BOOL v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  ASN1_OBJECT *v23;
  uint64_t result;
  unint64_t v25;
  void *v26;
  uint64_t v27;
  size_t v28;
  unint64_t *v29;
  uint64_t v30;
  size_t v31;
  char *v32;
  _QWORD *v33;
  unint64_t *v34;
  size_t v35;
  const void *v36;
  _QWORD *v37;
  _QWORD *v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t i;
  const ASN1_OBJECT *v42;
  unint64_t *v43;
  BOOL v44;
  int v45;
  BOOL v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  size_t v52;
  unint64_t v53;
  void *v54;
  uint64_t v55;
  size_t v56;
  unint64_t *v57;
  uint64_t v58;
  size_t v59;
  unint64_t *v60;
  char *v61;
  _QWORD *v62;
  unint64_t *v63;
  size_t v64;
  const void *v65;
  _QWORD *v66;
  _QWORD *v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  const char *v71;
  uint64_t k;
  uint64_t v73;
  void *v74;
  uint64_t v75;
  size_t v76;
  const void *v77;
  BOOL v78;
  int v79;
  BOOL v80;
  const void *v81;
  BOOL v82;
  int v83;
  size_t v84;
  _QWORD *v85;
  _QWORD *v86;
  uint64_t v87;
  void *v88;
  uint64_t v89;
  size_t v90;
  char v91;
  size_t v92;
  _QWORD *v93;
  _QWORD *v94;
  uint64_t v95;
  void *v96;
  uint64_t v97;
  size_t v98;
  BOOL v99;
  uint64_t j;
  ASN1_OBJECT *v101;
  _QWORD *v102;
  uint64_t v103;
  size_t v104;
  _QWORD *v105;
  uint64_t v106;
  size_t v107;

  if (!a2)
    return 1;
  v6 = *(_DWORD *)(a2 + 16);
  if (a3)
    v7 = 1;
  else
    v7 = *(_DWORD *)(a1 + 16) == 0;
  v8 = v7;
  if (v6)
    v9 = v8 == 0;
  else
    v9 = 1;
  if (!v9)
    *(_DWORD *)(a1 + 16) = v6;
  v10 = *(_DWORD *)(a2 + 20);
  if (a3)
    v11 = 1;
  else
    v11 = *(_DWORD *)(a1 + 20) == 0;
  v12 = v11;
  if (v10 && v12)
    *(_DWORD *)(a1 + 20) = v10;
  v13 = *(_DWORD *)(a2 + 24);
  if (a3)
    v14 = 1;
  else
    v14 = *(_DWORD *)(a1 + 24) == -1;
  v15 = v14;
  if (v13 != -1 && v15)
    *(_DWORD *)(a1 + 24) = v13;
  v16 = *(_QWORD *)(a1 + 8);
  if ((v16 & 2) == 0)
    *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8) | v16;
  v17 = *(unint64_t **)(a1 + 32);
  v18 = *(unint64_t **)(a2 + 32);
  if (a3)
    v19 = 1;
  else
    v19 = v17 == 0;
  v20 = v19;
  if (v18 && v20)
  {
    if (v17)
    {
      v21 = *v17;
      if (*v17)
      {
        v22 = 0;
        do
        {
          v23 = *(ASN1_OBJECT **)(v17[1] + 8 * v22);
          if (v23)
          {
            ASN1_OBJECT_free(v23);
            v21 = *v17;
          }
          ++v22;
        }
        while (v22 < v21);
      }
      v25 = v17[1];
      if (v25)
      {
        v27 = *(_QWORD *)(v25 - 8);
        v26 = (void *)(v25 - 8);
        v28 = v27 + 8;
        if (v27 != -8)
          bzero(v26, v28);
        free(v26);
      }
      v30 = *(v17 - 1);
      v29 = v17 - 1;
      v31 = v30 + 8;
      if (v30 != -8)
        bzero(v29, v31);
      free(v29);
    }
    v32 = (char *)malloc_type_malloc(0x30uLL, 0x30772F57uLL);
    if (!v32)
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      goto LABEL_70;
    }
    v33 = v32;
    *(_OWORD *)(v32 + 8) = 0u;
    v34 = (unint64_t *)(v32 + 8);
    *(_QWORD *)v32 = 40;
    *(_OWORD *)(v32 + 24) = 0u;
    *((_QWORD *)v32 + 5) = 0;
    v35 = 8 * v18[3];
    if (v35 == -8)
      goto LABEL_66;
    if (!v35)
      goto LABEL_67;
    v36 = (const void *)v18[1];
    v37 = malloc_type_malloc(v35 + 8, 0x30772F57uLL);
    if (!v37)
    {
LABEL_66:
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      goto LABEL_67;
    }
    *v37 = v35;
    v38 = v37 + 1;
    memcpy(v37 + 1, v36, v35);
    v39 = *v18;
    v33[1] = *v18;
    v33[2] = v38;
    *((_DWORD *)v33 + 6) = *((_DWORD *)v18 + 4);
    v40 = v18[4];
    v33[4] = v18[3];
    v33[5] = v40;
    if (v39)
    {
      for (i = 0; i < v39; ++i)
      {
        v42 = (const ASN1_OBJECT *)v38[i];
        if (v42)
        {
          *(_QWORD *)(v33[2] + 8 * i) = OBJ_dup(v42);
          v38 = (_QWORD *)v33[2];
          if (!v38[i])
          {
            if (!i)
              goto LABEL_175;
            for (j = 0; j != i; ++j)
            {
              v101 = *(ASN1_OBJECT **)(v33[2] + 8 * j);
              if (v101)
                ASN1_OBJECT_free(v101);
            }
            v38 = (_QWORD *)v33[2];
            if (v38)
            {
LABEL_175:
              v103 = *(v38 - 1);
              v102 = v38 - 1;
              v104 = v103 + 8;
              if (v103 != -8)
                bzero(v102, v104);
              free(v102);
            }
LABEL_67:
            if (*v33 != -8)
              __memset_chk();
            free(v33);
LABEL_70:
            result = 0;
            *(_QWORD *)(a1 + 32) = 0;
            return result;
          }
          v39 = *v34;
        }
      }
    }
    *(_QWORD *)(a1 + 32) = v34;
  }
  v43 = *(unint64_t **)(a1 + 40);
  if (a3)
    v44 = 1;
  else
    v44 = v43 == 0;
  v45 = v44;
  if (*(_QWORD *)(a2 + 40))
    v46 = v45 == 0;
  else
    v46 = 1;
  if (v46)
    goto LABEL_122;
  if (v43)
  {
    v47 = *v43;
    if (*v43)
    {
      v48 = 0;
      do
      {
        v49 = *(_QWORD *)(v43[1] + 8 * v48);
        if (v49)
        {
          v51 = *(_QWORD *)(v49 - 8);
          v50 = (void *)(v49 - 8);
          v52 = v51 + 8;
          if (v51 != -8)
            bzero(v50, v52);
          free(v50);
          v47 = *v43;
        }
        ++v48;
      }
      while (v48 < v47);
    }
    v53 = v43[1];
    if (v53)
    {
      v55 = *(_QWORD *)(v53 - 8);
      v54 = (void *)(v53 - 8);
      v56 = v55 + 8;
      if (v55 != -8)
        bzero(v54, v56);
      free(v54);
    }
    v58 = *(v43 - 1);
    v57 = v43 - 1;
    v59 = v58 + 8;
    if (v58 != -8)
      bzero(v57, v59);
    free(v57);
  }
  *(_QWORD *)(a1 + 40) = 0;
  v60 = *(unint64_t **)(a2 + 40);
  if (!v60)
  {
LABEL_122:
    v77 = *(const void **)(a2 + 56);
    if (a3)
      v78 = 1;
    else
      v78 = *(_QWORD *)(a1 + 56) == 0;
    v79 = v78;
    if (v77)
      v80 = v79 == 0;
    else
      v80 = 1;
    if (v80)
    {
      v81 = *(const void **)(a2 + 72);
      if (a3)
        v82 = 1;
      else
        v82 = *(_QWORD *)(a1 + 72) == 0;
      v83 = v82;
      if (!v81)
        goto LABEL_149;
    }
    else
    {
      v92 = *(_QWORD *)(a2 + 64);
      if (!v92 || memchr(*(void **)(a2 + 56), 0, *(_QWORD *)(a2 + 64)))
        goto LABEL_167;
      if (v92 > 0xFFFFFFFFFFFFFFF7)
        goto LABEL_166;
      v93 = malloc_type_malloc(v92 + 8, 0x30772F57uLL);
      if (!v93)
        goto LABEL_166;
      *v93 = v92;
      v94 = v93 + 1;
      memcpy(v93 + 1, v77, v92);
      v95 = *(_QWORD *)(a1 + 56);
      if (v95)
      {
        v97 = *(_QWORD *)(v95 - 8);
        v96 = (void *)(v95 - 8);
        v98 = v97 + 8;
        if (v97 != -8)
          bzero(v96, v98);
        free(v96);
      }
      *(_QWORD *)(a1 + 56) = v94;
      *(_QWORD *)(a1 + 64) = v92;
      v81 = *(const void **)(a2 + 72);
      if (a3)
        v99 = 1;
      else
        v99 = *(_QWORD *)(a1 + 72) == 0;
      v83 = v99;
      if (!v81)
        goto LABEL_149;
    }
    if (v83)
    {
      v84 = *(_QWORD *)(a2 + 80);
      if (v84 != 16 && v84 != 4)
        goto LABEL_167;
      v85 = malloc_type_malloc(v84 + 8, 0x30772F57uLL);
      if (v85)
      {
        *v85 = v84;
        v86 = v85 + 1;
        memcpy(v85 + 1, v81, v84);
        v87 = *(_QWORD *)(a1 + 72);
        if (v87)
        {
          v89 = *(_QWORD *)(v87 - 8);
          v88 = (void *)(v87 - 8);
          v90 = v89 + 8;
          if (v89 != -8)
            bzero(v88, v90);
          free(v88);
        }
        *(_QWORD *)(a1 + 72) = v86;
        *(_QWORD *)(a1 + 80) = v84;
        goto LABEL_149;
      }
LABEL_166:
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
LABEL_167:
      result = 0;
      v91 = 1;
      goto LABEL_168;
    }
LABEL_149:
    v91 = *(_BYTE *)(a2 + 88);
    result = 1;
LABEL_168:
    *(_BYTE *)(a1 + 88) = v91;
    return result;
  }
  v61 = (char *)malloc_type_malloc(0x30uLL, 0x30772F57uLL);
  if (!v61)
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    goto LABEL_120;
  }
  v62 = v61;
  *(_OWORD *)(v61 + 8) = 0u;
  v63 = (unint64_t *)(v61 + 8);
  *(_QWORD *)v61 = 40;
  *(_OWORD *)(v61 + 24) = 0u;
  *((_QWORD *)v61 + 5) = 0;
  v64 = 8 * v60[3];
  if (v64 == -8)
    goto LABEL_116;
  if (!v64)
    goto LABEL_117;
  v65 = (const void *)v60[1];
  v66 = malloc_type_malloc(v64 + 8, 0x30772F57uLL);
  if (!v66)
  {
LABEL_116:
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    goto LABEL_117;
  }
  *v66 = v64;
  v67 = v66 + 1;
  memcpy(v66 + 1, v65, v64);
  v68 = *v60;
  v62[1] = *v60;
  v62[2] = v67;
  *((_DWORD *)v62 + 6) = *((_DWORD *)v60 + 4);
  v69 = v60[4];
  v62[4] = v60[3];
  v62[5] = v69;
  if (!v68)
  {
LABEL_121:
    *(_QWORD *)(a1 + 40) = v63;
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
    goto LABEL_122;
  }
  v70 = 0;
  while (1)
  {
    v71 = (const char *)v67[v70];
    if (!v71)
      goto LABEL_105;
    *(_QWORD *)(v62[2] + 8 * v70) = OPENSSL_strdup(v71);
    v67 = (_QWORD *)v62[2];
    if (!v67[v70])
      break;
    v68 = *v63;
LABEL_105:
    if (++v70 >= v68)
      goto LABEL_121;
  }
  if (!v70)
    goto LABEL_179;
  for (k = 0; k != v70; ++k)
  {
    v73 = *(_QWORD *)(v62[2] + 8 * k);
    if (v73)
    {
      v75 = *(_QWORD *)(v73 - 8);
      v74 = (void *)(v73 - 8);
      v76 = v75 + 8;
      if (v75 != -8)
        bzero(v74, v76);
      free(v74);
    }
  }
  v67 = (_QWORD *)v62[2];
  if (v67)
  {
LABEL_179:
    v106 = *(v67 - 1);
    v105 = v67 - 1;
    v107 = v106 + 8;
    if (v106 != -8)
      bzero(v105, v107);
    free(v105);
  }
LABEL_117:
  if (*v62 != -8)
    __memset_chk();
  free(v62);
LABEL_120:
  result = 0;
  *(_QWORD *)(a1 + 40) = 0;
  return result;
}

uint64_t int_x509_param_set_hosts(uint64_t a1, int a2, _BYTE *__s, size_t __n)
{
  uint64_t result;
  void *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  size_t v16;
  unint64_t v17;
  void *v18;
  uint64_t v19;
  size_t v20;
  unint64_t *v21;
  uint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t *v25;
  _QWORD *v26;
  uint64_t v27;
  size_t v28;
  BUF_MEM *v29;

  result = 0;
  if (__s)
  {
    if (__n)
    {
      v9 = memchr(__s, 0, __n);
      result = 0;
      if (!v9)
      {
        if (!a2)
        {
          v10 = *(unint64_t **)(a1 + 40);
          if (v10)
          {
            v11 = *v10;
            if (*v10)
            {
              v12 = 0;
              do
              {
                v13 = *(_QWORD *)(v10[1] + 8 * v12);
                if (v13)
                {
                  v15 = *(_QWORD *)(v13 - 8);
                  v14 = (void *)(v13 - 8);
                  v16 = v15 + 8;
                  if (v15 != -8)
                    bzero(v14, v16);
                  free(v14);
                  v11 = *v10;
                }
                ++v12;
              }
              while (v12 < v11);
            }
            v17 = v10[1];
            if (v17)
            {
              v19 = *(_QWORD *)(v17 - 8);
              v18 = (void *)(v17 - 8);
              v20 = v19 + 8;
              if (v19 != -8)
                bzero(v18, v20);
              free(v18);
            }
            v22 = *(v10 - 1);
            v21 = v10 - 1;
            v23 = v22 + 8;
            if (v22 != -8)
              bzero(v21, v23);
            free(v21);
            *(_QWORD *)(a1 + 40) = 0;
          }
        }
        result = (uint64_t)OPENSSL_strndup(__s, __n);
        if (result)
        {
          v24 = (_QWORD *)result;
          v25 = *(unint64_t **)(a1 + 40);
          if (v25 || (v25 = (unint64_t *)OPENSSL_sk_new_null(), (*(_QWORD *)(a1 + 40) = v25) != 0))
          {
            if (OPENSSL_sk_insert(v25, (uint64_t)v24, *v25))
            {
              return 1;
            }
            else
            {
              v27 = *(v24 - 1);
              v26 = v24 - 1;
              v28 = v27 + 8;
              if (v27 != -8)
                bzero(v26, v28);
              free(v26);
              v29 = *(BUF_MEM **)(a1 + 40);
              if (v29 && *(_QWORD *)&v29->length)
              {
                return 0;
              }
              else
              {
                ASN1_STRING_free(v29);
                result = 0;
                *(_QWORD *)(a1 + 40) = 0;
              }
            }
          }
          else
          {
            OPENSSL_free(v24);
            return 0;
          }
        }
      }
    }
  }
  return result;
}

int X509_NAME_get_index_by_NID(X509_NAME *name, int nid, int lastpos)
{
  char **v3;
  STACK *entries;
  uint64_t num;
  uint64_t v6;
  int v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  int v12;

  if (nid)
  {
    if (nid > 0x3C4)
    {
      if (pthread_rwlock_rdlock(&global_added_lock) || pthread_rwlock_unlock(&global_added_lock))
        abort();
    }
    else
    {
      v3 = &kObjects[5 * (nid - 1)];
      if (*((_DWORD *)v3 + 4))
      {
        if (name)
          goto LABEL_5;
        goto LABEL_8;
      }
    }
    ERR_put_error(8, 0, 100, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/obj/obj.c", 373);
    return -2;
  }
  v3 = OBJ_get_undef_kUndef;
  if (name)
  {
LABEL_5:
    entries = name->entries;
    if (name->entries)
      num = entries->num;
    else
      num = 0;
    if (lastpos < 0)
      v8 = -1;
    else
      v8 = lastpos;
    v9 = v8 + 1;
    while (v9 < num)
    {
      v6 = v9;
      v10 = *(_QWORD *)entries->data[v9];
      v11 = *(int *)(v10 + 20);
      if ((_DWORD)v11 == *((_DWORD *)v3 + 5))
      {
        if (!(_DWORD)v11)
          return v6;
        v12 = memcmp(*(const void **)(v10 + 24), v3[3], v11);
        v9 = v6 + 1;
        if (!v12)
          return v6;
      }
      else
      {
        v9 = v6 + 1;
      }
    }
    return -1;
  }
LABEL_8:
  LODWORD(v6) = -1;
  return v6;
}

X509_NAME_ENTRY *__cdecl X509_NAME_delete_entry(X509_NAME *name, int loc)
{
  X509_NAME_ENTRY *v2;
  STACK *entries;
  uint64_t v6;
  uint64_t v7;
  char **data;
  X509_NAME_ENTRY **v9;
  uint64_t v10;
  size_t v12;
  char **v13;
  int set;

  v2 = 0;
  if (name && (loc & 0x80000000) == 0)
  {
    entries = name->entries;
    if (!name->entries)
      return 0;
    v6 = *(_QWORD *)&entries->num;
    v7 = loc;
    if (*(_QWORD *)&entries->num <= (unint64_t)loc)
      return 0;
    data = entries->data;
    v9 = (X509_NAME_ENTRY **)&data[loc];
    v2 = *v9;
    v10 = v6 - 1;
    if (v6 - 1 == loc)
    {
      *(_QWORD *)&entries->num = loc;
      name->modified = 1;
      return v2;
    }
    v12 = 8 * (v6 + ~(unint64_t)loc);
    if (v12)
    {
      memmove(v9, &data[loc + 1], v12);
      v10 = *(_QWORD *)&entries->num - 1;
    }
    *(_QWORD *)&entries->num = v10;
    name->modified = 1;
    if (v10 != loc)
    {
      if (loc)
      {
        v13 = entries->data;
        set = *((_DWORD *)v13[loc - 1] + 4) + 1;
      }
      else
      {
        set = v2->set;
        v13 = entries->data;
      }
      if (set < *((_DWORD *)v13[loc] + 4))
      {
        do
          --*((_DWORD *)v13[v7++] + 4);
        while (v10 != v7);
      }
    }
  }
  return v2;
}

X509_NAME_ENTRY *__cdecl X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne, ASN1_OBJECT *obj, int type, const unsigned __int8 *bytes, int len)
{
  uint64_t v5;
  X509_NAME_ENTRY *v10;
  int v11;
  X509_NAME_ENTRY *result;
  ASN1_OBJECT *v14;
  int v15;
  ASN1_VALUE *pval;

  v5 = *(_QWORD *)&len;
  if (!ne || (v10 = *ne) == 0)
  {
    pval = 0;
    v11 = ASN1_item_ex_new(&pval, &X509_NAME_ENTRY_it);
    result = 0;
    v10 = (X509_NAME_ENTRY *)pval;
    if (!v11 || pval == 0)
      return result;
  }
  if (!obj)
  {
    ERR_put_error(11, 0, 67, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x509name.c", 364);
    goto LABEL_16;
  }
  ASN1_OBJECT_free(v10->object);
  v14 = OBJ_dup(obj);
  v10->object = v14;
  if (!v14 || !bytes && v5)
    goto LABEL_16;
  if (type >= 1 && (type & 0x1000) != 0)
  {
    v15 = OBJ_obj2nid(v14);
    if (!ASN1_STRING_set_by_NID(&v10->value, bytes, v5, type, v15))
    {
LABEL_16:
      if (!ne || v10 != *ne)
      {
        pval = (ASN1_VALUE *)v10;
        ASN1_item_ex_free(&pval, &X509_NAME_ENTRY_it);
      }
      return 0;
    }
  }
  else
  {
    if (v5 < 0)
      LODWORD(v5) = strlen((const char *)bytes);
    if (!ASN1_STRING_set(v10->value, bytes, v5))
      goto LABEL_16;
    if (type != -1)
      v10->value->type = type;
  }
  if (ne && !*ne)
    *ne = v10;
  return v10;
}

int X509_NAME_add_entry(X509_NAME *name, X509_NAME_ENTRY *ne, int loc, int set)
{
  unint64_t *entries;
  int v5;
  int v7;
  _BOOL4 v8;
  int v9;
  ASN1_VALUE *v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  ASN1_VALUE *pval;

  if (name)
  {
    entries = (unint64_t *)name->entries;
    if (name->entries)
      v5 = *(_DWORD *)entries;
    else
      v5 = 0;
    if (v5 < loc || loc < 0)
      v7 = v5;
    else
      v7 = loc;
    v8 = set == 0;
    name->modified = 1;
    if (set == -1)
    {
      if (v7)
      {
        v8 = 0;
        v9 = *(_DWORD *)(*(_QWORD *)(entries[1] + 8 * v7 - 8) + 16);
        name = (X509_NAME *)ASN1_item_dup(&X509_NAME_ENTRY_it, ne);
        if (!name)
          return (int)name;
      }
      else
      {
        v9 = 0;
        v8 = 1;
        name = (X509_NAME *)ASN1_item_dup(&X509_NAME_ENTRY_it, ne);
        if (!name)
          return (int)name;
      }
    }
    else if (v7 >= v5)
    {
      if (v7)
      {
        v9 = *(_DWORD *)(*(_QWORD *)(entries[1] + 8 * v7 - 8) + 16) + 1;
        name = (X509_NAME *)ASN1_item_dup(&X509_NAME_ENTRY_it, ne);
        if (!name)
          return (int)name;
      }
      else
      {
        v9 = 0;
        name = (X509_NAME *)ASN1_item_dup(&X509_NAME_ENTRY_it, ne);
        if (!name)
          return (int)name;
      }
    }
    else
    {
      v9 = *(_DWORD *)(*(_QWORD *)(entries[1] + 8 * v7) + 16);
      name = (X509_NAME *)ASN1_item_dup(&X509_NAME_ENTRY_it, ne);
      if (!name)
        return (int)name;
    }
    v10 = (ASN1_VALUE *)name;
    LODWORD(name->bytes) = v9;
    if (OPENSSL_sk_insert(entries, (uint64_t)name, v7))
    {
      if (v8)
      {
        if (entries)
        {
          v11 = *(_DWORD *)entries;
          LODWORD(v12) = v7 + 1;
          if (v7 + 1 < *(_DWORD *)entries)
          {
LABEL_31:
            v12 = (int)v12;
            v13 = entries[1];
            v14 = ~v7 + v11;
            do
            {
              ++*(_DWORD *)(*(_QWORD *)(v13 + 8 * v12++) + 16);
              --v14;
            }
            while (v14);
          }
        }
        else
        {
          v11 = 0;
          LODWORD(v12) = v7 + 1;
          if (v7 + 1 < 0)
            goto LABEL_31;
        }
      }
      LODWORD(name) = 1;
      return (int)name;
    }
    pval = v10;
    ASN1_item_ex_free(&pval, &X509_NAME_ENTRY_it);
    LODWORD(name) = 0;
  }
  return (int)name;
}

int X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type, const unsigned __int8 *bytes, int len, int loc, int set)
{
  ASN1_OBJECT *v14;
  ASN1_OBJECT *v15;
  X509_NAME_ENTRY *v16;
  int v17;
  ASN1_VALUE *pval;

  v14 = OBJ_txt2obj(field, 0);
  if (v14)
  {
    v15 = v14;
    v16 = X509_NAME_ENTRY_create_by_OBJ(0, v14, type, bytes, len);
    ASN1_OBJECT_free(v15);
    if (v16)
    {
      v17 = X509_NAME_add_entry(name, v16, loc, set);
      pval = (ASN1_VALUE *)v16;
      ASN1_item_ex_free(&pval, &X509_NAME_ENTRY_it);
      return v17;
    }
  }
  else
  {
    ERR_put_error(11, 0, 111, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x509name.c", 309);
    ERR_add_error_data(2, "name=", field);
  }
  return 0;
}

X509_ALGOR *__cdecl d2i_X509_ALGOR(X509_ALGOR **a, const unsigned __int8 **in, uint64_t len)
{
  X509_ALGOR *result;
  ASN1_VALUE *pval;

  pval = 0;
  if ((int)asn1_item_ex_d2i((uint64_t)&pval, (unsigned __int8 **)in, len, (uint64_t)&X509_ALGOR_it, -1, 0, 0, 0, 0) <= 0)
  {
    ASN1_item_ex_free(&pval, &X509_ALGOR_it);
    if (a)
      goto LABEL_3;
  }
  else if (a)
  {
LABEL_3:
    ASN1_item_ex_free((ASN1_VALUE **)a, &X509_ALGOR_it);
    result = (X509_ALGOR *)pval;
    *a = (X509_ALGOR *)pval;
    return result;
  }
  return (X509_ALGOR *)pval;
}

uint64_t X509_ALGOR_cmp(_QWORD *a1, _QWORD *a2)
{
  size_t v2;
  int v3;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  int v13;

  v2 = *(int *)(*a1 + 20);
  v3 = *(_DWORD *)(*a2 + 20);
  if ((int)v2 < v3)
    return 0xFFFFFFFFLL;
  if ((int)v2 > v3)
    return 1;
  if (!(_DWORD)v2 || (result = memcmp(*(const void **)(*a1 + 24), *(const void **)(*a2 + 24), v2), !(_DWORD)result))
  {
    v7 = a1[1];
    v8 = a2[1];
    if (!(v7 | v8))
      return 0;
    result = 0xFFFFFFFFLL;
    if (v7)
    {
      if (v8)
      {
        v9 = *(_DWORD *)v7;
        if (*(_DWORD *)v7 == *(_DWORD *)v8)
        {
          if (v9 == 1)
            return (*(_DWORD *)(v7 + 8) - *(_DWORD *)(v8 + 8));
          if (v9 == 5)
            return 0;
          if (v9 != 6)
            return ASN1_STRING_cmp(*(ASN1_STRING **)(v7 + 8), *(ASN1_STRING **)(v8 + 8));
          v10 = *(_QWORD *)(v7 + 8);
          v11 = *(_QWORD *)(v8 + 8);
          v12 = *(int *)(v10 + 20);
          v13 = *(_DWORD *)(v11 + 20);
          if ((int)v12 >= v13)
          {
            if ((int)v12 > v13)
              return 1;
            if ((_DWORD)v12)
              return memcmp(*(const void **)(v10 + 24), *(const void **)(v11 + 24), v12);
            return 0;
          }
        }
      }
    }
  }
  return result;
}

int i2d_PKCS8_bio(BIO *bp, X509_SIG *p8)
{
  unsigned int v3;
  unsigned __int8 *v4;
  unint64_t v5;
  uint64_t v6;
  int (__cdecl *bwrite)(BIO *, const char *, int);
  unsigned int v8;
  int v9;
  unsigned __int8 *v11;
  uint64_t v12;
  size_t v13;
  unsigned __int8 *out;

  out = 0;
  v3 = ASN1_item_i2d((ASN1_VALUE *)p8, &out, &X509_SIG_it);
  if ((v3 & 0x80000000) != 0)
    return 0;
  v4 = out;
  if (!v3)
  {
    v9 = 1;
    if (out)
      goto LABEL_21;
    return v9;
  }
  if (bp)
  {
    v5 = v3;
    while (1)
    {
      v6 = v5 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : v5;
      if (!bp->method)
        break;
      bwrite = bp->method->bwrite;
      if (!bwrite)
        break;
      if (!LODWORD(bp->cb_arg))
      {
        ERR_put_error(17, 0, 114, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 171);
        v9 = 0;
        v4 = out;
        if (out)
          goto LABEL_21;
        return v9;
      }
      v8 = ((uint64_t (*)(BIO *, unsigned __int8 *, uint64_t))bwrite)(bp, v4, v6);
      if ((int)v8 <= 0)
        goto LABEL_18;
      bp->prev_bio = (bio_st *)((char *)bp->prev_bio + v8);
      v4 += v8;
      v5 -= v8;
      if (!v5)
      {
        v9 = 1;
        v4 = out;
        if (out)
          goto LABEL_21;
        return v9;
      }
    }
  }
  ERR_put_error(17, 0, 115, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 167);
LABEL_18:
  v9 = 0;
  v4 = out;
  if (!out)
    return v9;
LABEL_21:
  v12 = *((_QWORD *)v4 - 1);
  v11 = v4 - 8;
  v13 = v12 + 8;
  if (v12 != -8)
    bzero(v11, v13);
  free(v11);
  return v9;
}

int i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf)
{
  unsigned int v3;
  unsigned __int8 *v4;
  unint64_t v5;
  uint64_t v6;
  int (__cdecl *bwrite)(BIO *, const char *, int);
  unsigned int v8;
  int v9;
  unsigned __int8 *v11;
  uint64_t v12;
  size_t v13;
  unsigned __int8 *out;

  out = 0;
  v3 = ASN1_item_i2d((ASN1_VALUE *)p8inf, &out, &PKCS8_PRIV_KEY_INFO_it);
  if ((v3 & 0x80000000) != 0)
    return 0;
  v4 = out;
  if (!v3)
  {
    v9 = 1;
    if (out)
      goto LABEL_21;
    return v9;
  }
  if (bp)
  {
    v5 = v3;
    while (1)
    {
      v6 = v5 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : v5;
      if (!bp->method)
        break;
      bwrite = bp->method->bwrite;
      if (!bwrite)
        break;
      if (!LODWORD(bp->cb_arg))
      {
        ERR_put_error(17, 0, 114, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 171);
        v9 = 0;
        v4 = out;
        if (out)
          goto LABEL_21;
        return v9;
      }
      v8 = ((uint64_t (*)(BIO *, unsigned __int8 *, uint64_t))bwrite)(bp, v4, v6);
      if ((int)v8 <= 0)
        goto LABEL_18;
      bp->prev_bio = (bio_st *)((char *)bp->prev_bio + v8);
      v4 += v8;
      v5 -= v8;
      if (!v5)
      {
        v9 = 1;
        v4 = out;
        if (out)
          goto LABEL_21;
        return v9;
      }
    }
  }
  ERR_put_error(17, 0, 115, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/bio/bio.c", 167);
LABEL_18:
  v9 = 0;
  v4 = out;
  if (!out)
    return v9;
LABEL_21:
  v12 = *((_QWORD *)v4 - 1);
  v11 = v4 - 8;
  v13 = v12 + 8;
  if (v12 != -8)
    bzero(v11, v13);
  free(v11);
  return v9;
}

uint64_t X509_REVOKED_cmp(ASN1_STRING ***a1, ASN1_STRING ***a2)
{
  return ASN1_STRING_cmp(**a1, **a2);
}

uint64_t crl_lookup(uint64_t a1, ASN1_STRING ***a2, ASN1_STRING *a3, const X509_NAME *a4)
{
  uint64_t v8;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t (*v16)(_QWORD **, uint64_t *);
  int v17;
  unint64_t v18;
  _QWORD **v19;
  _QWORD **v20;
  _QWORD *v21;
  unsigned int (*v22)(_QWORD **, uint64_t *);
  unint64_t *v23;
  ASN1_STRING **v24;
  int v25;
  int v26;
  uint64_t result;
  int v28;
  int v29;
  _QWORD v30[4];
  uint64_t v31;
  _QWORD *v32;

  v30[0] = a3;
  if (pthread_rwlock_rdlock(&g_crl_sort_lock))
    goto LABEL_71;
  v8 = *(_QWORD *)(*(_QWORD *)a1 + 40);
  if (v8 && !*(_DWORD *)(v8 + 16))
  {
    if (!*(_QWORD *)(v8 + 32))
    {
      if (pthread_rwlock_unlock(&g_crl_sort_lock))
        goto LABEL_71;
      goto LABEL_11;
    }
    v9 = *(_QWORD *)v8 < 2uLL;
    if (pthread_rwlock_unlock(&g_crl_sort_lock))
      goto LABEL_71;
  }
  else
  {
    v9 = 1;
    if (pthread_rwlock_unlock(&g_crl_sort_lock))
      goto LABEL_71;
  }
  if (!v9)
  {
LABEL_11:
    if (!pthread_rwlock_wrlock(&g_crl_sort_lock))
    {
      v10 = *(_QWORD *)(*(_QWORD *)a1 + 40);
      if (v10 && !*(_DWORD *)(v10 + 16) && (!*(_QWORD *)(v10 + 32) || *(_QWORD *)v10 >= 2uLL))
        OPENSSL_sk_sort(v10, (uint64_t (*)(_QWORD, _QWORD, _QWORD))sk_X509_REVOKED_call_cmp_func);
      if (!pthread_rwlock_unlock(&g_crl_sort_lock))
        goto LABEL_18;
    }
LABEL_71:
    abort();
  }
LABEL_18:
  memset(&v30[1], 0, 24);
  v11 = *(_QWORD *)(*(_QWORD *)a1 + 40);
  if (!v11)
    return 0;
  if (*(_QWORD *)(v11 + 32))
  {
    v12 = *(_QWORD *)v11;
    if (*(_DWORD *)(v11 + 16))
      v13 = 0;
    else
      v13 = v12 >= 2;
    if (!v13)
    {
      if (v12)
      {
        v14 = 0;
        while (1)
        {
          v15 = v14 + ((v12 - v14 - 1) >> 1);
          v16 = *(uint64_t (**)(_QWORD **, uint64_t *))(v11 + 32);
          v31 = *(_QWORD *)(*(_QWORD *)(v11 + 8) + 8 * v15);
          v32 = v30;
          v17 = v16(&v32, &v31);
          if (v17 >= 1)
          {
            v14 = v15 + 1;
          }
          else if (v17 < 0)
          {
            v12 = v14 + ((v12 - v14 - 1) >> 1);
          }
          else
          {
            if (v12 - v14 == 1)
              goto LABEL_45;
            v12 = v15 + 1;
          }
          if (v14 >= v12)
            return 0;
        }
      }
      return 0;
    }
    v15 = 0;
    while (1)
    {
      v22 = *(unsigned int (**)(_QWORD **, uint64_t *))(v11 + 32);
      v31 = *(_QWORD *)(*(_QWORD *)(v11 + 8) + 8 * v15);
      v32 = v30;
      if (!v22(&v32, &v31))
        break;
      if (++v15 >= *(_QWORD *)v11)
        return 0;
    }
  }
  else
  {
    v18 = *(_QWORD *)v11;
    if (!*(_QWORD *)v11)
      return 0;
    v19 = *(_QWORD ***)(v11 + 8);
    if (*v19 != v30)
    {
      v15 = 0;
      v20 = v19 + 1;
      while (v18 - 1 != v15)
      {
        v21 = v20[v15++];
        if (v21 == v30)
        {
          if (v15 < v18)
            goto LABEL_45;
          return 0;
        }
      }
      return 0;
    }
    v15 = 0;
  }
LABEL_45:
  v23 = *(unint64_t **)(*(_QWORD *)a1 + 40);
  if (a4)
  {
    if (v23)
    {
      while (v15 < *v23)
      {
        v24 = *(ASN1_STRING ***)(v23[1] + 8 * v15);
        v25 = (*v24)->type & 0x100;
        if (v25 != (a3->type & 0x100))
          break;
        v26 = ASN1_STRING_cmp(*v24, a3);
        if (v25)
        {
          if (v26 < 0)
            return 0;
          if (v26)
            v26 = -1;
          else
            v26 = 0;
        }
        if (v26)
          break;
        if (!X509_NAME_cmp(a4, *(const X509_NAME **)(*(_QWORD *)a1 + 16)))
          goto LABEL_68;
        result = 0;
        ++v15;
        v23 = *(unint64_t **)(*(_QWORD *)a1 + 40);
        if (!v23)
          return result;
      }
    }
    return 0;
  }
  if (!v23)
    return 0;
  if (v15 >= *v23)
    return 0;
  v24 = *(ASN1_STRING ***)(v23[1] + 8 * v15);
  v28 = (*v24)->type & 0x100;
  if (v28 != (a3->type & 0x100))
    return 0;
  v29 = ASN1_STRING_cmp(*v24, a3);
  if (!v28)
    goto LABEL_66;
  if (v29 < 0)
    return 0;
  if (v29)
    v29 = -1;
  else
    v29 = 0;
LABEL_66:
  if (v29)
    return 0;
LABEL_68:
  if (a2)
    *a2 = v24;
  return 1;
}

uint64_t crl_inf_cb(int a1, uint64_t a2)
{
  uint64_t v2;

  if (*(_QWORD *)a2)
  {
    if (a1 == 5)
    {
      v2 = *(_QWORD *)(*(_QWORD *)a2 + 40);
      if (v2)
      {
        if (*(uint64_t (**)(ASN1_STRING ***, ASN1_STRING ***))(v2 + 32) != X509_REVOKED_cmp)
          *(_DWORD *)(v2 + 16) = 0;
        *(_QWORD *)(v2 + 32) = X509_REVOKED_cmp;
      }
    }
  }
  return 1;
}

uint64_t crl_cb(uint64_t result, const void *****a2)
{
  const void ****v2;
  const void ***v3;
  const void **v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  char *v10;
  void *d2i;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  const void ***v17;
  const void **v18;
  const void *v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  const void **v23;
  unint64_t v24;
  uint64_t v25;
  const void **v26;
  const void **v28;
  int v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  size_t v33;
  const void **v34;
  uint64_t v35;
  size_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int crit;
  ASN1_VALUE *pval;

  v2 = *a2;
  if ((_DWORD)result == 5)
  {
    v3 = *v2;
    v4 = **v2;
    if (!v4)
      goto LABEL_10;
    pval = 0;
    if (asn1_string_get_int64((int64_t *)&pval, v4, 2))
    {
      if ((unint64_t)pval < 2)
      {
        if (pval)
          goto LABEL_14;
        v3 = *v2;
LABEL_10:
        if (v3[6])
        {
          v5 = 139;
          v6 = 183;
LABEL_26:
          ERR_put_error(11, 0, v5, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x_crl.c", v6);
          return 0;
        }
LABEL_14:
        if (pthread_once(&EVP_sha256_once, (void (*)(void))EVP_sha256_init))
          abort();
        pval = 0;
        v7 = ASN1_item_i2d((ASN1_VALUE *)v2, (unsigned __int8 **)&pval, (const ASN1_ITEM *)&X509_CRL_INFO_it.sname);
        result = (uint64_t)pval;
        if (!pval)
          return result;
        v8 = EVP_Digest(pval, v7, (unsigned __int8 *)v2 + 52, 0, (const EVP_MD *)&EVP_sha256_storage, 0);
        if (pval)
        {
          v10 = (char *)pval - 8;
          v9 = *((_QWORD *)pval - 1);
          if (v9 != -8)
            bzero(v10, v9 + 8);
          free(v10);
        }
        if (v8)
        {
          v40 = 0;
          d2i = X509V3_get_d2i((STACK *)(*v2)[6], 770, &v40, 0);
          v2[5] = (const void ***)d2i;
          if (d2i)
          {
            v12 = *((_DWORD *)v2 + 12);
            v13 = v12 | 1;
            *((_DWORD *)v2 + 12) = v12 | 1;
            if (*((int *)d2i + 2) < 1)
            {
              v14 = 0;
            }
            else
            {
              v13 = v12 | 5;
              *((_DWORD *)v2 + 12) = v12 | 5;
              v14 = 1;
            }
            if (*((int *)d2i + 3) >= 1)
            {
              ++v14;
              v13 |= 8u;
              *((_DWORD *)v2 + 12) = v13;
            }
            v15 = *((_DWORD *)d2i + 7);
            if (v15 > 0)
            {
              v13 |= 0x10u;
              ++v14;
            }
            if (v14 > 1)
              v13 |= 2u;
            if (v15 > 0 || v14 >= 2)
              *((_DWORD *)v2 + 12) = v13;
            if (*((int *)d2i + 6) >= 1)
            {
              v13 |= 0x20u;
              *((_DWORD *)v2 + 12) = v13;
            }
            if (*((_QWORD *)d2i + 2))
              *((_DWORD *)v2 + 12) = v13 | 0x40;
            result = DIST_POINT_set_dpname(*(_QWORD *)d2i, (*v2)[2]);
            if (!(_DWORD)result)
              return result;
          }
          else if (v40 != -1)
          {
            return 0;
          }
          v17 = (const void ***)X509V3_get_d2i((STACK *)(*v2)[6], 90, &v40, 0);
          v2[4] = v17;
          if (v17 || v40 == -1)
          {
            v18 = (*v2)[6];
            if (!v18)
              goto LABEL_62;
            v19 = *v18;
            if (!*v18)
              goto LABEL_62;
            v20 = 0;
            while (1)
            {
              if ((unint64_t)v19 > v20 && (v21 = *((_QWORD *)v18[1] + v20)) != 0)
              {
                v22 = OBJ_obj2nid(*(const ASN1_OBJECT **)v21);
                if (*(int *)(v21 + 8) >= 1 && v22 != 90 && v22 != 770)
                {
                  *((_DWORD *)v2 + 7) |= 0x200u;
LABEL_62:
                  v23 = (*v2)[5];
                  if (v23 && *v23)
                  {
                    v24 = 0;
                    while (1)
                    {
                      v25 = *((_QWORD *)v23[1] + v24);
                      crit = 0;
                      v26 = (const void **)X509V3_get_d2i(*(STACK **)(v25 + 16), 141, &crit, 0);
                      if (!v26 && crit != -1)
                        break;
                      v28 = v26;
                      if (v26)
                      {
                        pval = 0;
                        if (asn1_string_get_int64((int64_t *)&pval, v26, 10))
                        {
                          v29 = (int)pval;
                        }
                        else
                        {
                          ERR_clear_error();
                          v29 = -1;
                        }
                        *(_DWORD *)(v25 + 24) = v29;
                        v30 = v28[1];
                        if (v30)
                        {
                          v32 = *(v30 - 1);
                          v31 = (char *)(v30 - 1);
                          v33 = v32 + 8;
                          if (v32 != -8)
                            bzero(v31, v33);
                          free(v31);
                        }
                        v35 = (uint64_t)*(v28 - 1);
                        v34 = v28 - 1;
                        v36 = v35 + 8;
                        if (v35 != -8)
                          bzero(v34, v36);
                        free(v34);
                      }
                      else
                      {
                        *(_DWORD *)(v25 + 24) = -1;
                      }
                      v37 = *(_QWORD **)(v25 + 16);
                      if (v37)
                      {
                        v38 = 0;
                        while (*v37 != v38)
                        {
                          v39 = *(_QWORD *)(v37[1] + 8 * v38);
                          if (v39)
                            LODWORD(v39) = *(_DWORD *)(v39 + 8) > 0;
                          ++v38;
                          if ((_DWORD)v39)
                          {
                            *((_DWORD *)v2 + 7) |= 0x200u;
                            break;
                          }
                        }
                      }
                      ++v24;
                      result = 1;
                      if (v24 >= (unint64_t)*v23)
                        return result;
                    }
                    *((_DWORD *)v2 + 7) |= 0x80u;
                  }
                  return 1;
                }
              }
              else
              {
                OBJ_obj2nid(0);
              }
              ++v20;
              v19 = *v18;
              if (v20 >= (unint64_t)*v18)
                goto LABEL_62;
            }
          }
        }
        return 0;
      }
    }
    else
    {
      ERR_clear_error();
    }
    v5 = 140;
    v6 = 176;
    goto LABEL_26;
  }
  if ((_DWORD)result == 3)
  {
    pval = (ASN1_VALUE *)v2[4];
    ASN1_item_ex_free(&pval, &AUTHORITY_KEYID_it);
    pval = (ASN1_VALUE *)v2[5];
    ASN1_item_ex_free(&pval, (const ASN1_ITEM *)&ISSUING_DIST_POINT_it);
    return 1;
  }
  if ((_DWORD)result != 1)
    return 1;
  *(const void ****)((char *)v2 + 36) = 0;
  *(const void ****)((char *)v2 + 28) = 0;
  *(const void ****)((char *)v2 + 44) = 0;
  return result;
}

uint64_t sk_X509_REVOKED_call_cmp_func(uint64_t (*a1)(uint64_t *, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a3;
  v5 = a2;
  return a1(&v5, &v4);
}

uint64_t x509_name_ex_new(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  char *v4;
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  size_t v11;
  void *v12;
  uint64_t v13;
  size_t v14;

  v2 = malloc_type_malloc(0x30uLL, 0x30772F57uLL);
  if (v2)
  {
    v3 = v2;
    *v2 = 40;
    v4 = OPENSSL_sk_new_null();
    v3[1] = v4;
    if (v4)
    {
      v5 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
      if (v5)
      {
        *v5 = 24;
        v5[2] = 0;
        v5[3] = 0;
        v5[1] = 0;
        v3[3] = v5 + 1;
        v3[4] = 0;
        *((_DWORD *)v3 + 10) = 0;
        result = 1;
        *((_DWORD *)v3 + 4) = 1;
        *a1 = v3 + 1;
        return result;
      }
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
      v3[3] = 0;
      v7 = v3[1];
      if (v7)
      {
        v8 = *(_QWORD *)(v7 + 8);
        if (v8)
        {
          v10 = *(_QWORD *)(v8 - 8);
          v9 = (void *)(v8 - 8);
          v11 = v10 + 8;
          if (v10 != -8)
            bzero(v9, v11);
          free(v9);
        }
        v13 = *(_QWORD *)(v7 - 8);
        v12 = (void *)(v7 - 8);
        v14 = v13 + 8;
        if (v13 != -8)
          bzero(v12, v14);
        free(v12);
      }
    }
    if (*v3 != -8)
      __memset_chk();
    free(v3);
    return 0;
  }
  else
  {
    ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    return 0;
  }
}

void x509_name_ex_free(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  size_t v7;
  void *v8;
  uint64_t v9;
  size_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  void *v15;
  uint64_t v16;
  size_t v17;
  unint64_t *v18;
  uint64_t v19;
  size_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  size_t v24;
  void *v25;
  uint64_t v26;
  size_t v27;
  ASN1_VALUE *pval;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = *(_QWORD *)(v2 + 16);
      if (v3)
      {
        v4 = *(_QWORD *)(v3 + 8);
        if (v4)
        {
          v6 = *(_QWORD *)(v4 - 8);
          v5 = (void *)(v4 - 8);
          v7 = v6 + 8;
          if (v6 != -8)
            bzero(v5, v7);
          free(v5);
        }
        v9 = *(_QWORD *)(v3 - 8);
        v8 = (void *)(v3 - 8);
        v10 = v9 + 8;
        if (v9 != -8)
          bzero(v8, v10);
        free(v8);
      }
      v11 = *(unint64_t **)v2;
      if (*(_QWORD *)v2)
      {
        v12 = *v11;
        if (*v11)
        {
          v13 = 0;
          do
          {
            if (*(_QWORD *)(v11[1] + 8 * v13))
            {
              pval = *(ASN1_VALUE **)(v11[1] + 8 * v13);
              ASN1_item_ex_free(&pval, &X509_NAME_ENTRY_it);
              v12 = *v11;
            }
            ++v13;
          }
          while (v13 < v12);
        }
        v14 = v11[1];
        if (v14)
        {
          v16 = *(_QWORD *)(v14 - 8);
          v15 = (void *)(v14 - 8);
          v17 = v16 + 8;
          if (v16 != -8)
            bzero(v15, v17);
          free(v15);
        }
        v19 = *(v11 - 1);
        v18 = v11 - 1;
        v20 = v19 + 8;
        if (v19 != -8)
          bzero(v18, v20);
        free(v18);
      }
      v21 = *(_QWORD *)(v2 + 24);
      if (v21)
      {
        v23 = *(_QWORD *)(v21 - 8);
        v22 = (void *)(v21 - 8);
        v24 = v23 + 8;
        if (v23 != -8)
          bzero(v22, v24);
        free(v22);
      }
      v26 = *(_QWORD *)(v2 - 8);
      v25 = (void *)(v2 - 8);
      v27 = v26 + 8;
      if (v26 != -8)
        bzero(v25, v27);
      free(v25);
      *a1 = 0;
    }
  }
}

uint64_t x509_name_ex_d2i(unint64_t ***a1, unsigned __int8 **a2, uint64_t a3, uint64_t a4, char a5)
{
  unsigned __int8 *v7;
  uint64_t result;
  unint64_t *v9;
  unint64_t **v10;
  unint64_t *v11;
  unint64_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;
  unint64_t *v16;
  uint64_t v17;
  size_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  void *v23;
  uint64_t v24;
  size_t v25;
  unint64_t *v26;
  uint64_t v27;
  size_t v28;
  unint64_t *v29;
  unint64_t *v30;
  uint64_t v31;
  size_t v32;
  unint64_t **v33;
  uint64_t v34;
  size_t v35;
  char *v36;
  char *v37;
  char *v38;
  unint64_t **v39;
  _QWORD *v40;
  BUF_MEM *v41;
  uint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  size_t v51;
  void *v52;
  uint64_t v53;
  size_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  void *v59;
  uint64_t v60;
  size_t v61;
  unint64_t *v62;
  uint64_t v63;
  size_t v64;
  unint64_t *v65;
  unsigned __int8 *v66;
  ASN1_VALUE *pval;

  v7 = *a2;
  v65 = 0;
  v66 = v7;
  if (a3 >= 0x100000)
    a3 = 0x100000;
  result = asn1_item_ex_d2i((uint64_t)&v65, &v66, a3, (uint64_t)&X509_NAME_INTERNAL_it, -1, 0, a5, 0, 0);
  if ((int)result >= 1)
  {
    v9 = v65;
    v10 = *a1;
    if (*a1)
    {
      v11 = v10[2];
      if (v11)
      {
        v12 = v11[1];
        if (v12)
        {
          v14 = *(_QWORD *)(v12 - 8);
          v13 = (void *)(v12 - 8);
          v15 = v14 + 8;
          if (v14 != -8)
            bzero(v13, v15);
          free(v13);
        }
        v17 = *(v11 - 1);
        v16 = v11 - 1;
        v18 = v17 + 8;
        if (v17 != -8)
          bzero(v16, v18);
        free(v16);
      }
      v19 = *v10;
      if (*v10)
      {
        v20 = *v19;
        if (*v19)
        {
          v21 = 0;
          do
          {
            if (*(_QWORD *)(v19[1] + 8 * v21))
            {
              pval = *(ASN1_VALUE **)(v19[1] + 8 * v21);
              ASN1_item_ex_free(&pval, &X509_NAME_ENTRY_it);
              v20 = *v19;
            }
            ++v21;
          }
          while (v21 < v20);
        }
        v22 = v19[1];
        if (v22)
        {
          v24 = *(_QWORD *)(v22 - 8);
          v23 = (void *)(v22 - 8);
          v25 = v24 + 8;
          if (v24 != -8)
            bzero(v23, v25);
          free(v23);
        }
        v27 = *(v19 - 1);
        v26 = v19 - 1;
        v28 = v27 + 8;
        if (v27 != -8)
          bzero(v26, v28);
        free(v26);
      }
      v29 = v10[3];
      if (v29)
      {
        v31 = *(v29 - 1);
        v30 = v29 - 1;
        v32 = v31 + 8;
        if (v31 != -8)
          bzero(v30, v32);
        free(v30);
      }
      v34 = (uint64_t)*(v10 - 1);
      v33 = v10 - 1;
      v35 = v34 + 8;
      if (v34 != -8)
        bzero(v33, v35);
      free(v33);
      *a1 = 0;
    }
    v36 = (char *)malloc_type_malloc(0x30uLL, 0x30772F57uLL);
    if (v36)
    {
      v37 = v36;
      *(_QWORD *)v36 = 40;
      v38 = OPENSSL_sk_new_null();
      *((_QWORD *)v37 + 1) = v38;
      v39 = (unint64_t **)(v37 + 8);
      if (v38)
      {
        v40 = malloc_type_malloc(0x20uLL, 0x30772F57uLL);
        if (v40)
        {
          *v40 = 24;
          v40[2] = 0;
          v40[3] = 0;
          v40[1] = 0;
          v41 = (BUF_MEM *)(v40 + 1);
          *((_QWORD *)v37 + 3) = v41;
          *((_QWORD *)v37 + 4) = 0;
          *((_DWORD *)v37 + 10) = 0;
          *((_DWORD *)v37 + 4) = 1;
          if (BUF_MEM_grow(v41, (_DWORD)v66 - (_DWORD)v7))
          {
            if (v66 != v7)
              memcpy(*(void **)(*((_QWORD *)v37 + 3) + 8), v7, v66 - v7);
            if (v9 && *v9)
            {
              v42 = 0;
              while (1)
              {
                v43 = *(unint64_t **)(v9[1] + 8 * v42);
                if (v43)
                {
                  v44 = *v43;
                  if (*v43)
                    break;
                }
LABEL_43:
                if (++v42 >= *v9)
                  goto LABEL_81;
              }
              v45 = 0;
              while (1)
              {
                v46 = v44 <= v45 ? 0 : *(_QWORD *)(v43[1] + 8 * v45);
                *(_DWORD *)(v46 + 16) = v42;
                if (!OPENSSL_sk_insert(*v39, v46, **v39))
                  break;
                v44 = *v43;
                if (*v43 > v45)
                  *(_QWORD *)(v43[1] + 8 * v45) = 0;
                if (++v45 >= v44)
                  goto LABEL_43;
              }
            }
            else
            {
LABEL_81:
              if (x509_name_canon((uint64_t)(v37 + 8)))
              {
                OPENSSL_sk_pop_free_ex(v9, (void (*)(uint64_t))sk_STACK_OF_X509_NAME_ENTRY_call_free_func, (uint64_t)local_sk_X509_NAME_ENTRY_free);
                *((_DWORD *)v37 + 4) = 0;
                *a1 = v39;
                *a2 = v66;
                return 1;
              }
            }
          }
          goto LABEL_66;
        }
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        *((_QWORD *)v37 + 3) = 0;
        v47 = *((_QWORD *)v37 + 1);
        if (v47)
        {
          v48 = *(_QWORD *)(v47 + 8);
          if (v48)
          {
            v50 = *(_QWORD *)(v48 - 8);
            v49 = (void *)(v48 - 8);
            v51 = v50 + 8;
            if (v50 != -8)
              bzero(v49, v51);
            free(v49);
          }
          v53 = *(_QWORD *)(v47 - 8);
          v52 = (void *)(v47 - 8);
          v54 = v53 + 8;
          if (v53 != -8)
            bzero(v52, v54);
          free(v52);
        }
      }
      if (*(_QWORD *)v37 != -8)
        __memset_chk();
      free(v37);
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    }
    v39 = 0;
LABEL_66:
    pval = (ASN1_VALUE *)v39;
    ASN1_item_ex_free(&pval, &X509_NAME_it);
    if (v9)
    {
      v55 = *v9;
      if (*v9)
      {
        v56 = 0;
        do
        {
          v57 = *(unint64_t **)(v9[1] + 8 * v56);
          if (v57)
          {
            local_sk_X509_NAME_ENTRY_pop_free(v57);
            v55 = *v9;
          }
          ++v56;
        }
        while (v56 < v55);
      }
      v58 = v9[1];
      if (v58)
      {
        v60 = *(_QWORD *)(v58 - 8);
        v59 = (void *)(v58 - 8);
        v61 = v60 + 8;
        if (v60 != -8)
          bzero(v59, v61);
        free(v59);
      }
      v63 = *(v9 - 1);
      v62 = v9 - 1;
      v64 = v63 + 8;
      if (v63 != -8)
        bzero(v62, v64);
      free(v62);
    }
    ERR_put_error(11, 0, 12, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x_name.c", 252);
    return 0;
  }
  return result;
}

uint64_t x509_name_ex_i2d(uint64_t *a1, void **a2)
{
  uint64_t v3;
  char *v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  int v8;
  unint64_t *v9;
  uint64_t v10;
  char *v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  size_t v19;
  void *v20;
  uint64_t v21;
  size_t v22;
  unint64_t v23;
  void *v24;
  uint64_t v25;
  size_t v26;
  unint64_t *v27;
  uint64_t v28;
  size_t v29;
  uint64_t *v30;
  uint64_t v31;
  unint64_t v32;
  void *v33;
  uint64_t v34;
  size_t v35;
  unint64_t *v36;
  uint64_t v37;
  size_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  size_t v45;
  void *v46;
  uint64_t v47;
  size_t v48;
  unint64_t v49;
  void *v50;
  uint64_t v51;
  size_t v52;
  unint64_t *v53;
  uint64_t v54;
  size_t v55;
  unint64_t *v57;
  void *v58;

  v3 = *a1;
  if (!*(_DWORD *)(*a1 + 8))
    goto LABEL_32;
  v58 = 0;
  v4 = OPENSSL_sk_new_null();
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = (unint64_t *)v4;
  v6 = 0;
  v7 = 0;
  v8 = -1;
  while (1)
  {
    v9 = *(unint64_t **)v3;
    if (!*(_QWORD *)v3 || v7 >= *v9)
      break;
    v10 = *(_QWORD *)(v9[1] + 8 * v7);
    if (*(_DWORD *)(v10 + 16) != v8)
    {
      v11 = OPENSSL_sk_new_null();
      if (!v11)
        goto LABEL_43;
      v6 = (unint64_t *)v11;
      if (!OPENSSL_sk_insert(v5, (uint64_t)v11, *v5))
      {
        v32 = v6[1];
        if (v32)
        {
          v34 = *(_QWORD *)(v32 - 8);
          v33 = (void *)(v32 - 8);
          v35 = v34 + 8;
          if (v34 != -8)
            bzero(v33, v35);
          free(v33);
        }
        v37 = *(v6 - 1);
        v36 = v6 - 1;
        v38 = v37 + 8;
        if (v37 != -8)
          bzero(v36, v38);
        free(v36);
        goto LABEL_43;
      }
      v8 = *(_DWORD *)(v10 + 16);
    }
    ++v7;
    if (!OPENSSL_sk_insert(v6, v10, *v6))
      goto LABEL_43;
  }
  v57 = v5;
  v12 = asn1_item_ex_i2d_opt(&v57, 0, (uint64_t)&X509_NAME_INTERNAL_it, 0xFFFFFFFFLL, 0, 0);
  if (v12 < 1
    || !BUF_MEM_grow(*(BUF_MEM **)(v3 + 16), v12)
    || (v58 = *(void **)(*(_QWORD *)(v3 + 16) + 8),
        (int)asn1_item_ex_i2d_opt(&v57, &v58, (uint64_t)&X509_NAME_INTERNAL_it, 0xFFFFFFFFLL, 0, 0) <= 0))
  {
LABEL_43:
    v39 = *v5;
    if (*v5)
    {
      v40 = 0;
      do
      {
        v41 = *(_QWORD *)(v5[1] + 8 * v40);
        if (v41)
        {
          v42 = *(_QWORD *)(v41 + 8);
          if (v42)
          {
            v44 = *(_QWORD *)(v42 - 8);
            v43 = (void *)(v42 - 8);
            v45 = v44 + 8;
            if (v44 != -8)
              bzero(v43, v45);
            free(v43);
          }
          v47 = *(_QWORD *)(v41 - 8);
          v46 = (void *)(v41 - 8);
          v48 = v47 + 8;
          if (v47 != -8)
            bzero(v46, v48);
          free(v46);
          v39 = *v5;
        }
        ++v40;
      }
      while (v40 < v39);
    }
    v49 = v5[1];
    if (v49)
    {
      v51 = *(_QWORD *)(v49 - 8);
      v50 = (void *)(v49 - 8);
      v52 = v51 + 8;
      if (v51 != -8)
        bzero(v50, v52);
      free(v50);
    }
    v54 = *(v5 - 1);
    v53 = v5 - 1;
    v55 = v54 + 8;
    if (v54 != -8)
      bzero(v53, v55);
    free(v53);
    return 0xFFFFFFFFLL;
  }
  v13 = *v5;
  if (*v5)
  {
    v14 = 0;
    do
    {
      v15 = *(_QWORD *)(v5[1] + 8 * v14);
      if (v15)
      {
        v16 = *(_QWORD *)(v15 + 8);
        if (v16)
        {
          v18 = *(_QWORD *)(v16 - 8);
          v17 = (void *)(v16 - 8);
          v19 = v18 + 8;
          if (v18 != -8)
            bzero(v17, v19);
          free(v17);
        }
        v21 = *(_QWORD *)(v15 - 8);
        v20 = (void *)(v15 - 8);
        v22 = v21 + 8;
        if (v21 != -8)
          bzero(v20, v22);
        free(v20);
        v13 = *v5;
      }
      ++v14;
    }
    while (v14 < v13);
  }
  v23 = v5[1];
  if (v23)
  {
    v25 = *(_QWORD *)(v23 - 8);
    v24 = (void *)(v23 - 8);
    v26 = v25 + 8;
    if (v25 != -8)
      bzero(v24, v26);
    free(v24);
  }
  v28 = *(v5 - 1);
  v27 = v5 - 1;
  v29 = v28 + 8;
  if (v28 != -8)
    bzero(v27, v29);
  free(v27);
  *(_DWORD *)(v3 + 8) = 0;
  if (!x509_name_canon(v3))
    return 0xFFFFFFFFLL;
LABEL_32:
  v30 = *(uint64_t **)(v3 + 16);
  v31 = *v30;
  if (a2)
  {
    if (v31 << 32)
      memcpy(*a2, (const void *)v30[1], (int)v31);
    *a2 = (char *)*a2 + (int)v31;
  }
  return v31;
}

uint64_t x509_name_canon(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  size_t v5;
  char *v6;
  unint64_t *v7;
  unint64_t *v8;
  unint64_t v9;
  int v10;
  unint64_t *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  ASN1_VALUE *v15;
  uint64_t v16;
  ASN1_STRING *v17;
  unsigned int type;
  _BYTE **v19;
  int v20;
  _BYTE *v21;
  uint64_t v22;
  int v23;
  int v24;
  BOOL v26;
  unsigned __int8 *v27;
  uint64_t v28;
  int v29;
  _BYTE *v31;
  int v32;
  int v33;
  int v35;
  unsigned int v36;
  unint64_t v38;
  unint64_t v39;
  unsigned int v40;
  ASN1_VALUE *v41;
  int v42;
  _QWORD *v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  void *v47;
  uint64_t v48;
  size_t v49;
  unint64_t *v50;
  uint64_t v51;
  size_t v52;
  unint64_t v53;
  unint64_t *v54;
  unint64_t v55;
  void *v56;
  uint64_t v57;
  size_t v58;
  unint64_t *v59;
  uint64_t v60;
  size_t v61;
  void *v63;
  ASN1_VALUE *pval;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    v4 = *(_QWORD *)(v2 - 8);
    v3 = (void *)(v2 - 8);
    v5 = v4 + 8;
    if (v4 != -8)
      bzero(v3, v5);
    free(v3);
    *(_QWORD *)(a1 + 24) = 0;
  }
  if (*(_QWORD *)a1 && **(_QWORD **)a1)
  {
    v6 = OPENSSL_sk_new_null();
    if (v6)
    {
      v7 = (unint64_t *)v6;
      v8 = 0;
      v9 = 0;
      v63 = 0;
      v10 = -1;
      while (1)
      {
        v11 = *(unint64_t **)a1;
        if (!*(_QWORD *)a1 || v9 >= *v11)
          break;
        v12 = *(_QWORD *)(v11[1] + 8 * v9);
        if (*(_DWORD *)(v12 + 16) != v10)
        {
          v13 = OPENSSL_sk_new_null();
          if (!v13)
            goto LABEL_85;
          v8 = (unint64_t *)v13;
          if (!OPENSSL_sk_insert(v7, (uint64_t)v13, *v7))
          {
            v46 = v8[1];
            if (v46)
            {
              v48 = *(_QWORD *)(v46 - 8);
              v47 = (void *)(v46 - 8);
              v49 = v48 + 8;
              if (v48 != -8)
                bzero(v47, v49);
              free(v47);
            }
            v51 = *(v8 - 1);
            v50 = v8 - 1;
            v52 = v51 + 8;
            if (v51 != -8)
              bzero(v50, v52);
            free(v50);
            goto LABEL_85;
          }
          v10 = *(_DWORD *)(v12 + 16);
        }
        pval = 0;
        v14 = 0;
        if (!ASN1_item_ex_new(&pval, &X509_NAME_ENTRY_it))
          goto LABEL_86;
        v15 = pval;
        if (!pval)
          goto LABEL_86;
        *(_QWORD *)v15 = OBJ_dup(*(const ASN1_OBJECT **)v12);
        v16 = *((_QWORD *)v15 + 1);
        v17 = *(ASN1_STRING **)(v12 + 8);
        type = v17->type;
        if (type > 0x1E || ((0x2BA7EFFFuLL >> type) & 1) != 0)
        {
          if (!ASN1_STRING_set(*((ASN1_STRING **)v15 + 1), v17->data, v17->length))
            goto LABEL_70;
          *(_DWORD *)(v16 + 4) = v17->type;
          *(_QWORD *)(v16 + 16) = v17->flags;
          ++v9;
          if (!OPENSSL_sk_insert(v8, (uint64_t)v15, *v8))
            goto LABEL_70;
        }
        else
        {
          *(_DWORD *)(v16 + 4) = 12;
          v19 = (_BYTE **)(v16 + 8);
          v20 = ASN1_STRING_to_UTF8((unsigned __int8 **)(v16 + 8), v17);
          *(_DWORD *)v16 = v20;
          if (v20 == -1)
            goto LABEL_70;
          v21 = *v19;
          if (v20 < 1)
          {
LABEL_40:
            v31 = *v19;
          }
          else
          {
            v22 = 0;
            v23 = v20;
            while (1)
            {
              v24 = v21[v22];
              if (v24 != 32 && (v24 - 14) < 0xFFFFFFFB)
                break;
              ++v22;
              v26 = __OFSUB__(v23--, 1);
              if ((v23 < 0) ^ v26 | (v23 == 0))
                goto LABEL_40;
            }
            v27 = &v21[v22];
            v28 = v20 - 1;
            while (1)
            {
              v29 = v21[v28];
              if (v29 != 32 && (v29 - 14) <= 0xFFFFFFFA)
                break;
              --v28;
              v26 = __OFSUB__(v23--, 1);
              if ((v23 < 0) ^ v26 | (v23 == 0))
                goto LABEL_40;
            }
            v32 = 0;
            do
            {
              v33 = *v27;
              if (v33 == 32 || (v33 - 14) >= 0xFFFFFFFB)
              {
                *v21 = 32;
                do
                {
                  v35 = *++v27;
                  ++v32;
                  v36 = v35 - 14;
                }
                while (v35 == 32 || v36 >= 0xFFFFFFFB);
              }
              else
              {
                if ((v33 - 65) < 0x1A)
                  LOBYTE(v33) = v33 + 32;
                *v21 = v33;
                ++v27;
                ++v32;
              }
              ++v21;
            }
            while (v32 < v23);
            v31 = *v19;
          }
          *(_DWORD *)v16 = (_DWORD)v21 - (_DWORD)v31;
          ++v9;
          if (!OPENSSL_sk_insert(v8, (uint64_t)v15, *v8))
          {
LABEL_70:
            pval = v15;
            ASN1_item_ex_free(&pval, &X509_NAME_ENTRY_it);
LABEL_85:
            v14 = 0;
LABEL_86:
            v45 = *v7;
            if (!*v7)
              goto LABEL_92;
            goto LABEL_87;
          }
        }
      }
      pval = 0;
      v38 = *v7;
      if (*v7)
      {
        v39 = 0;
        v40 = 0;
        while (1)
        {
          v41 = v38 <= v39 ? 0 : *(ASN1_VALUE **)(v7[1] + 8 * v39);
          pval = v41;
          v42 = asn1_item_ex_i2d_opt((unint64_t **)&pval, 0, (uint64_t)&X509_NAME_ENTRIES_it, 0xFFFFFFFFLL, 0, 0);
          if (v42 < 0)
            goto LABEL_85;
          v40 += v42;
          ++v39;
          v38 = *v7;
          if (v39 >= *v7)
          {
            if ((v40 & 0x80000000) == 0)
              goto LABEL_72;
            goto LABEL_85;
          }
        }
      }
      v40 = 0;
LABEL_72:
      *(_DWORD *)(a1 + 32) = v40;
      v43 = malloc_type_malloc(v40 + 8, 0x30772F57uLL);
      if (v43)
      {
        v44 = 0;
        *v43 = v40;
        v63 = v43 + 1;
        pval = 0;
        *(_QWORD *)(a1 + 24) = v43 + 1;
        do
        {
          if (v44 >= *v7)
            break;
          pval = *(ASN1_VALUE **)(v7[1] + 8 * v44++);
        }
        while ((asn1_item_ex_i2d_opt((unint64_t **)&pval, &v63, (uint64_t)&X509_NAME_ENTRIES_it, 0xFFFFFFFFLL, 0, 0) & 0x80000000) == 0);
        v14 = 1;
        v45 = *v7;
        if (!*v7)
          goto LABEL_92;
      }
      else
      {
        ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
        v14 = 0;
        v63 = 0;
        v45 = *v7;
        if (!*v7)
          goto LABEL_92;
      }
LABEL_87:
      v53 = 0;
      do
      {
        v54 = *(unint64_t **)(v7[1] + 8 * v53);
        if (v54)
        {
          local_sk_X509_NAME_ENTRY_pop_free(v54);
          v45 = *v7;
        }
        ++v53;
      }
      while (v53 < v45);
LABEL_92:
      v55 = v7[1];
      if (v55)
      {
        v57 = *(_QWORD *)(v55 - 8);
        v56 = (void *)(v55 - 8);
        v58 = v57 + 8;
        if (v57 != -8)
          bzero(v56, v58);
        free(v56);
      }
      v60 = *(v7 - 1);
      v59 = v7 - 1;
      v61 = v60 + 8;
      if (v60 != -8)
        bzero(v59, v61);
      free(v59);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 32) = 0;
    return 1;
  }
  return v14;
}

void local_sk_X509_NAME_ENTRY_free(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  size_t v5;
  char *v6;
  uint64_t v7;
  size_t v8;

  if (a1)
  {
    v2 = a1[1];
    if (v2)
    {
      v4 = *(_QWORD *)(v2 - 8);
      v3 = (void *)(v2 - 8);
      v5 = v4 + 8;
      if (v4 != -8)
        bzero(v3, v5);
      free(v3);
    }
    v7 = *(a1 - 1);
    v6 = (char *)(a1 - 1);
    v8 = v7 + 8;
    if (v7 != -8)
      bzero(v6, v8);
    free(v6);
  }
}

void local_sk_X509_NAME_ENTRY_pop_free(unint64_t *a1)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  void *v5;
  uint64_t v6;
  size_t v7;
  char *v8;
  uint64_t v9;
  size_t v10;
  ASN1_VALUE *pval;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = 0;
      do
      {
        if (*(_QWORD *)(a1[1] + 8 * v3))
        {
          pval = *(ASN1_VALUE **)(a1[1] + 8 * v3);
          ASN1_item_ex_free(&pval, &X509_NAME_ENTRY_it);
          v2 = *a1;
        }
        ++v3;
      }
      while (v3 < v2);
    }
    v4 = a1[1];
    if (v4)
    {
      v6 = *(_QWORD *)(v4 - 8);
      v5 = (void *)(v4 - 8);
      v7 = v6 + 8;
      if (v6 != -8)
        bzero(v5, v7);
      free(v5);
    }
    v9 = *(a1 - 1);
    v8 = (char *)(a1 - 1);
    v10 = v9 + 8;
    if (v9 != -8)
      bzero(v8, v10);
    free(v8);
  }
}

uint64_t sk_STACK_OF_X509_NAME_ENTRY_call_free_func(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

uint64_t pubkey_cb(int a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int k;
  unsigned int v5;
  uint64_t v7;
  unsigned int i;
  unsigned int v9;
  uint64_t v10;
  void (*v11)(uint64_t);
  void *v12;
  uint64_t v13;
  size_t v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int j;
  unsigned int v19;
  uint64_t v20;
  void (*v21)(unsigned int *);
  unsigned int *v22;
  uint64_t v23;
  size_t v24;
  uint64_t v25;
  unsigned __int8 *v26;
  uint64_t v27;
  void (*v28)(uint64_t);
  void *v29;
  uint64_t v30;
  size_t v31;
  unsigned __int8 *v32;
  uint64_t v33;
  unsigned __int8 *out;

  v2 = *a2;
  if (a1 == 5)
  {
    v7 = *(_QWORD *)(v2 + 16);
    if (v7)
    {
      for (i = atomic_load((unsigned int *)v7); i != -1; i = v9)
      {
        if (!i)
LABEL_58:
          abort();
        v9 = __ldaxr((unsigned int *)v7);
        if (v9 == i)
        {
          if (!__stlxr(i - 1, (unsigned int *)v7))
          {
            if (i == 1)
            {
              v10 = *(_QWORD *)(v7 + 16);
              if (v10)
              {
                v11 = *(void (**)(uint64_t))(v10 + 160);
                if (v11)
                {
                  v11(v7);
                  *(_QWORD *)(v7 + 8) = 0;
                  *(_DWORD *)(v7 + 4) = 0;
                }
              }
              v13 = *(_QWORD *)(v7 - 8);
              v12 = (void *)(v7 - 8);
              v14 = v13 + 8;
              if (v13 != -8)
                bzero(v12, v14);
              free(v12);
            }
            break;
          }
        }
        else
        {
          __clrex();
        }
      }
    }
    *(_QWORD *)(v2 + 16) = 0;
    out = 0;
    v15 = ASN1_item_i2d((ASN1_VALUE *)v2, &out, &X509_PUBKEY_it);
    if ((v15 & 0x80000000) == 0)
    {
      v32 = out;
      v33 = v15;
      v16 = EVP_parse_public_key(&v32);
      v17 = v16;
      if (!v16 || v33)
      {
        if (v16)
        {
          for (j = atomic_load(v16); j != -1; j = v19)
          {
            if (!j)
              goto LABEL_58;
            v19 = __ldaxr(v16);
            if (v19 == j)
            {
              if (!__stlxr(j - 1, v16))
              {
                if (j == 1)
                {
                  v20 = *((_QWORD *)v16 + 2);
                  if (v20)
                  {
                    v21 = *(void (**)(unsigned int *))(v20 + 160);
                    if (v21)
                    {
                      v21(v16);
                      *((_QWORD *)v17 + 1) = 0;
                      v17[1] = 0;
                    }
                  }
                  v23 = *((_QWORD *)v17 - 1);
                  v22 = v17 - 2;
                  v24 = v23 + 8;
                  if (v23 != -8)
                    bzero(v22, v24);
                  free(v22);
                }
                break;
              }
            }
            else
            {
              __clrex();
            }
          }
        }
      }
      else
      {
        *(_QWORD *)(v2 + 16) = v16;
      }
    }
    if (out)
    {
      v26 = out - 8;
      v25 = *((_QWORD *)out - 1);
      if (v25 != -8)
        bzero(v26, v25 + 8);
      free(v26);
    }
    ERR_clear_error();
    return 1;
  }
  else
  {
    if (a1 == 3)
    {
      v3 = *(_QWORD *)(v2 + 16);
      if (v3)
      {
        for (k = atomic_load((unsigned int *)v3); k != -1; k = v5)
        {
          if (!k)
            goto LABEL_58;
          v5 = __ldaxr((unsigned int *)v3);
          if (v5 == k)
          {
            if (!__stlxr(k - 1, (unsigned int *)v3))
            {
              if (k != 1)
                return 1;
              v27 = *(_QWORD *)(v3 + 16);
              if (v27)
              {
                v28 = *(void (**)(uint64_t))(v27 + 160);
                if (v28)
                {
                  v28(v3);
                  *(_QWORD *)(v3 + 8) = 0;
                  *(_DWORD *)(v3 + 4) = 0;
                }
              }
              v30 = *(_QWORD *)(v3 - 8);
              v29 = (void *)(v3 - 8);
              v31 = v30 + 8;
              if (v30 != -8)
                bzero(v29, v31);
              free(v29);
              return 1;
            }
          }
          else
          {
            __clrex();
          }
        }
      }
    }
    return 1;
  }
}

void X509_free(X509 *a)
{
  int *p_valid;
  unsigned int i;
  unsigned int v4;
  ASN1_BIT_STRING *signature;
  unsigned __int8 *data;
  unsigned __int8 *v7;
  uint64_t v8;
  size_t v9;
  uint64_t *p_flags;
  uint64_t flags;
  size_t v12;
  uint64_t ex_pcpathlen;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  size_t v17;
  void *v18;
  uint64_t v19;
  size_t v20;
  X509_CERT_AUX **p_aux;
  X509_CERT_AUX *aux;
  size_t p_reject;
  ASN1_VALUE *pval;

  if (a)
  {
    p_valid = &a->valid;
    for (i = atomic_load((unsigned int *)&a->valid); i != -1; i = v4)
    {
      if (!i)
        abort();
      v4 = __ldaxr((unsigned int *)p_valid);
      if (v4 == i)
      {
        if (!__stlxr(i - 1, (unsigned int *)p_valid))
        {
          if (i == 1)
          {
            CRYPTO_free_ex_data((int)&g_ex_data_class_2, a, (CRYPTO_EX_DATA *)&a->name);
            pval = (ASN1_VALUE *)a->cert_info;
            ASN1_item_ex_free(&pval, &X509_CINF_it);
            pval = (ASN1_VALUE *)a->sig_alg;
            ASN1_item_ex_free(&pval, &X509_ALGOR_it);
            signature = a->signature;
            if (signature)
            {
              data = signature->data;
              if (data)
              {
                v8 = *((_QWORD *)data - 1);
                v7 = data - 8;
                v9 = v8 + 8;
                if (v8 != -8)
                  bzero(v7, v9);
                free(v7);
              }
              flags = signature[-1].flags;
              p_flags = &signature[-1].flags;
              v12 = flags + 8;
              if (flags != -8)
                bzero(p_flags, v12);
              free(p_flags);
            }
            ex_pcpathlen = a->ex_pcpathlen;
            if (ex_pcpathlen)
            {
              v14 = *(_QWORD *)(ex_pcpathlen + 8);
              if (v14)
              {
                v16 = *(_QWORD *)(v14 - 8);
                v15 = (void *)(v14 - 8);
                v17 = v16 + 8;
                if (v16 != -8)
                  bzero(v15, v17);
                free(v15);
              }
              v19 = *(_QWORD *)(ex_pcpathlen - 8);
              v18 = (void *)(ex_pcpathlen - 8);
              v20 = v19 + 8;
              if (v19 != -8)
                bzero(v18, v20);
              free(v18);
            }
            pval = (ASN1_VALUE *)a->ex_flags;
            ASN1_item_ex_free(&pval, &AUTHORITY_KEYID_it);
            pval = (ASN1_VALUE *)a->ex_kusage;
            ASN1_item_ex_free(&pval, &CRL_DIST_POINTS_it);
            pval = (ASN1_VALUE *)a->ex_xkusage;
            ASN1_item_ex_free(&pval, &GENERAL_NAMES_it);
            pval = (ASN1_VALUE *)a->ex_nscert;
            ASN1_item_ex_free(&pval, &NAME_CONSTRAINTS_it);
            pval = *(ASN1_VALUE **)&a->sha1_hash[8];
            ASN1_item_ex_free(&pval, &X509_CERT_AUX_it);
            pthread_rwlock_destroy((pthread_rwlock_t *)&a->sha1_hash[16]);
            aux = a[-1].aux;
            p_aux = &a[-1].aux;
            p_reject = (size_t)&aux->reject;
            if (aux != (X509_CERT_AUX *)-8)
              bzero(p_aux, p_reject);
            free(p_aux);
          }
          return;
        }
      }
      else
      {
        __clrex();
      }
    }
  }
}

X509 *x509_parse(unsigned __int8 **a1, int a2)
{
  unint64_t v3;
  const char *v4;
  int v5;
  int v6;
  int v7;
  X509 *v8;
  char *v10;
  char *v11;
  X509_ALGOR *v12;
  ASN1_BIT_STRING *v13;
  X509_CINF *cert_info;
  ASN1_INTEGER *version;
  unint64_t v16;
  int v17;
  int v18;
  unsigned __int8 *in;
  uint64_t v20;
  unsigned __int8 *v21;
  unint64_t v22;
  unsigned __int8 *v23;
  uint64_t v24;
  unsigned __int8 *v25;
  uint64_t v26;
  unsigned __int8 *v27;
  unint64_t v28;
  unint64_t v29;

  v27 = 0;
  v28 = 0;
  v25 = 0;
  v26 = 0;
  v23 = 0;
  v24 = 0;
  v21 = 0;
  v22 = 0;
  v29 = 0;
  LODWORD(in) = 0;
  if (cbs_get_any_asn1_element(a1, &v27, &in, &v29, 0, 0, 0))
  {
    if ((_DWORD)in == 536870928)
    {
      v3 = v28 - v29;
      if (v28 >= v29)
      {
        v27 += v29;
        v28 -= v29;
        if (!(v3 >> 30))
        {
          v29 = 0;
          LODWORD(in) = 0;
          if (cbs_get_any_asn1_element(&v27, &v25, &in, &v29, 0, 0, 0))
          {
            if ((_DWORD)in == 536870928)
            {
              v29 = 0;
              LODWORD(in) = 0;
              if (cbs_get_any_asn1_element(&v27, &v23, &in, &v29, 0, 0, 0))
              {
                if ((_DWORD)in == 536870928)
                {
                  v20 = 0;
                  v29 = 0;
                  if (!cbs_get_any_asn1_element(&v27, &v21, (_DWORD *)&v20 + 1, &v29, &in, &v20, 1)
                    || v20 != 0x300000000
                    || v22 < v29
                    || (v21 += v29, v22 -= v29, v28))
                  {
                    v4 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/"
                         "boringssl/src/crypto/x509/x_x509.c";
                    v5 = 12;
                    v6 = 109;
                    v7 = 171;
                    goto LABEL_6;
                  }
                  v10 = (char *)malloc_type_malloc(0x160uLL, 0x30772F57uLL);
                  if (!v10)
                  {
                    v4 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/"
                         "boringssl/src/crypto/mem.c";
                    v5 = 14;
                    v6 = 65;
                    v7 = 247;
                    goto LABEL_6;
                  }
                  v11 = v10;
                  *(_QWORD *)v10 = 344;
                  *(_OWORD *)(v10 + 8) = 0u;
                  v8 = (X509 *)(v10 + 8);
                  *(_OWORD *)(v10 + 24) = 0u;
                  *(_OWORD *)(v10 + 40) = 0u;
                  *(_OWORD *)(v10 + 56) = 0u;
                  *(_OWORD *)(v10 + 72) = 0u;
                  *(_OWORD *)(v10 + 88) = 0u;
                  *(_OWORD *)(v10 + 104) = 0u;
                  *(_OWORD *)(v10 + 120) = 0u;
                  *(_OWORD *)(v10 + 136) = 0u;
                  *(_OWORD *)(v10 + 168) = 0u;
                  *(_OWORD *)(v10 + 184) = 0u;
                  *(_OWORD *)(v10 + 200) = 0u;
                  *(_OWORD *)(v10 + 216) = 0u;
                  *(_OWORD *)(v10 + 232) = 0u;
                  *(_OWORD *)(v10 + 248) = 0u;
                  *((_QWORD *)v10 + 43) = 0;
                  *(_OWORD *)(v10 + 264) = 0u;
                  *(_OWORD *)(v10 + 280) = 0u;
                  *(_OWORD *)(v10 + 296) = 0u;
                  *(_OWORD *)(v10 + 312) = 0u;
                  *(_OWORD *)(v10 + 328) = 0u;
                  *(_OWORD *)(v10 + 152) = 0u;
                  *((_DWORD *)v10 + 8) = 1;
                  *((_QWORD *)v10 + 6) = -1;
                  if (pthread_rwlock_init((pthread_rwlock_t *)(v10 + 152), 0))
                    abort();
                  in = v25;
                  if ((int)asn1_item_ex_d2i((uint64_t)v8, &in, v26, (uint64_t)&X509_CINF_it, -1, 0, 0, a2, 0) < 1
                    || in != &v25[v26]
                    || (in = v23,
                        v12 = d2i_X509_ALGOR(0, (const unsigned __int8 **)&in, v24),
                        (*((_QWORD *)v11 + 2) = v12) == 0)
                    || in != &v23[v24]
                    || (in = v21,
                        v13 = c2i_ASN1_BIT_STRING(0, (const unsigned __int8 **)&in, v22),
                        (*((_QWORD *)v11 + 3) = v13) == 0)
                    || in != &v21[v22])
                  {
LABEL_22:
                    X509_free(v8);
                    return 0;
                  }
                  cert_info = v8->cert_info;
                  version = v8->cert_info->version;
                  if (version)
                  {
                    v16 = ASN1_INTEGER_get(version);
                    if (v16 >= 3)
                    {
                      v17 = 140;
                      v18 = 210;
LABEL_40:
                      ERR_put_error(11, 0, v17, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x_x509.c", v18);
                      goto LABEL_22;
                    }
                    if (v16)
                    {
                      if (v16 == 2)
                        return v8;
                      cert_info = v8->cert_info;
                      goto LABEL_38;
                    }
                    cert_info = v8->cert_info;
                  }
                  if (cert_info->issuerUID || cert_info->subjectUID)
                  {
                    v17 = 139;
                    v18 = 218;
                    goto LABEL_40;
                  }
LABEL_38:
                  if (!cert_info->extensions)
                    return v8;
                  v17 = 139;
                  v18 = 224;
                  goto LABEL_40;
                }
              }
            }
          }
        }
      }
    }
  }
  v4 = "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/cryp"
       "to/x509/x_x509.c";
  v5 = 12;
  v6 = 109;
  v7 = 153;
LABEL_6:
  ERR_put_error(v5, 0, v6, v4, v7);
  return 0;
}

int i2d_X509(X509 *a, unsigned __int8 **out)
{
  _QWORD *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v12;
  void *v13;
  unsigned __int8 *outa;
  _OWORD v15[3];
  _OWORD v16[3];
  unint64_t *cert_info;

  if (a)
  {
    memset(v15, 0, sizeof(v15));
    memset(v16, 0, sizeof(v16));
    v4 = malloc_type_malloc(0x48uLL, 0x30772F57uLL);
    if (v4)
    {
      *v4 = 64;
      BYTE8(v16[0]) = 0;
      *(_QWORD *)&v16[0] = 0;
      *(_QWORD *)&v16[1] = v4 + 1;
      *(_OWORD *)((char *)&v16[1] + 8) = xmmword_208F05A00;
      BYTE8(v16[2]) = 1;
      if (CBB_flush((uint64_t *)v16))
      {
        cert_info = 0;
        if (CBB_add_space((uint64_t)v16, &cert_info, 1))
        {
          *(_BYTE *)cert_info = 48;
          if (cbb_add_child((uint64_t)v16, (uint64_t)v15, 1u, 1))
          {
            outa = 0;
            cert_info = (unint64_t *)a->cert_info;
            v5 = asn1_item_ex_i2d_opt(&cert_info, 0, (uint64_t)&X509_CINF_it, 0xFFFFFFFFLL, 0, 0);
            if ((v5 & 0x80000000) == 0)
            {
              v6 = v5;
              if (CBB_add_space((uint64_t)v15, &outa, v5))
              {
                if (ASN1_item_i2d((ASN1_VALUE *)a->cert_info, &outa, &X509_CINF_it) == v6)
                {
                  cert_info = (unint64_t *)a->sig_alg;
                  v7 = asn1_item_ex_i2d_opt(&cert_info, 0, (uint64_t)&X509_ALGOR_it, 0xFFFFFFFFLL, 0, 0);
                  if ((v7 & 0x80000000) == 0)
                  {
                    v8 = v7;
                    if (CBB_add_space((uint64_t)v15, &outa, v7))
                    {
                      if (ASN1_item_i2d((ASN1_VALUE *)a->sig_alg, &outa, &X509_ALGOR_it) == v8)
                      {
                        cert_info = (unint64_t *)a->signature;
                        v9 = asn1_item_ex_i2d_opt(&cert_info, 0, (uint64_t)&ASN1_ENUMERATED_it.sname, 0xFFFFFFFFLL, 0, 0);
                        if ((v9 & 0x80000000) == 0)
                        {
                          v10 = v9;
                          if (CBB_add_space((uint64_t)v15, &outa, v9))
                          {
                            if (ASN1_item_i2d((ASN1_VALUE *)a->signature, &outa, (const ASN1_ITEM *)&ASN1_ENUMERATED_it.sname) == v10)return CBB_finish_i2d((uint64_t)v16, (void **)out);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      ERR_put_error(14, 0, 65, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/mem.c", 247);
    }
    if (!BYTE8(v16[0]) && (BYTE8(v16[2]) & 1) != 0 && *(_QWORD *)&v16[1])
    {
      v13 = (void *)(*(_QWORD *)&v16[1] - 8);
      v12 = *(_QWORD *)(*(_QWORD *)&v16[1] - 8);
      if (v12 != -8)
        bzero(v13, v12 + 8);
      free(v13);
      return -1;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    ERR_put_error(12, 0, 155, "/Library/Caches/com.apple.xbs/Sources/libwebrtc/Source/ThirdParty/libwebrtc/Source/third_party/boringssl/src/crypto/x509/x_x509.c", 261);
    return -1;
  }
}

uint64_t silk_A2NLSF(_WORD *a1, int *a2, int a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _WORD *v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  int *v12;
  uint64_t v13;
  int v14;
  int *v15;
  int v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  unint64_t v24;
  char v25;
  int v26;
  unsigned int *v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  BOOL v39;
  BOOL v40;
  BOOL v41;
  int32x4_t *v42;
  int32x4_t *v43;
  unint64_t v44;
  unint64_t v45;
  int32x4_t v46;
  uint64_t v47;
  int32x4_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  int32x2_t v58;
  int32x2_t *v59;
  uint64_t v60;
  int32x2_t *v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  int32x2_t v67;
  int32x2_t *v68;
  int32x4_t *v69;
  int32x4_t *v70;
  int32x4_t *v71;
  uint64_t v72;
  int8x16_t v73;
  int32x4_t v74;
  int32x4_t v75;
  int v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  char *v80;
  uint64_t v81;
  int *v82;
  char *v83;
  int *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  char *v88;
  char *v89;
  char *v90;
  char *v91;
  char *v92;
  uint64_t v93;
  BOOL v95;
  char *v96;
  int *v97;
  char *v98;
  int *v99;
  unint64_t v100;
  BOOL v102;
  BOOL v103;
  int v104;
  BOOL v106;
  uint64_t v107;
  uint64_t result;
  BOOL v110;
  int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  signed int v126;
  int v127;
  int v128;
  int *v129;
  uint64_t v130;
  uint64_t v131;
  char v132;
  uint64_t v133;
  int32x4_t *v134;
  int32x4_t *v135;
  int v136;
  unint64_t v137;
  unint64_t v138;
  unsigned int v139;
  unsigned int v140;
  int v141;
  int v142;
  int v143;
  uint64_t v144;
  int32x4_t *v145;
  int32x4_t *v146;
  int v147;
  uint64_t v148;
  int32x4_t *v149;
  int8x16_t v150;
  int32x4_t v151;
  int32x4_t v152;
  uint64_t v153;
  int *v154;
  int *v155;
  int *v156;
  int v157;
  int v158;
  int v159;
  char v160;
  unint64_t v161;
  unint64_t v162;
  int32x4_t *v163;
  int32x4_t *v164;
  int32x4_t v165;
  uint64_t v166;
  int32x4_t v167;
  uint64_t v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  uint64_t v173;
  int64_t v174;
  unint64_t v175;
  int32x2_t v176;
  int32x2_t *v177;
  uint64_t v178;
  unint64_t v179;
  uint64_t v180;
  int *v181;
  uint64_t v182;
  int64_t v183;
  unint64_t v184;
  int32x2_t v185;
  int32x2_t *v186;
  unint64_t v187;
  unint64_t v188;
  unint64_t v189;
  unsigned int v190;
  uint64_t v191;
  int v192;
  unint64_t v193;
  int16x8_t v194;
  int16x8_t v195;
  int16x8_t v196;
  int16x8_t *v197;
  unint64_t v198;
  int16x8_t v199;
  uint64_t v200;
  _WORD *v201;
  unint64_t v202;
  BOOL v203;
  char v204;
  char v205;
  uint64_t v206;
  unint64_t v207;
  uint64_t v208;
  int32x4_t *v209;
  int32x4_t *v210;
  unint64_t v211;
  char *v213;
  unint64_t v214;
  int v216;
  uint64_t v217;
  int *v218;
  int *v219;
  int v220;
  int v221;
  unsigned int v222;
  int v223;
  int v224;
  int v225;
  int v226;
  int v227;
  _BYTE v228[12];
  int v229;
  int v230;
  int v231;
  int v232;
  int v233;
  int v234;
  int v235;
  int v236;
  uint64_t v237;

  v237 = *MEMORY[0x24BDAC8D0];
  v3 = (a3 >> 1);
  v218 = &v229;
  v219 = &v220;
  v4 = (uint64_t)a3 >> 1;
  v5 = 4 * (int)v3;
  *(int *)((char *)&v229 + v5) = 0x10000;
  *(int *)((char *)&v220 + v5) = 0x10000;
  v217 = v4;
  if (a3 < 2)
  {
    v25 = 0;
    v26 = 0;
    v28 = (a3 >> 1);
    v23 = 0x10000;
    v27 = (unsigned int *)&v229;
    goto LABEL_71;
  }
  v6 = a1;
  if (a3 >= 0x10 && ((v7 = v3 - 1, (int)v4 > 0) ? (v8 = (v3 - 1) >> 32 == 0) : (v8 = 0), v8))
  {
    v9 = v3 & 0xFFFFFFFC;
    v69 = (int32x4_t *)&a2[v4];
    v70 = (int32x4_t *)&v229;
    v71 = (int32x4_t *)&v220;
    v72 = v9;
    do
    {
      v73 = (int8x16_t)vrev64q_s32(*(int32x4_t *)&a2[v7 - 3]);
      v74 = (int32x4_t)vextq_s8(v73, v73, 8uLL);
      v75 = *v69++;
      *v70++ = vnegq_s32(vaddq_s32(v74, v75));
      *v71++ = vsubq_s32(v75, v74);
      v7 -= 4;
      v72 -= 4;
    }
    while (v72);
    if (v9 == v3)
      goto LABEL_10;
  }
  else
  {
    v9 = 0;
  }
  v10 = v3 - v9;
  v11 = &v220 + v9;
  v12 = &v229 + v9;
  v13 = v9 + v4;
  v14 = ~(_DWORD)v9 + v4;
  v15 = &a2[v13];
  do
  {
    v16 = a2[v14];
    v17 = *v15++;
    *v12++ = -v17 - v16;
    *v11++ = v17 - v16;
    --v14;
    --v10;
  }
  while (v10);
LABEL_10:
  v18 = v3 + 1;
  v19 = v3 + 1 - (a3 > 1);
  v20 = 4 * v3;
  v21 = (a3 >> 1);
  if (v19 < 0x24)
    goto LABEL_224;
  v29 = v3 - (a3 > 1);
  v30 = 4 * v29;
  v21 = (a3 >> 1);
  if ((char *)&v220 + v20 + -4 * v29 > (char *)&v220 + v20)
    goto LABEL_224;
  v31 = 4 * (v4 - 1);
  v21 = (a3 >> 1);
  if ((char *)&v220 + v31 - v30 > (char *)&v220 + v31)
    goto LABEL_224;
  v21 = (a3 >> 1);
  if ((char *)&v229 + v20 - v30 > (char *)&v229 + v20)
    goto LABEL_224;
  v21 = (a3 >> 1);
  if ((char *)&v229 + v31 - v30 > (char *)&v229 + v31)
    goto LABEL_224;
  v21 = (a3 >> 1);
  if ((int)v4 - 1 < v29)
    goto LABEL_224;
  v21 = (a3 >> 1);
  if (HIDWORD(v29))
    goto LABEL_224;
  v32 = 4 * (a3 > 1);
  v33 = 4 * (v3 - 1);
  v34 = v32 + v33 - v20;
  v33 += 4;
  v35 = (char *)&v229 + v33;
  v36 = (char *)&v229 + v32;
  v37 = (char *)&v220 + v33;
  v38 = (char *)&v220 + v32;
  v39 = (char *)&v220 + v34 >= (char *)&v220 + v20 + 4 || v38 >= v37;
  v40 = !v39;
  v41 = v36 >= v35 || (char *)&v229 + v34 >= (char *)&v229 + v20 + 4;
  v21 = (a3 >> 1);
  if (!v41)
    goto LABEL_224;
  v21 = (a3 >> 1);
  if (v40)
    goto LABEL_224;
  v21 = v3 - (v19 & 0xFFFFFFFFFFFFFFFCLL);
  v42 = (int32x4_t *)((char *)&v220 + v20 - 12);
  v43 = (int32x4_t *)((char *)&v229 + v20 - 12);
  v44 = v3 + 0xFFFFFFFF;
  v45 = v19 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v46 = *v43--;
    v47 = 4 * v44;
    *(int32x4_t *)&v228[v47] = vsubq_s32(*(int32x4_t *)&v228[v47], v46);
    v48 = *v42--;
    *(int32x4_t *)((char *)&v218 + v47 + 4) = vaddq_s32(*(int32x4_t *)((char *)&v218 + v47 + 4), v48);
    v44 -= 4;
    v45 -= 4;
  }
  while (v45);
  if (v19 != (v19 & 0xFFFFFFFFFFFFFFFCLL))
  {
LABEL_224:
    do
    {
      v22 = 4 * (v21 - 1);
      *(int *)((char *)&v229 + v22) -= *(&v229 + v21);
      *(int *)((char *)&v220 + v22) += *(&v220 + v21);
      v102 = v21-- > 1;
    }
    while (v102);
  }
  if (a3 <= 3)
  {
    v23 = *(&v229 + v4);
LABEL_14:
    v24 = v3 + 1;
    do
      v23 = *(&v229 + (v24-- - 2)) + 2 * v23;
    while (v24 > 1);
    if (v23 < 0)
    {
      *v6 = 0;
      v27 = (unsigned int *)&v220;
      v23 = *(&v220 + v4);
      do
        v23 = *(&v220 + (v18-- - 2)) + 2 * v23;
      while (v18 > 1);
      v25 = 0;
      v26 = 1;
    }
    else
    {
      v25 = 0;
      v26 = 0;
      v27 = (unsigned int *)&v229;
    }
    v28 = (a3 >> 1);
    goto LABEL_71;
  }
  v49 = 0;
  v50 = (v3 + 1);
  v51 = v3 - 2;
  v52 = v20 - 4;
  v53 = 2;
  v54 = v3 - 2;
  do
  {
    if (v53 < v3)
    {
      v55 = v51 - v49;
      v56 = (a3 >> 1);
      if (v51 - v49 < 2)
        goto LABEL_225;
      v57 = v54 & 0xFFFFFFFFFFFFFFFELL;
      v56 = v3 - (v55 & 0xFFFFFFFFFFFFFFFELL);
      v58 = *(int32x2_t *)((char *)&v229 + v52);
      v59 = (int32x2_t *)((char *)&v229 + v20 - 12);
      do
      {
        v58 = vsub_s32(*v59, v58);
        *v59-- = v58;
        v57 -= 2;
      }
      while (v57);
      v4 = (uint64_t)a3 >> 1;
      if (v55 != (v55 & 0xFFFFFFFFFFFFFFFELL))
      {
LABEL_225:
        do
        {
          *(_DWORD *)&v228[4 * v56 + 4] -= *(&v229 + v56);
          --v56;
        }
        while (v56 > v53);
      }
    }
    *(_DWORD *)&v228[4 * v53 + 4] -= 2 * *(&v229 + v53);
    ++v53;
    ++v49;
    --v54;
  }
  while (v53 != v50);
  v60 = 0;
  v61 = (int32x2_t *)((char *)&v220 + v20 - 12);
  v62 = 2;
  v63 = v3 - 2;
  v6 = a1;
  do
  {
    if (v62 < v3)
    {
      v64 = v51 - v60;
      v65 = (a3 >> 1);
      if (v51 - v60 < 2)
        goto LABEL_226;
      v66 = v63 & 0xFFFFFFFFFFFFFFFELL;
      v65 = v3 - (v64 & 0xFFFFFFFFFFFFFFFELL);
      v67 = *(int32x2_t *)((char *)&v220 + v52);
      v68 = v61;
      do
      {
        v67 = vsub_s32(*v68, v67);
        *v68-- = v67;
        v66 -= 2;
      }
      while (v66);
      v6 = a1;
      if (v64 != (v64 & 0xFFFFFFFFFFFFFFFELL))
      {
LABEL_226:
        do
        {
          *((_DWORD *)&v219 + v65) -= *(&v220 + v65);
          --v65;
        }
        while (v65 > v62);
      }
    }
    *((_DWORD *)&v219 + v62) -= 2 * *(&v220 + v62);
    ++v62;
    ++v60;
    --v63;
  }
  while (v62 != v50);
  v23 = *(&v229 + v4);
  if ((_DWORD)v3 != 8)
    goto LABEL_14;
  v23 = v229 + 2 * v230 + 4 * (v231 + 2 * v232 + 8 * v234 + 4 * v233 + 16 * (2 * v236 + 4 * v23 + v235));
  if (v23 < 0)
  {
    *v6 = 0;
    v27 = (unsigned int *)&v220;
    v23 = v220 + 2 * v221 + 4 * (v222 + 2 * v223 + 8 * v225 + 4 * v224 + 16 * (2 * v227 + 4 * *(&v220 + v4) + v226));
    v25 = 1;
    v28 = 8;
    v26 = 1;
  }
  else
  {
    v26 = 0;
    v27 = (unsigned int *)&v229;
    v25 = 1;
    v28 = 8;
  }
LABEL_71:
  v216 = 0;
  v76 = 0;
  v77 = (v4 + 1);
  v208 = (a3 - 1);
  v207 = v28 - 2;
  v78 = v28 - (v28 != 0);
  v79 = 4 * (v28 - 1);
  v80 = (char *)&v229 + v79;
  v81 = 4 * v28;
  v82 = &v229 + v28;
  v83 = (char *)&v220 + v79;
  v84 = &v220 + v28;
  v85 = 4 * (v28 != 0);
  v86 = (4 * v28 + 0x3FFFFFFFCLL) & 0x3FFFFFFFCLL;
  v87 = v85 + v86 - 4 * v28;
  v213 = (char *)&v229 + v87;
  v86 += 4;
  v88 = (char *)&v229 + v86;
  v89 = (char *)&v229 + v85;
  v90 = (char *)&v220 + v87;
  v91 = (char *)&v220 + v86;
  v92 = (char *)&v220 + v85;
  v93 = v28 + 1 - (v28 != 0);
  v206 = 4 * v28 - 4;
  v95 = (int)v3 - (int)v28 >= (int)v217 || (v28 - 1) >> 32 != 0;
  v205 = v95;
  v96 = &v80[-4 * v78];
  v97 = &v82[-v78];
  v39 = (int)v28 - 1 >= v78;
  v98 = &v83[-4 * v78];
  v99 = &v84[-v78];
  v100 = HIDWORD(v78);
  v102 = !v39 || v100 != 0 || v96 > v80;
  v103 = v102 || v97 > v82;
  v104 = a3;
  v106 = v103 || v98 > v83 || v99 > v84;
  v107 = (uint64_t)a3 >> 1;
  result = v106;
  v110 = v213 < (char *)&v229 + 4 * v28 + 4 && v89 < v88;
  if (v90 < (char *)&v220 + 4 * v28 + 4 && v92 < v91)
    v110 = 1;
  v203 = v110;
  v204 = result;
  v214 = v28 + 1 - (v28 != 0);
  v211 = v93 & 0xFFFFFFFFFFFFFFFCLL;
  v202 = v28 - (v93 & 0xFFFFFFFFFFFFFFFCLL);
  v209 = (int32x4_t *)((char *)&v229 + v81 - 12);
  v210 = (int32x4_t *)((char *)&v220 + v81 - 12);
  v112 = 0x2000;
  v113 = 1;
  while (1)
  {
    do
    {
      while (1)
      {
        v114 = silk_LSFCosTab_FIX_Q12[v113];
        v115 = v27[v107];
        v116 = 16 * v114;
        if ((v25 & 1) != 0)
        {
          result = *v27;
          v117 = result
               + ((unint64_t)((int)(v27[1]
                                         + ((unint64_t)((int)(v27[2]
                                                                   + ((unint64_t)((int)(v27[3]
                                                                                             + ((unint64_t)((int)(v27[4] + ((unint64_t)((int)(v27[5] + ((unint64_t)((int)(v27[6] + ((unint64_t)((int)(v27[7] + ((unint64_t)(v115 * (uint64_t)v116) >> 16)) * (uint64_t)v116) >> 16)) * (uint64_t)v116) >> 16)) * (uint64_t)v116) >> 16)) * (uint64_t)v116) >> 16))
                                                                                       * (uint64_t)v116) >> 16))
                                                             * (uint64_t)v116) >> 16))
                                   * (uint64_t)v116) >> 16);
        }
        else
        {
          v188 = v28 + 1;
          v117 = v27[v107];
          if (v104 > 1)
          {
            do
            {
              result = (unint64_t)(v116 * (uint64_t)v117) >> 16;
              v117 = v27[(v188-- - 2)] + result;
            }
            while (v188 > 1);
          }
        }
        v118 = v113;
        if ((v23 >= 1 || v117 < v76) && (v23 < 0 || v117 > -v76))
          break;
        v119 = ((v112 + v114) & 1) + ((v112 + v114) >> 1);
        v120 = 16 * v119;
        if ((v25 & 1) != 0)
        {
          v121 = *v27
               + ((unint64_t)((int)(v27[1]
                                         + ((unint64_t)((int)(v27[2]
                                                                   + ((unint64_t)((int)(v27[3]
                                                                                             + ((unint64_t)((int)(v27[4] + ((unint64_t)((int)(v27[5] + ((unint64_t)((int)(v27[6] + ((unint64_t)((int)(v27[7] + ((unint64_t)(v115 * (uint64_t)v120) >> 16)) * (uint64_t)v120) >> 16)) * (uint64_t)v120) >> 16)) * (uint64_t)v120) >> 16)) * (uint64_t)v120) >> 16))
                                                                                       * (uint64_t)v120) >> 16))
                                                             * (uint64_t)v120) >> 16))
                                   * (uint64_t)v120) >> 16);
        }
        else
        {
          v121 = v27[v107];
          if (v104 > 1)
          {
            v189 = v28 + 1;
            v121 = v115;
            do
              v121 = v27[(v189-- - 2)] + ((unint64_t)(v120 * (uint64_t)v121) >> 16);
            while (v189 > 1);
          }
        }
        if ((v23 >= 1 || v121 < 0) && (v23 < 0 || v121 >= 1))
        {
          v122 = -128;
          v112 = ((v112 + v114) & 1) + ((v112 + v114) >> 1);
          v23 = v121;
          v121 = v117;
          v123 = ((v114 + v119) & 1) + ((v114 + v119) >> 1);
          v124 = 16 * v123;
          if ((v25 & 1) != 0)
          {
LABEL_120:
            v125 = *v27
                 + ((unint64_t)((int)(v27[1]
                                           + ((unint64_t)((int)(v27[2]
                                                                     + ((unint64_t)((int)(v27[3]
                                                                                               + ((unint64_t)((int)(v27[4] + ((unint64_t)((int)(v27[5] + ((unint64_t)((int)(v27[6] + ((unint64_t)((int)(v27[7] + ((unint64_t)(v115 * (uint64_t)v124) >> 16)) * (uint64_t)v124) >> 16)) * (uint64_t)v124) >> 16)) * (uint64_t)v124) >> 16)) * (uint64_t)v124) >> 16))
                                                                                         * (uint64_t)v124) >> 16))
                                                               * (uint64_t)v124) >> 16))
                                     * (uint64_t)v124) >> 16);
            goto LABEL_121;
          }
        }
        else
        {
          v122 = -256;
          v114 = ((v112 + v114) & 1) + ((v112 + v114) >> 1);
          v123 = ((v119 + v112) & 1) + ((v119 + v112) >> 1);
          v124 = 16 * v123;
          if ((v25 & 1) != 0)
            goto LABEL_120;
        }
        v125 = v115;
        if (v104 > 1)
        {
          v136 = v124;
          v137 = v28 + 1;
          v125 = v115;
          do
            v125 = v27[(v137-- - 2)] + ((unint64_t)(v136 * (uint64_t)v125) >> 16);
          while (v137 > 1);
        }
LABEL_121:
        if ((v23 >= 1 || v125 < 0) && (v23 < 0 || v125 >= 1))
        {
          v122 |= 0x40u;
          v23 = v125;
          v126 = 16 * (((v114 + v123) & 1) + ((v114 + v123) >> 1));
          if ((v25 & 1) != 0)
          {
LABEL_126:
            v115 = *v27
                 + ((unint64_t)((int)(v27[1]
                                           + ((unint64_t)((int)(v27[2]
                                                                     + ((unint64_t)((int)(v27[3]
                                                                                               + ((unint64_t)((int)(v27[4] + ((unint64_t)((int)(v27[5] + ((unint64_t)((int)(v27[6] + ((unint64_t)((int)(v27[7] + ((unint64_t)(v115 * (uint64_t)v126) >> 16)) * (uint64_t)v126) >> 16)) * (uint64_t)v126) >> 16)) * (uint64_t)v126) >> 16)) * (uint64_t)v126) >> 16))
                                                                                         * (uint64_t)v126) >> 16))
                                                               * (uint64_t)v126) >> 16))
                                     * (uint64_t)v126) >> 16);
            goto LABEL_127;
          }
        }
        else
        {
          v121 = v125;
          v126 = 16 * (((v123 + v112) & 1) + ((v123 + v112) >> 1));
          if ((v25 & 1) != 0)
            goto LABEL_126;
        }
        if (v104 > 1)
        {
          v138 = v28 + 1;
          do
            v115 = v27[(v138-- - 2)] + ((unint64_t)(v126 * (uint64_t)v115) >> 16);
          while (v138 > 1);
        }
LABEL_127:
        if ((v23 >= 1 || v115 < 0) && (v23 < 0 || v115 >= 1))
        {
          v122 += 32;
          v23 = v115;
        }
        else
        {
          v121 = v115;
        }
        v76 = v117 == 0;
        if (v23 >= 0)
          v139 = v23;
        else
          v139 = -v23;
        v140 = HIWORD(v139);
        v141 = v23 / ((v23 - v121) >> 5) + v122;
        result = (((v23 - v121) >> 1) + 32 * v23);
        if (v23 != v121)
          v122 += (int)result / (v23 - v121);
        if (v140)
          v142 = v141;
        else
          v142 = v122;
        v143 = v142 + (v113 << 8);
        if (v143 >= 0x7FFF)
          LOWORD(v143) = 0x7FFF;
        a1[v26++] = v143;
        if (v26 >= v104)
          return result;
        v27 = (unsigned int *)(&v218)[v26 & 1];
        v112 = silk_LSFCosTab_FIX_Q12[v113 - 1];
        v23 = 4096 - ((v26 << 12) & 0x2000);
        v107 = v217;
      }
      v76 = 0;
      ++v113;
      v112 = v114;
      v23 = v117;
    }
    while (v118 < 128);
    if (v216 >= 16)
      break;
    v127 = -1 << (v216 + 1);
    v128 = v127 + 0x10000;
    ++v216;
    if (v104 < 2)
    {
      v26 = 0;
      v76 = 0;
      a2[(int)v208] = (unint64_t)(a2[(int)v208] * (uint64_t)v128) >> 16;
      v144 = 4 * v107;
      v27 = (unsigned int *)&v229;
      v23 = 0x10000;
      *(int *)((char *)&v229 + v144) = 0x10000;
      *(int *)((char *)&v220 + v144) = 0x10000;
      v112 = 0x2000;
      v113 = 1;
      if ((v25 & 1) != 0)
        goto LABEL_180;
    }
    else
    {
      v129 = a2;
      v130 = v208;
      do
      {
        *v129 = (unint64_t)(*v129 * (uint64_t)v128) >> 16;
        ++v129;
        v128 += (((v128 * v127) >> 15) + 1) >> 1;
        --v130;
      }
      while (v130);
      a2[(int)v208] = (unint64_t)(a2[(int)v208] * (uint64_t)v128) >> 16;
      v131 = 4 * v107;
      *(int *)((char *)&v229 + v131) = 0x10000;
      *(int *)((char *)&v220 + v131) = 0x10000;
      v132 = v205;
      if (v28 < 8)
        v132 = 1;
      if ((v132 & 1) != 0)
      {
        v133 = 0;
        v135 = v209;
        v134 = v210;
      }
      else
      {
        v145 = (int32x4_t *)&v229;
        v146 = (int32x4_t *)&v220;
        v147 = v217 - 1;
        v148 = v28 & 0xFFFFFFFC;
        v149 = (int32x4_t *)&a2[v217];
        v135 = v209;
        v134 = v210;
        do
        {
          v150 = (int8x16_t)vrev64q_s32(*(int32x4_t *)&a2[v147 - 3]);
          v151 = (int32x4_t)vextq_s8(v150, v150, 8uLL);
          v152 = *v149++;
          *v145++ = vnegq_s32(vaddq_s32(v151, v152));
          *v146++ = vsubq_s32(v152, v151);
          v147 -= 4;
          v148 -= 4;
        }
        while (v148);
        v133 = v28 & 0xFFFFFFFC;
        if (v28 == v133)
          goto LABEL_171;
      }
      v153 = v28 - v133;
      v154 = &v220 + v133;
      v155 = &v229 + v133;
      v156 = &a2[v107 + v133];
      v157 = v3 - 1 - v133;
      do
      {
        v158 = a2[v157];
        v159 = *v156++;
        *v155++ = -v159 - v158;
        *v154++ = v159 - v158;
        --v157;
        --v153;
      }
      while (v153);
LABEL_171:
      v160 = v204;
      if (v214 < 0x1C)
        v160 = 1;
      v161 = v28;
      if (((v160 | v203) & 1) != 0)
        goto LABEL_227;
      v162 = v28 + 0xFFFFFFFF;
      v163 = v135;
      v164 = v134;
      result = v211;
      do
      {
        v165 = *v163--;
        v166 = 4 * v162;
        *(int32x4_t *)&v228[v166] = vsubq_s32(*(int32x4_t *)&v228[v166], v165);
        v167 = *v164--;
        *(int32x4_t *)((char *)&v218 + v166 + 4) = vaddq_s32(*(int32x4_t *)((char *)&v218 + v166 + 4), v167);
        v162 -= 4;
        result -= 4;
      }
      while (result);
      v161 = v202;
      if (v214 != v211)
      {
LABEL_227:
        do
        {
          v168 = 4 * (v161 - 1);
          result = *(unsigned int *)((char *)&v229 + v168);
          *(int *)((char *)&v229 + v168) = result - *(&v229 + v161);
          *(int *)((char *)&v220 + v168) += *(&v220 + v161);
          v102 = v161-- > 1;
        }
        while (v102);
      }
      if (a3 >= 4)
      {
        v170 = 0;
        v171 = v28 - 2;
        v172 = 2;
        do
        {
          if (v172 < v28)
          {
            v173 = v207 - v170;
            v174 = v28;
            if (v207 - v170 < 2)
              goto LABEL_228;
            v175 = v171 & 0xFFFFFFFFFFFFFFFELL;
            v174 = v28 - (v173 & 0xFFFFFFFFFFFFFFFELL);
            v176 = *(int32x2_t *)((char *)&v229 + v206);
            v177 = (int32x2_t *)v135;
            do
            {
              v176 = vsub_s32(*v177, v176);
              *v177-- = v176;
              v175 -= 2;
            }
            while (v175);
            if (v173 != (v173 & 0xFFFFFFFFFFFFFFFELL))
            {
LABEL_228:
              do
              {
                *(_DWORD *)&v228[4 * v174 + 4] -= *(&v229 + v174);
                --v174;
              }
              while (v174 > v172);
            }
          }
          *(_DWORD *)&v228[4 * v172 + 4] -= 2 * *(&v229 + v172);
          ++v172;
          ++v170;
          --v171;
        }
        while (v172 != v77);
        v178 = 0;
        v179 = v28 - 2;
        v180 = 2;
        do
        {
          if (v180 < v28)
          {
            v182 = v207 - v178;
            v183 = v28;
            if (v207 - v178 < 2)
              goto LABEL_229;
            v184 = v179 & 0xFFFFFFFFFFFFFFFELL;
            v183 = v28 - (v182 & 0xFFFFFFFFFFFFFFFELL);
            v185 = *(int32x2_t *)((char *)&v220 + v206);
            v186 = (int32x2_t *)v134;
            do
            {
              v185 = vsub_s32(*v186, v185);
              *v186-- = v185;
              v184 -= 2;
            }
            while (v184);
            if (v182 != (v182 & 0xFFFFFFFFFFFFFFFELL))
            {
LABEL_229:
              do
              {
                *((_DWORD *)&v219 + v183) -= *(&v220 + v183);
                --v183;
              }
              while (v183 > v180);
            }
          }
          v181 = &v220 + v180;
          result = (*(v181 - 2) - 2 * *v181);
          *(v181 - 2) = result;
          ++v180;
          ++v178;
          --v179;
        }
        while (v180 != v77);
      }
      v23 = *(&v229 + v107);
      v169 = v28 + 1;
      v104 = a3;
      if ((v25 & 1) != 0)
      {
LABEL_180:
        v26 = 0;
        v76 = 0;
        v23 = v229 + 2 * v230 + 4 * (v231 + 2 * v232 + 8 * v234 + 4 * v233 + 16 * (2 * v236 + 4 * v23 + v235));
        v27 = (unsigned int *)&v229;
        v112 = 0x2000;
        v113 = 1;
        if (v23 < 0)
        {
          v76 = 0;
          *a1 = 0;
          v27 = (unsigned int *)&v220;
          result = v222;
          v23 = v220
              + 2 * v221
              + 4 * (v222 + 2 * v223 + 8 * v225 + 4 * v224 + 16 * (2 * v227 + 4 * *(&v220 + v107) + v226));
          v113 = 1;
          v26 = 1;
        }
      }
      else
      {
        do
          v23 = *(&v229 + (v169-- - 2)) + 2 * v23;
        while (v169 > 1);
        v26 = 0;
        v76 = 0;
        v27 = (unsigned int *)&v229;
        v112 = 0x2000;
        v113 = 1;
        if (v23 < 0)
        {
          *a1 = 0;
          v23 = *(&v220 + v107);
          v187 = v28 + 1;
          do
          {
            v27 = (unsigned int *)&v220;
            v23 = *(&v220 + (v187-- - 2)) + 2 * v23;
            v112 = 0x2000;
            v113 = 1;
          }
          while (v187 > 1);
          v76 = 0;
          v26 = 1;
        }
      }
    }
  }
  v190 = 0x8000 / (v104 + 1);
  *a1 = v190;
  if (v104 >= 2)
  {
    if (v104 < 0x11)
    {
      v191 = 1;
      v192 = 0x8000 / (v104 + 1);
      goto LABEL_218;
    }
    v193 = (v104 - 1) & 0xFFFFFFFFFFFFFFF0;
    v192 = (v193 | 1) * v190;
    v191 = v193 | 1;
    v194 = vdupq_n_s16(v190);
    v195 = vmulq_s16(v194, (int16x8_t)xmmword_208F0D900);
    v196 = vdupq_n_s16(8 * v190);
    v197 = (int16x8_t *)(a1 + 9);
    v198 = v193;
    do
    {
      v199 = vaddq_s16(v195, v196);
      v197[-1] = vaddq_s16(v195, v194);
      *v197 = vaddq_s16(v199, v194);
      v195 = vaddq_s16(v199, v196);
      v197 += 2;
      v198 -= 16;
    }
    while (v198);
    if (v104 - 1 != v193)
    {
LABEL_218:
      v200 = v104 - v191;
      v201 = &a1[v191];
      do
      {
        v192 += v190;
        *v201++ = v192;
        --v200;
      }
      while (v200);
    }
  }
  return result;
}

void run_analysis(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, int a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  char v26;
  float v27;
  float v28;
  float v29;
  float v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  unsigned int *v40;
  uint64_t v41;
  float *v42;
  signed int v43;
  unsigned int v44;
  float v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  float v50;
  float v51;
  float v52;
  uint64_t v53;
  float v54;
  float v55;
  __int32 *v56;
  __int32 *v57;
  uint64_t v58;
  float v59;
  float32x2_t v60;
  _OWORD *v61;
  int v62;
  unsigned int v63;
  uint64_t v64;
  const float *v65;
  __int16 *v66;
  float32x2_t v67;
  float32x2_t *v68;
  uint64_t v69;
  uint64_t v70;
  float32x2_t v71;
  float v72;
  uint64_t v73;
  float *v74;
  float *v75;
  float v76;
  float v77;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float *v84;
  float v85;
  float v86;
  float v87;
  float v88;
  uint64_t v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  uint64_t v115;
  uint64_t v116;
  _OWORD *v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  uint64_t v121;
  const float *v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t *v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float v136;
  float v137;
  float v138;
  float v139;
  float v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;
  uint64_t v147;
  int v148;
  double v149;
  unint64_t v150;
  float v151;
  float v152;
  unint64_t v153;
  float v154;
  float v155;
  float v156;
  float *v157;
  unint64_t v158;
  int v159;
  float v160;
  float v161;
  float v162;
  float v163;
  uint64_t v164;
  unint64_t v165;
  const float *v166;
  const float *v167;
  uint64_t v168;
  float32x4_t *v169;
  int8x16_t *v170;
  unint64_t v171;
  float32x4_t v172;
  const float *v173;
  const float *v174;
  int8x16_t v175;
  int8x16_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  unint64_t v182;
  float *v183;
  float *v184;
  uint64_t v185;
  float *v186;
  float *v187;
  float v188;
  float v189;
  float v190;
  float v191;
  float v192;
  float v193;
  float v194;
  float v195;
  uint64_t v196;
  uint64_t v197;
  float v198;
  unint64_t v199;
  float v200;
  float v201;
  unint64_t v202;
  float *v203;
  float *v204;
  float v205;
  uint64_t v206;
  float v207;
  float v208;
  float v209;
  float v210;
  float v211;
  float v212;
  float v213;
  float v214;
  float v215;
  float v216;
  float v217;
  float v218;
  float v219;
  float v220;
  float v221;
  float v222;
  float v223;
  float v224;
  float v225;
  float v226;
  float v227;
  float v228;
  float v229;
  float v230;
  int v231;
  int v232;
  float v233;
  uint64_t v234;
  float v235;
  float v236;
  int v237;
  int v238;
  float v239;
  float v240;
  uint64_t v241;
  float v242;
  float v243;
  float v244;
  float v245;
  float v246;
  float v247;
  float v248;
  float v249;
  float v250;
  float v251;
  float v252;
  float v253;
  float v254;
  float v255;
  float v256;
  float v257;
  float v258;
  float v259;
  float v260;
  float v261;
  float v262;
  float v263;
  float v264;
  float v265;
  float v266;
  float v267;
  float v268;
  float v269;
  float v270;
  float v271;
  float v272;
  float v273;
  float v274;
  float v275;
  float v276;
  float32x4_t v277;
  float32x4_t v278;
  float32x4_t v279;
  float32x4_t v280;
  float32x4_t v281;
  float32x4_t v285;
  float32x4_t v286;
  float32x4_t v287;
  float32x4_t v288;
  float32x2_t v289;
  float32x2_t v290;
  float32x4_t v291;
  float32x2_t v292;
  int32x2_t v294;
  int8x16_t *v295;
  float32x4_t v296;
  float32x4_t v297;
  float32x4_t v298;
  float32x4_t v299;
  float32x4_t v300;
  float v301;
  float v302;
  float v303;
  int v304;
  uint64_t v305;
  float v306;
  float *v307;
  float v308;
  float v309;
  float v310;
  float v311;
  float v312;
  float v313;
  float v314;
  float v315;
  float v316;
  float v317;
  float v318;
  float v319;
  float v320;
  float v321;
  float v322;
  float v323;
  float v324;
  float v325;
  float *v326;
  float v327;
  float v328;
  float v329;
  float v330;
  float v331;
  unint64_t v333;
  int v334;
  float v335;
  float v336;
  int64_t v337;
  int v338;
  float v339;
  float v340;
  float v341;
  float v342;
  unint64_t v343;
  int v344;
  float v345;
  unint64_t v346;
  unint64_t v347;
  const float *v348;
  const float *v349;
  unint64_t v350;
  const float *v351;
  const float *v352;
  int8x16_t v353;
  float32x4_t v354;
  int8x16_t v355;
  float32x4_t v356;
  unint64_t v357;
  uint64_t v358;
  float *v359;
  float *v360;
  float v361;
  float v362;
  float v363;
  float v364;
  float v365;
  float v366;
  unint64_t v367;
  float v368;
  float v369;
  float v371;
  float v372;
  float v373;
  float v375;
  _BOOL4 v376;
  float v377;
  float v378;
  int v379;
  long double v380;
  float v381;
  float v382;
  float v383;
  float32x4_t v384;
  uint64_t v385;
  float v386;
  float v387;
  float v388;
  float v389;
  float v390;
  float v391;
  float v392;
  float v393;
  float v394;
  float v395;
  float v396;
  float v397;
  float v398;
  float32x2_t v399;
  float32x2_t v400;
  float32x2_t v401;
  float32x2_t v402;
  float32x2_t v403;
  float v404;
  float v405;
  float v406;
  float v408;
  float v409;
  float v410;
  float32x2_t v411;
  float v412;
  float v413;
  float32x2_t v414;
  float32x2_t v416;
  int v418;
  int v419;
  int v420;
  int v421;
  float v422;
  float v423;
  float v424;
  int v425;
  float v426;
  float v427;
  float v428;
  float v437;
  float v438;
  float32x2_t v439;
  float v440;
  float v441;
  float v442;
  float v443;
  __n128 v444;
  float v445;
  float v446;
  float v447;
  int32x4_t v448;
  double v449;
  int32x4_t v450;
  __n128 v451;
  int32x4_t v452;
  float v453;
  uint64_t v454;
  int v455;
  int v456;
  int v457;
  int v458;
  int v459;
  int v460;
  int v461;
  unsigned int v462;
  unsigned int v463;
  int v464;
  int v465;
  int v466;
  int v468;
  __int128 v469;
  __int128 v470;
  __int128 v471;
  float v472;
  int v473;
  int v474;
  char v475;
  char v476;
  char v477;
  float v478;
  float v479;
  int v480;
  uint64_t v481;
  float v482;
  float v483;
  int v484;
  int v485;
  uint64_t v486;
  float v487;
  int v488;
  int v489;
  uint64_t v490;
  float v491;
  int v492;
  int v493;
  int v494;
  int v495;
  int v496;
  int v497;
  int v498;
  int v499;
  int v500;
  int v501;
  int v502;
  int v503;
  int v504;
  float v505;
  float v506;
  int v507;
  int v508;
  int v509;
  uint64_t v510;
  uint64_t v511;
  int v512;
  int v513;
  float v514;
  float v515;
  float v516;
  float v517;
  float v518;
  uint64_t v519;
  float v520;
  float v521;
  float v522;
  float v523;
  float v524;
  float v525;
  int v526;
  int v527;
  float v528;
  float v529;
  float v530;
  float v531;
  float v532;
  float v533;
  unsigned int v534;
  int v535;
  float v536;
  float v537;
  float v538;
  void *v539;
  void *__b;
  float *v541;
  float v542;
  float v543;
  float32x4_t *__dst;
  uint64_t v545;
  float v546;
  float v547;
  float v548;
  float v549;
  float v550;
  float v551;
  float v552;
  float v553;
  float v554;
  float v555;
  float v556;
  float v557;
  float v558;
  float v559;
  float v560;
  float v561;
  float v562;
  float v563;
  float v564;
  float v565;
  float v566;
  float v567;
  float v568;
  float v569;
  float32x4_t v570;
  float v571;
  float v572;
  float v573;
  float v574;
  float v575;
  float v576;
  float v577;
  float v578;
  float v579;
  float v580;
  float v581;
  float v582;
  float v583;
  float v584;
  float *v585;
  _DWORD *v586;
  __int32 *v587;
  float *v588;
  void *__src;
  float v590;
  float v591;
  float v592;
  float v593;
  float v594;
  float v595;
  float v596;
  uint64_t v597;
  int v598;
  uint64_t v599;
  float *v600;
  uint64_t v601;
  unsigned int v602;
  int v603;
  int v604;
  int v605;
  int v606;
  float v607;
  float v608;
  float v609;
  float v610;
  float v611;
  float v612;
  float v613;
  float v614;
  float v615;
  _BYTE v616[1896];
  float v617;
  float v618;
  float v619;
  float v620;
  float v621;
  float v622;
  float v623;
  float v624;
  float v625;
  float v626;
  float v627;
  float v628;
  float v629;
  _QWORD v630[469];
  _BYTE v631[32];
  float v632;
  float v633;
  float v634;
  float v635;
  float v636;
  float v637;
  _BYTE v638[4];
  _BYTE v639[3836];
  float v640[32];
  float32x4_t v641;
  float32x4_t v642;
  float32x4_t v643;
  float32x4_t v644;
  float32x2_t v645;
  float v646;
  float32x4_t v647;
  float32x4_t v648;
  float32x4_t v649;
  float32x4_t v650;
  float32x2_t v651;
  float v652;
  float32x4_t v653;
  float32x4_t v654;
  float32x4_t v655;
  float32x4_t v656;
  float32x2_t v657;
  float v658;
  _BYTE v659[4];
  _BYTE v660[924];
  float v661;
  float v662;
  float v663;
  float v664;
  float v665;
  float v666;
  float v667;
  _DWORD v668[18];
  _BOOL4 v669;
  float v670[2];
  float32x4_t v671;
  float v672;
  float v673;
  float32x2_t v674;
  float v675;
  float32x2_t v676;
  float v677;
  float32x4_t v678;
  float v679;
  float v680;
  float v681;
  float v682;
  float v683;
  float v684;
  float v685;
  float v686;
  float v687;
  float v688;
  float v689;
  float v690;
  float v691;
  float v692;
  float v693;
  float v694;
  float v695;
  float v696;
  float v697;
  float v698;
  float v699;
  float v700;
  float v701;
  float v702;
  float v703;
  float v704[18];
  uint64_t v705;
  float32x4x2_t v706;
  float32x4x2_t v707;
  float32x4x2_t v708;
  float32x4x2_t v709;
  float32x4x2_t v710;
  float32x4x2_t v711;
  float32x4x2_t v712;
  float32x4x2_t v713;

  v12 = MEMORY[0x24BDAC7A8](a1, a2);
  v604 = v15;
  v603 = v16;
  v602 = v17;
  v599 = v18;
  v19 = v12;
  v705 = *MEMORY[0x24BDAC8D0];
  v601 = v20;
  if (!v20)
    goto LABEL_328;
  v535 = v14;
  v21 = v13 & 0xFFFFFFFE;
  if (95 * a9 / 50 < (int)(v13 & 0xFFFFFFFE))
    v21 = 95 * a9 / 50;
  v22 = *(unsigned int *)(v12 + 7440);
  v534 = v21;
  v23 = v21 - v22;
  if ((int)(v21 - v22) < 1)
    goto LABEL_327;
  v545 = v12 + 7228;
  v24 = a9 / 50;
  v25 = v12 + 2892;
  v600 = (float *)(v12 + 7592);
  __src = (void *)(v12 + 4812);
  v588 = (float *)(v12 + 3852);
  __b = (void *)(v12 + 7008);
  v539 = (void *)(v12 + 7080);
  if (a10 <= 8)
    v26 = 8;
  else
    v26 = a10;
  __dst = (float32x4_t *)(v12 + 7464);
  v587 = (__int32 *)(v12 + 4808);
  v542 = (float)((float)(0.00057 / (float)(1 << (v26 - 8))) * (float)(0.00057 / (float)(1 << (v26 - 8)))) * 3.0;
  v27 = 1.0;
  v541 = (float *)(v12 + 6500);
  v28 = 1.0 / (float)(1 << a10);
  v29 = 2.0;
  v30 = 0.25;
  v598 = a9 / 50;
  v543 = (float)(0.00057 / (float)(1 << (v26 - 8))) * (float)(0.00057 / (float)(1 << (v26 - 8)));
LABEL_11:
  while (2)
  {
    v605 = v23;
    if (v24 >= v23)
      v31 = v23;
    else
      v31 = v24;
    if (!*(_DWORD *)(v19 + 7460))
    {
      *(_DWORD *)(v19 + 5772) = 240;
      *(_DWORD *)(v19 + 7460) = 1;
    }
    v32 = *(_DWORD *)(v19 + 7436);
    if (v32 < 10)
      v33 = v32 + 1;
    else
      v33 = 10;
    if (v32 < 25)
      v34 = v32 + 1;
    else
      v34 = 25;
    if (v32 < 100)
      v35 = v32 + 1;
    else
      v35 = 100;
    v36 = *(_DWORD *)(v19 + 8);
    if (v36 == 16000)
    {
      v31 = 3 * v31 / 2;
      v39 = 3 * v22 + (3 * (int)v22 < 0);
LABEL_34:
      v37 = (v39 >> 1);
      goto LABEL_35;
    }
    v37 = v22;
    if (v36 == 48000)
    {
      if (v31 >= 0)
        v38 = v31;
      else
        v38 = v31 + 1;
      v31 = v38 >> 1;
      if ((int)v22 >= 0)
        v39 = v22;
      else
        v39 = v22 + 1;
      goto LABEL_34;
    }
LABEL_35:
    v606 = v22;
    v40 = *(unsigned int **)(v599 + 88);
    v41 = *(int *)(v19 + 5772);
    v42 = (float *)(v19 + 4 * v41 + 2892);
    v43 = 720 - v41;
    if (v31 >= v43)
      v44 = v43;
    else
      v44 = v31;
    v45 = downmix_and_resample(a11, v601, v42, v600, v44, v37, v602, v603, v604, v36) + *(float *)(v19 + 7456);
    *(float *)(v19 + 7456) = v45;
    v46 = *(_DWORD *)(v19 + 5772) + v31;
    if (v46 <= 719)
    {
      *(_DWORD *)(v19 + 5772) = v46;
      goto LABEL_10;
    }
    v590 = v45;
    v47 = 0;
    v594 = v27 / (float)v34;
    v592 = v27 - (float)(v27 / (float)v35);
    v48 = *(int *)(v19 + 7444);
    v49 = v48 - 99;
    if ((int)v48 <= 98)
      v49 = v48 + 1;
    *(_DWORD *)(v19 + 7444) = v49;
    v50 = 0.0;
    v51 = 0.0;
    do
    {
      v52 = *(float *)(v25 + v47);
      if (v51 <= v52)
        v51 = *(float *)(v25 + v47);
      if (v50 >= v52)
        v50 = *(float *)(v25 + v47);
      v47 += 4;
    }
    while (v47 != 2880);
    v596 = v27 / (float)v33;
    v53 = 0;
    v54 = -v50;
    if (v51 <= v54)
      v55 = v54;
    else
      v55 = v51;
    v56 = (__int32 *)(v19 + 2892);
    v57 = v587;
    v58 = 3832;
    do
    {
      v59 = analysis_window[v53];
      v60.i32[0] = *v56;
      v60.i32[1] = v56[240];
      *(float32x2_t *)&v638[8 * v53] = vmul_n_f32(v60, v59);
      v60.i32[0] = *v57;
      v60.i32[1] = v57[240];
      *(float32x2_t *)&v638[v58] = vmul_n_f32(v60, v59);
      ++v53;
      v58 -= 8;
      --v57;
      ++v56;
    }
    while (v53 != 240);
    v597 = v48;
    v61 = (_OWORD *)(v19 + (v48 << 6) + 7604);
    memmove((void *)(v19 + 2892), __src, 0x3C0uLL);
    v62 = *(_DWORD *)(v19 + 5772);
    v63 = v31 + v62 - 720;
    *(float *)(v19 + 7456) = downmix_and_resample(a11, v601, v588, v600, v63, (v37 - v62 + 720), v602, v603, v604, *(_DWORD *)(v19 + 8));
    *(_DWORD *)(v19 + 5772) = v63 + 240;
    if (v55 > v28)
    {
      v586 = v61;
      v64 = *v40;
      if ((int)v64 >= 1)
      {
        v65 = (const float *)(v40 + 1);
        v66 = (__int16 *)*((_QWORD *)v40 + 6);
        v67 = vld1_dup_f32(v65);
        v68 = (float32x2_t *)v638;
        do
        {
          v70 = *v66++;
          v69 = v70;
          v71 = *v68++;
          *((float32x2_t *)&v622 + v69) = vmul_f32(v67, v71);
          --v64;
        }
        while (v64);
      }
      opus_fft_impl((uint64_t)v40, &v622);
      v72 = v622;
      v73 = 0;
      v74 = &v625;
      v75 = &v637;
      do
      {
        v95 = *(v74 - 1);
        v96 = *(v75 - 1);
        v97 = v95 + v96;
        v98 = *v74 - *v75;
        v99 = v97 * v97;
        v100 = v98 * v98;
        v82 = 0.0;
        v101 = 0.0;
        if ((float)((float)(v97 * v97) + (float)(v98 * v98)) >= 1.0e-18)
        {
          if (v99 >= v100)
          {
            v104 = v97 * v98;
            v105 = (float)(v104 * (float)(v99 + (float)(v100 * 0.43158)))
                 / (float)((float)(v99 + (float)(v100 * 0.67848)) * (float)(v99 + (float)(v100 * 0.085955)));
            _NF = v98 < 0.0;
            v106 = 1.5708;
            if (_NF)
              v107 = -1.5708;
            else
              v107 = 1.5708;
            v108 = v107 + v105;
            if (v104 < 0.0)
              v106 = -1.5708;
            v101 = v108 - v106;
          }
          else
          {
            v102 = (float)((float)(v98 * v97) * (float)(v100 + (float)(v99 * 0.43158)))
                 / (float)((float)(v100 + (float)(v99 * 0.67848)) * (float)(v100 + (float)(v99 * 0.085955)));
            _NF = v98 < 0.0;
            v103 = 1.5708;
            if (_NF)
              v103 = -1.5708;
            v101 = v103 - v102;
          }
        }
        v109 = *v74 + *v75;
        v110 = v96 - v95;
        v111 = v109 * v109;
        v112 = v110 * v110;
        if ((float)((float)(v110 * v110) + (float)(v109 * v109)) >= 1.0e-18)
        {
          if (v111 >= v112)
          {
            v76 = v110 * v109;
            v77 = (float)(v76 * (float)(v111 + (float)(v112 * 0.43158)))
                / (float)((float)(v111 + (float)(v112 * 0.67848)) * (float)(v111 + (float)(v112 * 0.085955)));
            _NF = v110 < 0.0;
            v79 = 1.5708;
            if (_NF)
              v80 = -1.5708;
            else
              v80 = 1.5708;
            v81 = v80 + v77;
            if (v76 < 0.0)
              v79 = -1.5708;
            v82 = v81 - v79;
          }
          else
          {
            v113 = (float)((float)(v110 * v109) * (float)(v112 + (float)(v111 * 0.43158)))
                 / (float)((float)(v112 + (float)(v111 * 0.67848)) * (float)(v112 + (float)(v111 * 0.085955)));
            _NF = v110 < 0.0;
            v114 = 1.5708;
            if (_NF)
              v114 = -1.5708;
            v82 = v114 - v113;
          }
        }
        v83 = v101 * 0.15915;
        v84 = (float *)(v19 + v73);
        v85 = v83 - *(float *)(v19 + v73 + 16);
        v86 = v85 - *(float *)(v19 + v73 + 976);
        v87 = v82 * 0.15915;
        v88 = v87 - v83;
        v89 = (uint64_t)rintf(v86);
        v90 = v88 - v85;
        v91 = vabds_f32(v86, (float)v89);
        v92 = (float)(v86 - (float)v89) * (float)(v86 - (float)v89);
        v93 = (float)(uint64_t)rintf(v90);
        *(float *)&v616[v73 + 4] = v91 + vabds_f32(v90, v93);
        v94 = (float)((float)(v90 - v93) * (float)(v90 - v93)) * (float)((float)(v90 - v93) * (float)(v90 - v93));
        *(float *)&v616[v73 + 964] = (float)(v27
                                           / (float)(v27
                                                   + (float)((float)((float)((float)((float)(v92 * v92)
                                                                                   + *(float *)(v19 + v73 + 1936))
                                                                           + (float)(v94 * v29))
                                                                   * v30)
                                                           * 62342.0)))
                                   + -0.015;
        *(float *)&v659[v73] = (float)(v27 / (float)(v27 + (float)(v94 * 62342.0))) + -0.015;
        v84[4] = v87;
        v84[244] = v88;
        v84[484] = v94;
        v73 += 4;
        v75 -= 2;
        v74 += 2;
      }
      while (v73 != 956);
      v121 = 0;
      v122 = (const float *)v660;
      v123 = vld1q_dup_f32(v122);
      do
      {
        v124 = *(float32x4_t *)&v660[v121 + 4];
        v125 = (float32x4_t)vextq_s8((int8x16_t)v123, (int8x16_t)v124, 0xCuLL);
        v123 = *(float32x4_t *)&v660[v121 + 20];
        v126 = (float32x4_t)vextq_s8((int8x16_t)v124, (int8x16_t)v123, 0xCuLL);
        v127 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)&v659[v121], v124), *(int8x16_t *)&v659[v121], (int8x16_t)v124);
        v128 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)&v660[v121 + 12], v123), *(int8x16_t *)&v660[v121 + 12], (int8x16_t)v123);
        v129 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v128, v126), (int8x16_t)v126, (int8x16_t)v128);
        v130 = (float32x4_t *)&v616[v121 + 984];
        v131 = (float32x4_t)vdupq_n_s32(0xBDCCCCCD);
        v132 = vaddq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v127, v125), (int8x16_t)v125, (int8x16_t)v127), v131);
        v133 = vaddq_f32(v129, v131);
        v134 = (float32x4_t)vdupq_n_s32(0x3F666666u);
        v135 = vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)&v616[v121 + 984], v133), *(int8x16_t *)&v616[v121 + 984], (int8x16_t)v133), v134);
        v130[-1] = vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)&v616[v121 + 968], v132), *(int8x16_t *)&v616[v121 + 968], (int8x16_t)v132), v134);
        *v130 = v135;
        v121 += 32;
      }
      while (v121 != 928);
      v136 = v123.f32[3];
      v137 = v661;
      v138 = v663;
      if (v661 <= v663)
        v137 = v663;
      if (v123.f32[3] >= v137)
        v136 = v137;
      v139 = v136 + -0.1;
      if (v617 > v139)
        v139 = v617;
      v617 = v139 * 0.9;
      v140 = v662;
      v141 = v664;
      if (v662 <= v664)
        v140 = v664;
      if (v663 < v140)
        v140 = v663;
      v142 = v140 + -0.1;
      if (v618 > v142)
        v142 = v618;
      v618 = v142 * 0.9;
      v143 = v665;
      if (v663 <= v665)
        v138 = v665;
      if (v664 < v138)
        v138 = v664;
      v144 = v138 + -0.1;
      if (v619 > v144)
        v144 = v619;
      v619 = v144 * 0.9;
      if (v664 <= v666)
        v141 = v666;
      if (v665 < v141)
        v141 = v665;
      v145 = v141 + -0.1;
      if (v620 > v145)
        v145 = v620;
      v620 = v145 * 0.9;
      if (v665 <= v667)
        v143 = v667;
      if (v666 < v143)
        v143 = v666;
      v146 = v143 + -0.1;
      if (v621 > v146)
        v146 = v621;
      v621 = v146 * 0.9;
      v147 = v19 + (v597 << 6);
      *(_DWORD *)(v147 + 7620) = 0;
      v148 = *(_DWORD *)(v19 + 7436);
      v149 = 7.5;
      if (!v148)
      {
        memset_pattern16(__b, &unk_208F314C0, 0x48uLL);
        memset_pattern16(v539, &unk_208F314D0, 0x48uLL);
      }
      v585 = (float *)(v147 + 7620);
      v150 = 0;
      v151 = log((float)((float)((float)((float)((float)((float)((float)(v623 + v623) * (float)(v623 + v623))
                                                       + (float)((float)(v72 + v72) * (float)(v72 + v72)))
                                               + (float)((float)((float)((float)(v636 * v636) + (float)(v624 * v624))
                                                               + (float)(v625 * v625))
                                                       + (float)(v637 * v637)))
                                       + (float)((float)((float)((float)(v634 * v634) + (float)(v626 * v626))
                                                       + (float)(v627 * v627))
                                               + (float)(v635 * v635)))
                               + (float)((float)((float)((float)(v632 * v632) + (float)(v628 * v628))
                                               + (float)(v629 * v629))
                                       + (float)(v633 * v633)))
                       + 1.0e-10));
      v152 = 0.0;
      v583 = v151 * 0.72135;
      v653.f32[0] = v151 * 0.72135;
      LODWORD(v153) = 4;
      v154 = 0.0;
      v155 = 0.0;
      v613 = 0.0;
      v615 = 0.0;
      v156 = 0.0;
      v611 = 0.0;
      while (1)
      {
        v607 = v156;
        v609 = v155;
        v158 = v150 + 1;
        v159 = *((_DWORD *)&tbands + v150 + 1);
        v160 = 0.0;
        v161 = 0.0;
        v162 = 0.0;
        v163 = 0.5;
        if ((int)v153 >= v159)
          goto LABEL_131;
        v164 = (int)v153;
        v165 = v159 - (uint64_t)(int)v153;
        if (v165 >= 8)
        {
          v153 = (v165 & 0xFFFFFFFFFFFFFFF8) + (int)v153;
          v166 = (const float *)&v631[-8 * v164];
          v167 = (const float *)&v630[v164];
          v168 = 4 * v164;
          v169 = (float32x4_t *)&v616[4 * v164 + 16];
          v170 = (int8x16_t *)&v616[v168 + 976];
          v171 = v165 & 0xFFFFFFFFFFFFFFF8;
          v172.i64[0] = 0x3F0000003F000000;
          v172.i64[1] = 0x3F0000003F000000;
          do
          {
            v707 = vld2q_f32(v167);
            v173 = v167 - 8;
            v708 = vld2q_f32(v173);
            v174 = v166;
            v709 = vld2q_f32(v174);
            v174 += 8;
            v706 = vld2q_f32(v174);
            v175 = (int8x16_t)vrev64q_s32((int32x4_t)v706.val[1]);
            v176 = (int8x16_t)vrev64q_s32((int32x4_t)v709.val[1]);
            v177 = (float32x4_t)vextq_s8(v176, v176, 8uLL);
            v706.val[0] = (float32x4_t)vrev64q_s32((int32x4_t)vmulq_f32(v706.val[0], v706.val[0]));
            v706.val[1] = (float32x4_t)vextq_s8((int8x16_t)v706.val[0], (int8x16_t)v706.val[0], 8uLL);
            v178 = (float32x4_t)vextq_s8(v175, v175, 8uLL);
            v706.val[0] = (float32x4_t)vrev64q_s32((int32x4_t)vmulq_f32(v709.val[0], v709.val[0]));
            v706.val[1] = vmlaq_f32(vmlaq_f32(vmlaq_f32(v706.val[1], v708.val[0], v708.val[0]), v708.val[1], v708.val[1]), v178, v178);
            v706.val[0] = vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vextq_s8((int8x16_t)v706.val[0], (int8x16_t)v706.val[0], 8uLL), v707.val[0], v707.val[0]), v707.val[1], v707.val[1]), v177, v177);
            v709.val[1] = vmulq_f32(v706.val[1], (float32x4_t)vbicq_s8(v170[-1], (int8x16_t)vcltzq_f32((float32x4_t)v170[-1])));
            v179 = vmulq_f32(v706.val[0], (float32x4_t)vbicq_s8(*v170, (int8x16_t)vcltzq_f32(*(float32x4_t *)v170)));
            v180 = vmulq_f32(vaddq_f32(v706.val[1], v706.val[1]), vsubq_f32(v172, v169[-1]));
            v181 = vmulq_f32(vaddq_f32(v706.val[0], v706.val[0]), vsubq_f32(v172, *v169));
            v161 = (float)((float)((float)((float)((float)((float)((float)(v161 + v709.val[1].f32[0])
                                                                 + v709.val[1].f32[1])
                                                         + v709.val[1].f32[2])
                                                 + v709.val[1].f32[3])
                                         + v179.f32[0])
                                 + v179.f32[1])
                         + v179.f32[2])
                 + v179.f32[3];
            v162 = (float)((float)((float)((float)((float)((float)((float)(v162 + v180.f32[0]) + v180.f32[1])
                                                         + v180.f32[2])
                                                 + v180.f32[3])
                                         + v181.f32[0])
                                 + v181.f32[1])
                         + v181.f32[2])
                 + v181.f32[3];
            v166 -= 16;
            v160 = (float)((float)((float)((float)((float)((float)((float)(v160 + v706.val[1].f32[0])
                                                                 + v706.val[1].f32[1])
                                                         + v706.val[1].f32[2])
                                                 + v706.val[1].f32[3])
                                         + v706.val[0].f32[0])
                                 + v706.val[0].f32[1])
                         + v706.val[0].f32[2])
                 + v706.val[0].f32[3];
            v167 += 16;
            v169 += 2;
            v170 += 2;
            v171 -= 8;
          }
          while (v171);
          v163 = 0.5;
          v149 = 7.5;
          if (v165 == (v165 & 0xFFFFFFFFFFFFFFF8))
            goto LABEL_131;
        }
        else
        {
          v153 = (int)v153;
        }
        v182 = v159 - v153;
        v183 = (float *)&v616[4 * v153];
        v184 = (float *)&v616[4 * v153 + 960];
        v185 = 8 * v153;
        v186 = &v623 + 2 * v153;
        v187 = (float *)&v639[-v185];
        do
        {
          v188 = (float)(*(v187 - 1) * *(v187 - 1)) + (float)(*(v186 - 1) * *(v186 - 1));
          v189 = *v186;
          v186 += 2;
          v190 = v188 + (float)(v189 * v189);
          v191 = *v187;
          v187 -= 2;
          v192 = v190 + (float)(v191 * v191);
          v193 = *v184++;
          v194 = v193;
          v160 = v160 + v192;
          if (v193 < 0.0)
            v194 = 0.0;
          v161 = v161 + (float)(v192 * v194);
          v195 = *v183++;
          v162 = v162 + (float)((float)(v192 + v192) * (float)(v163 - v195));
          --v182;
        }
        while (v182);
LABEL_131:
        if (v160 >= 1000000000.0)
        {
          *v586 = 0;
          v231 = v606;
          v232 = v605;
          v24 = a9 / 50;
          goto LABEL_325;
        }
        v196 = 4 * v150;
        v197 = v19 + 72 * *(int *)(v19 + 7432) + 4 * v150;
        *(float *)(v197 + 5856) = v160;
        v198 = log((float)(v160 + 1.0e-10));
        *(&v688 + v150) = v198;
        v653.f32[v158] = v198 * 0.72135;
        *(float *)(v197 + 6432) = v198;
        v199 = v19 + 4 * v150;
        if (v148)
        {
          v200 = *(float *)(v199 + 7080);
          v201 = *(float *)(v199 + 7008);
        }
        else
        {
          *(float *)(v199 + 7008) = v198;
          *(float *)(v199 + 7080) = v198;
          v201 = v198;
          v200 = v198;
        }
        v202 = v19 + 4 * v150;
        v203 = (float *)(v202 + 7080);
        v204 = (float *)(v202 + 7008);
        if (v201 + v149 >= v200)
          goto LABEL_138;
        if ((float)(v200 - v198) > (float)(v198 - v201))
        {
          v200 = v200 + -0.01;
          *v203 = v200;
LABEL_138:
          if (v200 >= v198)
            goto LABEL_143;
          goto LABEL_139;
        }
        v201 = v201 + 0.01;
        *v204 = v201;
        if (v200 >= v198)
        {
LABEL_143:
          if (v201 > v198)
          {
            *v204 = v198;
            if ((float)(v198 + 15.0) < v200)
              v200 = v198 + 15.0;
            *v203 = v200;
            v201 = v198;
          }
          goto LABEL_147;
        }
LABEL_139:
        *v203 = v198;
        if ((float)(v198 + -15.0) > v201)
          v201 = v198 + -15.0;
        *v204 = v201;
        v200 = v198;
LABEL_147:
        v205 = v160 + 1.0e-15;
        v206 = v19 + v196;
        v207 = *(float *)(v19 + v196 + 5856);
        v208 = *(float *)(v19 + v196 + 5928);
        v209 = (float)(sqrtf(v207) + 0.0) + sqrtf(v208);
        v210 = (float)(v207 + 0.0) + v208;
        v211 = *(float *)(v19 + v196 + 6000);
        v212 = v209 + sqrtf(v211);
        v213 = v210 + v211;
        v214 = *(float *)(v19 + v196 + 6072);
        v215 = v212 + sqrtf(v214);
        v216 = v213 + v214;
        v217 = *(float *)(v19 + v196 + 6144);
        v218 = v215 + sqrtf(v217);
        v219 = v216 + v217;
        v220 = *(float *)(v19 + v196 + 6216);
        v221 = v218 + sqrtf(v220);
        v222 = v219 + v220;
        v223 = *(float *)(v19 + v196 + 6288);
        v224 = v221 + sqrtf(v223);
        v225 = v222 + v223;
        v226 = *(float *)(v19 + v196 + 6360);
        v227 = sqrt((float)((float)(v225 + v226) * 8.0) + 1.0e-15);
        v228 = (float)(v224 + sqrtf(v226)) / v227;
        if (v228 > 0.99)
          v228 = 0.99;
        v229 = (float)(v228 * v228) * (float)(v228 * v228);
        v230 = v161 / v205;
        if ((float)(v161 / v205) <= (float)(*(float *)(v206 + 5776) * v229))
          v230 = *(float *)(v206 + 5776) * v229;
        v704[v150] = v230;
        v152 = v152 + v230;
        if (v150 >= 9)
          v152 = v152 - v704[(v150 - 9)];
        v155 = v609 + (float)(v162 / v205);
        v611 = v611 + sqrtf(v160 + 1.0e-10);
        v156 = v607 + (float)((float)(v198 - v201) / (float)((float)(v200 - v201) + 0.00001));
        v615 = v615 + v229;
        v157 = (float *)(v206 + 5776);
        v27 = 1.0;
        if (v154 <= (float)((float)((float)((float)((int)v150 - 18) * 0.03) + 1.0) * v152))
          v154 = (float)((float)((float)((int)v150 - 18) * 0.03) + 1.0) * v152;
        v613 = v613 + (float)(v230 * (float)((int)v150 - 8));
        *v157 = v230;
        LODWORD(v153) = v159;
        ++v150;
        if (v158 == 18)
        {
          v233 = v583 + -2.5;
          v234 = 1u;
          v235 = v583 + -2.5;
          v236 = v583;
          v237 = 4;
          do
          {
            v238 = *(_DWORD *)((char *)&tbands + v234 * 4);
            v239 = (float)((float)(v238 - v237) + (float)(v238 - v237)) * 0.25;
            v236 = v236 + v239;
            v240 = v653.f32[v234];
            if (v236 >= v240)
              v236 = v653.f32[v234];
            v647.f32[v234] = v236;
            v235 = v235 - v239;
            if (v235 <= (float)(v240 + -2.5))
              v235 = v240 + -2.5;
            v641.f32[v234++] = v235;
            v237 = v238;
          }
          while (v234 != 19);
          v241 = 0;
          v242 = v652;
          v243 = v651.f32[0];
          if ((float)(v651.f32[1] + 16.0) < v651.f32[0])
            v243 = v651.f32[1] + 16.0;
          v651.f32[0] = v243;
          v244 = v646;
          v245 = v645.f32[1] + -16.0;
          if ((float)(v645.f32[1] + -16.0) <= v645.f32[0])
            v245 = v645.f32[0];
          v645.f32[0] = v245;
          v246 = v243 + 12.0;
          if (v246 >= v650.f32[3])
            v246 = v650.f32[3];
          v247 = v245 + -12.0;
          if ((float)(v245 + -12.0) <= v644.f32[3])
            v247 = v644.f32[3];
          v248 = v246 + 12.0;
          if ((float)(v246 + 12.0) >= v650.f32[2])
            v248 = v650.f32[2];
          v650.i64[1] = __PAIR64__(LODWORD(v246), LODWORD(v248));
          v249 = v247 + -12.0;
          if ((float)(v247 + -12.0) <= v644.f32[2])
            v249 = v644.f32[2];
          v644.i64[1] = __PAIR64__(LODWORD(v247), LODWORD(v249));
          v250 = v248 + 8.0;
          if ((float)(v248 + 8.0) >= v650.f32[1])
            v250 = v650.f32[1];
          v251 = v249 + -8.0;
          if (v251 <= v644.f32[1])
            v251 = v644.f32[1];
          v252 = v250 + 8.0;
          if ((float)(v250 + 8.0) >= v650.f32[0])
            v252 = v650.f32[0];
          v650.i64[0] = __PAIR64__(LODWORD(v250), LODWORD(v252));
          v253 = v251 + -8.0;
          if ((float)(v251 + -8.0) <= v644.f32[0])
            v253 = v644.f32[0];
          v644.i64[0] = __PAIR64__(LODWORD(v251), LODWORD(v253));
          v254 = v252 + 8.0;
          if ((float)(v252 + 8.0) >= v649.f32[3])
            v254 = v649.f32[3];
          v255 = v253 + -8.0;
          if (v255 <= v643.f32[3])
            v255 = v643.f32[3];
          v256 = v254 + 4.0;
          if ((float)(v254 + 4.0) >= v649.f32[2])
            v256 = v649.f32[2];
          v649.i64[1] = __PAIR64__(LODWORD(v254), LODWORD(v256));
          v257 = v255 + -4.0;
          if ((float)(v255 + -4.0) <= v643.f32[2])
            v257 = v643.f32[2];
          v643.i64[1] = __PAIR64__(LODWORD(v255), LODWORD(v257));
          v258 = v256 + 4.0;
          if ((float)(v256 + 4.0) >= v649.f32[1])
            v258 = v649.f32[1];
          v259 = v257 + -4.0;
          if (v259 <= v643.f32[1])
            v259 = v643.f32[1];
          v260 = v258 + 4.0;
          if ((float)(v258 + 4.0) >= v649.f32[0])
            v260 = v649.f32[0];
          v649.i64[0] = __PAIR64__(LODWORD(v258), LODWORD(v260));
          v261 = v259 + -4.0;
          if ((float)(v259 + -4.0) <= v643.f32[0])
            v261 = v643.f32[0];
          v643.i64[0] = __PAIR64__(LODWORD(v259), LODWORD(v261));
          v262 = v260 + 4.0;
          if ((float)(v260 + 4.0) >= v648.f32[3])
            v262 = v648.f32[3];
          v263 = v261 + -4.0;
          if (v263 <= v642.f32[3])
            v263 = v642.f32[3];
          v264 = v262 + 2.0;
          if ((float)(v262 + 2.0) >= v648.f32[2])
            v264 = v648.f32[2];
          v648.i64[1] = __PAIR64__(LODWORD(v262), LODWORD(v264));
          v265 = v263 + -2.0;
          if ((float)(v263 + -2.0) <= v642.f32[2])
            v265 = v642.f32[2];
          v642.i64[1] = __PAIR64__(LODWORD(v263), LODWORD(v265));
          v266 = v264 + 2.0;
          if ((float)(v264 + 2.0) >= v648.f32[1])
            v266 = v648.f32[1];
          v267 = v265 + -2.0;
          if (v267 <= v642.f32[1])
            v267 = v642.f32[1];
          v268 = v266 + 2.0;
          if ((float)(v266 + 2.0) >= v648.f32[0])
            v268 = v648.f32[0];
          v648.i64[0] = __PAIR64__(LODWORD(v266), LODWORD(v268));
          v269 = v267 + -2.0;
          if ((float)(v267 + -2.0) <= v642.f32[0])
            v269 = v642.f32[0];
          v642.i64[0] = __PAIR64__(LODWORD(v267), LODWORD(v269));
          v270 = v268 + 2.0;
          if ((float)(v268 + 2.0) >= v647.f32[3])
            v270 = v647.f32[3];
          v271 = v269 + -2.0;
          if (v271 <= v641.f32[3])
            v271 = v641.f32[3];
          v272 = v270 + 2.0;
          if ((float)(v270 + 2.0) >= v647.f32[2])
            v272 = v647.f32[2];
          v647.i64[1] = __PAIR64__(LODWORD(v270), LODWORD(v272));
          v273 = v271 + -2.0;
          if ((float)(v271 + -2.0) <= v641.f32[2])
            v273 = v641.f32[2];
          v641.i64[1] = __PAIR64__(LODWORD(v271), LODWORD(v273));
          v274 = v272 + 2.0;
          if ((float)(v272 + 2.0) >= v647.f32[1])
            v274 = v647.f32[1];
          v275 = v273 + -2.0;
          if (v275 <= v641.f32[1])
            v275 = v641.f32[1];
          v276 = v274 + 2.0;
          if ((float)(v274 + 2.0) >= v583)
            v276 = v583;
          v647.i64[0] = __PAIR64__(LODWORD(v274), LODWORD(v276));
          if ((float)(v275 + -2.0) > v233)
            v233 = v275 + -2.0;
          v641.i64[0] = __PAIR64__(LODWORD(v275), LODWORD(v233));
          v277 = v654;
          v278 = vsubq_f32(v643, v655);
          v279 = vsubq_f32(v644, v656);
          v280 = vsubq_f32(v641, v653);
          v281 = vsubq_f32(v642, v654);
          __asm { FMOV            V22.4S, #2.5 }
          v285 = vaddq_f32(v648, _Q22);
          v286 = vsubq_f32(v655, vaddq_f32(v649, _Q22));
          v287 = vsubq_f32(v656, vaddq_f32(v650, _Q22));
          v288 = vsubq_f32(v653, vaddq_f32(v647, _Q22));
          v289 = vsub_f32(v645, v657);
          __asm { FMOV            V22.2S, #2.5 }
          v290 = vsub_f32(v657, vadd_f32(v651, *(float32x2_t *)_Q22.f32));
          v291 = (float32x4_t)vdupq_n_s32(0x42800000u);
          v292 = vadd_f32((float32x2_t)vbic_s8((int8x8_t)v289, (int8x8_t)vcltz_f32(v289)), (float32x2_t)vbic_s8((int8x8_t)v290, (int8x8_t)vcltz_f32(v290)));
          __asm { FMOV            V19.2D, #0.5 }
          v294 = vmin_s32(vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32(v292, *(float32x2_t *)v291.f32)), _Q19)))), (int32x2_t)0xFF000000FFLL);
          v295 = (int8x16_t *)(v19 + (v597 << 6));
          v295[479].i8[1] = v294.i8[4];
          v295[479].i8[0] = v294.i8[0];
          v296 = vsubq_f32(v277, v285);
          v297 = vmulq_f32(vaddq_f32((float32x4_t)vbicq_s8((int8x16_t)v278, (int8x16_t)vcltzq_f32(v278)), (float32x4_t)vbicq_s8((int8x16_t)v286, (int8x16_t)vcltzq_f32(v286))), v291);
          v298 = vmulq_f32(vaddq_f32((float32x4_t)vbicq_s8((int8x16_t)v279, (int8x16_t)vcltzq_f32(v279)), (float32x4_t)vbicq_s8((int8x16_t)v287, (int8x16_t)vcltzq_f32(v287))), v291);
          v299 = vmulq_f32(vaddq_f32((float32x4_t)vbicq_s8((int8x16_t)v280, (int8x16_t)vcltzq_f32(v280)), (float32x4_t)vbicq_s8((int8x16_t)v288, (int8x16_t)vcltzq_f32(v288))), v291);
          v300 = vmulq_f32(vaddq_f32((float32x4_t)vbicq_s8((int8x16_t)v281, (int8x16_t)vcltzq_f32(v281)), (float32x4_t)vbicq_s8((int8x16_t)v296, (int8x16_t)vcltzq_f32(v296))), v291);
          v296.i64[0] = 0xFF000000FFLL;
          v296.i64[1] = 0xFF000000FFLL;
          v295[478] = vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vminq_s32(vuzp1q_s32((int32x4_t)vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v299.f32), _Q19))), (int32x4_t)vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vcvt_hight_f64_f32(v299), _Q19)))), (int32x4_t)v296), (int16x8_t)vminq_s32(vuzp1q_s32((int32x4_t)vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v300.f32), _Q19))), (int32x4_t)vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vcvt_hight_f64_f32(v300), _Q19)))), (int32x4_t)v296)),
                        (int8x16_t)vuzp1q_s16((int16x8_t)vminq_s32(vuzp1q_s32((int32x4_t)vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v297.f32), _Q19))), (int32x4_t)vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vcvt_hight_f64_f32(v297), _Q19)))), (int32x4_t)v296), (int16x8_t)vminq_s32(vuzp1q_s32((int32x4_t)vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v298.f32), _Q19))), (int32x4_t)vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vcvt_hight_f64_f32(v298), _Q19)))), (int32x4_t)v296)));
          v301 = v244 - v658;
          v302 = 0.0;
          if (v301 < 0.0)
            v301 = 0.0;
          v303 = v658 - (float)(v242 + 2.5);
          if (v303 < 0.0)
            v303 = 0.0;
          v304 = vcvtmd_s64_f64((float)((float)(v301 + v303) * 64.0) + 0.5);
          if (v304 >= 255)
            LOBYTE(v304) = -1;
          v295[479].i8[2] = v304;
          do
          {
            v305 = 0;
            v306 = 1.0e15;
            v307 = (float *)(v19 + 72 * v241);
            v308 = v307[1611];
            v309 = v307[1612];
            v310 = v307[1613];
            v311 = v307[1614];
            v312 = v307[1615];
            v313 = v307[1616];
            v314 = v307[1617];
            v315 = v307[1618];
            v316 = v307[1619];
            v317 = v307[1620];
            v318 = v307[1621];
            v319 = v307[1622];
            v320 = v307[1623];
            v321 = v307[1624];
            v322 = v307[1625];
            v323 = v307[1608];
            v324 = v307[1609];
            v325 = v307[1610];
            v326 = v541;
            do
            {
              v327 = *(v326 - 2);
              v328 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v323 - *(v326 - 17)) * (float)(v323 - *(v326 - 17))) + 0.0) + (float)((float)(v324 - *(v326 - 16)) * (float)(v324 - *(v326 - 16)))) + (float)((float)(v325 - *(v326 - 15)) * (float)(v325 - *(v326 - 15)))) + (float)((float)(v308 - *(v326 - 14)) * (float)(v308 - *(v326 - 14)))) + (float)((float)(v309 - *(v326 - 13)) * (float)(v309 - *(v326 - 13)))) + (float)((float)(v310 - *(v326 - 12)) * (float)(v310 - *(v326 - 12))))
                                                                                           + (float)((float)(v311 - *(v326 - 11)) * (float)(v311 - *(v326 - 11))))
                                                                                   + (float)((float)(v312 - *(v326 - 10))
                                                                                           * (float)(v312 - *(v326 - 10))))
                                                                           + (float)((float)(v313 - *(v326 - 9))
                                                                                   * (float)(v313 - *(v326 - 9))))
                                                                   + (float)((float)(v314 - *(v326 - 8))
                                                                           * (float)(v314 - *(v326 - 8))))
                                                           + (float)((float)(v315 - *(v326 - 7))
                                                                   * (float)(v315 - *(v326 - 7))))
                                                   + (float)((float)(v316 - *(v326 - 6)) * (float)(v316 - *(v326 - 6))))
                                           + (float)((float)(v317 - *(v326 - 5)) * (float)(v317 - *(v326 - 5))))
                                   + (float)((float)(v318 - *(v326 - 4)) * (float)(v318 - *(v326 - 4))))
                           + (float)((float)(v319 - *(v326 - 3)) * (float)(v319 - *(v326 - 3))))
                   + (float)((float)(v320 - v327) * (float)(v320 - v327));
              v329 = v328 + (float)((float)(v321 - *(v326 - 1)) * (float)(v321 - *(v326 - 1)));
              v330 = *v326;
              v326 += 18;
              v331 = v329 + (float)((float)(v322 - v330) * (float)(v322 - v330));
              if (v306 >= v331 && v241 != v305)
                v306 = v331;
              ++v305;
            }
            while (v305 != 8);
            v302 = v302 + v306;
            ++v241;
          }
          while (v241 != 8);
          v333 = 0;
          v334 = 0;
          v335 = 0.0;
          if (v32 >= 2)
            v336 = v592;
          else
            v336 = 0.0;
          v337 = *(int *)(v19 + 5852);
          v338 = 4;
          v339 = 0.0;
          v340 = 0.0;
          v341 = 0.0;
          while (2)
          {
            v343 = v333 + 1;
            v344 = *((_DWORD *)&tbands + v333 + 1);
            v345 = 0.0;
            if (v344 > v338)
            {
              v346 = v344 - (uint64_t)v338;
              if (v346 < 8)
              {
                v347 = v338;
                goto LABEL_258;
              }
              v347 = (v346 & 0xFFFFFFFFFFFFFFF8) + v338;
              v348 = (const float *)&v631[-8 * v338];
              v349 = (const float *)&v630[v338];
              v350 = v346 & 0xFFFFFFFFFFFFFFF8;
              do
              {
                v351 = v349 - 8;
                v710 = vld2q_f32(v351);
                v711 = vld2q_f32(v349);
                v352 = v348;
                v712 = vld2q_f32(v352);
                v352 += 8;
                v713 = vld2q_f32(v352);
                v353 = (int8x16_t)vrev64q_s32((int32x4_t)v713.val[1]);
                v354 = (float32x4_t)vextq_s8(v353, v353, 8uLL);
                v355 = (int8x16_t)vrev64q_s32((int32x4_t)v712.val[1]);
                v356 = (float32x4_t)vextq_s8(v355, v355, 8uLL);
                v713.val[0] = (float32x4_t)vrev64q_s32((int32x4_t)vmulq_f32(v713.val[0], v713.val[0]));
                v712.val[0] = (float32x4_t)vrev64q_s32((int32x4_t)vmulq_f32(v712.val[0], v712.val[0]));
                v713.val[0] = vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vextq_s8((int8x16_t)v713.val[0], (int8x16_t)v713.val[0], 8uLL), v710.val[0], v710.val[0]), v710.val[1], v710.val[1]), v354, v354);
                v712.val[0] = vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vextq_s8((int8x16_t)v712.val[0], (int8x16_t)v712.val[0], 8uLL), v711.val[0], v711.val[0]), v711.val[1], v711.val[1]), v356, v356);
                v345 = (float)((float)((float)((float)((float)((float)((float)(v345 + v713.val[0].f32[0])
                                                                     + v713.val[0].f32[1])
                                                             + v713.val[0].f32[2])
                                                     + v713.val[0].f32[3])
                                             + v712.val[0].f32[0])
                                     + v712.val[0].f32[1])
                             + v712.val[0].f32[2])
                     + v712.val[0].f32[3];
                v348 -= 16;
                v349 += 16;
                v350 -= 8;
              }
              while (v350);
              if (v346 != (v346 & 0xFFFFFFFFFFFFFFF8))
              {
LABEL_258:
                v357 = v344 - v347;
                v358 = 8 * v347;
                v359 = &v623 + 2 * v347;
                v360 = (float *)&v639[-v358];
                do
                {
                  v361 = (float)(*(v360 - 1) * *(v360 - 1)) + (float)(*(v359 - 1) * *(v359 - 1));
                  v362 = *v359;
                  v359 += 2;
                  v363 = v361 + (float)(v362 * v362);
                  v364 = *v360;
                  v360 -= 2;
                  v345 = v345 + (float)(v363 + (float)(v364 * v364));
                  --v357;
                }
                while (v357);
              }
            }
            if (v340 <= v345)
              v340 = v345;
            if (v333 >= 0xB)
              v365 = -0.0;
            else
              v365 = v345;
            if (v333 >= 0xB)
              v366 = v345;
            else
              v366 = -0.0;
            v367 = v19 + 4 * v333;
            v368 = v336 * *(float *)(v367 + 7152);
            if (v368 <= v345)
              v368 = v345;
            *(float *)(v367 + 7152) = v368;
            if ((float)(v345 * 1000000000.0) > v340)
            {
              v369 = (float)(v344 - v338);
              if (v345 > v368)
                v368 = v345;
              if (v345 > (float)(v543 * v369) || v368 > (float)(v542 * v369))
                v334 = v333 + 1;
            }
            v339 = v339 + v365;
            v335 = v335 + v366;
            v342 = 0.01;
            if ((uint64_t)v333 >= v337)
              v342 = 0.05;
            v668[v333] = v345 < (float)(v342 * v341);
            v341 = v341 * 0.05;
            if (v341 <= v345)
              v341 = v345;
            v338 = v344;
            ++v333;
            if (v343 != 18)
              continue;
            break;
          }
          if (*(_DWORD *)(v19 + 8) == 48000)
          {
            v371 = v590 * 0.00027778;
            v372 = 30.0;
            if ((_DWORD)v337 == 20)
              v372 = 10.0;
            v373 = v336 * *(float *)(v19 + 7224);
            if (v373 <= v371)
              v373 = v590 * 0.00027778;
            *(float *)(v19 + 7224) = v373;
            if (v371 > v373)
              v373 = v590 * 0.00027778;
            if (v373 > (float)((float)(v543 * (float)(v372 * 3.0)) * 160.0)
              || v371 > (float)((float)(v543 * v372) * 160.0))
            {
              v334 = 20;
            }
            v335 = v371 + v335;
            v375 = 0.05;
            if ((_DWORD)v337 == 20)
              v375 = 0.01;
            v376 = v371 < (float)(v375 * v341);
            v669 = v376;
          }
          else
          {
            v376 = v669;
          }
          if (v335 <= v339)
            v377 = 1.0;
          else
            v377 = v339 / v335;
          *(float *)(v19 + (v597 << 6) + 7644) = v377;
          if (v334 == 20 && v376)
          {
            v334 = 18;
          }
          else if ((v334 - 1) <= 0x11 && v668[v334 - 1])
          {
            --v334;
          }
          v378 = v302 * 0.125;
          v379 = *(_DWORD *)(v19 + 7436);
          v380 = v611;
          v612 = v378 / 18.0;
          v381 = log10(v380);
          v382 = v381 * 20.0;
          if ((float)(*(float *)(v19 + 7424) + -0.003) <= v382)
            v383 = v382;
          else
            v383 = *(float *)(v19 + 7424) + -0.003;
          v546 = *(float *)(v19 + 7036);
          v571 = *(float *)(v19 + 7100);
          v572 = v688;
          v573 = v689;
          v574 = v690;
          v575 = v691;
          v576 = v692;
          v577 = v693;
          v578 = v694;
          v579 = v695;
          v580 = v696;
          v581 = v697;
          v582 = v698;
          v584 = v699;
          v591 = v700;
          v610 = v701;
          v608 = v702;
          v593 = v703;
          v384 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)0, (float32x4_t)xmmword_208F31300, v688), (float32x4_t)xmmword_208F31310, v689), (float32x4_t)xmmword_208F31320, v690),
                                           (float32x4_t)xmmword_208F31330,
                                           v691),
                                         (float32x4_t)xmmword_208F31340,
                                         v692),
                                       (float32x4_t)xmmword_208F31350,
                                       v693),
                                     (float32x4_t)xmmword_208F31400,
                                     v694),
                                   (float32x4_t)xmmword_208F31410,
                                   v695),
                                 (float32x4_t)xmmword_208F31420,
                                 v696),
                               (float32x4_t)xmmword_208F31430,
                               v697),
                             (float32x4_t)xmmword_208F31440,
                             v698),
                           (float32x4_t)xmmword_208F31450,
                           v699),
                         (float32x4_t)xmmword_208F31460,
                         v700),
                       (float32x4_t)xmmword_208F31470,
                       v701),
                     (float32x4_t)xmmword_208F31480,
                     v702),
                   (float32x4_t)xmmword_208F31490,
                   v703);
          v385 = v19 + (v597 << 6);
          *(float *)(v385 + 7612) = v613 * 0.015625;
          v386 = *(float *)(v19 + 7324);
          v387 = *(float *)(v19 + 7228);
          v388 = *(float *)(v19 + 7292);
          v389 = *(float *)(v19 + 7232);
          v390 = (float)((float)(v387 - v388) * 0.31623) + (float)((float)(v384.f32[0] - v386) * 0.63246);
          v391 = *(float *)(v19 + 7296);
          v392 = *(float *)(v19 + 7328);
          v393 = (float)((float)(v389 - v391) * 0.31623) + (float)((float)(v384.f32[1] - v392) * 0.63246);
          if (v382 >= (float)(v383 + -30.0))
            v394 = -0.0;
          else
            v394 = v594;
          v395 = (float)((float)(1.0 - v594) * *(float *)(v19 + 7428)) + v394;
          if (v379 < 3)
            v334 = 20;
          v396 = v156 / 18.0;
          if (v379 < 10)
            v396 = 0.5;
          v614 = v155 / 18.0;
          v595 = (float)((float)(1.0 - v594) * *(float *)(v19 + 7428)) + v394;
          *(float *)(v19 + 7428) = v395;
          v397 = *(float *)(v19 + 7108);
          v398 = *(float *)(v19 + 7044);
          *v585 = (float)(v155 / 18.0) + (float)((float)(1.0 - (float)(v155 / 18.0)) * v396);
          v399 = *(float32x2_t *)(v545 + 8);
          v400 = *(float32x2_t *)(v545 + 72);
          v401 = *(float32x2_t *)(v545 + 104);
          v402 = (float32x2_t)vdup_n_s32(0x3F21E8E6u);
          v403 = vmla_f32(vmul_f32(vsub_f32(v399, v400), (float32x2_t)vdup_n_s32(0x3EA1E8E6u)), v402, vsub_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v384, (int8x16_t)v384, 8uLL), v401));
          *(float *)(v19 + 7424) = v383;
          v404 = *(float *)(v19 + 5848) * 0.8;
          if ((float)(v154 / 9.0) > v404)
            v404 = v154 / 9.0;
          *(float *)(v19 + 5848) = v404;
          v405 = *(float *)(v19 + 7032);
          v406 = *(float *)(v19 + 7096);
          *(float *)(v385 + 7608) = v404;
          v402.f32[0] = 1.0 - v596;
          _Q9 = *(float32x4_t *)(v545 + 128);
          *(float32x4_t *)(v545 + 128) = vmlaq_n_f32(vmulq_n_f32(v384, v596), _Q9, 1.0 - v596);
          v408 = v384.f32[0] + v386;
          v409 = v387 + v388;
          v410 = (float)((float)(v387 + v388) * -0.26726) + (float)((float)(v384.f32[0] + v386) * 0.53452);
          v411 = (float32x2_t)vdup_lane_s32((int32x2_t)v401, 0);
          v411.f32[0] = v392;
          v412 = *(float *)(v19 + 7260);
          v413 = v410 + (float)(v412 * -0.53452);
          v414 = (float32x2_t)vdup_lane_s32((int32x2_t)v399, 0);
          v414.f32[0] = v389;
          _D28 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v384, (int8x16_t)v384, 4uLL), v411);
          v416 = (float32x2_t)vdup_lane_s32((int32x2_t)v400, 0);
          v416.f32[0] = v391;
          _D10 = *(float32x2_t *)(v19 + 7264);
          v676 = vmla_f32(vmla_f32(vmul_f32(vadd_f32(v414, v416), (float32x2_t)vdup_n_s32(0xBE88D64D)), (float32x2_t)vdup_n_s32(0x3F08D64Du), _D28), (float32x2_t)vdup_n_s32(0xBF08D64D), _D10);
          v418 = *(_DWORD *)(v19 + 7432) + 1;
          _NF = -v418 < 0;
          v419 = -v418 & 7;
          v420 = v418 & 7;
          if (!_NF)
            v420 = -v419;
          *(_DWORD *)(v19 + 7432) = v420;
          if (v379 < 9999)
            v421 = v379 + 1;
          else
            v421 = 10000;
          *(_DWORD *)(v19 + 7436) = v421;
          v673 = (float)((float)(v389 - v391) * 0.31623) + (float)((float)(v384.f32[1] - v392) * 0.63246);
          v674 = v403;
          v675 = v413;
          v422 = *(float *)(v19 + 7112);
          v569 = *(float *)(v19 + 7040);
          v423 = *(float *)(v19 + 7116);
          v424 = *(float *)(v19 + 7120);
          v560 = *(float *)(v19 + 7080);
          v558 = *(float *)(v19 + 7008);
          v550 = *(float *)(v19 + 7012);
          v549 = *(float *)(v19 + 7088);
          v555 = *(float *)(v19 + 7016);
          v556 = *(float *)(v19 + 7084);
          v548 = *(float *)(v19 + 7020);
          v547 = *(float *)(v19 + 7024);
          v564 = *(float *)(v19 + 7028);
          v553 = *(float *)(v19 + 7104);
          v554 = *(float *)(v19 + 7092);
          v566 = *(float *)(v19 + 7124);
          v567 = *(float *)(v19 + 7048);
          v565 = *(float *)(v19 + 7128);
          v562 = *(float *)(v19 + 7056);
          v563 = *(float *)(v19 + 7052);
          v561 = *(float *)(v19 + 7132);
          v559 = *(float *)(v19 + 7060);
          v557 = *(float *)(v19 + 7136);
          v551 = *(float *)(v19 + 7140);
          v552 = *(float *)(v19 + 7064);
          v568 = *(float *)(v19 + 7068);
          v425 = *(_DWORD *)(v19 + 7272);
          v426 = *(float *)(v19 + 7388);
          v672 = v390;
          if (v421 <= 5)
          {
            v570 = *(float32x4_t *)(v19 + 7392);
            v438 = *(float *)(v19 + 7408);
            v439.i32[0] = *(_DWORD *)(v19 + 7412);
            v440 = *(float *)(v19 + 7420);
          }
          else
          {
            v538 = v388;
            v427 = v405;
            v428 = v398;
            v536 = v422;
            _S27 = -1107566034;
            _S29 = 1060268545;
            _S30 = -1078482226;
            __asm { FMLA            S0, S30, V9.S[3] }
            v537 = v423;
            __asm
            {
              FMLA            S7, S27, V28.S[1]
              FMLA            S7, S29, V10.S[1]
              FMLA            S7, S30, V9.S[2]
              FMLA            S4, S30, V9.S[1]
            }
            v398 = v428;
            v405 = v427;
            v388 = v538;
            v437 = vmlas_n_f32((float)((float)(v409 * 0.49195) + (float)(v408 * -0.12299)) + (float)(v412 * 0.69693), -1.4349, _Q9.f32[0]);
            v426 = (float)(v437 * (float)(v596 * v437)) + (float)(v402.f32[0] * v426);
            *(float *)(v19 + 7388) = v426;
            _Q4.i32[1] = _S7;
            _Q4.i64[1] = __PAIR64__(LODWORD(v390), _S0);
            v422 = v536;
            v423 = v537;
            v570 = vmlaq_f32(vmulq_f32(_Q4, vmulq_n_f32(_Q4, v596)), *(float32x4_t *)(v19 + 7392), (float32x4_t)vdupq_lane_s32((int32x2_t)v402, 0));
            *(float32x4_t *)(v19 + 7392) = v570;
            v438 = (float)(v393 * (float)(v596 * v393)) + (float)(v402.f32[0] * *(float *)(v19 + 7408));
            *(float *)(v19 + 7408) = v438;
            v439 = vmla_n_f32(vmul_f32(v403, vmul_n_f32(v403, v596)), *(float32x2_t *)(v545 + 184), v402.f32[0]);
            *(float32x2_t *)(v545 + 184) = v439;
            v440 = (float)(v413 * (float)(v596 * v413)) + (float)(v402.f32[0] * *(float *)(v19 + 7420));
            *(float *)(v19 + 7420) = v440;
          }
          v232 = v605;
          *(float *)(v19 + 7324) = v388;
          *(float *)(v19 + 7292) = v412;
          *(float *)(v19 + 7260) = v387;
          *(float *)(v19 + 7328) = v391;
          *(float32x2_t *)(v19 + 7296) = _D10;
          v441 = v397 + v546;
          v442 = v422 + v569;
          *(float *)(v19 + 7264) = v389;
          *(float32x2_t *)(v19 + 7332) = v400;
          v443 = v423 + v398;
          *(float32x2_t *)(v19 + 7268) = v399;
          *(_DWORD *)(v19 + 7304) = v425;
          *(_OWORD *)(v545 + 112) = *(_OWORD *)(v545 + 80);
          v444 = *(__n128 *)(v545 + 48);
          *(_OWORD *)(v545 + 48) = *(_OWORD *)(v545 + 16);
          v445 = *(float *)(v385 + 7608);
          *(float32x4_t *)v545 = v384;
          v446 = *v585;
          v447 = *(float *)(v385 + 7612);
          v448 = (int32x4_t)vsubq_f32(v384, vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)0, (float32x4_t)xmmword_208F312A0,
                                                              v560 + v558),
                                                            (float32x4_t)xmmword_208F312B0,
                                                            v556 + v550),
                                                          (float32x4_t)xmmword_208F312C0,
                                                          v549 + v555),
                                                        (float32x4_t)xmmword_208F312D0,
                                                        v554 + v548),
                                                      (float32x4_t)xmmword_208F312E0,
                                                      v406 + v547),
                                                    (float32x4_t)xmmword_208F312F0,
                                                    v571 + v564),
                                                  (float32x4_t)xmmword_208F31360,
                                                  v405 + v553),
                                                (float32x4_t)xmmword_208F31370,
                                                v441),
                                              (float32x4_t)xmmword_208F31380,
                                              v442),
                                            (float32x4_t)xmmword_208F31390,
                                            v443),
                                          (float32x4_t)xmmword_208F313A0,
                                          v424 + v567),
                                        (float32x4_t)xmmword_208F313B0,
                                        v566 + v563),
                                      (float32x4_t)xmmword_208F313C0,
                                      v565 + v562),
                                    (float32x4_t)xmmword_208F313D0,
                                    v561 + v559),
                                  (float32x4_t)xmmword_208F313E0,
                                  v557 + v552),
                                (float32x4_t)xmmword_208F313F0,
                                v551 + v568));
          v671 = (float32x4_t)v448;
          *(__n128 *)(v545 + 80) = v444;
          *(float32x4_t *)(v545 + 16) = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)0, (float32x4_t)xmmword_208F311B0, v572), (float32x4_t)xmmword_208F311C0,
                                                                      v573),
                                                                    (float32x4_t)xmmword_208F311D0,
                                                                    v574),
                                                                  (float32x4_t)xmmword_208F311E0,
                                                                  v575),
                                                                (float32x4_t)xmmword_208F311F0,
                                                                v576),
                                                              (float32x4_t)xmmword_208F31200,
                                                              v577),
                                                            (float32x4_t)xmmword_208F31210,
                                                            v578),
                                                          (float32x4_t)xmmword_208F31220,
                                                          v579),
                                                        (float32x4_t)xmmword_208F31230,
                                                        v580),
                                                      (float32x4_t)xmmword_208F31240,
                                                      v581),
                                                    (float32x4_t)xmmword_208F31250,
                                                    v582),
                                                  (float32x4_t)xmmword_208F31260,
                                                  v584),
                                                (float32x4_t)xmmword_208F31270,
                                                v591),
                                              (float32x4_t)xmmword_208F31280,
                                              v610),
                                            (float32x4_t)xmmword_208F31290,
                                            v608),
                                          (float32x4_t)xmmword_208F314A0,
                                          v593);
          v678 = vaddq_f32(vsqrtq_f32(v570), (float32x4_t)xmmword_208F314B0);
          v677 = sqrtf(v426) + -5.6849;
          v679 = sqrtf(v438) + -2.1633;
          v680 = sqrtf(v439.f32[0]) + -1.2608;
          v681 = sqrtf(v612) + -0.78;
          v682 = sqrtf(v440) + -1.9188;
          v683 = v445 + -0.15472;
          v684 = v446 + -0.72464;
          v685 = (float)(v615 / 18.0) + -0.74372;
          v444.n128_f32[0] = v447 + 0.069216;
          *(float *)v448.i32 = v595 + -0.06793;
          v686 = v447 + 0.069216;
          v687 = v595 + -0.06793;
          compute_dense((uint64_t)&layer0, v640, &v671, v444, v448);
          compute_gru((int8x16_t **)&layer1, __dst->f32, v640, v449, v450);
          compute_dense((uint64_t)&layer2, v670, __dst, v451, v452);
          v453 = v670[0];
          v454 = v19 + (v597 << 6);
          *(float *)(v454 + 7640) = v670[1];
          *(float *)(v454 + 7624) = v453;
          *(_DWORD *)(v454 + 7636) = v334;
          *(_DWORD *)(v19 + 5852) = v334;
          *(float *)(v454 + 7616) = v614;
          *v586 = 1;
          v231 = v606;
          v24 = a9 / 50;
          v27 = 1.0;
LABEL_325:
          v28 = 1.0 / (float)(1 << a10);
          v29 = 2.0;
          v30 = 0.25;
          v22 = (v231 + v24);
          _VF = __OFSUB__(v232, v24);
          v23 = v232 - v24;
          if ((v23 < 0) ^ _VF | (v23 == 0))
            goto LABEL_327;
          goto LABEL_11;
        }
      }
    }
    v115 = *(int *)(v19 + 7444);
    v116 = 98;
    if (v115 >= 2)
      v116 = -2;
    v117 = (_OWORD *)(v19 + ((v116 + v115) << 6) + 7604);
    v118 = v117[2];
    v119 = v117[3];
    v120 = v117[1];
    *v61 = *v117;
    v61[1] = v120;
    v61[2] = v118;
    v61[3] = v119;
LABEL_10:
    v24 = a9 / 50;
    v22 = (v606 + v598);
    v23 = v605 - v598;
    if (v605 > v598)
      continue;
    break;
  }
LABEL_327:
  v14 = v535;
  *(_DWORD *)(v19 + 7440) = v534 - v535;
LABEL_328:
  v455 = *(_DWORD *)(v19 + 7448);
  v456 = *(_DWORD *)(v19 + 7444);
  v457 = v456 - v455;
  if (v456 < v455)
    v457 = v456 - v455 + 100;
  v458 = *(_DWORD *)(v19 + 8);
  v459 = *(_DWORD *)(v19 + 7452) + v14 / (v458 / 400);
  *(_DWORD *)(v19 + 7452) = v459;
  v460 = v455;
  if (v459 >= 8)
  {
    if (v459 >= 15)
      v461 = 15;
    else
      v461 = v459;
    v462 = v459 - v461 + 7;
    v463 = v459 - (v462 & 0xFFFFFFF8) - 8;
    v460 = v455 + (v462 >> 3) + 1;
    *(_DWORD *)(v19 + 7452) = v463;
    *(_DWORD *)(v19 + 7448) = v460;
  }
  _VF = __OFSUB__(v460, 100);
  v464 = v460 - 100;
  if (v464 < 0 == _VF)
    *(_DWORD *)(v19 + 7448) = v464;
  v465 = v458 / 50;
  if (v455 == 99)
    v466 = 0;
  else
    v466 = v455 + 1;
  if (v456 != v455 && v465 < v14)
    v455 = v466;
  v468 = v455 - (v455 == v456);
  if (v468 < 0)
    v468 = 99;
  v469 = *(_OWORD *)(v19 + ((uint64_t)v468 << 6) + 7652);
  v471 = *(_OWORD *)(v19 + ((uint64_t)v468 << 6) + 7604);
  v470 = *(_OWORD *)(v19 + ((uint64_t)v468 << 6) + 7620);
  *(_OWORD *)(a12 + 32) = *(_OWORD *)(v19 + ((uint64_t)v468 << 6) + 7636);
  *(_OWORD *)(a12 + 48) = v469;
  *(_OWORD *)a12 = v471;
  *(_OWORD *)(a12 + 16) = v470;
  if (*(_DWORD *)a12)
  {
    v472 = *(float *)(a12 + 4);
    v473 = *(_DWORD *)(v19 + 7444);
    if (v468 == 99)
      v474 = 0;
    else
      v474 = v468 + 1;
    if (v474 == v473)
    {
      v475 = 0;
      v476 = 0;
      v477 = 0;
      v478 = 1.0;
      v479 = *(float *)(a12 + 4);
      v480 = v468 - 1;
      if (v468 < 1)
        v480 = 99;
      if (v480 == v473)
        goto LABEL_422;
    }
    else
    {
      v481 = v19 + ((uint64_t)v474 << 6);
      v482 = *(float *)(v481 + 7608);
      if (v472 <= v482)
        v483 = *(float *)(v481 + 7608);
      else
        v483 = *(float *)(a12 + 4);
      v479 = v472 + v482;
      v484 = *(_DWORD *)(v481 + 7636);
      if (*(_DWORD *)(a12 + 32) > v484)
        v484 = *(_DWORD *)(a12 + 32);
      *(_DWORD *)(a12 + 32) = v484;
      if (v474 == 99)
        v485 = 0;
      else
        v485 = v474 + 1;
      if (v485 == v473)
      {
        v475 = 0;
        v476 = 0;
        v477 = 1;
        v478 = 2.0;
        v472 = v483;
        v480 = v468 - 1;
        if (v468 < 1)
          v480 = 99;
        if (v480 == v473)
          goto LABEL_422;
      }
      else
      {
        v486 = v19 + ((uint64_t)v485 << 6);
        v487 = *(float *)(v486 + 7608);
        if (v483 <= v487)
          v472 = *(float *)(v486 + 7608);
        else
          v472 = v483;
        v479 = v479 + v487;
        v488 = *(_DWORD *)(v486 + 7636);
        if (v484 > v488)
          v488 = v484;
        *(_DWORD *)(a12 + 32) = v488;
        if (v485 == 99)
          v489 = 0;
        else
          v489 = v485 + 1;
        if (v489 == v473)
        {
          v475 = 0;
          v477 = 0;
          v476 = 1;
          v478 = 3.0;
          v480 = v468 - 1;
          if (v468 < 1)
            v480 = 99;
          if (v480 == v473)
            goto LABEL_422;
        }
        else
        {
          v476 = 0;
          v477 = 0;
          v490 = v19 + ((uint64_t)v489 << 6);
          v491 = *(float *)(v490 + 7608);
          if (v472 <= v491)
            v472 = *(float *)(v490 + 7608);
          v479 = v479 + v491;
          v492 = *(_DWORD *)(v490 + 7636);
          if (v488 <= v492)
            v488 = v492;
          *(_DWORD *)(a12 + 32) = v488;
          v475 = 1;
          v478 = 4.0;
          v480 = v468 - 1;
          if (v468 < 1)
            v480 = 99;
          if (v480 == v473)
            goto LABEL_422;
        }
      }
    }
    v493 = *(_DWORD *)(a12 + 32);
    if (v493 <= *(_DWORD *)(v19 + ((uint64_t)v480 << 6) + 7636))
      v493 = *(_DWORD *)(v19 + ((uint64_t)v480 << 6) + 7636);
    *(_DWORD *)(a12 + 32) = v493;
    _VF = __OFSUB__(v480, 1);
    v494 = v480 - 1;
    if (v494 < 0 != _VF)
      v495 = 99;
    else
      v495 = v494;
    if (v495 != v473)
    {
      v496 = *(_DWORD *)(a12 + 32);
      if (v496 <= *(_DWORD *)(v19 + ((uint64_t)v495 << 6) + 7636))
        v496 = *(_DWORD *)(v19 + ((uint64_t)v495 << 6) + 7636);
      *(_DWORD *)(a12 + 32) = v496;
      _VF = __OFSUB__(v495, 1);
      v497 = v495 - 1;
      if (v497 < 0 != _VF)
        v497 = 99;
      if (v497 != v473)
      {
        v498 = *(_DWORD *)(a12 + 32);
        if (v498 <= *(_DWORD *)(v19 + ((uint64_t)v497 << 6) + 7636))
          v498 = *(_DWORD *)(v19 + ((uint64_t)v497 << 6) + 7636);
        *(_DWORD *)(a12 + 32) = v498;
        if ((v475 & 1) == 0)
        {
          v499 = v497 - 1;
          if (v497 < 1)
            v499 = 99;
          if (v499 != v473)
          {
            v500 = *(_DWORD *)(a12 + 32);
            if (v500 <= *(_DWORD *)(v19 + ((uint64_t)v499 << 6) + 7636))
              v500 = *(_DWORD *)(v19 + ((uint64_t)v499 << 6) + 7636);
            *(_DWORD *)(a12 + 32) = v500;
            if ((v476 & 1) == 0)
            {
              v501 = v499 - 1;
              if (v499 < 1)
                v501 = 99;
              if (v501 != v473)
              {
                v502 = *(_DWORD *)(a12 + 32);
                if (v502 <= *(_DWORD *)(v19 + ((uint64_t)v501 << 6) + 7636))
                  v502 = *(_DWORD *)(v19 + ((uint64_t)v501 << 6) + 7636);
                *(_DWORD *)(a12 + 32) = v502;
                if ((v477 & 1) == 0)
                {
                  v503 = v501 - 1;
                  if (v501 < 1)
                    v503 = 99;
                  if (v503 != v473)
                  {
                    v504 = *(_DWORD *)(v19 + ((uint64_t)v503 << 6) + 7636);
                    if (*(_DWORD *)(a12 + 32) > v504)
                      v504 = *(_DWORD *)(a12 + 32);
                    *(_DWORD *)(a12 + 32) = v504;
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_422:
    v505 = v479 / v478;
    v506 = v472 + -0.2;
    if (v505 <= v506)
      v505 = v506;
    *(float *)(a12 + 4) = v505;
    if (v468 <= 94)
      v507 = 5;
    else
      v507 = -95;
    v508 = v507 + v468;
    v509 = v468 - 99;
    if (v468 <= 98)
      v509 = v468 + 1;
    v510 = v509;
    v511 = v508;
    v512 = v508 + 1;
    if (v457 >= 16)
    {
      v513 = v509;
    }
    else
    {
      v512 = v468 + 1;
      v511 = v468;
      v510 = v468;
      v513 = v468;
    }
    v514 = *(float *)(v19 + 7604 + (v510 << 6) + 36);
    v515 = 0.1;
    if (v514 >= 0.1)
      v515 = *(float *)(v19 + 7604 + (v510 << 6) + 36);
    v516 = *(float *)(v19 + 7604 + (v511 << 6) + 20) * v515;
    if (v512 == 100)
      v512 = 0;
    v517 = 1.0;
    v518 = 0.0;
    if (v512 != v473)
    {
      v519 = v19 + 7604;
      do
      {
        if (v513 == 99)
          v513 = 0;
        else
          ++v513;
        if (v513 == v473)
          break;
        v520 = *(float *)(v519 + ((uint64_t)v513 << 6) + 36);
        if ((float)((float)(v516 + (float)((float)(v514 - v520) * -10.0)) / v515) < v517)
          v517 = (float)(v516 + (float)((float)(v514 - v520) * -10.0)) / v515;
        if ((float)((float)(v516 + (float)((float)(v514 - v520) * 10.0)) / v515) > v518)
          v518 = (float)(v516 + (float)((float)(v514 - v520) * 10.0)) / v515;
        if (v520 < 0.1)
          v520 = 0.1;
        v515 = v515 + v520;
        v516 = v516 + (float)(v520 * *(float *)(v519 + ((uint64_t)v512 << 6) + 20));
        if (v512 == 99)
          v512 = 0;
        else
          ++v512;
      }
      while (v512 != v473);
    }
    v521 = v516 / v515;
    *(float *)(a12 + 20) = v521;
    if (v521 >= v517)
      v522 = v517;
    else
      v522 = v521;
    if (v521 <= v518)
      v523 = v518;
    else
      v523 = v521;
    v524 = fmaxf(v522, 0.0);
    v525 = fminf(v523, 1.0);
    if (v457 <= 9)
    {
      v526 = *(_DWORD *)(v19 + 7436);
      if (v526 <= 15)
        v527 = v526 - 1;
      else
        v527 = 15;
      v528 = v524;
      v529 = v525;
      if (v527 >= 1)
      {
        v529 = v525;
        v528 = v524;
        do
        {
          _VF = __OFSUB__(v468--, 1);
          if (v468 < 0 != _VF)
            v468 = 99;
          v530 = *(float *)(v19 + ((uint64_t)v468 << 6) + 7624);
          if (v528 >= v530)
            v528 = *(float *)(v19 + ((uint64_t)v468 << 6) + 7624);
          if (v529 <= v530)
            v529 = *(float *)(v19 + ((uint64_t)v468 << 6) + 7624);
          --v527;
        }
        while (v527);
      }
      v531 = v528 + (float)(v514 * -0.1);
      if (v531 < 0.0)
        v531 = 0.0;
      v532 = v529 + (float)(v514 * 0.1);
      if (v532 > 1.0)
        v532 = 1.0;
      v533 = (float)((float)v457 * -0.1) + 1.0;
      v524 = v524 + (float)(v533 * (float)(v531 - v524));
      v525 = v525 + (float)(v533 * (float)(v532 - v525));
    }
    *(float *)(a12 + 24) = v524;
    *(float *)(a12 + 28) = v525;
  }
}

float downmix_and_resample(uint64_t a1, uint64_t a2, float *a3, float *a4, unsigned int a5, uint64_t a6, uint64_t a7, int a8, int a9, int a10)
{
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  float32x4_t *v16;
  uint64_t v17;
  void (*v18)(uint64_t, char *, uint64_t);
  uint64_t v19;
  float v20;
  float v21;
  uint64_t v22;
  float32x4_t *v23;
  uint64_t v24;
  float32x4_t v25;
  uint64_t v26;
  float *v27;
  uint64_t v28;
  float *v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  unsigned int v39;
  uint64_t v40;
  float *v41;
  uint64_t v42;
  float32x4_t *v43;
  uint64_t v44;
  float *v45;
  float *v46;
  float *v47;
  uint64_t v48;
  char *v49;
  char *v50;
  int v51;
  uint64_t v52;
  float *v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  _QWORD v61[2];
  float32x4x3_t v62;
  float32x4x3_t v63;

  v61[1] = *MEMORY[0x24BDAC8D0];
  if (!a5)
    return 0.0;
  v13 = (int)(2 * a5) / 3;
  if (a10 != 16000)
    v13 = a5;
  if (a10 == 48000)
    v14 = 2 * a5;
  else
    v14 = v13;
  MEMORY[0x24BDAC7A8](a1, a2);
  v16 = (float32x4_t *)((char *)v61 - v15);
  v18(v17, (char *)v61 - v15, v14);
  if (a8 == -2)
  {
    v20 = 0.000030518 / (float)a9;
    if ((int)v14 < 1)
      goto LABEL_21;
  }
  else
  {
    v20 = 0.000030518;
    if (a8 >= 0)
      v20 = 0.000015259;
    if ((int)v14 < 1)
      goto LABEL_21;
  }
  if (v14 < 8)
  {
    v22 = 0;
LABEL_19:
    v26 = v14 - v22;
    v27 = &v16->f32[v22];
    do
    {
      *v27 = v20 * *v27;
      ++v27;
      --v26;
    }
    while (v26);
    goto LABEL_21;
  }
  v22 = v14 & 0x7FFFFFF8;
  v23 = v16 + 1;
  v24 = v14 & 0xFFFFFFF8;
  do
  {
    v25 = vmulq_n_f32(*v23, v20);
    v23[-1] = vmulq_n_f32(v23[-1], v20);
    *v23 = v25;
    v23 += 2;
    v24 -= 8;
  }
  while (v24);
  if (v22 != v14)
    goto LABEL_19;
LABEL_21:
  v21 = 0.0;
  switch(a10)
  {
    case 48000:
      if ((int)v14 >= 2)
      {
        v28 = v14 >> 1;
        v29 = &v16->f32[1];
        do
        {
          v30 = *(v29 - 1);
          v31 = a4[1];
          v32 = (float)(v30 - *a4) * 0.60744;
          v33 = *a4 + v32;
          v34 = *v29;
          v29 += 2;
          v35 = (float)(v34 - v31) * 0.15063;
          v36 = (float)(v33 + v31) + v35;
          *a4 = v30 + v32;
          a4[1] = v34 + v35;
          v37 = a4[2];
          v38 = (float)((float)-v34 - v37) * 0.15063;
          a4[2] = v38 - v34;
          v21 = v21 + (float)((float)((float)(v33 + v37) + v38) * (float)((float)(v33 + v37) + v38));
          *a3++ = v36 * 0.5;
          --v28;
        }
        while (v28);
      }
      return v21;
    case 16000:
      MEMORY[0x24BDAC7A8](v61, v19);
      v41 = (float *)((char *)v61 - v40);
      if ((int)v14 < 1)
        return v21;
      if (v14 >= 8)
      {
        v42 = v14 & 0x7FFFFFF8;
        v43 = v16 + 1;
        v44 = v14 & 0xFFFFFFF8;
        v45 = v41;
        do
        {
          v62.val[0] = v43[-1];
          v63.val[0] = *v43;
          v62.val[1] = v62.val[0];
          v62.val[2] = v62.val[0];
          v63.val[1] = *v43;
          v63.val[2] = *v43;
          v46 = v45 + 24;
          vst3q_f32(v45, v62);
          v47 = v45 + 12;
          vst3q_f32(v47, v63);
          v43 += 2;
          v45 = v46;
          v44 -= 8;
        }
        while (v44);
        if (v42 == v14)
          goto LABEL_37;
      }
      else
      {
        v42 = 0;
      }
      v48 = v14 - v42;
      v49 = (char *)&v41[3 * v42 + 2];
      v50 = &v16->i8[4 * v42];
      do
      {
        v51 = *(_DWORD *)v50;
        v50 += 4;
        *((_DWORD *)v49 - 2) = v51;
        *((_DWORD *)v49 - 1) = v51;
        *(_DWORD *)v49 = v51;
        v49 += 12;
        --v48;
      }
      while (v48);
LABEL_37:
      v52 = v39 >> 1;
      v53 = v41 + 1;
      do
      {
        v54 = *(v53 - 1);
        v55 = a4[1];
        v56 = (float)(v54 - *a4) * 0.60744;
        v57 = *v53;
        v53 += 2;
        v58 = (float)(*a4 + v56) + v55;
        v59 = (float)(v57 - v55) * 0.15063;
        *a4 = v54 + v56;
        a4[1] = v57 + v59;
        a4[2] = (float)((float)((float)-v57 - a4[2]) * 0.15063) - v57;
        *a3++ = (float)(v58 + v59) * 0.5;
        --v52;
      }
      while (v52);
      return v21;
    case 24000:
      memcpy(a3, v16, 4 * (int)v14);
      break;
  }
  return v21;
}

uint64_t compute_band_energies(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, char a6)
{
  uint64_t v6;
  uint64_t v7;
  __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  int v14;
  float v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  float v20;

  if (a4 >= 1)
  {
    v6 = 0;
    v7 = 0;
    v8 = *(__int16 **)(result + 32);
    v9 = *(int *)(result + 8);
    v10 = (int)(*(_DWORD *)(result + 48) << a6);
    if (a5 <= 1)
      v11 = 1;
    else
      v11 = a5;
    v12 = *v8;
    v13 = a4;
    do
    {
      result = 0;
      LOWORD(v14) = v12;
      do
      {
        v16 = (__int16)v14;
        v17 = result + 1;
        v14 = v8[result + 1];
        v18 = ((v14 - v16) << a6);
        if ((int)v18 < 1)
        {
          v15 = 0.0;
        }
        else
        {
          v19 = (float *)(a2 + 4 * (v6 + (v16 << a6)));
          v15 = 0.0;
          do
          {
            v20 = *v19++;
            v15 = v15 + (float)(v20 * v20);
            --v18;
          }
          while (v18);
        }
        *(float *)(a3 + 4 * (result + v7 * v9)) = sqrtf(v15 + 1.0e-27);
        ++result;
      }
      while (v17 != v13);
      ++v7;
      v6 += v10;
    }
    while (v7 != v11);
  }
  return result;
}

void anti_collapse(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13)
{
  unsigned int v14;
  uint64_t v15;
  uint64_t v18;
  __int16 v19;
  int v20;
  int v21;
  long double v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  float v26;
  float *v27;
  uint64_t v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float *v35;
  uint64_t v36;
  int v37;
  int v38;
  float v39;
  float v40;
  uint64_t v41;
  int i;
  float v43;
  unsigned int v44;
  int v45;
  int8x16_t v46;
  int8x16_t v47;
  int v48;
  int8x16_t v49;
  uint32x4_t v50;
  int32x4_t v51;
  uint32x4_t v52;
  int32x4_t v53;
  int8x16_t v54;
  int8x16_t v55;
  int32x4_t v56;
  BOOL v57;
  float v58;
  float *v59;
  uint64_t v60;
  float v61;
  float v62;
  unsigned int v63;
  unint64_t v64;
  float32x4_t *v65;
  float32x4_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v71;
  __int16 v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;

  if (a7 < a8)
  {
    v14 = 1 << a4 <= 1 ? 1 : 1 << a4;
    v15 = a5 <= 1 ? 1 : a5;
    v76 = v15;
    if (a4 != 31)
    {
      v69 = a8;
      v18 = a7;
      v75 = a6;
      v74 = 4 * a6;
      v81 = *(int *)(a1 + 8);
      v68 = *(_QWORD *)(a1 + 32);
      v19 = *(_WORD *)(v68 + 2 * a7);
      do
      {
        v71 = v18 + 1;
        v20 = v19;
        v72 = *(_WORD *)(v68 + 2 * (v18 + 1));
        v21 = v72 - v19;
        v22 = exp((float)((float)(int)(((*(_DWORD *)(a12 + 4 * v18) + 1) / v21) >> a4) * -0.125)* 0.693147181);
        v23 = a10;
        v24 = 0;
        *(float *)&v22 = v22;
        v25 = *(float *)&v22 * 0.5;
        v78 = v21 << a4;
        *(float *)&v22 = sqrt((double)(v21 << a4));
        v26 = 1.0 / *(float *)&v22;
        v79 = v18 * a5;
        v80 = v18;
        v73 = v18 + v81;
        v27 = (float *)(a2 + 4 * (v20 << a4));
        do
        {
          v28 = v80 + (int)v81 * (int)v24;
          v29 = *(float *)(v23 + 4 * v28);
          v30 = *(float *)(a11 + 4 * v28);
          if (a5 == 1)
          {
            if (v29 <= *(float *)(v23 + 4 * v73))
              v29 = *(float *)(v23 + 4 * v73);
            if (v30 <= *(float *)(a11 + 4 * v73))
              v30 = *(float *)(a11 + 4 * v73);
          }
          if (v29 >= v30)
            v29 = v30;
          v31 = *(float *)(a9 + 4 * v28) - v29;
          if (v31 < 0.0)
            v31 = 0.0;
          v32 = exp(v31 * -0.693147181);
          v33 = v32 + v32;
          if (a4 == 3)
            v33 = v33 * 1.4142;
          if (v25 >= v33)
            v34 = v33;
          else
            v34 = v25;
          v35 = (float *)(a2 + 4 * (v20 << a4) + 4 * v24 * v75);
          v36 = v24 + v79;
          if (v21 < 1)
          {
            v44 = *(unsigned __int8 *)(a3 + v36);
            if (v14 >= 8)
            {
              v46 = (int8x16_t)vdupq_n_s32(v44);
              v47 = 0uLL;
              v48 = v14 & 0x7FFFFFF8;
              v49 = 0uLL;
              v50 = (uint32x4_t)xmmword_208F071C0;
              v51.i64[0] = 0x400000004;
              v51.i64[1] = 0x400000004;
              v52.i64[0] = 0x100000001;
              v52.i64[1] = 0x100000001;
              v53.i64[0] = 0x800000008;
              v53.i64[1] = 0x800000008;
              do
              {
                v54 = (int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v52, v50), v46));
                v55 = (int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v52, (uint32x4_t)vaddq_s32((int32x4_t)v50, v51)), v46));
                v47 = (int8x16_t)vsubq_s32((int32x4_t)vbicq_s8(v47, v54), (int32x4_t)v54);
                v49 = (int8x16_t)vsubq_s32((int32x4_t)vbicq_s8(v49, v55), (int32x4_t)v55);
                v50 = (uint32x4_t)vaddq_s32((int32x4_t)v50, v53);
                v48 -= 8;
              }
              while (v48);
              v56 = (int32x4_t)vorrq_s8(v47, v49);
              v37 = vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(v56, v56))) & 1;
              v45 = v14 & 0x7FFFFFF8;
              v23 = a10;
              v41 = (v21 << a4);
              if ((v14 & 0x7FFFFFF8) != 0)
                goto LABEL_46;
            }
            else
            {
              v37 = 0;
              v45 = 0;
              v23 = a10;
              v41 = (v21 << a4);
            }
            do
            {
              if (((v44 >> v45) & 1) == 0)
                v37 = 1;
              ++v45;
            }
            while (v14 != v45);
          }
          else
          {
            v37 = 0;
            v38 = 0;
            v39 = v26 * v34;
            v40 = -(float)(v26 * v34);
            v23 = a10;
            v41 = (v21 << a4);
            do
            {
              if (((*(unsigned __int8 *)(a3 + v36) >> v38) & 1) == 0)
              {
                for (i = 0; i != v21; ++i)
                {
                  a13 = 1664525 * a13 + 1013904223;
                  if ((a13 & 0x8000) != 0)
                    v43 = v39;
                  else
                    v43 = v40;
                  v35[(i << a4) + v38] = v43;
                }
                v37 = 1;
              }
              ++v38;
            }
            while (v38 != v14);
          }
LABEL_46:
          if (v37)
            v57 = (int)v41 < 1;
          else
            v57 = 1;
          if (!v57)
          {
            v58 = 0.0;
            v59 = v27;
            v60 = v41;
            do
            {
              v61 = *v59++;
              v58 = v58 + (float)(v61 * v61);
              --v60;
            }
            while (v60);
            v62 = 1.0 / sqrtf(v58 + 1.0e-15);
            if (v41 < 8)
            {
              v63 = 0;
LABEL_57:
              v67 = v41 - v63;
              do
              {
                *v35 = v62 * *v35;
                ++v35;
                --v67;
              }
              while (v67);
              goto LABEL_13;
            }
            v64 = 0;
            v35 += v78 & 0xFFFFFFF8;
            do
            {
              v65 = (float32x4_t *)&v27[v64 / 4];
              v66 = vmulq_n_f32(*(float32x4_t *)&v27[v64 / 4 + 4], v62);
              *v65 = vmulq_n_f32(*(float32x4_t *)&v27[v64 / 4], v62);
              v65[1] = v66;
              v64 += 32;
            }
            while (((4 * (v21 << a4)) & 0x3FFFFFFE0) != v64);
            v63 = v78 & 0xFFFFFFF8;
            if ((v78 & 0xFFFFFFF8) != v41)
              goto LABEL_57;
          }
LABEL_13:
          ++v24;
          v27 = (float *)((char *)v27 + v74);
        }
        while (v24 != v76);
        v18 = v71;
        v19 = v72;
      }
      while (v71 != v69);
    }
  }
}

uint64_t spreading_decision(uint64_t a1, uint64_t a2, int *a3, int a4, int *a5, int *a6, int a7, int a8, int a9, int a10, uint64_t a11)
{
  __int16 *v11;
  uint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  float32x4_t v23;
  float32x4_t v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  float v32;
  uint64_t v33;
  int32x4_t v34;
  uint64_t v35;
  uint64_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  float v49;
  unsigned int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  int *v56;

  v11 = *(__int16 **)(a1 + 32);
  if ((v11[a8] - v11[a8 - 1]) * a10 < 9)
    return 0;
  if (a8 >= 1)
  {
    v56 = a6;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    if (a9 <= 1)
      v17 = 1;
    else
      v17 = a9;
    __asm { FMOV            V0.4S, #0.25 }
    v23 = (float32x4_t)vdupq_n_s32(0x3D800000u);
    v24 = (float32x4_t)vdupq_n_s32(0x3C800000u);
    do
    {
      v25 = 0;
      v26 = *v11;
      do
      {
        v30 = v25 + 1;
        v31 = ((v11[v25 + 1] - v26) * a10);
        if ((int)v31 >= 9)
        {
          v32 = (float)(int)v31;
          v33 = 4 * v26 * a10;
          v34 = 0uLL;
          v35 = v31 & 0xFFFFFFF8;
          v36 = v33;
          v37 = 0uLL;
          v38 = 0uLL;
          v39 = 0uLL;
          v40 = 0uLL;
          v41 = 0uLL;
          do
          {
            v42 = vmulq_n_f32(vmulq_f32(*(float32x4_t *)(a2 + v36), *(float32x4_t *)(a2 + v36)), v32);
            v43 = vmulq_n_f32(vmulq_f32(*(float32x4_t *)(a2 + v36 + 16), *(float32x4_t *)(a2 + v36 + 16)), v32);
            v40 = vsubq_s32(v40, vcgtq_f32(_Q0, v42));
            v41 = vsubq_s32(v41, vcgtq_f32(_Q0, v43));
            v38 = vsubq_s32(v38, vcgtq_f32(v23, v42));
            v39 = vsubq_s32(v39, vcgtq_f32(v23, v43));
            v34 = vsubq_s32(v34, vcgtq_f32(v24, v42));
            v37 = vsubq_s32(v37, vcgtq_f32(v24, v43));
            v36 += 32;
            v35 -= 8;
          }
          while (v35);
          v44 = vaddvq_s32(vaddq_s32(v41, v40));
          v45 = vaddvq_s32(vaddq_s32(v39, v38));
          v46 = vaddvq_s32(vaddq_s32(v37, v34));
          v47 = v31 - (v31 & 0xFFFFFFF8);
          if (v47)
          {
            v48 = ((4 * v31) & 0x3FFFFFFE0) + v33;
            do
            {
              v49 = (float)(*(float *)(a2 + v48) * *(float *)(a2 + v48)) * v32;
              if (v49 < 0.25)
                ++v44;
              if (v49 < 0.0625)
                ++v45;
              if (v49 < 0.015625)
                ++v46;
              v48 += 4;
              --v47;
            }
            while (v47);
          }
          if (v25 > *(int *)(a1 + 8) - 4)
            v16 += 32 * (v45 + v44) / v31;
          v27 = (int)v31 <= 2 * v44;
          if ((int)v31 <= 2 * v45)
            ++v27;
          if ((int)v31 > 2 * v46)
            v28 = v27;
          else
            v28 = v27 + 1;
          v29 = *(_DWORD *)(a11 + 4 * v25);
          v14 += v29 * v28;
          v15 += v29;
        }
        v26 = v11[++v25];
      }
      while (v30 != a8);
      ++v13;
      a2 += 4 * *(_DWORD *)(a1 + 48) * a10;
    }
    while (v13 != v17);
    if (!a7)
      goto LABEL_48;
    if (v16)
      v50 = v16 / ((a8 - *(_DWORD *)(a1 + 8) + 4) * a9);
    else
      v50 = 0;
    a6 = v56;
    goto LABEL_40;
  }
  v14 = 0;
  v15 = 0;
  v50 = 0;
  if (a7)
  {
LABEL_40:
    v51 = (int)(*a5 + v50) >> 1;
    *a5 = v51;
    v52 = v51 - 4;
    if (*a6 == 2)
      v51 += 4;
    if (!*a6)
      v51 = v52;
    if (v51 <= 22)
      v53 = v51 > 18;
    else
      v53 = 2;
    *a6 = v53;
  }
LABEL_48:
  v54 = *a3 + (v14 << 8) / v15;
  *a3 = v54 >> 1;
  v55 = (v54 & 0xFFFFFFFE) + (v54 >> 1) - (a4 << 7) + 450;
  if ((int)v55 < 320)
    return 3;
  if (v55 >= 0x400)
    return v55 < 0x600;
  return 2;
}

uint64_t quant_all_bands(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11, int a12, uint64_t a13, int a14, int a15, char **a16, unsigned int a17, unsigned int a18, _DWORD *a19, int a20,int a21)
{
  int v22;
  _DWORD *v23;
  uint64_t v24;
  int v25;
  BOOL v26;
  _BOOL4 v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  float32x4_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t result;
  float32x4_t *v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unsigned int v56;
  uint64_t v57;
  float32x4_t v58;
  uint64_t v59;
  int v60;
  int v61;
  char **v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  float32x4_t *v67;
  _BOOL4 v69;
  uint64_t v70;
  float32x4_t v71;
  _BOOL4 v72;
  float *v73;
  float32x4_t *v74;
  int v75;
  uint64_t __dst;
  uint64_t v77;
  int v78;
  unsigned int v79;
  int v80;
  uint64_t v81;
  int v82;
  float32x4_t *v83;
  unsigned int v84;
  unsigned int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  BOOL v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  int v99;
  size_t v100;
  float32x4_t *v101;
  uint64_t v102;
  float *v103;
  float32x4_t *v104;
  float32x4_t *v105;
  int v106;
  int v107;
  int v108;
  uint64_t v109;
  int v110;
  int v111;
  uint64_t v112;
  int v113;
  int v114;
  int v115;
  int v116;
  __int16 *v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  uint64_t v124;
  int v125;
  int v126;
  int v127;
  int v128;
  unsigned int v129;
  uint64_t v130;
  float32x4_t *v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  unsigned int v138;
  int v139;
  int v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  float *v145;
  char v146;
  float v147;
  float v148;
  float v149;
  __int128 v150;
  float32x4_t *v151;
  unint64_t v152;
  uint64_t v153;
  float32x4_t *v154;
  float32x4_t v155;
  float *v156;
  float32x4_t *v157;
  char **v158;
  size_t v159;
  char *v160;
  uint64_t v161;
  float v162;
  float32x4_t *v163;
  float *v164;
  float32x4_t *v165;
  unsigned int v166;
  float *v167;
  int v168;
  char v169;
  float32x4_t v170;
  float *v171;
  float *v172;
  float32x4_t *v173;
  float v174;
  float32x4_t *v175;
  uint64_t v176;
  float32x4_t *v177;
  float32x4_t v178;
  float32x4_t v179;
  uint64_t v180;
  uint64_t v181;
  float *v182;
  float *v183;
  float v184;
  float v185;
  float v186;
  uint64_t v187;
  float32x4_t *v188;
  uint64_t v189;
  float32x4_t *v190;
  float32x4_t v191;
  float32x4_t v192;
  uint64_t v193;
  uint64_t v194;
  float *v195;
  float *v196;
  float v197;
  float v198;
  float v199;
  __int128 v200;
  int v201;
  int v202;
  char **v203;
  __int128 *v204;
  float32x4_t v205;
  uint64_t v206;
  int v207;
  int v208;
  float32x4_t *v209;
  uint64_t v210;
  float v211;
  float32x4_t *v212;
  float v213;
  float32x4_t *v214;
  uint64_t v215;
  float32x4_t *v216;
  float32x4_t v217;
  float32x4_t v218;
  uint64_t v219;
  uint64_t v220;
  float *v221;
  float *v222;
  float v223;
  float v224;
  float v225;
  uint64_t v226;
  float32x4_t *v227;
  uint64_t v228;
  float32x4_t *v229;
  float32x4_t v230;
  float32x4_t v231;
  uint64_t v232;
  uint64_t v233;
  float *v234;
  float *v235;
  float v236;
  float v237;
  float v238;
  float v239;
  float v240;
  __int128 v241;
  size_t v242;
  char v243;
  uint64_t v244;
  float32x4_t *v245;
  float32x4_t v246;
  _QWORD v247[2];
  uint64_t v248;
  char *v249;
  float32x4_t *v250;
  float32x4_t *v251;
  char *v252;
  uint64_t v253;
  size_t v254;
  unsigned int v255;
  char *v256;
  char *v257;
  uint64_t v258;
  float *v259;
  int v260;
  char *v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  __int128 *v265;
  __int128 *v266;
  unint64_t v267;
  uint64_t v268;
  float32x4_t *v269;
  float32x4_t *v270;
  int v271;
  uint64_t v272;
  uint64_t v273;
  int v274;
  _BOOL4 v275;
  float32x4_t *v276;
  int v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  char *v281;
  int v282;
  size_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  int v288;
  _BOOL4 v289;
  uint64_t v290;
  char **v291;
  uint64_t v292;
  int v293;
  int v294;
  uint64_t v295;
  uint64_t v296;
  float32x4_t *v297;
  uint64_t v298;
  uint64_t v299;
  float32x4_t *v300;
  unsigned int v301;
  uint64_t v302;
  float *v303;
  uint64_t v304;
  uint64_t v305;
  float32x4_t *v306;
  __int128 v307;
  __int128 v308;
  __int128 v309;
  __int128 v310;
  __int128 v311;
  __int128 v312;
  __int128 v313;
  __int128 v314;
  __int128 v315;
  __int128 v316;
  __int128 v317;
  __int128 v318;
  __int128 v319;
  char *v320;
  __int128 v321;
  __int128 v322;
  __int128 v323;
  __int128 v324;
  __int128 v325;
  __int128 v326;
  _BYTE v327[3];
  __int128 v328;
  uint64_t v329;
  uint64_t v330;

  v253 = a8;
  LOBYTE(v22) = a17;
  v23 = a19;
  v330 = *MEMORY[0x24BDAC8D0];
  v24 = *(_QWORD *)(a2 + 32);
  v280 = a6;
  v25 = a6 != 0;
  LODWORD(v300) = a12;
  if (a12)
    v26 = 1;
  else
    v26 = a20 <= 7;
  v27 = !v26 && a6 != 0;
  if (!(_DWORD)a1)
    v27 = 1;
  v289 = v27;
  v325 = 0u;
  v326 = 0u;
  v323 = 0u;
  v324 = 0u;
  if (a10)
    v28 = 1 << a17;
  else
    v28 = 1;
  v271 = *(__int16 *)(v24 + 2 * a3);
  v29 = MEMORY[0x24BDAC7A8](a1, a2);
  v296 = v30;
  v297 = (float32x4_t *)((char *)v247 - v32);
  v33 = *(__int16 *)(v24 + 2 * *(int *)(v30 + 8) - 2) << a17;
  v288 = v34;
  if (v34 == 1)
  {
    v29 = MEMORY[0x24BDAC7A8](v29, v30);
    v303 = (float *)((char *)v247 - v35);
  }
  else
  {
    v303 = (float *)(v31 + 4 * v33);
  }
  v36 = MEMORY[0x24BDAC7A8](v29, v30);
  v38 = MEMORY[0x24BDAC7A8](v36, (char *)v247 - ((v37 + 15) & 0x7FFFFFFF0));
  v40 = (float32x4_t *)((char *)v247 - v39);
  v42 = MEMORY[0x24BDAC7A8](v38, v41);
  v257 = (char *)v247 - v43;
  v45 = MEMORY[0x24BDAC7A8](v42, v44);
  v256 = (char *)v247 - v46;
  result = MEMORY[0x24BDAC7A8](v45, v47);
  v252 = (char *)v247 - v59;
  v60 = *a19;
  DWORD2(v325) = *a19;
  HIDWORD(v325) = a21;
  *(_QWORD *)&v325 = v253;
  *(_QWORD *)&v324 = a16;
  *((_QWORD *)&v322 + 1) = v296;
  *(_QWORD *)((char *)&v323 + 4) = __PAIR64__(v56, v55);
  *(_QWORD *)&v322 = __PAIR64__(v289, result);
  DWORD1(v326) = v61;
  LODWORD(v326) = 0;
  DWORD2(v326) = v28 > 1;
  if (v50 < v51)
  {
    v62 = a16;
    v247[0] = a19;
    v247[1] = v53;
    v279 = v52;
    v302 = 0;
    v63 = (unint64_t)v297;
    v64 = v271 << a17;
    v65 = v50;
    v281 = (char *)v297 - 4 * v64;
    v248 = (uint64_t)v297->i64 + 4 * (v54 - v64) + -4 * v64;
    v299 = v50 + 1;
    v267 = (unint64_t)v297->u64 + 4 * v54 + -4 * v64;
    v268 = v50 + 2;
    v278 = a13;
    v286 = a9;
    v277 = a14;
    if (v280)
      v67 = v297;
    else
      v67 = 0;
    v276 = v67;
    v69 = v56 != 3 || v28 > 1;
    v275 = v69;
    v282 = v28;
    v274 = ~(-1 << v28);
    v266 = (__int128 *)((char *)a16 + 12);
    v264 = v271 << a17;
    v265 = (__int128 *)(a16 + 4);
    v284 = v55;
    v273 = (int)a18;
    v272 = v51;
    v304 = v51 - 1;
    v262 = v24 - 2;
    v263 = a18;
    v70 = 4 * v57 - 4 * v64;
    v269 = v40;
    v270 = v49;
    v251 = v49 + 1;
    v249 = &v297->i8[4 * (v57 - v64)];
    v250 = v40 + 1;
    v71.i64[0] = 0x3F0000003F000000;
    v71.i64[1] = 0x3F0000003F000000;
    v298 = v50;
    v72 = 1;
    v287 = v24;
    v290 = v70;
    v291 = a16;
    v285 = a17;
    while (1)
    {
      v79 = 0;
      LODWORD(v323) = v65;
      v80 = *(__int16 *)(v24 + 2 * v65);
      v81 = 4 * (v80 << v22);
      v82 = *(__int16 *)(v24 + 2 * (v65 + 1));
      if (v280)
        v83 = (float32x4_t *)(v280 + v81);
      else
        v83 = 0;
      v84 = *((_DWORD *)v62 + 8);
      v85 = __clz(v84);
      v86 = ((__PAIR64__(8 * (v85 + *((_DWORD *)v62 + 6)), ec_tell_frac_correction[(v84 >> (16 - v85) >> 12) - 8])
            - __PAIR64__(v84 >> (16 - v85) >> 12, v84 >> (16 - v85))) >> 32)
          - 248;
      if (v65 == v298)
        v87 = 0;
      else
        v87 = v86;
      v88 = a15 - v87;
      v294 = v86;
      v89 = v277 - v86;
      DWORD2(v324) = v277 - v86 - 1;
      if (v65 < v273)
      {
        v90 = v263 - v65;
        if ((int)v263 - (int)v65 >= 3)
          v90 = 3;
        v91 = *(_DWORD *)(v286 + 4 * v65) + v88 / v90;
        if (v89 >= v91)
          v89 = v91;
        v92 = v89 & ~(v89 >> 31);
        if (v92 >= 0x3FFF)
          v79 = 0x3FFF;
        else
          v79 = v92;
      }
      v301 = v79;
      v93 = v82 - v80;
      v295 = v65 + 1;
      v293 = v88;
      LODWORD(v283) = v80;
      v292 = (v80 << v22);
      if (v289 && ((v80 - v93) << v22 >= *(__int16 *)(v24 + 2 * v298) << v22 || v65 == v299))
      {
        if ((_DWORD)v302)
          v94 = !v72;
        else
          v94 = 0;
        if (v94)
          v95 = v302;
        else
          v95 = v65;
        v302 = v95;
      }
      if (v65 == v299)
      {
        v96 = *(_QWORD *)(v296 + 32);
        v97 = *(__int16 *)(v96 + 2 * v299);
        v98 = (v97 - *(__int16 *)(v96 + 2 * v298)) << v285;
        LODWORD(v96) = (*(__int16 *)(v96 + 2 * v268) - v97) << v285;
        v99 = 2 * v98 - v96;
        v100 = 4 * ((int)v96 - v98);
        v101 = v83;
        memcpy((void *)(v63 + 4 * v98), (const void *)(v63 + 4 * v99), v100);
        v83 = v101;
        v71.i64[0] = 0x3F0000003F000000;
        v71.i64[1] = 0x3F0000003F000000;
        v70 = v290;
        v63 = (unint64_t)v297;
        if ((_DWORD)v300)
        {
          memcpy((void *)(v267 + 4 * v98), (const void *)(v267 + 4 * v99), v100);
          v83 = v101;
          v71.i64[0] = 0x3F0000003F000000;
          v71.i64[1] = 0x3F0000003F000000;
          v70 = v290;
          v63 = (unint64_t)v297;
        }
      }
      v22 = v285;
      v102 = (v93 << v285);
      v103 = v303;
      if (v65 < *(int *)(v296 + 12))
      {
        v104 = (float32x4_t *)(v279 + v81);
      }
      else
      {
        v103 = 0;
        v104 = (float32x4_t *)v63;
      }
      v105 = v276;
      if (v65 < *(int *)(v296 + 12))
        v105 = v83;
      v306 = v105;
      v106 = *(_DWORD *)(v278 + 4 * v65);
      HIDWORD(v323) = v106;
      v107 = v288;
      if (v65 != v304)
        v107 = 1;
      if (v107)
        __dst = (uint64_t)v103;
      else
        __dst = 0;
      v108 = v106 < 0 || v275;
      v109 = 0xFFFFFFFFLL;
      if (!(_DWORD)v302)
      {
        v110 = v274;
        v111 = v274;
        v24 = v287;
        goto LABEL_99;
      }
      v110 = v274;
      v111 = v274;
      v24 = v287;
      if (!v108)
        goto LABEL_99;
      v112 = 2 * (int)v302;
      v113 = (*(__int16 *)(v287 + v112) - v271 - v93) << v285;
      v109 = v113 & ~(v113 >> 31);
      v114 = v109 + v264;
      v115 = -(int)v302;
      v116 = 1 - v302;
      v117 = (__int16 *)(v262 + v112);
      v118 = 2 - v302;
      v119 = v302;
      do
      {
        v120 = v118;
        v121 = *v117--;
        ++v115;
        --v119;
        ++v116;
        ++v118;
      }
      while (v121 << v285 > v114);
      v122 = -v115;
      v123 = v114 + v102;
      v124 = (int)v302 - 1 + 1;
      v125 = v65 <= v124 ? v302 : v65;
      v126 = v125 - 1;
      while (v124 < v65)
      {
        v127 = *(__int16 *)(v287 + 2 * v124++) << v285;
        if (v127 >= v123)
        {
          v126 = v124 - 2;
          break;
        }
      }
      v128 = v119 <= v126 ? v126 : v119;
      v129 = v128 + v115 + 1;
      if (v129 < 2)
        break;
      v130 = __dst;
      v131 = v104;
      v132 = 0;
      v133 = 0;
      v134 = 0;
      v135 = 0;
      v136 = 0;
      if (v119 <= v126)
        v137 = v126;
      else
        v137 = v119;
      v122 = ((v137 + v116) & 0xFFFFFFFE) - v115;
      v138 = (v137 + v120) & 0xFFFFFFFE;
      do
      {
        v139 = (v119 + v132) << v25;
        v140 = (v119 + v132 + 1) << v25;
        v133 |= *(unsigned __int8 *)(a7 + v139);
        v134 |= *(unsigned __int8 *)(a7 + v140);
        v135 |= *(unsigned __int8 *)(a7 + v139 + v25);
        v136 |= *(unsigned __int8 *)(a7 + v140 + v25);
        v132 += 2;
      }
      while (v138 != v132);
      v110 = v136 | v135;
      v111 = v134 | v133;
      v104 = v131;
      __dst = v130;
      if (v129 != (v129 & 0xFFFFFFFE))
        goto LABEL_98;
LABEL_99:
      v141 = (int)v292;
      v303 = (float *)__dst;
      v305 = v102;
      if ((_DWORD)v300)
      {
        if (v289 && v65 == v284)
        {
          v142 = (((_DWORD)v283 - v271) << v285);
          if ((int)v142 >= 1)
          {
            if (v142 >= 8 && (v63 >= (unint64_t)&v249[4 * v142] || v267 >= v63 + 4 * v142))
            {
              v143 = v142 & 0x7FFFFFF8;
              v244 = v142 & 0xFFFFFFF8;
              v245 = (float32x4_t *)v63;
              do
              {
                v58 = vmulq_f32(vaddq_f32(*v245, *(float32x4_t *)((char *)v245 + v70)), v71);
                v246 = vmulq_f32(vaddq_f32(v245[1], *(float32x4_t *)((char *)v245 + v70 + 16)), v71);
                *v245 = v58;
                v245[1] = v246;
                v245 += 2;
                v244 -= 8;
              }
              while (v244);
              if (v143 == v142)
                goto LABEL_111;
            }
            else
            {
              v143 = 0;
            }
            v144 = v142 - v143;
            v145 = (float *)(v63 + 4 * v143);
            do
            {
              v58.f32[0] = (float)(*v145 + *(float *)((char *)v145 + v70)) * 0.5;
              *v145++ = v58.f32[0];
              --v144;
            }
            while (v144);
          }
        }
        else if (v65 != v284)
        {
          v166 = v301 >> 1;
          if ((_DWORD)v109 == -1)
            v167 = 0;
          else
            v167 = (float *)(v63 + 4 * (int)v109);
          LODWORD(v292) = v301 >> 1;
          if (v65 == v304)
          {
            v58.i32[0] = 1.0;
            v168 = v282;
            v243 = quant_band((uint64_t)&v322, v104, v102, v166, v282, v167, v285, 0, v58, (float *)__dst, v111);
            v171 = (float *)__dst;
            LOBYTE(__dst) = v243;
            v173 = 0;
            if ((_DWORD)v109 == -1)
              v172 = 0;
            else
              v172 = (float *)(v267 + 4 * (int)v109);
            v24 = v287;
          }
          else
          {
            v58.i32[0] = 1.0;
            v168 = v282;
            v169 = quant_band((uint64_t)&v322, v104, v102, v166, v282, v167, v285, (float32x4_t *)&v281[4 * v141], v58, v103, v111);
            v171 = (float *)__dst;
            LOBYTE(__dst) = v169;
            if ((_DWORD)v109 == -1)
              v172 = 0;
            else
              v172 = (float *)(v267 + 4 * (int)v109);
            v24 = v287;
            v173 = (float32x4_t *)(v248 + 4 * (*(__int16 *)(v287 + 2 * v65) << v22));
          }
          v170.i32[0] = 1.0;
          result = quant_band((uint64_t)&v322, v306, v305, v292, v168, v172, v22, v173, v170, v171, v110);
          v63 = (unint64_t)v297;
          v70 = v290;
          v62 = v291;
          v71.i64[0] = 0x3F0000003F000000;
          v71.i64[1] = 0x3F0000003F000000;
          v75 = v301;
          v78 = v294;
          v77 = v295;
          goto LABEL_34;
        }
      }
LABEL_111:
      if (v306)
      {
        v146 = v288 ^ 1;
        if (v65 >= v284)
          v146 = 1;
        if ((v146 & 1) == 0)
        {
          v320 = 0;
          v318 = 0u;
          v319 = 0u;
          v317 = 0u;
          v310 = 0u;
          v311 = 0u;
          v147 = *(float *)(v253 + 4 * v65);
          v308 = 0u;
          v309 = 0u;
          v148 = *(float *)(v253 + 4 * (v65 + *(int *)(v296 + 8)));
          v307 = 0u;
          if (v147 >= v148)
            v149 = v148;
          else
            v149 = v147;
          v300 = (float32x4_t *)v109;
          LODWORD(v292) = v110 | v111;
          v261 = *v291;
          v260 = *((_DWORD *)v291 + 2);
          v321 = *v266;
          v258 = *((unsigned int *)v291 + 7);
          v150 = *v265;
          v329 = *((_QWORD *)v265 + 2);
          v328 = v150;
          v315 = v325;
          v316 = v326;
          v313 = v323;
          v314 = v324;
          v312 = v322;
          v151 = v104;
          v152 = v63;
          v153 = v141;
          memcpy(v270, v104, 4 * (int)v102);
          v154 = v306;
          v283 = 4 * (int)v102;
          memcpy(v269, v306, v283);
          LODWORD(v326) = -1;
          if ((_DWORD)v300 == -1)
            v156 = 0;
          else
            v156 = (float *)(v152 + 4 * (int)v300);
          v157 = (float32x4_t *)&v281[4 * v153];
          if (v65 == v304)
            v157 = 0;
          v300 = v151;
          v259 = v156;
          v255 = quant_band_stereo((uint64_t)&v322, v151, v154, v305, v301, v282, v156, v22, v155, v157, v303, v292);
          if ((int)v305 < 1)
          {
            v162 = 0.0;
            v174 = 0.0;
            v158 = v291;
            v77 = v295;
            v163 = v300;
            v159 = v283;
            v160 = v261;
          }
          else
          {
            v158 = v291;
            v77 = v295;
            v159 = v283;
            v160 = v261;
            if (v305 < 8)
            {
              v161 = 0;
              v162 = 0.0;
              v163 = v300;
              goto LABEL_144;
            }
            v161 = v305 & 0xFFFFFFF8;
            v163 = v300;
            v175 = v300 + 1;
            v162 = 0.0;
            v176 = v161;
            v177 = v251;
            do
            {
              v178 = vmulq_f32(v177[-1], v175[-1]);
              v179 = vmulq_f32(*v177, *v175);
              v162 = (float)((float)((float)((float)((float)((float)((float)(v162 + v178.f32[0]) + v178.f32[1])
                                                           + v178.f32[2])
                                                   + v178.f32[3])
                                           + v179.f32[0])
                                   + v179.f32[1])
                           + v179.f32[2])
                   + v179.f32[3];
              v177 += 2;
              v175 += 2;
              v176 -= 8;
            }
            while (v176);
            if (v161 != v305)
            {
LABEL_144:
              v180 = v305 - v161;
              v181 = v161;
              v182 = &v163->f32[v161];
              v183 = &v270->f32[v181];
              do
              {
                v184 = *v183++;
                v185 = v184;
                v186 = *v182++;
                v162 = v162 + (float)(v185 * v186);
                --v180;
              }
              while (v180);
            }
            if (v305 < 8)
            {
              v187 = 0;
              v174 = 0.0;
              goto LABEL_151;
            }
            v187 = v305 & 0xFFFFFFF8;
            v188 = v306 + 1;
            v174 = 0.0;
            v189 = v187;
            v190 = v250;
            do
            {
              v191 = vmulq_f32(v190[-1], v188[-1]);
              v192 = vmulq_f32(*v190, *v188);
              v174 = (float)((float)((float)((float)((float)((float)((float)(v174 + v191.f32[0]) + v191.f32[1])
                                                           + v191.f32[2])
                                                   + v191.f32[3])
                                           + v192.f32[0])
                                   + v192.f32[1])
                           + v192.f32[2])
                   + v192.f32[3];
              v190 += 2;
              v188 += 2;
              v189 -= 8;
            }
            while (v189);
            if (v187 != v305)
            {
LABEL_151:
              v193 = v305 - v187;
              v194 = v187;
              v195 = &v306->f32[v187];
              v196 = &v269->f32[v194];
              do
              {
                v197 = *v196++;
                v198 = v197;
                v199 = *v195++;
                v174 = v174 + (float)(v198 * v199);
                --v193;
              }
              while (v193);
            }
          }
          v200 = *((_OWORD *)v158 + 1);
          v317 = *(_OWORD *)v158;
          v318 = v200;
          v319 = *((_OWORD *)v158 + 2);
          v320 = v158[6];
          v309 = v324;
          v310 = v325;
          v311 = v326;
          v307 = v322;
          v308 = v323;
          memcpy(v257, v163, v159);
          memcpy(v256, v306, v159);
          if (v65 != v304)
            memcpy(v252, &v281[4 * (*(__int16 *)(v287 + 2 * v65) << v22)], v159);
          v201 = v258;
          v202 = v260;
          v261 = &v160[(int)v258];
          v254 = v260 - (int)v258;
          __memcpy_chk();
          v203 = v291;
          *v291 = v160;
          *((_DWORD *)v203 + 2) = v202;
          *v266 = v321;
          *((_DWORD *)v203 + 7) = v201;
          v204 = v265;
          *v265 = v328;
          *((_QWORD *)v204 + 2) = v329;
          v324 = v314;
          v325 = v315;
          v326 = v316;
          v322 = v312;
          v323 = v313;
          memcpy(v300, v270, v159);
          memcpy(v306, v269, v159);
          if (v65 == v299)
          {
            v206 = *(_QWORD *)(v296 + 32);
            v207 = *(__int16 *)(v206 + 2 * v299);
            v208 = (v207 - *(__int16 *)(v206 + 2 * v298)) << v22;
            LODWORD(v206) = (*(__int16 *)(v206 + 2 * v268) - v207) << v22;
            memcpy(&v297->f32[v208], &v297->f32[2 * v208 - (int)v206], 4 * ((int)v206 - v208));
          }
          LODWORD(v326) = 1;
          v24 = v287;
          v75 = v301;
          if (v65 == v304)
            v209 = 0;
          else
            v209 = (float32x4_t *)&v281[4 * (*(__int16 *)(v287 + 2 * v65) << v22)];
          __dst = quant_band_stereo((uint64_t)&v322, v300, v306, v305, v301, v282, v259, v22, v205, v209, v303, v292);
          if ((int)v305 < 1)
          {
            v211 = 0.0;
            v213 = 0.0;
            v78 = v294;
            v212 = v300;
            v62 = v291;
          }
          else
          {
            v78 = v294;
            v62 = v291;
            if (v305 < 8)
            {
              v210 = 0;
              v211 = 0.0;
              v212 = v300;
              goto LABEL_167;
            }
            v210 = v305 & 0xFFFFFFF8;
            v212 = v300;
            v214 = v300 + 1;
            v211 = 0.0;
            v215 = v210;
            v216 = v251;
            do
            {
              v217 = vmulq_f32(v216[-1], v214[-1]);
              v218 = vmulq_f32(*v216, *v214);
              v211 = (float)((float)((float)((float)((float)((float)((float)(v211 + v217.f32[0]) + v217.f32[1])
                                                           + v217.f32[2])
                                                   + v217.f32[3])
                                           + v218.f32[0])
                                   + v218.f32[1])
                           + v218.f32[2])
                   + v218.f32[3];
              v216 += 2;
              v214 += 2;
              v215 -= 8;
            }
            while (v215);
            if (v210 != v305)
            {
LABEL_167:
              v219 = v305 - v210;
              v220 = v210;
              v221 = &v212->f32[v210];
              v222 = &v270->f32[v220];
              do
              {
                v223 = *v222++;
                v224 = v223;
                v225 = *v221++;
                v211 = v211 + (float)(v224 * v225);
                --v219;
              }
              while (v219);
            }
            if (v305 < 8)
            {
              v226 = 0;
              v213 = 0.0;
              goto LABEL_174;
            }
            v226 = v305 & 0xFFFFFFF8;
            v227 = v306 + 1;
            v213 = 0.0;
            v228 = v226;
            v229 = v250;
            do
            {
              v230 = vmulq_f32(v229[-1], v227[-1]);
              v231 = vmulq_f32(*v229, *v227);
              v213 = (float)((float)((float)((float)((float)((float)((float)(v213 + v230.f32[0]) + v230.f32[1])
                                                           + v230.f32[2])
                                                   + v230.f32[3])
                                           + v231.f32[0])
                                   + v231.f32[1])
                           + v231.f32[2])
                   + v231.f32[3];
              v229 += 2;
              v227 += 2;
              v228 -= 8;
            }
            while (v228);
            if (v226 != v305)
            {
LABEL_174:
              v232 = v305 - v226;
              v233 = v226;
              v234 = &v306->f32[v226];
              v235 = &v269->f32[v233];
              do
              {
                v236 = *v235++;
                v237 = v236;
                v238 = *v234++;
                v213 = v213 + (float)(v237 * v238);
                --v232;
              }
              while (v232);
            }
          }
          v239 = v147 + (float)(v149 / 3.0);
          v240 = v148 + (float)(v149 / 3.0);
          v58.f32[0] = (float)(v240 * v213) + (float)(v239 * v211);
          if ((float)((float)(v240 * v174) + (float)(v239 * v162)) >= v58.f32[0])
          {
            v241 = v318;
            *(_OWORD *)v62 = v317;
            *((_OWORD *)v62 + 1) = v241;
            *((_OWORD *)v62 + 2) = v319;
            v62[6] = v320;
            v324 = v309;
            v325 = v310;
            v326 = v311;
            v322 = v307;
            v323 = v308;
            v242 = v283;
            memcpy(v212, v257, v283);
            memcpy(v306, v256, v242);
            if (v65 != v304)
              memcpy(&v281[4 * (*(__int16 *)(v24 + 2 * v65) << v22)], v252, v242);
            memcpy(v261, v327, v254);
            __dst = v255;
            v62 = v291;
          }
          LODWORD(v300) = 0;
          result = __dst;
          v63 = (unint64_t)v297;
          v70 = v290;
          v71.i64[0] = 0x3F0000003F000000;
          v71.i64[1] = 0x3F0000003F000000;
          goto LABEL_34;
        }
        LODWORD(v326) = 0;
        if ((_DWORD)v109 == -1)
          v164 = 0;
        else
          v164 = (float *)(v63 + 4 * (int)v109);
        v165 = (float32x4_t *)&v281[4 * v141];
        if (v65 == v304)
          v165 = 0;
        v75 = v301;
        result = quant_band_stereo((uint64_t)&v322, v104, v306, v102, v301, v282, v164, v22, v58, v165, (float *)__dst, v110 | v111);
        v63 = (unint64_t)v297;
        LOBYTE(__dst) = result;
        LODWORD(v300) = 0;
        v70 = v290;
        v62 = v291;
        v71.i64[0] = 0x3F0000003F000000;
        v71.i64[1] = 0x3F0000003F000000;
      }
      else
      {
        if ((_DWORD)v109 == -1)
          v73 = 0;
        else
          v73 = (float *)(v63 + 4 * (int)v109);
        if (v65 == v304)
          v74 = 0;
        else
          v74 = (float32x4_t *)&v281[4 * v141];
        v58.i32[0] = 1.0;
        v75 = v301;
        result = quant_band((uint64_t)&v322, v104, v102, v301, v282, v73, v22, v74, v58, (float *)__dst, v110 | v111);
        v71.i64[0] = 0x3F0000003F000000;
        v71.i64[1] = 0x3F0000003F000000;
        v70 = v290;
        v62 = v291;
        v63 = (unint64_t)v297;
        LOBYTE(__dst) = result;
        LODWORD(v300) = 0;
      }
      v77 = v295;
      v78 = v294;
LABEL_34:
      *(_BYTE *)(a7 + (int)((_DWORD)v65 << v25)) = __dst;
      *(_BYTE *)(a7 + ((_DWORD)v65 << v25) + v25) = result;
      a15 = v293 + v78 + *(_DWORD *)(v286 + 4 * v65);
      v72 = v75 > 8 * (int)v305;
      DWORD2(v326) = 0;
      v65 = v77;
      if (v77 == v272)
      {
        v60 = DWORD2(v325);
        v23 = (_DWORD *)v247[0];
        goto LABEL_191;
      }
    }
    v111 = 0;
    v110 = 0;
    do
    {
LABEL_98:
      v111 |= *(unsigned __int8 *)(a7 + (v122 << v25));
      v110 |= *(unsigned __int8 *)(a7 + (v122 << v25) + v25);
      v26 = v122++ < v126;
    }
    while (v26);
    goto LABEL_99;
  }
LABEL_191:
  *v23 = v60;
  return result;
}

uint64_t quant_band(uint64_t a1, float32x4_t *a2, uint64_t a3, int a4, int a5, float *__src, int a7, float32x4_t *a8, float32x4_t a9, float *__dst, int a11)
{
  int v12;
  int v13;
  uint64_t *v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  int v24;
  unsigned int v25;
  unsigned __int32 v26;
  float *v27;
  int v31;
  uint64_t v32;
  unsigned int v33;
  float *v34;
  float32x4_t *v35;
  char v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  float32x4_t *v40;
  uint64_t v41;
  float *v42;
  float v43;
  uint64_t v44;
  float v45;
  uint64_t v46;
  float *v47;
  uint64_t v48;
  float *v49;
  float v50;
  uint64_t v51;
  float v52;
  int v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  float32x4_t *v58;
  float *v59;
  float *v60;
  float *v61;
  uint64_t v62;
  float v63;
  float v64;
  uint64_t v65;
  float *v66;
  float *v67;
  float *v68;
  float *v69;
  uint64_t v70;
  float v71;
  float v72;
  int v73;
  uint64_t v74;
  unsigned int v75;
  int v76;
  unsigned int v77;
  unsigned int v78;
  uint64_t v79;
  int v80;
  BOOL v81;
  int v82;
  int v83;
  uint64_t v84;
  char v85;
  uint64_t v86;
  float *v87;
  uint64_t v88;
  float32x4_t *v89;
  float *v90;
  float *v91;
  uint64_t v92;
  float v93;
  float v94;
  float32x4_t *v95;
  uint64_t v96;
  float v97;
  float32x4_t *v98;
  float32x4_t *v99;
  uint64_t v100;
  float32x4_t v101;
  uint64_t v102;
  uint64_t v103;
  float *v104;
  float *v105;
  float v106;
  uint64_t v107;
  uint64_t v108;
  float32x4_t *v109;
  uint64_t v110;
  float *v111;
  float v112;
  uint64_t v113;
  float v114;
  uint64_t v115;
  int v116;
  int v117;
  uint64_t v118;
  int v119;
  int v120;
  uint64_t v121;
  unsigned int v122;
  int v123;
  unsigned int v125;
  char v126;
  float32x4_t *v127;

  v12 = *(_DWORD *)a1;
  if ((_DWORD)a3 == 1)
  {
    v13 = *(_DWORD *)(a1 + 40);
    if (v13 < 8)
    {
      v37 = 1.0;
      if (!*(_DWORD *)(a1 + 4))
        goto LABEL_126;
    }
    else
    {
      v14 = *(uint64_t **)(a1 + 32);
      if (v12)
      {
        v15 = a2->f32[0] < 0.0;
        v16 = *((_DWORD *)v14 + 4);
        v17 = *((_DWORD *)v14 + 5);
        v18 = v17 + 1;
        if ((v17 + 1) >= 0x21)
        {
          do
          {
            v25 = *((_DWORD *)v14 + 2);
            v24 = *((_DWORD *)v14 + 3);
            if (v24 + *((_DWORD *)v14 + 7) < v25)
            {
              v20 = 0;
              v21 = *v14;
              v22 = v24 + 1;
              *((_DWORD *)v14 + 3) = v22;
              *(_BYTE *)(v21 + v25 - v22) = v16;
            }
            else
            {
              v20 = -1;
            }
            *((_DWORD *)v14 + 12) |= v20;
            v16 >>= 8;
            v19 = v17 - 8;
            v23 = v17 <= 15;
            v17 -= 8;
          }
          while (!v23);
          v18 = v19 + 1;
          v13 = *(_DWORD *)(a1 + 40);
        }
        else
        {
          v19 = *((_DWORD *)v14 + 5);
        }
        *((_DWORD *)v14 + 4) = (v15 << v19) | v16;
        *((_DWORD *)v14 + 5) = v18;
      }
      else
      {
        v75 = *((_DWORD *)v14 + 4);
        v76 = *((_DWORD *)v14 + 5);
        if (!v76)
        {
          v77 = *((_DWORD *)v14 + 2);
          v78 = *((_DWORD *)v14 + 3);
          if (v78 >= v77)
          {
            v80 = 0;
          }
          else
          {
            v79 = *v14;
            *((_DWORD *)v14 + 3) = ++v78;
            v80 = *(unsigned __int8 *)(v79 + v77 - v78);
          }
          if (v78 >= v77)
          {
            v116 = 0;
          }
          else
          {
            v115 = *v14;
            *((_DWORD *)v14 + 3) = ++v78;
            v116 = *(unsigned __int8 *)(v115 + v77 - v78) << 8;
          }
          v117 = v80 | v116;
          if (v78 >= v77)
          {
            v119 = 0;
          }
          else
          {
            v118 = *v14;
            *((_DWORD *)v14 + 3) = ++v78;
            v119 = *(unsigned __int8 *)(v118 + v77 - v78) << 16;
          }
          v120 = v117 | v119;
          if (v78 >= v77)
          {
            v123 = 0;
          }
          else
          {
            v121 = *v14;
            v122 = v78 + 1;
            *((_DWORD *)v14 + 3) = v122;
            v123 = *(unsigned __int8 *)(v121 + v77 - v122) << 24;
          }
          v75 |= v120 | v123;
          v76 = 32;
        }
        v15 = v75 & 1;
        *((_DWORD *)v14 + 4) = v75 >> 1;
        *((_DWORD *)v14 + 5) = v76 - 1;
      }
      ++*((_DWORD *)v14 + 6);
      *(_DWORD *)(a1 + 40) = v13 - 8;
      if (!*(_DWORD *)(a1 + 4))
        goto LABEL_126;
      v37 = -1.0;
      if (!v15)
        v37 = 1.0;
    }
    a2->f32[0] = v37;
LABEL_126:
    if (a8)
      a8->i32[0] = a2->i32[0];
    return 1;
  }
  v26 = a9.i32[0];
  v27 = __src;
  v31 = *(_DWORD *)(a1 + 28);
  v32 = v31 & ~(v31 >> 31);
  v33 = a3 / a5;
  if (!__src || (v34 = __dst) == 0)
  {
    v34 = __src;
    v36 = 1;
    if (v31 < 1)
      goto LABEL_36;
LABEL_18:
    v38 = 0;
    do
    {
      if (v12 && v38 != 31 && (int)a3 >> v38 >= 2)
      {
        v39 = 0;
        v40 = a2;
        do
        {
          v41 = 0;
          v42 = (float *)v40;
          do
          {
            v43 = *v42 * 0.70711;
            v44 = ((v41 + 1) << v38) + v39;
            v45 = a2->f32[v44] * 0.70711;
            *v42 = v43 + v45;
            a2->f32[v44] = v43 - v45;
            v41 += 2;
            v42 += (2 << v38);
          }
          while ((((int)a3 >> v38) & 0xFFFFFFFE) != v41);
          ++v39;
          v40 = (float32x4_t *)((char *)v40 + 4);
        }
        while (v39 != 1 << v38);
      }
      if (v34 && v38 != 31 && (int)a3 >> v38 >= 2)
      {
        v46 = 0;
        v47 = v34;
        do
        {
          v48 = 0;
          v49 = v47;
          do
          {
            v50 = *v49 * 0.70711;
            v51 = ((v48 + 1) << v38) + v46;
            v52 = v34[v51] * 0.70711;
            *v49 = v50 + v52;
            v34[v51] = v50 - v52;
            v48 += 2;
            v49 += (2 << v38);
          }
          while ((((int)a3 >> v38) & 0xFFFFFFFE) != v48);
          ++v46;
          ++v47;
        }
        while (v46 != 1 << v38);
      }
      a11 = quant_band_bit_interleave_table[a11 & 0xF] | (4 * quant_band_bit_interleave_table[a11 >> 4]);
      ++v38;
    }
    while (v38 != v32);
    v36 = 0;
LABEL_36:
    v27 = v34;
    v53 = 0;
    v54 = (a5 >> (v31 & ~(v31 >> 31)));
    v55 = v33 << (v31 & ~(v31 >> 31));
    v127 = a8;
    if ((v55 & 1) != 0)
      goto LABEL_74;
    goto LABEL_37;
  }
  if (v31 > 0 || ((v33 & 1) == 0 ? (v81 = v31 == 0) : (v81 = 1), v81 ? (v82 = 0) : (v82 = 1), a5 > 1 || v82))
  {
    v35 = a8;
    memcpy(__dst, __src, 4 * (int)a3);
    a8 = v35;
    v36 = 1;
    if (v31 < 1)
      goto LABEL_36;
    goto LABEL_18;
  }
  v36 = 1;
  v53 = 0;
  v54 = (a5 >> (v31 & ~(v31 >> 31)));
  v55 = v33 << (v31 & ~(v31 >> 31));
  v127 = a8;
  if ((v55 & 1) != 0)
  {
LABEL_74:
    v56 = v54;
    v73 = v55;
    v126 = v36;
    if ((int)v54 < 2)
      goto LABEL_75;
    goto LABEL_56;
  }
LABEL_37:
  if ((v31 & 0x80000000) == 0)
    goto LABEL_74;
  v53 = 0;
  do
  {
    v56 = (2 * v54);
    if (v12 && v55 >= 2 && (int)v54 >= 1)
    {
      v57 = 0;
      v58 = a2;
      v59 = &a2->f32[v54];
      do
      {
        v60 = (float *)v58;
        v61 = v59;
        v62 = v55 >> 1;
        do
        {
          v63 = *v60 * 0.70711;
          v64 = *v61 * 0.70711;
          *v60 = v63 + v64;
          *v61 = v63 - v64;
          v61 += 2 * v54;
          v60 += (2 * v54);
          --v62;
        }
        while (v62);
        ++v57;
        ++v59;
        v58 = (float32x4_t *)((char *)v58 + 4);
      }
      while (v57 != v54);
    }
    if (v27 && v55 >= 2 && (int)v54 >= 1)
    {
      v65 = 0;
      v66 = v27;
      v67 = &v27[v54];
      do
      {
        v68 = v66;
        v69 = v67;
        v70 = v55 >> 1;
        do
        {
          v71 = *v68 * 0.70711;
          v72 = *v69 * 0.70711;
          *v68 = v71 + v72;
          *v69 = v71 - v72;
          v69 += 2 * v54;
          v68 += (2 * v54);
          --v70;
        }
        while (v70);
        ++v65;
        ++v67;
        ++v66;
      }
      while (v65 != v54);
    }
    a11 |= a11 << v54;
    v73 = v55 >> 1;
    ++v53;
    if ((v55 & 2) != 0)
      break;
    v55 >>= 1;
    LODWORD(v54) = 2 * v54;
    v23 = v31++ < -1;
  }
  while (v23);
  v126 = v36;
  if ((int)v56 < 2)
  {
LABEL_75:
    a9.i32[0] = v26;
    v74 = quant_partition(a1, a2, a3, a4, v56, v27, a7, a11, a9);
    if (!*(_DWORD *)(a1 + 4))
      return v74;
    goto LABEL_76;
  }
LABEL_56:
  v125 = v73 >> v32;
  if (v12)
    deinterleave_hadamard((uint64_t)a2, v125);
  if (v27)
    deinterleave_hadamard((uint64_t)v27, v125);
  a9.i32[0] = v26;
  v74 = quant_partition(a1, a2, a3, a4, v56, v27, a7, a11, a9);
  if (*(_DWORD *)(a1 + 4))
  {
    interleave_hadamard((uint64_t)a2, v125);
LABEL_76:
    if (v53)
    {
      v83 = 0;
      v84 = v56;
      v85 = v126;
      do
      {
        v56 = ((int)v84 >> 1);
        if ((int)v84 >= 2 && 2 * v73 >= 2)
        {
          v86 = 0;
          v87 = &a2->f32[v56];
          v88 = (4 * v84) & 0x3FFFFFFF8;
          v89 = a2;
          do
          {
            v90 = (float *)v89;
            v91 = v87;
            v92 = v73 & 0x7FFFFFFF;
            do
            {
              v93 = *v90 * 0.70711;
              v94 = *v91 * 0.70711;
              *v90 = v93 + v94;
              *v91 = v93 - v94;
              v91 += 2 * v56;
              v90 = (float *)((char *)v90 + v88);
              --v92;
            }
            while (v92);
            ++v86;
            ++v87;
            v89 = (float32x4_t *)((char *)v89 + 4);
          }
          while (v86 != v56);
        }
        LODWORD(v74) = (v74 >> v56) | v74;
        ++v83;
        v73 *= 2;
        v84 = v56;
      }
      while (v83 != v53);
    }
    else
    {
      v85 = v126;
    }
    if ((v85 & 1) != 0)
    {
      v95 = v127;
    }
    else
    {
      v107 = 0;
      v95 = v127;
      do
      {
        LODWORD(v74) = quant_band_bit_deinterleave_table[v74];
        if (v107 != 31 && (int)a3 >> v107 >= 2)
        {
          v108 = 0;
          v109 = a2;
          do
          {
            v110 = 0;
            v111 = (float *)v109;
            do
            {
              v112 = *v111 * 0.70711;
              v113 = ((v110 + 1) << v107) + v108;
              v114 = a2->f32[v113] * 0.70711;
              *v111 = v112 + v114;
              a2->f32[v113] = v112 - v114;
              v110 += 2;
              v111 += (2 << v107);
            }
            while ((((int)a3 >> v107) & 0xFFFFFFFE) != v110);
            ++v108;
            v109 = (float32x4_t *)((char *)v109 + 4);
          }
          while (v108 != 1 << v107);
        }
        ++v107;
      }
      while (v107 != v32);
    }
    if (v95)
    {
      if ((int)a3 >= 1)
      {
        v96 = 0;
        v97 = sqrt((double)(int)a3);
        if (a3 < 8)
          goto LABEL_96;
        if ((unint64_t)((char *)v95 - (char *)a2) < 0x20)
          goto LABEL_96;
        v96 = a3 & 0x7FFFFFF8;
        v98 = a2 + 1;
        v99 = v95 + 1;
        v100 = a3 & 0xFFFFFFF8;
        do
        {
          v101 = vmulq_n_f32(*v98, v97);
          v99[-1] = vmulq_n_f32(v98[-1], v97);
          *v99 = v101;
          v98 += 2;
          v99 += 2;
          v100 -= 8;
        }
        while (v100);
        if (v96 != a3)
        {
LABEL_96:
          v102 = a3 - v96;
          v103 = v96;
          v104 = &v95->f32[v96];
          v105 = &a2->f32[v103];
          do
          {
            v106 = *v105++;
            *v104++ = v106 * v97;
            --v102;
          }
          while (v102);
        }
      }
    }
    return v74 & ~(-1 << ((_DWORD)v56 << v32));
  }
  return v74;
}

uint64_t quant_band_stereo(uint64_t a1, float32x4_t *a2, float32x4_t *a3, uint64_t a4, int a5, int a6, float *a7, int a8, float32x4_t a9, float32x4_t *a10, float *__dst, int a12)
{
  float32x4_t *v13;
  int v15;
  int v16;
  uint64_t *v17;
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  unsigned int v28;
  float32x4_t v31;
  int v32;
  float32x4_t v33;
  int v34;
  int v35;
  int v36;
  float32x4_t *v37;
  float *v38;
  float *v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  unsigned int v49;
  float v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  float32x4_t v58;
  int v59;
  float32x4_t *v60;
  int v61;
  BOOL v62;
  int v63;
  int v64;
  float32x4_t *v65;
  int v66;
  float v67;
  uint64_t v68;
  int v69;
  BOOL v70;
  int v71;
  int v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  uint64_t v77;
  int v78;
  float32x2_t *v79;
  float *v80;
  float *v81;
  unsigned int v82;
  unsigned int v83;
  int v84;
  unsigned int v85;
  unsigned int v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  int v90;
  int v91;
  uint64_t v92;
  int v93;
  int v94;
  uint64_t v95;
  unsigned int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  float v101;
  int v102;
  int v103;
  int v104;
  int v105;
  uint64_t v106;
  int v107;
  int v108;
  unsigned int v109;
  unsigned int v110;
  unsigned int v111;
  uint64_t v112;
  int v113;
  uint64_t v114;
  int v115;
  int v116;
  uint64_t v117;
  int v118;
  int v119;
  uint64_t v120;
  unsigned int v121;
  int v122;
  int v123;
  int v124;
  float32x2_t v125;
  float v126;
  float v127;
  uint64_t v128;
  float v129;
  float v130;
  float *v131;
  float *v132;
  uint64_t v133;
  float v134;
  uint64_t v135;
  uint64_t v136;
  float *v137;
  float *v138;
  float v139;
  float v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v147;
  float v148;
  uint64_t v149;
  uint64_t v150;
  float32x4_t *v151;
  float32x4_t *v152;
  float32x4_t v153;
  float32x4_t v154;
  uint64_t v155;
  uint64_t v156;
  float *v157;
  float *v158;
  float v159;
  float v160;
  uint64_t v161;
  float32x4_t *v162;
  uint64_t v163;
  float32x4_t v164;
  uint64_t v165;
  float *v166;
  uint64_t v167;
  int v168;
  int v169;
  uint64_t v170;
  int v171;
  int v172;
  uint64_t v173;
  unsigned int v174;
  int v175;
  float32x4_t *v177;
  float v178;
  unsigned int v179;
  float32x4_t v180;
  int v181;
  unsigned int v183;
  float32x2_t *v184;
  float v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  int v190[3];

  v13 = a2;
  v15 = a12;
  v190[0] = a5;
  v16 = *(_DWORD *)a1;
  v17 = *(uint64_t **)(a1 + 32);
  if ((_DWORD)a4 == 1)
  {
    v18 = *(_DWORD *)(a1 + 40);
    if (v18 < 8)
    {
      if (!*(_DWORD *)(a1 + 4))
      {
LABEL_158:
        if (a10)
          a10->i32[0] = a2->i32[0];
        return 1;
      }
      a2->i32[0] = 1065353216;
      v50 = 1.0;
    }
    else
    {
      if (v16)
      {
        v19 = a2->f32[0] < 0.0;
        v20 = *((_DWORD *)v17 + 4);
        v21 = *((_DWORD *)v17 + 5);
        v22 = v21 + 1;
        if ((v21 + 1) >= 0x21)
        {
          do
          {
            v28 = *((_DWORD *)v17 + 2);
            v27 = *((_DWORD *)v17 + 3);
            if (v27 + *((_DWORD *)v17 + 7) < v28)
            {
              v24 = 0;
              v25 = *v17;
              v26 = v27 + 1;
              *((_DWORD *)v17 + 3) = v26;
              *(_BYTE *)(v25 + v28 - v26) = v20;
            }
            else
            {
              v24 = -1;
            }
            *((_DWORD *)v17 + 12) |= v24;
            v20 >>= 8;
            v23 = v21 - 8;
            v62 = v21 <= 15;
            v21 -= 8;
          }
          while (!v62);
          v22 = v23 + 1;
          v18 = *(_DWORD *)(a1 + 40);
        }
        else
        {
          v23 = *((_DWORD *)v17 + 5);
        }
        v82 = (v19 << v23) | v20;
      }
      else
      {
        v73 = *((_DWORD *)v17 + 4);
        v74 = *((_DWORD *)v17 + 5);
        if (!v74)
        {
          v75 = *((_DWORD *)v17 + 2);
          v76 = *((_DWORD *)v17 + 3);
          if (v76 >= v75)
          {
            v78 = 0;
          }
          else
          {
            v77 = *v17;
            *((_DWORD *)v17 + 3) = ++v76;
            v78 = *(unsigned __int8 *)(v77 + v75 - v76);
          }
          if (v76 >= v75)
          {
            v90 = 0;
          }
          else
          {
            v89 = *v17;
            *((_DWORD *)v17 + 3) = ++v76;
            v90 = *(unsigned __int8 *)(v89 + v75 - v76);
          }
          v91 = v78 | (v90 << 8);
          if (v76 >= v75)
          {
            v93 = 0;
          }
          else
          {
            v92 = *v17;
            *((_DWORD *)v17 + 3) = ++v76;
            v93 = *(unsigned __int8 *)(v92 + v75 - v76) << 16;
          }
          v94 = v91 | v93;
          if (v76 >= v75)
          {
            v97 = 0;
          }
          else
          {
            v95 = *v17;
            v96 = v76 + 1;
            *((_DWORD *)v17 + 3) = v96;
            v97 = *(unsigned __int8 *)(v95 + v75 - v96) << 24;
          }
          v73 |= v94 | v97;
          v74 = 32;
        }
        v19 = v73 & 1;
        v82 = v73 >> 1;
        v22 = v74 - 1;
      }
      *((_DWORD *)v17 + 4) = v82;
      *((_DWORD *)v17 + 5) = v22;
      v98 = *((_DWORD *)v17 + 6) + 1;
      *((_DWORD *)v17 + 6) = v98;
      v99 = v18 - 8;
      *(_DWORD *)(a1 + 40) = v18 - 8;
      v100 = *(_DWORD *)(a1 + 4);
      if (v100)
      {
        v101 = -1.0;
        if (!v19)
          v101 = 1.0;
        a2->f32[0] = v101;
      }
      if (v18 < 16)
      {
        v102 = 0;
        if (!v100)
          goto LABEL_158;
      }
      else if (v16)
      {
        v102 = a3->f32[0] < 0.0;
        v103 = v22 + 1;
        if ((v22 + 1) >= 0x21)
        {
          do
          {
            v109 = *((_DWORD *)v17 + 2);
            v108 = *((_DWORD *)v17 + 3);
            if (v108 + *((_DWORD *)v17 + 7) < v109)
            {
              v105 = 0;
              v106 = *v17;
              v107 = v108 + 1;
              *((_DWORD *)v17 + 3) = v107;
              *(_BYTE *)(v106 + v109 - v107) = v82;
            }
            else
            {
              v105 = -1;
            }
            *((_DWORD *)v17 + 12) |= v105;
            v82 >>= 8;
            v104 = v22 - 8;
            v62 = v22 <= 15;
            v22 -= 8;
          }
          while (!v62);
          v103 = v104 + 1;
          v98 = *((_DWORD *)v17 + 6);
          v99 = *(_DWORD *)(a1 + 40);
          v100 = *(_DWORD *)(a1 + 4);
        }
        else
        {
          LOBYTE(v104) = v22;
        }
        *((_DWORD *)v17 + 4) = (v102 << v104) | v82;
        *((_DWORD *)v17 + 5) = v103;
        *((_DWORD *)v17 + 6) = v98 + 1;
        *(_DWORD *)(a1 + 40) = v99 - 8;
        if (!v100)
          goto LABEL_158;
      }
      else
      {
        if (!v22)
        {
          v110 = *((_DWORD *)v17 + 2);
          v111 = *((_DWORD *)v17 + 3);
          if (v111 >= v110)
          {
            v113 = 0;
          }
          else
          {
            v112 = *v17;
            *((_DWORD *)v17 + 3) = ++v111;
            v113 = *(unsigned __int8 *)(v112 + v110 - v111);
          }
          if (v111 >= v110)
          {
            v168 = 0;
          }
          else
          {
            v167 = *v17;
            *((_DWORD *)v17 + 3) = ++v111;
            v168 = *(unsigned __int8 *)(v167 + v110 - v111) << 8;
          }
          v169 = v113 | v168;
          if (v111 >= v110)
          {
            v171 = 0;
          }
          else
          {
            v170 = *v17;
            *((_DWORD *)v17 + 3) = ++v111;
            v171 = *(unsigned __int8 *)(v170 + v110 - v111) << 16;
          }
          v172 = v169 | v171;
          if (v111 >= v110)
          {
            v175 = 0;
          }
          else
          {
            v173 = *v17;
            v174 = v111 + 1;
            *((_DWORD *)v17 + 3) = v174;
            v175 = *(unsigned __int8 *)(v173 + v110 - v174) << 24;
          }
          v82 |= v172 | v175;
          v22 = 32;
        }
        v102 = v82 & 1;
        *((_DWORD *)v17 + 4) = v82 >> 1;
        *((_DWORD *)v17 + 5) = v22 - 1;
        *((_DWORD *)v17 + 6) = v98 + 1;
        *(_DWORD *)(a1 + 40) = v99 - 8;
        if (!v100)
          goto LABEL_158;
      }
      v50 = -1.0;
      if (!v102)
        v50 = 1.0;
    }
    a3->f32[0] = v50;
    goto LABEL_158;
  }
  v187 = 0;
  v188 = 0;
  v189 = 0;
  compute_theta((int *)a1, (uint64_t)&v187, a2, a3, a4, v190, a6, a6, a9, a8, 1, &a12);
  v32 = v189;
  v33.f32[0] = (float)(int)v188 * 0.000030518;
  v181 = v187;
  v186 = (float)SHIDWORD(v187) * 0.000030518;
  v184 = (float32x2_t *)v13;
  if ((_DWORD)a4 == 2)
  {
    v34 = v189 & 0xFFFFBFFF;
    if ((v189 & 0xFFFFBFFF) != 0)
      v35 = -8;
    else
      v35 = 0;
    v36 = v190[0] + v35;
    *(_DWORD *)(a1 + 40) += v35 - HIDWORD(v189);
    v37 = v13;
    if (v32 <= 0x2000)
    {
      v38 = (float *)a3;
    }
    else
    {
      v13 = a3;
      v38 = (float *)v37;
    }
    v178 = v33.f32[0];
    if (v34)
    {
      if (v16)
      {
        v39 = v38;
        v40 = (float)((float)(v13->f32[0] * v38[1]) - (float)(v13->f32[1] * *v38)) < 0.0;
        v41 = *((_DWORD *)v17 + 4);
        v42 = *((_DWORD *)v17 + 5);
        v43 = v42 + 1;
        if ((v42 + 1) >= 0x21)
        {
          do
          {
            v49 = *((_DWORD *)v17 + 2);
            v48 = *((_DWORD *)v17 + 3);
            if (v48 + *((_DWORD *)v17 + 7) < v49)
            {
              v45 = 0;
              v46 = *v17;
              v47 = v48 + 1;
              *((_DWORD *)v17 + 3) = v47;
              *(_BYTE *)(v46 + v49 - v47) = v41;
            }
            else
            {
              v45 = -1;
            }
            *((_DWORD *)v17 + 12) |= v45;
            v41 >>= 8;
            v44 = v42 - 8;
            v62 = v42 <= 15;
            v42 -= 8;
          }
          while (!v62);
          v43 = v44 + 1;
        }
        else
        {
          v44 = *((_DWORD *)v17 + 5);
        }
        *((_DWORD *)v17 + 4) = (v40 << v44) | v41;
        *((_DWORD *)v17 + 5) = v43;
        v81 = __dst;
        v80 = a7;
      }
      else
      {
        v83 = *((_DWORD *)v17 + 4);
        v84 = *((_DWORD *)v17 + 5);
        if (v84)
        {
          v39 = v38;
        }
        else
        {
          v85 = *((_DWORD *)v17 + 2);
          v86 = *((_DWORD *)v17 + 3);
          v39 = v38;
          if (v86 >= v85)
          {
            v88 = 0;
          }
          else
          {
            v87 = *v17;
            *((_DWORD *)v17 + 3) = ++v86;
            v88 = *(unsigned __int8 *)(v87 + v85 - v86);
          }
          if (v86 >= v85)
          {
            v115 = 0;
          }
          else
          {
            v114 = *v17;
            *((_DWORD *)v17 + 3) = ++v86;
            v115 = *(unsigned __int8 *)(v114 + v85 - v86) << 8;
          }
          v116 = v88 | v115;
          if (v86 >= v85)
          {
            v118 = 0;
          }
          else
          {
            v117 = *v17;
            *((_DWORD *)v17 + 3) = ++v86;
            v118 = *(unsigned __int8 *)(v117 + v85 - v86) << 16;
          }
          v119 = v116 | v118;
          if (v86 >= v85)
          {
            v122 = 0;
          }
          else
          {
            v120 = *v17;
            v121 = v86 + 1;
            *((_DWORD *)v17 + 3) = v121;
            v122 = *(unsigned __int8 *)(v120 + v85 - v121) << 24;
          }
          v83 |= v119 | v122;
          v84 = 32;
        }
        v81 = __dst;
        v80 = a7;
        v40 = v83 & 1;
        *((_DWORD *)v17 + 4) = v83 >> 1;
        *((_DWORD *)v17 + 5) = v84 - 1;
      }
      v79 = (float32x2_t *)a3;
      ++*((_DWORD *)v17 + 6);
    }
    else
    {
      v39 = v38;
      v79 = (float32x2_t *)a3;
      v40 = 0;
      v81 = __dst;
      v80 = a7;
    }
    v123 = 2 * v40 - 1;
    v124 = 1 - 2 * v40;
    v31.i32[0] = 1.0;
    v68 = quant_band(a1, v13, 2, v36, a6, v80, a8, a10, v31, v81, v15);
    *v39 = v13->f32[1] * (float)v123;
    v39[1] = v13->f32[0] * (float)v124;
    if (!*(_DWORD *)(a1 + 4))
      return v68;
    v65 = (float32x4_t *)v184;
    v67 = v186;
    *v184 = vmul_n_f32(*v184, v186);
    v60 = (float32x4_t *)v79;
    v125 = vmul_n_f32(*v79, v178);
    *v79 = v125;
    v126 = v184->f32[0];
    v184->f32[0] = v184->f32[0] - v125.f32[0];
    v127 = v79->f32[1];
    v79->f32[0] = v126 + v79->f32[0];
    v125.i32[0] = v184->i32[1];
    v184->f32[1] = v125.f32[0] - v127;
    v79->f32[1] = v125.f32[0] + v79->f32[1];
    if (!*(_DWORD *)(a1 + 4))
      return v68;
  }
  else
  {
    v177 = a3;
    v51 = v190[0];
    v52 = v190[0] - HIDWORD(v188);
    if (v190[0] < SHIDWORD(v188))
      ++v52;
    v53 = v52 >> 1;
    if (v190[0] < v53)
      v53 = v190[0];
    v54 = v53 & ~(v53 >> 31);
    v55 = v190[0] - v54;
    v56 = *(_DWORD *)(a1 + 40) - HIDWORD(v189);
    *(_DWORD *)(a1 + 40) = v56;
    v57 = a12;
    if (v54 >= v51 - v54)
    {
      v31.i32[0] = 1.0;
      v180 = v33;
      v183 = quant_band(a1, (float32x4_t *)v184, a4, v53 & ~(v53 >> 31), a6, a7, a8, a10, v31, __dst, a12);
      v69 = *(_DWORD *)(a1 + 40) - v56 + v54;
      v65 = (float32x4_t *)v184;
      if (v32)
        v70 = v69 <= 24;
      else
        v70 = 1;
      if (v70)
        v71 = 0;
      else
        v71 = v69 - 24;
      v60 = v177;
      v72 = quant_band(a1, v177, a4, v71 + v55, a6, 0, a8, 0, v180, 0, v57 >> a6);
      v67 = v186;
      v68 = v72 | v183;
      if (!*(_DWORD *)(a1 + 4))
        return v68;
    }
    else
    {
      v31.i32[0] = v33.i32[0];
      v179 = quant_band(a1, v177, a4, v51 - v54, a6, 0, a8, 0, v31, 0, a12 >> a6);
      v59 = *(_DWORD *)(a1 + 40) - v56;
      v60 = v177;
      v61 = v59 + v55;
      v62 = v32 == 0x4000 || v61 <= 24;
      if (v62)
        v63 = 0;
      else
        v63 = v61 - 24;
      v64 = v63 + v54;
      v58.i32[0] = 1.0;
      v65 = (float32x4_t *)v184;
      v66 = quant_band(a1, (float32x4_t *)v184, a4, v64, a6, a7, a8, a10, v58, __dst, v57);
      v67 = v186;
      v68 = v66 | v179;
      if (!*(_DWORD *)(a1 + 4))
        return v68;
    }
  }
  if ((_DWORD)a4 == 2)
    goto LABEL_133;
  if ((int)a4 < 1)
  {
    v130 = 0.0;
    v129 = 0.0;
    goto LABEL_119;
  }
  if ((_DWORD)a4 == 1)
  {
    v128 = 0;
    v129 = 0.0;
    v130 = 0.0;
LABEL_117:
    v135 = a4 - v128;
    v136 = v128;
    v137 = &v65->f32[v128];
    v138 = &v60->f32[v136];
    do
    {
      v139 = *v138++;
      v140 = v139;
      v141 = *v137++;
      v130 = v130 + (float)(v140 * v141);
      v129 = v129 + (float)(v140 * v140);
      --v135;
    }
    while (v135);
    goto LABEL_119;
  }
  v128 = a4 & 0xFFFFFFFE;
  v131 = &v60->f32[1];
  v132 = &v65->f32[1];
  v129 = 0.0;
  v133 = v128;
  v130 = 0.0;
  do
  {
    v134 = *(v131 - 1);
    v129 = (float)(v129 + (float)(v134 * v134)) + (float)(*v131 * *v131);
    v130 = (float)(v130 + (float)(v134 * *(v132 - 1))) + (float)(*v131 * *v132);
    v131 += 2;
    v132 += 2;
    v133 -= 2;
  }
  while (v133);
  if (v128 != a4)
    goto LABEL_117;
LABEL_119:
  v142 = v67 * v130;
  v143 = v129 + (float)(v67 * v67);
  v144 = v143 + (float)(v142 * -2.0);
  v145 = v143 + (float)(v142 * 2.0);
  if (v145 < 0.0006 || v144 < 0.0006)
  {
    memcpy(v60, v65, 4 * (int)a4);
    goto LABEL_133;
  }
  if ((int)a4 < 1)
    return v68;
  v147 = 1.0 / sqrtf(v144);
  v148 = 1.0 / sqrtf(v145);
  if (a4 < 4)
  {
    v149 = 0;
LABEL_131:
    v155 = a4 - v149;
    v156 = v149;
    v157 = &v60->f32[v149];
    v158 = &v65->f32[v156];
    do
    {
      v159 = v67 * *v158;
      v160 = *v157;
      *v158++ = v147 * (float)(v159 - *v157);
      *v157++ = v148 * (float)(v159 + v160);
      --v155;
    }
    while (v155);
    goto LABEL_133;
  }
  v149 = a4 & 0xFFFFFFFC;
  v150 = v149;
  v151 = v60;
  v152 = v65;
  do
  {
    v153 = vmulq_n_f32(*v152, v67);
    v154 = *v151;
    *v152++ = vmulq_n_f32(vsubq_f32(v153, *v151), v147);
    *v151++ = vmulq_n_f32(vaddq_f32(v153, v154), v148);
    v150 -= 4;
  }
  while (v150);
  if (v149 != a4)
    goto LABEL_131;
LABEL_133:
  if ((int)a4 >= 1 && v181)
  {
    if (a4 >= 8)
    {
      v161 = a4 & 0xFFFFFFF8;
      v162 = v60 + 1;
      v163 = v161;
      do
      {
        v164 = vnegq_f32(*v162);
        v162[-1] = vnegq_f32(v162[-1]);
        *v162 = v164;
        v162 += 2;
        v163 -= 8;
      }
      while (v163);
      if (v161 == a4)
        return v68;
    }
    else
    {
      v161 = 0;
    }
    v165 = a4 - v161;
    v166 = &v60->f32[v161];
    do
    {
      *v166 = -*v166;
      ++v166;
      --v165;
    }
    while (v165);
  }
  return v68;
}

void *deinterleave_hadamard(uint64_t a1, uint64_t a2)
{
  void *v2;
  unsigned int v3;
  int v4;
  int v5;
  uint64_t v6;
  char *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  _DWORD *v20;
  int v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  _DWORD *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  _DWORD *v33;
  int v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  _QWORD v39[2];

  v39[1] = *MEMORY[0x24BDAC8D0];
  v2 = (void *)MEMORY[0x24BDAC7A8](a1, a2);
  v7 = (char *)v39 - v6;
  if (!v8)
  {
    if ((int)v3 < 1 || v4 < 1)
      return memcpy(v2, v7, 4 * v5);
    v25 = 0;
    v26 = 0;
    v27 = v7 + 4;
    v28 = 4 * v4;
    v29 = v2;
    while (1)
    {
      if (v3 >= 2)
      {
        v31 = v27;
        v32 = v3 & 0xFFFFFFFE;
        v33 = v29;
        do
        {
          v34 = v33[v4];
          *((_DWORD *)v31 - 1) = *v33;
          *(_DWORD *)v31 = v34;
          v33 += 2 * v4;
          v31 += 8;
          v32 -= 2;
        }
        while (v32);
        v30 = v3 & 0xFFFFFFFE;
        if (v30 == v3)
          goto LABEL_17;
      }
      else
      {
        v30 = 0;
      }
      v35 = v3 - v30;
      v36 = &v7[4 * v30 + 4 * v25];
      v37 = v28 * v30;
      do
      {
        *(_DWORD *)v36 = *(_DWORD *)((char *)v29 + v37);
        v36 += 4;
        v37 += v28;
        --v35;
      }
      while (v35);
LABEL_17:
      ++v26;
      ++v29;
      v27 += 4 * v3;
      v25 += v3;
      if (v26 == v4)
        return memcpy(v2, v7, 4 * v5);
    }
  }
  if ((int)v3 >= 1 && v4 >= 1)
  {
    v9 = 0;
    v10 = v4;
    v11 = v4;
    v12 = (char *)&ordery_table + 4 * v4 - 8;
    v13 = 8 * v4;
    v14 = 4 * v4;
    v15 = v2;
    do
    {
      v16 = *(int *)&v12[4 * v9] * (uint64_t)(int)v3;
      if (v3 >= 2)
      {
        v18 = &v7[4 * v16 + 4];
        v19 = v3 & 0xFFFFFFFE;
        v20 = v15;
        do
        {
          v21 = v20[v10];
          *((_DWORD *)v18 - 1) = *v20;
          *(_DWORD *)v18 = v21;
          v20 = (_DWORD *)((char *)v20 + v13);
          v18 += 8;
          v19 -= 2;
        }
        while (v19);
        v17 = v3 & 0xFFFFFFFE;
        if (v17 == v3)
          goto LABEL_5;
      }
      else
      {
        v17 = 0;
      }
      v22 = v3 - v17;
      v23 = &v7[4 * v17 + 4 * v16];
      v24 = v14 * v17;
      do
      {
        *(_DWORD *)v23 = *(_DWORD *)((char *)v15 + v24);
        v23 += 4;
        v24 += v14;
        --v22;
      }
      while (v22);
LABEL_5:
      ++v9;
      ++v15;
    }
    while (v9 != v11);
  }
  return memcpy(v2, v7, 4 * v5);
}

uint64_t quant_partition(uint64_t a1, float32x4_t *a2, uint64_t a3, int a4, int a5, float *a6, int a7, unsigned int a8, float32x4_t a9)
{
  char v9;
  float v13;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float32x4_t *v27;
  int v28;
  uint64_t v29;
  int v30;
  int v31;
  BOOL v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  unint64_t v36;
  int v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  unsigned int v43;
  int v44;
  uint64_t result;
  uint64_t v46;
  int v47;
  float *v48;
  uint64_t v49;
  float v50;
  float v51;
  int v52;
  int v53;
  float v54;
  float v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  BOOL v60;
  int v61;
  int v62;
  uint64_t v63;
  int v64;
  int v65;
  float *v66;
  int v67;
  int v69;
  int v70;
  BOOL v71;
  int v72;
  int v73;
  float *v74;
  uint64_t v75;
  uint64_t v76;
  float v77;
  float *v78;
  uint64_t v79;
  uint64_t v80;
  float *v81;
  float v82;
  float v83;
  uint64_t v84;
  float *v85;
  float32x4_t *v86;
  uint64_t v87;
  float32x4_t v88;
  int v89;
  int v90;
  float32x4_t *v91;
  unsigned int v92;
  unsigned int v93;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unsigned int v99;
  int v100;

  v9 = a7;
  v13 = a9.f32[0];
  v99 = a8;
  v100 = a4;
  v16 = *(_DWORD *)a1;
  v17 = *(_QWORD *)(a1 + 8);
  v18 = *(int *)(a1 + 16);
  v19 = *(_DWORD *)(a1 + 24);
  v20 = *(_QWORD *)(a1 + 32);
  v22 = *(_QWORD *)(v17 + 136);
  v21 = *(_QWORD *)(v17 + 144);
  if (a7 == -1)
  {
    v23 = *(__int16 *)(v22 + 2 * v18);
    v24 = v21 + v23;
    v25 = *(unsigned __int8 *)(v21 + v23);
  }
  else
  {
    v23 = *(__int16 *)(v22 + 2 * (*(_DWORD *)(v17 + 8) + *(_DWORD *)(v17 + 8) * a7 + (int)v18));
    v24 = v21 + v23;
    v25 = *(unsigned __int8 *)(v21 + v23);
    if ((int)a3 >= 3 && *(unsigned __int8 *)(v24 + v25) + 12 < a4)
    {
      v96 = 0;
      v97 = 0;
      v98 = 0;
      v26 = a3 >> 1;
      v27 = (float32x4_t *)((char *)a2 + 4 * v26);
      v28 = a7 - 1;
      v93 = a7 - 1;
      v91 = v27;
      if (a5 == 1)
      {
        v99 = a8 & 1 | (2 * a8);
        v29 = 1;
        compute_theta((int *)a1, (uint64_t)&v96, a2, v27, v26, &v100, 1, 1, a9, v28, 0, &v99);
      }
      else
      {
        v29 = ((a5 + 1) >> 1);
        compute_theta((int *)a1, (uint64_t)&v96, a2, v27, v26, &v100, (a5 + 1) >> 1, a5, a9, v28, 0, &v99);
      }
      v52 = HIDWORD(v97);
      v53 = v98;
      v54 = (float)SHIDWORD(v96) * 0.000030518;
      v55 = (float)(int)v97 * 0.000030518;
      v56 = (HIDWORD(v97) + ((8 * (int)v26) >> (6 - v9))) & ((HIDWORD(v97) + ((8 * (int)v26) >> (6 - v9))) >> 31);
      if ((int)v98 > 0x2000)
        v56 = HIDWORD(v97) - (SHIDWORD(v97) >> (5 - v9));
      if ((v98 & 0x3FFF) != 0)
        v57 = v56;
      else
        v57 = HIDWORD(v97);
      if (a5 >= 2)
        v52 = v57;
      v59 = v99;
      v58 = v100;
      v60 = __OFSUB__(v100, v52);
      v61 = v100 - v52;
      if (v61 < 0 != v60)
        ++v61;
      v62 = v61 >> 1;
      if (v100 < v62)
        v62 = v100;
      v63 = v62 & ~(v62 >> 31);
      v64 = v100 - v63;
      v90 = a5;
      v65 = *(_DWORD *)(a1 + 40) - HIDWORD(v98);
      *(_DWORD *)(a1 + 40) = v65;
      if (a6)
        v66 = &a6[v26];
      else
        v66 = 0;
      if ((int)v63 >= v64)
      {
        v95 = quant_partition(a1, a2, v26, v63, v29, a6, v93, v59, v54 * v13);
        v70 = *(_DWORD *)(a1 + 40) - v65 + v63;
        if (v53)
          v71 = v70 <= 24;
        else
          v71 = 1;
        if (v71)
          v72 = 0;
        else
          v72 = v70 - 24;
        return (quant_partition(a1, v91, v26, (v72 + v64), v29, v66, v93, ((int)v59 >> v29), v55 * v13) << (v90 >> 1)) | v95;
      }
      else
      {
        v92 = quant_partition(a1, v91, v26, (v58 - v63), v29, v66, v93, ((int)v59 >> v29), v55 * v13) << (v90 >> 1);
        v67 = *(_DWORD *)(a1 + 40) - v65 + v64;
        if (v53 == 0x4000 || v67 <= 24)
          v69 = 0;
        else
          v69 = v67 - 24;
        return quant_partition(a1, a2, v26, (v69 + v63), v29, a6, v93, v59, v54 * v13) | v92;
      }
    }
  }
  v30 = a4 - 1;
  v31 = *(unsigned __int8 *)(v24 + ((unint64_t)(v25 + 1) >> 1));
  v32 = v30 <= v31;
  if (v30 <= v31)
    v33 = 0;
  else
    v33 = (unint64_t)(v25 + 1) >> 1;
  if (v32)
    LODWORD(v25) = (unint64_t)(v25 + 1) >> 1;
  if (v30 <= *(unsigned __int8 *)(v24 + ((unint64_t)(v33 + v25 + 1) >> 1)))
    LODWORD(v25) = (v33 + v25 + 1) >> 1;
  else
    v33 = (v33 + v25 + 1) >> 1;
  if (v30 <= *(unsigned __int8 *)(v24 + ((unint64_t)(v33 + v25 + 1) >> 1)))
    LODWORD(v25) = (v33 + v25 + 1) >> 1;
  else
    v33 = (v33 + v25 + 1) >> 1;
  if (v30 <= *(unsigned __int8 *)(v24 + ((unint64_t)(v33 + v25 + 1) >> 1)))
    LODWORD(v25) = (v33 + v25 + 1) >> 1;
  else
    v33 = (v33 + v25 + 1) >> 1;
  v34 = *(unsigned __int8 *)(v24 + ((unint64_t)(v33 + v25 + 1) >> 1));
  if (v30 <= v34)
    v35 = v33;
  else
    v35 = (v33 + v25 + 1) >> 1;
  if (v30 <= v34)
    LODWORD(v25) = (v33 + v25 + 1) >> 1;
  v36 = (unint64_t)(v35 + v25 + 1) >> 1;
  v37 = *(unsigned __int8 *)(v24 + v36);
  if (v30 <= v37)
    v38 = v35;
  else
    v38 = (v35 + v25 + 1) >> 1;
  if (v38)
    v39 = *(unsigned __int8 *)(v24 + v38);
  else
    v39 = -1;
  if (v30 <= v37)
    LODWORD(v25) = v36;
  if (v30 - v39 <= *(unsigned __int8 *)(v24 + v25) - v30)
    v40 = v38;
  else
    v40 = v25;
  if (!v40)
  {
LABEL_47:
    if (!*(_DWORD *)(a1 + 4))
      return 0;
    v46 = (1 << a5) - 1;
    result = v46 & a8;
    if ((v46 & a8) == 0)
    {
      bzero(a2, 4 * (int)a3);
      return 0;
    }
    if (a6)
    {
      if ((int)a3 < 1)
        return result;
      v47 = *(_DWORD *)(a1 + 56);
      v48 = (float *)a2;
      v49 = a3;
      do
      {
        v47 = 1664525 * v47 + 1013904223;
        v50 = 0.0039062;
        if ((v47 & 0x8000) == 0)
          v50 = -0.0039062;
        v51 = *a6++;
        *v48++ = v51 + v50;
        --v49;
      }
      while (v49);
      *(_DWORD *)(a1 + 56) = v47;
      v46 = v46 & a8;
    }
    else
    {
      if ((int)a3 < 1)
        return v46;
      v73 = *(_DWORD *)(a1 + 56);
      v74 = (float *)a2;
      v75 = a3;
      do
      {
        v73 = 1664525 * v73 + 1013904223;
        *v74++ = (float)(v73 >> 20);
        --v75;
      }
      while (v75);
      *(_DWORD *)(a1 + 56) = v73;
    }
    if ((_DWORD)a3 == 1)
    {
      v76 = 0;
      v77 = 0.0;
    }
    else
    {
      v76 = a3 & 0xFFFFFFFE;
      v78 = &a2->f32[1];
      v77 = 0.0;
      v79 = v76;
      do
      {
        v77 = (float)(v77 + (float)(*(v78 - 1) * *(v78 - 1))) + (float)(*v78 * *v78);
        v78 += 2;
        v79 -= 2;
      }
      while (v79);
      if (v76 == a3)
        goto LABEL_100;
    }
    v80 = a3 - v76;
    v81 = &a2->f32[v76];
    do
    {
      v82 = *v81++;
      v77 = v77 + (float)(v82 * v82);
      --v80;
    }
    while (v80);
LABEL_100:
    v83 = (float)(1.0 / sqrtf(v77 + 1.0e-15)) * v13;
    if (a3 >= 8)
    {
      v84 = a3 & 0xFFFFFFF8;
      v85 = &a2->f32[v84];
      v86 = a2 + 1;
      v87 = v84;
      do
      {
        v88 = vmulq_n_f32(*v86, v83);
        v86[-1] = vmulq_n_f32(v86[-1], v83);
        *v86 = v88;
        v86 += 2;
        v87 -= 8;
      }
      while (v87);
      if (v84 == a3)
        return v46;
    }
    else
    {
      LODWORD(v84) = 0;
      v85 = (float *)a2;
    }
    v89 = a3 - v84;
    do
    {
      *v85 = v83 * *v85;
      ++v85;
      --v89;
    }
    while (v89);
    return v46;
  }
  v41 = *(unsigned __int8 *)(v21 + v23 + v40) + 1;
  v42 = *(_DWORD *)(a1 + 40) - v41;
  *(_DWORD *)(a1 + 40) = v42;
  if (v42 < 0)
  {
    v43 = v40 - 1;
    do
    {
      v44 = v42 + v41;
      *(_DWORD *)(a1 + 40) = v44;
      if (!v43)
        goto LABEL_47;
      v41 = *(unsigned __int8 *)(v21 + *(__int16 *)(v22 + 2 * ((int)v18 + *(_DWORD *)(v17 + 8) * (a7 + 1))) + v43) + 1;
      v42 = v44 - v41;
      *(_DWORD *)(a1 + 40) = v42;
      --v43;
      --v40;
    }
    while (v42 < 0);
  }
  if (v40 >= 8)
    v40 = (v40 & 7 | 8) << ((v40 >> 3) - 1);
  if (v16)
    return alg_quant(a2, a3, v40, v19, a5, v20, *(_DWORD *)(a1 + 4), a9.f32[0]);
  else
    return alg_unquant((uint64_t)a2, a3, v40, v19, a5, a9.f32[0]);
}

void *interleave_hadamard(uint64_t a1, uint64_t a2)
{
  char *v2;
  unsigned int v3;
  int v4;
  int v5;
  uint64_t v6;
  char *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  _DWORD *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  _DWORD *v30;
  uint64_t v31;
  int *v32;
  _DWORD *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  int v39;
  _QWORD v41[2];

  v41[1] = *MEMORY[0x24BDAC8D0];
  v2 = (char *)MEMORY[0x24BDAC7A8](a1, a2);
  v7 = (char *)v41 - v6;
  if (!v8)
  {
    if ((int)v3 < 1 || v4 < 1)
      return memcpy(v2, v7, 4 * v5);
    v26 = 0;
    v27 = 0;
    v28 = (int *)(v2 + 4);
    v29 = 4 * v4;
    v30 = v7;
    while (1)
    {
      if (v3 >= 2)
      {
        v32 = v28;
        v33 = v30;
        v34 = v3 & 0xFFFFFFFE;
        do
        {
          v35 = *v32;
          *v33 = *(v32 - 1);
          v33[v4] = v35;
          v33 += 2 * v4;
          v32 += 2;
          v34 -= 2;
        }
        while (v34);
        v31 = v3 & 0xFFFFFFFE;
        if (v31 == v3)
          goto LABEL_17;
      }
      else
      {
        v31 = 0;
      }
      v36 = v3 - v31;
      v37 = v29 * v31;
      v38 = &v2[4 * v31 + 4 * v26];
      do
      {
        v39 = *(_DWORD *)v38;
        v38 += 4;
        *(_DWORD *)((char *)v30 + v37) = v39;
        v37 += v29;
        --v36;
      }
      while (v36);
LABEL_17:
      ++v27;
      ++v30;
      v28 += v3;
      v26 += v3;
      if (v27 == v4)
        return memcpy(v2, v7, 4 * v5);
    }
  }
  if ((int)v3 >= 1 && v4 >= 1)
  {
    v9 = 0;
    v10 = v4;
    v11 = v4;
    v12 = (char *)&ordery_table + 4 * v4 - 8;
    v13 = 8 * v4;
    v14 = 4 * v4;
    v15 = v7;
    do
    {
      v16 = *(int *)&v12[4 * v9] * (uint64_t)(int)v3;
      if (v3 >= 2)
      {
        v18 = &v2[4 * v16 + 4];
        v19 = v15;
        v20 = v3 & 0xFFFFFFFE;
        do
        {
          v21 = *(_DWORD *)v18;
          *v19 = *((_DWORD *)v18 - 1);
          v19[v10] = v21;
          v19 = (_DWORD *)((char *)v19 + v13);
          v18 += 8;
          v20 -= 2;
        }
        while (v20);
        v17 = v3 & 0xFFFFFFFE;
        if (v17 == v3)
          goto LABEL_5;
      }
      else
      {
        v17 = 0;
      }
      v22 = v3 - v17;
      v23 = v14 * v17;
      v24 = &v2[4 * v17 + 4 * v16];
      do
      {
        v25 = *(_DWORD *)v24;
        v24 += 4;
        *(_DWORD *)((char *)v15 + v23) = v25;
        v23 += v14;
        --v22;
      }
      while (v22);
LABEL_5:
      ++v9;
      ++v15;
    }
    while (v9 != v11);
  }
  return memcpy(v2, v7, 4 * v5);
}

unint64_t compute_theta(int *a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, int a5, int *a6, char a7, int a8, float32x4_t a9, int a10, int a11, _DWORD *a12)
{
  _DWORD *v15;
  int v16;
  uint64_t v17;
  unint64_t result;
  uint64_t v19;
  uint64_t v20;
  int v21;
  _BOOL4 v22;
  _BOOL4 v23;
  BOOL v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  float v34;
  float v35;
  int v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  _BOOL4 v41;
  uint64_t v42;
  float v43;
  int v44;
  int v45;
  int v46;
  int v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  BOOL v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  BOOL v58;
  int v59;
  int v60;
  int v61;
  int v62;
  unsigned int v63;
  unint64_t v64;
  int v65;
  int v66;
  unint64_t v67;
  uint64_t v68;
  int v69;
  float *v70;
  float *v71;
  uint64_t v72;
  float v73;
  float v74;
  uint64_t v75;
  uint64_t v76;
  float *v77;
  float *v78;
  float v79;
  float v80;
  float v81;
  int v82;
  int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  int v88;
  unsigned int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  unsigned int v94;
  float *v95;
  uint64_t v96;
  uint64_t v97;
  float *v98;
  float v99;
  uint64_t v100;
  float v101;
  float *v102;
  uint64_t v103;
  uint64_t v104;
  float *v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  int v116;
  unsigned int v117;
  int v118;
  uint64_t v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int *v125;
  char v126;
  int v127;
  int v128;
  unsigned int v129;
  unsigned int v130;
  int v131;
  unsigned int v132;
  int v133;
  int v134;
  int v135;
  int32x2_t v136;
  unsigned int v137;
  int v138;
  int v139;
  BOOL v140;
  int32x2_t v141;
  int32x2_t v142;
  int32x2_t v143;
  int32x2_t v144;
  int32x2_t v145;
  int32x2_t v146;
  uint32x2_t v147;
  int v148;
  float v149;
  float v150;
  float v151;
  float v152;
  uint64_t v153;
  float32x4_t *v154;
  float32x4_t *v155;
  float v156;
  float v157;
  float v158;
  float v159;
  uint64_t v160;
  uint64_t v161;
  float32x4_t *v162;
  float32x4_t *v163;
  float32x4_t v164;
  float32x4_t *v165;
  float32x4_t *v166;
  uint64_t v167;
  float32x4_t v168;
  uint64_t v169;
  uint64_t v170;
  float *v171;
  float *v172;
  float v173;
  char v174;
  int *v175;
  char v176;
  int *v177;
  float32x4_t v178;
  float32x4_t *v179;
  float32x4_t *v180;
  uint64_t v181;
  float32x4_t v182;
  uint64_t v183;
  uint64_t v184;
  float *v185;
  float *v186;
  float v187;
  unsigned int v188;
  unsigned int v189;
  int v190;
  float32x4_t v191;
  uint64_t v192;
  float32x4_t *v193;
  float32x4_t *v194;
  float32x4_t v195;
  float32x4_t v196;
  uint64_t v197;
  uint64_t v198;
  float *v199;
  float *v200;
  float v201;
  float v202;
  unsigned int v203;
  unsigned int v204;
  int v205;
  unsigned int v206;
  unint64_t v207;
  int v208;
  int v209;
  unint64_t v210;
  uint64_t v211;
  int v212;
  float32x4_t *v213;
  uint64_t v214;
  float32x4_t v215;
  uint64_t v216;
  float *v217;
  int v218;
  int v219;
  unsigned int v220;
  unsigned int v221;
  unsigned int v222;
  BOOL v223;
  unsigned int v224;
  int v225;
  int v226;
  unsigned int v227;
  unint64_t v228;
  int v229;
  int v230;
  unint64_t v231;
  uint64_t v232;
  int v233;
  unsigned int v234;
  int v235;
  int v236;
  unsigned int v237;
  unsigned int v238;
  int32x2_t v239;
  int v240;
  int v241;
  int32x2_t v242;
  int32x2_t v243;
  int32x2_t v244;
  int32x2_t v245;
  unsigned __int16 v246;
  int32x2_t v247;
  uint32x2_t v248;
  uint64_t v249;
  uint64_t v250;
  unint64_t v251;

  v15 = a12;
  v16 = *a1;
  v17 = *((_QWORD *)a1 + 1);
  result = a1[4];
  v19 = *((_QWORD *)a1 + 4);
  v20 = *((_QWORD *)a1 + 6);
  v21 = *(__int16 *)(*(_QWORD *)(v17 + 64) + 2 * result) + 8 * a10;
  v22 = a11 != 0;
  v23 = a5 == 2;
  v24 = !v23 || !v22;
  if (v23 && v22)
    v25 = -16;
  else
    v25 = -4;
  v26 = v25 + (v21 >> 1);
  v27 = *a6;
  if (v24)
    v28 = -1;
  else
    v28 = -2;
  v29 = (v27 + v26 * (v28 + 2 * a5)) / (v28 + 2 * a5);
  v30 = v27 - v21 - 32;
  if (v30 >= v29)
    v30 = v29;
  if (v30 >= 64)
    v30 = 64;
  if (v30 < 4)
  {
    v31 = 1;
    v32 = 1;
    if (v16)
      goto LABEL_13;
LABEL_24:
    v37 = *(_DWORD *)(v19 + 24);
    v38 = *(_DWORD *)(v19 + 32);
    v39 = __clz(v38);
    v40 = ((__PAIR64__(8 * (v39 + v37), ec_tell_frac_correction[(v38 >> (16 - v39) >> 12) - 8])
          - __PAIR64__(v38 >> (16 - v39) >> 12, v38 >> (16 - v39))) >> 32)
        - 248;
    if (v32 == 1)
    {
      if (a11)
      {
        v41 = 0;
        goto LABEL_150;
      }
      goto LABEL_167;
    }
    if (a5 > 2 && a11)
    {
      if (v32 >= 0)
        v44 = v32;
      else
        v44 = v32 + 1;
      v45 = v44 >> 1;
      v46 = (v44 >> 1) + 1;
      v47 = 3 * v46;
      v48 = 3 * v46 + (v44 >> 1);
      v49 = v38 / v48;
      *(_DWORD *)(v19 + 40) = v38 / v48;
      v50 = *(_DWORD *)(v19 + 36);
      v51 = v50 / (v38 / v48) + 1;
      v52 = v48 >= v51;
      v53 = v48 - v51;
      if (!v52)
        v53 = 0;
      result = (unint64_t)(1431655766 * v53) >> 63;
      v54 = v53 - 2 * v46;
      if (v53 >= v47)
        v55 = v54;
      else
        v55 = v53 / 3;
      v56 = v47 + ~v45 + v55;
      v57 = v47 - v45;
      v58 = v55 <= v45;
      if (v55 <= v45)
        v59 = 3 * v55;
      else
        v59 = v56;
      v60 = v57 + v55;
      if (v58)
        v60 = 3 * v55 + 3;
      v61 = (v48 - v60) * v49;
      v62 = v50 - v61;
      v63 = (v60 - v59) * v49;
      if (!v59)
        v63 = v38 - v61;
      *(_DWORD *)(v19 + 32) = v63;
      *(_DWORD *)(v19 + 36) = v62;
      if (v63 <= 0x800000)
      {
        v64 = *(unsigned int *)(v19 + 8);
        v65 = *(_DWORD *)(v19 + 44);
        v66 = v37 + 8;
        v67 = *(unsigned int *)(v19 + 28);
        do
        {
          *(_DWORD *)(v19 + 24) = v66;
          *(_DWORD *)(v19 + 32) = v63 << 8;
          if (v67 < v64)
          {
            v68 = *(_QWORD *)v19;
            *(_DWORD *)(v19 + 28) = v67 + 1;
            v69 = *(unsigned __int8 *)(v68 + v67++);
          }
          else
          {
            v69 = 0;
          }
          v62 = (((v62 & 0x7FFFFF) << 8) | ((v69 | (v65 << 8)) >> 1)) ^ 0xFF;
          *(_DWORD *)(v19 + 44) = v69;
          *(_DWORD *)(v19 + 36) = v62;
          v66 += 8;
          v65 = v69;
          v58 = v63 > 0x8000;
          v63 <<= 8;
        }
        while (!v58);
      }
    }
    else if (a8 >= 2 || a11)
    {
      v176 = a7;
      v177 = a6;
      result = ec_dec_uint(*((uint64_t **)a1 + 4), v32 + 1);
      a6 = v177;
      a7 = v176;
      v55 = result;
    }
    else
    {
      v82 = (v32 >> 1) + 1;
      v83 = v82 * v82;
      v84 = v38 / (v82 * v82);
      *(_DWORD *)(v19 + 40) = v84;
      v85 = *(_DWORD *)(v19 + 36);
      v86 = v85 / v84 + 1;
      v52 = v82 * v82 >= v86;
      v87 = v82 * v82 - v86;
      if (!v52)
        v87 = 0;
      if (v87 >= (v82 * (v32 >> 1)) >> 1)
      {
        v218 = 0;
        v219 = v32 + 1;
        v220 = (8 * (v83 + ~v87)) | 1;
        v221 = (__clz(v220) >> 1) ^ 0xF;
        v222 = 1 << v221;
        do
        {
          LODWORD(result) = (v222 + 2 * v218) << v221;
          v223 = result > v220;
          if (result <= v220)
            result = result;
          else
            result = 0;
          if (v223)
            v224 = 0;
          else
            v224 = v222;
          v220 -= result;
          v218 += v224;
          v222 >>= 1;
          --v221;
        }
        while (v221 != -1);
        v55 = (2 * v219 - v218) >> 1;
        v93 = v219 - v55;
        v94 = v83 - ((v93 * (v32 - v55 + 2)) >> 1);
      }
      else
      {
        v88 = 0;
        v89 = (8 * v87) | 1;
        v90 = (__clz(v89) >> 1) ^ 0xF;
        v91 = 1 << v90;
        do
        {
          v92 = (v91 + 2 * v88) << v90;
          if (v92 <= v89)
          {
            result = v91;
          }
          else
          {
            v92 = 0;
            result = 0;
          }
          v89 -= v92;
          v88 += result;
          v91 >>= 1;
          --v90;
        }
        while (v90 != -1);
        v55 = (v88 - 1) >> 1;
        v93 = v55 + 1;
        v94 = ((v55 + 1) * v55) >> 1;
      }
      v225 = (v83 - v93 - v94) * v84;
      v226 = v85 - v225;
      v227 = v93 * v84;
      if (!v94)
        v227 = v38 - v225;
      *(_DWORD *)(v19 + 32) = v227;
      *(_DWORD *)(v19 + 36) = v226;
      if (v227 <= 0x800000)
      {
        v228 = *(unsigned int *)(v19 + 8);
        v229 = *(_DWORD *)(v19 + 44);
        v230 = v37 + 8;
        v231 = *(unsigned int *)(v19 + 28);
        do
        {
          *(_DWORD *)(v19 + 24) = v230;
          *(_DWORD *)(v19 + 32) = v227 << 8;
          if (v231 < v228)
          {
            v232 = *(_QWORD *)v19;
            *(_DWORD *)(v19 + 28) = v231 + 1;
            v233 = *(unsigned __int8 *)(v232 + v231++);
          }
          else
          {
            v233 = 0;
          }
          v226 = (((v226 & 0x7FFFFF) << 8) | ((v233 | (v229 << 8)) >> 1)) ^ 0xFF;
          *(_DWORD *)(v19 + 44) = v233;
          *(_DWORD *)(v19 + 36) = v226;
          v230 += 8;
          v229 = v233;
          v58 = v227 > 0x8000;
          v227 <<= 8;
        }
        while (!v58);
      }
    }
    goto LABEL_217;
  }
  v31 = ((compute_qn_exp2_table8[v30 & 7] >> (14 - (v30 >> 3))) + 1) & 0xFFFFFFFE;
  if ((int)result < a1[5] || a11 == 0)
    v32 = v31;
  else
    v32 = 1;
  if (!v16)
    goto LABEL_24;
LABEL_13:
  if (!a11)
  {
    if (a5 < 1)
      goto LABEL_30;
    if (a5 == 1)
    {
      v42 = 0;
      v43 = 0.0;
    }
    else
    {
      v42 = a5 & 0xFFFFFFFE;
      v95 = &a3->f32[1];
      v43 = 0.0;
      v96 = v42;
      do
      {
        v43 = (float)(v43 + (float)(*(v95 - 1) * *(v95 - 1))) + (float)(*v95 * *v95);
        v95 += 2;
        v96 -= 2;
      }
      while (v96);
      if (v42 == a5)
      {
LABEL_77:
        if (a5 >= 2)
        {
          v100 = a5 & 0xFFFFFFFE;
          v102 = &a4->f32[1];
          v101 = 0.0;
          v103 = v100;
          do
          {
            v101 = (float)(v101 + (float)(*(v102 - 1) * *(v102 - 1))) + (float)(*v102 * *v102);
            v102 += 2;
            v103 -= 2;
          }
          while (v103);
          if (v100 == a5)
            goto LABEL_84;
        }
        else
        {
          v100 = 0;
          v101 = 0.0;
        }
        v104 = a5 - v100;
        v105 = &a4->f32[v100];
        do
        {
          v106 = *v105++;
          v101 = v101 + (float)(v106 * v106);
          --v104;
        }
        while (v104);
LABEL_84:
        v35 = v43 + 1.0e-15;
        v34 = v101 + 1.0e-15;
        goto LABEL_85;
      }
    }
    v97 = a5 - v42;
    v98 = &a3->f32[v42];
    do
    {
      v99 = *v98++;
      v43 = v43 + (float)(v99 * v99);
      --v97;
    }
    while (v97);
    goto LABEL_77;
  }
  if (a5 < 1)
  {
LABEL_30:
    v35 = 1.0e-15;
    v34 = 1.0e-15;
    goto LABEL_85;
  }
  if (a5 == 1)
  {
    v33 = 0;
    v34 = 1.0e-15;
    v35 = 1.0e-15;
LABEL_58:
    v75 = a5 - v33;
    v76 = v33;
    v77 = &a4->f32[v33];
    v78 = &a3->f32[v76];
    do
    {
      v79 = *v78++;
      v80 = v79;
      v81 = *v77++;
      v35 = v35 + (float)((float)(v80 + v81) * (float)(v80 + v81));
      v34 = v34 + (float)((float)(v80 - v81) * (float)(v80 - v81));
      --v75;
    }
    while (v75);
    goto LABEL_85;
  }
  v33 = a5 & 0xFFFFFFFE;
  v70 = &a3->f32[1];
  v71 = &a4->f32[1];
  v34 = 1.0e-15;
  v72 = v33;
  v35 = 1.0e-15;
  do
  {
    v73 = *(v70 - 1);
    v74 = *(v71 - 1);
    v34 = (float)(v34 + (float)((float)(v73 - v74) * (float)(v73 - v74)))
        + (float)((float)(*v70 - *v71) * (float)(*v70 - *v71));
    v35 = (float)(v35 + (float)((float)(v73 + v74) * (float)(v73 + v74)))
        + (float)((float)(*v70 + *v71) * (float)(*v70 + *v71));
    v70 += 2;
    v71 += 2;
    v72 -= 2;
  }
  while (v72);
  if (v33 != a5)
    goto LABEL_58;
LABEL_85:
  v107 = sqrtf(v35);
  v108 = sqrtf(v34);
  v109 = v107 * v107;
  v110 = v108 * v108;
  v111 = 0.0;
  if ((float)((float)(v107 * v107) + (float)(v108 * v108)) >= 1.0e-18)
  {
    if (v109 >= v110)
    {
      v112 = v107 * v108;
      v113 = (float)(v112 * (float)(v109 + (float)(v110 * 0.43158)))
           / (float)((float)(v109 + (float)(v110 * 0.67848)) * (float)(v109 + (float)(v110 * 0.085955)));
      v114 = 1.5708;
      v115 = v113 + 1.5708;
      if (v112 < 0.0)
        v114 = -1.5708;
      v111 = v115 - v114;
    }
    else
    {
      v111 = 1.5708
           - (float)((float)((float)(v108 * v107) * (float)(v110 + (float)(v109 * 0.43158)))
                   / (float)((float)(v110 + (float)(v109 * 0.67848)) * (float)(v110 + (float)(v109 * 0.085955))));
    }
  }
  v116 = vcvtms_s32_f32((float)(v111 * 10430.0) + 0.5);
  v37 = *(_DWORD *)(v19 + 24);
  v38 = *(_DWORD *)(v19 + 32);
  v117 = __clz(v38);
  v40 = ((__PAIR64__(8 * (v117 + v37), ec_tell_frac_correction[(v38 >> (16 - v117) >> 12) - 8])
        - __PAIR64__(v38 >> (16 - v117) >> 12, v38 >> (16 - v117))) >> 32)
      - 248;
  if (v32 == 1)
  {
    if (a11)
    {
      if (v116 <= 0x2000)
      {
        v41 = 0;
      }
      else
      {
        v118 = a1[17];
        v41 = v118 == 0;
        if (a5 >= 1 && !v118)
        {
          if (a5 >= 8)
          {
            v119 = a5 & 0x7FFFFFF8;
            v213 = a4 + 1;
            v214 = a5 & 0xFFFFFFF8;
            do
            {
              a9 = vnegq_f32(v213[-1]);
              v215 = vnegq_f32(*v213);
              v213[-1] = a9;
              *v213 = v215;
              v213 += 2;
              v214 -= 8;
            }
            while (v214);
            if (v119 == a5)
              goto LABEL_191;
          }
          else
          {
            v119 = 0;
          }
          v216 = a5 - v119;
          v217 = &a4->f32[v119];
          do
          {
            *v217 = -*v217;
            ++v217;
            --v216;
          }
          while (v216);
LABEL_191:
          v41 = 1;
LABEL_140:
          v156 = *(float *)(v20 + 4 * result);
          v157 = *(float *)(v20 + 4 * (*(_DWORD *)(v17 + 8) + (int)result));
          v158 = sqrtf((float)((float)(v156 * v156) + 1.0e-15) + (float)(v157 * v157)) + 1.0e-15;
          a9.f32[0] = v156 / v158;
          v159 = v157 / v158;
          if (a5 >= 8)
          {
            v160 = a5 & 0x7FFFFFF8;
            v164 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a9.f32, 0);
            v165 = a3 + 1;
            v166 = a4 + 1;
            v167 = a5 & 0xFFFFFFF8;
            do
            {
              v168 = vmlaq_f32(vmulq_n_f32(*v166, v159), *v165, v164);
              v165[-1] = vmlaq_f32(vmulq_n_f32(v166[-1], v159), v165[-1], v164);
              *v165 = v168;
              v165 += 2;
              v166 += 2;
              v167 -= 8;
            }
            while (v167);
            if (v160 == a5)
              goto LABEL_150;
          }
          else
          {
            v160 = 0;
          }
          v169 = a5 - v160;
          v170 = v160;
          v171 = &a4->f32[v160];
          v172 = &a3->f32[v170];
          do
          {
            v173 = *v171++;
            *v172 = (float)(v159 * v173) + (float)(a9.f32[0] * *v172);
            ++v172;
            --v169;
          }
          while (v169);
LABEL_150:
          if (v27 < 17 || a1[10] < 17)
          {
            v41 = 0;
          }
          else if (v16)
          {
            v174 = a7;
            v175 = a6;
            result = (unint64_t)ec_enc_bit_logp((uint64_t *)v19, v41, 2);
            a6 = v175;
            a7 = v174;
          }
          else
          {
            v203 = *(_DWORD *)(v19 + 36);
            v204 = v38 >> 2;
            v205 = v203;
            if (v203 >= v38 >> 2)
            {
              *(_DWORD *)(v19 + 36) = v203 - (v38 >> 2);
              v205 = v203 - v204;
            }
            v206 = v38 - v204;
            if (v203 < v204)
              v206 = v204;
            *(_DWORD *)(v19 + 32) = v206;
            if (v206 <= 0x800000)
            {
              v207 = *(unsigned int *)(v19 + 8);
              v208 = *(_DWORD *)(v19 + 44);
              v209 = v37 + 8;
              v210 = *(unsigned int *)(v19 + 28);
              do
              {
                *(_DWORD *)(v19 + 24) = v209;
                *(_DWORD *)(v19 + 32) = v206 << 8;
                if (v210 < v207)
                {
                  v211 = *(_QWORD *)v19;
                  result = v210 + 1;
                  *(_DWORD *)(v19 + 28) = v210 + 1;
                  v212 = *(unsigned __int8 *)(v211 + v210++);
                }
                else
                {
                  v212 = 0;
                }
                v205 = (((v205 & 0x7FFFFF) << 8) | ((v212 | (v208 << 8)) >> 1)) ^ 0xFF;
                *(_DWORD *)(v19 + 44) = v212;
                *(_DWORD *)(v19 + 36) = v205;
                v209 += 8;
                v208 = v212;
                v58 = v206 > 0x8000;
                v206 <<= 8;
              }
              while (!v58);
            }
            v41 = v203 < v204;
          }
          if (a1[17])
            v116 = 0;
          else
            v116 = v41;
          goto LABEL_168;
        }
      }
      if (a5 < 1)
        goto LABEL_150;
      goto LABEL_140;
    }
    goto LABEL_218;
  }
  if (!a11)
  {
    v138 = v32 * v116 + 0x2000;
    v139 = v138 >> 14;
    if (a1[18])
    {
      v140 = v32 * v116 >= 0x2000 && v139 < v32;
      v55 = v138 >> 14;
      if (v140)
      {
        v141.i32[0] = ((v138 & 0xFFFFC000) / v32) << 16;
        v141.i32[1] = 0x40000000 - v141.i32[0];
        v142 = vshr_n_s32(vmla_s32((int32x2_t)0x800000008000, vshl_s32(v141, (int32x2_t)0xFFFFFFF3FFFFFFF0), vshl_s32(v141, (int32x2_t)0xFFFFFFF0FFFFFFF3)), 0x10uLL);
        v143 = vmul_s32(v142, (int32x2_t)(*(_QWORD *)&vsra_n_u32((uint32x2_t)vdup_n_s32(0x2055u), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, v142, vdup_n_s32(0x7FFFFD8Eu)), 0xFuLL) & 0xFFFCFFFFFFFCFFFFLL));
        v144 = (int32x2_t)veor_s8((int8x8_t)vshr_n_s32(vshl_n_s32(vsub_s32((int32x2_t)vshr_n_u32((uint32x2_t)vmla_s32((int32x2_t)0x400000004000, vshr_n_s32(vadd_s32(vadd_s32(v143, v143), vdup_n_s32(0xE21D8000)), 0x10uLL), v142), 0xFuLL), v142), 0x10uLL), 0x10uLL), (int8x8_t)0x7F0000007FLL);
        v145 = vclz_s32(v144);
        v146 = vshr_n_s32(vshl_n_s32((int32x2_t)vshl_u32((uint32x2_t)v144, (uint32x2_t)vadd_s32(v145, (int32x2_t)0x1000000010)), 0x10uLL), 0x10uLL);
        v147 = vshr_n_u32((uint32x2_t)vmla_s32((int32x2_t)0x400000004000, (int32x2_t)(*(_QWORD *)&vsra_n_u32((uint32x2_t)vdup_n_s32(0x1EFCu), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, v146, vdup_n_s32(0x7FFFF5DBu)), 0xFuLL) & 0xFFFCFFFFFFFCFFFFLL), v146), 0xFuLL);
        v148 = ((__int16)(v147.i16[2] - v147.i16[0] + (vsub_s32(v145, vdup_lane_s32(v145, 1)).u16[0] << 11))
              * (__int16)(((_WORD)a5 << 7) - 128)
              + 0x4000) >> 15;
        v55 = v31;
        if (v148 <= v27)
        {
          if (v148 >= -v27)
            v55 = v139;
          else
            v55 = 0;
        }
      }
      v125 = a6;
      v126 = a7;
      if (a8 > 1)
        goto LABEL_132;
    }
    else
    {
      v55 = v138 >> 14;
      v125 = a6;
      v126 = a7;
      if (a8 > 1)
      {
LABEL_132:
        v249 = v17;
        v250 = v20;
        v251 = result;
        goto LABEL_133;
      }
    }
    v234 = ((v32 >> 1) + 1) * ((v32 >> 1) + 1);
    if (v55 <= v32 >> 1)
      v235 = v55 + 1;
    else
      v235 = v32 - v55 + 1;
    if (v55 <= v32 >> 1)
      v236 = ((v55 + 1) * v55) >> 1;
    else
      v236 = v234 - (((v32 - v55 + 1) * (v32 - v55 + 2)) >> 1);
    result = (unint64_t)ec_encode((uint64_t *)v19, v236, v236 + v235, v234);
    a7 = v126;
    v15 = a12;
    a6 = v125;
LABEL_217:
    v116 = (v55 << 14) / v32;
    goto LABEL_218;
  }
  v120 = a1[16];
  if (v116 > 0x2000)
    v121 = 0x7FFF;
  else
    v121 = -32767;
  v122 = v121 / v32 + v32 * v116;
  if (v122 >= 0)
    v123 = v122 >> 14;
  else
    v123 = 0;
  if (v32 <= v123)
    v123 = v32 - 1;
  v124 = v123 + (v120 >= 0);
  if (v120)
    v55 = v124;
  else
    v55 = (v32 * v116 + 0x2000) >> 14;
  v249 = v17;
  v250 = v20;
  v251 = result;
  v125 = a6;
  v126 = a7;
  if (a5 > 2)
  {
    if (v32 >= 0)
      v127 = v32;
    else
      v127 = v32 + 1;
    v128 = v127 >> 1;
    v129 = (v127 & 0xFFFFFFFE) + (v127 >> 1) + 3;
    v130 = v129 + v128;
    v131 = v129 + ~v128 + v55;
    v132 = v129 - v128;
    if (v55 <= v128)
      v133 = 3 * v55;
    else
      v133 = v131;
    v134 = v132 + v55;
    if (v55 <= v128)
      v135 = 3 * v55 + 3;
    else
      v135 = v134;
    result = (unint64_t)ec_encode((uint64_t *)v19, v133, v135, v130);
    v137 = v55 << 14;
    v116 = (v55 << 14) / v32;
    goto LABEL_134;
  }
LABEL_133:
  result = (unint64_t)ec_enc_uint(v19, v55, v32 + 1);
  v137 = v55 << 14;
  v116 = (v55 << 14) / v32;
  if (!a11)
  {
    a7 = v126;
    v15 = a12;
    a6 = v125;
    goto LABEL_218;
  }
LABEL_134:
  if (v32 > v137)
  {
    a7 = v126;
    a6 = v125;
    if (a5 < 1)
    {
      v116 = 0;
      v15 = a12;
LABEL_168:
      v188 = *(_DWORD *)(v19 + 32);
      v189 = __clz(v188);
      v190 = ((__PAIR64__(8 * (v189 + *(_DWORD *)(v19 + 24)) - v40, ec_tell_frac_correction[(v188 >> (16 - v189) >> 12) - 8])- __PAIR64__(v188 >> (16 - v189) >> 12, v188 >> (16 - v189))) >> 32)- 248;
      *a6 -= v190;
      goto LABEL_220;
    }
    v149 = *(float *)(v250 + 4 * v251);
    v150 = *(float *)(v250 + 4 * (*(_DWORD *)(v249 + 8) + (int)v251));
    v151 = sqrtf((float)((float)(v149 * v149) + 1.0e-15) + (float)(v150 * v150)) + 1.0e-15;
    *(float *)v136.i32 = v149 / v151;
    v152 = v150 / v151;
    if (a5 >= 8)
    {
      v153 = a5 & 0xFFFFFFF8;
      v178 = (float32x4_t)vdupq_lane_s32(v136, 0);
      v155 = a4;
      v154 = a3;
      v179 = a3 + 1;
      v180 = a4 + 1;
      v181 = v153;
      do
      {
        v182 = vmlaq_f32(vmulq_n_f32(*v180, v152), *v179, v178);
        v179[-1] = vmlaq_f32(vmulq_n_f32(v180[-1], v152), v179[-1], v178);
        *v179 = v182;
        v179 += 2;
        v180 += 2;
        v181 -= 8;
      }
      while (v181);
      v15 = a12;
      if (v153 == a5)
        goto LABEL_167;
    }
    else
    {
      v153 = 0;
      v154 = a3;
      v15 = a12;
      v155 = a4;
    }
    v183 = a5 - v153;
    v184 = v153;
    v185 = &v155->f32[v153];
    v186 = &v154->f32[v184];
    do
    {
      v187 = *v185++;
      *v186 = (float)(v152 * v187) + (float)(*(float *)v136.i32 * *v186);
      ++v186;
      --v183;
    }
    while (v183);
LABEL_167:
    v116 = 0;
    goto LABEL_168;
  }
  a7 = v126;
  a6 = v125;
  if (a5 < 1)
  {
    v15 = a12;
  }
  else
  {
    if (a5 >= 4)
    {
      v161 = a5 & 0xFFFFFFFC;
      v191 = (float32x4_t)vdupq_n_s32(0x3F3504F3u);
      v192 = v161;
      v163 = a4;
      v162 = a3;
      v193 = a4;
      v194 = a3;
      do
      {
        v195 = vmulq_f32(*v194, v191);
        v196 = vmulq_f32(*v193, v191);
        *v194++ = vaddq_f32(v195, v196);
        *v193++ = vsubq_f32(v196, v195);
        v192 -= 4;
      }
      while (v192);
      v15 = a12;
      if (v161 == a5)
        goto LABEL_218;
    }
    else
    {
      v161 = 0;
      v162 = a3;
      v15 = a12;
      v163 = a4;
    }
    v197 = a5 - v161;
    v198 = v161;
    v199 = &v163->f32[v161];
    v200 = &v162->f32[v198];
    do
    {
      v201 = *v200 * 0.70711;
      v202 = *v199 * 0.70711;
      *v200++ = v201 + v202;
      *v199++ = v202 - v201;
      --v197;
    }
    while (v197);
  }
LABEL_218:
  v237 = *(_DWORD *)(v19 + 32);
  v238 = __clz(v237);
  v190 = ((__PAIR64__(8 * (v238 + *(_DWORD *)(v19 + 24)) - v40, ec_tell_frac_correction[(v237 >> (16 - v238) >> 12) - 8])- __PAIR64__(v237 >> (16 - v238) >> 12, v237 >> (16 - v238))) >> 32)- 248;
  *a6 -= v190;
  if (v116 == 0x4000)
  {
    v241 = 0;
    *v15 &= ~(-1 << a7) << a7;
    v239 = (int32x2_t)0x7FFF00000000;
    v240 = 0x4000;
    goto LABEL_223;
  }
  if (v116)
  {
    v241 = 0;
    v242.i32[0] = v116 << 16;
    v242.i32[1] = 0x40000000 - (v116 << 16);
    v243 = vshr_n_s32(vmla_s32((int32x2_t)0x800000008000, vshl_s32(v242, (int32x2_t)0xFFFFFFF3FFFFFFF0), vshl_s32(v242, (int32x2_t)0xFFFFFFF0FFFFFFF3)), 0x10uLL);
    v244 = vmul_s32(v243, (int32x2_t)(*(_QWORD *)&vsra_n_u32((uint32x2_t)vdup_n_s32(0x2055u), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, v243, vdup_n_s32(0x7FFFFD8Eu)), 0xFuLL) & 0xFFFCFFFFFFFCFFFFLL));
    v239 = (int32x2_t)veor_s8((int8x8_t)vshr_n_s32(vshl_n_s32(vsub_s32((int32x2_t)vshr_n_u32((uint32x2_t)vmla_s32((int32x2_t)0x400000004000, vshr_n_s32(vadd_s32(vadd_s32(v244, v244), vdup_n_s32(0xE21D8000)), 0x10uLL), v243), 0xFuLL), v243), 0x10uLL), 0x10uLL), (int8x8_t)0x7F0000007FLL);
    v245 = vclz_s32(v239);
    v246 = vsub_s32(v245, vdup_lane_s32(v245, 1)).u16[0];
    v247 = vshr_n_s32(vshl_n_s32((int32x2_t)vshl_u32((uint32x2_t)v239, (uint32x2_t)vadd_s32(v245, (int32x2_t)0x1000000010)), 0x10uLL), 0x10uLL);
    v248 = vshr_n_u32((uint32x2_t)vmla_s32((int32x2_t)0x400000004000, (int32x2_t)(*(_QWORD *)&vsra_n_u32((uint32x2_t)vdup_n_s32(0x1EFCu), (uint32x2_t)vmla_s32((int32x2_t)0x400000004000, v247, vdup_n_s32(0x7FFFF5DBu)), 0xFuLL) & 0xFFFCFFFFFFFCFFFFLL), v247), 0xFuLL);
    v240 = ((__int16)(v248.i16[2] - v248.i16[0] + (v246 << 11)) * (__int16)(((_WORD)a5 << 7) - 128) + 0x4000) >> 15;
    goto LABEL_223;
  }
LABEL_220:
  *v15 &= ~(-1 << a7);
  v239 = (int32x2_t)0x7FFFLL;
  v240 = -16384;
  v241 = v116;
  v116 = 0;
LABEL_223:
  *(_DWORD *)a2 = v241;
  *(int32x2_t *)(a2 + 4) = v239;
  *(_DWORD *)(a2 + 12) = v240;
  *(_DWORD *)(a2 + 16) = v116;
  *(_DWORD *)(a2 + 20) = v190;
  return result;
}

float silk_burg_modified_FLP(float32x4_t *a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5, float a6)
{
  int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  double v10;
  unsigned int v11;
  unint64_t v12;
  const float *v13;
  uint64_t v14;
  const float *v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float *v26;
  double v27;
  float v28;
  float v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float *v35;
  uint64_t v36;
  float *v37;
  float v38;
  uint64_t v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  const float *v43;
  uint64_t v44;
  const float *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  unsigned int v54;
  const float *v55;
  uint64_t v56;
  double *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  unint64_t v61;
  double v62;
  unsigned int v63;
  unint64_t v64;
  unint64_t v65;
  const float *v66;
  const float *v67;
  const float *v68;
  const float *v69;
  float64x2_t v70;
  float64x2_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float64x2_t v84;
  float64x2_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float64x2_t v88;
  float64x2_t v89;
  float64x2_t v90;
  float64x2_t v91;
  uint64_t v92;
  double v93;
  uint64_t v94;
  unint64_t v95;
  double v96;
  uint64_t v97;
  uint64_t *v98;
  uint64_t v99;
  unint64_t v100;
  double v101;
  double *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  BOOL v108;
  char v109;
  int32x4_t *v110;
  uint64_t v111;
  int32x4_t *v112;
  uint64_t v113;
  uint64_t v114;
  float v115;
  double v116;
  float v117;
  double v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  float64x2_t *v122;
  float64x2_t *v123;
  float64x2_t *v124;
  int32x4_t *v125;
  unint64_t v126;
  int8x16_t v127;
  float32x4_t v128;
  int8x16_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float64x2_t v133;
  float64x2_t v134;
  float64x2_t v135;
  float64x2_t v136;
  float32x4_t *v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float64x2_t v142;
  float64x2_t v143;
  float64x2_t v144;
  float64x2_t v145;
  float64x2_t v146;
  float64x2_t v147;
  float64x2_t v148;
  float64x2_t v149;
  float64x2_t v150;
  float64x2_t v151;
  float64x2_t v152;
  float64x2_t v153;
  float64x2_t v154;
  float64x2_t v155;
  float64x2_t v156;
  float64x2_t v157;
  float64x2_t v158;
  float64x2_t v159;
  float64x2_t v160;
  float64x2_t v161;
  uint64_t v162;
  float *v163;
  float v164;
  uint64_t v165;
  float v166;
  double v167;
  double v168;
  double v169;
  char v170;
  uint64_t v171;
  float64x2_t v172;
  float64x2_t *v173;
  float64x2_t v174;
  float64x2_t *v175;
  unint64_t v176;
  uint64_t v177;
  int32x4_t *v178;
  int32x4_t v179;
  int8x16_t v180;
  float32x4_t v181;
  float64x2_t v182;
  float32x4_t v183;
  float64x2_t v184;
  int64_t v185;
  float *v186;
  float v187;
  uint64_t v188;
  double v189;
  double v190;
  double *v191;
  uint64_t v192;
  uint64_t v193;
  double v194;
  int v195;
  unint64_t v196;
  double v197;
  double v198;
  uint64_t v199;
  double v200;
  double v201;
  double v202;
  double v203;
  double *v204;
  double *v205;
  double v206;
  double v207;
  uint64_t v208;
  unint64_t v209;
  float64x2_t v210;
  float64x2_t *v211;
  int8x16_t *v212;
  float64x2_t v213;
  float64x2_t v214;
  int8x16_t v215;
  uint64_t v216;
  double *v217;
  double v218;
  double *v219;
  double v220;
  double v221;
  uint64_t v222;
  float32x4_t *v223;
  uint64_t v224;
  float32x4_t *v225;
  float64x2_t *v226;
  float32x4_t *v227;
  uint64_t v228;
  float64x2_t v229;
  float64x2_t v230;
  float64x2_t v231;
  float64x2_t v232;
  uint64_t v233;
  float *v234;
  double *v235;
  double v236;
  float v237;
  unint64_t v238;
  uint64_t v239;
  unint64_t v240;
  unint64_t v241;
  const float *v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  float *v246;
  unint64_t v247;
  double v248;
  uint64_t v249;
  const float *v250;
  const float *v251;
  float64x2_t v252;
  float64x2_t v253;
  float64x2_t v254;
  float64x2_t v255;
  float64x2_t v256;
  float64x2_t v257;
  float64x2_t v258;
  float64x2_t v259;
  float64x2_t v260;
  float64x2_t v261;
  float *v262;
  double v263;
  float v264;
  float v265;
  float *v266;
  int v267;
  float v268;
  float64x2_t *v269;
  float64x2_t *v270;
  float32x4_t *v271;
  uint64_t v272;
  float64x2_t v273;
  float64x2_t v274;
  float64x2_t v275;
  float64x2_t v276;
  float64x2_t v277;
  float64x2_t v278;
  float64x2_t v279;
  float64x2_t v280;
  float64x2_t v281;
  float64x2_t v282;
  float64x2_t v283;
  float64x2_t v284;
  float64x2_t v285;
  float64x2_t v286;
  float64x2_t v287;
  float64x2_t v288;
  float *v289;
  uint64_t v290;
  uint64_t v291;
  double *v292;
  double *v293;
  double v294;
  double v295;
  double v296;
  uint64_t v299;
  double v300;
  float *v301;
  uint64_t v302;
  float v303;
  float32x4_t *v304;
  unsigned int v305;
  unint64_t v307;
  uint64_t v308;
  double *v309;
  uint64_t *v310;
  uint64_t v311;
  _OWORD *v312;
  uint64_t v313;
  int32x4_t *v314;
  uint64_t v315;
  uint64_t v316;
  int v317;
  uint64_t v318;
  uint64_t v319;
  double v320[4];
  _BYTE v321[160];
  double v322[25];
  double v323;
  _QWORD v324[4];
  _BYTE v325[160];
  _OWORD v326[2];
  _OWORD v327[9];
  __int128 v328;
  __int128 v329;
  __int128 v330;
  __int128 v331;
  __int128 v332;
  __int128 v333;
  __int128 v334;
  __int128 v335;
  __int128 v336;
  __int128 v337;
  __int128 v338;
  __int128 v339;
  __int128 v340;
  uint64_t v341;
  float32x2x4_t v342;
  float32x2x4_t v343;
  float32x2x4_t v344;
  float32x2x4_t v345;
  float32x2x4_t v346;
  float32x2x4_t v347;
  float32x2x4_t v348;
  float32x2x4_t v349;

  v341 = *MEMORY[0x24BDAC8D0];
  v319 = a3;
  v6 = a4 * a3;
  if (a4 * (int)a3 < 4)
  {
    v11 = 0;
    v10 = 0.0;
    v305 = a5;
    v304 = a1;
    if (v6 <= 0)
      goto LABEL_22;
    goto LABEL_14;
  }
  v7 = (v6 - 3);
  v8 = 4;
  if (v7 > 4)
    v8 = (v6 - 3);
  if (v8 < 0xD)
  {
    v9 = 0;
    v10 = 0.0;
LABEL_11:
    v26 = (float *)(a2 + 4 * v9 + 8);
    do
    {
      v27 = *(v26 - 1) * *(v26 - 1) + *(v26 - 2) * *(v26 - 2);
      v28 = *v26;
      v29 = v26[1];
      v26 += 4;
      v10 = v10 + v27 + v28 * v28 + v29 * v29;
      v9 += 4;
    }
    while (v9 < v7);
    goto LABEL_13;
  }
  v12 = ((v8 - 1) >> 2) + 1;
  v9 = 4 * (v12 & 0x7FFFFFFFFFFFFFFCLL);
  v13 = (const float *)(a2 + 32);
  v10 = 0.0;
  v14 = v12 & 0x7FFFFFFFFFFFFFFCLL;
  do
  {
    v15 = v13 - 8;
    v342 = vld4_f32(v15);
    v345 = vld4_f32(v13);
    v16 = vcvtq_f64_f32(v342.val[0]);
    v17 = vcvtq_f64_f32(v345.val[0]);
    v18 = vcvtq_f64_f32(v342.val[1]);
    v19 = vcvtq_f64_f32(v345.val[1]);
    v20 = vmlaq_f64(vmulq_f64(v18, v18), v16, v16);
    v21 = vmlaq_f64(vmulq_f64(v19, v19), v17, v17);
    v22 = vcvtq_f64_f32(v342.val[2]);
    v23 = vcvtq_f64_f32(v345.val[2]);
    *(float64x2_t *)v342.val[0].f32 = vcvtq_f64_f32(v342.val[3]);
    *(float64x2_t *)v342.val[1].f32 = vcvtq_f64_f32(v345.val[3]);
    v24 = vmlaq_f64(vmlaq_f64(v20, v22, v22), *(float64x2_t *)v342.val[0].f32, *(float64x2_t *)v342.val[0].f32);
    v25 = vmlaq_f64(vmlaq_f64(v21, v23, v23), *(float64x2_t *)v342.val[1].f32, *(float64x2_t *)v342.val[1].f32);
    v10 = v10 + v24.f64[0] + v24.f64[1] + v25.f64[0] + v25.f64[1];
    v13 += 16;
    v14 -= 4;
  }
  while (v14);
  if (v12 != (v12 & 0x7FFFFFFFFFFFFFFCLL))
    goto LABEL_11;
LABEL_13:
  v11 = v6 & 0xFFFFFFFC;
  v305 = a5;
  v304 = a1;
  if ((int)(v6 & 0xFFFFFFFC) >= v6)
    goto LABEL_22;
LABEL_14:
  v30 = v11;
  v31 = v6 + ~v11;
  if ((_DWORD)v31)
  {
    v32 = v31 + 1;
    v33 = (v31 + 1) & 0x1FFFFFFFELL;
    v34 = v33 + v30;
    v35 = (float *)(a2 + 4 * v30 + 4);
    v36 = v33;
    do
    {
      v10 = v10 + *(v35 - 1) * *(v35 - 1) + *v35 * *v35;
      v35 += 2;
      v36 -= 2;
    }
    while (v36);
    if (v32 == v33)
      goto LABEL_22;
  }
  else
  {
    v34 = v30;
  }
  v37 = (float *)(a2 + 4 * v34);
  do
  {
    v38 = *v37++;
    v10 = v10 + v38 * v38;
    LODWORD(v34) = v34 + 1;
  }
  while (v6 > (int)v34);
LABEL_22:
  v318 = a2;
  v340 = 0u;
  v339 = 0u;
  v338 = 0u;
  v337 = 0u;
  v336 = 0u;
  v335 = 0u;
  v334 = 0u;
  v333 = 0u;
  v332 = 0u;
  v330 = 0u;
  v331 = 0u;
  v329 = 0u;
  if (a4 >= 1 && (int)v305 >= 1)
  {
    v39 = 0;
    v40 = v319 - 2;
    v41 = v319 - 4;
    v42 = a2;
    v43 = (const float *)(a2 + 32);
    v44 = 4 * (int)v319;
    v45 = (const float *)(a2 + 36);
    v46 = a2 + 8;
    v47 = a2 + 20;
    v48 = a2 + 4;
    do
    {
      v49 = 0;
      v50 = v48;
      v51 = v47;
      v52 = v40;
      v53 = v46;
      v54 = v41;
      v55 = v45;
      v56 = 1;
      do
      {
        v58 = v54;
        if (v54 <= 4uLL)
          v58 = 4;
        if (v41 - v49 <= 4)
          v59 = 4;
        else
          v59 = v41 - v49;
        v60 = v319 - v56;
        if ((int)v319 - (int)v56 < 4)
        {
          v63 = 0;
          v62 = 0.0;
          if (v60 <= 0)
            goto LABEL_27;
          goto LABEL_44;
        }
        if (v59 < 0xD)
        {
          v61 = 0;
          v62 = 0.0;
LABEL_41:
          v72 = 4 * v61;
          v73 = v53;
          v74 = v42;
          do
          {
            v62 = v62
                + *(float *)(v74 + v72 + 4) * *(float *)(v73 + v72)
                + *(float *)(v74 + v72) * *(float *)(v73 + v72 - 4)
                + *(float *)(v74 + v72 + 8) * *(float *)(v73 + v72 + 4)
                + *(float *)(v74 + v72 + 12) * *(float *)(v73 + v72 + 8);
            v61 += 4;
            v74 += 16;
            v73 += 16;
          }
          while (v61 < (v60 - 3));
          goto LABEL_43;
        }
        v64 = (((unint64_t)(v58 - 1) >> 2) + 1) & 0x7FFFFFFFFFFFFFFCLL;
        v65 = ((unint64_t)(v59 - 1) >> 2) + 1;
        v61 = 4 * (v65 & 0x7FFFFFFFFFFFFFFCLL);
        v62 = 0.0;
        v66 = v55;
        v67 = v43;
        do
        {
          v68 = v67 - 8;
          v344 = vld4_f32(v68);
          v346 = vld4_f32(v67);
          v69 = v66 - 8;
          v348 = vld4_f32(v69);
          v349 = vld4_f32(v66);
          v70 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v344.val[1]), vcvtq_f64_f32(v348.val[1])), vcvtq_f64_f32(v348.val[0]), vcvtq_f64_f32(v344.val[0])), vcvtq_f64_f32(v348.val[2]), vcvtq_f64_f32(v344.val[2])), vcvtq_f64_f32(v348.val[3]), vcvtq_f64_f32(v344.val[3]));
          v71 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v346.val[1]), vcvtq_f64_f32(v349.val[1])), vcvtq_f64_f32(v349.val[0]), vcvtq_f64_f32(v346.val[0])), vcvtq_f64_f32(v349.val[2]), vcvtq_f64_f32(v346.val[2])), vcvtq_f64_f32(v349.val[3]), vcvtq_f64_f32(v346.val[3]));
          v62 = v62 + v70.f64[0] + v70.f64[1] + v71.f64[0] + v71.f64[1];
          v67 += 16;
          v66 += 16;
          v64 -= 4;
        }
        while (v64);
        if (v65 != (v65 & 0x7FFFFFFFFFFFFFFCLL))
          goto LABEL_41;
LABEL_43:
        v63 = v60 & 0xFFFFFFFC;
        if ((int)(v60 & 0xFFFFFFFC) >= v60)
          goto LABEL_27;
LABEL_44:
        v75 = v63;
        v76 = v40 - (v49 + v63);
        if (v76 < 7)
        {
          v77 = v63;
LABEL_49:
          v92 = 4 * v77;
          do
          {
            v62 = v62 + *(float *)(v42 + v92) * *(float *)(v50 + v92);
            LODWORD(v77) = v77 + 1;
            v92 += 4;
          }
          while (v60 > (int)v77);
          goto LABEL_27;
        }
        v78 = v76 + 1;
        v79 = (v76 + 1) & 0x1FFFFFFF8;
        v77 = v79 + v63;
        v80 = (v52 - v63 + 1) & 0x1FFFFFFF8;
        v81 = 4 * v75;
        do
        {
          v82 = *(float32x4_t *)(v42 + v81);
          v83 = *(float32x4_t *)(v42 + v81 + 16);
          v84 = vcvtq_f64_f32(*(float32x2_t *)v82.f32);
          v85 = vcvtq_f64_f32(*(float32x2_t *)v83.f32);
          v86 = *(float32x4_t *)(v51 + v81 - 16);
          v87 = *(float32x4_t *)(v51 + v81);
          v88 = vmulq_f64(vcvt_hight_f64_f32(v82), vcvt_hight_f64_f32(v86));
          v89 = vmulq_f64(v84, vcvtq_f64_f32(*(float32x2_t *)v86.f32));
          v90 = vmulq_f64(vcvt_hight_f64_f32(v83), vcvt_hight_f64_f32(v87));
          v91 = vmulq_f64(v85, vcvtq_f64_f32(*(float32x2_t *)v87.f32));
          v62 = v62
              + v89.f64[0]
              + v89.f64[1]
              + v88.f64[0]
              + v88.f64[1]
              + v91.f64[0]
              + v91.f64[1]
              + v90.f64[0]
              + v90.f64[1];
          v81 += 32;
          v80 -= 8;
        }
        while (v80);
        if (v78 != v79)
          goto LABEL_49;
LABEL_27:
        v57 = (double *)&v329 + v56++;
        *(v57 - 1) = v62 + *(v57 - 1);
        ++v49;
        ++v55;
        --v54;
        v53 += 4;
        --v52;
        v51 += 4;
        v50 += 4;
      }
      while (v56 != v305 + 1);
      ++v39;
      v43 = (const float *)((char *)v43 + v44);
      v45 = (const float *)((char *)v45 + v44);
      v42 += v44;
      v46 += v44;
      v47 += v44;
      v48 += v44;
    }
    while (v39 != a4);
  }
  v327[6] = v337;
  v327[7] = v338;
  v327[8] = v339;
  v328 = v340;
  v327[2] = v333;
  v327[3] = v334;
  v327[4] = v335;
  v327[5] = v336;
  v326[0] = v329;
  v326[1] = v330;
  v327[0] = v331;
  v327[1] = v332;
  v93 = v10 + v10 * 0.00000999999975 + 9.99999972e-10;
  v323 = v93;
  v322[0] = v93;
  if ((int)v305 < 1)
  {
    v221 = 1.0;
    return v93 + v10 * -0.00000999999975 * v221;
  }
  v94 = 0;
  v95 = 0;
  v96 = a6;
  v97 = 4 * (int)v319;
  v315 = (int)v319;
  v314 = (int32x4_t *)(a2 - 16);
  v312 = (_OWORD *)(a2 - 12);
  v313 = a2 - 4;
  v317 = v319 - 1;
  v98 = &v319;
  v99 = 2;
  v100 = 1;
  v101 = 1.0;
  v102 = v322;
  v311 = a2;
  v103 = a4;
  v316 = ((uint64_t)(int)v319 << 32) - 0x100000000;
  do
  {
    v309 = v102;
    v310 = v98;
    v307 = v99;
    v308 = v94;
    if (v100 >> 1 <= 1)
      v104 = 1;
    else
      v104 = v100 >> 1;
    if (a4 >= 1)
    {
      v105 = 0;
      v106 = v315;
      v107 = v315 - v95;
      v108 = ~(_DWORD)v95 + (int)v319 + (int)v95 >= ~(_DWORD)v95 + (int)v319 && HIDWORD(v95) == 0;
      v109 = !v108;
      v111 = v311;
      v110 = (int32x4_t *)v312;
      v113 = v313;
      v112 = v314;
      do
      {
        v114 = a2 + 4 * v105 * v106;
        v115 = *(float *)(v114 + 4 * v95);
        v116 = v115;
        v117 = *(float *)(v114 + 4 * (v315 - v95 - 1));
        v118 = v117;
        if (v95)
        {
          if (v95 >= 8)
          {
            v120 = v103;
            v121 = 0;
            v123 = (float64x2_t *)v327;
            v122 = (float64x2_t *)&v331;
            v124 = (float64x2_t *)v321;
            v125 = v112;
            v126 = v95 & 0xFFFFFFFFFFFFFFF8;
            do
            {
              v127 = (int8x16_t)vrev64q_s32(*v125);
              v128 = (float32x4_t)vextq_s8(v127, v127, 8uLL);
              v129 = (int8x16_t)vrev64q_s32(v125[-1]);
              v130 = (float32x4_t)vextq_s8(v129, v129, 8uLL);
              v131 = vmulq_n_f32(v128, v115);
              v132 = vmulq_n_f32(v130, v115);
              v133 = vcvt_hight_f64_f32(v132);
              v134 = vsubq_f64(v122[-1], vcvt_hight_f64_f32(v131));
              v135 = vsubq_f64(*v122, vcvtq_f64_f32(*(float32x2_t *)v132.f32));
              v136 = vsubq_f64(v122[1], v133);
              v122[-2] = vsubq_f64(v122[-2], vcvtq_f64_f32(*(float32x2_t *)v131.f32));
              v122[-1] = v134;
              *v122 = v135;
              v122[1] = v136;
              v122 += 4;
              v137 = (float32x4_t *)(v114 + 4 * (v107 + (v121 >> 32)));
              v138 = *v137;
              v139 = v137[1];
              v140 = vmulq_n_f32(*v137, v117);
              v141 = vmulq_n_f32(v139, v117);
              v142 = vcvt_hight_f64_f32(v141);
              v143 = vsubq_f64(v123[-1], vcvt_hight_f64_f32(v140));
              v144 = vsubq_f64(*v123, vcvtq_f64_f32(*(float32x2_t *)v141.f32));
              v145 = vsubq_f64(v123[1], v142);
              v123[-2] = vsubq_f64(v123[-2], vcvtq_f64_f32(*(float32x2_t *)v140.f32));
              v123[-1] = v143;
              *v123 = v144;
              v123[1] = v145;
              v123 += 4;
              v146 = v124[-2];
              v147 = v124[-1];
              v148 = *v124;
              v149 = v124[1];
              v124 += 4;
              v150 = vcvtq_f64_f32(*(float32x2_t *)v128.f32);
              v151 = vcvtq_f64_f32(*(float32x2_t *)v130.f32);
              v152 = vmulq_f64(v147, vcvt_hight_f64_f32(v128));
              v153 = vmulq_f64(v146, v150);
              v154 = vmulq_f64(v149, vcvt_hight_f64_f32(v130));
              v155 = vmulq_f64(v148, v151);
              v156 = vcvtq_f64_f32(*(float32x2_t *)v138.f32);
              v157 = vcvtq_f64_f32(*(float32x2_t *)v139.f32);
              v158 = vmulq_f64(v147, vcvt_hight_f64_f32(v138));
              v159 = vmulq_f64(v146, v156);
              v160 = vmulq_f64(v149, vcvt_hight_f64_f32(v139));
              v161 = vmulq_f64(v148, v157);
              v118 = v118
                   + v159.f64[0]
                   + v159.f64[1]
                   + v158.f64[0]
                   + v158.f64[1]
                   + v161.f64[0]
                   + v161.f64[1]
                   + v160.f64[0]
                   + v160.f64[1];
              v125 -= 2;
              v116 = v116
                   + v153.f64[0]
                   + v153.f64[1]
                   + v152.f64[0]
                   + v152.f64[1]
                   + v155.f64[0]
                   + v155.f64[1]
                   + v154.f64[0]
                   + v154.f64[1];
              v121 += 0x800000000;
              v126 -= 8;
            }
            while (v126);
            v119 = v95 & 0xFFFFFFFFFFFFFFF8;
            v103 = v120;
            v106 = v315;
            if (v95 == (v95 & 0xFFFFFFFFFFFFFFF8))
              goto LABEL_75;
          }
          else
          {
            v119 = 0;
          }
          v162 = v119 << 32;
          v163 = (float *)(v113 - 4 * v119);
          do
          {
            v164 = *v163--;
            v165 = 8 * v119;
            *(double *)((char *)&v329 + v165) = *((double *)&v329 + v119) - (float)(v115 * v164);
            v166 = *(float *)(v114 + 4 * (v107 + (v162 >> 32)));
            *(double *)((char *)v326 + v165) = *((double *)v326 + v119) - (float)(v117 * v166);
            v167 = v320[v119];
            v116 = v116 + v164 * v167;
            v118 = v118 + v166 * v167;
            ++v119;
            v162 += 0x100000000;
          }
          while (v95 != v119);
        }
LABEL_75:
        v168 = -v116;
        v169 = -v118;
        if (v100 < 4)
          v170 = 1;
        else
          v170 = v109;
        if ((v170 & 1) != 0)
        {
          v171 = 0;
        }
        else
        {
          v172 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v168, 0);
          v173 = (float64x2_t *)&v323;
          v174 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v169, 0);
          v175 = (float64x2_t *)v322;
          v176 = v100 & 0xFFFFFFFFFFFFFFFCLL;
          v177 = v316;
          v178 = v110;
          do
          {
            v179 = *v178--;
            v180 = (int8x16_t)vrev64q_s32(v179);
            v181 = (float32x4_t)vextq_s8(v180, v180, 8uLL);
            v182 = vmlaq_f64(v173[1], vcvt_hight_f64_f32(v181), v172);
            *v173 = vmlaq_f64(*v173, vcvtq_f64_f32(*(float32x2_t *)v181.f32), v172);
            v173[1] = v182;
            v173 += 2;
            v183 = *(float32x4_t *)(v114 + (v177 >> 30));
            v184 = vmlaq_f64(v175[1], vcvt_hight_f64_f32(v183), v174);
            *v175 = vmlaq_f64(*v175, vcvtq_f64_f32(*(float32x2_t *)v183.f32), v174);
            v175[1] = v184;
            v175 += 2;
            v177 += 0x400000000;
            v176 -= 4;
          }
          while (v176);
          v171 = v100 & 0x7FFFFFFFFFFFFFFCLL;
          if (v100 == (v100 & 0x7FFFFFFFFFFFFFFCLL))
            goto LABEL_66;
        }
        v185 = (unint64_t)(v317 + v171) << 32;
        v186 = (float *)(v111 - 4 * v171);
        do
        {
          v187 = *v186--;
          v188 = v171;
          *(double *)&v324[v188 - 1] = *(double *)&v324[v171 - 1] + v168 * v187;
          v322[v188] = v322[v171++] + v169 * *(float *)(v114 + (v185 >> 30));
          v185 += 0x100000000;
        }
        while (v100 != v171);
LABEL_66:
        ++v105;
        v112 = (int32x4_t *)((char *)v112 + v97);
        v113 += v97;
        v110 = (int32x4_t *)((char *)v110 + v97);
        v111 += v97;
        a2 = v318;
      }
      while (v105 != v103);
    }
    v189 = *((double *)&v329 + v95);
    v190 = *((double *)v326 + v95);
    if (v95)
    {
      v191 = v320;
      v192 = v308;
      v193 = v308;
      do
      {
        v194 = *v191++;
        v189 = v189 + *(double *)&v325[v193 + 152] * v194;
        v190 = v190 + *(double *)((char *)&v328 + v193 + 8) * v194;
        v193 -= 8;
      }
      while (v193);
      v195 = v95 + 1;
      v196 = v95 + 1;
      *(double *)&v324[v196 - 1] = v189;
      v322[v196] = v190;
      v197 = v322[0];
      v198 = v323;
      v199 = v308;
      do
      {
        v200 = *(double *)((char *)v320 + v193);
        v190 = v190 + *(double *)((char *)v322 + v199) * v200;
        v197 = v197 + *(double *)((char *)&v322[1] + v193) * v200;
        v198 = v198 + *(double *)((char *)v324 + v193) * v200;
        v193 += 8;
        v199 -= 8;
      }
      while (v199);
    }
    else
    {
      v324[0] = v329;
      v322[1] = v190;
      v197 = v322[0];
      v195 = 1;
      v198 = v323;
      v192 = v308;
    }
    v201 = v190 * -2.0 / (v198 + v197);
    v202 = v101 * (1.0 - v201 * v201);
    v203 = v202;
    if (v202 <= v96)
    {
      v201 = sqrt(1.0 - v96 / v101);
      if (v190 > 0.0)
        v201 = -v201;
      v203 = v96;
    }
    v101 = v203;
    if (v95)
    {
      v204 = v320;
      v205 = (double *)v310;
      do
      {
        v206 = *v204;
        v207 = *v205;
        *v204 = *v204 + v201 * *v205;
        ++v204;
        *v205-- = v207 + v201 * v206;
        --v104;
      }
      while (v104);
    }
    v320[v95] = v201;
    if (v202 <= v96)
    {
      if (v195 < (int)v305)
      {
        bzero(&v320[v95 + 1], 8 * (v305 - v95 - 2) + 8);
        a2 = v318;
      }
      if (v305 < 8)
      {
        v222 = 0;
        v223 = v304;
        goto LABEL_119;
      }
      v222 = v305 & 0xFFFFFFF8;
      v226 = (float64x2_t *)v321;
      v223 = v304;
      v227 = v304 + 1;
      v228 = v222;
      do
      {
        v230 = v226[-2];
        v229 = v226[-1];
        v232 = *v226;
        v231 = v226[1];
        v226 += 4;
        v227[-1] = vnegq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v230), v229));
        *v227 = vnegq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v232), v231));
        v227 += 2;
        v228 -= 8;
      }
      while (v228);
      if (v222 != v305)
      {
LABEL_119:
        v233 = v305 - v222;
        v234 = &v223->f32[v222];
        v235 = &v320[v222];
        do
        {
          v236 = *v235++;
          v237 = v236;
          *v234++ = -v237;
          --v233;
        }
        while (v233);
      }
      if (a4 >= 1)
      {
        v238 = v305 - 3;
        if ((int)v305 > 3)
        {
          v239 = 0;
          v240 = 4;
          if (v238 > 4)
            v240 = v305 - 3;
          v241 = ((v240 - 1) >> 2) + 1;
          v242 = (const float *)(a2 + 32);
          v243 = 4 * v315;
          v244 = a2 + 4;
          v245 = a2 + 8;
          v246 = (float *)(a2 + 16 * ((unint64_t)v305 >> 2));
          while (1)
          {
            if (v240 >= 0xD)
            {
              v248 = 0.0;
              v249 = v241 & 0x7FFFFFFFFFFFFFFCLL;
              v250 = v242;
              do
              {
                v251 = v250 - 8;
                v343 = vld4_f32(v251);
                v347 = vld4_f32(v250);
                v252 = vcvtq_f64_f32(v343.val[0]);
                v253 = vcvtq_f64_f32(v347.val[0]);
                v254 = vcvtq_f64_f32(v343.val[1]);
                v255 = vcvtq_f64_f32(v347.val[1]);
                v256 = vmlaq_f64(vmulq_f64(v254, v254), v252, v252);
                v257 = vmlaq_f64(vmulq_f64(v255, v255), v253, v253);
                v258 = vcvtq_f64_f32(v343.val[2]);
                v259 = vcvtq_f64_f32(v347.val[2]);
                *(float64x2_t *)v343.val[0].f32 = vcvtq_f64_f32(v343.val[3]);
                *(float64x2_t *)v343.val[1].f32 = vcvtq_f64_f32(v347.val[3]);
                v260 = vmlaq_f64(vmlaq_f64(v256, v258, v258), *(float64x2_t *)v343.val[0].f32, *(float64x2_t *)v343.val[0].f32);
                v261 = vmlaq_f64(vmlaq_f64(v257, v259, v259), *(float64x2_t *)v343.val[1].f32, *(float64x2_t *)v343.val[1].f32);
                v248 = v248 + v260.f64[0] + v260.f64[1] + v261.f64[0] + v261.f64[1];
                v250 += 16;
                v249 -= 4;
              }
              while (v249);
              v247 = 4 * (v241 & 0x7FFFFFFFFFFFFFFCLL);
              if (v241 == (v241 & 0x7FFFFFFFFFFFFFFCLL))
                goto LABEL_134;
            }
            else
            {
              v247 = 0;
              v248 = 0.0;
            }
            v262 = (float *)(v245 + 4 * v247);
            do
            {
              v263 = *(float *)(v244 + 4 * v247) * *(float *)(v244 + 4 * v247) + *(v262 - 2) * *(v262 - 2);
              v264 = *v262;
              v265 = v262[1];
              v262 += 4;
              v248 = v248 + v263 + v264 * v264 + v265 * v265;
              v247 += 4;
            }
            while (v247 < v238);
LABEL_134:
            if ((v305 & 0x7FFFFFFC) < v305)
            {
              v266 = v246;
              v267 = 4 * (v305 >> 2);
              do
              {
                v268 = *v266++;
                v248 = v248 + v268 * v268;
                ++v267;
              }
              while (v267 < (int)v305);
            }
            ++v239;
            v242 = (const float *)((char *)v242 + v243);
            v10 = v10 - v248;
            v244 += v243;
            v245 += v243;
            v246 = (float *)((char *)v246 + v243);
            if (v239 == v103)
              return v101 * v10;
          }
        }
        v299 = 0;
        do
        {
          v300 = 0.0;
          v301 = (float *)a2;
          v302 = v305;
          do
          {
            v303 = *v301++;
            v300 = v300 + v303 * v303;
            --v302;
          }
          while (v302);
          v10 = v10 - v300;
          ++v299;
          a2 += 4 * v315;
        }
        while (v299 != v103);
      }
      return v101 * v10;
    }
    if (v307 < 2)
    {
      v208 = 0;
LABEL_106:
      v216 = -v208;
      v217 = (double *)&v324[v208 - 1];
      do
      {
        v218 = *v217;
        v219 = &v309[v216];
        v220 = v219[1];
        *v217 = *v217 + v201 * v220;
        ++v217;
        v219[1] = v220 + v201 * v218;
        --v216;
      }
      while (v307 + v216);
      goto LABEL_54;
    }
    v209 = v307 & 0xFFFFFFFFFFFFFFFELL;
    v208 = v307 & 0x7FFFFFFFFFFFFFFELL;
    v210 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v201, 0);
    v211 = (float64x2_t *)&v323;
    v212 = (int8x16_t *)v309;
    do
    {
      v213 = *v211;
      v214 = (float64x2_t)vextq_s8(*v212, *v212, 8uLL);
      *v211 = vmlaq_f64(*v211, v214, v210);
      ++v211;
      v215 = (int8x16_t)vmlaq_f64(v214, v213, v210);
      *v212-- = vextq_s8(v215, v215, 8uLL);
      v209 -= 2;
    }
    while (v209);
    if (v307 != v208)
      goto LABEL_106;
LABEL_54:
    v99 = v307 + 1;
    ++v95;
    v314 = (int32x4_t *)((char *)v314 + 4);
    v313 += 4;
    v312 = (_OWORD *)((char *)v312 + 4);
    v316 -= 0x100000000;
    --v317;
    v311 += 4;
    v94 = v192 + 8;
    v98 = v310 + 1;
    v102 = v309 + 1;
    v108 = v100++ == v305;
  }
  while (!v108);
  v93 = v323;
  if (v305 < 8)
  {
    v224 = 0;
    v221 = 1.0;
    v225 = v304;
    goto LABEL_141;
  }
  v224 = v305 & 0xFFFFFFF8;
  v269 = (float64x2_t *)v325;
  v270 = (float64x2_t *)v321;
  v225 = v304;
  v271 = v304 + 1;
  v221 = 1.0;
  v272 = v224;
  do
  {
    v273 = v270[-2];
    v274 = v270[-1];
    v275 = *v270;
    v276 = v270[1];
    v270 += 4;
    v277 = v269[-2];
    v278 = v269[-1];
    v279 = *v269;
    v280 = v269[1];
    v269 += 4;
    v281 = vmulq_f64(v278, v274);
    v282 = vmulq_f64(v277, v273);
    v283 = vmulq_f64(v280, v276);
    v284 = vmulq_f64(v279, v275);
    v285 = vmulq_f64(v274, v274);
    v286 = vmulq_f64(v273, v273);
    v287 = vmulq_f64(v276, v276);
    v288 = vmulq_f64(v275, v275);
    v271[-1] = vnegq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v273), v274));
    *v271 = vnegq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v275), v276));
    v221 = v221
         + v286.f64[0]
         + v286.f64[1]
         + v285.f64[0]
         + v285.f64[1]
         + v288.f64[0]
         + v288.f64[1]
         + v287.f64[0]
         + v287.f64[1];
    v93 = v93
        + v282.f64[0]
        + v282.f64[1]
        + v281.f64[0]
        + v281.f64[1]
        + v284.f64[0]
        + v284.f64[1]
        + v283.f64[0]
        + v283.f64[1];
    v271 += 2;
    v272 -= 8;
  }
  while (v272);
  if (v224 != v305)
  {
LABEL_141:
    v289 = &v225->f32[v224];
    v290 = v305 - v224;
    v291 = v224;
    v292 = (double *)&v324[v224];
    v293 = &v320[v291];
    do
    {
      v294 = *v293++;
      v295 = v294;
      v296 = *v292++;
      v93 = v93 + v296 * v295;
      v221 = v221 + v295 * v295;
      *(float *)&v295 = v295;
      *v289++ = -*(float *)&v295;
      --v290;
    }
    while (v290);
  }
  return v93 + v10 * -0.00000999999975 * v221;
}

float comb_filter(float32x4_t *a1, float32x4_t *a2, int a3, int a4, int a5, int a6, int a7, _OWORD *a8, int8x16_t a9, float a10, double a11, double a12, double a13, double a14, double a15, int8x16_t a16, unsigned int a17)
{
  int32x2_t v17;
  uint64_t v18;
  uint64_t v19;
  float *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v26;
  float *v27;
  float v28;
  float v29;
  int32x2_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  float32x4_t *v36;
  float32x4_t *v37;
  float v38;
  float v39;
  unsigned int v40;
  uint64_t v41;
  __int8 *v42;
  int32x2_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  char *v48;
  char *v49;
  BOOL v51;
  BOOL v53;
  BOOL v55;
  BOOL v56;
  int8x16_t v57;
  int8x16_t v58;
  int8x16_t v59;
  float32x4_t *v63;
  uint64_t v64;
  float32x4_t *v65;
  float32x4_t *v66;
  int8x16_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int v74;
  uint64_t v75;
  __int8 *v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  float32x4_t v80;
  float32x4_t v81;
  uint64_t v82;
  float32x4_t *v83;
  float32x4_t *v84;
  uint64_t v85;
  float32x4_t v86;
  int8x16_t *v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  uint64_t v95;
  uint64_t v96;
  float *v97;
  float *v98;
  int v99;
  float v100;
  float v101;
  int32x2_t v102;

  if (*(float *)a9.i32 == 0.0 && a10 == 0.0)
  {
    if (a2 != a1)
      memmove(a1, a2, 4 * a5);
    return *(float *)a9.i32;
  }
  if (a3 <= 15)
    v18 = 15;
  else
    v18 = a3;
  if (a4 <= 15)
    v19 = 15;
  else
    v19 = a4;
  v20 = (float *)((char *)&comb_filter_gains + 12 * a7);
  *(float *)&a11 = *v20 * a10;
  *(float *)&a12 = v20[1] * a10;
  *(float *)&a13 = v20[2] * a10;
  v21 = -(int)v19;
  v22 = ~(_DWORD)v19;
  v23 = -2 - (int)v19;
  if (a6 == a7 && *(float *)a9.i32 == a10 && (_DWORD)v18 == (_DWORD)v19)
    v26 = 0;
  else
    v26 = a17;
  if ((int)v26 >= 1)
  {
    v27 = (float *)((char *)&comb_filter_gains + 12 * a6);
    v28 = *v27 * *(float *)a9.i32;
    v29 = v27[1] * *(float *)a9.i32;
    *(float *)a9.i32 = v27[2] * *(float *)a9.i32;
    a16.i32[0] = a2->i32[v23];
    v17.i32[0] = a2->i32[v22];
    v30 = *(int32x2_t *)&a2->f32[v21];
    if (v26 >= 8)
    {
      v31 = 0;
      v46 = (unint64_t)a1->u64 + 4 * v26;
      v47 = 4 * v26 + 8;
      v48 = (char *)a2 + v47 - 4 * v18;
      v49 = (char *)a2 + v47 - 4 * v19;
      v51 = (float32x4_t *)&a2->f32[v26] > a1 && v46 > (unint64_t)a2;
      v53 = v49 > (char *)a1 && (unint64_t)&a2->u64[1] - 4 * v19 < v46;
      v55 = (float32x4_t *)((char *)a8 + 4 * v26) > a1 && v46 > (unint64_t)a8;
      v56 = (unint64_t)a2 - 4 * v18 - 8 < v46 && v48 > (char *)a1;
      if (!v56 && !v51 && !v53 && !v55)
      {
        v31 = v26 & 0x7FFFFFFC;
        v57 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)a16.i8, 0);
        v58 = (int8x16_t)vdupq_lane_s32(v17, 0);
        v59 = (int8x16_t)vdupq_lane_s32(v30, 0);
        a16.i64[1] = *(uint64_t *)((char *)a2->i64 + 4 * v21);
        __asm { FMOV            V16.4S, #1.0 }
        v63 = a1;
        v64 = v26 & 0xFFFFFFFC;
        v65 = (float32x4_t *)a8;
        v66 = a2;
        do
        {
          v67 = a16;
          a16 = *(int8x16_t *)((char *)v66 + 8 - 4 * v19);
          v68 = *v65++;
          v69 = (float32x4_t)vextq_s8(v67, a16, 0xCuLL);
          v70 = (float32x4_t)vextq_s8(v59, (int8x16_t)v69, 0xCuLL);
          v71 = vmulq_f32(v68, v68);
          v72 = vsubq_f32(_Q16, v71);
          v73 = (float32x4_t)vextq_s8(v58, (int8x16_t)v70, 0xCuLL);
          *v63++ = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(*v66, *(float32x4_t *)((char *)v66 - 4 * v18), vmulq_n_f32(v72, v28)), vaddq_f32(*(float32x4_t *)((char *)v66 - 4 * v18 + 4), *(float32x4_t *)((char *)v66 - 4 * v18 - 4)), vmulq_n_f32(v72, v29)), vaddq_f32(*(float32x4_t *)((char *)v66 - 4 * v18 + 8), *(float32x4_t *)((char *)v66 - 4 * v18 - 8)), vmulq_n_f32(v72, *(float *)a9.i32)), v70, vmulq_n_f32(v71, *(float *)&a11)), vaddq_f32(v73, v69), vmulq_n_f32(v71, *(float *)&a12)), vaddq_f32((float32x4_t)vextq_s8(v57, (int8x16_t)v73, 0xCuLL), (float32x4_t)a16), vmulq_n_f32(v71, *(float *)&a13));
          ++v66;
          v57 = (int8x16_t)v73;
          v58 = (int8x16_t)v70;
          v59 = (int8x16_t)v69;
          v64 -= 4;
        }
        while (v64);
        if (v31 == v26)
        {
LABEL_25:
          v40 = v26;
          if (a10 == 0.0)
            goto LABEL_26;
LABEL_29:
          v41 = a5 - v40;
          if ((int)v41 < 1)
            return *(float *)a9.i32;
          v42 = &a2->i8[4 * v40];
          v43 = *(int32x2_t *)&v42[4 * v21];
          LODWORD(a14) = *(_DWORD *)&v42[4 * v22];
          a9.i32[0] = *(_DWORD *)&v42[4 * v23];
          v44 = v40;
          if (v41 >= 0x10)
          {
            v45 = 0;
            v74 = 2 - v19;
            if (2 - (int)v19 + (int)v41 - 1 >= 2 - (int)v19 && !((unint64_t)(v41 - 1) >> 32))
            {
              v45 = 0;
              v75 = 4 * v40;
              v76 = &a1->i8[4 * v44];
              if ((unint64_t)(v76 - (__int8 *)&a2->f32[v44]) >= 0x20
                && (unint64_t)(v76 - ((char *)a2 + v75 + -4 * (int)v19) - 8) >= 0x20)
              {
                v45 = v41 & 0x7FFFFFF8;
                v77 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)a9.i8, 0);
                v78 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)&a14, 0);
                v79 = (int8x16_t)vdupq_lane_s32(v43, 0);
                a9.u64[1] = (unint64_t)v43;
                v80 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a11, 0);
                v81 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a12, 0);
                v82 = v75 + 16;
                v83 = (float32x4_t *)((char *)a2 + v75 + 16);
                v84 = (float32x4_t *)((char *)a1 + v82);
                v85 = v41 & 0xFFFFFFF8;
                v86 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a13, 0);
                do
                {
                  v87 = (int8x16_t *)&v42[4 * v74];
                  v88 = (float32x4_t)vextq_s8(a9, *v87, 0xCuLL);
                  a9 = v87[1];
                  v89 = (float32x4_t)vextq_s8(v79, (int8x16_t)v88, 0xCuLL);
                  v90 = (float32x4_t)vextq_s8(*v87, a9, 0xCuLL);
                  v91 = (float32x4_t)vextq_s8(v78, (int8x16_t)v89, 0xCuLL);
                  v92 = (float32x4_t)vextq_s8((int8x16_t)v88, (int8x16_t)v90, 0xCuLL);
                  v93 = (float32x4_t)vextq_s8((int8x16_t)v89, (int8x16_t)v92, 0xCuLL);
                  v94 = vmlaq_f32(vmlaq_f32(vmlaq_f32(*v83, v92, v80), vaddq_f32(v93, v90), v81), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v91, (int8x16_t)v93, 0xCuLL), (float32x4_t)a9), v86);
                  v84[-1] = vmlaq_f32(vmlaq_f32(vmlaq_f32(v83[-1], v89, v80), vaddq_f32(v91, v88), v81), vaddq_f32((float32x4_t)vextq_s8(v77, (int8x16_t)v91, 0xCuLL), *(float32x4_t *)v87), v86);
                  *v84 = v94;
                  v83 += 2;
                  v84 += 2;
                  v74 += 8;
                  v77 = (int8x16_t)v93;
                  v78 = (int8x16_t)v92;
                  v79 = (int8x16_t)v90;
                  v85 -= 8;
                }
                while (v85);
                if (v45 == v41)
                  return *(float *)a9.i32;
                LODWORD(a14) = a9.i32[1];
                v43 = (int32x2_t)vextq_s8(a9, a9, 8uLL).u64[0];
              }
            }
          }
          else
          {
            v45 = 0;
          }
          v95 = v41 - v45;
          v96 = 4 * v45 + 4 * v44;
          v97 = (float *)((char *)a1->f32 + v96);
          v98 = (float *)((char *)a2->f32 + v96);
          v99 = v45 - v19 + 2;
          do
          {
            v100 = *(float *)&v42[4 * v99];
            v101 = *v98++;
            *v97++ = (float)(vmlas_n_f32(v101, *(float *)&a11, *(float *)v43.i32)
                           + (float)(*(float *)&a12 * (float)(*(float *)&a14 + *(float *)&v43.i32[1])))
                   + (float)(*(float *)&a13 * (float)(*(float *)a9.i32 + v100));
            v102.i32[0] = vdup_lane_s32(v43, 1).u32[0];
            a9.i32[0] = LODWORD(a14);
            LODWORD(a14) = v43.i32[0];
            *(float *)&v102.i32[1] = v100;
            ++v99;
            v43 = v102;
            --v95;
          }
          while (v95);
          return *(float *)a9.i32;
        }
        v17.i32[0] = a16.i32[1];
        v30 = (int32x2_t)vextq_s8(a16, a16, 8uLL).u64[0];
      }
    }
    else
    {
      v31 = 0;
    }
    v32 = 4 * v31;
    v33 = (uint64_t)&a2->i64[1] - 4 * v19;
    v34 = v26 - v31;
    v35 = (char *)a2 - 4 * v18;
    v36 = a2;
    v37 = a1;
    do
    {
      v38 = *(float *)(v33 + v32);
      v39 = *(float *)((char *)a8 + v32) * *(float *)((char *)a8 + v32);
      v37->f32[(unint64_t)v32 / 4] = (float)(vmlas_n_f32((float)((float)(v36->f32[(unint64_t)v32 / 4]+ (float)((float)(v28 * (float)(1.0 - v39))* *(float *)&v35[v32]))+ (float)((float)(v29 * (float)(1.0 - v39))* (float)(*(float *)&v35[v32 + 4]+ *(float *)&v35[v32 - 4])))+ (float)((float)(*(float *)a9.i32 * (float)(1.0 - v39))* (float)(*(float *)&v35[v32 + 8] + *(float *)&v35[v32 - 8])), *(float *)&a11 * v39, *(float *)v30.i32)+ (float)((float)(*(float *)&a12 * v39)* (float)(*(float *)v17.i32 + *(float *)&v30.i32[1])))+ (float)((float)(*(float *)&a13 * v39) * (float)(*(float *)a16.i32 + v38));
      a16.i32[0] = v17.i32[0];
      v17.i32[0] = v30.i32[0];
      v30.i32[0] = vdup_lane_s32(v30, 1).u32[0];
      v33 += 4;
      v37 = (float32x4_t *)((char *)v37 + 4);
      a8 = (_OWORD *)((char *)a8 + 4);
      *(float *)&v30.i32[1] = v38;
      v36 = (float32x4_t *)((char *)v36 + 4);
      v35 += 4;
      --v34;
    }
    while (v34);
    goto LABEL_25;
  }
  v40 = 0;
  if (a10 != 0.0)
    goto LABEL_29;
LABEL_26:
  if (a2 != a1)
    memmove(&a1->f32[(int)v26], &a2->f32[(int)v26], 4 * (a5 - (int)v26));
  return *(float *)a9.i32;
}

uint64_t celt_decode_with_ec(uint64_t a1, unsigned __int8 *a2, unsigned int a3, uint64_t a4, int a5, _BYTE *a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  int v29;
  int v30;
  uint64_t result;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  _QWORD *v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  float32x4_t *v54;
  uint64_t v55;
  uint64_t v56;
  int8x16_t v57;
  uint64_t v58;
  uint64_t v59;
  float *v60;
  float *v61;
  float v62;
  float v63;
  int v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  uint64_t v72;
  unsigned int v73;
  unsigned int v74;
  unint64_t v75;
  int v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  float v81;
  int v82;
  int v83;
  uint64_t v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  unsigned int v88;
  unsigned int v89;
  unint64_t v90;
  int v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  int v96;
  unsigned int v97;
  signed int v98;
  unsigned int v99;
  unsigned int v100;
  uint64_t v101;
  int v102;
  int v103;
  unsigned int v104;
  unsigned int v105;
  int v106;
  int v107;
  unsigned int v108;
  unsigned int v109;
  int v110;
  uint64_t v111;
  int v112;
  int v113;
  int v114;
  _BOOL4 v115;
  signed int v116;
  unsigned int v117;
  unsigned int v118;
  int v119;
  unsigned int v120;
  unsigned int v121;
  unint64_t v122;
  int v123;
  unint64_t v124;
  uint64_t v125;
  int v126;
  _BOOL4 v127;
  int v128;
  unsigned int v129;
  unsigned int v130;
  int v131;
  unsigned int v132;
  unint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  _BYTE *v143;
  unsigned int v144;
  unsigned int v145;
  int v146;
  unsigned int v147;
  int v148;
  unsigned int v149;
  int v150;
  BOOL v151;
  int v152;
  unsigned int v153;
  int v154;
  unsigned int v155;
  signed int v156;
  unsigned int v157;
  unsigned int v158;
  int v159;
  unsigned int v160;
  unsigned int v161;
  unsigned int v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  unsigned int v168;
  uint64_t v169;
  unsigned int v170;
  unsigned int v171;
  unsigned int v172;
  int v173;
  unsigned int v174;
  uint64_t v175;
  int v176;
  unsigned int v177;
  unsigned int v178;
  int v179;
  unsigned int v180;
  unsigned int v181;
  int v182;
  unsigned int v183;
  uint64_t v184;
  int v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  int *v189;
  unint64_t v190;
  uint64_t v191;
  int *v192;
  int v193;
  uint64_t v194;
  unsigned int v195;
  unsigned int v196;
  const char *v197;
  unsigned int v198;
  int v199;
  int v200;
  unsigned int v201;
  int v202;
  unsigned int v203;
  uint64_t v204;
  int v205;
  uint64_t v206;
  int64_t v207;
  uint64_t v208;
  uint64_t v209;
  unsigned __int16 *v210;
  int64_t v211;
  unsigned int v212;
  unsigned int v213;
  unsigned __int16 *v214;
  uint64_t v215;
  unsigned int v216;
  unint64_t v218;
  int v219;
  unsigned __int16 *v220;
  uint64_t v221;
  uint64_t v222;
  unsigned int v223;
  unsigned int v224;
  uint64_t v225;
  uint64_t v226;
  _BYTE *v227;
  uint64_t v228;
  int v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  __int16 v233;
  int v234;
  int v235;
  uint64_t v236;
  unsigned int v237;
  int v238;
  int v239;
  int v240;
  int v241;
  int v242;
  unsigned int v243;
  unsigned int v244;
  unsigned int v245;
  unsigned int v246;
  int v247;
  unsigned int v248;
  uint64_t v249;
  int v250;
  unsigned int v251;
  int v253;
  int v254;
  unsigned int v255;
  unsigned int v256;
  int v257;
  unsigned int v258;
  uint64_t v259;
  int v260;
  unsigned int v261;
  BOOL v262;
  int v263;
  int v264;
  int v265;
  unsigned int v266;
  unsigned int v267;
  int v268;
  uint64_t v269;
  uint64_t v270;
  _BYTE *v271;
  int v272;
  _BOOL4 v273;
  uint64_t v274;
  unsigned int v275;
  unsigned int v276;
  int v277;
  const char *v278;
  unsigned int v279;
  int v280;
  int v281;
  int v282;
  unsigned int v283;
  uint64_t v284;
  int v285;
  unsigned int v286;
  unsigned int v287;
  _BOOL4 v288;
  int v289;
  int v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  int v296;
  uint64_t v297;
  uint64_t v298;
  int v299;
  uint64_t v300;
  uint64_t v301;
  int v302;
  uint64_t v303;
  uint64_t v304;
  int v305;
  unsigned int v306;
  int v307;
  int v308;
  int v309;
  float v310;
  uint64_t v311;
  float v312;
  unsigned int v313;
  unsigned int v314;
  uint64_t v315;
  int v316;
  size_t v317;
  void **v318;
  uint64_t v319;
  uint64_t v320;
  char *v321;
  void *v322;
  uint64_t v323;
  int v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  _BYTE *v329;
  _BYTE *v330;
  uint64_t v331;
  uint64_t v332;
  int v333;
  int v334;
  int v335;
  unsigned int v336;
  signed int v337;
  int v338;
  int v339;
  int v340;
  char v341;
  int v342;
  unsigned int v343;
  unsigned int v344;
  uint64_t v345;
  int v346;
  unint64_t v347;
  unint64_t v348;
  BOOL v350;
  BOOL v351;
  int8x16_t v352;
  uint32x4_t v353;
  int8x16_t *v354;
  int32x4_t v355;
  int32x4_t *v356;
  int32x4_t v357;
  int16x8_t v358;
  int16x8_t v359;
  uint32x4_t v360;
  uint32x4_t v361;
  int8x16_t v362;
  uint64_t v363;
  int v364;
  int v365;
  uint64_t v366;
  int v367;
  int v368;
  uint64_t v369;
  unsigned int v370;
  int v371;
  _BYTE *v372;
  int v373;
  uint64_t v374;
  int v375;
  int8x16_t v376;
  double v377;
  double v378;
  double v379;
  double v380;
  int8x16_t v381;
  uint64_t v382;
  uint64_t v383;
  unsigned int v384;
  uint64_t v385;
  double v386;
  float32x4_t *v387;
  double v388;
  int v389;
  int v390;
  int v391;
  int v392;
  int v393;
  int v394;
  uint64_t v395;
  _BOOL4 v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  int v402;
  int v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  int v407;
  size_t v408;
  char *v409;
  uint64_t v410;
  unint64_t v411;
  uint64_t v412;
  float32x4_t *v413;
  uint64_t v414;
  int8x16_t *v415;
  int8x16_t v416;
  uint64_t v417;
  float *v418;
  float v419;
  int v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  float *v426;
  float *v427;
  float v428;
  float v429;
  float v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v468;
  _OWORD *v469;
  _OWORD *v470;
  uint64_t v471;
  _OWORD *v472;
  unint64_t v474;
  _OWORD *v475;
  _OWORD *v476;
  uint64_t v477;
  uint64_t v478;
  _OWORD *v479;
  unint64_t v481;
  _OWORD *v482;
  _OWORD *v483;
  float32x4_t v484;
  float32x4_t *v485;
  float32x4_t *v486;
  uint64_t v487;
  float32x4_t v488;
  float32x4_t v489;
  int8x16_t v490;
  int v491;
  unsigned int v492;
  int v493;
  _BYTE v494[12];
  int v495;
  uint64_t v496;
  int v497;
  int v498;
  _BYTE *v499;
  uint64_t v500;
  int v501;
  _BOOL4 v502;
  _BYTE *v503;
  int v504;
  uint64_t v505;
  int v506;
  unint64_t v507;
  uint64_t v508;
  uint64_t v509;
  char *v510;
  unsigned int v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  uint64_t v515;
  _BOOL4 v516;
  uint64_t v517;
  int v518;
  signed int v519;
  char *v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  _BYTE *v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  unsigned int v528;
  int v529;
  int v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  int v534;
  uint64_t v535;
  _BYTE v536[56];
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  _QWORD v540[2];

  v540[1] = *MEMORY[0x24BDAC8D0];
  memset(v536, 0, sizeof(v536));
  v7 = *(int *)(a1 + 12);
  v535 = 0;
  v8 = *(_QWORD *)a1;
  v9 = *(_DWORD *)(*(_QWORD *)a1 + 40);
  if (v9 < 0)
    return 0xFFFFFFFFLL;
  v14 = 0;
  v15 = 0;
  v16 = *(unsigned int *)(v8 + 8);
  v17 = *(int *)(v8 + 4);
  v18 = (int)v16;
  v527 = *(_QWORD *)(v8 + 32);
  v20 = *(int *)(a1 + 24);
  v19 = *(int *)(a1 + 28);
  v21 = *(unsigned int *)(a1 + 24);
  v528 = *(_DWORD *)(a1 + 16);
  v22 = (*(_DWORD *)(a1 + 20) * a5);
  v23 = v17 + 2048;
  v24 = ((int)v17 + 2048) * (int)v7;
  v25 = 24 * v7;
  v26 = (char *)(a1 + 4 * v24 + 96 * v7 + 96);
  v27 = 2 * (int)v16;
  v28 = &v26[4 * v27];
  v533 = v8;
  v29 = v9 + 1;
  v30 = 1;
  while (*(_DWORD *)(v8 + 48) << v15 != (_DWORD)v22)
  {
    ++v15;
    v30 -= 2;
    v14 += 8;
    if (v29 == v15)
      return 0xFFFFFFFFLL;
  }
  v532 = v17;
  v520 = &v28[4 * v27];
  result = 0xFFFFFFFFLL;
  if (a3 <= 0x4FB && a4)
  {
    v510 = &v26[4 * v27];
    v507 = (unint64_t)&v28[4 * v27 + 4 * v27];
    v517 = a4;
    v32 = 0;
    v539 = 0;
    v540[0] = 0;
    v537 = 0;
    v538 = 0;
    v33 = (int)v22;
    v522 = v7;
    if ((int)v7 <= 1)
      v34 = 1;
    else
      v34 = v7;
    v35 = 4 * v23;
    v525 = v20;
    v518 = a7;
    v514 = 2 * (int)v16;
    if (v34 < 2)
      goto LABEL_16;
    v36 = v21;
    v37 = ((int)v17 + 2048) * (int)v7;
    v32 = v34 & 0x7FFFFFFE;
    v38 = &v538;
    v39 = v540;
    v40 = v32;
    v41 = a1;
    do
    {
      *(v39 - 1) = v41 + 96;
      *v39 = v41 + v35 + 96;
      *(v38 - 1) = v41 + 8288 - 4 * (int)v22;
      *v38 = v41 + v35 - 4 * (int)v22 + 8288;
      v41 += 8 * v23;
      v38 += 2;
      v39 += 2;
      v40 -= 2;
    }
    while (v40);
    LODWORD(v20) = v525;
    v33 = (int)v22;
    v24 = v37;
    v21 = v36;
    v25 = 24 * v7;
    v18 = (int)v16;
    a7 = v518;
    if (v32 != v34)
    {
LABEL_16:
      v42 = v34 - v32;
      v43 = &v537 + v32;
      v44 = &v540[v32 - 1];
      v45 = a1 + 4 * v32 * v23;
      do
      {
        *v44++ = v45 + 96;
        *v43++ = v45 + 8288 - 4 * v33;
        v45 += v35;
        --v42;
      }
      while (v42);
    }
    v534 = 0;
    v46 = *(_DWORD *)(v533 + 12);
    if ((int)v19 < v46)
      v46 = v19;
    if (!a2 || (int)a3 <= 1)
    {
      celt_decode_lost(a1, v22);
      deemphasis((uint64_t)&v537, v517, v22, v522, *(_DWORD *)(a1 + 20), (float *)(v533 + 16), (float *)(a1 + 88), a7);
      return ((int)v22 / *(_DWORD *)(a1 + 20));
    }
    v506 = v46;
    *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 56) != 0;
    if (!a6)
    {
      *(_QWORD *)v536 = a2;
      *(_DWORD *)&v536[8] = a3;
      *(_QWORD *)&v536[12] = 0;
      *(_DWORD *)&v536[20] = 0;
      v47 = *a2;
      *(_QWORD *)&v536[44] = *a2;
      v48 = 2;
      *(_DWORD *)&v536[36] = (v47 >> 1) ^ 0x7F;
      *(_DWORD *)&v536[28] = 2;
      v49 = a2[1];
      if (a3 < 3)
      {
        v50 = 0;
      }
      else
      {
        v48 = 3;
        *(_DWORD *)&v536[28] = 3;
        v50 = a2[2];
      }
      v51 = ((_WORD)v49 << 7) & 0xFF00 | (unsigned __int16)((_WORD)v47 << 15) | (((v47 >> 1) ^ 0x7F) << 16) | ((v50 | (v49 << 8)) >> 1);
      *(_DWORD *)&v536[24] = 33;
      *(_DWORD *)&v536[32] = 0x80000000;
      if (v48 >= a3)
      {
        v52 = 0;
      }
      else
      {
        *(_DWORD *)&v536[28] = v48 + 1;
        v52 = a2[v48];
      }
      *(_DWORD *)&v536[44] = v52;
      *(_DWORD *)&v536[36] = (((v52 | (v50 << 8)) >> 1) | (v51 << 8)) ^ 0xFFFFFF;
      a6 = v536;
    }
    if (v528 == 1 && (int)v18 >= 1)
    {
      if (v18 >= 8)
      {
        v53 = v16 & 0xFFFFFFF8;
        v54 = (float32x4_t *)(a1 + 4 * v24 + 4 * v25);
        v55 = 4 * v16;
        v56 = v53;
        do
        {
          v57 = vbslq_s8((int8x16_t)vcgtq_f32(v54[7], *(float32x4_t *)((char *)v54 + v55 + 112)), (int8x16_t)v54[7], *(int8x16_t *)((char *)&v54[7] + v55));
          v54[6] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v54[6], *(float32x4_t *)((char *)v54 + v55 + 96)), (int8x16_t)v54[6], *(int8x16_t *)((char *)&v54[6] + v55));
          v54[7] = (float32x4_t)v57;
          v54 += 2;
          v56 -= 8;
        }
        while (v56);
        if (v53 == v16)
          goto LABEL_42;
      }
      else
      {
        v53 = 0;
      }
      v58 = v16 - v53;
      v59 = 4 * v25 + a1;
      v60 = (float *)(4 * v24 + 4 * (v53 + v16) + v59 + 96);
      v61 = (float *)(4 * v24 + 4 * v53 + v59 + 96);
      do
      {
        v62 = *v60++;
        v63 = v62;
        if (*v61 > v62)
          v63 = *v61;
        *v61++ = v63;
        --v58;
      }
      while (v58);
    }
LABEL_42:
    v64 = 8 * a3;
    v65 = *((_DWORD *)a6 + 6);
    v66 = *((_DWORD *)a6 + 8);
    v67 = __clz(v66);
    v68 = v65 + v67 - 32;
    LODWORD(v524) = a3;
    if (v68 < (int)(8 * a3))
    {
      if (v65 + v67 != 33)
      {
        v495 = 0;
        v498 = 1;
        goto LABEL_60;
      }
      v69 = *((_DWORD *)a6 + 9);
      v70 = v66 >> 15;
      v71 = v69;
      if (v69 >= v66 >> 15)
      {
        *((_DWORD *)a6 + 9) = v69 - (v66 >> 15);
        v71 = v69 - v70;
      }
      v72 = v33;
      v73 = v66 - v70;
      if (v69 >= v70)
        v74 = v73;
      else
        v74 = v70;
      *((_DWORD *)a6 + 8) = v74;
      if (v74 >= 0x800001)
      {
        v66 = v74;
      }
      else
      {
        v75 = *((unsigned int *)a6 + 2);
        v76 = *((_DWORD *)a6 + 11);
        v77 = *((unsigned int *)a6 + 7);
        do
        {
          v65 += 8;
          *((_DWORD *)a6 + 6) = v65;
          v66 = v74 << 8;
          *((_DWORD *)a6 + 8) = v74 << 8;
          if (v77 < v75)
          {
            v78 = *(_QWORD *)a6;
            *((_DWORD *)a6 + 7) = v77 + 1;
            v79 = *(unsigned __int8 *)(v78 + v77++);
          }
          else
          {
            v79 = 0;
          }
          *((_DWORD *)a6 + 11) = v79;
          v71 = (((v71 & 0x7FFFFF) << 8) | ((v79 | (v76 << 8)) >> 1)) ^ 0xFF;
          *((_DWORD *)a6 + 9) = v71;
          v76 = v79;
          v151 = v74 > 0x8000;
          v74 <<= 8;
        }
        while (!v151);
      }
      if (v69 >= v70)
      {
        v495 = 0;
        v68 = 1;
        v498 = 1;
        LODWORD(v20) = v525;
        v33 = v72;
LABEL_60:
        v80 = 0;
        v81 = 0.0;
        v515 = v18;
        v82 = v19;
        v526 = v19;
        v509 = v24;
        v508 = v25;
        v523 = v21;
        v519 = v64;
        v513 = v16;
        v512 = v34;
        v505 = v33;
        if ((_DWORD)v20)
        {
          v529 = 0;
          v83 = v528;
          v84 = v533;
        }
        else
        {
          v83 = v528;
          v84 = v533;
          if (v68 + 16 > v64)
          {
            v529 = 0;
          }
          else
          {
            v85 = *((_DWORD *)a6 + 9);
            v86 = v66 >> 1;
            v87 = v85;
            if (v85 >= v66 >> 1)
            {
              *((_DWORD *)a6 + 9) = v85 - (v66 >> 1);
              v87 = v85 - v86;
            }
            v88 = v66 - v86;
            if (v85 >= v86)
              v89 = v88;
            else
              v89 = v86;
            *((_DWORD *)a6 + 8) = v89;
            if (v89 >= 0x800001)
            {
              v66 = v89;
            }
            else
            {
              v90 = *((unsigned int *)a6 + 2);
              v91 = *((_DWORD *)a6 + 11);
              v92 = *((unsigned int *)a6 + 7);
              do
              {
                v65 += 8;
                *((_DWORD *)a6 + 6) = v65;
                v66 = v89 << 8;
                *((_DWORD *)a6 + 8) = v89 << 8;
                if (v92 < v90)
                {
                  v93 = *(_QWORD *)a6;
                  *((_DWORD *)a6 + 7) = v92 + 1;
                  v94 = *(unsigned __int8 *)(v93 + v92++);
                }
                else
                {
                  v94 = 0;
                }
                *((_DWORD *)a6 + 11) = v94;
                v87 = (((v87 & 0x7FFFFF) << 8) | ((v94 | (v91 << 8)) >> 1)) ^ 0xFF;
                *((_DWORD *)a6 + 9) = v87;
                v91 = v94;
                v151 = v89 > 0x8000;
                v89 <<= 8;
              }
              while (!v151);
            }
            if (v85 >= v86)
            {
              v80 = 0;
              v529 = 0;
              v81 = 0.0;
              LODWORD(v20) = v525;
            }
            else
            {
              v95 = ec_dec_uint((uint64_t *)a6, 6u);
              v96 = v95 + 4;
              v97 = *((_DWORD *)a6 + 4);
              v98 = *((_DWORD *)a6 + 5);
              if (v98 >= (v95 + 4))
              {
                v102 = *((_DWORD *)a6 + 5);
                v64 = v519;
              }
              else
              {
                v99 = *((_DWORD *)a6 + 2);
                v100 = *((_DWORD *)a6 + 3);
                v64 = v519;
                do
                {
                  while (v100 < v99)
                  {
                    v101 = *(_QWORD *)a6;
                    *((_DWORD *)a6 + 3) = ++v100;
                    v97 |= *(unsigned __int8 *)(v101 + v99 - v100) << v98;
                    v102 = v98 + 8;
                    v151 = v98 < 17;
                    v98 += 8;
                    if (!v151)
                      goto LABEL_87;
                  }
                  v102 = v98 + 8;
                  v151 = v98 < 17;
                  v98 += 8;
                }
                while (v151);
              }
LABEL_87:
              v103 = v97 & ~(-1 << v96);
              v104 = v97 >> v96;
              v105 = v102 - v96;
              *((_DWORD *)a6 + 4) = v104;
              *((_DWORD *)a6 + 5) = v102 - v96;
              v106 = *((_DWORD *)a6 + 6) + v96;
              *((_DWORD *)a6 + 6) = v106;
              v107 = (16 << v95) + v103;
              if (v105 <= 2)
              {
                v108 = *((_DWORD *)a6 + 2);
                v109 = *((_DWORD *)a6 + 3);
                v110 = v102 - v95 - 12;
                do
                {
                  while (v109 < v108)
                  {
                    v111 = *(_QWORD *)a6;
                    *((_DWORD *)a6 + 3) = ++v109;
                    v110 += 8;
                    v104 |= *(unsigned __int8 *)(v111 + v108 - v109) << v110;
                    if (v110 >= 17)
                      goto LABEL_92;
                  }
                  v110 += 8;
                }
                while (v110 < 17);
LABEL_92:
                v105 = v110 + 8;
              }
              v80 = v107 - 1;
              v112 = v104 & 7;
              *((_DWORD *)a6 + 4) = v104 >> 3;
              *((_DWORD *)a6 + 5) = v105 - 3;
              v65 = v106 + 3;
              *((_DWORD *)a6 + 6) = v106 + 3;
              v66 = *((_DWORD *)a6 + 8);
              if ((int)(v106 + __clz(v66) - 27) <= v64)
              {
                v113 = v80;
                v114 = ec_dec_icdf((uint64_t *)a6, tapset_icdf, 2);
                v80 = v113;
                v64 = v519;
                v529 = v114;
                v65 = *((_DWORD *)a6 + 6);
                v66 = *((_DWORD *)a6 + 8);
              }
              else
              {
                v529 = 0;
              }
              v82 = v526;
              LODWORD(v20) = v525;
              v83 = v528;
              v84 = v533;
              v81 = (float)(v112 + 1) * 0.09375;
            }
            v68 = v65 + __clz(v66) - 32;
          }
        }
        v115 = 0;
        v116 = v68 + 3;
        v530 = v80;
        if (v15 && v116 <= v64)
        {
          v117 = *((_DWORD *)a6 + 9);
          v118 = v66 >> 3;
          v119 = v117;
          if (v117 >= v66 >> 3)
          {
            *((_DWORD *)a6 + 9) = v117 - (v66 >> 3);
            v119 = v117 - v118;
          }
          v120 = v66 - v118;
          if (v117 >= v118)
            v121 = v120;
          else
            v121 = v118;
          *((_DWORD *)a6 + 8) = v121;
          if (v121 >= 0x800001)
          {
            v66 = v121;
          }
          else
          {
            v122 = *((unsigned int *)a6 + 2);
            v123 = *((_DWORD *)a6 + 11);
            v124 = *((unsigned int *)a6 + 7);
            do
            {
              v65 += 8;
              *((_DWORD *)a6 + 6) = v65;
              v66 = v121 << 8;
              *((_DWORD *)a6 + 8) = v121 << 8;
              if (v124 < v122)
              {
                v125 = *(_QWORD *)a6;
                *((_DWORD *)a6 + 7) = v124 + 1;
                v126 = *(unsigned __int8 *)(v125 + v124++);
              }
              else
              {
                v126 = 0;
              }
              *((_DWORD *)a6 + 11) = v126;
              v119 = (((v119 & 0x7FFFFF) << 8) | ((v126 | (v123 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)a6 + 9) = v119;
              v123 = v126;
              v151 = v121 > 0x8000;
              v121 <<= 8;
            }
            while (!v151);
          }
          v115 = v117 < v118;
          v116 = v65 + __clz(v66) - 29;
          LODWORD(v20) = v525;
        }
        v127 = 0;
        if (v115)
          v128 = 1 << v15;
        else
          v128 = 0;
        v504 = v128;
        if (v116 <= v64)
        {
          v129 = *((_DWORD *)a6 + 9);
          v130 = v66 >> 3;
          v131 = v129;
          if (v129 >= v66 >> 3)
          {
            *((_DWORD *)a6 + 9) = v129 - (v66 >> 3);
            v131 = v129 - v130;
          }
          v132 = v66 - v130;
          if (v129 < v130)
            v132 = v130;
          *((_DWORD *)a6 + 8) = v132;
          if (v132 < 0x800001)
          {
            v133 = *((unsigned int *)a6 + 2);
            v134 = *((_DWORD *)a6 + 11);
            v135 = v65 + 8;
            v136 = *((unsigned int *)a6 + 7);
            do
            {
              *((_DWORD *)a6 + 6) = v135;
              *((_DWORD *)a6 + 8) = v132 << 8;
              if (v136 < v133)
              {
                v137 = *(_QWORD *)a6;
                *((_DWORD *)a6 + 7) = v136 + 1;
                v138 = *(unsigned __int8 *)(v137 + v136++);
              }
              else
              {
                v138 = 0;
              }
              v131 = (((v131 & 0x7FFFFF) << 8) | ((v138 | (v134 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)a6 + 11) = v138;
              *((_DWORD *)a6 + 9) = v131;
              v135 += 8;
              v134 = v138;
              v151 = v132 > 0x8000;
              v132 <<= 8;
            }
            while (!v151);
          }
          v127 = v129 < v130;
          LODWORD(v20) = v525;
        }
        v497 = 1 << v15;
        v139 = unquant_coarse_energy(v84, v20, v82, (uint64_t)v26, v127, (uint64_t *)a6, v83, v15);
        MEMORY[0x24BDAC7A8](v139, v494);
        v141 = v526;
        v521 = v142;
        v143 = &v494[-((v142 + 15) & 0x7FFFFFFF0)];
        v144 = *((_DWORD *)a6 + 2);
        v145 = 8 * v144;
        v146 = *((_DWORD *)a6 + 6);
        v147 = *((_DWORD *)a6 + 8);
        v148 = v146 - 32;
        v149 = v146 - 32 + __clz(v147);
        if (v115)
          v150 = 2;
        else
          v150 = 4;
        if (v15)
          v151 = v149 + v150 + 1 > v145;
        else
          v151 = 1;
        v152 = !v151;
        v500 = v140;
        if ((int)v523 < (int)v526)
        {
          v153 = v145 - v152;
          if (v115)
            v154 = 4;
          else
            v154 = 5;
          if (v149 + v150 <= v153)
          {
            v157 = *((_DWORD *)a6 + 9);
            v158 = v147 >> v150;
            v159 = v157;
            v156 = v519;
            if (v157 >= v158)
            {
              *((_DWORD *)a6 + 9) = v157 - v158;
              v159 = v157 - v158;
            }
            v160 = v147 - v158;
            if (v157 >= v158)
              v161 = v160;
            else
              v161 = v158;
            *((_DWORD *)a6 + 8) = v161;
            if (v161 >= 0x800001)
            {
              v147 = v161;
            }
            else
            {
              LODWORD(v140) = *((_DWORD *)a6 + 11);
              v162 = *((_DWORD *)a6 + 7);
              do
              {
                v146 += 8;
                *((_DWORD *)a6 + 6) = v146;
                v147 = v161 << 8;
                *((_DWORD *)a6 + 8) = v161 << 8;
                if (v162 < v144)
                {
                  v163 = *(_QWORD *)a6;
                  *((_DWORD *)a6 + 7) = v162 + 1;
                  v164 = *(unsigned __int8 *)(v163 + v162++);
                }
                else
                {
                  v164 = 0;
                }
                *((_DWORD *)a6 + 11) = v164;
                v159 = (((v159 & 0x7FFFFF) << 8) | ((v164 | ((_DWORD)v140 << 8)) >> 1)) ^ 0xFF;
                *((_DWORD *)a6 + 9) = v159;
                v140 = v164;
                v151 = v161 > 0x8000;
                v161 <<= 8;
              }
              while (!v151);
              v148 = v146 - 32;
            }
            v155 = v157 < v158;
            v149 = v148 + __clz(v147);
          }
          else
          {
            v155 = 0;
            v156 = v519;
          }
          v165 = v525;
          *(_DWORD *)&v143[4 * v525] = v155;
          v166 = v165 + 1;
          if ((_DWORD)v141 != (_DWORD)v166)
          {
            v168 = v155;
            do
            {
              if (v149 + v154 <= v153)
              {
                v169 = *((unsigned int *)a6 + 9);
                v170 = v147 >> v154;
                v140 = v169;
                if (v169 >= v147 >> v154)
                {
                  *((_DWORD *)a6 + 9) = v169 - (v147 >> v154);
                  v140 = v169 - v170;
                }
                v171 = v147 - v170;
                if (v169 >= v170)
                  v172 = v171;
                else
                  v172 = v170;
                *((_DWORD *)a6 + 8) = v172;
                if (v172 >= 0x800001)
                {
                  v147 = v172;
                }
                else
                {
                  v173 = *((_DWORD *)a6 + 11);
                  v174 = *((_DWORD *)a6 + 7);
                  do
                  {
                    v146 += 8;
                    *((_DWORD *)a6 + 6) = v146;
                    v147 = v172 << 8;
                    *((_DWORD *)a6 + 8) = v172 << 8;
                    if (v174 < v144)
                    {
                      v175 = *(_QWORD *)a6;
                      *((_DWORD *)a6 + 7) = v174 + 1;
                      v176 = *(unsigned __int8 *)(v175 + v174++);
                    }
                    else
                    {
                      v176 = 0;
                    }
                    *((_DWORD *)a6 + 11) = v176;
                    v140 = (((v140 & 0x7FFFFF) << 8) | ((v176 | (v173 << 8)) >> 1)) ^ 0xFF;
                    *((_DWORD *)a6 + 9) = v140;
                    v173 = v176;
                    v151 = v172 > 0x8000;
                    v172 <<= 8;
                  }
                  while (!v151);
                }
                v168 ^= v169 < v170;
                v149 = v146 + __clz(v147) - 32;
                v155 |= v168;
              }
              *(_DWORD *)&v143[4 * v166++] = v168;
            }
            while ((_DWORD)v141 != (_DWORD)v166);
          }
        }
        else
        {
          v155 = 0;
          v156 = v519;
        }
        if (v152)
        {
          v167 = v525;
          if (tf_select_table[v155 + (unint64_t)(4 * v115) + v14] == tf_select_table[((4 * v115) | 2u) + (unint64_t)v155 + v14])
          {
            v152 = 0;
LABEL_192:
            if ((int)v167 < (int)v141)
            {
              v186 = v152 | (4 * v115);
              v187 = v141 - v167;
              v188 = v167;
              if ((unint64_t)(v141 - v167) < 2)
                goto LABEL_197;
              v188 = (v187 & 0xFFFFFFFFFFFFFFFELL) + v167;
              v189 = (int *)&v143[4 * v167 + 4];
              v190 = v187 & 0xFFFFFFFFFFFFFFFELL;
              do
              {
                v140 = tf_select_table[v186 + *v189 + v14];
                *(v189 - 1) = tf_select_table[v186 + *(v189 - 1) + v14];
                *v189 = v140;
                v189 += 2;
                v190 -= 2;
              }
              while (v190);
              if (v187 != (v187 & 0xFFFFFFFFFFFFFFFELL))
              {
LABEL_197:
                v191 = v141 - v188;
                v192 = (int *)&v143[4 * v188];
                do
                {
                  *v192 = tf_select_table[*v192 + (unint64_t)v186 + v14];
                  ++v192;
                  --v191;
                }
                while (v191);
              }
            }
            v503 = v143;
            if ((int)(v146 + __clz(v147) - 28) <= v156)
            {
              v195 = *((_DWORD *)a6 + 9);
              v196 = v147 >> 5;
              v193 = -1;
              v197 = "\x19\x17\x02";
              v194 = v533;
              do
              {
                v198 = v147;
                v199 = *(unsigned __int8 *)v197++;
                v147 = v196 * v199;
                ++v193;
                v200 = v195 - v196 * v199;
              }
              while (v195 < v196 * v199);
              v201 = v198 - v147;
              *((_DWORD *)a6 + 8) = v201;
              *((_DWORD *)a6 + 9) = v200;
              if (v201 < 0x800001)
              {
                v202 = *((_DWORD *)a6 + 11);
                v203 = *((_DWORD *)a6 + 7);
                do
                {
                  v146 += 8;
                  *((_DWORD *)a6 + 6) = v146;
                  *((_DWORD *)a6 + 8) = v201 << 8;
                  if (v203 < v144)
                  {
                    v204 = *(_QWORD *)a6;
                    *((_DWORD *)a6 + 7) = v203 + 1;
                    v205 = *(unsigned __int8 *)(v204 + v203++);
                  }
                  else
                  {
                    v205 = 0;
                  }
                  *((_DWORD *)a6 + 11) = v205;
                  v200 = (((v200 & 0x7FFFFF) << 8) | ((v205 | (v202 << 8)) >> 1)) ^ 0xFF;
                  *((_DWORD *)a6 + 9) = v200;
                  v202 = v205;
                  v151 = v201 > 0x8000;
                  v201 <<= 8;
                }
                while (!v151);
              }
            }
            else
            {
              v193 = 2;
              v194 = v533;
            }
            v206 = MEMORY[0x24BDAC7A8](v194, v140);
            v209 = (v208 + 15) & 0x7FFFFFFF0;
            v210 = (unsigned __int16 *)&v494[-v209];
            v211 = *(int *)(v206 + 8);
            v212 = v528;
            if ((int)v211 >= 1)
            {
              v213 = v528 - v30;
              v214 = *(unsigned __int16 **)(v206 + 32);
              v215 = *(_QWORD *)(v206 + 152);
              v216 = *v214;
              if (v211 < 0x10
                || ((int)(v211 * v213 + v211 - 1) >= (int)(v211 * v213)
                  ? (_ZF = (unint64_t)(v211 - 1) >> 32 == 0)
                  : (_ZF = 0),
                    !_ZF))
              {
                v218 = 0;
                goto LABEL_216;
              }
              v218 = 0;
              v347 = (unint64_t)&v210[2 * v211];
              v348 = v215 + (int)(v211 * v213);
              v350 = (unint64_t)v210 < v348 + v211 && v348 < v347;
              v351 = (unint64_t)(v214 + 1) >= v347 || v210 >= &v214[v211 + 1];
              if (!v351 || v350)
                goto LABEL_216;
              v352 = (int8x16_t)vdupq_n_s16(v216);
              v218 = v211 & 0xFFFFFFFFFFFFFFF0;
              v353 = (uint32x4_t)vdupq_n_s32(v15);
              v354 = (int8x16_t *)(v214 + 1);
              LODWORD(v206) = v211 * v213;
              v355.i64[0] = 0x4000000040;
              v355.i64[1] = 0x4000000040;
              v207 = v211 & 0xFFFFFFFFFFFFFFF0;
              v356 = (int32x4_t *)&v494[-v209];
              v357 = vdupq_n_s32(v528);
              do
              {
                v358 = (int16x8_t)vextq_s8(v352, *v354, 0xEuLL);
                v352 = v354[1];
                v359 = (int16x8_t)vextq_s8(*v354, v352, 0xEuLL);
                v360 = (uint32x4_t)vsubl_s16(*(int16x4_t *)v354->i8, *(int16x4_t *)v358.i8);
                v361 = (uint32x4_t)vsubl_high_s16(*(int16x8_t *)v354, v358);
                v362 = *(int8x16_t *)(v215 + (int)v206);
                v356[2] = vshrq_n_s32(vmulq_s32((int32x4_t)vshlq_u32((uint32x4_t)vsubl_s16(*(int16x4_t *)v352.i8, *(int16x4_t *)v359.i8), v353), vmulq_s32(v357, vaddq_s32((int32x4_t)vqtbl1q_s8(v362, (int8x16_t)xmmword_208F04F30), v355))), 2uLL);
                v356[3] = vshrq_n_s32(vmulq_s32((int32x4_t)vshlq_u32((uint32x4_t)vsubl_high_s16((int16x8_t)v352, v359), v353), vmulq_s32(v357, vaddq_s32((int32x4_t)vqtbl1q_s8(v362, (int8x16_t)xmmword_208F04F20), v355))), 2uLL);
                *v356 = vshrq_n_s32(vmulq_s32((int32x4_t)vshlq_u32(v360, v353), vmulq_s32(v357, vaddq_s32((int32x4_t)vqtbl1q_s8(v362, (int8x16_t)xmmword_208F04F50), v355))), 2uLL);
                v356[1] = vshrq_n_s32(vmulq_s32((int32x4_t)vshlq_u32(v361, v353), vmulq_s32(v357, vaddq_s32((int32x4_t)vqtbl1q_s8(v362, (int8x16_t)xmmword_208F04F40), v355))), 2uLL);
                v356 += 4;
                v354 += 2;
                v206 = (v206 + 16);
                v207 -= 16;
              }
              while (v207);
              if (v218 != v211)
              {
                LOWORD(v216) = v352.i16[7];
LABEL_216:
                v219 = v211 * v213;
                v220 = v214 + 1;
                do
                {
                  v206 = (__int16)v220[v218];
                  *(_DWORD *)&v210[2 * v218] = (int)((((_DWORD)v206 - (__int16)v216) << v15)
                                                   * v212
                                                   * (*(unsigned __int8 *)(v215 + v219 + (int)v218) + 64)) >> 2;
                  v207 = v218 + 1;
                  LOWORD(v216) = v206;
                  v218 = v207;
                }
                while (v207 < v211);
              }
            }
            v516 = v115;
            MEMORY[0x24BDAC7A8](v206, v207);
            v227 = &v494[-v226];
            v228 = ((_DWORD)v524 << 6);
            LODWORD(v226) = __clz(v224);
            v229 = ((__PAIR64__(8 * ((int)v226 + (int)v225), ec_tell_frac_correction[(v224 >> (16 - v226) >> 12) - 8])
                   - __PAIR64__(v224 >> (16 - v226) >> 12, v224 >> (16 - v226))) >> 32)
                 - 248;
            v230 = v526;
            v231 = v525;
            v511 = (_DWORD)v524 << 6;
            v524 = v227;
            if ((int)v525 < (int)v526)
            {
              v232 = v527;
              v233 = *(_WORD *)(v527 + 2 * v525);
              v234 = 6;
              v235 = v225;
              LODWORD(v236) = v225;
              v237 = v528;
              while (1)
              {
                v221 = v231 + 1;
                v238 = *(__int16 *)(v232 + 2 * (v231 + 1));
                v239 = ((v238 - v233) * v237) << v15;
                v240 = 8 * v239;
                if (v239 <= 48)
                  v239 = 48;
                if (v240 >= v239)
                  v241 = v239;
                else
                  v241 = v240;
                if (v229 + 8 * v234 >= (int)v228)
                  goto LABEL_221;
                v242 = *(_DWORD *)(v222 + 4 * v231);
                if (v242 < 1)
                  goto LABEL_221;
                v243 = *((_DWORD *)a6 + 9);
                v244 = v224 >> v234;
                v245 = v243;
                if (v243 >= v224 >> v234)
                {
                  *((_DWORD *)a6 + 9) = v243 - (v224 >> v234);
                  v245 = v243 - v244;
                }
                v246 = v224 - v244;
                if (v243 < v244)
                  v246 = v224 >> v234;
                *((_DWORD *)a6 + 8) = v246;
                if (v246 >= 0x800001)
                {
                  v236 = v225;
                  v224 = v246;
                }
                else
                {
                  v247 = *((_DWORD *)a6 + 11);
                  v248 = *((_DWORD *)a6 + 7);
                  do
                  {
                    v236 = (v236 + 8);
                    *((_DWORD *)a6 + 6) = v236;
                    v224 = v246 << 8;
                    *((_DWORD *)a6 + 8) = v246 << 8;
                    if (v248 < v223)
                    {
                      v249 = *(_QWORD *)a6;
                      *((_DWORD *)a6 + 7) = v248 + 1;
                      v250 = *(unsigned __int8 *)(v249 + v248++);
                    }
                    else
                    {
                      v250 = 0;
                    }
                    v245 = (((v245 & 0x7FFFFF) << 8) | ((v250 | (v247 << 8)) >> 1)) ^ 0xFF;
                    *((_DWORD *)a6 + 11) = v250;
                    *((_DWORD *)a6 + 9) = v245;
                    v247 = v250;
                    v235 = v236;
                    v151 = v246 > 0x8000;
                    v246 <<= 8;
                  }
                  while (!v151);
                }
                v251 = __clz(v224);
                v229 = ((__PAIR64__(8 * (v251 + v235), ec_tell_frac_correction[(v224 >> (16 - v251) >> 12) - 8])
                       - __PAIR64__(v224 >> (16 - v251) >> 12, v224 >> (16 - v251))) >> 32)
                     - 248;
                if (v243 >= v244)
                {
                  v225 = v236;
                  LODWORD(v236) = v235;
                  v230 = v526;
                  v237 = v528;
                  v232 = v527;
                  v227 = v524;
LABEL_221:
                  *(_DWORD *)&v227[4 * v231] = 0;
                  v233 = v238;
                  ++v231;
                  if (v221 == v230)
                    break;
                }
                else
                {
                  v228 = (v228 - v241);
                  if (v229 + 8 < (int)v228 && v241 < v242)
                  {
                    v235 = v236;
                    v253 = v241;
                    v254 = v245;
                    do
                    {
                      v255 = v224 >> 1;
                      if (v245 >= v224 >> 1)
                      {
                        *((_DWORD *)a6 + 9) = v245 - (v224 >> 1);
                        v254 = v245 - v255;
                      }
                      v256 = v224 - v255;
                      if (v245 < v255)
                        v256 = v224 >> 1;
                      *((_DWORD *)a6 + 8) = v256;
                      if (v256 >= 0x800001)
                      {
                        v224 = v256;
                      }
                      else
                      {
                        v257 = *((_DWORD *)a6 + 11);
                        v258 = *((_DWORD *)a6 + 7);
                        do
                        {
                          v236 = (v236 + 8);
                          *((_DWORD *)a6 + 6) = v236;
                          v224 = v256 << 8;
                          *((_DWORD *)a6 + 8) = v256 << 8;
                          if (v258 < v223)
                          {
                            v259 = *(_QWORD *)a6;
                            *((_DWORD *)a6 + 7) = v258 + 1;
                            v260 = *(unsigned __int8 *)(v259 + v258++);
                          }
                          else
                          {
                            v260 = 0;
                          }
                          v254 = (((v254 & 0x7FFFFF) << 8) | ((v260 | (v257 << 8)) >> 1)) ^ 0xFF;
                          *((_DWORD *)a6 + 11) = v260;
                          *((_DWORD *)a6 + 9) = v254;
                          v257 = v260;
                          v235 = v236;
                          v151 = v256 > 0x8000;
                          v256 <<= 8;
                        }
                        while (!v151);
                      }
                      v261 = __clz(v224);
                      v229 = ((__PAIR64__(8 * (v261 + v236), ec_tell_frac_correction[(v224 >> (16 - v261) >> 12) - 8])- __PAIR64__(v224 >> (16 - v261) >> 12, v224 >> (16 - v261))) >> 32)- 248;
                      if (v245 >= v255)
                        break;
                      v253 += v241;
                      v228 = (v228 - v241);
                      v262 = v229 + 8 < (int)v228 && v253 < v242;
                      v245 = v254;
                    }
                    while (v262);
                  }
                  else
                  {
                    v253 = v241;
                  }
                  v227 = v524;
                  *(_DWORD *)&v524[4 * v231] = v253;
                  if (v234 <= 3)
                    v263 = 3;
                  else
                    v263 = v234;
                  v264 = v263 - 1;
                  if (v253 > 0)
                    v234 = v264;
                  v225 = v236;
                  LODWORD(v236) = v235;
                  v230 = v526;
                  v237 = v528;
                  v232 = v527;
                  v233 = v238;
                  ++v231;
                  if (v221 == v526)
                    break;
                }
              }
            }
            v265 = MEMORY[0x24BDAC7A8](v228, v221);
            v270 = (v269 + 15) & 0x7FFFFFFF0;
            v271 = &v494[-v270];
            if (v272 + 48 <= v265)
            {
              v275 = *((_DWORD *)a6 + 9);
              v276 = v267 >> 7;
              v277 = -1;
              v278 = "~|wmW)\x13\t\x04\x02";
              v273 = v516;
              v274 = v511;
              do
              {
                v279 = v267;
                v280 = *(unsigned __int8 *)v278++;
                v267 = v276 * v280;
                ++v277;
                v281 = v275 - v276 * v280;
              }
              while (v275 < v276 * v280);
              v267 = v279 - v267;
              *((_DWORD *)a6 + 8) = v267;
              *((_DWORD *)a6 + 9) = v281;
              if (v267 < 0x800001)
              {
                v282 = *((_DWORD *)a6 + 11);
                v283 = *((_DWORD *)a6 + 7);
                do
                {
                  v268 += 8;
                  *((_DWORD *)a6 + 6) = v268;
                  v286 = v267 << 8;
                  *((_DWORD *)a6 + 8) = v267 << 8;
                  if (v283 < v266)
                  {
                    v284 = *(_QWORD *)a6;
                    *((_DWORD *)a6 + 7) = v283 + 1;
                    v285 = *(unsigned __int8 *)(v284 + v283++);
                  }
                  else
                  {
                    v285 = 0;
                  }
                  *((_DWORD *)a6 + 11) = v285;
                  v281 = (((v281 & 0x7FFFFF) << 8) | ((v285 | (v282 << 8)) >> 1)) ^ 0xFF;
                  *((_DWORD *)a6 + 9) = v281;
                  v282 = v285;
                  v151 = v267 > 0x8000;
                  v267 <<= 8;
                }
                while (!v151);
                v267 = v286;
              }
            }
            else
            {
              v273 = v516;
              v274 = v511;
            }
            v287 = __clz(v267);
            v288 = (int)(v274
                       + ~(((__PAIR64__(8 * (v287 + v268), ec_tell_frac_correction[(v267 >> (16 - v287) >> 12) - 8])
                           - __PAIR64__(v267 >> (16 - v287) >> 12, v267 >> (16 - v287))) >> 32)
                         - 248)) >= (int)v14 + 16;
            if ((int)(v274
                     + ~(((__PAIR64__(8 * (v287 + v268), ec_tell_frac_correction[(v267 >> (16 - v287) >> 12) - 8])
                         - __PAIR64__(v267 >> (16 - v287) >> 12, v267 >> (16 - v287))) >> 32)
                       - 248)) < (int)v14 + 16)
              v289 = 0;
            else
              v289 = 8;
            if (!v273)
            {
              v288 = 0;
              v289 = 0;
            }
            if (v15 < 2)
              v288 = 0;
            v502 = v288;
            if (v15 >= 2)
              v290 = v289;
            else
              v290 = 0;
            v501 = v290;
            v291 = MEMORY[0x24BDAC7A8](v274, v270);
            MEMORY[0x24BDAC7A8](v291, v292);
            v499 = &v494[-v293];
            v527 = v294;
            v295 = v533;
            v296 = v526;
            LODWORD(v521) = clt_compute_allocation(v533, v523, v526, (uint64_t)v524, v297, v298, (int *)&v535 + 1, (uint64_t)&v535, v299, &v534, v294, (uint64_t)v271, (uint64_t)&v494[-v293], v528, v15, (uint64_t)a6, 0, 0, 0);
            if ((int)v525 < v296)
            {
              if ((int)v528 <= 1)
                v300 = 1;
              else
                v300 = v528;
              v301 = v525;
              do
              {
                v302 = *(_DWORD *)&v271[4 * v301];
                if (v302 >= 1)
                {
                  v303 = 0;
                  v304 = *(int *)(v295 + 8);
                  v306 = *((_DWORD *)a6 + 4);
                  v305 = *((_DWORD *)a6 + 5);
                  v307 = *((_DWORD *)a6 + 6);
                  do
                  {
                    if (v305 >= v302)
                    {
                      v308 = v305;
                    }
                    else
                    {
                      v313 = *((_DWORD *)a6 + 2);
                      v314 = *((_DWORD *)a6 + 3);
                      do
                      {
                        while (v314 < v313)
                        {
                          v315 = *(_QWORD *)a6;
                          *((_DWORD *)a6 + 3) = ++v314;
                          v306 |= *(unsigned __int8 *)(v315 + v313 - v314) << v305;
                          v308 = v305 + 8;
                          v151 = v305 < 17;
                          v305 += 8;
                          if (!v151)
                            goto LABEL_299;
                        }
                        v308 = v305 + 8;
                        v151 = v305 < 17;
                        v305 += 8;
                      }
                      while (v151);
                    }
LABEL_299:
                    v309 = v306 & ~(-1 << v302);
                    v306 >>= v302;
                    v305 = v308 - v302;
                    *((_DWORD *)a6 + 4) = v306;
                    *((_DWORD *)a6 + 5) = v308 - v302;
                    v307 += v302;
                    v310 = (float)((float)((float)((float)v309 + 0.5) * (float)(1 << (14 - v302))) * 0.000061035) + -0.5;
                    v311 = 4 * (v301 + v303 * v304);
                    v312 = *(float *)&v26[v311];
                    *((_DWORD *)a6 + 6) = v307;
                    *(float *)&v26[v311] = v310 + v312;
                    ++v303;
                  }
                  while (v303 != v300);
                }
                ++v301;
              }
              while (v296 != (_DWORD)v301);
            }
            v524 = v271;
            if ((int)v532 >= 0)
              v316 = v532;
            else
              v316 = v532 + 1;
            v317 = 4 * ((v316 >> 1) - (int)v22 + 2048);
            v318 = (void **)&v539;
            v319 = v512;
            v320 = v505;
            do
            {
              v321 = (char *)*v318++;
              v322 = memmove(v321, &v321[4 * v320], v317);
              --v319;
            }
            while (v319);
            v324 = v528;
            v496 = v515 * v528;
            v325 = MEMORY[0x24BDAC7A8](v322, v323);
            MEMORY[0x24BDAC7A8](v325, v326);
            v329 = &v494[-v328];
            v330 = &v494[4 * v320 - v328];
            if (v324 == 2)
              v331 = (uint64_t)v330;
            else
              v331 = 0;
            v493 = *(_DWORD *)(a1 + 40);
            v492 = v521;
            v491 = v193;
            v332 = v533;
            v333 = v525;
            v334 = v526;
            v521 = v327;
            quant_all_bands(0, v533, v525, v526, (uint64_t)v329, v331, v327, 0, v527, v504, v491, v535, (uint64_t)v503, v511 - v501, v534, (char **)a6, v15, v492, (_DWORD *)(a1 + 44),
              0,
              v493);
            if (v502)
            {
              v336 = *((_DWORD *)a6 + 4);
              v335 = *((_DWORD *)a6 + 5);
              v337 = v519;
              if (v335)
              {
                v338 = v526;
                v339 = v525;
                v340 = v528;
                v341 = v498;
                v342 = v516;
              }
              else
              {
                v343 = *((_DWORD *)a6 + 2);
                v344 = *((_DWORD *)a6 + 3);
                v338 = v526;
                v339 = v525;
                v340 = v528;
                v341 = v498;
                v342 = v516;
                if (v344 >= v343)
                {
                  v346 = 0;
                }
                else
                {
                  v345 = *(_QWORD *)a6;
                  *((_DWORD *)a6 + 3) = ++v344;
                  v346 = *(unsigned __int8 *)(v345 + v343 - v344);
                }
                if (v344 >= v343)
                {
                  v364 = 0;
                }
                else
                {
                  v363 = *(_QWORD *)a6;
                  *((_DWORD *)a6 + 3) = ++v344;
                  v364 = *(unsigned __int8 *)(v363 + v343 - v344);
                }
                v365 = v346 | (v364 << 8);
                if (v344 >= v343)
                {
                  v367 = 0;
                }
                else
                {
                  v366 = *(_QWORD *)a6;
                  *((_DWORD *)a6 + 3) = ++v344;
                  v367 = *(unsigned __int8 *)(v366 + v343 - v344);
                }
                v368 = v365 | (v367 << 16);
                if (v344 >= v343)
                {
                  v371 = 0;
                }
                else
                {
                  v369 = *(_QWORD *)a6;
                  v370 = v344 + 1;
                  *((_DWORD *)a6 + 3) = v370;
                  v371 = *(unsigned __int8 *)(v369 + v343 - v370);
                }
                v336 |= v368 | (v371 << 24);
                v335 = 32;
              }
              v372 = v499;
              *((_DWORD *)a6 + 4) = v336 >> 1;
              *((_DWORD *)a6 + 5) = v335 - 1;
              v373 = *((_DWORD *)a6 + 6) + 1;
              *((_DWORD *)a6 + 6) = v373;
              unquant_energy_finalise(v332, v339, v338, (uint64_t)v26, (uint64_t)v524, (uint64_t)v372, v337 - (v373 + __clz(*((_DWORD *)a6 + 8))) + 32, (uint64_t *)a6, v340);
              if ((v336 & 1) != 0)
                anti_collapse(v332, (uint64_t)v329, v521, v15, v528, v22, v525, v526, (uint64_t)v26, (uint64_t)v510, (uint64_t)v520, v527, *(_DWORD *)(a1 + 44));
            }
            else
            {
              unquant_energy_finalise(v332, v333, v334, (uint64_t)v26, (uint64_t)v524, (uint64_t)v499, v519 - *((_DWORD *)a6 + 6) - __clz(*((_DWORD *)a6 + 8)) + 32, (uint64_t *)a6, v324);
              v341 = v498;
              v342 = v516;
            }
            v374 = a1;
            v531 = v22;
            if ((v341 & 1) != 0)
            {
              v375 = 0;
            }
            else
            {
              if ((int)v496 >= 1)
                memset_pattern16(v26, &unk_208F31A80, 4 * v496);
              v375 = v495;
            }
            celt_synthesis(v533, (uint64_t)v329, (uint64_t)&v537, (uint64_t)v26, v523, v506, v528, v522, v342, v15, *(_DWORD *)(a1 + 20), v375, *(_DWORD *)(a1 + 40));
            v382 = 0;
            v383 = 8 * v512;
            v384 = v532;
            v385 = v533;
            do
            {
              v376.i64[0] = *(_QWORD *)(a1 + 64);
              v386 = COERCE_DOUBLE(vmax_s32(*(int32x2_t *)v376.i8, (int32x2_t)0xF0000000FLL));
              *(double *)(a1 + 64) = v386;
              v387 = *(float32x4_t **)((char *)&v537 + v382);
              v376.i32[0] = *(_DWORD *)(a1 + 76);
              comb_filter(v387, v387, SHIDWORD(v386), SLODWORD(v386), *(_DWORD *)(v385 + 48), *(_DWORD *)(a1 + 84), *(_DWORD *)(a1 + 80), *(_OWORD **)(v385 + 72), v376, *(float *)(a1 + 72), v386, v377, v378, v379, v380, v381, v384);
              if (v15)
              {
                v376.i32[0] = *(_DWORD *)(a1 + 72);
                comb_filter((float32x4_t *)((char *)v387 + 4 * *(int *)(v385 + 48)), (float32x4_t *)((char *)v387 + 4 * *(int *)(v385 + 48)), *(_DWORD *)(a1 + 64), v530, v531 - *(_DWORD *)(v385 + 48), *(_DWORD *)(a1 + 80), v529, *(_OWORD **)(v385 + 72), v376, v81, v388, v377, v378, v379, v380, v381, v384);
              }
              v382 += 8;
            }
            while (v383 != v382);
            v389 = *(_DWORD *)(a1 + 64);
            v390 = *(_DWORD *)(a1 + 72);
            v391 = *(_DWORD *)(a1 + 80);
            v393 = v529;
            v392 = v530;
            *(_DWORD *)(a1 + 64) = v530;
            *(_DWORD *)(a1 + 68) = v389;
            *(float *)(a1 + 72) = v81;
            *(_DWORD *)(a1 + 76) = v390;
            *(_DWORD *)(a1 + 80) = v393;
            *(_DWORD *)(a1 + 84) = v391;
            if (v15)
            {
              *(_DWORD *)(a1 + 68) = v392;
              *(float *)(a1 + 76) = v81;
              *(_DWORD *)(a1 + 84) = v393;
            }
            v394 = v518;
            v395 = v515;
            v396 = v516;
            if (v528 == 1)
            {
              memcpy(&v26[4 * v515], v26, 4 * v515);
              v395 = v515;
            }
            v397 = v526;
            v398 = v509;
            v399 = v514;
            v400 = v508;
            v401 = v523;
            v402 = v513;
            v403 = v531;
            if (!v396)
            {
              v408 = 4 * v514;
              v409 = v510;
              memcpy(v520, v510, 4 * v514);
              memcpy(v409, v26, v408);
              v402 = v513;
              v401 = v523;
              v400 = v508;
              v399 = v514;
              v398 = v509;
              v397 = v526;
              v395 = v515;
              v404 = v533;
              v407 = v497;
              goto LABEL_381;
            }
            v404 = v533;
            if ((int)v513 < 1)
              goto LABEL_395;
            if ((int)v514 <= 1)
              v405 = 1;
            else
              v405 = v514;
            if (v405 >= 0x10)
            {
              v410 = 4 * v509 + 4 * v508;
              v411 = v410 + 4 * v405 + v374 + 96;
              v407 = v497;
              if ((unint64_t)v510 >= v411 || (unint64_t)v26 >= v411 + 4 * v514)
              {
                v406 = v405 & 0x7FFFFFF8;
                v412 = 4 * v514;
                v413 = (float32x4_t *)(v410 + v374 + 112);
                v414 = v406;
                do
                {
                  v415 = (int8x16_t *)((char *)v413 + v412);
                  v376 = vbslq_s8((int8x16_t)vcgtq_f32(v413[-1], *(float32x4_t *)((char *)v413 + v412 - 16)), *(int8x16_t *)((char *)&v413[-1] + v412), (int8x16_t)v413[-1]);
                  v416 = vbslq_s8((int8x16_t)vcgtq_f32(*v413, *(float32x4_t *)((char *)v413 + 4 * v399)), *(int8x16_t *)((char *)v413 + 4 * v399), *(int8x16_t *)v413);
                  v415[-1] = v376;
                  *v415 = v416;
                  v413 += 2;
                  v414 -= 8;
                }
                while (v414);
                if (v406 == v405)
                  goto LABEL_381;
              }
              else
              {
                v406 = 0;
              }
            }
            else
            {
              v406 = 0;
              v407 = v497;
            }
            v417 = v405 - v406;
            v418 = (float *)(4 * v406 + 4 * v398 + 4 * v400 + v374 + 96);
            do
            {
              v419 = v418[v399];
              if (v419 >= *v418)
                v419 = *v418;
              v418[v399] = v419;
              ++v418;
              --v417;
            }
            while (v417);
LABEL_381:
            v420 = *(_DWORD *)(v374 + 56) + v407;
            *(float *)v376.i32 = (float)v420 * 0.001;
            if (v420 > 160)
              *(float *)v376.i32 = 0.16;
            if (v402 >= 1)
            {
              if ((int)v399 <= 1)
                v421 = 1;
              else
                v421 = v399;
              if (v421 >= 0x10
                && ((v422 = v398 + v400, v507 >= v374 + 4 * (v398 + v400 + v421) + 96)
                 || (unint64_t)v26 >= 12 * (int)v399 + 4 * v422 + 4 * v421 + v374 + 96))
              {
                v423 = v421 & 0x7FFFFFF8;
                v484 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v376.i8, 0);
                v485 = (float32x4_t *)(12 * (int)v399 + 4 * v422 + v374 + 112);
                v486 = (float32x4_t *)(4 * v398 + 4 * v400 + v374 + 112);
                v487 = v423;
                do
                {
                  v488 = vaddq_f32(v484, v485[-1]);
                  v489 = vaddq_f32(v484, *v485);
                  v490 = vbslq_s8((int8x16_t)vcgtq_f32(*v486, v489), (int8x16_t)v489, *(int8x16_t *)v486);
                  v485[-1] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v486[-1], v488), (int8x16_t)v488, (int8x16_t)v486[-1]);
                  *v485 = (float32x4_t)v490;
                  v485 += 2;
                  v486 += 2;
                  v487 -= 8;
                }
                while (v487);
                if (v423 == v421)
                  goto LABEL_395;
              }
              else
              {
                v423 = 0;
              }
              v424 = v421 - v423;
              v425 = 4 * v423;
              v426 = (float *)(4 * v423 + 4 * v398 + 4 * v400 + v374 + 96);
              v427 = (float *)(v425 + 12 * (int)v399 + 4 * (v398 + v400) + v374 + 96);
              do
              {
                v428 = *v426++;
                v429 = v428;
                v430 = *(float *)v376.i32 + *v427;
                if (v430 >= v428)
                  v430 = v429;
                *v427++ = v430;
                --v424;
              }
              while (v424);
            }
LABEL_395:
            if ((int)v401 <= 0)
              goto LABEL_400;
            if (v525 >= 0x1C)
            {
              v431 = 0;
              if ((unint64_t)(8 * v399) >= 0x20)
              {
                v451 = 4 * v399;
                if ((unint64_t)(4 * v399) >= 0x20
                  && (unint64_t)(4 * v398 + 4 * v400 + v451 - (8 * v399 + 4 * v398 + 4 * v400)) >= 0x20)
                {
                  v452 = 0;
                  v431 = v401 & 0xFFFFFFF8;
                  v453 = 4 * v398 + 4 * v400;
                  v454 = v374 + v453;
                  v455 = v374 + 8 * v399 + v453;
                  __asm { FMOV            V1.4S, #-28.0 }
                  v459 = v374 + v451 + v453;
                  do
                  {
                    v460 = v454 + v452;
                    *(_OWORD *)(v460 + 96) = 0uLL;
                    *(_OWORD *)(v460 + 112) = 0uLL;
                    v461 = v455 + v452;
                    *(_OWORD *)(v461 + 96) = _Q1;
                    *(_OWORD *)(v461 + 112) = _Q1;
                    v462 = v459 + v452;
                    v452 += 32;
                    *(_OWORD *)(v462 + 96) = _Q1;
                    *(_OWORD *)(v462 + 112) = _Q1;
                  }
                  while (((4 * v401) & 0x3FFFFFFE0) != v452);
                  if (v431 == v401)
                  {
LABEL_400:
                    if ((int)v397 < (int)v395)
                    {
                      v436 = v395 - v397;
                      v437 = v397;
                      if ((unint64_t)(v395 - v397) < 0x20)
                        goto LABEL_402;
                      v437 = v397;
                      if ((unint64_t)(8 * v399
                                            + 4 * v397
                                            + 4 * v398
                                            + 4 * v400
                                            - (4 * v397
                                             + 4 * v398
                                             + 4 * v400)) < 0x20)
                        goto LABEL_402;
                      v471 = 4 * v399;
                      v437 = v397;
                      if ((unint64_t)(4 * v399) < 0x20)
                        goto LABEL_402;
                      v437 = v397;
                      if ((unint64_t)(4 * v397
                                            + 4 * v398
                                            + 4 * v400
                                            + v471
                                            - (8 * v399
                                             + 4 * v397
                                             + 4 * v398
                                             + 4 * v400)) < 0x20)
                        goto LABEL_402;
                      v437 = (v436 & 0xFFFFFFFFFFFFFFF8) + v397;
                      v472 = (_OWORD *)(4 * v397 + 4 * v398 + 4 * v400 + v374 + 96);
                      __asm { FMOV            V1.4S, #-28.0 }
                      v474 = v436 & 0xFFFFFFFFFFFFFFF8;
                      do
                      {
                        *v472 = 0uLL;
                        v472[1] = 0uLL;
                        v475 = (_OWORD *)((char *)v472 + 8 * v399);
                        *v475 = _Q1;
                        v475[1] = _Q1;
                        v476 = (_OWORD *)((char *)v472 + v471);
                        v472 += 2;
                        *v476 = _Q1;
                        v476[1] = _Q1;
                        v474 -= 8;
                      }
                      while (v474);
                      if (v436 != (v436 & 0xFFFFFFFFFFFFFFF8))
                      {
LABEL_402:
                        v438 = 0;
                        v439 = v395 - v437;
                        v440 = 4 * v437 + 4 * v398 + 4 * v400 + v374 + 96;
                        do
                        {
                          v441 = 4 * v438;
                          *(_DWORD *)(v440 + v441) = 0;
                          *(_DWORD *)(v440 + 8 * v399 + v441) = -1042284544;
                          *(_DWORD *)(v440 + 4 * v399 + v441) = -1042284544;
                          ++v438;
                        }
                        while (v439 != v438);
                      }
                    }
                    if ((int)v401 < 1)
                      goto LABEL_409;
                    if (v401 >= 0x1C)
                    {
                      v442 = 0;
                      if ((unint64_t)(8 * v399
                                            + 4 * v395
                                            + 4 * v398
                                            + 4 * v400
                                            - (4 * v395
                                             + 4 * v398
                                             + 4 * v400)) >= 0x20)
                      {
                        v463 = 4 * v399;
                        if ((unint64_t)(4 * v399) >= 0x20
                          && (unint64_t)(4 * v395
                                              + 4 * v398
                                              + 4 * v400
                                              + v463
                                              - (8 * v399
                                               + 4 * v395
                                               + 4 * v398
                                               + 4 * v400)) >= 0x20)
                        {
                          v464 = 0;
                          v442 = v401 & 0xFFFFFFF8;
                          v465 = 4 * v395 + 4 * v398 + 4 * v400;
                          v466 = v465 + v463 + v374 + 112;
                          __asm { FMOV            V1.4S, #-28.0 }
                          do
                          {
                            v468 = v374 + v465 + v464;
                            *(_OWORD *)(v468 + 96) = 0uLL;
                            *(_OWORD *)(v468 + 112) = 0uLL;
                            v469 = (_OWORD *)(v465 + 8 * v399 + v374 + 112 + v464);
                            *(v469 - 1) = _Q1;
                            *v469 = _Q1;
                            v470 = (_OWORD *)(v466 + v464);
                            *(v470 - 1) = _Q1;
                            *v470 = _Q1;
                            v464 += 32;
                          }
                          while (((4 * v401) & 0x3FFFFFFE0) != v464);
                          if (v442 == v401)
                            goto LABEL_409;
                        }
                      }
                    }
                    else
                    {
                      v442 = 0;
                    }
                    v443 = 0;
                    v444 = v401 - v442;
                    v445 = 4 * (v442 + v395) + 4 * v398 + 4 * v400 + v374 + 96;
                    do
                    {
                      v446 = 4 * v443;
                      *(_DWORD *)(v445 + v446) = 0;
                      *(_DWORD *)(v445 + 8 * v399 + v446) = -1042284544;
                      *(_DWORD *)(v445 + 4 * v399 + v446) = -1042284544;
                      ++v443;
                    }
                    while (v444 != v443);
LABEL_409:
                    if ((int)v397 < (int)v395)
                    {
                      v447 = v395 - v397;
                      if ((unint64_t)(v395 - v397) < 0x1C)
                        goto LABEL_411;
                      v477 = 4 * (v397 + v395);
                      if ((unint64_t)(8 * v399) < 0x20)
                        goto LABEL_411;
                      v478 = 4 * v399;
                      if ((unint64_t)(4 * v399) < 0x20)
                        goto LABEL_411;
                      if ((unint64_t)(4 * v398 + 4 * v400 + v478 - (8 * v399 + 4 * v398 + 4 * v400)) < 0x20)
                        goto LABEL_411;
                      v397 += v447 & 0xFFFFFFFFFFFFFFF8;
                      v479 = (_OWORD *)(v477 + 4 * v398 + 4 * v400 + v374 + 112);
                      __asm { FMOV            V1.4S, #-28.0 }
                      v481 = v447 & 0xFFFFFFFFFFFFFFF8;
                      do
                      {
                        *(v479 - 1) = 0uLL;
                        *v479 = 0uLL;
                        v482 = (_OWORD *)((char *)v479 + 8 * v399);
                        *(v482 - 1) = _Q1;
                        *v482 = _Q1;
                        v483 = (_OWORD *)((char *)v479 + v478);
                        *(v483 - 1) = _Q1;
                        *v483 = _Q1;
                        v479 += 2;
                        v481 -= 8;
                      }
                      while (v481);
                      if (v447 != (v447 & 0xFFFFFFFFFFFFFFF8))
                      {
LABEL_411:
                        v448 = 0;
                        v449 = 4 * (v397 + v395) + 4 * v398 + 4 * v400 + v374 + 96;
                        do
                        {
                          v450 = 4 * v448;
                          *(_DWORD *)(v449 + v450) = 0;
                          *(_DWORD *)(v449 + 8 * v399 + v450) = -1042284544;
                          *(_DWORD *)(v449 + 4 * v399 + v450) = -1042284544;
                          ++v448;
                        }
                        while (v395 - v397 != v448);
                      }
                    }
                    *(_DWORD *)(v374 + 44) = *((_DWORD *)a6 + 8);
                    deemphasis((uint64_t)&v537, v517, v403, v522, *(_DWORD *)(v374 + 20), (float *)(v404 + 16), (float *)(v374 + 88), v394);
                    *(_DWORD *)(v374 + 56) = 0;
                    if ((int)(*((_DWORD *)a6 + 6) + __clz(*((_DWORD *)a6 + 8)) - 32) > v519)
                      return 4294967293;
                    if (*((_DWORD *)a6 + 12))
                      *(_DWORD *)(v374 + 48) = 1;
                    return (v403 / *(_DWORD *)(v374 + 20));
                  }
                }
              }
            }
            else
            {
              v431 = 0;
            }
            v432 = 0;
            v433 = v401 - v431;
            v434 = 4 * v431 + 4 * v398 + 4 * v400 + v374 + 96;
            do
            {
              v435 = 4 * v432;
              *(_DWORD *)(v434 + v435) = 0;
              *(_DWORD *)(v434 + 8 * v399 + v435) = -1042284544;
              *(_DWORD *)(v434 + 4 * v399 + v435) = -1042284544;
              ++v432;
            }
            while (v433 != v432);
            goto LABEL_400;
          }
          v177 = *((_DWORD *)a6 + 9);
          v178 = v147 >> 1;
          v179 = v177;
          if (v177 >= v147 >> 1)
          {
            *((_DWORD *)a6 + 9) = v177 - (v147 >> 1);
            v179 = v177 - v178;
          }
          v180 = v147 - v178;
          if (v177 >= v178)
            v181 = v180;
          else
            v181 = v178;
          *((_DWORD *)a6 + 8) = v181;
          if (v181 >= 0x800001)
          {
            v147 = v181;
          }
          else
          {
            v182 = *((_DWORD *)a6 + 11);
            v183 = *((_DWORD *)a6 + 7);
            do
            {
              v146 += 8;
              *((_DWORD *)a6 + 6) = v146;
              v147 = v181 << 8;
              *((_DWORD *)a6 + 8) = v181 << 8;
              if (v183 < v144)
              {
                v184 = *(_QWORD *)a6;
                v140 = v183 + 1;
                *((_DWORD *)a6 + 7) = v140;
                v185 = *(unsigned __int8 *)(v184 + v183++);
              }
              else
              {
                v185 = 0;
              }
              *((_DWORD *)a6 + 11) = v185;
              v179 = (((v179 & 0x7FFFFF) << 8) | ((v185 | (v182 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)a6 + 9) = v179;
              v182 = v185;
              v151 = v181 > 0x8000;
              v181 <<= 8;
            }
            while (!v151);
          }
          v152 = 2 * (v177 < v178);
        }
        v167 = v525;
        goto LABEL_192;
      }
      v67 = __clz(v66);
      LODWORD(v20) = v525;
      v33 = v72;
    }
    v498 = 0;
    v65 = v64 - v67 + 32;
    *((_DWORD *)a6 + 6) = v65;
    v495 = 1;
    v68 = v64;
    goto LABEL_60;
  }
  return result;
}

void celt_decode_lost(uint64_t a1, uint64_t a2)
{
  int *v2;
  int *v3;
  char v4;
  char v5;
  int *v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  float **v22;
  int *v23;
  int v24;
  int *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  int v31;
  size_t v32;
  void **v33;
  char *v34;
  int32x2_t v35;
  int v36;
  int v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  float32x4_t v50;
  uint64_t v51;
  int *v52;
  uint64_t v53;
  _DWORD *v54;
  uint64_t v55;
  char *v56;
  char *v57;
  char *v58;
  int *v59;
  uint64_t v60;
  float32x4_t *v62;
  float32x4_t *v63;
  unint64_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int8x16_t v67;
  uint64_t v68;
  uint64_t v69;
  float *v70;
  float *v71;
  float v72;
  float v73;
  int v74;
  uint64_t v75;
  int v76;
  int v77;
  __int16 v78;
  int v79;
  int v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  int v84;
  float *v85;
  uint64_t v86;
  float *v87;
  float *v88;
  float v89;
  uint64_t v90;
  float v91;
  float v92;
  uint64_t v93;
  float32x4_t *v94;
  uint64_t v95;
  float32x4_t v96;
  int v97;
  int v98;
  __int32 v99;
  float v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  float32x4_t *v108;
  int v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  float32x4_t *v113;
  int v114;
  int v115;
  int v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  int v122;
  uint64_t v123;
  unint64_t v124;
  unint64_t v125;
  unint64_t v126;
  int v127;
  int v128;
  int v129;
  int v132;
  _BOOL4 v134;
  _BOOL4 v136;
  _BOOL4 v138;
  BOOL v139;
  int v140;
  uint64_t v141;
  uint64_t v142;
  int v143;
  float *v144;
  uint64_t i;
  unint64_t v146;
  float32x4_t v147;
  float32x4_t *v148;
  uint64_t v149;
  int *v150;
  float32x4_t *v151;
  unint64_t v152;
  uint64_t v153;
  uint64_t v154;
  float v155;
  uint64_t v156;
  unint64_t v157;
  float32x4_t *v158;
  uint64_t v159;
  uint64_t v160;
  float v161;
  unint64_t v162;
  uint64_t v163;
  unint64_t v164;
  float32x4_t *v165;
  float32x4_t v166;
  float32x4_t v167;
  float *v168;
  void *v169;
  const void *v170;
  char v171;
  float32x4_t *v172;
  uint64_t v173;
  float v174;
  float v175;
  int v176;
  int v177;
  uint64_t v178;
  float32x4_t *v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t *v182;
  float32x4_t v183;
  float32x4_t v184;
  uint64_t v185;
  int v186;
  int v187;
  float v188;
  int v189;
  __int32 v190;
  float v191;
  float v192;
  float v193;
  int v194;
  uint64_t v195;
  float *v196;
  float v197;
  __int32 v198;
  __int32 v199;
  float v200;
  float32x4_t v201;
  float32x4_t v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  int8x16_t v208;
  uint64_t v209;
  char v210;
  int v211;
  float32x4_t *v212;
  uint64_t v213;
  uint64_t v214;
  float v215;
  int v216;
  uint64_t v217;
  float32x4_t *v218;
  uint64_t v219;
  int v220;
  float v221;
  char v222;
  uint64_t v223;
  uint64_t v224;
  float *v225;
  int v226;
  float v227;
  uint64_t v228;
  BOOL v229;
  uint64_t v230;
  unint64_t v231;
  int v232;
  float32x4_t *v233;
  char v234;
  uint64_t v235;
  int v236;
  uint64_t v237;
  float *v238;
  uint64_t v239;
  int v240;
  int v241;
  uint64_t v242;
  char v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  float *v247;
  float *v248;
  int v249;
  float *v250;
  float v251;
  float v252;
  float v253;
  float *v254;
  float32x4_t *v255;
  BOOL v256;
  BOOL v257;
  BOOL v258;
  BOOL v259;
  BOOL v260;
  BOOL v261;
  float32x4_t *v263;
  float32x4_t *v264;
  int v265;
  uint64_t v266;
  float32x4_t *v267;
  uint64_t v268;
  int8x16_t v269;
  int8x16_t v270;
  uint64_t v271;
  int8x16_t v272;
  int8x16_t v273;
  float32x4_t v274;
  int v275;
  uint64_t v276;
  float32x4_t *v277;
  float32x4_t *v281;
  uint64_t v282;
  unint64_t v283;
  uint64_t v284;
  uint64_t v285;
  size_t v286;
  int v287;
  float32x4_t *v288;
  uint64_t v289;
  uint64_t v290;
  unint64_t v291;
  _BOOL4 v292;
  _BOOL4 v293;
  float32x4_t *v294;
  unint64_t v295;
  uint64_t v296;
  unint64_t v297;
  unint64_t v298;
  unint64_t v299;
  unint64_t v300;
  unint64_t v301;
  unint64_t v302;
  uint64_t v303;
  uint64_t *v304;
  float32x4_t v305;
  float32x4_t v306;
  float32x4_t v307;
  float32x4_t v308;
  float32x4_t v309;
  float32x4_t v310;
  int v311;
  uint64_t v312;
  int v313;
  int *v314;
  uint64_t v315;
  int v316;
  int v317;
  int v318;
  uint64_t v319;
  _BOOL4 v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  char *v345;
  size_t v346;
  char *v347;
  float32x4_t *v348;
  uint64_t v349;
  uint64_t v350;
  int *v351;
  uint64_t v352;
  size_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  int v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  float *v362;
  uint64_t v363;
  uint64_t v364;
  int *v365;
  float v366;
  float v367;
  float32x4_t v368;
  float32x4_t v369;
  float32x4_t v370;
  float32x4_t v371;
  float32x4_t v372;
  float32x2_t v373;
  float v374;
  float32x4_t v375[6];
  float32x4_t v376[256];
  uint64_t v377;
  uint64_t v378;
  float *v379;
  uint64_t v380;
  int8x16_t v381[256];
  uint64_t v382;

  v2 = (int *)MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v6 = v2;
  v7 = 0;
  v382 = *MEMORY[0x24BDAC8D0];
  v8 = (float *)v2[3];
  v379 = 0;
  v380 = 0;
  v377 = 0;
  v378 = 0;
  v9 = *(_QWORD *)v2;
  v364 = *(int *)(*(_QWORD *)v2 + 8);
  v355 = *(unsigned int *)(v9 + 4);
  v10 = *(_QWORD *)(v9 + 32);
  v11 = v2 + 24;
  v361 = (int)v355;
  v12 = (int)v355 + 2048;
  v314 = v3;
  v13 = (int)v3;
  if ((int)v8 <= 1)
    v14 = 1;
  else
    v14 = v8;
  v15 = 4 * v12;
  if (v14 < 2)
    goto LABEL_8;
  v7 = v14 & 0x7FFFFFFE;
  v16 = v15 - 4 * (int)v3 + 8288;
  v17 = &v378;
  v18 = 8288 - 4 * (int)v3;
  v19 = &v380;
  v2 = (int *)v7;
  v3 = v6;
  do
  {
    *(v19 - 1) = (uint64_t)(v3 + 24);
    *v19 = (uint64_t)&v3[(unint64_t)v15 / 4 + 24];
    *(v17 - 1) = (uint64_t)v3 + v18;
    *v17 = (uint64_t)v3 + v16;
    v3 += 2 * v12;
    v17 += 2;
    v19 += 2;
    v2 = (int *)((char *)v2 - 2);
  }
  while (v2);
  if (v7 != v14)
  {
LABEL_8:
    v20 = v14 - v7;
    v21 = &v377 + v7;
    v22 = &(&v379)[v7];
    v23 = &v6[v7 * v12];
    do
    {
      *v22++ = (float *)(v23 + 24);
      *v21++ = (uint64_t)v23 + 8288 - 4 * v13;
      v23 = (int *)((char *)v23 + v15);
      --v20;
    }
    while (v20);
  }
  v24 = v12 * (_DWORD)v8;
  v25 = &v11[v24];
  v26 = v6[6];
  v358 = v6[14];
  v365 = v6;
  v356 = v14;
  if (v358 > 39 || v26 || v6[15])
  {
    v304 = &v282;
    v359 = v24;
    v357 = 24 * (_QWORD)v8;
    v361 = (uint64_t)&v25[24 * (_QWORD)v8];
    v354 = 2 * v364;
    v27 = v26;
    v28 = v6[7];
    v363 = v9;
    LODWORD(v360) = *(_DWORD *)(v9 + 12);
    v362 = v8;
    MEMORY[0x24BDAC7A8](v2, v3);
    v30 = (char *)&v282 - v29;
    v32 = 4 * (((int)v355 >> 1) - v31 + 2048);
    v33 = (void **)&v379;
    do
    {
      v34 = (char *)*v33++;
      memmove(v34, &v34[4 * v13], v32);
      --v14;
    }
    while (v14);
    if ((int)v28 >= (int)v360)
      v36 = v360;
    else
      v36 = v28;
    if ((int)v27 <= v36)
      v37 = v36;
    else
      v37 = v27;
    v35.i32[0] = 0.5;
    if (!v358)
      *(float *)v35.i32 = 1.5;
    v38 = v365;
    v39 = v356;
    v40 = v364;
    if ((int)v27 < (int)v28)
    {
      v41 = 0;
      v42 = 0;
      v43 = 4 * v364;
      v44 = 4 * (v359 + v357 + v28) + 96;
      v45 = 12 * v354 + 4 * (v359 + v357);
      v46 = v45 + 4 * v27;
      v47 = v46 + 96;
      v48 = v28 - v27;
      v49 = (v28 - v27) & 0xFFFFFFFFFFFFFFF8;
      v50 = (float32x4_t)vdupq_lane_s32(v35, 0);
      v51 = (uint64_t)v365 + v46 + 112;
      v52 = &v365[v359 + v357];
      v53 = (uint64_t)&v52[v27 + 28];
      v54 = v52 + 24;
      v55 = (uint64_t)v365 + v45 + 96;
      v56 = (char *)&v365[3 * v354] + v44;
      v57 = (char *)v365 + v47;
      v58 = (char *)v365 + v44;
      v59 = &v365[v359 + 24 + v357 + v27];
      do
      {
        v60 = v27;
        if (v48 < 8)
          goto LABEL_35;
        _CF = (char *)v59 + v43 * v42 >= &v56[v43 * v42] || &v57[v43 * v42] >= &v58[v43 * v42];
        v60 = v27;
        if (!_CF)
          goto LABEL_35;
        v62 = (float32x4_t *)v53;
        v63 = (float32x4_t *)v51;
        v64 = (v28 - v27) & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v65 = vsubq_f32(v62[-1], v50);
          v66 = vsubq_f32(*v62, v50);
          v67 = vbslq_s8((int8x16_t)vcgtq_f32(*v63, v66), *(int8x16_t *)v63, (int8x16_t)v66);
          v62[-1] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v63[-1], v65), (int8x16_t)v63[-1], (int8x16_t)v65);
          *v62 = (float32x4_t)v67;
          v63 += 2;
          v62 += 2;
          v64 -= 8;
        }
        while (v64);
        v60 = v49 + v27;
        if (v48 != v49)
        {
LABEL_35:
          v68 = v28 - v60;
          v69 = v60 + v41;
          v70 = (float *)&v54[v69];
          v71 = (float *)(v55 + v69 * 4);
          do
          {
            v72 = *v71++;
            v73 = v72;
            if (v72 <= (float)(*v70 - *(float *)v35.i32))
              v73 = *v70 - *(float *)v35.i32;
            *v70++ = v73;
            --v68;
          }
          while (v68);
        }
        ++v42;
        v51 += v43;
        v53 += v43;
        v41 += v40;
      }
      while (v42 != v39);
    }
    v74 = v38[11];
    v75 = (uint64_t)v362;
    if ((int)v362 < 1 || (int)v27 >= v36)
    {
LABEL_59:
      v38[11] = v74;
      celt_synthesis(v363, (uint64_t)v30, (uint64_t)&v377, v361, v27, v37, v75, v75, 0, v5, v38[5], 0, v38[10]);
      goto LABEL_60;
    }
    v76 = 0;
    v77 = 0;
    v78 = *(_WORD *)(v10 + 2 * v27);
    v79 = (int)v314;
LABEL_44:
    LOWORD(v80) = v78;
    v81 = v27;
    while (1)
    {
      v82 = (__int16)v80;
      ++v81;
      v80 = *(__int16 *)(v10 + 2 * v81);
      v83 = ((v80 - v82) << v5);
      if ((int)v83 >= 1)
      {
        v84 = v82 << v5;
        v85 = (float *)&v30[4 * v76 + 4 * (v82 << v5)];
        v86 = ((v80 - v82) << v5);
        do
        {
          v74 = 1664525 * v74 + 1013904223;
          *v85++ = (float)(v74 >> 20);
          --v86;
        }
        while (v86);
        v87 = (float *)&v30[4 * v84 + 4 * v77 * v79];
        v88 = (float *)&v30[4 * v76 + 4 * v84];
        v89 = 0.0;
        v90 = v83;
        do
        {
          v91 = *v88++;
          v89 = v89 + (float)(v91 * v91);
          --v90;
        }
        while (v90);
        v92 = 1.0 / sqrtf(v89 + 1.0e-15);
        if (v83 >= 8)
        {
          v93 = v83 & 0x7FFFFFF8;
          v87 += v83 & 0xFFFFFFF8;
          v94 = (float32x4_t *)&v30[4 * v76 + 16 + 4 * v84];
          v95 = v83 & 0xFFFFFFF8;
          do
          {
            v96 = vmulq_n_f32(*v94, v92);
            v94[-1] = vmulq_n_f32(v94[-1], v92);
            *v94 = v96;
            v94 += 2;
            v95 -= 8;
          }
          while (v95);
          if (v93 == v83)
            goto LABEL_45;
        }
        else
        {
          LODWORD(v93) = 0;
        }
        v97 = v83 - v93;
        do
        {
          *v87 = v92 * *v87;
          ++v87;
          --v97;
        }
        while (v97);
      }
LABEL_45:
      if (v81 == v37)
      {
        ++v77;
        v76 += v79;
        if (v77 == (_DWORD)v75)
          goto LABEL_59;
        goto LABEL_44;
      }
    }
  }
  v351 = v25;
  if (v358)
  {
    v99 = v6[13];
    v100 = 0.8;
  }
  else
  {
    v381[0].i32[0] = 0;
    pitch_downsample(&v379, (char *)v375, 2048, (int)v8);
    pitch_search(&v376[84], v375, 1328, 620, v381);
    v99 = 720 - v381[0].i32[0];
    v6[13] = 720 - v381[0].i32[0];
    v100 = 1.0;
  }
  v304 = &v282;
  v352 = v13;
  v350 = -v13;
  if (2 * v99 >= 1024)
    v101 = 1024;
  else
    v101 = (2 * v99);
  v102 = MEMORY[0x24BDAC7A8](v355, v101);
  v348 = (float32x4_t *)((char *)&v282 - ((v103 + 15) & 0x7FFFFFFF0));
  v105 = MEMORY[0x24BDAC7A8](v102, v104);
  v347 = (char *)&v282 - v111;
  v112 = 0;
  v113 = *(float32x4_t **)(v9 + 72);
  v346 = 4 * (int)v106;
  v345 = (char *)&v375[262] - v346;
  v114 = (int)v106 >> 1;
  v115 = 2048 - v110;
  v116 = v109 - v99;
  v117 = (v361 + v110);
  if ((int)v361 >= 0)
    v118 = v361;
  else
    v118 = v361 + 1;
  v119 = (v118 >> 1);
  if (v114 <= 1)
    v120 = 1;
  else
    v120 = v114;
  v344 = 2047 - v110;
  v343 = 2046 - v110;
  v342 = 2045 - v110;
  v340 = 2043 - v110;
  v341 = 2044 - v110;
  v338 = 2041 - v110;
  v339 = 2042 - v110;
  v337 = 2040 - v110;
  v121 = v119 - 1;
  v122 = v361 - 1;
  if (v361 + 1 > (int)v117)
    v123 = v361 + 1;
  else
    v123 = (int)v117;
  v124 = v123 + ~v361;
  v125 = v105 - 1;
  v126 = v117 - 1;
  v127 = v109 - v114;
  v349 = v106;
  v128 = v109 - v106;
  v129 = v109 - v114 + v120 - 1;
  v317 = v128;
  _ZF = v128 + (int)v120 - 1 >= v128 && (unint64_t)(v120 - 1) >> 32 == 0;
  v318 = v127;
  v132 = !_ZF || v129 < v127;
  v316 = v132;
  v134 = v115 + (int)v126 < v115 || HIDWORD(v126) != 0;
  v320 = v134;
  v289 = v105 - 1;
  v136 = v115 + (int)v125 < v115 || HIDWORD(v125) != 0;
  v287 = v361 - v110 + 2048;
  v138 = v287 + (int)v124 < v287 || HIDWORD(v124) != 0;
  v292 = v138;
  v293 = v136;
  v336 = 2039 - v110;
  v139 = v122 - (int)v121 <= v122 && HIDWORD(v121) == 0;
  v310 = (float32x4_t)xmmword_208F31A30;
  v309 = (float32x4_t)xmmword_208F31A40;
  v308 = (float32x4_t)xmmword_208F31A50;
  v307 = (float32x4_t)xmmword_208F31A60;
  v306 = (float32x4_t)xmmword_208F31A70;
  v334 = 2037 - v110;
  v335 = 2038 - v110;
  v332 = 2035 - v110;
  v333 = 2036 - v110;
  v330 = 2033 - v110;
  v331 = 2034 - v110;
  v328 = 2031 - v110;
  v329 = 2032 - v110;
  v326 = 2029 - v110;
  v327 = 2030 - v110;
  v324 = 2027 - v110;
  v325 = 2028 - v110;
  v322 = 2025 - v110;
  v323 = 2026 - v110;
  v321 = 2024 - v110;
  v140 = v116 - v110 + 1024;
  v312 = (v361 - 1);
  v141 = 4 * v122 + 4;
  v142 = 4 * v119;
  v303 = v142 + 0x2000;
  v301 = (unint64_t)v108 + v142;
  v302 = (unint64_t)v113 + v142;
  v300 = (unint64_t)v113 + v141 - v142;
  v299 = (unint64_t)v108 + v141 - v142;
  v297 = (unint64_t)v108 + v141;
  v298 = (unint64_t)v113 + v141;
  v305 = (float32x4_t)vdupq_n_s32(0xB88637BE);
  v360 = (2048 - v110);
  v353 = 4 * v115;
  v286 = v353 + v107;
  v357 = v120;
  v315 = v120 & 0x3FFFFFF8;
  v359 = (v361 + v110);
  v319 = v117 & 0xFFFFFFF8;
  v283 = (unint64_t)v113 + v107;
  v284 = v105 & 0xFFFFFFF8;
  v295 = v123 - v361;
  v290 = v107;
  v291 = (v123 - v361) & 0xFFFFFFFFFFFFFFF8;
  v285 = v291 + v361;
  v143 = !v139;
  v313 = v143;
  v354 = v119;
  v296 = v119 & 0xFFFFFFF8;
  v294 = v113 + 1;
  v288 = v108 + 1;
  v364 = (int)v117;
  while (2)
  {
    v144 = (&v379)[v112];
    if ((unint64_t)((char *)v375 - (char *)v144 - 4000) >= 0x20)
    {
      v146 = -4192;
      do
      {
        v147 = *(float32x4_t *)&v144[v146 / 4 + 2052];
        v148 = &v375[v146 / 0x10];
        v148[262] = *(float32x4_t *)&v144[v146 / 4 + 2048];
        v148[263] = v147;
        v146 += 32;
      }
      while (v146);
    }
    else
    {
      for (i = 0; i != 1048; ++i)
        v375[0].f32[i] = v144[i + 1000];
    }
    v363 = v112;
    if (v358)
    {
      v149 = (24 * v112);
      v150 = v351;
      goto LABEL_140;
    }
    v362 = (float *)&v282;
    v151 = v376;
    if ((_DWORD)v355)
    {
      v311 = v365[10];
      v151 = (float32x4_t *)v381;
      memcpy(v381, v376, sizeof(v381));
      if ((int)v355 >= 1)
      {
        v152 = 0;
        v153 = 0x3FF00000000;
        v154 = v290;
        do
        {
          v155 = v113->f32[v152 / 4];
          v151 = (float32x4_t *)v381;
          *(float *)&v381[0].i32[v152 / 4] = v376[0].f32[v152 / 4] * v155;
          *(float *)((char *)v381[0].i32 + (v153 >> 30)) = v155 * *(float *)((char *)v376[0].f32 + (v153 >> 30));
          v153 -= 0x100000000;
          v152 += 4;
        }
        while (v154 != v152);
      }
    }
    celt_pitch_xcorr_c(v151->f32, v151->f32, &v366, 0x3E8u, 25);
    v156 = 0;
    v157 = 0;
    v158 = v151;
    v159 = 24;
    v160 = 1000;
    do
    {
      v161 = 0.0;
      if (v157 > 0x17)
        goto LABEL_126;
      v162 = 24 - v157;
      if (24 - v157 < 8)
      {
        v163 = v160;
        goto LABEL_130;
      }
      if (-1002 - (int)v157 < (23 - v157))
      {
        v163 = v160;
        do
        {
LABEL_130:
          v161 = v161 + (float)(v151->f32[v163] * v158->f32[v163]);
          ++v163;
        }
        while ((_DWORD)v163 != 1024);
        goto LABEL_126;
      }
      v163 = v160;
      if ((23 - v157) >> 32)
        goto LABEL_130;
      v164 = v159 & 0xFFFFFFFFFFFFFFF8;
      v163 = v160 + (v162 & 0xFFFFFFFFFFFFFFF8);
      v165 = v151;
      do
      {
        v166 = vmulq_f32(*(float32x4_t *)((char *)v165 + v156 + 4000), v165[250]);
        v167 = vmulq_f32(*(float32x4_t *)((char *)v165 + v156 + 4016), v165[251]);
        v161 = (float)((float)((float)((float)((float)((float)((float)(v161 + v166.f32[0]) + v166.f32[1]) + v166.f32[2])
                                             + v166.f32[3])
                                     + v167.f32[0])
                             + v167.f32[1])
                     + v167.f32[2])
             + v167.f32[3];
        v165 += 2;
        v164 -= 8;
      }
      while (v164);
      if (v162 != (v162 & 0xFFFFFFFFFFFFFFF8))
        goto LABEL_130;
LABEL_126:
      *(&v366 + v157) = v161 + *(&v366 + v157);
      ++v157;
      ++v160;
      --v159;
      v156 += 4;
      v158 = (float32x4_t *)((char *)v158 - 4);
    }
    while (v157 != 25);
    v366 = v366 * 1.0001;
    v367 = v367 + (float)(v367 * -0.000064);
    v368 = vmlaq_f32(v368, v310, vmulq_f32(vmulq_f32(v368, v305), v310));
    v369 = vmlaq_f32(v369, v309, vmulq_f32(vmulq_f32(v369, v305), v309));
    v370 = vmlaq_f32(v370, v308, vmulq_f32(vmulq_f32(v370, v305), v308));
    v371 = vmlaq_f32(v371, v307, vmulq_f32(vmulq_f32(v371, v305), v307));
    v372 = vmlaq_f32(v372, v306, vmulq_f32(vmulq_f32(v372, v305), v306));
    v373 = vmla_f32(v373, (float32x2_t)0x41B8000041B00000, vmul_f32(vmul_f32(v373, *(float32x2_t *)v305.f32), (float32x2_t)0x41B8000041B00000));
    v374 = v374 + (float)((float)((float)(v374 * -0.000064) * 24.0) * 24.0);
    v149 = (24 * v112);
    v150 = v351;
    _celt_lpc((float *)&v351[v149], &v366, 24);
LABEL_140:
    v168 = (float *)&v150[v149];
    v169 = v345;
    v362 = v168;
    v170 = v347;
    celt_fir_c();
    memcpy(v169, v170, v346);
    if (v99 < 1)
    {
      v175 = 1.0;
      v174 = 1.0;
      v172 = v348;
    }
    else
    {
      v171 = v316;
      if (v357 < 0x14)
        v171 = 1;
      v172 = v348;
      if ((v171 & 1) != 0)
      {
        v173 = 0;
        v174 = 1.0;
        v175 = 1.0;
        goto LABEL_149;
      }
      v174 = 1.0;
      v176 = v317;
      v177 = v318;
      v178 = v315;
      v175 = 1.0;
      do
      {
        v179 = (float32x4_t *)((char *)v376 + 4 * v177);
        v180 = vmulq_f32(*v179, *v179);
        v181 = vmulq_f32(v179[1], v179[1]);
        v182 = (float32x4_t *)((char *)v376 + 4 * v176);
        v183 = vmulq_f32(*v182, *v182);
        v184 = vmulq_f32(v182[1], v182[1]);
        v174 = (float)((float)((float)((float)((float)((float)((float)(v174 + v183.f32[0]) + v183.f32[1]) + v183.f32[2])
                                             + v183.f32[3])
                                     + v184.f32[0])
                             + v184.f32[1])
                     + v184.f32[2])
             + v184.f32[3];
        v175 = (float)((float)((float)((float)((float)((float)((float)(v175 + v180.f32[0]) + v180.f32[1]) + v180.f32[2])
                                             + v180.f32[3])
                                     + v181.f32[0])
                             + v181.f32[1])
                     + v181.f32[2])
             + v181.f32[3];
        v177 += 8;
        v176 += 8;
        v178 -= 8;
      }
      while (v178);
      v173 = v315;
      if (v315 != v357)
      {
LABEL_149:
        v185 = v357 - v173;
        v186 = v317 + v173;
        v187 = v318 + v173;
        do
        {
          v175 = v175 + (float)(v376[0].f32[v187] * v376[0].f32[v187]);
          v174 = v174 + (float)(v376[0].f32[v186] * v376[0].f32[v186]);
          ++v186;
          ++v187;
          --v185;
        }
        while (v185);
      }
    }
    if (v175 >= v174)
      v188 = v174;
    else
      v188 = v175;
    memmove(v144, &v144[v352], v353);
    v189 = v364;
    if ((int)v364 < 1)
    {
      v193 = 0.0;
      v196 = v362;
    }
    else
    {
      v190 = 0;
      v191 = sqrtf(v188 / v174);
      v192 = v100 * v191;
      v193 = 0.0;
      v194 = v360;
      v195 = v359;
      v196 = v362;
      do
      {
        if (v190 >= v99)
          v197 = v191;
        else
          v197 = 1.0;
        v192 = v192 * v197;
        if (v190 >= v99)
          v198 = v99;
        else
          v198 = 0;
        v199 = v190 - v198;
        v144[v194] = v192 * v376[0].f32[v199 + v116];
        v200 = v144[v140 + v199];
        v193 = v193 + (float)(v200 * v200);
        v190 = v199 + 1;
        ++v194;
        --v195;
      }
      while (v195);
    }
    *(float *)v381[0].i32 = v144[v344];
    *(float *)&v381[0].i32[1] = v144[v343];
    *(float *)&v381[0].i32[2] = v144[v342];
    *(float *)&v381[0].i32[3] = v144[v341];
    *(float *)v381[1].i32 = v144[v340];
    *(float *)&v381[1].i32[1] = v144[v339];
    *(float *)&v381[1].i32[2] = v144[v338];
    *(float *)&v381[1].i32[3] = v144[v337];
    *(float *)v381[2].i32 = v144[v336];
    *(float *)&v381[2].i32[1] = v144[v335];
    *(float *)&v381[2].i32[2] = v144[v334];
    *(float *)&v381[2].i32[3] = v144[v333];
    *(float *)v381[3].i32 = v144[v332];
    *(float *)&v381[3].i32[1] = v144[v331];
    *(float *)&v381[3].i32[2] = v144[v330];
    *(float *)&v381[3].i32[3] = v144[v329];
    *(float *)v381[4].i32 = v144[v328];
    *(float *)&v381[4].i32[1] = v144[v327];
    *(float *)&v381[4].i32[2] = v144[v326];
    *(float *)&v381[4].i32[3] = v144[v325];
    *(float *)v381[5].i32 = v144[v324];
    *(float *)&v381[5].i32[1] = v144[v323];
    *(float *)&v381[5].i32[2] = v144[v322];
    *(float *)&v381[5].i32[3] = v144[v321];
    v201 = celt_iir((uint64_t)&v144[v350 + 2048], v196, (uint64_t)&v144[v350 + 2048], v189, 24, v381);
    v209 = v359;
    if ((int)v359 < 1)
    {
      v215 = 0.0;
      v211 = v360;
      v212 = (float32x4_t *)(v144 + 2048);
      v213 = v364;
      if (v193 > 0.0)
        goto LABEL_178;
    }
    else
    {
      v210 = v320;
      if (v359 < 0x10)
        v210 = 1;
      v211 = v360;
      v212 = (float32x4_t *)(v144 + 2048);
      v213 = v364;
      if ((v210 & 1) != 0)
      {
        v214 = 0;
        v215 = 0.0;
        goto LABEL_175;
      }
      v215 = 0.0;
      v216 = v360;
      v217 = v319;
      do
      {
        v218 = (float32x4_t *)&v144[v216];
        v202 = vmulq_f32(*v218, *v218);
        v204.i32[0] = v202.i32[3];
        v205.i32[0] = v202.i32[2];
        v206.i32[0] = v202.i32[1];
        v203 = vmulq_f32(v218[1], v218[1]);
        v207.i32[0] = v203.i32[3];
        v208.i32[0] = v203.i32[2];
        v215 = (float)((float)((float)((float)((float)((float)((float)(v215 + v202.f32[0]) + v202.f32[1]) + v202.f32[2])
                                             + v202.f32[3])
                                     + v203.f32[0])
                             + v203.f32[1])
                     + v203.f32[2])
             + v203.f32[3];
        v216 += 8;
        v217 -= 8;
      }
      while (v217);
      v214 = v319;
      if (v319 != v359)
      {
LABEL_175:
        v219 = v359 - v214;
        v220 = v360 + v214;
        do
        {
          v215 = v215 + (float)(v144[v220] * v144[v220]);
          ++v220;
          --v219;
        }
        while (v219);
      }
      if (v193 <= (float)(v215 * 0.2))
      {
        v234 = v320;
        if (v364 < 8)
          v234 = 1;
        if ((v234 & 1) != 0)
        {
          v235 = 0;
        }
        else
        {
          v236 = v360;
          v237 = v319;
          v201 = 0uLL;
          do
          {
            v238 = &v144[v236];
            *(_OWORD *)v238 = 0uLL;
            *((_OWORD *)v238 + 1) = 0uLL;
            v236 += 8;
            v237 -= 8;
          }
          while (v237);
          v235 = v319;
          if (v319 == v209)
            goto LABEL_207;
        }
        v239 = v209 - v235;
        v240 = v211 + v235;
        do
        {
          v144[v240++] = 0.0;
          --v239;
        }
        while (v239);
        goto LABEL_207;
      }
LABEL_178:
      if (v193 < v215)
      {
        v221 = sqrtf((float)(v193 + 1.0) / (float)(v215 + 1.0));
        if ((int)v361 >= 1)
        {
          v202.f32[0] = 1.0 - v221;
          v222 = v293;
          if (v361 < 8)
            v222 = 1;
          if ((v222 & 1) != 0
            || v113 < (float32x4_t *)((char *)v144 + v286) && (unint64_t)&v144[v353 / 4] < v283)
          {
            v223 = 0;
            goto LABEL_186;
          }
          v203 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v202.f32, 0);
          v275 = v211;
          v276 = v284;
          v277 = v294;
          do
          {
            __asm { FMOV            V5.4S, #1.0 }
            v207 = vmlsq_f32(_Q5, v203, v277[-1]);
            v206 = vmlsq_f32(_Q5, v203, *v277);
            v281 = (float32x4_t *)&v144[v275];
            v204 = vmulq_f32(v207, *v281);
            v205 = vmulq_f32(v206, v281[1]);
            *v281 = v204;
            v281[1] = v205;
            v277 += 2;
            v275 += 8;
            v276 -= 8;
          }
          while (v276);
          v223 = v284;
          if (v284 != v355)
          {
LABEL_186:
            v224 = v355 - v223;
            v225 = &v113->f32[v223];
            v226 = v211 + v223;
            do
            {
              v227 = *v225++;
              v228 = v226;
              v204.f32[0] = v144[v228];
              v203.f32[0] = (float)(1.0 - (float)(v227 * v202.f32[0])) * v204.f32[0];
              v144[v228] = v203.f32[0];
              ++v226;
              --v224;
            }
            while (v224);
          }
        }
        if ((int)v314 >= 1)
        {
          v229 = v295 < 8 || v292;
          v230 = v361;
          if (v229)
            goto LABEL_251;
          v231 = v291;
          v232 = v287;
          do
          {
            v233 = (float32x4_t *)&v144[v232];
            v203 = vmulq_n_f32(v233[1], v221);
            *v233 = vmulq_n_f32(*v233, v221);
            v233[1] = v203;
            v232 += 8;
            v231 -= 8;
          }
          while (v231);
          v230 = v285;
          if (v295 != v291)
          {
LABEL_251:
            do
            {
              v144[v211 + (int)v230] = v221 * v144[v211 + (int)v230];
              ++v230;
            }
            while (v230 < v213);
          }
        }
      }
    }
LABEL_207:
    v201.f32[0] = -*((float *)v365 + 18);
    v241 = v361;
    comb_filter(v172, v212, v365[16], v365[16], v361, v365[20], v365[20], 0, (int8x16_t)v201, v201.f32[0], *(double *)v203.i64, *(double *)v204.i64, *(double *)v205.i64, *(double *)v206.i64, *(double *)v207.i64, v208, 0);
    v242 = v356;
    if (v241 > 1)
    {
      v243 = v313;
      v244 = 0;
      if (v354 < 0x10)
        v243 = 1;
      if ((v243 & 1) != 0)
        goto LABEL_211;
      v254 = v144 + 2048;
      v255 = (float32x4_t *)((char *)v144 + v303);
      v256 = (unint64_t)(v144 + 2048) >= v302 || v113 >= v255;
      v257 = !v256;
      v258 = (unint64_t)v254 >= v301 || v172 >= v255;
      v259 = !v258;
      v260 = (unint64_t)v254 >= v297 || v299 >= (unint64_t)v255;
      v261 = !v260;
      if (v300 < (unint64_t)v255 && (unint64_t)v254 < v298)
        goto LABEL_211;
      if (v257)
        goto LABEL_211;
      if (v259)
        goto LABEL_211;
      if (v261)
        goto LABEL_211;
      v263 = (float32x4_t *)(v144 + 2052);
      v264 = v288;
      v265 = v289;
      v266 = v296;
      v267 = v294;
      do
      {
        v268 = 4 * v265;
        v269 = (int8x16_t)vrev64q_s32(*(int32x4_t *)((char *)v172 + v268 - 12));
        v270 = (int8x16_t)vrev64q_s32(*(int32x4_t *)((char *)&v172[-1] + v268 - 12));
        v271 = (uint64_t)v113 + v268;
        v272 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v271 - 12));
        v273 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v271 - 28));
        v274 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v273, v273, 8uLL), *v264), (float32x4_t)vextq_s8(v270, v270, 8uLL), *v267);
        v265 -= 8;
        v263[-1] = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v272, v272, 8uLL), v264[-1]), (float32x4_t)vextq_s8(v269, v269, 8uLL), v267[-1]);
        *v263 = v274;
        v267 += 2;
        v264 += 2;
        v263 += 2;
        v266 -= 8;
      }
      while (v266);
      v244 = v296;
      if (v296 != v354)
      {
LABEL_211:
        v245 = v354 - v244;
        v246 = v244;
        v247 = &v144[v244 + 2048];
        v248 = &v172->f32[v244];
        v249 = v312 - v244;
        v250 = &v113->f32[v246];
        do
        {
          v251 = *v250++;
          v252 = v251;
          v253 = *v248++;
          *v247++ = (float)(v113->f32[v249] * v253) + (float)(v252 * v172->f32[v249]);
          --v249;
          --v245;
        }
        while (v245);
      }
    }
    v112 = v363 + 1;
    if (v363 + 1 != v242)
      continue;
    break;
  }
  v38 = v365;
LABEL_60:
  v98 = v358 + (1 << v5);
  if (v98 >= 10000)
    v98 = 10000;
  v38[14] = v98;
}

uint64_t deemphasis(uint64_t result, uint64_t a2, int a3, int a4, int a5, float *a6, float *a7, int a8)
{
  float v8;
  float v9;
  float v10;
  uint64_t v11;
  float *v12;
  float *v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float *v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float *v26;
  float *v27;
  float v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float *v35;
  float *v36;
  uint64_t v37;
  float v38;
  float v39;
  uint64_t v40;
  uint64_t v41;
  float *v42;
  float *v43;
  float v44;
  uint64_t v45;
  uint64_t v46;
  float *v47;
  uint64_t v48;
  uint64_t v49;
  float v50;
  float *v51;
  float *v52;
  uint64_t v53;
  float v54;
  float v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  float *v65;
  float *v66;
  float v67;
  uint64_t v68;
  uint64_t v69;
  float *v70;
  uint64_t v71;
  uint64_t v72;
  float v73;
  float *v74;
  float *v75;
  uint64_t v76;
  float v77;
  float v78;
  _QWORD v79[2];

  v79[1] = *MEMORY[0x24BDAC8D0];
  if (a4 == 2 && a5 == 1 && !a8)
  {
    v9 = *a7;
    v8 = a7[1];
    if (a3 >= 1)
    {
      v10 = *a6;
      v11 = a3;
      v12 = (float *)(a2 + 4);
      v13 = *(float **)result;
      v14 = *(float **)(result + 8);
      do
      {
        v15 = *v13++;
        v16 = v9 + (float)(v15 + 1.0e-30);
        v17 = *v14++;
        v18 = v8 + (float)(v17 + 1.0e-30);
        v9 = v10 * v16;
        v8 = v10 * v18;
        *(v12 - 1) = v16 * 0.000030518;
        *v12 = v18 * 0.000030518;
        v12 += 2;
        --v11;
      }
      while (v11);
    }
    *a7 = v9;
    a7[1] = v8;
    return result;
  }
  result = MEMORY[0x24BDAC7A8]();
  v26 = (float *)((char *)v79 - v25);
  v28 = *v27;
  if ((int)v22 > 1)
  {
    v29 = (v20 / (int)v22);
    if (v20 >= 1)
    {
      if ((int)v29 <= 0)
      {
        v71 = 0;
        if (v21 <= 1)
          v72 = 1;
        else
          v72 = v21;
        do
        {
          v73 = *(float *)(v23 + 4 * v71);
          v74 = *(float **)(result + 8 * v71);
          v75 = v26;
          v76 = v24;
          do
          {
            v77 = *v74++;
            v78 = v73 + (float)(v77 + 1.0e-30);
            v73 = v28 * v78;
            *v75++ = v78;
            --v76;
          }
          while (v76);
          *(float *)(v23 + 4 * v71++) = v73;
        }
        while (v71 != v72);
        return result;
      }
      v30 = 0;
      if (v21 <= 1)
        v31 = 1;
      else
        v31 = v21;
      v32 = 4 * v21;
      v33 = 4 * v22;
      while (1)
      {
        v34 = *(float *)(v23 + 4 * v30);
        v35 = *(float **)(result + 8 * v30);
        v36 = v26;
        v37 = v24;
        do
        {
          v38 = *v35++;
          v39 = v34 + (float)(v38 + 1.0e-30);
          v34 = v28 * v39;
          *v36++ = v39;
          --v37;
        }
        while (v37);
        *(float *)(v23 + 4 * v30) = v34;
        if (v29 >= 2)
        {
          v41 = v29 & 0xFFFFFFFE;
          v42 = v19;
          v43 = v26;
          do
          {
            v44 = v43[v22] * 0.000030518;
            *v42 = *v43 * 0.000030518;
            v42[v21] = v44;
            v43 += 2 * v22;
            v42 += 2 * v21;
            v41 -= 2;
          }
          while (v41);
          v40 = v29 & 0xFFFFFFFE;
          if (v40 == v29)
            goto LABEL_15;
        }
        else
        {
          v40 = 0;
        }
        v45 = v29 - v40;
        v46 = v32 * v40;
        v47 = (float *)((char *)v26 + v33 * v40);
        do
        {
          *(float *)((char *)v19 + v46) = *v47 * 0.000030518;
          v46 += v32;
          v47 = (float *)((char *)v47 + v33);
          --v45;
        }
        while (v45);
LABEL_15:
        ++v30;
        ++v19;
        if (v30 == v31)
          return result;
      }
    }
    if ((int)v29 < 1)
      return result;
    v56 = 0;
    v57 = v21;
    v58 = 8 * v22;
    v59 = 8 * v21;
    if (v21 <= 1)
      v60 = 1;
    else
      v60 = v21;
    v61 = 4 * v21;
    v62 = 4 * v22;
    result = v22;
    while (1)
    {
      if (v29 >= 2)
      {
        v64 = v29 & 0xFFFFFFFE;
        v65 = v19;
        v66 = v26;
        do
        {
          v67 = v66[result] * 0.000030518;
          *v65 = *v66 * 0.000030518;
          v65[v57] = v67;
          v66 = (float *)((char *)v66 + v58);
          v65 = (float *)((char *)v65 + v59);
          v64 -= 2;
        }
        while (v64);
        v63 = v29 & 0xFFFFFFFE;
        if (v63 == v29)
          goto LABEL_39;
      }
      else
      {
        v63 = 0;
      }
      v68 = v29 - v63;
      v69 = v61 * v63;
      v70 = (float *)((char *)v26 + v62 * v63);
      do
      {
        *(float *)((char *)v19 + v69) = *v70 * 0.000030518;
        v69 += v61;
        v70 = (float *)((char *)v70 + v62);
        --v68;
      }
      while (v68);
LABEL_39:
      ++v56;
      ++v19;
      if (v56 == v60)
        return result;
    }
  }
  if (v20 >= 1)
  {
    v48 = 0;
    if (v21 <= 1)
      v49 = 1;
    else
      v49 = v21;
    do
    {
      v50 = *(float *)(v23 + 4 * v48);
      v51 = *(float **)(result + 8 * v48);
      v52 = v19;
      v53 = v24;
      do
      {
        v54 = *v51++;
        v55 = v50 + (float)(v54 + 1.0e-30);
        v50 = v28 * v55;
        *v52 = v55 * 0.000030518;
        v52 += v21;
        --v53;
      }
      while (v53);
      *(float *)(v23 + 4 * v48++) = v50;
      ++v19;
    }
    while (v48 != v49);
  }
  return result;
}

void celt_synthesis(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, int a9, char a10, int a11, int a12, int a13)
{
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  float32x4_t *v26;
  unsigned int v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  unsigned int v40;
  __int16 v41;
  float32x4_t *v42;
  uint64_t v43;
  int v44;
  int v45;
  float v46;
  float v47;
  int v48;
  float v49;
  float v50;
  int v51;
  uint64_t v52;
  float *v53;
  float *v54;
  uint64_t v55;
  uint64_t v56;
  float32x4_t *v57;
  float32x4_t *v58;
  uint64_t v59;
  float32x4_t v60;
  float v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  int v66;
  int v67;
  int v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  int v72;
  int v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  __int16 v77;
  uint64_t v78;
  float32x4_t *v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  int v83;
  int v84;
  float v85;
  float v86;
  int v87;
  uint64_t v88;
  float *v89;
  float *v90;
  uint64_t v91;
  uint64_t v92;
  float32x4_t *v93;
  float32x4_t *v94;
  uint64_t v95;
  float32x4_t v96;
  float v97;
  int v98;
  char *v99;
  int v100;
  int v101;
  char *v102;
  int v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  int v116;
  int v117;
  int v118;
  uint64_t v119;
  int v120;
  int v121;
  int v122;
  uint64_t v123;
  unsigned int v124;
  unint64_t v125;
  uint64_t v126;
  __int16 v127;
  uint64_t v128;
  unint64_t v129;
  int v130;
  int v131;
  int v132;
  float v133;
  float v134;
  int v135;
  uint64_t v136;
  float *v137;
  float *v138;
  uint64_t v139;
  uint64_t v140;
  float32x4_t *v141;
  float32x4_t *v142;
  uint64_t v143;
  float32x4_t v144;
  float v145;
  int v146;
  float *v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  _QWORD *v151;
  int v152;
  int v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  unsigned int v162;
  unint64_t v163;
  uint64_t v164;
  int v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  int v169;
  int v170;
  int v171;
  uint64_t v172;
  uint64_t v173;
  int v174;
  int v175;
  uint64_t v176;
  float *v177;
  float32x4_t *v178;
  __int16 v179;
  unint64_t v180;
  unint64_t v181;
  int v182;
  int v183;
  int v184;
  float v185;
  float v186;
  int v187;
  uint64_t v188;
  float *v189;
  float *v190;
  uint64_t v191;
  uint64_t v192;
  float32x4_t *v193;
  float32x4_t *v194;
  uint64_t v195;
  float32x4_t v196;
  float v197;
  uint64_t v198;
  __int16 v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  int v203;
  int v204;
  float v205;
  float v206;
  int v207;
  float v208;
  float v209;
  int v210;
  uint64_t v211;
  float *v212;
  float *v213;
  uint64_t v214;
  uint64_t v215;
  float32x4_t *v216;
  float32x4_t *v217;
  uint64_t v218;
  float32x4_t v219;
  float v220;
  int v221;
  uint64_t v222;
  uint64_t v223;
  float *v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  float *v231;
  float *v232;
  float v233;
  _QWORD *v234;
  int v235;
  int v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  float32x4_t *v240;
  float32x4_t *v241;
  float32x4_t v242;
  uint64_t v243;
  float32x4_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  int v251;
  int v252;
  char *v253;
  uint64_t v254;
  int v255;
  uint64_t v256;
  uint64_t v257;
  int v258;
  uint64_t v259;
  unint64_t v260;
  unint64_t v261;
  uint64_t v262;
  _QWORD *v263;
  int v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;

  v262 = a4;
  v246 = a2;
  LODWORD(v253) = a13;
  v258 = a12;
  v268 = *MEMORY[0x24BDAC8D0];
  v247 = *(int *)(a1 + 8);
  v14 = MEMORY[0x24BDAC7A8](a1, (*(_DWORD *)(a1 + 48) << a10));
  v26 = (float32x4_t *)((char *)&v245 - v25);
  v27 = 1 << v22;
  v28 = v23 == 0;
  if (v23)
    v29 = v27;
  else
    v29 = 1;
  if (v23)
    v30 = v21;
  else
    v30 = v15;
  if (v28)
    v31 = v22;
  else
    v31 = 0;
  v251 = *(_DWORD *)(v14 + 40) - v31;
  v252 = v24;
  v261 = (unint64_t)v26;
  v254 = v14;
  v263 = v16;
  v267 = v29;
  v264 = 1 << v22;
  if (v19 != 1 || v20 != 2)
  {
    v255 = v17;
    if (v19 == 2 && v20 == 1)
    {
      v265 = v30;
      v266 = v15;
      v62 = *v16;
      if (v24 >= 0)
        v63 = v24;
      else
        v63 = (v24 + 1);
      v245 = v63;
      v64 = (int)v63 >> 1;
      v65 = *(_QWORD *)(v14 + 32);
      v66 = v21 * v27;
      v67 = v27 * *(__int16 *)(v65 + 2 * a6);
      LODWORD(v259) = v66;
      v68 = v66 / v17;
      LODWORD(v250) = v68;
      if (v67 < v68)
        v68 = v67;
      if (v17 != 1)
        v67 = v68;
      LODWORD(v249) = v67;
      if (v258)
        v69 = 0;
      else
        v69 = a6;
      if (v258)
        v70 = 0;
      else
        v70 = v18;
      v71 = v70;
      v72 = *(__int16 *)(v65 + 2 * v70);
      v73 = v27 * v72;
      v74 = (uint64_t)v26;
      v75 = v27 * v72 - 1;
      if ((int)(v27 * v72) >= 1)
      {
        v76 = v69;
        bzero(v26, 4 * v27 * v72);
        v69 = v76;
        v74 = (uint64_t)v26->i64 + 4 * v75 + 4;
      }
      v248 = a6;
      v256 = v62;
      v257 = v69;
      v260 = v62 + 4 * v64;
      if ((int)v71 < (int)v69)
      {
        v77 = v72;
        v78 = (int)v257;
        v79 = (float32x4_t *)(v246 + 4 * v73);
        v80 = v71;
        do
        {
          v81 = v80 + 1;
          v82 = *(__int16 *)(v65 + 2 * (v80 + 1));
          v83 = v264 * v77;
          v84 = v264 * v82;
          v85 = *(float *)(v262 + 4 * v80) + *((float *)&eMeans + v80);
          if (v85 > 32.0)
            v85 = 32.0;
          v86 = exp(v85 * 0.693147181);
          if (v84 <= v83 + 1)
            v87 = v83 + 1;
          else
            v87 = v84;
          v88 = (v87 + ~v83);
          if (v88 >= 7)
          {
            v91 = v88 + 1;
            v92 = (v88 + 1) & 0x1FFFFFFF8;
            v89 = (float *)(v74 + 4 * v92);
            v90 = &v79->f32[v92];
            v83 += v92;
            v93 = v79 + 1;
            v94 = (float32x4_t *)(v74 + 16);
            v95 = v92;
            do
            {
              v96 = vmulq_n_f32(*v93, v86);
              v94[-1] = vmulq_n_f32(v93[-1], v86);
              *v94 = v96;
              v93 += 2;
              v94 += 2;
              v95 -= 8;
            }
            while (v95);
            if (v91 == v92)
              goto LABEL_57;
          }
          else
          {
            v89 = (float *)v74;
            v90 = (float *)v79;
          }
          do
          {
            v97 = *v90++;
            *v89++ = v97 * v86;
            ++v83;
          }
          while (v83 < v84);
LABEL_57:
          v77 = v82;
          v80 = v81;
          v79 = (float32x4_t *)v90;
          v74 = (uint64_t)v89;
        }
        while (v81 != v78);
      }
      v157 = v249;
      if (v258)
        v157 = 0;
      bzero((void *)(v261 + 4 * v157), 4 * ((int)v259 - v157));
      v158 = v264 * *(__int16 *)(v65 + 2 * v248);
      v159 = v250;
      if (v158 < (int)v250)
        v159 = v264 * *(__int16 *)(v65 + 2 * v248);
      if (v255 != 1)
        v158 = v159;
      v255 = v158;
      v160 = *(__int16 *)(v65 + 2 * v71);
      v161 = v264 * v160;
      v162 = v264 * v160 - 1;
      if (v264 * v160 < 1)
      {
        v164 = v260;
        v165 = v257;
        if ((int)v71 >= (int)v257)
          goto LABEL_177;
      }
      else
      {
        v163 = v260;
        bzero((void *)v260, 4 * (v264 * v160));
        v164 = v163 + 4 * v162 + 4;
        v165 = v257;
        if ((int)v71 >= (int)v257)
        {
LABEL_177:
          v221 = v255;
          if (v258)
            v221 = 0;
          bzero((void *)(v260 + 4 * v221), 4 * ((int)v259 - v221));
          v223 = v266;
          v222 = v267;
          v224 = (float *)v261;
          v225 = v254;
          v226 = v256;
          if ((int)v266 < 1)
            goto LABEL_186;
          v227 = (uint64_t)(int)v245 >> 1;
          if (v266 >= 8 && (v261 >= v256 + 4 * (v227 + v266) || v260 >= v261 + 4 * v266))
          {
            v228 = v266 & 0xFFFFFFF8;
            v240 = (float32x4_t *)(v261 + 16);
            v241 = (float32x4_t *)(v256 + 4 * v227 + 16);
            v242.i64[0] = 0x3F0000003F000000;
            v242.i64[1] = 0x3F0000003F000000;
            v243 = v228;
            do
            {
              v244 = vmlaq_f32(vmulq_f32(*v241, v242), v242, *v240);
              v240[-1] = vmlaq_f32(vmulq_f32(v241[-1], v242), v242, v240[-1]);
              *v240 = v244;
              v240 += 2;
              v241 += 2;
              v243 -= 8;
            }
            while (v243);
            if (v228 == v223)
            {
LABEL_186:
              v234 = v263;
              v235 = v252;
              v236 = v251;
              if ((int)v222 >= 1)
              {
                v237 = 0;
                v238 = 4 * (int)v265;
                v239 = v222;
                do
                {
                  clt_mdct_backward_c(v225 + 80, v224, *v234 + v237, *(_QWORD *)(v225 + 72), v235, v236, v222);
                  LODWORD(v222) = v267;
                  v237 += v238;
                  ++v224;
                  --v239;
                }
                while (v239);
              }
              return;
            }
          }
          else
          {
            v228 = 0;
          }
          v229 = v223 - v228;
          v230 = v228;
          v231 = (float *)(v226 + v230 * 4 + 4 * v227);
          v232 = &v224[v230];
          do
          {
            v233 = *v231++;
            *v232 = (float)(v233 * 0.5) + (float)(*v232 * 0.5);
            ++v232;
            --v229;
          }
          while (v229);
          goto LABEL_186;
        }
      }
      v198 = v262 + 4 * v247;
      v199 = v160;
      v200 = v165;
      v201 = v246 + 4 * (int)v266 + 4 * v161;
      while (1)
      {
        v202 = v71 + 1;
        v203 = *(__int16 *)(v65 + 2 * (v71 + 1));
        v204 = v264 * v199;
        v205 = *(float *)(v198 + 4 * v71);
        v206 = *((float *)&eMeans + v71);
        v207 = v264 * v203;
        v208 = v205 + v206;
        if (v208 > 32.0)
          v208 = 32.0;
        v209 = exp(v208 * 0.693147181);
        if (v207 <= v204 + 1)
          v210 = v204 + 1;
        else
          v210 = v207;
        v211 = (v210 + ~v204);
        if (v211 >= 7)
        {
          v214 = v211 + 1;
          v215 = (v211 + 1) & 0x1FFFFFFF8;
          v212 = (float *)(v164 + 4 * v215);
          v213 = (float *)(v201 + 4 * v215);
          v204 += v215;
          v216 = (float32x4_t *)(v201 + 16);
          v217 = (float32x4_t *)(v164 + 16);
          v218 = v215;
          do
          {
            v219 = vmulq_n_f32(*v216, v209);
            v217[-1] = vmulq_n_f32(v216[-1], v209);
            *v217 = v219;
            v216 += 2;
            v217 += 2;
            v218 -= 8;
          }
          while (v218);
          if (v214 == v215)
            goto LABEL_164;
        }
        else
        {
          v212 = (float *)v164;
          v213 = (float *)v201;
        }
        do
        {
          v220 = *v213++;
          *v212++ = v220 * v209;
          ++v204;
        }
        while (v204 < v207);
LABEL_164:
        v199 = v203;
        v71 = v202;
        v201 = (uint64_t)v213;
        v164 = (uint64_t)v212;
        if (v202 == v200)
          goto LABEL_177;
      }
    }
    v112 = a6;
    if ((int)v29 > 0)
    {
      v113 = 0;
      v245 = (int)v15;
      if (v20 <= 1)
        v114 = 1;
      else
        v114 = v20;
      v249 = v114;
      if (v258)
        v115 = 0;
      else
        v115 = a6;
      if (v258)
        v116 = 0;
      else
        v116 = v18;
      v260 = v116;
      v265 = v115;
      v250 = a6;
      v248 = 4 * (int)v30;
      v266 = v14 + 80;
      while (1)
      {
        v259 = v113;
        v117 = v264;
        v118 = *(_DWORD *)(v14 + 48) * v264;
        v119 = *(_QWORD *)(v14 + 32);
        v120 = v264 * *(__int16 *)(v119 + 2 * v112);
        if (v17 != 1 && v120 >= v118 / v17)
          v120 = v118 / v17;
        LODWORD(v256) = v120;
        LODWORD(v257) = v118;
        v121 = *(__int16 *)(v119 + 2 * v260);
        v122 = v264 * v121;
        v123 = (uint64_t)v26;
        v124 = v264 * v121 - 1;
        if (v264 * v121 >= 1)
        {
          bzero(v26, 4 * (v264 * v121));
          v123 = (uint64_t)v26->i64 + 4 * v124 + 4;
        }
        if ((int)v260 < (int)v265)
          break;
LABEL_113:
        v146 = v256;
        if (v258)
          v146 = 0;
        v147 = (float *)v261;
        bzero((void *)(v261 + 4 * v146), 4 * ((int)v257 - v146));
        v148 = 0;
        v149 = v267;
        v150 = v267;
        v14 = v254;
        v151 = v263;
        v152 = v252;
        v153 = v251;
        v154 = v248;
        v155 = v259;
        do
        {
          v156 = v14;
          clt_mdct_backward_c(v266, v147, v151[v155] + v148, *(_QWORD *)(v14 + 72), v152, v153, v149);
          v14 = v156;
          v149 = v267;
          v148 += v154;
          ++v147;
          --v150;
        }
        while (v150);
        v113 = v155 + 1;
        v112 = v250;
        v17 = v255;
        v26 = (float32x4_t *)v261;
        if (v113 == v249)
          return;
      }
      v125 = v260;
      v126 = v262 + 4 * v259 * v247;
      v127 = v121;
      v128 = v246 + 4 * v259 * v245 + 4 * v122;
      while (1)
      {
        v129 = v125 + 1;
        v130 = *(__int16 *)(v119 + 2 * (v125 + 1));
        v131 = v117 * v127;
        v132 = v117 * v130;
        v133 = *(float *)(v126 + 4 * v125) + *((float *)&eMeans + v125);
        if (v133 > 32.0)
          v133 = 32.0;
        v134 = exp(v133 * 0.693147181);
        if (v132 <= v131 + 1)
          v135 = v131 + 1;
        else
          v135 = v117 * v130;
        v136 = (v135 + ~v131);
        if (v136 >= 7)
        {
          v139 = v136 + 1;
          v140 = (v136 + 1) & 0x1FFFFFFF8;
          v137 = (float *)(v123 + 4 * v140);
          v138 = (float *)(v128 + 4 * v140);
          v131 += v140;
          v141 = (float32x4_t *)(v128 + 16);
          v142 = (float32x4_t *)(v123 + 16);
          v143 = v140;
          do
          {
            v144 = vmulq_n_f32(*v141, v134);
            v142[-1] = vmulq_n_f32(v141[-1], v134);
            *v142 = v144;
            v141 += 2;
            v142 += 2;
            v143 -= 8;
          }
          while (v143);
          if (v139 == v140)
            goto LABEL_100;
        }
        else
        {
          v137 = (float *)v123;
          v138 = (float *)v128;
        }
        do
        {
          v145 = *v138++;
          *v137++ = v145 * v134;
          ++v131;
        }
        while (v131 < v132);
LABEL_100:
        v127 = v130;
        v125 = v129;
        v128 = (uint64_t)v138;
        v123 = (uint64_t)v137;
        if (v129 == v265)
          goto LABEL_113;
      }
    }
    v267 = 0;
    v257 = (int)v15;
    if (v20 <= 1)
      v166 = 1;
    else
      v166 = v20;
    v259 = v166;
    v167 = *(_QWORD *)(v14 + 32);
    LODWORD(v265) = v21 * v27;
    LODWORD(v263) = v27 * *(__int16 *)(v167 + 2 * a6);
    if (v258)
      v168 = 0;
    else
      v168 = a6;
    if (v258)
      v169 = 0;
    else
      v169 = v18;
    v260 = v169;
    v170 = *(__int16 *)(v167 + 2 * v169);
    LODWORD(v256) = (unsigned __int16)v170;
    v171 = v27 * v170;
    v172 = v168;
    if (v171 <= 0)
      v173 = 0;
    else
      v173 = 4 * (v171 - 1) + 4;
    v253 = (char *)v26 + v173;
    v254 = v246 + 4 * v171;
    while (1)
    {
      v175 = (int)v263;
      if (v17 != 1)
      {
        v175 = (int)v265 / v17;
        if ((int)v263 < (int)v265 / v17)
          v175 = (int)v263;
      }
      LODWORD(v266) = v175;
      if ((int)v260 < (int)v172)
        break;
LABEL_141:
      v174 = v266;
      if (v258)
        v174 = 0;
      bzero((void *)(v261 + 4 * v174), 4 * ((int)v265 - v174));
      ++v267;
      v17 = v255;
      if (v267 == v259)
        return;
    }
    v176 = v262 + 4 * v267 * v247;
    v177 = (float *)v253;
    v178 = (float32x4_t *)(v254 + 4 * v267 * v257);
    v179 = v256;
    v180 = v260;
    while (1)
    {
      v181 = v180 + 1;
      v182 = *(__int16 *)(v167 + 2 * (v180 + 1));
      v183 = v264 * v179;
      v184 = v264 * v182;
      v185 = *(float *)(v176 + 4 * v180) + *((float *)&eMeans + v180);
      if (v185 > 32.0)
        v185 = 32.0;
      v186 = exp(v185 * 0.693147181);
      if (v184 <= v183 + 1)
        v187 = v183 + 1;
      else
        v187 = v184;
      v188 = (v187 + ~v183);
      if (v188 >= 7)
      {
        v191 = v188 + 1;
        v192 = (v188 + 1) & 0x1FFFFFFF8;
        v189 = &v177[v192];
        v190 = &v178->f32[v192];
        v183 += v192;
        v193 = v178 + 1;
        v194 = (float32x4_t *)(v177 + 4);
        v195 = v192;
        do
        {
          v196 = vmulq_n_f32(*v193, v186);
          v194[-1] = vmulq_n_f32(v193[-1], v186);
          *v194 = v196;
          v193 += 2;
          v194 += 2;
          v195 -= 8;
        }
        while (v195);
        if (v191 == v192)
          goto LABEL_149;
      }
      else
      {
        v189 = v177;
        v190 = (float *)v178;
      }
      do
      {
        v197 = *v190++;
        *v189++ = v197 * v186;
        ++v183;
      }
      while (v183 < v184);
LABEL_149:
      v179 = v182;
      v180 = v181;
      v178 = (float32x4_t *)v190;
      v177 = v189;
      if (v181 == v172)
        goto LABEL_141;
    }
  }
  v265 = v30;
  v266 = v15;
  v32 = *(_QWORD *)(v14 + 32);
  v33 = v21 * v27;
  v34 = v27 * *(__int16 *)(v32 + 2 * a6);
  if (v17 != 1 && v34 >= v33 / v17)
    v34 = v33 / v17;
  LODWORD(v260) = v21 * v27;
  if (v258)
    v35 = 0;
  else
    v35 = a6;
  if (v258)
    v36 = 0;
  else
    v36 = v18;
  v37 = v36;
  v38 = *(__int16 *)(v32 + 2 * v36);
  v39 = v27 * v38;
  v40 = v27 * v38 - 1;
  if ((int)(v27 * v38) >= 1)
  {
    bzero(v26, 4 * v27 * v38);
    v26 = (float32x4_t *)((char *)v26 + 4 * v40 + 4);
  }
  if ((int)v37 < v35)
  {
    v41 = v38;
    v42 = (float32x4_t *)(v246 + 4 * v39);
    do
    {
      v43 = v37 + 1;
      v44 = *(__int16 *)(v32 + 2 * (v37 + 1));
      v45 = v264 * v41;
      v46 = *(float *)(v262 + 4 * v37);
      v47 = *((float *)&eMeans + v37);
      v48 = v264 * v44;
      v49 = v46 + v47;
      if (v49 > 32.0)
        v49 = 32.0;
      v50 = exp(v49 * 0.693147181);
      if (v48 <= v45 + 1)
        v51 = v45 + 1;
      else
        v51 = v48;
      v52 = (v51 + ~v45);
      if (v52 >= 7)
      {
        v55 = v52 + 1;
        v56 = (v52 + 1) & 0x1FFFFFFF8;
        v53 = &v26->f32[v56];
        v54 = &v42->f32[v56];
        v45 += v56;
        v57 = v42 + 1;
        v58 = v26 + 1;
        v59 = v56;
        do
        {
          v60 = vmulq_n_f32(*v57, v50);
          v58[-1] = vmulq_n_f32(v57[-1], v50);
          *v58 = v60;
          v57 += 2;
          v58 += 2;
          v59 -= 8;
        }
        while (v59);
        if (v55 == v56)
          goto LABEL_25;
      }
      else
      {
        v53 = (float *)v26;
        v54 = (float *)v42;
      }
      do
      {
        v61 = *v54++;
        *v53++ = v61 * v50;
        ++v45;
      }
      while (v45 < v48);
LABEL_25:
      v41 = v44;
      v37 = v43;
      v42 = (float32x4_t *)v54;
      v26 = (float32x4_t *)v53;
    }
    while (v43 != v35);
  }
  if (v258)
    v98 = 0;
  else
    v98 = v34;
  v99 = (char *)v261;
  bzero((void *)(v261 + 4 * v98), 4 * ((int)v260 - v98));
  v100 = v252;
  if (v252 >= 0)
    v101 = v252;
  else
    v101 = v252 + 1;
  v102 = (char *)(v263[1] + 4 * (v101 >> 1));
  memcpy(v102, v99, 4 * (int)v266);
  v103 = v267;
  v104 = v254;
  v105 = v251;
  if ((int)v267 >= 1)
  {
    v106 = 0;
    v266 = (int)v265;
    v107 = 4 * (int)v265;
    v108 = v267;
    do
    {
      clt_mdct_backward_c(v104 + 80, (float *)v102, *v263 + v106, *(_QWORD *)(v104 + 72), v100, v105, v103);
      v103 = v267;
      v106 += v107;
      v102 += 4;
      --v108;
    }
    while (v108);
    v109 = 0;
    v110 = 4 * v266;
    v111 = v267;
    do
    {
      clt_mdct_backward_c(v104 + 80, (float *)v99, v263[1] + v109, *(_QWORD *)(v104 + 72), v100, v105, v103);
      v103 = v267;
      v109 += v110;
      v99 += 4;
      --v111;
    }
    while (v111);
  }
}

uint64_t opus_custom_decoder_ctl(_DWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9)
{
  uint64_t result;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  _DWORD *v23;
  _OWORD *v24;
  _OWORD *v25;
  uint64_t v31;

  result = 4294967291;
  switch(a2)
  {
    case 4027:
      if (!a9)
        return 0xFFFFFFFFLL;
      result = 0;
      *a9 = a1[2] / a1[5];
      return result;
    case 4028:
      v12 = a1[2];
      v11 = a1[3];
      v13 = *(_DWORD *)(*(_QWORD *)a1 + 8);
      bzero(a1 + 11, 32 * v13 + 4 * v11 * (*(_DWORD *)(*(_QWORD *)a1 + 4) + 2072) + 100 - 44);
      if (v13 < 1)
        goto LABEL_16;
      v14 = (v12 + 2048) * v11;
      v15 = 24 * v11;
      v16 = 2 * v13;
      if ((int)v16 <= 1)
        v17 = 1;
      else
        v17 = v16;
      if (v17 >= 0x18 && (v18 = 4 * v14 + 4 * v15, (unint64_t)(-4 * v16) >= 0x20))
      {
        v19 = v17 & 0x7FFFFFF8;
        v24 = (_OWORD *)((char *)&a1[2 * v16 + 28] + v18);
        v25 = (_OWORD *)((char *)&a1[v16 + 28] + v18);
        __asm { FMOV            V0.4S, #-28.0 }
        v31 = v19;
        do
        {
          *(v24 - 1) = _Q0;
          *v24 = _Q0;
          v24 += 2;
          *(v25 - 1) = _Q0;
          *v25 = _Q0;
          v25 += 2;
          v31 -= 8;
        }
        while (v31);
        if (v19 == v17)
          goto LABEL_16;
      }
      else
      {
        v19 = 0;
      }
      v20 = v17 - v19;
      v21 = 4 * v19 + 4 * v14 + 4 * v15;
      v22 = (_DWORD *)((char *)&a1[v16 + 24] + v21);
      v23 = (_DWORD *)((char *)&a1[2 * v16 + 24] + v21);
      do
      {
        *v23++ = -1042284544;
        *v22++ = -1042284544;
        --v20;
      }
      while (v20);
LABEL_16:
      result = 0;
      a1[15] = 1;
      return result;
    case 4029:
    case 4030:
    case 4032:
    case 4034:
    case 4035:
    case 4036:
    case 4037:
    case 4038:
    case 4039:
    case 4040:
    case 4041:
    case 4042:
    case 4043:
    case 4044:
    case 4045:
      return result;
    case 4031:
      if (!a9)
        return 0xFFFFFFFFLL;
      result = 0;
      *a9 = a1[11];
      return result;
    case 4033:
      if (!a9)
        return 0xFFFFFFFFLL;
      result = 0;
      *a9 = a1[16];
      return result;
    case 4046:
      if (a9 > 1)
        return 0xFFFFFFFFLL;
      result = 0;
      a1[9] = (_DWORD)a9;
      return result;
    case 4047:
      if (!a9)
        return 0xFFFFFFFFLL;
      result = 0;
      *a9 = a1[9];
      return result;
    default:
      switch(a2)
      {
        case 10007:
          if (!a9)
            return 0xFFFFFFFFLL;
          result = 0;
          *a9 = a1[12];
          a1[12] = 0;
          break;
        case 10008:
          if (((_DWORD)a9 - 3) < 0xFFFFFFFE)
            return 0xFFFFFFFFLL;
          result = 0;
          a1[4] = (_DWORD)a9;
          break;
        case 10010:
          if ((a9 & 0x80000000) != 0 || (int)a9 >= *(_DWORD *)(*(_QWORD *)a1 + 8))
            return 0xFFFFFFFFLL;
          result = 0;
          a1[6] = (_DWORD)a9;
          break;
        case 10012:
          if ((int)a9 < 1 || (int)a9 > *(_DWORD *)(*(_QWORD *)a1 + 8))
            return 0xFFFFFFFFLL;
          result = 0;
          a1[7] = (_DWORD)a9;
          break;
        case 10015:
          if (!a9)
            return 0xFFFFFFFFLL;
          result = 0;
          *(_QWORD *)a9 = *(_QWORD *)a1;
          break;
        case 10016:
          result = 0;
          a1[8] = (_DWORD)a9;
          break;
        default:
          return result;
      }
      return result;
  }
}

void celt_preemphasis(float *a1, float *a2, int a3, int a4, int a5, float *a6, float *a7, int a8)
{
  float *v13;
  float v15;
  float v16;
  uint64_t v17;
  float v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float *v24;
  float *v25;
  float v26;
  uint64_t v27;
  float *v28;
  float *v29;
  uint64_t v30;
  float32x4_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  uint64_t v34;
  float32x4_t v35;
  float32x4_t v36;
  uint64_t v37;
  float *v38;
  float v39;
  uint64_t v40;
  float v41;

  v13 = a2;
  v15 = *a6;
  v16 = *a7;
  if (!a8 && a5 == 1 && a6[1] == 0.0)
  {
    if (a3 >= 1)
    {
      v17 = a3;
      do
      {
        v18 = *a1 * 32768.0;
        *v13++ = v18 - v16;
        v16 = v15 * v18;
        a1 += a4;
        --v17;
      }
      while (v17);
    }
    goto LABEL_36;
  }
  v19 = (a3 / a5);
  if (a5 != 1)
    bzero(a2, 4 * a3);
  if ((int)v19 >= 1)
  {
    v20 = (_DWORD)v19 != 1 && a5 == 1;
    v21 = 4 * a5;
    if (v20)
    {
      v22 = v19 & 0xFFFFFFFE;
      v23 = v22;
      v24 = v13;
      v25 = a1;
      do
      {
        v26 = v25[a4] * 32768.0;
        *v24 = *v25 * 32768.0;
        v24[a5] = v26;
        v25 += 2 * a4;
        v24 += 2 * a5;
        v23 -= 2;
      }
      while (v23);
      if (v22 == v19)
      {
LABEL_21:
        if (a8)
        {
          v30 = 0;
          if (v19 < 8)
            goto LABEL_27;
          if (a5 != 1)
            goto LABEL_27;
          v30 = v19 & 0xFFFFFFF8;
          v31 = (float32x4_t *)(v13 + 4);
          v32 = (float32x4_t)vdupq_n_s32(0x47800000u);
          v33 = (float32x4_t)vdupq_n_s32(0xC7800000);
          v34 = v30;
          do
          {
            v35 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v31[-1], v32), (int8x16_t)v32, (int8x16_t)v31[-1]);
            v36 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*v31, v32), (int8x16_t)v32, *(int8x16_t *)v31);
            v31[-1] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v33, v35), (int8x16_t)v33, (int8x16_t)v35);
            *(int8x16_t *)v31 = vbslq_s8((int8x16_t)vcgtq_f32(v33, v36), (int8x16_t)v33, (int8x16_t)v36);
            v31 += 2;
            v34 -= 8;
          }
          while (v34);
          if (v30 != v19)
          {
LABEL_27:
            v37 = v19 - v30;
            v38 = &v13[v30 * a5];
            do
            {
              v39 = *v38;
              if (*v38 > 65536.0)
                v39 = 65536.0;
              if (v39 < -65536.0)
                v39 = -65536.0;
              *v38 = v39;
              v38 = (float *)((char *)v38 + v21);
              --v37;
            }
            while (v37);
          }
        }
        goto LABEL_33;
      }
    }
    else
    {
      v22 = 0;
    }
    v27 = v19 - v22;
    v28 = &v13[v22 * a5];
    v29 = &a1[v22 * a4];
    do
    {
      *v28 = *v29 * 32768.0;
      v28 = (float *)((char *)v28 + v21);
      v29 += a4;
      --v27;
    }
    while (v27);
    goto LABEL_21;
  }
LABEL_33:
  if (a3 >= 1)
  {
    v40 = a3;
    do
    {
      v41 = *v13;
      *v13 = *v13 - v16;
      ++v13;
      v16 = v15 * v41;
      --v40;
    }
    while (v40);
  }
LABEL_36:
  *a7 = v16;
}

uint64_t celt_encode_with_ec(uint64_t *a1, float32x4_t *a2, int a3, uint64_t a4, int a5, _QWORD *a6)
{
  int v7;
  uint64_t v8;
  float32x4_t *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t result;
  __int32 v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  __int32 v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  _DWORD *v34;
  unint64_t v35;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int *v46;
  uint64_t v47;
  int v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t *v53;
  float v54;
  int v55;
  int v56;
  uint64_t v57;
  float v58;
  float32x4_t *v59;
  float *v60;
  uint64_t v61;
  float v62;
  float v63;
  float v64;
  float v65;
  int v66;
  float v67;
  float *v68;
  uint64_t v69;
  float v70;
  float v71;
  int v72;
  int v73;
  uint64_t v74;
  float *v75;
  float v76;
  float v77;
  int v78;
  float v79;
  float v80;
  char *v81;
  float v82;
  float v83;
  float v84;
  uint64_t *v85;
  uint64_t v86;
  unsigned int v87;
  int v88;
  unint64_t v89;
  float *v90;
  float32x4_t *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  _BOOL4 v97;
  _BOOL4 v98;
  uint64_t *v99;
  int v100;
  signed int v101;
  uint64_t v102;
  char *v103;
  int v104;
  int *v105;
  int v106;
  uint64_t v107;
  uint64_t *v108;
  float v109;
  double v110;
  double v111;
  _BOOL4 v112;
  int v113;
  unsigned int v114;
  int v115;
  unsigned int v116;
  unsigned int v117;
  int v118;
  int v119;
  int v120;
  uint64_t v121;
  int v122;
  int v123;
  int v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  float v128;
  int v129;
  int v130;
  uint64_t v131;
  int v132;
  int v133;
  int v134;
  unsigned int v135;
  int v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  float32x4_t *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  float32x4_t *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  float32x4_t *v149;
  uint64_t v150;
  int v151;
  uint64_t v152;
  char v153;
  int v154;
  int v155;
  int v156;
  uint64_t *v157;
  int32x2_t v158;
  int v159;
  BOOL v160;
  int v161;
  uint64_t *v162;
  uint64_t v163;
  uint64_t v164;
  __int16 *v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  __int16 v169;
  uint64_t v170;
  int v171;
  float v172;
  int v173;
  uint64_t v174;
  uint64_t v175;
  float *v176;
  float v177;
  int v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  float32x4_t *v192;
  float32x4_t *v193;
  uint64_t v194;
  uint64_t v195;
  int32x2_t v196;
  uint64_t v197;
  uint64_t v198;
  float32x4_t v199;
  float32x4_t *v200;
  uint64_t v201;
  float32x4_t v202;
  uint64_t v203;
  uint64_t v204;
  float32x4_t *v205;
  float32x4_t v206;
  uint64_t v207;
  float *v208;
  float32x4_t v209;
  float32x4_t *v210;
  float32x4_t v211;
  unint64_t v212;
  float32x4_t v213;
  unint64_t v214;
  float *v215;
  float v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  float *v220;
  unint64_t v221;
  uint64_t *v222;
  float v223;
  float v224;
  float v225;
  uint64_t v226;
  unint64_t v227;
  int v228;
  uint64_t v229;
  unint64_t v230;
  uint64_t v231;
  int v232;
  unsigned __int16 *v233;
  __int16 v234;
  int32x4_t v235;
  float v236;
  float32x4_t v240;
  float32x4_t v241;
  int32x4_t v242;
  int32x4_t v243;
  float *v244;
  float v245;
  __int16 v246;
  int32x4_t v247;
  unint64_t v248;
  int32x4_t v249;
  int8x16_t *v250;
  int8x16_t v251;
  int32x4_t v252;
  int32x4_t v253;
  int8x16_t v254;
  float32x4_t v255;
  float32x4_t v256;
  float32x4_t v257;
  float32x4_t v258;
  float32x4_t v259;
  float32x4_t v260;
  int8x16_t v261;
  int16x8_t v262;
  int32x4_t v263;
  int32x4_t v264;
  float32x4_t v265;
  float32x4_t v266;
  float32x4_t v267;
  float32x4_t v268;
  int v269;
  float v270;
  int v271;
  float v272;
  __int16 *v273;
  int v274;
  int v275;
  uint64_t v276;
  int v277;
  float v278;
  float v279;
  uint64_t v280;
  float v281;
  float v282;
  unint64_t v283;
  float32x4_t *v284;
  uint64_t v286;
  float32x4_t v287;
  float32x4_t v288;
  unint64_t v289;
  float *v290;
  float v291;
  float v292;
  float v293;
  unint64_t v294;
  float *v295;
  float *v296;
  float v297;
  float v298;
  float v299;
  float v300;
  signed int v301;
  char v302;
  uint64_t *v303;
  uint64_t v304;
  int v305;
  uint64_t v306;
  _BYTE *v307;
  uint64_t v308;
  uint64_t v309;
  __int16 *v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  __int16 v314;
  uint64_t v315;
  int v316;
  unint64_t v317;
  uint64_t v318;
  int v319;
  float v320;
  uint64_t v321;
  uint64_t v322;
  unint64_t v323;
  uint64_t v324;
  float32x4_t *v325;
  float32x4_t *v326;
  unint64_t v327;
  float32x4_t v328;
  uint64_t v329;
  uint64_t v330;
  float *v331;
  float *v332;
  float v333;
  _BOOL4 v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  _DWORD *v342;
  int v343;
  float32x4_t *v344;
  int16x4_t *v345;
  int v346;
  int v347;
  int v348;
  int v349;
  float32x4_t *v350;
  uint64_t v351;
  int v352;
  float v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  int v361;
  _DWORD *v362;
  char *v363;
  int v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  float v369;
  float v370;
  uint64_t v371;
  float *v372;
  float *v373;
  float v374;
  float v375;
  uint64_t v376;
  uint64_t v377;
  float *v378;
  float *v379;
  float v380;
  uint64_t v381;
  float v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  unint64_t v387;
  unint64_t v388;
  int8x16_t *v389;
  uint64_t v390;
  unint64_t v391;
  int8x16_t *v392;
  int8x16_t *v393;
  float32x4_t v394;
  float32x4_t v395;
  int8x16_t v396;
  int8x16_t v397;
  uint64_t v398;
  float *v399;
  float *v400;
  float v401;
  float v402;
  float v403;
  float v404;
  float v405;
  float32x4_t *v406;
  int32x2_t v407;
  uint64_t v408;
  uint64_t v409;
  float32x4_t *v410;
  uint64_t v411;
  uint64_t v412;
  float32x4_t v413;
  float32x4_t *v414;
  float32x4_t v415;
  uint64_t v416;
  uint64_t v417;
  float32x4_t *v418;
  float32x4_t v419;
  uint64_t v420;
  float *v421;
  int32x4_t v422;
  int32x4_t *v423;
  uint64_t v424;
  uint64_t v425;
  _DWORD *v426;
  uint64_t v427;
  _BYTE *v428;
  uint64_t v429;
  int v430;
  uint64_t v431;
  unint64_t v432;
  uint64_t *v433;
  char *v434;
  char *v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  float v439;
  int v440;
  _BOOL4 v441;
  uint64_t v442;
  unsigned int v443;
  unsigned int v444;
  int v445;
  BOOL v446;
  int v447;
  unsigned int v448;
  int v449;
  int v450;
  uint64_t v451;
  uint64_t v452;
  unint64_t v453;
  unint64_t v454;
  uint64_t v455;
  int v456;
  int *v457;
  int v458;
  int v459;
  int v460;
  unsigned int v461;
  uint64_t v462;
  char *v463;
  uint64_t *v464;
  uint64_t v465;
  signed int v466;
  int v467;
  signed int v468;
  uint64_t v469;
  int *v470;
  unint64_t v471;
  int v472;
  unint64_t v473;
  int *v474;
  int v475;
  int v476;
  float32x4_t *v477;
  uint64_t v478;
  int32x4_t *v479;
  float32x4_t *v480;
  int64_t v481;
  unint64_t v482;
  int v483;
  unsigned __int16 *v484;
  uint64_t v485;
  unsigned int v486;
  int v487;
  BOOL v488;
  int64_t v489;
  int v490;
  unsigned __int16 *v491;
  int v492;
  int v493;
  unsigned int v494;
  unsigned int v495;
  int v496;
  int v497;
  int v498;
  uint64_t v499;
  unsigned __int16 *v500;
  int v501;
  uint64_t v502;
  int v503;
  int v504;
  int v505;
  unsigned int v506;
  unsigned int v507;
  int v508;
  int v509;
  int v510;
  int v511;
  int v512;
  int v513;
  int v514;
  uint64_t *v515;
  unsigned int v516;
  unsigned int v517;
  uint64_t *v518;
  int v519;
  int v520;
  char v521;
  uint64_t v522;
  _WORD *v523;
  int v524;
  uint64_t v525;
  float v526;
  float v527;
  int v528;
  int v529;
  uint64_t v530;
  uint64_t v531;
  unint64_t v532;
  uint64_t v533;
  float32x4_t *v534;
  unint64_t v535;
  float32x4_t v536;
  float32x4_t v537;
  float32x4_t v538;
  float32x4_t v539;
  float32x4_t v540;
  float32x4_t v541;
  uint64_t v542;
  float *v543;
  float *v544;
  float v545;
  float v546;
  float v547;
  int v548;
  int v549;
  int v550;
  unint64_t v551;
  unint64_t v552;
  BOOL v554;
  BOOL v555;
  int8x16_t v556;
  uint32x4_t v557;
  int8x16_t *v558;
  int v559;
  int32x4_t v560;
  unint64_t v561;
  int32x4_t *v562;
  int32x4_t v563;
  int16x8_t v564;
  int16x8_t v565;
  uint32x4_t v566;
  uint32x4_t v567;
  int8x16_t v568;
  int v569;
  unsigned int v570;
  unsigned int v571;
  float v572;
  int v573;
  uint64_t v574;
  int v575;
  unsigned int v576;
  unsigned int v577;
  __int32 v578;
  signed int v579;
  int v580;
  int v581;
  int v582;
  BOOL v583;
  unsigned int v584;
  unsigned int v585;
  unsigned int v586;
  int v587;
  int v588;
  int v589;
  __int32 v590;
  uint64_t v591;
  __int32 v592;
  int v593;
  __int32 v594;
  int v595;
  int v596;
  int v597;
  int v598;
  float v599;
  float v600;
  int v601;
  float v602;
  float v603;
  float v604;
  uint64_t v605;
  int v606;
  float v607;
  float v608;
  int v609;
  BOOL v610;
  char v611;
  int v612;
  float v613;
  int v614;
  int v615;
  char v616;
  int v617;
  float v618;
  int v619;
  int v620;
  int v621;
  int v622;
  int v623;
  int v624;
  int v625;
  int v626;
  float v627;
  int v628;
  int v629;
  int v630;
  unsigned int v631;
  uint64_t v632;
  uint64_t v633;
  uint64_t v634;
  uint64_t v635;
  uint64_t v636;
  uint64_t v637;
  uint64_t v638;
  uint64_t v639;
  _BYTE *v640;
  _BOOL4 v641;
  unsigned int v642;
  unsigned int v643;
  unsigned int v644;
  unsigned int v645;
  int v646;
  int v647;
  int v648;
  uint64_t v649;
  int v650;
  uint64_t v651;
  int v652;
  int v653;
  int v654;
  uint64_t *v655;
  uint64_t v656;
  signed int v657;
  unsigned int v658;
  int v659;
  signed int v660;
  signed int v661;
  int *v662;
  float32x4_t *v663;
  int v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  uint64_t v668;
  int v669;
  unsigned int v670;
  int v671;
  int v672;
  int v673;
  float32x4_t *v674;
  float *v675;
  uint64_t v676;
  uint64_t v677;
  uint64_t v678;
  int v679;
  int v680;
  uint64_t v681;
  int v682;
  int v683;
  int v684;
  unsigned int v685;
  int v686;
  uint64_t v687;
  _BYTE *v688;
  uint64_t v689;
  _BYTE *v690;
  uint64_t v691;
  uint64_t v692;
  unint64_t v693;
  unint64_t v694;
  uint64_t v695;
  uint64_t v696;
  size_t v697;
  int *v698;
  uint64_t v699;
  int *v700;
  float32x4_t v701;
  float32x4_t v702;
  unint64_t v703;
  uint64_t v704;
  uint64_t v705;
  int8x16_t *v706;
  float32x4_t *v707;
  unint64_t v708;
  float32x4_t v709;
  float32x4_t v710;
  unint64_t v711;
  uint64_t v712;
  float *v713;
  float *v714;
  float v715;
  float v716;
  char v717;
  uint64_t v718;
  uint64_t v719;
  float *v720;
  float v721;
  char *v722;
  uint64_t v723;
  uint64_t v724;
  uint64_t v725;
  uint64_t v726;
  uint64_t v727;
  uint64_t v728;
  unint64_t v729;
  int *v730;
  int *v731;
  uint64_t v732;
  uint64_t v733;
  unint64_t v734;
  _OWORD *v735;
  int *v736;
  size_t v738;
  uint64_t v739;
  _OWORD *v740;
  uint64_t v741;
  _OWORD *v742;
  _OWORD *v743;
  uint64_t v744;
  uint64_t v745;
  char *v746;
  char *v747;
  int *v748;
  uint64_t v749;
  uint64_t *v750;
  unint64_t v751;
  size_t v752;
  size_t v753;
  size_t v754;
  int *v755;
  unint64_t v756;
  int *v757;
  int *v758;
  uint64_t v759;
  unint64_t v760;
  char *v761;
  char *v762;
  int *v763;
  uint64_t v764;
  int v765;
  uint64_t *v766;
  float32x4_t *v767;
  uint64_t v768;
  int8x16_t *v769;
  int8x16_t v770;
  int v771;
  int v772;
  uint64_t v773;
  _BYTE v774[12];
  float v775;
  uint64_t v776;
  int *v777;
  _BOOL4 v778;
  int v779;
  int v780;
  int v781;
  int v782;
  int v783;
  int v784;
  uint64_t v785;
  uint64_t v786;
  int v787;
  int v788;
  char *v789;
  uint64_t v790;
  int v791;
  unsigned int v792;
  int v793;
  int v794;
  uint64_t v795;
  int v796;
  uint64_t v797;
  __int128 v798;
  _BYTE *v799;
  __int128 v800;
  uint64_t v801;
  int v802;
  int v803;
  uint64_t v804;
  uint64_t v805;
  int *v806;
  uint64_t v807;
  float *v808;
  uint64_t v809;
  uint64_t v810;
  int16x8_t v811;
  uint64_t v812;
  unint64_t v813;
  unsigned int v814;
  unsigned __int16 *v815;
  char *v816;
  uint64_t v817;
  _BYTE *v818;
  float32x4_t *v819;
  uint64_t v820;
  uint64_t *v821;
  int32x4_t *v822;
  uint64_t v823;
  unint64_t v824;
  uint64_t v825;
  float32x4_t *v826;
  uint64_t v827;
  uint64_t *v828;
  uint64_t v829;
  char *v830;
  char *v831;
  int v832;
  int v833;
  float v834;
  int v835;
  int v836;
  _BOOL4 v837;
  float v838;
  int v839;
  _QWORD v840[7];
  float v841;
  _BYTE v842[4];
  _QWORD v843[11];

  v843[10] = *MEMORY[0x24BDAC8D0];
  memset(v840, 0, sizeof(v840));
  v7 = *((_DWORD *)a1 + 2);
  v8 = *((unsigned int *)a1 + 3);
  v839 = 15;
  v838 = 0.0;
  v837 = 0;
  v836 = 0;
  v835 = 0;
  v833 = 0;
  v832 = 0;
  v9 = (float32x4_t *)*a1;
  v11 = *(int *)(*a1 + 4);
  v10 = *(int *)(*a1 + 8);
  v12 = *(unsigned __int16 **)(*a1 + 32);
  v14 = *((int *)a1 + 9);
  v13 = *((int *)a1 + 10);
  result = 0xFFFFFFFFLL;
  v834 = 0.0;
  if (!a2)
    return result;
  if (a5 < 2)
    return result;
  v16 = v9[2].i32[2];
  if (v16 < 0)
    return result;
  v17 = 0;
  v18 = 0;
  v804 = v10;
  v829 = v14;
  v19 = *((int *)a1 + 8) * (uint64_t)a3;
  v20 = v16 + 1;
  v21 = 1;
  while (v9[3].i32[0] << v18 != (_DWORD)v19)
  {
    ++v18;
    v21 -= 2;
    v17 += 8;
    if (v20 == v18)
      return 0xFFFFFFFFLL;
  }
  v815 = v12;
  if (a6)
  {
    v22 = *((_DWORD *)a6 + 8);
    v23 = __clz(v22);
    v24 = v23 + *((_DWORD *)a6 + 6);
    v25 = ((__PAIR64__(8 * v24, ec_tell_frac_correction[(v22 >> (16 - v23) >> 12) - 8])
          - __PAIR64__(v22 >> (16 - v23) >> 12, v22 >> (16 - v23))) >> 32)
        - 248;
    v814 = v24 - 32;
    v26 = (int)(v24 - 28) >> 3;
  }
  else
  {
    v26 = 0;
    v814 = 1;
    v25 = 1;
  }
  v27 = v10 * v7;
  if (a5 >= 1275)
    v28 = 1275;
  else
    v28 = a5;
  LODWORD(v818) = v28 - v26;
  v29 = *((_DWORD *)a1 + 11);
  v30 = *((_DWORD *)a1 + 12);
  v827 = v13;
  v817 = v14;
  v781 = v25;
  v796 = v21;
  if (v30)
  {
    if (v29 != -1)
    {
      v803 = (v29 * (int)v19 + (v9->i32[0] >> 4)) / (v9->i32[0] >> 3);
      v31 = (v803 >> 6);
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if (v29 == -1)
  {
LABEL_26:
    v803 = 0;
    v31 = v818;
    goto LABEL_27;
  }
  v803 = 0;
  v32 = v814;
  if ((int)v814 <= 1)
    v32 = 0;
  v33 = (int)(v32 + v29 * v19 + 4 * v9->i32[0]) / (8 * v9->i32[0]) - (*((_DWORD *)a1 + 13) != 0);
  if ((int)v28 < v33)
    v33 = v28;
  if (v33 <= 2)
    v28 = 2;
  else
    v28 = v33;
  v31 = (v28 - v26);
LABEL_27:
  v809 = v31;
  v820 = v19;
  v34 = (_DWORD *)a1 + 63;
  v35 = ((v11 + 1024) * v7);
  v791 = 3 - v18;
  if ((400 * (int)v28) << (3 - v18) < v29 || v29 == -1)
    v29 = (400 * (_DWORD)v28) << (3 - v18);
  if (!a6)
  {
    v840[0] = a4;
    *(_OWORD *)((char *)&v840[1] + 4) = xmmword_208F31AE0;
    *(_OWORD *)((char *)&v840[3] + 4) = xmmword_208F08BB0;
    LODWORD(v840[1]) = v28;
    *(_QWORD *)((char *)&v840[5] + 4) = 0xFFFFFFFFLL;
    a6 = v840;
  }
  v821 = a6;
  v37 = 4 * v27;
  v808 = (float *)&v34[(int)v35];
  v812 = v10;
  v824 = v13;
  v823 = v8;
  v819 = v9;
  v828 = a1;
  LODWORD(v813) = v7;
  v826 = a2;
  v810 = v28;
  LODWORD(v825) = v29;
  if (v803 >= 1 && *((_DWORD *)a1 + 14))
  {
    v38 = 2 * (v814 == 1) <= (2 * v803 - *((_DWORD *)a1 + 53)) >> 6
        ? (2 * v803 - *((_DWORD *)a1 + 53)) >> 6
        : 2 * (v814 == 1);
    if (v38 < (int)v818)
    {
      v39 = (v38 + v26);
      v40 = *v821;
      v41 = *v821 + v39;
      v806 = (int *)v35;
      memmove((void *)(v41 - *((unsigned int *)v821 + 3)), (const void *)(v40 + *((unsigned int *)v821 + 2) - *((unsigned int *)v821 + 3)), *((unsigned int *)v821 + 3));
      *((_DWORD *)v821 + 2) = v39;
      v9 = v819;
      LODWORD(v818) = v38;
      v810 = v39;
    }
  }
  v802 = v26;
  v831 = (char *)&v808[(unint64_t)v37 / 4];
  v42 = v9->i32[3];
  if ((int)v827 >= (int)v42)
    v43 = v42;
  else
    v43 = v827;
  v44 = v813;
  v45 = MEMORY[0x24BDAC7A8]((v820 + v11), a2);
  v816 = &v774[-v52];
  v53 = v828;
  v54 = *((float *)v828 + 57);
  v55 = v823;
  v56 = *((_DWORD *)v828 + 8);
  v57 = ((v51 - (int)v11) * (int)v823 / v56);
  v58 = 0.0;
  if ((int)v57 < 1)
  {
    v67 = 0.0;
    v66 = v810;
    v59 = v826;
    if (v54 > 0.0)
      goto LABEL_64;
    goto LABEL_62;
  }
  v59 = v826;
  v60 = (float *)v826;
  v61 = ((v51 - (int)v11) * (int)v823 / v56);
  v62 = 0.0;
  do
  {
    v63 = *v60++;
    v64 = v63;
    if (v62 <= v63)
      v62 = v64;
    if (v58 >= v64)
      v58 = v64;
    --v61;
  }
  while (v61);
  v65 = -v58;
  if (v62 > v65)
    v65 = v62;
  v66 = v810;
  if (v54 <= v65)
  {
    v67 = 0.0;
    v68 = (float *)v826;
    v69 = v57;
    v58 = 0.0;
    do
    {
      v70 = *v68++;
      v71 = v70;
      if (v58 <= v70)
        v58 = v71;
      if (v67 >= v71)
        v67 = v71;
      --v69;
    }
    while (v69);
LABEL_62:
    v54 = -v67;
    if (v58 > (float)-v67)
      v54 = v58;
  }
LABEL_64:
  v830 = &v831[v37];
  v72 = v50 + v823 * v48;
  v73 = v49 - 50;
  LODWORD(v822) = 8 * v66;
  v74 = ((int)v11 * (int)v823 / v56);
  if ((int)v74 < 1)
  {
    v77 = 0.0;
    v76 = 0.0;
    v78 = v825;
  }
  else
  {
    v75 = &v59->f32[(int)v57];
    v76 = 0.0;
    v77 = 0.0;
    v78 = v825;
    do
    {
      v79 = *v75++;
      v80 = v79;
      if (v77 <= v79)
        v77 = v80;
      if (v76 >= v80)
        v76 = v80;
      --v74;
    }
    while (v74);
  }
  v811.i64[0] = (uint64_t)&v34[(int)v11 * (int)v813];
  v805 = v27;
  v81 = &v830[v37];
  v782 = v72;
  v792 = v78 - v73 * v72;
  v82 = -v76;
  if (v77 <= v82)
    v77 = v82;
  *((float *)v828 + 57) = v77;
  if (v54 <= v77)
    v83 = v77;
  else
    v83 = v54;
  v790 = v47;
  v797 = v17;
  v789 = v81;
  v785 = v42;
  v807 = v45;
  if (v814 == 1)
  {
    v806 = v46;
    v84 = 1.0 / (float)(1 << *((_DWORD *)v53 + 16));
    v85 = v821;
    ec_enc_bit_logp(v821, v83 <= v84, 15);
    v88 = v796;
    if (v83 > v84)
    {
      v802 = 1;
      v814 = 1;
      v55 = v823;
      v53 = v828;
      v44 = v813;
      LODWORD(v45) = v807;
      v59 = v826;
    }
    else
    {
      if (v803 < 1)
      {
        v87 = v822;
      }
      else
      {
        if ((int)v810 >= v802 + 2)
          v86 = (v802 + 2);
        else
          v86 = v810;
        v87 = 8 * v86;
        memmove((void *)(*v85 + v86 - *((unsigned int *)v85 + 3)), (const void *)(*v85 + *((unsigned int *)v85 + 2) - *((unsigned int *)v85 + 3)), *((unsigned int *)v85 + 3));
        *((_DWORD *)v85 + 2) = v86;
        LODWORD(v818) = 2;
        v809 = v86;
        v810 = v86;
      }
      v53 = v828;
      LODWORD(v45) = v807;
      v59 = v826;
      v802 = 0;
      *((_DWORD *)v85 + 6) = v87 - __clz(*((_DWORD *)v85 + 8)) + 32;
      LODWORD(v822) = v87;
      v814 = v87;
      v55 = v823;
      v44 = v813;
    }
    LODWORD(v46) = (_DWORD)v806;
  }
  else
  {
    v802 = 1;
    v88 = v796;
  }
  v89 = 0;
  v780 = 1 << v18;
  v801 = (int)v46;
  v783 = v55 - v88;
  v90 = (float *)&v816[4 * v11];
  v91 = v819 + 1;
  if (v44 <= 1)
    v92 = 1;
  else
    v92 = v44;
  v825 = v92;
  v93 = 4 * v92;
  v94 = 4 * (int)v45;
  v95 = v820;
  do
  {
    v97 = v83 > 65536.0 && *((_DWORD *)v53 + 5) != 0;
    celt_preemphasis(&v59->f32[v89 / 4], v90, v95, v44, *((_DWORD *)v53 + 8), v91->f32, (float *)((char *)v53 + v89 + 196), v97);
    v59 = v826;
    v53 = v828;
    v89 += 4;
    v90 = (float *)((char *)v90 + v94);
  }
  while (v93 != v89);
  v841 = 0.0;
  if (!*((_DWORD *)v828 + 17) || (int)v818 <= 3)
  {
    v98 = 0;
    v99 = v821;
    v100 = v820;
    v101 = (int)v822;
    v102 = v813;
    if ((int)v818 > 12 * (int)v823)
    {
      v103 = (char *)v811.i64[0];
      if ((_DWORD)v817 || ((v802 ^ 1) & 1) != 0)
        goto LABEL_113;
      goto LABEL_109;
    }
LABEL_111:
    v103 = (char *)v811.i64[0];
    goto LABEL_113;
  }
  v98 = 0;
  v99 = v821;
  v100 = v820;
  v101 = (int)v822;
  v102 = v813;
  if ((_DWORD)v817)
    goto LABEL_111;
  v103 = (char *)v811.i64[0];
  if (((v802 ^ 1) & 1) == 0)
  {
LABEL_109:
    if (*((_DWORD *)v828 + 6))
      v98 = 0;
    else
      v98 = *((_DWORD *)v828 + 7) > 4;
  }
LABEL_113:
  v105 = (int *)(v828 + 13);
  v104 = *((_DWORD *)v828 + 26);
  v806 = (int *)v828 + 31;
  v106 = run_prefilter(v828, v816, v103, v102, v100, v104, &v839, &v838, &v841, v98, (int)v818, (float *)v828 + 31);
  v108 = v828;
  v793 = v106;
  v109 = v838;
  if (v838 <= 0.4 && *((float *)v828 + 28) <= 0.4 || *v806 && *((float *)v828 + 32) <= 0.3)
  {
    v778 = 0;
    v788 = v104;
    if (v793)
    {
LABEL_120:
      ec_enc_bit_logp(v99, 1, 1);
      v113 = v839 + 1;
      v114 = __clz(v839 + 1);
      ec_encode(v99, 27 - v114, 28 - v114, 6u);
      v115 = (-16 << (27 - v114)) + v113;
      v116 = 31 - v114;
      v117 = *((_DWORD *)v99 + 4);
      v118 = *((_DWORD *)v99 + 5);
      v119 = v118 + 31 - v114;
      if (v119 < 0x21)
      {
        v123 = *((_DWORD *)v99 + 5);
        LODWORD(v102) = v813;
      }
      else
      {
        LODWORD(v102) = v813;
        do
        {
          v125 = *((_DWORD *)v99 + 2);
          v124 = *((_DWORD *)v99 + 3);
          if (v124 + *((_DWORD *)v99 + 7) < v125)
          {
            v120 = 0;
            v121 = *v99;
            v122 = v124 + 1;
            *((_DWORD *)v99 + 3) = v122;
            *(_BYTE *)(v121 + v125 - v122) = v117;
          }
          else
          {
            v120 = -1;
          }
          *((_DWORD *)v99 + 12) |= v120;
          v117 >>= 8;
          v123 = v118 - 8;
          v446 = v118 <= 15;
          v118 -= 8;
        }
        while (!v446);
        v119 = v116 + v123;
      }
      v126 = (v115 << v123) | v117;
      v127 = *((_DWORD *)v99 + 6) + v116;
      *((_DWORD *)v99 + 6) = v127;
      v128 = v841;
      v129 = v119 + 3;
      if ((v119 + 3) >= 0x21)
      {
        do
        {
          v135 = *((_DWORD *)v99 + 2);
          v134 = *((_DWORD *)v99 + 3);
          if (v134 + *((_DWORD *)v99 + 7) < v135)
          {
            v130 = 0;
            v131 = *v99;
            v132 = v134 + 1;
            *((_DWORD *)v99 + 3) = v132;
            *(_BYTE *)(v131 + v135 - v132) = v126;
          }
          else
          {
            v130 = -1;
          }
          *((_DWORD *)v99 + 12) |= v130;
          v126 >>= 8;
          v133 = v119 - 8;
          v446 = v119 <= 15;
          v119 -= 8;
        }
        while (!v446);
        v129 = v133 + 3;
        v127 = *((_DWORD *)v99 + 6);
        LOBYTE(v119) = v133;
      }
      *((_DWORD *)v99 + 4) = (LODWORD(v128) << v119) | v126;
      *((_DWORD *)v99 + 5) = v129;
      *((_DWORD *)v99 + 6) = v127 + 3;
      ec_enc_icdf(v99, v104, (uint64_t)&tapset_icdf_0, 2);
      goto LABEL_140;
    }
  }
  else
  {
    v110 = (double)v839;
    v111 = (double)*((int *)v828 + 27);
    v112 = v111 * 1.26 < v110;
    if (v111 * 0.79 > v110)
      v112 = 1;
    v778 = v112;
    v788 = v104;
    if (v793)
      goto LABEL_120;
  }
  if (!(_DWORD)v829 && (int)(v814 + 16) <= v101)
  {
    ec_enc_bit_logp(v99, 0, 1);
LABEL_140:
    v108 = v828;
  }
  v136 = *((_DWORD *)v108 + 7);
  if (v136 < 1 || *((_DWORD *)v108 + 17))
  {
    v137 = 0;
    v777 = v105;
    if (!v18)
      goto LABEL_147;
  }
  else
  {
    transient_analysis();
    v777 = v105;
    if (!v18)
    {
LABEL_147:
      v784 = 1;
      v138 = v817;
LABEL_148:
      v139 = MEMORY[0x24BDAC7A8](v137, v107);
      v141 = (float32x4_t *)&v774[-v140];
      v143 = MEMORY[0x24BDAC7A8](v139, v142);
      v145 = (float32x4_t *)&v774[-((v144 + 15) & 0x7FFFFFFF0)];
      v147 = MEMORY[0x24BDAC7A8](v143, v146);
      v149 = (float32x4_t *)&v774[-v148];
      v807 = (v804 * v823);
      MEMORY[0x24BDAC7A8](v147, v150);
      v826 = (float32x4_t *)&v774[-v152];
      v153 = 0;
      v814 = 0;
      v154 = v102;
      v155 = 0;
      v156 = 1;
      v157 = v828;
      goto LABEL_149;
    }
  }
  if ((int)(*((_DWORD *)v99 + 6) + __clz(*((_DWORD *)v99 + 8)) - 29) > v101)
    goto LABEL_147;
  v138 = v817;
  if (!(_DWORD)v137)
  {
    v784 = 0;
    goto LABEL_148;
  }
  v181 = MEMORY[0x24BDAC7A8](v137, v107);
  v141 = (float32x4_t *)&v774[-v182];
  v184 = MEMORY[0x24BDAC7A8](v181, v183);
  v145 = (float32x4_t *)&v774[-((v185 + 15) & 0x7FFFFFFF0)];
  v187 = MEMORY[0x24BDAC7A8](v184, v186);
  v149 = (float32x4_t *)&v774[-v188];
  v189 = v823;
  v807 = (v804 * v823);
  MEMORY[0x24BDAC7A8](v187, v190);
  v192 = (float32x4_t *)&v774[-v191];
  v154 = v102;
  v826 = (float32x4_t *)&v774[-v191];
  if (v136 < 8)
  {
    v153 = 0;
    v784 = 0;
    v814 = 1;
    v155 = v780;
    v151 = v189;
    v156 = 0;
    v157 = v828;
  }
  else
  {
    v193 = v819;
    compute_mdcts((uint64_t)v819, 0, (uint64_t)v816, v141, v189, v154, v18, *((_DWORD *)v828 + 8));
    compute_band_energies((uint64_t)v193, (uint64_t)v141, (uint64_t)v145, v43, v189, v18);
    v194 = (uint64_t)v193;
    v195 = v827;
    amp2Log2(v194, v43, v827, v145, v192, v189);
    v151 = v189;
    if ((int)v189 >= 1)
    {
      v197 = 0;
      v198 = 0;
      *(float *)v196.i32 = (float)v18;
      v199 = (float32x4_t)vdupq_lane_s32(v196, 0);
      v200 = v192 + 1;
      v201 = v812;
      v202.i64[0] = 0x3F0000003F000000;
      v202.i64[1] = 0x3F0000003F000000;
      v157 = v828;
      while (1)
      {
        if ((int)v195 >= 1)
        {
          if (v195 >= 8)
          {
            v204 = v195 & 0xFFFFFFF8;
            v205 = v200;
            do
            {
              v206 = vmlaq_f32(*v205, v202, v199);
              v205[-1] = vmlaq_f32(v205[-1], v202, v199);
              *v205 = v206;
              v205 += 2;
              v204 -= 8;
            }
            while (v204);
            v203 = v195 & 0xFFFFFFF8;
            if (v203 == v195)
              goto LABEL_179;
          }
          else
          {
            v203 = 0;
          }
          v207 = v195 - v203;
          v208 = &v192->f32[v203 + v197];
          do
          {
            *v208 = *v208 + (float)(*(float *)v196.i32 * 0.5);
            ++v208;
            --v207;
          }
          while (v207);
        }
LABEL_179:
        ++v198;
        v200 = (float32x4_t *)((char *)v200 + 4 * v201);
        v197 += v201;
        if (v198 == v189)
        {
          v784 = 0;
          v156 = 0;
          v153 = 1;
          v814 = 1;
          v155 = v780;
          goto LABEL_223;
        }
      }
    }
    v784 = 0;
    v156 = 0;
    v153 = 1;
    v814 = 1;
    v155 = v780;
    v157 = v828;
LABEL_223:
    v154 = v813;
  }
  v138 = v817;
LABEL_149:
  compute_mdcts((uint64_t)v819, v155, (uint64_t)v816, v141, v151, v154, v18, *((_DWORD *)v157 + 8));
  v159 = v823;
  v160 = v154 == 2 && (_DWORD)v823 == 1;
  v161 = v160;
  v787 = v161;
  if (v160)
    v835 = 0;
  v162 = v828;
  if ((int)v43 >= 1)
  {
    v163 = 0;
    v164 = 0;
    v165 = (__int16 *)v819[2].i64[0];
    v166 = v819->i32[2];
    v167 = v819[3].i32[0] << v18;
    if ((int)v823 <= 1)
      v168 = 1;
    else
      v168 = v823;
    v169 = *v165;
    do
    {
      v170 = 0;
      LOWORD(v171) = v169;
      do
      {
        v173 = (__int16)v171;
        v174 = v170 + 1;
        v171 = v165[v170 + 1];
        v175 = ((v171 - v173) << v18);
        if ((int)v175 < 1)
        {
          v172 = 0.0;
        }
        else
        {
          v176 = &v141->f32[v163 + (v173 << v18)];
          v172 = 0.0;
          do
          {
            v177 = *v176++;
            v172 = v172 + (float)(v177 * v177);
            --v175;
          }
          while (v175);
        }
        v145->f32[v170 + v164 * v166] = sqrtf(v172 + 1.0e-27);
        ++v170;
      }
      while (v174 != v43);
      ++v164;
      v163 += v167;
    }
    while (v164 != v168);
  }
  v794 = v155;
  v178 = *((_DWORD *)v162 + 17);
  if (!v178 || (int)v827 < 3)
    goto LABEL_196;
  *(float *)v158.i32 = v145->f32[0] * 0.0001;
  v179 = v827 - 2;
  if ((unint64_t)(v827 - 2) < 8)
  {
    v180 = 2;
    goto LABEL_192;
  }
  v209 = (float32x4_t)vdupq_lane_s32(v158, 0);
  v180 = v179 & 0xFFFFFFFFFFFFFFF8 | 2;
  v210 = (float32x4_t *)((char *)v145 + 24);
  v211 = (float32x4_t)vdupq_n_s32(0x26901D7Du);
  v212 = v179 & 0xFFFFFFFFFFFFFFF8;
  do
  {
    v213 = vmaxnmq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v209, *v210), *(int8x16_t *)v210, (int8x16_t)v209), v211);
    v210[-1] = vmaxnmq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v209, v210[-1]), (int8x16_t)v210[-1], (int8x16_t)v209), v211);
    *v210 = v213;
    v210 += 2;
    v212 -= 8;
  }
  while (v212);
  if (v179 != (v179 & 0xFFFFFFFFFFFFFFF8))
  {
LABEL_192:
    v214 = v827 - v180;
    v215 = &v145->f32[v180];
    do
    {
      v216 = *v215;
      if (*v215 >= *(float *)v158.i32)
        v216 = *(float *)v158.i32;
      *v215++ = fmaxf(v216, 1.0e-15);
      --v214;
    }
    while (v214);
  }
LABEL_196:
  amp2Log2((uint64_t)v819, v43, v827, v145, v149, v159);
  MEMORY[0x24BDAC7A8](v217, v218);
  v795 = v219;
  v799 = &v774[-((v219 + 15) & 0x7FFFFFFF0)];
  v786 = 4 * v824;
  bzero(v799, 4 * v824);
  v222 = v828;
  if ((_DWORD)v138 || (v229 = v828[30]) == 0)
  {
    v223 = 0.0;
    v224 = 0.0;
    v225 = 0.0;
    v226 = v812;
    v227 = v824;
    v228 = v823;
    if (!v178)
      goto LABEL_250;
    goto LABEL_267;
  }
  v223 = 0.0;
  v224 = 0.0;
  v225 = 0.0;
  v226 = v812;
  v227 = v824;
  v228 = v823;
  if (v178)
    goto LABEL_267;
  LODWORD(v230) = *((_DWORD *)v828 + 24);
  if ((int)v230 <= 2)
    v230 = 2;
  else
    v230 = v230;
  if ((int)v823 > 0)
  {
    v231 = 0;
    v232 = 0;
    v233 = v815 + 1;
    v234 = *v815;
    v811 = vdupq_n_s16(*v815);
    v235 = vdupq_n_s32(v230);
    v236 = 0.0;
    v800 = xmmword_208F08E20;
    v798 = xmmword_208F071C0;
    __asm { FMOV            V17.4S, #0.25 }
    v240.i64[0] = 0xC0000000C0000000;
    v240.i64[1] = 0xC0000000C0000000;
    v241.i64[0] = 0x3F0000003F000000;
    v241.i64[1] = 0x3F0000003F000000;
    v242.i64[0] = 0x100000001;
    v242.i64[1] = 0x100000001;
    v243.i64[0] = 0x800000008;
    v243.i64[1] = 0x800000008;
    v244 = (float *)v229;
    v245 = 0.0;
    v775 = v109;
    while (v230 >= 8)
    {
      v247 = 0uLL;
      v248 = v230 & 0x7FFFFFF8;
      v221 = (unint64_t)v244;
      v249 = (int32x4_t)v232;
      v250 = (int8x16_t *)(v815 + 1);
      v251 = (int8x16_t)v811;
      v252 = (int32x4_t)v798;
      v253 = (int32x4_t)v800;
      do
      {
        v254 = v251;
        v255 = *(float32x4_t *)v221;
        v256 = *(float32x4_t *)(v221 + 16);
        v221 += 32;
        v257 = vmaxnmq_f32(vminnmq_f32(v255, _Q17), v240);
        v258 = vmaxnmq_f32(vminnmq_f32(v256, _Q17), v240);
        v259 = (float32x4_t)vbslq_s8((int8x16_t)vcgtzq_f32(v257), (int8x16_t)vmulq_f32(v257, v241), (int8x16_t)v257);
        v260 = (float32x4_t)vbslq_s8((int8x16_t)vcgtzq_f32(v258), (int8x16_t)vmulq_f32(v258, v241), (int8x16_t)v258);
        v261 = *v250++;
        v251 = v261;
        v262 = (int16x8_t)vextq_s8(v254, v261, 0xEuLL);
        v263 = vsubl_high_s16((int16x8_t)v261, v262);
        v264 = vsubl_s16(*(int16x4_t *)v261.i8, *(int16x4_t *)v262.i8);
        v265 = vmulq_f32(v260, vcvtq_f32_s32(v263));
        v266 = vmulq_f32(v259, vcvtq_f32_s32(v264));
        v247 = vaddq_s32(v263, v247);
        v249 = vaddq_s32(v264, v249);
        v267 = vmulq_f32(v260, vcvtq_f32_s32(vaddq_s32(vsubq_s32(vaddq_s32(v253, v253), v235), v242)));
        v268 = vmulq_f32(v259, vcvtq_f32_s32(vaddq_s32(vsubq_s32(vaddq_s32(v252, v252), v235), v242)));
        v236 = (float)((float)((float)((float)((float)((float)((float)(v236 + v268.f32[0]) + v268.f32[1]) + v268.f32[2])
                                             + v268.f32[3])
                                     + v267.f32[0])
                             + v267.f32[1])
                     + v267.f32[2])
             + v267.f32[3];
        v245 = (float)((float)((float)((float)((float)((float)((float)(v245 + v266.f32[0]) + v266.f32[1]) + v266.f32[2])
                                             + v266.f32[3])
                                     + v265.f32[0])
                             + v265.f32[1])
                     + v265.f32[2])
             + v265.f32[3];
        v252 = vaddq_s32(v252, v243);
        v253 = vaddq_s32(v253, v243);
        v248 -= 8;
      }
      while (v248);
      v232 = vaddvq_s32(vaddq_s32(v249, v247));
      if ((v230 & 0x7FFFFFF8) != v230)
      {
        v246 = v251.i16[7];
        v221 = v230 & 0x7FFFFFF8;
        v109 = v775;
LABEL_214:
        v269 = 1 - v230 + 2 * v221;
        do
        {
          v270 = fmaxf(fminf(v244[v221], 0.25), -2.0);
          if (v270 > 0.0)
            v270 = v270 * 0.5;
          v271 = (__int16)v233[v221] - v246;
          v245 = v245 + (float)(v270 * (float)v271);
          v232 += v271;
          v236 = v236 + (float)(v270 * (float)v269);
          v269 += 2;
          v246 = v233[v221++];
        }
        while (v230 != v221);
        goto LABEL_207;
      }
      v109 = v775;
LABEL_207:
      ++v231;
      v244 += v812;
      if (v231 == v823)
        goto LABEL_226;
    }
    v221 = 0;
    v246 = v234;
    goto LABEL_214;
  }
  v232 = 0;
  v245 = 0.0;
  v236 = 0.0;
LABEL_226:
  v272 = fminf((float)((float)(v236 * 6.0) / (float)(v230 * v823 * (v230 - 1) + v230 * v823 * (v230 - 1) * v230)) * 0.5, 0.031);
  v273 = (__int16 *)(v815 + 1);
  v274 = 1;
  v220 = (float *)v799;
  do
  {
    v275 = *v273++;
    --v274;
  }
  while (v275 < (v815[v230] + (v815[v230] >> 15)) << 16 >> 17);
  v276 = 0;
  v277 = 0;
  v278 = (float)(v245 / (float)v232) + 0.2;
  v279 = fmaxf(v272, -0.031);
  do
  {
    v281 = *(float *)(v229 + 4 * v276);
    if (v228 != 2)
    {
      v282 = fminf(v281, 0.0) - (float)(v278 + (float)(v279 * (float)v274));
      if (v282 <= 0.25)
        goto LABEL_229;
LABEL_236:
      v220[v276] = v282 + -0.25;
      ++v277;
      goto LABEL_229;
    }
    v280 = v229 + 4 * v226;
    if (v281 <= *(float *)(v280 + 4 * v276))
      v281 = *(float *)(v280 + 4 * v276);
    v282 = fminf(v281, 0.0) - (float)(v278 + (float)(v279 * (float)v274));
    if (v282 > 0.25)
      goto LABEL_236;
LABEL_229:
    ++v276;
    ++v274;
  }
  while (v230 != v276);
  if (v277 < 3)
    goto LABEL_249;
  v278 = v278 + 0.25;
  if (v278 > 0.0)
  {
    bzero(v220, 4 * v230);
    v222 = v828;
    v228 = v823;
    v227 = v824;
    v226 = v812;
    v278 = 0.0;
    v279 = 0.0;
    goto LABEL_249;
  }
  if (v230 >= 8)
  {
    v283 = v230 & 0x7FFFFFF8;
    v284 = (float32x4_t *)(v220 + 4);
    __asm { FMOV            V2.4S, #-0.25 }
    v286 = v230 & 0xFFFFFFF8;
    do
    {
      v287 = vaddq_f32(v284[-1], _Q2);
      v288 = vaddq_f32(*v284, _Q2);
      v284[-1] = (float32x4_t)vbicq_s8((int8x16_t)v287, (int8x16_t)vcltzq_f32(v287));
      *(int8x16_t *)v284 = vbicq_s8((int8x16_t)v288, (int8x16_t)vcltzq_f32(v288));
      v284 += 2;
      v286 -= 8;
    }
    while (v286);
    if (v230 != v283)
      goto LABEL_245;
  }
  else
  {
    v283 = 0;
LABEL_245:
    v289 = v230 - v283;
    v290 = &v220[v283];
    do
    {
      v291 = *v290 + -0.25;
      if (v291 < 0.0)
        v291 = 0.0;
      *v290++ = v291;
      --v289;
    }
    while (v289);
  }
LABEL_249:
  v224 = v278 + 0.2;
  v223 = v279 * 64.0;
LABEL_250:
  v292 = (float)v18 * 0.5;
  v293 = 0.0;
  if (v156)
    v292 = 0.0;
  if ((int)v827 > (int)v138)
  {
    v294 = v227 - v138;
    v295 = &v149->f32[v138 + v226];
    v296 = &v149->f32[v138];
    v297 = -10.0;
    do
    {
      v297 = v297 + -1.0;
      if (v297 <= (float)(*v296 - v292))
        v297 = *v296 - v292;
      if (v228 == 2 && v297 <= (float)(*v295 - v292))
        v297 = *v295 - v292;
      v293 = v293 + v297;
      ++v295;
      ++v296;
      --v294;
    }
    while (v294);
  }
  v178 = 0;
  v298 = v293 / (float)(v827 - v138);
  v299 = *((float *)v222 + 62);
  v300 = v298 - v299;
  if (v300 < -1.5)
    v300 = -1.5;
  if (v300 <= 3.0)
    v225 = v300;
  else
    v225 = 3.0;
  *((float *)v222 + 62) = v299 + (float)(v225 * 0.02);
LABEL_267:
  if ((v153 & 1) == 0)
  {
    v220 = (float *)memcpy(v826, v149, 4 * (int)v807);
    v222 = v828;
    v228 = v823;
    LODWORD(v227) = v824;
    v226 = v812;
  }
  if (v18)
  {
    v301 = *((_DWORD *)v821 + 6) + __clz(*((_DWORD *)v821 + 8)) - 29;
    v302 = v814;
    if (v301 > (int)v822)
      v302 = 1;
    if ((v302 & 1) != 0 || (v814 = 0, v368 = v827, v178) || *((int *)v222 + 7) < 5)
    {
      v303 = v821;
    }
    else
    {
      v303 = v821;
      if (!(_DWORD)v829)
      {
        v369 = *v808;
        if (v228 == 1)
        {
          v841 = *v808;
          v370 = 0.0;
          if ((int)v827 >= 2)
          {
            v371 = v827 - 1;
            v372 = (float *)v842;
            v373 = (float *)v222 + v801 + 64;
            do
            {
              v374 = *v373++;
              v375 = v374;
              v369 = v369 + -1.0;
              if (v369 <= v374)
                v369 = v375;
              *v372++ = v369;
              --v371;
            }
            while (v371);
            goto LABEL_341;
          }
          goto LABEL_366;
        }
        if (v369 <= v808[v226])
          v369 = v808[v226];
        v841 = v369;
        v370 = 0.0;
        if ((int)v827 >= 2)
        {
          v377 = v827 - 1;
          v378 = (float *)v842;
          v379 = (float *)v222 + v801 + 64;
          do
          {
            v369 = v369 + -1.0;
            v380 = *v379;
            if (*v379 <= v379[v226])
              v380 = v379[v226];
            if (v369 <= v380)
              v369 = v380;
            *v378++ = v369;
            ++v379;
            --v377;
          }
          while (v377);
LABEL_341:
          v370 = 0.0;
          if ((int)v368 >= 2)
          {
            v381 = 4 * (v368 - 2);
            v382 = *(float *)&v842[v381];
            do
            {
              v382 = v382 + -1.0;
              if (*(float *)&v842[v381 - 4] > v382)
                v382 = *(float *)&v842[v381 - 4];
              *(float *)&v842[v381 - 4] = v382;
              v381 -= 4;
            }
            while (v381 != -4);
            if ((int)v227 >= 4)
            {
              v383 = 0;
              v384 = 0;
              v385 = (v368 - 1);
              if (v228 <= 1)
                v386 = 1;
              else
                v386 = v228;
              v387 = v385 - 2;
              v388 = (v385 - 2) & 0xFFFFFFFFFFFFFFF8;
              v389 = (int8x16_t *)&v149[1].u32[2];
              v220 = &v841;
              v221 = (unint64_t)v843;
              v370 = 0.0;
              while (v387 >= 8)
              {
                v391 = (v385 - 2) & 0xFFFFFFFFFFFFFFF8;
                v392 = (int8x16_t *)v843;
                v393 = v389;
                do
                {
                  v394 = vsubq_f32((float32x4_t)vbicq_s8(v393[-1], (int8x16_t)vcltzq_f32((float32x4_t)v393[-1])), (float32x4_t)vbicq_s8(v392[-1], (int8x16_t)vcltzq_f32((float32x4_t)v392[-1])));
                  v395 = vsubq_f32((float32x4_t)vbicq_s8(*v393, (int8x16_t)vcltzq_f32(*(float32x4_t *)v393)), (float32x4_t)vbicq_s8(*v392, (int8x16_t)vcltzq_f32(*(float32x4_t *)v392)));
                  v396 = vbicq_s8((int8x16_t)v394, (int8x16_t)vcltzq_f32(v394));
                  v397 = vbicq_s8((int8x16_t)v395, (int8x16_t)vcltzq_f32(v395));
                  v370 = (float)((float)((float)((float)((float)((float)((float)(v370 + *(float *)v396.i32)
                                                                       + *(float *)&v396.i32[1])
                                                               + *(float *)&v396.i32[2])
                                                       + *(float *)&v396.i32[3])
                                               + *(float *)v397.i32)
                                       + *(float *)&v397.i32[1])
                               + *(float *)&v397.i32[2])
                       + *(float *)&v397.i32[3];
                  v393 += 2;
                  v392 += 2;
                  v391 -= 8;
                }
                while (v391);
                v390 = v388 | 2;
                if (v387 != v388)
                  goto LABEL_357;
LABEL_351:
                ++v384;
                v389 = (int8x16_t *)((char *)v389 + 4 * v226);
                v383 += v226;
                if (v384 == v386)
                  goto LABEL_366;
              }
              v390 = 2;
LABEL_357:
              v398 = v385 - v390;
              v399 = (float *)&v842[4 * v390 - 4];
              v400 = &v149->f32[v390 + v383];
              do
              {
                v401 = *v400++;
                v402 = v401;
                if (v401 < 0.0)
                  v402 = 0.0;
                v403 = *v399++;
                v404 = v403;
                if (v403 < 0.0)
                  v404 = 0.0;
                v405 = v402 - v404;
                if (v405 < 0.0)
                  v405 = 0.0;
                v370 = v370 + v405;
                --v398;
              }
              while (v398);
              goto LABEL_351;
            }
          }
        }
LABEL_366:
        if ((float)(v370 / (float)((v368 - 3) * v228)) <= 1.0)
        {
          v814 = 0;
          goto LABEL_274;
        }
        v406 = v819;
        compute_mdcts((uint64_t)v819, v780, (uint64_t)v816, v141, v228, v813, v18, *((_DWORD *)v222 + 8));
        compute_band_energies((uint64_t)v406, (uint64_t)v141, (uint64_t)v145, v43, v823, v18);
        amp2Log2((uint64_t)v406, v43, v368, v145, v149, v823);
        v408 = v823;
        v409 = v812;
        v410 = v826;
        if ((int)v823 < 1)
        {
LABEL_380:
          v834 = 0.2;
          v301 = *((_DWORD *)v303 + 6) + __clz(*((_DWORD *)v303 + 8)) - 29;
          v814 = 1;
          v794 = v780;
          goto LABEL_274;
        }
        v411 = 0;
        v412 = 0;
        *(float *)v407.i32 = (float)v18;
        v413 = (float32x4_t)vdupq_lane_s32(v407, 0);
        v414 = v826 + 1;
        v415.i64[0] = 0x3F0000003F000000;
        v415.i64[1] = 0x3F0000003F000000;
        while (2)
        {
          if ((int)v368 >= 1)
          {
            if (v368 < 8)
            {
              v416 = 0;
              goto LABEL_377;
            }
            v417 = v368 & 0xFFFFFFF8;
            v418 = v414;
            do
            {
              v419 = vmlaq_f32(*v418, v415, v413);
              v418[-1] = vmlaq_f32(v418[-1], v415, v413);
              *v418 = v419;
              v418 += 2;
              v417 -= 8;
            }
            while (v417);
            v416 = v368 & 0xFFFFFFF8;
            if (v416 != v368)
            {
LABEL_377:
              v420 = v368 - v416;
              v421 = &v410->f32[v416 + v411];
              do
              {
                *v421 = *v421 + (float)(*(float *)v407.i32 * 0.5);
                ++v421;
                --v420;
              }
              while (v420);
            }
          }
          ++v412;
          v414 = (float32x4_t *)((char *)v414 + 4 * v409);
          v411 += v409;
          if (v412 == v408)
            goto LABEL_380;
          continue;
        }
      }
    }
LABEL_274:
    if (v301 <= (int)v822)
      v220 = (float *)ec_enc_bit_logp(v303, v814, 3);
  }
  else
  {
    v303 = v821;
  }
  v304 = MEMORY[0x24BDAC7A8](v220, v221);
  v305 = v823;
  v307 = &v774[-v306];
  v813 = (v43 - 1);
  if ((int)v43 >= 1)
  {
    v308 = 0;
    v309 = 0;
    v310 = (__int16 *)v819[2].i64[0];
    v311 = v819->i32[2];
    v312 = v819[3].i32[0] << v18;
    if ((int)v823 <= 1)
      v313 = 1;
    else
      v313 = v823;
    v314 = *v310;
    do
    {
      v315 = 0;
      v304 = v309 * v311;
      LOWORD(v316) = v314;
      do
      {
        LODWORD(v317) = (__int16)v316 << v18;
        v318 = v315 + 1;
        v316 = v310[v315 + 1];
        v319 = v316 << v18;
        if ((int)v317 < v316 << v18)
        {
          v320 = 1.0 / (float)(v145->f32[v315 + v304] + 1.0e-27);
          v321 = (int)v317;
          v322 = v319;
          v323 = v319 - (uint64_t)(int)v317;
          v317 = (int)v317;
          if (v323 < 8)
            goto LABEL_290;
          v317 = (v323 & 0xFFFFFFFFFFFFFFF8) + (int)v317;
          v324 = 4 * (v308 + v321);
          v325 = (float32x4_t *)((char *)v141 + v324 + 16);
          v326 = (float32x4_t *)&v307[v324 + 16];
          v327 = v323 & 0xFFFFFFFFFFFFFFF8;
          do
          {
            v328 = vmulq_n_f32(*v325, v320);
            v326[-1] = vmulq_n_f32(v325[-1], v320);
            *v326 = v328;
            v325 += 2;
            v326 += 2;
            v327 -= 8;
          }
          while (v327);
          if (v323 != (v323 & 0xFFFFFFFFFFFFFFF8))
          {
LABEL_290:
            v329 = v322 - v317;
            v330 = v308 + v317;
            v331 = (float *)&v307[v330 * 4];
            v332 = &v141->f32[v330];
            do
            {
              v333 = *v332++;
              *v331++ = v320 * v333;
              --v329;
            }
            while (v329);
          }
        }
        v315 = v318;
      }
      while (v318 != v43);
      ++v309;
      v308 += v312;
    }
    while (v309 != v313);
  }
  *(_QWORD *)&v800 = v149;
  v811.i64[0] = (uint64_t)v307;
  if ((int)v809 < 15 * v305 || (_DWORD)v138)
  {
    LODWORD(v816) = 0;
  }
  else
  {
    v335 = *((int *)v828 + 7) > 1 && *((_DWORD *)v828 + 17) == 0;
    LODWORD(v816) = v335;
  }
  v336 = 4 * v804;
  v337 = MEMORY[0x24BDAC7A8](v304, v826);
  v339 = MEMORY[0x24BDAC7A8](v337, v338);
  v340 = (uint64_t)&v774[-((v336 + 15) & 0x7FFFFFFF0)];
  MEMORY[0x24BDAC7A8](v339, v341);
  v343 = v342[16];
  v344 = v819;
  v345 = (int16x4_t *)v819[4].i64[0];
  v346 = v342[12];
  v347 = v342[14];
  v776 = v340;
  v348 = v809;
  v349 = v814;
  v826 = v350;
  v353 = dynalloc_analysis((float *)v800, v351, v812, v829, v824, v823, (uint64_t)v350, v343, v345, v814, v346, v347, (uint64_t)v815, v18, v809, &v833, v352, (uint64_t)v799, v806,
           v340,
           (int8x16_t *)v340);
  *(_QWORD *)&v798 = v336;
  MEMORY[0x24BDAC7A8](v354, v355);
  v357 = v340;
  v804 = v340;
  if ((_DWORD)v816)
  {
    if (20480 / v348 >= 78)
      v358 = (20480 / v348 + 2);
    else
      v358 = 80;
    v359 = tf_analysis(v344[2].i64[0], v43, v349, v834, v340, v358, v811.i64[0], v820, v18, v835, (int *)v340);
    LODWORD(v340) = v349;
    if ((int)v827 <= (int)v785)
    {
      v366 = v827;
      v367 = v817;
      v363 = (char *)v808;
      v364 = v805;
      v365 = v800;
    }
    else
    {
      v360 = (int)v813;
      v361 = v824 - v785;
      v362 = (_DWORD *)(v357 + 4 * v785);
      v363 = (char *)v808;
      v364 = v805;
      v365 = v800;
      do
      {
        *v362++ = *(_DWORD *)(v357 + 4 * v360);
        --v361;
      }
      while (v361);
      v366 = v827;
      v367 = v817;
    }
    goto LABEL_389;
  }
  v367 = v817;
  if ((_DWORD)v817 && v832)
  {
    v366 = v827;
    v363 = (char *)v808;
    v364 = v805;
    LODWORD(v340) = v814;
    v365 = v800;
    if ((int)v827 >= 1)
      memset_pattern16((void *)v804, &unk_208F1A9B0, 4 * v827);
LABEL_388:
    v359 = 0;
  }
  else
  {
    v366 = v827;
    v363 = (char *)v808;
    v364 = v805;
    v340 = v814;
    v365 = v800;
    if (!(_DWORD)v829 || (int)v809 > 14 || *((_DWORD *)v828 + 47) == 2)
    {
      if ((int)v827 < 1)
        goto LABEL_388;
      if (v827 >= 8)
      {
        v376 = v827 & 0xFFFFFFF8;
        v422 = vdupq_n_s32(v814);
        v423 = (int32x4_t *)(v804 + 16);
        v424 = v376;
        do
        {
          v423[-1] = v422;
          *v423 = v422;
          v423 += 2;
          v424 -= 8;
        }
        while (v424);
        if (v376 == v366)
          goto LABEL_388;
      }
      else
      {
        v376 = 0;
      }
      v425 = v366 - v376;
      v426 = (_DWORD *)(v804 + 4 * v376);
      do
      {
        *v426++ = v340;
        --v425;
      }
      while (v425);
      goto LABEL_388;
    }
    v359 = v814;
    if ((int)v827 >= 1)
    {
      bzero((void *)v804, 4 * v827);
      v359 = v340;
    }
  }
LABEL_389:
  v779 = v359;
  MEMORY[0x24BDAC7A8](v359, v356);
  v428 = &v774[-((v427 + 15) & 0x7FFFFFFF0)];
  v429 = 0;
  v430 = v823;
  if ((int)v823 <= 1)
    v431 = 1;
  else
    v431 = v823;
  v432 = v824 - v367;
  v433 = v828;
  v434 = (char *)v828 + 4 * v367 + 4 * v801 + 252;
  v435 = &v434[12 * v364];
  v436 = 4 * v812;
  v795 = 4 * v367;
  v437 = v365 + 4 * v367;
  do
  {
    if ((int)v367 < (int)v366)
    {
      v438 = 0;
      do
      {
        v439 = *(float *)(v437 + 4 * v438);
        if (vabds_f32(v439, *(float *)&v434[4 * v438]) < 2.0)
          *(float *)(v437 + 4 * v438) = v439 + (float)(*(float *)&v435[4 * v438] * -0.25);
        ++v438;
      }
      while (v432 != v438);
    }
    ++v429;
    v435 += v436;
    v434 += v436;
    v437 += v436;
  }
  while (v429 != v431);
  v813 = v432;
  v785 = v431;
  v440 = *((_DWORD *)v433 + 4);
  v441 = *((_DWORD *)v433 + 7) > 3;
  v772 = *((_DWORD *)v433 + 15);
  LODWORD(v773) = *((_DWORD *)v433 + 17);
  v799 = v428;
  quant_coarse_energy(v819, v367, v366, v43, v365, v363, v822, v428, (uint64_t)v303, v430, v18, (int)v818, v440, (float *)v433 + 22, v441, v772, v773);
  v443 = 8 * *((_DWORD *)v303 + 2);
  v444 = *((_DWORD *)v303 + 6) + __clz(*((_DWORD *)v303 + 8)) - 32;
  if ((_DWORD)v340)
    v445 = 2;
  else
    v445 = 4;
  if (v18)
    v446 = v444 + v445 + 1 > v443;
  else
    v446 = 1;
  v447 = !v446;
  LODWORD(v816) = v447;
  if ((int)v366 <= (int)v367)
  {
    v450 = 0;
    v453 = v824;
    v454 = v813;
  }
  else
  {
    v448 = v443 - v447;
    if ((_DWORD)v340)
      v449 = 4;
    else
      v449 = 5;
    if (v444 + v445 <= v448)
    {
      v452 = v804;
      v455 = v795;
      ec_enc_bit_logp(v303, *(_DWORD *)(v804 + v795), v445);
      v444 = *((_DWORD *)v303 + 6) + __clz(*((_DWORD *)v303 + 8)) - 32;
      v450 = *(_DWORD *)(v452 + v455);
      v453 = v824;
      v451 = v817;
    }
    else
    {
      v450 = 0;
      v451 = v817;
      v452 = v804;
      *(_DWORD *)(v804 + 4 * v817) = 0;
      v453 = v824;
    }
    v454 = v813;
    if ((_DWORD)v366 != (_DWORD)v451 + 1)
    {
      v456 = ~(_DWORD)v451 + v366;
      v457 = (int *)(v452 + 4 * v451 + 4);
      v458 = v450;
      do
      {
        while (v444 + v449 > v448)
        {
          *v457++ = v458;
          if (!--v456)
            goto LABEL_421;
        }
        ec_enc_bit_logp(v303, *v457 ^ v458, v449);
        v454 = v813;
        v453 = v824;
        v444 = *((_DWORD *)v303 + 6) + __clz(*((_DWORD *)v303 + 8)) - 32;
        v459 = *v457++;
        v458 = v459;
        v450 |= v459;
        --v456;
      }
      while (v456);
    }
  }
LABEL_421:
  v460 = (int)v816;
  if ((_DWORD)v816)
  {
    v461 = v814;
    v462 = v797;
    v463 = &tf_select_table[4 * v814 + v450 + v797];
    if (*v463 == v463[2])
    {
      v460 = 0;
    }
    else
    {
      v467 = v779;
      ec_enc_bit_logp(v303, v779, 1);
      v454 = v813;
      v453 = v824;
      v460 = 2 * v467;
    }
    v464 = v828;
    v465 = v817;
    v466 = (int)v822;
    if ((int)v366 > (int)v817)
      goto LABEL_428;
  }
  else
  {
    v464 = v828;
    v465 = v817;
    v462 = v797;
    v461 = v814;
    v466 = (int)v822;
    if ((int)v366 > (int)v817)
    {
LABEL_428:
      v468 = v460 + 4 * v461;
      v469 = v465;
      if (v454 < 2)
        goto LABEL_432;
      v469 = (v454 & 0xFFFFFFFFFFFFFFFELL) + v465;
      v470 = (int *)(v804 + 4 * v465 + 4);
      v471 = v454 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v472 = tf_select_table[v468 + (uint64_t)*v470 + v462];
        *(v470 - 1) = tf_select_table[v468 + (uint64_t)*(v470 - 1) + v462];
        *v470 = v472;
        v470 += 2;
        v471 -= 2;
      }
      while (v471);
      if (v454 != (v454 & 0xFFFFFFFFFFFFFFFELL))
      {
LABEL_432:
        v473 = v453 - v469;
        v474 = (int *)(v804 + 4 * v469);
        do
        {
          *v474 = tf_select_table[*v474 + (uint64_t)v468 + v462];
          ++v474;
          --v473;
        }
        while (v473);
      }
    }
  }
  if ((int)(*((_DWORD *)v303 + 6) + __clz(*((_DWORD *)v303 + 8)) - 28) > v466)
    goto LABEL_440;
  if (*((_DWORD *)v464 + 17))
  {
    *((_DWORD *)v464 + 26) = 0;
    goto LABEL_437;
  }
  if (!(_DWORD)v465)
  {
    v569 = *((_DWORD *)v464 + 7);
    if (!v794 && v569 >= 3 && (int)v818 >= 10 * (int)v823)
    {
      v475 = spreading_decision((uint64_t)v819, v811.i64[0], (int *)v464 + 23, *((_DWORD *)v464 + 21), (int *)v464 + 25, v777, v793, v43, v823, v780, v776);
      *((_DWORD *)v464 + 21) = v475;
      goto LABEL_439;
    }
    if (v569)
    {
LABEL_437:
      v475 = 2;
      goto LABEL_438;
    }
LABEL_524:
    v475 = 0;
    *((_DWORD *)v464 + 21) = 0;
    goto LABEL_439;
  }
  if (!*((_DWORD *)v464 + 7))
    goto LABEL_524;
  if (v461)
    goto LABEL_437;
  v475 = 3;
LABEL_438:
  *((_DWORD *)v464 + 21) = v475;
LABEL_439:
  v454 = (unint64_t)ec_enc_icdf(v303, v475, (uint64_t)&spread_icdf_0, 5);
LABEL_440:
  if (*((_DWORD *)v464 + 17))
  {
    v476 = (int)v809 / 3;
    if ((int)v809 > 26)
      v476 = 8;
    v826->i32[0] = v476;
  }
  MEMORY[0x24BDAC7A8](v454, v442);
  v479 = (int32x4_t *)&v774[-((v478 + 15) & 0x7FFFFFFF0)];
  v480 = v819;
  v481 = v819->i32[2];
  v482 = v824;
  v483 = v823;
  if ((int)v481 >= 1)
  {
    v484 = (unsigned __int16 *)v819[2].i64[0];
    v485 = v819[9].i64[1];
    v486 = *v484;
    if (v481 < 0x10
      || ((v487 = v481 * (v823 - v796), v487 + (int)v481 - 1 >= v487)
        ? (v488 = (unint64_t)(v481 - 1) >> 32 == 0)
        : (v488 = 0),
          !v488))
    {
      v489 = 0;
      goto LABEL_451;
    }
    v489 = 0;
    v551 = (unint64_t)v479 + 4 * v481;
    v552 = v485 + v487;
    v554 = (unint64_t)v479 < v552 + v481 && v552 < v551;
    v555 = (unint64_t)(v484 + 1) >= v551 || v479 >= (int32x4_t *)&v484[v481 + 1];
    if (!v555 || v554)
    {
LABEL_451:
      v490 = v481 * v783;
      v491 = v484 + 1;
      do
      {
        v492 = (__int16)v491[v489];
        v479->i32[v489] = (((v492 - (__int16)v486) << v18) * v483 * (*(unsigned __int8 *)(v485 + v490 + (int)v489) + 64)) >> 2;
        LOWORD(v486) = v492;
        ++v489;
      }
      while (v489 < v481);
    }
    else
    {
      v556 = (int8x16_t)vdupq_n_s16(v486);
      v489 = v481 & 0xFFFFFFFFFFFFFFF0;
      v557 = (uint32x4_t)vdupq_n_s32(v18);
      v558 = (int8x16_t *)(v484 + 1);
      v559 = v481 * v783;
      v560.i64[0] = 0x4000000040;
      v560.i64[1] = 0x4000000040;
      v561 = v481 & 0xFFFFFFFFFFFFFFF0;
      v562 = v479;
      v563 = vdupq_n_s32(v823);
      do
      {
        v564 = (int16x8_t)vextq_s8(v556, *v558, 0xEuLL);
        v556 = v558[1];
        v565 = (int16x8_t)vextq_s8(*v558, v556, 0xEuLL);
        v566 = (uint32x4_t)vsubl_s16(*(int16x4_t *)v558->i8, *(int16x4_t *)v564.i8);
        v567 = (uint32x4_t)vsubl_high_s16(*(int16x8_t *)v558, v564);
        v568 = *(int8x16_t *)(v485 + v559);
        v562[2] = vshrq_n_s32(vmulq_s32((int32x4_t)vshlq_u32((uint32x4_t)vsubl_s16(*(int16x4_t *)v556.i8, *(int16x4_t *)v565.i8), v557), vmulq_s32(v563, vaddq_s32((int32x4_t)vqtbl1q_s8(v568, (int8x16_t)xmmword_208F04F30), v560))), 2uLL);
        v562[3] = vshrq_n_s32(vmulq_s32((int32x4_t)vshlq_u32((uint32x4_t)vsubl_high_s16((int16x8_t)v556, v565), v557), vmulq_s32(v563, vaddq_s32((int32x4_t)vqtbl1q_s8(v568, (int8x16_t)xmmword_208F04F20), v560))), 2uLL);
        *v562 = vshrq_n_s32(vmulq_s32((int32x4_t)vshlq_u32(v566, v557), vmulq_s32(v563, vaddq_s32((int32x4_t)vqtbl1q_s8(v568, (int8x16_t)xmmword_208F04F50), v560))), 2uLL);
        v562[1] = vshrq_n_s32(vmulq_s32((int32x4_t)vshlq_u32(v567, v557), vmulq_s32(v563, vaddq_s32((int32x4_t)vqtbl1q_s8(v568, (int8x16_t)xmmword_208F04F40), v560))), 2uLL);
        v562 += 4;
        v558 += 2;
        v559 += 16;
        v561 -= 16;
      }
      while (v561);
      if (v489 != v481)
      {
        LOWORD(v486) = v556.i16[7];
        goto LABEL_451;
      }
    }
  }
  v493 = 8 * v466;
  v494 = *((_DWORD *)v303 + 8);
  v495 = __clz(v494);
  v496 = ((__PAIR64__(8 * (v495 + *((_DWORD *)v303 + 6)), ec_tell_frac_correction[(v494 >> (16 - v495) >> 12) - 8])
         - __PAIR64__(v494 >> (16 - v495) >> 12, v494 >> (16 - v495))) >> 32)
       - 248;
  v822 = v479;
  v497 = 0;
  if ((int)v366 > (int)v829)
  {
    v498 = 6;
    v499 = v465;
    v500 = v815;
    LODWORD(v809) = 8 * v466;
    do
    {
      v502 = v499 + 1;
      v503 = (((__int16)v500[v499 + 1] - (__int16)v500[v499]) * v483) << v18;
      v504 = 8 * v503;
      if (v503 <= 48)
        v503 = 48;
      if (v504 >= v503)
        v501 = v503;
      else
        v501 = v504;
      if (v496 + 8 * v498 >= v493 - v497 || v479->i32[v499] < 1)
      {
        v501 = 0;
      }
      else
      {
        LODWORD(v818) = v497;
        v505 = v826->i32[v499];
        LODWORD(v816) = v498;
        ec_enc_bit_logp(v303, v505 > 0, v498);
        v506 = *((_DWORD *)v303 + 8);
        v507 = __clz(v506);
        v496 = ((__PAIR64__(8 * (v507 + *((_DWORD *)v303 + 6)), ec_tell_frac_correction[(v506 >> (16 - v507) >> 12) - 8])- __PAIR64__(v506 >> (16 - v507) >> 12, v506 >> (16 - v507))) >> 32)- 248;
        if (v505 >= 1)
        {
          v508 = v501 + (_DWORD)v818;
          v493 = v809;
          v509 = v809 - (v501 + (_DWORD)v818);
          if (v496 + 8 < v509)
          {
            v479 = v822;
            v482 = v824;
            v483 = v823;
            v500 = v815;
            v510 = (int)v816;
            if (v501 < v822->i32[v499])
            {
              v511 = 0;
              v512 = 1;
              while (1)
              {
                v513 = v511;
                v514 = v826->i32[v499];
                v515 = v821;
                ec_enc_bit_logp(v821, v512 < v514, 1);
                v516 = *((_DWORD *)v515 + 8);
                v517 = __clz(v516);
                v496 = ((__PAIR64__(8 * (v517 + *((_DWORD *)v515 + 6)), ec_tell_frac_correction[(v516 >> (16 - v517) >> 12) - 8])- __PAIR64__(v516 >> (16 - v517) >> 12, v516 >> (16 - v517))) >> 32)- 248;
                if (v512 >= v514)
                  break;
                v509 -= v501;
                v479 = v822;
                if (v496 + 8 < v509)
                {
                  v511 = v513 + v501;
                  ++v512;
                  if (v501 + v513 + v501 < v822->i32[v499])
                    continue;
                }
                v501 = v513 + 2 * v501;
                v508 = v501 + (_DWORD)v818;
                v303 = v821;
                v482 = v824;
                v366 = v827;
                v483 = v823;
                v480 = v819;
                v500 = v815;
                goto LABEL_475;
              }
              v501 += v513;
              v508 = v501 + (_DWORD)v818;
              v303 = v821;
              v482 = v824;
              v366 = v827;
              v483 = v823;
              v480 = v819;
              v500 = v815;
              v479 = v822;
LABEL_475:
              v493 = v809;
LABEL_476:
              v510 = (int)v816;
            }
            if (v510 <= 3)
              v510 = 3;
            v498 = v510 - 1;
            v497 = v508;
            v465 = v817;
            goto LABEL_456;
          }
          v482 = v824;
          v483 = v823;
          v500 = v815;
          v479 = v822;
          goto LABEL_476;
        }
        v501 = 0;
        v482 = v824;
        v483 = v823;
        v500 = v815;
        v479 = v822;
        v497 = (int)v818;
        v493 = v809;
        v498 = (int)v816;
      }
LABEL_456:
      v826->i32[v499++] = v501;
    }
    while (v502 != v482);
  }
  v518 = v828;
  v519 = v803;
  v520 = v792;
  v521 = v791;
  if (v483 != 2)
    goto LABEL_577;
  if (!v18)
    goto LABEL_496;
  v522 = 0;
  v523 = (_WORD *)v480[2].i64[0];
  LOWORD(v524) = *v523;
  v525 = v811.i64[0] + 16;
  v526 = 1.0e-15;
  v527 = 1.0e-15;
  while (2)
  {
    v528 = (__int16)v524 << v18;
    v524 = (__int16)v523[++v522];
    v529 = v524 << v18;
    if (v528 < v524 << v18)
    {
      v530 = v528;
      v531 = v529;
      v532 = v529 - v530;
      if (v532 < 8)
      {
        v533 = v530;
        goto LABEL_490;
      }
      v482 = v532 & 0xFFFFFFFFFFFFFFF8;
      v533 = (v532 & 0xFFFFFFFFFFFFFFF8) + v530;
      v477 = (float32x4_t *)(v525 + 4 * v530);
      v534 = (float32x4_t *)(v525 + 4 * (v820 + v530));
      v535 = v532 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        v536 = v477[-1];
        v537 = v534[-1];
        v538 = vaddq_f32(vabsq_f32(v536), vabsq_f32(v537));
        v539 = vaddq_f32(vabsq_f32(*v477), vabsq_f32(*v534));
        v540 = vaddq_f32(vabsq_f32(vaddq_f32(v536, v537)), vabdq_f32(v536, v537));
        v541 = vaddq_f32(vabsq_f32(vaddq_f32(*v477, *v534)), vabdq_f32(*v477, *v534));
        v526 = (float)((float)((float)((float)((float)((float)((float)(v526 + v538.f32[0]) + v538.f32[1]) + v538.f32[2])
                                             + v538.f32[3])
                                     + v539.f32[0])
                             + v539.f32[1])
                     + v539.f32[2])
             + v539.f32[3];
        v527 = (float)((float)((float)((float)((float)((float)((float)(v527 + v540.f32[0]) + v540.f32[1]) + v540.f32[2])
                                             + v540.f32[3])
                                     + v541.f32[0])
                             + v541.f32[1])
                     + v541.f32[2])
             + v541.f32[3];
        v477 += 2;
        v534 += 2;
        v535 -= 8;
      }
      while (v535);
      if (v532 != v482)
      {
LABEL_490:
        v542 = v531 - v533;
        v482 = v811.i64[0];
        v543 = (float *)(v811.i64[0] + 4 * (v820 + v533));
        v544 = (float *)(v811.i64[0] + 4 * v533);
        do
        {
          v545 = *v544++;
          v546 = v545;
          v547 = *v543++;
          v526 = v526 + (float)(fabsf(v546) + fabsf(v547));
          v527 = v527 + (float)(fabsf(v546 + v547) + vabds_f32(v546, v547));
          --v542;
        }
        while (v542);
      }
    }
    if (v522 != 13)
      continue;
    break;
  }
  if (v18 < 2)
    LODWORD(v522) = 5;
  v548 = (__int16)v523[13] << (v18 + 1);
  v837 = (float)((float)(v527 * 0.70711) * (float)(v548 + v522)) > (float)(v526 * (float)v548);
LABEL_496:
  v549 = *((_DWORD *)v828 + 59);
  if ((int)v792 >= 1000)
  {
    if (v792 >= 0x7D0)
    {
      if (v792 >= 0xBB8)
      {
        if (v792 >= 0xFA0)
        {
          if (v792 >> 3 >= 0x271)
          {
            v570 = v792 >> 4;
            if (v792 >> 4 >= 0x177)
            {
              if (v792 >> 3 >= 0x36B)
              {
                v571 = v792 >> 6;
                if (v792 >> 6 >= 0x7D)
                {
                  if (v792 >> 7 >= 0x7D)
                  {
                    if (v571 >= 0x177)
                    {
                      if (v792 >> 5 >= 0x465)
                      {
                        if (v792 >> 5 >= 0x55F)
                        {
                          if (v570 >= 0xC35)
                          {
                            if (v571 >= 0x36B)
                            {
                              if (v570 >= 0xF23)
                              {
                                if (v792 >= 0x105B8)
                                {
                                  if (v571 >= 0x465)
                                  {
                                    if (v792 >= 0x13498)
                                    {
                                      if (v571 >= 0x55F)
                                      {
                                        if (v792 >= 0x19E10)
                                        {
                                          if (v792 > 0x20B6F)
                                            v550 = 21;
                                          else
                                            v550 = 20;
                                        }
                                        else
                                        {
                                          v550 = 19;
                                        }
                                      }
                                      else
                                      {
                                        v550 = 18;
                                      }
                                    }
                                    else
                                    {
                                      v550 = 17;
                                    }
                                  }
                                  else
                                  {
                                    v550 = 16;
                                  }
                                }
                                else
                                {
                                  v550 = 15;
                                }
                              }
                              else
                              {
                                v550 = 14;
                              }
                            }
                            else
                            {
                              v550 = 13;
                            }
                          }
                          else
                          {
                            v550 = 12;
                          }
                        }
                        else
                        {
                          v550 = 11;
                        }
                      }
                      else
                      {
                        v550 = 10;
                      }
                      v518 = v828;
                      v303 = v821;
                      v366 = v827;
                      v465 = v817;
                      v483 = v823;
                      v480 = v819;
                      v519 = v803;
                      v520 = v792;
                      v521 = v791;
                    }
                    else
                    {
                      v550 = 9;
                    }
                  }
                  else
                  {
                    v550 = 8;
                  }
                }
                else
                {
                  v550 = 7;
                }
              }
              else
              {
                v550 = 6;
              }
            }
            else
            {
              v550 = 5;
            }
          }
          else
          {
            v550 = 4;
          }
        }
        else
        {
          v550 = 3;
        }
      }
      else
      {
        v550 = 2;
      }
    }
    else
    {
      v550 = 1;
    }
  }
  else
  {
    v550 = 0;
  }
  v572 = (float)((int)v792 / 1000);
  if (v550 > v549
    && (float)(celt_encode_with_ec_intensity_thresholds[v549] + celt_encode_with_ec_intensity_histeresis[v549]) > v572
    || v550 < v549
    && (float)(celt_encode_with_ec_intensity_thresholds[v549 - 1] - celt_encode_with_ec_intensity_histeresis[v549 - 1]) < v572)
  {
    v550 = *((_DWORD *)v828 + 59);
  }
  if ((int)v465 <= v550)
    v573 = v550;
  else
    v573 = v465;
  if ((int)v366 < v573)
    v573 = v366;
  *((_DWORD *)v518 + 59) = v573;
LABEL_577:
  if (v496 + 48 <= v493 - v497)
  {
    LODWORD(v818) = v497;
    if ((int)v829 > 0 || *((_DWORD *)v518 + 17))
    {
      *((_DWORD *)v518 + 58) = 0;
      v575 = 5;
    }
    else
    {
      v575 = alloc_trim_analysis((uint64_t)v480, v811.i64[0], (float32x4_t *)v800, v366, v18, v483, v820, (uint64_t)v806, v834, v223, (float *)v518 + 58, *((_DWORD *)v518 + 59), v520);
    }
    LODWORD(v816) = v575;
    v482 = (unint64_t)ec_enc_icdf(v303, v575, (uint64_t)&trim_icdf_0, 7);
    v576 = *((_DWORD *)v303 + 8);
    v577 = __clz(v576);
    v496 = ((__PAIR64__(8 * (v577 + *((_DWORD *)v303 + 6)), ec_tell_frac_correction[(v576 >> (16 - v577) >> 12) - 8])
           - __PAIR64__(v576 >> (16 - v577) >> 12, v576 >> (16 - v577))) >> 32)
         - 248;
    v483 = v823;
    v497 = (int)v818;
    if (v519 >= 1)
      goto LABEL_584;
LABEL_579:
    v574 = v810;
  }
  else
  {
    LODWORD(v816) = 5;
    if (v519 < 1)
      goto LABEL_579;
LABEL_584:
    v578 = v480[2].i32[2] - v18;
    v579 = 0x4FBu >> v521;
    if ((int)v810 < (int)(0x4FBu >> v521))
      v579 = v810;
    v580 = v519 - 8 * v782;
    if ((_DWORD)v465)
      v580 = (v519 - 72 * v483 - 32) & ~((v519 - 72 * v483 - 32) >> 31);
    v581 = *((_DWORD *)v518 + 14);
    if (v581)
      v580 += *((int *)v518 + 55) >> v578;
    if ((_DWORD)v829)
    {
      v582 = *((_DWORD *)v518 + 48);
      v583 = v582 <= 100;
      if (v582 >= 100)
        v584 = 0;
      else
        v584 = 0x60u >> v521;
      v585 = v584 + v580;
      v586 = 0x90u >> v521;
      if (v583)
        v586 = 0;
      v587 = v585 - v586 + (int)(float)((float)(v834 + -0.25) * 400.0);
      if (v587 <= 400)
        v588 = 400;
      else
        v588 = v587;
      if (v834 > 0.7)
        v587 = v588;
      v589 = ((v497 + v496 + 63) >> 6) + 2;
      if (v589 <= (v781 + v497 + 359) >> 6)
        v589 = (v781 + v497 + 359) >> 6;
    }
    else
    {
      v590 = *((_DWORD *)v518 + 59);
      v591 = v480[2].i64[0];
      if (*((_DWORD *)v518 + 24))
        v592 = *((_DWORD *)v518 + 24);
      else
        v592 = v480->i32[2];
      v593 = *(__int16 *)(v591 + 2 * v592);
      if (v483 == 2)
      {
        if (v592 >= v590)
          v594 = *((_DWORD *)v518 + 59);
        else
          v594 = v592;
        v593 += *(__int16 *)(v591 + 2 * v594);
      }
      v595 = *((_DWORD *)v518 + 17);
      v596 = v593 << v18;
      v597 = 8 * (v593 << v18);
      v598 = v580;
      if (*v806)
      {
        v599 = *((float *)v518 + 35);
        v598 = v580;
        if (v599 < 0.4)
          v598 = v580 - (int)(float)((float)(0.4 - v599) * (float)v597);
      }
      if (v483 == 2)
      {
        v600 = *((float *)v518 + 58);
        if (v592 < v590)
          v590 = v592;
        v601 = (*(__int16 *)(v591 + 2 * v590) << v18) - v590;
        v602 = v600 + -0.1;
        _NF = v600 < 1.0;
        v603 = 0.9;
        if (_NF)
          v603 = v602;
        v604 = v603 * (float)(8 * v601);
        if ((float)((float)((float)((float)v601 * 0.8) / (float)v596) * (float)v598) < v604)
          v604 = (float)((float)((float)v601 * 0.8) / (float)v596) * (float)v598;
        v598 -= (int)v604;
      }
      v605 = v518[30];
      v606 = v833 + (-19 << v18) + v598 + (int)(float)((float)(v834 + -0.044) * (float)(v833 + (-19 << v18) + v598));
      if (!v595 && *v806)
      {
        v607 = *((float *)v518 + 32) + -0.15;
        if (v607 >= 0.0)
          v608 = v607 + -0.12;
        else
          v608 = -0.12;
        v609 = (int)(float)((float)v597 * 0.8);
        if (!v778)
          v609 = 0;
        v606 += v609 + (int)(float)((float)((float)v597 * 1.2) * v608);
      }
      if (v595)
        v610 = 1;
      else
        v610 = v605 == 0;
      v611 = v610;
      v612 = v606 + (int)(float)(v224 * (float)v597);
      if (v606 / 4 > v612)
        v612 = v606 / 4;
      v613 = (float)(8 * v483 * (*(__int16 *)(v591 + 2 * (v480->i32[2] - 2)) << v18));
      if ((v611 & 1) != 0)
        v614 = v606;
      else
        v614 = v612;
      v615 = (int)(float)(v353 * v613);
      if (v614 >> 2 > v615)
        v615 = v614 >> 2;
      if (v614 >= v615)
        v614 = v615;
      v616 = v611 ^ 1;
      if (!v581)
        v616 = 1;
      if ((v616 & 1) == 0)
        v614 = v580 + (int)(float)((float)(v614 - v580) * 0.67);
      if (v834 < 0.2 && !v605)
      {
        v617 = 96000 - v520;
        if (96000 - v520 >= 32000)
          v617 = 32000;
        v618 = (float)v617 * 0.0000031;
        if (v617 < 0)
          v618 = 0.0;
        v614 += (int)(float)((float)(v618 * v225) * (float)v614);
      }
      v587 = 2 * v580;
      if (v587 >= v614)
        v587 = v614;
      v589 = ((v497 + v496 + 63) >> 6) + 2;
    }
    v619 = v587 + v496;
    v620 = (v619 + 32) >> 6;
    if (v589 > v620)
      v620 = v589;
    if (v579 < v620)
      v620 = v579;
    v621 = v619 - v519;
    v622 = v620 << 6;
    if (v802)
      v623 = v620;
    else
      v623 = 2;
    if (v802)
      v624 = v621;
    else
      v624 = 0;
    if (v802)
      v625 = v622;
    else
      v625 = 128;
    v626 = *((_DWORD *)v518 + 56);
    if (v626 > 969)
    {
      v627 = 0.001;
    }
    else
    {
      *((_DWORD *)v518 + 56) = v626 + 1;
      v627 = 1.0 / (float)(v626 + 21);
    }
    if (v581)
    {
      v628 = *((_DWORD *)v518 + 54);
      v629 = (int)(float)(v627 * (float)((v624 << v578) - (*((_DWORD *)v518 + 55) + v628)));
      v630 = *((_DWORD *)v518 + 53) + v625 - v519;
      *((_DWORD *)v518 + 53) = v630;
      *((_DWORD *)v518 + 54) = v628 + v629;
      *((_DWORD *)v518 + 55) = -(v628 + v629);
      if (v630 < 0)
      {
        v631 = -v630 >> 6;
        if (!v802)
          v631 = 0;
        v623 += v631;
        *((_DWORD *)v518 + 53) = 0;
      }
    }
    if (v579 >= v623)
      v574 = v623;
    else
      v574 = v579;
    v482 = (unint64_t)memmove((void *)(*v303 + v574 - *((unsigned int *)v303 + 3)), (const void *)(*v303 + *((unsigned int *)v303 + 2) - *((unsigned int *)v303 + 3)), *((unsigned int *)v303 + 3));
    *((_DWORD *)v303 + 2) = v574;
  }
  v632 = MEMORY[0x24BDAC7A8](v482, v477);
  v822 = (int32x4_t *)&v774[-((v633 + 15) & 0x7FFFFFFF0)];
  MEMORY[0x24BDAC7A8](v632, v634);
  v637 = MEMORY[0x24BDAC7A8](&v774[-v635], v636);
  v640 = &v774[-v639];
  v641 = 0;
  v643 = __clz(v642);
  v644 = v642 >> (16 - v643);
  v645 = ec_tell_frac_correction[(v644 >> 12) - 8];
  v810 = v574;
  v647 = ((_DWORD)v574 << 6) + ~(((__PAIR64__(8 * (v643 + v646), v645) - __PAIR64__(v644 >> 12, v644)) >> 32) - 248);
  v648 = 0;
  if (v18 < 2)
  {
    v649 = v824;
    v650 = v823;
    v651 = v816;
  }
  else
  {
    v649 = v824;
    v650 = v823;
    v651 = v816;
    if (v814)
    {
      v641 = v647 >= (int)v797 + 16;
      if (v647 < (int)v797 + 16)
        v648 = 0;
      else
        v648 = 8;
    }
  }
  v652 = v647 - v648;
  v653 = *v806;
  LODWORD(v816) = v641;
  LODWORD(v815) = (_DWORD)v574 << 6;
  if (v653)
  {
    if (v520 >= 32000 * v650)
    {
      if (v520 >= 48000 * v650)
      {
        if (v520 >= 60000 * v650)
        {
          if (v520 < 80000 * v650)
            v654 = 19;
          else
            v654 = 20;
        }
        else
        {
          v654 = 18;
        }
      }
      else
      {
        v654 = 16;
      }
    }
    else
    {
      v654 = 13;
    }
    v655 = v828;
    if (*((_DWORD *)v828 + 39) > v654)
      v654 = *((_DWORD *)v828 + 39);
  }
  else
  {
    v654 = v366 - 1;
    v655 = v828;
  }
  if (*((_DWORD *)v655 + 17))
    v654 = 1;
  v771 = *((_DWORD *)v655 + 24);
  v818 = v640;
  v656 = v637;
  v657 = clt_compute_allocation((uint64_t)v819, v465, v649, (uint64_t)v826, v638, v651, (int *)v655 + 59, (uint64_t)&v837, v652, &v836, v637, (uint64_t)v822, (uint64_t)v640, v650, v18, (uint64_t)v303, 1, v771, v654);
  v658 = v657;
  v659 = *((_DWORD *)v655 + 24);
  v660 = v657;
  if (v659)
  {
    v661 = v659 - 1;
    if (v659 - 1 <= v657)
      v661 = v657;
    if (v659 + 1 < v661)
      v660 = v659 + 1;
    else
      v660 = v661;
  }
  LODWORD(v826) = 8 * v810;
  v662 = (int *)v828;
  *((_DWORD *)v828 + 24) = v660;
  v663 = v819;
  v664 = v823;
  v665 = quant_fine_energy((uint64_t)v819, v817, v366, (uint64_t)v808, (uint64_t)v799, (uint64_t)v822, v303, v823);
  MEMORY[0x24BDAC7A8](v665, v666);
  if (v664 == 2)
    v668 = v811.i64[0] + 4 * (int)v820;
  else
    v668 = 0;
  quant_all_bands(1, (uint64_t)v663, v829, v366, v811.i64[0], v668, (uint64_t)&v774[-((v667 + 15) & 0x1FFFFFFF0)], (uint64_t)v145, v656, v794, v662[21], v837, v804, (_DWORD)v815 - v648, v836, (char **)v303, v18, v658, v662 + 20,
    v662[7],
    v662[19]);
  if ((v816 & 1) != 0)
  {
    v669 = v662[30] < 2;
    v670 = *((_DWORD *)v303 + 4);
    v671 = *((_DWORD *)v303 + 5);
    v672 = v671 + 1;
    if ((v671 + 1) < 0x21)
    {
      v683 = *((_DWORD *)v303 + 5);
      v673 = v823;
      v674 = v819;
      v675 = v808;
      v676 = v805;
      v677 = v801;
      v678 = (uint64_t)v818;
      v679 = (int)v826;
    }
    else
    {
      v673 = v823;
      v674 = v819;
      v675 = v808;
      v676 = v805;
      v677 = v801;
      v678 = (uint64_t)v818;
      v679 = (int)v826;
      do
      {
        v685 = *((_DWORD *)v303 + 2);
        v684 = *((_DWORD *)v303 + 3);
        if (v684 + *((_DWORD *)v303 + 7) < v685)
        {
          v680 = 0;
          v681 = *v303;
          v682 = v684 + 1;
          *((_DWORD *)v303 + 3) = v682;
          *(_BYTE *)(v681 + v685 - v682) = v670;
        }
        else
        {
          v680 = -1;
        }
        *((_DWORD *)v303 + 12) |= v680;
        v670 >>= 8;
        v683 = v671 - 8;
        v446 = v671 <= 15;
        v671 -= 8;
      }
      while (!v446);
      v672 = v683 + 1;
    }
    *((_DWORD *)v303 + 4) = (v669 << v683) | v670;
    *((_DWORD *)v303 + 5) = v672;
    v686 = *((_DWORD *)v303 + 6) + 1;
    *((_DWORD *)v303 + 6) = v686;
  }
  else
  {
    v686 = *((_DWORD *)v303 + 6);
    v673 = v823;
    v674 = v819;
    v675 = v808;
    v676 = v805;
    v677 = v801;
    v678 = (uint64_t)v818;
    v679 = (int)v826;
  }
  v687 = v817;
  v688 = v799;
  quant_energy_finalise((uint64_t)v674, v817, v366, (uint64_t)v675, (uint64_t)v799, (uint64_t)v822, v678, v679 - v686 - __clz(*((_DWORD *)v303 + 8)) + 32, v303, v673);
  v689 = 4 * v676;
  bzero(v789, 4 * v676);
  v690 = v688;
  v691 = 0;
  v692 = 0;
  v693 = v813;
  v694 = v813 & 0xFFFFFFFFFFFFFFF8;
  v695 = (uint64_t)&v688[v795 + 16];
  v696 = v812;
  v697 = 4 * v812;
  v698 = &v662[3 * (int)v676 + v677];
  v699 = (uint64_t)v698 + v795 + 268;
  v700 = v698 + 63;
  v701.i64[0] = 0x3F0000003F000000;
  v701.i64[1] = 0x3F0000003F000000;
  v702.i64[0] = 0xBF000000BF000000;
  v702.i64[1] = 0xBF000000BF000000;
  v703 = v824;
  v704 = v785;
  do
  {
    if ((int)v366 > (int)v687)
    {
      v705 = v687;
      if (v693 < 8)
        goto LABEL_733;
      v706 = (int8x16_t *)v699;
      v707 = (float32x4_t *)v695;
      v708 = v693 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        v709 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v707[-1], v701), (int8x16_t)v701, (int8x16_t)v707[-1]);
        v710 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*v707, v701), (int8x16_t)v701, *(int8x16_t *)v707);
        v706[-1] = vbslq_s8((int8x16_t)vcgtq_f32(v702, v709), (int8x16_t)v702, (int8x16_t)v709);
        *v706 = vbslq_s8((int8x16_t)vcgtq_f32(v702, v710), (int8x16_t)v702, (int8x16_t)v710);
        v707 += 2;
        v706 += 2;
        v708 -= 8;
      }
      while (v708);
      v705 = (v693 & 0xFFFFFFFFFFFFFFF8) + v687;
      if (v693 != v694)
      {
LABEL_733:
        v711 = v703 - v705;
        v712 = v705 + v691;
        v713 = (float *)&v700[v712];
        v714 = (float *)&v690[v712 * 4];
        do
        {
          v715 = *v714++;
          v716 = v715;
          if (v715 > 0.5)
            v716 = 0.5;
          if (v716 < -0.5)
            v716 = -0.5;
          *v713++ = v716;
          --v711;
        }
        while (v711);
      }
    }
    ++v692;
    v695 += v697;
    v699 += v697;
    v691 += v696;
  }
  while (v692 != v704);
  v717 = v802;
  if ((int)v807 < 1)
    v717 = 1;
  if ((v717 & 1) == 0)
  {
    memset_pattern16(v675, &unk_208F31A80, 4 * v807);
    v703 = v824;
    v696 = v812;
  }
  v662[27] = v839;
  *((float *)v662 + 28) = v109;
  v662[29] = v788;
  if (v787)
  {
    memcpy(&v675[v697 / 4], v675, v697);
    v703 = v824;
    v696 = v812;
  }
  if (v814)
  {
    if ((int)v676 >= 1)
    {
      if (v676 >= 0xC
        && (v831 >= (char *)&v662[v677 + 63 + v676]
         || v675 >= (float *)&v662[v677 + 63 + v676 + v676]))
      {
        v718 = v676 & 0x7FFFFFF8;
        v767 = (float32x4_t *)&v662[v677 + 67];
        v768 = v676 & 0xFFFFFFF8;
        do
        {
          v769 = (int8x16_t *)((char *)v767 + v689);
          v770 = vbslq_s8((int8x16_t)vcgtq_f32(*v767, *(float32x4_t *)((char *)v767 + 4 * v676)), *(int8x16_t *)((char *)v767 + 4 * v676), *(int8x16_t *)v767);
          v769[-1] = vbslq_s8((int8x16_t)vcgtq_f32(v767[-1], *(float32x4_t *)((char *)v767 + v689 - 16)), *(int8x16_t *)((char *)&v767[-1] + v689), (int8x16_t)v767[-1]);
          *v769 = v770;
          v767 += 2;
          v768 -= 8;
        }
        while (v768);
        if (v718 != v676)
          goto LABEL_752;
      }
      else
      {
        v718 = 0;
LABEL_752:
        v719 = v676 - v718;
        v720 = (float *)&v662[v718 + 63 + v677];
        do
        {
          v721 = v720[v676];
          if (v721 >= *v720)
            v721 = *v720;
          v720[v676] = v721;
          ++v720;
          --v719;
        }
        while (v719);
      }
    }
  }
  else
  {
    v722 = v831;
    memcpy(v830, v831, 4 * v676);
    memcpy(v722, v675, 4 * v676);
    v703 = v824;
    v696 = v812;
  }
  v723 = 0;
  v724 = 0;
  v725 = 2 * v676;
  v726 = (uint64_t)&v662[2 * v676 + 63 + v677];
  v727 = v726 + v786;
  v728 = (uint64_t)&v662[(unint64_t)v786 / 4 + 63 + v677];
  v729 = v696 - v703;
  v730 = &v662[v677];
  v731 = v730 + 63;
  v732 = (uint64_t)&v662[(unint64_t)v689 / 4 + 63 + v677];
  v733 = v829 & 0xFFFFFFF8;
  v734 = (v696 - v703) & 0xFFFFFFFFFFFFFFF8;
  v735 = v730 + 67;
  v736 = &v730[(unint64_t)v786 / 4 + 67];
  __asm { FMOV            V1.4S, #-28.0 }
  while (2)
  {
    v738 = v697 * v724;
    if ((int)v829 >= 1)
    {
      if (v829 < 0xC)
      {
        v739 = 0;
        goto LABEL_769;
      }
      v739 = 0;
      if ((unint64_t)(v726 - (_QWORD)v731) < 0x20)
        goto LABEL_769;
      if ((unint64_t)(v732 - (_QWORD)v731) < 0x20)
        goto LABEL_769;
      if ((unint64_t)(v732 - v726) < 0x20)
        goto LABEL_769;
      v740 = v735;
      v741 = v733;
      do
      {
        *(v740 - 1) = 0uLL;
        *v740 = 0uLL;
        v742 = (_OWORD *)((char *)v740 + v725 * 4);
        *(v742 - 1) = _Q1;
        *v742 = _Q1;
        v743 = (_OWORD *)((char *)v740 + v689);
        *(v743 - 1) = _Q1;
        *v743 = _Q1;
        v740 += 2;
        v741 -= 8;
      }
      while (v741);
      v739 = v733;
      if (v733 != v829)
      {
LABEL_769:
        v744 = 0;
        v745 = v829 - v739;
        v746 = &v831[4 * v739];
        v747 = &v830[4 * v739];
        v748 = &v730[v739 + v723];
        do
        {
          v749 = 4 * v744;
          v748[v744 + 63] = 0;
          *(_DWORD *)&v747[v749] = -1042284544;
          *(_DWORD *)&v746[v749] = -1042284544;
          ++v744;
        }
        while (v745 != v744);
      }
    }
    v750 = v828;
    if ((int)v827 < (int)v696)
    {
      v751 = v703;
      if (v729 < 0xC)
        goto LABEL_779;
      v752 = v727 + v738;
      v753 = v728 + v738;
      v751 = v703;
      if ((unint64_t)(v727 - v728) < 0x20)
        goto LABEL_779;
      v754 = v728 + v689 + v738;
      v751 = v703;
      if (v754 - v753 < 0x20)
        goto LABEL_779;
      v751 = v703;
      if (v754 - v752 < 0x20)
        goto LABEL_779;
      v755 = v736;
      v756 = (v696 - v703) & 0xFFFFFFFFFFFFFFF8;
      do
      {
        *((_OWORD *)v755 - 1) = 0uLL;
        *(_OWORD *)v755 = 0uLL;
        v757 = &v755[v725];
        *((_OWORD *)v757 - 1) = _Q1;
        *(_OWORD *)v757 = _Q1;
        v758 = &v755[(unint64_t)v689 / 4];
        *((_OWORD *)v758 - 1) = _Q1;
        *(_OWORD *)v758 = _Q1;
        v755 += 8;
        v756 -= 8;
      }
      while (v756);
      v751 = v734 + v703;
      if (v729 != v734)
      {
LABEL_779:
        v759 = 0;
        v760 = v696 - v751;
        v761 = &v831[4 * v751];
        v762 = &v830[4 * v751];
        v763 = &v730[v751 + v723];
        do
        {
          v764 = 4 * v759;
          v763[v759 + 63] = 0;
          *(_DWORD *)&v762[v764] = -1042284544;
          *(_DWORD *)&v761[v764] = -1042284544;
          ++v759;
        }
        while (v760 != v759);
      }
    }
    ++v724;
    v735 = (_OWORD *)((char *)v735 + v697);
    v831 += v697;
    v830 += v697;
    v723 += v696;
    v736 = (int *)((char *)v736 + v697);
    if (v724 != v825)
      continue;
    break;
  }
  if (((v814 == 0) & ~v784) != 0)
    v765 = 0;
  else
    v765 = *((_DWORD *)v750 + 30) + 1;
  v766 = v821;
  *((_DWORD *)v750 + 30) = v765;
  *((_DWORD *)v750 + 20) = *((_DWORD *)v766 + 8);
  ec_enc_done(v766);
  if (*((_DWORD *)v766 + 12))
    return 4294967293;
  else
    return v810;
}

uint64_t run_prefilter(uint64_t *a1, char *a2, char *a3, uint64_t a4, int a5, int a6, _DWORD *a7, float *a8, _DWORD *a9, int a10, int a11, float *a12)
{
  char *v13;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  size_t v28;
  float *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  float32x4_t *v34;
  int v35;
  uint64_t v36;
  float v37;
  float v38;
  int v39;
  float *v40;
  int v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  int v47;
  int v48;
  unint64_t v49;
  char *v50;
  size_t v51;
  void *v52;
  float *v53;
  size_t v54;
  uint64_t v55;
  int v56;
  int8x16_t v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double v62;
  int8x16_t v63;
  int v64;
  float32x4_t *v65;
  int v66;
  uint64_t v67;
  _DWORD *v68;
  uint64_t v70;
  int v71;
  _DWORD *v72;
  uint64_t *v73;
  float *v74;
  _DWORD *v75;
  uint64_t v76;
  float *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  float *v88[4];

  v74 = a8;
  v75 = a7;
  v82 = a6;
  v13 = a2;
  v73 = &v70;
  v77 = a12;
  LODWORD(v78) = a11;
  LODWORD(v76) = a10;
  v72 = a9;
  v88[2] = *(float **)MEMORY[0x24BDAC8D0];
  v87 = 0;
  v85 = *a1;
  v83 = a5;
  MEMORY[0x24BDAC7A8](a1, a2);
  v20 = 0;
  v70 = v21;
  v88[0] = (float *)((char *)&v70 - v22);
  v88[1] = (float *)((char *)&v70 + 4 * v21 - v22);
  v84 = v18;
  v23 = 4 * (int)v18;
  v79 = (int)v19 + (int)v18;
  v71 = v17;
  if (v17 <= 1)
    v24 = 1;
  else
    v24 = v17;
  v80 = v24;
  v81 = v16;
  v25 = 8 * v24;
  v26 = 4 * ((int)v19 + (int)v18);
  v86 = v19;
  v27 = (char *)(v15 + 4 * v19);
  do
  {
    v28 = v23;
    v29 = v88[v20 / 8];
    memcpy(v29, a3, 0x1000uLL);
    v30 = v29 + 1024;
    v23 = v28;
    v31 = memcpy(v30, v27, v28);
    v20 += 8;
    v27 += v26;
    a3 += 4096;
  }
  while (v25 != v20);
  if ((_DWORD)v76)
  {
    MEMORY[0x24BDAC7A8](v31, v32);
    v34 = (float32x4_t *)((char *)&v70 - v33);
    pitch_downsample(v88, (char *)&v70 - v33, v35, v71);
    v36 = v84;
    pitch_search(v34 + 128, v34, v84, 979, &v87);
    v87 = 1024 - v87;
    remove_doubling((uint64_t)v34, 1024, 15, v36, (uint64_t)&v87);
    if (v87 >= 1023)
      v87 = 1022;
    v38 = v37 * 0.7;
    v39 = *((_DWORD *)a1 + 15);
    if (v39 > 2)
      v38 = v38 * 0.5;
    if (v39 > 4)
      v38 = v38 * 0.5;
    if (v39 > 8)
      v38 = 0.0;
    v40 = v77;
    if (*(_DWORD *)v77)
      goto LABEL_16;
  }
  else
  {
    v87 = 15;
    v38 = 0.0;
    v40 = v77;
    if (*(_DWORD *)v77)
LABEL_16:
      v38 = v38 * v40[10];
  }
  v41 = v87 - *((_DWORD *)a1 + 27);
  if (v41 < 0)
    v41 = *((_DWORD *)a1 + 27) - v87;
  if (10 * v41 <= v87)
    v42 = 0.2;
  else
    v42 = 0.4;
  if ((int)v78 < 25)
    v42 = v42 + 0.1;
  v43 = v42 + 0.1;
  if ((int)v78 >= 35)
    v43 = v42;
  v44 = *((float *)a1 + 28);
  if (v44 <= 0.4)
    v45 = v43;
  else
    v45 = v43 + -0.1;
  if (v44 > 0.55)
    v45 = v45 + -0.1;
  if (v38 >= fmaxf(v45, 0.2))
  {
    if (vabds_f32(v38, v44) < 0.1)
      v38 = *((float *)a1 + 28);
    v47 = vcvtms_s32_f32((float)((float)(v38 * 32.0) / 3.0) + 0.5);
    if (v47 >= 8)
      v47 = 8;
    if (v47 <= 1)
      v47 = 1;
    v71 = v47 - 1;
    v46 = (float)v47 * 0.09375;
    LODWORD(v70) = 1;
  }
  else
  {
    LODWORD(v70) = 0;
    v71 = 0;
    v46 = 0.0;
  }
  v48 = 0;
  v49 = 0;
  v50 = (char *)a1 + 252;
  v51 = 4 * v86;
  v76 = -v83;
  v77 = (float *)(4 * (1024 - v84));
  v79 *= 4;
  v80 *= 8;
  v78 = 4 * v83;
  do
  {
    v55 = *(int *)(v85 + 48);
    v56 = *((_DWORD *)a1 + 27);
    if (v56 <= 15)
      v56 = 15;
    *((_DWORD *)a1 + 27) = v56;
    memcpy(v13, v50, v51);
    v64 = v55 - v86;
    if ((_DWORD)v55 != (_DWORD)v86)
    {
      *(float *)v57.i32 = -*((float *)a1 + 28);
      comb_filter((float32x4_t *)&v13[v51], (float32x4_t *)v88[v49 / 8] + 256, *((_DWORD *)a1 + 27), *((_DWORD *)a1 + 27), v55 - v86, *((_DWORD *)a1 + 29), *((_DWORD *)a1 + 29), 0, v57, *(float *)v57.i32, v58, v59, v60, v61, v62, v63, 0);
    }
    v65 = (float32x4_t *)&v13[4 * v55];
    v66 = v84;
    *(float *)v57.i32 = -*((float *)a1 + 28);
    comb_filter(v65, (float32x4_t *)&v88[v49 / 8][v64 + 1024], *((_DWORD *)a1 + 27), v87, v84 - v64, *((_DWORD *)a1 + 29), v82, *(_OWORD **)(v85 + 72), v57, -v46, v58, v59, v60, v61, v62, v63, v86);
    memcpy(v50, &v13[v78], v51);
    v67 = v81 + 4 * (v48 & 0xFFFFFC00);
    if (v66 < 1025)
    {
      memmove((void *)(v81 + 4 * (v48 & 0xFFFFFC00)), (const void *)(v67 + 4 * v83), (size_t)v77);
      v52 = (void *)(v67 + 4 * v76 + 4096);
      v53 = v88[v49 / 8] + 1024;
      v54 = v28;
    }
    else
    {
      v53 = &v88[v49 / 8][v83];
      v52 = (void *)(v81 + 4 * (v48 & 0xFFFFFC00));
      v54 = 4096;
    }
    memcpy(v52, v53, v54);
    v49 += 8;
    v48 += 1024;
    v50 += v51;
    v13 += v79;
  }
  while (v80 != v49);
  v68 = v75;
  *v74 = v46;
  *v68 = v87;
  *v72 = v71;
  return v70;
}

float transient_analysis()
{
  uint64_t v0;
  int v1;
  int v2;
  float *v3;
  _DWORD *v4;
  int v5;
  _DWORD *v6;
  uint64_t v7;
  float *v8;
  float v9;
  int v10;
  uint64_t v11;
  int v12;
  float v13;
  float v14;
  float v15;
  BOOL v16;
  float v17;
  double v18;
  float result;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float *v33;
  float *v34;
  uint64_t v35;
  float v36;
  float v37;
  float v38;
  uint64_t v39;
  float v40;
  uint64_t v41;
  float v42;
  float v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  float *v49;
  float v50;
  float v51;
  float v52;
  float v53;
  uint64_t v54;
  uint64_t v55;
  float v56;
  uint64_t v57;
  _DWORD *v58;
  float *v59;
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  v0 = MEMORY[0x24BDAC7A8]();
  v8 = (float *)((char *)&v58 - v7);
  *v6 = 0;
  v9 = 0.0625;
  if (v5)
    v9 = 0.03125;
  if (v2 < 1)
    goto LABEL_12;
  if (v1 >= 0)
    v10 = v1;
  else
    v10 = v1 + 1;
  v11 = v2;
  if (v1 <= 0)
  {
    do
    {
      *((_OWORD *)v8 + 1) = 0uLL;
      *((_OWORD *)v8 + 2) = 0uLL;
      *(_OWORD *)v8 = 0uLL;
      --v11;
    }
    while (v11);
    goto LABEL_12;
  }
  if (v1 == 1)
  {
    do
    {
      *((_OWORD *)v8 + 1) = 0uLL;
      *((_OWORD *)v8 + 2) = 0uLL;
      *(_OWORD *)v8 = 0uLL;
      --v11;
    }
    while (v11);
LABEL_12:
    v12 = 0;
    goto LABEL_13;
  }
  v58 = v6;
  v59 = v3;
  v20 = 0;
  v12 = 0;
  v21 = (v10 >> 1);
  v22 = 6 * v21 - 102;
  v23 = (int)v21 - 5;
  v24 = 16;
  if (v23 > 16)
    v24 = (int)v21 - 5;
  v25 = v24 - 13;
  v26 = (v25 >> 2) + 1;
  v60 = 4 * (v26 & 0x7FFFFFFFFFFFFFFELL) + 12;
  do
  {
    v27 = 0;
    v28 = 0.0;
    v29 = 0.0;
    do
    {
      v30 = *(float *)(v0 + v27 * 4);
      v31 = v28 + v30;
      v28 = (float)(v29 + (float)(v28 + v30)) + (float)(v30 * -2.0);
      v29 = v30 + (float)(v31 * -0.5);
      v8[v27++] = v31;
    }
    while (v1 != v27);
    *((_OWORD *)v8 + 1) = 0uLL;
    *((_OWORD *)v8 + 2) = 0uLL;
    v32 = 0.0;
    v33 = v8 + 1;
    v34 = v8;
    v35 = v21;
    v36 = 0.0;
    *(_OWORD *)v8 = 0uLL;
    do
    {
      v37 = (float)(*v33 * *v33) + (float)(*(v33 - 1) * *(v33 - 1));
      v36 = v36 + v37;
      v32 = v32 + (float)(v9 * (float)(v37 - v32));
      *v34++ = v32;
      v33 += 2;
      --v35;
    }
    while (v35);
    v38 = 0.0;
    v39 = v21 + 1;
    v40 = 0.0;
    do
    {
      v41 = (v39 - 2);
      v38 = v38 + (float)((float)(v8[v41] - v38) * 0.125);
      v8[v41] = v38;
      if (v40 <= v38)
        v40 = v38;
      --v39;
    }
    while (v39 > 1);
    if (v1 < 36)
    {
      v44 = 0;
      goto LABEL_53;
    }
    v42 = sqrt((float)(v36 * v40) * 0.5 * (double)(int)v21);
    v43 = (float)((float)(int)v21 / (float)(v42 + 1.0e-15)) * 64.0;
    if (v25 < 4)
    {
      v44 = 0;
      v45 = 12;
      do
      {
LABEL_48:
        v56 = floorf(v43 * (float)(v8[v45] + 1.0e-15));
        if (v56 >= 127.0)
          v56 = 127.0;
        v57 = (int)v56;
        if (v56 < 0.0)
          v57 = 0;
        v44 += transient_analysis_inv_table[v57];
        v45 += 4;
      }
      while (v45 < v23);
      goto LABEL_53;
    }
    v46 = 0;
    v47 = 0;
    v48 = v26 & 0x7FFFFFFFFFFFFFFELL;
    v49 = v8 + 16;
    do
    {
      v50 = *(v49 - 4);
      v51 = *v49;
      v49 += 8;
      v52 = floorf(v43 * (float)(v50 + 1.0e-15));
      v53 = floorf(v43 * (float)(v51 + 1.0e-15));
      if (v52 >= 127.0)
        v52 = 127.0;
      if (v53 >= 127.0)
        v53 = 127.0;
      v54 = (int)v52;
      v55 = (int)v53;
      if (v52 < 0.0)
        v54 = 0;
      if (v53 < 0.0)
        v55 = 0;
      v46 += transient_analysis_inv_table[v54];
      v47 += transient_analysis_inv_table[v55];
      v48 -= 2;
    }
    while (v48);
    v44 = v47 + v46;
    v45 = v60;
    if (v26 != (v26 & 0x7FFFFFFFFFFFFFFELL))
      goto LABEL_48;
LABEL_53:
    if ((v44 << 8) / v22 > v12)
    {
      *v4 = v20;
      v12 = (v44 << 8) / v22;
    }
    ++v20;
    v0 += 4 * v1;
  }
  while (v20 != v2);
  if (v5)
  {
    v3 = v59;
    if (v12 >= 201 && v12 <= 599)
      *v58 = 1;
  }
  else
  {
    v3 = v59;
  }
LABEL_13:
  v13 = sqrt((double)(27 * v12));
  v14 = v13 + -42.0;
  if (v14 < 0.0)
    v14 = 0.0;
  v15 = v14 * 0.0069;
  v16 = v14 <= 163.0;
  v17 = 1.1247;
  if (v16)
    v17 = v15;
  v18 = v17 + -0.139;
  if (v18 < 0.0)
    v18 = 0.0;
  result = sqrt(v18);
  *v3 = result;
  return result;
}

void compute_mdcts(uint64_t a1, int a2, uint64_t a3, float32x4_t *a4, int a5, int a6, int a7, int a8)
{
  uint64_t v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  float *v21;
  uint64_t v22;
  uint64_t v23;
  float32x4_t v24;
  uint64_t v25;
  float32x4_t *v26;
  float32x4_t v27;
  uint64_t v28;
  float *v29;
  float *v30;
  float v31;
  uint64_t v32;
  size_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  float32x4_t *v40;
  uint64_t v41;
  float32x4_t v42;
  uint64_t v43;
  float *v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  float v54;

  v10 = *(unsigned int *)(a1 + 4);
  v11 = *(_DWORD *)(a1 + 48);
  if (a2)
  {
    v12 = v11 * a2;
    if (a2 < 1)
      goto LABEL_13;
    v46 = a5;
    v47 = a8;
    v13 = v11 * a2;
    v14 = *(_DWORD *)(a1 + 40);
  }
  else
  {
    v46 = a5;
    v47 = a8;
    v13 = v11 << a7;
    v14 = *(_DWORD *)(a1 + 40) - a7;
    a2 = 1;
    v11 <<= a7;
  }
  v15 = 0;
  v16 = 0;
  v50 = v13;
  v17 = v13 + v10;
  v45 = a6;
  if (a6 <= 1)
    v18 = 1;
  else
    v18 = a6;
  v48 = 4 * v17;
  v49 = v18;
  v19 = 4 * v11;
  v20 = a2;
  do
  {
    v51 = v16;
    v52 = v15;
    v21 = &a4->f32[v15];
    v53 = a3;
    v22 = v20;
    do
    {
      clt_mdct_forward_c(a1 + 80, a3, v21++, *(_QWORD *)(a1 + 72), v10, v14, v20);
      a3 += v19;
      --v22;
    }
    while (v22);
    v16 = v51 + 1;
    v15 = v52 + v50;
    a3 = v53 + v48;
  }
  while (v51 + 1 != v49);
  v12 = v50;
  a5 = v46;
  a8 = v47;
  a6 = v45;
LABEL_13:
  if (a5 == 1 && a6 == 2 && (int)v12 >= 1)
  {
    if (v12 < 8)
    {
      v23 = 0;
LABEL_21:
      v28 = v12 - v23;
      v29 = &a4->f32[v23 + v12];
      v30 = &a4->f32[v23];
      do
      {
        v31 = *v29++;
        *v30 = (float)(v31 * 0.5) + (float)(*v30 * 0.5);
        ++v30;
        --v28;
      }
      while (v28);
      goto LABEL_23;
    }
    v23 = v12 & 0xFFFFFFF8;
    v24.i64[0] = 0x3F0000003F000000;
    v24.i64[1] = 0x3F0000003F000000;
    v25 = v23;
    v26 = a4;
    do
    {
      v27 = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)v26 + 4 * v12 + 16), v24), v24, v26[1]);
      *v26 = vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)v26 + 4 * v12), v24), v24, *v26);
      v26[1] = v27;
      v26 += 2;
      v25 -= 8;
    }
    while (v25);
    if (v23 != v12)
      goto LABEL_21;
  }
LABEL_23:
  if (a8 != 1)
  {
    v32 = ((int)v12 / a8);
    v33 = 4 * (int)(v12 - v32);
    if (a5 <= 1)
      v34 = 1;
    else
      v34 = a5;
    if ((int)v32 > 0)
    {
      v35 = 0;
      v36 = 0;
      v37 = (float)a8;
      v54 = (float)a8;
      while (1)
      {
        v38 = v35;
        if (v32 >= 8)
        {
          v40 = (float32x4_t *)((char *)a4 + 4 * v35 + 16);
          v41 = v32 & 0xFFFFFFF8;
          do
          {
            v42 = vmulq_n_f32(*v40, v37);
            v40[-1] = vmulq_n_f32(v40[-1], v37);
            *v40 = v42;
            v40 += 2;
            v41 -= 8;
          }
          while (v41);
          v39 = v32 & 0x7FFFFFF8;
          if ((v32 & 0xFFFFFFF8) == v32)
            goto LABEL_29;
        }
        else
        {
          v39 = 0;
        }
        v43 = v32 - v39;
        v44 = &a4->f32[v39 + v38];
        do
        {
          *v44 = *v44 * v37;
          ++v44;
          --v43;
        }
        while (v43);
LABEL_29:
        bzero(&a4->f32[(int)(v12 * v36 + v32)], v33);
        v37 = v54;
        ++v36;
        v35 = v38 + v12;
        if (v36 == v34)
          return;
      }
    }
    do
    {
      bzero(&a4->f32[(int)v32], v33);
      LODWORD(v32) = v32 + v12;
      --v34;
    }
    while (v34);
  }
}

float dynalloc_analysis(float *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, int a8, int16x4_t *a9, int a10, int a11, int a12, uint64_t a13, int a14, int a15, int *a16, int a17, uint64_t a18, _DWORD *a19, uint64_t a20,int8x16_t *a21)
{
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  float32x4_t *v32;
  int v33;
  float64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  int32x2_t v38;
  int32x4_t v39;
  uint64_t v40;
  uint64_t v41;
  float *v42;
  uint64_t v43;
  uint64_t v44;
  float *v45;
  uint64_t v46;
  uint64_t v47;
  float32x4_t *v48;
  float v49;
  int32x2_t v50;
  float32x4_t v51;
  int8x16_t v52;
  float *v53;
  float v54;
  uint64_t v55;
  unsigned int v56;
  uint64_t v57;
  float v58;
  int *v59;
  int v60;
  int v61;
  float32x4_t v62;
  int16x4_t *v63;
  float32x4_t *v64;
  float32x4_t *v65;
  float32x4_t v66;
  int32x4_t v67;
  int32x4_t v68;
  float32x4_t v69;
  int32x4_t v70;
  uint64_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int32x4_t v75;
  int32x4_t v76;
  float32x4_t v77;
  uint64_t v78;
  uint64_t v79;
  float *v80;
  float *v81;
  float *v82;
  uint64_t v83;
  float v84;
  float v85;
  float v86;
  float v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  float32x4_t *v91;
  uint64_t v92;
  uint64_t v93;
  float32x4_t *v94;
  float32x4_t *v95;
  float32x4_t *v96;
  uint64_t v97;
  float32x4_t v98;
  uint64_t v99;
  uint64_t v100;
  float *v101;
  float *v102;
  float *v103;
  float v104;
  float v105;
  float v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  int8x16_t *v110;
  float32x4_t v111;
  float32x4_t v112;
  int8x16_t v113;
  __int8 *v114;
  float v115;
  float v116;
  uint64_t v117;
  float32x4_t v118;
  float32x4_t *v119;
  float32x4_t *v120;
  int8x16_t *v121;
  float32x4_t v122;
  int8x16_t v123;
  uint64_t v124;
  int32x4_t v125;
  int32x4_t v126;
  uint64_t v127;
  uint64_t v128;
  int *v129;
  float *v130;
  float *v131;
  float v132;
  float v133;
  float v134;
  float v135;
  int v136;
  int v137;
  unsigned int v138;
  int v139;
  uint64_t v140;
  uint64_t v141;
  int v142;
  uint64_t v143;
  char *v144;
  char *v145;
  float32x4_t *v146;
  float64_t v147;
  uint64_t v148;
  int v149;
  uint64_t v154;
  char *v155;
  uint64_t v156;
  int v157;
  uint64_t v158;
  float32x2_t *v159;
  uint64_t v160;
  uint64_t v161;
  float v162;
  uint64_t v163;
  float *v164;
  float v165;
  float v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  int64_t v171;
  float *v172;
  float v173;
  float *v174;
  float v175;
  float v176;
  float v177;
  float v178;
  float v179;
  float v180;
  float v181;
  BOOL v182;
  float v183;
  float v184;
  float v185;
  float v186;
  float v187;
  float v188;
  float v189;
  float v190;
  float v191;
  float v192;
  unint64_t v193;
  uint64_t v194;
  float32x4_t *v195;
  uint64_t v196;
  float32x4_t v197;
  float32x4_t v198;
  int8x16_t v199;
  int8x16_t v200;
  float32x4_t v201;
  float32x4_t v202;
  float32x4_t v203;
  int8x16_t v204;
  float32x4_t v205;
  int8x16_t v206;
  int8x16_t v207;
  float32x4_t v208;
  float32x4_t v209;
  float32x4_t v210;
  int8x16_t v211;
  int8x16_t v212;
  int8x16_t v213;
  int8x16_t v214;
  int8x16_t v215;
  int8x16_t v216;
  int8x16_t v217;
  int8x16_t v218;
  int8x16_t v219;
  int8x16_t v220;
  int8x16_t v221;
  int8x16_t v222;
  int8x16_t v223;
  float v224;
  float v225;
  float v226;
  float v227;
  float32x2_t v228;
  float *v229;
  float v230;
  float v231;
  float v232;
  float v233;
  float v234;
  uint64_t v235;
  unint64_t v236;
  int8x16_t *v237;
  int8x16_t v238;
  float v239;
  int *v240;
  int v241;
  int v242;
  unsigned int v243;
  uint64_t v244;
  char *v245;
  uint64_t v246;
  float *v247;
  unint64_t v248;
  unint64_t v249;
  uint64_t v250;
  char *v251;
  float32x4_t v253;
  unint64_t v254;
  float32x4_t v255;
  float32x4_t v256;
  float32x4_t v257;
  float32x4_t v258;
  float32x4_t v259;
  float32x4_t v260;
  uint64_t v261;
  uint64_t v262;
  char *v263;
  float v264;
  float v265;
  float v266;
  float v267;
  float *v268;
  unint64_t v269;
  unint64_t v270;
  uint64_t v271;
  float32x4_t *v272;
  float32x4_t *v273;
  unint64_t v274;
  float32x4_t v275;
  float32x4_t v276;
  uint64_t v277;
  uint64_t v278;
  float *v279;
  float *v280;
  float v281;
  float v282;
  unint64_t v283;
  unint64_t v284;
  unint64_t v285;
  uint64_t v286;
  uint64_t v287;
  float32x4_t *v288;
  float32x4_t *v289;
  unint64_t v290;
  int8x16_t v291;
  uint64_t v292;
  uint64_t v293;
  float *v294;
  float *v295;
  float v296;
  float v297;
  unint64_t v298;
  uint64_t v299;
  float32x4_t *v300;
  int32x4_t *v301;
  unint64_t v304;
  float32x4_t v305;
  float32x4_t v306;
  float64x2_t v307;
  float64x2_t v308;
  float64x2_t v309;
  float64x2_t v310;
  float32x4_t v311;
  uint64_t v312;
  uint64_t v313;
  _DWORD *v314;
  float *v315;
  float v316;
  float v317;
  int v318;
  int v319;
  char v321;
  unsigned int v322;
  int v323;
  _DWORD *v324;
  unint64_t v325;
  unint64_t v326;
  float32x4_t *v327;
  float32x4_t v328;
  unint64_t v329;
  float32x4_t v330;
  uint64_t v331;
  float *v332;
  uint64_t i;
  float v334;
  uint64_t v335;
  int v336;
  unint64_t v337;
  unint64_t v338;
  __int32 *v339;
  float32x4_t *v340;
  float32x4_t v341;
  unint64_t v342;
  float32x4_t v343;
  unint64_t v344;
  unsigned __int8 *v345;
  float *v346;
  unsigned int v347;
  BOOL v348;
  char v349;
  uint64_t v350;
  unsigned int v351;
  unint64_t v352;
  unint64_t v353;
  int v355;
  signed int v356;
  int *v357;
  uint64_t v358;
  __int16 *v359;
  float *v360;
  float v361;
  __int16 v362;
  int v363;
  int v364;
  int v365;
  int v366;
  int8x16_t v367;
  int32x4_t v368;
  uint32x4_t v369;
  uint64_t v370;
  int8x16_t *v371;
  float32x4_t *v372;
  int32x4_t v373;
  int8x16_t *v376;
  int32x4_t v377;
  int32x4_t v378;
  uint32x4_t v379;
  unint64_t v380;
  int32x4_t v381;
  int32x4_t v382;
  int32x4_t v383;
  float32x4_t v384;
  float32x4_t v385;
  int8x16_t v386;
  float32x4_t v387;
  int16x8_t v388;
  int8x16_t v389;
  int16x8_t v390;
  int32x4_t v391;
  int32x4_t v392;
  uint32x4_t v393;
  uint32x4_t v394;
  float32x4_t v395;
  int32x4_t v396;
  int32x4_t v397;
  int32x4_t v398;
  int32x4_t v399;
  int8x16_t v400;
  int8x16_t v401;
  int8x16_t v402;
  int8x16_t v403;
  int8x16_t v404;
  int8x16_t v405;
  int32x4_t v406;
  int32x4_t v407;
  int8x16_t v408;
  int8x16_t v409;
  int8x16_t v410;
  int8x16_t v411;
  int8x16_t v412;
  int8x16_t v413;
  int8x16_t v414;
  int8x16_t v415;
  int8x16_t v416;
  int8x16_t v417;
  int8x16_t v418;
  int8x16_t v419;
  int8x16_t v420;
  int8x16_t v421;
  int8x16_t v422;
  int8x16_t v423;
  int8x16_t v424;
  int8x16_t v425;
  int8x16_t v426;
  int32x4_t v427;
  int8x16_t v428;
  int8x16_t v429;
  int8x16_t v430;
  int32x4_t v431;
  int8x16_t v432;
  int8x16_t v433;
  int8x16_t v434;
  int32x4_t v435;
  int8x16_t v436;
  int8x16_t v437;
  uint64_t v438;
  int *v439;
  uint64_t v440;
  __int16 *v441;
  float *v442;
  int v443;
  int v444;
  float v445;
  __int16 v446;
  int v447;
  int v448;
  uint64_t v449;
  uint64_t v450;
  int v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  unsigned int v455;
  _DWORD *v456;
  int v457;
  int v458;
  int v459;
  unsigned int v460;
  int *v461;
  uint64_t v462;
  _BOOL4 v463;
  uint64_t v464;
  float *v465;
  unint64_t v466;
  unint64_t v467;
  unint64_t v468;
  unint64_t v469;
  uint64_t v470;
  float32x4_t v471;
  float64x2_t v472;
  float32x4_t v473;
  float64x2_t v474;
  float64x2_t v475;
  float64x2_t v476;
  uint64_t v477;

  v464 = a4;
  v465 = a1;
  v477 = *MEMORY[0x24BDAC8D0];
  v27 = MEMORY[0x24BDAC7A8](a1, a2);
  v29 = (char *)&v449 - ((v28 + 15) & 0x7FFFFFFF0);
  MEMORY[0x24BDAC7A8](v27, v30);
  v32 = (float32x4_t *)((char *)&v449 - v31);
  *(_QWORD *)&v34 = v33;
  bzero(v35, 4 * v33);
  v476.f64[0] = v34;
  v40 = 4 * *(_QWORD *)&v34;
  v470 = a3;
  if (a5 < 1)
  {
    *(_QWORD *)&v475.f64[0] = &v449;
    v43 = MEMORY[0x24BDAC7A8](v36, v37);
    v45 = (float *)((char *)&v449 - ((v44 + 15) & 0x7FFFFFFF0));
    MEMORY[0x24BDAC7A8](v43, v46);
    v48 = (float32x4_t *)((char *)&v449 - v47);
    v463 = a6 == 2;
    v49 = -31.9;
    memcpy((char *)&v449 - v47, v45, 4 * a5);
    goto LABEL_47;
  }
  *(float *)v38.i32 = (float)(9 - a8);
  if (a5 < 8)
  {
    v41 = 0;
    v42 = v465;
    do
    {
LABEL_17:
      v39.i16[0] = a9->i16[v41];
      v39.i64[0] = vmovl_s16(*(int16x4_t *)v39.i8).u64[0];
      *(float *)v39.i32 = (float)((float)((float)((float)((float)v39.i32[0] * 0.0625) + 0.5) + *(float *)v38.i32)
                                - *((float *)&eMeans + v41))
                        + (float)((float)((v41 + 5) * (v41 + 5)) * 0.0062);
      v32->i32[v41++] = v39.i32[0];
    }
    while (a5 != v41);
    goto LABEL_18;
  }
  v41 = a5 & 0xFFFFFFF8;
  v62 = (float32x4_t)vdupq_lane_s32(v38, 0);
  v63 = a9 + 1;
  v39 = (int32x4_t)xmmword_208F071C0;
  v64 = (float32x4_t *)&unk_208F387D0;
  v65 = v32 + 1;
  v66 = (float32x4_t)vdupq_n_s32(0x3D800000u);
  v67.i64[0] = 0x500000005;
  v67.i64[1] = 0x500000005;
  v68.i64[0] = 0x900000009;
  v68.i64[1] = 0x900000009;
  v69 = (float32x4_t)vdupq_n_s32(0x3BCB295Fu);
  v70.i64[0] = 0x800000008;
  v70.i64[1] = 0x800000008;
  v71 = v41;
  v42 = v465;
  do
  {
    v72.i64[0] = 0x3F0000003F000000;
    v72.i64[1] = 0x3F0000003F000000;
    v73.i64[0] = 0x3F0000003F000000;
    v73.i64[1] = 0x3F0000003F000000;
    v74 = vsubq_f32(vaddq_f32(vmlaq_f32(v72, v66, vcvtq_f32_s32(vmovl_s16(v63[-1]))), v62), v64[-1]);
    v75 = vaddq_s32(v39, v67);
    v76 = vaddq_s32(v39, v68);
    v77 = vmlaq_f32(vsubq_f32(vaddq_f32(vmlaq_f32(v73, v66, vcvtq_f32_s32(vmovl_s16(*v63))), v62), *v64), v69, vcvtq_f32_s32(vmulq_s32(v76, v76)));
    v65[-1] = vmlaq_f32(v74, v69, vcvtq_f32_s32(vmulq_s32(v75, v75)));
    *v65 = v77;
    v39 = vaddq_s32(v39, v70);
    v63 += 2;
    v64 += 2;
    v65 += 2;
    v71 -= 8;
  }
  while (v71);
  if (v41 != a5)
    goto LABEL_17;
LABEL_18:
  v78 = 0;
  if (a6 <= 1)
    v79 = 1;
  else
    v79 = a6;
  v49 = -31.9;
  v80 = v42;
  do
  {
    v81 = v80;
    v82 = (float *)v32;
    v83 = a5;
    do
    {
      v84 = *v81++;
      v85 = v84;
      v86 = *v82++;
      v87 = v85 - v86;
      if (v49 <= v87)
        v49 = v87;
      --v83;
    }
    while (v83);
    ++v78;
    v80 = (float *)((char *)v80 + v40);
  }
  while (v78 != v79);
  *(_QWORD *)&v475.f64[0] = &v449;
  v88 = MEMORY[0x24BDAC7A8](v36, v37);
  v45 = (float *)((char *)&v449 - ((v89 + 15) & 0x7FFFFFFF0));
  MEMORY[0x24BDAC7A8](v88, v90);
  v48 = (float32x4_t *)((char *)&v449 - v92);
  if (a5 < 8)
  {
    v93 = 0;
LABEL_32:
    v99 = a5 - v93;
    v100 = v93;
    v101 = &v45[v93];
    v102 = &v32->f32[v100];
    v103 = &v91->f32[v100];
    do
    {
      v104 = *v103++;
      v105 = v104;
      v106 = *v102++;
      *v101++ = v105 - v106;
      --v99;
    }
    while (v99);
    goto LABEL_34;
  }
  v93 = a5 & 0xFFFFFFF8;
  v94 = v91 + 1;
  v95 = v32 + 1;
  v96 = (float32x4_t *)(v45 + 4);
  v97 = v93;
  do
  {
    v98 = vsubq_f32(*v94, *v95);
    v96[-1] = vsubq_f32(v94[-1], v95[-1]);
    *v96 = v98;
    v94 += 2;
    v95 += 2;
    v96 += 2;
    v97 -= 8;
  }
  while (v97);
  if (v93 != a5)
    goto LABEL_32;
LABEL_34:
  if (a6 == 2)
  {
    if (a5 >= 8)
    {
      v108 = 0;
      v107 = a5 & 0xFFFFFFF8;
      v109 = (uint64_t)v91[1].i64 + 4 * *(_QWORD *)&v476.f64[0];
      do
      {
        v110 = (int8x16_t *)&v45[v108 / 4];
        v111 = vsubq_f32(*(float32x4_t *)(v109 + v108 - 16), v32[v108 / 0x10]);
        v112 = vsubq_f32(*(float32x4_t *)(v109 + v108), v32[v108 / 0x10 + 1]);
        v113 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)&v45[v108 / 4 + 4], v112), *(int8x16_t *)&v45[v108 / 4 + 4], (int8x16_t)v112);
        *v110 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)&v45[v108 / 4], v111), *(int8x16_t *)&v45[v108 / 4], (int8x16_t)v111);
        v110[1] = v113;
        v108 += 32;
      }
      while (((4 * a5) & 0x3FFFFFFE0) != v108);
      if (v107 == a5)
        goto LABEL_46;
    }
    else
    {
      v107 = 0;
    }
    v114 = &v91->i8[4 * *(_QWORD *)&v476.f64[0]];
    do
    {
      v115 = v45[v107];
      v116 = v32->f32[v107];
      if (v115 <= (float)(*(float *)&v114[4 * v107] - v116))
        v115 = *(float *)&v114[4 * v107] - v116;
      v45[v107++] = v115;
    }
    while (a5 != v107);
LABEL_46:
    v463 = 1;
    memcpy(v48, v45, 4 * a5);
    if (a5 <= 1)
      goto LABEL_47;
    goto LABEL_5;
  }
  v463 = 0;
  memcpy(v48, v45, 4 * a5);
  if (a5 <= 1)
  {
LABEL_47:
    v56 = a5 - 2;
    v59 = a16;
    v60 = a14;
    v61 = a5 - 1;
    if (a5 < 1)
      goto LABEL_65;
    goto LABEL_48;
  }
LABEL_5:
  v53 = v45 + 1;
  v54 = *v45;
  v55 = a5 - 1;
  do
  {
    v54 = v54 + -2.0;
    if (*v53 > v54)
      v54 = *v53;
    *v53++ = v54;
    --v55;
  }
  while (v55);
  v56 = a5 - 2;
  v57 = (a5 - 2);
  v58 = v45[v57 + 1];
  do
  {
    v58 = v58 + -3.0;
    if (v45[v57] > v58)
      v58 = v45[v57];
    v45[v57--] = v58;
  }
  while (v57 != -1);
  v59 = a16;
  v60 = a14;
  v61 = a5 - 1;
LABEL_48:
  *(float *)v50.i32 = v49 + -12.0;
  if ((float)(v49 + -12.0) < 0.0)
    *(float *)v50.i32 = 0.0;
  if (a5 < 8)
  {
    v117 = 0;
    goto LABEL_55;
  }
  v117 = a5 & 0xFFFFFFF8;
  v118 = (float32x4_t)vdupq_lane_s32(v50, 0);
  v119 = v48 + 1;
  v120 = (float32x4_t *)(v45 + 4);
  v121 = a21 + 1;
  v122.i64[0] = 0x3F0000003F000000;
  v122.i64[1] = 0x3F0000003F000000;
  v51.i64[0] = 0x500000005;
  v51.i64[1] = 0x500000005;
  v123.i64[0] = 0x2000000020;
  v123.i64[1] = 0x2000000020;
  v124 = v117;
  do
  {
    v125 = vcvtq_s32_f32(vrndmq_f32(vaddq_f32(vsubq_f32(v119[-1], (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v118, v120[-1]), (int8x16_t)v118, (int8x16_t)v120[-1])), v122)));
    v126 = vcvtq_s32_f32(vrndmq_f32(vaddq_f32(vsubq_f32(*v119, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v118, *v120), (int8x16_t)v118, *(int8x16_t *)v120)), v122)));
    v52 = vbslq_s8((int8x16_t)vcgtzq_s32(v125), v123, (int8x16_t)vshlq_u32((uint32x4_t)v123, (uint32x4_t)vnegq_s32(vminq_s32(vnegq_s32(v125), (int32x4_t)v51))));
    v121[-1] = v52;
    *v121 = vbslq_s8((int8x16_t)vcgtzq_s32(v126), v123, (int8x16_t)vshlq_u32((uint32x4_t)v123, (uint32x4_t)vnegq_s32(vminq_s32(vnegq_s32(v126), (int32x4_t)v51))));
    v119 += 2;
    v120 += 2;
    v121 += 2;
    v124 -= 8;
  }
  while (v124);
  if (v117 != a5)
  {
LABEL_55:
    v127 = a5 - v117;
    v128 = v117;
    v129 = &a21->i32[v117];
    v130 = &v45[v117];
    v131 = &v48->f32[v128];
    do
    {
      v132 = *v131++;
      v133 = v132;
      v134 = *v130++;
      v135 = v134;
      if (*(float *)v50.i32 > v134)
        v135 = *(float *)v50.i32;
      v136 = vcvtms_s32_f32((float)(v133 - v135) + 0.5);
      if (-v136 < 5)
        v137 = -v136;
      else
        LOBYTE(v137) = 5;
      v138 = 0x20u >> v137;
      if (v136 <= 0)
        v139 = v138;
      else
        v139 = 32;
      *v129++ = v139;
      --v127;
    }
    while (v127);
  }
LABEL_65:
  if (v60 < 1 || a15 < 51 || a17)
  {
    if ((int)v464 < a5)
    {
      v240 = v59;
      memset_pattern16((void *)(a20 + 4 * (int)v464), &unk_208F31AF0, 4 * (~(_DWORD)v464 + a5) + 4);
      v59 = v240;
      v241 = 0;
      goto LABEL_278;
    }
LABEL_277:
    v241 = 0;
    goto LABEL_278;
  }
  v452 = a20;
  v451 = a15;
  v460 = v60;
  v461 = v59;
  v454 = a7;
  v140 = 0;
  v141 = 0;
  v142 = 0;
  v453 = a13;
  v462 = a5;
  LODWORD(v475.f64[0]) = a5 - 3;
  v459 = a11;
  v458 = a10;
  v455 = a6;
  if (a6 <= 1)
    v143 = 1;
  else
    v143 = a6;
  *(_QWORD *)&v474.f64[0] = v143;
  v456 = a19;
  v450 = a18;
  v457 = a12;
  *(_QWORD *)&v472.f64[0] = v56;
  v473.i64[0] = v56 - 2;
  v468 = v473.i64[0] & 0xFFFFFFFFFFFFFFFCLL;
  v466 = v473.i64[0] & 0xFFFFFFFFFFFFFFFCLL | 2;
  v471.i64[0] = a5 & 0xFFFFFFF8;
  v144 = v29 + 4;
  v145 = v29 - 4;
  v146 = (float32x4_t *)(v29 + 8);
  v147 = v476.f64[0];
  v148 = *(_QWORD *)&v476.f64[0] << 32;
  v149 = -2;
  v469 = v56 - 3;
  v467 = HIDWORD(v469);
  __asm { FMOV            V4.4S, #-1.0 }
  v154 = v61;
  v155 = v29;
  v156 = a2;
  do
  {
    v157 = v141 * LODWORD(v147);
    v158 = 4 * v141 * *(_QWORD *)&v147;
    v159 = (float32x2_t *)&v155[v158];
    v160 = a2 + v158;
    v52.i32[0] = *(_DWORD *)v160;
    v159->i32[0] = *(_DWORD *)v160;
    if (a5 > 1)
    {
      v161 = 0;
      v162 = *(float *)v52.i32;
      do
      {
        v163 = 4 * v161;
        v164 = (float *)(v156 + 4 * v161);
        v165 = v164[1];
        ++v161;
        if (v165 > (float)(*v164 + 0.5))
          v142 = v161;
        v162 = v162 + 1.5;
        if (v162 >= v165)
          v162 = v164[1];
        *(float *)&v144[v163] = v162;
      }
      while (a5 - 1 != v161);
    }
    if (v142 >= 1)
    {
      v166 = v159->f32[v142];
      v167 = v142;
      do
      {
        v166 = v166 + 2.0;
        v168 = v156 + 4 * v167;
        if (v166 >= *(float *)(v168 - 4))
          v166 = *(float *)(v168 - 4);
        if (*(float *)&v145[4 * v167] < v166)
          v166 = *(float *)&v145[4 * v167];
        *(float *)&v145[4 * v167] = v166;
        v182 = v167-- > 1;
      }
      while (v182);
    }
    if (a5 >= 5)
    {
      if (v473.i64[0] >= 4uLL)
      {
        v169 = 2;
        if ((int)v141 * (int)v470 + (int)v469 >= (int)v141 * (int)v470 && !v467)
        {
          v193 = v468;
          v194 = v140;
          v195 = v146;
          do
          {
            v196 = a2 + (v194 >> 30);
            v197 = *(float32x4_t *)(v196 + 8);
            v198 = *(float32x4_t *)(v196 + 4);
            v199 = (int8x16_t)vcgtq_f32(*(float32x4_t *)v196, v198);
            v200 = vbslq_s8(v199, *(int8x16_t *)v196, (int8x16_t)v198);
            v201 = (float32x4_t)vbslq_s8(v199, (int8x16_t)v198, *(int8x16_t *)v196);
            v202 = *(float32x4_t *)(v196 + 12);
            v203 = *(float32x4_t *)(v196 + 16);
            v204 = (int8x16_t)vcgtq_f32(v202, v203);
            v205 = (float32x4_t)vbslq_s8(v204, (int8x16_t)v203, (int8x16_t)v202);
            v206 = vbslq_s8(v204, (int8x16_t)v202, (int8x16_t)v203);
            v207 = (int8x16_t)vcgtq_f32(v201, v205);
            v208 = (float32x4_t)vbslq_s8(v207, v206, v200);
            v209 = (float32x4_t)vbslq_s8(v207, (int8x16_t)v201, (int8x16_t)v205);
            v210 = (float32x4_t)vbslq_s8(v207, v200, v206);
            v211 = (int8x16_t)vcgtq_f32(v197, v208);
            v212 = (int8x16_t)vcgtq_f32(v209, v197);
            v213 = vbslq_s8((int8x16_t)vcgtq_f32(v210, v197), (int8x16_t)v197, (int8x16_t)v210);
            v214 = (int8x16_t)vcgtq_f32(v209, v208);
            v215 = vbslq_s8(v214, (int8x16_t)v208, (int8x16_t)v209);
            v216 = vbslq_s8((int8x16_t)vcgtq_f32(v208, v210), (int8x16_t)v210, (int8x16_t)v208);
            v217 = vbslq_s8(v212, (int8x16_t)v197, (int8x16_t)v209);
            v218 = vandq_s8(v211, v214);
            v219 = vbicq_s8(v211, v214);
            v220 = (int8x16_t)vcgtq_f32(*v195, vaddq_f32((float32x4_t)vbslq_s8(vorrq_s8(v211, v212), vbslq_s8(vbicq_s8(v212, v211), v215, vbslq_s8(v219, v216, v217)), v213), _Q4));
            v221 = vorrq_s8(vornq_s8(v218, v211), v219);
            v222 = vbicq_s8(v221, v220);
            v223 = vbicq_s8(v222, v211);
            *(int8x16_t *)v195 = vbslq_s8(vandq_s8(v221, v220), *(int8x16_t *)v195, (int8x16_t)vaddq_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vbicq_s8(v223, v212), 0x1FuLL)), v213, vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vandq_s8(v223, v212), 0x1FuLL)), v215, vbslq_s8(vandq_s8(v219, v222), v216, v217))), _Q4));
            ++v195;
            v194 += 0x400000000;
            v193 -= 4;
          }
          while (v193);
          v169 = v466;
          if (v473.i64[0] == v468)
            goto LABEL_155;
        }
      }
      else
      {
        v169 = 2;
      }
      v170 = *(_QWORD *)&v472.f64[0] - v169;
      v171 = (unint64_t)(v169 + v149) << 32;
      v172 = (float *)&v29[4 * v169];
      do
      {
        v173 = *v172;
        v174 = (float *)(a2 + (v171 >> 30));
        v175 = v174[1];
        if (*v174 <= v175)
          v176 = v174[1];
        else
          v176 = *v174;
        if (*v174 <= v175)
          v177 = *v174;
        else
          v177 = v174[1];
        v178 = v174[2];
        v179 = v174[3];
        v180 = v174[4];
        if (v179 <= v180)
          v181 = v174[3];
        else
          v181 = v174[4];
        if (v179 > v180)
          v180 = v174[3];
        v182 = v177 <= v181;
        if (v177 <= v181)
          v183 = v176;
        else
          v183 = v180;
        if (v177 <= v181)
          v177 = v181;
        if (v182)
          v176 = v180;
        if (v178 >= v176)
          v184 = v176;
        else
          v184 = v174[2];
        if (v183 >= v177)
          v185 = v177;
        else
          v185 = v183;
        if (v178 < v177)
          v184 = v185;
        if (v176 >= v183)
          v186 = v183;
        else
          v186 = v176;
        if (v178 >= v177)
          v187 = v177;
        else
          v187 = v174[2];
        if (v183 < v177)
          v186 = v187;
        if (v178 > v183)
          v184 = v186;
        if (v173 <= (float)(v184 + -1.0))
        {
          if (v178 >= v176)
            v188 = v176;
          else
            v188 = v174[2];
          if (v183 >= v177)
            v189 = v177;
          else
            v189 = v183;
          if (v178 < v177)
            v188 = v189;
          if (v176 >= v183)
            v176 = v183;
          if (v178 >= v177)
            v190 = v177;
          else
            v190 = v174[2];
          if (v183 < v177)
            v191 = v190;
          else
            v191 = v176;
          if (v178 > v183)
            v192 = v191;
          else
            v192 = v188;
          v173 = v192 + -1.0;
        }
        *v172++ = v173;
        v171 += 0x100000000;
        --v170;
      }
      while (v170);
    }
LABEL_155:
    v224 = *(float *)(v160 + 4);
    v225 = *(float *)(v160 + 8);
    if (*(float *)v52.i32 <= v224)
      v226 = *(float *)v52.i32;
    else
      v226 = *(float *)(v160 + 4);
    if (*(float *)v52.i32 <= v224)
      v52.i32[0] = *(_DWORD *)(v160 + 4);
    if (v226 >= v225)
      v227 = v226;
    else
      v227 = *(float *)(v160 + 8);
    if (*(float *)v52.i32 >= v225)
      *(float *)v52.i32 = v227;
    *(float *)v52.i32 = *(float *)v52.i32 + -1.0;
    v228 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v52.i8, 0);
    *(int8x8_t *)v52.i8 = vbsl_s8((int8x8_t)vcgt_f32(*v159, v228), (int8x8_t)*v159, (int8x8_t)v228);
    *v159 = *(float32x2_t *)v52.i8;
    v229 = (float *)(a2 + 4 * (LODWORD(v475.f64[0]) + v157));
    v52.i32[0] = *(__int32 *)v229;
    v230 = v229[1];
    if (*v229 <= v230)
      v231 = *v229;
    else
      v231 = v229[1];
    if (*v229 <= v230)
      v52.i32[0] = (__int32)v229[1];
    v232 = v229[2];
    if (v231 < v232)
      v231 = v229[2];
    if (*(float *)v52.i32 >= v232)
      *(float *)v52.i32 = v231;
    v233 = *(float *)v52.i32 + -1.0;
    v234 = v159->f32[v56];
    if (v234 <= v233)
      v234 = v233;
    v159->f32[v56] = v234;
    if (v159->f32[v154] > v233)
      v233 = v159->f32[v154];
    v159->f32[v154] = v233;
    v147 = v476.f64[0];
    if (a5 >= 1)
    {
      if (a5 >= 8)
      {
        v236 = 0;
        do
        {
          v237 = (int8x16_t *)&v29[v236];
          v52 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)&v29[v236], v32[v236 / 0x10]), *(int8x16_t *)&v29[v236], (int8x16_t)v32[v236 / 0x10]);
          v238 = vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)&v29[v236 + 16], v32[v236 / 0x10 + 1]), *(int8x16_t *)&v29[v236 + 16], (int8x16_t)v32[v236 / 0x10 + 1]);
          *v237 = v52;
          v237[1] = v238;
          v236 += 32;
        }
        while (((4 * a5) & 0x3FFFFFFE0) != v236);
        v235 = v471.i64[0];
        if (v471.i64[0] == a5)
          goto LABEL_72;
      }
      else
      {
        v235 = 0;
      }
      do
      {
        v239 = *(float *)&v29[4 * v235];
        if (v239 <= v32->f32[v235])
          v239 = v32->f32[v235];
        *(float *)&v29[4 * v235++] = v239;
      }
      while (a5 != v235);
    }
LABEL_72:
    ++v141;
    v144 += v40;
    v156 += v40;
    v145 += v40;
    v146 = (float32x4_t *)((char *)v146 + v40);
    v140 += v148;
    v149 += LODWORD(v147);
    v29 += v40;
  }
  while (v141 != *(_QWORD *)&v474.f64[0]);
  if (v463)
  {
    v242 = v464;
    v243 = v455;
    v244 = v454;
    v245 = v155;
    v246 = v462;
    v247 = v465;
    if ((int)v464 < a5)
    {
      v248 = (int)v464;
      v249 = v462 - (int)v464;
      if (v249 < 4
        || &v155[4 * (int)v464 + 4 * *(_QWORD *)&v147] < &v155[4 * v462]
        && &v155[4 * (int)v464] < &v155[4 * v462 + 4 * *(_QWORD *)&v147])
      {
        goto LABEL_198;
      }
      v250 = 4 * (int)v464;
      v251 = &v155[v40];
      __asm { FMOV            V0.4S, #-4.0 }
      v253.i64[0] = 0x3F0000003F000000;
      v253.i64[1] = 0x3F0000003F000000;
      v254 = v249 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v255 = *(float32x4_t *)&v245[v250];
        v256 = vaddq_f32(v255, _Q0);
        v257 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)&v251[v250], v256), *(int8x16_t *)&v251[v250], (int8x16_t)v256);
        *(float32x4_t *)&v251[v250] = v257;
        v258 = vaddq_f32(v257, _Q0);
        v259 = vsubq_f32(*(float32x4_t *)&v247[(unint64_t)v250 / 4], (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v255, v258), (int8x16_t)v255, (int8x16_t)v258));
        v51 = (float32x4_t)vbicq_s8((int8x16_t)v259, (int8x16_t)vcltzq_f32(v259));
        v260 = vsubq_f32(*(float32x4_t *)&v247[(unint64_t)v40 / 4 + (unint64_t)v250 / 4], v257);
        _Q4 = (float32x4_t)vcltzq_f32(v260);
        *(float32x4_t *)&v245[v250] = vmulq_f32(vaddq_f32(v51, (float32x4_t)vbicq_s8((int8x16_t)v260, (int8x16_t)_Q4)), v253);
        v250 += 16;
        v254 -= 4;
      }
      while (v254);
      v248 = (v249 & 0xFFFFFFFFFFFFFFFCLL) + v242;
      if (v249 != (v249 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_198:
        v261 = v246 - v248;
        v262 = 4 * (v248 + *(_QWORD *)&v147);
        v263 = v245;
        do
        {
          v264 = *(float *)&v263[v262];
          if (v264 <= (float)(*(float *)&v263[4 * v248] + -4.0))
            v264 = *(float *)&v263[4 * v248] + -4.0;
          *(float *)&v263[v262] = v264;
          v265 = v264 + -4.0;
          if (*(float *)&v263[4 * v248] > v265)
            v265 = *(float *)&v263[4 * v248];
          *(float *)&v263[4 * v248] = v265;
          v266 = v247[v248] - v265;
          if (v266 < 0.0)
            v266 = 0.0;
          v267 = v247[(unint64_t)v262 / 4] - *(float *)&v263[v262];
          if (v267 < 0.0)
            v267 = 0.0;
          *(float *)&v263[4 * v248] = (float)(v266 + v267) * 0.5;
          ++v247;
          v263 += 4;
          --v261;
        }
        while (v261);
      }
      goto LABEL_218;
    }
  }
  else
  {
    v242 = v464;
    v243 = v455;
    v244 = v454;
    v245 = v155;
    v246 = v462;
    v268 = v465;
    if ((int)v464 < a5)
    {
      v269 = v462 - (int)v464;
      v270 = (int)v464;
      if (v269 < 8)
        goto LABEL_214;
      v270 = (v269 & 0xFFFFFFFFFFFFFFF8) + (int)v464;
      v271 = 4 * (int)v464 + 16;
      v272 = (float32x4_t *)((char *)v465 + v271);
      v273 = (float32x4_t *)&v155[v271];
      v274 = v269 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        v275 = vsubq_f32(v272[-1], v273[-1]);
        v276 = vsubq_f32(*v272, *v273);
        v51 = (float32x4_t)vcltzq_f32(v276);
        v273[-1] = (float32x4_t)vbicq_s8((int8x16_t)v275, (int8x16_t)vcltzq_f32(v275));
        *(int8x16_t *)v273 = vbicq_s8((int8x16_t)v276, (int8x16_t)v51);
        v272 += 2;
        v273 += 2;
        v274 -= 8;
      }
      while (v274);
      if (v269 != (v269 & 0xFFFFFFFFFFFFFFF8))
      {
LABEL_214:
        v277 = v246 - v270;
        v278 = v270;
        v279 = (float *)&v245[4 * v270];
        v280 = &v268[v278];
        do
        {
          v281 = *v280++;
          v282 = v281 - *v279;
          if (v282 < 0.0)
            v282 = 0.0;
          *v279++ = v282;
          --v277;
        }
        while (v277);
      }
LABEL_218:
      if (v242 < a5)
      {
        v283 = v242;
        v284 = v246 - v242;
        v285 = v242;
        v286 = v450;
        if (v284 < 8)
          goto LABEL_223;
        v285 = (v284 & 0xFFFFFFFFFFFFFFF8) + v242;
        v287 = 4 * v242 + 16;
        v288 = (float32x4_t *)&v245[v287];
        v289 = (float32x4_t *)(v450 + v287);
        v290 = v284 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v291 = vbslq_s8((int8x16_t)vcgtq_f32(*v288, *v289), *(int8x16_t *)v288, *(int8x16_t *)v289);
          v288[-1] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v288[-1], v289[-1]), (int8x16_t)v288[-1], (int8x16_t)v289[-1]);
          *v288 = (float32x4_t)v291;
          v288 += 2;
          v289 += 2;
          v290 -= 8;
        }
        while (v290);
        if (v284 != (v284 & 0xFFFFFFFFFFFFFFF8))
        {
LABEL_223:
          v292 = v246 - v285;
          v293 = 4 * v285;
          v294 = (float *)(v286 + 4 * v285);
          v295 = (float *)&v245[v293];
          do
          {
            v296 = *v294++;
            v297 = v296;
            if (*v295 > v296)
              v297 = *v295;
            *v295++ = v297;
            --v292;
          }
          while (v292);
        }
        if (v284 < 4)
          goto LABEL_231;
        v298 = (v284 & 0xFFFFFFFFFFFFFFFCLL) + v242;
        v299 = 4 * v242;
        v300 = (float32x4_t *)&v245[v299];
        v301 = (int32x4_t *)(v452 + v299);
        __asm { FMOV            V1.4S, #4.0 }
        v472 = (float64x2_t)vdupq_n_s64(0x3FE62E42FEFA39EFuLL);
        v473 = _Q1;
        __asm { FMOV            V0.4S, #13.0 }
        v471 = _Q0;
        v304 = v284 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v305 = *v300++;
          v306 = vminnmq_f32(v305, v473);
          v476 = vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v306.f32), v472);
          v474 = vmulq_f64(vcvt_hight_f64_f32(v306), v472);
          v307.f64[0] = exp(v474.f64[1]);
          v475 = v307;
          v308.f64[0] = exp(v474.f64[0]);
          v308.f64[1] = v475.f64[0];
          v475 = v308;
          v309.f64[0] = exp(v476.f64[1]);
          v474 = v309;
          v310.f64[0] = exp(v476.f64[0]);
          v310.f64[1] = v474.f64[0];
          v311.i64[0] = 0x3F0000003F000000;
          v311.i64[1] = 0x3F0000003F000000;
          *v301++ = vcvtq_s32_f32(vrndmq_f32(vmlaq_f32(v311, v471, vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v310), v475))));
          v304 -= 4;
        }
        while (v304);
        v283 = v298;
        v242 = v464;
        v246 = v462;
        if (v284 != (v284 & 0xFFFFFFFFFFFFFFFCLL))
        {
LABEL_231:
          v312 = v246 - v283;
          v313 = 4 * v283;
          v314 = (_DWORD *)(v452 + v313);
          v315 = (float *)&v245[v313];
          do
          {
            v316 = *v315++;
            v317 = exp(fminf(v316, 4.0) * 0.693147181);
            *v314++ = vcvtms_s32_f32((float)(v317 * 13.0) + 0.5);
            --v312;
          }
          while (v312);
        }
      }
    }
  }
  v318 = v459;
  v319 = v457;
  if (v459)
    _ZF = v457 == 0;
  else
    _ZF = 0;
  v321 = _ZF;
  v59 = v461;
  v322 = v460;
  v323 = v458;
  v324 = v456;
  if (!v458 && v242 < a5 && (v321 & 1) == 0)
  {
    v325 = v246 - v242;
    v326 = v242;
    if (v325 < 8)
      goto LABEL_246;
    v326 = (v325 & 0xFFFFFFFFFFFFFFF8) + v242;
    v327 = (float32x4_t *)&v245[4 * v242 + 16];
    v328.i64[0] = 0x3F0000003F000000;
    v328.i64[1] = 0x3F0000003F000000;
    v329 = v325 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      v330 = vmulq_f32(*v327, v328);
      v327[-1] = vmulq_f32(v327[-1], v328);
      *v327 = v330;
      v327 += 2;
      v329 -= 8;
    }
    while (v329);
    if (v325 != (v325 & 0xFFFFFFFFFFFFFFF8))
    {
LABEL_246:
      v331 = v246 - v326;
      v332 = (float *)&v245[4 * v326];
      do
      {
        *v332 = *v332 * 0.5;
        ++v332;
        --v331;
      }
      while (v331);
    }
  }
  if (v242 < a5)
  {
    for (i = v242; v246 != i; ++i)
    {
      v334 = 2.0;
      v335 = i;
      if (i >= 8)
      {
        if (i < 0xC)
          continue;
        v335 = i;
        v334 = 0.5;
      }
      *(float *)&v245[4 * v335] = v334 * *(float *)&v245[4 * v335];
    }
  }
  if (*v324)
  {
    v336 = a5 >= 19 ? 19 : a5;
    if (v336 > v242)
    {
      v337 = v336 - (uint64_t)v242;
      v338 = v242;
      if (v337 < 8)
        goto LABEL_264;
      v338 = (v337 & 0xFFFFFFFFFFFFFFF8) + v242;
      v339 = (_DWORD *)((char *)v324 + v242 + 48);
      v340 = (float32x4_t *)&v245[4 * v242 + 16];
      v341 = (float32x4_t)vdupq_n_s32(0x3C800000u);
      v342 = v337 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        v51.i32[0] = *(v339 - 1);
        _Q4.i32[0] = *v339;
        v51 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v51.f32)));
        _Q4 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)_Q4.f32)));
        v343 = vmlaq_f32(*v340, v341, _Q4);
        v340[-1] = vmlaq_f32(v340[-1], v341, v51);
        *v340 = v343;
        v339 += 2;
        v340 += 2;
        v342 -= 8;
      }
      while (v342);
      if (v337 != (v337 & 0xFFFFFFFFFFFFFFF8))
      {
LABEL_264:
        v344 = v336 - v338;
        v345 = (unsigned __int8 *)v324 + v338 + 44;
        v346 = (float *)&v245[4 * v338];
        do
        {
          v347 = *v345++;
          *v346 = *v346 + (float)((float)v347 * 0.015625);
          ++v346;
          --v344;
        }
        while (v344);
      }
    }
  }
  if (v242 >= a5)
    goto LABEL_277;
  if (v323)
    v348 = 1;
  else
    v348 = v319 == 0;
  v349 = v348;
  v350 = v453;
  v351 = *(unsigned __int16 *)(v453 + 2 * v242);
  if (v318 && (v349 & 1) != 0)
  {
    v352 = v246 - v242;
    if (v352 >= 0x10)
    {
      v367 = (int8x16_t)vdupq_n_s16(v351);
      v368 = vdupq_n_s32(v243);
      v369 = (uint32x4_t)vdupq_n_s32(v322);
      v353 = (v352 & 0xFFFFFFFFFFFFFFF0) + v242;
      v370 = 4 * v242 + 32;
      v371 = (int8x16_t *)(v244 + v370);
      v372 = (float32x4_t *)&v245[v370];
      v373 = 0uLL;
      __asm
      {
        FMOV            V3.4S, #4.0
        FMOV            V5.4S, #6.0
      }
      v376 = (int8x16_t *)(v453 + 2 * v242 + 18);
      v377.i64[0] = 0x3000000030;
      v377.i64[1] = 0x3000000030;
      v378.i64[0] = 0x500000005;
      v378.i64[1] = 0x500000005;
      v379.i64[0] = 0x2B0000002BLL;
      v379.i64[1] = 0x2B0000002BLL;
      v380 = v352 & 0xFFFFFFFFFFFFFFF0;
      v381 = 0uLL;
      v382 = 0uLL;
      v383 = 0uLL;
      do
      {
        v384 = vminnmq_f32(v372[-1], _Q3);
        v385 = vminnmq_f32(v372[-2], _Q3);
        v386 = v376[-1];
        v387 = vminnmq_f32(v372[1], _Q3);
        v388 = (int16x8_t)vextq_s8(v367, v386, 0xEuLL);
        v389 = *v376;
        v376 += 2;
        v367 = v389;
        v390 = (int16x8_t)vextq_s8(v386, v389, 0xEuLL);
        v391 = vsubl_s16(*(int16x4_t *)v386.i8, *(int16x4_t *)v388.i8);
        v392 = vsubl_high_s16((int16x8_t)v386, v388);
        v393 = (uint32x4_t)vmulq_s32(vsubl_high_s16((int16x8_t)v389, v390), v368);
        v394 = (uint32x4_t)vmulq_s32(vsubl_s16(*(int16x4_t *)v389.i8, *(int16x4_t *)v390.i8), v368);
        v395 = vminnmq_f32(*v372, _Q3);
        v396 = (int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v391, v368), v369);
        v397 = (int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v392, v368), v369);
        v398 = (int32x4_t)vshlq_u32(v394, v369);
        v399 = (int32x4_t)vshlq_u32(v393, v369);
        v400 = (int8x16_t)vcvtq_n_s32_f32(v385, 3uLL);
        v401 = (int8x16_t)vcvtq_n_s32_f32(v384, 3uLL);
        v402 = (int8x16_t)vcvtq_n_s32_f32(v395, 3uLL);
        v403 = (int8x16_t)vcvtq_n_s32_f32(v387, 3uLL);
        v404 = (int8x16_t)vshrq_n_s32(vshlq_n_s32(vmulq_s32((int32x4_t)v400, v396), 3uLL), 3uLL);
        v405 = (int8x16_t)vshrq_n_s32(vshlq_n_s32(vmulq_s32((int32x4_t)v401, v397), 3uLL), 3uLL);
        v406 = vshlq_n_s32(vmulq_s32((int32x4_t)v402, v398), 3uLL);
        v407 = vshlq_n_s32(vmulq_s32((int32x4_t)v403, v399), 3uLL);
        v408 = (int8x16_t)vcvtq_s32_f32(v384);
        v409 = (int8x16_t)vcgtq_s32(v397, v377);
        v410 = vbslq_s8(v409, v401, v408);
        v411 = vbslq_s8(v409, v405, (int8x16_t)vshlq_n_s32(vmulq_s32((int32x4_t)v408, v397), 3uLL));
        v412 = (int8x16_t)vcvtq_s32_f32(v385);
        v413 = (int8x16_t)vcgtq_s32(v396, v377);
        v414 = vbslq_s8(v413, v400, v412);
        v415 = vbslq_s8(v413, v404, (int8x16_t)vshlq_n_s32(vmulq_s32((int32x4_t)v412, v396), 3uLL));
        v416 = (int8x16_t)vcvtq_s32_f32(v387);
        v417 = (int8x16_t)vcgtq_s32(v399, v377);
        v418 = vbslq_s8(v417, v403, v416);
        v419 = vbslq_s8(v417, (int8x16_t)vshrq_n_s32(v407, 3uLL), (int8x16_t)vshlq_n_s32(vmulq_s32((int32x4_t)v416, v399), 3uLL));
        v420 = (int8x16_t)vcvtq_s32_f32(v395);
        v421 = (int8x16_t)vcgtq_s32(v398, v377);
        v422 = vbslq_s8(v421, v402, v420);
        v423 = vbslq_s8(v421, (int8x16_t)vshrq_n_s32(v406, 3uLL), (int8x16_t)vshlq_n_s32(vmulq_s32((int32x4_t)v420, v398), 3uLL));
        v424 = (int8x16_t)vcvtq_s32_f32(vdivq_f32(vmulq_f32(v385, vcvtq_f32_s32(v396)), _Q5));
        v425 = (int8x16_t)vcgtq_u32(v379, (uint32x4_t)vaddq_s32(v396, v378));
        v426 = vbslq_s8(v425, v424, v414);
        v427 = (int32x4_t)vbslq_s8(v425, (int8x16_t)vmulq_s32((int32x4_t)v424, v377), v415);
        v428 = (int8x16_t)vcvtq_s32_f32(vdivq_f32(vmulq_f32(v384, vcvtq_f32_s32(v397)), _Q5));
        v429 = (int8x16_t)vcgtq_u32(v379, (uint32x4_t)vaddq_s32(v397, v378));
        v430 = vbslq_s8(v429, v428, v410);
        v431 = (int32x4_t)vbslq_s8(v429, (int8x16_t)vmulq_s32((int32x4_t)v428, v377), v411);
        v432 = (int8x16_t)vcvtq_s32_f32(vdivq_f32(vmulq_f32(v395, vcvtq_f32_s32(v398)), _Q5));
        v433 = (int8x16_t)vcgtq_u32(v379, (uint32x4_t)vaddq_s32(v398, v378));
        v434 = vbslq_s8(v433, v432, v422);
        v435 = (int32x4_t)vbslq_s8(v433, (int8x16_t)vmulq_s32((int32x4_t)v432, v377), v423);
        v436 = (int8x16_t)vcvtq_s32_f32(vdivq_f32(vmulq_f32(v387, vcvtq_f32_s32(v399)), _Q5));
        v437 = (int8x16_t)vcgtq_u32(v379, (uint32x4_t)vaddq_s32(v399, v378));
        v372[-2] = v385;
        v372[-1] = v384;
        *v372 = v395;
        v372[1] = v387;
        v372 += 4;
        v381 = vaddq_s32(v431, v381);
        v373 = vaddq_s32(v427, v373);
        v383 = vaddq_s32((int32x4_t)vbslq_s8(v437, (int8x16_t)vmulq_s32((int32x4_t)v436, v377), v419), v383);
        v371[-2] = v426;
        v371[-1] = v430;
        v382 = vaddq_s32(v435, v382);
        *v371 = v434;
        v371[1] = vbslq_s8(v437, v436, v418);
        v371 += 4;
        v380 -= 16;
      }
      while (v380);
      v241 = vaddvq_s32(vaddq_s32(vaddq_s32(v382, v373), vaddq_s32(v383, v381)));
      if (v352 != (v352 & 0xFFFFFFFFFFFFFFF0))
      {
        LOWORD(v351) = v367.i16[7];
        goto LABEL_293;
      }
    }
    else
    {
      v241 = 0;
      v353 = v242;
LABEL_293:
      v438 = 4 * v353;
      v439 = (int *)(v244 + 4 * v353);
      v440 = v246 - v353;
      v441 = (__int16 *)(v350 + 2 * v353 + 2);
      v442 = (float *)&v245[v438];
      do
      {
        v445 = fminf(*v442, 4.0);
        *v442 = v445;
        v447 = *v441++;
        v446 = v447;
        v448 = ((v447 - (__int16)v351) * v243) << v322;
        if (v448 < 6)
        {
          v443 = (int)v445;
          v444 = 8 * (int)v445 * v448;
        }
        else if (v448 <= 0x30)
        {
          v443 = (int)(float)((float)(v445 * (float)v448) / 6.0);
          v444 = 48 * v443;
        }
        else
        {
          v443 = vcvts_n_s32_f32(v445, 3uLL);
          v444 = (8 * v443 * v448) >> 3;
        }
        LOWORD(v351) = v446;
        v241 += v444;
        *v439++ = v443;
        ++v442;
        --v440;
      }
      while (v440);
    }
  }
  else
  {
    v355 = 0;
    v356 = 2 * v451 / 3u;
    v357 = (int *)(v244 + 4 * v242);
    v358 = v246 - v242;
    v359 = (__int16 *)(v453 + 2 * v242 + 2);
    v360 = (float *)&v245[4 * v242];
    while (1)
    {
      v361 = fminf(*v360, 4.0);
      *v360 = v361;
      v363 = *v359++;
      v362 = v363;
      v364 = ((v363 - (__int16)v351) * v243) << v322;
      if (v364 > 5)
      {
        if (v364 < 0x31)
        {
          v365 = (int)(float)((float)(v361 * (float)v364) / 6.0);
          v366 = 48 * v365;
        }
        else
        {
          v365 = vcvts_n_s32_f32(v361, 3uLL);
          v366 = (8 * v365 * v364) >> 3;
        }
      }
      else
      {
        v365 = (int)v361;
        v366 = 8 * (int)v361 * v364;
      }
      v241 = v366 + v355;
      if (v356 < (v366 + v355) >> 6)
        break;
      LOWORD(v351) = v362;
      *v357++ = v365;
      ++v360;
      v355 = v241;
      if (!--v358)
        goto LABEL_278;
    }
    v241 = v356 << 6;
    *v357 = (v356 << 6) - v355;
  }
LABEL_278:
  *v59 = v241;
  return v49;
}

BOOL tf_analysis(uint64_t a1, uint64_t a2, int a3, float a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, int a10, int *a11)
{
  int *v13;
  float v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float32x4_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float32x4_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  _WORD *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t *v39;
  char *v40;
  uint64_t v41;
  int v42;
  float v43;
  __int16 v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  float v48;
  float32x4_t *v49;
  uint64_t v50;
  float32x4_t *v51;
  float32x4_t v52;
  float32x4_t v53;
  uint64_t v54;
  float *v55;
  float v56;
  int v57;
  float v58;
  uint64_t v59;
  float *v60;
  uint64_t v61;
  float *v62;
  float v63;
  uint64_t v64;
  float v65;
  uint64_t v66;
  float v67;
  BOOL v68;
  uint64_t v69;
  uint64_t v70;
  float32x4_t *v71;
  float32x4_t v72;
  float32x4_t v73;
  uint64_t v74;
  float *v75;
  float v76;
  float v77;
  uint64_t v78;
  float v79;
  float v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  float *v84;
  uint64_t v85;
  float *v86;
  float v87;
  uint64_t v88;
  float v89;
  uint64_t v90;
  uint64_t v91;
  float32x4_t *v92;
  float32x4_t v93;
  float32x4_t v94;
  uint64_t v95;
  float *v96;
  float v97;
  int v98;
  uint64_t v99;
  int v101;
  uint64_t v102;
  unsigned int v103;
  int v104;
  char *v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  uint64_t v112;
  int *v113;
  int *v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  char *v124;
  int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int v130;
  uint64_t v131;
  int *v132;
  int *v133;
  int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  int v139;
  int v140;
  int v141;
  int v142;
  _BOOL4 v143;
  int v144;
  unsigned int v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  int v151;
  int v152;
  uint64_t v153;
  uint64_t v154;
  int v155;
  int v156;
  _BOOL4 v157;
  int v158;
  int v159;
  int v160;
  int v161;
  uint64_t v162;
  int v163;
  char *v164;
  uint64_t v166;
  char *v167;
  char *v168;
  uint64_t v169;
  int *v170;
  int v171;
  uint64_t v172;
  float32x4_t *v173;
  int v174;
  int v175;
  _WORD *v176;
  _DWORD *v177;
  uint64_t v178;
  uint64_t v179;
  float32x4_t *v180;
  int v181;
  uint64_t v182;
  uint64_t v183;
  int v184;
  uint64_t v185;

  v178 = a7;
  v13 = a11;
  v185 = *MEMORY[0x24BDAC8D0];
  v14 = 0.5 - a4;
  if (v14 >= -0.25)
    v15 = v14 * 0.04;
  else
    v15 = -0.01;
  v179 = a2;
  v16 = MEMORY[0x24BDAC7A8](a1, a2);
  v18 = (_DWORD *)((char *)&v166 - ((v17 + 15) & 0x7FFFFFFF0));
  v20 = (int)v19 - 1;
  v21 = MEMORY[0x24BDAC7A8](v16, v19);
  v23 = (float32x4_t *)((char *)&v166 - ((v22 + 15) & 0x7FFFFFFF0));
  v25 = MEMORY[0x24BDAC7A8](v21, v24);
  v27 = (float32x4_t *)((char *)&v166 - v26);
  v29 = MEMORY[0x24BDAC7A8](v25, v28);
  v31 = (char *)&v166 - v30;
  v33 = (_WORD *)MEMORY[0x24BDAC7A8](v29, v32);
  v39 = &v166;
  v40 = (char *)&v166 - v38;
  if ((int)v34 < 1)
    goto LABEL_80;
  v166 = v34;
  v167 = (char *)&v166 - v38;
  v168 = v31;
  v169 = v20;
  v170 = a11;
  v171 = v36;
  v172 = v35;
  v41 = 0;
  if (a3)
    v42 = a9;
  else
    v42 = 0;
  v43 = v15 * (float)v42;
  v174 = -2 * a9;
  v175 = a10 * v37;
  v176 = v33;
  v177 = v18;
  v44 = *v33;
  v173 = v27 + 1;
  v180 = v23 + 1;
  do
  {
    v183 = v41;
    v182 = v41 + 1;
    v181 = (__int16)v176[v41 + 1];
    v184 = v181 - v44;
    v45 = (v184 << a9);
    memcpy(v23, (const void *)(v178 + 4 * ((v44 << a9) + v175)), 4 * (int)v45);
    if ((int)v45 < 1)
    {
      v48 = 0.0;
      v49 = v180;
      v46 = v184;
      goto LABEL_19;
    }
    v46 = v184;
    if (v45 < 8)
    {
      v47 = 0;
      v48 = 0.0;
      v49 = v180;
LABEL_17:
      v54 = v45 - v47;
      v55 = &v23->f32[v47];
      do
      {
        v56 = *v55++;
        v48 = v48 + fabsf(v56);
        --v54;
      }
      while (v54);
      goto LABEL_19;
    }
    v47 = v45 & 0x7FFFFFF8;
    v48 = 0.0;
    v50 = v45 & 0xFFFFFFF8;
    v49 = v180;
    v51 = v180;
    do
    {
      v52 = vabsq_f32(v51[-1]);
      v53 = vabsq_f32(*v51);
      v48 = (float)((float)((float)((float)((float)((float)((float)(v48 + v52.f32[0]) + v52.f32[1]) + v52.f32[2])
                                          + v52.f32[3])
                                  + v53.f32[0])
                          + v53.f32[1])
                  + v53.f32[2])
          + v53.f32[3];
      v51 += 2;
      v50 -= 8;
    }
    while (v50);
    if (v47 != v45)
      goto LABEL_17;
LABEL_19:
    v57 = 0;
    v58 = v48 + (float)(v43 * v48);
    if (!a3 || v46 == 1)
    {
      v18 = v177;
      if (a3)
        v68 = 1;
      else
        v68 = v46 == 1;
      if (v68)
        v69 = a9;
      else
        v69 = (a9 + 1);
      if ((int)v69 < 1)
        goto LABEL_70;
LABEL_48:
      v78 = 0;
      while (1)
      {
        v81 = ~(_DWORD)v78 + a9;
        v82 = v78 + 1;
        if (!a3)
          v81 = v78 + 1;
        if (v78 != 31 && (int)v45 >> v78 > 1)
        {
          v83 = 0;
          v84 = (float *)v23;
          do
          {
            v85 = 0;
            v86 = v84;
            do
            {
              v87 = *v86 * 0.70711;
              v88 = ((v85 + 1) << v78) + v83;
              v89 = v23->f32[v88] * 0.70711;
              *v86 = v87 + v89;
              v23->f32[v88] = v87 - v89;
              v85 += 2;
              v86 += (2 << v78);
            }
            while ((((int)v45 >> v78) & 0xFFFFFFFE) != v85);
            ++v83;
            ++v84;
          }
          while (v83 != 1 << v78);
        }
        if ((int)v45 < 1)
        {
          v79 = 0.0;
        }
        else
        {
          if (v45 >= 8)
          {
            v79 = 0.0;
            v91 = v45 & 0xFFFFFFF8;
            v92 = v49;
            do
            {
              v93 = vabsq_f32(v92[-1]);
              v94 = vabsq_f32(*v92);
              v79 = (float)((float)((float)((float)((float)((float)((float)(v79 + v93.f32[0]) + v93.f32[1]) + v93.f32[2])
                                                  + v93.f32[3])
                                          + v94.f32[0])
                                  + v94.f32[1])
                          + v94.f32[2])
                  + v94.f32[3];
              v92 += 2;
              v91 -= 8;
            }
            while (v91);
            v90 = v45 & 0x7FFFFFF8;
            if ((v45 & 0xFFFFFFF8) == v45)
              goto LABEL_50;
          }
          else
          {
            v90 = 0;
            v79 = 0.0;
          }
          v95 = v45 - v90;
          v96 = &v23->f32[v90];
          do
          {
            v97 = *v96++;
            v79 = v79 + fabsf(v97);
            --v95;
          }
          while (v95);
        }
LABEL_50:
        v80 = v79 + (float)((float)(v15 * (float)v81) * v79);
        if (v80 < v58)
        {
          v58 = v80;
          v57 = v82;
        }
        v78 = v82;
        if (v82 == v69)
          goto LABEL_70;
      }
    }
    memcpy(v27, v23, 4 * (int)v45);
    if (a9 != 31 && (int)v45 >> a9 > 1)
    {
      v59 = 0;
      v60 = (float *)v27;
      do
      {
        v61 = 0;
        v62 = v60;
        do
        {
          v63 = *v62 * 0.70711;
          v64 = ((v61 + 1) << a9) + v59;
          v65 = v27->f32[v64] * 0.70711;
          *v62 = v63 + v65;
          v27->f32[v64] = v63 - v65;
          v61 += 2;
          v62 += (2 << a9);
        }
        while ((((int)v45 >> a9) & 0xFFFFFFFE) != v61);
        ++v59;
        ++v60;
      }
      while (v59 != 1 << a9);
    }
    v18 = v177;
    v49 = v180;
    v46 = v184;
    if ((int)v45 < 1)
    {
      v67 = 0.0;
      goto LABEL_44;
    }
    if (v45 < 8)
    {
      v66 = 0;
      v67 = 0.0;
LABEL_42:
      v74 = v45 - v66;
      v75 = &v27->f32[v66];
      do
      {
        v76 = *v75++;
        v67 = v67 + fabsf(v76);
        --v74;
      }
      while (v74);
      goto LABEL_44;
    }
    v66 = v45 & 0x7FFFFFF8;
    v67 = 0.0;
    v70 = v45 & 0xFFFFFFF8;
    v71 = v173;
    do
    {
      v72 = vabsq_f32(v71[-1]);
      v73 = vabsq_f32(*v71);
      v67 = (float)((float)((float)((float)((float)((float)((float)(v67 + v72.f32[0]) + v72.f32[1]) + v72.f32[2])
                                          + v72.f32[3])
                                  + v73.f32[0])
                          + v73.f32[1])
                  + v73.f32[2])
          + v73.f32[3];
      v71 += 2;
      v70 -= 8;
    }
    while (v70);
    if (v66 != v45)
      goto LABEL_42;
LABEL_44:
    v77 = v67 + (float)((float)(v15 * (float)(a9 + 1)) * v67);
    if (v77 >= v58)
    {
      v57 = 0;
      v69 = a9;
      if (a9 >= 1)
        goto LABEL_48;
    }
    else
    {
      v57 = -1;
      v58 = v77;
      v69 = a9;
      if (a9 >= 1)
        goto LABEL_48;
    }
LABEL_70:
    v98 = 2 * v57;
    if (!a3)
      v98 = -v98;
    v99 = v183;
    v18[v183] = v98;
    if (v46 == 1 && (!v98 || v98 == v174))
      v18[v99] = v98 - 1;
    v44 = v181;
    v41 = v182;
  }
  while (v182 != v179);
  LODWORD(v39) = *v18;
  v35 = v172;
  v36 = v171;
  v20 = v169;
  v13 = v170;
  v31 = v168;
  v40 = v167;
  LODWORD(v34) = v166;
LABEL_80:
  v101 = *v13;
  v102 = a9;
  v103 = 4 * a3;
  if (a3)
    v104 = 0;
  else
    v104 = v36;
  v105 = &tf_select_table[8 * a9];
  v106 = 2 * v105[v103];
  v107 = (_DWORD)v39 - v106;
  if ((int)v39 - v106 < 0)
    v107 = v106 - (_DWORD)v39;
  v108 = v107 * v101;
  v109 = 2 * v105[(4 * a3) | 1];
  v110 = (_DWORD)v39 - v109;
  if ((int)v39 - v109 < 0)
    v110 = v109 - (_DWORD)v39;
  v111 = v104 + v110 * v101;
  if ((int)v34 > 1)
  {
    v112 = v179 - 1;
    v113 = v18 + 1;
    v114 = v13 + 1;
    do
    {
      if (v108 >= v111 + v36)
        v115 = v111 + v36;
      else
        v115 = v108;
      v116 = v108 + v36;
      if (v116 < v111)
        v111 = v116;
      v118 = *v114++;
      v117 = v118;
      v120 = *v113++;
      v119 = v120;
      v121 = v120 - v106;
      if (v120 - v106 < 0)
        v121 = -v121;
      v108 = v115 + v121 * v117;
      v122 = v119 - v109;
      if (v122 < 0)
        v122 = -v122;
      v111 += v122 * v117;
      --v112;
    }
    while (v112);
  }
  if (v108 >= v111)
    v123 = v111;
  else
    v123 = v108;
  v124 = &tf_select_table[8 * v102];
  v125 = 2 * v124[v103 | 2];
  v126 = (_DWORD)v39 - v125;
  if ((int)v39 - v125 < 0)
    v126 = v125 - (_DWORD)v39;
  v127 = v126 * v101;
  v128 = 2 * v124[v103 | 3];
  v129 = (_DWORD)v39 - v128;
  if ((int)v39 - v128 < 0)
    v129 = v128 - (_DWORD)v39;
  v130 = v104 + v129 * v101;
  if ((int)v34 >= 2)
  {
    v131 = v179 - 1;
    v132 = v18 + 1;
    v133 = v13 + 1;
    do
    {
      if (v127 >= v130 + v36)
        v134 = v130 + v36;
      else
        v134 = v127;
      v135 = v127 + v36;
      if (v135 < v130)
        v130 = v135;
      v137 = *v133++;
      v136 = v137;
      v139 = *v132++;
      v138 = v139;
      v140 = v139 - v125;
      if (v139 - v125 < 0)
        v140 = -v140;
      v127 = v134 + v140 * v136;
      v141 = v138 - v128;
      if (v141 < 0)
        v141 = -v141;
      v130 += v141 * v136;
      --v131;
    }
    while (v131);
  }
  if (v127 >= v130)
    v142 = v130;
  else
    v142 = v127;
  v143 = a3 != 0 && v142 < v123;
  if (v143)
    v144 = 2;
  else
    v144 = 0;
  v145 = v144 | v103;
  v146 = 2 * v124[v145];
  v147 = (_DWORD)v39 - v146;
  if ((int)v39 - v146 < 0)
    v147 = v146 - (_DWORD)v39;
  v148 = v124[v145 | 1];
  v149 = v147 * v101;
  v150 = 2 * v148;
  v151 = (_DWORD)v39 - v150;
  if (v151 < 0)
    v151 = -v151;
  v152 = v104 + v151 * v101;
  if ((int)v34 < 2)
  {
    *(_DWORD *)(v35 + 4 * v20) = v149 >= v152;
  }
  else
  {
    v153 = 4 * v179;
    v154 = 4;
    do
    {
      v155 = v152 + v36;
      if (v149 < v152 + v36)
        v155 = v149;
      *(_DWORD *)&v31[v154] = v149 >= v152 + v36;
      v156 = v149 + v36;
      v157 = v156 >= v152;
      if (v156 < v152)
        v152 = v156;
      *(_DWORD *)&v40[v154] = v157;
      v158 = v13[(unint64_t)v154 / 4];
      v159 = v18[(unint64_t)v154 / 4];
      v160 = v159 - v146;
      if (v159 - v146 < 0)
        v160 = v146 - v159;
      v149 = v155 + v160 * v158;
      v161 = v159 - v150;
      if (v159 - v150 < 0)
        v161 = v150 - v159;
      v152 += v161 * v158;
      v154 += 4;
    }
    while (v153 != v154);
    *(_DWORD *)(v35 + 4 * v20) = v149 >= v152;
    v162 = 4 * (v34 - 2);
    v163 = *(_DWORD *)(v162 + v35 + 4);
    do
    {
      if (v163 == 1)
        v164 = v40;
      else
        v164 = v31;
      v163 = *(_DWORD *)&v164[v162 + 4];
      *(_DWORD *)(v35 + v162) = v163;
      v162 -= 4;
    }
    while (v162 != -4);
  }
  return v143;
}

uint64_t alloc_trim_analysis(uint64_t a1, uint64_t a2, float32x4_t *a3, signed int a4, char a5, int a6, int a7, uint64_t a8, float a9, float a10, float *a11, int a12, int a13)
{
  float v20;
  uint64_t v21;
  float v22;
  __int16 *v23;
  int v24;
  int v25;
  uint64_t v26;
  float v27;
  float v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float32x4_t *v33;
  float32x4_t *v34;
  uint64_t v35;
  float32x4_t v36;
  float32x4_t v37;
  uint64_t v38;
  uint64_t v39;
  float *v40;
  float *v41;
  float v42;
  float v43;
  float v44;
  float v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  float32x4_t *v52;
  float32x4_t *v53;
  uint64_t v54;
  float32x4_t v55;
  float32x4_t v56;
  uint64_t v57;
  uint64_t v58;
  float *v59;
  float *v60;
  float v61;
  float v62;
  float v63;
  float v64;
  int v65;
  uint64_t v66;
  float v67;
  float v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  float32x4_t *v73;
  float32x4_t *v74;
  uint64_t v75;
  float32x4_t v76;
  float32x4_t v77;
  uint64_t v78;
  uint64_t v79;
  float *v80;
  float *v81;
  float v82;
  float v83;
  float v84;
  float v85;
  int v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  float32x4_t *v92;
  float32x4_t *v93;
  uint64_t v94;
  float32x4_t v95;
  float32x4_t v96;
  uint64_t v97;
  uint64_t v98;
  float *v99;
  float *v100;
  float v101;
  float v102;
  float v103;
  float v104;
  int v105;
  uint64_t v106;
  float v107;
  float v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  float32x4_t *v113;
  float32x4_t *v114;
  uint64_t v115;
  float32x4_t v116;
  float32x4_t v117;
  uint64_t v118;
  uint64_t v119;
  float *v120;
  float *v121;
  float v122;
  float v123;
  float v124;
  float v125;
  int v126;
  uint64_t v127;
  int v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  float32x4_t *v132;
  float32x4_t *v133;
  uint64_t v134;
  float32x4_t v135;
  float32x4_t v136;
  uint64_t v137;
  uint64_t v138;
  float *v139;
  float *v140;
  float v141;
  float v142;
  float v143;
  float v144;
  int v145;
  uint64_t v146;
  float v147;
  float v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  float32x4_t *v153;
  float32x4_t *v154;
  uint64_t v155;
  float32x4_t v156;
  float32x4_t v157;
  uint64_t v158;
  uint64_t v159;
  float *v160;
  float *v161;
  float v162;
  float v163;
  float v164;
  float v165;
  uint64_t v166;
  int v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  float32x4_t *v171;
  float32x4_t *v172;
  uint64_t v173;
  float32x4_t v174;
  float32x4_t v175;
  uint64_t v176;
  uint64_t v177;
  float *v178;
  float *v179;
  float v180;
  float v181;
  float v182;
  float v183;
  float v184;
  int v185;
  uint64_t v186;
  uint64_t v187;
  float v188;
  float v189;
  int v190;
  uint64_t v191;
  int v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  float32x4_t *v196;
  float32x4_t *v197;
  uint64_t v198;
  float32x4_t v199;
  float32x4_t v200;
  uint64_t v201;
  uint64_t v202;
  float *v203;
  float *v204;
  float v205;
  float v206;
  float v207;
  float v208;
  float v209;
  float v210;
  float v211;
  float v212;
  float v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  int32x4_t v218;
  float32x4_t *v219;
  int32x4_t v220;
  int32x4_t v221;
  int32x4_t v222;
  uint64_t v223;
  uint64_t v224;
  float32x4_t *v225;
  int32x4_t v226;
  int32x4_t v227;
  float32x4_t v228;
  float32x4_t v229;
  uint64_t v230;
  int v231;
  float *v232;
  float v233;
  float v234;
  float v235;
  _BOOL4 v236;
  float v237;
  float v238;
  float v239;
  _BOOL4 v240;
  int v241;

  v20 = 4.0;
  if (a13 >= 64000)
  {
    if (a13 >> 7 <= 0x270)
      v20 = (float)((float)((a13 - 64000) >> 10) * 0.0625) + 4.0;
    else
      v20 = 5.0;
    if (a6 != 2)
    {
LABEL_3:
      v21 = (a4 - 1);
      v22 = 0.0;
      if (a4 < 2)
        goto LABEL_113;
      goto LABEL_100;
    }
  }
  else if (a6 != 2)
  {
    goto LABEL_3;
  }
  v23 = *(__int16 **)(a1 + 32);
  v24 = *v23;
  v25 = v23[1];
  v26 = ((v25 - v24) << a5);
  v27 = 0.0;
  v28 = 0.0;
  if ((int)v26 >= 1)
  {
    v29 = v24 << a5;
    v30 = v24 << a5;
    v31 = v29 + a7;
    if (v26 < 8)
    {
      v32 = 0;
LABEL_15:
      v38 = v26 - v32;
      v39 = 4 * v32;
      v40 = (float *)(a2 + v39 + 4 * v31);
      v41 = (float *)(a2 + v39 + 4 * v30);
      do
      {
        v42 = *v41++;
        v43 = v42;
        v44 = *v40++;
        v28 = v28 + (float)(v43 * v44);
        --v38;
      }
      while (v38);
      goto LABEL_17;
    }
    v32 = v26 & 0x7FFFFFF8;
    v33 = (float32x4_t *)(a2 + 4 * v30 + 16);
    v34 = (float32x4_t *)(a2 + 4 * v31 + 16);
    v35 = v26 & 0xFFFFFFF8;
    do
    {
      v36 = vmulq_f32(v33[-1], v34[-1]);
      v37 = vmulq_f32(*v33, *v34);
      v28 = (float)((float)((float)((float)((float)((float)((float)(v28 + v36.f32[0]) + v36.f32[1]) + v36.f32[2])
                                          + v36.f32[3])
                                  + v37.f32[0])
                          + v37.f32[1])
                  + v37.f32[2])
          + v37.f32[3];
      v33 += 2;
      v34 += 2;
      v35 -= 8;
    }
    while (v35);
    if (v32 != v26)
      goto LABEL_15;
  }
LABEL_17:
  v45 = v28 + 0.0;
  v46 = v23[2];
  v47 = ((v46 - v25) << a5);
  if ((int)v47 < 1)
    goto LABEL_25;
  v48 = v25 << a5;
  v49 = v25 << a5;
  v50 = v48 + a7;
  if (v47 < 8)
  {
    v51 = 0;
    v27 = 0.0;
LABEL_23:
    v57 = v47 - v51;
    v58 = 4 * v51;
    v59 = (float *)(a2 + v58 + 4 * v50);
    v60 = (float *)(a2 + v58 + 4 * v49);
    do
    {
      v61 = *v60++;
      v62 = v61;
      v63 = *v59++;
      v27 = v27 + (float)(v62 * v63);
      --v57;
    }
    while (v57);
    goto LABEL_25;
  }
  v51 = v47 & 0x7FFFFFF8;
  v52 = (float32x4_t *)(a2 + 4 * v49 + 16);
  v53 = (float32x4_t *)(a2 + 4 * v50 + 16);
  v27 = 0.0;
  v54 = v47 & 0xFFFFFFF8;
  do
  {
    v55 = vmulq_f32(v52[-1], v53[-1]);
    v56 = vmulq_f32(*v52, *v53);
    v27 = (float)((float)((float)((float)((float)((float)((float)(v27 + v55.f32[0]) + v55.f32[1]) + v55.f32[2])
                                        + v55.f32[3])
                                + v56.f32[0])
                        + v56.f32[1])
                + v56.f32[2])
        + v56.f32[3];
    v52 += 2;
    v53 += 2;
    v54 -= 8;
  }
  while (v54);
  if (v51 != v47)
    goto LABEL_23;
LABEL_25:
  v64 = v45 + v27;
  v65 = v23[3];
  v66 = ((v65 - v46) << a5);
  v67 = 0.0;
  v68 = 0.0;
  if ((int)v66 < 1)
    goto LABEL_33;
  v69 = v46 << a5;
  v70 = v46 << a5;
  v71 = v69 + a7;
  if (v66 < 8)
  {
    v72 = 0;
LABEL_31:
    v78 = v66 - v72;
    v79 = 4 * v72;
    v80 = (float *)(a2 + v79 + 4 * v71);
    v81 = (float *)(a2 + v79 + 4 * v70);
    do
    {
      v82 = *v81++;
      v83 = v82;
      v84 = *v80++;
      v68 = v68 + (float)(v83 * v84);
      --v78;
    }
    while (v78);
    goto LABEL_33;
  }
  v72 = v66 & 0x7FFFFFF8;
  v73 = (float32x4_t *)(a2 + 4 * v70 + 16);
  v74 = (float32x4_t *)(a2 + 4 * v71 + 16);
  v75 = v66 & 0xFFFFFFF8;
  do
  {
    v76 = vmulq_f32(v73[-1], v74[-1]);
    v77 = vmulq_f32(*v73, *v74);
    v68 = (float)((float)((float)((float)((float)((float)((float)(v68 + v76.f32[0]) + v76.f32[1]) + v76.f32[2])
                                        + v76.f32[3])
                                + v77.f32[0])
                        + v77.f32[1])
                + v77.f32[2])
        + v77.f32[3];
    v73 += 2;
    v74 += 2;
    v75 -= 8;
  }
  while (v75);
  if (v72 != v66)
    goto LABEL_31;
LABEL_33:
  v85 = v64 + v68;
  v86 = v23[4];
  v87 = ((v86 - v65) << a5);
  if ((int)v87 < 1)
    goto LABEL_41;
  v88 = v65 << a5;
  v89 = v65 << a5;
  v90 = v88 + a7;
  if (v87 < 8)
  {
    v91 = 0;
    v67 = 0.0;
LABEL_39:
    v97 = v87 - v91;
    v98 = 4 * v91;
    v99 = (float *)(a2 + v98 + 4 * v90);
    v100 = (float *)(a2 + v98 + 4 * v89);
    do
    {
      v101 = *v100++;
      v102 = v101;
      v103 = *v99++;
      v67 = v67 + (float)(v102 * v103);
      --v97;
    }
    while (v97);
    goto LABEL_41;
  }
  v91 = v87 & 0x7FFFFFF8;
  v92 = (float32x4_t *)(a2 + 4 * v89 + 16);
  v93 = (float32x4_t *)(a2 + 4 * v90 + 16);
  v67 = 0.0;
  v94 = v87 & 0xFFFFFFF8;
  do
  {
    v95 = vmulq_f32(v92[-1], v93[-1]);
    v96 = vmulq_f32(*v92, *v93);
    v67 = (float)((float)((float)((float)((float)((float)((float)(v67 + v95.f32[0]) + v95.f32[1]) + v95.f32[2])
                                        + v95.f32[3])
                                + v96.f32[0])
                        + v96.f32[1])
                + v96.f32[2])
        + v96.f32[3];
    v92 += 2;
    v93 += 2;
    v94 -= 8;
  }
  while (v94);
  if (v91 != v87)
    goto LABEL_39;
LABEL_41:
  v104 = v85 + v67;
  v105 = v23[5];
  v106 = ((v105 - v86) << a5);
  v107 = 0.0;
  v108 = 0.0;
  if ((int)v106 < 1)
    goto LABEL_49;
  v109 = v86 << a5;
  v110 = v86 << a5;
  v111 = v109 + a7;
  if (v106 < 8)
  {
    v112 = 0;
LABEL_47:
    v118 = v106 - v112;
    v119 = 4 * v112;
    v120 = (float *)(a2 + v119 + 4 * v111);
    v121 = (float *)(a2 + v119 + 4 * v110);
    do
    {
      v122 = *v121++;
      v123 = v122;
      v124 = *v120++;
      v108 = v108 + (float)(v123 * v124);
      --v118;
    }
    while (v118);
    goto LABEL_49;
  }
  v112 = v106 & 0x7FFFFFF8;
  v113 = (float32x4_t *)(a2 + 4 * v110 + 16);
  v114 = (float32x4_t *)(a2 + 4 * v111 + 16);
  v115 = v106 & 0xFFFFFFF8;
  do
  {
    v116 = vmulq_f32(v113[-1], v114[-1]);
    v117 = vmulq_f32(*v113, *v114);
    v108 = (float)((float)((float)((float)((float)((float)((float)(v108 + v116.f32[0]) + v116.f32[1]) + v116.f32[2])
                                         + v116.f32[3])
                                 + v117.f32[0])
                         + v117.f32[1])
                 + v117.f32[2])
         + v117.f32[3];
    v113 += 2;
    v114 += 2;
    v115 -= 8;
  }
  while (v115);
  if (v112 != v106)
    goto LABEL_47;
LABEL_49:
  v125 = v104 + v108;
  v126 = v23[6];
  v127 = ((v126 - v105) << a5);
  if ((int)v127 < 1)
    goto LABEL_57;
  v128 = v105 << a5;
  v129 = v105 << a5;
  v130 = v128 + a7;
  if (v127 < 8)
  {
    v131 = 0;
    v107 = 0.0;
LABEL_55:
    v137 = v127 - v131;
    v138 = 4 * v131;
    v139 = (float *)(a2 + v138 + 4 * v130);
    v140 = (float *)(a2 + v138 + 4 * v129);
    do
    {
      v141 = *v140++;
      v142 = v141;
      v143 = *v139++;
      v107 = v107 + (float)(v142 * v143);
      --v137;
    }
    while (v137);
    goto LABEL_57;
  }
  v131 = v127 & 0x7FFFFFF8;
  v132 = (float32x4_t *)(a2 + 4 * v129 + 16);
  v133 = (float32x4_t *)(a2 + 4 * v130 + 16);
  v107 = 0.0;
  v134 = v127 & 0xFFFFFFF8;
  do
  {
    v135 = vmulq_f32(v132[-1], v133[-1]);
    v136 = vmulq_f32(*v132, *v133);
    v107 = (float)((float)((float)((float)((float)((float)((float)(v107 + v135.f32[0]) + v135.f32[1]) + v135.f32[2])
                                         + v135.f32[3])
                                 + v136.f32[0])
                         + v136.f32[1])
                 + v136.f32[2])
         + v136.f32[3];
    v132 += 2;
    v133 += 2;
    v134 -= 8;
  }
  while (v134);
  if (v131 != v127)
    goto LABEL_55;
LABEL_57:
  v144 = v125 + v107;
  v145 = v23[7];
  v146 = ((v145 - v126) << a5);
  v147 = 0.0;
  v148 = 0.0;
  if ((int)v146 < 1)
    goto LABEL_65;
  v149 = v126 << a5;
  v150 = v126 << a5;
  v151 = v149 + a7;
  if (v146 < 8)
  {
    v152 = 0;
LABEL_63:
    v158 = v146 - v152;
    v159 = 4 * v152;
    v160 = (float *)(a2 + v159 + 4 * v151);
    v161 = (float *)(a2 + v159 + 4 * v150);
    do
    {
      v162 = *v161++;
      v163 = v162;
      v164 = *v160++;
      v148 = v148 + (float)(v163 * v164);
      --v158;
    }
    while (v158);
    goto LABEL_65;
  }
  v152 = v146 & 0x7FFFFFF8;
  v153 = (float32x4_t *)(a2 + 4 * v150 + 16);
  v154 = (float32x4_t *)(a2 + 4 * v151 + 16);
  v155 = v146 & 0xFFFFFFF8;
  do
  {
    v156 = vmulq_f32(v153[-1], v154[-1]);
    v157 = vmulq_f32(*v153, *v154);
    v148 = (float)((float)((float)((float)((float)((float)((float)(v148 + v156.f32[0]) + v156.f32[1]) + v156.f32[2])
                                         + v156.f32[3])
                                 + v157.f32[0])
                         + v157.f32[1])
                 + v157.f32[2])
         + v157.f32[3];
    v153 += 2;
    v154 += 2;
    v155 -= 8;
  }
  while (v155);
  if (v152 != v146)
    goto LABEL_63;
LABEL_65:
  v165 = v144 + v148;
  v166 = ((v23[8] - v145) << a5);
  if ((int)v166 < 1)
    goto LABEL_73;
  v167 = v145 << a5;
  v168 = v145 << a5;
  v169 = v167 + a7;
  if (v166 < 8)
  {
    v170 = 0;
    v147 = 0.0;
LABEL_71:
    v176 = v166 - v170;
    v177 = 4 * v170;
    v178 = (float *)(a2 + v177 + 4 * v169);
    v179 = (float *)(a2 + v177 + 4 * v168);
    do
    {
      v180 = *v179++;
      v181 = v180;
      v182 = *v178++;
      v147 = v147 + (float)(v181 * v182);
      --v176;
    }
    while (v176);
    goto LABEL_73;
  }
  v170 = v166 & 0x7FFFFFF8;
  v171 = (float32x4_t *)(a2 + 4 * v168 + 16);
  v172 = (float32x4_t *)(a2 + 4 * v169 + 16);
  v147 = 0.0;
  v173 = v166 & 0xFFFFFFF8;
  do
  {
    v174 = vmulq_f32(v171[-1], v172[-1]);
    v175 = vmulq_f32(*v171, *v172);
    v147 = (float)((float)((float)((float)((float)((float)((float)(v147 + v174.f32[0]) + v174.f32[1]) + v174.f32[2])
                                         + v174.f32[3])
                                 + v175.f32[0])
                         + v175.f32[1])
                 + v175.f32[2])
         + v175.f32[3];
    v171 += 2;
    v172 += 2;
    v173 -= 8;
  }
  while (v173);
  if (v170 != v166)
    goto LABEL_71;
LABEL_73:
  v183 = fabsf((float)(v165 + v147) * 0.125);
  if (v183 > 1.0)
    v183 = 1.0;
  v184 = v183;
  if (a12 >= 9)
  {
    LOWORD(v185) = v23[8];
    v186 = a2 + 16;
    v187 = 8;
    v184 = v183;
    do
    {
      v190 = (__int16)v185;
      v185 = v23[++v187];
      v191 = ((v185 - v190) << a5);
      if ((int)v191 < 1)
      {
        v188 = 0.0;
      }
      else
      {
        v192 = v190 << a5;
        v193 = v190 << a5;
        v194 = v192 + a7;
        if (v191 >= 8)
        {
          v195 = v191 & 0x7FFFFFF8;
          v196 = (float32x4_t *)(v186 + 4 * v193);
          v197 = (float32x4_t *)(v186 + 4 * v194);
          v188 = 0.0;
          v198 = v191 & 0xFFFFFFF8;
          do
          {
            v199 = vmulq_f32(v196[-1], v197[-1]);
            v200 = vmulq_f32(*v196, *v197);
            v188 = (float)((float)((float)((float)((float)((float)((float)(v188 + v199.f32[0]) + v199.f32[1])
                                                         + v199.f32[2])
                                                 + v199.f32[3])
                                         + v200.f32[0])
                                 + v200.f32[1])
                         + v200.f32[2])
                 + v200.f32[3];
            v196 += 2;
            v197 += 2;
            v198 -= 8;
          }
          while (v198);
          if (v195 == v191)
            goto LABEL_78;
        }
        else
        {
          v195 = 0;
          v188 = 0.0;
        }
        v201 = v191 - v195;
        v202 = 4 * v195;
        v203 = (float *)(a2 + v202 + 4 * v194);
        v204 = (float *)(a2 + v202 + 4 * v193);
        do
        {
          v205 = *v204++;
          v206 = v205;
          v207 = *v203++;
          v188 = v188 + (float)(v206 * v207);
          --v201;
        }
        while (v201);
      }
LABEL_78:
      v189 = fabsf(v188);
      if (v184 >= v189)
        v184 = v189;
    }
    while (v187 != a12);
  }
  v208 = fabsf(v184);
  if (v208 <= 1.0)
    v209 = v208;
  else
    v209 = 1.0;
  v210 = log((float)(1.001 - (float)(v183 * v183))) * 1.44269504;
  v211 = log((float)(1.001 - (float)(v209 * v209))) * 1.44269504;
  if ((float)(v210 * 0.5) > v211)
    v211 = v210 * 0.5;
  v212 = v210 * 0.75;
  if ((float)(v210 * 0.75) < -4.0)
    v212 = -4.0;
  v20 = v20 + v212;
  v213 = v211 * -0.5;
  if ((float)(*a11 + 0.25) < v213)
    v213 = *a11 + 0.25;
  *a11 = v213;
  v21 = (a4 - 1);
  v22 = 0.0;
  if (a4 >= 2)
  {
LABEL_100:
    v214 = 0;
    v215 = 0;
    v216 = *(int *)(a1 + 8);
    if (a6 <= 1)
      v217 = 1;
    else
      v217 = a6;
    v218 = vdupq_n_s32(a4);
    v219 = a3 + 1;
    v220.i64[0] = 0x800000008;
    v220.i64[1] = 0x800000008;
    v221.i64[0] = 0x200000002;
    v221.i64[1] = 0x200000002;
    v222.i64[0] = 0xA0000000ALL;
    v222.i64[1] = 0xA0000000ALL;
    do
    {
      if (a4 >= 9)
      {
        v224 = v21 & 0xFFFFFFF8;
        v225 = v219;
        v226 = (int32x4_t)xmmword_208F071C0;
        do
        {
          v227 = vsubq_s32(vaddq_s32(v226, v226), v218);
          v228 = vmulq_f32(v225[-1], vcvtq_f32_s32(vaddq_s32(v227, v221)));
          v229 = vmulq_f32(*v225, vcvtq_f32_s32(vaddq_s32(v227, v222)));
          v22 = (float)((float)((float)((float)((float)((float)((float)(v22 + v228.f32[0]) + v228.f32[1]) + v228.f32[2])
                                              + v228.f32[3])
                                      + v229.f32[0])
                              + v229.f32[1])
                      + v229.f32[2])
              + v229.f32[3];
          v226 = vaddq_s32(v226, v220);
          v225 += 2;
          v224 -= 8;
        }
        while (v224);
        v223 = v21 & 0xFFFFFFF8;
        if (v223 == v21)
          goto LABEL_104;
      }
      else
      {
        v223 = 0;
      }
      v230 = v21 - v223;
      v231 = 2 - a4 + 2 * v223;
      v232 = &a3->f32[v223 + v214];
      do
      {
        v233 = *v232++;
        v22 = v22 + (float)(v233 * (float)v231);
        v231 += 2;
        --v230;
      }
      while (v230);
LABEL_104:
      ++v215;
      v219 = (float32x4_t *)((char *)v219 + 4 * v216);
      v214 += v216;
    }
    while (v215 != v217);
  }
LABEL_113:
  v234 = (float)((float)(v22 / (float)(v21 * a6)) + 1.0) / 6.0;
  v235 = -2.0;
  v236 = v234 > 2.0 || v234 < -2.0;
  if (v234 < -2.0 && v234 <= 2.0)
    v237 = -2.0;
  else
    v237 = 2.0;
  if (v236)
    v234 = v237;
  v238 = (float)((float)(v20 - v234) - a10) + (float)(a9 * -2.0);
  if (*(_DWORD *)a8)
  {
    v239 = (float)(*(float *)(a8 + 8) + 0.05) + (float)(*(float *)(a8 + 8) + 0.05);
    v240 = v239 > 2.0 || v239 < -2.0;
    if (v239 >= -2.0 || v239 > 2.0)
      v235 = 2.0;
    if (!v240)
      v235 = (float)(*(float *)(a8 + 8) + 0.05) + (float)(*(float *)(a8 + 8) + 0.05);
    v238 = v238 - v235;
  }
  v241 = vcvtms_s32_f32(v238 + 0.5);
  if (v241 >= 10)
    v241 = 10;
  return v241 & ~(v241 >> 31);
}

uint64_t opus_custom_encoder_ctl(_DWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t result;
  int v11;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  _DWORD *v24;
  _DWORD *v25;
  _DWORD *v26;
  int v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _OWORD *v31;
  _OWORD *v32;
  uint64_t v37;

  result = 4294967291;
  switch(a2)
  {
    case 4002:
      v11 = a9;
      if ((int)a9 <= 500 && (_DWORD)a9 != -1)
        return 0xFFFFFFFFLL;
      result = 0;
      if ((int)a9 >= 260000 * a1[2])
        v11 = 260000 * a1[2];
      a1[11] = v11;
      return result;
    case 4003:
    case 4004:
    case 4005:
    case 4007:
    case 4008:
    case 4009:
    case 4011:
    case 4012:
    case 4013:
    case 4015:
    case 4016:
    case 4017:
    case 4018:
    case 4019:
    case 4021:
    case 4022:
    case 4023:
    case 4024:
    case 4025:
    case 4026:
    case 4027:
    case 4029:
    case 4030:
    case 4032:
    case 4033:
    case 4034:
    case 4035:
    case 4038:
    case 4039:
    case 4040:
    case 4041:
    case 4042:
    case 4043:
    case 4044:
    case 4045:
      return result;
    case 4006:
      result = 0;
      a1[12] = a9;
      return result;
    case 4010:
      if (a9 > 0xA)
        return 0xFFFFFFFFLL;
      result = 0;
      a1[7] = a9;
      return result;
    case 4014:
      if (a9 > 0x64)
        return 0xFFFFFFFFLL;
      result = 0;
      a1[15] = a9;
      return result;
    case 4020:
      result = 0;
      a1[14] = a9;
      return result;
    case 4028:
      v13 = a1[2];
      v14 = *(_QWORD *)a1;
      v15 = *(_DWORD *)(*(_QWORD *)a1 + 8);
      v16 = *(_DWORD *)(*(_QWORD *)a1 + 4) + 1024;
      bzero(a1 + 20, 4 * v13 * (v16 + 4 * v15) + 252 - 80);
      v17 = (*(_DWORD *)(v14 + 8) * v13);
      if ((int)v17 < 1)
        goto LABEL_25;
      v18 = v15 * v13;
      v19 = v16 * v13;
      if (v17 < 0x14 || (unint64_t)(-4 * v18) < 0x20)
      {
        v20 = 0;
LABEL_23:
        v21 = v17 - v20;
        v22 = v20;
        v23 = &a1[v19];
        v24 = &a1[v19 + 63 + v18 + v22];
        v25 = &v23[2 * v18 + 63 + v22];
        do
        {
          *v25++ = -1042284544;
          *v24++ = -1042284544;
          --v21;
        }
        while (v21);
        goto LABEL_25;
      }
      v20 = v17 & 0x7FFFFFF8;
      v31 = &a1[2 * v18 + 67 + v19];
      v32 = &a1[v18 + 67 + v19];
      __asm { FMOV            V0.4S, #-28.0 }
      v37 = v17 & 0xFFFFFFF8;
      do
      {
        *(v31 - 1) = _Q0;
        *v31 = _Q0;
        v31 += 2;
        *(v32 - 1) = _Q0;
        *v32 = _Q0;
        v32 += 2;
        v37 -= 8;
      }
      while (v37);
      if (v20 != v17)
        goto LABEL_23;
LABEL_25:
      result = 0;
      a1[55] = 0;
      *(_QWORD *)(a1 + 21) = 0x3F80000000000002;
      a1[23] = 256;
      a1[25] = 0;
      a1[26] = 0;
      return result;
    case 4031:
      v26 = (_DWORD *)a9;
      if (!a9)
        return 0xFFFFFFFFLL;
      result = 0;
      v27 = a1[20];
      goto LABEL_35;
    case 4036:
      if ((a9 - 25) < 0xFFFFFFEF)
        return 0xFFFFFFFFLL;
      result = 0;
      a1[16] = a9;
      return result;
    case 4037:
      result = 0;
      v26 = (_DWORD *)a9;
      v27 = a1[16];
      goto LABEL_35;
    case 4046:
      if (a9 > 1)
        return 0xFFFFFFFFLL;
      result = 0;
      a1[18] = a9;
      return result;
    case 4047:
      v26 = (_DWORD *)a9;
      if (!a9)
        return 0xFFFFFFFFLL;
      result = 0;
      v27 = a1[18];
LABEL_35:
      *v26 = v27;
      return result;
    default:
      switch(a2)
      {
        case 10002:
          if (a9 > 2)
            return 0xFFFFFFFFLL;
          result = 0;
          a1[6] = a9 != 2;
          a1[4] = a9 == 0;
          break;
        case 10008:
          if ((a9 - 3) < 0xFFFFFFFE)
            return 0xFFFFFFFFLL;
          result = 0;
          a1[3] = a9;
          break;
        case 10010:
          if ((a9 & 0x80000000) != 0 || (int)a9 >= *(_DWORD *)(*(_QWORD *)a1 + 8))
            return 0xFFFFFFFFLL;
          result = 0;
          a1[9] = a9;
          break;
        case 10012:
          if ((int)a9 < 1 || (int)a9 > *(_DWORD *)(*(_QWORD *)a1 + 8))
            return 0xFFFFFFFFLL;
          result = 0;
          a1[10] = a9;
          break;
        case 10015:
          if (!a9)
            return 0xFFFFFFFFLL;
          result = 0;
          *(_QWORD *)a9 = *(_QWORD *)a1;
          break;
        case 10016:
          result = 0;
          a1[13] = a9;
          break;
        case 10022:
          if (!a9)
            goto LABEL_54;
          result = 0;
          v28 = *(_OWORD *)a9;
          v29 = *(_OWORD *)(a9 + 16);
          v30 = *(_OWORD *)(a9 + 32);
          *(_OWORD *)(a1 + 43) = *(_OWORD *)(a9 + 48);
          *(_OWORD *)(a1 + 39) = v30;
          *(_OWORD *)(a1 + 35) = v29;
          *(_OWORD *)(a1 + 31) = v28;
          break;
        case 10024:
          result = 0;
          a1[17] = a9;
          break;
        case 10026:
          result = 0;
          *((_QWORD *)a1 + 30) = a9;
          break;
        case 10028:
          if (a9)
          {
            result = 0;
            *(_QWORD *)(a1 + 47) = *(_QWORD *)a9;
          }
          else
          {
LABEL_54:
            result = 0;
          }
          break;
        default:
          return result;
      }
      return result;
  }
}

void _celt_lpc(float *a1, float *a2, int a3)
{
  float v6;
  unint64_t v7;
  unint64_t i;
  float v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  float v13;
  int32x4_t *v14;
  unint64_t v15;
  float32x4_t *v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  unint64_t v21;
  float *v22;
  float v23;
  float *v24;
  float *v25;
  float v26;
  float v27;

  v6 = *a2;
  bzero(a1, 4 * a3);
  if (*a2 > 1.0e-10)
  {
    v7 = 0;
    for (i = 1; ; ++i)
    {
      v11 = i >> 1;
      if (i >> 1 <= 1)
        v11 = 1;
      if (v7 == (a3 & ~(a3 >> 31)))
        return;
      if (v7)
        break;
      v9 = (float)-(float)(a2[1] + 0.0) / v6;
      *a1 = v9;
      v10 = 1;
LABEL_4:
      v6 = v6 + (float)((float)-(float)(v9 * v9) * v6);
      v7 = v10;
      if (v6 <= (float)(*a2 * 0.001))
        return;
    }
    if (v7 >= 8)
    {
      v12 = v7 & 0xFFFFFFFFFFFFFFF8;
      v14 = (int32x4_t *)&a2[v7 - 3];
      v13 = 0.0;
      v15 = v7 & 0xFFFFFFFFFFFFFFF8;
      v16 = (float32x4_t *)(a1 + 4);
      do
      {
        v17 = (int8x16_t)vrev64q_s32(*v14);
        v18 = (int8x16_t)vrev64q_s32(v14[-1]);
        v19 = vmulq_f32(v16[-1], (float32x4_t)vextq_s8(v17, v17, 8uLL));
        v20 = vmulq_f32(*v16, (float32x4_t)vextq_s8(v18, v18, 8uLL));
        v13 = (float)((float)((float)((float)((float)((float)((float)(v13 + v19.f32[0]) + v19.f32[1]) + v19.f32[2])
                                            + v19.f32[3])
                                    + v20.f32[0])
                            + v20.f32[1])
                    + v20.f32[2])
            + v20.f32[3];
        v16 += 2;
        v14 -= 2;
        v15 -= 8;
      }
      while (v15);
      if (v7 == v12)
        goto LABEL_16;
    }
    else
    {
      v12 = 0;
      v13 = 0.0;
    }
    v21 = v7 - v12;
    v22 = &a1[v12];
    do
    {
      v23 = *v22++;
      v13 = v13 + (float)(v23 * a2[v21--]);
    }
    while (v21);
LABEL_16:
    v10 = v7 + 1;
    v9 = (float)-(float)(v13 + a2[v7 + 1]) / v6;
    a1[v7] = v9;
    v24 = &a1[v7 - 1];
    v25 = a1;
    do
    {
      v26 = *v25;
      v27 = *v24;
      *v25 = *v25 + (float)(v9 * *v24);
      ++v25;
      *v24-- = v27 + (float)(v9 * v26);
      --v11;
    }
    while (v11);
    goto LABEL_4;
  }
}

float32_t celt_fir_c()
{
  unint64_t v0;
  uint64_t v1;
  float32x4_t *v2;
  int v3;
  signed int v4;
  uint64_t v5;
  float32x4_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  __int32 *v20;
  float v21;
  float v22;
  float v23;
  float *v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float *v39;
  uint64_t v40;
  float *v41;
  float v42;
  float v43;
  float v44;
  unint64_t v45;
  unint64_t v46;
  int8x16_t *v47;
  uint64_t v48;
  uint64_t v49;
  int8x16_t v50;
  int8x16_t v51;
  unint64_t v52;
  float32x4_t *v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  int i;
  BOOL v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  float *v73;
  float v74;
  int v75;
  uint64_t v76;
  float32x4_t *v77;
  float32x4_t *v78;
  float32x4_t v79;
  float32x4_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  float32x4_t *v84;
  float32x4_t *v85;
  unint64_t v86;
  float32x4_t v87;
  uint64_t v88;
  uint64_t v89;
  __int32 *v90;
  __int32 *v91;
  __int32 v92;
  unint64_t v93;
  uint64_t v94;
  float32x4_t *v95;
  float32x4_t *v96;
  float32x4_t v97;
  float32x4_t v98;
  _QWORD v100[2];

  v100[1] = *MEMORY[0x24BDAC8D0];
  v0 = MEMORY[0x24BDAC7A8]();
  v8 = (char *)v100 - v7;
  if (v4 >= 1)
  {
    if (v4 < 0xC)
    {
      v9 = 0;
LABEL_4:
      v10 = v5 - v9;
      v11 = &v8[4 * v9];
      v12 = ~(_DWORD)v9 + v4;
      do
      {
        v6.i32[0] = *(_DWORD *)(v1 + 4 * v12);
        *(_DWORD *)v11 = v6.i32[0];
        v11 += 4;
        --v12;
        --v10;
      }
      while (v10);
      goto LABEL_6;
    }
    v9 = 0;
    v46 = v5 - 1;
    if (v4 - (int)v5 > v4 - 1)
      goto LABEL_4;
    if (HIDWORD(v46))
      goto LABEL_4;
    v9 = v5 & 0xFFFFFFF8;
    v47 = (int8x16_t *)(v8 + 16);
    v48 = v9;
    do
    {
      v49 = v1 + 4 * (int)v46;
      v50 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v49 - 12));
      v6 = (float32x4_t)vextq_s8(v50, v50, 8uLL);
      v51 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v49 - 28));
      v47[-1] = (int8x16_t)v6;
      *v47 = vextq_s8(v51, v51, 8uLL);
      v47 += 2;
      LODWORD(v46) = v46 - 8;
      v48 -= 8;
    }
    while (v48);
    if (v9 != v5)
      goto LABEL_4;
  }
LABEL_6:
  if (v3 < 4)
  {
    LODWORD(v45) = 0;
    goto LABEL_43;
  }
  v13 = (v3 - 3);
  if (v4 >= 4)
  {
    v14 = 0;
    v15 = v4 & 0xFFFFFFFC | 1;
    v16 = v4 & 0xFFFFFFFC | 2;
    v17 = v0 - 4 * v4;
    while (1)
    {
      v18 = 0;
      v19 = 0;
      v20 = (__int32 *)(v0 + 4 * v14);
      v6.i32[0] = *v20;
      v21 = *(float *)(v0 + 4 * (v14 | 1));
      v22 = *(float *)(v0 + 4 * (v14 | 2));
      v23 = *(float *)(v0 + 4 * (v14 | 3));
      v24 = (float *)&v20[-v4];
      v25 = *v24;
      v26 = v24[1];
      v27 = v24[2];
      do
      {
        v28 = *(float *)&v8[v18];
        v29 = *(float *)&v8[v18 + 4];
        v30 = v6.f32[0] + (float)(v28 * v25);
        v31 = *(float *)(v17 + v18 + 12);
        v25 = *(float *)(v17 + v18 + 16);
        v32 = v30 + (float)(v29 * v26);
        v33 = (float)(v21 + (float)(v28 * v26)) + (float)(v29 * v27);
        v34 = (float)(v22 + (float)(v28 * v27)) + (float)(v29 * v31);
        v35 = (float)(v23 + (float)(v28 * v31)) + (float)(v29 * v25);
        v36 = *(float *)&v8[v18 + 8];
        v37 = *(float *)&v8[v18 + 12];
        v38 = v32 + (float)(v36 * v27);
        v26 = *(float *)(v17 + v18 + 20);
        v27 = *(float *)(v17 + v18 + 24);
        v6.f32[0] = v38 + (float)(v37 * v31);
        v21 = (float)(v33 + (float)(v36 * v31)) + (float)(v37 * v25);
        v22 = (float)(v34 + (float)(v36 * v25)) + (float)(v37 * v26);
        v23 = (float)(v35 + (float)(v36 * v26)) + (float)(v37 * v27);
        v19 += 4;
        v18 += 16;
      }
      while (v19 < v4 - 3);
      v39 = (float *)&v8[v18];
      v40 = v17 + v18;
      v41 = (float *)(v17 + v18 + 12);
      if ((v4 & 0xFFFFFFFC) >= v4)
      {
        if (v15 >= v4)
        {
LABEL_14:
          if (v16 < v4)
            goto LABEL_18;
          goto LABEL_9;
        }
      }
      else
      {
        v31 = *v41;
        v41 = (float *)(v40 + 16);
        v6.f32[0] = v6.f32[0] + (float)(*v39 * v25);
        v21 = v21 + (float)(*v39 * v26);
        v22 = v22 + (float)(*v39 * v27);
        v23 = v23 + (float)(*v39 * v31);
        v39 = (float *)&v8[16 * ((v4 - 4) >> 2) + 20];
        if (v15 >= v4)
          goto LABEL_14;
      }
      v42 = *v39++;
      v43 = v42;
      v44 = *v41++;
      v25 = v44;
      v6.f32[0] = v6.f32[0] + (float)(v43 * v26);
      v21 = v21 + (float)(v43 * v27);
      v22 = v22 + (float)(v43 * v31);
      v23 = v23 + (float)(v43 * v44);
      if (v16 < v4)
      {
LABEL_18:
        v6.f32[0] = v6.f32[0] + (float)(*v39 * v27);
        v21 = v21 + (float)(*v39 * v31);
        v22 = v22 + (float)(*v39 * v25);
        v23 = v23 + (float)(*v39 * *v41);
      }
LABEL_9:
      v2[v14 / 4].i32[0] = v6.i32[0];
      v2->f32[v14 | 1] = v21;
      v2->f32[v14 | 2] = v22;
      v2->f32[v14 | 3] = v23;
      v14 += 4;
      v17 += 16;
      if (v14 >= v13)
      {
        LODWORD(v45) = v14;
        goto LABEL_43;
      }
    }
  }
  if (v4 <= 0)
  {
    v58 = 4;
    if (v13 > 4)
      v58 = (v3 - 3);
    if (v58 < 0x1D)
      goto LABEL_40;
    v59 = 4;
    if (v13 > 4)
      v59 = (v3 - 3);
    v60 = ((4 * v59 - 4) & 0xFFFFFFFFFFFFFFF0) + 16;
    if (v0 + v60 <= (unint64_t)v2 || (unint64_t)v2 + v60 <= v0)
    {
      v93 = ((v58 - 1) >> 2) + 1;
      v45 = 4 * (v93 & 0x7FFFFFFFFFFFFFFCLL);
      v94 = v93 & 0x7FFFFFFFFFFFFFFCLL;
      v95 = v2;
      v96 = (float32x4_t *)v0;
      do
      {
        v97 = *v96;
        v6 = v96[1];
        v98 = v96[3];
        v95[2] = v96[2];
        v95[3] = v98;
        *v95 = v97;
        v95[1] = v6;
        v95 += 4;
        v96 += 4;
        v94 -= 4;
      }
      while (v94);
      if (v93 == (v93 & 0x7FFFFFFFFFFFFFFCLL))
        goto LABEL_43;
    }
    else
    {
LABEL_40:
      v45 = 0;
    }
    v61 = 4 * v45 + 8;
    v62 = v0 + v61;
    v63 = (char *)v2 + v61;
    do
    {
      v6 = *(float32x4_t *)(v62 - 8);
      *(float32x4_t *)(v63 - 8) = v6;
      v45 += 4;
      v62 += 16;
      v63 += 16;
    }
    while (v45 < v13);
    goto LABEL_43;
  }
  v45 = 0;
  v6 = vld1q_dup_f32((const float *)v8);
  v52 = v0;
  v53 = v2;
  do
  {
    v54 = *(float32x4_t *)(v52 - 4 * v4);
    v55 = vmlaq_f32(*(float32x4_t *)v52, v54, v6);
    if (v4 >= 2)
    {
      v56 = (float32x4_t)vextq_s8((int8x16_t)v54, (int8x16_t)v6, 4uLL);
      v56.i32[3] = *(_DWORD *)(v52 - 4 * v4 + 16);
      v55 = vmlaq_n_f32(v55, v56, *((float *)v8 + 1));
      if (v4 == 3)
      {
        v57.i64[0] = vdupq_laneq_s64((int64x2_t)v54, 1).u64[0];
        v57.i64[1] = *(_QWORD *)(v52 + 4);
        v55 = vmlaq_n_f32(v55, v57, *((float *)v8 + 2));
      }
    }
    *v53++ = v55;
    v45 += 4;
    v52 += 16;
  }
  while (v45 < v13);
LABEL_43:
  if ((int)v45 < v3)
  {
    v64 = v45;
    v65 = v3;
    if (v4 > 0)
    {
      v66 = 0;
      v67 = v45 - v4;
      for (i = v67; ; ++i)
      {
        v6.i32[0] = *(_DWORD *)(v0 + 4 * v64);
        if (v4 >= 8
          && (v67 + v66 + (int)v5 - 1 >= v67 + v66 ? (v69 = (unint64_t)(v5 - 1) >> 32 == 0) : (v69 = 0), v69))
        {
          v75 = i;
          v76 = v5 & 0xFFFFFFF8;
          v77 = (float32x4_t *)(v8 + 16);
          do
          {
            v78 = (float32x4_t *)(v0 + 4 * v75);
            v79 = vmulq_f32(v77[-1], *v78);
            v80 = vmulq_f32(*v77, v78[1]);
            v6.f32[0] = (float)((float)((float)((float)((float)((float)((float)(v6.f32[0] + v79.f32[0]) + v79.f32[1])
                                                              + v79.f32[2])
                                                      + v79.f32[3])
                                              + v80.f32[0])
                                      + v80.f32[1])
                              + v80.f32[2])
                      + v80.f32[3];
            v77 += 2;
            v75 += 8;
            v76 -= 8;
          }
          while (v76);
          v70 = v5 & 0xFFFFFFF8;
          if (v70 == v5)
            goto LABEL_46;
        }
        else
        {
          v70 = 0;
        }
        v71 = v5 - v70;
        v72 = i + v70;
        v73 = (float *)&v8[4 * v70];
        do
        {
          v74 = *v73++;
          v6.f32[0] = v6.f32[0] + (float)(v74 * *(float *)(v0 + 4 * v72++));
          --v71;
        }
        while (v71);
LABEL_46:
        v2->i32[v64++] = v6.i32[0];
        ++v66;
        if (v64 == v65)
          return v6.f32[0];
      }
    }
    v81 = v3 - (unint64_t)v45;
    if (v81 < 0xC)
      goto LABEL_65;
    v82 = 4 * v45;
    if ((unint64_t)v2->u64 + 4 * v64 - v0 + -4 * v64 < 0x20)
      goto LABEL_65;
    v64 += v81 & 0xFFFFFFFFFFFFFFF8;
    v83 = v82 + 16;
    v84 = (float32x4_t *)(v0 + v82 + 16);
    v85 = (float32x4_t *)((char *)v2 + v83);
    v86 = v81 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      v6 = v84[-1];
      v87 = *v84;
      v85[-1] = v6;
      *v85 = v87;
      v84 += 2;
      v85 += 2;
      v86 -= 8;
    }
    while (v86);
    if (v81 != (v81 & 0xFFFFFFFFFFFFFFF8))
    {
LABEL_65:
      v88 = v3 - v64;
      v89 = 4 * v64;
      v90 = (__int32 *)((char *)v2 + v89);
      v91 = (__int32 *)(v0 + v89);
      do
      {
        v92 = *v91++;
        v6.i32[0] = v92;
        *v90++ = v92;
        --v88;
      }
      while (v88);
    }
  }
  return v6.f32[0];
}

float32x4_t celt_iir(uint64_t a1, float *a2, uint64_t a3, int a4, int a5, int8x16_t *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int v17;
  int v18;
  float32x4_t result;
  uint64_t v20;
  float32x4_t *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unint64_t v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float *v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float *v46;
  float v47;
  float v48;
  float *v49;
  float v50;
  int v51;
  float *v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float *v63;
  float *v64;
  int v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  float32x4_t *v76;
  float32x4_t *v77;
  float32x4_t v78;
  float32x4_t v79;
  uint64_t v80;
  float *v81;
  float *v82;
  float v83;
  float v84;
  float v85;
  unint64_t v86;
  int8x16_t *v87;
  uint64_t v88;
  float *v89;
  int8x16_t v90;
  int8x16_t v91;
  unint64_t v92;
  float32x4_t *v93;
  uint64_t v94;
  __int8 *v95;
  int8x16_t v96;
  int8x16_t v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  __int32 *v102;
  __int32 *v103;
  __int32 *v104;
  __int32 v105;
  uint64_t v106;
  uint64_t v107;
  __int32 *v108;
  int v109;
  int v110;
  uint64_t v111;
  int8x16_t *v112;
  uint64_t v113;
  uint64_t v114;
  int8x16_t v115;
  int8x16_t v116;
  uint64_t v117;
  int8x16_t *v118;
  int8x16_t *v119;
  char *v120;
  unint64_t v121;
  int8x16_t v122;
  _QWORD v123[2];

  v123[1] = *MEMORY[0x24BDAC8D0];
  v12 = a5;
  v13 = MEMORY[0x24BDAC7A8](a1, a2);
  v15 = (char *)v123 - v14;
  MEMORY[0x24BDAC7A8](v13, v16);
  v21 = (float32x4_t *)((char *)v123 - v20);
  if (v17 >= 1)
  {
    if (a5 >= 0xC)
    {
      v22 = 0;
      v86 = v12 - 1;
      if (v17 - (int)v12 <= v17 - 1 && !HIDWORD(v86))
      {
        v22 = v12 & 0xFFFFFFF8;
        v87 = (int8x16_t *)(v15 + 16);
        v88 = v22;
        do
        {
          v89 = &a2[(int)v86];
          v90 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v89 - 3));
          result = (float32x4_t)vextq_s8(v90, v90, 8uLL);
          v91 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v89 - 7));
          v87[-1] = (int8x16_t)result;
          *v87 = vextq_s8(v91, v91, 8uLL);
          v87 += 2;
          LODWORD(v86) = v86 - 8;
          v88 -= 8;
        }
        while (v88);
        if (v22 == v12)
        {
LABEL_6:
          if (a5 >= 0xC)
          {
            v26 = 0;
            v92 = v12 - 1;
            if (v17 - (int)v12 <= v17 - 1 && !HIDWORD(v92))
            {
              v26 = v12 & 0xFFFFFFF8;
              v93 = v21 + 1;
              v94 = v26;
              do
              {
                v95 = &a6->i8[4 * (int)v92];
                v96 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v95 - 12));
                v97 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v95 - 28));
                result = vnegq_f32((float32x4_t)vextq_s8(v96, v96, 8uLL));
                v93[-1] = result;
                *v93 = vnegq_f32((float32x4_t)vextq_s8(v97, v97, 8uLL));
                v93 += 2;
                LODWORD(v92) = v92 - 8;
                v94 -= 8;
              }
              while (v94);
              if (v26 == v12)
              {
LABEL_10:
                v28 = v12;
                if ((int)v12 >= v18)
                  goto LABEL_12;
                goto LABEL_11;
              }
            }
          }
          else
          {
            v26 = 0;
          }
          v27 = (-8 - v26) + 7;
          do
          {
            result.f32[0] = -*(float *)&a6->i32[(int)v12 + (int)v27];
            v21->i32[v26++] = result.i32[0];
            --v27;
          }
          while (v12 != v26);
          goto LABEL_10;
        }
      }
    }
    else
    {
      v22 = 0;
    }
    v23 = v12 - v22;
    v24 = &v15[4 * v22];
    v25 = ~(_DWORD)v22 + a5;
    do
    {
      *(float *)v24 = a2[v25];
      v24 += 4;
      --v25;
      --v23;
    }
    while (v23);
    goto LABEL_6;
  }
  v28 = 0;
  if (v18 > 0)
LABEL_11:
    bzero(&v21->f32[v28], 4 * (v18 + ~v28) + 4);
LABEL_12:
  if (a4 >= 4)
  {
    v29 = 0;
    while (1)
    {
      v42 = *(float *)(a1 + 4 * v29);
      v43 = *(float *)(a1 + 4 * (v29 | 1));
      v44 = *(float *)(a1 + 4 * (v29 | 2));
      v45 = *(float *)(a1 + 4 * (v29 | 3));
      v46 = &v21->f32[v29];
      v47 = *v46;
      v48 = v46[1];
      v49 = v46 + 3;
      v50 = v46[2];
      if (a5 < 4)
        break;
      v51 = 0;
      v52 = (float *)v15;
      do
      {
        v53 = v52[1];
        v54 = v42 + (float)(*v52 * v47);
        v55 = *v49;
        v47 = v49[1];
        v56 = v54 + (float)(v53 * v48);
        v57 = (float)(v43 + (float)(*v52 * v48)) + (float)(v53 * v50);
        v58 = (float)(v44 + (float)(*v52 * v50)) + (float)(v53 * *v49);
        v59 = (float)(v45 + (float)(*v52 * *v49)) + (float)(v53 * v47);
        v60 = v52[2];
        v61 = v52[3];
        v62 = v56 + (float)(v60 * v50);
        v48 = v49[2];
        v50 = v49[3];
        v63 = v52 + 4;
        v64 = v49 + 4;
        v42 = v62 + (float)(v61 * *v49);
        v43 = (float)(v57 + (float)(v60 * *v49)) + (float)(v61 * v47);
        v44 = (float)(v58 + (float)(v60 * v47)) + (float)(v61 * v48);
        v45 = (float)(v59 + (float)(v60 * v48)) + (float)(v61 * v50);
        v51 += 4;
        v52 += 4;
        v49 += 4;
      }
      while (v51 < a5 - 3);
      v65 = a5 & 0x7FFFFFFC;
      v49 = v64;
      if ((int)(a5 & 0xFFFFFFFC) < a5)
        goto LABEL_21;
LABEL_22:
      if ((v65 | 1) >= a5)
      {
        if ((v65 | 2) < a5)
        {
LABEL_26:
          v42 = v42 + (float)(*v63 * v50);
          v43 = v43 + (float)(*v63 * v55);
          v44 = v44 + (float)(*v63 * v47);
          v45 = v45 + (float)(*v63 * *v49);
        }
      }
      else
      {
        v69 = *v63++;
        v70 = v69;
        v71 = *v49++;
        v47 = v71;
        v42 = v42 + (float)(v70 * v48);
        v43 = v43 + (float)(v70 * v50);
        v44 = v44 + (float)(v70 * v55);
        v45 = v45 + (float)(v70 * v71);
        if ((v65 | 2) < a5)
          goto LABEL_26;
      }
      *(float *)(a3 + 4 * v29) = v42;
      v30 = *a2;
      v31 = v43 - (float)(v42 * *a2);
      *(float *)(a3 + 4 * (v29 | 1)) = v31;
      v32 = a2[1];
      v33 = v44 - (float)(v31 * *a2);
      v34 = v33 - (float)(v42 * v32);
      *(float *)(a3 + 4 * (v29 | 2)) = v34;
      v35 = a2[1];
      v36 = v45 - (float)(v34 * *a2);
      v37 = -v42;
      v38 = &v21->f32[v29 + a5];
      *v38 = -v42;
      v38[1] = -(float)(v43 + (float)((float)-v42 * v30));
      v39 = -(float)(v33 + (float)((float)-v42 * v32));
      v40 = v36 - (float)(v31 * v35);
      v41 = a2[2];
      result.f32[0] = v40 - (float)(v42 * v41);
      v38[2] = v39;
      v38[3] = -(float)(v40 + (float)(v37 * v41));
      *(_DWORD *)(a3 + 4 * (v29 | 3)) = result.i32[0];
      v29 += 4;
      if (v29 >= (a4 - 3))
        goto LABEL_28;
    }
    v65 = 0;
    v55 = 0.0;
    v63 = (float *)v15;
    if (a5 <= 0)
      goto LABEL_22;
LABEL_21:
    v66 = *v63++;
    v67 = v66;
    v68 = *v49++;
    v55 = v68;
    v42 = v42 + (float)(v67 * v47);
    v43 = v43 + (float)(v67 * v48);
    v44 = v44 + (float)(v67 * v50);
    v45 = v45 + (float)(v67 * v68);
    goto LABEL_22;
  }
  LODWORD(v29) = 0;
LABEL_28:
  if ((int)v29 >= a4)
    goto LABEL_59;
  v72 = v29;
  if (a5 >= 1)
  {
    v73 = (uint64_t)v21[1].i64 + 4 * v29;
    while (1)
    {
      result.i32[0] = *(_DWORD *)(a1 + 4 * v72);
      if (a5 >= 8)
      {
        v75 = v12 & 0xFFFFFFF8;
        v76 = (float32x4_t *)v73;
        v77 = (float32x4_t *)(v15 + 16);
        do
        {
          v78 = vmulq_f32(v76[-1], vnegq_f32(v77[-1]));
          v79 = vmulq_f32(*v76, vnegq_f32(*v77));
          result.f32[0] = (float)((float)((float)((float)((float)((float)((float)(result.f32[0] + v78.f32[0])
                                                                        + v78.f32[1])
                                                                + v78.f32[2])
                                                        + v78.f32[3])
                                                + v79.f32[0])
                                        + v79.f32[1])
                                + v79.f32[2])
                        + v79.f32[3];
          v77 += 2;
          v76 += 2;
          v75 -= 8;
        }
        while (v75);
        v74 = v12 & 0xFFFFFFF8;
        if (v74 == v12)
          goto LABEL_31;
      }
      else
      {
        v74 = 0;
      }
      v80 = v12 - v74;
      v81 = &v21->f32[v74 + v72];
      v82 = (float *)&v15[4 * v74];
      do
      {
        v83 = *v82++;
        v84 = v83;
        v85 = *v81++;
        result.f32[0] = result.f32[0] - (float)(v84 * v85);
        --v80;
      }
      while (v80);
LABEL_31:
      v21->i32[v72 + v12] = result.i32[0];
      *(_DWORD *)(a3 + 4 * v72++) = result.i32[0];
      v73 += 4;
      if (v72 == a4)
        goto LABEL_59;
    }
  }
  v98 = a4 - (unint64_t)v29;
  if (v98 >= 8 && (v99 = 4 * v29, (unint64_t)(a3 - a1) >= 0x20))
  {
    v100 = (v98 & 0xFFFFFFFFFFFFFFF8) + v29;
    v117 = v99 + 16;
    v118 = (int8x16_t *)(a3 + v99 + 16);
    v119 = (int8x16_t *)(a1 + v117);
    v120 = &v21[1].i8[4 * a5 + 4 * (unint64_t)v29];
    v121 = v98 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      result = (float32x4_t)v119[-1];
      v122 = *v119;
      *((float32x4_t *)v120 - 1) = result;
      *(int8x16_t *)v120 = v122;
      v118[-1] = (int8x16_t)result;
      *v118 = v122;
      v118 += 2;
      v119 += 2;
      v120 += 32;
      v121 -= 8;
    }
    while (v121);
    if (v98 == (v98 & 0xFFFFFFFFFFFFFFF8))
      goto LABEL_59;
  }
  else
  {
    v100 = v29;
  }
  v101 = a4 - v100;
  v102 = (__int32 *)(a3 + 4 * v100);
  v103 = &v21->i32[v100 + a5];
  v104 = (__int32 *)(a1 + 4 * v100);
  do
  {
    v105 = *v104++;
    result.i32[0] = v105;
    *v103++ = v105;
    *v102++ = v105;
    --v101;
  }
  while (v101);
LABEL_59:
  if (a5 < 1)
    return result;
  if (a5 < 0x18)
    goto LABEL_61;
  v106 = 0;
  v110 = a4 - 1;
  if (a4 - (int)v12 > a4 - 1 || (unint64_t)(v12 - 1) >> 32)
    goto LABEL_62;
  v111 = 4 * v110 + 4;
  if (a3 + v111 > (unint64_t)a6 && a3 + v111 - 4 * v12 < (unint64_t)a6 + 4 * v12)
  {
LABEL_61:
    v106 = 0;
LABEL_62:
    v107 = v12 - v106;
    v108 = &a6->i32[v106];
    v109 = ~(_DWORD)v106 + a4;
    do
    {
      result.i32[0] = *(_DWORD *)(a3 + 4 * v109);
      *v108++ = result.i32[0];
      --v109;
      --v107;
    }
    while (v107);
    return result;
  }
  v106 = v12 & 0xFFFFFFF8;
  v112 = a6 + 1;
  v113 = v106;
  do
  {
    v114 = a3 + 4 * v110;
    v115 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v114 - 12));
    result = (float32x4_t)vextq_s8(v115, v115, 8uLL);
    v116 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v114 - 28));
    v112[-1] = (int8x16_t)result;
    *v112 = vextq_s8(v116, v116, 8uLL);
    v112 += 2;
    v110 -= 8;
    v113 -= 8;
  }
  while (v113);
  if (v106 != v12)
    goto LABEL_62;
  return result;
}

uint64_t _celt_autocorr(char *a1, float *a2, uint64_t a3, int a4, int a5, int a6)
{
  char *v11;
  signed int v12;
  uint64_t v13;
  char *v14;
  int v15;
  int v16;
  uint64_t v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  char *v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float32x4_t *v28;
  float32x4_t *v29;
  uint64_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int v33;
  float *v34;
  float *v35;
  float v36;
  float v37;
  float v38;
  _QWORD v40[2];

  v11 = a1;
  v40[1] = *MEMORY[0x24BDAC8D0];
  v12 = a6 - a5;
  MEMORY[0x24BDAC7A8](a1, a2);
  v14 = (char *)v40 - v13;
  if (v15)
  {
    v16 = a6 - 1;
    if (a6 >= 1)
      memcpy(v14, v11, 4 * a6);
    if (a4 >= 1)
    {
      v17 = 0;
      do
      {
        v18 = *(float *)(a3 + v17);
        *(float *)&v14[v17] = *(float *)&v11[v17] * v18;
        *(float *)&v14[4 * v16] = v18 * *(float *)&v11[4 * v16];
        v17 += 4;
        --v16;
      }
      while (4 * a4 != v17);
    }
    v11 = v14;
  }
  celt_pitch_xcorr_c((float *)v11, (const float *)v11, a2, v12, a5 + 1);
  if ((a5 & 0x80000000) == 0)
  {
    v19 = 0;
    v20 = 0;
    v21 = a6 - (uint64_t)v12;
    v22 = a5 - 1;
    v23 = v11 + 16;
    do
    {
      v24 = 0.0;
      if (v20 < v21)
      {
        v25 = (~(_DWORD)v20 + a5);
        v26 = v12;
        if (v25 < 7)
          goto LABEL_16;
        v27 = (v22 + 1) & 0x1FFFFFFF8;
        v28 = (float32x4_t *)&v23[4 * v12];
        v29 = (float32x4_t *)&v23[4 * v19 + 4 * v12];
        v30 = v25 + 1;
        v26 = (v30 & 0x1FFFFFFF8) + v12;
        do
        {
          v31 = vmulq_f32(v28[-1], v29[-1]);
          v32 = vmulq_f32(*v28, *v29);
          v24 = (float)((float)((float)((float)((float)((float)((float)(v24 + v31.f32[0]) + v31.f32[1]) + v31.f32[2])
                                              + v31.f32[3])
                                      + v32.f32[0])
                              + v32.f32[1])
                      + v32.f32[2])
              + v32.f32[3];
          v28 += 2;
          v29 += 2;
          v27 -= 8;
        }
        while (v27);
        if (v30 != (v30 & 0x1FFFFFFF8))
        {
LABEL_16:
          v33 = a6 - v26;
          v34 = (float *)&v11[4 * v26 + 4 * v19];
          v35 = (float *)&v11[4 * v26];
          do
          {
            v36 = *v35++;
            v37 = v36;
            v38 = *v34++;
            v24 = v24 + (float)(v37 * v38);
            --v33;
          }
          while (v33);
        }
      }
      a2[v20] = v24 + a2[v20];
      ++v20;
      ++v12;
      --v22;
      --v19;
    }
    while (v20 != a5 + 1);
  }
  return 0;
}

uint64_t check_control_input(_DWORD *a1)
{
  int v1;
  uint64_t v2;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  int v12;

  v1 = a1[2];
  v2 = 4294967194;
  if (v1 <= 23999)
  {
    if (v1 != 8000 && v1 != 12000 && v1 != 16000)
      return v2;
  }
  else if (v1 > 44099)
  {
    if (v1 != 48000 && v1 != 44100)
      return v2;
  }
  else if (v1 != 24000 && v1 != 32000)
  {
    return v2;
  }
  v7 = a1[5];
  if (v7 != 8000 && v7 != 16000 && v7 != 12000)
    return 4294967194;
  v8 = a1[3];
  if (v8 != 8000 && v8 != 16000 && v8 != 12000)
    return 4294967194;
  v9 = a1[4];
  if (v9 != 8000 && v9 != 16000 && v9 != 12000)
    return 4294967194;
  v2 = 4294967194;
  if (v9 > v7)
    return v2;
  if (v8 < v7)
    return v2;
  if (v9 > v8)
    return v2;
  v10 = a1[6];
  v2 = 4294967193;
  if (v10 > 0x3C || ((1 << v10) & 0x1000010000100400) == 0)
    return v2;
  if (a1[8] > 0x64u)
    return 4294967191;
  if (a1[12] > 1u)
    return 4294967188;
  if (a1[13] > 1u)
    return 4294967187;
  if (a1[10] > 1u)
    return 4294967189;
  if ((*a1 - 3) < 0xFFFFFFFE)
    return 4294967185;
  v12 = a1[1];
  v2 = 4294967185;
  if (v12 > *a1 || (v12 - 3) < 0xFFFFFFFE)
    return v2;
  if (a1[9] <= 0xAu)
    return 0;
  else
    return 4294967190;
}

void silk_CNG(char *a1, uint64_t a2, uint64_t a3, int a4)
{
  char *v6;
  int16x8_t *v7;
  char *v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int16x8_t *v18;
  uint64_t v19;
  int32x4_t v20;
  int32x4_t v21;
  uint64_t v22;
  char *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int16x8_t v27;
  uint64_t v28;
  int16x8_t *v29;
  int16x8_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  int v38;
  int *v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  unint64_t v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  BOOL v49;
  int v50;
  int v51;
  unsigned int v52;
  signed int v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  int v57;
  unsigned int v58;
  unsigned int v59;
  signed int v60;
  unsigned int v61;
  uint64_t v62;
  _DWORD *v63;
  uint64_t v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  uint64_t v82;
  int v83;
  unint64_t v84;
  int v85;
  int v86;
  int v87;
  int v88;
  unint64_t v89;
  int *v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  char *v97;
  __int128 v98;
  _OWORD *v99;
  __int128 v100;
  uint64_t v101;
  _OWORD *v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  uint64_t v116;
  int v117;
  uint64_t v118;
  int16x8_t v119;
  __int16 v120;
  __int16 v121;
  __int16 v122;
  __int16 v123;
  __int16 v124;
  __int16 v125;
  __int16 v126;
  __int16 v127;
  uint64_t v128;

  v118 = a3;
  v6 = a1;
  v128 = *MEMORY[0x24BDAC8D0];
  v7 = (int16x8_t *)(a1 + 2344);
  v8 = a1 + 2796;
  v9 = *((_DWORD *)a1 + 579);
  if (v9 != *((_DWORD *)a1 + 1045))
  {
    v10 = *((unsigned int *)a1 + 585);
    if ((int)v10 >= 1)
    {
      v11 = 0x7FFF / ((int)v10 + 1);
      if (v10 >= 0x10)
      {
        v12 = v10 & 0x7FFFFFF0;
        v13 = v11 * (v10 & 0xFFFFFFF0);
        v14 = vdupq_n_s32(v11);
        v15 = vmulq_s32(v14, (int32x4_t)xmmword_208F08E20);
        v16 = vmulq_s32(v14, (int32x4_t)xmmword_208F071C0);
        v17 = vdupq_n_s32(8 * v11);
        v18 = (int16x8_t *)(a1 + 4076);
        v19 = v10 & 0xFFFFFFF0;
        do
        {
          v20 = vaddq_s32(v15, v17);
          v21 = vaddq_s32(v16, v17);
          *v18 = vuzp1q_s16((int16x8_t)vaddq_s32(v16, v14), (int16x8_t)vaddq_s32(v15, v14));
          v18[1] = vuzp1q_s16((int16x8_t)vaddq_s32(v21, v14), (int16x8_t)vaddq_s32(v20, v14));
          v18 += 2;
          v16 = vaddq_s32(v21, v17);
          v15 = vaddq_s32(v20, v17);
          v19 -= 16;
        }
        while (v19);
        if (v12 == v10)
          goto LABEL_10;
      }
      else
      {
        v12 = 0;
        v13 = 0;
      }
      v22 = v10 - v12;
      v23 = &a1[2 * v12 + 4076];
      v24 = v13 + v11;
      do
      {
        *(_WORD *)v23 = v24;
        v23 += 2;
        v24 += v11;
        --v22;
      }
      while (v22);
    }
LABEL_10:
    *(_QWORD *)(a1 + 4172) = 0x30788000000000;
    *((_DWORD *)a1 + 1045) = v9;
  }
  if (*((_DWORD *)a1 + 1046))
    goto LABEL_34;
  if (!*((_DWORD *)a1 + 1047))
  {
    v25 = *((unsigned int *)a1 + 585);
    if ((int)v25 >= 1)
    {
      if (v25 >= 8)
      {
        v26 = v25 & 0x7FFFFFF8;
        v27 = vdupq_n_s16(0x3FDCu);
        v28 = v25 & 0xFFFFFFF8;
        do
        {
          v29 = (int16x8_t *)((char *)v7 + 1732);
          v30 = *v7++;
          *v29 = vaddq_s16(*v29, vsubhn_high_s32(vsubhn_s32(vmull_s16(*(int16x4_t *)v30.i8, *(int16x4_t *)v27.i8), vmull_s16(*(int16x4_t *)v29->i8, *(int16x4_t *)v27.i8)), vmull_high_s16(v30, v27), vmull_high_s16(*v29, v27)));
          v28 -= 8;
        }
        while (v28);
        if (v26 == v25)
          goto LABEL_21;
      }
      else
      {
        v26 = 0;
      }
      v31 = v25 - v26;
      v32 = &a1[2 * v26 + 2344];
      do
      {
        *((_WORD *)v32 + 866) += (16348 * (*(__int16 *)v32 - *((__int16 *)v32 + 866))) >> 16;
        v32 += 2;
        --v31;
      }
      while (v31);
    }
LABEL_21:
    v33 = *((unsigned int *)a1 + 581);
    if ((int)v33 < 1)
    {
      v35 = 0;
    }
    else
    {
      v34 = 0;
      v35 = 0;
      v36 = 0;
      do
      {
        if (*(_DWORD *)(a2 + 16 + 4 * v34) > v36)
        {
          v36 = *(_DWORD *)(a2 + 16 + 4 * v34);
          v35 = v34;
        }
        ++v34;
      }
      while (v33 != v34);
    }
    memmove(&v8[4 * *((int *)a1 + 583)], v8, 4 * *((_DWORD *)a1 + 583) * ((int)v33 - 1));
    a1 = (char *)memcpy(v8, &v6[4 * *((_DWORD *)v6 + 583) * v35 + 4], 4 * *((int *)v6 + 583));
    v37 = *((unsigned int *)v6 + 581);
    if ((int)v37 >= 1)
    {
      v38 = *((_DWORD *)v6 + 1043);
      v39 = (int *)(a2 + 16);
      do
      {
        v38 += (unint64_t)(4634 * (*v39 - (uint64_t)v38)) >> 16;
        *((_DWORD *)v6 + 1043) = v38;
        v41 = *v39++;
        v40 = v41;
        if (v41 < (int)((unint64_t)(46396 * v38) >> 16))
          v38 = v40;
        *((_DWORD *)v6 + 1043) = v38;
        --v37;
      }
      while (v37);
    }
  }
  if (!*((_DWORD *)v6 + 1046))
  {
    bzero(v6 + 4108, 4 * *((int *)v6 + 585));
    return;
  }
LABEL_34:
  MEMORY[0x24BDAC7A8](a1, a2);
  v44 = (char *)&v101 - v43;
  v45 = (unint64_t)(*((int *)v6 + 1068) * (uint64_t)*((__int16 *)v6 + 2126)) >> 16;
  v46 = *((_DWORD *)v6 + 1043);
  if ((int)v45 >= 0x200000 || *((int *)v6 + 1043) > 0x800000)
  {
    v54 = (v46 >> 16) * (v46 >> 16) - 32 * ((int)v45 >> 16) * ((int)v45 >> 16);
    if ((int)v54 >= 1)
    {
      v55 = __clz(v54);
      if (v55 != 24)
      {
        v49 = v54 > 0x7F;
        v56 = (v54 << (v55 + 8)) | (v54 >> (24 - v55));
        v54 <<= v55 - 24;
        if (v49)
          LOBYTE(v54) = v56;
      }
      v57 = v54 & 0x7F;
      if ((v55 & 1) != 0)
        v58 = 0x8000;
      else
        v58 = 46214;
      v53 = (((213 * v57) | 0x10000) * (v58 >> (v55 >> 1))) & 0xFFFF0000;
      goto LABEL_53;
    }
  }
  else
  {
    v47 = ((unint64_t)(v46 * (uint64_t)v46) >> 16)
        - (((unint64_t)((int)v45 * (uint64_t)(int)v45) >> 11) & 0xFFFFFFE0);
    if ((int)v47 >= 1)
    {
      v48 = __clz(v47);
      if (v48 != 24)
      {
        v49 = v47 > 0x7F;
        v50 = (v47 << (v48 + 8)) | (v47 >> (24 - v48));
        v47 <<= v48 - 24;
        if (v49)
          LOBYTE(v47) = v50;
      }
      v51 = v47 & 0x7F;
      if ((v48 & 1) != 0)
        v52 = 0x8000;
      else
        v52 = 46214;
      v53 = ((v52 >> (v48 >> 1)) + ((213 * (v52 >> (v48 >> 1)) * v51) >> 16)) << 8;
      goto LABEL_53;
    }
  }
  v53 = 0;
LABEL_53:
  v59 = 255;
  do
  {
    v60 = v59;
    v59 >>= 1;
  }
  while (v60 > a4);
  v61 = *((_DWORD *)v6 + 1044);
  v62 = a4;
  v103 = v42;
  if (a4 >= 1)
  {
    v63 = v44 + 64;
    v64 = a4;
    do
    {
      v61 = 196314165 * v61 + 907633515;
      *v63++ = *(_DWORD *)&v8[4 * (v60 & HIBYTE(v61))];
      --v64;
    }
    while (v64);
  }
  *((_DWORD *)v6 + 1044) = v61;
  silk_NLSF2A(&v119, (__int16 *)v6 + 2038, *((_DWORD *)v6 + 585));
  v102 = v6 + 4108;
  v65 = *(_OWORD *)(v6 + 4124);
  *(_OWORD *)v44 = *(_OWORD *)(v6 + 4108);
  *((_OWORD *)v44 + 1) = v65;
  v66 = *(_OWORD *)(v6 + 4156);
  *((_OWORD *)v44 + 2) = *(_OWORD *)(v6 + 4140);
  *((_OWORD *)v44 + 3) = v66;
  v104 = a4;
  if (a4 >= 1)
  {
    v67 = 0;
    v68 = *((_DWORD *)v6 + 585);
    v116 = v119.i16[0];
    v117 = v68;
    v115 = v68 >> 1;
    v113 = v119.i16[2];
    v114 = v119.i16[1];
    v111 = v119.i16[4];
    v112 = v119.i16[3];
    v69 = v119.i16[5];
    v70 = v119.i16[6];
    v71 = v119.i16[7];
    v72 = v120;
    v73 = v121;
    v109 = v123;
    v110 = v122;
    v107 = v125;
    v108 = v124;
    v105 = v127;
    v106 = v126;
    v74 = v53 >> 6;
    v75 = *((_DWORD *)v44 + 15);
    v76 = *((_DWORD *)v44 + 13);
    v77 = *((_DWORD *)v44 + 11);
    v78 = *((_DWORD *)v44 + 9);
    v79 = *((_DWORD *)v44 + 7);
    v80 = v68 >> 1;
    do
    {
      v88 = v79;
      v89 = (unint64_t)((int)v116 * (uint64_t)v75) >> 16;
      v90 = (int *)&v44[4 * v67];
      v91 = (int)v113 * (uint64_t)v76;
      v76 = v90[14];
      v92 = (int)v111 * (uint64_t)v77;
      v77 = v90[12];
      v93 = v92 >> 16;
      v94 = v70 * (uint64_t)v78;
      v78 = v90[10];
      v95 = v94 >> 16;
      v79 = v90[8];
      v81 = v80
          + ((unint64_t)(v72 * (uint64_t)v88) >> 16)
          + v95
          + v93
          + (v91 >> 16)
          + v89
          + ((unint64_t)(v76 * (uint64_t)(int)v114) >> 16)
          + ((unint64_t)(v77 * (uint64_t)(int)v112) >> 16)
          + ((unint64_t)(v78 * (uint64_t)v69) >> 16)
          + ((unint64_t)(v79 * (uint64_t)v71) >> 16)
          + ((unint64_t)(v90[6] * (uint64_t)v73) >> 16);
      v96 = v67 + 1;
      if (v117 == 16)
        v81 += ((unint64_t)(v90[5] * (uint64_t)(int)v110) >> 16)
             + ((unint64_t)(v90[4] * (uint64_t)(int)v109) >> 16)
             + ((unint64_t)(v90[3] * (uint64_t)(int)v108) >> 16)
             + ((unint64_t)(v90[2] * (uint64_t)(int)v107) >> 16)
             + ((unint64_t)(*(int *)&v44[4 * v67 + 4] * (uint64_t)(int)v106) >> 16)
             + ((unint64_t)(*v90 * (uint64_t)(int)v105) >> 16);
      v82 = 4 * (v67 + 16);
      if (v81 <= -134217728)
        v83 = -134217728;
      else
        v83 = v81;
      if (v83 >= 0x7FFFFFF)
        v83 = 0x7FFFFFF;
      v75 = vqadds_s32(*(_DWORD *)&v44[v82], 16 * v83);
      *(_DWORD *)&v44[v82] = v75;
      v84 = (unint64_t)(v74 * (uint64_t)v75) >> 16;
      v85 = (((int)v84 >> 7) + 1) >> 1;
      if ((int)v84 < -8388736)
        v85 = -32768;
      if ((int)v84 <= 8388479)
        v86 = v85;
      else
        v86 = 0x7FFF;
      v87 = v86 + *(__int16 *)(v118 + 2 * v67);
      if (v87 <= -32768)
        v87 = -32768;
      if (v87 >= 0x7FFF)
        LOWORD(v87) = 0x7FFF;
      *(_WORD *)(v118 + 2 * v67++) = v87;
    }
    while (v96 != v62);
  }
  v97 = &v44[4 * v104];
  v98 = *((_OWORD *)v97 + 1);
  v99 = v102;
  *v102 = *(_OWORD *)v97;
  v99[1] = v98;
  v100 = *((_OWORD *)v97 + 3);
  v99[2] = *((_OWORD *)v97 + 2);
  v99[3] = v100;
}

uint64_t *silk_encode_signs(uint64_t *result, uint64_t a2, int a3, int a4, int a5, int *a6)
{
  uint64_t *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  char v11;
  int v12;
  unsigned int v13;
  _BYTE v14[2];

  v14[1] = 0;
  if (a3 >= 8)
  {
    v7 = result;
    v8 = (char *)&silk_sign_iCDF + 8 * (((a5 << 16) + (a4 << 17)) >> 16) - (((a5 << 16) + (a4 << 17)) >> 16);
    v9 = (a3 + 8) >> 4;
    v10 = (_BYTE *)(a2 + 7);
    do
    {
      v12 = *a6++;
      v11 = v12;
      if (v12 >= 1)
      {
        v13 = v11 & 0x1F;
        if (v13 >= 6)
          v13 = 6;
        v14[0] = v8[v13];
        if (*(v10 - 7))
          result = ec_enc_icdf(v7, (*(v10 - 7) & 0x80) == 0, (uint64_t)v14, 8);
        if (*(v10 - 6))
          result = ec_enc_icdf(v7, (*(v10 - 6) & 0x80) == 0, (uint64_t)v14, 8);
        if (*(v10 - 5))
          result = ec_enc_icdf(v7, (*(v10 - 5) & 0x80) == 0, (uint64_t)v14, 8);
        if (*(v10 - 4))
          result = ec_enc_icdf(v7, (*(v10 - 4) & 0x80) == 0, (uint64_t)v14, 8);
        if (*(v10 - 3))
          result = ec_enc_icdf(v7, (*(v10 - 3) & 0x80) == 0, (uint64_t)v14, 8);
        if (*(v10 - 2))
          result = ec_enc_icdf(v7, (*(v10 - 2) & 0x80) == 0, (uint64_t)v14, 8);
        if (*(v10 - 1))
          result = ec_enc_icdf(v7, (*(v10 - 1) & 0x80) == 0, (uint64_t)v14, 8);
        if (*v10)
          result = ec_enc_icdf(v7, (*v10 & 0x80) == 0, (uint64_t)v14, 8);
        if (v10[1])
          result = ec_enc_icdf(v7, (v10[1] & 0x80) == 0, (uint64_t)v14, 8);
        if (v10[2])
          result = ec_enc_icdf(v7, (v10[2] & 0x80) == 0, (uint64_t)v14, 8);
        if (v10[3])
          result = ec_enc_icdf(v7, (v10[3] & 0x80) == 0, (uint64_t)v14, 8);
        if (v10[4])
          result = ec_enc_icdf(v7, (v10[4] & 0x80) == 0, (uint64_t)v14, 8);
        if (v10[5])
          result = ec_enc_icdf(v7, (v10[5] & 0x80) == 0, (uint64_t)v14, 8);
        if (v10[6])
          result = ec_enc_icdf(v7, (v10[6] & 0x80) == 0, (uint64_t)v14, 8);
        if (v10[7])
          result = ec_enc_icdf(v7, (v10[7] & 0x80) == 0, (uint64_t)v14, 8);
        if (v10[8])
          result = ec_enc_icdf(v7, (v10[8] & 0x80) == 0, (uint64_t)v14, 8);
      }
      v10 += 16;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t *silk_decode_signs(uint64_t *result, __int16 *a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  unint64_t v33;
  int v34;
  unint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  unsigned int v46;
  unint64_t v47;
  int v48;
  unint64_t v49;
  int v50;
  uint64_t v51;
  int v52;
  int v53;
  uint64_t v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  unsigned int v60;
  unint64_t v61;
  int v62;
  unint64_t v63;
  int v64;
  uint64_t v65;
  int v66;
  int v67;
  uint64_t v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  int v73;
  unsigned int v74;
  unint64_t v75;
  int v76;
  unint64_t v77;
  int v78;
  uint64_t v79;
  int v80;
  int v81;
  uint64_t v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  unsigned int v88;
  unint64_t v89;
  int v90;
  unint64_t v91;
  int v92;
  uint64_t v93;
  int v94;
  int v95;
  uint64_t v96;
  unsigned int v97;
  unsigned int v98;
  unsigned int v99;
  unsigned int v100;
  int v101;
  unsigned int v102;
  unint64_t v103;
  int v104;
  unint64_t v105;
  int v106;
  uint64_t v107;
  int v108;
  int v109;
  uint64_t v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  unsigned int v114;
  int v115;
  unsigned int v116;
  unint64_t v117;
  int v118;
  unint64_t v119;
  int v120;
  uint64_t v121;
  int v122;
  int v123;
  uint64_t v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  unsigned int v128;
  int v129;
  unsigned int v130;
  unint64_t v131;
  int v132;
  unint64_t v133;
  int v134;
  uint64_t v135;
  int v136;
  int v137;
  uint64_t v138;
  unsigned int v139;
  unsigned int v140;
  unsigned int v141;
  unsigned int v142;
  int v143;
  unsigned int v144;
  unint64_t v145;
  int v146;
  unint64_t v147;
  int v148;
  uint64_t v149;
  int v150;
  int v151;
  uint64_t v152;
  unsigned int v153;
  unsigned int v154;
  unsigned int v155;
  unsigned int v156;
  int v157;
  unsigned int v158;
  unint64_t v159;
  int v160;
  unint64_t v161;
  int v162;
  uint64_t v163;
  int v164;
  int v165;
  uint64_t v166;
  unsigned int v167;
  unsigned int v168;
  unsigned int v169;
  unsigned int v170;
  int v171;
  unsigned int v172;
  unint64_t v173;
  int v174;
  unint64_t v175;
  int v176;
  uint64_t v177;
  int v178;
  int v179;
  uint64_t v180;
  unsigned int v181;
  unsigned int v182;
  unsigned int v183;
  unsigned int v184;
  int v185;
  unsigned int v186;
  unint64_t v187;
  int v188;
  unint64_t v189;
  int v190;
  uint64_t v191;
  int v192;
  int v193;
  uint64_t v194;
  unsigned int v195;
  unsigned int v196;
  unsigned int v197;
  unsigned int v198;
  int v199;
  unsigned int v200;
  unint64_t v201;
  int v202;
  unint64_t v203;
  int v204;
  uint64_t v205;
  int v206;
  int v207;
  uint64_t v208;
  unsigned int v209;
  unsigned int v210;
  unsigned int v211;
  unsigned int v212;
  int v213;
  unsigned int v214;
  unint64_t v215;
  int v216;
  unint64_t v217;
  int v218;
  uint64_t v219;
  int v220;
  int v221;
  uint64_t v222;
  unsigned int v223;
  unsigned int v224;
  unsigned int v225;
  unsigned int v226;
  int v227;
  unsigned int v228;
  unint64_t v229;
  int v230;
  unint64_t v231;
  int v232;
  uint64_t v233;
  int v234;
  _BYTE v235[2];

  v235[1] = 0;
  if (a3 >= 8)
  {
    v6 = 0;
    v7 = (char *)&silk_sign_iCDF + 8 * (((a5 << 16) + (a4 << 17)) >> 16) - (((a5 << 16) + (a4 << 17)) >> 16);
    v8 = (a3 + 8) >> 4;
    do
    {
      if (*(int *)(a6 + 4 * v6) >= 1)
      {
        v9 = *(_DWORD *)(a6 + 4 * v6) & 0x1F;
        if (v9 >= 6)
          v9 = 6;
        v235[0] = v7[v9];
        v10 = *a2;
        if (v10 >= 1)
        {
          v11 = 0;
          v12 = *((_DWORD *)result + 8);
          v13 = *((_DWORD *)result + 9);
          v14 = v12 >> 8;
          do
          {
            v15 = v12;
            v12 = v14 * v235[v11++];
            v16 = v13 - v12;
          }
          while (v13 < v12);
          v17 = v15 - v12;
          *((_DWORD *)result + 8) = v15 - v12;
          *((_DWORD *)result + 9) = v16;
          if (v15 - v12 < 0x800001)
          {
            v18 = *((unsigned int *)result + 2);
            v19 = *((_DWORD *)result + 11);
            v20 = *((unsigned int *)result + 7);
            v21 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v21;
              *((_DWORD *)result + 8) = v17 << 8;
              if (v20 < v18)
              {
                v22 = *result;
                *((_DWORD *)result + 7) = v20 + 1;
                v23 = *(unsigned __int8 *)(v22 + v20++);
              }
              else
              {
                v23 = 0;
              }
              v16 = (((v16 & 0x7FFFFF) << 8) | ((v23 | (v19 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v23;
              *((_DWORD *)result + 9) = v16;
              v21 += 8;
              v19 = v23;
              v24 = v17 > 0x8000;
              v17 <<= 8;
            }
            while (!v24);
          }
          *a2 = (2 * (v11 - 1) - 1) * v10;
        }
        v25 = a2[1];
        if (v25 >= 1)
        {
          v26 = 0;
          v27 = *((_DWORD *)result + 8);
          v28 = *((_DWORD *)result + 9);
          v29 = v27 >> 8;
          do
          {
            v30 = v27;
            v27 = v29 * v235[v26++];
            v31 = v28 - v27;
          }
          while (v28 < v27);
          v32 = v30 - v27;
          *((_DWORD *)result + 8) = v30 - v27;
          *((_DWORD *)result + 9) = v31;
          if (v30 - v27 < 0x800001)
          {
            v33 = *((unsigned int *)result + 2);
            v34 = *((_DWORD *)result + 11);
            v35 = *((unsigned int *)result + 7);
            v36 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v36;
              *((_DWORD *)result + 8) = v32 << 8;
              if (v35 < v33)
              {
                v37 = *result;
                *((_DWORD *)result + 7) = v35 + 1;
                v38 = *(unsigned __int8 *)(v37 + v35++);
              }
              else
              {
                v38 = 0;
              }
              v31 = (((v31 & 0x7FFFFF) << 8) | ((v38 | (v34 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v38;
              *((_DWORD *)result + 9) = v31;
              v36 += 8;
              v34 = v38;
              v24 = v32 > 0x8000;
              v32 <<= 8;
            }
            while (!v24);
          }
          a2[1] = (2 * (v26 - 1) - 1) * v25;
        }
        v39 = a2[2];
        if (v39 >= 1)
        {
          v40 = 0;
          v41 = *((_DWORD *)result + 8);
          v42 = *((_DWORD *)result + 9);
          v43 = v41 >> 8;
          do
          {
            v44 = v41;
            v41 = v43 * v235[v40++];
            v45 = v42 - v41;
          }
          while (v42 < v41);
          v46 = v44 - v41;
          *((_DWORD *)result + 8) = v44 - v41;
          *((_DWORD *)result + 9) = v45;
          if (v44 - v41 < 0x800001)
          {
            v47 = *((unsigned int *)result + 2);
            v48 = *((_DWORD *)result + 11);
            v49 = *((unsigned int *)result + 7);
            v50 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v50;
              *((_DWORD *)result + 8) = v46 << 8;
              if (v49 < v47)
              {
                v51 = *result;
                *((_DWORD *)result + 7) = v49 + 1;
                v52 = *(unsigned __int8 *)(v51 + v49++);
              }
              else
              {
                v52 = 0;
              }
              v45 = (((v45 & 0x7FFFFF) << 8) | ((v52 | (v48 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v52;
              *((_DWORD *)result + 9) = v45;
              v50 += 8;
              v48 = v52;
              v24 = v46 > 0x8000;
              v46 <<= 8;
            }
            while (!v24);
          }
          a2[2] = (2 * (v40 - 1) - 1) * v39;
        }
        v53 = a2[3];
        if (v53 >= 1)
        {
          v54 = 0;
          v55 = *((_DWORD *)result + 8);
          v56 = *((_DWORD *)result + 9);
          v57 = v55 >> 8;
          do
          {
            v58 = v55;
            v55 = v57 * v235[v54++];
            v59 = v56 - v55;
          }
          while (v56 < v55);
          v60 = v58 - v55;
          *((_DWORD *)result + 8) = v58 - v55;
          *((_DWORD *)result + 9) = v59;
          if (v58 - v55 < 0x800001)
          {
            v61 = *((unsigned int *)result + 2);
            v62 = *((_DWORD *)result + 11);
            v63 = *((unsigned int *)result + 7);
            v64 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v64;
              *((_DWORD *)result + 8) = v60 << 8;
              if (v63 < v61)
              {
                v65 = *result;
                *((_DWORD *)result + 7) = v63 + 1;
                v66 = *(unsigned __int8 *)(v65 + v63++);
              }
              else
              {
                v66 = 0;
              }
              v59 = (((v59 & 0x7FFFFF) << 8) | ((v66 | (v62 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v66;
              *((_DWORD *)result + 9) = v59;
              v64 += 8;
              v62 = v66;
              v24 = v60 > 0x8000;
              v60 <<= 8;
            }
            while (!v24);
          }
          a2[3] = (2 * (v54 - 1) - 1) * v53;
        }
        v67 = a2[4];
        if (v67 >= 1)
        {
          v68 = 0;
          v69 = *((_DWORD *)result + 8);
          v70 = *((_DWORD *)result + 9);
          v71 = v69 >> 8;
          do
          {
            v72 = v69;
            v69 = v71 * v235[v68++];
            v73 = v70 - v69;
          }
          while (v70 < v69);
          v74 = v72 - v69;
          *((_DWORD *)result + 8) = v72 - v69;
          *((_DWORD *)result + 9) = v73;
          if (v72 - v69 < 0x800001)
          {
            v75 = *((unsigned int *)result + 2);
            v76 = *((_DWORD *)result + 11);
            v77 = *((unsigned int *)result + 7);
            v78 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v78;
              *((_DWORD *)result + 8) = v74 << 8;
              if (v77 < v75)
              {
                v79 = *result;
                *((_DWORD *)result + 7) = v77 + 1;
                v80 = *(unsigned __int8 *)(v79 + v77++);
              }
              else
              {
                v80 = 0;
              }
              v73 = (((v73 & 0x7FFFFF) << 8) | ((v80 | (v76 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v80;
              *((_DWORD *)result + 9) = v73;
              v78 += 8;
              v76 = v80;
              v24 = v74 > 0x8000;
              v74 <<= 8;
            }
            while (!v24);
          }
          a2[4] = (2 * (v68 - 1) - 1) * v67;
        }
        v81 = a2[5];
        if (v81 >= 1)
        {
          v82 = 0;
          v83 = *((_DWORD *)result + 8);
          v84 = *((_DWORD *)result + 9);
          v85 = v83 >> 8;
          do
          {
            v86 = v83;
            v83 = v85 * v235[v82++];
            v87 = v84 - v83;
          }
          while (v84 < v83);
          v88 = v86 - v83;
          *((_DWORD *)result + 8) = v86 - v83;
          *((_DWORD *)result + 9) = v87;
          if (v86 - v83 < 0x800001)
          {
            v89 = *((unsigned int *)result + 2);
            v90 = *((_DWORD *)result + 11);
            v91 = *((unsigned int *)result + 7);
            v92 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v92;
              *((_DWORD *)result + 8) = v88 << 8;
              if (v91 < v89)
              {
                v93 = *result;
                *((_DWORD *)result + 7) = v91 + 1;
                v94 = *(unsigned __int8 *)(v93 + v91++);
              }
              else
              {
                v94 = 0;
              }
              v87 = (((v87 & 0x7FFFFF) << 8) | ((v94 | (v90 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v94;
              *((_DWORD *)result + 9) = v87;
              v92 += 8;
              v90 = v94;
              v24 = v88 > 0x8000;
              v88 <<= 8;
            }
            while (!v24);
          }
          a2[5] = (2 * (v82 - 1) - 1) * v81;
        }
        v95 = a2[6];
        if (v95 >= 1)
        {
          v96 = 0;
          v97 = *((_DWORD *)result + 8);
          v98 = *((_DWORD *)result + 9);
          v99 = v97 >> 8;
          do
          {
            v100 = v97;
            v97 = v99 * v235[v96++];
            v101 = v98 - v97;
          }
          while (v98 < v97);
          v102 = v100 - v97;
          *((_DWORD *)result + 8) = v100 - v97;
          *((_DWORD *)result + 9) = v101;
          if (v100 - v97 < 0x800001)
          {
            v103 = *((unsigned int *)result + 2);
            v104 = *((_DWORD *)result + 11);
            v105 = *((unsigned int *)result + 7);
            v106 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v106;
              *((_DWORD *)result + 8) = v102 << 8;
              if (v105 < v103)
              {
                v107 = *result;
                *((_DWORD *)result + 7) = v105 + 1;
                v108 = *(unsigned __int8 *)(v107 + v105++);
              }
              else
              {
                v108 = 0;
              }
              v101 = (((v101 & 0x7FFFFF) << 8) | ((v108 | (v104 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v108;
              *((_DWORD *)result + 9) = v101;
              v106 += 8;
              v104 = v108;
              v24 = v102 > 0x8000;
              v102 <<= 8;
            }
            while (!v24);
          }
          a2[6] = (2 * (v96 - 1) - 1) * v95;
        }
        v109 = a2[7];
        if (v109 >= 1)
        {
          v110 = 0;
          v111 = *((_DWORD *)result + 8);
          v112 = *((_DWORD *)result + 9);
          v113 = v111 >> 8;
          do
          {
            v114 = v111;
            v111 = v113 * v235[v110++];
            v115 = v112 - v111;
          }
          while (v112 < v111);
          v116 = v114 - v111;
          *((_DWORD *)result + 8) = v114 - v111;
          *((_DWORD *)result + 9) = v115;
          if (v114 - v111 < 0x800001)
          {
            v117 = *((unsigned int *)result + 2);
            v118 = *((_DWORD *)result + 11);
            v119 = *((unsigned int *)result + 7);
            v120 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v120;
              *((_DWORD *)result + 8) = v116 << 8;
              if (v119 < v117)
              {
                v121 = *result;
                *((_DWORD *)result + 7) = v119 + 1;
                v122 = *(unsigned __int8 *)(v121 + v119++);
              }
              else
              {
                v122 = 0;
              }
              v115 = (((v115 & 0x7FFFFF) << 8) | ((v122 | (v118 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v122;
              *((_DWORD *)result + 9) = v115;
              v120 += 8;
              v118 = v122;
              v24 = v116 > 0x8000;
              v116 <<= 8;
            }
            while (!v24);
          }
          a2[7] = (2 * (v110 - 1) - 1) * v109;
        }
        v123 = a2[8];
        if (v123 >= 1)
        {
          v124 = 0;
          v125 = *((_DWORD *)result + 8);
          v126 = *((_DWORD *)result + 9);
          v127 = v125 >> 8;
          do
          {
            v128 = v125;
            v125 = v127 * v235[v124++];
            v129 = v126 - v125;
          }
          while (v126 < v125);
          v130 = v128 - v125;
          *((_DWORD *)result + 8) = v128 - v125;
          *((_DWORD *)result + 9) = v129;
          if (v128 - v125 < 0x800001)
          {
            v131 = *((unsigned int *)result + 2);
            v132 = *((_DWORD *)result + 11);
            v133 = *((unsigned int *)result + 7);
            v134 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v134;
              *((_DWORD *)result + 8) = v130 << 8;
              if (v133 < v131)
              {
                v135 = *result;
                *((_DWORD *)result + 7) = v133 + 1;
                v136 = *(unsigned __int8 *)(v135 + v133++);
              }
              else
              {
                v136 = 0;
              }
              v129 = (((v129 & 0x7FFFFF) << 8) | ((v136 | (v132 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v136;
              *((_DWORD *)result + 9) = v129;
              v134 += 8;
              v132 = v136;
              v24 = v130 > 0x8000;
              v130 <<= 8;
            }
            while (!v24);
          }
          a2[8] = (2 * (v124 - 1) - 1) * v123;
        }
        v137 = a2[9];
        if (v137 >= 1)
        {
          v138 = 0;
          v139 = *((_DWORD *)result + 8);
          v140 = *((_DWORD *)result + 9);
          v141 = v139 >> 8;
          do
          {
            v142 = v139;
            v139 = v141 * v235[v138++];
            v143 = v140 - v139;
          }
          while (v140 < v139);
          v144 = v142 - v139;
          *((_DWORD *)result + 8) = v142 - v139;
          *((_DWORD *)result + 9) = v143;
          if (v142 - v139 < 0x800001)
          {
            v145 = *((unsigned int *)result + 2);
            v146 = *((_DWORD *)result + 11);
            v147 = *((unsigned int *)result + 7);
            v148 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v148;
              *((_DWORD *)result + 8) = v144 << 8;
              if (v147 < v145)
              {
                v149 = *result;
                *((_DWORD *)result + 7) = v147 + 1;
                v150 = *(unsigned __int8 *)(v149 + v147++);
              }
              else
              {
                v150 = 0;
              }
              v143 = (((v143 & 0x7FFFFF) << 8) | ((v150 | (v146 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v150;
              *((_DWORD *)result + 9) = v143;
              v148 += 8;
              v146 = v150;
              v24 = v144 > 0x8000;
              v144 <<= 8;
            }
            while (!v24);
          }
          a2[9] = (2 * (v138 - 1) - 1) * v137;
        }
        v151 = a2[10];
        if (v151 >= 1)
        {
          v152 = 0;
          v153 = *((_DWORD *)result + 8);
          v154 = *((_DWORD *)result + 9);
          v155 = v153 >> 8;
          do
          {
            v156 = v153;
            v153 = v155 * v235[v152++];
            v157 = v154 - v153;
          }
          while (v154 < v153);
          v158 = v156 - v153;
          *((_DWORD *)result + 8) = v156 - v153;
          *((_DWORD *)result + 9) = v157;
          if (v156 - v153 < 0x800001)
          {
            v159 = *((unsigned int *)result + 2);
            v160 = *((_DWORD *)result + 11);
            v161 = *((unsigned int *)result + 7);
            v162 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v162;
              *((_DWORD *)result + 8) = v158 << 8;
              if (v161 < v159)
              {
                v163 = *result;
                *((_DWORD *)result + 7) = v161 + 1;
                v164 = *(unsigned __int8 *)(v163 + v161++);
              }
              else
              {
                v164 = 0;
              }
              v157 = (((v157 & 0x7FFFFF) << 8) | ((v164 | (v160 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v164;
              *((_DWORD *)result + 9) = v157;
              v162 += 8;
              v160 = v164;
              v24 = v158 > 0x8000;
              v158 <<= 8;
            }
            while (!v24);
          }
          a2[10] = (2 * (v152 - 1) - 1) * v151;
        }
        v165 = a2[11];
        if (v165 >= 1)
        {
          v166 = 0;
          v167 = *((_DWORD *)result + 8);
          v168 = *((_DWORD *)result + 9);
          v169 = v167 >> 8;
          do
          {
            v170 = v167;
            v167 = v169 * v235[v166++];
            v171 = v168 - v167;
          }
          while (v168 < v167);
          v172 = v170 - v167;
          *((_DWORD *)result + 8) = v170 - v167;
          *((_DWORD *)result + 9) = v171;
          if (v170 - v167 < 0x800001)
          {
            v173 = *((unsigned int *)result + 2);
            v174 = *((_DWORD *)result + 11);
            v175 = *((unsigned int *)result + 7);
            v176 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v176;
              *((_DWORD *)result + 8) = v172 << 8;
              if (v175 < v173)
              {
                v177 = *result;
                *((_DWORD *)result + 7) = v175 + 1;
                v178 = *(unsigned __int8 *)(v177 + v175++);
              }
              else
              {
                v178 = 0;
              }
              v171 = (((v171 & 0x7FFFFF) << 8) | ((v178 | (v174 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v178;
              *((_DWORD *)result + 9) = v171;
              v176 += 8;
              v174 = v178;
              v24 = v172 > 0x8000;
              v172 <<= 8;
            }
            while (!v24);
          }
          a2[11] = (2 * (v166 - 1) - 1) * v165;
        }
        v179 = a2[12];
        if (v179 >= 1)
        {
          v180 = 0;
          v181 = *((_DWORD *)result + 8);
          v182 = *((_DWORD *)result + 9);
          v183 = v181 >> 8;
          do
          {
            v184 = v181;
            v181 = v183 * v235[v180++];
            v185 = v182 - v181;
          }
          while (v182 < v181);
          v186 = v184 - v181;
          *((_DWORD *)result + 8) = v184 - v181;
          *((_DWORD *)result + 9) = v185;
          if (v184 - v181 < 0x800001)
          {
            v187 = *((unsigned int *)result + 2);
            v188 = *((_DWORD *)result + 11);
            v189 = *((unsigned int *)result + 7);
            v190 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v190;
              *((_DWORD *)result + 8) = v186 << 8;
              if (v189 < v187)
              {
                v191 = *result;
                *((_DWORD *)result + 7) = v189 + 1;
                v192 = *(unsigned __int8 *)(v191 + v189++);
              }
              else
              {
                v192 = 0;
              }
              v185 = (((v185 & 0x7FFFFF) << 8) | ((v192 | (v188 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v192;
              *((_DWORD *)result + 9) = v185;
              v190 += 8;
              v188 = v192;
              v24 = v186 > 0x8000;
              v186 <<= 8;
            }
            while (!v24);
          }
          a2[12] = (2 * (v180 - 1) - 1) * v179;
        }
        v193 = a2[13];
        if (v193 >= 1)
        {
          v194 = 0;
          v195 = *((_DWORD *)result + 8);
          v196 = *((_DWORD *)result + 9);
          v197 = v195 >> 8;
          do
          {
            v198 = v195;
            v195 = v197 * v235[v194++];
            v199 = v196 - v195;
          }
          while (v196 < v195);
          v200 = v198 - v195;
          *((_DWORD *)result + 8) = v198 - v195;
          *((_DWORD *)result + 9) = v199;
          if (v198 - v195 < 0x800001)
          {
            v201 = *((unsigned int *)result + 2);
            v202 = *((_DWORD *)result + 11);
            v203 = *((unsigned int *)result + 7);
            v204 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v204;
              *((_DWORD *)result + 8) = v200 << 8;
              if (v203 < v201)
              {
                v205 = *result;
                *((_DWORD *)result + 7) = v203 + 1;
                v206 = *(unsigned __int8 *)(v205 + v203++);
              }
              else
              {
                v206 = 0;
              }
              v199 = (((v199 & 0x7FFFFF) << 8) | ((v206 | (v202 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v206;
              *((_DWORD *)result + 9) = v199;
              v204 += 8;
              v202 = v206;
              v24 = v200 > 0x8000;
              v200 <<= 8;
            }
            while (!v24);
          }
          a2[13] = (2 * (v194 - 1) - 1) * v193;
        }
        v207 = a2[14];
        if (v207 >= 1)
        {
          v208 = 0;
          v209 = *((_DWORD *)result + 8);
          v210 = *((_DWORD *)result + 9);
          v211 = v209 >> 8;
          do
          {
            v212 = v209;
            v209 = v211 * v235[v208++];
            v213 = v210 - v209;
          }
          while (v210 < v209);
          v214 = v212 - v209;
          *((_DWORD *)result + 8) = v212 - v209;
          *((_DWORD *)result + 9) = v213;
          if (v212 - v209 < 0x800001)
          {
            v215 = *((unsigned int *)result + 2);
            v216 = *((_DWORD *)result + 11);
            v217 = *((unsigned int *)result + 7);
            v218 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v218;
              *((_DWORD *)result + 8) = v214 << 8;
              if (v217 < v215)
              {
                v219 = *result;
                *((_DWORD *)result + 7) = v217 + 1;
                v220 = *(unsigned __int8 *)(v219 + v217++);
              }
              else
              {
                v220 = 0;
              }
              v213 = (((v213 & 0x7FFFFF) << 8) | ((v220 | (v216 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v220;
              *((_DWORD *)result + 9) = v213;
              v218 += 8;
              v216 = v220;
              v24 = v214 > 0x8000;
              v214 <<= 8;
            }
            while (!v24);
          }
          a2[14] = (2 * (v208 - 1) - 1) * v207;
        }
        v221 = a2[15];
        if (v221 >= 1)
        {
          v222 = 0;
          v223 = *((_DWORD *)result + 8);
          v224 = *((_DWORD *)result + 9);
          v225 = v223 >> 8;
          do
          {
            v226 = v223;
            v223 = v225 * v235[v222++];
            v227 = v224 - v223;
          }
          while (v224 < v223);
          v228 = v226 - v223;
          *((_DWORD *)result + 8) = v226 - v223;
          *((_DWORD *)result + 9) = v227;
          if (v226 - v223 < 0x800001)
          {
            v229 = *((unsigned int *)result + 2);
            v230 = *((_DWORD *)result + 11);
            v231 = *((unsigned int *)result + 7);
            v232 = *((_DWORD *)result + 6) + 8;
            do
            {
              *((_DWORD *)result + 6) = v232;
              *((_DWORD *)result + 8) = v228 << 8;
              if (v231 < v229)
              {
                v233 = *result;
                *((_DWORD *)result + 7) = v231 + 1;
                v234 = *(unsigned __int8 *)(v233 + v231++);
              }
              else
              {
                v234 = 0;
              }
              v227 = (((v227 & 0x7FFFFF) << 8) | ((v234 | (v230 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)result + 11) = v234;
              *((_DWORD *)result + 9) = v227;
              v232 += 8;
              v230 = v234;
              v24 = v228 > 0x8000;
              v228 <<= 8;
            }
            while (!v24);
          }
          a2[15] = (2 * (v222 - 1) - 1) * v221;
        }
      }
      a2 += 16;
      ++v6;
    }
    while (v6 != v8);
  }
  return result;
}

uint64_t silk_control_audio_bandwidth(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  int v4;
  int v5;
  int v6;
  int v7;
  int v10;
  int v11;
  int v12;
  int v13;

  result = *(unsigned int *)(a1 + 4576);
  if ((_DWORD)result)
  {
    if ((_DWORD)result << 16)
      goto LABEL_3;
LABEL_17:
    v11 = *(_DWORD *)(a1 + 4572);
    v10 = *(_DWORD *)(a1 + 4556);
    if (v11 < v10)
      v10 = v11;
    return (v10 / 1000);
  }
  result = *(unsigned int *)(a1 + 32);
  if (!((_DWORD)result << 16))
    goto LABEL_17;
LABEL_3:
  v4 = 1000 * (__int16)result;
  v5 = *(_DWORD *)(a1 + 4556);
  v6 = *(_DWORD *)(a1 + 4564);
  v7 = *(_DWORD *)(a1 + 4568);
  if (v4 > v5 || v4 > v6 || v4 < v7)
  {
    if (v5 >= v6)
      v10 = *(_DWORD *)(a1 + 4564);
    else
      v10 = *(_DWORD *)(a1 + 4556);
    if (v10 <= v7)
      v10 = v7;
    return (v10 / 1000);
  }
  v12 = *(_DWORD *)(a1 + 24);
  if (v12 >= 256)
    *(_DWORD *)(a1 + 28) = 0;
  if (*(_DWORD *)(a1 + 4536) || a2[16])
  {
    v13 = *(_DWORD *)(a1 + 4572);
    if (v4 <= v13)
    {
      if (v4 >= v13)
      {
        if ((*(_DWORD *)(a1 + 28) & 0x80000000) == 0)
          return result;
      }
      else
      {
        if (a2[16])
        {
          if ((_DWORD)result == 8)
            result = 12;
          else
            result = 16;
          *(_QWORD *)(a1 + 16) = 0;
          *(_QWORD *)(a1 + 24) = 0x100000000;
          return result;
        }
        if (!*(_DWORD *)(a1 + 28))
        {
LABEL_44:
          a2[22] = 1;
          a2[14] -= 5 * a2[14] / (a2[6] + 5);
          return result;
        }
      }
      *(_DWORD *)(a1 + 28) = 1;
      return result;
    }
    if (*(_DWORD *)(a1 + 28))
    {
      if (!a2[16])
      {
        if (v12 <= 0)
          goto LABEL_44;
LABEL_41:
        *(_DWORD *)(a1 + 28) = -2;
        return result;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 24) = 256;
      *(_QWORD *)(a1 + 16) = 0;
      if (!a2[16])
        goto LABEL_41;
    }
    *(_DWORD *)(a1 + 28) = 0;
    if ((_DWORD)result == 16)
      return 12;
    else
      return 8;
  }
  return result;
}

uint64_t silk_control_encoder(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  BOOL v19;
  int v20;
  int v21;
  void *v22;
  uint64_t v23;
  uint64_t result;
  int v25;
  int v26;
  void *v27;
  void *v28;
  int v29;
  int v30;
  char *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;

  LODWORD(v5) = a5;
  v8 = a1 + 4541;
  v9 = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 6096) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 4676) = v9;
  v10 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 4556) = v10;
  *(_QWORD *)(a1 + 4564) = *(_QWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 4572) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 6108) = *(_DWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 5768) = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 4536) = a3;
  *(_DWORD *)(a1 + 5776) = a4;
  if (*(_DWORD *)(a1 + 4668) && !*(_DWORD *)(a1 + 4680))
  {
    if (v10 == *(_DWORD *)(a1 + 4560))
      return 0;
    v23 = *(unsigned int *)(a1 + 4576);
    if ((int)v23 < 1)
      return 0;
    else
      return silk_setup_resamplers((_DWORD *)a1, v23);
  }
  v11 = silk_control_audio_bandwidth(a1, (_DWORD *)a2);
  if ((_DWORD)v5)
    v5 = v5;
  else
    v5 = v11;
  v12 = silk_setup_resamplers((_DWORD *)a1, v5);
  v13 = *(_DWORD *)(a2 + 24);
  if (*(_DWORD *)(a1 + 4612) != v13)
  {
    if (v13 <= 0x3C && ((1 << v13) & 0x1000010000100400) != 0)
    {
      v14 = 0;
      v19 = v13 == 10;
      if (v13 <= 10)
      {
LABEL_15:
        *(_DWORD *)(a1 + 5760) = 1;
        if (v19)
          v20 = 2;
        else
          v20 = 1;
        *(_DWORD *)(a1 + 4580) = v20;
        *(_DWORD *)(a1 + 4584) = (__int16)v13 * (__int16)v5;
        *(_DWORD *)(a1 + 4548) = 14 * (__int16)v5;
        v21 = *(_DWORD *)(a1 + 4576);
        if (v21 != 8)
        {
          *(_QWORD *)(a1 + 4696) = &silk_pitch_contour_10_ms_iCDF;
          *(_DWORD *)(a1 + 4612) = v13;
          *(_DWORD *)(a1 + 4608) = 0;
          if (v21 != (_DWORD)v5)
            goto LABEL_36;
          goto LABEL_8;
        }
        v22 = &silk_pitch_contour_10_ms_NB_iCDF;
LABEL_33:
        *(_QWORD *)(a1 + 4696) = v22;
        *(_DWORD *)(a1 + 4612) = v13;
        *(_DWORD *)(a1 + 4608) = 0;
        if ((_DWORD)v5 != 8)
          goto LABEL_36;
LABEL_8:
        v15 = *(_DWORD *)(a2 + 36);
        if (v15 > 0)
          goto LABEL_9;
LABEL_55:
        *(_DWORD *)(a1 + 4644) = 0;
        *(_DWORD *)(a1 + 4652) = 52429;
        v16 = 3 * v5;
        *(_DWORD *)(a1 + 4600) = 3 * v5;
        *(_DWORD *)(a1 + 4628) = 1;
        *(_QWORD *)(a1 + 4632) = 0xC00000000;
        goto LABEL_56;
      }
    }
    else
    {
      v14 = -103;
      v19 = v13 == 10;
      if (v13 <= 10)
        goto LABEL_15;
    }
    *(_DWORD *)(a1 + 5760) = v13 / 0x14u;
    *(_DWORD *)(a1 + 4580) = 4;
    *(_DWORD *)(a1 + 4584) = 20 * (__int16)v5;
    *(_DWORD *)(a1 + 4548) = 24 * (__int16)v5;
    v25 = *(_DWORD *)(a1 + 4576);
    if (v25 != 8)
    {
      *(_QWORD *)(a1 + 4696) = &silk_pitch_contour_iCDF;
      *(_DWORD *)(a1 + 4612) = v13;
      *(_DWORD *)(a1 + 4608) = 0;
      if (v25 != (_DWORD)v5)
        goto LABEL_36;
      goto LABEL_8;
    }
    v22 = &silk_pitch_contour_NB_iCDF;
    goto LABEL_33;
  }
  v14 = 0;
  if (*(_DWORD *)(a1 + 4576) == (_DWORD)v5)
    goto LABEL_8;
LABEL_36:
  *(_DWORD *)(a1 + 7200) = 0;
  *(_QWORD *)(a1 + 7192) = 0;
  bzero((void *)(a1 + 148), 0x1100uLL);
  *(_OWORD *)(a1 + 4500) = 0u;
  *(_OWORD *)(a1 + 4516) = 0u;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 5756) = 0;
  *(_DWORD *)(a1 + 5764) = 0;
  *(_DWORD *)(a1 + 4608) = 0;
  *(_DWORD *)(a1 + 4544) = 100;
  *(_DWORD *)(a1 + 4664) = 1;
  *(_BYTE *)(a1 + 7192) = 10;
  *(_DWORD *)(a1 + 4476) = 100;
  *(_DWORD *)(a1 + 4492) = 0x10000;
  *(_BYTE *)v8 = 0;
  *(_DWORD *)(a1 + 4576) = v5;
  v26 = *(_DWORD *)(a1 + 4580);
  if ((_DWORD)v5 == 8)
  {
    v27 = &silk_pitch_contour_10_ms_NB_iCDF;
    if (v26 == 4)
      v27 = &silk_pitch_contour_NB_iCDF;
    v28 = &silk_NLSF_CB_NB_MB;
    v29 = 10;
  }
  else
  {
    v27 = &silk_pitch_contour_10_ms_iCDF;
    if (v26 == 4)
      v27 = &silk_pitch_contour_iCDF;
    if ((_DWORD)v5 == 12)
      v29 = 10;
    else
      v29 = 16;
    v28 = &silk_NLSF_CB_WB;
    if ((_DWORD)v5 == 12)
      v28 = &silk_NLSF_CB_NB_MB;
  }
  *(_QWORD *)(a1 + 4696) = v27;
  *(_DWORD *)(a1 + 4640) = v29;
  *(_QWORD *)(a1 + 4704) = v28;
  *(_DWORD *)(a1 + 4588) = 5 * v5;
  *(_DWORD *)(a1 + 4584) = (__int16)v26 * (__int16)(5 * v5);
  *(_DWORD *)(a1 + 4592) = 20 * (__int16)v5;
  *(_DWORD *)(a1 + 4596) = 2 * (__int16)v5;
  *(_DWORD *)(a1 + 4552) = 18 * (__int16)v5;
  if (v26 == 4)
    v30 = 24;
  else
    v30 = 14;
  *(_DWORD *)(a1 + 4548) = v30 * (__int16)v5;
  v31 = silk_uniform4_iCDF;
  if ((_DWORD)v5 == 12)
    v31 = (char *)&silk_uniform6_iCDF;
  if ((_DWORD)v5 == 16)
    v31 = silk_uniform8_iCDF;
  *(_QWORD *)(a1 + 4688) = v31;
  v15 = *(_DWORD *)(a2 + 36);
  if (v15 <= 0)
    goto LABEL_55;
LABEL_9:
  if (v15 != 1)
  {
    if (v15 > 2)
    {
      if (v15 != 3)
      {
        if (v15 > 5)
        {
          v16 = 5 * v5;
          v36 = 983 * v5;
          if (v15 > 7)
          {
            *(_DWORD *)(a1 + 4652) = 45875;
            *(_QWORD *)(v8 + 103) = 0x1000000002;
            *(_DWORD *)(a1 + 4636) = 24;
            *(_DWORD *)(a1 + 4600) = v16;
            *(_QWORD *)(v8 + 87) = 0x100000004;
            v18 = 16;
            *(_DWORD *)(a1 + 4660) = 16;
            *(_DWORD *)(a1 + 4672) = v36;
          }
          else
          {
            *(_DWORD *)(a1 + 4652) = 47186;
            *(_QWORD *)(v8 + 103) = 0xC00000001;
            *(_DWORD *)(a1 + 4636) = 20;
            *(_DWORD *)(a1 + 4600) = v16;
            *(_QWORD *)(v8 + 87) = 0x100000003;
            *(_DWORD *)(a1 + 4660) = 8;
            *(_DWORD *)(a1 + 4672) = v36;
            v18 = 12;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 4644) = 1;
          *(_QWORD *)(a1 + 4648) = 0xBD710000000ALL;
          v16 = 5 * v5;
          *(_DWORD *)(a1 + 4600) = 5 * v5;
          *(_DWORD *)(a1 + 4628) = 2;
          *(_QWORD *)(a1 + 4632) = 0x1000000001;
          *(_DWORD *)(a1 + 4660) = 6;
          *(_DWORD *)(a1 + 4672) = 983 * v5;
          v18 = 10;
        }
        goto LABEL_57;
      }
      *(_DWORD *)(a1 + 4644) = 1;
      *(_QWORD *)(a1 + 4648) = 0xC28F00000008;
      v16 = 5 * v5;
      *(_DWORD *)(a1 + 4600) = 5 * v5;
      *(_DWORD *)(a1 + 4628) = 2;
      *(_QWORD *)(a1 + 4632) = 0xE00000000;
      v17 = 4;
      goto LABEL_11;
    }
    *(_DWORD *)(a1 + 4644) = 0;
    *(_QWORD *)(a1 + 4648) = 0xCCCD00000006;
    v16 = 3 * v5;
    *(_DWORD *)(a1 + 4600) = 3 * v5;
    *(_DWORD *)(a1 + 4628) = 2;
    *(_QWORD *)(a1 + 4632) = 0xC00000000;
LABEL_56:
    *(_DWORD *)(a1 + 4660) = 2;
    *(_DWORD *)(a1 + 4672) = 0;
    v18 = 6;
    goto LABEL_57;
  }
  *(_DWORD *)(a1 + 4644) = 1;
  *(_DWORD *)(a1 + 4652) = 49807;
  v16 = 5 * v5;
  *(_DWORD *)(a1 + 4600) = 5 * v5;
  *(_DWORD *)(a1 + 4628) = 1;
  *(_QWORD *)(a1 + 4632) = 0xE00000000;
  v17 = 3;
LABEL_11:
  *(_DWORD *)(a1 + 4660) = v17;
  *(_DWORD *)(a1 + 4672) = 0;
  v18 = 8;
LABEL_57:
  result = (v14 + v12);
  if (v18 >= *(_DWORD *)(a1 + 4640))
    v18 = *(_DWORD *)(a1 + 4640);
  *(_DWORD *)(a1 + 4648) = v18;
  *(_DWORD *)(a1 + 4604) = 5 * v5 + 2 * v16;
  *(_DWORD *)(a1 + 4624) = v15;
  v32 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 4616) = v32;
  v33 = *(_DWORD *)(a2 + 44);
  v34 = *(_DWORD *)(a1 + 6112);
  *(_DWORD *)(a1 + 6112) = v33;
  if (v33)
  {
    v35 = 7;
    if (v34)
    {
      v35 = 7 - ((unint64_t)(13107 * v32) >> 16);
      if (v35 <= 3)
        v35 = 3;
    }
    *(_DWORD *)(a1 + 6116) = v35;
  }
  *(_DWORD *)(a1 + 4668) = 1;
  return result;
}

uint64_t silk_setup_resamplers(_DWORD *a1, uint64_t a2)
{
  __int16 v2;
  int v4;
  uint64_t result;
  int v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _DWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  int v19;
  int v20;
  int8x16_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  int8x16_t v29;
  int16x8_t v30;
  int8x16_t v31;
  int16x8_t v32;
  int32x4_t v33;
  _DWORD *v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  _QWORD v39[2];
  int v40[76];
  uint64_t v41;

  v2 = a2;
  v41 = *MEMORY[0x24BDAC8D0];
  v4 = a1[1144];
  if (v4 == (_DWORD)a2 && a1[1140] == a1[1139])
  {
    result = 0;
    goto LABEL_19;
  }
  if (!v4)
  {
    result = silk_resampler_init((uint64_t)(a1 + 1448), a1[1139], 1000 * (int)a2, 1);
    goto LABEL_19;
  }
  v39[1] = v39;
  v6 = 10 * a1[1145] + 5;
  v7 = (v6 * v4);
  v39[0] = (v6 * a2);
  MEMORY[0x24BDAC7A8](a1, a2);
  v9 = (char *)v39 - v8;
  v10 = a1 + 1801;
  if ((int)v7 >= 1)
  {
    v11 = v7 + 1;
    do
    {
      v12 = (uint64_t)rintf(*(float *)&v10[(v11 - 2)]);
      if ((int)v12 <= -32768)
        LODWORD(v12) = -32768;
      if ((int)v12 >= 0x7FFF)
        LOWORD(v12) = 0x7FFF;
      *(_WORD *)&v9[2 * (v11-- - 2)] = v12;
    }
    while (v11 > 1);
  }
  v13 = silk_resampler_init((uint64_t)v40, 1000 * *((__int16 *)a1 + 2288), a1[1139], 0);
  v14 = v13;
  v15 = a1[1139] / 1000 * v6;
  MEMORY[0x24BDAC7A8](v13, v16);
  v18 = (char *)v39 - v17;
  v19 = silk_resampler(v40, (_QWORD *)((char *)v39 - v17), v9, v7);
  v20 = v19 + v14 + silk_resampler_init((uint64_t)(a1 + 1448), a1[1139], 1000 * v2, 1);
  result = v20 + silk_resampler(a1 + 1448, v9, v18, v15);
  v22 = v39[0];
  if (SLODWORD(v39[0]) >= 1)
  {
    if (LODWORD(v39[0]) < 0x10 || (v25 = v39[0] - 1, (unint64_t)(v39[0] - 1) >> 32))
    {
      v23 = v39[0];
    }
    else
    {
      v26 = v39[0] & 0xFFFFFFF0;
      v23 = v39[0] & 0xF;
      v27 = v26;
      do
      {
        v28 = &v9[2 * v25];
        v29 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(v28 - 14));
        v30 = (int16x8_t)vextq_s8(v29, v29, 8uLL);
        v31 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(v28 - 30));
        v32 = (int16x8_t)vextq_s8(v31, v31, 8uLL);
        v33 = (int32x4_t)vcvtq_f32_s32(vmovl_high_s16(v30));
        v34 = &v10[v25];
        v35 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v30.i8)));
        v36 = (int8x16_t)vrev64q_s32(v33);
        *(int8x16_t *)(v34 - 7) = vextq_s8(v36, v36, 8uLL);
        *(int8x16_t *)(v34 - 3) = vextq_s8(v35, v35, 8uLL);
        v37 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v32.i8)));
        v21 = vextq_s8(v37, v37, 8uLL);
        v38 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_high_s16(v32)));
        *(int8x16_t *)(v34 - 15) = vextq_s8(v38, v38, 8uLL);
        *(int8x16_t *)(v34 - 11) = v21;
        v25 -= 16;
        v27 -= 16;
      }
      while (v27);
      if (v26 == v22)
        goto LABEL_19;
    }
    v24 = v23 + 1;
    do
    {
      v21.i16[0] = *(_WORD *)&v9[2 * (v24 - 2)];
      v21.i64[0] = vmovl_s16(*(int16x4_t *)v21.i8).u64[0];
      *(float *)v21.i32 = (float)v21.i32[0];
      v10[(v24-- - 2)] = v21.i32[0];
    }
    while (v24 > 1);
  }
LABEL_19:
  a1[1140] = a1[1139];
  return result;
}

void silk_corrVector_FLP(uint64_t a1, float *a2, uint64_t a3, int a4, float *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  float *v16;
  float v17;
  unint64_t v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  const float *v22;
  const float *v23;
  float64x2_t v24;
  float64x2_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float64x2_t v32;
  float64x2_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  uint64_t v40;
  float *v41;
  float v42;
  double v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  float *v47;
  float v48;
  unint64_t v49;
  double v50;
  uint64_t v51;
  uint64_t v52;
  const float *v53;
  const float *v54;
  float64x2_t v55;
  float64x2_t v56;
  uint64_t v57;
  float32x2x4_t v58;
  float32x2x4_t v59;
  float32x2x4_t v60;
  float32x2x4_t v61;
  float32x2x4_t v62;
  float32x2x4_t v63;
  float32x2x4_t v64;
  float32x2x4_t v65;

  v5 = (a4 - 1);
  if (a4 >= 1)
  {
    v6 = a4;
    if ((int)a3 >= 4)
    {
      v7 = a1 + 4 * v5;
      v8 = (a3 - 3);
      v9 = a3 & 0xFFFFFFFC;
      if (v9 < a3)
      {
        v10 = 0;
        v11 = v9 | 1;
        if ((int)a3 > (int)(v9 | 1))
          v11 = a3;
        v12 = (v11 + ~(_DWORD)v9);
        v13 = v12 + 1;
        v14 = 4;
        if (v8 > 4)
          v14 = (a3 - 3);
        v15 = ((v14 - 1) >> 2) + 1;
        while (v14 >= 0xD)
        {
          v20 = 0;
          v19 = 0.0;
          v21 = v15 & 0x7FFFFFFFFFFFFFFCLL;
          do
          {
            v22 = (const float *)(v7 + v20 * 4);
            v58 = vld4_f32(v22);
            v22 += 8;
            v60 = vld4_f32(v22);
            v23 = &a2[v20];
            v62 = vld4_f32(v23);
            v23 += 8;
            v64 = vld4_f32(v23);
            v24 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v58.val[1]), vcvtq_f64_f32(v62.val[1])), vcvtq_f64_f32(v62.val[0]), vcvtq_f64_f32(v58.val[0])), vcvtq_f64_f32(v62.val[2]), vcvtq_f64_f32(v58.val[2])), vcvtq_f64_f32(v62.val[3]), vcvtq_f64_f32(v58.val[3]));
            v25 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v60.val[1]), vcvtq_f64_f32(v64.val[1])), vcvtq_f64_f32(v64.val[0]), vcvtq_f64_f32(v60.val[0])), vcvtq_f64_f32(v64.val[2]), vcvtq_f64_f32(v60.val[2])), vcvtq_f64_f32(v64.val[3]), vcvtq_f64_f32(v60.val[3]));
            v19 = v19 + v24.f64[0] + v24.f64[1] + v25.f64[0] + v25.f64[1];
            v20 += 16;
            v21 -= 4;
          }
          while (v21);
          v18 = 4 * (v15 & 0x7FFFFFFFFFFFFFFCLL);
          if (v15 != (v15 & 0x7FFFFFFFFFFFFFFCLL))
            goto LABEL_15;
LABEL_17:
          if (v12 >= 7)
          {
            v28 = (4 * a3) & 0x3FFFFFFF0;
            v29 = v13 & 0x1FFFFFFF8;
            do
            {
              v30 = *(float32x4_t *)(v7 + v28);
              v31 = *(float32x4_t *)(v7 + v28 + 16);
              v32 = vcvtq_f64_f32(*(float32x2_t *)v30.f32);
              v33 = vcvtq_f64_f32(*(float32x2_t *)v31.f32);
              v34 = *(float32x4_t *)((char *)a2 + v28);
              v35 = *(float32x4_t *)((char *)a2 + v28 + 16);
              v36 = vmulq_f64(vcvt_hight_f64_f32(v30), vcvt_hight_f64_f32(v34));
              v37 = vmulq_f64(v32, vcvtq_f64_f32(*(float32x2_t *)v34.f32));
              v38 = vmulq_f64(vcvt_hight_f64_f32(v31), vcvt_hight_f64_f32(v35));
              v39 = vmulq_f64(v33, vcvtq_f64_f32(*(float32x2_t *)v35.f32));
              v19 = v19
                  + v37.f64[0]
                  + v37.f64[1]
                  + v36.f64[0]
                  + v36.f64[1]
                  + v39.f64[0]
                  + v39.f64[1]
                  + v38.f64[0]
                  + v38.f64[1];
              v28 += 32;
              v29 -= 8;
            }
            while (v29);
            v27 = (v13 & 0x1FFFFFFF8) + v9;
            if (v13 == (v13 & 0x1FFFFFFF8))
              goto LABEL_9;
          }
          else
          {
            v27 = a3 & 0xFFFFFFFC;
          }
          v40 = v27;
          do
          {
            v19 = v19 + *(float *)(v7 + v40 * 4) * a2[v40];
            LODWORD(v27) = v27 + 1;
            ++v40;
          }
          while ((int)v27 < (int)a3);
LABEL_9:
          v17 = v19;
          a5[v10] = v17;
          v7 -= 4;
          if (++v10 == a4)
            return;
        }
        v18 = 0;
        v19 = 0.0;
LABEL_15:
        v26 = v18;
        do
        {
          v16 = a2 + 2;
          v19 = v19
              + *(float *)(v7 + v26 * 4 + 4) * v16[v26 - 1]
              + *(float *)(v7 + v26 * 4) * v16[v26 - 2]
              + *(float *)(v7 + v26 * 4 + 8) * v16[v26]
              + *(float *)(v7 + v26 * 4 + 12) * v16[v26 + 1];
          v18 += 4;
          v26 += 4;
        }
        while (v18 < v8);
        goto LABEL_17;
      }
      v44 = 0;
      v45 = 4;
      if (v8 > 4)
        v45 = (a3 - 3);
      v46 = ((v45 - 1) >> 2) + 1;
      while (1)
      {
        if (v45 >= 0xD)
        {
          v51 = 0;
          v50 = 0.0;
          v52 = v46 & 0x7FFFFFFFFFFFFFFCLL;
          do
          {
            v53 = (const float *)(v7 + v51 * 4);
            v59 = vld4_f32(v53);
            v53 += 8;
            v61 = vld4_f32(v53);
            v54 = &a2[v51];
            v63 = vld4_f32(v54);
            v54 += 8;
            v65 = vld4_f32(v54);
            v55 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v59.val[1]), vcvtq_f64_f32(v63.val[1])), vcvtq_f64_f32(v63.val[0]), vcvtq_f64_f32(v59.val[0])), vcvtq_f64_f32(v63.val[2]), vcvtq_f64_f32(v59.val[2])), vcvtq_f64_f32(v63.val[3]), vcvtq_f64_f32(v59.val[3]));
            v56 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v61.val[1]), vcvtq_f64_f32(v65.val[1])), vcvtq_f64_f32(v65.val[0]), vcvtq_f64_f32(v61.val[0])), vcvtq_f64_f32(v65.val[2]), vcvtq_f64_f32(v61.val[2])), vcvtq_f64_f32(v65.val[3]), vcvtq_f64_f32(v61.val[3]));
            v50 = v50 + v55.f64[0] + v55.f64[1] + v56.f64[0] + v56.f64[1];
            v51 += 16;
            v52 -= 4;
          }
          while (v52);
          v49 = 4 * (v46 & 0x7FFFFFFFFFFFFFFCLL);
          if (v46 == (v46 & 0x7FFFFFFFFFFFFFFCLL))
            goto LABEL_34;
        }
        else
        {
          v49 = 0;
          v50 = 0.0;
        }
        v57 = v49;
        do
        {
          v47 = a2 + 2;
          v50 = v50
              + *(float *)(v7 + v57 * 4 + 4) * v47[v57 - 1]
              + *(float *)(v7 + v57 * 4) * v47[v57 - 2]
              + *(float *)(v7 + v57 * 4 + 8) * v47[v57]
              + *(float *)(v7 + v57 * 4 + 12) * v47[v57 + 1];
          v49 += 4;
          v57 += 4;
        }
        while (v49 < v8);
LABEL_34:
        v48 = v50;
        a5[v44] = v48;
        v7 -= 4;
        if (++v44 == a4)
          return;
      }
    }
    if ((int)a3 <= 0)
    {
      bzero(a5, 4 * a4);
    }
    else
    {
      v41 = (float *)(a1 + 4 * v5 + 8);
      do
      {
        v43 = *(v41 - 2) * *a2 + 0.0;
        if ((_DWORD)a3 != 1)
        {
          v43 = v43 + *(v41 - 1) * a2[1];
          if ((_DWORD)a3 != 2)
            v43 = v43 + *v41 * a2[2];
        }
        v42 = v43;
        *a5++ = v42;
        --v41;
        --v6;
      }
      while (v6);
    }
  }
}

uint64_t silk_corrMatrix_FLP(uint64_t result, int a2, unsigned int a3, float *a4)
{
  signed int v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  double v8;
  unsigned int v9;
  unint64_t v10;
  const float *v11;
  uint64_t v12;
  const float *v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float *v24;
  double v25;
  float v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  uint64_t v34;
  float *v35;
  float v36;
  float v37;
  uint64_t v38;
  float *v39;
  unsigned int v40;
  uint64_t v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  unint64_t v52;
  double v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  const float *v57;
  const float *v58;
  float64x2_t v59;
  float64x2_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float64x2_t v71;
  float64x2_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float64x2_t v75;
  float64x2_t v76;
  float64x2_t v77;
  float64x2_t v78;
  uint64_t v79;
  float v80;
  uint64_t v81;
  int v82;
  float *v83;
  uint64_t v84;
  float v85;
  float32x2x4_t v86;
  float32x2x4_t v87;
  float32x2x4_t v88;
  float32x2x4_t v89;
  float32x2x4_t v90;
  float32x2x4_t v91;

  v4 = a3 - 1;
  if (a2 >= 4)
  {
    v5 = (a2 - 3);
    v6 = 4;
    if (v5 > 4)
      v6 = (a2 - 3);
    if (v6 >= 0xD)
    {
      v10 = ((v6 - 1) >> 2) + 1;
      v7 = 4 * (v10 & 0x7FFFFFFFFFFFFFFCLL);
      v11 = (const float *)(result + 4 * v4 + 32);
      v8 = 0.0;
      v12 = v10 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v13 = v11 - 8;
        v86 = vld4_f32(v13);
        v88 = vld4_f32(v11);
        v14 = vcvtq_f64_f32(v86.val[0]);
        v15 = vcvtq_f64_f32(v88.val[0]);
        v16 = vcvtq_f64_f32(v86.val[1]);
        v17 = vcvtq_f64_f32(v88.val[1]);
        v18 = vmlaq_f64(vmulq_f64(v16, v16), v14, v14);
        v19 = vmlaq_f64(vmulq_f64(v17, v17), v15, v15);
        v20 = vcvtq_f64_f32(v86.val[2]);
        v21 = vcvtq_f64_f32(v88.val[2]);
        *(float64x2_t *)v86.val[0].f32 = vcvtq_f64_f32(v86.val[3]);
        *(float64x2_t *)v86.val[1].f32 = vcvtq_f64_f32(v88.val[3]);
        v22 = vmlaq_f64(vmlaq_f64(v18, v20, v20), *(float64x2_t *)v86.val[0].f32, *(float64x2_t *)v86.val[0].f32);
        v23 = vmlaq_f64(vmlaq_f64(v19, v21, v21), *(float64x2_t *)v86.val[1].f32, *(float64x2_t *)v86.val[1].f32);
        v8 = v8 + v22.f64[0] + v22.f64[1] + v23.f64[0] + v23.f64[1];
        v11 += 16;
        v12 -= 4;
      }
      while (v12);
      if (v10 == (v10 & 0x7FFFFFFFFFFFFFFCLL))
      {
LABEL_13:
        v9 = a2 & 0x7FFFFFFC;
        if ((int)(a2 & 0xFFFFFFFC) >= a2)
          goto LABEL_22;
        goto LABEL_14;
      }
    }
    else
    {
      v7 = 0;
      v8 = 0.0;
    }
    v24 = (float *)(4 * v7 + 4 * v4 + result + 8);
    do
    {
      v25 = *(v24 - 1) * *(v24 - 1) + *(v24 - 2) * *(v24 - 2);
      v26 = *v24;
      v27 = v24[1];
      v24 += 4;
      v8 = v8 + v25 + v26 * v26 + v27 * v27;
      v7 += 4;
    }
    while (v7 < v5);
    goto LABEL_13;
  }
  v9 = 0;
  v8 = 0.0;
  if (a2 <= 0)
    goto LABEL_22;
LABEL_14:
  v28 = v9;
  v29 = ~v9 + a2;
  if (!(_DWORD)v29)
  {
    v32 = v28;
LABEL_20:
    v35 = (float *)(result + 4 * v32 + 4 * v4);
    do
    {
      v36 = *v35++;
      v8 = v8 + v36 * v36;
      LODWORD(v32) = v32 + 1;
    }
    while ((int)v32 < a2);
    goto LABEL_22;
  }
  v30 = v29 + 1;
  v31 = (v29 + 1) & 0x1FFFFFFFELL;
  v32 = v31 + v28;
  v33 = (float *)(4 * v4 + 4 * v28 + result + 4);
  v34 = v31;
  do
  {
    v8 = v8 + *(v33 - 1) * *(v33 - 1) + *v33 * *v33;
    v33 += 2;
    v34 -= 2;
  }
  while (v34);
  if (v30 != v31)
    goto LABEL_20;
LABEL_22:
  v37 = v8;
  *a4 = v37;
  if ((int)a3 >= 2)
  {
    v38 = result + 4 * v4;
    v39 = (float *)(v38 - 4);
    v40 = a3 + 1;
    v41 = a3 - 1;
    do
    {
      v8 = v8 + (float)((float)(*v39 * *v39) - (float)(v39[a2] * v39[a2]));
      v42 = v8;
      a4[v40] = v42;
      v40 += a3 + 1;
      --v39;
      --v41;
    }
    while (v41);
    v43 = 4 * (a3 - 2);
    v44 = result + v43;
    v45 = (a2 - 3);
    v46 = 4;
    if (v45 > 4)
      v46 = (a2 - 3);
    v47 = ((v46 - 1) >> 2) + 1;
    v48 = result + 4 * v4;
    v49 = (uint64_t)&a4[a3 + 2];
    v50 = 2 * a3;
    result = 4 * a2 + result + v43 - 4;
    v51 = 1;
    while (1)
    {
      if (a2 < 4)
      {
        v54 = 0;
        v53 = 0.0;
        goto LABEL_39;
      }
      if (v46 < 0xD)
        break;
      v55 = 0;
      v53 = 0.0;
      v56 = v47 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v57 = (const float *)(v38 + v55);
        v87 = vld4_f32(v57);
        v57 += 8;
        v89 = vld4_f32(v57);
        v58 = (const float *)(v44 + v55);
        v90 = vld4_f32(v58);
        v58 += 8;
        v91 = vld4_f32(v58);
        v59 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v87.val[1]), vcvtq_f64_f32(v90.val[1])), vcvtq_f64_f32(v90.val[0]), vcvtq_f64_f32(v87.val[0])), vcvtq_f64_f32(v90.val[2]), vcvtq_f64_f32(v87.val[2])), vcvtq_f64_f32(v90.val[3]), vcvtq_f64_f32(v87.val[3]));
        v60 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v89.val[1]), vcvtq_f64_f32(v91.val[1])), vcvtq_f64_f32(v91.val[0]), vcvtq_f64_f32(v89.val[0])), vcvtq_f64_f32(v91.val[2]), vcvtq_f64_f32(v89.val[2])), vcvtq_f64_f32(v91.val[3]), vcvtq_f64_f32(v89.val[3]));
        v53 = v53 + v59.f64[0] + v59.f64[1] + v60.f64[0] + v60.f64[1];
        v55 += 64;
        v56 -= 4;
      }
      while (v56);
      v52 = 4 * (v47 & 0x7FFFFFFFFFFFFFFCLL);
      v54 = a2 & 0xFFFFFFFC;
      if (v47 != (v47 & 0x7FFFFFFFFFFFFFFCLL))
        goto LABEL_36;
LABEL_39:
      if ((int)v54 < a2)
      {
        v62 = v54;
        v63 = ~v54 + a2;
        if (v63 >= 7)
        {
          v65 = v63 + 1;
          v66 = (v63 + 1) & 0x1FFFFFFF8;
          v64 = v66 + v62;
          v67 = 4 * v62;
          v68 = v66;
          do
          {
            v69 = *(float32x4_t *)(v48 + v67);
            v70 = *(float32x4_t *)(v48 + 16 + v67);
            v71 = vcvtq_f64_f32(*(float32x2_t *)v69.f32);
            v72 = vcvtq_f64_f32(*(float32x2_t *)v70.f32);
            v73 = *(float32x4_t *)(v44 + v67);
            v74 = *(float32x4_t *)(v44 + v67 + 16);
            v75 = vmulq_f64(vcvt_hight_f64_f32(v69), vcvt_hight_f64_f32(v73));
            v76 = vmulq_f64(v71, vcvtq_f64_f32(*(float32x2_t *)v73.f32));
            v77 = vmulq_f64(vcvt_hight_f64_f32(v70), vcvt_hight_f64_f32(v74));
            v78 = vmulq_f64(v72, vcvtq_f64_f32(*(float32x2_t *)v74.f32));
            v53 = v53
                + v76.f64[0]
                + v76.f64[1]
                + v75.f64[0]
                + v75.f64[1]
                + v78.f64[0]
                + v78.f64[1]
                + v77.f64[0]
                + v77.f64[1];
            v67 += 32;
            v68 -= 8;
          }
          while (v68);
          if (v65 == v66)
            goto LABEL_47;
        }
        else
        {
          v64 = v54;
        }
        v79 = 4 * v64;
        do
        {
          v53 = v53 + *(float *)(v38 + v79) * *(float *)(v44 + v79);
          LODWORD(v64) = v64 + 1;
          v79 += 4;
        }
        while ((int)v64 < a2);
      }
LABEL_47:
      v80 = v53;
      a4[v51 * a3] = v80;
      a4[v51] = v80;
      if (v51 < a3 - 1)
      {
        v81 = 0;
        v82 = v50;
        v83 = (float *)v49;
        v84 = 1;
        do
        {
          v53 = v53
              + (float)((float)(*(float *)(v48 - 4 + 4 * v81) * *(float *)(v44 + 4 * v81 - 4))
                      - (float)(*(float *)(v48 - 4 + 4 * a2 + 4 * v81) * *(float *)(result + 4 * v81)));
          v85 = v53;
          a4[v84 + v82] = v85;
          *v83 = v85;
          ++v84;
          --v81;
          v83 += a3 + 1;
          v82 += a3;
        }
        while (1 - v4 != v81);
      }
      v44 -= 4;
      ++v51;
      --v4;
      v49 += 4;
      v50 += a3;
      result -= 4;
      if (v51 == a3)
        return result;
    }
    v52 = 0;
    v53 = 0.0;
LABEL_36:
    v61 = 4 * v52 + 8;
    do
    {
      v53 = v53
          + *(float *)(v38 + v61 - 4) * *(float *)(v44 + 4 * v52 + 4)
          + *(float *)(v38 + v61 - 8) * *(float *)(v44 + v61 - 8)
          + *(float *)(v38 + v61) * *(float *)(v44 + v61)
          + *(float *)(v38 + v61 + 4) * *(float *)(v44 + v61 + 4);
      v52 += 4;
      v61 += 16;
    }
    while (v52 < v45);
    v54 = a2 & 0x7FFFFFFC;
    goto LABEL_39;
  }
  return result;
}

float decode_pulses(_DWORD *a1, int a2, int a3, uint64_t *a4)
{
  unsigned int v4;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  float v15;
  uint64_t v16;
  int v17;
  const char **v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  BOOL v23;
  uint64_t v24;
  int v25;
  unsigned int v26;
  const char **v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  uint64_t v34;
  const char **v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  __int16 v42;
  __int16 v43;
  int v44;

  v4 = a3;
  if (a2 >= a3)
    v7 = a3;
  else
    v7 = a2;
  v8 = *((_QWORD *)&X509_CERT_AUX_it.sname + v7);
  if (a2 <= a3)
    v9 = a3;
  else
    v9 = a2;
  v10 = *(_DWORD *)(v8 + 4 * v9);
  if (a3 + 1 < a2)
    v11 = a3 + 1;
  else
    v11 = a2;
  v12 = *((_QWORD *)&X509_CERT_AUX_it.sname + v11);
  if (a3 + 1 > a2)
    v13 = a3 + 1;
  else
    v13 = a2;
  v14 = ec_dec_uint(a4, *(_DWORD *)(v12 + 4 * v13) + v10);
  v15 = 0.0;
  if (a2 >= 3)
  {
    v16 = a2;
    do
    {
      if (v16 <= (int)v4)
      {
        v31 = *((_QWORD *)&X509_CERT_AUX_it.sname + v16);
        v17 = *(_DWORD *)(v31 + 4 * (int)v4 + 4);
        if (v14 >= v17)
          v32 = *(_DWORD *)(v31 + 4 * (int)v4 + 4);
        else
          v32 = 0;
        v33 = v14 - v32;
        if (*(_DWORD *)(v31 + 4 * v16) <= v33)
        {
          v37 = v4;
          v34 = (int)v4 + 1;
          do
          {
            v36 = *(_DWORD *)(v31 + 4 * v37);
            v37 = v34 - 2;
            --v34;
          }
          while (v36 > v33);
        }
        else
        {
          v34 = v16;
          do
          {
            v35 = &X509_CERT_AUX_it.sname + v34--;
            v36 = *(_DWORD *)&(*(v35 - 1))[4 * v16];
          }
          while (v36 > v33);
        }
        v23 = v14 >= v17;
        v14 = v33 - v36;
        LOWORD(v17) = v4 - v34;
        if (v23)
          LOWORD(v17) = v34 - v4;
        v17 = (__int16)v17;
        *a1 = (__int16)v17;
        v15 = v15 + (float)((float)v17 * (float)v17);
        v4 = v34;
      }
      else
      {
        v19 = &X509_CERT_AUX_it.sname + (int)v4;
        v20 = *(_DWORD *)&(*v19)[4 * v16];
        v21 = *(_DWORD *)&v19[1][4 * v16];
        v23 = v14 >= v20;
        v22 = v14 - v20;
        v23 = !v23 || v14 >= v21;
        if (v23)
        {
          v24 = 0;
          if (v14 >= v21)
            v25 = *(_DWORD *)&v19[1][4 * v16];
          else
            v25 = 0;
          v26 = v14 - v25;
          v27 = v19 - 1;
          do
          {
            v28 = *(_DWORD *)&v27[v24--][4 * v16];
            v23 = v26 >= v28;
            v29 = v26 - v28;
          }
          while (!v23);
          v4 += v24;
          if (v14 >= v21)
            LOWORD(v30) = v24;
          else
            v30 = -(int)v24;
          v30 = (__int16)v30;
          *a1 = (__int16)v30;
          v15 = v15 + (float)((float)v30 * (float)v30);
          v14 = v29;
        }
        else
        {
          *a1 = 0;
          v14 = v22;
        }
      }
      ++a1;
    }
    while (v16-- > 3);
  }
  v38 = (2 * v4) | 1;
  if (v14 >= v38)
    v39 = (2 * v4) | 1;
  else
    v39 = 0;
  v40 = v14 - v39;
  v41 = (v40 + 1) >> 1;
  v42 = v4 - v41;
  if (v14 >= v38)
    v42 = v41 - v4;
  v43 = ((v40 + 1) & 0xFFFE) - 1;
  if (v40 + 1 < 2)
    v43 = 0;
  v44 = (__int16)((v41 - (v40 - v43)) ^ (v43 - v40));
  *a1 = v42;
  a1[1] = v44;
  return (float)(v15 + (float)((float)v42 * (float)v42)) + (float)((float)v44 * (float)v44);
}

uint64_t silk_InitDecoder(_DWORD *a1)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  int16x8_t *v6;
  int32x4_t v7;
  int32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  uint64_t v11;
  int32x4_t v12;
  int32x4_t v13;
  uint64_t v14;
  _WORD *v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  int16x8_t *v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  uint64_t v26;
  int32x4_t v27;
  int32x4_t v28;
  uint64_t v29;
  _WORD *v30;
  int v31;

  bzero(a1, 0x10C0uLL);
  a1[594] = 1;
  *a1 = 0x10000;
  a1[1048] = 0;
  v2 = a1[585];
  if ((int)v2 >= 1)
  {
    v3 = 0x7FFF / ((int)v2 + 1);
    if (v2 < 0x10)
    {
      v4 = 0;
      v5 = 0;
LABEL_7:
      v14 = v2 - v4;
      v15 = (_WORD *)a1 + v4 + 2038;
      v16 = v5 + v3;
      do
      {
        *v15++ = v16;
        v16 += v3;
        --v14;
      }
      while (v14);
      goto LABEL_9;
    }
    v6 = (int16x8_t *)(a1 + 1019);
    v4 = v2 & 0xFFFFFFF0;
    v5 = v3 * (v2 & 0xFFFFFFF0);
    v7 = vdupq_n_s32(v3);
    v8 = vmulq_s32(v7, (int32x4_t)xmmword_208F08E20);
    v9 = vmulq_s32(v7, (int32x4_t)xmmword_208F071C0);
    v10 = vdupq_n_s32(8 * v3);
    v11 = v4;
    do
    {
      v12 = vaddq_s32(v8, v10);
      v13 = vaddq_s32(v9, v10);
      *v6 = vuzp1q_s16((int16x8_t)vaddq_s32(v9, v7), (int16x8_t)vaddq_s32(v8, v7));
      v6[1] = vuzp1q_s16((int16x8_t)vaddq_s32(v13, v7), (int16x8_t)vaddq_s32(v12, v7));
      v6 += 2;
      v9 = vaddq_s32(v13, v10);
      v8 = vaddq_s32(v12, v10);
      v11 -= 16;
    }
    while (v11);
    if (v4 != v2)
      goto LABEL_7;
  }
LABEL_9:
  *(_QWORD *)(a1 + 1043) = 0x30788000000000;
  a1[1049] = a1[582] << 7;
  *(_QWORD *)(a1 + 1067) = 0x1000000010000;
  *((_QWORD *)a1 + 535) = 0x1400000002;
  bzero(a1 + 1072, 0x10C0uLL);
  a1[1666] = 1;
  a1[1072] = 0x10000;
  a1[2120] = 0;
  v17 = a1[1657];
  if ((int)v17 < 1)
    goto LABEL_17;
  v18 = 0x7FFF / ((int)v17 + 1);
  if (v17 < 0x10)
  {
    v19 = 0;
    v20 = 0;
LABEL_15:
    v29 = v17 - v19;
    v30 = (_WORD *)a1 + v19 + 4182;
    v31 = v20 + v18;
    do
    {
      *v30++ = v31;
      v31 += v18;
      --v29;
    }
    while (v29);
    goto LABEL_17;
  }
  v21 = (int16x8_t *)(a1 + 2095);
  v19 = v17 & 0xFFFFFFF0;
  v20 = v18 * (v17 & 0xFFFFFFF0);
  v22 = vdupq_n_s32(v18);
  v23 = vmulq_s32(v22, (int32x4_t)xmmword_208F08E20);
  v24 = vmulq_s32(v22, (int32x4_t)xmmword_208F071C0);
  v25 = vdupq_n_s32(8 * v18);
  v26 = v19;
  do
  {
    v27 = vaddq_s32(v23, v25);
    v28 = vaddq_s32(v24, v25);
    v21[-1] = vuzp1q_s16((int16x8_t)vaddq_s32(v24, v22), (int16x8_t)vaddq_s32(v23, v22));
    *v21 = vuzp1q_s16((int16x8_t)vaddq_s32(v28, v22), (int16x8_t)vaddq_s32(v27, v22));
    v24 = vaddq_s32(v28, v25);
    v23 = vaddq_s32(v27, v25);
    v21 += 2;
    v26 -= 16;
  }
  while (v26);
  if (v19 != v17)
    goto LABEL_15;
LABEL_17:
  a1[2115] = 0;
  a1[2116] = 3176576;
  a1[2121] = a1[1654] << 7;
  *(_QWORD *)(a1 + 2139) = 0x1000000010000;
  *((_QWORD *)a1 + 1071) = 0x1400000002;
  *((_QWORD *)a1 + 1072) = 0;
  a1[2146] = 0;
  a1[2149] = 0;
  return 0;
}

uint64_t silk_Decode(uint64_t a1, int8x16_t *a2, int a3, int a4, uint64_t a5, _DWORD *a6, int *a7, int a8)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int16x8_t *v28;
  uint64_t v29;
  int32x4_t v30;
  int32x4_t v31;
  uint64_t v32;
  _WORD *v33;
  int v34;
  _BOOL4 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t result;
  int v41;
  int v42;
  BOOL v43;
  unsigned int v44;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t i;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  unsigned int v55;
  unint64_t v56;
  int v57;
  uint64_t v58;
  int v59;
  BOOL v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  int v64;
  unsigned int v65;
  unint64_t v66;
  unint64_t v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int8x16_t *v72;
  uint64_t v73;
  int32x4_t v74;
  int8x16_t v75;
  int32x4_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unsigned int v80;
  unsigned int v81;
  unsigned int v82;
  int v83;
  int v84;
  unint64_t v85;
  int v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  uint32x4_t v90;
  int32x4_t v91;
  int v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  char *v96;
  unsigned int v97;
  int v98;
  int v99;
  unsigned int v100;
  unint64_t v101;
  int v102;
  unint64_t v103;
  int v104;
  uint64_t v105;
  int v106;
  int v107;
  int v108;
  int v110;
  int v111;
  char *v112;
  _DWORD *v113;
  int v114;
  uint64_t v115;
  int *v116;
  _DWORD *v117;
  int v118;
  int v119;
  BOOL v120;
  int v121;
  int v122;
  uint64_t v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  int v127;
  int v128;
  unint64_t v129;
  int v130;
  int v131;
  uint64_t v132;
  uint64_t v133;
  int *v134;
  int v135;
  int v136;
  uint64_t v137;
  char *v138;
  __int16 *v139;
  int v140;
  uint64_t v141;
  uint64_t v142;
  char *v143;
  int v144;
  char *v145;
  int v146;
  uint64_t v147;
  _DWORD *v148;
  int v149;
  int v150;
  uint64_t v151;
  __int16 *v152;
  _WORD *v153;
  __int16 v154;
  uint64_t v155;
  _WORD *v156;
  __int16 v157;
  int v158;
  uint64_t v159;
  uint64_t v160;
  __int16 *v161;
  uint64_t v162;
  __int16 v163;
  uint64_t v164;
  _WORD *v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  _BYTE *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  unsigned int v175;
  unsigned int v176;
  unsigned int v177;
  char *v178;
  unsigned int v179;
  int v180;
  int v181;
  unsigned int v182;
  unint64_t v183;
  int v184;
  unint64_t v185;
  int v186;
  uint64_t v187;
  int v188;
  unsigned int v189;
  unsigned int v190;
  unsigned int v191;
  char *v192;
  unsigned int v193;
  int v194;
  int v195;
  unsigned int v196;
  unint64_t v197;
  int v198;
  unint64_t v199;
  int v200;
  uint64_t v201;
  int v202;
  _DWORD v203[4];
  _BYTE *v204;
  _BOOL4 v205;
  _DWORD *v206;
  char *v207;
  int v208;
  int *v209;
  _DWORD *v210;
  int *v211;
  unsigned int v212;
  __int16 v213[320];
  uint64_t v214;
  char *v215;
  _DWORD *v216;
  uint64_t v217;

  LODWORD(v207) = a8;
  v209 = a7;
  v206 = a6;
  v10 = (int *)a2;
  v11 = a1;
  v217 = *MEMORY[0x24BDAC8D0];
  v215 = 0;
  v216 = 0;
  v214 = 0;
  v12 = a2->u32[1];
  if (a4 && (int)v12 >= 1)
  {
    if (v12 < 2)
    {
      v13 = 0;
LABEL_8:
      v16 = v12 - v13;
      v17 = (_DWORD *)(a1 + 4288 * v13 + 2400);
      do
      {
        *v17 = 0;
        v17 += 1072;
        --v16;
      }
      while (v16);
      goto LABEL_10;
    }
    v13 = v12 & 0xFFFFFFFE;
    v14 = v13;
    v15 = a1;
    do
    {
      *(_DWORD *)(v15 + 2400) = 0;
      *(_DWORD *)(v15 + 6688) = 0;
      v15 += 8576;
      v14 -= 2;
    }
    while (v14);
    if (v13 != v12)
      goto LABEL_8;
  }
LABEL_10:
  v18 = a1 + 6600;
  v19 = *(_DWORD *)(a1 + 8592);
  v211 = (int *)a2;
  if ((int)v12 > v19)
  {
    bzero((void *)(a1 + 4288), 0x10C0uLL);
    v10 = v211;
    *(_DWORD *)(v11 + 6664) = 1;
    *(_DWORD *)(v11 + 4288) = 0x10000;
    *(_DWORD *)(v11 + 8480) = 0;
    v20 = *(unsigned int *)(v11 + 6628);
    if ((int)v20 >= 1)
    {
      v21 = 0x7FFF / ((int)v20 + 1);
      if (v20 >= 0x10)
      {
        v22 = v20 & 0x7FFFFFF0;
        v23 = v21 * (v20 & 0xFFFFFFF0);
        v24 = vdupq_n_s32(v21);
        v25 = vmulq_s32(v24, (int32x4_t)xmmword_208F08E20);
        v26 = vmulq_s32(v24, (int32x4_t)xmmword_208F071C0);
        v27 = vdupq_n_s32(8 * v21);
        v28 = (int16x8_t *)(v18 + 1780);
        v29 = v20 & 0xFFFFFFF0;
        do
        {
          v30 = vaddq_s32(v25, v27);
          v31 = vaddq_s32(v26, v27);
          v28[-1] = vuzp1q_s16((int16x8_t)vaddq_s32(v26, v24), (int16x8_t)vaddq_s32(v25, v24));
          *v28 = vuzp1q_s16((int16x8_t)vaddq_s32(v31, v24), (int16x8_t)vaddq_s32(v30, v24));
          v26 = vaddq_s32(v31, v27);
          v25 = vaddq_s32(v30, v27);
          v28 += 2;
          v29 -= 16;
        }
        while (v29);
        if (v22 == v20)
          goto LABEL_19;
      }
      else
      {
        v22 = 0;
        v23 = 0;
      }
      v32 = v20 - v22;
      v33 = (_WORD *)(v11 + 2 * v22 + 8364);
      v34 = v23 + v21;
      do
      {
        *v33++ = v34;
        v34 += v21;
        --v32;
      }
      while (v32);
    }
LABEL_19:
    *(_QWORD *)(v11 + 8460) = 0x30788000000000;
    *(_DWORD *)(v11 + 8484) = *(_DWORD *)(v11 + 6616) << 7;
    *(_QWORD *)(v11 + 8556) = 0x1000000010000;
    *(_QWORD *)(v11 + 8568) = 0x1400000002;
    LODWORD(v12) = v10[1];
  }
  v35 = 0;
  v204 = (_BYTE *)v18;
  if (v19 == 2 && (_DWORD)v12 == 1)
    v35 = v10[3] == 1000 * *(_DWORD *)(v11 + 2316);
  v205 = v35;
  v36 = 0;
  if ((int)v12 >= 1 && !*(_DWORD *)(v11 + 2400))
  {
    v37 = 0;
    LODWORD(v36) = 0;
    v38 = v11;
    do
    {
      v39 = v10[4];
      result = 4294967093;
      if (v39 <= 19)
      {
        if (v39)
          v43 = v39 == 10;
        else
          v43 = 1;
        if (!v43)
          return result;
        v41 = 2;
        v42 = 1;
      }
      else
      {
        switch(v39)
        {
          case 60:
            v41 = 4;
            v42 = 3;
            break;
          case 40:
            v41 = 4;
            v42 = 2;
            break;
          case 20:
            v41 = 4;
            v42 = 1;
            break;
          default:
            return result;
        }
      }
      *(_DWORD *)(v38 + 2404) = v42;
      *(_DWORD *)(v38 + 2324) = v41;
      v44 = v10[3] >> 10;
      if (v44 > 0xF || ((1 << v44) & 0x8880) == 0)
        return 4294967096;
      a1 = silk_decoder_set_fs(v38, v44 + 1, v10[2]);
      v10 = v211;
      v36 = (a1 + v36);
      ++v37;
      v12 = v211[1];
      v38 += 4288;
    }
    while (v37 < v12);
  }
  v46 = *v10;
  if (*v10 != 2)
    goto LABEL_51;
  if ((_DWORD)v12 != 2)
    goto LABEL_50;
  if (*(_DWORD *)(v11 + 8588) != 1 && *(_DWORD *)(v11 + 8592) != 1)
  {
    LODWORD(v12) = 2;
LABEL_50:
    v46 = 2;
    goto LABEL_51;
  }
  *(_DWORD *)(v11 + 8576) = 0;
  *(_DWORD *)(v11 + 8584) = 0;
  a1 = (uint64_t)memcpy((void *)(v11 + 6736), (const void *)(v11 + 2448), 0x130uLL);
  v10 = v211;
  v46 = *v211;
  LODWORD(v12) = v211[1];
LABEL_51:
  *(_DWORD *)(v11 + 8588) = v46;
  *(_DWORD *)(v11 + 8592) = v12;
  if ((v10[2] - 48001) < 0xFFFF63BF)
    return 4294967096;
  v212 = 0;
  v208 = a3;
  if (a3 == 1 || *(_DWORD *)(v11 + 2400))
    goto LABEL_106;
  if ((int)v12 >= 1)
  {
    v47 = 0;
    do
    {
      v49 = *(int *)(v11 + 4288 * v47 + 2404);
      if ((int)v49 >= 1)
      {
        for (i = 0; i < v49; ++i)
        {
          v52 = *(_DWORD *)(a5 + 32);
          v51 = *(_DWORD *)(a5 + 36);
          v53 = v52 >> 1;
          v54 = v51;
          if (v51 >= v52 >> 1)
          {
            *(_DWORD *)(a5 + 36) = v51 - (v52 >> 1);
            v54 = v51 - v53;
          }
          v55 = v52 - v53;
          if (v51 < v53)
            v55 = v53;
          *(_DWORD *)(a5 + 32) = v55;
          if (v55 < 0x800001)
          {
            v56 = *(unsigned int *)(a5 + 8);
            v57 = *(_DWORD *)(a5 + 44);
            a2 = (int8x16_t *)*(unsigned int *)(a5 + 28);
            LODWORD(a1) = *(_DWORD *)(a5 + 24) + 8;
            do
            {
              *(_DWORD *)(a5 + 24) = a1;
              *(_DWORD *)(a5 + 32) = v55 << 8;
              if ((unint64_t)a2 < v56)
              {
                v58 = *(_QWORD *)a5;
                *(_DWORD *)(a5 + 28) = (_DWORD)a2 + 1;
                v59 = a2->u8[v58];
                a2 = (int8x16_t *)((char *)a2 + 1);
              }
              else
              {
                v59 = 0;
              }
              v54 = (((v54 & 0x7FFFFF) << 8) | ((v59 | (v57 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a5 + 44) = v59;
              *(_DWORD *)(a5 + 36) = v54;
              a1 = (a1 + 8);
              v57 = v59;
              v60 = v55 > 0x8000;
              v55 <<= 8;
            }
            while (!v60);
          }
          *(_DWORD *)(v11 + 4288 * v47 + 4 * i + 2416) = v51 < v53;
        }
      }
      v62 = *(_DWORD *)(a5 + 32);
      v61 = *(_DWORD *)(a5 + 36);
      v63 = v62 >> 1;
      v64 = v61;
      if (v61 >= v62 >> 1)
      {
        *(_DWORD *)(a5 + 36) = v61 - (v62 >> 1);
        v64 = v61 - v63;
      }
      v65 = v62 - v63;
      if (v61 < v63)
        v65 = v63;
      *(_DWORD *)(a5 + 32) = v65;
      if (v65 < 0x800001)
      {
        v66 = *(unsigned int *)(a5 + 8);
        LODWORD(a1) = *(_DWORD *)(a5 + 44);
        v67 = *(unsigned int *)(a5 + 28);
        v68 = *(_DWORD *)(a5 + 24) + 8;
        do
        {
          *(_DWORD *)(a5 + 24) = v68;
          a2 = (int8x16_t *)(v65 << 8);
          *(_DWORD *)(a5 + 32) = (_DWORD)a2;
          if (v67 < v66)
          {
            v69 = *(_QWORD *)a5;
            *(_DWORD *)(a5 + 28) = v67 + 1;
            v70 = *(unsigned __int8 *)(v69 + v67++);
          }
          else
          {
            v70 = 0;
          }
          v64 = (((v64 & 0x7FFFFF) << 8) | ((v70 | ((_DWORD)a1 << 8)) >> 1)) ^ 0xFF;
          *(_DWORD *)(a5 + 44) = v70;
          *(_DWORD *)(a5 + 36) = v64;
          v68 += 8;
          a1 = v70;
          v60 = v65 > 0x8000;
          v65 <<= 8;
        }
        while (!v60);
      }
      *(_DWORD *)(v11 + 4288 * v47++ + 2428) = v61 < v63;
      v48 = v10[1];
    }
    while (v47 < v48);
    LODWORD(v12) = v10[1];
    if ((int)v48 >= 1)
    {
      v71 = 0;
      v72 = (int8x16_t *)(v11 + 2448);
      v73 = v11 + 2432;
      v74.i64[0] = 0x300000003;
      v74.i64[1] = 0x300000003;
      v75.i64[0] = 0x100000001;
      v75.i64[1] = 0x100000001;
      v76.i64[0] = 0x800000008;
      v76.i64[1] = 0x800000008;
      while (1)
      {
        v77 = v11 + 4288 * v71;
        *(_DWORD *)(v77 + 2440) = 0;
        *(_QWORD *)(v77 + 2432) = 0;
        if (*(_DWORD *)(v77 + 2428))
        {
          v78 = *(unsigned int *)(v11 + 4288 * v71 + 2404);
          if ((_DWORD)v78 == 1)
          {
            *(_DWORD *)(v77 + 2432) = 1;
          }
          else
          {
            v79 = 0;
            v80 = *(_DWORD *)(a5 + 32);
            a2 = (int8x16_t *)*(unsigned int *)(a5 + 36);
            v81 = v80 >> 8;
            do
            {
              v82 = v80;
              v80 = v81 * *((unsigned __int8 *)*(&silk_LBRR_flags_iCDF_ptr + (int)v78 - 2) + v79++);
              v83 = (_DWORD)a2 - v80;
            }
            while (a2 < v80);
            a1 = v82 - v80;
            *(_DWORD *)(a5 + 32) = a1;
            *(_DWORD *)(a5 + 36) = v83;
            if (a1 < 0x800001)
            {
              a2 = (int8x16_t *)*(unsigned int *)(a5 + 8);
              v84 = *(_DWORD *)(a5 + 44);
              v85 = *(unsigned int *)(a5 + 28);
              v86 = *(_DWORD *)(a5 + 24) + 8;
              do
              {
                *(_DWORD *)(a5 + 24) = v86;
                *(_DWORD *)(a5 + 32) = (_DWORD)a1 << 8;
                if (v85 < (unint64_t)a2)
                {
                  v87 = *(_QWORD *)a5;
                  *(_DWORD *)(a5 + 28) = v85 + 1;
                  v88 = *(unsigned __int8 *)(v87 + v85++);
                }
                else
                {
                  v88 = 0;
                }
                v83 = (((v83 & 0x7FFFFF) << 8) | ((v88 | (v84 << 8)) >> 1)) ^ 0xFF;
                *(_DWORD *)(a5 + 44) = v88;
                *(_DWORD *)(a5 + 36) = v83;
                v86 += 8;
                v84 = v88;
                v60 = a1 > 0x8000;
                a1 = ((_DWORD)a1 << 8);
              }
              while (!v60);
            }
            v10 = v211;
            if ((int)v78 < 1)
              goto LABEL_85;
            if (v78 >= 8)
            {
              v89 = v78 & 0x7FFFFFF8;
              v90 = (uint32x4_t)vdupq_n_s32(v79);
              a1 = v78 & 0xFFFFFFF8;
              a2 = v72;
              v91 = (int32x4_t)xmmword_208F071C0;
              do
              {
                a2[-1] = vandq_s8((int8x16_t)vshlq_u32(v90, (uint32x4_t)vnegq_s32(v91)), v75);
                *a2 = vandq_s8((int8x16_t)vshlq_u32(v90, (uint32x4_t)vsubq_s32(v74, v91)), v75);
                v91 = vaddq_s32(v91, v76);
                a2 += 2;
                a1 -= 8;
              }
              while (a1);
              if (v89 == v78)
                goto LABEL_85;
            }
            else
            {
              v89 = 0;
            }
            do
            {
              a1 = (v79 >> v89) & 1;
              *(_DWORD *)(v73 + 4 * v89++) = a1;
            }
            while (v78 != v89);
          }
        }
LABEL_85:
        ++v71;
        v72 += 268;
        v73 += 4288;
        if (v71 >= v10[1])
        {
          LODWORD(v12) = v10[1];
          break;
        }
      }
    }
  }
  if (a3 || *(int *)(v11 + 2404) < 1)
  {
LABEL_106:
    v92 = 0;
  }
  else
  {
    if ((int)v12 < 1)
    {
      v92 = 0;
      goto LABEL_123;
    }
    v92 = 0;
    v172 = 0;
    do
    {
      if ((int)v12 >= 1)
      {
        v210 = (_DWORD *)(v11 + 4 * v172 + 6720);
        v173 = 0;
        if (v172)
        {
          do
          {
            if (*(_DWORD *)(v11 + 4288 * v173 + 4 * v172 + 2432))
            {
              if (!v173 && (_DWORD)v12 == 2)
              {
                silk_stereo_decode_pred((uint64_t *)a5, &v214);
                if (!*v210)
                {
                  v176 = *(_DWORD *)(a5 + 32);
                  v175 = *(_DWORD *)(a5 + 36);
                  v177 = v176 >> 8;
                  v92 = -1;
                  v178 = &silk_stereo_only_code_mid_iCDF;
                  do
                  {
                    v179 = v176;
                    v180 = *v178++;
                    v176 = v177 * v180;
                    ++v92;
                    v181 = v175 - v177 * v180;
                  }
                  while (v175 < v177 * v180);
                  v182 = v179 - v176;
                  *(_DWORD *)(a5 + 32) = v179 - v176;
                  *(_DWORD *)(a5 + 36) = v181;
                  if (v179 - v176 < 0x800001)
                  {
                    v183 = *(unsigned int *)(a5 + 8);
                    v184 = *(_DWORD *)(a5 + 44);
                    v185 = *(unsigned int *)(a5 + 28);
                    v186 = *(_DWORD *)(a5 + 24) + 8;
                    do
                    {
                      *(_DWORD *)(a5 + 24) = v186;
                      *(_DWORD *)(a5 + 32) = v182 << 8;
                      if (v185 < v183)
                      {
                        v187 = *(_QWORD *)a5;
                        *(_DWORD *)(a5 + 28) = v185 + 1;
                        v188 = *(unsigned __int8 *)(v187 + v185++);
                      }
                      else
                      {
                        v188 = 0;
                      }
                      v181 = (((v181 & 0x7FFFFF) << 8) | ((v188 | (v184 << 8)) >> 1)) ^ 0xFF;
                      *(_DWORD *)(a5 + 44) = v188;
                      *(_DWORD *)(a5 + 36) = v181;
                      v186 += 8;
                      v184 = v188;
                      v60 = v182 > 0x8000;
                      v182 <<= 8;
                    }
                    while (!v60);
                  }
                }
              }
              v174 = v11 + 4288 * v173;
              silk_decode_indices(v174, (uint64_t *)a5, v172, 1, 2 * (*(_DWORD *)(v174 + 4 * (v172 - 1) + 2432) != 0));
              a1 = (uint64_t)silk_decode_pulses(a5, v213, *(char *)(v174 + 2789), *(char *)(v174 + 2790), *(_DWORD *)(v174 + 2328));
              v10 = v211;
              LODWORD(v12) = v211[1];
              a3 = v208;
            }
            ++v173;
          }
          while (v173 < (int)v12);
        }
        else
        {
          do
          {
            if (*(_DWORD *)(v11 + 4288 * v173 + 2432))
            {
              if (!v173 && (_DWORD)v12 == 2)
              {
                silk_stereo_decode_pred((uint64_t *)a5, &v214);
                if (!*v210)
                {
                  v190 = *(_DWORD *)(a5 + 32);
                  v189 = *(_DWORD *)(a5 + 36);
                  v191 = v190 >> 8;
                  v92 = -1;
                  v192 = &silk_stereo_only_code_mid_iCDF;
                  do
                  {
                    v193 = v190;
                    v194 = *v192++;
                    v190 = v191 * v194;
                    ++v92;
                    v195 = v189 - v191 * v194;
                  }
                  while (v189 < v191 * v194);
                  v196 = v193 - v190;
                  *(_DWORD *)(a5 + 32) = v193 - v190;
                  *(_DWORD *)(a5 + 36) = v195;
                  if (v193 - v190 < 0x800001)
                  {
                    v197 = *(unsigned int *)(a5 + 8);
                    v198 = *(_DWORD *)(a5 + 44);
                    v199 = *(unsigned int *)(a5 + 28);
                    v200 = *(_DWORD *)(a5 + 24) + 8;
                    do
                    {
                      *(_DWORD *)(a5 + 24) = v200;
                      *(_DWORD *)(a5 + 32) = v196 << 8;
                      if (v199 < v197)
                      {
                        v201 = *(_QWORD *)a5;
                        *(_DWORD *)(a5 + 28) = v199 + 1;
                        v202 = *(unsigned __int8 *)(v201 + v199++);
                      }
                      else
                      {
                        v202 = 0;
                      }
                      v195 = (((v195 & 0x7FFFFF) << 8) | ((v202 | (v198 << 8)) >> 1)) ^ 0xFF;
                      *(_DWORD *)(a5 + 44) = v202;
                      *(_DWORD *)(a5 + 36) = v195;
                      v200 += 8;
                      v198 = v202;
                      v60 = v196 > 0x8000;
                      v196 <<= 8;
                    }
                    while (!v60);
                  }
                }
              }
              silk_decode_indices(v11 + 4288 * v173, (uint64_t *)a5, 0, 1, 0);
              a1 = (uint64_t)silk_decode_pulses(a5, v213, *(char *)(v11 + 4288 * v173 + 2789), *(char *)(v11 + 4288 * v173 + 2790), *(_DWORD *)(v11 + 4288 * v173 + 2328));
              v10 = v211;
              LODWORD(v12) = v211[1];
            }
            ++v173;
          }
          while (v173 < (int)v12);
        }
      }
      ++v172;
    }
    while (v172 < *(int *)(v11 + 2404));
  }
  if ((_DWORD)v12 != 2)
    goto LABEL_123;
  if (a3)
  {
    if (a3 != 2 || *(_DWORD *)(v11 + 4 * *(int *)(v11 + 2400) + 2432) != 1)
    {
      v107 = *(__int16 *)(v11 + 8578);
      LODWORD(v214) = *(__int16 *)(v11 + 8576);
      HIDWORD(v214) = v107;
      goto LABEL_123;
    }
    a1 = (uint64_t)silk_stereo_decode_pred((uint64_t *)a5, &v214);
    if (!*(_DWORD *)(v11 + 4 * *(int *)(v11 + 2400) + 6720))
      goto LABEL_112;
LABEL_122:
    v92 = 0;
    v10 = v211;
    goto LABEL_123;
  }
  a1 = (uint64_t)silk_stereo_decode_pred((uint64_t *)a5, &v214);
  if (*(_DWORD *)(v11 + 4 * *(int *)(v11 + 2400) + 6704))
    goto LABEL_122;
LABEL_112:
  v94 = *(_DWORD *)(a5 + 32);
  v93 = *(_DWORD *)(a5 + 36);
  v95 = v94 >> 8;
  v92 = -1;
  v96 = &silk_stereo_only_code_mid_iCDF;
  do
  {
    v97 = v94;
    v98 = *v96++;
    v94 = v95 * v98;
    ++v92;
    v99 = v93 - v95 * v98;
  }
  while (v93 < v95 * v98);
  v100 = v97 - v94;
  *(_DWORD *)(a5 + 32) = v97 - v94;
  *(_DWORD *)(a5 + 36) = v99;
  v10 = v211;
  if (v97 - v94 <= 0x800000)
  {
    v101 = *(unsigned int *)(a5 + 8);
    v102 = *(_DWORD *)(a5 + 44);
    v103 = *(unsigned int *)(a5 + 28);
    v104 = *(_DWORD *)(a5 + 24) + 8;
    do
    {
      *(_DWORD *)(a5 + 24) = v104;
      *(_DWORD *)(a5 + 32) = v100 << 8;
      if (v103 < v101)
      {
        v105 = *(_QWORD *)a5;
        *(_DWORD *)(a5 + 28) = v103 + 1;
        v106 = *(unsigned __int8 *)(v105 + v103++);
      }
      else
      {
        v106 = 0;
      }
      v99 = (((v99 & 0x7FFFFF) << 8) | ((v106 | (v102 << 8)) >> 1)) ^ 0xFF;
      *(_DWORD *)(a5 + 44) = v106;
      *(_DWORD *)(a5 + 36) = v99;
      v104 += 8;
      v102 = v106;
      v60 = v100 > 0x8000;
      v100 <<= 8;
    }
    while (!v60);
  }
LABEL_123:
  v108 = v10[1];
  LODWORD(v210) = v92 == 0;
  if (v108 == 2 && v92 == 0)
  {
    if (*(_DWORD *)(v11 + 8596) == 1)
    {
      bzero((void *)(v11 + 5636), 0x3C0uLL);
      v10 = v211;
      *(_OWORD *)(v11 + 5604) = 0u;
      *(_OWORD *)(v11 + 5620) = 0u;
      *(_OWORD *)(v11 + 5572) = 0u;
      *(_OWORD *)(v11 + 5588) = 0u;
      *(_DWORD *)(v11 + 6596) = 100;
      *v204 = 10;
      *(_DWORD *)(v11 + 8476) = 0;
      *(_DWORD *)(v11 + 6664) = 1;
      v108 = v10[1];
    }
    else
    {
      v108 = 2;
    }
  }
  v110 = v10[3] * v108;
  v111 = *v10 * v10[2];
  if (v110 < v111)
  {
    v112 = (char *)v206;
    v113 = (_DWORD *)((char *)v206 + 2 * *(int *)(v11 + 2328) + 4);
    v215 = (char *)v206;
    v216 = v113;
    v204 = v203;
    if (a3)
      goto LABEL_133;
LABEL_138:
    v114 = v10[1];
LABEL_139:
    if (v114 < 1)
      goto LABEL_159;
    goto LABEL_142;
  }
  a1 = MEMORY[0x24BDAC7A8](a1, a2);
  v112 = (char *)v203 - v115;
  v117 = (_DWORD *)((char *)&v203[1] + 2 * *v116 - v115);
  v215 = (char *)v203 - v115;
  v216 = v117;
  v204 = v203;
  if (!a3)
    goto LABEL_138;
LABEL_133:
  v114 = v10[1];
  if (*(_DWORD *)(v11 + 8596))
  {
    LODWORD(v210) = 0;
    if (a3 == 2 && v114 == 2)
    {
      LODWORD(v210) = *(_DWORD *)(v11 + 4 * *(int *)(v11 + 6688) + 6720) == 1;
      goto LABEL_142;
    }
    goto LABEL_139;
  }
  LODWORD(v210) = 1;
  if (v114 < 1)
  {
LABEL_159:
    *(_DWORD *)v112 = *(_DWORD *)(v11 + 8580);
    v129 = (int)v212;
    v207 = v112;
    *(_DWORD *)(v11 + 8580) = *(_DWORD *)&v112[2 * v212];
    goto LABEL_160;
  }
LABEL_142:
  v118 = *(_DWORD *)(v11 + 2400);
  v119 = 2 * (v118 > 0);
  v203[2] = v111;
  v203[3] = v110;
  if (a3 == 2)
  {
    v120 = __OFSUB__(v118, 1);
    v121 = v118 - 1;
    if (v121 < 0 == v120)
      v119 = 2 * (*(_DWORD *)(v11 + 4 * v121 + 2432) != 0);
  }
  a1 = silk_decode_frame(v11, (uint64_t *)a5, v112 + 4, (int *)&v212, a3, v119, (int)v207);
  v36 = (a1 + v36);
  v10 = v211;
  v122 = v211[1];
  ++*(_DWORD *)(v11 + 2400);
  if (v122 <= 1)
  {
    v112 = v215;
    goto LABEL_159;
  }
  v123 = v11 + 6720;
  v124 = -2;
  v125 = 1;
  do
  {
    if ((_DWORD)v210)
    {
      v127 = *(_DWORD *)(v11 + 2400);
      if (v124 + v127 + 1 < 1)
      {
        v128 = 0;
      }
      else if (a3 == 2)
      {
        v128 = 2 * (*(_DWORD *)(v123 + 4 * (v127 + v124)) != 0);
      }
      else if (*(_DWORD *)(v11 + 8596))
      {
        v128 = 1;
      }
      else
      {
        v128 = 2;
      }
      a1 = silk_decode_frame(v123 - 2432, (uint64_t *)a5, (&v215)[v125] + 4, (int *)&v212, a3, v128, (int)v207);
      v36 = (a1 + v36);
    }
    else
    {
      bzero((&v215)[v125] + 4, 2 * (int)v212);
    }
    ++*(_DWORD *)(v123 - 32);
    ++v125;
    v10 = v211;
    v126 = v211[1];
    v123 += 4288;
    --v124;
  }
  while (v125 < v126);
  v112 = v215;
  if ((_DWORD)v126 != 2 || *v211 != 2)
    goto LABEL_159;
  v158 = *(_DWORD *)(v11 + 2316);
  v129 = v212;
  v207 = v215;
  a1 = (uint64_t)silk_stereo_MS_to_LR((unsigned __int16 *)(v11 + 8576), v215, v216, (int *)&v214, v158, v212);
  v10 = v211;
LABEL_160:
  v130 = v10[2];
  v210 = (_DWORD *)v129;
  *v209 = v130 * (int)v129 / (1000 * *(__int16 *)(v11 + 2316));
  v131 = *v10;
  v132 = MEMORY[0x24BDAC7A8](a1, v112);
  v138 = (char *)v203 - v137;
  if (v131 == 2)
    v139 = (__int16 *)v138;
  else
    v139 = (__int16 *)v206;
  v140 = v134[1];
  if (v135 < v136)
  {
    v141 = *(int *)(v11 + 2328);
    MEMORY[0x24BDAC7A8](v132, v133);
    v143 = (char *)v203 - v142;
    memcpy((char *)v203 - v142, v206, 2 * v144);
    v134 = v211;
    v145 = &v143[2 * v141];
    a3 = v208;
    v207 = v143;
    v215 = v143;
    v216 = v145 + 4;
  }
  if (v131 >= v140)
    v146 = v140;
  else
    v146 = v131;
  if (v146 >= 1)
  {
    v147 = 0;
    v148 = v206;
    do
    {
      v150 = silk_resampler((int *)(v11 + 4288 * v147 + 2448), v139, (&v215)[v147] + 2, (int)v210);
      v134 = v211;
      v131 = *v211;
      if (*v211 == 2)
      {
        v151 = *v209;
        if ((int)v151 >= 1)
        {
          v152 = v139;
          v153 = v148;
          do
          {
            v154 = *v152++;
            *v153 = v154;
            v153 += 2;
            --v151;
          }
          while (v151);
        }
      }
      v36 = (v150 + v36);
      ++v147;
      v140 = v134[1];
      if (v131 >= v140)
        v149 = v134[1];
      else
        v149 = v131;
      v148 = (_DWORD *)((char *)v148 + 2);
    }
    while (v147 < v149);
    a3 = v208;
  }
  if (v131 != 2 || v140 != 1)
    goto LABEL_203;
  if (!v205)
  {
    v159 = *v209;
    if ((int)v159 < 1)
      goto LABEL_203;
    if ((_DWORD)v159 == 1)
    {
      v160 = 0;
LABEL_201:
      v164 = v159 - v160;
      v165 = (_WORD *)&v206[v160] + 1;
      do
      {
        *v165 = *(v165 - 1);
        v165 += 2;
        --v164;
      }
      while (v164);
      goto LABEL_203;
    }
    v160 = v159 & 0xFFFFFFFE;
    v161 = (__int16 *)(v206 + 1);
    v162 = v160;
    do
    {
      v163 = *v161;
      *(v161 - 1) = *(v161 - 2);
      v161[1] = v163;
      v161 += 4;
      v162 -= 2;
    }
    while (v162);
    if (v160 != v159)
      goto LABEL_201;
LABEL_203:
    result = v36;
    if (*(_DWORD *)(v11 + 4188) == 2)
      goto LABEL_187;
    goto LABEL_204;
  }
  result = silk_resampler((int *)(v11 + 6736), v139, v207 + 2, (int)v210) + v36;
  v155 = *v209;
  if ((int)v155 < 1)
  {
    v134 = v211;
    if (*(_DWORD *)(v11 + 4188) == 2)
      goto LABEL_187;
LABEL_204:
    v134[5] = 0;
    if (a3 != 1)
      goto LABEL_188;
    goto LABEL_205;
  }
  v156 = (_WORD *)v206 + 1;
  v134 = v211;
  do
  {
    v157 = *v139++;
    *v156 = v157;
    v156 += 2;
    --v155;
  }
  while (v155);
  if (*(_DWORD *)(v11 + 4188) != 2)
    goto LABEL_204;
LABEL_187:
  v134[5] = dword_208F332A8[(*(_DWORD *)(v11 + 2316) - 8) >> 2] * *(_DWORD *)(v11 + 2308);
  if (a3 != 1)
  {
LABEL_188:
    *(_DWORD *)(v11 + 8596) = v92;
    return result;
  }
LABEL_205:
  v166 = *(unsigned int *)(v11 + 8592);
  if ((int)v166 < 1)
    return result;
  if ((_DWORD)v166 == 1)
  {
    v167 = 0;
LABEL_211:
    v170 = v166 - v167;
    v171 = (_BYTE *)(v11 + 4288 * v167 + 2312);
    do
    {
      *v171 = 10;
      v171 += 4288;
      --v170;
    }
    while (v170);
    return result;
  }
  v167 = v166 & 0xFFFFFFFE;
  v168 = v167;
  v169 = v11;
  do
  {
    *(_BYTE *)(v169 + 2312) = 10;
    *(_BYTE *)(v169 + 6600) = 10;
    v169 += 8576;
    v168 -= 2;
  }
  while (v168);
  if (v167 != v166)
    goto LABEL_211;
  return result;
}

__n128 silk_decode_core(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  int16x4_t *v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  int v46;
  int v47;
  unsigned int v48;
  unsigned int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  int v54;
  signed int v55;
  unsigned int v56;
  unsigned int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  unsigned int v62;
  signed int v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  __int16 *v72;
  int v73;
  int v74;
  _BOOL4 v76;
  uint64_t v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  int v82;
  int v83;
  int v84;
  uint64_t v85;
  int v86;
  char *v87;
  char *v88;
  unint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  uint64_t v99;
  int8x16_t v100;
  int16x8_t v101;
  int32x4_t v102;
  int32x4_t v103;
  int32x4_t v104;
  int8x16_t v105;
  int8x16_t v106;
  int8x16_t *v107;
  int v108;
  uint64_t v109;
  char *v110;
  int8x16_t v111;
  int32x4_t v112;
  int8x16_t v113;
  int32x4_t v114;
  int32x4_t v115;
  int8x16_t v116;
  int8x16_t v117;
  uint64_t v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  char *v127;
  char *v128;
  char *v129;
  int v130;
  uint64_t v131;
  int v132;
  uint64_t v133;
  int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  int v139;
  int v140;
  int v141;
  int v142;
  uint64_t v143;
  int v144;
  int v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  unint64_t v151;
  unsigned int v152;
  __int16 v153;
  int *v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  int *v158;
  unint64_t v159;
  uint64_t v160;
  __int128 v161;
  uint64_t v162;
  __n128 result;
  __int128 v164;
  _QWORD v165[2];
  char *v166;
  char *v167;
  char *v168;
  int v169;
  char *v170;
  char *v171;
  char *v172;
  char *v173;
  uint64_t v174;
  int v175;
  uint64_t v176;
  unint64_t v177;
  int v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  int16x4_t *v189;
  uint64_t v190;
  char *v191;
  __int16 v192;
  __int16 v193;
  __int16 v194;
  __int16 v195;
  __int16 v196;
  __int16 v197;
  __int16 v198;
  __int16 v199;
  __int16 v200;
  __int16 v201;
  __int16 v202;
  __int16 v203;
  __int16 v204;
  __int16 v205;
  __int16 v206;
  __int16 v207;
  uint64_t v208;

  v169 = a5;
  v166 = a3;
  v5 = a1;
  v165[1] = v165;
  v208 = *MEMORY[0x24BDAC8D0];
  v6 = MEMORY[0x24BDAC7A8](a1, a2);
  v8 = (char *)v165 - ((v7 + 15) & 0x3FFFFFFF0);
  v10 = MEMORY[0x24BDAC7A8](v6, v9);
  v12 = (char *)v165 - v11;
  v14 = MEMORY[0x24BDAC7A8](v10, v13);
  v16 = (char *)v165 - ((v15 + 15) & 0x7FFFFFFF0);
  v18 = MEMORY[0x24BDAC7A8](v14, v17);
  v22 = (int *)((char *)v165 - v21);
  v175 = *(char *)(v18 + 2791);
  if (v23 >= 1)
  {
    v24 = 0;
    v25 = *(char *)(v5 + 2794);
    v26 = 16 * silk_Quantization_Offsets_Q10[2 * (*(char *)(v5 + 2789) >> 1) + *(char *)(v5 + 2790)];
    do
    {
      v27 = 196314165 * v25 + 907633515;
      v28 = *(__int16 *)(v20 + 2 * v24);
      v29 = v28 << 14;
      if (v28 < 0)
        v29 = (v28 << 14) | 0x500;
      if (v28 > 0)
        v29 = (v28 << 14) - 1280;
      v30 = v29 + v26;
      if (v27 < 0)
        v30 = -v30;
      *(_DWORD *)(v5 + 4 + 4 * v24) = v30;
      v25 = v27 + v28;
      ++v24;
    }
    while (v24 < *(int *)(v5 + 2328));
  }
  v31 = *(_OWORD *)(v5 + 1300);
  *(_OWORD *)v22 = *(_OWORD *)(v5 + 1284);
  *((_OWORD *)v22 + 1) = v31;
  v32 = *(_OWORD *)(v5 + 1316);
  v33 = *(_OWORD *)(v5 + 1332);
  v165[0] = v5 + 1284;
  *((_OWORD *)v22 + 2) = v32;
  *((_OWORD *)v22 + 3) = v33;
  if (*(int *)(v5 + 2324) >= 1)
  {
    v34 = 0;
    v35 = v5 + 4;
    v178 = *(_DWORD *)(v5 + 2336);
    v168 = v8 - 14;
    v167 = v12 - 28;
    v170 = v12 - 8;
    v191 = v166;
    v180 = v19;
    v174 = v5;
    v173 = v8;
    v172 = v12;
    v171 = v16;
    do
    {
      v41 = (int16x4_t *)(v19 + 32 * (v34 >> 1) + 32);
      __memcpy_chk();
      v19 = v180;
      v42 = *(_DWORD *)(v180 + 4 * v34 + 16);
      if (v42 >= 0)
        v43 = *(_DWORD *)(v180 + 4 * v34 + 16);
      else
        v43 = -v42;
      v44 = __clz(v43);
      v45 = v42 << (v44 - 1);
      v46 = 0x1FFFFFFF / (v45 >> 16);
      v47 = ((unint64_t)((int)((unint64_t)-(uint64_t)((((uint64_t)(__int16)v46 << 19) * v45) & 0xFFFFFFF800000000) >> 32)
                              * (uint64_t)v46) >> 16)
          + (v46 << 16);
      v48 = v43 >> 17;
      v49 = v47 >> (15 - v44);
      v50 = (int)0x80000000 >> (v44 - 15);
      if (v47 > v50)
        v50 = ((unint64_t)((int)((unint64_t)-(uint64_t)((((uint64_t)(__int16)v46 << 19) * v45) & 0xFFFFFFF800000000) >> 32)
                                * (uint64_t)v46) >> 16)
            + (v46 << 16);
      if (v47 <= (int)(0x7FFFFFFFu >> (v44 - 15)))
        v51 = v50;
      else
        v51 = 0x7FFFFFFFu >> (v44 - 15);
      v52 = v51 << (v44 - 15);
      if (v48)
        v53 = v49;
      else
        v53 = v52;
      v54 = *(_DWORD *)v5;
      if (v42 == *(_DWORD *)v5)
      {
        v55 = 0x10000;
      }
      else
      {
        if (v54 >= 0)
          v56 = *(_DWORD *)v5;
        else
          v56 = -v54;
        v57 = __clz(v56);
        v58 = ((unint64_t)((__int16)v46
                                * (uint64_t)(int)((v54 << (v57 - 1))
                                               - (((unint64_t)((int)(((__int16)v46 * (uint64_t)(v54 << (v57 - 1))) >> 16)
                                                                    * (uint64_t)v45) >> 29) & 0xFFFFFFF8))) >> 16)
            + (((__int16)v46 * (uint64_t)(v54 << (v57 - 1))) >> 16);
        v59 = v57 - v44;
        if ((v59 + 29) >= 0x30)
          v60 = 0;
        else
          v60 = v58 >> (v59 + 13);
        v61 = (int)0x80000000 >> (-13 - v59);
        if (v61 <= v58)
          v61 = v58;
        if ((int)(0x7FFFFFFFu >> (-13 - v59)) >= v58)
          v62 = v61;
        else
          v62 = 0x7FFFFFFFu >> (-13 - v59);
        v63 = v62 << (-13 - v59);
        if (v59 <= -14)
          v55 = v63;
        else
          v55 = v60;
        v64 = (unint64_t)(v22[1] * (uint64_t)v55) >> 16;
        *v22 = (unint64_t)(*v22 * (uint64_t)v55) >> 16;
        v22[1] = v64;
        v65 = (unint64_t)(v22[3] * (uint64_t)v55) >> 16;
        v22[2] = (unint64_t)(v22[2] * (uint64_t)v55) >> 16;
        v22[3] = v65;
        v66 = (unint64_t)(v22[5] * (uint64_t)v55) >> 16;
        v22[4] = (unint64_t)(v22[4] * (uint64_t)v55) >> 16;
        v22[5] = v66;
        v67 = (unint64_t)(v22[7] * (uint64_t)v55) >> 16;
        v22[6] = (unint64_t)(v22[6] * (uint64_t)v55) >> 16;
        v22[7] = v67;
        v68 = (unint64_t)(v22[9] * (uint64_t)v55) >> 16;
        v22[8] = (unint64_t)(v22[8] * (uint64_t)v55) >> 16;
        v22[9] = v68;
        v69 = (unint64_t)(v22[11] * (uint64_t)v55) >> 16;
        v22[10] = (unint64_t)(v22[10] * (uint64_t)v55) >> 16;
        v22[11] = v69;
        v70 = (unint64_t)(v22[13] * (uint64_t)v55) >> 16;
        v22[12] = (unint64_t)(v22[12] * (uint64_t)v55) >> 16;
        v22[13] = v70;
        v71 = (unint64_t)(v22[15] * (uint64_t)v55) >> 16;
        v22[14] = (unint64_t)(v22[14] * (uint64_t)v55) >> 16;
        v22[15] = v71;
      }
      v72 = (__int16 *)(v19 + 2 * (5 * v34) + 96);
      v73 = *(unsigned __int8 *)(v5 + 2789);
      *(_DWORD *)v5 = v42;
      if (*(_DWORD *)(v5 + 4184) && *(_DWORD *)(v5 + 4188) == 2 && v34 <= 1 && v73 != 2)
      {
        *(_QWORD *)v72 = 0;
        *(_WORD *)(v19 + 2 * (5 * v34) + 104) = 0;
        *(_WORD *)(v19 + 2 * (5 * v34) + 100) = 4096;
        v74 = *(_DWORD *)(v5 + 2308);
        *(_DWORD *)(v19 + 4 * v34) = v74;
        v76 = v175 < 4 && v34 == 2;
        if (!v34)
          goto LABEL_69;
      }
      else
      {
        if (v73 != 2)
        {
          v36 = *(unsigned int *)(v5 + 2332);
          v190 = v35;
          if ((int)v36 >= 1)
            goto LABEL_99;
          goto LABEL_13;
        }
        v74 = *(_DWORD *)(v19 + 4 * v34);
        v76 = v175 < 4 && v34 == 2;
        if (!v34)
          goto LABEL_69;
      }
      if (!v76)
      {
        if (v55 == 0x10000 || v74 < -1)
          goto LABEL_95;
        v78 = (v74 + 2);
        if (v78 >= 0xC)
        {
          v79 = 0;
          v108 = v178 - 1;
          if (v178 - (int)v78 <= v178 - 1 && !((unint64_t)(v78 - 1) >> 32))
          {
            v79 = v78 & 0xFFFFFFF8;
            v109 = v79;
            do
            {
              v110 = &v12[4 * v108];
              v111 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v110 - 12));
              v112 = (int32x4_t)vextq_s8(v111, v111, 8uLL);
              v113 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v110 - 28));
              v114 = (int32x4_t)vextq_s8(v113, v113, 8uLL);
              v115 = vdupq_n_s32(v55);
              v116 = (int8x16_t)vrev64q_s32(vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v115.i8, *(int32x2_t *)v112.i8), 0x10uLL), vmull_high_s32(v115, v112), 0x10uLL));
              *(int8x16_t *)(v110 - 12) = vextq_s8(v116, v116, 8uLL);
              v117 = (int8x16_t)vrev64q_s32(vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v115.i8, *(int32x2_t *)v114.i8), 0x10uLL), vmull_high_s32(v115, v114), 0x10uLL));
              *(int8x16_t *)(v110 - 28) = vextq_s8(v117, v117, 8uLL);
              v108 -= 8;
              v109 -= 8;
            }
            while (v109);
            if (v79 == v78)
              goto LABEL_95;
          }
        }
        else
        {
          v79 = 0;
        }
        v118 = v78 - v79;
        v119 = ~(_DWORD)v79 + v178;
        do
        {
          *(_DWORD *)&v12[4 * v119] = (unint64_t)(*(int *)&v12[4 * v119] * (uint64_t)v55) >> 16;
          --v119;
          --v118;
        }
        while (v118);
        goto LABEL_95;
      }
LABEL_69:
      v188 = v53;
      v189 = v41;
      v179 = v35;
      v80 = *(_DWORD *)(v5 + 2336);
      v81 = *(unsigned int *)(v5 + 2340);
      v82 = *(_DWORD *)(v5 + 2332);
      v190 = v19 + 2 * (5 * v34) + 96;
      if (v34 == 2)
      {
        v83 = v74;
        memcpy((void *)(v5 + 2 * v80 + 1348), v166, 4 * v82);
        v74 = v83;
        v82 = *(_DWORD *)(v5 + 2332);
        v84 = *(_DWORD *)(v5 + 2336);
        v85 = *(unsigned int *)(v5 + 2340);
      }
      else
      {
        v85 = v81;
        v84 = v80;
      }
      v86 = v74;
      silk_LPC_analysis_filter(&v8[2 * (v80 - v74 - (int)v81) - 4], v5 + 2 * (v80 - v74 - (int)v81 - 2 + v82 * (int)v34) + 1348, v189, v84 - (v80 - v74 - v81 - 2), v85);
      if (v34)
      {
        v35 = v179;
        v19 = v180;
        v87 = v168;
        v88 = v167;
        v72 = (__int16 *)v190;
        LODWORD(v89) = v188;
        v74 = v86;
        if (v86 < -1)
          goto LABEL_95;
      }
      else
      {
        v35 = v179;
        v19 = v180;
        v89 = ((unint64_t)(*(__int16 *)(v180 + 136) * (uint64_t)(int)v188) >> 14) & 0xFFFFFFFC;
        v87 = v168;
        v88 = v167;
        v72 = (__int16 *)v190;
        v74 = v86;
        if (v86 < -1)
          goto LABEL_95;
      }
      v90 = *(_DWORD *)(v5 + 2336);
      v91 = (v74 + 2);
      if (v91 >= 0x18)
      {
        v92 = 0;
        v97 = v90 - 1;
        if (v90 - (int)v91 <= v90 - 1)
        {
          v98 = v178 - 1;
          if (v178 - (int)v91 <= v178 - 1 && !((unint64_t)(v91 - 1) >> 32))
          {
            v92 = v91 & 0xFFFFFFF8;
            v99 = v92;
            do
            {
              v100 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v87[2 * v97]);
              v101 = (int16x8_t)vextq_s8(v100, v100, 8uLL);
              v102 = vmovl_high_s16(v101);
              v103 = vmovl_s16(*(int16x4_t *)v101.i8);
              v104 = vdupq_n_s32(v89);
              v105 = (int8x16_t)vrev64q_s32(vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v104.i8, *(int32x2_t *)v103.i8), 0x10uLL), vmull_high_s32(v104, v103), 0x10uLL));
              v106 = (int8x16_t)vrev64q_s32(vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v104.i8, *(int32x2_t *)v102.i8), 0x10uLL), vmull_high_s32(v104, v102), 0x10uLL));
              v107 = (int8x16_t *)&v88[4 * v98];
              *v107 = vextq_s8(v106, v106, 8uLL);
              v107[1] = vextq_s8(v105, v105, 8uLL);
              v98 -= 8;
              v97 -= 8;
              v99 -= 8;
            }
            while (v99);
            if (v92 == v91)
              goto LABEL_95;
          }
        }
      }
      else
      {
        v92 = 0;
      }
      v93 = v91 - v92;
      v94 = ~(_DWORD)v92;
      v95 = ~(_DWORD)v92 + v178;
      v96 = v94 + v90;
      do
      {
        *(_DWORD *)&v12[4 * v95--] = (unint64_t)(*(__int16 *)&v8[2 * v96--] * (uint64_t)(int)v89) >> 16;
        --v93;
      }
      while (v93);
LABEL_95:
      v120 = *(unsigned int *)(v5 + 2332);
      if ((int)v120 >= 1)
      {
        v121 = 0;
        v122 = *v72 << 16;
        v123 = v72[1] << 16;
        v124 = v72[4];
        v125 = v72[2] << 16;
        v126 = v72[3] << 16;
        v127 = &v12[4 * v178];
        v128 = &v170[4 * (v178 - v74) + 8];
        v129 = v128;
        do
        {
          v130 = *((_DWORD *)v129 + 1);
          v129 += 4;
          v131 = 4 * v121;
          v132 = *(_DWORD *)(v35 + 4 * v121)
               + 2
               * (((((v123 * (uint64_t)v130) & 0xFFFFFFFF00000000)
                  + v122 * (uint64_t)*((int *)v128 + 2)
                  + ((v125 * (uint64_t)*(int *)v128) & 0xFFFFFFFF00000000)
                  + ((v126 * (uint64_t)*((int *)v128 - 1)) & 0x7FFFFFFF00000000)
                  + 0x200000000) >> 32)
                + ((unint64_t)(*((int *)v128 - 2) * (uint64_t)v124) >> 16));
          *(_DWORD *)&v16[v131] = v132;
          *(_DWORD *)&v127[v131] = 2 * v132;
          ++v121;
          v128 = v129;
        }
        while (v120 != v121);
        v178 += v121;
        v36 = v120;
        v190 = (uint64_t)v16;
LABEL_99:
        v179 = v35;
        v177 = v34;
        v133 = 0;
        v134 = *(_DWORD *)(v5 + 2340);
        v189 = (int16x4_t *)v192;
        LODWORD(v188) = v134 >> 1;
        v187 = v193;
        v135 = v194;
        v136 = v195;
        v137 = v196;
        v138 = v197;
        v139 = v198;
        v140 = v199;
        v141 = v200;
        v142 = v201;
        v186 = v202;
        v185 = v203;
        v184 = v204;
        v183 = v205;
        v182 = v206;
        v181 = v207;
        v176 = v36;
        v143 = v36;
        v144 = v22[15];
        v145 = v22[13];
        v146 = v22[11];
        v147 = v22[9];
        v148 = v22[7];
        do
        {
          v154 = &v22[v133];
          v155 = v135 * (uint64_t)v145;
          v145 = v154[14];
          v156 = v137 * (uint64_t)v146;
          v146 = v154[12];
          v157 = v139 * (uint64_t)v147;
          v147 = v154[10];
          v158 = v22;
          v159 = v141 * (uint64_t)v148;
          v148 = v154[8];
          v149 = v188
               + (v159 >> 16)
               + (v157 >> 16)
               + (v156 >> 16)
               + (v155 >> 16)
               + ((unint64_t)((int)v189 * (uint64_t)v144) >> 16)
               + ((unint64_t)(v145 * (uint64_t)(int)v187) >> 16)
               + ((unint64_t)(v146 * (uint64_t)v136) >> 16)
               + ((unint64_t)(v147 * (uint64_t)v138) >> 16)
               + ((unint64_t)(v148 * (uint64_t)v140) >> 16)
               + ((unint64_t)(v154[6] * (uint64_t)v142) >> 16);
          v160 = v133 + 1;
          if (v134 == 16)
            v149 += ((unint64_t)(v154[5] * (uint64_t)(int)v186) >> 16)
                  + ((unint64_t)(v154[4] * (uint64_t)(int)v185) >> 16)
                  + ((unint64_t)(v154[3] * (uint64_t)(int)v184) >> 16)
                  + ((unint64_t)(v154[2] * (uint64_t)(int)v183) >> 16)
                  + ((unint64_t)(v158[v133 + 1] * (uint64_t)(int)v182) >> 16)
                  + ((unint64_t)(*v154 * (uint64_t)(int)v181) >> 16);
          v22 = v158;
          if (v149 <= -134217728)
            v149 = -134217728;
          if (v149 >= 0x7FFFFFF)
            v149 = 0x7FFFFFF;
          v150 = vqadds_s32(*(_DWORD *)(v190 + 4 * v133), 16 * v149);
          v158[v133 + 16] = v150;
          v144 = v150;
          v151 = (unint64_t)((v42 >> 6) * (uint64_t)v150) >> 16;
          v152 = ((v151 >> 7) + 1) >> 1;
          if ((int)v151 < -8388736)
            LOWORD(v152) = 0x8000;
          if ((int)v151 <= 8388479)
            v153 = v152;
          else
            v153 = 0x7FFF;
          *(_WORD *)&v191[2 * v133++] = v153;
        }
        while (v160 != v143);
        v35 = v179;
        v19 = v180;
        v5 = v174;
        v8 = v173;
        v12 = v172;
        v16 = v171;
        LODWORD(v36) = v176;
        v34 = v177;
        goto LABEL_13;
      }
      LODWORD(v36) = *(_DWORD *)(v5 + 2332);
LABEL_13:
      v37 = (int)v36;
      v38 = *(_OWORD *)&v22[v37];
      v39 = *(_OWORD *)&v22[v37 + 4];
      v40 = *(_OWORD *)&v22[v37 + 12];
      *((_OWORD *)v22 + 2) = *(_OWORD *)&v22[v37 + 8];
      *((_OWORD *)v22 + 3) = v40;
      *(_OWORD *)v22 = v38;
      *((_OWORD *)v22 + 1) = v39;
      v35 += v37 * 4;
      v191 += 2 * (int)v36;
      ++v34;
    }
    while ((uint64_t)v34 < *(int *)(v5 + 2324));
  }
  v161 = *((_OWORD *)v22 + 1);
  v162 = v165[0];
  *(_OWORD *)v165[0] = *(_OWORD *)v22;
  *(_OWORD *)(v162 + 16) = v161;
  result = *((__n128 *)v22 + 2);
  v164 = *((_OWORD *)v22 + 3);
  *(__n128 *)(v162 + 32) = result;
  *(_OWORD *)(v162 + 48) = v164;
  return result;
}

uint64_t silk_decode_frame(uint64_t a1, uint64_t *a2, char *a3, int *a4, int a5, int a6, int a7)
{
  int v13;
  uint64_t v14;
  __int16 *v15;
  int v16;
  uint64_t v17;
  size_t v18;
  uint64_t v20;
  int32x4_t v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v13 = *(_DWORD *)(a1 + 2328);
  v22 = 0;
  if (!a5 || a5 == 2 && *(_DWORD *)(a1 + 4 * *(int *)(a1 + 2400) + 2432) == 1)
  {
    MEMORY[0x24BDAC7A8](a1, a2);
    v15 = (__int16 *)((char *)&v20 - v14);
    silk_decode_indices(a1, a2, *(_DWORD *)(a1 + 2400), v16, a6);
    silk_decode_pulses((uint64_t)a2, v15, *(char *)(a1 + 2789), *(char *)(a1 + 2790), *(_DWORD *)(a1 + 2328));
    silk_decode_parameters(a1, (int16x8_t *)&v21, a6);
    silk_decode_core(a1, (uint64_t)&v21, a3, (uint64_t)v15, a7);
    silk_PLC(a1, &v21, (uint64_t)a3, 0, a7);
    *(_DWORD *)(a1 + 4184) = 0;
    *(_DWORD *)(a1 + 4188) = *(char *)(a1 + 2789);
    *(_DWORD *)(a1 + 2376) = 0;
  }
  else
  {
    silk_PLC(a1, &v21, (uint64_t)a3, 1, a7);
  }
  v17 = *(int *)(a1 + 2328);
  v18 = 2 * (*(_DWORD *)(a1 + 2336) - (int)v17);
  memmove((void *)(a1 + 1348), (const void *)(a1 + 1348 + 2 * v17), v18);
  memcpy((void *)(a1 + 1348 + v18), a3, 2 * *(int *)(a1 + 2328));
  silk_CNG((char *)a1, (uint64_t)&v21, (uint64_t)a3, v13);
  silk_PLC_glue_frames((_DWORD *)a1, (__int16 *)a3, v13);
  *(_DWORD *)(a1 + 2308) = v21.i32[*(int *)(a1 + 2324) - 1];
  *a4 = v13;
  return 0;
}

uint64_t silk_decode_indices(uint64_t result, uint64_t *a2, int a3, int a4, int a5)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  BOOL v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  _BYTE *v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  char v28;
  unint64_t v29;
  int v30;
  unint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  char v39;
  unint64_t v40;
  int v41;
  unint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  int v51;
  unsigned int v52;
  char v53;
  unint64_t v54;
  int v55;
  unint64_t v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t i;
  uint64_t v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  unsigned int v68;
  unint64_t v69;
  int v70;
  unint64_t v71;
  int v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  __int16 *v76;
  uint64_t v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  unsigned int v82;
  int v83;
  unsigned int v84;
  char v85;
  unint64_t v86;
  int v87;
  unint64_t v88;
  int v89;
  uint64_t v90;
  int v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unsigned __int8 *v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  __int16 *v99;
  uint8x16_t *v100;
  int8x16_t v101;
  int8x16_t v102;
  unint64_t v103;
  uint8x16_t v104;
  uint8x16_t v105;
  uint8x16_t v106;
  uint8x16_t v107;
  uint8x16_t v108;
  __int16 *v109;
  __int16 *v110;
  __int16 *v111;
  __int16 *v112;
  uint8x8_t *v113;
  unint64_t v114;
  __int16 *v115;
  uint8x8_t v116;
  unsigned int v117;
  unsigned int v118;
  unsigned int v119;
  char *v120;
  unsigned int v121;
  int v122;
  unint64_t v123;
  int v124;
  unint64_t v125;
  int v126;
  uint64_t v127;
  int v128;
  unsigned int v129;
  unsigned int v130;
  _WORD *v131;
  uint64_t v132;
  uint64_t v133;
  unsigned __int8 *v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  int v139;
  unsigned int v140;
  unsigned int v141;
  unint64_t v142;
  int v143;
  unint64_t v144;
  int v145;
  uint64_t v146;
  int v147;
  unsigned int v148;
  unsigned int v149;
  unsigned int v150;
  int v151;
  unsigned int v152;
  unint64_t v153;
  int v154;
  unint64_t v155;
  int v156;
  uint64_t v157;
  int v158;
  unsigned int v159;
  unsigned int v160;
  int v161;
  unsigned int v162;
  unint64_t v163;
  int v164;
  unint64_t v165;
  int v166;
  uint64_t v167;
  int v168;
  uint64_t v169;
  unsigned int v170;
  unsigned int v171;
  unsigned int v172;
  unsigned int v173;
  int v174;
  unsigned int v175;
  char v176;
  unint64_t v177;
  int v178;
  unint64_t v179;
  int v180;
  uint64_t v181;
  int v182;
  int v183;
  unsigned int v184;
  unsigned int v185;
  uint64_t v186;
  unsigned int v187;
  int v188;
  unsigned int v189;
  unsigned int v190;
  unsigned int v191;
  unint64_t v192;
  int v193;
  unint64_t v194;
  int v195;
  uint64_t v196;
  int v197;
  __int16 v198;
  unsigned int v199;
  int v200;
  char *v201;
  unsigned int v202;
  int v203;
  unsigned int v204;
  unsigned int v205;
  unint64_t v206;
  int v207;
  unint64_t v208;
  int v209;
  uint64_t v210;
  int v211;
  unsigned int v212;
  uint64_t v213;
  int v214;
  unsigned int v215;
  unsigned int v216;
  unsigned int v217;
  __int16 v218;
  unint64_t v219;
  int v220;
  unint64_t v221;
  int v222;
  uint64_t v223;
  int v224;
  uint64_t v225;
  unsigned int v226;
  unsigned int v227;
  unsigned int v228;
  unsigned int v229;
  char v230;
  unint64_t v231;
  int v232;
  unint64_t v233;
  int v234;
  uint64_t v235;
  int v236;
  unsigned int v237;
  uint64_t v238;
  unsigned int v239;
  unsigned int v240;
  int v241;
  unsigned int v242;
  char v243;
  unint64_t v244;
  int v245;
  unint64_t v246;
  int v247;
  uint64_t v248;
  int v249;
  uint64_t j;
  uint64_t v251;
  unsigned int v252;
  unsigned int v253;
  unsigned int v254;
  unsigned int v255;
  int v256;
  unsigned int v257;
  unint64_t v258;
  int v259;
  unint64_t v260;
  int v261;
  uint64_t v262;
  int v263;
  char v264;
  uint64_t v265;
  unsigned int v266;
  unsigned int v267;
  unsigned int v268;
  unsigned int v269;
  int v270;
  unsigned int v271;
  unint64_t v272;
  int v273;
  unint64_t v274;
  int v275;
  uint64_t v276;
  int v277;
  uint64_t v278;
  unsigned int v279;
  unsigned int v280;
  unsigned int v281;
  unsigned int v282;
  int v283;
  unsigned int v284;
  char v285;
  unint64_t v286;
  int v287;
  unint64_t v288;
  int v289;
  uint64_t v290;
  int v291;
  _WORD v292[16];
  uint64_t v293;
  uint64_t vars8;
  int16x8x2_t v295;
  int16x8x2_t v296;
  int16x8x2_t v297;
  int16x8x2_t v298;

  v293 = *MEMORY[0x24BDAC8D0];
  if (a4 || *(_DWORD *)(result + 4 * a3 + 2416))
  {
    v5 = 0;
    v6 = *((_DWORD *)a2 + 8);
    v7 = *((_DWORD *)a2 + 9);
    v8 = v6 >> 8;
    do
    {
      v9 = v6;
      v6 = v8 * silk_type_offset_VAD_iCDF[v5++];
      v10 = v7 - v6;
    }
    while (v7 < v6);
    *((_DWORD *)a2 + 9) = v10;
    v11 = v9 - v6;
    if (v11 >= 0x800001)
    {
      v19 = v11;
    }
    else
    {
      v12 = *((unsigned int *)a2 + 2);
      v13 = *((_DWORD *)a2 + 11);
      v14 = *((unsigned int *)a2 + 7);
      v15 = *((_DWORD *)a2 + 6) + 8;
      do
      {
        *((_DWORD *)a2 + 6) = v15;
        v19 = v11 << 8;
        *((_DWORD *)a2 + 8) = v11 << 8;
        if (v14 < v12)
        {
          v16 = *a2;
          *((_DWORD *)a2 + 7) = v14 + 1;
          v17 = *(unsigned __int8 *)(v16 + v14++);
        }
        else
        {
          v17 = 0;
        }
        v10 = (((v10 & 0x7FFFFF) << 8) | ((v17 | (v13 << 8)) >> 1)) ^ 0xFF;
        *((_DWORD *)a2 + 11) = v17;
        *((_DWORD *)a2 + 9) = v10;
        v15 += 8;
        v13 = v17;
        v18 = v11 > 0x8000;
        v11 <<= 8;
      }
      while (!v18);
    }
    v20 = v5 + 1;
  }
  else
  {
    v117 = *((_DWORD *)a2 + 8);
    v118 = *((_DWORD *)a2 + 9);
    v119 = v117 >> 8;
    v20 = -1;
    v120 = &silk_type_offset_no_VAD_iCDF;
    do
    {
      v121 = v117;
      v122 = *v120++;
      v117 = v119 * v122;
      ++v20;
      v10 = v118 - v119 * v122;
    }
    while (v118 < v119 * v122);
    *((_DWORD *)a2 + 9) = v10;
    v19 = v121 - v117;
    if (v121 - v117 < 0x800001)
    {
      v123 = *((unsigned int *)a2 + 2);
      v124 = *((_DWORD *)a2 + 11);
      v125 = *((unsigned int *)a2 + 7);
      v126 = *((_DWORD *)a2 + 6) + 8;
      do
      {
        *((_DWORD *)a2 + 6) = v126;
        v129 = v19 << 8;
        *((_DWORD *)a2 + 8) = v19 << 8;
        if (v125 < v123)
        {
          v127 = *a2;
          *((_DWORD *)a2 + 7) = v125 + 1;
          v128 = *(unsigned __int8 *)(v127 + v125++);
        }
        else
        {
          v128 = 0;
        }
        v10 = (((v10 & 0x7FFFFF) << 8) | ((v128 | (v124 << 8)) >> 1)) ^ 0xFF;
        *((_DWORD *)a2 + 11) = v128;
        *((_DWORD *)a2 + 9) = v10;
        v126 += 8;
        v124 = v128;
        v18 = v19 > 0x8000;
        v19 <<= 8;
      }
      while (!v18);
      v19 = v129;
    }
  }
  v21 = v20 >> 1;
  v22 = (_BYTE *)(result + 2760);
  *(_BYTE *)(result + 2789) = v20 >> 1;
  *(_BYTE *)(result + 2790) = v20 & 1;
  v23 = v19 >> 8;
  if (a5 == 2)
  {
    v24 = 0;
    do
    {
      v25 = v19;
      v19 = v23 * silk_delta_gain_iCDF[v24++];
      v26 = v10 - v19;
    }
    while (v10 < v19);
    v27 = v25 - v19;
    *((_DWORD *)a2 + 8) = v27;
    *((_DWORD *)a2 + 9) = v26;
    v28 = v24 - 1;
    if (v27 < 0x800001)
    {
      v29 = *((unsigned int *)a2 + 2);
      v30 = *((_DWORD *)a2 + 11);
      v31 = *((unsigned int *)a2 + 7);
      v32 = *((_DWORD *)a2 + 6) + 8;
      do
      {
        *((_DWORD *)a2 + 6) = v32;
        *((_DWORD *)a2 + 8) = v27 << 8;
        if (v31 < v29)
        {
          v33 = *a2;
          *((_DWORD *)a2 + 7) = v31 + 1;
          v34 = *(unsigned __int8 *)(v33 + v31++);
        }
        else
        {
          v34 = 0;
        }
        v26 = (((v26 & 0x7FFFFF) << 8) | ((v34 | (v30 << 8)) >> 1)) ^ 0xFF;
        *((_DWORD *)a2 + 11) = v34;
        *((_DWORD *)a2 + 9) = v26;
        v32 += 8;
        v30 = v34;
        v18 = v27 > 0x8000;
        v27 <<= 8;
      }
      while (!v18);
    }
  }
  else
  {
    v35 = 0;
    do
    {
      v36 = v19;
      v19 = v23 * silk_gain_iCDF[8 * (char)v21 + v35++];
      v37 = v10 - v19;
    }
    while (v10 < v19);
    v38 = v36 - v19;
    *((_DWORD *)a2 + 8) = v36 - v19;
    *((_DWORD *)a2 + 9) = v37;
    v39 = v35 - 1;
    if (v38 < 0x800001)
    {
      v40 = *((unsigned int *)a2 + 2);
      v41 = *((_DWORD *)a2 + 11);
      v42 = *((unsigned int *)a2 + 7);
      v43 = *((_DWORD *)a2 + 6) + 8;
      do
      {
        *((_DWORD *)a2 + 6) = v43;
        *((_DWORD *)a2 + 8) = v38 << 8;
        if (v42 < v40)
        {
          v44 = *a2;
          *((_DWORD *)a2 + 7) = v42 + 1;
          v45 = *(unsigned __int8 *)(v44 + v42++);
        }
        else
        {
          v45 = 0;
        }
        v37 = (((v37 & 0x7FFFFF) << 8) | ((v45 | (v41 << 8)) >> 1)) ^ 0xFF;
        *((_DWORD *)a2 + 11) = v45;
        *((_DWORD *)a2 + 9) = v37;
        v43 += 8;
        v41 = v45;
        v18 = v38 > 0x8000;
        v38 <<= 8;
      }
      while (!v18);
    }
    v46 = 0;
    *v22 = 8 * v39;
    v48 = *((_DWORD *)a2 + 8);
    v47 = *((_DWORD *)a2 + 9);
    v49 = v48 >> 8;
    do
    {
      v50 = v48;
      v48 = v49 * silk_uniform8_iCDF[v46++];
      v51 = v47 - v48;
    }
    while (v47 < v48);
    v52 = v50 - v48;
    *((_DWORD *)a2 + 8) = v52;
    *((_DWORD *)a2 + 9) = v51;
    v53 = v46 - 1;
    if (v52 < 0x800001)
    {
      v54 = *((unsigned int *)a2 + 2);
      v55 = *((_DWORD *)a2 + 11);
      v56 = *((unsigned int *)a2 + 7);
      v57 = *((_DWORD *)a2 + 6) + 8;
      do
      {
        *((_DWORD *)a2 + 6) = v57;
        *((_DWORD *)a2 + 8) = v52 << 8;
        if (v56 < v54)
        {
          v58 = *a2;
          *((_DWORD *)a2 + 7) = v56 + 1;
          v59 = *(unsigned __int8 *)(v58 + v56++);
        }
        else
        {
          v59 = 0;
        }
        v51 = (((v51 & 0x7FFFFF) << 8) | ((v59 | (v55 << 8)) >> 1)) ^ 0xFF;
        *((_DWORD *)a2 + 11) = v59;
        *((_DWORD *)a2 + 9) = v51;
        v57 += 8;
        v55 = v59;
        v18 = v52 > 0x8000;
        v52 <<= 8;
      }
      while (!v18);
    }
    v28 = *v22 + v53;
  }
  *(_BYTE *)(result + 2760) = v28;
  v60 = *(unsigned int *)(result + 2324);
  if ((int)v60 >= 2)
  {
    for (i = 1; i != v60; ++i)
    {
      v62 = 0;
      v64 = *((_DWORD *)a2 + 8);
      v63 = *((_DWORD *)a2 + 9);
      v65 = v64 >> 8;
      do
      {
        v66 = v64;
        v64 = v65 * silk_delta_gain_iCDF[v62++];
        v67 = v63 - v64;
      }
      while (v63 < v64);
      v68 = v66 - v64;
      *((_DWORD *)a2 + 8) = v66 - v64;
      *((_DWORD *)a2 + 9) = v67;
      if (v66 - v64 < 0x800001)
      {
        v69 = *((unsigned int *)a2 + 2);
        v70 = *((_DWORD *)a2 + 11);
        v71 = *((unsigned int *)a2 + 7);
        v72 = *((_DWORD *)a2 + 6) + 8;
        do
        {
          *((_DWORD *)a2 + 6) = v72;
          *((_DWORD *)a2 + 8) = v68 << 8;
          if (v71 < v69)
          {
            v73 = *a2;
            *((_DWORD *)a2 + 7) = v71 + 1;
            v74 = *(unsigned __int8 *)(v73 + v71++);
          }
          else
          {
            v74 = 0;
          }
          v67 = (((v67 & 0x7FFFFF) << 8) | ((v74 | (v70 << 8)) >> 1)) ^ 0xFF;
          *((_DWORD *)a2 + 11) = v74;
          *((_DWORD *)a2 + 9) = v67;
          v72 += 8;
          v70 = v74;
          v18 = v68 > 0x8000;
          v68 <<= 8;
        }
        while (!v18);
      }
      v22[i] = v62 - 1;
    }
    LOBYTE(v21) = *(_BYTE *)(result + 2789);
  }
  v75 = 0;
  v76 = *(__int16 **)(result + 2752);
  v77 = *((_QWORD *)v76 + 3) + *v76 * (uint64_t)((char)v21 >> 1);
  v79 = *((_DWORD *)a2 + 8);
  v78 = *((_DWORD *)a2 + 9);
  v80 = v79 >> 8;
  v81 = -16777216;
  do
  {
    v82 = v79;
    v79 = v80 * *(unsigned __int8 *)(v77 + v75++);
    v81 += 0x1000000;
    v83 = v78 - v79;
  }
  while (v78 < v79);
  v84 = v82 - v79;
  *((_DWORD *)a2 + 8) = v82 - v79;
  *((_DWORD *)a2 + 9) = v83;
  v85 = v75 - 1;
  if (v82 - v79 < 0x800001)
  {
    v86 = *((unsigned int *)a2 + 2);
    v87 = *((_DWORD *)a2 + 11);
    v88 = *((unsigned int *)a2 + 7);
    v89 = *((_DWORD *)a2 + 6) + 8;
    do
    {
      *((_DWORD *)a2 + 6) = v89;
      *((_DWORD *)a2 + 8) = v84 << 8;
      if (v88 < v86)
      {
        v90 = *a2;
        *((_DWORD *)a2 + 7) = v88 + 1;
        v91 = *(unsigned __int8 *)(v90 + v88++);
      }
      else
      {
        v91 = 0;
      }
      v83 = (((v83 & 0x7FFFFF) << 8) | ((v91 | (v87 << 8)) >> 1)) ^ 0xFF;
      *((_DWORD *)a2 + 11) = v91;
      *((_DWORD *)a2 + 9) = v83;
      v89 += 8;
      v87 = v91;
      v18 = v84 > 0x8000;
      v84 <<= 8;
    }
    while (!v18);
  }
  *(_BYTE *)(result + 2768) = v85;
  if (v76[1] >= 1)
  {
    v92 = (unsigned __int16)v76[1];
    v93 = *((_QWORD *)v76 + 5);
    v94 = (uint64_t)((v81 >> 24) * (unsigned __int16)v76[1] + ((v81 >> 24) * (unsigned __int16)v76[1] < 0)) >> 1;
    v95 = (unsigned __int8 *)(v93 + v94);
    if ((unsigned __int16)v76[1] < 0xFu)
    {
      v96 = 0;
      goto LABEL_82;
    }
    v97 = ((v92 - 1) >> 1) + 1;
    if ((unsigned __int16)v76[1] >= 0x3Fu)
    {
      v98 = v97 & 0xFFFFFFFFFFFFFFE0;
      v99 = (__int16 *)&vars8;
      v100 = (uint8x16_t *)(v94 + v93 + 16);
      v101.i64[0] = 0x707070707070707;
      v101.i64[1] = 0x707070707070707;
      v102.i64[0] = 0x909090909090909;
      v102.i64[1] = 0x909090909090909;
      v103 = v97 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v104 = v100[-1];
        v105 = (uint8x16_t)vmulq_s8(vandq_s8((int8x16_t)vshrq_n_u8(v104, 1uLL), v101), v102);
        v106 = (uint8x16_t)vmulq_s8(vandq_s8((int8x16_t)vshrq_n_u8(*v100, 1uLL), v101), v102);
        v297.val[0] = (int16x8_t)vmovl_high_u8(v105);
        v107 = (uint8x16_t)vmulq_s8((int8x16_t)vshrq_n_u8(v104, 5uLL), v102);
        v297.val[1] = (int16x8_t)vmovl_high_u8(v107);
        v298.val[0] = (int16x8_t)vmovl_u8(*(uint8x8_t *)v105.i8);
        v298.val[1] = (int16x8_t)vmovl_u8(*(uint8x8_t *)v107.i8);
        v108 = (uint8x16_t)vmulq_s8((int8x16_t)vshrq_n_u8(*v100, 5uLL), v102);
        v295.val[0] = (int16x8_t)vmovl_u8(*(uint8x8_t *)v106.i8);
        v109 = v99 - 32;
        vst2q_s16(v109, v298);
        v295.val[1] = (int16x8_t)vmovl_u8(*(uint8x8_t *)v108.i8);
        v110 = v99 - 16;
        vst2q_s16(v110, v297);
        v111 = v99 + 64;
        vst2q_s16(v99, v295);
        v112 = v99 + 16;
        v295.val[0] = (int16x8_t)vmovl_high_u8(v106);
        v295.val[1] = (int16x8_t)vmovl_high_u8(v108);
        vst2q_s16(v112, v295);
        v100 += 2;
        v99 = v111;
        v103 -= 32;
      }
      while (v103);
      if (v97 == v98)
        goto LABEL_83;
      if ((v97 & 0x18) == 0)
      {
        v95 += v98;
        v96 = 2 * v98;
        do
        {
LABEL_82:
          v130 = *v95++;
          v131 = &v292[v96];
          *v131 = (v130 >> 1) & 7 | (8 * ((v130 >> 1) & 7));
          v131[1] = (v130 >> 5) | (8 * (v130 >> 5));
          v96 += 2;
        }
        while (v96 < v92);
        goto LABEL_83;
      }
    }
    else
    {
      v98 = 0;
    }
    v96 = 2 * (v97 & 0xFFFFFFFFFFFFFFF8);
    v95 += v97 & 0xFFFFFFFFFFFFFFF8;
    v113 = (uint8x8_t *)(v93 + v98 + v94);
    v114 = v98 - (v97 & 0xFFFFFFFFFFFFFFF8);
    v115 = &v292[2 * v98];
    do
    {
      v116 = *v113++;
      v296.val[0] = (int16x8_t)vmovl_u8((uint8x8_t)vmul_s8(vand_s8((int8x8_t)vshr_n_u8(v116, 1uLL), (int8x8_t)0x707070707070707), (int8x8_t)0x909090909090909));
      v296.val[1] = (int16x8_t)vmovl_u8((uint8x8_t)vmul_s8((int8x8_t)vshr_n_u8(v116, 5uLL), (int8x8_t)0x909090909090909));
      vst2q_s16(v115, v296);
      v115 += 16;
      v114 += 8;
    }
    while (v114);
    if (v97 != (v97 & 0xFFFFFFFFFFFFFFF8))
      goto LABEL_82;
LABEL_83:
    v132 = 0;
    do
    {
      v134 = (unsigned __int8 *)(*((_QWORD *)v76 + 6) + (__int16)v292[v132]);
      v136 = *((_DWORD *)a2 + 8);
      v135 = *((_DWORD *)a2 + 9);
      v137 = v136 >> 8;
      LODWORD(v133) = -1;
      do
      {
        v138 = v136;
        v139 = *v134++;
        v136 = v137 * v139;
        LODWORD(v133) = v133 + 1;
        v140 = v135 - v137 * v139;
      }
      while (v135 < v137 * v139);
      v141 = v138 - v136;
      *((_DWORD *)a2 + 8) = v138 - v136;
      *((_DWORD *)a2 + 9) = v140;
      if (v138 - v136 >= 0x800001)
      {
        v148 = v138 - v136;
      }
      else
      {
        v142 = *((unsigned int *)a2 + 2);
        v143 = *((_DWORD *)a2 + 11);
        v144 = *((unsigned int *)a2 + 7);
        v145 = *((_DWORD *)a2 + 6) + 8;
        do
        {
          *((_DWORD *)a2 + 6) = v145;
          v148 = v141 << 8;
          *((_DWORD *)a2 + 8) = v141 << 8;
          if (v144 < v142)
          {
            v146 = *a2;
            *((_DWORD *)a2 + 7) = v144 + 1;
            v147 = *(unsigned __int8 *)(v146 + v144++);
          }
          else
          {
            v147 = 0;
          }
          v140 = (((v140 & 0x7FFFFF) << 8) | ((v147 | (v143 << 8)) >> 1)) ^ 0xFF;
          *((_DWORD *)a2 + 11) = v147;
          *((_DWORD *)a2 + 9) = v140;
          v145 += 8;
          v143 = v147;
          v18 = v141 > 0x8000;
          v141 <<= 8;
        }
        while (!v18);
      }
      if ((_DWORD)v133)
      {
        if ((_DWORD)v133 == 8)
        {
          v133 = 0;
          v149 = v148 >> 8;
          do
          {
            v150 = v148;
            v148 = v149 * silk_NLSF_EXT_iCDF[v133++];
            v151 = v140 - v148;
          }
          while (v140 < v148);
          v152 = v150 - v148;
          *((_DWORD *)a2 + 8) = v150 - v148;
          *((_DWORD *)a2 + 9) = v151;
          if (v150 - v148 < 0x800001)
          {
            v153 = *((unsigned int *)a2 + 2);
            v154 = *((_DWORD *)a2 + 11);
            v155 = *((unsigned int *)a2 + 7);
            v156 = *((_DWORD *)a2 + 6) + 8;
            do
            {
              *((_DWORD *)a2 + 6) = v156;
              *((_DWORD *)a2 + 8) = v152 << 8;
              if (v155 < v153)
              {
                v157 = *a2;
                *((_DWORD *)a2 + 7) = v155 + 1;
                v158 = *(unsigned __int8 *)(v157 + v155++);
              }
              else
              {
                v158 = 0;
              }
              v151 = (((v151 & 0x7FFFFF) << 8) | ((v158 | (v154 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)a2 + 11) = v158;
              *((_DWORD *)a2 + 9) = v151;
              v156 += 8;
              v154 = v158;
              v18 = v152 > 0x8000;
              v152 <<= 8;
            }
            while (!v18);
          }
          LOBYTE(v133) = v133 + 7;
        }
      }
      else
      {
        v133 = 0;
        v159 = v148 >> 8;
        do
        {
          v160 = v148;
          v148 = v159 * silk_NLSF_EXT_iCDF[v133++];
          v161 = v140 - v148;
        }
        while (v140 < v148);
        v162 = v160 - v148;
        *((_DWORD *)a2 + 8) = v160 - v148;
        *((_DWORD *)a2 + 9) = v161;
        if (v160 - v148 < 0x800001)
        {
          v163 = *((unsigned int *)a2 + 2);
          v164 = *((_DWORD *)a2 + 11);
          v165 = *((unsigned int *)a2 + 7);
          v166 = *((_DWORD *)a2 + 6) + 8;
          do
          {
            *((_DWORD *)a2 + 6) = v166;
            *((_DWORD *)a2 + 8) = v162 << 8;
            if (v165 < v163)
            {
              v167 = *a2;
              *((_DWORD *)a2 + 7) = v165 + 1;
              v168 = *(unsigned __int8 *)(v167 + v165++);
            }
            else
            {
              v168 = 0;
            }
            v161 = (((v161 & 0x7FFFFF) << 8) | ((v168 | (v164 << 8)) >> 1)) ^ 0xFF;
            *((_DWORD *)a2 + 11) = v168;
            *((_DWORD *)a2 + 9) = v161;
            v166 += 8;
            v164 = v168;
            v18 = v162 > 0x8000;
            v162 <<= 8;
          }
          while (!v18);
        }
        LOBYTE(v133) = 1 - v133;
      }
      ++v132;
      *(_BYTE *)(result + v132 + 2768) = v133 - 4;
    }
    while (v132 < v76[1]);
  }
  if ((_DWORD)v60 == 4)
  {
    v169 = 0;
    v171 = *((_DWORD *)a2 + 8);
    v170 = *((_DWORD *)a2 + 9);
    v172 = v171 >> 8;
    do
    {
      v173 = v171;
      v171 = v172 * silk_NLSF_interpolation_factor_iCDF[v169++];
      v174 = v170 - v171;
    }
    while (v170 < v171);
    v175 = v173 - v171;
    *((_DWORD *)a2 + 8) = v173 - v171;
    *((_DWORD *)a2 + 9) = v174;
    v176 = v169 - 1;
    if (v173 - v171 < 0x800001)
    {
      v177 = *((unsigned int *)a2 + 2);
      v178 = *((_DWORD *)a2 + 11);
      v179 = *((unsigned int *)a2 + 7);
      v180 = *((_DWORD *)a2 + 6) + 8;
      do
      {
        *((_DWORD *)a2 + 6) = v180;
        *((_DWORD *)a2 + 8) = v175 << 8;
        if (v179 < v177)
        {
          v181 = *a2;
          *((_DWORD *)a2 + 7) = v179 + 1;
          v182 = *(unsigned __int8 *)(v181 + v179++);
        }
        else
        {
          v182 = 0;
        }
        v174 = (((v174 & 0x7FFFFF) << 8) | ((v182 | (v178 << 8)) >> 1)) ^ 0xFF;
        *((_DWORD *)a2 + 11) = v182;
        *((_DWORD *)a2 + 9) = v174;
        v180 += 8;
        v178 = v182;
        v18 = v175 > 0x8000;
        v175 <<= 8;
      }
      while (!v18);
    }
  }
  else
  {
    v176 = 4;
  }
  *(_BYTE *)(result + 2791) = v176;
  v183 = *(unsigned __int8 *)(result + 2789);
  if (v183 == 2)
  {
    if (a5 == 2)
    {
      v184 = *((_DWORD *)a2 + 8);
      v185 = *((_DWORD *)a2 + 9);
      if (*(_DWORD *)(result + 2408) == 2)
      {
        v186 = 0;
        v187 = v184 >> 8;
        v188 = -65536;
        do
        {
          v189 = v184;
          v184 = v187 * silk_pitch_delta_iCDF[v186++];
          v188 += 0x10000;
          v190 = v185 - v184;
        }
        while (v185 < v184);
        v191 = v189 - v184;
        *((_DWORD *)a2 + 8) = v189 - v184;
        *((_DWORD *)a2 + 9) = v190;
        if (v189 - v184 >= 0x800001)
        {
          v184 = v189 - v184;
        }
        else
        {
          v192 = *((unsigned int *)a2 + 2);
          v193 = *((_DWORD *)a2 + 11);
          v194 = *((unsigned int *)a2 + 7);
          v195 = *((_DWORD *)a2 + 6) + 8;
          do
          {
            *((_DWORD *)a2 + 6) = v195;
            v184 = v191 << 8;
            *((_DWORD *)a2 + 8) = v191 << 8;
            if (v194 < v192)
            {
              v196 = *a2;
              *((_DWORD *)a2 + 7) = v194 + 1;
              v197 = *(unsigned __int8 *)(v196 + v194++);
            }
            else
            {
              v197 = 0;
            }
            v190 = (((v190 & 0x7FFFFF) << 8) | ((v197 | (v193 << 8)) >> 1)) ^ 0xFF;
            *((_DWORD *)a2 + 11) = v197;
            *((_DWORD *)a2 + 9) = v190;
            v195 += 8;
            v193 = v197;
            v18 = v191 > 0x8000;
            v191 <<= 8;
          }
          while (!v18);
        }
        if (v188 >= 1)
        {
          v198 = v186 - 1 + *(_WORD *)(result + 2412) - 9;
LABEL_159:
          *(_WORD *)(result + 2786) = v198;
          v225 = 0;
          *(_WORD *)(result + 2412) = v198;
          v226 = v184 >> 8;
          do
          {
            v227 = v184;
            v184 = v226 * *(unsigned __int8 *)(*(_QWORD *)(result + 2392) + v225++);
            v228 = v190 - v184;
          }
          while (v190 < v184);
          *((_DWORD *)a2 + 9) = v228;
          v229 = v227 - v184;
          v230 = v225 - 1;
          if (v229 >= 0x800001)
          {
            v237 = v229;
          }
          else
          {
            v231 = *((unsigned int *)a2 + 2);
            v232 = *((_DWORD *)a2 + 11);
            v233 = *((unsigned int *)a2 + 7);
            v234 = *((_DWORD *)a2 + 6) + 8;
            do
            {
              *((_DWORD *)a2 + 6) = v234;
              v237 = v229 << 8;
              *((_DWORD *)a2 + 8) = v229 << 8;
              if (v233 < v231)
              {
                v235 = *a2;
                *((_DWORD *)a2 + 7) = v233 + 1;
                v236 = *(unsigned __int8 *)(v235 + v233++);
              }
              else
              {
                v236 = 0;
              }
              v228 = (((v228 & 0x7FFFFF) << 8) | ((v236 | (v232 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)a2 + 11) = v236;
              *((_DWORD *)a2 + 9) = v228;
              v234 += 8;
              v232 = v236;
              v18 = v229 > 0x8000;
              v229 <<= 8;
            }
            while (!v18);
          }
          v238 = 0;
          *(_BYTE *)(result + 2788) = v230;
          v239 = v237 >> 8;
          do
          {
            v240 = v237;
            v237 = v239 * silk_LTP_per_index_iCDF[v238++];
            v241 = v228 - v237;
          }
          while (v228 < v237);
          v242 = v240 - v237;
          *((_DWORD *)a2 + 8) = v240 - v237;
          *((_DWORD *)a2 + 9) = v241;
          v243 = v238 - 1;
          if (v240 - v237 < 0x800001)
          {
            v244 = *((unsigned int *)a2 + 2);
            v245 = *((_DWORD *)a2 + 11);
            v246 = *((unsigned int *)a2 + 7);
            v247 = *((_DWORD *)a2 + 6) + 8;
            do
            {
              *((_DWORD *)a2 + 6) = v247;
              *((_DWORD *)a2 + 8) = v242 << 8;
              if (v246 < v244)
              {
                v248 = *a2;
                *((_DWORD *)a2 + 7) = v246 + 1;
                v249 = *(unsigned __int8 *)(v248 + v246++);
              }
              else
              {
                v249 = 0;
              }
              v241 = (((v241 & 0x7FFFFF) << 8) | ((v249 | (v245 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)a2 + 11) = v249;
              *((_DWORD *)a2 + 9) = v241;
              v247 += 8;
              v245 = v249;
              v18 = v242 > 0x8000;
              v242 <<= 8;
            }
            while (!v18);
          }
          *(_BYTE *)(result + 2792) = v243;
          if ((int)v60 >= 1)
          {
            for (j = 0; j != v60; ++j)
            {
              v251 = 0;
              v253 = *((_DWORD *)a2 + 8);
              v252 = *((_DWORD *)a2 + 9);
              v254 = v253 >> 8;
              do
              {
                v255 = v253;
                v253 = v254 * *((unsigned __int8 *)*(&silk_LTP_gain_iCDF_ptrs + *(char *)(result + 2792)) + v251++);
                v256 = v252 - v253;
              }
              while (v252 < v253);
              v257 = v255 - v253;
              *((_DWORD *)a2 + 8) = v255 - v253;
              *((_DWORD *)a2 + 9) = v256;
              if (v255 - v253 < 0x800001)
              {
                v258 = *((unsigned int *)a2 + 2);
                v259 = *((_DWORD *)a2 + 11);
                v260 = *((unsigned int *)a2 + 7);
                v261 = *((_DWORD *)a2 + 6) + 8;
                do
                {
                  *((_DWORD *)a2 + 6) = v261;
                  *((_DWORD *)a2 + 8) = v257 << 8;
                  if (v260 < v258)
                  {
                    v262 = *a2;
                    *((_DWORD *)a2 + 7) = v260 + 1;
                    v263 = *(unsigned __int8 *)(v262 + v260++);
                  }
                  else
                  {
                    v263 = 0;
                  }
                  v256 = (((v256 & 0x7FFFFF) << 8) | ((v263 | (v259 << 8)) >> 1)) ^ 0xFF;
                  *((_DWORD *)a2 + 11) = v263;
                  *((_DWORD *)a2 + 9) = v256;
                  v261 += 8;
                  v259 = v263;
                  v18 = v257 > 0x8000;
                  v257 <<= 8;
                }
                while (!v18);
              }
              *(_BYTE *)(result + j + 2764) = v251 - 1;
            }
          }
          if (a5)
          {
            v264 = 0;
          }
          else
          {
            v265 = 0;
            v267 = *((_DWORD *)a2 + 8);
            v266 = *((_DWORD *)a2 + 9);
            v268 = v267 >> 8;
            do
            {
              v269 = v267;
              v267 = v268 * silk_LTPscale_iCDF[v265++];
              v270 = v266 - v267;
            }
            while (v266 < v267);
            v271 = v269 - v267;
            *((_DWORD *)a2 + 8) = v269 - v267;
            *((_DWORD *)a2 + 9) = v270;
            v264 = v265 - 1;
            if (v269 - v267 < 0x800001)
            {
              v272 = *((unsigned int *)a2 + 2);
              v273 = *((_DWORD *)a2 + 11);
              v274 = *((unsigned int *)a2 + 7);
              v275 = *((_DWORD *)a2 + 6) + 8;
              do
              {
                *((_DWORD *)a2 + 6) = v275;
                *((_DWORD *)a2 + 8) = v271 << 8;
                if (v274 < v272)
                {
                  v276 = *a2;
                  *((_DWORD *)a2 + 7) = v274 + 1;
                  v277 = *(unsigned __int8 *)(v276 + v274++);
                }
                else
                {
                  v277 = 0;
                }
                v270 = (((v270 & 0x7FFFFF) << 8) | ((v277 | (v273 << 8)) >> 1)) ^ 0xFF;
                *((_DWORD *)a2 + 11) = v277;
                *((_DWORD *)a2 + 9) = v270;
                v275 += 8;
                v273 = v277;
                v18 = v271 > 0x8000;
                v271 <<= 8;
              }
              while (!v18);
            }
          }
          *(_BYTE *)(result + 2793) = v264;
          LOBYTE(v183) = *(_BYTE *)(result + 2789);
          goto LABEL_198;
        }
      }
      else
      {
        v190 = *((_DWORD *)a2 + 9);
      }
    }
    else
    {
      v184 = *((_DWORD *)a2 + 8);
      v190 = *((_DWORD *)a2 + 9);
    }
    v199 = v184 >> 8;
    v200 = -1;
    v201 = &silk_pitch_lag_iCDF;
    do
    {
      v202 = v184;
      v203 = *v201++;
      v184 = v199 * v203;
      ++v200;
      v204 = v190 - v199 * v203;
    }
    while (v190 < v199 * v203);
    v205 = v202 - v184;
    *((_DWORD *)a2 + 8) = v202 - v184;
    *((_DWORD *)a2 + 9) = v204;
    if (v202 - v184 >= 0x800001)
    {
      v212 = v202 - v184;
    }
    else
    {
      v206 = *((unsigned int *)a2 + 2);
      v207 = *((_DWORD *)a2 + 11);
      v208 = *((unsigned int *)a2 + 7);
      v209 = *((_DWORD *)a2 + 6) + 8;
      do
      {
        *((_DWORD *)a2 + 6) = v209;
        v212 = v205 << 8;
        *((_DWORD *)a2 + 8) = v205 << 8;
        if (v208 < v206)
        {
          v210 = *a2;
          *((_DWORD *)a2 + 7) = v208 + 1;
          v211 = *(unsigned __int8 *)(v210 + v208++);
        }
        else
        {
          v211 = 0;
        }
        v204 = (((v204 & 0x7FFFFF) << 8) | ((v211 | (v207 << 8)) >> 1)) ^ 0xFF;
        *((_DWORD *)a2 + 11) = v211;
        *((_DWORD *)a2 + 9) = v204;
        v209 += 8;
        v207 = v211;
        v18 = v205 > 0x8000;
        v205 <<= 8;
      }
      while (!v18);
    }
    v213 = 0;
    v214 = (*(_DWORD *)(result + 2316) >> 1) * v200;
    *(_WORD *)(result + 2786) = v214;
    v215 = v212 >> 8;
    do
    {
      v216 = v212;
      v212 = v215 * *(unsigned __int8 *)(*(_QWORD *)(result + 2384) + v213++);
      v190 = v204 - v212;
    }
    while (v204 < v212);
    v217 = v216 - v212;
    *((_DWORD *)a2 + 8) = v216 - v212;
    *((_DWORD *)a2 + 9) = v190;
    v218 = v213 - 1;
    if (v216 - v212 >= 0x800001)
    {
      v184 = v216 - v212;
    }
    else
    {
      v219 = *((unsigned int *)a2 + 2);
      v220 = *((_DWORD *)a2 + 11);
      v221 = *((unsigned int *)a2 + 7);
      v222 = *((_DWORD *)a2 + 6) + 8;
      do
      {
        *((_DWORD *)a2 + 6) = v222;
        v184 = v217 << 8;
        *((_DWORD *)a2 + 8) = v217 << 8;
        if (v221 < v219)
        {
          v223 = *a2;
          *((_DWORD *)a2 + 7) = v221 + 1;
          v224 = *(unsigned __int8 *)(v223 + v221++);
        }
        else
        {
          v224 = 0;
        }
        v190 = (((v190 & 0x7FFFFF) << 8) | ((v224 | (v220 << 8)) >> 1)) ^ 0xFF;
        *((_DWORD *)a2 + 11) = v224;
        *((_DWORD *)a2 + 9) = v190;
        v222 += 8;
        v220 = v224;
        v18 = v217 > 0x8000;
        v217 <<= 8;
      }
      while (!v18);
    }
    v198 = v218 + v214;
    goto LABEL_159;
  }
LABEL_198:
  v278 = 0;
  *(_DWORD *)(result + 2408) = (char)v183;
  v280 = *((_DWORD *)a2 + 8);
  v279 = *((_DWORD *)a2 + 9);
  v281 = v280 >> 8;
  do
  {
    v282 = v280;
    v280 = v281 * silk_uniform4_iCDF[v278++];
    v283 = v279 - v280;
  }
  while (v279 < v280);
  v284 = v282 - v280;
  *((_DWORD *)a2 + 8) = v282 - v280;
  *((_DWORD *)a2 + 9) = v283;
  v285 = v278 - 1;
  if (v282 - v280 < 0x800001)
  {
    v286 = *((unsigned int *)a2 + 2);
    v287 = *((_DWORD *)a2 + 11);
    v288 = *((unsigned int *)a2 + 7);
    v289 = *((_DWORD *)a2 + 6) + 8;
    do
    {
      *((_DWORD *)a2 + 6) = v289;
      *((_DWORD *)a2 + 8) = v284 << 8;
      if (v288 < v286)
      {
        v290 = *a2;
        *((_DWORD *)a2 + 7) = v288 + 1;
        v291 = *(unsigned __int8 *)(v290 + v288++);
      }
      else
      {
        v291 = 0;
      }
      v283 = (((v283 & 0x7FFFFF) << 8) | ((v291 | (v287 << 8)) >> 1)) ^ 0xFF;
      *((_DWORD *)a2 + 11) = v291;
      *((_DWORD *)a2 + 9) = v283;
      v289 += 8;
      v287 = v291;
      v18 = v284 > 0x8000;
      v284 <<= 8;
    }
    while (!v18);
  }
  *(_BYTE *)(result + 2794) = v285;
  return result;
}

void silk_decode_parameters(uint64_t a1, int16x8_t *a2, int a3)
{
  _BOOL4 v5;
  uint64_t v6;
  uint64_t i;
  int v8;
  char v9;
  int v10;
  unsigned int v11;
  int16x8_t *v12;
  signed int v13;
  uint64_t v14;
  uint64_t v15;
  int32x4_t v16;
  int16x8_t *v17;
  int16x4_t *v18;
  int16x8_t *v19;
  uint64_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  uint64_t v24;
  uint64_t v25;
  __int16 *v26;
  __int16 *v27;
  __int16 *v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int16x8_t *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int16x8_t *v39;
  int v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  int16x8_t *v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  __int16 *v62;
  uint64_t v63;
  char *v64;
  __int32 v65;
  __int16 v66[8];
  uint64_t v67;
  __int16 __src[8];
  _QWORD v69[3];

  v69[2] = *MEMORY[0x24BDAC8D0];
  v5 = a3 == 2;
  v6 = *(unsigned int *)(a1 + 2324);
  if ((int)v6 >= 1)
  {
    for (i = 0; i != v6; ++i)
    {
      if (i | v5)
      {
        v8 = *(char *)(a1 + 2760 + i) - 4;
        v9 = *(_BYTE *)(a1 + 2312);
        if (v8 > v9 + 8)
          LOBYTE(v8) = 2 * v8 - 8;
        else
          LOBYTE(v8) = v9 + v8;
      }
      else
      {
        v8 = *(char *)(a1 + 2760);
        if (v8 <= *(char *)(a1 + 2312) - 16)
          LOBYTE(v8) = *(_BYTE *)(a1 + 2312) - 16;
      }
      v10 = (char)v8 & ~((char)v8 >> 31);
      if (v10 >= 63)
        v10 = 63;
      *(_BYTE *)(a1 + 2312) = v10;
      v11 = ((1907825 * v10) >> 16) + 2090;
      a2[1].i32[i] = (1 << (v11 >> 7))
                   + ((v11 & 0x7F) + ((int)(-174 * (v11 & 0x7F) * (128 - (v11 & 0x7F))) >> 16))
                   * ((1 << (v11 >> 7)) >> 7);
    }
  }
  silk_NLSF_decode(__src, (char *)(a1 + 2768), *(_QWORD *)(a1 + 2752));
  v12 = a2 + 2;
  silk_NLSF2A(a2 + 4, __src, *(_DWORD *)(a1 + 2340));
  if (*(_DWORD *)(a1 + 2376) == 1)
  {
    *(_BYTE *)(a1 + 2791) = 4;
LABEL_18:
    memcpy(&a2[2], &a2[4], 2 * *(int *)(a1 + 2340));
    goto LABEL_25;
  }
  v13 = *(char *)(a1 + 2791);
  if (v13 > 3)
    goto LABEL_18;
  v14 = *(unsigned int *)(a1 + 2340);
  if ((int)v14 >= 1)
  {
    if (v14 >= 0x10)
    {
      v15 = v14 & 0x7FFFFFF0;
      v16 = vdupq_n_s32(v13);
      v17 = (int16x8_t *)(a1 + 2344);
      v18 = (int16x4_t *)v69;
      v19 = (int16x8_t *)&v67;
      v20 = v14 & 0xFFFFFFF0;
      do
      {
        v21 = *v17;
        v22 = v17[1];
        v17 += 2;
        v23 = vaddq_s16(v22, vshrn_high_n_s32(vshrn_n_s32(vmulq_s32(vsubl_s16(*v18, *(int16x4_t *)v22.i8), v16), 2uLL), vmulq_s32(vsubl_high_s16(*(int16x8_t *)v18->i8, v22), v16), 2uLL));
        v19[-1] = vaddq_s16(v21, vshrn_high_n_s32(vshrn_n_s32(vmulq_s32(vsubl_s16(v18[-2], *(int16x4_t *)v21.i8), v16), 2uLL), vmulq_s32(vsubl_high_s16(*(int16x8_t *)v18[-2].i8, v21), v16), 2uLL));
        *v19 = v23;
        v18 += 4;
        v19 += 2;
        v20 -= 16;
      }
      while (v20);
      if (v15 == v14)
        goto LABEL_24;
    }
    else
    {
      v15 = 0;
    }
    v24 = v14 - v15;
    v25 = v15;
    v26 = &v66[v15];
    v27 = &__src[v25];
    v28 = (__int16 *)(v25 * 2 + a1 + 2344);
    do
    {
      v30 = *v28++;
      v29 = v30;
      v31 = *v27++;
      *v26++ = v29 + (((v31 - v29) * v13) >> 2);
      --v24;
    }
    while (v24);
  }
LABEL_24:
  silk_NLSF2A(a2 + 2, v66, v14);
LABEL_25:
  v32 = *(int *)(a1 + 2340);
  memcpy((void *)(a1 + 2344), __src, 2 * v32);
  if (*(_DWORD *)(a1 + 4184))
  {
    v33 = (v32 - 1);
    if ((int)v32 <= 1)
    {
      v37 = (int)v33;
      v38 = 63570;
      v12->i16[(int)v33] = (((63570 * v12->i16[(int)v33]) >> 15) + 1) >> 1;
    }
    else
    {
      v34 = 63570;
      v35 = a2 + 2;
      v36 = (v32 - 1);
      do
      {
        v35->i16[0] = (((v34 * v35->i16[0]) >> 15) + 1) >> 1;
        v35 = (int16x8_t *)((char *)v35 + 2);
        v34 += (((-1966 * v34) >> 15) + 1) >> 1;
        --v36;
      }
      while (v36);
      v37 = (int)v33;
      v12->i16[(int)v33] = (((v34 * v12->i16[(int)v33]) >> 15) + 1) >> 1;
      v38 = 63570;
      v39 = a2 + 4;
      do
      {
        v39->i16[0] = (((v38 * v39->i16[0]) >> 15) + 1) >> 1;
        v39 = (int16x8_t *)((char *)v39 + 2);
        v38 += (((-1966 * v38) >> 15) + 1) >> 1;
        --v33;
      }
      while (v33);
    }
    a2[4].i16[v37] = (((v38 * a2[4].i16[v37]) >> 15) + 1) >> 1;
  }
  if (*(_BYTE *)(a1 + 2789) == 2)
  {
    v40 = *(_DWORD *)(a1 + 2316);
    v41 = *(unsigned int *)(a1 + 2324);
    v42 = (char *)&silk_CB_lags_stage2_10_ms;
    if ((_DWORD)v41 == 4)
      v42 = (char *)&silk_CB_lags_stage2;
    v43 = (char *)&silk_CB_lags_stage3_10_ms;
    if ((_DWORD)v41 == 4)
      v43 = &silk_CB_lags_stage3;
    if (v40 == 8)
      v44 = v42;
    else
      v44 = v43;
    if ((int)v41 >= 1)
    {
      v45 = 2 * (__int16)v40;
      v46 = 18 * (__int16)v40;
      v47 = v45 + *(__int16 *)(a1 + 2786);
      v48 = 3;
      if ((_DWORD)v41 == 4)
        v48 = 11;
      v49 = 12;
      if ((_DWORD)v41 == 4)
        v49 = 34;
      if (v40 == 8)
        v50 = v48;
      else
        v50 = v49;
      v51 = &v44[*(char *)(a1 + 2788)];
      v52 = a2;
      if (v45 <= v46)
      {
        do
        {
          v56 = v47 + *v51;
          if (v56 <= v45)
            v57 = v45;
          else
            v57 = v47 + *v51;
          if (v56 <= v46)
            v58 = v57;
          else
            v58 = v46;
          v52->i32[0] = v58;
          v52 = (int16x8_t *)((char *)v52 + 4);
          v51 += v50;
          --v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          v53 = v47 + *v51;
          if (v53 <= v46)
            v54 = v46;
          else
            v54 = v47 + *v51;
          if (v53 <= v45)
            v55 = v54;
          else
            v55 = v45;
          v52->i32[0] = v55;
          v52 = (int16x8_t *)((char *)v52 + 4);
          v51 += v50;
          --v41;
        }
        while (v41);
      }
    }
    v59 = *(unsigned int *)(a1 + 2324);
    if ((int)v59 >= 1)
    {
      v60 = (uint64_t)*(&silk_LTP_vq_ptrs_Q7 + *(char *)(a1 + 2792));
      v61 = (char *)(a1 + 2764);
      v62 = &a2[6].i16[4];
      do
      {
        v63 = *v61++;
        v64 = (char *)(v60 + 5 * v63);
        *(v62 - 4) = *v64 << 7;
        *(v62 - 3) = v64[1] << 7;
        *(v62 - 2) = v64[2] << 7;
        *(v62 - 1) = v64[3] << 7;
        *v62 = v64[4] << 7;
        v62 += 5;
        --v59;
      }
      while (v59);
    }
    v65 = (__int16)silk_LTPScales_table_Q14[*(char *)(a1 + 2793)];
  }
  else
  {
    bzero(a2, 4 * *(int *)(a1 + 2324));
    bzero(&a2[6], 10 * *(int *)(a1 + 2324));
    v65 = 0;
    *(_BYTE *)(a1 + 2792) = 0;
  }
  a2[8].i32[2] = v65;
}

uint64_t *silk_decode_pulses(uint64_t a1, __int16 *a2, int a3, int a4, int a5)
{
  unsigned __int8 *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  unint64_t v19;
  int v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  BOOL v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  unsigned int v31;
  int v32;
  unsigned __int8 *v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  unsigned int v37;
  unint64_t v38;
  int v39;
  unint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  char *v45;
  unsigned __int8 *v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  unint64_t v52;
  int v53;
  unint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  int v58;
  int *v59;
  uint64_t v60;
  int v61;
  int v62;
  __int16 *v63;
  uint64_t i;
  int v65;
  int v66;
  __int16 *v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  char *v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  unint64_t v76;
  int v77;
  unint64_t v78;
  int v79;
  uint64_t v80;
  int v81;
  int v82;
  int v83;
  unsigned int v84;
  char *v85;
  unsigned int v86;
  int v87;
  unsigned int v88;
  unint64_t v89;
  int v90;
  unint64_t v91;
  int v92;
  uint64_t v93;
  int v94;
  int v95;
  int v96;
  unsigned int v97;
  char *v98;
  unsigned int v99;
  int v100;
  unsigned int v101;
  unint64_t v102;
  int v103;
  unint64_t v104;
  int v105;
  uint64_t v106;
  int v107;
  int v108;
  int v109;
  unsigned int v110;
  char *v111;
  unsigned int v112;
  int v113;
  unsigned int v114;
  unint64_t v115;
  int v116;
  unint64_t v117;
  int v118;
  uint64_t v119;
  int v120;
  int v121;
  int v122;
  unsigned int v123;
  char *v124;
  unsigned int v125;
  int v126;
  unsigned int v127;
  unint64_t v128;
  int v129;
  unint64_t v130;
  int v131;
  uint64_t v132;
  int v133;
  int v134;
  int v135;
  unsigned int v136;
  char *v137;
  unsigned int v138;
  int v139;
  unsigned int v140;
  unint64_t v141;
  int v142;
  unint64_t v143;
  int v144;
  uint64_t v145;
  int v146;
  int v147;
  int v148;
  unsigned int v149;
  char *v150;
  unsigned int v151;
  int v152;
  unsigned int v153;
  unint64_t v154;
  int v155;
  unint64_t v156;
  int v157;
  uint64_t v158;
  int v159;
  int v160;
  int v161;
  unsigned int v162;
  char *v163;
  unsigned int v164;
  int v165;
  unsigned int v166;
  unint64_t v167;
  int v168;
  unint64_t v169;
  int v170;
  uint64_t v171;
  int v172;
  int v173;
  int v174;
  unsigned int v175;
  char *v176;
  unsigned int v177;
  int v178;
  unsigned int v179;
  unint64_t v180;
  int v181;
  unint64_t v182;
  int v183;
  uint64_t v184;
  int v185;
  int v186;
  int v187;
  unsigned int v188;
  char *v189;
  unsigned int v190;
  int v191;
  unsigned int v192;
  unint64_t v193;
  int v194;
  unint64_t v195;
  int v196;
  uint64_t v197;
  int v198;
  int v199;
  int v200;
  unsigned int v201;
  char *v202;
  unsigned int v203;
  int v204;
  unsigned int v205;
  unint64_t v206;
  int v207;
  unint64_t v208;
  int v209;
  uint64_t v210;
  int v211;
  int v212;
  int v213;
  unsigned int v214;
  char *v215;
  unsigned int v216;
  int v217;
  unsigned int v218;
  unint64_t v219;
  int v220;
  unint64_t v221;
  int v222;
  uint64_t v223;
  int v224;
  int v225;
  int v226;
  unsigned int v227;
  char *v228;
  unsigned int v229;
  int v230;
  unsigned int v231;
  unint64_t v232;
  int v233;
  unint64_t v234;
  int v235;
  uint64_t v236;
  int v237;
  int v238;
  int v239;
  unsigned int v240;
  char *v241;
  unsigned int v242;
  int v243;
  unsigned int v244;
  unint64_t v245;
  int v246;
  unint64_t v247;
  int v248;
  uint64_t v249;
  int v250;
  int v251;
  int v252;
  unsigned int v253;
  char *v254;
  unsigned int v255;
  int v256;
  unsigned int v257;
  unint64_t v258;
  int v259;
  unint64_t v260;
  int v261;
  uint64_t v262;
  int v263;
  int v264;
  int v265;
  unsigned int v266;
  char *v267;
  unsigned int v268;
  int v269;
  int v270;
  unsigned int v271;
  unint64_t v272;
  int v273;
  unint64_t v274;
  int v275;
  uint64_t v276;
  int v277;
  _DWORD v279[20];
  _DWORD v280[20];
  uint64_t v281;

  v281 = *MEMORY[0x24BDAC8D0];
  v10 = (unsigned __int8 *)&silk_rate_levels_iCDF + 8 * (a3 >> 1) + ((uint64_t)a3 >> 1);
  v12 = *(_DWORD *)(a1 + 32);
  v11 = *(_DWORD *)(a1 + 36);
  v13 = v12 >> 8;
  v14 = -1;
  do
  {
    v15 = v12;
    v16 = *v10++;
    v12 = v13 * v16;
    ++v14;
    v17 = v11 - v13 * v16;
  }
  while (v11 < v13 * v16);
  v18 = v15 - v12;
  *(_DWORD *)(a1 + 32) = v15 - v12;
  *(_DWORD *)(a1 + 36) = v17;
  if (v15 - v12 > 0x800000)
  {
    v26 = v15 - v12;
  }
  else
  {
    v19 = *(unsigned int *)(a1 + 8);
    v20 = *(_DWORD *)(a1 + 44);
    v21 = *(unsigned int *)(a1 + 28);
    v22 = *(_DWORD *)(a1 + 24) + 8;
    do
    {
      *(_DWORD *)(a1 + 24) = v22;
      v26 = v18 << 8;
      *(_DWORD *)(a1 + 32) = v18 << 8;
      if (v21 < v19)
      {
        v23 = *(_QWORD *)a1;
        *(_DWORD *)(a1 + 28) = v21 + 1;
        v24 = *(unsigned __int8 *)(v23 + v21++);
      }
      else
      {
        v24 = 0;
      }
      v17 = (((v17 & 0x7FFFFF) << 8) | ((v24 | (v20 << 8)) >> 1)) ^ 0xFF;
      *(_DWORD *)(a1 + 44) = v24;
      *(_DWORD *)(a1 + 36) = v17;
      v22 += 8;
      v20 = v24;
      v25 = v18 > 0x8000;
      v18 <<= 8;
    }
    while (!v25);
  }
  v27 = a5 >> 4;
  if ((int)(a5 & 0xFFFFFFF0) >= a5)
    v28 = v27;
  else
    v28 = v27 + 1;
  if ((int)v28 >= 1)
  {
    v29 = 0;
    v30 = (char *)&silk_pulses_per_block_iCDF + 18 * v14;
    do
    {
      v279[v29] = 0;
      v31 = v26 >> 8;
      v32 = -1;
      v33 = (unsigned __int8 *)v30;
      do
      {
        v34 = v26;
        v35 = *v33++;
        v26 = v31 * v35;
        ++v32;
        v36 = v17 - v31 * v35;
      }
      while (v17 < v31 * v35);
      v37 = v34 - v26;
      *(_DWORD *)(a1 + 32) = v34 - v26;
      *(_DWORD *)(a1 + 36) = v36;
      if (v34 - v26 >= 0x800001)
      {
        v26 = v34 - v26;
      }
      else
      {
        v38 = *(unsigned int *)(a1 + 8);
        v39 = *(_DWORD *)(a1 + 44);
        v40 = *(unsigned int *)(a1 + 28);
        v41 = *(_DWORD *)(a1 + 24) + 8;
        do
        {
          *(_DWORD *)(a1 + 24) = v41;
          v26 = v37 << 8;
          *(_DWORD *)(a1 + 32) = v37 << 8;
          if (v40 < v38)
          {
            v42 = *(_QWORD *)a1;
            *(_DWORD *)(a1 + 28) = v40 + 1;
            v43 = *(unsigned __int8 *)(v42 + v40++);
          }
          else
          {
            v43 = 0;
          }
          v36 = (((v36 & 0x7FFFFF) << 8) | ((v43 | (v39 << 8)) >> 1)) ^ 0xFF;
          *(_DWORD *)(a1 + 44) = v43;
          *(_DWORD *)(a1 + 36) = v36;
          v41 += 8;
          v39 = v43;
          v25 = v37 > 0x8000;
          v37 <<= 8;
        }
        while (!v25);
      }
      if (v32 == 17)
      {
        v44 = 0;
        do
        {
          if (++v44 == 10)
            v45 = (char *)&unk_208F39D62;
          else
            v45 = (char *)&silk_pulses_per_block_iCDF;
          v46 = (unsigned __int8 *)(v45 + 162);
          v47 = v26 >> 8;
          v32 = -1;
          do
          {
            v48 = v26;
            v49 = *v46++;
            v26 = v47 * v49;
            ++v32;
            v50 = v36 - v47 * v49;
          }
          while (v36 < v47 * v49);
          v51 = v48 - v26;
          *(_DWORD *)(a1 + 32) = v48 - v26;
          *(_DWORD *)(a1 + 36) = v50;
          if (v48 - v26 >= 0x800001)
          {
            v36 -= v26;
            v26 = v48 - v26;
          }
          else
          {
            v52 = *(unsigned int *)(a1 + 8);
            v53 = *(_DWORD *)(a1 + 44);
            v54 = *(unsigned int *)(a1 + 28);
            v55 = *(_DWORD *)(a1 + 24) + 8;
            v36 = v50;
            do
            {
              *(_DWORD *)(a1 + 24) = v55;
              v26 = v51 << 8;
              *(_DWORD *)(a1 + 32) = v51 << 8;
              if (v54 < v52)
              {
                v56 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v54 + 1;
                v57 = *(unsigned __int8 *)(v56 + v54++);
              }
              else
              {
                v57 = 0;
              }
              v36 = (((v36 & 0x7FFFFF) << 8) | ((v57 | (v53 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v57;
              *(_DWORD *)(a1 + 36) = v36;
              v55 += 8;
              v53 = v57;
              v25 = v51 > 0x8000;
              v51 <<= 8;
            }
            while (!v25);
          }
        }
        while (v32 == 17);
        v279[v29] = v44;
      }
      v280[v29++] = v32;
      v17 = v36;
    }
    while (v29 != v28);
    v58 = 0;
    v59 = v280;
    v60 = v28;
    do
    {
      while (1)
      {
        v62 = *v59++;
        v61 = v62;
        v63 = &a2[v58 >> 12];
        if (v62 >= 1)
          break;
        *(_OWORD *)v63 = 0u;
        *((_OWORD *)v63 + 1) = 0u;
        v58 += 0x10000;
        if (!--v60)
          goto LABEL_45;
      }
      silk_shell_decoder((uint64_t)v63, (uint64_t *)a1, v61);
      v58 += 0x10000;
      --v60;
    }
    while (v60);
LABEL_45:
    for (i = 0; i != v28; ++i)
    {
      v65 = v279[i];
      if (v65 >= 1)
      {
        v66 = 0;
        v67 = &a2[16 * (__int16)i];
        v68 = (unsigned __int16)*v67;
        v70 = *(_DWORD *)(a1 + 32);
        v69 = *(_DWORD *)(a1 + 36);
        do
        {
          v71 = v70 >> 8;
          v68 = 2 * v68 - 1;
          v72 = &silk_lsb_iCDF;
          do
          {
            v73 = v70;
            v74 = *v72++;
            v70 = v71 * v74;
            ++v68;
          }
          while (v69 < v71 * v74);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v75 = v73 - v70;
          if (v73 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v73 - v70;
          }
          else
          {
            v76 = *(unsigned int *)(a1 + 8);
            v77 = *(_DWORD *)(a1 + 44);
            v78 = *(unsigned int *)(a1 + 28);
            v79 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v79;
              v70 = v75 << 8;
              *(_DWORD *)(a1 + 32) = v75 << 8;
              if (v78 < v76)
              {
                v80 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v78 + 1;
                v81 = *(unsigned __int8 *)(v80 + v78++);
              }
              else
              {
                v81 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v81 | (v77 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v81;
              *(_DWORD *)(a1 + 36) = v69;
              v79 += 8;
              v77 = v81;
              v25 = v75 > 0x8000;
              v75 <<= 8;
            }
            while (!v25);
          }
          ++v66;
        }
        while (v66 != v65);
        v82 = 0;
        *v67 = v68;
        v83 = (unsigned __int16)v67[1];
        do
        {
          v84 = v70 >> 8;
          v83 = 2 * v83 - 1;
          v85 = &silk_lsb_iCDF;
          do
          {
            v86 = v70;
            v87 = *v85++;
            v70 = v84 * v87;
            ++v83;
          }
          while (v69 < v84 * v87);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v88 = v86 - v70;
          if (v86 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v86 - v70;
          }
          else
          {
            v89 = *(unsigned int *)(a1 + 8);
            v90 = *(_DWORD *)(a1 + 44);
            v91 = *(unsigned int *)(a1 + 28);
            v92 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v92;
              v70 = v88 << 8;
              *(_DWORD *)(a1 + 32) = v88 << 8;
              if (v91 < v89)
              {
                v93 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v91 + 1;
                v94 = *(unsigned __int8 *)(v93 + v91++);
              }
              else
              {
                v94 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v94 | (v90 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v94;
              *(_DWORD *)(a1 + 36) = v69;
              v92 += 8;
              v90 = v94;
              v25 = v88 > 0x8000;
              v88 <<= 8;
            }
            while (!v25);
          }
          ++v82;
        }
        while (v82 != v65);
        v95 = 0;
        v67[1] = v83;
        v96 = (unsigned __int16)v67[2];
        do
        {
          v97 = v70 >> 8;
          v96 = 2 * v96 - 1;
          v98 = &silk_lsb_iCDF;
          do
          {
            v99 = v70;
            v100 = *v98++;
            v70 = v97 * v100;
            ++v96;
          }
          while (v69 < v97 * v100);
          v101 = v99 - v70;
          *(_DWORD *)(a1 + 32) = v99 - v70;
          *(_DWORD *)(a1 + 36) = v69 - v70;
          if (v99 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v99 - v70;
          }
          else
          {
            v102 = *(unsigned int *)(a1 + 8);
            v103 = *(_DWORD *)(a1 + 44);
            v104 = *(unsigned int *)(a1 + 28);
            v105 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v105;
              v70 = v101 << 8;
              *(_DWORD *)(a1 + 32) = v101 << 8;
              if (v104 < v102)
              {
                v106 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v104 + 1;
                v107 = *(unsigned __int8 *)(v106 + v104++);
              }
              else
              {
                v107 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v107 | (v103 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v107;
              *(_DWORD *)(a1 + 36) = v69;
              v105 += 8;
              v103 = v107;
              v25 = v101 > 0x8000;
              v101 <<= 8;
            }
            while (!v25);
          }
          ++v95;
        }
        while (v95 != v65);
        v108 = 0;
        v67[2] = v96;
        v109 = (unsigned __int16)v67[3];
        do
        {
          v110 = v70 >> 8;
          v109 = 2 * v109 - 1;
          v111 = &silk_lsb_iCDF;
          do
          {
            v112 = v70;
            v113 = *v111++;
            v70 = v110 * v113;
            ++v109;
          }
          while (v69 < v110 * v113);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v114 = v112 - v70;
          if (v112 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v112 - v70;
          }
          else
          {
            v115 = *(unsigned int *)(a1 + 8);
            v116 = *(_DWORD *)(a1 + 44);
            v117 = *(unsigned int *)(a1 + 28);
            v118 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v118;
              v70 = v114 << 8;
              *(_DWORD *)(a1 + 32) = v114 << 8;
              if (v117 < v115)
              {
                v119 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v117 + 1;
                v120 = *(unsigned __int8 *)(v119 + v117++);
              }
              else
              {
                v120 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v120 | (v116 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v120;
              *(_DWORD *)(a1 + 36) = v69;
              v118 += 8;
              v116 = v120;
              v25 = v114 > 0x8000;
              v114 <<= 8;
            }
            while (!v25);
          }
          ++v108;
        }
        while (v108 != v65);
        v121 = 0;
        v67[3] = v109;
        v122 = (unsigned __int16)v67[4];
        do
        {
          v123 = v70 >> 8;
          v122 = 2 * v122 - 1;
          v124 = &silk_lsb_iCDF;
          do
          {
            v125 = v70;
            v126 = *v124++;
            v70 = v123 * v126;
            ++v122;
          }
          while (v69 < v123 * v126);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v127 = v125 - v70;
          if (v125 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v125 - v70;
          }
          else
          {
            v128 = *(unsigned int *)(a1 + 8);
            v129 = *(_DWORD *)(a1 + 44);
            v130 = *(unsigned int *)(a1 + 28);
            v131 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v131;
              v70 = v127 << 8;
              *(_DWORD *)(a1 + 32) = v127 << 8;
              if (v130 < v128)
              {
                v132 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v130 + 1;
                v133 = *(unsigned __int8 *)(v132 + v130++);
              }
              else
              {
                v133 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v133 | (v129 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v133;
              *(_DWORD *)(a1 + 36) = v69;
              v131 += 8;
              v129 = v133;
              v25 = v127 > 0x8000;
              v127 <<= 8;
            }
            while (!v25);
          }
          ++v121;
        }
        while (v121 != v65);
        v134 = 0;
        v67[4] = v122;
        v135 = (unsigned __int16)v67[5];
        do
        {
          v136 = v70 >> 8;
          v135 = 2 * v135 - 1;
          v137 = &silk_lsb_iCDF;
          do
          {
            v138 = v70;
            v139 = *v137++;
            v70 = v136 * v139;
            ++v135;
          }
          while (v69 < v136 * v139);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v140 = v138 - v70;
          if (v138 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v138 - v70;
          }
          else
          {
            v141 = *(unsigned int *)(a1 + 8);
            v142 = *(_DWORD *)(a1 + 44);
            v143 = *(unsigned int *)(a1 + 28);
            v144 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v144;
              v70 = v140 << 8;
              *(_DWORD *)(a1 + 32) = v140 << 8;
              if (v143 < v141)
              {
                v145 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v143 + 1;
                v146 = *(unsigned __int8 *)(v145 + v143++);
              }
              else
              {
                v146 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v146 | (v142 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v146;
              *(_DWORD *)(a1 + 36) = v69;
              v144 += 8;
              v142 = v146;
              v25 = v140 > 0x8000;
              v140 <<= 8;
            }
            while (!v25);
          }
          ++v134;
        }
        while (v134 != v65);
        v147 = 0;
        v67[5] = v135;
        v148 = (unsigned __int16)v67[6];
        do
        {
          v149 = v70 >> 8;
          v148 = 2 * v148 - 1;
          v150 = &silk_lsb_iCDF;
          do
          {
            v151 = v70;
            v152 = *v150++;
            v70 = v149 * v152;
            ++v148;
          }
          while (v69 < v149 * v152);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v153 = v151 - v70;
          if (v151 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v151 - v70;
          }
          else
          {
            v154 = *(unsigned int *)(a1 + 8);
            v155 = *(_DWORD *)(a1 + 44);
            v156 = *(unsigned int *)(a1 + 28);
            v157 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v157;
              v70 = v153 << 8;
              *(_DWORD *)(a1 + 32) = v153 << 8;
              if (v156 < v154)
              {
                v158 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v156 + 1;
                v159 = *(unsigned __int8 *)(v158 + v156++);
              }
              else
              {
                v159 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v159 | (v155 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v159;
              *(_DWORD *)(a1 + 36) = v69;
              v157 += 8;
              v155 = v159;
              v25 = v153 > 0x8000;
              v153 <<= 8;
            }
            while (!v25);
          }
          ++v147;
        }
        while (v147 != v65);
        v160 = 0;
        v67[6] = v148;
        v161 = (unsigned __int16)v67[7];
        do
        {
          v162 = v70 >> 8;
          v161 = 2 * v161 - 1;
          v163 = &silk_lsb_iCDF;
          do
          {
            v164 = v70;
            v165 = *v163++;
            v70 = v162 * v165;
            ++v161;
          }
          while (v69 < v162 * v165);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v166 = v164 - v70;
          if (v164 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v164 - v70;
          }
          else
          {
            v167 = *(unsigned int *)(a1 + 8);
            v168 = *(_DWORD *)(a1 + 44);
            v169 = *(unsigned int *)(a1 + 28);
            v170 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v170;
              v70 = v166 << 8;
              *(_DWORD *)(a1 + 32) = v166 << 8;
              if (v169 < v167)
              {
                v171 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v169 + 1;
                v172 = *(unsigned __int8 *)(v171 + v169++);
              }
              else
              {
                v172 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v172 | (v168 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v172;
              *(_DWORD *)(a1 + 36) = v69;
              v170 += 8;
              v168 = v172;
              v25 = v166 > 0x8000;
              v166 <<= 8;
            }
            while (!v25);
          }
          ++v160;
        }
        while (v160 != v65);
        v173 = 0;
        v67[7] = v161;
        v174 = (unsigned __int16)v67[8];
        do
        {
          v175 = v70 >> 8;
          v174 = 2 * v174 - 1;
          v176 = &silk_lsb_iCDF;
          do
          {
            v177 = v70;
            v178 = *v176++;
            v70 = v175 * v178;
            ++v174;
          }
          while (v69 < v175 * v178);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v179 = v177 - v70;
          if (v177 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v177 - v70;
          }
          else
          {
            v180 = *(unsigned int *)(a1 + 8);
            v181 = *(_DWORD *)(a1 + 44);
            v182 = *(unsigned int *)(a1 + 28);
            v183 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v183;
              v70 = v179 << 8;
              *(_DWORD *)(a1 + 32) = v179 << 8;
              if (v182 < v180)
              {
                v184 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v182 + 1;
                v185 = *(unsigned __int8 *)(v184 + v182++);
              }
              else
              {
                v185 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v185 | (v181 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v185;
              *(_DWORD *)(a1 + 36) = v69;
              v183 += 8;
              v181 = v185;
              v25 = v179 > 0x8000;
              v179 <<= 8;
            }
            while (!v25);
          }
          ++v173;
        }
        while (v173 != v65);
        v186 = 0;
        v67[8] = v174;
        v187 = (unsigned __int16)v67[9];
        do
        {
          v188 = v70 >> 8;
          v187 = 2 * v187 - 1;
          v189 = &silk_lsb_iCDF;
          do
          {
            v190 = v70;
            v191 = *v189++;
            v70 = v188 * v191;
            ++v187;
          }
          while (v69 < v188 * v191);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v192 = v190 - v70;
          if (v190 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v190 - v70;
          }
          else
          {
            v193 = *(unsigned int *)(a1 + 8);
            v194 = *(_DWORD *)(a1 + 44);
            v195 = *(unsigned int *)(a1 + 28);
            v196 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v196;
              v70 = v192 << 8;
              *(_DWORD *)(a1 + 32) = v192 << 8;
              if (v195 < v193)
              {
                v197 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v195 + 1;
                v198 = *(unsigned __int8 *)(v197 + v195++);
              }
              else
              {
                v198 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v198 | (v194 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v198;
              *(_DWORD *)(a1 + 36) = v69;
              v196 += 8;
              v194 = v198;
              v25 = v192 > 0x8000;
              v192 <<= 8;
            }
            while (!v25);
          }
          ++v186;
        }
        while (v186 != v65);
        v199 = 0;
        v67[9] = v187;
        v200 = (unsigned __int16)v67[10];
        do
        {
          v201 = v70 >> 8;
          v200 = 2 * v200 - 1;
          v202 = &silk_lsb_iCDF;
          do
          {
            v203 = v70;
            v204 = *v202++;
            v70 = v201 * v204;
            ++v200;
          }
          while (v69 < v201 * v204);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v205 = v203 - v70;
          if (v203 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v203 - v70;
          }
          else
          {
            v206 = *(unsigned int *)(a1 + 8);
            v207 = *(_DWORD *)(a1 + 44);
            v208 = *(unsigned int *)(a1 + 28);
            v209 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v209;
              v70 = v205 << 8;
              *(_DWORD *)(a1 + 32) = v205 << 8;
              if (v208 < v206)
              {
                v210 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v208 + 1;
                v211 = *(unsigned __int8 *)(v210 + v208++);
              }
              else
              {
                v211 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v211 | (v207 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v211;
              *(_DWORD *)(a1 + 36) = v69;
              v209 += 8;
              v207 = v211;
              v25 = v205 > 0x8000;
              v205 <<= 8;
            }
            while (!v25);
          }
          ++v199;
        }
        while (v199 != v65);
        v212 = 0;
        v67[10] = v200;
        v213 = (unsigned __int16)v67[11];
        do
        {
          v214 = v70 >> 8;
          v213 = 2 * v213 - 1;
          v215 = &silk_lsb_iCDF;
          do
          {
            v216 = v70;
            v217 = *v215++;
            v70 = v214 * v217;
            ++v213;
          }
          while (v69 < v214 * v217);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v218 = v216 - v70;
          if (v216 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v216 - v70;
          }
          else
          {
            v219 = *(unsigned int *)(a1 + 8);
            v220 = *(_DWORD *)(a1 + 44);
            v221 = *(unsigned int *)(a1 + 28);
            v222 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v222;
              v70 = v218 << 8;
              *(_DWORD *)(a1 + 32) = v218 << 8;
              if (v221 < v219)
              {
                v223 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v221 + 1;
                v224 = *(unsigned __int8 *)(v223 + v221++);
              }
              else
              {
                v224 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v224 | (v220 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v224;
              *(_DWORD *)(a1 + 36) = v69;
              v222 += 8;
              v220 = v224;
              v25 = v218 > 0x8000;
              v218 <<= 8;
            }
            while (!v25);
          }
          ++v212;
        }
        while (v212 != v65);
        v225 = 0;
        v67[11] = v213;
        v226 = (unsigned __int16)v67[12];
        do
        {
          v227 = v70 >> 8;
          v226 = 2 * v226 - 1;
          v228 = &silk_lsb_iCDF;
          do
          {
            v229 = v70;
            v230 = *v228++;
            v70 = v227 * v230;
            ++v226;
          }
          while (v69 < v227 * v230);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v231 = v229 - v70;
          if (v229 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v229 - v70;
          }
          else
          {
            v232 = *(unsigned int *)(a1 + 8);
            v233 = *(_DWORD *)(a1 + 44);
            v234 = *(unsigned int *)(a1 + 28);
            v235 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v235;
              v70 = v231 << 8;
              *(_DWORD *)(a1 + 32) = v231 << 8;
              if (v234 < v232)
              {
                v236 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v234 + 1;
                v237 = *(unsigned __int8 *)(v236 + v234++);
              }
              else
              {
                v237 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v237 | (v233 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v237;
              *(_DWORD *)(a1 + 36) = v69;
              v235 += 8;
              v233 = v237;
              v25 = v231 > 0x8000;
              v231 <<= 8;
            }
            while (!v25);
          }
          ++v225;
        }
        while (v225 != v65);
        v238 = 0;
        v67[12] = v226;
        v239 = (unsigned __int16)v67[13];
        do
        {
          v240 = v70 >> 8;
          v239 = 2 * v239 - 1;
          v241 = &silk_lsb_iCDF;
          do
          {
            v242 = v70;
            v243 = *v241++;
            v70 = v240 * v243;
            ++v239;
          }
          while (v69 < v240 * v243);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v244 = v242 - v70;
          if (v242 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v242 - v70;
          }
          else
          {
            v245 = *(unsigned int *)(a1 + 8);
            v246 = *(_DWORD *)(a1 + 44);
            v247 = *(unsigned int *)(a1 + 28);
            v248 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v248;
              v70 = v244 << 8;
              *(_DWORD *)(a1 + 32) = v244 << 8;
              if (v247 < v245)
              {
                v249 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v247 + 1;
                v250 = *(unsigned __int8 *)(v249 + v247++);
              }
              else
              {
                v250 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v250 | (v246 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v250;
              *(_DWORD *)(a1 + 36) = v69;
              v248 += 8;
              v246 = v250;
              v25 = v244 > 0x8000;
              v244 <<= 8;
            }
            while (!v25);
          }
          ++v238;
        }
        while (v238 != v65);
        v251 = 0;
        v67[13] = v239;
        v252 = (unsigned __int16)v67[14];
        do
        {
          v253 = v70 >> 8;
          v252 = 2 * v252 - 1;
          v254 = &silk_lsb_iCDF;
          do
          {
            v255 = v70;
            v256 = *v254++;
            v70 = v253 * v256;
            ++v252;
          }
          while (v69 < v253 * v256);
          *(_DWORD *)(a1 + 36) = v69 - v70;
          v257 = v255 - v70;
          if (v255 - v70 >= 0x800001)
          {
            v69 -= v70;
            v70 = v255 - v70;
          }
          else
          {
            v258 = *(unsigned int *)(a1 + 8);
            v259 = *(_DWORD *)(a1 + 44);
            v260 = *(unsigned int *)(a1 + 28);
            v261 = *(_DWORD *)(a1 + 24) + 8;
            v69 -= v70;
            do
            {
              *(_DWORD *)(a1 + 24) = v261;
              v70 = v257 << 8;
              *(_DWORD *)(a1 + 32) = v257 << 8;
              if (v260 < v258)
              {
                v262 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v260 + 1;
                v263 = *(unsigned __int8 *)(v262 + v260++);
              }
              else
              {
                v263 = 0;
              }
              v69 = (((v69 & 0x7FFFFF) << 8) | ((v263 | (v259 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v263;
              *(_DWORD *)(a1 + 36) = v69;
              v261 += 8;
              v259 = v263;
              v25 = v257 > 0x8000;
              v257 <<= 8;
            }
            while (!v25);
          }
          ++v251;
        }
        while (v251 != v65);
        v264 = 0;
        v67[14] = v252;
        v265 = (unsigned __int16)v67[15];
        do
        {
          v266 = v70 >> 8;
          v265 = 2 * v265 - 1;
          v267 = &silk_lsb_iCDF;
          do
          {
            v268 = v70;
            v269 = *v267++;
            v70 = v266 * v269;
            ++v265;
            v270 = v69 - v266 * v269;
          }
          while (v69 < v266 * v269);
          v271 = v268 - v70;
          *(_DWORD *)(a1 + 32) = v268 - v70;
          *(_DWORD *)(a1 + 36) = v270;
          if (v268 - v70 >= 0x800001)
          {
            v70 = v268 - v70;
          }
          else
          {
            v272 = *(unsigned int *)(a1 + 8);
            v273 = *(_DWORD *)(a1 + 44);
            v274 = *(unsigned int *)(a1 + 28);
            v275 = *(_DWORD *)(a1 + 24) + 8;
            do
            {
              *(_DWORD *)(a1 + 24) = v275;
              v70 = v271 << 8;
              *(_DWORD *)(a1 + 32) = v271 << 8;
              if (v274 < v272)
              {
                v276 = *(_QWORD *)a1;
                *(_DWORD *)(a1 + 28) = v274 + 1;
                v277 = *(unsigned __int8 *)(v276 + v274++);
              }
              else
              {
                v277 = 0;
              }
              v270 = (((v270 & 0x7FFFFF) << 8) | ((v277 | (v273 << 8)) >> 1)) ^ 0xFF;
              *(_DWORD *)(a1 + 44) = v277;
              *(_DWORD *)(a1 + 36) = v270;
              v275 += 8;
              v273 = v277;
              v25 = v271 > 0x8000;
              v271 <<= 8;
            }
            while (!v25);
          }
          ++v264;
          v69 = v270;
        }
        while (v264 != v65);
        v67[15] = v265;
        v280[i] |= 32 * v65;
      }
    }
  }
  return silk_decode_signs((uint64_t *)a1, a2, a5, a3, a4, (uint64_t)v280);
}

uint64_t silk_decoder_set_fs(uint64_t a1, int a2, unsigned int a3)
{
  int v6;
  int v7;
  uint64_t v8;
  char v9;
  int v10;
  BOOL v11;
  void *v12;
  void *v13;
  char *v14;

  v6 = (__int16)a2;
  *(_DWORD *)(a1 + 2332) = 5 * (__int16)a2;
  v7 = *(__int16 *)(a1 + 2324) * (__int16)(5 * a2);
  if (*(_DWORD *)(a1 + 2316) == a2 && *(_DWORD *)(a1 + 2320) == a3)
  {
    v8 = 0;
  }
  else
  {
    v8 = silk_resampler_init(a1 + 2448, 1000 * (__int16)a2, a3, 0);
    v9 = 0;
    *(_DWORD *)(a1 + 2320) = a3;
    if (*(_DWORD *)(a1 + 2316) != a2)
      goto LABEL_7;
  }
  if (v7 != *(_DWORD *)(a1 + 2328))
  {
    v9 = 1;
LABEL_7:
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = v10 == 4;
    if (v10 == 4)
      v12 = &silk_pitch_contour_NB_iCDF;
    else
      v12 = &silk_pitch_contour_10_ms_NB_iCDF;
    v13 = &silk_pitch_contour_10_ms_iCDF;
    if (v11)
      v13 = &silk_pitch_contour_iCDF;
    if (a2 != 8)
      v12 = v13;
    *(_QWORD *)(a1 + 2392) = v12;
    if ((v9 & 1) != 0)
      goto LABEL_25;
    *(_DWORD *)(a1 + 2336) = 20 * v6;
    if ((a2 | 4) == 0xC)
    {
      *(_DWORD *)(a1 + 2340) = 10;
      *(_QWORD *)(a1 + 2752) = &silk_NLSF_CB_NB_MB;
      if (a2 != 16)
        goto LABEL_17;
    }
    else
    {
      *(_DWORD *)(a1 + 2340) = 16;
      *(_QWORD *)(a1 + 2752) = &silk_NLSF_CB_WB;
      if (a2 != 16)
      {
LABEL_17:
        if (a2 == 12)
        {
          v14 = (char *)&silk_uniform6_iCDF;
        }
        else
        {
          if (a2 != 8)
          {
LABEL_24:
            *(_DWORD *)(a1 + 2376) = 1;
            *(_DWORD *)(a1 + 2308) = 100;
            *(_BYTE *)(a1 + 2312) = 10;
            *(_DWORD *)(a1 + 4188) = 0;
            bzero((void *)(a1 + 1348), 0x3C0uLL);
            *(_OWORD *)(a1 + 1316) = 0u;
            *(_OWORD *)(a1 + 1332) = 0u;
            *(_OWORD *)(a1 + 1284) = 0u;
            *(_OWORD *)(a1 + 1300) = 0u;
LABEL_25:
            *(_DWORD *)(a1 + 2316) = a2;
            *(_DWORD *)(a1 + 2328) = v7;
            return v8;
          }
          v14 = silk_uniform4_iCDF;
        }
LABEL_23:
        *(_QWORD *)(a1 + 2384) = v14;
        goto LABEL_24;
      }
    }
    v14 = silk_uniform8_iCDF;
    goto LABEL_23;
  }
  return v8;
}

uint64_t silk_InitEncoder(uint64_t a1, int a2, uint64_t a3)
{
  _OWORD *v6;
  int32x2_t v7;
  int v8;
  __int128 v9;
  int v10;
  int v11;
  int v12;
  int v13;
  _BOOL4 v14;

  v6 = (_OWORD *)(a1 + 10184);
  bzero((void *)a1, 0x4F28uLL);
  bzero((void *)a1, 0x2768uLL);
  v7 = vdup_n_s32(0x2F400u);
  *(_DWORD *)(a1 + 5108) = a2;
  *(int32x2_t *)(a1 + 8) = v7;
  *(_DWORD *)(a1 + 4664) = 1;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(_OWORD *)(a1 + 100) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(_OWORD *)(a1 + 96) = xmmword_208F332D0;
  *(_OWORD *)(a1 + 112) = xmmword_208F332E0;
  *(_OWORD *)(a1 + 128) = xmmword_208F332C0;
  *(_DWORD *)(a1 + 144) = 15;
  memset_pattern16((void *)(a1 + 76), &memset_pattern_5, 0x10uLL);
  bzero((void *)(a1 + 10088), 0x2768uLL);
  *(_DWORD *)(a1 + 15196) = a2;
  *(int32x2_t *)(a1 + 10096) = v7;
  *(_DWORD *)(a1 + 14752) = 1;
  *(_OWORD *)(a1 + 10220) = 0u;
  *(_OWORD *)(a1 + 10204) = 0u;
  *(_OWORD *)(a1 + 10172) = 0u;
  *(_OWORD *)(a1 + 10188) = 0u;
  *(_OWORD *)(a1 + 10124) = 0u;
  *(_OWORD *)(a1 + 10140) = 0u;
  *(_OWORD *)(a1 + 10156) = 0u;
  *v6 = xmmword_208F332D0;
  v6[1] = xmmword_208F332E0;
  v6[2] = xmmword_208F332C0;
  *(_DWORD *)(a1 + 10232) = 15;
  memset_pattern16((void *)(a1 + 10164), &memset_pattern_5, 0x10uLL);
  *(_QWORD *)(a1 + 20240) = 0x100000001;
  *(_QWORD *)a3 = 0x100000001;
  v8 = *(_DWORD *)(a1 + 4564);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 4556);
  *(_DWORD *)(a3 + 12) = v8;
  *(_QWORD *)&v9 = *(_QWORD *)(a1 + 4568);
  *((int32x2_t *)&v9 + 1) = vrev64_s32(*(int32x2_t *)(a1 + 4608));
  *(_OWORD *)(a3 + 16) = v9;
  v10 = *(_DWORD *)(a1 + 4624);
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 4616);
  *(_DWORD *)(a3 + 36) = v10;
  *(_DWORD *)(a3 + 40) = *(_DWORD *)(a1 + 6108);
  v11 = *(_DWORD *)(a1 + 4676);
  *(_DWORD *)(a3 + 48) = *(_DWORD *)(a1 + 6096);
  *(_DWORD *)(a3 + 52) = v11;
  v12 = *(_DWORD *)(a1 + 4576);
  v13 = *(_DWORD *)(a1 + 4536);
  *(_DWORD *)(a3 + 72) = 1000 * (__int16)v12;
  *(_DWORD *)(a3 + 76) = v13;
  v14 = v12 == 16 && *(_DWORD *)(a1 + 28) == 0;
  *(_DWORD *)(a3 + 80) = v14;
  return 0;
}

uint64_t silk_Encode(uint64_t a1, _DWORD *a2, const __int16 *a3, int a4, uint64_t *a5, int *a6, int a7, int a8)
{
  _DWORD *v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  _DWORD *v24;
  uint64_t v25;
  int16x8_t *v26;
  __int32 v27;
  int32x2_t v28;
  __int32 v29;
  __int128 v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int32x2_t v34;
  int16x8_t *v35;
  __int32 v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  int16x8_t *v40;
  uint64_t v41;
  __int32 *v42;
  uint64_t v43;
  __int8 *v44;
  int16x8_t *v45;
  int v46;
  __int32 *v47;
  BOOL v49;
  int16x8_t *v50;
  uint64_t v51;
  uint64_t v52;
  __int32 v53;
  int v54;
  char *v55;
  uint64_t v56;
  int8x16_t v57;
  const __int16 *v58;
  int v59;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  BOOL v64;
  int v65;
  int v66;
  int v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  char *v71;
  int v72;
  uint64_t v73;
  int v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  const __int16 *v79;
  uint64_t v80;
  unsigned __int128 *v81;
  const __int16 *v82;
  unsigned __int128 v83;
  unsigned __int128 v84;
  uint64_t v85;
  char *v86;
  const __int16 *v87;
  __int16 v88;
  int v89;
  int v91;
  uint64_t v92;
  int v93;
  int v94;
  uint64_t v95;
  const __int16 *v96;
  uint64_t v97;
  int16x8_t *v98;
  const __int16 *v99;
  int8x16_t v100;
  int8x16_t v101;
  uint64_t v102;
  char *v103;
  const __int16 *v104;
  unsigned int v105;
  uint64_t *v106;
  uint64_t v107;
  int v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  uint64_t v114;
  const __int16 *v115;
  uint64_t v116;
  unsigned __int128 *v117;
  const __int16 *v118;
  unsigned __int128 v119;
  unsigned __int128 v120;
  uint64_t v121;
  char *v122;
  const __int16 *v123;
  __int16 v124;
  int v125;
  signed int v126;
  int v127;
  int v128;
  uint64_t v129;
  uint64_t v130;
  uint32x4_t *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  __int32 v135;
  int8x16_t v136;
  uint64_t v137;
  uint32x4_t *v138;
  int8x16_t v139;
  uint32x4_t v140;
  int32x4_t v141;
  int32x4_t v142;
  int8x16_t v143;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t *v148;
  uint64_t v149;
  char *v150;
  unint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  _DWORD *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v174;
  uint64_t v175;
  int v176;
  int v177;
  int v178;
  unsigned int v179;
  int v180;
  int v181;
  int v182;
  int v183;
  int v184;
  int v185;
  int v186;
  int16x8_t *v187;
  uint64_t v188;
  uint64_t v189;
  int16x8_t *v190;
  int v191;
  char v192;
  int v193;
  uint64_t *v194;
  _OWORD *v195;
  int16x8_t *v196;
  int v197;
  char v198;
  int v199;
  int v200;
  int16x8_t *v201;
  __int32 v202;
  int v203;
  int v204;
  unsigned __int8 *v205;
  int v206;
  int v207;
  uint64_t i;
  int v211;
  __int32 v214;
  int v215;
  unsigned __int8 *v216;
  int v217;
  uint64_t v218;
  int v219;
  uint64_t v220;
  int v221;
  char *v222;
  uint64_t *v223;
  uint64_t v224;
  uint64_t v225;
  char *v226;
  int v227;
  char v228;
  char v229;
  int v230;
  int v231;
  int v232;
  char *v233;
  int v234;
  uint64_t *v235;
  __int8 *v236;
  unint64_t v237;
  int v238;
  int v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  int16x8_t *v244;
  int16x8_t v245;
  uint64_t v246;
  int v247;
  _BOOL4 v248;
  int v249;
  int v250;
  uint64_t v251;
  uint64_t v252;
  _DWORD *v253;
  uint64_t v254;
  _DWORD *v255;
  char *v256;
  int v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t *v260;
  int v261;
  int v262;
  _OWORD *v263;
  void *v264;
  int16x8_t *v265;
  int16x8_t *v266;
  int v267;
  uint64_t v268;
  int v269;
  uint32x4_t *v270;
  _QWORD *v271;
  __int8 *v272;
  int *v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  unsigned __int16 *v278;
  int v279;
  void *v280;
  unsigned int v281;
  int v282;
  uint64_t v283;
  int v284;
  int *v285;
  _QWORD *v286;
  char *v287;
  char *v288;
  int v289;
  int v290;
  unsigned int v291;
  uint64_t v292;
  __int128 v293;
  int v294;
  _DWORD *v295;
  const __int16 *v296;
  uint64_t v297;
  int v298;
  int v299;
  int *v300;
  int v301;
  uint64_t v302;
  uint64_t v303;
  char *v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  _DWORD *v309;
  uint64_t v310;
  uint64_t v311;
  int16x8_t *v312;
  uint64_t v313;
  __int128 v314;
  __int128 v315;
  __int128 v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t *v319;
  __int16 v320;
  int16x8_t v321;
  uint64_t v322;
  int16x8x2_t v323;
  int16x8x2_t v324;

  v289 = a8;
  v300 = a6;
  v319 = a5;
  v296 = a3;
  v10 = a2;
  v322 = *MEMORY[0x24BDAC8D0];
  if (a2[17])
  {
    *(_DWORD *)(a1 + 4664) = 1;
    *(_DWORD *)(a1 + 14752) = 1;
  }
  *(_DWORD *)(a1 + 15852) = 0;
  *(_DWORD *)(a1 + 5764) = 0;
  v12 = check_control_input(a2);
  v14 = v12;
  if ((_DWORD)v12)
    return v14;
  v294 = a4;
  v16 = (_DWORD *)(a1 + 20176);
  v280 = (void *)(a1 + 10088);
  v10[22] = 0;
  v17 = v10[1];
  v18 = *(_DWORD *)(a1 + 20244);
  v295 = (_DWORD *)(a1 + 20176);
  if (v17 > v18)
  {
    v19 = *(_DWORD *)(a1 + 5108);
    bzero(v280, 0x2768uLL);
    *(_DWORD *)(a1 + 15196) = v19;
    *(int32x2_t *)(a1 + 10096) = vdup_n_s32(0x2F400u);
    *(_DWORD *)(a1 + 14752) = 1;
    *(_OWORD *)(a1 + 10220) = 0u;
    *(_OWORD *)(a1 + 10204) = 0u;
    *(_OWORD *)(a1 + 10172) = 0u;
    *(_OWORD *)(a1 + 10188) = 0u;
    *(_OWORD *)(a1 + 10124) = 0u;
    *(_OWORD *)(a1 + 10140) = 0u;
    *(_OWORD *)(a1 + 10156) = 0u;
    *(_OWORD *)(a1 + 10184) = xmmword_208F332D0;
    *(_OWORD *)(a1 + 10200) = xmmword_208F332E0;
    *(_OWORD *)(a1 + 10216) = xmmword_208F332C0;
    *(_DWORD *)(a1 + 10232) = 15;
    memset_pattern16((void *)(a1 + 10164), &memset_pattern_5, 0x10uLL);
    *v16 = 0;
    *(_OWORD *)(a1 + 20184) = xmmword_208F05120;
    *(_QWORD *)(a1 + 20200) = 0x400000000001;
    if (*(_DWORD *)(a1 + 20240) == 2)
    {
      v12 = (uint64_t)memcpy((void *)(a1 + 15880), (const void *)(a1 + 5792), 0x130uLL);
      *(_QWORD *)(a1 + 10088) = *(_QWORD *)a1;
    }
    v17 = v10[1];
    v16 = v295;
  }
  LODWORD(v318) = v10[6];
  v312 = (int16x8_t *)a1;
  LODWORD(v317) = *(_DWORD *)(a1 + 4612);
  v16[16] = *v10;
  v16[17] = v17;
  v20 = v294;
  v21 = v10[2];
  v22 = 100 * v294 / v21;
  v23 = v22 >> 1;
  if (v22 <= 1)
    v23 = 1;
  v298 = v23;
  v279 = a7;
  v24 = v16;
  if (!a7)
  {
    v14 = 4294967195;
    if (v294 < 0 || v22 * v21 != 100 * v294 || 1000 * v294 > v21 * (int)v318)
      return v14;
    LODWORD(v313) = 100 * v294 / v21;
    v262 = 0;
    v32 = 0;
    LODWORD(v31) = v17;
    goto LABEL_35;
  }
  if (v22 != 1)
    return 4294967195;
  LODWORD(v313) = 1;
  if (a7 == 2)
  {
    v321 = v312[1];
    if (v17 >= 1)
    {
      LODWORD(v311) = v18;
      v25 = 0;
      v26 = v312;
      v27 = v312[286].i32[0];
      v28 = vdup_n_s32(0x2F400u);
      v316 = xmmword_208F332C0;
      v315 = xmmword_208F332D0;
      v314 = xmmword_208F332E0;
      do
      {
        v29 = v26[319].i32[1];
        bzero(v26, 0x2768uLL);
        v26[319].i32[1] = v29;
        v26->u64[1] = (unint64_t)v28;
        v26[291].i32[2] = 1;
        *(int16x8_t *)((char *)&v26[8] + 4) = 0u;
        *(int16x8_t *)((char *)&v26[7] + 4) = 0u;
        *(int16x8_t *)((char *)&v26[5] + 4) = 0u;
        *(int16x8_t *)((char *)&v26[6] + 4) = 0u;
        *(int16x8_t *)((char *)&v26[2] + 4) = 0u;
        *(int16x8_t *)((char *)&v26[3] + 4) = 0u;
        *(int16x8_t *)((char *)&v26[4] + 4) = 0u;
        v30 = v316;
        v26[6] = (int16x8_t)v315;
        v26[7] = (int16x8_t)v314;
        v26[8] = (int16x8_t)v30;
        v26[9].i32[0] = 15;
        memset_pattern16((char *)&v26[4].u64[1] + 4, &memset_pattern_5, 0x10uLL);
        v26[1] = v321;
        v26[2].i32[0] = v27;
        ++v25;
        v31 = (int)v10[1];
        v26 = (int16x8_t *)((char *)v26 + 10088);
      }
      while (v25 < v31);
      a7 = v279;
      goto LABEL_26;
    }
LABEL_29:
    v10[6] = 10;
    v32 = v10[9];
    v10[9] = 0;
    v262 = v318;
    LODWORD(v31) = v17;
    v20 = v294;
    goto LABEL_35;
  }
  if (v17 < 1)
    goto LABEL_29;
  LODWORD(v311) = v18;
  v33 = 0;
  v34 = vdup_n_s32(0x2F400u);
  v316 = xmmword_208F332C0;
  v315 = xmmword_208F332D0;
  v314 = xmmword_208F332E0;
  v35 = v312;
  do
  {
    v36 = v35[319].i32[1];
    bzero(v35, 0x2768uLL);
    v35[319].i32[1] = v36;
    v35->u64[1] = (unint64_t)v34;
    v35[291].i32[2] = 1;
    *(int16x8_t *)((char *)&v35[8] + 4) = 0u;
    *(int16x8_t *)((char *)&v35[7] + 4) = 0u;
    *(int16x8_t *)((char *)&v35[5] + 4) = 0u;
    *(int16x8_t *)((char *)&v35[6] + 4) = 0u;
    *(int16x8_t *)((char *)&v35[2] + 4) = 0u;
    *(int16x8_t *)((char *)&v35[3] + 4) = 0u;
    *(int16x8_t *)((char *)&v35[4] + 4) = 0u;
    v37 = v316;
    v35[6] = (int16x8_t)v315;
    v35[7] = (int16x8_t)v314;
    v35[8] = (int16x8_t)v37;
    v35[9].i32[0] = 15;
    memset_pattern16((char *)&v35[4].u64[1] + 4, &memset_pattern_5, 0x10uLL);
    ++v33;
    v31 = (int)v10[1];
    v35 = (int16x8_t *)((char *)v35 + 10088);
  }
  while (v33 < v31);
LABEL_26:
  v262 = v10[6];
  v10[6] = 10;
  v32 = v10[9];
  v10[9] = 0;
  v24 = v295;
  v20 = v294;
  v18 = v311;
  if ((int)v31 >= 1)
  {
    if ((_DWORD)v31 == 1)
    {
      v38 = 0;
    }
    else
    {
      v38 = v31 & 0xFFFFFFFE;
      v39 = v38;
      v40 = v312;
      do
      {
        v40[291].i32[3] = 0;
        v40[922].i32[1] = 0;
        v40[292].i32[2] = 1;
        v40[923].i32[0] = 1;
        v40 += 1261;
        v39 -= 2;
      }
      while (v39);
      if (v38 == v31)
        goto LABEL_35;
    }
    v41 = v31 - v38;
    v42 = &v312[292].i32[2522 * v38 + 2];
    do
    {
      *(v42 - 3) = 0;
      *v42 = 1;
      v42 += 2522;
      --v41;
    }
    while (v41);
  }
LABEL_35:
  if ((int)v31 >= 1)
  {
    v43 = 0;
    v44 = &v312[296].i8[4];
    do
    {
      if (v43 == 1)
      {
        v45 = v312;
        v46 = v312[286].i32[0];
      }
      else
      {
        v46 = 0;
        v45 = v312;
      }
      v47 = &v45->i32[2522 * v43];
      v12 = silk_control_encoder((uint64_t)v47, (uint64_t)v10, v295[20], v43, v46);
      if ((_DWORD)v12)
        return v12;
      if (v47[1166])
        _ZF = 0;
      else
        _ZF = (_DWORD)v318 == (_DWORD)v317;
      v49 = _ZF && v18 == v17;
      v50 = v312;
      if (!v49 && v312[360].i32[0] >= 1)
      {
        v51 = 0;
        do
          *(_DWORD *)&v44[4 * v51++] = 0;
        while (v51 < v50[360].i32[0]);
      }
      v47[1525] = v47[1524];
      ++v43;
      v44 += 10088;
      v24 = v295;
    }
    while (v43 < (int)v10[1]);
  }
  v261 = v32;
  v260 = &v258;
  v52 = (uint64_t)v312;
  v265 = v312 + 1080;
  v271 = (uint64_t *)((char *)&v312[1011].i64[1] + 4);
  v272 = &v312[914].i8[5];
  v53 = v312[286].i32[0];
  v267 = 10 * v313;
  v284 = v53 * 10 * v313;
  MEMORY[0x24BDAC7A8](v12, v13);
  LODWORD(v14) = 0;
  v54 = 0;
  v285 = (int *)(v52 + 5792);
  v273 = (int *)(v52 + 15880);
  v278 = (unsigned __int16 *)(v52 + 20176);
  v277 = v52 + 5116;
  v276 = v52 + 15204;
  v264 = (void *)(v52 + 10236);
  v263 = (_OWORD *)(v52 + 14588);
  v301 = v298 - 1;
  v269 = 2 * v298;
  v286 = v55 + 1364;
  v268 = v52 + 15202;
  v283 = v52 + 5114;
  v288 = (char *)&v258 - v56;
  v266 = (int16x8_t *)((char *)&v258 - v56 + 16);
  v287 = v55;
  v270 = (uint32x4_t *)(v55 + 20);
  v274 = v52 + 4740;
  v318 = v52 + 34848;
  v308 = v52 + 36413;
  v297 = v52 + 35004;
  v307 = v52 + 6228;
  v306 = v52 + 6150;
  v305 = v52 + 6149;
  v57.i64[0] = 0x100000001;
  v57.i64[1] = 0x100000001;
  v293 = xmmword_208F071C0;
  v275 = v52 + 20228;
  v58 = v296;
  v259 = v52 + 5112;
  v258 = v52 + 15200;
  do
  {
    v294 = v20;
    v66 = *(_DWORD *)(v52 + 5756);
    if (*(_DWORD *)(v52 + 4584) - v66 >= v284)
      v67 = v284;
    else
      v67 = *(_DWORD *)(v52 + 4584) - v66;
    v68 = (v67 * *(_DWORD *)(v52 + 4556) / (1000 * *(_DWORD *)(v52 + 4576)));
    _ZF = *v10 == 2;
    v292 = v68;
    v296 = v58;
    if (!_ZF)
      goto LABEL_71;
    v69 = v10[1];
    if (v69 == 1)
    {
      if ((int)v68 < 1)
        goto LABEL_98;
      if (v68 >= 0x10)
      {
        v77 = v68 & 0x7FFFFFF0;
        v96 = v296 + 16;
        v97 = v68 & 0xFFFFFFF0;
        v98 = v266;
        do
        {
          v99 = v96 - 16;
          v323 = vld2q_s16(v99);
          v324 = vld2q_s16(v96);
          v100 = (int8x16_t)vaddl_high_u16((uint16x8_t)v323.val[1], (uint16x8_t)v323.val[0]);
          v101 = (int8x16_t)vaddl_u16(*(uint16x4_t *)v323.val[1].i8, *(uint16x4_t *)v323.val[0].i8);
          v323.val[0] = vhaddq_s16(v323.val[1], v323.val[0]);
          v323.val[1] = vhaddq_s16(v324.val[1], v324.val[0]);
          v98[-1] = vuzp1q_s16((int16x8_t)vaddw_u16((uint32x4_t)vandq_s8(v101, v57), *(uint16x4_t *)v323.val[0].i8), (int16x8_t)vaddw_high_u16((uint32x4_t)vandq_s8(v100, v57), (uint16x8_t)v323.val[0]));
          *v98 = vuzp1q_s16((int16x8_t)vaddw_u16((uint32x4_t)vandq_s8((int8x16_t)vaddl_u16(*(uint16x4_t *)v324.val[1].i8, *(uint16x4_t *)v324.val[0].i8), v57), *(uint16x4_t *)v323.val[1].i8), (int16x8_t)vaddw_high_u16((uint32x4_t)vandq_s8((int8x16_t)vaddl_high_u16((uint16x8_t)v324.val[1], (uint16x8_t)v324.val[0]), v57), (uint16x8_t)v323.val[1]));
          v96 += 32;
          v98 += 2;
          v97 -= 16;
        }
        while (v97);
        if (v77 == v68)
        {
LABEL_98:
          v14 = silk_resampler(v285, (_WORD *)(v52 + 2 * (v66 + 2) + 5112), v288, v68)
              + v14;
          if (v24[18] != 2)
          {
            v106 = v319;
LABEL_107:
            v76 = *(_DWORD *)(v52 + 5756) + v67;
            *(_DWORD *)(v52 + 5756) = v76;
            goto LABEL_116;
          }
          v106 = v319;
          if (*(_DWORD *)(v52 + 5764))
            goto LABEL_107;
          v14 = silk_resampler(v273, (_WORD *)(v52 + 2 * *(int *)(v52 + 15844) + 15204), v288, v292)
              + v14;
          v107 = *(unsigned int *)(v52 + 4584);
          if ((int)v107 < 1)
            goto LABEL_107;
          v108 = *(_DWORD *)(v52 + 5756);
          v109 = *(_DWORD *)(v52 + 15844);
          if (v107 >= 0x18)
          {
            v110 = 0;
            v237 = v107 - 1;
            v238 = v108 + 2;
            if (v108 + 2 + (int)v107 - 1 < v108 + 2)
              goto LABEL_103;
            v239 = v109 + 2;
            if (v109 + 2 + (int)v237 < v109 + 2 || HIDWORD(v237))
              goto LABEL_103;
            v240 = 2 * (v108 + 2);
            v241 = 2 * (v109 + 2);
            if (v259 + v240 >= (unint64_t)(v258 + 2 * v107 + v241)
              || v258 + v241 >= (unint64_t)(v259 + 2 * v107 + v240))
            {
              v110 = v107 & 0x7FFFFFF0;
              v242 = v107 & 0xFFFFFFF0;
              do
              {
                v243 = v52 + 2 * v238 + 5112;
                v244 = (int16x8_t *)(v52 + 2 * v239);
                v245 = vhaddq_s16(v244[951], *(int16x8_t *)(v52 + 2 * v238 + 5128));
                *(int16x8_t *)v243 = vhaddq_s16(v244[950], *(int16x8_t *)v243);
                *(int16x8_t *)(v243 + 16) = v245;
                v238 += 16;
                v239 += 16;
                v242 -= 16;
              }
              while (v242);
              if (v110 == v107)
                goto LABEL_107;
              goto LABEL_103;
            }
          }
          v110 = 0;
LABEL_103:
          v111 = v107 - v110;
          v112 = v109 + v110 + 2;
          v113 = v108 + v110 + 2;
          do
          {
            *(_WORD *)(v52 + 2 * v113 + 5112) = (*(__int16 *)(v52 + 2 * v112++ + 15200)
                                                               + *(__int16 *)(v52 + 2 * v113 + 5112)) >> 1;
            ++v113;
            --v111;
          }
          while (v111);
          goto LABEL_107;
        }
      }
      else
      {
        v77 = 0;
      }
      v102 = v68 - v77;
      v103 = &v288[2 * v77];
      v104 = &v296[2 * v77 + 1];
      do
      {
        v105 = *v104 + *(v104 - 1);
        *(_WORD *)v103 = (v105 & 1) + (v105 >> 1);
        v103 += 2;
        v104 += 2;
        --v102;
      }
      while (v102);
      goto LABEL_98;
    }
    if (v69 == 2)
    {
      if ((int)v68 >= 1)
      {
        if (v68 >= 0x11)
        {
          v78 = v68 & 0xF;
          if ((v68 & 0xF) == 0)
            v78 = 16;
          v70 = v68 - v78;
          v79 = v296 + 16;
          v80 = v70;
          v81 = (unsigned __int128 *)v266;
          do
          {
            v82 = v79 - 16;
            v83 = (unsigned __int128)vld2q_s16(v82);
            v84 = (unsigned __int128)vld2q_s16(v79);
            *(v81 - 1) = v83;
            *v81 = v84;
            v79 += 32;
            v81 += 2;
            v80 -= 16;
          }
          while (v80);
        }
        else
        {
          v70 = 0;
        }
        v85 = v68 - v70;
        v86 = &v288[2 * v70];
        v87 = &v296[2 * v70];
        do
        {
          v88 = *v87;
          v87 += 2;
          *(_WORD *)v86 = v88;
          v86 += 2;
          --v85;
        }
        while (v85);
      }
      v89 = v14;
      if (v24[18] == 1 && *(_DWORD *)(v52 + 5764) == 0)
      {
        memcpy(v273, v285, 0x130uLL);
        LODWORD(v68) = v292;
      }
      v91 = silk_resampler(v285, (_WORD *)(v52 + 2 * (v66 + 2) + 5112), v288, v68);
      v92 = v292;
      *(_DWORD *)(v52 + 5756) += v67;
      v93 = *(_DWORD *)(v52 + 15844);
      if (*(_DWORD *)(v52 + 14672) - v93 >= *(_DWORD *)(v52 + 14664) * v267)
        v94 = *(_DWORD *)(v52 + 14664) * v267;
      else
        v94 = *(_DWORD *)(v52 + 14672) - v93;
      if ((int)v92 >= 1)
      {
        if (v92 >= 0x11)
        {
          v114 = v92 & 0xF;
          if ((v92 & 0xF) == 0)
            v114 = 16;
          v95 = v92 - v114;
          v115 = v296 + 17;
          v116 = v95;
          v117 = (unsigned __int128 *)v266;
          do
          {
            v118 = v115 - 16;
            v119 = (unsigned __int128)vld2q_s16(v118);
            v120 = (unsigned __int128)vld2q_s16(v115);
            *(v117 - 1) = v119;
            *v117 = v120;
            v115 += 32;
            v117 += 2;
            v116 -= 16;
          }
          while (v116);
        }
        else
        {
          v95 = 0;
        }
        v121 = v92 - v95;
        v122 = &v288[2 * v95];
        v123 = &v296[2 * v95 + 1];
        do
        {
          v124 = *v123;
          v123 += 2;
          *(_WORD *)v122 = v124;
          v122 += 2;
          --v121;
        }
        while (v121);
      }
      v14 = v91 + v89 + silk_resampler(v273, (_WORD *)(v52 + 2 * (v93 + 2) + 15200), v288, v92);
      *(_DWORD *)(v52 + 15844) += v94;
      v76 = *(_DWORD *)(v52 + 5756);
      goto LABEL_115;
    }
LABEL_71:
    v71 = v288;
    v72 = v14;
    v73 = v52;
    v74 = v68;
    memcpy(v288, v58, 2 * (int)v68);
    v75 = v74;
    v52 = v73;
    v14 = silk_resampler(v285, (_WORD *)(v73 + 2 * (v66 + 2) + 5112), v71, v75) + v72;
    v76 = *(_DWORD *)(v73 + 5756) + v67;
    *(_DWORD *)(v73 + 5756) = v76;
LABEL_115:
    v106 = v319;
LABEL_116:
    v125 = *v10;
    v24[20] = 0;
    if (v76 < *(_DWORD *)(v52 + 4584))
    {
      v246 = v10[1];
      v24[18] = v246;
      v10[19] = 0;
      v247 = *(_DWORD *)(v52 + 4576);
      if (v247 != 16)
        goto LABEL_285;
      goto LABEL_283;
    }
    v290 = v125;
    v291 = v14;
    if (*(_DWORD *)(v52 + 5764) | a7)
    {
      v126 = 0;
      goto LABEL_161;
    }
    v320 = 0;
    LOBYTE(v320) = -(0x100u >> (v10[1] + v10[1] * *(_DWORD *)(v52 + 5760)));
    ec_enc_icdf(v106, 0, (uint64_t)&v320, 8);
    v127 = *((_DWORD *)v106 + 6);
    v281 = *((_DWORD *)v106 + 8);
    v128 = v10[1];
    v282 = v127;
    if (v128 >= 1)
    {
      v129 = 0;
      v130 = v274;
      v131 = v270;
      while (1)
      {
        v132 = v52 + 10088 * v129;
        v133 = *(unsigned int *)(v132 + 5760);
        if ((int)v133 < 1)
        {
          v135 = 0;
          goto LABEL_130;
        }
        if (v133 < 8)
          break;
        v134 = v133 & 0x7FFFFFF8;
        v136 = 0uLL;
        v137 = v133 & 0xFFFFFFF8;
        v138 = v131;
        v139 = 0uLL;
        v140 = (uint32x4_t)v293;
        v141.i64[0] = 0x400000004;
        v141.i64[1] = 0x400000004;
        v142.i64[0] = 0x800000008;
        v142.i64[1] = 0x800000008;
        do
        {
          v136 = vorrq_s8((int8x16_t)vshlq_u32(v138[-1], v140), v136);
          v139 = vorrq_s8((int8x16_t)vshlq_u32(*v138, (uint32x4_t)vaddq_s32((int32x4_t)v140, v141)), v139);
          v140 = (uint32x4_t)vaddq_s32((int32x4_t)v140, v142);
          v138 += 2;
          v137 -= 8;
        }
        while (v137);
        v143 = vorrq_s8(v139, v136);
        *(int8x8_t *)v143.i8 = vorr_s8(*(int8x8_t *)v143.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v143, v143, 8uLL));
        v135 = v143.i32[0] | v143.i32[1];
        if (v134 != v133)
          goto LABEL_129;
LABEL_130:
        *(_BYTE *)(v132 + 4739) = v135 > 0;
        if ((int)v133 > 1 && v135 != 0)
        {
          ec_enc_icdf(v319, v135 - 1, (uint64_t)*(&silk_LBRR_flags_iCDF_ptr + (v133 - 2)), 8);
          v128 = v10[1];
        }
        ++v129;
        v131 = (uint32x4_t *)((char *)v131 + 10088);
        v130 += 10088;
        if (v129 >= v128)
          goto LABEL_135;
      }
      v134 = 0;
      v135 = 0;
      do
      {
LABEL_129:
        v135 |= *(_DWORD *)(v130 + 4 * v134) << v134;
        ++v134;
      }
      while (v133 != v134);
      goto LABEL_130;
    }
LABEL_135:
    if (*(int *)(v52 + 5760) < 1)
    {
      v148 = v319;
    }
    else
    {
      v145 = 0;
      v146 = 0xFFFFFFFFLL;
      v147 = v52;
      *(_QWORD *)&v316 = v305;
      *(_QWORD *)&v315 = v306;
      *(_QWORD *)&v314 = v307;
      v317 = v297;
      v313 = v308;
      v148 = v319;
      v299 = v54;
      do
      {
        v302 = v146;
        if (v128 >= 1)
        {
          v150 = (char *)(v52 + 20176 + 6 * v145 + 34);
          v309 = (_DWORD *)(v52 + 4 * v145 + 14828);
          v304 = (char *)(v52 + 20176 + v145 + 52);
          v310 = v147;
          if (v145)
          {
            v151 = 0;
            v152 = 0;
            v153 = 4 * v146;
            v311 = v297 + v153;
            v154 = v52 + v153;
            do
            {
              _X9 = v317 + v151;
              __asm { PRFM            #0, [X9] }
              if (*(_DWORD *)(v147 + v151 + 4740))
              {
                v166 = v10;
                if (!v151 && v128 == 2)
                {
                  ec_enc_icdf(v148, 5 * v150[2] + v150[5], (uint64_t)&silk_stereo_pred_joint_iCDF, 8);
                  ec_enc_icdf(v148, *v150, (uint64_t)&silk_uniform3_iCDF, 8);
                  ec_enc_icdf(v148, v150[1], (uint64_t)silk_uniform5_iCDF, 8);
                  ec_enc_icdf(v148, v150[3], (uint64_t)&silk_uniform3_iCDF, 8);
                  v147 = v310;
                  ec_enc_icdf(v148, v150[4], (uint64_t)silk_uniform5_iCDF, 8);
                  if (!*v309)
                    ec_enc_icdf(v148, *v304, (uint64_t)&silk_stereo_only_code_mid_iCDF, 8);
                }
                _X19 = v318 + v151;
                v52 = (uint64_t)v312;
                _X28 = v313 + v151;
                _X8 = v311 + v151;
                __asm { PRFM            #0, [X8] }
                silk_encode_indices((uint64_t)&v312->i64[v151 / 8], v319, v145, 1, 2 * (*(_DWORD *)(v154 + v151 + 4740) != 0));
                __asm
                {
                  PRFM            #0, [X28]
                  PRFM            #0, [X19]
                }
                v148 = v319;
                silk_encode_pulses(v319, *(char *)(v316 + v151), *(char *)(v315 + v151), v314 + v151, *(_DWORD *)(v52 + v151 + 4584));
                v10 = v166;
                v128 = v166[1];
              }
              ++v152;
              v151 += 10088;
            }
            while (v152 < v128);
          }
          else
          {
            v167 = 0;
            v168 = 0;
            v303 = 0;
            do
            {
              _X26 = v318 + v167;
              __asm { PRFUM           #0, [X26,#0x9C] }
              if (*(_DWORD *)(v52 + v167 + 4740))
              {
                if (!v167 && v128 == 2)
                {
                  ec_enc_icdf(v148, 5 * v150[2] + v150[5], (uint64_t)&silk_stereo_pred_joint_iCDF, 8);
                  ec_enc_icdf(v148, *v150, (uint64_t)&silk_uniform3_iCDF, 8);
                  ec_enc_icdf(v148, v150[1], (uint64_t)silk_uniform5_iCDF, 8);
                  v145 = v303;
                  ec_enc_icdf(v148, v150[3], (uint64_t)&silk_uniform3_iCDF, 8);
                  v147 = v310;
                  ec_enc_icdf(v148, v150[4], (uint64_t)silk_uniform5_iCDF, 8);
                  if (!*v309)
                    ec_enc_icdf(v148, *v304, (uint64_t)&silk_stereo_only_code_mid_iCDF, 8);
                }
                _X19 = v308 + v167;
                silk_encode_indices(v52 + v167, v319, 0, 1, 0);
                __asm { PRFM            #0, [X19] }
                v148 = v319;
                __asm { PRFM            #0, [X26] }
                silk_encode_pulses(v319, *(char *)(v305 + v167), *(char *)(v306 + v167), v307 + v167, *(_DWORD *)(v52 + v167 + 4584));
                v128 = v10[1];
              }
              ++v168;
              v167 += 10088;
            }
            while (v168 < v128);
          }
        }
        ++v145;
        v149 = *(int *)(v52 + 5760);
        v313 += 36;
        v146 = (v302 + 1);
        v317 += 4;
        *(_QWORD *)&v314 = v314 + 320;
        *(_QWORD *)&v315 = v315 + 36;
        *(_QWORD *)&v316 = v316 + 36;
        v147 += 4;
        v54 = v299;
      }
      while (v145 < v149);
    }
    if (v128 >= 1)
    {
      v174 = 0;
      v175 = v274;
      do
      {
        *(_DWORD *)(v175 + 8) = 0;
        *(_QWORD *)v175 = 0;
        ++v174;
        v175 += 10088;
      }
      while (v174 < (int)v10[1]);
    }
    v126 = *((_DWORD *)v148 + 6) - (__clz(v281) + v282) + __clz(*((_DWORD *)v148 + 8));
    a7 = v279;
    v24 = v295;
LABEL_161:
    silk_HP_variable_cutoff(v52);
    v177 = v10[6];
    v176 = v10[7];
    v178 = v177 * v176 / 1000;
    if (!a7)
    {
      if (v126 >= 10)
      {
        v180 = v24[14];
        v64 = v180 < 10;
        v179 = (v180 + v126) >> 1;
        if (v64)
          v179 = v126;
      }
      else
      {
        v179 = 0;
      }
      v24[14] = v179;
      v178 -= v179;
    }
    v181 = v178 / *(_DWORD *)(v52 + 5760);
    if (v177 == 10)
      v182 = 100;
    else
      v182 = 50;
    v183 = (__int16)v181 * v182 - 2 * v24[15];
    if (!a7)
    {
      v184 = *(_DWORD *)(v52 + 5764);
      if (v184 >= 1)
        v183 += 2 * (v24[14] + v184 * v181 - (*((_DWORD *)v319 + 6) + __clz(*((_DWORD *)v319 + 8)))) + 64;
    }
    if (v176 <= 5000)
      v185 = 5000;
    else
      v185 = v176;
    if (v176 >= 5000)
      v176 = 5000;
    if (v183 > v176)
      v176 = v183;
    if (v183 <= v185)
      v186 = v176;
    else
      v186 = v185;
    if (v10[1] != 2)
    {
      v190 = v312;
      v312[319].i32[2] = v24[1];
      v24[1] = *(__int32 *)((char *)&v190[319].i32[2] + 2 * v190[286].i32[2]);
      goto LABEL_188;
    }
    v187 = v312;
    v188 = v275;
    silk_stereo_LR_to_MS(v278, v277, v276, &v312[1263].i8[6 * v312[360].i32[1] + 2], (_BYTE *)(v275 + v312[360].i32[1]), &v321, v186, v312[283].u32[1], v10[15], v312[286].i32[0], v312[286].i32[2]);
    v189 = v187[360].i32[1];
    if (!*(_BYTE *)(v188 + v189))
    {
      if (v24[21] == 1)
      {
        v194 = (uint64_t *)v265;
        v265->i32[2] = 0;
        *v194 = 0;
        bzero(v264, 0x1100uLL);
        v195 = v263;
        *v263 = 0u;
        v195[1] = 0u;
        v196 = v312;
        v312[631].i64[1] = 0;
        v196[914].i32[2] = 100;
        v196[910].i32[1] = 100;
        *(_BYTE *)v194 = 10;
        *v272 = 0;
        v196[911].i32[1] = 0x10000;
        v196[922].i32[0] = 1;
      }
      silk_VAD_GetSA_Q8_c();
      v197 = v312[913].i32[3];
      if (v289)
      {
        if (v197 > 12)
        {
          *v271 = 0;
          v198 = 1;
          v272[240] = 1;
          goto LABEL_263;
        }
      }
      else if (v197 >= 13)
      {
        v312[913].i32[3] = 12;
      }
      v272[240] = 0;
      v231 = v312[1012].i32[0];
      v312[1012].i32[0] = v231 + 1;
      if (v231 >= 10)
      {
        if (v231 < 0x1E)
        {
          v198 = 0;
LABEL_263:
          *((_BYTE *)v280 + v312[990].i32[3] + 4736) = v198;
          v190 = v312;
          if (a7)
            goto LABEL_188;
          goto LABEL_264;
        }
        v312[1012].i32[0] = 10;
      }
      v198 = 0;
      *(_DWORD *)v271 = 0;
      goto LABEL_263;
    }
    v187[926].i8[v189 + 8] = 0;
    v190 = v312;
    if (a7)
      goto LABEL_188;
LABEL_264:
    v233 = &v190[1263].i8[6 * v190[360].i32[1] + 2];
    ec_enc_icdf(v319, 5 * v190[1263].i8[6 * v190[360].i32[1] + 4] + v190[1263].i8[6 * v190[360].i32[1] + 7], (uint64_t)&silk_stereo_pred_joint_iCDF, 8);
    ec_enc_icdf(v319, *v233, (uint64_t)&silk_uniform3_iCDF, 8);
    ec_enc_icdf(v319, v233[1], (uint64_t)silk_uniform5_iCDF, 8);
    ec_enc_icdf(v319, v233[3], (uint64_t)&silk_uniform3_iCDF, 8);
    v234 = v233[4];
    v235 = v319;
    ec_enc_icdf(v319, v234, (uint64_t)silk_uniform5_iCDF, 8);
    v236 = &v190->i8[v190[360].i32[1]];
    if (!v236[14824])
      ec_enc_icdf(v235, v236[20228], (uint64_t)&silk_stereo_only_code_mid_iCDF, 8);
LABEL_188:
    silk_VAD_GetSA_Q8_c();
    v191 = v190[283].i32[1];
    if (v289)
    {
      v14 = v291;
      v57.i64[0] = 0x100000001;
      v57.i64[1] = 0x100000001;
      if (v191 > 12)
      {
        *v286 = 0;
        v192 = 1;
        v287[45] = 1;
        goto LABEL_203;
      }
    }
    else
    {
      v14 = v291;
      v57.i64[0] = 0x100000001;
      v57.i64[1] = 0x100000001;
      if (v191 >= 13)
        v312[283].i32[1] = 12;
    }
    v287[45] = 0;
    v193 = v312[381].i32[2];
    v312[381].i32[2] = v193 + 1;
    if (v193 < 10)
      goto LABEL_196;
    if (v193 >= 0x1E)
    {
      v312[381].i32[2] = 10;
LABEL_196:
      v192 = 0;
      *(_DWORD *)v286 = 0;
      goto LABEL_203;
    }
    v192 = 0;
LABEL_203:
    v312[296].i8[v312[360].i32[1]] = v192;
    v199 = v10[1];
    if (v199 >= 1)
    {
      if (v199 == 1)
        v200 = v186;
      else
        v200 = v321.i32[0];
      v201 = v312;
      if (v200 >= 1)
      {
        v312[288].i32[0] = v200;
        v202 = v201[286].i32[0];
        if (v201[286].i32[1] == 2)
          v203 = v200 - v202 / 16 - 2000;
        else
          v203 = v200;
        if (v202 == 8)
        {
          v204 = 106;
          v205 = (unsigned __int8 *)&silk_TargetRate_NB_21;
        }
        else if (v202 == 12)
        {
          v204 = 154;
          v205 = (unsigned __int8 *)&silk_TargetRate_MB_21;
        }
        else
        {
          v204 = 190;
          v205 = (unsigned __int8 *)&silk_TargetRate_WB_21;
        }
        v206 = (v203 + 200) / 400 - 10;
        if (v206 >= v204)
          v206 = v204;
        if (v206 < 1)
          v207 = 0;
        else
          v207 = 21 * v205[v206];
        v201 = v312;
        v312[295].i32[3] = v207;
        v14 = silk_encode_frame_FLP((uint64_t)v201, (uint64_t)v300);
        v199 = v10[1];
        v57.i64[0] = 0x100000001;
        v57.i64[1] = 0x100000001;
      }
      v201[291].i32[3] = 0;
      v201[359].i32[3] = 0;
      ++v201[360].i32[1];
      if (v199 > 1)
      {
        for (i = 1; i < v199; ++i)
        {
          v211 = v186;
          if (v199 != 1)
            v211 = v321.i32[i];
          if (v211 >= 1)
          {
            _X8 = &v201[2808].i32[1];
            v201[918].i32[2] = v211;
            __asm { PRFM            #0, [X8] }
            v214 = v201[916].i32[2];
            if (v201[916].i32[3] == 2)
              v211 = v211 - v214 / 16 - 2000;
            if (v214 == 8)
            {
              v215 = 106;
              v216 = (unsigned __int8 *)&silk_TargetRate_NB_21;
            }
            else if (v214 == 12)
            {
              v215 = 154;
              v216 = (unsigned __int8 *)&silk_TargetRate_MB_21;
            }
            else
            {
              v215 = 190;
              v216 = (unsigned __int8 *)&silk_TargetRate_WB_21;
            }
            v217 = (v211 + 200) / 400 - 10;
            if (v217 < v215)
              v215 = v217;
            if (v215 < 1)
              v201[926].i32[1] = 0;
            else
              v201[926].i32[1] = 21 * v216[v215];
            v14 = silk_encode_frame_FLP((uint64_t)&v201[630].i64[1], (uint64_t)v300);
            v199 = v10[1];
            v57.i64[0] = 0x100000001;
            v57.i64[1] = 0x100000001;
          }
          _X9 = &v201[2882].i32[1];
          v201[922].i32[1] = 0;
          v201[990].i32[1] = 0;
          __asm { PRFM            #0, [X9] }
          ++v201[990].i32[3];
          v201 = (int16x8_t *)((char *)v201 + 10088);
        }
      }
    }
    v52 = (uint64_t)v312;
    v218 = v312[360].i32[1];
    v24[21] = v312[1264].i8[v218 + 3];
    v219 = v294;
    if (*v300 >= 1 && (_DWORD)v218 == *(_DWORD *)(v52 + 5760))
    {
      if (v199 < 1)
      {
        v221 = 0;
        v223 = v319;
      }
      else
      {
        v220 = 0;
        v221 = 0;
        v222 = v287;
        v223 = v319;
        do
        {
          v224 = v52 + 10088 * v220;
          v225 = *(unsigned int *)(v224 + 5760);
          if ((int)v225 >= 1)
          {
            v226 = v222;
            do
            {
              v227 = *v226++;
              v221 = v227 | (2 * v221);
              --v225;
            }
            while (v225);
          }
          v221 = *(char *)(v224 + 4739) | (2 * v221);
          ++v220;
          v222 += 10088;
        }
        while (v220 != v199);
      }
      if (!a7)
      {
        v228 = v199 + v199 * v218;
        v229 = 8 - v228;
        v230 = ~(-1 << v228) << (8 - v228);
        if (*((_DWORD *)v223 + 7))
        {
          *(_BYTE *)*v223 = *(_BYTE *)*v223 & ~(_BYTE)v230 | ((_BYTE)v221 << v229);
        }
        else
        {
          v232 = *((_DWORD *)v223 + 11);
          if (v232 < 0)
          {
            if (*((_DWORD *)v223 + 8) <= 0x80000000 >> v228)
              *((_DWORD *)v223 + 9) = *((_DWORD *)v223 + 9) & ~(v230 << 23) | (v221 << ~v228);
            else
              *((_DWORD *)v223 + 12) = -1;
          }
          else
          {
            *((_DWORD *)v223 + 11) = v232 & ~v230 | (v221 << v229);
          }
        }
      }
      if (*(_DWORD *)v286 && (v10[1] == 1 || *(_DWORD *)v271))
        *v300 = 0;
      v59 = v10[6];
      v60 = -274877907 * v59 * v10[7];
      v61 = v24[15] + 8 * *v300 + (v60 >> 38) + ((unint64_t)v60 >> 63);
      v62 = v61 & ~(v61 >> 31);
      if (v62 >= 10000)
        v62 = 10000;
      v24[15] = v62;
      v63 = v24[19];
      v64 = *(_DWORD *)(v52 + 4532) < (int)(((unint64_t)(3188 * (__int16)v63) >> 16) + 13);
      v65 = v63 + v59;
      if (v64)
        v65 = 0;
      v24[19] = v65;
      v24[20] = v64;
    }
    v58 = &v296[v290 * (int)v292];
    ++v54;
    v20 = v219 - v292;
  }
  while (v20);
  v249 = v24[20];
  v246 = v10[1];
  v24[18] = v246;
  v10[19] = v249;
  v247 = *(_DWORD *)(v52 + 4576);
  if (v247 == 16)
  {
LABEL_283:
    v248 = *(_DWORD *)(v52 + 28) == 0;
    goto LABEL_286;
  }
LABEL_285:
  v248 = 0;
LABEL_286:
  v250 = v261;
  v10[20] = v248;
  v10[18] = 1000 * (__int16)v247;
  if (v10[15])
  {
    v10[21] = 0;
    if (!a7)
      goto LABEL_299;
  }
  else
  {
    v10[21] = *((__int16 *)v24 + 14);
    if (!a7)
      goto LABEL_299;
  }
  v10[6] = v262;
  v10[9] = v250;
  if ((int)v246 < 1)
    goto LABEL_299;
  if ((_DWORD)v246 == 1)
  {
    v251 = 0;
    goto LABEL_297;
  }
  v251 = v246 & 0xFFFFFFFE;
  v252 = v251;
  v253 = (_DWORD *)v52;
  do
  {
    v253[1167] = 0;
    v253[3689] = 0;
    v253[1170] = 0;
    v253[3692] = 0;
    v253 += 5044;
    v252 -= 2;
  }
  while (v252);
  if (v251 != v246)
  {
LABEL_297:
    v254 = v246 - v251;
    v255 = (_DWORD *)(v52 + 10088 * v251 + 4680);
    do
    {
      *(v255 - 3) = 0;
      *v255 = 0;
      v255 += 2522;
      --v254;
    }
    while (v254);
  }
LABEL_299:
  v256 = v287;
  v257 = v287[45];
  v10[23] = v257;
  v10[24] = silk_Quantization_Offsets_Q10[2 * (v257 >> 1) + v256[46]];
  return v14;
}

uint64_t silk_encode_frame_FLP(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  __int128 *v6;
  int *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int8x16_t v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  float v24;
  uint64_t v25;
  int v26;
  char *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  char v39;
  unsigned int v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int8x16_t v45;
  int16x8_t v46;
  int8x16_t v47;
  int16x8_t v48;
  int32x4_t v49;
  float *v50;
  int8x16_t v51;
  int8x16_t v52;
  int8x16_t v53;
  int8x16_t v54;
  uint64_t v55;
  int32x4_t *v56;
  float32x4_t *v57;
  float32x4_t v58;
  uint64_t v59;
  float32x4_t v60;
  uint64_t v61;
  uint64_t v62;
  float *v63;
  int *v64;
  int v65;
  uint64_t v66;
  int v67;
  char *v68;
  int v69;
  __int128 v70;
  _DWORD *v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  __int128 v78;
  BOOL v79;
  int v80;
  int v81;
  char v82;
  size_t v83;
  size_t v84;
  unsigned int v85;
  int v86;
  int v87;
  unsigned int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int8x16_t *v98;
  int v99;
  uint64_t v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  uint32x4_t v104;
  int8x16_t *v105;
  uint32x4_t v106;
  uint64_t v107;
  uint32x4_t v108;
  uint32x4_t v109;
  uint32x4_t v110;
  uint32x4_t v111;
  uint32x4_t v112;
  uint32x4_t v113;
  uint8x16_t v114;
  uint8x16_t v115;
  uint16x8_t v116;
  uint16x8_t v117;
  uint16x8_t v118;
  uint16x8_t v119;
  uint32x4_t v120;
  uint32x4_t v121;
  uint64_t v122;
  int8x8_t *v123;
  int8x8_t v124;
  uint16x8_t v125;
  char *v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  uint64_t v134;
  unsigned int v135;
  int v136;
  int v137;
  unsigned int v138;
  int v139;
  unsigned int v140;
  _DWORD *v141;
  __int16 *v142;
  int *v143;
  int *v144;
  uint64_t v145;
  int v146;
  unint64_t v147;
  int v148;
  __int16 v149;
  uint64_t v150;
  char *v151;
  uint64_t v152;
  int v153;
  uint64_t v154;
  uint64_t v155;
  float32x4_t *v156;
  int32x4_t *v157;
  float32x4_t v158;
  uint64_t v159;
  uint64_t v160;
  float *v161;
  int *v162;
  int v163;
  _BOOL4 v165;
  void *v166;
  char v167;
  void *__dst;
  int *v169;
  char v170;
  int v171;
  __int16 v172;
  int v173;
  __int128 *v174;
  unsigned int __n;
  float32x4_t v176;
  float *v177;
  int v178;
  int v179;
  char v180;
  int v181;
  _BYTE *__b;
  __int128 *v183;
  unsigned int v184;
  char *v185;
  char *v186;
  int v187;
  void *v188;
  int v189;
  int v190;
  int v191;
  _OWORD v192[272];
  float32x4_t v193;
  _OWORD v194[13];
  _OWORD v195[29];
  float v196;
  uint64_t v197;
  char v198;
  _DWORD v199[1092];
  _WORD v200[4];
  _QWORD v201[2];
  _BYTE v202[16];
  int v203;
  _BYTE v204[16];
  __int128 v205;
  uint64_t v206;
  _OWORD v207[2];
  __int128 v208;
  __int128 v209;
  __int128 v210;
  uint64_t v211;
  float v212[672];
  uint64_t v213;

  v2 = MEMORY[0x24BDAC7A8](a1, a2);
  v173 = v3;
  v189 = v4;
  v178 = v5;
  v183 = v6;
  v169 = v7;
  v8 = v2;
  v213 = *MEMORY[0x24BDAC8D0];
  memset(v207, 0, 28);
  v206 = 0;
  v205 = 0uLL;
  memset(v192, 0, 512);
  v201[1] = 0;
  v201[0] = 0;
  v9 = *(_DWORD *)(v2 + 4620);
  *(_DWORD *)(v2 + 4620) = v9 + 1;
  v10 = *(int *)(v2 + 4592);
  __dst = (void *)(v2 + 7204);
  v177 = (float *)(v2 + 7204 + v10 * 4);
  v185 = (char *)(v2 + 4540);
  *(_BYTE *)(v2 + 4786) = v9 & 3;
  v11 = v2 + 5114;
  silk_LP_variable_cutoff((int *)(v2 + 16), (__int16 *)(v8 + 5114), *(unsigned int *)(v8 + 4584));
  v13 = 5 * *(int *)(v8 + 4576);
  v14 = *(unsigned int *)(v8 + 4584);
  if ((int)v14 >= 1)
  {
    v15 = &v177[5 * *(int *)(v8 + 4576)];
    v16 = *(unsigned int *)(v8 + 4584);
    if (v14 < 0x10)
      goto LABEL_3;
    v42 = v14 - 1;
    v16 = *(unsigned int *)(v8 + 4584);
    if ((unint64_t)(v14 - 1) >> 32)
      goto LABEL_3;
    v16 = v14 & 0xF;
    v43 = v14 & 0xFFFFFFF0;
    do
    {
      v44 = v11 + 2 * v42;
      v45 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(v44 - 14));
      v46 = (int16x8_t)vextq_s8(v45, v45, 8uLL);
      v47 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(v44 - 30));
      v48 = (int16x8_t)vextq_s8(v47, v47, 8uLL);
      v49 = (int32x4_t)vcvtq_f32_s32(vmovl_high_s16(v46));
      v50 = &v15[v42];
      v51 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v46.i8)));
      v52 = (int8x16_t)vrev64q_s32(v49);
      *(int8x16_t *)(v50 - 7) = vextq_s8(v52, v52, 8uLL);
      *(int8x16_t *)(v50 - 3) = vextq_s8(v51, v51, 8uLL);
      v53 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v48.i8)));
      v12 = vextq_s8(v53, v53, 8uLL);
      v54 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_high_s16(v48)));
      *(int8x16_t *)(v50 - 15) = vextq_s8(v54, v54, 8uLL);
      *(int8x16_t *)(v50 - 11) = v12;
      v42 -= 16;
      v43 -= 16;
    }
    while (v43);
    if ((v14 & 0x7FFFFFF0) != v14)
    {
LABEL_3:
      v17 = v16 + 1;
      do
      {
        v12.i16[0] = *(_WORD *)(v11 + 2 * (v17 - 2));
        v12.i64[0] = vmovl_s16(*(int16x4_t *)v12.i8).u64[0];
        *(float *)v12.i32 = (float)v12.i32[0];
        v15[(v17-- - 2)] = *(float *)v12.i32;
      }
      while (v17 > 1);
    }
  }
  v18 = v14;
  v19 = (int)v14 >> 3;
  v177[v13] = v177[v13] + 0.000001;
  v20 = (uint64_t)v18 >> 3;
  v177[v20 + v13] = v177[v20 + v13] + 0.000001;
  v21 = v13 + 2 * v19;
  v177[v21] = v177[v21] + -0.000001;
  v177[v21 + v20] = v177[v21 + v20] + -0.000001;
  v22 = v13 + 4 * v19;
  v177[v22] = v177[v22] + 0.000001;
  v23 = v22 + v20;
  v24 = v177[v23] + 0.000001;
  memset(v195, 0, 288);
  memset(&v194[1], 0, 192);
  v177[v23] = v24;
  v194[0] = 0u;
  v193 = 0u;
  v177[6 * v19 + v13] = v177[6 * v19 + v13] + -0.000001;
  v25 = v13 - v20 + 8 * v19;
  v177[v25] = v177[v25] + -0.000001;
  if (!*(_DWORD *)(v8 + 4680))
  {
    v186 = (char *)(v8 + 7192);
    v27 = (char *)(v8 + 4752);
    silk_find_pitch_lags_FLP(v8, (uint64_t)&v193, v212, (uint64_t)v177);
    silk_noise_shape_analysis_FLP((int *)v8, v193.f32, (uint64_t)&v212[v10], (uint64_t)v177);
    silk_find_pred_coefs_FLP(v8, (uint64_t)&v193, &v212[v10], (uint64_t)v177, v178);
    silk_process_gains_FLP(v8, &v193, v178);
    if (!*(_DWORD *)(v8 + 6112) || *(int *)(v8 + 4532) < 78)
    {
LABEL_41:
      v66 = *(unsigned int *)(v8 + 4580);
      if ((int)v66 < 1)
      {
        v67 = 0;
      }
      else
      {
        v67 = 0;
        v68 = (char *)(v8 + 4752);
        do
        {
          v69 = *v68++;
          v67 = v69 + (v67 << 8);
          --v66;
        }
        while (v66);
      }
      v70 = v183[1];
      v208 = *v183;
      v209 = v70;
      v210 = v183[2];
      v211 = *((_QWORD *)v183 + 6);
      v174 = v183 + 2;
      memcpy(v199, (const void *)(v8 + 148), 0x1100uLL);
      v71 = (_DWORD *)(v8 + 148);
      __n = 0;
      v72 = 0;
      v187 = 0;
      v184 = 0;
      v73 = 0;
      v179 = 0;
      v191 = 0;
      v167 = v185[246];
      v172 = *(_WORD *)(v8 + 5788);
      v170 = 0;
      v171 = *(_DWORD *)(v8 + 5784);
      v74 = v8 + 4788;
      v180 = 0;
      LOWORD(v75) = 256;
      v190 = -1;
      v176 = (float32x4_t)vdupq_n_s32(0x37800000u);
      v181 = -1;
      __b = (_BYTE *)(v8 + 4752);
      v188 = (void *)(v8 + 4788);
      while (1)
      {
        if (v67 == v190)
        {
          v76 = v73;
          v77 = v184;
          if (v72 == 6)
            goto LABEL_160;
        }
        else if (v67 == v181)
        {
          v76 = v73;
          v77 = v73;
          if (v72 == 6)
            goto LABEL_160;
        }
        else
        {
          v76 = v73;
          if (v72)
          {
            v78 = v209;
            *v183 = v208;
            v183[1] = v78;
            v183[2] = v210;
            *((_QWORD *)v183 + 6) = v211;
            memcpy(v71, v199, 0x1100uLL);
            v74 = v8 + 4788;
            v71 = (_DWORD *)(v8 + 148);
            v185[246] = v167;
            *(_WORD *)(v8 + 5788) = v172;
            *(_DWORD *)(v8 + 5784) = v171;
          }
          silk_NSQ_wrapper_FLP((_DWORD *)v8, (uint64_t)&v193, v27, v71, v74, v177);
          v79 = v72 == 6 && v187 == 0;
          v80 = v79;
          if (v79)
          {
            v207[0] = *v183;
            *(_OWORD *)((char *)v207 + 12) = *(__int128 *)((char *)v183 + 12);
            __n = *((_DWORD *)v183 + 7);
            v205 = *v174;
            v206 = *((_QWORD *)v183 + 6);
          }
          silk_encode_indices(v8, (uint64_t *)v183, *(_DWORD *)(v8 + 5764), 0, v178);
          silk_encode_pulses((uint64_t *)v183, v185[241], v185[242], (uint64_t)v188, *(_DWORD *)(v8 + 4584));
          v77 = *((_DWORD *)v183 + 6) + __clz(*((_DWORD *)v183 + 8)) - 32;
          if ((int)v77 > v189)
            v81 = v80;
          else
            v81 = 0;
          if (v81 == 1)
          {
            *v183 = v207[0];
            *(__int128 *)((char *)v183 + 12) = *(_OWORD *)((char *)v207 + 12);
            *((_DWORD *)v183 + 7) = __n;
            *v174 = v205;
            *((_QWORD *)v183 + 6) = v206;
            v82 = v198;
            *v186 = v198;
            v83 = *(unsigned int *)(v8 + 4580);
            if ((int)v83 >= 1)
              memset(__b, 4, v83);
            if (v178 != 2)
              *__b = v82;
            *(_WORD *)(v8 + 5788) = v172;
            *(_DWORD *)(v8 + 5784) = v171;
            v84 = *(unsigned int *)(v8 + 4584);
            if ((int)v84 >= 1)
              bzero(v188, v84);
            silk_encode_indices(v8, (uint64_t *)v183, *(_DWORD *)(v8 + 5764), 0, v178);
            silk_encode_pulses((uint64_t *)v183, v185[241], v185[242], (uint64_t)v188, *(_DWORD *)(v8 + 4584));
            v77 = *((_DWORD *)v183 + 6) + __clz(*((_DWORD *)v183 + 8)) - 32;
          }
          v71 = (_DWORD *)(v8 + 148);
          if (v72 | v173)
          {
            v74 = v8 + 4788;
            if (v72 == 6)
              goto LABEL_160;
          }
          else
          {
            v74 = v8 + 4788;
            if ((int)v77 <= v189)
              goto LABEL_6;
            if (v72 == 6)
            {
LABEL_160:
              v165 = v67 == v190 || (int)v77 > v189;
              if (v187 && v165)
              {
                *v183 = v207[0];
                *(__int128 *)((char *)v183 + 12) = *(_OWORD *)((char *)v207 + 12);
                *((_DWORD *)v183 + 7) = __n;
                v183[2] = v205;
                *((_QWORD *)v183 + 6) = v206;
                v166 = v71;
                memcpy(*(void **)v183, v202, __n);
                memcpy(v166, v192, 0x1100uLL);
                *v186 = v170;
              }
              goto LABEL_6;
            }
          }
        }
        if ((int)v77 <= v189)
        {
          if ((int)v77 >= v189 - 5)
            goto LABEL_6;
          if (v67 != v190)
          {
            v207[0] = *v183;
            *(_OWORD *)((char *)v207 + 12) = *(__int128 *)((char *)v183 + 12);
            v85 = *((_DWORD *)v183 + 7);
            v205 = *v174;
            v206 = *((_QWORD *)v183 + 6);
            __n = v85;
            __memcpy_chk();
            memcpy(v192, (const void *)(v8 + 148), sizeof(v192));
            v170 = *v186;
          }
          v86 = (__int16)v75;
          if ((v180 & 1) == 0)
          {
            v87 = (((int)v77 - v189) << 7) / *(_DWORD *)(v8 + 4584);
            v179 = (__int16)v75;
            if (v87 >= -2048)
            {
              if ((v87 + 2048) <= 0xF7E)
              {
                v135 = (v87 + 2048) >> 7;
                v136 = 1 << v135;
                v137 = (v87 & 0x7F) + ((-174 * (v87 & 0x7F) * (128 - (v87 & 0x7F))) >> 16);
                v138 = v137 * ((1 << v135) >> 7);
                v139 = v137 << v135 >> 7;
                if (v87 >= 0xFFFFF800)
                  v140 = v139;
                else
                  v140 = v138;
                v88 = v140 + v136;
              }
              else
              {
                v88 = 0x7FFFFFFF;
              }
            }
            else
            {
              v88 = 0;
            }
            v73 = v76;
            v75 = ((unint64_t)v88 * (__int16)v75) >> 16;
            v187 = 1;
            v184 = v77;
            v190 = v67;
LABEL_140:
            v27 = (char *)(v8 + 4752);
            v129 = v191;
            v134 = *(unsigned int *)(v8 + 4580);
            if ((int)v134 < 1)
              goto LABEL_149;
LABEL_141:
            v141 = v204;
            v142 = v200;
            v143 = (int *)v201;
            v144 = (int *)&v197;
            v145 = v134;
            do
            {
              v148 = *v143++;
              v149 = v75;
              if (v148)
                v149 = *v142;
              v146 = *v144++;
              v147 = (unint64_t)(v146 * (uint64_t)v149) >> 16;
              if ((int)v147 <= -8388608)
                LODWORD(v147) = -8388608;
              if ((int)v147 >= 0x7FFFFF)
                LODWORD(v147) = 0x7FFFFF;
              *v141++ = (_DWORD)v147 << 8;
              ++v142;
              --v145;
            }
            while (v145);
            goto LABEL_149;
          }
          v190 = v67;
          v73 = v76;
        }
        else
        {
          if (!v187 && v72 >= 2)
          {
            v180 = 0;
            v196 = fmaxf(v196 * 1.5, 1.5);
            v185[242] = 0;
            v67 = -1;
            v77 = v76;
LABEL_92:
            v89 = *(unsigned int *)(v8 + 4580);
            if ((int)v89 >= 1)
            {
              v90 = 0;
              v91 = 0;
              v92 = *(_DWORD *)(v8 + 4588);
              v93 = (v92 - 1);
              v94 = v93 + 1;
              v95 = (v93 + 1) & 0x1FFFFFFE0;
              v96 = (v93 + 1) & 0x1FFFFFFF8;
              v97 = v74;
              v98 = (int8x16_t *)(v185 + 264);
              v99 = v92;
              do
              {
                v100 = v90 + 1;
                if (v90 * v92 >= (v90 + 1) * v92)
                {
                  v101 = 0;
                }
                else
                {
                  if (v93 < 7)
                  {
                    v101 = 0;
                    v102 = v91;
                    goto LABEL_112;
                  }
                  if (v93 >= 0x1F)
                  {
                    v104 = 0uLL;
                    v105 = v98;
                    v106 = 0uLL;
                    v107 = (v93 + 1) & 0x1FFFFFFE0;
                    v108 = 0uLL;
                    v109 = 0uLL;
                    v110 = 0uLL;
                    v111 = 0uLL;
                    v112 = 0uLL;
                    v113 = 0uLL;
                    do
                    {
                      v114 = (uint8x16_t)vabsq_s8(v105[-1]);
                      v115 = (uint8x16_t)vabsq_s8(*v105);
                      v116 = vmovl_u8(*(uint8x8_t *)v114.i8);
                      v117 = vmovl_high_u8(v114);
                      v118 = vmovl_u8(*(uint8x8_t *)v115.i8);
                      v119 = vmovl_high_u8(v115);
                      v109 = vaddw_high_u16(v109, v117);
                      v108 = vaddw_u16(v108, *(uint16x4_t *)v117.i8);
                      v106 = vaddw_high_u16(v106, v116);
                      v104 = vaddw_u16(v104, *(uint16x4_t *)v116.i8);
                      v113 = vaddw_high_u16(v113, v119);
                      v112 = vaddw_u16(v112, *(uint16x4_t *)v119.i8);
                      v111 = vaddw_high_u16(v111, v118);
                      v110 = vaddw_u16(v110, *(uint16x4_t *)v118.i8);
                      v105 += 2;
                      v107 -= 32;
                    }
                    while (v107);
                    v101 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)v110, (int32x4_t)v104), vaddq_s32((int32x4_t)v112, (int32x4_t)v108)), vaddq_s32(vaddq_s32((int32x4_t)v111, (int32x4_t)v106), vaddq_s32((int32x4_t)v113, (int32x4_t)v109))));
                    if (v94 == v95)
                      goto LABEL_116;
                    if (((v93 + 1) & 0x18) == 0)
                    {
                      v102 = v91 + v95;
LABEL_112:
                      v126 = (char *)(v74 + v102);
                      do
                      {
                        v128 = *v126++;
                        v127 = v128;
                        if (v128 < 0)
                          v127 = -v127;
                        v101 += v127;
                        LODWORD(v102) = v102 + 1;
                      }
                      while (v99 != (_DWORD)v102);
                      goto LABEL_116;
                    }
                    v103 = (v93 + 1) & 0x1FFFFFFE0;
                  }
                  else
                  {
                    v101 = 0;
                    v103 = 0;
                  }
                  v102 = v91 + v96;
                  v120 = 0uLL;
                  v121 = (uint32x4_t)v101;
                  v122 = v103 - v96;
                  v123 = (int8x8_t *)(v97 + v103);
                  do
                  {
                    v124 = *v123++;
                    v125 = vmovl_u8((uint8x8_t)vabs_s8(v124));
                    v120 = vaddw_high_u16(v120, v125);
                    v121 = vaddw_u16(v121, *(uint16x4_t *)v125.i8);
                    v122 += 8;
                  }
                  while (v122);
                  v101 = vaddvq_s32(vaddq_s32((int32x4_t)v121, (int32x4_t)v120));
                  if (v94 != v96)
                    goto LABEL_112;
                }
LABEL_116:
                if (v72 && (v101 >= v199[v90 + 1088] || *((_DWORD *)v201 + v90)))
                {
                  *((_DWORD *)v201 + v90) = 1;
                }
                else
                {
                  v199[v90 + 1088] = v101;
                  v200[v90] = v75;
                }
                v91 += v92;
                v99 += v92;
                v98 = (int8x16_t *)((char *)v98 + v92);
                v97 += v92;
                ++v90;
              }
              while (v100 != v89);
            }
            if ((__int16)v75 >= 0x4000)
              LOWORD(v75) = 0x7FFF;
            else
              LOWORD(v75) = 2 * v75;
            v73 = v77;
            v181 = v67;
            goto LABEL_140;
          }
          v191 = (__int16)v75;
          v180 = 1;
          if (!v187)
            goto LABEL_92;
          v73 = v77;
          v181 = v67;
          v86 = v179;
          LODWORD(v77) = v184;
        }
        v129 = v191;
        v184 = v77;
        v130 = (v191 - v86) * (v189 - (int)v77) / ((int)v73 - (int)v77) + v86;
        v131 = (__int16)((v191 - v86) * (v189 - (int)v77) / ((int)v73 - (int)v77) + v86);
        v132 = (v191 - v86) >> 2;
        v179 = v86;
        LOWORD(v75) = v132 + v86;
        v27 = (char *)(v8 + 4752);
        if (v131 <= v132 + v86)
        {
          v133 = v191 - v132;
          if (v131 >= v133)
            LOWORD(v75) = v130;
          else
            LOWORD(v75) = v133;
        }
        v187 = 1;
        v134 = *(unsigned int *)(v8 + 4580);
        if ((int)v134 >= 1)
          goto LABEL_141;
LABEL_149:
        v191 = v129;
        *v186 = v198;
        silk_gains_quant((uint64_t)v27, (uint64_t)v204, v186, v178 == 2, v134);
        v150 = *(unsigned int *)(v8 + 4580);
        if ((int)v150 < 1)
        {
          v67 = 0;
          v74 = v8 + 4788;
          goto LABEL_48;
        }
        v67 = 0;
        v151 = v27;
        v152 = *(unsigned int *)(v8 + 4580);
        v74 = v8 + 4788;
        do
        {
          v153 = *v151++;
          v67 = v153 + (v67 << 8);
          --v152;
        }
        while (v152);
        if (v150 < 8)
        {
          v154 = 0;
LABEL_157:
          v159 = v150 - v154;
          v160 = 4 * v154;
          v161 = &v193.f32[v154];
          v162 = (int *)&v204[v160];
          do
          {
            v163 = *v162++;
            *v161++ = (float)v163 * 0.000015259;
            --v159;
          }
          while (v159);
          goto LABEL_48;
        }
        v154 = v150 & 0x7FFFFFF8;
        v155 = v150 & 0xFFFFFFF8;
        v156 = (float32x4_t *)v194;
        v157 = (int32x4_t *)&v205;
        do
        {
          v158 = vmulq_f32(vcvtq_f32_s32(*v157), v176);
          v156[-1] = vmulq_f32(vcvtq_f32_s32(v157[-1]), v176);
          *v156 = v158;
          v157 += 2;
          v156 += 2;
          v155 -= 8;
        }
        while (v155);
        if (v154 != v150)
          goto LABEL_157;
LABEL_48:
        ++v72;
        v71 = (_DWORD *)(v8 + 148);
      }
    }
    v28 = *(int *)(v8 + 5764);
    v29 = (char *)(v8 + 36 * (int)v28 + 6120);
    *(_DWORD *)(v8 + 4 * v28 + 4740) = 1;
    memcpy(v199, (const void *)(v8 + 148), 0x1100uLL);
    v31 = *(_OWORD *)v27;
    v30 = *(_OWORD *)(v8 + 4768);
    *((_DWORD *)v29 + 8) = *(_DWORD *)(v8 + 4784);
    *(_OWORD *)v29 = v31;
    *((_OWORD *)v29 + 1) = v30;
    v32 = *(unsigned int *)(v8 + 4580);
    __memcpy_chk();
    v33 = *(int *)(v8 + 5764);
    if (!(_DWORD)v33 || !*(_DWORD *)(v8 + 4 * v33 + 4736))
    {
      *v185 = *v186;
      v34 = (char)(*v29 + *(_BYTE *)(v8 + 6116));
      if (v34 >= 63)
        LOBYTE(v34) = 63;
      *v29 = v34;
    }
    if ((int)v32 >= 1)
    {
      v35 = 0;
      LOBYTE(v36) = *v185;
      do
      {
        if (v35 | (v178 == 2))
        {
          v37 = v29[v35] - 4;
          v38 = (char)v36 + 8;
          v39 = v36 + v37;
          LOBYTE(v36) = 2 * v37 - 8;
          if (v37 <= v38)
            LOBYTE(v36) = v39;
        }
        else
        {
          v36 = (char)v36 - 16;
          if (*v29 > v36)
            LOBYTE(v36) = *v29;
        }
        v36 = (char)v36 & ~((char)v36 >> 31);
        if (v36 >= 63)
          v36 = 63;
        *v185 = v36;
        v40 = ((1907825 * v36) >> 16) + 2090;
        *(_DWORD *)&v202[4 * v35++] = (1 << (v40 >> 7))
                                    + ((v40 & 0x7F) + ((int)(-174 * (v40 & 0x7F) * (128 - (v40 & 0x7F))) >> 16))
                                    * ((1 << (v40 >> 7)) >> 7);
      }
      while (v32 != v35);
      if (v32 >= 8)
      {
        v55 = v32 & 0x7FFFFFF8;
        v56 = (int32x4_t *)&v203;
        v57 = (float32x4_t *)v194;
        v58 = (float32x4_t)vdupq_n_s32(0x37800000u);
        v59 = v32 & 0xFFFFFFF8;
        do
        {
          v60 = vmulq_f32(vcvtq_f32_s32(*v56), v58);
          v57[-1] = vmulq_f32(vcvtq_f32_s32(v56[-1]), v58);
          *v57 = v60;
          v56 += 2;
          v57 += 2;
          v59 -= 8;
        }
        while (v59);
        if (v55 == v32)
          goto LABEL_40;
      }
      else
      {
        v55 = 0;
      }
      v61 = v32 - v55;
      v62 = 4 * v55;
      v63 = &v193.f32[v55];
      v64 = (int *)&v202[v62];
      do
      {
        v65 = *v64++;
        *v63++ = (float)v65 * 0.000015259;
        --v61;
      }
      while (v61);
    }
LABEL_40:
    silk_NSQ_wrapper_FLP((_DWORD *)v8, (uint64_t)&v193, v29, v199, v8 + 320 * (int)v33 + 6228, v177);
    __memcpy_chk();
    goto LABEL_41;
  }
LABEL_6:
  memmove(__dst, (const void *)(v8 + 4 * *(int *)(v8 + 4584) + 7204), 4 * (5 * *(_DWORD *)(v8 + 4576) + *(_DWORD *)(v8 + 4592)));
  if (*(_DWORD *)(v8 + 4680))
  {
    v26 = 0;
  }
  else
  {
    *(_DWORD *)(v8 + 4544) = *((_DWORD *)v195 + *(int *)(v8 + 4580));
    v185[1] = v185[241];
    *(_DWORD *)(v8 + 4664) = 0;
    v26 = (int)(*((_DWORD *)v183 + 6) + __clz(*((_DWORD *)v183 + 8)) - 25) >> 3;
  }
  *v169 = v26;
  return 0;
}

uint64_t *silk_encode_indices(uint64_t a1, uint64_t *a2, int a3, int a4, int a5)
{
  char *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  __int16 *v21;
  uint8x16_t *v22;
  int8x16_t v23;
  int8x16_t v24;
  unint64_t v25;
  uint8x16_t v26;
  uint8x16_t v27;
  uint8x16_t v28;
  uint8x16_t v29;
  uint8x16_t v30;
  __int16 *v31;
  __int16 *v32;
  __int16 *v33;
  __int16 *v34;
  uint8x8_t *v35;
  unint64_t v36;
  __int16 *v37;
  uint8x8_t v38;
  unsigned int v39;
  _WORD *v40;
  uint64_t v41;
  char *v42;
  int v43;
  uint64_t *v44;
  char *v45;
  int v46;
  int v47;
  unsigned int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  _WORD v57[16];
  uint64_t v58;
  uint64_t v59;
  int16x8x2_t v60;
  int16x8x2_t v61;
  int16x8x2_t v62;
  int16x8x2_t v63;

  v58 = *MEMORY[0x24BDAC8D0];
  if (a4)
    v8 = (char *)(a1 + 36 * a3 + 6120);
  else
    v8 = (char *)(a1 + 4752);
  v9 = v8[30] + 2 * v8[29];
  if (a4 || v9 >= 2)
  {
    ec_enc_icdf(a2, v9 - 2, (uint64_t)silk_type_offset_VAD_iCDF, 8);
    v10 = *v8;
    if (a5 != 2)
    {
LABEL_7:
      ec_enc_icdf(a2, v10 >> 3, (uint64_t)&silk_gain_iCDF[8 * v8[29]], 8);
      ec_enc_icdf(a2, *v8 & 7, (uint64_t)silk_uniform8_iCDF, 8);
      if (*(int *)(a1 + 4580) <= 1)
        goto LABEL_13;
      goto LABEL_11;
    }
  }
  else
  {
    ec_enc_icdf(a2, v9, (uint64_t)&silk_type_offset_no_VAD_iCDF, 8);
    v10 = *v8;
    if (a5 != 2)
      goto LABEL_7;
  }
  ec_enc_icdf(a2, v10, (uint64_t)silk_delta_gain_iCDF, 8);
  if (*(int *)(a1 + 4580) <= 1)
    goto LABEL_13;
LABEL_11:
  v11 = 1;
  do
    ec_enc_icdf(a2, v8[v11++], (uint64_t)silk_delta_gain_iCDF, 8);
  while (v11 < *(int *)(a1 + 4580));
LABEL_13:
  ec_enc_icdf(a2, v8[8], *(_QWORD *)(*(_QWORD *)(a1 + 4704) + 24) + **(__int16 **)(a1 + 4704) * (uint64_t)(v8[29] >> 1), 8);
  v12 = *(_QWORD *)(a1 + 4704);
  if (*(__int16 *)(v12 + 2) >= 1)
  {
    v13 = *(unsigned __int16 *)(v12 + 2);
    v14 = *(unsigned __int16 *)(v12 + 2);
    v15 = *(_QWORD *)(v12 + 40);
    v16 = (uint64_t)(int)(v8[8] * v14 + (((v8[8] * v14) & 0x80000000) != 0)) >> 1;
    v17 = (unsigned __int8 *)(v15 + v16);
    if (v14 < 0xF)
    {
      v18 = 0;
      goto LABEL_27;
    }
    v19 = ((v13 - 1) >> 1) + 1;
    if (v14 >= 0x3F)
    {
      v20 = v19 & 0xFFFFFFFFFFFFFFE0;
      v21 = (__int16 *)&v59;
      v22 = (uint8x16_t *)(v16 + v15 + 16);
      v23.i64[0] = 0x707070707070707;
      v23.i64[1] = 0x707070707070707;
      v24.i64[0] = 0x909090909090909;
      v24.i64[1] = 0x909090909090909;
      v25 = v19 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v26 = v22[-1];
        v27 = (uint8x16_t)vmulq_s8(vandq_s8((int8x16_t)vshrq_n_u8(v26, 1uLL), v23), v24);
        v28 = (uint8x16_t)vmulq_s8(vandq_s8((int8x16_t)vshrq_n_u8(*v22, 1uLL), v23), v24);
        v62.val[0] = (int16x8_t)vmovl_high_u8(v27);
        v29 = (uint8x16_t)vmulq_s8((int8x16_t)vshrq_n_u8(v26, 5uLL), v24);
        v62.val[1] = (int16x8_t)vmovl_high_u8(v29);
        v63.val[0] = (int16x8_t)vmovl_u8(*(uint8x8_t *)v27.i8);
        v63.val[1] = (int16x8_t)vmovl_u8(*(uint8x8_t *)v29.i8);
        v30 = (uint8x16_t)vmulq_s8((int8x16_t)vshrq_n_u8(*v22, 5uLL), v24);
        v60.val[0] = (int16x8_t)vmovl_u8(*(uint8x8_t *)v28.i8);
        v31 = v21 - 32;
        vst2q_s16(v31, v63);
        v60.val[1] = (int16x8_t)vmovl_u8(*(uint8x8_t *)v30.i8);
        v32 = v21 - 16;
        vst2q_s16(v32, v62);
        v33 = v21 + 64;
        vst2q_s16(v21, v60);
        v34 = v21 + 16;
        v60.val[0] = (int16x8_t)vmovl_high_u8(v28);
        v60.val[1] = (int16x8_t)vmovl_high_u8(v30);
        vst2q_s16(v34, v60);
        v22 += 2;
        v21 = v33;
        v25 -= 32;
      }
      while (v25);
      if (v19 == v20)
        goto LABEL_28;
      if ((v19 & 0x18) == 0)
      {
        v17 += v20;
        v18 = 2 * v20;
        do
        {
LABEL_27:
          v39 = *v17++;
          v40 = &v57[v18];
          *v40 = (v39 >> 1) & 7 | (8 * ((v39 >> 1) & 7));
          v40[1] = (v39 >> 5) | (8 * (v39 >> 5));
          v18 += 2;
        }
        while (v18 < v13);
LABEL_28:
        v41 = 0;
        v42 = v8 + 9;
        while (1)
        {
          v46 = v42[v41];
          if (v46 >= 4)
          {
            ec_enc_icdf(a2, 8, *(_QWORD *)(v12 + 48) + (__int16)v57[v41], 8);
            v43 = v42[v41] - 4;
          }
          else
          {
            if (v46 > -4)
            {
              v43 = v46 + 4;
              v45 = (char *)(*(_QWORD *)(v12 + 48) + (__int16)v57[v41]);
              v44 = a2;
              goto LABEL_31;
            }
            ec_enc_icdf(a2, 0, *(_QWORD *)(v12 + 48) + (__int16)v57[v41], 8);
            v43 = -4 - v42[v41];
          }
          v44 = a2;
          v45 = silk_NLSF_EXT_iCDF;
LABEL_31:
          ec_enc_icdf(v44, v43, (uint64_t)v45, 8);
          ++v41;
          v12 = *(_QWORD *)(a1 + 4704);
          if (v41 >= *(__int16 *)(v12 + 2))
            goto LABEL_36;
        }
      }
    }
    else
    {
      v20 = 0;
    }
    v18 = 2 * (v19 & 0xFFFFFFFFFFFFFFF8);
    v17 += v19 & 0xFFFFFFFFFFFFFFF8;
    v35 = (uint8x8_t *)(v15 + v20 + v16);
    v36 = v20 - (v19 & 0xFFFFFFFFFFFFFFF8);
    v37 = &v57[2 * v20];
    do
    {
      v38 = *v35++;
      v61.val[0] = (int16x8_t)vmovl_u8((uint8x8_t)vmul_s8(vand_s8((int8x8_t)vshr_n_u8(v38, 1uLL), (int8x8_t)0x707070707070707), (int8x8_t)0x909090909090909));
      v61.val[1] = (int16x8_t)vmovl_u8((uint8x8_t)vmul_s8((int8x8_t)vshr_n_u8(v38, 5uLL), (int8x8_t)0x909090909090909));
      vst2q_s16(v37, v61);
      v37 += 16;
      v36 += 8;
    }
    while (v36);
    if (v19 == (v19 & 0xFFFFFFFFFFFFFFF8))
      goto LABEL_28;
    goto LABEL_27;
  }
LABEL_36:
  if (*(_DWORD *)(a1 + 4580) == 4)
    ec_enc_icdf(a2, v8[31], (uint64_t)silk_NLSF_interpolation_factor_iCDF, 8);
  if (v8[29] == 2)
  {
    if (a5 != 2
      || *(_DWORD *)(a1 + 5784) != 2
      || ((v47 = *((__int16 *)v8 + 13) - *(__int16 *)(a1 + 5788), v48 = v47 - 12, v49 = v47 + 9, v48 >= 0xFFFFFFEC)
        ? (v50 = v49)
        : (v50 = 0),
          ec_enc_icdf(a2, v50, (uint64_t)silk_pitch_delta_iCDF, 8),
          v48 <= 0xFFFFFFEB))
    {
      v51 = *((__int16 *)v8 + 13);
      v52 = *(_DWORD *)(a1 + 4576);
      v53 = v51 / (v52 >> 1);
      v54 = v51 - (__int16)v53 * (__int16)(v52 >> 1);
      ec_enc_icdf(a2, v53, (uint64_t)&silk_pitch_lag_iCDF, 8);
      ec_enc_icdf(a2, v54, *(_QWORD *)(a1 + 4688), 8);
    }
    *(_WORD *)(a1 + 5788) = *((_WORD *)v8 + 13);
    ec_enc_icdf(a2, v8[28], *(_QWORD *)(a1 + 4696), 8);
    ec_enc_icdf(a2, v8[32], (uint64_t)silk_LTP_per_index_iCDF, 8);
    if (*(int *)(a1 + 4580) >= 1)
    {
      v55 = 0;
      do
        ec_enc_icdf(a2, v8[v55++ + 4], (uint64_t)*(&silk_LTP_gain_iCDF_ptrs + v8[32]), 8);
      while (v55 < *(int *)(a1 + 4580));
    }
    if (!a5)
      ec_enc_icdf(a2, v8[33], (uint64_t)silk_LTPscale_iCDF, 8);
  }
  *(_DWORD *)(a1 + 5784) = v8[29];
  return ec_enc_icdf(a2, v8[34], (uint64_t)silk_uniform4_iCDF, 8);
}

uint64_t *silk_encode_pulses(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, signed int a5)
{
  int v5;
  uint64_t v7;
  _QWORD *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int8x16_t v15;
  int8x16_t v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  float *v41;
  int8x8_t v42;
  int8x8_t v43;
  int8x8_t v44;
  float *v45;
  float *v46;
  uint64_t v47;
  float *v48;
  int8x16_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;
  int8x16_t v53;
  int8x16_t v54;
  int8x16_t v55;
  float *v56;
  float *v57;
  int8x16_t v58;
  float *v59;
  int *v60;
  char *v61;
  int v62;
  int v63;
  int v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  char *v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  uint64_t v81;
  int *v82;
  uint64_t v83;
  int v84;
  int v85;
  int v86;
  _BOOL4 v87;
  int v88;
  int v89;
  int v90;
  int v91;
  _BOOL4 v92;
  int v93;
  _BOOL4 v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  unsigned int v98;
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  unsigned int v104;
  unsigned int v105;
  uint64_t v106;
  int v107;
  unsigned int v108;
  unsigned int v109;
  uint64_t v110;
  unsigned int v111;
  int v112;
  uint64_t v113;
  int v114;
  int v115;
  uint64_t v116;
  int v117;
  int v118;
  uint64_t v119;
  int v120;
  int v121;
  int v122;
  int v123;
  unsigned int v124;
  uint64_t v125;
  char *v126;
  void *v127;
  uint64_t v128;
  int v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  _BYTE *v134;
  uint64_t v135;
  int v136;
  int v137;
  unsigned int v138;
  int v139;
  uint64_t v141;
  int v142;
  int v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  float32x4x4_t v148;
  float32x4x4_t v149;
  float32x4x4_t v150;
  float32x4x4_t v151;

  v5 = a5;
  v7 = a2;
  v147 = *MEMORY[0x24BDAC8D0];
  if ((int)(a5 & 0xFFFFFFF0) < a5)
  {
    v9 = (_QWORD *)(a4 + a5);
    *v9 = 0;
    v9[1] = 0;
  }
  v10 = (const char *)MEMORY[0x24BDAC7A8](a1, a2);
  v18 = (int *)((char *)&v141 - v17);
  v145 = v12;
  if (v13 <= 0)
  {
    MEMORY[0x24BDAC7A8](v10, v11);
    v23 = (int *)((char *)&v141 - v22);
    v25 = ((uint64_t)(int)v7 >> 1) + 8 * v24;
    v27 = (unsigned __int8 *)(v26 + v25);
    v28 = *(unsigned __int8 *)(v26 + v25);
    v29 = *(unsigned __int8 *)(v26 + v25 + 1);
    v30 = v28 > v29;
    if ((int)v29 < (int)v28)
      v28 = v29;
    v31 = v27[2];
    if (v28 > v31)
      v30 = 2;
    if ((int)v31 < (int)v28)
      v28 = v27[2];
    v32 = v27[3];
    if (v28 > v32)
      v30 = 3;
    if ((int)v32 < (int)v28)
      v28 = v27[3];
    v33 = v27[4];
    if (v28 > v33)
      v30 = 4;
    if ((int)v33 < (int)v28)
      v28 = v27[4];
    v34 = v27[5];
    if (v28 > v34)
      v30 = 5;
    if ((int)v34 < (int)v28)
      v28 = v27[5];
    v35 = v27[6];
    if (v28 > v35)
      v30 = 6;
    if ((int)v35 < (int)v28)
      v28 = v27[6];
    v36 = v27[7];
    if (v28 > v36)
      v30 = 7;
    if ((int)v36 < (int)v28)
      v28 = v27[7];
    if (v28 <= v27[8])
      v37 = v30;
    else
      v37 = 8;
    ec_enc_icdf(a1, v37, (uint64_t)&silk_rate_levels_iCDF + v25, 8);
    return silk_encode_signs(a1, v145, v5, v7, a3, v23);
  }
  v19 = v14;
  if (v14 <= 4)
    v20 = 4;
  else
    v20 = v14;
  v144 = v7;
  v142 = v5;
  if (v20 < 0x1D)
  {
    v21 = 0;
    goto LABEL_50;
  }
  v38 = ((v20 - 1) >> 2) + 1;
  if (v20 < 0x3D)
  {
    v39 = 0;
    goto LABEL_41;
  }
  v39 = v38 & 0x7FFFFFFFFFFFFFF0;
  v15.i64[1] = 0xFFFFFF07FFFFFF06;
  v47 = v38 & 0x7FFFFFFFFFFFFFF0;
  v48 = (float *)v18;
  v10 = (const char *)v12;
  do
  {
    *(int8x16x4_t *)(&v16 - 2) = vld4q_s8(v10);
    v10 += 64;
    v50 = vabsq_s8(v49);
    v149.val[0] = (float32x4_t)vqtbl1q_s8(v50, (int8x16_t)xmmword_208F04F40);
    v151.val[0] = (float32x4_t)vqtbl1q_s8(v50, (int8x16_t)xmmword_208F04F50);
    v52 = vabsq_s8(v51);
    v149.val[1] = (float32x4_t)vqtbl1q_s8(v52, (int8x16_t)xmmword_208F04F40);
    v151.val[1] = (float32x4_t)vqtbl1q_s8(v52, (int8x16_t)xmmword_208F04F50);
    v53 = vabsq_s8(v16);
    v149.val[2] = (float32x4_t)vqtbl1q_s8(v53, (int8x16_t)xmmword_208F04F40);
    v151.val[2] = (float32x4_t)vqtbl1q_s8(v53, (int8x16_t)xmmword_208F04F50);
    v55 = vabsq_s8(v54);
    v149.val[3] = (float32x4_t)vqtbl1q_s8(v55, (int8x16_t)xmmword_208F04F40);
    v151.val[3] = (float32x4_t)vqtbl1q_s8(v55, (int8x16_t)xmmword_208F04F50);
    v56 = v48;
    vst4q_f32(v56, v151);
    v56 += 16;
    vst4q_f32(v56, v149);
    v149.val[0] = (float32x4_t)vqtbl1q_s8(v50, (int8x16_t)xmmword_208F04F30);
    v149.val[1] = (float32x4_t)vqtbl1q_s8(v52, (int8x16_t)xmmword_208F04F30);
    v149.val[2] = (float32x4_t)vqtbl1q_s8(v53, (int8x16_t)xmmword_208F04F30);
    v149.val[3] = (float32x4_t)vqtbl1q_s8(v55, (int8x16_t)xmmword_208F04F30);
    v57 = v48 + 32;
    vst4q_f32(v57, v149);
    v58 = vqtbl1q_s8(v50, (int8x16_t)xmmword_208F04F20);
    v149.val[0] = (float32x4_t)vqtbl1q_s8(v52, (int8x16_t)xmmword_208F04F20);
    v149.val[1] = (float32x4_t)vqtbl1q_s8(v53, (int8x16_t)xmmword_208F04F20);
    v149.val[2] = (float32x4_t)vqtbl1q_s8(v55, (int8x16_t)xmmword_208F04F20);
    v59 = v48 + 48;
    vst4q_f32(v59, v149);
    v48 += 64;
    v47 -= 16;
  }
  while (v47);
  if (v38 == v39)
    goto LABEL_60;
  if ((v38 & 8) != 0)
  {
LABEL_41:
    v21 = 4 * (v38 & 0x7FFFFFFFFFFFFFF8);
    v10 = (const char *)(v12 + 4 * v39);
    v40 = v39 - (v38 & 0x7FFFFFFFFFFFFFF8);
    v41 = (float *)&v18[4 * v39];
    do
    {
      *(int8x8x4_t *)v15.i8 = vld4_s8(v10);
      v10 += 32;
      *(int8x8_t *)v16.i8 = vabs_s8(*(int8x8_t *)v15.i8);
      v148.val[0] = (float32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_208F04F40);
      v150.val[0] = (float32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_208F04F50);
      *(int8x8_t *)v16.i8 = vabs_s8(v42);
      v148.val[1] = (float32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_208F04F40);
      v150.val[1] = (float32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_208F04F50);
      *(int8x8_t *)v16.i8 = vabs_s8(v43);
      v148.val[2] = (float32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_208F04F40);
      v150.val[2] = (float32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_208F04F50);
      *(int8x8_t *)v15.i8 = vabs_s8(v44);
      v148.val[3] = (float32x4_t)vqtbl1q_s8(v15, (int8x16_t)xmmword_208F04F40);
      v150.val[3] = (float32x4_t)vqtbl1q_s8(v15, (int8x16_t)xmmword_208F04F50);
      v45 = v41 + 32;
      vst4q_f32(v41, v150);
      v46 = v41 + 16;
      vst4q_f32(v46, v148);
      v41 = v45;
      v40 += 8;
    }
    while (v40);
    if (v38 == (v38 & 0x7FFFFFFFFFFFFFF8))
      goto LABEL_60;
    goto LABEL_50;
  }
  v21 = 4 * v39;
LABEL_50:
  v60 = &v18[v21 + 2];
  do
  {
    v61 = (char *)(v12 + v21);
    v62 = *(char *)(v12 + v21);
    if (v62 < 0)
      v62 = -v62;
    v63 = v61[1];
    if (v63 < 0)
      v63 = -v63;
    *(v60 - 2) = v62;
    *(v60 - 1) = v63;
    v64 = v61[2];
    if (v64 < 0)
      v64 = -v64;
    v65 = v61[3];
    if (v65 < 0)
      v65 = -v65;
    *v60 = v64;
    v60[1] = v65;
    v60 += 4;
    v21 += 4;
  }
  while (v21 < v19);
LABEL_60:
  v66 = MEMORY[0x24BDAC7A8](v10, v13);
  v23 = (int *)((char *)&v141 - ((v67 + 15) & 0x7FFFFFFF0));
  MEMORY[0x24BDAC7A8](v66, v68);
  v72 = (char *)&v141 - v71;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = v18;
  v146 = v83;
  do
  {
    *(_DWORD *)&v72[4 * v81] = 0;
    v84 = 1;
    v85 = *v82;
    v86 = v82[1];
    while (1)
    {
      if (v85 + v86 <= 8)
      {
        if (v82[3] + v82[2] <= 8)
        {
          if (v82[5] + v82[4] <= 8)
          {
            if (v82[7] + v82[6] <= 8)
            {
              if (v82[9] + v82[8] <= 8)
              {
                if (v82[11] + v82[10] <= 8)
                {
                  if (v82[13] + v82[12] <= 8)
                  {
                    v88 = v82[15] + v82[14];
                    v87 = v88 > 8;
                    if (v88 <= 8)
                      v80 = v82[15] + v82[14];
                    v73 = v85 + v86;
                    v74 = v82[3] + v82[2];
                    v75 = v82[5] + v82[4];
                    v76 = v82[7] + v82[6];
                    v77 = v82[9] + v82[8];
                    v78 = v82[11] + v82[10];
                    v79 = v82[13] + v82[12];
                  }
                  else
                  {
                    v87 = 1;
                    v73 = v85 + v86;
                    v74 = v82[3] + v82[2];
                    v75 = v82[5] + v82[4];
                    v76 = v82[7] + v82[6];
                    v77 = v82[9] + v82[8];
                    v78 = v82[11] + v82[10];
                  }
                }
                else
                {
                  v87 = 1;
                  v73 = v85 + v86;
                  v74 = v82[3] + v82[2];
                  v75 = v82[5] + v82[4];
                  v76 = v82[7] + v82[6];
                  v77 = v82[9] + v82[8];
                }
              }
              else
              {
                v87 = 1;
                v73 = v85 + v86;
                v74 = v82[3] + v82[2];
                v75 = v82[5] + v82[4];
                v76 = v82[7] + v82[6];
              }
            }
            else
            {
              v87 = 1;
              v73 = v85 + v86;
              v74 = v82[3] + v82[2];
              v75 = v82[5] + v82[4];
            }
          }
          else
          {
            v87 = 1;
            v73 = v85 + v86;
            v74 = v82[3] + v82[2];
          }
        }
        else
        {
          v87 = 1;
          v73 = v85 + v86;
        }
      }
      else
      {
        v87 = 1;
      }
      v89 = v76 + v75;
      v90 = v78 + v77;
      v91 = v80 + v79;
      v92 = v80 + v79 > 10;
      if (v80 + v79 > 10)
        v91 = v76;
      if (v90 > 10)
      {
        v90 = v75;
        v91 = v76;
        v92 = 1;
      }
      if (v89 > 10)
      {
        v89 = v74;
        v90 = v75;
        v91 = v76;
        v92 = 1;
      }
      if (v74 + v73 > 10)
      {
        v93 = 1;
      }
      else
      {
        v73 += v74;
        v74 = v89;
        v75 = v90;
        v76 = v91;
        v93 = v92;
      }
      v94 = v74 + v73 > 12;
      if (v74 + v73 <= 12)
        v73 += v74;
      v95 = v76 + v75 > 12 || v94;
      if (!v95)
        v74 = v76 + v75;
      if (v74 + v73 <= 16)
      {
        v23[v81] = v74 + v73;
        if (v93 + v87 == v95 << 31 >> 31)
          break;
      }
      *(_DWORD *)&v72[4 * v81] = v84;
      v85 >>= 1;
      v86 >>= 1;
      *v82 = v85;
      v82[1] = v86;
      *(int32x4_t *)(v82 + 2) = vshrq_n_s32(*(int32x4_t *)(v82 + 2), 1uLL);
      *(int32x4_t *)(v82 + 6) = vshrq_n_s32(*(int32x4_t *)(v82 + 6), 1uLL);
      *(int32x4_t *)(v82 + 10) = vshrq_n_s32(*(int32x4_t *)(v82 + 10), 1uLL);
      *((int32x2_t *)v82 + 7) = vshr_n_s32(*(int32x2_t *)(v82 + 14), 1uLL);
      ++v84;
    }
    v82 += 16;
    ++v81;
  }
  while (v81 != v146);
  v96 = 0;
  v97 = (uint64_t)(int)v144 >> 1;
  v98 = *(unsigned __int8 *)(v69 + v97 + 8 * v70);
  do
  {
    while (*(int *)&v72[4 * v96] <= 0)
    {
      v98 += *((unsigned __int8 *)&silk_pulses_per_block_BITS_Q5 + v23[v96++]);
      if (v146 == v96)
        goto LABEL_103;
    }
    v98 += 255;
    ++v96;
  }
  while (v146 != v96);
LABEL_103:
  v99 = 0;
  v100 = *(unsigned __int8 *)(v69 + 9 * v97 + 1);
  do
  {
    while (*(int *)&v72[4 * v99] <= 0)
    {
      v100 += *((unsigned __int8 *)&silk_pulses_per_block_BITS_Q5 + v23[v99++] + 18);
      if (v146 == v99)
        goto LABEL_107;
    }
    v100 += 255;
    ++v99;
  }
  while (v146 != v99);
LABEL_107:
  v101 = 0;
  v102 = *(unsigned __int8 *)(v69 + 9 * v97 + 2);
  do
  {
    while (*(int *)&v72[4 * v101] <= 0)
    {
      v102 += *((unsigned __int8 *)&silk_pulses_per_block_BITS_Q5 + v23[v101++] + 36);
      if (v146 == v101)
        goto LABEL_111;
    }
    v102 += 224;
    ++v101;
  }
  while (v146 != v101);
LABEL_111:
  v103 = 0;
  if ((int)v100 >= (int)v98)
    v104 = v98;
  else
    v104 = v100;
  v105 = *(unsigned __int8 *)(v69 + 9 * v97 + 3);
  do
  {
    while (*(int *)&v72[4 * v103] <= 0)
    {
      v105 += *((unsigned __int8 *)&silk_pulses_per_block_BITS_Q5 + v23[v103++] + 54);
      if (v146 == v103)
        goto LABEL_118;
    }
    v105 += 255;
    ++v103;
  }
  while (v146 != v103);
LABEL_118:
  v106 = 0;
  v107 = v100 < v98;
  if ((int)v102 >= (int)v104)
    v108 = v104;
  else
    v108 = v102;
  v109 = *(unsigned __int8 *)(v69 + 9 * v97 + 4);
  do
  {
    while (*(int *)&v72[4 * v106] <= 0)
    {
      v109 += *((unsigned __int8 *)&silk_pulses_per_block_BITS_Q5 + v23[v106++] + 72);
      if (v146 == v106)
        goto LABEL_125;
    }
    v109 += 255;
    ++v106;
  }
  while (v146 != v106);
LABEL_125:
  v110 = 0;
  if (v102 < v104)
    v107 = 2;
  if ((int)v105 >= (int)v108)
    v111 = v108;
  else
    v111 = v105;
  v112 = *(unsigned __int8 *)(v69 + 9 * v97 + 5);
  do
  {
    while (*(int *)&v72[4 * v110] <= 0)
    {
      v112 += *((unsigned __int8 *)&silk_pulses_per_block_BITS_Q5 + v23[v110++] + 90);
      if (v146 == v110)
        goto LABEL_134;
    }
    v112 += 150;
    ++v110;
  }
  while (v146 != v110);
LABEL_134:
  v113 = 0;
  if (v105 < v108)
    v107 = 3;
  if ((int)v109 >= (int)v111)
    v114 = v111;
  else
    v114 = v109;
  v115 = *(unsigned __int8 *)(v69 + 9 * v97 + 6);
  do
  {
    while (*(int *)&v72[4 * v113] <= 0)
    {
      v115 += *((unsigned __int8 *)&silk_pulses_per_block_BITS_Q5 + v23[v113++] + 108);
      if (v146 == v113)
        goto LABEL_143;
    }
    v115 += 255;
    ++v113;
  }
  while (v146 != v113);
LABEL_143:
  v116 = 0;
  if (v109 < v111)
    v107 = 4;
  if (v112 >= v114)
    v117 = v114;
  else
    v117 = v112;
  v118 = *(unsigned __int8 *)(v69 + 9 * v97 + 7);
  do
  {
    while (*(int *)&v72[4 * v116] <= 0)
    {
      v118 += *((unsigned __int8 *)&silk_pulses_per_block_BITS_Q5 + v23[v116++] + 126);
      if (v146 == v116)
        goto LABEL_152;
    }
    v118 += 224;
    ++v116;
  }
  while (v146 != v116);
LABEL_152:
  v119 = 0;
  if (v112 >= v114)
    v120 = v107;
  else
    v120 = 5;
  if (v115 >= v117)
    v121 = v117;
  else
    v121 = v115;
  v122 = *(unsigned __int8 *)(v69 + 9 * v97 + 8);
  do
  {
    while (*(int *)&v72[4 * v119] <= 0)
    {
      v122 += *((unsigned __int8 *)&silk_pulses_per_block_BITS_Q5 + v23[v119++] + 144);
      if (v146 == v119)
        goto LABEL_162;
    }
    v122 += 131;
    ++v119;
  }
  while (v146 != v119);
LABEL_162:
  if (v115 >= v117)
    v123 = v120;
  else
    v123 = 6;
  if (v118 >= v121)
    v118 = v121;
  else
    v123 = 7;
  if (v122 >= v118)
    v124 = v123;
  else
    v124 = 8;
  ec_enc_icdf(a1, v124, (uint64_t)&silk_rate_levels_iCDF + 9 * v97, 8);
  v125 = 0;
  v126 = (char *)&silk_pulses_per_block_iCDF + 18 * v124;
  do
  {
    v129 = *(_DWORD *)&v72[4 * v125];
    v127 = v126;
    if (v129)
    {
      ec_enc_icdf(a1, 17, (uint64_t)v126, 8);
      if (v129 < 2)
      {
        v127 = &unk_208F39E03;
      }
      else
      {
        v130 = v129 - 1;
        do
        {
          v127 = &unk_208F39E03;
          ec_enc_icdf(a1, 17, (uint64_t)&unk_208F39E03, 8);
          --v130;
        }
        while (v130);
      }
    }
    ec_enc_icdf(a1, v23[v125++], (uint64_t)v127, 8);
    v128 = v146;
  }
  while (v125 != v146);
  v131 = 0;
  do
  {
    if (v23[v131] >= 1)
      silk_shell_encoder(a1, v18);
    ++v131;
    v18 += 16;
  }
  while (v128 != v131);
  v143 = a3;
  v132 = 0;
  do
  {
    v133 = *(_DWORD *)&v72[4 * v132];
    if (v133 >= 1)
    {
      v134 = (_BYTE *)(v145 + 16 * v132);
      if (v133 == 1)
      {
        ec_enc_icdf(a1, *v134 & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[1] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[2] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[3] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[4] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[5] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[6] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[7] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[8] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[9] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[10] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[11] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[12] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[13] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[14] & 1, (uint64_t)&silk_lsb_iCDF, 8);
        ec_enc_icdf(a1, v134[15] & 1, (uint64_t)&silk_lsb_iCDF, 8);
      }
      else
      {
        v135 = 0;
        v136 = v133 + 1;
        do
        {
          v137 = (char)v134[v135];
          if (v137 < 0)
            v137 = -v137;
          v138 = (char)v137;
          v139 = v136;
          do
            ec_enc_icdf(a1, (v138 >> (v139-- - 2)) & 1, (uint64_t)&silk_lsb_iCDF, 8);
          while (v139 > 2);
          ec_enc_icdf(a1, v138 & 1, (uint64_t)&silk_lsb_iCDF, 8);
          ++v135;
        }
        while (v135 != 16);
      }
    }
    ++v132;
  }
  while (v132 != v146);
  v5 = v142;
  a3 = v143;
  LODWORD(v7) = v144;
  return silk_encode_signs(a1, v145, v5, v7, a3, v23);
}

BOOL ec_dec_bit_logp(uint64_t *a1, char a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  BOOL v13;

  v3 = *((_DWORD *)a1 + 8);
  v2 = *((_DWORD *)a1 + 9);
  v4 = v3 >> a2;
  v5 = v2;
  if (v2 >= v3 >> a2)
  {
    *((_DWORD *)a1 + 9) = v2 - (v3 >> a2);
    v5 = v2 - v4;
  }
  v6 = v3 - v4;
  if (v2 < v4)
    v6 = v4;
  *((_DWORD *)a1 + 8) = v6;
  if (v6 <= 0x800000)
  {
    v7 = *((unsigned int *)a1 + 2);
    v8 = *((_DWORD *)a1 + 11);
    v9 = *((unsigned int *)a1 + 7);
    v10 = *((_DWORD *)a1 + 6) + 8;
    do
    {
      *((_DWORD *)a1 + 6) = v10;
      *((_DWORD *)a1 + 8) = v6 << 8;
      if (v9 < v7)
      {
        v11 = *a1;
        *((_DWORD *)a1 + 7) = v9 + 1;
        v12 = *(unsigned __int8 *)(v11 + v9++);
      }
      else
      {
        v12 = 0;
      }
      v5 = (((v5 & 0x7FFFFF) << 8) | ((v12 | (v8 << 8)) >> 1)) ^ 0xFF;
      *((_DWORD *)a1 + 11) = v12;
      *((_DWORD *)a1 + 9) = v5;
      v10 += 8;
      v8 = v12;
      v13 = v6 > 0x8000;
      v6 <<= 8;
    }
    while (!v13);
  }
  return v2 < v4;
}

uint64_t ec_dec_icdf(uint64_t *a1, unsigned __int8 *a2, char a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  int v9;
  unsigned int v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  BOOL v17;

  v4 = *((_DWORD *)a1 + 8);
  v3 = *((_DWORD *)a1 + 9);
  v5 = v4 >> a3;
  LODWORD(v6) = -1;
  do
  {
    v7 = v4;
    v8 = *a2++;
    v4 = v5 * v8;
    v6 = (v6 + 1);
    v9 = v3 - v5 * v8;
  }
  while (v3 < v5 * v8);
  v10 = v7 - v4;
  *((_DWORD *)a1 + 8) = v7 - v4;
  *((_DWORD *)a1 + 9) = v9;
  if (v7 - v4 <= 0x800000)
  {
    v11 = *((unsigned int *)a1 + 2);
    v12 = *((_DWORD *)a1 + 11);
    v13 = *((unsigned int *)a1 + 7);
    v14 = *((_DWORD *)a1 + 6) + 8;
    do
    {
      *((_DWORD *)a1 + 6) = v14;
      *((_DWORD *)a1 + 8) = v10 << 8;
      if (v13 < v11)
      {
        v15 = *a1;
        *((_DWORD *)a1 + 7) = v13 + 1;
        v16 = *(unsigned __int8 *)(v15 + v13++);
      }
      else
      {
        v16 = 0;
      }
      v9 = (((v9 & 0x7FFFFF) << 8) | ((v16 | (v12 << 8)) >> 1)) ^ 0xFF;
      *((_DWORD *)a1 + 11) = v16;
      *((_DWORD *)a1 + 9) = v9;
      v14 += 8;
      v12 = v16;
      v17 = v10 > 0x8000;
      v10 <<= 8;
    }
    while (!v17);
  }
  return v6;
}

uint64_t ec_dec_uint(uint64_t *a1, unsigned int a2)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  BOOL v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  int v27;
  unsigned int v28;
  unint64_t v29;
  int v30;
  unint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  int v41;

  v2 = a2 - 1;
  if (v2 < 0x100)
  {
    v22 = *((_DWORD *)a1 + 8);
    v21 = *((_DWORD *)a1 + 9);
    v23 = v22 / a2;
    v24 = v21 / (v22 / a2) + 1;
    LODWORD(v25) = a2 - v24;
    if (a2 >= v24)
      v25 = v25;
    else
      v25 = 0;
    v26 = (~(_DWORD)v25 + a2) * v23;
    v27 = v21 - v26;
    v28 = v22 - v26;
    if (v24 < a2)
      v28 = v23;
    *((_DWORD *)a1 + 9) = v27;
    *((_DWORD *)a1 + 10) = v23;
    *((_DWORD *)a1 + 8) = v28;
    if (v28 < 0x800001)
    {
      v29 = *((unsigned int *)a1 + 2);
      v30 = *((_DWORD *)a1 + 11);
      v31 = *((unsigned int *)a1 + 7);
      v32 = *((_DWORD *)a1 + 6) + 8;
      do
      {
        *((_DWORD *)a1 + 6) = v32;
        *((_DWORD *)a1 + 8) = v28 << 8;
        if (v31 < v29)
        {
          v33 = *a1;
          *((_DWORD *)a1 + 7) = v31 + 1;
          v34 = *(unsigned __int8 *)(v33 + v31++);
        }
        else
        {
          v34 = 0;
        }
        v27 = (((v27 & 0x7FFFFF) << 8) | ((v34 | (v30 << 8)) >> 1)) ^ 0xFF;
        *((_DWORD *)a1 + 11) = v34;
        *((_DWORD *)a1 + 9) = v27;
        v32 += 8;
        v30 = v34;
        v20 = v28 > 0x8000;
        v28 <<= 8;
      }
      while (!v20);
    }
  }
  else
  {
    v3 = 24 - __clz(v2);
    v4 = v2 >> v3;
    v6 = *((_DWORD *)a1 + 8);
    v5 = *((_DWORD *)a1 + 9);
    v7 = v6 / ((v2 >> v3) + 1);
    v8 = v5 / v7 + 1;
    v9 = (v2 >> v3) - v5 / v7;
    if ((v2 >> v3) + 1 < v8)
      v9 = 0;
    v10 = (v4 - v9) * v7;
    v11 = v5 - v10;
    v12 = v6 - v10;
    if (v4 >= v8)
      v13 = v7;
    else
      v13 = v12;
    *((_DWORD *)a1 + 9) = v11;
    *((_DWORD *)a1 + 10) = v7;
    *((_DWORD *)a1 + 8) = v13;
    if (v13 < 0x800001)
    {
      v14 = *((unsigned int *)a1 + 2);
      v15 = *((_DWORD *)a1 + 11);
      v16 = *((unsigned int *)a1 + 7);
      v17 = *((_DWORD *)a1 + 6) + 8;
      do
      {
        *((_DWORD *)a1 + 6) = v17;
        *((_DWORD *)a1 + 8) = v13 << 8;
        if (v16 < v14)
        {
          v18 = *a1;
          *((_DWORD *)a1 + 7) = v16 + 1;
          v19 = *(unsigned __int8 *)(v18 + v16++);
        }
        else
        {
          v19 = 0;
        }
        v11 = (((v11 & 0x7FFFFF) << 8) | ((v19 | (v15 << 8)) >> 1)) ^ 0xFF;
        *((_DWORD *)a1 + 11) = v19;
        *((_DWORD *)a1 + 9) = v11;
        v17 += 8;
        v15 = v19;
        v20 = v13 > 0x8000;
        v13 <<= 8;
      }
      while (!v20);
    }
    v35 = v9 << v3;
    v36 = *((_DWORD *)a1 + 4);
    v37 = *((_DWORD *)a1 + 5);
    if (v37 >= v3)
    {
      v41 = *((_DWORD *)a1 + 5);
    }
    else
    {
      v38 = *((_DWORD *)a1 + 2);
      v39 = *((_DWORD *)a1 + 3);
      do
      {
        while (v39 < v38)
        {
          v40 = *a1;
          *((_DWORD *)a1 + 3) = ++v39;
          v36 |= *(unsigned __int8 *)(v40 + v38 - v39) << v37;
          v41 = v37 + 8;
          v20 = v37 < 17;
          v37 += 8;
          if (!v20)
            goto LABEL_32;
        }
        v41 = v37 + 8;
        v20 = v37 < 17;
        v37 += 8;
      }
      while (v20);
    }
LABEL_32:
    *((_DWORD *)a1 + 4) = v36 >> v3;
    *((_DWORD *)a1 + 5) = v41 - v3;
    *((_DWORD *)a1 + 6) += v3;
    v25 = v36 & ~(-1 << v3) | v35;
    if (v25 > v2)
    {
      *((_DWORD *)a1 + 12) = 1;
      return v2;
    }
  }
  return v25;
}

uint64_t *ec_encode(uint64_t *result, int a2, int a3, unsigned int a4)
{
  unsigned int v4;
  int v5;
  unsigned int v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int i;
  uint64_t v13;
  uint64_t v14;

  v4 = *((_DWORD *)result + 8);
  v5 = v4 / a4;
  if (a2)
  {
    *((_DWORD *)result + 9) += v4 + v5 * (a2 - a4);
    v6 = v5 * (a3 - a2);
    *((_DWORD *)result + 8) = v6;
    if (v6 > 0x800000)
      return result;
  }
  else
  {
    v6 = v4 + v5 * (a3 - a4);
    *((_DWORD *)result + 8) = v6;
    if (v6 > 0x800000)
      return result;
  }
  v7 = *((_DWORD *)result + 9);
  do
  {
    if (v7 >> 23 == 255)
    {
      ++*((_DWORD *)result + 10);
    }
    else
    {
      v8 = *((_DWORD *)result + 11);
      if ((v8 & 0x80000000) == 0)
      {
        v9 = *((unsigned int *)result + 7);
        if ((*((_DWORD *)result + 3) + v9) >= *((_DWORD *)result + 2))
        {
          v10 = -1;
        }
        else
        {
          v10 = 0;
          v11 = *result;
          *((_DWORD *)result + 7) = v9 + 1;
          *(_BYTE *)(v11 + v9) = v8 + (v7 < 0);
        }
        *((_DWORD *)result + 12) |= v10;
      }
      for (i = *((_DWORD *)result + 10); i; *((_DWORD *)result + 10) = i)
      {
        while (1)
        {
          v14 = *((unsigned int *)result + 7);
          if ((*((_DWORD *)result + 3) + v14) >= *((_DWORD *)result + 2))
            break;
          v13 = *result;
          *((_DWORD *)result + 7) = v14 + 1;
          *(_BYTE *)(v13 + v14) = (v7 < 0) - 1;
          LODWORD(v13) = *((_DWORD *)result + 10);
          *((_DWORD *)result + 12) = *((_DWORD *)result + 12);
          i = v13 - 1;
          *((_DWORD *)result + 10) = i;
          if (!i)
            goto LABEL_19;
        }
        *((_DWORD *)result + 12) = -1;
        --i;
      }
LABEL_19:
      *((_DWORD *)result + 11) = (v7 >> 23);
      v6 = *((_DWORD *)result + 8);
      v7 = *((_DWORD *)result + 9);
    }
    v7 = (v7 & 0x7FFFFF) << 8;
    v6 <<= 8;
    *((_DWORD *)result + 8) = v6;
    *((_DWORD *)result + 9) = v7;
    *((_DWORD *)result + 6) += 8;
  }
  while (v6 < 0x800001);
  return result;
}

uint64_t *ec_encode_bin(uint64_t *result, int a2, int a3, char a4)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int i;
  uint64_t v14;
  uint64_t v15;

  v4 = *((_DWORD *)result + 8);
  v5 = v4 >> a4;
  v6 = -1 << a4;
  if (a2)
  {
    *((_DWORD *)result + 9) += v4 + v5 * (v6 + a2);
    v7 = v5 * (a3 - a2);
    *((_DWORD *)result + 8) = v7;
    if (v7 > 0x800000)
      return result;
  }
  else
  {
    v7 = v4 + v5 * (v6 + a3);
    *((_DWORD *)result + 8) = v7;
    if (v7 > 0x800000)
      return result;
  }
  v8 = *((_DWORD *)result + 9);
  do
  {
    if (v8 >> 23 == 255)
    {
      ++*((_DWORD *)result + 10);
    }
    else
    {
      v9 = *((_DWORD *)result + 11);
      if ((v9 & 0x80000000) == 0)
      {
        v10 = *((unsigned int *)result + 7);
        if ((*((_DWORD *)result + 3) + v10) >= *((_DWORD *)result + 2))
        {
          v11 = -1;
        }
        else
        {
          v11 = 0;
          v12 = *result;
          *((_DWORD *)result + 7) = v10 + 1;
          *(_BYTE *)(v12 + v10) = v9 + (v8 < 0);
        }
        *((_DWORD *)result + 12) |= v11;
      }
      for (i = *((_DWORD *)result + 10); i; *((_DWORD *)result + 10) = i)
      {
        while (1)
        {
          v15 = *((unsigned int *)result + 7);
          if ((*((_DWORD *)result + 3) + v15) >= *((_DWORD *)result + 2))
            break;
          v14 = *result;
          *((_DWORD *)result + 7) = v15 + 1;
          *(_BYTE *)(v14 + v15) = (v8 < 0) - 1;
          LODWORD(v14) = *((_DWORD *)result + 10);
          *((_DWORD *)result + 12) = *((_DWORD *)result + 12);
          i = v14 - 1;
          *((_DWORD *)result + 10) = i;
          if (!i)
            goto LABEL_19;
        }
        *((_DWORD *)result + 12) = -1;
        --i;
      }
LABEL_19:
      *((_DWORD *)result + 11) = (v8 >> 23);
      v7 = *((_DWORD *)result + 8);
      v8 = *((_DWORD *)result + 9);
    }
    v8 = (v8 & 0x7FFFFF) << 8;
    v7 <<= 8;
    *((_DWORD *)result + 8) = v7;
    *((_DWORD *)result + 9) = v8;
    *((_DWORD *)result + 6) += 8;
  }
  while (v7 < 0x800001);
  return result;
}

uint64_t *ec_enc_bit_logp(uint64_t *result, int a2, char a3)
{
  unsigned int v3;
  unsigned int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int i;
  uint64_t v11;
  uint64_t v12;

  v3 = *((_DWORD *)result + 8);
  v4 = v3 - (v3 >> a3);
  if (a2)
  {
    *((_DWORD *)result + 9) += v4;
    v4 = v3 >> a3;
  }
  *((_DWORD *)result + 8) = v4;
  if (v4 <= 0x800000)
  {
    v5 = *((_DWORD *)result + 9);
    do
    {
      if (v5 >> 23 == 255)
      {
        ++*((_DWORD *)result + 10);
      }
      else
      {
        v6 = *((_DWORD *)result + 11);
        if ((v6 & 0x80000000) == 0)
        {
          v7 = *((unsigned int *)result + 7);
          if ((*((_DWORD *)result + 3) + v7) >= *((_DWORD *)result + 2))
          {
            v8 = -1;
          }
          else
          {
            v8 = 0;
            v9 = *result;
            *((_DWORD *)result + 7) = v7 + 1;
            *(_BYTE *)(v9 + v7) = v6 + (v5 < 0);
          }
          *((_DWORD *)result + 12) |= v8;
        }
        for (i = *((_DWORD *)result + 10); i; *((_DWORD *)result + 10) = i)
        {
          while (1)
          {
            v12 = *((unsigned int *)result + 7);
            if ((*((_DWORD *)result + 3) + v12) >= *((_DWORD *)result + 2))
              break;
            v11 = *result;
            *((_DWORD *)result + 7) = v12 + 1;
            *(_BYTE *)(v11 + v12) = (v5 < 0) - 1;
            LODWORD(v11) = *((_DWORD *)result + 10);
            *((_DWORD *)result + 12) = *((_DWORD *)result + 12);
            i = v11 - 1;
            *((_DWORD *)result + 10) = i;
            if (!i)
              goto LABEL_18;
          }
          *((_DWORD *)result + 12) = -1;
          --i;
        }
LABEL_18:
        *((_DWORD *)result + 11) = (v5 >> 23);
        v4 = *((_DWORD *)result + 8);
        v5 = *((_DWORD *)result + 9);
      }
      v5 = (v5 & 0x7FFFFF) << 8;
      v4 <<= 8;
      *((_DWORD *)result + 8) = v4;
      *((_DWORD *)result + 9) = v5;
      *((_DWORD *)result + 6) += 8;
    }
    while (v4 < 0x800001);
  }
  return result;
}

uint64_t *ec_enc_icdf(uint64_t *result, int a2, uint64_t a3, char a4)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int i;
  uint64_t v14;
  uint64_t v15;

  v4 = *((_DWORD *)result + 8);
  v5 = v4 >> a4;
  v6 = (a2 - 1);
  if (a2 < 1)
  {
    v7 = v4 - v5 * *(unsigned __int8 *)(a3 + a2);
    *((_DWORD *)result + 8) = v7;
    if (v7 > 0x800000)
      return result;
  }
  else
  {
    *((_DWORD *)result + 9) = *((_DWORD *)result + 9) + v4 - v5 * *(unsigned __int8 *)(a3 + v6);
    v7 = (*(unsigned __int8 *)(a3 + v6) - *(unsigned __int8 *)(a3 + a2)) * v5;
    *((_DWORD *)result + 8) = v7;
    if (v7 > 0x800000)
      return result;
  }
  v8 = *((_DWORD *)result + 9);
  do
  {
    if (v8 >> 23 == 255)
    {
      ++*((_DWORD *)result + 10);
    }
    else
    {
      v9 = *((_DWORD *)result + 11);
      if ((v9 & 0x80000000) == 0)
      {
        v10 = *((unsigned int *)result + 7);
        if ((*((_DWORD *)result + 3) + v10) >= *((_DWORD *)result + 2))
        {
          v11 = -1;
        }
        else
        {
          v11 = 0;
          v12 = *result;
          *((_DWORD *)result + 7) = v10 + 1;
          *(_BYTE *)(v12 + v10) = v9 + (v8 < 0);
        }
        *((_DWORD *)result + 12) |= v11;
      }
      for (i = *((_DWORD *)result + 10); i; *((_DWORD *)result + 10) = i)
      {
        while (1)
        {
          v15 = *((unsigned int *)result + 7);
          if ((*((_DWORD *)result + 3) + v15) >= *((_DWORD *)result + 2))
            break;
          v14 = *result;
          *((_DWORD *)result + 7) = v15 + 1;
          *(_BYTE *)(v14 + v15) = (v8 < 0) - 1;
          LODWORD(v14) = *((_DWORD *)result + 10);
          *((_DWORD *)result + 12) = *((_DWORD *)result + 12);
          i = v14 - 1;
          *((_DWORD *)result + 10) = i;
          if (!i)
            goto LABEL_19;
        }
        *((_DWORD *)result + 12) = -1;
        --i;
      }
LABEL_19:
      *((_DWORD *)result + 11) = (v8 >> 23);
      v7 = *((_DWORD *)result + 8);
      v8 = *((_DWORD *)result + 9);
    }
    v8 = (v8 & 0x7FFFFF) << 8;
    v7 <<= 8;
    *((_DWORD *)result + 8) = v7;
    *((_DWORD *)result + 9) = v8;
    *((_DWORD *)result + 6) += 8;
  }
  while (v7 < 0x800001);
  return result;
}

uint64_t *ec_enc_uint(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t *result;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  BOOL v16;
  int v17;
  unsigned int v18;

  v5 = a3 - 1;
  if (a3 - 1 < 0x100)
    return ec_encode((uint64_t *)a1, a2, a2 + 1, a3);
  v6 = __clz(v5);
  v7 = 24 - v6;
  result = ec_encode((uint64_t *)a1, a2 >> (24 - v6), (a2 >> (24 - v6)) + 1, (v5 >> (24 - v6)) + 1);
  v9 = *(_DWORD *)(a1 + 16);
  v10 = *(_DWORD *)(a1 + 20);
  v11 = v10 + v7;
  if (v10 + v7 >= 0x21)
  {
    do
    {
      v18 = *(_DWORD *)(a1 + 8);
      v17 = *(_DWORD *)(a1 + 12);
      if (v17 + *(_DWORD *)(a1 + 28) < v18)
      {
        v13 = 0;
        v14 = *(_QWORD *)a1;
        v15 = v17 + 1;
        *(_DWORD *)(a1 + 12) = v15;
        *(_BYTE *)(v14 + v18 - v15) = v9;
      }
      else
      {
        v13 = -1;
      }
      *(_DWORD *)(a1 + 48) |= v13;
      v9 >>= 8;
      v12 = v10 - 8;
      v16 = v10 <= 15;
      v10 -= 8;
    }
    while (!v16);
    v11 = v7 + v12;
  }
  else
  {
    v12 = *(_DWORD *)(a1 + 20);
  }
  *(_DWORD *)(a1 + 16) = ((a2 & ~(-1 << v7)) << v12) | v9;
  *(_DWORD *)(a1 + 20) = v11;
  *(_DWORD *)(a1 + 24) += v7;
  return result;
}

void ec_enc_done(uint64_t *a1)
{
  int v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int ii;
  unsigned int v16;
  int v17;
  int i;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int j;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int k;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  char v41;
  int m;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int n;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  int v59;
  int v60;
  BOOL v61;
  int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;

  v3 = *((_DWORD *)a1 + 8);
  v2 = *((_DWORD *)a1 + 9);
  v4 = __clz(v3);
  v5 = ((0x7FFFFFFFu >> v4) + v2) & ((int)0x80000000 >> v4);
  if ((v5 | (0x7FFFFFFFu >> v4)) >= v2 + v3)
  {
    v7 = 0x3FFFFFFFu >> v4;
    v8 = -1073741824 >> v4++;
    v5 = (v7 + v2) & v8;
    if (v5 >> 23 == 255)
      goto LABEL_4;
LABEL_7:
    v9 = *((_DWORD *)a1 + 11);
    if ((v9 & 0x80000000) == 0)
    {
      v10 = *((unsigned int *)a1 + 7);
      if ((*((_DWORD *)a1 + 3) + v10) >= *((_DWORD *)a1 + 2))
      {
        v11 = -1;
      }
      else
      {
        v11 = 0;
        v12 = *a1;
        *((_DWORD *)a1 + 7) = v10 + 1;
        *(_BYTE *)(v12 + v10) = v9 + ((v5 & 0x80000000) != 0);
      }
      *((_DWORD *)a1 + 12) |= v11;
    }
    for (i = *((_DWORD *)a1 + 10); i; *((_DWORD *)a1 + 10) = i)
    {
      while (1)
      {
        v20 = *((unsigned int *)a1 + 7);
        if ((*((_DWORD *)a1 + 3) + v20) >= *((_DWORD *)a1 + 2))
          break;
        v19 = *a1;
        *((_DWORD *)a1 + 7) = v20 + 1;
        *(_BYTE *)(v19 + v20) = ((v5 & 0x80000000) != 0) - 1;
        LODWORD(v19) = *((_DWORD *)a1 + 10);
        *((_DWORD *)a1 + 12) = *((_DWORD *)a1 + 12);
        i = v19 - 1;
        *((_DWORD *)a1 + 10) = i;
        if (!i)
          goto LABEL_21;
      }
      *((_DWORD *)a1 + 12) = -1;
      --i;
    }
LABEL_21:
    *((_DWORD *)a1 + 11) = (v5 >> 23);
    if (v4 < 9)
      goto LABEL_5;
    goto LABEL_22;
  }
  if (!v4)
  {
    v13 = 0;
    v14 = *((_DWORD *)a1 + 11);
    if ((v14 & 0x80000000) == 0)
      goto LABEL_74;
LABEL_11:
    ii = *((_DWORD *)a1 + 10);
    if (ii)
      goto LABEL_80;
    v16 = *((_DWORD *)a1 + 4);
    v17 = *((_DWORD *)a1 + 5);
    if (v17 <= 7)
      goto LABEL_83;
    goto LABEL_87;
  }
  if (v5 >> 23 != 255)
    goto LABEL_7;
LABEL_4:
  ++*((_DWORD *)a1 + 10);
  if (v4 < 9)
  {
LABEL_5:
    v6 = 8;
    goto LABEL_73;
  }
LABEL_22:
  v21 = (v5 >> 15);
  if (v21 == 255)
  {
    ++*((_DWORD *)a1 + 10);
    if (v4 < 17)
    {
LABEL_24:
      v6 = 16;
      goto LABEL_73;
    }
  }
  else
  {
    v22 = *((_DWORD *)a1 + 11);
    if ((v22 & 0x80000000) == 0)
    {
      v23 = *((unsigned int *)a1 + 7);
      if ((*((_DWORD *)a1 + 3) + v23) >= *((_DWORD *)a1 + 2))
      {
        v24 = -1;
      }
      else
      {
        v24 = 0;
        v25 = *a1;
        *((_DWORD *)a1 + 7) = v23 + 1;
        *(_BYTE *)(v25 + v23) = v22;
      }
      *((_DWORD *)a1 + 12) |= v24;
    }
    for (j = *((_DWORD *)a1 + 10); j; *((_DWORD *)a1 + 10) = j)
    {
      while (1)
      {
        v28 = *((unsigned int *)a1 + 7);
        if ((*((_DWORD *)a1 + 3) + v28) >= *((_DWORD *)a1 + 2))
          break;
        v27 = *a1;
        *((_DWORD *)a1 + 7) = v28 + 1;
        *(_BYTE *)(v27 + v28) = -1;
        LODWORD(v27) = *((_DWORD *)a1 + 10);
        *((_DWORD *)a1 + 12) = *((_DWORD *)a1 + 12);
        j = v27 - 1;
        *((_DWORD *)a1 + 10) = j;
        if (!j)
          goto LABEL_35;
      }
      *((_DWORD *)a1 + 12) = -1;
      --j;
    }
LABEL_35:
    *((_DWORD *)a1 + 11) = v21;
    if (v4 < 17)
      goto LABEL_24;
  }
  v29 = (v5 >> 7);
  if (v29 == 255)
  {
    ++*((_DWORD *)a1 + 10);
    if (v4 < 25)
    {
LABEL_38:
      v6 = 24;
      goto LABEL_73;
    }
  }
  else
  {
    v30 = *((_DWORD *)a1 + 11);
    if ((v30 & 0x80000000) == 0)
    {
      v31 = *((unsigned int *)a1 + 7);
      if ((*((_DWORD *)a1 + 3) + v31) >= *((_DWORD *)a1 + 2))
      {
        v32 = -1;
      }
      else
      {
        v32 = 0;
        v33 = *a1;
        *((_DWORD *)a1 + 7) = v31 + 1;
        *(_BYTE *)(v33 + v31) = v30;
      }
      *((_DWORD *)a1 + 12) |= v32;
    }
    for (k = *((_DWORD *)a1 + 10); k; *((_DWORD *)a1 + 10) = k)
    {
      while (1)
      {
        v36 = *((unsigned int *)a1 + 7);
        if ((*((_DWORD *)a1 + 3) + v36) >= *((_DWORD *)a1 + 2))
          break;
        v35 = *a1;
        *((_DWORD *)a1 + 7) = v36 + 1;
        *(_BYTE *)(v35 + v36) = -1;
        LODWORD(v35) = *((_DWORD *)a1 + 10);
        *((_DWORD *)a1 + 12) = *((_DWORD *)a1 + 12);
        k = v35 - 1;
        *((_DWORD *)a1 + 10) = k;
        if (!k)
          goto LABEL_49;
      }
      *((_DWORD *)a1 + 12) = -1;
      --k;
    }
LABEL_49:
    *((_DWORD *)a1 + 11) = v29;
    if (v4 < 25)
      goto LABEL_38;
  }
  v37 = *((_DWORD *)a1 + 11);
  if ((v37 & 0x80000000) == 0)
  {
    v38 = *((unsigned int *)a1 + 7);
    if ((*((_DWORD *)a1 + 3) + v38) >= *((_DWORD *)a1 + 2))
    {
      v39 = -1;
    }
    else
    {
      v39 = 0;
      v40 = *a1;
      *((_DWORD *)a1 + 7) = v38 + 1;
      *(_BYTE *)(v40 + v38) = v37;
    }
    *((_DWORD *)a1 + 12) |= v39;
  }
  v41 = 2 * v5;
  for (m = *((_DWORD *)a1 + 10); m; *((_DWORD *)a1 + 10) = m)
  {
    while (1)
    {
      v44 = *((unsigned int *)a1 + 7);
      if ((*((_DWORD *)a1 + 3) + v44) >= *((_DWORD *)a1 + 2))
        break;
      v43 = *a1;
      *((_DWORD *)a1 + 7) = v44 + 1;
      *(_BYTE *)(v43 + v44) = -1;
      LODWORD(v43) = *((_DWORD *)a1 + 10);
      *((_DWORD *)a1 + 12) = *((_DWORD *)a1 + 12);
      m = v43 - 1;
      *((_DWORD *)a1 + 10) = m;
      if (!m)
        goto LABEL_60;
    }
    *((_DWORD *)a1 + 12) = -1;
    --m;
  }
LABEL_60:
  *((_DWORD *)a1 + 11) = v41 & 0xFE;
  if (v4 < 33)
  {
    v6 = 32;
  }
  else
  {
    v45 = *((_DWORD *)a1 + 11);
    if ((v45 & 0x80000000) == 0)
    {
      v46 = *((unsigned int *)a1 + 7);
      if ((*((_DWORD *)a1 + 3) + v46) >= *((_DWORD *)a1 + 2))
      {
        v47 = -1;
      }
      else
      {
        v47 = 0;
        v48 = *a1;
        *((_DWORD *)a1 + 7) = v46 + 1;
        *(_BYTE *)(v48 + v46) = v45;
      }
      *((_DWORD *)a1 + 12) |= v47;
    }
    for (n = *((_DWORD *)a1 + 10); n; *((_DWORD *)a1 + 10) = n)
    {
      while (1)
      {
        v51 = *((unsigned int *)a1 + 7);
        if ((*((_DWORD *)a1 + 3) + v51) >= *((_DWORD *)a1 + 2))
          break;
        v50 = *a1;
        *((_DWORD *)a1 + 7) = v51 + 1;
        *(_BYTE *)(v50 + v51) = -1;
        LODWORD(v50) = *((_DWORD *)a1 + 10);
        *((_DWORD *)a1 + 12) = *((_DWORD *)a1 + 12);
        n = v50 - 1;
        *((_DWORD *)a1 + 10) = n;
        if (!n)
          goto LABEL_72;
      }
      *((_DWORD *)a1 + 12) = -1;
      --n;
    }
LABEL_72:
    *((_DWORD *)a1 + 11) = 0;
    v6 = 40;
  }
LABEL_73:
  v13 = v6 - v4;
  v14 = *((_DWORD *)a1 + 11);
  if (v14 < 0)
    goto LABEL_11;
LABEL_74:
  v52 = *((unsigned int *)a1 + 7);
  if ((*((_DWORD *)a1 + 3) + v52) >= *((_DWORD *)a1 + 2))
  {
    *((_DWORD *)a1 + 12) = -1;
    for (ii = *((_DWORD *)a1 + 10); ii; *((_DWORD *)a1 + 10) = ii)
    {
LABEL_80:
      while (1)
      {
        v55 = *((unsigned int *)a1 + 7);
        if ((*((_DWORD *)a1 + 3) + v55) >= *((_DWORD *)a1 + 2))
          break;
        v54 = *a1;
        *((_DWORD *)a1 + 7) = v55 + 1;
        *(_BYTE *)(v54 + v55) = -1;
        LODWORD(v54) = *((_DWORD *)a1 + 10);
        *((_DWORD *)a1 + 12) = *((_DWORD *)a1 + 12);
        ii = v54 - 1;
        *((_DWORD *)a1 + 10) = ii;
        if (!ii)
          goto LABEL_82;
      }
      *((_DWORD *)a1 + 12) = -1;
      --ii;
    }
  }
  else
  {
    v53 = *a1;
    *((_DWORD *)a1 + 7) = v52 + 1;
    *(_BYTE *)(v53 + v52) = v14;
    *((_DWORD *)a1 + 12) = *((_DWORD *)a1 + 12);
    ii = *((_DWORD *)a1 + 10);
    if (ii)
      goto LABEL_80;
  }
LABEL_82:
  *((_DWORD *)a1 + 11) = 0;
  v16 = *((_DWORD *)a1 + 4);
  v17 = *((_DWORD *)a1 + 5);
  if (v17 <= 7)
  {
LABEL_83:
    if (*((_DWORD *)a1 + 12))
      return;
    goto LABEL_90;
  }
  do
  {
LABEL_87:
    v63 = *((_DWORD *)a1 + 2);
    v62 = *((_DWORD *)a1 + 3);
    if (v62 + *((_DWORD *)a1 + 7) < v63)
    {
      v56 = 0;
      v57 = *a1;
      v58 = v62 + 1;
      *((_DWORD *)a1 + 3) = v58;
      *(_BYTE *)(v57 + v63 - v58) = v16;
    }
    else
    {
      v56 = -1;
    }
    v59 = *((_DWORD *)a1 + 12) | v56;
    *((_DWORD *)a1 + 12) = v59;
    v16 >>= 8;
    v60 = v17 - 8;
    v61 = v17 <= 15;
    v17 -= 8;
  }
  while (!v61);
  v17 = v60;
  if (!v59)
  {
LABEL_90:
    bzero((void *)(*a1 + *((unsigned int *)a1 + 7)), (*((_DWORD *)a1 + 2) - (*((_DWORD *)a1 + 7) + *((_DWORD *)a1 + 3))));
    if (v17 >= 1)
    {
      v65 = *((_DWORD *)a1 + 2);
      v64 = *((_DWORD *)a1 + 3);
      if (v64 >= v65)
      {
        *((_DWORD *)a1 + 12) = -1;
      }
      else
      {
        if (*((_DWORD *)a1 + 7) + v64 >= v65 && v17 > v13)
        {
          v16 &= ~(-1 << v13);
          *((_DWORD *)a1 + 12) = -1;
        }
        *(_BYTE *)(*a1 + v65 + ~v64) |= v16;
      }
    }
  }
}

void silk_find_LPC_FLP(uint64_t a1, int16x8_t *a2, unint64_t a3, float a4)
{
  int16x8_t *v8;
  int v9;
  unsigned int v10;
  int v11;
  float v12;
  float v13;
  float v14;
  int v15;
  int16x8_t *v16;
  float32x4_t *v17;
  uint64_t v18;
  float v19;
  uint64_t v20;
  uint64_t v21;
  int16x8_t *v22;
  int16x8_t *v23;
  int16x8_t v24;
  uint64_t v25;
  int16x8_t *v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  uint64_t v31;
  uint64_t v32;
  __int16 *v33;
  __int16 *v34;
  __int16 *v35;
  __int16 v36;
  __int16 v37;
  __int16 v38;
  uint64_t v39;
  int16x8_t *v40;
  float32x4_t *v41;
  float32x4_t v42;
  uint64_t v43;
  int16x8_t v44;
  float32x4_t v45;
  float32x4_t v46;
  uint64_t v47;
  float *v48;
  __int16 *v49;
  int v50;
  uint64_t v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  double v56;
  unsigned int v57;
  unint64_t v58;
  const float *v59;
  uint64_t v60;
  const float *v61;
  float64x2_t v62;
  float64x2_t v63;
  float64x2_t v64;
  float64x2_t v65;
  float64x2_t v66;
  float64x2_t v67;
  float64x2_t v68;
  float64x2_t v69;
  float64x2_t v70;
  float64x2_t v71;
  float *v72;
  double v73;
  float v74;
  float v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  float *v81;
  uint64_t v82;
  float *v83;
  float v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  double v89;
  unsigned int v90;
  float v91;
  unint64_t v92;
  const float *v93;
  uint64_t v94;
  const float *v95;
  float64x2_t v96;
  float64x2_t v97;
  float64x2_t v98;
  float64x2_t v99;
  float64x2_t v100;
  float64x2_t v101;
  float64x2_t v102;
  float64x2_t v103;
  float64x2_t v104;
  float64x2_t v105;
  float *v106;
  double v107;
  float v108;
  float v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  float *v115;
  uint64_t v116;
  float *v117;
  float v118;
  double v119;
  float v120;
  uint64_t v121;
  int16x8_t *v122;
  int16x8_t *v123;
  uint64_t v124;
  int16x8_t *v125;
  int16x8_t v126;
  uint64_t v127;
  uint64_t v128;
  __int16 *v129;
  __int16 *v130;
  __int16 *v131;
  __int16 v132;
  __int16 v133;
  __int16 v134;
  uint64_t v135;
  int16x8_t *v136;
  float32x4_t *v137;
  float32x4_t v138;
  uint64_t v139;
  int16x8_t v140;
  float32x4_t v141;
  float32x4_t v142;
  uint64_t v143;
  float *v144;
  __int16 *v145;
  int v146;
  uint64_t v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  uint64_t v151;
  unint64_t v152;
  double v153;
  unsigned int v154;
  unint64_t v155;
  const float *v156;
  uint64_t v157;
  const float *v158;
  float64x2_t v159;
  float64x2_t v160;
  float64x2_t v161;
  float64x2_t v162;
  float64x2_t v163;
  float64x2_t v164;
  float64x2_t v165;
  float64x2_t v166;
  float64x2_t v167;
  float64x2_t v168;
  float *v169;
  double v170;
  float v171;
  float v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  float *v178;
  uint64_t v179;
  float *v180;
  float v181;
  uint64_t v182;
  unint64_t v183;
  unint64_t v184;
  unint64_t v185;
  double v186;
  unsigned int v187;
  unint64_t v188;
  const float *v189;
  uint64_t v190;
  const float *v191;
  float64x2_t v192;
  float64x2_t v193;
  float64x2_t v194;
  float64x2_t v195;
  float64x2_t v196;
  float64x2_t v197;
  float64x2_t v198;
  float64x2_t v199;
  float64x2_t v200;
  float64x2_t v201;
  float *v202;
  double v203;
  float v204;
  float v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  float *v211;
  uint64_t v212;
  float *v213;
  float v214;
  double v215;
  float v216;
  uint64_t v217;
  int16x8_t *v218;
  int16x8_t *v219;
  uint64_t v220;
  int16x8_t *v221;
  int16x8_t v222;
  uint64_t v223;
  uint64_t v224;
  __int16 *v225;
  __int16 *v226;
  __int16 *v227;
  __int16 v228;
  __int16 v229;
  __int16 v230;
  uint64_t v231;
  int16x8_t *v232;
  float32x4_t *v233;
  float32x4_t v234;
  uint64_t v235;
  int16x8_t v236;
  float32x4_t v237;
  float32x4_t v238;
  uint64_t v239;
  float *v240;
  __int16 *v241;
  int v242;
  uint64_t v243;
  uint64_t v244;
  int v245;
  unint64_t v246;
  unint64_t v247;
  unint64_t v248;
  double v249;
  uint64_t v250;
  unsigned int v251;
  unint64_t v252;
  const float *v253;
  uint64_t v254;
  const float *v255;
  float64x2_t v256;
  float64x2_t v257;
  float64x2_t v258;
  float64x2_t v259;
  float64x2_t v260;
  float64x2_t v261;
  float64x2_t v262;
  float64x2_t v263;
  float64x2_t v264;
  float64x2_t v265;
  float *v266;
  double v267;
  float v268;
  float v269;
  uint64_t v270;
  int v271;
  uint64_t v272;
  uint64_t v273;
  float *v274;
  uint64_t v275;
  float *v276;
  float v277;
  unint64_t v278;
  unint64_t v279;
  unint64_t v280;
  double v281;
  int v282;
  unint64_t v283;
  const float *v284;
  uint64_t v285;
  const float *v286;
  float64x2_t v287;
  float64x2_t v288;
  float64x2_t v289;
  float64x2_t v290;
  float64x2_t v291;
  float64x2_t v292;
  float64x2_t v293;
  float64x2_t v294;
  float64x2_t v295;
  float64x2_t v296;
  float *v297;
  double v298;
  float v299;
  float v300;
  uint64_t v301;
  int v302;
  uint64_t v303;
  uint64_t v304;
  float *v305;
  uint64_t v306;
  float *v307;
  float v308;
  float v309;
  int16x8_t *v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  int16x8_t *v314;
  float32x4_t *v315;
  float32x4_t v316;
  uint64_t v317;
  int16x8_t v318;
  float32x4_t v319;
  float32x4_t v320;
  uint64_t v321;
  float *v322;
  __int16 *v323;
  int v324;
  uint64_t v325;
  int v326;
  unint64_t v327;
  unint64_t v328;
  unint64_t v329;
  double v330;
  uint64_t v331;
  unsigned int v332;
  unint64_t v333;
  const float *v334;
  uint64_t v335;
  const float *v336;
  float64x2_t v337;
  float64x2_t v338;
  float64x2_t v339;
  float64x2_t v340;
  float64x2_t v341;
  float64x2_t v342;
  float64x2_t v343;
  float64x2_t v344;
  float64x2_t v345;
  float64x2_t v346;
  float *v347;
  double v348;
  float v349;
  float v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  float *v356;
  uint64_t v357;
  float *v358;
  float v359;
  unint64_t v360;
  unint64_t v361;
  unint64_t v362;
  double v363;
  int v364;
  unint64_t v365;
  const float *v366;
  uint64_t v367;
  const float *v368;
  float64x2_t v369;
  float64x2_t v370;
  float64x2_t v371;
  float64x2_t v372;
  float64x2_t v373;
  float64x2_t v374;
  float64x2_t v375;
  float64x2_t v376;
  float64x2_t v377;
  float64x2_t v378;
  float *v379;
  double v380;
  float v381;
  float v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  float *v388;
  uint64_t v389;
  float *v390;
  float v391;
  float v392;
  int v393;
  int16x8_t *v394;
  float32x4_t *v395;
  uint64_t v396;
  float v397;
  int16x8_t v398[96];
  _BYTE v399[1520];
  float32x4_t v400[2];
  _BYTE v401[32];
  __int16 __dst[8];
  _BYTE v403[16];
  float32x4_t v404[4];
  int16x8_t v405;
  _QWORD v406[8];
  float32x2x4_t v407;
  float32x2x4_t v408;
  float32x2x4_t v409;
  float32x2x4_t v410;
  float32x2x4_t v411;
  float32x2x4_t v412;
  float32x2x4_t v413;
  float32x2x4_t v414;
  float32x2x4_t v415;
  float32x2x4_t v416;
  float32x2x4_t v417;
  float32x2x4_t v418;
  float32x2x4_t v419;
  float32x2x4_t v420;
  float32x2x4_t v421;
  float32x2x4_t v422;

  v406[6] = *MEMORY[0x24BDAC8D0];
  v8 = (int16x8_t *)(a1 + 4516);
  v9 = *(_DWORD *)(a1 + 4588);
  v10 = *(_DWORD *)(a1 + 4640);
  v11 = v10 + v9;
  *(_BYTE *)(a1 + 4783) = 4;
  v12 = silk_burg_modified_FLP(v404, a3, v10 + v9, *(_DWORD *)(a1 + 4580), v10, a4);
  if (!*(_DWORD *)(a1 + 4632) || *(_DWORD *)(a1 + 4664) || *(_DWORD *)(a1 + 4580) != 4)
    goto LABEL_235;
  v13 = v12;
  v14 = silk_burg_modified_FLP(v400, a3 + 8 * v11, v10 + v9, 2, *(_DWORD *)(a1 + 4640), a4);
  v15 = *(_DWORD *)(a1 + 4640);
  if (v15 >= 1)
  {
    v16 = v398;
    v17 = v400;
    v18 = *(unsigned int *)(a1 + 4640);
    do
    {
      v19 = v17->f32[0];
      v17 = (float32x4_t *)((char *)v17 + 4);
      v16->i32[0] = (uint64_t)rintf(v19 * 65536.0);
      v16 = (int16x8_t *)((char *)v16 + 4);
      --v18;
    }
    while (v18);
  }
  silk_A2NLSF(a2, v398[0].i32, v15);
  v20 = *(unsigned int *)(a1 + 4640);
  if ((int)v20 <= 0)
  {
    silk_NLSF2A(v398, __dst, *(_DWORD *)(a1 + 4640));
    goto LABEL_23;
  }
  if (v20 < 0x10)
  {
    v21 = 0;
LABEL_14:
    v31 = v20 - v21;
    v32 = v21;
    v33 = &__dst[v21];
    v34 = &a2->i16[v32];
    v35 = (__int16 *)(v32 * 2 + a1 + 4500);
    do
    {
      v37 = *v35++;
      v36 = v37;
      v38 = *v34++;
      *v33++ = v36 + ((3 * (__int16)(v38 - v36)) >> 2);
      --v31;
    }
    while (v31);
    goto LABEL_16;
  }
  v21 = v20 & 0x7FFFFFF0;
  v22 = a2 + 1;
  v23 = (int16x8_t *)v403;
  v24.i64[0] = 0x3000300030003;
  v24.i64[1] = 0x3000300030003;
  v25 = v20 & 0xFFFFFFF0;
  v26 = v8;
  do
  {
    v27 = v26[-1];
    v28 = vsubq_s16(v22[-1], v27);
    v29 = vsubq_s16(*v22, *v26);
    v30 = vaddq_s16(*v26, vshrn_high_n_s32(vshrn_n_s32(vmull_s16(*(int16x4_t *)v29.i8, (int16x4_t)0x3000300030003), 2uLL), vmull_high_s16(v29, v24), 2uLL));
    v23[-1] = vaddq_s16(v27, vshrn_high_n_s32(vshrn_n_s32(vmull_s16(*(int16x4_t *)v28.i8, (int16x4_t)0x3000300030003), 2uLL), vmull_high_s16(v28, v24), 2uLL));
    *v23 = v30;
    v26 += 2;
    v22 += 2;
    v23 += 2;
    v25 -= 16;
  }
  while (v25);
  if (v21 != v20)
    goto LABEL_14;
LABEL_16:
  silk_NLSF2A(v398, __dst, v20);
  if (v20 < 0x10)
  {
    v39 = 0;
LABEL_21:
    v47 = v20 - v39;
    v48 = &v400[0].f32[v39];
    v49 = &v398[0].i16[v39];
    do
    {
      v50 = *v49++;
      *v48++ = (float)v50 * 0.00024414;
      --v47;
    }
    while (v47);
    goto LABEL_23;
  }
  v39 = v20 & 0x7FFFFFF0;
  v40 = (int16x8_t *)v399;
  v41 = (float32x4_t *)v401;
  v42 = (float32x4_t)vdupq_n_s32(0x39800000u);
  v43 = v20 & 0xFFFFFFF0;
  do
  {
    v44 = v40[-1];
    v45 = vcvtq_f32_s32(vmovl_high_s16(*v40));
    v46 = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v40->i8)), v42);
    v41[-2] = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v44.i8)), v42);
    v41[-1] = vmulq_f32(vcvtq_f32_s32(vmovl_high_s16(v44)), v42);
    *v41 = v46;
    v41[1] = vmulq_f32(v45, v42);
    v41 += 4;
    v40 += 2;
    v43 -= 16;
  }
  while (v43);
  if (v39 != v20)
    goto LABEL_21;
LABEL_23:
  silk_LPC_analysis_filter_FLP((float *)v398[0].i32, v400[0].f32, a3, 2 * v11, *(_DWORD *)(a1 + 4640));
  v51 = *(int *)(a1 + 4640);
  v52 = v11 - v51;
  if (v11 - (int)v51 >= 4)
  {
    v53 = (v52 - 3);
    v54 = 4;
    if (v53 > 4)
      v54 = (v52 - 3);
    if (v54 >= 0xD)
    {
      v58 = ((v54 - 1) >> 2) + 1;
      v55 = 4 * (v58 & 0x7FFFFFFFFFFFFFFCLL);
      v59 = (const float *)&v399[4 * v51 + 16];
      v56 = 0.0;
      v60 = v58 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v61 = v59 - 8;
        v407 = vld4_f32(v61);
        v415 = vld4_f32(v59);
        v62 = vcvtq_f64_f32(v407.val[0]);
        v63 = vcvtq_f64_f32(v415.val[0]);
        v64 = vcvtq_f64_f32(v407.val[1]);
        v65 = vcvtq_f64_f32(v415.val[1]);
        v66 = vmlaq_f64(vmulq_f64(v64, v64), v62, v62);
        v67 = vmlaq_f64(vmulq_f64(v65, v65), v63, v63);
        v68 = vcvtq_f64_f32(v407.val[2]);
        v69 = vcvtq_f64_f32(v415.val[2]);
        *(float64x2_t *)v407.val[0].f32 = vcvtq_f64_f32(v407.val[3]);
        *(float64x2_t *)v407.val[1].f32 = vcvtq_f64_f32(v415.val[3]);
        v70 = vmlaq_f64(vmlaq_f64(v66, v68, v68), *(float64x2_t *)v407.val[0].f32, *(float64x2_t *)v407.val[0].f32);
        v71 = vmlaq_f64(vmlaq_f64(v67, v69, v69), *(float64x2_t *)v407.val[1].f32, *(float64x2_t *)v407.val[1].f32);
        v56 = v56 + v70.f64[0] + v70.f64[1] + v71.f64[0] + v71.f64[1];
        v59 += 16;
        v60 -= 4;
      }
      while (v60);
      if (v58 == (v58 & 0x7FFFFFFFFFFFFFFCLL))
      {
LABEL_35:
        v57 = v52 & 0xFFFFFFFC;
        if ((int)(v52 & 0xFFFFFFFC) >= v52)
          goto LABEL_43;
        goto LABEL_36;
      }
    }
    else
    {
      v55 = 0;
      v56 = 0.0;
    }
    v72 = (float *)&v398[v55 / 4].i32[v51 + 2];
    do
    {
      v73 = *(v72 - 1) * *(v72 - 1) + *(v72 - 2) * *(v72 - 2);
      v74 = *v72;
      v75 = v72[1];
      v72 += 4;
      v56 = v56 + v73 + v74 * v74 + v75 * v75;
      v55 += 4;
    }
    while (v55 < v53);
    goto LABEL_35;
  }
  v57 = 0;
  v56 = 0.0;
  if (v52 <= 0)
    goto LABEL_43;
LABEL_36:
  v76 = v57;
  v77 = v9 + v10 + ~v57 - v51;
  if (!(_DWORD)v77)
  {
    v78 = v76;
LABEL_41:
    v83 = (float *)&v398[0].i32[v78 + v51];
    do
    {
      v84 = *v83++;
      v56 = v56 + v84 * v84;
      LODWORD(v78) = v78 + 1;
    }
    while (v52 > (int)v78);
    goto LABEL_43;
  }
  v79 = v77 + 1;
  v80 = (v77 + 1) & 0x1FFFFFFFELL;
  v78 = v80 + v76;
  v81 = (float *)&v398[0].i32[v51 + 1 + v76];
  v82 = v80;
  do
  {
    v56 = v56 + *(v81 - 1) * *(v81 - 1) + *v81 * *v81;
    v81 += 2;
    v82 -= 2;
  }
  while (v82);
  if (v79 != v80)
    goto LABEL_41;
LABEL_43:
  v85 = *(unsigned int *)(a1 + 4640);
  if (v52 >= 4)
  {
    v86 = (v52 - 3);
    v87 = 4;
    if (v86 > 4)
      v87 = (v52 - 3);
    if (v87 >= 0xD)
    {
      v92 = ((v87 - 1) >> 2) + 1;
      v88 = 4 * (v92 & 0x7FFFFFFFFFFFFFFCLL);
      v93 = (const float *)&v398[2].i32[v11 + v51];
      v89 = 0.0;
      v94 = v92 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v95 = v93 - 8;
        v411 = vld4_f32(v95);
        v416 = vld4_f32(v93);
        v96 = vcvtq_f64_f32(v411.val[0]);
        v97 = vcvtq_f64_f32(v416.val[0]);
        v98 = vcvtq_f64_f32(v411.val[1]);
        v99 = vcvtq_f64_f32(v416.val[1]);
        v100 = vmlaq_f64(vmulq_f64(v98, v98), v96, v96);
        v101 = vmlaq_f64(vmulq_f64(v99, v99), v97, v97);
        v102 = vcvtq_f64_f32(v411.val[2]);
        v103 = vcvtq_f64_f32(v416.val[2]);
        *(float64x2_t *)v411.val[0].f32 = vcvtq_f64_f32(v411.val[3]);
        *(float64x2_t *)v411.val[1].f32 = vcvtq_f64_f32(v416.val[3]);
        v104 = vmlaq_f64(vmlaq_f64(v100, v102, v102), *(float64x2_t *)v411.val[0].f32, *(float64x2_t *)v411.val[0].f32);
        v105 = vmlaq_f64(vmlaq_f64(v101, v103, v103), *(float64x2_t *)v411.val[1].f32, *(float64x2_t *)v411.val[1].f32);
        v89 = v89 + v104.f64[0] + v104.f64[1] + v105.f64[0] + v105.f64[1];
        v93 += 16;
        v94 -= 4;
      }
      while (v94);
      if (v92 == (v92 & 0x7FFFFFFFFFFFFFFCLL))
      {
LABEL_55:
        v90 = v52 & 0x7FFFFFFC;
        v91 = v13 - v14;
        if ((int)(v52 & 0xFFFFFFFC) >= v52)
          goto LABEL_63;
        goto LABEL_56;
      }
    }
    else
    {
      v88 = 0;
      v89 = 0.0;
    }
    v106 = (float *)&v398[v88 / 4].i32[v11 + 2 + v51];
    do
    {
      v107 = *(v106 - 1) * *(v106 - 1) + *(v106 - 2) * *(v106 - 2);
      v108 = *v106;
      v109 = v106[1];
      v106 += 4;
      v89 = v89 + v107 + v108 * v108 + v109 * v109;
      v88 += 4;
    }
    while (v88 < v86);
    goto LABEL_55;
  }
  v90 = 0;
  v89 = 0.0;
  v91 = v13 - v14;
  if (v52 <= 0)
    goto LABEL_63;
LABEL_56:
  v110 = v90;
  v111 = v9 + v10 + ~v90 - v51;
  if (!(_DWORD)v111)
  {
    v112 = v110;
LABEL_61:
    v117 = (float *)&v398[0].i32[v112 + v11 + v51];
    do
    {
      v118 = *v117++;
      v89 = v89 + v118 * v118;
      LODWORD(v112) = v112 + 1;
    }
    while (v52 > (int)v112);
    goto LABEL_63;
  }
  v113 = v111 + 1;
  v114 = (v111 + 1) & 0x1FFFFFFFELL;
  v112 = v114 + v110;
  v115 = (float *)&v398[0].i32[v11 + 1 + v51 + v110];
  v116 = v114;
  do
  {
    v89 = v89 + *(v115 - 1) * *(v115 - 1) + *v115 * *v115;
    v115 += 2;
    v116 -= 2;
  }
  while (v116);
  if (v113 != v114)
    goto LABEL_61;
LABEL_63:
  v119 = v56 + v89;
  v120 = v119;
  if (v91 <= v120)
  {
    if (v120 > 3.4028e38)
      goto LABEL_235;
  }
  else
  {
    v8[16].i8[11] = 3;
    v91 = v119;
  }
  if ((int)v51 <= 0)
  {
    silk_NLSF2A(&v405, __dst, v51);
    goto LABEL_82;
  }
  if (v51 < 0x10)
  {
    v121 = 0;
LABEL_73:
    v127 = v85 - v121;
    v128 = v121;
    v129 = &__dst[v121];
    v130 = &a2->i16[v128];
    v131 = (__int16 *)(v128 * 2 + a1 + 4500);
    do
    {
      v133 = *v131++;
      v132 = v133;
      v134 = *v130++;
      *v129++ = v132 + ((__int16)(v134 - v132) >> 1);
      --v127;
    }
    while (v127);
    goto LABEL_75;
  }
  v121 = v51 & 0xFFFFFFF0;
  v122 = a2 + 1;
  v123 = (int16x8_t *)v403;
  v124 = v85 & 0xFFFFFFF0;
  v125 = v8;
  do
  {
    v126 = vsraq_n_s16(*v125, vsubq_s16(*v122, *v125), 1uLL);
    v123[-1] = vsraq_n_s16(v125[-1], vsubq_s16(v122[-1], v125[-1]), 1uLL);
    *v123 = v126;
    v125 += 2;
    v122 += 2;
    v123 += 2;
    v124 -= 16;
  }
  while (v124);
  if (v121 != v85)
    goto LABEL_73;
LABEL_75:
  silk_NLSF2A(&v405, __dst, v85);
  if (v85 < 0x10)
  {
    v135 = 0;
LABEL_80:
    v143 = v85 - v135;
    v144 = &v400[0].f32[v135];
    v145 = &v405.i16[v135];
    do
    {
      v146 = *v145++;
      *v144++ = (float)v146 * 0.00024414;
      --v143;
    }
    while (v143);
    goto LABEL_82;
  }
  v135 = v85 & 0xFFFFFFF0;
  v136 = (int16x8_t *)v406;
  v137 = (float32x4_t *)v401;
  v138 = (float32x4_t)vdupq_n_s32(0x39800000u);
  v139 = v135;
  do
  {
    v140 = v136[-1];
    v141 = vcvtq_f32_s32(vmovl_high_s16(*v136));
    v142 = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v136->i8)), v138);
    v137[-2] = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v140.i8)), v138);
    v137[-1] = vmulq_f32(vcvtq_f32_s32(vmovl_high_s16(v140)), v138);
    *v137 = v142;
    v137[1] = vmulq_f32(v141, v138);
    v137 += 4;
    v136 += 2;
    v139 -= 16;
  }
  while (v139);
  if (v135 != v85)
    goto LABEL_80;
LABEL_82:
  silk_LPC_analysis_filter_FLP((float *)v398[0].i32, v400[0].f32, a3, 2 * v11, *(_DWORD *)(a1 + 4640));
  v147 = *(int *)(a1 + 4640);
  v148 = v11 - v147;
  if (v11 - (int)v147 >= 4)
  {
    v149 = (v148 - 3);
    v150 = 4;
    if (v149 > 4)
      v150 = (v148 - 3);
    v151 = v11;
    if (v150 >= 0xD)
    {
      v155 = ((v150 - 1) >> 2) + 1;
      v152 = 4 * (v155 & 0x7FFFFFFFFFFFFFFCLL);
      v156 = (const float *)&v399[4 * v147 + 16];
      v153 = 0.0;
      v157 = v155 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v158 = v156 - 8;
        v408 = vld4_f32(v158);
        v417 = vld4_f32(v156);
        v159 = vcvtq_f64_f32(v408.val[0]);
        v160 = vcvtq_f64_f32(v417.val[0]);
        v161 = vcvtq_f64_f32(v408.val[1]);
        v162 = vcvtq_f64_f32(v417.val[1]);
        v163 = vmlaq_f64(vmulq_f64(v161, v161), v159, v159);
        v164 = vmlaq_f64(vmulq_f64(v162, v162), v160, v160);
        v165 = vcvtq_f64_f32(v408.val[2]);
        v166 = vcvtq_f64_f32(v417.val[2]);
        *(float64x2_t *)v408.val[0].f32 = vcvtq_f64_f32(v408.val[3]);
        *(float64x2_t *)v408.val[1].f32 = vcvtq_f64_f32(v417.val[3]);
        v167 = vmlaq_f64(vmlaq_f64(v163, v165, v165), *(float64x2_t *)v408.val[0].f32, *(float64x2_t *)v408.val[0].f32);
        v168 = vmlaq_f64(vmlaq_f64(v164, v166, v166), *(float64x2_t *)v408.val[1].f32, *(float64x2_t *)v408.val[1].f32);
        v153 = v153 + v167.f64[0] + v167.f64[1] + v168.f64[0] + v168.f64[1];
        v156 += 16;
        v157 -= 4;
      }
      while (v157);
      if (v155 == (v155 & 0x7FFFFFFFFFFFFFFCLL))
      {
LABEL_94:
        v154 = v148 & 0xFFFFFFFC;
        if ((int)(v148 & 0xFFFFFFFC) >= v148)
          goto LABEL_102;
        goto LABEL_95;
      }
    }
    else
    {
      v152 = 0;
      v153 = 0.0;
    }
    v169 = (float *)&v398[v152 / 4].i32[v147 + 2];
    do
    {
      v170 = *(v169 - 1) * *(v169 - 1) + *(v169 - 2) * *(v169 - 2);
      v171 = *v169;
      v172 = v169[1];
      v169 += 4;
      v153 = v153 + v170 + v171 * v171 + v172 * v172;
      v152 += 4;
    }
    while (v152 < v149);
    goto LABEL_94;
  }
  v154 = 0;
  v153 = 0.0;
  v151 = v11;
  if (v148 <= 0)
    goto LABEL_102;
LABEL_95:
  v173 = v154;
  v174 = v9 + v10 + ~v154 - v147;
  if (!(_DWORD)v174)
  {
    v175 = v173;
LABEL_100:
    v180 = (float *)&v398[0].i32[v175 + v147];
    do
    {
      v181 = *v180++;
      v153 = v153 + v181 * v181;
      LODWORD(v175) = v175 + 1;
    }
    while (v148 > (int)v175);
    goto LABEL_102;
  }
  v176 = v174 + 1;
  v177 = (v174 + 1) & 0x1FFFFFFFELL;
  v175 = v177 + v173;
  v178 = (float *)&v398[0].i32[v147 + 1 + v173];
  v179 = v177;
  do
  {
    v153 = v153 + *(v178 - 1) * *(v178 - 1) + *v178 * *v178;
    v178 += 2;
    v179 -= 2;
  }
  while (v179);
  if (v176 != v177)
    goto LABEL_100;
LABEL_102:
  v182 = *(unsigned int *)(a1 + 4640);
  if (v148 >= 4)
  {
    v183 = (v148 - 3);
    v184 = 4;
    if (v183 > 4)
      v184 = (v148 - 3);
    if (v184 >= 0xD)
    {
      v188 = ((v184 - 1) >> 2) + 1;
      v185 = 4 * (v188 & 0x7FFFFFFFFFFFFFFCLL);
      v189 = (const float *)&v398[2].i32[v151 + v147];
      v186 = 0.0;
      v190 = v188 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v191 = v189 - 8;
        v412 = vld4_f32(v191);
        v418 = vld4_f32(v189);
        v192 = vcvtq_f64_f32(v412.val[0]);
        v193 = vcvtq_f64_f32(v418.val[0]);
        v194 = vcvtq_f64_f32(v412.val[1]);
        v195 = vcvtq_f64_f32(v418.val[1]);
        v196 = vmlaq_f64(vmulq_f64(v194, v194), v192, v192);
        v197 = vmlaq_f64(vmulq_f64(v195, v195), v193, v193);
        v198 = vcvtq_f64_f32(v412.val[2]);
        v199 = vcvtq_f64_f32(v418.val[2]);
        *(float64x2_t *)v412.val[0].f32 = vcvtq_f64_f32(v412.val[3]);
        *(float64x2_t *)v412.val[1].f32 = vcvtq_f64_f32(v418.val[3]);
        v200 = vmlaq_f64(vmlaq_f64(v196, v198, v198), *(float64x2_t *)v412.val[0].f32, *(float64x2_t *)v412.val[0].f32);
        v201 = vmlaq_f64(vmlaq_f64(v197, v199, v199), *(float64x2_t *)v412.val[1].f32, *(float64x2_t *)v412.val[1].f32);
        v186 = v186 + v200.f64[0] + v200.f64[1] + v201.f64[0] + v201.f64[1];
        v189 += 16;
        v190 -= 4;
      }
      while (v190);
      if (v188 == (v188 & 0x7FFFFFFFFFFFFFFCLL))
      {
LABEL_114:
        v187 = v148 & 0x7FFFFFFC;
        if ((int)(v148 & 0xFFFFFFFC) >= v148)
          goto LABEL_122;
        goto LABEL_115;
      }
    }
    else
    {
      v185 = 0;
      v186 = 0.0;
    }
    v202 = (float *)&v398[v185 / 4].i32[v151 + 2 + v147];
    do
    {
      v203 = *(v202 - 1) * *(v202 - 1) + *(v202 - 2) * *(v202 - 2);
      v204 = *v202;
      v205 = v202[1];
      v202 += 4;
      v186 = v186 + v203 + v204 * v204 + v205 * v205;
      v185 += 4;
    }
    while (v185 < v183);
    goto LABEL_114;
  }
  v187 = 0;
  v186 = 0.0;
  if (v148 <= 0)
    goto LABEL_122;
LABEL_115:
  v206 = v187;
  v207 = v9 + v10 + ~v187 - v147;
  if (!(_DWORD)v207)
  {
    v208 = v206;
LABEL_120:
    v213 = (float *)&v398[0].i32[v208 + v151 + v147];
    do
    {
      v214 = *v213++;
      v186 = v186 + v214 * v214;
      LODWORD(v208) = v208 + 1;
    }
    while (v148 > (int)v208);
    goto LABEL_122;
  }
  v209 = v207 + 1;
  v210 = (v207 + 1) & 0x1FFFFFFFELL;
  v208 = v210 + v206;
  v211 = (float *)&v398[0].i32[v151 + 1 + v147 + v206];
  v212 = v210;
  do
  {
    v186 = v186 + *(v211 - 1) * *(v211 - 1) + *v211 * *v211;
    v211 += 2;
    v212 -= 2;
  }
  while (v212);
  if (v209 != v210)
    goto LABEL_120;
LABEL_122:
  v215 = v153 + v186;
  v216 = v215;
  if (v91 <= v216)
  {
    if (v120 < v216)
      goto LABEL_235;
  }
  else
  {
    v8[16].i8[11] = 2;
    v91 = v215;
  }
  if ((int)v147 <= 0)
  {
    silk_NLSF2A(&v405, __dst, v147);
    goto LABEL_141;
  }
  if (v147 < 0x10)
  {
    v217 = 0;
LABEL_132:
    v223 = v182 - v217;
    v224 = v217;
    v225 = &__dst[v217];
    v226 = &a2->i16[v224];
    v227 = (__int16 *)(v224 * 2 + a1 + 4500);
    do
    {
      v229 = *v227++;
      v228 = v229;
      v230 = *v226++;
      *v225++ = v228 + ((__int16)(v230 - v228) >> 2);
      --v223;
    }
    while (v223);
    goto LABEL_134;
  }
  v217 = v147 & 0x7FFFFFF0;
  v218 = a2 + 1;
  v219 = (int16x8_t *)v403;
  v220 = v182 & 0xFFFFFFF0;
  v221 = v8;
  do
  {
    v222 = vsraq_n_s16(*v221, vsubq_s16(*v218, *v221), 2uLL);
    v219[-1] = vsraq_n_s16(v221[-1], vsubq_s16(v218[-1], v221[-1]), 2uLL);
    *v219 = v222;
    v221 += 2;
    v218 += 2;
    v219 += 2;
    v220 -= 16;
  }
  while (v220);
  if (v217 != v182)
    goto LABEL_132;
LABEL_134:
  silk_NLSF2A(&v405, __dst, v182);
  if (v182 < 0x10)
  {
    v231 = 0;
LABEL_139:
    v239 = v182 - v231;
    v240 = &v400[0].f32[v231];
    v241 = &v405.i16[v231];
    do
    {
      v242 = *v241++;
      *v240++ = (float)v242 * 0.00024414;
      --v239;
    }
    while (v239);
    goto LABEL_141;
  }
  v231 = v182 & 0xFFFFFFF0;
  v232 = (int16x8_t *)v406;
  v233 = (float32x4_t *)v401;
  v234 = (float32x4_t)vdupq_n_s32(0x39800000u);
  v235 = v231;
  do
  {
    v236 = v232[-1];
    v237 = vcvtq_f32_s32(vmovl_high_s16(*v232));
    v238 = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v232->i8)), v234);
    v233[-2] = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v236.i8)), v234);
    v233[-1] = vmulq_f32(vcvtq_f32_s32(vmovl_high_s16(v236)), v234);
    *v233 = v238;
    v233[1] = vmulq_f32(v237, v234);
    v233 += 4;
    v232 += 2;
    v235 -= 16;
  }
  while (v235);
  if (v231 != v182)
    goto LABEL_139;
LABEL_141:
  silk_LPC_analysis_filter_FLP((float *)v398[0].i32, v400[0].f32, a3, 2 * v11, *(_DWORD *)(a1 + 4640));
  v243 = *(int *)(a1 + 4640);
  v244 = *(unsigned int *)(a1 + 4640);
  v245 = v11 - v243;
  if (v11 - (int)v243 < 4)
  {
    v251 = 0;
    v249 = 0.0;
    v250 = v11;
    goto LABEL_153;
  }
  v246 = (v245 - 3);
  v247 = 4;
  if (v246 > 4)
    v247 = (v245 - 3);
  if (v247 >= 0xD)
  {
    v252 = ((v247 - 1) >> 2) + 1;
    v248 = 4 * (v252 & 0x7FFFFFFFFFFFFFFCLL);
    v253 = (const float *)&v399[4 * v243 + 16];
    v249 = 0.0;
    v254 = v252 & 0x7FFFFFFFFFFFFFFCLL;
    do
    {
      v255 = v253 - 8;
      v409 = vld4_f32(v255);
      v419 = vld4_f32(v253);
      v256 = vcvtq_f64_f32(v409.val[0]);
      v257 = vcvtq_f64_f32(v419.val[0]);
      v258 = vcvtq_f64_f32(v409.val[1]);
      v259 = vcvtq_f64_f32(v419.val[1]);
      v260 = vmlaq_f64(vmulq_f64(v258, v258), v256, v256);
      v261 = vmlaq_f64(vmulq_f64(v259, v259), v257, v257);
      v262 = vcvtq_f64_f32(v409.val[2]);
      v263 = vcvtq_f64_f32(v419.val[2]);
      *(float64x2_t *)v409.val[0].f32 = vcvtq_f64_f32(v409.val[3]);
      *(float64x2_t *)v409.val[1].f32 = vcvtq_f64_f32(v419.val[3]);
      v264 = vmlaq_f64(vmlaq_f64(v260, v262, v262), *(float64x2_t *)v409.val[0].f32, *(float64x2_t *)v409.val[0].f32);
      v265 = vmlaq_f64(vmlaq_f64(v261, v263, v263), *(float64x2_t *)v409.val[1].f32, *(float64x2_t *)v409.val[1].f32);
      v249 = v249 + v264.f64[0] + v264.f64[1] + v265.f64[0] + v265.f64[1];
      v253 += 16;
      v254 -= 4;
    }
    while (v254);
    v250 = v11;
    if (v252 == (v252 & 0x7FFFFFFFFFFFFFFCLL))
      goto LABEL_152;
  }
  else
  {
    v248 = 0;
    v249 = 0.0;
    v250 = v11;
  }
  v266 = (float *)&v398[v248 / 4].i32[v243 + 2];
  do
  {
    v267 = *(v266 - 1) * *(v266 - 1) + *(v266 - 2) * *(v266 - 2);
    v268 = *v266;
    v269 = v266[1];
    v266 += 4;
    v249 = v249 + v267 + v268 * v268 + v269 * v269;
    v248 += 4;
  }
  while (v248 < v246);
LABEL_152:
  v251 = v245 & 0xFFFFFFFC;
LABEL_153:
  if ((int)v251 >= v245)
    goto LABEL_161;
  v270 = v251;
  v271 = v9 + v10 + ~v251;
  if (v271 == (_DWORD)v243)
  {
    v272 = v270;
LABEL_159:
    v276 = (float *)&v398[0].i32[v272 + v243];
    do
    {
      v277 = *v276++;
      v249 = v249 + v277 * v277;
      LODWORD(v272) = v272 + 1;
    }
    while (v245 > (int)v272);
    goto LABEL_161;
  }
  v273 = (v271 - v244) + 1;
  v272 = (v273 & 0x1FFFFFFFELL) + v270;
  v274 = (float *)&v398[0].i32[v243 + 1 + v270];
  v275 = v273 & 0x1FFFFFFFELL;
  do
  {
    v249 = v249 + *(v274 - 1) * *(v274 - 1) + *v274 * *v274;
    v274 += 2;
    v275 -= 2;
  }
  while (v275);
  if (v273 != (v273 & 0x1FFFFFFFELL))
    goto LABEL_159;
LABEL_161:
  if (v245 < 4)
  {
    v282 = 0;
    v281 = 0.0;
    goto LABEL_173;
  }
  v278 = (v245 - 3);
  v279 = 4;
  if (v278 > 4)
    v279 = (v245 - 3);
  if (v279 >= 0xD)
  {
    v283 = ((v279 - 1) >> 2) + 1;
    v280 = 4 * (v283 & 0x7FFFFFFFFFFFFFFCLL);
    v284 = (const float *)&v398[2].i32[v250 + v243];
    v281 = 0.0;
    v285 = v283 & 0x7FFFFFFFFFFFFFFCLL;
    do
    {
      v286 = v284 - 8;
      v413 = vld4_f32(v286);
      v420 = vld4_f32(v284);
      v287 = vcvtq_f64_f32(v413.val[0]);
      v288 = vcvtq_f64_f32(v420.val[0]);
      v289 = vcvtq_f64_f32(v413.val[1]);
      v290 = vcvtq_f64_f32(v420.val[1]);
      v291 = vmlaq_f64(vmulq_f64(v289, v289), v287, v287);
      v292 = vmlaq_f64(vmulq_f64(v290, v290), v288, v288);
      v293 = vcvtq_f64_f32(v413.val[2]);
      v294 = vcvtq_f64_f32(v420.val[2]);
      *(float64x2_t *)v413.val[0].f32 = vcvtq_f64_f32(v413.val[3]);
      *(float64x2_t *)v413.val[1].f32 = vcvtq_f64_f32(v420.val[3]);
      v295 = vmlaq_f64(vmlaq_f64(v291, v293, v293), *(float64x2_t *)v413.val[0].f32, *(float64x2_t *)v413.val[0].f32);
      v296 = vmlaq_f64(vmlaq_f64(v292, v294, v294), *(float64x2_t *)v413.val[1].f32, *(float64x2_t *)v413.val[1].f32);
      v281 = v281 + v295.f64[0] + v295.f64[1] + v296.f64[0] + v296.f64[1];
      v284 += 16;
      v285 -= 4;
    }
    while (v285);
    if (v283 == (v283 & 0x7FFFFFFFFFFFFFFCLL))
      goto LABEL_172;
  }
  else
  {
    v280 = 0;
    v281 = 0.0;
  }
  v297 = (float *)&v398[v280 / 4].i32[v250 + 2 + v243];
  do
  {
    v298 = *(v297 - 1) * *(v297 - 1) + *(v297 - 2) * *(v297 - 2);
    v299 = *v297;
    v300 = v297[1];
    v297 += 4;
    v281 = v281 + v298 + v299 * v299 + v300 * v300;
    v280 += 4;
  }
  while (v280 < v278);
LABEL_172:
  v282 = v245 & 0x7FFFFFFC;
LABEL_173:
  if (v282 >= v245)
    goto LABEL_181;
  v301 = v282;
  v302 = v9 + v10 + ~v282;
  if (v302 == (_DWORD)v244)
  {
    v303 = v301;
LABEL_179:
    v307 = (float *)&v398[0].i32[v303 + v250 + v243];
    do
    {
      v308 = *v307++;
      v281 = v281 + v308 * v308;
      LODWORD(v303) = v303 + 1;
    }
    while (v245 > (int)v303);
    goto LABEL_181;
  }
  v304 = (v302 - v243) + 1;
  v303 = (v304 & 0x1FFFFFFFELL) + v301;
  v305 = (float *)&v398[0].i32[v250 + 1 + v243 + v301];
  v306 = v304 & 0x1FFFFFFFELL;
  do
  {
    v281 = v281 + *(v305 - 1) * *(v305 - 1) + *v305 * *v305;
    v305 += 2;
    v306 -= 2;
  }
  while (v306);
  if (v304 != (v304 & 0x1FFFFFFFELL))
    goto LABEL_179;
LABEL_181:
  v309 = v249 + v281;
  if (v91 <= v309)
  {
    if (v216 < v309)
      goto LABEL_235;
  }
  else
  {
    v8[16].i8[11] = 1;
    v91 = v309;
  }
  if ((int)v244 <= 0)
  {
    silk_NLSF2A(&v405, __dst, v243);
    goto LABEL_193;
  }
  v310 = a2;
  v311 = v244;
  memcpy(__dst, (const void *)(a1 + 4500), 2 * v244);
  silk_NLSF2A(&v405, __dst, v243);
  v312 = v311;
  if (v311 < 0x10)
  {
    v313 = 0;
    a2 = v310;
LABEL_191:
    v321 = v312 - v313;
    v322 = &v400[0].f32[v313];
    v323 = &v405.i16[v313];
    do
    {
      v324 = *v323++;
      *v322++ = (float)v324 * 0.00024414;
      --v321;
    }
    while (v321);
    goto LABEL_193;
  }
  v313 = v311 & 0x7FFFFFF0;
  v314 = (int16x8_t *)v406;
  v315 = (float32x4_t *)v401;
  v316 = (float32x4_t)vdupq_n_s32(0x39800000u);
  v317 = v311 & 0xFFFFFFF0;
  do
  {
    v318 = v314[-1];
    v319 = vcvtq_f32_s32(vmovl_high_s16(*v314));
    v320 = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v314->i8)), v316);
    v315[-2] = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v318.i8)), v316);
    v315[-1] = vmulq_f32(vcvtq_f32_s32(vmovl_high_s16(v318)), v316);
    *v315 = v320;
    v315[1] = vmulq_f32(v319, v316);
    v315 += 4;
    v314 += 2;
    v317 -= 16;
  }
  while (v317);
  a2 = v310;
  if (v313 != v312)
    goto LABEL_191;
LABEL_193:
  silk_LPC_analysis_filter_FLP((float *)v398[0].i32, v400[0].f32, a3, 2 * v11, *(_DWORD *)(a1 + 4640));
  v325 = *(int *)(a1 + 4640);
  v326 = v11 - v325;
  if (v11 - (int)v325 < 4)
  {
    v332 = 0;
    v330 = 0.0;
    v331 = v11;
    goto LABEL_205;
  }
  v327 = (v326 - 3);
  v328 = 4;
  if (v327 > 4)
    v328 = (v326 - 3);
  if (v328 >= 0xD)
  {
    v333 = ((v328 - 1) >> 2) + 1;
    v329 = 4 * (v333 & 0x7FFFFFFFFFFFFFFCLL);
    v334 = (const float *)&v399[4 * v325 + 16];
    v330 = 0.0;
    v335 = v333 & 0x7FFFFFFFFFFFFFFCLL;
    do
    {
      v336 = v334 - 8;
      v410 = vld4_f32(v336);
      v421 = vld4_f32(v334);
      v337 = vcvtq_f64_f32(v410.val[0]);
      v338 = vcvtq_f64_f32(v421.val[0]);
      v339 = vcvtq_f64_f32(v410.val[1]);
      v340 = vcvtq_f64_f32(v421.val[1]);
      v341 = vmlaq_f64(vmulq_f64(v339, v339), v337, v337);
      v342 = vmlaq_f64(vmulq_f64(v340, v340), v338, v338);
      v343 = vcvtq_f64_f32(v410.val[2]);
      v344 = vcvtq_f64_f32(v421.val[2]);
      *(float64x2_t *)v410.val[0].f32 = vcvtq_f64_f32(v410.val[3]);
      *(float64x2_t *)v410.val[1].f32 = vcvtq_f64_f32(v421.val[3]);
      v345 = vmlaq_f64(vmlaq_f64(v341, v343, v343), *(float64x2_t *)v410.val[0].f32, *(float64x2_t *)v410.val[0].f32);
      v346 = vmlaq_f64(vmlaq_f64(v342, v344, v344), *(float64x2_t *)v410.val[1].f32, *(float64x2_t *)v410.val[1].f32);
      v330 = v330 + v345.f64[0] + v345.f64[1] + v346.f64[0] + v346.f64[1];
      v334 += 16;
      v335 -= 4;
    }
    while (v335);
    v331 = v11;
    if (v333 == (v333 & 0x7FFFFFFFFFFFFFFCLL))
      goto LABEL_204;
  }
  else
  {
    v329 = 0;
    v330 = 0.0;
    v331 = v11;
  }
  v347 = (float *)&v398[v329 / 4].i32[v325 + 2];
  do
  {
    v348 = *(v347 - 1) * *(v347 - 1) + *(v347 - 2) * *(v347 - 2);
    v349 = *v347;
    v350 = v347[1];
    v347 += 4;
    v330 = v330 + v348 + v349 * v349 + v350 * v350;
    v329 += 4;
  }
  while (v329 < v327);
LABEL_204:
  v332 = v326 & 0xFFFFFFFC;
LABEL_205:
  if ((int)v332 >= v326)
    goto LABEL_213;
  v351 = v332;
  v352 = v9 + v10 + ~v332 - v325;
  if (!(_DWORD)v352)
  {
    v353 = v351;
LABEL_211:
    v358 = (float *)&v398[0].i32[v353 + v325];
    do
    {
      v359 = *v358++;
      v330 = v330 + v359 * v359;
      LODWORD(v353) = v353 + 1;
    }
    while (v326 > (int)v353);
    goto LABEL_213;
  }
  v354 = v352 + 1;
  v355 = (v352 + 1) & 0x1FFFFFFFELL;
  v353 = v355 + v351;
  v356 = (float *)&v398[0].i32[v325 + 1 + v351];
  v357 = v355;
  do
  {
    v330 = v330 + *(v356 - 1) * *(v356 - 1) + *v356 * *v356;
    v356 += 2;
    v357 -= 2;
  }
  while (v357);
  if (v354 != v355)
    goto LABEL_211;
LABEL_213:
  if (v326 < 4)
  {
    v364 = 0;
    v363 = 0.0;
    goto LABEL_225;
  }
  v360 = (v326 - 3);
  v361 = 4;
  if (v360 > 4)
    v361 = (v326 - 3);
  if (v361 >= 0xD)
  {
    v365 = ((v361 - 1) >> 2) + 1;
    v362 = 4 * (v365 & 0x7FFFFFFFFFFFFFFCLL);
    v366 = (const float *)&v398[2].i32[v331 + v325];
    v363 = 0.0;
    v367 = v365 & 0x7FFFFFFFFFFFFFFCLL;
    do
    {
      v368 = v366 - 8;
      v414 = vld4_f32(v368);
      v422 = vld4_f32(v366);
      v369 = vcvtq_f64_f32(v414.val[0]);
      v370 = vcvtq_f64_f32(v422.val[0]);
      v371 = vcvtq_f64_f32(v414.val[1]);
      v372 = vcvtq_f64_f32(v422.val[1]);
      v373 = vmlaq_f64(vmulq_f64(v371, v371), v369, v369);
      v374 = vmlaq_f64(vmulq_f64(v372, v372), v370, v370);
      v375 = vcvtq_f64_f32(v414.val[2]);
      v376 = vcvtq_f64_f32(v422.val[2]);
      *(float64x2_t *)v414.val[0].f32 = vcvtq_f64_f32(v414.val[3]);
      *(float64x2_t *)v414.val[1].f32 = vcvtq_f64_f32(v422.val[3]);
      v377 = vmlaq_f64(vmlaq_f64(v373, v375, v375), *(float64x2_t *)v414.val[0].f32, *(float64x2_t *)v414.val[0].f32);
      v378 = vmlaq_f64(vmlaq_f64(v374, v376, v376), *(float64x2_t *)v414.val[1].f32, *(float64x2_t *)v414.val[1].f32);
      v363 = v363 + v377.f64[0] + v377.f64[1] + v378.f64[0] + v378.f64[1];
      v366 += 16;
      v367 -= 4;
    }
    while (v367);
    if (v365 == (v365 & 0x7FFFFFFFFFFFFFFCLL))
      goto LABEL_224;
  }
  else
  {
    v362 = 0;
    v363 = 0.0;
  }
  v379 = (float *)&v398[v362 / 4].i32[v331 + 2 + v325];
  do
  {
    v380 = *(v379 - 1) * *(v379 - 1) + *(v379 - 2) * *(v379 - 2);
    v381 = *v379;
    v382 = v379[1];
    v379 += 4;
    v363 = v363 + v380 + v381 * v381 + v382 * v382;
    v362 += 4;
  }
  while (v362 < v360);
LABEL_224:
  v364 = v326 & 0x7FFFFFFC;
LABEL_225:
  if (v364 >= v326)
    goto LABEL_233;
  v383 = v364;
  v384 = v9 + v10 + ~v364 - v325;
  if (!(_DWORD)v384)
  {
    v385 = v383;
LABEL_231:
    v390 = (float *)&v398[0].i32[v385 + v331 + v325];
    do
    {
      v391 = *v390++;
      v363 = v363 + v391 * v391;
      LODWORD(v385) = v385 + 1;
    }
    while (v326 > (int)v385);
    goto LABEL_233;
  }
  v386 = v384 + 1;
  v387 = (v384 + 1) & 0x1FFFFFFFELL;
  v385 = v387 + v383;
  v388 = (float *)&v398[0].i32[v331 + 1 + v325 + v383];
  v389 = v387;
  do
  {
    v363 = v363 + *(v388 - 1) * *(v388 - 1) + *v388 * *v388;
    v388 += 2;
    v389 -= 2;
  }
  while (v389);
  if (v386 != v387)
    goto LABEL_231;
LABEL_233:
  v392 = v330 + v363;
  if (v91 > v392)
  {
    v8[16].i8[11] = 0;
    return;
  }
LABEL_235:
  if (v8[16].i8[11] == 4)
  {
    v393 = *(_DWORD *)(a1 + 4640);
    if (v393 >= 1)
    {
      v394 = &v405;
      v395 = v404;
      v396 = *(unsigned int *)(a1 + 4640);
      do
      {
        v397 = v395->f32[0];
        v395 = (float32x4_t *)((char *)v395 + 4);
        v394->i32[0] = (uint64_t)rintf(v397 * 65536.0);
        v394 = (int16x8_t *)((char *)v394 + 4);
        --v396;
      }
      while (v396);
    }
    silk_A2NLSF(a2, v405.i32, v393);
  }
}

void silk_find_LTP_FLP(float32x4_t *a1, float32x4_t *a2, float *a3, uint64_t a4, uint64_t a5, int a6)
{
  float *v7;
  uint64_t v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  const float *v14;
  uint64_t v15;
  float v16;
  float v17;
  float v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  uint64_t v22;
  unint64_t v23;
  double v24;
  signed int v25;
  uint64_t v26;
  const float *v27;
  const float *v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  uint64_t v44;
  float32x2x4_t v46;
  float32x2x4_t v47;

  if (a6 >= 1)
  {
    v7 = a3;
    v10 = 0;
    v11 = a5 + 5;
    v44 = a6;
    v12 = (a5 + 2);
    v43 = (a5 + 5) & 0xFFFFFFFC;
    v13 = 4;
    if (v12 > 4)
      v13 = (a5 + 2);
    v42 = v13;
    v41 = ((unint64_t)(v13 - 1) >> 2) + 1;
    v14 = a3 + 8;
    v15 = 4 * (int)a5;
    do
    {
      v22 = (uint64_t)&v7[-2 - *(int *)(a4 + 4 * v10)];
      silk_corrMatrix_FLP(v22, a5, 5u, a1->f32);
      silk_corrVector_FLP(v22, v7, a5, 5, a2->f32);
      if ((int)a5 < -1)
      {
        v25 = 0;
        v24 = 0.0;
      }
      else
      {
        if (v42 >= 0xD)
        {
          v24 = 0.0;
          v26 = v41 & 0x7FFFFFFFFFFFFFFCLL;
          v27 = v14;
          do
          {
            v28 = v27 - 8;
            v46 = vld4_f32(v28);
            v47 = vld4_f32(v27);
            v29 = vcvtq_f64_f32(v46.val[0]);
            v30 = vcvtq_f64_f32(v47.val[0]);
            v31 = vcvtq_f64_f32(v46.val[1]);
            v32 = vcvtq_f64_f32(v47.val[1]);
            v33 = vmlaq_f64(vmulq_f64(v31, v31), v29, v29);
            v34 = vmlaq_f64(vmulq_f64(v32, v32), v30, v30);
            v35 = vcvtq_f64_f32(v46.val[2]);
            v36 = vcvtq_f64_f32(v47.val[2]);
            *(float64x2_t *)v46.val[0].f32 = vcvtq_f64_f32(v46.val[3]);
            *(float64x2_t *)v46.val[1].f32 = vcvtq_f64_f32(v47.val[3]);
            v37 = vmlaq_f64(vmlaq_f64(v33, v35, v35), *(float64x2_t *)v46.val[0].f32, *(float64x2_t *)v46.val[0].f32);
            v38 = vmlaq_f64(vmlaq_f64(v34, v36, v36), *(float64x2_t *)v46.val[1].f32, *(float64x2_t *)v46.val[1].f32);
            v24 = v24 + v37.f64[0] + v37.f64[1] + v38.f64[0] + v38.f64[1];
            v27 += 16;
            v26 -= 4;
          }
          while (v26);
          v23 = 4 * (v41 & 0x7FFFFFFFFFFFFFFCLL);
          v25 = v43;
          if (v41 == (v41 & 0x7FFFFFFFFFFFFFFCLL))
            goto LABEL_18;
        }
        else
        {
          v23 = 0;
          v24 = 0.0;
        }
        v39 = 4 * v23 + 8;
        do
        {
          v24 = v24
              + v7[v23 + 1] * v7[v23 + 1]
              + *(float *)((char *)v7 + v39 - 8) * *(float *)((char *)v7 + v39 - 8)
              + *(float *)((char *)v7 + v39) * *(float *)((char *)v7 + v39)
              + *(float *)((char *)v7 + v39 + 4) * *(float *)((char *)v7 + v39 + 4);
          v23 += 4;
          v39 += 16;
        }
        while (v23 < v12);
        v25 = v43;
      }
LABEL_18:
      if (v25 < v11)
      {
        v40 = v25;
        do
        {
          v24 = v24 + v7[v40] * v7[v40];
          ++v25;
          ++v40;
        }
        while (v11 > v25);
      }
      v16 = a1[6].f32[0];
      v17 = v24;
      if ((float)((float)((float)(COERCE_FLOAT(*a1) + v16) * 0.015) + 1.0) >= v17)
        v17 = (float)((float)(COERCE_FLOAT(*a1) + v16) * 0.015) + 1.0;
      v18 = 1.0 / v17;
      v19 = vmulq_n_f32(a1[1], v18);
      *a1 = vmulq_n_f32(*a1, v18);
      a1[1] = v19;
      v20 = vmulq_n_f32(a1[3], v18);
      a1[2] = vmulq_n_f32(a1[2], v18);
      a1[3] = v20;
      v21 = vmulq_n_f32(a1[5], v18);
      a1[4] = vmulq_n_f32(a1[4], v18);
      a1[5] = v21;
      a1[6].f32[0] = v18 * v16;
      *a2 = vmulq_n_f32(*a2, v18);
      a2[1].f32[0] = v18 * a2[1].f32[0];
      v7 = (float *)((char *)v7 + v15);
      a1 = (float32x4_t *)((char *)a1 + 100);
      a2 = (float32x4_t *)((char *)a2 + 20);
      ++v10;
      v14 = (const float *)((char *)v14 + v15);
    }
    while (v10 != v44);
  }
}

void silk_find_pitch_lags_FLP(uint64_t a1, uint64_t a2, float *a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  float v13;
  unint64_t v14;
  float *v15;
  float *v16;
  float v17;
  float v18;
  float v19;
  float v20;
  int v21;
  float v22;
  unint64_t v23;
  float v24;
  float *v25;
  float *v26;
  float v27;
  float v28;
  float v29;
  float v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  unsigned int v37;
  float *v38;
  float v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  double v44;
  unsigned int v45;
  unint64_t v46;
  unint64_t v47;
  const float *v48;
  const float *v49;
  const float *v50;
  const float *v51;
  float64x2_t v52;
  float64x2_t v53;
  uint64_t v54;
  float *v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  float32x4_t *v62;
  float32x4_t v63;
  float64x2_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float64x2_t v67;
  float64x2_t v68;
  float64x2_t v69;
  float64x2_t v70;
  float *v71;
  float v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  double *v76;
  float32x2_t *v77;
  uint64_t v78;
  float32x4_t v79;
  float32x4_t v80;
  double *v81;
  double *v82;
  double *v83;
  double *v84;
  uint64_t v85;
  int64x2_t *v86;
  float *v87;
  float v88;
  uint64_t v89;
  unint64_t v90;
  unsigned int v91;
  unint64_t v92;
  double v93;
  float v94;
  double *v95;
  uint64_t v96;
  double v97;
  double v98;
  uint64_t v99;
  float v100;
  float *v101;
  unint64_t v102;
  uint64_t v103;
  float v104;
  float *v105;
  float *v106;
  float v107;
  float v108;
  int v109;
  float *v110;
  float v111;
  uint64_t v112;
  float v113;
  unint64_t v114;
  _BYTE v116[8];
  _BYTE v117[1592];
  float v118[4];
  int v119;
  int v120;
  float v121[2];
  double v122;
  uint64_t v123;
  _QWORD v124[44];
  float64x2x2_t v125;
  float64x2x2_t v126;
  float64x2x2_t v127;
  float64x2x2_t v128;
  float32x2x4_t v129;
  float32x2x4_t v130;
  float32x2x4_t v131;
  float32x2x4_t v132;

  v124[42] = *MEMORY[0x24BDAC8D0];
  v7 = *(int *)(a1 + 4596);
  v8 = *(unsigned int *)(a1 + 4596);
  v9 = *(int *)(a1 + 4592);
  v10 = *(int *)(a1 + 4584) + v7 + v9;
  v114 = a4 - 4 * v9;
  v11 = *(int *)(a1 + 4548);
  v12 = 3.1416 / (float)(v7 + 1);
  v13 = 2.0 - (float)(v12 * v12);
  if ((int)v7 >= 1)
  {
    v14 = 0;
    v15 = (float *)v117;
    v16 = (float *)(4 * v10 - 4 * v11 - 4 * v9 + a4 + 8);
    v17 = 0.0;
    do
    {
      v18 = v12 * *(v16 - 1);
      *(v15 - 2) = (float)(v12 + v17) * (float)(*(v16 - 2) * 0.5);
      *(v15 - 1) = v18;
      v17 = -(float)(v17 - (float)(v13 * v12));
      v19 = *v16;
      v20 = v16[1];
      v16 += 4;
      *v15 = (float)(v12 + v17) * (float)(v19 * 0.5);
      v15[1] = v17 * v20;
      v15 += 4;
      v12 = -(float)(v12 - (float)(v13 * v17));
      v14 += 4;
    }
    while (v14 < v8);
  }
  v21 = 2 * v7;
  memcpy(&v116[4 * v7], (const void *)(v114 + 4 * v10 - 4 * v11 + 4 * v7), 4 * ((int)v11 - 2 * (int)v7));
  if ((int)v8 >= 1)
  {
    v23 = 0;
    v22 = 0.5;
    v24 = v13 * 0.5;
    v25 = (float *)&v116[4 * v11 + 4 * v7 - 4 * v21 + 8];
    v26 = (float *)(a4 - 4 * (v9 + v21) + 4 * (v7 + v10) + 8);
    v27 = 1.0;
    do
    {
      v28 = v24 * *(v26 - 1);
      *(v25 - 2) = (float)(v24 + v27) * (float)(*(v26 - 2) * 0.5);
      *(v25 - 1) = v28;
      v27 = -(float)(v27 - (float)(v13 * v24));
      v29 = *v26;
      v30 = v26[1];
      v26 += 4;
      *v25 = (float)(v24 + v27) * (float)(v29 * 0.5);
      v25[1] = v27 * v30;
      v25 += 4;
      v24 = -(float)(v24 - (float)(v13 * v27));
      v23 += 4;
    }
    while (v23 < v8);
  }
  v31 = *(unsigned int *)(a1 + 4648);
  if ((int)v31 + 1 < (int)v11)
    v32 = (v31 + 1);
  else
    v32 = v11;
  if ((int)v32 >= 1)
  {
    v33 = 0;
    v34 = 0;
    v35 = v11 - 3;
    v36 = v11 - 1;
    v37 = v11 - 3;
    v38 = a3;
    while (1)
    {
      if (v37 <= 4uLL)
        v40 = 4;
      else
        v40 = v37;
      if ((v35 - v34) <= 4)
        v41 = 4;
      else
        v41 = (v35 - v34);
      v42 = v11 - v34;
      if ((int)v11 - (int)v34 < 4)
      {
        v45 = 0;
        v44 = 0.0;
        if (v42 <= 0)
          goto LABEL_12;
        goto LABEL_30;
      }
      if (v41 < 0xD)
        break;
      v46 = (((unint64_t)(v40 - 1) >> 2) + 1) & 0x7FFFFFFFFFFFFFFCLL;
      v47 = ((unint64_t)(v41 - 1) >> 2) + 1;
      v43 = 4 * (v47 & 0x7FFFFFFFFFFFFFFCLL);
      v44 = 0.0;
      v48 = (const float *)v116;
      do
      {
        v49 = v48 + 8;
        v50 = v48;
        v129 = vld4_f32(v50);
        v51 = &v50[v33];
        v130 = vld4_f32(v49);
        v131 = vld4_f32(v51);
        v51 += 8;
        v132 = vld4_f32(v51);
        v52 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v129.val[1]), vcvtq_f64_f32(v131.val[1])), vcvtq_f64_f32(v131.val[0]), vcvtq_f64_f32(v129.val[0])), vcvtq_f64_f32(v131.val[2]), vcvtq_f64_f32(v129.val[2])), vcvtq_f64_f32(v131.val[3]), vcvtq_f64_f32(v129.val[3]));
        v53 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v130.val[1]), vcvtq_f64_f32(v132.val[1])), vcvtq_f64_f32(v132.val[0]), vcvtq_f64_f32(v130.val[0])), vcvtq_f64_f32(v132.val[2]), vcvtq_f64_f32(v130.val[2])), vcvtq_f64_f32(v132.val[3]), vcvtq_f64_f32(v130.val[3]));
        v44 = v44 + v52.f64[0] + v52.f64[1] + v53.f64[0] + v53.f64[1];
        v48 += 16;
        v46 -= 4;
      }
      while (v46);
      if (v47 != (v47 & 0x7FFFFFFFFFFFFFFCLL))
        goto LABEL_27;
LABEL_29:
      v45 = v42 & 0xFFFFFFFC;
      if ((int)(v42 & 0xFFFFFFFC) >= v42)
        goto LABEL_12;
LABEL_30:
      v57 = (_DWORD)v11 + ~(_DWORD)v34 - v45;
      if (v57 >= 7)
      {
        v59 = v57 + 1;
        v60 = (v57 + 1) & 0x1FFFFFFF8;
        v58 = v60 + v45;
        v61 = (v36 - v45 + 1) & 0x1FFFFFFF8;
        v62 = (float32x4_t *)&v116[4 * v45];
        do
        {
          v63 = v62[1];
          v64 = vcvtq_f64_f32(*(float32x2_t *)v63.f32);
          v65 = *(float32x4_t *)((char *)v62 + v33 * 4);
          v66 = *(float32x4_t *)((char *)v62 + v33 * 4 + 16);
          v67 = vmulq_f64(vcvt_hight_f64_f32(*v62), vcvt_hight_f64_f32(v65));
          v68 = vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v62->f32), vcvtq_f64_f32(*(float32x2_t *)v65.f32));
          v69 = vmulq_f64(vcvt_hight_f64_f32(v63), vcvt_hight_f64_f32(v66));
          v70 = vmulq_f64(v64, vcvtq_f64_f32(*(float32x2_t *)v66.f32));
          v44 = v44
              + v68.f64[0]
              + v68.f64[1]
              + v67.f64[0]
              + v67.f64[1]
              + v70.f64[0]
              + v70.f64[1]
              + v69.f64[0]
              + v69.f64[1];
          v62 += 2;
          v61 -= 8;
        }
        while (v61);
        if (v59 == v60)
          goto LABEL_12;
      }
      else
      {
        v58 = v45;
      }
      v71 = (float *)&v116[4 * v58];
      do
      {
        v44 = v44 + *v71 * v71[v33];
        LODWORD(v58) = v58 + 1;
        ++v71;
      }
      while (v42 > (int)v58);
LABEL_12:
      v39 = v44;
      v118[v34++] = v39;
      ++v33;
      --v37;
      --v36;
      if (v34 == v32)
      {
        v22 = v118[0];
        goto LABEL_40;
      }
    }
    v43 = 0;
    v44 = 0.0;
LABEL_27:
    v54 = v43 + 3;
    v55 = (float *)&v116[4 * v43];
    do
    {
      v44 = v44 + v55[1] * v55[v33 + 1] + *v55 * v55[v33] + v55[2] * v55[v33 + 2] + v55[3] * v55[v33 + 3];
      v56 = v54 + 1;
      v54 += 4;
      v55 += 4;
    }
    while (v56 < (v42 - 3));
    goto LABEL_29;
  }
  v38 = a3;
LABEL_40:
  v72 = v22 + (float)((float)(v22 * 0.001) + 1.0);
  v118[0] = v72;
  v73 = v31 & ~((int)v31 >> 31);
  if (v73 < 7)
  {
    v74 = 0;
LABEL_45:
    v85 = v73 - v74 + 1;
    v86 = (int64x2_t *)&v121[4 * v74];
    v87 = &v118[v74];
    do
    {
      v88 = *v87++;
      *v86++ = vdupq_lane_s64(COERCE__INT64(v88), 0);
      --v85;
    }
    while (v85);
    goto LABEL_47;
  }
  v75 = (v73 + 1);
  v74 = v75 & 0xFFFFFFF8;
  v76 = (double *)v124;
  v77 = (float32x2_t *)&v119;
  v78 = v74;
  do
  {
    v79 = *(float32x4_t *)v77[-2].f32;
    v80 = *(float32x4_t *)v77->f32;
    v126.val[0] = vcvt_hight_f64_f32(v79);
    v126.val[1] = v126.val[0];
    v127.val[0] = vcvtq_f64_f32(*(float32x2_t *)v79.f32);
    v127.val[1] = v127.val[0];
    v128.val[0] = vcvtq_f64_f32(*v77);
    v81 = v76 - 8;
    vst2q_f64(v81, v127);
    v128.val[1] = v128.val[0];
    v82 = v76 - 4;
    vst2q_f64(v82, v126);
    v83 = v76 + 16;
    vst2q_f64(v76, v128);
    v84 = v76 + 4;
    v125.val[0] = vcvt_hight_f64_f32(v80);
    v125.val[1] = v125.val[0];
    vst2q_f64(v84, v125);
    v77 += 4;
    v76 = v83;
    v78 -= 8;
  }
  while (v78);
  if (v74 != v75)
    goto LABEL_45;
LABEL_47:
  if ((int)v31 <= 0)
  {
    v113 = v122;
    *(float *)(a2 + 704) = v72 / fmaxf(v113, 1.0);
    v109 = v31 - 1;
LABEL_67:
    v111 = 0.99;
    goto LABEL_68;
  }
  v89 = 0;
  v90 = 0;
  v91 = v31;
  do
  {
    v92 = v90++;
    v93 = -*(double *)&v121[4 * v90] / fmax(v122, 9.99999972e-10);
    v94 = v93;
    *(float *)&v117[4 * v92 + 1528] = v94;
    if (v92 < v31)
    {
      v95 = (double *)&v123;
      v96 = v91;
      do
      {
        v97 = v95[v89];
        v98 = *(v95 - 1);
        v95[v89] = v97 + v98 * v93;
        *(v95 - 1) = v98 + v97 * v93;
        v95 += 2;
        --v96;
      }
      while (v96);
    }
    --v91;
    v89 += 2;
  }
  while (v90 != v31);
  v99 = 0;
  v100 = v122;
  *(float *)(a2 + 704) = v72 / fmaxf(v100, 1.0);
  v101 = (float *)&v120;
  v102 = 1;
  do
  {
    v103 = v102 >> 1;
    if (v102 >> 1 <= 1)
      v103 = 1;
    v104 = *(float *)&v117[4 * v99 + 1528];
    if (v99)
    {
      v105 = v121;
      v106 = v101;
      do
      {
        v107 = *v105;
        v108 = *v106;
        *v105 = *v105 + (float)(*v106 * v104);
        ++v105;
        *v106-- = v108 + (float)(v107 * v104);
        --v103;
      }
      while (v103);
    }
    v121[v99] = -v104;
    ++v102;
    ++v101;
    ++v99;
  }
  while (v99 != v31);
  v109 = v31 - 1;
  if ((int)v31 < 2)
    goto LABEL_67;
  v110 = v121;
  v111 = 0.99;
  v112 = (v31 - 1);
  do
  {
    *v110 = v111 * *v110;
    ++v110;
    v111 = v111 * 0.99;
    --v112;
  }
  while (v112);
LABEL_68:
  v121[v109] = v111 * v121[v109];
  silk_LPC_analysis_filter_FLP(v38, v121, v114, v10, v31);
  if (*(_BYTE *)(a1 + 4781) && !*(_DWORD *)(a1 + 4664))
  {
    if (silk_pitch_analysis_core_FLP((uint64_t)v38, a2 + 228, a1 + 4778, a1 + 4780, a1 + 10084, *(unsigned int *)(a1 + 4544), *(unsigned int *)(a1 + 4576), *(unsigned int *)(a1 + 4644), *(_DWORD *)(a1 + 4580)))*(_BYTE *)(a1 + 4781) = 1;
    else
      *(_BYTE *)(a1 + 4781) = 2;
  }
  else
  {
    *(_QWORD *)(a2 + 236) = 0;
    *(_QWORD *)(a2 + 228) = 0;
    *(_WORD *)(a1 + 4778) = 0;
    *(_BYTE *)(a1 + 4780) = 0;
    *(_DWORD *)(a1 + 10084) = 0;
  }
}

double silk_find_pred_coefs_FLP(uint64_t a1, uint64_t a2, float *a3, uint64_t a4, int a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  float32x4_t *v13;
  uint64_t v18;
  float32x4_t v19;
  uint64_t v20;
  uint64_t v21;
  float *v22;
  float *v23;
  float v24;
  unint64_t v25;
  int v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float32x4_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  _DWORD *v42;
  float v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  const float *v48;
  float *v49;
  uint64_t v50;
  float v51;
  float *v52;
  float v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  float32x4_t v58;
  float32x4_t *v59;
  int16x8_t *v60;
  float32x4_t *v61;
  uint64_t v62;
  int16x8_t v63;
  float32x4_t v64;
  float32x4_t v65;
  uint64_t v66;
  float *v67;
  __int16 *v68;
  int v69;
  int32x2_t v70;
  int32x2_t v71;
  int32x2_t v72;
  int32x2_t v73;
  int32x2_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  uint64_t v79;
  float32x4_t *v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  float32x4_t *v86;
  float *v87;
  uint64_t v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float *v95;
  uint64_t v96;
  float32x4_t *v97;
  BOOL v99;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  uint64_t v105;
  uint64_t v106;
  float32x4_t *v107;
  float32x4_t v108;
  float32x4_t *v109;
  char *v110;
  float32x4_t v111;
  float *v112;
  uint64_t v113;
  float v114;
  float32_t v115;
  float v116;
  float32_t v117;
  float32_t v118;
  float v119;
  float v120;
  uint64_t v121;
  uint64_t v122;
  int16x8_t *v123;
  float32x4_t *v124;
  float32x4_t v125;
  uint64_t v126;
  int16x8_t v127;
  float32x4_t v128;
  float32x4_t v129;
  uint64_t v130;
  float *v131;
  __int16 *v132;
  int v133;
  uint64_t v134;
  int16x8_t *v135;
  float32x4_t *v136;
  float32x4_t v137;
  uint64_t v138;
  int16x8_t v139;
  float32x4_t v140;
  float32x4_t v141;
  uint64_t v142;
  float *v143;
  __int16 *v144;
  int v145;
  double result;
  __int128 v147;
  int v148;
  _DWORD v149[384];
  int16x8_t v150;
  __int128 v151;
  float v152[4];
  float32x4_t v153[5];
  float32x4_t v154[25];
  int16x8_t v155;
  _BYTE v156[32];
  uint64_t v157;
  _WORD v158[8];
  _QWORD v159[6];
  float32x4x4_t v160;
  float32x4x4_t v161;

  v159[3] = *MEMORY[0x24BDAC8D0];
  v150 = 0u;
  v151 = 0u;
  v9 = *(unsigned int *)(a1 + 4580);
  v10 = (int)v9;
  if ((int)v9 >= 1)
  {
    if (v9 >= 8)
    {
      v11 = v9 & 0x7FFFFFF8;
      v12 = (float32x4_t *)(a2 + 16);
      v13 = v153;
      __asm { FMOV            V0.4S, #1.0 }
      v18 = v9 & 0xFFFFFFF8;
      do
      {
        v19 = vdivq_f32(_Q0, *v12);
        v13[-1] = vdivq_f32(_Q0, v12[-1]);
        *v13 = v19;
        v12 += 2;
        v13 += 2;
        v18 -= 8;
      }
      while (v18);
      if (v11 == v9)
        goto LABEL_11;
    }
    else
    {
      v11 = 0;
    }
    v20 = v9 - v11;
    v21 = 4 * v11;
    v22 = &v152[v11];
    v23 = (float *)(a2 + v21);
    do
    {
      v24 = *v23++;
      *v22++ = 1.0 / v24;
      --v20;
    }
    while (v20);
LABEL_11:
    if (*(_BYTE *)(a1 + 4781) == 2)
      goto LABEL_12;
    v34 = 0;
    v35 = *(int *)(a1 + 4640);
    v36 = a4 - 4 * v35;
    v37 = *(int *)(a1 + 4588);
    v38 = (v37 + v35);
    v39 = (unsigned __int16)v38 & 0xFFFC;
    v40 = ((v39 - 1) >> 2) + 1;
    v41 = 4 * v37;
    v42 = v149;
    while (1)
    {
      v43 = v152[v34];
      if ((v38 & 0xFFFC) == 0)
      {
        v45 = 0;
        if ((int)v38 <= 0)
          goto LABEL_24;
        goto LABEL_36;
      }
      if (v39 < 0xD)
        break;
      v46 = 0;
      v47 = v40 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v48 = (const float *)(v36 + v46 * 4);
        v160 = vld4q_f32(v48);
        v161.val[0] = vmulq_n_f32(v160.val[0], v43);
        v161.val[1] = vmulq_n_f32(v160.val[1], v43);
        v161.val[2] = vmulq_n_f32(v160.val[2], v43);
        v161.val[3] = vmulq_n_f32(v160.val[3], v43);
        v49 = (float *)&v42[v46];
        vst4q_f32(v49, v161);
        v46 += 16;
        v47 -= 4;
      }
      while (v47);
      v44 = 4 * (v40 & 0x7FFFFFFFFFFFFFFCLL);
      if (v40 != (v40 & 0x7FFFFFFFFFFFFFFCLL))
        goto LABEL_33;
LABEL_35:
      v45 = v44;
      if ((int)v44 >= (int)v38)
        goto LABEL_24;
LABEL_36:
      v54 = v38 - v45;
      if ((unint64_t)(v38 - v45) >= 8)
      {
        v55 = (v54 & 0xFFFFFFFFFFFFFFF8) + v45;
        v56 = v45;
        v57 = v54 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v58 = vmulq_n_f32(*(float32x4_t *)(v36 + v56 * 4 + 16), v43);
          v59 = (float32x4_t *)&v42[v56];
          *v59 = vmulq_n_f32(*(float32x4_t *)(v36 + v56 * 4), v43);
          v59[1] = v58;
          v56 += 8;
          v57 -= 8;
        }
        while (v57);
        if (v54 == (v54 & 0xFFFFFFFFFFFFFFF8))
          goto LABEL_24;
      }
      else
      {
        v55 = v45;
      }
      do
      {
        *(float *)&v42[v55] = v43 * *(float *)(v36 + 4 * v55);
        ++v55;
      }
      while (v38 != v55);
LABEL_24:
      ++v34;
      v36 += v41;
      v42 += (int)v38;
      if (v34 == v10)
        goto LABEL_5;
    }
    v44 = 0;
LABEL_33:
    v50 = 4 * v44 + 8;
    do
    {
      v51 = *(float *)(v36 + v50 - 4);
      v52 = (float *)((char *)v42 + v50);
      *(v52 - 2) = v43 * *(float *)(v36 + v50 - 8);
      *(float *)&v42[v44 + 1] = v43 * v51;
      v53 = v43 * *(float *)(v36 + v50 + 4);
      *v52 = v43 * *(float *)(v36 + v50);
      v52[1] = v53;
      v44 += 4;
      v50 += 16;
    }
    while (v44 < v39);
    goto LABEL_35;
  }
  if (*(_BYTE *)(a1 + 4781) != 2)
  {
LABEL_5:
    bzero((void *)(a2 + 144), 20 * (_DWORD)v10);
    *(_DWORD *)(a2 + 708) = 0;
    *(_DWORD *)(a1 + 4656) = 0;
    goto LABEL_72;
  }
LABEL_12:
  silk_find_LTP_FLP(v154, v153, a3, a2 + 228, *(unsigned int *)(a1 + 4588), v10);
  v25 = 0;
  v26 = *(_DWORD *)(a1 + 4588);
  v27 = *(_DWORD *)(a1 + 4580);
  v28 = 25 * v27;
  if (25 * v27 <= 1)
    v28 = 1;
  v29 = 4 * v28;
  do
  {
    v149[v25 / 4] = (uint64_t)rintf(v154[0].f32[v25 / 4] * 131070.0);
    v25 += 4;
  }
  while (v29 != v25);
  v30 = 0;
  if (5 * v27 <= 1)
    v31 = 1;
  else
    v31 = (5 * v27);
  do
  {
    v155.i32[v30] = (uint64_t)rintf(v153[0].f32[v30] * 131070.0);
    ++v30;
  }
  while (v31 != v30);
  v148 = 0;
  silk_quant_LTP_gains((uint64_t)v158, (char *)(a1 + 4756), (_BYTE *)(a1 + 4784), (unsigned int *)(a1 + 4656), &v148, v149, v155.i32, v26, v27);
  if (v27 >= 1)
  {
    if (v31 < 0x10)
    {
      v33 = 0;
LABEL_46:
      v66 = v31 - v33;
      v67 = (float *)(a2 + 4 * v33 + 144);
      v68 = &v158[v33];
      do
      {
        v69 = *v68++;
        *v67++ = (float)v69 * 0.000061035;
        --v66;
      }
      while (v66);
      goto LABEL_48;
    }
    v33 = v31 & 0x7FFFFFF0;
    v60 = (int16x8_t *)v159;
    v61 = (float32x4_t *)(a2 + 176);
    v32 = (float32x4_t)vdupq_n_s32(0x38800000u);
    v62 = v33;
    do
    {
      v63 = v60[-1];
      v64 = vcvtq_f32_s32(vmovl_high_s16(*v60));
      v65 = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v60->i8)), v32);
      v61[-2] = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v63.i8)), v32);
      v61[-1] = vmulq_f32(vcvtq_f32_s32(vmovl_high_s16(v63)), v32);
      *v61 = v65;
      v61[1] = vmulq_f32(v64, v32);
      v61 += 4;
      v60 += 2;
      v62 -= 16;
    }
    while (v62);
    if (v33 != v31)
      goto LABEL_46;
  }
LABEL_48:
  v32.f32[0] = (float)v148 * 0.0078125;
  *(_DWORD *)(a2 + 708) = v32.i32[0];
  silk_LTP_scale_ctrl_FLP(a1, a2, a5, *(double *)v32.i64);
  v75 = *(unsigned int *)(a1 + 4580);
  if ((int)v75 >= 1)
  {
    v76 = *(int *)(a1 + 4640);
    v77 = *(int *)(a1 + 4588);
    v78 = v77 + v76;
    if ((int)v77 + (int)v76 >= 1)
    {
      v79 = 0;
      v80 = (float32x4_t *)(a4 - 4 * v76);
      v81 = (v77 + v76);
      v82 = 4 * v81;
      v83 = 4 * (int)v78;
      v84 = 4 * v76;
      v85 = 4 * v77;
      v86 = (float32x4_t *)v149;
      do
      {
        v87 = (float *)(a2 + 144 + 20 * v79);
        v88 = *(int *)(a2 + 228 + 4 * v79);
        v89 = v152[v79];
        v90 = *v87;
        v91 = v87[1];
        v92 = v87[2];
        v93 = v87[3];
        v94 = v87[4];
        v95 = &v80->f32[-v88];
        *(float *)v70.i32 = -v90;
        *(float *)v71.i32 = -v91;
        *(float *)v72.i32 = -v92;
        *(float *)v73.i32 = -v93;
        *(float *)v74.i32 = -v94;
        if (v78 >= 4)
        {
          v96 = 0;
          v97 = (float32x4_t *)((char *)&v149[v82 / 4] + v83 * v79);
          v99 = (unint64_t)v86 < a4 + v82 - v84 + v85 * v79 && v80 < v97;
          if ((v85 * v79 - v84 + a4 - 4 * v88 - 8 >= (unint64_t)v97
             || (unint64_t)v86 >= a4 + v82 - v84 + 8 + v85 * v79 - 4 * v88)
            && !v99)
          {
            v95 += v78 & 0xFFFFFFFC;
            v101 = (float32x4_t)vdupq_lane_s32(v70, 0);
            v102 = (float32x4_t)vdupq_lane_s32(v71, 0);
            v103 = (float32x4_t)vdupq_lane_s32(v72, 0);
            v104 = (float32x4_t)vdupq_lane_s32(v73, 0);
            v105 = -4 * v88;
            v106 = v78 & 0xFFFFFFFC;
            v107 = v86;
            v108 = (float32x4_t)vdupq_lane_s32(v74, 0);
            v109 = v80;
            do
            {
              v110 = (char *)v109 + v105;
              v111 = *v109++;
              *v107++ = vmulq_n_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(v111, *(float32x4_t *)(v110 + 8), v101), *(float32x4_t *)(v110 + 4), v102), *(float32x4_t *)v110, v103), *(float32x4_t *)(v110 - 4), v104), *(float32x4_t *)(v110 - 8), v108), v89);
              v106 -= 4;
            }
            while (v106);
            v96 = v78 & 0xFFFFFFFC;
            if (v96 == v81)
              goto LABEL_51;
          }
        }
        else
        {
          v96 = 0;
        }
        v112 = v95;
        do
        {
          v113 = v96;
          v114 = v80->f32[v96];
          v86->f32[v113] = v114;
          v115 = v114 + (float)(*(float *)v70.i32 * v95[2]);
          v86->f32[v113] = v115;
          v116 = v112[1];
          ++v112;
          v117 = (float)(v115 + (float)(*(float *)v71.i32 * v116)) + (float)(*(float *)v72.i32 * *v95);
          v86->f32[v113] = v117;
          v118 = v117 + (float)(*(float *)v73.i32 * *(v95 - 1));
          v86->f32[v113] = v118;
          v86->f32[v113] = v89 * (float)(v118 + (float)(*(float *)v74.i32 * *(v95 - 2)));
          ++v96;
          v95 = v112;
        }
        while (v81 != v96);
LABEL_51:
        v86 = (float32x4_t *)((char *)v86 + v83);
        v80 = (float32x4_t *)((char *)v80 + v85);
        ++v79;
      }
      while (v79 != v75);
    }
  }
LABEL_72:
  if (*(_DWORD *)(a1 + 4664))
  {
    v119 = 0.01;
  }
  else
  {
    v120 = exp2((float)(*(float *)(a2 + 708) / 3.0));
    v119 = (float)(v120 / 10000.0) / (float)((float)(*(float *)(a2 + 700) * 0.75) + 0.25);
  }
  silk_find_LPC_FLP(a1, &v150, (unint64_t)v149, v119);
  silk_process_NLSFs(a1, &v155, v150.i16, (int16x8_t *)(a1 + 4500));
  v121 = *(unsigned int *)(a1 + 4640);
  if ((int)v121 < 1)
    goto LABEL_90;
  if (v121 >= 0x10)
  {
    v122 = v121 & 0x7FFFFFF0;
    v123 = (int16x8_t *)v156;
    v124 = (float32x4_t *)(a2 + 48);
    v125 = (float32x4_t)vdupq_n_s32(0x39800000u);
    v126 = v121 & 0xFFFFFFF0;
    do
    {
      v127 = v123[-1];
      v128 = vcvtq_f32_s32(vmovl_high_s16(*v123));
      v129 = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v123->i8)), v125);
      v124[-2] = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v127.i8)), v125);
      v124[-1] = vmulq_f32(vcvtq_f32_s32(vmovl_high_s16(v127)), v125);
      *v124 = v129;
      v124[1] = vmulq_f32(v128, v125);
      v124 += 4;
      v123 += 2;
      v126 -= 16;
    }
    while (v126);
    if (v122 == v121)
      goto LABEL_83;
  }
  else
  {
    v122 = 0;
  }
  v130 = v121 - v122;
  v131 = (float *)(a2 + 4 * v122 + 16);
  v132 = &v155.i16[v122];
  do
  {
    v133 = *v132++;
    *v131++ = (float)v133 * 0.00024414;
    --v130;
  }
  while (v130);
LABEL_83:
  if (v121 < 0x10)
  {
    v134 = 0;
LABEL_88:
    v142 = v121 - v134;
    v143 = (float *)(a2 + 4 * v134 + 80);
    v144 = (__int16 *)&v156[2 * v134 + 16];
    do
    {
      v145 = *v144++;
      *v143++ = (float)v145 * 0.00024414;
      --v142;
    }
    while (v142);
    goto LABEL_90;
  }
  v134 = v121 & 0x7FFFFFF0;
  v135 = (int16x8_t *)&v157;
  v136 = (float32x4_t *)(a2 + 112);
  v137 = (float32x4_t)vdupq_n_s32(0x39800000u);
  v138 = v121 & 0xFFFFFFF0;
  do
  {
    v139 = v135[-1];
    v140 = vcvtq_f32_s32(vmovl_high_s16(*v135));
    v141 = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v135->i8)), v137);
    v136[-2] = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v139.i8)), v137);
    v136[-1] = vmulq_f32(vcvtq_f32_s32(vmovl_high_s16(v139)), v137);
    *v136 = v141;
    v136[1] = vmulq_f32(v140, v137);
    v136 += 4;
    v135 += 2;
    v138 -= 16;
  }
  while (v138);
  if (v134 != v121)
    goto LABEL_88;
LABEL_90:
  silk_residual_energy_FLP((float *)(a2 + 712), (unint64_t)v149, (float *)(a2 + 16), (float *)a2, *(_DWORD *)(a1 + 4588), *(_DWORD *)(a1 + 4580), v121);
  result = *(double *)v150.i64;
  v147 = v151;
  *(int16x8_t *)(a1 + 4500) = v150;
  *(_OWORD *)(a1 + 4516) = v147;
  return result;
}

uint64_t silk_gains_quant(uint64_t result, uint64_t a2, _BYTE *a3, int a4, int a5)
{
  uint64_t i;
  int v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;

  if (a5 >= 1)
  {
    for (i = 0; i != a5; *(_DWORD *)(a2 + 4 * i++) = v6)
    {
      v7 = *(_DWORD *)(a2 + 4 * i);
      v8 = __clz(v7);
      if (v8 != 24)
      {
        v9 = v7 > 0x7F;
        v10 = (v7 << (v8 + 8)) | (v7 >> (24 - v8));
        v7 <<= v8 - 24;
        if (v9)
          LOBYTE(v7) = v10;
      }
      v11 = (2251
                         * (__int16)((v7 & 0x7F)
                                   - ((_WORD)v8 << 7)
                                   + ((179 * (v7 & 0x7F) * (128 - (v7 & 0x7F))) >> 16)
                                   + 1878)) >> 16;
      *(_BYTE *)(result + i) = v11;
      if ((char)*a3 > (char)v11)
        LOBYTE(v11) = v11 + 1;
      v12 = (char)v11 & ~((char)v11 >> 31);
      if (v12 >= 63)
        LOBYTE(v12) = 63;
      *(_BYTE *)(result + i) = v12;
      v13 = (char)*a3;
      if (i | a4)
      {
        LOBYTE(v13) = v12 - v13;
        *(_BYTE *)(result + i) = v13;
        v14 = (char)*a3;
        v15 = v14 + 8;
        v16 = v14 + 8 + (((char)v13 - v14 + 505) >> 1);
        if (v15 < (char)v13)
          LOBYTE(v13) = v16;
        v13 = (char)v13;
        if ((char)v13 <= -4)
          v13 = -4;
        if (v13 >= 36)
          v13 = 36;
        *(_BYTE *)(result + i) = v13;
        if (v15 >= v13)
        {
          LOBYTE(v12) = *a3 + v13;
        }
        else
        {
          v12 = (char)(*a3 - v15 + 2 * v13);
          if (v12 >= 63)
            LOBYTE(v12) = 63;
        }
        *a3 = v12;
        *(_BYTE *)(result + i) += 4;
        LOBYTE(v12) = *a3;
      }
      else
      {
        if (v13 - 4 > v12)
          LOBYTE(v12) = v13 - 4;
        if (v13 > 67)
          LOBYTE(v12) = 63;
        *(_BYTE *)(result + i) = v12;
        *a3 = v12;
      }
      v17 = (1907825 * (char)v12) >> 16;
      if (v17 >= 1877)
        v17 = 1877;
      if (v17 < -2090)
      {
        v6 = 0;
      }
      else
      {
        v18 = v17 + 2090;
        if (v18 <= 0xF7E)
        {
          v19 = 1 << (v18 >> 7);
          v20 = (v18 & 0x7F) + ((int)(-174 * (v18 & 0x7F) * (128 - (v18 & 0x7F))) >> 16);
          if (v18 <= 0x7FF)
            v21 = v20 << (v18 >> 7) >> 7;
          else
            v21 = v20 * (v19 >> 7);
          v6 = v21 + v19;
        }
        else
        {
          v6 = 0x7FFFFFFF;
        }
      }
    }
  }
  return result;
}

uint64_t silk_HP_variable_cutoff(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  BOOL v3;
  int v4;
  unsigned int v5;
  int v6;
  int v7;
  int v8;

  if (*(_BYTE *)(result + 4541) == 2)
  {
    v1 = 65536000 * *(_DWORD *)(result + 4576) / *(_DWORD *)(result + 4544);
    v2 = __clz(v1);
    if (v2 != 24)
    {
      v3 = v1 > 0x7F;
      v4 = (v1 << (v2 + 8)) | (v1 >> (24 - v2));
      v1 <<= v2 - 24;
      if (v3)
        LOBYTE(v1) = v4;
    }
    v5 = (v1 & 0x7F) - (v2 << 7) + ((179 * (v1 & 0x7F) * (128 - (v1 & 0x7F))) >> 16);
    v6 = *(_DWORD *)(result + 8);
    v7 = v5
       - (v6 >> 8)
       + (((__int16)(v5 + 1164)
         * ((unint64_t)((__int16)*(_DWORD *)(result + 4712) * (uint64_t)(-4 * *(_DWORD *)(result + 4712))) >> 16)) >> 16)
       + 1920;
    if (v7 < 0)
      v7 *= 3;
    if (v7 <= -51)
      v7 = -51;
    if (v7 >= 51)
      v7 = 51;
    v8 = v6 + ((unint64_t)(6554 * v7 * *(__int16 *)(result + 4532)) >> 16);
    if (v8 <= 193536)
      v8 = 193536;
    if (v8 >= 217856)
      v8 = 217856;
    *(_DWORD *)(result + 8) = v8;
  }
  return result;
}

uint64_t opus_fft_impl(uint64_t result, float *a2)
{
  uint64_t v2;
  int v3;
  unsigned __int16 *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  float *v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  float v42;
  uint64_t v43;
  float *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  float *v48;
  float *v49;
  float *v50;
  float *v51;
  uint64_t v52;
  float *v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float *v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  uint64_t v74;
  float *v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  float *v93;
  float v94;
  float v95;
  float *v96;
  float v97;
  float v98;
  uint64_t v99;
  uint64_t v100;
  float *v101;
  uint64_t v102;
  float *v103;
  uint64_t v104;
  uint64_t v105;
  float *v106;
  uint64_t v107;
  float *v108;
  uint64_t v109;
  uint64_t v110;
  float *v111;
  float *v112;
  unint64_t v113;
  float *v114;
  float *v115;
  float *v116;
  float *v117;
  float *v118;
  float *v119;
  float *v120;
  float *v121;
  float *v122;
  float v123;
  float v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  float v139;
  float v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float v151;
  float v152;
  float v153;
  float v154;
  float v155;
  float v156;
  float v157;
  float v158;
  float v159;
  float v160;
  float v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  float *v171;
  float *v172;
  float *v173;
  float *v174;
  int v175;
  float *v176;
  float v177;
  float v178;
  float v179;
  float v180;
  float v181;
  float *v182;
  float v183;
  float v184;
  float v185;
  float v186;
  float v187;
  float *v188;
  float v189;
  float v190;
  float v191;
  float v192;
  float v193;
  float v194;
  float v195;
  float v196;
  float v197;
  float v198;
  float v199;
  float v200;
  float v201;
  float v202;
  int v203;
  _DWORD v204[8];
  uint64_t v205;

  v205 = *MEMORY[0x24BDAC8D0];
  v2 = 1;
  v3 = *(_DWORD *)(result + 8);
  v204[0] = 1;
  v4 = (unsigned __int16 *)(result + 14);
  v5 = -1;
  v6 = 1;
  do
  {
    v6 *= (__int16)*(v4 - 1);
    v204[v2] = v6;
    v7 = *v4;
    v4 += 2;
    ++v2;
    v5 += 2;
  }
  while (v7 != 1);
  v203 = v3 & ~(v3 >> 31);
  v8 = *(__int16 *)(result + 2 * v5 + 12);
  v9 = v2 - 2;
  do
  {
    v11 = v8;
    if (v9)
    {
      v8 = *(__int16 *)(result + 4 * (int)v9 + 10);
      v12 = v9;
      v13 = *(__int16 *)(result + 2 * (2 * v9) + 12) - 2;
      if (v13 > 3)
        continue;
    }
    else
    {
      v12 = 0;
      v8 = 1;
      v13 = *(__int16 *)(result + 12) - 2;
    }
    switch(v13)
    {
      case 0u:
        v14 = v204[v12];
        if (v14 >= 1)
        {
          v15 = a2 + 8;
          do
          {
            v16 = *v15;
            v17 = v15[1];
            v18 = *(v15 - 8);
            v19 = *(v15 - 7);
            *v15 = v18 - *v15;
            v15[1] = v19 - v17;
            *(v15 - 8) = v16 + v18;
            *(v15 - 7) = v17 + v19;
            v20 = v15[2];
            v21 = v15[3];
            v22 = (float)(v20 + v21) * 0.70711;
            v23 = (float)(v21 - v20) * 0.70711;
            v24 = *(v15 - 6);
            v25 = *(v15 - 5);
            v15[2] = v24 - v22;
            v15[3] = v25 - v23;
            *(v15 - 6) = v24 + v22;
            *(v15 - 5) = v23 + v25;
            v27 = v15[4];
            v26 = v15[5];
            v28 = *(v15 - 4);
            v29 = *(v15 - 3);
            v15[4] = v28 - v26;
            v15[5] = v27 + v29;
            *(v15 - 4) = v26 + v28;
            *(v15 - 3) = v29 - v27;
            v31 = v15[6];
            v30 = v15[7];
            v32 = (float)(v30 - v31) * 0.70711;
            v33 = (float)(v30 + v31) * -0.70711;
            v34 = *(v15 - 2);
            v35 = *(v15 - 1);
            v15[6] = v34 - v32;
            v15[7] = v35 - v33;
            *(v15 - 2) = v34 + v32;
            *(v15 - 1) = v33 + v35;
            v15 += 16;
            --v14;
          }
          while (v14);
        }
        break;
      case 1u:
        v36 = v204[v12];
        if ((int)v36 >= 1)
        {
          v37 = 0;
          v38 = (int)((_DWORD)v36 << v203);
          v39 = *(_QWORD *)(result + 56);
          v40 = 2 * v11;
          v41 = v11;
          v42 = *(float *)(v39 + 8 * v38 * v11 + 4);
          v43 = 2 * v11;
          v44 = (float *)(v39 + 4);
          v45 = 16 * v38;
          v46 = 2 * v40;
          v47 = 8 * v38;
          v48 = a2 + 1;
          do
          {
            v49 = v44;
            v50 = v44;
            v51 = v48;
            v52 = v41;
            do
            {
              v53 = &v51[v43];
              v54 = v51[v43 - 1];
              v55 = v51[v43];
              v56 = *(v49 - 1);
              v57 = (float)(v54 * v56) - (float)(v55 * *v49);
              v58 = (float)(v56 * v55) + (float)(v54 * *v49);
              v59 = &v51[v46];
              v60 = v51[v46 - 1];
              v61 = v51[v46];
              v62 = *(v50 - 1);
              v63 = (float)(v60 * v62) - (float)(v61 * *v50);
              v64 = (float)(v62 * v61) + (float)(v60 * *v50);
              v65 = v58 + v64;
              v66 = v58 - v64;
              v67 = *v51 - (float)(v65 * 0.5);
              *(v53 - 1) = *(v51 - 1) - (float)((float)(v57 + v63) * 0.5);
              *v53 = v67;
              v68 = v42 * (float)(v57 - v63);
              v69 = v42 * v66;
              v70 = v65 + *v51;
              *(v51 - 1) = (float)(v57 + v63) + *(v51 - 1);
              *v51 = v70;
              v71 = v51[v43] - v68;
              *(v59 - 1) = v69 + v51[v43 - 1];
              *v59 = v71;
              v72 = v51[v43 - 1] - v69;
              v73 = v68 + v51[v43];
              *(v53 - 1) = v72;
              *v53 = v73;
              v51 += 2;
              v50 = (float *)((char *)v50 + v45);
              v49 = (float *)((char *)v49 + v47);
              --v52;
            }
            while (v52);
            ++v37;
            v48 += 2 * v8;
          }
          while (v37 != v36);
        }
        break;
      case 2u:
        v74 = v204[v12];
        if (v11 == 1)
        {
          if ((int)v74 >= 1)
          {
            v75 = a2;
            do
            {
              v76 = v75[1];
              v77 = v75[4];
              v78 = v75[5];
              v79 = *v75 - v77;
              v80 = v76 - v78;
              v81 = *v75 + v77;
              v82 = v76 + v78;
              v83 = v75[2];
              v84 = v75[3];
              v85 = v75[6];
              v86 = v75[7];
              v75[4] = v81 - (float)(v83 + v85);
              v75[5] = v82 - (float)(v84 + v86);
              *v75 = v81 + (float)(v83 + v85);
              v75[1] = v82 + (float)(v84 + v86);
              v75[2] = v79 + (float)(v84 - v86);
              v75[3] = v80 - (float)(v83 - v85);
              v75[6] = v79 - (float)(v84 - v86);
              v75[7] = v80 + (float)(v83 - v85);
              v75 += 8;
              LODWORD(v74) = v74 - 1;
            }
            while ((_DWORD)v74);
          }
        }
        else if ((int)v74 >= 1 && v11 >= 1)
        {
          v162 = 0;
          v163 = (int)((_DWORD)v74 << v203);
          v164 = *(_QWORD *)(result + 56) + 4;
          v165 = 24 * v163;
          v166 = (8 * v11) | 4;
          v167 = 16 * v163;
          v168 = (16 * v11) | 4;
          v169 = 8 * v163;
          v170 = (24 * v11) | 4;
          do
          {
            v171 = &a2[2 * v162 * v8];
            v172 = (float *)v164;
            v173 = (float *)v164;
            v174 = (float *)v164;
            v175 = v11;
            do
            {
              v176 = (float *)((char *)v171 + v166);
              v177 = *(float *)((char *)v171 + v166 - 4);
              v178 = *(float *)((char *)v171 + v166);
              v179 = *(v172 - 1);
              v180 = (float)(v177 * v179) - (float)(v178 * *v172);
              v181 = (float)(v179 * v178) + (float)(v177 * *v172);
              v182 = (float *)((char *)v171 + v168);
              v183 = *(float *)((char *)v171 + v168 - 4);
              v184 = *(float *)((char *)v171 + v168);
              v185 = *(v173 - 1);
              v186 = (float)(v183 * v185) - (float)(v184 * *v173);
              v187 = (float)(v185 * v184) + (float)(v183 * *v173);
              v188 = (float *)((char *)v171 + v170);
              v189 = *(float *)((char *)v171 + v170 - 4);
              v190 = *(float *)((char *)v171 + v170);
              v191 = *(v174 - 1);
              v192 = (float)(v189 * v191) - (float)(v190 * *v174);
              v193 = (float)(v191 * v190) + (float)(v189 * *v174);
              v194 = v171[1];
              v195 = *v171 - v186;
              v196 = v194 - v187;
              v197 = v186 + *v171;
              v198 = v187 + v194;
              v199 = v180 + v192;
              v200 = v181 + v193;
              v201 = v180 - v192;
              v202 = v181 - v193;
              *(v182 - 1) = v197 - v199;
              *v182 = v198 - v200;
              *v171 = v197 + v199;
              v171[1] = v200 + v198;
              v171 += 2;
              *(v176 - 1) = v195 + v202;
              *v176 = v196 - v201;
              *(v188 - 1) = v195 - v202;
              *v188 = v196 + v201;
              v174 = (float *)((char *)v174 + v165);
              v173 = (float *)((char *)v173 + v167);
              v172 = (float *)((char *)v172 + v169);
              --v175;
            }
            while (v175);
            ++v162;
          }
          while (v162 != v74);
        }
        break;
      case 3u:
        v87 = v204[v12];
        if ((int)v87 >= 1 && v11 >= 1)
        {
          v88 = 0;
          v89 = (int)((_DWORD)v87 << v203);
          v90 = *(_QWORD *)(result + 56);
          v91 = v11;
          v92 = v89 * v11;
          v93 = (float *)(v90 + 8 * v92);
          v94 = *v93;
          v95 = v93[1];
          v96 = (float *)(v90 + 16 * v92);
          v97 = *v96;
          v98 = v96[1];
          v99 = 2 * v11;
          v100 = 3 * v11;
          v101 = &a2[8 * v11];
          v102 = 8 * v8;
          v103 = (float *)(v90 + 4);
          v104 = 24 * v89;
          v105 = 8 * v11;
          v106 = &a2[2 * v100];
          v107 = 32 * v89;
          v108 = &a2[2 * v99];
          v109 = 16 * v89;
          v110 = 8 * v89;
          v111 = a2;
          v112 = &a2[2 * v91];
          do
          {
            v113 = 0;
            v114 = v103;
            v115 = v103;
            v116 = v103;
            v117 = v103;
            do
            {
              v118 = &v101[v113 / 4];
              v119 = &v106[v113 / 4];
              v120 = &v108[v113 / 4];
              v121 = &v112[v113 / 4];
              v122 = &v111[v113 / 4];
              v124 = v111[v113 / 4];
              v123 = v111[v113 / 4 + 1];
              v125 = *(v114 - 1);
              v126 = v112[v113 / 4];
              v127 = v112[v113 / 4 + 1];
              v128 = (float)(v126 * v125) - (float)(v127 * *v114);
              v129 = (float)(v125 * v127) + (float)(v126 * *v114);
              v131 = v108[v113 / 4];
              v130 = v108[v113 / 4 + 1];
              v132 = *(v115 - 1);
              v133 = (float)(v131 * v132) - (float)(v130 * *v115);
              v134 = (float)(v132 * v130) + (float)(v131 * *v115);
              v135 = *(v117 - 1);
              v136 = v106[v113 / 4];
              v137 = v106[v113 / 4 + 1];
              v138 = (float)(v136 * v135) - (float)(v137 * *v117);
              v139 = v135 * v137;
              v140 = *(v116 - 1);
              v141 = v101[v113 / 4];
              v142 = v101[v113 / 4 + 1];
              v143 = v139 + (float)(v136 * *v117);
              v144 = (float)(v141 * v140) - (float)(v142 * *v116);
              v145 = (float)(v140 * v142) + (float)(v141 * *v116);
              v146 = v128 + v144;
              v147 = v129 + v145;
              v148 = v128 - v144;
              v149 = v129 - v145;
              v150 = v133 + v138;
              v151 = v134 + v143;
              v152 = v133 - v138;
              v153 = v134 - v143;
              *v122 = v124 + (float)(v150 + v146);
              v122[1] = v123 + (float)(v151 + v147);
              v154 = v124 + (float)((float)(v97 * v150) + (float)(v146 * v94));
              v155 = v123 + (float)((float)(v97 * v151) + (float)(v147 * v94));
              v156 = (float)(v98 * v153) + (float)(v149 * v95);
              v157 = (float)(v98 * v152) + (float)(v148 * v95);
              v158 = v124 + (float)((float)(v94 * v150) + (float)(v146 * v97));
              v159 = v123 + (float)((float)(v94 * v151) + (float)(v147 * v97));
              v160 = (float)(v153 * v95) - (float)(v149 * v98);
              *v121 = v154 - v156;
              v121[1] = v155 + v157;
              v161 = (float)(v148 * v98) - (float)(v152 * v95);
              *v118 = v156 + v154;
              v118[1] = v155 - v157;
              v113 += 8;
              v117 = (float *)((char *)v117 + v104);
              *v120 = v160 + v158;
              v120[1] = v159 + v161;
              *v119 = v158 - v160;
              v119[1] = v159 - v161;
              v116 = (float *)((char *)v116 + v107);
              v115 = (float *)((char *)v115 + v109);
              v114 = (float *)((char *)v114 + v110);
            }
            while (v105 != v113);
            ++v88;
            v101 = (float *)((char *)v101 + v102);
            v106 = (float *)((char *)v106 + v102);
            v108 = (float *)((char *)v108 + v102);
            v112 = (float *)((char *)v112 + v102);
            v111 = (float *)((char *)v111 + v102);
          }
          while (v88 != v87);
        }
        break;
      default:
        break;
    }
  }
  while (v9-- > 0);
  return result;
}

int *silk_LP_variable_cutoff(int *result, __int16 *a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int *v8;
  int v9;
  int v10;
  int v11;
  int *v12;
  uint64_t v13;
  int *v14;
  int v15;
  int v16;
  int *v17;
  int *v18;
  int *v19;
  uint64_t v20;
  int *v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;

  v3 = result[3];
  if (v3)
  {
    v4 = result[2];
    v5 = 0x40000 - (v4 << 10);
    if (v5 >= 0x40000)
    {
      v11 = 89306658;
      v15 = 35497197;
      v16 = 57401098;
      v10 = 178584282;
      v9 = 89306658;
    }
    else
    {
      v6 = v5 >> 16;
      v7 = (unsigned __int16)(-1024 * v4);
      if (-1024 * (_WORD)v4)
      {
        v8 = (int *)((char *)&silk_Transition_LP_B_Q28 + 12 * v6);
        if (v7 >= 0x8000)
        {
          v9 = v8[3] + ((unint64_t)((__int16)v7 * (v8[3] - (uint64_t)*v8)) >> 16);
          v10 = v8[4] + ((unint64_t)((__int16)v7 * (v8[4] - (uint64_t)v8[1])) >> 16);
          v11 = v8[5] + ((unint64_t)((__int16)v7 * (v8[5] - (uint64_t)v8[2])) >> 16);
          v19 = (int *)((char *)&silk_Transition_LP_A_Q28 + 8 * v6);
          v20 = v19[1];
          v21 = v19 + 2;
          v15 = v19[2] + ((unint64_t)((__int16)v7 * (v19[2] - (uint64_t)*v19)) >> 16);
          v16 = v21[1] + ((unint64_t)((__int16)v7 * (v21[1] - v20)) >> 16);
        }
        else
        {
          v9 = *v8 + ((unint64_t)((v8[3] - (uint64_t)*v8) * v7) >> 16);
          v10 = v8[1] + ((unint64_t)((v8[4] - (uint64_t)v8[1]) * v7) >> 16);
          v11 = v8[2] + ((unint64_t)((v8[5] - (uint64_t)v8[2]) * v7) >> 16);
          v12 = (int *)((char *)&silk_Transition_LP_A_Q28 + 8 * v6);
          v13 = v12[1];
          v14 = v12 + 2;
          v15 = *v12 + ((unint64_t)((v12[2] - (uint64_t)*v12) * v7) >> 16);
          v16 = v13 + ((unint64_t)((v14[1] - v13) * v7) >> 16);
        }
      }
      else
      {
        v17 = (int *)((char *)&silk_Transition_LP_B_Q28 + 12 * v6);
        v9 = *v17;
        v10 = v17[1];
        v11 = v17[2];
        v18 = (int *)((char *)&silk_Transition_LP_A_Q28 + 8 * v6);
        v15 = *v18;
        v16 = v18[1];
      }
    }
    v22 = (v4 + v3) & ~((v4 + v3) >> 31);
    if (v22 >= 256)
      v22 = 256;
    result[2] = v22;
    if ((int)a3 >= 1)
    {
      v23 = -v16;
      v24 = -v15 & 0x3FFF;
      v25 = (__int16)(-v15 >> 14);
      v26 = v23 & 0x3FFF;
      v27 = (__int16)(v23 >> 14);
      v29 = *result;
      v28 = result[1];
      a3 = a3;
      do
      {
        v30 = 4 * (v29 + ((unint64_t)(*a2 * (uint64_t)v9) >> 16));
        v29 = v28
            + ((unint64_t)(*a2 * (uint64_t)v10) >> 16)
            + ((unint64_t)(v25 * (uint64_t)v30) >> 16)
            + ((((int)((unint64_t)(v24 * (uint64_t)v30) >> 16) >> 13) + 1) >> 1);
        v28 = ((unint64_t)(v27 * (uint64_t)v30) >> 16)
            + ((unint64_t)(*a2 * (uint64_t)v11) >> 16)
            + ((((int)((unint64_t)(v26 * (uint64_t)v30) >> 16) >> 13) + 1) >> 1);
        v31 = (v30 + 0x3FFF) >> 14;
        if (v31 <= -32768)
          LOWORD(v31) = 0x8000;
        if (v30 > 536854528)
          LOWORD(v31) = 0x7FFF;
        *a2++ = v31;
        --a3;
      }
      while (a3);
      *result = v29;
      result[1] = v28;
    }
  }
  return result;
}

void silk_LPC_analysis_filter(_WORD *a1, uint64_t a2, int16x4_t *a3, int a4, uint64_t a5)
{
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __int16 *v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  unint64_t v14;
  int32x4_t v15;
  int32x4_t v16;
  uint64_t v17;
  const __int16 *v18;
  const __int16 *v19;
  int32x4_t v20;
  int32x4_t v21;
  const __int16 *v22;
  int8x16_t v23;
  int16x8_t v24;
  int8x16_t v25;
  int16x8_t v26;
  const __int16 *v27;
  __int16 *v28;
  size_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  BOOL v34;
  BOOL v35;
  BOOL v36;
  const __int16 *v37;
  int16x4_t v38;
  int32x4_t v39;
  int16x4_t v40;
  int32x4_t v41;
  const __int16 *v42;
  int16x4_t v43;
  int32x4_t v44;
  const __int16 *v45;
  int16x4_t v46;
  int32x4_t v47;
  const __int16 *v48;
  int16x4_t v49;
  int32x4_t v50;
  const __int16 *v51;
  int16x4_t v52;
  int32x4_t v53;
  int16x8_t *v54;
  uint64_t v55;
  int32x4_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  _WORD *v60;
  __int16 *v61;
  __int16 *v62;
  int v63;
  int v64;
  int16x8x2_t v65;
  int16x8x2_t v66;
  int16x8x2_t v67;
  int16x8x2_t v68;

  if ((int)a5 >= a4)
  {
    v29 = 2 * (int)a5;
  }
  else
  {
    if ((int)a5 > 6)
    {
      v5 = a5;
      v6 = 8;
      if (a5 > 8uLL)
        v6 = a5;
      v7 = v6 - 7;
      v8 = (v7 >> 1) + 1;
      v9 = a2 + 2 * a5;
      v10 = (const __int16 *)(v9 - 76);
      v11 = v9 - 2;
      a5 = a5;
      while (1)
      {
        v13 = vaddvq_s32(vmull_s16(vrev64_s16(*(int16x4_t *)(a2 + 2 * a5 - 8)), *a3))
            + a3[1].i16[0] * *(__int16 *)(a2 + 2 * a5 - 10)
            + a3[1].i16[1] * *(__int16 *)(a2 + 2 * a5 - 12);
        if (v7 >= 0x1E)
        {
          v15 = (int32x4_t)v13;
          v16 = 0uLL;
          v17 = v8 & 0x7FFFFFFFFFFFFFF0;
          v18 = v10;
          v19 = (const __int16 *)&a3[5] + 2;
          v20 = 0uLL;
          v21 = 0uLL;
          do
          {
            v22 = v18;
            v65 = vld2q_s16(v22);
            v22 += 16;
            v66 = vld2q_s16(v22);
            v23 = (int8x16_t)vrev64q_s16(v66.val[0]);
            v24 = (int16x8_t)vextq_s8(v23, v23, 8uLL);
            v25 = (int8x16_t)vrev64q_s16(v65.val[0]);
            v26 = (int16x8_t)vextq_s8(v25, v25, 8uLL);
            v66.val[0] = vrev64q_s16(v66.val[1]);
            v27 = v19 - 16;
            v67 = vld2q_s16(v27);
            v66.val[0] = (int16x8_t)vextq_s8((int8x16_t)v66.val[0], (int8x16_t)v66.val[0], 8uLL);
            v65.val[0] = vrev64q_s16(v65.val[1]);
            v68 = vld2q_s16(v19);
            v65.val[0] = (int16x8_t)vextq_s8((int8x16_t)v65.val[0], (int8x16_t)v65.val[0], 8uLL);
            v16 = vmlal_high_s16(vmlal_high_s16(v16, v67.val[0], v66.val[0]), v67.val[1], v24);
            v15 = vmlal_s16(vmlal_s16(v15, *(int16x4_t *)v67.val[0].i8, *(int16x4_t *)v66.val[0].i8), *(int16x4_t *)v67.val[1].i8, *(int16x4_t *)v24.i8);
            v21 = vmlal_high_s16(vmlal_high_s16(v21, v68.val[0], v65.val[0]), v68.val[1], v26);
            v20 = vmlal_s16(vmlal_s16(v20, *(int16x4_t *)v68.val[0].i8, *(int16x4_t *)v65.val[0].i8), *(int16x4_t *)v68.val[1].i8, *(int16x4_t *)v26.i8);
            v19 += 32;
            v18 -= 32;
            v17 -= 16;
          }
          while (v17);
          v13 = vaddvq_s32(vaddq_s32(vaddq_s32(v20, v15), vaddq_s32(v21, v16)));
          v14 = (32 * ((v8 & 0x7FFFFFFFFFFFFFF0uLL) >> 4)) | 6;
          if (v8 == (v8 & 0x7FFFFFFFFFFFFFF0))
            goto LABEL_6;
        }
        else
        {
          v14 = 6;
        }
        v28 = (__int16 *)(v11 - 2 * v14);
        do
        {
          v13 += a3->i16[v14] * *v28 + *(__int16 *)((char *)a3->i16 + ((2 * v14) | 2)) * *(v28 - 1);
          v14 += 2;
          v28 -= 2;
        }
        while (v14 < v5);
LABEL_6:
        v12 = (((int)((*(__int16 *)(a2 + 2 * a5) << 12) - v13) >> 11) + 1) >> 1;
        if (v12 <= -32768)
          v12 = -32768;
        if (v12 >= 0x7FFF)
          LOWORD(v12) = 0x7FFF;
        a1[a5++] = v12;
        ++v10;
        v11 += 2;
        if (a5 == a4)
          goto LABEL_43;
      }
    }
    v5 = (int)a5;
    v30 = a4 - (uint64_t)(int)a5;
    v31 = (int)a5;
    if (v30 < 8)
      goto LABEL_37;
    v32 = (int)a5;
    v33 = (unint64_t)&a1[a4];
    v34 = &a1[v32] < (_WORD *)&a3[1] + 2 && v33 > (unint64_t)a3;
    v35 = v34;
    v36 = 2 * (int)a5 + a2 - 12 >= v33 || (unint64_t)&a1[v32] >= a2 + 2 * a4;
    v31 = (int)a5;
    if (!v36)
      goto LABEL_37;
    v31 = (int)a5;
    if (v35)
      goto LABEL_37;
    v31 = (v30 & 0xFFFFFFFFFFFFFFF8) + (int)a5;
    v37 = (const __int16 *)a3;
    v38 = vld1_dup_s16(v37++);
    v39 = vmovl_s16(v38);
    v40 = vld1_dup_s16(v37);
    v41 = vmovl_s16(v40);
    v42 = (const __int16 *)a3 + 2;
    v43 = vld1_dup_s16(v42);
    v44 = vmovl_s16(v43);
    v45 = (const __int16 *)a3 + 3;
    v46 = vld1_dup_s16(v45);
    v47 = vmovl_s16(v46);
    v48 = (const __int16 *)&a3[1];
    v49 = vld1_dup_s16(v48);
    v50 = vmovl_s16(v49);
    v51 = (const __int16 *)&a3[1] + 1;
    v52 = vld1_dup_s16(v51);
    v53 = vmovl_s16(v52);
    v54 = (int16x8_t *)&a1[v32];
    v55 = v32 * 2 + a2 - 6;
    v56.i64[0] = 0x100000001;
    v56.i64[1] = 0x100000001;
    v57 = v30 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      *v54++ = vqmovn_high_s32(vqmovn_s32(vhaddq_s32(vshrq_n_s32(vsubq_s32(vshll_n_s16(*(int16x4_t *)(v55 + 6), 0xCuLL), vmlaq_s32(vmlaq_s32(vmlaq_s32(vmlaq_s32(vmlaq_s32(vmulq_s32(v39, vmovl_s16(*(int16x4_t *)(v55 + 4))), v41, vmovl_s16(*(int16x4_t *)(v55 + 2))), v44, vmovl_s16(*(int16x4_t *)v55)), v47, vmovl_s16(*(int16x4_t *)(v55 - 2))), v50, vmovl_s16(*(int16x4_t *)(v55 - 4))),
                           v53,
                           vmovl_s16(*(int16x4_t *)(v55 - 6)))),
                       0xBuLL),
                     v56)),
                 vhaddq_s32(vshrq_n_s32(vsubq_s32(vshll_high_n_s16(*(int16x8_t *)(v55 + 6), 0xCuLL), vmlaq_s32(vmlaq_s32(vmlaq_s32(vmlaq_s32(vmlaq_s32(vmulq_s32(v39, vmovl_high_s16(*(int16x8_t *)(v55 + 4))), v41, vmovl_high_s16(*(int16x8_t *)(v55 + 2))), v44, vmovl_high_s16(*(int16x8_t *)v55)), v47, vmovl_high_s16(*(int16x8_t *)(v55 - 2))), v50, vmovl_high_s16(*(int16x8_t *)(v55 - 4))), v53, vmovl_high_s16(*(int16x8_t *)(v55 - 6)))),
                     0xBuLL),
                   v56));
      v55 += 16;
      v57 -= 8;
    }
    while (v57);
    if (v30 != (v30 & 0xFFFFFFFFFFFFFFF8))
    {
LABEL_37:
      v58 = a4 - v31;
      v59 = v31;
      v60 = &a1[v59];
      v61 = (__int16 *)(v59 * 2 + a2 - 12);
      v62 = v61;
      do
      {
        v63 = v62[1];
        ++v62;
        v64 = ((((v61[6] << 12)
               - (vaddvq_s32(vmull_s16(vrev64_s16(*(int16x4_t *)(v61 + 2)), *a3))
                + a3[1].i16[0] * v63
                + a3[1].i16[1] * *v61)) >> 11)
             + 1) >> 1;
        if (v64 <= -32768)
          v64 = -32768;
        if (v64 >= 0x7FFF)
          LOWORD(v64) = 0x7FFF;
        *v60++ = v64;
        v61 = v62;
        --v58;
      }
      while (v58);
    }
LABEL_43:
    v29 = 2 * v5;
  }
  bzero(a1, v29);
}

void silk_LPC_analysis_filter_FLP(float *a1, float *a2, unint64_t a3, unsigned int a4, int a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  BOOL v17;
  BOOL v18;
  const float *v19;
  float32x4_t v20;
  float32x4_t v21;
  const float *v22;
  float32x4_t v23;
  const float *v24;
  float32x4_t v25;
  const float *v26;
  float32x4_t v27;
  const float *v28;
  float32x4_t v29;
  float32x4_t *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  float *v35;
  float *v36;
  float *v37;
  float v38;
  char *v39;
  BOOL v41;
  BOOL v42;
  const float *v43;
  float32x4_t v44;
  float32x4_t v45;
  const float *v46;
  float32x4_t v47;
  const float *v48;
  float32x4_t v49;
  const float *v50;
  float32x4_t v51;
  const float *v52;
  float32x4_t v53;
  const float *v54;
  float32x4_t v55;
  const float *v56;
  float32x4_t v57;
  float32x4_t *v58;
  unint64_t v59;
  unint64_t v60;
  float32x4_t v61;
  float32x4_t v62;
  unint64_t v63;
  uint64_t v64;
  float *v65;
  float *v66;
  float *v67;
  float v68;
  char *v69;
  BOOL v71;
  BOOL v72;
  const float *v73;
  float32x4_t v74;
  float32x4_t v75;
  const float *v76;
  float32x4_t v77;
  const float *v78;
  float32x4_t v79;
  const float *v80;
  float32x4_t v81;
  const float *v82;
  float32x4_t v83;
  const float *v84;
  float32x4_t v85;
  const float *v86;
  float32x4_t v87;
  const float *v88;
  float32x4_t v89;
  const float *v90;
  float32x4_t v91;
  float32x4_t *v92;
  float32x4_t *v93;
  unint64_t v94;
  float32x4_t *v95;
  float32x4_t v96;
  unint64_t v97;
  uint64_t v98;
  float *v99;
  float *v100;
  float *v101;
  float v102;
  char *v103;
  BOOL v105;
  BOOL v106;
  const float *v107;
  float32x4_t v108;
  float32x4_t v109;
  const float *v110;
  float32x4_t v111;
  const float *v112;
  float32x4_t v113;
  const float *v114;
  float32x4_t v115;
  const float *v116;
  float32x4_t v117;
  const float *v118;
  float32x4_t v119;
  const float *v120;
  float32x4_t v121;
  const float *v122;
  float32x4_t v123;
  const float *v124;
  float32x4_t v125;
  const float *v126;
  float32x4_t v127;
  const float *v128;
  float32x4_t v129;
  float32x4_t *v130;
  float32x4_t *v131;
  unint64_t v132;
  float32x4_t *v133;
  float32x4_t v134;
  unint64_t v135;
  uint64_t v136;
  float *v137;
  float *v138;
  float *v139;
  float v140;
  char *v141;
  BOOL v143;
  BOOL v144;
  const float *v145;
  float32x4_t v146;
  float32x4_t v147;
  const float *v148;
  float32x4_t v149;
  const float *v150;
  float32x4_t v151;
  const float *v152;
  float32x4_t v153;
  const float *v154;
  float32x4_t v155;
  const float *v156;
  float32x4_t v157;
  const float *v158;
  float32x4_t v159;
  const float *v160;
  float32x4_t v161;
  const float *v162;
  float32x4_t v163;
  const float *v164;
  float32x4_t v165;
  const float *v166;
  float32x4_t v167;
  const float *v168;
  float32x4_t v169;
  const float *v170;
  float32x4_t v171;
  const float *v172;
  float32x4_t v173;
  const float *v174;
  float32x4_t v175;
  float32x4_t *v176;
  float32x4_t *v177;
  unint64_t v178;
  float32x4_t *v179;
  float32x4_t v180;
  unint64_t v181;
  uint64_t v182;
  float *v183;
  float *v184;
  float *v185;
  float v186;

  switch(a5)
  {
    case 6:
      if ((int)a4 < 7)
        goto LABEL_106;
      v5 = a4 - 6;
      if (v5 < 4)
      {
        v6 = 6;
LABEL_32:
        v33 = a4 - v6;
        v34 = v6;
        v35 = &a1[v34];
        v36 = (float *)(v34 * 4 + a3 - 12);
        v37 = v36;
        do
        {
          v38 = v37[1];
          ++v37;
          *v35++ = v36[3]
                 - (float)((float)((float)((float)((float)((float)(v38 * a2[1]) + (float)(v36[2] * *a2))
                                                 + (float)(*v36 * a2[2]))
                                         + (float)(*(v36 - 1) * a2[3]))
                                 + (float)(*(v36 - 2) * a2[4]))
                         + (float)(*(v36 - 3) * a2[5]));
          v36 = v37;
          --v33;
        }
        while (v33);
        goto LABEL_106;
      }
      v15 = (char *)&a1[a4];
      v17 = a1 < a2 && v15 > (char *)a2;
      v18 = (unint64_t)v15 <= a3 || (unint64_t)(a1 + 6) >= a3 + 4 * a4;
      v6 = 6;
      if (!v18)
        goto LABEL_32;
      if (v17)
        goto LABEL_32;
      v19 = a2;
      v20 = vld1q_dup_f32(v19++);
      v6 = (v5 & 0xFFFFFFFFFFFFFFFCLL) + 6;
      v21 = vld1q_dup_f32(v19);
      v22 = a2 + 2;
      v23 = vld1q_dup_f32(v22);
      v24 = a2 + 3;
      v25 = vld1q_dup_f32(v24);
      v26 = a2 + 4;
      v27 = vld1q_dup_f32(v26);
      v28 = a2 + 5;
      v29 = vld1q_dup_f32(v28);
      v30 = (float32x4_t *)(a1 + 6);
      v31 = a3 + 12;
      v32 = v5 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        *v30++ = vsubq_f32(*(float32x4_t *)(v31 + 12), vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(*(float32x4_t *)(v31 + 4), v21), v20, *(float32x4_t *)(v31 + 8)), v23, *(float32x4_t *)v31), v25, *(float32x4_t *)(v31 - 4)), v27, *(float32x4_t *)(v31 - 8)), v29, *(float32x4_t *)(v31 - 12)));
        v31 += 16;
        v32 -= 4;
      }
      while (v32);
      if (v5 != (v5 & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_32;
      goto LABEL_106;
    case 8:
      if ((int)a4 < 9)
        goto LABEL_106;
      v7 = a4 - 8;
      if (v7 < 4)
      {
        v8 = 8;
LABEL_50:
        v63 = a4 - v8;
        v64 = v8;
        v65 = &a1[v64];
        v66 = (float *)(v64 * 4 + a3 - 16);
        v67 = v66;
        do
        {
          v68 = v67[1];
          ++v67;
          *v65++ = v66[4]
                 - (float)((float)((float)((float)((float)((float)((float)((float)(v66[2] * a2[1])
                                                                         + (float)(v66[3] * *a2))
                                                                 + (float)(v68 * a2[2]))
                                                         + (float)(*v66 * a2[3]))
                                                 + (float)(*(v66 - 1) * a2[4]))
                                         + (float)(*(v66 - 2) * a2[5]))
                                 + (float)(*(v66 - 3) * a2[6]))
                         + (float)(*(v66 - 4) * a2[7]));
          v66 = v67;
          --v63;
        }
        while (v63);
        goto LABEL_106;
      }
      v39 = (char *)&a1[a4];
      v41 = a1 < a2 && v39 > (char *)a2;
      v42 = (unint64_t)v39 <= a3 || (unint64_t)(a1 + 8) >= a3 + 4 * a4;
      v8 = 8;
      if (!v42)
        goto LABEL_50;
      if (v41)
        goto LABEL_50;
      v43 = a2;
      v44 = vld1q_dup_f32(v43++);
      v8 = (v7 & 0xFFFFFFFFFFFFFFFCLL) + 8;
      v45 = vld1q_dup_f32(v43);
      v46 = a2 + 2;
      v47 = vld1q_dup_f32(v46);
      v48 = a2 + 3;
      v49 = vld1q_dup_f32(v48);
      v50 = a2 + 4;
      v51 = vld1q_dup_f32(v50);
      v52 = a2 + 5;
      v53 = vld1q_dup_f32(v52);
      v54 = a2 + 6;
      v55 = vld1q_dup_f32(v54);
      v56 = a2 + 7;
      v57 = vld1q_dup_f32(v56);
      v58 = (float32x4_t *)(a1 + 8);
      v59 = a3 + 16;
      v60 = v7 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v61 = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(*(float32x4_t *)(v59 + 8), v45), v44, *(float32x4_t *)(v59 + 12)), v47, *(float32x4_t *)(v59 + 4)), v49, *(float32x4_t *)v59), v51, *(float32x4_t *)(v59 - 4)), v53, *(float32x4_t *)(v59 - 8)), v55, *(float32x4_t *)(v59 - 12)), v57, *(float32x4_t *)(v59 - 16));
        v62 = *(float32x4_t *)(v59 + 16);
        v59 += 16;
        *v58++ = vsubq_f32(v62, v61);
        v60 -= 4;
      }
      while (v60);
      if (v7 != (v7 & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_50;
      goto LABEL_106;
    case 10:
      if ((int)a4 < 11)
        goto LABEL_106;
      v9 = a4 - 10;
      if (v9 < 4)
      {
        v10 = 10;
LABEL_68:
        v97 = a4 - v10;
        v98 = v10;
        v99 = &a1[v98];
        v100 = (float *)(v98 * 4 + a3 - 20);
        v101 = v100;
        do
        {
          v102 = v101[1];
          ++v101;
          *v99++ = v100[5]
                 - (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v100[3] * a2[1])
                                                                                         + (float)(v100[4] * *a2))
                                                                                 + (float)(v100[2] * a2[2]))
                                                                         + (float)(v102 * a2[3]))
                                                                 + (float)(*v100 * a2[4]))
                                                         + (float)(*(v100 - 1) * a2[5]))
                                                 + (float)(*(v100 - 2) * a2[6]))
                                         + (float)(*(v100 - 3) * a2[7]))
                                 + (float)(*(v100 - 4) * a2[8]))
                         + (float)(*(v100 - 5) * a2[9]));
          v100 = v101;
          --v97;
        }
        while (v97);
        goto LABEL_106;
      }
      v69 = (char *)&a1[a4];
      v71 = a1 < a2 && v69 > (char *)a2;
      v72 = (unint64_t)v69 <= a3 || (unint64_t)(a1 + 10) >= a3 + 4 * a4;
      v10 = 10;
      if (!v72)
        goto LABEL_68;
      if (v71)
        goto LABEL_68;
      v10 = (v9 & 0xFFFFFFFFFFFFFFFCLL) + 10;
      v73 = a2;
      v74 = vld1q_dup_f32(v73++);
      v75 = vld1q_dup_f32(v73);
      v76 = a2 + 2;
      v77 = vld1q_dup_f32(v76);
      v78 = a2 + 3;
      v79 = vld1q_dup_f32(v78);
      v80 = a2 + 4;
      v81 = vld1q_dup_f32(v80);
      v82 = a2 + 5;
      v83 = vld1q_dup_f32(v82);
      v84 = a2 + 6;
      v85 = vld1q_dup_f32(v84);
      v86 = a2 + 7;
      v87 = vld1q_dup_f32(v86);
      v88 = a2 + 8;
      v89 = vld1q_dup_f32(v88);
      v90 = a2 + 9;
      v91 = vld1q_dup_f32(v90);
      v92 = (float32x4_t *)(a1 + 10);
      v93 = (float32x4_t *)(a3 + 20);
      v94 = v9 & 0xFFFFFFFFFFFFFFFCLL;
      v95 = (float32x4_t *)(a3 + 20);
      do
      {
        v96 = v95[1];
        ++v95;
        *v92++ = vsubq_f32(*(float32x4_t *)((char *)v93 + 20), vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)v93 + 12), v75), v74, v96), v77, *(float32x4_t *)((char *)v93 + 8)), v79, *(float32x4_t *)((char *)v93 + 4)), v81, *v93), v83, *(float32x4_t *)((char *)v93 - 4)), v85,
                           *(float32x4_t *)((char *)v93 - 8)),
                         v87,
                         *(float32x4_t *)((char *)v93 - 12)),
                       v89,
                       v93[-1]),
                     v91,
                     *(float32x4_t *)((char *)v93 - 20)));
        v93 = v95;
        v94 -= 4;
      }
      while (v94);
      if (v9 != (v9 & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_68;
      goto LABEL_106;
    case 12:
      if ((int)a4 < 13)
        goto LABEL_106;
      v11 = a4 - 12;
      if (v11 < 4)
      {
        v12 = 12;
LABEL_86:
        v135 = a4 - v12;
        v136 = 4 * v12;
        v137 = &a1[v12];
        v138 = (float *)(v136 + a3 - 24);
        v139 = v138;
        do
        {
          v140 = v139[1];
          ++v139;
          *v137++ = v138[6]
                  - (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v138[4] * a2[1]) + (float)(v138[5] * *a2))
                                                                                                  + (float)(v138[3] * a2[2]))
                                                                                          + (float)(v138[2] * a2[3]))
                                                                                  + (float)(v140 * a2[4]))
                                                                          + (float)(*v138 * a2[5]))
                                                                  + (float)(*(v138 - 1) * a2[6]))
                                                          + (float)(*(v138 - 2) * a2[7]))
                                                  + (float)(*(v138 - 3) * a2[8]))
                                          + (float)(*(v138 - 4) * a2[9]))
                                  + (float)(*(v138 - 5) * a2[10]))
                          + (float)(*(v138 - 6) * a2[11]));
          v138 = v139;
          --v135;
        }
        while (v135);
        goto LABEL_106;
      }
      v103 = (char *)&a1[a4];
      v105 = a1 < a2 && v103 > (char *)a2;
      v106 = (unint64_t)v103 <= a3 || (unint64_t)(a1 + 12) >= a3 + 4 * a4;
      v12 = 12;
      if (!v106)
        goto LABEL_86;
      if (v105)
        goto LABEL_86;
      v12 = (v11 & 0xFFFFFFFFFFFFFFFCLL) + 12;
      v107 = a2;
      v108 = vld1q_dup_f32(v107++);
      v109 = vld1q_dup_f32(v107);
      v110 = a2 + 2;
      v111 = vld1q_dup_f32(v110);
      v112 = a2 + 3;
      v113 = vld1q_dup_f32(v112);
      v114 = a2 + 4;
      v115 = vld1q_dup_f32(v114);
      v116 = a2 + 5;
      v117 = vld1q_dup_f32(v116);
      v118 = a2 + 6;
      v119 = vld1q_dup_f32(v118);
      v120 = a2 + 7;
      v121 = vld1q_dup_f32(v120);
      v122 = a2 + 8;
      v123 = vld1q_dup_f32(v122);
      v124 = a2 + 9;
      v125 = vld1q_dup_f32(v124);
      v126 = a2 + 10;
      v127 = vld1q_dup_f32(v126);
      v128 = a2 + 11;
      v129 = vld1q_dup_f32(v128);
      v130 = (float32x4_t *)(a1 + 12);
      v131 = (float32x4_t *)(a3 + 24);
      v132 = v11 & 0xFFFFFFFFFFFFFFFCLL;
      v133 = (float32x4_t *)(a3 + 24);
      do
      {
        v134 = v133[1];
        ++v133;
        *v130++ = vsubq_f32(*(float32x4_t *)((char *)v131 + 24), vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(v134, v109), v108, *(float32x4_t *)((char *)v131 + 20)), v111, *(float32x4_t *)((char *)v131 + 12)), v113, *(float32x4_t *)((char *)v131 + 8)), v115, *(float32x4_t *)((char *)v131 + 4)), v117,
                                  *v131),
                                v119,
                                *(float32x4_t *)((char *)v131 - 4)),
                              v121,
                              *(float32x4_t *)((char *)v131 - 8)),
                            v123,
                            *(float32x4_t *)((char *)v131 - 12)),
                          v125,
                          v131[-1]),
                        v127,
                        *(float32x4_t *)((char *)v131 - 20)),
                      v129,
                      *(float32x4_t *)((char *)v131 - 24)));
        v131 = v133;
        v132 -= 4;
      }
      while (v132);
      if (v11 != (v11 & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_86;
      goto LABEL_106;
    case 16:
      if ((int)a4 < 17)
        goto LABEL_106;
      v13 = a4 - 16;
      if (v13 < 4)
      {
        v14 = 16;
LABEL_104:
        v181 = a4 - v14;
        v182 = v14;
        v183 = &a1[v182];
        v184 = (float *)(v182 * 4 + a3 - 32);
        v185 = v184;
        do
        {
          v186 = v185[1];
          ++v185;
          *v183++ = v184[8]
                  - (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v184[6] * a2[1]) + (float)(v184[7] * *a2)) + (float)(v184[5] * a2[2])) + (float)(v184[4] * a2[3])) + (float)(v184[3] * a2[4])) + (float)(v184[2] * a2[5]))
                                                                                                  + (float)(v186 * a2[6]))
                                                                                          + (float)(*v184 * a2[7]))
                                                                                  + (float)(*(v184 - 1) * a2[8]))
                                                                          + (float)(*(v184 - 2) * a2[9]))
                                                                  + (float)(*(v184 - 3) * a2[10]))
                                                          + (float)(*(v184 - 4) * a2[11]))
                                                  + (float)(*(v184 - 5) * a2[12]))
                                          + (float)(*(v184 - 6) * a2[13]))
                                  + (float)(*(v184 - 7) * a2[14]))
                          + (float)(*(v184 - 8) * a2[15]));
          v184 = v185;
          --v181;
        }
        while (v181);
        goto LABEL_106;
      }
      v141 = (char *)&a1[a4];
      v143 = a1 < a2 && v141 > (char *)a2;
      v144 = (unint64_t)v141 <= a3 || (unint64_t)(a1 + 16) >= a3 + 4 * a4;
      v14 = 16;
      if (!v144)
        goto LABEL_104;
      if (v143)
        goto LABEL_104;
      v14 = (v13 & 0xFFFFFFFFFFFFFFFCLL) + 16;
      v145 = a2;
      v146 = vld1q_dup_f32(v145++);
      v147 = vld1q_dup_f32(v145);
      v148 = a2 + 2;
      v149 = vld1q_dup_f32(v148);
      v150 = a2 + 3;
      v151 = vld1q_dup_f32(v150);
      v152 = a2 + 4;
      v153 = vld1q_dup_f32(v152);
      v154 = a2 + 5;
      v155 = vld1q_dup_f32(v154);
      v156 = a2 + 6;
      v157 = vld1q_dup_f32(v156);
      v158 = a2 + 7;
      v159 = vld1q_dup_f32(v158);
      v160 = a2 + 8;
      v161 = vld1q_dup_f32(v160);
      v162 = a2 + 9;
      v163 = vld1q_dup_f32(v162);
      v164 = a2 + 10;
      v165 = vld1q_dup_f32(v164);
      v166 = a2 + 11;
      v167 = vld1q_dup_f32(v166);
      v168 = a2 + 12;
      v169 = vld1q_dup_f32(v168);
      v170 = a2 + 13;
      v171 = vld1q_dup_f32(v170);
      v172 = a2 + 14;
      v173 = vld1q_dup_f32(v172);
      v174 = a2 + 15;
      v175 = vld1q_dup_f32(v174);
      v176 = (float32x4_t *)(a1 + 16);
      v177 = (float32x4_t *)(a3 + 32);
      v178 = v13 & 0xFFFFFFFFFFFFFFFCLL;
      v179 = (float32x4_t *)(a3 + 32);
      do
      {
        v180 = v179[1];
        ++v179;
        *v176++ = vsubq_f32(v177[2], vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(*(float32x4_t *)((char *)v177 + 24), v147), v146, *(float32x4_t *)((char *)v177 + 28)),
                                                v149,
                                                *(float32x4_t *)((char *)v177 + 20)),
                                              v151,
                                              v180),
                                            v153,
                                            *(float32x4_t *)((char *)v177 + 12)),
                                          v155,
                                          *(float32x4_t *)((char *)v177 + 8)),
                                        v157,
                                        *(float32x4_t *)((char *)v177 + 4)),
                                      v159,
                                      *v177),
                                    v161,
                                    *(float32x4_t *)((char *)v177 - 4)),
                                  v163,
                                  *(float32x4_t *)((char *)v177 - 8)),
                                v165,
                                *(float32x4_t *)((char *)v177 - 12)),
                              v167,
                              v177[-1]),
                            v169,
                            *(float32x4_t *)((char *)v177 - 20)),
                          v171,
                          *(float32x4_t *)((char *)v177 - 24)),
                        v173,
                        *(float32x4_t *)((char *)v177 - 28)),
                      v175,
                      v177[-2]));
        v177 = v179;
        v178 -= 4;
      }
      while (v178);
      if (v13 != (v13 & 0xFFFFFFFFFFFFFFFCLL))
        goto LABEL_104;
LABEL_106:
      bzero(a1, 4 * a5);
      return;
    default:
      goto LABEL_106;
  }
}

uint64_t silk_LPC_fit(uint64_t result, int8x16_t *a2, int a3, int a4, unsigned int a5)
{
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  int v12;
  signed int v13;
  int v14;
  int v15;
  int v16;
  int8x16_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int8x16_t v22;
  int32x4_t v23;
  int32x4_t v24;
  uint64_t v25;
  int16x8_t *v26;
  int8x16_t *v27;
  int32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  int32x4_t v31;
  uint64_t v32;
  _WORD *v33;
  int *v34;
  int v35;
  uint32x4_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int8x16_t v41;
  int8x16_t v42;
  uint64_t v43;
  int16x8_t *v44;
  int32x4_t *v45;
  int32x4_t v46;
  int32x4_t v47;
  int16x8_t v48;
  int16x8_t v49;
  uint64_t v50;
  _WORD *v51;
  int *v52;
  int v53;
  int v54;
  uint64_t v55;
  int8x16_t *v56;
  int16x8_t *v57;
  int8x16_t v58;
  uint64_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  uint64_t v64;
  _WORD *v65;
  int *v66;
  unsigned int v67;
  int32x4_t *v68;
  int16x8_t *v69;
  int32x4_t v70;
  uint64_t v71;
  int32x4_t v72;
  int32x4_t v73;
  int32x4_t v74;
  int32x4_t v75;
  uint64_t v76;
  _WORD *v77;
  int *v78;
  int v79;

  if ((int)a5 >= 1)
  {
    v5 = 0;
    v6 = 0;
    v7 = a4 - a3;
    v8 = a4 - a3 - 1;
    do
    {
      v9 = 0;
      v10 = 0;
      do
      {
        v11 = a2->i32[v9];
        if (v11 < 0)
          v11 = -v11;
        if (v11 > (int)v10)
        {
          v5 = v9;
          v10 = v11;
        }
        ++v9;
      }
      while (a5 != v9);
      v12 = (v10 & 1) + (v10 >> 1);
      v13 = ((v10 >> v8) + 1) >> 1;
      if (v7 == 1)
        v13 = v12;
      if (v13 < 0x8000)
      {
        if (v7 == 1)
        {
          if (a5 >= 0x10)
          {
            v21 = a5 & 0xFFFFFFF0;
            v56 = a2 + 2;
            v57 = (int16x8_t *)(result + 16);
            v58.i64[0] = 0x100000001;
            v58.i64[1] = 0x100000001;
            v59 = v21;
            do
            {
              v61 = v56[-2];
              v60 = v56[-1];
              v63 = *v56;
              v62 = v56[1];
              v56 += 4;
              v57[-1] = vuzp1q_s16((int16x8_t)vsraq_n_u32((uint32x4_t)vandq_s8(v61, v58), (uint32x4_t)v61, 1uLL), (int16x8_t)vsraq_n_u32((uint32x4_t)vandq_s8(v60, v58), (uint32x4_t)v60, 1uLL));
              *v57 = vuzp1q_s16((int16x8_t)vsraq_n_u32((uint32x4_t)vandq_s8(v63, v58), (uint32x4_t)v63, 1uLL), (int16x8_t)vsraq_n_u32((uint32x4_t)vandq_s8(v62, v58), (uint32x4_t)v62, 1uLL));
              v57 += 2;
              v59 -= 16;
            }
            while (v59);
            if (v21 == a5)
              return result;
          }
          else
          {
            v21 = 0;
          }
          v64 = a5 - v21;
          v65 = (_WORD *)(result + 2 * v21);
          v66 = &a2->i32[v21];
          do
          {
            v67 = *v66++;
            *v65++ = (v67 & 1) + (v67 >> 1);
            --v64;
          }
          while (v64);
          return result;
        }
        if (a5 >= 0x10)
        {
          v55 = a5 & 0xFFFFFFF0;
          v68 = (int32x4_t *)&a2[2];
          v69 = (int16x8_t *)(result + 16);
          v70 = vnegq_s32(vdupq_n_s32(v8));
          v71 = v55;
          do
          {
            v72 = v68[-2];
            v73 = v68[-1];
            v74 = *v68;
            v75 = v68[1];
            v68 += 4;
            v69[-1] = vrshrn_high_n_s32(vrshrn_n_s32(vshlq_s32(v72, v70), 1uLL), vshlq_s32(v73, v70), 1uLL);
            *v69 = vrshrn_high_n_s32(vrshrn_n_s32(vshlq_s32(v74, v70), 1uLL), vshlq_s32(v75, v70), 1uLL);
            v69 += 2;
            v71 -= 16;
          }
          while (v71);
          if (v55 == a5)
            return result;
        }
        else
        {
          v55 = 0;
        }
        v76 = a5 - v55;
        v77 = (_WORD *)(result + 2 * v55);
        v78 = &a2->i32[v55];
        do
        {
          v79 = *v78++;
          *v77++ = ((v79 >> v8) + 1) >> 1;
          --v76;
        }
        while (v76);
        return result;
      }
      if (v13 >= 163838)
        v13 = 163838;
      v14 = ((v13 << 14) - 536854528) / ((v13 + v13 * v5) >> 2);
      v15 = 65470 - v14;
      if (a5 != 1)
      {
        v16 = -66 - v14;
        v17 = a2;
        v18 = a5 - 1;
        do
        {
          v17->i32[0] = (unint64_t)(v17->i32[0] * (uint64_t)v15) >> 16;
          v17 = (int8x16_t *)((char *)v17 + 4);
          v15 += (((v15 * v16) >> 15) + 1) >> 1;
          --v18;
        }
        while (v18);
      }
      a2->i32[a5 - 1] = (unint64_t)(a2->i32[a5 - 1] * (uint64_t)v15) >> 16;
      ++v6;
    }
    while (v6 != 10);
    if (v7 == 1)
    {
      if (a5 >= 8)
      {
        v19 = a5 & 0x7FFFFFF8;
        v22.i64[0] = 0x100000001;
        v22.i64[1] = 0x100000001;
        v23.i64[0] = 0x7F0000007FLL;
        v23.i64[1] = 0x7F0000007FLL;
        v24.i64[0] = 0x7F0000007FLL;
        v24.i64[1] = 0x7F0000007FLL;
        v25 = a5 & 0xFFFFFFF8;
        v26 = (int16x8_t *)result;
        v27 = a2;
        do
        {
          v28 = vsraq_n_s32((int32x4_t)vandq_s8(*v27, v22), *(int32x4_t *)v27, 1uLL);
          v29 = vsraq_n_s32((int32x4_t)vandq_s8(v27[1], v22), (int32x4_t)v27[1], 1uLL);
          v30 = vminq_s32(vmaxq_s32(v28, v23), v24);
          v31 = vminq_s32(vmaxq_s32(v29, v23), v24);
          *v26++ = vqmovn_high_s32(vqmovn_s32(v28), v29);
          *(int32x4_t *)v27 = vaddq_s32(v30, v30);
          v27[1] = (int8x16_t)vaddq_s32(v31, v31);
          v27 += 2;
          v25 -= 8;
        }
        while (v25);
        if (v19 == a5)
          return result;
      }
      else
      {
        v19 = 0;
      }
      v32 = a5 - v19;
      v33 = (_WORD *)(result + 2 * v19);
      v34 = &a2->i32[v19];
      do
      {
        v35 = (*v34 & 1) + (*v34 >> 1);
        if (v35 <= -32768)
          v35 = -32768;
        if (v35 >= 0x7FFF)
          v35 = 0x7FFF;
        *v33++ = v35;
        *v34++ = 2 * v35;
        --v32;
      }
      while (v32);
    }
    else
    {
      if (a5 >= 8)
      {
        v36 = (uint32x4_t)vdupq_n_s32(v7);
        v20 = a5 & 0xFFFFFFF8;
        v37 = vnegq_s32(vdupq_n_s32(v8));
        v38.i64[0] = 0xFFFF0000FFFFLL;
        v38.i64[1] = 0xFFFF0000FFFFLL;
        v39.i64[0] = 0x1000000010000;
        v39.i64[1] = 0x1000000010000;
        v40.i64[0] = 0x100000001;
        v40.i64[1] = 0x100000001;
        v41.i64[0] = 0x7F0000007FLL;
        v41.i64[1] = 0x7F0000007FLL;
        v42.i64[0] = 0x7F0000007FLL;
        v42.i64[1] = 0x7F0000007FLL;
        v43 = v20;
        v44 = (int16x8_t *)result;
        v45 = (int32x4_t *)a2;
        do
        {
          v46 = vshlq_s32(v45[1], v37);
          v47 = vshlq_s32(*v45, v37);
          v48 = (int16x8_t)vbslq_s8((int8x16_t)vcgtq_s32(v39, v47), v42, vbslq_s8((int8x16_t)vcgtq_s32(v38, v47), (int8x16_t)vshrq_n_s32(vaddq_s32(v47, v40), 1uLL), v41));
          v49 = (int16x8_t)vbslq_s8((int8x16_t)vcgtq_s32(v39, v46), v42, vbslq_s8((int8x16_t)vcgtq_s32(v38, v46), (int8x16_t)vshrq_n_s32(vaddq_s32(v46, v40), 1uLL), v41));
          *v44++ = vuzp1q_s16(v48, v49);
          *(uint32x4_t *)v45 = vshlq_u32((uint32x4_t)v48, v36);
          v45[1] = (int32x4_t)vshlq_u32((uint32x4_t)v49, v36);
          v45 += 2;
          v43 -= 8;
        }
        while (v43);
        if (v20 == a5)
          return result;
      }
      else
      {
        v20 = 0;
      }
      v50 = a5 - v20;
      v51 = (_WORD *)(result + 2 * v20);
      v52 = &a2->i32[v20];
      do
      {
        v53 = *v52 >> v8;
        LODWORD(result) = (v53 + 1) >> 1;
        if (v53 >= -65537)
          result = result;
        else
          result = 4294934528;
        if (v53 <= 65534)
          v54 = result;
        else
          v54 = 0x7FFF;
        *v51++ = v54;
        *v52++ = v54 << v7;
        --v50;
      }
      while (v50);
    }
  }
  return result;
}

unint64_t silk_LPC_inverse_pred_gain_c(int16x8_t *a1, int a2)
{
  unint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  int16x8_t *v7;
  int32x4_t *v8;
  int32x4_t v9;
  uint64_t v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int32x4_t v16;
  uint64_t v17;
  _DWORD *v18;
  __int16 *v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  unint64_t v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  int *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  char v40;
  int *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _DWORD v49[8];
  _QWORD v50[9];

  v50[8] = *MEMORY[0x24BDAC8D0];
  if (a2 <= 0)
  {
    v5 = a2 - 1;
    v6 = 0x40000000;
    goto LABEL_31;
  }
  v2 = a2;
  if (a2 >= 0x10)
  {
    v3 = a2 & 0x7FFFFFF0;
    v7 = a1 + 1;
    v8 = (int32x4_t *)v50;
    v9 = 0uLL;
    v10 = a2 & 0xFFFFFFF0;
    v11 = 0uLL;
    v12 = 0uLL;
    v13 = 0uLL;
    do
    {
      v14 = v7[-1];
      v15 = *v7;
      v11 = vaddw_high_s16(v11, v14);
      v9 = vaddw_s16(v9, *(int16x4_t *)v14.i8);
      v13 = vaddw_high_s16(v13, *v7);
      v12 = vaddw_s16(v12, *(int16x4_t *)v7->i8);
      v16 = vshll_n_s16(*(int16x4_t *)v7->i8, 0xCuLL);
      v8[-2] = vshll_n_s16(*(int16x4_t *)v14.i8, 0xCuLL);
      v8[-1] = vshll_high_n_s16(v14, 0xCuLL);
      *v8 = v16;
      v8[1] = vshll_high_n_s16(v15, 0xCuLL);
      v8 += 4;
      v7 += 2;
      v10 -= 16;
    }
    while (v10);
    v4 = vaddvq_s32(vaddq_s32(vaddq_s32(v12, v9), vaddq_s32(v13, v11)));
    if (v3 == a2)
      goto LABEL_10;
  }
  else
  {
    v3 = 0;
    v4 = 0;
  }
  v17 = a2 - v3;
  v18 = &v49[v3];
  v19 = &a1->i16[v3];
  do
  {
    v20 = *v19++;
    v4 += v20;
    *v18++ = v20 << 12;
    --v17;
  }
  while (v17);
LABEL_10:
  if (v4 > 4095)
    return 0;
  v5 = a2 - 1;
  v6 = 0x40000000;
  v21 = a2 - 2;
  if (a2 >= 2)
  {
    v22 = 0x40000000;
LABEL_13:
    v23 = (int)v49[v5];
    if ((v23 - 16773023) >= 0xFE0020C3)
    {
      v24 = v23 << 7;
      v25 = -v24;
      v26 = 0x40000000 - ((unint64_t)-(v24 * -v24) >> 32);
      v27 = (unint64_t)(v26 * v22) >> 30;
      v22 = v27 & 0xFFFFFFFC;
      if ((int)(v27 & 0xFFFFFFFC) >= 107374)
      {
        v28 = v2 >> 1;
        if (v26 >= 0)
          v29 = v26;
        else
          v29 = -v26;
        v30 = __clz(v29);
        v31 = ((unint64_t)((int)(-8
                                      * ((unint64_t)(0x1FFFFFFF
                                                          / (v26 << (v30 - 1) >> 16)
                                                          * (uint64_t)(v26 << (v30 - 1))) >> 16))
                                * (uint64_t)(0x1FFFFFFF / (v26 << (v30 - 1) >> 16))) >> 16)
            + ((0x1FFFFFFF / (v26 << (v30 - 1) >> 16)) << 16);
        if (v30 == 31)
        {
          v32 = v49;
          v33 = v21;
          while (1)
          {
            v34 = *v32;
            v35 = (int)v49[v33];
            v36 = vqsubs_s32(*v32, (((unint64_t)(v35 * v25) >> 30) + 1) >> 1);
            v37 = (((_BYTE)v36 * (_BYTE)v31) & 1) + ((v31 * (uint64_t)v36) >> 1);
            if (v37 != (int)v37)
              break;
            *v32 = v37;
            v38 = vqsubs_s32(v35, (((unint64_t)(v34 * v25) >> 30) + 1) >> 1);
            v39 = (((_BYTE)v38 * (_BYTE)v31) & 1) + ((v31 * (uint64_t)v38) >> 1);
            if (v39 != (int)v39)
              break;
            v49[v33--] = v39;
            ++v32;
            if (!--v28)
              goto LABEL_28;
          }
        }
        else
        {
          v40 = 31 - v30;
          v41 = v49;
          v42 = v21;
          while (1)
          {
            v43 = *v41;
            v44 = (int)v49[v42];
            v45 = ((v31 * (uint64_t)vqsubs_s32(*v41, (((unint64_t)(v44 * v25) >> 30) + 1) >> 1)) >> v40) + 1;
            if (v45 >> 1 != (int)(v45 >> 1))
              break;
            *v41 = (unint64_t)v45 >> 1;
            v46 = ((v31 * (uint64_t)vqsubs_s32(v44, (((unint64_t)(v43 * v25) >> 30) + 1) >> 1)) >> v40) + 1;
            if (v46 >> 1 != (int)(v46 >> 1))
              break;
            v49[v42--] = (unint64_t)v46 >> 1;
            ++v41;
            if (!--v28)
            {
LABEL_28:
              --v2;
              --v21;
              if (v5-- >= 2)
                goto LABEL_13;
              v5 = 0;
              v6 = v27 & 0xFFFFFFFC;
              goto LABEL_31;
            }
          }
        }
      }
    }
    return 0;
  }
LABEL_31:
  if ((v49[v5] - 16773023) < 0xFE0020C3)
    return 0;
  if ((int)(((unint64_t)(((0x4000000000000000
                                 - ((-128 * v49[0] * (uint64_t)(-128 * v49[0])) & 0x7FFFFFFF00000000)) >> 32)
                               * v6) >> 30) & 0xFFFFFFFC) >= 107374)
    return ((unint64_t)(((0x4000000000000000
                               - ((-128 * v49[0] * (uint64_t)(-128 * v49[0])) & 0x7FFFFFFF00000000)) >> 32)
                             * v6) >> 30) & 0xFFFFFFFC;
  else
    return 0;
}

float silk_LTP_scale_ctrl_FLP(uint64_t a1, uint64_t a2, int a3, double a4)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  int v7;
  _BOOL4 v8;
  _BYTE *v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;

  if (a3)
  {
    v4 = 0;
    *(_BYTE *)(a1 + 4785) = 0;
    goto LABEL_23;
  }
  v5 = *(_DWORD *)(a1 + 5760) * *(_DWORD *)(a1 + 4616);
  if (*(_BYTE *)(a1 + 4739))
    v5 = (__int16)v5 * (__int16)v5 / 0x64u + 2;
  LODWORD(a4) = *(_DWORD *)(a2 + 708);
  v6 = (__int16)v5 * (int)*(float *)&a4;
  v7 = *(_DWORD *)(a1 + 4732);
  if (v7 <= 2900)
  {
    v11 = 2900 - v7;
    v12 = 1 << ((2900 - v7) >> 7);
    v13 = (v11 & 0x7F) + ((int)(-174 * (v11 & 0x7F) * (128 - (v11 & 0x7F))) >> 16);
    v14 = v13 << ((2900 - v7) >> 7) >> 7;
    if ((2900 - v7) > 0x7FF)
      v14 = v13 * (v12 >> 7);
    v15 = v14 + v12;
    if (v11 <= 0xF7E)
      v16 = v15;
    else
      v16 = 0x7FFFFFFF;
    v8 = v6 > v16;
    *(_BYTE *)(a1 + 4785) = v8;
    v9 = (_BYTE *)(a1 + 4785);
    goto LABEL_14;
  }
  v8 = v6 > 0;
  *(_BYTE *)(a1 + 4785) = v8;
  v9 = (_BYTE *)(a1 + 4785);
  if (v7 <= 0xF3C)
  {
LABEL_14:
    v17 = 3900 - v7;
    v18 = 1 << (v17 >> 7);
    v19 = (v17 & 0x7F) + ((int)(-174 * (v17 & 0x7F) * (128 - (v17 & 0x7F))) >> 16);
    v20 = v19 << (v17 >> 7) >> 7;
    if (v17 > 0x7FF)
      v20 = v19 * (v18 >> 7);
    v21 = v20 + v18;
    if (v17 <= 0xF7E)
      v10 = v21;
    else
      v10 = 0x7FFFFFFF;
    goto LABEL_19;
  }
  v10 = 0;
LABEL_19:
  if (v6 <= v10)
    v4 = v8;
  else
    v4 = (v8 + 1);
  *v9 = v4;
LABEL_23:
  LOWORD(a4) = silk_LTPScales_table_Q14[v4];
  *(float *)&a4 = (float)vmovl_s16(*(int16x4_t *)&a4).i32[0] * 0.000061035;
  *(_DWORD *)(a2 + 224) = LODWORD(a4);
  return *(float *)&a4;
}

uint64_t clt_mdct_forward_c(uint64_t a1, uint64_t a2, float *a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t v10;
  int v11;
  float *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float *v17;
  int v18;
  float *v19;
  int v20;
  int v21;
  float v22;
  uint64_t v23;
  float *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  float *v30;
  uint64_t v31;
  uint64_t v32;
  float *v33;
  int v34;
  float *v35;
  float v36;
  float v37;
  float v38;
  float *v39;
  float v40;
  float *v41;
  float *v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  float v46;
  float v47;
  float v48;
  float *v49;
  int v50;
  BOOL v51;
  float *v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  __int16 *v60;
  uint64_t v61;
  uint64_t v62;
  float *v63;
  uint64_t v64;
  float v65;
  float v66;
  float v67;
  float v68;
  uint64_t v69;
  float *v70;
  uint64_t result;
  float *v72;
  float *v73;
  float v74;
  float v75;
  float v76;
  float v77;
  _QWORD v78[2];

  v78[1] = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(a1 + 8 * a6 + 8);
  v11 = *(_DWORD *)a1;
  v12 = *(float **)(a1 + 40);
  if (a6 >= 1)
  {
    do
    {
      v11 >>= 1;
      v12 += v11;
      --a6;
    }
    while (a6);
  }
  v13 = MEMORY[0x24BDAC7A8](v10, a2);
  v15 = MEMORY[0x24BDAC7A8](v13, v14);
  v24 = (float *)((char *)v78 - v23);
  v26 = v16 + 4 * v25;
  v27 = v26 - 4;
  v28 = (v18 + 3) >> 2;
  if (v18 < 1)
  {
    v29 = 0;
    v45 = 4 * (v18 >> 1);
    v41 = (float *)(v16 + v45);
    v42 = (float *)(v27 + v45);
    v39 = v19;
    v43 = (uint64_t)v20 >> 1;
    v44 = v21 - v28;
    if (v44 <= 0)
      goto LABEL_15;
  }
  else
  {
    if (v28 <= 1)
      v29 = 1;
    else
      v29 = (v18 + 3) >> 2;
    v30 = v17 - 1;
    v31 = v16 - 4;
    v32 = 4 * ((uint64_t)v18 >> 1);
    v33 = v17;
    v34 = v29;
    v35 = v19;
    do
    {
      v36 = v30[(unint64_t)v32 / 4];
      v37 = v33[(unint64_t)v32 / 4];
      v38 = (float)(v37 * *(float *)(v27 + v32)) + (float)(v36 * *(float *)(v26 + v32));
      v39 = v35 + 2;
      v40 = (float)(v37 * *(float *)(v16 + v32)) - (float)(v36 * *(float *)(v31 + v32));
      v16 += 8;
      v26 += 8;
      v30 -= 2;
      v33 += 2;
      *v35 = v38;
      v35[1] = v40;
      v27 -= 8;
      v31 -= 8;
      v35 += 2;
      --v34;
    }
    while (v34);
    v41 = (float *)(v16 + v32);
    v42 = (float *)(v27 + v32);
    v43 = (uint64_t)v20 >> 1;
    v44 = v21 - v28;
    if (v29 >= v44)
    {
LABEL_15:
      v51 = __OFSUB__(v21, v29);
      v50 = v21 - v29;
      if ((v50 < 0) ^ v51 | (v50 == 0))
        goto LABEL_18;
      goto LABEL_16;
    }
  }
  do
  {
    v46 = *v42;
    v42 -= 2;
    v47 = v46;
    v48 = *v41;
    v41 += 2;
    v49 = v39 + 2;
    *v39 = v47;
    v39[1] = v48;
    ++v29;
    v39 += 2;
  }
  while (v29 < v44);
  v39 = v49;
  v50 = v21 - v44;
  if (v21 <= v44)
    goto LABEL_18;
LABEL_16:
  v52 = &v17[v18 - 1];
  do
  {
    v53 = *v17;
    v17 += 2;
    v54 = v53;
    v55 = *v52;
    v52 -= 2;
    v56 = v55;
    v57 = (float)(v55 * *v42) - (float)(v54 * v41[-v43]);
    v58 = *v41;
    v41 += 2;
    v59 = (float)(v54 * v42[v43]) + (float)(v56 * v58);
    *v39 = v57;
    v39[1] = v59;
    v39 += 2;
    v42 -= 2;
    --v50;
  }
  while (v50);
LABEL_18:
  if (v20 <= 3)
    return opus_fft_impl(v15, v24);
  v60 = *(__int16 **)(v15 + 48);
  v61 = v21;
  if (v21 <= 1)
    v62 = 1;
  else
    v62 = v21;
  v63 = v12;
  v64 = v62;
  do
  {
    v65 = v63[v21];
    v66 = *v19;
    v67 = v19[1];
    v19 += 2;
    v68 = (float)(v65 * v66) + (float)(v67 * *v63);
    v69 = *v60++;
    v70 = &v24[2 * v69];
    *v70 = v22 * (float)((float)(v66 * *v63) - (float)(v67 * v65));
    v70[1] = v22 * v68;
    ++v63;
    --v64;
  }
  while (v64);
  result = opus_fft_impl(v15, v24);
  v72 = &a3[((int)v43 - 1) * a7];
  v73 = v24 + 1;
  do
  {
    v74 = *(v73 - 1);
    v75 = v12[v61];
    v76 = *v12++;
    v77 = (float)(*v73 * v76) + (float)(v74 * v75);
    *a3 = (float)(*v73 * v75) - (float)(v74 * v76);
    *v72 = v77;
    v72 -= 2 * a7;
    a3 += 2 * a7;
    v73 += 2;
    --v62;
  }
  while (v62);
  return result;
}

float clt_mdct_backward_c(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  int v10;
  float *v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  __int16 *v16;
  float *v17;
  uint64_t v18;
  uint64_t v19;
  float *v20;
  uint64_t v21;
  float v22;
  float v23;
  float *v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float *v32;
  float *v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float result;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  float v49;
  float v50;
  float v51;
  float v52;

  v10 = *(_DWORD *)a1;
  v11 = *(float **)(a1 + 40);
  if (a6 >= 1)
  {
    v12 = a6;
    do
    {
      v10 >>= 1;
      v11 += v10;
      --v12;
    }
    while (v12);
  }
  v13 = *(_QWORD *)(a1 + 8 * a6 + 8);
  if (v10 > 3)
  {
    v14 = v10 >> 1;
    v15 = v10 >> 2;
    v16 = *(__int16 **)(v13 + 48);
    v17 = &a2[(v14 - 1) * a7];
    if (v15 <= 1)
      v18 = 1;
    else
      v18 = v15;
    v19 = 8 * a7;
    v20 = v11;
    do
    {
      v21 = *v16++;
      v22 = v20[v15];
      v23 = (float)(*a2 * v22) + (float)(*v17 * *v20);
      v24 = (float *)(a3 + 4 * (a5 >> 1) + 8 * v21);
      *v24 = (float)(*a2 * *v20) - (float)(*v17 * v22);
      v24[1] = v23;
      ++v20;
      a2 = (float *)((char *)a2 + v19);
      v17 = (float *)((char *)v17 - v19);
      --v18;
    }
    while (v18);
    opus_fft_impl(v13, (float *)(a3 + 4 * (a5 >> 1)));
    v25 = 0;
    v26 = (v15 + 1) >> 1;
    if (v26 <= 1)
      v26 = 1;
    v27 = 4 * v26;
    v28 = 4 * v14 - 4;
    v29 = v15;
    v30 = v29 * 4 - 4;
    v31 = a3 + 4 * ((uint64_t)a5 >> 1);
    v32 = (float *)(v31 + 4);
    v33 = (float *)(v28 + v31);
    do
    {
      v34 = *(v32 - 1);
      v35 = v11[v25 / 4];
      v36 = v11[v29];
      v37 = (float)(v34 * v36) + (float)(*v32 * v35);
      v38 = (float)(*v32 * v36) - (float)(v34 * v35);
      v40 = *(v33 - 1);
      v39 = *v33;
      *(v32 - 1) = v37;
      *v33 = v38;
      v41 = *(float *)((char *)v11 + v30);
      v42 = *(float *)((char *)v11 + v28);
      v43 = (float)(v40 * v42) + (float)(v39 * v41);
      result = (float)(v39 * v42) - (float)(v40 * v41);
      v25 += 4;
      v28 -= 4;
      v30 -= 4;
      *(v33 - 1) = v43;
      *v32 = result;
      v32 += 2;
      ++v29;
      v33 -= 2;
    }
    while (v27 != v25);
    if (a5 >= 0)
      v45 = a5;
    else
      v45 = a5 + 1;
    if (a5 < 2)
      return result;
LABEL_23:
    v46 = 0;
    v47 = v45 >> 1;
    v48 = 4 * a5 - 4;
    do
    {
      v49 = *(float *)(a3 + v48);
      v50 = *(float *)(a3 + 4 * v46);
      v51 = *(float *)(a4 + v48);
      v52 = *(float *)(a4 + 4 * v46);
      *(float *)(a3 + 4 * v46) = (float)(v51 * v50) - (float)(v52 * v49);
      result = (float)(v49 * v51) + (float)(v52 * v50);
      *(float *)(a3 + v48) = result;
      ++v46;
      v48 -= 4;
    }
    while (v47 != (_DWORD)v46);
    return result;
  }
  opus_fft_impl(v13, (float *)(a3 + 4 * (a5 >> 1)));
  if (a5 >= 0)
    v45 = a5;
  else
    v45 = a5 + 1;
  if (a5 >= 2)
    goto LABEL_23;
  return result;
}

uint64_t compute_dense(uint64_t result, float *a2, float32x4_t *a3, __n128 a4, int32x4_t a5)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  int8x8_t *v11;
  __n128 *v12;
  uint64_t v13;
  int8x8_t v14;
  int8x8_t v15;
  uint64_t v16;
  float *v17;
  char *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _BOOL4 v23;
  int8x16_t *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  BOOL v28;
  BOOL v29;
  BOOL v30;
  uint64_t v31;
  unint64_t v32;
  float32x4_t *v33;
  uint64_t v34;
  int8x8_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  uint64_t v40;
  float32x4_t *v41;
  int8x16_t *v42;
  int8x8_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  uint64_t v48;
  float *v49;
  unint64_t v50;
  float v51;
  uint64_t v52;
  float32x4_t *v53;
  float32x4_t v54;
  uint64_t v55;
  float32x4_t v56;
  uint64_t v57;
  float *v58;
  BOOL v59;
  float v60;
  float v61;
  float v62;
  signed int v63;
  float v64;
  uint64_t v65;
  float *v66;
  int8x16_t *v67;
  int8x16_t v68;
  int8x8_t v69;
  float32x4_t v70;
  float v71;
  float v72;
  BOOL v73;
  float v74;
  float v75;
  signed int v76;

  v5 = *(unsigned int *)(result + 20);
  if ((int)v5 < 1)
    return result;
  v6 = *(unsigned int *)(result + 16);
  v7 = *(_QWORD *)result;
  if (v5 < 8 || (v7 + v5 > (unint64_t)a2 ? (v8 = v7 >= (unint64_t)&a2[v5]) : (v8 = 1), !v8))
  {
    v9 = 0;
    goto LABEL_15;
  }
  if (v5 >= 0x10)
  {
    v9 = v5 & 0x7FFFFFF0;
    v65 = v5 & 0xFFFFFFF0;
    v66 = a2;
    v67 = *(int8x16_t **)result;
    do
    {
      v68 = *v67++;
      v69 = (int8x8_t)vextq_s8(v68, v68, 8uLL).u64[0];
      v70 = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(v69, *(int8x8_t *)v68.i8), 8uLL), 8uLL)));
      a5 = vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(v69, *(int8x8_t *)v68.i8), 8uLL), 8uLL));
      *(float32x4_t *)v66 = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(*(int8x8_t *)v68.i8, *(int8x8_t *)v68.i8), 8uLL), 8uLL)));
      *((float32x4_t *)v66 + 1) = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(*(int8x8_t *)v68.i8, *(int8x8_t *)v68.i8), 8uLL), 8uLL)));
      a4 = (__n128)vcvtq_f32_s32(a5);
      *((float32x4_t *)v66 + 2) = v70;
      *((__n128 *)v66 + 3) = a4;
      v66 += 16;
      v65 -= 16;
    }
    while (v65);
    if (v9 == v5)
      goto LABEL_17;
    if ((v5 & 8) == 0)
    {
LABEL_15:
      v16 = v5 - v9;
      v17 = &a2[v9];
      v18 = (char *)(v7 + v9);
      do
      {
        v19 = *v18++;
        *v17++ = (float)v19;
        --v16;
      }
      while (v16);
      goto LABEL_17;
    }
  }
  else
  {
    v9 = 0;
  }
  v10 = v9;
  v9 = v5 & 0xFFFFFFF8;
  v11 = (int8x8_t *)(v7 + v10);
  v12 = (__n128 *)&a2[v10];
  v13 = v10 - v9;
  do
  {
    v14 = *v11++;
    v15 = v14;
    a5 = (int32x4_t)vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(v15, v15), 8uLL), 8uLL)));
    a4 = (__n128)vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(v15, v15), 8uLL), 8uLL)));
    *v12 = (__n128)a5;
    v12[1] = a4;
    v12 += 2;
    v13 += 8;
  }
  while (v13);
  if (v9 != v5)
    goto LABEL_15;
LABEL_17:
  if ((int)v6 >= 1)
  {
    v20 = 0;
    v21 = *(_QWORD *)(result + 8);
    v23 = v6 > 7 && (_DWORD)v5 == 1;
    v24 = *(int8x16_t **)(result + 8);
    do
    {
      a4.n128_f32[0] = a2[v20];
      v25 = 0;
      if (v23)
      {
        v26 = (unint64_t)&a2[v20];
        v27 = v26 + 4;
        v28 = v26 < (unint64_t)a3->u64 + 4 * v6 && v27 > (unint64_t)a3;
        v29 = v28;
        v30 = v21 + v20 >= v27 || v26 >= v21 + v20 + v6;
        if (v30 && !v29)
        {
          if (v6 < 0x10)
          {
            v31 = 0;
LABEL_41:
            v32 = v5 * (unint64_t)v31;
            v33 = (float32x4_t *)((char *)a3 + 4 * v31);
            v34 = v31 - (v6 & 0xFFFFFFF8);
            do
            {
              v35 = *(int8x8_t *)&v24->i8[v32];
              v36 = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(v35, (int8x8_t)a4.n128_u64[0]), 8uLL), 8uLL)));
              v37 = *v33;
              v38 = v33[1];
              v33 += 2;
              a5 = (int32x4_t)vmulq_f32(v38, vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(v35, (int8x8_t)a4.n128_u64[0]), 8uLL), 8uLL))));
              v39 = vmulq_f32(v37, v36);
              a4.n128_f32[0] = (float)((float)((float)((float)((float)((float)((float)(a4.n128_f32[0] + v39.f32[0])
                                                                             + v39.f32[1])
                                                                     + v39.f32[2])
                                                             + v39.f32[3])
                                                     + *(float *)a5.i32)
                                             + *(float *)&a5.i32[1])
                                     + *(float *)&a5.i32[2])
                             + *(float *)&a5.i32[3];
              v32 += 8 * v5;
              v34 += 8;
            }
            while (v34);
            a2[v20] = a4.n128_f32[0];
            v25 = v6 & 0xFFFFFFF8;
            if (v25 == v6)
              goto LABEL_25;
            goto LABEL_49;
          }
          v40 = v6 & 0x7FFFFFF0;
          v41 = a3;
          v42 = v24;
          do
          {
            v43 = (int8x8_t)vextq_s8(*v42, *v42, 8uLL).u64[0];
            v44 = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(v43, (int8x8_t)a4.n128_u64[0]), 8uLL), 8uLL)));
            a5 = (int32x4_t)vmulq_f32(v41[3], vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(v43, (int8x8_t)a4.n128_u64[0]), 8uLL), 8uLL))));
            v45 = vmulq_f32(v41[2], v44);
            v46 = vmulq_f32(v41[1], vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(*(int8x8_t *)v42->i8, (int8x8_t)a4.n128_u64[0]), 8uLL), 8uLL))));
            v47 = vmulq_f32(*v41, vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(*(int8x8_t *)v42->i8, (int8x8_t)a4.n128_u64[0]), 8uLL), 8uLL))));
            a4.n128_f32[0] = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(a4.n128_f32[0] + v47.f32[0]) + v47.f32[1]) + v47.f32[2]) + v47.f32[3]) + v46.f32[0]) + v46.f32[1]) + v46.f32[2])
                                                                                           + v46.f32[3])
                                                                                   + v45.f32[0])
                                                                           + v45.f32[1])
                                                                   + v45.f32[2])
                                                           + v45.f32[3])
                                                   + *(float *)a5.i32)
                                           + *(float *)&a5.i32[1])
                                   + *(float *)&a5.i32[2])
                           + *(float *)&a5.i32[3];
            v42 += v5;
            v41 += 4;
            v40 -= 16;
          }
          while (v40);
          a2[v20] = a4.n128_f32[0];
          if ((v6 & 0x7FFFFFF0) == v6)
            goto LABEL_25;
          v31 = v6 & 0x7FFFFFF0;
          v25 = v6 & 0xFFFFFFF0;
          if ((v6 & 8) != 0)
            goto LABEL_41;
        }
      }
LABEL_49:
      v48 = v6 - v25;
      v49 = &a3->f32[v25];
      v50 = v5 * (unint64_t)v25;
      do
      {
        a5.i8[0] = v24->i8[v50];
        a5.i64[0] = vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)a5.i8)).u64[0];
        v51 = *v49++;
        *(float *)a5.i32 = (float)a5.i32[0];
        a4.n128_f32[0] = a4.n128_f32[0] + (float)(*(float *)a5.i32 * v51);
        a2[v20] = a4.n128_f32[0];
        v50 += v5;
        --v48;
      }
      while (v48);
LABEL_25:
      ++v20;
      v24 = (int8x16_t *)((char *)v24 + 1);
    }
    while (v20 != v5);
  }
  if (v5 < 8)
  {
    v52 = 0;
LABEL_57:
    v57 = v5 - v52;
    v58 = &a2[v52];
    do
    {
      *v58 = *v58 * 0.0078125;
      ++v58;
      --v57;
    }
    while (v57);
    goto LABEL_59;
  }
  v52 = v5 & 0x7FFFFFF8;
  v53 = (float32x4_t *)(a2 + 4);
  v54.i64[0] = 0x3C0000003C000000;
  v54.i64[1] = 0x3C0000003C000000;
  v55 = v5 & 0xFFFFFFF8;
  do
  {
    v56 = vmulq_f32(*v53, v54);
    v53[-1] = vmulq_f32(v53[-1], v54);
    *v53 = v56;
    v53 += 2;
    v55 -= 8;
  }
  while (v55);
  if (v52 != v5)
    goto LABEL_57;
LABEL_59:
  if (*(_DWORD *)(result + 24))
  {
    do
    {
      v60 = *a2 * 0.5;
      v64 = 1.0;
      if (v60 < 8.0)
      {
        v64 = -1.0;
        if (v60 > -8.0)
        {
          v59 = v60 < 0.0;
          if (v60 < 0.0)
            v60 = -v60;
          v61 = (float)(v60 * 25.0) + 0.5;
          v62 = floorf(v61);
          v63 = vcvtms_s32_f32(v61);
          if (v59)
            v64 = -(float)(tansig_table[v63]
                         + (float)((float)((float)(v60 + (float)((float)(int)v62 * -0.04))
                                         * (float)(1.0 - (float)(tansig_table[v63] * tansig_table[v63])))
                                 * (float)(1.0
                                         - (float)(tansig_table[v63] * (float)(v60 + (float)((float)(int)v62 * -0.04))))));
          else
            v64 = tansig_table[v63]
                + (float)((float)((float)(v60 + (float)((float)(int)v62 * -0.04))
                                * (float)(1.0 - (float)(tansig_table[v63] * tansig_table[v63])))
                        * (float)(1.0 - (float)(tansig_table[v63] * (float)(v60 + (float)((float)(int)v62 * -0.04)))));
        }
      }
      *a2++ = (float)(v64 * 0.5) + 0.5;
      --v5;
    }
    while (v5);
  }
  else
  {
    do
    {
      v71 = *a2;
      v72 = 1.0;
      if (*a2 < 8.0)
      {
        v72 = -1.0;
        if (v71 > -8.0)
        {
          v73 = v71 < 0.0;
          if (v71 < 0.0)
            v71 = -v71;
          v74 = (float)(v71 * 25.0) + 0.5;
          v75 = floorf(v74);
          v76 = vcvtms_s32_f32(v74);
          if (v73)
            v72 = -(float)(tansig_table[v76]
                         + (float)((float)((float)(v71 + (float)((float)(int)v75 * -0.04))
                                         * (float)(1.0 - (float)(tansig_table[v76] * tansig_table[v76])))
                                 * (float)(1.0
                                         - (float)(tansig_table[v76] * (float)(v71 + (float)((float)(int)v75 * -0.04))))));
          else
            v72 = tansig_table[v76]
                + (float)((float)((float)(v71 + (float)((float)(int)v75 * -0.04))
                                * (float)(1.0 - (float)(tansig_table[v76] * tansig_table[v76])))
                        * (float)(1.0 - (float)(tansig_table[v76] * (float)(v71 + (float)((float)(int)v75 * -0.04)))));
        }
      }
      *a2++ = v72;
      --v5;
    }
    while (v5);
  }
  return result;
}

int8x16_t **compute_gru(int8x16_t **result, float *__dst, float *a3, double a4, int32x4_t a5)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  int8x16_t *v9;
  uint64_t v10;
  uint64_t v11;
  int8x8_t *v12;
  float32x4_t *v13;
  uint64_t v14;
  int8x8_t v15;
  float32x4_t *v16;
  uint64_t v17;
  int8x16_t *v18;
  int8x16_t v19;
  int8x8_t v20;
  float32x4_t v21;
  uint64_t v22;
  float *v23;
  __int8 *v24;
  int v25;
  uint64_t v26;
  int8x16_t *v27;
  uint64_t v28;
  unsigned __int8 *v29;
  float v30;
  unsigned __int8 *v31;
  float *v32;
  uint64_t v33;
  float v34;
  uint64_t v35;
  unsigned __int8 *v36;
  unsigned __int8 *v37;
  uint64_t v38;
  float v39;
  unsigned __int8 *v40;
  float *v41;
  uint64_t v42;
  float v43;
  float v44;
  BOOL v45;
  float v46;
  float v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  int8x8_t *v51;
  float32x4_t *v52;
  uint64_t v53;
  int8x8_t v54;
  int8x16_t *v55;
  float32x4_t *v56;
  uint64_t v57;
  int8x16_t v58;
  int8x8_t v59;
  float32x4_t v60;
  uint64_t v61;
  float *v62;
  __int8 *v63;
  int v64;
  uint64_t v65;
  unsigned __int8 *v66;
  float v67;
  unsigned __int8 *v68;
  float *v69;
  uint64_t v70;
  float v71;
  uint64_t v72;
  unsigned __int8 *v73;
  uint64_t v74;
  float v75;
  unsigned __int8 *v76;
  float *v77;
  uint64_t v78;
  float v79;
  float v80;
  BOOL v81;
  float v82;
  float v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int8x8_t *v88;
  float32x4_t *v89;
  uint64_t v90;
  int8x8_t v91;
  int8x16_t *v92;
  float32x4_t *v93;
  uint64_t v94;
  int8x16_t v95;
  int8x8_t v96;
  float32x4_t v97;
  uint64_t v98;
  float *v99;
  __int8 *v100;
  int v101;
  uint64_t v102;
  float32x4_t *v103;
  float32x4_t *v104;
  __n128 *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  float *v109;
  float *v110;
  float *v111;
  float v112;
  float v113;
  float v114;
  uint64_t v115;
  unsigned __int8 *v116;
  float v117;
  unsigned __int8 *v118;
  float *v119;
  uint64_t v120;
  float v121;
  uint64_t v122;
  unsigned __int8 *v123;
  float v124;
  float *v125;
  unsigned __int8 *v126;
  uint64_t v127;
  float v128;
  uint64_t v129;
  float v130;
  float v131;
  float v132;
  BOOL v133;
  float v134;
  float v135;
  unsigned int v136;
  float v137;
  float __src[32];
  float v139[4];
  uint64_t v140;
  float v141[32];
  _DWORD v142[4];
  _QWORD v143[15];

  v143[14] = *MEMORY[0x24BDAC8D0];
  v5 = *((int *)result + 7);
  if ((int)v5 < 1)
    return result;
  v7 = *((unsigned int *)result + 6);
  v8 = *((unsigned int *)result + 7);
  v9 = *result;
  if (v5 < 8)
  {
    v10 = 0;
    goto LABEL_14;
  }
  if (v5 >= 0x10)
  {
    v10 = v5 & 0x7FFFFFF0;
    v16 = (float32x4_t *)v141;
    v17 = v5 & 0xFFFFFFF0;
    v18 = *result;
    do
    {
      v19 = *v18++;
      v20 = (int8x8_t)vextq_s8(v19, v19, 8uLL).u64[0];
      v21 = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(v20, *(int8x8_t *)v19.i8), 8uLL), 8uLL)));
      a5 = vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(v20, *(int8x8_t *)v19.i8), 8uLL), 8uLL));
      *v16 = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(*(int8x8_t *)v19.i8, *(int8x8_t *)v19.i8), 8uLL), 8uLL)));
      v16[1] = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(*(int8x8_t *)v19.i8, *(int8x8_t *)v19.i8), 8uLL), 8uLL)));
      v16[2] = v21;
      v16[3] = vcvtq_f32_s32(a5);
      v16 += 4;
      v17 -= 16;
    }
    while (v17);
    if (v10 == v8)
      goto LABEL_16;
    if ((v8 & 8) == 0)
    {
LABEL_14:
      v22 = v8 - v10;
      v23 = &v141[v10];
      v24 = &v9->i8[v10];
      do
      {
        v25 = *v24++;
        *v23++ = (float)v25;
        --v22;
      }
      while (v22);
      goto LABEL_16;
    }
  }
  else
  {
    v10 = 0;
  }
  v11 = v10;
  v10 = v5 & 0xFFFFFFF8;
  v12 = (int8x8_t *)&v9->i8[v11];
  v13 = (float32x4_t *)&v141[v11];
  v14 = v11 - v10;
  do
  {
    v15 = *v12++;
    a5 = (int32x4_t)vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(v15, v15), 8uLL), 8uLL)));
    *v13 = (float32x4_t)a5;
    v13[1] = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(v15, v15), 8uLL), 8uLL)));
    v13 += 2;
    v14 += 8;
  }
  while (v14);
  if (v10 != v8)
    goto LABEL_14;
LABEL_16:
  v26 = 3 * v5;
  v27 = result[1];
  if ((int)v7 >= 1)
  {
    v28 = 0;
    v29 = (unsigned __int8 *)result[1];
    do
    {
      v30 = v141[v28];
      v31 = v29;
      v32 = a3;
      v33 = v7;
      do
      {
        a5.i8[0] = *v31;
        a5.i64[0] = vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)a5.i8)).u64[0];
        *(float *)a5.i32 = (float)a5.i32[0];
        v34 = *v32++;
        v30 = v30 + (float)(*(float *)a5.i32 * v34);
        v31 += v26;
        --v33;
      }
      while (v33);
      v141[v28++] = v30;
      ++v29;
    }
    while (v28 != v8);
  }
  v35 = 0;
  v36 = (unsigned __int8 *)result[2];
  v37 = v36;
  do
  {
    v38 = 0;
    v39 = v141[v35];
    v40 = v37;
    do
    {
      a5.i8[0] = *v40;
      a5.i64[0] = vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)a5.i8)).u64[0];
      *(float *)a5.i32 = (float)a5.i32[0];
      v39 = v39 + (float)(*(float *)a5.i32 * __dst[v38++]);
      v40 += v26;
    }
    while (v8 != v38);
    v141[v35++] = v39;
    ++v37;
  }
  while (v35 != v8);
  v41 = v141;
  a5.i32[0] = 0.5;
  v42 = v8;
  do
  {
    v43 = (float)(*v41 * 0.0078125) * 0.5;
    v44 = 1.0;
    if (v43 < 8.0)
    {
      v44 = -1.0;
      if (v43 > -8.0)
      {
        v45 = v43 < 0.0;
        if (v43 < 0.0)
          v43 = -v43;
        v46 = (float)(v43 * 25.0) + 0.5;
        v47 = floorf(v46);
        v48 = vcvtms_s32_f32(v46);
        if (v45)
          v44 = -(float)(tansig_table[v48]
                       + (float)((float)((float)(v43 + (float)((float)(int)v47 * -0.04))
                                       * (float)(1.0 - (float)(tansig_table[v48] * tansig_table[v48])))
                               * (float)(1.0
                                       - (float)(tansig_table[v48] * (float)(v43 + (float)((float)(int)v47 * -0.04))))));
        else
          v44 = tansig_table[v48]
              + (float)((float)((float)(v43 + (float)((float)(int)v47 * -0.04))
                              * (float)(1.0 - (float)(tansig_table[v48] * tansig_table[v48])))
                      * (float)(1.0 - (float)(tansig_table[v48] * (float)(v43 + (float)((float)(int)v47 * -0.04)))));
      }
    }
    *v41++ = (float)(v44 * 0.5) + 0.5;
    --v42;
  }
  while (v42);
  if (v8 < 8)
  {
    v49 = 0;
    goto LABEL_46;
  }
  if (v8 >= 0x10)
  {
    v49 = v8 & 0x7FFFFFF0;
    v55 = (int8x16_t *)((char *)v9 + v8);
    v56 = (float32x4_t *)v139;
    v57 = v8 & 0xFFFFFFF0;
    do
    {
      v58 = *v55++;
      v59 = (int8x8_t)vextq_s8(v58, v58, 8uLL).u64[0];
      v60 = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(v59, *(int8x8_t *)v58.i8), 8uLL), 8uLL)));
      a5 = vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(v59, *(int8x8_t *)v58.i8), 8uLL), 8uLL));
      *v56 = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(*(int8x8_t *)v58.i8, *(int8x8_t *)v58.i8), 8uLL), 8uLL)));
      v56[1] = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(*(int8x8_t *)v58.i8, *(int8x8_t *)v58.i8), 8uLL), 8uLL)));
      v56[2] = v60;
      v56[3] = vcvtq_f32_s32(a5);
      v56 += 4;
      v57 -= 16;
    }
    while (v57);
    if (v49 == v8)
      goto LABEL_48;
    if ((v8 & 8) == 0)
    {
LABEL_46:
      v61 = v8 - v49;
      v62 = &v139[v49];
      v63 = &v9->i8[v49 + v8];
      do
      {
        v64 = *v63++;
        *v62++ = (float)v64;
        --v61;
      }
      while (v61);
      goto LABEL_48;
    }
  }
  else
  {
    v49 = 0;
  }
  v50 = v49;
  v49 = v8 & 0xFFFFFFF8;
  v51 = (int8x8_t *)&v9->i8[v50 + v8];
  v52 = (float32x4_t *)&v139[v50];
  v53 = v50 - v49;
  do
  {
    v54 = *v51++;
    a5 = (int32x4_t)vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(v54, v54), 8uLL), 8uLL)));
    *v52 = (float32x4_t)a5;
    v52[1] = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(v54, v54), 8uLL), 8uLL)));
    v52 += 2;
    v53 += 8;
  }
  while (v53);
  if (v49 != v8)
    goto LABEL_46;
LABEL_48:
  if ((int)v7 >= 1)
  {
    v65 = 0;
    v66 = &v27->u8[v8];
    do
    {
      v67 = v139[v65];
      v68 = v66;
      v69 = a3;
      v70 = v7;
      do
      {
        a5.i8[0] = *v68;
        a5.i64[0] = vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)a5.i8)).u64[0];
        *(float *)a5.i32 = (float)a5.i32[0];
        v71 = *v69++;
        v67 = v67 + (float)(*(float *)a5.i32 * v71);
        v68 += v26;
        --v70;
      }
      while (v70);
      v139[v65++] = v67;
      ++v66;
    }
    while (v65 != v8);
  }
  v72 = 0;
  v73 = v36;
  do
  {
    v74 = 0;
    v75 = v139[v72];
    v76 = v73;
    do
    {
      a5.i8[0] = v76[v8];
      a5.i64[0] = vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)a5.i8)).u64[0];
      *(float *)a5.i32 = (float)a5.i32[0];
      v75 = v75 + (float)(*(float *)a5.i32 * __dst[v74++]);
      v76 += v26;
    }
    while (v8 != v74);
    v139[v72++] = v75;
    ++v73;
  }
  while (v72 != v8);
  v77 = v139;
  v78 = v8;
  do
  {
    v79 = (float)(*v77 * 0.0078125) * 0.5;
    v80 = 1.0;
    if (v79 < 8.0)
    {
      v80 = -1.0;
      if (v79 > -8.0)
      {
        v81 = v79 < 0.0;
        if (v79 < 0.0)
          v79 = -v79;
        v82 = (float)(v79 * 25.0) + 0.5;
        v83 = floorf(v82);
        v84 = vcvtms_s32_f32(v82);
        if (v81)
          v80 = -(float)(tansig_table[v84]
                       + (float)((float)((float)(v79 + (float)((float)(int)v83 * -0.04))
                                       * (float)(1.0 - (float)(tansig_table[v84] * tansig_table[v84])))
                               * (float)(1.0
                                       - (float)(tansig_table[v84] * (float)(v79 + (float)((float)(int)v83 * -0.04))))));
        else
          v80 = tansig_table[v84]
              + (float)((float)((float)(v79 + (float)((float)(int)v83 * -0.04))
                              * (float)(1.0 - (float)(tansig_table[v84] * tansig_table[v84])))
                      * (float)(1.0 - (float)(tansig_table[v84] * (float)(v79 + (float)((float)(int)v83 * -0.04)))));
      }
    }
    *v77++ = (float)(v80 * 0.5) + 0.5;
    --v78;
  }
  while (v78);
  v85 = 2 * v8;
  if (v8 < 8)
  {
    v86 = 0;
    goto LABEL_78;
  }
  if (v8 >= 0x10)
  {
    v86 = v8 & 0x7FFFFFF0;
    v92 = (int8x16_t *)((char *)v9 + v85);
    v93 = (float32x4_t *)__src;
    v94 = v8 & 0xFFFFFFF0;
    do
    {
      v95 = *v92++;
      v96 = (int8x8_t)vextq_s8(v95, v95, 8uLL).u64[0];
      v97 = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(v96, *(int8x8_t *)v95.i8), 8uLL), 8uLL)));
      a5 = vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(v96, *(int8x8_t *)v95.i8), 8uLL), 8uLL));
      *v93 = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(*(int8x8_t *)v95.i8, *(int8x8_t *)v95.i8), 8uLL), 8uLL)));
      v93[1] = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(*(int8x8_t *)v95.i8, *(int8x8_t *)v95.i8), 8uLL), 8uLL)));
      v93[2] = v97;
      v93[3] = vcvtq_f32_s32(a5);
      v93 += 4;
      v94 -= 16;
    }
    while (v94);
    if (v86 == v8)
      goto LABEL_80;
    if ((v8 & 8) == 0)
    {
LABEL_78:
      v98 = v8 - v86;
      v99 = &__src[v86];
      v100 = &v9->i8[v86 + v85];
      do
      {
        v101 = *v100++;
        *v99++ = (float)v101;
        --v98;
      }
      while (v98);
      goto LABEL_80;
    }
  }
  else
  {
    v86 = 0;
  }
  v87 = v86;
  v86 = v8 & 0xFFFFFFF8;
  v88 = (int8x8_t *)&v9->i8[v87 + v85];
  v89 = (float32x4_t *)&__src[v87];
  v90 = v87 - v86;
  do
  {
    v91 = *v88++;
    a5 = (int32x4_t)vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip1_s8(v91, v91), 8uLL), 8uLL)));
    *v89 = (float32x4_t)a5;
    v89[1] = vcvtq_f32_s32(vmovl_s16(vshr_n_s16(vshl_n_s16((int16x4_t)vzip2_s8(v91, v91), 8uLL), 8uLL)));
    v89 += 2;
    v90 += 8;
  }
  while (v90);
  if (v86 != v8)
    goto LABEL_78;
LABEL_80:
  if (v8 >= 8)
  {
    v102 = v8 & 0x7FFFFFF8;
    v103 = (float32x4_t *)(__dst + 4);
    v104 = (float32x4_t *)&v140;
    v105 = (__n128 *)v143;
    v106 = v8 & 0xFFFFFFF8;
    do
    {
      a5 = (int32x4_t)vmulq_f32(*v103, *v104);
      v105[-1] = (__n128)vmulq_f32(v103[-1], v104[-1]);
      *v105 = (__n128)a5;
      v103 += 2;
      v104 += 2;
      v105 += 2;
      v106 -= 8;
    }
    while (v106);
    if (v102 == v8)
      goto LABEL_87;
  }
  else
  {
    v102 = 0;
  }
  v107 = v8 - v102;
  v108 = v102;
  v109 = (float *)&v142[v102];
  v110 = &v139[v108];
  v111 = &__dst[v108];
  do
  {
    v112 = *v111++;
    v113 = v112;
    v114 = *v110++;
    *(float *)a5.i32 = v114;
    *v109++ = v113 * v114;
    --v107;
  }
  while (v107);
LABEL_87:
  if ((int)v7 >= 1)
  {
    v115 = 0;
    v116 = &v27->u8[v85];
    do
    {
      v117 = __src[v115];
      v118 = v116;
      v119 = a3;
      v120 = v7;
      do
      {
        a5.i8[0] = *v118;
        a5.i64[0] = vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)a5.i8)).u64[0];
        *(float *)a5.i32 = (float)a5.i32[0];
        v121 = *v119++;
        v117 = v117 + (float)(*(float *)a5.i32 * v121);
        v118 += v26;
        --v120;
      }
      while (v120);
      __src[v115++] = v117;
      ++v116;
    }
    while (v115 != v8);
  }
  v122 = 0;
  v123 = &v36[v85];
  do
  {
    v124 = __src[v122];
    v125 = (float *)v142;
    v126 = v123;
    v127 = v8;
    do
    {
      a5.i8[0] = *v126;
      a5.i64[0] = vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)a5.i8)).u64[0];
      *(float *)a5.i32 = (float)a5.i32[0];
      v128 = *v125++;
      v124 = v124 + (float)(*(float *)a5.i32 * v128);
      v126 += v26;
      --v127;
    }
    while (v127);
    __src[v122++] = v124;
    ++v123;
  }
  while (v122 != v8);
  v129 = 0;
  do
  {
    v130 = __src[v129] * 0.0078125;
    v131 = 1.0;
    if (v130 < 8.0)
    {
      v131 = -1.0;
      if (v130 > -8.0)
      {
        v132 = -v130;
        v133 = v130 < 0.0;
        if (v130 >= 0.0)
          v132 = __src[v129] * 0.0078125;
        v134 = (float)(v132 * 25.0) + 0.5;
        v135 = floorf(v134);
        v136 = vcvtms_s32_f32(v134);
        v137 = tansig_table[v136]
             + (float)((float)((float)(v132 + (float)((float)(int)v135 * -0.04))
                             * (float)(1.0 - (float)(tansig_table[v136] * tansig_table[v136])))
                     * (float)(1.0 - (float)(tansig_table[v136] * (float)(v132 + (float)((float)(int)v135 * -0.04)))));
        v131 = -v137;
        if (!v133)
          v131 = v137;
      }
    }
    __src[v129] = (float)((float)(1.0 - v141[v129]) * v131) + (float)(v141[v129] * __dst[v129]);
    ++v129;
  }
  while (v8 != v129);
  return (int8x16_t **)memcpy(__dst, __src, 4 * v8);
}

unint64_t silk_NLSF2A(int16x8_t *a1, __int16 *a2, int a3)
{
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int *v21;
  int *v22;
  int8x16_t *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  unint64_t result;
  unsigned int v31;
  uint32x4_t v32;
  int v33;
  int8x16_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int16x8_t *v38;
  uint32x4_t *v39;
  uint32x4_t v40;
  uint32x4_t v41;
  uint32x4_t v42;
  uint32x4_t v43;
  uint64_t v44;
  __int16 *v45;
  __int32 *v46;
  unsigned int v47;
  BOOL v48;
  unsigned int v49;
  uint64_t v50;
  unint64_t v51;
  int v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int8x16_t v57;
  uint64_t v58;
  int v59;
  _DWORD v60[12];
  int v61;
  _DWORD v62[12];
  int v63;
  _QWORD v64[13];

  *(_QWORD *)((char *)&v64[11] + 4) = *MEMORY[0x24BDAC8D0];
  v5 = (unsigned __int8 *)&silk_NLSF2A_ordering10;
  if (a3 == 16)
    v5 = (unsigned __int8 *)&silk_NLSF2A_ordering16;
  v6 = a3;
  v56 = a3;
  if (a3 <= 0)
  {
    LODWORD(v10) = a3 >> 1;
    v17 = 0x10000;
    v61 = 0x10000;
LABEL_14:
    v59 = 0x10000;
    v60[0] = -v17;
    goto LABEL_15;
  }
  do
  {
    v7 = *a2++;
    v8 = ((((silk_LSFCosTab_FIX_Q12[(v7 >> 8) + 1] - silk_LSFCosTab_FIX_Q12[v7 >> 8]) * v7
          + (silk_LSFCosTab_FIX_Q12[v7 >> 8] << 8)) >> 3)
        + 1) >> 1;
    v9 = *v5++;
    *(&v63 + v9) = v8;
    --v6;
  }
  while (v6);
  v10 = a3 >> 1;
  v61 = 0x10000;
  v62[0] = -v63;
  if (a3 <= 3)
  {
    v17 = v64[0];
    goto LABEL_14;
  }
  v11 = 0;
  v12 = 1;
  do
  {
    v13 = *(&v63 + 2 * v12);
    v14 = v12 + 1;
    v62[v12] = 2 * v62[v12 - 2] - ((((unint64_t)(v62[v12 - 1] * (uint64_t)v13) >> 15) + 1) >> 1);
    if (v12 >= 2)
    {
      v15 = v11;
      do
      {
        v62[v15] = v62[v15]
                 + v62[(v15 - 1) - 1]
                 - ((((unint64_t)(v62[v15 - 1] * (uint64_t)v13) >> 15) + 1) >> 1);
        v16 = v15-- + 1;
      }
      while (v16 > 2);
    }
    v62[0] -= v13;
    ++v11;
    v12 = v14;
  }
  while (v14 != v10);
  v50 = 0;
  v59 = 0x10000;
  v60[0] = -LODWORD(v64[0]);
  v51 = 1;
  do
  {
    v52 = v64[v51];
    v53 = v51 + 1;
    v60[v51] = 2 * v60[v51 - 2] - ((((unint64_t)(v60[v51 - 1] * (uint64_t)v52) >> 15) + 1) >> 1);
    if (v51 >= 2)
    {
      v54 = v50;
      do
      {
        v60[v54] = v60[v54]
                 + v60[(v54 - 1) - 1]
                 - ((((unint64_t)(v60[v54 - 1] * (uint64_t)v52) >> 15) + 1) >> 1);
        v55 = v54-- + 1;
      }
      while (v55 > 2);
    }
    v60[0] -= v52;
    ++v50;
    v51 = v53;
  }
  while (v53 != v10);
LABEL_15:
  v18 = a3 - 1;
  if (a3 > 1)
  {
    if ((int)v10 <= 1)
      v10 = 1;
    else
      v10 = v10;
    v19 = v61;
    v20 = v59;
    v21 = v60;
    v22 = v62;
    v23 = &v57;
    do
    {
      v25 = *v22++;
      v24 = v25;
      v26 = v25 + v19;
      v27 = *v21++;
      v28 = v27 - v20;
      v23->i32[0] = -(v26 + v28);
      v23 = (int8x16_t *)((char *)v23 + 4);
      v57.i32[v18--] = v28 - v26;
      v20 = v27;
      v19 = v24;
      --v10;
    }
    while (v10);
  }
  silk_LPC_fit((uint64_t)a1, &v57, 12, 17, a3);
  v29 = (a3 - 1);
  if (a3 < 1)
  {
    result = silk_LPC_inverse_pred_gain_c(a1, a3);
    if (!(_DWORD)result)
    {
      v49 = 0;
      do
      {
        v57.i32[(int)v29] = (unint64_t)(v57.i32[(int)v29] * (uint64_t)((-2 << v49) + 0x10000)) >> 16;
        result = silk_LPC_inverse_pred_gain_c(a1, a3);
        if ((_DWORD)result)
          break;
        v48 = v49++ >= 0xF;
      }
      while (!v48);
    }
  }
  else
  {
    result = silk_LPC_inverse_pred_gain_c(a1, a3);
    if (!(_DWORD)result)
    {
      v31 = 0;
      v32.i64[0] = 0x100000001;
      v32.i64[1] = 0x100000001;
      while (1)
      {
        v33 = (-2 << v31) + 0x10000;
        if (a3 >= 2)
        {
          v34 = &v57;
          v35 = (a3 - 1);
          do
          {
            v34->i32[0] = (unint64_t)(v34->i32[0] * (uint64_t)v33) >> 16;
            v34 = (int8x16_t *)((char *)v34 + 4);
            v33 += (((v33 * (-2 << v31)) >> 15) + 1) >> 1;
            --v35;
          }
          while (v35);
        }
        v57.i32[v29] = (unint64_t)(v57.i32[v29] * (uint64_t)v33) >> 16;
        if (a3 >= 0x10)
        {
          v37 = v56 & 0xFFFFFFF0;
          v38 = a1 + 1;
          v39 = (uint32x4_t *)&v58;
          do
          {
            v41 = v39[-2];
            v40 = v39[-1];
            v43 = *v39;
            v42 = v39[1];
            v39 += 4;
            v38[-1] = vuzp1q_s16((int16x8_t)vhaddq_u32(vshrq_n_u32(v41, 4uLL), v32), (int16x8_t)vhaddq_u32(vshrq_n_u32(v40, 4uLL), v32));
            *v38 = vuzp1q_s16((int16x8_t)vhaddq_u32(vshrq_n_u32(v43, 4uLL), v32), (int16x8_t)vhaddq_u32(vshrq_n_u32(v42, 4uLL), v32));
            v38 += 2;
            v37 -= 16;
          }
          while (v37);
          v36 = v56 & 0xFFFFFFF0;
          if (v36 == v56)
            goto LABEL_34;
        }
        else
        {
          v36 = 0;
        }
        v44 = v56 - v36;
        v45 = &a1->i16[v36];
        v46 = &v57.i32[v36];
        do
        {
          v47 = *v46++;
          *v45++ = ((v47 >> 4) + 1) >> 1;
          --v44;
        }
        while (v44);
LABEL_34:
        result = silk_LPC_inverse_pred_gain_c(a1, a3);
        v32.i64[0] = 0x100000001;
        v32.i64[1] = 0x100000001;
        if (!(_DWORD)result)
        {
          v48 = v31++ >= 0xF;
          if (!v48)
            continue;
        }
        return result;
      }
    }
  }
  return result;
}

__int16 *silk_NLSF_decode(__int16 *a1, char *a2, uint64_t a3)
{
  int v3;
  unint64_t v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  _BYTE *v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  _WORD v26[24];
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v3 = *(__int16 *)(a3 + 2);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *a2;
    v6 = *(unsigned __int16 *)(a3 + 2);
    v7 = *(_QWORD *)(a3 + 32);
    v8 = (unsigned __int8 *)(*(_QWORD *)(a3 + 40) + *(unsigned __int16 *)(a3 + 2) * v5 / 2);
    v9 = v6 - 1;
    do
    {
      v10 = *v8++;
      v11 = &v26[v4 / 2 + 16];
      *v11 = *(_BYTE *)(v7 + ((v10 << 31 >> 31) & v9) + (int)v4);
      v11[1] = *(_BYTE *)(v7 + (v9 & (v10 << 27 >> 31)) + (int)v4 + 1);
      v4 += 2;
    }
    while (v4 < v6);
    LOWORD(v12) = 0;
    v13 = *(__int16 *)(a3 + 4);
    v14 = v6 + 1;
    do
    {
      v15 = (v14 - 2);
      v16 = (__int16)v12 * *((unsigned __int8 *)&v26[16] + v15);
      v17 = a2[v15 + 1];
      if (v17 <= 0)
        v18 = ((v17 << 10) | 0x66) & (v17 >> 31);
      else
        v18 = ((v17 << 10) - 102);
      v12 = ((unint64_t)(v18 * v13) >> 16) + (v16 >> 8);
      v26[v15] = v12;
      --v14;
    }
    while (v14 > 1);
    v19 = 0;
    v20 = (int)v6 * (uint64_t)v5;
    v21 = *(_QWORD *)(a3 + 8) + v20;
    v22 = *(_QWORD *)(a3 + 16) + 2 * v20;
    do
    {
      v23 = ((__int16)v26[v19] << 14) / *(__int16 *)(v22 + 2 * v19) + (*(unsigned __int8 *)(v21 + v19) << 7);
      v24 = v23 & ~(v23 >> 31);
      if (v24 >= 0x7FFF)
        LOWORD(v24) = 0x7FFF;
      a1[v19++] = v24;
    }
    while (v19 < *(__int16 *)(a3 + 2));
    LOWORD(v3) = *(_WORD *)(a3 + 2);
  }
  return silk_NLSF_stabilize(a1, *(int16x8_t **)(a3 + 64), (__int16)v3);
}

uint64_t silk_NLSF_del_dec_quant(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 a7, int a8, int a9, __int16 a10)
{
  signed int v10;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  _BYTE *v17;
  _BYTE *v18;
  uint64_t v19;
  __int16 v20;
  __int16 v21;
  __int16 v22;
  __int16 v23;
  __int16 v24;
  __int16 v25;
  __int16 v26;
  BOOL v27;
  __int16 v28;
  __int16 v29;
  uint64_t v30;
  int v31;
  int v32;
  unsigned int v33;
  uint64_t v34;
  BOOL v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __int16 v41;
  int v42;
  int v43;
  uint64_t v44;
  int *v45;
  __int16 *v46;
  _BYTE *v47;
  int v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  int v56;
  int v57;
  __int16 v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  char v63;
  int v64;
  int v65;
  __int16 v66;
  unsigned int v67;
  int v68;
  int v69;
  int v70;
  __int16 v71;
  int v72;
  int v73;
  int v74;
  int v75;
  __int16 v76;
  unsigned int v77;
  int v78;
  int v79;
  int v80;
  __int16 v81;
  unsigned int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  unsigned int v91;
  uint64_t v92;
  unsigned int v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  int v97;
  _BYTE *v98;
  int v99;
  _BOOL4 v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  unsigned int v107;
  _BYTE *v108;
  uint64_t result;
  _BYTE *__dst;
  int v111;
  uint64_t v117;
  uint64_t v118;
  int v119;
  _BYTE v120[80];
  _BYTE v121[80];
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  __int16 v138;
  __int16 v139;
  __int16 v140;
  __int16 v141;
  __int16 v142;
  __int16 v143;
  __int16 v144;
  __int16 v145;
  _BYTE v146[64];
  unsigned int v147;
  int v148;
  unsigned int v149;
  unsigned int v150;
  uint64_t v151;

  v12 = 0;
  v13 = a10;
  v14 = a9;
  v151 = *MEMORY[0x24BDAC8D0];
  v15 = 102;
  v16 = 922;
  v17 = v121;
  v18 = v120;
  do
  {
    v19 = v12 - 10;
    v20 = ((_WORD)v12 - 10) << 10;
    v21 = v20 + 1024;
    v22 = (v20 + 1024) | 0x66;
    v23 = v20 | 0x39A;
    if ((_DWORD)v12 == 10)
      v24 = 0;
    else
      v24 = v20 | 0x66;
    if ((_DWORD)v12 == 10)
      v22 = v20 | 0x39A;
    if ((_DWORD)v12 == 9)
      v25 = v20 | 0x66;
    else
      v25 = v24;
    if ((_DWORD)v12 != 9)
      v21 = v22;
    v26 = v20 - 102;
    v27 = __OFSUB__(v19, 1);
    if (v19 >= 1)
      v28 = v26;
    else
      v28 = v25;
    if (v12 - 11 < 0 != v27)
      v29 = v21;
    else
      v29 = v23;
    v30 = 4 * v12;
    *(_DWORD *)&v121[v30] = (a7 * v28) >> 16;
    *(_DWORD *)&v120[v30] = (a7 * v29) >> 16;
    ++v12;
  }
  while (v12 != 20);
  v130 = 0;
  v138 = 0;
  v31 = a10;
  if (a10 >= 1)
  {
    __dst = a1;
    v32 = a10 - 1;
    v33 = 1;
    v34 = a10;
    while (1)
    {
      while (1)
      {
        v36 = &v146[v32];
        v37 = v34 - 1;
        v38 = (v34 - 1);
        if ((int)v33 >= 1)
          break;
LABEL_42:
        v59 = 2 * v33;
        if (v33 <= 1)
        {
          v60 = v59;
          if (v59 <= 3)
            v61 = 3;
          else
            v61 = 2 * v33;
          v62 = v61 + 1;
          do
          {
            v63 = *v36;
            v36 += 16;
            v146[16 * v60++ + v38] = v63;
          }
          while (v62 != v60);
        }
        v33 *= 2;
        --v32;
        v35 = v34 <= 1;
        v34 = v37;
        if (v35)
          goto LABEL_110;
      }
      v117 = v34 - 1;
      v118 = v34;
      v39 = 0;
      v40 = a6 + *(__int16 *)(a5 + 2 * v38);
      v41 = *(_WORD *)(a2 + 2 * v38);
      v42 = *(unsigned __int8 *)(a4 + v38);
      v43 = *(__int16 *)(a3 + 2 * v38);
      v44 = v33;
      v45 = &v130 + v33;
      v119 = v33;
      v46 = &v138 + v33;
      v47 = &v146[v32];
      do
      {
        v52 = (*(&v138 + v39) * v42) >> 8;
        v53 = ((__int16)(v41 - v52) * a8) >> 16;
        if (v53 <= -10)
          v53 = -10;
        if (v53 >= 9)
          v54 = 9;
        else
          v54 = v53;
        *v47 = v54;
        v55 = 4 * (v54 + 10);
        v56 = *(_DWORD *)&v120[v55];
        v57 = v52 + *(_DWORD *)&v121[v55];
        v58 = v56 + v52;
        *(&v138 + v39) = v57;
        v46[v39] = v58;
        if (v54 < 3)
        {
          if (v54 > -4)
          {
            v48 = *(unsigned __int8 *)(v40 + (v54 + 4));
            v49 = *(unsigned __int8 *)(v40 + (v54 + 5));
          }
          else if (v54 == -4)
          {
            v49 = *(unsigned __int8 *)(v40 + 1);
            v48 = 280;
          }
          else
          {
            v48 = -43 * v54 + 108;
            v49 = -43 * v54 + 65;
          }
        }
        else if (v54 == 3)
        {
          v48 = *(unsigned __int8 *)(v40 + 7);
          v49 = 280;
        }
        else
        {
          v48 = 43 * v54 + 108;
          v49 = 43 * v54 + 151;
        }
        v50 = v39;
        v51 = *(&v130 + v39);
        *(int *)((char *)&v130 + v50 * 4) = (__int16)(v41 - v57) * v43 * (__int16)(v41 - v57) + v48 * (__int16)a9 + v51;
        v45[v50] = v51 + (__int16)(v41 - v58) * v43 * (__int16)(v41 - v58) + v49 * (__int16)a9;
        ++v39;
        v47 += 16;
      }
      while (v44 != v39);
      v33 = v119;
      if (v119 < 3)
      {
        v146[16 * v44 + v38] = v146[v38] + 1;
        v37 = v117;
        v34 = v118;
        if (v119 != 1)
          v146[16 * v44 + 16 + v38] = v146[v38 + 16] + 1;
        goto LABEL_42;
      }
      v64 = v130;
      v65 = v134;
      if (v130 <= v134)
      {
        v67 = 0;
        v68 = v134;
      }
      else
      {
        v130 = v134;
        v134 = v64;
        v66 = v138;
        v138 = v142;
        v142 = v66;
        v67 = 4;
        v68 = v64;
        v64 = v65;
      }
      v122 = v68;
      v126 = v64;
      v147 = v67;
      v69 = v131;
      v70 = v135;
      if (v131 <= v135)
      {
        v72 = 1;
        v73 = v135;
      }
      else
      {
        v131 = v135;
        v135 = v69;
        v71 = v139;
        v139 = v143;
        v143 = v71;
        v72 = 5;
        v73 = v69;
        v69 = v70;
      }
      v123 = v73;
      v127 = v69;
      v148 = v72;
      v74 = v132;
      v75 = v136;
      if (v132 <= v136)
      {
        v77 = 2;
        v78 = v136;
      }
      else
      {
        v132 = v136;
        v136 = v74;
        v76 = v140;
        v140 = v144;
        v144 = v76;
        v77 = 6;
        v78 = v74;
        v74 = v75;
      }
      v124 = v78;
      v128 = v74;
      v149 = v77;
      v79 = v133;
      v80 = v137;
      v111 = v72;
      if (v133 <= v137)
      {
        v82 = 3;
        v83 = v137;
      }
      else
      {
        v133 = v137;
        v137 = v79;
        v81 = v141;
        v141 = v145;
        v145 = v81;
        v82 = 7;
        v83 = v79;
        v79 = v80;
      }
      v125 = v83;
      v129 = v79;
      v150 = v82;
      v84 = v64 & ~(v64 >> 31);
      if (v68 >= v73)
        v85 = v73;
      else
        v85 = v68;
      if (v84 <= v69)
        v86 = v69;
      else
        v86 = v84;
      if (v85 >= v78)
        v87 = v78;
      else
        v87 = v85;
      if (v86 <= v74)
        v88 = v74;
      else
        v88 = v86;
      if (v87 >= v83)
        v89 = v83;
      else
        v89 = v87;
      if (v88 <= v79)
        v90 = v79;
      else
        v90 = v88;
      v35 = v89 < v90;
      v91 = v111;
      if (v35)
      {
        do
        {
          v92 = v84 < v69;
          if (v86 < v74)
            v92 = 2;
          if (v88 < v79)
            v92 = 3;
          v93 = v68 > v73;
          if (v85 > v78)
            v93 = 2;
          if (v87 > v83)
            v93 = 3;
          v94 = 4 * v93;
          v95 = 4 * v92;
          *(unsigned int *)((char *)&v147 + v95) = *(unsigned int *)((char *)&v147 + v94) ^ 4;
          *(int *)((char *)&v130 + v95) = *(&v130 + (v93 | 4));
          *(&v138 + v92) = *(&v138 + (v93 | 4));
          *(int *)((char *)&v126 + v95) = 0;
          *(int *)((char *)&v122 + v94) = 0x7FFFFFFF;
          *(_OWORD *)&v146[16 * v92] = *(_OWORD *)&v146[16 * v93];
          v68 = v122;
          v73 = v123;
          v69 = v127;
          v78 = v124;
          v83 = v125;
          v74 = v128;
          v79 = v129;
          v84 = v126 & ~(v126 >> 31);
          if (v122 >= v123)
            v85 = v123;
          else
            v85 = v122;
          if (v84 <= v127)
            v86 = v127;
          else
            v86 = v126 & ~(v126 >> 31);
          if (v85 >= v124)
            v87 = v124;
          else
            v87 = v85;
          if (v86 <= v128)
            v88 = v128;
          else
            v88 = v86;
          if (v87 >= v125)
            v96 = v125;
          else
            v96 = v87;
          if (v88 <= v129)
            v97 = v129;
          else
            v97 = v88;
        }
        while (v96 < v97);
        v67 = v147;
        v91 = v148;
        v77 = v149;
        v82 = v150;
      }
      v98 = &v146[v38];
      *v98 = v146[v38] + (v67 >> 2);
      v98[16] = v146[v38 + 16] + (v91 >> 2);
      v98[32] = v146[v38 + 32] + (v77 >> 2);
      v98[48] = v146[v38 + 48] + (v82 >> 2);
      v33 = v119;
      --v32;
      v34 = v117;
      if (v118 <= 1)
      {
LABEL_110:
        v99 = v130;
        LODWORD(v18) = v131;
        LODWORD(v17) = v132;
        v16 = v133;
        v15 = v134;
        v31 = v135;
        v14 = v136;
        v10 = v137;
        a1 = __dst;
        v13 = a10;
        goto LABEL_112;
      }
    }
  }
  v99 = 0;
LABEL_112:
  v100 = v99 > (int)v18;
  if (v99 >= (int)v18)
    v99 = (int)v18;
  if (v99 <= (int)v17)
    v101 = v100;
  else
    v101 = 2;
  if (v99 >= (int)v17)
    v99 = (int)v17;
  if (v99 <= v16)
    v102 = v101;
  else
    v102 = 3;
  if (v99 >= v16)
    v99 = v16;
  if (v99 <= v15)
    v103 = v102;
  else
    v103 = 4;
  if (v99 >= v15)
    v99 = v15;
  if (v99 <= v31)
    v104 = v103;
  else
    v104 = 5;
  if (v99 < v31)
    v31 = v99;
  if (v31 <= v14)
    v105 = v104;
  else
    v105 = 6;
  if (v31 >= v14)
    v106 = v14;
  else
    v106 = v31;
  if (v106 <= v10)
    v107 = v105;
  else
    v107 = 7;
  if (v13 > 0)
  {
    v108 = a1;
    memcpy(a1, &v146[16 * (v107 & 3)], a10);
    a1 = v108;
  }
  if (v106 >= v10)
    result = v10;
  else
    result = v106;
  *a1 += v107 >> 2;
  return result;
}

uint64_t silk_NLSF_encode(char *a1, __int16 *a2, int16x8_t **a3, int16x8_t *a4, int a5, uint64_t a6, int a7)
{
  __int16 *v10;
  __int16 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  uint32x4_t v43;
  int32x4_t v44;
  uint32x4_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t *v53;
  int16x8_t *v54;
  int16x8_t *v55;
  int16x8_t *v56;
  unint64_t v57;
  unint64_t v58;
  __int16 *v59;
  unint64_t v60;
  BOOL v61;
  BOOL v62;
  BOOL v63;
  BOOL v64;
  BOOL v65;
  BOOL v66;
  BOOL v67;
  BOOL v68;
  BOOL v69;
  BOOL v70;
  BOOL v71;
  BOOL v72;
  BOOL v73;
  BOOL v74;
  BOOL v75;
  BOOL v76;
  uint64_t v78;
  int16x8_t *v79;
  int16x8_t *v80;
  int16x8_t *v81;
  int16x8_t *v82;
  int16x8_t v83;
  int16x8_t v84;
  int16x8_t v85;
  uint32x4_t v86;
  uint32x4_t v87;
  uint32x4_t v88;
  uint32x4_t v89;
  int32x4_t v90;
  int32x4_t v91;
  int32x4_t v92;
  int32x4_t v93;
  int32x4_t v94;
  int32x4_t v95;
  int32x4_t v96;
  int32x4_t v97;
  int32x4_t v98;
  int32x4_t v99;
  unsigned int v100;
  unsigned int v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  unsigned int v105;
  unsigned int v106;
  unsigned int v107;
  int64x2_t v108;
  int64x2_t v109;
  int64x2_t v110;
  int64x2_t v111;
  int64x2_t v112;
  int64x2_t v113;
  int64x2_t v114;
  int64x2_t v115;
  int64x2_t v116;
  int64x2_t v117;
  int64x2_t v118;
  int64x2_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  int64x2_t v128;
  int64x2_t v129;
  int64x2_t v130;
  int64x2_t v131;
  uint64_t v132;
  int64x2_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  int16x8_t v139;
  int16x8_t v140;
  int16x8_t v141;
  int32x4_t v142;
  int64x2_t v143;
  uint64x2_t v144;
  int32x4_t v145;
  uint64x2_t v146;
  uint64x2_t v147;
  int32x4_t v148;
  int32x4_t v149;
  int32x4_t v150;
  int8x16_t v151;
  int8x16_t v152;
  int32x4_t v153;
  int8x16_t v154;
  int8x16_t v155;
  uint32x4_t v156;
  uint32x4_t v157;
  uint32x4_t v158;
  int32x4_t v159;
  uint32x4_t v160;
  int8x16_t v161;
  int8x16_t v162;
  uint64_t v163;
  __int8 *v164;
  uint64_t v165;
  uint64_t v166;
  int v167;
  int v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  int v172;
  unsigned int v173;
  int v174;
  uint64_t v175;
  int v176;
  int v177;
  int v178;
  int v179;
  unsigned int v180;
  unsigned int v181;
  uint64_t v182;
  uint64_t v183;
  unsigned __int8 *v184;
  int v185;
  unsigned int v186;
  __int16 *v187;
  _BYTE *v188;
  uint64_t v189;
  int v190;
  unsigned __int8 *v191;
  int v192;
  unsigned int v193;
  unsigned int v194;
  int v195;
  unsigned int *v196;
  uint64_t v197;
  char *v198;
  char *v199;
  _QWORD v201[2];
  char *v202;
  uint64_t v203;
  __int16 *v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  int v211;
  uint64_t v212;
  int v213;
  int v214;
  int16x8_t *v215;
  int v216;
  char *v217;
  char *v218;
  unsigned int *v219;
  int32x4_t v220[2];
  _BYTE v221[16];
  _WORD v222[16];
  _WORD v223[12];
  uint64_t v224;

  v216 = a5;
  v10 = (__int16 *)a3;
  v202 = a1;
  v224 = *MEMORY[0x24BDAC8D0];
  v220[0].i32[0] = 0;
  v12 = silk_NLSF_stabilize(a2, a3[8], *((__int16 *)a3 + 1));
  v201[1] = v201;
  v14 = MEMORY[0x24BDAC7A8](v12, v13);
  v17 = (char *)v201 - v16;
  v18 = *v10;
  if ((int)v18 >= 1)
  {
    v19 = v10[1];
    if (v19 < 2)
    {
      bzero((char *)v201 - v16, 4 * v18);
    }
    else
    {
      v20 = 0;
      v21 = v10[1];
      v22 = *((_QWORD *)v10 + 1);
      v23 = *((_QWORD *)v10 + 2);
      v24 = v19 + 2;
      do
      {
        v25 = 0;
        v26 = 0;
        v27 = v24;
        do
        {
          v28 = (__int16)(a2[v27 - 3] - (*(unsigned __int8 *)(v22 + (v27 - 3)) << 7))
              * *(__int16 *)(v23 + 2 * (v27 - 3));
          v29 = v28 - (v25 >> 1);
          if (v29 < 0)
            v29 = -v29;
          v14 = 2 * (v27 - 4);
          v15 = *(unsigned __int16 *)((char *)a2 + v14);
          v30 = v29 + v26;
          v25 = (__int16)(v15 - (*(unsigned __int8 *)(v22 + (v27 - 4)) << 7)) * *(__int16 *)(v23 + v14);
          v31 = v25 - (v28 >> 1);
          if (v31 < 0)
            v31 = (v28 >> 1) - v25;
          v26 = v30 + v31;
          v27 -= 2;
        }
        while (v27 > 3);
        *(_DWORD *)&v17[4 * v20] = v26;
        v22 += v21;
        v23 += 2 * v21;
        ++v20;
      }
      while (v20 != v18);
    }
  }
  v215 = a4;
  MEMORY[0x24BDAC7A8](v14, v15);
  v32 = (4 * a6 + 15) & 0x7FFFFFFF0;
  v218 = (char *)v201 - v32;
  v33 = silk_insertion_sort_increasing((uint64_t)v17, (int32x4_t *)((char *)v201 - v32), v18, a6);
  v35 = MEMORY[0x24BDAC7A8](v33, v34);
  v219 = (unsigned int *)((char *)v201 - v32);
  MEMORY[0x24BDAC7A8](v35, v36);
  v217 = (char *)v201 - v37;
  v203 = a6;
  if ((int)a6 >= 1)
  {
    v38 = 0;
    v214 = a7 >> 1;
    v213 = (__int16)(v216 >> 2);
    v39.i64[0] = -1;
    v39.i64[1] = -1;
    v40.i64[0] = 0x700000007;
    v40.i64[1] = 0x700000007;
    v41.i64[0] = 0x800000008;
    v41.i64[1] = 0x800000008;
    v42.i64[0] = 0x1D0000001DLL;
    v42.i64[1] = 0x1D0000001DLL;
    v43.i64[0] = 0x3500000035;
    v43.i64[1] = 0x3500000035;
    v44.i64[0] = 0x8000000080000000;
    v44.i64[1] = 0x8000000080000000;
    v45.i64[0] = 0x8000000080000000;
    v45.i64[1] = 0x8000000080000000;
    v212 = v203;
    v204 = v10;
    while (1)
    {
      v46 = *(int *)&v218[4 * v38];
      v47 = v10[1];
      v48 = (unsigned __int16)v10[1];
      if ((int)v47 < 1)
        goto LABEL_102;
      v49 = (int)v46 * (uint64_t)v10[1];
      v51 = *((_QWORD *)v10 + 1);
      v50 = *((_QWORD *)v10 + 2);
      if (v47 < 0x10)
      {
        v52 = 0;
        goto LABEL_85;
      }
      v211 = (unsigned __int16)v10[1];
      v52 = 0;
      v53 = (uint64_t *)(v51 + (int)v46 * (uint64_t)(int)v47);
      v54 = (int16x8_t *)(v50 + 2 * v49);
      v55 = (int16x8_t *)&v223[v47];
      v56 = (int16x8_t *)&v222[v47];
      v57 = v51 + v49 + v47;
      v210 = v50;
      v58 = v50 + 2 * (v49 + v47);
      v59 = &a2[v47];
      v60 = (unint64_t)v215 + 2 * v47;
      v61 = (unint64_t)v223 >= v57 || v53 >= (uint64_t *)v55;
      v62 = !v61;
      v63 = (unint64_t)v223 >= v58 || v54 >= v55;
      v64 = !v63;
      v65 = v223 < v59 && v55 > (int16x8_t *)a2;
      v66 = v65;
      v67 = (unint64_t)v223 < v60 && v55 > v215;
      v68 = v67;
      v69 = (unint64_t)v222 >= v57 || v53 >= (uint64_t *)v56;
      v70 = !v69;
      v71 = (unint64_t)v222 >= v58 || v54 >= v56;
      v72 = !v71;
      v73 = v222 < v59 && v56 > (int16x8_t *)a2;
      v74 = v73;
      v75 = (unint64_t)v222 < v60 && v56 > v215;
      v76 = v75;
      if (v222 < (_WORD *)v55 && v223 < (_WORD *)v56)
        break;
      v48 = v211;
      if (v62 || v64 || v66 || v68 || v70 || v72 || v74)
      {
        v50 = v210;
LABEL_85:
        v163 = 0;
        v164 = &v215->i8[2 * v52];
        v165 = v50 + 2 * v52 + 2 * v49;
        v166 = v51 + v52 + v49;
        do
        {
          v167 = *(__int16 *)(v165 + 2 * v163);
          v223[v52 + v163] = ((__int16)(a2[v52 + v163] - (*(unsigned __int8 *)(v166 + v163) << 7)) * v167) >> 14;
          v168 = *(__int16 *)&v164[2 * v163];
          v169 = v167 * v167;
          if (v168 >= 0)
            v170 = *(__int16 *)&v164[2 * v163];
          else
            v170 = -v168;
          v171 = __clz(v170);
          v172 = v168 << (v171 - 1);
          v173 = __clz(v169);
          v174 = v169 << (v173 - 1);
          v175 = (0x1FFFFFFF / (v174 >> 16) * (uint64_t)v172) >> 16;
          v176 = ((unint64_t)(0x1FFFFFFF
                                   / (v174 >> 16)
                                   * (uint64_t)(int)(v172
                                                  - (((unint64_t)((int)v175 * (uint64_t)v174) >> 29) & 0xFFFFFFF8))) >> 16)
               + v175;
          v177 = v171 - v173;
          if (v171 - v173 + 29 >= 0x35)
            LOWORD(v178) = 0;
          else
            v178 = v176 >> (v177 + 8);
          v179 = (int)0x80000000 >> (-8 - v177);
          if (v179 <= v176)
            v179 = v176;
          if ((int)(0x7FFFFFFFu >> (-8 - v177)) >= v176)
            v180 = v179;
          else
            v180 = 0x7FFFFFFFu >> (-8 - v177);
          v181 = v180 << (-8 - v177);
          if (v177 > -9)
            LOWORD(v181) = v178;
          v222[v52 + v163++] = v181;
        }
        while (v47 - v52 != v163);
        goto LABEL_100;
      }
      v50 = v210;
      if (v76)
        goto LABEL_85;
      v206 = v51;
      v207 = (int)v46 * (uint64_t)(int)v47;
      v209 = v46;
      v208 = v47;
      v78 = v47 & 0xFFFFFFF8;
      v79 = (int16x8_t *)v223;
      v80 = (int16x8_t *)v222;
      v205 = v78;
      v81 = v215;
      v82 = (int16x8_t *)a2;
      do
      {
        v83 = *v54++;
        v84 = v83;
        v85 = *v81++;
        v86 = (uint32x4_t)vmovl_s16(*(int16x4_t *)v85.i8);
        v87 = (uint32x4_t)vmovl_high_s16(v85);
        v88 = (uint32x4_t)vmull_s16(*(int16x4_t *)v84.i8, *(int16x4_t *)v84.i8);
        v89 = (uint32x4_t)vmull_high_s16(v84, v84);
        v90 = vclzq_s32(vabsq_s32((int32x4_t)v86));
        v91 = vclzq_s32(vabsq_s32((int32x4_t)v87));
        v92 = vclzq_s32((int32x4_t)v89);
        v93 = vclzq_s32((int32x4_t)v88);
        v94 = (int32x4_t)vshlq_u32(v86, (uint32x4_t)vaddq_s32(v90, v39));
        v95 = (int32x4_t)vshlq_u32(v89, (uint32x4_t)vaddq_s32(v92, v39));
        v96 = (int32x4_t)vshlq_u32(v88, (uint32x4_t)vaddq_s32(v93, v39));
        v97 = vshrq_n_s32(v96, 0x10uLL);
        v98 = vshrq_n_s32(v95, 0x10uLL);
        v99 = (int32x4_t)vshlq_u32(v87, (uint32x4_t)vaddq_s32(v91, v39));
        v100 = 0x1FFFFFFF / v98.i32[1];
        v101 = 0x1FFFFFFF / v98.i32[0];
        v102 = 0x1FFFFFFF / v98.i32[3];
        v103 = 0x1FFFFFFF / v98.i32[2];
        v104 = 0x1FFFFFFF / v97.i32[1];
        v105 = 0x1FFFFFFF / v97.i32[0];
        v106 = 0x1FFFFFFF / v97.i32[3];
        v107 = 0x1FFFFFFF / v97.i32[2];
        v108.i64[0] = v99.i32[0];
        v108.i64[1] = v99.i32[1];
        v109 = v108;
        v108.i64[0] = v99.i32[2];
        v108.i64[1] = v99.i32[3];
        v110 = v108;
        v108.i64[0] = v94.i32[0];
        v108.i64[1] = v94.i32[1];
        v111 = v108;
        v108.i64[0] = v94.i32[2];
        v108.i64[1] = v94.i32[3];
        v112 = v108;
        v108.i64[0] = v107;
        v108.i64[1] = v106;
        v113 = v108;
        v108.i64[0] = v105;
        v108.i64[1] = v104;
        v114 = v108;
        v108.i64[0] = v101;
        v108.i64[1] = v100;
        v115 = v108;
        v108.i64[0] = v103;
        v108.i64[1] = v102;
        v116 = vshrq_n_s64(vshlq_n_s64(v115, 0x30uLL), 0x30uLL);
        v117 = vshrq_n_s64(vshlq_n_s64(v114, 0x30uLL), 0x30uLL);
        v118 = vshrq_n_s64(vshlq_n_s64(v108, 0x30uLL), 0x30uLL);
        v119 = vshrq_n_s64(vshlq_n_s64(v113, 0x30uLL), 0x30uLL);
        v120 = v119.i64[1];
        v121 = v117.i64[1];
        v122 = v119.i64[0];
        v123 = v117.i64[0];
        v111.i64[0] *= v117.i64[0];
        v124 = v118.i64[1];
        v112.i64[0] *= v119.i64[0];
        v125 = v118.i64[0];
        v111.i64[1] *= v117.i64[1];
        v126 = v116.i64[1];
        v112.i64[1] *= v119.i64[1];
        v110.i64[0] *= v118.i64[0];
        v127 = v116.i64[0];
        v110.i64[1] *= v118.i64[1];
        v109.i64[0] *= v116.i64[0];
        v109.i64[1] *= v116.i64[1];
        v85.i64[0] = *v53++;
        v108.i64[0] = v95.i32[2];
        v108.i64[1] = v95.i32[3];
        v128 = v108;
        v108.i64[0] = v96.i32[0];
        v108.i64[1] = v96.i32[1];
        v129 = v108;
        v108.i64[1] = v96.i32[3];
        v130 = vshrq_n_s64(v110, 0x10uLL);
        v131 = vshrq_n_s64(v111, 0x10uLL);
        v132 = v96.i32[2];
        v133 = vshrq_n_s64(v112, 0x10uLL);
        v134 = v133.i64[0] * v132;
        v135 = v131.i64[1] * v129.i64[1];
        v136 = v133.i64[1] * v108.i64[1];
        v133.i64[0] = v131.i64[0] * v129.i64[0];
        v137 = v130.i64[1] * v128.i64[1];
        v138 = v130.i64[0] * v128.i64[0];
        v139 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v85.i8, 7uLL);
        v140 = *v82++;
        v141 = vsubq_s16(v140, v139);
        v128.i64[0] = v134;
        v142 = vmull_high_s16(v141, v84);
        *(int16x4_t *)v84.i8 = vshrn_n_s32(vmull_s16(*(int16x4_t *)v141.i8, *(int16x4_t *)v84.i8), 0xEuLL);
        v108.i64[1] = v95.i32[1];
        v133.i64[1] = v135;
        v143 = vshrq_n_s64(v109, 0x10uLL);
        v130.i64[0] = v138;
        v128.i64[1] = v136;
        v130.i64[1] = v137;
        v95.i64[0] = v143.i64[0] * v95.i32[0];
        v95.i64[1] = v143.i64[1] * v108.i64[1];
        v144 = (uint64x2_t)vsubq_s32(v99, (int32x4_t)(*(_OWORD *)&vshrn_high_n_s64(vshrn_n_s64((int64x2_t)v95, 0x1DuLL), v130, 0x1DuLL) & __PAIR128__(0xFFFFFFF8FFFFFFF8, 0xFFFFFFF8FFFFFFF8)));
        v145 = vsubq_s32(v94, (int32x4_t)(*(_OWORD *)&vshrn_high_n_s64(vshrn_n_s64(v133, 0x1DuLL), v128, 0x1DuLL) & __PAIR128__(0xFFFFFFF8FFFFFFF8, 0xFFFFFFF8FFFFFFF8)));
        v108.i64[0] = v145.i32[0];
        v108.i64[1] = v145.i32[1];
        v146 = (uint64x2_t)v108;
        v108.i64[0] = v145.i32[2];
        v108.i64[1] = v145.i32[3];
        v147 = (uint64x2_t)v108;
        v108.i64[0] = v144.i32[0];
        v108.i64[1] = v144.i32[1];
        v144.i64[0] = v125 * v144.i32[2];
        v133.i64[0] = v127 * v108.i64[0];
        v144.i64[1] = v124 * v144.i32[3];
        v147.i64[0] *= v122;
        v133.i64[1] = v126 * v108.i64[1];
        v146.i64[0] *= v123;
        v147.i64[1] *= v120;
        v146.i64[1] *= v121;
        v148 = vsubq_s32(v91, v92);
        v149 = vuzp1q_s32((int32x4_t)vsraq_n_s64((int64x2_t)vshrq_n_u64(v146, 0x10uLL), v111, 0x10uLL), (int32x4_t)vsraq_n_s64((int64x2_t)vshrq_n_u64(v147, 0x10uLL), v112, 0x10uLL));
        v150 = vsubq_s32(v90, v93);
        v151 = (int8x16_t)vcgtq_s32(v150, v41);
        v152 = (int8x16_t)vcgtq_s32(v148, v41);
        v153 = vuzp1q_s32((int32x4_t)vsraq_n_s64((int64x2_t)vshrq_n_u64((uint64x2_t)v133, 0x10uLL), v109, 0x10uLL), (int32x4_t)vsraq_n_s64((int64x2_t)vshrq_n_u64(v144, 0x10uLL), v110, 0x10uLL));
        v154 = (int8x16_t)vcgtq_u32(v43, (uint32x4_t)vaddq_s32(v148, v42));
        v155 = (int8x16_t)vcgtq_u32(v43, (uint32x4_t)vaddq_s32(v150, v42));
        v156 = (uint32x4_t)vsubq_s32(v40, v148);
        v157 = (uint32x4_t)vsubq_s32(v40, v150);
        v158 = (uint32x4_t)vnegq_s32((int32x4_t)v156);
        v159 = vshlq_s32(v44, (int32x4_t)v158);
        v160 = (uint32x4_t)vnegq_s32((int32x4_t)v157);
        v161 = (int8x16_t)vshlq_u32(v45, v158);
        v162 = (int8x16_t)vshlq_u32(v45, v160);
        *v79++ = vshrn_high_n_s32(*(int16x4_t *)v84.i8, v142, 0xEuLL);
        *v80++ = vuzp1q_s16((int16x8_t)vbslq_s8(v151, vandq_s8((int8x16_t)vshlq_s32(v149, (int32x4_t)v157), v155), (int8x16_t)vshlq_u32((uint32x4_t)vbslq_s8((int8x16_t)vcgtq_s32(v149, (int32x4_t)v162), v162, (int8x16_t)vmaxq_s32(vshlq_s32(v44, (int32x4_t)v160), v149)), v157)), (int16x8_t)vbslq_s8(v152, vandq_s8((int8x16_t)vshlq_s32(v153, (int32x4_t)v156), v154), (int8x16_t)vshlq_u32((uint32x4_t)vbslq_s8((int8x16_t)vcgtq_s32(v153, (int32x4_t)v161), v161, (int8x16_t)vmaxq_s32(v159, v153)), v156)));
        v78 -= 8;
      }
      while (v78);
      v47 = v208;
      v52 = v205;
      v10 = v204;
      v46 = v209;
      v48 = v211;
      v49 = v207;
      v51 = v206;
      v50 = v210;
      if (v205 != v208)
        goto LABEL_85;
LABEL_100:
      v182 = 0;
      v183 = *((_QWORD *)v10 + 4);
      v184 = (unsigned __int8 *)(*((_QWORD *)v10 + 5) + (int)v46 * v48 / 2);
      v185 = v47 - 1;
      do
      {
        v186 = *v184++;
        v187 = &v220[0].i16[v182 + 2];
        *v187 = (v186 >> 1) & 7 | (8 * ((v186 >> 1) & 7));
        v188 = &v221[v182];
        *v188 = *(_BYTE *)(v183 + (((int)(v186 << 31) >> 31) & v185) + (int)v182);
        v187[1] = (v186 >> 5) | (8 * (v186 >> 5));
        v188[1] = *(_BYTE *)(v183 + (v185 & ((int)(v186 << 27) >> 31)) + (int)v182 + 1);
        v182 += 2;
      }
      while (v182 < (int)v47);
LABEL_102:
      v189 = v46;
      v190 = silk_NLSF_del_dec_quant(&v217[(16 * v38)], (uint64_t)v223, (uint64_t)v222, (uint64_t)v221, (uint64_t)v220[0].i64 + 4, *((_QWORD *)v10 + 7), v10[2], v10[3], v216, v48);
      v191 = (unsigned __int8 *)(*((_QWORD *)v10 + 3) + *v10 * (uint64_t)v214);
      if ((_DWORD)v189)
      {
        v192 = v191[v189 - 1];
        v191 += v189;
      }
      else
      {
        v192 = 256;
      }
      v193 = v192 - *v191;
      v194 = __clz(v193);
      v39.i64[0] = -1;
      v39.i64[1] = -1;
      v40.i64[0] = 0x700000007;
      v40.i64[1] = 0x700000007;
      v41.i64[0] = 0x800000008;
      v41.i64[1] = 0x800000008;
      v42.i64[0] = 0x1D0000001DLL;
      v42.i64[1] = 0x1D0000001DLL;
      v43.i64[0] = 0x3500000035;
      v43.i64[1] = 0x3500000035;
      v44.i64[0] = 0x8000000080000000;
      v44.i64[1] = 0x8000000080000000;
      v45.i64[0] = 0x8000000080000000;
      v45.i64[1] = 0x8000000080000000;
      if (v194 != 24)
      {
        v65 = v193 > 0x7F;
        v195 = (v193 << (v194 + 8)) | (v193 >> (24 - v194));
        v193 <<= v194 - 24;
        if (v65)
          LOBYTE(v193) = v195;
      }
      v219[v38++] = v190
                  + ((int)(0x4000000
                         - ((179 * (v193 & 0x7F) * (128 - (v193 & 0x7F))
                           - (v194 << 23)
                           + ((v193 & 0x7F) << 16)
                           + 260046848) & 0xFFFF0000)) >> 16)
                  * v213;
      if (v38 == v212)
        goto LABEL_109;
    }
    v50 = v210;
    v48 = v211;
    goto LABEL_85;
  }
LABEL_109:
  v196 = v219;
  silk_insertion_sort_increasing((uint64_t)v219, v220, v203, 1);
  v197 = v220[0].i32[0];
  v198 = v202;
  v199 = v202;
  *v202 = *(_DWORD *)&v218[4 * v220[0].i32[0]];
  memcpy(v199 + 1, &v217[16 * v197], v10[1]);
  silk_NLSF_decode(a2, v198, (uint64_t)v10);
  return *v196;
}

__int16 *silk_NLSF_stabilize(__int16 *result, int16x8_t *a2, int a3)
{
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  uint64_t i;
  __int16 v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int32x4_t v16;
  uint64_t v17;
  int16x8_t *v18;
  int32x4_t v19;
  int32x4_t v20;
  int32x4_t v21;
  int16x8_t v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  uint64_t v26;
  unint64_t v27;
  int v28;
  int64_t v29;
  int32x4_t v30;
  int16x8_t *v31;
  unint64_t v32;
  int32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int8x16_t v36;
  int16x8_t v37;
  int8x16_t v38;
  int16x8_t v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  __int16 *v44;
  int v45;
  int v46;
  int v47;
  __int16 v48;
  uint64_t j;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  uint64_t v55;
  int v56;
  __int16 *v57;
  int v58;
  __int16 *v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  int v65;

  v3 = 0;
  v4 = a3 - 1;
  while (1)
  {
    v5 = a2->i16[0];
    v6 = *result - v5;
    if (a3 < 2)
    {
      LODWORD(v7) = 0;
    }
    else
    {
      LODWORD(v7) = 0;
      v8 = *result;
      for (i = 1; i != a3; ++i)
      {
        v10 = result[i];
        v11 = v10 - (a2->i16[i] + v8);
        if (v11 < v6)
        {
          LODWORD(v7) = i;
          v6 = v11;
        }
        v8 = v10;
      }
    }
    v12 = a2->i16[a3];
    v13 = 0x8000 - (result[v4] + v12);
    if (v13 >= v6)
      v7 = v7;
    else
      v7 = a3;
    if (v13 < v6)
      v6 = 0x8000 - (result[v4] + v12);
    if ((v6 & 0x80000000) == 0)
      return result;
    if ((_DWORD)v7)
    {
      if ((_DWORD)v7 != a3)
      {
        if ((int)v7 < 1)
        {
          v15 = 0;
        }
        else
        {
          if (v7 < 0x10)
          {
            v14 = 0;
            v15 = 0;
            goto LABEL_27;
          }
          v14 = v7 & 0x7FFFFFF0;
          v16 = 0uLL;
          v17 = v7 & 0xFFFFFFF0;
          v18 = a2 + 1;
          v19 = 0uLL;
          v20 = 0uLL;
          v21 = 0uLL;
          do
          {
            v22 = v18[-1];
            v19 = vaddw_high_s16(v19, v22);
            v16 = vaddw_s16(v16, *(int16x4_t *)v22.i8);
            v21 = vaddw_high_s16(v21, *v18);
            v20 = vaddw_s16(v20, *(int16x4_t *)v18->i8);
            v18 += 2;
            v17 -= 16;
          }
          while (v17);
          v15 = vaddvq_s32(vaddq_s32(vaddq_s32(v20, v16), vaddq_s32(v21, v19)));
          if (v14 != v7)
          {
LABEL_27:
            v23 = v7 - v14;
            v24 = &a2->i16[v14];
            do
            {
              v25 = *v24++;
              v15 += v25;
              --v23;
            }
            while (v23);
          }
        }
        v26 = (int)v7;
        if ((int)v7 >= a3)
        {
          v28 = 0x8000;
        }
        else
        {
          v27 = a3 - (uint64_t)(int)v7;
          if (v27 < 0x10)
          {
            v28 = 0x8000;
            v29 = a3;
            goto LABEL_36;
          }
          v29 = a3 - (v27 & 0xFFFFFFFFFFFFFFF0);
          v30 = 0uLL;
          v31 = (int16x8_t *)((char *)a2 + 2 * a3 - 14);
          v32 = v27 & 0xFFFFFFFFFFFFFFF0;
          v33 = (int32x4_t)xmmword_208F38240;
          v34 = 0uLL;
          v35 = 0uLL;
          do
          {
            v36 = (int8x16_t)vrev64q_s16(*v31);
            v37 = (int16x8_t)vextq_s8(v36, v36, 8uLL);
            v38 = (int8x16_t)vrev64q_s16(v31[-1]);
            v39 = (int16x8_t)vextq_s8(v38, v38, 8uLL);
            v30 = vsubw_high_s16(v30, v37);
            v33 = vsubw_s16(v33, *(int16x4_t *)v37.i8);
            v35 = vsubw_high_s16(v35, v39);
            v34 = vsubw_s16(v34, *(int16x4_t *)v39.i8);
            v31 -= 2;
            v32 -= 16;
          }
          while (v32);
          v28 = vaddvq_s32(vaddq_s32(vaddq_s32(v34, v33), vaddq_s32(v35, v30)));
          if (v27 != (v27 & 0xFFFFFFFFFFFFFFF0))
          {
            do
LABEL_36:
              v28 -= a2->i16[v29--];
            while (v29 > (int)v7);
          }
        }
        v40 = a2->i16[(int)v7] >> 1;
        v41 = v15 + v40;
        v42 = v28 - v40;
        v43 = v26;
        v44 = &result[v43];
        v45 = result[v43] + result[v43 - 1];
        v46 = (v45 & 1) + (v45 >> 1);
        if (v41 <= v28 - v40)
          v47 = v28 - v40;
        else
          v47 = v41;
        if (v41 >= v42)
          v41 = v42;
        if (v46 > v41)
          LOWORD(v41) = v46;
        if (v46 > v47)
          LOWORD(v41) = v47;
        v48 = v41 - v40;
        *(v44 - 1) = v48;
        *v44 = v48 + a2->i16[v43];
        goto LABEL_3;
      }
      result[v4] = 0x8000 - v12;
    }
    else
    {
      *result = v5;
    }
LABEL_3:
    if (++v3 == 20)
    {
      if (a3 < 2)
      {
        v54 = *result;
        if (v54 <= a2->i16[0])
          LOWORD(v54) = a2->i16[0];
        *result = v54;
        v55 = v4;
        v56 = 0x8000 - a2->i16[a3];
        if (result[v55] < v56)
          LOWORD(v56) = result[v55];
        result[v55] = v56;
      }
      else
      {
        for (j = 1; j != a3; ++j)
        {
          v50 = result[j];
          v51 = j;
          while (1)
          {
            v52 = v51 - 1;
            v53 = result[(v51 - 1)];
            if (v50 >= v53)
              break;
            result[v51--] = v53;
            if (v52 + 1 <= 1)
            {
              LODWORD(v51) = 0;
              break;
            }
          }
          result[(int)v51] = v50;
        }
        v57 = &a2->i16[1];
        v58 = a2->i16[0];
        if (*result > v58)
          LOWORD(v58) = *result;
        *result = v58;
        v59 = result + 1;
        v60 = a3 - 1;
        do
        {
          v61 = *v57++;
          v58 = v61 + (__int16)v58;
          if (v58 >= 0x7FFF)
            v58 = 0x7FFF;
          if (v58 <= -32768)
            v58 = -32768;
          if (*v59 > v58)
            LOWORD(v58) = *v59;
          *v59++ = v58;
          --v60;
        }
        while (v60);
        v62 = v4;
        v63 = 0x8000 - a2->i16[a3];
        if (result[v62] < v63)
          LOWORD(v63) = result[v62];
        result[v62] = v63;
        v64 = (a3 - 2);
        LOWORD(v65) = result[v64 + 1];
        do
        {
          v65 = (__int16)v65 - a2->i16[v64 + 1];
          if (result[v64] < v65)
            LOWORD(v65) = result[v64];
          result[v64--] = v65;
        }
        while (v64 != -1);
      }
      return result;
    }
  }
}

void silk_noise_shape_analysis_FLP(int *a1, float *a2, uint64_t a3, uint64_t a4)
{
  float *v6;
  int *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  long double v13;
  float32x4_t v14;
  int32x2_t v15;
  float v16;
  int v17;
  float v18;
  int v19;
  float v20;
  float v21;
  float v22;
  float v23;
  int v24;
  int v25;
  int v26;
  int v27;
  unint64_t v28;
  double v29;
  float v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  int v35;
  uint64_t v36;
  int v37;
  unint64_t v38;
  float v39;
  float v40;
  double v41;
  unsigned int v42;
  float v43;
  uint64_t v44;
  uint64_t v45;
  const float *v46;
  uint64_t v47;
  const float *v48;
  float64x2_t v49;
  float64x2_t v50;
  float64x2_t v51;
  float64x2_t v52;
  float64x2_t v53;
  float64x2_t v54;
  float64x2_t v55;
  float64x2_t v56;
  float64x2_t v57;
  float64x2_t v58;
  float *v59;
  double v60;
  float v61;
  float v62;
  uint64_t v63;
  float32x2_t *v64;
  float32x2_t v65;
  float64x2_t v66;
  float64x2_t v67;
  float v68;
  float v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  float v73;
  uint64_t v74;
  double v75;
  signed int v76;
  uint64_t v77;
  const float *v78;
  const float *v79;
  float64x2_t v80;
  float64x2_t v81;
  float64x2_t v82;
  float64x2_t v83;
  float64x2_t v84;
  float64x2_t v85;
  float64x2_t v86;
  float64x2_t v87;
  float64x2_t v88;
  float64x2_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  float v94;
  unint64_t v95;
  float *v96;
  float v97;
  float *v98;
  float v99;
  float v100;
  float v101;
  float v102;
  uint64_t v103;
  float64x2_t v104;
  unint64_t v105;
  float *v106;
  float *v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  unint64_t v113;
  uint64_t v114;
  float v115;
  float v116;
  float32x4_t v117;
  float32x4_t v118;
  char *v119;
  uint64_t v120;
  double v121;
  uint64_t v122;
  double v123;
  uint64_t v124;
  double *v125;
  double v126;
  double v127;
  double v128;
  double *v129;
  double v130;
  double v131;
  uint64_t v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  unsigned int v139;
  float v140;
  uint64_t v141;
  uint64_t v142;
  int v143;
  uint64_t v144;
  double v145;
  unsigned int v146;
  unint64_t v147;
  unint64_t v148;
  const float *v149;
  const float *v150;
  const float *v151;
  const float *v152;
  float32x2_t v153;
  float32x2_t v154;
  float32x2_t v155;
  float64x2_t v156;
  float64x2_t v157;
  uint64_t v158;
  float *v159;
  unint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  float32x4_t *v167;
  float32x4_t v168;
  float64x2_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float64x2_t v172;
  float64x2_t v173;
  float64x2_t v174;
  float *v175;
  uint64_t v176;
  float32x4_t *v177;
  float64x2_t *v178;
  float64x2_t v179;
  float64x2_t v180;
  float64x2_t v181;
  uint64_t v182;
  float *v183;
  double *v184;
  double v185;
  float v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  float32x2_t *v191;
  double *v192;
  float32x4_t v193;
  float32x4_t v194;
  float64x2_t v195;
  double *v196;
  double *v197;
  double *v198;
  double *v199;
  uint64_t v200;
  int64x2_t *v201;
  float *v202;
  float v203;
  uint64_t v204;
  unint64_t v205;
  uint64_t v206;
  float *v207;
  float *v208;
  unsigned int v209;
  unint64_t v210;
  double v211;
  float v212;
  float64_t *v213;
  uint64_t v214;
  double v215;
  uint64_t v216;
  double v217;
  float *v218;
  unint64_t v219;
  uint64_t v220;
  float v221;
  float *v222;
  float *v223;
  float v224;
  float v225;
  float v226;
  float v227;
  uint64_t v228;
  float *v229;
  float v230;
  uint64_t v231;
  float *v232;
  uint64_t v233;
  float v234;
  float v235;
  unint64_t v236;
  unint64_t v237;
  int v238;
  int v239;
  uint64_t v240;
  int v241;
  float v242;
  float v243;
  float v244;
  float v245;
  float *v246;
  uint64_t v247;
  float v248;
  unint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  double v253;
  float *v254;
  uint64_t v255;
  float v256;
  uint64_t v257;
  float v258;
  float v259;
  float v260;
  float v261;
  float v262;
  float *v263;
  uint64_t v264;
  float v265;
  int32x4_t *v266;
  uint64_t v267;
  unint64_t v268;
  int8x16_t v269;
  int8x16_t v270;
  float *v271;
  int8x16_t v272;
  int8x16_t v273;
  int8x16_t v274;
  int8x16_t v275;
  uint64_t v276;
  float v277;
  float v278;
  float v279;
  float v280;
  float v281;
  float *v282;
  uint64_t v283;
  float v284;
  uint64_t v285;
  float v286;
  float v287;
  float v288;
  float v289;
  float v290;
  float *v291;
  uint64_t v292;
  float v293;
  float v294;
  float v295;
  uint64_t v296;
  float32x4_t *v297;
  uint64_t v298;
  unint64_t v299;
  float *v300;
  int v301;
  int v302;
  _BOOL8 v303;
  unint64_t v304;
  uint64_t v305;
  float *v306;
  uint64_t v307;
  float *v308;
  unint64_t v309;
  float *v310;
  float *v311;
  unint64_t v312;
  unint64_t v313;
  uint64_t v314;
  uint64_t v315;
  unint64_t v316;
  float *v318;
  float *v319;
  BOOL v320;
  char v322;
  char v324;
  int32x4_t *v325;
  uint64_t v326;
  float v327;
  float v328;
  uint64_t v329;
  unint64_t v330;
  int8x16_t *v331;
  int8x16_t v332;
  float32x4_t v333;
  float32x4_t v334;
  unint64_t v335;
  float *v336;
  float v337;
  float v338;
  uint64_t v339;
  uint64_t v340;
  float32x4_t *v341;
  float32x4_t v342;
  uint64_t v343;
  float *v344;
  float v345;
  float *v346;
  uint64_t v347;
  float v348;
  char v349;
  char v350;
  uint64_t v351;
  uint64_t v352;
  int32x4_t *v353;
  unint64_t v354;
  int8x16_t v355;
  int8x16_t v356;
  float *v357;
  int8x16_t v358;
  int8x16_t v359;
  int8x16_t v360;
  int8x16_t v361;
  float v362;
  uint64_t v363;
  uint64_t v364;
  float32x4_t *v365;
  uint64_t v366;
  float *v367;
  uint64_t v368;
  float v369;
  float v370;
  float v371;
  float v372;
  float v373;
  float *v374;
  uint64_t v375;
  float v376;
  uint64_t v377;
  float v378;
  float v379;
  float v380;
  float v381;
  float v382;
  float *v383;
  uint64_t v384;
  float v385;
  uint64_t v386;
  float v387;
  float v388;
  float v389;
  float v390;
  float v391;
  float *v392;
  uint64_t v393;
  float v394;
  uint64_t v395;
  float v396;
  float v397;
  float v398;
  float v399;
  float v400;
  float *v401;
  uint64_t v402;
  float v403;
  uint64_t v404;
  float v405;
  float v406;
  float v407;
  float v408;
  float v409;
  float *v410;
  uint64_t v411;
  float v412;
  uint64_t v413;
  float v414;
  float v415;
  float v416;
  float v417;
  float v418;
  uint64_t v419;
  float32x4_t *v420;
  float32x4_t v421;
  uint64_t v422;
  float32x4_t v423;
  uint64_t v424;
  float *v425;
  float v426;
  uint64_t v427;
  float v428;
  uint64_t v429;
  float *v430;
  float v431;
  float v432;
  float32x4_t v433;
  float32x4_t v434;
  uint64_t v440;
  float *v441;
  float32x4_t v442;
  uint64_t v443;
  float *v444;
  float v445;
  uint64_t v446;
  float *v447;
  float v448;
  float v449;
  float v450;
  int v451;
  int v452;
  int v453;
  unsigned int v454;
  uint64_t v455;
  float *v456;
  float *v457;
  int v458;
  uint64_t __n;
  _BYTE *v460;
  uint64_t v461;
  int v462;
  int v463;
  uint64_t v464;
  float32x4_t *v465;
  int *v466;
  uint64_t v467;
  int v468;
  uint64_t v469;
  uint64_t v470;
  int32x4_t v471;
  uint64_t v472;
  int32x4_t v473;
  float v474;
  float v475;
  uint64_t v476;
  int v477;
  uint64_t v478;
  float v479[25];
  float v480[4];
  _BYTE v481[84];
  _BYTE v482[8];
  _BYTE v483[952];
  double v484[4];
  _BYTE v485[160];
  uint64_t v486;
  __int128 v487;
  _BYTE v488[48];
  _BYTE v489[128];
  uint64_t v490;
  uint64_t v491;
  float64x2x2_t v492;
  float64x2x2_t v493;
  float64x2x2_t v494;
  float32x2x4_t v495;
  float32x2x4_t v496;
  float32x2x4_t v497;
  float32x2x4_t v498;
  float32x2x4_t v499;
  float32x2x4_t v500;
  float32x2x4_t v501;

  v6 = a2;
  v7 = a1;
  v491 = *MEMORY[0x24BDAC8D0];
  v8 = (unsigned __int8 *)a1 + 4781;
  v9 = a1[1150];
  v10 = (float)a1[1183];
  v11 = v10 * 0.0078125;
  v451 = a1[1178];
  v12 = (float)((float)(a1[1179] + v451) * 0.5) * 0.000030518;
  a2[174] = v12;
  v13 = 1.0 / (exp((float)((float)((float)(v10 * 0.0078125) + -20.0) * -0.25)) + 1.0);
  v16 = v13;
  v6[175] = v16;
  if (v7[1169])
  {
    v17 = *v8;
    v465 = (float32x4_t *)v6;
    v466 = v7;
    v452 = v17;
    if (v17 == 2)
      goto LABEL_3;
LABEL_6:
    v22 = (float)((float)(v10 * -0.4) * 0.0078125) + 6.0;
    v23 = 1.0 - v12;
    v24 = v7[1145];
    v453 = v24;
    v472 = a4;
    v470 = v9;
    v468 = 5 * (__int16)v24 / 2;
    if (v24 << 16 < 1)
    {
      v30 = 0.0;
LABEL_14:
      v18 = v11 + (float)(v22 * v23);
      v17 = v452;
      v8[1] = v30 <= (float)((float)(v468 - 1) * 0.6);
      v6 = (float *)v465;
      v7 = v466;
      v19 = v453;
      a4 = v472;
      v9 = v470;
      v20 = 1.0;
      if (v453 < 1)
        goto LABEL_337;
      goto LABEL_18;
    }
    v25 = v7[1144];
    v26 = 2 * v25;
    if (5 * (__int16)v24 / 2 <= 1)
      v27 = 1;
    else
      v27 = 5 * (__int16)v24 / 2;
    v477 = v27;
    if (v25 < 2)
    {
      v42 = 0;
      v29 = 0.0;
      v43 = (float)v26;
      v44 = v26;
      if (v26 > 0)
        goto LABEL_29;
      goto LABEL_31;
    }
    if ((v26 - 4) >= 0xC)
    {
      v45 = ((v26 - 4) >> 2) + 1;
      v28 = 4 * (v45 & 0x7FFFFFFC);
      v46 = (const float *)(a3 + 32);
      v29 = 0.0;
      v47 = v45 & 0x7FFFFFFC;
      do
      {
        v48 = v46 - 8;
        v495 = vld4_f32(v48);
        v497 = vld4_f32(v46);
        v49 = vcvtq_f64_f32(v495.val[0]);
        v50 = vcvtq_f64_f32(v497.val[0]);
        v51 = vcvtq_f64_f32(v495.val[1]);
        v52 = vcvtq_f64_f32(v497.val[1]);
        v53 = vmlaq_f64(vmulq_f64(v51, v51), v49, v49);
        v54 = vmlaq_f64(vmulq_f64(v52, v52), v50, v50);
        v55 = vcvtq_f64_f32(v495.val[2]);
        v56 = vcvtq_f64_f32(v497.val[2]);
        *(float64x2_t *)v495.val[0].f32 = vcvtq_f64_f32(v495.val[3]);
        *(float64x2_t *)v495.val[1].f32 = vcvtq_f64_f32(v497.val[3]);
        v57 = vmlaq_f64(vmlaq_f64(v53, v55, v55), *(float64x2_t *)v495.val[0].f32, *(float64x2_t *)v495.val[0].f32);
        v58 = vmlaq_f64(vmlaq_f64(v54, v56, v56), *(float64x2_t *)v495.val[1].f32, *(float64x2_t *)v495.val[1].f32);
        v29 = v29 + v57.f64[0] + v57.f64[1] + v58.f64[0] + v58.f64[1];
        v46 += 16;
        v47 -= 4;
      }
      while (v47);
      if ((v45 & 0x7FFFFFFC) == v45)
      {
LABEL_28:
        v42 = v26 & 0xFFFFFFFC;
        v43 = (float)v26;
        v44 = v26;
        if ((int)(v26 & 0xFFFFFFFC) < v26)
        {
LABEL_29:
          v63 = v26 - v42 - 2 + 2;
          v64 = (float32x2_t *)(a3 + 4 * v42);
          do
          {
            v65 = *v64++;
            v66 = vcvtq_f64_f32(v65);
            v67 = vmulq_f64(v66, v66);
            v29 = v29 + v67.f64[0] + v67.f64[1];
            v63 -= 2;
          }
          while (v63);
        }
LABEL_31:
        v68 = v29;
        v69 = log10((float)(v43 + v68)) * 3.32192809;
        v476 = ((v26 - 4) >> 2) + 1;
        v70 = 4 * v44;
        v71 = 4 * v44 + a3 + 32;
        v30 = 0.0;
        v72 = 1;
        while (1)
        {
          if (v25 < 2)
          {
            v76 = 0;
            v75 = 0.0;
          }
          else
          {
            if ((v26 - 4) >= 0xC)
            {
              v75 = 0.0;
              v77 = v476 & 0x7FFFFFFC;
              v78 = (const float *)v71;
              do
              {
                v79 = v78 - 8;
                v496 = vld4_f32(v79);
                v498 = vld4_f32(v78);
                v80 = vcvtq_f64_f32(v496.val[0]);
                v81 = vcvtq_f64_f32(v498.val[0]);
                v82 = vcvtq_f64_f32(v496.val[1]);
                v83 = vcvtq_f64_f32(v498.val[1]);
                v84 = vmlaq_f64(vmulq_f64(v82, v82), v80, v80);
                v85 = vmlaq_f64(vmulq_f64(v83, v83), v81, v81);
                v86 = vcvtq_f64_f32(v496.val[2]);
                v87 = vcvtq_f64_f32(v498.val[2]);
                *(float64x2_t *)v496.val[0].f32 = vcvtq_f64_f32(v496.val[3]);
                *(float64x2_t *)v496.val[1].f32 = vcvtq_f64_f32(v498.val[3]);
                v88 = vmlaq_f64(vmlaq_f64(v84, v86, v86), *(float64x2_t *)v496.val[0].f32, *(float64x2_t *)v496.val[0].f32);
                v89 = vmlaq_f64(vmlaq_f64(v85, v87, v87), *(float64x2_t *)v496.val[1].f32, *(float64x2_t *)v496.val[1].f32);
                v75 = v75 + v88.f64[0] + v88.f64[1] + v89.f64[0] + v89.f64[1];
                v78 += 16;
                v77 -= 4;
              }
              while (v77);
              v74 = 4 * (v476 & 0x7FFFFFFC);
              v76 = v26 & 0xFFFFFFFC;
              if ((v476 & 0x7FFFFFFC) == v476)
                goto LABEL_43;
            }
            else
            {
              v74 = 0;
              v75 = 0.0;
            }
            v90 = v74 + 3;
            v91 = v70 + 4 * v74;
            do
            {
              v75 = v75
                  + *(float *)(a3 + v91 + 4) * *(float *)(a3 + v91 + 4)
                  + *(float *)(a3 + v91) * *(float *)(a3 + v91)
                  + *(float *)(a3 + v91 + 8) * *(float *)(a3 + v91 + 8)
                  + *(float *)(a3 + v91 + 12) * *(float *)(a3 + v91 + 12);
              v92 = v90 + 1;
              v90 += 4;
              v91 += 16;
            }
            while (v92 < (v26 - 3));
            v76 = v26 & 0xFFFFFFFC;
          }
LABEL_43:
          if (v76 < v26)
          {
            v93 = v70 + 4 * v76;
            do
            {
              v75 = v75 + *(float *)(a3 + v93) * *(float *)(a3 + v93);
              ++v76;
              v93 += 4;
            }
            while (v26 > v76);
          }
          v73 = v75;
          v13 = log10((float)(v43 + v73)) * 3.32192809;
          *(float *)&v13 = v13;
          ++v72;
          v30 = v30 + vabds_f32(*(float *)&v13, v69);
          v71 += v70;
          a3 += v70;
          v69 = *(float *)&v13;
          if (v72 == v477)
            goto LABEL_14;
        }
      }
    }
    else
    {
      v28 = 0;
      v29 = 0.0;
    }
    v59 = (float *)(a3 + 4 * v28 + 8);
    do
    {
      v60 = *(v59 - 1) * *(v59 - 1) + *(v59 - 2) * *(v59 - 2);
      v61 = *v59;
      v62 = v59[1];
      v59 += 4;
      v29 = v29 + v60 + v61 * v61 + v62 * v62;
      v28 += 4;
    }
    while (v28 < (v26 - 3));
    goto LABEL_28;
  }
  v21 = (float)((float)v7[1133] * -0.0039062) + 1.0;
  v11 = v11 + (float)((float)((float)((float)((float)(v12 * 0.5) + 0.5) * (float)(v16 * -2.0)) * v21) * v21);
  v17 = *v8;
  v465 = (float32x4_t *)v6;
  v466 = v7;
  v452 = v17;
  if (v17 != 2)
    goto LABEL_6;
LABEL_3:
  v18 = v11 + (float)(*((float *)v7 + 2521) * 2.0);
  v8[1] = 0;
  v19 = v7[1145];
  v20 = 1.0;
  if (v19 < 1)
    goto LABEL_337;
LABEL_18:
  v450 = v18;
  v31 = 0;
  v32 = 0;
  v33 = a4 - 4 * v9;
  v34 = 0.94 / (float)(v20 + (float)((float)(v6[176] * 0.001) * (float)(v6[176] * 0.001)));
  v463 = v7[1168];
  v14.f32[0] = (float)((float)v463 * 0.000015259) + (float)(v16 * 0.01);
  v474 = -v14.f32[0];
  v475 = v14.f32[0];
  v35 = 3 * v7[1144];
  v36 = v7[1151];
  v37 = v36 - v35;
  v462 = v36 - v35;
  if ((int)v36 < v35)
    ++v37;
  v38 = (v37 >> 1);
  v39 = v20 - (float)(v14.f32[0] * v14.f32[0]);
  v461 = (uint64_t)v37 >> 1;
  v460 = &v482[4 * (int)v38];
  __n = 12 * v7[1144];
  v454 = v19;
  v464 = v19;
  v458 = v36 - 3;
  v455 = 4 * ((int)v38 + v35) + 8;
  v40 = 2.0 - (float)((float)(3.1416 / (float)((int)v38 + 1)) * (float)(3.1416 / (float)((int)v38 + 1)));
  v41 = v14.f32[0];
  v457 = v6 + 60;
  v456 = v6 + 61;
  v471 = vdupq_lane_s32(*(int32x2_t *)v14.f32, 0);
  *(float *)v15.i32 = -v14.f32[0];
  v473 = vdupq_lane_s32(v15, 0);
  do
  {
    v478 = v32;
    v469 = v33;
    if (v462 < 2)
    {
      memcpy(v460, (const void *)(v33 + 4 * v461), __n);
    }
    else
    {
      v95 = 0;
      v96 = (float *)(v33 + 8);
      v97 = 0.0;
      v98 = (float *)v483;
      v99 = 3.1416 / (float)((int)v38 + 1);
      do
      {
        v100 = v99 * *(v96 - 1);
        *(v98 - 2) = (float)(v99 + v97) * (float)(*(v96 - 2) * 0.5);
        *(v98 - 1) = v100;
        v97 = -(float)(v97 - (float)(v40 * v99));
        v101 = *v96;
        v102 = v96[1];
        v96 += 4;
        *v98 = (float)(v99 + v97) * (float)(v101 * 0.5);
        v98[1] = v97 * v102;
        v98 += 4;
        v99 = -(float)(v99 - (float)(v40 * v97));
        v95 += 4;
      }
      while (v95 < v38);
      v103 = v33;
      memcpy(v460, (const void *)(v33 + 4 * v461), __n);
      v105 = 0;
      v106 = (float *)&v482[v455];
      v107 = (float *)(v103 + v455);
      v108 = 1.0;
      v109 = v40 * 0.5;
      do
      {
        v110 = v109 * *(v107 - 1);
        *(v106 - 2) = (float)(v109 + v108) * (float)(*(v107 - 2) * 0.5);
        *(v106 - 1) = v110;
        v108 = -(float)(v108 - (float)(v40 * v109));
        v111 = *v107;
        v112 = v107[1];
        v107 += 4;
        *v106 = (float)(v109 + v108) * (float)(v111 * 0.5);
        v106[1] = v108 * v112;
        v106 += 4;
        v109 = -(float)(v109 - (float)(v40 * v108));
        v105 += 4;
      }
      while (v105 < v38);
    }
    v113 = v7[1159];
    v467 = v7[1147];
    if (v463 < 1)
    {
      if ((int)v113 + 1 < (int)v36)
        v135 = (v113 + 1);
      else
        v135 = v36;
      v114 = v478;
      v116 = v474;
      v115 = v475;
      v118 = (float32x4_t)v471;
      v117 = (float32x4_t)v473;
      v119 = &byte_208F31000;
      if ((int)v135 < 1)
        goto LABEL_103;
      v136 = 0;
      v137 = 0;
      v138 = v36 - 1;
      v139 = v36 - 3;
      while (1)
      {
        if (v139 <= 4uLL)
          v141 = 4;
        else
          v141 = v139;
        if ((v458 - v137) <= 4)
          v142 = 4;
        else
          v142 = (v458 - v137);
        v143 = v36 - v137;
        if ((int)v36 - (int)v137 < 4)
        {
          v146 = 0;
          v145 = 0.0;
          if (v143 <= 0)
            goto LABEL_72;
          goto LABEL_90;
        }
        if (v142 < 0xD)
          break;
        v147 = (((unint64_t)(v141 - 1) >> 2) + 1) & 0x7FFFFFFFFFFFFFFCLL;
        v148 = ((unint64_t)(v142 - 1) >> 2) + 1;
        v144 = 4 * (v148 & 0x7FFFFFFFFFFFFFFCLL);
        v145 = 0.0;
        v149 = (const float *)v482;
        do
        {
          v150 = v149 + 8;
          v151 = v149;
          *(float32x2x4_t *)((char *)&v104 - 8) = vld4_f32(v151);
          v152 = &v151[v136];
          v499 = vld4_f32(v150);
          v500 = vld4_f32(v152);
          v152 += 8;
          v501 = vld4_f32(v152);
          v156 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)&v104.f64[0]), vcvtq_f64_f32(v500.val[1])), vcvtq_f64_f32(v500.val[0]), vcvtq_f64_f32(v153)), vcvtq_f64_f32(v500.val[2]), vcvtq_f64_f32(v154)), vcvtq_f64_f32(v500.val[3]), vcvtq_f64_f32(v155));
          v157 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v499.val[1]), vcvtq_f64_f32(v501.val[1])), vcvtq_f64_f32(v501.val[0]), vcvtq_f64_f32(v499.val[0])), vcvtq_f64_f32(v501.val[2]), vcvtq_f64_f32(v499.val[2])), vcvtq_f64_f32(v501.val[3]), vcvtq_f64_f32(v499.val[3]));
          HIDWORD(v104.f64[0]) = HIDWORD(v157.f64[1]);
          v145 = v145 + v156.f64[0] + v156.f64[1] + v157.f64[0] + v157.f64[1];
          v149 += 16;
          v147 -= 4;
        }
        while (v147);
        v116 = v474;
        v115 = v475;
        v118 = (float32x4_t)v471;
        v117 = (float32x4_t)v473;
        if (v148 != (v148 & 0x7FFFFFFFFFFFFFFCLL))
          goto LABEL_87;
LABEL_89:
        v146 = v143 & 0xFFFFFFFC;
        if ((int)(v143 & 0xFFFFFFFC) >= v143)
          goto LABEL_72;
LABEL_90:
        v161 = v146;
        v162 = (_DWORD)v36 + ~(_DWORD)v137 - v146;
        if (v162 >= 7)
        {
          v164 = v162 + 1;
          v165 = (v162 + 1) & 0x1FFFFFFF8;
          v163 = v165 + v146;
          v166 = (v138 - v146 + 1) & 0x1FFFFFFF8;
          v167 = (float32x4_t *)&v482[4 * v161];
          do
          {
            v168 = v167[1];
            v169 = vcvtq_f64_f32(*(float32x2_t *)v168.f32);
            v170 = *(float32x4_t *)((char *)v167 + v136 * 4);
            v171 = *(float32x4_t *)((char *)v167 + v136 * 4 + 16);
            v172 = vmulq_f64(vcvt_hight_f64_f32(*v167), vcvt_hight_f64_f32(v170));
            v173 = vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v167->f32), vcvtq_f64_f32(*(float32x2_t *)v170.f32));
            v104 = vmulq_f64(vcvt_hight_f64_f32(v168), vcvt_hight_f64_f32(v171));
            v174 = vmulq_f64(v169, vcvtq_f64_f32(*(float32x2_t *)v171.f32));
            v145 = v145
                 + v173.f64[0]
                 + v173.f64[1]
                 + v172.f64[0]
                 + v172.f64[1]
                 + v174.f64[0]
                 + v174.f64[1]
                 + v104.f64[0]
                 + v104.f64[1];
            v167 += 2;
            v166 -= 8;
          }
          while (v166);
          if (v164 == v165)
            goto LABEL_72;
        }
        else
        {
          v163 = v146;
        }
        v175 = (float *)&v482[4 * v163];
        do
        {
          v104.f64[0] = v175[v136];
          v145 = v145 + *v175 * v104.f64[0];
          LODWORD(v163) = v163 + 1;
          ++v175;
        }
        while (v143 > (int)v163);
LABEL_72:
        v140 = v145;
        v480[v137++] = v140;
        ++v136;
        --v139;
        --v138;
        if (v137 == v135)
          goto LABEL_103;
      }
      v144 = 0;
      v145 = 0.0;
LABEL_87:
      v158 = v144 + 3;
      v159 = (float *)&v482[4 * v144];
      do
      {
        v104.f64[0] = v159[3];
        v145 = v145
             + v159[1] * v159[v136 + 1]
             + *v159 * v159[v136]
             + v159[2] * v159[v136 + 2]
             + v104.f64[0] * v159[v136 + 3];
        v160 = v158 + 1;
        v158 += 4;
        v159 += 4;
      }
      while (v160 < (v143 - 3));
      goto LABEL_89;
    }
    v490 = 0;
    memset(v489, 0, sizeof(v489));
    v487 = 0u;
    memset(v488, 0, sizeof(v488));
    v486 = 0;
    memset(v485, 0, sizeof(v485));
    memset(v484, 0, sizeof(v484));
    v114 = v478;
    v116 = v474;
    v115 = v475;
    v118 = (float32x4_t)v471;
    v117 = (float32x4_t)v473;
    v119 = &byte_208F31000;
    if ((int)v36 >= 1)
    {
      if ((int)v113 < 1)
      {
        v253 = v484[(int)v113];
        v254 = (float *)v482;
        v255 = v36;
        do
        {
          v256 = *v254++;
          *(double *)&v488[8 * (int)v113 - 16] = v256;
          HIDWORD(v104.f64[0]) = DWORD1(v487);
          v253 = v253 + *(double *)&v487 * v256;
          --v255;
        }
        while (v255);
        v484[(int)v113] = v253;
        if ((v113 & 0x80000000) != 0)
          goto LABEL_103;
        goto LABEL_65;
      }
      v120 = 0;
      v121 = 0.0;
      do
      {
        v122 = 0;
        v123 = *(float *)&v482[4 * v120];
        v124 = 8;
        do
        {
          v125 = (double *)&v488[v124 - 16];
          v126 = *(double *)&v488[v124 - 16];
          v127 = v121 + v41 * (v126 - v123);
          *(v125 - 1) = v123;
          v128 = *(double *)&v487;
          v129 = &v484[(unint64_t)v124 / 8];
          v130 = *(double *)&v483[v124 + 944] + *(double *)&v487 * v123;
          v122 += 2;
          v121 = *(double *)&v488[v124 - 8];
          v123 = v126 + v41 * (v121 - v127);
          *v125 = v127;
          v131 = v484[(unint64_t)v124 / 8] + v128 * v127;
          *(v129 - 1) = v130;
          *v129 = v131;
          v124 += 16;
        }
        while (v122 < (int)v113);
        v132 = (int)v113;
        *(double *)&v488[v132 * 8 - 16] = v123;
        v104.f64[0] = v484[v132];
        v121 = *(double *)&v487;
        v484[v132] = v104.f64[0] + *(double *)&v487 * v123;
        ++v120;
      }
      while (v120 != v36);
    }
    if ((v113 & 0x80000000) != 0)
      goto LABEL_103;
LABEL_65:
    v133 = v113 + 1;
    if (v113 < 7)
    {
      v134 = 0;
LABEL_101:
      v182 = v133 - v134;
      v183 = &v480[v134];
      v184 = &v484[v134];
      do
      {
        v185 = *v184++;
        v186 = v185;
        *v183++ = v186;
        --v182;
      }
      while (v182);
      goto LABEL_103;
    }
    v134 = v133 & 0xFFFFFFF8;
    v176 = v134;
    v177 = (float32x4_t *)v481;
    v178 = (float64x2_t *)v485;
    do
    {
      v180 = v178[-2];
      v179 = v178[-1];
      v181 = *v178;
      v104 = v178[1];
      v178 += 4;
      v177[-1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v180), v179);
      *v177 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v181), v104);
      v177 += 2;
      v176 -= 8;
    }
    while (v176);
    if (v134 != v133)
      goto LABEL_101;
LABEL_103:
    v480[0] = v480[0] + (float)(v20 + (float)(v480[0] * 0.00003));
    v187 = v113 & ~((int)v113 >> 31);
    if (v187 < 7)
    {
      v188 = 0;
LABEL_108:
      v200 = v187 - v188 + 1;
      v201 = (int64x2_t *)&v488[16 * v188 - 16];
      v202 = &v480[v188];
      do
      {
        v203 = *v202++;
        *v201++ = vdupq_lane_s64(COERCE__INT64(v203), 0);
        --v200;
      }
      while (v200);
      goto LABEL_110;
    }
    v189 = (v187 + 1);
    v188 = v189 & 0xFFFFFFF8;
    v190 = v188;
    v191 = (float32x2_t *)v481;
    v192 = (double *)v489;
    do
    {
      v193 = *(float32x4_t *)v191[-2].f32;
      v194 = *(float32x4_t *)v191->f32;
      v104 = vcvt_hight_f64_f32(v193);
      v195 = v104;
      v493.val[0] = vcvtq_f64_f32(*(float32x2_t *)v193.f32);
      v493.val[1] = v493.val[0];
      v494.val[0] = vcvtq_f64_f32(*v191);
      v196 = v192 - 8;
      vst2q_f64(v196, v493);
      v494.val[1] = v494.val[0];
      v197 = v192 - 4;
      vst2q_f64(v197, *(float64x2x2_t *)v104.f64);
      v198 = v192 + 16;
      vst2q_f64(v192, v494);
      v199 = v192 + 4;
      v492.val[0] = vcvt_hight_f64_f32(v194);
      v492.val[1] = v492.val[0];
      vst2q_f64(v199, v492);
      v191 += 4;
      v192 = v198;
      v190 -= 8;
    }
    while (v190);
    if (v188 != v189)
      goto LABEL_108;
LABEL_110:
    if ((int)v113 <= 0)
    {
      v217 = *((double *)&v487 + 1);
      v218 = &v6[(24 * v114) + 61];
    }
    else
    {
      v204 = 0;
      v205 = 0;
      v206 = 8 * (v31 & 0x1FFFFFFF);
      v207 = &v457[v206];
      v208 = &v456[v206];
      v209 = v113;
      do
      {
        v210 = v205++;
        v104.f64[0] = *((float64_t *)v119 + 313);
        v211 = -*(double *)&v488[16 * v205 - 16] / fmax(*((double *)&v487 + 1), v104.f64[0]);
        v212 = v211;
        v479[v210] = v212;
        if (v210 < v113)
        {
          v213 = (float64_t *)v488;
          v214 = v209;
          do
          {
            v215 = v213[v204];
            v104.f64[0] = *(v213 - 1);
            v213[v204] = v215 + v104.f64[0] * v211;
            *(v213 - 1) = v104.f64[0] + v215 * v211;
            v213 += 2;
            --v214;
          }
          while (v214);
        }
        --v209;
        v204 += 2;
      }
      while (v205 != v113);
      v216 = 0;
      v217 = *((double *)&v487 + 1);
      v218 = &v6[(24 * v114) + 61];
      v219 = 1;
      do
      {
        v220 = v219 >> 1;
        if (v219 >> 1 <= 1)
          v220 = 1;
        v221 = v479[v216];
        if (v216)
        {
          v222 = v208;
          v223 = v207;
          do
          {
            v224 = *v222;
            v225 = *v223;
            *v222 = *v222 + (float)(*v223 * v221);
            ++v222;
            *v223-- = v225 + (float)(v224 * v221);
            --v220;
          }
          while (v220);
        }
        v218[v216] = -v221;
        ++v219;
        ++v207;
        ++v216;
      }
      while (v216 != v113);
    }
    v226 = v217;
    v227 = sqrtf(v226);
    v6[v114] = v227;
    v228 = (v113 - 1);
    if (v463 < 1)
    {
      if ((int)v113 <= 1)
      {
        v239 = 0;
        v229 = &v218[(int)v228];
        v235 = v34 * *v229;
        *v229 = v235;
        if ((int)v113 < 1)
          goto LABEL_49;
        goto LABEL_142;
      }
LABEL_132:
      v232 = v218;
      v233 = (v113 - 1);
      v234 = v34;
      do
      {
        *v232 = v234 * *v232;
        ++v232;
        v234 = v34 * v234;
        --v233;
      }
      while (v233);
      v229 = &v218[(int)v228];
      v235 = v234 * *v229;
      *v229 = v235;
      if (v463 >= 1)
      {
        v236 = (v113 - 1) - (unint64_t)((_DWORD)v113 != 1) + 1;
        if (v236 >= 0x28)
        {
          v249 = (v113 - 1) - (unint64_t)((_DWORD)v113 != 1);
          v250 = v228;
          if (&v218[v228 - v249] > &v218[v228])
          {
            v237 = (v113 - 1);
          }
          else if (&v218[(v113 - 2) - v249] > &v218[(v113 - 2)])
          {
            v237 = (v113 - 1);
          }
          else if ((int)v113 - 2 < v249)
          {
            v237 = (v113 - 1);
          }
          else if (HIDWORD(v249))
          {
            v237 = (v113 - 1);
          }
          else
          {
            v251 = (_DWORD)v113 != 1;
            v252 = (v113 - 2);
            if ((float *)((char *)v218 + v251 * 4 + v252 * 4 - v250 * 4) >= &v218[v250 + 1]
              || &v218[v251] >= &v218[v252 + 1])
            {
              v237 = v228 - (v236 & 0xFFFFFFFFFFFFFFF8);
              v266 = (int32x4_t *)&v218[v250 - 3];
              v267 = v228 + 0xFFFFFFFFLL;
              v268 = v236 & 0xFFFFFFFFFFFFFFF8;
              do
              {
                v269 = (int8x16_t)vrev64q_s32(*v266);
                v270 = (int8x16_t)vrev64q_s32(v266[-1]);
                v271 = &v218[v267];
                v272 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v271 - 3));
                v273 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v271 - 7));
                v104 = (float64x2_t)vmlaq_f32((float32x4_t)vextq_s8(v272, v272, 8uLL), (float32x4_t)vextq_s8(v269, v269, 8uLL), v117);
                v274 = (int8x16_t)vrev64q_s32((int32x4_t)v104);
                *(int8x16_t *)(v271 - 3) = vextq_s8(v274, v274, 8uLL);
                v275 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_f32((float32x4_t)vextq_s8(v273, v273, 8uLL), (float32x4_t)vextq_s8(v270, v270, 8uLL), v117));
                *(int8x16_t *)(v271 - 7) = vextq_s8(v275, v275, 8uLL);
                v266 -= 2;
                v267 -= 8;
                v268 -= 8;
              }
              while (v268);
              if (v236 == (v236 & 0xFFFFFFFFFFFFFFF8))
                goto LABEL_201;
            }
            else
            {
              v237 = (v113 - 1);
            }
          }
        }
        else
        {
          v237 = (v113 - 1);
        }
        do
        {
          v294 = v218[v237];
          v320 = v237-- > 1;
          v218[v237] = v218[v237] + (float)(v116 * v294);
        }
        while (v320);
LABEL_201:
        v238 = 1;
LABEL_202:
        v295 = v39 / (float)(v20 + (float)(v115 * *v218));
        if (v113 >= 8)
        {
          v296 = v113 & 0x7FFFFFF8;
          v297 = (float32x4_t *)(v218 + 4);
          v298 = v113 & 0xFFFFFFF8;
          do
          {
            v104 = (float64x2_t)vmulq_n_f32(*v297, v295);
            v297[-1] = vmulq_n_f32(v297[-1], v295);
            *v297 = (float32x4_t)v104;
            v297 += 2;
            v298 -= 8;
          }
          while (v298);
          if (v296 == v113)
          {
LABEL_209:
            v301 = 0;
            v302 = 0;
            v303 = (_DWORD)v113 != 1;
            v304 = v228 - v303;
            v305 = (v113 - 2);
            v306 = &v218[v305];
            v307 = (v113 - 1);
            v308 = &v218[v307];
            v309 = (unint64_t)v218 + 4 * v303 + v305 * 4 - v307 * 4;
            v310 = &v218[v305 + 1];
            v311 = &v218[v303];
            v312 = v113 - v303;
            v313 = (v113 - 1) & 0xFFFFFFFFFFFFFFF8;
            v314 = v113 & 0xFFFFFFF8;
            _CF = (int)v113 - 2 >= (v228 - v303);
            v315 = 4 * (v228 - v303);
            v316 = HIDWORD(v304);
            _ZF = _CF && v316 == 0;
            v318 = &v306[v315 / 0xFFFFFFFFFFFFFFFCLL];
            v319 = &v308[v315 / 0xFFFFFFFFFFFFFFFCLL];
            v320 = !_ZF || v318 > v306;
            v322 = v320 || v319 > v308;
            _CF = v309 >= (unint64_t)&v218[v307 + 1] || v311 >= v310;
            v324 = !_CF;
            v325 = (int32x4_t *)(v308 - 3);
            while (1)
            {
              v326 = 0;
              v327 = -1.0;
              do
              {
                v328 = fabsf(v218[v326]);
                if (v328 > v327)
                {
                  v301 = v326;
                  v327 = v328;
                }
                ++v326;
              }
              while (v113 != v326);
              if (v327 <= 3.999)
                goto LABEL_49;
              if (v238)
              {
                *(float *)v104.f64 = *v218;
                if (v113 < 9)
                {
                  v329 = 1;
                  goto LABEL_241;
                }
                v104 = (float64x2_t)vdupq_lane_s32(*(int32x2_t *)&v104.f64[0], 0);
                v330 = (v113 - 1) & 0xFFFFFFFFFFFFFFF8;
                v331 = (int8x16_t *)(v218 + 5);
                do
                {
                  v332 = v331[-1];
                  v333 = (float32x4_t)vextq_s8((int8x16_t)v104, v332, 0xCuLL);
                  v104 = *(float64x2_t *)v331;
                  v334 = vmlaq_f32((float32x4_t)vextq_s8(v332, *v331, 0xCuLL), *(float32x4_t *)v331, v118);
                  *(float32x4_t *)((char *)&v331[-2] + 12) = vmlaq_f32(v333, (float32x4_t)v332, v118);
                  *(float32x4_t *)((char *)v331 - 4) = v334;
                  v331 += 2;
                  v330 -= 8;
                }
                while (v330);
                if (v113 - 1 != v313)
                {
                  LODWORD(v104.f64[0]) = HIDWORD(v104.f64[1]);
                  v329 = v313 | 1;
LABEL_241:
                  v335 = v113 - v329;
                  v336 = &v218[v329];
                  do
                  {
                    v337 = *v336;
                    *(v336 - 1) = *(float *)v104.f64 + (float)(v115 * *v336);
                    ++v336;
                    *(float *)v104.f64 = v337;
                    --v335;
                  }
                  while (v335);
                }
              }
              v338 = v20 / v295;
              if (v113 < 8)
              {
                v339 = 0;
LABEL_248:
                v343 = v113 - v339;
                v344 = &v218[v339];
                do
                {
                  *v344 = v338 * *v344;
                  ++v344;
                  --v343;
                }
                while (v343);
                goto LABEL_250;
              }
              v340 = v113 & 0x7FFFFFF8;
              v341 = (float32x4_t *)(v218 + 4);
              do
              {
                v104 = (float64x2_t)vmulq_n_f32(v341[-1], v338);
                v342 = vmulq_n_f32(*v341, v338);
                v341[-1] = (float32x4_t)v104;
                *v341 = v342;
                v341 += 2;
                v340 -= 8;
              }
              while (v340);
              v339 = v113 & 0xFFFFFFF8;
              if (v314 != v113)
                goto LABEL_248;
LABEL_250:
              v345 = 0.99
                   - (float)((float)((float)((float)((float)v302 * 0.1) + 0.8) * (float)(v327 + -3.999))
                           / (float)(v327 * (float)(v301 + 1)));
              v346 = v218;
              v347 = (v113 - 1);
              v348 = v345;
              if (v238)
              {
                do
                {
                  *v346 = v348 * *v346;
                  ++v346;
                  v348 = v345 * v348;
                  --v347;
                }
                while (v347);
                *v229 = v348 * *v229;
                if (v312 < 0x18)
                  v349 = 1;
                else
                  v349 = v322;
                v350 = v349 | v324;
                v351 = (v113 - 1);
                if ((v350 & 1) != 0)
                  goto LABEL_260;
                v352 = v228 + 0xFFFFFFFFLL;
                v353 = v325;
                v354 = v312 & 0xFFFFFFFFFFFFFFF8;
                do
                {
                  v355 = (int8x16_t)vrev64q_s32(*v353);
                  v356 = (int8x16_t)vrev64q_s32(v353[-1]);
                  v357 = &v218[v352];
                  v358 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v357 - 3));
                  v359 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v357 - 7));
                  v104 = (float64x2_t)vmlaq_f32((float32x4_t)vextq_s8(v358, v358, 8uLL), (float32x4_t)vextq_s8(v355, v355, 8uLL), v117);
                  v360 = (int8x16_t)vrev64q_s32((int32x4_t)v104);
                  *(int8x16_t *)(v357 - 3) = vextq_s8(v360, v360, 8uLL);
                  v361 = (int8x16_t)vrev64q_s32((int32x4_t)vmlaq_f32((float32x4_t)vextq_s8(v359, v359, 8uLL), (float32x4_t)vextq_s8(v356, v356, 8uLL), v117));
                  *(int8x16_t *)(v357 - 7) = vextq_s8(v361, v361, 8uLL);
                  v353 -= 2;
                  v352 -= 8;
                  v354 -= 8;
                }
                while (v354);
                v351 = v228 - (v312 & 0xFFFFFFFFFFFFFFF8);
                if (v312 != (v312 & 0xFFFFFFFFFFFFFFF8))
                {
LABEL_260:
                  do
                  {
                    v362 = v218[v351];
                    v320 = v351-- <= 1;
                    v218[v351] = v218[v351] + (float)(v116 * v362);
                  }
                  while (!v320);
                }
                v295 = v39 / (float)(v20 + (float)(v115 * *v218));
                if (v113 >= 8)
                {
LABEL_264:
                  v364 = v113 & 0x7FFFFFF8;
                  v365 = (float32x4_t *)(v218 + 4);
                  do
                  {
                    v104 = (float64x2_t)vmulq_n_f32(*v365, v295);
                    v365[-1] = vmulq_n_f32(v365[-1], v295);
                    *v365 = (float32x4_t)v104;
                    v365 += 2;
                    v364 -= 8;
                  }
                  while (v364);
                  v363 = v113 & 0xFFFFFFF8;
                  if (v314 == v113)
                    goto LABEL_228;
                  goto LABEL_267;
                }
              }
              else
              {
                *v229 = v345 * *v229;
                v295 = v39 / (float)(v20 + (float)(v115 * *v218));
                if (v113 >= 8)
                  goto LABEL_264;
              }
              v363 = 0;
LABEL_267:
              v366 = v113 - v363;
              v367 = &v218[v363];
              do
              {
                *v367 = v295 * *v367;
                ++v367;
                --v366;
              }
              while (v366);
LABEL_228:
              if (++v302 == 10)
                goto LABEL_49;
            }
          }
        }
        else
        {
          v296 = 0;
        }
        v299 = v113 - v296;
        v300 = &v218[v296];
        do
        {
          *v300 = v295 * *v300;
          ++v300;
          --v299;
        }
        while (v299);
        goto LABEL_209;
      }
      v239 = 1;
LABEL_142:
      v240 = 0;
      v241 = 0;
      v242 = -1.0;
      do
      {
        v243 = fabsf(v218[v240]);
        if (v243 > v242)
        {
          v241 = v240;
          v242 = v243;
        }
        ++v240;
      }
      while (v113 != v240);
      if (v242 > 3.999)
      {
        v244 = (float)((float)(v242 + -3.999) * -0.8) / (float)(v242 * (float)(v241 + 1));
        v245 = v244 + 0.99;
        if (v239)
        {
          v246 = v218;
          v247 = (v113 - 1);
          v248 = v244 + 0.99;
          do
          {
            *v246 = v248 * *v246;
            ++v246;
            v248 = v245 * v248;
            --v247;
          }
          while (v247);
          v235 = *v229;
        }
        else
        {
          v248 = v244 + 0.99;
        }
        v257 = 0;
        v258 = v248 * v235;
        *v229 = v258;
        v259 = -1.0;
        do
        {
          v260 = fabsf(v218[v257]);
          if (v260 > v259)
          {
            v241 = v257;
            v259 = v260;
          }
          ++v257;
        }
        while (v113 != v257);
        if (v259 > 3.999)
        {
          v261 = (float)((float)(v259 + -3.999) * -0.9) / (float)(v259 * (float)(v241 + 1));
          v262 = v261 + 0.99;
          if (v239)
          {
            v263 = v218;
            v264 = (v113 - 1);
            v265 = v261 + 0.99;
            do
            {
              *v263 = v265 * *v263;
              ++v263;
              v265 = v262 * v265;
              --v264;
            }
            while (v264);
            v258 = *v229;
          }
          else
          {
            v265 = v261 + 0.99;
          }
          v276 = 0;
          v277 = v265 * v258;
          *v229 = v277;
          v278 = -1.0;
          do
          {
            v279 = fabsf(v218[v276]);
            if (v279 > v278)
            {
              v241 = v276;
              v278 = v279;
            }
            ++v276;
          }
          while (v113 != v276);
          if (v278 > 3.999)
          {
            v280 = (float)(v278 + -3.999) / (float)(v278 * (float)(v241 + 1));
            v281 = 0.99 - v280;
            if (v239)
            {
              v282 = v218;
              v283 = (v113 - 1);
              v284 = 0.99 - v280;
              do
              {
                *v282 = v284 * *v282;
                ++v282;
                v284 = v281 * v284;
                --v283;
              }
              while (v283);
              v277 = *v229;
            }
            else
            {
              v284 = 0.99 - v280;
            }
            v285 = 0;
            v286 = v284 * v277;
            *v229 = v286;
            v287 = -1.0;
            do
            {
              v288 = fabsf(v218[v285]);
              if (v288 > v287)
              {
                v241 = v285;
                v287 = v288;
              }
              ++v285;
            }
            while (v113 != v285);
            if (v287 > 3.999)
            {
              v289 = (float)((float)(v287 + -3.999) * -1.1) / (float)(v287 * (float)(v241 + 1));
              v290 = v289 + 0.99;
              if (v239)
              {
                v291 = v218;
                v292 = (v113 - 1);
                v293 = v289 + 0.99;
                do
                {
                  *v291 = v293 * *v291;
                  ++v291;
                  v293 = v290 * v293;
                  --v292;
                }
                while (v292);
                v286 = *v229;
              }
              else
              {
                v293 = v289 + 0.99;
              }
              v368 = 0;
              v369 = v293 * v286;
              *v229 = v369;
              v370 = -1.0;
              do
              {
                v371 = fabsf(v218[v368]);
                if (v371 > v370)
                {
                  v241 = v368;
                  v370 = v371;
                }
                ++v368;
              }
              while (v113 != v368);
              if (v370 > 3.999)
              {
                v372 = (float)((float)(v370 + -3.999) * -1.2) / (float)(v370 * (float)(v241 + 1));
                v373 = v372 + 0.99;
                if (v239)
                {
                  v374 = v218;
                  v375 = (v113 - 1);
                  v376 = v372 + 0.99;
                  do
                  {
                    *v374 = v376 * *v374;
                    ++v374;
                    v376 = v373 * v376;
                    --v375;
                  }
                  while (v375);
                  v369 = *v229;
                }
                else
                {
                  v376 = v372 + 0.99;
                }
                v377 = 0;
                v378 = v376 * v369;
                *v229 = v378;
                v379 = -1.0;
                do
                {
                  v380 = fabsf(v218[v377]);
                  if (v380 > v379)
                  {
                    v241 = v377;
                    v379 = v380;
                  }
                  ++v377;
                }
                while (v113 != v377);
                if (v379 > 3.999)
                {
                  v381 = (float)((float)(v379 + -3.999) * -1.3) / (float)(v379 * (float)(v241 + 1));
                  v382 = v381 + 0.99;
                  if (v239)
                  {
                    v383 = v218;
                    v384 = (v113 - 1);
                    v385 = v381 + 0.99;
                    do
                    {
                      *v383 = v385 * *v383;
                      ++v383;
                      v385 = v382 * v385;
                      --v384;
                    }
                    while (v384);
                    v378 = *v229;
                  }
                  else
                  {
                    v385 = v381 + 0.99;
                  }
                  v386 = 0;
                  v387 = v385 * v378;
                  *v229 = v387;
                  v388 = -1.0;
                  do
                  {
                    v389 = fabsf(v218[v386]);
                    if (v389 > v388)
                    {
                      v241 = v386;
                      v388 = v389;
                    }
                    ++v386;
                  }
                  while (v113 != v386);
                  if (v388 > 3.999)
                  {
                    v390 = (float)((float)(v388 + -3.999) * -1.4) / (float)(v388 * (float)(v241 + 1));
                    v391 = v390 + 0.99;
                    if (v239)
                    {
                      v392 = v218;
                      v393 = (v113 - 1);
                      v394 = v390 + 0.99;
                      do
                      {
                        *v392 = v394 * *v392;
                        ++v392;
                        v394 = v391 * v394;
                        --v393;
                      }
                      while (v393);
                      v387 = *v229;
                    }
                    else
                    {
                      v394 = v390 + 0.99;
                    }
                    v395 = 0;
                    v396 = v394 * v387;
                    *v229 = v396;
                    v397 = -1.0;
                    do
                    {
                      v398 = fabsf(v218[v395]);
                      if (v398 > v397)
                      {
                        v241 = v395;
                        v397 = v398;
                      }
                      ++v395;
                    }
                    while (v113 != v395);
                    if (v397 > 3.999)
                    {
                      v399 = (float)((float)(v397 + -3.999) * -1.5) / (float)(v397 * (float)(v241 + 1));
                      v400 = v399 + 0.99;
                      if (v239)
                      {
                        v401 = v218;
                        v402 = (v113 - 1);
                        v403 = v399 + 0.99;
                        do
                        {
                          *v401 = v403 * *v401;
                          ++v401;
                          v403 = v400 * v403;
                          --v402;
                        }
                        while (v402);
                        v396 = *v229;
                      }
                      else
                      {
                        v403 = v399 + 0.99;
                      }
                      v404 = 0;
                      v405 = v403 * v396;
                      *v229 = v405;
                      v406 = -1.0;
                      do
                      {
                        v407 = fabsf(v218[v404]);
                        if (v407 > v406)
                        {
                          v241 = v404;
                          v406 = v407;
                        }
                        ++v404;
                      }
                      while (v113 != v404);
                      if (v406 > 3.999)
                      {
                        v408 = (float)((float)(v406 + -3.999) * -1.6) / (float)(v406 * (float)(v241 + 1));
                        v409 = v408 + 0.99;
                        if (v239)
                        {
                          v410 = v218;
                          v411 = (v113 - 1);
                          v412 = v408 + 0.99;
                          do
                          {
                            *v410 = v412 * *v410;
                            ++v410;
                            v412 = v409 * v412;
                            --v411;
                          }
                          while (v411);
                          v405 = *v229;
                        }
                        else
                        {
                          v412 = v408 + 0.99;
                        }
                        v413 = 0;
                        v414 = v412 * v405;
                        *v229 = v414;
                        v415 = -1.0;
                        do
                        {
                          v416 = fabsf(v218[v413]);
                          if (v416 > v415)
                          {
                            v241 = v413;
                            v415 = v416;
                          }
                          ++v413;
                        }
                        while (v113 != v413);
                        if (v415 > 3.999)
                        {
                          v417 = (float)((float)(v415 + -3.999) * -1.7) / (float)(v415 * (float)(v241 + 1));
                          v418 = v417 + 0.99;
                          if (v239)
                          {
                            v94 = v417 + 0.99;
                            do
                            {
                              *v218 = v94 * *v218;
                              ++v218;
                              v94 = v418 * v94;
                              --v228;
                            }
                            while (v228);
                            v414 = *v229;
                          }
                          else
                          {
                            v94 = v417 + 0.99;
                          }
                          *v229 = v94 * v414;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_49;
    }
    v229 = &v218[(int)v228];
    v230 = *v229;
    if ((int)v113 > 1)
    {
      v231 = (v113 - 2);
      do
        v230 = v218[v231--] + (float)(v116 * v230);
      while (v231 != -1);
      v6[v114] = v227 * (float)(v20 / (float)(v20 + (float)(v115 * v230)));
      goto LABEL_132;
    }
    v238 = 0;
    v6[v114] = v227 * (float)(v20 / (float)(v20 + (float)(v115 * v230)));
    *v229 = v34 * *v229;
    if ((int)v113 >= 1)
      goto LABEL_202;
LABEL_49:
    v33 = v469 + 4 * v467;
    v32 = v478 + 1;
    v31 += 3;
    v6 = (float *)v465;
    v7 = v466;
  }
  while (v478 + 1 != v464);
  v13 = exp2((float)(v450 * -0.16));
  *(float *)&v13 = v13;
  v19 = v454;
  if (v454 < 8)
  {
    v419 = 0;
    v17 = v452;
LABEL_335:
    v424 = v464 - v419;
    v425 = &v465->f32[v419];
    do
    {
      *v425 = (float)(*v425 * *(float *)&v13) + 1.2483;
      ++v425;
      --v424;
    }
    while (v424);
    goto LABEL_337;
  }
  v419 = v464 & 0xFFFFFFF8;
  v420 = v465 + 1;
  v421 = (float32x4_t)vdupq_n_s32(0x3F9FC94Cu);
  v422 = v419;
  v17 = v452;
  do
  {
    v14 = vaddq_f32(vmulq_n_f32(v420[-1], *(float *)&v13), v421);
    v423 = vaddq_f32(vmulq_n_f32(*v420, *(float *)&v13), v421);
    v420[-1] = v14;
    *v420 = v423;
    v420 += 2;
    v422 -= 8;
  }
  while (v422);
  if (v419 != v464)
    goto LABEL_335;
LABEL_337:
  v426 = (float)v7[1133];
  *(float *)&v13 = (float)((float)(v20 + (float)((float)((float)((float)v451 * 0.000030518) + -1.0) * 0.5)) * 4.0)
                 * (float)(v426 * 0.0039062);
  if (v17 == 2)
  {
    if (v19 >= 1)
    {
      v14.f32[0] = 0.2 / (float)v7[1144];
      if (v19 >= 4)
      {
        v433 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 0);
        v434 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v13, 0);
        v427 = v19 & 0xFFFFFFFC;
        __asm
        {
          FMOV            V5.4S, #3.0
          FMOV            V6.4S, #-1.0
          FMOV            V7.4S, #1.0
        }
        v440 = v427;
        v441 = v6;
        do
        {
          v442 = vaddq_f32(v433, vdivq_f32(_Q5, vcvtq_f32_s32(*(int32x4_t *)(v441 + 57))));
          *(float32x4_t *)(v441 + 157) = vaddq_f32(v442, _Q6);
          *(float32x4_t *)(v441 + 161) = vmlsq_f32(vsubq_f32(_Q7, v442), v434, v442);
          v441 += 4;
          v440 -= 4;
        }
        while (v440);
        if (v427 == v19)
          goto LABEL_351;
      }
      else
      {
        v427 = 0;
      }
      v443 = v19 - v427;
      v444 = &v6[v427];
      do
      {
        v445 = v14.f32[0] + (float)(3.0 / (float)*((int *)v444 + 57));
        v444[157] = v445 + -1.0;
        v444[161] = (float)(1.0 - v445) - (float)(v445 * *(float *)&v13);
        ++v444;
        --v443;
      }
      while (v443);
    }
LABEL_351:
    v431 = (float)((float)(v426 * -0.2625) * 0.0039062) + -0.25;
    v432 = (float)((float)((float)(1.0 - (float)((float)(1.0 - v6[175]) * v6[174])) * 0.2) + 0.3)
         * sqrtf(*((float *)v7 + 2521));
    goto LABEL_352;
  }
  v428 = 1.3 / (float)v7[1144];
  v6[157] = v428 + -1.0;
  v6[161] = (float)(1.0 - v428) + (float)((float)(*(float *)&v13 * v428) * -0.6);
  if (v19 <= 1)
  {
    v432 = 0.0;
    v431 = -0.25;
  }
  else
  {
    v429 = v19 - 1;
    v430 = v6 + 162;
    do
    {
      *(v430 - 4) = v428 + -1.0;
      *v430++ = v6[161];
      --v429;
    }
    while (v429);
    v431 = -0.25;
    v432 = 0.0;
  }
LABEL_352:
  if (v19 >= 1)
  {
    v446 = v19;
    v447 = v6 + 169;
    do
    {
      v448 = *((float *)v7 + 1799) + (float)((float)(v432 - *((float *)v7 + 1799)) * 0.4);
      *((float *)v7 + 1799) = v448;
      *v447 = v448;
      v449 = *((float *)v7 + 1800) + (float)((float)(v431 - *((float *)v7 + 1800)) * 0.4);
      *((float *)v7 + 1800) = v449;
      *(v447 - 4) = v449;
      ++v447;
      --v446;
    }
    while (v446);
  }
}

void *silk_NSQ_c(_DWORD *a1, _DWORD *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unsigned int a14, __int16 a15)
{
  _DWORD *v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  _OWORD *v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  _OWORD *v43;
  int16x4_t *v44;
  int v45;
  char v46;
  int v47;
  int v48;
  unsigned int v49;
  char v50;
  int v51;
  unsigned int v52;
  int v53;
  char v54;
  int v55;
  unsigned int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  __int16 *v62;
  uint64_t v63;
  char *v64;
  unint64_t v65;
  uint64_t v66;
  char *v67;
  __int16 *v68;
  int v69;
  uint64_t v70;
  int v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  __int16 *v76;
  char *v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  char *v81;
  __int16 *v82;
  int v83;
  int v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  unsigned int v88;
  unsigned int v89;
  int v90;
  uint64_t v91;
  int v92;
  int v93;
  int v94;
  int v95;
  unsigned int v96;
  signed int v97;
  signed int v98;
  int v99;
  _DWORD *v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  int32x2_t *v106;
  unint64_t v107;
  int32x4_t v108;
  int32x4_t v109;
  uint64_t v110;
  char *v111;
  uint64_t v112;
  __int16 *v113;
  __int16 *v114;
  int v115;
  unint64_t v116;
  int v117;
  int v118;
  char *v119;
  int *v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  int v124;
  int *v125;
  uint64_t v126;
  uint64_t v127;
  unsigned int v128;
  unsigned int v129;
  int v130;
  int v131;
  unsigned int v132;
  uint64_t v133;
  int v134;
  int v135;
  int v136;
  unint64_t v137;
  unsigned int v138;
  __int16 v139;
  int v140;
  int v141;
  int32x2_t *v142;
  int32x2_t v143;
  int v144;
  int v145;
  char *v146;
  int v147;
  int v148;
  int v149;
  int *v150;
  __int16 *v151;
  unint64_t i;
  int v153;
  int v154;
  int v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  int v164;
  int v165;
  unsigned int v166;
  unsigned int v167;
  uint64_t v168;
  int v169;
  uint64_t v171;
  char *v172;
  char *v173;
  uint64_t v174;
  uint64_t v175;
  char *v176;
  uint64_t v177;
  _DWORD *v178;
  int v179;
  uint64_t v180;
  int *v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  _OWORD *v186;
  uint64_t v187;
  _BOOL8 v188;
  uint64_t v189;
  char *v190;
  uint64_t v191;
  _DWORD *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  int v198;
  int v199;
  int v200;
  unsigned int v201;
  unsigned int v202;
  int *v203;
  __int16 *v204;
  int v205;
  unsigned int v206;
  int v207;
  uint64_t v208;
  uint64_t v209;
  int v210;
  int v211;
  char *v212;
  uint64_t v213;
  uint64_t v214;
  _DWORD *v215;
  int v216;
  int v217;
  uint64_t v218;
  int32x2_t *v219;
  int v220;
  char *v221;
  uint64_t v222;
  unsigned int v223;
  uint64_t v224;

  v185 = a7;
  v189 = a6;
  v222 = a5;
  v17 = a1;
  v191 = a13;
  v224 = *MEMORY[0x24BDAC8D0];
  a2[1085] = a3[34];
  v18 = a2[1082];
  v19 = silk_Quantization_Offsets_Q10[2 * (a3[29] >> 1) + a3[30]];
  v190 = a3;
  v20 = MEMORY[0x24BDAC7A8](a1, a2);
  v22 = (char *)&v171 - v21;
  MEMORY[0x24BDAC7A8](v20, v23);
  v26 = MEMORY[0x24BDAC7A8]((char *)&v171 - v24, v25);
  v32 = (char *)&v171 - ((v34 + 15) & 0x7FFFFFFF0);
  *(_DWORD *)(v33 + 4336) = v31;
  *(_DWORD *)(v33 + 4332) = v31;
  LODWORD(v34) = v17[1145];
  if ((int)v34 >= 1)
  {
    v197 = 0;
    v35 = 0;
    v219 = (int32x2_t *)(a2 + 1083);
    v221 = (char *)a2 + 2 * v31;
    v194 = a12;
    v183 = a11;
    v188 = v29 == 4;
    if (v29 == 4)
      v36 = 3;
    else
      v36 = 1;
    v179 = v36;
    v182 = a10;
    v187 = a9;
    v175 = a15;
    v186 = a2 + 960;
    v181 = a2 + 975;
    v207 = (a14 >> 1) - 512;
    v198 = 512 - (a14 >> 1);
    v201 = v19 - 944;
    v211 = a14;
    v200 = (__int16)(944 - v19) * (__int16)a14;
    v37 = (__int16)a14 * v19;
    v206 = v19 + 944;
    v210 = (__int16)a14;
    v205 = (__int16)(v19 + 944) * (__int16)a14;
    v202 = v19 - 80;
    v176 = v32 + 4;
    v177 = v26;
    v174 = v26 + 2;
    v173 = v22 + 4;
    v178 = a2 + 320;
    v172 = v22 + 16;
    v184 = v27;
    v180 = v27 + 4;
    v203 = a2 + 1058;
    v223 = v19;
    v212 = v32;
    v199 = v37;
    v192 = v17;
    while (1)
    {
      v44 = (int16x4_t *)(v189 + 32 * (v188 | (v35 >> 1)));
      v45 = *(_DWORD *)(v187 + 4 * v35);
      a2[1087] = 0;
      v220 = v190[29];
      if (v220 != 2)
        goto LABEL_10;
      v18 = *(unsigned int *)(v191 + 4 * v35);
      if ((v179 & v35) != 0)
        break;
      v168 = v17[1160];
      v169 = v17[1148] - v168 - v18 - 2;
      silk_LPC_analysis_filter((_WORD *)(v177 + 2 * v169), (uint64_t)a2 + 2 * v169 + 2 * (int)v28 * (int)v35, v44, 2 - (-(int)v168 - v18), v168);
      v37 = v199;
      v32 = v212;
      v19 = v223;
      v46 = 0;
      a2[1087] = 1;
      a2[1083] = v17[1148];
      v220 = v190[29];
LABEL_11:
      v47 = *(_DWORD *)(v191 + 4 * v35);
      v48 = *(_DWORD *)(v194 + 4 * v35);
      if (v48 <= 1)
        v49 = 1;
      else
        v49 = *(_DWORD *)(v194 + 4 * v35);
      v50 = __clz(v49);
      v51 = ((unint64_t)((int)((unint64_t)-(uint64_t)((((uint64_t)(0x1FFFFFFF
                                                                             / ((int)(v49 << (v50 - 1)) >> 16)) << 19)
                                                                  * (int)(v49 << (v50 - 1))) & 0xFFFFFFF800000000) >> 32)
                              * (uint64_t)(0x1FFFFFFF / ((int)(v49 << (v50 - 1)) >> 16))) >> 16)
          + ((0x1FFFFFFF / ((int)(v49 << (v50 - 1)) >> 16)) << 16);
      v52 = v49 >> 17;
      v53 = v51 >> (15 - v50);
      v54 = v50 - 15;
      v55 = (int)0x80000000 >> v54;
      if (v51 > (int)0x80000000 >> v54)
        v55 = v51;
      if (v51 <= (int)(0x7FFFFFFFu >> v54))
        v56 = v55;
      else
        v56 = 0x7FFFFFFFu >> v54;
      v57 = v56 << v54;
      if (v52)
        v58 = v53;
      else
        v58 = v57;
      v59 = v17[1147];
      if ((int)v59 < 1)
        goto LABEL_30;
      v60 = (uint64_t)((v58 >> 4) + 1) >> 1;
      if ((_DWORD)v59 == 1)
      {
        v61 = 0;
      }
      else
      {
        v61 = v59 & 0xFFFFFFFE;
        v62 = (__int16 *)(a4 + 2);
        v63 = v61;
        v64 = v176;
        do
        {
          v65 = (unint64_t)(*v62 * (uint64_t)(int)v60) >> 16;
          *((_DWORD *)v64 - 1) = (unint64_t)(*(v62 - 1) * (uint64_t)(int)v60) >> 16;
          *(_DWORD *)v64 = v65;
          v62 += 2;
          v64 += 8;
          v63 -= 2;
        }
        while (v63);
        if (v61 == v59)
          goto LABEL_30;
      }
      v66 = v59 - v61;
      v67 = &v32[4 * v61];
      v68 = (__int16 *)(a4 + 2 * v61);
      do
      {
        v69 = *v68++;
        *(_DWORD *)v67 = (unint64_t)(v69 * (uint64_t)(int)v60) >> 16;
        v67 += 4;
        --v66;
      }
      while (v66);
LABEL_30:
      if ((v46 & 1) == 0)
      {
        v70 = v219->i32[0];
        v71 = v70 - v47 - 2;
        if (v71 < (int)v70)
        {
          v72 = ((unint64_t)((int)v175 * (uint64_t)v58) >> 14) & 0xFFFFFFFC;
          if (v35)
            LODWORD(v72) = v58;
          v73 = v71;
          v74 = v70 - v71;
          v75 = v73;
          if (v74 < 2)
            goto LABEL_38;
          v75 = (v74 & 0xFFFFFFFFFFFFFFFELL) + v73;
          v76 = (__int16 *)(v174 + 2 * v73);
          v77 = &v173[4 * v73];
          v78 = v74 & 0xFFFFFFFFFFFFFFFELL;
          do
          {
            v79 = (unint64_t)(*v76 * (uint64_t)(int)v72) >> 16;
            *((_DWORD *)v77 - 1) = (unint64_t)(*(v76 - 1) * (uint64_t)(int)v72) >> 16;
            *(_DWORD *)v77 = v79;
            v76 += 2;
            v77 += 8;
            v78 -= 2;
          }
          while (v78);
          if (v74 != (v74 & 0xFFFFFFFFFFFFFFFELL))
          {
LABEL_38:
            v80 = v70 - v75;
            v81 = &v22[4 * v75];
            v82 = (__int16 *)(v177 + 2 * v75);
            do
            {
              v83 = *v82++;
              *(_DWORD *)v81 = (unint64_t)(v83 * (uint64_t)(int)v72) >> 16;
              v81 += 4;
              --v80;
            }
            while (v80);
          }
        }
      }
      v193 = a4;
      v84 = a2[1086];
      if (v48 != v84)
      {
        if (v84 >= 0)
          v85 = a2[1086];
        else
          v85 = -v84;
        v86 = __clz(v85);
        v87 = v84 << (v86 - 1);
        if (v48 >= 0)
          v88 = v48;
        else
          v88 = -v48;
        v89 = __clz(v88);
        v90 = v48 << (v89 - 1);
        v91 = (0x1FFFFFFF / (v90 >> 16) * (uint64_t)v87) >> 16;
        v92 = ((unint64_t)(0x1FFFFFFF
                                / (v90 >> 16)
                                * (uint64_t)(int)(v87 - (((unint64_t)((int)v91 * (uint64_t)v90) >> 29) & 0xFFFFFFF8))) >> 16)
            + v91;
        v93 = v86 - v89;
        if (v86 - v89 + 29 >= 0x30)
          v94 = 0;
        else
          v94 = v92 >> (v93 + 13);
        v95 = (int)0x80000000 >> (-13 - v93);
        if (v95 <= v92)
          v95 = v92;
        if ((int)(0x7FFFFFFFu >> (-13 - v93)) >= v92)
          v96 = v95;
        else
          v96 = 0x7FFFFFFFu >> (-13 - v93);
        v97 = v96 << (-13 - v93);
        if (v93 <= -14)
          v98 = v97;
        else
          v98 = v94;
        v99 = v17[1148];
        v100 = v178;
        if (v99 >= 1)
        {
          v101 = a2[1084] - v99;
          do
          {
            v100[v101] = (unint64_t)((int)v100[v101] * (uint64_t)v98) >> 16;
            ++v101;
          }
          while (v101 < (int)a2[1084]);
        }
        if (v220 == 2 && !a2[1087])
        {
          v102 = v219->i32[0];
          LODWORD(v103) = v102 - v47 - 2;
          if ((int)v103 < (int)v102)
          {
            v104 = (int)v103;
            v105 = v102 - (int)v103;
            v103 = (int)v103;
            if (v105 < 8)
              goto LABEL_68;
            v103 = (v105 & 0xFFFFFFFFFFFFFFF8) + (int)v103;
            v106 = (int32x2_t *)&v172[4 * v104];
            v107 = v105 & 0xFFFFFFFFFFFFFFF8;
            do
            {
              v108 = vdupq_n_s32(v98);
              v109 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v108.i8, *v106), 0x10uLL), vmull_high_s32(v108, *(int32x4_t *)v106->i8), 0x10uLL);
              *(int32x4_t *)v106[-2].i8 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v108.i8, v106[-2]), 0x10uLL), vmull_high_s32(v108, *(int32x4_t *)v106[-2].i8), 0x10uLL);
              *(int32x4_t *)v106->i8 = v109;
              v106 += 4;
              v107 -= 8;
            }
            while (v107);
            if (v105 != (v105 & 0xFFFFFFFFFFFFFFF8))
            {
LABEL_68:
              v110 = v102 - v103;
              v111 = &v22[4 * v103];
              do
              {
                *(_DWORD *)v111 = (unint64_t)(*(int *)v111 * (uint64_t)v98) >> 16;
                v111 += 4;
                --v110;
              }
              while (v110);
            }
          }
        }
        a2[1080] = (unint64_t)((int)a2[1080] * (uint64_t)v98) >> 16;
        a2[1081] = (unint64_t)((int)a2[1081] * (uint64_t)v98) >> 16;
        a2[960] = (unint64_t)((int)a2[960] * (uint64_t)v98) >> 16;
        a2[961] = (unint64_t)((int)a2[961] * (uint64_t)v98) >> 16;
        a2[962] = (unint64_t)((int)a2[962] * (uint64_t)v98) >> 16;
        a2[963] = (unint64_t)((int)a2[963] * (uint64_t)v98) >> 16;
        a2[964] = (unint64_t)((int)a2[964] * (uint64_t)v98) >> 16;
        a2[965] = (unint64_t)((int)a2[965] * (uint64_t)v98) >> 16;
        a2[966] = (unint64_t)((int)a2[966] * (uint64_t)v98) >> 16;
        a2[967] = (unint64_t)((int)a2[967] * (uint64_t)v98) >> 16;
        a2[968] = (unint64_t)((int)a2[968] * (uint64_t)v98) >> 16;
        a2[969] = (unint64_t)((int)a2[969] * (uint64_t)v98) >> 16;
        a2[970] = (unint64_t)((int)a2[970] * (uint64_t)v98) >> 16;
        a2[971] = (unint64_t)((int)a2[971] * (uint64_t)v98) >> 16;
        a2[972] = (unint64_t)((int)a2[972] * (uint64_t)v98) >> 16;
        a2[973] = (unint64_t)((int)a2[973] * (uint64_t)v98) >> 16;
        a2[974] = (unint64_t)((int)a2[974] * (uint64_t)v98) >> 16;
        a2[975] = (unint64_t)((int)a2[975] * (uint64_t)v98) >> 16;
        a2[1056] = (unint64_t)((int)a2[1056] * (uint64_t)v98) >> 16;
        a2[1057] = (unint64_t)((int)a2[1057] * (uint64_t)v98) >> 16;
        a2[1058] = (unint64_t)((int)a2[1058] * (uint64_t)v98) >> 16;
        a2[1059] = (unint64_t)((int)a2[1059] * (uint64_t)v98) >> 16;
        a2[1060] = (unint64_t)((int)a2[1060] * (uint64_t)v98) >> 16;
        a2[1061] = (unint64_t)((int)a2[1061] * (uint64_t)v98) >> 16;
        a2[1062] = (unint64_t)((int)a2[1062] * (uint64_t)v98) >> 16;
        a2[1063] = (unint64_t)((int)a2[1063] * (uint64_t)v98) >> 16;
        a2[1064] = (unint64_t)((int)a2[1064] * (uint64_t)v98) >> 16;
        a2[1065] = (unint64_t)((int)a2[1065] * (uint64_t)v98) >> 16;
        a2[1066] = (unint64_t)((int)a2[1066] * (uint64_t)v98) >> 16;
        a2[1067] = (unint64_t)((int)a2[1067] * (uint64_t)v98) >> 16;
        a2[1068] = (unint64_t)((int)a2[1068] * (uint64_t)v98) >> 16;
        a2[1069] = (unint64_t)((int)a2[1069] * (uint64_t)v98) >> 16;
        a2[1070] = (unint64_t)((int)a2[1070] * (uint64_t)v98) >> 16;
        a2[1071] = (unint64_t)((int)a2[1071] * (uint64_t)v98) >> 16;
        a2[1072] = (unint64_t)((int)a2[1072] * (uint64_t)v98) >> 16;
        a2[1073] = (unint64_t)((int)a2[1073] * (uint64_t)v98) >> 16;
        a2[1074] = (unint64_t)((int)a2[1074] * (uint64_t)v98) >> 16;
        a2[1075] = (unint64_t)((int)a2[1075] * (uint64_t)v98) >> 16;
        a2[1076] = (unint64_t)((int)a2[1076] * (uint64_t)v98) >> 16;
        a2[1077] = (unint64_t)((int)a2[1077] * (uint64_t)v98) >> 16;
        a2[1078] = (unint64_t)((int)a2[1078] * (uint64_t)v98) >> 16;
        a2[1079] = (unint64_t)((int)a2[1079] * (uint64_t)v98) >> 16;
        a2[1086] = *(_DWORD *)(v194 + 4 * v35);
        v59 = v17[1147];
      }
      v196 = v35;
      v195 = v59;
      if ((int)v59 >= 1)
      {
        v112 = 0;
        v204 = (__int16 *)(v180 + 16 * (v197 & 0x1FFFFFFF));
        v113 = (__int16 *)(v185 + 2 * (5 * v196));
        v114 = (__int16 *)(v184 + 2 * (24 * v196));
        v115 = v192[1160];
        v116 = v192[1159];
        v117 = *(_DWORD *)(v194 + 4 * v35);
        v118 = *(_DWORD *)(v183 + 4 * v35);
        v218 = (__int16)v118;
        v119 = &v22[4 * (a2[1083] - (int)v18) + 8];
        v120 = &a2[a2[1084] - (int)v18 + 321];
        v121 = v115;
        v216 = (int)v116 >> 1;
        v217 = v115 >> 1;
        v122 = (int)v116 - 1;
        v215 = &a2[v122 + 1056];
        v214 = *(__int16 *)(v182 + 4 * v35);
        v213 = (uint64_t)v118 >> 16;
        v208 = (uint64_t)((v45 >> 2) | (v45 << 15)) >> 16;
        v209 = (__int16)(v45 >> 2);
        v123 = (uint64_t)v117 >> 6;
        v124 = a2[1085];
        v125 = v181;
        v126 = v195;
        v127 = v18;
        while (1)
        {
          a2[1085] = 196314165 * v124 + 907633515;
          v144 = v217
               + ((unint64_t)(v44->i16[0] * (uint64_t)*v125) >> 16)
               + ((unint64_t)(v44->i16[1] * (uint64_t)*(v125 - 1)) >> 16)
               + ((unint64_t)(v44->i16[2] * (uint64_t)*(v125 - 2)) >> 16)
               + ((unint64_t)(v44->i16[3] * (uint64_t)*(v125 - 3)) >> 16)
               + ((unint64_t)(v44[1].i16[0] * (uint64_t)*(v125 - 4)) >> 16)
               + ((unint64_t)(v44[1].i16[1] * (uint64_t)*(v125 - 5)) >> 16)
               + ((unint64_t)(v44[1].i16[2] * (uint64_t)*(v125 - 6)) >> 16)
               + ((unint64_t)(v44[1].i16[3] * (uint64_t)*(v125 - 7)) >> 16)
               + ((unint64_t)(v44[2].i16[0] * (uint64_t)*(v125 - 8)) >> 16)
               + ((unint64_t)(v44[2].i16[1] * (uint64_t)*(v125 - 9)) >> 16);
          if (v121 == 16)
            v144 += ((unint64_t)(v44[2].i16[2] * (uint64_t)*(v125 - 10)) >> 16)
                  + ((unint64_t)(v44[2].i16[3] * (uint64_t)*(v125 - 11)) >> 16)
                  + ((unint64_t)(v44[3].i16[0] * (uint64_t)*(v125 - 12)) >> 16)
                  + ((unint64_t)(v44[3].i16[1] * (uint64_t)*(v125 - 13)) >> 16)
                  + ((unint64_t)(v44[3].i16[2] * (uint64_t)*(v125 - 14)) >> 16)
                  + ((unint64_t)(v44[3].i16[3] * (uint64_t)*(v125 - 15)) >> 16);
          if (v220 == 2)
          {
            v145 = ((((*(int *)v119 * (uint64_t)*v113) << 16)
                   + ((unint64_t)(*((int *)v119 - 1) * (uint64_t)v113[1]) >> 16 << 32)
                   + ((unint64_t)(*((int *)v119 - 2) * (uint64_t)v113[2]) >> 16 << 32)
                   + ((unint64_t)(*((int *)v119 - 3) * (uint64_t)v113[3]) >> 16 << 32)
                   + 0x200000000) >> 32)
                 + ((unint64_t)(v113[4] * (uint64_t)*((int *)v119 - 4)) >> 16);
            v119 += 4;
          }
          else
          {
            v145 = 0;
          }
          v146 = v22;
          v147 = a2[1081];
          v148 = a2[1056];
          a2[1056] = v147;
          v149 = v216 + ((unint64_t)(*v114 * (uint64_t)v147) >> 16);
          if ((int)v116 >= 3)
          {
            v150 = v203;
            v151 = v204;
            for (i = 2; i < v116; i += 2)
            {
              v153 = *(v150 - 1);
              *(v150 - 1) = v148;
              v154 = v149 + ((unint64_t)(*(v151 - 1) * (uint64_t)v148) >> 16);
              v148 = *v150;
              *v150 = v153;
              v150 += 2;
              v149 = v154 + ((unint64_t)(*v151 * (uint64_t)v153) >> 16);
              v151 += 2;
            }
          }
          *v215 = v148;
          v155 = a2[1080];
          v156 = ((unint64_t)((int)v214 * (uint64_t)v155) >> 16)
               + 2 * (v149 + ((unint64_t)(v114[v122] * (uint64_t)v148) >> 16));
          v157 = ((unint64_t)((int)v218 * (uint64_t)(int)a2[a2[1084] + 319]) >> 16)
               + ((unint64_t)(v155 * (uint64_t)(int)v213) >> 16);
          v158 = 4 * v144 - v156 - v157;
          if ((int)v18 < 1)
          {
            v160 = v158 >> 1;
          }
          else
          {
            v159 = ((unint64_t)(*(v120 - 1) * (uint64_t)(int)v208) >> 16)
                 + ((unint64_t)((int)v209 * (uint64_t)vqadds_s32(*v120, *(v120 - 2))) >> 16);
            ++v120;
            v160 = (v145 + 2 * v158 - 2 * v159) >> 2;
          }
          v161 = *(_DWORD *)&v32[4 * v112];
          v162 = v161 - ((v160 + 1) >> 1);
          if ((int)a2[1085] < 0)
            v162 = -v162;
          if (v162 <= -31744)
            v162 = -31744;
          if (v162 >= 30720)
            v163 = 30720;
          else
            v163 = v162;
          v164 = v163 - v19;
          if (v211 < 2049)
            goto LABEL_106;
          if (v164 > v207)
            break;
          if (v164 >= v198)
          {
            if (v164 >= 0)
              v128 = v19;
            else
              v128 = v201;
            if (v164 >= 0)
              v129 = v206;
            else
              v129 = v19;
            if (v164 >= 0)
              v130 = v37;
            else
              v130 = v200;
            v131 = v205;
            if (v164 < 0)
              v131 = v37;
            goto LABEL_74;
          }
          v164 += v207;
          if (v164 < 1024)
          {
LABEL_107:
            v165 = v164 >> 10;
            v128 = v19;
            v131 = v205;
            v129 = v206;
            v130 = v37;
            if (v164 >> 10)
            {
              v129 = v223;
              v166 = v223 + (v164 & 0xFFFFFC00);
              v128 = v166 + 80;
              v167 = v166 + 1104;
              v130 = (__int16)(-80 - v166) * v210;
              v131 = (__int16)(-1104 - v166) * v210;
              v37 = v199;
              if (v165 == -1)
              {
                v128 = v201;
                v130 = v200;
              }
              else
              {
                v129 = v167;
              }
              if (v165 == -1)
                v131 = v199;
            }
            goto LABEL_74;
          }
LABEL_73:
          v128 = v202 + (v164 & 0xFFFFFC00);
          v129 = v128 + 1024;
          v130 = (__int16)(v202 + (v164 & 0xFC00)) * v210;
          v131 = (__int16)(v202 + (v164 & 0xFC00) + 1024) * v210;
LABEL_74:
          if (v131 + (__int16)(v163 - v129) * (__int16)(v163 - v129) >= v130
                                                                       + (__int16)(v163 - v128) * (__int16)(v163 - v128))
            v132 = v128;
          else
            v132 = v129;
          v133 = v222;
          *(_BYTE *)(v222 + v112) = ((v132 >> 9) + 1) >> 1;
          v134 = 16 * v132;
          if ((int)a2[1085] < 0)
            v134 = -v134;
          v135 = v134 + 2 * v145;
          v136 = v135 + 16 * v144;
          v137 = (unint64_t)((int)v123 * (uint64_t)v136) >> 16;
          v138 = ((v137 >> 7) + 1) >> 1;
          if ((int)v137 < -8388736)
            LOWORD(v138) = 0x8000;
          if ((int)v137 <= 8388479)
            v139 = v138;
          else
            v139 = 0x7FFF;
          *(_WORD *)&v221[2 * v112] = v139;
          v125[1] = v136;
          ++v125;
          v140 = v136 - 16 * v161;
          a2[1081] = v140;
          v141 = v140 - 4 * v156;
          a2[1080] = v141;
          a2[a2[1084] + 320] = v141 - 4 * v157;
          v142 = v219;
          v143 = vadd_s32(*v219, (int32x2_t)0x100000001);
          v22 = v146;
          *(_DWORD *)&v146[4 * v219->i32[0]] = 2 * v135;
          *v142 = v143;
          v124 = a2[1085] + *(char *)(v133 + v112);
          a2[1085] = v124;
          ++v112;
          v18 = v127;
          v19 = v223;
          v32 = v212;
          if (v112 == v126)
            goto LABEL_6;
        }
        v164 -= v207;
LABEL_106:
        if (v164 < 1024)
          goto LABEL_107;
        goto LABEL_73;
      }
LABEL_6:
      v38 = &a2[(int)v195];
      v39 = v38[240];
      v40 = v38[241];
      v41 = v38[242];
      v42 = v38[243];
      v43 = v186;
      v186[2] = v41;
      v43[3] = v42;
      *v43 = v39;
      v43[1] = v40;
      v17 = v192;
      v28 = (int)v192[1147];
      a4 = v193 + 2 * v28;
      v222 += v28;
      v221 += 2 * v28;
      v35 = v196 + 1;
      v34 = (int)v192[1145];
      v197 = (v197 + 3);
      if (v196 + 1 >= v34)
      {
        v30 = v192[1146];
        v31 = v192[1148];
        goto LABEL_130;
      }
    }
    v220 = 2;
LABEL_10:
    v46 = 1;
    goto LABEL_11;
  }
LABEL_130:
  a2[1082] = *(_DWORD *)(v191 + 4 * ((int)v34 - 1));
  memmove(a2, (char *)a2 + 2 * v30, 2 * v31);
  return memmove(a2 + 320, &a2[v17[1146] + 320], 4 * (int)v17[1148]);
}

void *silk_NSQ_del_dec_c(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int32x4_t *a13, unsigned int a14, __int16 a15)
{
  uint64_t v19;
  uint64_t v20;
  int32x4_t *v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int32x2_t v27;
  __int32 v28;
  int32x2_t *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  int32x4_t v42;
  int32x4_t *v43;
  int32x4_t v44;
  uint64_t v45;
  int32x4_t v46;
  uint64_t v47;
  __int32 *v48;
  int v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  uint64_t v68;
  unsigned int v69;
  int v70;
  int v71;
  char v72;
  uint64_t v73;
  __int32 v74;
  int v75;
  unsigned int v76;
  char v77;
  int v78;
  unsigned int v79;
  int v80;
  char v81;
  int v82;
  unsigned int v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  __int16 *v88;
  uint64_t v89;
  char *v90;
  unint64_t v91;
  uint64_t v92;
  char *v93;
  __int16 *v94;
  int v95;
  uint64_t v96;
  int v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  __int16 *v104;
  _DWORD *v105;
  unint64_t v106;
  unint64_t v107;
  uint64_t v108;
  _DWORD *v109;
  __int16 *v110;
  int v111;
  int v112;
  int v113;
  unsigned int v114;
  unsigned int v115;
  int v116;
  unsigned int v117;
  unsigned int v118;
  int v119;
  uint64_t v120;
  int v121;
  int v122;
  int v123;
  int v124;
  unsigned int v125;
  signed int v126;
  int v127;
  uint64_t v128;
  int v129;
  int v130;
  int v131;
  uint64_t v132;
  uint64_t v133;
  unint64_t v134;
  uint64_t v135;
  int32x2_t *v136;
  unint64_t v137;
  int32x4_t v138;
  int32x4_t v139;
  signed int v140;
  int32x4_t *v141;
  int32x4_t v142;
  int32x4_t v143;
  int32x4_t v144;
  int32x4_t v145;
  int32x4_t v146;
  int32x4_t v147;
  int32x4_t v148;
  int32x4_t v149;
  int32x4_t v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  uint64_t v159;
  unsigned int v160;
  __int32 v161;
  char *v162;
  uint64_t v163;
  int v164;
  int v165;
  uint64_t v166;
  char *v167;
  unsigned int v168;
  unsigned int v169;
  __int16 *v170;
  _BYTE *v171;
  int v172;
  uint64_t v173;
  char *v174;
  unint64_t v175;
  unsigned int v176;
  __int16 v177;
  uint64_t v178;
  int v179;
  int v180;
  __int32 v181;
  __int32 *v182;
  uint64_t i;
  unsigned int v184;
  uint64_t v185;
  uint64_t v186;
  char *v187;
  unint64_t v188;
  unsigned int v189;
  __int16 v190;
  char *v192;
  char *v193;
  __int128 v194;
  __int128 v195;
  _QWORD v197[2];
  char *v198;
  uint64_t v199;
  uint64_t v200;
  int v201;
  char *i8;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  char *v207;
  uint64_t v208;
  uint64_t v209;
  int v210;
  uint64_t v211;
  uint64_t v212;
  unsigned int v213;
  _BOOL8 v214;
  uint64_t v215;
  uint64_t v216;
  int v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  int v221;
  char *v222;
  uint64_t v223;
  int32x4_t *v224;
  uint64_t v225;
  int32x4_t *v226;
  int v227;
  int16x4_t *v228;
  int v229;
  char v230[8];
  uint64_t v231;

  v220 = a8;
  v219 = a7;
  v218 = a6;
  v225 = a3;
  v231 = *MEMORY[0x24BDAC8D0];
  v227 = *(_DWORD *)(a2 + 4328);
  v19 = MEMORY[0x24BDAC7A8](a1, a2);
  v21 = (int32x4_t *)((char *)v197 - v20);
  v22 = *(_DWORD *)(v19 + 4628);
  bzero((char *)v197 - v20, v22 * (uint64_t)v23);
  if (v22 >= 1)
  {
    v25 = v22;
    v26 = *(unsigned __int8 *)(v225 + 34);
    v27 = *(int32x2_t *)(a2 + 4320);
    v28 = *(_DWORD *)(a2 + 4 * *(int *)(a1 + 4592) + 1276);
    v29 = (int32x2_t *)v21;
    do
    {
      v29[161] = vdup_n_s32(v26 & 3);
      v30 = *(_OWORD *)(a2 + 3856);
      *(_OWORD *)v29->i8 = *(_OWORD *)(a2 + 3840);
      *(_OWORD *)v29[2].i8 = v30;
      v31 = *(_OWORD *)(a2 + 3888);
      *(_OWORD *)v29[4].i8 = *(_OWORD *)(a2 + 3872);
      *(_OWORD *)v29[6].i8 = v31;
      v32 = *(_OWORD *)(a2 + 4272);
      *(_OWORD *)v29[152].i8 = *(_OWORD *)(a2 + 4256);
      *(_OWORD *)v29[154].i8 = v32;
      v33 = *(_OWORD *)(a2 + 4304);
      *(_OWORD *)v29[156].i8 = *(_OWORD *)(a2 + 4288);
      *(_OWORD *)v29[158].i8 = v33;
      v34 = *(_OWORD *)(a2 + 4240);
      *(_OWORD *)v29[148].i8 = *(_OWORD *)(a2 + 4224);
      v29[162].i32[0] = 0;
      v29[160] = v27;
      v29[128].i32[0] = v28;
      *(_OWORD *)v29[150].i8 = v34;
      v29 = (int32x2_t *)((char *)v29 + 1300);
      ++v26;
      --v25;
    }
    while (v25);
  }
  v226 = a13;
  v35 = a12;
  v36 = *(unsigned __int8 *)(v225 + 29);
  v217 = silk_Quantization_Offsets_Q10[2 * ((char)v36 >> 1) + *(char *)(v225 + 30)];
  v229 = 0;
  v37 = *(_DWORD *)(a1 + 4588);
  if (v37 >= 40)
    v38 = 40;
  else
    v38 = v37;
  if (v36 != 2)
  {
    v41 = v227 - 3;
    if ((int)v38 < v227 - 3)
      v41 = v38;
    if (v227 >= 1)
      v38 = v41;
    else
      v38 = v38;
    goto LABEL_24;
  }
  v39 = *(unsigned int *)(a1 + 4580);
  if ((int)v39 >= 1)
  {
    if (v39 < 8)
    {
      v40 = 0;
      goto LABEL_19;
    }
    v40 = v39 & 0x7FFFFFF8;
    v42 = vdupq_n_s32(v38);
    v43 = v226 + 1;
    v44.i64[0] = 0x200000002;
    v44.i64[1] = 0x200000002;
    v45 = v39 & 0xFFFFFFF8;
    v46 = v42;
    do
    {
      v42 = vminq_s32(v42, vaddq_s32(v43[-1], v44));
      v46 = vminq_s32(v46, vaddq_s32(*v43, v44));
      v43 += 2;
      v45 -= 8;
    }
    while (v45);
    v38 = vminvq_s32(vminq_s32(v42, v46));
    if (v40 != v39)
    {
LABEL_19:
      v47 = v39 - v40;
      v48 = &v226->i32[v40];
      do
      {
        v49 = *v48++;
        v50 = v49 - 3;
        if ((int)v38 >= v49 - 3)
          v38 = v50;
        else
          v38 = v38;
        --v47;
      }
      while (v47);
    }
  }
LABEL_24:
  v51 = MEMORY[0x24BDAC7A8](v38, v24);
  v53 = MEMORY[0x24BDAC7A8](v51, v52);
  v55 = MEMORY[0x24BDAC7A8](v53, v54);
  v61 = (char *)v197 - ((v60 + 15) & 0x7FFFFFFF0);
  v63 = a2 + 2 * v62;
  *(_DWORD *)(a2 + 4336) = v62;
  *(_DWORD *)(a2 + 4332) = v62;
  LODWORD(v64) = *(_DWORD *)(a1 + 4580);
  if ((int)v64 < 1)
    goto LABEL_123;
  v197[1] = v197;
  v65 = 0;
  v66 = 0;
  v215 = a11;
  v214 = v58 == 4;
  if (v58 == 4)
    v67 = 3;
  else
    v67 = 1;
  v210 = v67;
  v213 = a14;
  v206 = a15;
  v203 = v55;
  v212 = a10;
  v211 = a9;
  v198 = &v21[162].i8[4];
  i8 = v21[81].i8;
  v201 = -v55;
  v207 = v61 + 4;
  v209 = v59;
  v205 = v59 + 2;
  v204 = v56 + 4;
  v197[0] = v56 + 16;
  LODWORD(v68) = v57;
  v200 = -2 * v55;
  v221 = v55;
  v199 = -(uint64_t)v55;
  v224 = v21;
  v216 = a12;
  v223 = v56;
  v222 = v61;
  do
  {
    v228 = (int16x4_t *)(v218 + 32 * (v214 | (v65 >> 1)));
    v70 = *(_DWORD *)(v211 + 4 * v65);
    *(_DWORD *)(a2 + 4348) = 0;
    v71 = *(unsigned __int8 *)(v225 + 29);
    if (v71 != 2)
      goto LABEL_34;
    v227 = v226->i32[v65];
    if ((v210 & v65) != 0)
    {
      LOBYTE(v71) = 2;
LABEL_34:
      v72 = 1;
      goto LABEL_35;
    }
    v208 = a4;
    if (v65 == 2)
    {
      v159 = *(unsigned int *)(a1 + 4628);
      if ((int)v159 <= 1)
      {
        v160 = 0;
        v164 = v221;
        if ((int)v159 < 1)
        {
LABEL_111:
          if (v164 < 1)
          {
            v165 = v70;
            v66 = 0;
          }
          else
          {
            v168 = v160;
            v169 = v229 + v164;
            v170 = (__int16 *)(v63 + v200);
            v171 = (_BYTE *)(a5 + v199);
            v172 = v201;
            v173 = v203;
            do
            {
              v169 = (int)(v169 - 1) % 40 + ((int)(v169 - 1) % 40 < 0 ? 0x28 : 0);
              v174 = &v21->i8[1300 * v168 + 4 * v169];
              *v171++ = ((*((_DWORD *)v174 + 136) >> 9) + 1) >> 1;
              v175 = (unint64_t)(*(int *)(v35 + 4) * (uint64_t)*((int *)v174 + 176)) >> 16;
              v176 = ((v175 >> 13) + 1) >> 1;
              if ((int)v175 < -536879104)
                LOWORD(v176) = 0x8000;
              if ((int)v175 <= 536862719)
                v177 = v176;
              else
                v177 = 0x7FFF;
              *v170++ = v177;
              *(_DWORD *)(a2 + 4 * (v172 + *(_DWORD *)(a2 + 4336)) + 1280) = *((_DWORD *)v174 + 256);
              ++v172;
              --v173;
            }
            while (v173);
            v165 = v70;
            v66 = 0;
            LODWORD(v68) = *(_DWORD *)(a1 + 4588);
          }
          goto LABEL_121;
        }
      }
      else
      {
        v160 = 0;
        v161 = v21[81].i32[0];
        v162 = v198;
        v163 = 1;
        v164 = v221;
        do
        {
          if (*(_DWORD *)v162 < v161)
          {
            v160 = v163;
            v161 = *(_DWORD *)v162;
          }
          ++v163;
          v162 += 1300;
        }
        while (v159 != v163);
      }
      v166 = v160;
      v167 = i8;
      do
      {
        if (v166)
          *(_DWORD *)v167 += 0x7FFFFFF;
        v167 += 1300;
        --v166;
        --v159;
      }
      while (v159);
      goto LABEL_111;
    }
    v165 = v70;
LABEL_121:
    v178 = *(unsigned int *)(a1 + 4640);
    v179 = *(_DWORD *)(a1 + 4592) - (v227 + v178) - 2;
    silk_LPC_analysis_filter((_WORD *)(v209 + 2 * v179), a2 + 2 * (v179 + (int)v68 * (int)v65), v228, v227 + v178 + 2, v178);
    v72 = 0;
    *(_DWORD *)(a2 + 4332) = *(_DWORD *)(a1 + 4592);
    *(_DWORD *)(a2 + 4348) = 1;
    LOBYTE(v71) = *(_BYTE *)(v225 + 29);
    v21 = v224;
    v56 = v223;
    v61 = v222;
    v70 = v165;
    a4 = v208;
LABEL_35:
    v73 = *(unsigned int *)(a1 + 4628);
    v74 = v226->i32[v65];
    v75 = *(_DWORD *)(v35 + 4 * v65);
    if (v75 <= 1)
      v76 = 1;
    else
      v76 = *(_DWORD *)(v35 + 4 * v65);
    v77 = __clz(v76);
    v78 = ((unint64_t)((int)((unint64_t)-(uint64_t)((((uint64_t)(0x1FFFFFFF / ((int)(v76 << (v77 - 1)) >> 16)) << 19)
                                                                * (int)(v76 << (v77 - 1))) & 0xFFFFFFF800000000) >> 32)
                            * (uint64_t)(0x1FFFFFFF / ((int)(v76 << (v77 - 1)) >> 16))) >> 16)
        + ((0x1FFFFFFF / ((int)(v76 << (v77 - 1)) >> 16)) << 16);
    v79 = v76 >> 17;
    v80 = v78 >> (15 - v77);
    v81 = v77 - 15;
    v82 = (int)0x80000000 >> v81;
    if (v78 > (int)0x80000000 >> v81)
      v82 = v78;
    if (v78 <= (int)(0x7FFFFFFFu >> v81))
      v83 = v82;
    else
      v83 = 0x7FFFFFFFu >> v81;
    v84 = v83 << v81;
    if (v79)
      v84 = v80;
    v85 = *(unsigned int *)(a1 + 4588);
    if ((int)v85 >= 1)
    {
      v86 = (uint64_t)((v84 >> 4) + 1) >> 1;
      if ((_DWORD)v85 == 1)
      {
        v87 = 0;
LABEL_51:
        v92 = v85 - v87;
        v93 = &v61[4 * v87];
        v94 = (__int16 *)(a4 + 2 * v87);
        do
        {
          v95 = *v94++;
          *(_DWORD *)v93 = (unint64_t)(v95 * (uint64_t)(int)v86) >> 16;
          v93 += 4;
          --v92;
        }
        while (v92);
        goto LABEL_53;
      }
      v87 = v85 & 0xFFFFFFFE;
      v88 = (__int16 *)(a4 + 2);
      v89 = v87;
      v90 = v207;
      do
      {
        v91 = (unint64_t)(*v88 * (uint64_t)(int)v86) >> 16;
        *((_DWORD *)v90 - 1) = (unint64_t)(*(v88 - 1) * (uint64_t)(int)v86) >> 16;
        *(_DWORD *)v90 = v91;
        v88 += 2;
        v90 += 8;
        v89 -= 2;
      }
      while (v89);
      if (v87 != v85)
        goto LABEL_51;
    }
LABEL_53:
    if ((v72 & 1) == 0)
    {
      v96 = *(int *)(a2 + 4332);
      v97 = v96 - v74 - 2;
      if (v97 < (int)v96)
      {
        v98 = ((unint64_t)((int)v206 * (uint64_t)v84) >> 14) & 0xFFFFFFFC;
        if (v65)
          LODWORD(v98) = v84;
        v99 = v97;
        v100 = v96 - v97;
        v101 = v99;
        if (v100 < 2)
          goto LABEL_61;
        v102 = a4;
        v103 = v70;
        v101 = (v100 & 0xFFFFFFFFFFFFFFFELL) + v99;
        v104 = (__int16 *)(v205 + 2 * v99);
        v105 = (_DWORD *)(v204 + 4 * v99);
        v106 = v100 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          v107 = (unint64_t)(*v104 * (uint64_t)(int)v98) >> 16;
          *(v105 - 1) = (unint64_t)(*(v104 - 1) * (uint64_t)(int)v98) >> 16;
          *v105 = v107;
          v104 += 2;
          v105 += 2;
          v106 -= 2;
        }
        while (v106);
        v70 = v103;
        a4 = v102;
        if (v100 != (v100 & 0xFFFFFFFFFFFFFFFELL))
        {
LABEL_61:
          v108 = v96 - v101;
          v109 = (_DWORD *)(v56 + 4 * v101);
          v110 = (__int16 *)(v209 + 2 * v101);
          do
          {
            v111 = *v110++;
            *v109++ = (unint64_t)(v111 * (uint64_t)(int)v98) >> 16;
            --v108;
          }
          while (v108);
        }
      }
    }
    v112 = (char)v71;
    v113 = *(_DWORD *)(a2 + 4344);
    if (v75 == v113)
    {
      v69 = v221;
    }
    else
    {
      if (v113 >= 0)
        v114 = *(_DWORD *)(a2 + 4344);
      else
        v114 = -v113;
      v115 = __clz(v114);
      v116 = v113 << (v115 - 1);
      if (v75 >= 0)
        v117 = v75;
      else
        v117 = -v75;
      v118 = __clz(v117);
      v119 = v75 << (v118 - 1);
      v120 = (0x1FFFFFFF / (v119 >> 16) * (uint64_t)v116) >> 16;
      v121 = ((unint64_t)(0x1FFFFFFF
                               / (v119 >> 16)
                               * (uint64_t)(int)(v116
                                              - (((unint64_t)((int)v120 * (uint64_t)v119) >> 29) & 0xFFFFFFF8))) >> 16)
           + v120;
      v122 = v115 - v118;
      if (v115 - v118 + 29 >= 0x30)
        v123 = 0;
      else
        v123 = v121 >> (v122 + 13);
      v124 = (int)0x80000000 >> (-13 - v122);
      if (v124 <= v121)
        v124 = v121;
      if ((int)(0x7FFFFFFFu >> (-13 - v122)) >= v121)
        v125 = v124;
      else
        v125 = 0x7FFFFFFFu >> (-13 - v122);
      v126 = v125 << (-13 - v122);
      if (v122 > -14)
        v126 = v123;
      v127 = *(_DWORD *)(a1 + 4592);
      v69 = v221;
      if (v127 >= 1)
      {
        v128 = *(_DWORD *)(a2 + 4336) - v127;
        do
        {
          *(_DWORD *)(a2 + 1280 + 4 * v128) = (unint64_t)(*(int *)(a2 + 1280 + 4 * v128) * (uint64_t)v126) >> 16;
          ++v128;
        }
        while (v128 < *(int *)(a2 + 4336));
      }
      if (v112 == 2 && !*(_DWORD *)(a2 + 4348))
      {
        v129 = *(_DWORD *)(a2 + 4332);
        v130 = v129 - v74 - 2;
        v131 = v129 - v69;
        if (v130 < v131)
        {
          v132 = v130;
          v133 = v131 <= v130 + 1 ? v130 + 1 : v131;
          v134 = v133 - v132;
          v135 = v132;
          if (v134 < 8)
            goto LABEL_143;
          v135 = (v134 & 0xFFFFFFFFFFFFFFF8) + v132;
          v136 = (int32x2_t *)(v197[0] + 4 * v132);
          v137 = v134 & 0xFFFFFFFFFFFFFFF8;
          do
          {
            v138 = vdupq_n_s32(v126);
            v139 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v138.i8, *v136), 0x10uLL), vmull_high_s32(v138, *(int32x4_t *)v136->i8), 0x10uLL);
            *(int32x4_t *)v136[-2].i8 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v138.i8, v136[-2]), 0x10uLL), vmull_high_s32(v138, *(int32x4_t *)v136[-2].i8), 0x10uLL);
            *(int32x4_t *)v136->i8 = v139;
            v136 += 4;
            v137 -= 8;
          }
          while (v137);
          if (v134 != (v134 & 0xFFFFFFFFFFFFFFF8))
          {
LABEL_143:
            do
            {
              *(_DWORD *)(v56 + 4 * v135) = (unint64_t)(*(int *)(v56 + 4 * v135) * (uint64_t)v126) >> 16;
              ++v135;
            }
            while (v135 < v131);
          }
        }
      }
      if ((int)v73 >= 1)
      {
        v140 = v126;
        v141 = v21;
        do
        {
          v142 = vdupq_n_s32(v140);
          v143 = v141[54];
          v144 = v141[55];
          v141[64] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[64].i8), 0x10uLL), vmull_high_s32(v142, v141[64]), 0x10uLL);
          v141[54] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v143.i8), 0x10uLL), vmull_high_s32(v142, v143), 0x10uLL);
          v141[55] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v144.i8), 0x10uLL), vmull_high_s32(v142, v144), 0x10uLL);
          v141[65] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[65].i8), 0x10uLL), vmull_high_s32(v142, v141[65]), 0x10uLL);
          v141[66] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[66].i8), 0x10uLL), vmull_high_s32(v142, v141[66]), 0x10uLL);
          v145 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[57].i8), 0x10uLL), vmull_high_s32(v142, v141[57]), 0x10uLL);
          v141[56] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[56].i8), 0x10uLL), vmull_high_s32(v142, v141[56]), 0x10uLL);
          v141[57] = v145;
          v141[67] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[67].i8), 0x10uLL), vmull_high_s32(v142, v141[67]), 0x10uLL);
          v141[68] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[68].i8), 0x10uLL), vmull_high_s32(v142, v141[68]), 0x10uLL);
          v146 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[59].i8), 0x10uLL), vmull_high_s32(v142, v141[59]), 0x10uLL);
          v141[58] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[58].i8), 0x10uLL), vmull_high_s32(v142, v141[58]), 0x10uLL);
          v141[59] = v146;
          v141[69] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[69].i8), 0x10uLL), vmull_high_s32(v142, v141[69]), 0x10uLL);
          v141[70] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[70].i8), 0x10uLL), vmull_high_s32(v142, v141[70]), 0x10uLL);
          v147 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[61].i8), 0x10uLL), vmull_high_s32(v142, v141[61]), 0x10uLL);
          v141[60] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[60].i8), 0x10uLL), vmull_high_s32(v142, v141[60]), 0x10uLL);
          v141[61] = v147;
          v141[71] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[71].i8), 0x10uLL), vmull_high_s32(v142, v141[71]), 0x10uLL);
          v141[72] = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[72].i8), 0x10uLL), vmull_high_s32(v142, v141[72]), 0x10uLL);
          v148 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[62].i8), 0x10uLL), vmull_high_s32(v142, v141[62]), 0x10uLL);
          v149 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[63].i8), 0x10uLL), vmull_high_s32(v142, v141[63]), 0x10uLL);
          v150 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v142.i8, *(int32x2_t *)v141[73].i8), 0x10uLL), vmull_high_s32(v142, v141[73]), 0x10uLL);
          v141[80].i32[0] = (unint64_t)(v141[80].i32[0] * (uint64_t)v140) >> 16;
          v141[80].i32[1] = (unint64_t)(v141[80].i32[1] * (uint64_t)v140) >> 16;
          v151 = (unint64_t)(v141->i32[1] * (uint64_t)v140) >> 16;
          v141->i32[0] = (unint64_t)(v141->i32[0] * (uint64_t)v140) >> 16;
          v141->i32[1] = v151;
          v152 = (unint64_t)(v141->i32[3] * (uint64_t)v140) >> 16;
          v141->i32[2] = (unint64_t)(v141->i32[2] * (uint64_t)v140) >> 16;
          v141->i32[3] = v152;
          v153 = (unint64_t)(v141[1].i32[1] * (uint64_t)v140) >> 16;
          v141[1].i32[0] = (unint64_t)(v141[1].i32[0] * (uint64_t)v140) >> 16;
          v141[1].i32[1] = v153;
          v154 = (unint64_t)(v141[1].i32[3] * (uint64_t)v140) >> 16;
          v141[1].i32[2] = (unint64_t)(v141[1].i32[2] * (uint64_t)v140) >> 16;
          v141[1].i32[3] = v154;
          v155 = (unint64_t)(v141[2].i32[1] * (uint64_t)v140) >> 16;
          v141[2].i32[0] = (unint64_t)(v141[2].i32[0] * (uint64_t)v140) >> 16;
          v141[2].i32[1] = v155;
          v156 = (unint64_t)(v141[2].i32[3] * (uint64_t)v140) >> 16;
          v141[2].i32[2] = (unint64_t)(v141[2].i32[2] * (uint64_t)v140) >> 16;
          v141[2].i32[3] = v156;
          v157 = (unint64_t)(v141[3].i32[1] * (uint64_t)v140) >> 16;
          v141[3].i32[0] = (unint64_t)(v141[3].i32[0] * (uint64_t)v140) >> 16;
          v141[3].i32[1] = v157;
          v158 = (unint64_t)(v141[3].i32[3] * (uint64_t)v140) >> 16;
          v141[3].i32[2] = (unint64_t)(v141[3].i32[2] * (uint64_t)v140) >> 16;
          v141[3].i32[3] = v158;
          v141[74].i32[0] = (unint64_t)(v141[74].i32[0] * (uint64_t)v140) >> 16;
          v141[74].i32[1] = (unint64_t)(v141[74].i32[1] * (uint64_t)v140) >> 16;
          v141[74].i32[2] = (unint64_t)(v141[74].i32[2] * (uint64_t)v140) >> 16;
          v141[74].i32[3] = (unint64_t)(v141[74].i32[3] * (uint64_t)v140) >> 16;
          v141[75].i32[0] = (unint64_t)(v141[75].i32[0] * (uint64_t)v140) >> 16;
          v141[75].i32[1] = (unint64_t)(v141[75].i32[1] * (uint64_t)v140) >> 16;
          v141[75].i32[2] = (unint64_t)(v141[75].i32[2] * (uint64_t)v140) >> 16;
          v141[75].i32[3] = (unint64_t)(v141[75].i32[3] * (uint64_t)v140) >> 16;
          v141[76].i32[0] = (unint64_t)(v141[76].i32[0] * (uint64_t)v140) >> 16;
          v141[76].i32[1] = (unint64_t)(v141[76].i32[1] * (uint64_t)v140) >> 16;
          v141[76].i32[2] = (unint64_t)(v141[76].i32[2] * (uint64_t)v140) >> 16;
          v141[76].i32[3] = (unint64_t)(v141[76].i32[3] * (uint64_t)v140) >> 16;
          v141[77].i32[0] = (unint64_t)(v141[77].i32[0] * (uint64_t)v140) >> 16;
          v141[77].i32[1] = (unint64_t)(v141[77].i32[1] * (uint64_t)v140) >> 16;
          v141[77].i32[2] = (unint64_t)(v141[77].i32[2] * (uint64_t)v140) >> 16;
          v141[77].i32[3] = (unint64_t)(v141[77].i32[3] * (uint64_t)v140) >> 16;
          v141[78].i32[0] = (unint64_t)(v141[78].i32[0] * (uint64_t)v140) >> 16;
          v141[78].i32[1] = (unint64_t)(v141[78].i32[1] * (uint64_t)v140) >> 16;
          v141[78].i32[2] = (unint64_t)(v141[78].i32[2] * (uint64_t)v140) >> 16;
          v141[78].i32[3] = (unint64_t)(v141[78].i32[3] * (uint64_t)v140) >> 16;
          v141[79].i32[0] = (unint64_t)(v141[79].i32[0] * (uint64_t)v140) >> 16;
          v141[79].i32[1] = (unint64_t)(v141[79].i32[1] * (uint64_t)v140) >> 16;
          v141[79].i32[2] = (unint64_t)(v141[79].i32[2] * (uint64_t)v140) >> 16;
          v141[79].i32[3] = (unint64_t)(v141[79].i32[3] * (uint64_t)v140) >> 16;
          v141[62] = v148;
          v141[63] = v149;
          v141[73] = v150;
          v141 = (int32x4_t *)((char *)v141 + 1300);
          --v73;
        }
        while (v73);
      }
      *(_DWORD *)(a2 + 4344) = *(_DWORD *)(v35 + 4 * v65);
      v75 = *(_DWORD *)(v35 + 4 * v65);
      LODWORD(v85) = *(_DWORD *)(a1 + 4588);
      LODWORD(v73) = *(_DWORD *)(a1 + 4628);
    }
    silk_noise_shape_quantizer_del_dec(a2, v21, v112, (uint64_t)v61, a5, v63, v56, (uint64_t)v230, (__int16 *)v228, (__int16 *)(v219 + 2 * (5 * v65)), (__int16 *)(v220 + 2 * (24 * v65)), v227, (v70 << 15) & 0xFFFF0000 | (v70 >> 2), *(_DWORD *)(v212 + 4 * v65), *(_DWORD *)(v215 + 4 * v65), v75, v213, v217, v85,
      v66,
      *(_QWORD *)(a1 + 4636),
      HIDWORD(*(_QWORD *)(a1 + 4636)),
      *(_DWORD *)(a1 + 4672),
      v73,
      &v229,
      v69);
    v61 = v222;
    v56 = v223;
    v21 = v224;
    v68 = *(int *)(a1 + 4588);
    a4 += 2 * v68;
    a5 += v68;
    v63 += 2 * v68;
    ++v65;
    v64 = *(int *)(a1 + 4580);
    ++v66;
    v35 = v216;
  }
  while (v65 < v64);
  v22 = *(_DWORD *)(a1 + 4628);
  v57 = *(_DWORD *)(a1 + 4588);
  v55 = v221;
LABEL_123:
  if (v22 <= 1)
  {
    v180 = 0;
  }
  else
  {
    v180 = 0;
    v181 = v21[81].i32[0];
    v182 = &v21[162].i32[1];
    for (i = 1; i != v22; ++i)
    {
      if (*v182 < v181)
      {
        v180 = i;
        v181 = *v182;
      }
      v182 += 325;
    }
  }
  *(_BYTE *)(v225 + 34) = v21[80].i32[325 * v180 + 3];
  if (v55 >= 1)
  {
    v184 = v229 + v55;
    v185 = (uint64_t)*(int *)(v35 + 4 * ((int)v64 - 1)) >> 6;
    v186 = -(uint64_t)v55;
    do
    {
      v184 = (int)(v184 - 1) % 40 + ((int)(v184 - 1) % 40 < 0 ? 0x28 : 0);
      v187 = &v21->i8[1300 * v180 + 4 * v184];
      *(_BYTE *)(a5 + v186) = ((*((_DWORD *)v187 + 136) >> 9) + 1) >> 1;
      v188 = (unint64_t)(*((int *)v187 + 176) * (uint64_t)(int)v185) >> 16;
      v189 = ((v188 >> 7) + 1) >> 1;
      if ((int)v188 < -8388736)
        LOWORD(v189) = 0x8000;
      if ((int)v188 <= 8388479)
        v190 = v189;
      else
        v190 = 0x7FFF;
      *(_WORD *)(v63 + 2 * v186) = v190;
      *(_DWORD *)(a2 + 4 * ((int)v186 + *(_DWORD *)(a2 + 4336)) + 1280) = *((_DWORD *)v187 + 256);
    }
    while (!__CFADD__(v186++, 1));
    v57 = *(_DWORD *)(a1 + 4588);
  }
  v192 = &v21->i8[1300 * v180];
  v193 = &v192[4 * v57];
  v194 = *((_OWORD *)v193 + 1);
  *(_OWORD *)(a2 + 3840) = *(_OWORD *)v193;
  *(_OWORD *)(a2 + 3856) = v194;
  v195 = *((_OWORD *)v193 + 3);
  *(_OWORD *)(a2 + 3872) = *((_OWORD *)v193 + 2);
  *(_OWORD *)(a2 + 3888) = v195;
  *(_OWORD *)(a2 + 4256) = *((_OWORD *)v192 + 76);
  *(_OWORD *)(a2 + 4272) = *((_OWORD *)v192 + 77);
  *(_OWORD *)(a2 + 4288) = *((_OWORD *)v192 + 78);
  *(_OWORD *)(a2 + 4304) = *((_OWORD *)v192 + 79);
  *(_OWORD *)(a2 + 4224) = *((_OWORD *)v192 + 74);
  *(_OWORD *)(a2 + 4240) = *((_OWORD *)v192 + 75);
  *(_QWORD *)(a2 + 4320) = *((_QWORD *)v192 + 160);
  *(_DWORD *)(a2 + 4328) = v226->i32[*(int *)(a1 + 4580) - 1];
  memmove((void *)a2, (const void *)(a2 + 2 * *(int *)(a1 + 4584)), 2 * *(int *)(a1 + 4592));
  return memmove((void *)(a2 + 1280), (const void *)(a2 + 1280 + 4 * *(int *)(a1 + 4584)), 4 * *(int *)(a1 + 4592));
}

uint64_t silk_noise_shape_quantizer_del_dec(uint64_t a1, _OWORD *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 *a9, __int16 *a10, __int16 *a11, int a12, int a13, __int16 a14, int a15, int a16, unsigned int a17, int a18, int a19, int a20,int a21,int a22,__int16 a23,int a24,int *a25,unsigned int a26)
{
  _OWORD *v26;
  uint64_t v27;
  uint64_t result;
  uint64_t v29;
  uint64_t v30;
  int v31;
  _OWORD *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  _DWORD *v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  char *v49;
  int v50;
  int v51;
  int v52;
  BOOL v53;
  int v54;
  int v55;
  int v56;
  int v57;
  BOOL v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  char *v66;
  int *v67;
  int v68;
  _DWORD *v69;
  int v70;
  int v71;
  int v72;
  int v73;
  _DWORD *v74;
  __int16 *v75;
  uint64_t v76;
  _DWORD *v77;
  int v78;
  int v79;
  int v80;
  uint64_t v81;
  int *v82;
  int v83;
  char *v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  char *v103;
  uint64_t v104;
  int v105;
  int v106;
  int v107;
  int v108;
  uint64_t v109;
  int v110;
  _DWORD *v111;
  char *v112;
  uint64_t v113;
  int v114;
  int v115;
  int v116;
  char *v117;
  uint64_t i;
  int v119;
  int v120;
  char *v121;
  char *v122;
  _DWORD *v123;
  uint64_t v124;
  unint64_t v125;
  unsigned int v126;
  __int16 v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  _OWORD *v131;
  uint64_t v132;
  char *v133;
  char *v134;
  int v135;
  int v136;
  int v137;
  int v138;
  int v139;
  uint64_t v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  char *v144;
  char *v145;
  __int16 *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  char *v151;
  _OWORD *v152;
  char *v153;
  char *v154;
  __int16 *v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  int v159;
  int v160;
  int *v161;
  int v162;
  int32x2_t *v163;
  int v164;
  uint64_t v165;
  uint64_t v166;
  int *v167;
  uint64_t v168;
  uint64_t v169;
  _OWORD *v170;
  int v171;
  int v172;
  int v173;
  int v174;
  __int16 *v175;
  int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  int v184;
  uint64_t v185;
  int v186;
  int v187;
  int v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  char *v200;
  uint64_t v201;
  uint64_t v202;

  v169 = a8;
  v150 = a7;
  v148 = a6;
  v147 = a5;
  v189 = a4;
  v164 = a3;
  v26 = a2;
  v149 = a1;
  v27 = a24;
  v202 = *MEMORY[0x24BDAC8D0];
  result = MEMORY[0x24BDAC7A8](a1, a2);
  v200 = (char *)&v144 - v29;
  v165 = v30;
  if ((int)v30 >= 1)
  {
    v201 = 0;
    v163 = (int32x2_t *)(v149 + 4332);
    v161 = (int *)(v150 + 4 * (*(_DWORD *)(v149 + 4332) - a12 + 2));
    v160 = a16 >> 6;
    v31 = *(_DWORD *)(v149 + 4336);
    v162 = a12;
    v167 = (int *)(v149 + 4 * (v31 - a12 + 1) + 1280);
    v157 = (__int16)a13;
    v156 = (uint64_t)a13 >> 16;
    v187 = a22;
    v186 = a22 >> 1;
    v159 = a20;
    v184 = a21 >> 1;
    v185 = a21;
    v198 = a21 - 1;
    v183 = a14;
    v182 = (__int16)a15;
    v181 = (uint64_t)a15 >> 16;
    v178 = (a17 >> 1) - 512;
    v171 = 512 - (a17 >> 1);
    v188 = a17;
    v173 = (__int16)(944 - a18) * (__int16)a17;
    v177 = a18 + 944;
    v176 = (__int16)(a18 + 944) * (__int16)a17;
    v146 = a10;
    v172 = a18 - 944;
    v179 = (__int16)a17;
    v180 = (__int16)a17 * a18;
    v174 = a18 - 80;
    v168 = a26;
    v166 = (int)a26;
    v155 = a11;
    v175 = a11 + 2;
    v154 = (char *)v26 + 1188;
    v145 = v200 + 60;
    v153 = v200 + 32;
    v152 = v26 + 24;
    v144 = v200 + 88;
    result = 1300;
    v151 = v200 + 12;
    v32 = v26 + 4;
    v158 = 1300 * a24;
    do
    {
      if (v164 == 2)
      {
        v33 = 2
            * (((((*v161 * (uint64_t)*v146) << 16)
               + ((unint64_t)(*(v161 - 1) * (uint64_t)v146[1]) >> 16 << 32)
               + ((unint64_t)(*(v161 - 2) * (uint64_t)v146[2]) >> 16 << 32)
               + (((*(v161 - 3) * (uint64_t)v146[3]) << 16) & 0x7FFFFFFF00000000)
               + 0x200000000) >> 32)
             + ((unint64_t)(v146[4] * (uint64_t)*(v161 - 4)) >> 16));
        ++v161;
        if (v162 >= 1)
          goto LABEL_9;
      }
      else
      {
        v33 = 0;
        if (v162 >= 1)
        {
LABEL_9:
          LODWORD(v199) = v33
                        - 4
                        * (((unint64_t)(*(v167 - 1) * (uint64_t)(int)v156) >> 16)
                         + ((unint64_t)((int)v157 * (uint64_t)vqadds_s32(*v167, *(v167 - 2))) >> 16));
          ++v167;
          v170 = v32;
          if (a24 <= 0)
            goto LABEL_7;
LABEL_10:
          v35 = 0;
          v36 = *a9;
          v196 = a9[1];
          v197 = v36;
          v194 = a9[2];
          v195 = (uint64_t)v26 + 4 * v201 + 60;
          v37 = a9[3];
          v192 = a9[4];
          v193 = v37;
          v38 = a9[5];
          v190 = a9[6];
          v191 = v38;
          v39 = a9[7];
          v40 = a9[8];
          v41 = a9[9];
          v42 = v154;
          v43 = *v155;
          v44 = v155[v198];
          while (2)
          {
            v66 = (char *)v26 + 1300 * v35;
            *((_DWORD *)v66 + 322) = 196314165 * *((_DWORD *)v66 + 322) + 907633515;
            v67 = (int *)(v195 + 1300 * v35);
            v68 = v186
                + ((unint64_t)(*v67 * (uint64_t)(int)v197) >> 16)
                + ((unint64_t)(*(v67 - 1) * (uint64_t)(int)v196) >> 16)
                + ((unint64_t)(*(v67 - 2) * (uint64_t)(int)v194) >> 16)
                + ((unint64_t)(*(v67 - 3) * (uint64_t)(int)v193) >> 16)
                + ((unint64_t)(*(v67 - 4) * (uint64_t)(int)v192) >> 16)
                + ((unint64_t)(*(v67 - 5) * (uint64_t)(int)v191) >> 16)
                + ((unint64_t)(*(v67 - 6) * (uint64_t)(int)v190) >> 16)
                + ((unint64_t)(*(v67 - 7) * (uint64_t)v39) >> 16)
                + ((unint64_t)(*(v67 - 8) * (uint64_t)v40) >> 16)
                + ((unint64_t)(*(v67 - 9) * (uint64_t)v41) >> 16);
            if (v187 == 16)
              v68 += ((unint64_t)(a9[10] * (uint64_t)*(v67 - 10)) >> 16)
                   + ((unint64_t)(a9[11] * (uint64_t)*(v67 - 11)) >> 16)
                   + ((unint64_t)(a9[12] * (uint64_t)*(v67 - 12)) >> 16)
                   + ((unint64_t)(a9[13] * (uint64_t)*(v67 - 13)) >> 16)
                   + ((unint64_t)(a9[14] * (uint64_t)*(v67 - 14)) >> 16)
                   + ((unint64_t)(a9[15] * (uint64_t)*(v67 - 15)) >> 16);
            v69 = (_DWORD *)v26 + 325 * v35;
            v70 = v69[296];
            v71 = v69[321] + ((unint64_t)(a23 * (uint64_t)v70) >> 16);
            v72 = v70 + ((unint64_t)(a23 * ((int)v69[297] - (uint64_t)v71)) >> 16);
            v69[296] = v71;
            v73 = v184 + ((unint64_t)(v43 * (uint64_t)v71) >> 16);
            if ((int)v185 >= 3)
            {
              v74 = v42;
              v75 = v175;
              v76 = 2;
              v77 = v42;
              do
              {
                v78 = v74[1];
                v79 = *v74 + ((unint64_t)(a23 * (uint64_t)(v78 - v72)) >> 16);
                v80 = v73 + ((unint64_t)(*(v75 - 1) * (uint64_t)v72) >> 16);
                v81 = (int)v77[2];
                v77 += 2;
                *v74 = v72;
                v74[1] = v79;
                v72 = v78 + ((unint64_t)(a23 * (v81 - v79)) >> 16);
                v73 = v80 + ((unint64_t)(*v75 * (uint64_t)v79) >> 16);
                v76 += 2;
                v75 += 2;
                v74 = v77;
              }
              while (v76 < a21);
            }
            v82 = (int *)(v66 + 1288);
            v83 = 16 * v68;
            v84 = (char *)v26 + 1300 * v35;
            *(_DWORD *)&v84[4 * v198 + 1184] = v72;
            v85 = v73 + ((unint64_t)(v44 * (uint64_t)v72) >> 16);
            v86 = *((_DWORD *)v84 + 320);
            v87 = (((unint64_t)((int)v183 * (uint64_t)v86) >> 14) & 0xFFFFFFFC) + 8 * v85;
            v34 = *a25;
            v88 = 4
                * (((unint64_t)((int)v182 * (uint64_t)*(int *)&v84[4 * v34 + 1024]) >> 16)
                 + ((unint64_t)(v86 * (uint64_t)(int)v181) >> 16));
            v89 = *(_DWORD *)(v189 + 4 * v201);
            v90 = v89 - (((vqsubs_s32(v83 + v199, vqadds_s32(v87, v88)) >> 3) + 1) >> 1);
            v91 = *v82;
            if (*v82 >= 0)
              v92 = v90;
            else
              v92 = -v90;
            if (v92 <= -31744)
              v92 = -31744;
            if (v92 >= 30720)
              v92 = 30720;
            v93 = v92 - a18;
            if (v188 < 2049)
            {
LABEL_43:
              if (v93 >= 1024)
                goto LABEL_11;
LABEL_44:
              v94 = v93 >> 10;
              v47 = v180;
              v48 = v176;
              v45 = a18;
              v46 = v177;
              if (v93 >> 10)
              {
                v95 = a18 + (v93 & 0xFFFFFC00);
                v96 = v95 + 80;
                v97 = v95 + 1104;
                v47 = (__int16)(-80 - v95) * v179;
                v98 = (__int16)(-1104 - v95) * v179;
                if (v94 == -1)
                  v47 = v173;
                v48 = v180;
                if (v94 == -1)
                {
                  v45 = v172;
                }
                else
                {
                  v48 = v98;
                  v45 = v96;
                }
                if (v94 == -1)
                  v46 = a18;
                else
                  v46 = v97;
              }
            }
            else
            {
              if (v93 > v178)
              {
                v93 -= v178;
                goto LABEL_43;
              }
              if (v93 >= v171)
              {
                v48 = v180;
                if (v93 >= 0)
                  v47 = v180;
                else
                  v47 = v173;
                if (v93 < 0)
                {
                  v45 = v172;
                }
                else
                {
                  v48 = v176;
                  v45 = a18;
                }
                v46 = v177;
                if (v93 < 0)
                  v46 = a18;
              }
              else
              {
                v93 += v178;
                if (v93 < 1024)
                  goto LABEL_44;
LABEL_11:
                v45 = v174 + (v93 & 0xFFFFFC00);
                v46 = v45 + 1024;
                v47 = (__int16)(v174 + (v93 & 0xFC00)) * v179;
                v48 = (__int16)(v174 + (v93 & 0xFC00) + 1024) * v179;
              }
            }
            v49 = &v200[56 * v35];
            v50 = (v47 + (__int16)(v92 - v45) * (__int16)(v92 - v45)) >> 10;
            v51 = (v48 + (__int16)(v92 - v46) * (__int16)(v92 - v46)) >> 10;
            v52 = *((_DWORD *)v26 + 325 * v35 + 324);
            v53 = v50 <= v51;
            if (v50 >= v51)
              v54 = v51;
            else
              v54 = v50;
            if (v50 > v51)
              v51 = v50;
            if (v53)
              v55 = v45;
            else
              v55 = v46;
            if (!v53)
              v46 = v45;
            v56 = v51 + v52;
            *(_DWORD *)v49 = v55;
            *((_DWORD *)v49 + 1) = v54 + v52;
            v57 = 16 * v55;
            v58 = v91 < 0;
            if (v91 >= 0)
              v59 = v57;
            else
              v59 = -v57;
            v60 = v59 + v33;
            v61 = v60 + v83;
            v62 = 16 * v89;
            v63 = 16 * v46;
            if (v58)
              v63 = -16 * v46;
            *((_DWORD *)v49 + 4) = v61 - v62;
            *((_DWORD *)v49 + 5) = vqsubs_s32(v61 - v62 - v87, v88);
            *((_DWORD *)v49 + 6) = v60;
            *((_DWORD *)v49 + 7) = v46;
            *((_DWORD *)v49 + 2) = v61;
            *((_DWORD *)v49 + 3) = v61 - v62 - v87;
            result = 1300;
            v64 = v63 + v33 + v83;
            v65 = v64 - v62;
            *((_DWORD *)v49 + 10) = v65 - v87;
            *((_DWORD *)v49 + 11) = v65;
            *((_DWORD *)v49 + 12) = vqsubs_s32(v65 - v87, v88);
            *((_DWORD *)v49 + 13) = v63 + v33;
            *((_DWORD *)v49 + 8) = v56;
            *((_DWORD *)v49 + 9) = v64;
            ++v35;
            v42 += 325;
            if (v35 == a24)
              goto LABEL_65;
            continue;
          }
        }
      }
      LODWORD(v199) = 0;
      v170 = v32;
      if (a24 > 0)
        goto LABEL_10;
LABEL_7:
      LODWORD(v34) = *a25;
LABEL_65:
      v99 = ((int)v34 - 1) % 40;
      v100 = v99 + 40;
      if (v99 >= 0)
        v100 = ((int)v34 - 1) % 40;
      *a25 = v100;
      v101 = *((_DWORD *)v200 + 1);
      if (a24 <= 1)
      {
        v102 = 0;
      }
      else
      {
        v102 = 0;
        v103 = v145;
        v104 = 1;
        v105 = *((_DWORD *)v200 + 1);
        do
        {
          v107 = *(_DWORD *)v103;
          v103 += 56;
          v106 = v107;
          if (v107 < v105)
          {
            v102 = v104;
            v105 = v106;
          }
          ++v104;
        }
        while (a24 != v104);
      }
      v108 = (v100 + (int)v168) % 40;
      v109 = v108;
      if (a24 < 1)
      {
        v116 = 0;
        v115 = 0;
        v114 = *((_DWORD *)v200 + 8);
        goto LABEL_88;
      }
      v110 = *((_DWORD *)v26 + 325 * v102 + v108 + 96);
      v111 = (_DWORD *)v152 + v108;
      v112 = v153;
      v113 = a24;
      do
      {
        if (*v111 != v110)
        {
          *((_DWORD *)v112 - 7) += 0x7FFFFFF;
          *(_DWORD *)v112 += 0x7FFFFFF;
        }
        v111 += 325;
        v112 += 56;
        --v113;
      }
      while (v113);
      v101 = *((_DWORD *)v200 + 1);
      v114 = *((_DWORD *)v200 + 8);
      if (a24 >= 2)
      {
        v115 = 0;
        v116 = 0;
        v117 = v144;
        for (i = 1; i != a24; ++i)
        {
          if (*((_DWORD *)v117 - 7) > v101)
          {
            v115 = i;
            v101 = *((_DWORD *)v117 - 7);
          }
          v120 = *(_DWORD *)v117;
          v117 += 56;
          v119 = v120;
          if (v120 < v114)
          {
            v116 = i;
            v114 = v119;
          }
        }
LABEL_88:
        if (v114 >= v101)
          goto LABEL_90;
LABEL_89:
        v199 = v109;
        memcpy((char *)v26 + 1300 * v115 + 4 * v201, (char *)v26 + 1300 * v116 + 4 * v201, 1300 - 4 * v201);
        v109 = v199;
        result = 1300;
        v121 = &v200[56 * v115];
        v122 = &v200[56 * v116];
        *(_OWORD *)v121 = *(_OWORD *)(v122 + 28);
        *(_OWORD *)(v121 + 12) = *(_OWORD *)(v122 + 40);
        goto LABEL_90;
      }
      v116 = 0;
      v115 = 0;
      if (v114 < v101)
        goto LABEL_89;
LABEL_90:
      if (v159 > 0 || v201 >= v166)
      {
        v123 = (_DWORD *)v26 + 325 * v102 + v109;
        v124 = v201 - v166;
        *(_BYTE *)(v147 + v201 - v166) = ((v123[136] >> 9) + 1) >> 1;
        v125 = (unint64_t)(*(int *)(v169 + 4 * v109) * (uint64_t)(int)v123[176]) >> 16;
        v126 = ((v125 >> 7) + 1) >> 1;
        if ((int)v125 < -8388736)
          LOWORD(v126) = 0x8000;
        if ((int)v125 <= 8388479)
          v127 = v126;
        else
          v127 = 0x7FFF;
        *(_WORD *)(v148 + 2 * v124) = v127;
        v128 = v149;
        v129 = v168;
        *(_DWORD *)(v149 + 4 * (*(_DWORD *)(v149 + 4336) - (int)v168) + 1280) = v123[256];
        *(_DWORD *)(v150 + 4 * (*(_DWORD *)(v128 + 4332) - v129)) = v123[216];
      }
      *v163 = vadd_s32(*v163, (int32x2_t)0x100000001);
      v130 = v158;
      v131 = v170;
      if (a24 >= 1)
      {
        v132 = 0;
        v133 = v151;
        do
        {
          v134 = (char *)v26 + v132;
          *((_QWORD *)v134 + 160) = *(_QWORD *)v133;
          v136 = *((_DWORD *)v133 - 2);
          v135 = *((_DWORD *)v133 - 1);
          *(_DWORD *)((char *)v131 + v132) = v135;
          *(_DWORD *)((char *)v26 + 4 * *a25 + v132 + 704) = v135;
          v137 = *((_DWORD *)v133 - 3);
          *(_DWORD *)((char *)v26 + 4 * *a25 + v132 + 544) = v137;
          v138 = *((_DWORD *)v133 + 2);
          *(_DWORD *)((char *)v26 + 4 * *a25 + v132 + 864) = 2 * *((_DWORD *)v133 + 3);
          *(_DWORD *)((char *)v26 + 4 * *a25 + v132 + 1024) = v138;
          v139 = *(_DWORD *)((char *)v26 + v132 + 1288) + (((v137 >> 9) + 1) >> 1);
          *((_DWORD *)v134 + 322) = v139;
          *(_DWORD *)((char *)v26 + 4 * *a25 + v132 + 384) = v139;
          *((_DWORD *)v134 + 324) = v136;
          v132 += 1300;
          v133 += 56;
        }
        while (v130 != v132);
      }
      *(_DWORD *)(v169 + 4 * *a25) = v160;
      v32 = (_OWORD *)((char *)v131 + 4);
      ++v201;
    }
    while (v201 != v165);
  }
  if (a24 >= 1)
  {
    v140 = 4 * (int)v165;
    do
    {
      v141 = *(_OWORD *)((char *)v26 + v140);
      v142 = *(_OWORD *)((char *)v26 + v140 + 16);
      v143 = *(_OWORD *)((char *)v26 + v140 + 48);
      v26[2] = *(_OWORD *)((char *)v26 + v140 + 32);
      v26[3] = v143;
      *v26 = v141;
      v26[1] = v142;
      v26 = (_OWORD *)((char *)v26 + 1300);
      --v27;
    }
    while (v27);
  }
  return result;
}

float32x4_t *opus_pcm_soft_clip(float32x4_t *result, int a2, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  float32x4_t *v6;
  float32x4_t v7;
  float32x4_t v8;
  uint64_t v9;
  float32x4_t v10;
  float32x4_t v11;
  uint64_t v12;
  float *v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  float *v17;
  float *v18;
  float v19;
  float *v20;
  uint64_t v21;
  float v22;
  uint64_t v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  float v29;
  float v31;
  float v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  float v37;
  uint64_t v38;
  float v39;
  float v40;
  _BOOL4 v41;
  float v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  float32x4_t *v47;
  float32x4_t v48;
  unint64_t v49;
  unint64_t v50;
  _BOOL4 v51;
  float v52;
  float v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  float v57;

  if (!a4 || !result || a2 < 1 || a3 < 1)
    return result;
  v4 = (a3 * a2);
  if ((int)v4 >= 1)
  {
    if (v4 >= 8)
    {
      v5 = v4 & 0x7FFFFFF8;
      v6 = result + 1;
      v7.i64[0] = 0x4000000040000000;
      v7.i64[1] = 0x4000000040000000;
      v8.i64[0] = 0xC0000000C0000000;
      v8.i64[1] = 0xC0000000C0000000;
      v9 = v4 & 0xFFFFFFF8;
      do
      {
        v10 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v6[-1], v7), (int8x16_t)v7, (int8x16_t)v6[-1]);
        v11 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*v6, v7), (int8x16_t)v7, *(int8x16_t *)v6);
        v6[-1] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v8, v10), (int8x16_t)v8, (int8x16_t)v10);
        *(int8x16_t *)v6 = vbslq_s8((int8x16_t)vcgtq_f32(v8, v11), (int8x16_t)v8, (int8x16_t)v11);
        v6 += 2;
        v9 -= 8;
      }
      while (v9);
      if (v5 == v4)
        goto LABEL_17;
    }
    else
    {
      v5 = 0;
    }
    v12 = v4 - v5;
    v13 = &result->f32[v5];
    do
    {
      v14 = *v13;
      if (*v13 > 2.0)
        v14 = 2.0;
      if (v14 < -2.0)
        v14 = -2.0;
      *v13++ = v14;
      --v12;
    }
    while (v12);
  }
LABEL_17:
  v15 = 0;
  v16 = 4 * a3;
  v17 = (float *)result;
  do
  {
    v18 = &result->f32[v15];
    v19 = *(float *)(a4 + 4 * v15);
    v20 = v17;
    v21 = a2;
    do
    {
      v22 = v19 * *v20;
      if (v22 >= 0.0)
        break;
      *v20 = *v20 + (float)(v22 * *v20);
      v20 = (float *)((char *)v20 + v16);
      --v21;
    }
    while (v21);
    v23 = 0;
    v24 = *v18;
    while (1)
    {
      v25 = v23;
      v26 = v23;
      if ((int)v23 < a2)
      {
        v27 = a2 - (uint64_t)(int)v23;
        v28 = v16 * (int)v25;
        v26 = v25;
        while (1)
        {
          v29 = *(float *)((char *)v17 + v28);
          if (v29 > 1.0 || v29 < -1.0)
            break;
          v26 = (v26 + 1);
          v28 += v16;
          if (!--v27)
            goto LABEL_70;
        }
      }
      if ((_DWORD)v26 == a2)
        break;
      v31 = v18[(int)v26 * a3];
      v32 = fabsf(v31);
      v23 = (int)v26;
      v33 = v26 + 1;
      v34 = v16 * ((int)v26 - 1);
      v35 = (int)v26;
      do
      {
        if (v35-- < 1)
        {
          v33 = v26 & ((int)v26 >> 31);
          if ((int)v26 < a2)
            goto LABEL_36;
          goto LABEL_45;
        }
        v37 = v31 * *(float *)((char *)v17 + v34);
        --v33;
        v34 -= v16;
      }
      while (v37 >= 0.0);
      if ((int)v26 < a2)
      {
LABEL_36:
        v38 = v16 * (int)v26;
        while (1)
        {
          v39 = *(float *)((char *)v17 + v38);
          if ((float)(v31 * v39) < 0.0)
            break;
          v40 = fabsf(v39);
          if (v40 > v32)
          {
            v32 = v40;
            LODWORD(v26) = v23;
          }
          ++v23;
          v38 += v16;
          if (a2 == v23)
          {
            v23 = a2;
            break;
          }
        }
        if (v33)
          goto LABEL_43;
        goto LABEL_46;
      }
LABEL_45:
      v23 = v26;
      if (v33)
      {
LABEL_43:
        v41 = 0;
        goto LABEL_47;
      }
LABEL_46:
      v41 = (float)(v31 * *v18) >= 0.0;
LABEL_47:
      if (v31 <= 0.0)
        v42 = (float)((float)(v32 + -1.0) / (float)(v32 * v32))
            + (float)((float)((float)(v32 + -1.0) / (float)(v32 * v32)) * 0.00000024);
      else
        v42 = -(float)((float)((float)(v32 + -1.0) / (float)(v32 * v32))
                     + (float)((float)((float)(v32 + -1.0) / (float)(v32 * v32)) * 0.00000024));
      if (v33 < (int)v23)
      {
        v43 = v33;
        v44 = (int)v23 - (uint64_t)v33;
        if (v44 < 8)
          goto LABEL_56;
        if (a3 != 1)
          goto LABEL_56;
        v45 = v16 * v33;
        v46 = v44 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v47 = (float32x4_t *)((char *)v17 + v45);
          v48 = vmlaq_f32(*(float32x4_t *)((char *)v17 + v45 + 16), *(float32x4_t *)((char *)v17 + v45 + 16), vmulq_n_f32(*(float32x4_t *)((char *)v17 + v45 + 16), v42));
          *v47 = vmlaq_f32(*(float32x4_t *)((char *)v17 + v45), *(float32x4_t *)((char *)v17 + v45), vmulq_n_f32(*(float32x4_t *)((char *)v17 + v45), v42));
          v47[1] = v48;
          v45 += 32;
          v46 -= 8;
        }
        while (v46);
        v43 = (v44 & 0xFFFFFFFFFFFFFFF8) + v33;
        if (v44 != (v44 & 0xFFFFFFFFFFFFFFF8))
        {
LABEL_56:
          v49 = (int)v23 - v43;
          v50 = v16 * v43;
          do
          {
            *(float *)((char *)v17 + v50) = *(float *)((char *)v17 + v50)
                                          + (float)((float)(v42 * *(float *)((char *)v17 + v50))
                                                  * *(float *)((char *)v17 + v50));
            v50 += v16;
            --v49;
          }
          while (v49);
        }
      }
      v51 = (int)v26 > 1 && v41;
      if (v51 && (int)v25 < (int)v26)
      {
        v52 = v24 - *v18;
        v53 = v52 / (float)(int)v26;
        v54 = (int)v25;
        v55 = v26 - (uint64_t)(int)v25;
        v56 = v16 * v54;
        do
        {
          v52 = v52 - v53;
          v57 = v52 + *(float *)((char *)v17 + v56);
          if (v57 > 1.0)
            v57 = 1.0;
          if (v57 < -1.0)
            v57 = -1.0;
          *(float *)((char *)v17 + v56) = v57;
          v56 += v16;
          --v55;
        }
        while (v55);
      }
      if ((_DWORD)v23 == a2)
        goto LABEL_71;
    }
LABEL_70:
    v42 = 0.0;
LABEL_71:
    *(float *)(a4 + 4 * v15++) = v42;
    ++v17;
  }
  while (v15 != a3);
  return result;
}

uint64_t opus_packet_parse_impl(unsigned __int8 *a1, unsigned int a2, int a3, _BYTE *a4, char **a5, int16x8_t *a6, _DWORD *a7, _DWORD *a8)
{
  uint64_t v8;
  int v9;
  unsigned int v10;
  int v11;
  BOOL v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  unint64_t v17;
  int v18;
  char *v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  __int16 *v25;
  signed int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  char v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  int16x8_t *v38;
  uint64_t v39;
  signed int v40;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int16x8_t *v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  int16x8_t v51;
  uint64_t v52;
  __int16 *v53;

  v8 = 0xFFFFFFFFLL;
  if ((a2 & 0x80000000) != 0 || !a6)
    return v8;
  if (!a2)
    return 4294967292;
  v9 = (char)*a1;
  v10 = *a1;
  v11 = (v10 >> 3) & 3;
  v12 = v11 == 3;
  v13 = 48000 << v11;
  if (v12)
    v14 = 2880;
  else
    v14 = (42949673 * (unint64_t)v13) >> 32;
  if ((v10 & 8) != 0)
    v15 = 960;
  else
    v15 = 480;
  if ((~v10 & 0x60) != 0)
    v16 = v14;
  else
    v16 = v15;
  v17 = (10737419 * (unint64_t)v13) >> 32;
  if (v9 < 0)
    v18 = v17;
  else
    v18 = v16;
  v19 = (char *)(a1 + 1);
  v20 = a2 - 1;
  v21 = v10 & 3;
  if ((v10 & 3) == 0)
  {
    v23 = 0;
    v22 = 1;
    v24 = a2 - 1;
    goto LABEL_23;
  }
  if (v21 == 2)
  {
    if (a2 != 1)
    {
      v31 = *v19;
      if (v31 < 0xFC)
      {
        v32 = 1;
        a6->i16[0] = v31;
        v20 = a2 - 2;
        v24 = a2 - 2 - v31;
        if ((int)(a2 - 2) < (int)v31)
          return 4294967292;
        goto LABEL_68;
      }
      if (a2 >= 3)
      {
        v40 = v31 + 4 * a1[2];
        v32 = 2;
        a6->i16[0] = v40;
        v20 = a2 - 3;
        v24 = a2 - 3 - v40;
        if ((int)(a2 - 3) < v40)
          return 4294967292;
LABEL_68:
        v23 = 0;
        v21 = 0;
        v22 = 2;
        v19 += v32;
        goto LABEL_23;
      }
    }
    a6->i16[0] = -1;
    return 4294967292;
  }
  if (v21 == 1)
  {
    if (a3)
    {
      v21 = 0;
      v22 = 2;
      v23 = 1;
      v24 = a2 - 1;
      v25 = &a6->i16[2];
      if (v20 < 1)
        goto LABEL_47;
      goto LABEL_25;
    }
    if ((v20 & 1) != 0)
      return 4294967292;
    v21 = 0;
    v26 = v20 >> 1;
    a6->i16[0] = v20 >> 1;
    v22 = 2;
    goto LABEL_51;
  }
  v24 = a2 - 2;
  if (a2 < 2)
    return 4294967292;
  v33 = *v19;
  v8 = 4294967292;
  v22 = *v19 & 0x3F;
  if ((*v19 & 0x3F) == 0 || (v22 * v18) > 0x1680)
    return v8;
  v19 = (char *)(a1 + 2);
  v21 = 0;
  if ((v33 & 0x40) != 0)
  {
    while (v24 >= 1)
    {
      v35 = *v19++;
      v34 = v35;
      if (v35 >= 0xFE)
        v36 = 254;
      else
        v36 = v34;
      v24 += ~v36;
      v21 += v36;
      if (v34 != 255)
      {
        if (v24 < 0)
          return 4294967292;
        goto LABEL_42;
      }
    }
    return 4294967292;
  }
LABEL_42:
  if (v33 < 0)
  {
    if (v22 < 2)
    {
      v23 = 0;
      v22 = 1;
      v20 = v24;
    }
    else
    {
      v45 = (v22 - 1);
      v46 = a6;
      v20 = v24;
      do
      {
        if (v20 < 1)
        {
LABEL_97:
          v46->i16[0] = -1;
          return 4294967292;
        }
        v47 = *v19;
        if (v47 >= 0xFC)
        {
          if (v20 < 2)
            goto LABEL_97;
          v47 += 4 * v19[1];
          v48 = 2;
        }
        else
        {
          v48 = 1;
        }
        v46->i16[0] = v47;
        v20 -= v48;
        if (v20 < (int)v47)
          return 4294967292;
        v19 += v48;
        v24 = v24 - v48 - v47;
        v46 = (int16x8_t *)((char *)v46 + 2);
        --v45;
      }
      while (v45);
      if (v24 < 0)
        return 4294967292;
      v23 = 0;
    }
LABEL_23:
    v26 = v24;
    v24 = v20;
    v20 = v26;
    if (a3)
    {
      v25 = &a6->i16[v22];
      if (v24 < 1)
        goto LABEL_47;
      goto LABEL_25;
    }
LABEL_51:
    if (v26 > 1275)
      return 4294967292;
LABEL_52:
    a6->i16[(v22 - 1)] = v26;
    goto LABEL_70;
  }
  if (!a3)
  {
    v26 = v24 / v22;
    if (v24 / v22 * (_DWORD)v22 != v24)
      return 4294967292;
    if (v22 < 2)
    {
      v22 = 1;
      if (v26 > 1275)
        return 4294967292;
      goto LABEL_52;
    }
    v49 = (v22 - 1);
    if (v22 >= 0x11)
    {
      v51 = vdupq_n_s16(v26);
      v50 = v49 & 0xFFFFFFF0;
      *a6 = v51;
      a6[1] = v51;
      if (v50 != 16)
      {
        a6[2] = v51;
        a6[3] = v51;
        if (v50 != 32)
        {
          a6[4] = v51;
          a6[5] = v51;
        }
      }
      if (v50 == v49)
      {
        v23 = 1;
LABEL_107:
        v20 = v24;
        v24 /= v22;
        goto LABEL_23;
      }
    }
    else
    {
      v50 = 0;
    }
    v52 = v49 - v50;
    v53 = &a6->i16[v50];
    v23 = 1;
    do
    {
      *v53++ = v26;
      --v52;
    }
    while (v52);
    goto LABEL_107;
  }
  v23 = 1;
  v25 = &a6->i16[v22];
  if (v24 < 1)
  {
LABEL_47:
    v28 = -1;
    *(v25 - 1) = -1;
    v29 = (v22 - 1);
    v30 = a6->i16[v29];
    v8 = 4294967292;
    if (v30 < 0)
      return v8;
    goto LABEL_56;
  }
LABEL_25:
  v27 = *v19;
  if (v27 >= 0xFC)
  {
    if (v24 < 2)
      goto LABEL_47;
    v28 = 2;
    *(v25 - 1) = v27 + 4 * v19[1];
    v29 = (v22 - 1);
    v30 = a6->i16[v29];
    v8 = 4294967292;
    if (v30 < 0)
      return v8;
  }
  else
  {
    v28 = 1;
    *(v25 - 1) = v27;
    v29 = (v22 - 1);
    v30 = a6->i16[v29];
    v8 = 4294967292;
    if (v30 < 0)
      return v8;
  }
LABEL_56:
  v37 = v24 - v28;
  if (v37 < v30)
    return v8;
  v19 += v28;
  if (v23)
  {
    if ((int)v22 * v30 <= v37)
    {
      if ((int)v22 < 2)
      {
        v22 = 1;
      }
      else
      {
        v38 = a6;
        v39 = v29;
        do
        {
          v38->i16[0] = a6->i16[v29];
          v38 = (int16x8_t *)((char *)v38 + 2);
          --v39;
        }
        while (v39);
      }
      goto LABEL_70;
    }
    return 4294967292;
  }
  if (v28 + v30 > v20)
    return 4294967292;
LABEL_70:
  if (a7)
    *a7 = (_DWORD)v19 - (_DWORD)a1;
  v42 = v22;
  if (a5)
  {
    do
    {
      *a5++ = v19;
      v43 = a6->i16[0];
      a6 = (int16x8_t *)((char *)a6 + 2);
      v19 += v43;
      --v42;
    }
    while (v42);
  }
  else
  {
    do
    {
      v44 = a6->i16[0];
      a6 = (int16x8_t *)((char *)a6 + 2);
      LODWORD(v19) = (_DWORD)v19 + v44;
      --v42;
    }
    while (v42);
  }
  if (a8)
    *a8 = v21 + (_DWORD)v19 - (_DWORD)a1;
  if (a4)
    *a4 = v9;
  return v22;
}

uint64_t opus_decoder_init(char *a1, int a2, int a3)
{
  uint64_t result;
  int v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int *v22;

  result = 0xFFFFFFFFLL;
  if (a2 > 15999)
  {
    if (a2 != 16000 && a2 != 48000 && a2 != 24000)
      return result;
LABEL_8:
    if ((a3 - 3) < 0xFFFFFFFE)
      return result;
    v7 = 8768 * a3;
    bzero(a1, (8768 * a3 + 9460));
    *(_QWORD *)a1 = 0x58000021F0;
    *((_DWORD *)a1 + 12) = a3;
    *((_DWORD *)a1 + 2) = a3;
    *((_DWORD *)a1 + 3) = a2;
    *((_DWORD *)a1 + 6) = a2;
    *((_DWORD *)a1 + 4) = a3;
    if (silk_InitDecoder((_DWORD *)a1 + 22))
      return 4294967293;
    bzero(a1 + 8688, (v7 + 772));
    *((_QWORD *)a1 + 1086) = &mode48000_960_120;
    *((_DWORD *)a1 + 2174) = 120;
    *((_DWORD *)a1 + 2175) = a3;
    *((_DWORD *)a1 + 2176) = a3;
    v8 = a1 + 8708;
    *(_OWORD *)(a1 + 8708) = xmmword_208F31A20;
    *(_QWORD *)(a1 + 8724) = a3 == 1;
    opus_custom_decoder_ctl((_DWORD *)a1 + 2172, 4028, v9, v10, v11, v12, v13, v14, v22);
    result = 4294967293;
    if (a2 <= 15999)
    {
      if (a2 == 8000)
      {
        v21 = 6;
        goto LABEL_22;
      }
      if (a2 == 12000)
      {
        v21 = 4;
        goto LABEL_22;
      }
    }
    else
    {
      switch(a2)
      {
        case 16000:
          v21 = 3;
          goto LABEL_22;
        case 48000:
          v21 = 1;
          goto LABEL_22;
        case 24000:
          v21 = 2;
LABEL_22:
          *((_DWORD *)a1 + 2177) = v21;
          opus_custom_decoder_ctl((_DWORD *)a1 + 2172, 10016, v15, v16, v17, v18, v19, v20, 0);
          result = 0;
          *((_DWORD *)a1 + 15) = 0;
          *((_DWORD *)a1 + 16) = (unsigned __int16)a2 / 0x190u;
          v8 = a1 + 44;
          break;
      }
    }
    *(_DWORD *)v8 = 0;
    return result;
  }
  if (a2 == 8000 || a2 == 12000)
    goto LABEL_8;
  return result;
}

uint64_t opus_decode_native(int8x16_t *a1, unsigned __int8 *a2, unsigned int a3, float32x4_t *a4, uint64_t a5, unsigned int a6, int a7, _DWORD *a8, int a9)
{
  int v14;
  unsigned int v15;
  int v16;
  __int32 v17;
  __int32 *v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  unsigned __int8 *v32;
  uint64_t v34;
  int16x8_t *v35;
  uint64_t v36;
  __int32 v37;
  uint64_t v38;
  int v39;
  int v40;
  char v41;
  int v42;
  int16x8_t v43[6];
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (a6 > 1 || (!a2 || !a3 || a6) && (int)a5 % (a1->i32[3] / 400))
    return 0xFFFFFFFFLL;
  if (!a2 || !a3)
  {
    LODWORD(v24) = 0;
    while (1)
    {
      v25 = opus_decode_frame(a1, 0, 0, &a4->i8[4 * a1->i32[2] * (int)v24], (int)a5 - (int)v24, 0);
      if ((v25 & 0x80000000) != 0)
        break;
      v24 = (v25 + v24);
      if ((int)v24 >= (int)a5)
      {
LABEL_25:
        a1[4].i32[2] = v24;
        return v24;
      }
    }
    return v25;
  }
  if ((a3 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v14 = (char)*a2;
  v15 = *a2;
  if ((~v14 & 0x60) != 0)
    v16 = 1000;
  else
    v16 = 1001;
  if (v14 < 0)
    v16 = 1002;
  v40 = v16;
  if (v14 < 0)
  {
    v26 = ((v15 >> 5) & 3) + 1102;
    if (((v15 >> 5) & 3) == 0)
      v26 = 1101;
    v39 = v26;
    v42 = 0;
    v41 = 0;
    v18 = &a1->i32[3];
    v23 = (a1->i32[3] << ((v15 >> 3) & 3)) / 400;
  }
  else
  {
    v42 = 0;
    v41 = 0;
    v18 = &a1->i32[3];
    v17 = a1->i32[3];
    if ((~v15 & 0x60) != 0)
    {
      v39 = ((v15 >> 5) & 3) + 1101;
      v27 = 1374389535 * (v17 << ((v15 >> 3) & 3));
      v28 = (v27 >> 37) + ((unint64_t)v27 >> 63);
      v29 = 60 * v17 / 1000;
      if (((v15 >> 3) & 3) == 3)
        v23 = v29;
      else
        v23 = v28;
    }
    else
    {
      if ((v15 & 0x10) != 0)
        v19 = 1105;
      else
        v19 = 1104;
      v39 = v19;
      v20 = 1374389535 * v17;
      v21 = (v20 >> 37) + ((unint64_t)v20 >> 63);
      v22 = (v20 >> 36) + ((unint64_t)v20 >> 63);
      if ((v15 & 8) != 0)
        v23 = v22;
      else
        v23 = v21;
    }
  }
  if ((v15 & 4) != 0)
    v30 = 2;
  else
    v30 = 1;
  v31 = opus_packet_parse_impl(a2, a3, a7, &v41, 0, v43, &v42, a8);
  v24 = v31;
  if ((v31 & 0x80000000) == 0)
  {
    v32 = &a2[v42];
    if (a6)
    {
      if ((v15 & 0x80) != 0 || (int)a5 < v23 || a1[3].i32[2] == 1002)
      {
        if ((int)a5 % (*v18 / 400))
          return 0xFFFFFFFFLL;
        LODWORD(v24) = 0;
        while (1)
        {
          v25 = opus_decode_frame(a1, 0, 0, &a4->i8[4 * a1->i32[2] * (int)v24], (int)a5 - (int)v24, 0);
          if ((v25 & 0x80000000) != 0)
            break;
          v24 = (v25 + v24);
          if ((int)v24 >= (int)a5)
            goto LABEL_25;
        }
      }
      else
      {
        if ((_DWORD)a5 != v23)
        {
          v37 = a1[4].i32[2];
          v38 = opus_decode_native(a1, 0, 0, a4, (a5 - v23), 0, 0, 0, a9);
          if ((v38 & 0x80000000) != 0)
          {
            v24 = v38;
            a1[4].i32[2] = v37;
            return v24;
          }
        }
        a1[4].i32[0] = v23;
        a1[3].i32[1] = v39;
        a1[3].i32[2] = v40;
        a1[3].i32[0] = v30;
        v25 = opus_decode_frame(a1, v32, v43[0].i16[0], &a4->i8[4 * a1->i32[2] * ((int)a5 - v23)], v23, 1);
        if ((v25 & 0x80000000) == 0)
        {
          a1[4].i32[2] = a5;
          return a5;
        }
      }
      return v25;
    }
    if ((int)v31 * v23 > (int)a5)
      return 4294967294;
    a1[4].i32[0] = v23;
    a1[3].i32[1] = v39;
    a1[3].i32[2] = v40;
    a1[3].i32[0] = v30;
    if ((_DWORD)v31)
    {
      v34 = v31;
      v35 = v43;
      LODWORD(v24) = 0;
      do
      {
        v25 = opus_decode_frame(a1, v32, v35->i16[0], &a4->i8[4 * a1->i32[2] * (int)v24], (int)a5 - (int)v24, 0);
        if ((v25 & 0x80000000) != 0)
          return v25;
        v36 = v35->i16[0];
        v35 = (int16x8_t *)((char *)v35 + 2);
        v32 += v36;
        v24 = (v25 + v24);
      }
      while (--v34);
    }
    a1[4].i32[2] = v24;
    if (a9)
    {
      opus_pcm_soft_clip(a4, v24, a1->i32[2], (uint64_t)&a1[4].i64[1] + 4);
    }
    else
    {
      a1[4].i32[3] = 0;
      a1[5].i32[0] = 0;
    }
  }
  return v24;
}

uint64_t opus_decode_frame(int8x16_t *a1, unsigned __int8 *a2, int a3, char *a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  char *v9;
  signed int v10;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  BOOL v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  unsigned __int8 *v39;
  int v41;
  int v42;
  _BOOL4 v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  unsigned __int8 *v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  float32x4_t *v53;
  int v54;
  int v55;
  unsigned int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _BOOL4 v61;
  int v62;
  unsigned int v63;
  int v64;
  unsigned int v65;
  int v66;
  int v67;
  BOOL v68;
  unsigned int v69;
  _DWORD *v70;
  _BOOL4 v71;
  _BOOL4 v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  char *v79;
  uint64_t v80;
  char *v81;
  int v82;
  uint64_t v83;
  _BOOL4 v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  char *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  char *v109;
  int v110;
  int v111;
  unsigned __int8 *v112;
  unsigned __int8 *v113;
  uint64_t v114;
  uint64_t v115;
  float32x4_t *v116;
  int16x4_t *v117;
  float32x4_t v118;
  uint64_t v119;
  int16x8_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  uint64_t v124;
  __int16 *v125;
  float *v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  float32x4_t *v133;
  int v134;
  char v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  _BOOL4 v140;
  uint64_t v141;
  char *v142;
  char *v143;
  uint64_t v144;
  uint64_t v145;
  __int128 v146;
  char *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  unsigned __int8 *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  float32x4_t *v164;
  int v165;
  uint64_t v166;
  uint64_t v167;
  float32x4_t *v168;
  unsigned int v169;
  int v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  __int128 *v177;
  _OWORD *v178;
  uint64_t v179;
  __int128 v180;
  uint64_t v181;
  uint64_t v182;
  char *v183;
  int *v184;
  int v185;
  uint64_t v186;
  int v187;
  double v188;
  uint64_t v189;
  float v190;
  uint64_t v191;
  float32x4_t *v192;
  uint64_t v193;
  float32x4_t v194;
  uint64_t v195;
  float *v196;
  __int32 v197;
  int v198;
  _QWORD v199[2];
  int *v200;
  unsigned int v201;
  int v202;
  signed int v203;
  uint64_t v204;
  uint64_t v205;
  unsigned int v206;
  uint64_t v207;
  _BYTE v208[12];
  int v209;
  int v210;
  float32x4_t *v211;
  unsigned __int8 *v212;
  int **v213;
  uint64_t v214;
  uint64_t v215;
  int v216;
  int v217;
  __int128 v218;
  __int128 v219;
  __int128 v220;
  uint64_t v221;
  uint64_t v222;

  v222 = *MEMORY[0x24BDAC8D0];
  v216 = 0;
  v6 = a1->i32[3];
  v7 = (int)v6 / 50;
  if (((int)v6 / 50) >> 3 > a5)
    return 4294967294;
  v9 = a4;
  v10 = a3;
  v12 = a1->i32[0];
  v13 = v7 >> 1;
  v14 = v7 >> 2;
  v221 = 0;
  v219 = 0u;
  v220 = 0u;
  v218 = 0u;
  v217 = 0;
  v15 = 3 * ((int)v6 / 25);
  if (v15 >= a5)
    v8 = a5;
  else
    v8 = v15;
  if (a3 > 1)
  {
    if (a2)
    {
      v17 = a1[4].i32[0];
      v18 = a1[3].i32[2];
      HIDWORD(v214) = a1[3].i32[1];
      *(_QWORD *)&v218 = a2;
      DWORD2(v218) = a3;
      LODWORD(v219) = 0;
      v19 = *a2;
      HIDWORD(v220) = v19;
      v20 = 2;
      DWORD1(v220) = (v19 >> 1) ^ 0x7F;
      HIDWORD(v219) = 2;
      v21 = a2[1];
      if (a3 < 3)
      {
        v22 = 0;
      }
      else
      {
        v20 = 3;
        HIDWORD(v219) = 3;
        v22 = a2[2];
      }
      v28 = ((_WORD)v21 << 7) & 0xFF00 | (unsigned __int16)((_WORD)v19 << 15) | (((v19 >> 1) ^ 0x7F) << 16) | ((v22 | (v21 << 8)) >> 1);
      DWORD2(v219) = 33;
      LODWORD(v220) = 0x80000000;
      if (v20 >= a3)
      {
        v29 = 0;
      }
      else
      {
        HIDWORD(v219) = v20 + 1;
        v29 = a2[v20];
      }
      HIDWORD(v220) = v29;
      DWORD1(v220) = (((v29 | (v22 << 8)) >> 1) | (v28 << 8)) ^ 0xFFFFFF;
      v30 = a1[3].i32[3];
      if (v30 >= 1)
      {
        if (v18 == 1002 && v30 != 1002)
        {
          if (a1[4].i32[1])
          {
            v26 = 0;
            v27 = 1;
            LODWORD(v214) = 1;
            v18 = 1002;
            if (v17 <= (int)v8)
              goto LABEL_57;
          }
          else
          {
            LODWORD(v204) = a6;
            v207 = v12;
            v212 = a2;
            MEMORY[0x24BDAC7A8](v12, a2);
            *(_QWORD *)&v208[4] = (char *)&v200 - v58;
            v59 = opus_decode_frame(a1, 0, 0);
            if (v17 <= (int)v8)
            {
              v205 = v6;
              v210 = v7 >> 2;
              v213 = &v200;
              v206 = ((int)v6 / 50) >> 3;
              MEMORY[0x24BDAC7A8](v59, v60);
              v211 = (float32x4_t *)v199;
              LODWORD(v8) = v17;
              v34 = 1;
              v31 = v207;
              v33 = v204;
              goto LABEL_59;
            }
          }
          return 0xFFFFFFFFLL;
        }
        if (v18 != 1002 && v30 == 1002)
        {
          v27 = a1->i32[2] * v14;
          v26 = 1;
          LODWORD(v214) = 1;
          if (v17 <= (int)v8)
            goto LABEL_57;
          return 0xFFFFFFFFLL;
        }
      }
      v26 = 0;
      v27 = 1;
      LODWORD(v214) = 1;
      if (v17 > (int)v8)
        return 0xFFFFFFFFLL;
LABEL_57:
      *(_DWORD *)v208 = v27;
      *(_DWORD *)&v208[4] = v26;
      v212 = a2;
      if (v18 == 1002)
      {
        v205 = v6;
        v210 = v7 >> 2;
        v213 = &v200;
        v206 = ((int)v6 / 50) >> 3;
        v31 = MEMORY[0x24BDAC7A8](v12, a2);
        v211 = (float32x4_t *)v199;
        LODWORD(v8) = v17;
        v34 = *(_DWORD *)&v208[4];
        goto LABEL_59;
      }
      v209 = v18;
      LODWORD(v8) = v17;
      goto LABEL_61;
    }
  }
  else
  {
    v16 = a1[4].i32[0];
    if ((int)v8 >= v16)
      v8 = v16;
    else
      v8 = v8;
  }
  if (a1[4].i32[1])
  {
    v18 = 1002;
  }
  else
  {
    v18 = a1[3].i32[3];
    if (!v18)
    {
      if (a1->i32[2] * (int)v8 >= 1)
        bzero(a4, 4 * (a1->i32[2] * v8));
      return v8;
    }
  }
  if ((int)v8 <= v7)
  {
    if ((int)v8 >= v7)
    {
      v213 = &v200;
      if (v18 == 1002)
      {
        v205 = v6;
        v210 = v7 >> 2;
        v206 = ((int)v6 / 50) >> 3;
        v31 = MEMORY[0x24BDAC7A8](v12, a2);
        v211 = (float32x4_t *)v199;
        v212 = 0;
        HIDWORD(v214) = 0;
        v34 = 0;
LABEL_59:
        v204 = 0;
        v41 = 0;
        v201 = 0;
        v42 = 0;
        v43 = v33 == 0;
        v202 = 1;
        v209 = 1002;
        goto LABEL_110;
      }
      v209 = v18;
      v35 = MEMORY[0x24BDAC7A8](v12, a2);
      v211 = (float32x4_t *)((char *)&v200 - v38);
      v214 = 0;
      v39 = 0;
      *(_QWORD *)v208 = 1;
LABEL_62:
      v205 = v6;
      v210 = v7 >> 2;
      v206 = ((int)v6 / 50) >> 3;
      v45 = (__int32 *)((char *)a1->i32 + v37);
      if (a1[3].i32[3] == 1002)
      {
        v46 = v35;
        v47 = v39;
        v48 = v36;
        silk_InitDecoder(v45);
        v36 = v48;
        v35 = v46;
        v39 = v47;
      }
      v203 = v10;
      v49 = 1000 * (int)v8 / a1->i32[3];
      if (v49 <= 10)
        v49 = 10;
      a1[2].i32[0] = v49;
      if ((_DWORD)v214)
      {
        a1[1].i32[1] = a1[3].i32[0];
        if (v209 == 1000 && (HIDWORD(v214) - 1101) <= 2)
          v50 = 4000 * (HIDWORD(v214) - 1101) + 8000;
        else
          v50 = 16000;
        a1[1].i32[3] = v50;
      }
      v207 = v35;
      v51 = 0;
      LODWORD(v204) = v36;
      v212 = v39;
      if (v39)
        v52 = 2 * v36;
      else
        v52 = 1;
      v53 = v211;
      do
      {
        while (!silk_Decode((uint64_t)v45, a1 + 1, v52, v51 == 0, (uint64_t)&v218, v53, &v217, a1[2].i32[3]))
        {
          v53 = (float32x4_t *)((char *)v53 + 2 * a1->i32[2] * v217);
          v51 += v217;
          if (v51 >= (int)v8)
            goto LABEL_82;
        }
        if (!v52)
          return 4294967293;
        v217 = v8;
        v54 = a1->i32[2] * v8;
        if (v54 >= 1)
          bzero(v53, 2 * (a1->i32[2] * v8));
        v53 = (float32x4_t *)((char *)v53 + 2 * v54);
        v51 += v8;
      }
      while (v51 < (int)v8);
LABEL_82:
      v43 = v204 == 0;
      v55 = v214;
      if ((_DWORD)v204)
        v55 = 0;
      if (v55 != 1)
      {
        v202 = 0;
        v41 = 0;
        v201 = 0;
        v42 = 0;
        v204 = 17;
        v10 = v203;
LABEL_108:
        v31 = v207;
        goto LABEL_109;
      }
      v56 = __clz(v220);
      if (v209 == 1001)
        v57 = 5;
      else
        v57 = -15;
      v10 = v203;
      v31 = v207;
      if ((int)(DWORD2(v219) + v57 + v56) > 8 * v203)
      {
        v202 = 0;
        v41 = 0;
        v201 = 0;
        v42 = 0;
        v204 = 17;
        v43 = 1;
LABEL_109:
        v34 = *(_DWORD *)&v208[4];
LABEL_110:
        v70 = (__int32 *)((char *)a1->i32 + v31);
        v71 = v34 != 0;
        LODWORD(v214) = v41;
        if (v41)
          v72 = 0;
        else
          v72 = v71;
        MEMORY[0x24BDAC7A8](v31, v32);
        v81 = (char *)&v200 - v80;
        if (v82 && v72)
        {
          opus_decode_frame(a1, 0, 0);
          v79 = v81;
        }
        v83 = 21;
        *(_QWORD *)&v208[4] = v79;
        if (SHIDWORD(v214) <= 1101)
        {
          v84 = v72;
          if (!HIDWORD(v214))
          {
LABEL_125:
            v85 = opus_custom_decoder_ctl(v70, 10008, v73, v74, v75, v76, v77, v78, (int *)a1[3].u32[0]);
            if (!(_DWORD)v85)
            {
              if ((_DWORD)v214)
              {
                MEMORY[0x24BDAC7A8](v85, v86);
                v95 = (char *)&v200 - v94;
                if (v42)
                {
                  if (opus_custom_decoder_ctl(v70, 10010, v88, v89, v90, v91, v92, v93, 0))
                    return 4294967293;
                  celt_decode_with_ec((uint64_t)v70, &v212[v10], v201, (uint64_t)v95, v210, 0, 0);
                  if (opus_custom_decoder_ctl(v70, 4031, v96, v97, v98, v99, v100, v101, &v216))
                    return 4294967293;
                  HIDWORD(v214) = 1;
                  v42 = 1;
                }
                else
                {
                  HIDWORD(v214) = 0;
                }
              }
              else
              {
                MEMORY[0x24BDAC7A8](v85, v86);
                v95 = (char *)v199;
                HIDWORD(v214) = 0;
                v42 = v42 != 0;
              }
              if (!opus_custom_decoder_ctl(v70, 10010, v88, v89, v90, v91, v92, v93, (int *)v204))
              {
                if (v209 != 1000)
                {
                  *(_DWORD *)v208 = v42;
                  v109 = v95;
                  if (v7 >= (int)v8)
                    v110 = v8;
                  else
                    v110 = v7;
                  v111 = a1[3].i32[3];
                  v112 = v212;
                  if (v209 != v111 && v111 >= 1 && !a1[4].i32[1])
                  {
                    v165 = opus_custom_decoder_ctl(v70, 4028, v102, v103, v104, v105, v106, v107, v200);
                    v112 = v212;
                    if (v165)
                      return 4294967293;
                  }
                  if (v43)
                    v113 = v112;
                  else
                    v113 = 0;
                  v108 = celt_decode_with_ec((uint64_t)v70, v113, v10, (uint64_t)v9, v110, &v218, 0);
                  v95 = v109;
                  v42 = *(_DWORD *)v208;
LABEL_155:
                  if ((v202 & 1) == 0)
                  {
                    v114 = (a1->i32[2] * v8);
                    if ((int)v114 >= 1)
                    {
                      if (v114 < 0x10)
                      {
                        v115 = 0;
LABEL_163:
                        v124 = v114 - v115;
                        v125 = (__int16 *)v211 + v115;
                        v126 = (float *)&v9[4 * v115];
                        do
                        {
                          v127 = *v125++;
                          *v126 = *v126 + (float)((float)v127 * 0.000030518);
                          ++v126;
                          --v124;
                        }
                        while (v124);
                        goto LABEL_165;
                      }
                      v115 = v114 & 0x7FFFFFF0;
                      v116 = (float32x4_t *)(v9 + 32);
                      v117 = (int16x4_t *)&v211[1];
                      v118.i64[0] = 0x3800000038000000;
                      v118.i64[1] = 0x3800000038000000;
                      v119 = v114 & 0xFFFFFFF0;
                      do
                      {
                        v120 = *(int16x8_t *)v117[-2].i8;
                        v121 = vmlaq_f32(v116[-1], v118, vcvtq_f32_s32(vmovl_high_s16(v120)));
                        v122 = vmlaq_f32(*v116, v118, vcvtq_f32_s32(vmovl_s16(*v117)));
                        v123 = vmlaq_f32(v116[1], v118, vcvtq_f32_s32(vmovl_high_s16(*(int16x8_t *)v117->i8)));
                        v116[-2] = vmlaq_f32(v116[-2], v118, vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v120.i8)));
                        v116[-1] = v121;
                        *v116 = v122;
                        v116[1] = v123;
                        v116 += 4;
                        v117 += 4;
                        v119 -= 16;
                      }
                      while (v119);
                      if (v115 != v114)
                        goto LABEL_163;
                    }
                  }
LABEL_165:
                  v215 = 0;
                  if (opus_custom_decoder_ctl(v70, 10015, v102, v103, v104, v105, v106, v107, (int *)&v215))return 4294967293;
                  v133 = *(float32x4_t **)(v215 + 72);
                  v134 = v214;
                  if ((_DWORD)v214)
                    v135 = v42;
                  else
                    v135 = 1;
                  if ((v135 & 1) != 0)
                  {
                    if (!HIDWORD(v214))
                      goto LABEL_204;
                  }
                  else
                  {
                    v211 = *(float32x4_t **)(v215 + 72);
                    if (opus_custom_decoder_ctl(v70, 4028, v128, v129, v130, (uint64_t)v133, v131, v132, v200))return 4294967293;
                    if (opus_custom_decoder_ctl(v70, 10010, v151, v152, v153, v154, v155, v156, 0))
                      return 4294967293;
                    v157 = &v212[v10];
                    v212 = (unsigned __int8 *)v95;
                    celt_decode_with_ec((uint64_t)v70, v157, v201, (uint64_t)v95, v210, 0, 0);
                    if (opus_custom_decoder_ctl(v70, 4031, v158, v159, v160, v161, v162, v163, &v216))
                      return 4294967293;
                    v164 = v211;
                    smooth_fade((uint64_t)&v9[4 * (int)(a1->i32[2] * (v8 - v206))], (uint64_t)&v212[4 * a1->i32[2] * v206], (uint64_t)&v9[4 * (int)(a1->i32[2] * (v8 - v206))], v206, a1->u32[2], v211, a1->i32[3]);
                    v133 = v164;
                    v134 = v214;
                    if (!HIDWORD(v214))
                      goto LABEL_204;
                  }
                  if (a1[3].i32[3] != 1000 || a1[4].i32[1])
                  {
                    v136 = a1->u32[2];
                    if ((int)v205 >= 400 && (int)v136 >= 1)
                    {
                      v137 = 0;
                      if ((int)v206 <= 1)
                        v138 = 1;
                      else
                        v138 = v206;
                      v140 = v138 > 7 && (_DWORD)v136 == 1;
                      v141 = 4 * v136;
                      v142 = v95;
                      v143 = v9;
                      do
                      {
                        if (v140)
                        {
                          v144 = 0;
                          v145 = v138 & 0x1FFFFF8;
                          do
                          {
                            v146 = *(_OWORD *)&v142[v144 + 16];
                            v147 = &v143[v144];
                            *(_OWORD *)v147 = *(_OWORD *)&v142[v144];
                            *((_OWORD *)v147 + 1) = v146;
                            v144 += 32 * v136;
                            v145 -= 8;
                          }
                          while (v145);
                          v148 = v138 & 0x1FFFFF8;
                          if (v148 == v138)
                            goto LABEL_186;
                        }
                        else
                        {
                          v148 = 0;
                        }
                        v149 = v138 - v148;
                        v150 = v141 * v148;
                        do
                        {
                          *(_DWORD *)&v143[v150] = *(_DWORD *)&v142[v150];
                          v150 += v141;
                          --v149;
                        }
                        while (v149);
LABEL_186:
                        ++v137;
                        v143 += 4;
                        v142 += 4;
                      }
                      while (v137 != v136);
                    }
                    v166 = 4 * (int)(v136 * v206);
                    v167 = (uint64_t)&v95[v166];
                    v168 = v133;
                    smooth_fade(v167, (uint64_t)&v9[v166], (uint64_t)&v9[v166], v206, v136, v133, a1->i32[3]);
                    v133 = v168;
                    v134 = v214;
                  }
LABEL_204:
                  if (v84)
                  {
                    v169 = a1->u32[2];
                    if ((int)v8 >= v210)
                    {
                      v174 = v169 * v206;
                      v175 = *(_QWORD *)&v208[4];
                      if ((int)v174 >= 1)
                      {
                        v176 = 0;
                        if (v174 < 8)
                          goto LABEL_213;
                        if ((unint64_t)&v9[-*(_QWORD *)&v208[4]] < 0x20)
                          goto LABEL_213;
                        v176 = v174 & 0x7FFFFFF8;
                        v177 = (__int128 *)(*(_QWORD *)&v208[4] + 16);
                        v178 = v9 + 16;
                        v179 = v174 & 0xFFFFFFF8;
                        do
                        {
                          v180 = *v177;
                          *(v178 - 1) = *(v177 - 1);
                          *v178 = v180;
                          v177 += 2;
                          v178 += 2;
                          v179 -= 8;
                        }
                        while (v179);
                        if (v176 != v174)
                        {
LABEL_213:
                          v181 = v174 - v176;
                          v182 = 4 * v176;
                          v183 = &v9[4 * v176];
                          v184 = (int *)(v175 + v182);
                          do
                          {
                            v185 = *v184++;
                            *(_DWORD *)v183 = v185;
                            v183 += 4;
                            --v181;
                          }
                          while (v181);
                        }
                      }
                      v186 = 4 * (int)v174;
                      v171 = v175 + v186;
                      v172 = (uint64_t)&v9[v186];
                      v170 = a1->i32[3];
                      v173 = (uint64_t)&v9[v186];
                    }
                    else
                    {
                      v170 = a1->i32[3];
                      v171 = *(_QWORD *)&v208[4];
                      v172 = (uint64_t)v9;
                      v173 = (uint64_t)v9;
                    }
                    smooth_fade(v171, v172, v173, v206, v169, v133, v170);
                    v134 = v214;
                  }
                  v187 = a1[2].i32[2];
                  if (!v187)
                    goto LABEL_226;
                  v188 = exp((float)((float)v187 * 0.00064881) * 0.693147181);
                  v134 = v214;
                  v189 = (a1->i32[2] * v8);
                  if ((int)v189 < 1)
                    goto LABEL_226;
                  v190 = v188;
                  if (v189 >= 8)
                  {
                    v191 = v189 & 0x7FFFFFF8;
                    v192 = (float32x4_t *)(v9 + 16);
                    v193 = v189 & 0xFFFFFFF8;
                    do
                    {
                      v194 = vmulq_n_f32(*v192, v190);
                      v192[-1] = vmulq_n_f32(v192[-1], v190);
                      *v192 = v194;
                      v192 += 2;
                      v193 -= 8;
                    }
                    while (v193);
                    if (v191 == v189)
                      goto LABEL_226;
                  }
                  else
                  {
                    v191 = 0;
                  }
                  v195 = v189 - v191;
                  v196 = (float *)&v9[4 * v191];
                  do
                  {
                    *v196 = *v196 * v190;
                    ++v196;
                    --v195;
                  }
                  while (v195);
LABEL_226:
                  v197 = v216 ^ v220;
                  if (v10 < 2)
                    v197 = 0;
                  a1[5].i32[1] = v197;
                  a1[3].i32[3] = v209;
                  v198 = v42 ^ 1;
                  if (!v134)
                    v198 = 0;
                  a1[4].i32[1] = v198;
                  if (v108 >= 0)
                    return v8;
                  else
                    return v108;
                }
                LOWORD(v215) = -1;
                if (a1->i32[2] * (int)v8 >= 1)
                  bzero(v9, 4 * (a1->i32[2] * v8));
                if (a1[3].i32[3] != 1001 || HIDWORD(v214) && a1[4].i32[1])
                {
LABEL_144:
                  v108 = 0;
                  goto LABEL_155;
                }
                if (!opus_custom_decoder_ctl(v70, 10010, v102, v103, v104, v105, v106, v107, 0))
                {
                  celt_decode_with_ec((uint64_t)v70, (unsigned __int8 *)&v215, 2u, (uint64_t)v9, v206, 0, 0);
                  goto LABEL_144;
                }
              }
            }
            return 4294967293;
          }
          if (HIDWORD(v214) == 1101)
            v83 = 13;
        }
        else
        {
          v84 = v72;
          if ((HIDWORD(v214) - 1102) >= 2)
          {
            if (HIDWORD(v214) == 1104)
              v83 = 19;
          }
          else
          {
            v83 = 17;
          }
        }
        if (opus_custom_decoder_ctl(v70, 10012, v73, v74, v75, v76, v77, v78, (int *)v83))
          return 4294967293;
        goto LABEL_125;
      }
      if (v209 == 1001)
      {
        v61 = ec_dec_bit_logp((uint64_t *)&v218, 12);
        if (!v61)
        {
          v202 = 0;
          v41 = 0;
          v201 = 0;
          v42 = 0;
          v204 = 17;
          v209 = 1001;
LABEL_107:
          v43 = 1;
          goto LABEL_108;
        }
        v62 = v61;
        v42 = ec_dec_bit_logp((uint64_t *)&v218, 1);
        v63 = ec_dec_uint((uint64_t *)&v218, 0x100u) + 2;
        v64 = DWORD2(v219);
        v65 = __clz(v220);
      }
      else
      {
        v62 = 1;
        v42 = ec_dec_bit_logp((uint64_t *)&v218, 1);
        v64 = DWORD2(v219);
        v65 = __clz(v220);
        v63 = v10 - ((int)(DWORD2(v219) + v65 - 25) >> 3);
      }
      v202 = 0;
      v66 = 8 * (v10 - v63);
      v67 = v65 + v64 - 32;
      v68 = v66 < v67;
      if (v66 >= v67)
        v41 = v62;
      else
        v41 = 0;
      if (v68)
        v69 = 0;
      else
        v69 = v63;
      if (v68)
        v10 = 0;
      else
        v10 -= v63;
      v201 = v69;
      DWORD2(v218) -= v69;
      v204 = 17;
      goto LABEL_107;
    }
    if ((int)v8 > v13)
    {
      v214 = 0;
      a2 = 0;
      v26 = 0;
      v27 = 1;
      v17 = v7 >> 1;
      if (v13 <= (int)v8)
        goto LABEL_57;
      return 0xFFFFFFFFLL;
    }
    if (v18 == 1000)
    {
      v214 = 0;
      v212 = 0;
      v209 = 1000;
      *(_QWORD *)v208 = 1;
LABEL_61:
      v213 = &v200;
      v35 = MEMORY[0x24BDAC7A8](v12, a2);
      v211 = (float32x4_t *)((char *)&v200 - v44);
      v39 = v212;
      goto LABEL_62;
    }
    v214 = 0;
    a2 = 0;
    v26 = 0;
    if ((int)v8 >= v13 || (int)v8 <= v14)
      v17 = v8;
    else
      v17 = v7 >> 2;
    v27 = 1;
    if (v17 > (int)v8)
      return 0xFFFFFFFFLL;
    goto LABEL_57;
  }
  v23 = v8;
  while (1)
  {
    v24 = opus_decode_frame(a1, 0, 0);
    if ((v24 & 0x80000000) != 0)
      break;
    v9 += 4 * a1->i32[2] * (int)v24;
    v25 = __OFSUB__(v23, (_DWORD)v24);
    v23 -= v24;
    if ((v23 < 0) ^ v25 | (v23 == 0))
      return v8;
  }
  return v24;
}

uint64_t opus_decode(int8x16_t *a1, unsigned __int8 *a2, int a3, _WORD *a4, int a5, int a6)
{
  __int32 v8;
  unsigned int v9;
  int v10;
  uint64_t result;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v21;
  float *v22;
  unsigned __int8 *v23;
  unsigned int v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  float v28;
  _QWORD v29[2];

  v29[1] = *MEMORY[0x24BDAC8D0];
  if (a5 < 1)
    return 0xFFFFFFFFLL;
  if (!a2 || a3 < 1 || a6)
    goto LABEL_27;
  v8 = a1->i32[3];
  v9 = *a2;
  if ((v9 & 3) == 0)
  {
    v10 = 1;
    if ((v9 & 0x80) == 0)
      goto LABEL_12;
LABEL_21:
    v17 = 1374389535 * (v8 << ((*a2 >> 3) & 3));
    v16 = (v17 >> 39) + ((unint64_t)v17 >> 63);
    goto LABEL_22;
  }
  if ((v9 & 3) != 3)
  {
    v10 = 2;
    if ((v9 & 0x80) == 0)
      goto LABEL_12;
    goto LABEL_21;
  }
  if (a3 < 2)
    return 4294967292;
  v10 = a2[1] & 0x3F;
  if ((v9 & 0x80) != 0)
    goto LABEL_21;
LABEL_12:
  v12 = 1374389535 * (v8 << ((*a2 >> 3) & 3));
  v13 = (v12 >> 37) + ((unint64_t)v12 >> 63);
  if (((v9 >> 3) & 3) == 3)
    v14 = 60 * v8 / 1000;
  else
    v14 = v13;
  v15 = v8 / 50;
  if ((v9 & 8) == 0)
    v15 = v8 / 100;
  if ((~v9 & 0x60) != 0)
    v16 = v14;
  else
    v16 = v15;
LABEL_22:
  v18 = v16 * v10;
  v19 = 3 * v8;
  if (v18 < 1 || 25 * v18 > v19)
    return 4294967292;
LABEL_27:
  MEMORY[0x24BDAC7A8](a1, a2);
  v22 = (float *)((char *)v29 - v21);
  result = opus_decode_native(a1, v23, v24, (float32x4_t *)((char *)v29 - v21), v25, v26, 0, 0, 1);
  if ((int)result >= 1)
  {
    v27 = (a1->i32[2] * result);
    if ((int)v27 >= 1)
    {
      do
      {
        v28 = *v22++;
        *a4++ = (uint64_t)rintf(fminf(fmaxf(v28 * 32768.0, -32768.0), 32767.0));
        --v27;
      }
      while (v27);
    }
  }
  return result;
}

uint64_t opus_decoder_ctl(int *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  _DWORD *v13;
  _DWORD *v14;
  int v15;
  int *v16;

  v10 = *a1;
  v11 = a1[1];
  result = 4294967291;
  v13 = (int *)((char *)a1 + v10);
  switch(a2)
  {
    case 4009:
      if (!a9)
        goto LABEL_22;
      result = 0;
      *a9 = a1[13];
      break;
    case 4028:
      v14 = (int *)((char *)a1 + v11);
      *((_QWORD *)a1 + 10) = 0;
      *((_OWORD *)a1 + 3) = 0u;
      *((_OWORD *)a1 + 4) = 0u;
      opus_custom_decoder_ctl(v13, 4028, a3, a4, a5, a6, a7, a8, v16);
      silk_InitDecoder(v14);
      result = 0;
      v15 = a1[3];
      a1[12] = a1[2];
      a1[16] = v15 / 400;
      break;
    case 4029:
      if (!a9)
        goto LABEL_22;
      result = 0;
      *a9 = a1[3];
      break;
    case 4031:
      if (!a9)
        goto LABEL_22;
      result = 0;
      *a9 = a1[21];
      break;
    case 4033:
      if (!a9)
        goto LABEL_22;
      if (a1[15] == 1002)
      {
        result = opus_custom_decoder_ctl(v13, 4033, a3, a4, a5, a6, a7, a8, a9);
      }
      else
      {
        result = 0;
        *a9 = a1[9];
      }
      break;
    case 4034:
      if ((_DWORD)a9 != (__int16)a9)
        goto LABEL_22;
      result = 0;
      a1[10] = (int)a9;
      break;
    case 4039:
      if (!a9)
        goto LABEL_22;
      result = 0;
      *a9 = a1[18];
      break;
    case 4045:
      if (!a9)
        goto LABEL_22;
      result = 0;
      *a9 = a1[10];
      break;
    case 4046:
      if (a9 > 1)
        goto LABEL_22;
      result = opus_custom_decoder_ctl(v13, 4046, a3, a4, a5, a6, a7, a8, (int *)a9);
      break;
    case 4047:
      if (a9)
        result = opus_custom_decoder_ctl(v13, 4047, a3, a4, a5, a6, a7, a8, a9);
      else
LABEL_22:
        result = 0xFFFFFFFFLL;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t opus_packet_get_nb_samples(unsigned __int8 *a1, int a2, int a3)
{
  unsigned int v3;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;

  if (a2 < 1)
    return 0xFFFFFFFFLL;
  v3 = *a1;
  if ((v3 & 3) != 0)
  {
    if ((v3 & 3) == 3)
    {
      if (a2 < 2)
        return 4294967292;
      v5 = a1[1] & 0x3F;
      if ((v3 & 0x80) != 0)
        goto LABEL_19;
LABEL_10:
      v6 = 1374389535 * (a3 << ((*a1 >> 3) & 3));
      v7 = (v6 >> 37) + ((unint64_t)v6 >> 63);
      if (((v3 >> 3) & 3) == 3)
        v8 = 60 * a3 / 1000;
      else
        v8 = v7;
      v9 = a3 / 50;
      if ((v3 & 8) == 0)
        v9 = a3 / 100;
      if ((~v3 & 0x60) != 0)
        v10 = v8;
      else
        v10 = v9;
      goto LABEL_20;
    }
    v5 = 2;
    if ((v3 & 0x80) == 0)
      goto LABEL_10;
  }
  else
  {
    v5 = 1;
    if ((v3 & 0x80) == 0)
      goto LABEL_10;
  }
LABEL_19:
  v11 = 1374389535 * (a3 << ((*a1 >> 3) & 3));
  v10 = (v11 >> 39) + ((unint64_t)v11 >> 63);
LABEL_20:
  v12 = v10 * v5;
  if ((int)(25 * v12) <= 3 * a3)
    return v12;
  else
    return 4294967292;
}

uint64_t smooth_fade(uint64_t result, uint64_t a2, uint64_t a3, int a4, unsigned int a5, float32x4_t *a6, int a7)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float32x4_t *v30;
  uint64_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t *v35;
  uint64_t v36;
  uint64_t v37;
  float *v38;

  if (a4 >= 1 && (int)a5 >= 1)
  {
    v7 = 0;
    v8 = 48000 / a7;
    v9 = a5;
    v11 = a5 != 1 || v8 != 1;
    v12 = 32 * v8;
    v13 = 32 * a5;
    v14 = a3 + 16;
    v15 = result + 16;
    v16 = 4 * a5;
    v17 = 4 * v8;
    __asm { FMOV            V1.4S, #1.0 }
    v22 = result;
    v23 = a3;
    v24 = a2;
    do
    {
      v25 = a4 < 8 || v11;
      if ((v25 & 1) != 0)
      {
        v26 = 0;
      }
      else
      {
        v26 = 0;
        v27 = 4 * v7;
        v28 = 4 * v7 + a3;
        if ((unint64_t)(v28 - (_QWORD)a6) >= 0x20
          && (unint64_t)(v28 - (v27 + a2)) >= 0x20
          && (unint64_t)(v28 - (v27 + result)) >= 0x20)
        {
          v29 = 0;
          v30 = a6 + 1;
          v31 = a4 & 0xFFFFFFF8;
          do
          {
            v32 = vmulq_f32(v30[-1], v30[-1]);
            v33 = vmulq_f32(*v30, *v30);
            v34 = vmlaq_f32(vmulq_f32(vsubq_f32(_Q1, v33), *(float32x4_t *)(v15 + v29)), *(float32x4_t *)(v24 + v29 + 16), v33);
            v35 = (float32x4_t *)(v14 + v29);
            v35[-1] = vmlaq_f32(vmulq_f32(vsubq_f32(_Q1, v32), *(float32x4_t *)(v15 + v29 - 16)), *(float32x4_t *)(v24 + v29), v32);
            *v35 = v34;
            v30 = (float32x4_t *)((char *)v30 + v12);
            v29 += v13;
            v31 -= 8;
          }
          while (v31);
          v26 = a4 & 0xFFFFFFF8;
          if (v26 == a4)
            goto LABEL_10;
        }
      }
      v36 = a4 - v26;
      v37 = v16 * v26;
      v38 = (float *)((char *)a6->f32 + v17 * v26);
      do
      {
        *(float *)(v23 + v37) = (float)((float)(1.0 - (float)(*v38 * *v38)) * *(float *)(v22 + v37))
                              + (float)((float)(*v38 * *v38) * *(float *)(v24 + v37));
        v37 += v16;
        v38 = (float *)((char *)v38 + v17);
        --v36;
      }
      while (v36);
LABEL_10:
      ++v7;
      v24 += 4;
      v14 += 4;
      v15 += 4;
      v23 += 4;
      v22 += 4;
    }
    while (v7 != v9);
  }
  return result;
}

uint64_t opus_encoder_init(char *a1, int a2, int a3, int a4)
{
  uint64_t result;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;

  result = 0xFFFFFFFFLL;
  if (a2 > 15999)
  {
    if (a2 != 16000 && a2 != 48000 && a2 != 24000)
      return result;
LABEL_8:
    if ((a3 - 3) < 0xFFFFFFFE || (a4 - 2048) > 3 || a4 == 2050)
      return result;
    v9 = 4912 * a3;
    bzero(a1, (4912 * a3 + 38668));
    *(_QWORD *)a1 = 0x46E800009610;
    *((_DWORD *)a1 + 28) = a3;
    *((_DWORD *)a1 + 3549) = a3;
    *((_DWORD *)a1 + 36) = a2;
    *((_DWORD *)a1 + 45) = 0;
    if (silk_InitEncoder((uint64_t)(a1 + 18152), 0, (uint64_t)(a1 + 8)))
      return 4294967293;
    *((_DWORD *)a1 + 2) = a3;
    *((_DWORD *)a1 + 3) = a3;
    *((_DWORD *)a1 + 4) = *((_DWORD *)a1 + 36);
    *(_OWORD *)(a1 + 20) = xmmword_208F382B0;
    *(_OWORD *)(a1 + 36) = xmmword_208F382C0;
    *((_QWORD *)a1 + 7) = 0;
    *((_DWORD *)a1 + 19) = 0;
    v10 = *((_DWORD *)a1 + 45);
    bzero(a1 + 38416, (v9 + 252));
    *((_QWORD *)a1 + 4802) = &mode48000_960_120;
    *((_DWORD *)a1 + 9606) = a3;
    *((_DWORD *)a1 + 9607) = a3;
    *((_DWORD *)a1 + 9623) = v10;
    *(_OWORD *)(a1 + 38460) = xmmword_208F31AC0;
    *((_QWORD *)a1 + 4804) = 0x100000000;
    *(_OWORD *)(a1 + 38444) = xmmword_208F31AD0;
    *((_DWORD *)a1 + 9620) = 24;
    opus_custom_encoder_ctl((_DWORD *)a1 + 9604, 4028, v11, v12, v13, v14, v15, v16, v31);
    if (a2 <= 15999)
    {
      if (a2 == 8000)
      {
        v23 = 6;
        goto LABEL_25;
      }
      if (a2 == 12000)
      {
        v23 = 4;
        goto LABEL_25;
      }
    }
    else
    {
      switch(a2)
      {
        case 16000:
          v23 = 3;
          goto LABEL_25;
        case 48000:
          v23 = 1;
          goto LABEL_25;
        case 24000:
          v23 = 2;
LABEL_25:
          *((_DWORD *)a1 + 9612) = v23;
          opus_custom_encoder_ctl((_DWORD *)a1 + 9604, 10016, v17, v18, v19, v20, v21, v22, 0);
          opus_custom_encoder_ctl((_DWORD *)a1 + 9604, 4010, v24, v25, v26, v27, v28, v29, *((unsigned int *)a1 + 11));
          *(_QWORD *)(a1 + 148) = 0x100000001;
          *(_OWORD *)(a1 + 120) = xmmword_208F382D0;
          v30 = *((_DWORD *)a1 + 36);
          *((_DWORD *)a1 + 27) = a4;
          *((_QWORD *)a1 + 17) = -1000;
          *((_DWORD *)a1 + 43) = v30 / 100;
          *(_QWORD *)(a1 + 164) = 0x18FFFFFC18;
          *((_DWORD *)a1 + 39) = 5000;
          *((_DWORD *)a1 + 40) = a3 * a2 + 3000;
          *((_DWORD *)a1 + 29) = v30 / 250;
          *((_WORD *)a1 + 7100) = 0x4000;
          *(_QWORD *)(a1 + 14204) = 0x3F8000000002F400;
          *((_DWORD *)a1 + 3564) = 1;
          *((_DWORD *)a1 + 3557) = 1001;
          *((_DWORD *)a1 + 3561) = 1105;
          *((_DWORD *)a1 + 48) = 0;
          *((_DWORD *)a1 + 50) = v30;
          bzero(a1 + 204, 0x36A8uLL);
          result = 0;
          *((_DWORD *)a1 + 49) = a4;
          return result;
      }
    }
    v23 = 0;
    goto LABEL_25;
  }
  if (a2 == 8000 || a2 == 12000)
    goto LABEL_8;
  return result;
}

float downmix_int(uint64_t a1, uint64_t a2, unsigned int a3, int a4, int a5, unsigned int a6, int a7, double a8, double a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  _WORD *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float *v26;
  uint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  _WORD *v30;
  uint64_t v31;
  float *v32;
  uint64_t v33;
  uint64_t v34;
  float *v35;
  _WORD *v36;

  if ((int)a3 < 1)
    return *(float *)&a8;
  v9 = a4;
  v10 = a5;
  v11 = 2 * a7;
  if (a3 == 1)
  {
    v12 = 0;
LABEL_7:
    v16 = a3 - v12;
    v17 = (_DWORD *)(a2 + 4 * v12);
    v18 = (_WORD *)(a1 + 2 * (v10 + (v12 + a4) * a7));
    do
    {
      LOWORD(a8) = *v18;
      *(_QWORD *)&a8 = vmovl_s16(*(int16x4_t *)&a8).u64[0];
      *(float *)&a8 = (float)SLODWORD(a8);
      *v17++ = LODWORD(a8);
      v18 = (_WORD *)((char *)v18 + v11);
      --v16;
    }
    while (v16);
    goto LABEL_9;
  }
  v12 = a3 & 0xFFFFFFFE;
  v13 = 2 * a5;
  v14 = (_DWORD *)(a2 + 4);
  v15 = v12;
  do
  {
    LOWORD(a8) = *(_WORD *)(a1 + 2 * a7 * (uint64_t)a4 + v13);
    *(_QWORD *)&a8 = vmovl_s16(*(int16x4_t *)&a8).u64[0];
    *(float *)&a8 = (float)SLODWORD(a8);
    LOWORD(a9) = *(_WORD *)(a1 + 2 * (a7 + a7 * (uint64_t)a4) + v13);
    *(_QWORD *)&a9 = vmovl_s16(*(int16x4_t *)&a9).u64[0];
    *(float *)&a9 = (float)SLODWORD(a9);
    *(v14 - 1) = LODWORD(a8);
    *v14 = LODWORD(a9);
    v13 += 4 * a7;
    v14 += 2;
    v15 -= 2;
  }
  while (v15);
  if (v12 != a3)
    goto LABEL_7;
LABEL_9:
  if ((a6 & 0x80000000) != 0)
  {
    if (a6 != -2 || a7 < 2)
      return *(float *)&a8;
    v20 = a4 * (unint64_t)a7;
    v21 = a1 + 2 * (a7 + v20) + 2;
    v22 = a1 + 2 * v20 + 2;
    v23 = 1;
    while (1)
    {
      if (a3 >= 2)
      {
        v25 = 0;
        v26 = (float *)(a2 + 4);
        v27 = a3 & 0xFFFFFFFE;
        do
        {
          LOWORD(a8) = *(_WORD *)(v22 + v25);
          *(_QWORD *)&a8 = vmovl_s16(*(int16x4_t *)&a8).u64[0];
          LOWORD(a9) = *(_WORD *)(v21 + v25);
          *(_QWORD *)&a9 = vmovl_s16(*(int16x4_t *)&a9).u64[0];
          *(float *)&a8 = *(v26 - 1) + (float)SLODWORD(a8);
          *(float *)&a9 = *v26 + (float)SLODWORD(a9);
          *(v26 - 1) = *(float *)&a8;
          *v26 = *(float *)&a9;
          v25 += 4 * a7;
          v26 += 2;
          v27 -= 2;
        }
        while (v27);
        v24 = a3 & 0xFFFFFFFE;
        if (v24 == a3)
          goto LABEL_15;
      }
      else
      {
        v24 = 0;
      }
      v28 = a3 - v24;
      v29 = (_DWORD *)(a2 + 4 * v24);
      v30 = (_WORD *)(a1 + 2 * (v23 + a7 * (v9 + v24)));
      do
      {
        LOWORD(a8) = *v30;
        *(_QWORD *)&a8 = vmovl_s16(*(int16x4_t *)&a8).u64[0];
        LODWORD(a9) = *v29;
        *(float *)&a8 = *(float *)v29 + (float)SLODWORD(a8);
        *v29++ = LODWORD(a8);
        v30 += a7;
        --v28;
      }
      while (v28);
LABEL_15:
      ++v23;
      v21 += 2;
      v22 += 2;
      if (v23 == a7)
        return *(float *)&a8;
    }
  }
  if (a3 < 2)
  {
    v19 = 0;
LABEL_27:
    v34 = a3 - v19;
    v35 = (float *)(a2 + 4 * v19);
    v36 = (_WORD *)(a1 + 2 * (a6 + (v19 + v9) * a7));
    do
    {
      LOWORD(a8) = *v36;
      *(_QWORD *)&a8 = vmovl_s16(*(int16x4_t *)&a8).u64[0];
      *(float *)&a8 = *v35 + (float)SLODWORD(a8);
      *v35++ = *(float *)&a8;
      v36 = (_WORD *)((char *)v36 + v11);
      --v34;
    }
    while (v34);
    return *(float *)&a8;
  }
  v19 = a3 & 0xFFFFFFFE;
  v31 = 2 * a6;
  v32 = (float *)(a2 + 4);
  v33 = v19;
  do
  {
    LOWORD(a8) = *(_WORD *)(a1 + 2 * a7 * (uint64_t)(int)v9 + v31);
    *(_QWORD *)&a8 = vmovl_s16(*(int16x4_t *)&a8).u64[0];
    LOWORD(a9) = *(_WORD *)(a1 + 2 * (a7 + a7 * (uint64_t)(int)v9) + v31);
    *(_QWORD *)&a9 = vmovl_s16(*(int16x4_t *)&a9).u64[0];
    *(float *)&a8 = *(v32 - 1) + (float)SLODWORD(a8);
    *(float *)&a9 = *v32 + (float)SLODWORD(a9);
    *(v32 - 1) = *(float *)&a8;
    *v32 = *(float *)&a9;
    v31 += 4 * a7;
    v32 += 2;
    v33 -= 2;
  }
  while (v33);
  if (v19 != a3)
    goto LABEL_27;
  return *(float *)&a8;
}

uint64_t opus_encode_native(int *a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11, uint64_t a12, int a13)
{
  __int16 *v13;
  uint64_t v14;
  uint64_t v15;
  int v18;
  uint64_t v19;
  uint64_t *v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  int v28;
  uint64_t v29;
  float v30;
  float *v31;
  float v32;
  float v33;
  float v34;
  __int128 v35;
  int v36;
  int v37;
  int *v38;
  int v39;
  int v40;
  float v41;
  int v42;
  int v43;
  float v44;
  unint64_t v45;
  float32x2_t v46;
  float v47;
  float32x2_t *v48;
  float32x2_t v49;
  float32x2_t v50;
  float v51;
  float32x2_t v52;
  float32x2_t v53;
  float32x2_t v54;
  float v55;
  float32x2_t v56;
  int8x8_t v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  unsigned int v81;
  int v82;
  _BYTE *v83;
  int v84;
  unsigned int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  BOOL v94;
  int v95;
  int v96;
  int *v97;
  int v98;
  BOOL v99;
  uint64_t v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  float v108;
  float v109;
  float v110;
  BOOL v111;
  float v112;
  uint64_t v113;
  uint64_t v114;
  float v115;
  int v116;
  int v117;
  char v118;
  int v119;
  char v120;
  char v122;
  char v123;
  char v124;
  char v125;
  char v126;
  size_t v127;
  float v128;
  float *v129;
  uint64_t v130;
  uint64_t v131;
  float *v132;
  float v133;
  float v134;
  uint64_t v135;
  float v136;
  int v137;
  uint64_t v138;
  int v139;
  int v140;
  int v141;
  uint64_t v142;
  int *v143;
  char v144;
  int v145;
  int v146;
  int v147;
  int v148;
  uint64_t *v149;
  int v150;
  int v151;
  int v152;
  int v153;
  int v154;
  int v155;
  int v156;
  char v157;
  float *v158;
  uint64_t v159;
  uint64_t v160;
  float *v161;
  float v162;
  uint64_t v163;
  uint64_t v164;
  float v165;
  float *v166;
  uint64_t v167;
  uint64_t v168;
  float *v169;
  float v170;
  int v171;
  float *v172;
  float *v173;
  int v174;
  char v175;
  int v176;
  char v177;
  int v178;
  int v179;
  char v180;
  int v181;
  int v182;
  BOOL v183;
  char v184;
  _BOOL4 v185;
  int v186;
  int v187;
  uint64_t v188;
  int v189;
  int v190;
  int v191;
  int v192;
  int v193;
  int v194;
  uint64_t v195;
  int v196;
  int v197;
  unint64_t v198;
  int v199;
  uint64_t v200;
  int v201;
  int v202;
  int v203;
  unint64_t v204;
  int v205;
  int v206;
  int v207;
  unint64_t v208;
  uint64_t v209;
  uint64_t v210;
  int v211;
  _BYTE *v212;
  uint64_t v213;
  int v214;
  int v215;
  uint64_t v216;
  int v217;
  int v218;
  unsigned int v219;
  int v221;
  int v222;
  int v223;
  int v224;
  int v225;
  uint64_t v226;
  int v227;
  int v228;
  BOOL v229;
  int v230;
  int v231;
  int v232;
  int v233;
  int v234;
  uint64_t v235;
  float *v236;
  int v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  int v246;
  int v247;
  unsigned int v248;
  float *v249;
  float *v250;
  int v251;
  uint64_t v252;
  __int16 v253;
  float v254;
  float v255;
  float v256;
  float v257;
  uint64_t v258;
  float *v259;
  float *v260;
  float v261;
  float v262;
  float v263;
  uint64_t v264;
  float *v265;
  float v266;
  float v267;
  unsigned int v268;
  int v269;
  int v270;
  unsigned int v271;
  int v272;
  __int16 v273;
  uint64_t v274;
  int v275;
  int v276;
  float v277;
  float v278;
  float v279;
  float v280;
  uint64_t v281;
  float v282;
  float v283;
  uint64_t v284;
  float v285;
  float v286;
  float *v287;
  float *v288;
  float v289;
  float v290;
  float v291;
  float v292;
  uint64_t v293;
  uint64_t v294;
  float v295;
  float *v296;
  uint64_t v297;
  uint64_t v298;
  float *v299;
  float v300;
  int v301;
  float v302;
  uint64_t *v303;
  int v304;
  int v305;
  uint64_t v306;
  int v307;
  double v308;
  int v309;
  int v310;
  uint64_t v311;
  int v312;
  int v313;
  uint64_t v314;
  int v315;
  float v316;
  float v317;
  int v318;
  uint64_t v319;
  uint64_t v320;
  float *v321;
  float v322;
  float32x4_t v323;
  float32x4_t v324;
  float32x4_t *v325;
  int8x16_t v326;
  int8x16_t v327;
  int8x16_t v328;
  int8x16_t v329;
  int8x16_t v330;
  int8x16_t v331;
  int8x16_t v332;
  int8x16_t v333;
  float *v334;
  uint64_t v335;
  float v336;
  float v337;
  long double v338;
  int v339;
  long double v340;
  int v341;
  int v342;
  int v343;
  int v344;
  int v345;
  int v346;
  int v347;
  int v348;
  int v349;
  char v350;
  int v351;
  size_t v352;
  int *v353;
  int v354;
  uint64_t v355;
  const __int16 *v356;
  float *v357;
  __int16 *v358;
  float v359;
  uint64_t v360;
  float *v361;
  __int16 *v362;
  float v363;
  int v364;
  int v365;
  int v366;
  int v367;
  int v368;
  int v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  int v390;
  uint64_t v391;
  float32x4_t *v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  int v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  int v426;
  int v427;
  int v428;
  uint64_t v429;
  char v430;
  uint64_t v431;
  int v432;
  int v433;
  int v434;
  int *v435;
  size_t v436;
  float32x4_t *v437;
  double v438;
  float32x4_t v439;
  int v440;
  unsigned int v441;
  int v442;
  int v443;
  int *v444;
  unsigned int v445;
  int v446;
  uint64_t v447;
  unsigned int v448;
  int v449;
  int v450;
  unsigned int v451;
  int v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  float32x4_t *v461;
  uint64_t v462;
  int v463;
  _BOOL4 v464;
  int v465;
  uint64_t *v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  uint64_t v481;
  uint64_t v482;
  uint64_t v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t *v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  int v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  char v506;
  int v507;
  uint64_t *v508;
  int v509;
  int v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  int v535;
  int v536;
  float32x4_t *v537;
  uint64_t *v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  char v545;
  char *v546;
  unsigned int v547;
  int *v548;
  int v549;
  int v550;
  int v551;
  int v552;
  char v553;
  int v554;
  int v555;
  uint64_t v556;
  uint64_t v557;
  const __int16 *v558;
  uint64_t *v559;
  int v560;
  int v561;
  int v562;
  _BYTE *v563;
  int *v564;
  uint64_t *v565;
  float *v566;
  _DWORD *v567;
  int v568;
  int v569;
  _BOOL4 v570;
  int v571;
  uint64_t v572;
  int v573;
  unsigned int v574;
  unsigned int v575;
  int *v576;
  uint64_t *v577;
  uint64_t v578;
  __int128 v579;
  float32x4_t *v580;
  _BYTE *v581;
  uint64_t v582;
  uint64_t v583;
  int v584;
  uint64_t v585[7];
  int v586;
  _QWORD v587[62];
  __int128 v588;
  __int128 v589;
  __int128 v590;
  __int128 v591;
  uint64_t v592;

  v592 = *MEMORY[0x24BDAC8D0];
  v13 = (__int16 *)(a1 + 3550);
  v584 = 0;
  if ((int)a5 >= 1276)
    v14 = 1276;
  else
    v14 = a5;
  a1[4537] = 0;
  v15 = 0xFFFFFFFFLL;
  if ((int)a3 < 1 || (int)v14 < 1)
    return v15;
  v18 = a5;
  v19 = a3;
  if ((_DWORD)v14 == 1 && a1[36] == 10 * (_DWORD)a3)
    return 4294967294;
  v22 = (uint64_t *)((char *)a1 + *a1);
  v23 = a1[27];
  v581 = (_BYTE *)a4;
  if (v23 == 2051)
    LODWORD(v578) = 0;
  else
    LODWORD(v578) = a1[29];
  v582 = a1[1];
  v583 = 0;
  v586 = 0;
  memset(v585, 0, sizeof(v585));
  v588 = 0u;
  v589 = 0u;
  v590 = 0u;
  v591 = 0u;
  LODWORD(v24) = a1[42];
  if ((int)v24 >= (int)a6)
    v24 = a6;
  else
    v24 = v24;
  v580 = (float32x4_t *)v24;
  opus_custom_encoder_ctl(v22, 10015, a3, a4, a5, a6, a7, a8, (uint64_t)&v583);
  LODWORD(v588) = 0;
  if (a1[11] < 7 || (v28 = a1[36], v28 < 16000))
  {
    if (a1[1913])
      bzero(a1 + 51, 0x36A8uLL);
    a1[35] = -1;
    *(_QWORD *)&v35 = -1;
    *((_QWORD *)&v35 + 1) = -1;
    v579 = v35;
    goto LABEL_28;
  }
  v29 = (a1[28] * v19);
  if ((int)v29 < 1)
  {
    v32 = 0.0;
    v30 = 0.0;
  }
  else
  {
    v30 = 0.0;
    v31 = a2;
    v32 = 0.0;
    do
    {
      v33 = *v31++;
      v34 = v33;
      if (v32 <= v33)
        v32 = v34;
      if (v30 >= v34)
        v30 = v34;
      --v29;
    }
    while (v29);
  }
  v108 = -v30;
  if (v32 <= v108)
    v109 = v108;
  else
    v109 = v32;
  v110 = 1.0 / (float)(1 << (char)v580);
  *(_QWORD *)&v27 = *((_QWORD *)a1 + 955);
  v579 = v27;
  run_analysis((uint64_t)(a1 + 48), v583, a7, a8, v19, a9, a10, a11, v28, (int)v580, a12, (uint64_t)&v588);
  v111 = v109 <= v110 || *((float *)&v590 + 1) <= 0.1;
  if (!v111)
  {
    v112 = *((float *)v13 + 985) * 0.999;
    v113 = (a1[28] * v19);
    if ((int)v113 < 1)
    {
      v128 = 0.0 / (float)(int)v113;
      if (v112 > v128)
        goto LABEL_318;
      goto LABEL_317;
    }
    if ((_DWORD)v113 == 1)
    {
      v114 = 0;
      v115 = 0.0;
    }
    else
    {
      v114 = v113 & 0xFFFFFFFE;
      v129 = a2 + 1;
      v115 = 0.0;
      v130 = v114;
      do
      {
        v115 = (float)(v115 + (float)(*(v129 - 1) * *(v129 - 1))) + (float)(*v129 * *v129);
        v129 += 2;
        v130 -= 2;
      }
      while (v130);
      if (v114 == v113)
      {
LABEL_256:
        v134 = (float)(int)v113;
        if (v112 > (float)(v115 / (float)(int)v113))
        {
LABEL_318:
          *((float *)v13 + 985) = v112;
          v37 = v588;
          goto LABEL_319;
        }
        if (v113 >= 2)
        {
          v135 = v113 & 0xFFFFFFFE;
          v158 = a2 + 1;
          v136 = 0.0;
          v159 = v135;
          do
          {
            v136 = (float)(v136 + (float)(*(v158 - 1) * *(v158 - 1))) + (float)(*v158 * *v158);
            v158 += 2;
            v159 -= 2;
          }
          while (v159);
          if (v135 == v113)
            goto LABEL_316;
        }
        else
        {
          v135 = 0;
          v136 = 0.0;
        }
        v160 = v113 - v135;
        v161 = &a2[v135];
        do
        {
          v162 = *v161++;
          v136 = v136 + (float)(v162 * v162);
          --v160;
        }
        while (v160);
LABEL_316:
        v128 = v136 / v134;
LABEL_317:
        v112 = v128;
        goto LABEL_318;
      }
    }
    v131 = v113 - v114;
    v132 = &a2[v114];
    do
    {
      v133 = *v132++;
      v115 = v115 + (float)(v133 * v133);
      --v131;
    }
    while (v131);
    goto LABEL_256;
  }
  v37 = v588;
  if (v109 <= v110)
  {
    v39 = 0;
    v36 = 1;
    goto LABEL_332;
  }
LABEL_319:
  a1[35] = -1;
  if (!v37)
  {
LABEL_28:
    v36 = 0;
    v37 = 0;
    v38 = (int *)(v13 + 1966);
    *((_DWORD *)v13 + 983) = 0;
    v39 = -1;
    goto LABEL_29;
  }
  if (*((float *)&v590 + 1) < 0.1)
  {
    v163 = (a1[28] * v19);
    if ((int)v163 < 1)
    {
      v165 = 0.0;
    }
    else
    {
      if ((_DWORD)v163 == 1)
      {
        v164 = 0;
        v165 = 0.0;
      }
      else
      {
        v164 = v163 & 0xFFFFFFFE;
        v166 = a2 + 1;
        v165 = 0.0;
        v167 = v164;
        do
        {
          v165 = (float)(v165 + (float)(*(v166 - 1) * *(v166 - 1))) + (float)(*v166 * *v166);
          v166 += 2;
          v167 -= 2;
        }
        while (v167);
        if (v164 == v163)
          goto LABEL_331;
      }
      v168 = v163 - v164;
      v169 = &a2[v164];
      do
      {
        v170 = *v169++;
        v165 = v165 + (float)(v170 * v170);
        --v168;
      }
      while (v168);
    }
LABEL_331:
    v36 = 0;
    v39 = *((float *)v13 + 985) < (float)((float)(v165 / (float)(int)v163) * 316.23);
LABEL_332:
    v38 = (int *)(v13 + 1966);
    *((_DWORD *)v13 + 983) = 0;
    if (!v37)
      goto LABEL_29;
    goto LABEL_333;
  }
  v36 = 0;
  v38 = (int *)(v13 + 1966);
  v39 = 1;
LABEL_333:
  if (a1[31] == -1000)
  {
    v171 = a1[3558];
    v172 = (float *)&v589 + 1;
    if (v171)
      v172 = (float *)&v589 + 2;
    if (v171 == 1002)
      v173 = (float *)&v589 + 3;
    else
      v173 = v172;
    a1[35] = vcvtmd_s64_f64((float)((float)(1.0 - *v173) * 100.0) + 0.5);
  }
  if ((int)v590 > 12)
  {
    if (v590 > 0xE)
    {
      if (v590 > 0x10)
      {
        if (v590 > 0x12)
          v174 = 1105;
        else
          v174 = 1104;
      }
      else
      {
        v174 = 1103;
      }
    }
    else
    {
      v174 = 1102;
    }
  }
  else
  {
    v174 = 1101;
  }
  *v38 = v174;
LABEL_29:
  v40 = a1[28];
  v41 = 0.0;
  if (v40 != 2 || a1[30] == 1)
    goto LABEL_56;
  v42 = a1[36] / (int)v19;
  if (v42 <= 50)
    v43 = 50;
  else
    v43 = a1[36] / (int)v19;
  v44 = (float)(-25.0 / (float)v43) + 1.0;
  if ((int)v19 < 4)
  {
    v46 = 0;
    v47 = 0.0;
  }
  else
  {
    v45 = 0;
    v46 = 0;
    v47 = 0.0;
    do
    {
      v48 = (float32x2_t *)&a2[2 * v45];
      v49 = *v48;
      v50 = v48[1];
      v51 = vmlas_n_f32(vmul_f32(v49, v49).f32[0], v50.f32[0], v50.f32[0]);
      v52 = vmla_lane_f32(vmul_lane_f32(v49, v49, 1), v50, v50, 1);
      v53 = v48[2];
      v54 = v48[3];
      v47 = v47 + vmlas_n_f32(vmlas_n_f32(v51, v53.f32[0], v53.f32[0]), v54.f32[0], v54.f32[0]);
      v46 = vadd_f32(v46, vmla_lane_f32(vmla_lane_f32(v52, v53, v53, 1), v54, v54, 1));
      v45 += 4;
    }
    while (v45 < (v19 - 3));
    if (v47 >= 1000000000.0)
      goto LABEL_41;
  }
  if (v46.f32[1] >= 1000000000.0)
  {
LABEL_41:
    v46 = 0;
    v47 = 0.0;
  }
  v55 = *((float *)a1 + 3568) + (float)(v44 * (float)(v47 - *((float *)a1 + 3568)));
  if (v55 < 0.0)
    v55 = 0.0;
  *((float *)a1 + 3568) = v55;
  v56 = vmla_n_f32(*(float32x2_t *)(v13 + 38), vsub_f32(v46, *(float32x2_t *)(v13 + 38)), v44);
  v57 = vbic_s8((int8x8_t)v56, (int8x8_t)vcltz_f32(v56));
  *(int8x8_t *)(v13 + 38) = v57;
  if (v55 <= *(float *)&v57.i32[1])
    v58 = *(float *)&v57.i32[1];
  else
    v58 = v55;
  if (v58 <= 0.0008)
  {
    v63 = *((float *)a1 + 3572);
  }
  else
  {
    v59 = sqrtf(v55);
    v60 = sqrtf(*(float *)&v57.i32[1]);
    v61 = sqrtf(v59);
    v62 = sqrtf(v60);
    if (*(float *)v57.i32 >= (float)(v59 * v60))
      *(float *)v57.i32 = v59 * v60;
    a1[3569] = v57.i32[0];
    v63 = *((float *)a1 + 3571)
        + (float)((float)((float)((float)(vabds_f32(v61, v62) / (float)((float)(v61 + 1.0e-15) + v62))
                                * sqrtf(1.0- (float)((float)(*(float *)v57.i32 / (float)((float)(v59 * v60) + 1.0e-15))* (float)(*(float *)v57.i32 / (float)((float)(v59 * v60) + 1.0e-15)))))- *((float *)a1 + 3571))/ (float)v42);
    *((float *)a1 + 3571) = v63;
    v64 = -0.02 / (float)v42;
    if ((float)(*((float *)a1 + 3572) + v64) > v63)
      v63 = *((float *)a1 + 3572) + v64;
    *((float *)a1 + 3572) = v63;
  }
  v41 = v63 * 20.0;
  if (v41 > 1.0)
    v41 = 1.0;
LABEL_56:
  v65 = a1[41];
  if (v65 == -1000)
  {
    v67 = a1[36];
    v66 = a1[37];
    v65 = 60 * v67 / (int)v19 + v67 * v40;
    a1[40] = v65;
    if (v66)
      goto LABEL_68;
  }
  else if (v65 == -1)
  {
    v67 = a1[36];
    v66 = a1[37];
    v65 = 8 * (int)v14 * v67 / (int)v19;
    a1[40] = v65;
    if (v66)
      goto LABEL_68;
  }
  else
  {
    v67 = a1[36];
    v66 = a1[37];
    a1[40] = v65;
    if (v66)
      goto LABEL_68;
  }
  v68 = 12 * v67 / (int)v19;
  v69 = 12 * v65 + (12 * v65 < 0 ? 7 : 0);
  if (v68 >= 0)
    v70 = 12 * v67 / (int)v19;
  else
    v70 = v68 + 1;
  v71 = ((v70 >> 1) + (v69 >> 3)) / v68;
  if (v71 >= (int)v14)
    v72 = v14;
  else
    v72 = v71;
  v65 = 8 * v68 * v72 / 12;
  a1[40] = v65;
  if (v72 <= 1)
    v14 = 1;
  else
    v14 = v72;
LABEL_68:
  v73 = v67 / (int)v19;
  if ((int)v14 >= 3 && v65 >= 24 * v73)
  {
    v74 = (v14 * v73);
    if (v73 > 49)
    {
      v571 = v39;
      v76 = a1[10];
      v77 = a1[11];
      if (v73 == 50)
      {
        v75 = 0;
        v78 = v65;
        if (v66)
          goto LABEL_105;
      }
      else
      {
        v78 = v65 + (v73 - 50) * (-40 * v40 - 20);
        v75 = 1;
        if (v66)
          goto LABEL_105;
      }
LABEL_104:
      v78 += v78 / -12;
LABEL_105:
      v86 = a1[31];
      v577 = v22;
      if (v86 == 3001)
      {
        v87 = 127;
        v88 = v77 + 90;
        v89 = 12 * v76 + 20;
        v90 = a1[30];
        if (v90 != -1000)
          goto LABEL_116;
      }
      else
      {
        if (v86 == 3002)
        {
          v87 = 0;
          v88 = v77 + 90;
          v89 = 12 * v76 + 20;
          v90 = a1[30];
          if (v90 == -1000)
            goto LABEL_108;
LABEL_116:
          if (v40 == 2)
          {
            a1[3549] = v90;
            v40 = v90;
            goto LABEL_119;
          }
LABEL_118:
          a1[3549] = v40;
LABEL_119:
          v92 = v65;
          if ((_DWORD)v75)
            v92 = v65 + (-40 * v40 - 20) * (v73 - 50);
          if (!v66)
            v92 += v92 / -12;
          v93 = a1[46];
          v569 = v36;
          if (v37 | v36)
            v94 = 1;
          else
            v94 = v93 == 0;
          v95 = !v94;
          a1[14] = v95;
          v96 = a1[27];
          if (v96 == 2051)
            goto LABEL_130;
          v98 = a1[34];
          if (v98 != -1000)
          {
            a1[3557] = v98;
            goto LABEL_180;
          }
          v101 = v92 * v88 / 100 - v92 * v88 / 100 * v76 / v89;
          v102 = (int)(float)((float)(v41 * 10000.0) + (float)((float)(1.0 - v41) * 10000.0))
               + ((v87
                 * v87
                 * ((int)(float)((float)(v41 * 44000.0) + (float)((float)(1.0 - v41) * 64000.0))
                  - (int)(float)((float)(v41 * 10000.0) + (float)((float)(1.0 - v41) * 10000.0)))) >> 14);
          if (v96 == 2048)
            v102 += 8000;
          v103 = a1[3558];
          v25 = (v102 - 4000);
          v26 = (v102 + 4000);
          if (v103 > 0)
            v102 += 4000;
          if (v103 == 1002)
            v102 = v25;
          if (v101 >= v102)
            v98 = 1002;
          else
            v98 = 1000;
          a1[3557] = v98;
          if (a1[12] && v76 > (128 - v87) >> 4)
          {
            if (a1[47] == 2 && v87 < 26)
              goto LABEL_151;
            v98 = 1000;
            a1[3557] = 1000;
          }
          if (v87 <= 100)
            v95 = 0;
          if (v95 == 1)
          {
            v98 = 1000;
            a1[3557] = 1000;
          }
LABEL_151:
          if ((_DWORD)v75)
            v104 = 9000;
          else
            v104 = 6000;
          if ((int)v14 < v104 * (int)v19 / (8 * v67))
          {
LABEL_130:
            v97 = a1 + 3557;
            v98 = 1002;
            a1[3557] = 1002;
            v99 = v67 / 100 > (int)v19;
            goto LABEL_131;
          }
LABEL_180:
          v97 = a1 + 3557;
          v116 = v67 / 100;
          v99 = v116 > (int)v19;
          if (v98 != 1002)
          {
            v100 = v582;
            if (v116 > (int)v19)
            {
              v98 = 1002;
              *v97 = 1002;
              v99 = 1;
            }
LABEL_183:
            if (a1[44])
            {
              v98 = 1002;
              *v97 = 1002;
            }
            v117 = a1[3558];
            if (v117 >= 1)
            {
              if (v98 != 1002 && v117 == 1002)
              {
                v575 = 0;
                v568 = 1;
                v573 = 1;
                v570 = 1;
                if (v40 != 1)
                  goto LABEL_260;
                goto LABEL_198;
              }
              if (v98 == 1002)
              {
                v118 = v117 == 1002 || v99;
                if ((v118 & 1) != 0)
                {
                  v575 = 0;
                  v573 = 0;
                  v570 = 0;
                  v568 = 1;
                  v98 = 1002;
                  if (v40 != 1)
                    goto LABEL_260;
                }
                else
                {
                  v568 = 0;
                  v573 = 0;
                  *v97 = v117;
                  v575 = 1;
                  v98 = v117;
                  v570 = 1;
                  if (v40 != 1)
                    goto LABEL_260;
                }
LABEL_198:
                if (a1[3559] == 2 && !a1[17] && v117 != 1002 && v98 != 1002)
                {
                  a1[17] = 1;
                  v40 = 2;
                  a1[3549] = 2;
                  if (!(_DWORD)v75)
                  {
LABEL_262:
                    v576 = v97;
                    LODWORD(v567) = v75;
                    if (!v66)
                      v65 += v65 / -12;
                    LODWORD(v582) = v65 * v88 / 100;
                    v572 = (uint64_t)a1 + v100;
                    if ((v98 & 0xFFFFFFFE) == 0x3E8)
                    {
                      if (v77 <= 1)
                        LODWORD(v582) = 4 * (int)v582 / 5;
                      LODWORD(v582) = v582 - (int)v582 * v76 / (6 * v76 + 10);
                      if (v117 == 1002)
                      {
LABEL_268:
                        v137 = a1[45];
                        LODWORD(v565) = v87;
                        v138 = (v14 * v73);
                        v566 = a2;
                        v139 = v18;
                        v140 = v19;
                        v141 = v73;
                        v142 = v14;
                        v143 = v38;
                        silk_InitEncoder((uint64_t)a1 + v100, v137, (uint64_t)v587);
                        v38 = v143;
                        v14 = v142;
                        v73 = v141;
                        LODWORD(v19) = v140;
                        v18 = v139;
                        a2 = v566;
                        v74 = v138;
                        v98 = a1[3557];
                        v574 = 1;
                        if (v98 != 1002)
                        {
LABEL_275:
                          if (!a1[3564] && !a1[21])
                          {
                            v144 = 0;
                            v150 = a1[3561];
                            v149 = v577;
                            v151 = a1[33];
                            if (v150 > v151)
                              goto LABEL_360;
                            goto LABEL_303;
                          }
                          v144 = 0;
LABEL_280:
                          v145 = 9000;
                          v146 = ((2500 * v87 * v87) >> 14) + 11000;
                          v147 = ((2000 * v87 * v87) >> 14) + 12000;
                          v148 = a1[3564];
                          if (v148)
                          {
                            v111 = (int)v582 < v147;
                            v149 = v577;
                            if (!v111)
                            {
                              v150 = 1105;
                              a1[3562] = 1105;
                              a1[3561] = 1105;
                              v151 = a1[33];
                              if (v151 >= 1105)
                                goto LABEL_303;
LABEL_360:
                              a1[3561] = v151;
                              v150 = v151;
                              v156 = a1[32];
                              if (v156 != -1000)
                              {
LABEL_304:
                                a1[3561] = v156;
                                v150 = v156;
                                if (v98 == 1002)
                                  goto LABEL_366;
                                goto LABEL_362;
                              }
LABEL_361:
                              if (v98 == 1002)
                                goto LABEL_366;
LABEL_362:
                              if ((int)v74 <= 1874)
                              {
                                if (v150 >= 1103)
                                  v150 = 1103;
                                a1[3561] = v150;
                              }
LABEL_366:
                              v176 = a1[36];
                              if (v176 > 24000)
                                goto LABEL_386;
                              if (v150 <= 1104)
                              {
                                if (v176 >= 16001)
                                  goto LABEL_386;
                                if (v150 <= 1103)
                                {
                                  if (v176 >= 12001)
                                    goto LABEL_386;
                                  if (v150 <= 1102)
                                  {
                                    if (v150 == 1102 && v176 < 8001)
                                      goto LABEL_374;
                                    goto LABEL_386;
                                  }
LABEL_373:
                                  v150 = 1102;
                                  a1[3561] = 1102;
                                  if (v176 <= 8000)
                                  {
LABEL_374:
                                    v150 = 1101;
                                    a1[3561] = 1101;
                                  }
LABEL_386:
                                  if (v156 != -1000)
                                    goto LABEL_406;
                                  v178 = *v38;
                                  if (!*v38)
                                    goto LABEL_406;
                                  v179 = a1[3549];
                                  if ((int)v582 <= 18000 * v179)
                                  {
                                    if ((v144 & 1) != 0)
                                    {
                                      v181 = 1101;
                                      goto LABEL_401;
                                    }
                                  }
                                  else
                                  {
                                    if ((int)v582 <= 24000 * v179)
                                      v180 = v144;
                                    else
                                      v180 = 0;
                                    if ((v180 & 1) != 0)
                                    {
                                      v181 = 1102;
LABEL_401:
                                      if (v178 <= v181)
                                        v178 = v181;
                                      *v38 = v178;
                                      if (v150 >= v178)
                                        v150 = v178;
                                      a1[3561] = v150;
LABEL_406:
                                      v182 = a1[10];
                                      if (a1[12])
                                        v183 = v182 == 0;
                                      else
                                        v183 = 1;
                                      if (v183)
                                        v184 = 1;
                                      else
                                        v184 = v144;
                                      if ((v184 & 1) != 0)
                                      {
                                        v185 = 0;
                                        goto LABEL_446;
                                      }
                                      v186 = a1[13];
                                      if (v182 >= 25)
                                        v187 = 25;
                                      else
                                        v187 = a1[10];
                                      v188 = 125 - v187;
                                      v189 = 2 * v150;
                                      v190 = fec_thresholds[2 * v150 - 2202];
                                      v191 = fec_thresholds[2 * v150 - 2201];
                                      if (v182 <= 5)
                                      {
                                        if (v186 == 1)
                                          v192 = fec_thresholds[2 * v150 - 2201];
                                        else
                                          v192 = 0;
                                        v193 = v190 - v192;
                                        if (v186)
                                          v194 = 0;
                                        else
                                          v194 = v191;
                                        v185 = (int)v582 > (int)((unint64_t)(655 * (v193 + v194) * (int)v188) >> 16);
LABEL_446:
                                        LODWORD(v566) = v74;
                                        a1[13] = v185;
                                        v209 = opus_custom_encoder_ctl(v149, 4036, v100, v25, v26, v74, v75, (uint64_t)v38, (uint64_t)v580);
                                        v211 = a1[3557];
                                        if (v211 == 1002 && a1[3561] == 1102)
                                          a1[3561] = 1103;
                                        v212 = v581;
                                        v213 = v579;
                                        if (a1[44])
                                        {
                                          v214 = 1101;
                                          a1[3561] = 1101;
                                        }
                                        else
                                        {
                                          v214 = a1[3561];
                                          if (v211 == 1000 && v214 > 1103)
                                          {
                                            a1[3557] = 1001;
                                            v215 = a1[36];
                                            v216 = (v215 / 50);
                                            if (v215 / 50 >= (int)v19 && 3 * v215 / 50 >= (int)v19)
                                            {
                                              v211 = 1001;
                                              goto LABEL_474;
                                            }
                                            goto LABEL_469;
                                          }
                                        }
                                        if (v211 == 1001 && v214 < 1104)
                                        {
                                          v211 = 1000;
                                          a1[3557] = 1000;
                                          v215 = a1[36];
                                          LODWORD(v216) = v215 / 50;
                                          goto LABEL_456;
                                        }
                                        v215 = a1[36];
                                        v216 = (v215 / 50);
                                        if (v215 / 50 >= (int)v19 || v211 == 1000)
                                        {
LABEL_456:
                                          if (3 * v215 / 50 < (int)v19)
                                          {
                                            v217 = 2 * v215 / 25;
                                            if (3 * v215 / 25 == (_DWORD)v19)
                                              v218 = 3 * v215 / 50;
                                            else
                                              v218 = v216;
                                            v219 = v215 / 25;
                                            if (v217 != (_DWORD)v19)
                                              v219 = v218;
                                            if (v211 == 1000)
                                              v216 = v219;
                                            else
                                              v216 = v216;
                                            goto LABEL_469;
                                          }
LABEL_474:
                                          v221 = v570;
                                          if (a1[3563])
                                          {
                                            a1[3563] = 0;
                                            v573 = 1;
                                            v574 = 2;
                                            v221 = 1;
                                          }
                                          v222 = 0;
                                          v223 = a1[40];
                                          if (v211 == 1002)
                                          {
                                            v570 = 0;
                                          }
                                          else
                                          {
                                            v570 = 0;
                                            if (v221)
                                            {
                                              v224 = a1[3549];
                                              v225 = 40 * v224 + 20;
                                              v226 = 4123168605 * (v223 + v225 * (200 - v73));
                                              v227 = (v226 >> 42) + ((unint64_t)v226 >> 63);
                                              v228 = 240 * (8 * (int)v14 - 2 * v225) / (48000 / v73 + 240);
                                              v229 = __OFADD__(v228, v225);
                                              v230 = v228 + v225;
                                              if (v230 < 0 != v229)
                                                v230 += 7;
                                              v231 = v230 >> 3;
                                              if (v227 < v231)
                                                v231 = v227;
                                              v232 = (8 * v224) | 4;
                                              if (v231 >= 257)
                                                v233 = 257;
                                              else
                                                v233 = v231;
                                              if (v231 <= v232)
                                                v222 = 0;
                                              else
                                                v222 = v233;
                                              v570 = v222 != 0;
                                            }
                                          }
                                          LODWORD(v579) = v214;
                                          v565 = &v557;
                                          v562 = v222;
                                          v234 = v223 * (int)v19 / (8 * v215);
                                          if ((int)v14 - v222 < v234)
                                            v234 = v14 - v222;
                                          v560 = v234;
                                          v563 = v212 + 1;
                                          v585[0] = (uint64_t)(v212 + 1);
                                          *(_OWORD *)((char *)&v585[1] + 4) = xmmword_208F31AE0;
                                          *(_OWORD *)((char *)&v585[3] + 4) = xmmword_208F08BB0;
                                          v575 = v14 - 1;
                                          LODWORD(v585[1]) = v14 - 1;
                                          *(uint64_t *)((char *)&v585[5] + 4) = 0xFFFFFFFFLL;
                                          v561 = v578 + v19;
                                          MEMORY[0x24BDAC7A8](v209, v210);
                                          v236 = (float *)((char *)&v557 - v235);
                                          v238 = a1[28];
                                          LODWORD(v235) = (a1[43] - v237) * v238;
                                          v564 = a1 + 3573;
                                          v239 = (int)v238 * v237;
                                          v580 = (float32x4_t *)v236;
                                          memcpy(v236, &a1[(int)v235 + 3573], 4 * v239);
                                          v246 = a1[3557];
                                          if (v246 == 1002)
                                            v247 = 193536;
                                          else
                                            v247 = *(_DWORD *)(v572 + 8);
                                          v248 = a1[3551] + ((unint64_t)(983 * (v247 - a1[3551])) >> 16);
                                          a1[3551] = v248;
                                          v249 = &v580->f32[v239];
                                          v250 = (float *)(a1 + 3553);
                                          v251 = a1[36];
                                          v252 = v579;
                                          if (a1[27] == 2048)
                                          {
                                            if ((v248 & 0x80000000) != 0)
                                            {
                                              v253 = 0;
                                            }
                                            else if (v248 >> 8 <= 0xF7E)
                                            {
                                              v268 = ((int)v248 >> 8) >> 7;
                                              v269 = 1 << v268;
                                              v270 = ((v248 >> 8) & 0x7F)
                                                   + ((int)(-174 * ((v248 >> 8) & 0x7F) * (128 - ((v248 >> 8) & 0x7F))) >> 16);
                                              v271 = v270 * ((1 << v268) >> 7);
                                              v272 = v270 << v268 >> 7;
                                              if (v248 >> 19)
                                                v273 = v271;
                                              else
                                                v273 = v272;
                                              v253 = v273 + v269;
                                            }
                                            else
                                            {
                                              v253 = -1;
                                            }
                                            v274 = 0;
                                            v275 = 2471 * v253 / (v251 / 1000);
                                            v276 = -471 * v275 + 0x10000000;
                                            v277 = (float)(int)((unint64_t)((int)((unint64_t)(((v275 * (uint64_t)v275) << 16) - 0x80000000000000) >> 32)
                                                                                 * (uint64_t)(v276 >> 6)) >> 16)
                                                 * 0.0000000037253;
                                            v278 = (float)(int)((unint64_t)((v276 >> 6) * (uint64_t)(v276 >> 6)) >> 16)
                                                 * 0.0000000037253;
                                            v279 = (float)v276 * 0.0000000037253;
                                            v280 = (float)(942 * v275 - 0x20000000) * 0.0000000037253;
                                            v281 = v19;
                                            v282 = *((float *)a1 + 3553);
                                            v283 = *((float *)a1 + 3554);
                                            v284 = v19;
                                            do
                                            {
                                              v285 = a2[v274];
                                              v286 = v282 + (float)(v279 * v285);
                                              v282 = (float)(v283 - (float)(v286 * v277)) + (float)(v280 * v285);
                                              *((float *)a1 + 3553) = v282;
                                              v283 = (float)((float)(v279 * v285) - (float)(v286 * v278)) + 1.0e-30;
                                              *((float *)a1 + 3554) = v283;
                                              v249[v274] = v286;
                                              v274 += v238;
                                              --v284;
                                            }
                                            while (v284);
                                            if ((_DWORD)v238 == 2)
                                            {
                                              v287 = a2 + 1;
                                              v288 = v249 + 1;
                                              v289 = *((float *)a1 + 3555);
                                              v290 = *((float *)a1 + 3556);
                                              do
                                              {
                                                v291 = *v287;
                                                v287 += 2;
                                                v292 = v289 + (float)(v279 * v291);
                                                v289 = (float)(v290 - (float)(v292 * v277)) + (float)(v280 * v291);
                                                *((float *)a1 + 3555) = v289;
                                                v290 = (float)((float)(v279 * v291) - (float)(v292 * v278)) + 1.0e-30;
                                                *((float *)a1 + 3556) = v290;
                                                *v288 = v292;
                                                v288 += 2;
                                                --v281;
                                              }
                                              while (v281);
                                            }
                                          }
                                          else
                                          {
                                            v254 = 18.9 / (float)v251;
                                            v255 = 1.0 - v254;
                                            v256 = *v250;
                                            if ((_DWORD)v238 == 2)
                                            {
                                              v257 = *((float *)a1 + 3555);
                                              v258 = v19;
                                              v259 = &v580->f32[v239 + 1];
                                              v260 = a2 + 1;
                                              do
                                              {
                                                v261 = *(v260 - 1);
                                                v262 = v261 - v256;
                                                v263 = *v260 - v257;
                                                v256 = (float)((float)(v254 * v261) + 1.0e-30) + (float)(v255 * v256);
                                                v257 = (float)((float)(v254 * *v260) + 1.0e-30) + (float)(v255 * v257);
                                                *(v259 - 1) = v262;
                                                *v259 = v263;
                                                v259 += 2;
                                                v260 += 2;
                                                --v258;
                                              }
                                              while (v258);
                                              *((float *)a1 + 3553) = v256;
                                              *((float *)a1 + 3555) = v257;
                                            }
                                            else
                                            {
                                              v264 = v19;
                                              v265 = &v580->f32[v239];
                                              do
                                              {
                                                v266 = *a2++;
                                                v267 = v266 - v256;
                                                v256 = (float)((float)(v254 * v266) + 1.0e-30) + (float)(v255 * v256);
                                                *v265++ = v267;
                                                --v264;
                                              }
                                              while (v264);
                                              *v250 = v256;
                                            }
                                          }
                                          if (!a13)
                                          {
LABEL_528:
                                            v302 = 1.0;
                                            if (v246 == 1002)
                                            {
                                              v303 = v577;
                                              v304 = v252 - 1101;
                                              v305 = v561;
                                              LODWORD(v579) = v252;
                                              if ((v252 - 1101) <= 3)
                                              {
LABEL_530:
                                                v306 = dword_208F382F0[v304];
                                                goto LABEL_617;
                                              }
LABEL_616:
                                              v306 = 21;
LABEL_617:
                                              opus_custom_encoder_ctl(v303, 10012, v240, v241, v242, v243, v244, v245, v306);
                                              opus_custom_encoder_ctl(v303, 10008, v370, v371, v372, v373, v374, v375, a1[3549]);
                                              v382 = opus_custom_encoder_ctl(v303, 4002, v376, v377, v378, v379, v380, v381, 0xFFFFFFFFLL);
                                              if (a1[3557] == 1000)
                                              {
                                                v390 = a1[28];
                                                MEMORY[0x24BDAC7A8](v382, v383);
                                                v392 = (float32x4_t *)((char *)&v557 - v391);
                                                goto LABEL_631;
                                              }
                                              opus_custom_encoder_ctl(v303, 4006, v384, v385, v386, v387, v388, v389, 0);
                                              v399 = opus_custom_encoder_ctl(v303, 10002, v393, v394, v395, v396, v397, v398, 2 * (a1[19] == 0));
                                              v407 = a1[37];
                                              if (a1[3557] == 1001)
                                              {
                                                if (!v407)
                                                {
                                                  v390 = a1[28];
                                                  MEMORY[0x24BDAC7A8](v399, v400);
                                                  v392 = (float32x4_t *)((char *)&v557 - v431);
                                                  v427 = 1001;
LABEL_628:
                                                  v432 = a1[3558];
                                                  if (v427 != v432 && v432 >= 1)
                                                    memcpy(v392, &a1[(v426 / -400 - (int)v578 + a1[43]) * v390 + 3573], 4 * v428);
LABEL_631:
                                                  v433 = a1[43];
                                                  if ((v433 - v305) * v390 < 1)
                                                  {
                                                    v437 = (float32x4_t *)((char *)v580 + 4 * (v305 - v433) * v390);
                                                    v436 = 4 * v433 * v390;
                                                    v435 = v564;
                                                  }
                                                  else
                                                  {
                                                    memmove(v564, &a1[v390 * (int)v19 + 3573], 4 * ((v433 - v305) * v390));
                                                    v434 = a1[28];
                                                    v435 = &a1[(a1[43] - v305) * v434 + 3573];
                                                    v436 = 4 * v434 * v305;
                                                    v437 = v580;
                                                  }
                                                  memcpy(v435, v437, v436);
                                                  v439.i32[0] = a1[3552];
                                                  if (v439.f32[0] < 1.0 || v302 < 1.0)
                                                  {
                                                    *(float *)&v438 = v302;
                                                    gain_fade(v580->f32, (unint64_t)v580, *(_DWORD *)(v583 + 4), v19, a1[28], *(float **)(v583 + 72), a1[36], v439.f32[0], v438);
                                                  }
                                                  *((float *)a1 + 3552) = v302;
                                                  v440 = a1[3557];
                                                  if (v440 != 1001 || a1[3549] == 1)
                                                  {
                                                    if ((int)v582 <= 32000)
                                                    {
                                                      if ((int)v582 >= 16000)
                                                        v441 = 0x4000
                                                             - (65536000 - ((_DWORD)v582 << 11))
                                                             / (v582 - 14000);
                                                      else
                                                        v441 = 0;
                                                    }
                                                    else
                                                    {
                                                      v441 = 0x4000;
                                                    }
                                                    a1[23] = v441;
                                                  }
                                                  if (!*((_QWORD *)a1 + 1783) && a1[28] == 2)
                                                  {
                                                    v442 = *v13;
                                                    v443 = a1[23];
                                                    if (v442 < 0x4000 || v443 < 0x4000)
                                                    {
                                                      v439.f32[0] = (float)v442 * 0.000061035;
                                                      *(float *)&v438 = (float)v443 * 0.000061035;
                                                      stereo_fade(v580->f32, (unint64_t)v580, *(_DWORD *)(v583 + 4), v19, *(float32x4_t **)(v583 + 72), a1[36], v439, v438);
                                                      *v13 = v443;
                                                    }
                                                  }
                                                  v444 = v576;
                                                  if (v440 == 1002)
                                                    goto LABEL_671;
                                                  v445 = __clz(v585[4]);
                                                  v446 = v440 == 1001 ? 5 : -15;
                                                  if ((int)(LODWORD(v585[3]) + v445 + v446) > (int)(8 * v575))
                                                    goto LABEL_671;
                                                  if (v440 == 1001)
                                                    ec_enc_bit_logp(v585, v570, 12);
                                                  if (!v570)
                                                  {
LABEL_671:
                                                    LODWORD(v447) = 0;
                                                    v451 = 0;
                                                    a1[3563] = 0;
                                                    LODWORD(v572) = 1;
                                                  }
                                                  else
                                                  {
                                                    LODWORD(v447) = 1;
                                                    ec_enc_bit_logp(v585, v573, 1);
                                                    v448 = __clz(v585[4]);
                                                    if (*v444 == 1001)
                                                      v449 = -21;
                                                    else
                                                      v449 = -32;
                                                    v450 = v575 - ((int)(LODWORD(v585[3]) + v448 + v449 + 7) >> 3);
                                                    if (v450 >= v562)
                                                      v450 = v562;
                                                    if (v450 <= 2)
                                                      v450 = 2;
                                                    if (v450 >= 0x101)
                                                      v451 = 257;
                                                    else
                                                      v451 = v450;
                                                    if (*v444 == 1001)
                                                      ec_encode(v585, v451 - 2, v451 - 1, 0x100u);
                                                    LODWORD(v572) = 0;
                                                  }
                                                  v452 = *v444;
                                                  if (*v444 == 1002)
                                                    v453 = 0;
                                                  else
                                                    v453 = 17;
                                                  LODWORD(v582) = v447;
                                                  v574 = v451;
                                                  if (v452 == 1000)
                                                  {
                                                    v454 = ((int)(LODWORD(v585[3]) + __clz(v585[4]) - 25) >> 3);
                                                    ec_enc_done(v585);
                                                    v578 = v454;
                                                  }
                                                  else
                                                  {
                                                    v447 = v453;
                                                    v461 = v392;
                                                    v462 = v575 - v451;
                                                    memmove((void *)(v585[0] + v462 - HIDWORD(v585[1])), (const void *)(v585[0] + LODWORD(v585[1]) - HIDWORD(v585[1])), HIDWORD(v585[1]));
                                                    v454 = 0;
                                                    v578 = v462;
                                                    LODWORD(v585[1]) = v462;
                                                    v392 = v461;
                                                    v453 = v447;
                                                    LOBYTE(v447) = v582;
                                                  }
                                                  if ((v447 & 1) != 0 || *v444 != 1000)
                                                  {
                                                    opus_custom_encoder_ctl(v577, 10022, v455, v456, v457, v458, v459, v460, (uint64_t)&v588);
                                                    if (*v444 == 1001)
                                                    {
                                                      v587[0] = *(_QWORD *)(a1 + 25);
                                                      opus_custom_encoder_ctl(v577, 10028, v455, v456, v457, v458, v459, v460, (uint64_t)v587);
                                                    }
                                                    v464 = v573 != 0;
                                                    if (v573)
                                                      v465 = v582;
                                                    else
                                                      v465 = 0;
                                                    if (v465 == 1)
                                                    {
                                                      v466 = v577;
                                                      opus_custom_encoder_ctl(v577, 10010, v455, v456, v457, v458, v459, v460, 0);
                                                      opus_custom_encoder_ctl(v466, 4006, v467, v468, v469, v470, v471, v472, 0);
                                                      opus_custom_encoder_ctl(v466, 4002, v473, v474, v475, v476, v477, v478, 0xFFFFFFFFLL);
                                                      if ((celt_encode_with_ec(v466, v580, a1[36] / 200, (uint64_t)&v563[(int)v578], v574, 0) & 0x80000000) != 0)return 4294967293;
                                                      opus_custom_encoder_ctl(v466, 4031, v479, v480, v481, v482, v483, v484, (uint64_t)&v584);
                                                      opus_custom_encoder_ctl(v466, 4028, v485, v486, v487, v488, v489, v490, v557);
                                                      v463 = 1;
                                                      v464 = 1;
                                                    }
                                                    else
                                                    {
                                                      v463 = 0;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    v463 = 0;
                                                    v464 = v573 != 0;
                                                  }
                                                  v556 = v453;
                                                  v491 = v577;
                                                  opus_custom_encoder_ctl(v577, 10010, v455, v456, v457, v458, v459, v460, v556);
                                                  if (*v576 == 1000)
                                                    goto LABEL_704;
                                                  v498 = a1[3558];
                                                  if (*v576 != v498 && v498 >= 1)
                                                  {
                                                    opus_custom_encoder_ctl(v491, 4028, v492, v493, v494, v495, v496, v497, v557);
                                                    celt_encode_with_ec(v491, v392, a1[36] / 400, (uint64_t)v587, 2, 0);
                                                    opus_custom_encoder_ctl(v491, 10002, v499, v500, v501, v502, v503, v504, 0);
                                                  }
                                                  if ((int)(LODWORD(v585[3]) + __clz(v585[4]) - 32) > 8 * (int)v578)
                                                    goto LABEL_704;
                                                  if (v463 && *v576 == 1001 && a1[37])
                                                    opus_custom_encoder_ctl(v491, 4002, v492, v493, v494, v495, v496, v497, (a1[40] - a1[9]));
                                                  opus_custom_encoder_ctl(v491, 4006, v492, v493, v494, v495, v496, v497, a1[37]);
                                                  v505 = celt_encode_with_ec(v491, v580, v19, 0, v578, v585);
                                                  if ((v505 & 0x80000000) != 0)
                                                    return 4294967293;
                                                  v454 = v505;
                                                  if (v463 && *v576 == 1001)
                                                  {
                                                    v506 = v582;
                                                    if (a1[37])
                                                    {
                                                      v507 = v578;
                                                      memmove(&v563[v505], &v563[(int)v578], v574);
                                                      v578 = v507 + v574;
                                                    }
                                                  }
                                                  else
                                                  {
LABEL_704:
                                                    v506 = v582;
                                                  }
                                                  if (((v572 | v464) & 1) == 0)
                                                  {
                                                    v508 = v491;
                                                    v509 = a1[36] / 200;
                                                    v510 = a1[36] / 400;
                                                    opus_custom_encoder_ctl(v508, 4028, v492, v493, v494, v495, v496, v497, v557);
                                                    opus_custom_encoder_ctl(v508, 10010, v511, v512, v513, v514, v515, v516, 0);
                                                    opus_custom_encoder_ctl(v508, 10002, v517, v518, v519, v520, v521, v522, 0);
                                                    opus_custom_encoder_ctl(v508, 4006, v523, v524, v525, v526, v527, v528, 0);
                                                    opus_custom_encoder_ctl(v508, 4002, v529, v530, v531, v532, v533, v534, 0xFFFFFFFFLL);
                                                    if (a1[3557] == 1001)
                                                    {
                                                      memmove((void *)(v585[0] + v454 - HIDWORD(v585[1])), (const void *)(v585[0] + LODWORD(v585[1]) - HIDWORD(v585[1])), HIDWORD(v585[1]));
                                                      LODWORD(v585[1]) = v454;
                                                      v578 = v454;
                                                    }
                                                    v535 = a1[28] * (v19 - v509 - v510);
                                                    v536 = v510;
                                                    v537 = v580;
                                                    v538 = v577;
                                                    celt_encode_with_ec(v577, (float32x4_t *)((char *)v580 + 4 * v535), v536, (uint64_t)v587, 2, 0);
                                                    if ((celt_encode_with_ec(v538, (float32x4_t *)((char *)v537 + 4* a1[28]* ((int)v19 - v509)), v509, (uint64_t)&v563[(int)v578], v574, 0) & 0x80000000) != 0)return 4294967293;
                                                    opus_custom_encoder_ctl(v538, 4031, v539, v540, v541, v542, v543, v544, (uint64_t)&v584);
                                                    v506 = v582;
                                                  }
                                                  v545 = gen_toc(a1[3557], a1[36] / (int)v19, v579, a1[3549]);
                                                  v546 = v581;
                                                  *v581 = v545;
                                                  v547 = v585[4];
                                                  *((_DWORD *)v13 + 987) = v584 ^ LODWORD(v585[4]);
                                                  if (v568)
                                                  {
                                                    v548 = v576;
                                                    v549 = *v576;
                                                    v550 = v569;
                                                    v551 = v571;
                                                  }
                                                  else
                                                  {
                                                    v549 = 1002;
                                                    v550 = v569;
                                                    v551 = v571;
                                                    v548 = v576;
                                                  }
                                                  a1[3558] = v549;
                                                  v552 = a1[3549];
                                                  a1[3559] = v552;
                                                  a1[3560] = v19;
                                                  a1[3564] = 0;
                                                  if (a1[46] && v588 | v550 && !v551)
                                                  {
                                                    v554 = a1[36];
                                                    v555 = *((_DWORD *)v13 + 984) + 2000 * (int)v19 / v554;
                                                    *((_DWORD *)v13 + 984) = v555;
                                                    if (v555 >= 401)
                                                    {
                                                      if (v555 < 0x4B1)
                                                      {
                                                        *((_DWORD *)v13 + 987) = 0;
                                                        *v546 = gen_toc(*v548, v554 / (int)v19, v579, v552);
                                                        return 1;
                                                      }
                                                      *((_DWORD *)v13 + 984) = 400;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    *((_DWORD *)v13 + 984) = 0;
                                                  }
                                                  if ((int)(__clz(v547) + LODWORD(v585[3]) - 32) <= (int)(8 * v575))
                                                  {
                                                    if (*v548 == 1000)
                                                      v553 = v506;
                                                    else
                                                      v553 = 1;
                                                    if ((v553 & 1) == 0 && (int)v454 >= 3)
                                                    {
                                                      while (!v546[v454])
                                                      {
                                                        v111 = (int)v454 <= 3;
                                                        LODWORD(v454) = v454 - 1;
                                                        if (v111)
                                                        {
                                                          LODWORD(v454) = 2;
                                                          break;
                                                        }
                                                      }
                                                    }
                                                  }
                                                  else
                                                  {
                                                    *v563 = 0;
                                                    *((_DWORD *)v13 + 987) = 0;
                                                    LODWORD(v454) = 1;
                                                  }
                                                  if (a1[37])
                                                    return v574 + v454 + 1;
                                                  if (!opus_packet_pad(v546, v574 + v454 + 1, v14))return v14;
                                                  return 4294967293;
                                                }
                                                opus_custom_encoder_ctl(v303, 4002, v401, v402, v403, v404, v405, v406, (a1[40] - a1[9]));
                                                v399 = opus_custom_encoder_ctl(v303, 4020, v408, v409, v410, v411, v412, v413, 0);
                                              }
                                              else if (v407)
                                              {
                                                opus_custom_encoder_ctl(v303, 4006, v401, v402, v403, v404, v405, v406, 1);
                                                opus_custom_encoder_ctl(v303, 4020, v414, v415, v416, v417, v418, v419, a1[38]);
                                                v399 = opus_custom_encoder_ctl(v303, 4002, v420, v421, v422, v423, v424, v425, a1[40]);
                                              }
                                              v390 = a1[28];
                                              MEMORY[0x24BDAC7A8](v399, v400);
                                              v392 = (float32x4_t *)((char *)&v557 - v429);
                                              if (v427 == 1000)
                                                goto LABEL_631;
                                              goto LABEL_628;
                                            }
                                            MEMORY[0x24BDAC7A8](v249, v252);
                                            v309 = (8 * v560 - 8) * v73;
                                            v310 = *v576;
                                            v558 = (const __int16 *)((char *)&v557 - v311);
                                            v559 = &v557;
                                            if (v310 == 1001)
                                            {
                                              v312 = a1[37];
                                              v313 = compute_silk_rate_for_hybrid((8 * v560 - 8) * v73, v307, a1[36] == 50 * (_DWORD)v19, v312, a1[13], a1[3549]);
                                              a1[9] = v313;
                                              v314 = *((_QWORD *)a1 + 1783);
                                              if (!v314)
                                              {
                                                v338 = (float)((float)(v313 - v309) * 0.00097656) * 0.693147181;
                                                v339 = v313;
                                                v340 = exp(v338);
                                                v313 = v339;
                                                *(float *)&v340 = v340;
                                                v302 = 1.0 - *(float *)&v340;
                                                v303 = v577;
                                                v307 = v579;
                                                v310 = 1001;
                                                goto LABEL_564;
                                              }
                                              v307 = v579;
                                              v310 = 1001;
                                            }
                                            else
                                            {
                                              a1[9] = v309;
                                              v314 = *((_QWORD *)a1 + 1783);
                                              if (!v314)
                                              {
                                                v313 = v309;
                                                v303 = v577;
                                                goto LABEL_564;
                                              }
                                              v312 = a1[37];
                                              v313 = v309;
                                            }
                                            v303 = v577;
                                            if (v312 && !a1[44])
                                            {
                                              v315 = a1[3561];
                                              v316 = 8000.0;
                                              v317 = 16000.0;
                                              if (v315 == 1102)
                                                v318 = 15;
                                              else
                                                v318 = 17;
                                              if (v315 == 1102)
                                                v317 = 12000.0;
                                              if (v315 == 1101)
                                                v318 = 13;
                                              else
                                                v316 = v317;
                                              v319 = a1[28];
                                              if ((int)v319 < 1)
                                              {
                                                v322 = 0.0;
                                              }
                                              else
                                              {
                                                v320 = 0;
                                                v321 = (float *)(v314 + ((4 * v318) & 0x60));
                                                v322 = 0.0;
                                                v323.i64[0] = 0x3F0000003F000000;
                                                v323.i64[1] = 0x3F0000003F000000;
                                                v324.i64[0] = 0xC0000000C0000000;
                                                v324.i64[1] = 0xC0000000C0000000;
                                                do
                                                {
                                                  v325 = (float32x4_t *)(v314 + 84 * v320);
                                                  v326 = (int8x16_t)vmaxnmq_f32(vminnmq_f32(*v325, v323), v324);
                                                  v327 = (int8x16_t)vmaxnmq_f32(vminnmq_f32(v325[1], v323), v324);
                                                  v328 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)v326), (int8x16_t)vmulq_f32((float32x4_t)v326, v323), v326);
                                                  v329 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)v327), (int8x16_t)vmulq_f32((float32x4_t)v327, v323), v327);
                                                  v322 = (float)((float)((float)((float)((float)((float)((float)(v322 + *(float *)v328.i32) + *(float *)&v328.i32[1])
                                                                                               + *(float *)&v328.i32[2])
                                                                                       + *(float *)&v328.i32[3])
                                                                               + *(float *)v329.i32)
                                                                       + *(float *)&v329.i32[1])
                                                               + *(float *)&v329.i32[2])
                                                       + *(float *)&v329.i32[3];
                                                  if ((v318 & 0x18) != 8)
                                                  {
                                                    v330 = (int8x16_t)vmaxnmq_f32(vminnmq_f32(v325[2], v323), v324);
                                                    v331 = (int8x16_t)vmaxnmq_f32(vminnmq_f32(v325[3], v323), v324);
                                                    v332 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)v330), (int8x16_t)vmulq_f32((float32x4_t)v330, v323), v330);
                                                    v333 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)v331), (int8x16_t)vmulq_f32((float32x4_t)v331, v323), v331);
                                                    v322 = (float)((float)((float)((float)((float)((float)((float)(v322 + *(float *)v332.i32) + *(float *)&v332.i32[1])
                                                                                                 + *(float *)&v332.i32[2])
                                                                                         + *(float *)&v332.i32[3])
                                                                                 + *(float *)v333.i32)
                                                                         + *(float *)&v333.i32[1])
                                                                 + *(float *)&v333.i32[2])
                                                         + *(float *)&v333.i32[3];
                                                  }
                                                  v334 = v321;
                                                  v335 = v318 & 7;
                                                  do
                                                  {
                                                    v336 = *v334++;
                                                    v337 = fmaxf(fminf(v336, 0.5), -2.0);
                                                    if (v337 > 0.0)
                                                      v337 = v337 * 0.5;
                                                    v322 = v322 + v337;
                                                    --v335;
                                                  }
                                                  while (v335);
                                                  ++v320;
                                                  v321 += 21;
                                                }
                                                while (v320 != v319);
                                              }
                                              v341 = (int)(float)(v316
                                                                * (float)((float)((float)(v322 / (float)v318)
                                                                                * (float)(int)v319)
                                                                        + 0.2));
                                              if (-2 * v313 / 3 > v341)
                                                v341 = -2 * v313 / 3;
                                              if ((v315 & 0xFFFFFFFE) == 0x450)
                                                v341 = 3 * v341 / 5;
                                              v313 += v341;
                                              a1[9] = v313;
                                            }
LABEL_564:
                                            v342 = a1[36];
                                            v343 = a1[28];
                                            if (v307 == 1102)
                                              v344 = 12000;
                                            else
                                              v344 = 16000;
                                            if (v307 == 1101)
                                              v344 = 8000;
                                            v345 = a1[3549];
                                            a1[2] = v343;
                                            a1[3] = v345;
                                            a1[7] = v344;
                                            a1[8] = 1000 * (int)v19 / v342;
                                            if (v310 == 1001)
                                            {
                                              *(int32x2_t *)(a1 + 5) = vdup_n_s32(0x3E80u);
                                              v346 = v562;
                                            }
                                            else
                                            {
                                              *(_QWORD *)(a1 + 5) = 0x1F4000003E80;
                                              v346 = v562;
                                              if (v310 == 1000)
                                              {
                                                v347 = (_DWORD)v567 ? 16 * (int)v566 / 3 : 8 * (_DWORD)v566;
                                                if (v347 <= 7999)
                                                {
                                                  a1[5] = 12000;
                                                  if (v344 >= 12000)
                                                    v344 = 12000;
                                                  a1[7] = v344;
                                                  if (v347 <= 6999)
                                                  {
                                                    a1[5] = 8000;
                                                    a1[7] = 8000;
                                                  }
                                                }
                                              }
                                            }
                                            v567 = a1 + 2;
                                            v348 = a1[37];
                                            v349 = 8 * v575;
                                            a1[15] = v348 == 0;
                                            a1[16] = v349;
                                            v350 = !v570;
                                            if (v346 < 2)
                                              v350 = 1;
                                            if ((v350 & 1) != 0)
                                            {
                                              if (!v348)
                                              {
                                                if (v310 != 1001)
                                                  goto LABEL_593;
                                                goto LABEL_590;
                                              }
                                              if (v310 != 1001)
                                                goto LABEL_593;
                                            }
                                            else
                                            {
                                              v351 = v349 + ~(8 * v346);
                                              a1[16] = v351;
                                              if (v310 != 1001)
                                                goto LABEL_593;
                                              v349 = v351 - 20;
                                              if (!v348)
                                              {
LABEL_590:
                                                if (v349 >= v313 * (int)v19 / v342)
                                                  v349 = v313 * (int)v19 / v342;
                                                goto LABEL_592;
                                              }
                                            }
                                            v349 = (int)(compute_silk_rate_for_hybrid(v349 * v342 / (int)v19, v579, v342 == 50 * (_DWORD)v19, v348, a1[13], v345)* v19)/ v342;
LABEL_592:
                                            a1[16] = v349;
LABEL_593:
                                            if (v574)
                                            {
                                              LODWORD(v587[0]) = 0;
                                              v352 = (a1[43] - a1[29] - v342 / 400) * v343;
                                              v353 = v564;
                                              LODWORD(v308) = 1.0;
                                              gain_fade((float *)&v564[v352], (unint64_t)&v564[v352], *(_DWORD *)(v583 + 4), v342 / 400, v343, *(float **)(v583 + 72), v342, 0.0, v308);
                                              bzero(v353, v352 * 4);
                                              v354 = a1[43];
                                              v355 = (a1[28] * v354);
                                              v356 = v558;
                                              if ((int)v355 >= 1)
                                              {
                                                v357 = (float *)(a1 + 3573);
                                                v358 = (__int16 *)v558;
                                                do
                                                {
                                                  v359 = *v357++;
                                                  *v358++ = (uint64_t)rintf(fminf(fmaxf(v359 * 32768.0, -32768.0), 32767.0));
                                                  --v355;
                                                }
                                                while (v355);
                                              }
                                              silk_Encode(v572, v567, v356, v354, 0, (int *)v587, v574, v571);
                                              a1[18] = 0;
                                              v343 = a1[28];
                                              v303 = v577;
                                            }
                                            else
                                            {
                                              v356 = v558;
                                            }
                                            v360 = (v343 * v19);
                                            if ((int)v360 >= 1)
                                            {
                                              v361 = &v580->f32[v343 * (int)v578];
                                              v362 = (__int16 *)v356;
                                              do
                                              {
                                                v363 = *v361++;
                                                *v362++ = (uint64_t)rintf(fminf(fmaxf(v363 * 32768.0, -32768.0), 32767.0));
                                                --v360;
                                              }
                                              while (v360);
                                            }
                                            if (silk_Encode(v572, v567, v356, v19, v585, &v586, 0, v571))
                                              return 4294967293;
                                            v364 = *v576;
                                            if (*v576 == 1000)
                                            {
                                              v365 = a1[20];
                                              v366 = v579;
                                              switch(v365)
                                              {
                                                case 8000:
                                                  v366 = 1101;
                                                  break;
                                                case 16000:
                                                  v366 = 1103;
                                                  break;
                                                case 12000:
                                                  v366 = 1102;
                                                  break;
                                              }
                                            }
                                            else
                                            {
                                              v366 = v579;
                                            }
                                            if (a1[24])
                                            {
                                              v367 = *((_DWORD *)v13 + 986);
                                              a1[18] = v367 == 0;
                                              if (v586)
                                              {
                                                if (!v367)
                                                {
                                                  v368 = v366;
                                                  v369 = compute_redundancy_bytes(v14, a1[40], v73, a1[3549]);
                                                  v366 = v368;
                                                  v573 = 0;
                                                  v562 = v369;
                                                  v570 = v369 != 0;
                                                  a1[3563] = 1;
                                                }
LABEL_615:
                                                v304 = v366 - 1101;
                                                v305 = v561;
                                                LODWORD(v579) = v366;
                                                if ((v366 - 1101) <= 3)
                                                  goto LABEL_530;
                                                goto LABEL_616;
                                              }
                                            }
                                            else
                                            {
                                              a1[18] = 0;
                                              if (v586)
                                                goto LABEL_615;
                                            }
                                            *((_DWORD *)v13 + 987) = 0;
                                            v430 = gen_toc(v364, a1[36] / (int)v19, v366, a1[3549]);
                                            *v581 = v430;
                                            return 1;
                                          }
                                          v293 = (v238 * v19);
                                          if ((int)v293 < 1)
                                          {
                                            v295 = 0.0;
                                            goto LABEL_526;
                                          }
                                          if ((_DWORD)v293 == 1)
                                          {
                                            v294 = 0;
                                            v295 = 0.0;
                                          }
                                          else
                                          {
                                            v294 = v293 & 0xFFFFFFFE;
                                            v296 = &v580->f32[v239 + 1];
                                            v295 = 0.0;
                                            v297 = v294;
                                            do
                                            {
                                              v295 = (float)(v295 + (float)(*(v296 - 1) * *(v296 - 1)))
                                                   + (float)(*v296 * *v296);
                                              v296 += 2;
                                              v297 -= 2;
                                            }
                                            while (v297);
                                            if (v294 == v293)
                                            {
LABEL_526:
                                              if (v295 >= 1000000000.0)
                                              {
                                                v301 = v246;
                                                bzero(v249, 4 * (int)v293);
                                                v246 = v301;
                                                v252 = v579;
                                                *(_QWORD *)(a1 + 3553) = 0;
                                                *(_QWORD *)(a1 + 3555) = 0;
                                              }
                                              goto LABEL_528;
                                            }
                                          }
                                          v298 = v293 - v294;
                                          v299 = &v580->f32[v294 + v239];
                                          do
                                          {
                                            v300 = *v299++;
                                            v295 = v295 + (float)(v300 * v300);
                                            --v298;
                                          }
                                          while (v298);
                                          goto LABEL_526;
                                        }
LABEL_469:
                                        if ((_DWORD)v213 != -1)
                                          *((_QWORD *)a1 + 955) = v213;
                                        return encode_multiframe_packet(a1, (uint64_t)a2, (int)v19 / (int)v216, v216, v212, v18, v575, v580, a13);
                                      }
                                      if (v186 == 1)
                                      {
                                        if ((int)v582 <= (int)((unint64_t)(655 * (v190 - v191) * (int)v188) >> 16))
                                        {
                                          v195 = v150;
                                          v196 = v189 - 2204;
                                          v197 = v150 - 1;
                                          while (v195 >= 1102)
                                          {
                                            --v195;
                                            a1[3561] = v197;
                                            v198 = (unint64_t)(655
                                                                    * (fec_thresholds[v196] - fec_thresholds[v196 + 1])
                                                                    * (int)v188) >> 16;
                                            v196 -= 2;
                                            --v197;
                                            if ((int)v582 > (int)v198)
                                              goto LABEL_435;
                                          }
LABEL_445:
                                          v185 = 0;
                                          a1[3561] = v150;
                                          goto LABEL_446;
                                        }
                                      }
                                      else
                                      {
                                        if (v186)
                                          v199 = 0;
                                        else
                                          v199 = fec_thresholds[2 * v150 - 2201];
                                        if ((int)v582 <= (int)((unint64_t)(655 * (v199 + v190) * (int)v188) >> 16))
                                        {
                                          v200 = v150;
                                          if (v186)
                                          {
                                            v201 = v189 - 2204;
                                            v202 = v150 - 1;
                                            v203 = v582;
                                            while (v200 > 1101)
                                            {
                                              --v200;
                                              a1[3561] = v202;
                                              v204 = (unint64_t)(655 * fec_thresholds[v201] * v188) >> 16;
                                              v201 -= 2;
                                              --v202;
                                              v185 = 1;
                                              if (v203 > (int)v204)
                                                goto LABEL_446;
                                            }
                                          }
                                          else
                                          {
                                            v205 = v189 - 2204;
                                            v206 = v150 - 1;
                                            v207 = v582;
                                            while (v200 >= 1102)
                                            {
                                              a1[3561] = v206;
                                              --v200;
                                              v208 = (unint64_t)(655
                                                                      * (fec_thresholds[v205 + 1] + fec_thresholds[v205])
                                                                      * (int)v188) >> 16;
                                              v205 -= 2;
                                              --v206;
                                              v185 = 1;
                                              if (v207 > (int)v208)
                                                goto LABEL_446;
                                            }
                                          }
                                          goto LABEL_445;
                                        }
                                      }
LABEL_435:
                                      v185 = 1;
                                      goto LABEL_446;
                                    }
                                  }
                                  if ((int)v582 <= 30000 * v179)
                                  {
                                    v181 = 1103;
                                  }
                                  else if ((int)v582 <= 44000 * v179)
                                  {
                                    v181 = 1104;
                                  }
                                  else
                                  {
                                    v181 = 1105;
                                  }
                                  goto LABEL_401;
                                }
                              }
                              else
                              {
                                v150 = 1104;
                                a1[3561] = 1104;
                                if (v176 >= 16001)
                                  goto LABEL_386;
                              }
                              v150 = 1103;
                              a1[3561] = 1103;
                              if (v176 >= 12001)
                                goto LABEL_386;
                              goto LABEL_373;
                            }
                            if ((int)v582 >= v146)
                            {
                              v150 = 1104;
                              *(int32x2_t *)(v13 + 22) = vdup_n_s32(0x450u);
                              v151 = a1[33];
                              if (v151 < 1104)
                                goto LABEL_360;
                              goto LABEL_303;
                            }
                            if ((int)v582 >= 9000)
                            {
                              v150 = 1103;
                              a1[3562] = 1103;
                              a1[3561] = 1103;
                              v151 = a1[33];
                              if (v151 >= 1103)
                                goto LABEL_303;
                              goto LABEL_360;
                            }
                            goto LABEL_352;
                          }
                          v152 = a1[3562];
                          if (v152 < 1105)
                            v153 = 2000;
                          else
                            v153 = -2000;
                          v111 = (int)v582 < v153 + v147;
                          v149 = v577;
                          if (v111)
                          {
                            v100 = 1000;
                            if (v152 < 1104)
                              v154 = 1000;
                            else
                              v154 = -1000;
                            if ((int)v582 >= v154 + v146)
                            {
                              v150 = 1104;
                              v157 = 1;
                            }
                            else
                            {
                              if (v152 < 1103)
                                v155 = 700;
                              else
                                v155 = -700;
                              if ((int)v582 < v155 + 9000)
                              {
                                if (v152 >= 1102)
                                  v145 = 8300;
                                else
                                  v145 = 9700;
LABEL_352:
                                v157 = 0;
                                if ((int)v582 >= v145)
                                  v150 = 1103;
                                else
                                  v150 = 1101;
                                goto LABEL_355;
                              }
                              v157 = 0;
                              v150 = 1103;
                            }
                          }
                          else
                          {
                            v150 = 1105;
                            v157 = 1;
                          }
LABEL_355:
                          a1[3562] = v150;
                          a1[3561] = v150;
                          if (v148)
                            v175 = 1;
                          else
                            v175 = v144;
                          if ((v175 & 1) != 0)
                          {
                            v151 = a1[33];
                            if (v150 > v151)
                              goto LABEL_360;
                          }
                          else
                          {
                            v177 = v157 ^ 1;
                            if (a1[22])
                              v177 = 1;
                            if ((v177 & 1) != 0)
                            {
                              v144 = 0;
                              v151 = a1[33];
                              if (v150 > v151)
                                goto LABEL_360;
                            }
                            else
                            {
                              v144 = 0;
                              v150 = 1103;
                              a1[3561] = 1103;
                              v151 = a1[33];
                              if (v151 < 1103)
                                goto LABEL_360;
                            }
                          }
LABEL_303:
                          v156 = a1[32];
                          if (v156 != -1000)
                            goto LABEL_304;
                          goto LABEL_361;
                        }
LABEL_279:
                        v144 = 1;
                        goto LABEL_280;
                      }
                    }
                    else
                    {
                      if (v98 == 1002)
                      {
                        v574 = 0;
                        if (v77 <= 4)
                          LODWORD(v582) = 9 * (int)v582 / 10;
                        v98 = 1002;
                        goto LABEL_279;
                      }
                      LODWORD(v582) = v582 - (int)v582 * v76 / v89;
                      if (v117 == 1002)
                        goto LABEL_268;
                    }
                    v574 = 0;
                    if (v98 != 1002)
                      goto LABEL_275;
                    goto LABEL_279;
                  }
LABEL_261:
                  v65 += (-40 * v40 - 20) * (v73 - 50);
                  goto LABEL_262;
                }
LABEL_260:
                a1[17] = 0;
                if (!(_DWORD)v75)
                  goto LABEL_262;
                goto LABEL_261;
              }
            }
            v575 = 0;
            v573 = 0;
            v570 = 0;
            v568 = 1;
            if (v40 != 1)
              goto LABEL_260;
            goto LABEL_198;
          }
LABEL_131:
          v100 = v582;
          goto LABEL_183;
        }
        v105 = a1[35];
        if (v105 < 0)
        {
          if (a1[27] == 2048)
            v87 = 115;
          else
            v87 = 48;
          v88 = v77 + 90;
          v89 = 12 * v76 + 20;
          v90 = a1[30];
          if (v90 != -1000)
            goto LABEL_116;
        }
        else
        {
          v106 = (327 * v105) >> 8;
          if (v106 >= 115)
            v107 = 115;
          else
            v107 = v106;
          if (a1[27] == 2049)
            v87 = v107;
          else
            v87 = v106;
          v88 = v77 + 90;
          v89 = 12 * v76 + 20;
          v90 = a1[30];
          if (v90 != -1000)
            goto LABEL_116;
        }
      }
LABEL_108:
      if (v40 == 2)
      {
        if (a1[3549] == 2)
          v91 = 16000;
        else
          v91 = 18000;
        if (v78 * v88 / 100 - v78 * v88 / 100 * v76 / v89 <= (int)(v91 + ((2000 * v87 * v87) >> 14)))
          v40 = 1;
        else
          v40 = 2;
      }
      goto LABEL_118;
    }
    if (v65 >= 2400 && (int)v74 >= 300)
    {
      v571 = v39;
      v75 = 0;
      v76 = a1[10];
      v77 = a1[11];
      v78 = v65;
      if (v66)
        goto LABEL_105;
      goto LABEL_104;
    }
  }
  v79 = a1[3557];
  if (a1[3561])
    v80 = a1[3561];
  else
    v80 = 1101;
  if (!v79)
    v79 = 1000;
  if (v73 > 100)
    v79 = 1002;
  v81 = v73 == 25 && v79 != 1000;
  if (v73 == 25 && v79 != 1000)
    v82 = 50;
  else
    v82 = v67 / (int)v19;
  if (v82 > 16)
  {
    LOBYTE(v84) = 0;
    v85 = v82;
    v83 = v581;
    if (v80 < 1104)
      goto LABEL_210;
  }
  else
  {
    v83 = v581;
    if (v18 == 1 || v79 == 1000 && v82 != 10)
    {
      LOBYTE(v84) = 0;
      v81 = v82 < 13;
      if (v82 == 12)
        v85 = 25;
      else
        v85 = 16;
      v79 = 1000;
      if (v80 < 1104)
      {
LABEL_210:
        if (v80 == 1102 && v79 == 1002)
        {
          v80 = 1101;
          v119 = a1[3549];
          if (v85 > 0x18F)
            goto LABEL_220;
        }
        else
        {
          if (v79 == 1001 && v80 < 1105)
            v80 = 1104;
          v119 = a1[3549];
          if (v85 > 0x18F)
            goto LABEL_220;
        }
        goto LABEL_207;
      }
    }
    else
    {
      v85 = 50;
      v81 = 3;
      v84 = 50 / v82;
      if (v80 < 1104)
        goto LABEL_210;
    }
  }
  if (v79 != 1000)
    goto LABEL_210;
  v80 = 1103;
  v119 = a1[3549];
  if (v85 > 0x18F)
  {
LABEL_220:
    v120 = 0;
    goto LABEL_221;
  }
LABEL_207:
  v120 = 0;
  do
  {
    v85 *= 2;
    v120 += 8;
  }
  while ((int)v85 < 400);
LABEL_221:
  if (v80 <= 1102)
    v122 = 78;
  else
    v122 = v80;
  v123 = (32 * v122 + 64) & 0x60 | v120 | 0x80;
  v124 = (v120 - 16) | (16 * v80) | 0x60;
  v125 = (v120 - 16) | (32 * v80 + 96) & 0xE0;
  if (v79 != 1000)
    v125 = v124;
  if (v79 == 1002)
    v126 = v123;
  else
    v126 = v125;
  *v83 = v126 | (4 * (v119 == 2)) | v81;
  if (v81 < 2)
    v127 = 1;
  else
    v127 = 2;
  if ((int)v14 <= (int)v127)
    v15 = v127;
  else
    v15 = v14;
  if (v81 == 3)
    v83[1] = v84;
  if (a1[37])
    return v127;
  if ((int)v127 < (int)v14)
  {
    memset(v587, 0, sizeof(v587));
    memmove(&v83[v15 - v127], v83, v127);
    if (opus_repacketizer_cat_impl((uint64_t)v587, &v83[v15 - v127], v127, 0)
      || (opus_repacketizer_out_range_impl((uint64_t)v587, 0, SHIDWORD(v587[0]), v83, v15, 0, 1) & 0x80000000) != 0)
    {
      return 4294967293;
    }
  }
  return v15;
}

uint64_t user_bitrate_to_bitrate(_DWORD *a1, int a2)
{
  uint64_t v2;

  if (a2)
  {
    v2 = a1[41];
    if ((_DWORD)v2 != -1)
      goto LABEL_3;
    return (10208 * a1[36] / a2);
  }
  a2 = a1[36] / 400;
  v2 = a1[41];
  if ((_DWORD)v2 == -1)
    return (10208 * a1[36] / a2);
LABEL_3:
  if ((_DWORD)v2 == -1000)
    return (60 * a1[36] / a2 + a1[28] * a1[36]);
  return v2;
}

uint64_t gen_toc(int a1, int a2, int a3, int a4)
{
  char v4;
  char v5;
  char v6;
  char v7;
  char v8;

  if (a2 > 399)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    do
    {
      a2 *= 2;
      v4 += 8;
    }
    while (a2 < 400);
  }
  if (a3 <= 1102)
    v5 = 78;
  else
    v5 = a3;
  v6 = (32 * v5 + 64) & 0x60 | v4 | 0x80;
  v7 = (v4 - 16) | (16 * a3) | 0x60;
  v8 = (v4 - 16) | (32 * a3 + 96) & 0xE0;
  if (a1 != 1000)
    v8 = v7;
  if (a1 == 1002)
    v8 = v6;
  return (v8 | (4 * (a4 == 2)));
}

uint64_t encode_multiframe_packet(_DWORD *a1, uint64_t a2, int a3, uint64_t a4, _BYTE *a5, int a6, uint64_t a7, unsigned int a8, int a9)
{
  unint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  _DWORD *v23;
  int v24;
  unint64_t v25;
  signed int v26;
  uint64_t result;
  signed int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  _BYTE *v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  _DWORD v40[124];
  uint64_t v41;

  v39 = a8;
  v33 = a5;
  v38 = a2;
  v41 = *MEMORY[0x24BDAC8D0];
  v11 = (a3 - 1);
  v12 = 2 * v11 + 2;
  if (a3 == 2)
    v12 = 3;
  if (!a1[37] && a1[41] != -1 && 3 * a1[40] / (24 * a1[36] / ((int)a4 * a3)) < a6)
    a6 = 3 * a1[40] / (24 * a1[36] / ((int)a4 * a3));
  v13 = (a6 - v12) / a3;
  if (v13 < 1276)
    v14 = (v13 + 1);
  else
    v14 = 1276;
  MEMORY[0x24BDAC7A8](a1, a2);
  v18 = (unsigned __int8 *)&v29 - v17;
  v40[1] = 0;
  v19 = a1[34];
  v31 = a1[32];
  v32 = v19;
  v20 = a1[30];
  a1[34] = a1[3557];
  a1[32] = a1[3561];
  v21 = a1[3549];
  a1[30] = v21;
  v29 = a1[17];
  v30 = v20;
  v34 = v22;
  if (!v29)
  {
    a1[3559] = v21;
    v35 = v15;
    if (v15 < 1)
      goto LABEL_20;
LABEL_14:
    v23 = a1 + 4536;
    v36 = v35;
    v37 = (int)v14;
    v24 = 0;
    v25 = 0;
    if (v16)
    {
      while (1)
      {
        a1[17] = 0;
        *v23 = v25 < v11;
        if (v11 == v25)
          a1[34] = 1002;
        v26 = opus_encode_native(a1, v38 + 4 * v24 * a1[28], a4, v18, v14, v39, 0, 0, 0, 0, 0, a9);
        if (v26 < 0 || (opus_repacketizer_cat_impl((uint64_t)v40, v18, v26, 0) & 0x80000000) != 0)
          break;
        ++v25;
        v18 += v37;
        v24 += a4;
        if (v36 == v25)
          goto LABEL_20;
      }
    }
    else
    {
      while (1)
      {
        a1[17] = 0;
        *v23 = v25 < v11;
        v28 = opus_encode_native(a1, v38 + 4 * v24 * a1[28], a4, v18, v14, v39, 0, 0, 0, 0, 0, a9);
        if (v28 < 0 || (opus_repacketizer_cat_impl((uint64_t)v40, v18, v28, 0) & 0x80000000) != 0)
          break;
        ++v25;
        v18 += v37;
        v24 += a4;
        if (v36 == v25)
          goto LABEL_20;
      }
    }
    return 4294967293;
  }
  a1[30] = 1;
  v35 = v15;
  if (v15 >= 1)
    goto LABEL_14;
LABEL_20:
  result = opus_repacketizer_out_range_impl((uint64_t)v40, 0, v35, v33, v34, 0, a1[37] == 0);
  if ((result & 0x80000000) == 0)
  {
    a1[34] = v32;
    a1[32] = v31;
    a1[30] = v30;
    a1[17] = v29;
    return result;
  }
  return 4294967293;
}

uint64_t compute_redundancy_bytes(int a1, int a2, int a3, int a4)
{
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  BOOL v8;
  int v9;
  int v10;
  unsigned int v11;

  v4 = 40 * a4 + 20;
  v5 = 4123168605 * (a2 + v4 * (200 - a3));
  v6 = (v5 >> 42) + ((unint64_t)v5 >> 63);
  v7 = 240 * (8 * a1 - 2 * v4) / (48000 / a3 + 240);
  v8 = __OFADD__(v7, v4);
  v9 = v7 + v4;
  if (v9 < 0 != v8)
    v9 += 7;
  v10 = v9 >> 3;
  if (v6 < v10)
    v10 = v6;
  if (v10 >= 257)
    v11 = 257;
  else
    v11 = v10;
  if (v10 <= ((8 * a4) | 4))
    return 0;
  else
    return v11;
}

uint64_t compute_silk_rate_for_hybrid(int a1, int a2, int a3, int a4, int a5, int a6)
{
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;

  v6 = a1 / a6;
  v7 = a3 + 2 * a5 + 1;
  if (a1 / a6 < 12000)
  {
    v8 = 1;
LABEL_13:
    v9 = (int)((v6 - compute_silk_rate_for_hybrid_rate_table[5 * v8 - 5])
             * compute_silk_rate_for_hybrid_rate_table[5 * v8 + v7]
             + (compute_silk_rate_for_hybrid_rate_table[5 * v8] - v6)
             * compute_silk_rate_for_hybrid_rate_table[5 * v8 - 5 + v7])
       / (compute_silk_rate_for_hybrid_rate_table[5 * v8] - compute_silk_rate_for_hybrid_rate_table[5 * v8 - 5]);
    goto LABEL_14;
  }
  if (v6 >> 7 < 0x7D)
  {
    v8 = 2;
    goto LABEL_13;
  }
  if (v6 >> 5 < 0x271)
  {
    v8 = 3;
    goto LABEL_13;
  }
  if (v6 >> 6 < 0x177)
  {
    v8 = 4;
    goto LABEL_13;
  }
  if (v6 >> 8 < 0x7D)
  {
    v8 = 5;
    goto LABEL_13;
  }
  if (v6 >> 9 < 0x7D)
  {
    v8 = 6;
    goto LABEL_13;
  }
  v9 = compute_silk_rate_for_hybrid_rate_table[v7 + 30] + ((v6 - 64000) >> 1);
LABEL_14:
  if (!a4)
    v9 += 100;
  if (a2 == 1104)
    v9 += 300;
  v10 = v9 * a6;
  if ((int)v6 > 11999 && a6 == 2)
    return v10 - 1000;
  else
    return v10;
}

float *gain_fade(float *result, unint64_t a2, int a3, int a4, int a5, float *a6, int a7, float a8, double a9)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  float *v13;
  uint64_t v14;
  float v15;
  uint64_t v16;
  unint64_t v17;
  float *v18;
  float *v19;
  BOOL v21;
  float32x4_t v23;
  uint64_t v29;
  const float *v30;
  float *v31;
  __int32 *v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  uint64_t v36;
  uint64_t v37;
  float *v38;
  float *v39;
  float *v40;
  uint64_t v41;
  float v42;
  float v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  BOOL v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  float *v52;
  uint64_t v53;
  float *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  float32x4_t v62;
  float32x4_t *v63;
  uint64_t v64;
  uint64_t v65;
  float32x4x2_t v66;
  float32x4x2_t v67;

  v9 = 48000 / a7;
  v10 = (a3 / (48000 / a7));
  if (a5 == 1)
  {
    if ((int)v10 >= 1)
    {
      v11 = 4 * v9;
      v12 = result;
      v13 = (float *)a2;
      v14 = (a3 / (48000 / a7));
      do
      {
        v15 = *v12++;
        *v13++ = v15
               * (float)((float)((float)(1.0 - (float)(*a6 * *a6)) * a8) + (float)((float)(*a6 * *a6) * *(float *)&a9));
        a6 = (float *)((char *)a6 + v11);
        --v14;
      }
      while (v14);
    }
    goto LABEL_30;
  }
  if ((int)v10 < 1)
    goto LABEL_30;
  if (v10 < 8)
  {
    v16 = 0;
LABEL_28:
    v36 = v10 - v16;
    v37 = (8 * v16) | 4;
    v38 = (float *)(a2 + v37);
    v39 = (float *)((char *)result + v37);
    v40 = &a6[v16 * v9];
    v41 = 4 * v9;
    do
    {
      v42 = (float)((float)(1.0 - (float)(*v40 * *v40)) * a8) + (float)((float)(*v40 * *v40) * *(float *)&a9);
      *(v38 - 1) = *(v39 - 1) * v42;
      v43 = *v39;
      v39 += 2;
      *v38 = v43 * v42;
      v38 += 2;
      v40 = (float *)((char *)v40 + v41);
      --v36;
    }
    while (v36);
    goto LABEL_30;
  }
  v16 = 0;
  v17 = a2 + 8 * v10;
  v18 = &a6[(v10 - 1) * v9];
  if (v18 <= a6)
    v19 = &a6[(v10 - 1) * v9];
  else
    v19 = a6;
  if (v18 < a6)
    v18 = a6;
  v21 = (unint64_t)&result[2 * v10] > a2 && v17 > (unint64_t)result;
  if ((unint64_t)v19 < v17 && (unint64_t)(v18 + 1) > a2)
    goto LABEL_28;
  if (v21)
    goto LABEL_28;
  v16 = v10 & 0x7FFFFFFC;
  v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
  __asm { FMOV            V3.4S, #1.0 }
  v29 = v10 & 0xFFFFFFFC;
  v30 = result;
  v31 = (float *)a2;
  v32 = (__int32 *)a6;
  do
  {
    v33.i32[0] = *v32;
    v33.i32[1] = v32[v9];
    v33.i32[2] = v32[2 * v9];
    v33.i32[3] = v32[3 * v9];
    v34 = vmulq_f32(v33, v33);
    v35 = vmlaq_f32(vmulq_n_f32(vsubq_f32(_Q3, v34), a8), v23, v34);
    v66 = vld2q_f32(v30);
    v30 += 8;
    v67.val[0] = vmulq_f32(v66.val[0], v35);
    v67.val[1] = vmulq_f32(v66.val[1], v35);
    vst2q_f32(v31, v67);
    v31 += 8;
    v32 += 4 * v9;
    v29 -= 4;
  }
  while (v29);
  if (v16 != v10)
    goto LABEL_28;
LABEL_30:
  if ((int)v10 < a4)
  {
    v44 = 0;
    v45 = (int)v10;
    v46 = a4;
    v47 = a4 - (uint64_t)(int)v10;
    v48 = v47 < 8;
    if (a5 <= 1)
      v49 = 1;
    else
      v49 = a5;
    v50 = (int)v10;
    v51 = v50 * 4 + a2;
    v52 = &result[v50];
    if (a5 != 1)
      v48 = 1;
    v53 = (int)v10 * (uint64_t)a5;
    v54 = &result[v53];
    v55 = 32 * a5;
    v56 = v53 * 4 + a2 + 16;
    v57 = 4 * a5;
    do
    {
      v58 = v51 + 4 * v44 - (unint64_t)&v52[v44] < 0x20 || v48;
      v59 = v45;
      if ((v58 & 1) != 0)
        goto LABEL_45;
      v60 = 0;
      v61 = v47 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        v62 = vmulq_n_f32(*(float32x4_t *)((char *)v54 + v60 + 16), *(float *)&a9);
        v63 = (float32x4_t *)(v56 + v60);
        v63[-1] = vmulq_n_f32(*(float32x4_t *)((char *)v54 + v60), *(float *)&a9);
        *v63 = v62;
        v60 += v55;
        v61 -= 8;
      }
      while (v61);
      v59 = (v47 & 0xFFFFFFFFFFFFFFF8) + v45;
      if (v47 != (v47 & 0xFFFFFFFFFFFFFFF8))
      {
LABEL_45:
        v64 = v46 - v59;
        v65 = v57 * v59;
        do
        {
          *(float *)(a2 + v65) = *(float *)((char *)result + v65) * *(float *)&a9;
          v65 += v57;
          --v64;
        }
        while (v64);
      }
      ++v44;
      ++v54;
      v56 += 4;
      a2 += 4;
      ++result;
    }
    while (v44 != v49);
  }
  return result;
}

float32_t stereo_fade(const float *a1, unint64_t a2, int a3, unsigned int a4, float32x4_t *a5, int a6, float32x4_t a7, double a8)
{
  int v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v12;
  unint64_t v13;
  BOOL v15;
  float32x4_t v17;
  float32x4_t v22;
  uint64_t v23;
  const float *v24;
  float *v25;
  float32x4_t *v26;
  float32x4_t v27;
  float32x4_t v28;
  uint64_t v29;
  float *v30;
  float *v31;
  unint64_t v32;
  float *v33;
  uint64_t v34;
  float v35;
  float v36;
  float v37;
  unint64_t v38;
  float *v39;
  const float *v40;
  unint64_t v41;
  float32x4_t v42;
  uint64_t v43;
  float *v44;
  float *v45;
  unint64_t v46;
  float v47;
  float v48;
  float v49;
  float32x4x2_t v51;
  float32x4x2_t v52;
  float32x4x2_t v53;
  float32x4x2_t v54;
  float32x4x2_t v55;

  v8 = 48000 / a6;
  v9 = (a3 / (48000 / a6));
  *(float *)&a8 = 1.0 - *(float *)&a8;
  if ((int)v9 < 1)
  {
    LODWORD(v9) = 0;
  }
  else
  {
    a7.f32[0] = 1.0 - a7.f32[0];
    v10 = v8;
    if (v9 < 4 || v8 != 1)
    {
      v12 = 0;
LABEL_22:
      v29 = (8 * v12) | 4;
      v30 = (float *)((char *)a1 + v29);
      v31 = (float *)(a2 + v29);
      v32 = v9 - v12;
      v33 = &a5->f32[v12 * v10];
      v34 = 4 * v10;
      do
      {
        v35 = (float)((float)(a7.f32[0] * (float)(1.0 - (float)(*v33 * *v33)))
                    + (float)((float)(*v33 * *v33) * *(float *)&a8))
            * (float)((float)(*(v30 - 1) - *v30) * 0.5);
        v36 = *(v31 - 1) - v35;
        v37 = *v31 + v35;
        *(v31 - 1) = v36;
        *v31 = v37;
        v30 += 2;
        v31 += 2;
        v33 = (float *)((char *)v33 + v34);
        --v32;
      }
      while (v32);
      goto LABEL_24;
    }
    v12 = 0;
    v13 = a2 + 8 * v9;
    v15 = (unint64_t)&a1[2 * v9] > a2 && v13 > (unint64_t)a1;
    if (v13 > (unint64_t)a5 && (unint64_t)a5->u64 + 4 * v9 > a2)
      goto LABEL_22;
    if (v15)
      goto LABEL_22;
    v12 = v9 & 0x7FFFFFFC;
    v17 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
    __asm { FMOV            V3.4S, #1.0 }
    v22.i64[0] = 0x3F0000003F000000;
    v22.i64[1] = 0x3F0000003F000000;
    v23 = v9 & 0xFFFFFFFC;
    v24 = a1;
    v25 = (float *)a2;
    v26 = a5;
    do
    {
      v53 = vld2q_f32(v24);
      v24 += 8;
      v27 = vmulq_f32(*v26, *v26);
      v28 = vmulq_f32(vmlaq_f32(vmulq_n_f32(vsubq_f32(_Q3, v27), a7.f32[0]), v17, v27), vmulq_f32(vsubq_f32(v53.val[0], v53.val[1]), v22));
      v54 = vld2q_f32(v25);
      v55.val[0] = vsubq_f32(v54.val[0], v28);
      v55.val[1] = vaddq_f32(v54.val[1], v28);
      vst2q_f32(v25, v55);
      v25 += 8;
      v26 += v10;
      v23 -= 4;
    }
    while (v23);
    if (v12 != v9)
      goto LABEL_22;
  }
LABEL_24:
  if ((int)v9 < (int)a4)
  {
    v9 = v9;
    v38 = a4 - (unint64_t)v9;
    if (v38 < 4)
      goto LABEL_31;
    v39 = (float *)(a2 + 8 * v9);
    v40 = &a1[2 * v9];
    if (v39 < &a1[2 * a4] && (unint64_t)v40 < a2 + 8 * a4)
      goto LABEL_31;
    v9 = (v38 & 0xFFFFFFFFFFFFFFFCLL) + v9;
    a7.i64[0] = 0x3F0000003F000000;
    a7.i64[1] = 0x3F0000003F000000;
    v41 = v38 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v51 = vld2q_f32(v40);
      v40 += 8;
      v51.val[0] = vmulq_n_f32(vmulq_f32(vsubq_f32(v51.val[0], v51.val[1]), a7), *(float *)&a8);
      *(float32x4x2_t *)((char *)&v51 + 16) = vld2q_f32(v39);
      v52.val[0] = vsubq_f32(v51.val[1], v51.val[0]);
      v52.val[1] = vaddq_f32(v42, v51.val[0]);
      vst2q_f32(v39, v52);
      v39 += 8;
      v41 -= 4;
    }
    while (v41);
    if (v38 != (v38 & 0xFFFFFFFFFFFFFFFCLL))
    {
LABEL_31:
      v43 = (8 * v9) | 4;
      v44 = (float *)((char *)a1 + v43);
      v45 = (float *)(a2 + v43);
      v46 = a4 - v9;
      a7.i32[0] = 0.5;
      do
      {
        v47 = *(float *)&a8 * (float)((float)(*(v44 - 1) - *v44) * 0.5);
        v48 = *(v45 - 1) - v47;
        v49 = *v45 + v47;
        *(v45 - 1) = v48;
        *v45 = v49;
        v44 += 2;
        v45 += 2;
        --v46;
      }
      while (v46);
    }
  }
  return a7.f32[0];
}

uint64_t opus_encode(uint64_t a1, uint64_t a2, int a3)
{
  signed int v3;
  int v4;
  unsigned int v5;
  char v6;
  BOOL v7;
  int v8;
  BOOL v9;
  __int16 v10;
  char v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float *v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  int16x8_t *v25;
  float32x4_t *v26;
  float32x4_t v27;
  uint64_t v28;
  int16x8_t v29;
  float32x4_t v30;
  float32x4_t v31;
  uint64_t v32;
  float *v33;
  __int16 *v34;
  int v35;
  _QWORD v36[2];

  v36[1] = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 144);
  if (v3 / 400 > a3)
    return 0xFFFFFFFFLL;
  v4 = a3;
  v5 = *(_DWORD *)(a1 + 156);
  if (v5 != 5000)
  {
    v6 = v5 + 119;
    if (v5 - 5001 > 8)
      return 0xFFFFFFFFLL;
    v7 = v5 >> 1 > 0x9C6;
    v8 = (int)((v5 - 5003) * v3) / 50;
    a3 = v7 ? v8 : (v3 / 400) << v6;
    if (a3 > v4)
      return 0xFFFFFFFFLL;
  }
  if (400 * a3 == v3 || 200 * a3 == v3 || 100 * a3 == v3)
  {
    if (a3 >= 1)
      goto LABEL_18;
    return 0xFFFFFFFFLL;
  }
  v9 = 25 * a3 == v3;
  v10 = (50 * a3 != v3) & vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(vdupq_n_s32(50 * a3), vmulq_s32(vdupq_n_s32(v3), (int32x4_t)xmmword_208F382E0)))), 0xFuLL)));
  if (v9)
    v11 = 0;
  else
    v11 = v10;
  v12 = 0xFFFFFFFFLL;
  if (a3 >= 1 && (v11 & 1) == 0)
  {
LABEL_18:
    v13 = (int *)MEMORY[0x24BDAC7A8](a1, a2);
    v20 = (float *)((char *)v36 - v19);
    v21 = v13[28];
    v22 = v21 * v14;
    if ((int)v22 >= 1)
    {
      if (v22 >= 0x10)
      {
        v23 = v22 & 0x7FFFFFF0;
        v25 = (int16x8_t *)(v17 + 16);
        v26 = (float32x4_t *)(v20 + 8);
        v27.i64[0] = 0x3800000038000000;
        v27.i64[1] = 0x3800000038000000;
        v28 = v22 & 0xFFFFFFF0;
        do
        {
          v29 = v25[-1];
          v30 = vcvtq_f32_s32(vmovl_high_s16(*v25));
          v31 = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v25->i8)), v27);
          v26[-2] = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v29.i8)), v27);
          v26[-1] = vmulq_f32(vcvtq_f32_s32(vmovl_high_s16(v29)), v27);
          *v26 = v31;
          v26[1] = vmulq_f32(v30, v27);
          v26 += 4;
          v25 += 2;
          v28 -= 16;
        }
        while (v28);
        if (v23 == v22)
          return opus_encode_native(v13, v20, v14, v15, v16, 16, v17, v18, 0, 0xFFFFFFFE, v21, (uint64_t)downmix_int, 0);
      }
      else
      {
        v23 = 0;
      }
      v32 = v22 - v23;
      v33 = &v20[v23];
      v34 = (__int16 *)(v17 + 2 * v23);
      do
      {
        v35 = *v34++;
        *v33++ = (float)v35 * 0.000030518;
        --v32;
      }
      while (v32);
    }
    return opus_encode_native(v13, v20, v14, v15, v16, 16, v17, v18, 0, 0xFFFFFFFE, v21, (uint64_t)downmix_int, 0);
  }
  return v12;
}

uint64_t opus_encoder_ctl(int *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _DWORD *v10;
  uint64_t result;
  int *v12;
  int v13;
  BOOL v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  _DWORD *v18;
  uint64_t *v19;
  _DWORD *v20;
  int *v21;
  int v22;
  uint64_t *v24;
  _DWORD *v25;
  int v26;
  int *v27;
  int v28;
  uint64_t *v29;
  _DWORD *v30;
  unsigned int *v31;
  unsigned int v32;
  uint64_t *v33;
  _DWORD *v34;
  int *v35;
  uint64_t *v36;
  _DWORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t *v40;
  _DWORD *v41;
  unsigned int *v42;
  unsigned int v43;
  uint64_t *v44;
  _DWORD *v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t *v48;
  _DWORD *v49;
  unsigned int *v50;
  unsigned int v51;
  uint64_t *v52;
  _DWORD *v53;
  unsigned int *v54;
  unsigned int v55;
  uint64_t *v56;
  _DWORD *v57;
  int *v58;
  int v59;
  uint64_t *v60;
  _DWORD *v61;
  int *v62;
  int v63;
  uint64_t *v64;
  _DWORD *v65;
  int **v66;
  int *v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  _DWORD *v77;
  uint64_t *v78;
  _DWORD *v79;
  int *v80;
  int v81;
  uint64_t *v82;
  _DWORD *v83;
  int *v84;
  int v85;
  uint64_t *v86;
  _DWORD *v87;
  unsigned int *v88;
  unsigned int v89;
  uint64_t *v90;
  _DWORD *v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  int **v96;
  int *v97;
  _DWORD *v98;
  int v99;
  uint64_t *v100;
  uint64_t v101;
  uint64_t *v102;
  uint64_t v103;
  int *v104;
  int v105;
  int *v106;
  int v107;
  BOOL v108;
  int v109;
  uint64_t v110;
  char v111[100];
  uint64_t *v112;

  v112 = &a9;
  v10 = (int *)((char *)a1 + *a1);
  result = 4294967291;
  if (a2 <= 10014)
  {
    switch(a2)
    {
      case 4000:
        v12 = (int *)v112++;
        v13 = *v12;
        v14 = (v13 - 2048) > 3 || v13 == 2050;
        if (v14 || !a1[3564] && a1[27] != v13)
          return 0xFFFFFFFFLL;
        result = 0;
        a1[27] = v13;
        a1[49] = v13;
        return result;
      case 4001:
        v19 = v112++;
        v20 = (_DWORD *)*v19;
        if (!v20)
          return 0xFFFFFFFFLL;
        result = 0;
        *v20 = a1[27];
        return result;
      case 4002:
        v21 = (int *)v112++;
        v22 = *v21;
        if (v22 != -1000 && v22 != -1)
        {
          if (v22 < 1)
            return 0xFFFFFFFFLL;
          if (v22 >= 0x1F5)
          {
            if (v22 >= 300000 * a1[28])
              v22 = 300000 * a1[28];
          }
          else
          {
            v22 = 500;
          }
        }
        result = 0;
        a1[41] = v22;
        return result;
      case 4003:
        v24 = v112++;
        v25 = (_DWORD *)*v24;
        if (!*v24)
          return 0xFFFFFFFFLL;
        v26 = user_bitrate_to_bitrate(a1, a1[3560]);
        result = 0;
        *v25 = v26;
        return result;
      case 4004:
        v27 = (int *)v112++;
        v28 = *v27;
        if ((v28 - 1106) < 0xFFFFFFFB)
          return 0xFFFFFFFFLL;
        a1[33] = v28;
        goto LABEL_40;
      case 4005:
        v29 = v112++;
        v30 = (_DWORD *)*v29;
        if (!v30)
          return 0xFFFFFFFFLL;
        result = 0;
        *v30 = a1[33];
        return result;
      case 4006:
        v31 = (unsigned int *)v112++;
        v32 = *v31;
        if (v32 > 1)
          return 0xFFFFFFFFLL;
        result = 0;
        a1[37] = v32;
        a1[15] = 1 - v32;
        return result;
      case 4007:
        v33 = v112++;
        v34 = (_DWORD *)*v33;
        if (!v34)
          return 0xFFFFFFFFLL;
        result = 0;
        *v34 = a1[37];
        return result;
      case 4008:
        v35 = (int *)v112++;
        v28 = *v35;
        if ((v28 - 1101) >= 5 && v28 != -1000)
          return 0xFFFFFFFFLL;
        a1[32] = v28;
LABEL_40:
        if (v28 == 1102)
        {
          result = 0;
          a1[5] = 12000;
        }
        else
        {
          result = 0;
          if (v28 == 1101)
            a1[5] = 8000;
          else
            a1[5] = 16000;
        }
        return result;
      case 4009:
        v36 = v112++;
        v37 = (_DWORD *)*v36;
        if (!v37)
          return 0xFFFFFFFFLL;
        result = 0;
        *v37 = a1[3561];
        return result;
      case 4010:
        v38 = v112++;
        v39 = *(unsigned int *)v38;
        if (v39 > 0xA)
          return 0xFFFFFFFFLL;
        a1[11] = v39;
        opus_custom_encoder_ctl(v10, 4010, a3, a4, a5, a6, a7, a8, v39);
        return 0;
      case 4011:
        v40 = v112++;
        v41 = (_DWORD *)*v40;
        if (!v41)
          return 0xFFFFFFFFLL;
        result = 0;
        *v41 = a1[11];
        return result;
      case 4012:
        v42 = (unsigned int *)v112++;
        v43 = *v42;
        if (v43 > 2)
          return 0xFFFFFFFFLL;
        result = 0;
        a1[47] = v43;
        a1[12] = v43 != 0;
        return result;
      case 4013:
        v44 = v112++;
        v45 = (_DWORD *)*v44;
        if (!v45)
          return 0xFFFFFFFFLL;
        result = 0;
        *v45 = a1[47];
        return result;
      case 4014:
        v46 = v112++;
        v47 = *(unsigned int *)v46;
        if (v47 > 0x64)
          return 0xFFFFFFFFLL;
        a1[10] = v47;
        opus_custom_encoder_ctl(v10, 4014, a3, a4, a5, a6, a7, a8, v47);
        return 0;
      case 4015:
        v48 = v112++;
        v49 = (_DWORD *)*v48;
        if (!v49)
          return 0xFFFFFFFFLL;
        result = 0;
        *v49 = a1[10];
        return result;
      case 4016:
        v50 = (unsigned int *)v112++;
        v51 = *v50;
        if (v51 > 1)
          return 0xFFFFFFFFLL;
        result = 0;
        a1[46] = v51;
        return result;
      case 4017:
        v52 = v112++;
        v53 = (_DWORD *)*v52;
        if (!v53)
          return 0xFFFFFFFFLL;
        result = 0;
        *v53 = a1[46];
        return result;
      case 4020:
        v54 = (unsigned int *)v112++;
        v55 = *v54;
        if (v55 > 1)
          return 0xFFFFFFFFLL;
        result = 0;
        a1[38] = v55;
        return result;
      case 4021:
        v56 = v112++;
        v57 = (_DWORD *)*v56;
        if (!v57)
          return 0xFFFFFFFFLL;
        result = 0;
        *v57 = a1[38];
        return result;
      case 4022:
        v58 = (int *)v112++;
        v59 = *v58;
        if (v59 < 1)
        {
          if (v59 != -1000)
            return 0xFFFFFFFFLL;
        }
        else if (v59 > a1[28])
        {
          return 0xFFFFFFFFLL;
        }
        result = 0;
        a1[30] = v59;
        return result;
      case 4023:
        v60 = v112++;
        v61 = (_DWORD *)*v60;
        if (!v61)
          return 0xFFFFFFFFLL;
        result = 0;
        *v61 = a1[30];
        return result;
      case 4024:
        v62 = (int *)v112++;
        v63 = *v62;
        if ((v63 - 3001) >= 2 && v63 != -1000)
          return 0xFFFFFFFFLL;
        result = 0;
        a1[31] = v63;
        return result;
      case 4025:
        v64 = v112++;
        v65 = (_DWORD *)*v64;
        if (!v65)
          return 0xFFFFFFFFLL;
        result = 0;
        *v65 = a1[31];
        return result;
      case 4027:
        v66 = (int **)v112++;
        v67 = *v66;
        if (!v67)
          return 0xFFFFFFFFLL;
        v68 = a1[36] / 400;
        *v67 = v68;
        if (a1[27] == 2051)
          return 0;
        result = 0;
        *v67 = a1[29] + v68;
        return result;
      case 4028:
        v69 = (uint64_t)a1 + a1[1];
        bzero(a1 + 51, 0x36A8uLL);
        bzero(a1 + 3549, 0xF74uLL);
        opus_custom_encoder_ctl(v10, 4028, v70, v71, v72, v73, v74, v75, v110);
        silk_InitEncoder(v69, a1[45], (uint64_t)v111);
        result = 0;
        a1[3549] = a1[28];
        *((_WORD *)a1 + 7100) = 0x4000;
        a1[3564] = 1;
        a1[3557] = 1001;
        a1[3561] = 1105;
        *(_QWORD *)(a1 + 3551) = 0x3F8000000002F400;
        return result;
      case 4029:
        v76 = v112++;
        v77 = (_DWORD *)*v76;
        if (!v77)
          return 0xFFFFFFFFLL;
        result = 0;
        *v77 = a1[36];
        return result;
      case 4031:
        v78 = v112++;
        v79 = (_DWORD *)*v78;
        if (!v79)
          return 0xFFFFFFFFLL;
        result = 0;
        *v79 = a1[4537];
        return result;
      case 4036:
        v80 = (int *)v112++;
        v81 = *v80;
        if ((v81 - 25) < 0xFFFFFFEF)
          return 0xFFFFFFFFLL;
        result = 0;
        a1[42] = v81;
        return result;
      case 4037:
        v82 = v112++;
        v83 = (_DWORD *)*v82;
        if (!v83)
          return 0xFFFFFFFFLL;
        result = 0;
        *v83 = a1[42];
        return result;
      case 4040:
        v84 = (int *)v112++;
        v85 = *v84;
        if ((v85 - 5010) < 0xFFFFFFF6)
          return 0xFFFFFFFFLL;
        result = 0;
        a1[39] = v85;
        return result;
      case 4041:
        v86 = v112++;
        v87 = (_DWORD *)*v86;
        if (!v87)
          return 0xFFFFFFFFLL;
        result = 0;
        *v87 = a1[39];
        return result;
      case 4042:
        v88 = (unsigned int *)v112++;
        v89 = *v88;
        if (v89 > 1)
          return 0xFFFFFFFFLL;
        result = 0;
        a1[19] = v89;
        return result;
      case 4043:
        v90 = v112++;
        v91 = (_DWORD *)*v90;
        if (!v91)
          return 0xFFFFFFFFLL;
        result = 0;
        *v91 = a1[19];
        return result;
      case 4046:
        v92 = v112++;
        v93 = *(unsigned int *)v92;
        if (v93 > 1)
          return 0xFFFFFFFFLL;
        opus_custom_encoder_ctl(v10, 4046, a3, a4, a5, a6, a7, a8, v93);
        return 0;
      case 4047:
        v94 = v112++;
        v95 = *v94;
        if (!v95)
          return 0xFFFFFFFFLL;
        opus_custom_encoder_ctl(v10, 4047, a3, a4, a5, a6, a7, a8, v95);
        return 0;
      case 4049:
        v96 = (int **)v112++;
        v97 = *v96;
        if (!v97)
          return 0xFFFFFFFFLL;
        if (a1[14] && (a1[3558] & 0xFFFFFFFE) == 0x3E8)
        {
          v98 = (int *)((char *)a1 + a1[1]);
          v99 = v98[1526];
          *v97 = v99 > 9;
          if (v99 < 10 || a1[3] != 2 || v98[5065])
            return 0;
          result = 0;
          v108 = v98[4048] <= 9;
        }
        else
        {
          if (!a1[46])
          {
            result = 0;
            *v97 = 0;
            return result;
          }
          result = 0;
          v108 = a1[4534] <= 399;
        }
        v109 = !v108;
        *v97 = v109;
        break;
      default:
        return result;
    }
    return result;
  }
  if (a2 > 11001)
  {
    switch(a2)
    {
      case 11002:
        v104 = (int *)v112++;
        v105 = *v104;
        if ((v105 - 1000) < 3 || v105 == -1000)
        {
          result = 0;
          a1[34] = v105;
          return result;
        }
        break;
      case 11018:
        v106 = (int *)v112++;
        v107 = *v106;
        if ((v107 - 101) >= 0xFFFFFF9A)
        {
          result = 0;
          a1[35] = v107;
          return result;
        }
        break;
      case 11019:
        v17 = v112++;
        v18 = (_DWORD *)*v17;
        if (v18)
        {
          result = 0;
          *v18 = a1[35];
          return result;
        }
        break;
      default:
        return result;
    }
    return 0xFFFFFFFFLL;
  }
  switch(a2)
  {
    case 10015:
      v100 = v112++;
      v101 = *v100;
      if (v101)
        return opus_custom_encoder_ctl(v10, 10015, a3, a4, a5, a6, a7, a8, v101);
      return 0xFFFFFFFFLL;
    case 10024:
      v102 = v112++;
      v103 = *(unsigned int *)v102;
      a1[44] = v103;
      return opus_custom_encoder_ctl(v10, 10024, a3, a4, a5, a6, a7, a8, v103);
    case 10026:
      v15 = v112++;
      v16 = *v15;
      *((_QWORD *)a1 + 1783) = v16;
      return opus_custom_encoder_ctl(v10, 10026, a3, a4, a5, a6, a7, a8, v16);
  }
  return result;
}

uint64_t opus_multistream_decoder_init(uint64_t a1, int a2, unsigned int a3, int a4, int a5, _OWORD *a6)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  char *v13;
  char v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  char *v19;
  int v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;

  if (a3 - 256 < 0xFFFFFF01)
    return 0xFFFFFFFFLL;
  result = 0xFFFFFFFFLL;
  if ((a5 & 0x80000000) == 0 && a4 >= 1 && a5 <= a4 && 255 - a5 >= a4)
  {
    *(_DWORD *)a1 = a3;
    *(_DWORD *)(a1 + 4) = a4;
    v9 = a3;
    *(_DWORD *)(a1 + 8) = a5;
    if (a3 < 8 || (unint64_t)(a1 - (_QWORD)a6 + 12) < 0x20)
    {
      v10 = 0;
      goto LABEL_10;
    }
    if (a3 >= 0x20)
    {
      v10 = a3 & 0xFFFFFFE0;
      v21 = a6[1];
      *(_OWORD *)(a1 + 12) = *a6;
      *(_OWORD *)(a1 + 28) = v21;
      if (v10 != 32)
      {
        v22 = a6[3];
        *(_OWORD *)(a1 + 44) = a6[2];
        *(_OWORD *)(a1 + 60) = v22;
        if (v10 != 64)
        {
          v23 = a6[5];
          *(_OWORD *)(a1 + 76) = a6[4];
          *(_OWORD *)(a1 + 92) = v23;
          if (v10 != 96)
          {
            v24 = a6[7];
            *(_OWORD *)(a1 + 108) = a6[6];
            *(_OWORD *)(a1 + 124) = v24;
            if (v10 != 128)
            {
              v25 = a6[9];
              *(_OWORD *)(a1 + 140) = a6[8];
              *(_OWORD *)(a1 + 156) = v25;
              if (v10 != 160)
              {
                v26 = a6[11];
                *(_OWORD *)(a1 + 172) = a6[10];
                *(_OWORD *)(a1 + 188) = v26;
                if (v10 != 192)
                {
                  v27 = a6[13];
                  *(_OWORD *)(a1 + 204) = a6[12];
                  *(_OWORD *)(a1 + 220) = v27;
                }
              }
            }
          }
        }
      }
      if (v10 == a3)
        goto LABEL_12;
      if ((a3 & 0x18) == 0)
      {
LABEL_10:
        v11 = a3 - v10;
        v12 = (_BYTE *)(v10 + a1 + 12);
        v13 = (char *)a6 + v10;
        do
        {
          v14 = *v13++;
          *v12++ = v14;
          --v11;
        }
        while (v11);
        goto LABEL_12;
      }
    }
    else
    {
      v10 = 0;
    }
    v28 = v10;
    v10 = a3 & 0xFFFFFFF8;
    v29 = (uint64_t *)((char *)a6 + v28);
    v30 = (_QWORD *)(v28 + a1 + 12);
    v31 = v28 - v10;
    do
    {
      v32 = *v29++;
      *v30++ = v32;
      v31 += 8;
    }
    while (v31);
    if (v10 != a3)
      goto LABEL_10;
LABEL_12:
    if (a5 + a4 <= 255)
    {
      if ((int)a3 < 1)
      {
LABEL_22:
        v19 = (char *)(a1 + 272);
        if (a5 < 1)
        {
          v20 = 0;
          do
          {
LABEL_32:
            result = opus_decoder_init(v19, a2, 1);
            if ((_DWORD)result)
              break;
            v19 += 18232;
            ++v20;
          }
          while (v20 < *(_DWORD *)(a1 + 4));
        }
        else
        {
          v20 = 0;
          while (1)
          {
            result = opus_decoder_init(v19, a2, 2);
            if ((_DWORD)result)
              break;
            v19 += 27000;
            if (++v20 >= *(_DWORD *)(a1 + 8))
            {
              if (v20 < *(_DWORD *)(a1 + 4))
                goto LABEL_32;
              return 0;
            }
          }
        }
      }
      else
      {
        v15 = (unsigned __int8 *)(a1 + 12);
        while (1)
        {
          v17 = *v15++;
          v16 = v17;
          if (v17 != 255 && a5 + a4 <= v16)
            return 0xFFFFFFFFLL;
          if (!--v9)
            goto LABEL_22;
        }
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t opus_multistream_decode_native(int *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9;
  unsigned int v10;
  uint64_t v11;
  void (*v12)(_QWORD);
  uint64_t v13;
  int v14;
  int8x16_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t nb_samples;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  int v28;
  unsigned __int8 *v29;
  int v30;
  BOOL v31;
  int v32;
  int v33;
  int8x16_t *v34;
  __int32 *v35;
  signed int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  __int32 *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  __int32 *v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  __int32 *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  void (*v61)(uint64_t);
  uint64_t v62;
  signed int v63;
  unsigned __int8 *v64;
  uint64_t v65;
  unsigned int v66;
  int v67;
  int v68;
  int v69;
  BOOL v70;
  uint64_t v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  _QWORD v77[3];
  int8x16_t *v78;
  unsigned int v79;
  __int32 *v80;
  uint64_t v81;
  void (*v82)(_QWORD);
  int v83;
  int v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  float32x4_t *v88;
  unsigned __int8 *v89;
  int v90;
  unsigned int v91;
  char v92;
  int16x8_t v93[6];
  uint64_t v94;

  v94 = *MEMORY[0x24BDAC8D0];
  if ((int)a6 < 1)
    return 0xFFFFFFFFLL;
  v9 = a8;
  v10 = a7;
  LODWORD(v11) = a6;
  v12 = (void (*)(_QWORD))a5;
  v13 = a4;
  v14 = a3;
  v16 = (int8x16_t *)a1;
  v90 = 0;
  v17 = opus_multistream_decoder_ctl(a1, 4029, a3, a4, a5, a6, a7, a8, (uint64_t)&v90);
  if ((_DWORD)v17)
    return 4294967293;
  v21 = 3 * (v90 / 25);
  if (v21 >= (int)v11)
    v11 = v11;
  else
    v11 = v21;
  MEMORY[0x24BDAC7A8](v17, v18);
  v88 = (float32x4_t *)((char *)v77 - v22);
  if (v14 < 0)
    return 0xFFFFFFFFLL;
  v84 = v14;
  v79 = v10;
  if (v14)
  {
    v23 = v16->i32[1];
    if (2 * v23 - 1 > v14)
      return 4294967292;
    v83 = v9;
    if (v23 <= 0)
    {
      LODWORD(nb_samples) = 0;
      goto LABEL_20;
    }
    v24 = v90;
    v25 = v14;
    v26 = v23 - 1;
    v92 = 0;
    v91 = 0;
    v27 = opus_packet_parse_impl(a2, v25, v23 != 1, &v92, 0, v93, 0, &v91);
    if ((v27 & 0x80000000) != 0)
      return v27;
    v85 = v11;
    v81 = v13;
    v82 = v12;
    v28 = v24;
    v29 = a2;
    v30 = v28;
    nb_samples = opus_packet_get_nb_samples(a2, v91, v28);
    if (v23 == 1)
    {
LABEL_17:
      v12 = v82;
      v13 = v81;
      v14 = v84;
      v11 = v85;
      a2 = v29;
      if ((nb_samples & 0x80000000) != 0)
        return nb_samples;
LABEL_20:
      v31 = (int)nb_samples <= (int)v11;
      v10 = v79;
      v9 = v83;
      if (!v31)
        return 4294967294;
      goto LABEL_22;
    }
    v63 = v84 - v91;
    v64 = &v29[v91];
    while (1)
    {
      if (v63 < 1)
        return 4294967292;
      v65 = opus_packet_parse_impl(v64, v63, v26 != 1, &v92, 0, v93, 0, &v91);
      if ((v65 & 0x80000000) != 0)
        return v65;
      if ((int)v91 < 1)
      {
        v67 = -1;
      }
      else
      {
        v66 = *v64;
        if ((v66 & 3) == 0)
        {
          v68 = 1;
LABEL_97:
          v69 = (v66 >> 3) & 3;
          v70 = v69 == 3;
          v71 = 1374389535 * (v30 << v69);
          v72 = (v71 >> 37) + ((unint64_t)v71 >> 63);
          if (v70)
            v72 = 60 * v30 / 1000;
          if ((v66 & 8) != 0)
            v73 = 50;
          else
            v73 = 100;
          v74 = v30 / v73;
          if ((~v66 & 0x60) == 0)
            v72 = v74;
          v75 = (v71 >> 39) + ((unint64_t)v71 >> 63);
          if ((v66 & 0x80) != 0)
            v76 = v75;
          else
            v76 = v72;
          v67 = v76 * v68;
          if (25 * v67 > 3 * v30)
            v67 = -4;
          goto LABEL_109;
        }
        if ((v66 & 3) != 3)
        {
          v68 = 2;
          goto LABEL_97;
        }
        if (v91 >= 2)
        {
          v68 = v64[1] & 0x3F;
          goto LABEL_97;
        }
        v67 = -4;
      }
LABEL_109:
      if ((_DWORD)nb_samples != v67)
        return 4294967292;
      v64 += (int)v91;
      v63 -= v91;
      if (!--v26)
        goto LABEL_17;
    }
  }
LABEL_22:
  v81 = v13;
  v82 = v12;
  v77[1] = v77;
  v86 = a9;
  v32 = v16->i32[1];
  if (v32 > 0)
  {
    v83 = v9;
    v89 = a2;
    v33 = 0;
    v34 = v16 + 17;
    v77[2] = (char *)v88->i64 + 4;
    v35 = &v16->i32[3];
    v36 = v14;
    v80 = &v16->i32[3];
    v78 = v16;
    while (1)
    {
      if (v33 >= v16->i32[2])
        v37 = 18232;
      else
        v37 = 27000;
      if (v14 && v36 < 1)
        return 4294967293;
      v93[0].i32[0] = 0;
      v38 = opus_decode_native(v34, v89, v36, v88, v11, v10, v33 != v32 - 1, v93, v83);
      v11 = v38;
      if (v14)
        v39 = v93[0].u32[0];
      else
        v39 = 0;
      if ((int)v38 < 1)
        return v11;
      v40 = v16->i32[2];
      v87 = v37;
      if (v33 >= v40)
      {
        v42 = v16->i32[0];
        if (v16->i32[0] >= 1)
        {
          v47 = 0;
          do
          {
            v48 = 0;
            v49 = v35;
            while (v16->i32[2] + v33 != *((unsigned __int8 *)v49 + v47))
            {
              v49 = (__int32 *)((char *)v49 + 1);
              ++v48;
              if (!((_DWORD)v47 - v42 + v48))
                goto LABEL_25;
            }
            if ((_DWORD)v47 + v48 == -1)
              goto LABEL_74;
            v50 = v39;
            v82(v81);
            v39 = v50;
            if ((int)v47 + v48 >= 0)
              v47 = (v47 + v48 + 1);
            else
              v47 = 0;
            v42 = v16->i32[0];
            v35 = v80;
          }
          while ((int)v47 < v16->i32[0]);
        }
      }
      else
      {
        v85 = v38;
        v41 = 2 * v33;
        v42 = v16->i32[0];
        if (v16->i32[0] >= 1)
        {
          v43 = 0;
          while (1)
          {
            v44 = 0;
            v45 = v35;
            while (v41 != *((unsigned __int8 *)v45 + v43))
            {
              v45 = (__int32 *)((char *)v45 + 1);
              ++v44;
              if (!((_DWORD)v43 - v42 + v44))
                goto LABEL_61;
            }
            if ((_DWORD)v43 + v44 == -1)
              break;
            v46 = v39;
            v82(v81);
            v39 = v46;
            if ((int)v43 + v44 >= 0)
              v43 = (v43 + v44 + 1);
            else
              v43 = 0;
            v42 = v16->i32[0];
            v35 = v80;
            if ((int)v43 >= v16->i32[0])
              goto LABEL_61;
          }
          v35 = v80;
        }
LABEL_61:
        if (v42 >= 1)
        {
          v51 = 0;
          v52 = v41 | 1;
          while (1)
          {
            v53 = 0;
            v54 = v35;
            while (v52 != *((unsigned __int8 *)v54 + v51))
            {
              v54 = (__int32 *)((char *)v54 + 1);
              ++v53;
              if (!((_DWORD)v51 - v42 + v53))
                goto LABEL_24;
            }
            v55 = v51 + v53;
            if ((_DWORD)v51 + v53 == -1)
              break;
            v56 = v85;
            v57 = v39;
            v82(v81);
            v39 = v57;
            v58 = v51 + v53;
            v11 = v56;
            v10 = v79;
            v16 = v78;
            v59 = (v58 + 1);
            if (v55 >= 0)
              v51 = v59;
            else
              v51 = 0;
            v42 = v78->i32[0];
            v35 = v80;
            if ((int)v51 >= v78->i32[0])
              goto LABEL_25;
          }
          v11 = v85;
LABEL_74:
          v35 = v80;
          goto LABEL_25;
        }
LABEL_24:
        v11 = v85;
      }
LABEL_25:
      v34 = (int8x16_t *)((char *)v34 + v87);
      v36 -= v39;
      v89 += (int)v39;
      ++v33;
      v32 = v16->i32[1];
      v14 = v84;
      if (v33 >= v32)
        goto LABEL_76;
    }
  }
  v42 = v16->i32[0];
LABEL_76:
  if (v42 < 1)
    return v11;
  v60 = 0;
  v61 = v82;
  v62 = v81;
  do
  {
    if (v16->u8[v60 + 12] == 255)
    {
      v61(v62);
      v42 = v16->i32[0];
    }
    ++v60;
  }
  while (v60 < v42);
  return v11;
}

uint64_t opus_multistream_decoder_ctl(int *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return opus_multistream_decoder_ctl_va_list(a1, a2, (uint64_t)&a9, a4, a5, a6, a7, a8);
}

uint64_t opus_copy_channel_out_short(uint64_t result, int a2, int a3, float *a4, int a5, int a6)
{
  uint64_t v6;
  _WORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _WORD *v12;

  if (!a4)
  {
    if (a6 < 1)
      return result;
    if (a6 == 1)
    {
      v8 = 0;
    }
    else
    {
      v8 = a6 & 0xFFFFFFFE;
      v9 = v8;
      v10 = result;
      do
      {
        *(_WORD *)(v10 + 2 * a3) = 0;
        *(_WORD *)(v10 + 2 * (a3 + (uint64_t)a2)) = 0;
        v10 += 4 * a2;
        v9 -= 2;
      }
      while (v9);
      if (v8 == a6)
        return result;
    }
    v11 = a6 - v8;
    v12 = (_WORD *)(result + 2 * (a3 + v8 * a2));
    do
    {
      *v12 = 0;
      v12 += a2;
      --v11;
    }
    while (v11);
    return result;
  }
  if (a6 >= 1)
  {
    v6 = a6;
    v7 = (_WORD *)(result + 2 * a3);
    do
    {
      *v7 = (uint64_t)rintf(fminf(fmaxf(*a4 * 32768.0, -32768.0), 32767.0));
      v7 += a2;
      a4 += a5;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t opus_multistream_decoder_ctl_va_list(int *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v10;
  uint64_t result;
  int **v12;
  int **v13;
  int v14;
  int *v15;
  int v16;
  uint64_t v17;
  int **v18;
  int v19;
  int ***v20;
  int **v21;
  int i;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  int **v27;
  int *v28;
  int v29;
  int v30;
  uint64_t v31;
  int *v32;
  int v33;
  int **v34;

  v34 = (int **)a3;
  v10 = a1 + 68;
  result = 4294967291;
  switch(a2)
  {
    case 4009:
    case 4029:
    case 4039:
    case 4045:
    case 4047:
      v12 = v34++;
      result = opus_decoder_ctl(v10, a2, a3, a4, a5, a6, a7, a8, *v12);
      break;
    case 4010:
    case 4011:
    case 4012:
    case 4013:
    case 4014:
    case 4015:
    case 4016:
    case 4017:
    case 4018:
    case 4019:
    case 4020:
    case 4021:
    case 4022:
    case 4023:
    case 4024:
    case 4025:
    case 4026:
    case 4027:
    case 4030:
    case 4032:
    case 4033:
    case 4035:
    case 4036:
    case 4037:
    case 4038:
    case 4040:
    case 4041:
    case 4042:
    case 4043:
    case 4044:
      return result;
    case 4028:
      if (a1[1] < 1)
        goto LABEL_38;
      v24 = 0;
      do
      {
        v25 = a1[2];
        result = opus_decoder_ctl(v10, 4028, a3, a4, a5, a6, a7, a8, v32);
        if ((_DWORD)result)
          break;
        v26 = v24 >= v25 ? 18232 : 27000;
        v10 = (int *)((char *)v10 + v26);
        ++v24;
      }
      while (v24 < a1[1]);
      break;
    case 4031:
      v27 = v34++;
      v28 = *v27;
      v33 = 0;
      if (!v28)
        goto LABEL_39;
      *v28 = 0;
      if (a1[1] < 1)
        goto LABEL_38;
      v29 = 0;
      while (1)
      {
        v30 = a1[2];
        result = opus_decoder_ctl(v10, 4031, a3, a4, a5, a6, a7, a8, &v33);
        if ((_DWORD)result)
          break;
        if (v29 >= v30)
          v31 = 18232;
        else
          v31 = 27000;
        v10 = (int *)((char *)v10 + v31);
        *v28 ^= v33;
        if (++v29 >= a1[1])
          goto LABEL_38;
      }
      break;
    case 4034:
    case 4046:
      v13 = v34++;
      if (a1[1] < 1)
      {
LABEL_38:
        result = 0;
      }
      else
      {
        v14 = 0;
        v15 = (int *)*(unsigned int *)v13;
        while (1)
        {
          v16 = a1[2];
          result = opus_decoder_ctl(v10, a2, a3, a4, a5, a6, a7, a8, v15);
          if ((_DWORD)result)
            break;
          if (v14 >= v16)
            v17 = 18232;
          else
            v17 = 27000;
          v10 = (int *)((char *)v10 + v17);
          if (++v14 >= a1[1])
            goto LABEL_38;
        }
      }
      break;
    default:
      if (a2 == 5122)
      {
        v18 = v34++;
        v19 = *(_DWORD *)v18;
        if (v19 < 0 || v19 >= a1[1] || (v20 = (int ***)v34, ++v34, (v21 = *v20) == 0))
        {
LABEL_39:
          result = 0xFFFFFFFFLL;
        }
        else
        {
          if (v19)
          {
            for (i = 0; i != v19; ++i)
            {
              if (i >= a1[2])
                v23 = 18232;
              else
                v23 = 27000;
              v10 = (int *)((char *)v10 + v23);
            }
          }
          result = 0;
          *v21 = v10;
        }
      }
      break;
  }
  return result;
}

void surround_analysis(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, void (*a17)(float *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD), float a18)
{
  float v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float *v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  __int128 v34;
  char v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  float v39;
  float v40;
  char v41;
  uint64_t v42;
  float32x4_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  float32x4_t *v47;
  float32x4_t *v48;
  float32x4_t v49;
  uint64_t v50;
  float *v51;
  float *v52;
  uint64_t v53;
  float v54;
  uint64_t v55;
  float *v56;
  float *v57;
  float v58;
  float *v59;
  uint64_t v60;
  float v61;
  float v62;
  float *v63;
  uint64_t v64;
  float v65;
  uint64_t v66;
  float32x2_t v67;
  float32x4_t v68;
  float32x2_t v69;
  float32x2_t v70;
  float32x2_t v71;
  float32x2_t v72;
  float32x2_t v73;
  float32x2_t v74;
  float32x2_t v75;
  float v76;
  float v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  float32x4_t *v81;
  float32x4_t v82;
  uint64_t v83;
  float *v84;
  uint64_t v85;
  _WORD *v86;
  int v87;
  int8x16_t v88;
  float v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  float *v93;
  float v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  float64x2_t v98;
  float64x2_t v99;
  float64x2_t v100;
  float64x2_t v101;
  float64x2_t v102;
  float64x2_t v103;
  float64x2_t v104;
  float64x2_t v105;
  float64x2_t v106;
  float64x2_t v107;
  float64x2_t v108;
  float64x2_t v109;
  float64x2_t v110;
  float64x2_t v111;
  float64x2_t v112;
  float64x2_t v113;
  float64x2_t v114;
  float64x2_t v115;
  float64x2_t v116;
  float64x2_t v117;
  long double v118;
  float v119;
  float v120;
  uint64_t v121;
  float v122;
  uint64_t v123;
  float v124;
  uint64_t v125;
  float v126;
  uint64_t v127;
  float v128;
  uint64_t v129;
  float v130;
  uint64_t v131;
  float v132;
  uint64_t v133;
  float v134;
  uint64_t v135;
  float v136;
  uint64_t v137;
  float v138;
  uint64_t v139;
  float v140;
  uint64_t v141;
  float v142;
  uint64_t v143;
  float v144;
  uint64_t v145;
  float v146;
  uint64_t v147;
  float v148;
  uint64_t v149;
  float v150;
  uint64_t v151;
  float v152;
  uint64_t v153;
  uint64_t v154;
  float v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  float v159;
  uint64_t v160;
  float v161;
  float v162;
  float v163;
  float v164;
  float v165;
  float v166;
  float v167;
  float v168;
  float v169;
  float v170;
  float v171;
  float v172;
  float v173;
  float v174;
  float v175;
  float v176;
  float v177;
  float v178;
  float v179;
  float v180;
  int v181;
  float *v182;
  void *v183;
  uint64_t i;
  float v185;
  float v186;
  float v187;
  float v188;
  signed int v189;
  float v190;
  float v191;
  float v192;
  signed int v193;
  uint64_t v194;
  float v195;
  float v196;
  float v197;
  float v198;
  signed int v199;
  uint64_t v200;
  float v201;
  float v202;
  float v203;
  float v204;
  signed int v205;
  float v206;
  float v207;
  float v208;
  float v209;
  float v210;
  float v211;
  float v212;
  float v213;
  float v214;
  int v215;
  float v216;
  float v217;
  float v218;
  float v219;
  float v220;
  float v221;
  float v222;
  float v223;
  float v224;
  float v225;
  float v226;
  float v227;
  float v228;
  float v229;
  float v230;
  float v231;
  float v232;
  float v233;
  float v234;
  float v235;
  float v236;
  float v237;
  uint64_t v238;
  uint64_t v239;
  __int128 *v240;
  float32x4_t *v241;
  float32x4_t *v242;
  float32x4_t v243;
  float32x4_t v244;
  int v245;
  int v246;
  uint64_t v247;
  _BYTE v248[4];
  float v249;
  float v250;
  float v251;
  float v252;
  float v253;
  float v254;
  int v255;
  _BYTE *v256;
  float32x4_t *v257;
  float32x4_t *v258;
  size_t v259;
  uint64_t v260;
  float v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  size_t v265;
  uint64_t v266;
  float *v267;
  uint64_t v268;
  double v269;
  float32x2_t v270;
  float32x2_t v271;
  float32x2_t v272;
  float32x2_t v273;
  float32x2_t v274;
  float32x2_t v275;
  float32x2_t v276;
  float32x2_t v277;
  float32x4_t v278;
  char *v279;
  void (*v280)(float *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t v281;
  unsigned int v282;
  int v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  float v287;
  float *v288;
  float *v289;
  uint64_t v290;
  float64x2_t v291;
  float64x2_t v292;
  const void *v293;
  float v294;
  float32x4_t *v295;
  uint64_t v296;
  uint64_t v297;
  __int128 v298;
  uint64_t v299;
  float v300;
  uint64_t v301;
  char *v302;
  uint64_t v303;
  int8x16_t v304;
  uint64_t v305;
  float32x4_t v306;
  float32x2_t v307;
  float32x2_t v308;
  float32x2_t v309;
  float32x2_t v310;
  float32x2_t v311;
  float32x2_t v312;
  float32x2_t v313;
  float32x2_t v314;
  float v315;
  float v316;
  float v317;
  float v318;
  float v319;
  float v320;
  float v321;
  float v322;
  float v323;
  float v324;
  float v325;
  float v326;
  float v327;
  float v328;
  float v329;
  float v330;
  float v331;
  float v332;
  float v333;
  float v334;
  float v335;
  float v336;
  float v337[21];
  float v338;
  float v339;
  float v340;
  float v341;
  float v342;
  float v343;
  float v344;
  float v345;
  float v346;
  float v347;
  float v348;
  float v349;
  float v350;
  float v351;
  float v352;
  float v353;
  float v354;
  float v355;
  float v356;
  float v357;
  float v358;
  __int128 v359;
  __int128 v360;
  uint64_t v361;

  v290 = a6;
  v284 = a2;
  v285 = a4;
  v361 = *MEMORY[0x24BDAC8D0];
  v359 = 0u;
  v360 = 0u;
  if (a8 <= 15999)
  {
    if (a8 == 8000)
    {
      v14 = 0.0;
      v15 = 6;
      goto LABEL_13;
    }
    if (a8 == 12000)
    {
      v14 = 0.0;
      v15 = 4;
      goto LABEL_13;
    }
LABEL_12:
    v14 = 0.0;
    v15 = 0;
    goto LABEL_13;
  }
  if (a8 == 16000)
  {
    v14 = 0.0;
    v15 = 3;
    goto LABEL_13;
  }
  if (a8 == 48000)
  {
    *(float *)&v283 = 0.0;
    LODWORD(v14) = 1;
    v15 = 1;
    goto LABEL_14;
  }
  if (a8 != 24000)
    goto LABEL_12;
  v14 = 0.0;
  v15 = 2;
LABEL_13:
  v283 = 1;
LABEL_14:
  v16 = v15 * v290;
  if ((int)v15 * (int)v290 >= 960)
    v17 = 960;
  else
    v17 = v16;
  v303 = v17;
  v18 = *(_DWORD *)(a1 + 40);
  if (v18 < 1)
  {
    v19 = 0;
  }
  else
  {
    v19 = 0;
    while (*(_DWORD *)(a1 + 48) << v19 != v16)
    {
      if (v18 == ++v19)
      {
        v19 = *(_DWORD *)(a1 + 40);
        break;
      }
    }
  }
  v297 = v15;
  v287 = v14;
  v256 = v248;
  v286 = (v15 * v290);
  v266 = v16 + 120;
  v20 = MEMORY[0x24BDAC7A8](a1, a2);
  v302 = &v248[-v21];
  v23 = MEMORY[0x24BDAC7A8](v20, v22);
  v289 = (float *)&v248[-v24];
  MEMORY[0x24BDAC7A8](v23, v25);
  v27 = (float *)&v248[-v26];
  switch((int)a7)
  {
    case 3:
    case 5:
    case 6:
      v28 = 0;
      v29 = 3;
      *(_QWORD *)&v359 = 0x200000001;
      DWORD2(v359) = 3;
      v30 = 1;
      v31 = 5;
      v32 = 4;
      v33 = 3;
      goto LABEL_28;
    case 4:
      v29 = 1;
      v30 = 3;
      LODWORD(v359) = 1;
      v32 = 2;
      v33 = 1;
      v31 = 3;
      v28 = 3;
      goto LABEL_28;
    case 7:
      v28 = 0;
      v33 = 2;
      v359 = xmmword_208F38480;
      v30 = 3;
      v31 = 6;
      v32 = 5;
      v29 = 4;
      goto LABEL_28;
    case 8:
      v28 = 0;
      v33 = 3;
      v359 = xmmword_208F38480;
      LODWORD(v360) = 3;
      v30 = 1;
      v31 = 7;
      v32 = 6;
      v29 = 5;
LABEL_28:
      *((_DWORD *)&v359 + v29) = v30;
      *((_DWORD *)&v359 + v32) = v33;
      *((_DWORD *)&v359 + v31) = v28;
      break;
    default:
      break;
  }
  memset_pattern16(&v316, &unk_208F31A80, 0x54uLL);
  memset_pattern16(v337, &unk_208F31A80, 0x54uLL);
  v267 = &v338;
  memset_pattern16(&v338, &unk_208F31A80, 0x54uLL);
  v255 = a7 - 1;
  v35 = LOBYTE(v287);
  if ((int)a7 >= 1)
  {
    v294 = 0.0;
    v36 = 0;
    v300 = a18;
    v288 = (float *)(v302 + 480);
    v265 = 4 * (int)v266;
    v299 = a1 + 80;
    *(float *)&v34 = (float)(int)v297;
    v298 = v34;
    v259 = 4 * (int)v286;
    v279 = &v302[v259];
    v280 = a17;
    if (v290 > 7)
      v37 = v287;
    else
      v37 = 0.0;
    v261 = v37;
    v278 = (float32x4_t)xmmword_208F38490;
    v277 = (float32x2_t)0xC09A0000C0A20000;
    v262 = v290;
    v260 = v290 & 0xFFFFFFF8;
    v276 = (float32x2_t)0xC08C0000C0900000;
    v258 = (float32x4_t *)(v289 + 4);
    v275 = (float32x2_t)0xC0960000C09C0000;
    v257 = (float32x4_t *)(v302 + 496);
    v274 = (float32x2_t)0xC08E0000C0920000;
    v264 = 32 * v297;
    v273 = (float32x2_t)0xC0940000C09C0000;
    v263 = 4 * v297;
    v272 = (float32x2_t)0xC0900000C08A0000;
    v295 = (float32x4_t *)(v27 + 4);
    v271 = (float32x2_t)0xC0940000C08C0000;
    v270 = (float32x2_t)0xC08E0000C0980000;
    v269 = 1.44269504;
    v268 = a7;
    v301 = ((int)v286 / (int)v303);
    v282 = a7;
    v281 = a5;
    while (1)
    {
      v296 = v36;
      v293 = (const void *)(v285 + 480 * v36);
      memcpy(v302, v293, 0x1E0uLL);
      v280(v289, 1, v284, a7, v296, v290, 0);
      v38 = v296;
      v39 = *(float *)(a5 + 4 * v296);
      v40 = *(float *)(a1 + 16);
      v41 = v283;
      if (*(float *)(a1 + 20) != 0.0)
        v41 = 1;
      if ((v41 & 1) != 0)
        break;
      LODWORD(v42) = v286;
      if ((int)v286 >= 1)
      {
        v52 = v288;
        v51 = v289;
        v53 = v286;
        do
        {
          v54 = *v51++;
          *v52++ = (float)(v54 * 32768.0) - v39;
          v39 = v40 * (float)(v54 * 32768.0);
          --v53;
        }
        while (v53);
      }
LABEL_56:
      *(float *)(a5 + 4 * v38) = v39;
      v62 = 0.0;
      if ((int)v42 >= -119)
      {
        v63 = (float *)v302;
        v64 = v266;
        do
        {
          v65 = *v63++;
          v62 = v62 + (float)(v65 * v65);
          --v64;
        }
        while (v64);
      }
      if (v62 >= 1.0e18)
      {
        bzero(v302, v265);
        *(_DWORD *)(a5 + 4 * v296) = 0;
      }
      if ((int)v301 >= 1)
      {
        v66 = 0;
        v67 = 0;
        v68 = 0uLL;
        LODWORD(v305) = 0;
        v69 = 0;
        v70 = 0;
        v71 = 0;
        v72 = 0;
        v73 = 0;
        v74 = 0;
        v75 = 0;
        while (1)
        {
          v304 = (int8x16_t)v68;
          clt_mdct_forward_c(v299, (uint64_t)&v302[3840 * v66], v27, *(_QWORD *)(a1 + 72), 120, *(_DWORD *)(a1 + 40) - v19, 1);
          v77 = *(float *)&v298;
          if ((v35 & 1) == 0)
            break;
LABEL_78:
          v85 = 0;
          v86 = *(_WORD **)(a1 + 32);
          LOWORD(v87) = *v86;
          v88 = v304;
          do
          {
            v90 = (__int16)v87;
            v91 = v85 + 1;
            v87 = (__int16)v86[v85 + 1];
            v92 = ((v87 - v90) << v19);
            if ((int)v92 < 1)
            {
              v89 = 0.0;
            }
            else
            {
              v93 = &v27[v90 << v19];
              v89 = 0.0;
              do
              {
                v94 = *v93++;
                v89 = v89 + (float)(v94 * v94);
                --v92;
              }
              while (v92);
            }
            v306.f32[v85++] = sqrtf(v89 + 1.0e-27);
          }
          while (v91 != 21);
          v68 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v88, v306), v88, (int8x16_t)v306);
          v67 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v67, v307), (int8x8_t)v67, (int8x8_t)v307);
          v69 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v69, v308), (int8x8_t)v69, (int8x8_t)v308);
          v70 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v70, v309), (int8x8_t)v70, (int8x8_t)v309);
          v71 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v71, v310), (int8x8_t)v71, (int8x8_t)v310);
          v72 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v72, v311), (int8x8_t)v72, (int8x8_t)v311);
          v73 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v73, v312), (int8x8_t)v73, (int8x8_t)v312);
          v74 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v74, v313), (int8x8_t)v74, (int8x8_t)v313);
          v75 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v75, v314), (int8x8_t)v75, (int8x8_t)v314);
          v76 = *(float *)&v305;
          if (*(float *)&v305 <= v315)
            v76 = v315;
          *(float *)&v305 = v76;
          if (++v66 == v301)
            goto LABEL_86;
        }
        v78 = ((int)v303 / (int)v297);
        if ((int)v78 < 1)
        {
          LODWORD(v78) = 0;
        }
        else
        {
          if (v78 < 8)
          {
            v79 = 0;
            goto LABEL_74;
          }
          v79 = v78 & 0x7FFFFFF8;
          v80 = v78 & 0xFFFFFFF8;
          v81 = v295;
          do
          {
            v82 = vmulq_n_f32(*v81, v77);
            v81[-1] = vmulq_n_f32(v81[-1], v77);
            *v81 = v82;
            v81 += 2;
            v80 -= 8;
          }
          while (v80);
          if (v79 != v78)
          {
LABEL_74:
            v83 = v78 - v79;
            v84 = &v27[v79];
            do
            {
              *v84 = *v84 * v77;
              ++v84;
              --v83;
            }
            while (v83);
          }
        }
        if ((int)v78 < (int)v303)
          bzero(&v27[v78], 4 * (v303 + ~(_DWORD)v78) + 4);
        goto LABEL_78;
      }
      v67 = 0;
      v68 = 0uLL;
      LODWORD(v305) = 0;
      v69 = 0;
      v70 = 0;
      v71 = 0;
      v72 = 0;
      v73 = 0;
      v74 = 0;
      v75 = 0;
LABEL_86:
      v95 = a3 + 4 * LODWORD(v294);
      v96 = 21 * v296;
      v97 = a3 + 4 * (21 * v296);
      v304 = (int8x16_t)vcvt_hight_f64_f32(v68);
      v291 = vcvtq_f64_f32(*(float32x2_t *)v68.f32);
      v98.f64[0] = log(v291.f64[1]);
      v292 = v98;
      v99.f64[0] = log(v291.f64[0]);
      v99.f64[1] = v292.f64[0];
      v292 = v99;
      v100.f64[0] = log(*(long double *)&v304.i64[1]);
      v291 = v100;
      v101.f64[0] = log(*(long double *)v304.i64);
      v101.f64[1] = v291.f64[0];
      v304 = (int8x16_t)vdupq_n_s64(0x3FF71547652B82FEuLL);
      *(float32x4_t *)v97 = vaddq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(v292, (float64x2_t)v304)), vmulq_f64(v101, (float64x2_t)v304)), v278);
      v291 = vcvtq_f64_f32(v67);
      v102.f64[0] = log(v291.f64[1]);
      v292 = v102;
      v103.f64[0] = log(v291.f64[0]);
      v103.f64[1] = v292.f64[0];
      *(float32x2_t *)(v97 + 16) = vadd_f32(vcvt_f32_f64(vmulq_f64(v103, (float64x2_t)v304)), v277);
      v291 = vcvtq_f64_f32(v69);
      v104.f64[0] = log(v291.f64[1]);
      v292 = v104;
      v105.f64[0] = log(v291.f64[0]);
      v105.f64[1] = v292.f64[0];
      *(float32x2_t *)(v97 + 24) = vadd_f32(vcvt_f32_f64(vmulq_f64(v105, (float64x2_t)v304)), v276);
      v291 = vcvtq_f64_f32(v70);
      v106.f64[0] = log(v291.f64[1]);
      v292 = v106;
      v107.f64[0] = log(v291.f64[0]);
      v107.f64[1] = v292.f64[0];
      *(float32x2_t *)(v97 + 32) = vadd_f32(vcvt_f32_f64(vmulq_f64(v107, (float64x2_t)v304)), v275);
      v291 = vcvtq_f64_f32(v71);
      v108.f64[0] = log(v291.f64[1]);
      v292 = v108;
      v109.f64[0] = log(v291.f64[0]);
      v109.f64[1] = v292.f64[0];
      *(float32x2_t *)(v97 + 40) = vadd_f32(vcvt_f32_f64(vmulq_f64(v109, (float64x2_t)v304)), v274);
      v291 = vcvtq_f64_f32(v72);
      v110.f64[0] = log(v291.f64[1]);
      v292 = v110;
      v111.f64[0] = log(v291.f64[0]);
      v111.f64[1] = v292.f64[0];
      *(float32x2_t *)(v97 + 48) = vadd_f32(vcvt_f32_f64(vmulq_f64(v111, (float64x2_t)v304)), v273);
      v291 = vcvtq_f64_f32(v73);
      v112.f64[0] = log(v291.f64[1]);
      v292 = v112;
      v113.f64[0] = log(v291.f64[0]);
      v113.f64[1] = v292.f64[0];
      *(float32x2_t *)(v97 + 56) = vadd_f32(vcvt_f32_f64(vmulq_f64(v113, (float64x2_t)v304)), v272);
      v291 = vcvtq_f64_f32(v74);
      v114.f64[0] = log(v291.f64[1]);
      v292 = v114;
      v115.f64[0] = log(v291.f64[0]);
      v115.f64[1] = v292.f64[0];
      *(float32x2_t *)(v97 + 64) = vadd_f32(vcvt_f32_f64(vmulq_f64(v115, (float64x2_t)v304)), v271);
      v291 = vcvtq_f64_f32(v75);
      v116.f64[0] = log(v291.f64[1]);
      v292 = v116;
      v117.f64[0] = log(v291.f64[0]);
      v117.f64[1] = v292.f64[0];
      *(float32x2_t *)(v97 + 72) = vadd_f32(vcvt_f32_f64(vmulq_f64(v117, (float64x2_t)v304)), v270);
      v118 = log(*(float *)&v305);
      *(float *)&v118 = v118 * v269;
      *(float *)(v97 + 80) = *(float *)&v118 + -3.75;
      v119 = *(float *)(a3 + 4 * (v96 + 1));
      v305 = 4 * v96;
      if (v119 <= (float)(*(float *)(a3 + 4 * v96) + -1.0))
        v119 = *(float *)(a3 + 4 * v96) + -1.0;
      *(float *)(a3 + 4 * (v96 + 1)) = v119;
      v120 = *(float *)(a3 + 4 * (v96 + 2));
      v121 = 4 * (v96 + 1);
      if (v120 <= (float)(*(float *)(a3 + v121) + -1.0))
        v120 = *(float *)(a3 + v121) + -1.0;
      *(float *)(a3 + 4 * (v96 + 2)) = v120;
      v122 = *(float *)(a3 + 4 * (v96 + 3));
      v123 = 4 * (v96 + 2);
      if (v122 <= (float)(*(float *)(a3 + v123) + -1.0))
        v122 = *(float *)(a3 + v123) + -1.0;
      *(float *)(a3 + 4 * (v96 + 3)) = v122;
      v124 = *(float *)(a3 + 4 * (v96 + 4));
      v125 = 4 * (v96 + 3);
      if (v124 <= (float)(*(float *)(a3 + v125) + -1.0))
        v124 = *(float *)(a3 + v125) + -1.0;
      *(float *)(a3 + 4 * (v96 + 4)) = v124;
      v126 = *(float *)(a3 + 4 * (v96 + 5));
      v127 = 4 * (v96 + 4);
      if (v126 <= (float)(*(float *)(a3 + v127) + -1.0))
        v126 = *(float *)(a3 + v127) + -1.0;
      *(float *)(a3 + 4 * (v96 + 5)) = v126;
      v128 = *(float *)(a3 + 4 * (v96 + 6));
      v129 = 4 * (v96 + 5);
      if (v128 <= (float)(*(float *)(a3 + v129) + -1.0))
        v128 = *(float *)(a3 + v129) + -1.0;
      *(float *)(a3 + 4 * (v96 + 6)) = v128;
      v130 = *(float *)(a3 + 4 * (v96 + 7));
      v131 = 4 * (v96 + 6);
      if (v130 <= (float)(*(float *)(a3 + v131) + -1.0))
        v130 = *(float *)(a3 + v131) + -1.0;
      *(float *)(a3 + 4 * (v96 + 7)) = v130;
      v132 = *(float *)(a3 + 4 * (v96 + 8));
      v133 = 4 * (v96 + 7);
      if (v132 <= (float)(*(float *)(a3 + v133) + -1.0))
        v132 = *(float *)(a3 + v133) + -1.0;
      *(float *)(a3 + 4 * (v96 + 8)) = v132;
      v134 = *(float *)(a3 + 4 * (v96 + 9));
      v135 = 4 * (v96 + 8);
      if (v134 <= (float)(*(float *)(a3 + v135) + -1.0))
        v134 = *(float *)(a3 + v135) + -1.0;
      *(float *)(a3 + 4 * (v96 + 9)) = v134;
      v136 = *(float *)(a3 + 4 * (v96 + 10));
      v137 = 4 * (v96 + 9);
      if (v136 <= (float)(*(float *)(a3 + v137) + -1.0))
        v136 = *(float *)(a3 + v137) + -1.0;
      *(float *)(a3 + 4 * (v96 + 10)) = v136;
      v138 = *(float *)(a3 + 4 * (v96 + 11));
      v139 = 4 * (v96 + 10);
      if (v138 <= (float)(*(float *)(a3 + v139) + -1.0))
        v138 = *(float *)(a3 + v139) + -1.0;
      *(float *)(a3 + 4 * (v96 + 11)) = v138;
      v140 = *(float *)(a3 + 4 * (v96 + 12));
      v141 = 4 * (v96 + 11);
      if (v140 <= (float)(*(float *)(a3 + v141) + -1.0))
        v140 = *(float *)(a3 + v141) + -1.0;
      *(float *)(a3 + 4 * (v96 + 12)) = v140;
      v142 = *(float *)(a3 + 4 * (v96 + 13));
      v143 = 4 * (v96 + 12);
      if (v142 <= (float)(*(float *)(a3 + v143) + -1.0))
        v142 = *(float *)(a3 + v143) + -1.0;
      *(float *)(a3 + 4 * (v96 + 13)) = v142;
      v144 = *(float *)(a3 + 4 * (v96 + 14));
      v145 = 4 * (v96 + 13);
      if (v144 <= (float)(*(float *)(a3 + v145) + -1.0))
        v144 = *(float *)(a3 + v145) + -1.0;
      *(float *)(a3 + 4 * (v96 + 14)) = v144;
      v146 = *(float *)(a3 + 4 * (v96 + 15));
      v147 = 4 * (v96 + 14);
      if (v146 <= (float)(*(float *)(a3 + v147) + -1.0))
        v146 = *(float *)(a3 + v147) + -1.0;
      *(float *)(a3 + 4 * (v96 + 15)) = v146;
      v148 = *(float *)(a3 + 4 * (v96 + 16));
      v149 = 4 * (v96 + 15);
      if (v148 <= (float)(*(float *)(a3 + v149) + -1.0))
        v148 = *(float *)(a3 + v149) + -1.0;
      *(float *)(a3 + 4 * (v96 + 16)) = v148;
      v150 = *(float *)(a3 + 4 * (v96 + 17));
      v151 = 4 * (v96 + 16);
      if (v150 <= (float)(*(float *)(a3 + v151) + -1.0))
        v150 = *(float *)(a3 + v151) + -1.0;
      *(float *)(a3 + 4 * (v96 + 17)) = v150;
      v152 = *(float *)(a3 + 4 * (v96 + 18));
      v153 = 4 * (v96 + 17);
      if (v152 <= (float)(*(float *)(a3 + v153) + -1.0))
        v152 = *(float *)(a3 + v153) + -1.0;
      *(float *)(a3 + 4 * (v96 + 18)) = v152;
      v154 = v96 + 19;
      v155 = *(float *)(a3 + 4 * (v96 + 19));
      v156 = 4 * (v96 + 18);
      if (v155 <= (float)(*(float *)(a3 + v156) + -1.0))
        v155 = *(float *)(a3 + v156) + -1.0;
      *(float *)(a3 + 4 * (v96 + 19)) = v155;
      v157 = v96 + 20;
      v158 = 4 * (v96 + 20);
      v159 = *(float *)(a3 + v158);
      v160 = 4 * v154;
      if (v159 <= (float)(*(float *)(a3 + v160) + -1.0))
        v159 = *(float *)(a3 + v160) + -1.0;
      *(float *)(a3 + v158) = v159;
      v161 = *(float *)(a3 + v160);
      if (v161 <= (float)(*(float *)(a3 + 4 * v157) + -2.0))
        v161 = *(float *)(a3 + 4 * v157) + -2.0;
      *(float *)(a3 + v160) = v161;
      v162 = v161 + -2.0;
      if (*(float *)(a3 + v156) > v162)
        v162 = *(float *)(a3 + v156);
      *(float *)(a3 + v156) = v162;
      v163 = v162 + -2.0;
      if (*(float *)(a3 + v153) > v163)
        v163 = *(float *)(a3 + v153);
      *(float *)(a3 + v153) = v163;
      v164 = v163 + -2.0;
      if (*(float *)(a3 + v151) > v164)
        v164 = *(float *)(a3 + v151);
      *(float *)(a3 + v151) = v164;
      v165 = v164 + -2.0;
      if (*(float *)(a3 + v149) > v165)
        v165 = *(float *)(a3 + v149);
      *(float *)(a3 + v149) = v165;
      v166 = v165 + -2.0;
      if (*(float *)(a3 + v147) > v166)
        v166 = *(float *)(a3 + v147);
      *(float *)(a3 + v147) = v166;
      v167 = v166 + -2.0;
      if (*(float *)(a3 + v145) > v167)
        v167 = *(float *)(a3 + v145);
      *(float *)(a3 + v145) = v167;
      v168 = v167 + -2.0;
      if (*(float *)(a3 + v143) > v168)
        v168 = *(float *)(a3 + v143);
      *(float *)(a3 + v143) = v168;
      v169 = v168 + -2.0;
      if (*(float *)(a3 + v141) > v169)
        v169 = *(float *)(a3 + v141);
      *(float *)(a3 + v141) = v169;
      v170 = v169 + -2.0;
      if (*(float *)(a3 + v139) > v170)
        v170 = *(float *)(a3 + v139);
      *(float *)(a3 + v139) = v170;
      v171 = v170 + -2.0;
      if (*(float *)(a3 + v137) > v171)
        v171 = *(float *)(a3 + v137);
      *(float *)(a3 + v137) = v171;
      v172 = v171 + -2.0;
      if (*(float *)(a3 + v135) > v172)
        v172 = *(float *)(a3 + v135);
      *(float *)(a3 + v135) = v172;
      v173 = v172 + -2.0;
      if (*(float *)(a3 + v133) > v173)
        v173 = *(float *)(a3 + v133);
      *(float *)(a3 + v133) = v173;
      v174 = v173 + -2.0;
      if (*(float *)(a3 + v131) > v174)
        v174 = *(float *)(a3 + v131);
      *(float *)(a3 + v131) = v174;
      v175 = v174 + -2.0;
      if (*(float *)(a3 + v129) > v175)
        v175 = *(float *)(a3 + v129);
      *(float *)(a3 + v129) = v175;
      v176 = v175 + -2.0;
      if (*(float *)(a3 + v127) > v176)
        v176 = *(float *)(a3 + v127);
      *(float *)(a3 + v127) = v176;
      v177 = v176 + -2.0;
      if (*(float *)(a3 + v125) > v177)
        v177 = *(float *)(a3 + v125);
      *(float *)(a3 + v125) = v177;
      v178 = v177 + -2.0;
      if (*(float *)(a3 + v123) > v178)
        v178 = *(float *)(a3 + v123);
      *(float *)(a3 + v123) = v178;
      v179 = v178 + -2.0;
      if (*(float *)(a3 + v121) > v179)
        v179 = *(float *)(a3 + v121);
      *(float *)(a3 + v121) = v179;
      v180 = v179 + -2.0;
      if (*(float *)(a3 + v305) > v180)
        v180 = *(float *)(a3 + v305);
      *(float *)(a3 + v305) = v180;
      v181 = *((_DWORD *)&v359 + v296);
      if (v181 == 1)
      {
        v200 = 0;
        a7 = v282;
        v35 = LOBYTE(v287);
        v183 = (void *)v293;
        do
        {
          v201 = *(float *)((char *)&v316 + v200);
          v202 = *(float *)(v95 + v200);
          v203 = v202 - v201;
          if (v201 > v202)
          {
            v204 = v201 - v202;
          }
          else
          {
            v201 = *(float *)(v95 + v200);
            v204 = v203;
          }
          if (v204 < 8.0)
          {
            v205 = vcvtms_s32_f32(v204 + v204);
            v201 = (float)(v201 + logSum_diff_table[v205])
                 + (float)((float)-(float)((float)(int)floorf(v204 + v204) - (float)(v204 * 2.0))
                         * (float)(logSum_diff_table[v205 + 1] - logSum_diff_table[v205]));
          }
          *(float *)((char *)&v316 + v200) = v201;
          v200 += 4;
        }
        while (v200 != 84);
      }
      else
      {
        a7 = v282;
        v182 = v267;
        v183 = (void *)v293;
        if (v181 == 3)
        {
          v194 = 0;
          v35 = LOBYTE(v287);
          do
          {
            v195 = v182[v194];
            v196 = *(float *)(v95 + v194 * 4);
            v197 = v196 - v195;
            if (v195 > v196)
            {
              v198 = v195 - v196;
            }
            else
            {
              v195 = *(float *)(v95 + v194 * 4);
              v198 = v197;
            }
            if (v198 < 8.0)
            {
              v199 = vcvtms_s32_f32(v198 + v198);
              v195 = (float)(v195 + logSum_diff_table[v199])
                   + (float)((float)-(float)((float)(int)floorf(v198 + v198) - (float)(v198 * 2.0))
                           * (float)(logSum_diff_table[v199 + 1] - logSum_diff_table[v199]));
            }
            v182[v194++] = v195;
          }
          while (v194 != 21);
        }
        else
        {
          v35 = LOBYTE(v287);
          if (v181 == 2)
          {
            for (i = 0; i != 84; i += 4)
            {
              v185 = *(float *)((char *)&v316 + i);
              v186 = *(float *)(v95 + i) + -0.5;
              v187 = v185 - v186;
              v188 = v186 - v185;
              if (v185 <= v186)
              {
                v185 = *(float *)(v95 + i) + -0.5;
                v187 = v188;
              }
              if (v187 < 8.0)
              {
                v189 = vcvtms_s32_f32(v187 + v187);
                v185 = (float)(v185 + logSum_diff_table[v189])
                     + (float)((float)-(float)((float)(int)floorf(v187 + v187) - (float)(v187 * 2.0))
                             * (float)(logSum_diff_table[v189 + 1] - logSum_diff_table[v189]));
              }
              *(float *)((char *)&v316 + i) = v185;
              v190 = *(float *)((char *)&v338 + i);
              v191 = v190 - v186;
              if (v190 <= v186)
              {
                v192 = v186 - v190;
              }
              else
              {
                v186 = *(float *)((char *)&v338 + i);
                v192 = v191;
              }
              if (v192 < 8.0)
              {
                v193 = vcvtms_s32_f32(v192 + v192);
                v186 = (float)(v186 + logSum_diff_table[v193])
                     + (float)((float)-(float)((float)(int)floorf(v192 + v192) - (float)(v192 * 2.0))
                             * (float)(logSum_diff_table[v193 + 1] - logSum_diff_table[v193]));
              }
              *(float *)((char *)&v338 + i) = v186;
            }
          }
        }
      }
      memcpy(v183, v279, 0x1E0uLL);
      v36 = v296 + 1;
      LODWORD(v294) += 21;
      a5 = v281;
      if (v296 + 1 == v268)
        goto LABEL_194;
    }
    if ((v35 & 1) == 0)
    {
      bzero(v288, v259);
      v38 = v296;
    }
    v42 = v286;
    v43.i64[0] = 0x4700000047000000;
    v43.i64[1] = 0x4700000047000000;
    v45 = v263;
    v44 = v264;
    if ((int)v290 >= 1)
    {
      if (v261 == 0.0)
      {
        v50 = 0;
      }
      else
      {
        v46 = v260;
        v47 = v257;
        v48 = v258;
        do
        {
          v49 = vmulq_f32(*v48, v43);
          v47[-1] = vmulq_f32(v48[-1], v43);
          *v47 = v49;
          v48 += 2;
          v47 = (float32x4_t *)((char *)v47 + v44);
          v46 -= 8;
        }
        while (v46);
        v50 = v260;
        if (v260 == v262)
          goto LABEL_53;
      }
      v55 = v262 - v50;
      v56 = (float *)((char *)v288 + v45 * (unint64_t)v50);
      v57 = &v289[v50];
      do
      {
        v58 = *v57++;
        *v56 = v58 * 32768.0;
        v56 = (float *)((char *)v56 + v45);
        --v55;
      }
      while (v55);
    }
LABEL_53:
    if ((int)v42 >= 1)
    {
      v59 = v288;
      v60 = v42;
      do
      {
        v61 = *v59;
        *v59 = *v59 - v39;
        ++v59;
        v39 = v40 * v61;
        --v60;
      }
      while (v60);
    }
    goto LABEL_56;
  }
LABEL_194:
  v206 = v338;
  *(float *)v304.i32 = v338;
  *(float *)&v262 = v316;
  if (v316 < v338)
    v206 = v316;
  *(float *)&v284 = v206;
  v207 = v339;
  *(float *)&v305 = v339;
  v208 = v340;
  *(float *)&v259 = v317;
  if (v317 < v339)
    v207 = v317;
  *(float *)&v283 = v207;
  *(float *)&v260 = v318;
  v261 = v319;
  *(float *)&v302 = v340;
  if (v318 < v340)
    v208 = v318;
  *(float *)&v281 = v208;
  v209 = v341;
  *(float *)&v303 = v341;
  v210 = v342;
  *(float *)&v301 = v342;
  if (v319 < v341)
    v209 = v319;
  *(float *)&v280 = v209;
  *(float *)&v257 = v320;
  *(float *)&v258 = v321;
  if (v320 < v342)
    v210 = v320;
  *(float *)&v279 = v210;
  v211 = v343;
  *(float *)&v298 = v343;
  v212 = v344;
  v300 = v344;
  if (v321 < v343)
    v211 = v321;
  v278.f32[0] = v211;
  v253 = v322;
  v254 = v323;
  if (v322 < v344)
    v212 = v322;
  v277.f32[0] = v212;
  v213 = v345;
  *(float *)&v297 = v345;
  v214 = v346;
  *(float *)&v299 = v346;
  if (v323 < v345)
    v213 = v323;
  v276.f32[0] = v213;
  v251 = v324;
  v252 = v325;
  if (v324 < v346)
    v214 = v324;
  v275.f32[0] = v214;
  v215 = v255;
  v216 = v347;
  *(float *)&v290 = v347;
  v217 = v348;
  *(float *)&v295 = v348;
  if (v325 < v347)
    v216 = v325;
  v274.f32[0] = v216;
  v250 = v326;
  *(float *)&v255 = v327;
  if (v326 < v348)
    v217 = v326;
  v273.f32[0] = v217;
  v218 = v349;
  *(float *)&v289 = v349;
  v219 = v350;
  v294 = v350;
  if (v327 < v349)
    v218 = v327;
  v272.f32[0] = v218;
  v220 = v328;
  v221 = v329;
  if (v328 < v350)
    v219 = v328;
  v271.f32[0] = v219;
  v222 = v351;
  *(float *)&v288 = v351;
  v223 = v352;
  *(float *)&v293 = v352;
  if (v329 < v351)
    v222 = v329;
  v270.f32[0] = v222;
  v224 = v330;
  v225 = v331;
  if (v330 < v352)
    v223 = v330;
  *(float *)&v269 = v223;
  v226 = v353;
  v287 = v353;
  v227 = v354;
  *(float *)v292.f64 = v354;
  if (v331 < v353)
    v226 = v331;
  *(float *)&v268 = v226;
  v228 = v332;
  v229 = v333;
  if (v332 < v354)
    v227 = v332;
  *(float *)&v267 = v227;
  v230 = v355;
  *(float *)&v286 = v355;
  v231 = v356;
  *(float *)v291.f64 = v356;
  if (v333 < v355)
    v230 = v333;
  *(float *)&v266 = v230;
  v232 = v334;
  v233 = v335;
  if (v334 < v356)
    v231 = v334;
  *(float *)&v265 = v231;
  v234 = v357;
  *(float *)&v285 = v357;
  v235 = v358;
  *(float *)&v296 = v358;
  if (v335 < v357)
    v234 = v335;
  *(float *)&v264 = v234;
  v249 = v336;
  if (v336 < v358)
    v235 = v336;
  *(float *)&v263 = v235;
  v236 = log((float)(2.0 / (float)v215)) * 1.44269504;
  v237 = v236 * 0.5;
  v316 = v237 + *(float *)&v262;
  v317 = v237 + *(float *)&v259;
  v318 = v237 + *(float *)&v260;
  v319 = v237 + v261;
  v320 = v237 + *(float *)&v257;
  v321 = v237 + *(float *)&v258;
  v322 = v237 + v253;
  v323 = v237 + v254;
  v324 = v237 + v251;
  v325 = v237 + v252;
  v326 = v237 + v250;
  v327 = v237 + *(float *)&v255;
  v328 = v237 + v220;
  v329 = v237 + v221;
  v330 = v237 + v224;
  v331 = v237 + v225;
  v332 = v237 + v228;
  v333 = v237 + v229;
  v334 = v237 + v232;
  v335 = v237 + v233;
  v336 = v237 + v249;
  v337[0] = v237 + *(float *)&v284;
  v337[1] = v237 + *(float *)&v283;
  v337[2] = v237 + *(float *)&v281;
  v337[3] = v237 + *(float *)&v280;
  v337[4] = v237 + *(float *)&v279;
  v337[5] = v237 + v278.f32[0];
  v337[6] = v237 + v277.f32[0];
  v337[7] = v237 + v276.f32[0];
  v337[8] = v237 + v275.f32[0];
  v337[9] = v237 + v274.f32[0];
  v337[10] = v237 + v273.f32[0];
  v337[11] = v237 + v272.f32[0];
  v337[12] = v237 + v271.f32[0];
  v337[13] = v237 + v270.f32[0];
  v337[14] = v237 + *(float *)&v269;
  v337[15] = v237 + *(float *)&v268;
  v337[16] = v237 + *(float *)&v267;
  v337[17] = v237 + *(float *)&v266;
  v337[18] = v237 + *(float *)&v265;
  v337[19] = v237 + *(float *)&v264;
  v337[20] = v237 + *(float *)&v263;
  v338 = v237 + *(float *)v304.i32;
  v339 = v237 + *(float *)&v305;
  v340 = v237 + *(float *)&v302;
  v341 = v237 + *(float *)&v303;
  v342 = v237 + *(float *)&v301;
  v343 = v237 + *(float *)&v298;
  v344 = v237 + v300;
  v345 = v237 + *(float *)&v297;
  v346 = v237 + *(float *)&v299;
  v347 = v237 + *(float *)&v290;
  v348 = v237 + *(float *)&v295;
  v349 = v237 + *(float *)&v289;
  v350 = v237 + v294;
  v351 = v237 + *(float *)&v288;
  v352 = v237 + *(float *)&v293;
  v353 = v237 + v287;
  v354 = v237 + *(float *)v292.f64;
  v355 = v237 + *(float *)&v286;
  v356 = v237 + *(float *)v291.f64;
  v357 = v237 + *(float *)&v285;
  v358 = v237 + *(float *)&v296;
  if ((int)a7 > 0)
  {
    v238 = 0;
    v239 = 21 * a7;
    v240 = &v359;
    do
    {
      while (1)
      {
        v246 = *(_DWORD *)v240;
        v240 = (__int128 *)((char *)v240 + 4);
        v245 = v246;
        if (!v246)
          break;
        v241 = (float32x4_t *)(&v316 + 21 * v245 - 21);
        v242 = (float32x4_t *)(a3 + 4 * v238);
        v243 = vsubq_f32(v242[1], v241[1]);
        *v242 = vsubq_f32(*v242, *v241);
        v242[1] = v243;
        v244 = vsubq_f32(v242[3], v241[3]);
        v242[2] = vsubq_f32(v242[2], v241[2]);
        v242[3] = v244;
        v242[4] = vsubq_f32(v242[4], v241[4]);
        v242[5].f32[0] = v242[5].f32[0] - v241[5].f32[0];
        v238 += 21;
        if (v239 == v238)
          return;
      }
      v247 = a3 + 4 * v238;
      *(_DWORD *)(v247 + 80) = 0;
      *(_OWORD *)(v247 + 48) = 0uLL;
      *(_OWORD *)(v247 + 64) = 0uLL;
      *(_OWORD *)(v247 + 16) = 0uLL;
      *(_OWORD *)(v247 + 32) = 0uLL;
      *(_OWORD *)v247 = 0uLL;
      v238 += 21;
    }
    while (v239 != v238);
  }
}

uint64_t opus_multistream_encoder_init_impl(unsigned int *a1, int a2, unsigned int a3, int a4, int a5, uint64_t a6, int a7, int a8)
{
  uint64_t v8;
  int v10;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  char *v18;
  char v19;
  uint64_t v21;
  int v22;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  unsigned __int8 *v28;
  unsigned int v29;
  uint64_t i;
  int v31;
  int v32;
  unsigned __int8 *v33;
  unsigned int v34;
  int v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  char *v44;
  int v45;
  char *v46;
  __int128 *v47;
  _OWORD *v48;
  uint64_t v49;
  __int128 v50;
  uint64_t v51;
  uint64_t *v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int *v69;
  int v70;
  uint64_t v71;
  int v72;
  int j;
  uint64_t v74;

  v8 = 0xFFFFFFFFLL;
  if (a3 - 256 < 0xFFFFFF01)
    return v8;
  if (a5 < 0)
    return v8;
  if (a4 < 1)
    return v8;
  if (a5 > a4)
    return v8;
  if (255 - a5 < a4)
    return v8;
  v10 = a5 + a4;
  if (a5 + a4 > (int)a3)
    return v8;
  a1[67] = 0;
  *a1 = a3;
  a1[1] = a4;
  a1[2] = a5;
  if (a8 != 1)
    a1[68] = -1;
  a1[72] = -1000;
  a1[69] = a7;
  a1[70] = 5000;
  if (a3 >= 8 && (unint64_t)a1 - a6 + 12 >= 0x20)
  {
    if (a3 >= 0x20)
    {
      v15 = a3 & 0xFFFFFFE0;
      v47 = (__int128 *)(a6 + 16);
      v48 = a1 + 7;
      v49 = v15;
      do
      {
        v50 = *v47;
        *(v48 - 1) = *(v47 - 1);
        *v48 = v50;
        v47 += 2;
        v48 += 2;
        v49 -= 32;
      }
      while (v49);
      if (v15 == a3)
        goto LABEL_14;
      if ((a3 & 0x18) == 0)
        goto LABEL_12;
    }
    else
    {
      v15 = 0;
    }
    v51 = v15;
    v15 = a3 & 0xFFFFFFF8;
    v52 = (uint64_t *)(a6 + v51);
    v53 = (_QWORD *)((char *)a1 + v51 + 12);
    v54 = v51 - v15;
    do
    {
      v55 = *v52++;
      *v53++ = v55;
      v54 += 8;
    }
    while (v54);
    if (v15 == a3)
      goto LABEL_14;
    goto LABEL_12;
  }
  v15 = 0;
LABEL_12:
  v16 = a3 - v15;
  v17 = (char *)a1 + v15 + 12;
  v18 = (char *)(a6 + v15);
  do
  {
    v19 = *v18++;
    *v17++ = v19;
    --v16;
  }
  while (v16);
LABEL_14:
  if (v10 <= 255)
  {
    v21 = 0;
    while (1)
    {
      v22 = *((unsigned __int8 *)a1 + v21 + 12);
      if (v22 != 255 && v10 <= v22)
        break;
      if (a3 == ++v21)
      {
        v24 = 0;
        if (a4 <= 1)
          v25 = 1;
        else
          v25 = a4;
        do
        {
          if (v24 >= a5)
          {
            v28 = (unsigned __int8 *)(a1 + 3);
            v29 = a3;
            for (i = 0xFFFFFFFFLL; ; --i)
            {
              v31 = *v28++;
              if (v24 + a5 == v31)
                break;
              v8 = 0xFFFFFFFFLL;
              if (!--v29)
                return v8;
            }
          }
          else
          {
            v26 = 0;
            v27 = 2 * v24;
            while (v27 != *((unsigned __int8 *)a1 + v26 + 12))
            {
              ++v26;
              v8 = 0xFFFFFFFFLL;
              if (a3 == (_DWORD)v26)
                return v8;
            }
            v8 = 0xFFFFFFFFLL;
            if (v26 == 0xFFFFFFFFLL)
              return v8;
            v32 = v27 | 1;
            v33 = (unsigned __int8 *)(a1 + 3);
            v34 = a3;
            for (i = 0xFFFFFFFFLL; ; --i)
            {
              v35 = *v33++;
              if (v32 == v35)
                break;
              v8 = 0xFFFFFFFFLL;
              if (!--v34)
                return v8;
            }
          }
          if (!i)
            return 0xFFFFFFFFLL;
          ++v24;
        }
        while (v24 != v25);
        if (a8 != 2)
          goto LABEL_54;
        if (a3 - 228 >= 0xFFFFFF1D)
        {
          v36 = 0;
          v37 = (31 - __clz(a3)) >> 1;
          v38 = 1 << v37;
          v39 = a3;
          do
          {
            v40 = (v38 + 2 * v36) << v37;
            if (v40 <= v39)
            {
              v41 = v38;
            }
            else
            {
              v40 = 0;
              v41 = 0;
            }
            v39 -= v40;
            v36 += v41;
            v38 >>= 1;
            --v37;
          }
          while (v37 != -1);
          v42 = a3 - v36 * v36;
          if (!v42 || v42 == 2)
          {
LABEL_54:
            v44 = (char *)(a1 + 74);
            if (a5 < 1)
            {
              v45 = 0;
              v46 = (char *)(a1 + 74);
              goto LABEL_73;
            }
            v45 = 0;
            v46 = (char *)(a1 + 74);
            do
            {
              v56 = opus_encoder_init(v46, a2, 2, a7);
              if ((_DWORD)v56)
                return v56;
              if (v45 == a1[68])
                opus_encoder_ctl((int *)v46, 10024, v57, v58, v59, v60, v61, v62, 1);
              v46 += 48496;
              ++v45;
            }
            while (v45 < (int)a1[2]);
            while (1)
            {
              a4 = a1[1];
LABEL_73:
              if (v45 >= a4)
                break;
              v8 = opus_encoder_init(v46, a2, 1, a7);
              if (v45 == a1[68])
                opus_encoder_ctl((int *)v46, 10024, v63, v64, v65, v66, v67, v68, 1);
              if ((_DWORD)v8)
                return v8;
              v46 += 43584;
              ++v45;
            }
            if (a8 == 1)
            {
              v69 = (int *)(a1 + 74);
              if (a4 >= 1)
              {
                v70 = 0;
                v69 = (int *)(a1 + 74);
                do
                {
                  if (v70 >= (int)a1[2])
                    v71 = 43584;
                  else
                    v71 = 48496;
                  v69 = (int *)((char *)v69 + v71);
                  ++v70;
                }
                while (a4 != v70);
              }
              bzero(&v69[120 * *a1], 4 * a3);
              v72 = a1[1];
              if (v72 >= 1)
              {
                for (j = 0; j != v72; ++j)
                {
                  if (j >= (int)a1[2])
                    v74 = 43584;
                  else
                    v74 = 48496;
                  v44 += v74;
                }
              }
              bzero(v44, 480 * a3);
            }
            v8 = 0;
            a1[71] = a8;
            return v8;
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t opus_multistream_encode_native(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, uint64_t a10)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  _BYTE *v19;
  uint64_t v20;
  void (*v21)(float *, uint64_t, uint64_t);
  void (*v22)(float *, uint64_t, uint64_t);
  unsigned int *v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int *v28;
  uint64_t v29;
  int i;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t result;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  __int16 v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  uint64_t v69;
  _BOOL8 v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  int v77;
  unsigned int v78;
  int v79;
  int v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  unsigned int v90;
  unint64_t v91;
  int v92;
  uint64_t v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  uint64_t v101;
  int v102;
  int v103;
  int v104;
  int32x4_t v105;
  int32x4_t *v106;
  uint64_t v107;
  unint64_t v108;
  unsigned int *v109;
  unint64_t v110;
  int v111;
  int32x4_t *v112;
  int32x4_t v113;
  int32x4_t v114;
  uint64_t v115;
  int32x4_t v116;
  int32x4_t v117;
  int32x4_t v118;
  unint64_t v119;
  int *v120;
  int v121;
  BOOL v122;
  int v123;
  uint64_t v124;
  int *v125;
  uint64_t v126;
  uint64_t v127;
  unsigned int v128;
  int v129;
  unsigned int v130;
  int v131;
  int v132;
  unsigned int v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  signed int v141;
  float *v142;
  unsigned int *v143;
  _BYTE *v144;
  signed int v145;
  uint64_t v146;
  uint64_t v147;
  int v148;
  uint64_t v149;
  int v150;
  int v151;
  float *v152;
  uint64_t v153;
  uint64_t v154;
  void (*v155)(float *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  __int128 v164;
  __int128 v165;
  _OWORD *v166;
  int v167;
  int v168;
  uint64_t v169;
  __int128 v170;
  __int128 v171;
  uint64_t v172;
  unsigned int v173;
  int v174;
  int v175;
  int v176;
  int v177;
  unsigned int v178;
  int v179;
  int v180;
  uint64_t v181;
  int v182;
  int v183;
  _BYTE *v184;
  int v185;
  _QWORD v186[2];
  float *v187;
  float *v188;
  uint64_t v189;
  int v190;
  uint64_t v191;
  int v192;
  unsigned int v193;
  unsigned int v194;
  uint64_t v195;
  void (*v196)(float *, uint64_t, uint64_t);
  _BYTE *v197;
  unsigned int v198;
  int v199;
  uint64_t v200;
  uint64_t v201;
  int *v202;
  uint64_t v203;
  int v204;
  int v205[127];
  int v206;
  _OWORD v207[5];
  int v208;
  _BYTE v209[108];
  _BYTE v210[1008];
  _DWORD v211[1916];
  uint64_t v212;

  v10 = (int *)MEMORY[0x24BDAC7A8](a1, a2);
  v200 = v16;
  v201 = v11;
  v17 = v15;
  v18 = v14;
  v19 = (_BYTE *)v13;
  v20 = v12;
  v22 = v21;
  v23 = (unsigned int *)v10;
  v212 = *MEMORY[0x24BDAC8D0];
  if (v10[71] == 1)
  {
    v24 = (uint64_t)(v10 + 74);
    v25 = v10[1];
    if (v25 <= 0)
    {
      v32 = v24 + 480 * *v10;
    }
    else
    {
      v26 = 0;
      v27 = v10[2];
      v28 = v10 + 74;
      do
      {
        if (v26 >= v27)
          v29 = 43584;
        else
          v29 = 48496;
        v28 = (int *)((char *)v28 + v29);
        ++v26;
      }
      while (v25 != v26);
      for (i = 0; i != v25; ++i)
      {
        if (i >= v27)
          v31 = 43584;
        else
          v31 = 48496;
        v24 += v31;
      }
      v32 = (uint64_t)&v28[120 * *v10];
    }
  }
  else
  {
    v24 = 0;
    v32 = 0;
  }
  v206 = 0;
  memset(v205, 0, 496);
  v204 = 0;
  v203 = 0;
  opus_encoder_ctl(v10 + 74, 4029, v11, v12, v13, v14, v15, v16, (uint64_t)&v206);
  opus_encoder_ctl((int *)v23 + 74, 4007, v33, v34, v35, v36, v37, v38, (uint64_t)&v204);
  v202 = (int *)(v23 + 74);
  result = opus_encoder_ctl((int *)v23 + 74, 10015, v39, v40, v41, v42, v43, v44, (uint64_t)&v203);
  if (v206 / 400 > (int)v20)
    return 0xFFFFFFFFLL;
  v47 = v23[70];
  v48 = v20;
  if (v47 != 5000)
  {
    if (v47 - 5001 > 8)
      return 0xFFFFFFFFLL;
    if (v47 >> 1 > 0x9C6)
    {
      v80 = (v47 - 5003) * v206;
      v48 = (v80 / 50);
      if (v80 / 50 > (int)v20)
        return 0xFFFFFFFFLL;
    }
    else
    {
      v48 = ((v206 / 400) << (v47 + 119));
      if ((int)v48 > (int)v20)
        return 0xFFFFFFFFLL;
    }
  }
  v196 = v22;
  if (400 * (_DWORD)v48 == v206 || 200 * (_DWORD)v48 == v206 || 100 * (_DWORD)v48 == v206)
  {
    if ((int)v48 >= 1)
      goto LABEL_31;
    return 0xFFFFFFFFLL;
  }
  v49 = (50 * (_DWORD)v48 != v206) & vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(vdupq_n_s32(50 * (int)v48), vmulq_s32(vdupq_n_s32(v206), (int32x4_t)xmmword_208F382E0)))), 0xFuLL)));
  if (25 * (_DWORD)v48 == v206)
    LOBYTE(v49) = 0;
  result = 0xFFFFFFFFLL;
  if ((int)v48 >= 1 && (v49 & 1) == 0)
  {
LABEL_31:
    if (v206 / (int)v48 == 10)
      v50 = v23[1];
    else
      v50 = 0;
    v51 = v50 + 2 * v23[1] - 1;
    if (v51 > v18)
      return 4294967294;
    v186[1] = v186;
    v52 = MEMORY[0x24BDAC7A8](result, v46);
    v188 = (float *)((char *)v186 - v53);
    MEMORY[0x24BDAC7A8](v52, v54);
    v189 = (uint64_t)v186 - v69;
    if (v23[71] == 1)
      surround_analysis(v203, v201, v189, v24, v32, v48, v59, v206, v61, v62, v63, v64, v65, v66, v67, v68, (void (*)(float *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))v196, *((float *)v23 + 67));
    v211[0] = 0;
    opus_encoder_ctl(v202, 4029, v55, v56, v57, v58, v59, v60, (uint64_t)v211);
    if (v23[71] == 2)
    {
      v76 = v23[1];
      v77 = v23[2] + v76;
      v78 = v23[72];
      if (v78 == -1)
      {
        v79 = 320000 * v77;
      }
      else
      {
        v79 = v23[72];
        if (v78 == -1000)
          v79 = 15000 * v76 + (60 * v211[0] / (int)v48 + v211[0]) * v77;
      }
      if ((int)v76 >= 1)
      {
        v90 = v79 / (int)v76;
        if (v76 < 8)
        {
          v91 = 0;
LABEL_87:
          v108 = v76 - v91;
          v109 = (unsigned int *)&v209[4 * v91 + 92];
          do
          {
            *v109++ = v90;
            --v108;
          }
          while (v108);
          goto LABEL_89;
        }
        v91 = v76 & 0x7FFFFFF8;
        v105 = vdupq_n_s32(v90);
        v106 = (int32x4_t *)v210;
        v107 = v76 & 0xFFFFFFF8;
        do
        {
          v106[-1] = v105;
          *v106 = v105;
          v106 += 2;
          v107 -= 8;
        }
        while (v107);
        if (v91 != v76)
          goto LABEL_87;
LABEL_89:
        if (v76 >= 8)
        {
          v110 = v76 & 0x7FFFFFF8;
          v112 = (int32x4_t *)v210;
          v113 = 0uLL;
          v114 = vdupq_n_s32(0x1F4u);
          v115 = v76 & 0xFFFFFFF8;
          v116 = 0uLL;
          do
          {
            v117 = vmaxq_s32(v112[-1], v114);
            v118 = vmaxq_s32(*v112, v114);
            v112[-1] = v117;
            *v112 = v118;
            v113 = vaddq_s32(v117, v113);
            v116 = vaddq_s32(v118, v116);
            v112 += 2;
            v115 -= 8;
          }
          while (v115);
          v111 = vaddvq_s32(vaddq_s32(v116, v113));
          if (v76 == v110)
          {
LABEL_98:
            v104 = 3 * v111;
LABEL_99:
            if (v204)
              v122 = 1;
            else
              v122 = v78 == -1;
            if (v122)
            {
              if ((int)v76 < 1)
                return 0;
            }
            else
            {
              if (v78 == -1000)
              {
                v123 = v104 / (24 * v206 / (int)v48);
              }
              else
              {
                v123 = (int)(3 * v78) / (24 * v206 / (int)v48);
                if (v51 > v123)
                  v123 = v51;
              }
              if (v123 < v18)
                v18 = v123;
              if ((int)v76 < 1)
                return 0;
            }
            v193 = v20;
            v194 = v17;
            v197 = v19;
            v190 = v18;
            v124 = 0;
            v191 = a10;
            v192 = a9;
            v199 = 3000;
            v125 = v202;
            do
            {
              if (v124 >= (int)v23[2])
                v127 = 43584;
              else
                v127 = 48496;
              opus_encoder_ctl(v125, 4002, v70, v71, v72, v73, v74, v75, *(unsigned int *)&v209[4 * v124 + 92]);
              v128 = v23[71];
              if (v128 == 2)
              {
                opus_encoder_ctl(v125, 11002, v70, v71, v72, v73, v74, v75, 1002);
              }
              else if (v128 == 1)
              {
                v129 = v23[72];
                v130 = *v23;
                if (50 * (int)v48 < v206)
                  v129 += (v199 - 60 * (v206 / (int)v48)) * v130;
                v131 = 10000 * v130;
                v132 = 7000 * v130;
                if (v129 <= (int)(5000 * v130))
                  v133 = 1101;
                else
                  v133 = 1103;
                if (v129 > v132)
                  v133 = 1104;
                if (v129 <= v131)
                  v134 = v133;
                else
                  v134 = 1105;
                opus_encoder_ctl(v125, 4008, v70, v71, v72, v73, v74, v75, v134);
                if (v124 < (int)v23[2])
                {
                  opus_encoder_ctl(v125, 11002, v70, v71, v72, v73, v74, v75, 1002);
                  opus_encoder_ctl(v125, 4022, v135, v136, v137, v138, v139, v140, 2);
                }
              }
              v125 = (int *)((char *)v125 + v127);
              ++v124;
              v126 = (int)v23[1];
            }
            while (v124 < v126);
            if ((int)v126 >= 1)
            {
              LODWORD(result) = 0;
              v141 = 0;
              v142 = v188;
              v187 = v188 + 1;
              v186[0] = v209;
              v143 = v23 + 3;
              v144 = v197;
              v198 = v48;
              while (1)
              {
                v205[1] = 0;
                v145 = v23[2];
                v146 = *v23;
                v197 = v144;
                v199 = result;
                if (v141 >= v145)
                {
                  if ((int)v146 < 1)
                  {
LABEL_149:
                    LODWORD(v147) = -1;
                  }
                  else
                  {
                    v147 = 0;
                    v151 = v145 + v141;
                    while (v151 != *((unsigned __int8 *)v143 + v147))
                    {
                      if (v146 == ++v147)
                        goto LABEL_149;
                    }
                  }
                  v196(v142, 1, v201);
                  v167 = -1;
                  if (v23[71] != 1)
                  {
                    v195 = 43584;
                    LODWORD(v149) = -1;
                    goto LABEL_159;
                  }
                  v166 = v207;
                  LODWORD(v149) = v147;
                  v195 = 43584;
                  v162 = v189;
                }
                else
                {
                  if ((int)v146 < 1)
                  {
                    LODWORD(v147) = -1;
LABEL_151:
                    v149 = 0xFFFFFFFFLL;
                  }
                  else
                  {
                    v147 = 0;
                    v148 = 2 * v141;
                    while (v148 != *((unsigned __int8 *)v143 + v147))
                    {
                      if (v146 == ++v147)
                      {
                        LODWORD(v147) = -1;
                        break;
                      }
                    }
                    v149 = 0;
                    v150 = v148 | 1;
                    while (v150 != *((unsigned __int8 *)v143 + v149))
                    {
                      if ((_DWORD)v146 == (_DWORD)++v149)
                        goto LABEL_151;
                    }
                  }
                  v152 = v142;
                  v153 = v201;
                  v154 = v191;
                  v155 = (void (*)(float *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v196;
                  v196(v152, 2, v201);
                  v155(v187, 2, v153, *v23, v149, v198, v154);
                  if (v23[71] != 1)
                  {
                    v195 = 48496;
                    v168 = v190;
                    LODWORD(v48) = v198;
                    v142 = v188;
                    goto LABEL_160;
                  }
                  v142 = v188;
                  v162 = v189;
                  v163 = v189 + 84 * (_DWORD)v147;
                  v164 = *(_OWORD *)(v163 + 48);
                  v207[2] = *(_OWORD *)(v163 + 32);
                  v207[3] = v164;
                  v207[4] = *(_OWORD *)(v163 + 64);
                  v208 = *(_DWORD *)(v163 + 80);
                  v165 = *(_OWORD *)(v163 + 16);
                  v207[0] = *(_OWORD *)v163;
                  v207[1] = v165;
                  v166 = (_OWORD *)v186[0];
                  v195 = 48496;
                  v167 = v149;
                  LODWORD(v48) = v198;
                }
                v169 = v162 + 84 * (_DWORD)v149;
                v170 = *(_OWORD *)(v169 + 48);
                v166[2] = *(_OWORD *)(v169 + 32);
                v166[3] = v170;
                v166[4] = *(_OWORD *)(v169 + 64);
                *((_DWORD *)v166 + 20) = *(_DWORD *)(v169 + 80);
                v171 = *(_OWORD *)(v169 + 16);
                *v166 = *(_OWORD *)v169;
                v166[1] = v171;
                opus_encoder_ctl(v202, 10026, v156, v157, v158, v159, v160, v161, (uint64_t)v207);
                LODWORD(v149) = v167;
LABEL_159:
                v168 = v190;
LABEL_160:
                v172 = (v168 - v199);
                v173 = v23[1];
                v174 = v173 + ~v141;
                if (v174 <= 0)
                  v175 = 0;
                else
                  v175 = 1 - 2 * v174;
                if (v206 / (int)v48 != 10)
                  v174 = 0;
                v176 = v172 - v174 + v175;
                if (v176 >= 7662)
                  v177 = 7662;
                else
                  v177 = v176;
                v178 = v173 - 1;
                if (v177 > 253)
                  v179 = -2;
                else
                  v179 = -1;
                if (v141 == v178)
                  v180 = 0;
                else
                  v180 = v179;
                if (!v204 && v141 == v178)
                  opus_encoder_ctl(v202, 4002, v156, v157, v158, v159, v160, v161, (8 * v206 / (int)v198 * v177));
                v181 = (v180 + v177);
                LODWORD(v48) = v198;
                result = opus_encode_native(v202, v142, v198, (uint64_t)v211, v181, v194, v201, v193, v147, v149, *v23, v200, v192);
                if ((result & 0x80000000) != 0)
                  return result;
                if (opus_repacketizer_cat_impl((uint64_t)v205, (unsigned __int8 *)v211, result, 0))
                  return 4294967293;
                v202 = (int *)((char *)v202 + v195);
                v182 = v23[1] - 1;
                v183 = v141 == v182 && v204 == 0;
                v184 = v197;
                v185 = opus_repacketizer_out_range_impl((uint64_t)v205, 0, v205[1], v197, v172, v141 != v182, v183);
                v144 = &v184[v185];
                result = (v185 + v199);
                if (++v141 >= (int)v23[1])
                  return result;
              }
            }
            return 0;
          }
        }
        else
        {
          v110 = 0;
          v111 = 0;
        }
        v119 = v76 - v110;
        v120 = (int *)&v209[4 * v110 + 92];
        do
        {
          v121 = *v120;
          if (*v120 <= 500)
            v121 = 500;
          *v120++ = v121;
          v111 += v121;
          --v119;
        }
        while (v119);
        goto LABEL_98;
      }
    }
    else
    {
      v81 = v23[68];
      if ((_DWORD)v81 == -1)
        v82 = 0;
      else
        v82 = -1;
      v76 = v23[1];
      v83 = (int)v23[2];
      v84 = v82 - v83 + v76;
      v85 = v84 + 2 * v83;
      v86 = v211[0] / (int)v48;
      if (v211[0] / (int)v48 >= 50)
        v87 = 40 * (v211[0] / (int)v48);
      else
        v87 = 2000;
      v78 = v23[72];
      if (v78 == -1)
      {
        if ((_DWORD)v81 == -1)
          v92 = 0;
        else
          v92 = 128000;
        v88 = v92 + 300000 * v85;
      }
      else
      {
        v88 = v23[72];
        if (v78 == -1000)
        {
          if ((_DWORD)v81 == -1)
            v89 = 0;
          else
            v89 = 8000;
          v88 = v89 + (v211[0] + v87 + 10000) * v85;
        }
      }
      if ((int)v76 >= 1)
      {
        v93 = 0;
        v94 = v88 / 20;
        if (v88 >= 60000)
          v94 = 3000;
        if (v86 >= 50)
          v95 = 15 * v86;
        else
          v95 = 750;
        v70 = (_DWORD)v81 != -1;
        v96 = v94 + v95;
        if ((_DWORD)v81 == -1)
          v97 = 0;
        else
          v97 = v96;
        v98 = v88 - (v97 + v85 * v87);
        v99 = v98 / v85 / 2;
        if (v99 >= 20000)
          v99 = 20000;
        v100 = v99 & ~(v99 >> 31);
        v101 = ((uint64_t)(v98 + v100 * ((v81 != 0xFFFFFFFFLL) - (int)v76)) << 8)
             / (((v84 << 8) + ((_DWORD)v83 << 9)) | (32 * (int)v70));
        v102 = ((v100 + v101) & ~((v100 + (int)v101) >> 31)) + v87;
        v103 = ((v100 + 2 * v101) & ~((v100 + 2 * (int)v101) >> 31)) + 2 * v87;
        do
        {
          if (v93 < v83)
          {
            *(_DWORD *)&v209[4 * v93 + 92] = v103;
          }
          else if (v81 == v93)
          {
            *(_DWORD *)&v209[4 * v93 + 92] = (v96 + ((int)v101 >> 3)) & ~((v96 + ((int)v101 >> 3)) >> 31);
          }
          else
          {
            *(_DWORD *)&v209[4 * v93 + 92] = v102;
          }
          ++v93;
        }
        while (v76 != v93);
        goto LABEL_89;
      }
    }
    v104 = 0;
    goto LABEL_99;
  }
  return result;
}

uint64_t opus_copy_channel_in_short(uint64_t result, int a2, uint64_t a3, int a4, int a5, int a6, double a7, __n128 a8)
{
  uint64_t v8;
  int16x8_t *v9;
  uint64_t v10;
  float32x4_t v11;
  uint64_t v12;
  int16x8_t v13;
  float32x4_t v14;
  float32x4_t v15;
  uint64_t v16;
  _DWORD *v17;
  unsigned __int16 *v18;

  if (a6 >= 1)
  {
    if (a6 < 0x10)
    {
      v8 = 0;
LABEL_9:
      v16 = a6 - v8;
      v17 = (_DWORD *)(result + 4 * v8 * a2);
      v18 = (unsigned __int16 *)(a3 + 2 * (a5 + v8 * a4));
      do
      {
        a8.n128_u16[0] = *v18;
        a8.n128_u64[0] = vmovl_s16((int16x4_t)a8.n128_u64[0]).u64[0];
        a8.n128_f32[0] = (float)a8.n128_i32[0] * 0.000030518;
        *v17 = a8.n128_u32[0];
        v17 += a2;
        v18 += a4;
        --v16;
      }
      while (v16);
      return result;
    }
    v8 = 0;
    if (a4 != 1)
      goto LABEL_9;
    if (a2 != 1)
      goto LABEL_9;
    v8 = a6 & 0xFFFFFFF0;
    v9 = (int16x8_t *)(a3 + 2 * a5 + 16);
    v10 = result + 32;
    v11.i64[0] = 0x3800000038000000;
    v11.i64[1] = 0x3800000038000000;
    v12 = v8;
    do
    {
      v13 = v9[-1];
      v14 = vcvtq_f32_s32(vmovl_high_s16(*v9));
      v15 = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v9->i8)), v11);
      *(float32x4_t *)(v10 - 32) = vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v13.i8)), v11);
      *(float32x4_t *)(v10 - 16) = vmulq_f32(vcvtq_f32_s32(vmovl_high_s16(v13)), v11);
      a8 = (__n128)vmulq_f32(v14, v11);
      *(float32x4_t *)v10 = v15;
      *(__n128 *)(v10 + 16) = a8;
      v9 += 2;
      v10 += 64;
      v12 -= 16;
    }
    while (v12);
    if (v8 != a6)
      goto LABEL_9;
  }
  return result;
}

uint64_t opus_multistream_encoder_ctl_va_list(int *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v10;
  uint64_t result;
  uint64_t *v12;
  unsigned int *v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int *v18;
  int v19;
  int *v21;
  _DWORD *v22;
  int v23;
  uint64_t v24;
  int *v25;
  int v26;
  int *v27;
  int v28;
  uint64_t v29;
  int v30;
  int *v31;
  int v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  int *v37;
  _DWORD *v38;
  int v39;
  int v40;
  uint64_t v41;
  int *v42;
  int *v43;
  _DWORD *v44;
  int *v45;
  int v46;
  int ***v47;
  int **v48;
  int i;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int *v53;

  v53 = (int *)a3;
  v10 = a1 + 74;
  result = 4294967291;
  if (a2 > 5119)
  {
    switch(a2)
    {
      case 5120:
        v45 = v53;
        v53 += 2;
        v46 = *v45;
        if (v46 < 0)
          return 0xFFFFFFFFLL;
        if (v46 >= a1[1])
          return 0xFFFFFFFFLL;
        v47 = (int ***)v53;
        v53 += 2;
        v48 = *v47;
        if (!v48)
        {
          return 0xFFFFFFFFLL;
        }
        else
        {
          if (v46)
          {
            for (i = 0; i != v46; ++i)
            {
              if (i >= a1[2])
                v50 = 43584;
              else
                v50 = 48496;
              v10 = (int *)((char *)v10 + v50);
            }
          }
          result = 0;
          *v48 = v10;
        }
        break;
      case 11002:
LABEL_8:
        v13 = (unsigned int *)v53;
        v53 += 2;
        if (a1[1] < 1)
        {
          return 0;
        }
        else
        {
          v14 = 0;
          v15 = *v13;
          while (1)
          {
            v16 = a1[2];
            result = opus_encoder_ctl(v10, a2, a3, a4, a5, a6, a7, a8, v15);
            if ((_DWORD)result)
              break;
            if (v14 >= v16)
              v17 = 43584;
            else
              v17 = 48496;
            v10 = (int *)((char *)v10 + v17);
            if (++v14 >= a1[1])
              return 0;
          }
        }
        break;
      case 11019:
LABEL_3:
        v12 = (uint64_t *)v53;
        v53 += 2;
        return opus_encoder_ctl(v10, a2, a3, a4, a5, a6, a7, a8, *v12);
    }
  }
  else
  {
    switch(a2)
    {
      case 4000:
      case 4004:
      case 4006:
      case 4008:
      case 4010:
      case 4012:
      case 4014:
      case 4016:
      case 4020:
      case 4022:
      case 4024:
      case 4036:
      case 4042:
      case 4046:
        goto LABEL_8;
      case 4001:
      case 4007:
      case 4009:
      case 4011:
      case 4013:
      case 4015:
      case 4017:
      case 4021:
      case 4023:
      case 4025:
      case 4027:
      case 4029:
      case 4037:
      case 4043:
      case 4047:
        goto LABEL_3;
      case 4002:
        v18 = v53;
        v53 += 2;
        v19 = *v18;
        if (v19 == -1000 || v19 == -1)
          goto LABEL_26;
        if (v19 < 1)
          return 0xFFFFFFFFLL;
        if (500 * *a1 > v19)
          v19 = 500 * *a1;
        if (300000 * *a1 < v19)
          v19 = 300000 * *a1;
LABEL_26:
        result = 0;
        a1[72] = v19;
        return result;
      case 4003:
        v21 = v53;
        v53 += 2;
        v22 = *(_DWORD **)v21;
        if (!*(_QWORD *)v21)
          return 0xFFFFFFFFLL;
        *v22 = 0;
        if (a1[1] < 1)
          return 0;
        v23 = 0;
        do
        {
          v52 = 0;
          if (v23 >= a1[2])
            v24 = 10896;
          else
            v24 = 12124;
          v25 = &v10[v24];
          opus_encoder_ctl(v10, 4003, a3, a4, a5, a6, a7, a8, (uint64_t)&v52);
          result = 0;
          *v22 += v52;
          ++v23;
          v10 = v25;
        }
        while (v23 < a1[1]);
        return result;
      case 4028:
        if (a1[71] == 1)
        {
          v26 = a1[1];
          v27 = v10;
          if (v26 >= 1)
          {
            v28 = 0;
            v27 = v10;
            do
            {
              if (v28 >= a1[2])
                v29 = 43584;
              else
                v29 = 48496;
              v27 = (int *)((char *)v27 + v29);
              ++v28;
            }
            while (v26 != v28);
          }
          bzero(&v27[120 * *a1], 4 * *a1);
          v30 = a1[1];
          v31 = v10;
          if (v30 >= 1)
          {
            v32 = 0;
            v31 = v10;
            do
            {
              if (v32 >= a1[2])
                v33 = 43584;
              else
                v33 = 48496;
              v31 = (int *)((char *)v31 + v33);
              ++v32;
            }
            while (v30 != v32);
          }
          bzero(v31, 480 * *a1);
        }
        if (a1[1] < 1)
          return 0;
        v34 = 0;
        do
        {
          v35 = a1[2];
          result = opus_encoder_ctl(v10, 4028, a3, a4, a5, a6, a7, a8, v51);
          if ((_DWORD)result)
            break;
          v36 = v34 >= v35 ? 43584 : 48496;
          v10 = (int *)((char *)v10 + v36);
          ++v34;
        }
        while (v34 < a1[1]);
        return result;
      case 4031:
        v37 = v53;
        v53 += 2;
        v38 = *(_DWORD **)v37;
        v52 = 0;
        if (!v38)
          return 0xFFFFFFFFLL;
        *v38 = 0;
        if (a1[1] < 1)
          return 0;
        v39 = 0;
        break;
      case 4040:
        result = 0;
        v42 = v53;
        v53 += 2;
        a1[70] = *v42;
        return result;
      case 4041:
        v43 = v53;
        v53 += 2;
        v44 = *(_DWORD **)v43;
        if (!v44)
          return 0xFFFFFFFFLL;
        result = 0;
        *v44 = a1[70];
        return result;
      default:
        return result;
    }
    while (1)
    {
      v40 = a1[2];
      result = opus_encoder_ctl(v10, 4031, a3, a4, a5, a6, a7, a8, (uint64_t)&v52);
      if ((_DWORD)result)
        break;
      if (v39 >= v40)
        v41 = 43584;
      else
        v41 = 48496;
      v10 = (int *)((char *)v10 + v41);
      *v38 ^= v52;
      if (++v39 >= a1[1])
        return 0;
    }
  }
  return result;
}

uint64_t opus_multistream_encoder_ctl(int *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return opus_multistream_encoder_ctl_va_list(a1, a2, (uint64_t)&a9, a4, a5, a6, a7, a8);
}

void pitch_downsample(float **a1, char *a2, int a3, int a4)
{
  uint64_t v6;
  float *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const float *v13;
  float32x4_t *v14;
  float32x4_t v19;
  const float *v20;
  unsigned __int128 v21;
  const float *v22;
  unsigned __int128 v23;
  const float *v24;
  uint64_t v25;
  float *v26;
  float *v27;
  float v28;
  float *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const float *v34;
  float32x4_t *v35;
  float32x4_t v37;
  const float *v38;
  unsigned __int128 v39;
  const float *v40;
  unsigned __int128 v41;
  const float *v42;
  float32x4_t v43;
  uint64_t v44;
  float *v45;
  float *v46;
  int32x2_t v47;
  int32x2_t v48;
  int32x2_t v49;
  int32x2_t v50;
  int32x2_t v51;
  uint64_t v52;
  float v53;
  int8x16_t v54;
  float v55;
  float v56;
  float v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t *v62;
  int8x16_t v63;
  uint64_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x16_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  uint64_t v80;
  float *v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float32x4_t v88;
  uint64_t v89;
  float32x4x2_t v90;
  float32x4x2_t v91;
  float32x4x2_t v92;
  float32x4x2_t v93;

  v89 = *MEMORY[0x24BDAC8D0];
  v6 = (a3 >> 1);
  v7 = *a1;
  if (a3 >= 4)
  {
    if ((int)v6 <= 2)
      v8 = 2;
    else
      v8 = v6;
    if (v8 >= 0xA
      && (a2 + 4 < (char *)&v7[2 * v8] ? (_CF = v7 + 1 >= (float *)&a2[4 * v8]) : (_CF = 1), _CF))
    {
      v10 = (v8 - 1) & 7;
      if (!v10)
        v10 = 8;
      v11 = v8 - 1 - v10;
      v12 = v11 + 1;
      v13 = v7 + 10;
      v14 = (float32x4_t *)(a2 + 20);
      __asm { FMOV            V0.4S, #0.25 }
      v19.i64[0] = 0x3F0000003F000000;
      v19.i64[1] = 0x3F0000003F000000;
      do
      {
        v20 = v13 - 9;
        v21 = (unsigned __int128)vld2q_f32(v20);
        v22 = v13 - 1;
        v23 = (unsigned __int128)vld2q_f32(v22);
        v24 = v13 - 8;
        v90 = vld2q_f32(v24);
        v91 = vld2q_f32(v13);
        v14[-1] = vmlaq_f32(vmlaq_f32(vmulq_f32(v90.val[1], _Q0), _Q0, (float32x4_t)v21), v19, v90.val[0]);
        *v14 = vmlaq_f32(vmlaq_f32(vmulq_f32(v91.val[1], _Q0), _Q0, (float32x4_t)v23), v19, v91.val[0]);
        v13 += 16;
        v14 += 2;
        v11 -= 8;
      }
      while (v11);
    }
    else
    {
      v12 = 1;
    }
    v25 = v8 - v12;
    v26 = (float *)&a2[4 * v12];
    v27 = &v7[2 * v12];
    do
    {
      *v26++ = (float)((float)(v27[1] * 0.25) + (float)(*(v27 - 1) * 0.25)) + (float)(*v27 * 0.5);
      v27 += 2;
      --v25;
    }
    while (v25);
  }
  v28 = (float)(*v7 * 0.5) + (float)(v7[1] * 0.25);
  *(float *)a2 = v28;
  if (a4 == 2)
  {
    v29 = a1[1];
    if (a3 >= 4)
    {
      if ((int)v6 <= 2)
        v30 = 2;
      else
        v30 = v6;
      if (v30 >= 0xA && (a2 + 4 >= (char *)&v29[2 * v30] || v29 + 1 >= (float *)&a2[4 * v30]))
      {
        v32 = (v30 - 1) & 7;
        if (!v32)
          v32 = 8;
        v33 = v30 - 1 - v32;
        v31 = v33 + 1;
        v34 = v29 + 10;
        v35 = (float32x4_t *)(a2 + 20);
        __asm { FMOV            V1.4S, #0.25 }
        v37.i64[0] = 0x3F0000003F000000;
        v37.i64[1] = 0x3F0000003F000000;
        do
        {
          v38 = v34 - 9;
          v39 = (unsigned __int128)vld2q_f32(v38);
          v40 = v34 - 1;
          v41 = (unsigned __int128)vld2q_f32(v40);
          v42 = v34 - 8;
          v92 = vld2q_f32(v42);
          v93 = vld2q_f32(v34);
          v43 = vaddq_f32(*v35, vmlaq_f32(vmlaq_f32(vmulq_f32(v93.val[1], _Q1), _Q1, (float32x4_t)v41), v37, v93.val[0]));
          v35[-1] = vaddq_f32(v35[-1], vmlaq_f32(vmlaq_f32(vmulq_f32(v92.val[1], _Q1), _Q1, (float32x4_t)v39), v37, v92.val[0]));
          *v35 = v43;
          v34 += 16;
          v35 += 2;
          v33 -= 8;
        }
        while (v33);
      }
      else
      {
        v31 = 1;
      }
      v44 = v30 - v31;
      v45 = (float *)&a2[4 * v31];
      v46 = &v29[2 * v31];
      do
      {
        *v45 = *v45 + (float)((float)((float)(v46[1] * 0.25) + (float)(*(v46 - 1) * 0.25)) + (float)(*v46 * 0.5));
        ++v45;
        v46 += 2;
        --v44;
      }
      while (v44);
    }
    *(float *)a2 = v28 + (float)((float)(*v29 * 0.5) + (float)(v29[1] * 0.25));
  }
  _celt_autocorr(a2, &v87, 0, 0, 4, v6);
  v87 = v87 * 1.0001;
  v88 = vmlaq_f32(v88, (float32x4_t)xmmword_208F38570, vmulq_f32(v88, (float32x4_t)xmmword_208F38560));
  _celt_lpc(&v83, &v87, 4);
  if (a3 >= 2)
  {
    *(float *)v47.i32 = (float)(v83 * 0.9) + 0.8;
    *(float *)v48.i32 = (float)(v84 * 0.81) + (float)((float)(v83 * 0.9) * 0.8);
    *(float *)v49.i32 = (float)(v85 * 0.729) + (float)((float)(v84 * 0.81) * 0.8);
    *(float *)v50.i32 = (float)(v86 * 0.6561) + (float)((float)(v85 * 0.729) * 0.8);
    *(float *)v51.i32 = (float)(v86 * 0.6561) * 0.8;
    if (a3 < 0x10)
    {
      v52 = 0;
      v53 = 0.0;
      v54.i32[0] = 0;
      v55 = 0.0;
      v56 = 0.0;
      v57 = 0.0;
      goto LABEL_42;
    }
    v58 = (float32x4_t)vdupq_lane_s32(v47, 0);
    v59 = (float32x4_t)vdupq_lane_s32(v48, 0);
    v60 = (float32x4_t)vdupq_lane_s32(v49, 0);
    v52 = v6 & 0xFFFFFFF8;
    v61 = (float32x4_t)vdupq_lane_s32(v50, 0);
    v62 = (int8x16_t *)(a2 + 16);
    v63 = 0uLL;
    v64 = v52;
    v65 = (float32x4_t)vdupq_lane_s32(v51, 0);
    v66 = 0uLL;
    v67 = 0uLL;
    v68 = 0uLL;
    v54 = 0uLL;
    do
    {
      v69 = (float32x4_t)v62[-1];
      v70 = (float32x4_t)vextq_s8(v54, (int8x16_t)v69, 0xCuLL);
      v54 = *v62;
      v71 = (float32x4_t)vextq_s8(v68, (int8x16_t)v70, 0xCuLL);
      v72 = (float32x4_t)vextq_s8((int8x16_t)v69, *v62, 0xCuLL);
      v73 = (float32x4_t)vextq_s8(v67, (int8x16_t)v71, 0xCuLL);
      v74 = (float32x4_t)vextq_s8((int8x16_t)v70, (int8x16_t)v72, 0xCuLL);
      v75 = (float32x4_t)vextq_s8(v66, (int8x16_t)v73, 0xCuLL);
      v76 = (float32x4_t)vextq_s8((int8x16_t)v71, (int8x16_t)v74, 0xCuLL);
      v77 = (float32x4_t)vextq_s8((int8x16_t)v73, (int8x16_t)v76, 0xCuLL);
      v78 = vmlaq_f32(v69, v70, v58);
      v79 = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(*(float32x4_t *)v62, v72, v58), v74, v59), v76, v60), v77, v61), (float32x4_t)vextq_s8((int8x16_t)v75, (int8x16_t)v77, 0xCuLL), v65);
      v62[-1] = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(v78, v71, v59), v73, v60), v75, v61), (float32x4_t)vextq_s8(v63, (int8x16_t)v75, 0xCuLL), v65);
      *v62 = (int8x16_t)v79;
      v62 += 2;
      v63 = (int8x16_t)v77;
      v66 = (int8x16_t)v76;
      v67 = (int8x16_t)v74;
      v68 = (int8x16_t)v72;
      v64 -= 8;
    }
    while (v64);
    if (v52 != v6)
    {
      v53 = v69.f32[3];
      v55 = *(float *)&v54.i32[1];
      v57 = *(float *)&v54.i32[3];
      v56 = *(float *)&v54.i32[2];
LABEL_42:
      v80 = v6 - v52;
      v81 = (float *)&a2[4 * v52];
      do
      {
        v82 = *v81;
        *v81 = (float)((float)((float)((float)(*v81 + (float)(*(float *)v47.i32 * v57))
                                     + (float)(*(float *)v48.i32 * v56))
                             + (float)(*(float *)v49.i32 * v55))
                     + (float)(*(float *)v50.i32 * *(float *)v54.i32))
             + (float)(*(float *)v51.i32 * v53);
        ++v81;
        v53 = *(float *)v54.i32;
        *(float *)v54.i32 = v55;
        v55 = v56;
        v56 = v57;
        v57 = v82;
        --v80;
      }
      while (v80);
    }
  }
}

void celt_pitch_xcorr_c(float *a1, const float *a2, float *a3, unsigned int a4, int a5)
{
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  signed int v16;
  float *v17;
  float v18;
  float v19;
  float *v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float *v26;
  float *v27;
  float *v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  unint64_t v44;
  uint64_t v45;
  float *v46;
  __int32 *v47;
  float32x4_t v48;
  float32x4_t v49;
  int8x16_t v50;
  float32x4_t v51;
  float32x4_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  BOOL v57;
  unint64_t v58;
  unint64_t v60;
  uint64_t v61;
  float *v62;
  const float *v63;
  uint64_t v64;
  float *v65;
  float *v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  uint64_t v74;
  float32x4_t *v75;
  float32x4_t *i;
  uint64_t v77;
  float v78;
  uint64_t v79;
  float32x4_t *v80;
  float32x4_t *v81;
  float32x4_t v82;
  float32x4_t v83;
  uint64_t v84;
  uint64_t v85;
  float *v86;
  float *v87;
  float v88;
  float v89;
  float v90;
  float32x4x4_t v91;
  float32x4x4_t v92;

  v10 = a5 - 4;
  if (a5 < 4)
  {
    LODWORD(v12) = 0;
    goto LABEL_46;
  }
  v11 = (a5 - 3);
  if ((int)a4 >= 4)
  {
    v12 = 0;
    v13 = a4 & 0xFFFFFFFC | 1;
    v14 = a4 & 0xFFFFFFFC | 2;
    v15 = (uint64_t)&a1[4 * ((a4 - 4) >> 2) + 5];
    while (1)
    {
      v16 = 0;
      v17 = (float *)&a2[v12];
      v18 = *v17;
      v19 = v17[1];
      v20 = v17 + 3;
      v21 = v17[2];
      v22 = 0.0;
      v23 = 0.0;
      v24 = 0.0;
      v25 = 0.0;
      v26 = a1;
      do
      {
        v27 = v20;
        v28 = v26;
        v29 = v26[1];
        v30 = v25 + (float)(*v26 * v18);
        v31 = *v20;
        v18 = v20[1];
        v32 = v30 + (float)(v29 * v19);
        v33 = (float)(v24 + (float)(*v26 * v19)) + (float)(v29 * v21);
        v34 = (float)(v23 + (float)(*v26 * v21)) + (float)(v29 * *v20);
        v35 = (float)(v22 + (float)(*v26 * *v20)) + (float)(v29 * v18);
        v36 = v26[2];
        v37 = v26[3];
        v38 = v32 + (float)(v36 * v21);
        v39 = v33 + (float)(v36 * *v20);
        v19 = v20[2];
        v21 = v20[3];
        v26 += 4;
        v20 += 4;
        v25 = v38 + (float)(v37 * v31);
        v24 = v39 + (float)(v37 * v18);
        v23 = (float)(v34 + (float)(v36 * v18)) + (float)(v37 * v19);
        v22 = (float)(v35 + (float)(v36 * v19)) + (float)(v37 * v21);
        v16 += 4;
      }
      while (v16 < (int)(a4 - 3));
      if ((a4 & 0xFFFFFFFC) < a4)
      {
        v40 = v28[4];
        ++v20;
        v31 = v27[4];
        v25 = v25 + (float)(v40 * v18);
        v24 = v24 + (float)(v40 * v19);
        v23 = v23 + (float)(v40 * v21);
        v22 = v22 + (float)(v40 * v31);
        v26 = (float *)v15;
        if (v13 >= a4)
        {
LABEL_9:
          if (v14 < a4)
            goto LABEL_13;
          goto LABEL_4;
        }
      }
      else if (v13 >= a4)
      {
        goto LABEL_9;
      }
      v41 = *v26++;
      v42 = v41;
      v43 = *v20++;
      v18 = v43;
      v25 = v25 + (float)(v42 * v19);
      v24 = v24 + (float)(v42 * v21);
      v23 = v23 + (float)(v42 * v31);
      v22 = v22 + (float)(v42 * v43);
      if (v14 < a4)
      {
LABEL_13:
        v25 = v25 + (float)(*v26 * v21);
        v24 = v24 + (float)(*v26 * v31);
        v23 = v23 + (float)(*v26 * v18);
        v22 = v22 + (float)(*v26 * *v20);
      }
LABEL_4:
      a3[v12] = v25;
      *(float *)((char *)a3 + ((4 * v12) | 4)) = v24;
      *(float *)((char *)a3 + ((4 * v12) | 8)) = v23;
      *(float *)((char *)a3 + ((4 * v12) | 0xC)) = v22;
      v12 += 4;
      if (v12 >= v11)
        goto LABEL_46;
    }
  }
  if ((int)a4 < 1)
  {
    bzero(a3, 16 * (v10 >> 2) + 16);
    LODWORD(v12) = (v10 & 0xFFFFFFFC) + 4;
    goto LABEL_46;
  }
  if (a4 != 1)
  {
    v12 = 0;
    v45 = 1;
    v46 = a3;
    do
    {
      v47 = (__int32 *)&a2[v12];
      v48 = *(float32x4_t *)&a2[v45];
      v49 = v48;
      v49.i32[3] = *v47;
      v50 = (int8x16_t)vmlaq_n_f32((float32x4_t)0, v49, *a1);
      v51 = vmlaq_n_f32((float32x4_t)vextq_s8(v50, v50, 0xCuLL), v48, a1[1]);
      if (a4 == 3)
      {
        v52 = (float32x4_t)vextq_s8((int8x16_t)v48, (int8x16_t)v51, 4uLL);
        v52.i32[3] = v47[5];
        v51 = vmlaq_n_f32(v51, v52, a1[2]);
      }
      *(float32x4_t *)v46 = v51;
      v46 += 4;
      v12 += 4;
      v45 += 4;
    }
    while (v12 < v11);
    goto LABEL_46;
  }
  if (v11 <= 4)
    v44 = 4;
  else
    v44 = (a5 - 3);
  if (v44 < 0x1D)
  {
    v12 = 0;
LABEL_44:
    v64 = 4 * v12 + 8;
    v65 = (float *)((char *)a2 + v64);
    v66 = (float *)((char *)a3 + v64);
    do
    {
      v67 = *(v65 - 2);
      v68 = *(v65 - 1);
      v69 = *v65;
      v70 = v65[1];
      v65 += 4;
      v71 = (float)(*a1 * v68) + 0.0;
      v72 = (float)(*a1 * v69) + 0.0;
      v73 = (float)(*a1 * v70) + 0.0;
      *(v66 - 2) = (float)(*a1 * v67) + 0.0;
      *(v66 - 1) = v71;
      *v66 = v72;
      v66[1] = v73;
      v66 += 4;
      v12 += 4;
    }
    while (v12 < v11);
    goto LABEL_46;
  }
  v12 = 0;
  v53 = 4;
  if (v11 > 4)
    v53 = (a5 - 3);
  v54 = ((4 * v53 - 4) & 0xFFFFFFFFFFFFFFF0) + 16;
  v55 = (char *)a3 + v54;
  v57 = a1 + 1 > a3 && v55 > (char *)a1;
  v58 = (unint64_t)a2 + v54;
  if (v55 > (char *)a2 && v58 > (unint64_t)a3)
    goto LABEL_44;
  if (v57)
    goto LABEL_44;
  v60 = ((v44 - 1) >> 2) + 1;
  v12 = 4 * (v60 & 0x7FFFFFFFFFFFFFFCLL);
  v61 = v60 & 0x7FFFFFFFFFFFFFFCLL;
  v62 = a3;
  v63 = a2;
  do
  {
    v91 = vld4q_f32(v63);
    v63 += 16;
    v92.val[0] = vmlaq_n_f32((float32x4_t)0, v91.val[0], *a1);
    v92.val[1] = vmlaq_n_f32((float32x4_t)0, v91.val[1], *a1);
    v92.val[2] = vmlaq_n_f32((float32x4_t)0, v91.val[2], *a1);
    v92.val[3] = vmlaq_n_f32((float32x4_t)0, v91.val[3], *a1);
    vst4q_f32(v62, v92);
    v62 += 16;
    v61 -= 4;
  }
  while (v61);
  if (v60 != (v60 & 0x7FFFFFFFFFFFFFFCLL))
    goto LABEL_44;
LABEL_46:
  if ((int)v12 < a5)
  {
    v74 = v12;
    if ((int)a4 >= 1)
    {
      v75 = (float32x4_t *)&a2[v12];
      for (i = v75 + 1; ; i = (float32x4_t *)((char *)i + 4))
      {
        if (a4 >= 8)
        {
          v78 = 0.0;
          v79 = a4 & 0xFFFFFFF8;
          v80 = i;
          v81 = (float32x4_t *)(a1 + 4);
          do
          {
            v82 = vmulq_f32(v81[-1], v80[-1]);
            v83 = vmulq_f32(*v81, *v80);
            v78 = (float)((float)((float)((float)((float)((float)((float)(v78 + v82.f32[0]) + v82.f32[1]) + v82.f32[2])
                                                + v82.f32[3])
                                        + v83.f32[0])
                                + v83.f32[1])
                        + v83.f32[2])
                + v83.f32[3];
            v81 += 2;
            v80 += 2;
            v79 -= 8;
          }
          while (v79);
          v77 = a4 & 0xFFFFFFF8;
          if (v77 == a4)
            goto LABEL_49;
        }
        else
        {
          v77 = 0;
          v78 = 0.0;
        }
        v84 = a4 - v77;
        v85 = v77;
        v86 = &v75->f32[v77];
        v87 = &a1[v85];
        do
        {
          v88 = *v87++;
          v89 = v88;
          v90 = *v86++;
          v78 = v78 + (float)(v89 * v90);
          --v84;
        }
        while (v84);
LABEL_49:
        a3[v74++] = v78;
        v75 = (float32x4_t *)((char *)v75 + 4);
        if ((int)v74 >= a5)
          return;
      }
    }
    bzero(&a3[v12], 4 * (~(_DWORD)v12 + a5) + 4);
  }
}

void pitch_search(float32x4_t *a1, float32x4_t *a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const float *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  int v20;
  int v21;
  uint64_t v22;
  float *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const float *f32;
  unsigned __int128 *v29;
  uint64_t v30;
  const float *v31;
  unsigned __int128 v32;
  unsigned __int128 v33;
  uint64_t v34;
  float *v35;
  __int32 *v36;
  __int32 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const float *v41;
  unsigned __int128 *v42;
  uint64_t v43;
  const float *v44;
  unsigned __int128 v45;
  unsigned __int128 v46;
  uint64_t v47;
  float *v48;
  __int32 *v49;
  int v50;
  float v51;
  uint64_t v52;
  float *v53;
  uint64_t v54;
  uint64_t v55;
  float *v56;
  float v57;
  int v58;
  int v59;
  uint64_t v60;
  float v61;
  float v62;
  int v63;
  float v64;
  float v65;
  float v66;
  float v67;
  BOOL v68;
  BOOL v69;
  uint64_t v70;
  int v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  float32x4_t *v75;
  float32x4_t *v76;
  float v77;
  unsigned int v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  float32x4_t *v82;
  float32x4_t *v83;
  float32x4_t v84;
  float32x4_t v85;
  uint64_t v86;
  uint64_t v87;
  float *v88;
  float *v89;
  float v90;
  float v91;
  float v92;
  float v93;
  uint64_t v94;
  float *v95;
  uint64_t v96;
  uint64_t v97;
  float *v98;
  float v99;
  int v100;
  uint64_t v101;
  float v102;
  float v103;
  uint64_t v104;
  float v105;
  float v106;
  float v107;
  float v108;
  BOOL v110;
  int v111;
  float v112;
  float v113;
  float v114;
  _QWORD v115[2];

  v115[1] = *MEMORY[0x24BDAC8D0];
  v10 = (a3 >> 2);
  MEMORY[0x24BDAC7A8](a1, a2);
  v13 = MEMORY[0x24BDAC7A8]((char *)v115 - v11, v12);
  v15 = (const float *)((char *)v115 - v14);
  v17 = (v16 >> 1);
  v19 = (float *)MEMORY[0x24BDAC7A8](v13, v18);
  v23 = (float *)((char *)v115 - v22);
  if (v24 >= 4)
  {
    if ((int)v10 <= 1)
      v25 = 1;
    else
      v25 = v10;
    if (v25 > 8)
    {
      v27 = v25 & 7;
      if ((v25 & 7) == 0)
        v27 = 8;
      v26 = v25 - v27;
      f32 = a1[2].f32;
      v29 = (unsigned __int128 *)(v19 + 4);
      v30 = v26;
      do
      {
        v31 = f32 - 8;
        v32 = (unsigned __int128)vld2q_f32(v31);
        v33 = (unsigned __int128)vld2q_f32(f32);
        *(v29 - 1) = v32;
        *v29 = v33;
        f32 += 16;
        v29 += 2;
        v30 -= 8;
      }
      while (v30);
    }
    else
    {
      v26 = 0;
    }
    v34 = v25 - v26;
    v35 = &v19[v26];
    v36 = (__int32 *)a1 + 2 * v26;
    do
    {
      v37 = *v36;
      v36 += 2;
      *(_DWORD *)v35++ = v37;
      --v34;
    }
    while (v34);
  }
  if (v20 >= 4)
  {
    if (v21 <= 1)
      v38 = 1;
    else
      v38 = v21;
    if (v38 > 8)
    {
      v40 = v38 & 7;
      if ((v38 & 7) == 0)
        v40 = 8;
      v39 = v38 - v40;
      v41 = a2[2].f32;
      v42 = (unsigned __int128 *)(v15 + 4);
      v43 = v39;
      do
      {
        v44 = v41 - 8;
        v45 = (unsigned __int128)vld2q_f32(v44);
        v46 = (unsigned __int128)vld2q_f32(v41);
        *(v42 - 1) = v45;
        *v42 = v46;
        v41 += 16;
        v42 += 2;
        v43 -= 8;
      }
      while (v43);
    }
    else
    {
      v39 = 0;
    }
    v47 = v38 - v39;
    v48 = (float *)&v15[v39];
    v49 = (__int32 *)a2 + 2 * v39;
    do
    {
      v50 = *v49;
      v49 += 2;
      *(_DWORD *)v48++ = v50;
      --v47;
    }
    while (v47);
  }
  celt_pitch_xcorr_c(v19, v15, v23, v10, a4 >> 2);
  v51 = 1.0;
  if (a3 >= 4)
  {
    if (a3 < 8)
    {
      v52 = 0;
LABEL_31:
      v55 = v10 - v52;
      v56 = (float *)&v15[v52];
      do
      {
        v57 = *v56++;
        v51 = v51 + (float)(v57 * v57);
        --v55;
      }
      while (v55);
      goto LABEL_33;
    }
    v52 = v10 & 0xFFFFFFFE;
    v53 = (float *)(v15 + 1);
    v54 = v52;
    do
    {
      v51 = (float)(v51 + (float)(*(v53 - 1) * *(v53 - 1))) + (float)(*v53 * *v53);
      v53 += 2;
      v54 -= 2;
    }
    while (v54);
    if (v52 != v10)
      goto LABEL_31;
  }
LABEL_33:
  if (a4 < 4)
  {
    v58 = 0;
    v63 = 1;
  }
  else
  {
    v58 = 0;
    v59 = 0;
    v60 = 0;
    v61 = -1.0;
    v62 = 0.0;
    v63 = 1;
    v64 = 0.0;
    v65 = -1.0;
    do
    {
      v66 = v23[v60];
      v68 = v66 <= 0.0;
      v67 = (float)(v66 * 1.0e-12) * (float)(v66 * 1.0e-12);
      v68 = v68 || (float)(v64 * v67) <= (float)(v65 * v51);
      if (!v68)
      {
        v69 = (float)(v62 * v67) <= (float)(v61 * v51);
        v63 = (float)(v62 * v67) <= (float)(v61 * v51) ? v60 : v59;
        if ((float)(v62 * v67) <= (float)(v61 * v51))
        {
          v65 = v67;
        }
        else
        {
          v58 = v60;
          v59 = v60;
          v65 = v61;
        }
        if ((float)(v62 * v67) <= (float)(v61 * v51))
        {
          v64 = v51;
        }
        else
        {
          v61 = v67;
          v64 = v62;
        }
        if (!v69)
          v62 = v51;
      }
      v51 = v51 + (float)((float)(v15[(int)v10 + v60] * v15[(int)v10 + v60]) - (float)(v15[v60] * v15[v60]));
      if (v51 < 1.0)
        v51 = 1.0;
      ++v60;
    }
    while (a4 >> 2 != v60);
  }
  if (a4 > 1)
  {
    v70 = 0;
    v71 = 2 * v58;
    v72 = 2 * v63;
    v73 = (a3 >> 1);
    if ((int)v17 <= 1)
      v74 = 1;
    else
      v74 = v17;
    v75 = a2 + 1;
    v76 = a2;
    while (1)
    {
      v23[v70] = 0.0;
      v78 = v70 - v71;
      if ((int)v70 - v71 < 0)
        v78 = v71 - v70;
      if (v78 >= 3)
      {
        v79 = v70 - v72;
        if ((int)v70 - v72 < 0)
          v79 = v72 - v70;
        if (v79 > 2)
          goto LABEL_63;
      }
      v77 = 0.0;
      if (a3 >= 2)
      {
        if (a3 >= 0x10)
        {
          v81 = v73 & 0xFFFFFFF8;
          v82 = v75;
          v83 = a1 + 1;
          do
          {
            v84 = vmulq_f32(v83[-1], v82[-1]);
            v85 = vmulq_f32(*v83, *v82);
            v77 = (float)((float)((float)((float)((float)((float)((float)(v77 + v84.f32[0]) + v84.f32[1]) + v84.f32[2])
                                                + v84.f32[3])
                                        + v85.f32[0])
                                + v85.f32[1])
                        + v85.f32[2])
                + v85.f32[3];
            v83 += 2;
            v82 += 2;
            v81 -= 8;
          }
          while (v81);
          v80 = v73 & 0xFFFFFFF8;
          if (v80 == v73)
            goto LABEL_60;
        }
        else
        {
          v80 = 0;
        }
        v86 = v73 - v80;
        v87 = v80;
        v88 = &v76->f32[v80];
        v89 = &a1->f32[v87];
        do
        {
          v90 = *v89++;
          v91 = v90;
          v92 = *v88++;
          v77 = v77 + (float)(v91 * v92);
          --v86;
        }
        while (v86);
      }
LABEL_60:
      if (v77 < -1.0)
        v77 = -1.0;
      v23[v70] = v77;
LABEL_63:
      ++v70;
      v75 = (float32x4_t *)((char *)v75 + 4);
      v76 = (float32x4_t *)((char *)v76 + 4);
      if (v70 == v74)
        goto LABEL_80;
    }
  }
  LODWORD(v73) = a3 >> 1;
LABEL_80:
  v93 = 1.0;
  if (a3 >= 2)
  {
    if (v73 < 2)
    {
      v94 = 0;
LABEL_86:
      v97 = v73 - v94;
      v98 = &a2->f32[v94];
      do
      {
        v99 = *v98++;
        v93 = v93 + (float)(v99 * v99);
        --v97;
      }
      while (v97);
      goto LABEL_88;
    }
    v94 = v73 & 0xFFFFFFFE;
    v95 = &a2->f32[1];
    v96 = v94;
    do
    {
      v93 = (float)(v93 + (float)(*(v95 - 1) * *(v95 - 1))) + (float)(*v95 * *v95);
      v95 += 2;
      v96 -= 2;
    }
    while (v96);
    if (v94 != v73)
      goto LABEL_86;
  }
LABEL_88:
  if (a4 < 2)
  {
    v100 = 0;
    v111 = 0;
  }
  else
  {
    v100 = 0;
    v101 = 0;
    v102 = -1.0;
    v103 = 0.0;
    v104 = (uint64_t)a2->i64 + 4 * (int)v73;
    v105 = 0.0;
    v106 = -1.0;
    do
    {
      v107 = v23[v101];
      v68 = v107 <= 0.0;
      v108 = (float)(v107 * 1.0e-12) * (float)(v107 * 1.0e-12);
      if (!v68 && (float)(v105 * v108) > (float)(v106 * v93))
      {
        v110 = (float)(v103 * v108) <= (float)(v102 * v93);
        if ((float)(v103 * v108) <= (float)(v102 * v93))
        {
          v106 = v108;
        }
        else
        {
          v100 = v101;
          v106 = v102;
        }
        if ((float)(v103 * v108) <= (float)(v102 * v93))
        {
          v105 = v93;
        }
        else
        {
          v102 = v108;
          v105 = v103;
        }
        if (!v110)
          v103 = v93;
      }
      v93 = v93
          + (float)((float)(*(float *)(v104 + 4 * v101) * *(float *)(v104 + 4 * v101))
                  - (float)(a2->f32[v101] * a2->f32[v101]));
      if (v93 < 1.0)
        v93 = 1.0;
      ++v101;
    }
    while (v17 != v101);
    v111 = 0;
    if (v100 >= 1 && v100 < (int)v17 - 1)
    {
      v112 = v23[v100 - 1];
      v113 = v23[v100];
      v114 = v23[v100 + 1];
      if ((float)(v114 - v112) <= (float)((float)(v113 - v112) * 0.7))
        v111 = (float)(v112 - v114) > (float)((float)(v113 - v114) * 0.7);
      else
        v111 = -1;
    }
  }
  *a5 = v111 + 2 * v100;
}

uint64_t remove_doubling(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  float v16;
  uint64_t v17;
  float *v18;
  float v19;
  float v20;
  uint64_t v21;
  float *v22;
  uint64_t v23;
  float v24;
  uint64_t v25;
  float *v26;
  int v27;
  float *v28;
  uint64_t v29;
  float *v30;
  float *v31;
  float v32;
  float v33;
  int v34;
  float v35;
  int v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  signed int v40;
  signed int v41;
  signed int v42;
  float v43;
  float *v44;
  uint64_t v45;
  float v46;
  float v47;
  unsigned int v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  uint64_t v57;
  uint64_t v58;
  float32x4_t *v59;
  uint64_t v60;
  float32x4_t v61;
  float32x4_t v62;
  uint64_t v63;
  uint64_t v64;
  float *v65;
  uint64_t v66;
  float32x4_t *v67;
  uint64_t v68;
  float32x4_t v69;
  float32x4_t v70;
  uint64_t v71;
  float *v72;
  uint64_t v73;
  uint64_t v74;
  float32x4_t *v75;
  uint64_t v76;
  float32x4_t v77;
  float32x4_t v78;
  uint64_t v79;
  uint64_t v80;
  float *v81;
  int v82;
  int v83;
  _QWORD v84[2];

  v84[1] = *MEMORY[0x24BDAC8D0];
  v84[0] = a5;
  result = MEMORY[0x24BDAC7A8]();
  v18 = (float *)((char *)v84 - v17);
  v19 = 0.0;
  v20 = 0.0;
  if (v8 < 2)
    goto LABEL_9;
  if (v12 >= 2)
  {
    v21 = v12 & 0xFFFFFFFE;
    v22 = (float *)(result + 4 * v9 + 4);
    v23 = v21;
    do
    {
      v24 = *(v22 - 1);
      v20 = (float)(v20 + (float)(v24 * v22[-v13 - 1])) + (float)(*v22 * v22[-v13]);
      v19 = (float)(v19 + (float)(v24 * v24)) + (float)(*v22 * *v22);
      v22 += 2;
      v23 -= 2;
    }
    while (v23);
    if (v21 == v12)
      goto LABEL_9;
  }
  else
  {
    v21 = 0;
  }
  v25 = v12 - v21;
  v26 = (float *)(result + 4 * v21 + 4 * v9);
  do
  {
    v19 = v19 + (float)(*v26 * *v26);
    v20 = v20 + (float)(*v26 * v26[-v13]);
    ++v26;
    --v25;
  }
  while (v25);
LABEL_9:
  v27 = v11 >> 1;
  *v18 = v19;
  v28 = (float *)(result + 4 * v14);
  if (v6 >= 2)
  {
    v29 = v10 - 1;
    v30 = v18 + 1;
    v31 = (float *)(result + 4 * v9 - 4);
    v32 = v19;
    do
    {
      v32 = (float)(v32 + (float)(*v31 * *v31)) - (float)(v31[(int)v12] * v31[(int)v12]);
      if (v32 >= 0.0)
        v33 = v32;
      else
        v33 = 0.0;
      *v30++ = v33;
      --v31;
      --v29;
    }
    while (v29);
  }
  v34 = -(v15 >> 1);
  v35 = v20 / sqrtf((float)(v19 * v18[v13]) + 1.0);
  v36 = 2 * v13;
  LODWORD(v37) = 2 * v13 + 2;
  v38 = 2;
  v39 = 4;
  v40 = v13;
  do
  {
    v41 = (v36 + (int)v38) / (2 * v38);
    if (v41 < v27)
      break;
    if (v38 == 2)
    {
      if (v41 + v13 <= (int)v9)
        v42 = v41 + v13;
      else
        v42 = v13;
      v37 = v37;
      v43 = 0.0;
      if (v8 < 2)
        goto LABEL_28;
LABEL_25:
      v44 = v28;
      v45 = v12;
      v46 = 0.0;
      do
      {
        v46 = v46 + (float)(*v44 * v44[-(v37 / v39)]);
        v43 = v43 + (float)(*v44 * v44[-v42]);
        ++v44;
        --v45;
      }
      while (v45);
      v43 = v46 + v43;
      goto LABEL_28;
    }
    v42 = ((int)v38 + second_check[v38] * v36) / (2 * v38);
    v37 = v37;
    v43 = 0.0;
    if (v8 >= 2)
      goto LABEL_25;
LABEL_28:
    v47 = (float)(v43 * 0.5) / sqrtf((float)(v19 * (float)((float)(v18[v41] + v18[v42]) * 0.5)) + 1.0);
    v48 = v41 + v34;
    if (v41 + v34 < 0)
      v48 = -v48;
    if (5 * (int)v38 * (int)v38 >= v13)
      v49 = 0.0;
    else
      v49 = v16 * 0.5;
    if (v48 != 2)
      v49 = 0.0;
    if (v48 < 2)
      v49 = v16;
    v50 = -v49;
    v51 = v50 + (float)(v35 * 0.7);
    if (v51 < 0.3)
      v51 = 0.3;
    v52 = v50 + (float)(v35 * 0.9);
    if (v52 < 0.5)
      v52 = 0.5;
    if (v41 < 2 * v27)
      v51 = v52;
    v53 = v50 + (float)(v35 * 0.85);
    if (v53 < 0.4)
      v53 = 0.4;
    if (v41 >= 3 * v27)
      v53 = v51;
    if (v47 > v53)
      v40 = (v36 + (int)v38) / (2 * v38);
    ++v38;
    LODWORD(v37) = v37 + 1;
    v39 += 2;
  }
  while (v38 != 16);
  v54 = 0.0;
  v55 = 0.0;
  v56 = 0.0;
  if (v8 >= 2)
  {
    v57 = v40 - 1;
    if (v12 < 8)
    {
      v58 = 0;
      goto LABEL_55;
    }
    v58 = v12 & 0xFFFFFFF8;
    v59 = (float32x4_t *)(result + 4 * v9 + 16);
    v60 = v58;
    do
    {
      v61 = vmulq_f32(v59[-1], *(float32x4_t *)((char *)v59 - 4 * v57 - 16));
      v62 = vmulq_f32(*v59, *(float32x4_t *)((char *)v59 - 4 * v57));
      v54 = (float)((float)((float)((float)((float)((float)((float)(v54 + v61.f32[0]) + v61.f32[1]) + v61.f32[2])
                                          + v61.f32[3])
                                  + v62.f32[0])
                          + v62.f32[1])
                  + v62.f32[2])
          + v62.f32[3];
      v59 += 2;
      v60 -= 8;
    }
    while (v60);
    if (v58 != v12)
    {
LABEL_55:
      v63 = v12 - v58;
      v64 = -1 * v57;
      v65 = (float *)(result + 4 * v58 + 4 * v9);
      do
      {
        v54 = v54 + (float)(*v65 * v65[v64]);
        ++v65;
        --v63;
      }
      while (v63);
    }
    if (v12 < 8)
    {
      v66 = 0;
      v55 = 0.0;
      goto LABEL_62;
    }
    v66 = v12 & 0xFFFFFFF8;
    v67 = (float32x4_t *)(result + 4 * v9 + 16);
    v55 = 0.0;
    v68 = v66;
    do
    {
      v69 = vmulq_f32(v67[-1], *(float32x4_t *)((char *)v67 - 4 * v40 - 16));
      v70 = vmulq_f32(*v67, *(float32x4_t *)((char *)v67 - 4 * v40));
      v55 = (float)((float)((float)((float)((float)((float)((float)(v55 + v69.f32[0]) + v69.f32[1]) + v69.f32[2])
                                          + v69.f32[3])
                                  + v70.f32[0])
                          + v70.f32[1])
                  + v70.f32[2])
          + v70.f32[3];
      v67 += 2;
      v68 -= 8;
    }
    while (v68);
    if (v66 != v12)
    {
LABEL_62:
      v71 = v12 - v66;
      v72 = (float *)(result + 4 * v66 + 4 * v9);
      do
      {
        v55 = v55 + (float)(*v72 * v72[-v40]);
        ++v72;
        --v71;
      }
      while (v71);
    }
    v73 = v40 + 1;
    if (v12 < 8)
    {
      v74 = 0;
      v56 = 0.0;
      goto LABEL_69;
    }
    v74 = v12 & 0xFFFFFFF8;
    v75 = (float32x4_t *)(result + 4 * v9 + 16);
    v56 = 0.0;
    v76 = v74;
    do
    {
      v77 = vmulq_f32(v75[-1], *(float32x4_t *)((char *)v75 - 4 * v73 - 16));
      v78 = vmulq_f32(*v75, *(float32x4_t *)((char *)v75 - 4 * v73));
      v56 = (float)((float)((float)((float)((float)((float)((float)(v56 + v77.f32[0]) + v77.f32[1]) + v77.f32[2])
                                          + v77.f32[3])
                                  + v78.f32[0])
                          + v78.f32[1])
                  + v78.f32[2])
          + v78.f32[3];
      v75 += 2;
      v76 -= 8;
    }
    while (v76);
    if (v74 != v12)
    {
LABEL_69:
      v79 = v12 - v74;
      v80 = -1 * v73;
      v81 = (float *)(result + 4 * v74 + 4 * v9);
      do
      {
        v56 = v56 + (float)(*v81 * v81[v80]);
        ++v81;
        --v79;
      }
      while (v79);
    }
  }
  if ((float)(v56 - v54) <= (float)((float)(v55 - v54) * 0.7))
  {
    if ((float)(v54 - v56) <= (float)((float)(v55 - v56) * 0.7))
      v82 = 0;
    else
      v82 = -1;
  }
  else
  {
    v82 = 1;
  }
  v83 = v82 + 2 * v40;
  if (v83 <= v7)
    v83 = v7;
  *(_DWORD *)v84[0] = v83;
  return result;
}

uint64_t silk_pitch_analysis_core_FLP(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9;
  int v10;
  __n128 v11;
  int v12;
  int v13;
  int v14;
  float *v15;
  _WORD *v16;
  _BYTE *v17;
  float v18;
  float v19;
  float v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  __int16 *v32;
  __int16 *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  int v38;
  int v39;
  __int16 v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE *v48;
  int8x16_t v49;
  int16x8_t v50;
  int8x16_t v51;
  int16x8_t v52;
  int32x4_t v53;
  _BYTE *v54;
  int8x16_t v55;
  int8x16_t v56;
  int8x16_t v57;
  int8x16_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _BYTE *v66;
  int8x16_t v67;
  int16x8_t v68;
  int8x16_t v69;
  int16x8_t v70;
  int32x4_t v71;
  _BYTE *v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t v75;
  int8x16_t v76;
  unint64_t v77;
  unint64_t v78;
  unsigned int v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  __int16 *v83;
  __int16 *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  int v89;
  int v90;
  __int16 v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  _WORD *v97;
  int8x16_t v98;
  int16x8_t v99;
  int8x16_t v100;
  int16x8_t v101;
  int32x4_t v102;
  _BYTE *v103;
  int8x16_t v104;
  int8x16_t v105;
  int8x16_t v106;
  int8x16_t v107;
  unint64_t v108;
  float *v109;
  int v110;
  float v111;
  float v112;
  int v113;
  float *v114;
  int *v115;
  uint64_t v116;
  double v117;
  double v118;
  double v119;
  double v120;
  double v121;
  double v122;
  double v123;
  double v124;
  double v125;
  double v126;
  float *v127;
  float v128;
  int8x16_t v129;
  float32x4_t v130;
  int8x16_t v131;
  float32x4_t v132;
  float32x4_t v133;
  int8x16_t v134;
  int8x16_t v135;
  int8x16_t v136;
  float32x4_t v137;
  int8x16_t v138;
  float32x4_t v139;
  int8x16_t v140;
  int8x16_t v141;
  int8x16_t v142;
  float32x4_t v143;
  int8x16_t v144;
  float32x4_t v145;
  int8x16_t v146;
  int8x16_t v147;
  int8x16_t v148;
  float32x4_t v149;
  int8x16_t v150;
  float32x4_t v151;
  int8x16_t v152;
  int8x16_t v153;
  int8x16_t v154;
  float32x4_t v155;
  int8x16_t v156;
  float32x4_t v157;
  int8x16_t v158;
  int8x16_t v159;
  int8x16_t v160;
  float32x4_t v161;
  int8x16_t v162;
  float32x4_t v163;
  int8x16_t v164;
  int8x16_t v165;
  int8x16_t v166;
  float32x4_t v167;
  int8x16_t v168;
  float32x4_t v169;
  int8x16_t v170;
  int8x16_t v171;
  int8x16_t v172;
  float32x4_t v173;
  int8x16_t v174;
  float32x4_t v175;
  int8x16_t v176;
  int8x16_t v177;
  int v178;
  int v179;
  uint64_t result;
  uint64_t v181;
  float v182;
  uint64_t v183;
  uint64_t v184;
  unsigned int v185;
  __int32 *v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  __int32 *v190;
  uint64_t v191;
  uint64_t v192;
  int v193;
  int8x16_t v194;
  int8x16_t v195;
  int8x16_t v196;
  int8x16_t v197;
  int8x16_t v198;
  int8x16_t v199;
  int8x16_t v200;
  int8x16_t v201;
  int8x16_t v202;
  int8x16_t v203;
  int16x8_t v204;
  int8x16_t v205;
  int8x16_t v206;
  int8x16_t v207;
  int8x16_t v208;
  int8x16_t v209;
  int8x16_t v210;
  int16x8_t v211;
  int8x16_t v212;
  int8x16_t v213;
  int8x16_t v214;
  int8x16_t v215;
  int8x16_t v216;
  int8x16_t v217;
  int16x8_t v218;
  int8x16_t v219;
  int8x16_t v220;
  int8x16_t v221;
  int8x16_t v222;
  int8x16_t v223;
  int8x16_t v224;
  int16x8_t v225;
  int8x16_t v226;
  int8x16_t v227;
  int8x16_t v228;
  int8x16_t v229;
  int8x16_t v230;
  int8x16_t v231;
  int8x16_t v232;
  int8x16_t v233;
  int8x16_t v234;
  int8x16_t v235;
  int8x16_t v236;
  int8x16_t v237;
  int8x16_t v238;
  int8x16_t v239;
  int8x16_t v240;
  int8x16_t v241;
  int8x16_t v242;
  int8x16_t v243;
  int8x16_t v244;
  int8x16_t v245;
  uint64_t v246;
  __int16 v247;
  __int16 v248;
  __int16 v249;
  _WORD *v250;
  unint64_t v251;
  int v252;
  uint64_t i;
  uint64_t v254;
  float *v255;
  float v256;
  __int16 *v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  float *v261;
  double v262;
  double v263;
  double v264;
  double v265;
  double v266;
  double v267;
  double v268;
  double v269;
  double v270;
  double v271;
  double v272;
  double v273;
  double v274;
  double v275;
  double v276;
  double v277;
  double v278;
  double v279;
  double v280;
  double v281;
  double v282;
  double v283;
  double v284;
  double v285;
  double v286;
  double v287;
  double v288;
  double v289;
  double v290;
  double v291;
  float v292;
  int v293;
  float v294;
  char *v295;
  uint64_t v296;
  uint64_t v297;
  BOOL v298;
  BOOL v299;
  float v300;
  uint64_t v301;
  float v302;
  int v303;
  float v304;
  int v305;
  uint64_t v306;
  char *v307;
  float v308;
  _DWORD *v309;
  char *v310;
  uint64_t v311;
  uint64_t v312;
  int v313;
  float v314;
  float v315;
  float v316;
  int v318;
  unint64_t v319;
  int v320;
  int v321;
  int v322;
  int v323;
  int *v324;
  uint64_t v325;
  int v326;
  int v327;
  int *v328;
  char *v329;
  int v330;
  __int16 v331;
  int v332;
  int v333;
  int v334;
  char *v335;
  float *v336;
  int v337;
  int v338;
  uint64_t v339;
  _BYTE *v340;
  char *v341;
  int v342;
  uint64_t v343;
  uint64_t v344;
  int v345;
  uint64_t v346;
  char *v347;
  _BYTE *v348;
  uint64_t v349;
  float *v350;
  uint64_t v351;
  uint64_t v352;
  int8x16_t *v353;
  int32x4_t *v354;
  uint64_t v355;
  int8x16_t v356;
  int8x16_t v357;
  int *v358;
  uint64_t v359;
  _DWORD *v360;
  int v361;
  uint64_t v362;
  _BYTE *v363;
  char *v364;
  int v365;
  uint64_t v366;
  uint64_t v367;
  char *v368;
  int v369;
  uint64_t v370;
  int v371;
  uint64_t v372;
  unint64_t v373;
  int v374;
  unint64_t v375;
  unint64_t v376;
  uint64_t v377;
  int v378;
  uint64_t v379;
  uint64_t v380;
  _BYTE *v381;
  int v382;
  uint64_t v383;
  uint64_t v384;
  double v385;
  uint64_t v386;
  uint64_t v387;
  const float *v388;
  float64x2_t v389;
  float64x2_t v390;
  float64x2_t v391;
  float64x2_t v392;
  float64x2_t v393;
  float64x2_t v394;
  float64x2_t v395;
  float64x2_t v396;
  float64x2_t v397;
  float64x2_t v398;
  uint64_t v399;
  uint64_t v400;
  unint64_t v401;
  float *v402;
  int v403;
  float v404;
  char *v405;
  uint64_t v406;
  double v407;
  float v408;
  int v409;
  BOOL v410;
  int v411;
  uint64_t v412;
  uint64_t v413;
  float *v414;
  uint64_t v415;
  float *v416;
  float v417;
  float v418;
  _BYTE *v419;
  uint64_t v420;
  uint64_t v421;
  _BYTE *v422;
  int v423;
  char *v424;
  uint64_t v425;
  uint64_t v426;
  int v427;
  unint64_t v428;
  unint64_t v429;
  int v430;
  unint64_t v431;
  double v432;
  unsigned int v433;
  unint64_t v434;
  const float *v435;
  uint64_t v436;
  const float *v437;
  float64x2_t v438;
  float64x2_t v439;
  float64x2_t v440;
  float64x2_t v441;
  float64x2_t v442;
  float64x2_t v443;
  float64x2_t v444;
  float64x2_t v445;
  float64x2_t v446;
  float64x2_t v447;
  float *v448;
  double v449;
  float v450;
  float v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  float *v457;
  uint64_t v458;
  int v459;
  int v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  float *v465;
  float v466;
  int v467;
  int v468;
  char *v469;
  int v470;
  int v471;
  int v472;
  uint64_t v473;
  double v474;
  float v475;
  uint64_t v476;
  float *v477;
  float *v478;
  float v479;
  uint64_t v480;
  float *v481;
  float *v482;
  double v483;
  float *v484;
  float *v485;
  uint64_t v486;
  double v487;
  float v488;
  float v489;
  uint64_t j;
  uint64_t v491;
  unint64_t v492;
  uint64_t v493;
  int v494;
  uint64_t v495;
  unint64_t v496;
  unint64_t v497;
  double v498;
  unint64_t v499;
  const float *v500;
  uint64_t v501;
  const float *v502;
  float64x2_t v503;
  float64x2_t v504;
  float64x2_t v505;
  float64x2_t v506;
  float64x2_t v507;
  float64x2_t v508;
  float64x2_t v509;
  float64x2_t v510;
  float64x2_t v511;
  float64x2_t v512;
  float *v513;
  double v514;
  float v515;
  float v516;
  int v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  float *v522;
  uint64_t v523;
  int8x16_t *v524;
  int32x4_t *v525;
  uint64_t v526;
  int8x16_t v527;
  int8x16_t v528;
  int *v529;
  uint64_t v530;
  _DWORD *v531;
  int v532;
  float *v533;
  int v534;
  int v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  int8x16_t *v539;
  int32x4_t *v540;
  uint64_t v541;
  int8x16_t v542;
  int8x16_t v543;
  int *v544;
  uint64_t v545;
  _DWORD *v546;
  int v547;
  float *v548;
  int v549;
  int v550;
  uint64_t v551;
  uint64_t v552;
  uint64_t v553;
  int8x16_t *v554;
  int32x4_t *v555;
  uint64_t v556;
  int8x16_t v557;
  int8x16_t v558;
  int *v559;
  uint64_t v560;
  _DWORD *v561;
  int v562;
  float *v563;
  int v564;
  int v565;
  uint64_t v566;
  uint64_t v567;
  uint64_t v568;
  int8x16_t *v569;
  int32x4_t *v570;
  uint64_t v571;
  int8x16_t v572;
  int8x16_t v573;
  int *v574;
  uint64_t v575;
  _DWORD *v576;
  int v577;
  float *v578;
  float v579;
  int v580;
  int v581;
  double v582;
  uint64_t v583;
  float *v584;
  float *v585;
  double v586;
  float v587;
  float v588;
  int v589;
  uint64_t v590;
  unint64_t v591;
  uint64_t v592;
  unint64_t v593;
  double v594;
  unint64_t v595;
  const float *v596;
  uint64_t v597;
  const float *v598;
  float64x2_t v599;
  float64x2_t v600;
  float64x2_t v601;
  float64x2_t v602;
  float64x2_t v603;
  float64x2_t v604;
  float64x2_t v605;
  float64x2_t v606;
  float64x2_t v607;
  float64x2_t v608;
  float *v609;
  double v610;
  float v611;
  float v612;
  int v613;
  uint64_t v614;
  uint64_t v615;
  uint64_t v616;
  uint64_t v617;
  float *v618;
  uint64_t v619;
  float *v620;
  float v621;
  int v622;
  int v623;
  double v624;
  uint64_t v625;
  float *v626;
  uint64_t v627;
  float *v628;
  float *v629;
  float v630;
  double v631;
  float v632;
  float v633;
  int v634;
  uint64_t v635;
  unint64_t v636;
  uint64_t v637;
  unint64_t v638;
  double v639;
  unint64_t v640;
  const float *v641;
  uint64_t v642;
  const float *v643;
  float64x2_t v644;
  float64x2_t v645;
  float64x2_t v646;
  float64x2_t v647;
  float64x2_t v648;
  float64x2_t v649;
  float64x2_t v650;
  float64x2_t v651;
  float64x2_t v652;
  float64x2_t v653;
  float *v654;
  double v655;
  float v656;
  float v657;
  int v658;
  uint64_t v659;
  uint64_t v660;
  uint64_t v661;
  uint64_t v662;
  float *v663;
  uint64_t v664;
  float *v665;
  float v666;
  int v667;
  int v668;
  double v669;
  uint64_t v670;
  float *v671;
  uint64_t v672;
  float *v673;
  float *v674;
  float v675;
  double v676;
  float v677;
  float v678;
  int v679;
  uint64_t v680;
  unint64_t v681;
  unint64_t v682;
  double v683;
  unint64_t v684;
  const float *v685;
  uint64_t v686;
  const float *v687;
  float64x2_t v688;
  float64x2_t v689;
  float64x2_t v690;
  float64x2_t v691;
  float64x2_t v692;
  float64x2_t v693;
  float64x2_t v694;
  float64x2_t v695;
  float64x2_t v696;
  float64x2_t v697;
  float *v698;
  double v699;
  float v700;
  float v701;
  int v702;
  uint64_t v703;
  uint64_t v704;
  float *v705;
  uint64_t v706;
  float *v707;
  float v708;
  int v709;
  int v710;
  double v711;
  uint64_t v712;
  float *v713;
  float *v714;
  float *v715;
  float v716;
  double v717;
  float v718;
  float v719;
  int v720;
  float v721;
  uint64_t v722;
  int v723;
  _WORD *v724;
  _BYTE *v725;
  int *v726;
  int v727;
  float *v728;
  double v729;
  double v730;
  double v731;
  double v732;
  double v733;
  double v734;
  double v735;
  double v736;
  double v737;
  double v738;
  double v739;
  double v740;
  double v741;
  double v742;
  double v743;
  double v744;
  double v745;
  double v746;
  double v747;
  double v748;
  double v749;
  double v750;
  double v751;
  double v752;
  double v753;
  double v754;
  double v755;
  double v756;
  double v757;
  double v758;
  double v759;
  double v760;
  double v761;
  double v762;
  double v763;
  double v764;
  double v765;
  double v766;
  double v767;
  int v768;
  double v769;
  int v770;
  double v771;
  double v772;
  double v773;
  int v774;
  double v775;
  int v776;
  double v777;
  uint64_t v778;
  double v779;
  char *v780;
  double v781;
  int v782;
  double v783;
  char *v784;
  double v785;
  size_t v786;
  double v787;
  uint64_t v788;
  double v789;
  int v790;
  uint64_t v791;
  double v792;
  char *v793;
  float *v794;
  _BYTE v795[2720];
  _WORD v796[1];
  __int16 v797;
  _BYTE v798[2706];
  _WORD v799[147];
  __int16 v800;
  int32x4_t v801[6];
  _DWORD v802[11];
  float v803[64];
  float v804;
  _DWORD v805[8];
  float v806;
  int32x4_t v807;
  int32x4_t v808;
  int32x4_t v809;
  int32x4_t v810;
  int32x4_t v811;
  int32x4_t v812;
  int32x4_t v813;
  int32x4_t v814;
  int32x4_t v815;
  int32x4_t v816;
  int32x4_t v817;
  int32x4_t v818;
  int32x4_t v819;
  int32x4_t v820;
  int32x4_t v821;
  int32x4_t v822;
  __n128 v823;
  uint64_t v824;
  _WORD v825[160];
  __int16 v826;
  _BYTE v827[922];
  int v828;
  _BYTE v829[960];
  uint64_t v830;
  int v831;
  float v832;
  _BYTE v833[100];
  float32x2x4_t v834;
  float32x2x4_t v835;
  float32x2x4_t v836;
  float32x2x4_t v837;
  float32x2x4_t v838;
  float32x2x4_t v839;
  float32x2x4_t v840;
  float32x2x4_t v841;
  float32x2x4_t v842;
  float32x2x4_t v843;
  float32x2x4_t v844;
  float32x2x4_t v845;

  v9 = MEMORY[0x24BDAC7A8](a1, a2);
  v727 = v12;
  v14 = v13;
  v728 = v15;
  v724 = v16;
  v725 = v17;
  v19 = v18;
  v20 = v11.n128_f32[0];
  v726 = v21;
  v22 = v9;
  v23 = a9;
  *(_QWORD *)&v833[84] = *MEMORY[0x24BDAC8D0];
  v24 = 5 * a9 + 20;
  v25 = (v24 * v10);
  v26 = (8 * v24);
  v723 = v10;
  if (v10 == 16)
  {
    if ((int)v25 <= 0)
    {
      v823.n128_u64[0] = 0;
      if (a9 < -3)
        goto LABEL_60;
    }
    else
    {
      v27 = v25 + 1;
      do
      {
        v11.n128_f32[0] = rintf(*(float *)(v9 + 4 * (v27 - 2)));
        v28 = (uint64_t)v11.n128_f32[0];
        if ((int)(uint64_t)v11.n128_f32[0] <= -32768)
          LODWORD(v28) = -32768;
        if ((int)v28 >= 0x7FFF)
          LOWORD(v28) = 0x7FFF;
        v796[(v27-- - 2)] = v28;
      }
      while (v27 > 1);
      if ((int)v25 >= 2)
      {
        v29 = 0;
        v30 = 0;
        v31 = v25 >> 1;
        v32 = &v797;
        v33 = &v826;
        do
        {
          v34 = (uint64_t)*(v32 - 1) << 10;
          v35 = v34 - (int)v30;
          LODWORD(v34) = v34 + ((unint64_t)(0xFFFFFFFF9B81 * v35) >> 16);
          v30 = v34 + v35;
          v36 = (uint64_t)*v32 << 10;
          v37 = (unint64_t)(9872 * (v36 - (int)v29)) >> 16;
          v38 = v34 + v29 + v37;
          v29 = v36 + v37;
          v32 += 2;
          v39 = ((v38 >> 10) + 1) >> 1;
          if (v39 <= -32768)
            LOWORD(v39) = 0x8000;
          if (v38 <= 67107839)
            v40 = v39;
          else
            v40 = 0x7FFF;
          *v33++ = v40;
          --v31;
        }
        while (v31);
        v823.n128_u64[0] = __PAIR64__(v29, v30);
      }
      if (a9 < -3)
        goto LABEL_60;
    }
    v61 = (v26 | 1) - (v24 != 0);
    if (v61 < 0x10 || (v62 = v26 - (v24 != 0), 40 * a9 + 159 < v62) || HIDWORD(v62))
    {
      v63 = (8 * v24);
    }
    else
    {
      v63 = v26 - (v61 & 0xFFFFFFF0);
      v64 = v26 - 1;
      v65 = v61 & 0xFFFFFFF0;
      do
      {
        v66 = &v827[2 * v64 - 2];
        v67 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(v66 - 14));
        v68 = (int16x8_t)vextq_s8(v67, v67, 8uLL);
        v69 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(v66 - 30));
        v70 = (int16x8_t)vextq_s8(v69, v69, 8uLL);
        v71 = (int32x4_t)vcvtq_f32_s32(vmovl_high_s16(v68));
        v72 = &v829[4 * v64 + 320];
        v73 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v68.i8)));
        v74 = (int8x16_t)vrev64q_s32(v71);
        *(int8x16_t *)(v72 - 28) = vextq_s8(v74, v74, 8uLL);
        *(int8x16_t *)(v72 - 12) = vextq_s8(v73, v73, 8uLL);
        v75 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v70.i8)));
        v11 = (__n128)vextq_s8(v75, v75, 8uLL);
        v76 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_high_s16(v70)));
        *(int8x16_t *)(v72 - 60) = vextq_s8(v76, v76, 8uLL);
        *(__n128 *)(v72 - 44) = v11;
        v64 -= 16;
        v65 -= 16;
      }
      while (v65);
      if (v61 == (v61 & 0xFFFFFFF0))
        goto LABEL_60;
    }
    v77 = v63 + 1;
    do
    {
      v11.n128_u16[0] = *(_WORD *)&v827[2 * (v77 - 2) - 2];
      v11.n128_u64[0] = vmovl_s16((int16x4_t)v11.n128_u64[0]).u64[0];
      v11.n128_f32[0] = (float)v11.n128_i32[0];
      *(_DWORD *)&v829[4 * (v77-- - 2) + 320] = v11.n128_u32[0];
    }
    while (v77 > 1);
    goto LABEL_60;
  }
  if (v10 == 12)
  {
    if ((int)v25 >= 1)
    {
      v41 = v25 + 1;
      do
      {
        v42 = (uint64_t)rintf(*(float *)(v9 + 4 * (v41 - 2)));
        if ((int)v42 <= -32768)
          LODWORD(v42) = -32768;
        if ((int)v42 >= 0x7FFF)
          LOWORD(v42) = 0x7FFF;
        v796[(v41-- - 2)] = v42;
      }
      while (v41 > 1);
    }
    v823 = 0uLL;
    v824 = 0;
    v11 = silk_resampler_down2_3(&v823, &v826, (uint64_t)v796, v25);
    if (a9 >= -3)
    {
      v43 = (v26 | 1) - (v24 != 0);
      if (v43 < 0x10 || (v44 = v26 - (v24 != 0), 40 * a9 + 159 < v44) || HIDWORD(v44))
      {
        v45 = (8 * v24);
      }
      else
      {
        v45 = v26 - (v43 & 0xFFFFFFF0);
        v46 = v26 - 1;
        v47 = v43 & 0xFFFFFFF0;
        do
        {
          v48 = &v827[2 * v46 - 2];
          v49 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(v48 - 14));
          v50 = (int16x8_t)vextq_s8(v49, v49, 8uLL);
          v51 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(v48 - 30));
          v52 = (int16x8_t)vextq_s8(v51, v51, 8uLL);
          v53 = (int32x4_t)vcvtq_f32_s32(vmovl_high_s16(v50));
          v54 = &v829[4 * v46 + 320];
          v55 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v50.i8)));
          v56 = (int8x16_t)vrev64q_s32(v53);
          *(int8x16_t *)(v54 - 28) = vextq_s8(v56, v56, 8uLL);
          *(int8x16_t *)(v54 - 12) = vextq_s8(v55, v55, 8uLL);
          v57 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v52.i8)));
          v11 = (__n128)vextq_s8(v57, v57, 8uLL);
          v58 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_high_s16(v52)));
          *(int8x16_t *)(v54 - 60) = vextq_s8(v58, v58, 8uLL);
          *(__n128 *)(v54 - 44) = v11;
          v46 -= 16;
          v47 -= 16;
        }
        while (v47);
        if (v43 == (v43 & 0xFFFFFFF0))
          goto LABEL_60;
      }
      v78 = v45 + 1;
      do
      {
        v11.n128_u16[0] = *(_WORD *)&v827[2 * (v78 - 2) - 2];
        v11.n128_u64[0] = vmovl_s16((int16x4_t)v11.n128_u64[0]).u64[0];
        v11.n128_f32[0] = (float)v11.n128_i32[0];
        *(_DWORD *)&v829[4 * (v78-- - 2) + 320] = v11.n128_u32[0];
      }
      while (v78 > 1);
    }
  }
  else
  {
    if (a9 <= -4)
    {
      v823.n128_u64[0] = 0;
      goto LABEL_83;
    }
    v59 = v26 + 1;
    do
    {
      v11.n128_f32[0] = rintf(*(float *)(v9 + 4 * (v59 - 2)));
      v60 = (uint64_t)v11.n128_f32[0];
      if ((int)(uint64_t)v11.n128_f32[0] <= -32768)
        LODWORD(v60) = -32768;
      if ((int)v60 >= 0x7FFF)
        LOWORD(v60) = 0x7FFF;
      *(_WORD *)&v827[2 * (v59-- - 2) - 2] = v60;
    }
    while (v59 > 1);
  }
LABEL_60:
  v823.n128_u64[0] = 0;
  if (a9 < -3)
    goto LABEL_83;
  v79 = 0;
  v80 = 0;
  v81 = (4 * v24);
  v82 = v26 >> 1;
  v83 = (__int16 *)v827;
  v84 = v825;
  do
  {
    v85 = (uint64_t)*(v83 - 1) << 10;
    v86 = v85 - (int)v80;
    LODWORD(v85) = v85 + ((unint64_t)(0xFFFFFFFF9B81 * v86) >> 16);
    v80 = v85 + v86;
    v87 = (uint64_t)*v83 << 10;
    v88 = (unint64_t)(9872 * (v87 - (int)v79)) >> 16;
    v89 = v85 + v79 + v88;
    v79 = v87 + v88;
    v83 += 2;
    v90 = ((v89 >> 10) + 1) >> 1;
    if (v90 <= -32768)
      LOWORD(v90) = 0x8000;
    if (v89 <= 67107839)
      v91 = v90;
    else
      v91 = 0x7FFF;
    *v84++ = v91;
    --v82;
  }
  while (v82);
  v823.n128_u64[0] = __PAIR64__(v79, v80);
  v92 = (v81 | 1) - ((_DWORD)v81 != 0);
  if (v92 < 0x10 || (v93 = v81 - ((_DWORD)v81 != 0), 20 * a9 + 79 < v93) || HIDWORD(v93))
  {
    v94 = (4 * v24);
LABEL_76:
    v108 = v94 + 1;
    do
    {
      v11.n128_u16[0] = v825[(v108 - 2)];
      v11.n128_u64[0] = vmovl_s16((int16x4_t)v11.n128_u64[0]).u64[0];
      v11.n128_f32[0] = (float)v11.n128_i32[0];
      *(_DWORD *)&v827[4 * (v108-- - 2) + 638] = v11.n128_u32[0];
    }
    while (v108 > 1);
    goto LABEL_78;
  }
  v94 = v81 - (v92 & 0xFFFFFFF0);
  v95 = v81 - 1;
  v96 = v92 & 0xFFFFFFF0;
  do
  {
    v97 = &v825[v95];
    v98 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(v97 - 7));
    v99 = (int16x8_t)vextq_s8(v98, v98, 8uLL);
    v100 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(v97 - 15));
    v101 = (int16x8_t)vextq_s8(v100, v100, 8uLL);
    v102 = (int32x4_t)vcvtq_f32_s32(vmovl_high_s16(v99));
    v103 = &v827[4 * v95 + 638];
    v104 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v99.i8)));
    v105 = (int8x16_t)vrev64q_s32(v102);
    *(int8x16_t *)(v103 - 28) = vextq_s8(v105, v105, 8uLL);
    *(int8x16_t *)(v103 - 12) = vextq_s8(v104, v104, 8uLL);
    v106 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v101.i8)));
    v11 = (__n128)vextq_s8(v106, v106, 8uLL);
    v107 = (int8x16_t)vrev64q_s32((int32x4_t)vcvtq_f32_s32(vmovl_high_s16(v101)));
    *(int8x16_t *)(v103 - 60) = vextq_s8(v107, v107, 8uLL);
    *(__n128 *)(v103 - 44) = v11;
    v95 -= 16;
    v96 -= 16;
  }
  while (v96);
  if (v92 != (v92 & 0xFFFFFFF0))
    goto LABEL_76;
LABEL_78:
  v109 = (float *)&v827[4 * (20 * a9 + 76) + 650];
  v110 = 20 * a9 + 81;
  do
  {
    v111 = *(v109 - 1) + (float)(int)*v109;
    v112 = 32767.0;
    if (v111 <= 32767.0)
    {
      v112 = -32768.0;
      if (v111 >= -32768.0)
        v112 = *(v109 - 1) + (float)(int)*v109;
    }
    *v109-- = (float)(int)v112;
    --v110;
  }
  while (v110 > 2);
LABEL_83:
  v722 = v22;
  __memset_chk();
  if (a9 >= 2)
  {
    v113 = 0;
    v114 = (float *)v829;
    v115 = &v828;
    do
    {
      celt_pitch_xcorr_c(v114, v114 - 72, v803, 0x28u, 65);
      v116 = 0;
      v117 = v114[5] * v114[5] + v114[4] * v114[4] + v114[6] * v114[6] + v114[7] * v114[7];
      v118 = v114[9] * v114[9] + v114[8] * v114[8] + v114[10] * v114[10] + v114[11] * v114[11];
      v119 = v114[13] * v114[13] + v114[12] * v114[12] + v114[14] * v114[14] + v114[15] * v114[15];
      v120 = v114[17] * v114[17] + v114[16] * v114[16] + v114[18] * v114[18] + v114[19] * v114[19];
      v121 = v114[21] * v114[21] + v114[20] * v114[20] + v114[22] * v114[22] + v114[23] * v114[23];
      v122 = v114[25] * v114[25] + v114[24] * v114[24] + v114[26] * v114[26] + v114[27] * v114[27];
      v123 = v114[29] * v114[29] + v114[28] * v114[28] + v114[30] * v114[30] + v114[31] * v114[31];
      v124 = v114[1] * v114[1] + *v114 * *v114 + v114[2] * v114[2] + v114[3] * v114[3];
      v125 = *(v114 - 7) * *(v114 - 7)
           + *(v114 - 8) * *(v114 - 8)
           + *(v114 - 6) * *(v114 - 6)
           + *(v114 - 5) * *(v114 - 5)
           + *(v114 - 3) * *(v114 - 3)
           + *(v114 - 4) * *(v114 - 4)
           + *(v114 - 2) * *(v114 - 2)
           + *(v114 - 1) * *(v114 - 1)
           + v124
           + v117
           + v118
           + v119
           + v120
           + v121
           + v122
           + v123;
      v126 = v124
           + v117
           + v118
           + v119
           + v120
           + v121
           + v122
           + v123
           + v114[33] * v114[33]
           + v114[32] * v114[32]
           + v114[34] * v114[34]
           + v114[35] * v114[35]
           + v114[37] * v114[37]
           + v114[36] * v114[36]
           + v114[38] * v114[38]
           + v114[39] * v114[39]
           + v125
           + 160000.0;
      *(float *)&v124 = (v804 + v804) / v126;
      v806 = v806 + *(float *)&v124;
      v127 = (float *)&v807;
      do
      {
        v126 = v126
             + *(float *)&v115[v116] * *(float *)&v115[v116]
             - *(float *)&v115[v116 + 40] * *(float *)&v115[v116 + 40];
        v128 = (v803[v116 + 63] + v803[v116 + 63]) / v126;
        *v127 = *v127 + v128;
        ++v127;
        --v116;
      }
      while (v116 != -64);
      v114 += 40;
      ++v113;
      v115 += 40;
    }
    while (v113 != a9 >> 1);
  }
  v129 = (int8x16_t)vrev64q_s32(v822);
  v130 = (float32x4_t)vextq_s8(v129, v129, 8uLL);
  v131 = (int8x16_t)vrev64q_s32(v821);
  v132 = (float32x4_t)vextq_s8(v131, v131, 8uLL);
  v133 = (float32x4_t)vdupq_n_s32(0x39800000u);
  v134 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v130, vmulq_f32(vmulq_f32(v130, (float32x4_t)xmmword_208F385C0), v133)));
  v135 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v132, vmulq_f32(vmulq_f32(v132, (float32x4_t)xmmword_208F385D0), v133)));
  v821 = (int32x4_t)vextq_s8(v135, v135, 8uLL);
  v822 = (int32x4_t)vextq_s8(v134, v134, 8uLL);
  v136 = (int8x16_t)vrev64q_s32(v820);
  v137 = (float32x4_t)vextq_s8(v136, v136, 8uLL);
  v138 = (int8x16_t)vrev64q_s32(v819);
  v139 = (float32x4_t)vextq_s8(v138, v138, 8uLL);
  v140 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v137, vmulq_f32(vmulq_f32(v137, (float32x4_t)xmmword_208F385E0), v133)));
  v820 = (int32x4_t)vextq_s8(v140, v140, 8uLL);
  v141 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v139, vmulq_f32(vmulq_f32(v139, (float32x4_t)xmmword_208F385F0), v133)));
  v819 = (int32x4_t)vextq_s8(v141, v141, 8uLL);
  v142 = (int8x16_t)vrev64q_s32(v818);
  v143 = (float32x4_t)vextq_s8(v142, v142, 8uLL);
  v144 = (int8x16_t)vrev64q_s32(v817);
  v145 = (float32x4_t)vextq_s8(v144, v144, 8uLL);
  v146 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v143, vmulq_f32(vmulq_f32(v143, (float32x4_t)xmmword_208F38600), v133)));
  v818 = (int32x4_t)vextq_s8(v146, v146, 8uLL);
  v147 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v145, vmulq_f32(vmulq_f32(v145, (float32x4_t)xmmword_208F38610), v133)));
  v817 = (int32x4_t)vextq_s8(v147, v147, 8uLL);
  v148 = (int8x16_t)vrev64q_s32(v816);
  v149 = (float32x4_t)vextq_s8(v148, v148, 8uLL);
  v150 = (int8x16_t)vrev64q_s32(v815);
  v151 = (float32x4_t)vextq_s8(v150, v150, 8uLL);
  v152 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v149, vmulq_f32(vmulq_f32(v149, (float32x4_t)xmmword_208F38620), v133)));
  v816 = (int32x4_t)vextq_s8(v152, v152, 8uLL);
  v153 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v151, vmulq_f32(vmulq_f32(v151, (float32x4_t)xmmword_208F38630), v133)));
  v815 = (int32x4_t)vextq_s8(v153, v153, 8uLL);
  v154 = (int8x16_t)vrev64q_s32(v814);
  v155 = (float32x4_t)vextq_s8(v154, v154, 8uLL);
  v156 = (int8x16_t)vrev64q_s32(v813);
  v157 = (float32x4_t)vextq_s8(v156, v156, 8uLL);
  v158 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v155, vmulq_f32(vmulq_f32(v155, (float32x4_t)xmmword_208F38640), v133)));
  v814 = (int32x4_t)vextq_s8(v158, v158, 8uLL);
  v159 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v157, vmulq_f32(vmulq_f32(v157, (float32x4_t)xmmword_208F38650), v133)));
  v813 = (int32x4_t)vextq_s8(v159, v159, 8uLL);
  v160 = (int8x16_t)vrev64q_s32(v812);
  v161 = (float32x4_t)vextq_s8(v160, v160, 8uLL);
  v162 = (int8x16_t)vrev64q_s32(v811);
  v163 = (float32x4_t)vextq_s8(v162, v162, 8uLL);
  v164 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v161, vmulq_f32(vmulq_f32(v161, (float32x4_t)xmmword_208F38660), v133)));
  v812 = (int32x4_t)vextq_s8(v164, v164, 8uLL);
  v165 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v163, vmulq_f32(vmulq_f32(v163, (float32x4_t)xmmword_208F38670), v133)));
  v811 = (int32x4_t)vextq_s8(v165, v165, 8uLL);
  v166 = (int8x16_t)vrev64q_s32(v810);
  v167 = (float32x4_t)vextq_s8(v166, v166, 8uLL);
  v168 = (int8x16_t)vrev64q_s32(v809);
  v169 = (float32x4_t)vextq_s8(v168, v168, 8uLL);
  v170 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v167, vmulq_f32(vmulq_f32(v167, (float32x4_t)xmmword_208F38680), v133)));
  v810 = (int32x4_t)vextq_s8(v170, v170, 8uLL);
  v171 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v169, vmulq_f32(vmulq_f32(v169, (float32x4_t)xmmword_208F38690), v133)));
  v809 = (int32x4_t)vextq_s8(v171, v171, 8uLL);
  v172 = (int8x16_t)vrev64q_s32(v808);
  v173 = (float32x4_t)vextq_s8(v172, v172, 8uLL);
  v174 = (int8x16_t)vrev64q_s32(v807);
  v175 = (float32x4_t)vextq_s8(v174, v174, 8uLL);
  v176 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v173, vmulq_f32(vmulq_f32(v173, (float32x4_t)xmmword_208F386A0), v133)));
  v808 = (int32x4_t)vextq_s8(v176, v176, 8uLL);
  v177 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(v175, vmulq_f32(vmulq_f32(v175, (float32x4_t)xmmword_208F386B0), v133)));
  v807 = (int32x4_t)vextq_s8(v177, v177, 8uLL);
  v806 = v806 + (float)((float)(v806 * -8.0) * 0.00024414);
  v178 = 2 * v727 + 4;
  silk_insertion_sort_decreasing_FLP((uint64_t)&v806, v801, 65, v178);
  if (v806 >= 0.2)
  {
    if (v727 >= -1)
    {
      v181 = 0;
      v182 = v806 * v20;
      if (v178 <= 1)
        v183 = 1;
      else
        v183 = v178;
      while (*(&v806 + v181) > v182)
      {
        v801[0].i32[v181] = 2 * v801[0].i32[v181] + 16;
        if (v183 == ++v181)
          goto LABEL_98;
      }
      v178 = v181;
    }
LABEL_98:
    v800 = 0;
    memset(&v799[11], 0, 272);
    if (v178 < 1)
    {
      v185 = 0;
LABEL_108:
      v192 = 0;
      v193 = 0;
      v194 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[137]);
      v195 = vextq_s8(v194, v194, 8uLL);
      v196 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[129]);
      v197 = vextq_s8(v196, v196, 8uLL);
      v198 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v195, (int16x8_t)vextq_s8((int8x16_t)vdupq_n_s16(v185), v195, 0xEuLL)));
      *(int16x8_t *)&v799[139] = vaddq_s16((int16x8_t)vextq_s8(v198, v198, 8uLL), *(int16x8_t *)&v799[139]);
      v199 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v197, (int16x8_t)vextq_s8(v195, v197, 0xEuLL)));
      *(int16x8_t *)&v799[131] = vaddq_s16((int16x8_t)vextq_s8(v199, v199, 8uLL), *(int16x8_t *)&v799[131]);
      v200 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[121]);
      v201 = vextq_s8(v200, v200, 8uLL);
      v202 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[113]);
      v203 = vextq_s8(v202, v202, 8uLL);
      v204 = (int16x8_t)vextq_s8(v201, v203, 0xEuLL);
      v205 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v201, (int16x8_t)vextq_s8(v197, v201, 0xEuLL)));
      *(int16x8_t *)&v799[123] = vaddq_s16((int16x8_t)vextq_s8(v205, v205, 8uLL), *(int16x8_t *)&v799[123]);
      v206 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v203, v204));
      *(int16x8_t *)&v799[115] = vaddq_s16((int16x8_t)vextq_s8(v206, v206, 8uLL), *(int16x8_t *)&v799[115]);
      v207 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[105]);
      v208 = vextq_s8(v207, v207, 8uLL);
      v209 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[97]);
      v210 = vextq_s8(v209, v209, 8uLL);
      v211 = (int16x8_t)vextq_s8(v208, v210, 0xEuLL);
      v212 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v208, (int16x8_t)vextq_s8(v203, v208, 0xEuLL)));
      *(int16x8_t *)&v799[107] = vaddq_s16((int16x8_t)vextq_s8(v212, v212, 8uLL), *(int16x8_t *)&v799[107]);
      v213 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v210, v211));
      *(int16x8_t *)&v799[99] = vaddq_s16((int16x8_t)vextq_s8(v213, v213, 8uLL), *(int16x8_t *)&v799[99]);
      v214 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[89]);
      v215 = vextq_s8(v214, v214, 8uLL);
      v216 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[81]);
      v217 = vextq_s8(v216, v216, 8uLL);
      v218 = (int16x8_t)vextq_s8(v215, v217, 0xEuLL);
      v219 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v215, (int16x8_t)vextq_s8(v210, v215, 0xEuLL)));
      *(int16x8_t *)&v799[91] = vaddq_s16((int16x8_t)vextq_s8(v219, v219, 8uLL), *(int16x8_t *)&v799[91]);
      v220 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v217, v218));
      *(int16x8_t *)&v799[83] = vaddq_s16((int16x8_t)vextq_s8(v220, v220, 8uLL), *(int16x8_t *)&v799[83]);
      v221 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[73]);
      v222 = vextq_s8(v221, v221, 8uLL);
      v223 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[65]);
      v224 = vextq_s8(v223, v223, 8uLL);
      v225 = (int16x8_t)vextq_s8(v222, v224, 0xEuLL);
      v226 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v222, (int16x8_t)vextq_s8(v217, v222, 0xEuLL)));
      *(int16x8_t *)&v799[75] = vaddq_s16((int16x8_t)vextq_s8(v226, v226, 8uLL), *(int16x8_t *)&v799[75]);
      v227 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v224, v225));
      *(int16x8_t *)&v799[67] = vaddq_s16((int16x8_t)vextq_s8(v227, v227, 8uLL), *(int16x8_t *)&v799[67]);
      v228 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[57]);
      v229 = vextq_s8(v228, v228, 8uLL);
      v230 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v229, (int16x8_t)vextq_s8(v224, v229, 0xEuLL)));
      *(int16x8_t *)&v799[59] = vaddq_s16((int16x8_t)vextq_s8(v230, v230, 8uLL), *(int16x8_t *)&v799[59]);
      v231 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[49]);
      v232 = vextq_s8(v231, v231, 8uLL);
      v233 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v232, (int16x8_t)vextq_s8(v229, v232, 0xEuLL)));
      *(int16x8_t *)&v799[51] = vaddq_s16((int16x8_t)vextq_s8(v233, v233, 8uLL), *(int16x8_t *)&v799[51]);
      v234 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[41]);
      v235 = vextq_s8(v234, v234, 8uLL);
      v236 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v235, (int16x8_t)vextq_s8(v232, v235, 0xEuLL)));
      *(int16x8_t *)&v799[43] = vaddq_s16((int16x8_t)vextq_s8(v236, v236, 8uLL), *(int16x8_t *)&v799[43]);
      v237 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[33]);
      v238 = vextq_s8(v237, v237, 8uLL);
      v239 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v238, (int16x8_t)vextq_s8(v235, v238, 0xEuLL)));
      *(int16x8_t *)&v799[35] = vaddq_s16((int16x8_t)vextq_s8(v239, v239, 8uLL), *(int16x8_t *)&v799[35]);
      v240 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[25]);
      v241 = vextq_s8(v240, v240, 8uLL);
      v242 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v241, (int16x8_t)vextq_s8(v238, v241, 0xEuLL)));
      *(int16x8_t *)&v799[27] = vaddq_s16((int16x8_t)vextq_s8(v242, v242, 8uLL), *(int16x8_t *)&v799[27]);
      v243 = (int8x16_t)vrev64q_s16(*(int16x8_t *)&v799[17]);
      v244 = vextq_s8(v243, v243, 8uLL);
      v245 = (int8x16_t)vrev64q_s16(vaddq_s16((int16x8_t)v244, (int16x8_t)vextq_s8(v241, v244, 0xEuLL)));
      *(int16x8_t *)&v799[19] = vaddq_s16((int16x8_t)vextq_s8(v245, v245, 8uLL), *(int16x8_t *)&v799[19]);
      v799[18] += v799[16] + v799[17];
      v720 = 2 * v723;
      v799[17] += v799[15] + v799[16];
      v799[16] += v799[14] + v799[15];
      do
      {
        if ((__int16)v799[v192 + 17] >= 1)
          v801[0].i32[v193++] = v192 + 16;
        ++v192;
      }
      while (v192 != 128);
      v246 = 0;
      v247 = v799[145];
      v248 = v799[144];
      do
      {
        v249 = v247 + v248;
        v250 = &v799[v246];
        v247 = v248;
        v248 = v250[143];
        v250[146] += v249 + v248;
        v251 = v246 + 146;
        --v246;
      }
      while (v251 > 0x10);
      v252 = 0;
      for (i = 16; i != 147; ++i)
      {
        if ((__int16)v799[i] >= 1)
          v799[v252++] = i - 2;
      }
      v721 = v19;
      bzero(v805, 0x950uLL);
      if (a9 >= 1)
      {
        v254 = 0;
        v255 = (float *)(v22 + 640);
        if (v723 != 8)
          v255 = (float *)&v830;
        do
        {
          if (v252 >= 1)
          {
            v769 = v255[1];
            v771 = *v255;
            v767 = v255[2];
            v766 = v255[3];
            v764 = v255[5];
            v765 = v255[4];
            v763 = v255[6];
            v762 = v255[7];
            v760 = v255[9];
            v761 = v255[8];
            v759 = v255[10];
            v758 = v255[11];
            v756 = v255[13];
            v757 = v255[12];
            v755 = v255[14];
            v754 = v255[15];
            v752 = v255[17];
            v753 = v255[16];
            v751 = v255[18];
            v750 = v255[19];
            v748 = v255[21];
            v749 = v255[20];
            v747 = v255[22];
            v746 = v255[23];
            v744 = v255[25];
            v745 = v255[24];
            v743 = v255[26];
            v742 = v255[27];
            v740 = v255[29];
            v741 = v255[28];
            v739 = v255[30];
            v738 = v255[31];
            v736 = v255[33];
            v737 = v255[32];
            v735 = v255[34];
            v734 = v255[35];
            v732 = v255[37];
            v733 = v255[36];
            v256 = v255[39];
            v731 = v255[38];
            v729 = v769 * v769
                 + v771 * v771
                 + v767 * v767
                 + v766 * v766
                 + v764 * v764
                 + v765 * v765
                 + v763 * v763
                 + v762 * v762
                 + v760 * v760
                 + v761 * v761
                 + v759 * v759
                 + v758 * v758
                 + v756 * v756
                 + v757 * v757
                 + v755 * v755
                 + v754 * v754
                 + v752 * v752
                 + v753 * v753
                 + v751 * v751
                 + v750 * v750
                 + v748 * v748
                 + v749 * v749
                 + v747 * v747
                 + v746 * v746
                 + v744 * v744
                 + v745 * v745
                 + v743 * v743
                 + v742 * v742
                 + v740 * v740
                 + v741 * v741
                 + v739 * v739
                 + v738 * v738
                 + v736 * v736
                 + v737 * v737
                 + v735 * v735
                 + v734 * v734
                 + v732 * v732
                 + v733 * v733
                 + v731 * v731
                 + v256 * v256
                 + 1.0;
            v730 = v256;
            v257 = v799;
            v258 = v252;
            do
            {
              v260 = *v257++;
              v259 = v260;
              v261 = &v255[-v260];
              v789 = v261[1];
              v792 = *v261;
              v787 = v261[3];
              v262 = v261[5];
              v783 = v261[4];
              v781 = v261[7];
              v775 = v261[9];
              v777 = v261[8];
              v773 = v261[11];
              v263 = v261[12];
              v264 = v261[13];
              v265 = v261[14];
              v266 = v261[15];
              v267 = v261[16];
              v268 = v261[17];
              v269 = v261[18];
              v270 = v261[19];
              v271 = v261[20];
              v272 = v261[21];
              v273 = v261[22];
              v274 = v261[23];
              v275 = v261[24];
              v276 = v261[25];
              v277 = v261[26];
              v278 = v261[27];
              v279 = v261[28];
              v280 = v261[29];
              v281 = v261[30];
              v282 = v261[31];
              v283 = v261[32];
              v284 = v261[33];
              v285 = v261[34];
              v286 = v261[35];
              v287 = v261[36];
              v288 = v261[37];
              v289 = v261[38];
              v290 = v261[39];
              v291 = v789 * v769
                   + v792 * v771
                   + v261[2] * v767
                   + v787 * v766
                   + 0.0
                   + v262 * v764
                   + v783 * v765
                   + v261[6] * v763
                   + v781 * v762
                   + v775 * v760
                   + v777 * v761
                   + v261[10] * v759
                   + v773 * v758
                   + v264 * v756
                   + v263 * v757
                   + v265 * v755
                   + v266 * v754
                   + v268 * v752
                   + v267 * v753
                   + v269 * v751
                   + v270 * v750
                   + v272 * v748
                   + v271 * v749
                   + v273 * v747
                   + v274 * v746
                   + v276 * v744
                   + v275 * v745
                   + v277 * v743
                   + v278 * v742
                   + v280 * v740
                   + v279 * v741
                   + v281 * v739
                   + v282 * v738
                   + v284 * v736
                   + v283 * v737
                   + v285 * v735
                   + v286 * v734
                   + v288 * v732
                   + v287 * v733
                   + v289 * v731
                   + v290 * v730;
              v292 = 0.0;
              if (v291 > 0.0)
              {
                v772 = v261[10];
                v779 = v261[6];
                v785 = v261[2];
                v292 = (v291 + v291)
                     / (v729
                      + v789 * v789
                      + v792 * v792
                      + v785 * v785
                      + v787 * v787
                      + v262 * v262
                      + v783 * v783
                      + v779 * v779
                      + v781 * v781
                      + v775 * v775
                      + v777 * v777
                      + v772 * v772
                      + v773 * v773
                      + v264 * v264
                      + v263 * v263
                      + v265 * v265
                      + v266 * v266
                      + v268 * v268
                      + v267 * v267
                      + v269 * v269
                      + v270 * v270
                      + v272 * v272
                      + v271 * v271
                      + v273 * v273
                      + v274 * v274
                      + v276 * v276
                      + v275 * v275
                      + v277 * v277
                      + v278 * v278
                      + v280 * v280
                      + v279 * v279
                      + v281 * v281
                      + v282 * v282
                      + v284 * v284
                      + v283 * v283
                      + v285 * v285
                      + v286 * v286
                      + v288 * v288
                      + v287 * v287
                      + v289 * v289
                      + v290 * v290);
              }
              *(float *)&v805[149 * v254 + v259] = v292;
              --v258;
            }
            while (v258);
          }
          v255 += 40;
          ++v254;
        }
        while (v254 != a9);
      }
      v293 = v14;
      v774 = 18 * v723;
      if (v14 < 1)
      {
        v294 = 0.0;
      }
      else
      {
        if (v723 == 12)
          v293 = 2 * v14 / 3;
        else
          v293 = v14 >> (v723 == 16);
        v294 = log10((float)v293) * 3.32192809;
      }
      v295 = (char *)&silk_CB_lags_stage2_10_ms;
      if (a9 == 4)
        v295 = (char *)&silk_CB_lags_stage2;
      v793 = v295;
      if (v193 < 1)
        goto LABEL_179;
      v788 = (5 * v723);
      v296 = 0;
      v790 = 0;
      v297 = a9 == 4 ? 11 : 3;
      v298 = v727 > 0 && v723 == 8;
      v299 = v298 && a9 == 4;
      v300 = (float)a9 * 0.2;
      v301 = v299 ? 11 : 3;
      v302 = 0.0;
      v303 = -1;
      v304 = -1000.0;
      do
      {
        v305 = v801[0].i32[v296];
        if (a9 < 1)
        {
          bzero(v802, 4 * v301);
        }
        else
        {
          v306 = 0;
          v307 = v793;
          do
          {
            v308 = 0.0;
            v309 = v805;
            v310 = v307;
            v311 = a9;
            do
            {
              v308 = v308 + *(float *)&v309[v305 + *v310];
              v309 += 149;
              v310 += v297;
              --v311;
            }
            while (v311);
            *(float *)&v802[v306++] = v308;
            ++v307;
          }
          while (v306 != v301);
        }
        v312 = 0;
        v313 = 0;
        v314 = -1000.0;
        do
        {
          if (*(float *)&v802[v312] > v314)
          {
            v314 = *(float *)&v802[v312];
            v313 = v312;
          }
          ++v312;
        }
        while (v301 != v312);
        v315 = log10((float)v305) * 3.32192809;
        v316 = v314 + (float)((float)-v300 * v315);
        if (v293 >= 1)
          v316 = v316
               - (float)((float)((float)((float)(v315 - v294) * (float)(v315 - v294)) * (float)(v300 * *v728))
                       / (float)((float)((float)(v315 - v294) * (float)(v315 - v294)) + 0.5));
        if (v316 > v304 && v314 > (float)((float)a9 * v721))
        {
          v302 = v314;
          v304 = v316;
          v790 = v313;
          v303 = v305;
        }
        ++v296;
      }
      while (v296 != v193);
      v318 = v723;
      LODWORD(v319) = 5 * v723;
      if (v303 == -1)
      {
LABEL_179:
        LOBYTE(v179) = 0;
        *(_QWORD *)v726 = 0;
        *((_QWORD *)v726 + 1) = 0;
        *v728 = 0.0;
        result = 1;
        *v724 = 0;
        goto LABEL_289;
      }
      *v728 = v302 / (float)a9;
      if (v723 <= 8)
      {
        v328 = v726;
        LOBYTE(v179) = v790;
        if (a9 >= 1)
        {
          v329 = &v793[v790];
          do
          {
            v330 = v303 + *v329;
            if (v330 <= 16)
              v330 = 16;
            if (v330 >= 144)
              v330 = 144;
            *v328++ = v330;
            v329 += v297;
            --v23;
          }
          while (v23);
        }
        v331 = v303 - 16;
        goto LABEL_288;
      }
      if (v723 == 12)
      {
        v320 = ((3 * (__int16)v303) & 1) + ((3 * (__int16)v303) >> 1);
        v321 = 216;
        v323 = 215;
        v322 = 2 * v723;
        v324 = v726;
        v325 = v722;
        if (v720 >= v774)
        {
LABEL_173:
          if (v320 <= v323)
            v326 = v323;
          else
            v326 = v320;
          if (v320 <= v322)
            v327 = v326;
          else
            v327 = v322;
          goto LABEL_195;
        }
      }
      else
      {
        v320 = 2 * v303;
        v321 = 18 * v723;
        v323 = 18 * v723 - 1;
        v322 = 2 * v723;
        v324 = v726;
        v325 = v722;
        if (v720 >= v774)
          goto LABEL_173;
      }
      if (v320 <= v322)
        v332 = v322;
      else
        v332 = v320;
      if (v320 >= v321)
        v327 = v323;
      else
        v327 = v332;
LABEL_195:
      if (v327 - 2 <= v322)
        v333 = v322;
      else
        v333 = v327 - 2;
      v334 = v327 + 2;
      if (v327 + 2 >= v323)
        v334 = v323;
      v768 = v334;
      v776 = v333;
      v770 = v327;
      if (a9 != 4)
      {
        if (a9 > 0)
        {
          v336 = (float *)(v325 + 80 * v723);
          v786 = -(uint64_t)v333;
          v791 = (int)v788;
          v784 = (char *)&silk_CB_lags_stage3_10_ms;
          v335 = (char *)&silk_Lag_range_stage3_10_ms;
          v778 = 12;
          v337 = 12;
          goto LABEL_205;
        }
        v424 = (char *)&silk_CB_lags_stage3_10_ms;
        v425 = 12;
        v423 = 12;
LABEL_246:
        v426 = 20 * v318;
        v427 = v319 * a9;
        if ((int)v319 * a9 < 4)
        {
          v433 = 0;
          v432 = 0.0;
          v430 = v770;
          if (v427 <= 0)
            goto LABEL_270;
LABEL_259:
          v452 = v433;
          v453 = v427 + ~v433;
          if ((_DWORD)v453)
          {
            v454 = v453 + 1;
            v455 = (v453 + 1) & 0x1FFFFFFFELL;
            v456 = v455 + v452;
            v457 = (float *)(4 * v426 + 4 * v452 + v325 + 4);
            v458 = v455;
            do
            {
              v432 = v432 + *(v457 - 1) * *(v457 - 1) + *v457 * *v457;
              v457 += 2;
              v458 -= 2;
            }
            while (v458);
            if (v454 == v455)
              goto LABEL_270;
          }
          else
          {
            v456 = v452;
          }
          v465 = (float *)(v325 + 4 * v456 + 4 * v426);
          do
          {
            v466 = *v465++;
            v432 = v432 + v466 * v466;
            LODWORD(v456) = v456 + 1;
          }
          while (v427 > (int)v456);
LABEL_270:
          if (v333 <= v768)
          {
            v473 = 0;
            v179 = 0;
            v474 = v432 + 1.0;
            v475 = -0.05 / (float)v430;
            v476 = (v768 - v333 + 1);
            v477 = (float *)v796;
            v478 = (float *)v795;
            v479 = -1000.0;
            do
            {
              if (v423 >= 1)
              {
                if (a9 <= 0)
                {
                  for (j = 0; j != v423; ++j)
                  {
                    if (v479 < 0.0 && v333 + silk_CB_lags_stage3[j] < v774)
                    {
                      v479 = 0.0;
                      v179 = j;
                      v430 = v333;
                    }
                  }
                }
                else
                {
                  v480 = 0;
                  v481 = v478;
                  v482 = v477;
                  do
                  {
                    v483 = 0.0;
                    v484 = v481;
                    v485 = v482;
                    v486 = a9;
                    v487 = v474;
                    do
                    {
                      v483 = v483 + *v484;
                      v487 = v487 + *v485;
                      v485 += 170;
                      v484 += 170;
                      --v486;
                    }
                    while (v486);
                    v488 = 0.0;
                    if (v483 > 0.0)
                    {
                      v489 = (v483 + v483) / v487;
                      v488 = (float)((float)(v475 * (float)(int)v480) + 1.0) * v489;
                    }
                    if (v488 > v479 && v333 + silk_CB_lags_stage3[v480] < v774)
                    {
                      v479 = v488;
                      v179 = v480;
                      v430 = v333;
                    }
                    ++v480;
                    v482 += 5;
                    v481 += 5;
                  }
                  while (v480 != v423);
                }
              }
              ++v473;
              ++v333;
              ++v477;
              ++v478;
            }
            while (v473 != v476);
          }
          else
          {
            v179 = 0;
          }
          if (a9 >= 1)
          {
            if (v720 <= v774)
              v467 = 18 * v723;
            else
              v467 = 2 * v723;
            if (v720 >= v774)
              v468 = 18 * v723;
            else
              v468 = 2 * v723;
            v469 = &v424[v179];
            do
            {
              v470 = v430 + *v469;
              if (v470 <= v468)
                v471 = v468;
              else
                v471 = v430 + *v469;
              if (v470 <= v467)
                v472 = v471;
              else
                v472 = v467;
              *v324++ = v472;
              v469 += v425;
              --v23;
            }
            while (v23);
          }
          v331 = v430 - v720;
LABEL_288:
          result = 0;
          *v724 = v331;
          goto LABEL_289;
        }
        v428 = (v427 - 3);
        v429 = 4;
        if (v428 > 4)
          v429 = (v427 - 3);
        v430 = v770;
        if (v429 >= 0xD)
        {
          v434 = ((v429 - 1) >> 2) + 1;
          v431 = 4 * (v434 & 0x7FFFFFFFFFFFFFFCLL);
          v435 = (const float *)(v325 + 4 * v426 + 32);
          v432 = 0.0;
          v436 = v434 & 0x7FFFFFFFFFFFFFFCLL;
          do
          {
            v437 = v435 - 8;
            v834 = vld4_f32(v437);
            v841 = vld4_f32(v435);
            v438 = vcvtq_f64_f32(v834.val[0]);
            v439 = vcvtq_f64_f32(v841.val[0]);
            v440 = vcvtq_f64_f32(v834.val[1]);
            v441 = vcvtq_f64_f32(v841.val[1]);
            v442 = vmlaq_f64(vmulq_f64(v440, v440), v438, v438);
            v443 = vmlaq_f64(vmulq_f64(v441, v441), v439, v439);
            v444 = vcvtq_f64_f32(v834.val[2]);
            v445 = vcvtq_f64_f32(v841.val[2]);
            *(float64x2_t *)v834.val[0].f32 = vcvtq_f64_f32(v834.val[3]);
            *(float64x2_t *)v834.val[1].f32 = vcvtq_f64_f32(v841.val[3]);
            v446 = vmlaq_f64(vmlaq_f64(v442, v444, v444), *(float64x2_t *)v834.val[0].f32, *(float64x2_t *)v834.val[0].f32);
            v447 = vmlaq_f64(vmlaq_f64(v443, v445, v445), *(float64x2_t *)v834.val[1].f32, *(float64x2_t *)v834.val[1].f32);
            v432 = v432 + v446.f64[0] + v446.f64[1] + v447.f64[0] + v447.f64[1];
            v435 += 16;
            v436 -= 4;
          }
          while (v436);
          if (v434 == (v434 & 0x7FFFFFFFFFFFFFFCLL))
          {
LABEL_258:
            v433 = v427 & 0xFFFFFFFC;
            if ((int)(v427 & 0xFFFFFFFC) >= v427)
              goto LABEL_270;
            goto LABEL_259;
          }
        }
        else
        {
          v431 = 0;
          v432 = 0.0;
        }
        v448 = (float *)(4 * v431 + 4 * v426 + v325 + 8);
        do
        {
          v449 = *(v448 - 1) * *(v448 - 1) + *(v448 - 2) * *(v448 - 2);
          v450 = *v448;
          v451 = v448[1];
          v448 += 4;
          v432 = v432 + v449 + v450 * v450 + v451 * v451;
          v431 += 4;
        }
        while (v431 < v428);
        goto LABEL_258;
      }
      v335 = (char *)&silk_Lag_range_stage3 + 8 * v727;
      v336 = (float *)(v325 + 80 * v723);
      v791 = (int)v788;
      if (silk_nb_cbk_searchs_stage3[v727] > 0)
      {
        v786 = -(uint64_t)v333;
        v778 = silk_nb_cbk_searchs_stage3[v727];
        v784 = silk_CB_lags_stage3;
        v337 = 34;
LABEL_205:
        v780 = v335;
        v782 = v337;
        v338 = 0;
        v339 = 0;
        v340 = v795;
        while (1)
        {
          v341 = &v335[2 * v339];
          v342 = *v341;
          v343 = *v341;
          v344 = -v343;
          v345 = v341[1];
          v346 = (v345 - v342 + 1);
          v794 = v336;
          celt_pitch_xcorr_c(v336, &v336[v786 - v341[1]], &v832, v788, v345 - v342 + 1);
          v347 = &v784[v338 & 0xFFFFFFFE];
          if (v345 >= v342)
            break;
          v348 = v340;
          v349 = v778;
          v335 = v780;
          v350 = v794;
          do
          {
LABEL_216:
            v362 = *v347++;
            v363 = &v796[2 * v362 + 2 * v344];
            *(_OWORD *)v348 = *(_OWORD *)v363;
            *((_DWORD *)v348 + 4) = *((_DWORD *)v363 + 4);
            v348 += 20;
            --v349;
          }
          while (v349);
          v336 = &v350[v791];
          ++v339;
          v338 += v782;
          v340 += 680;
          if (v339 == a9)
            goto LABEL_218;
        }
        if (v346 >= 8)
        {
          v351 = v346 & 0xFFFFFFF8;
          v352 = v351 + v343;
          v353 = (int8x16_t *)v798;
          v354 = (int32x4_t *)(&v831 + v345 - v343);
          v355 = v351;
          do
          {
            v356 = (int8x16_t)vrev64q_s32(*v354);
            v357 = (int8x16_t)vrev64q_s32(v354[-1]);
            v353[-1] = vextq_s8(v356, v356, 8uLL);
            *v353 = vextq_s8(v357, v357, 8uLL);
            v353 += 2;
            v354 -= 2;
            v355 -= 8;
          }
          while (v355);
          v335 = v780;
          v350 = v794;
          if (v351 == v346)
            goto LABEL_215;
        }
        else
        {
          v351 = 0;
          v352 = v343;
          v335 = v780;
          v350 = v794;
        }
        v358 = (int *)&v833[4 * v345 - 4 + -4 * v352];
        v359 = v346 - v351;
        v360 = &v796[2 * v351];
        do
        {
          v361 = *v358--;
          *v360++ = v361;
          --v359;
        }
        while (v359);
LABEL_215:
        v348 = v340;
        v349 = v778;
        goto LABEL_216;
      }
      v459 = *v335;
      v460 = v335[1];
      v461 = (v460 - v459 + 1);
      v462 = v325 + 80 * v723;
      celt_pitch_xcorr_c(v336, &v336[-v333 - v335[1]], &v832, v788, v460 - v459 + 1);
      if (v460 >= v459)
      {
        if (v461 < 8)
        {
          v463 = 0;
          v464 = v459;
LABEL_328:
          v529 = (int *)&v833[4 * v460 - 4 + -4 * v464];
          v530 = v461 - v463;
          v531 = &v796[2 * v463];
          do
          {
            v532 = *v529--;
            *v531++ = v532;
            --v530;
          }
          while (v530);
          goto LABEL_330;
        }
        v463 = v461 & 0xFFFFFFF8;
        v464 = v463 + v459;
        v524 = (int8x16_t *)v798;
        v525 = (int32x4_t *)&v833[4 * v460 - 16 + -4 * v459];
        v526 = v463;
        do
        {
          v527 = (int8x16_t)vrev64q_s32(*v525);
          v528 = (int8x16_t)vrev64q_s32(v525[-1]);
          v524[-1] = vextq_s8(v527, v527, 8uLL);
          *v524 = vextq_s8(v528, v528, 8uLL);
          v524 += 2;
          v525 -= 2;
          v526 -= 8;
        }
        while (v526);
        if (v463 != v461)
          goto LABEL_328;
      }
LABEL_330:
      v533 = (float *)(v462 + 4 * (int)v788);
      v534 = v335[2];
      v535 = v335[3];
      v536 = (v535 - v534 + 1);
      celt_pitch_xcorr_c(v533, &v533[-v333 - v335[3]], &v832, v788, v535 - v534 + 1);
      if (v535 < v534)
        goto LABEL_338;
      if (v536 >= 8)
      {
        v537 = v536 & 0xFFFFFFF8;
        v538 = v537 + v534;
        v539 = (int8x16_t *)v798;
        v540 = (int32x4_t *)&v833[4 * v535 - 16 + -4 * v534];
        v541 = v537;
        do
        {
          v542 = (int8x16_t)vrev64q_s32(*v540);
          v543 = (int8x16_t)vrev64q_s32(v540[-1]);
          v539[-1] = vextq_s8(v542, v542, 8uLL);
          *v539 = vextq_s8(v543, v543, 8uLL);
          v539 += 2;
          v540 -= 2;
          v541 -= 8;
        }
        while (v541);
        if (v537 == v536)
        {
LABEL_338:
          v548 = &v533[(int)v788];
          v549 = v335[4];
          v550 = v335[5];
          v551 = (v550 - v549 + 1);
          celt_pitch_xcorr_c(v548, &v548[-v333 - v335[5]], &v832, v788, v550 - v549 + 1);
          if (v550 < v549)
            goto LABEL_346;
          if (v551 >= 8)
          {
            v552 = v551 & 0xFFFFFFF8;
            v553 = v552 + v549;
            v554 = (int8x16_t *)v798;
            v555 = (int32x4_t *)&v833[4 * v550 - 16 + -4 * v549];
            v556 = v552;
            do
            {
              v557 = (int8x16_t)vrev64q_s32(*v555);
              v558 = (int8x16_t)vrev64q_s32(v555[-1]);
              v554[-1] = vextq_s8(v557, v557, 8uLL);
              *v554 = vextq_s8(v558, v558, 8uLL);
              v554 += 2;
              v555 -= 2;
              v556 -= 8;
            }
            while (v556);
            if (v552 == v551)
            {
LABEL_346:
              v563 = &v548[(int)v788];
              v564 = v335[6];
              v565 = v335[7];
              v566 = (v565 - v564 + 1);
              celt_pitch_xcorr_c(v563, &v563[-v333 - v335[7]], &v832, v788, v565 - v564 + 1);
              if (v565 < v564)
                goto LABEL_218;
              if (v566 >= 8)
              {
                v567 = v566 & 0xFFFFFFF8;
                v568 = v567 + v564;
                v569 = (int8x16_t *)v798;
                v570 = (int32x4_t *)&v833[4 * v565 - 16 + -4 * v564];
                v571 = v567;
                do
                {
                  v572 = (int8x16_t)vrev64q_s32(*v570);
                  v573 = (int8x16_t)vrev64q_s32(v570[-1]);
                  v569[-1] = vextq_s8(v572, v572, 8uLL);
                  *v569 = vextq_s8(v573, v573, 8uLL);
                  v569 += 2;
                  v570 -= 2;
                  v571 -= 8;
                }
                while (v571);
                if (v567 == v566)
                {
LABEL_218:
                  if (a9 != 4)
                  {
                    v319 = (5 * v723);
                    v333 = v776;
                    v370 = v722 + 80 * v723;
                    v366 = (int)v788;
                    v368 = (char *)&silk_CB_lags_stage3_10_ms;
                    v364 = (char *)&silk_Lag_range_stage3_10_ms;
                    v367 = 12;
                    v369 = 12;
                    goto LABEL_222;
                  }
                  v364 = (char *)&silk_Lag_range_stage3 + 8 * v727;
                  v365 = 20 * v723;
                  v319 = (5 * v723);
                  v366 = (int)v788;
                  v333 = v776;
                  if (silk_nb_cbk_searchs_stage3[v727] > 0)
                  {
                    v367 = silk_nb_cbk_searchs_stage3[v727];
                    v368 = silk_CB_lags_stage3;
                    v369 = 34;
                    v370 = v722 + 4 * v365;
LABEL_222:
                    v371 = 0;
                    v372 = 0;
                    v373 = (v319 - 3);
                    v374 = v319 & 0xFFFFFFFC;
                    v375 = 4;
                    if (v373 > 4)
                      v375 = (v319 - 3);
                    v376 = ((v375 - 1) >> 2) + 1;
                    v377 = 4 * v366;
                    v378 = 4 * (v319 >> 2);
                    v379 = v370 + 16 * (v319 >> 2);
                    v380 = v370 - 4;
                    v381 = v796;
                    while (1)
                    {
                      v382 = v364[2 * v372];
                      v383 = v333 + v382;
                      if (v375 >= 0xD)
                      {
                        v386 = -4 * v383;
                        v385 = 0.0;
                        v387 = v376 & 0x7FFFFFFFFFFFFFFCLL;
                        do
                        {
                          v388 = (const float *)(v370 + v386);
                          v386 += 64;
                          v839 = vld4_f32(v388);
                          v388 += 8;
                          v389 = vcvtq_f64_f32(v839.val[0]);
                          v840 = vld4_f32(v388);
                          v390 = vcvtq_f64_f32(v840.val[0]);
                          v391 = vcvtq_f64_f32(v839.val[1]);
                          v392 = vcvtq_f64_f32(v840.val[1]);
                          v393 = vmlaq_f64(vmulq_f64(v391, v391), v389, v389);
                          v394 = vmlaq_f64(vmulq_f64(v392, v392), v390, v390);
                          v395 = vcvtq_f64_f32(v839.val[2]);
                          v396 = vcvtq_f64_f32(v840.val[2]);
                          *(float64x2_t *)v839.val[0].f32 = vcvtq_f64_f32(v839.val[3]);
                          *(float64x2_t *)v839.val[1].f32 = vcvtq_f64_f32(v840.val[3]);
                          v397 = vmlaq_f64(vmlaq_f64(v393, v395, v395), *(float64x2_t *)v839.val[0].f32, *(float64x2_t *)v839.val[0].f32);
                          v398 = vmlaq_f64(vmlaq_f64(v394, v396, v396), *(float64x2_t *)v839.val[1].f32, *(float64x2_t *)v839.val[1].f32);
                          v385 = v385 + v397.f64[0] + v397.f64[1] + v398.f64[0] + v398.f64[1];
                          v387 -= 4;
                        }
                        while (v387);
                        v384 = 4 * (v376 & 0x7FFFFFFFFFFFFFFCLL);
                        if (v376 == (v376 & 0x7FFFFFFFFFFFFFFCLL))
                          goto LABEL_232;
                      }
                      else
                      {
                        v384 = 0;
                        v385 = 0.0;
                      }
                      v399 = v384 + 3;
                      v400 = 4 * v384 - 4 * v383;
                      do
                      {
                        v385 = v385
                             + *(float *)(v370 + v400 + 4) * *(float *)(v370 + v400 + 4)
                             + *(float *)(v370 + v400) * *(float *)(v370 + v400)
                             + *(float *)(v370 + v400 + 8) * *(float *)(v370 + v400 + 8)
                             + *(float *)(v370 + v400 + 12) * *(float *)(v370 + v400 + 12);
                        v401 = v399 + 1;
                        v399 += 4;
                        v400 += 16;
                      }
                      while (v401 < v373);
LABEL_232:
                      LODWORD(v319) = 5 * v723;
                      if (v374 < (int)v788)
                      {
                        v402 = (float *)(v379 - 4 * v383);
                        v403 = v378;
                        do
                        {
                          v404 = *v402++;
                          v385 = v385 + v404 * v404;
                          ++v403;
                        }
                        while ((int)v788 > v403);
                      }
                      v405 = &v368[v371 & 0xFFFFFFFE];
                      v406 = -(uint64_t)v364[2 * v372];
                      v407 = v385 + 0.001;
                      v408 = v407;
                      v832 = v408;
                      v409 = v364[(2 * v372) | 1];
                      v410 = __OFSUB__(v409, v382);
                      v411 = v409 - v382;
                      if (!((v411 < 0) ^ v410 | (v411 == 0)))
                      {
                        v412 = (v411 + 1) - 1;
                        v413 = 4 * v383;
                        v414 = (float *)(v380 - 4 * v383);
                        v415 = v377 - 4 - v413;
                        v416 = (float *)v833;
                        do
                        {
                          v417 = *v414--;
                          v407 = v407 - *(float *)(v370 + v415) * *(float *)(v370 + v415) + v417 * v417;
                          v418 = v407;
                          *v416++ = v418;
                          v415 -= 4;
                          --v412;
                        }
                        while (v412);
                      }
                      v419 = v381;
                      v420 = v367;
                      do
                      {
                        v421 = *v405++;
                        v422 = &v833[4 * v421 - 4 + 4 * v406];
                        *(_OWORD *)v419 = *(_OWORD *)v422;
                        *((_DWORD *)v419 + 4) = *((_DWORD *)v422 + 4);
                        v419 += 20;
                        --v420;
                      }
                      while (v420);
                      ++v372;
                      v370 += v377;
                      v379 += v377;
                      v380 += v377;
                      v371 += v369;
                      v381 += 680;
                      v333 = v776;
                      if (v372 == a9)
                        goto LABEL_241;
                    }
                  }
                  v491 = v365;
                  v492 = (v788 - 3);
                  v493 = v788 & 0xFFFFFFFC;
                  v494 = *v364;
                  v495 = v776 + v494;
                  v496 = 4;
                  if (v492 > 4)
                    v496 = (v788 - 3);
                  if (v496 >= 0xD)
                  {
                    v499 = ((v496 - 1) >> 2) + 1;
                    v497 = 4 * (v499 & 0x7FFFFFFFFFFFFFFCLL);
                    v500 = (const float *)(v722 - 4 * v495 + 4 * v491 + 32);
                    v498 = 0.0;
                    v501 = v499 & 0x7FFFFFFFFFFFFFFCLL;
                    do
                    {
                      v502 = v500 - 8;
                      v835 = vld4_f32(v502);
                      v842 = vld4_f32(v500);
                      v503 = vcvtq_f64_f32(v835.val[0]);
                      v504 = vcvtq_f64_f32(v842.val[0]);
                      v505 = vcvtq_f64_f32(v835.val[1]);
                      v506 = vcvtq_f64_f32(v842.val[1]);
                      v507 = vmlaq_f64(vmulq_f64(v505, v505), v503, v503);
                      v508 = vmlaq_f64(vmulq_f64(v506, v506), v504, v504);
                      v509 = vcvtq_f64_f32(v835.val[2]);
                      v510 = vcvtq_f64_f32(v842.val[2]);
                      *(float64x2_t *)v835.val[0].f32 = vcvtq_f64_f32(v835.val[3]);
                      *(float64x2_t *)v835.val[1].f32 = vcvtq_f64_f32(v842.val[3]);
                      v511 = vmlaq_f64(vmlaq_f64(v507, v509, v509), *(float64x2_t *)v835.val[0].f32, *(float64x2_t *)v835.val[0].f32);
                      v512 = vmlaq_f64(vmlaq_f64(v508, v510, v510), *(float64x2_t *)v835.val[1].f32, *(float64x2_t *)v835.val[1].f32);
                      v498 = v498 + v511.f64[0] + v511.f64[1] + v512.f64[0] + v512.f64[1];
                      v500 += 16;
                      v501 -= 4;
                    }
                    while (v501);
                    if (v499 == (v499 & 0x7FFFFFFFFFFFFFFCLL))
                    {
LABEL_317:
                      if ((int)v493 >= (int)v788)
                        goto LABEL_358;
                      v517 = v788 & 0xFFFFFFFC | 1;
                      if ((int)v788 > v517)
                        v517 = 5 * v723;
                      v518 = v517 + ~(v788 & 0xFFFFFFFC);
                      if ((_DWORD)v518)
                      {
                        v519 = v518 + 1;
                        v520 = (v518 + 1) & 0x1FFFFFFFELL;
                        v521 = v520 + v493;
                        v522 = (float *)(((4 * v788) & 0x3FFFFFFF0) + 4 * v491 - 4 * v495 + v722 + 4);
                        v523 = v520;
                        do
                        {
                          v498 = v498 + *(v522 - 1) * *(v522 - 1) + *v522 * *v522;
                          v522 += 2;
                          v523 -= 2;
                        }
                        while (v523);
                        if (v519 == v520)
                        {
LABEL_358:
                          v580 = v364[1];
                          v410 = __OFSUB__(v580, v494);
                          v581 = v580 - v494;
                          if (!((v581 < 0) ^ v410 | (v581 == 0)))
                          {
                            v582 = v498 + 0.001;
                            v583 = (v581 + 1) - 1;
                            v584 = (float *)v833;
                            v585 = (float *)(v722 - 4 * v495 + 4 * v491 - 4);
                            do
                            {
                              v586 = v582 - v585[(int)v788] * v585[(int)v788];
                              v587 = *v585--;
                              v582 = v586 + v587 * v587;
                              v588 = v582;
                              *v584++ = v588;
                              --v583;
                            }
                            while (v583);
                          }
                          v589 = v364[2];
                          v590 = v776 + v589;
                          if (v492 <= 4)
                            v591 = 4;
                          else
                            v591 = (v788 - 3);
                          v592 = 4 * v491;
                          if (v591 >= 0xD)
                          {
                            v595 = ((v591 - 1) >> 2) + 1;
                            v593 = 4 * (v595 & 0x7FFFFFFFFFFFFFFCLL);
                            v596 = (const float *)(v592 + 4 * (int)v788 - 4 * v590 + v722 + 32);
                            v594 = 0.0;
                            v597 = v595 & 0x7FFFFFFFFFFFFFFCLL;
                            do
                            {
                              v598 = v596 - 8;
                              v836 = vld4_f32(v598);
                              v843 = vld4_f32(v596);
                              v599 = vcvtq_f64_f32(v836.val[0]);
                              v600 = vcvtq_f64_f32(v843.val[0]);
                              v601 = vcvtq_f64_f32(v836.val[1]);
                              v602 = vcvtq_f64_f32(v843.val[1]);
                              v603 = vmlaq_f64(vmulq_f64(v601, v601), v599, v599);
                              v604 = vmlaq_f64(vmulq_f64(v602, v602), v600, v600);
                              v605 = vcvtq_f64_f32(v836.val[2]);
                              v606 = vcvtq_f64_f32(v843.val[2]);
                              *(float64x2_t *)v836.val[0].f32 = vcvtq_f64_f32(v836.val[3]);
                              *(float64x2_t *)v836.val[1].f32 = vcvtq_f64_f32(v843.val[3]);
                              v607 = vmlaq_f64(vmlaq_f64(v603, v605, v605), *(float64x2_t *)v836.val[0].f32, *(float64x2_t *)v836.val[0].f32);
                              v608 = vmlaq_f64(vmlaq_f64(v604, v606, v606), *(float64x2_t *)v836.val[1].f32, *(float64x2_t *)v836.val[1].f32);
                              v594 = v594 + v607.f64[0] + v607.f64[1] + v608.f64[0] + v608.f64[1];
                              v596 += 16;
                              v597 -= 4;
                            }
                            while (v597);
                            if (v595 == (v595 & 0x7FFFFFFFFFFFFFFCLL))
                            {
LABEL_371:
                              if ((int)v493 >= (int)v788)
                                goto LABEL_382;
                              v613 = v788 & 0xFFFFFFFC | 1;
                              if ((int)v788 > v613)
                                v613 = 5 * v723;
                              v614 = v613 + ~(v788 & 0xFFFFFFFC);
                              if ((_DWORD)v614)
                              {
                                v615 = v614 + 1;
                                v616 = (v614 + 1) & 0x1FFFFFFFELL;
                                v617 = v616 + v493;
                                v618 = (float *)(((4 * v788) & 0x3FFFFFFF0)
                                               + 4 * v491
                                               + 4 * (int)v788
                                               - 4 * v590
                                               + v722
                                               + 4);
                                v619 = v616;
                                do
                                {
                                  v594 = v594 + *(v618 - 1) * *(v618 - 1) + *v618 * *v618;
                                  v618 += 2;
                                  v619 -= 2;
                                }
                                while (v619);
                                if (v615 == v616)
                                {
LABEL_382:
                                  v622 = v364[3];
                                  v410 = __OFSUB__(v622, v589);
                                  v623 = v622 - v589;
                                  if (!((v623 < 0) ^ v410 | (v623 == 0)))
                                  {
                                    v624 = v594 + 0.001;
                                    v625 = (v623 + 1) - 1;
                                    v626 = (float *)v833;
                                    v627 = 4 * v590;
                                    v628 = (float *)(v592 + 4 * (int)v788 - 4 * v590 + v722 - 4);
                                    v629 = (float *)(v592 + 8 * (int)v788 - v627 + v722 - 4);
                                    do
                                    {
                                      v630 = *v629--;
                                      v631 = v624 - v630 * v630;
                                      v632 = *v628--;
                                      v624 = v631 + v632 * v632;
                                      v633 = v624;
                                      *v626++ = v633;
                                      --v625;
                                    }
                                    while (v625);
                                  }
                                  v634 = v364[4];
                                  v635 = v776 + v634;
                                  if (v492 <= 4)
                                    v636 = 4;
                                  else
                                    v636 = (v788 - 3);
                                  v637 = 8 * (int)v788;
                                  if (v636 >= 0xD)
                                  {
                                    v640 = ((v636 - 1) >> 2) + 1;
                                    v638 = 4 * (v640 & 0x7FFFFFFFFFFFFFFCLL);
                                    v641 = (const float *)(v637 + 4 * v491 - 4 * v635 + v722 + 32);
                                    v639 = 0.0;
                                    v642 = v640 & 0x7FFFFFFFFFFFFFFCLL;
                                    do
                                    {
                                      v643 = v641 - 8;
                                      v837 = vld4_f32(v643);
                                      v844 = vld4_f32(v641);
                                      v644 = vcvtq_f64_f32(v837.val[0]);
                                      v645 = vcvtq_f64_f32(v844.val[0]);
                                      v646 = vcvtq_f64_f32(v837.val[1]);
                                      v647 = vcvtq_f64_f32(v844.val[1]);
                                      v648 = vmlaq_f64(vmulq_f64(v646, v646), v644, v644);
                                      v649 = vmlaq_f64(vmulq_f64(v647, v647), v645, v645);
                                      v650 = vcvtq_f64_f32(v837.val[2]);
                                      v651 = vcvtq_f64_f32(v844.val[2]);
                                      *(float64x2_t *)v837.val[0].f32 = vcvtq_f64_f32(v837.val[3]);
                                      *(float64x2_t *)v837.val[1].f32 = vcvtq_f64_f32(v844.val[3]);
                                      v652 = vmlaq_f64(vmlaq_f64(v648, v650, v650), *(float64x2_t *)v837.val[0].f32, *(float64x2_t *)v837.val[0].f32);
                                      v653 = vmlaq_f64(vmlaq_f64(v649, v651, v651), *(float64x2_t *)v837.val[1].f32, *(float64x2_t *)v837.val[1].f32);
                                      v639 = v639 + v652.f64[0] + v652.f64[1] + v653.f64[0] + v653.f64[1];
                                      v641 += 16;
                                      v642 -= 4;
                                    }
                                    while (v642);
                                    if (v640 == (v640 & 0x7FFFFFFFFFFFFFFCLL))
                                    {
LABEL_395:
                                      if ((int)v493 >= (int)v788)
                                        goto LABEL_406;
                                      v658 = v788 & 0xFFFFFFFC | 1;
                                      if ((int)v788 > v658)
                                        v658 = 5 * v723;
                                      v659 = v658 + ~(v788 & 0xFFFFFFFC);
                                      if ((_DWORD)v659)
                                      {
                                        v660 = v659 + 1;
                                        v661 = (v659 + 1) & 0x1FFFFFFFELL;
                                        v662 = v661 + v493;
                                        v663 = (float *)(((4 * v788) & 0x3FFFFFFF0)
                                                       + 8 * (int)v788
                                                       + 4 * v491
                                                       - 4 * v635
                                                       + v722
                                                       + 4);
                                        v664 = v661;
                                        do
                                        {
                                          v639 = v639 + *(v663 - 1) * *(v663 - 1) + *v663 * *v663;
                                          v663 += 2;
                                          v664 -= 2;
                                        }
                                        while (v664);
                                        if (v660 == v661)
                                        {
LABEL_406:
                                          v667 = v364[5];
                                          v410 = __OFSUB__(v667, v634);
                                          v668 = v667 - v634;
                                          if (!((v668 < 0) ^ v410 | (v668 == 0)))
                                          {
                                            v669 = v639 + 0.001;
                                            v670 = (v668 + 1) - 1;
                                            v671 = (float *)v833;
                                            v672 = 4 * v635;
                                            v673 = (float *)(v592 + 8 * (int)v788 - 4 * v635 + v722 - 4);
                                            v674 = (float *)(v592 + 12 * (int)v788 - v672 + v722 - 4);
                                            do
                                            {
                                              v675 = *v674--;
                                              v676 = v669 - v675 * v675;
                                              v677 = *v673--;
                                              v669 = v676 + v677 * v677;
                                              v678 = v669;
                                              *v671++ = v678;
                                              --v670;
                                            }
                                            while (v670);
                                          }
                                          v679 = v364[6];
                                          v680 = v776 + v679;
                                          v681 = 4;
                                          if (v492 > 4)
                                            v681 = (v788 - 3);
                                          if (v681 >= 0xD)
                                          {
                                            v684 = ((v681 - 1) >> 2) + 1;
                                            v682 = 4 * (v684 & 0x7FFFFFFFFFFFFFFCLL);
                                            v685 = (const float *)(12 * (int)v788 + 4 * v491 - 4 * v680 + v722 + 32);
                                            v683 = 0.0;
                                            v686 = v684 & 0x7FFFFFFFFFFFFFFCLL;
                                            do
                                            {
                                              v687 = v685 - 8;
                                              v838 = vld4_f32(v687);
                                              v845 = vld4_f32(v685);
                                              v688 = vcvtq_f64_f32(v838.val[0]);
                                              v689 = vcvtq_f64_f32(v845.val[0]);
                                              v690 = vcvtq_f64_f32(v838.val[1]);
                                              v691 = vcvtq_f64_f32(v845.val[1]);
                                              v692 = vmlaq_f64(vmulq_f64(v690, v690), v688, v688);
                                              v693 = vmlaq_f64(vmulq_f64(v691, v691), v689, v689);
                                              v694 = vcvtq_f64_f32(v838.val[2]);
                                              v695 = vcvtq_f64_f32(v845.val[2]);
                                              *(float64x2_t *)v838.val[0].f32 = vcvtq_f64_f32(v838.val[3]);
                                              *(float64x2_t *)v838.val[1].f32 = vcvtq_f64_f32(v845.val[3]);
                                              v696 = vmlaq_f64(vmlaq_f64(v692, v694, v694), *(float64x2_t *)v838.val[0].f32, *(float64x2_t *)v838.val[0].f32);
                                              v697 = vmlaq_f64(vmlaq_f64(v693, v695, v695), *(float64x2_t *)v838.val[1].f32, *(float64x2_t *)v838.val[1].f32);
                                              v683 = v683 + v696.f64[0] + v696.f64[1] + v697.f64[0] + v697.f64[1];
                                              v685 += 16;
                                              v686 -= 4;
                                            }
                                            while (v686);
                                            if (v684 == (v684 & 0x7FFFFFFFFFFFFFFCLL))
                                            {
LABEL_418:
                                              if ((int)v493 < (int)v788)
                                              {
                                                v702 = v788 & 0xFFFFFFFC | 1;
                                                if ((int)v788 > v702)
                                                  v702 = 5 * v723;
                                                v703 = v702 + ~(v788 & 0xFFFFFFFC);
                                                if (!(_DWORD)v703)
                                                  goto LABEL_425;
                                                v704 = v703 + 1;
                                                v493 += v704 & 0x1FFFFFFFELL;
                                                v705 = (float *)(((4 * v788) & 0x3FFFFFFF0)
                                                               + 12 * (int)v788
                                                               + 4 * v491
                                                               - 4 * v680
                                                               + v722
                                                               + 4);
                                                v706 = v704 & 0x1FFFFFFFELL;
                                                do
                                                {
                                                  v683 = v683 + *(v705 - 1) * *(v705 - 1) + *v705 * *v705;
                                                  v705 += 2;
                                                  v706 -= 2;
                                                }
                                                while (v706);
                                                if (v704 != (v704 & 0x1FFFFFFFELL))
                                                {
LABEL_425:
                                                  v707 = (float *)(v722
                                                                 + 12 * (int)v788
                                                                 + 4 * v493
                                                                 + 4 * v491
                                                                 - 4 * v680);
                                                  do
                                                  {
                                                    v708 = *v707++;
                                                    v683 = v683 + v708 * v708;
                                                    LODWORD(v493) = v493 + 1;
                                                  }
                                                  while ((int)v788 > (int)v493);
                                                }
                                              }
                                              v709 = v364[7];
                                              v410 = __OFSUB__(v709, v679);
                                              v710 = v709 - v679;
                                              if (!((v710 < 0) ^ v410 | (v710 == 0)))
                                              {
                                                v711 = v683 + 0.001;
                                                v712 = (v710 + 1) - 1;
                                                v713 = (float *)v833;
                                                v714 = (float *)(v592 + 12 * (int)v788 - 4 * v680 + v722 - 4);
                                                v715 = (float *)(v592 + 16 * (int)v788 - 4 * v680 + v722 - 4);
                                                do
                                                {
                                                  v716 = *v715--;
                                                  v717 = v711 - v716 * v716;
                                                  v718 = *v714--;
                                                  v711 = v717 + v718 * v718;
                                                  v719 = v711;
                                                  *v713++ = v719;
                                                  --v712;
                                                }
                                                while (v712);
                                              }
LABEL_241:
                                              if (a9 == 4)
                                              {
                                                v423 = silk_nb_cbk_searchs_stage3[v727];
                                                v424 = silk_CB_lags_stage3;
                                                v425 = 34;
                                              }
                                              else
                                              {
                                                v424 = (char *)&silk_CB_lags_stage3_10_ms;
                                                v425 = 12;
                                                v423 = 12;
                                              }
                                              v324 = v726;
                                              v325 = v722;
                                              v318 = v723;
                                              goto LABEL_246;
                                            }
                                          }
                                          else
                                          {
                                            v682 = 0;
                                            v683 = 0.0;
                                          }
                                          v698 = (float *)(12 * (int)v788 + 4 * v682 + 4 * v491 - 4 * v680 + v722 + 8);
                                          do
                                          {
                                            v699 = *(v698 - 1) * *(v698 - 1) + *(v698 - 2) * *(v698 - 2);
                                            v700 = *v698;
                                            v701 = v698[1];
                                            v698 += 4;
                                            v683 = v683 + v699 + v700 * v700 + v701 * v701;
                                            v682 += 4;
                                          }
                                          while (v682 < v492);
                                          goto LABEL_418;
                                        }
                                      }
                                      else
                                      {
                                        v662 = v788 & 0xFFFFFFFC;
                                      }
                                      v665 = (float *)(v722 + v637 + 4 * v662 + 4 * v491 - 4 * v635);
                                      do
                                      {
                                        v666 = *v665++;
                                        v639 = v639 + v666 * v666;
                                        LODWORD(v662) = v662 + 1;
                                      }
                                      while ((int)v788 > (int)v662);
                                      goto LABEL_406;
                                    }
                                  }
                                  else
                                  {
                                    v638 = 0;
                                    v639 = 0.0;
                                  }
                                  v654 = (float *)(v637 + 4 * v638 + 4 * v491 - 4 * v635 + v722 + 8);
                                  do
                                  {
                                    v655 = *(v654 - 1) * *(v654 - 1) + *(v654 - 2) * *(v654 - 2);
                                    v656 = *v654;
                                    v657 = v654[1];
                                    v654 += 4;
                                    v639 = v639 + v655 + v656 * v656 + v657 * v657;
                                    v638 += 4;
                                  }
                                  while (v638 < v492);
                                  goto LABEL_395;
                                }
                              }
                              else
                              {
                                v617 = v788 & 0xFFFFFFFC;
                              }
                              v620 = (float *)(v722 + 4 * v617 + 4 * v491 + 4 * (int)v788 - 4 * v590);
                              do
                              {
                                v621 = *v620++;
                                v594 = v594 + v621 * v621;
                                LODWORD(v617) = v617 + 1;
                              }
                              while ((int)v788 > (int)v617);
                              goto LABEL_382;
                            }
                          }
                          else
                          {
                            v593 = 0;
                            v594 = 0.0;
                          }
                          v609 = (float *)(4 * v593 + 4 * v491 + 4 * (int)v788 - 4 * v590 + v722 + 8);
                          do
                          {
                            v610 = *(v609 - 1) * *(v609 - 1) + *(v609 - 2) * *(v609 - 2);
                            v611 = *v609;
                            v612 = v609[1];
                            v609 += 4;
                            v594 = v594 + v610 + v611 * v611 + v612 * v612;
                            v593 += 4;
                          }
                          while (v593 < v492);
                          goto LABEL_371;
                        }
                      }
                      else
                      {
                        v521 = v788 & 0xFFFFFFFC;
                      }
                      v578 = (float *)(v722 + 4 * v521 + 4 * v491 - 4 * v495);
                      do
                      {
                        v579 = *v578++;
                        v498 = v498 + v579 * v579;
                        LODWORD(v521) = v521 + 1;
                      }
                      while ((int)v788 > (int)v521);
                      goto LABEL_358;
                    }
                  }
                  else
                  {
                    v497 = 0;
                    v498 = 0.0;
                  }
                  v513 = (float *)(4 * v497 + 4 * v491 - 4 * v495 + v722 + 8);
                  do
                  {
                    v514 = *(v513 - 1) * *(v513 - 1) + *(v513 - 2) * *(v513 - 2);
                    v515 = *v513;
                    v516 = v513[1];
                    v513 += 4;
                    v498 = v498 + v514 + v515 * v515 + v516 * v516;
                    v497 += 4;
                  }
                  while (v497 < v492);
                  goto LABEL_317;
                }
              }
              else
              {
                v567 = 0;
                v568 = v564;
              }
              v574 = (int *)&v833[4 * v565 - 4 + -4 * v568];
              v575 = v566 - v567;
              v576 = &v796[2 * v567];
              do
              {
                v577 = *v574--;
                *v576++ = v577;
                --v575;
              }
              while (v575);
              goto LABEL_218;
            }
          }
          else
          {
            v552 = 0;
            v553 = v549;
          }
          v559 = (int *)&v833[4 * v550 - 4 + -4 * v553];
          v560 = v551 - v552;
          v561 = &v796[2 * v552];
          do
          {
            v562 = *v559--;
            *v561++ = v562;
            --v560;
          }
          while (v560);
          goto LABEL_346;
        }
      }
      else
      {
        v537 = 0;
        v538 = v534;
      }
      v544 = (int *)&v833[4 * v535 - 4 + -4 * v538];
      v545 = v536 - v537;
      v546 = &v796[2 * v537];
      do
      {
        v547 = *v544--;
        *v546++ = v547;
        --v545;
      }
      while (v545);
      goto LABEL_338;
    }
    if (v178 == 1)
    {
      v184 = 0;
    }
    else
    {
      v184 = v178 & 0xFFFFFFFE;
      v186 = &v801[0].i32[1];
      v187 = v184;
      do
      {
        v188 = *v186;
        v799[*(v186 - 1)] = 1;
        v799[v188] = 1;
        v186 += 2;
        v187 -= 2;
      }
      while (v187);
      if (v184 == v178)
        goto LABEL_107;
    }
    v189 = v178 - v184;
    v190 = &v801[0].i32[v184];
    do
    {
      v191 = *v190++;
      v799[v191] = 1;
      --v189;
    }
    while (v189);
LABEL_107:
    v185 = v799[145];
    goto LABEL_108;
  }
  bzero(v726, 4 * a9);
  LOBYTE(v179) = 0;
  *v728 = 0.0;
  *v724 = 0;
  result = 1;
LABEL_289:
  *v725 = v179;
  return result;
}

void silk_PLC(uint64_t a1, int32x4_t *a2, uint64_t a3, int a4, int a5)
{
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  __int8 *v18;
  uint64_t v19;
  BOOL v20;
  unsigned int v21;
  int v22;
  int v23;

  v7 = *(_DWORD *)(a1 + 2316);
  if (v7 != *(_DWORD *)(a1 + 4276))
  {
    *(_DWORD *)(a1 + 4196) = *(_DWORD *)(a1 + 2328) << 7;
    *(_QWORD *)(a1 + 4268) = 0x1000000010000;
    *(_QWORD *)(a1 + 4280) = 0x1400000002;
    *(_DWORD *)(a1 + 4276) = v7;
  }
  if (a4)
  {
    silk_PLC_conceal(a1, a2, a3, a5);
    ++*(_DWORD *)(a1 + 4184);
  }
  else
  {
    v8 = *(char *)(a1 + 2789);
    *(_DWORD *)(a1 + 4188) = v8;
    if (v8 == 2)
    {
      v9 = 0;
      v10 = *(unsigned int *)(a1 + 2324);
      if ((_DWORD)v10)
      {
        v11 = (int)v10 - 1;
        v12 = a2->i32[v11];
        if (v12 >= 1)
        {
          v9 = 0;
          v13 = *(int *)(a1 + 2332);
          v14 = ((_DWORD)v10 << 16) - 0x10000;
          v15 = 5 * v10 - 5;
          v16 = v13;
          do
          {
            v17 = vaddvq_s32(vmovl_s16(*(int16x4_t *)&a2[6].i8[2 * v15])) + a2[6].i16[v15 + 4];
            if (v17 > (int)v9)
            {
              v18 = &a2->i8[10 * (v14 >> 16)];
              v19 = *((_QWORD *)v18 + 12);
              *(_WORD *)(a1 + 4208) = *((_WORD *)v18 + 52);
              *(_QWORD *)(a1 + 4200) = v19;
              *(_DWORD *)(a1 + 4196) = a2->i32[(int)v10 - 1] << 8;
              v12 = a2->i32[v11];
              v9 = v17;
            }
            if (!--v10)
              break;
            v14 -= 0x10000;
            v15 -= 5;
            v20 = v16 < v12;
            v16 += v13;
          }
          while (v20);
        }
      }
      *(_QWORD *)(a1 + 4200) = 0;
      *(_WORD *)(a1 + 4208) = 0;
      *(_WORD *)(a1 + 4204) = v9;
      if ((int)v9 > 11468)
      {
        if (v9 >= 0x3CCE)
        {
          *(_WORD *)(a1 + 4200) = (0xF334000 / v9 * *(__int16 *)(a1 + 4200)) >> 14;
          *(_WORD *)(a1 + 4202) = (0xF334000 / v9 * *(__int16 *)(a1 + 4202)) >> 14;
          *(_WORD *)(a1 + 4204) = (0xF334000 / v9 * (__int16)v9) >> 14;
          *(_WORD *)(a1 + 4206) = (0xF334000 / v9 * *(__int16 *)(a1 + 4206)) >> 14;
          *(_WORD *)(a1 + 4208) = (0xF334000 / v9 * *(__int16 *)(a1 + 4208)) >> 14;
        }
      }
      else
      {
        if ((int)v9 <= 1)
          v21 = 1;
        else
          v21 = v9;
        v22 = (__int16)(0xB33400 / v21);
        *(_WORD *)(a1 + 4200) = (v22 * *(__int16 *)(a1 + 4200)) >> 10;
        *(_WORD *)(a1 + 4202) = (v22 * *(__int16 *)(a1 + 4202)) >> 10;
        *(_WORD *)(a1 + 4204) = (v22 * v9) >> 10;
        *(_WORD *)(a1 + 4206) = (v22 * *(__int16 *)(a1 + 4206)) >> 10;
        *(_WORD *)(a1 + 4208) = (v22 * *(__int16 *)(a1 + 4208)) >> 10;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4196) = 4608 * (__int16)v7;
      *(_QWORD *)(a1 + 4200) = 0;
      *(_WORD *)(a1 + 4208) = 0;
    }
    memcpy((void *)(a1 + 4210), &a2[4], 2 * *(int *)(a1 + 2340));
    *(_WORD *)(a1 + 4264) = a2[8].i32[2];
    v23 = *(_DWORD *)(a1 + 2324);
    *(_QWORD *)(a1 + 4268) = *(uint64_t *)((char *)&a2->i64[1] + 4 * v23);
    *(_DWORD *)(a1 + 4284) = *(_DWORD *)(a1 + 2332);
    *(_DWORD *)(a1 + 4280) = v23;
  }
}

int32x4_t silk_PLC_conceal(uint64_t a1, int32x4_t *a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  char *v22;
  __int16 v23;
  uint64_t v24;
  int v25;
  __int16 *v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  int v35;
  unsigned int v36;
  char v37;
  int v38;
  unsigned int v39;
  int v40;
  char v41;
  int v42;
  unsigned int v43;
  int v44;
  unint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  char *v55;
  char *v56;
  int v57;
  int v58;
  int v59;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  int16x4_t v64;
  unsigned int v65;
  int16x4_t v66;
  char *v67;
  char *v68;
  int v69;
  char *v70;
  int v71;
  char *v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  unint64_t v83;
  int v84;
  int v85;
  int v86;
  uint64_t v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  unint64_t v93;
  unsigned int v94;
  __int16 v95;
  uint64_t v96;
  int *v97;
  unint64_t v98;
  int v99;
  unint64_t v100;
  int v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int32x4_t v106;
  int32x4_t v107;
  int16x4_t *v108;
  int32x4_t v109;
  int32x4_t v110;
  char *v111;
  int8x16_t v112;
  int32x4_t v113;
  int8x16_t v114;
  int32x4_t v115;
  int8x16_t v116;
  int32x4_t v117;
  int8x16_t v118;
  int32x4_t v119;
  int16x8_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  uint64_t v125;
  __int16 *v126;
  int *v127;
  int v128;
  int v129;
  int v130;
  char *v131;
  __int128 v132;
  _OWORD *v133;
  __int128 v134;
  uint64_t v135;
  int32x4_t result;
  _QWORD v137[2];
  int32x4_t *v138;
  int16x4_t *v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  char *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  int16x4_t v152;
  __int16 v153;
  __int16 v154;
  __int16 v155;
  __int16 v156;
  __int16 v157;
  __int16 v158;
  uint64_t v159;

  LODWORD(v149) = a4;
  v146 = a3;
  v4 = a1;
  v137[1] = v137;
  v138 = a2;
  v159 = *MEMORY[0x24BDAC8D0];
  v5 = MEMORY[0x24BDAC7A8](a1, a2);
  v145 = (char *)v137 - v6;
  v7 = *(_DWORD *)(v5 + 2336);
  v9 = (_DWORD *)MEMORY[0x24BDAC7A8](v5, v8);
  v11 = (char *)v137 - ((v10 + 15) & 0x3FFFFFFF0);
  v12 = ((int)v9[1067] >> 6);
  v13 = ((int)v9[1068] >> 6);
  if (v9[594])
  {
    *(_OWORD *)(v4 + 4226) = 0u;
    *(_OWORD *)(v4 + 4210) = 0u;
  }
  v150 = 0;
  v151 = 0;
  silk_PLC_energy((uint64_t)&v150 + 4, (uint64_t)&v151 + 4, (uint64_t)&v150, (uint64_t)&v151, v4 + 4, v12, v13, *(unsigned int *)(v4 + 2332), *(_DWORD *)(v4 + 2324));
  v14 = *(_DWORD *)(v4 + 4280);
  if (SHIDWORD(v150) >> v151 >= (int)v150 >> SBYTE4(v151))
  {
    v15 = *(_DWORD *)(v4 + 4284);
  }
  else
  {
    v15 = v14 - 1;
    v14 = *(_DWORD *)(v4 + 4284);
  }
  v16 = v15 * v14;
  if (v16 <= 128)
    v16 = 128;
  v144 = v16;
  LOWORD(v17) = *(_WORD *)(v4 + 4252);
  v18 = *(_DWORD *)(v4 + 4184);
  if (v18 >= 1)
    v19 = 1;
  else
    v19 = *(_DWORD *)(v4 + 4184);
  v20 = 2 * v19;
  LODWORD(v147) = *(__int16 *)((char *)&HARM_ATT_Q15 + v20);
  v21 = *(_DWORD *)(v4 + 4188);
  v22 = (char *)&PLC_RAND_ATTENUATE_UV_Q15;
  if (v21 == 2)
    v22 = (char *)&PLC_RAND_ATTENUATE_V_Q15;
  v23 = *(_WORD *)&v22[v20];
  v24 = *(unsigned int *)(v4 + 2340);
  v25 = 64881;
  if ((int)v24 >= 2)
  {
    v26 = (__int16 *)(v4 + 4210);
    v27 = (v24 - 1);
    do
    {
      *v26 = (((v25 * *v26) >> 15) + 1) >> 1;
      ++v26;
      v25 += (((-655 * v25) >> 15) + 1) >> 1;
      --v27;
    }
    while (v27);
  }
  *(_WORD *)(v4 + 4210 + 2 * ((int)v24 - 1)) = (((v25 * *(__int16 *)(v4 + 4210 + 2 * ((int)v24 - 1))) >> 15)
                                                + 1) >> 1;
  __memcpy_chk();
  if (v18)
  {
    LOWORD(v28) = v23;
  }
  else if (v21 == 2)
  {
    LOWORD(v28) = v23;
    v29 = (__int16)(0x4000 - (vaddv_s16(*(int16x4_t *)(v4 + 4200)) + *(_WORD *)(v4 + 4208)));
    if (v29 <= 3277)
      v29 = 3277;
    v17 = (v29 * *(__int16 *)(v4 + 4264)) >> 14;
  }
  else
  {
    v30 = silk_LPC_inverse_pred_gain_c((int16x8_t *)(v4 + 4210), v24);
    if (v30 >= 0x8000000)
      v31 = 0x8000000;
    else
      v31 = v30;
    if (v31 <= 0x400000)
      v31 = 0x400000;
    v28 = (int)(((unint64_t)(8 * v31) * v23) >> 16) >> 14;
    v24 = *(unsigned int *)(v4 + 2340);
    v7 = *(_DWORD *)(v4 + 2336);
    LOWORD(v17) = 0x4000;
  }
  v32 = *(_DWORD *)(v4 + 4248);
  v33 = ((*(int *)(v4 + 4196) >> 7) + 1) >> 1;
  v34 = v7 - v24 - v33 - 2;
  silk_LPC_analysis_filter(&v11[2 * v34], v4 + 2 * v34 + 1348, &v152, 2 - (-(int)v24 - v33), v24);
  v35 = *(_DWORD *)(v4 + 4272);
  if (v35 >= 0)
    v36 = *(_DWORD *)(v4 + 4272);
  else
    v36 = -v35;
  v37 = __clz(v36);
  v38 = ((unint64_t)((int)((unint64_t)-(uint64_t)((((uint64_t)(0x1FFFFFFF / (v35 << (v37 - 1) >> 16)) << 19)
                                                              * (v35 << (v37 - 1))) & 0xFFFFFFF800000000) >> 32)
                          * (uint64_t)(0x1FFFFFFF / (v35 << (v37 - 1) >> 16))) >> 16)
      + ((0x1FFFFFFF / (v35 << (v37 - 1) >> 16)) << 16);
  v39 = HIWORD(v36);
  v40 = v38 >> (16 - v37);
  v41 = v37 - 16;
  v42 = (int)0x80000000 >> v41;
  if (v38 > (int)0x80000000 >> v41)
    v42 = v38;
  if (v38 <= (int)(0x7FFFFFFFu >> v41))
    v43 = v42;
  else
    v43 = 0x7FFFFFFFu >> v41;
  v44 = v43 << v41;
  if (v39)
    v44 = v40;
  v149 = *(unsigned int *)(v4 + 2340);
  LODWORD(v45) = v149 + v34;
  v46 = *(int *)(v4 + 2336);
  v47 = v145;
  if ((int)v149 + v34 < (int)v46)
  {
    if (v44 >= 0x3FFFFFFF)
      v44 = 0x3FFFFFFF;
    v48 = (int)v45;
    v49 = v46 - (int)v45;
    v45 = (int)v45;
    if (v49 < 2)
      goto LABEL_45;
    v45 = (v49 & 0xFFFFFFFFFFFFFFFELL) + (int)v45;
    v50 = &v11[2 * v48 + 2];
    v51 = &v145[4 * v48 + 4];
    v52 = v49 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v53 = (unint64_t)(*(__int16 *)v50 * (uint64_t)v44) >> 16;
      *((_DWORD *)v51 - 1) = (unint64_t)(*((__int16 *)v50 - 1) * (uint64_t)v44) >> 16;
      *(_DWORD *)v51 = v53;
      v50 += 4;
      v51 += 8;
      v52 -= 2;
    }
    while (v52);
    if (v49 != (v49 & 0xFFFFFFFFFFFFFFFELL))
    {
LABEL_45:
      v54 = v46 - v45;
      v55 = &v47[4 * v45];
      v56 = &v11[2 * v45];
      do
      {
        v57 = *(__int16 *)v56;
        v56 += 2;
        *(_DWORD *)v55 = (unint64_t)(v57 * (uint64_t)v44) >> 16;
        v55 += 4;
        --v54;
      }
      while (v54);
    }
  }
  v58 = *(_DWORD *)(v4 + 2324);
  v148 = v4;
  if (v58 >= 1)
  {
    v142 = v46;
    v143 = v13;
    v59 = 0;
    v60 = v4 + 4 * (v144 - 128) + 4;
    v61 = *(_DWORD *)(v4 + 2332);
    v62 = 4608 * *(__int16 *)(v4 + 2316);
    v63 = *(_DWORD *)(v4 + 4196);
    v64 = *(int16x4_t *)(v4 + 4200);
    v65 = *(unsigned __int16 *)(v4 + 4208);
    v66 = vdup_n_s16(v147);
    do
    {
      if (v61 >= 1)
      {
        v67 = &v145[4 * v7];
        v68 = &v47[4 * (v7 - v33 + 2) - 8];
        v69 = v61;
        v70 = v68;
        do
        {
          v71 = *((_DWORD *)v70 + 1);
          v70 += 4;
          v32 = 196314165 * v32 + 907633515;
          *(_DWORD *)v67 = 4
                         * ((((((v64.u16[1] << 16) * (uint64_t)v71) & 0xFFFFFFFF00000000)
                            + (v64.u16[0] << 16) * (uint64_t)*((int *)v68 + 2)
                            + (((v64.u16[2] << 16) * (uint64_t)*(int *)v68) & 0xFFFFFFFF00000000)
                            + (((v64.u16[3] << 16) * (uint64_t)*((int *)v68 - 1)) & 0xFFFFFFFF00000000)
                            + (((int)(v65 << 16) * (uint64_t)*((int *)v68 - 2)) & 0x3FFFFFFF00000000)
                            + 0x200000000) >> 32)
                          + ((unint64_t)(*(int *)(v60 + 4 * (v32 >> 25)) * (uint64_t)(__int16)v17) >> 16));
          v67 += 4;
          ++v7;
          v68 = v70;
          --v69;
        }
        while (v69);
      }
      v64 = vshrn_n_s32(vmull_s16(v66, v64), 0xFuLL);
      v65 = ((__int16)v65 * (_DWORD)v147) >> 15;
      v17 = ((__int16)v28 * (__int16)v17) >> 15;
      v63 += (unint64_t)(655 * v63) >> 16;
      if (v63 >= v62)
        v63 = v62;
      v4 = v148;
      *(_DWORD *)(v148 + 4196) = v63;
      v33 = ((v63 >> 7) + 1) >> 1;
      ++v59;
    }
    while (v59 != v58);
    *(_WORD *)(v4 + 4208) = v65;
    *(int16x4_t *)(v4 + 4200) = v64;
    v47 = v145;
    LODWORD(v46) = v142;
    LODWORD(v13) = v143;
  }
  v72 = &v47[4 * (int)v46 - 64];
  v73 = *(_OWORD *)(v4 + 1300);
  *(_OWORD *)v72 = *(_OWORD *)(v4 + 1284);
  *((_OWORD *)v72 + 1) = v73;
  v74 = *(_OWORD *)(v4 + 1316);
  v75 = *(_OWORD *)(v4 + 1332);
  v137[0] = v4 + 1284;
  *((_OWORD *)v72 + 2) = v74;
  *((_OWORD *)v72 + 3) = v75;
  v76 = *(unsigned int *)(v4 + 2328);
  if ((int)v76 >= 1)
  {
    v77 = 0;
    v147 = v152.i16[0];
    v145 = (char *)v152.i16[1];
    v144 = (int)v149 >> 1;
    v142 = v152.i16[3];
    v143 = v152.i16[2];
    v78 = v153;
    v79 = v154;
    v80 = v155;
    v81 = v13;
    v82 = v156;
    v141 = v149 - 10;
    v83 = (v149 - 10) & 0xFFFFFFFFFFFFFFF0;
    v84 = v157;
    v140 = v83 | 0xA;
    v139 = (int16x4_t *)((char *)&v159 + 4);
    v85 = v158;
    v86 = *((_DWORD *)v72 + 15);
    v87 = (uint64_t)&v47[4 * (int)v46 - 4];
    v88 = *((_DWORD *)v72 + 13);
    v89 = *((_DWORD *)v72 + 11);
    v90 = *((_DWORD *)v72 + 9);
    v91 = *((_DWORD *)v72 + 7);
    do
    {
      v96 = v77 + 16;
      v97 = (int *)&v72[4 * v77];
      v98 = (int)v143 * (uint64_t)v88;
      v88 = v97[14];
      v99 = v144
          + ((unint64_t)((int)v147 * (uint64_t)v86) >> 16)
          + (v98 >> 16)
          + ((unint64_t)(v88 * (uint64_t)(int)v145) >> 16);
      v100 = v78 * (uint64_t)v89;
      v89 = v97[12];
      v101 = v99 + ((unint64_t)(v89 * (uint64_t)(int)v142) >> 16) + (v100 >> 16);
      v102 = v80 * (uint64_t)v90;
      v90 = v97[10];
      v103 = v84 * (uint64_t)v91;
      v91 = v97[8];
      v92 = v101
          + ((unint64_t)(v90 * (uint64_t)v79) >> 16)
          + (v102 >> 16)
          + ((unint64_t)(v91 * (uint64_t)v82) >> 16)
          + (v103 >> 16)
          + ((unint64_t)(v97[6] * (uint64_t)v85) >> 16);
      if ((int)v149 >= 11)
      {
        if (v141 >= 0x10)
        {
          v105 = 0;
          v106 = 0uLL;
          v107 = (int32x4_t)v92;
          v108 = v139;
          v109 = 0uLL;
          v110 = 0uLL;
          do
          {
            v111 = &v72[4 * v96 + 4 * (v105 ^ 0x3FFFFFFFFFFFFFF5)];
            v112 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v111 - 28));
            v113 = (int32x4_t)vextq_s8(v112, v112, 8uLL);
            v114 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v111 - 12));
            v115 = (int32x4_t)vextq_s8(v114, v114, 8uLL);
            v116 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v111 - 60));
            v117 = (int32x4_t)vextq_s8(v116, v116, 8uLL);
            v118 = (int8x16_t)vrev64q_s32(*(int32x4_t *)(v111 - 44));
            v119 = (int32x4_t)vextq_s8(v118, v118, 8uLL);
            v120 = *(int16x8_t *)v108[-2].i8;
            v121 = vmovl_s16(*(int16x4_t *)v120.i8);
            v122 = vmovl_high_s16(v120);
            v123 = vmovl_s16(*v108);
            v124 = vmovl_high_s16(*(int16x8_t *)v108->i8);
            v106 = vaddq_s32(v106, vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v122.i8, *(int32x2_t *)v113.i8), 0x10uLL), vmull_high_s32(v122, v113), 0x10uLL));
            v107 = vaddq_s32(v107, vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v121.i8, *(int32x2_t *)v115.i8), 0x10uLL), vmull_high_s32(v121, v115), 0x10uLL));
            v110 = vaddq_s32(v110, vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v124.i8, *(int32x2_t *)v117.i8), 0x10uLL), vmull_high_s32(v124, v117), 0x10uLL));
            v109 = vaddq_s32(v109, vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v123.i8, *(int32x2_t *)v119.i8), 0x10uLL), vmull_high_s32(v123, v119), 0x10uLL));
            v105 += 16;
            v108 += 4;
          }
          while (v83 != v105);
          v92 = vaddvq_s32(vaddq_s32(vaddq_s32(v109, v107), vaddq_s32(v110, v106)));
          v104 = v140;
          if (v141 == v83)
            goto LABEL_59;
        }
        else
        {
          v104 = 10;
        }
        v125 = v149 - v104;
        v126 = (__int16 *)&v152 + v104;
        v127 = (int *)(v87 - 4 * v104);
        do
        {
          v129 = *v127--;
          v128 = v129;
          v130 = *v126++;
          v92 += (unint64_t)(v130 * (uint64_t)v128) >> 16;
          --v125;
        }
        while (v125);
      }
LABEL_59:
      if (v92 <= -134217728)
        v92 = -134217728;
      if (v92 >= 0x7FFFFFF)
        v92 = 0x7FFFFFF;
      v86 = vqadds_s32(*(_DWORD *)&v72[4 * v96], 16 * v92);
      *(_DWORD *)&v72[4 * v96] = v86;
      v93 = (unint64_t)(v81 * (uint64_t)v86) >> 16;
      v94 = ((v93 >> 7) + 1) >> 1;
      if ((int)v93 < -8388736)
        LOWORD(v94) = 0x8000;
      if ((int)v93 <= 8388479)
        v95 = v94;
      else
        v95 = 0x7FFF;
      *(_WORD *)(v146 + 2 * v77++) = v95;
      v87 += 4;
    }
    while (v77 != v76);
  }
  v131 = &v72[4 * (int)v76];
  v132 = *((_OWORD *)v131 + 1);
  v133 = (_OWORD *)v137[0];
  *(_OWORD *)v137[0] = *(_OWORD *)v131;
  v133[1] = v132;
  v134 = *((_OWORD *)v131 + 3);
  v133[2] = *((_OWORD *)v131 + 2);
  v133[3] = v134;
  v135 = v148;
  *(_DWORD *)(v148 + 4248) = v32;
  *(_WORD *)(v135 + 4252) = v17;
  result = vdupq_n_s32(v33);
  *v138 = result;
  return result;
}

_DWORD *silk_PLC_glue_frames(_DWORD *result, __int16 *a2, signed int a3)
{
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unint64_t v16;
  int32x4_t v17;
  int32x4_t v18;
  const __int16 *v19;
  uint32x4_t v20;
  uint64_t v21;
  int32x4_t v22;
  int32x4_t v23;
  const __int16 *v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  unsigned int v31;
  unint64_t v32;
  const __int16 *v33;
  int32x4_t v34;
  uint32x4_t v35;
  uint64_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int32x4_t v39;
  const __int16 *v40;
  int v41;
  unsigned int v42;
  unint64_t v43;
  int32x4_t v44;
  int32x4_t v45;
  const __int16 *v46;
  uint32x4_t v47;
  uint64_t v48;
  int32x4_t v49;
  int32x4_t v50;
  const __int16 *v51;
  int v52;
  unsigned int v53;
  signed int v54;
  unint64_t v55;
  unint64_t v56;
  int v57;
  unsigned int v58;
  unint64_t v59;
  const __int16 *v60;
  int32x4_t v61;
  uint32x4_t v62;
  uint64_t v63;
  int32x4_t v64;
  int32x4_t v65;
  int32x4_t v66;
  const __int16 *v67;
  int v68;
  signed int v69;
  signed int v70;
  unsigned int v71;
  signed int v72;
  int v73;
  unsigned int v74;
  unsigned int v75;
  BOOL v76;
  int v77;
  int v78;
  unsigned int v79;
  signed int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  int16x8x2_t v84;
  int16x8x2_t v85;
  int16x8x2_t v86;
  int16x8x2_t v87;
  int16x8x2_t v88;
  int16x8x2_t v89;
  int16x8x2_t v90;
  int16x8x2_t v91;

  if (result[1046])
  {
    v3 = __clz(a3);
    v4 = 31 - v3;
    v5 = (a3 - 1);
    if (a3 < 2)
    {
      v15 = 0;
      v8 = a3;
      if (a3 <= 0)
      {
LABEL_21:
        v26 = v3 + __clz(v8);
        v27 = (34 - v26) & ~((int)(34 - v26) >> 31);
        if (a3 < 2)
        {
          v31 = 0;
          v30 = 0;
          if (a3 <= 0)
            goto LABEL_34;
          goto LABEL_33;
        }
        v28 = 2;
        if (v5 > 2)
          v28 = (a3 - 1);
        if (v28 >= 0x1F)
        {
          v32 = ((v28 - 1) >> 1) + 1;
          v29 = 2 * (v32 & 0x7FFFFFFFFFFFFFF0);
          v33 = a2 + 16;
          v34 = 0uLL;
          v35 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v27));
          v36 = v32 & 0x7FFFFFFFFFFFFFF0;
          v37 = 0uLL;
          v38 = 0uLL;
          v39 = 0uLL;
          do
          {
            v40 = v33 - 16;
            v85 = vld2q_s16(v40);
            v89 = vld2q_s16(v33);
            v37 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v85.val[1], v85.val[1]), v85.val[0], v85.val[0]), v35), v37);
            v34 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v85.val[1].i8, *(int16x4_t *)v85.val[1].i8), *(int16x4_t *)v85.val[0].i8, *(int16x4_t *)v85.val[0].i8), v35), v34);
            v39 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v89.val[1], v89.val[1]), v89.val[0], v89.val[0]), v35), v39);
            v38 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v89.val[1].i8, *(int16x4_t *)v89.val[1].i8), *(int16x4_t *)v89.val[0].i8, *(int16x4_t *)v89.val[0].i8), v35), v38);
            v33 += 32;
            v36 -= 16;
          }
          while (v36);
          v30 = vaddvq_s32(vaddq_s32(vaddq_s32(v38, v34), vaddq_s32(v39, v37)));
          if (v32 == (v32 & 0x7FFFFFFFFFFFFFF0))
          {
LABEL_32:
            v31 = a3 & 0xFFFFFFFE;
            if ((int)(a3 & 0xFFFFFFFE) >= a3)
            {
LABEL_34:
              result[1065] = v27;
              result[1064] = v30;
              result[1061] = 1;
              return result;
            }
LABEL_33:
            v41 = a2[v31];
            v30 += (v41 * v41) >> v27;
            goto LABEL_34;
          }
        }
        else
        {
          v29 = 0;
          v30 = 0;
        }
        do
        {
          v30 += (a2[v29] * a2[v29] + a2[v29 + 1] * a2[v29 + 1]) >> v27;
          v29 += 2;
        }
        while (v29 < v5);
        goto LABEL_32;
      }
LABEL_20:
      v25 = a2[v15];
      v8 += (v25 * v25) >> v4;
      goto LABEL_21;
    }
    v6 = 2;
    if (v5 > 2)
      v6 = (a3 - 1);
    if (v6 >= 0x1F)
    {
      v16 = ((v6 - 1) >> 1) + 1;
      v7 = 2 * (v16 & 0x7FFFFFFFFFFFFFF0);
      v17 = (int32x4_t)a3;
      v18 = 0uLL;
      v19 = a2 + 16;
      v20 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v4));
      v21 = v16 & 0x7FFFFFFFFFFFFFF0;
      v22 = 0uLL;
      v23 = 0uLL;
      do
      {
        v24 = v19 - 16;
        v84 = vld2q_s16(v24);
        v88 = vld2q_s16(v19);
        v18 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v84.val[1], v84.val[1]), v84.val[0], v84.val[0]), v20), v18);
        v17 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v84.val[1].i8, *(int16x4_t *)v84.val[1].i8), *(int16x4_t *)v84.val[0].i8, *(int16x4_t *)v84.val[0].i8), v20), v17);
        v23 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v88.val[1], v88.val[1]), v88.val[0], v88.val[0]), v20), v23);
        v22 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v88.val[1].i8, *(int16x4_t *)v88.val[1].i8), *(int16x4_t *)v88.val[0].i8, *(int16x4_t *)v88.val[0].i8), v20), v22);
        v19 += 32;
        v21 -= 16;
      }
      while (v21);
      v8 = vaddvq_s32(vaddq_s32(vaddq_s32(v22, v17), vaddq_s32(v23, v18)));
      if (v16 == (v16 & 0x7FFFFFFFFFFFFFF0))
      {
LABEL_19:
        v15 = a3 & 0xFFFFFFFE;
        if ((int)(a3 & 0xFFFFFFFE) >= a3)
          goto LABEL_21;
        goto LABEL_20;
      }
    }
    else
    {
      v7 = 0;
      v8 = a3;
    }
    do
    {
      v8 += (a2[v7] * a2[v7] + a2[v7 + 1] * a2[v7 + 1]) >> v4;
      v7 += 2;
    }
    while (v7 < v5);
    goto LABEL_19;
  }
  if (!result[1061])
    goto LABEL_77;
  v9 = __clz(a3);
  v10 = 31 - v9;
  v11 = (a3 - 1);
  if (a3 >= 2)
  {
    v12 = 2;
    if (v11 > 2)
      v12 = (a3 - 1);
    if (v12 >= 0x1F)
    {
      v43 = ((v12 - 1) >> 1) + 1;
      v13 = 2 * (v43 & 0x7FFFFFFFFFFFFFF0);
      v44 = (int32x4_t)a3;
      v45 = 0uLL;
      v46 = a2 + 16;
      v47 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v10));
      v48 = v43 & 0x7FFFFFFFFFFFFFF0;
      v49 = 0uLL;
      v50 = 0uLL;
      do
      {
        v51 = v46 - 16;
        v86 = vld2q_s16(v51);
        v90 = vld2q_s16(v46);
        v45 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v86.val[1], v86.val[1]), v86.val[0], v86.val[0]), v47), v45);
        v44 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v86.val[1].i8, *(int16x4_t *)v86.val[1].i8), *(int16x4_t *)v86.val[0].i8, *(int16x4_t *)v86.val[0].i8), v47), v44);
        v50 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v90.val[1], v90.val[1]), v90.val[0], v90.val[0]), v47), v50);
        v49 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v90.val[1].i8, *(int16x4_t *)v90.val[1].i8), *(int16x4_t *)v90.val[0].i8, *(int16x4_t *)v90.val[0].i8), v47), v49);
        v46 += 32;
        v48 -= 16;
      }
      while (v48);
      v14 = vaddvq_s32(vaddq_s32(vaddq_s32(v49, v44), vaddq_s32(v50, v45)));
      if (v43 == (v43 & 0x7FFFFFFFFFFFFFF0))
      {
LABEL_41:
        v42 = a3 & 0xFFFFFFFE;
        if ((int)(a3 & 0xFFFFFFFE) >= a3)
          goto LABEL_43;
        goto LABEL_42;
      }
    }
    else
    {
      v13 = 0;
      v14 = a3;
    }
    do
    {
      v14 += (a2[v13] * a2[v13] + a2[v13 + 1] * a2[v13 + 1]) >> v10;
      v13 += 2;
    }
    while (v13 < v11);
    goto LABEL_41;
  }
  v42 = 0;
  v14 = a3;
  if (a3 > 0)
  {
LABEL_42:
    v52 = a2[v42];
    v14 += (v52 * v52) >> v10;
  }
LABEL_43:
  v53 = v9 + __clz(v14);
  v54 = (34 - v53) & ~((int)(34 - v53) >> 31);
  if (a3 < 2)
  {
    v58 = 0;
    v57 = 0;
    if (a3 <= 0)
      goto LABEL_56;
    goto LABEL_55;
  }
  v55 = 2;
  if (v11 > 2)
    v55 = (a3 - 1);
  if (v55 < 0x1F)
  {
    v56 = 0;
    v57 = 0;
    do
    {
LABEL_53:
      v57 += (a2[v56] * a2[v56] + a2[v56 + 1] * a2[v56 + 1]) >> v54;
      v56 += 2;
    }
    while (v56 < v11);
    goto LABEL_54;
  }
  v59 = ((v55 - 1) >> 1) + 1;
  v56 = 2 * (v59 & 0x7FFFFFFFFFFFFFF0);
  v60 = a2 + 16;
  v61 = 0uLL;
  v62 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v54));
  v63 = v59 & 0x7FFFFFFFFFFFFFF0;
  v64 = 0uLL;
  v65 = 0uLL;
  v66 = 0uLL;
  do
  {
    v67 = v60 - 16;
    v87 = vld2q_s16(v67);
    v91 = vld2q_s16(v60);
    v64 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v87.val[1], v87.val[1]), v87.val[0], v87.val[0]), v62), v64);
    v61 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v87.val[1].i8, *(int16x4_t *)v87.val[1].i8), *(int16x4_t *)v87.val[0].i8, *(int16x4_t *)v87.val[0].i8), v62), v61);
    v66 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v91.val[1], v91.val[1]), v91.val[0], v91.val[0]), v62), v66);
    v65 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v91.val[1].i8, *(int16x4_t *)v91.val[1].i8), *(int16x4_t *)v91.val[0].i8, *(int16x4_t *)v91.val[0].i8), v62), v65);
    v60 += 32;
    v63 -= 16;
  }
  while (v63);
  v57 = vaddvq_s32(vaddq_s32(vaddq_s32(v65, v61), vaddq_s32(v66, v64)));
  if (v59 != (v59 & 0x7FFFFFFFFFFFFFF0))
    goto LABEL_53;
LABEL_54:
  v58 = a3 & 0xFFFFFFFE;
  if ((int)(a3 & 0xFFFFFFFE) < a3)
  {
LABEL_55:
    v68 = a2[v58];
    v57 += (v68 * v68) >> v54;
  }
LABEL_56:
  v69 = result[1065];
  if (v54 <= v69)
  {
    if (v54 < v69)
      v57 >>= v69 - v54;
    v70 = result[1064];
    if (v57 <= v70)
      goto LABEL_77;
  }
  else
  {
    v70 = (int)result[1064] >> (v54 - v69);
    result[1064] = v70;
    if (v57 <= v70)
      goto LABEL_77;
  }
  v71 = __clz(v70);
  v72 = v70 << (v71 - 1);
  result[1064] = v72;
  v73 = v57 >> ((25 - v71) & ~((int)(25 - v71) >> 31));
  if (v73 <= 1)
    v73 = 1;
  v74 = v72 / v73;
  if ((int)v74 >= 1)
  {
    v75 = __clz(v74);
    if (v75 != 24)
    {
      v76 = v74 > 0x7F;
      v77 = (v74 << (v75 + 8)) | (v74 >> (24 - v75));
      v74 <<= v75 - 24;
      if (v76)
        LOBYTE(v74) = v77;
    }
    v78 = v74 & 0x7F;
    if ((v75 & 1) != 0)
      v79 = 0x8000;
    else
      v79 = 46214;
    v80 = 16 * ((v79 >> (v75 >> 1)) + ((213 * (v79 >> (v75 >> 1)) * v78) >> 16));
    if (a3 < 1)
      goto LABEL_77;
    goto LABEL_74;
  }
  v80 = 0;
  if (a3 >= 1)
  {
LABEL_74:
    v81 = 4 * ((0x10000 - v80) / a3);
    v82 = a3 - 1;
    do
    {
      v83 = v82;
      *a2 = (*a2 * v80) >> 16;
      ++a2;
      v80 += v81;
      if (v80 > 0x10000)
        break;
      --v82;
    }
    while (v83);
  }
LABEL_77:
  result[1061] = 0;
  return result;
}

uint64_t silk_PLC_energy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  int *v9;
  unsigned int *v10;
  int *v11;
  unsigned int *v12;
  uint64_t v13;
  signed int v14;
  signed int v15;
  uint64_t v16;
  uint64_t v17;
  int8x16_t *v18;
  unsigned int v19;
  signed int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  unint64_t v25;
  unsigned int v26;
  int32x4_t *v27;
  int32x4_t v28;
  int32x4_t v29;
  int8x16_t v30;
  uint64_t v31;
  int8x16_t *v32;
  int32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int64x2_t v36;
  int64x2_t v37;
  int64x2_t v38;
  int64x2_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int8x16_t v42;
  uint64_t v43;
  char *v44;
  int *v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  int v50;
  uint64_t v51;
  int8x16_t *v52;
  int32x4_t *v53;
  int32x4_t v54;
  int32x4_t v55;
  int8x16_t v56;
  uint64_t v57;
  int32x4_t v58;
  int32x4_t v59;
  int32x4_t v60;
  int64x2_t v61;
  int64x2_t v62;
  int64x2_t v63;
  int64x2_t v64;
  int32x4_t v65;
  int32x4_t v66;
  int8x16_t v67;
  uint64_t v68;
  char *v69;
  int *v70;
  int v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  int v77;
  unint64_t v78;
  int32x4_t v79;
  int32x4_t v80;
  const __int16 *i16;
  uint32x4_t v82;
  uint64_t v83;
  int32x4_t v84;
  int32x4_t v85;
  const __int16 *v86;
  int v87;
  unsigned int v88;
  unsigned int v89;
  unint64_t v90;
  unint64_t v91;
  int v92;
  int v93;
  unint64_t v94;
  const __int16 *v95;
  int32x4_t v96;
  uint32x4_t v97;
  uint64_t v98;
  int32x4_t v99;
  int32x4_t v100;
  int32x4_t v101;
  const __int16 *v102;
  int v103;
  char *v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t result;
  int v108;
  unint64_t v109;
  int32x4_t v110;
  int32x4_t v111;
  const __int16 *v112;
  uint32x4_t v113;
  uint64_t v114;
  int32x4_t v115;
  int32x4_t v116;
  const __int16 *v117;
  int v118;
  unsigned int v119;
  unsigned int v120;
  unint64_t v121;
  unint64_t v122;
  int v123;
  int v124;
  unint64_t v125;
  const __int16 *v126;
  int32x4_t v127;
  uint32x4_t v128;
  uint64_t v129;
  int32x4_t v130;
  int32x4_t v131;
  int32x4_t v132;
  const __int16 *v133;
  int v134;
  _QWORD v135[2];
  int16x8x2_t v136;
  int16x8x2_t v137;
  int16x8x2_t v138;
  int16x8x2_t v139;
  int16x8x2_t v140;
  int16x8x2_t v141;
  int16x8x2_t v142;
  int16x8x2_t v143;

  v135[1] = *MEMORY[0x24BDAC8D0];
  v9 = (int *)MEMORY[0x24BDAC7A8]();
  v18 = (int8x16_t *)((char *)v135 - v17);
  v19 = __clz(v16);
  if ((int)v16 <= 0)
  {
    v23 = 0;
    v24 = 31 - v19;
    LODWORD(v25) = v16 - 1;
    v26 = v16;
    goto LABEL_37;
  }
  v20 = v14;
  v21 = (a9 - 2) * (int)v16;
  if (v16 >= 8)
  {
    v22 = v16 & 0xFFFFFFF8;
    v27 = (int32x4_t *)(v13 + 4 * v21);
    v28.i64[0] = 0x7F0000007FLL;
    v28.i64[1] = 0x7F0000007FLL;
    v29.i64[0] = 0x7F0000007FLL;
    v29.i64[1] = 0x7F0000007FLL;
    v30.i64[0] = 0x8000800080008000;
    v30.i64[1] = 0x8000800080008000;
    v31 = v22;
    v32 = v18;
    do
    {
      v34 = *v27;
      v33 = v27[1];
      v27 += 2;
      v35 = vdupq_n_s32(v20);
      v36 = vmull_high_s32(v35, v33);
      v37 = vmull_s32(*(int32x2_t *)v35.i8, *(int32x2_t *)v33.i8);
      v38 = vmull_high_s32(v35, v34);
      v39 = vmull_s32(*(int32x2_t *)v35.i8, *(int32x2_t *)v34.i8);
      v40 = vshrn_high_n_s64(vshrn_n_s64(v39, 0x10uLL), v38, 0x10uLL);
      v41 = vshrn_high_n_s64(vshrn_n_s64(v37, 0x10uLL), v36, 0x10uLL);
      v42 = (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_s32(v40, v28), (int16x8_t)vcgtq_s32(v41, v28));
      *v32++ = vorrq_s8((int8x16_t)(*(_OWORD *)&v42 & __PAIR128__(0x7FFF7FFF7FFF7FFFLL, 0x7FFF7FFF7FFF7FFFLL)), vbicq_s8(vbslq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_s32(v29, v40), (int16x8_t)vcgtq_s32(v29, v41)), v30, (int8x16_t)vuzp1q_s16((int16x8_t)vshrn_high_n_s64(vshrn_n_s64(v39, 0x18uLL), v38, 0x18uLL), (int16x8_t)vshrn_high_n_s64(vshrn_n_s64(v37, 0x18uLL), v36, 0x18uLL))), v42));
      v31 -= 8;
    }
    while (v31);
    if (v22 == v16)
      goto LABEL_14;
  }
  else
  {
    v22 = 0;
  }
  v43 = v16 - v22;
  v44 = &v18->i8[2 * v22];
  v45 = (int *)(v13 + 4 * (v22 + v21));
  do
  {
    v46 = *v45++;
    v47 = v46 * (uint64_t)v20;
    v48 = v47 >> 16;
    v49 = v47 >> 24;
    if ((int)v48 < -8388608)
      LOWORD(v49) = 0x8000;
    if ((int)v48 >= 0x800000)
      LOWORD(v49) = 0x7FFF;
    *(_WORD *)v44 = v49;
    v44 += 2;
    --v43;
  }
  while (v43);
LABEL_14:
  v50 = (a9 - 1) * v16;
  if (v16 >= 8)
  {
    v52 = (int8x16_t *)((char *)v18 + 2 * (int)v16);
    v51 = v16 & 0xFFFFFFF8;
    v53 = (int32x4_t *)(v13 + 4 * v50);
    v54.i64[0] = 0x7F0000007FLL;
    v54.i64[1] = 0x7F0000007FLL;
    v55.i64[0] = 0x7F0000007FLL;
    v55.i64[1] = 0x7F0000007FLL;
    v56.i64[0] = 0x8000800080008000;
    v56.i64[1] = 0x8000800080008000;
    v57 = v51;
    do
    {
      v59 = *v53;
      v58 = v53[1];
      v53 += 2;
      v60 = vdupq_n_s32(v15);
      v61 = vmull_high_s32(v60, v58);
      v62 = vmull_s32(*(int32x2_t *)v60.i8, *(int32x2_t *)v58.i8);
      v63 = vmull_high_s32(v60, v59);
      v64 = vmull_s32(*(int32x2_t *)v60.i8, *(int32x2_t *)v59.i8);
      v65 = vshrn_high_n_s64(vshrn_n_s64(v64, 0x10uLL), v63, 0x10uLL);
      v66 = vshrn_high_n_s64(vshrn_n_s64(v62, 0x10uLL), v61, 0x10uLL);
      v67 = (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_s32(v65, v54), (int16x8_t)vcgtq_s32(v66, v54));
      *v52++ = vorrq_s8((int8x16_t)(*(_OWORD *)&v67 & __PAIR128__(0x7FFF7FFF7FFF7FFFLL, 0x7FFF7FFF7FFF7FFFLL)), vbicq_s8(vbslq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_s32(v55, v65), (int16x8_t)vcgtq_s32(v55, v66)), v56, (int8x16_t)vuzp1q_s16((int16x8_t)vshrn_high_n_s64(vshrn_n_s64(v64, 0x18uLL), v63, 0x18uLL), (int16x8_t)vshrn_high_n_s64(vshrn_n_s64(v62, 0x18uLL), v61, 0x18uLL))), v67));
      v57 -= 8;
    }
    while (v57);
    if (v51 == v16)
      goto LABEL_25;
  }
  else
  {
    v51 = 0;
  }
  v68 = v16 - v51;
  v69 = &v18->i8[2 * v51 + 2 * (int)v16];
  v70 = (int *)(v13 + 4 * (v51 + v50));
  do
  {
    v71 = *v70++;
    v72 = v71 * (uint64_t)v15;
    v73 = v72 >> 16;
    v74 = v72 >> 24;
    if ((int)v73 < -8388608)
      LOWORD(v74) = 0x8000;
    if ((int)v73 >= 0x800000)
      LOWORD(v74) = 0x7FFF;
    *(_WORD *)v69 = v74;
    v69 += 2;
    --v68;
  }
  while (v68);
LABEL_25:
  v24 = v19 ^ 0x1F;
  v25 = (v16 - 1);
  if ((int)v16 >= 2)
  {
    v75 = 2;
    if (v25 > 2)
      v75 = (v16 - 1);
    if (v75 >= 0x1F)
    {
      v78 = ((v75 - 1) >> 1) + 1;
      v76 = 2 * (v78 & 0x7FFFFFFFFFFFFFF0);
      v79 = (int32x4_t)v16;
      v80 = 0uLL;
      i16 = v18[2].i16;
      v82 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v24));
      v83 = v78 & 0x7FFFFFFFFFFFFFF0;
      v84 = 0uLL;
      v85 = 0uLL;
      do
      {
        v86 = i16 - 16;
        v136 = vld2q_s16(v86);
        v140 = vld2q_s16(i16);
        v80 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v136.val[1], v136.val[1]), v136.val[0], v136.val[0]), v82), v80);
        v79 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v136.val[1].i8, *(int16x4_t *)v136.val[1].i8), *(int16x4_t *)v136.val[0].i8, *(int16x4_t *)v136.val[0].i8), v82), v79);
        v85 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v140.val[1], v140.val[1]), v140.val[0], v140.val[0]), v82), v85);
        v84 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v140.val[1].i8, *(int16x4_t *)v140.val[1].i8), *(int16x4_t *)v140.val[0].i8, *(int16x4_t *)v140.val[0].i8), v82), v84);
        i16 += 32;
        v83 -= 16;
      }
      while (v83);
      v26 = vaddvq_s32(vaddq_s32(vaddq_s32(v84, v79), vaddq_s32(v85, v80)));
      if (v78 == (v78 & 0x7FFFFFFFFFFFFFF0))
      {
LABEL_35:
        v77 = v16 & 0xFFFFFFFE;
        v23 = 1;
        if ((v16 & 0xFFFFFFFE) >= (int)v16)
          goto LABEL_37;
        goto LABEL_36;
      }
    }
    else
    {
      v76 = 0;
      v26 = v16;
    }
    do
    {
      v26 += (v18->i16[v76] * v18->i16[v76] + v18->i16[v76 + 1] * v18->i16[v76 + 1]) >> v24;
      v76 += 2;
    }
    while (v76 < v25);
    goto LABEL_35;
  }
  v23 = 0;
  v77 = 0;
  v26 = v16;
LABEL_36:
  v87 = v18->i16[v77];
  v26 += (v87 * v87) >> v24;
LABEL_37:
  v88 = __clz(v26);
  v89 = (34 - v19 - v88) & ~((int)(34 - v19 - v88) >> 31);
  if (v23)
  {
    v90 = 2;
    if (v25 > 2uLL)
      v90 = v25;
    if (v90 >= 0x1F)
    {
      v94 = ((v90 - 1) >> 1) + 1;
      v91 = 2 * (v94 & 0x7FFFFFFFFFFFFFF0);
      v95 = v18[2].i16;
      v96 = 0uLL;
      v97 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v89));
      v98 = v94 & 0x7FFFFFFFFFFFFFF0;
      v99 = 0uLL;
      v100 = 0uLL;
      v101 = 0uLL;
      do
      {
        v102 = v95 - 16;
        v137 = vld2q_s16(v102);
        v141 = vld2q_s16(v95);
        v99 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v137.val[1], v137.val[1]), v137.val[0], v137.val[0]), v97), v99);
        v96 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v137.val[1].i8, *(int16x4_t *)v137.val[1].i8), *(int16x4_t *)v137.val[0].i8, *(int16x4_t *)v137.val[0].i8), v97), v96);
        v101 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v141.val[1], v141.val[1]), v141.val[0], v141.val[0]), v97), v101);
        v100 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v141.val[1].i8, *(int16x4_t *)v141.val[1].i8), *(int16x4_t *)v141.val[0].i8, *(int16x4_t *)v141.val[0].i8), v97), v100);
        v95 += 32;
        v98 -= 16;
      }
      while (v98);
      v92 = vaddvq_s32(vaddq_s32(vaddq_s32(v100, v96), vaddq_s32(v101, v99)));
      if (v94 == (v94 & 0x7FFFFFFFFFFFFFF0))
      {
LABEL_48:
        v93 = v16 & 0xFFFFFFFE;
        if ((v16 & 0xFFFFFFFE) >= (int)v16)
          goto LABEL_50;
        goto LABEL_49;
      }
    }
    else
    {
      v91 = 0;
      v92 = 0;
    }
    do
    {
      v92 += (v18->i16[v91] * v18->i16[v91] + v18->i16[v91 + 1] * v18->i16[v91 + 1]) >> v89;
      v91 += 2;
    }
    while (v91 < v25);
    goto LABEL_48;
  }
  v93 = 0;
  v92 = 0;
  if ((int)v16 > 0)
  {
LABEL_49:
    v103 = v18->i16[v93];
    v92 += (v103 * v103) >> v89;
  }
LABEL_50:
  *v10 = v89;
  *v9 = v92;
  v104 = &v18->i8[2 * (int)v16];
  if (v23)
  {
    v105 = 2;
    if (v25 > 2uLL)
      v105 = v25;
    if (v105 >= 0x1F)
    {
      v109 = ((v105 - 1) >> 1) + 1;
      v106 = 2 * (v109 & 0x7FFFFFFFFFFFFFF0);
      v110 = 0uLL;
      v111 = (int32x4_t)v16;
      v112 = &v18[2].i16[(int)v16];
      v113 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v24));
      v114 = v109 & 0x7FFFFFFFFFFFFFF0;
      v115 = 0uLL;
      v116 = 0uLL;
      do
      {
        v117 = v112 - 16;
        v138 = vld2q_s16(v117);
        v142 = vld2q_s16(v112);
        v110 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v138.val[1], v138.val[1]), v138.val[0], v138.val[0]), v113), v110);
        v111 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v138.val[1].i8, *(int16x4_t *)v138.val[1].i8), *(int16x4_t *)v138.val[0].i8, *(int16x4_t *)v138.val[0].i8), v113), v111);
        v116 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v142.val[1], v142.val[1]), v142.val[0], v142.val[0]), v113), v116);
        v115 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v142.val[1].i8, *(int16x4_t *)v142.val[1].i8), *(int16x4_t *)v142.val[0].i8, *(int16x4_t *)v142.val[0].i8), v113), v115);
        v112 += 32;
        v114 -= 16;
      }
      while (v114);
      result = vaddvq_s32(vaddq_s32(vaddq_s32(v115, v111), vaddq_s32(v116, v110)));
      if (v109 == (v109 & 0x7FFFFFFFFFFFFFF0))
      {
LABEL_61:
        v108 = v16 & 0xFFFFFFFE;
        if ((v16 & 0xFFFFFFFE) >= (int)v16)
          goto LABEL_63;
        goto LABEL_62;
      }
    }
    else
    {
      v106 = 0;
      LODWORD(result) = v16;
    }
    do
    {
      result = ((*(__int16 *)&v104[2 * v106] * *(__int16 *)&v104[2 * v106]
                             + *(__int16 *)&v104[2 * v106 + 2] * *(__int16 *)&v104[2 * v106 + 2]) >> v24)
             + result;
      v106 += 2;
    }
    while (v106 < v25);
    goto LABEL_61;
  }
  v108 = 0;
  result = v16;
  if ((int)v16 > 0)
  {
LABEL_62:
    v118 = *(__int16 *)&v104[2 * v108];
    result = ((v118 * v118) >> v24) + result;
  }
LABEL_63:
  v119 = __clz(result);
  v120 = (34 - v19 - v119) & ~((int)(34 - v19 - v119) >> 31);
  if (!v23)
  {
    v124 = 0;
    v123 = 0;
    if ((int)v16 <= 0)
      goto LABEL_76;
    goto LABEL_75;
  }
  v121 = 2;
  if (v25 > 2uLL)
    v121 = v25;
  if (v121 < 0x1F)
  {
    v122 = 0;
    v123 = 0;
    do
    {
LABEL_73:
      v123 += (*(__int16 *)&v104[2 * v122] * *(__int16 *)&v104[2 * v122]
                           + *(__int16 *)&v104[2 * v122 + 2] * *(__int16 *)&v104[2 * v122 + 2]) >> v120;
      v122 += 2;
    }
    while (v122 < v25);
    goto LABEL_74;
  }
  v125 = ((v121 - 1) >> 1) + 1;
  v122 = 2 * (v125 & 0x7FFFFFFFFFFFFFF0);
  v126 = &v18[2].i16[(int)v16];
  v127 = 0uLL;
  v128 = (uint32x4_t)vnegq_s32(vdupq_n_s32(v120));
  v129 = v125 & 0x7FFFFFFFFFFFFFF0;
  v130 = 0uLL;
  v131 = 0uLL;
  v132 = 0uLL;
  do
  {
    v133 = v126 - 16;
    v139 = vld2q_s16(v133);
    v143 = vld2q_s16(v126);
    v130 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v139.val[1], v139.val[1]), v139.val[0], v139.val[0]), v128), v130);
    v127 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v139.val[1].i8, *(int16x4_t *)v139.val[1].i8), *(int16x4_t *)v139.val[0].i8, *(int16x4_t *)v139.val[0].i8), v128), v127);
    v132 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_high_s16(vmull_high_s16(v143.val[1], v143.val[1]), v143.val[0], v143.val[0]), v128), v132);
    v131 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlal_s16(vmull_s16(*(int16x4_t *)v143.val[1].i8, *(int16x4_t *)v143.val[1].i8), *(int16x4_t *)v143.val[0].i8, *(int16x4_t *)v143.val[0].i8), v128), v131);
    v126 += 32;
    v129 -= 16;
  }
  while (v129);
  v123 = vaddvq_s32(vaddq_s32(vaddq_s32(v131, v127), vaddq_s32(v132, v130)));
  if (v125 != (v125 & 0x7FFFFFFFFFFFFFF0))
    goto LABEL_73;
LABEL_74:
  v124 = v16 & 0xFFFFFFFE;
  if ((v16 & 0xFFFFFFFE) < (int)v16)
  {
LABEL_75:
    v134 = *(__int16 *)&v104[2 * v124];
    v123 += (v134 * v134) >> v120;
  }
LABEL_76:
  *v12 = v120;
  *v11 = v123;
  return result;
}

float32_t silk_process_gains_FLP(uint64_t a1, float32x4_t *a2, int a3)
{
  __int8 *v6;
  unsigned __int8 *v7;
  uint64_t v8;
  double v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t v13;
  float32x4_t *v14;
  uint64_t v15;
  float32x4_t v16;
  uint64_t v17;
  float *v18;
  double v19;
  float v20;
  uint64_t v21;
  float32x4_t v22;
  uint64_t v23;
  float32x4_t *v24;
  float32x4_t v25;
  uint64_t v26;
  float *v27;
  uint64_t v28;
  float32x4_t *v29;
  int32x4_t *v30;
  uint64_t v31;
  int32x4_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  float *v36;
  float v37;
  float32x4_t v38;
  uint64_t v39;
  uint64_t v40;
  int32x4_t *v41;
  float32x4_t *v42;
  uint64_t v43;
  float32x4_t v44;
  uint64_t v45;
  uint64_t v46;
  __int32 *v47;
  int *v48;
  int v49;
  int v50;
  uint64_t v51;
  _BYTE __src[16];
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v6 = (__int8 *)(a1 + 7192);
  v7 = (unsigned __int8 *)(a1 + 4781);
  v8 = a1 + 4752;
  if (*(_BYTE *)(a1 + 4781) != 2)
  {
    LODWORD(v10) = *(_DWORD *)(a1 + 4580);
    goto LABEL_11;
  }
  v9 = exp((float)((float)(a2[44].f32[1] + -12.0) * -0.25));
  v10 = *(unsigned int *)(a1 + 4580);
  if ((int)v10 < 1)
    goto LABEL_11;
  v11 = 1.0 / (v9 + 1.0);
  v12 = (float)(v11 * -0.5) + 1.0;
  if (v10 < 8)
  {
    v13 = 0;
LABEL_9:
    v17 = v10 - v13;
    v18 = &a2->f32[v13];
    do
    {
      *v18 = v12 * *v18;
      ++v18;
      --v17;
    }
    while (v17);
    goto LABEL_11;
  }
  v13 = v10 & 0x7FFFFFF8;
  v14 = a2 + 1;
  v15 = v10 & 0xFFFFFFF8;
  do
  {
    v16 = vmulq_n_f32(*v14, v12);
    v14[-1] = vmulq_n_f32(v14[-1], v12);
    *v14 = v16;
    v14 += 2;
    v15 -= 8;
  }
  while (v15);
  if (v13 != v10)
    goto LABEL_9;
LABEL_11:
  v19 = exp2((float)((float)((float)((float)*(int *)(a1 + 4732) * -0.0078125) + 21.0) * 0.33));
  if ((int)v10 < 1)
    goto LABEL_26;
  v20 = v19 / (double)*(int *)(a1 + 4588);
  if (v10 < 8)
  {
    v21 = 0;
LABEL_17:
    v26 = v10 - v21;
    v27 = &a2->f32[v21];
    do
    {
      *v27 = fminf(sqrtf((float)(v27[178] * v20) + (float)(*v27 * *v27)), 32767.0);
      ++v27;
      --v26;
    }
    while (v26);
    goto LABEL_19;
  }
  v21 = v10 & 0xFFFFFFF8;
  v22 = (float32x4_t)vdupq_n_s32(0x46FFFE00u);
  v23 = v21;
  v24 = a2;
  do
  {
    v25 = vminnmq_f32(vsqrtq_f32(vmlaq_f32(vmulq_n_f32(*(float32x4_t *)((char *)v24 + 728), v20), v24[1], v24[1])), v22);
    *v24 = vminnmq_f32(vsqrtq_f32(vmlaq_f32(vmulq_n_f32(*(float32x4_t *)((char *)v24 + 712), v20), *v24, *v24)), v22);
    v24[1] = v25;
    v24 += 2;
    v23 -= 8;
  }
  while (v23);
  if (v21 != v10)
    goto LABEL_17;
LABEL_19:
  if (v10 < 8)
  {
    v28 = 0;
LABEL_24:
    v33 = v10 - v28;
    v34 = v28;
    v35 = &__src[4 * v28];
    v36 = &a2->f32[v34];
    do
    {
      v37 = *v36++;
      *v35++ = vcvts_n_s32_f32(v37, 0x10uLL);
      --v33;
    }
    while (v33);
    goto LABEL_26;
  }
  v28 = v10 & 0x7FFFFFF8;
  v29 = a2 + 1;
  v30 = (int32x4_t *)&v54;
  v31 = v10 & 0xFFFFFFF8;
  do
  {
    v32 = vcvtq_n_s32_f32(*v29, 0x10uLL);
    v30[-1] = vcvtq_n_s32_f32(v29[-1], 0x10uLL);
    *v30 = v32;
    v29 += 2;
    v30 += 2;
    v31 -= 8;
  }
  while (v31);
  if (v28 != v10)
    goto LABEL_24;
LABEL_26:
  memcpy(&a2[45].u32[2], __src, 4 * (int)v10);
  a2[46].i8[8] = *v6;
  silk_gains_quant(v8, (uint64_t)__src, v6, a3 == 2, *(_DWORD *)(a1 + 4580));
  v39 = *(unsigned int *)(a1 + 4580);
  if ((int)v39 >= 1)
  {
    if (v39 >= 8)
    {
      v40 = v39 & 0x7FFFFFF8;
      v41 = (int32x4_t *)&v54;
      v42 = a2 + 1;
      v38 = (float32x4_t)vdupq_n_s32(0x37800000u);
      v43 = v39 & 0xFFFFFFF8;
      do
      {
        v44 = vmulq_f32(vcvtq_f32_s32(*v41), v38);
        v42[-1] = vmulq_f32(vcvtq_f32_s32(v41[-1]), v38);
        *v42 = v44;
        v41 += 2;
        v42 += 2;
        v43 -= 8;
      }
      while (v43);
      if (v40 == v39)
        goto LABEL_34;
    }
    else
    {
      v40 = 0;
    }
    v45 = v39 - v40;
    v46 = 4 * v40;
    v47 = &a2->i32[v40];
    v48 = (int *)&__src[v46];
    do
    {
      v49 = *v48++;
      v38.f32[0] = (float)v49 * 0.000015259;
      *v47++ = v38.i32[0];
      --v45;
    }
    while (v45);
  }
LABEL_34:
  v50 = *v7;
  if (v50 == 2)
  {
    v38.f32[0] = a2[44].f32[1] + (float)((float)*(int *)(a1 + 4728) * 0.000030518);
    if (v38.f32[0] <= 1.0)
    {
      v51 = 1;
      v7[1] = 1;
    }
    else
    {
      v51 = 0;
      v7[1] = 0;
    }
  }
  else
  {
    v51 = (char)v7[1];
  }
  v38.i16[0] = silk_Quantization_Offsets_Q10[2 * ((char)v50 >> 1) + v51];
  v38.f32[0] = (float)((float)((float)((float)((float)((float)*(int *)(a1 + 4628) * -0.05) + 1.2)
                                     + (float)((float)((float)*(int *)(a1 + 4532) * -0.2) * 0.0039062))
                             + (float)(a2[43].f32[2] * -0.1))
                     + (float)(a2[43].f32[3] * -0.2))
             + (float)((float)((float)vmovl_s16(*(int16x4_t *)v38.f32).i32[0] * 0.00097656) * 0.8);
  a2[43].i32[1] = v38.i32[0];
  return v38.f32[0];
}

void *silk_process_NLSFs(uint64_t a1, int16x8_t *a2, __int16 *a3, int16x8_t *a4)
{
  char *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;
  __int16 *v24;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  __int8 *v29;
  int v30;
  __int16 v31;
  unint64_t v32;
  uint64_t v33;
  int v34;
  int16x8_t *v35;
  signed int v36;
  uint64_t v37;
  int v38;
  int v39;
  int16x8_t *v40;
  int16x8_t *v41;
  int16x8_t *v42;
  int32x4_t v43;
  uint64_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int16x8_t v48;
  uint64_t v49;
  uint64_t v50;
  __int16 *v51;
  __int16 *v52;
  __int16 *v53;
  __int16 v54;
  __int16 v55;
  __int16 v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  unsigned int v60;
  __int16 v61;
  uint64_t v62;
  __int16 *v63;
  int v64;
  int v65;
  unsigned int v66;
  _WORD *v67;
  int v68;
  __int16 v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  unsigned int v73;
  uint64_t v74;
  int16x8_t *v75;
  int16x4_t *v76;
  int16x8_t v77;
  uint64_t v78;
  int16x8_t v79;
  uint64_t v80;
  uint64_t v81;
  __int16 *v82;
  __int16 *v83;
  int v84;
  uint64_t v85;
  int v86;
  unsigned int v87;
  uint64_t v88;
  int16x8_t *v90;
  int16x8_t *v91;
  int16x8_t *v92;
  int32x4_t v93;
  uint64_t v94;
  int16x8_t v95;
  int16x8_t v96;
  int16x8_t v97;
  int16x8_t v98;
  uint64_t v99;
  uint64_t v100;
  __int16 *v101;
  __int16 *v102;
  __int16 *v103;
  __int16 v104;
  __int16 v105;
  __int16 v106;
  _WORD v107[8];
  uint64_t v108;
  int16x8_t v109;
  uint64_t v110;
  __int16 v111[8];
  _QWORD v112[3];

  v112[2] = *MEMORY[0x24BDAC8D0];
  v8 = (char *)(a1 + 4781);
  v9 = ((unint64_t)(0xFFFFFFFBE76ELL * *(__int16 *)(a1 + 4532)) >> 16) + 3146;
  if (*(_DWORD *)(a1 + 4580) == 2)
    v10 = v9 >> 1;
  else
    v10 = 0;
  v11 = v10 + v9;
  v12 = *(int *)(a1 + 4640);
  v13 = *a3;
  if (v13 <= 1)
    v14 = 1;
  else
    v14 = *a3;
  v15 = 0x20000 / v14;
  v16 = a3[1];
  v17 = v16 - v13;
  if (v17 <= 1)
    v17 = 1;
  v18 = 0x20000u / v17;
  v19 = 0x20000u / v17 + v15;
  if (v19 >= 0x7FFF)
    LOWORD(v19) = 0x7FFF;
  v109.i16[0] = v19;
  v20 = v12 - 1;
  LODWORD(v21) = v12 - 1;
  if ((int)v12 > 2)
  {
    v22 = 0;
    v23 = v16;
    v20 = v21;
    do
    {
      v24 = &a3[v22];
      v25 = v24[2];
      v26 = v25 - v23;
      if (v26 <= 1)
        v26 = 1;
      v27 = 0x20000u / v26;
      v28 = 0x20000u / v26 + v18;
      if (v28 >= 0x7FFF)
        LOWORD(v28) = 0x7FFF;
      v29 = &v109.i8[2 * v22];
      *((_WORD *)v29 + 1) = v28;
      v23 = v24[3];
      v30 = v23 - v25;
      if (v30 <= 1)
        v30 = 1;
      v18 = 0x20000u / v30;
      v31 = v18 + v27;
      if ((int)(v18 + v27) >= 0x7FFF)
        v31 = 0x7FFF;
      *((_WORD *)v29 + 2) = v31;
      v32 = v22 + 3;
      v22 += 2;
    }
    while (v32 < v21);
  }
  v33 = v20;
  v34 = 0x20000u / (0x8000 - a3[v33]) + v18;
  if (v34 >= 0x7FFF)
    LOWORD(v34) = 0x7FFF;
  v35 = &v109;
  v109.i16[v33] = v34;
  if (*(_DWORD *)(a1 + 4632) != 1 || (v36 = v8[2], v36 > 3))
  {
    v38 = 0;
    goto LABEL_68;
  }
  if ((int)v12 < 1)
  {
    v39 = 0;
    goto LABEL_37;
  }
  if (v12 >= 0x10)
  {
    v37 = v12 & 0x7FFFFFF0;
    v40 = a4 + 1;
    v41 = (int16x8_t *)(a3 + 8);
    v42 = (int16x8_t *)v112;
    v43 = vdupq_n_s32(v36);
    v44 = v12 & 0xFFFFFFF0;
    do
    {
      v45 = v40[-1];
      v46 = vsubq_s16(v41[-1], v45);
      v47 = vsubq_s16(*v41, *v40);
      v48 = vaddq_s16(*v40, vshrn_high_n_s32(vshrn_n_s32(vmulq_s32(v43, vmovl_s16(*(int16x4_t *)v47.i8)), 2uLL), vmulq_s32(v43, vmovl_high_s16(v47)), 2uLL));
      v42[-1] = vaddq_s16(v45, vshrn_high_n_s32(vshrn_n_s32(vmulq_s32(v43, vmovl_s16(*(int16x4_t *)v46.i8)), 2uLL), vmulq_s32(v43, vmovl_high_s16(v46)), 2uLL));
      *v42 = v48;
      v40 += 2;
      v41 += 2;
      v42 += 2;
      v44 -= 16;
    }
    while (v44);
    if (v37 == v12)
      goto LABEL_36;
  }
  else
  {
    v37 = 0;
  }
  v49 = v12 - v37;
  v50 = v37;
  v51 = &v111[v37];
  v52 = &a3[v50];
  v53 = &a4->i16[v50];
  do
  {
    v55 = *v53++;
    v54 = v55;
    v56 = *v52++;
    *v51++ = v54 + (((__int16)(v56 - v54) * v36) >> 2);
    --v49;
  }
  while (v49);
LABEL_36:
  v39 = v111[0];
  LOWORD(v35) = v111[1];
LABEL_37:
  if (v39 <= 1)
    v57 = 1;
  else
    v57 = v39;
  v58 = 0x20000 / v57;
  v59 = (__int16)v35 - v39;
  if (v59 <= 1)
    v59 = 1;
  v60 = 0x20000u / v59;
  v61 = v60 + v58;
  if ((int)(v60 + v58) >= 0x7FFF)
    v61 = 0x7FFF;
  v107[0] = v61;
  if ((int)v12 <= 2)
  {
    v21 = (int)v21;
  }
  else
  {
    v62 = 0;
    v21 = v21;
    do
    {
      v63 = &v111[v62];
      v64 = v63[2];
      v65 = v64 - (__int16)v35;
      if (v65 <= 1)
        v65 = 1;
      v66 = 0x20000u / v65;
      LODWORD(v35) = 0x20000u / v65 + v60;
      if ((int)v35 >= 0x7FFF)
        LOWORD(v35) = 0x7FFF;
      v67 = &v107[v62];
      v67[1] = (_WORD)v35;
      LOWORD(v35) = v63[3];
      v68 = (__int16)v35 - v64;
      if (v68 <= 1)
        v68 = 1;
      v60 = 0x20000u / v68;
      v69 = v60 + v66;
      if ((int)(v60 + v66) >= 0x7FFF)
        v69 = 0x7FFF;
      v67[2] = v69;
      v70 = v62 + 3;
      v62 += 2;
    }
    while (v70 < v21);
  }
  v71 = v21;
  v72 = 0x20000u / (0x8000 - v111[v71]) + v60;
  if (v72 >= 0x7FFF)
    LOWORD(v72) = 0x7FFF;
  v107[v71] = v72;
  if ((int)v12 < 1)
    goto LABEL_67;
  v73 = (__int16)(((_WORD)v36 * (_WORD)v36) << 11);
  if (v12 >= 0x10)
  {
    v74 = v12 & 0x7FFFFFF0;
    v75 = (int16x8_t *)&v110;
    v76 = (int16x4_t *)&v108;
    v77 = vdupq_n_s16(v73);
    v78 = v12 & 0xFFFFFFF0;
    do
    {
      v79 = vsraq_n_s16(vuzp2q_s16((int16x8_t)vmull_s16(*(int16x4_t *)v77.i8, *v76), (int16x8_t)vmull_high_s16(v77, *(int16x8_t *)v76->i8)), *v75, 1uLL);
      v75[-1] = vsraq_n_s16(vuzp2q_s16((int16x8_t)vmull_s16(*(int16x4_t *)v77.i8, v76[-2]), (int16x8_t)vmull_high_s16(v77, *(int16x8_t *)v76[-2].i8)), v75[-1], 1uLL);
      *v75 = v79;
      v75 += 2;
      v76 += 4;
      v78 -= 16;
    }
    while (v78);
    if (v74 == v12)
      goto LABEL_67;
  }
  else
  {
    v74 = 0;
  }
  v80 = v12 - v74;
  v81 = v74;
  v82 = &v107[v74];
  v83 = &v109.i16[v81];
  do
  {
    v84 = *v82++;
    *v83 = (*v83 >> 1) + ((v84 * v73) >> 16);
    ++v83;
    --v80;
  }
  while (v80);
LABEL_67:
  v38 = 1;
LABEL_68:
  silk_NLSF_encode((char *)(a1 + 4760), a3, *(int16x8_t ***)(a1 + 4704), &v109, v11, *(unsigned int *)(a1 + 4660), *v8);
  silk_NLSF2A(a2 + 2, a3, *(_DWORD *)(a1 + 4640));
  v85 = *(unsigned int *)(a1 + 4640);
  v86 = *(_DWORD *)(a1 + 4640);
  if (!v38)
    return memcpy(a2, &a2[2], 2 * (int)v85);
  if (v86 >= 1)
  {
    v87 = v8[2];
    if (v85 >= 0x10)
    {
      v88 = v85 & 0xFFFFFFF0;
      v90 = a4 + 1;
      v91 = (int16x8_t *)(a3 + 8);
      v92 = (int16x8_t *)v112;
      v93 = vdupq_n_s32(v87);
      v94 = v88;
      do
      {
        v95 = v90[-1];
        v96 = vsubq_s16(v91[-1], v95);
        v97 = vsubq_s16(*v91, *v90);
        v98 = vaddq_s16(*v90, vshrn_high_n_s32(vshrn_n_s32(vmulq_s32(v93, vmovl_s16(*(int16x4_t *)v97.i8)), 2uLL), vmulq_s32(v93, vmovl_high_s16(v97)), 2uLL));
        v92[-1] = vaddq_s16(v95, vshrn_high_n_s32(vshrn_n_s32(vmulq_s32(v93, vmovl_s16(*(int16x4_t *)v96.i8)), 2uLL), vmulq_s32(v93, vmovl_high_s16(v96)), 2uLL));
        *v92 = v98;
        v90 += 2;
        v91 += 2;
        v92 += 2;
        v94 -= 16;
      }
      while (v94);
      if (v88 == v85)
        return (void *)silk_NLSF2A(a2, v111, v86);
    }
    else
    {
      v88 = 0;
    }
    v99 = v85 - v88;
    v100 = v88;
    v101 = &v111[v88];
    v102 = &a3[v100];
    v103 = &a4->i16[v100];
    do
    {
      v105 = *v103++;
      v104 = v105;
      v106 = *v102++;
      *v101++ = v104 + (((__int16)(v106 - v104) * v87) >> 2);
      --v99;
    }
    while (v99);
  }
  return (void *)silk_NLSF2A(a2, v111, v86);
}

uint64_t quant_coarse_energy(float32x4_t *a1, uint64_t a2, int a3, int a4, uint64_t a5, char *a6, unsigned int a7, void *a8, uint64_t a9, int a10, unsigned int a11, int a12, int a13, float *a14, int a15, int a16, int a17)
{
  uint64_t v19;
  float v21;
  _BOOL4 v22;
  int v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float32x4_t *v33;
  unint64_t v34;
  float32x4_t *v35;
  float32x4_t *v36;
  unint64_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  uint64_t v42;
  uint64_t v43;
  float *v44;
  float *v45;
  float v46;
  float v47;
  float v48;
  float v49;
  __int128 *v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  float v54;
  float v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  _BOOL4 v63;
  _BOOL4 v64;
  int v65;
  const void *v66;
  uint64_t v67;
  uint64_t v68;
  const void *v69;
  uint64_t result;
  float *v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  uint64_t v76;
  int v77;
  int v78;
  size_t v79;
  uint64_t v80;
  char *v81;
  void *v82;
  void *v83;
  uint64_t v84;
  int v85;
  unsigned int v86;
  unsigned int v87;
  uint64_t v88;
  int v89;
  void *v90;
  _BOOL4 v91;
  int v92;
  uint64_t *v93;
  uint64_t v94;
  const void *v95;
  char *v96;
  _BOOL4 v97;
  uint64_t *v98;
  float *v99;
  void *v100;
  int v101;
  int v102;
  uint64_t v103;
  int v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  unsigned int v108;
  __int128 v109;
  int v110;
  __int128 v111;
  uint64_t v112;
  __int128 v113;
  uint64_t v114;
  _BYTE v115[28];
  uint64_t v116;

  v108 = a7;
  v19 = (uint64_t)a1;
  v116 = *MEMORY[0x24BDAC8D0];
  if (a13)
  {
    v21 = *a14;
    v22 = 1;
  }
  else
  {
    v21 = *a14;
    v22 = !a15 && (v23 = (a3 - a2) * a10, v21 > (float)(2 * v23)) && v23 < a12;
  }
  v107 = a11;
  v24 = 0.0;
  v25 = a1->i32[2];
  if ((int)a2 < a4)
  {
    v26 = 0;
    v27 = 0;
    if (a10 <= 1)
      v28 = 1;
    else
      v28 = a10;
    v29 = a4;
    v30 = a4 - (uint64_t)(int)a2;
    v31 = 4 * (int)a2 + 16;
    a1 = (float32x4_t *)(a5 + v31);
    v32 = 4 * v25;
    v33 = (float32x4_t *)&a6[v31];
    do
    {
      if (v30 >= 8)
      {
        v35 = v33;
        v36 = a1;
        v37 = v30 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v38 = vsubq_f32(v36[-1], v35[-1]);
          v39 = vsubq_f32(*v36, *v35);
          v40 = vmulq_f32(v38, v38);
          v41 = vmulq_f32(v39, v39);
          v24 = (float)((float)((float)((float)((float)((float)((float)(v24 + v40.f32[0]) + v40.f32[1]) + v40.f32[2])
                                              + v40.f32[3])
                                      + v41.f32[0])
                              + v41.f32[1])
                      + v41.f32[2])
              + v41.f32[3];
          v36 += 2;
          v35 += 2;
          v37 -= 8;
        }
        while (v37);
        v34 = (v30 & 0xFFFFFFFFFFFFFFF8) + (int)a2;
        if (v30 == (v30 & 0xFFFFFFFFFFFFFFF8))
          goto LABEL_12;
      }
      else
      {
        v34 = (int)a2;
      }
      v42 = v29 - v34;
      v43 = 4 * (v34 + v26);
      v44 = (float *)&a6[v43];
      v45 = (float *)(a5 + v43);
      do
      {
        v46 = *v45++;
        v47 = v46;
        v48 = *v44++;
        v24 = v24 + (float)((float)(v47 - v48) * (float)(v47 - v48));
        --v42;
      }
      while (v42);
LABEL_12:
      ++v27;
      a1 = (float32x4_t *)((char *)a1 + v32);
      v33 = (float32x4_t *)((char *)v33 + v32);
      v26 += v25;
    }
    while (v27 != v28);
  }
  v100 = a8;
  v98 = &v88;
  if (v24 <= 200.0)
    v49 = v24;
  else
    v49 = 200.0;
  v50 = (__int128 *)(a9 + 32);
  v51 = *(unsigned int *)(a9 + 28);
  v52 = *(_DWORD *)(a9 + 24) + __clz(*(_DWORD *)(a9 + 32));
  v101 = v52 - 32;
  v53 = v52 - 29;
  v104 = a3;
  v103 = a2;
  v54 = (float)a12 * 0.125;
  if (v54 > 16.0)
    v54 = 16.0;
  if (a3 - (int)a2 <= 10)
    v54 = 16.0;
  v102 = a17;
  if (a17)
    v55 = 3.0;
  else
    v55 = v54;
  *(_OWORD *)v115 = *(_OWORD *)a9;
  *(_OWORD *)&v115[12] = *(_OWORD *)(a9 + 12);
  v114 = *(_QWORD *)(a9 + 48);
  v113 = *v50;
  MEMORY[0x24BDAC7A8](a1, a2);
  v105 = v57;
  v59 = (void *)MEMORY[0x24BDAC7A8]((char *)&v88 - v56, v58);
  v96 = (char *)&v88 - v60;
  v95 = v59;
  v62 = (uint64_t)memcpy(v59, a6, 4 * v61);
  v63 = v53 <= v108 && a15 != 0;
  v64 = v22 && v53 <= v108;
  v106 = (int)v107;
  v97 = v63;
  v99 = a14;
  if (v63 || v64)
  {
    v65 = v105;
    v66 = v96;
    v67 = v19;
    v68 = v19;
    v69 = v95;
    v62 = quant_coarse_energy_impl(v67, v103, v104, a5, (uint64_t)v95, v108, v101, (uint64_t)&e_prob_model + 84 * (int)v106 + 42, v55, (uint64_t)v96, a9, v105, v107, 1, v102);
    if (v64)
    {
      memcpy(a6, v69, 4 * *(_DWORD *)(v68 + 8) * v65);
      result = (uint64_t)memcpy(v100, v66, 4 * *(_DWORD *)(v68 + 8) * v65);
      v71 = v99;
      goto LABEL_49;
    }
    v92 = v62;
    v94 = v68;
  }
  else
  {
    v94 = v19;
    v92 = 0;
  }
  v93 = &v88;
  v72 = *(_DWORD *)(a9 + 32);
  v73 = __clz(v72);
  v74 = v72 >> (16 - v73);
  v75 = v74 >> 12;
  v91 = v74 > ec_tell_frac_correction[(v74 >> 12) - 8];
  v76 = *(_QWORD *)a9;
  v109 = *(_OWORD *)(a9 + 8);
  v78 = *(_DWORD *)(a9 + 24);
  v77 = *(_DWORD *)(a9 + 28);
  v110 = v78;
  v111 = *v50;
  v112 = *(_QWORD *)(a9 + 48);
  v88 = v76;
  v89 = v77;
  v79 = (v77 - v51);
  MEMORY[0x24BDAC7A8](v62, v76 + v51);
  v81 = (char *)&v88 - v80;
  v90 = v82;
  memcpy((char *)&v88 - v80, v82, v79);
  *(_OWORD *)a9 = *(_OWORD *)v115;
  *(_OWORD *)(a9 + 12) = *(_OWORD *)&v115[12];
  *(_DWORD *)(a9 + 28) = v51;
  *v50 = v113;
  *(_QWORD *)(a9 + 48) = v114;
  v83 = v100;
  result = quant_coarse_energy_impl(v94, v103, v104, a5, (uint64_t)a6, v108, v101, (uint64_t)&e_prob_model + 84 * (int)v106, v55, (uint64_t)v100, a9, v105, v107, 0, v102);
  if (v97
    && (v92 < (int)result
     || v92 == (_DWORD)result
     && (v86 = *(_DWORD *)(a9 + 32),
         v87 = __clz(v86),
         (int)(((__PAIR64__((int)(float)((float)((float)(v21 * (float)v108) * (float)a16) / (float)(v105 << 9))+ 8 * (v87 + *(_DWORD *)(a9 + 24)), ec_tell_frac_correction[(v86 >> (16 - v87) >> 12) - 8])- __PAIR64__(v86 >> (16 - v87) >> 12, v86 >> (16 - v87))) >> 32)- 248) > (int)(8 * (v73 + v78) - v75 - v91 - 248))))
  {
    *(_QWORD *)a9 = v88;
    *(_OWORD *)(a9 + 8) = v109;
    *(_DWORD *)(a9 + 24) = v110;
    *(_DWORD *)(a9 + 28) = v89;
    *v50 = v111;
    *(_QWORD *)(a9 + 48) = v112;
    memcpy(v90, v81, v79);
    v84 = v94;
    v85 = v105;
    memcpy(a6, v95, 4 * *(_DWORD *)(v94 + 8) * v105);
    result = (uint64_t)memcpy(v83, v96, 4 * *(_DWORD *)(v84 + 8) * v85);
    v71 = v99;
  }
  else
  {
    v71 = v99;
    v49 = v49 + (float)((float)(pred_coef[v106] * pred_coef[v106]) * *v99);
  }
LABEL_49:
  *v71 = v49;
  return result;
}

uint64_t quant_coarse_energy_impl(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, uint64_t a8, float a9, uint64_t a10, uint64_t a11, int a12, int a13, int a14, int a15)
{
  float v18;
  float v19;
  unsigned int v20;
  float v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  BOOL v27;
  int v28;
  int v29;
  int v30;
  float v31;
  int v32;
  uint64_t v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  int v39;
  float v40;
  int v41;
  int v42;
  signed int v43;
  int v44;
  int v45;
  int v46;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  int v56;
  int v58;
  int v59;
  int v60;
  int v61;
  unsigned int v62;
  uint64_t v63;
  int v65;
  int v66;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  _QWORD v75[3];

  v75[1] = *MEMORY[0x24BDAC8D0];
  v75[0] = 0;
  v69 = a2;
  if (a7 + 3 <= a6)
  {
    ec_enc_bit_logp((uint64_t *)a11, a14, 3);
    a2 = v69;
  }
  if (a14)
  {
    v18 = 0.0;
    v19 = 0.14999;
    v66 = a15;
    if (a2 < a3)
      goto LABEL_5;
LABEL_86:
    v20 = 0;
    goto LABEL_87;
  }
  v63 = 4 * a13;
  v19 = *(float *)((char *)&beta_coef + v63);
  v18 = *(float *)((char *)&pred_coef + v63);
  v66 = a15;
  if (a2 >= a3)
    goto LABEL_86;
LABEL_5:
  v20 = 0;
  v65 = a3;
  v21 = -v19;
  if (a12 <= 1)
    v22 = 1;
  else
    v22 = a12;
  v71 = v22;
  v23 = *(_DWORD *)(a1 + 8);
  v70 = a6 + 32;
  v24 = a2;
  while (2)
  {
    v25 = 0;
    v26 = 3 * a12 * (v24 - a3);
    if (v66)
      v27 = v24 <= 1;
    else
      v27 = 1;
    v28 = !v27;
    if (v24 >= 20)
      v29 = 20;
    else
      v29 = v24;
    v68 = 2 * v29;
    do
    {
      v33 = 4 * (v24 + v23 * (int)v25);
      v34 = *(float *)(a4 + v33);
      v35 = *(float *)(a5 + v33);
      if (v35 >= -9.0)
        v36 = *(float *)(a5 + v33);
      else
        v36 = -9.0;
      v37 = *((float *)v75 + v25);
      v38 = (float)(v34 + (float)((float)-v18 * v36)) - v37;
      v39 = vcvtms_s32_f32(v38 + 0.5);
      if (v35 < -28.0)
        v35 = -28.0;
      v40 = v35 - a9;
      v41 = (v39 + (int)(float)(v40 - v34)) & ((v39 + (int)(float)(v40 - v34)) >> 31);
      if (v34 >= v40)
        v41 = v39;
      if (v39 < 0)
        v42 = v41;
      else
        v42 = v39;
      v43 = v70 - *(_DWORD *)(a11 + 24) - __clz(*(_DWORD *)(a11 + 32));
      v44 = v43 + v26;
      if (v42 >= 1)
        v45 = 1;
      else
        v45 = v42;
      if (v45 < 0)
        v46 = -1;
      else
        v46 = v45;
      if (v44 < 16)
        v45 = v46;
      if (v44 <= 29 && v44 <= 23)
        v48 = v45;
      else
        v48 = v42;
      if (v24 == a2)
        v48 = v42;
      if (v28)
        v49 = v48 & (v48 >> 31);
      else
        v49 = v48;
      if (v43 >= 15)
      {
        v50 = *(unsigned __int8 *)(a8 + v68) << 7;
        if (v49)
        {
          v51 = *(unsigned __int8 *)(a8 + (v68 | 1)) << 6;
          if (v49 >= 0)
            v52 = v49;
          else
            v52 = -v49;
          v53 = (0x4000 - v51) * (32736 - v50);
          v54 = v53 >> 15;
          v55 = 1;
          if (v53 >= 0x8000 && v52 >= 2)
          {
            do
            {
              v56 = 2 * v54;
              v50 += v56 + 2;
              v53 = v56 * v51;
              ++v55;
              v54 = (v56 * v51) >> 15;
            }
            while (v53 >= 0x8000 && v55 < v52);
          }
          if (v53 >> 15)
          {
            if (v49 >= 0)
              v62 = v54 + 1;
            else
              v62 = 0;
            v30 = v62 + v50;
            v50 = v54 + 1;
          }
          else
          {
            v58 = v49 >> 31;
            v59 = v52 - v55;
            if (v59 >= ((int)(((v49 >> 31) | 0x8000) - v50) >> 1) - 1)
              v59 = ((int)(((v49 >> 31) | 0x8000) - v50) >> 1) - 1;
            v60 = v58 + v50 + 2 * v59;
            v30 = v60 + 1;
            v50 = v60 != 0x7FFF;
            v49 = (v55 + v58 + v59) ^ v58;
          }
        }
        else
        {
          v30 = 0;
        }
        ec_encode_bin((uint64_t *)a11, v30, v30 + v50, 15);
        goto LABEL_22;
      }
      if (v43 >= 2)
      {
        if (v49 >= 1)
          v61 = 1;
        else
          v61 = v49;
        if (v61 < 0)
          v49 = -1;
        else
          v49 = v61;
        ec_enc_icdf((uint64_t *)a11, (2 * v49) ^ (v49 >> 31), (uint64_t)&small_energy_icdf, 2);
        goto LABEL_22;
      }
      if (v43 == 1)
      {
        v49 &= v49 >> 31;
        ec_enc_bit_logp((uint64_t *)a11, -v49, 1);
LABEL_22:
        a2 = v69;
        goto LABEL_23;
      }
      v49 = -1;
LABEL_23:
      v31 = (float)v49;
      v23 = *(_DWORD *)(a1 + 8);
      *(float *)(a10 + 4 * (v24 + v23 * (int)v25)) = v38 - (float)v49;
      v32 = v42 - v49;
      if (v42 - v49 < 0)
        v32 = v49 - v42;
      v20 += v32;
      *(float *)(a5 + 4 * (v24 + v23 * (int)v25)) = (float)(v37 + (float)(v18 * v36)) + v31;
      *((float *)v75 + v25++) = (float)(v37 + v31) + (float)(v21 * v31);
    }
    while (v25 != v71);
    ++v24;
    a3 = v65;
    if (v24 != v65)
      continue;
    break;
  }
LABEL_87:
  if (v66)
    return 0;
  else
    return v20;
}

uint64_t quant_fine_energy(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8)
{
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  float v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  BOOL v26;
  int v27;
  unsigned int v28;

  if (a2 < a3)
  {
    if (a8 <= 1)
      v8 = 1;
    else
      v8 = a8;
    v9 = a2;
    do
    {
      v10 = *(_DWORD *)(a6 + 4 * v9);
      if (v10 >= 1)
      {
        v11 = 0;
        v12 = 0x10000 << v10 >> 16;
        v13 = *(_DWORD *)(result + 8);
        v14 = *((_DWORD *)a7 + 4);
        v15 = *((_DWORD *)a7 + 5);
        do
        {
          v17 = v9 + v11 * v13;
          v21 = vcvtms_s32_f32((float)(*(float *)(a5 + 4 * v17) + 0.5) * (float)v12);
          if (v12 <= v21)
            v21 = v12 - 1;
          v16 = v15 + v10;
          if ((v15 + v10) >= 0x21)
          {
            do
            {
              v28 = *((_DWORD *)a7 + 2);
              v27 = *((_DWORD *)a7 + 3);
              if (v27 + *((_DWORD *)a7 + 7) < v28)
              {
                v22 = 0;
                v23 = *a7;
                v24 = v27 + 1;
                *((_DWORD *)a7 + 3) = v24;
                *(_BYTE *)(v23 + v28 - v24) = v14;
              }
              else
              {
                v22 = -1;
              }
              *((_DWORD *)a7 + 12) |= v22;
              v14 >>= 8;
              v25 = v15 - 8;
              v26 = v15 <= 15;
              v15 -= 8;
            }
            while (!v26);
            v16 = v10 + v25;
            v13 = *(_DWORD *)(result + 8);
            v17 = v9 + v13 * v11;
            LOBYTE(v15) = v25;
          }
          v18 = v21 & ~(v21 >> 31);
          v14 |= v18 << v15;
          *((_DWORD *)a7 + 4) = v14;
          *((_DWORD *)a7 + 5) = v16;
          *((_DWORD *)a7 + 6) += v10;
          v10 = *(_DWORD *)(a6 + 4 * v9);
          v19 = 4 * v17;
          v20 = (float)((float)((float)((float)v18 + 0.5) * (float)(1 << (14 - v10))) * 0.000061035) + -0.5;
          *(float *)(a4 + v19) = *(float *)(a4 + 4 * v17) + v20;
          *(float *)(a5 + v19) = *(float *)(a5 + 4 * v17) - v20;
          ++v11;
          v15 = v16;
        }
        while (v11 != v8);
      }
      ++v9;
    }
    while ((_DWORD)v9 != a3);
  }
  return result;
}

uint64_t quant_energy_finalise(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t *a9, int a10)
{
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  uint64_t v19;
  float v20;
  uint64_t v21;
  float v22;
  float v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  BOOL v28;
  int v29;
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  float v39;
  float v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  unsigned int v46;

  if (a2 < a3)
  {
    if (a10 <= 1)
      v10 = 1;
    else
      v10 = a10;
    v11 = a2;
    v12 = a3;
    if (a8 >= a10)
    {
      v13 = a2;
      do
      {
        if (*(int *)(a6 + 4 * v13) <= 7)
        {
          v14 = *(_DWORD *)(a7 + 4 * v13);
          if (!v14)
          {
            v15 = *(_DWORD *)(result + 8);
            v16 = *((_DWORD *)a9 + 4);
            v17 = *((_DWORD *)a9 + 5);
            do
            {
              v19 = v13 + v14 * v15;
              v23 = *(float *)(a5 + 4 * v19);
              v18 = v17 + 1;
              if ((v17 + 1) >= 0x21)
              {
                do
                {
                  v30 = *((_DWORD *)a9 + 2);
                  v29 = *((_DWORD *)a9 + 3);
                  if (v29 + *((_DWORD *)a9 + 7) < v30)
                  {
                    v24 = 0;
                    v25 = *a9;
                    v26 = v29 + 1;
                    *((_DWORD *)a9 + 3) = v26;
                    *(_BYTE *)(v25 + v30 - v26) = v16;
                  }
                  else
                  {
                    v24 = -1;
                  }
                  *((_DWORD *)a9 + 12) |= v24;
                  v16 >>= 8;
                  v27 = v17 - 8;
                  v28 = v17 <= 15;
                  v17 -= 8;
                }
                while (!v28);
                v18 = v27 + 1;
                v15 = *(_DWORD *)(result + 8);
                v19 = v13 + v15 * v14;
                LOBYTE(v17) = v27;
              }
              v16 |= (v23 >= 0.0) << v17;
              *((_DWORD *)a9 + 4) = v16;
              *((_DWORD *)a9 + 5) = v18;
              ++*((_DWORD *)a9 + 6);
              if (v23 < 0.0)
                v20 = 0.0;
              else
                v20 = 1.0;
              v21 = 4 * v19;
              v22 = (float)((float)(v20 + -0.5) * (float)(1 << (13 - *(_DWORD *)(a6 + 4 * v13)))) * 0.000061035;
              *(float *)(a4 + v21) = *(float *)(a4 + 4 * v19) + v22;
              *(float *)(a5 + v21) = *(float *)(a5 + 4 * v19) - v22;
              ++v14;
              v17 = v18;
            }
            while (v14 != v10);
            a8 -= v10;
          }
        }
        ++v13;
      }
      while (v13 < v12 && a8 >= a10);
    }
    if (a8 >= a10)
    {
      do
      {
        if (*(int *)(a6 + 4 * v11) <= 7 && *(_DWORD *)(a7 + 4 * v11) == 1)
        {
          v31 = 0;
          v32 = *(_DWORD *)(result + 8);
          v34 = *((_DWORD *)a9 + 4);
          v33 = *((_DWORD *)a9 + 5);
          do
          {
            v36 = v11 + v31 * v32;
            v40 = *(float *)(a5 + 4 * v36);
            v35 = v33 + 1;
            if ((v33 + 1) >= 0x21)
            {
              do
              {
                v46 = *((_DWORD *)a9 + 2);
                v45 = *((_DWORD *)a9 + 3);
                if (v45 + *((_DWORD *)a9 + 7) < v46)
                {
                  v41 = 0;
                  v42 = *a9;
                  v43 = v45 + 1;
                  *((_DWORD *)a9 + 3) = v43;
                  *(_BYTE *)(v42 + v46 - v43) = v34;
                }
                else
                {
                  v41 = -1;
                }
                *((_DWORD *)a9 + 12) |= v41;
                v34 >>= 8;
                v44 = v33 - 8;
                v28 = v33 <= 15;
                v33 -= 8;
              }
              while (!v28);
              v35 = v44 + 1;
              v32 = *(_DWORD *)(result + 8);
              v36 = v11 + v32 * v31;
              LOBYTE(v33) = v44;
            }
            v34 |= (v40 >= 0.0) << v33;
            *((_DWORD *)a9 + 4) = v34;
            *((_DWORD *)a9 + 5) = v35;
            ++*((_DWORD *)a9 + 6);
            if (v40 < 0.0)
              v37 = 0.0;
            else
              v37 = 1.0;
            v38 = 4 * v36;
            v39 = (float)((float)(v37 + -0.5) * (float)(1 << (13 - *(_DWORD *)(a6 + 4 * v11)))) * 0.000061035;
            *(float *)(a4 + v38) = *(float *)(a4 + 4 * v36) + v39;
            *(float *)(a5 + v38) = *(float *)(a5 + 4 * v36) - v39;
            ++v31;
            v33 = v35;
          }
          while (v31 != v10);
          a8 -= v10;
        }
        ++v11;
      }
      while (v11 < v12 && a8 >= a10);
    }
  }
  return result;
}

uint64_t unquant_coarse_energy(uint64_t result, int a2, int a3, uint64_t a4, int a5, uint64_t *a6, int a7, int a8)
{
  float v8;
  float v9;
  uint64_t v10;
  char *v11;
  unsigned int v12;
  float v13;
  uint64_t v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  float v21;
  float v22;
  float v23;
  signed int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  char *v35;
  unsigned int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  int v43;
  BOOL v44;
  int v45;
  unsigned int v46;
  int v47;
  unsigned int v48;
  unsigned int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  uint64_t v56;
  int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  int v61;
  unsigned int v62;
  int v63;
  unsigned int v64;
  uint64_t v65;
  int v66;
  _QWORD v67[2];

  v67[1] = *MEMORY[0x24BDAC8D0];
  v67[0] = 0;
  if (a5)
  {
    v8 = 0.0;
    v9 = 0.14999;
    if (a2 >= a3)
      return result;
  }
  else
  {
    v10 = 4 * a8;
    v9 = *(float *)((char *)&beta_coef + v10);
    v8 = *(float *)((char *)&pred_coef + v10);
    if (a2 >= a3)
      return result;
  }
  v11 = (char *)&e_prob_model + 84 * a8 + 42 * a5;
  v12 = *((_DWORD *)a6 + 2);
  v13 = -v9;
  if (a7 <= 1)
    v14 = 1;
  else
    v14 = a7;
  v15 = *(_DWORD *)(result + 8);
  v16 = *((_DWORD *)a6 + 6);
  v17 = *((_DWORD *)a6 + 8);
  result = 0x4000;
  do
  {
    v18 = 0;
    if (a2 >= 20)
      v19 = 20;
    else
      v19 = a2;
    v20 = 2 * v19;
    do
    {
      v24 = 8 * v12 + 32 - (v16 + __clz(v17));
      if (v24 < 15)
      {
        if (v24 < 2)
        {
          if (v24 == 1)
          {
            v59 = *((_DWORD *)a6 + 9);
            v60 = v17 >> 1;
            v61 = v59;
            if (v59 >= v17 >> 1)
            {
              *((_DWORD *)a6 + 9) = v59 - (v17 >> 1);
              v61 = v59 - v60;
            }
            if (v59 >= v60)
              v62 = v17 - v60;
            else
              v62 = v17 >> 1;
            *((_DWORD *)a6 + 8) = v62;
            if (v62 >= 0x800001)
            {
              v17 = v62;
            }
            else
            {
              v63 = *((_DWORD *)a6 + 11);
              v64 = *((_DWORD *)a6 + 7);
              do
              {
                v16 += 8;
                *((_DWORD *)a6 + 6) = v16;
                v17 = v62 << 8;
                *((_DWORD *)a6 + 8) = v62 << 8;
                if (v64 < v12)
                {
                  v65 = *a6;
                  *((_DWORD *)a6 + 7) = v64 + 1;
                  v66 = *(unsigned __int8 *)(v65 + v64++);
                }
                else
                {
                  v66 = 0;
                }
                *((_DWORD *)a6 + 11) = v66;
                v61 = (((v61 & 0x7FFFFF) << 8) | ((v66 | (v63 << 8)) >> 1)) ^ 0xFF;
                *((_DWORD *)a6 + 9) = v61;
                v63 = v66;
                v44 = v62 > 0x8000;
                v62 <<= 8;
              }
              while (!v44);
            }
            if (v59 >= v60)
              v30 = 0;
            else
              v30 = -1;
          }
          else
          {
            v30 = -1;
          }
        }
        else
        {
          v32 = *((_DWORD *)a6 + 9);
          v33 = v17 >> 2;
          v34 = -1;
          v35 = &small_energy_icdf;
          do
          {
            v36 = v17;
            v37 = *v35++;
            v17 = v33 * v37;
            ++v34;
            v38 = v32 - v33 * v37;
          }
          while (v32 < v33 * v37);
          v39 = v36 - v17;
          *((_DWORD *)a6 + 8) = v36 - v17;
          *((_DWORD *)a6 + 9) = v38;
          if (v36 - v17 >= 0x800001)
          {
            v17 = v36 - v17;
          }
          else
          {
            v40 = *((_DWORD *)a6 + 11);
            v41 = *((_DWORD *)a6 + 7);
            do
            {
              v16 += 8;
              *((_DWORD *)a6 + 6) = v16;
              v17 = v39 << 8;
              *((_DWORD *)a6 + 8) = v39 << 8;
              if (v41 < v12)
              {
                v42 = *a6;
                *((_DWORD *)a6 + 7) = v41 + 1;
                v43 = *(unsigned __int8 *)(v42 + v41++);
              }
              else
              {
                v43 = 0;
              }
              *((_DWORD *)a6 + 11) = v43;
              v38 = (((v38 & 0x7FFFFF) << 8) | ((v43 | (v40 << 8)) >> 1)) ^ 0xFF;
              *((_DWORD *)a6 + 9) = v38;
              v40 = v43;
              v44 = v39 > 0x8000;
              v39 <<= 8;
            }
            while (!v44);
          }
          v30 = -(v34 & 1) ^ (v34 >> 1);
        }
      }
      else
      {
        v25 = v11[v20] << 7;
        v26 = v11[v20 | 1];
        v27 = v17 >> 15;
        *((_DWORD *)a6 + 10) = v17 >> 15;
        v28 = *((_DWORD *)a6 + 9);
        if (v28 / (v17 >> 15) + 1 <= 0x8000)
          v29 = 0x7FFF - v28 / (v17 >> 15);
        else
          v29 = 0;
        if (v29 >= v25)
        {
          v45 = v26 << 6;
          v46 = (0x4000 - (v26 << 6)) * (32736 - v25);
          v47 = (v46 >> 15) + 1;
          v30 = 1;
          if (v46 < 0x8000)
          {
LABEL_37:
            v30 += (v29 - v25) >> 1;
            v48 = ((v29 - v25) & 0xFFFFFFFE) + v25;
          }
          else
          {
            v48 = v25;
            while (1)
            {
              v25 = 2 * v47 + v48;
              if (v29 < v25)
                break;
              ++v30;
              v49 = ((2 * v47 - 2) * v45) >> 15;
              v47 = v49 + 1;
              v48 = v25;
              if (!v49)
                goto LABEL_37;
            }
          }
          if (v29 >= v48 + v47)
          {
            v31 = v48 + v47;
          }
          else
          {
            v30 = -v30;
            v31 = v48;
          }
          v25 = v47;
        }
        else
        {
          v30 = 0;
          v31 = 0;
        }
        v50 = v25 + v31;
        if (v25 + v31 >= 0x8000)
          v50 = 0x8000;
        v51 = (0x8000 - v50) * v27;
        v52 = v28 - v51;
        v53 = (v50 - v31) * v27;
        v17 -= v51;
        if (v31)
          v17 = v53;
        *((_DWORD *)a6 + 8) = v17;
        *((_DWORD *)a6 + 9) = v52;
        if (v17 < 0x800001)
        {
          v54 = *((_DWORD *)a6 + 11);
          v55 = *((_DWORD *)a6 + 7);
          do
          {
            v16 += 8;
            *((_DWORD *)a6 + 6) = v16;
            v58 = v17 << 8;
            *((_DWORD *)a6 + 8) = v17 << 8;
            if (v55 < v12)
            {
              v56 = *a6;
              *((_DWORD *)a6 + 7) = v55 + 1;
              v57 = *(unsigned __int8 *)(v56 + v55++);
            }
            else
            {
              v57 = 0;
            }
            *((_DWORD *)a6 + 11) = v57;
            v52 = (((v52 & 0x7FFFFF) << 8) | ((v57 | (v54 << 8)) >> 1)) ^ 0xFF;
            *((_DWORD *)a6 + 9) = v52;
            v54 = v57;
            v44 = v17 > 0x8000;
            v17 <<= 8;
          }
          while (!v44);
          v17 = v58;
        }
      }
      v21 = (float)v30;
      v22 = *(float *)(a4 + 4 * (a2 + v15 * (int)v18));
      if (v22 < -9.0)
        v22 = -9.0;
      v23 = *((float *)v67 + v18);
      *(float *)(a4 + 4 * (a2 + v15 * (int)v18)) = (float)(v23 + (float)(v8 * v22)) + v21;
      *((float *)v67 + v18++) = (float)(v23 + v21) + (float)(v13 * v21);
    }
    while (v18 != v14);
    ++a2;
  }
  while (a2 != a3);
  return result;
}

uint64_t unquant_energy_finalise(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t *a8, int a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  float *v31;
  int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  float *v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;

  if (a2 < a3)
  {
    if (a9 <= 1)
      v9 = 1;
    else
      v9 = a9;
    v10 = a2;
    v11 = a3;
    if (a7 >= a9)
    {
      v12 = a2;
      v13 = (float *)(a4 + 4 * a2);
      while (*(int *)(a5 + 4 * v12) > 7 || *(_DWORD *)(a6 + 4 * v12))
      {
LABEL_24:
        if (++v12 < v11)
        {
          ++v13;
          if (a7 >= a9)
            continue;
        }
        goto LABEL_26;
      }
      v14 = *((_DWORD *)a8 + 4);
      v15 = *((_DWORD *)a8 + 5);
      v16 = 4 * *(int *)(result + 8);
      v17 = v9;
      v18 = v13;
      while (1)
      {
        if (v15)
          goto LABEL_12;
        v23 = *((_DWORD *)a8 + 2);
        v24 = *((_DWORD *)a8 + 3);
        if (v24 >= v23)
          break;
        v25 = *a8;
        *((_DWORD *)a8 + 3) = ++v24;
        v26 = *(unsigned __int8 *)(v25 + v23 - v24);
        if (v24 >= v23)
          goto LABEL_16;
        v29 = *a8;
        *((_DWORD *)a8 + 3) = ++v24;
        v27 = *(unsigned __int8 *)(v29 + v23 - v24);
        if (v24 >= v23)
        {
LABEL_17:
          v28 = 0;
          if (v24 >= v23)
            goto LABEL_22;
          goto LABEL_10;
        }
LABEL_21:
        v30 = *a8;
        *((_DWORD *)a8 + 3) = ++v24;
        v28 = *(unsigned __int8 *)(v30 + v23 - v24);
        if (v24 >= v23)
        {
LABEL_22:
          v21 = 0;
          goto LABEL_11;
        }
LABEL_10:
        v19 = *a8;
        v20 = v24 + 1;
        *((_DWORD *)a8 + 3) = v20;
        v21 = *(unsigned __int8 *)(v19 + v23 - v20);
LABEL_11:
        v14 |= v26 | (v27 << 8) | (v28 << 16) | (v21 << 24);
        v15 = 32;
LABEL_12:
        v22 = v14 & 1;
        v14 >>= 1;
        --v15;
        *((_DWORD *)a8 + 4) = v14;
        *((_DWORD *)a8 + 5) = v15;
        ++*((_DWORD *)a8 + 6);
        *v18 = *v18
             + (float)((float)((float)((float)v22 + -0.5) * (float)(1 << (13 - *(_DWORD *)(a5 + 4 * v12)))) * 0.000061035);
        v18 = (float *)((char *)v18 + v16);
        if (!--v17)
        {
          a7 -= v9;
          goto LABEL_24;
        }
      }
      v26 = 0;
LABEL_16:
      v27 = 0;
      if (v24 >= v23)
        goto LABEL_17;
      goto LABEL_21;
    }
LABEL_26:
    if (a7 >= a9)
    {
      v31 = (float *)(a4 + 4 * v10);
      while (*(int *)(a5 + 4 * v10) > 7 || *(_DWORD *)(a6 + 4 * v10) != 1)
      {
LABEL_45:
        if (++v10 < v11)
        {
          ++v31;
          if (a7 >= a9)
            continue;
        }
        return result;
      }
      v33 = *((_DWORD *)a8 + 4);
      v32 = *((_DWORD *)a8 + 5);
      v34 = 4 * *(int *)(result + 8);
      v35 = v9;
      v36 = v31;
      while (1)
      {
        if (v32)
          goto LABEL_33;
        v41 = *((_DWORD *)a8 + 2);
        v42 = *((_DWORD *)a8 + 3);
        if (v42 >= v41)
          break;
        v43 = *a8;
        *((_DWORD *)a8 + 3) = ++v42;
        v44 = *(unsigned __int8 *)(v43 + v41 - v42);
        if (v42 >= v41)
          goto LABEL_37;
        v47 = *a8;
        *((_DWORD *)a8 + 3) = ++v42;
        v45 = *(unsigned __int8 *)(v47 + v41 - v42);
        if (v42 >= v41)
        {
LABEL_38:
          v46 = 0;
          if (v42 >= v41)
            goto LABEL_43;
          goto LABEL_31;
        }
LABEL_42:
        v48 = *a8;
        *((_DWORD *)a8 + 3) = ++v42;
        v46 = *(unsigned __int8 *)(v48 + v41 - v42);
        if (v42 >= v41)
        {
LABEL_43:
          v39 = 0;
          goto LABEL_32;
        }
LABEL_31:
        v37 = *a8;
        v38 = v42 + 1;
        *((_DWORD *)a8 + 3) = v38;
        v39 = *(unsigned __int8 *)(v37 + v41 - v38);
LABEL_32:
        v33 |= v44 | (v45 << 8) | (v46 << 16) | (v39 << 24);
        v32 = 32;
LABEL_33:
        v40 = v33 & 1;
        v33 >>= 1;
        --v32;
        *((_DWORD *)a8 + 4) = v33;
        *((_DWORD *)a8 + 5) = v32;
        ++*((_DWORD *)a8 + 6);
        *v36 = *v36
             + (float)((float)((float)((float)v40 + -0.5) * (float)(1 << (13 - *(_DWORD *)(a5 + 4 * v10)))) * 0.000061035);
        v36 = (float *)((char *)v36 + v34);
        if (!--v35)
        {
          a7 -= v9;
          goto LABEL_45;
        }
      }
      v44 = 0;
LABEL_37:
      v45 = 0;
      if (v42 >= v41)
        goto LABEL_38;
      goto LABEL_42;
    }
  }
  return result;
}

void amp2Log2(uint64_t a1, int a2, int a3, float32x4_t *a4, float32x4_t *a5, int a6)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t *v13;
  float32x4_t *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v20;
  __int128 *v21;
  float32x4_t *v22;
  float32x4_t *v23;
  float32x4_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float32x4_t v27;
  float v28;
  size_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  float32x4_t *v38;
  float32x4_t *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v45;
  __int128 *v46;
  float32x4_t *v47;
  float32x4_t *v48;
  float32x4_t v49;
  float64x2_t v50;
  float64x2_t v51;
  float32x4_t v52;
  float v53;
  size_t __len;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  float64x2_t v63;
  float64x2_t v64;
  float64x2_t __x;
  float64x2_t __xa;
  long double v67;
  float64x2_t v68;
  long double v69;
  float64x2_t v70;
  float64x2_t v71;
  float64x2_t v72;

  v6 = a2;
  if (a2 >= 1)
  {
    v7 = *(int *)(a1 + 8);
    if (a2 < a3)
    {
      v8 = 0;
      v9 = 4 * (~a2 + a3) + 4;
      if (a6 <= 1)
        v10 = 1;
      else
        v10 = a6;
      v58 = v10;
      v11 = a2;
      v12 = 4 * v7;
      v56 = a2 & 0xFFFFFFFC;
      v13 = a4;
      v14 = a5;
      v63 = (float64x2_t)vdupq_n_s64(0x3FF71547652B82FEuLL);
      __len = 4 * (~a2 + a3) + 4;
      v55 = *(_DWORD *)(a1 + 8);
      while (1)
      {
        if (v6 >= 4)
        {
          v16 = (uint64_t)a5 + v12 * v8;
          v17 = v16 - ((_QWORD)a4 + v12 * v8);
          v18 = v16 - (_QWORD)&eMeans;
          if (v17 >= 0x10 && v18 >= 0x10)
          {
            v20 = v56;
            v21 = &eMeans;
            v22 = v13;
            v23 = v14;
            do
            {
              v24 = *v22++;
              v71 = vcvt_hight_f64_f32(v24);
              __x = vcvtq_f64_f32(*(float32x2_t *)v24.f32);
              v67 = log(__x.f64[1]);
              v25.f64[0] = log(__x.f64[0]);
              v25.f64[1] = v67;
              v68 = v25;
              __x.f64[0] = log(v71.f64[1]);
              v26.f64[0] = log(v71.f64[0]);
              v26.f64[1] = __x.f64[0];
              v27 = (float32x4_t)*v21++;
              *v23++ = vsubq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(v68, v63)), vmulq_f64(v26, v63)), v27);
              v20 -= 4;
            }
            while (v20);
            LODWORD(v7) = v55;
            v15 = v56;
            v9 = __len;
            if (v56 == v11)
              goto LABEL_7;
          }
          else
          {
            v15 = 0;
          }
        }
        else
        {
          v15 = 0;
        }
        do
        {
          v28 = log(v13->f32[v15]) * 1.44269504;
          v14->f32[v15] = v28 - *((float *)&eMeans + v15);
          ++v15;
        }
        while (v11 != v15);
LABEL_7:
        v6 = a2;
        memset_pattern16(&a5->f32[a2 + (int)v7 * (int)v8++], &memset_pattern_4, v9);
        v14 = (float32x4_t *)((char *)v14 + v12);
        v13 = (float32x4_t *)((char *)v13 + v12);
        if (v8 == v58)
          return;
      }
    }
    v33 = 0;
    if (a6 <= 1)
      v34 = 1;
    else
      v34 = a6;
    v35 = a2;
    v36 = 4 * v7;
    v37 = a2 & 0xFFFFFFFC;
    v38 = a4;
    v39 = a5;
    v64 = (float64x2_t)vdupq_n_s64(0x3FF71547652B82FEuLL);
    v57 = v37;
    v59 = v34;
    while (1)
    {
      if (v6 >= 4)
      {
        v41 = (uint64_t)a5 + v36 * v33;
        v42 = v41 - ((_QWORD)a4 + v36 * v33);
        v43 = v41 - (_QWORD)&eMeans;
        if (v42 >= 0x10 && v43 >= 0x10)
        {
          v45 = v37;
          v46 = &eMeans;
          v47 = v38;
          v48 = v39;
          do
          {
            v49 = *v47++;
            v72 = vcvt_hight_f64_f32(v49);
            __xa = vcvtq_f64_f32(*(float32x2_t *)v49.f32);
            v69 = log(__xa.f64[1]);
            v50.f64[0] = log(__xa.f64[0]);
            v50.f64[1] = v69;
            v70 = v50;
            __xa.f64[0] = log(v72.f64[1]);
            v51.f64[0] = log(v72.f64[0]);
            v51.f64[1] = __xa.f64[0];
            v52 = (float32x4_t)*v46++;
            *v48++ = vsubq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(v70, v64)), vmulq_f64(v51, v64)), v52);
            v45 -= 4;
          }
          while (v45);
          v37 = v57;
          v34 = v59;
          v40 = v57;
          if (v57 == v35)
            goto LABEL_31;
        }
        else
        {
          v40 = 0;
        }
      }
      else
      {
        v40 = 0;
      }
      do
      {
        v53 = log(v38->f32[v40]) * 1.44269504;
        v39->f32[v40] = v53 - *((float *)&eMeans + v40);
        ++v40;
      }
      while (v35 != v40);
LABEL_31:
      ++v33;
      v39 = (float32x4_t *)((char *)v39 + v36);
      v38 = (float32x4_t *)((char *)v38 + v36);
      v6 = a2;
      if (v33 == v34)
        return;
    }
  }
  if (a2 < a3)
  {
    v29 = 4 * (~a2 + a3) + 4;
    if (a6 <= 1)
      v30 = 1;
    else
      v30 = a6;
    v31 = &a5->i8[4 * a2];
    v32 = 4 * *(int *)(a1 + 8);
    do
    {
      memset_pattern16(v31, &memset_pattern_4, v29);
      v31 += v32;
      --v30;
    }
    while (v30);
  }
}

void *silk_quant_LTP_gains(uint64_t a1, char *__dst, _BYTE *a3, unsigned int *a4, _DWORD *a5, _DWORD *a6, int *a7, __int16 a8, int a9)
{
  _DWORD *v9;
  unsigned int *v10;
  char *v12;
  int v13;
  int *v14;
  _DWORD *v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int *v19;
  _DWORD *v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  char v29;
  int v30;
  char v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  int *v38;
  _DWORD *v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  char v47;
  int v48;
  char v49;
  unsigned int v50;
  int v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  int v55;
  int v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  unsigned int v60;
  int v61;
  int v62;
  void *result;
  unsigned int v64;
  unsigned int v65;
  char v66;
  int v67;
  char v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  unsigned int v72;
  uint64_t v73;
  _WORD *v74;
  uint64_t v75;
  unsigned int v76;
  char v77;
  unsigned int v78;
  unsigned int v79;
  BOOL v80;
  int v81;
  signed int v82;
  unsigned int v83;
  _BYTE *v86;
  unsigned int *v87;
  int v88;
  int v89;
  int v91;
  uint64_t v92;
  _BYTE __src[4];

  v9 = a5;
  v10 = a4;
  v12 = __dst;
  v13 = a9;
  v92 = 0;
  v91 = 0;
  if (a9 < 1)
  {
    memcpy(__dst, __src, a9);
    *a3 = 1;
    memcpy(v12, __src, a9);
    v76 = *v10;
    *a3 = 2;
    result = memcpy(v12, __src, a9);
    v70 = v76;
    v56 = 0;
  }
  else
  {
    v14 = a7;
    v15 = a6;
    v16 = 0;
    v89 = 0;
    v17 = *a4;
    v18 = a9;
    v19 = a7;
    v20 = a6;
    do
    {
      v21 = 6229 - v17;
      if ((int)(6229 - v17) < 0)
      {
        v22 = 0;
      }
      else if (v21 <= 0xF7E)
      {
        v23 = 1 << (v21 >> 7);
        v24 = (v21 & 0x7F) + ((int)(-174 * (v21 & 0x7F) * (128 - (v21 & 0x7F))) >> 16);
        if (v21 <= 0x7FF)
          v25 = v24 << (v21 >> 7) >> 7;
        else
          v25 = v24 * (v23 >> 7);
        v22 = v25 + v23;
      }
      else
      {
        v22 = 0x7FFFFFFF;
      }
      silk_VQ_WMat_EC_c(&__src[v16], (unsigned int *)&v92 + 1, (int *)&v92, &v91, v20, v19, (uint64_t)&silk_LTP_gain_vq_0, (uint64_t)&silk_LTP_gain_vq_0_gain, (uint64_t)&silk_LTP_gain_BITS_Q5_0, a8, v22 - 51, 8);
      v26 = v92 + v89;
      v88 = v92 + v89;
      if ((int)v92 + v89 < 0)
        v26 = 0x7FFFFFFF;
      v89 = v26;
      v27 = v91 + 51;
      v28 = __clz(v91 + 51);
      v29 = 24 - v28;
      LOBYTE(v30) = v91 + 51;
      v31 = v28 - 24;
      if (v28 != 24)
      {
        v30 = (v27 << (v28 + 8)) | (v27 >> v29);
        if (v27 <= 0x7F)
          LOBYTE(v30) = v27 << v31;
      }
      v32 = 0;
      if ((int)(v17 - (v28 << 7) + (v30 & 0x7F) + ((179 * (v30 & 0x7F) * (128 - (v30 & 0x7Fu))) >> 16) + 3968) >= 896)
      {
        v33 = (v27 << (v28 + 8)) | (v27 >> v29);
        v34 = v27 << v31;
        if (v27 <= 0x7F)
          LOBYTE(v33) = v34;
        if (v28 != 24)
          LOBYTE(v27) = v33;
        v32 = v17 - (v28 << 7) + (v27 & 0x7F) + ((179 * (v27 & 0x7F) * (128 - (v27 & 0x7F))) >> 16) + 3072;
      }
      v20 += 25;
      v19 += 5;
      ++v16;
      v17 = v32;
    }
    while (a9 != v16);
    v83 = v32;
    v86 = a3;
    *a3 = 0;
    memcpy(v12, __src, a9);
    v35 = 0;
    v36 = 0;
    v87 = v10;
    v37 = *v10;
    v38 = v14;
    v39 = v15;
    do
    {
      v40 = 6229 - v37;
      if ((int)(6229 - v37) < 0)
      {
        v41 = 0;
      }
      else if (v40 <= 0xF7E)
      {
        v42 = 1 << (v40 >> 7);
        v43 = (v40 & 0x7F) + ((int)(-174 * (v40 & 0x7F) * (128 - (v40 & 0x7F))) >> 16);
        if (v40 <= 0x7FF)
          v44 = v43 << (v40 >> 7) >> 7;
        else
          v44 = v43 * (v42 >> 7);
        v41 = v44 + v42;
      }
      else
      {
        v41 = 0x7FFFFFFF;
      }
      silk_VQ_WMat_EC_c(&__src[v35], (unsigned int *)&v92 + 1, (int *)&v92, &v91, v39, v38, (uint64_t)&silk_LTP_gain_vq_1, (uint64_t)&silk_LTP_gain_vq_1_gain, (uint64_t)&silk_LTP_gain_BITS_Q5_1, a8, v41 - 51, 16);
      if ((int)v92 + v36 < 0)
        v36 = 0x7FFFFFFF;
      else
        v36 += v92;
      v45 = v91 + 51;
      v46 = __clz(v91 + 51);
      v47 = 24 - v46;
      LOBYTE(v48) = v91 + 51;
      v49 = v46 - 24;
      if (v46 != 24)
      {
        v48 = (v45 << (v46 + 8)) | (v45 >> v47);
        if (v45 <= 0x7F)
          LOBYTE(v48) = v45 << v49;
      }
      v50 = 0;
      if ((int)(v37 - (v46 << 7) + (v48 & 0x7F) + ((179 * (v48 & 0x7F) * (128 - (v48 & 0x7Fu))) >> 16) + 3968) >= 896)
      {
        v51 = (v45 << (v46 + 8)) | (v45 >> v47);
        v52 = v45 << v49;
        if (v45 <= 0x7F)
          LOBYTE(v51) = v52;
        if (v46 != 24)
          LOBYTE(v45) = v51;
        v50 = v37 - (v46 << 7) + (v45 & 0x7F) + ((179 * (v45 & 0x7F) * (128 - (v45 & 0x7F))) >> 16) + 3072;
      }
      v39 += 25;
      v38 += 5;
      ++v35;
      v37 = v50;
    }
    while (a9 != v35);
    v53 = v83;
    if (v36 <= v89)
    {
      *v86 = 1;
      memcpy(v12, __src, a9);
      v88 = v36;
      v53 = v50;
    }
    v54 = 0;
    v55 = 0;
    v56 = 0;
    v57 = *v87;
    do
    {
      v58 = 6229 - v57;
      if ((int)(6229 - v57) < 0)
      {
        v59 = 0;
      }
      else if (v58 <= 0xF7E)
      {
        v60 = 1 << (v58 >> 7);
        v61 = (v58 & 0x7F) + ((int)(-174 * (v58 & 0x7F) * (128 - (v58 & 0x7F))) >> 16);
        if (v58 <= 0x7FF)
          v62 = v61 << (v58 >> 7) >> 7;
        else
          v62 = v61 * (v60 >> 7);
        v59 = v62 + v60;
      }
      else
      {
        v59 = 0x7FFFFFFF;
      }
      result = silk_VQ_WMat_EC_c(&__src[v54], (unsigned int *)&v92 + 1, (int *)&v92, &v91, v15, v14, (uint64_t)&silk_LTP_gain_vq_2, (uint64_t)&silk_LTP_gain_vq_2_gain, (uint64_t)&silk_LTP_gain_BITS_Q5_2, a8, v59 - 51, 32);
      if (HIDWORD(v92) + v56 < 0)
        v56 = 0x7FFFFFFF;
      else
        v56 += HIDWORD(v92);
      if ((int)v92 + v55 < 0)
        v55 = 0x7FFFFFFF;
      else
        v55 += v92;
      v64 = v91 + 51;
      v65 = __clz(v91 + 51);
      v66 = 24 - v65;
      LOBYTE(v67) = v91 + 51;
      v68 = v65 - 24;
      if (v65 != 24)
      {
        v67 = (v64 << (v65 + 8)) | (v64 >> v66);
        if (v64 <= 0x7F)
          LOBYTE(v67) = v64 << v68;
      }
      v69 = 0;
      v70 = v53;
      if ((int)(v57 - (v65 << 7) + (v67 & 0x7F) + ((179 * (v67 & 0x7F) * (128 - (v67 & 0x7Fu))) >> 16) + 3968) >= 896)
      {
        v71 = (v64 << (v65 + 8)) | (v64 >> v66);
        v72 = v64 << v68;
        if (v64 <= 0x7F)
          LOBYTE(v71) = v72;
        if (v65 != 24)
          LOBYTE(v64) = v71;
        v69 = v57 - (v65 << 7) + (v64 & 0x7F) + ((179 * (v64 & 0x7F) * (128 - (v64 & 0x7F))) >> 16) + 3072;
      }
      v15 += 25;
      v14 += 5;
      ++v54;
      v57 = v69;
    }
    while (a9 != v54);
    if (v55 <= v88)
    {
      *v86 = 2;
      result = memcpy(v12, __src, a9);
      v70 = v69;
    }
    v73 = (uint64_t)*(&silk_LTP_vq_ptrs_Q7 + (char)*v86);
    v13 = a9;
    v74 = (_WORD *)(a1 + 4);
    do
    {
      *(v74 - 2) = *(char *)(v73 + 5 * *v12) << 7;
      *(v74 - 1) = *(char *)(5 * *v12 + v73 + 1) << 7;
      *v74 = *(char *)(5 * *v12 + v73 + 2) << 7;
      v74[1] = *(char *)(5 * *v12 + v73 + 3) << 7;
      v75 = *v12++;
      v74[2] = *(char *)(5 * v75 + v73 + 4) << 7;
      v74 += 5;
      --v18;
    }
    while (v18);
    v9 = a5;
    v10 = v87;
  }
  if (v13 == 2)
    v77 = 1;
  else
    v77 = 2;
  v78 = v56 >> v77;
  *v10 = v70;
  v79 = __clz(v56 >> v77);
  if (v79 != 24)
  {
    v80 = v78 > 0x7F;
    v81 = (v78 << (v79 + 8)) | (v78 >> (24 - v79));
    v78 <<= v79 - 24;
    if (v80)
      LOBYTE(v78) = v81;
  }
  v82 = ((179 * (v78 & 0x7F) * (128 - (v78 & 0x7F)) - (v79 << 23) + ((v78 & 0x7F) << 16) + 260046848) & 0xFFFF0000)
      - 125829120;
  *v9 = (v82 >> 16) - (v82 >> 14);
  return result;
}

uint64_t clt_compute_allocation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, uint64_t a8, int a9, _DWORD *a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, unsigned int a15, uint64_t a16, int a17, int a18, int a19)
{
  uint64_t v20;
  unsigned int v21;
  signed int v22;
  int v23;
  int v24;
  int v25;
  BOOL v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  char *v43;
  signed int v44;
  int *v45;
  uint64_t v46;
  int v47;
  unsigned int v48;
  uint64_t v49;
  unsigned int v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  int16x8_t v54;
  int32x4_t v55;
  int8x16_t v56;
  uint32x4_t v57;
  int8x16_t v58;
  int32x4_t v59;
  int32x4_t v60;
  int8x16_t v61;
  uint32x4_t v62;
  int8x16_t *v63;
  int32x4_t *v64;
  int32x4_t *v65;
  int16x8_t v66;
  int32x4_t v67;
  int32x4_t v68;
  unint64_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int16x8_t v72;
  uint32x4_t v73;
  uint32x4_t v74;
  char *v75;
  int v76;
  int v77;
  int *v78;
  unint64_t v79;
  __int16 *v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  uint64_t v88;
  __int16 v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  signed int v96;
  int v97;
  int v98;
  int v99;
  uint64_t v100;
  signed int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  uint64_t v108;
  _QWORD *v109;
  int v110;
  uint64_t v111;
  signed int v112;
  int v113;
  uint64_t v114;
  __int16 *v115;
  _WORD *v116;
  __int16 v117;
  __int16 v118;
  char *v119;
  uint64_t v120;
  char *v121;
  char *v122;
  char *v123;
  uint64_t v124;
  uint64_t v125;
  char *v126;
  uint64_t v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  signed int v138;
  char *v139;
  uint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  int v144;
  signed int v145;
  unsigned int v146;
  uint64_t v147;
  int v148;
  int v149;
  int v150;
  signed int v151;
  int v152;
  int v153;
  BOOL v154;
  unsigned int v155;
  uint64_t v156;
  int v157;
  int v158;
  int v159;
  signed int v160;
  uint64_t v161;
  int v162;
  int v163;
  int v164;
  signed int v165;
  uint64_t v166;
  int v167;
  int v168;
  int v169;
  signed int v170;
  BOOL v171;
  unsigned int v172;
  unsigned int v173;
  unsigned int v174;
  uint64_t v175;
  int v176;
  int v177;
  char v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  int v182;
  int v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  int v188;
  int v189;
  int v190;
  int v191;
  int v192;
  int v193;
  unsigned int v194;
  int v195;
  int v196;
  int v197;
  int v198;
  int v199;
  int v200;
  uint64_t v201;
  unsigned int v202;
  unsigned int v203;
  unsigned int v204;
  int v205;
  unsigned int v206;
  unint64_t v207;
  int v208;
  unint64_t v209;
  int v210;
  uint64_t v211;
  int v212;
  uint64_t v213;
  int *v214;
  int v215;
  signed int v216;
  uint64_t v217;
  int v218;
  unsigned int v219;
  int v220;
  signed int v221;
  uint64_t v222;
  int v223;
  int v224;
  uint64_t v225;
  signed int v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  unsigned int v231;
  unsigned int v232;
  unsigned int v233;
  int v234;
  unsigned int v235;
  unint64_t v236;
  int v237;
  unint64_t v238;
  int v239;
  uint64_t v240;
  int v241;
  unsigned int v242;
  uint64_t v243;
  int v244;
  uint64_t v245;
  uint64_t v246;
  int v247;
  unsigned int v248;
  unsigned int v249;
  int v250;
  unint64_t v251;
  __int16 v252;
  uint64_t v253;
  uint64_t v254;
  int8x16_t v255;
  int32x4_t v256;
  int8x16_t *v257;
  int32x4_t *v258;
  unint64_t v259;
  int8x16_t v260;
  int16x8_t v261;
  int8x16_t v262;
  int16x8_t v263;
  int32x4_t v264;
  int32x4_t v265;
  int32x4_t v266;
  _DWORD *v267;
  uint64_t v268;
  __int16 *v269;
  int v270;
  _DWORD *v271;
  __int16 *v272;
  __int16 v273;
  int v274;
  int v275;
  __int16 v276;
  unsigned int v277;
  char v278;
  uint64_t v279;
  unsigned int v280;
  int v281;
  int v282;
  int v283;
  int v284;
  int v285;
  _BOOL4 v286;
  int v287;
  int v288;
  unsigned int v289;
  unsigned int v290;
  int v291;
  int v292;
  int v293;
  int v294;
  int v295;
  int v296;
  int v297;
  int v298;
  unint64_t v299;
  unint64_t v300;
  uint64_t v301;
  uint64_t v302;
  unint64_t v303;
  unint64_t v304;
  unint64_t v305;
  unint64_t v306;
  unint64_t v307;
  BOOL v308;
  BOOL v309;
  BOOL v310;
  BOOL v311;
  int32x4_t *v313;
  int32x4_t *v314;
  int8x16_t *v315;
  int32x4_t v316;
  int32x4_t v317;
  int8x16_t v318;
  unint64_t v319;
  int32x4_t v320;
  uint64_t v321;
  uint64_t v322;
  _DWORD *v323;
  int *v324;
  int *v325;
  int v326;
  uint64_t v328;
  uint64_t v329;
  int v330;
  _BOOL4 v331;
  int v332;
  _DWORD *v333;
  uint64_t v334;
  uint64_t v335;
  char *v336;
  uint64_t v337;
  int *v338;
  uint64_t v339;
  _QWORD *v340;
  uint64_t v341;
  uint64_t v342;
  int *v343;
  char *v344;
  int v345;
  uint64_t v346;
  uint64_t v347;
  signed int v348;
  uint64_t v349;

  v338 = a7;
  v346 = a5;
  v20 = a3;
  v349 = *MEMORY[0x24BDAC8D0];
  v21 = a9 & ~(a9 >> 31);
  v330 = 8 * (v21 > 7);
  v22 = v21 - v330;
  if (a14 == 2)
  {
    v23 = LOG2_FRAC_TABLE[(int)a3 - (int)a2];
    v24 = 8 * (v22 - v23 > 7);
    v25 = v22 - v23 - v24;
    v26 = v22 < v23;
    if (v22 < v23)
      v23 = 0;
    v345 = v23;
    if (v26)
      v27 = 0;
    else
      v27 = v24;
    v332 = v27;
    if (!v26)
      v22 = v25;
    v348 = v22;
  }
  else
  {
    v348 = v21 - v330;
    v345 = 0;
    v332 = 0;
  }
  v342 = a11;
  v28 = MEMORY[0x24BDAC7A8](a1, a2);
  v30 = MEMORY[0x24BDAC7A8](v28, v29);
  v344 = (char *)&v328 - v31;
  v33 = MEMORY[0x24BDAC7A8](v30, v32);
  v35 = MEMORY[0x24BDAC7A8](v33, v34);
  v43 = (char *)&v328 - v42;
  v44 = 8 * a14;
  v334 = v20;
  v329 = v35;
  v341 = v39;
  v339 = v37;
  v343 = v45;
  if ((int)v20 <= (int)v39)
  {
    v107 = 0;
    v108 = (int)v20;
    v49 = (int)v39;
    v109 = (_QWORD *)(v35 + 32);
    v110 = v39;
    v111 = v342;
    v112 = v348;
    v113 = v345;
    goto LABEL_153;
  }
  v337 = v40;
  v46 = *(_QWORD *)(v35 + 32);
  v340 = (_QWORD *)(v35 + 32);
  v335 = v41;
  v47 = v38 - a15 - 5;
  v48 = a15 + 3;
  v49 = (int)v39;
  v50 = *(unsigned __int16 *)(v46 + 2 * (int)v39);
  v51 = (int)v20 - (uint64_t)(int)v39;
  v52 = 4 * (int)v39;
  v53 = (int)v39;
  if (v51 >= 8)
  {
    v53 = (v51 & 0xFFFFFFFFFFFFFFF8) + (int)v39;
    v54 = vdupq_n_s16(v50);
    v55 = vdupq_n_s32(v39);
    v56 = (int8x16_t)vaddq_s32(v55, (int32x4_t)xmmword_208F08E20);
    v57 = (uint32x4_t)vdupq_n_s32(a15);
    v58 = (int8x16_t)vdupq_n_s32(v44);
    v59 = vdupq_n_s32(v20);
    v60 = vdupq_n_s32(v47 * a14);
    v61 = (int8x16_t)vaddq_s32(v55, (int32x4_t)xmmword_208F071C0);
    v62 = (uint32x4_t)vdupq_n_s32(v48);
    v63 = (int8x16_t *)(v46 + 2 * (int)v39 + 2);
    v64 = (int32x4_t *)(v37 + v52);
    v65 = (int32x4_t *)&v43[v52];
    v66.i64[0] = 0x3000300030003;
    v66.i64[1] = 0x3000300030003;
    v67.i64[0] = 0x100000001;
    v67.i64[1] = 0x100000001;
    v68.i64[0] = 0x800000008;
    v68.i64[1] = 0x800000008;
    v69 = v51 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      v70 = (int8x16_t)v54;
      v71 = *v63++;
      v54 = (int16x8_t)v71;
      v72 = (int16x8_t)vextq_s8(v70, v71, 0xEuLL);
      v73 = (uint32x4_t)vsubl_s16(*(int16x4_t *)v71.i8, *(int16x4_t *)v72.i8);
      v74 = (uint32x4_t)vsubl_high_s16((int16x8_t)v71, v72);
      *v64 = vmaxq_s32((int32x4_t)v58, vshrq_n_s32(vshlq_n_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlsl_s16(vmull_s16(*(int16x4_t *)v71.i8, (int16x4_t)0x3000300030003), *(int16x4_t *)v72.i8, (int16x4_t)0x3000300030003), v57), 3uLL), 4uLL));
      v64[1] = vmaxq_s32((int32x4_t)v58, vshrq_n_s32(vshlq_n_s32((int32x4_t)vshlq_u32((uint32x4_t)vmlsl_high_s16(vmull_high_s16((int16x8_t)v71, v66), v72, v66), v57), 3uLL), 4uLL));
      v64 += 2;
      *v65 = vsubq_s32(vshrq_n_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(vmulq_s32(v60, vaddq_s32(v59, (int32x4_t)vmvnq_s8(v61))), (int32x4_t)v73), v62), 6uLL), (int32x4_t)vandq_s8(v58, (int8x16_t)vceqq_s32((int32x4_t)vshlq_u32(v73, v57), v67)));
      v65[1] = vsubq_s32(vshrq_n_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(vmulq_s32(v60, vaddq_s32(v59, (int32x4_t)vmvnq_s8(v56))), (int32x4_t)v74), v62), 6uLL), (int32x4_t)vandq_s8(v58, (int8x16_t)vceqq_s32((int32x4_t)vshlq_u32(v74, v57), v67)));
      v65 += 2;
      v61 = (int8x16_t)vaddq_s32((int32x4_t)v61, v68);
      v56 = (int8x16_t)vaddq_s32((int32x4_t)v56, v68);
      v69 -= 8;
    }
    while (v69);
    if (v51 == (v51 & 0xFFFFFFFFFFFFFFF8))
      goto LABEL_24;
    LOWORD(v50) = v54.i16[7];
    v37 = v339;
  }
  v75 = &v43[4 * v53];
  v76 = a14 * v47;
  v77 = v76 * (~(_DWORD)v53 + v20);
  v78 = (int *)(v37 + 4 * v53);
  v79 = (int)v20 - v53;
  v80 = (__int16 *)(v46 + 2 * v53 + 2);
  do
  {
    v81 = *v80++;
    v82 = v81 - (__int16)v50;
    LOWORD(v50) = v81;
    v83 = (8 * ((3 * v82) << a15)) >> 4;
    if (v44 > v83)
      v83 = 8 * a14;
    *v78++ = v83;
    v84 = (v77 * v82) << v48 >> 6;
    if (v82 << a15 == 1)
      v85 = 8 * a14;
    else
      v85 = 0;
    *(_DWORD *)v75 = v84 - v85;
    v75 += 4;
    v77 -= v76;
    --v79;
  }
  while (v79);
LABEL_24:
  v333 = (_DWORD *)v52;
  v86 = *(_DWORD *)(v35 + 52);
  v87 = v86 - 1;
  v88 = *(_QWORD *)(v35 + 32);
  v347 = (int)v20;
  v89 = *(_WORD *)(v88 + 2 * (int)v20);
  v90 = v346 - 4;
  v91 = v339 - 4;
  v92 = a4;
  v93 = a4 - 4;
  v94 = *(_QWORD *)(v35 + 56);
  v336 = v43;
  v95 = 1;
  do
  {
    v96 = 0;
    v97 = 0;
    v98 = (v95 + v87) >> 1;
    LOWORD(v99) = v89;
    v100 = v347;
    do
    {
      while (1)
      {
        v102 = (__int16)v99;
        v99 = *(__int16 *)(v88 - 2 + 2 * v100);
        v103 = ((v102 - v99) * a14 * *(unsigned __int8 *)(v94 - 1 + v98 * v41 + v100)) << a15;
        v104 = v103 >> 2;
        if (v103 >= 4)
        {
          v105 = *(_DWORD *)&v43[4 * v100 - 4] + v104;
          v104 = v105 & ~(v105 >> 31);
        }
        v101 = *(_DWORD *)(v93 + 4 * v100) + v104;
        if (v97 || v101 >= *(_DWORD *)(v91 + 4 * v100))
          break;
        v97 = 0;
        if (v101 >= v44)
          v106 = 8 * a14;
        else
          v106 = 0;
        --v100;
        v96 += v106;
        if (v100 <= v49)
          goto LABEL_25;
      }
      if (v101 >= *(_DWORD *)(v90 + 4 * v100))
        v101 = *(_DWORD *)(v90 + 4 * v100);
      v97 = 1;
      --v100;
      v96 += v101;
    }
    while (v100 > v49);
LABEL_25:
    if (v96 <= v348)
      v95 = v98 + 1;
    else
      v87 = v98 - 1;
  }
  while (v95 <= v87);
  v114 = 0;
  v115 = (__int16 *)(v88 + 2 * v49);
  v118 = *v115;
  v116 = v115 + 1;
  v117 = v118;
  v119 = (char *)v333 + (_QWORD)v344;
  v120 = v337;
  v121 = (char *)v333 + v337;
  v122 = (char *)v333 + v92;
  v123 = (char *)v333 + (_QWORD)v336;
  v124 = v94 + v49;
  v125 = v94 + v49 + (int)v335 * (uint64_t)v95;
  v126 = (char *)v333 + v346;
  v127 = v124 + (v95 - 1) * v335;
  v111 = v342;
  v110 = v341;
  v128 = v341;
  do
  {
    v132 = ((__int16)v116[v114] - v117) * a14;
    if (v95 >= v86)
    {
      v133 = *(_DWORD *)&v126[4 * v114];
      v136 = (v132 * *(unsigned __int8 *)(v127 + v114)) << a15;
      v135 = v136 >> 2;
      if (v136 < 4)
        goto LABEL_55;
LABEL_54:
      v135 = (*(_DWORD *)&v123[4 * v114] + v135) & ~((*(_DWORD *)&v123[4 * v114] + v135) >> 31);
      goto LABEL_55;
    }
    v133 = (v132 * *(unsigned __int8 *)(v125 + v114)) << a15 >> 2;
    v134 = (v132 * *(unsigned __int8 *)(v127 + v114)) << a15;
    v135 = v134 >> 2;
    if (v134 >= 4)
      goto LABEL_54;
LABEL_55:
    if (v133 >= 1)
      v133 = (*(_DWORD *)&v123[4 * v114] + v133) & ~((*(_DWORD *)&v123[4 * v114] + v133) >> 31);
    v117 = v116[v114];
    v129 = *(_DWORD *)&v122[4 * v114];
    if (v95 <= 1)
      v130 = 0;
    else
      v130 = *(_DWORD *)&v122[4 * v114];
    v131 = v130 + v135;
    if (v129 > 0)
      v110 = v128 + v114;
    *(_DWORD *)&v121[4 * v114] = v131;
    *(_DWORD *)&v119[4 * v114++] = (v129 + v133 - v131) & ~((v129 + v133 - v131) >> 31);
  }
  while (v51 != v114);
  v137 = 0;
  v138 = 0;
  v139 = v344 - 4;
  v140 = v120 - 4;
  v108 = v347;
  v141 = v347;
  v20 = v334;
  LODWORD(v39) = v341;
  v112 = v348;
  do
  {
    while (1)
    {
      v142 = *(_DWORD *)(v140 + 4 * v141) + (*(int *)&v139[4 * v141] >> 1);
      if (v137 || v142 >= *(_DWORD *)(v91 + 4 * v141))
        break;
      v137 = 0;
      if (v142 >= v44)
        v143 = 8 * a14;
      else
        v143 = 0;
      --v141;
      v138 += v143;
      if (v141 <= v49)
        goto LABEL_67;
    }
    if (v142 >= *(_DWORD *)(v90 + 4 * v141))
      v142 = *(_DWORD *)(v90 + 4 * v141);
    v137 = 1;
    --v141;
    v138 += v142;
  }
  while (v141 > v49);
LABEL_67:
  v144 = 0;
  v145 = 0;
  if (v138 <= v348)
    v146 = 48;
  else
    v146 = 16;
  v147 = v347;
  do
  {
    while (1)
    {
      v148 = *(_DWORD *)(v140 + 4 * v147) + ((int)(*(_DWORD *)&v139[4 * v147] * v146) >> 6);
      if (v144 || v148 >= *(_DWORD *)(v91 + 4 * v147))
        break;
      v144 = 0;
      if (v148 >= v44)
        v149 = 8 * a14;
      else
        v149 = 0;
      --v147;
      v145 += v149;
      if (v147 <= v49)
        goto LABEL_80;
    }
    if (v148 >= *(_DWORD *)(v90 + 4 * v147))
      v148 = *(_DWORD *)(v90 + 4 * v147);
    v144 = 1;
    --v147;
    v145 += v148;
  }
  while (v147 > v49);
LABEL_80:
  v150 = 0;
  v151 = 0;
  v26 = v138 <= v348;
  v152 = 32 * (v138 <= v348);
  if (v26)
    v153 = 64;
  else
    v153 = 32;
  v154 = v145 <= v348;
  if (v145 <= v348)
    v155 = v146;
  else
    v155 = v152;
  if (v154)
    v146 = v153;
  v156 = v347;
  do
  {
    while (1)
    {
      v157 = *(_DWORD *)(v140 + 4 * v156) + ((int)(*(_DWORD *)&v139[4 * v156] * ((v146 + v155) >> 1)) >> 6);
      if (v150 || v157 >= *(_DWORD *)(v91 + 4 * v156))
        break;
      v150 = 0;
      if (v157 >= v44)
        v158 = 8 * a14;
      else
        v158 = 0;
      --v156;
      v151 += v158;
      if (v156 <= v49)
        goto LABEL_99;
    }
    if (v157 >= *(_DWORD *)(v90 + 4 * v156))
      v157 = *(_DWORD *)(v90 + 4 * v156);
    v150 = 1;
    --v156;
    v151 += v157;
  }
  while (v156 > v49);
LABEL_99:
  v159 = 0;
  v160 = 0;
  if (v151 > v348)
    v146 = (v146 + v155) >> 1;
  else
    v155 = (v146 + v155) >> 1;
  v161 = v347;
  do
  {
    while (1)
    {
      v162 = *(_DWORD *)(v140 + 4 * v161) + ((int)(*(_DWORD *)&v139[4 * v161] * ((v146 + v155) >> 1)) >> 6);
      if (v159 || v162 >= *(_DWORD *)(v91 + 4 * v161))
        break;
      v159 = 0;
      if (v162 >= v44)
        v163 = 8 * a14;
      else
        v163 = 0;
      --v161;
      v160 += v163;
      if (v161 <= v49)
        goto LABEL_112;
    }
    if (v162 >= *(_DWORD *)(v90 + 4 * v161))
      v162 = *(_DWORD *)(v90 + 4 * v161);
    v159 = 1;
    --v161;
    v160 += v162;
  }
  while (v161 > v49);
LABEL_112:
  v164 = 0;
  v165 = 0;
  if (v160 > v348)
    v146 = (v146 + v155) >> 1;
  else
    v155 = (v146 + v155) >> 1;
  v166 = v347;
  do
  {
    while (1)
    {
      v167 = *(_DWORD *)(v140 + 4 * v166) + ((int)(*(_DWORD *)&v139[4 * v166] * ((v146 + v155) >> 1)) >> 6);
      if (v164 || v167 >= *(_DWORD *)(v91 + 4 * v166))
        break;
      v164 = 0;
      if (v167 >= v44)
        v168 = 8 * a14;
      else
        v168 = 0;
      --v166;
      v165 += v168;
      if (v166 <= v49)
        goto LABEL_125;
    }
    if (v167 >= *(_DWORD *)(v90 + 4 * v166))
      v167 = *(_DWORD *)(v90 + 4 * v166);
    v164 = 1;
    --v166;
    v165 += v167;
  }
  while (v166 > v49);
LABEL_125:
  v169 = 0;
  v170 = 0;
  v171 = v165 <= v348;
  if (v165 <= v348)
    v172 = (v146 + v155) >> 1;
  else
    v172 = v155;
  if (v171)
    v173 = v146;
  else
    v173 = (v146 + v155) >> 1;
  v174 = (v173 + v172) >> 1;
  v175 = v347;
  v113 = v345;
  do
  {
    while (1)
    {
      v176 = *(_DWORD *)(v140 + 4 * v175) + ((int)(*(_DWORD *)&v139[4 * v175] * v174) >> 6);
      if (v169 || v176 >= *(_DWORD *)(v91 + 4 * v175))
        break;
      v169 = 0;
      if (v176 >= v44)
        v177 = 8 * a14;
      else
        v177 = 0;
      --v175;
      v170 += v177;
      if (v175 <= v49)
        goto LABEL_141;
    }
    if (v176 >= *(_DWORD *)(v90 + 4 * v175))
      v176 = *(_DWORD *)(v90 + 4 * v175);
    v169 = 1;
    --v175;
    v170 += v176;
  }
  while (v175 > v49);
LABEL_141:
  v178 = 0;
  v107 = 0;
  if (v170 <= v348)
    v172 = v174;
  v179 = v347;
  do
  {
    v180 = 4 * v179;
    v181 = v179 - 1;
    v182 = *(_DWORD *)(v140 + 4 * v179) + ((int)(*(_DWORD *)&v139[4 * v179] * v172) >> 6);
    v178 |= v182 >= *(_DWORD *)(v91 + v180);
    if (v182 >= v44)
      v183 = 8 * a14;
    else
      v183 = 0;
    if ((v178 & 1) == 0)
      v182 = v183;
    if (v182 >= *(_DWORD *)(v90 + v180))
      v182 = *(_DWORD *)(v90 + v180);
    *(_DWORD *)(v111 - 4 + v180) = v182;
    v107 += v182;
    v179 = v181;
  }
  while (v181 > v49);
  v109 = v340;
  v36 = LOG2_FRAC_TABLE;
LABEL_153:
  v347 = v108;
  v333 = a10;
  LODWORD(v344) = a17;
  v331 = a14 > 1;
  v340 = v109;
  if ((int)v20 - 1 <= v110)
  {
    v190 = v113;
    v185 = v20;
LABEL_191:
    v112 += v330;
    if (v190 <= 0)
      goto LABEL_207;
    goto LABEL_192;
  }
  LODWORD(v337) = v39 + 2;
  v184 = (int)v20 - 1;
  LODWORD(v336) = a18;
  v335 = a19;
  v185 = v20;
  v186 = v110;
  v187 = v339;
  while (2)
  {
    v192 = *(__int16 *)(*v109 + 2 * (int)v185);
    v193 = *(__int16 *)(*v109 + 2 * v49);
    v194 = (v112 - v107) / (v192 - v193);
    v195 = *(__int16 *)(*v109 + 2 * v184);
    v196 = v112 - v107 + v193 - v195 + (v193 - v192) * v194;
    v197 = v196 & ~(v196 >> 31);
    v198 = v192 - v195;
    v189 = *(_DWORD *)(v111 + 4 * v184);
    v188 = v189 + v198 * v194 + v197;
    v199 = *(_DWORD *)(v187 + 4 * v184);
    if (v199 <= v44 + 8)
      v199 = v44 + 8;
    if (v188 < v199)
      goto LABEL_157;
    if ((_DWORD)v344)
    {
      v345 = v113;
      if ((int)v185 <= (int)v337)
        goto LABEL_206;
      if ((int)v185 <= (int)v336)
        v200 = 7;
      else
        v200 = 9;
      if ((int)v185 <= 17)
        v200 = 0;
      if (v184 <= v335 && v188 > (8 * ((v198 * v200) << a15)) >> 4)
      {
LABEL_206:
        v225 = v185;
        ec_enc_bit_logp((uint64_t *)a16, 1, 1);
        v185 = v225;
        LODWORD(v39) = v341;
        v111 = v342;
        v112 = v348;
        v109 = v340;
        if (v345 <= 0)
        {
LABEL_207:
          v213 = v347;
          goto LABEL_208;
        }
LABEL_192:
        if (!(_DWORD)v344)
          goto LABEL_200;
        v214 = v338;
        v215 = *v338;
        if (*v338 >= (int)v185)
          v215 = v185;
        *v338 = v215;
        v216 = v112;
        v217 = v185;
        ec_enc_uint(a16, v215 - v39, v185 - v39 + 1);
        v185 = v217;
        v109 = v340;
        LODWORD(v39) = v341;
        v112 = v216;
        v111 = v342;
        v218 = *v214;
        v213 = v347;
        v219 = v331;
        if (*v214 <= (int)v341)
          v220 = v332;
        else
          v220 = 0;
        if (!v332)
          goto LABEL_230;
LABEL_212:
        if (v218 <= (int)v39)
          goto LABEL_230;
        if (!(_DWORD)v344)
          goto LABEL_216;
        v226 = v112;
        v227 = v185;
        ec_enc_bit_logp((uint64_t *)a16, *v343, 1);
        v185 = v227;
        v109 = v340;
        LODWORD(v39) = v341;
        v112 = v226;
        v111 = v342;
        v228 = a12;
        v229 = a13;
        if ((int)v227 <= (int)v341)
          goto LABEL_227;
        goto LABEL_231;
      }
      ec_enc_bit_logp((uint64_t *)a16, 0, 1);
      v187 = v339;
      v109 = v340;
      v36 = LOG2_FRAC_TABLE;
      LODWORD(v39) = v341;
      v111 = v342;
      v112 = v348;
      v113 = v345;
LABEL_156:
      v107 += 8;
      v188 -= 8;
      v189 = *(_DWORD *)(v111 + 4 * v184);
LABEL_157:
      if (v113)
        v190 = v36[v184 - v49];
      else
        v190 = 0;
      if (v188 >= v44)
        v191 = 8 * a14;
      else
        v191 = 0;
      *(_DWORD *)(v111 + 4 * v184) = v191;
      v107 = v107 - v189 - v113 + v190 + v191;
      v185 = v184--;
      v113 = v190;
      if (v184 <= v186)
        goto LABEL_191;
      continue;
    }
    break;
  }
  v201 = v185;
  v203 = *(_DWORD *)(a16 + 32);
  v202 = *(_DWORD *)(a16 + 36);
  v204 = v203 >> 1;
  v205 = v202;
  if (v202 >= v203 >> 1)
  {
    *(_DWORD *)(a16 + 36) = v202 - (v203 >> 1);
    v205 = v202 - v204;
  }
  v206 = v203 - v204;
  if (v202 < v204)
    v206 = v204;
  *(_DWORD *)(a16 + 32) = v206;
  if (v206 < 0x800001)
  {
    v207 = *(unsigned int *)(a16 + 8);
    v208 = *(_DWORD *)(a16 + 44);
    v209 = *(unsigned int *)(a16 + 28);
    v210 = *(_DWORD *)(a16 + 24) + 8;
    do
    {
      *(_DWORD *)(a16 + 24) = v210;
      *(_DWORD *)(a16 + 32) = v206 << 8;
      if (v209 < v207)
      {
        v211 = *(_QWORD *)a16;
        *(_DWORD *)(a16 + 28) = v209 + 1;
        v212 = *(unsigned __int8 *)(v211 + v209++);
      }
      else
      {
        v212 = 0;
      }
      v205 = (((v205 & 0x7FFFFF) << 8) | ((v212 | (v208 << 8)) >> 1)) ^ 0xFF;
      *(_DWORD *)(a16 + 44) = v212;
      *(_DWORD *)(a16 + 36) = v205;
      v210 += 8;
      v208 = v212;
      v26 = v206 > 0x8000;
      v206 <<= 8;
    }
    while (!v26);
  }
  if (v202 >= v204)
    goto LABEL_156;
  v213 = v347;
  v185 = v201;
  if (v113 <= 0)
  {
LABEL_208:
    v218 = 0;
    *v338 = 0;
    v219 = v331;
    if ((int)v39 >= 0)
      v220 = v332;
    else
      v220 = 0;
    if (v332)
      goto LABEL_212;
    goto LABEL_230;
  }
LABEL_200:
  v221 = v112;
  v222 = v185;
  v223 = ec_dec_uint((uint64_t *)a16, (int)v185 - (int)v39 + 1);
  LODWORD(v39) = v341;
  v224 = v223 + v341;
  *v338 = v223 + v341;
  if (v224 <= (int)v39)
    v220 = v332;
  else
    v220 = 0;
  if (!v332)
  {
    v111 = v342;
    v112 = v221;
    v109 = v340;
    v219 = v331;
    v185 = v222;
    v213 = v347;
    goto LABEL_230;
  }
  v111 = v342;
  v112 = v221;
  v109 = v340;
  v219 = v331;
  v185 = v222;
  v213 = v347;
  if (v224 <= (int)v39)
  {
LABEL_230:
    *v343 = 0;
    v228 = a12;
    v229 = a13;
    if ((int)v185 > (int)v39)
      goto LABEL_231;
LABEL_227:
    *v333 = 0;
    if ((int)v39 < (int)v334)
      goto LABEL_275;
    return v185;
  }
LABEL_216:
  v230 = v185;
  v232 = *(_DWORD *)(a16 + 32);
  v231 = *(_DWORD *)(a16 + 36);
  v233 = v232 >> 1;
  v234 = v231;
  if (v231 >= v232 >> 1)
  {
    *(_DWORD *)(a16 + 36) = v231 - (v232 >> 1);
    v234 = v231 - v233;
  }
  v235 = v232 - v233;
  if (v231 < v233)
    v235 = v233;
  *(_DWORD *)(a16 + 32) = v235;
  if (v235 <= 0x800000)
  {
    v236 = *(unsigned int *)(a16 + 8);
    v237 = *(_DWORD *)(a16 + 44);
    v238 = *(unsigned int *)(a16 + 28);
    v239 = *(_DWORD *)(a16 + 24) + 8;
    do
    {
      *(_DWORD *)(a16 + 24) = v239;
      *(_DWORD *)(a16 + 32) = v235 << 8;
      if (v238 < v236)
      {
        v240 = *(_QWORD *)a16;
        *(_DWORD *)(a16 + 28) = v238 + 1;
        v241 = *(unsigned __int8 *)(v240 + v238++);
      }
      else
      {
        v241 = 0;
      }
      v234 = (((v234 & 0x7FFFFF) << 8) | ((v241 | (v237 << 8)) >> 1)) ^ 0xFF;
      *(_DWORD *)(a16 + 44) = v241;
      *(_DWORD *)(a16 + 36) = v234;
      v239 += 8;
      v237 = v241;
      v26 = v235 > 0x8000;
      v235 <<= 8;
    }
    while (!v26);
  }
  *v343 = v231 < v233;
  v185 = v230;
  v228 = a12;
  v229 = a13;
  if ((int)v230 <= (int)v39)
    goto LABEL_227;
LABEL_231:
  v242 = v112 - v107 + v220;
  v243 = *v109;
  v244 = *(__int16 *)(*v109 + 2 * (int)v185);
  v245 = v185;
  v246 = (int)v185;
  v247 = *(__int16 *)(*v109 + 2 * v49);
  v248 = *(unsigned __int16 *)(*v109 + 2 * v49);
  v249 = v242 / (v244 - v247);
  v250 = v242 + (v247 - v244) * v249;
  v251 = (int)v185 - v49;
  v252 = *(_WORD *)(*v109 + 2 * v49);
  v253 = v49;
  v254 = v329;
  if (v251 < 0x10)
  {
LABEL_236:
    v267 = (_DWORD *)(v111 + 4 * v253);
    v268 = v246 - v253;
    v269 = (__int16 *)(v243 + 2 * v253 + 2);
    do
    {
      v270 = *v269++;
      *v267++ += (v270 - v252) * v249;
      v252 = v270;
      --v268;
    }
    while (v268);
  }
  else
  {
    v255 = (int8x16_t)vdupq_n_s16(v248);
    v256 = vdupq_n_s32(v249);
    v253 = v49 + (v251 & 0xFFFFFFFFFFFFFFF0);
    v257 = (int8x16_t *)(v243 + 2 * v49 + 18);
    v258 = (int32x4_t *)(v111 + 4 * v49 + 32);
    v259 = v251 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      v260 = v257[-1];
      v261 = (int16x8_t)vextq_s8(v255, v260, 0xEuLL);
      v262 = *v257;
      v257 += 2;
      v255 = v262;
      v263 = (int16x8_t)vextq_s8(v260, v262, 0xEuLL);
      v264 = vmlaq_s32(v258[-1], vsubl_high_s16((int16x8_t)v260, v261), v256);
      v265 = vmlaq_s32(*v258, vsubl_s16(*(int16x4_t *)v262.i8, *(int16x4_t *)v263.i8), v256);
      v266 = vmlaq_s32(v258[1], vsubl_high_s16((int16x8_t)v262, v263), v256);
      v258[-2] = vmlaq_s32(v258[-2], vsubl_s16(*(int16x4_t *)v260.i8, *(int16x4_t *)v261.i8), v256);
      v258[-1] = v264;
      *v258 = v265;
      v258[1] = v266;
      v258 += 4;
      v259 -= 16;
    }
    while (v259);
    if (v251 != (v251 & 0xFFFFFFFFFFFFFFF0))
    {
      v252 = v255.i16[7];
      goto LABEL_236;
    }
  }
  v271 = (_DWORD *)(v111 + 4 * v49);
  v272 = (__int16 *)(v243 + 2 * v49 + 2);
  v273 = v248;
  do
  {
    v274 = *v272++;
    v275 = v274 - v273;
    v276 = v274;
    if (v250 < v275)
      v275 = v250;
    *v271++ += v275;
    v250 -= v275;
    v273 = v276;
    --v251;
  }
  while (v251);
  v277 = 0;
  if (a14 <= 1)
    v278 = 3;
  else
    v278 = 4;
  v279 = v243 + 2;
  while (2)
  {
    while (2)
    {
      v283 = *(__int16 *)(v279 + 2 * v49);
      v284 = (v283 - (__int16)v248) << a15;
      v285 = *(_DWORD *)(v111 + 4 * v49) + v277;
      if (v284 >= 2)
      {
        v286 = 0;
        v287 = *(_DWORD *)(v346 + 4 * v49);
        v288 = v285 - v287;
        if (v285 >= v287)
          v285 = *(_DWORD *)(v346 + 4 * v49);
        *(_DWORD *)(v111 + 4 * v49) = v285;
        if (a14 == 2 && v284 != 2)
        {
          if (*v343)
            v286 = 0;
          else
            v286 = v49 < *v338;
        }
        v290 = v284 * a14 + v286;
        v291 = (8 * a15 + *(__int16 *)(*(_QWORD *)(v254 + 64) + 2 * v49)) * v290;
        if (v284 == 2)
          v292 = (int)(8 * v290) >> 2;
        else
          v292 = 0;
        v293 = v292 - 21 * v290 + (v291 >> 1);
        v294 = v293 + v285;
        v295 = v293 + (v291 >> 3);
        if (v293 + v285 >= (int)(24 * v290))
          v295 = v293;
        v296 = v293 + (v291 >> 2);
        if (v294 >= (int)(16 * v290))
          v296 = v295;
        v297 = (((v285 + 4 * v290 + v296) & ~((int)(v285 + 4 * v290 + v296) >> 31)) / v290) >> 3;
        *(_DWORD *)(v228 + 4 * v49) = v297;
        v298 = *(_DWORD *)(v111 + 4 * v49);
        if (v297 * a14 > v298 >> 3)
          v297 = v298 >> v219 >> 3;
        if (v297 >= 8)
          v297 = 8;
        *(_DWORD *)(v228 + 4 * v49) = v297;
        *(_DWORD *)(v229 + 4 * v49) = (int)(v297 * 8 * v290) >= *(_DWORD *)(v111 + 4 * v49) + v296;
        v289 = v288 & ~(v288 >> 31);
        *(_DWORD *)(v111 + 4 * v49) -= *(_DWORD *)(v228 + 4 * v49) * v44;
        if (v289)
          break;
        goto LABEL_273;
      }
      v289 = (v285 - v44) & ~((v285 - v44) >> 31);
      if (v285 >= v44)
        v285 = 8 * a14;
      *(_DWORD *)(v111 + 4 * v49) = v285;
      *(_DWORD *)(v228 + 4 * v49) = 0;
      *(_DWORD *)(v229 + 4 * v49) = 1;
      if (!v289)
      {
LABEL_273:
        v277 = 0;
        ++v49;
        LOWORD(v248) = v283;
        if (v246 == v49)
          goto LABEL_274;
        continue;
      }
      break;
    }
    v280 = v289 >> v278;
    v281 = *(_DWORD *)(v228 + 4 * v49);
    if ((int)(v289 >> v278) >= 8 - v281)
      v280 = 8 - v281;
    *(_DWORD *)(v228 + 4 * v49) = v280 + v281;
    v282 = v280 * v44;
    *(_DWORD *)(v229 + 4 * v49) = v282 >= (int)(v289 - v277);
    v277 = v289 - v282;
    ++v49;
    LOWORD(v248) = v283;
    if (v246 != v49)
      continue;
    break;
  }
LABEL_274:
  v185 = v245;
  LODWORD(v39) = v245;
  v213 = v347;
  *v333 = v277;
  if ((int)v39 < (int)v334)
  {
LABEL_275:
    v299 = (int)v39;
    v300 = v213 - (int)v39;
    if (v300 < 0xC)
      goto LABEL_298;
    v301 = v185;
    v302 = 4 * (int)v39;
    v303 = v228 + 4 * v213;
    v304 = v111 + v302;
    v305 = v111 + 4 * v213;
    v306 = v229 + v302;
    v307 = v229 + 4 * v213;
    v308 = v228 + v302 >= v307 || v306 >= v303;
    v309 = !v308;
    v310 = v304 >= v307 || v306 >= v305;
    v311 = !v310;
    v308 = v304 >= v303;
    v185 = v301;
    if (!v308 && v228 + v302 < v305)
      goto LABEL_298;
    if (v309)
      goto LABEL_298;
    if (v311)
      goto LABEL_298;
    v299 = (v300 & 0xFFFFFFFFFFFFFFFCLL) + (int)v39;
    v313 = (int32x4_t *)(v111 + v302);
    v314 = (int32x4_t *)(v228 + v302);
    v315 = (int8x16_t *)(v229 + v302);
    v316 = vnegq_s32(vdupq_n_s32(v219));
    v317.i64[0] = 0x800000008;
    v317.i64[1] = 0x800000008;
    v318.i64[0] = 0x100000001;
    v318.i64[1] = 0x100000001;
    v319 = v300 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v320 = vshlq_s32(*v313, v316);
      *v314++ = vshrq_n_s32(v320, 3uLL);
      v313->i64[0] = 0;
      v313->i64[1] = 0;
      ++v313;
      *v315++ = vandq_s8((int8x16_t)vcgtq_s32(v317, v320), v318);
      v319 -= 4;
    }
    while (v319);
    if (v300 != (v300 & 0xFFFFFFFFFFFFFFFCLL))
    {
LABEL_298:
      v321 = v213 - v299;
      v322 = 4 * v299;
      v323 = (_DWORD *)(v229 + v322);
      v324 = (int *)(v228 + v322);
      v325 = (int *)(v111 + v322);
      do
      {
        *v324 = *v325 >> v219 >> 3;
        *v325++ = 0;
        v326 = *v324++;
        *v323++ = v326 < 1;
        --v321;
      }
      while (v321);
    }
  }
  return v185;
}

uint64_t opus_repacketizer_cat_impl(uint64_t a1, unsigned __int8 *a2, signed int a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unsigned __int8 v8;
  uint64_t result;
  unsigned int v10;
  int v11;
  BOOL v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  char v20;
  uint64_t v21;
  uint64_t v22;

  if (a3 < 1)
    return 4294967292;
  v21 = v4;
  v22 = v5;
  v7 = *(int *)(a1 + 4);
  if ((_DWORD)v7)
  {
    v8 = *a2;
    if ((*a2 ^ *(_BYTE *)a1) > 3u)
      return 4294967292;
  }
  else
  {
    *(_BYTE *)a1 = *a2;
    v10 = *a2;
    v11 = (v10 >> 3) & 3;
    v12 = v11 == 3;
    v13 = 8000 << v11;
    if (v12)
      v14 = 480;
    else
      v14 = (5243 * (v13 >> 2)) >> 17;
    if ((v10 & 8) != 0)
      v15 = 160;
    else
      v15 = 80;
    if ((~v10 & 0x60) != 0)
      v16 = v14;
    else
      v16 = v15;
    if ((*a2 & 0x80u) != 0)
      v17 = (2622 * (v13 >> 4)) >> 16;
    else
      v17 = v16;
    *(_DWORD *)(a1 + 488) = v17;
    v8 = *a2;
  }
  v18 = v8 & 3;
  if (v18)
  {
    if (v18 != 3)
    {
      v19 = 2;
      if (((int)v7 + 2) * *(_DWORD *)(a1 + 488) > 960)
        return 4294967292;
      goto LABEL_28;
    }
    if (a3 < 2)
      return 4294967292;
    v19 = a2[1] & 0x3F;
    if ((a2[1] & 0x3F) == 0)
      return 4294967292;
  }
  else
  {
    v19 = 1;
  }
  if ((v19 + (int)v7) * *(_DWORD *)(a1 + 488) > 960)
    return 4294967292;
LABEL_28:
  v20 = 0;
  result = opus_packet_parse_impl(a2, a3, a4, &v20, (char **)(a1 + 8 * v7 + 8), (int16x8_t *)(a1 + 2 * v7 + 392), 0, 0);
  if ((int)result >= 1)
  {
    result = 0;
    *(_DWORD *)(a1 + 4) += v19;
  }
  return result;
}

uint64_t opus_repacketizer_out_range_impl(uint64_t a1, unsigned int a2, int a3, _BYTE *a4, uint64_t a5, int a6, int a7)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v13;
  uint64_t v14;
  __int16 *v15;
  char v16;
  int v17;
  int v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  int v22;
  _BYTE *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  BOOL v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  int32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int8x16_t v36;
  uint64_t v37;
  int16x8_t *v38;
  int32x4_t v39;
  int32x4_t v40;
  int16x8_t v41;
  int16x8_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  uint64_t v47;
  __int16 *v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  size_t v54;
  char v55;
  char v56;
  uint64_t v57;
  __int16 *v58;
  int v59;
  int v60;
  int v61;
  uint64_t v62;
  int v64;
  BOOL v65;

  v7 = 0xFFFFFFFFLL;
  if ((a2 & 0x80000000) != 0)
    return v7;
  v8 = a3 - a2;
  if (a3 <= (int)a2 || *(_DWORD *)(a1 + 4) < a3)
    return v7;
  v13 = a1 + 392;
  v14 = a2;
  v15 = (__int16 *)(a1 + 392 + 2 * a2);
  if (!a6)
  {
    v7 = 0;
    if ((_DWORD)v8 != 2)
      goto LABEL_9;
LABEL_13:
    v17 = (unsigned __int16)v15[1];
    v18 = (unsigned __int16)*v15;
    if (v17 != v18)
    {
      v22 = v7 + (__int16)v17 + (__int16)v18;
      if ((__int16)v18 > 251)
        ++v22;
      v7 = (v22 + 2);
      if ((int)v7 > (int)a5)
        return 4294967294;
      *a4 = *(_BYTE *)a1 & 0xFC | 2;
      v23 = a4 + 1;
      v24 = (unsigned __int16)*v15;
      if ((__int16)v24 >= 252)
      {
        a4[2] = (v24 - (v24 | 0xFCu)) >> 2;
        v25 = 2;
        LOBYTE(v24) = v24 | 0xFC;
      }
      else
      {
        v25 = 1;
      }
      *v23 = v24;
      v19 = &v23[v25];
      if (!a7)
        goto LABEL_74;
      goto LABEL_19;
    }
    v7 = (v7 + 2 * (__int16)v18 + 1);
    if ((int)v7 > (int)a5)
      return 4294967294;
    v16 = *(_BYTE *)a1 & 0xFC | 1;
    goto LABEL_16;
  }
  if (v15[(int)v8 - 1] <= 251)
    v7 = 1;
  else
    v7 = 2;
  if ((_DWORD)v8 == 2)
    goto LABEL_13;
LABEL_9:
  if ((_DWORD)v8 == 1)
  {
    v7 = (v7 + *v15 + 1);
    if ((int)v7 > (int)a5)
      return 4294967294;
    v16 = *(_BYTE *)a1 & 0xFC;
LABEL_16:
    *a4 = v16;
    v19 = a4 + 1;
    goto LABEL_18;
  }
  v19 = a4;
  if ((int)v8 > 2)
    goto LABEL_20;
LABEL_18:
  if (!a7)
    goto LABEL_74;
LABEL_19:
  if ((int)v7 < (int)a5)
  {
LABEL_20:
    if (a6)
    {
      if (v15[(int)v8 - 1] <= 251)
        v20 = 3;
      else
        v20 = 4;
      v21 = *v15;
      if ((int)v8 < 2)
        goto LABEL_37;
    }
    else
    {
      v20 = 2;
      v21 = *v15;
      if ((int)v8 < 2)
        goto LABEL_37;
    }
    if ((unsigned __int16)v15[1] == (unsigned __int16)v21)
    {
      v26 = 0;
      while (v8 - 2 != v26)
      {
        v27 = *(unsigned __int16 *)(a1 + 2 * a2 + 396 + 2 * v26++);
        if (v27 != (unsigned __int16)v21)
        {
          v28 = v26 + 1 < v8;
          goto LABEL_40;
        }
      }
LABEL_37:
      v7 = v20 + (_DWORD)v8 * v21;
      if ((int)v7 <= (int)a5)
      {
        v28 = 0;
        *a4 = *(_BYTE *)a1 | 3;
        a4[1] = a3 - a2;
        v29 = a3 - a2;
LABEL_56:
        v19 = a4 + 2;
        v52 = a5 - v7;
        if (a7 && (_DWORD)a5 != (_DWORD)v7)
        {
          a4[1] = v29 | 0x40;
          v53 = (v52 - 1) / 255;
          if (v52 >= 256)
          {
            if (v53 <= 1)
              v54 = 1;
            else
              v54 = v53;
            v64 = v54;
            v65 = v28;
            v55 = v52;
            memset(a4 + 2, 255, v54);
            LOBYTE(v52) = v55;
            v28 = v65;
            v19 = &a4[v64 - 1 + 3];
          }
          *v19++ = v53 + v52 - 1;
          v7 = a5;
        }
        v56 = !v28;
        if ((int)v8 < 2)
          v56 = 1;
        if ((v56 & 1) == 0)
        {
          v57 = (v8 - 1);
          v58 = v15;
          do
          {
            while (1)
            {
              v60 = (unsigned __int16)*v58++;
              v59 = v60;
              if ((__int16)v60 < 252)
                break;
              v19[1] = (v59 - (v59 | 0xFCu)) >> 2;
              *v19 = v59 | 0xFC;
              v19 += 2;
              if (!--v57)
                goto LABEL_74;
            }
            *v19++ = v59;
            --v57;
          }
          while (v57);
        }
        goto LABEL_74;
      }
      return 4294967294;
    }
    v28 = 1;
LABEL_40:
    v30 = v8 - 1;
    if ((int)v8 - 1 <= 1)
      v31 = 1;
    else
      v31 = v30;
    if (v31 >= 0x10)
    {
      v32 = v31 & 0x7FFFFFF0;
      v33 = 0uLL;
      v34 = (int32x4_t)v20;
      v35.i64[0] = 0xFB000000FBLL;
      v35.i64[1] = 0xFB000000FBLL;
      v36.i64[0] = 0x200000002;
      v36.i64[1] = 0x200000002;
      v37 = v32;
      v38 = (int16x8_t *)(a1 + 392 + 2 * a2);
      v39 = 0uLL;
      v40 = 0uLL;
      do
      {
        v41 = *v38;
        v42 = v38[1];
        v38 += 2;
        v43 = (int8x16_t)vcgtq_s32(vmovl_high_s16(v41), v35);
        v44 = (int8x16_t)vcgtq_s32(vmovl_s16(*(int16x4_t *)v41.i8), v35);
        v45 = (int8x16_t)vcgtq_s32(vmovl_high_s16(v42), v35);
        v46 = (int8x16_t)vcgtq_s32(vmovl_s16(*(int16x4_t *)v42.i8), v35);
        v33 = vaddq_s32(vaddw_high_s16(v33, v41), vsubq_s32((int32x4_t)vandq_s8(v43, v36), (int32x4_t)vmvnq_s8(v43)));
        v34 = vaddq_s32(vaddw_s16(v34, *(int16x4_t *)v41.i8), vsubq_s32((int32x4_t)vandq_s8(v44, v36), (int32x4_t)vmvnq_s8(v44)));
        v40 = vaddq_s32(vaddw_high_s16(v40, v42), vsubq_s32((int32x4_t)vandq_s8(v45, v36), (int32x4_t)vmvnq_s8(v45)));
        v39 = vaddq_s32(vaddw_s16(v39, *(int16x4_t *)v42.i8), vsubq_s32((int32x4_t)vandq_s8(v46, v36), (int32x4_t)vmvnq_s8(v46)));
        v37 -= 16;
      }
      while (v37);
      v20 = vaddvq_s32(vaddq_s32(vaddq_s32(v39, v34), vaddq_s32(v40, v33)));
      if (v32 == v31)
        goto LABEL_53;
    }
    else
    {
      v32 = 0;
    }
    v47 = v31 - v32;
    v48 = (__int16 *)(2 * v32 + 2 * a2 + a1 + 392);
    do
    {
      v50 = *v48++;
      v49 = v50;
      if (v50 <= 251)
        v51 = 1;
      else
        v51 = 2;
      v20 += v49 + v51;
      --v47;
    }
    while (v47);
LABEL_53:
    v7 = v20 + v15[v30];
    if ((int)v7 <= (int)a5)
    {
      *a4 = *(_BYTE *)a1 | 3;
      v29 = (a3 - a2) | 0x80;
      a4[1] = v29;
      goto LABEL_56;
    }
    return 4294967294;
  }
LABEL_74:
  if (a6)
  {
    v61 = (unsigned __int16)v15[(int)v8 - 1];
    if ((__int16)v61 >= 252)
    {
      v19[1] = (v61 - (v61 | 0xFCu)) >> 2;
      v62 = 2;
      LOBYTE(v61) = v61 | 0xFC;
    }
    else
    {
      v62 = 1;
    }
    *v19 = v61;
    v19 += v62;
  }
  if ((int)v8 >= 1)
  {
    do
    {
      memmove(v19, *(const void **)(v13 + 8 * v14 - 384), *(__int16 *)(v13 + 2 * v14));
      v19 += *(__int16 *)(v13 + 2 * v14++);
      --v8;
    }
    while (v8);
  }
  if (a7 && v19 < &a4[(int)a5])
    bzero(v19, &a4[(int)a5] - v19);
  return v7;
}

uint64_t opus_packet_pad(char *__src, size_t __len, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  signed int v6;
  uint64_t result;
  char *v9;
  int v10;
  _OWORD v11[31];
  uint64_t v12;
  uint64_t v13;

  if ((int)__len < 1)
    return 0xFFFFFFFFLL;
  v12 = v3;
  v13 = v4;
  v6 = __len;
  if ((_DWORD)__len == (_DWORD)a3)
    return 0;
  if ((int)__len > (int)a3)
    return 0xFFFFFFFFLL;
  v9 = &__src[a3 - __len];
  memset(v11, 0, sizeof(v11));
  memmove(v9, __src, __len);
  result = opus_repacketizer_cat_impl((uint64_t)v11, (unsigned __int8 *)v9, v6, 0);
  if (!(_DWORD)result)
  {
    v10 = opus_repacketizer_out_range_impl((uint64_t)v11, 0, SDWORD1(v11[0]), __src, a3, 0, 1);
    return v10 & (v10 >> 31);
  }
  return result;
}

uint64_t silk_resampler_init(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  char *v4;
  unsigned int v5;
  char v6;
  uint64_t v8;
  int v9;
  int v10;
  unint64_t v11;

  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  if (a4)
  {
    if ((int)a2 <= 15999)
    {
      if (a2 != 8000 && a2 != 12000)
        return 0xFFFFFFFFLL;
    }
    else if (a2 != 16000 && a2 != 48000 && a2 != 24000)
    {
      return 0xFFFFFFFFLL;
    }
    if (a3 != 8000 && a3 != 16000 && a3 != 12000)
      return 0xFFFFFFFFLL;
    v4 = (char *)&delay_matrix_enc + 3 * (((a2 >> 12) - (a2 > 0x3E80)) >> (a2 > 0x5DC0)) + (a3 >> 12) - 4;
  }
  else
  {
    if (a2 != 8000 && a2 != 16000 && a2 != 12000)
      return 0xFFFFFFFFLL;
    if ((int)a3 <= 15999)
    {
      if (a3 != 8000 && a3 != 12000)
        return 0xFFFFFFFFLL;
    }
    else if (a3 != 16000 && a3 != 48000 && a3 != 24000)
    {
      return 0xFFFFFFFFLL;
    }
    v4 = (char *)&delay_matrix_dec + 5 * (a2 >> 12) + (((a3 >> 12) - (a3 > 0x3E80)) >> (a3 > 0x5DC0)) - 6;
  }
  *(_DWORD *)(a1 + 292) = *v4;
  v5 = (unsigned __int16)a2 / 0x3E8u;
  *(_DWORD *)(a1 + 284) = v5;
  *(_DWORD *)(a1 + 288) = (unsigned __int16)a3 / 0x3E8u;
  *(_DWORD *)(a1 + 268) = 10 * v5;
  if (a3 > a2)
  {
    if (a3 == 2 * a2)
    {
      v6 = 0;
      *(_DWORD *)(a1 + 264) = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 264) = 2;
      v6 = 1;
    }
    goto LABEL_33;
  }
  if (a3 >= a2)
  {
    v6 = 0;
    *(_DWORD *)(a1 + 264) = 0;
    goto LABEL_33;
  }
  *(_DWORD *)(a1 + 264) = 3;
  if (4 * a3 == 3 * a2)
  {
    v6 = 0;
    *(_QWORD *)(a1 + 276) = 0x300000012;
    *(_QWORD *)(a1 + 296) = &silk_Resampler_3_4_COEFS;
    goto LABEL_33;
  }
  if (3 * a3 == 2 * a2)
  {
    v6 = 0;
    *(_QWORD *)(a1 + 276) = 0x200000012;
    *(_QWORD *)(a1 + 296) = &silk_Resampler_2_3_COEFS;
    goto LABEL_33;
  }
  if (a2 == 2 * a3)
  {
    v6 = 0;
    *(_QWORD *)(a1 + 276) = 0x100000018;
    *(_QWORD *)(a1 + 296) = &silk_Resampler_1_2_COEFS;
    goto LABEL_33;
  }
  if (3 * a3 == a2)
  {
    v6 = 0;
    *(_QWORD *)(a1 + 276) = 0x100000024;
    *(_QWORD *)(a1 + 296) = &silk_Resampler_1_3_COEFS;
    goto LABEL_33;
  }
  if (4 * a3 == a2)
  {
    v6 = 0;
    *(_QWORD *)(a1 + 276) = 0x100000024;
    *(_QWORD *)(a1 + 296) = &silk_Resampler_1_4_COEFS;
    goto LABEL_33;
  }
  if (6 * a3 != a2)
    return 0xFFFFFFFFLL;
  v6 = 0;
  *(_QWORD *)(a1 + 276) = 0x100000024;
  *(_QWORD *)(a1 + 296) = &silk_Resampler_1_6_COEFS;
LABEL_33:
  v8 = 4 * ((a2 << (v6 | 0xE)) / a3);
  v9 = a2 << v6;
  do
  {
    v10 = v8;
    v11 = (v8 * (unint64_t)a3) >> 16;
    ++v8;
  }
  while (v9 > (int)v11);
  *(_DWORD *)(a1 + 272) = v10;
  return 0;
}

uint64_t silk_resampler(int *a1, _WORD *a2, char *__src, int a4)
{
  uint64_t v8;
  __int16 *v9;
  uint64_t v10;
  int v11;

  v8 = a1[73];
  v9 = (__int16 *)(a1 + 42);
  v10 = a1[71] - (int)v8;
  memcpy((char *)a1 + 2 * v8 + 168, __src, 2 * v10);
  v11 = a1[66];
  switch(v11)
  {
    case 3:
      silk_resampler_private_down_FIR((uint64_t)a1, a2, v9, a1[71]);
      silk_resampler_private_down_FIR((uint64_t)a1, &a2[a1[72]], (__int16 *)&__src[2 * v10], a4 - a1[71]);
      break;
    case 2:
      silk_resampler_private_IIR_FIR((uint64_t)a1, a2, (uint64_t)v9, a1[71]);
      silk_resampler_private_IIR_FIR((uint64_t)a1, &a2[a1[72]], (uint64_t)&__src[2 * v10], a4 - a1[71]);
      break;
    case 1:
      silk_resampler_private_up2_HQ(a1, (uint64_t)a2, v9, a1[71]);
      silk_resampler_private_up2_HQ(a1, (uint64_t)&a2[a1[72]], (__int16 *)&__src[2 * v10], (a4 - a1[71]));
      break;
    default:
      memcpy(a2, v9, 2 * a1[71]);
      memcpy(&a2[a1[72]], &__src[2 * v10], 2 * (a4 - a1[71]));
      break;
  }
  memcpy(v9, &__src[2 * (a4 - a1[73])], 2 * a1[73]);
  return 0;
}

__n128 silk_resampler_down2_3(__n128 *a1, __int16 *a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int32 v7;
  unsigned __int32 v8;
  uint64_t v9;
  signed __int32 v10;
  int v11;
  int *v12;
  int v13;
  __int16 v14;
  __int16 *v15;
  int v16;
  int v17;
  unint64_t v18;
  int v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  __n128 result;
  __n128 v26;
  _QWORD v27[242];

  v27[241] = *MEMORY[0x24BDAC8D0];
  v26 = *a1;
  if (a4 >= 480)
    v4 = 480;
  else
    v4 = a4;
  if (a4 < 1)
    goto LABEL_21;
  while (1)
  {
    v5 = 0;
    v7 = a1[1].n128_u32[0];
    LODWORD(v6) = a1[1].n128_u32[1];
    do
    {
      v8 = v7 + (*(__int16 *)(a3 + 2 * v5) << 8);
      *((_DWORD *)&v26 + v5 + 4) = v8;
      v9 = (int)(4 * v8);
      v7 = v6 + ((unint64_t)(0xFFFFFFFFF513 * v9) >> 16);
      v6 = (unint64_t)(0xFFFFFFFFE695 * v9) >> 16;
      ++v5;
    }
    while (v4 != v5);
    a1[1].n128_u32[0] = v7;
    a1[1].n128_u32[1] = v6;
    if ((int)v4 >= 3)
    {
      v10 = v26.n128_u32[0];
      v11 = v4 + 3;
      v12 = (int *)v27;
      do
      {
        v16 = *(v12 - 3);
        v17 = ((unint64_t)(10739 * v16) >> 16) + ((unint64_t)(4697 * v10) >> 16);
        v18 = (unint64_t)(8276 * *(v12 - 2)) >> 16;
        v10 = *(v12 - 1);
        v19 = v17 + v18 + ((unint64_t)(1567 * v10) >> 16);
        v20 = ((v19 >> 5) + 1) >> 1;
        if (v20 <= -32768)
          LOWORD(v20) = 0x8000;
        if (v19 <= 2097119)
          v21 = v20;
        else
          v21 = 0x7FFF;
        *a2 = v21;
        v22 = v18
            + ((unint64_t)(1567 * v16) >> 16)
            + ((unint64_t)(10739 * v10) >> 16)
            + ((unint64_t)(4697 * *v12) >> 16);
        if (v22 <= 2097119)
        {
          v13 = ((v22 >> 5) + 1) >> 1;
          if (v13 <= -32768)
            v14 = 0x8000;
          else
            v14 = v13;
        }
        else
        {
          v14 = 0x7FFF;
        }
        v15 = a2 + 2;
        a2[1] = v14;
        v12 += 3;
        v11 -= 3;
        a2 += 2;
      }
      while (v11 > 5);
      a2 = v15;
    }
LABEL_21:
    v23 = (int)v4;
    a4 -= v4;
    v24 = 4 * (int)v4;
    if (a4 < 1)
      break;
    a3 += 2 * v23;
    v26 = *(__n128 *)((char *)&v26 + v24);
    if (a4 >= 480)
      v4 = 480;
    else
      v4 = a4;
  }
  result = *(__n128 *)((char *)&v26 + v24);
  *a1 = result;
  return result;
}

void *silk_resampler_private_down_FIR(uint64_t a1, _WORD *a2, __int16 *a3, int a4)
{
  _WORD *v6;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  __int16 *v13;
  __int16 *v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  __int16 *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;
  _DWORD *v29;
  int v30;
  int k;
  int v32;
  int *v33;
  int v34;
  int v35;
  int v36;
  int i;
  int v38;
  int *v39;
  uint64_t v40;
  __int16 *v41;
  __int16 *v42;
  int v43;
  int v44;
  int j;
  int v46;
  int *v47;
  int v48;
  int v49;
  uint64_t v51;
  void *v52;
  char *v53;
  size_t v54;
  uint64_t v55;
  int v56;
  _DWORD *v57;
  uint64_t v58;

  v6 = a2;
  v58 = *MEMORY[0x24BDAC8D0];
  v56 = *(_DWORD *)(a1 + 268);
  v8 = MEMORY[0x24BDAC7A8](a1, a2);
  v10 = (char *)&v51 - v9;
  v55 = v11;
  v12 = 4 * v11;
  v52 = (void *)(v8 + 24);
  memcpy((char *)&v51 - v9, (const void *)(v8 + 24), 4 * v11);
  v13 = *(__int16 **)(a1 + 296);
  v14 = v13 + 2;
  v15 = *(_DWORD *)(a1 + 272);
  v53 = &v10[v12];
  v54 = v12;
  v57 = (_DWORD *)a1;
  v16 = *(_DWORD *)(a1 + 280);
  if (a4 >= v56)
    v17 = v56;
  else
    v17 = a4;
  v18 = v55;
  if ((int)v17 >= 1)
  {
LABEL_5:
    v19 = *v13;
    v20 = v13[1];
    v21 = a3;
    v22 = v53;
    v23 = v17;
    v25 = *v57;
    LODWORD(v24) = v57[1];
    do
    {
      v26 = *v21++;
      v27 = v25 + (v26 << 8);
      *(_DWORD *)v22 = v27;
      v22 += 4;
      v28 = 4 * v27;
      v25 = v24 + ((unint64_t)(v19 * (uint64_t)(4 * v27)) >> 16);
      v24 = (unint64_t)(v20 * (uint64_t)v28) >> 16;
      --v23;
    }
    while (v23);
    v29 = v57;
    *v57 = v25;
    v29[1] = v24;
    goto LABEL_8;
  }
  while (1)
  {
LABEL_8:
    v30 = (_DWORD)v17 << 16;
    if (v18 == 18)
    {
      if (v30 >= 1)
      {
        for (i = 0; i < v30; i += v15)
        {
          while (1)
          {
            v39 = (int *)&v10[4 * (i >> 16)];
            v40 = (uint64_t)((__int16)v16 * (unint64_t)(unsigned __int16)i) >> 16;
            v41 = &v14[9 * (int)v40];
            v42 = &v14[9 * v16 + 9 * ~(_DWORD)v40];
            v43 = ((unint64_t)(v41[1] * (uint64_t)v39[1]) >> 16)
                + ((unint64_t)(*v41 * (uint64_t)*v39) >> 16)
                + ((unint64_t)(v41[2] * (uint64_t)v39[2]) >> 16)
                + ((unint64_t)(v41[3] * (uint64_t)v39[3]) >> 16)
                + ((unint64_t)(v41[4] * (uint64_t)v39[4]) >> 16)
                + ((unint64_t)(v41[5] * (uint64_t)v39[5]) >> 16)
                + ((unint64_t)(v41[6] * (uint64_t)v39[6]) >> 16)
                + ((unint64_t)(v41[7] * (uint64_t)v39[7]) >> 16)
                + ((unint64_t)(v41[8] * (uint64_t)v39[8]) >> 16)
                + ((unint64_t)(*v42 * (uint64_t)v39[17]) >> 16)
                + ((unint64_t)(v42[1] * (uint64_t)v39[16]) >> 16)
                + ((unint64_t)(v42[2] * (uint64_t)v39[15]) >> 16)
                + ((unint64_t)(v42[3] * (uint64_t)v39[14]) >> 16);
            v44 = v43
                + ((unint64_t)(v42[4] * (uint64_t)v39[13]) >> 16)
                + ((unint64_t)(v42[5] * (uint64_t)v39[12]) >> 16)
                + ((unint64_t)(v42[6] * (uint64_t)v39[11]) >> 16)
                + ((unint64_t)(v42[7] * (uint64_t)v39[10]) >> 16)
                + ((unint64_t)(v42[8] * (uint64_t)v39[9]) >> 16);
            if (v44 <= 2097119)
              break;
            *v6++ = 0x7FFF;
            i += v15;
            if (i >= v30)
              goto LABEL_34;
          }
          v38 = ((v44 >> 5) + 1) >> 1;
          if (v38 <= -32768)
            LOWORD(v38) = 0x8000;
          *v6++ = v38;
        }
      }
    }
    else if (v18 == 24)
    {
      if (v30 >= 1)
      {
        for (j = 0; j < v30; j += v15)
        {
          while (1)
          {
            v47 = (int *)&v10[4 * (j >> 16)];
            v48 = ((unint64_t)((v47[22] + (uint64_t)v47[1]) * v13[3]) >> 16)
                + ((unint64_t)((v47[23] + (uint64_t)*v47) * v13[2]) >> 16)
                + ((unint64_t)((v47[21] + (uint64_t)v47[2]) * v13[4]) >> 16)
                + ((unint64_t)((v47[20] + (uint64_t)v47[3]) * v13[5]) >> 16)
                + ((unint64_t)((v47[19] + (uint64_t)v47[4]) * v13[6]) >> 16)
                + ((unint64_t)((v47[18] + (uint64_t)v47[5]) * v13[7]) >> 16)
                + ((unint64_t)((v47[17] + (uint64_t)v47[6]) * v13[8]) >> 16);
            v49 = v48
                + ((unint64_t)((v47[16] + (uint64_t)v47[7]) * v13[9]) >> 16)
                + ((unint64_t)((v47[15] + (uint64_t)v47[8]) * v13[10]) >> 16)
                + ((unint64_t)((v47[14] + (uint64_t)v47[9]) * v13[11]) >> 16)
                + ((unint64_t)((v47[13] + (uint64_t)v47[10]) * v13[12]) >> 16)
                + ((unint64_t)((v47[12] + (uint64_t)v47[11]) * v13[13]) >> 16);
            if (v49 <= 2097119)
              break;
            *v6++ = 0x7FFF;
            j += v15;
            if (j >= v30)
              goto LABEL_34;
          }
          v46 = ((v49 >> 5) + 1) >> 1;
          if (v46 <= -32768)
            LOWORD(v46) = 0x8000;
          *v6++ = v46;
        }
      }
    }
    else if (v18 == 36 && v30 >= 1)
    {
      for (k = 0; k < v30; k += v15)
      {
        while (1)
        {
          v33 = (int *)&v10[4 * (k >> 16)];
          v34 = ((unint64_t)((v33[34] + (uint64_t)v33[1]) * v13[3]) >> 16)
              + ((unint64_t)((v33[35] + (uint64_t)*v33) * v13[2]) >> 16)
              + ((unint64_t)((v33[33] + (uint64_t)v33[2]) * v13[4]) >> 16)
              + ((unint64_t)((v33[32] + (uint64_t)v33[3]) * v13[5]) >> 16)
              + ((unint64_t)((v33[31] + (uint64_t)v33[4]) * v13[6]) >> 16)
              + ((unint64_t)((v33[30] + (uint64_t)v33[5]) * v13[7]) >> 16)
              + ((unint64_t)((v33[29] + (uint64_t)v33[6]) * v13[8]) >> 16);
          v35 = v34
              + ((unint64_t)((v33[28] + (uint64_t)v33[7]) * v13[9]) >> 16)
              + ((unint64_t)((v33[27] + (uint64_t)v33[8]) * v13[10]) >> 16)
              + ((unint64_t)((v33[26] + (uint64_t)v33[9]) * v13[11]) >> 16)
              + ((unint64_t)((v33[25] + (uint64_t)v33[10]) * v13[12]) >> 16)
              + ((unint64_t)((v33[24] + (uint64_t)v33[11]) * v13[13]) >> 16)
              + ((unint64_t)((v33[23] + (uint64_t)v33[12]) * v13[14]) >> 16)
              + ((unint64_t)((v33[22] + (uint64_t)v33[13]) * v13[15]) >> 16)
              + ((unint64_t)((v33[21] + (uint64_t)v33[14]) * v13[16]) >> 16)
              + ((unint64_t)((v33[20] + (uint64_t)v33[15]) * v13[17]) >> 16);
          v36 = v35
              + ((unint64_t)((v33[19] + (uint64_t)v33[16]) * v13[18]) >> 16)
              + ((unint64_t)((v33[18] + (uint64_t)v33[17]) * v13[19]) >> 16);
          if (v36 <= 2097119)
            break;
          *v6++ = 0x7FFF;
          k += v15;
          if (k >= v30)
            goto LABEL_34;
        }
        v32 = ((v36 >> 5) + 1) >> 1;
        if (v32 <= -32768)
          LOWORD(v32) = 0x8000;
        *v6++ = v32;
      }
    }
LABEL_34:
    a4 -= v17;
    if (a4 <= 1)
      return memcpy(v52, &v10[4 * (int)v17], v54);
    a3 += (int)v17;
    memcpy(v10, &v10[4 * (int)v17], v54);
    if (a4 >= v56)
      v17 = v56;
    else
      v17 = a4;
    v18 = v55;
    if ((int)v17 >= 1)
      goto LABEL_5;
  }
}

__n128 silk_resampler_private_IIR_FIR(uint64_t a1, _WORD *a2, uint64_t a3, int a4)
{
  _WORD *v5;
  uint64_t v6;
  __int16 *v7;
  int v8;
  uint64_t v9;
  _OWORD *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  __int16 *v14;
  int v15;
  int v16;
  __int16 *v17;
  int v18;
  int8x16_t v19;
  int v20;
  int v21;
  __n128 result;
  uint64_t v23;
  __n128 *v24;
  uint64_t v25;
  uint64_t v26;

  v5 = a2;
  v26 = *MEMORY[0x24BDAC8D0];
  v6 = MEMORY[0x24BDAC7A8](a1, a2);
  v10 = (_OWORD *)((char *)&v23 - v9);
  *(_OWORD *)((char *)&v23 - v9) = *(_OWORD *)(v6 + 24);
  v11 = *(_DWORD *)(v6 + 272);
  v24 = (__n128 *)(v6 + 24);
  v25 = (uint64_t)&v23 - v9 + 16;
  while (1)
  {
    v12 = a4 >= v8 ? v8 : a4;
    v13 = v6;
    v14 = v7;
    silk_resampler_private_up2_HQ((int *)v6, v25, v7, v12);
    v15 = (_DWORD)v12 << 17;
    if ((int)((_DWORD)v12 << 17) < 1)
    {
      v6 = v13;
      v17 = v14;
    }
    else
    {
      v16 = 0;
      v6 = v13;
      v17 = v14;
      do
      {
        while (1)
        {
          v19 = *(int8x16_t *)((char *)v10 + 2 * (v16 >> 16));
          v20 = vaddvq_s32(vmlal_s16(vmull_s16(silk_resampler_frac_FIR_12[(unsigned __int16)((3 * (unsigned __int16)v16) >> 14)], *(int16x4_t *)v19.i8), vrev64_s16(silk_resampler_frac_FIR_12[11- (unsigned __int16)((3* (unsigned __int16)v16) >> 14)]), (int16x4_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL)));
          if (v20 <= 1073725439)
            break;
          *v5++ = 0x7FFF;
          v16 += v11;
          if (v16 >= v15)
            goto LABEL_14;
        }
        v18 = ((v20 >> 14) + 1) >> 1;
        if (v18 <= -32768)
          LOWORD(v18) = 0x8000;
        *v5++ = v18;
        v16 += v11;
      }
      while (v16 < v15);
    }
LABEL_14:
    a4 -= v12;
    v21 = 2 * v12;
    if (a4 < 1)
      break;
    v7 = &v17[(int)v12];
    *v10 = *(_OWORD *)((char *)v10 + 2 * v21);
    v8 = *(_DWORD *)(v6 + 268);
  }
  result = *(__n128 *)((char *)v10 + 2 * v21);
  *v24 = result;
  return result;
}

int *silk_resampler_private_up2_HQ(int *result, uint64_t a2, __int16 *a3, uint64_t a4)
{
  int v4;
  int v5;
  __int16 *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  int v17;
  int v18;
  int v19;
  unint64_t v20;
  int v21;
  int v22;
  BOOL v23;
  int v24;
  int v25;
  int v26;
  __int16 v27;

  if ((int)a4 >= 1)
  {
    v4 = *result;
    v5 = result[1];
    v6 = (__int16 *)(a2 + 2);
    v8 = result[2];
    v7 = result[3];
    v10 = result[4];
    v9 = result[5];
    a4 = a4;
    do
    {
      v11 = *a3++;
      v12 = (unint64_t)(1746 * ((v11 << 10) - v4)) >> 16;
      v13 = v4 + v12;
      v4 = ((_DWORD)v11 << 10) + v12;
      v14 = (unint64_t)(14986 * (v13 - v5)) >> 16;
      v15 = v5 + v14;
      v5 = v13 + v14;
      v16 = (unint64_t)(6854 * (((_DWORD)v11 << 10) - v7)) >> 16;
      v17 = v15 - v8;
      v18 = v7 + v16;
      v7 = ((_DWORD)v11 << 10) + v16;
      v19 = v15 + ((unint64_t)(0xFFFFFFFF98ABLL * v17) >> 16);
      v20 = (unint64_t)(25769 * (v18 - v10)) >> 16;
      v21 = v10 + v20;
      v10 = v18 + v20;
      v8 = v19 + v17;
      v22 = ((v19 >> 9) + 1) >> 1;
      if (v22 <= -32768)
        LOWORD(v22) = 0x8000;
      v23 = v19 <= 33553919;
      v24 = v21 - v9;
      v25 = v21 + ((unint64_t)(0xFFFFFFFFD8F6 * v24) >> 16);
      if (!v23)
        LOWORD(v22) = 0x7FFF;
      v9 = v25 + v24;
      *(v6 - 1) = v22;
      if (((v25 >> 9) + 1) >> 1 <= -32768)
        LOWORD(v26) = 0x8000;
      else
        v26 = ((v25 >> 9) + 1) >> 1;
      if (v25 <= 33553919)
        v27 = v26;
      else
        v27 = 0x7FFF;
      *v6 = v27;
      v6 += 2;
      --a4;
    }
    while (a4);
    *result = v4;
    result[1] = v5;
    result[2] = v8;
    result[3] = v7;
    result[4] = v10;
    result[5] = v9;
  }
  return result;
}

float silk_residual_energy_FLP(float *a1, unint64_t a2, float *a3, float *a4, int a5, int a6, int a7)
{
  uint64_t v14;
  signed int v15;
  float v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  double v20;
  unsigned int v21;
  double v22;
  unint64_t v23;
  const float *v24;
  uint64_t v25;
  const float *v26;
  float64x2_t v27;
  float64x2_t v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  float *v37;
  double v38;
  float v39;
  float v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  float *v46;
  uint64_t v47;
  float *v48;
  float v49;
  float v50;
  float v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  double v55;
  unsigned int v56;
  double v57;
  unint64_t v58;
  const float *v59;
  uint64_t v60;
  const float *v61;
  float64x2_t v62;
  float64x2_t v63;
  float64x2_t v64;
  float64x2_t v65;
  float64x2_t v66;
  float64x2_t v67;
  float64x2_t v68;
  float64x2_t v69;
  float64x2_t v70;
  float64x2_t v71;
  float *v72;
  double v73;
  float v74;
  float v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  float *v81;
  uint64_t v82;
  float *v83;
  float v84;
  float result;
  float v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  double v90;
  unsigned int v91;
  double v92;
  unint64_t v93;
  const float *v94;
  uint64_t v95;
  const float *v96;
  float64x2_t v97;
  float64x2_t v98;
  float64x2_t v99;
  float64x2_t v100;
  float64x2_t v101;
  float64x2_t v102;
  float64x2_t v103;
  float64x2_t v104;
  float64x2_t v105;
  float64x2_t v106;
  float *v107;
  double v108;
  float v109;
  float v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  float *v116;
  uint64_t v117;
  float *v118;
  float v119;
  float v120;
  float v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  double v125;
  unsigned int v126;
  double v127;
  unint64_t v128;
  const float *v129;
  uint64_t v130;
  const float *v131;
  float64x2_t v132;
  float64x2_t v133;
  float64x2_t v134;
  float64x2_t v135;
  float64x2_t v136;
  float64x2_t v137;
  float64x2_t v138;
  float64x2_t v139;
  float64x2_t v140;
  float64x2_t v141;
  float *v142;
  double v143;
  float v144;
  float v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  float *v152;
  uint64_t v153;
  float *v154;
  float v155;
  float v156[192];
  uint64_t v157;
  float32x2x4_t v158;
  float32x2x4_t v159;
  float32x2x4_t v160;
  float32x2x4_t v161;
  float32x2x4_t v162;
  float32x2x4_t v163;
  float32x2x4_t v164;
  float32x2x4_t v165;

  v157 = *MEMORY[0x24BDAC8D0];
  v14 = a7;
  v15 = 2 * (a7 + a5);
  silk_LPC_analysis_filter_FLP(v156, a3, a2, v15, a7);
  v16 = *a4 * *a4;
  if (a5 >= 4)
  {
    v17 = (a5 - 3);
    v18 = 4;
    if (v17 > 4)
      v18 = (a5 - 3);
    if (v18 >= 0xD)
    {
      v23 = ((v18 - 1) >> 2) + 1;
      v19 = 4 * (v23 & 0x7FFFFFFFFFFFFFFCLL);
      v24 = &v156[v14 + 8];
      v20 = 0.0;
      v25 = v23 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v26 = v24 - 8;
        v158 = vld4_f32(v26);
        v162 = vld4_f32(v24);
        v27 = vcvtq_f64_f32(v158.val[0]);
        v28 = vcvtq_f64_f32(v162.val[0]);
        v29 = vcvtq_f64_f32(v158.val[1]);
        v30 = vcvtq_f64_f32(v162.val[1]);
        v31 = vmlaq_f64(vmulq_f64(v29, v29), v27, v27);
        v32 = vmlaq_f64(vmulq_f64(v30, v30), v28, v28);
        v33 = vcvtq_f64_f32(v158.val[2]);
        v34 = vcvtq_f64_f32(v162.val[2]);
        *(float64x2_t *)v158.val[0].f32 = vcvtq_f64_f32(v158.val[3]);
        *(float64x2_t *)v158.val[1].f32 = vcvtq_f64_f32(v162.val[3]);
        v35 = vmlaq_f64(vmlaq_f64(v31, v33, v33), *(float64x2_t *)v158.val[0].f32, *(float64x2_t *)v158.val[0].f32);
        v36 = vmlaq_f64(vmlaq_f64(v32, v34, v34), *(float64x2_t *)v158.val[1].f32, *(float64x2_t *)v158.val[1].f32);
        v20 = v20 + v35.f64[0] + v35.f64[1] + v36.f64[0] + v36.f64[1];
        v24 += 16;
        v25 -= 4;
      }
      while (v25);
      if (v23 == (v23 & 0x7FFFFFFFFFFFFFFCLL))
      {
LABEL_13:
        v21 = a5 & 0x7FFFFFFC;
        v22 = v16;
        if ((int)(a5 & 0xFFFFFFFC) >= a5)
          goto LABEL_22;
        goto LABEL_14;
      }
    }
    else
    {
      v19 = 0;
      v20 = 0.0;
    }
    v37 = &v156[v19 + 2 + v14];
    do
    {
      v38 = *(v37 - 1) * *(v37 - 1) + *(v37 - 2) * *(v37 - 2);
      v39 = *v37;
      v40 = v37[1];
      v37 += 4;
      v20 = v20 + v38 + v39 * v39 + v40 * v40;
      v19 += 4;
    }
    while (v19 < v17);
    goto LABEL_13;
  }
  v21 = 0;
  v20 = 0.0;
  v22 = v16;
  if (a5 <= 0)
    goto LABEL_22;
LABEL_14:
  v41 = v21;
  v42 = ~v21 + a5;
  if (!(_DWORD)v42)
  {
    v45 = v41;
LABEL_20:
    v48 = &v156[v45 + v14];
    do
    {
      v49 = *v48++;
      v20 = v20 + v49 * v49;
      LODWORD(v45) = v45 + 1;
    }
    while ((int)v45 < a5);
    goto LABEL_22;
  }
  v43 = v42 + 1;
  v44 = (v42 + 1) & 0x1FFFFFFFELL;
  v45 = v44 + v41;
  v46 = &v156[v14 + 1 + v41];
  v47 = v44;
  do
  {
    v20 = v20 + *(v46 - 1) * *(v46 - 1) + *v46 * *v46;
    v46 += 2;
    v47 -= 2;
  }
  while (v47);
  if (v43 != v44)
    goto LABEL_20;
LABEL_22:
  v50 = v20 * v22;
  *a1 = v50;
  v51 = a4[1] * a4[1];
  if (a5 >= 4)
  {
    v52 = (a5 - 3);
    v53 = 4;
    if (v52 > 4)
      v53 = (a5 - 3);
    if (v53 >= 0xD)
    {
      v58 = ((v53 - 1) >> 2) + 1;
      v54 = 4 * (v58 & 0x7FFFFFFFFFFFFFFCLL);
      v59 = &v156[2 * v14 + 8 + a5];
      v55 = 0.0;
      v60 = v58 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v61 = v59 - 8;
        v159 = vld4_f32(v61);
        v163 = vld4_f32(v59);
        v62 = vcvtq_f64_f32(v159.val[0]);
        v63 = vcvtq_f64_f32(v163.val[0]);
        v64 = vcvtq_f64_f32(v159.val[1]);
        v65 = vcvtq_f64_f32(v163.val[1]);
        v66 = vmlaq_f64(vmulq_f64(v64, v64), v62, v62);
        v67 = vmlaq_f64(vmulq_f64(v65, v65), v63, v63);
        v68 = vcvtq_f64_f32(v159.val[2]);
        v69 = vcvtq_f64_f32(v163.val[2]);
        *(float64x2_t *)v159.val[0].f32 = vcvtq_f64_f32(v159.val[3]);
        *(float64x2_t *)v159.val[1].f32 = vcvtq_f64_f32(v163.val[3]);
        v70 = vmlaq_f64(vmlaq_f64(v66, v68, v68), *(float64x2_t *)v159.val[0].f32, *(float64x2_t *)v159.val[0].f32);
        v71 = vmlaq_f64(vmlaq_f64(v67, v69, v69), *(float64x2_t *)v159.val[1].f32, *(float64x2_t *)v159.val[1].f32);
        v55 = v55 + v70.f64[0] + v70.f64[1] + v71.f64[0] + v71.f64[1];
        v59 += 16;
        v60 -= 4;
      }
      while (v60);
      if (v58 == (v58 & 0x7FFFFFFFFFFFFFFCLL))
      {
LABEL_34:
        v56 = a5 & 0x7FFFFFFC;
        v57 = v51;
        if ((int)(a5 & 0xFFFFFFFC) >= a5)
          goto LABEL_43;
        goto LABEL_35;
      }
    }
    else
    {
      v54 = 0;
      v55 = 0.0;
    }
    v72 = &v156[2 * v14 + 2 + v54 + a5];
    do
    {
      v73 = *(v72 - 1) * *(v72 - 1) + *(v72 - 2) * *(v72 - 2);
      v74 = *v72;
      v75 = v72[1];
      v72 += 4;
      v55 = v55 + v73 + v74 * v74 + v75 * v75;
      v54 += 4;
    }
    while (v54 < v52);
    goto LABEL_34;
  }
  v56 = 0;
  v55 = 0.0;
  v57 = v51;
  if (a5 <= 0)
    goto LABEL_43;
LABEL_35:
  v76 = v56;
  v77 = ~v56 + a5;
  if (!(_DWORD)v77)
  {
    v80 = v76;
LABEL_41:
    v83 = &v156[2 * v14 + v80 + a5];
    do
    {
      v84 = *v83++;
      v55 = v55 + v84 * v84;
      LODWORD(v80) = v80 + 1;
    }
    while ((int)v80 < a5);
    goto LABEL_43;
  }
  v78 = v77 + 1;
  v79 = (v77 + 1) & 0x1FFFFFFFELL;
  v80 = v79 + v76;
  v81 = &v156[2 * v14 + 1 + a5 + v76];
  v82 = v79;
  do
  {
    v55 = v55 + *(v81 - 1) * *(v81 - 1) + *v81 * *v81;
    v81 += 2;
    v82 -= 2;
  }
  while (v82);
  if (v78 != v79)
    goto LABEL_41;
LABEL_43:
  result = v55 * v57;
  a1[1] = result;
  if (a6 != 4)
    return result;
  silk_LPC_analysis_filter_FLP(v156, a3 + 16, a2 + 4 * v15, v15, a7);
  v86 = a4[2] * a4[2];
  if (a5 >= 4)
  {
    v87 = (a5 - 3);
    v88 = 4;
    if (v87 > 4)
      v88 = (a5 - 3);
    if (v88 >= 0xD)
    {
      v93 = ((v88 - 1) >> 2) + 1;
      v89 = 4 * (v93 & 0x7FFFFFFFFFFFFFFCLL);
      v94 = &v156[v14 + 8];
      v90 = 0.0;
      v95 = v93 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v96 = v94 - 8;
        v160 = vld4_f32(v96);
        v164 = vld4_f32(v94);
        v97 = vcvtq_f64_f32(v160.val[0]);
        v98 = vcvtq_f64_f32(v164.val[0]);
        v99 = vcvtq_f64_f32(v160.val[1]);
        v100 = vcvtq_f64_f32(v164.val[1]);
        v101 = vmlaq_f64(vmulq_f64(v99, v99), v97, v97);
        v102 = vmlaq_f64(vmulq_f64(v100, v100), v98, v98);
        v103 = vcvtq_f64_f32(v160.val[2]);
        v104 = vcvtq_f64_f32(v164.val[2]);
        *(float64x2_t *)v160.val[0].f32 = vcvtq_f64_f32(v160.val[3]);
        *(float64x2_t *)v160.val[1].f32 = vcvtq_f64_f32(v164.val[3]);
        v105 = vmlaq_f64(vmlaq_f64(v101, v103, v103), *(float64x2_t *)v160.val[0].f32, *(float64x2_t *)v160.val[0].f32);
        v106 = vmlaq_f64(vmlaq_f64(v102, v104, v104), *(float64x2_t *)v160.val[1].f32, *(float64x2_t *)v160.val[1].f32);
        v90 = v90 + v105.f64[0] + v105.f64[1] + v106.f64[0] + v106.f64[1];
        v94 += 16;
        v95 -= 4;
      }
      while (v95);
      if (v93 == (v93 & 0x7FFFFFFFFFFFFFFCLL))
      {
LABEL_56:
        v91 = a5 & 0x7FFFFFFC;
        v92 = v86;
        if ((int)(a5 & 0xFFFFFFFC) >= a5)
          goto LABEL_65;
        goto LABEL_57;
      }
    }
    else
    {
      v89 = 0;
      v90 = 0.0;
    }
    v107 = &v156[v89 + 2 + v14];
    do
    {
      v108 = *(v107 - 1) * *(v107 - 1) + *(v107 - 2) * *(v107 - 2);
      v109 = *v107;
      v110 = v107[1];
      v107 += 4;
      v90 = v90 + v108 + v109 * v109 + v110 * v110;
      v89 += 4;
    }
    while (v89 < v87);
    goto LABEL_56;
  }
  v91 = 0;
  v90 = 0.0;
  v92 = v86;
  if (a5 <= 0)
    goto LABEL_65;
LABEL_57:
  v111 = v91;
  v112 = ~v91 + a5;
  if (!(_DWORD)v112)
  {
    v115 = v111;
LABEL_63:
    v118 = &v156[v115 + v14];
    do
    {
      v119 = *v118++;
      v90 = v90 + v119 * v119;
      LODWORD(v115) = v115 + 1;
    }
    while ((int)v115 < a5);
    goto LABEL_65;
  }
  v113 = v112 + 1;
  v114 = (v112 + 1) & 0x1FFFFFFFELL;
  v115 = v114 + v111;
  v116 = &v156[v14 + 1 + v111];
  v117 = v114;
  do
  {
    v90 = v90 + *(v116 - 1) * *(v116 - 1) + *v116 * *v116;
    v116 += 2;
    v117 -= 2;
  }
  while (v117);
  if (v113 != v114)
    goto LABEL_63;
LABEL_65:
  v120 = v90 * v92;
  a1[2] = v120;
  v121 = a4[3] * a4[3];
  if (a5 >= 4)
  {
    v122 = (a5 - 3);
    v123 = 4;
    if (v122 > 4)
      v123 = (a5 - 3);
    if (v123 >= 0xD)
    {
      v128 = ((v123 - 1) >> 2) + 1;
      v124 = 4 * (v128 & 0x7FFFFFFFFFFFFFFCLL);
      v129 = &v156[2 * v14 + 8 + a5];
      v125 = 0.0;
      v130 = v128 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        v131 = v129 - 8;
        v161 = vld4_f32(v131);
        v165 = vld4_f32(v129);
        v132 = vcvtq_f64_f32(v161.val[0]);
        v133 = vcvtq_f64_f32(v165.val[0]);
        v134 = vcvtq_f64_f32(v161.val[1]);
        v135 = vcvtq_f64_f32(v165.val[1]);
        v136 = vmlaq_f64(vmulq_f64(v134, v134), v132, v132);
        v137 = vmlaq_f64(vmulq_f64(v135, v135), v133, v133);
        v138 = vcvtq_f64_f32(v161.val[2]);
        v139 = vcvtq_f64_f32(v165.val[2]);
        *(float64x2_t *)v161.val[0].f32 = vcvtq_f64_f32(v161.val[3]);
        *(float64x2_t *)v161.val[1].f32 = vcvtq_f64_f32(v165.val[3]);
        v140 = vmlaq_f64(vmlaq_f64(v136, v138, v138), *(float64x2_t *)v161.val[0].f32, *(float64x2_t *)v161.val[0].f32);
        v141 = vmlaq_f64(vmlaq_f64(v137, v139, v139), *(float64x2_t *)v161.val[1].f32, *(float64x2_t *)v161.val[1].f32);
        v125 = v125 + v140.f64[0] + v140.f64[1] + v141.f64[0] + v141.f64[1];
        v129 += 16;
        v130 -= 4;
      }
      while (v130);
      if (v128 == (v128 & 0x7FFFFFFFFFFFFFFCLL))
      {
LABEL_77:
        v126 = a5 & 0x7FFFFFFC;
        v127 = v121;
        if ((int)(a5 & 0xFFFFFFFC) >= a5)
          goto LABEL_86;
        goto LABEL_78;
      }
    }
    else
    {
      v124 = 0;
      v125 = 0.0;
    }
    v142 = &v156[2 * v14 + 2 + v124 + a5];
    do
    {
      v143 = *(v142 - 1) * *(v142 - 1) + *(v142 - 2) * *(v142 - 2);
      v144 = *v142;
      v145 = v142[1];
      v142 += 4;
      v125 = v125 + v143 + v144 * v144 + v145 * v145;
      v124 += 4;
    }
    while (v124 < v122);
    goto LABEL_77;
  }
  v126 = 0;
  v125 = 0.0;
  v127 = v121;
  if (a5 <= 0)
    goto LABEL_86;
LABEL_78:
  v146 = v126;
  v147 = 2 * v14;
  v148 = ~v126 + a5;
  if ((_DWORD)v148)
  {
    v149 = v148 + 1;
    v150 = (v148 + 1) & 0x1FFFFFFFELL;
    v151 = v150 + v146;
    v152 = &v156[a5 + 1 + v146 + v147];
    v153 = v150;
    do
    {
      v125 = v125 + *(v152 - 1) * *(v152 - 1) + *v152 * *v152;
      v152 += 2;
      v153 -= 2;
    }
    while (v153);
    if (v149 == v150)
      goto LABEL_86;
  }
  else
  {
    v151 = v146;
  }
  v154 = &v156[v151 + a5 + v147];
  do
  {
    v155 = *v154++;
    v125 = v125 + v155 * v155;
    LODWORD(v151) = v151 + 1;
  }
  while ((int)v151 < a5);
LABEL_86:
  result = v125 * v127;
  a1[3] = result;
  return result;
}

uint64_t *silk_shell_encoder(uint64_t *result, int *a2)
{
  uint64_t *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;

  v3 = result;
  v4 = a2[1] + *a2;
  v5 = a2[3] + a2[2];
  v6 = a2[5] + a2[4];
  v7 = v5 + v4;
  v12 = a2[7] + a2[6];
  v13 = a2[9] + a2[8];
  v8 = v12 + v6;
  v9 = a2[11] + a2[10] + v13;
  v15 = a2[13] + a2[12];
  v16 = a2[15] + a2[14];
  v10 = v12 + v6 + v5 + v4;
  v14 = a2[11] + a2[10];
  v11 = v16 + v15 + v9;
  if (v11 + v10 >= 1)
    result = ec_enc_icdf(result, v8 + v7, (uint64_t)&silk_shell_code_table3[silk_shell_code_table_offsets[v11 + v10]], 8);
  if (v10 >= 1)
    result = ec_enc_icdf(v3, v5 + v4, (uint64_t)&silk_shell_code_table2[silk_shell_code_table_offsets[v10]], 8);
  if (v7 >= 1)
    result = ec_enc_icdf(v3, v4, (uint64_t)&silk_shell_code_table1[silk_shell_code_table_offsets[v7]], 8);
  if (v4 >= 1)
    result = ec_enc_icdf(v3, *a2, (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v4]], 8);
  if (v5 >= 1)
    result = ec_enc_icdf(v3, a2[2], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v5]], 8);
  if (v8 >= 1)
    result = ec_enc_icdf(v3, v6, (uint64_t)&silk_shell_code_table1[silk_shell_code_table_offsets[v8]], 8);
  if (v6 >= 1)
    result = ec_enc_icdf(v3, a2[4], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v6]], 8);
  if (v12 >= 1)
    result = ec_enc_icdf(v3, a2[6], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v12]], 8);
  if (v11 >= 1)
    result = ec_enc_icdf(v3, v9, (uint64_t)&silk_shell_code_table2[silk_shell_code_table_offsets[v11]], 8);
  if (v9 >= 1)
    result = ec_enc_icdf(v3, v13, (uint64_t)&silk_shell_code_table1[silk_shell_code_table_offsets[v9]], 8);
  if (v13 >= 1)
    result = ec_enc_icdf(v3, a2[8], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v13]], 8);
  if (v14 >= 1)
    result = ec_enc_icdf(v3, a2[10], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v14]], 8);
  if (v16 + v15 >= 1)
    result = ec_enc_icdf(v3, v15, (uint64_t)&silk_shell_code_table1[silk_shell_code_table_offsets[v16 + v15]], 8);
  if (v15 >= 1)
    result = ec_enc_icdf(v3, a2[12], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v15]], 8);
  if (v16 >= 1)
    return ec_enc_icdf(v3, a2[14], (uint64_t)&silk_shell_code_table0[silk_shell_code_table_offsets[v16]], 8);
  return result;
}

